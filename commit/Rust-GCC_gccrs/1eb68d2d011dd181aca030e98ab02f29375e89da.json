{"sha": "1eb68d2d011dd181aca030e98ab02f29375e89da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWViNjhkMmQwMTFkZDE4MWFjYTAzMGU5OGFiMDJmMjkzNzVlODlkYQ==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2014-06-24T13:22:11Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2014-06-24T13:22:11Z"}, "message": "add hash_map class\n\ngcc/\n\n\t* alloc-pool.c (alloc_pool_hash): Use hash_map instead of hash_table.\n\t* dominance.c (iterate_fix_dominators): Use hash_map instead of\n\tpointer_map.\n\t* hash-map.h: New file.\n\t* ipa-comdats.c: Use hash_map instead of pointer_map.\n\t* ipa.c: Likewise.\n\t* lto-section-out.c: Adjust.\n\t* lto-streamer.h: Replace pointer_map with hash_map.\n\t* symtab.c (verify_symtab): Likewise.\n\t* tree-ssa-strlen.c (decl_to_stridxlist_htab): Likewise.\n\t* tree-ssa-uncprop.c (val_ssa_equiv): Likewise.\n\t* tree-streamer.h: Likewise.\n\t* tree-streamer.c: Adjust.\n\t* pointer-set.h: Remove pointer_map.\n\ngcc/lto/\n\n\t* lto.c (canonical_type_hash_cache): Use hash_map instead of\n\tpointer_map.\n\nFrom-SVN: r211938", "tree": {"sha": "e42565bc6a235c9d4d379f34d53a38e7f997cb45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e42565bc6a235c9d4d379f34d53a38e7f997cb45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1eb68d2d011dd181aca030e98ab02f29375e89da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eb68d2d011dd181aca030e98ab02f29375e89da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eb68d2d011dd181aca030e98ab02f29375e89da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eb68d2d011dd181aca030e98ab02f29375e89da/comments", "author": null, "committer": null, "parents": [{"sha": "84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84baa4b968f2dbf4e85e49dba9215ad0f0f3ddc8"}], "stats": {"total": 633, "additions": 325, "deletions": 308}, "files": [{"sha": "fe5d2ffcac9d4b34d247ba935db6d4f30df6261c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1eb68d2d011dd181aca030e98ab02f29375e89da", "patch": "@@ -1,3 +1,20 @@\n+2014-06-24  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* alloc-pool.c (alloc_pool_hash): Use hash_map instead of hash_table.\n+\t* dominance.c (iterate_fix_dominators): Use hash_map instead of\n+\tpointer_map.\n+\t* hash-map.h: New file.\n+\t* ipa-comdats.c: Use hash_map instead of pointer_map.\n+\t* ipa.c: Likewise.\n+\t* lto-section-out.c: Adjust.\n+\t* lto-streamer.h: Replace pointer_map with hash_map.\n+\t* symtab.c (verify_symtab): Likewise.\n+\t* tree-ssa-strlen.c (decl_to_stridxlist_htab): Likewise.\n+\t* tree-ssa-uncprop.c (val_ssa_equiv): Likewise.\n+\t* tree-streamer.h: Likewise.\n+\t* tree-streamer.c: Adjust.\n+\t* pointer-set.h: Remove pointer_map.\n+\n 2014-06-24  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* hash-table.h: Add a template arg to choose between storing values"}, {"sha": "0d3183514744f1e09f3440aa1a5883e2a2f186fb", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 15, "deletions": 47, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=1eb68d2d011dd181aca030e98ab02f29375e89da", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"alloc-pool.h\"\n #include \"hash-table.h\"\n+#include \"hash-map.h\"\n \n #define align_eight(x) (((x+7) >> 3) << 3)\n \n@@ -69,7 +70,6 @@ static ALLOC_POOL_ID_TYPE last_id;\n    size for that pool.  */\n struct alloc_pool_descriptor\n {\n-  const char *name;\n   /* Number of pools allocated.  */\n   unsigned long created;\n   /* Gross allocated storage.  */\n@@ -82,48 +82,17 @@ struct alloc_pool_descriptor\n   int elt_size;\n };\n \n-/* Hashtable helpers.  */\n-struct alloc_pool_hasher : typed_noop_remove <alloc_pool_descriptor>\n-{\n-  typedef alloc_pool_descriptor value_type;\n-  typedef char compare_type;\n-  static inline hashval_t hash (const alloc_pool_descriptor *);\n-  static inline bool equal (const value_type *, const compare_type *);\n-};\n-\n-inline hashval_t\n-alloc_pool_hasher::hash (const value_type *d)\n-{\n-  return htab_hash_pointer (d->name);\n-}\n-\n-inline bool\n-alloc_pool_hasher::equal (const value_type *d,\n-                          const compare_type *p2)\n-{\n-  return d->name == p2;\n-}\n-\n /* Hashtable mapping alloc_pool names to descriptors.  */\n-static hash_table<alloc_pool_hasher> *alloc_pool_hash;\n+static hash_map<const char *, alloc_pool_descriptor> *alloc_pool_hash;\n \n /* For given name, return descriptor, create new if needed.  */\n static struct alloc_pool_descriptor *\n allocate_pool_descriptor (const char *name)\n {\n-  struct alloc_pool_descriptor **slot;\n-\n   if (!alloc_pool_hash)\n-    alloc_pool_hash = new hash_table<alloc_pool_hasher> (10);\n-\n-  slot = alloc_pool_hash->find_slot_with_hash (name,\n-\t\t\t\t\t       htab_hash_pointer (name),\n-\t\t\t\t\t       INSERT);\n-  if (*slot)\n-    return *slot;\n-  *slot = XCNEW (struct alloc_pool_descriptor);\n-  (*slot)->name = name;\n-  return *slot;\n+    alloc_pool_hash = new hash_map<const char *, alloc_pool_descriptor> (10);\n+\n+  return &alloc_pool_hash->get_or_insert (name);\n }\n \n /* Create a pool of things of size SIZE, with NUM in each block we\n@@ -375,23 +344,22 @@ struct output_info\n   unsigned long total_allocated;\n };\n \n-/* Called via hash_table.traverse.  Output alloc_pool descriptor pointed out by\n+/* Called via hash_map.traverse.  Output alloc_pool descriptor pointed out by\n    SLOT and update statistics.  */\n-int\n-print_alloc_pool_statistics (alloc_pool_descriptor **slot,\n+bool\n+print_alloc_pool_statistics (const char *const &name,\n+\t\t\t     const alloc_pool_descriptor &d,\n \t\t\t     struct output_info *i)\n {\n-  struct alloc_pool_descriptor *d = *slot;\n-\n-  if (d->allocated)\n+  if (d.allocated)\n     {\n       fprintf (stderr,\n \t       \"%-22s %6d %10lu %10lu(%10lu) %10lu(%10lu) %10lu(%10lu)\\n\",\n-\t       d->name, d->elt_size, d->created, d->allocated,\n-\t       d->allocated / d->elt_size, d->peak, d->peak / d->elt_size,\n-\t       d->current, d->current / d->elt_size);\n-      i->total_allocated += d->allocated;\n-      i->total_created += d->created;\n+\t       name, d.elt_size, d.created, d.allocated,\n+\t       d.allocated / d.elt_size, d.peak, d.peak / d.elt_size,\n+\t       d.current, d.current / d.elt_size);\n+      i->total_allocated += d.allocated;\n+      i->total_created += d.created;\n     }\n   return 1;\n }"}, {"sha": "be0a43910e60b4aae24723be8f9525df44d8c20e", "filename": "gcc/dominance.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=1eb68d2d011dd181aca030e98ab02f29375e89da", "patch": "@@ -43,6 +43,7 @@\n #include \"diagnostic-core.h\"\n #include \"et-forest.h\"\n #include \"timevar.h\"\n+#include \"hash-map.h\"\n #include \"pointer-set.h\"\n #include \"graphds.h\"\n #include \"bitmap.h\"\n@@ -1258,7 +1259,6 @@ iterate_fix_dominators (enum cdi_direction dir, vec<basic_block> bbs,\n   size_t dom_i;\n   edge e;\n   edge_iterator ei;\n-  pointer_map<int> *map;\n   int *parent, *son, *brother;\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n \n@@ -1346,15 +1346,15 @@ iterate_fix_dominators (enum cdi_direction dir, vec<basic_block> bbs,\n     }\n \n   /* Construct the graph G.  */\n-  map = new pointer_map<int>;\n+  hash_map<basic_block, int> map (251);\n   FOR_EACH_VEC_ELT (bbs, i, bb)\n     {\n       /* If the dominance tree is conservatively correct, split it now.  */\n       if (conservative)\n \tset_immediate_dominator (CDI_DOMINATORS, bb, NULL);\n-      *map->insert (bb) = i;\n+      map.put (bb, i);\n     }\n-  *map->insert (ENTRY_BLOCK_PTR_FOR_FN (cfun)) = n;\n+  map.put (ENTRY_BLOCK_PTR_FOR_FN (cfun), n);\n \n   g = new_graph (n + 1);\n   for (y = 0; y < g->n_vertices; y++)\n@@ -1367,7 +1367,7 @@ iterate_fix_dominators (enum cdi_direction dir, vec<basic_block> bbs,\n \t  if (dom == bb)\n \t    continue;\n \n-\t  dom_i = *map->contains (dom);\n+\t  dom_i = *map.get (dom);\n \n \t  /* Do not include parallel edges to G.  */\n \t  if (!bitmap_set_bit ((bitmap) g->vertices[dom_i].data, i))\n@@ -1378,7 +1378,6 @@ iterate_fix_dominators (enum cdi_direction dir, vec<basic_block> bbs,\n     }\n   for (y = 0; y < g->n_vertices; y++)\n     BITMAP_FREE (g->vertices[y].data);\n-  delete map;\n \n   /* Find the dominator tree of G.  */\n   son = XNEWVEC (int, n + 1);"}, {"sha": "0b50f7242515aa1f10473fde55f552c7cd30f83d", "filename": "gcc/hash-map.h", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Fhash-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Fhash-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-map.h?ref=1eb68d2d011dd181aca030e98ab02f29375e89da", "patch": "@@ -0,0 +1,203 @@\n+/* A type-safe hash map.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+#ifndef hash_map_h\n+#define hash_map_h\n+\n+#include \"hash-table.h\"\n+\n+/* implement default behavior for traits when types allow it.  */\n+\n+struct default_hashmap_traits\n+{\n+  /* Hashes the passed in key.  */\n+\n+  template<typename T>\n+  static hashval_t\n+  hash (T *p)\n+    {\n+      return uintptr_t(p) >> 3;\n+    }\n+\n+  /* The right thing to do here would be using is_integral to only allow\n+     template arguments of integer type, but reimplementing that is a pain, so\n+     we'll just promote everything to [u]int64_t and truncate to hashval_t.  */\n+\n+  static hashval_t hash (uint64_t v) { return v; }\n+  static hashval_t hash (int64_t v) { return v; }\n+\n+  /* Return true if the two keys passed as arguments are equal.  */\n+\n+  template<typename T>\n+  static bool\n+  equal_keys (const T &a, const T &b)\n+    {\n+      return a == b;\n+    }\n+\n+  /* Called to dispose of the key and value before marking the entry as\n+     deleted.  */\n+\n+  template<typename T> static void remove (T &v) { v.~T (); }\n+\n+  /* Mark the passed in entry as being deleted.  */\n+\n+  template<typename T>\n+  static void\n+  mark_deleted (T &e)\n+    {\n+      mark_key_deleted (e.m_key);\n+    }\n+\n+  /* Mark the passed in entry as being empty.  */\n+\n+  template<typename T>\n+  static void\n+  mark_empty (T &e)\n+    {\n+      mark_key_empty (e.m_key);\n+    }\n+\n+  /* Return true if the passed in entry is marked as deleted.  */\n+\n+  template<typename T>\n+  static bool\n+  is_deleted (T &e)\n+    {\n+      return e.m_key == (void *)1;\n+    }\n+\n+  /* Return true if the passed in entry is marked as empty.  */\n+\n+  template<typename T> static bool is_empty (T &e) { return e.m_key == NULL; }\n+\n+private:\n+  template<typename T>\n+  static void\n+  mark_key_deleted (T *&k)\n+    {\n+      k = static_cast<T *> (1);\n+    }\n+\n+  template<typename T>\n+  static void\n+  mark_key_empty (T *&k)\n+    {\n+      k = static_cast<T *> (0);\n+    }\n+};\n+\n+template<typename Key, typename Value,\n+\t typename Traits = default_hashmap_traits>\n+class hash_map\n+{\n+  struct hash_entry\n+  {\n+    Key m_key;\n+    Value m_value;\n+\n+    typedef hash_entry value_type;\n+    typedef Key compare_type;\n+    typedef int store_values_directly;\n+\n+    static hashval_t hash (const hash_entry &e)\n+      {\n+       \treturn Traits::hash (e.m_key);\n+      }\n+\n+    static bool equal (const hash_entry &a, const Key &b)\n+       \t{\n+\t  return Traits::equal_keys (a.m_key, b);\n+       \t}\n+\n+    static void remove (hash_entry &e) { Traits::remove (e); }\n+\n+    static void mark_deleted (hash_entry &e) { Traits::mark_deleted (e); }\n+\n+    static bool is_deleted (const hash_entry &e)\n+      {\n+       \treturn Traits::is_deleted (e);\n+      }\n+\n+    static void mark_empty (hash_entry &e) { Traits::mark_empty (e); }\n+    static bool is_empty (const hash_entry &e) { return Traits::is_empty (e); }\n+  };\n+\n+public:\n+  explicit hash_map (size_t n = 13) : m_table (n) {}\n+\n+  /* If key k isn't already in the map add key k with value v to the map, and\n+     return false.  Otherwise set the value of the entry for key k to be v and\n+     return true.  */\n+\n+  bool put (const Key &k, const Value &v)\n+    {\n+      hash_entry *e = m_table.find_slot_with_hash (k, Traits::hash (k),\n+\t\t\t\t\t\t   INSERT);\n+      bool existed = !hash_entry::is_empty (*e);\n+      if (!existed)\n+\te->m_key = k;\n+\n+      e->m_value = v;\n+      return existed;\n+    }\n+\n+  /* if the passed in key is in the map return its value otherwise NULL.  */\n+\n+  Value *get (const Key &k)\n+    {\n+      hash_entry &e = m_table.find_with_hash (k, Traits::hash (k));\n+      return Traits::is_empty (e) ? NULL : &e.m_value;\n+    }\n+\n+  /* Return a reference to the value for the passed in key, creating the entry\n+     if it doesn't already exist.  If existed is not NULL then it is set to false\n+     if the key was not previously in the map, and true otherwise.  */\n+\n+  Value &get_or_insert (const Key &k, bool *existed = NULL)\n+    {\n+      hash_entry *e = m_table.find_slot_with_hash (k, Traits::hash (k),\n+\t\t\t\t\t\t   INSERT);\n+      bool ins = Traits::is_empty (*e);\n+      if (ins)\n+\te->m_key = k;\n+\n+      if (existed != NULL)\n+\t*existed = !ins;\n+\n+      return e->m_value;\n+    }\n+\n+  /* Call the call back on each pair of key and value with the passed in\n+     arg.  */\n+\n+  template<typename Arg, bool (*f)(const Key &, const Value &, Arg)>\n+  void traverse (Arg a) const\n+    {\n+      for (typename hash_table<hash_entry>::iterator iter = m_table.begin ();\n+\t   iter != m_table.end (); ++iter)\n+\tf ((*iter).m_key, (*iter).m_value, a);\n+    }\n+\n+private:\n+  hash_table<hash_entry> m_table;\n+};\n+\n+#endif"}, {"sha": "b1bc35e9392c859f31b13066df4e93c1f225630f", "filename": "gcc/ipa-comdats.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Fipa-comdats.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Fipa-comdats.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-comdats.c?ref=1eb68d2d011dd181aca030e98ab02f29375e89da", "patch": "@@ -55,7 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"cgraph.h\"\n #include \"tree-pass.h\"\n-#include \"pointer-set.h\"\n+#include \"hash-map.h\"\n \n /* Main dataflow loop propagating comdat groups across\n    the symbol table.  All references to SYMBOL are examined\n@@ -64,7 +64,7 @@ along with GCC; see the file COPYING3.  If not see\n \n tree\n propagate_comdat_group (struct symtab_node *symbol,\n-\t\t\ttree newgroup, pointer_map <tree> &map)\n+\t\t\ttree newgroup, hash_map<symtab_node *, tree> &map)\n {\n   int i;\n   struct ipa_ref *ref;\n@@ -105,7 +105,7 @@ propagate_comdat_group (struct symtab_node *symbol,\n \n       /* The actual merge operation.  */\n \n-      tree *val2 = map.contains (symbol2);\n+      tree *val2 = map.get (symbol2);\n \n       if (val2 && *val2 != newgroup)\n \t{\n@@ -138,7 +138,7 @@ propagate_comdat_group (struct symtab_node *symbol,\n \n         /* The actual merge operation.  */\n \n-\ttree *val2 = map.contains (symbol2);\n+\ttree *val2 = map.get (symbol2);\n \n \tif (val2 && *val2 != newgroup)\n \t  {\n@@ -213,8 +213,8 @@ set_comdat_group (symtab_node *symbol,\n static unsigned int\n ipa_comdats (void)\n {\n-  pointer_map<tree> map;\n-  pointer_map<symtab_node *> comdat_head_map;\n+  hash_map<symtab_node *, tree> map (251);\n+  hash_map<tree, symtab_node *> comdat_head_map (251);\n   symtab_node *symbol;\n   bool comdat_group_seen = false;\n   symtab_node *first = (symtab_node *) (void *) 1;\n@@ -229,8 +229,8 @@ ipa_comdats (void)\n       ;\n     else if ((group = symbol->get_comdat_group ()) != NULL)\n       {\n-        *map.insert (symbol) = group;\n-        *comdat_head_map.insert (group) = symbol;\n+        map.put (symbol, group);\n+        comdat_head_map.put (group, symbol);\n \tcomdat_group_seen = true;\n \n \t/* Mark the symbol so we won't waste time visiting it for dataflow.  */\n@@ -248,7 +248,7 @@ ipa_comdats (void)\n \t\t && (DECL_STATIC_CONSTRUCTOR (symbol->decl)\n \t\t     || DECL_STATIC_DESTRUCTOR (symbol->decl))))\n       {\n-\t*map.insert (symtab_alias_ultimate_target (symbol, NULL)) = error_mark_node;\n+\tmap.put (symtab_alias_ultimate_target (symbol, NULL), error_mark_node);\n \n \t/* Mark the symbol so we won't waste time visiting it for dataflow.  */\n \tsymbol->aux = (symtab_node *) (void *) 1;\n@@ -278,7 +278,7 @@ ipa_comdats (void)\n       first = (symtab_node *)first->aux;\n \n       /* Get current lattice value of SYMBOL.  */\n-      val = map.contains (symbol);\n+      val = map.get (symbol);\n       if (val)\n \tgroup = *val;\n \n@@ -301,7 +301,7 @@ ipa_comdats (void)\n       if (val)\n \t*val = newgroup;\n       else\n-\t*map.insert (symbol) = newgroup;\n+\tmap.put (symbol, newgroup);\n       enqueue_references (&first, symbol);\n \n       /* We may need to revisit the symbol unless it is BOTTOM.  */\n@@ -318,7 +318,7 @@ ipa_comdats (void)\n \t  && !symbol->alias\n \t  && symtab_real_symbol_p (symbol))\n \t{\n-\t  tree group = *map.contains (symbol);\n+\t  tree group = *map.get (symbol);\n \n \t  if (group == error_mark_node)\n \t    continue;\n@@ -329,7 +329,7 @@ ipa_comdats (void)\n \t      fprintf (dump_file, \"To group: %s\\n\", IDENTIFIER_POINTER (group));\n \t    }\n \t  symtab_for_node_and_aliases (symbol, set_comdat_group,\n-\t\t\t\t       *comdat_head_map.contains (group), true);\n+\t\t\t\t       *comdat_head_map.get (group), true);\n \t}\n     }\n   return 0;"}, {"sha": "04f2c79ae331182a638e5cc5b3bc8915d5ea7689", "filename": "gcc/ipa.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=1eb68d2d011dd181aca030e98ab02f29375e89da", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"cgraph.h\"\n #include \"tree-pass.h\"\n+#include \"hash-map.h\"\n #include \"pointer-set.h\"\n #include \"gimple-expr.h\"\n #include \"gimplify.h\"\n@@ -1113,14 +1114,14 @@ make_pass_ipa_cdtor_merge (gcc::context *ctxt)\n \n cgraph_node *\n meet (cgraph_node *function, varpool_node *var,\n-       pointer_map<cgraph_node *> &single_user_map)\n+       hash_map<varpool_node *, cgraph_node *> &single_user_map)\n {\n   struct cgraph_node *user, **f;\n \n   if (var->aux == BOTTOM)\n     return BOTTOM;\n \n-  f = single_user_map.contains (var);\n+  f = single_user_map.get (var);\n   if (!f)\n     return function;\n   user = *f;\n@@ -1139,7 +1140,7 @@ meet (cgraph_node *function, varpool_node *var,\n \n cgraph_node *\n propagate_single_user (varpool_node *vnode, cgraph_node *function,\n-\t\t       pointer_map<cgraph_node *> &single_user_map)\n+\t\t       hash_map<varpool_node *, cgraph_node *> &single_user_map)\n {\n   int i;\n   struct ipa_ref *ref;\n@@ -1180,7 +1181,7 @@ ipa_single_use (void)\n {\n   varpool_node *first = (varpool_node *) (void *) 1;\n   varpool_node *var;\n-  pointer_map<cgraph_node *> single_user_map;\n+  hash_map<varpool_node *, cgraph_node *> single_user_map;\n \n   FOR_EACH_DEFINED_VARIABLE (var)\n     if (!varpool_all_refs_explicit_p (var))\n@@ -1201,7 +1202,7 @@ ipa_single_use (void)\n       var = first;\n       first = (varpool_node *)first->aux;\n \n-      f = single_user_map.contains (var);\n+      f = single_user_map.get (var);\n       if (f)\n \torig_user = *f;\n       else\n@@ -1216,7 +1217,7 @@ ipa_single_use (void)\n \t  unsigned int i;\n \t  ipa_ref *ref;\n \n-\t  *single_user_map.insert (var) = user;\n+\t  single_user_map.put (var, user);\n \n \t  /* Enqueue all aliases for re-processing.  */\n \t  for (i = 0;\n@@ -1253,8 +1254,8 @@ ipa_single_use (void)\n       if (var->aux != BOTTOM)\n \t{\n #ifdef ENABLE_CHECKING\n-\t  if (!single_user_map.contains (var))\n-          gcc_assert (single_user_map.contains (var));\n+\t  if (!single_user_map.get (var))\n+          gcc_assert (single_user_map.get (var));\n #endif\n \t  if (dump_file)\n \t    {"}, {"sha": "00b18016a833ed0185484629587f8a6666fb05d8", "filename": "gcc/lto-section-out.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Flto-section-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Flto-section-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-out.c?ref=1eb68d2d011dd181aca030e98ab02f29375e89da", "patch": "@@ -224,21 +224,17 @@ lto_output_decl_index (struct lto_output_stream *obs,\n \t\t       struct lto_tree_ref_encoder *encoder,\n \t\t       tree name, unsigned int *this_index)\n {\n-  unsigned *slot;\n-  unsigned int index;\n   bool new_entry_p = FALSE;\n   bool existed_p;\n \n-  slot = encoder->tree_hash_table->insert (name, &existed_p);\n+  unsigned int &index\n+    = encoder->tree_hash_table->get_or_insert (name, &existed_p);\n   if (!existed_p)\n     {\n       index = encoder->trees.length ();\n-      *slot = index;\n       encoder->trees.safe_push (name);\n       new_entry_p = TRUE;\n     }\n-  else\n-    index = *slot;\n \n   if (obs)\n     streamer_write_uhwi_stream (obs, index);"}, {"sha": "566a0e0b3593b4edaff851b844eb6b0f75567619", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=1eb68d2d011dd181aca030e98ab02f29375e89da", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"plugin-api.h\"\n #include \"hash-table.h\"\n+#include \"hash-map.h\"\n #include \"target.h\"\n #include \"cgraph.h\"\n #include \"vec.h\"\n@@ -472,7 +473,7 @@ struct GTY(()) lto_tree_ref_table\n \n struct lto_tree_ref_encoder\n {\n-  pointer_map<unsigned> *tree_hash_table;\t/* Maps pointers to indices. */\n+  hash_map<tree, unsigned> *tree_hash_table;\t/* Maps pointers to indices. */\n   vec<tree> trees;\t\t\t/* Maps indices to pointers. */\n };\n \n@@ -994,7 +995,7 @@ lto_tag_check_range (enum LTO_tags actual, enum LTO_tags tag1,\n static inline void\n lto_init_tree_ref_encoder (struct lto_tree_ref_encoder *encoder)\n {\n-  encoder->tree_hash_table = new pointer_map<unsigned>;\n+  encoder->tree_hash_table = new hash_map<tree, unsigned> (251);\n   encoder->trees.create (0);\n }\n \n@@ -1005,8 +1006,8 @@ static inline void\n lto_destroy_tree_ref_encoder (struct lto_tree_ref_encoder *encoder)\n {\n   /* Hash table may be delete already.  */\n-  if (encoder->tree_hash_table)\n-    delete encoder->tree_hash_table;\n+  delete encoder->tree_hash_table;\n+  encoder->tree_hash_table = NULL;\n   encoder->trees.release ();\n }\n "}, {"sha": "83a684e07a57a3fb88c18ec6f4a6cefa66eb9bc8", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=1eb68d2d011dd181aca030e98ab02f29375e89da", "patch": "@@ -1,3 +1,8 @@\n+2014-06-24  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* lto.c (canonical_type_hash_cache): Use hash_map instead of\n+\tpointer_map.\n+\n 2014-06-24  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* lto.c: Adjust."}, {"sha": "5c4acc5e469ed0109a258ced4a626c68c2a7076a", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=1eb68d2d011dd181aca030e98ab02f29375e89da", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"langhooks.h\"\n #include \"bitmap.h\"\n+#include \"hash-map.h\"\n #include \"ipa-prop.h\"\n #include \"common.h\"\n #include \"debug.h\"\n@@ -261,7 +262,7 @@ lto_read_in_decl_state (struct data_in *data_in, const uint32_t *data,\n \n /* Global canonical type table.  */\n static htab_t gimple_canonical_types;\n-static pointer_map <hashval_t> *canonical_type_hash_cache;\n+static hash_map<const_tree, hashval_t> *canonical_type_hash_cache;\n static unsigned long num_canonical_type_hash_entries;\n static unsigned long num_canonical_type_hash_queries;\n \n@@ -405,8 +406,7 @@ static hashval_t\n gimple_canonical_type_hash (const void *p)\n {\n   num_canonical_type_hash_queries++;\n-  hashval_t *slot\n-    = canonical_type_hash_cache->contains (CONST_CAST_TREE ((const_tree) p));\n+  hashval_t *slot = canonical_type_hash_cache->get ((const_tree) p);\n   gcc_assert (slot != NULL);\n   return *slot;\n }\n@@ -648,10 +648,8 @@ gimple_register_canonical_type_1 (tree t, hashval_t hash)\n       *slot = (void *) t;\n       /* Cache the just computed hash value.  */\n       num_canonical_type_hash_entries++;\n-      bool existed_p;\n-      hashval_t *hslot = canonical_type_hash_cache->insert (t, &existed_p);\n+      bool existed_p = canonical_type_hash_cache->put (t, hash);\n       gcc_assert (!existed_p);\n-      *hslot = hash;\n     }\n }\n \n@@ -2917,7 +2915,7 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n     }\n   cgraph_state = CGRAPH_LTO_STREAMING;\n \n-  canonical_type_hash_cache = new pointer_map <hashval_t>;\n+  canonical_type_hash_cache = new hash_map<const_tree, hashval_t> (251);\n   gimple_canonical_types = htab_create_ggc (16381, gimple_canonical_type_hash,\n \t\t\t\t\t    gimple_canonical_type_eq, 0);\n   gcc_obstack_init (&tree_scc_hash_obstack);"}, {"sha": "fc5921218721f899edeb7bb32cd3c1b79f316e99", "filename": "gcc/pointer-set.h", "status": "modified", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Fpointer-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Fpointer-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-set.h?ref=1eb68d2d011dd181aca030e98ab02f29375e89da", "patch": "@@ -45,117 +45,6 @@ void pointer_set_traverse (const struct pointer_set_t *,\n \t\t\t   void *);\n bool pointer_set_lookup (const pointer_set_t *, const void *, size_t *);\n \n-/* A pointer map is represented the same way as a pointer_set, so\n-   the hash code is based on the address of the key, rather than\n-   its contents.  Null keys are a reserved value.  Deletion is not\n-   supported (yet).  There is no mechanism for user control of hash\n-   function, equality comparison, initial size, or resizing policy.  */\n-\n-template <typename T>\n-class pointer_map : protected pointer_set_t\n-{\n-  T *values;\n-\n-public:\n-  pointer_map ();\n-  ~pointer_map ();\n-  T *contains (const void *p);\n-  T *insert (const void *p, bool *existed_p = NULL);\n-  void traverse (bool (*fn) (const void *, T *, void *), void *data);\n-};\n-\n-/* Allocate an empty pointer map.  */\n-template <typename T>\n-pointer_map<T>::pointer_map (void)\n-{\n-  n_elements = 0;\n-  log_slots = 8;\n-  n_slots = (size_t) 1 << log_slots;\n-\n-  slots = XCNEWVEC (const void *, n_slots);\n-  values = XNEWVEC (T, n_slots);\n-}\n-\n-/* Reclaims all memory associated with PMAP.  */\n-template <typename T>\n-pointer_map<T>::~pointer_map (void)\n-{\n-  XDELETEVEC (slots);\n-  XDELETEVEC (values);\n-}\n-\n-/* Returns a pointer to the value to which P maps, if PMAP contains P.  P\n-   must be nonnull.  Return NULL if PMAP does not contain P.\n-\n-   Collisions are resolved by linear probing.  */\n-template <typename T>\n-T *\n-pointer_map<T>::contains (const void *p)\n-{\n-  size_t n;\n-  if (!pointer_set_lookup (this, p, &n))\n-    return NULL;\n-  return &values[n];\n-}\n-\n-/* Inserts P into PMAP if it wasn't already there.  Returns a pointer\n-   to the value.  P must be nonnull.  */\n-template <typename T>\n-T *\n-pointer_map<T>::insert (const void *p, bool *existed_p)\n-{\n-  size_t n;\n-\n-  /* For simplicity, expand the map even if P is already there.  This can be\n-     superfluous but can happen at most once.  */\n-  /* ???  Fugly that we have to inline that here.  */\n-  if (n_elements > n_slots / 4)\n-    {\n-      size_t old_n_slots = n_slots;\n-      const void **old_keys = slots;\n-      T *old_values = values;\n-      log_slots = log_slots + 1;\n-      n_slots = n_slots * 2;\n-      slots = XCNEWVEC (const void *, n_slots);\n-      values = XNEWVEC (T, n_slots);\n-      for (size_t i = 0; i < old_n_slots; ++i)\n-\tif (old_keys[i])\n-\t  {\n-\t    const void *key = old_keys[i];\n-\t    pointer_set_lookup (this, key, &n);\n-\t    slots[n] = key;\n-\t    values[n] = old_values[i];\n-\t  }\n-      XDELETEVEC (old_keys);\n-      XDELETEVEC (old_values);\n-    }\n-\n-  if (!pointer_set_lookup (this, p, &n))\n-    {\n-      ++n_elements;\n-      slots[n] = p;\n-      if (existed_p)\n-\t*existed_p = false;\n-    }\n-  else if (existed_p)\n-    *existed_p = true;\n-\n-  return &values[n];\n-}\n-\n-/* Pass each pointer in PMAP to the function in FN, together with the pointer\n-   to the value and the fixed parameter DATA.  If FN returns false, the\n-   iteration stops.  */\n-\n-template <class T>\n-void\n-pointer_map<T>::traverse (bool (*fn) (const void *, T *, void *), void *data)\n-{\n-  for (size_t i = 0; i < n_slots; ++i)\n-    if (slots[i] && !fn (slots[i], &values[i], data))\n-      break;\n-}\n-\n \n struct pointer_map_t;\n pointer_map_t *pointer_map_create (void);"}, {"sha": "6e521154fa8fd646b4550bfc74c647c776445404", "filename": "gcc/symtab.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=1eb68d2d011dd181aca030e98ab02f29375e89da", "patch": "@@ -895,7 +895,7 @@ DEBUG_FUNCTION void\n verify_symtab (void)\n {\n   symtab_node *node;\n-  pointer_map<symtab_node *> comdat_head_map;\n+  hash_map<tree, symtab_node *> comdat_head_map (251);\n \n   FOR_EACH_SYMBOL (node)\n     {\n@@ -905,7 +905,8 @@ verify_symtab (void)\n \t  symtab_node **entry, *s;\n \t  bool existed;\n \n-\t  entry = comdat_head_map.insert (node->get_comdat_group (), &existed);\n+\t  entry = &comdat_head_map.get_or_insert (node->get_comdat_group (),\n+\t\t\t\t\t\t  &existed);\n \t  if (!existed)\n \t    *entry = node;\n \t  else"}, {"sha": "dc659c93dd54a27b463f2262e849b2ab417b02e2", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 16, "deletions": 36, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=1eb68d2d011dd181aca030e98ab02f29375e89da", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"stor-layout.h\"\n #include \"hash-table.h\"\n+#include \"hash-map.h\"\n #include \"bitmap.h\"\n #include \"basic-block.h\"\n #include \"tree-ssa-alias.h\"\n@@ -134,31 +135,23 @@ struct decl_stridxlist_map\n \n /* stridxlist hashtable helpers.  */\n \n-struct stridxlist_hasher : typed_noop_remove <decl_stridxlist_map>\n+struct stridxlist_hash_traits : default_hashmap_traits\n {\n-  typedef decl_stridxlist_map value_type;\n-  typedef decl_stridxlist_map compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  static inline hashval_t hash (tree);\n };\n \n /* Hash a from tree in a decl_stridxlist_map.  */\n \n inline hashval_t\n-stridxlist_hasher::hash (const value_type *item)\n+stridxlist_hash_traits::hash (tree item)\n {\n-  return DECL_UID (item->base.from);\n-}\n-\n-inline bool\n-stridxlist_hasher::equal (const value_type *v, const compare_type *c)\n-{\n-  return tree_map_base_eq (&v->base, &c->base);\n+  return DECL_UID (item);\n }\n \n /* Hash table for mapping decls to a chained list of offset -> idx\n    mappings.  */\n-static hash_table<stridxlist_hasher> *decl_to_stridxlist_htab;\n+static hash_map<tree, stridxlist, stridxlist_hash_traits>\n+  *decl_to_stridxlist_htab;\n \n /* Obstack for struct stridxlist and struct decl_stridxlist_map.  */\n static struct obstack stridx_obstack;\n@@ -179,7 +172,6 @@ static int\n get_addr_stridx (tree exp)\n {\n   HOST_WIDE_INT off;\n-  struct decl_stridxlist_map ent, *e;\n   struct stridxlist *list;\n   tree base;\n \n@@ -190,12 +182,10 @@ get_addr_stridx (tree exp)\n   if (base == NULL || !DECL_P (base))\n     return 0;\n \n-  ent.base.from = base;\n-  e = decl_to_stridxlist_htab->find_with_hash (&ent, DECL_UID (base));\n-  if (e == NULL)\n+  list = decl_to_stridxlist_htab->get (base);\n+  if (list == NULL)\n     return 0;\n \n-  list = &e->list;\n   do\n     {\n       if (list->offset == off)\n@@ -270,9 +260,6 @@ unshare_strinfo_vec (void)\n static int *\n addr_stridxptr (tree exp)\n {\n-  decl_stridxlist_map **slot;\n-  struct decl_stridxlist_map ent;\n-  struct stridxlist *list;\n   HOST_WIDE_INT off;\n \n   tree base = get_addr_base_and_unit_offset (exp, &off);\n@@ -281,16 +268,16 @@ addr_stridxptr (tree exp)\n \n   if (!decl_to_stridxlist_htab)\n     {\n-      decl_to_stridxlist_htab = new hash_table<stridxlist_hasher> (64);\n+      decl_to_stridxlist_htab\n+       \t= new hash_map<tree, stridxlist, stridxlist_hash_traits> (64);\n       gcc_obstack_init (&stridx_obstack);\n     }\n-  ent.base.from = base;\n-  slot = decl_to_stridxlist_htab->find_slot_with_hash (&ent, DECL_UID (base),\n-\t\t\t\t\t\t       INSERT);\n-  if (*slot)\n+\n+  bool existed;\n+  stridxlist *list = &decl_to_stridxlist_htab->get_or_insert (base, &existed);\n+  if (existed)\n     {\n       int i;\n-      list = &(*slot)->list;\n       for (i = 0; i < 16; i++)\n \t{\n \t  if (list->offset == off)\n@@ -303,14 +290,7 @@ addr_stridxptr (tree exp)\n       list->next = XOBNEW (&stridx_obstack, struct stridxlist);\n       list = list->next;\n     }\n-  else\n-    {\n-      struct decl_stridxlist_map *e\n-\t= XOBNEW (&stridx_obstack, struct decl_stridxlist_map);\n-      e->base.from = base;\n-      *slot = e;\n-      list = &e->list;\n-    }\n+\n   list->next = NULL;\n   list->offset = off;\n   list->idx = 0;"}, {"sha": "5c928b4f9e01ab8587c52548f72e5cce8a1577ab", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 19, "deletions": 56, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=1eb68d2d011dd181aca030e98ab02f29375e89da", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"basic-block.h\"\n #include \"function.h\"\n #include \"hash-table.h\"\n+#include \"hash-map.h\"\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\"\n #include \"gimple-expr.h\"\n@@ -284,44 +285,38 @@ struct equiv_hash_elt\n \n /* Value to ssa name equivalence hashtable helpers.  */\n \n-struct val_ssa_equiv_hasher\n+struct val_ssa_equiv_hash_traits : default_hashmap_traits\n {\n-  typedef equiv_hash_elt value_type;\n-  typedef equiv_hash_elt compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n-  static inline void remove (value_type *);\n+  static inline hashval_t hash (tree);\n+  static inline bool equal_keys (tree, tree);\n+  template<typename T> static inline void remove (T &);\n };\n \n inline hashval_t\n-val_ssa_equiv_hasher::hash (const value_type *p)\n+val_ssa_equiv_hash_traits::hash (tree value)\n {\n-  tree const value = p->value;\n   return iterative_hash_expr (value, 0);\n }\n \n inline bool\n-val_ssa_equiv_hasher::equal (const value_type *p1, const compare_type *p2)\n+val_ssa_equiv_hash_traits::equal_keys (tree value1, tree value2)\n {\n-  tree value1 = p1->value;\n-  tree value2 = p2->value;\n-\n   return operand_equal_p (value1, value2, 0);\n }\n \n /* Free an instance of equiv_hash_elt.  */\n \n+template<typename T>\n inline void\n-val_ssa_equiv_hasher::remove (value_type *elt)\n+val_ssa_equiv_hash_traits::remove (T &elt)\n {\n-  elt->equivalences.release ();\n-  free (elt);\n+  elt.m_value.release ();\n }\n \n /* Global hash table implementing a mapping from invariant values\n    to a list of SSA_NAMEs which have the same value.  We might be\n    able to reuse tree-vn for this code.  */\n-static hash_table<val_ssa_equiv_hasher> *val_ssa_equiv;\n+static hash_map<tree, vec<tree>, val_ssa_equiv_hash_traits> *val_ssa_equiv;\n \n static void uncprop_into_successor_phis (basic_block);\n \n@@ -330,40 +325,15 @@ static void uncprop_into_successor_phis (basic_block);\n static void\n remove_equivalence (tree value)\n {\n-  struct equiv_hash_elt an_equiv_elt, *an_equiv_elt_p;\n-  equiv_hash_elt **slot;\n-\n-  an_equiv_elt.value = value;\n-  an_equiv_elt.equivalences.create (0);\n-\n-  slot = val_ssa_equiv->find_slot (&an_equiv_elt, NO_INSERT);\n-\n-  an_equiv_elt_p = *slot;\n-  an_equiv_elt_p->equivalences.pop ();\n+    val_ssa_equiv->get (value)->pop ();\n }\n \n /* Record EQUIVALENCE = VALUE into our hash table.  */\n \n static void\n record_equiv (tree value, tree equivalence)\n {\n-  equiv_hash_elt *an_equiv_elt_p;\n-  equiv_hash_elt **slot;\n-\n-  an_equiv_elt_p = XNEW (struct equiv_hash_elt);\n-  an_equiv_elt_p->value = value;\n-  an_equiv_elt_p->equivalences.create (0);\n-\n-  slot = val_ssa_equiv->find_slot (an_equiv_elt_p, INSERT);\n-\n-  if (*slot == NULL)\n-    *slot = an_equiv_elt_p;\n-  else\n-     free (an_equiv_elt_p);\n-\n-  an_equiv_elt_p = *slot;\n-\n-  an_equiv_elt_p->equivalences.safe_push (equivalence);\n+  val_ssa_equiv->get_or_insert (value).safe_push (equivalence);\n }\n \n class uncprop_dom_walker : public dom_walker\n@@ -433,8 +403,6 @@ uncprop_into_successor_phis (basic_block bb)\n \t  gimple phi = gsi_stmt (gsi);\n \t  tree arg = PHI_ARG_DEF (phi, e->dest_idx);\n \t  tree res = PHI_RESULT (phi);\n-\t  equiv_hash_elt an_equiv_elt;\n-\t  equiv_hash_elt **slot;\n \n \t  /* If the argument is not an invariant and can be potentially\n \t     coalesced with the result, then there's no point in\n@@ -444,23 +412,17 @@ uncprop_into_successor_phis (basic_block bb)\n \t    continue;\n \n \t  /* Lookup this argument's value in the hash table.  */\n-\t  an_equiv_elt.value = arg;\n-\t  an_equiv_elt.equivalences.create (0);\n-\t  slot = val_ssa_equiv->find_slot (&an_equiv_elt, NO_INSERT);\n-\n-\t  if (slot)\n+\t  vec<tree> *equivalences = val_ssa_equiv->get (arg);\n+\t  if (equivalences)\n \t    {\n-\t      struct equiv_hash_elt *elt = *slot;\n-\t      int j;\n-\n \t      /* Walk every equivalence with the same value.  If we find\n \t\t one that can potentially coalesce with the PHI rsult,\n \t\t then replace the value in the argument with its equivalent\n \t\t SSA_NAME.  Use the most recent equivalence as hopefully\n \t\t that results in shortest lifetimes.  */\n-\t      for (j = elt->equivalences.length () - 1; j >= 0; j--)\n+\t      for (int j = equivalences->length () - 1; j >= 0; j--)\n \t\t{\n-\t\t  tree equiv = elt->equivalences[j];\n+\t\t  tree equiv = (*equivalences)[j];\n \n \t\t  if (gimple_can_coalesce_p (equiv, res))\n \t\t    {\n@@ -578,7 +540,8 @@ pass_uncprop::execute (function *fun)\n   associate_equivalences_with_edges ();\n \n   /* Create our global data structures.  */\n-  val_ssa_equiv = new hash_table<val_ssa_equiv_hasher> (1024);\n+  val_ssa_equiv\n+    = new hash_map<tree, vec<tree>, val_ssa_equiv_hash_traits> (1024);\n \n   /* We're going to do a dominator walk, so ensure that we have\n      dominance information.  */"}, {"sha": "17f304506ae713cb9d1306ff8227f9d2e8a8d52e", "filename": "gcc/tree-streamer.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Ftree-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Ftree-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer.c?ref=1eb68d2d011dd181aca030e98ab02f29375e89da", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\"\n #include \"gimple-expr.h\"\n+#include \"hash-map.h\"\n #include \"is-a.h\"\n #include \"gimple.h\"\n #include \"streamer-hooks.h\"\n@@ -134,36 +135,30 @@ streamer_tree_cache_insert_1 (struct streamer_tree_cache_d *cache,\n \t\t\t      tree t, hashval_t hash, unsigned *ix_p,\n \t\t\t      bool insert_at_next_slot_p)\n {\n-  unsigned *slot;\n-  unsigned ix;\n   bool existed_p;\n \n   gcc_assert (t);\n \n-  slot = cache->node_map->insert (t, &existed_p);\n+  unsigned int &ix = cache->node_map->get_or_insert (t, &existed_p);\n   if (!existed_p)\n     {\n       /* Determine the next slot to use in the cache.  */\n       if (insert_at_next_slot_p)\n \tix = cache->next_idx++;\n       else\n \tix = *ix_p;\n-       *slot = ix;\n \n       streamer_tree_cache_add_to_node_array (cache, ix, t, hash);\n     }\n   else\n     {\n-      ix = *slot;\n-\n       if (!insert_at_next_slot_p && ix != *ix_p)\n \t{\n \t  /* If the caller wants to insert T at a specific slot\n \t     location, and ENTRY->TO does not match *IX_P, add T to\n \t     the requested location slot.  */\n \t  ix = *ix_p;\n \t  streamer_tree_cache_add_to_node_array (cache, ix, t, hash);\n-\t  *slot = ix;\n \t}\n     }\n \n@@ -231,7 +226,7 @@ streamer_tree_cache_lookup (struct streamer_tree_cache_d *cache, tree t,\n \n   gcc_assert (t);\n \n-  slot = cache->node_map->contains (t);\n+  slot = cache->node_map->get (t);\n   if (slot == NULL)\n     {\n       retval = false;\n@@ -332,7 +327,7 @@ streamer_tree_cache_create (bool with_hashes, bool with_map, bool with_vec)\n   cache = XCNEW (struct streamer_tree_cache_d);\n \n   if (with_map)\n-    cache->node_map = new pointer_map<unsigned>;\n+    cache->node_map = new hash_map<tree, unsigned> (251);\n   cache->next_idx = 0;\n   if (with_vec)\n     cache->nodes.create (165);\n@@ -356,8 +351,8 @@ streamer_tree_cache_delete (struct streamer_tree_cache_d *c)\n   if (c == NULL)\n     return;\n \n-  if (c->node_map)\n-    delete c->node_map;\n+  delete c->node_map;\n+  c->node_map = NULL;\n   c->nodes.release ();\n   c->hashes.release ();\n   free (c);"}, {"sha": "ddd366a92df6f65fdc5abe3ba70a6a48cdc9afac", "filename": "gcc/tree-streamer.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Ftree-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb68d2d011dd181aca030e98ab02f29375e89da/gcc%2Ftree-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer.h?ref=1eb68d2d011dd181aca030e98ab02f29375e89da", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"streamer-hooks.h\"\n #include \"lto-streamer.h\"\n+#include \"hash-map.h\"\n \n /* Cache of pickled nodes.  Used to avoid writing the same node more\n    than once.  The first time a tree node is streamed out, it is\n@@ -46,7 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n struct streamer_tree_cache_d\n {\n   /* The mapping between tree nodes and slots into the nodes array.  */\n-  pointer_map<unsigned> *node_map;\n+  hash_map<tree, unsigned> *node_map;\n \n   /* The nodes pickled so far.  */\n   vec<tree> nodes;"}]}