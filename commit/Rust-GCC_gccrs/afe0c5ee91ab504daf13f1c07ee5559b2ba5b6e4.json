{"sha": "afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZlMGM1ZWU5MWFiNTA0ZGFmMTNmMWMwN2VlNTU1OWIyYmE1YjZlNA==", "commit": {"author": {"name": "Rong Xu", "email": "xur@gcc.gnu.org", "date": "2014-10-07T04:02:31Z"}, "committer": {"name": "Rong Xu", "email": "xur@gcc.gnu.org", "date": "2014-10-07T04:02:31Z"}, "message": "Makefile.in: Fix dependence.\n\n2014-10-06  Rong Xu  <xur@google.com>\n\n\t* gcc/Makefile.in: Fix dependence.\n\t* gcc/gcov-counter.def (GCOV_COUNTER_ICALL_TOPNV): Add\n        indirect call topn profiler.\n\t* gcc/gcov-io.h: Ditto.\n\t* libgcc/Makefile.in: Ditto.\n\t* libgcc/libgcov-driver.c (gcov_sort_n_vals): New utility function.\n\t(gcov_sort_icall_topn_counter): Ditto.\n\t(gcov_sort_topn_counter_arrays): Ditto.\n\t(dump_one_gcov): Sort indirect_call topn counters.\n\t* libgcc/libgcov-merge.c (__gcov_merge_icall_topn): New merge\n        function.\n\t* libgcc/libgcov-profiler.c (__gcov_topn_value_profiler_body): New\n        utility function.\n\t(__gcov_indirect_call_topn_profiler): New profiler function.\n\t* libgcc/libgcov-util.c (__gcov_icall_topn_counter_op): New.\n\t* libgcc/libgcov.h: New decls.\n\nFrom-SVN: r215962", "tree": {"sha": "d43837c0db3f96bc2d979153fab89e2f3767ac1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d43837c0db3f96bc2d979153fab89e2f3767ac1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/comments", "author": null, "committer": null, "parents": [{"sha": "c5b0abd3ef7a0d1311b63783435ddf15bbe507fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5b0abd3ef7a0d1311b63783435ddf15bbe507fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5b0abd3ef7a0d1311b63783435ddf15bbe507fa"}], "stats": {"total": 326, "additions": 322, "deletions": 4}, "files": [{"sha": "e4c791fb872a896d109029ac2e6d424ec98081ac", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4", "patch": "@@ -2574,7 +2574,7 @@ gcov-dump$(exeext): $(GCOV_DUMP_OBJS) $(LIBDEPS)\n \n GCOV_TOOL_DEP_FILES = $(srcdir)/../libgcc/libgcov-util.c gcov-io.c $(GCOV_IO_H) \\\n   $(srcdir)/../libgcc/libgcov-driver.c $(srcdir)/../libgcc/libgcov-driver-system.c \\\n-  $(srcdir)/../libgcc/libgcov-merge.c \\\n+  $(srcdir)/../libgcc/libgcov-merge.c $(srcdir)/../libgcc/libgcov.h \\\n   $(SYSTEM_H) coretypes.h $(TM_H) $(CONFIG_H) version.h intl.h $(DIAGNOSTIC_H)\n libgcov-util.o: $(srcdir)/../libgcc/libgcov-util.c $(GCOV_TOOL_DEP_FILES)\n \t+$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -o $@ $<"}, {"sha": "b1831eabce4212a84a99cf80b51cada7d394c9f5", "filename": "gcc/gcov-counter.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/gcc%2Fgcov-counter.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/gcc%2Fgcov-counter.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-counter.def?ref=afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4", "patch": "@@ -52,3 +52,6 @@ DEF_GCOV_COUNTER(GCOV_COUNTER_IOR, \"ior\", _ior)\n \n /* Time profile collecting first run of a function */\n DEF_GCOV_COUNTER(GCOV_TIME_PROFILER, \"time_profiler\", _time_profile)\n+\n+/* Top N value tracking for indirect calls.  */\n+DEF_GCOV_COUNTER(GCOV_COUNTER_ICALL_TOPNV, \"indirect_call_topn\", _icall_topn)"}, {"sha": "6fc126851b430a7da847cd96e6ca6847a0dc8c4d", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4", "patch": "@@ -270,6 +270,12 @@ GCOV_COUNTERS\n #define GCOV_N_VALUE_COUNTERS \\\n   (GCOV_LAST_VALUE_COUNTER - GCOV_FIRST_VALUE_COUNTER + 1)\n \n+/* The number of hottest callees to be tracked.  */\n+#define GCOV_ICALL_TOPN_VAL  2\n+\n+/* The number of counter entries per icall callsite.  */\n+#define GCOV_ICALL_TOPN_NCOUNTS (1 + GCOV_ICALL_TOPN_VAL * 4)\n+\n /* Convert a counter index to a tag.  */\n #define GCOV_TAG_FOR_COUNTER(COUNT)\t\t\t\t\\\n \t(GCOV_TAG_COUNTER_BASE + ((gcov_unsigned_t)(COUNT) << 17))"}, {"sha": "4008a859349ffdd35239acc851a0363a694aee3a", "filename": "libgcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/libgcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/libgcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FMakefile.in?ref=afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4", "patch": "@@ -855,11 +855,12 @@ include $(iterator)\n # Build libgcov components.\n \n LIBGCOV_MERGE = _gcov_merge_add _gcov_merge_single _gcov_merge_delta\t\\\n-\t_gcov_merge_ior _gcov_merge_time_profile\n+\t_gcov_merge_ior _gcov_merge_time_profile _gcov_merge_icall_topn\n LIBGCOV_PROFILER = _gcov_interval_profiler _gcov_pow2_profiler\t\t\\\n \t_gcov_one_value_profiler _gcov_indirect_call_profiler\t\t\\\n  \t_gcov_average_profiler _gcov_ior_profiler\t\t\t\\\n-\t_gcov_indirect_call_profiler_v2 _gcov_time_profiler\n+\t_gcov_indirect_call_profiler_v2 _gcov_time_profiler\t\t\\\n+\t_gcov_indirect_call_topn_profiler\n LIBGCOV_INTERFACE = _gcov_dump _gcov_flush _gcov_fork\t\t\t\\\n \t_gcov_execl _gcov_execlp\t\t\t\t\t\\\n \t_gcov_execle _gcov_execv _gcov_execvp _gcov_execve _gcov_reset"}, {"sha": "754584de7ce0af2567ff662f2c8001d73520a067", "filename": "libgcc/libgcov-driver.c", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/libgcc%2Flibgcov-driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/libgcc%2Flibgcov-driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-driver.c?ref=afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4", "patch": "@@ -665,6 +665,85 @@ merge_summary (const char *filename, int run_counted,\n   return 0;\n }\n \n+\n+/* Sort N entries in VALUE_ARRAY in descending order.\n+   Each entry in VALUE_ARRAY has two values. The sorting\n+   is based on the second value.  */\n+\n+GCOV_LINKAGE  void\n+gcov_sort_n_vals (gcov_type *value_array, int n)\n+{\n+  int j, k;\n+\n+  for (j = 2; j < n; j += 2)\n+    {\n+      gcov_type cur_ent[2];\n+\n+      cur_ent[0] = value_array[j];\n+      cur_ent[1] = value_array[j + 1];\n+      k = j - 2;\n+      while (k >= 0 && value_array[k + 1] < cur_ent[1])\n+        {\n+          value_array[k + 2] = value_array[k];\n+          value_array[k + 3] = value_array[k+1];\n+          k -= 2;\n+        }\n+      value_array[k + 2] = cur_ent[0];\n+      value_array[k + 3] = cur_ent[1];\n+    }\n+}\n+\n+/* Sort the profile counters for all indirect call sites. Counters\n+   for each call site are allocated in array COUNTERS.  */\n+\n+static void\n+gcov_sort_icall_topn_counter (const struct gcov_ctr_info *counters)\n+{\n+  int i;\n+  gcov_type *values;\n+  int n = counters->num;\n+\n+  gcc_assert (!(n % GCOV_ICALL_TOPN_NCOUNTS));\n+  values = counters->values;\n+\n+  for (i = 0; i < n; i += GCOV_ICALL_TOPN_NCOUNTS)\n+    {\n+      gcov_type *value_array = &values[i + 1];\n+      gcov_sort_n_vals (value_array, GCOV_ICALL_TOPN_NCOUNTS - 1);\n+    }\n+}\n+\n+/* Sort topn indirect_call profile counters in GI_PTR.  */\n+\n+static void\n+gcov_sort_topn_counter_arrays (const struct gcov_info *gi_ptr)\n+{\n+  unsigned int i;\n+  int f_ix;\n+  const struct gcov_fn_info *gfi_ptr;\n+  const struct gcov_ctr_info *ci_ptr;\n+\n+  if (!gi_ptr->merge[GCOV_COUNTER_ICALL_TOPNV]) \n+    return;\n+\n+  for (f_ix = 0; (unsigned)f_ix != gi_ptr->n_functions; f_ix++)\n+    {\n+      gfi_ptr = gi_ptr->functions[f_ix];\n+      ci_ptr = gfi_ptr->ctrs;\n+      for (i = 0; i < GCOV_COUNTERS; i++)\n+        {\n+          if (!gi_ptr->merge[i])\n+            continue;\n+          if (i == GCOV_COUNTER_ICALL_TOPNV)\n+            {\n+              gcov_sort_icall_topn_counter (ci_ptr);\n+              break;\n+            }\n+          ci_ptr++;\n+        }\n+    }\n+}\n+\n /* Dump the coverage counts for one gcov_info object. We merge with existing\n    counts when possible, to avoid growing the .da files ad infinitum. We use\n    this program's checksum to make sure we only accumulate whole program\n@@ -687,6 +766,8 @@ dump_one_gcov (struct gcov_info *gi_ptr, struct gcov_filename *gf,\n   fn_buffer = 0;\n   sum_buffer = 0;\n \n+  gcov_sort_topn_counter_arrays (gi_ptr);\n+\n   error = gcov_exit_open_gcda_file (gi_ptr, gf);\n   if (error == -1)\n     return;"}, {"sha": "5ed4793a926699811fbb0c96c63efc62f4a50ed4", "filename": "libgcc/libgcov-merge.c", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/libgcc%2Flibgcov-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/libgcc%2Flibgcov-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-merge.c?ref=afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4", "patch": "@@ -166,4 +166,67 @@ __gcov_merge_delta (gcov_type *counters, unsigned n_counters)\n     }\n }\n #endif /* L_gcov_merge_delta */\n+\n+#ifdef L_gcov_merge_icall_topn\n+/* The profile merging function used for merging indirect call counts\n+   This function is given array COUNTERS of N_COUNTERS old counters and it\n+   reads the same number of counters from the gcov file.  */\n+\n+void\n+__gcov_merge_icall_topn (gcov_type *counters, unsigned n_counters)\n+{\n+  unsigned i, j, k, m;\n+\n+  gcc_assert (!(n_counters % GCOV_ICALL_TOPN_NCOUNTS));\n+  for (i = 0; i < n_counters; i += GCOV_ICALL_TOPN_NCOUNTS)\n+    {\n+      gcov_type *value_array = &counters[i + 1];\n+      unsigned tmp_size = 2 * (GCOV_ICALL_TOPN_NCOUNTS - 1);\n+      gcov_type *tmp_array \n+          = (gcov_type *) alloca (tmp_size * sizeof (gcov_type));\n+\n+      for (j = 0; j < tmp_size; j++)\n+        tmp_array[j] = 0;\n+\n+      for (j = 0; j < GCOV_ICALL_TOPN_NCOUNTS - 1; j += 2)\n+        {\n+          tmp_array[j] = value_array[j];\n+          tmp_array[j + 1] = value_array [j + 1];\n+        }\n+\n+      /* Skip the number_of_eviction entry.  */\n+      gcov_get_counter ();\n+      for (k = 0; k < GCOV_ICALL_TOPN_NCOUNTS - 1; k += 2)\n+        {\n+          int found = 0;\n+          gcov_type global_id = gcov_get_counter_target ();\n+          gcov_type call_count = gcov_get_counter ();\n+          for (m = 0; m < j; m += 2)\n+            {\n+              if (tmp_array[m] == global_id)\n+                {\n+                  found = 1;\n+                  tmp_array[m + 1] += call_count;\n+                  break;\n+                }\n+            }\n+          if (!found)\n+            {\n+              tmp_array[j] = global_id;\n+              tmp_array[j + 1] = call_count;\n+              j += 2;\n+            }\n+        }\n+      /* Now sort the temp array */\n+      gcov_sort_n_vals (tmp_array, j);\n+\n+      /* Now copy back the top half of the temp array */\n+      for (k = 0; k < GCOV_ICALL_TOPN_NCOUNTS - 1; k += 2)\n+        {\n+          value_array[k] = tmp_array[k];\n+          value_array[k + 1] = tmp_array[k + 1];\n+        }\n+    }\n+}\n+#endif /* L_gcov_merge_icall_topn */\n #endif /* inhibit_libc */"}, {"sha": "98f1ae9cb5f7dda55dca23d67d2007a9c2e4d2f7", "filename": "libgcc/libgcov-profiler.c", "status": "modified", "additions": 139, "deletions": 1, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/libgcc%2Flibgcov-profiler.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/libgcc%2Flibgcov-profiler.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-profiler.c?ref=afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4", "patch": "@@ -93,6 +93,144 @@ __gcov_one_value_profiler (gcov_type *counters, gcov_type value)\n }\n #endif\n \n+#ifdef L_gcov_indirect_call_topn_profiler\n+/* Tries to keep track the most frequent N values in the counters where\n+   N is specified by parameter TOPN_VAL. To track top N values, 2*N counter\n+   entries are used.\n+   counter[0] --- the accumative count of the number of times one entry in\n+                  in the counters gets evicted/replaced due to limited capacity.\n+                  When this value reaches a threshold, the bottom N values are\n+                  cleared.\n+   counter[1] through counter[2*N] records the top 2*N values collected so far.\n+   Each value is represented by two entries: count[2*i+1] is the ith value, and\n+   count[2*i+2] is the number of times the value is seen.  */\n+\n+static void\n+__gcov_topn_value_profiler_body (gcov_type *counters, gcov_type value)\n+{\n+   unsigned i, found = 0, have_zero_count = 0;\n+   gcov_type *entry;\n+   gcov_type *lfu_entry = &counters[1];\n+   gcov_type *value_array = &counters[1];\n+   gcov_type *num_eviction = &counters[0];\n+   gcov_unsigned_t topn_val = GCOV_ICALL_TOPN_VAL;\n+\n+   /* There are 2*topn_val values tracked, each value takes two slots in the\n+      counter array.  */\n+   for (i = 0; i < (topn_val << 2); i += 2)\n+     {\n+       entry = &value_array[i];\n+       if (entry[0] == value)\n+         {\n+           entry[1]++ ;\n+           found = 1;\n+           break;\n+         }\n+       else if (entry[1] == 0)\n+         {\n+           lfu_entry = entry;\n+           have_zero_count = 1;\n+         }\n+      else if (entry[1] < lfu_entry[1])\n+        lfu_entry = entry;\n+     }\n+\n+   if (found)\n+     return;\n+\n+   /* lfu_entry is either an empty entry or an entry\n+      with lowest count, which will be evicted.  */\n+   lfu_entry[0] = value;\n+   lfu_entry[1] = 1;\n+\n+#define GCOV_ICALL_COUNTER_CLEAR_THRESHOLD 3000\n+\n+   /* Too many evictions -- time to clear bottom entries to\n+      avoid hot values bumping each other out.  */\n+   if (!have_zero_count\n+       && ++*num_eviction >= GCOV_ICALL_COUNTER_CLEAR_THRESHOLD)\n+     {\n+       unsigned i, j;\n+       gcov_type *p, minv;\n+       gcov_type* tmp_cnts\n+           = (gcov_type *)alloca (topn_val * sizeof (gcov_type));\n+\n+       *num_eviction = 0;\n+\n+       for (i = 0; i < topn_val; i++)\n+         tmp_cnts[i] = 0;\n+\n+       /* Find the largest topn_val values from the group of\n+          2*topn_val values and put them into tmp_cnts.  */\n+\n+       for (i = 0; i < 2 * topn_val; i += 2)\n+         {\n+           p = 0;\n+           for (j = 0; j < topn_val; j++)\n+             {\n+               if (!p || tmp_cnts[j] < *p)\n+                  p = &tmp_cnts[j];\n+             }\n+            if (value_array[i + 1] > *p)\n+              *p = value_array[i + 1];\n+         }\n+\n+       minv = tmp_cnts[0];\n+       for (j = 1; j < topn_val; j++)\n+         {\n+           if (tmp_cnts[j] < minv)\n+             minv = tmp_cnts[j];\n+         }\n+       /* Zero out low value entries.  */\n+       for (i = 0; i < 2 * topn_val; i += 2)\n+         {\n+           if (value_array[i + 1] < minv)\n+             {\n+               value_array[i] = 0;\n+               value_array[i + 1] = 0;\n+             }\n+         }\n+     }\n+}\n+\n+/* These two variables are used to actually track caller and callee.  Keep\n+   them in TLS memory so races are not common (they are written to often).\n+   The variables are set directly by GCC instrumented code, so declaration\n+   here must match one in tree-profile.c.  */\n+\n+#if defined(HAVE_CC_TLS) && !defined (USE_EMUTLS)\n+__thread\n+#endif\n+gcov_type *__gcov_indirect_call_topn_counters ATTRIBUTE_HIDDEN;\n+\n+#if defined(HAVE_CC_TLS) && !defined (USE_EMUTLS)\n+__thread\n+#endif\n+void *__gcov_indirect_call_topn_callee ATTRIBUTE_HIDDEN;\n+\n+#ifdef TARGET_VTABLE_USES_DESCRIPTORS\n+#define VTABLE_USES_DESCRIPTORS 1\n+#else\n+#define VTABLE_USES_DESCRIPTORS 0\n+#endif\n+\n+/* This fucntion is instrumented at function entry to track topn indirect\n+   calls to CUR_FUNC.  */\n+ \n+void\n+__gcov_indirect_call_topn_profiler (gcov_type value, void* cur_func)\n+{\n+  void *callee_func = __gcov_indirect_call_topn_callee;\n+  /* If the C++ virtual tables contain function descriptors then one\n+     function may have multiple descriptors and we need to dereference\n+     the descriptors to see if they point to the same function.  */\n+  if (cur_func == callee_func\n+      || (VTABLE_USES_DESCRIPTORS && callee_func\n+\t  && *(void **) cur_func == *(void **) callee_func))\n+    __gcov_topn_value_profiler_body (__gcov_indirect_call_topn_counters, value);\n+}\n+#endif\n+\n #ifdef L_gcov_indirect_call_profiler\n /* This function exist only for workaround of binutils bug 14342.\n    Once this compatibility hack is obsolette, it can be removed.  */\n@@ -118,8 +256,8 @@ __gcov_indirect_call_profiler (gcov_type* counter, gcov_type value,\n           && *(void **) cur_func == *(void **) callee_func))\n     __gcov_one_value_profiler_body (counter, value);\n }\n-\n #endif\n+\n #ifdef L_gcov_indirect_call_profiler_v2\n \n /* These two variables are used to actually track caller and callee.  Keep"}, {"sha": "38d434ae954b51686d2d58432694680a58ba2cde", "filename": "libgcc/libgcov-util.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/libgcc%2Flibgcov-util.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/libgcc%2Flibgcov-util.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-util.c?ref=afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4", "patch": "@@ -746,6 +746,25 @@ __gcov_single_counter_op (gcov_type *counters, unsigned n_counters,\n     }\n }\n \n+/* Performing FN upon indirect-call profile counters.  */\n+\n+static void\n+__gcov_icall_topn_counter_op (gcov_type *counters, unsigned n_counters,\n+                              counter_op_fn fn, void *data1, void *data2)\n+{\n+  unsigned i;\n+\n+  gcc_assert (!(n_counters % GCOV_ICALL_TOPN_NCOUNTS));\n+  for (i = 0; i < n_counters; i += GCOV_ICALL_TOPN_NCOUNTS)\n+    {\n+      unsigned j;\n+      gcov_type *value_array = &counters[i + 1];\n+\n+      for (j = 0; j < GCOV_ICALL_TOPN_NCOUNTS - 1; j += 2)\n+        value_array[j + 1] = fn (value_array[j + 1], data1, data2);\n+    }\n+}\n+\n /* Scaling the counter value V by multiplying *(float*) DATA1.  */\n \n static gcov_type"}, {"sha": "78300632a19dff7db0e3b7752b4189b92cceac3a", "filename": "libgcc/libgcov.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/libgcc%2Flibgcov.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4/libgcc%2Flibgcov.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov.h?ref=afe0c5ee91ab504daf13f1c07ee5559b2ba5b6e4", "patch": "@@ -100,6 +100,7 @@ typedef unsigned gcov_type_unsigned __attribute__ ((mode (QI)));\n #define gcov_read_unsigned __gcov_read_unsigned\n #define gcov_read_counter __gcov_read_counter\n #define gcov_read_summary __gcov_read_summary\n+#define gcov_sort_n_vals __gcov_sort_n_vals\n \n #else /* IN_GCOV_TOOL */\n /* About the host.  */\n@@ -128,6 +129,7 @@ typedef unsigned gcov_position_t;\n #define L_gcov_merge_delta 1\n #define L_gcov_merge_ior 1\n #define L_gcov_merge_time_profile 1\n+#define L_gcov_merge_icall_topn 1\n \n extern gcov_type gcov_read_counter_mem ();\n extern unsigned gcov_get_merge_weight ();\n@@ -261,6 +263,9 @@ extern void __gcov_merge_delta (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;\n /* The merge function that just ors the counters together.  */\n extern void __gcov_merge_ior (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;\n \n+/* The merge function is used for topn indirect call counters.  */\n+extern void __gcov_merge_icall_topn (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;\n+\n /* The profiler functions.  */\n extern void __gcov_interval_profiler (gcov_type *, gcov_type, int, unsigned);\n extern void __gcov_pow2_profiler (gcov_type *, gcov_type);\n@@ -271,6 +276,8 @@ extern void __gcov_indirect_call_profiler_v2 (gcov_type, void *);\n extern void __gcov_time_profiler (gcov_type *);\n extern void __gcov_average_profiler (gcov_type *, gcov_type);\n extern void __gcov_ior_profiler (gcov_type *, gcov_type);\n+extern void __gcov_indirect_call_topn_profiler (gcov_type, void *);\n+extern void gcov_sort_n_vals (gcov_type *, int);\n \n #ifndef inhibit_libc\n /* The wrappers around some library functions..  */"}]}