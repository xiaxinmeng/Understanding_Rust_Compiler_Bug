{"sha": "ea47d37c9a33bda4ea158008cb7eae2a1547af03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE0N2QzN2M5YTMzYmRhNGVhMTU4MDA4Y2I3ZWFlMmExNTQ3YWYwMw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-27T01:54:02Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-27T01:54:02Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r838", "tree": {"sha": "e9008136178c8cc074408e64a455479ef750d604", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9008136178c8cc074408e64a455479ef750d604"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea47d37c9a33bda4ea158008cb7eae2a1547af03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea47d37c9a33bda4ea158008cb7eae2a1547af03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea47d37c9a33bda4ea158008cb7eae2a1547af03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea47d37c9a33bda4ea158008cb7eae2a1547af03/comments", "author": null, "committer": null, "parents": [{"sha": "8cbe291798c84e97225c6fdca575187cb1e61a57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cbe291798c84e97225c6fdca575187cb1e61a57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cbe291798c84e97225c6fdca575187cb1e61a57"}], "stats": {"total": 52, "additions": 48, "deletions": 4}, "files": [{"sha": "3c647ba6eb2d51ee5c27afd2666188be652ccec8", "filename": "gcc/enquire.c", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea47d37c9a33bda4ea158008cb7eae2a1547af03/gcc%2Fenquire.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea47d37c9a33bda4ea158008cb7eae2a1547af03/gcc%2Fenquire.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fenquire.c?ref=ea47d37c9a33bda4ea158008cb7eae2a1547af03", "patch": "@@ -11,11 +11,13 @@\n    Copyright (c) 1988, 1989, 1990 Steven Pemberton, CWI, Amsterdam.\n    All rights reserved.\n \n+   Changes by Richard Stallman:\n    Undef CHAR_BIT, etc., if defined in stdio.h, Richard Stallman, Aug 90.\n    In EPROP, avoid a <= old if bad is set, Richard Stallman, May 91.\n    Use gstddef.h, not stddef.h, Richard Stallman, Nov 91.\n    Don't declare malloc, instead cast the value, Richard Stallman, Nov 91.\n    Include sys/types.h before signal.h, Apr 92.\n+   Support NO_LONG_DOUBLE_IO in f_define and f_rep; new fn fake_f_rep, Apr 92.\n \n    COMPILING\n    With luck and a following wind, just the following will work:\n@@ -28,6 +30,7 @@\n \tunsigned short and long\t\t\t-DNO_UI\n \tvoid\t\t\t\t\t-DNO_VOID\n \tsignal(), or setjmp/longjmp()\t\t-DNO_SIG\n+\t%Lf in printf\t\t\t\t-DNO_LONG_DOUBLE_IO\n \n    Try to compile first with no flags, and see if you get any errors -\n    you might be surprised. (Most non-ANSI compilers need -DNO_SC, though.)\n@@ -421,6 +424,7 @@ char *malloc ARGS((size_t size));\n Procedure exit ARGS((int status));\n \n char *f_rep ARGS((int precision, Long_double val));\n+char *fake_f_rep ARGS((char *type, Long_double val));\n \n int maximum_int NOARGS;\n int cprop NOARGS;\n@@ -810,8 +814,29 @@ Procedure f_define(desc, extra, sort, name, precision, val, mark)\n \t/* Produce a #define for a float/double/long double */\n \tdescribe(desc, extra);\n \tif (stdc) {\n+#ifdef NO_LONG_DOUBLE_IO\n+\t\tstatic int union_defined = 0;\n+\t\tif (!strcmp(sort, \"LDBL\")) {\n+\t\t\tif (!union_defined) {\n+\t\t\t\tprintf(\"#ifndef __LDBL_UNION__\\n\");\n+\t\t\t\tprintf(\"#define __LDBL_UNION__\\n\");\n+\t\t\t\tprintf(\"union __convert_long_double {\\n\");\n+\t\t\t\tprintf(\"  int __convert_long_double_i[4];\\n\");\n+\t\t\t\tprintf(\"  long double __convert_long_double_d;\\n\");\n+\t\t\t\tprintf(\"};\\n\");\n+\t\t\t\tprintf(\"#endif\\n\");\n+\t\t\t\tunion_defined = 1;\n+\t\t\t}\n+\t\t\tprintf(\"#define %s%s %s\\n\",\n+\t\t\t       sort, name, fake_f_rep(\"long double\", val));\n+\t\t} else {\n+\t\t\tprintf(\"#define %s%s %s%s\\n\",\n+\t\t\t       sort, name, f_rep(precision, val), mark);\n+\t\t}\n+#else\n \t\tprintf(\"#define %s%s %s%s\\n\",\n \t\t       sort, name, f_rep(precision, val), mark);\n+#endif\n \t} else if (*mark == 'F') {\n \t\t/* non-ANSI C has no float constants, so cast the constant */\n \t\tprintf(\"#define %s%s ((float)%s)\\n\",\n@@ -865,19 +890,38 @@ int exponent(x, fract, exp) Long_double x; double *fract; int *exp; {\n \treturn 1;\n }\n \n+/* Print a value of type TYPE with value VAL,\n+   assuming that sprintf can't handle this type properly (without truncation).\n+   We create an expession that uses type casting to create the value from\n+   a bit pattern.  */\n+\n+char *fake_f_rep(type, val) char *type; Long_double val; {\n+\tstatic char buf[1024];\n+\tunion { int i[4]; Long_double ld;} u;\n+\tu.ld = val;\n+\tsprintf(buf, \"(((union __convert_long_double) {0x%x, 0x%x, 0x%x, 0x%x}).__convert_long_double_d)\",\n+\t\tu.i[0], u.i[1], u.i[2], u.i[3]);\n+\treturn buf;\n+}\n+\n char *f_rep(precision, val) int precision; Long_double val; {\n \t/* Return the floating representation of val */\n \tstatic char buf[1024];\n \tchar *f1;\n-\tif (sizeof(double) == sizeof(Long_double)) {\n+#ifdef NO_LONG_DOUBLE_IO\n+\tif (1)\n+#else\n+\tif (sizeof(double) == sizeof(Long_double))\n+#endif\n+\t{\n+\t\tdouble d = val;\n \t\t/* Assume they're the same, and use non-stdc format */\n \t\t/* This is for stdc compilers using non-stdc libraries */\n-\t\tf1= \"%.*e\";\n+\t\tsprintf(buf, \"%.*e\", precision, d);\n \t} else {\n \t\t/* It had better support Le then */\n-\t\tf1= \"%.*Le\";\n+\t\tsprintf(buf, \"%.*Le\", precision, val);\n \t}\n-\tsprintf(buf, f1, precision, val);\n \treturn buf;\n }\n "}]}