{"sha": "72c4a4ca45bb4adc746cedd9eba5960b357b6537", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJjNGE0Y2E0NWJiNGFkYzc0NmNlZGQ5ZWJhNTk2MGIzNTdiNjUzNw==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2006-12-01T23:01:05Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2006-12-01T23:01:05Z"}, "message": "decl.c (poplevel): Check DECL_INITIAL invariant.\n\n\t* decl.c (poplevel): Check DECL_INITIAL invariant.\n\t(duplicate_decls): Preserve DECL_INITIAL when eliminating\n\ta new definition in favour of an old declaration.\n\t(start_preparsed_function): Define and document value of\n\tDECL_INITIAL before and after routine.\n\t(finish_function): Check DECL_INITIAL invariant.\n\t* parser.c \n\t(cp_parser_function_definition_from_specifiers_and_declarator): \n\tSkip duplicate function definitions.\n\nFrom-SVN: r119427", "tree": {"sha": "6a7205d17e6c8b71f9549fe22d01ac548d72b018", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a7205d17e6c8b71f9549fe22d01ac548d72b018"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72c4a4ca45bb4adc746cedd9eba5960b357b6537", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72c4a4ca45bb4adc746cedd9eba5960b357b6537", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72c4a4ca45bb4adc746cedd9eba5960b357b6537", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72c4a4ca45bb4adc746cedd9eba5960b357b6537/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "01975fc73d3e6f23fac39e0593363af838980d95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01975fc73d3e6f23fac39e0593363af838980d95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01975fc73d3e6f23fac39e0593363af838980d95"}], "stats": {"total": 103, "additions": 75, "deletions": 28}, "files": [{"sha": "989efcf06f5d9626542faf93b04e61476253764c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72c4a4ca45bb4adc746cedd9eba5960b357b6537/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72c4a4ca45bb4adc746cedd9eba5960b357b6537/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=72c4a4ca45bb4adc746cedd9eba5960b357b6537", "patch": "@@ -1,3 +1,15 @@\n+2006-12-01  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* decl.c (poplevel): Check DECL_INITIAL invariant.\n+\t(duplicate_decls): Preserve DECL_INITIAL when eliminating\n+\ta new definition in favour of an old declaration.\n+\t(start_preparsed_function): Define and document value of\n+\tDECL_INITIAL before and after routine.\n+\t(finish_function): Check DECL_INITIAL invariant.\n+\t* parser.c \n+\t(cp_parser_function_definition_from_specifiers_and_declarator): \n+\tSkip duplicate function definitions.\n+\n 2006-12-01  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/30022"}, {"sha": "0852d72c7e9434fee2a4ebbbeb96059875697284", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 46, "deletions": 23, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72c4a4ca45bb4adc746cedd9eba5960b357b6537/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72c4a4ca45bb4adc746cedd9eba5960b357b6537/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=72c4a4ca45bb4adc746cedd9eba5960b357b6537", "patch": "@@ -756,7 +756,12 @@ poplevel (int keep, int reverse, int functionbody)\n \n   leave_scope ();\n   if (functionbody)\n-    DECL_INITIAL (current_function_decl) = block;\n+    {\n+      /* The current function is being defined, so its DECL_INITIAL\n+\t should be error_mark_node.  */\n+      gcc_assert (DECL_INITIAL (current_function_decl) == error_mark_node);\n+      DECL_INITIAL (current_function_decl) = block;\n+    }\n   else if (block)\n     current_binding_level->blocks\n       = chainon (current_binding_level->blocks, block);\n@@ -1632,13 +1637,15 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t}\n \n       /* If the new declaration is a definition, update the file and\n-\t line information on the declaration.  */\n+\t line information on the declaration, and also make\n+\t the old declaration the same definition.  */\n       if (DECL_INITIAL (old_result) == NULL_TREE\n \t  && DECL_INITIAL (new_result) != NULL_TREE)\n \t{\n \t  DECL_SOURCE_LOCATION (olddecl)\n \t    = DECL_SOURCE_LOCATION (old_result)\n \t    = DECL_SOURCE_LOCATION (newdecl);\n+\t  DECL_INITIAL (old_result) = DECL_INITIAL (new_result);\n \t  if (DECL_FUNCTION_TEMPLATE_P (newdecl))\n \t    DECL_ARGUMENTS (old_result)\n \t      = DECL_ARGUMENTS (new_result);\n@@ -10374,7 +10381,13 @@ check_function_type (tree decl, tree current_function_parms)\n    For C++, we must first check whether that datum makes any sense.\n    For example, \"class A local_a(1,2);\" means that variable local_a\n    is an aggregate of type A, which should have a constructor\n-   applied to it with the argument list [1, 2].  */\n+   applied to it with the argument list [1, 2].\n+\n+   On entry, DECL_INITIAL (decl1) should be NULL_TREE or error_mark_node,\n+   or may be a BLOCK if the function has been defined previously\n+   in this translation unit.  On exit, DECL_INITIAL (decl1) will be\n+   error_mark_node if the function has never been defined, or\n+   a BLOCK if the function has been defined somewhere.  */\n \n void\n start_preparsed_function (tree decl1, tree attrs, int flags)\n@@ -10503,24 +10516,6 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n       cp_apply_type_quals_to_decl (cp_type_quals (restype), resdecl);\n     }\n \n-  /* Initialize RTL machinery.  We cannot do this until\n-     CURRENT_FUNCTION_DECL and DECL_RESULT are set up.  We do this\n-     even when processing a template; this is how we get\n-     CFUN set up, and our per-function variables initialized.\n-     FIXME factor out the non-RTL stuff.  */\n-  bl = current_binding_level;\n-  allocate_struct_function (decl1);\n-  current_binding_level = bl;\n-\n-  /* Even though we're inside a function body, we still don't want to\n-     call expand_expr to calculate the size of a variable-sized array.\n-     We haven't necessarily assigned RTL to all variables yet, so it's\n-     not safe to try to expand expressions involving them.  */\n-  cfun->x_dont_save_pending_sizes_p = 1;\n-\n-  /* Start the statement-tree, start the tree now.  */\n-  DECL_SAVED_TREE (decl1) = push_stmt_list ();\n-\n   /* Let the user know we're compiling this function.  */\n   announce_function (decl1);\n \n@@ -10566,9 +10561,33 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \tmaybe_apply_pragma_weak (decl1);\n     }\n \n-  /* Reset these in case the call to pushdecl changed them.  */\n+  /* Reset this in case the call to pushdecl changed it.  */\n   current_function_decl = decl1;\n-  cfun->decl = decl1;\n+\n+  gcc_assert (DECL_INITIAL (decl1));\n+\n+  /* This function may already have been parsed, in which case just\n+     return; our caller will skip over the body without parsing.  */\n+  if (DECL_INITIAL (decl1) != error_mark_node)\n+    return;\n+\n+  /* Initialize RTL machinery.  We cannot do this until\n+     CURRENT_FUNCTION_DECL and DECL_RESULT are set up.  We do this\n+     even when processing a template; this is how we get\n+     CFUN set up, and our per-function variables initialized.\n+     FIXME factor out the non-RTL stuff.  */\n+  bl = current_binding_level;\n+  allocate_struct_function (decl1);\n+  current_binding_level = bl;\n+\n+  /* Even though we're inside a function body, we still don't want to\n+     call expand_expr to calculate the size of a variable-sized array.\n+     We haven't necessarily assigned RTL to all variables yet, so it's\n+     not safe to try to expand expressions involving them.  */\n+  cfun->x_dont_save_pending_sizes_p = 1;\n+\n+  /* Start the statement-tree, start the tree now.  */\n+  DECL_SAVED_TREE (decl1) = push_stmt_list ();\n \n   /* If we are (erroneously) defining a function that we have already\n      defined before, wipe out what we knew before.  */\n@@ -11077,6 +11096,10 @@ finish_function (int flags)\n       which then got a warning when stored in a ptr-to-function variable.  */\n \n   gcc_assert (building_stmt_tree ());\n+  /* The current function is being defined, so its DECL_INITIAL should\n+     be set, and unless there's a multiple definition, it should be\n+     error_mark_node.  */\n+  gcc_assert (DECL_INITIAL (fndecl) == error_mark_node);\n \n   /* For a cloned function, we've already got all the code we need;\n      there's no need to add any extra bits.  */"}, {"sha": "71e34f064c1ac219e7b45abab521a4a92b000645", "filename": "gcc/cp/method.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72c4a4ca45bb4adc746cedd9eba5960b357b6537/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72c4a4ca45bb4adc746cedd9eba5960b357b6537/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=72c4a4ca45bb4adc746cedd9eba5960b357b6537", "patch": "@@ -407,10 +407,6 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \t}\n     }\n \n-  /* The back-end expects DECL_INITIAL to contain a BLOCK, so we\n-     create one.  */\n-  DECL_INITIAL (thunk_fndecl) = make_node (BLOCK);\n-\n   /* Set up cloned argument trees for the thunk.  */\n   t = NULL_TREE;\n   for (a = DECL_ARGUMENTS (function); a; a = TREE_CHAIN (a))\n@@ -424,17 +420,23 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n     }\n   a = nreverse (t);\n   DECL_ARGUMENTS (thunk_fndecl) = a;\n-  BLOCK_VARS (DECL_INITIAL (thunk_fndecl)) = a;\n \n   if (this_adjusting\n       && targetm.asm_out.can_output_mi_thunk (thunk_fndecl, fixed_offset,\n \t\t\t\t\t      virtual_value, alias))\n     {\n       const char *fnname;\n+      tree fn_block;\n+      \n       current_function_decl = thunk_fndecl;\n       DECL_RESULT (thunk_fndecl)\n \t= build_decl (RESULT_DECL, 0, integer_type_node);\n       fnname = XSTR (XEXP (DECL_RTL (thunk_fndecl), 0), 0);\n+      /* The back-end expects DECL_INITIAL to contain a BLOCK, so we\n+\t create one.  */\n+      fn_block = make_node (BLOCK);\n+      BLOCK_VARS (fn_block) = a;\n+      DECL_INITIAL (thunk_fndecl) = fn_block;\n       init_function_start (thunk_fndecl);\n       current_function_is_thunk = 1;\n       assemble_start_function (thunk_fndecl, fnname);"}, {"sha": "3ed7497624298641d14e3f23147cb8d4f6e1ab43", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72c4a4ca45bb4adc746cedd9eba5960b357b6537/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72c4a4ca45bb4adc746cedd9eba5960b357b6537/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=72c4a4ca45bb4adc746cedd9eba5960b357b6537", "patch": "@@ -15583,6 +15583,16 @@ cp_parser_function_definition_from_specifiers_and_declarator\n       cp_parser_skip_to_end_of_block_or_statement (parser);\n       fn = error_mark_node;\n     }\n+  else if (DECL_INITIAL (current_function_decl) != error_mark_node)\n+    {\n+      /* Seen already, skip it.  An error message has already been output.  */\n+      cp_parser_skip_to_end_of_block_or_statement (parser);\n+      fn = current_function_decl;\n+      current_function_decl = NULL_TREE;\n+      /* If this is a function from a class, pop the nested class.  */\n+      if (current_class_name)\n+\tpop_nested_class ();\n+    }\n   else\n     fn = cp_parser_function_definition_after_declarator (parser,\n \t\t\t\t\t\t\t /*inline_p=*/false);"}]}