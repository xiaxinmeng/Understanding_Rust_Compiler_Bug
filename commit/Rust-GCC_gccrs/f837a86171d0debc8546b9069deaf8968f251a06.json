{"sha": "f837a86171d0debc8546b9069deaf8968f251a06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgzN2E4NjE3MWQwZGViYzg1NDZiOTA2OWRlYWY4OTY4ZjI1MWEwNg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-08-08T15:19:34Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-08-08T15:19:34Z"}, "message": "Add prototype support.\n\nFrom-SVN: r1785", "tree": {"sha": "0834e09b5caa55aaceeefd7e8ab80819c97fec98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0834e09b5caa55aaceeefd7e8ab80819c97fec98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f837a86171d0debc8546b9069deaf8968f251a06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f837a86171d0debc8546b9069deaf8968f251a06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f837a86171d0debc8546b9069deaf8968f251a06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f837a86171d0debc8546b9069deaf8968f251a06/comments", "author": null, "committer": null, "parents": [{"sha": "e83d45c45e9155cb449b3ce70afabc175b572d29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e83d45c45e9155cb449b3ce70afabc175b572d29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e83d45c45e9155cb449b3ce70afabc175b572d29"}], "stats": {"total": 754, "additions": 489, "deletions": 265}, "files": [{"sha": "5b104ec6ed9f5efde7e89a11ea83e091df6c77ee", "filename": "gcc/genflags.c", "status": "modified", "additions": 130, "deletions": 3, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f837a86171d0debc8546b9069deaf8968f251a06/gcc%2Fgenflags.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f837a86171d0debc8546b9069deaf8968f251a06/gcc%2Fgenflags.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenflags.c?ref=f837a86171d0debc8546b9069deaf8968f251a06", "patch": "@@ -39,18 +39,100 @@ char *xmalloc ();\n static void fatal ();\n void fancy_abort ();\n \n+/* Names for patterns.  Need to allow linking with print-rtl.  */\n+char **insn_name_ptr;\n+\n+/* Obstacks to remember normal, and call insns.  */\n+static struct obstack call_obstack, normal_obstack;\n+\n+/* Max size of names encountered.  */\n+static int max_id_len;\n+\n+/* Count the number of match_operand's found.  */\n+static int\n+num_operands (x)\n+     rtx x;\n+{\n+  int count = 0;\n+  int i, j;\n+  enum rtx_code code = GET_CODE (x);\n+  char *format_ptr = GET_RTX_FORMAT (code);\n+\n+  if (code == MATCH_OPERAND)\n+    return 1;\n+\n+  if (code == MATCH_OPERATOR)\n+    count++;\n+\n+  for (i = 0; i < GET_RTX_LENGTH (code); i++)\n+    {\n+      switch (*format_ptr++)\n+\t{\n+\tcase 'u':\n+\tcase 'e':\n+\t  count += num_operands (XEXP (x, i));\n+\t  break;\n+\n+\tcase 'E':\n+\t  if (XVEC (x, i) != NULL)\n+\t    for (j = 0; j < XVECLEN (x, i); j++)\n+\t      count += num_operands (XVECEXP (x, i, j));\n+\n+\t  break;\n+\t}\n+    }\n+\n+  return count;\n+}\n+\n+/* Print out prototype information for a function.  */\n+static void\n+gen_proto (insn)\n+     rtx insn;\n+{\n+  int num = num_operands (insn);\n+  printf (\"extern rtx gen_%-*s PROTO((\", max_id_len, XSTR (insn, 0));\n+\n+  if (num == 0)\n+    printf (\"void\");\n+  else\n+    {\n+      while (num-- > 1)\n+\tprintf (\"rtx, \");\n+\n+      printf (\"rtx\");\n+    }\n+\n+  printf (\"));\\n\");\n+}\n+\n+/* Print out a function declaration without a prototype.  */\n+static void\n+gen_nonproto (insn)\n+     rtx insn;\n+{\n+  printf (\"extern rtx gen_%s ();\\n\", XSTR (insn, 0));\n+}\n+\n static void\n gen_insn (insn)\n      rtx insn;\n {\n+  char *name = XSTR (insn, 0);\n   char *p;\n+  struct obstack *obstack_ptr;\n+  int len;\n \n   /* Don't mention instructions whose names are the null string.\n      They are in the machine description just to be recognized.  */\n-  if (strlen (XSTR (insn, 0)) == 0)\n+  len = strlen (name);\n+  if (len == 0)\n     return;\n \n-  printf (\"#define HAVE_%s \", XSTR (insn, 0));\n+  if (len > max_id_len)\n+    max_id_len = len;\n+\n+  printf (\"#define HAVE_%s \", name);\n   if (strlen (XSTR (insn, 2)) == 0)\n     printf (\"1\\n\");\n   else\n@@ -68,7 +150,16 @@ gen_insn (insn)\n       printf (\")\\n\");\n     }\n       \n-  printf (\"extern rtx gen_%s ();\\n\", XSTR (insn, 0));\n+  /* Save the current insn, so that we can later put out appropriate\n+     prototypes.  At present, most md files have the wrong number of\n+     arguments for call and call_value, ignoring the extra arguments\n+     that are passed for some machines, so by default, turn off the\n+     prototype.  */\n+\n+  obstack_ptr = (!strcmp (name, \"call\") || !strcmp (name, \"call_value\"))\n+    ? &call_obstack : &normal_obstack;\n+\n+  obstack_grow (obstack_ptr, &insn, sizeof (rtx));\n }\n \f\n char *\n@@ -119,10 +210,16 @@ main (argc, argv)\n      char **argv;\n {\n   rtx desc;\n+  rtx dummy;\n+  rtx *call_insns;\n+  rtx *normal_insns;\n+  rtx *insn_ptr;\n   FILE *infile;\n   register int c;\n \n   obstack_init (rtl_obstack);\n+  obstack_init (&call_obstack);\n+  obstack_init (&normal_obstack);\n \n   if (argc <= 1)\n     fatal (\"No input file name.\");\n@@ -153,6 +250,36 @@ from the machine description file `md'.  */\\n\\n\");\n \tgen_insn (desc);\n     }\n \n+  /* Print out the prototypes now.  */\n+  dummy = (rtx)0;\n+  obstack_grow (&call_obstack, &dummy, sizeof (rtx));\n+  call_insns = (rtx *) obstack_finish (&call_obstack);\n+\n+  obstack_grow (&normal_obstack, &dummy, sizeof (rtx));\n+  normal_insns = (rtx *) obstack_finish (&normal_obstack);\n+\n+  printf (\"\\n#ifndef NO_MD_PROTOTYPES\\n\");\n+  for (insn_ptr = normal_insns; *insn_ptr; insn_ptr++)\n+    gen_proto (*insn_ptr);\n+\n+  printf (\"\\n#ifdef MD_CALL_PROTOTYPES\\n\");\n+  for (insn_ptr = call_insns; *insn_ptr; insn_ptr++)\n+    gen_proto (*insn_ptr);\n+\n+  printf (\"\\n#else /* !MD_CALL_PROTOTYPES */\\n\");\n+  for (insn_ptr = call_insns; *insn_ptr; insn_ptr++)\n+    gen_nonproto (*insn_ptr);\n+\n+  printf (\"#endif /* !MD_CALL_PROTOTYPES */\\n\");\n+  printf (\"\\n#else  /* NO_MD_PROTOTYPES */\\n\");\n+  for (insn_ptr = normal_insns; *insn_ptr; insn_ptr++)\n+    gen_nonproto (*insn_ptr);\n+\n+  for (insn_ptr = call_insns; *insn_ptr; insn_ptr++)\n+    gen_nonproto (*insn_ptr);\n+\n+  printf (\"#endif  /* NO_MD_PROTOTYPES */\\n\");\n+\n   fflush (stdout);\n   exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n   /* NOTREACHED */"}, {"sha": "7c7edbe59c348a2fc51a08f50ebf0d2795f369c0", "filename": "gcc/rtl.h", "status": "modified", "additions": 178, "deletions": 117, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f837a86171d0debc8546b9069deaf8968f251a06/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f837a86171d0debc8546b9069deaf8968f251a06/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=f837a86171d0debc8546b9069deaf8968f251a06", "patch": "@@ -131,6 +131,15 @@ typedef struct rtx_def\n   rtunion fld[1];\n } *rtx;\n \n+/* Add prototype support.  */\n+#ifndef PROTO\n+#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)\n+#define PROTO(ARGS) ARGS\n+#else\n+#define PROTO(ARGS) ()\n+#endif\n+#endif\n+\n #define NULL_RTX (rtx) 0\n \n /* Define a generic NULL if one hasn't already been defined.  */\n@@ -139,8 +148,16 @@ typedef struct rtx_def\n #define NULL 0\n #endif\n \n+#ifndef GENERIC_PTR\n+#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)\n+#define GENERIC_PTR void *\n+#else\n+#define GENERIC_PTR char *\n+#endif\n+#endif\n+\n #ifndef NULL_PTR\n-#define NULL_PTR (char *) NULL\n+#define NULL_PTR ((GENERIC_PTR)0)\n #endif\n \n /* Define macros to access the `code' field of the rtx.  */\n@@ -568,135 +585,160 @@ extern char *note_insn_name[];\n #define plus_constant_for_output(X,C)  \\\n   plus_constant_for_output_wide (X, (HOST_WIDE_INT) (C))\n \n-extern rtx plus_constant_wide (), plus_constant_for_output_wide ();\n+extern rtx plus_constant_wide\t\t PROTO((rtx, HOST_WIDE_INT));\n+extern rtx plus_constant_for_output_wide PROTO((rtx, HOST_WIDE_INT));\n \n #define GEN_INT(N) gen_rtx (CONST_INT, VOIDmode, (N))\n \n-extern rtx gen_rtx ();\n+#if 0\n+/* We cannot define prototypes for the variable argument functions,\n+   since they have not been ANSI-fied, and an ANSI compiler would\n+   complain when compiling the definition of these functions.  */\n \n-extern char *xmalloc ();\n-extern char *xrealloc ();\n-extern char *oballoc ();\n-extern char *permalloc ();\n-extern void free ();\n-extern rtx rtx_alloc ();\n-extern rtvec rtvec_alloc ();\n-extern rtx find_reg_note ();\n-extern rtx find_regno_note ();\n-extern HOST_WIDE_INT get_integer_term ();\n-extern rtx get_related_value ();\n-extern rtx single_set ();\n-extern rtx find_last_value ();\n-extern rtx copy_rtx ();\n-extern rtx copy_rtx_if_shared ();\n-extern rtx copy_most_rtx ();\n-extern rtx replace_rtx ();\n+extern rtx gen_rtx\t\t\tPROTO((enum rtx_code, enum machine_mode, ...));\n+extern rtvec gen_rtvec\t\t\tPROTO((int, ...));\n+\n+#else\n+extern rtx gen_rtx ();\n extern rtvec gen_rtvec ();\n-extern rtvec gen_rtvec_v ();\n+#endif\n+\n+#ifdef BUFSIZ\t\t\t/* stdio.h has been included */\n+extern rtx read_rtx\t\t\tPROTO((FILE *));\n+#else\n extern rtx read_rtx ();\n-extern rtx gen_reg_rtx ();\n-extern rtx gen_label_rtx ();\n-extern rtx gen_inline_header_rtx ();\n-extern rtx gen_lowpart_common ();\n-extern rtx gen_lowpart ();\n-extern rtx gen_lowpart_if_possible ();\n-extern rtx operand_subword ();\n-extern rtx operand_subword_force ();\n-extern int subreg_lowpart_p ();\n-extern rtx make_safe_from ();\n-extern rtx memory_address ();\n-extern rtx get_insns ();\n-extern rtx get_last_insn ();\n-extern rtx get_last_insn_anywhere ();\n-extern void start_sequence ();\n-extern void push_to_sequence ();\n-extern void end_sequence ();\n-extern rtx gen_sequence ();\n-extern rtx expand_expr ();\n-extern rtx output_constant_def ();\n-extern rtx immed_real_const ();\n-extern rtx immed_real_const_1 ();\n-extern rtx immed_double_const ();\n-extern rtx force_const_mem ();\n-extern rtx get_pool_constant ();\n-extern enum machine_mode get_pool_mode ();\n-extern int get_pool_offset ();\n-extern rtx get_parm_real_loc ();\n-extern rtx assign_stack_local ();\n-extern rtx assign_stack_temp ();\n-extern rtx protect_from_queue ();\n-extern void emit_queue ();\n-extern rtx emit_move_insn ();\n-extern rtx emit_insn_before ();\n-extern rtx emit_jump_insn_before ();\n-extern rtx emit_call_insn_before ();\n-extern rtx emit_barrier_before ();\n-extern rtx emit_note_before ();\n-extern rtx emit_insn_after ();\n-extern rtx emit_jump_insn_after ();\n-extern rtx emit_barrier_after ();\n-extern rtx emit_label_after ();\n-extern rtx emit_note_after ();\n-extern rtx emit_line_note_after ();\n-extern rtx emit_insn ();\n-extern rtx emit_insns ();\n-extern rtx emit_insns_before ();\n-extern rtx emit_jump_insn ();\n-extern rtx emit_call_insn ();\n-extern rtx emit_label ();\n-extern rtx emit_barrier ();\n-extern rtx emit_line_note ();\n-extern rtx emit_note ();\n-extern rtx emit_line_note_force ();\n-extern rtx make_insn_raw ();\n-extern rtx previous_insn ();\n-extern rtx next_insn ();\n-extern rtx prev_nonnote_insn ();\n-extern rtx next_nonnote_insn ();\n-extern rtx prev_real_insn ();\n-extern rtx next_real_insn ();\n-extern rtx prev_active_insn ();\n-extern rtx next_active_insn ();\n-extern rtx prev_label ();\n-extern rtx next_label ();\n-extern rtx next_cc0_user ();\n-extern rtx prev_cc0_setter ();\n-extern rtx reg_set_last ();\n-extern rtx next_nondeleted_insn ();\n-extern enum rtx_code reverse_condition ();\n-extern enum rtx_code swap_condition ();\n-extern enum rtx_code unsigned_condition ();\n-extern enum rtx_code signed_condition ();\n-extern rtx find_equiv_reg ();\n-extern rtx squeeze_notes ();\n-extern rtx delete_insn ();\n-extern void delete_jump ();\n-extern rtx get_label_before ();\n-extern rtx get_label_after ();\n-extern rtx follow_jumps ();\n-extern rtx adj_offsettable_operand ();\n-extern rtx try_split ();\n-extern rtx split_insns ();\n-extern rtx simplify_unary_operation (), simplify_binary_operation ();\n-extern rtx simplify_ternary_operation (), simplify_relational_operation ();\n-extern rtx nonlocal_label_rtx_list ();\n+#endif\n+\n+#if 0\n+/* At present, don't prototype xrealloc, since all of the callers don't\n+   cast their pointers to char *, and all of the xrealloc's don't use\n+   void * yet.  */\n+extern char *xrealloc\t\t\tPROTO((void *, unsigned));\n+#else\n+extern char *xrealloc ();\n+#endif\n+\n+extern char *xmalloc\t\t\tPROTO((unsigned));\n+extern char *oballoc\t\t\tPROTO((int));\n+extern char *permalloc\t\t\tPROTO((int));\n+extern void free\t\t\tPROTO((void *));\n+extern rtx rtx_alloc\t\t\tPROTO((RTX_CODE));\n+extern rtvec rtvec_alloc\t\tPROTO((int));\n+extern rtx find_reg_note\t\tPROTO((rtx, enum reg_note, rtx));\n+extern rtx find_regno_note\t\tPROTO((rtx, enum reg_note, int));\n+extern HOST_WIDE_INT get_integer_term\tPROTO((rtx));\n+extern rtx get_related_value\t\tPROTO((rtx));\n+extern rtx single_set\t\t\tPROTO((rtx));\n+extern rtx find_last_value\t\tPROTO((rtx, rtx *, rtx));\n+extern rtx copy_rtx\t\t\tPROTO((rtx));\n+extern rtx copy_rtx_if_shared\t\tPROTO((rtx));\n+extern rtx copy_most_rtx\t\tPROTO((rtx, rtx));\n+extern rtx replace_rtx\t\t\tPROTO((rtx, rtx, rtx));\n+extern rtvec gen_rtvec_v\t\tPROTO((int, rtx *));\n+extern rtx gen_reg_rtx\t\t\tPROTO((enum machine_mode));\n+extern rtx gen_label_rtx\t\tPROTO((void));\n+extern rtx gen_inline_header_rtx\tPROTO((rtx, rtx, int, int, int, int, int, int, rtx, int, int, rtvec, rtx));\n+extern rtx gen_lowpart_common\t\tPROTO((enum machine_mode, rtx));\n+extern rtx gen_lowpart\t\t\tPROTO((enum machine_mode, rtx));\n+extern rtx gen_lowpart_if_possible\tPROTO((enum machine_mode, rtx));\n+extern rtx operand_subword\t\tPROTO((rtx, int, int, enum machine_mode));\n+extern rtx operand_subword_force\tPROTO((rtx, int, enum machine_mode));\n+extern int subreg_lowpart_p\t\tPROTO((rtx));\n+extern rtx make_safe_from\t\tPROTO((rtx, rtx));\n+extern rtx memory_address\t\tPROTO((enum machine_mode, rtx));\n+extern rtx get_insns\t\t\tPROTO((void));\n+extern rtx get_last_insn\t\tPROTO((void));\n+extern rtx get_last_insn_anywhere\tPROTO((void));\n+extern void start_sequence\t\tPROTO((void));\n+extern void push_to_sequence\t\tPROTO((rtx));\n+extern void end_sequence\t\tPROTO((void));\n+extern rtx gen_sequence\t\t\tPROTO((void));\n+extern rtx immed_double_const\t\tPROTO((HOST_WIDE_INT, HOST_WIDE_INT, enum machine_mode));\n+extern rtx force_const_mem\t\tPROTO((enum machine_mode, rtx));\n+extern rtx force_reg\t\t\tPROTO((enum machine_mode, rtx));\n+extern rtx get_pool_constant\t\tPROTO((rtx));\n+extern enum machine_mode get_pool_mode\tPROTO((rtx));\n+extern int get_pool_offset\t\tPROTO((rtx));\n+extern rtx assign_stack_local\t\tPROTO((enum machine_mode, int, int));\n+extern rtx assign_stack_temp\t\tPROTO((enum machine_mode, int, int));\n+extern rtx protect_from_queue\t\tPROTO((rtx, int));\n+extern void emit_queue\t\t\tPROTO((void));\n+extern rtx emit_move_insn\t\tPROTO((rtx, rtx));\n+extern rtx emit_insn_before\t\tPROTO((rtx, rtx));\n+extern rtx emit_jump_insn_before\tPROTO((rtx, rtx));\n+extern rtx emit_call_insn_before\tPROTO((rtx, rtx));\n+extern rtx emit_barrier_before\t\tPROTO((rtx));\n+extern rtx emit_note_before\t\tPROTO((int, rtx));\n+extern rtx emit_insn_after\t\tPROTO((rtx, rtx));\n+extern rtx emit_jump_insn_after\t\tPROTO((rtx, rtx));\n+extern rtx emit_barrier_after\t\tPROTO((rtx));\n+extern rtx emit_label_after\t\tPROTO((rtx, rtx));\n+extern rtx emit_note_after\t\tPROTO((int, rtx));\n+extern rtx emit_line_note_after\t\tPROTO((char *, int, rtx));\n+extern rtx emit_insn\t\t\tPROTO((rtx));\n+extern rtx emit_insns\t\t\tPROTO((rtx));\n+extern rtx emit_insns_before\t\tPROTO((rtx, rtx));\n+extern rtx emit_jump_insn\t\tPROTO((rtx));\n+extern rtx emit_call_insn\t\tPROTO((rtx));\n+extern rtx emit_label\t\t\tPROTO((rtx));\n+extern rtx emit_barrier\t\t\tPROTO((void));\n+extern rtx emit_line_note\t\tPROTO((char *, int));\n+extern rtx emit_note\t\t\tPROTO((char *, int));\n+extern rtx emit_line_note_force\t\tPROTO((char *, int));\n+extern rtx make_insn_raw\t\tPROTO((rtx));\n+extern rtx previous_insn\t\tPROTO((rtx));\n+extern rtx next_insn\t\t\tPROTO((rtx));\n+extern rtx prev_nonnote_insn\t\tPROTO((rtx));\n+extern rtx next_nonnote_insn\t\tPROTO((rtx));\n+extern rtx prev_real_insn\t\tPROTO((rtx));\n+extern rtx next_real_insn\t\tPROTO((rtx));\n+extern rtx prev_active_insn\t\tPROTO((rtx));\n+extern rtx next_active_insn\t\tPROTO((rtx));\n+extern rtx prev_label\t\t\tPROTO((rtx));\n+extern rtx next_label\t\t\tPROTO((rtx));\n+extern rtx next_cc0_user\t\tPROTO((rtx));\n+extern rtx prev_cc0_setter\t\tPROTO((rtx));\n+extern rtx reg_set_last\t\t\tPROTO((rtx, rtx));\n+extern rtx next_nondeleted_insn\t\tPROTO((rtx));\n+extern enum rtx_code reverse_condition\tPROTO((enum rtx_code));\n+extern enum rtx_code swap_condition\tPROTO((enum rtx_code));\n+extern enum rtx_code unsigned_condition\tPROTO((enum rtx_code));\n+extern enum rtx_code signed_condition\tPROTO((enum rtx_code));\n+extern rtx find_equiv_reg\t\tPROTO((rtx, rtx, enum reg_class, int, short *, int, enum machine_mode));\n+extern rtx squeeze_notes\t\tPROTO((rtx, rtx));\n+extern rtx delete_insn\t\t\tPROTO((rtx));\n+extern void delete_jump\t\t\tPROTO((rtx));\n+extern rtx get_label_before\t\tPROTO((rtx));\n+extern rtx get_label_after\t\tPROTO((rtx));\n+extern rtx follow_jumps\t\t\tPROTO((rtx));\n+extern rtx adj_offsettable_operand\tPROTO((rtx, int));\n+extern rtx try_split\t\t\tPROTO((rtx, rtx, int));\n+extern rtx split_insns\t\t\tPROTO((rtx, rtx));\n+extern rtx simplify_unary_operation\tPROTO((enum rtx_code, enum machine_mode, rtx, enum machine_mode));\n+extern rtx simplify_binary_operation\tPROTO((enum rtx_code, enum machine_mode, rtx, rtx));\n+extern rtx simplify_ternary_operation\tPROTO((enum rtx_code, enum machine_mode, enum machine_mode, rtx, rtx, rtx));\n+extern rtx simplify_relational_operation PROTO((enum rtx_code, enum machine_mode, rtx, rtx));\n+extern rtx nonlocal_label_rtx_list\tPROTO((void));\n+extern rtx gen_move_insn\t\tPROTO((rtx, rtx));\n+extern rtx gen_jump\t\t\tPROTO((rtx));\n+extern rtx gen_beq\t\t\tPROTO((rtx));\n+extern rtx gen_bge\t\t\tPROTO((rtx));\n+extern rtx gen_ble\t\t\tPROTO((rtx));\n+extern rtx eliminate_constant_term\tPROTO((rtx, rtx *));\n \n /* Maximum number of parallel sets and clobbers in any insn in this fn.\n    Always at least 3, since the combiner could put that many togetherm\n    and we want this to remain correct for all the remaining passes.  */\n \n extern int max_parallel;\n \n-extern int asm_noperands ();\n-extern char *decode_asm_operands ();\n+extern int asm_noperands\t\tPROTO((rtx));\n+extern char *decode_asm_operands\tPROTO((rtx, rtx *, rtx **, char **, enum machine_mode *));\n \n-#ifdef BITS_PER_WORD\n-/* Conditional is to detect when config.h has been included.  */\n-extern enum reg_class reg_preferred_class ();\n-extern enum reg_class reg_alternate_class ();\n-#endif\n+extern enum reg_class reg_preferred_class PROTO((int));\n+extern enum reg_class reg_alternate_class PROTO((int));\n \n-extern rtx get_first_nonparm_insn ();\n+extern rtx get_first_nonparm_insn\tPROTO((void));\n \n /* Standard pieces of rtx, to be substituted directly into things.  */\n extern rtx pc_rtx;\n@@ -773,8 +815,27 @@ extern rtx virtual_outgoing_args_rtx;\n \n #define LAST_VIRTUAL_REGISTER\t((FIRST_VIRTUAL_REGISTER) + 3)\n \n-extern rtx find_next_ref ();\n-extern rtx *find_single_use ();\n+extern rtx find_next_ref\t\tPROTO((rtx, rtx));\n+extern rtx *find_single_use\t\tPROTO((rtx, rtx, rtx *));\n+\n+/* It is hard to write the prototype for expand_expr, since it needs\n+   expr.h to be included for the enumeration.  */\n+\n+extern rtx expand_expr ();\n+extern rtx immed_real_const_1();\n+\n+#ifdef TREE_CODE\n+/* rtl.h and tree.h were included.  */\n+extern rtx  output_constant_def PROTO((tree));\n+extern rtx  immed_real_const\tPROTO((tree));\n+extern rtx  immed_real_const_1\tPROTO((REAL_VALUE_TYPE, enum machine_mode));\n+extern tree make_tree\t\tPROTO((tree, rtx));\n+\n+#else\n+extern rtx output_constant_def ();\n+extern rtx immed_real_const ();\n+extern rtx immed_real_const_1 ();\n+#endif\n \n /* Define a default value for STORE_FLAG_VALUE.  */\n "}, {"sha": "875d0c80fc0072bfca27fdd3528bf1378859c6ce", "filename": "gcc/tree.h", "status": "modified", "additions": 181, "deletions": 145, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f837a86171d0debc8546b9069deaf8968f251a06/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f837a86171d0debc8546b9069deaf8968f251a06/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=f837a86171d0debc8546b9069deaf8968f251a06", "patch": "@@ -115,18 +115,6 @@ enum built_in_function\n \n typedef union tree_node *tree;\n \n-#define NULL_TREE (tree) NULL\n-\n-/* Define a generic NULL if one hasn't already been defined.  */\n-\n-#ifndef NULL\n-#define NULL 0\n-#endif\n-\n-#ifndef NULL_PTR\n-#define NULL_PTR (char *) NULL\n-#endif\n-\n /* Every kind of tree node starts with this structure,\n    so all nodes have these fields.\n \n@@ -929,6 +917,36 @@ union tree_node\n   struct tree_block block;\n  };\n \n+/* Add prototype support.  */\n+#ifndef PROTO\n+#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)\n+#define PROTO(ARGS) ARGS\n+#else\n+#define PROTO(ARGS) ()\n+#endif\n+#endif\n+\n+\n+#define NULL_TREE (tree) NULL\n+\n+/* Define a generic NULL if one hasn't already been defined.  */\n+\n+#ifndef NULL\n+#define NULL 0\n+#endif\n+\n+#ifndef GENERIC_PTR\n+#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)\n+#define GENERIC_PTR void *\n+#else\n+#define GENERIC_PTR char *\n+#endif\n+#endif\n+\n+#ifndef NULL_PTR\n+#define NULL_PTR ((GENERIC_PTR)0)\n+#endif\n+\n /* Format for global names of constructor and destructor functions.  */\n #ifndef NO_DOLLAR_IN_LABEL\n #define CONSTRUCTOR_NAME_FORMAT \"_GLOBAL_$I$%s\"\n@@ -945,77 +963,106 @@ union tree_node\n #define floor_log2(N) floor_log2_wide ((HOST_WIDE_INT) (N))\n #endif\n \n-extern char *oballoc ();\n-extern char *permalloc ();\n-extern char *savealloc ();\n-extern char *xmalloc ();\n+#if 0\n+/* At present, don't prototype xrealloc, since all of the callers don't\n+   cast their pointers to char *, and all of the xrealloc's don't use\n+   void * yet.  */\n+extern char *xrealloc\t\t\tPROTO((void *, unsigned));\n+#else\n extern char *xrealloc ();\n-extern void free ();\n+#endif\n+\n+extern char *oballoc\t\t\tPROTO((int));\n+extern char *permalloc\t\t\tPROTO((int));\n+extern char *savealloc\t\t\tPROTO((int));\n+extern char *xmalloc\t\t\tPROTO((unsigned));\n+extern void free\t\t\tPROTO((void *));\n \n /* Lowest level primitive for allocating a node.\n    The TREE_CODE is the only argument.  Contents are initialized\n    to zero except for a few of the common fields.  */\n \n-extern tree make_node ();\n+extern tree make_node\t\t\tPROTO((enum tree_code));\n \n /* Make a copy of a node, with all the same contents except\n    for TREE_PERMANENT.  (The copy is permanent\n    iff nodes being made now are permanent.)  */\n \n-extern tree copy_node ();\n+extern tree copy_node\t\t\tPROTO((tree));\n \n /* Make a copy of a chain of TREE_LIST nodes.  */\n \n-extern tree copy_list ();\n+extern tree copy_list\t\t\tPROTO((tree));\n \n /* Make a TREE_VEC.  */\n \n-extern tree make_tree_vec ();\n+extern tree make_tree_vec\t\tPROTO((int));\n \n /* Return the (unique) IDENTIFIER_NODE node for a given name.\n    The name is supplied as a char *.  */\n \n-extern tree get_identifier ();\n+extern tree get_identifier\t\tPROTO((char *));\n \n /* Construct various types of nodes.  */\n \n #define build_int_2(LO,HI)  \\\n   build_int_2_wide ((HOST_WIDE_INT) (LO), (HOST_WIDE_INT) (HI))\n \n-extern tree build_int_2_wide ();\n-extern tree build_real ();\n-extern tree build_real_from_string ();\n-extern tree build_real_from_int_cst ();\n-extern tree build_complex ();\n-extern tree build_string ();\n-extern tree build (), build1 ();\n-extern tree build_nt (), build_parse_node ();\n-extern tree build_tree_list (), build_decl_list ();\n-extern tree build_op_identifier ();\n-extern tree build_decl ();\n-extern tree build_block ();\n+#if 0\n+/* We cannot define prototypes for the variable argument functions,\n+   since they have not been ANSI-fied, and an ANSI compiler would\n+   complain when compiling the definition of these functions.  */\n+\n+extern tree build\t\t\tPROTO((enum tree_code, tree, ...));\n+extern tree build_nt\t\t\tPROTO((enum tree_code, ...));\n+extern tree build_parse_node\t\tPROTO((enum tree_code, ...));\n+#else\n+extern tree build ();\n+extern tree build_nt ();\n+extern tree build_parse_node ();\n+#endif\n+\n+extern tree build_int_2_wide\t\tPROTO((HOST_WIDE_INT, HOST_WIDE_INT));\n+extern tree build_real\t\t\tPROTO((tree, REAL_VALUE_TYPE));\n+extern tree build_real_from_int_cst \tPROTO((tree, tree));\n+extern tree build_complex\t\tPROTO((tree, tree));\n+extern tree build_string\t\tPROTO((int, char *));\n+extern tree build1\t\t\tPROTO((enum tree_code, tree, tree));\n+extern tree build_tree_list\t\tPROTO((tree, tree));\n+extern tree build_decl_list\t\tPROTO((tree, tree));\n+extern tree build_decl\t\t\tPROTO((enum tree_code, tree, tree));\n+extern tree build_block\t\t\tPROTO((tree, tree, tree, tree, tree));\n \n /* Construct various nodes representing data types.  */\n \n-extern tree make_signed_type ();\n-extern tree make_unsigned_type ();\n-extern tree signed_or_unsigned_type ();\n-extern void fixup_unsigned_type ();\n-extern tree build_pointer_type ();\n-extern tree build_reference_type ();\n-extern tree build_index_type (), build_index_2_type ();\n-extern tree build_array_type ();\n-extern tree build_function_type ();\n-extern tree build_method_type ();\n-extern tree build_offset_type ();\n-extern tree build_complex_type ();\n-extern tree array_type_nelts ();\n-\n-/* Construct expressions, performing type checking.  */\n+extern tree make_signed_type\t\tPROTO((int));\n+extern tree make_unsigned_type\t\tPROTO((int));\n+extern tree signed_or_unsigned_type \tPROTO((int, tree));\n+extern void fixup_unsigned_type\t\tPROTO((tree));\n+extern tree build_pointer_type\t\tPROTO((tree));\n+extern tree build_reference_type \tPROTO((tree));\n+extern tree build_index_type\t\tPROTO((tree));\n+extern tree build_index_2_type\t\tPROTO((tree, tree));\n+extern tree build_array_type\t\tPROTO((tree, tree));\n+extern tree build_function_type\t\tPROTO((tree, tree));\n+extern tree build_method_type\t\tPROTO((tree, tree));\n+extern tree build_offset_type\t\tPROTO((tree, tree));\n+extern tree build_complex_type\t\tPROTO((tree));\n+extern tree array_type_nelts\t\tPROTO((tree));\n+\n+/* Construct expressions, performing type checking.\n+   GCC and G++ use different calling sequences for build_binary_op,\n+   and build_indirect_ref, so don't include a prototype here.  */\n \n extern tree build_binary_op ();\n extern tree build_indirect_ref ();\n-extern tree build_unary_op ();\n+extern tree build_unary_op\t\tPROTO((enum tree_code, tree, int));\n+\n+/* From expmed.c.  Since rtl.h is included after tree.h, we can't\n+   put the prototype here.  Rtl.h does declare the prototype if\n+   tree.h had been included.  */\n+\n+extern tree make_tree ();\n \f\n /* Given a type node TYPE, and CONSTP and VOLATILEP, return a type\n    for the same kind of data as TYPE describes.\n@@ -1024,25 +1071,25 @@ extern tree build_unary_op ();\n    so that duplicate variants are never made.\n    Only main variants should ever appear as types of expressions.  */\n \n-extern tree build_type_variant ();\n+extern tree build_type_variant\t\tPROTO((tree, int, int));\n \n /* Make a copy of a type node.  */\n \n-extern tree build_type_copy ();\n+extern tree build_type_copy\t\tPROTO((tree));\n \n /* Given a ..._TYPE node, calculate the TYPE_SIZE, TYPE_SIZE_UNIT,\n    TYPE_ALIGN and TYPE_MODE fields.\n    If called more than once on one node, does nothing except\n    for the first time.  */\n \n-extern void layout_type ();\n+extern void layout_type\t\t\tPROTO((tree));\n \n /* Given a hashcode and a ..._TYPE node (for which the hashcode was made),\n    return a canonicalized ..._TYPE node, so that duplicates are not made.\n    How the hash code is computed is up to the caller, as long as any two\n    callers that could hash identical-looking type nodes agree.  */\n \n-extern tree type_hash_canon ();\n+extern tree type_hash_canon\t\tPROTO((int, tree));\n \n /* Given a VAR_DECL, PARM_DECL, RESULT_DECL or FIELD_DECL node,\n    calculates the DECL_SIZE, DECL_SIZE_UNIT, DECL_ALIGN and DECL_MODE\n@@ -1052,28 +1099,27 @@ extern tree type_hash_canon ();\n    be starting at (in bits).  Zero means it can be assumed aligned\n    on any boundary that may be needed.  */\n \n-extern void layout_decl ();\n+extern void layout_decl\t\t\tPROTO((tree, unsigned));\n \n /* Fold constants as much as possible in an expression.\n    Returns the simplified expression.\n    Acts only on the top level of the expression;\n    if the argument itself cannot be simplified, its\n    subexpressions are not changed.  */\n \n-extern tree fold ();\n+extern tree fold\t\t\tPROTO((tree));\n \n /* Return an expr equal to X but certainly not valid as an lvalue.  */\n \n-extern tree non_lvalue ();\n+extern tree non_lvalue\t\t\tPROTO((tree));\n \n-extern tree convert ();\n-extern tree size_in_bytes ();\n-extern int int_size_in_bytes ();\n-extern tree size_binop ();\n-extern tree size_int ();\n-extern tree round_up ();\n-extern tree get_pending_sizes ();\n-extern tree get_permanent_types (), get_temporary_types ();\n+extern tree convert\t\t\tPROTO((tree, tree));\n+extern tree size_in_bytes\t\tPROTO((tree));\n+extern int int_size_in_bytes\t\tPROTO((tree));\n+extern tree size_binop\t\t\tPROTO((enum tree_code, tree, tree));\n+extern tree size_int\t\t\tPROTO((unsigned));\n+extern tree round_up\t\t\tPROTO((tree, int));\n+extern tree get_pending_sizes\t\tPROTO((void));\n \n /* Type for sizes of data-type.  */\n \n@@ -1083,157 +1129,145 @@ extern tree sizetype;\n    by making the last node in X point to Y.\n    Returns X, except if X is 0 returns Y.  */\n \n-extern tree chainon ();\n+extern tree chainon\t\t\tPROTO((tree, tree));\n \n /* Make a new TREE_LIST node from specified PURPOSE, VALUE and CHAIN.  */\n \n-extern tree tree_cons (), perm_tree_cons (), temp_tree_cons ();\n-extern tree saveable_tree_cons (), decl_tree_cons ();\n+extern tree tree_cons\t\t\tPROTO((tree, tree, tree));\n+extern tree perm_tree_cons\t\tPROTO((tree, tree, tree));\n+extern tree temp_tree_cons\t\tPROTO((tree, tree, tree));\n+extern tree saveable_tree_cons\t\tPROTO((tree, tree, tree));\n+extern tree decl_tree_cons\t\tPROTO((tree, tree, tree));\n \n /* Return the last tree node in a chain.  */\n \n-extern tree tree_last ();\n+extern tree tree_last\t\t\tPROTO((tree));\n \n /* Reverse the order of elements in a chain, and return the new head.  */\n \n-extern tree nreverse ();\n-\n-/* Make a copy of a chain of tree nodes.  */\n-\n-extern tree copy_chain ();\n+extern tree nreverse\t\t\tPROTO((tree));\n \n /* Returns the length of a chain of nodes\n    (number of chain pointers to follow before reaching a null pointer).  */\n \n-extern int list_length ();\n+extern int list_length\t\t\tPROTO((tree));\n \n /* integer_zerop (tree x) is nonzero if X is an integer constant of value 0 */\n \n-extern int integer_zerop ();\n+extern int integer_zerop\t\tPROTO((tree));\n \n /* integer_onep (tree x) is nonzero if X is an integer constant of value 1 */\n \n-extern int integer_onep ();\n+extern int integer_onep\t\t\tPROTO((tree));\n \n /* integer_all_onesp (tree x) is nonzero if X is an integer constant\n    all of whose significant bits are 1.  */\n \n-extern int integer_all_onesp ();\n+extern int integer_all_onesp\t\tPROTO((tree));\n \n /* integer_pow2p (tree x) is nonzero is X is an integer constant with\n    exactly one bit 1.  */\n \n-extern int integer_pow2p ();\n-\n-/* type_unsigned_p (tree x) is nonzero if the type X is an unsigned type\n-   (all of its possible values are >= 0).\n-   If X is a pointer type, the value is 1.\n-   If X is a real type, the value is 0.  */\n-\n-extern int type_unsigned_p ();\n+extern int integer_pow2p\t\tPROTO((tree));\n \n /* staticp (tree x) is nonzero if X is a reference to data allocated\n    at a fixed address in memory.  */\n \n-extern int staticp ();\n+extern int staticp\t\t\tPROTO((tree));\n \n /* Gets an error if argument X is not an lvalue.\n    Also returns 1 if X is an lvalue, 0 if not.  */\n \n-extern int lvalue_or_else ();\n+extern int lvalue_or_else\t\tPROTO((tree, char *));\n \n /* save_expr (EXP) returns an expression equivalent to EXP\n    but it can be used multiple times within context CTX\n    and only evaluate EXP once.  */\n \n-extern tree save_expr ();\n+extern tree save_expr\t\t\tPROTO((tree));\n \n /* variable_size (EXP) is like save_expr (EXP) except that it\n    is for the special case of something that is part of a\n    variable size for a data type.  It makes special arrangements\n    to compute the value at the right time when the data type\n    belongs to a function parameter.  */\n \n-extern tree variable_size ();\n+extern tree variable_size\t\tPROTO((tree));\n \n /* stabilize_reference (EXP) returns an reference equivalent to EXP\n    but it can be used multiple times\n    and only evaluate the subexpressions once.  */\n \n-extern tree stabilize_reference ();\n+extern tree stabilize_reference\t\tPROTO((tree));\n \n /* Return EXP, stripped of any conversions to wider types\n    in such a way that the result of converting to type FOR_TYPE\n    is the same as if EXP were converted to FOR_TYPE.\n    If FOR_TYPE is 0, it signifies EXP's type.  */\n \n-extern tree get_unwidened ();\n+extern tree get_unwidened\t\tPROTO((tree, tree));\n \n /* Return OP or a simpler expression for a narrower value\n    which can be sign-extended or zero-extended to give back OP.\n    Store in *UNSIGNEDP_PTR either 1 if the value should be zero-extended\n    or 0 if the value should be sign-extended.  */\n \n-extern tree get_narrower ();\n+extern tree get_narrower\t\tPROTO((tree, int *));\n \n /* Given MODE and UNSIGNEDP, return a suitable type-tree\n    with that mode.\n    The definition of this resides in language-specific code\n    as the repertoire of available types may vary.  */\n \n-extern tree type_for_mode ();\n+extern tree type_for_mode\t\tPROTO((enum machine_mode, int));\n \n /* Given PRECISION and UNSIGNEDP, return a suitable type-tree\n    for an integer type with at least that precision.\n    The definition of this resides in language-specific code\n    as the repertoire of available types may vary.  */\n \n-extern tree type_for_size ();\n+extern tree type_for_size\t\tPROTO((unsigned, int));\n \n /* Given an integer type T, return a type like T but unsigned.\n    If T is unsigned, the value is T.\n    The definition of this resides in language-specific code\n    as the repertoire of available types may vary.  */\n \n-extern tree unsigned_type ();\n+extern tree unsigned_type\t\tPROTO((tree));\n \n /* Given an integer type T, return a type like T but signed.\n    If T is signed, the value is T.\n    The definition of this resides in language-specific code\n    as the repertoire of available types may vary.  */\n \n-extern tree signed_type ();\n+extern tree signed_type\t\t\tPROTO((tree));\n \n /* This function must be defined in the language-specific files.\n    expand_expr calls it to build the cleanup-expression for a TARGET_EXPR.\n    This is defined in a language-specific file.  */\n \n-extern tree maybe_build_cleanup ();\n-\n-/* Return the floating type node for a given floating machine mode.  */\n-\n-extern tree get_floating_type ();\n+extern tree maybe_build_cleanup\t\tPROTO((tree));\n \n /* Given an expression EXP that may be a COMPONENT_REF or an ARRAY_REF,\n    look for nested component-refs or array-refs at constant positions\n    and find the ultimate containing object, which is returned.  */\n \n-extern tree get_inner_reference ();\n+extern tree get_inner_reference\t\tPROTO((tree, int *, int *, tree *, enum machine_mode *, int *, int *));\n \n /* Return the FUNCTION_DECL which provides this _DECL with its context,\n    or zero if none.  */\n-extern tree decl_function_context ();\n+extern tree decl_function_context \tPROTO((tree));\n \n /* Return the RECORD_TYPE or UNION_TYPE which provides this _DECL\n    with its context, or zero if none.  */\n-extern tree decl_type_context ();\n+extern tree decl_type_context\t\tPROTO((tree));\n \n /* Given the FUNCTION_DECL for the current function,\n    return zero if it is ok for this function to be inline.\n    Otherwise return a warning message with a single %s\n    for the function's name.  */\n \n-extern char *function_cannot_inline_p ();\n+extern char *function_cannot_inline_p \tPROTO((tree));\n \f\n /* Declare commonly used variables for tree structure.  */\n \n@@ -1303,75 +1337,77 @@ extern int all_types_permanent;\n \n extern char *(*decl_printable_name) ();\n \f\n-/* In expmed.c */\n-extern tree make_tree ();\n-\n /* In stmt.c */\n \n-extern tree expand_start_stmt_expr ();\n-extern tree expand_end_stmt_expr ();\n-extern void expand_expr_stmt (), clear_last_expr ();\n-extern void expand_label (), expand_goto (), expand_asm ();\n-extern void expand_start_cond (), expand_end_cond ();\n-extern void expand_start_else (), expand_start_elseif ();\n-extern struct nesting *expand_start_loop ();\n-extern struct nesting *expand_start_loop_continue_elsewhere ();\n-extern void expand_loop_continue_here ();\n-extern void expand_end_loop ();\n-extern int expand_continue_loop ();\n-extern int expand_exit_loop (), expand_exit_loop_if_false ();\n-extern int expand_exit_something ();\n-\n-extern void expand_start_delayed_expr ();\n-extern tree expand_end_delayed_expr ();\n-extern void expand_emit_delayed_expr ();\n-\n-extern void expand_null_return (), expand_return ();\n-extern void expand_start_bindings (), expand_end_bindings ();\n-extern tree last_cleanup_this_contour ();\n-extern void expand_start_case (), expand_end_case ();\n-extern int pushcase (), pushcase_range ();\n-extern void expand_start_function (), expand_end_function ();\n+extern tree expand_start_stmt_expr\t\tPROTO((void));\n+extern tree expand_end_stmt_expr\t\tPROTO((tree));\n+extern void expand_expr_stmt\t\t\tPROTO((tree));\n+extern void clear_last_expr\t\t\tPROTO((void));\n+extern void expand_label\t\t\tPROTO((tree));\n+extern void expand_goto\t\t\t\tPROTO((tree));\n+extern void expand_asm\t\t\t\tPROTO((tree));\n+extern void expand_start_cond\t\t\tPROTO((tree, int));\n+extern void expand_end_cond\t\t\tPROTO((void));\n+extern void expand_start_else\t\t\tPROTO((void));\n+extern void expand_start_elseif\t\t\tPROTO((tree));\n+extern struct nesting *expand_start_loop \tPROTO((int));\n+extern struct nesting *expand_start_loop_continue_elsewhere \tPROTO((int));\n+extern void expand_loop_continue_here\t\tPROTO((void));\n+extern void expand_end_loop\t\t\tPROTO((void));\n+extern int expand_continue_loop\t\t\tPROTO((struct nesting *));\n+extern int expand_exit_loop\t\t\tPROTO((struct nesting *));\n+extern int expand_exit_loop_if_false\t\tPROTO((struct nesting *, tree));\n+extern int expand_exit_something\t\tPROTO((void));\n+\n+extern void expand_null_return\t\t\tPROTO((void));\n+extern void expand_return\t\t\tPROTO((tree));\n+extern void expand_start_bindings\t\tPROTO((int));\n+extern void expand_end_bindings\t\t\tPROTO((tree, int, int));\n+extern tree last_cleanup_this_contour\t\tPROTO((void));\n+extern void expand_start_case\t\t\tPROTO((int, tree, tree, char *));\n+extern void expand_end_case\t\t\tPROTO((tree));\n+extern int pushcase\t\t\t\tPROTO((tree, tree, tree *));\n+extern int pushcase_range\t\t\tPROTO((tree, tree, tree, tree *));\n \n /* In fold-const.c */\n \n-extern tree invert_truthvalue ();\n+extern tree invert_truthvalue\t\t\tPROTO((tree));\n \f\n /* The language front-end must define these functions.  */\n \n /* Function of no arguments for initializing lexical scanning.  */\n-extern void init_lex ();\n+extern void init_lex\t\t\t\tPROTO((void));\n /* Function of no arguments for initializing the symbol table.  */\n-extern void init_decl_processing ();\n+extern void init_decl_processing\t\tPROTO((void));\n \n /* Functions called with no arguments at the beginning and end or processing\n    the input source file.  */\n-extern void lang_init ();\n-extern void lang_finish ();\n+extern void lang_init\t\t\t\tPROTO((void));\n+extern void lang_finish\t\t\t\tPROTO((void));\n \n /* Function called with no arguments to parse and compile the input.  */\n-extern int yyparse ();\n+extern int yyparse\t\t\t\tPROTO((void));\n /* Function called with option as argument\n    to decode options starting with -f or -W or +.\n    It should return nonzero if it handles the option.  */\n-extern int lang_decode_option ();\n+extern int lang_decode_option\t\t\tPROTO((char *));\n \n /* Functions for processing symbol declarations.  */\n /* Function to enter a new lexical scope.\n    Takes one argument: always zero when called from outside the front end.  */\n-extern void pushlevel ();\n+extern void pushlevel\t\t\t\tPROTO((int));\n /* Function to exit a lexical scope.  It returns a BINDING for that scope.\n    Takes three arguments:\n      KEEP -- nonzero if there were declarations in this scope.\n      REVERSE -- reverse the order of decls before returning them.\n      FUNCTIONBODY -- nonzero if this level is the body of a function.  */\n-extern tree poplevel ();\n+extern tree poplevel\t\t\t\tPROTO((int, int, int));\n /* Function to add a decl to the current scope level.\n    Takes one argument, a decl to add.\n    Returns that decl, or, if the same symbol is already declared, may\n    return a different decl for that name.  */\n-extern tree pushdecl ();\n+extern tree pushdecl\t\t\t\tPROTO((tree));\n /* Function to return the chain of decls so far in the current scope level.  */\n-extern tree getdecls ();\n+extern tree getdecls\t\t\t\tPROTO((void));\n /* Function to return the chain of structure tags in the current scope level.  */\n-extern tree gettags ();\n+extern tree gettags\t\t\t\tPROTO((void));"}]}