{"sha": "a918548079a2af0db87abf7611aac4ab4b691c39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTkxODU0ODA3OWEyYWYwZGI4N2FiZjc2MTFhYWM0YWI0YjY5MWMzOQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-11-29T19:26:49Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-11-29T19:26:49Z"}, "message": "sse.md (UNSPEC_MASKOP): Move from i386.md.\n\n\t* config/i386/sse.md (UNSPEC_MASKOP): Move from i386.md.\n\t(mshift): Ditto.\n\t(SWI1248_AVX512BWDQ): Ditto.\n\t(SWI1248_AVX512BW): Ditto.\n\t(k<any_logic:code><mode>): Ditto.\n\t(kandn<mode>): Ditto.\n\t(kxnor<mode>): Ditto.\n\t(knot<mode>): Ditto.\n\t(*k<any_lshift:code><mode>): Ditto.\n\t(kortestzhi, kortestchi): Ditto.\n\t(kunpckhi, kunpcksi, kunpckdi): Ditto.\n\ntestsuite/ChangeLog:\n\n\t* gcc.target/i386/avx512f-kmovw-1.c (avx512f_test):\n\tForce value through k register.\n\nFrom-SVN: r242971", "tree": {"sha": "6472418120382b43ae6dc06563dedc1d47e270f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6472418120382b43ae6dc06563dedc1d47e270f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a918548079a2af0db87abf7611aac4ab4b691c39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a918548079a2af0db87abf7611aac4ab4b691c39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a918548079a2af0db87abf7611aac4ab4b691c39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a918548079a2af0db87abf7611aac4ab4b691c39/comments", "author": null, "committer": null, "parents": [{"sha": "28ea3e977ce07c1d0ad14c188336419288fce8d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28ea3e977ce07c1d0ad14c188336419288fce8d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28ea3e977ce07c1d0ad14c188336419288fce8d1"}], "stats": {"total": 420, "additions": 225, "deletions": 195}, "files": [{"sha": "f9bcdbd9e49f97b696c405b410256d14da2d6777", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a918548079a2af0db87abf7611aac4ab4b691c39/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a918548079a2af0db87abf7611aac4ab4b691c39/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a918548079a2af0db87abf7611aac4ab4b691c39", "patch": "@@ -1,3 +1,17 @@\n+2016-11-29  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/sse.md (UNSPEC_MASKOP): Move from i386.md.\n+\t(mshift): Ditto.\n+\t(SWI1248_AVX512BWDQ): Ditto.\n+\t(SWI1248_AVX512BW): Ditto.\n+\t(k<any_logic:code><mode>): Ditto.\n+\t(kandn<mode>): Ditto.\n+\t(kxnor<mode>): Ditto.\n+\t(knot<mode>): Ditto.\n+\t(*k<any_lshift:code><mode>): Ditto.\n+\t(kortestzhi, kortestchi): Ditto.\n+\t(kunpckhi, kunpcksi, kunpckdi): Ditto.\n+\n 2016-11-29  Andrew Pinski  <apinski@cavium.com>\n \n \t* tree-vrp.c (simplify_stmt_using_ranges): Use boolean_type_node\n@@ -16,8 +30,9 @@\n \t* config/avr/avr-devices.c(avr_mcu_types): Add flash size info.\n \t* config/avr/avr-mcu.def: Likewise.\n \t* config/avr/gen-avr-mmcu-specs.c (print_mcu): Remove hard-coded prefix\n-\tcheck to find wrap-around value, instead use MCU flash size. For 8k flash\n-\tdevices, update link_pmem_wrap spec string to add --pmem-wrap-around=8k.\n+\tcheck to find wrap-around value, instead use MCU flash size. For 8k\n+\tflash devices, update link_pmem_wrap spec string to add\n+\t--pmem-wrap-around=8k.\n \t* config/avr/specs.h: Remove link_pmem_wrap from LINK_RELAX_SPEC and\n \tadd to linker specs (LINK_SPEC) directly.\n \n@@ -202,9 +217,8 @@\n \n 2016-11-28  Richard Biener  <rguenther@suse.de>\n \n-\t* tree-vrp.c (vrp_visit_assignment_or_call): Handle\n-\tsimplifications to SSA names via extract_range_from_ssa_name\n-\tif allowed.\n+\t* tree-vrp.c (vrp_visit_assignment_or_call): Handle simplifications\n+\tto SSA names via extract_range_from_ssa_name if allowed.\n \n 2016-11-28  Richard Biener  <rguenther@suse.de>\n \n@@ -214,9 +228,8 @@\n \n 2016-11-28  Paolo Bonzini  <bonzini@gnu.org>\n \n-\t* combine.c (simplify_if_then_else): Simplify IF_THEN_ELSE\n-\tthat isolates a single bit, even if the condition involves\n-\tsubregs.\n+\t* combine.c (simplify_if_then_else): Simplify IF_THEN_ELSE that\n+\tisolates a single bit, even if the condition involves subregs.\n \n 2016-11-28  Tamar Christina  <tamar.christina@arm.com>\n \n@@ -305,6 +318,7 @@\n \t(vdupq_laneq_p64): Likewise.\n \n 2016-11-28  Tamar Christina  <tamar.christina@arm.com>\n+\n \t* config/arm/arm_neon.h (vget_lane_p64): New.\n \n 2016-11-28  Iain Sandoe  <iain@codesourcery.com>"}, {"sha": "ed525b97a3dc7b563646b9036393b3e59fbd6472", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 0, "deletions": 184, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a918548079a2af0db87abf7611aac4ab4b691c39/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a918548079a2af0db87abf7611aac4ab4b691c39/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=a918548079a2af0db87abf7611aac4ab4b691c39", "patch": "@@ -186,9 +186,6 @@\n   UNSPEC_PDEP\n   UNSPEC_PEXT\n \n-  ;; For AVX512F support\n-  UNSPEC_KMASKOP\n-\n   UNSPEC_BNDMK\n   UNSPEC_BNDMK_ADDR\n   UNSPEC_BNDSTX\n@@ -921,9 +918,6 @@\n (define_code_attr shift [(ashift \"sll\") (lshiftrt \"shr\") (ashiftrt \"sar\")])\n (define_code_attr vshift [(ashift \"sll\") (lshiftrt \"srl\") (ashiftrt \"sra\")])\n \n-;; Mask variant left right mnemonics\n-(define_code_attr mshift [(ashift \"shiftl\") (lshiftrt \"shiftr\")])\n-\n ;; Mapping of rotate operators\n (define_code_iterator any_rotate [rotate rotatert])\n \n@@ -966,15 +960,6 @@\n ;; All integer modes.\n (define_mode_iterator SWI1248x [QI HI SI DI])\n \n-;; All integer modes with AVX512BW/DQ.\n-(define_mode_iterator SWI1248_AVX512BWDQ\n-  [(QI \"TARGET_AVX512DQ\") HI (SI \"TARGET_AVX512BW\") (DI \"TARGET_AVX512BW\")])\n-\n-;; All integer modes with AVX512BW, where HImode operation\n-;; can be used instead of QImode.\n-(define_mode_iterator SWI1248_AVX512BW\n-  [QI HI (SI \"TARGET_AVX512BW\") (DI \"TARGET_AVX512BW\")])\n-\n ;; All integer modes without QImode.\n (define_mode_iterator SWI248x [HI SI DI])\n \n@@ -2489,11 +2474,6 @@\n \t   ]\n \t   (const_string \"SI\")))])\n \n-(define_expand \"kmovw\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\")\n-\t(match_operand:HI 1 \"nonimmediate_operand\"))]\n-  \"TARGET_AVX512F && !(MEM_P (operands[0]) && MEM_P (operands[1]))\")\n-\n (define_insn \"*movhi_internal\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r ,r ,m ,k,k ,r,m\")\n \t(match_operand:HI 1 \"general_operand\"      \"r ,rn,rm,rn,r,km,k,k\"))]\n@@ -8061,28 +8041,6 @@\n   operands[3] = gen_lowpart (QImode, operands[3]);\n })\n \n-(define_insn \"k<code><mode>\"\n-  [(set (match_operand:SWI1248_AVX512BW 0 \"register_operand\" \"=k\")\n-\t(any_logic:SWI1248_AVX512BW\n-\t  (match_operand:SWI1248_AVX512BW 1 \"register_operand\" \"k\")\n-\t  (match_operand:SWI1248_AVX512BW 2 \"register_operand\" \"k\")))\n-   (unspec [(const_int 0)] UNSPEC_KMASKOP)]\n-  \"TARGET_AVX512F\"\n-{\n-  if (get_attr_mode (insn) == MODE_HI)\n-    return \"k<logic>w\\t{%2, %1, %0|%0, %1, %2}\";\n-  else\n-    return \"k<logic><mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\";\n-}\n-  [(set_attr \"type\" \"msklog\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set (attr \"mode\")\n-     (cond [(and (match_test \"<MODE>mode == QImode\")\n-\t\t (not (match_test \"TARGET_AVX512DQ\")))\n-\t       (const_string \"HI\")\n-\t   ]\n-\t   (const_string \"<MODE>\")))])\n-\n ;; %%% This used to optimize known byte-wide and operations to memory,\n ;; and sometimes to QImode registers.  If this is considered useful,\n ;; it should be done with splitters.\n@@ -8576,29 +8534,6 @@\n   operands[2] = gen_lowpart (QImode, operands[2]);\n })\n \n-(define_insn \"kandn<mode>\"\n-  [(set (match_operand:SWI1248_AVX512BW 0 \"register_operand\" \"=k\")\n-\t(and:SWI1248_AVX512BW\n-\t  (not:SWI1248_AVX512BW\n-\t    (match_operand:SWI1248_AVX512BW 1 \"register_operand\" \"k\"))\n-\t  (match_operand:SWI1248_AVX512BW 2 \"register_operand\" \"k\")))\n-   (unspec [(const_int 0)] UNSPEC_KMASKOP)]\n-  \"TARGET_AVX512F\"\n-{\n-  if (get_attr_mode (insn) == MODE_HI)\n-    return \"kandnw\\t{%2, %1, %0|%0, %1, %2}\";\n-  else\n-    return \"kandn<mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\";\n-}\n-  [(set_attr \"type\" \"msklog\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set (attr \"mode\")\n-     (cond [(and (match_test \"<MODE>mode == QImode\")\n-\t\t (not (match_test \"TARGET_AVX512DQ\")))\n-\t      (const_string \"HI\")\n-\t   ]\n-\t   (const_string \"<MODE>\")))])\n-\n (define_insn_and_split \"*andndi3_doubleword\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(and:DI\n@@ -8987,92 +8922,6 @@\n    (set_attr \"type\" \"alu\")\n    (set_attr \"modrm\" \"1\")\n    (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"kxnor<mode>\"\n-  [(set (match_operand:SWI1248_AVX512BW 0 \"register_operand\" \"=k\")\n-\t(not:SWI1248_AVX512BW\n-\t  (xor:SWI1248_AVX512BW\n-\t    (match_operand:SWI1248_AVX512BW 1 \"register_operand\" \"k\")\n-\t    (match_operand:SWI1248_AVX512BW 2 \"register_operand\" \"k\"))))\n-   (unspec [(const_int 0)] UNSPEC_KMASKOP)]\n-  \"TARGET_AVX512F\"\n-{\n-  if (get_attr_mode (insn) == MODE_HI)\n-    return \"kxnorw\\t{%2, %1, %0|%0, %1, %2}\";\n-  else\n-    return \"kxnor<mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\";\n-}\n-  [(set_attr \"type\" \"msklog\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set (attr \"mode\")\n-     (cond [(and (match_test \"<MODE>mode == QImode\")\n-\t\t (not (match_test \"TARGET_AVX512DQ\")))\n-\t      (const_string \"HI\")\n-\t   ]\n-\t   (const_string \"<MODE>\")))])\n-\n-;;There are kortrest[bdq] but no intrinsics for them.\n-;;We probably don't need to implement them.\n-(define_insn \"kortestzhi\"\n-  [(set (reg:CCZ FLAGS_REG)\n-\t(compare:CCZ\n-\t  (ior:HI\n-\t    (match_operand:HI 0 \"register_operand\" \"k\")\n-\t    (match_operand:HI 1 \"register_operand\" \"k\"))\n-\t  (const_int 0)))]\n-  \"TARGET_AVX512F && ix86_match_ccmode (insn, CCZmode)\"\n-  \"kortestw\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"mode\" \"HI\")\n-   (set_attr \"type\" \"msklog\")\n-   (set_attr \"prefix\" \"vex\")])\n-\n-(define_insn \"kortestchi\"\n-  [(set (reg:CCC FLAGS_REG)\n-\t(compare:CCC\n-\t  (ior:HI\n-\t    (match_operand:HI 0 \"register_operand\" \"k\")\n-\t    (match_operand:HI 1 \"register_operand\" \"k\"))\n-\t  (const_int -1)))]\n-  \"TARGET_AVX512F && ix86_match_ccmode (insn, CCCmode)\"\n-  \"kortestw\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"mode\" \"HI\")\n-   (set_attr \"type\" \"msklog\")\n-   (set_attr \"prefix\" \"vex\")])\n-\n-(define_insn \"kunpckhi\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=k\")\n-\t(ior:HI\n-\t  (ashift:HI\n-\t    (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"k\"))\n-\t    (const_int 8))\n-\t  (zero_extend:HI (match_operand:QI 2 \"register_operand\" \"k\"))))]\n-  \"TARGET_AVX512F\"\n-  \"kunpckbw\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"mode\" \"HI\")\n-   (set_attr \"type\" \"msklog\")\n-   (set_attr \"prefix\" \"vex\")])\n-\n-(define_insn \"kunpcksi\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=k\")\n-\t(ior:SI\n-\t  (ashift:SI\n-\t    (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"k\"))\n-\t    (const_int 16))\n-\t  (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"k\"))))]\n-  \"TARGET_AVX512BW\"\n-  \"kunpckwd\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"kunpckdi\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=k\")\n-\t(ior:DI\n-\t  (ashift:DI\n-\t    (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"k\"))\n-\t    (const_int 32))\n-\t  (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"k\"))))]\n-  \"TARGET_AVX512BW\"\n-  \"kunpckdq\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"mode\" \"DI\")])\n \f\n ;; Negation instructions\n \n@@ -9463,27 +9312,6 @@\n \f\n ;; One complement instructions\n \n-(define_insn \"knot<mode>\"\n-  [(set (match_operand:SWI1248_AVX512BW 0 \"register_operand\" \"=k\")\n-\t(not:SWI1248_AVX512BW\n-\t  (match_operand:SWI1248_AVX512BW 1 \"register_operand\" \"k\")))\n-   (unspec [(const_int 0)] UNSPEC_KMASKOP)]\n-  \"TARGET_AVX512F\"\n-{\n-  if (get_attr_mode (insn) == MODE_HI)\n-    return \"knotw\\t{%1, %0|%0, %1}\";\n-  else\n-    return \"knot<mskmodesuffix>\\t{%1, %0|%0, %1}\";\n-}\n-  [(set_attr \"type\" \"msklog\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set (attr \"mode\")\n-     (cond [(and (match_test \"<MODE>mode == QImode\")\n-\t\t (not (match_test \"TARGET_AVX512DQ\")))\n-\t       (const_string \"HI\")\n-\t   ]\n-\t   (const_string \"<MODE>\")))])\n-\n (define_expand \"one_cmpl<mode>2\"\n   [(set (match_operand:SWIM 0 \"nonimmediate_operand\")\n \t(not:SWIM (match_operand:SWIM 1 \"nonimmediate_operand\")))]\n@@ -9600,18 +9428,6 @@\n ;; shift pair, instead using moves and sign extension for counts greater\n ;; than 31.\n \n-(define_insn \"*k<code><mode>\"\n-  [(set (match_operand:SWI1248_AVX512BWDQ 0 \"register_operand\" \"=k\")\n-\t(any_lshift:SWI1248_AVX512BWDQ\n-\t  (match_operand:SWI1248_AVX512BWDQ 1 \"register_operand\" \"k\")\n-\t  (match_operand:QI 2 \"immediate_operand\" \"n\")))\n-   (unspec [(const_int 0)] UNSPEC_KMASKOP)]\n-  \"TARGET_AVX512F\"\n-  \"k<mshift><mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"msklog\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n (define_expand \"ashl<mode>3\"\n   [(set (match_operand:SDWIM 0 \"<shift_operand>\")\n \t(ashift:SDWIM (match_operand:SDWIM 1 \"<ashl_input_operand>\")"}, {"sha": "454aeca75e10e4b80fa582c0bbe8784c75a71b39", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 194, "deletions": 2, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a918548079a2af0db87abf7611aac4ab4b691c39/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a918548079a2af0db87abf7611aac4ab4b691c39/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=a918548079a2af0db87abf7611aac4ab4b691c39", "patch": "@@ -106,6 +106,9 @@\n   UNSPEC_MASKED_EQ\n   UNSPEC_MASKED_GT\n \n+  ;; Mask operations\n+  UNSPEC_MASKOP\n+\n   ;; For embed. rounding feature\n   UNSPEC_EMBEDDED_ROUNDING\n \n@@ -1288,6 +1291,195 @@\n \t  UNSPEC_MOVNT))]\n   \"TARGET_SSE\")\n \n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;\n+;; Mask operations\n+;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; All integer modes with AVX512BW/DQ.\n+(define_mode_iterator SWI1248_AVX512BWDQ\n+  [(QI \"TARGET_AVX512DQ\") HI (SI \"TARGET_AVX512BW\") (DI \"TARGET_AVX512BW\")])\n+\n+;; All integer modes with AVX512BW, where HImode operation\n+;; can be used instead of QImode.\n+(define_mode_iterator SWI1248_AVX512BW\n+  [QI HI (SI \"TARGET_AVX512BW\") (DI \"TARGET_AVX512BW\")])\n+\n+;; Mask variant shift mnemonics\n+(define_code_attr mshift [(ashift \"shiftl\") (lshiftrt \"shiftr\")])\n+\n+(define_expand \"kmovw\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\")\n+\t(match_operand:HI 1 \"nonimmediate_operand\"))]\n+  \"TARGET_AVX512F\n+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\")\n+\n+(define_insn \"k<code><mode>\"\n+  [(set (match_operand:SWI1248_AVX512BW 0 \"register_operand\" \"=k\")\n+\t(any_logic:SWI1248_AVX512BW\n+\t  (match_operand:SWI1248_AVX512BW 1 \"register_operand\" \"k\")\n+\t  (match_operand:SWI1248_AVX512BW 2 \"register_operand\" \"k\")))\n+   (unspec [(const_int 0)] UNSPEC_MASKOP)]\n+  \"TARGET_AVX512F\"\n+{\n+  if (get_attr_mode (insn) == MODE_HI)\n+    return \"k<logic>w\\t{%2, %1, %0|%0, %1, %2}\";\n+  else\n+    return \"k<logic><mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\";\n+}\n+  [(set_attr \"type\" \"msklog\")\n+   (set_attr \"prefix\" \"vex\")\n+   (set (attr \"mode\")\n+     (cond [(and (match_test \"<MODE>mode == QImode\")\n+\t\t (not (match_test \"TARGET_AVX512DQ\")))\n+\t       (const_string \"HI\")\n+\t   ]\n+\t   (const_string \"<MODE>\")))])\n+\n+(define_insn \"kandn<mode>\"\n+  [(set (match_operand:SWI1248_AVX512BW 0 \"register_operand\" \"=k\")\n+\t(and:SWI1248_AVX512BW\n+\t  (not:SWI1248_AVX512BW\n+\t    (match_operand:SWI1248_AVX512BW 1 \"register_operand\" \"k\"))\n+\t  (match_operand:SWI1248_AVX512BW 2 \"register_operand\" \"k\")))\n+   (unspec [(const_int 0)] UNSPEC_MASKOP)]\n+  \"TARGET_AVX512F\"\n+{\n+  if (get_attr_mode (insn) == MODE_HI)\n+    return \"kandnw\\t{%2, %1, %0|%0, %1, %2}\";\n+  else\n+    return \"kandn<mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\";\n+}\n+  [(set_attr \"type\" \"msklog\")\n+   (set_attr \"prefix\" \"vex\")\n+   (set (attr \"mode\")\n+     (cond [(and (match_test \"<MODE>mode == QImode\")\n+\t\t (not (match_test \"TARGET_AVX512DQ\")))\n+\t      (const_string \"HI\")\n+\t   ]\n+\t   (const_string \"<MODE>\")))])\n+\n+(define_insn \"kxnor<mode>\"\n+  [(set (match_operand:SWI1248_AVX512BW 0 \"register_operand\" \"=k\")\n+\t(not:SWI1248_AVX512BW\n+\t  (xor:SWI1248_AVX512BW\n+\t    (match_operand:SWI1248_AVX512BW 1 \"register_operand\" \"k\")\n+\t    (match_operand:SWI1248_AVX512BW 2 \"register_operand\" \"k\"))))\n+   (unspec [(const_int 0)] UNSPEC_MASKOP)]\n+  \"TARGET_AVX512F\"\n+{\n+  if (get_attr_mode (insn) == MODE_HI)\n+    return \"kxnorw\\t{%2, %1, %0|%0, %1, %2}\";\n+  else\n+    return \"kxnor<mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\";\n+}\n+  [(set_attr \"type\" \"msklog\")\n+   (set_attr \"prefix\" \"vex\")\n+   (set (attr \"mode\")\n+     (cond [(and (match_test \"<MODE>mode == QImode\")\n+\t\t (not (match_test \"TARGET_AVX512DQ\")))\n+\t      (const_string \"HI\")\n+\t   ]\n+\t   (const_string \"<MODE>\")))])\n+\n+(define_insn \"knot<mode>\"\n+  [(set (match_operand:SWI1248_AVX512BW 0 \"register_operand\" \"=k\")\n+\t(not:SWI1248_AVX512BW\n+\t  (match_operand:SWI1248_AVX512BW 1 \"register_operand\" \"k\")))\n+   (unspec [(const_int 0)] UNSPEC_MASKOP)]\n+  \"TARGET_AVX512F\"\n+{\n+  if (get_attr_mode (insn) == MODE_HI)\n+    return \"knotw\\t{%1, %0|%0, %1}\";\n+  else\n+    return \"knot<mskmodesuffix>\\t{%1, %0|%0, %1}\";\n+}\n+  [(set_attr \"type\" \"msklog\")\n+   (set_attr \"prefix\" \"vex\")\n+   (set (attr \"mode\")\n+     (cond [(and (match_test \"<MODE>mode == QImode\")\n+\t\t (not (match_test \"TARGET_AVX512DQ\")))\n+\t       (const_string \"HI\")\n+\t   ]\n+\t   (const_string \"<MODE>\")))])\n+\n+(define_insn \"*k<code><mode>\"\n+  [(set (match_operand:SWI1248_AVX512BWDQ 0 \"register_operand\" \"=k\")\n+\t(any_lshift:SWI1248_AVX512BWDQ\n+\t  (match_operand:SWI1248_AVX512BWDQ 1 \"register_operand\" \"k\")\n+\t  (match_operand:QI 2 \"immediate_operand\" \"n\")))\n+   (unspec [(const_int 0)] UNSPEC_MASKOP)]\n+  \"TARGET_AVX512F\"\n+  \"k<mshift><mskmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"type\" \"msklog\")\n+   (set_attr \"prefix\" \"vex\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;;There are kortrest[bdq] but no intrinsics for them.\n+;;We probably don't need to implement them.\n+(define_insn \"kortestzhi\"\n+  [(set (reg:CCZ FLAGS_REG)\n+\t(compare:CCZ\n+\t  (ior:HI\n+\t    (match_operand:HI 0 \"register_operand\" \"k\")\n+\t    (match_operand:HI 1 \"register_operand\" \"k\"))\n+\t  (const_int 0)))]\n+  \"TARGET_AVX512F && ix86_match_ccmode (insn, CCZmode)\"\n+  \"kortestw\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"mode\" \"HI\")\n+   (set_attr \"type\" \"msklog\")\n+   (set_attr \"prefix\" \"vex\")])\n+\n+(define_insn \"kortestchi\"\n+  [(set (reg:CCC FLAGS_REG)\n+\t(compare:CCC\n+\t  (ior:HI\n+\t    (match_operand:HI 0 \"register_operand\" \"k\")\n+\t    (match_operand:HI 1 \"register_operand\" \"k\"))\n+\t  (const_int -1)))]\n+  \"TARGET_AVX512F && ix86_match_ccmode (insn, CCCmode)\"\n+  \"kortestw\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"mode\" \"HI\")\n+   (set_attr \"type\" \"msklog\")\n+   (set_attr \"prefix\" \"vex\")])\n+\n+(define_insn \"kunpckhi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=k\")\n+\t(ior:HI\n+\t  (ashift:HI\n+\t    (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"k\"))\n+\t    (const_int 8))\n+\t  (zero_extend:HI (match_operand:QI 2 \"register_operand\" \"k\"))))]\n+  \"TARGET_AVX512F\"\n+  \"kunpckbw\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"mode\" \"HI\")\n+   (set_attr \"type\" \"msklog\")\n+   (set_attr \"prefix\" \"vex\")])\n+\n+(define_insn \"kunpcksi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=k\")\n+\t(ior:SI\n+\t  (ashift:SI\n+\t    (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"k\"))\n+\t    (const_int 16))\n+\t  (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"k\"))))]\n+  \"TARGET_AVX512BW\"\n+  \"kunpckwd\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"kunpckdi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=k\")\n+\t(ior:DI\n+\t  (ashift:DI\n+\t    (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"k\"))\n+\t    (const_int 32))\n+\t  (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"k\"))))]\n+  \"TARGET_AVX512BW\"\n+  \"kunpckdq\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"mode\" \"DI\")])\n+\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Parallel floating point arithmetic\n@@ -13716,7 +13908,7 @@\n      [(set (subreg:HI (match_operand:QI 0 \"register_operand\") 0)\n \t   (lshiftrt:HI (match_operand:HI 1 \"register_operand\")\n \t\t\t(const_int 8)))\n-      (unspec [(const_int 0)] UNSPEC_KMASKOP)])]\n+      (unspec [(const_int 0)] UNSPEC_MASKOP)])]\n   \"TARGET_AVX512F\")\n \n (define_expand \"vec_unpacks_hi_<mode>\"\n@@ -13725,7 +13917,7 @@\n \t     (match_operand:<HALFMASKMODE> 0 \"register_operand\") 0)\n \t   (lshiftrt:SWI48x (match_operand:SWI48x 1 \"register_operand\")\n \t\t\t    (match_dup 2)))\n-      (unspec [(const_int 0)] UNSPEC_KMASKOP)])]\n+      (unspec [(const_int 0)] UNSPEC_MASKOP)])]\n   \"TARGET_AVX512BW\"\n   \"operands[2] = GEN_INT (GET_MODE_BITSIZE (<HALFMASKMODE>mode));\")\n "}, {"sha": "c86c345055ef33122901fbf4639a8dec83f7a266", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a918548079a2af0db87abf7611aac4ab4b691c39/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a918548079a2af0db87abf7611aac4ab4b691c39/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a918548079a2af0db87abf7611aac4ab4b691c39", "patch": "@@ -1,3 +1,8 @@\n+2016-11-29  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* gcc.target/i386/avx512f-kmovw-1.c (avx512f_test):\n+\tForce value through k register.\n+\n 2016-11-29  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c++/72774"}, {"sha": "95173e9b5267b93c006962187566ab498379f086", "filename": "gcc/testsuite/gcc.target/i386/avx512f-kmovw-1.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a918548079a2af0db87abf7611aac4ab4b691c39/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-kmovw-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a918548079a2af0db87abf7611aac4ab4b691c39/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-kmovw-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-kmovw-1.c?ref=a918548079a2af0db87abf7611aac4ab4b691c39", "patch": "@@ -8,5 +8,8 @@ volatile __mmask16 k1;\n void\n avx512f_test ()\n {\n-  k1 = _mm512_kmov (11);\n+  __mmask16 k = _mm512_kmov (11);\n+\n+  asm volatile (\"\" : \"+k\" (k));\n+  k1 = k;\n }"}]}