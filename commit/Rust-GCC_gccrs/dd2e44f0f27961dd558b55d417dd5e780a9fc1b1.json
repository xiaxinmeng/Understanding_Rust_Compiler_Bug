{"sha": "dd2e44f0f27961dd558b55d417dd5e780a9fc1b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQyZTQ0ZjBmMjc5NjFkZDU1OGI1NWQ0MTdkZDVlNzgwYTlmYzFiMQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2011-02-13T19:57:30Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2011-02-13T19:57:30Z"}, "message": "Revert r170108, r170107, r170105, r170104, r170103, r170102, r170101, r170097.\n\nFrom-SVN: r170111", "tree": {"sha": "e332e1f123e28733bb97d60233db347e42ccc4bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e332e1f123e28733bb97d60233db347e42ccc4bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "975b975b29fa2aa9dd562a55006a4cd93421a652", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/975b975b29fa2aa9dd562a55006a4cd93421a652", "html_url": "https://github.com/Rust-GCC/gccrs/commit/975b975b29fa2aa9dd562a55006a4cd93421a652"}], "stats": {"total": 5178, "additions": 2441, "deletions": 2737}, "files": [{"sha": "de8e127fdb6335a1615cd0b2b3bd9d989bc8364b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dd2e44f0f27961dd558b55d417dd5e780a9fc1b1", "patch": "@@ -1,24 +1,7 @@\n-2011-02-13  Mike Stump  <mikestump@comcast.net>\n-\n-\t* config/t-darwin (build/slashify1): Harden against rebuilds.\n-\t(config/darwin.h.rebuild): Harden against parallel builds.\n-\t* config/slashify.c: Nix parms to quite the build.\n-\n 2011-02-13  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* configure: Regenerate.\n \n-2011-02-12  Mike Stump  <mikestump@comcast.net>\n-\n-\t* config/t-darwin (build/slashify): Allow others to reuse easier.\n-\n-2011-02-12  Mike Stump  <mikestump@comcast.net>\n-\n-\t* config/darwin.h: Make pretty.\n-\t* config/t-darwin (config/darwin.h.rebuild): Add.\n-\t(build/slashify): Add.\n-\t* config/slashify.c: Add.\n-\n 2011-02-12  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR driver/45731\n@@ -67,7 +50,7 @@\n 2011-02-12  Iain Sandoe  <iains@gcc.gnu.org>\n \n \t* config/darwin.c (darwin_override_options): Add a hunk missed\n-\tfrom the commit of r168571.  Trim comment line lengths and\n+\tfrom the commit of r168571.  Trim comment line lengths and \n \tcorrect indents of the preceding block.\n \n 2011-02-12  Iain Sandoe  <iains@gcc.gnu.org>"}, {"sha": "778ff1e3023ea38855919a3a6074183ea0db4ffe", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 413, "deletions": 415, "changes": 828, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=dd2e44f0f27961dd558b55d417dd5e780a9fc1b1", "patch": "@@ -123,47 +123,46 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n /* True if pragma ms_struct is in effect.  */\n extern GTY(()) int darwin_ms_struct;\n \n-#define DRIVER_SELF_SPECS @(\n-  \"%{gfull:-g -fno-eliminate-unused-debug-symbols} %<gfull\",\n-  \"%{gused:-g -feliminate-unused-debug-symbols} %<gused\",\n-  \"%{fapple-kext|mkernel:-static}\",\n-  \"%{shared:-Zdynamiclib} %<shared\"@)\n-\n-#define DARWIN_CC1_SPEC @(\n-  \"%{findirect-virtual-calls: -fapple-kext} %<findirect-virtual-calls \"\n-  \"%{fterminated-vtables: -fapple-kext} %<fterminated-vtables \"\n-  \"%<filelist* %<framework*\"@)\n-\n-#define SUBSUBTARGET_OVERRIDE_OPTIONS @(\n-  do {\n-    darwin_override_options ();\n-  } while (0)@)\n-\n-#define SUBTARGET_C_COMMON_OVERRIDE_OPTIONS @(\n-  do {\n-    /* Sort out ObjC exceptions: If the runtime is NeXT we default to\n-       sjlj for m32 only.  */\n-    if (!global_options_set.x_flag_objc_sjlj_exceptions)\n-      global_options.x_flag_objc_sjlj_exceptions\n-\t= flag_next_runtime && !TARGET_64BIT;\n-    if (flag_mkernel || flag_apple_kext)\n-      {\n-\tif (flag_use_cxa_atexit == 2)\n-\t  flag_use_cxa_atexit = 0;\n-\t/* kexts should always be built without the coalesced sections\n-\t   because the kernel loader doesn't grok such sections.  */\n-\tflag_weak = 0;\n-\t/* No RTTI in kexts.  */\n-\tflag_rtti = 0;\n-      }\n-  } while (0)@)\n+#define DRIVER_SELF_SPECS\t\t\t\t\t\\\n+  \"%{gfull:-g -fno-eliminate-unused-debug-symbols} %<gfull\",\t\\\n+  \"%{gused:-g -feliminate-unused-debug-symbols} %<gused\",\t\\\n+  \"%{fapple-kext|mkernel:-static}\",\t\t\t\t\\\n+  \"%{shared:-Zdynamiclib} %<shared\"\n+\n+#define DARWIN_CC1_SPEC\t\t\t\t\t\t\t\\\n+  \"%{findirect-virtual-calls: -fapple-kext} %<findirect-virtual-calls \" \\\n+  \"%{fterminated-vtables: -fapple-kext} %<fterminated-vtables \"\t\t\\\n+  \"%<filelist* %<framework*\"\n+\n+#define SUBSUBTARGET_OVERRIDE_OPTIONS\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    darwin_override_options ();\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define SUBTARGET_C_COMMON_OVERRIDE_OPTIONS do {                        \\\n+  /* Sort out ObjC exceptions: If the runtime is NeXT we default to\t\\\n+     sjlj for m32 only.  */\t\t\t\t\t\t\\\n+  if (!global_options_set.x_flag_objc_sjlj_exceptions)\t\t\t\\\n+    global_options.x_flag_objc_sjlj_exceptions = \t\t\t\\\n+\t\t\t\tflag_next_runtime && !TARGET_64BIT;\t\\\n+    if (flag_mkernel || flag_apple_kext)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (flag_use_cxa_atexit == 2)\t\t\t\t\t\\\n+\t  flag_use_cxa_atexit = 0;\t\t\t\t\t\\\n+\t/* kexts should always be built without the coalesced sections\t\\\n+\t   because the kernel loader doesn't grok such sections.  */\t\\\n+\tflag_weak = 0;\t\t\t\t\t\t\t\\\n+\t/* No RTTI in kexts.  */\t\t\t\t\t\\\n+\tflag_rtti = 0;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n \n /* Machine dependent cpp options.  Don't add more options here, add\n    them to darwin_cpp_builtins in darwin-c.c.  */\n \n #undef\tCPP_SPEC\n-#define CPP_SPEC \"%{static:%{!dynamic:-D__STATIC__}}%{!static:-D__DYNAMIC__}\" @(\n-\t\" %{pthread:-D_REENTRANT}\"@)\n+#define CPP_SPEC \"%{static:%{!dynamic:-D__STATIC__}}%{!static:-D__DYNAMIC__}\" \\\n+\t\" %{pthread:-D_REENTRANT}\"\n \n /* This is mostly a clone of the standard LINK_COMMAND_SPEC, plus\n    precomp, libtool, and fat build additions.\n@@ -173,31 +172,31 @@ extern GTY(()) int darwin_ms_struct;\n    specifying the handling of options understood by generic Unix\n    linkers, and for positional arguments like libraries.  */\n \n-#define LINK_COMMAND_SPEC_A @(\n-   \"%{!fdump=*:%{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\n-    %(linker)\n-    %{flto*:%<fcompare-debug*}\n-    %{flto*}\n-    %l %X %{s} %{t} %{Z} %{u*}\n-    %{e*} %{r}\n-    %{o*}%{!o:-o a.out}\n-    %{!nostdlib:%{!nostartfiles:%S}}\n-    %{L*} %(link_libgcc) %o %{fprofile-arcs|fprofile-generate*|coverage:-lgcov}\n-    %{fopenmp|ftree-parallelize-loops=*:\n-      %{static|static-libgcc|static-libstdc++|static-libgfortran: libgomp.a%s; : -lgomp } }\n-    %{!nostdlib:%{!nodefaultlibs:\n-      %(link_ssp) %(link_gcc_c_sequence)\n-    }}\n-    %{!nostdlib:%{!nostartfiles:%E}} %{T*} %{F*} }}}}}}}\"@)\n+#define LINK_COMMAND_SPEC_A \\\n+   \"%{!fdump=*:%{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\\\n+    %(linker) \\\n+    %{flto*:%<fcompare-debug*} \\\n+    %{flto*} \\\n+    %l %X %{s} %{t} %{Z} %{u*} \\\n+    %{e*} %{r} \\\n+    %{o*}%{!o:-o a.out} \\\n+    %{!nostdlib:%{!nostartfiles:%S}} \\\n+    %{L*} %(link_libgcc) %o %{fprofile-arcs|fprofile-generate*|coverage:-lgcov} \\\n+    %{fopenmp|ftree-parallelize-loops=*: \\\n+      %{static|static-libgcc|static-libstdc++|static-libgfortran: libgomp.a%s; : -lgomp } } \\\n+    %{!nostdlib:%{!nodefaultlibs:\\\n+      %(link_ssp) %(link_gcc_c_sequence)\\\n+    }}\\\n+    %{!nostdlib:%{!nostartfiles:%E}} %{T*} %{F*} }}}}}}}\"\n \n #define DSYMUTIL \"\\ndsymutil\"\n \n-#define DSYMUTIL_SPEC @(\n-   \"%{!fdump=*:%{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\n-    %{v}\n-    %{gdwarf-2:%{!gstabs*:%{!g0: -idsym}}}\n-    %{.c|.cc|.C|.cpp|.cp|.c++|.cxx|.CPP|.m|.mm:\n-    %{gdwarf-2:%{!gstabs*:%{!g0: -dsym}}}}}}}}}}}\"@)\n+#define DSYMUTIL_SPEC \\\n+   \"%{!fdump=*:%{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\\\n+    %{v} \\\n+    %{gdwarf-2:%{!gstabs*:%{!g0: -idsym}}}\\\n+    %{.c|.cc|.C|.cpp|.cp|.c++|.cxx|.CPP|.m|.mm: \\\n+    %{gdwarf-2:%{!gstabs*:%{!g0: -dsym}}}}}}}}}}}\"\n \n #define LINK_COMMAND_SPEC LINK_COMMAND_SPEC_A DSYMUTIL_SPEC\n \n@@ -210,8 +209,8 @@ extern GTY(()) int darwin_ms_struct;\n #define LINK_GCC_C_SEQUENCE_SPEC \"%G %L\"\n \n #ifdef TARGET_SYSTEM_ROOT\n-#define LINK_SYSROOT_SPEC @(\n-  \"%{isysroot*:-syslibroot %*;:-syslibroot \" TARGET_SYSTEM_ROOT \"}\"@)\n+#define LINK_SYSROOT_SPEC \\\n+  \"%{isysroot*:-syslibroot %*;:-syslibroot \" TARGET_SYSTEM_ROOT \"}\"\n #else\n #define LINK_SYSROOT_SPEC \"%{isysroot*:-syslibroot %*}\"\n #endif\n@@ -220,90 +219,90 @@ extern GTY(()) int darwin_ms_struct;\n    'Z' and 'no' prefixes). Note that options taking arguments may appear\n    multiple times on a command line with different arguments each time,\n    so put a * after their names so all of them get passed.  */\n-#define LINK_SPEC @(\n-  \"%{static}%{!static:-dynamic}\n-   %:remove-outfile(-ldl)\n-   %:remove-outfile(-lm)\n-   %:remove-outfile(-lpthread)\n-   %{fgnu-runtime: %{static|static-libgcc:\n-                     %:replace-outfile(-lobjc libobjc-gnu.a%s);\n-                    :%:replace-outfile(-lobjc -lobjc-gnu ) } }\n-   %{static|static-libgcc|static-libgfortran:%:replace-outfile(-lgfortran libgfortran.a%s)}\n-   %{static|static-libgcc|static-libstdc++|static-libgfortran:%:replace-outfile(-lgomp libgomp.a%s)}\n-   %{static|static-libgcc|static-libstdc++:%:replace-outfile(-lstdc++ libstdc++.a%s)}\n-   %{!Zdynamiclib:\n-     %{Zforce_cpusubtype_ALL:-arch %(darwin_arch) -force_cpusubtype_ALL}\n-     %{!Zforce_cpusubtype_ALL:-arch %(darwin_subarch)}\n-     %{Zbundle:-bundle}\n-     %{Zbundle_loader*:-bundle_loader %*}\n-     %{client_name*}\n-     %{compatibility_version*:%e-compatibility_version only allowed with -dynamiclib\n-}\n-     %{current_version*:%e-current_version only allowed with -dynamiclib}\n-     %{Zforce_flat_namespace:-force_flat_namespace}\n-     %{Zinstall_name*:%e-install_name only allowed with -dynamiclib}\n-     %{keep_private_externs}\n-     %{private_bundle}\n-    }\n-   %{Zdynamiclib: -dylib\n-     %{Zbundle:%e-bundle not allowed with -dynamiclib}\n-     %{Zbundle_loader*:%e-bundle_loader not allowed with -dynamiclib}\n-     %{client_name*:%e-client_name not allowed with -dynamiclib}\n-     %{compatibility_version*:-dylib_compatibility_version %*}\n-     %{current_version*:-dylib_current_version %*}\n-     %{Zforce_cpusubtype_ALL:-arch %(darwin_arch)}\n-     %{!Zforce_cpusubtype_ALL: -arch %(darwin_subarch)}\n-     %{Zforce_flat_namespace:%e-force_flat_namespace not allowed with -dynamiclib}\n-     %{Zinstall_name*:-dylib_install_name %*}\n-     %{keep_private_externs:%e-keep_private_externs not allowed with -dynamiclib}\n-     %{private_bundle:%e-private_bundle not allowed with -dynamiclib}\n-    }\n-   %{Zall_load:-all_load}\n-   %{Zallowable_client*:-allowable_client %*}\n-   %{Zbind_at_load:-bind_at_load}\n-   %{Zarch_errors_fatal:-arch_errors_fatal}\n-   %{Zdead_strip:-dead_strip}\n-   %{Zno_dead_strip_inits_and_terms:-no_dead_strip_inits_and_terms}\n-   %{Zdylib_file*:-dylib_file %*}\n-   %{Zdynamic:-dynamic}\n-   %{Zexported_symbols_list*:-exported_symbols_list %*}\n-   %{Zflat_namespace:-flat_namespace}\n-   %{headerpad_max_install_names}\n-   %{Zimage_base*:-image_base %*}\n-   %{Zinit*:-init %*}\n-   %{!mmacosx-version-min=*:-macosx_version_min %(darwin_minversion)}\n-   %{mmacosx-version-min=*:-macosx_version_min %*}\n-   %{nomultidefs}\n-   %{Zmulti_module:-multi_module} %{Zsingle_module:-single_module}\n-   %{Zmultiply_defined*:-multiply_defined %*}\n-   %{!Zmultiply_defined*:%{shared-libgcc:\n-     %:version-compare(< 10.5 mmacosx-version-min= -multiply_defined)\n-     %:version-compare(< 10.5 mmacosx-version-min= suppress)}}\n-   %{Zmultiplydefinedunused*:-multiply_defined_unused %*}\n-   %{fpie:-pie}\n-   %{prebind} %{noprebind} %{nofixprebinding} %{prebind_all_twolevel_modules}\n-   %{read_only_relocs}\n-   %{sectcreate*} %{sectorder*} %{seg1addr*} %{segprot*}\n-   %{Zsegaddr*:-segaddr %*}\n-   %{Zsegs_read_only_addr*:-segs_read_only_addr %*}\n-   %{Zsegs_read_write_addr*:-segs_read_write_addr %*}\n-   %{Zseg_addr_table*: -seg_addr_table %*}\n-   %{Zfn_seg_addr_table_filename*:-seg_addr_table_filename %*}\n-   %{sub_library*} %{sub_umbrella*}\n-   \" LINK_SYSROOT_SPEC \"\n-   %{twolevel_namespace} %{twolevel_namespace_hints}\n-   %{Zumbrella*: -umbrella %*}\n-   %{undefined*}\n-   %{Zunexported_symbols_list*:-unexported_symbols_list %*}\n-   %{Zweak_reference_mismatches*:-weak_reference_mismatches %*}\n-   %{!Zweak_reference_mismatches*:-weak_reference_mismatches non-weak}\n-   %{X}\n-   %{y*}\n-   %{w}\n-   %{pagezero_size*} %{segs_read_*} %{seglinkedit} %{noseglinkedit}\n-   %{sectalign*} %{sectobjectsymbols*} %{segcreate*} %{whyload}\n-   %{whatsloaded} %{dylinker_install_name*}\n-   %{dylinker} %{Mach} \"@)\n+#define LINK_SPEC  \\\n+  \"%{static}%{!static:-dynamic} \\\n+   %:remove-outfile(-ldl) \\\n+   %:remove-outfile(-lm) \\\n+   %:remove-outfile(-lpthread) \\\n+   %{fgnu-runtime: %{static|static-libgcc: \\\n+                     %:replace-outfile(-lobjc libobjc-gnu.a%s); \\\n+                    :%:replace-outfile(-lobjc -lobjc-gnu ) } }\\\n+   %{static|static-libgcc|static-libgfortran:%:replace-outfile(-lgfortran libgfortran.a%s)}\\\n+   %{static|static-libgcc|static-libstdc++|static-libgfortran:%:replace-outfile(-lgomp libgomp.a%s)}\\\n+   %{static|static-libgcc|static-libstdc++:%:replace-outfile(-lstdc++ libstdc++.a%s)}\\\n+   %{!Zdynamiclib: \\\n+     %{Zforce_cpusubtype_ALL:-arch %(darwin_arch) -force_cpusubtype_ALL} \\\n+     %{!Zforce_cpusubtype_ALL:-arch %(darwin_subarch)} \\\n+     %{Zbundle:-bundle} \\\n+     %{Zbundle_loader*:-bundle_loader %*} \\\n+     %{client_name*} \\\n+     %{compatibility_version*:%e-compatibility_version only allowed with -dynamiclib\\\n+} \\\n+     %{current_version*:%e-current_version only allowed with -dynamiclib} \\\n+     %{Zforce_flat_namespace:-force_flat_namespace} \\\n+     %{Zinstall_name*:%e-install_name only allowed with -dynamiclib} \\\n+     %{keep_private_externs} \\\n+     %{private_bundle} \\\n+    } \\\n+   %{Zdynamiclib: -dylib \\\n+     %{Zbundle:%e-bundle not allowed with -dynamiclib} \\\n+     %{Zbundle_loader*:%e-bundle_loader not allowed with -dynamiclib} \\\n+     %{client_name*:%e-client_name not allowed with -dynamiclib} \\\n+     %{compatibility_version*:-dylib_compatibility_version %*} \\\n+     %{current_version*:-dylib_current_version %*} \\\n+     %{Zforce_cpusubtype_ALL:-arch %(darwin_arch)} \\\n+     %{!Zforce_cpusubtype_ALL: -arch %(darwin_subarch)} \\\n+     %{Zforce_flat_namespace:%e-force_flat_namespace not allowed with -dynamiclib} \\\n+     %{Zinstall_name*:-dylib_install_name %*} \\\n+     %{keep_private_externs:%e-keep_private_externs not allowed with -dynamiclib} \\\n+     %{private_bundle:%e-private_bundle not allowed with -dynamiclib} \\\n+    } \\\n+   %{Zall_load:-all_load} \\\n+   %{Zallowable_client*:-allowable_client %*} \\\n+   %{Zbind_at_load:-bind_at_load} \\\n+   %{Zarch_errors_fatal:-arch_errors_fatal} \\\n+   %{Zdead_strip:-dead_strip} \\\n+   %{Zno_dead_strip_inits_and_terms:-no_dead_strip_inits_and_terms} \\\n+   %{Zdylib_file*:-dylib_file %*} \\\n+   %{Zdynamic:-dynamic}\\\n+   %{Zexported_symbols_list*:-exported_symbols_list %*} \\\n+   %{Zflat_namespace:-flat_namespace} \\\n+   %{headerpad_max_install_names} \\\n+   %{Zimage_base*:-image_base %*} \\\n+   %{Zinit*:-init %*} \\\n+   %{!mmacosx-version-min=*:-macosx_version_min %(darwin_minversion)} \\\n+   %{mmacosx-version-min=*:-macosx_version_min %*} \\\n+   %{nomultidefs} \\\n+   %{Zmulti_module:-multi_module} %{Zsingle_module:-single_module} \\\n+   %{Zmultiply_defined*:-multiply_defined %*} \\\n+   %{!Zmultiply_defined*:%{shared-libgcc: \\\n+     %:version-compare(< 10.5 mmacosx-version-min= -multiply_defined) \\\n+     %:version-compare(< 10.5 mmacosx-version-min= suppress)}} \\\n+   %{Zmultiplydefinedunused*:-multiply_defined_unused %*} \\\n+   %{fpie:-pie} \\\n+   %{prebind} %{noprebind} %{nofixprebinding} %{prebind_all_twolevel_modules} \\\n+   %{read_only_relocs} \\\n+   %{sectcreate*} %{sectorder*} %{seg1addr*} %{segprot*} \\\n+   %{Zsegaddr*:-segaddr %*} \\\n+   %{Zsegs_read_only_addr*:-segs_read_only_addr %*} \\\n+   %{Zsegs_read_write_addr*:-segs_read_write_addr %*} \\\n+   %{Zseg_addr_table*: -seg_addr_table %*} \\\n+   %{Zfn_seg_addr_table_filename*:-seg_addr_table_filename %*} \\\n+   %{sub_library*} %{sub_umbrella*} \\\n+   \" LINK_SYSROOT_SPEC \" \\\n+   %{twolevel_namespace} %{twolevel_namespace_hints} \\\n+   %{Zumbrella*: -umbrella %*} \\\n+   %{undefined*} \\\n+   %{Zunexported_symbols_list*:-unexported_symbols_list %*} \\\n+   %{Zweak_reference_mismatches*:-weak_reference_mismatches %*} \\\n+   %{!Zweak_reference_mismatches*:-weak_reference_mismatches non-weak} \\\n+   %{X} \\\n+   %{y*} \\\n+   %{w} \\\n+   %{pagezero_size*} %{segs_read_*} %{seglinkedit} %{noseglinkedit}  \\\n+   %{sectalign*} %{sectobjectsymbols*} %{segcreate*} %{whyload} \\\n+   %{whatsloaded} %{dylinker_install_name*} \\\n+   %{dylinker} %{Mach} \"\n \n \n /* Machine dependent libraries.  */\n@@ -324,19 +323,19 @@ extern GTY(()) int darwin_ms_struct;\n    If it is linked against, it has to be before -lgcc, because it may\n    need symbols from -lgcc.  */\n #undef REAL_LIBGCC_SPEC\n-#define REAL_LIBGCC_SPEC @(\n-   \"%{static-libgcc|static: -lgcc_eh -lgcc;\n-      shared-libgcc|fexceptions|fgnu-runtime:\n-       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_s.10.4)\n-       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)\n-       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)\n-       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)\n-       -lgcc ;\n-      :%:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4)\n-       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)\n-       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)\n-       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)\n-       -lgcc }\"@)\n+#define REAL_LIBGCC_SPEC\t\t\t\t\t\t   \\\n+   \"%{static-libgcc|static: -lgcc_eh -lgcc;\t\t\t\t   \\\n+      shared-libgcc|fexceptions|fgnu-runtime:\t\t\t\t   \\\n+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_s.10.4)\t   \\\n+       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \\\n+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)\t   \\\n+       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)\t   \\\n+       -lgcc ;\t\t\t\t\t\t\t\t   \\\n+      :%:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4) \\\n+       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \\\n+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)\t   \\\n+       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)\t   \\\n+       -lgcc }\"\n \n /* We specify crt0.o as -lcrt0.o so that ld will search the library path.\n \n@@ -346,42 +345,42 @@ extern GTY(()) int darwin_ms_struct;\n    powerpc program built.  */\n \n #undef  STARTFILE_SPEC\n-#define STARTFILE_SPEC @(\n-  \"%{Zdynamiclib: %(darwin_dylib1) }\n-   %{!Zdynamiclib:%{Zbundle:%{!static:-lbundle1.o}}\n-     %{!Zbundle:%{pg:%{static:-lgcrt0.o}\n-                     %{!static:%{object:-lgcrt0.o}\n-                               %{!object:%{preload:-lgcrt0.o}\n-                                 %{!preload:-lgcrt1.o %(darwin_crt2)}}}}\n-                %{!pg:%{static:-lcrt0.o}\n-                      %{!static:%{object:-lcrt0.o}\n-                                %{!object:%{preload:-lcrt0.o}\n-                                  %{!preload: %(darwin_crt1)\n-\t\t\t\t\t      %(darwin_crt2)}}}}}}\n-  %{shared-libgcc:%:version-compare(< 10.5 mmacosx-version-min= crt3.o%s)}\"@)\n+#define STARTFILE_SPEC\t\t\t\t\t\t\t    \\\n+  \"%{Zdynamiclib: %(darwin_dylib1) }\t\t\t\t\t    \\\n+   %{!Zdynamiclib:%{Zbundle:%{!static:-lbundle1.o}}\t\t\t    \\\n+     %{!Zbundle:%{pg:%{static:-lgcrt0.o}\t\t\t\t    \\\n+                     %{!static:%{object:-lgcrt0.o}\t\t\t    \\\n+                               %{!object:%{preload:-lgcrt0.o}\t\t    \\\n+                                 %{!preload:-lgcrt1.o %(darwin_crt2)}}}}    \\\n+                %{!pg:%{static:-lcrt0.o}\t\t\t\t    \\\n+                      %{!static:%{object:-lcrt0.o}\t\t\t    \\\n+                                %{!object:%{preload:-lcrt0.o}\t\t    \\\n+                                  %{!preload: %(darwin_crt1)\t\t    \\\n+\t\t\t\t\t      %(darwin_crt2)}}}}}}\t    \\\n+  %{shared-libgcc:%:version-compare(< 10.5 mmacosx-version-min= crt3.o%s)}\"\n \n /* The native Darwin linker doesn't necessarily place files in the order\n    that they're specified on the link line.  Thus, it is pointless\n    to put anything in ENDFILE_SPEC.  */\n /* #define ENDFILE_SPEC \"\" */\n \n-#define DARWIN_EXTRA_SPECS @(\n-  { \"darwin_crt1\", DARWIN_CRT1_SPEC },\n-  { \"darwin_dylib1\", DARWIN_DYLIB1_SPEC },\n-  { \"darwin_minversion\", DARWIN_MINVERSION_SPEC },@)\n+#define DARWIN_EXTRA_SPECS\t\t\t\t\t\t\\\n+  { \"darwin_crt1\", DARWIN_CRT1_SPEC },\t\t\t\t\t\\\n+  { \"darwin_dylib1\", DARWIN_DYLIB1_SPEC },\t\t\t\t\\\n+  { \"darwin_minversion\", DARWIN_MINVERSION_SPEC },\n \n-#define DARWIN_DYLIB1_SPEC @(\n-  \"%:version-compare(!> 10.5 mmacosx-version-min= -ldylib1.o)\n-   %:version-compare(>= 10.5 mmacosx-version-min= -ldylib1.10.5.o)\"@)\n+#define DARWIN_DYLIB1_SPEC\t\t\t\t\t\t\\\n+  \"%:version-compare(!> 10.5 mmacosx-version-min= -ldylib1.o)\t\t\\\n+   %:version-compare(>= 10.5 mmacosx-version-min= -ldylib1.10.5.o)\"\n \n-#define DARWIN_CRT1_SPEC @(\n-  \"%:version-compare(!> 10.5 mmacosx-version-min= -lcrt1.o)\n-   %:version-compare(>= 10.5 mmacosx-version-min= -lcrt1.10.5.o)\"@)\n+#define DARWIN_CRT1_SPEC\t\t\t\t\t\t\\\n+  \"%:version-compare(!> 10.5 mmacosx-version-min= -lcrt1.o)\t\t\\\n+   %:version-compare(>= 10.5 mmacosx-version-min= -lcrt1.10.5.o)\"\n \n /* Default Darwin ASM_SPEC, very simple.  */\n-#define ASM_SPEC \"-arch %(darwin_arch) @(\n-  %{Zforce_cpusubtype_ALL:-force_cpusubtype_ALL}\n-  %{static}\"@)\n+#define ASM_SPEC \"-arch %(darwin_arch) \\\n+  %{Zforce_cpusubtype_ALL:-force_cpusubtype_ALL} \\\n+  %{static}\"\n \n /* We still allow output of STABS.  */\n \n@@ -424,27 +423,27 @@ extern GTY(()) int darwin_ms_struct;\n    coalesced sections.  Weak aliases (or any other kind of aliases) are\n    not supported.  Weak symbols that aren't visible outside the .s file\n    are not supported.  */\n-#define ASM_WEAKEN_DECL(FILE, DECL, NAME, ALIAS) @(\n-  do {\n-    if (ALIAS)\n-      {\n-\twarning (0, \"alias definitions not supported in Mach-O; ignored\");\n-\tbreak;\n-      }\n-\n-    if (! DECL_EXTERNAL (DECL) && TREE_PUBLIC (DECL))\n-      targetm.asm_out.globalize_label (FILE, NAME);\n-    if (DECL_EXTERNAL (DECL))\n-      fputs (\"\\t.weak_reference \", FILE);\n-    else if (lookup_attribute (\"weak_import\", DECL_ATTRIBUTES (DECL)))\n-      break;\n-    else if (TREE_PUBLIC (DECL))\n-      fputs (\"\\t.weak_definition \", FILE);\n-    else\n-      break;\n-    assemble_name (FILE, NAME);\n-    fputc ('\\n', FILE);\n-  } while (0)@)\n+#define ASM_WEAKEN_DECL(FILE, DECL, NAME, ALIAS)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (ALIAS)\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\twarning (0, \"alias definitions not supported in Mach-O; ignored\");\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+ \t\t\t\t\t\t\t\t\t\\\n+    if (! DECL_EXTERNAL (DECL) && TREE_PUBLIC (DECL))\t\t\t\\\n+      targetm.asm_out.globalize_label (FILE, NAME);\t\t\t\\\n+    if (DECL_EXTERNAL (DECL))\t\t\t\t\t\t\\\n+      fputs (\"\\t.weak_reference \", FILE);\t\t\t\t\\\n+    else if (lookup_attribute (\"weak_import\", DECL_ATTRIBUTES (DECL)))\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    else if (TREE_PUBLIC (DECL))\t\t\t\t\t\\\n+      fputs (\"\\t.weak_definition \", FILE);\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    fputc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+  } while (0)\n \n /* Darwin has the pthread routines in libSystem, which every program\n    links to, so there's no need for weak-ness for that.  */\n@@ -525,90 +524,90 @@ extern GTY(()) int darwin_ms_struct;\n #undef  TARGET_ASM_LTO_END\n #define TARGET_ASM_LTO_END darwin_asm_lto_end\n \n-#define ASM_OUTPUT_SKIP(FILE,SIZE) @(\n-  fprintf (FILE, \"\\t.space \"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", SIZE)@)\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.space \"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", SIZE)\n \n /* Give ObjC methods pretty symbol names.  */\n \n #undef\tOBJC_GEN_METHOD_LABEL\n-#define OBJC_GEN_METHOD_LABEL(BUF,IS_INST,CLASS_NAME,CAT_NAME,SEL_NAME,NUM) @(\n-  do { if (CAT_NAME)\n-\t sprintf (BUF, \"%c[%s(%s) %s]\", (IS_INST) ? '-' : '+',\n-\t\t  (CLASS_NAME), (CAT_NAME), (SEL_NAME));\n-       else\n-\t sprintf (BUF, \"%c[%s %s]\", (IS_INST) ? '-' : '+',\n-\t\t  (CLASS_NAME), (SEL_NAME));\n-     } while (0)@)\n+#define OBJC_GEN_METHOD_LABEL(BUF,IS_INST,CLASS_NAME,CAT_NAME,SEL_NAME,NUM) \\\n+  do { if (CAT_NAME)\t\t\t\t\t\t\t\\\n+\t sprintf (BUF, \"%c[%s(%s) %s]\", (IS_INST) ? '-' : '+',\t\t\\\n+\t\t  (CLASS_NAME), (CAT_NAME), (SEL_NAME));\t\t\\\n+       else\t\t\t\t\t\t\t\t\\\n+\t sprintf (BUF, \"%c[%s %s]\", (IS_INST) ? '-' : '+',\t\t\\\n+\t\t  (CLASS_NAME), (SEL_NAME));\t\t\t\t\\\n+     } while (0)\n \n #undef ASM_DECLARE_OBJECT_NAME\n-#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL) @(\n-\tdarwin_asm_declare_object_name ((FILE), (NAME), (DECL))@)\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL) \\\n+\tdarwin_asm_declare_object_name ((FILE), (NAME), (DECL))\n \n /* The RTTI data (e.g., __ti4name) is common and public (and static),\n    but it does need to be referenced via indirect PIC data pointers.\n    The machopic_define_symbol calls are telling the machopic subsystem\n    that the name *is* defined in this module, so it doesn't need to\n    make them indirect.  */\n \n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) @(\n-  do {\n-    const char *xname = NAME;\n-    if (GET_CODE (XEXP (DECL_RTL (DECL), 0)) != SYMBOL_REF)\n-      xname = IDENTIFIER_POINTER (DECL_NAME (DECL));\n-    if (! DECL_WEAK (DECL)\n-        && ((TREE_STATIC (DECL)\n-\t     && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))\n-            || DECL_INITIAL (DECL)))\n-        machopic_define_symbol (DECL_RTL (DECL));\n-    if ((TREE_STATIC (DECL)\n-\t && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))\n-        || DECL_INITIAL (DECL))\n-      (* targetm.encode_section_info) (DECL, DECL_RTL (DECL), false);\n-    ASM_OUTPUT_FUNCTION_LABEL (FILE, xname, DECL);\n-  } while (0)@)\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    const char *xname = NAME;\t\t\t\t\t\t\\\n+    if (GET_CODE (XEXP (DECL_RTL (DECL), 0)) != SYMBOL_REF)\t\t\\\n+      xname = IDENTIFIER_POINTER (DECL_NAME (DECL));\t\t\t\\\n+    if (! DECL_WEAK (DECL)\t\t\t\t\t\t\\\n+        && ((TREE_STATIC (DECL)\t\t\t\t\t\t\\\n+\t     && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))\t\t\\\n+            || DECL_INITIAL (DECL)))\t\t\t\t\t\\\n+        machopic_define_symbol (DECL_RTL (DECL));\t\t\t\\\n+    if ((TREE_STATIC (DECL)\t\t\t\t\t\t\\\n+\t && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))\t\t\\\n+        || DECL_INITIAL (DECL))\t\t\t\t\t\t\\\n+      (* targetm.encode_section_info) (DECL, DECL_RTL (DECL), false);\t\\\n+    ASM_OUTPUT_FUNCTION_LABEL (FILE, xname, DECL);\t\t\t\\\n+  } while (0)\n \n #undef TARGET_ASM_DECLARE_CONSTANT_NAME\n #define TARGET_ASM_DECLARE_CONSTANT_NAME darwin_asm_declare_constant_name\n \n /* Wrap new method names in quotes so the assembler doesn't gag.\n-   Make Objective-C internal symbols local and in doing this, we need\n+   Make Objective-C internal symbols local and in doing this, we need \n    to accommodate the name mangling done by c++ on file scope locals.  */\n \n int darwin_label_is_anonymous_local_objc_name (const char *name);\n \n #undef\tASM_OUTPUT_LABELREF\n-#define ASM_OUTPUT_LABELREF(FILE,NAME) @(\n-  do {\n-       const char *xname = (NAME);\n-       if (! strcmp (xname, MACHOPIC_FUNCTION_BASE_NAME))\n-         machopic_output_function_base_name(FILE);\n-       else if (xname[0] == '&' || xname[0] == '*')\n-         {\n-           int len = strlen (xname);\n-\t   if (len > 6 && !strcmp (\"$stub\", xname + len - 5))\n-\t     machopic_validate_stub_or_non_lazy_ptr (xname);\n-\t   else if (len > 7 && !strcmp (\"$stub\\\"\", xname + len - 6))\n-\t     machopic_validate_stub_or_non_lazy_ptr (xname);\n-\t   else if (len > 14 && !strcmp (\"$non_lazy_ptr\", xname + len - 13))\n-\t     machopic_validate_stub_or_non_lazy_ptr (xname);\n-\t   else if (len > 15 && !strcmp (\"$non_lazy_ptr\\\"\", xname + len - 14))\n-\t     machopic_validate_stub_or_non_lazy_ptr (xname);\n-\t   if (xname[1] != '\"' && name_needs_quotes (&xname[1]))\n-\t     fprintf (FILE, \"\\\"%s\\\"\", &xname[1]);\n-\t   else\n-\t     fputs (&xname[1], FILE);\n-\t }\n-       else if (xname[0] == '+' || xname[0] == '-')\n-         fprintf (FILE, \"\\\"%s\\\"\", xname);\n-       else if (darwin_label_is_anonymous_local_objc_name (xname))\n-         fprintf (FILE, \"L%s\", xname);\n-       else if (!strncmp (xname, \".objc_class_name_\", 17))\n-\t fprintf (FILE, \"%s\", xname);\n-       else if (xname[0] != '\"' && name_needs_quotes (xname))\n-\t fprintf (FILE, \"\\\"%s\\\"\", xname);\n-       else\n-         asm_fprintf (FILE, \"%U%s\", xname);\n-  } while (0)@)\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\t\t\t\t     \\\n+  do {\t\t\t\t\t\t\t\t\t     \\\n+       const char *xname = (NAME);\t\t\t\t\t     \\\n+       if (! strcmp (xname, MACHOPIC_FUNCTION_BASE_NAME))\t\t     \\\n+         machopic_output_function_base_name(FILE);                           \\\n+       else if (xname[0] == '&' || xname[0] == '*')\t\t\t     \\\n+         {\t\t\t\t\t\t\t\t     \\\n+           int len = strlen (xname);\t\t\t\t\t     \\\n+\t   if (len > 6 && !strcmp (\"$stub\", xname + len - 5))\t\t     \\\n+\t     machopic_validate_stub_or_non_lazy_ptr (xname);\t\t     \\\n+\t   else if (len > 7 && !strcmp (\"$stub\\\"\", xname + len - 6))\t     \\\n+\t     machopic_validate_stub_or_non_lazy_ptr (xname);\t\t     \\\n+\t   else if (len > 14 && !strcmp (\"$non_lazy_ptr\", xname + len - 13)) \\\n+\t     machopic_validate_stub_or_non_lazy_ptr (xname);\t\t     \\\n+\t   else if (len > 15 && !strcmp (\"$non_lazy_ptr\\\"\", xname + len - 14)) \\\n+\t     machopic_validate_stub_or_non_lazy_ptr (xname);\t\t     \\\n+\t   if (xname[1] != '\"' && name_needs_quotes (&xname[1]))\t     \\\n+\t     fprintf (FILE, \"\\\"%s\\\"\", &xname[1]);\t\t\t     \\\n+\t   else\t\t\t\t\t\t\t\t     \\\n+\t     fputs (&xname[1], FILE); \t\t\t\t\t     \\\n+\t }\t\t\t\t\t\t\t\t     \\\n+       else if (xname[0] == '+' || xname[0] == '-')\t\t\t     \\\n+         fprintf (FILE, \"\\\"%s\\\"\", xname);\t\t\t\t     \\\n+       else if (darwin_label_is_anonymous_local_objc_name (xname))\t\t\t\t     \\\n+         fprintf (FILE, \"L%s\", xname);\t\t\t\t\t     \\\n+       else if (!strncmp (xname, \".objc_class_name_\", 17))\t\t     \\\n+\t fprintf (FILE, \"%s\", xname);\t\t\t\t\t     \\\n+       else if (xname[0] != '\"' && name_needs_quotes (xname))\t\t     \\\n+\t fprintf (FILE, \"\\\"%s\\\"\", xname);\t\t\t\t     \\\n+       else\t\t\t\t\t\t\t\t     \\\n+         asm_fprintf (FILE, \"%U%s\", xname);\t\t\t\t     \\\n+  } while (0)\n \n /* Output before executable code.  */\n #undef TEXT_SECTION_ASM_OP\n@@ -623,9 +622,9 @@ int darwin_label_is_anonymous_local_objc_name (const char *name);\n #define ALIGN_ASM_OP\t\t\".align\"\n \n #undef\tASM_OUTPUT_ALIGN\n-#define ASM_OUTPUT_ALIGN(FILE,LOG) @(\n-  if ((LOG) != 0)\n-    fprintf (FILE, \"\\t%s\\t%d\\n\", ALIGN_ASM_OP, (LOG))@)\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t%d\\n\", ALIGN_ASM_OP, (LOG))\n \n /* The maximum alignment which the object file format can support in\n    bits.  For Mach-O, this is 2^15 bytes.  */\n@@ -636,18 +635,18 @@ int darwin_label_is_anonymous_local_objc_name (const char *name);\n #define L2_MAX_OFILE_ALIGNMENT 15\n \n /*  These are the three variants that emit referenced blank space.  */\n-#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) @(\n-\tdarwin_output_aligned_bss ((FILE), (DECL), (NAME), (SIZE), (ALIGN))@)\n+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN)\t\t\\\n+\tdarwin_output_aligned_bss ((FILE), (DECL), (NAME), (SIZE), (ALIGN))\n \n #undef\tASM_OUTPUT_ALIGNED_DECL_LOCAL\n-#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(FILE, DECL, NAME, SIZE, ALIGN) @(\n-\tdarwin_asm_output_aligned_decl_local\n-\t\t\t\t  ((FILE), (DECL), (NAME), (SIZE), (ALIGN))@)\n+#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(FILE, DECL, NAME, SIZE, ALIGN)\t\\\n+\tdarwin_asm_output_aligned_decl_local\t\t\t\t\\\n+\t\t\t\t  ((FILE), (DECL), (NAME), (SIZE), (ALIGN))\n \n #undef  ASM_OUTPUT_ALIGNED_DECL_COMMON\n-#define ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN) @(\n-\tdarwin_asm_output_aligned_decl_common\n-\t\t\t\t   ((FILE), (DECL), (NAME), (SIZE), (ALIGN))@)\n+#define ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN)\t\\\n+\tdarwin_asm_output_aligned_decl_common\t\t\t\t\\\n+\t\t\t\t   ((FILE), (DECL), (NAME), (SIZE), (ALIGN))\n \n /* The generic version, archs should over-ride where required.  */\n #define MACHOPIC_NL_SYMBOL_PTR_SECTION \".non_lazy_symbol_pointer\"\n@@ -670,8 +669,8 @@ extern GTY(()) section * darwin_sections[NUM_DARWIN_SECTIONS];\n #define TARGET_ASM_FUNCTION_SECTION darwin_function_section\n \n #undef\tTARGET_ASM_FUNCTION_SWITCHED_TEXT_SECTIONS\n-#define TARGET_ASM_FUNCTION_SWITCHED_TEXT_SECTIONS @(\n-\tdarwin_function_switched_text_sections@)\n+#define TARGET_ASM_FUNCTION_SWITCHED_TEXT_SECTIONS \\\n+\tdarwin_function_switched_text_sections\n \n #undef\tTARGET_ASM_SELECT_RTX_SECTION\n #define TARGET_ASM_SELECT_RTX_SECTION machopic_select_rtx_section\n@@ -683,27 +682,27 @@ extern GTY(()) section * darwin_sections[NUM_DARWIN_SECTIONS];\n #define TARGET_ASM_RELOC_RW_MASK machopic_reloc_rw_mask\n \n \n-#define ASM_DECLARE_UNRESOLVED_REFERENCE(FILE,NAME) @(\n-    do {\n-\t if (FILE) {\n-\t   if (MACHOPIC_INDIRECT)\n-\t     fprintf (FILE, \"\\t.lazy_reference \");\n-\t   else\n-\t     fprintf (FILE, \"\\t.reference \");\n-\t   assemble_name (FILE, NAME);\n-\t   fprintf (FILE, \"\\n\");\n-\t }\n-       } while (0)@)\n-\n-#define ASM_DECLARE_CLASS_REFERENCE(FILE,NAME) @(\n-    do {\n-\t if (FILE) {\n-\t   fprintf (FILE, \"\\t\");\n-\t   assemble_name (FILE, NAME);\n-\t   fprintf (FILE, \"=0\\n\");\n-\t   (*targetm.asm_out.globalize_label) (FILE, NAME);\n-\t }\n-       } while (0)@)\n+#define ASM_DECLARE_UNRESOLVED_REFERENCE(FILE,NAME)\t\t\t\\\n+    do {\t\t\t\t\t\t\t\t\\\n+\t if (FILE) {\t\t\t\t\t\t\t\\\n+\t   if (MACHOPIC_INDIRECT)\t\t\t\t\t\\\n+\t     fprintf (FILE, \"\\t.lazy_reference \");\t\t\t\\\n+\t   else\t\t\t\t\t\t\t\t\\\n+\t     fprintf (FILE, \"\\t.reference \");\t\t\t\t\\\n+\t   assemble_name (FILE, NAME);\t\t\t\t\t\\\n+\t   fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n+\t }                                                              \\\n+       } while (0)\n+\n+#define ASM_DECLARE_CLASS_REFERENCE(FILE,NAME)\t\t\t\t\\\n+    do {\t\t\t\t\t\t\t\t\\\n+\t if (FILE) {\t\t\t\t\t\t\t\\\n+\t   fprintf (FILE, \"\\t\");\t\t\t\t\t\\\n+\t   assemble_name (FILE, NAME);\t\t\t\t\t\\\n+\t   fprintf (FILE, \"=0\\n\");\t\t\t\t\t\\\n+\t   (*targetm.asm_out.globalize_label) (FILE, NAME);\t\t\\\n+\t }\t\t\t\t\t\t\t\t\\\n+       } while (0)\n \n /* Globalizing directive for a label.  */\n #define GLOBAL_ASM_OP \"\\t.globl \"\n@@ -716,16 +715,16 @@ extern GTY(()) section * darwin_sections[NUM_DARWIN_SECTIONS];\n #define TARGET_ASM_ASSEMBLE_VISIBILITY darwin_assemble_visibility\n \n /* Extra attributes for Darwin.  */\n-#define SUBTARGET_ATTRIBUTE_TABLE @(\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  { \"apple_kext_compatibility\", 0, 0, false, true, false,\n-    darwin_handle_kext_attribute },\n-  { \"weak_import\", 0, 0, true, false, false,\n-    darwin_handle_weak_import_attribute }@)\n+#define SUBTARGET_ATTRIBUTE_TABLE\t\t\t\t\t     \\\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */ \\\n+  { \"apple_kext_compatibility\", 0, 0, false, true, false,\t\t     \\\n+    darwin_handle_kext_attribute },\t\t\t\t\t     \\\n+  { \"weak_import\", 0, 0, true, false, false,\t\t\t\t     \\\n+    darwin_handle_weak_import_attribute }\n \n #undef ASM_GENERATE_INTERNAL_LABEL\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM) @(\n-  sprintf (LABEL, \"*%s%ld\", PREFIX, (long)(NUM))@)\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*%s%ld\", PREFIX, (long)(NUM))\n \n #undef TARGET_ASM_MARK_DECL_PRESERVED\n #define TARGET_ASM_MARK_DECL_PRESERVED darwin_mark_decl_preserved\n@@ -771,61 +770,61 @@ enum machopic_addr_class {\n #undef TARGET_STRIP_NAME_ENCODING\n #define TARGET_STRIP_NAME_ENCODING  default_strip_name_encoding\n \n-#define GEN_BINDER_NAME_FOR_STUB(BUF,STUB,STUB_LENGTH) @(\n-  do {\n-    const char *const stub_ = (STUB);\n-    char *buffer_ = (BUF);\n-    strcpy (buffer_, stub_);\n-    if (stub_[0] == '\"')\n-      {\n-\tstrcpy (buffer_ + (STUB_LENGTH) - 1, \"_binder\\\"\");\n-      }\n-    else\n-      {\n-\tstrcpy (buffer_ + (STUB_LENGTH), \"_binder\");\n-      }\n-  } while (0)@)\n-\n-#define GEN_SYMBOL_NAME_FOR_SYMBOL(BUF,SYMBOL,SYMBOL_LENGTH) @(\n-  do {\n-    const char *const symbol_ = (SYMBOL);\n-    char *buffer_ = (BUF);\n-    if (name_needs_quotes (symbol_) && symbol_[0] != '\"')\n-      {\n-\t  sprintf (buffer_, \"\\\"%s\\\"\", symbol_);\n-      }\n-    else\n-      {\n-\tstrcpy (buffer_, symbol_);\n-      }\n-  } while (0)@)\n+#define GEN_BINDER_NAME_FOR_STUB(BUF,STUB,STUB_LENGTH)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    const char *const stub_ = (STUB);\t\t\t\t\\\n+    char *buffer_ = (BUF);\t\t\t\t\t\\\n+    strcpy (buffer_, stub_);\t\t\t\t\t\\\n+    if (stub_[0] == '\"')\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tstrcpy (buffer_ + (STUB_LENGTH) - 1, \"_binder\\\"\");\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tstrcpy (buffer_ + (STUB_LENGTH), \"_binder\");\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define GEN_SYMBOL_NAME_FOR_SYMBOL(BUF,SYMBOL,SYMBOL_LENGTH)\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    const char *const symbol_ = (SYMBOL);\t\t\t\\\n+    char *buffer_ = (BUF);\t\t\t\t\t\\\n+    if (name_needs_quotes (symbol_) && symbol_[0] != '\"')\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\t  sprintf (buffer_, \"\\\"%s\\\"\", symbol_);\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tstrcpy (buffer_, symbol_);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (0)\n \n /* Given a symbol name string, create the lazy pointer version\n    of the symbol name.  */\n \n-#define GEN_LAZY_PTR_NAME_FOR_SYMBOL(BUF,SYMBOL,SYMBOL_LENGTH) @(\n-  do {\n-    const char *symbol_ = (SYMBOL);\n-    char *buffer_ = (BUF);\n-    if (symbol_[0] == '\"')\n-      {\n-        strcpy (buffer_, \"\\\"L\");\n-        strcpy (buffer_ + 2, symbol_ + 1);\n-\tstrcpy (buffer_ + (SYMBOL_LENGTH), \"$lazy_ptr\\\"\");\n-      }\n-    else if (name_needs_quotes (symbol_))\n-      {\n-        strcpy (buffer_, \"\\\"L\");\n-        strcpy (buffer_ + 2, symbol_);\n-\tstrcpy (buffer_ + (SYMBOL_LENGTH) + 2, \"$lazy_ptr\\\"\");\n-      }\n-    else\n-      {\n-        strcpy (buffer_, \"L\");\n-        strcpy (buffer_ + 1, symbol_);\n-\tstrcpy (buffer_ + (SYMBOL_LENGTH) + 1, \"$lazy_ptr\");\n-      }\n-  } while (0)@)\n+#define GEN_LAZY_PTR_NAME_FOR_SYMBOL(BUF,SYMBOL,SYMBOL_LENGTH)\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    const char *symbol_ = (SYMBOL);                             \\\n+    char *buffer_ = (BUF);\t\t\t\t\t\\\n+    if (symbol_[0] == '\"')\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        strcpy (buffer_, \"\\\"L\");\t\t\t\t\\\n+        strcpy (buffer_ + 2, symbol_ + 1);\t\t\t\\\n+\tstrcpy (buffer_ + (SYMBOL_LENGTH), \"$lazy_ptr\\\"\");\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else if (name_needs_quotes (symbol_))\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        strcpy (buffer_, \"\\\"L\");\t\t\t\t\\\n+        strcpy (buffer_ + 2, symbol_);\t\t\t\t\\\n+\tstrcpy (buffer_ + (SYMBOL_LENGTH) + 2, \"$lazy_ptr\\\"\");\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        strcpy (buffer_, \"L\");\t\t\t\t\t\\\n+        strcpy (buffer_ + 1, symbol_);\t\t\t\t\\\n+\tstrcpy (buffer_ + (SYMBOL_LENGTH) + 1, \"$lazy_ptr\");\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (0)\n \n #define EH_FRAME_SECTION_NAME   \"__TEXT\"\n #define EH_FRAME_SECTION_ATTR \",coalesced,no_toc+strip_static_syms+live_support\"\n@@ -834,22 +833,22 @@ enum machopic_addr_class {\n #define JCR_SECTION_NAME \"__DATA,jcr,regular,no_dead_strip\"\n \n #undef ASM_PREFERRED_EH_DATA_FORMAT\n-#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL) @(\n-  (((CODE) == 2 && (GLOBAL) == 1)\n-   ? (DW_EH_PE_pcrel | DW_EH_PE_indirect | DW_EH_PE_sdata4) :\n-     ((CODE) == 1 || (GLOBAL) == 0) ? DW_EH_PE_pcrel : DW_EH_PE_absptr)@)\n+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL)  \\\n+  (((CODE) == 2 && (GLOBAL) == 1) \\\n+   ? (DW_EH_PE_pcrel | DW_EH_PE_indirect | DW_EH_PE_sdata4) : \\\n+     ((CODE) == 1 || (GLOBAL) == 0) ? DW_EH_PE_pcrel : DW_EH_PE_absptr)\n \n-#define ASM_OUTPUT_DWARF_DELTA(FILE,SIZE,LABEL1,LABEL2) @(\n-  darwin_asm_output_dwarf_delta (FILE, SIZE, LABEL1, LABEL2)@)\n+#define ASM_OUTPUT_DWARF_DELTA(FILE,SIZE,LABEL1,LABEL2)  \\\n+  darwin_asm_output_dwarf_delta (FILE, SIZE, LABEL1, LABEL2)\n \n-#define ASM_OUTPUT_DWARF_OFFSET(FILE,SIZE,LABEL,BASE) @(\n-  darwin_asm_output_dwarf_offset (FILE, SIZE, LABEL, BASE)@)\n+#define ASM_OUTPUT_DWARF_OFFSET(FILE,SIZE,LABEL,BASE)  \\\n+  darwin_asm_output_dwarf_offset (FILE, SIZE, LABEL, BASE)\n \n-#define ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX(ASM_OUT_FILE, ENCODING, SIZE, ADDR, DONE) @(\n-      if (ENCODING == ASM_PREFERRED_EH_DATA_FORMAT (2, 1)) {\n-\tdarwin_non_lazy_pcrel (ASM_OUT_FILE, ADDR);\n-\tgoto DONE;\n-      }@)\n+#define ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX(ASM_OUT_FILE, ENCODING, SIZE, ADDR, DONE)\t\\\n+      if (ENCODING == ASM_PREFERRED_EH_DATA_FORMAT (2, 1)) {\t\t\t\t\\\n+\tdarwin_non_lazy_pcrel (ASM_OUT_FILE, ADDR);\t\t\t\t\t\\\n+\tgoto DONE;\t\t\t\t\t\t\t\t\t\\\n+      }\n \n /* Experimentally, putting jump tables in text is faster on SPEC.\n    Also this is needed for correctness for coalesced functions.  */\n@@ -864,16 +863,16 @@ enum machopic_addr_class {\n #undef TARGET_ASM_NAMED_SECTION\n #define TARGET_ASM_NAMED_SECTION darwin_asm_named_section\n \n-#define DARWIN_REGISTER_TARGET_PRAGMAS() @(\n-  do {\n-    if (!flag_preprocess_only)\n-      cpp_register_pragma (parse_in, NULL, \"mark\",\n-\t\t\t   darwin_pragma_ignore, false);\n-    c_register_pragma (0, \"options\", darwin_pragma_options);\n-    c_register_pragma (0, \"segment\", darwin_pragma_ignore);\n-    c_register_pragma (0, \"unused\", darwin_pragma_unused);\n-    c_register_pragma (0, \"ms_struct\", darwin_pragma_ms_struct);\n-  } while (0)@)\n+#define DARWIN_REGISTER_TARGET_PRAGMAS()\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if (!flag_preprocess_only)\t\t\t\t\t\\\n+      cpp_register_pragma (parse_in, NULL, \"mark\",\t\t\\\n+\t\t\t   darwin_pragma_ignore, false);\t\\\n+    c_register_pragma (0, \"options\", darwin_pragma_options);\t\\\n+    c_register_pragma (0, \"segment\", darwin_pragma_ignore);\t\\\n+    c_register_pragma (0, \"unused\", darwin_pragma_unused);\t\\\n+    c_register_pragma (0, \"ms_struct\", darwin_pragma_ms_struct); \\\n+  } while (0)\n \n #undef ASM_APP_ON\n #define ASM_APP_ON \"\"\n@@ -903,7 +902,7 @@ void add_framework_path (char *);\n #undef GOMP_SELF_SPECS\n #define GOMP_SELF_SPECS \"\"\n \n-/* Darwin disables section anchors by default.\n+/* Darwin disables section anchors by default.  \n    They should be enabled per arch where support exists in that arch.  */\n #define TARGET_ASM_OUTPUT_ANCHOR NULL\n #define DARWIN_SECTION_ANCHORS 0\n@@ -921,31 +920,30 @@ void add_framework_path (char *);\n     considered dangerous for library calls to send messages to\n     stdout/stderr.  */\n \n-#define ENABLE_EXECUTE_STACK @(\n-  extern void __enable_execute_stack (void *);\n-\n-  void\n-  __enable_execute_stack (void *addr)\n-  {\n-    extern int mprotect (void *, size_t, int);\n-    extern int getpagesize (void);\n-    static int size;\n-    static long mask;\n-\n-    char *page, *end;\n-\n-    if (size == 0)\n-      {\n-\tsize = getpagesize();\n-\tmask = ~((long) size - 1);\n-      }\n-\n-    page = (char *) (((long) addr) & mask);\n-    end  = (char *) ((((long) (addr + (TARGET_64BIT ? 48 : 40))) & mask) + size);\n-\n-    /* 7 == PROT_READ | PROT_WRITE | PROT_EXEC */\n-    (void) mprotect (page, end - page, 7);\n-  }@)\n+#define ENABLE_EXECUTE_STACK                                            \\\n+extern void __enable_execute_stack (void *);                            \\\n+void                                                                    \\\n+__enable_execute_stack (void *addr)                                     \\\n+{                                                                       \\\n+   extern int mprotect (void *, size_t, int);                           \\\n+   extern int getpagesize (void);\t\t\t\t\t\\\n+   static int size;                                                     \\\n+   static long mask;                                                    \\\n+                                                                        \\\n+   char *page, *end;                                                    \\\n+                                                                        \\\n+   if (size == 0)                                                       \\\n+     {                                                                  \\\n+       size = getpagesize();\t\t\t\t\t\t\\\n+       mask = ~((long) size - 1);                                       \\\n+     }                                                                  \\\n+                                                                        \\\n+   page = (char *) (((long) addr) & mask);                              \\\n+   end  = (char *) ((((long) (addr + (TARGET_64BIT ? 48 : 40))) & mask) + size); \\\n+                                                                        \\\n+   /* 7 == PROT_READ | PROT_WRITE | PROT_EXEC */                        \\\n+   (void) mprotect (page, end - page, 7);                               \\\n+}\n \n /* For Apple KEXTs, we make the constructors return this to match gcc\n    2.95.  */\n@@ -955,24 +953,24 @@ void add_framework_path (char *);\n /* We have target-specific builtins.  */\n #define TARGET_FOLD_BUILTIN darwin_fold_builtin\n \n-#define TARGET_OBJC_CONSTRUCT_STRING_OBJECT @(\n-  darwin_objc_construct_string@)\n+#define TARGET_OBJC_CONSTRUCT_STRING_OBJECT \\\n+  darwin_objc_construct_string\n \n-#define TARGET_STRING_OBJECT_REF_TYPE_P @(\n-  darwin_cfstring_ref_p@)\n+#define TARGET_STRING_OBJECT_REF_TYPE_P \\\n+  darwin_cfstring_ref_p\n \n #define TARGET_N_FORMAT_TYPES 1\n #define TARGET_FORMAT_TYPES darwin_additional_format_types\n \n-#define TARGET_CHECK_STRING_OBJECT_FORMAT_ARG @(\n-  darwin_check_cfstring_format_arg@)\n+#define TARGET_CHECK_STRING_OBJECT_FORMAT_ARG \\\n+  darwin_check_cfstring_format_arg\n \n #define TARGET_HAS_TARGETCM 1\n \n #ifndef USED_FOR_TARGET\n extern void darwin_driver_init (unsigned int *,struct cl_decoded_option **);\n-#define GCC_DRIVER_HOST_INITIALIZATION @(\n-  darwin_driver_init (&decoded_options_count, &decoded_options)@)\n+#define GCC_DRIVER_HOST_INITIALIZATION \\\n+  darwin_driver_init (&decoded_options_count, &decoded_options)\n #endif\n \n /* The Apple assembler and linker do not support constructor priorities.  */"}, {"sha": "555bf8831c3e74c7dc45a7a381f70c3db0dfbd0b", "filename": "gcc/config/slashify.c", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/975b975b29fa2aa9dd562a55006a4cd93421a652/gcc%2Fconfig%2Fslashify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/975b975b29fa2aa9dd562a55006a4cd93421a652/gcc%2Fconfig%2Fslashify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fslashify.c?ref=975b975b29fa2aa9dd562a55006a4cd93421a652", "patch": "@@ -1,56 +0,0 @@\n-/* Generate a slashified version of the input\n-   Copyright (C) 2011\n-   Free Software Foundation, Inc.\n-   Contributed by Mike Stump <mikestump@comcast.net>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-/* This is a small utility to slashify a source file so that one never\n-   needs to stare at backslashes.  */\n-\n-#include <stdio.h>\n-\n-extern int main (void);\n-\n-int main (void) {\n-  int c,c1;\n-  int saw_start = 0;\n-  while ((c=getchar ()) != EOF) {\n-    if (c != '@') {\n-      if (saw_start && c == '\\n') {\n-\tputchar ('\\\\');\n-      }\n-      putchar (c);\n-      continue;\n-    }\n-    c1=getchar();\n-    if (c1 == EOF) {\n-      putchar (c);\n-      return 0;\n-    }\n-    if (!saw_start && c1 == '(') {\n-      saw_start = 1;\n-    } else if (saw_start && c1 == ')') {\n-      saw_start = 0;\n-    } else {\n-      putchar (c); \n-      putchar (c1); \n-    }\n-  }\n-  return 0;\n-}"}, {"sha": "24a7b90c3e2d2a32a94dbaf6291dac2d60dfae16", "filename": "gcc/config/t-darwin", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/gcc%2Fconfig%2Ft-darwin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/gcc%2Fconfig%2Ft-darwin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ft-darwin?ref=dd2e44f0f27961dd558b55d417dd5e780a9fc1b1", "patch": "@@ -17,20 +17,6 @@\n # along with GCC; see the file COPYING3.  If not see\n # <http://www.gnu.org/licenses/>.\n \n-build/slashify1: $(srcdir)/config/slashify.c\n-\t$(COMPILER_FOR_BUILD) $(BUILD_COMPILERFLAGS) $(BUILD_CPPFLAGS) $(srcdir)/config/slashify.c -o $@\n-\n-$(srcdir)/config/darwin.h: config/darwin.h.rebuild\n-\n-config/darwin.h.rebuild: build/slashify1\n-\t@$(mkinstalldirs) config\n-\t@if [ ! -e $(srcdir)/config/darwin.h\t\t\t\t\t\\\n-\t      -o $(srcdir)/config/darwin.h -nt config/darwin.h ]; then\t\t\\\n-\t\tcp $(srcdir)/config/darwin-sections.def\t\t\t\t\\\n-\t\t   config/darwin-sections.def &&\t\t\t\t\\\n-\t\tbuild/slashify1 < $(srcdir)/config/darwin.h  >config/darwin.h;\t\\\n-\tfi\n-\n darwin.o: $(srcdir)/config/darwin.c $(CONFIG_H) $(SYSTEM_H) coretypes.h     \\\n   $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(REAL_H) insn-config.h         \\\n   conditions.h insn-flags.h output.h insn-attr.h flags.h $(TREE_H) expr.h   \\"}, {"sha": "c3f780abe0494e11994312330d4f25e0d9680f04", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dd2e44f0f27961dd558b55d417dd5e780a9fc1b1", "patch": "@@ -1,21 +1,3 @@\n-2011-02-13  Mike Stump  <mikestump@comcast.net>\n-\n-\t* parser.c (cp_parser_primary_expression): Add arguments to all the plugins.\n-\t* lex.c: Plugify.\n-\t* Make-lang.in (objcp/plugin/lex.h): Likewise.\n-\t(build/slashify): Harden against rebuilds.\n-\t(objcp/plugin/parser.h): Harden against parallel builds.\n-\n-\t* Make-lang.in (cp/parser.o): Move c-family/c-objc.h dependancy\n-\tdown.\n-\n-2011-02-12  Mike Stump  <mikestump@comcast.net>\n-\n-\t* Make-lang.in (build/slashify): Plugify Objective-C++.\n-\t(cp/parser.o): Likewise.\n-\t(objcp/plugin/parser.h): Likewise.\n-\t* parser.c (cp_parser_token_starts_cast_expression): Likewise.\n-\n 2011-02-09  Jason Merrill  <jason@redhat.com>\n \n \t* decl.c (cp_make_fname_decl): Set DECL_THIS_STATIC at toplevel."}, {"sha": "373471448a4ace7fd1a9522a802fe5fdb29e4378", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=dd2e44f0f27961dd558b55d417dd5e780a9fc1b1", "patch": "@@ -247,7 +247,8 @@ CXX_TREE_H = $(TREE_H) cp/name-lookup.h cp/cp-tree.h $(C_COMMON_H) \\\n CXX_PRETTY_PRINT_H = cp/cxx-pretty-print.h $(C_PRETTY_PRINT_H)\n \n cp/lex.o: cp/lex.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) \\\n-  $(C_PRAGMA_H) output.h input.h cp/operators.def $(TM_P_H)\n+  $(C_PRAGMA_H) output.h input.h cp/operators.def $(TM_P_H) \\\n+  c-family/c-objc.h\n cp/cp-lang.o: cp/cp-lang.c $(CXX_TREE_H) $(TM_H) debug.h langhooks.h \\\n   $(LANGHOOKS_DEF_H) $(C_COMMON_H) gtype-cp.h gt-cp-cp-lang.h \\\n   cp/cp-objcp-common.h $(EXPR_H) $(TARGET_H)\n@@ -314,7 +315,8 @@ cp/optimize.o: cp/optimize.c $(CXX_TREE_H) $(TM_H) \\\n cp/mangle.o: cp/mangle.c $(CXX_TREE_H) $(TM_H) $(REAL_H) \\\n   gt-cp-mangle.h $(TARGET_H) $(TM_P_H) $(CGRAPH_H)\n cp/parser.o: cp/parser.c $(CXX_TREE_H) $(TM_H) $(DIAGNOSTIC_CORE_H) \\\n-  gt-cp-parser.h output.h $(TARGET_H) $(PLUGIN_H) intl.h\n+  gt-cp-parser.h output.h $(TARGET_H) $(PLUGIN_H) intl.h \\\n+  c-family/c-objc.h\n cp/cp-gimplify.o: cp/cp-gimplify.c $(CXX_TREE_H) $(C_COMMON_H) \\\n \t$(TM_H) coretypes.h pointer-set.h tree-iterator.h\n \n@@ -324,24 +326,3 @@ cp/name-lookup.o: cp/name-lookup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \n cp/cxx-pretty-print.o: cp/cxx-pretty-print.c $(CXX_PRETTY_PRINT_H) \\\n   $(CONFIG_H) $(SYSTEM_H) $(TM_H) coretypes.h $(CXX_TREE_H) tree-pretty-print.h\n-\n-\n-# Objective-C++ related rules:\n-\n-cp/parser.o: $(objdir)/objcp/plugin/parser.h $(srcdir)/objcp/plugin/parser.c \\\n-\tc-family/c-objc.h\n-\n-cp/lex.o: $(objdir)/objcp/plugin/lex.h c-family/c-objc.h\n-\n-# Would like to get rid of the #, but we always rebuild the checksum\n-# if we do\n-build/slashify: # $(srcdir)/config/slashify.c\n-\t$(COMPILER_FOR_BUILD) $(BUILD_COMPILERFLAGS) $(BUILD_CPPFLAGS) $(srcdir)/config/slashify.c -o $@\n-\n-$(objdir)/objcp/plugin/parser.h: $(srcdir)/objcp/plugin/parser.h build/slashify\n-\t$(mkinstalldirs) objcp/plugin\n-\tbuild/slashify < $< > $@\n-\n-$(objdir)/objcp/plugin/lex.h: $(srcdir)/objcp/plugin/lex.h build/slashify\n-\t$(mkinstalldirs) objcp/plugin\n-\tbuild/slashify < $< > $@"}, {"sha": "852c3a2867acbcfc53c843f342b7000685d2542f", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=dd2e44f0f27961dd558b55d417dd5e780a9fc1b1", "patch": "@@ -33,7 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cpplib.h\"\n #include \"flags.h\"\n #include \"c-family/c-pragma.h\"\n-#include \"objcp/plugin/lex.h\"\n+#include \"c-family/c-objc.h\"\n #include \"output.h\"\n #include \"tm_p.h\"\n #include \"timevar.h\"\n@@ -449,7 +449,7 @@ unqualified_name_lookup_error (tree name)\n     }\n   else\n     {\n-      if (!PLUGIN_UNQUALIFIED_NAME_LOOKUP_ERROR (name))\n+      if (!objc_diagnose_private_ivar (name))\n \t{\n \t  error (\"%qD was not declared in this scope\", name);\n \t  suggest_alternatives_for (location_of (name), name);"}, {"sha": "11039b899ccd4e94f0585f3be5aeffb5ea789d08", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2020, "deletions": 18, "changes": 2038, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=dd2e44f0f27961dd558b55d417dd5e780a9fc1b1", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"cgraph.h\"\n #include \"c-family/c-common.h\"\n+#include \"c-family/c-objc.h\"\n #include \"plugin.h\"\n \n \f\n@@ -2098,7 +2099,44 @@ enum pragma_context { pragma_external, pragma_stmt, pragma_compound };\n static bool cp_parser_pragma\n   (cp_parser *, enum pragma_context);\n \n-#include \"objcp/plugin/parser.h\"\n+/* Objective-C++ Productions */\n+\n+static tree cp_parser_objc_message_receiver\n+  (cp_parser *);\n+static tree cp_parser_objc_message_args\n+  (cp_parser *);\n+static tree cp_parser_objc_message_expression\n+  (cp_parser *);\n+static tree cp_parser_objc_encode_expression\n+  (cp_parser *);\n+static tree cp_parser_objc_defs_expression\n+  (cp_parser *);\n+static tree cp_parser_objc_protocol_expression\n+  (cp_parser *);\n+static tree cp_parser_objc_selector_expression\n+  (cp_parser *);\n+static tree cp_parser_objc_expression\n+  (cp_parser *);\n+static bool cp_parser_objc_selector_p\n+  (enum cpp_ttype);\n+static tree cp_parser_objc_selector\n+  (cp_parser *);\n+static tree cp_parser_objc_protocol_refs_opt\n+  (cp_parser *);\n+static void cp_parser_objc_declaration\n+  (cp_parser *, tree);\n+static tree cp_parser_objc_statement\n+  (cp_parser *);\n+static bool cp_parser_objc_valid_prefix_attributes\n+  (cp_parser *, tree *);\n+static void cp_parser_objc_at_property_declaration \n+  (cp_parser *) ;\n+static void cp_parser_objc_at_synthesize_declaration \n+  (cp_parser *) ;\n+static void cp_parser_objc_at_dynamic_declaration\n+  (cp_parser *) ;\n+static tree cp_parser_objc_struct_declaration\n+  (cp_parser *) ;\n \n /* Utility Routines */\n \n@@ -3671,11 +3709,18 @@ cp_parser_primary_expression (cp_parser *parser,\n       }\n \n     case CPP_OPEN_SQUARE:\n-      PLUGIN_PRIMARY_EXPRESSION_3 (parser);\n+      if (c_dialect_objc ())\n+        /* We have an Objective-C++ message. */\n+        return cp_parser_objc_expression (parser);\n       maybe_warn_cpp0x (CPP0X_LAMBDA_EXPR);\n       return cp_parser_lambda_expression (parser);\n \n-    PLUGIN_PRIMARY_EXPRESSION_2 (parser, cp_parser_error)\n+    case CPP_OBJC_STRING:\n+      if (c_dialect_objc ())\n+\t/* We have an Objective-C++ string literal. */\n+        return cp_parser_objc_expression (parser);\n+      cp_parser_error (parser, \"expected primary-expression\");\n+      return error_mark_node;\n \n     case CPP_KEYWORD:\n       switch (token->keyword)\n@@ -3806,7 +3851,11 @@ cp_parser_primary_expression (cp_parser *parser,\n \tcase RID_IS_LITERAL_TYPE:\n \t  return cp_parser_trait_expr (parser, token->keyword);\n \n-\tPLUGIN_PRIMARY_EXPRESSION_1 (parser)\n+\t/* Objective-C++ expressions.  */\n+\tcase RID_AT_ENCODE:\n+\tcase RID_AT_PROTOCOL:\n+\tcase RID_AT_SELECTOR:\n+\t  return cp_parser_objc_expression (parser);\n \n \tcase RID_TEMPLATE:\n \t  if (parser->in_function_body\n@@ -3890,8 +3939,25 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    if (ambiguous_decls)\n \t      return error_mark_node;\n \n-\t    PLUGIN_PRIMARY_EXPRESSION (parser, decl, cp_lexer_consume_token,\n-\t\t\t\t       cp_lexer_peek_token);\n+\t    /* In Objective-C++, we may have an Objective-C 2.0\n+\t       dot-syntax for classes here.  */\n+\t    if (c_dialect_objc ()\n+\t\t&& cp_lexer_peek_token (parser->lexer)->type == CPP_DOT\n+\t\t&& TREE_CODE (decl) == TYPE_DECL\n+\t\t&& objc_is_class_name (decl))\n+\t      {\n+\t\ttree component;\n+\t\tcp_lexer_consume_token (parser->lexer);\n+\t\tcomponent = cp_parser_identifier (parser);\n+\t\tif (component == error_mark_node)\n+\t\t  return error_mark_node;\n+\n+\t\treturn objc_build_class_component_ref (id_expression, component);\n+\t      }\n+\n+\t    /* In Objective-C++, an instance variable (ivar) may be preferred\n+\t       to whatever cp_parser_lookup_name() found.  */\n+\t    decl = objc_lookup_ivar (decl, id_expression);\n \n \t    /* If name lookup gives us a SCOPE_REF, then the\n \t       qualifying scope was dependent.  */\n@@ -6529,9 +6595,9 @@ cp_parser_token_starts_cast_expression (cp_token *token)\n     case CPP_EOF:\n       return false;\n \n+      /* '[' may start a primary-expression in obj-c++.  */\n     case CPP_OPEN_SQUARE:\n-      PLUGIN_TOKEN_STARTS_CAST_EXPR;\n-      return false;\n+      return c_dialect_objc ();\n \n     default:\n       return true;\n@@ -8016,7 +8082,14 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t  statement = cp_parser_jump_statement (parser);\n \t  break;\n \n-\tPLUGIN_STATEMENT\n+\t  /* Objective-C++ exception-handling constructs.  */\n+\tcase RID_AT_TRY:\n+\tcase RID_AT_CATCH:\n+\tcase RID_AT_FINALLY:\n+\tcase RID_AT_SYNCHRONIZED:\n+\tcase RID_AT_THROW:\n+\t  statement = cp_parser_objc_statement (parser);\n+\t  break;\n \n \tcase RID_TRY:\n \t  statement = cp_parser_try_block (parser);\n@@ -9401,7 +9474,13 @@ cp_parser_declaration (cp_parser* parser)\n   else if (token1.keyword == RID_INLINE\n \t   && token2.keyword == RID_NAMESPACE)\n     cp_parser_namespace_definition (parser);\n-  PLUGIN_DECLARATION (token1, attributes)\n+  /* Objective-C++ declaration/definition.  */\n+  else if (c_dialect_objc () && OBJC_IS_AT_KEYWORD (token1.keyword))\n+    cp_parser_objc_declaration (parser, NULL_TREE);\n+  else if (c_dialect_objc ()\n+\t   && token1.keyword == RID_ATTRIBUTE\n+\t   && cp_parser_objc_valid_prefix_attributes (parser, &attributes))\n+    cp_parser_objc_declaration (parser, attributes);\n   /* We must have either a block declaration or a function\n      definition.  */\n   else\n@@ -12800,7 +12879,25 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \n   if (type && type != error_mark_node)\n     {\n-      PLUGIN_SIMPLE_TYPE_SPECIFIER (parser, type, decl_specs);\n+      /* See if TYPE is an Objective-C type, and if so, parse and\n+\t accept any protocol references following it.  Do this before\n+\t the cp_parser_check_for_invalid_template_id() call, because\n+\t Objective-C types can be followed by '<...>' which would\n+\t enclose protocol names rather than template arguments, and so\n+\t everything is fine.  */\n+      if (c_dialect_objc () && !parser->scope\n+\t  && (objc_is_id (type) || objc_is_class_name (type)))\n+\t{\n+\t  tree protos = cp_parser_objc_protocol_refs_opt (parser);\n+\t  tree qual_type = objc_get_protocol_qualified_type (type, protos);\n+\n+\t  /* Clobber the \"unqualified\" type previously entered into\n+\t     DECL_SPECS with the new, improved protocol-qualified version.  */\n+\t  if (decl_specs)\n+\t    decl_specs->type = qual_type;\n+\n+\t  return qual_type;\n+\t}\n \n       /* There is no valid C++ program where a non-template type is\n \t followed by a \"<\".  That usually indicates that the user\n@@ -12876,11 +12973,26 @@ cp_parser_nonclass_name (cp_parser* parser)\n   /* Look up the type-name.  */\n   type_decl = cp_parser_lookup_name_simple (parser, identifier, token->location);\n \n-  PLUGIN_NONCLASS_NAME1 (parser, type_decl, identifier);\n+  if (TREE_CODE (type_decl) != TYPE_DECL\n+      && (objc_is_id (identifier) || objc_is_class_name (identifier)))\n+    {\n+      /* See if this is an Objective-C type.  */\n+      tree protos = cp_parser_objc_protocol_refs_opt (parser);\n+      tree type = objc_get_protocol_qualified_type (identifier, protos);\n+      if (type)\n+\ttype_decl = TYPE_NAME (type);\n+    }\n \n   /* Issue an error if we did not find a type-name.  */\n   if (TREE_CODE (type_decl) != TYPE_DECL\n-      PLUGIN_NONCLASS_NAME (parser, type_decl, cp_lexer_peek_token))\n+      /* In Objective-C, we have the complication that class names are\n+\t normally type names and start declarations (eg, the\n+\t \"NSObject\" in \"NSObject *object;\"), but can be used in an\n+\t Objective-C 2.0 dot-syntax (as in \"NSObject.version\") which\n+\t is an expression.  So, a classname followed by a dot is not a\n+\t valid type-name.  */\n+      || (objc_is_class_name (TREE_TYPE (type_decl))\n+\t  && cp_lexer_peek_token (parser->lexer)->type == CPP_DOT))\n     {\n       if (!cp_parser_simulate_error (parser))\n \tcp_parser_name_lookup_error (parser, identifier, type_decl,\n@@ -16724,7 +16836,11 @@ cp_parser_class_name (cp_parser *parser,\n   else if (TREE_CODE (decl) != TYPE_DECL\n \t   || TREE_TYPE (decl) == error_mark_node\n \t   || !MAYBE_CLASS_TYPE_P (TREE_TYPE (decl))\n-\t   PLUGIN_CLASS_NAME (parser, cp_lexer_peek_token, CPP_DOT))\n+\t   /* In Objective-C 2.0, a classname followed by '.' starts a\n+\t      dot-syntax expression, and it's not a type-name.  */\n+\t   || (c_dialect_objc ()\n+\t       && cp_lexer_peek_token (parser->lexer)->type == CPP_DOT \n+\t       && objc_is_class_name (decl)))\n     decl = error_mark_node;\n \n   if (decl == error_mark_node)\n@@ -17585,8 +17701,21 @@ cp_parser_member_declaration (cp_parser* parser)\n       return;\n     }\n \n-  PLUGIN_MEMBER_DECLARATION (parser, cp_lexer_next_token_is_keyword,\n-\t\t\t     finish_member_declaration);\n+  /* Check for @defs.  */\n+  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_DEFS))\n+    {\n+      tree ivar, member;\n+      tree ivar_chains = cp_parser_objc_defs_expression (parser);\n+      ivar = ivar_chains;\n+      while (ivar)\n+\t{\n+\t  member = ivar;\n+\t  ivar = TREE_CHAIN (member);\n+\t  TREE_CHAIN (member) = NULL_TREE;\n+\t  finish_member_declaration (member);\n+\t}\n+      return;\n+    }\n \n   /* If the next token is `static_assert' we have a static assertion.  */\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_STATIC_ASSERT))\n@@ -21302,11 +21431,1884 @@ cp_parser_allow_gnu_extensions_p (cp_parser* parser)\n {\n   return parser->allow_gnu_extensions_p;\n }\n-\n \f\n /* Objective-C++ Productions */\n \n-#include \"../objcp/plugin/parser.c\"\n+\n+/* Parse an Objective-C expression, which feeds into a primary-expression\n+   above.\n+\n+   objc-expression:\n+     objc-message-expression\n+     objc-string-literal\n+     objc-encode-expression\n+     objc-protocol-expression\n+     objc-selector-expression\n+\n+  Returns a tree representation of the expression.  */\n+\n+static tree\n+cp_parser_objc_expression (cp_parser* parser)\n+{\n+  /* Try to figure out what kind of declaration is present.  */\n+  cp_token *kwd = cp_lexer_peek_token (parser->lexer);\n+\n+  switch (kwd->type)\n+    {\n+    case CPP_OPEN_SQUARE:\n+      return cp_parser_objc_message_expression (parser);\n+\n+    case CPP_OBJC_STRING:\n+      kwd = cp_lexer_consume_token (parser->lexer);\n+      return objc_build_string_object (kwd->u.value);\n+\n+    case CPP_KEYWORD:\n+      switch (kwd->keyword)\n+\t{\n+\tcase RID_AT_ENCODE:\n+\t  return cp_parser_objc_encode_expression (parser);\n+\n+\tcase RID_AT_PROTOCOL:\n+\t  return cp_parser_objc_protocol_expression (parser);\n+\n+\tcase RID_AT_SELECTOR:\n+\t  return cp_parser_objc_selector_expression (parser);\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    default:\n+      error_at (kwd->location,\n+\t\t\"misplaced %<@%D%> Objective-C++ construct\",\n+\t\tkwd->u.value);\n+      cp_parser_skip_to_end_of_block_or_statement (parser);\n+    }\n+\n+  return error_mark_node;\n+}\n+\n+/* Parse an Objective-C message expression.\n+\n+   objc-message-expression:\n+     [ objc-message-receiver objc-message-args ]\n+\n+   Returns a representation of an Objective-C message.  */\n+\n+static tree\n+cp_parser_objc_message_expression (cp_parser* parser)\n+{\n+  tree receiver, messageargs;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '['.  */\n+  receiver = cp_parser_objc_message_receiver (parser);\n+  messageargs = cp_parser_objc_message_args (parser);\n+  cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n+\n+  return objc_build_message_expr (build_tree_list (receiver, messageargs));\n+}\n+\n+/* Parse an objc-message-receiver.\n+\n+   objc-message-receiver:\n+     expression\n+     simple-type-specifier\n+\n+  Returns a representation of the type or expression.  */\n+\n+static tree\n+cp_parser_objc_message_receiver (cp_parser* parser)\n+{\n+  tree rcv;\n+\n+  /* An Objective-C message receiver may be either (1) a type\n+     or (2) an expression.  */\n+  cp_parser_parse_tentatively (parser);\n+  rcv = cp_parser_expression (parser, false, NULL);\n+\n+  if (cp_parser_parse_definitely (parser))\n+    return rcv;\n+\n+  rcv = cp_parser_simple_type_specifier (parser,\n+\t\t\t\t\t /*decl_specs=*/NULL,\n+\t\t\t\t\t CP_PARSER_FLAGS_NONE);\n+\n+  return objc_get_class_reference (rcv);\n+}\n+\n+/* Parse the arguments and selectors comprising an Objective-C message.\n+\n+   objc-message-args:\n+     objc-selector\n+     objc-selector-args\n+     objc-selector-args , objc-comma-args\n+\n+   objc-selector-args:\n+     objc-selector [opt] : assignment-expression\n+     objc-selector-args objc-selector [opt] : assignment-expression\n+\n+   objc-comma-args:\n+     assignment-expression\n+     objc-comma-args , assignment-expression\n+\n+   Returns a TREE_LIST, with TREE_PURPOSE containing a list of\n+   selector arguments and TREE_VALUE containing a list of comma\n+   arguments.  */\n+\n+static tree\n+cp_parser_objc_message_args (cp_parser* parser)\n+{\n+  tree sel_args = NULL_TREE, addl_args = NULL_TREE;\n+  bool maybe_unary_selector_p = true;\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON)\n+    {\n+      tree selector = NULL_TREE, arg;\n+\n+      if (token->type != CPP_COLON)\n+\tselector = cp_parser_objc_selector (parser);\n+\n+      /* Detect if we have a unary selector.  */\n+      if (maybe_unary_selector_p\n+\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n+\treturn build_tree_list (selector, NULL_TREE);\n+\n+      maybe_unary_selector_p = false;\n+      cp_parser_require (parser, CPP_COLON, RT_COLON);\n+      arg = cp_parser_assignment_expression (parser, false, NULL);\n+\n+      sel_args\n+\t= chainon (sel_args,\n+\t\t   build_tree_list (selector, arg));\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  /* Handle non-selector arguments, if any. */\n+  while (token->type == CPP_COMMA)\n+    {\n+      tree arg;\n+\n+      cp_lexer_consume_token (parser->lexer);\n+      arg = cp_parser_assignment_expression (parser, false, NULL);\n+\n+      addl_args\n+\t= chainon (addl_args,\n+\t\t   build_tree_list (NULL_TREE, arg));\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  if (sel_args == NULL_TREE && addl_args == NULL_TREE)\n+    {\n+      cp_parser_error (parser, \"objective-c++ message argument(s) are expected\");\n+      return build_tree_list (error_mark_node, error_mark_node);\n+    }\n+\n+  return build_tree_list (sel_args, addl_args);\n+}\n+\n+/* Parse an Objective-C encode expression.\n+\n+   objc-encode-expression:\n+     @encode objc-typename\n+\n+   Returns an encoded representation of the type argument.  */\n+\n+static tree\n+cp_parser_objc_encode_expression (cp_parser* parser)\n+{\n+  tree type;\n+  cp_token *token;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@encode'.  */\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  token = cp_lexer_peek_token (parser->lexer);\n+  type = complete_type (cp_parser_type_id (parser));\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\n+  if (!type)\n+    {\n+      error_at (token->location, \n+\t\t\"%<@encode%> must specify a type as an argument\");\n+      return error_mark_node;\n+    }\n+\n+  /* This happens if we find @encode(T) (where T is a template\n+     typename or something dependent on a template typename) when\n+     parsing a template.  In that case, we can't compile it\n+     immediately, but we rather create an AT_ENCODE_EXPR which will\n+     need to be instantiated when the template is used.\n+  */\n+  if (dependent_type_p (type))\n+    {\n+      tree value = build_min (AT_ENCODE_EXPR, size_type_node, type);\n+      TREE_READONLY (value) = 1;\n+      return value;\n+    }\n+\n+  return objc_build_encode_expr (type);\n+}\n+\n+/* Parse an Objective-C @defs expression.  */\n+\n+static tree\n+cp_parser_objc_defs_expression (cp_parser *parser)\n+{\n+  tree name;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@defs'.  */\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  name = cp_parser_identifier (parser);\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\n+  return objc_get_class_ivars (name);\n+}\n+\n+/* Parse an Objective-C protocol expression.\n+\n+  objc-protocol-expression:\n+    @protocol ( identifier )\n+\n+  Returns a representation of the protocol expression.  */\n+\n+static tree\n+cp_parser_objc_protocol_expression (cp_parser* parser)\n+{\n+  tree proto;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@protocol'.  */\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  proto = cp_parser_identifier (parser);\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\n+  return objc_build_protocol_expr (proto);\n+}\n+\n+/* Parse an Objective-C selector expression.\n+\n+   objc-selector-expression:\n+     @selector ( objc-method-signature )\n+\n+   objc-method-signature:\n+     objc-selector\n+     objc-selector-seq\n+\n+   objc-selector-seq:\n+     objc-selector :\n+     objc-selector-seq objc-selector :\n+\n+  Returns a representation of the method selector.  */\n+\n+static tree\n+cp_parser_objc_selector_expression (cp_parser* parser)\n+{\n+  tree sel_seq = NULL_TREE;\n+  bool maybe_unary_selector_p = true;\n+  cp_token *token;\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@selector'.  */\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  token = cp_lexer_peek_token (parser->lexer);\n+\n+  while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON\n+\t || token->type == CPP_SCOPE)\n+    {\n+      tree selector = NULL_TREE;\n+\n+      if (token->type != CPP_COLON\n+\t  || token->type == CPP_SCOPE)\n+\tselector = cp_parser_objc_selector (parser);\n+\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_COLON)\n+\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_SCOPE))\n+\t{\n+\t  /* Detect if we have a unary selector.  */\n+\t  if (maybe_unary_selector_p)\n+\t    {\n+\t      sel_seq = selector;\n+\t      goto finish_selector;\n+\t    }\n+\t  else\n+\t    {\n+\t      cp_parser_error (parser, \"expected %<:%>\");\n+\t    }\n+\t}\n+      maybe_unary_selector_p = false;\n+      token = cp_lexer_consume_token (parser->lexer);\n+\n+      if (token->type == CPP_SCOPE)\n+\t{\n+\t  sel_seq\n+\t    = chainon (sel_seq,\n+\t\t       build_tree_list (selector, NULL_TREE));\n+\t  sel_seq\n+\t    = chainon (sel_seq,\n+\t\t       build_tree_list (NULL_TREE, NULL_TREE));\n+\t}\n+      else\n+\tsel_seq\n+\t  = chainon (sel_seq,\n+\t\t     build_tree_list (selector, NULL_TREE));\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+ finish_selector:\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\n+  return objc_build_selector_expr (loc, sel_seq);\n+}\n+\n+/* Parse a list of identifiers.\n+\n+   objc-identifier-list:\n+     identifier\n+     objc-identifier-list , identifier\n+\n+   Returns a TREE_LIST of identifier nodes.  */\n+\n+static tree\n+cp_parser_objc_identifier_list (cp_parser* parser)\n+{\n+  tree identifier;\n+  tree list;\n+  cp_token *sep;\n+\n+  identifier = cp_parser_identifier (parser);\n+  if (identifier == error_mark_node)\n+    return error_mark_node;      \n+\n+  list = build_tree_list (NULL_TREE, identifier);\n+  sep = cp_lexer_peek_token (parser->lexer);\n+\n+  while (sep->type == CPP_COMMA)\n+    {\n+      cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n+      identifier = cp_parser_identifier (parser);\n+      if (identifier == error_mark_node)\n+\treturn list;\n+\n+      list = chainon (list, build_tree_list (NULL_TREE,\n+\t\t\t\t\t     identifier));\n+      sep = cp_lexer_peek_token (parser->lexer);\n+    }\n+  \n+  return list;\n+}\n+\n+/* Parse an Objective-C alias declaration.\n+\n+   objc-alias-declaration:\n+     @compatibility_alias identifier identifier ;\n+\n+   This function registers the alias mapping with the Objective-C front end.\n+   It returns nothing.  */\n+\n+static void\n+cp_parser_objc_alias_declaration (cp_parser* parser)\n+{\n+  tree alias, orig;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@compatibility_alias'.  */\n+  alias = cp_parser_identifier (parser);\n+  orig = cp_parser_identifier (parser);\n+  objc_declare_alias (alias, orig);\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+}\n+\n+/* Parse an Objective-C class forward-declaration.\n+\n+   objc-class-declaration:\n+     @class objc-identifier-list ;\n+\n+   The function registers the forward declarations with the Objective-C\n+   front end.  It returns nothing.  */\n+\n+static void\n+cp_parser_objc_class_declaration (cp_parser* parser)\n+{\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@class'.  */\n+  objc_declare_class (cp_parser_objc_identifier_list (parser));\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+}\n+\n+/* Parse a list of Objective-C protocol references.\n+\n+   objc-protocol-refs-opt:\n+     objc-protocol-refs [opt]\n+\n+   objc-protocol-refs:\n+     < objc-identifier-list >\n+\n+   Returns a TREE_LIST of identifiers, if any.  */\n+\n+static tree\n+cp_parser_objc_protocol_refs_opt (cp_parser* parser)\n+{\n+  tree protorefs = NULL_TREE;\n+\n+  if(cp_lexer_next_token_is (parser->lexer, CPP_LESS))\n+    {\n+      cp_lexer_consume_token (parser->lexer);  /* Eat '<'.  */\n+      protorefs = cp_parser_objc_identifier_list (parser);\n+      cp_parser_require (parser, CPP_GREATER, RT_GREATER);\n+    }\n+\n+  return protorefs;\n+}\n+\n+/* Parse a Objective-C visibility specification.  */\n+\n+static void\n+cp_parser_objc_visibility_spec (cp_parser* parser)\n+{\n+  cp_token *vis = cp_lexer_peek_token (parser->lexer);\n+\n+  switch (vis->keyword)\n+    {\n+    case RID_AT_PRIVATE:\n+      objc_set_visibility (OBJC_IVAR_VIS_PRIVATE);\n+      break;\n+    case RID_AT_PROTECTED:\n+      objc_set_visibility (OBJC_IVAR_VIS_PROTECTED);\n+      break;\n+    case RID_AT_PUBLIC:\n+      objc_set_visibility (OBJC_IVAR_VIS_PUBLIC);\n+      break;\n+    case RID_AT_PACKAGE:\n+      objc_set_visibility (OBJC_IVAR_VIS_PACKAGE);\n+      break;\n+    default:\n+      return;\n+    }\n+\n+  /* Eat '@private'/'@protected'/'@public'.  */\n+  cp_lexer_consume_token (parser->lexer);\n+}\n+\n+/* Parse an Objective-C method type.  Return 'true' if it is a class\n+   (+) method, and 'false' if it is an instance (-) method.  */\n+\n+static inline bool\n+cp_parser_objc_method_type (cp_parser* parser)\n+{\n+  if (cp_lexer_consume_token (parser->lexer)->type == CPP_PLUS)\n+    return true;\n+  else\n+    return false;\n+}\n+\n+/* Parse an Objective-C protocol qualifier.  */\n+\n+static tree\n+cp_parser_objc_protocol_qualifiers (cp_parser* parser)\n+{\n+  tree quals = NULL_TREE, node;\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  node = token->u.value;\n+\n+  while (node && TREE_CODE (node) == IDENTIFIER_NODE\n+\t && (node == ridpointers [(int) RID_IN]\n+\t     || node == ridpointers [(int) RID_OUT]\n+\t     || node == ridpointers [(int) RID_INOUT]\n+\t     || node == ridpointers [(int) RID_BYCOPY]\n+\t     || node == ridpointers [(int) RID_BYREF]\n+\t     || node == ridpointers [(int) RID_ONEWAY]))\n+    {\n+      quals = tree_cons (NULL_TREE, node, quals);\n+      cp_lexer_consume_token (parser->lexer);\n+      token = cp_lexer_peek_token (parser->lexer);\n+      node = token->u.value;\n+    }\n+\n+  return quals;\n+}\n+\n+/* Parse an Objective-C typename.  */\n+\n+static tree\n+cp_parser_objc_typename (cp_parser* parser)\n+{\n+  tree type_name = NULL_TREE;\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+    {\n+      tree proto_quals, cp_type = NULL_TREE;\n+\n+      cp_lexer_consume_token (parser->lexer);  /* Eat '('.  */\n+      proto_quals = cp_parser_objc_protocol_qualifiers (parser);\n+\n+      /* An ObjC type name may consist of just protocol qualifiers, in which\n+\t case the type shall default to 'id'.  */\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n+\t{\n+\t  cp_type = cp_parser_type_id (parser);\n+\t  \n+\t  /* If the type could not be parsed, an error has already\n+\t     been produced.  For error recovery, behave as if it had\n+\t     not been specified, which will use the default type\n+\t     'id'.  */\n+\t  if (cp_type == error_mark_node)\n+\t    {\n+\t      cp_type = NULL_TREE;\n+\t      /* We need to skip to the closing parenthesis as\n+\t\t cp_parser_type_id() does not seem to do it for\n+\t\t us.  */\n+\t      cp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t     /*recovering=*/true,\n+\t\t\t\t\t\t     /*or_comma=*/false,\n+\t\t\t\t\t\t     /*consume_paren=*/false);\n+\t    }\n+\t}\n+\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+      type_name = build_tree_list (proto_quals, cp_type);\n+    }\n+\n+  return type_name;\n+}\n+\n+/* Check to see if TYPE refers to an Objective-C selector name.  */\n+\n+static bool\n+cp_parser_objc_selector_p (enum cpp_ttype type)\n+{\n+  return (type == CPP_NAME || type == CPP_KEYWORD\n+\t  || type == CPP_AND_AND || type == CPP_AND_EQ || type == CPP_AND\n+\t  || type == CPP_OR || type == CPP_COMPL || type == CPP_NOT\n+\t  || type == CPP_NOT_EQ || type == CPP_OR_OR || type == CPP_OR_EQ\n+\t  || type == CPP_XOR || type == CPP_XOR_EQ);\n+}\n+\n+/* Parse an Objective-C selector.  */\n+\n+static tree\n+cp_parser_objc_selector (cp_parser* parser)\n+{\n+  cp_token *token = cp_lexer_consume_token (parser->lexer);\n+\n+  if (!cp_parser_objc_selector_p (token->type))\n+    {\n+      error_at (token->location, \"invalid Objective-C++ selector name\");\n+      return error_mark_node;\n+    }\n+\n+  /* C++ operator names are allowed to appear in ObjC selectors.  */\n+  switch (token->type)\n+    {\n+    case CPP_AND_AND: return get_identifier (\"and\");\n+    case CPP_AND_EQ: return get_identifier (\"and_eq\");\n+    case CPP_AND: return get_identifier (\"bitand\");\n+    case CPP_OR: return get_identifier (\"bitor\");\n+    case CPP_COMPL: return get_identifier (\"compl\");\n+    case CPP_NOT: return get_identifier (\"not\");\n+    case CPP_NOT_EQ: return get_identifier (\"not_eq\");\n+    case CPP_OR_OR: return get_identifier (\"or\");\n+    case CPP_OR_EQ: return get_identifier (\"or_eq\");\n+    case CPP_XOR: return get_identifier (\"xor\");\n+    case CPP_XOR_EQ: return get_identifier (\"xor_eq\");\n+    default: return token->u.value;\n+    }\n+}\n+\n+/* Parse an Objective-C params list.  */\n+\n+static tree\n+cp_parser_objc_method_keyword_params (cp_parser* parser, tree* attributes)\n+{\n+  tree params = NULL_TREE;\n+  bool maybe_unary_selector_p = true;\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON)\n+    {\n+      tree selector = NULL_TREE, type_name, identifier;\n+      tree parm_attr = NULL_TREE;\n+\n+      if (token->keyword == RID_ATTRIBUTE)\n+\tbreak;\n+\n+      if (token->type != CPP_COLON)\n+\tselector = cp_parser_objc_selector (parser);\n+\n+      /* Detect if we have a unary selector.  */\n+      if (maybe_unary_selector_p\n+\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n+\t{\n+\t  params = selector; /* Might be followed by attributes.  */\n+\t  break;\n+\t}\n+\n+      maybe_unary_selector_p = false;\n+      if (!cp_parser_require (parser, CPP_COLON, RT_COLON))\n+\t{\n+\t  /* Something went quite wrong.  There should be a colon\n+\t     here, but there is not.  Stop parsing parameters.  */\n+\t  break;\n+\t}\n+      type_name = cp_parser_objc_typename (parser);\n+      /* New ObjC allows attributes on parameters too.  */\n+      if (cp_lexer_next_token_is_keyword (parser->lexer, RID_ATTRIBUTE))\n+\tparm_attr = cp_parser_attributes_opt (parser);\n+      identifier = cp_parser_identifier (parser);\n+\n+      params\n+\t= chainon (params,\n+\t\t   objc_build_keyword_decl (selector,\n+\t\t\t\t\t    type_name,\n+\t\t\t\t\t    identifier,\n+\t\t\t\t\t    parm_attr));\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  if (params == NULL_TREE)\n+    {\n+      cp_parser_error (parser, \"objective-c++ method declaration is expected\");\n+      return error_mark_node;\n+    }\n+\n+  /* We allow tail attributes for the method.  */\n+  if (token->keyword == RID_ATTRIBUTE)\n+    {\n+      *attributes = cp_parser_attributes_opt (parser);\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON)\n+\t  || cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+\treturn params;\n+      cp_parser_error (parser, \n+\t\t       \"method attributes must be specified at the end\");\n+      return error_mark_node;\n+    }\n+\n+  if (params == NULL_TREE)\n+    {\n+      cp_parser_error (parser, \"objective-c++ method declaration is expected\");\n+      return error_mark_node;\n+    }\n+  return params;\n+}\n+\n+/* Parse the non-keyword Objective-C params.  */\n+\n+static tree\n+cp_parser_objc_method_tail_params_opt (cp_parser* parser, bool *ellipsisp, \n+\t\t\t\t       tree* attributes)\n+{\n+  tree params = make_node (TREE_LIST);\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  *ellipsisp = false;  /* Initially, assume no ellipsis.  */\n+\n+  while (token->type == CPP_COMMA)\n+    {\n+      cp_parameter_declarator *parmdecl;\n+      tree parm;\n+\n+      cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n+      token = cp_lexer_peek_token (parser->lexer);\n+\n+      if (token->type == CPP_ELLIPSIS)\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);  /* Eat '...'.  */\n+\t  *ellipsisp = true;\n+\t  token = cp_lexer_peek_token (parser->lexer);\n+\t  break;\n+\t}\n+\n+      /* TODO: parse attributes for tail parameters.  */\n+      parmdecl = cp_parser_parameter_declaration (parser, false, NULL);\n+      parm = grokdeclarator (parmdecl->declarator,\n+\t\t\t     &parmdecl->decl_specifiers,\n+\t\t\t     PARM, /*initialized=*/0,\n+\t\t\t     /*attrlist=*/NULL);\n+\n+      chainon (params, build_tree_list (NULL_TREE, parm));\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  /* We allow tail attributes for the method.  */\n+  if (token->keyword == RID_ATTRIBUTE)\n+    {\n+      if (*attributes == NULL_TREE)\n+\t{\n+\t  *attributes = cp_parser_attributes_opt (parser);\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON)\n+\t      || cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+\t    return params;\n+\t}\n+      else        \n+\t/* We have an error, but parse the attributes, so that we can \n+\t   carry on.  */\n+\t*attributes = cp_parser_attributes_opt (parser);\n+\n+      cp_parser_error (parser, \n+\t\t       \"method attributes must be specified at the end\");\n+      return error_mark_node;\n+    }\n+\n+  return params;\n+}\n+\n+/* Parse a linkage specification, a pragma, an extra semicolon or a block.  */\n+\n+static void\n+cp_parser_objc_interstitial_code (cp_parser* parser)\n+{\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  /* If the next token is `extern' and the following token is a string\n+     literal, then we have a linkage specification.  */\n+  if (token->keyword == RID_EXTERN\n+      && cp_parser_is_string_literal (cp_lexer_peek_nth_token (parser->lexer, 2)))\n+    cp_parser_linkage_specification (parser);\n+  /* Handle #pragma, if any.  */\n+  else if (token->type == CPP_PRAGMA)\n+    cp_parser_pragma (parser, pragma_external);\n+  /* Allow stray semicolons.  */\n+  else if (token->type == CPP_SEMICOLON)\n+    cp_lexer_consume_token (parser->lexer);\n+  /* Mark methods as optional or required, when building protocols.  */\n+  else if (token->keyword == RID_AT_OPTIONAL)\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      objc_set_method_opt (true);\n+    }\n+  else if (token->keyword == RID_AT_REQUIRED)\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      objc_set_method_opt (false);\n+    }\n+  else if (token->keyword == RID_NAMESPACE)\n+    cp_parser_namespace_definition (parser);\n+  /* Other stray characters must generate errors.  */\n+  else if (token->type == CPP_OPEN_BRACE || token->type == CPP_CLOSE_BRACE)\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      error (\"stray %qs between Objective-C++ methods\",\n+\t     token->type == CPP_OPEN_BRACE ? \"{\" : \"}\");\n+    }\n+  /* Finally, try to parse a block-declaration, or a function-definition.  */\n+  else\n+    cp_parser_block_declaration (parser, /*statement_p=*/false);\n+}\n+\n+/* Parse a method signature.  */\n+\n+static tree\n+cp_parser_objc_method_signature (cp_parser* parser, tree* attributes)\n+{\n+  tree rettype, kwdparms, optparms;\n+  bool ellipsis = false;\n+  bool is_class_method;\n+\n+  is_class_method = cp_parser_objc_method_type (parser);\n+  rettype = cp_parser_objc_typename (parser);\n+  *attributes = NULL_TREE;\n+  kwdparms = cp_parser_objc_method_keyword_params (parser, attributes);\n+  if (kwdparms == error_mark_node)\n+    return error_mark_node;\n+  optparms = cp_parser_objc_method_tail_params_opt (parser, &ellipsis, attributes);\n+  if (optparms == error_mark_node)\n+    return error_mark_node;\n+\n+  return objc_build_method_signature (is_class_method, rettype, kwdparms, optparms, ellipsis);\n+}\n+\n+static bool\n+cp_parser_objc_method_maybe_bad_prefix_attributes (cp_parser* parser)\n+{\n+  tree tattr;  \n+  cp_lexer_save_tokens (parser->lexer);\n+  tattr = cp_parser_attributes_opt (parser);\n+  gcc_assert (tattr) ;\n+  \n+  /* If the attributes are followed by a method introducer, this is not allowed.\n+     Dump the attributes and flag the situation.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_PLUS)\n+      || cp_lexer_next_token_is (parser->lexer, CPP_MINUS))\n+    return true;\n+\n+  /* Otherwise, the attributes introduce some interstitial code, possibly so\n+     rewind to allow that check.  */\n+  cp_lexer_rollback_tokens (parser->lexer);\n+  return false;  \n+}\n+\n+/* Parse an Objective-C method prototype list.  */\n+\n+static void\n+cp_parser_objc_method_prototype_list (cp_parser* parser)\n+{\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  while (token->keyword != RID_AT_END && token->type != CPP_EOF)\n+    {\n+      if (token->type == CPP_PLUS || token->type == CPP_MINUS)\n+\t{\n+\t  tree attributes, sig;\n+\t  bool is_class_method;\n+\t  if (token->type == CPP_PLUS)\n+\t    is_class_method = true;\n+\t  else\n+\t    is_class_method = false;\n+\t  sig = cp_parser_objc_method_signature (parser, &attributes);\n+\t  if (sig == error_mark_node)\n+\t    {\n+\t      cp_parser_skip_to_end_of_block_or_statement (parser);\n+\t      token = cp_lexer_peek_token (parser->lexer);\n+\t      continue;\n+\t    }\n+\t  objc_add_method_declaration (is_class_method, sig, attributes);\n+\t  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\t}\n+      else if (token->keyword == RID_AT_PROPERTY)\n+\tcp_parser_objc_at_property_declaration (parser);\n+      else if (token->keyword == RID_ATTRIBUTE \n+      \t       && cp_parser_objc_method_maybe_bad_prefix_attributes(parser))\n+\twarning_at (cp_lexer_peek_token (parser->lexer)->location, \n+\t\t    OPT_Wattributes, \n+\t\t    \"prefix attributes are ignored for methods\");\n+      else\n+\t/* Allow for interspersed non-ObjC++ code.  */\n+\tcp_parser_objc_interstitial_code (parser);\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  if (token->type != CPP_EOF)\n+    cp_lexer_consume_token (parser->lexer);  /* Eat '@end'.  */\n+  else\n+    cp_parser_error (parser, \"expected %<@end%>\");\n+\n+  objc_finish_interface ();\n+}\n+\n+/* Parse an Objective-C method definition list.  */\n+\n+static void\n+cp_parser_objc_method_definition_list (cp_parser* parser)\n+{\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  while (token->keyword != RID_AT_END && token->type != CPP_EOF)\n+    {\n+      tree meth;\n+\n+      if (token->type == CPP_PLUS || token->type == CPP_MINUS)\n+\t{\n+\t  cp_token *ptk;\n+\t  tree sig, attribute;\n+\t  bool is_class_method;\n+\t  if (token->type == CPP_PLUS)\n+\t    is_class_method = true;\n+\t  else\n+\t    is_class_method = false;\n+\t  push_deferring_access_checks (dk_deferred);\n+\t  sig = cp_parser_objc_method_signature (parser, &attribute);\n+\t  if (sig == error_mark_node)\n+\t    {\n+\t      cp_parser_skip_to_end_of_block_or_statement (parser);\n+\t      token = cp_lexer_peek_token (parser->lexer);\n+\t      continue;\n+\t    }\n+\t  objc_start_method_definition (is_class_method, sig, attribute);\n+\n+\t  /* For historical reasons, we accept an optional semicolon.  */\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n+\t    cp_lexer_consume_token (parser->lexer);\n+\n+\t  ptk = cp_lexer_peek_token (parser->lexer);\n+\t  if (!(ptk->type == CPP_PLUS || ptk->type == CPP_MINUS \n+\t\t|| ptk->type == CPP_EOF || ptk->keyword == RID_AT_END))\n+\t    {\n+\t      perform_deferred_access_checks ();\n+\t      stop_deferring_access_checks ();\n+\t      meth = cp_parser_function_definition_after_declarator (parser,\n+\t\t\t\t\t\t\t\t     false);\n+\t      pop_deferring_access_checks ();\n+\t      objc_finish_method_definition (meth);\n+\t    }\n+\t}\n+      /* The following case will be removed once @synthesize is\n+\t completely implemented.  */\n+      else if (token->keyword == RID_AT_PROPERTY)\n+\tcp_parser_objc_at_property_declaration (parser);\n+      else if (token->keyword == RID_AT_SYNTHESIZE)\n+\tcp_parser_objc_at_synthesize_declaration (parser);\n+      else if (token->keyword == RID_AT_DYNAMIC)\n+\tcp_parser_objc_at_dynamic_declaration (parser);\n+      else if (token->keyword == RID_ATTRIBUTE \n+      \t       && cp_parser_objc_method_maybe_bad_prefix_attributes(parser))\n+\twarning_at (token->location, OPT_Wattributes,\n+\t       \t    \"prefix attributes are ignored for methods\");\n+      else\n+\t/* Allow for interspersed non-ObjC++ code.  */\n+\tcp_parser_objc_interstitial_code (parser);\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  if (token->type != CPP_EOF)\n+    cp_lexer_consume_token (parser->lexer);  /* Eat '@end'.  */\n+  else\n+    cp_parser_error (parser, \"expected %<@end%>\");\n+\n+  objc_finish_implementation ();\n+}\n+\n+/* Parse Objective-C ivars.  */\n+\n+static void\n+cp_parser_objc_class_ivars (cp_parser* parser)\n+{\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  if (token->type != CPP_OPEN_BRACE)\n+    return;\t/* No ivars specified.  */\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '{'.  */\n+  token = cp_lexer_peek_token (parser->lexer);\n+\n+  while (token->type != CPP_CLOSE_BRACE \n+\t&& token->keyword != RID_AT_END && token->type != CPP_EOF)\n+    {\n+      cp_decl_specifier_seq declspecs;\n+      int decl_class_or_enum_p;\n+      tree prefix_attributes;\n+\n+      cp_parser_objc_visibility_spec (parser);\n+\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))\n+\tbreak;\n+\n+      cp_parser_decl_specifier_seq (parser,\n+\t\t\t\t    CP_PARSER_FLAGS_OPTIONAL,\n+\t\t\t\t    &declspecs,\n+\t\t\t\t    &decl_class_or_enum_p);\n+\n+      /* auto, register, static, extern, mutable.  */\n+      if (declspecs.storage_class != sc_none)\n+\t{\n+\t  cp_parser_error (parser, \"invalid type for instance variable\");\t  \n+\t  declspecs.storage_class = sc_none;\n+\t}\n+\n+      /* __thread.  */\n+      if (declspecs.specs[(int) ds_thread])\n+\t{\n+\t  cp_parser_error (parser, \"invalid type for instance variable\");\n+\t  declspecs.specs[(int) ds_thread] = 0;\n+\t}\n+      \n+      /* typedef.  */\n+      if (declspecs.specs[(int) ds_typedef])\n+\t{\n+\t  cp_parser_error (parser, \"invalid type for instance variable\");\n+\t  declspecs.specs[(int) ds_typedef] = 0;\n+\t}\n+\n+      prefix_attributes = declspecs.attributes;\n+      declspecs.attributes = NULL_TREE;\n+\n+      /* Keep going until we hit the `;' at the end of the\n+\t declaration.  */\n+      while (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n+\t{\n+\t  tree width = NULL_TREE, attributes, first_attribute, decl;\n+\t  cp_declarator *declarator = NULL;\n+\t  int ctor_dtor_or_conv_p;\n+\n+\t  /* Check for a (possibly unnamed) bitfield declaration.  */\n+\t  token = cp_lexer_peek_token (parser->lexer);\n+\t  if (token->type == CPP_COLON)\n+\t    goto eat_colon;\n+\n+\t  if (token->type == CPP_NAME\n+\t      && (cp_lexer_peek_nth_token (parser->lexer, 2)->type\n+\t\t  == CPP_COLON))\n+\t    {\n+\t      /* Get the name of the bitfield.  */\n+\t      declarator = make_id_declarator (NULL_TREE,\n+\t\t\t\t\t       cp_parser_identifier (parser),\n+\t\t\t\t\t       sfk_none);\n+\n+\t     eat_colon:\n+\t      cp_lexer_consume_token (parser->lexer);  /* Eat ':'.  */\n+\t      /* Get the width of the bitfield.  */\n+\t      width\n+\t\t= cp_parser_constant_expression (parser,\n+\t\t\t\t\t\t /*allow_non_constant=*/false,\n+\t\t\t\t\t\t NULL);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Parse the declarator.  */\n+\t      declarator\n+\t\t= cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n+\t\t\t\t\t&ctor_dtor_or_conv_p,\n+\t\t\t\t\t/*parenthesized_p=*/NULL,\n+\t\t\t\t\t/*member_p=*/false);\n+\t    }\n+\n+\t  /* Look for attributes that apply to the ivar.  */\n+\t  attributes = cp_parser_attributes_opt (parser);\n+\t  /* Remember which attributes are prefix attributes and\n+\t     which are not.  */\n+\t  first_attribute = attributes;\n+\t  /* Combine the attributes.  */\n+\t  attributes = chainon (prefix_attributes, attributes);\n+\n+\t  if (width)\n+\t      /* Create the bitfield declaration.  */\n+\t      decl = grokbitfield (declarator, &declspecs,\n+\t\t\t\t   width,\n+\t\t\t\t   attributes);\n+\t  else\n+\t    decl = grokfield (declarator, &declspecs,\n+\t\t\t      NULL_TREE, /*init_const_expr_p=*/false,\n+\t\t\t      NULL_TREE, attributes);\n+\n+\t  /* Add the instance variable.  */\n+\t  objc_add_instance_variable (decl);\n+\n+\t  /* Reset PREFIX_ATTRIBUTES.  */\n+\t  while (attributes && TREE_CHAIN (attributes) != first_attribute)\n+\t    attributes = TREE_CHAIN (attributes);\n+\t  if (attributes)\n+\t    TREE_CHAIN (attributes) = NULL_TREE;\n+\n+\t  token = cp_lexer_peek_token (parser->lexer);\n+\n+\t  if (token->type == CPP_COMMA)\n+\t    {\n+\t      cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n+\t      continue;\n+\t    }\n+\t  break;\n+\t}\n+\n+      cp_parser_consume_semicolon_at_end_of_statement (parser);\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  if (token->keyword == RID_AT_END)\n+    cp_parser_error (parser, \"expected %<}%>\");\n+\n+  /* Do not consume the RID_AT_END, so it will be read again as terminating\n+     the @interface of @implementation.  */ \n+  if (token->keyword != RID_AT_END && token->type != CPP_EOF)\n+    cp_lexer_consume_token (parser->lexer);  /* Eat '}'.  */\n+    \n+  /* For historical reasons, we accept an optional semicolon.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n+    cp_lexer_consume_token (parser->lexer);\n+}\n+\n+/* Parse an Objective-C protocol declaration.  */\n+\n+static void\n+cp_parser_objc_protocol_declaration (cp_parser* parser, tree attributes)\n+{\n+  tree proto, protorefs;\n+  cp_token *tok;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@protocol'.  */\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n+    {\n+      tok = cp_lexer_peek_token (parser->lexer);\n+      error_at (tok->location, \"identifier expected after %<@protocol%>\");\n+      goto finish;\n+    }\n+\n+  /* See if we have a forward declaration or a definition.  */\n+  tok = cp_lexer_peek_nth_token (parser->lexer, 2);\n+\n+  /* Try a forward declaration first.  */\n+  if (tok->type == CPP_COMMA || tok->type == CPP_SEMICOLON)\n+    {\n+      objc_declare_protocols (cp_parser_objc_identifier_list (parser), \n+\t\t\t      attributes);\n+     finish:\n+      cp_parser_consume_semicolon_at_end_of_statement (parser);\n+    }\n+\n+  /* Ok, we got a full-fledged definition (or at least should).  */\n+  else\n+    {\n+      proto = cp_parser_identifier (parser);\n+      protorefs = cp_parser_objc_protocol_refs_opt (parser);\n+      objc_start_protocol (proto, protorefs, attributes);\n+      cp_parser_objc_method_prototype_list (parser);\n+    }\n+}\n+\n+/* Parse an Objective-C superclass or category.  */\n+\n+static void\n+cp_parser_objc_superclass_or_category (cp_parser *parser, \n+\t\t\t\t       bool iface_p,\n+\t\t\t\t       tree *super,\n+\t\t\t\t       tree *categ, bool *is_class_extension)\n+{\n+  cp_token *next = cp_lexer_peek_token (parser->lexer);\n+\n+  *super = *categ = NULL_TREE;\n+  *is_class_extension = false;\n+  if (next->type == CPP_COLON)\n+    {\n+      cp_lexer_consume_token (parser->lexer);  /* Eat ':'.  */\n+      *super = cp_parser_identifier (parser);\n+    }\n+  else if (next->type == CPP_OPEN_PAREN)\n+    {\n+      cp_lexer_consume_token (parser->lexer);  /* Eat '('.  */\n+\n+      /* If there is no category name, and this is an @interface, we\n+\t have a class extension.  */\n+      if (iface_p && cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n+\t{\n+\t  *categ = NULL_TREE;\n+\t  *is_class_extension = true;\n+\t}\n+      else\n+\t*categ = cp_parser_identifier (parser);\n+\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+    }\n+}\n+\n+/* Parse an Objective-C class interface.  */\n+\n+static void\n+cp_parser_objc_class_interface (cp_parser* parser, tree attributes)\n+{\n+  tree name, super, categ, protos;\n+  bool is_class_extension;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@interface'.  */\n+  name = cp_parser_identifier (parser);\n+  if (name == error_mark_node)\n+    {\n+      /* It's hard to recover because even if valid @interface stuff\n+\t is to follow, we can't compile it (or validate it) if we\n+\t don't even know which class it refers to.  Let's assume this\n+\t was a stray '@interface' token in the stream and skip it.\n+      */\n+      return;\n+    }\n+  cp_parser_objc_superclass_or_category (parser, true, &super, &categ,\n+\t\t\t\t\t &is_class_extension);\n+  protos = cp_parser_objc_protocol_refs_opt (parser);\n+\n+  /* We have either a class or a category on our hands.  */\n+  if (categ || is_class_extension)\n+    objc_start_category_interface (name, categ, protos, attributes);\n+  else\n+    {\n+      objc_start_class_interface (name, super, protos, attributes);\n+      /* Handle instance variable declarations, if any.  */\n+      cp_parser_objc_class_ivars (parser);\n+      objc_continue_interface ();\n+    }\n+\n+  cp_parser_objc_method_prototype_list (parser);\n+}\n+\n+/* Parse an Objective-C class implementation.  */\n+\n+static void\n+cp_parser_objc_class_implementation (cp_parser* parser)\n+{\n+  tree name, super, categ;\n+  bool is_class_extension;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@implementation'.  */\n+  name = cp_parser_identifier (parser);\n+  if (name == error_mark_node)\n+    {\n+      /* It's hard to recover because even if valid @implementation\n+\t stuff is to follow, we can't compile it (or validate it) if\n+\t we don't even know which class it refers to.  Let's assume\n+\t this was a stray '@implementation' token in the stream and\n+\t skip it.\n+      */\n+      return;\n+    }\n+  cp_parser_objc_superclass_or_category (parser, false, &super, &categ,\n+\t\t\t\t\t &is_class_extension);\n+\n+  /* We have either a class or a category on our hands.  */\n+  if (categ)\n+    objc_start_category_implementation (name, categ);\n+  else\n+    {\n+      objc_start_class_implementation (name, super);\n+      /* Handle instance variable declarations, if any.  */\n+      cp_parser_objc_class_ivars (parser);\n+      objc_continue_implementation ();\n+    }\n+\n+  cp_parser_objc_method_definition_list (parser);\n+}\n+\n+/* Consume the @end token and finish off the implementation.  */\n+\n+static void\n+cp_parser_objc_end_implementation (cp_parser* parser)\n+{\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@end'.  */\n+  objc_finish_implementation ();\n+}\n+\n+/* Parse an Objective-C declaration.  */\n+\n+static void\n+cp_parser_objc_declaration (cp_parser* parser, tree attributes)\n+{\n+  /* Try to figure out what kind of declaration is present.  */\n+  cp_token *kwd = cp_lexer_peek_token (parser->lexer);\n+\n+  if (attributes)\n+    switch (kwd->keyword)\n+      {\n+\tcase RID_AT_ALIAS:\n+\tcase RID_AT_CLASS:\n+\tcase RID_AT_END:\n+\t  error_at (kwd->location, \"attributes may not be specified before\"\n+\t            \" the %<@%D%> Objective-C++ keyword\",\n+\t\t    kwd->u.value);\n+\t  attributes = NULL;\n+\t  break;\n+\tcase RID_AT_IMPLEMENTATION:\n+\t  warning_at (kwd->location, OPT_Wattributes,\n+\t\t      \"prefix attributes are ignored before %<@%D%>\",\n+\t\t      kwd->u.value);\n+\t  attributes = NULL;\n+\tdefault:\n+\t  break;\n+      }\n+\n+  switch (kwd->keyword)\n+    {\n+    case RID_AT_ALIAS:\n+      cp_parser_objc_alias_declaration (parser);\n+      break;\n+    case RID_AT_CLASS:\n+      cp_parser_objc_class_declaration (parser);\n+      break;\n+    case RID_AT_PROTOCOL:\n+      cp_parser_objc_protocol_declaration (parser, attributes);\n+      break;\n+    case RID_AT_INTERFACE:\n+      cp_parser_objc_class_interface (parser, attributes);\n+      break;\n+    case RID_AT_IMPLEMENTATION:\n+      cp_parser_objc_class_implementation (parser);\n+      break;\n+    case RID_AT_END:\n+      cp_parser_objc_end_implementation (parser);\n+      break;\n+    default:\n+      error_at (kwd->location, \"misplaced %<@%D%> Objective-C++ construct\",\n+\t\tkwd->u.value);\n+      cp_parser_skip_to_end_of_block_or_statement (parser);\n+    }\n+}\n+\n+/* Parse an Objective-C try-catch-finally statement.\n+\n+   objc-try-catch-finally-stmt:\n+     @try compound-statement objc-catch-clause-seq [opt]\n+       objc-finally-clause [opt]\n+\n+   objc-catch-clause-seq:\n+     objc-catch-clause objc-catch-clause-seq [opt]\n+\n+   objc-catch-clause:\n+     @catch ( objc-exception-declaration ) compound-statement\n+\n+   objc-finally-clause:\n+     @finally compound-statement\n+\n+   objc-exception-declaration:\n+     parameter-declaration\n+     '...'\n+\n+   where '...' is to be interpreted literally, that is, it means CPP_ELLIPSIS.\n+\n+   Returns NULL_TREE.\n+\n+   PS: This function is identical to c_parser_objc_try_catch_finally_statement\n+   for C.  Keep them in sync.  */   \n+\n+static tree\n+cp_parser_objc_try_catch_finally_statement (cp_parser *parser)\n+{\n+  location_t location;\n+  tree stmt;\n+\n+  cp_parser_require_keyword (parser, RID_AT_TRY, RT_AT_TRY);\n+  location = cp_lexer_peek_token (parser->lexer)->location;\n+  objc_maybe_warn_exceptions (location);\n+  /* NB: The @try block needs to be wrapped in its own STATEMENT_LIST\n+     node, lest it get absorbed into the surrounding block.  */\n+  stmt = push_stmt_list ();\n+  cp_parser_compound_statement (parser, NULL, false);\n+  objc_begin_try_stmt (location, pop_stmt_list (stmt));\n+\n+  while (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_CATCH))\n+    {\n+      cp_parameter_declarator *parm;\n+      tree parameter_declaration = error_mark_node;\n+      bool seen_open_paren = false;\n+\n+      cp_lexer_consume_token (parser->lexer);\n+      if (cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+\tseen_open_paren = true;\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+\t{\n+\t  /* We have \"@catch (...)\" (where the '...' are literally\n+\t     what is in the code).  Skip the '...'.\n+\t     parameter_declaration is set to NULL_TREE, and\n+\t     objc_being_catch_clauses() knows that that means\n+\t     '...'.  */\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  parameter_declaration = NULL_TREE;\n+\t}\n+      else\n+\t{\n+\t  /* We have \"@catch (NSException *exception)\" or something\n+\t     like that.  Parse the parameter declaration.  */\n+\t  parm = cp_parser_parameter_declaration (parser, false, NULL);\n+\t  if (parm == NULL)\n+\t    parameter_declaration = error_mark_node;\n+\t  else\n+\t    parameter_declaration = grokdeclarator (parm->declarator,\n+\t\t\t\t\t\t    &parm->decl_specifiers,\n+\t\t\t\t\t\t    PARM, /*initialized=*/0,\n+\t\t\t\t\t\t    /*attrlist=*/NULL);\n+\t}\n+      if (seen_open_paren)\n+\tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+      else\n+\t{\n+\t  /* If there was no open parenthesis, we are recovering from\n+\t     an error, and we are trying to figure out what mistake\n+\t     the user has made.  */\n+\n+\t  /* If there is an immediate closing parenthesis, the user\n+\t     probably forgot the opening one (ie, they typed \"@catch\n+\t     NSException *e)\".  Parse the closing parenthesis and keep\n+\t     going.  */\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n+\t    cp_lexer_consume_token (parser->lexer);\n+\t  \n+\t  /* If these is no immediate closing parenthesis, the user\n+\t     probably doesn't know that parenthesis are required at\n+\t     all (ie, they typed \"@catch NSException *e\").  So, just\n+\t     forget about the closing parenthesis and keep going.  */\n+\t}\n+      objc_begin_catch_clause (parameter_declaration);\n+      cp_parser_compound_statement (parser, NULL, false);\n+      objc_finish_catch_clause ();\n+    }\n+  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_FINALLY))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      location = cp_lexer_peek_token (parser->lexer)->location;\n+      /* NB: The @finally block needs to be wrapped in its own STATEMENT_LIST\n+\t node, lest it get absorbed into the surrounding block.  */\n+      stmt = push_stmt_list ();\n+      cp_parser_compound_statement (parser, NULL, false);\n+      objc_build_finally_clause (location, pop_stmt_list (stmt));\n+    }\n+\n+  return objc_finish_try_stmt ();\n+}\n+\n+/* Parse an Objective-C synchronized statement.\n+\n+   objc-synchronized-stmt:\n+     @synchronized ( expression ) compound-statement\n+\n+   Returns NULL_TREE.  */\n+\n+static tree\n+cp_parser_objc_synchronized_statement (cp_parser *parser)\n+{\n+  location_t location;\n+  tree lock, stmt;\n+\n+  cp_parser_require_keyword (parser, RID_AT_SYNCHRONIZED, RT_AT_SYNCHRONIZED);\n+\n+  location = cp_lexer_peek_token (parser->lexer)->location;\n+  objc_maybe_warn_exceptions (location);\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  lock = cp_parser_expression (parser, false, NULL);\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\n+  /* NB: The @synchronized block needs to be wrapped in its own STATEMENT_LIST\n+     node, lest it get absorbed into the surrounding block.  */\n+  stmt = push_stmt_list ();\n+  cp_parser_compound_statement (parser, NULL, false);\n+\n+  return objc_build_synchronized (location, lock, pop_stmt_list (stmt));\n+}\n+\n+/* Parse an Objective-C throw statement.\n+\n+   objc-throw-stmt:\n+     @throw assignment-expression [opt] ;\n+\n+   Returns a constructed '@throw' statement.  */\n+\n+static tree\n+cp_parser_objc_throw_statement (cp_parser *parser)\n+{\n+  tree expr = NULL_TREE;\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  cp_parser_require_keyword (parser, RID_AT_THROW, RT_AT_THROW);\n+\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n+    expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\n+  return objc_build_throw_stmt (loc, expr);\n+}\n+\n+/* Parse an Objective-C statement.  */\n+\n+static tree\n+cp_parser_objc_statement (cp_parser * parser)\n+{\n+  /* Try to figure out what kind of declaration is present.  */\n+  cp_token *kwd = cp_lexer_peek_token (parser->lexer);\n+\n+  switch (kwd->keyword)\n+    {\n+    case RID_AT_TRY:\n+      return cp_parser_objc_try_catch_finally_statement (parser);\n+    case RID_AT_SYNCHRONIZED:\n+      return cp_parser_objc_synchronized_statement (parser);\n+    case RID_AT_THROW:\n+      return cp_parser_objc_throw_statement (parser);\n+    default:\n+      error_at (kwd->location, \"misplaced %<@%D%> Objective-C++ construct\",\n+\t       kwd->u.value);\n+      cp_parser_skip_to_end_of_block_or_statement (parser);\n+    }\n+\n+  return error_mark_node;\n+}\n+\n+/* If we are compiling ObjC++ and we see an __attribute__ we neeed to \n+   look ahead to see if an objc keyword follows the attributes.  This\n+   is to detect the use of prefix attributes on ObjC @interface and \n+   @protocol.  */\n+\n+static bool\n+cp_parser_objc_valid_prefix_attributes (cp_parser* parser, tree *attrib)\n+{\n+  cp_lexer_save_tokens (parser->lexer);\n+  *attrib = cp_parser_attributes_opt (parser);\n+  gcc_assert (*attrib);\n+  if (OBJC_IS_AT_KEYWORD (cp_lexer_peek_token (parser->lexer)->keyword))\n+    {\n+      cp_lexer_commit_tokens (parser->lexer);\n+      return true;\n+    }\n+  cp_lexer_rollback_tokens (parser->lexer);\n+  return false;  \n+}\n+\n+/* This routine is a minimal replacement for\n+   c_parser_struct_declaration () used when parsing the list of\n+   types/names or ObjC++ properties.  For example, when parsing the\n+   code\n+\n+   @property (readonly) int a, b, c;\n+\n+   this function is responsible for parsing \"int a, int b, int c\" and\n+   returning the declarations as CHAIN of DECLs.\n+\n+   TODO: Share this code with cp_parser_objc_class_ivars.  It's very\n+   similar parsing.  */\n+static tree\n+cp_parser_objc_struct_declaration (cp_parser *parser)\n+{\n+  tree decls = NULL_TREE;\n+  cp_decl_specifier_seq declspecs;\n+  int decl_class_or_enum_p;\n+  tree prefix_attributes;\n+\n+  cp_parser_decl_specifier_seq (parser,\n+\t\t\t\tCP_PARSER_FLAGS_NONE,\n+\t\t\t\t&declspecs,\n+\t\t\t\t&decl_class_or_enum_p);\n+\n+  if (declspecs.type == error_mark_node)\n+    return error_mark_node;\n+\n+  /* auto, register, static, extern, mutable.  */\n+  if (declspecs.storage_class != sc_none)\n+    {\n+      cp_parser_error (parser, \"invalid type for property\");\n+      declspecs.storage_class = sc_none;\n+    }\n+  \n+  /* __thread.  */\n+  if (declspecs.specs[(int) ds_thread])\n+    {\n+      cp_parser_error (parser, \"invalid type for property\");\n+      declspecs.specs[(int) ds_thread] = 0;\n+    }\n+  \n+  /* typedef.  */\n+  if (declspecs.specs[(int) ds_typedef])\n+    {\n+      cp_parser_error (parser, \"invalid type for property\");\n+      declspecs.specs[(int) ds_typedef] = 0;\n+    }\n+\n+  prefix_attributes = declspecs.attributes;\n+  declspecs.attributes = NULL_TREE;\n+\n+  /* Keep going until we hit the `;' at the end of the declaration. */\n+  while (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n+    {\n+      tree attributes, first_attribute, decl;\n+      cp_declarator *declarator;\n+      cp_token *token;\n+\n+      /* Parse the declarator.  */\n+      declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n+\t\t\t\t\t NULL, NULL, false);\n+\n+      /* Look for attributes that apply to the ivar.  */\n+      attributes = cp_parser_attributes_opt (parser);\n+      /* Remember which attributes are prefix attributes and\n+\t which are not.  */\n+      first_attribute = attributes;\n+      /* Combine the attributes.  */\n+      attributes = chainon (prefix_attributes, attributes);\n+      \n+      decl = grokfield (declarator, &declspecs,\n+\t\t\tNULL_TREE, /*init_const_expr_p=*/false,\n+\t\t\tNULL_TREE, attributes);\n+\n+      if (decl == error_mark_node || decl == NULL_TREE)\n+\treturn error_mark_node;\n+      \n+      /* Reset PREFIX_ATTRIBUTES.  */\n+      while (attributes && TREE_CHAIN (attributes) != first_attribute)\n+\tattributes = TREE_CHAIN (attributes);\n+      if (attributes)\n+\tTREE_CHAIN (attributes) = NULL_TREE;\n+\n+      DECL_CHAIN (decl) = decls;\n+      decls = decl;\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+      if (token->type == CPP_COMMA)\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n+\t  continue;\n+\t}\n+      else\n+\tbreak;\n+    }\n+  return decls;\n+}\n+\n+/* Parse an Objective-C @property declaration.  The syntax is:\n+\n+   objc-property-declaration:\n+     '@property' objc-property-attributes[opt] struct-declaration ;\n+\n+   objc-property-attributes:\n+    '(' objc-property-attribute-list ')'\n+\n+   objc-property-attribute-list:\n+     objc-property-attribute\n+     objc-property-attribute-list, objc-property-attribute\n+\n+   objc-property-attribute\n+     'getter' = identifier\n+     'setter' = identifier\n+     'readonly'\n+     'readwrite'\n+     'assign'\n+     'retain'\n+     'copy'\n+     'nonatomic'\n+\n+  For example:\n+    @property NSString *name;\n+    @property (readonly) id object;\n+    @property (retain, nonatomic, getter=getTheName) id name;\n+    @property int a, b, c;\n+\n+   PS: This function is identical to\n+   c_parser_objc_at_property_declaration for C.  Keep them in sync.  */\n+static void \n+cp_parser_objc_at_property_declaration (cp_parser *parser)\n+{\n+  /* The following variables hold the attributes of the properties as\n+     parsed.  They are 'false' or 'NULL_TREE' if the attribute was not\n+     seen.  When we see an attribute, we set them to 'true' (if they\n+     are boolean properties) or to the identifier (if they have an\n+     argument, ie, for getter and setter).  Note that here we only\n+     parse the list of attributes, check the syntax and accumulate the\n+     attributes that we find.  objc_add_property_declaration() will\n+     then process the information.  */\n+  bool property_assign = false;\n+  bool property_copy = false;\n+  tree property_getter_ident = NULL_TREE;\n+  bool property_nonatomic = false;\n+  bool property_readonly = false;\n+  bool property_readwrite = false;\n+  bool property_retain = false;\n+  tree property_setter_ident = NULL_TREE;\n+\n+  /* 'properties' is the list of properties that we read.  Usually a\n+     single one, but maybe more (eg, in \"@property int a, b, c;\" there\n+     are three).  */\n+  tree properties;\n+  location_t loc;\n+\n+  loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@property'.  */\n+\n+  /* Parse the optional attribute list...  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+    {\n+      /* Eat the '('.  */\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      while (true)\n+\t{\n+\t  bool syntax_error = false;\n+\t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+      \t  enum rid keyword;\n+\n+\t  if (token->type != CPP_NAME)\n+\t    {\n+\t      cp_parser_error (parser, \"expected identifier\");\n+\t      break;\n+\t    }\n+\t  keyword = C_RID_CODE (token->u.value);\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  switch (keyword)\n+\t    {\n+\t    case RID_ASSIGN:    property_assign = true;    break;\n+\t    case RID_COPY:      property_copy = true;      break;\n+\t    case RID_NONATOMIC: property_nonatomic = true; break;\n+\t    case RID_READONLY:  property_readonly = true;  break;\n+\t    case RID_READWRITE: property_readwrite = true; break;\n+\t    case RID_RETAIN:    property_retain = true;    break;\n+\n+\t    case RID_GETTER:\n+\t    case RID_SETTER:\n+\t      if (cp_lexer_next_token_is_not (parser->lexer, CPP_EQ))\n+\t\t{\n+\t\t  if (keyword == RID_GETTER)\n+\t\t    cp_parser_error (parser,\n+\t\t\t\t     \"missing %<=%> (after %<getter%> attribute)\");\n+\t\t  else\n+\t\t    cp_parser_error (parser,\n+\t\t\t\t     \"missing %<=%> (after %<setter%> attribute)\");\n+\t\t  syntax_error = true;\n+\t\t  break;\n+\t\t}\n+\t      cp_lexer_consume_token (parser->lexer); /* eat the = */\n+\t      if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n+\t\t{\n+\t\t  cp_parser_error (parser, \"expected identifier\");\n+\t\t  syntax_error = true;\n+\t\t  break;\n+\t\t}\n+\t      if (keyword == RID_SETTER)\n+\t\t{\n+\t\t  if (property_setter_ident != NULL_TREE)\n+\t\t    cp_parser_error (parser, \"the %<setter%> attribute may only be specified once\");\n+\t\t  else\n+\t\t    property_setter_ident = cp_lexer_peek_token (parser->lexer)->u.value;\n+\t\t  cp_lexer_consume_token (parser->lexer);\n+\t\t  if (cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n+\t\t    cp_parser_error (parser, \"setter name must terminate with %<:%>\");\n+\t\t  else\n+\t\t    cp_lexer_consume_token (parser->lexer);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (property_getter_ident != NULL_TREE)\n+\t\t    cp_parser_error (parser, \"the %<getter%> attribute may only be specified once\");\n+\t\t  else\n+\t\t    property_getter_ident = cp_lexer_peek_token (parser->lexer)->u.value;\n+\t\t  cp_lexer_consume_token (parser->lexer);\n+\t\t}\n+\t      break;\n+\t    default:\n+\t      cp_parser_error (parser, \"unknown property attribute\");\n+\t      syntax_error = true;\n+\t      break;\n+\t    }\n+\n+\t  if (syntax_error)\n+\t    break;\n+\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\t    cp_lexer_consume_token (parser->lexer);\n+\t  else\n+\t    break;\n+\t}\n+\n+      /* FIXME: \"@property (setter, assign);\" will generate a spurious\n+\t \"error: expected \u2018)\u2019 before \u2018,\u2019 token\".  This is because\n+\t cp_parser_require, unlike the C counterpart, will produce an\n+\t error even if we are in error recovery.  */\n+      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+\t{\n+\t  cp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t /*recovering=*/true,\n+\t\t\t\t\t\t /*or_comma=*/false,\n+\t\t\t\t\t\t /*consume_paren=*/true);\n+\t}\n+    }\n+\n+  /* ... and the property declaration(s).  */\n+  properties = cp_parser_objc_struct_declaration (parser);\n+\n+  if (properties == error_mark_node)\n+    {\n+      cp_parser_skip_to_end_of_statement (parser);\n+      /* If the next token is now a `;', consume it.  */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n+\tcp_lexer_consume_token (parser->lexer);\n+      return;\n+    }\n+\n+  if (properties == NULL_TREE)\n+    cp_parser_error (parser, \"expected identifier\");\n+  else\n+    {\n+      /* Comma-separated properties are chained together in\n+\t reverse order; add them one by one.  */\n+      properties = nreverse (properties);\n+      \n+      for (; properties; properties = TREE_CHAIN (properties))\n+\tobjc_add_property_declaration (loc, copy_node (properties),\n+\t\t\t\t       property_readonly, property_readwrite,\n+\t\t\t\t       property_assign, property_retain,\n+\t\t\t\t       property_copy, property_nonatomic,\n+\t\t\t\t       property_getter_ident, property_setter_ident);\n+    }\n+  \n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+}\n+\n+/* Parse an Objective-C++ @synthesize declaration.  The syntax is:\n+\n+   objc-synthesize-declaration:\n+     @synthesize objc-synthesize-identifier-list ;\n+\n+   objc-synthesize-identifier-list:\n+     objc-synthesize-identifier\n+     objc-synthesize-identifier-list, objc-synthesize-identifier\n+\n+   objc-synthesize-identifier\n+     identifier\n+     identifier = identifier\n+\n+  For example:\n+    @synthesize MyProperty;\n+    @synthesize OneProperty, AnotherProperty=MyIvar, YetAnotherProperty;\n+\n+  PS: This function is identical to c_parser_objc_at_synthesize_declaration\n+  for C.  Keep them in sync.\n+*/\n+static void \n+cp_parser_objc_at_synthesize_declaration (cp_parser *parser)\n+{\n+  tree list = NULL_TREE;\n+  location_t loc;\n+  loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@synthesize'.  */\n+  while (true)\n+    {\n+      tree property, ivar;\n+      property = cp_parser_identifier (parser);\n+      if (property == error_mark_node)\n+\t{\n+\t  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\t  return;\n+\t}\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_EQ))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  ivar = cp_parser_identifier (parser);\n+\t  if (ivar == error_mark_node)\n+\t    {\n+\t      cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\t      return;\n+\t    }\n+\t}\n+      else\n+\tivar = NULL_TREE;\n+      list = chainon (list, build_tree_list (ivar, property));\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\tcp_lexer_consume_token (parser->lexer);\n+      else\n+\tbreak;\n+    }\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+  objc_add_synthesize_declaration (loc, list);\n+}\n+\n+/* Parse an Objective-C++ @dynamic declaration.  The syntax is:\n+\n+   objc-dynamic-declaration:\n+     @dynamic identifier-list ;\n+\n+   For example:\n+     @dynamic MyProperty;\n+     @dynamic MyProperty, AnotherProperty;\n+\n+  PS: This function is identical to c_parser_objc_at_dynamic_declaration\n+  for C.  Keep them in sync.\n+*/\n+static void \n+cp_parser_objc_at_dynamic_declaration (cp_parser *parser)\n+{\n+  tree list = NULL_TREE;\n+  location_t loc;\n+  loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@dynamic'.  */\n+  while (true)\n+    {\n+      tree property;\n+      property = cp_parser_identifier (parser);\n+      if (property == error_mark_node)\n+\t{\n+\t  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\t  return;\n+\t}\n+      list = chainon (list, build_tree_list (NULL, property));\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\tcp_lexer_consume_token (parser->lexer);\n+      else\n+\tbreak;\n+    }\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+  objc_add_dynamic_declaration (loc, list);\n+}\n \n \f\n /* OpenMP 2.5 parsing routines.  */"}, {"sha": "83999f7f310bd6d7aa7e39e9c3cfb3201576b3d4", "filename": "gcc/objcp/ChangeLog", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/gcc%2Fobjcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/gcc%2Fobjcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FChangeLog?ref=dd2e44f0f27961dd558b55d417dd5e780a9fc1b1", "patch": "@@ -1,14 +1,3 @@\n-2011-02-13  Mike Stump  <mikestump@comcast.net>\n-\n-\t* plugin/parser.h: Add arguments to all plugins.\n-\t* plugin/lex.h: Plugify.\n-\n-2011-02-12  Mike Stump  <mikestump@comcast.net>\n-\n-\t* Make-lang.in (obj-c++.tags): Plugify Objective-C++.\n-\t* plugin/parser.h: Likewise.\n-\t* plugin/parser.c: Likewise.\n-\n 2011-02-07  Mike Stump  <mikestump@comcast.net>\n \n \t* Make-lang.in (obj-c++.tags): Don't include *.y."}, {"sha": "2122d2df7e6f11f58acd61494294ccd4fb262687", "filename": "gcc/objcp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/gcc%2Fobjcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd2e44f0f27961dd558b55d417dd5e780a9fc1b1/gcc%2Fobjcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FMake-lang.in?ref=dd2e44f0f27961dd558b55d417dd5e780a9fc1b1", "patch": "@@ -110,7 +110,7 @@ obj-c++.man:\n obj-c++.install-plugin:\n \n obj-c++.tags: force\n-\tcd $(srcdir)/objcp; etags -o TAGS.sub *.c *.h plugin/*.h plugin/*.c; \\\n+\tcd $(srcdir)/objcp; etags -o TAGS.sub *.c *.h; \\\n \tetags --include TAGS.sub --include ../TAGS.sub\n \n lang_checks += check-obj-c++"}, {"sha": "a13024a5b2d641aaec6f470eab4f1efb4406eaf4", "filename": "gcc/objcp/plugin/lex.h", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/975b975b29fa2aa9dd562a55006a4cd93421a652/gcc%2Fobjcp%2Fplugin%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/975b975b29fa2aa9dd562a55006a4cd93421a652/gcc%2Fobjcp%2Fplugin%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fplugin%2Flex.h?ref=975b975b29fa2aa9dd562a55006a4cd93421a652", "patch": "@@ -1,32 +0,0 @@\n-/* Objective-C++ Parser plugin\n-   Copyright (C) 2011  Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#ifndef HIDE_OBJC\n-\n-#include \"c-family/c-objc.h\"\n-\n-#define PLUGIN_UNQUALIFIED_NAME_LOOKUP_ERROR(name) @(\n-  objc_diagnose_private_ivar (name)@)\n-\n-#else\n-\n-#define PLUGIN_UNQUALIFIED_NAME_LOOKUP_ERROR(name) 0\n-\n-#endif"}, {"sha": "a2481f1859c04c734b23af8986d78161f874c64e", "filename": "gcc/objcp/plugin/parser.c", "status": "removed", "additions": 0, "deletions": 1902, "changes": 1902, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/975b975b29fa2aa9dd562a55006a4cd93421a652/gcc%2Fobjcp%2Fplugin%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/975b975b29fa2aa9dd562a55006a4cd93421a652/gcc%2Fobjcp%2Fplugin%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fplugin%2Fparser.c?ref=975b975b29fa2aa9dd562a55006a4cd93421a652", "patch": "@@ -1,1902 +0,0 @@\n-/* Objective-C++ Parser plugin\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004,\n-   2005, 2007, 2008, 2009, 2010, 2011  Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#ifndef HIDE_OBJC\n-\n-/* Objective-C++ Productions */\n-\n-\n-/* Parse an Objective-C expression, which feeds into a primary-expression\n-   above.\n-\n-   objc-expression:\n-     objc-message-expression\n-     objc-string-literal\n-     objc-encode-expression\n-     objc-protocol-expression\n-     objc-selector-expression\n-\n-  Returns a tree representation of the expression.  */\n-\n-static tree\n-cp_parser_objc_expression (cp_parser* parser)\n-{\n-  /* Try to figure out what kind of declaration is present.  */\n-  cp_token *kwd = cp_lexer_peek_token (parser->lexer);\n-\n-  switch (kwd->type)\n-    {\n-    case CPP_OPEN_SQUARE:\n-      return cp_parser_objc_message_expression (parser);\n-\n-    case CPP_OBJC_STRING:\n-      kwd = cp_lexer_consume_token (parser->lexer);\n-      return objc_build_string_object (kwd->u.value);\n-\n-    case CPP_KEYWORD:\n-      switch (kwd->keyword)\n-\t{\n-\tcase RID_AT_ENCODE:\n-\t  return cp_parser_objc_encode_expression (parser);\n-\n-\tcase RID_AT_PROTOCOL:\n-\t  return cp_parser_objc_protocol_expression (parser);\n-\n-\tcase RID_AT_SELECTOR:\n-\t  return cp_parser_objc_selector_expression (parser);\n-\n-\tdefault:\n-\t  break;\n-\t}\n-    default:\n-      error_at (kwd->location,\n-\t\t\"misplaced %<@%D%> Objective-C++ construct\",\n-\t\tkwd->u.value);\n-      cp_parser_skip_to_end_of_block_or_statement (parser);\n-    }\n-\n-  return error_mark_node;\n-}\n-\n-/* Parse an Objective-C message expression.\n-\n-   objc-message-expression:\n-     [ objc-message-receiver objc-message-args ]\n-\n-   Returns a representation of an Objective-C message.  */\n-\n-static tree\n-cp_parser_objc_message_expression (cp_parser* parser)\n-{\n-  tree receiver, messageargs;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '['.  */\n-  receiver = cp_parser_objc_message_receiver (parser);\n-  messageargs = cp_parser_objc_message_args (parser);\n-  cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n-\n-  return objc_build_message_expr (build_tree_list (receiver, messageargs));\n-}\n-\n-/* Parse an objc-message-receiver.\n-\n-   objc-message-receiver:\n-     expression\n-     simple-type-specifier\n-\n-  Returns a representation of the type or expression.  */\n-\n-static tree\n-cp_parser_objc_message_receiver (cp_parser* parser)\n-{\n-  tree rcv;\n-\n-  /* An Objective-C message receiver may be either (1) a type\n-     or (2) an expression.  */\n-  cp_parser_parse_tentatively (parser);\n-  rcv = cp_parser_expression (parser, false, NULL);\n-\n-  if (cp_parser_parse_definitely (parser))\n-    return rcv;\n-\n-  rcv = cp_parser_simple_type_specifier (parser,\n-\t\t\t\t\t /*decl_specs=*/NULL,\n-\t\t\t\t\t CP_PARSER_FLAGS_NONE);\n-\n-  return objc_get_class_reference (rcv);\n-}\n-\n-/* Parse the arguments and selectors comprising an Objective-C message.\n-\n-   objc-message-args:\n-     objc-selector\n-     objc-selector-args\n-     objc-selector-args , objc-comma-args\n-\n-   objc-selector-args:\n-     objc-selector [opt] : assignment-expression\n-     objc-selector-args objc-selector [opt] : assignment-expression\n-\n-   objc-comma-args:\n-     assignment-expression\n-     objc-comma-args , assignment-expression\n-\n-   Returns a TREE_LIST, with TREE_PURPOSE containing a list of\n-   selector arguments and TREE_VALUE containing a list of comma\n-   arguments.  */\n-\n-static tree\n-cp_parser_objc_message_args (cp_parser* parser)\n-{\n-  tree sel_args = NULL_TREE, addl_args = NULL_TREE;\n-  bool maybe_unary_selector_p = true;\n-  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\n-  while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON)\n-    {\n-      tree selector = NULL_TREE, arg;\n-\n-      if (token->type != CPP_COLON)\n-\tselector = cp_parser_objc_selector (parser);\n-\n-      /* Detect if we have a unary selector.  */\n-      if (maybe_unary_selector_p\n-\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n-\treturn build_tree_list (selector, NULL_TREE);\n-\n-      maybe_unary_selector_p = false;\n-      cp_parser_require (parser, CPP_COLON, RT_COLON);\n-      arg = cp_parser_assignment_expression (parser, false, NULL);\n-\n-      sel_args\n-\t= chainon (sel_args,\n-\t\t   build_tree_list (selector, arg));\n-\n-      token = cp_lexer_peek_token (parser->lexer);\n-    }\n-\n-  /* Handle non-selector arguments, if any. */\n-  while (token->type == CPP_COMMA)\n-    {\n-      tree arg;\n-\n-      cp_lexer_consume_token (parser->lexer);\n-      arg = cp_parser_assignment_expression (parser, false, NULL);\n-\n-      addl_args\n-\t= chainon (addl_args,\n-\t\t   build_tree_list (NULL_TREE, arg));\n-\n-      token = cp_lexer_peek_token (parser->lexer);\n-    }\n-\n-  if (sel_args == NULL_TREE && addl_args == NULL_TREE)\n-    {\n-      cp_parser_error (parser, \"objective-c++ message argument(s) are expected\");\n-      return build_tree_list (error_mark_node, error_mark_node);\n-    }\n-\n-  return build_tree_list (sel_args, addl_args);\n-}\n-\n-/* Parse an Objective-C encode expression.\n-\n-   objc-encode-expression:\n-     @encode objc-typename\n-\n-   Returns an encoded representation of the type argument.  */\n-\n-static tree\n-cp_parser_objc_encode_expression (cp_parser* parser)\n-{\n-  tree type;\n-  cp_token *token;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@encode'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n-  token = cp_lexer_peek_token (parser->lexer);\n-  type = complete_type (cp_parser_type_id (parser));\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-\n-  if (!type)\n-    {\n-      error_at (token->location, \n-\t\t\"%<@encode%> must specify a type as an argument\");\n-      return error_mark_node;\n-    }\n-\n-  /* This happens if we find @encode(T) (where T is a template\n-     typename or something dependent on a template typename) when\n-     parsing a template.  In that case, we can't compile it\n-     immediately, but we rather create an AT_ENCODE_EXPR which will\n-     need to be instantiated when the template is used.\n-  */\n-  if (dependent_type_p (type))\n-    {\n-      tree value = build_min (AT_ENCODE_EXPR, size_type_node, type);\n-      TREE_READONLY (value) = 1;\n-      return value;\n-    }\n-\n-  return objc_build_encode_expr (type);\n-}\n-\n-/* Parse an Objective-C @defs expression.  */\n-\n-static tree\n-cp_parser_objc_defs_expression (cp_parser *parser)\n-{\n-  tree name;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@defs'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n-  name = cp_parser_identifier (parser);\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-\n-  return objc_get_class_ivars (name);\n-}\n-\n-/* Parse an Objective-C protocol expression.\n-\n-  objc-protocol-expression:\n-    @protocol ( identifier )\n-\n-  Returns a representation of the protocol expression.  */\n-\n-static tree\n-cp_parser_objc_protocol_expression (cp_parser* parser)\n-{\n-  tree proto;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@protocol'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n-  proto = cp_parser_identifier (parser);\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-\n-  return objc_build_protocol_expr (proto);\n-}\n-\n-/* Parse an Objective-C selector expression.\n-\n-   objc-selector-expression:\n-     @selector ( objc-method-signature )\n-\n-   objc-method-signature:\n-     objc-selector\n-     objc-selector-seq\n-\n-   objc-selector-seq:\n-     objc-selector :\n-     objc-selector-seq objc-selector :\n-\n-  Returns a representation of the method selector.  */\n-\n-static tree\n-cp_parser_objc_selector_expression (cp_parser* parser)\n-{\n-  tree sel_seq = NULL_TREE;\n-  bool maybe_unary_selector_p = true;\n-  cp_token *token;\n-  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@selector'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n-  token = cp_lexer_peek_token (parser->lexer);\n-\n-  while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON\n-\t || token->type == CPP_SCOPE)\n-    {\n-      tree selector = NULL_TREE;\n-\n-      if (token->type != CPP_COLON\n-\t  || token->type == CPP_SCOPE)\n-\tselector = cp_parser_objc_selector (parser);\n-\n-      if (cp_lexer_next_token_is_not (parser->lexer, CPP_COLON)\n-\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_SCOPE))\n-\t{\n-\t  /* Detect if we have a unary selector.  */\n-\t  if (maybe_unary_selector_p)\n-\t    {\n-\t      sel_seq = selector;\n-\t      goto finish_selector;\n-\t    }\n-\t  else\n-\t    {\n-\t      cp_parser_error (parser, \"expected %<:%>\");\n-\t    }\n-\t}\n-      maybe_unary_selector_p = false;\n-      token = cp_lexer_consume_token (parser->lexer);\n-\n-      if (token->type == CPP_SCOPE)\n-\t{\n-\t  sel_seq\n-\t    = chainon (sel_seq,\n-\t\t       build_tree_list (selector, NULL_TREE));\n-\t  sel_seq\n-\t    = chainon (sel_seq,\n-\t\t       build_tree_list (NULL_TREE, NULL_TREE));\n-\t}\n-      else\n-\tsel_seq\n-\t  = chainon (sel_seq,\n-\t\t     build_tree_list (selector, NULL_TREE));\n-\n-      token = cp_lexer_peek_token (parser->lexer);\n-    }\n-\n- finish_selector:\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-\n-  return objc_build_selector_expr (loc, sel_seq);\n-}\n-\n-/* Parse a list of identifiers.\n-\n-   objc-identifier-list:\n-     identifier\n-     objc-identifier-list , identifier\n-\n-   Returns a TREE_LIST of identifier nodes.  */\n-\n-static tree\n-cp_parser_objc_identifier_list (cp_parser* parser)\n-{\n-  tree identifier;\n-  tree list;\n-  cp_token *sep;\n-\n-  identifier = cp_parser_identifier (parser);\n-  if (identifier == error_mark_node)\n-    return error_mark_node;      \n-\n-  list = build_tree_list (NULL_TREE, identifier);\n-  sep = cp_lexer_peek_token (parser->lexer);\n-\n-  while (sep->type == CPP_COMMA)\n-    {\n-      cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n-      identifier = cp_parser_identifier (parser);\n-      if (identifier == error_mark_node)\n-\treturn list;\n-\n-      list = chainon (list, build_tree_list (NULL_TREE,\n-\t\t\t\t\t     identifier));\n-      sep = cp_lexer_peek_token (parser->lexer);\n-    }\n-  \n-  return list;\n-}\n-\n-/* Parse an Objective-C alias declaration.\n-\n-   objc-alias-declaration:\n-     @compatibility_alias identifier identifier ;\n-\n-   This function registers the alias mapping with the Objective-C front end.\n-   It returns nothing.  */\n-\n-static void\n-cp_parser_objc_alias_declaration (cp_parser* parser)\n-{\n-  tree alias, orig;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@compatibility_alias'.  */\n-  alias = cp_parser_identifier (parser);\n-  orig = cp_parser_identifier (parser);\n-  objc_declare_alias (alias, orig);\n-  cp_parser_consume_semicolon_at_end_of_statement (parser);\n-}\n-\n-/* Parse an Objective-C class forward-declaration.\n-\n-   objc-class-declaration:\n-     @class objc-identifier-list ;\n-\n-   The function registers the forward declarations with the Objective-C\n-   front end.  It returns nothing.  */\n-\n-static void\n-cp_parser_objc_class_declaration (cp_parser* parser)\n-{\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@class'.  */\n-  objc_declare_class (cp_parser_objc_identifier_list (parser));\n-  cp_parser_consume_semicolon_at_end_of_statement (parser);\n-}\n-\n-/* Parse a list of Objective-C protocol references.\n-\n-   objc-protocol-refs-opt:\n-     objc-protocol-refs [opt]\n-\n-   objc-protocol-refs:\n-     < objc-identifier-list >\n-\n-   Returns a TREE_LIST of identifiers, if any.  */\n-\n-static tree\n-cp_parser_objc_protocol_refs_opt (cp_parser* parser)\n-{\n-  tree protorefs = NULL_TREE;\n-\n-  if(cp_lexer_next_token_is (parser->lexer, CPP_LESS))\n-    {\n-      cp_lexer_consume_token (parser->lexer);  /* Eat '<'.  */\n-      protorefs = cp_parser_objc_identifier_list (parser);\n-      cp_parser_require (parser, CPP_GREATER, RT_GREATER);\n-    }\n-\n-  return protorefs;\n-}\n-\n-/* Parse a Objective-C visibility specification.  */\n-\n-static void\n-cp_parser_objc_visibility_spec (cp_parser* parser)\n-{\n-  cp_token *vis = cp_lexer_peek_token (parser->lexer);\n-\n-  switch (vis->keyword)\n-    {\n-    case RID_AT_PRIVATE:\n-      objc_set_visibility (OBJC_IVAR_VIS_PRIVATE);\n-      break;\n-    case RID_AT_PROTECTED:\n-      objc_set_visibility (OBJC_IVAR_VIS_PROTECTED);\n-      break;\n-    case RID_AT_PUBLIC:\n-      objc_set_visibility (OBJC_IVAR_VIS_PUBLIC);\n-      break;\n-    case RID_AT_PACKAGE:\n-      objc_set_visibility (OBJC_IVAR_VIS_PACKAGE);\n-      break;\n-    default:\n-      return;\n-    }\n-\n-  /* Eat '@private'/'@protected'/'@public'.  */\n-  cp_lexer_consume_token (parser->lexer);\n-}\n-\n-/* Parse an Objective-C method type.  Return 'true' if it is a class\n-   (+) method, and 'false' if it is an instance (-) method.  */\n-\n-static inline bool\n-cp_parser_objc_method_type (cp_parser* parser)\n-{\n-  if (cp_lexer_consume_token (parser->lexer)->type == CPP_PLUS)\n-    return true;\n-  else\n-    return false;\n-}\n-\n-/* Parse an Objective-C protocol qualifier.  */\n-\n-static tree\n-cp_parser_objc_protocol_qualifiers (cp_parser* parser)\n-{\n-  tree quals = NULL_TREE, node;\n-  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\n-  node = token->u.value;\n-\n-  while (node && TREE_CODE (node) == IDENTIFIER_NODE\n-\t && (node == ridpointers [(int) RID_IN]\n-\t     || node == ridpointers [(int) RID_OUT]\n-\t     || node == ridpointers [(int) RID_INOUT]\n-\t     || node == ridpointers [(int) RID_BYCOPY]\n-\t     || node == ridpointers [(int) RID_BYREF]\n-\t     || node == ridpointers [(int) RID_ONEWAY]))\n-    {\n-      quals = tree_cons (NULL_TREE, node, quals);\n-      cp_lexer_consume_token (parser->lexer);\n-      token = cp_lexer_peek_token (parser->lexer);\n-      node = token->u.value;\n-    }\n-\n-  return quals;\n-}\n-\n-/* Parse an Objective-C typename.  */\n-\n-static tree\n-cp_parser_objc_typename (cp_parser* parser)\n-{\n-  tree type_name = NULL_TREE;\n-\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n-    {\n-      tree proto_quals, cp_type = NULL_TREE;\n-\n-      cp_lexer_consume_token (parser->lexer);  /* Eat '('.  */\n-      proto_quals = cp_parser_objc_protocol_qualifiers (parser);\n-\n-      /* An ObjC type name may consist of just protocol qualifiers, in which\n-\t case the type shall default to 'id'.  */\n-      if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n-\t{\n-\t  cp_type = cp_parser_type_id (parser);\n-\t  \n-\t  /* If the type could not be parsed, an error has already\n-\t     been produced.  For error recovery, behave as if it had\n-\t     not been specified, which will use the default type\n-\t     'id'.  */\n-\t  if (cp_type == error_mark_node)\n-\t    {\n-\t      cp_type = NULL_TREE;\n-\t      /* We need to skip to the closing parenthesis as\n-\t\t cp_parser_type_id() does not seem to do it for\n-\t\t us.  */\n-\t      cp_parser_skip_to_closing_parenthesis (parser,\n-\t\t\t\t\t\t     /*recovering=*/true,\n-\t\t\t\t\t\t     /*or_comma=*/false,\n-\t\t\t\t\t\t     /*consume_paren=*/false);\n-\t    }\n-\t}\n-\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-      type_name = build_tree_list (proto_quals, cp_type);\n-    }\n-\n-  return type_name;\n-}\n-\n-/* Check to see if TYPE refers to an Objective-C selector name.  */\n-\n-static bool\n-cp_parser_objc_selector_p (enum cpp_ttype type)\n-{\n-  return (type == CPP_NAME || type == CPP_KEYWORD\n-\t  || type == CPP_AND_AND || type == CPP_AND_EQ || type == CPP_AND\n-\t  || type == CPP_OR || type == CPP_COMPL || type == CPP_NOT\n-\t  || type == CPP_NOT_EQ || type == CPP_OR_OR || type == CPP_OR_EQ\n-\t  || type == CPP_XOR || type == CPP_XOR_EQ);\n-}\n-\n-/* Parse an Objective-C selector.  */\n-\n-static tree\n-cp_parser_objc_selector (cp_parser* parser)\n-{\n-  cp_token *token = cp_lexer_consume_token (parser->lexer);\n-\n-  if (!cp_parser_objc_selector_p (token->type))\n-    {\n-      error_at (token->location, \"invalid Objective-C++ selector name\");\n-      return error_mark_node;\n-    }\n-\n-  /* C++ operator names are allowed to appear in ObjC selectors.  */\n-  switch (token->type)\n-    {\n-    case CPP_AND_AND: return get_identifier (\"and\");\n-    case CPP_AND_EQ: return get_identifier (\"and_eq\");\n-    case CPP_AND: return get_identifier (\"bitand\");\n-    case CPP_OR: return get_identifier (\"bitor\");\n-    case CPP_COMPL: return get_identifier (\"compl\");\n-    case CPP_NOT: return get_identifier (\"not\");\n-    case CPP_NOT_EQ: return get_identifier (\"not_eq\");\n-    case CPP_OR_OR: return get_identifier (\"or\");\n-    case CPP_OR_EQ: return get_identifier (\"or_eq\");\n-    case CPP_XOR: return get_identifier (\"xor\");\n-    case CPP_XOR_EQ: return get_identifier (\"xor_eq\");\n-    default: return token->u.value;\n-    }\n-}\n-\n-/* Parse an Objective-C params list.  */\n-\n-static tree\n-cp_parser_objc_method_keyword_params (cp_parser* parser, tree* attributes)\n-{\n-  tree params = NULL_TREE;\n-  bool maybe_unary_selector_p = true;\n-  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\n-  while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON)\n-    {\n-      tree selector = NULL_TREE, type_name, identifier;\n-      tree parm_attr = NULL_TREE;\n-\n-      if (token->keyword == RID_ATTRIBUTE)\n-\tbreak;\n-\n-      if (token->type != CPP_COLON)\n-\tselector = cp_parser_objc_selector (parser);\n-\n-      /* Detect if we have a unary selector.  */\n-      if (maybe_unary_selector_p\n-\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n-\t{\n-\t  params = selector; /* Might be followed by attributes.  */\n-\t  break;\n-\t}\n-\n-      maybe_unary_selector_p = false;\n-      if (!cp_parser_require (parser, CPP_COLON, RT_COLON))\n-\t{\n-\t  /* Something went quite wrong.  There should be a colon\n-\t     here, but there is not.  Stop parsing parameters.  */\n-\t  break;\n-\t}\n-      type_name = cp_parser_objc_typename (parser);\n-      /* New ObjC allows attributes on parameters too.  */\n-      if (cp_lexer_next_token_is_keyword (parser->lexer, RID_ATTRIBUTE))\n-\tparm_attr = cp_parser_attributes_opt (parser);\n-      identifier = cp_parser_identifier (parser);\n-\n-      params\n-\t= chainon (params,\n-\t\t   objc_build_keyword_decl (selector,\n-\t\t\t\t\t    type_name,\n-\t\t\t\t\t    identifier,\n-\t\t\t\t\t    parm_attr));\n-\n-      token = cp_lexer_peek_token (parser->lexer);\n-    }\n-\n-  if (params == NULL_TREE)\n-    {\n-      cp_parser_error (parser, \"objective-c++ method declaration is expected\");\n-      return error_mark_node;\n-    }\n-\n-  /* We allow tail attributes for the method.  */\n-  if (token->keyword == RID_ATTRIBUTE)\n-    {\n-      *attributes = cp_parser_attributes_opt (parser);\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON)\n-\t  || cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n-\treturn params;\n-      cp_parser_error (parser, \n-\t\t       \"method attributes must be specified at the end\");\n-      return error_mark_node;\n-    }\n-\n-  if (params == NULL_TREE)\n-    {\n-      cp_parser_error (parser, \"objective-c++ method declaration is expected\");\n-      return error_mark_node;\n-    }\n-  return params;\n-}\n-\n-/* Parse the non-keyword Objective-C params.  */\n-\n-static tree\n-cp_parser_objc_method_tail_params_opt (cp_parser* parser, bool *ellipsisp, \n-\t\t\t\t       tree* attributes)\n-{\n-  tree params = make_node (TREE_LIST);\n-  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-  *ellipsisp = false;  /* Initially, assume no ellipsis.  */\n-\n-  while (token->type == CPP_COMMA)\n-    {\n-      cp_parameter_declarator *parmdecl;\n-      tree parm;\n-\n-      cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n-      token = cp_lexer_peek_token (parser->lexer);\n-\n-      if (token->type == CPP_ELLIPSIS)\n-\t{\n-\t  cp_lexer_consume_token (parser->lexer);  /* Eat '...'.  */\n-\t  *ellipsisp = true;\n-\t  token = cp_lexer_peek_token (parser->lexer);\n-\t  break;\n-\t}\n-\n-      /* TODO: parse attributes for tail parameters.  */\n-      parmdecl = cp_parser_parameter_declaration (parser, false, NULL);\n-      parm = grokdeclarator (parmdecl->declarator,\n-\t\t\t     &parmdecl->decl_specifiers,\n-\t\t\t     PARM, /*initialized=*/0,\n-\t\t\t     /*attrlist=*/NULL);\n-\n-      chainon (params, build_tree_list (NULL_TREE, parm));\n-      token = cp_lexer_peek_token (parser->lexer);\n-    }\n-\n-  /* We allow tail attributes for the method.  */\n-  if (token->keyword == RID_ATTRIBUTE)\n-    {\n-      if (*attributes == NULL_TREE)\n-\t{\n-\t  *attributes = cp_parser_attributes_opt (parser);\n-\t  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON)\n-\t      || cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n-\t    return params;\n-\t}\n-      else        \n-\t/* We have an error, but parse the attributes, so that we can \n-\t   carry on.  */\n-\t*attributes = cp_parser_attributes_opt (parser);\n-\n-      cp_parser_error (parser, \n-\t\t       \"method attributes must be specified at the end\");\n-      return error_mark_node;\n-    }\n-\n-  return params;\n-}\n-\n-/* Parse a linkage specification, a pragma, an extra semicolon or a block.  */\n-\n-static void\n-cp_parser_objc_interstitial_code (cp_parser* parser)\n-{\n-  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\n-  /* If the next token is `extern' and the following token is a string\n-     literal, then we have a linkage specification.  */\n-  if (token->keyword == RID_EXTERN\n-      && cp_parser_is_string_literal (cp_lexer_peek_nth_token (parser->lexer, 2)))\n-    cp_parser_linkage_specification (parser);\n-  /* Handle #pragma, if any.  */\n-  else if (token->type == CPP_PRAGMA)\n-    cp_parser_pragma (parser, pragma_external);\n-  /* Allow stray semicolons.  */\n-  else if (token->type == CPP_SEMICOLON)\n-    cp_lexer_consume_token (parser->lexer);\n-  /* Mark methods as optional or required, when building protocols.  */\n-  else if (token->keyword == RID_AT_OPTIONAL)\n-    {\n-      cp_lexer_consume_token (parser->lexer);\n-      objc_set_method_opt (true);\n-    }\n-  else if (token->keyword == RID_AT_REQUIRED)\n-    {\n-      cp_lexer_consume_token (parser->lexer);\n-      objc_set_method_opt (false);\n-    }\n-  else if (token->keyword == RID_NAMESPACE)\n-    cp_parser_namespace_definition (parser);\n-  /* Other stray characters must generate errors.  */\n-  else if (token->type == CPP_OPEN_BRACE || token->type == CPP_CLOSE_BRACE)\n-    {\n-      cp_lexer_consume_token (parser->lexer);\n-      error (\"stray %qs between Objective-C++ methods\",\n-\t     token->type == CPP_OPEN_BRACE ? \"{\" : \"}\");\n-    }\n-  /* Finally, try to parse a block-declaration, or a function-definition.  */\n-  else\n-    cp_parser_block_declaration (parser, /*statement_p=*/false);\n-}\n-\n-/* Parse a method signature.  */\n-\n-static tree\n-cp_parser_objc_method_signature (cp_parser* parser, tree* attributes)\n-{\n-  tree rettype, kwdparms, optparms;\n-  bool ellipsis = false;\n-  bool is_class_method;\n-\n-  is_class_method = cp_parser_objc_method_type (parser);\n-  rettype = cp_parser_objc_typename (parser);\n-  *attributes = NULL_TREE;\n-  kwdparms = cp_parser_objc_method_keyword_params (parser, attributes);\n-  if (kwdparms == error_mark_node)\n-    return error_mark_node;\n-  optparms = cp_parser_objc_method_tail_params_opt (parser, &ellipsis, attributes);\n-  if (optparms == error_mark_node)\n-    return error_mark_node;\n-\n-  return objc_build_method_signature (is_class_method, rettype, kwdparms, optparms, ellipsis);\n-}\n-\n-static bool\n-cp_parser_objc_method_maybe_bad_prefix_attributes (cp_parser* parser)\n-{\n-  tree tattr;  \n-  cp_lexer_save_tokens (parser->lexer);\n-  tattr = cp_parser_attributes_opt (parser);\n-  gcc_assert (tattr) ;\n-  \n-  /* If the attributes are followed by a method introducer, this is not allowed.\n-     Dump the attributes and flag the situation.  */\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_PLUS)\n-      || cp_lexer_next_token_is (parser->lexer, CPP_MINUS))\n-    return true;\n-\n-  /* Otherwise, the attributes introduce some interstitial code, possibly so\n-     rewind to allow that check.  */\n-  cp_lexer_rollback_tokens (parser->lexer);\n-  return false;  \n-}\n-\n-/* Parse an Objective-C method prototype list.  */\n-\n-static void\n-cp_parser_objc_method_prototype_list (cp_parser* parser)\n-{\n-  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\n-  while (token->keyword != RID_AT_END && token->type != CPP_EOF)\n-    {\n-      if (token->type == CPP_PLUS || token->type == CPP_MINUS)\n-\t{\n-\t  tree attributes, sig;\n-\t  bool is_class_method;\n-\t  if (token->type == CPP_PLUS)\n-\t    is_class_method = true;\n-\t  else\n-\t    is_class_method = false;\n-\t  sig = cp_parser_objc_method_signature (parser, &attributes);\n-\t  if (sig == error_mark_node)\n-\t    {\n-\t      cp_parser_skip_to_end_of_block_or_statement (parser);\n-\t      token = cp_lexer_peek_token (parser->lexer);\n-\t      continue;\n-\t    }\n-\t  objc_add_method_declaration (is_class_method, sig, attributes);\n-\t  cp_parser_consume_semicolon_at_end_of_statement (parser);\n-\t}\n-      else if (token->keyword == RID_AT_PROPERTY)\n-\tcp_parser_objc_at_property_declaration (parser);\n-      else if (token->keyword == RID_ATTRIBUTE \n-      \t       && cp_parser_objc_method_maybe_bad_prefix_attributes(parser))\n-\twarning_at (cp_lexer_peek_token (parser->lexer)->location, \n-\t\t    OPT_Wattributes, \n-\t\t    \"prefix attributes are ignored for methods\");\n-      else\n-\t/* Allow for interspersed non-ObjC++ code.  */\n-\tcp_parser_objc_interstitial_code (parser);\n-\n-      token = cp_lexer_peek_token (parser->lexer);\n-    }\n-\n-  if (token->type != CPP_EOF)\n-    cp_lexer_consume_token (parser->lexer);  /* Eat '@end'.  */\n-  else\n-    cp_parser_error (parser, \"expected %<@end%>\");\n-\n-  objc_finish_interface ();\n-}\n-\n-/* Parse an Objective-C method definition list.  */\n-\n-static void\n-cp_parser_objc_method_definition_list (cp_parser* parser)\n-{\n-  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\n-  while (token->keyword != RID_AT_END && token->type != CPP_EOF)\n-    {\n-      tree meth;\n-\n-      if (token->type == CPP_PLUS || token->type == CPP_MINUS)\n-\t{\n-\t  cp_token *ptk;\n-\t  tree sig, attribute;\n-\t  bool is_class_method;\n-\t  if (token->type == CPP_PLUS)\n-\t    is_class_method = true;\n-\t  else\n-\t    is_class_method = false;\n-\t  push_deferring_access_checks (dk_deferred);\n-\t  sig = cp_parser_objc_method_signature (parser, &attribute);\n-\t  if (sig == error_mark_node)\n-\t    {\n-\t      cp_parser_skip_to_end_of_block_or_statement (parser);\n-\t      token = cp_lexer_peek_token (parser->lexer);\n-\t      continue;\n-\t    }\n-\t  objc_start_method_definition (is_class_method, sig, attribute);\n-\n-\t  /* For historical reasons, we accept an optional semicolon.  */\n-\t  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n-\t    cp_lexer_consume_token (parser->lexer);\n-\n-\t  ptk = cp_lexer_peek_token (parser->lexer);\n-\t  if (!(ptk->type == CPP_PLUS || ptk->type == CPP_MINUS \n-\t\t|| ptk->type == CPP_EOF || ptk->keyword == RID_AT_END))\n-\t    {\n-\t      perform_deferred_access_checks ();\n-\t      stop_deferring_access_checks ();\n-\t      meth = cp_parser_function_definition_after_declarator (parser,\n-\t\t\t\t\t\t\t\t     false);\n-\t      pop_deferring_access_checks ();\n-\t      objc_finish_method_definition (meth);\n-\t    }\n-\t}\n-      /* The following case will be removed once @synthesize is\n-\t completely implemented.  */\n-      else if (token->keyword == RID_AT_PROPERTY)\n-\tcp_parser_objc_at_property_declaration (parser);\n-      else if (token->keyword == RID_AT_SYNTHESIZE)\n-\tcp_parser_objc_at_synthesize_declaration (parser);\n-      else if (token->keyword == RID_AT_DYNAMIC)\n-\tcp_parser_objc_at_dynamic_declaration (parser);\n-      else if (token->keyword == RID_ATTRIBUTE \n-      \t       && cp_parser_objc_method_maybe_bad_prefix_attributes(parser))\n-\twarning_at (token->location, OPT_Wattributes,\n-\t       \t    \"prefix attributes are ignored for methods\");\n-      else\n-\t/* Allow for interspersed non-ObjC++ code.  */\n-\tcp_parser_objc_interstitial_code (parser);\n-\n-      token = cp_lexer_peek_token (parser->lexer);\n-    }\n-\n-  if (token->type != CPP_EOF)\n-    cp_lexer_consume_token (parser->lexer);  /* Eat '@end'.  */\n-  else\n-    cp_parser_error (parser, \"expected %<@end%>\");\n-\n-  objc_finish_implementation ();\n-}\n-\n-/* Parse Objective-C ivars.  */\n-\n-static void\n-cp_parser_objc_class_ivars (cp_parser* parser)\n-{\n-  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\n-  if (token->type != CPP_OPEN_BRACE)\n-    return;\t/* No ivars specified.  */\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '{'.  */\n-  token = cp_lexer_peek_token (parser->lexer);\n-\n-  while (token->type != CPP_CLOSE_BRACE \n-\t&& token->keyword != RID_AT_END && token->type != CPP_EOF)\n-    {\n-      cp_decl_specifier_seq declspecs;\n-      int decl_class_or_enum_p;\n-      tree prefix_attributes;\n-\n-      cp_parser_objc_visibility_spec (parser);\n-\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))\n-\tbreak;\n-\n-      cp_parser_decl_specifier_seq (parser,\n-\t\t\t\t    CP_PARSER_FLAGS_OPTIONAL,\n-\t\t\t\t    &declspecs,\n-\t\t\t\t    &decl_class_or_enum_p);\n-\n-      /* auto, register, static, extern, mutable.  */\n-      if (declspecs.storage_class != sc_none)\n-\t{\n-\t  cp_parser_error (parser, \"invalid type for instance variable\");\t  \n-\t  declspecs.storage_class = sc_none;\n-\t}\n-\n-      /* __thread.  */\n-      if (declspecs.specs[(int) ds_thread])\n-\t{\n-\t  cp_parser_error (parser, \"invalid type for instance variable\");\n-\t  declspecs.specs[(int) ds_thread] = 0;\n-\t}\n-      \n-      /* typedef.  */\n-      if (declspecs.specs[(int) ds_typedef])\n-\t{\n-\t  cp_parser_error (parser, \"invalid type for instance variable\");\n-\t  declspecs.specs[(int) ds_typedef] = 0;\n-\t}\n-\n-      prefix_attributes = declspecs.attributes;\n-      declspecs.attributes = NULL_TREE;\n-\n-      /* Keep going until we hit the `;' at the end of the\n-\t declaration.  */\n-      while (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-\t{\n-\t  tree width = NULL_TREE, attributes, first_attribute, decl;\n-\t  cp_declarator *declarator = NULL;\n-\t  int ctor_dtor_or_conv_p;\n-\n-\t  /* Check for a (possibly unnamed) bitfield declaration.  */\n-\t  token = cp_lexer_peek_token (parser->lexer);\n-\t  if (token->type == CPP_COLON)\n-\t    goto eat_colon;\n-\n-\t  if (token->type == CPP_NAME\n-\t      && (cp_lexer_peek_nth_token (parser->lexer, 2)->type\n-\t\t  == CPP_COLON))\n-\t    {\n-\t      /* Get the name of the bitfield.  */\n-\t      declarator = make_id_declarator (NULL_TREE,\n-\t\t\t\t\t       cp_parser_identifier (parser),\n-\t\t\t\t\t       sfk_none);\n-\n-\t     eat_colon:\n-\t      cp_lexer_consume_token (parser->lexer);  /* Eat ':'.  */\n-\t      /* Get the width of the bitfield.  */\n-\t      width\n-\t\t= cp_parser_constant_expression (parser,\n-\t\t\t\t\t\t /*allow_non_constant=*/false,\n-\t\t\t\t\t\t NULL);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Parse the declarator.  */\n-\t      declarator\n-\t\t= cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n-\t\t\t\t\t&ctor_dtor_or_conv_p,\n-\t\t\t\t\t/*parenthesized_p=*/NULL,\n-\t\t\t\t\t/*member_p=*/false);\n-\t    }\n-\n-\t  /* Look for attributes that apply to the ivar.  */\n-\t  attributes = cp_parser_attributes_opt (parser);\n-\t  /* Remember which attributes are prefix attributes and\n-\t     which are not.  */\n-\t  first_attribute = attributes;\n-\t  /* Combine the attributes.  */\n-\t  attributes = chainon (prefix_attributes, attributes);\n-\n-\t  if (width)\n-\t      /* Create the bitfield declaration.  */\n-\t      decl = grokbitfield (declarator, &declspecs,\n-\t\t\t\t   width,\n-\t\t\t\t   attributes);\n-\t  else\n-\t    decl = grokfield (declarator, &declspecs,\n-\t\t\t      NULL_TREE, /*init_const_expr_p=*/false,\n-\t\t\t      NULL_TREE, attributes);\n-\n-\t  /* Add the instance variable.  */\n-\t  objc_add_instance_variable (decl);\n-\n-\t  /* Reset PREFIX_ATTRIBUTES.  */\n-\t  while (attributes && TREE_CHAIN (attributes) != first_attribute)\n-\t    attributes = TREE_CHAIN (attributes);\n-\t  if (attributes)\n-\t    TREE_CHAIN (attributes) = NULL_TREE;\n-\n-\t  token = cp_lexer_peek_token (parser->lexer);\n-\n-\t  if (token->type == CPP_COMMA)\n-\t    {\n-\t      cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n-\t      continue;\n-\t    }\n-\t  break;\n-\t}\n-\n-      cp_parser_consume_semicolon_at_end_of_statement (parser);\n-      token = cp_lexer_peek_token (parser->lexer);\n-    }\n-\n-  if (token->keyword == RID_AT_END)\n-    cp_parser_error (parser, \"expected %<}%>\");\n-\n-  /* Do not consume the RID_AT_END, so it will be read again as terminating\n-     the @interface of @implementation.  */ \n-  if (token->keyword != RID_AT_END && token->type != CPP_EOF)\n-    cp_lexer_consume_token (parser->lexer);  /* Eat '}'.  */\n-    \n-  /* For historical reasons, we accept an optional semicolon.  */\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n-    cp_lexer_consume_token (parser->lexer);\n-}\n-\n-/* Parse an Objective-C protocol declaration.  */\n-\n-static void\n-cp_parser_objc_protocol_declaration (cp_parser* parser, tree attributes)\n-{\n-  tree proto, protorefs;\n-  cp_token *tok;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@protocol'.  */\n-  if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n-    {\n-      tok = cp_lexer_peek_token (parser->lexer);\n-      error_at (tok->location, \"identifier expected after %<@protocol%>\");\n-      goto finish;\n-    }\n-\n-  /* See if we have a forward declaration or a definition.  */\n-  tok = cp_lexer_peek_nth_token (parser->lexer, 2);\n-\n-  /* Try a forward declaration first.  */\n-  if (tok->type == CPP_COMMA || tok->type == CPP_SEMICOLON)\n-    {\n-      objc_declare_protocols (cp_parser_objc_identifier_list (parser), \n-\t\t\t      attributes);\n-     finish:\n-      cp_parser_consume_semicolon_at_end_of_statement (parser);\n-    }\n-\n-  /* Ok, we got a full-fledged definition (or at least should).  */\n-  else\n-    {\n-      proto = cp_parser_identifier (parser);\n-      protorefs = cp_parser_objc_protocol_refs_opt (parser);\n-      objc_start_protocol (proto, protorefs, attributes);\n-      cp_parser_objc_method_prototype_list (parser);\n-    }\n-}\n-\n-/* Parse an Objective-C superclass or category.  */\n-\n-static void\n-cp_parser_objc_superclass_or_category (cp_parser *parser, \n-\t\t\t\t       bool iface_p,\n-\t\t\t\t       tree *super,\n-\t\t\t\t       tree *categ, bool *is_class_extension)\n-{\n-  cp_token *next = cp_lexer_peek_token (parser->lexer);\n-\n-  *super = *categ = NULL_TREE;\n-  *is_class_extension = false;\n-  if (next->type == CPP_COLON)\n-    {\n-      cp_lexer_consume_token (parser->lexer);  /* Eat ':'.  */\n-      *super = cp_parser_identifier (parser);\n-    }\n-  else if (next->type == CPP_OPEN_PAREN)\n-    {\n-      cp_lexer_consume_token (parser->lexer);  /* Eat '('.  */\n-\n-      /* If there is no category name, and this is an @interface, we\n-\t have a class extension.  */\n-      if (iface_p && cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n-\t{\n-\t  *categ = NULL_TREE;\n-\t  *is_class_extension = true;\n-\t}\n-      else\n-\t*categ = cp_parser_identifier (parser);\n-\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-    }\n-}\n-\n-/* Parse an Objective-C class interface.  */\n-\n-static void\n-cp_parser_objc_class_interface (cp_parser* parser, tree attributes)\n-{\n-  tree name, super, categ, protos;\n-  bool is_class_extension;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@interface'.  */\n-  name = cp_parser_identifier (parser);\n-  if (name == error_mark_node)\n-    {\n-      /* It's hard to recover because even if valid @interface stuff\n-\t is to follow, we can't compile it (or validate it) if we\n-\t don't even know which class it refers to.  Let's assume this\n-\t was a stray '@interface' token in the stream and skip it.\n-      */\n-      return;\n-    }\n-  cp_parser_objc_superclass_or_category (parser, true, &super, &categ,\n-\t\t\t\t\t &is_class_extension);\n-  protos = cp_parser_objc_protocol_refs_opt (parser);\n-\n-  /* We have either a class or a category on our hands.  */\n-  if (categ || is_class_extension)\n-    objc_start_category_interface (name, categ, protos, attributes);\n-  else\n-    {\n-      objc_start_class_interface (name, super, protos, attributes);\n-      /* Handle instance variable declarations, if any.  */\n-      cp_parser_objc_class_ivars (parser);\n-      objc_continue_interface ();\n-    }\n-\n-  cp_parser_objc_method_prototype_list (parser);\n-}\n-\n-/* Parse an Objective-C class implementation.  */\n-\n-static void\n-cp_parser_objc_class_implementation (cp_parser* parser)\n-{\n-  tree name, super, categ;\n-  bool is_class_extension;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@implementation'.  */\n-  name = cp_parser_identifier (parser);\n-  if (name == error_mark_node)\n-    {\n-      /* It's hard to recover because even if valid @implementation\n-\t stuff is to follow, we can't compile it (or validate it) if\n-\t we don't even know which class it refers to.  Let's assume\n-\t this was a stray '@implementation' token in the stream and\n-\t skip it.\n-      */\n-      return;\n-    }\n-  cp_parser_objc_superclass_or_category (parser, false, &super, &categ,\n-\t\t\t\t\t &is_class_extension);\n-\n-  /* We have either a class or a category on our hands.  */\n-  if (categ)\n-    objc_start_category_implementation (name, categ);\n-  else\n-    {\n-      objc_start_class_implementation (name, super);\n-      /* Handle instance variable declarations, if any.  */\n-      cp_parser_objc_class_ivars (parser);\n-      objc_continue_implementation ();\n-    }\n-\n-  cp_parser_objc_method_definition_list (parser);\n-}\n-\n-/* Consume the @end token and finish off the implementation.  */\n-\n-static void\n-cp_parser_objc_end_implementation (cp_parser* parser)\n-{\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@end'.  */\n-  objc_finish_implementation ();\n-}\n-\n-/* Parse an Objective-C declaration.  */\n-\n-static void\n-cp_parser_objc_declaration (cp_parser* parser, tree attributes)\n-{\n-  /* Try to figure out what kind of declaration is present.  */\n-  cp_token *kwd = cp_lexer_peek_token (parser->lexer);\n-\n-  if (attributes)\n-    switch (kwd->keyword)\n-      {\n-\tcase RID_AT_ALIAS:\n-\tcase RID_AT_CLASS:\n-\tcase RID_AT_END:\n-\t  error_at (kwd->location, \"attributes may not be specified before\"\n-\t            \" the %<@%D%> Objective-C++ keyword\",\n-\t\t    kwd->u.value);\n-\t  attributes = NULL;\n-\t  break;\n-\tcase RID_AT_IMPLEMENTATION:\n-\t  warning_at (kwd->location, OPT_Wattributes,\n-\t\t      \"prefix attributes are ignored before %<@%D%>\",\n-\t\t      kwd->u.value);\n-\t  attributes = NULL;\n-\tdefault:\n-\t  break;\n-      }\n-\n-  switch (kwd->keyword)\n-    {\n-    case RID_AT_ALIAS:\n-      cp_parser_objc_alias_declaration (parser);\n-      break;\n-    case RID_AT_CLASS:\n-      cp_parser_objc_class_declaration (parser);\n-      break;\n-    case RID_AT_PROTOCOL:\n-      cp_parser_objc_protocol_declaration (parser, attributes);\n-      break;\n-    case RID_AT_INTERFACE:\n-      cp_parser_objc_class_interface (parser, attributes);\n-      break;\n-    case RID_AT_IMPLEMENTATION:\n-      cp_parser_objc_class_implementation (parser);\n-      break;\n-    case RID_AT_END:\n-      cp_parser_objc_end_implementation (parser);\n-      break;\n-    default:\n-      error_at (kwd->location, \"misplaced %<@%D%> Objective-C++ construct\",\n-\t\tkwd->u.value);\n-      cp_parser_skip_to_end_of_block_or_statement (parser);\n-    }\n-}\n-\n-/* Parse an Objective-C try-catch-finally statement.\n-\n-   objc-try-catch-finally-stmt:\n-     @try compound-statement objc-catch-clause-seq [opt]\n-       objc-finally-clause [opt]\n-\n-   objc-catch-clause-seq:\n-     objc-catch-clause objc-catch-clause-seq [opt]\n-\n-   objc-catch-clause:\n-     @catch ( objc-exception-declaration ) compound-statement\n-\n-   objc-finally-clause:\n-     @finally compound-statement\n-\n-   objc-exception-declaration:\n-     parameter-declaration\n-     '...'\n-\n-   where '...' is to be interpreted literally, that is, it means CPP_ELLIPSIS.\n-\n-   Returns NULL_TREE.\n-\n-   PS: This function is identical to c_parser_objc_try_catch_finally_statement\n-   for C.  Keep them in sync.  */   \n-\n-static tree\n-cp_parser_objc_try_catch_finally_statement (cp_parser *parser)\n-{\n-  location_t location;\n-  tree stmt;\n-\n-  cp_parser_require_keyword (parser, RID_AT_TRY, RT_AT_TRY);\n-  location = cp_lexer_peek_token (parser->lexer)->location;\n-  objc_maybe_warn_exceptions (location);\n-  /* NB: The @try block needs to be wrapped in its own STATEMENT_LIST\n-     node, lest it get absorbed into the surrounding block.  */\n-  stmt = push_stmt_list ();\n-  cp_parser_compound_statement (parser, NULL, false);\n-  objc_begin_try_stmt (location, pop_stmt_list (stmt));\n-\n-  while (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_CATCH))\n-    {\n-      cp_parameter_declarator *parm;\n-      tree parameter_declaration = error_mark_node;\n-      bool seen_open_paren = false;\n-\n-      cp_lexer_consume_token (parser->lexer);\n-      if (cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n-\tseen_open_paren = true;\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n-\t{\n-\t  /* We have \"@catch (...)\" (where the '...' are literally\n-\t     what is in the code).  Skip the '...'.\n-\t     parameter_declaration is set to NULL_TREE, and\n-\t     objc_being_catch_clauses() knows that that means\n-\t     '...'.  */\n-\t  cp_lexer_consume_token (parser->lexer);\n-\t  parameter_declaration = NULL_TREE;\n-\t}\n-      else\n-\t{\n-\t  /* We have \"@catch (NSException *exception)\" or something\n-\t     like that.  Parse the parameter declaration.  */\n-\t  parm = cp_parser_parameter_declaration (parser, false, NULL);\n-\t  if (parm == NULL)\n-\t    parameter_declaration = error_mark_node;\n-\t  else\n-\t    parameter_declaration = grokdeclarator (parm->declarator,\n-\t\t\t\t\t\t    &parm->decl_specifiers,\n-\t\t\t\t\t\t    PARM, /*initialized=*/0,\n-\t\t\t\t\t\t    /*attrlist=*/NULL);\n-\t}\n-      if (seen_open_paren)\n-\tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-      else\n-\t{\n-\t  /* If there was no open parenthesis, we are recovering from\n-\t     an error, and we are trying to figure out what mistake\n-\t     the user has made.  */\n-\n-\t  /* If there is an immediate closing parenthesis, the user\n-\t     probably forgot the opening one (ie, they typed \"@catch\n-\t     NSException *e)\".  Parse the closing parenthesis and keep\n-\t     going.  */\n-\t  if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n-\t    cp_lexer_consume_token (parser->lexer);\n-\t  \n-\t  /* If these is no immediate closing parenthesis, the user\n-\t     probably doesn't know that parenthesis are required at\n-\t     all (ie, they typed \"@catch NSException *e\").  So, just\n-\t     forget about the closing parenthesis and keep going.  */\n-\t}\n-      objc_begin_catch_clause (parameter_declaration);\n-      cp_parser_compound_statement (parser, NULL, false);\n-      objc_finish_catch_clause ();\n-    }\n-  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_FINALLY))\n-    {\n-      cp_lexer_consume_token (parser->lexer);\n-      location = cp_lexer_peek_token (parser->lexer)->location;\n-      /* NB: The @finally block needs to be wrapped in its own STATEMENT_LIST\n-\t node, lest it get absorbed into the surrounding block.  */\n-      stmt = push_stmt_list ();\n-      cp_parser_compound_statement (parser, NULL, false);\n-      objc_build_finally_clause (location, pop_stmt_list (stmt));\n-    }\n-\n-  return objc_finish_try_stmt ();\n-}\n-\n-/* Parse an Objective-C synchronized statement.\n-\n-   objc-synchronized-stmt:\n-     @synchronized ( expression ) compound-statement\n-\n-   Returns NULL_TREE.  */\n-\n-static tree\n-cp_parser_objc_synchronized_statement (cp_parser *parser)\n-{\n-  location_t location;\n-  tree lock, stmt;\n-\n-  cp_parser_require_keyword (parser, RID_AT_SYNCHRONIZED, RT_AT_SYNCHRONIZED);\n-\n-  location = cp_lexer_peek_token (parser->lexer)->location;\n-  objc_maybe_warn_exceptions (location);\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n-  lock = cp_parser_expression (parser, false, NULL);\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-\n-  /* NB: The @synchronized block needs to be wrapped in its own STATEMENT_LIST\n-     node, lest it get absorbed into the surrounding block.  */\n-  stmt = push_stmt_list ();\n-  cp_parser_compound_statement (parser, NULL, false);\n-\n-  return objc_build_synchronized (location, lock, pop_stmt_list (stmt));\n-}\n-\n-/* Parse an Objective-C throw statement.\n-\n-   objc-throw-stmt:\n-     @throw assignment-expression [opt] ;\n-\n-   Returns a constructed '@throw' statement.  */\n-\n-static tree\n-cp_parser_objc_throw_statement (cp_parser *parser)\n-{\n-  tree expr = NULL_TREE;\n-  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n-\n-  cp_parser_require_keyword (parser, RID_AT_THROW, RT_AT_THROW);\n-\n-  if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-    expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n-\n-  cp_parser_consume_semicolon_at_end_of_statement (parser);\n-\n-  return objc_build_throw_stmt (loc, expr);\n-}\n-\n-/* Parse an Objective-C statement.  */\n-\n-static tree\n-cp_parser_objc_statement (cp_parser * parser)\n-{\n-  /* Try to figure out what kind of declaration is present.  */\n-  cp_token *kwd = cp_lexer_peek_token (parser->lexer);\n-\n-  switch (kwd->keyword)\n-    {\n-    case RID_AT_TRY:\n-      return cp_parser_objc_try_catch_finally_statement (parser);\n-    case RID_AT_SYNCHRONIZED:\n-      return cp_parser_objc_synchronized_statement (parser);\n-    case RID_AT_THROW:\n-      return cp_parser_objc_throw_statement (parser);\n-    default:\n-      error_at (kwd->location, \"misplaced %<@%D%> Objective-C++ construct\",\n-\t       kwd->u.value);\n-      cp_parser_skip_to_end_of_block_or_statement (parser);\n-    }\n-\n-  return error_mark_node;\n-}\n-\n-/* If we are compiling ObjC++ and we see an __attribute__ we neeed to \n-   look ahead to see if an objc keyword follows the attributes.  This\n-   is to detect the use of prefix attributes on ObjC @interface and \n-   @protocol.  */\n-\n-static bool\n-cp_parser_objc_valid_prefix_attributes (cp_parser* parser, tree *attrib)\n-{\n-  cp_lexer_save_tokens (parser->lexer);\n-  *attrib = cp_parser_attributes_opt (parser);\n-  gcc_assert (*attrib);\n-  if (OBJC_IS_AT_KEYWORD (cp_lexer_peek_token (parser->lexer)->keyword))\n-    {\n-      cp_lexer_commit_tokens (parser->lexer);\n-      return true;\n-    }\n-  cp_lexer_rollback_tokens (parser->lexer);\n-  return false;  \n-}\n-\n-/* This routine is a minimal replacement for\n-   c_parser_struct_declaration () used when parsing the list of\n-   types/names or ObjC++ properties.  For example, when parsing the\n-   code\n-\n-   @property (readonly) int a, b, c;\n-\n-   this function is responsible for parsing \"int a, int b, int c\" and\n-   returning the declarations as CHAIN of DECLs.\n-\n-   TODO: Share this code with cp_parser_objc_class_ivars.  It's very\n-   similar parsing.  */\n-static tree\n-cp_parser_objc_struct_declaration (cp_parser *parser)\n-{\n-  tree decls = NULL_TREE;\n-  cp_decl_specifier_seq declspecs;\n-  int decl_class_or_enum_p;\n-  tree prefix_attributes;\n-\n-  cp_parser_decl_specifier_seq (parser,\n-\t\t\t\tCP_PARSER_FLAGS_NONE,\n-\t\t\t\t&declspecs,\n-\t\t\t\t&decl_class_or_enum_p);\n-\n-  if (declspecs.type == error_mark_node)\n-    return error_mark_node;\n-\n-  /* auto, register, static, extern, mutable.  */\n-  if (declspecs.storage_class != sc_none)\n-    {\n-      cp_parser_error (parser, \"invalid type for property\");\n-      declspecs.storage_class = sc_none;\n-    }\n-  \n-  /* __thread.  */\n-  if (declspecs.specs[(int) ds_thread])\n-    {\n-      cp_parser_error (parser, \"invalid type for property\");\n-      declspecs.specs[(int) ds_thread] = 0;\n-    }\n-  \n-  /* typedef.  */\n-  if (declspecs.specs[(int) ds_typedef])\n-    {\n-      cp_parser_error (parser, \"invalid type for property\");\n-      declspecs.specs[(int) ds_typedef] = 0;\n-    }\n-\n-  prefix_attributes = declspecs.attributes;\n-  declspecs.attributes = NULL_TREE;\n-\n-  /* Keep going until we hit the `;' at the end of the declaration. */\n-  while (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-    {\n-      tree attributes, first_attribute, decl;\n-      cp_declarator *declarator;\n-      cp_token *token;\n-\n-      /* Parse the declarator.  */\n-      declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n-\t\t\t\t\t NULL, NULL, false);\n-\n-      /* Look for attributes that apply to the ivar.  */\n-      attributes = cp_parser_attributes_opt (parser);\n-      /* Remember which attributes are prefix attributes and\n-\t which are not.  */\n-      first_attribute = attributes;\n-      /* Combine the attributes.  */\n-      attributes = chainon (prefix_attributes, attributes);\n-      \n-      decl = grokfield (declarator, &declspecs,\n-\t\t\tNULL_TREE, /*init_const_expr_p=*/false,\n-\t\t\tNULL_TREE, attributes);\n-\n-      if (decl == error_mark_node || decl == NULL_TREE)\n-\treturn error_mark_node;\n-      \n-      /* Reset PREFIX_ATTRIBUTES.  */\n-      while (attributes && TREE_CHAIN (attributes) != first_attribute)\n-\tattributes = TREE_CHAIN (attributes);\n-      if (attributes)\n-\tTREE_CHAIN (attributes) = NULL_TREE;\n-\n-      DECL_CHAIN (decl) = decls;\n-      decls = decl;\n-\n-      token = cp_lexer_peek_token (parser->lexer);\n-      if (token->type == CPP_COMMA)\n-\t{\n-\t  cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n-\t  continue;\n-\t}\n-      else\n-\tbreak;\n-    }\n-  return decls;\n-}\n-\n-/* Parse an Objective-C @property declaration.  The syntax is:\n-\n-   objc-property-declaration:\n-     '@property' objc-property-attributes[opt] struct-declaration ;\n-\n-   objc-property-attributes:\n-    '(' objc-property-attribute-list ')'\n-\n-   objc-property-attribute-list:\n-     objc-property-attribute\n-     objc-property-attribute-list, objc-property-attribute\n-\n-   objc-property-attribute\n-     'getter' = identifier\n-     'setter' = identifier\n-     'readonly'\n-     'readwrite'\n-     'assign'\n-     'retain'\n-     'copy'\n-     'nonatomic'\n-\n-  For example:\n-    @property NSString *name;\n-    @property (readonly) id object;\n-    @property (retain, nonatomic, getter=getTheName) id name;\n-    @property int a, b, c;\n-\n-   PS: This function is identical to\n-   c_parser_objc_at_property_declaration for C.  Keep them in sync.  */\n-static void \n-cp_parser_objc_at_property_declaration (cp_parser *parser)\n-{\n-  /* The following variables hold the attributes of the properties as\n-     parsed.  They are 'false' or 'NULL_TREE' if the attribute was not\n-     seen.  When we see an attribute, we set them to 'true' (if they\n-     are boolean properties) or to the identifier (if they have an\n-     argument, ie, for getter and setter).  Note that here we only\n-     parse the list of attributes, check the syntax and accumulate the\n-     attributes that we find.  objc_add_property_declaration() will\n-     then process the information.  */\n-  bool property_assign = false;\n-  bool property_copy = false;\n-  tree property_getter_ident = NULL_TREE;\n-  bool property_nonatomic = false;\n-  bool property_readonly = false;\n-  bool property_readwrite = false;\n-  bool property_retain = false;\n-  tree property_setter_ident = NULL_TREE;\n-\n-  /* 'properties' is the list of properties that we read.  Usually a\n-     single one, but maybe more (eg, in \"@property int a, b, c;\" there\n-     are three).  */\n-  tree properties;\n-  location_t loc;\n-\n-  loc = cp_lexer_peek_token (parser->lexer)->location;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@property'.  */\n-\n-  /* Parse the optional attribute list...  */\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n-    {\n-      /* Eat the '('.  */\n-      cp_lexer_consume_token (parser->lexer);\n-\n-      while (true)\n-\t{\n-\t  bool syntax_error = false;\n-\t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-      \t  enum rid keyword;\n-\n-\t  if (token->type != CPP_NAME)\n-\t    {\n-\t      cp_parser_error (parser, \"expected identifier\");\n-\t      break;\n-\t    }\n-\t  keyword = C_RID_CODE (token->u.value);\n-\t  cp_lexer_consume_token (parser->lexer);\n-\t  switch (keyword)\n-\t    {\n-\t    case RID_ASSIGN:    property_assign = true;    break;\n-\t    case RID_COPY:      property_copy = true;      break;\n-\t    case RID_NONATOMIC: property_nonatomic = true; break;\n-\t    case RID_READONLY:  property_readonly = true;  break;\n-\t    case RID_READWRITE: property_readwrite = true; break;\n-\t    case RID_RETAIN:    property_retain = true;    break;\n-\n-\t    case RID_GETTER:\n-\t    case RID_SETTER:\n-\t      if (cp_lexer_next_token_is_not (parser->lexer, CPP_EQ))\n-\t\t{\n-\t\t  if (keyword == RID_GETTER)\n-\t\t    cp_parser_error (parser,\n-\t\t\t\t     \"missing %<=%> (after %<getter%> attribute)\");\n-\t\t  else\n-\t\t    cp_parser_error (parser,\n-\t\t\t\t     \"missing %<=%> (after %<setter%> attribute)\");\n-\t\t  syntax_error = true;\n-\t\t  break;\n-\t\t}\n-\t      cp_lexer_consume_token (parser->lexer); /* eat the = */\n-\t      if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n-\t\t{\n-\t\t  cp_parser_error (parser, \"expected identifier\");\n-\t\t  syntax_error = true;\n-\t\t  break;\n-\t\t}\n-\t      if (keyword == RID_SETTER)\n-\t\t{\n-\t\t  if (property_setter_ident != NULL_TREE)\n-\t\t    cp_parser_error (parser, \"the %<setter%> attribute may only be specified once\");\n-\t\t  else\n-\t\t    property_setter_ident = cp_lexer_peek_token (parser->lexer)->u.value;\n-\t\t  cp_lexer_consume_token (parser->lexer);\n-\t\t  if (cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n-\t\t    cp_parser_error (parser, \"setter name must terminate with %<:%>\");\n-\t\t  else\n-\t\t    cp_lexer_consume_token (parser->lexer);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (property_getter_ident != NULL_TREE)\n-\t\t    cp_parser_error (parser, \"the %<getter%> attribute may only be specified once\");\n-\t\t  else\n-\t\t    property_getter_ident = cp_lexer_peek_token (parser->lexer)->u.value;\n-\t\t  cp_lexer_consume_token (parser->lexer);\n-\t\t}\n-\t      break;\n-\t    default:\n-\t      cp_parser_error (parser, \"unknown property attribute\");\n-\t      syntax_error = true;\n-\t      break;\n-\t    }\n-\n-\t  if (syntax_error)\n-\t    break;\n-\n-\t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n-\t    cp_lexer_consume_token (parser->lexer);\n-\t  else\n-\t    break;\n-\t}\n-\n-      /* FIXME: \"@property (setter, assign);\" will generate a spurious\n-\t \"error: expected \u2018)\u2019 before \u2018,\u2019 token\".  This is because\n-\t cp_parser_require, unlike the C counterpart, will produce an\n-\t error even if we are in error recovery.  */\n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n-\t{\n-\t  cp_parser_skip_to_closing_parenthesis (parser,\n-\t\t\t\t\t\t /*recovering=*/true,\n-\t\t\t\t\t\t /*or_comma=*/false,\n-\t\t\t\t\t\t /*consume_paren=*/true);\n-\t}\n-    }\n-\n-  /* ... and the property declaration(s).  */\n-  properties = cp_parser_objc_struct_declaration (parser);\n-\n-  if (properties == error_mark_node)\n-    {\n-      cp_parser_skip_to_end_of_statement (parser);\n-      /* If the next token is now a `;', consume it.  */\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n-\tcp_lexer_consume_token (parser->lexer);\n-      return;\n-    }\n-\n-  if (properties == NULL_TREE)\n-    cp_parser_error (parser, \"expected identifier\");\n-  else\n-    {\n-      /* Comma-separated properties are chained together in\n-\t reverse order; add them one by one.  */\n-      properties = nreverse (properties);\n-      \n-      for (; properties; properties = TREE_CHAIN (properties))\n-\tobjc_add_property_declaration (loc, copy_node (properties),\n-\t\t\t\t       property_readonly, property_readwrite,\n-\t\t\t\t       property_assign, property_retain,\n-\t\t\t\t       property_copy, property_nonatomic,\n-\t\t\t\t       property_getter_ident, property_setter_ident);\n-    }\n-  \n-  cp_parser_consume_semicolon_at_end_of_statement (parser);\n-}\n-\n-/* Parse an Objective-C++ @synthesize declaration.  The syntax is:\n-\n-   objc-synthesize-declaration:\n-     @synthesize objc-synthesize-identifier-list ;\n-\n-   objc-synthesize-identifier-list:\n-     objc-synthesize-identifier\n-     objc-synthesize-identifier-list, objc-synthesize-identifier\n-\n-   objc-synthesize-identifier\n-     identifier\n-     identifier = identifier\n-\n-  For example:\n-    @synthesize MyProperty;\n-    @synthesize OneProperty, AnotherProperty=MyIvar, YetAnotherProperty;\n-\n-  PS: This function is identical to c_parser_objc_at_synthesize_declaration\n-  for C.  Keep them in sync.\n-*/\n-static void \n-cp_parser_objc_at_synthesize_declaration (cp_parser *parser)\n-{\n-  tree list = NULL_TREE;\n-  location_t loc;\n-  loc = cp_lexer_peek_token (parser->lexer)->location;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@synthesize'.  */\n-  while (true)\n-    {\n-      tree property, ivar;\n-      property = cp_parser_identifier (parser);\n-      if (property == error_mark_node)\n-\t{\n-\t  cp_parser_consume_semicolon_at_end_of_statement (parser);\n-\t  return;\n-\t}\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_EQ))\n-\t{\n-\t  cp_lexer_consume_token (parser->lexer);\n-\t  ivar = cp_parser_identifier (parser);\n-\t  if (ivar == error_mark_node)\n-\t    {\n-\t      cp_parser_consume_semicolon_at_end_of_statement (parser);\n-\t      return;\n-\t    }\n-\t}\n-      else\n-\tivar = NULL_TREE;\n-      list = chainon (list, build_tree_list (ivar, property));\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n-\tcp_lexer_consume_token (parser->lexer);\n-      else\n-\tbreak;\n-    }\n-  cp_parser_consume_semicolon_at_end_of_statement (parser);\n-  objc_add_synthesize_declaration (loc, list);\n-}\n-\n-/* Parse an Objective-C++ @dynamic declaration.  The syntax is:\n-\n-   objc-dynamic-declaration:\n-     @dynamic identifier-list ;\n-\n-   For example:\n-     @dynamic MyProperty;\n-     @dynamic MyProperty, AnotherProperty;\n-\n-  PS: This function is identical to c_parser_objc_at_dynamic_declaration\n-  for C.  Keep them in sync.\n-*/\n-static void \n-cp_parser_objc_at_dynamic_declaration (cp_parser *parser)\n-{\n-  tree list = NULL_TREE;\n-  location_t loc;\n-  loc = cp_lexer_peek_token (parser->lexer)->location;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@dynamic'.  */\n-  while (true)\n-    {\n-      tree property;\n-      property = cp_parser_identifier (parser);\n-      if (property == error_mark_node)\n-\t{\n-\t  cp_parser_consume_semicolon_at_end_of_statement (parser);\n-\t  return;\n-\t}\n-      list = chainon (list, build_tree_list (NULL, property));\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n-\tcp_lexer_consume_token (parser->lexer);\n-      else\n-\tbreak;\n-    }\n-  cp_parser_consume_semicolon_at_end_of_statement (parser);\n-  objc_add_dynamic_declaration (loc, list);\n-}\n-\n-#endif"}, {"sha": "a8344543389e2b64d1463fdd65f97de171456137", "filename": "gcc/objcp/plugin/parser.h", "status": "removed", "additions": 0, "deletions": 227, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/975b975b29fa2aa9dd562a55006a4cd93421a652/gcc%2Fobjcp%2Fplugin%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/975b975b29fa2aa9dd562a55006a4cd93421a652/gcc%2Fobjcp%2Fplugin%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fplugin%2Fparser.h?ref=975b975b29fa2aa9dd562a55006a4cd93421a652", "patch": "@@ -1,227 +0,0 @@\n-/* Objective-C++ Parser plugin\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004,\n-   2005, 2007, 2008, 2009, 2010, 2011  Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-/* This isn't defined anywhere, yet, but it could be.  This will turn off\n-   the entire C++ Objective-C++ plugin.  */\n-#ifndef HIDE_OBJC\n-\n-#include \"c-family/c-objc.h\"\n-\n-\n-/* Objective-C++ Productions */\n-\n-static tree cp_parser_objc_message_receiver\n-  (cp_parser *);\n-static tree cp_parser_objc_message_args\n-  (cp_parser *);\n-static tree cp_parser_objc_message_expression\n-  (cp_parser *);\n-static tree cp_parser_objc_encode_expression\n-  (cp_parser *);\n-static tree cp_parser_objc_defs_expression\n-  (cp_parser *);\n-static tree cp_parser_objc_protocol_expression\n-  (cp_parser *);\n-static tree cp_parser_objc_selector_expression\n-  (cp_parser *);\n-static tree cp_parser_objc_expression\n-  (cp_parser *);\n-static bool cp_parser_objc_selector_p\n-  (enum cpp_ttype);\n-static tree cp_parser_objc_selector\n-  (cp_parser *);\n-static tree cp_parser_objc_protocol_refs_opt\n-  (cp_parser *);\n-static void cp_parser_objc_declaration\n-  (cp_parser *, tree);\n-static tree cp_parser_objc_statement\n-  (cp_parser *);\n-static bool cp_parser_objc_valid_prefix_attributes\n-  (cp_parser *, tree *);\n-static void cp_parser_objc_at_property_declaration \n-  (cp_parser *) ;\n-static void cp_parser_objc_at_synthesize_declaration \n-  (cp_parser *) ;\n-static void cp_parser_objc_at_dynamic_declaration\n-  (cp_parser *) ;\n-static tree cp_parser_objc_struct_declaration\n-  (cp_parser *) ;\n-\n-#define PLUGIN_PRIMARY_EXPRESSION_3(parser) @(\n-  do {\n-    if (c_dialect_objc ())\n-      /* We have an Objective-C++ message. */\n-      return cp_parser_objc_expression (parser);\n-  } while (0)@)\n-\n-#define PLUGIN_PRIMARY_EXPRESSION_2(parser, cp_parser_error) @(\n-  case CPP_OBJC_STRING:\n-    if (c_dialect_objc ())\n-      /* We have an Objective-C++ string literal. */\n-      return cp_parser_objc_expression (parser);\n-    cp_parser_error (parser, \"expected primary-expression\");\n-    return error_mark_node;@)\n-\n-#define PLUGIN_PRIMARY_EXPRESSION_1(parser) @(\n-  /* Objective-C++ expressions.  */\n-  case RID_AT_ENCODE:\n-  case RID_AT_PROTOCOL:\n-  case RID_AT_SELECTOR:\n-    return cp_parser_objc_expression (parser);@)\n-\n-#define PLUGIN_PRIMARY_EXPRESSION(parser, decl, cp_lexer_consume_token, cp_lexer_peek_token) @(\n-  do {\n-    /* In Objective-C++, we may have an Objective-C 2.0\n-       dot-syntax for classes here.  */\n-    if (c_dialect_objc ()\n-\t&& cp_lexer_peek_token (parser->lexer)->type == CPP_DOT\n-\t&& TREE_CODE (decl) == TYPE_DECL\n-\t&& objc_is_class_name (decl))\n-      {\n-\ttree component;\n-\tcp_lexer_consume_token (parser->lexer);\n-\tcomponent = cp_parser_identifier (parser);\n-\tif (component == error_mark_node)\n-\t  return error_mark_node;\n-\n-\treturn objc_build_class_component_ref (id_expression, component);\n-      }\n-\n-    /* In Objective-C++, an instance variable (ivar) may be preferred\n-       to whatever cp_parser_lookup_name() found.  */\n-    decl = objc_lookup_ivar (decl, id_expression);\n-  } while (0)@)\n-\n-#define PLUGIN_TOKEN_STARTS_CAST_EXPR @(\n-  do {\n-    /* '[' may start a primary-expression in obj-c++.  */\n-    return c_dialect_objc ();\n-  } while (0)@)\n-\n-#define PLUGIN_STATEMENT @(\n-  /* Objective-C++ exception-handling constructs.  */\n- case RID_AT_TRY:\n- case RID_AT_CATCH:\n- case RID_AT_FINALLY:\n- case RID_AT_SYNCHRONIZED:\n- case RID_AT_THROW:\n-   statement = cp_parser_objc_statement (parser);\n-   break;@)\n-\n-\n-#define PLUGIN_DECLARATION(token1, attributes) @(\n-  /* Objective-C++ declaration/definition.  */\n-  else if (c_dialect_objc () && OBJC_IS_AT_KEYWORD (token1.keyword))\n-    cp_parser_objc_declaration (parser, NULL_TREE);\n-  else if (c_dialect_objc ()\n-\t   && token1.keyword == RID_ATTRIBUTE\n-\t   && cp_parser_objc_valid_prefix_attributes (parser, &attributes))\n-    cp_parser_objc_declaration (parser, attributes);@)\n-\n-#define PLUGIN_SIMPLE_TYPE_SPECIFIER(parser, type, decl_specs)  @(\n-  do {\n-    /* See if TYPE is an Objective-C type, and if so, parse and\n-       accept any protocol references following it.  Do this before\n-       the cp_parser_check_for_invalid_template_id() call, because\n-       Objective-C types can be followed by '<...>' which would\n-       enclose protocol names rather than template arguments, and so\n-       everything is fine.  */\n-    if (c_dialect_objc () && !parser->scope\n-\t&& (objc_is_id (type) || objc_is_class_name (type)))\n-      {\n-\ttree protos = cp_parser_objc_protocol_refs_opt (parser);\n-\ttree qual_type = objc_get_protocol_qualified_type (type, protos);\n-\n-\t/* Clobber the \"unqualified\" type previously entered into\n-\t   DECL_SPECS with the new, improved protocol-qualified version.  */\n-\tif (decl_specs)\n-\t  decl_specs->type = qual_type;\n-\n-\treturn qual_type;\n-      }\n-  } while (0)@)\n-\n-\n-#define PLUGIN_NONCLASS_NAME1(parser, type_decl, identifier) @(\n-  do {\n-    if (TREE_CODE (type_decl) != TYPE_DECL\n-\t&& (objc_is_id (identifier) || objc_is_class_name (identifier)))\n-      {\n-\t/* See if this is an Objective-C type.  */\n-\ttree protos = cp_parser_objc_protocol_refs_opt (parser);\n-\ttree type = objc_get_protocol_qualified_type (identifier, protos);\n-\tif (type)\n-\t  type_decl = TYPE_NAME (type);\n-      }\n-  } while (0)@)\n-\n-#define PLUGIN_NONCLASS_NAME(parser, type_decl, cp_lexer_peek_token) @(\n-  /* In Objective-C, we have the complication that class names are\n-     normally type names and start declarations (eg, the\n-     \"NSObject\" in \"NSObject *object;\"), but can be used in an\n-     Objective-C 2.0 dot-syntax (as in \"NSObject.version\") which\n-     is an expression.  So, a classname followed by a dot is not a\n-     valid type-name.  */\n-  || (objc_is_class_name (TREE_TYPE (type_decl))\n-      && cp_lexer_peek_token (parser->lexer)->type == CPP_DOT)@)\n-\n-#define PLUGIN_CLASS_NAME(parser, cp_lexer_peek_token, CPP_DOT) @(\n-  /* In Objective-C 2.0, a classname followed by '.' starts a\n-     dot-syntax expression, and it's not a type-name.  */\n-  || (c_dialect_objc ()\n-      && cp_lexer_peek_token (parser->lexer)->type == CPP_DOT \n-      && objc_is_class_name (decl))@)\n-\n-#define PLUGIN_MEMBER_DECLARATION(parser, cp_lexer_next_token_is_keyword, finish_member_declaration) @(\n-  do {\n-    /* Check for @defs.  */\n-    if (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_DEFS))\n-      {\n-\ttree ivar, member;\n-\ttree ivar_chains = cp_parser_objc_defs_expression (parser);\n-\tivar = ivar_chains;\n-\twhile (ivar)\n-\t  {\n-\t    member = ivar;\n-\t    ivar = TREE_CHAIN (member);\n-\t    TREE_CHAIN (member) = NULL_TREE;\n-\t    finish_member_declaration (member);\n-\t  }\n-\treturn;\n-      }\n-  } while (0)@)\n-\n-#else\n-\n-#define PLUGIN_PRIMARY_EXPRESSION_3(parser)\n-#define PLUGIN_PRIMARY_EXPRESSION_2(parser, cp_parser_error)\n-#define PLUGIN_PRIMARY_EXPRESSION_1(parser)\n-#define PLUGIN_PRIMARY_EXPRESSION(parser, decl, cp_lexer_consume_token, cp_lexer_peek_token)\n-#define PLUGIN_TOKEN_STARTS_CAST_EXPR\n-#define PLUGIN_STATEMENT\n-#define PLUGIN_DECLARATION(token1, attributes)\n-#define PLUGIN_SIMPLE_TYPE_SPECIFIER(parser, type, decl_specs)\n-#define PLUGIN_NONCLASS_NAME1(parser, type_decl, identifier)\n-#define PLUGIN_NONCLASS_NAME(parser, type_decl, cp_lexer_peek_token) \n-#define PLUGIN_CLASS_NAME(parser, cp_lexer_peek_token, CPP_DOT)\n-#define PLUGIN_MEMBER_DECLARATION(parser, cp_lexer_next_token_is_keyword, finish_member_declaration)\n-\n-#endif"}]}