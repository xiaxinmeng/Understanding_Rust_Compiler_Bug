{"sha": "8f985ec4c7de63e524197f1728a2c056f9af6554", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY5ODVlYzRjN2RlNjNlNTI0MTk3ZjE3MjhhMmMwNTZmOWFmNjU1NA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@bitmover.com", "date": "1999-08-19T22:33:38Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "1999-08-19T22:33:38Z"}, "message": "rtl.def (NOTE): Change format to \"iuu0n\".\n\n1999-08-19 14:44 -0700  Zack Weinberg  <zack@bitmover.com>\n\n\t* rtl.def (NOTE): Change format to \"iuu0n\".\n\t(ADDR_DIFF_VEC): Change format to \"eEee0\".\n\t(ADDRESSOF): Change format to \"eit\".\n\n\t* rtl.h (rtvec): Make \"elem\" an array of rtx, not rtunion.\n\t(RTVEC_ELT): Change to match.\n\t(XVECEXP): Use XVEC and RTVEC_ELT.\n\t(INSN_UID, INSN_CODE, CODE_LABEL_NUMBER, NOTE_LINE_NUMBER,\n\tADDRESSOF_REGNO, REGNO, SUBREG_WORD): Use XINT.\n\t(PREV_INSN, NEXT_INSN, PATTERN, REG_NOTES,\n\tCALL_INSN_FUNCTION_USAGE, SUBREG_REG, SET_SRC, SET_DEST,\n\tTRAP_CONDITION, TRAP_CODE): Use XEXP.\n\t(INTVAL): Use XWINT.\n\t(ADDRESSOF_DECL): Use XTREE.\n\t(SET_ADDRESSOF_DECL): Delete.\n\t(NOTE_DECL_NAME, NOTE_DECL_CODE, NOTE_DECL_RTL,\n\tNOTE_DECL_IDENTIFIER, NOTE_DECL_TYPE): Kill.  These have been\n\tifdefed out since 2.6 at least.\n\t(gen_rtvec_vv): Delete prototype.\n\n\t* rtl.h (rtvec_alloc): rt->elem is now an array of rtx,\n\tnot rtunion.\n\t(copy_most_rtx): Handle 't' format letter.\n\t* emit-rtl.c (gen_rtvec_v): rt_val->elem is an array of rtx.\n\t(gen_rtvec_vv): Delete function.  All callers changed to use\n\tgen_rtvec_v instead.\n\t* print-rtl.c (print_rtx): Move special casing of NOTEs to\n\tthe '0' format letter.\n\n\t* function.c (gen_mem_addressof): Don't use\n\tSET_ADDRESSOF_DECL; provide `decl' to gen_rtx_ADDRESSOF\n\tinstead.\n\t* integrate.c (copy_rtx_and_substitute): Likewise.\n\tCopy 't' slots with XTREE.\n\t(subst_constants): Treat 't' slots like '[swi]' slots.\n\t* cse.c (canon_hash, exp_equiv_p): Treat 't' slots like\t'0' slots.\n\t* jump.c (rtx_equal_for_thread_p): Likewise.\n\t* rtlanal.c (rtx_equal_p): Likewise.\n\t* stmt.c (expand_end_case): gen_rtx_ADDR_DIFF_VEC now takes\n\tonly four arguments.\n\t* gengenrtl.c (type_from_format): Provide correct types for\n\t'b' and 't' slots.\n\n\n\t* tree.h [ENABLE_CHECKING] (TREE_CHECK, TREE_CLASS_CHECK):\n\tIf a recent gcc is in use (always in stage2 and beyond), use\n\tstatement expressions, so we don't make a function call unless\n\tthe check fails.  Evaluate arguments exactly once.\n\t(CHAIN_CHECK, DO_CHECK, DO_CHECK1, TREE_CHECK1,\n\tTREE_CLASS_CHECK1, TYPE_CHECK1, DECL_CHECK1, CST_CHECK1):\n\tDelete.\n\t(CST_OR_CONSTRUCTOR_CHECK, EXPR_CHECK): Redefine such that\n\tthey evaluate their arguments exactly once, irrespective of\n\tthe compiler in use.\n\n\t* tree.c [ENABLE_CHECKING]: Define whichever set of functions\n\tis used by the currently-enabled check macros.  This is:\n\t(tree_check_failed, tree_class_check_failed): For gcc.\n\t(tree_check, tree_class_check, cst_or_constructor_check,\n\texpr_check): For other compilers.\n\n\t* gencheck.c: Do not define any *_CHECK1 macros.\n\nFrom-SVN: r28769", "tree": {"sha": "7d2c04e895a06940acfa67236fcbdb23966207b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d2c04e895a06940acfa67236fcbdb23966207b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f985ec4c7de63e524197f1728a2c056f9af6554", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f985ec4c7de63e524197f1728a2c056f9af6554", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f985ec4c7de63e524197f1728a2c056f9af6554", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f985ec4c7de63e524197f1728a2c056f9af6554/comments", "author": null, "committer": null, "parents": [{"sha": "02af3af6514c82ca3bc75aa75b2774073f0ce602", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02af3af6514c82ca3bc75aa75b2774073f0ce602", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02af3af6514c82ca3bc75aa75b2774073f0ce602"}], "stats": {"total": 527, "additions": 324, "deletions": 203}, "files": [{"sha": "5a3bc478d4bf6d6b58b9463e9483782cd59ca778", "filename": "gcc/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f985ec4c7de63e524197f1728a2c056f9af6554", "patch": "@@ -1,3 +1,68 @@\n+1999-08-19 14:44 -0700  Zack Weinberg  <zack@bitmover.com>\n+\n+\t* rtl.def (NOTE): Change format to \"iuu0n\".\n+\t(ADDR_DIFF_VEC): Change format to \"eEee0\".\n+\t(ADDRESSOF): Change format to \"eit\".\n+\n+\t* rtl.h (rtvec): Make \"elem\" an array of rtx, not rtunion.\n+\t(RTVEC_ELT): Change to match.\n+\t(XVECEXP): Use XVEC and RTVEC_ELT.\n+\t(INSN_UID, INSN_CODE, CODE_LABEL_NUMBER, NOTE_LINE_NUMBER,\n+\tADDRESSOF_REGNO, REGNO, SUBREG_WORD): Use XINT.\n+\t(PREV_INSN, NEXT_INSN, PATTERN, REG_NOTES, \n+\tCALL_INSN_FUNCTION_USAGE, SUBREG_REG, SET_SRC, SET_DEST,\n+\tTRAP_CONDITION, TRAP_CODE): Use XEXP.\n+\t(INTVAL): Use XWINT.\n+\t(ADDRESSOF_DECL): Use XTREE.\n+\t(SET_ADDRESSOF_DECL): Delete.\n+\t(NOTE_DECL_NAME, NOTE_DECL_CODE, NOTE_DECL_RTL,\n+\tNOTE_DECL_IDENTIFIER, NOTE_DECL_TYPE): Kill.  These have been\n+\tifdefed out since 2.6 at least.\n+\t(gen_rtvec_vv): Delete prototype.\n+\n+\t* rtl.h (rtvec_alloc): rt->elem is now an array of rtx,\n+\tnot rtunion.\n+\t(copy_most_rtx): Handle 't' format letter.\n+\t* emit-rtl.c (gen_rtvec_v): rt_val->elem is an array of rtx.\n+\t(gen_rtvec_vv): Delete function.  All callers changed to use\n+\tgen_rtvec_v instead.\n+\t* print-rtl.c (print_rtx): Move special casing of NOTEs to \n+\tthe '0' format letter.\n+\n+\t* function.c (gen_mem_addressof): Don't use\n+\tSET_ADDRESSOF_DECL; provide `decl' to gen_rtx_ADDRESSOF\n+\tinstead.\n+\t* integrate.c (copy_rtx_and_substitute): Likewise.\n+\tCopy 't' slots with XTREE.\n+\t(subst_constants): Treat 't' slots like '[swi]' slots.\n+\t* cse.c (canon_hash, exp_equiv_p): Treat 't' slots like\t'0' slots.\n+\t* jump.c (rtx_equal_for_thread_p): Likewise.\n+\t* rtlanal.c (rtx_equal_p): Likewise.\n+\t* stmt.c (expand_end_case): gen_rtx_ADDR_DIFF_VEC now takes\n+\tonly four arguments.\n+\t* gengenrtl.c (type_from_format): Provide correct types for\n+\t'b' and 't' slots.\n+\n+\n+\t* tree.h [ENABLE_CHECKING] (TREE_CHECK, TREE_CLASS_CHECK):\n+\tIf a recent gcc is in use (always in stage2 and beyond), use\n+\tstatement expressions, so we don't make a function call unless\n+\tthe check fails.  Evaluate arguments exactly once.\n+\t(CHAIN_CHECK, DO_CHECK, DO_CHECK1, TREE_CHECK1,\n+\tTREE_CLASS_CHECK1, TYPE_CHECK1, DECL_CHECK1, CST_CHECK1):\n+\tDelete.\n+\t(CST_OR_CONSTRUCTOR_CHECK, EXPR_CHECK): Redefine such that\n+\tthey evaluate their arguments exactly once, irrespective of\n+\tthe compiler in use.\n+\n+\t* tree.c [ENABLE_CHECKING]: Define whichever set of functions\n+\tis used by the currently-enabled check macros.  This is:\n+\t(tree_check_failed, tree_class_check_failed): For gcc.\n+\t(tree_check, tree_class_check, cst_or_constructor_check,\n+\texpr_check): For other compilers.\n+\n+\t* gencheck.c: Do not define any *_CHECK1 macros.\n+\n Thu Aug 19 14:42:38 1999  Mike Stump <mrs@wrs.com>\n \t                  Mark Mitchell <mark@codesourcery.com>\n "}, {"sha": "8fe9040ddc02c8b962317adac011a004e4743307", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=8f985ec4c7de63e524197f1728a2c056f9af6554", "patch": "@@ -2261,7 +2261,7 @@ canon_hash (x, mode)\n \t  register unsigned tem = XINT (x, i);\n \t  hash += tem;\n \t}\n-      else if (fmt[i] == '0')\n+      else if (fmt[i] == '0' || fmt[i] == 't')\n \t/* unused */;\n       else\n \tabort ();\n@@ -2444,6 +2444,7 @@ exp_equiv_p (x, y, validate, equal_values)\n \tbreak;\n \n \tcase '0':\n+\tcase 't':\n \t  break;\n \n \tdefault:"}, {"sha": "b3c63b57cbc38120415ae523435ac1c4cf9d74e9", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=8f985ec4c7de63e524197f1728a2c056f9af6554", "patch": "@@ -455,29 +455,11 @@ gen_rtvec_v (n, argp)\n   rt_val = rtvec_alloc (n);\t/* Allocate an rtvec...\t\t\t*/\n \n   for (i = 0; i < n; i++)\n-    rt_val->elem[i].rtx = *argp++;\n+    rt_val->elem[i] = *argp++;\n \n   return rt_val;\n }\n \n-rtvec\n-gen_rtvec_vv (n, argp)\n-     int n;\n-     rtunion *argp;\n-{\n-  register int i;\n-  register rtvec rt_val;\n-\n-  if (n == 0)\n-    return NULL_RTVEC;\t\t/* Don't allocate an empty rtvec...\t*/\n-\n-  rt_val = rtvec_alloc (n);\t/* Allocate an rtvec...\t\t\t*/\n-\n-  for (i = 0; i < n; i++)\n-    rt_val->elem[i].rtx = (argp++)->rtx;\n-\n-  return rt_val;\n-}\n \f\n /* Generate a REG rtx for a new pseudo register of mode MODE.\n    This pseudo is assigned the next sequential register number.  */\n@@ -1761,7 +1743,7 @@ copy_rtx_if_shared (orig)\n \t      int len = XVECLEN (x, i);\n \n \t      if (copied && len > 0)\n-\t\tXVEC (x, i) = gen_rtvec_vv (len, XVEC (x, i)->elem);\n+\t\tXVEC (x, i) = gen_rtvec_v (len, XVEC (x, i)->elem);\n \t      for (j = 0; j < len; j++)\n \t\tXVECEXP (x, i, j) = copy_rtx_if_shared (XVECEXP (x, i, j));\n \t    }"}, {"sha": "e321cc5d05393f2f33d62175eb5aad71356ee090", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=8f985ec4c7de63e524197f1728a2c056f9af6554", "patch": "@@ -2630,8 +2630,8 @@ gen_mem_addressof (reg, decl)\n      tree decl;\n {\n   tree type = TREE_TYPE (decl);\n-  rtx r = gen_rtx_ADDRESSOF (Pmode, gen_reg_rtx (GET_MODE (reg)), REGNO (reg));\n-  SET_ADDRESSOF_DECL (r, decl);\n+  rtx r = gen_rtx_ADDRESSOF (Pmode, gen_reg_rtx (GET_MODE (reg)),\n+\t\t\t     REGNO (reg), decl);\n   /* If the original REG was a user-variable, then so is the REG whose\n      address is being taken.  */\n   REG_USERVAR_P (XEXP (r, 0)) = REG_USERVAR_P (reg);"}, {"sha": "11aed536bbfb1d0c8e6581cb85d57bc11dd36202", "filename": "gcc/gencheck.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Fgencheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Fgencheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgencheck.c?ref=8f985ec4c7de63e524197f1728a2c056f9af6554", "patch": "@@ -55,8 +55,6 @@ int main (argc, argv)\n     {\n       printf (\"#define %s_CHECK(t)\\tTREE_CHECK (t, %s)\\n\",\n \t      tree_codes[i], tree_codes[i]);\n-      printf (\"#define %s_CHECK1(t)\\tTREE_CHECK1 (t, %s)\\n\",\n-\t      tree_codes[i], tree_codes[i]);\n     }\n \n   return 0;"}, {"sha": "37bdd9cb0816ddc961fc03bc1f99cb458d30371e", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=8f985ec4c7de63e524197f1728a2c056f9af6554", "patch": "@@ -72,16 +72,10 @@ type_from_format (c)\n       return \"rtx\";\n     case 'E':\n       return \"rtvec\";\n-    /* ?!? These should be bitmap and tree respectively, but those types\n-       are not available in many of the files which include the output\n-       of gengenrtl.\n-\n-       These are only used in prototypes, so I think we can assume that\n-       void * is useable.  */\n     case 'b':\n-      return \"void *\";\n+      return \"struct bitmap_head_def *\";  /* bitmap - typedef not available */\n     case 't':\n-      return \"void *\";\n+      return \"union tree_node *\";  /* tree - typedef not available */\n     default:\n       abort ();\n     }"}, {"sha": "70f69feadf6c2345cbf16fe59a48cda1e9d4ab30", "filename": "gcc/integrate.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=8f985ec4c7de63e524197f1728a2c056f9af6554", "patch": "@@ -1233,7 +1233,7 @@ copy_for_inline (orig)\n \t    {\n \t      register int j;\n \n-\t      XVEC (x, i) = gen_rtvec_vv (XVECLEN (x, i), XVEC (x, i)->elem);\n+\t      XVEC (x, i) = gen_rtvec_v (XVECLEN (x, i), XVEC (x, i)->elem);\n \t      for (j = 0; j < XVECLEN (x, i); j++)\n \t\tXVECEXP (x, i, j)\n \t\t  = copy_for_inline (XVECEXP (x, i, j));\n@@ -2428,8 +2428,8 @@ copy_rtx_and_substitute (orig, map)\n \n     case ADDRESSOF:\n       copy = gen_rtx_ADDRESSOF (mode,\n-\t\t\tcopy_rtx_and_substitute (XEXP (orig, 0), map), 0);\n-      SET_ADDRESSOF_DECL (copy, ADDRESSOF_DECL (orig));\n+\t\t\t\tcopy_rtx_and_substitute (XEXP (orig, 0), map),\n+\t\t\t\t0, ADDRESSOF_DECL(orig));\n       regno = ADDRESSOF_REGNO (orig);\n       if (map->reg_map[regno])\n \tregno = REGNO (map->reg_map[regno]);\n@@ -2730,6 +2730,10 @@ copy_rtx_and_substitute (orig, map)\n \t  XSTR (copy, i) = XSTR (orig, i);\n \t  break;\n \n+\tcase 't':\n+\t  XTREE (copy, i) = XTREE (orig, i);\n+\t  break;\n+\n \tdefault:\n \t  abort ();\n \t}\n@@ -3002,6 +3006,7 @@ subst_constants (loc, insn, map)\n \tcase 'i':\n \tcase 's':\n \tcase 'w':\n+\tcase 't':\n \t  break;\n \n \tcase 'E':"}, {"sha": "35a70ca6a72596896c4063c6803858446b61adad", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=8f985ec4c7de63e524197f1728a2c056f9af6554", "patch": "@@ -5253,6 +5253,7 @@ rtx_equal_for_thread_p (x, y, yinsn)\n \t  break;\n \n \tcase '0':\n+\tcase 't':\n \t  break;\n \n \t  /* It is believed that rtx's at this level will never"}, {"sha": "a6349f38e8cfa7f29eac26c2a16b49efd425fed2", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 40, "deletions": 33, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=8f985ec4c7de63e524197f1728a2c056f9af6554", "patch": "@@ -146,38 +146,6 @@ print_rtx (in_rtx)\n       {\n       case 'S':\n       case 's':\n-\tif (i == 3 && GET_CODE (in_rtx) == NOTE\n-\t    && (NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_EH_REGION_BEG\n-\t\t|| NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_EH_REGION_END\n-\t\t|| NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_BLOCK_BEG\n-\t\t|| NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_BLOCK_END))\n-\t  {\n-\t    fprintf (outfile, \" %d\", NOTE_BLOCK_NUMBER (in_rtx));\n-\t    sawclose = 1;\n-\t    break;\n-\t  }\n-\n-\tif (i == 3 && GET_CODE (in_rtx) == NOTE\n-\t    && (NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_RANGE_START\n-\t\t|| NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_RANGE_END\n-\t\t|| NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_LIVE))\n-\t  {\n-\t    indent += 2;\n-\t    if (!sawclose)\n-\t      fprintf (outfile, \" \");\n-\t    print_rtx (NOTE_RANGE_INFO (in_rtx));\n-\t    indent -= 2;\n-\t    break;\n-\t  }\n-\n-\tif (i == 3 && GET_CODE (in_rtx) == NOTE\n-\t    && NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_BASIC_BLOCK)\n-\t  {\n-\t    basic_block bb = NOTE_BASIC_BLOCK (in_rtx);\n-\t    fprintf (outfile, \" [bb %d]\", bb->index);\n-\t    break;\n-\t  }\n-\n \tif (XSTR (in_rtx, i) == 0)\n \t  fputs (dump_for_graph ? \" \\\\\\\"\\\\\\\"\" : \" \\\"\\\"\", outfile);\n \telse\n@@ -186,8 +154,47 @@ print_rtx (in_rtx)\n \tsawclose = 1;\n \tbreak;\n \n-\t/* 0 indicates a field for internal use that should not be printed.  */\n+\t/* 0 indicates a field for internal use that should not be printed.\n+\t   An exception is the third field of a NOTE, where it indicates\n+\t   that the field has several different valid contents.  */\n       case '0':\n+\tif (i == 3 && GET_CODE (in_rtx) == NOTE)\n+\t  {\n+\t    if (NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_EH_REGION_BEG\n+\t\t|| NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_EH_REGION_END\n+\t\t|| NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_BLOCK_BEG\n+\t\t|| NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_BLOCK_END)\n+\t      {\n+\t\tfprintf (outfile, \" %d\", NOTE_BLOCK_NUMBER (in_rtx));\n+\t\tsawclose = 1;\n+\t      }\n+\t    else if (NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_RANGE_START\n+\t\t     || NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_RANGE_END\n+\t\t     || NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_LIVE)\n+\t      {\n+\t\tindent += 2;\n+\t\tif (!sawclose)\n+\t\t  fprintf (outfile, \" \");\n+\t\tprint_rtx (NOTE_RANGE_INFO (in_rtx));\n+\t\tindent -= 2;\n+\t      }\n+\t    else if (NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_BASIC_BLOCK)\n+\t      {\n+\t\tbasic_block bb = NOTE_BASIC_BLOCK (in_rtx);\n+\t\tfprintf (outfile, \" [bb %d]\", bb->index);\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* Can't use XSTR because of type checking.  */\n+\t\tchar *str = in_rtx->fld[i].rtstr;\n+\t\tif (str == 0)\n+\t\t  fputs (dump_for_graph ? \" \\\\\\\"\\\\\\\"\" : \" \\\"\\\"\", outfile);\n+\t\telse\n+\t\t  fprintf (outfile,\n+\t\t\t   dump_for_graph ? \" (\\\\\\\"%s\\\\\\\")\" : \" (\\\"%s\\\")\",\n+\t\t\t   str);\n+\t      }\n+\t  }\n \tbreak;\n \n       case 'e':"}, {"sha": "e4bda8b31695d820c77f00344b3b0c0575573898", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=8f985ec4c7de63e524197f1728a2c056f9af6554", "patch": "@@ -3225,8 +3225,8 @@ eliminate_regs (x, mem_mode, insn)\n \t      new = eliminate_regs (XVECEXP (x, i, j), mem_mode, insn);\n \t      if (new != XVECEXP (x, i, j) && ! copied_vec)\n \t\t{\n-\t\t  rtvec new_v = gen_rtvec_vv (XVECLEN (x, i),\n-\t\t\t\t\t      XVEC (x, i)->elem);\n+\t\t  rtvec new_v = gen_rtvec_v (XVECLEN (x, i),\n+\t\t\t\t\t     XVEC (x, i)->elem);\n \t\t  if (! copied)\n \t\t    {\n \t\t      rtx new_x = rtx_alloc (code);"}, {"sha": "89f800ab8d09c67c70213c514fb8d11ab361c687", "filename": "gcc/rtl.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=8f985ec4c7de63e524197f1728a2c056f9af6554", "patch": "@@ -212,13 +212,13 @@ rtvec_alloc (n)\n \n   rt = (rtvec) obstack_alloc (rtl_obstack,\n \t\t\t      sizeof (struct rtvec_def)\n-\t\t\t      + (( n - 1) * sizeof (rtunion)));\n+\t\t\t      + (( n - 1) * sizeof (rtx)));\n \n   /* clear out the vector */\n   PUT_NUM_ELEM (rt, n);\n \n   for (i = 0; i < n; i++)\n-    rt->elem[i].rtwint = 0;\n+    rt->elem[i] = 0;\n \n   return rt;\n }\n@@ -477,6 +477,10 @@ copy_most_rtx (orig, may_share)\n \t  XINT (copy, i) = XINT (orig, i);\n \t  break;\n \n+\tcase 't':\n+\t  XTREE (copy, i) = XTREE (orig, i);\n+\t  break;\n+\n \tcase 's':\n \tcase 'S':\n \t  XSTR (copy, i) = XSTR (orig, i);"}, {"sha": "4a8e8d6fa1b0734479d28c531e15e5725f54cb05", "filename": "gcc/rtl.def", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=8f985ec4c7de63e524197f1728a2c056f9af6554", "patch": "@@ -390,7 +390,7 @@ DEF_RTL_EXPR(CODE_LABEL, \"code_label\", \"iuuis00\", 'x')\n       are really changed to NOTEs with a number of -1.\n    -2 means beginning of a name binding contour; output N_LBRAC.\n    -3 means end of a contour; output N_RBRAC.  */\n-DEF_RTL_EXPR(NOTE, \"note\", \"iuusn\", 'x')\n+DEF_RTL_EXPR(NOTE, \"note\", \"iuu0n\", 'x')\n \n /* ----------------------------------------------------------------------\n    Top level constituents of INSN, JUMP_INSN and CALL_INSN.\n@@ -462,7 +462,7 @@ DEF_RTL_EXPR(ADDR_VEC, \"addr_vec\", \"E\", 'x')\n    CASE_VECTOR_SHORTEN_MODE is defined, and only in an optimizing\n    compilations.  */\n      \n-DEF_RTL_EXPR(ADDR_DIFF_VEC, \"addr_diff_vec\", \"eEeei\", 'x')\n+DEF_RTL_EXPR(ADDR_DIFF_VEC, \"addr_diff_vec\", \"eEee0\", 'x')\n \n /* ----------------------------------------------------------------------\n    At the top level of an instruction (perhaps under PARALLEL).\n@@ -610,7 +610,7 @@ DEF_RTL_EXPR(CC0, \"cc0\", \"\", 'o')\n    3rd operand: the decl for the object in the register, for\n      put_reg_in_stack.  */\n \n-DEF_RTL_EXPR(ADDRESSOF, \"addressof\", \"ei0\", 'o')\n+DEF_RTL_EXPR(ADDRESSOF, \"addressof\", \"eit\", 'o')\n \n /* =====================================================================\n    A QUEUED expression really points to a member of the queue of instructions"}, {"sha": "00abb021f82b203e62adb4190dfa7761d0e8827e", "filename": "gcc/rtl.h", "status": "modified", "additions": 35, "deletions": 43, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=8f985ec4c7de63e524197f1728a2c056f9af6554", "patch": "@@ -200,16 +200,14 @@ typedef struct rtx_def\n \n typedef struct rtvec_def{\n   int num_elem;\t\t/* number of elements */\n-  rtunion elem[1];\n+  struct rtx_def *elem[1];\n } *rtvec;\n \n #define NULL_RTVEC (rtvec) 0\n \n #define GET_NUM_ELEM(RTVEC)\t\t((RTVEC)->num_elem)\n #define PUT_NUM_ELEM(RTVEC, NUM)\t((RTVEC)->num_elem = (NUM))\n \n-#define RTVEC_ELT(RTVEC, I)  ((RTVEC)->elem[(I)].rtx)\n-\n /* 1 if X is a REG.  */\n \n #define REG_P(X) (GET_CODE (X) == REG)\n@@ -224,40 +222,44 @@ typedef struct rtvec_def{\n \n /* General accessor macros for accessing the fields of an rtx.  */\n \n-#define XEXP(RTX, N)\t((RTX)->fld[N].rtx)\n-#define XINT(RTX, N)\t((RTX)->fld[N].rtint)\n-#define XWINT(RTX, N)\t((RTX)->fld[N].rtwint)\n-#define XSTR(RTX, N)\t((RTX)->fld[N].rtstr)\n-#define XVEC(RTX, N)\t((RTX)->fld[N].rtvec)\n-#define XVECLEN(RTX, N)\t((RTX)->fld[N].rtvec->num_elem)\n-#define XVECEXP(RTX,N,M)((RTX)->fld[N].rtvec->elem[M].rtx)\n-#define XBITMAP(RTX, N) ((RTX)->fld[N].rtbit)\n-#define XTREE(RTX, N)   ((RTX)->fld[N].rttree)\n+#define XWINT(RTX, N)\t((RTX)->fld[N].rtwint)\t\t\t/* w */\n+#define XINT(RTX, N)\t((RTX)->fld[N].rtint)\t\t\t/* i,n */\n+#define XSTR(RTX, N)\t((RTX)->fld[N].rtstr)\t\t\t/* s,S */\n+#define XEXP(RTX, N)\t((RTX)->fld[N].rtx)\t\t\t/* e,u */\n+#define XVEC(RTX, N)\t((RTX)->fld[N].rtvec)\t\t\t/* E,V */\n+#define XVECLEN(RTX, N)\t((RTX)->fld[N].rtvec->num_elem)\t\t/* E,V */\n+#define XMODE(RTX, N)\t((RTX)->fld[N].rttype)\t\t\t/* M */\n+#define XBITMAP(RTX, N) ((RTX)->fld[N].rtbit)\t\t\t/* b */\n+#define XTREE(RTX, N)   ((RTX)->fld[N].rttree)\t\t\t/* t */\n+#define XBBDEF(RTX, N)\t((RTX)->fld[N].bb)\t\t\t/* B */\n+\n+#define RTVEC_ELT(RTVEC, I)\t((RTVEC)->elem[I])\n+#define XVECEXP(RTX,N,M)\tRTVEC_ELT (XVEC (RTX, N), M)\n \n \f\n /* ACCESS MACROS for particular fields of insns.  */\n \n /* Holds a unique number for each insn.\n    These are not necessarily sequentially increasing.  */\n-#define INSN_UID(INSN)\t((INSN)->fld[0].rtint)\n+#define INSN_UID(INSN)  XINT(INSN, 0)\n \n /* Chain insns together in sequence.  */\n-#define PREV_INSN(INSN)\t((INSN)->fld[1].rtx)\n-#define NEXT_INSN(INSN)\t((INSN)->fld[2].rtx)\n+#define PREV_INSN(INSN)\tXEXP(INSN, 1)\n+#define NEXT_INSN(INSN)\tXEXP(INSN, 2)\n \n /* The body of an insn.  */\n-#define PATTERN(INSN)\t((INSN)->fld[3].rtx)\n+#define PATTERN(INSN)\tXEXP(INSN, 3)\n \n /* Code number of instruction, from when it was recognized.\n    -1 means this instruction has not been recognized yet.  */\n-#define INSN_CODE(INSN) ((INSN)->fld[4].rtint)\n+#define INSN_CODE(INSN) XINT(INSN, 4)\n \n /* Set up in flow.c; empty before then.\n    Holds a chain of INSN_LIST rtx's whose first operands point at\n    previous insns with direct data-flow connections to this one.\n    That means that those insns set variables whose next use is in this insn.\n    They are always in the same basic block as this insn.  */\n-#define LOG_LINKS(INSN)\t\t((INSN)->fld[5].rtx)\n+#define LOG_LINKS(INSN)\tXEXP(INSN, 5)\n \n /* 1 if insn has been deleted.  */\n #define INSN_DELETED_P(INSN) ((INSN)->volatil)\n@@ -353,7 +355,7 @@ typedef struct rtvec_def{\n    non standard flow edges required for a rethrow. */\n    \n \n-#define REG_NOTES(INSN)\t((INSN)->fld[6].rtx)\n+#define REG_NOTES(INSN)\tXEXP(INSN, 6)\n \n #define ADDR_DIFF_VEC_FLAGS(RTX) ((RTX)->fld[4].rt_addr_diff_vec_flags)\n \n@@ -386,12 +388,12 @@ extern char *reg_note_name[];\n      CLOBBER expressions document the registers explicitly clobbered\n    by this CALL_INSN.\n      Pseudo registers can not be mentioned in this list.  */\n-#define CALL_INSN_FUNCTION_USAGE(INSN)\t((INSN)->fld[7].rtx)\n+#define CALL_INSN_FUNCTION_USAGE(INSN)\tXEXP(INSN, 7)\n \n /* The label-number of a code-label.  The assembler label\n    is made from `L' and the label-number printed in decimal.\n    Label numbers are unique in a compilation.  */\n-#define CODE_LABEL_NUMBER(INSN)\t((INSN)->fld[3].rtint)\n+#define CODE_LABEL_NUMBER(INSN)\tXINT(INSN, 3)\n \n #define LINE_NUMBER NOTE\n \n@@ -414,7 +416,7 @@ extern char *reg_note_name[];\n \n /* In a NOTE that is a line number, this is the line number.\n    Other kinds of NOTEs are identified by negative numbers here.  */\n-#define NOTE_LINE_NUMBER(INSN) ((INSN)->fld[4].rtint)\n+#define NOTE_LINE_NUMBER(INSN) XINT(INSN, 4)\n \n /* Codes that appear in the NOTE_LINE_NUMBER field\n    for kinds of notes that are not line numbers.\n@@ -475,33 +477,24 @@ extern char *reg_note_name[];\n /* Record the struct for the following basic block.  */\n #define NOTE_INSN_BASIC_BLOCK -20\n \n-#if 0 /* These are not used, and I don't know what they were for. --rms.  */\n-#define NOTE_DECL_NAME(INSN) ((INSN)->fld[3].rtstr)\n-#define NOTE_DECL_CODE(INSN) ((INSN)->fld[4].rtint)\n-#define NOTE_DECL_RTL(INSN) ((INSN)->fld[5].rtx)\n-#define NOTE_DECL_IDENTIFIER(INSN) ((INSN)->fld[6].rtint)\n-#define NOTE_DECL_TYPE(INSN) ((INSN)->fld[7].rtint)\n-#endif /* 0 */\n-\n /* Names for NOTE insn's other than line numbers.  */\n \n extern char *note_insn_name[];\n #define GET_NOTE_INSN_NAME(NOTE_CODE) (note_insn_name[-(NOTE_CODE)])\n \n /* The name of a label, in case it corresponds to an explicit label\n    in the input source code.  */\n-#define LABEL_NAME(LABEL) ((LABEL)->fld[4].rtstr)\n+#define LABEL_NAME(LABEL) XSTR(LABEL, 4)\n \n /* In jump.c, each label contains a count of the number\n    of LABEL_REFs that point at it, so unused labels can be deleted.  */\n #define LABEL_NUSES(LABEL) ((LABEL)->fld[5].rtint)\n \n /* The original regno this ADDRESSOF was built for.  */\n-#define ADDRESSOF_REGNO(RTX) ((RTX)->fld[1].rtint)\n+#define ADDRESSOF_REGNO(RTX) XINT(RTX, 1)\n \n /* The variable in the register we took the address of.  */\n-#define ADDRESSOF_DECL(X) ((tree) XEXP ((X), 2))\n-#define SET_ADDRESSOF_DECL(X, T) (XEXP ((X), 2) = (rtx) (T))\n+#define ADDRESSOF_DECL(RTX) XTREE(RTX, 2)\n \n /* In jump.c, each JUMP_INSN can point to a label that it can jump to,\n    so that if the JUMP_INSN is deleted, the label's LABEL_NUSES can\n@@ -527,7 +520,7 @@ extern char *note_insn_name[];\n \n /* For a REG rtx, REGNO extracts the register number.  */\n \n-#define REGNO(RTX) ((RTX)->fld[0].rtint)\n+#define REGNO(RTX) XINT(RTX, 0)\n \n /* For a REG rtx, REG_FUNCTION_VALUE_P is nonzero if the reg\n    is the current function's return value.  */\n@@ -539,13 +532,13 @@ extern char *note_insn_name[];\n \n /* For a CONST_INT rtx, INTVAL extracts the integer.  */\n \n-#define INTVAL(RTX) ((RTX)->fld[0].rtwint)\n+#define INTVAL(RTX) XWINT(RTX, 0)\n \n /* For a SUBREG rtx, SUBREG_REG extracts the value we want a subreg of.\n    SUBREG_WORD extracts the word-number.  */\n \n-#define SUBREG_REG(RTX) ((RTX)->fld[0].rtx)\n-#define SUBREG_WORD(RTX) ((RTX)->fld[1].rtint)\n+#define SUBREG_REG(RTX) XEXP(RTX, 0)\n+#define SUBREG_WORD(RTX) XINT(RTX, 1)\n \n /* 1 if the REG contained in SUBREG_REG is already known to be\n    sign- or zero-extended from the mode of the SUBREG to the mode of\n@@ -640,12 +633,12 @@ extern char *note_insn_name[];\n \n /* For a SET rtx, SET_DEST is the place that is set\n    and SET_SRC is the value it is set to.  */\n-#define SET_DEST(RTX) ((RTX)->fld[0].rtx)\n-#define SET_SRC(RTX) ((RTX)->fld[1].rtx)\n+#define SET_DEST(RTX) XEXP(RTX, 0)\n+#define SET_SRC(RTX) XEXP(RTX, 1)\n \n /* For a TRAP_IF rtx, TRAP_CONDITION is an expression.  */\n-#define TRAP_CONDITION(RTX) ((RTX)->fld[0].rtx)\n-#define TRAP_CODE(RTX) (RTX)->fld[1].rtx\n+#define TRAP_CONDITION(RTX) XEXP(RTX, 0)\n+#define TRAP_CODE(RTX) XEXP(RTX, 1)\n \n /* 1 in a SYMBOL_REF if it addresses this function's constants pool.  */\n #define CONSTANT_POOL_ADDRESS_P(RTX) ((RTX)->unchanging)\n@@ -870,7 +863,6 @@ extern rtx copy_rtx_if_shared\t\tPROTO((rtx));\n extern rtx copy_most_rtx\t\tPROTO((rtx, rtx));\n extern rtx shallow_copy_rtx\t\tPROTO((rtx));\n extern rtvec gen_rtvec_v\t\tPROTO((int, rtx *));\n-extern rtvec gen_rtvec_vv\t\tPROTO((int, rtunion *));\n extern rtx gen_reg_rtx\t\t\tPROTO((enum machine_mode));\n extern rtx gen_label_rtx\t\tPROTO((void));\n extern rtx gen_lowpart_common\t\tPROTO((enum machine_mode, rtx));"}, {"sha": "a7d335be5599b06623c3fe4cc540b0e82e879dee", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=8f985ec4c7de63e524197f1728a2c056f9af6554", "patch": "@@ -1161,6 +1161,7 @@ rtx_equal_p (x, y)\n \t  break;\n \n \tcase '0':\n+\tcase 't':\n \t  break;\n \n \t  /* It is believed that rtx's at this level will never"}, {"sha": "97afc4e7c65c07b8c3db5ba0ef274a2d25fab8ca", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=8f985ec4c7de63e524197f1728a2c056f9af6554", "patch": "@@ -5348,7 +5348,7 @@ expand_end_case (orig_index)\n \t    emit_jump_insn (gen_rtx_ADDR_DIFF_VEC (CASE_VECTOR_MODE,\n \t\t\t\t\t\t   gen_rtx_LABEL_REF (Pmode, table_label),\n \t\t\t\t\t\t   gen_rtvec_v (ncases, labelvec),\n-\t\t\t\t\t\t    const0_rtx, const0_rtx, 0));\n+\t\t\t\t\t\t    const0_rtx, const0_rtx));\n \t  else\n \t    emit_jump_insn (gen_rtx_ADDR_VEC (CASE_VECTOR_MODE,\n \t\t\t\t\t      gen_rtvec_v (ncases, labelvec)));"}, {"sha": "123a3cece8275ea4ce788574175e64c3f3df2c0e", "filename": "gcc/tree.c", "status": "modified", "additions": 82, "deletions": 51, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=8f985ec4c7de63e524197f1728a2c056f9af6554", "patch": "@@ -5077,81 +5077,112 @@ get_set_constructor_bytes (init, buffer, wd_size)\n \f\n #ifdef ENABLE_CHECKING\n \n-/* Complain if the tree code does not match the expected one.\n-   NODE is the tree node in question, CODE is the expected tree code,\n-   and FILE and LINE are the filename and line number, respectively,\n-   of the line on which the check was done.  If NONFATAL is nonzero,\n-   don't abort if the reference is invalid; instead, return 0.\n-   If the reference is valid, return NODE.  */\n+#if defined __GNUC__ && (__GNUC__ > 2 || __GNUC_MINOR__ > 6)\n \n-tree\n-tree_check (node, code, file, line, nofatal)\n-     tree node;\n+/* Complain that the tree code of NODE does not match the expected CODE.\n+   FILE, LINE, and FUNCTION are of the caller.\n+\n+   FIXME: should print the blather about reporting the bug. */\n+void\n+tree_check_failed (node, code, file, line, function)\n+     const tree node;\n      enum tree_code code;\n      const char *file;\n      int line;\n-     int nofatal;\n+     const char *function;\n {\n-  if (TREE_CODE (node) == code)\n-    return node;\n-  else if (nofatal)\n-    return 0;\n-  else\n-    fatal (\"%s:%d: Expect %s, have %s\\n\", file, line,\n-\t   tree_code_name[code], tree_code_name[TREE_CODE (node)]);\n+  fatal (\"Internal compiler error in `%s', at %s:%d:\\n\\\n+\\texpected %s, have %s\\n\",\n+\t function, trim_filename (file), line,\n+\t tree_code_name[code], tree_code_name[TREE_CODE (node)]);\n }\n \n /* Similar to above, except that we check for a class of tree\n    code, given in CL.  */\n-\n-tree\n-tree_class_check (node, cl, file, line, nofatal)\n-     tree node;\n+void\n+tree_class_check_failed (node, cl, file, line, function)\n+     const tree node;\n      char cl;\n      const char *file;\n      int line;\n-     int nofatal;\n+     const char *function;\n {\n-  if (TREE_CODE_CLASS (TREE_CODE (node)) == cl)\n+  fatal (\"Internal compiler error in `%s', at %s:%d:\\n\\\n+\\texpected '%c', have '%c' (%s)\\n\",\n+\t function, trim_filename (file), line, cl,\n+\t TREE_CODE_CLASS (TREE_CODE (node)),\n+\t tree_code_name[TREE_CODE (node)]);\n+}\n+\n+#else /* not gcc or old gcc */\n+\n+/* These functions are just like the above, but they have to\n+   do the check as well as report the error.  */\n+tree\n+tree_check (node, code, file, line)\n+     const tree node;\n+     enum tree_code code;\n+     const char *file;\n+     int line;\n+{\t\n+  if (TREE_CODE (node) == code)\n     return node;\n-  else if (nofatal)\n-    return 0;\n-  else\n-    fatal (\"%s:%d: Expect '%c', have '%s'\\n\", file, line,\n-\t   cl, tree_code_name[TREE_CODE (node)]);\n+\n+  fatal (\"Internal compiler error at %s:%d:\\n\\texpected %s, have %s\\n\",\n+\t file, trim_filename (file), tree_code_name[code], tree_code_name[TREE_CODE(node)]);\n }\n \n-/* Likewise, but complain if the tree node is not an expression.  */\n+tree\n+tree_class_check (node, class, file, line)\n+     const tree node;\n+     char class;\n+     const char *file;\n+     int line;\n+{\t\n+  if (TREE_CODE_CLASS (TREE_CODE (node)) == class)\n+    return node;\n+\n+  fatal (\"Internal compiler error at %s:%d:\\n\\\n+\\texpected '%c', have '%c' (%s)\\n\",\n+\t file, trim_filename (file), class, TREE_CODE_CLASS (TREE_CODE (node)),\n+\t tree_code_name[TREE_CODE(node)]);\n+}\n \n tree\n-expr_check (node, ignored, file, line, nofatal)\n-     tree node;\n-     int ignored;\n+cst_or_constructor_check (node, file, line)\n+     const tree node;\n      const char *file;\n      int line;\n-     int nofatal;\n {\n-  switch (TREE_CODE_CLASS (TREE_CODE (node)))\n-    {\n-    case 'r':\n-    case 's':\n-    case 'e':\n-    case '<':\n-    case '1':\n-    case '2':\n-      break;\n+  enum tree_code code = TREE_CODE (node);\n+  \n+  if (code == CONSTRUCTOR || TREE_CODE_CLASS (code) == 'c')\n+    return node;\n \n-    default:\n-      if (nofatal)\n-\treturn 0;\n-      else\n-\tfatal (\"%s:%d: Expect expression, have '%s'\\n\", file, line,\n-\t       tree_code_name[TREE_CODE (node)]);\n-    }\n+  fatal (\"Internal compiler error at %s:%d:\\n\\\n+\\texpected constructor, have %s\\n\",\n+\t file, line, tree_code_name[code]);\n+}\n \n-  return node;\n+tree\n+cst_or_constructor_check (node, file, line)\n+     const tree node;\n+     const char *file;\n+     int line;\n+{\n+  char c = TREE_CODE_CLASS (TREE_CODE (node));\n+\n+  if (c == 'r' || c == 's' || c == '<'\n+      || c == '1' || c == '2' || c == 'e')\n+    return node;\n+\n+  fatal (\"Internal compiler error at %s:%d:\\n\\\n+\\texpected 'e', have '%c' (%s)\\n\",\n+\t file, trim_filename (file), c, tree_code_name[TREE_CODE (node)]);\n }\n-#endif\n+\n+#endif /* not gcc or old gcc */\n+#endif /* ENABLE_CHECKING */\n \n /* Return the alias set for T, which may be either a type or an\n    expression.  */"}, {"sha": "3777d0e82457169cdce0839d51ad82cc3157f9b1", "filename": "gcc/tree.h", "status": "modified", "additions": 72, "deletions": 32, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f985ec4c7de63e524197f1728a2c056f9af6554/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8f985ec4c7de63e524197f1728a2c056f9af6554", "patch": "@@ -311,38 +311,84 @@ struct tree_common\n #define TREE_SET_CODE(NODE, VALUE) ((NODE)->common.code = (int) (VALUE))\n \n /* When checking is enabled, errors will be generated if a tree node\n-   is accessed incorrectly. The macros abort with a fatal error,\n-   except for the *1 variants, which just return 0 on failure.  The\n-   latter variants should only be used for combination checks, which\n-   succeed when one of the checks succeed. The CHAIN_CHECK macro helps\n-   defining such checks.  */\n+   is accessed incorrectly. The macros abort with a fatal error.  */\n \n #ifdef ENABLE_CHECKING\n-#define DO_CHECK(FUNC, t, param)   FUNC (t, param, __FILE__, __LINE__, 0)\n-#define DO_CHECK1(FUNC, t, param)  FUNC (t, param, __FILE__, __LINE__, 1)\n-#define CHAIN_CHECK(t, c1, c2)     (c1 (t) ? t : c2 (t))\n-#else\n-#define DO_CHECK(FUNC, t, param)   (t)\n-#define DO_CHECK1(FUNC, t, param)  (t)\n-#define CHAIN_CHECK(t, c1, c2)     (t)\n-#endif\n \n-#define TREE_CHECK(t, code)        DO_CHECK (tree_check, t, code)\n-#define TREE_CHECK1(t, code)       DO_CHECK1 (tree_check, t, code)\n+#if defined __GNUC__ && (__GNUC__ > 2 || __GNUC_MINOR__ > 6)\n+/* This optimization can only be done in stage2/3, because it\n+   uses statement expressions.  You might think that you could use\n+   conditional (?:) expressions, but you would be wrong: these macros\n+   need to evaluate `t' only once.  */\n+#define TREE_CHECK(t, code)\t\t\t\t\t\t\\\n+({  const tree __t = t;\t\t\t\t\t\t\t\\\n+    if (TREE_CODE(__t) != (code))\t\t\t\t\t\\\n+      tree_check_failed (__t, code, __FILE__,\t\t\t\t\\\n+\t\t\t __LINE__, __PRETTY_FUNCTION__);\t\t\\\n+    __t; })\n+#define TREE_CLASS_CHECK(t, class)\t\t\t\t\t\\\n+({  const tree __t = t;\t\t\t\t\t\t\t\\\n+    if (TREE_CODE_CLASS(TREE_CODE(__t)) != (class))\t\t\t\\\n+      tree_class_check_failed (__t, class, __FILE__,\t\t\t\\\n+\t\t\t       __LINE__, __PRETTY_FUNCTION__);\t\t\\\n+    __t; })\n+\n+/* These checks have to be special cased.  */\n+#define CST_OR_CONSTRUCTOR_CHECK(t)\t\t\t\t\t\\\n+({  const tree __t = t;\t\t\t\t\t\t\t\\\n+    enum tree_code __c = TREE_CODE(__t);\t\t\t\t\\\n+    if (__c != CONSTRUCTOR && TREE_CODE_CLASS(__c) != 'c')\t\t\\\n+      tree_check_failed (__t, CONSTRUCTOR, __FILE__,\t\t\t\\\n+\t\t\t __LINE__, __PRETTY_FUNCTION__);\t\t\\\n+    __t; })\n+#define EXPR_CHECK(t)\t\t\t\t\t\t\t\\\n+({  const tree __t = t;\t\t\t\t\t\t\t\\\n+    char __c = TREE_CODE_CLASS(TREE_CODE(__t));\t\t\t\t\\\n+    if (__c != 'r' && __c != 's' && __c != '<'\t\t\t\t\\\n+\t&& __c != '1' && __c != '2' && __c != 'e')\t\t\t\\\n+      tree_class_check_failed(__t, 'e', __FILE__,\t\t\t\\\n+\t\t\t      __LINE__, __PRETTY_FUNCTION__);\t\t\\\n+    __t; })\n+\n+extern void tree_check_failed PROTO((const tree, enum tree_code,\n+\t\t\t\t     const char *, int, const char *))\n+    ATTRIBUTE_NORETURN;\n+extern void tree_class_check_failed PROTO((const tree, char,\n+\t\t\t\t\t   const char *, int, const char *))\n+    ATTRIBUTE_NORETURN;\n+\n+#else /* not gcc or old gcc */\n+\n+#define TREE_CHECK(t, code) \\\n+\ttree_check (t, code, __FILE__, __LINE__)\n+#define TREE_CLASS_CHECK(t, code) \\\n+\ttree_class_check (t, code, __FILE__, __LINE__)\n+#define CST_OR_CONSTRUCTOR_CHECK(t) \\\n+\tcst_or_constructor_check (t, __FILE__, __LINE__)\n+#define EXPR_CHECK(t) \\\n+\texpr_check (t, __FILE__, __LINE__)\n+\n+extern tree tree_check PROTO((const tree, enum tree_code, const char *, int));\n+extern tree tree_class_check PROTO((const tree, char, const char *, int));\n+extern tree cst_or_constructor_check PROTO((const tree, const char *, int));\n+extern tree expr_check PROTO((const tree, enum tree_code, const char *, int));\n \n-#include \"tree-check.h\"\n+#endif /* not gcc or old gcc */\n \n-#define TYPE_CHECK(tree)       DO_CHECK (tree_class_check, tree, 't')\n-#define TYPE_CHECK1(tree)      DO_CHECK1 (tree_class_check, tree, 't')\n-#define DECL_CHECK(t)          DO_CHECK (tree_class_check, t, 'd')\n-#define DECL_CHECK1(t)         DO_CHECK1 (tree_class_check, t, 'd')\n-#define CST_CHECK(t)           DO_CHECK (tree_class_check, t, 'c')\n-#define CST_CHECK1(t)          DO_CHECK1 (tree_class_check, t, 'c')\n-#define EXPR_CHECK(t)          DO_CHECK (expr_check, t, 0)\n+#else /* not ENABLE_CHECKING */\n \n-/* Chained checks. The last check has to succeed, the others may fail. */\n-#define CST_OR_CONSTRUCTOR_CHECK(t) \\\n-   CHAIN_CHECK (t, CST_CHECK1, CONSTRUCTOR_CHECK)\n+#define TREE_CHECK(t, code)\t\t(t)\n+#define TREE_CLASS_CHECK(t, code)\t(t)\n+#define CST_OR_CONSTRUCTOR_CHECK(t)\t(t)\n+#define EXPR_CHECK(t)\t\t\t(t)\n+\n+#endif\n+\n+#include \"tree-check.h\"\n+\n+#define TYPE_CHECK(tree)\tTREE_CLASS_CHECK  (tree, 't')\n+#define DECL_CHECK(tree)\tTREE_CLASS_CHECK  (tree, 'd')\n+#define CST_CHECK(tree)\t\tTREE_CLASS_CHECK  (tree, 'c')\n \n /* In all nodes that are expressions, this is the data type of the expression.\n    In POINTER_TYPE nodes, this is the type that the pointer points to.\n@@ -2198,12 +2244,6 @@ extern void start_identifier_warnings\tPROTO ((void));\n extern void gcc_obstack_init\t\tPROTO ((struct obstack *));\n extern void init_obstacks\t\tPROTO ((void));\n extern void obfree\t\t\tPROTO ((char *));\n-extern tree tree_check                  PROTO ((tree, enum tree_code,\n-\t\t\t\t\t\tconst char *, int, int));\n-extern tree tree_class_check            PROTO ((tree, char, const char *,\n-\t\t\t\t\t\tint, int));\n-extern tree expr_check                  PROTO ((tree, int, const char *,\n-\t\t\t\t\t\tint, int));\n \n /* In function.c */\n extern void setjmp_protect_args\t\tPROTO ((void));"}]}