{"sha": "e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU3ZDkzYzZiY2ZkNTBjZGIzZDE5MjhkNzhlOGZlMGJiNmNlNTE3Yw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-05-18T21:48:02Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-05-18T21:48:02Z"}, "message": "Implement explicit conversions ops as specified in N2437.\n\n\t* decl.c (grokdeclarator): Handle explicit conversion ops.\n\t(check_initializer): Pass flags to store_init_value.\n\t* decl2.c (maybe_emit_vtables): Likewise.\n\t* init.c (expand_aggr_init_1): Likewise.\n\t* call.c (convert_class_to_reference): Take flags parm,\n\tcheck DECL_NONCONVERTING_P.\n\t(build_user_type_conversion_1): Check DECL_NONCONVERTING_P.\n\t(add_builtin_candidates): Simplify getting type of conversion.\n\t(build_object_call): Likewise.  Check DECL_NONCONVERTING_P.\n\t(implicit_conversion): Pass through LOOKUP_ONLYCONVERTING.\n\t(reference_binding): Take flags parm.  Direct-initialize copy parm.\n\t(add_function_candidate): Direct-initialize the copy parm.\n\t(add_conv_candidate): Use LOOKUP_IMPLICIT, not LOOKUP_NORMAL.\n\t(build_builtin_candidate): Add LOOKUP_ONLYCONVERTING.\n\t(conditional_conversion): Likewise.\n\t(convert_like_real): Only complain about DECL_NONCONVERTING_P\n\tconstructors.\n\t(perform_implicit_conversion_flags): Add flags parm to\n\tperform_implicit_conversion.  Improve diagnostics.\n\t* cp-tree.h (LOOKUP_IMPLICIT): New macro.\n\t(LOOKUP_COPY_PARM): New bit macro.\n\t* cvt.c (build_expr_type_conversion): Check DECL_NONCONVERTING_P.\n\t* typeck.c (convert_for_assignment): Take flags parm, pass it to\n\tperform_implicit_conversion_flags.\n\t(cp_build_modify_expr): Pass flags to convert_for_assignment.\n\t(convert_for_initialization): Likewise.\n\t* typeck2.c (store_init_value): Take flags parm, pass to\n\tdigest_init_flags.\n\t(digest_init_flags): Add flags parm to digest_init.\n\t(digest_init_r): Take flags parm, pass to convert_for_initialization.\n\t(process_init_constructor_array): Pass it.\n\t(process_init_constructor_record): Likewise.\n\t(process_init_constructor_union): Likewise.\n\nFrom-SVN: r147677", "tree": {"sha": "1cb5674ddf2e19bccf1158ba381c45a6b1606ef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cb5674ddf2e19bccf1158ba381c45a6b1606ef6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "82725547db6fba598916a16b027e06d16c5e6a57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82725547db6fba598916a16b027e06d16c5e6a57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82725547db6fba598916a16b027e06d16c5e6a57"}], "stats": {"total": 280, "additions": 238, "deletions": 42}, "files": [{"sha": "813413e767d3e79d95886c284949e27fcab7c541", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c", "patch": "@@ -1,3 +1,40 @@\n+2009-05-18  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement explicit conversions ops as specified in N2437.\n+\t* decl.c (grokdeclarator): Handle explicit conversion ops.\n+\t(check_initializer): Pass flags to store_init_value.\n+\t* decl2.c (maybe_emit_vtables): Likewise.\n+\t* init.c (expand_aggr_init_1): Likewise.\n+\t* call.c (convert_class_to_reference): Take flags parm,\n+\tcheck DECL_NONCONVERTING_P.\n+\t(build_user_type_conversion_1): Check DECL_NONCONVERTING_P.\n+\t(add_builtin_candidates): Simplify getting type of conversion.\n+\t(build_object_call): Likewise.  Check DECL_NONCONVERTING_P.\n+\t(implicit_conversion): Pass through LOOKUP_ONLYCONVERTING.\n+\t(reference_binding): Take flags parm.  Direct-initialize copy parm.\n+\t(add_function_candidate): Direct-initialize the copy parm.\n+\t(add_conv_candidate): Use LOOKUP_IMPLICIT, not LOOKUP_NORMAL.\n+\t(build_builtin_candidate): Add LOOKUP_ONLYCONVERTING.\n+\t(conditional_conversion): Likewise.\n+\t(convert_like_real): Only complain about DECL_NONCONVERTING_P\n+\tconstructors.\n+\t(perform_implicit_conversion_flags): Add flags parm to\n+\tperform_implicit_conversion.  Improve diagnostics.\n+\t* cp-tree.h (LOOKUP_IMPLICIT): New macro.\n+\t(LOOKUP_COPY_PARM): New bit macro.\n+\t* cvt.c (build_expr_type_conversion): Check DECL_NONCONVERTING_P.\n+\t* typeck.c (convert_for_assignment): Take flags parm, pass it to\n+\tperform_implicit_conversion_flags.\n+\t(cp_build_modify_expr): Pass flags to convert_for_assignment.\n+\t(convert_for_initialization): Likewise.\n+\t* typeck2.c (store_init_value): Take flags parm, pass to\n+\tdigest_init_flags.\n+\t(digest_init_flags): Add flags parm to digest_init.\n+\t(digest_init_r): Take flags parm, pass to convert_for_initialization.\n+\t(process_init_constructor_array): Pass it.\n+\t(process_init_constructor_record): Likewise.\n+\t(process_init_constructor_union): Likewise.\n+\n 2009-05-16  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/40139"}, {"sha": "b33e9036b4d7980409ad68b3042539c7255657ef", "filename": "gcc/cp/call.c", "status": "modified", "additions": 60, "deletions": 19, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c", "patch": "@@ -190,7 +190,7 @@ static tree source_type (conversion *);\n static void add_warning (struct z_candidate *, struct z_candidate *);\n static bool reference_related_p (tree, tree);\n static bool reference_compatible_p (tree, tree);\n-static conversion *convert_class_to_reference (tree, tree, tree);\n+static conversion *convert_class_to_reference (tree, tree, tree, int);\n static conversion *direct_reference_binding (tree, conversion *);\n static bool promoted_arithmetic_type_p (tree);\n static conversion *conditional_conversion (tree, tree);\n@@ -993,7 +993,7 @@ reference_compatible_p (tree t1, tree t2)\n    converted to T as in [over.match.ref].  */\n \n static conversion *\n-convert_class_to_reference (tree reference_type, tree s, tree expr)\n+convert_class_to_reference (tree reference_type, tree s, tree expr, int flags)\n {\n   tree conversions;\n   tree arglist;\n@@ -1034,7 +1034,7 @@ convert_class_to_reference (tree reference_type, tree s, tree expr)\n \n   t = TREE_TYPE (reference_type);\n \n-  while (conversions)\n+  for (; conversions; conversions = TREE_CHAIN (conversions))\n     {\n       tree fns = TREE_VALUE (conversions);\n \n@@ -1043,6 +1043,10 @@ convert_class_to_reference (tree reference_type, tree s, tree expr)\n \t  tree f = OVL_CURRENT (fns);\n \t  tree t2 = TREE_TYPE (TREE_TYPE (f));\n \n+\t  if (DECL_NONCONVERTING_P (f)\n+\t      && (flags & LOOKUP_ONLYCONVERTING))\n+\t    continue;\n+\n \t  cand = NULL;\n \n \t  /* If this is a template function, try to get an exact\n@@ -1101,7 +1105,6 @@ convert_class_to_reference (tree reference_type, tree s, tree expr)\n \t      cand->second_conv->bad_p |= cand->convs[0]->bad_p;\n \t    }\n \t}\n-      conversions = TREE_CHAIN (conversions);\n     }\n \n   candidates = splice_viable (candidates, pedantic, &any_viable_p);\n@@ -1303,7 +1306,7 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n \n \tthe reference is bound to the lvalue result of the conversion\n \tin the second case.  */\n-      conv = convert_class_to_reference (rto, from, expr);\n+      conv = convert_class_to_reference (rto, from, expr, flags);\n       if (conv)\n \treturn conv;\n     }\n@@ -1347,6 +1350,12 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n      conversion operator).  */\n   flags |= LOOKUP_NO_TEMP_BIND;\n \n+  /* Temporaries are copy-initialized, except for this hack to allow\n+     explicit conversion ops to the copy ctor.  See also\n+     add_function_candidate.  */\n+  if (!(flags & LOOKUP_COPY_PARM))\n+    flags |= LOOKUP_ONLYCONVERTING;\n+\n   conv = implicit_conversion (to, from, expr, c_cast_p,\n \t\t\t      flags);\n   if (!conv)\n@@ -1394,8 +1403,7 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n       && (flags & LOOKUP_NO_CONVERSION) == 0)\n     {\n       struct z_candidate *cand;\n-      int convflags = ((flags & LOOKUP_NO_TEMP_BIND)\n-\t\t       |LOOKUP_ONLYCONVERTING);\n+      int convflags = (flags & (LOOKUP_NO_TEMP_BIND|LOOKUP_ONLYCONVERTING));\n \n       if (CLASS_TYPE_P (to)\n \t  && !CLASSTYPE_NON_AGGREGATE (complete_type (to))\n@@ -1547,9 +1555,17 @@ add_function_candidate (struct z_candidate **candidates,\n \t      parmtype = build_pointer_type (parmtype);\n \t    }\n \n-\t  if ((flags & LOOKUP_NO_COPY_CTOR_CONVERSION)\n-\t      && ctype && i == 0 && DECL_COPY_CONSTRUCTOR_P (fn))\n-\t    lflags |= LOOKUP_NO_CONVERSION;\n+\t  if (ctype && i == 0 && DECL_COPY_CONSTRUCTOR_P (fn))\n+\t    {\n+\t      /* Hack: Direct-initialize copy parm (i.e. suppress\n+\t\t LOOKUP_ONLYCONVERTING) to make explicit conversion ops\n+\t\t work.  See also reference_binding.  */\n+\t      lflags |= LOOKUP_COPY_PARM;\n+\t      if (flags & LOOKUP_NO_COPY_CTOR_CONVERSION)\n+\t\tlflags |= LOOKUP_NO_CONVERSION;\n+\t    }\n+\t  else\n+\t    lflags |= LOOKUP_ONLYCONVERTING;\n \n \t  t = implicit_conversion (parmtype, argtype, arg,\n \t\t\t\t   /*c_cast_p=*/false, lflags);\n@@ -1612,7 +1628,7 @@ add_conv_candidate (struct z_candidate **candidates, tree fn, tree obj,\n   parmnode = parmlist;\n   argnode = arglist;\n   viable = 1;\n-  flags = LOOKUP_NORMAL;\n+  flags = LOOKUP_IMPLICIT;\n \n   /* Don't bother looking up the same type twice.  */\n   if (*candidates && (*candidates)->fn == totype)\n@@ -1679,6 +1695,7 @@ build_builtin_candidate (struct z_candidate **candidates, tree fnname,\n \n   num_convs =  args[2] ? 3 : (args[1] ? 2 : 1);\n   convs = alloc_conversions (num_convs);\n+  flags |= LOOKUP_ONLYCONVERTING;\n \n   for (i = 0; i < 2; ++i)\n     {\n@@ -2268,7 +2285,7 @@ add_builtin_candidates (struct z_candidate **candidates, enum tree_code code,\n \n \t  for (; convs; convs = TREE_CHAIN (convs))\n \t    {\n-\t      type = TREE_TYPE (TREE_TYPE (OVL_CURRENT (TREE_VALUE (convs))));\n+\t      type = TREE_TYPE (convs);\n \n \t      if (i == 0 && ref1\n \t\t  && (TREE_CODE (type) != REFERENCE_TYPE\n@@ -2785,6 +2802,10 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n \n+\t  if (DECL_NONCONVERTING_P (fn)\n+\t      && (flags & LOOKUP_ONLYCONVERTING))\n+\t    continue;\n+\n \t  /* [over.match.funcs] For conversion functions, the function\n \t     is considered to be a member of the class of the implicit\n \t     object argument for the purpose of defining the type of\n@@ -3214,7 +3235,7 @@ build_object_call (tree obj, tree args, tsubst_flags_t complain)\n   for (; convs; convs = TREE_CHAIN (convs))\n     {\n       tree fns = TREE_VALUE (convs);\n-      tree totype = TREE_TYPE (TREE_TYPE (OVL_CURRENT (fns)));\n+      tree totype = TREE_TYPE (convs);\n \n       if ((TREE_CODE (totype) == POINTER_TYPE\n \t   && TREE_CODE (TREE_TYPE (totype)) == FUNCTION_TYPE)\n@@ -3226,6 +3247,10 @@ build_object_call (tree obj, tree args, tsubst_flags_t complain)\n \tfor (; fns; fns = OVL_NEXT (fns))\n \t  {\n \t    tree fn = OVL_CURRENT (fns);\n+\n+\t    if (DECL_NONCONVERTING_P (fn))\n+\t      continue;\n+\n \t    if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t      add_template_conv_candidate\n \t\t(&candidates, fn, obj, args, totype,\n@@ -3348,7 +3373,7 @@ conditional_conversion (tree e1, tree e2)\n \t\t\t\t  t1,\n \t\t\t\t  e1,\n \t\t\t\t  /*c_cast_p=*/false,\n-\t\t\t\t  LOOKUP_NO_TEMP_BIND);\n+\t\t\t\t  LOOKUP_NO_TEMP_BIND|LOOKUP_ONLYCONVERTING);\n       if (conv)\n \treturn conv;\n     }\n@@ -3386,7 +3411,7 @@ conditional_conversion (tree e1, tree e2)\n        converted to the type that expression E2 would have if E2 were\n        converted to an rvalue (or the type it has, if E2 is an rvalue).  */\n     return implicit_conversion (t2, t1, e1, /*c_cast_p=*/false,\n-\t\t\t\tLOOKUP_NORMAL);\n+\t\t\t\tLOOKUP_IMPLICIT);\n }\n \n /* Implement [expr.cond].  ARG1, ARG2, and ARG3 are the three\n@@ -4584,7 +4609,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \n \t/* When converting from an init list we consider explicit\n \t   constructors, but actually trying to call one is an error.  */\n-\tif (DECL_NONCONVERTING_P (convfn))\n+\tif (DECL_NONCONVERTING_P (convfn) && DECL_CONSTRUCTOR_P (convfn))\n \t  {\n \t    if (complain & tf_error)\n \t      error (\"converting to %qT from initializer list would use \"\n@@ -7025,7 +7050,7 @@ can_convert_arg_bad (tree to, tree from, tree arg)\n    doing a bad conversion, convert_like will complain.  */\n \n tree\n-perform_implicit_conversion (tree type, tree expr, tsubst_flags_t complain)\n+perform_implicit_conversion_flags (tree type, tree expr, tsubst_flags_t complain, int flags)\n {\n   conversion *conv;\n   void *p;\n@@ -7038,11 +7063,21 @@ perform_implicit_conversion (tree type, tree expr, tsubst_flags_t complain)\n \n   conv = implicit_conversion (type, TREE_TYPE (expr), expr,\n \t\t\t      /*c_cast_p=*/false,\n-\t\t\t      LOOKUP_NORMAL);\n+\t\t\t      flags);\n+\n   if (!conv)\n     {\n       if (complain & tf_error)\n-\terror (\"could not convert %qE to %qT\", expr, type);\n+\t{\n+\t  /* If expr has unknown type, then it is an overloaded function.\n+\t     Call instantiate_type to get good error messages.  */\n+\t  if (TREE_TYPE (expr) == unknown_type_node)\n+\t    instantiate_type (type, expr, complain);\n+\t  else if (invalid_nonstatic_memfn_p (expr, complain))\n+\t    /* We gave an error.  */;\n+\t  else\n+\t    error (\"could not convert %qE to %qT\", expr, type);\n+\t}\n       expr = error_mark_node;\n     }\n   else if (processing_template_decl)\n@@ -7062,6 +7097,12 @@ perform_implicit_conversion (tree type, tree expr, tsubst_flags_t complain)\n   return expr;\n }\n \n+tree\n+perform_implicit_conversion (tree type, tree expr, tsubst_flags_t complain)\n+{\n+  return perform_implicit_conversion_flags (type, expr, complain, LOOKUP_IMPLICIT);\n+}\n+\n /* Convert EXPR to TYPE (as a direct-initialization) if that is\n    permitted.  If the conversion is valid, the converted expression is\n    returned.  Otherwise, NULL_TREE is returned, except in the case"}, {"sha": "3dfd482f3c93fc1a15110ded20d5f05b2ccd0e94", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c", "patch": "@@ -1963,8 +1963,8 @@ struct GTY(()) lang_decl {\n    is mutable.  */\n #define DECL_MUTABLE_P(NODE) (DECL_LANG_FLAG_0 (NODE))\n \n-/* Nonzero for _DECL means that this constructor is a non-converting\n-   constructor.  */\n+/* Nonzero for _DECL means that this constructor or conversion function is\n+   non-converting.  */\n #define DECL_NONCONVERTING_P(NODE) \\\n   (DECL_LANG_SPECIFIC (NODE)->decl_flags.nonconverting)\n \n@@ -3758,8 +3758,10 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n /* Even if the function found by lookup is a virtual function, it\n    should be called directly.  */\n #define LOOKUP_NONVIRTUAL (1 << 2)\n-/* Non-converting (i.e., \"explicit\") constructors are not tried.  */\n+/* Non-converting (i.e., \"explicit\") constructors are not tried.  This flag\n+   indicates that we are not performing direct-initialization.  */\n #define LOOKUP_ONLYCONVERTING (1 << 3)\n+#define LOOKUP_IMPLICIT (LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING)\n /* If a temporary is created, it should be created so that it lives\n    as long as the current variable bindings; otherwise it only lives\n    until the end of the complete-expression.  It also forces\n@@ -3793,6 +3795,8 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n /* Avoid user-defined conversions for the first parameter of a copy\n    constructor.  */\n #define LOOKUP_NO_COPY_CTOR_CONVERSION (LOOKUP_NO_NARROWING << 1)\n+/* This is the first parameter of a copy constructor.  */\n+#define LOOKUP_COPY_PARM (LOOKUP_NO_COPY_CTOR_CONVERSION << 1)\n \n #define LOOKUP_NAMESPACES_ONLY(F)  \\\n   (((F) & LOOKUP_PREFER_NAMESPACES) && !((F) & LOOKUP_PREFER_TYPES))\n@@ -4200,6 +4204,7 @@ extern tree initialize_reference\t\t(tree, tree, tree, tree *);\n extern tree make_temporary_var_for_ref_to_temp\t(tree, tree);\n extern tree strip_top_quals\t\t\t(tree);\n extern tree perform_implicit_conversion\t\t(tree, tree, tsubst_flags_t);\n+extern tree perform_implicit_conversion_flags\t(tree, tree, tsubst_flags_t, int);\n extern tree perform_direct_initialization_if_possible (tree, tree, bool,\n                                                        tsubst_flags_t);\n extern tree in_charge_arg_for_name\t\t(tree);\n@@ -5001,9 +5006,10 @@ extern void readonly_error\t\t\t(tree, const char *);\n extern void complete_type_check_abstract\t(tree);\n extern int abstract_virtuals_error\t\t(tree, tree);\n \n-extern tree store_init_value\t\t\t(tree, tree);\n+extern tree store_init_value\t\t\t(tree, tree, int);\n extern void check_narrowing\t\t\t(tree, tree);\n extern tree digest_init\t\t\t\t(tree, tree);\n+extern tree digest_init_flags\t\t\t(tree, tree, int);\n extern tree build_scoped_ref\t\t\t(tree, tree, tree *);\n extern tree build_x_arrow\t\t\t(tree);\n extern tree build_m_component_ref\t\t(tree, tree);"}, {"sha": "3fdebd7f155e10f8068a1c297dddda601618ee3a", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c", "patch": "@@ -1181,6 +1181,9 @@ build_expr_type_conversion (int desires, tree expr, bool complain)\n       if (winner && winner == cand)\n \tcontinue;\n \n+      if (DECL_NONCONVERTING_P (cand))\n+\tcontinue;\n+\n       candidate = non_reference (TREE_TYPE (TREE_TYPE (cand)));\n \n       switch (TREE_CODE (candidate))"}, {"sha": "e9ff87bcec996f0a49a072721ec316a62b95238d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c", "patch": "@@ -5176,7 +5176,7 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n \treturn build_aggr_init_full_exprs (decl, init, flags);\n       else if (TREE_CODE (init) != TREE_VEC)\n \t{\n-\t  init_code = store_init_value (decl, init);\n+\t  init_code = store_init_value (decl, init, flags);\n \t  if (pedantic && TREE_CODE (type) == ARRAY_TYPE\n \t      && DECL_INITIAL (decl)\n \t      && TREE_CODE (DECL_INITIAL (decl)) == STRING_CST\n@@ -8413,6 +8413,14 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t \"class definition\",\n \t\t\t name);\n \t      }\n+\t    else if (ctype && sfk == sfk_conversion)\n+\t      {\n+\t\tif (explicitp == 1)\n+\t\t  {\n+\t\t    maybe_warn_cpp0x (\"explicit conversion operators\");\n+\t\t    explicitp = 2;\n+\t\t  }\n+\t      }\n \n \t    arg_types = grokparms (declarator->u.function.parameters,\n \t\t\t\t   &parms);"}, {"sha": "0e050dd0cf86aa1e8b113e3a25ce45b84a20f6c0", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c", "patch": "@@ -1764,7 +1764,7 @@ maybe_emit_vtables (tree ctype)\n \n       if (TREE_TYPE (DECL_INITIAL (vtbl)) == 0)\n \t{\n-\t  tree expr = store_init_value (vtbl, DECL_INITIAL (vtbl));\n+\t  tree expr = store_init_value (vtbl, DECL_INITIAL (vtbl), LOOKUP_NORMAL);\n \n \t  /* It had better be all done at compile-time.  */\n \t  gcc_assert (!expr);"}, {"sha": "5fa5eb84b27bf010790667e2cb8937f7898c893f", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c", "patch": "@@ -1387,7 +1387,7 @@ expand_aggr_init_1 (tree binfo, tree true_exp, tree exp, tree init, int flags,\n       /* If store_init_value returns NULL_TREE, the INIT has been\n \t recorded as the DECL_INITIAL for EXP.  That means there's\n \t nothing more we have to do.  */\n-      init = store_init_value (exp, init);\n+      init = store_init_value (exp, init, flags);\n       if (init)\n \tfinish_expr_stmt (init);\n       return;"}, {"sha": "66472ee96ebfb5f1d3528952172da98b3c0e660c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c", "patch": "@@ -48,7 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n static tree pfn_from_ptrmemfunc (tree);\n static tree delta_from_ptrmemfunc (tree);\n static tree convert_for_assignment (tree, tree, const char *, tree, int,\n-\t\t\t\t    tsubst_flags_t);\n+\t\t\t\t    tsubst_flags_t, int);\n static tree cp_pointer_int_sum (enum tree_code, tree, tree);\n static tree rationalize_conditional_expr (enum tree_code, tree, \n \t\t\t\t\t  tsubst_flags_t);\n@@ -6157,12 +6157,14 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n     }\n \n   if (modifycode == INIT_EXPR)\n+    /* Calls with INIT_EXPR are all direct-initialization, so don't set\n+       LOOKUP_ONLYCONVERTING.  */\n     newrhs = convert_for_initialization (lhs, olhstype, newrhs, LOOKUP_NORMAL,\n \t\t\t\t\t \"initialization\", NULL_TREE, 0,\n                                          complain);\n   else\n     newrhs = convert_for_assignment (olhstype, newrhs, \"assignment\",\n-\t\t\t\t     NULL_TREE, 0, complain);\n+\t\t\t\t     NULL_TREE, 0, complain, LOOKUP_IMPLICIT);\n \n   if (!same_type_p (lhstype, olhstype))\n     newrhs = cp_convert_and_check (lhstype, newrhs);\n@@ -6568,7 +6570,7 @@ delta_from_ptrmemfunc (tree t)\n static tree\n convert_for_assignment (tree type, tree rhs,\n \t\t\tconst char *errtype, tree fndecl, int parmnum,\n-\t\t\ttsubst_flags_t complain)\n+\t\t\ttsubst_flags_t complain, int flags)\n {\n   tree rhstype;\n   enum tree_code coder;\n@@ -6689,7 +6691,8 @@ convert_for_assignment (tree type, tree rhs,\n       TREE_NO_WARNING (rhs) = 1;\n     }\n \n-  return perform_implicit_conversion (strip_top_quals (type), rhs, complain);\n+  return perform_implicit_conversion_flags (strip_top_quals (type), rhs,\n+\t\t\t\t\t    complain, flags);\n }\n \n /* Convert RHS to be of type TYPE.\n@@ -6780,7 +6783,7 @@ convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n     return ocp_convert (type, rhs, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n \n   return convert_for_assignment (type, rhs, errtype, fndecl, parmnum,\n-\t\t\t\t complain);\n+\t\t\t\t complain, flags);\n }\n \f\n /* If RETVAL is the address of, or a reference to, a local variable or"}, {"sha": "5783f6781b1f82317d66469021d610887f8745e4", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c", "patch": "@@ -586,7 +586,7 @@ split_nonconstant_init (tree dest, tree init)\n    for static variable.  In that case, caller must emit the code.  */\n \n tree\n-store_init_value (tree decl, tree init)\n+store_init_value (tree decl, tree init, int flags)\n {\n   tree value, type;\n \n@@ -628,7 +628,7 @@ store_init_value (tree decl, tree init)\n   /* End of special C++ code.  */\n \n   /* Digest the specified initializer into an expression.  */\n-  value = digest_init (type, init);\n+  value = digest_init_flags (type, init, flags);\n   /* If the initializer is not a constant, fill in DECL_INITIAL with\n      the bits that are constant, and then return an expression that\n      will perform the dynamic initialization.  */\n@@ -717,7 +717,7 @@ check_narrowing (tree type, tree init)\n    NESTED is true iff we are being called for an element of a CONSTRUCTOR.  */\n \n static tree\n-digest_init_r (tree type, tree init, bool nested)\n+digest_init_r (tree type, tree init, bool nested, int flags)\n {\n   enum tree_code code = TREE_CODE (type);\n \n@@ -796,9 +796,9 @@ digest_init_r (tree type, tree init, bool nested)\n \n       if (cxx_dialect != cxx98 && nested)\n \tcheck_narrowing (type, init);\n-      init = convert_for_initialization (0, type, init, LOOKUP_NORMAL,\n+      init = convert_for_initialization (0, type, init, flags,\n \t\t\t\t\t \"initialization\", NULL_TREE, 0,\n-                                         tf_warning_or_error);\n+\t\t\t\t\t tf_warning_or_error);\n       exp = &init;\n \n       /* Skip any conversions since we'll be outputting the underlying\n@@ -842,7 +842,7 @@ digest_init_r (tree type, tree init, bool nested)\n \t}\n \n       return convert_for_initialization (NULL_TREE, type, init,\n-\t\t\t\t\t LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING,\n+\t\t\t\t\t flags,\n \t\t\t\t\t \"initialization\", NULL_TREE, 0,\n                                          tf_warning_or_error);\n     }\n@@ -851,7 +851,13 @@ digest_init_r (tree type, tree init, bool nested)\n tree\n digest_init (tree type, tree init)\n {\n-  return digest_init_r (type, init, false);\n+  return digest_init_r (type, init, false, LOOKUP_IMPLICIT);\n+}\n+\n+tree\n+digest_init_flags (tree type, tree init, int flags)\n+{\n+  return digest_init_r (type, init, false, flags);\n }\n \f\n /* Set of flags used within process_init_constructor to describe the\n@@ -924,7 +930,7 @@ process_init_constructor_array (tree type, tree init)\n       else\n \tce->index = size_int (i);\n       gcc_assert (ce->value);\n-      ce->value = digest_init_r (TREE_TYPE (type), ce->value, true);\n+      ce->value = digest_init_r (TREE_TYPE (type), ce->value, true, LOOKUP_IMPLICIT);\n \n       if (ce->value != error_mark_node)\n \tgcc_assert (same_type_ignoring_top_level_qualifiers_p\n@@ -1031,7 +1037,7 @@ process_init_constructor_record (tree type, tree init)\n \t    }\n \n \t  gcc_assert (ce->value);\n-\t  next = digest_init_r (type, ce->value, true);\n+\t  next = digest_init_r (type, ce->value, true, LOOKUP_IMPLICIT);\n \t  ++idx;\n \t}\n       else if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (field)))\n@@ -1046,7 +1052,7 @@ process_init_constructor_record (tree type, tree init)\n \t  else\n \t    next = build_constructor (init_list_type_node, NULL);\n \n-\t  next = digest_init_r (TREE_TYPE (field), next, true);\n+\t  next = digest_init_r (TREE_TYPE (field), next, true, LOOKUP_IMPLICIT);\n \n \t  /* Warn when some struct elements are implicitly initialized.  */\n \t  warning (OPT_Wmissing_field_initializers,\n@@ -1156,7 +1162,7 @@ process_init_constructor_union (tree type, tree init)\n     }\n \n   if (ce->value && ce->value != error_mark_node)\n-    ce->value = digest_init_r (TREE_TYPE (ce->index), ce->value, true);\n+    ce->value = digest_init_r (TREE_TYPE (ce->index), ce->value, true, LOOKUP_IMPLICIT);\n \n   return picflag_from_initializer (ce->value);\n }"}, {"sha": "34a7a2d0a4a19525fa0e43a0df6e64264e84a8f7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c", "patch": "@@ -1,3 +1,8 @@\n+2009-05-18  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/explicit1.C: New.\n+\t* g++.dg/cpp0x/explicit2.C: New.\n+\n 2009-05-18  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR debug/40109"}, {"sha": "fe164fc8cb1fc3be7ac4fb5567e360fa6f4765db", "filename": "gcc/testsuite/g++.dg/cpp0x/explicit1.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fexplicit1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fexplicit1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fexplicit1.C?ref=e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c", "patch": "@@ -0,0 +1,58 @@\n+// Test for explicit conversion ops from N2437.\n+// { dg-options \"-std=c++0x\" }\n+\n+class U; class V;\n+class T\n+{\n+public:\n+  T( U const & );\n+  //implicit converting ctor\n+  explicit T( V const & );\n+  // explicit ctor\n+};\n+class U\n+{\n+};\n+class V\n+{\n+};\n+class W\n+{\n+public:\n+  operator T() const;\n+};\n+class X\n+{\n+public:\n+  explicit operator T() const; // theoretical\n+};\n+int main()\n+{\n+  U u; V v; W w; X x;\n+  // Direct initialization:\n+  T t1( u );\n+  T t2( v );\n+  T t3( w );\n+  T t4( x );\n+  // Copy initialization:\n+  T t5 = u;\n+  T t6 = v;\t\t\t// { dg-error \"\" }\n+  T t7 = w;\n+  T t8 = x;\t\t\t// { dg-error \"\" }\n+  // Cast notation:\n+  T t9 = (T) u;\n+  T t10 = (T) v;\n+  T t11 = (T) w;\n+  T t12 = (T) x;\n+  // Static cast:\n+  T t13 = static_cast<T>( u );\n+  T t14 = static_cast<T>( v );\n+  T t15 = static_cast<T>( w );\n+  T t16 = static_cast<T>( x );\n+  // Function-style cast:\n+  T t17 = T( u );\n+  T t18 = T( v );\n+  T t19 = T( w );\n+  T t20 = T( x );\n+  return 0;\n+}"}, {"sha": "c2327c140d8e95ed44b948ad96282a64d214ee48", "filename": "gcc/testsuite/g++.dg/cpp0x/explicit2.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fexplicit2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fexplicit2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fexplicit2.C?ref=e57d93c6bcfd50cdb3d1928d78e8fe0bb6ce517c", "patch": "@@ -0,0 +1,29 @@\n+// Test for explicit conversion ops in various conversion situations.\n+// { dg-options \"-std=c++0x\" }\n+\n+typedef void (*pfn)();\n+\n+struct A\n+{\n+  explicit operator int() const;\n+  explicit operator pfn() const;\n+};\n+\n+int main()\n+{\n+  A a;\n+  int i = a;\t\t\t// { dg-error \"\" }\n+  const int &ir = a;\t\t// { dg-error \"\" }\n+  a();\t\t\t\t// { dg-error \"\" }\n+  a + 1;\t\t\t// { dg-message \"\" } (error and note on same line)\n+\n+  int j (a);\n+  (int)a;\n+  static_cast<int>(a);\n+}\n+\n+struct B\n+{\n+  int i;\n+  B(const A& a): i(a) { }\n+};"}]}