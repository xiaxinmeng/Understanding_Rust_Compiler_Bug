{"sha": "ff8f44010f2c7d7de2666078cc5d627f27c7432b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmY4ZjQ0MDEwZjJjN2Q3ZGUyNjY2MDc4Y2M1ZDYyN2YyN2M3NDMyYg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-23T18:50:33Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-23T18:50:33Z"}, "message": "(output_constant_def_contents): New function.\n\n(output_constant_def): Use it.\n(deferred_constants): New list of constants not yet output.\n(defer_addressed_constants): New function.\n(output_deferred_addressed_constants): New function.\n(make_decl_rtl): Don't ever replace old rtl;\ninstead, change its mode if necessary.\n\nFrom-SVN: r4974", "tree": {"sha": "f3e3a067c65cab37af90b168e94e95156be6d7f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3e3a067c65cab37af90b168e94e95156be6d7f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff8f44010f2c7d7de2666078cc5d627f27c7432b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff8f44010f2c7d7de2666078cc5d627f27c7432b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff8f44010f2c7d7de2666078cc5d627f27c7432b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff8f44010f2c7d7de2666078cc5d627f27c7432b/comments", "author": null, "committer": null, "parents": [{"sha": "de5206613ed98eac1e9b142079458314b66ada83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de5206613ed98eac1e9b142079458314b66ada83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de5206613ed98eac1e9b142079458314b66ada83"}], "stats": {"total": 208, "additions": 149, "deletions": 59}, "files": [{"sha": "a65d75c86cc2ecf44db9d29d3fc8429f8fe471d8", "filename": "gcc/varasm.c", "status": "modified", "additions": 149, "deletions": 59, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff8f44010f2c7d7de2666078cc5d627f27c7432b/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff8f44010f2c7d7de2666078cc5d627f27c7432b/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=ff8f44010f2c7d7de2666078cc5d627f27c7432b", "patch": "@@ -88,6 +88,8 @@ extern FILE *asm_out_file;\n \n static char *compare_constant_1 ();\n static void record_constant_1 ();\n+static void output_constant_def_contents ();\n+\n void output_constant_pool ();\n void assemble_name ();\n int output_addressed_constants ();\n@@ -313,11 +315,8 @@ make_decl_rtl (decl, asmspec, top_level)\n     }\n \n   /* For a duplicate declaration, we can be called twice on the\n-     same DECL node.  Don't alter the RTL already made\n-     unless the old mode is wrong (which can happen when\n-     the previous rtl was made when the type was incomplete).  */\n-  if (DECL_RTL (decl) == 0\n-      || GET_MODE (DECL_RTL (decl)) != DECL_MODE (decl))\n+     same DECL node.  Don't discard the RTL already made.  */\n+  if (DECL_RTL (decl) == 0)\n     {\n       DECL_RTL (decl) = 0;\n \n@@ -419,6 +418,12 @@ make_decl_rtl (decl, asmspec, top_level)\n #endif\n \t}\n     }\n+  /* If the old RTL had the wrong mode, fix the mode.  */\n+  else if (GET_MODE (DECL_RTL (decl)) != DECL_MODE (decl))\n+    {\n+      rtx rtl = DECL_RTL (decl);\n+      PUT_MODE (rtl, DECL_MODE (decl));\n+    }\n }\n \n /* Make the rtl for variable VAR be volatile.\n@@ -693,10 +698,12 @@ assemble_string (p, size)\n \n    TOP_LEVEL is nonzero if this variable has file scope.\n    AT_END is nonzero if this is the special handling, at end of compilation,\n-   to define things that have had only tentative definitions.  */\n+   to define things that have had only tentative definitions.\n+   DONT_OUTPUT_DATA if nonzero means don't actually output the\n+   initial value (that will be done by the caller).  */\n \n void\n-assemble_variable (decl, top_level, at_end)\n+assemble_variable (decl, top_level, at_end, dont_output_data)\n      tree decl;\n      int top_level;\n      int at_end;\n@@ -763,7 +770,7 @@ assemble_variable (decl, top_level, at_end)\n   /* Still incomplete => don't allocate it; treat the tentative defn\n      (which is what it must have been) as an `extern' reference.  */\n \n-  if (DECL_SIZE (decl) == 0)\n+  if (!dont_output_data && DECL_SIZE (decl) == 0)\n     {\n       error_with_file_and_line (DECL_SOURCE_FILE (decl),\n \t\t\t\tDECL_SOURCE_LINE (decl),\n@@ -785,19 +792,22 @@ assemble_variable (decl, top_level, at_end)\n   /* If storage size is erroneously variable, just continue.\n      Error message was already made.  */\n \n-  if (TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n-    goto finish;\n+  if (DECL_SIZE (decl))\n+    {\n+      if (TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n+\tgoto finish;\n \n-  app_disable ();\n+      app_disable ();\n \n-  /* This is better than explicit arithmetic, since it avoids overflow.  */\n-  size_tree = size_binop (CEIL_DIV_EXPR,\n-\t\t\t  DECL_SIZE (decl), size_int (BITS_PER_UNIT));\n+      /* This is better than explicit arithmetic, since it avoids overflow.  */\n+      size_tree = size_binop (CEIL_DIV_EXPR,\n+\t\t\t      DECL_SIZE (decl), size_int (BITS_PER_UNIT));\n \n-  if (TREE_INT_CST_HIGH (size_tree) != 0)\n-    {\n-      error_with_decl (decl, \"size of variable `%s' is too large\");\n-      goto finish;\n+      if (TREE_INT_CST_HIGH (size_tree) != 0)\n+\t{\n+\t  error_with_decl (decl, \"size of variable `%s' is too large\");\n+\t  goto finish;\n+\t}\n     }\n \n   name = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n@@ -809,6 +819,7 @@ assemble_variable (decl, top_level, at_end)\n      initializer equal to zero.  (Section 3.7.2)\n      -fno-common gives strict ANSI behavior.  Usually you don't want it.  */\n   if (! flag_no_common\n+      && ! dont_output_data\n       && (DECL_INITIAL (decl) == 0 || DECL_INITIAL (decl) == error_mark_node))\n     {\n       int size = TREE_INT_CST_LOW (size_tree);\n@@ -995,21 +1006,16 @@ assemble_variable (decl, top_level, at_end)\n   ASM_OUTPUT_LABEL (asm_out_file, name);\n #endif /* ASM_DECLARE_OBJECT_NAME */\n \n-#if 0\n-  for (d = equivalents; d; d = TREE_CHAIN (d))\n+  if (!dont_output_data)\n     {\n-      tree e = TREE_VALUE (d);\n-      ASM_OUTPUT_LABEL (asm_out_file, XSTR (XEXP (DECL_RTL (e), 0), 0));\n+      if (DECL_INITIAL (decl))\n+\t/* Output the actual data.  */\n+\toutput_constant (DECL_INITIAL (decl),\n+\t\t\t int_size_in_bytes (TREE_TYPE (decl)));\n+      else\n+\t/* Leave space for it.  */\n+\tassemble_zeros (int_size_in_bytes (TREE_TYPE (decl)));\n     }\n-#endif\n-\n-  if (DECL_INITIAL (decl))\n-    /* Output the actual data.  */\n-    output_constant (DECL_INITIAL (decl),\n-\t\t     int_size_in_bytes (TREE_TYPE (decl)));\n-  else\n-    /* Leave space for it.  */\n-    assemble_zeros (int_size_in_bytes (TREE_TYPE (decl)));\n \n  finish:\n #ifdef XCOFF_DEBUGGING_INFO\n@@ -2004,19 +2010,70 @@ record_constant_1 (exp)\n   obstack_grow (&permanent_obstack, strp, len);\n }\n \f\n+/* Record a list of constant expressions that were passed to\n+   output_constant_def but that could not be output right away.  */\n+\n+struct deferred_constant\n+{\n+  struct deferred_constant *next;\n+  tree exp;\n+  int reloc;\n+  int labelno;\n+};\n+\n+static struct deferred_constant *deferred_constants;\n+\n+/* Nonzero means defer output of addressed subconstants\n+   (i.e., those for which output_constant_def is called.)  */\n+static int defer_addressed_constants_flag;\n+\n+/* Start deferring output of subconstants.  */\n+\n+void\n+defer_addressed_constants ()\n+{\n+  defer_addressed_constants_flag++;\n+}\n+\n+/* Stop deferring output of subconstants,\n+   and output now all those that have been deferred.  */\n+\n+void\n+output_deferred_addressed_constants ()\n+{\n+  struct deferred_constant *p, *next;\n+\n+  defer_addressed_constants_flag--;\n+\n+  if (defer_addressed_constants_flag > 0)\n+    return;\n+\n+  for (p = deferred_constants; p; p = next)\n+    {\n+      output_constant_def_contents (p->exp, p->reloc, p->labelno);\n+      next = p->next;\n+      free (p);\n+    }\n+\n+  deferred_constants = 0;\n+}\n+\f\n /* Return an rtx representing a reference to constant data in memory\n    for the constant expression EXP.\n+\n    If assembler code for such a constant has already been output,\n    return an rtx to refer to it.\n-   Otherwise, output such a constant in memory and generate\n-   an rtx for it.  The TREE_CST_RTL of EXP is set up to point to that rtx.\n+   Otherwise, output such a constant in memory (or defer it for later)\n+   and generate an rtx for it.\n+\n+   The TREE_CST_RTL of EXP is set up to point to that rtx.\n    The const_hash_table records which constants already have label strings.  */\n \n rtx\n output_constant_def (exp)\n      tree exp;\n {\n-  register int hash, align;\n+  register int hash;\n   register struct constant_descriptor *desc;\n   char label[256];\n   char *found = 0;\n@@ -2090,44 +2147,77 @@ output_constant_def (exp)\n   ENCODE_SECTION_INFO (exp);\n #endif\n \n+  /* If this is the first time we've seen this particular constant,\n+     output it (or defer its output for later).  */\n   if (found == 0)\n     {\n-      /* Now output assembler code to define that label\n-\t and follow it with the data of EXP.  */\n+      if (defer_addressed_constants_flag)\n+\t{\n+\t  struct deferred_constant *p;\n+\t  p = (struct deferred_constant *) xmalloc (sizeof (struct deferred_constant));\n+\n+\t  /* We really should copy trees in depth here,\n+\t     but since this case is the only one that should happen now,\n+\t     let's do it later.  */\n+\t  if (TREE_CODE (exp) != STRING_CST)\n+\t    abort ();\n+\n+\t  push_obstacks_nochange ();\n+\t  suspend_momentary ();\n+\t  p->exp = copy_node (exp);\n+\t  pop_obstacks ();\n+\t  p->reloc = reloc;\n+\t  p->labelno = const_labelno++;\n+\t  p->next = deferred_constants;\n+\t  deferred_constants = p;\n+\t}\n+      else\n+\toutput_constant_def_contents (exp, reloc, const_labelno++);\n+    }\n+\n+  return TREE_CST_RTL (exp);\n+}\n+\n+/* Now output assembler code to define the label for EXP,\n+   and follow it with the data of EXP.  */\n+\n+static void\n+output_constant_def_contents (exp, reloc, labelno)\n+     tree exp;\n+     int reloc;\n+     int labelno;\n+{\n+  int align;\n \n-      /* First switch to text section, except for writable strings.  */\n+  /* First switch to text section, except for writable strings.  */\n #ifdef SELECT_SECTION\n-      SELECT_SECTION (exp, reloc);\n+  SELECT_SECTION (exp, reloc);\n #else\n-      if (((TREE_CODE (exp) == STRING_CST) && flag_writable_strings)\n-\t  || (flag_pic && reloc))\n-\tdata_section ();\n-      else\n-\treadonly_data_section ();\n+  if (((TREE_CODE (exp) == STRING_CST) && flag_writable_strings)\n+      || (flag_pic && reloc))\n+    data_section ();\n+  else\n+    readonly_data_section ();\n #endif\n \n-      /* Align the location counter as required by EXP's data type.  */\n-      align = TYPE_ALIGN (TREE_TYPE (exp));\n+  /* Align the location counter as required by EXP's data type.  */\n+  align = TYPE_ALIGN (TREE_TYPE (exp));\n #ifdef CONSTANT_ALIGNMENT\n-      align = CONSTANT_ALIGNMENT (exp, align);\n+  align = CONSTANT_ALIGNMENT (exp, align);\n #endif\n \n-      if (align > BITS_PER_UNIT)\n-\tASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n-\n-      /* Output the label itself.  */\n-      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LC\", const_labelno);\n+  if (align > BITS_PER_UNIT)\n+    ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n \n-      /* Output the value of EXP.  */\n-      output_constant (exp,\n-\t\t       (TREE_CODE (exp) == STRING_CST\n-\t\t\t? TREE_STRING_LENGTH (exp)\n-\t\t\t: int_size_in_bytes (TREE_TYPE (exp))));\n+  /* Output the label itself.  */\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LC\", labelno);\n \n-      ++const_labelno;\n-    }\n+  /* Output the value of EXP.  */\n+  output_constant (exp,\n+\t\t   (TREE_CODE (exp) == STRING_CST\n+\t\t    ? TREE_STRING_LENGTH (exp)\n+\t\t    : int_size_in_bytes (TREE_TYPE (exp))));\n \n-  return TREE_CST_RTL (exp);\n }\n \f\n /* Similar hash facility for making memory-constants"}]}