{"sha": "74aa8b4b45a6d65fbd9a05545bcc5372967d5a74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRhYThiNGI0NWE2ZDY1ZmJkOWEwNTU0NWJjYzUzNzI5NjdkNWE3NA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2006-03-27T13:15:46Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2006-03-27T13:15:46Z"}, "message": "s390-protos.h (s390_hard_regno_mode_ok, [...]): New function prototypes.\n\n2006-03-27  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* config/s390/s390-protos.h (s390_hard_regno_mode_ok, \n\ts390_class_max_nregs): New function prototypes.\n\t* config/s390/s390.c (REGNO_PAIR_OK): New macro.\n\t(s390_hard_regno_mode_ok, s390_class_max_nregs): New functions.\n\t* config/s390/s390.h (HARD_REGNO_NREGS, HARD_REGNO_MODE_OK,\n\tCLASS_MAX_NREGS): Macro bodies replaced by function calls.\n\nFrom-SVN: r112418", "tree": {"sha": "e49ac34d5165f889dc922d691bfa895e8c3abd37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e49ac34d5165f889dc922d691bfa895e8c3abd37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74aa8b4b45a6d65fbd9a05545bcc5372967d5a74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74aa8b4b45a6d65fbd9a05545bcc5372967d5a74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74aa8b4b45a6d65fbd9a05545bcc5372967d5a74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74aa8b4b45a6d65fbd9a05545bcc5372967d5a74/comments", "author": null, "committer": null, "parents": [{"sha": "8370d5bcb1e3a2fd2445bbc8ee7db50d199e3ad1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8370d5bcb1e3a2fd2445bbc8ee7db50d199e3ad1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8370d5bcb1e3a2fd2445bbc8ee7db50d199e3ad1"}], "stats": {"total": 128, "additions": 92, "deletions": 36}, "files": [{"sha": "45cac9db8749d76b3c9172cd45df628c9d0c7b79", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74aa8b4b45a6d65fbd9a05545bcc5372967d5a74/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74aa8b4b45a6d65fbd9a05545bcc5372967d5a74/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=74aa8b4b45a6d65fbd9a05545bcc5372967d5a74", "patch": "@@ -1,3 +1,12 @@\n+2006-03-27  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* config/s390/s390-protos.h (s390_hard_regno_mode_ok, \n+\ts390_class_max_nregs): New function prototypes.\n+\t* config/s390/s390.c (REGNO_PAIR_OK): New macro.\n+\t(s390_hard_regno_mode_ok, s390_class_max_nregs): New functions.\n+\t* config/s390/s390.h (HARD_REGNO_NREGS, HARD_REGNO_MODE_OK,\n+\tCLASS_MAX_NREGS): Macro bodies replaced by function calls.\n+\n 2006-03-26  Geoffrey Keating  <geoffk@apple.com>\n \n \t* dwarf2out.c (add_location_or_const_value_attribute): Call"}, {"sha": "4e432640a573adeb372f85c31c2be6a9e035bdc2", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74aa8b4b45a6d65fbd9a05545bcc5372967d5a74/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74aa8b4b45a6d65fbd9a05545bcc5372967d5a74/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=74aa8b4b45a6d65fbd9a05545bcc5372967d5a74", "patch": "@@ -30,7 +30,9 @@ extern void s390_emit_epilogue (bool);\n extern void s390_function_profiler (FILE *, int);\n extern void s390_conditional_register_usage (void);\n extern void s390_set_has_landing_pad_p (bool);\n+extern bool s390_hard_regno_mode_ok (unsigned int, enum machine_mode);\n extern bool s390_hard_regno_rename_ok (unsigned int, unsigned int);\n+extern bool s390_class_max_nregs (enum reg_class, enum machine_mode);\n \n #ifdef RTX_CODE\n extern int s390_extra_constraint_str (rtx, int, const char *);"}, {"sha": "1ee6fba6add21a6844afbac8547170bb08db0ef8", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74aa8b4b45a6d65fbd9a05545bcc5372967d5a74/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74aa8b4b45a6d65fbd9a05545bcc5372967d5a74/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=74aa8b4b45a6d65fbd9a05545bcc5372967d5a74", "patch": "@@ -331,6 +331,9 @@ struct machine_function GTY(())\n #define CONST_OK_FOR_On(x) \\\n         CONST_OK_FOR_CONSTRAINT_P((x), 'O', \"On\")\n \n+#define REGNO_PAIR_OK(REGNO, MODE)                               \\\n+  (HARD_REGNO_NREGS ((REGNO), (MODE)) == 1 || !((REGNO) & 1))\n+\n /* Set the has_landing_pad_p flag in struct machine_function to VALUE.  */\n \n void\n@@ -6753,6 +6756,54 @@ s390_update_frame_layout (void)\n     regs_ever_live[REGNO (cfun->machine->base_reg)] = 1;\n }\n \n+/* Return true if it is legal to put a value with MODE into REGNO.  */\n+\n+bool\n+s390_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n+{\n+  switch (REGNO_REG_CLASS (regno))\n+    {\n+    case FP_REGS:\n+      if (REGNO_PAIR_OK (regno, mode))\n+\t{\n+\t  if (mode == SImode || mode == DImode)\n+\t    return true;\n+\n+\t  if (FLOAT_MODE_P (mode) && GET_MODE_CLASS (mode) != MODE_VECTOR_FLOAT)\n+\t    return true;\n+\t}\n+      break;\n+    case ADDR_REGS:\n+      if (FRAME_REGNO_P (regno) && mode == Pmode)\n+\treturn true;\n+\n+      /* fallthrough */\n+    case GENERAL_REGS:\n+      if (REGNO_PAIR_OK (regno, mode))\n+\t{\n+\t  if (TARGET_64BIT \n+\t      || (mode != TFmode && mode != TCmode))\n+\t    return true;\n+\t}\t  \n+      break;\n+    case CC_REGS:\n+      if (GET_MODE_CLASS (mode) == MODE_CC)\n+\treturn true;\n+      break;\n+    case ACCESS_REGS:\n+      if (REGNO_PAIR_OK (regno, mode))\n+\t{\n+\t  if (mode == SImode || mode == Pmode)\n+\t    return true;\n+\t}\n+      break;\n+    default:\n+      return false;\n+    }\n+  \n+  return false;\n+}\n+\n /* Return nonzero if register OLD_REG can be renamed to register NEW_REG.  */\n \n bool\n@@ -6768,6 +6819,27 @@ s390_hard_regno_rename_ok (unsigned int old_reg, unsigned int new_reg)\n   return true;\n }\n \n+/* Maximum number of registers to represent a value of mode MODE\n+   in a register of class CLASS.  */\n+\n+bool\n+s390_class_max_nregs (enum reg_class class, enum machine_mode mode)\n+{\n+  switch (class)\n+    {\n+    case FP_REGS:\n+      if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n+\treturn 2 * ((GET_MODE_SIZE (mode) / 2 + 8 - 1) / 8);\n+      else\n+\treturn (GET_MODE_SIZE (mode) + 8 - 1) / 8;\n+    case ACCESS_REGS:\n+      return (GET_MODE_SIZE (mode) + 4 - 1) / 4;\n+    default:\n+      break;\n+    }\n+  return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+}\n+\n /* Return true if register FROM can be eliminated via register TO.  */\n \n bool"}, {"sha": "2f9b7d0f527011c67979599b6f8abbfe5f658500", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 9, "deletions": 36, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74aa8b4b45a6d65fbd9a05545bcc5372967d5a74/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74aa8b4b45a6d65fbd9a05545bcc5372967d5a74/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=74aa8b4b45a6d65fbd9a05545bcc5372967d5a74", "patch": "@@ -355,36 +355,15 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n \n    Condition code modes fit only into the CC register.  */\n \n+/* Because all registers in a class have the same size HARD_REGNO_NREGS\n+   is equivalent to CLASS_MAX_NREGS.  */\n #define HARD_REGNO_NREGS(REGNO, MODE)                           \\\n-  (FP_REGNO_P(REGNO)?                                           \\\n-   (GET_MODE_CLASS(MODE) == MODE_COMPLEX_FLOAT ?                \\\n-    2 * ((GET_MODE_SIZE(MODE) / 2 + 8 - 1) / 8) : \t\t\\\n-    ((GET_MODE_SIZE(MODE) + 8 - 1) / 8)) :\t\t\t\\\n-   GENERAL_REGNO_P(REGNO)?                                      \\\n-    ((GET_MODE_SIZE(MODE)+UNITS_PER_WORD-1) / UNITS_PER_WORD) : \\\n-   ACCESS_REGNO_P(REGNO)?\t\t\t\t\t\\\n-    ((GET_MODE_SIZE(MODE) + 4 - 1) / 4) : \t\t\t\\\n-   1)\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)                             \\\n-  (FP_REGNO_P(REGNO)?                                               \\\n-   (((MODE) == SImode || (MODE) == DImode                           \\\n-     || GET_MODE_CLASS(MODE) == MODE_FLOAT                          \\\n-     || GET_MODE_CLASS(MODE) == MODE_COMPLEX_FLOAT)                 \\\n-    && (HARD_REGNO_NREGS(REGNO, MODE) == 1 || !((REGNO) & 1))) :    \\\n-   GENERAL_REGNO_P(REGNO)?                                          \\\n-   ((HARD_REGNO_NREGS(REGNO, MODE) == 1 || !((REGNO) & 1))\t    \\\n-    && (((MODE) != TFmode && (MODE) != TCmode) || TARGET_64BIT)) :  \\\n-   CC_REGNO_P(REGNO)?                                               \\\n-     GET_MODE_CLASS (MODE) == MODE_CC :                             \\\n-   FRAME_REGNO_P(REGNO)?                                            \\\n-     (enum machine_mode) (MODE) == Pmode :                          \\\n-   ACCESS_REGNO_P(REGNO)?\t\t\t\t\t    \\\n-     (((MODE) == SImode || ((enum machine_mode) (MODE) == Pmode))   \\\n-      && (HARD_REGNO_NREGS(REGNO, MODE) == 1 || !((REGNO) & 1))) :  \\\n-   0)\n-\n-#define HARD_REGNO_RENAME_OK(FROM, TO) \\\n+  s390_class_max_nregs (REGNO_REG_CLASS (REGNO), (MODE))\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)         \\\n+  s390_hard_regno_mode_ok ((REGNO), (MODE))\n+\n+#define HARD_REGNO_RENAME_OK(FROM, TO)          \\\n   s390_hard_regno_rename_ok (FROM, TO)\n \n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\\\n@@ -394,13 +373,7 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n /* Maximum number of registers to represent a value of mode MODE\n    in a register of class CLASS.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)   \t\t\t\t\t\\\n-     ((CLASS) == FP_REGS ? \t\t\t\t\t\t\\\n-      (GET_MODE_CLASS(MODE) == MODE_COMPLEX_FLOAT ?                     \\\n-       2 * (GET_MODE_SIZE (MODE) / 2 + 8 - 1) / 8 :\t\t        \\\n-       (GET_MODE_SIZE (MODE) + 8 - 1) / 8) :\t\t\t\t\\\n-      (CLASS) == ACCESS_REGS ?\t\t\t\t\t\t\\\n-      (GET_MODE_SIZE (MODE) + 4 - 1) / 4 :\t\t\t\t\\\n-      (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+  s390_class_max_nregs ((CLASS), (MODE))\n \n /* If a 4-byte value is loaded into a FPR, it is placed into the\n    *upper* half of the register, not the lower.  Therefore, we"}]}