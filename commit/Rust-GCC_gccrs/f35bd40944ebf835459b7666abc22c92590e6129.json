{"sha": "f35bd40944ebf835459b7666abc22c92590e6129", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM1YmQ0MDk0NGViZjgzNTQ1OWI3NjY2YWJjMjJjOTI1OTBlNjEyOQ==", "commit": {"author": {"name": "Ghjuvan Lacambre", "email": "lacambre@adacore.com", "date": "2020-06-18T08:29:35Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-27T08:05:20Z"}, "message": "[Ada] Refactor pragma argument getters\n\ngcc/ada/\n\n\t* exp_prag.adb (Arg1, Arg2, Arg3): Removed.\n\t(Arg_N): New function.", "tree": {"sha": "6a67f47c094febe15bbff8b71b70c801e8218233", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a67f47c094febe15bbff8b71b70c801e8218233"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f35bd40944ebf835459b7666abc22c92590e6129", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f35bd40944ebf835459b7666abc22c92590e6129", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f35bd40944ebf835459b7666abc22c92590e6129", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f35bd40944ebf835459b7666abc22c92590e6129/comments", "author": {"login": "glacambre", "id": 11534587, "node_id": "MDQ6VXNlcjExNTM0NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/11534587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glacambre", "html_url": "https://github.com/glacambre", "followers_url": "https://api.github.com/users/glacambre/followers", "following_url": "https://api.github.com/users/glacambre/following{/other_user}", "gists_url": "https://api.github.com/users/glacambre/gists{/gist_id}", "starred_url": "https://api.github.com/users/glacambre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glacambre/subscriptions", "organizations_url": "https://api.github.com/users/glacambre/orgs", "repos_url": "https://api.github.com/users/glacambre/repos", "events_url": "https://api.github.com/users/glacambre/events{/privacy}", "received_events_url": "https://api.github.com/users/glacambre/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c1bfc9e60e1f1e23746f6140611bbd463c4a9b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c1bfc9e60e1f1e23746f6140611bbd463c4a9b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c1bfc9e60e1f1e23746f6140611bbd463c4a9b5"}], "stats": {"total": 114, "additions": 33, "deletions": 81}, "files": [{"sha": "e978595d40357311de8b7083c798213e9b90bd7e", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 33, "deletions": 81, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f35bd40944ebf835459b7666abc22c92590e6129/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f35bd40944ebf835459b7666abc22c92590e6129/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=f35bd40944ebf835459b7666abc22c92590e6129", "patch": "@@ -61,9 +61,7 @@ package body Exp_Prag is\n    -- Local Subprograms --\n    -----------------------\n \n-   function Arg1 (N : Node_Id) return Node_Id;\n-   function Arg2 (N : Node_Id) return Node_Id;\n-   function Arg3 (N : Node_Id) return Node_Id;\n+   function Arg_N (N : Node_Id; Arg_Number : Positive) return Node_Id;\n    --  Obtain specified pragma argument expression\n \n    procedure Expand_Pragma_Abort_Defer             (N : Node_Id);\n@@ -84,80 +82,32 @@ package body Exp_Prag is\n    --  these cases we want no initialization to occur, but we have already done\n    --  the initialization by the time we see the pragma, so we have to undo it.\n \n-   ----------\n-   -- Arg1 --\n-   ----------\n+   -----------\n+   -- Arg_N --\n+   -----------\n \n-   function Arg1 (N : Node_Id) return Node_Id is\n-      Arg : constant Node_Id := First (Pragma_Argument_Associations (N));\n+   function Arg_N (N : Node_Id; Arg_Number : Positive) return Node_Id is\n+      Arg : Node_Id := First (Pragma_Argument_Associations (N));\n    begin\n+      if No (Arg) then\n+         return Empty;\n+      end if;\n+\n+      for J in 2 .. Arg_Number loop\n+         Next (Arg);\n+         if No (Arg) then\n+            return Empty;\n+         end if;\n+      end loop;\n+\n       if Present (Arg)\n         and then Nkind (Arg) = N_Pragma_Argument_Association\n       then\n          return Expression (Arg);\n       else\n          return Arg;\n       end if;\n-   end Arg1;\n-\n-   ----------\n-   -- Arg2 --\n-   ----------\n-\n-   function Arg2 (N : Node_Id) return Node_Id is\n-      Arg1 : constant Node_Id := First (Pragma_Argument_Associations (N));\n-\n-   begin\n-      if No (Arg1) then\n-         return Empty;\n-\n-      else\n-         declare\n-            Arg : constant Node_Id := Next (Arg1);\n-         begin\n-            if Present (Arg)\n-              and then Nkind (Arg) = N_Pragma_Argument_Association\n-            then\n-               return Expression (Arg);\n-            else\n-               return Arg;\n-            end if;\n-         end;\n-      end if;\n-   end Arg2;\n-\n-   ----------\n-   -- Arg3 --\n-   ----------\n-\n-   function Arg3 (N : Node_Id) return Node_Id is\n-      Arg1 : constant Node_Id := First (Pragma_Argument_Associations (N));\n-\n-   begin\n-      if No (Arg1) then\n-         return Empty;\n-\n-      else\n-         declare\n-            Arg : Node_Id := Next (Arg1);\n-         begin\n-            if No (Arg) then\n-               return Empty;\n-\n-            else\n-               Next (Arg);\n-\n-               if Present (Arg)\n-                 and then Nkind (Arg) = N_Pragma_Argument_Association\n-               then\n-                  return Expression (Arg);\n-               else\n-                  return Arg;\n-               end if;\n-            end if;\n-         end;\n-      end if;\n-   end Arg3;\n+   end Arg_N;\n \n    ---------------------\n    -- Expand_N_Pragma --\n@@ -317,8 +267,8 @@ package body Exp_Prag is\n    --------------------------\n \n    procedure Expand_Pragma_Check (N : Node_Id) is\n-      Cond : constant Node_Id := Arg2 (N);\n-      Nam  : constant Name_Id := Chars (Arg1 (N));\n+      Cond : constant Node_Id := Arg_N (N, 2);\n+      Nam  : constant Name_Id := Chars (Arg_N (N, 1));\n       Msg  : Node_Id;\n \n       Loc : constant Source_Ptr := Sloc (First_Node (Cond));\n@@ -477,7 +427,7 @@ package body Exp_Prag is\n       if ((Debug_Flag_Dot_G\n             or else Restriction_Active (No_Exception_Propagation))\n            and then Present (Find_Local_Handler (RTE (RE_Assert_Failure), N)))\n-        or else (Opt.Exception_Locations_Suppressed and then No (Arg3 (N)))\n+        or else (Opt.Exception_Locations_Suppressed and then No (Arg_N (N, 3)))\n       then\n          Rewrite (N,\n            Make_If_Statement (Loc,\n@@ -491,8 +441,8 @@ package body Exp_Prag is\n       else\n          --  If we have a message given, use it\n \n-         if Present (Arg3 (N)) then\n-            Msg := Get_Pragma_Arg (Arg3 (N));\n+         if Present (Arg_N (N, 3)) then\n+            Msg := Get_Pragma_Arg (Arg_N (N, 3));\n \n          --  Here we have no string, so prepare one\n \n@@ -615,8 +565,8 @@ package body Exp_Prag is\n    procedure Expand_Pragma_Common_Object (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n \n-      Internal : constant Node_Id := Arg1 (N);\n-      External : constant Node_Id := Arg2 (N);\n+      Internal : constant Node_Id := Arg_N (N, 1);\n+      External : constant Node_Id := Arg_N (N, 2);\n \n       Psect : Node_Id;\n       --  Psect value upper cased as string literal\n@@ -1380,11 +1330,11 @@ package body Exp_Prag is\n       if Relaxed_RM_Semantics\n         and then List_Length (Pragma_Argument_Associations (N)) = 2\n         and then Pragma_Name (N) = Name_Import\n-        and then Nkind (Arg2 (N)) = N_String_Literal\n+        and then Nkind (Arg_N (N, 2)) = N_String_Literal\n       then\n-         Def_Id := Entity (Arg1 (N));\n+         Def_Id := Entity (Arg_N (N, 1));\n       else\n-         Def_Id := Entity (Arg2 (N));\n+         Def_Id := Entity (Arg_N (N, 2));\n       end if;\n \n       --  Variable case (we have to undo any initialization already done)\n@@ -1401,7 +1351,7 @@ package body Exp_Prag is\n \n          declare\n             Loc          : constant Source_Ptr := Sloc (N);\n-            Rtti_Name    : constant Node_Id    := Arg3 (N);\n+            Rtti_Name    : constant Node_Id    := Arg_N (N, 3);\n             Dum          : constant Entity_Id  := Make_Temporary (Loc, 'D');\n             Exdata       : List_Id;\n             Lang_Char    : Node_Id;\n@@ -2219,7 +2169,9 @@ package body Exp_Prag is\n                           (Make_Function_Call\n                              (Loc, New_Occurrence_Of (RTE (RE_Clock), Loc)))),\n                     Right_Opnd  =>\n-                      Unchecked_Convert_To (Standard_Duration, Arg1 (N)))))));\n+                      Unchecked_Convert_To (\n+                        Standard_Duration,\n+                        Arg_N (N, 1)))))));\n \n          Analyze (N);\n       end if;\n@@ -2230,7 +2182,7 @@ package body Exp_Prag is\n    -------------------------------------------\n \n    procedure Expand_Pragma_Suppress_Initialization (N : Node_Id) is\n-      Def_Id : constant Entity_Id  := Entity (Arg1 (N));\n+      Def_Id : constant Entity_Id  := Entity (Arg_N (N, 1));\n \n    begin\n       --  Variable case (we have to undo any initialization already done)"}]}