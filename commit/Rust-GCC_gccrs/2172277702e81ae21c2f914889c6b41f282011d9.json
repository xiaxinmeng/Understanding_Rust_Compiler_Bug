{"sha": "2172277702e81ae21c2f914889c6b41f282011d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE3MjI3NzcwMmU4MWFlMjFjMmY5MTQ4ODljNmI0MWYyODIwMTFkOQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-06-06T18:46:20Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-06-06T18:46:20Z"}, "message": "tree-ssa-strlen.c (adjust_related_strinfos): Avoid trailing article.\n\n\ngcc/ChangeLog:\n\n\t* tree-ssa-strlen.c (adjust_related_strinfos): Avoid trailing article.\n\t(handle_builtin_malloc): Remove trailing spaces.\n\t(handle_builtin_memset): Same.\n\t(handle_builtin_memcmp): Same.\n\t(compute_string_length): Same.\n\t(determine_min_objsize): Same.\n\t(handle_builtin_string_cmp): Same.\n\t(handle_char_store): Same.  Break up excessively long line.\n\nFrom-SVN: r272016", "tree": {"sha": "6bdd01ca180424820319af9ce5a535ac3b75f597", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bdd01ca180424820319af9ce5a535ac3b75f597"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2172277702e81ae21c2f914889c6b41f282011d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2172277702e81ae21c2f914889c6b41f282011d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2172277702e81ae21c2f914889c6b41f282011d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2172277702e81ae21c2f914889c6b41f282011d9/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c56c86024f8fba0c286cd69c79e6b15ba82bf169", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c56c86024f8fba0c286cd69c79e6b15ba82bf169", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c56c86024f8fba0c286cd69c79e6b15ba82bf169"}], "stats": {"total": 127, "additions": 70, "deletions": 57}, "files": [{"sha": "37320f985d8e80cfc48d1a22afbf16d99d23caa9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2172277702e81ae21c2f914889c6b41f282011d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2172277702e81ae21c2f914889c6b41f282011d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2172277702e81ae21c2f914889c6b41f282011d9", "patch": "@@ -1,3 +1,14 @@\n+2019-06-06  Martin Sebor  <msebor@redhat.com>\n+\n+\t* tree-ssa-strlen.c (adjust_related_strinfos): Avoid trailing article.\n+\t(handle_builtin_malloc): Remove trailing spaces.\n+\t(handle_builtin_memset): Same.\n+\t(handle_builtin_memcmp): Same.\n+\t(compute_string_length): Same.\n+\t(determine_min_objsize): Same.\n+\t(handle_builtin_string_cmp): Same.\n+\t(handle_char_store): Same.  Break up excessively long line.\n+\n 2019-06-06  Martin Jambor  <mjambor@suse.cz>\n \n \t* tree-sra.c (build_reconstructed_reference): Drop the alignment"}, {"sha": "98d8420d8cf91217a14fac0296a09e90e74f81d3", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 59, "deletions": 57, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2172277702e81ae21c2f914889c6b41f282011d9/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2172277702e81ae21c2f914889c6b41f282011d9/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=2172277702e81ae21c2f914889c6b41f282011d9", "patch": "@@ -891,9 +891,9 @@ adjust_related_strinfos (location_t loc, strinfo *origsi, tree adj)\n \t  tree tem;\n \n \t  si = unshare_strinfo (si);\n-\t  /* We shouldn't see delayed lengths here; the caller must have\n-\t     calculated the old length in order to calculate the\n-\t     adjustment.  */\n+\t  /* We shouldn't see delayed lengths here; the caller must\n+\t     have calculated the old length in order to calculate\n+\t     the adjustment.  */\n \t  gcc_assert (si->nonzero_chars);\n \t  tem = fold_convert_loc (loc, TREE_TYPE (si->nonzero_chars), adj);\n \t  si->nonzero_chars = fold_build2_loc (loc, PLUS_EXPR,\n@@ -2759,7 +2759,7 @@ handle_builtin_malloc (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n \n /* Handle a call to memset.\n    After a call to calloc, memset(,0,) is unnecessary.\n-   memset(malloc(n),0,n) is calloc(n,1). \n+   memset(malloc(n),0,n) is calloc(n,1).\n    return true when the call is transfomred, false otherwise.  */\n \n static bool\n@@ -2815,7 +2815,7 @@ handle_builtin_memset (gimple_stmt_iterator *gsi)\n \n /* Handle a call to memcmp.  We try to handle small comparisons by\n    converting them to load and compare, and replacing the call to memcmp\n-   with a __builtin_memcmp_eq call where possible. \n+   with a __builtin_memcmp_eq call where possible.\n    return true when call is transformed, return false otherwise.  */\n \n static bool\n@@ -2898,13 +2898,13 @@ handle_builtin_memcmp (gimple_stmt_iterator *gsi)\n   return true;\n }\n \n-/* Given an index to the strinfo vector, compute the string length for the\n-   corresponding string. Return -1 when unknown.  */\n- \n-static HOST_WIDE_INT \n+/* Given an index to the strinfo vector, compute the string length\n+   for the corresponding string. Return -1 when unknown.  */\n+\n+static HOST_WIDE_INT\n compute_string_length (int idx)\n {\n-  HOST_WIDE_INT string_leni = -1; \n+  HOST_WIDE_INT string_leni = -1;\n   gcc_assert (idx != 0);\n \n   if (idx < 0)\n@@ -2924,9 +2924,9 @@ compute_string_length (int idx)\n   return string_leni;\n }\n \n-/* Determine the minimum size of the object referenced by DEST expression which\n-   must have a pointer type. \n-   Return the minimum size of the object if successful or NULL when the size \n+/* Determine the minimum size of the object referenced by DEST expression\n+   which must have a pointer type.\n+   Return the minimum size of the object if successful or NULL when the size\n    cannot be determined.  */\n static tree\n determine_min_objsize (tree dest)\n@@ -2936,8 +2936,8 @@ determine_min_objsize (tree dest)\n   if (compute_builtin_object_size (dest, 2, &size))\n     return build_int_cst (sizetype, size);\n \n-  /* Try to determine the size of the object through the RHS of the \n-     assign statement.  */\n+  /* Try to determine the size of the object through the RHS\n+     of the assign statement.  */\n   if (TREE_CODE (dest) == SSA_NAME)\n     {\n       gimple *stmt = SSA_NAME_DEF_STMT (dest);\n@@ -2962,33 +2962,33 @@ determine_min_objsize (tree dest)\n \n   type = TYPE_MAIN_VARIANT (type);\n \n-  /* We cannot determine the size of the array if it's a flexible array, \n+  /* We cannot determine the size of the array if it's a flexible array,\n      which is declared at the end of a structure.  */\n   if (TREE_CODE (type) == ARRAY_TYPE\n       && !array_at_struct_end_p (dest))\n     {\n       tree size_t = TYPE_SIZE_UNIT (type);\n-      if (size_t && TREE_CODE (size_t) == INTEGER_CST \n+      if (size_t && TREE_CODE (size_t) == INTEGER_CST\n \t  && !integer_zerop (size_t))\n         return size_t;\n     }\n \n   return NULL_TREE;\n }\n \n-/* Handle a call to strcmp or strncmp. When the result is ONLY used to do \n+/* Handle a call to strcmp or strncmp. When the result is ONLY used to do\n    equality test against zero:\n \n    A. When the lengths of both arguments are constant and it's a strcmp:\n       * if the lengths are NOT equal, we can safely fold the call\n         to a non-zero value.\n       * otherwise, do nothing now.\n-  \n-   B. When the length of one argument is constant, try to replace the call with\n-   a __builtin_str(n)cmp_eq call where possible, i.e:\n \n-   strncmp (s, STR, C) (!)= 0 in which, s is a pointer to a string, STR is a \n-   string with constant length , C is a constant.\n+   B. When the length of one argument is constant, try to replace the call\n+   with a __builtin_str(n)cmp_eq call where possible, i.e:\n+\n+   strncmp (s, STR, C) (!)= 0 in which, s is a pointer to a string, STR\n+   is a string with constant length , C is a constant.\n      if (C <= strlen(STR) && sizeof_array(s) > C)\n        {\n          replace this call with\n@@ -3000,16 +3000,16 @@ determine_min_objsize (tree dest)\n          can handled by the following strcmp.\n        }\n \n-   strcmp (s, STR) (!)= 0 in which, s is a pointer to a string, STR is a \n-   string with constant length.\n+   strcmp (s, STR) (!)= 0 in which, s is a pointer to a string, STR\n+   is a string with constant length.\n      if  (sizeof_array(s) > strlen(STR))\n        {\n          replace this call with\n          strcmp_eq (s, STR, strlen(STR)+1) (!)= 0\n        }\n \n-   Return true when the call is transformed, return false otherwise. \n- */ \n+   Return true when the call is transformed, return false otherwise.\n+ */\n \n static bool\n handle_builtin_string_cmp (gimple_stmt_iterator *gsi)\n@@ -3047,19 +3047,19 @@ handle_builtin_string_cmp (gimple_stmt_iterator *gsi)\n     return false;\n \n   /* When the result is ONLY used to do equality test against zero.  */\n-  FOR_EACH_IMM_USE_FAST (use_p, iter, res) \n-    {    \n+  FOR_EACH_IMM_USE_FAST (use_p, iter, res)\n+    {\n       gimple *use_stmt = USE_STMT (use_p);\n \n       if (is_gimple_debug (use_stmt))\n         continue;\n       if (gimple_code (use_stmt) == GIMPLE_ASSIGN)\n-\t{    \n+\t{\n \t  tree_code code = gimple_assign_rhs_code (use_stmt);\n-\t  if (code == COND_EXPR) \n+\t  if (code == COND_EXPR)\n \t    {\n \t      tree cond_expr = gimple_assign_rhs1 (use_stmt);\n-\t      if ((TREE_CODE (cond_expr) != EQ_EXPR \n+\t      if ((TREE_CODE (cond_expr) != EQ_EXPR\n \t\t   && (TREE_CODE (cond_expr) != NE_EXPR))\n \t\t  || !integer_zerop (TREE_OPERAND (cond_expr, 1)))\n \t\treturn false;\n@@ -3069,7 +3069,7 @@ handle_builtin_string_cmp (gimple_stmt_iterator *gsi)\n \t      if (!integer_zerop (gimple_assign_rhs2 (use_stmt)))\n \t\treturn false;\n             }\n-\t  else \n+\t  else\n \t    return false;\n \t}\n       else if (gimple_code (use_stmt) == GIMPLE_COND)\n@@ -3082,21 +3082,21 @@ handle_builtin_string_cmp (gimple_stmt_iterator *gsi)\n       else\n         return false;\n     }\n-  \n-  /* When the lengths of both arguments are known, and they are unequal, we can \n-     safely fold the call to a non-zero value for strcmp;\n+\n+  /* When the lengths of both arguments are known, and they are unequal,\n+     we can safely fold the call to a non-zero value for strcmp;\n      othewise, do nothing now.  */\n   if (idx1 != 0 && idx2 != 0)\n     {\n       HOST_WIDE_INT const_string_leni1 = compute_string_length (idx1);\n       HOST_WIDE_INT const_string_leni2 = compute_string_length (idx2);\n \n-      if (!is_ncmp \n+      if (!is_ncmp\n \t  && const_string_leni1 != -1\n \t  && const_string_leni2 != -1\n-\t  && const_string_leni1 != const_string_leni2) \n+\t  && const_string_leni1 != const_string_leni2)\n \t{\n-\t  replace_call_with_value (gsi, integer_one_node); \n+\t  replace_call_with_value (gsi, integer_one_node);\n \t  return true;\n \t}\n       return false;\n@@ -3105,56 +3105,56 @@ handle_builtin_string_cmp (gimple_stmt_iterator *gsi)\n   /* When the length of one argument is constant.  */\n   tree var_string = NULL_TREE;\n   HOST_WIDE_INT const_string_leni = -1;\n-  \n+\n   if (idx1)\n     {\n       const_string_leni = compute_string_length (idx1);\n       var_string = arg2;\n-    } \n-  else \n+    }\n+  else\n     {\n       gcc_checking_assert (idx2);\n       const_string_leni = compute_string_length (idx2);\n       var_string = arg1;\n-    } \n+    }\n \n-  if (const_string_leni < 0) \n+  if (const_string_leni < 0)\n     return false;\n- \n+\n   unsigned HOST_WIDE_INT var_sizei = 0;\n   /* try to determine the minimum size of the object pointed by var_string.  */\n   tree size = determine_min_objsize (var_string);\n \n   if (!size)\n     return false;\n- \n+\n   if (tree_fits_uhwi_p (size))\n     var_sizei = tree_to_uhwi (size);\n \n   if (var_sizei == 0)\n     return false;\n \n-  /* For strncmp, if length > const_string_leni , this call can be safely \n+  /* For strncmp, if length > const_string_leni , this call can be safely\n      transformed to a strcmp.  */\n   if (is_ncmp && length > const_string_leni)\n     is_ncmp = false;\n \n-  unsigned HOST_WIDE_INT final_length \n+  unsigned HOST_WIDE_INT final_length\n     = is_ncmp ? length : const_string_leni + 1;\n \n   /* Replace strcmp or strncmp with the corresponding str(n)cmp_eq.  */\n-  if (var_sizei > final_length) \n+  if (var_sizei > final_length)\n     {\n-      tree fn \n-\t= (is_ncmp \n-\t   ? builtin_decl_implicit (BUILT_IN_STRNCMP_EQ) \n+      tree fn\n+\t= (is_ncmp\n+\t   ? builtin_decl_implicit (BUILT_IN_STRNCMP_EQ)\n \t   : builtin_decl_implicit (BUILT_IN_STRCMP_EQ));\n       if (!fn)\n \treturn false;\n-      tree const_string_len = build_int_cst (size_type_node, final_length); \n+      tree const_string_len = build_int_cst (size_type_node, final_length);\n       update_gimple_call (gsi, fn, 3, arg1, arg2, const_string_len);\n     }\n-  else \n+  else\n     return false;\n \n   return true;\n@@ -3355,7 +3355,7 @@ handle_char_store (gimple_stmt_iterator *gsi)\n \t and if we aren't storing '\\0', we know that the length of the\n \t string and any other zero terminated string in memory remains\n \t the same.  In that case we move to the next gimple statement and\n-\t return to signal the caller that it shouldn't invalidate anything.  \n+\t return to signal the caller that it shouldn't invalidate anything.\n \n \t This is benefical for cases like:\n \n@@ -3370,13 +3370,15 @@ handle_char_store (gimple_stmt_iterator *gsi)\n \t   size_t len4 = strlen (q);        // This can be optimized into len2\n \t   bar (len, len2, len3, len4);\n         }\n-\t*/ \n+\t*/\n       else if (storing_nonzero_p && cmp > 0)\n \t{\n \t  gsi_next (gsi);\n \t  return false;\n \t}\n-      else if (storing_all_zeros_p || storing_nonzero_p || (offset != 0 && cmp > 0))\n+      else if (storing_all_zeros_p\n+\t       || storing_nonzero_p\n+\t       || (offset != 0 && cmp > 0))\n \t{\n \t  /* When STORING_NONZERO_P, we know that the string will start\n \t     with at least OFFSET + 1 nonzero characters.  If storing"}]}