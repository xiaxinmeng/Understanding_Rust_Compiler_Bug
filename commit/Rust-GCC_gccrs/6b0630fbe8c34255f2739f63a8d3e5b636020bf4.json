{"sha": "6b0630fbe8c34255f2739f63a8d3e5b636020bf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmIwNjMwZmJlOGMzNDI1NWYyNzM5ZjYzYThkM2U1YjYzNjAyMGJmNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T08:59:18Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T08:59:18Z"}, "message": "poly_int: vec_perm_indices element type\n\nThis patch changes the vec_perm_indices element type from HOST_WIDE_INT\nto poly_int64, so that it can represent indices into a variable-length\nvector.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* vec-perm-indices.h (vec_perm_builder): Change element type\n\tfrom HOST_WIDE_INT to poly_int64.\n\t(vec_perm_indices::element_type): Update accordingly.\n\t(vec_perm_indices::clamp): Handle polynomial element_types.\n\t* vec-perm-indices.c (vec_perm_indices::series_p): Likewise.\n\t(vec_perm_indices::all_in_range_p): Likewise.\n\t(tree_to_vec_perm_builder): Check for poly_int64 trees rather\n\tthan shwi trees.\n\t* vector-builder.h (vector_builder::stepped_sequence_p): Handle\n\tpolynomial vec_perm_indices element types.\n\t* int-vector-builder.h (int_vector_builder::equal_p): Likewise.\n\t* fold-const.c (fold_vec_perm): Likewise.\n\t* optabs.c (shift_amt_for_vec_perm_mask): Likewise.\n\t* tree-vect-generic.c (lower_vec_perm): Likewise.\n\t* tree-vect-slp.c (vect_transform_slp_perm_load): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_evpc_tbl): Cast d->perm\n\telement type to HOST_WIDE_INT.\n\nFrom-SVN: r256164", "tree": {"sha": "e12d59269ca650f27b7141a5e825d503877ad63c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e12d59269ca650f27b7141a5e825d503877ad63c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b0630fbe8c34255f2739f63a8d3e5b636020bf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b0630fbe8c34255f2739f63a8d3e5b636020bf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b0630fbe8c34255f2739f63a8d3e5b636020bf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/comments", "author": null, "committer": null, "parents": [{"sha": "9f61be58cec631ded93e6b71940dacd14ce3f3f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f61be58cec631ded93e6b71940dacd14ce3f3f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f61be58cec631ded93e6b71940dacd14ce3f3f5"}], "stats": {"total": 96, "additions": 66, "deletions": 30}, "files": [{"sha": "bc93660d1af8ce8ee13fdec97abe6292e2a154ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b0630fbe8c34255f2739f63a8d3e5b636020bf4", "patch": "@@ -1,3 +1,23 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* vec-perm-indices.h (vec_perm_builder): Change element type\n+\tfrom HOST_WIDE_INT to poly_int64.\n+\t(vec_perm_indices::element_type): Update accordingly.\n+\t(vec_perm_indices::clamp): Handle polynomial element_types.\n+\t* vec-perm-indices.c (vec_perm_indices::series_p): Likewise.\n+\t(vec_perm_indices::all_in_range_p): Likewise.\n+\t(tree_to_vec_perm_builder): Check for poly_int64 trees rather\n+\tthan shwi trees.\n+\t* vector-builder.h (vector_builder::stepped_sequence_p): Handle\n+\tpolynomial vec_perm_indices element types.\n+\t* int-vector-builder.h (int_vector_builder::equal_p): Likewise.\n+\t* fold-const.c (fold_vec_perm): Likewise.\n+\t* optabs.c (shift_amt_for_vec_perm_mask): Likewise.\n+\t* tree-vect-generic.c (lower_vec_perm): Likewise.\n+\t* tree-vect-slp.c (vect_transform_slp_perm_load): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_evpc_tbl): Cast d->perm\n+\telement type to HOST_WIDE_INT.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "1fc57a218b7e1aa38b4b4f1f08edc85cc999193c", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=6b0630fbe8c34255f2739f63a8d3e5b636020bf4", "patch": "@@ -13625,7 +13625,7 @@ aarch64_evpc_tbl (struct expand_vec_perm_d *d)\n \t mode on NEON.  Reverse the index within each word but not the word\n \t itself.  */\n       rperm[i] = GEN_INT (BYTES_BIG_ENDIAN ? d->perm[i] ^ (nunits - 1)\n-\t\t\t\t\t   : d->perm[i]);\n+\t\t\t\t\t   : (HOST_WIDE_INT) d->perm[i]);\n     }\n   sel = gen_rtx_CONST_VECTOR (vmode, gen_rtvec_v (nelt, rperm));\n   sel = force_reg (vmode, sel);"}, {"sha": "6c13d6d34039c3603077b6ff3f8f92cd4939e66c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6b0630fbe8c34255f2739f63a8d3e5b636020bf4", "patch": "@@ -8945,9 +8945,12 @@ fold_vec_perm (tree type, tree arg0, tree arg1, const vec_perm_indices &sel)\n   tree_vector_builder out_elts (type, nelts, 1);\n   for (i = 0; i < nelts; i++)\n     {\n-      if (!CONSTANT_CLASS_P (in_elts[sel[i]]))\n+      HOST_WIDE_INT index;\n+      if (!sel[i].is_constant (&index))\n+\treturn NULL_TREE;\n+      if (!CONSTANT_CLASS_P (in_elts[index]))\n \tneed_ctor = true;\n-      out_elts.quick_push (unshare_expr (in_elts[sel[i]]));\n+      out_elts.quick_push (unshare_expr (in_elts[index]));\n     }\n \n   if (need_ctor)"}, {"sha": "30a8ae18321d049d70afa8abcab48125989c25d6", "filename": "gcc/int-vector-builder.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2Fint-vector-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2Fint-vector-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fint-vector-builder.h?ref=6b0630fbe8c34255f2739f63a8d3e5b636020bf4", "patch": "@@ -66,7 +66,7 @@ template<typename T>\n inline bool\n int_vector_builder<T>::equal_p (T elt1, T elt2) const\n {\n-  return elt1 == elt2;\n+  return known_eq (elt1, elt2);\n }\n \n /* Return the value of element ELT2 minus the value of element ELT1.  */"}, {"sha": "5706205069e4488fdb938adf0fbca3ee733679b4", "filename": "gcc/optabs.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=6b0630fbe8c34255f2739f63a8d3e5b636020bf4", "patch": "@@ -5398,16 +5398,18 @@ shift_amt_for_vec_perm_mask (machine_mode mode, const vec_perm_indices &sel)\n {\n   unsigned int nelt = GET_MODE_NUNITS (mode);\n   unsigned int bitsize = GET_MODE_UNIT_BITSIZE (mode);\n-  unsigned int first = sel[0];\n-  if (first >= nelt)\n+  poly_int64 first = sel[0];\n+  if (maybe_ge (sel[0], nelt))\n     return NULL_RTX;\n \n   if (!sel.series_p (0, 1, first, 1))\n     for (unsigned int i = 1; i < nelt; i++)\n       {\n-\tunsigned int expected = i + first;\n+\tpoly_int64 expected = i + first;\n \t/* Indices into the second vector are all equivalent.  */\n-\tif (MIN (nelt, sel[i]) != MIN (nelt, expected))\n+\tif (maybe_lt (sel[i], nelt)\n+\t    ? maybe_ne (sel[i], expected)\n+\t    : maybe_lt (expected, nelt))\n \t  return NULL_RTX;\n       }\n "}, {"sha": "a9a6640687b767a3d88e4d53c66cfa43666efe7d", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=6b0630fbe8c34255f2739f63a8d3e5b636020bf4", "patch": "@@ -1337,18 +1337,19 @@ lower_vec_perm (gimple_stmt_iterator *gsi)\n \t  != CODE_FOR_nothing\n \t  && TREE_CODE (vec1) == VECTOR_CST\n \t  && initializer_zerop (vec1)\n-\t  && indices[0]\n-\t  && indices[0] < elements)\n+\t  && maybe_ne (indices[0], 0)\n+\t  && known_lt (indices[0], elements))\n \t{\n \t  bool ok_p = indices.series_p (0, 1, indices[0], 1);\n \t  if (!ok_p)\n \t    {\n \t      for (i = 1; i < elements; ++i)\n \t\t{\n-\t\t  unsigned int expected = i + indices[0];\n+\t\t  poly_int64 expected = i + indices[0];\n \t\t  /* Indices into the second vector are all equivalent.  */\n-\t\t  if (MIN (elements, (unsigned) indices[i])\n-\t\t      != MIN (elements, expected))\n+\t\t  if (maybe_lt (indices[i], elements)\n+\t\t      ? maybe_ne (indices[i], expected)\n+\t\t      : maybe_lt (expected, elements))\n \t\t    break;\n \t\t}\n \t      ok_p = i == elements;"}, {"sha": "5da3e156d5dd2b8cb0c6ed034a43174c7c9fe484", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=6b0630fbe8c34255f2739f63a8d3e5b636020bf4", "patch": "@@ -3727,8 +3727,10 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \t\t\t\t       vect_location, \n \t\t\t\t       \"unsupported vect permute { \");\n \t\t      for (i = 0; i < nunits; ++i)\n-\t\t\tdump_printf (MSG_MISSED_OPTIMIZATION,\n-\t\t\t\t     HOST_WIDE_INT_PRINT_DEC \" \", mask[i]);\n+\t\t\t{\n+\t\t\t  dump_dec (MSG_MISSED_OPTIMIZATION, mask[i]);\n+\t\t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \" \");\n+\t\t\t}\n \t\t      dump_printf (MSG_MISSED_OPTIMIZATION, \"}\\n\");\n \t\t    }\n \t\t  gcc_assert (analyze_only);"}, {"sha": "2bcac72e5a899c26a96c66d6d43fdbe725e4ea98", "filename": "gcc/vec-perm-indices.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2Fvec-perm-indices.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2Fvec-perm-indices.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec-perm-indices.c?ref=6b0630fbe8c34255f2739f63a8d3e5b636020bf4", "patch": "@@ -95,7 +95,7 @@ vec_perm_indices::series_p (unsigned int out_base, unsigned int out_step,\n \t\t\t    element_type in_base, element_type in_step) const\n {\n   /* Check the base value.  */\n-  if (clamp (m_encoding.elt (out_base)) != clamp (in_base))\n+  if (maybe_ne (clamp (m_encoding.elt (out_base)), clamp (in_base)))\n     return false;\n \n   unsigned int full_nelts = m_encoding.full_nelts ();\n@@ -127,7 +127,7 @@ vec_perm_indices::series_p (unsigned int out_base, unsigned int out_step,\n \n       element_type v0 = m_encoding.elt (out_base - out_step);\n       element_type v1 = m_encoding.elt (out_base);\n-      if (clamp (v1 - v0) != in_step)\n+      if (maybe_ne (clamp (v1 - v0), in_step))\n \treturn false;\n \n       out_base += out_step;\n@@ -146,7 +146,7 @@ vec_perm_indices::all_in_range_p (element_type start, element_type size) const\n   unsigned int nelts_per_pattern = m_encoding.nelts_per_pattern ();\n   unsigned int base_nelts = npatterns * MIN (nelts_per_pattern, 2);\n   for (unsigned int i = 0; i < base_nelts; ++i)\n-    if (m_encoding[i] < start || (m_encoding[i] - start) >= size)\n+    if (!known_in_range_p (m_encoding[i], start, size))\n       return false;\n \n   /* For stepped encodings, check the full range of the series.  */\n@@ -174,8 +174,11 @@ vec_perm_indices::all_in_range_p (element_type start, element_type size) const\n \t     wide enough for overflow not to be a problem.  */\n \t  element_type headroom_down = base1 - start;\n \t  element_type headroom_up = size - headroom_down - 1;\n-\t  if (headroom_up < step * step_nelts\n-\t      && headroom_down < (limit - step) * step_nelts)\n+\t  HOST_WIDE_INT diff;\n+\t  if ((!step.is_constant (&diff)\n+\t       || maybe_lt (headroom_up, diff * step_nelts))\n+\t      && (!(limit - step).is_constant (&diff)\n+\t\t  || maybe_lt (headroom_down, diff * step_nelts)))\n \t    return false;\n \t}\n     }\n@@ -191,14 +194,14 @@ tree_to_vec_perm_builder (vec_perm_builder *builder, tree cst)\n {\n   unsigned int encoded_nelts = vector_cst_encoded_nelts (cst);\n   for (unsigned int i = 0; i < encoded_nelts; ++i)\n-    if (!tree_fits_shwi_p (VECTOR_CST_ENCODED_ELT (cst, i)))\n+    if (!tree_fits_poly_int64_p (VECTOR_CST_ENCODED_ELT (cst, i)))\n       return false;\n \n   builder->new_vector (TYPE_VECTOR_SUBPARTS (TREE_TYPE (cst)),\n \t\t       VECTOR_CST_NPATTERNS (cst),\n \t\t       VECTOR_CST_NELTS_PER_PATTERN (cst));\n   for (unsigned int i = 0; i < encoded_nelts; ++i)\n-    builder->quick_push (tree_to_shwi (VECTOR_CST_ENCODED_ELT (cst, i)));\n+    builder->quick_push (tree_to_poly_int64 (VECTOR_CST_ENCODED_ELT (cst, i)));\n   return true;\n }\n "}, {"sha": "0b5478207113e14bd7f656fa14efc0422e729544", "filename": "gcc/vec-perm-indices.h", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2Fvec-perm-indices.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2Fvec-perm-indices.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec-perm-indices.h?ref=6b0630fbe8c34255f2739f63a8d3e5b636020bf4", "patch": "@@ -25,7 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n /* A vector_builder for building constant permutation vectors.\n    The elements do not need to be clamped to a particular range\n    of input elements.  */\n-typedef int_vector_builder<HOST_WIDE_INT> vec_perm_builder;\n+typedef int_vector_builder<poly_int64> vec_perm_builder;\n \n /* This class represents a constant permutation vector, such as that used\n    as the final operand to a VEC_PERM_EXPR.\n@@ -49,7 +49,7 @@ typedef int_vector_builder<HOST_WIDE_INT> vec_perm_builder;\n    different numbers of elements.  */\n class vec_perm_indices\n {\n-  typedef HOST_WIDE_INT element_type;\n+  typedef poly_int64 element_type;\n \n public:\n   vec_perm_indices ();\n@@ -118,13 +118,17 @@ vec_perm_indices::vec_perm_indices (const vec_perm_builder &elements,\n inline vec_perm_indices::element_type\n vec_perm_indices::clamp (element_type elt) const\n {\n-  element_type limit = input_nelts ();\n-  elt %= limit;\n+  element_type limit = input_nelts (), elem_within_input;\n+  int input;\n+  if (!can_div_trunc_p (elt, limit, &input, &elem_within_input))\n+    return elt;\n+\n   /* Treat negative elements as counting from the end.  This only matters\n      if the vector size is not a power of 2.  */\n-  if (elt < 0)\n-    elt += limit;\n-  return elt;\n+  if (known_lt (elem_within_input, 0))\n+    return elem_within_input + limit;\n+\n+  return elem_within_input;\n }\n \n /* Return the value of vector element I, which might or might not be"}, {"sha": "939709ca5820faa2ffc743d1fb0a579655c8c845", "filename": "gcc/vector-builder.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2Fvector-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b0630fbe8c34255f2739f63a8d3e5b636020bf4/gcc%2Fvector-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvector-builder.h?ref=6b0630fbe8c34255f2739f63a8d3e5b636020bf4", "patch": "@@ -284,7 +284,8 @@ vector_builder<T, Derived>::stepped_sequence_p (unsigned int start,\n \t  || !derived ()->integral_p (elt3))\n \treturn false;\n \n-      if (derived ()->step (elt1, elt2) != derived ()->step (elt2, elt3))\n+      if (maybe_ne (derived ()->step (elt1, elt2),\n+\t\t    derived ()->step (elt2, elt3)))\n \treturn false;\n \n       if (!derived ()->can_elide_p (elt3))"}]}