{"sha": "9ddb66ca2c45a7b33ccabfa750292234928d6a2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRkYjY2Y2EyYzQ1YTdiMzNjY2FiZmE3NTAyOTIyMzQ5MjhkNmEyYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-01-12T11:15:33Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-01-12T11:15:33Z"}, "message": "alias.c: Invlude varray.h\n\n\t* alias.c:  Invlude varray.h\n\t(alias_sets): Turn into varray.\n\t(get_alias_set_entry): Use VARRAY; mark inline.\n\t(mems_in_disjoint_alias_sets_p): Mark inline.\n\t(record_alias_subset): Use varray.\n\t(init_alias_once): Initialize varray.\n\t(new_alias_set): Grow array.\n\t* varray.c: Make VARRAY_GENERIC_PTR non GTYized.\n\nFrom-SVN: r75711", "tree": {"sha": "5e9cab849c3f60977861853b4d2869f626c7215c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e9cab849c3f60977861853b4d2869f626c7215c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ddb66ca2c45a7b33ccabfa750292234928d6a2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ddb66ca2c45a7b33ccabfa750292234928d6a2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ddb66ca2c45a7b33ccabfa750292234928d6a2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ddb66ca2c45a7b33ccabfa750292234928d6a2c/comments", "author": null, "committer": null, "parents": [{"sha": "c65ecebc826db604a52f546fe956da2926ee3486", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c65ecebc826db604a52f546fe956da2926ee3486", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c65ecebc826db604a52f546fe956da2926ee3486"}], "stats": {"total": 119, "additions": 51, "deletions": 68}, "files": [{"sha": "efb09a3237a9a930bca63adeabef57396e084493", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ddb66ca2c45a7b33ccabfa750292234928d6a2c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ddb66ca2c45a7b33ccabfa750292234928d6a2c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ddb66ca2c45a7b33ccabfa750292234928d6a2c", "patch": "@@ -1,6 +1,17 @@\n 2004-01-12  Jan Hubicka  <jh@suse.cz>\n \n-\tPartial fox for PR opt/10776 II\n+\t* alias.c:  Invlude varray.h\n+\t(alias_sets): Turn into varray.\n+\t(get_alias_set_entry): Use VARRAY; mark inline.\n+\t(mems_in_disjoint_alias_sets_p): Mark inline.\n+\t(record_alias_subset): Use varray.\n+\t(init_alias_once): Initialize varray.\n+\t(new_alias_set): Grow array.\n+\t* varray.c: Make VARRAY_GENERIC_PTR non GTYized.\n+\n+2004-01-12  Jan Hubicka  <jh@suse.cz>\n+\n+\tPartial fix for PR opt/10776 II\n \t* cselib.c: Include params.h\n \t(cselib_invalidate_mem):  Limit amount of nonconflicting memory\n \tlocations."}, {"sha": "62b28b188a503e1dddf886e8d9fca375a194b4bb", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ddb66ca2c45a7b33ccabfa750292234928d6a2c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ddb66ca2c45a7b33ccabfa750292234928d6a2c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=9ddb66ca2c45a7b33ccabfa750292234928d6a2c", "patch": "@@ -1653,7 +1653,7 @@ web.o : web.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n gcse.o : gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(GGC_H) $(RECOG_H) $(EXPR_H) \\\n    $(BASIC_BLOCK_H) function.h output.h toplev.h $(TM_P_H) $(PARAMS_H) \\\n-   except.h gt-gcse.h $(TREE_H)\n+   except.h gt-gcse.h $(TREE_H) cselib.h\n sibcall.o : sibcall.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    function.h hard-reg-set.h flags.h insn-config.h $(RECOG_H) $(BASIC_BLOCK_H)\n resource.o : resource.c $(CONFIG_H) $(RTL_H) hard-reg-set.h $(SYSTEM_H) coretypes.h \\"}, {"sha": "6c5f73bc9244e1f534f9345d6c1881c6811adb49", "filename": "gcc/alias.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ddb66ca2c45a7b33ccabfa750292234928d6a2c/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ddb66ca2c45a7b33ccabfa750292234928d6a2c/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=9ddb66ca2c45a7b33ccabfa750292234928d6a2c", "patch": "@@ -42,6 +42,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"timevar.h\"\n #include \"target.h\"\n #include \"cgraph.h\"\n+#include \"varray.h\"\n \n /* The alias sets assigned to MEMs assist the back-end in determining\n    which MEMs can alias which other MEMs.  In general, two MEMs in\n@@ -205,24 +206,21 @@ char *reg_known_equiv_p;\n static bool copying_arguments;\n \n /* The splay-tree used to store the various alias set entries.  */\n-static splay_tree alias_sets;\n+varray_type alias_sets;\n \f\n /* Returns a pointer to the alias set entry for ALIAS_SET, if there is\n    such an entry, or NULL otherwise.  */\n \n-static alias_set_entry\n+static inline alias_set_entry\n get_alias_set_entry (HOST_WIDE_INT alias_set)\n {\n-  splay_tree_node sn\n-    = splay_tree_lookup (alias_sets, (splay_tree_key) alias_set);\n-\n-  return sn != 0 ? ((alias_set_entry) sn->value) : 0;\n+  return (alias_set_entry)VARRAY_GENERIC_PTR (alias_sets, alias_set);\n }\n \n /* Returns nonzero if the alias sets for MEM1 and MEM2 are such that\n    the two MEMs cannot alias each other.  */\n \n-static int\n+static inline int\n mems_in_disjoint_alias_sets_p (rtx mem1, rtx mem2)\n {\n #ifdef ENABLE_CHECKING\n@@ -599,7 +597,10 @@ new_alias_set (void)\n   static HOST_WIDE_INT last_alias_set;\n \n   if (flag_strict_aliasing)\n-    return ++last_alias_set;\n+    {\n+      VARRAY_GROW (alias_sets, last_alias_set + 2);\n+      return ++last_alias_set;\n+    }\n   else\n     return 0;\n }\n@@ -641,8 +642,7 @@ record_alias_subset (HOST_WIDE_INT superset, HOST_WIDE_INT subset)\n       superset_entry->children\n \t= splay_tree_new (splay_tree_compare_ints, 0, 0);\n       superset_entry->has_zero_child = 0;\n-      splay_tree_insert (alias_sets, (splay_tree_key) superset,\n-\t\t\t (splay_tree_value) superset_entry);\n+      VARRAY_GENERIC_PTR (alias_sets, superset) = superset_entry;\n     }\n \n   if (subset == 0)\n@@ -2673,7 +2673,7 @@ init_alias_once (void)\n     = gen_rtx_ADDRESS (Pmode, hard_frame_pointer_rtx);\n #endif\n \n-  alias_sets = splay_tree_new (splay_tree_compare_ints, 0, 0);\n+  VARRAY_GENERIC_PTR_INIT (alias_sets, 10, \"alias sets\");\n }\n \n /* Set MEMORY_MODIFIED when X modifies DATA (that is assumed"}, {"sha": "bcfe68facf435ffaf9783e57be8d8bb15d908d5d", "filename": "gcc/cse.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ddb66ca2c45a7b33ccabfa750292234928d6a2c/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ddb66ca2c45a7b33ccabfa750292234928d6a2c/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=9ddb66ca2c45a7b33ccabfa750292234928d6a2c", "patch": "@@ -1768,14 +1768,16 @@ struct check_dependence_data\n {\n   enum machine_mode mode;\n   rtx exp;\n+  rtx addr;\n };\n \n static int\n check_dependence (rtx *x, void *data)\n {\n   struct check_dependence_data *d = (struct check_dependence_data *) data;\n   if (*x && GET_CODE (*x) == MEM)\n-    return true_dependence (d->exp, d->mode, *x, cse_rtx_varies_p);\n+    return canon_true_dependence (d->exp, d->mode, d->addr, *x,\n+\t\t    \t\t  cse_rtx_varies_p);\n   else\n     return 0;\n }\n@@ -1797,6 +1799,7 @@ invalidate (rtx x, enum machine_mode full_mode)\n {\n   int i;\n   struct table_elt *p;\n+  rtx addr;\n \n   switch (GET_CODE (x))\n     {\n@@ -1887,6 +1890,7 @@ invalidate (rtx x, enum machine_mode full_mode)\n       return;\n \n     case MEM:\n+      addr = canon_rtx (get_addr (XEXP (x, 0)));\n       /* Calculate the canonical version of X here so that\n \t true_dependence doesn't generate new RTL for X on each call.  */\n       x = canon_rtx (x);\n@@ -1914,6 +1918,7 @@ invalidate (rtx x, enum machine_mode full_mode)\n \t\t  if (!p->canon_exp)\n \t\t    p->canon_exp = canon_rtx (p->exp);\n \t\t  d.exp = x;\n+\t\t  d.addr = addr;\n \t\t  d.mode = full_mode;\n \t\t  if (for_each_rtx (&p->canon_exp, check_dependence, &d))\n \t\t    remove_from_table (p, i);"}, {"sha": "c3a68726a2bf43946e13caf552c03685c2cd722f", "filename": "gcc/cselib.c", "status": "modified", "additions": 19, "deletions": 53, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ddb66ca2c45a7b33ccabfa750292234928d6a2c/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ddb66ca2c45a7b33ccabfa750292234928d6a2c/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=9ddb66ca2c45a7b33ccabfa750292234928d6a2c", "patch": "@@ -58,7 +58,6 @@ static cselib_val *new_cselib_val (unsigned int, enum machine_mode);\n static void add_mem_for_addr (cselib_val *, cselib_val *, rtx);\n static cselib_val *cselib_lookup_mem (rtx, int);\n static void cselib_invalidate_regno (unsigned int, enum machine_mode);\n-static int cselib_mem_conflict_p (rtx, rtx);\n static void cselib_invalidate_mem (rtx);\n static void cselib_invalidate_rtx (rtx, rtx, void *);\n static void cselib_record_set (rtx, cselib_val *, cselib_val *);\n@@ -168,6 +167,7 @@ new_elt_loc_list (struct elt_loc_list *next, rtx loc)\n     el = ggc_alloc (sizeof (struct elt_loc_list));\n   el->next = next;\n   el->loc = loc;\n+  el->canon_loc = NULL;\n   el->setting_insn = cselib_current_insn;\n   el->in_libcall = cselib_current_insn_in_libcall;\n   return el;\n@@ -1050,60 +1050,18 @@ cselib_invalidate_regno (unsigned int regno, enum machine_mode mode)\n \t}\n     }\n }\n-\n-/* The memory at address MEM_BASE is being changed.\n-   Return whether this change will invalidate VAL.  */\n+\f\n+/* Return 1 if X has a value that can vary even between two\n+   executions of the program.  0 means X can be compared reliably\n+   against certain constants or near-constants.  */\n \n static int\n-cselib_mem_conflict_p (rtx mem_base, rtx val)\n+cselib_rtx_varies_p (rtx x ATTRIBUTE_UNUSED, int from_alias ATTRIBUTE_UNUSED)\n {\n-  enum rtx_code code;\n-  const char *fmt;\n-  int i, j;\n-\n-  code = GET_CODE (val);\n-  switch (code)\n-    {\n-      /* Get rid of a few simple cases quickly.  */\n-    case REG:\n-    case PC:\n-    case CC0:\n-    case SCRATCH:\n-    case CONST:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST_VECTOR:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return 0;\n-\n-    case MEM:\n-      if (GET_MODE (mem_base) == BLKmode\n-\t  || GET_MODE (val) == BLKmode\n-\t  || anti_dependence (val, mem_base))\n-\treturn 1;\n-\n-      /* The address may contain nested MEMs.  */\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  if (cselib_mem_conflict_p (mem_base, XEXP (val, i)))\n-\t    return 1;\n-\t}\n-      else if (fmt[i] == 'E')\n-\tfor (j = 0; j < XVECLEN (val, i); j++)\n-\t  if (cselib_mem_conflict_p (mem_base, XVECEXP (val, i, j)))\n-\t    return 1;\n-    }\n-\n+  /* We actually don't need to verify very hard.  This is because\n+     if X has actually changed, we invalidate the memory anyway,\n+     so assume that all common memory addresses are\n+     invariant.  */\n   return 0;\n }\n \n@@ -1116,6 +1074,10 @@ cselib_invalidate_mem (rtx mem_rtx)\n {\n   cselib_val **vp, *v, *next;\n   int num_mems = 0;\n+  rtx mem_addr;\n+\n+  mem_addr = canon_rtx (get_addr (XEXP (mem_rtx, 0)));\n+  mem_rtx = canon_rtx (mem_rtx);\n \n   vp = &first_containing_mem;\n   for (v = *vp; v != &dummy_val; v = next)\n@@ -1127,6 +1089,7 @@ cselib_invalidate_mem (rtx mem_rtx)\n       while (*p)\n \t{\n \t  rtx x = (*p)->loc;\n+\t  rtx canon_x = (*p)->canon_loc;\n \t  cselib_val *addr;\n \t  struct elt_list **mem_chain;\n \n@@ -1137,8 +1100,11 @@ cselib_invalidate_mem (rtx mem_rtx)\n \t      p = &(*p)->next;\n \t      continue;\n \t    }\n+\t  if (!canon_x)\n+\t    canon_x = (*p)->canon_loc = canon_rtx (x);\n \t  if (num_mems < PARAM_VALUE (PARAM_MAX_CSELIB_MEMORY_LOCATIONS)\n-\t      && ! cselib_mem_conflict_p (mem_rtx, x))\n+\t      && ! canon_true_dependence (mem_rtx, GET_MODE (mem_rtx), mem_addr,\n+\t\t      \t\t\t  x, cselib_rtx_varies_p))\n \t    {\n \t      has_mem = true;\n \t      num_mems++;"}, {"sha": "c751c42dbcabe990d5187b4119d0805a8164bf83", "filename": "gcc/cselib.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ddb66ca2c45a7b33ccabfa750292234928d6a2c/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ddb66ca2c45a7b33ccabfa750292234928d6a2c/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=9ddb66ca2c45a7b33ccabfa750292234928d6a2c", "patch": "@@ -49,6 +49,7 @@ struct elt_loc_list GTY(())\n   struct elt_loc_list *next;\n   /* An rtl expression that holds the value.  */\n   rtx loc;\n+  rtx canon_loc;\n   /* The insn that made the equivalence.  */\n   rtx setting_insn;\n   /* True when setting insn is inside libcall.  */"}, {"sha": "aca4b6bccf4ff7796eb2bf756aae478143d35a37", "filename": "gcc/varray.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ddb66ca2c45a7b33ccabfa750292234928d6a2c/gcc%2Fvarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ddb66ca2c45a7b33ccabfa750292234928d6a2c/gcc%2Fvarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.c?ref=9ddb66ca2c45a7b33ccabfa750292234928d6a2c", "patch": "@@ -47,7 +47,7 @@ static const struct {\n   { sizeof (unsigned long), 1 },\n   { sizeof (HOST_WIDE_INT), 1 },\n   { sizeof (unsigned HOST_WIDE_INT), 1 },\n-  { sizeof (void *), 1 },\n+  { sizeof (void *), 0 },\n   { sizeof (char *), 1 },\n   { sizeof (struct rtx_def *), 1 },\n   { sizeof (struct rtvec_def *), 1 },"}]}