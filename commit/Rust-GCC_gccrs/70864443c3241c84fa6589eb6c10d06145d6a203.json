{"sha": "70864443c3241c84fa6589eb6c10d06145d6a203", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA4NjQ0NDNjMzI0MWM4NGZhNjU4OWViNmMxMGQwNjE0NWQ2YTIwMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-22T22:15:30Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-06-22T22:15:30Z"}, "message": "(expand_binop): New variable next_methods; pass to most recursive calls when trying to avoid libcalls.\n\n(expand_binop): New variable next_methods; pass to most recursive calls when\ntrying to avoid libcalls.\nAlways check for a return value of zero in recursive calls.\n(expand_float): Ensure TARGET has proper mode.\nPass OPTAB_LIB_WIDEN to expand_binop calls.\n\nFrom-SVN: r7526", "tree": {"sha": "dc13e282856120f3e14aacc74732ba1be0fb3444", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc13e282856120f3e14aacc74732ba1be0fb3444"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70864443c3241c84fa6589eb6c10d06145d6a203", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70864443c3241c84fa6589eb6c10d06145d6a203", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70864443c3241c84fa6589eb6c10d06145d6a203", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70864443c3241c84fa6589eb6c10d06145d6a203/comments", "author": null, "committer": null, "parents": [{"sha": "e24d9a314466dac1d70e1f9b1a6377a9a6bf5c88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e24d9a314466dac1d70e1f9b1a6377a9a6bf5c88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e24d9a314466dac1d70e1f9b1a6377a9a6bf5c88"}], "stats": {"total": 490, "additions": 301, "deletions": 189}, "files": [{"sha": "011d3ff8e0efc1c427cb4f6019bfca01dcd70f8b", "filename": "gcc/optabs.c", "status": "modified", "additions": 301, "deletions": 189, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70864443c3241c84fa6589eb6c10d06145d6a203/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70864443c3241c84fa6589eb6c10d06145d6a203/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=70864443c3241c84fa6589eb6c10d06145d6a203", "patch": "@@ -327,6 +327,9 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n      int unsignedp;\n      enum optab_methods methods;\n {\n+  enum optab_methods next_methods\n+    = (methods == OPTAB_LIB || methods == OPTAB_LIB_WIDEN\n+       ? OPTAB_WIDEN : methods);\n   enum mode_class class;\n   enum machine_mode wider_mode;\n   register rtx temp;\n@@ -483,10 +486,13 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t\t\t   unsignedp ? umul_widen_optab : smul_widen_optab,\n \t\t\t   op0, op1, NULL_RTX, unsignedp, OPTAB_DIRECT);\n \n-      if (GET_MODE_CLASS (mode) == MODE_INT)\n-\treturn gen_lowpart (mode, temp);\n-      else\n-\treturn convert_to_mode (mode, temp, unsignedp);\n+      if (temp != 0)\n+\t{\n+\t  if (GET_MODE_CLASS (mode) == MODE_INT)\n+\t    return gen_lowpart (mode, temp);\n+\t  else\n+\t    return convert_to_mode (mode, temp, unsignedp);\n+\t}\n     }\n \n   /* Look for a wider mode of the same class for which we think we\n@@ -568,22 +574,29 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  rtx x = expand_binop (word_mode, binoptab,\n \t\t\t\toperand_subword_force (op0, i, mode),\n \t\t\t\toperand_subword_force (op1, i, mode),\n-\t\t\t\ttarget_piece, unsignedp, methods);\n+\t\t\t\ttarget_piece, unsignedp, next_methods);\n+\n+\t  if (x == 0)\n+\t    break;\n+\n \t  if (target_piece != x)\n \t    emit_move_insn (target_piece, x);\n \t}\n \n       insns = get_insns ();\n       end_sequence ();\n \n-      if (binoptab->code != UNKNOWN)\n-\tequiv_value\n-\t  = gen_rtx (binoptab->code, mode, copy_rtx (op0), copy_rtx (op1));\n-      else\n-\tequiv_value = 0;\n+      if (i == GET_MODE_BITSIZE (mode) / BITS_PER_WORD)\n+\t{\n+\t  if (binoptab->code != UNKNOWN)\n+\t    equiv_value\n+\t      = gen_rtx (binoptab->code, mode, copy_rtx (op0), copy_rtx (op1));\n+\t  else\n+\t    equiv_value = 0;\n \n-      emit_no_conflict_block (insns, target, op0, op1, equiv_value);\n-      return target;\n+\t  emit_no_conflict_block (insns, target, op0, op1, equiv_value);\n+\t  return target;\n+\t}\n     }\n \n   /* Synthesize double word shifts from single word shifts.  */\n@@ -596,7 +609,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       && ashl_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing\n       && lshr_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing)\n     {\n-      rtx insns, equiv_value;\n+      rtx insns, inter, equiv_value;\n       rtx into_target, outof_target;\n       rtx into_input, outof_input;\n       int shift_count, left_shift, outof_word;\n@@ -626,26 +639,30 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n       if (shift_count >= BITS_PER_WORD)\n \t{\n-\t  emit_move_insn (into_target,\n-\t\t\t  expand_binop (word_mode, binoptab,\n-\t\t\t\t\toutof_input,\n-\t\t\t\t\tGEN_INT (shift_count - BITS_PER_WORD),\n-\t\t\t\t\tinto_target, unsignedp, methods));\n+\t  inter = expand_binop (word_mode, binoptab,\n+\t\t\t       outof_input,\n+\t\t\t       GEN_INT (shift_count - BITS_PER_WORD),\n+\t\t\t       into_target, unsignedp, next_methods);\n+\n+\t  if (inter != 0)\n+\t    emit_move_insn (into_target, inter);\n \n \t  /* For a signed right shift, we must fill the word we are shifting\n \t     out of with copies of the sign bit.  Otherwise it is zeroed.  */\n \t  if (binoptab != ashr_optab)\n \t    emit_move_insn (outof_target, CONST0_RTX (word_mode));\n-\t  else\n-\t    emit_move_insn (outof_target,\n-\t\t\t    expand_binop (word_mode, binoptab,\n-\t\t\t\t\t  outof_input,\n-\t\t\t\t\t  GEN_INT (BITS_PER_WORD - 1),\n-\t\t\t\t\t  outof_target, unsignedp, methods));\n+\t  else if (inter != 0)\n+\t    inter = expand_binop (word_mode, binoptab,\n+\t\t\t\t  outof_input,\n+\t\t\t\t  GEN_INT (BITS_PER_WORD - 1),\n+\t\t\t\t  outof_target, unsignedp, next_methods);\n+\n+\t  if (inter != 0)\n+\t    emit_move_insn (outof_target, inter);\n \t}\n       else\n \t{\n-\t  rtx carries, into_temp;\n+\t  rtx carries;\n \t  optab reverse_unsigned_shift, unsigned_shift;\n \n \t  /* For a shift of less then BITS_PER_WORD, to compute the carry,\n@@ -663,32 +680,42 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  carries = expand_binop (word_mode, reverse_unsigned_shift,\n \t\t\t\t  outof_input,\n \t\t\t\t  GEN_INT (BITS_PER_WORD - shift_count),\n-\t\t\t\t  0, unsignedp, methods);\n-\n-\t  emit_move_insn (outof_target,\n-\t\t\t  expand_binop (word_mode, binoptab,\n-\t\t\t\t\toutof_input,\n-\t\t\t\t\top1, outof_target, unsignedp, methods));\n-\t  into_temp = expand_binop (word_mode, unsigned_shift,\n-\t\t\t\t    into_input,\n-\t\t\t\t    op1, 0, unsignedp, methods);\n-\n-\t  emit_move_insn (into_target,\n-\t\t\t  expand_binop (word_mode, ior_optab,\n-\t\t\t\t\tcarries, into_temp,\n-\t\t\t\t\tinto_target, unsignedp, methods));\n+\t\t\t\t  0, unsignedp, next_methods);\n+\n+\t  if (carries == 0)\n+\t    inter = 0;\n+\t  else\n+\t    inter = expand_binop (word_mode, binoptab, outof_input,\n+\t\t\t\t  op1, outof_target, unsignedp, next_methods);\n+\t  \n+\t  if (inter != 0)\n+\t    emit_move_insn (outof_target, inter);\n+\n+\t  if (inter != 0)\n+\t    inter = expand_binop (word_mode, unsigned_shift, into_input,\n+\t\t\t\t  op1, 0, unsignedp, next_methods);\n+\n+\t  if (inter != 0)\n+\t    inter = expand_binop (word_mode, ior_optab, carries, inter,\n+\t\t\t\t  into_target, unsignedp, next_methods);\n+\n+\t  if (inter != 0)\n+\t    emit_move_insn (into_target, inter);\n \t}\n \n       insns = get_insns ();\n       end_sequence ();\n \n-      if (binoptab->code != UNKNOWN)\n-\tequiv_value = gen_rtx (binoptab->code, mode, op0, op1);\n-      else\n-\tequiv_value = 0;\n+      if (inter != 0)\n+\t{\n+\t  if (binoptab->code != UNKNOWN)\n+\t    equiv_value = gen_rtx (binoptab->code, mode, op0, op1);\n+\t  else\n+\t    equiv_value = 0;\n \n-      emit_no_conflict_block (insns, target, op0, op1, equiv_value);\n-      return target;\n+\t  emit_no_conflict_block (insns, target, op0, op1, equiv_value);\n+\t  return target;\n+\t}\n     }\n \n   /* Synthesize double word rotates from single word shifts.  */\n@@ -702,6 +729,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       rtx insns, equiv_value;\n       rtx into_target, outof_target;\n       rtx into_input, outof_input;\n+      rtx inter;\n       int shift_count, left_shift, outof_word;\n \n       /* If TARGET is the same as one of the operands, the REG_EQUAL note\n@@ -732,6 +760,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  /* This is just a word swap.  */\n \t  emit_move_insn (outof_target, into_input);\n \t  emit_move_insn (into_target, outof_input);\n+\t  inter = const0_rtx;\n \t}\n       else\n \t{\n@@ -758,43 +787,57 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n \t  into_temp1 = expand_binop (word_mode, unsigned_shift,\n \t\t\t\t     outof_input, first_shift_count,\n-\t\t\t\t     NULL_RTX, unsignedp, methods);\n+\t\t\t\t     NULL_RTX, unsignedp, next_methods);\n \t  into_temp2 = expand_binop (word_mode, reverse_unsigned_shift,\n \t\t\t\t     into_input, second_shift_count,\n-\t\t\t\t     into_target, unsignedp, methods);\n-\t  emit_move_insn (into_target,\n-\t\t\t  expand_binop (word_mode, ior_optab,\n-\t\t\t\t\tinto_temp1, into_temp2,\n-\t\t\t\t\tinto_target, unsignedp, methods));\n+\t\t\t\t     into_target, unsignedp, next_methods);\n+\n+\t  if (into_temp1 != 0 && into_temp2 != 0)\n+\t    inter = expand_binop (word_mode, ior_optab, into_temp1, into_temp2,\n+\t\t\t\t  into_target, unsignedp, next_methods);\n+\t  else\n+\t    inter = 0;\n+\n+\t  if (inter != 0)\n+\t    emit_move_insn (into_target, inter);\n \n \t  outof_temp1 = expand_binop (word_mode, unsigned_shift,\n \t\t\t\t      into_input, first_shift_count,\n-\t\t\t\t      NULL_RTX, unsignedp, methods);\n+\t\t\t\t      NULL_RTX, unsignedp, next_methods);\n \t  outof_temp2 = expand_binop (word_mode, reverse_unsigned_shift,\n \t\t\t\t      outof_input, second_shift_count,\n-\t\t\t\t      outof_target, unsignedp, methods);\n-\t  emit_move_insn (outof_target,\n-\t\t\t  expand_binop (word_mode, ior_optab,\n-\t\t\t\t\toutof_temp1, outof_temp2,\n-\t\t\t\t\toutof_target, unsignedp, methods));\n+\t\t\t\t      outof_target, unsignedp, next_methods);\n+\n+\t  if (inter != 0 && outof_temp1 != 0 && outof_temp2 != 0)\n+\t    inter = expand_binop (word_mode, ior_optab,\n+\t\t\t\t  outof_temp1, outof_temp2,\n+\t\t\t\t  outof_target, unsignedp, next_methods);\n+\n+\t  if (inter != 0)\n+\t    emit_move_insn (outof_target, inter);\n \t}\n \n       insns = get_insns ();\n       end_sequence ();\n \n-      if (binoptab->code != UNKNOWN)\n-\tequiv_value = gen_rtx (binoptab->code, mode, op0, op1);\n-      else\n-\tequiv_value = 0;\n+      if (inter != 0)\n+\t{\n+\t  if (binoptab->code != UNKNOWN)\n+\t    equiv_value = gen_rtx (binoptab->code, mode, op0, op1);\n+\t  else\n+\t    equiv_value = 0;\n \n-      /* We can't make this a no conflict block if this is a word swap,\n-\t because the word swap case fails if the input and output values\n-\t are in the same register.  */\n-      if (shift_count != BITS_PER_WORD)\n-\temit_no_conflict_block (insns, target, op0, op1, equiv_value);\n-      else\n-\temit_insns (insns);\n-      return target;\n+\t  /* We can't make this a no conflict block if this is a word swap,\n+\t     because the word swap case fails if the input and output values\n+\t     are in the same register.  */\n+\t  if (shift_count != BITS_PER_WORD)\n+\t    emit_no_conflict_block (insns, target, op0, op1, equiv_value);\n+\t  else\n+\t    emit_insns (insns);\n+\n+\n+\t  return target;\n+\t}\n     }\n \n   /* These can be done a word at a time by propagating carries.  */\n@@ -843,7 +886,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  /* Main add/subtract of the input operands.  */\n \t  x = expand_binop (word_mode, binoptab,\n \t\t\t    op0_piece, op1_piece,\n-\t\t\t    target_piece, unsignedp, methods);\n+\t\t\t    target_piece, unsignedp, next_methods);\n \t  if (x == 0)\n \t    break;\n \n@@ -855,7 +898,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t\t\t\t\t   binoptab == add_optab ? LTU : GTU,\n \t\t\t\t\t   x, op0_piece,\n \t\t\t\t\t   word_mode, 1, normalizep);\n-\t      if (!carry_out)\n+\t      if (carry_out == 0)\n \t\tbreak;\n \t    }\n \n@@ -865,8 +908,10 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t      x = expand_binop (word_mode,\n \t\t\t\tnormalizep == 1 ? binoptab : otheroptab,\n \t\t\t\tx, carry_in,\n-\t\t\t\ttarget_piece, 1, methods);\n-\t      if (target_piece != x)\n+\t\t\t\ttarget_piece, 1, next_methods);\n+\t      if (x == 0)\n+\t\tbreak;\n+\t      else if (target_piece != x)\n \t\temit_move_insn (target_piece, x);\n \n \t      if (i + 1 < nwords)\n@@ -878,11 +923,12 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t\t\t\t\t         ? LTU : GTU,\n \t\t\t\t\t       x, carry_in,\n \t\t\t\t\t       word_mode, 1, normalizep);\n+\n \t\t  /* Logical-ior the two poss. carry together.  */\n \t\t  carry_out = expand_binop (word_mode, ior_optab,\n \t\t\t\t\t    carry_out, carry_tmp,\n-\t\t\t\t\t    carry_out, 0, methods);\n-\t\t  if (!carry_out)\n+\t\t\t\t\t    carry_out, 0, next_methods);\n+\t\t  if (carry_out == 0)\n \t\t    break;\n \t\t}\n \t    }\n@@ -892,9 +938,8 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n       if (i == GET_MODE_BITSIZE (mode) / BITS_PER_WORD)\n \t{\n-\t  rtx temp;\n-\t  \n-\t  temp = emit_move_insn (target, target);\n+\t  rtx temp = emit_move_insn (target, target);\n+\n \t  REG_NOTES (temp) = gen_rtx (EXPR_LIST, REG_EQUAL,\n \t\t\t\t      gen_rtx (binoptab->code, mode,\n \t\t\t\t\t       copy_rtx (xop0),\n@@ -1005,33 +1050,33 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  product = expand_binop (mode, smul_widen_optab, op0_low, op1_low,\n \t\t\t\t  target, 1, OPTAB_DIRECT);\n \t  op0_xhigh = expand_binop (word_mode, lshr_optab, op0_low, wordm1,\n-\t\t\t\t    NULL_RTX, 1, OPTAB_DIRECT);\n+\t\t\t\t    NULL_RTX, 1, next_methods);\n \t  if (op0_xhigh)\n \t    op0_xhigh = expand_binop (word_mode, add_optab, op0_high,\n-\t\t\t\t      op0_xhigh, op0_xhigh, 0, OPTAB_DIRECT);\n+\t\t\t\t      op0_xhigh, op0_xhigh, 0, next_methods);\n \t  else\n \t    {\n \t      op0_xhigh = expand_binop (word_mode, ashr_optab, op0_low, wordm1,\n-\t\t\t\t\tNULL_RTX, 0, OPTAB_DIRECT);\n+\t\t\t\t\tNULL_RTX, 0, next_methods);\n \t      if (op0_xhigh)\n \t\top0_xhigh = expand_binop (word_mode, sub_optab, op0_high,\n \t\t\t\t\t  op0_xhigh, op0_xhigh, 0,\n-\t\t\t\t\t  OPTAB_DIRECT);\n+\t\t\t\t\t  next_methods);\n \t    }\n \n \t  op1_xhigh = expand_binop (word_mode, lshr_optab, op1_low, wordm1,\n-\t\t\t\t    NULL_RTX, 1, OPTAB_DIRECT);\n+\t\t\t\t    NULL_RTX, 1, next_methods);\n \t  if (op1_xhigh)\n \t    op1_xhigh = expand_binop (word_mode, add_optab, op1_high,\n-\t\t\t\t      op1_xhigh, op1_xhigh, 0, OPTAB_DIRECT);\n+\t\t\t\t      op1_xhigh, op1_xhigh, 0, next_methods);\n \t  else\n \t    {\n \t      op1_xhigh = expand_binop (word_mode, ashr_optab, op1_low, wordm1,\n-\t\t\t\t\tNULL_RTX, 0, OPTAB_DIRECT);\n+\t\t\t\t\tNULL_RTX, 0, next_methods);\n \t      if (op1_xhigh)\n \t\top1_xhigh = expand_binop (word_mode, sub_optab, op1_high,\n \t\t\t\t\t  op1_xhigh, op1_xhigh, 0,\n-\t\t\t\t\t  OPTAB_DIRECT);\n+\t\t\t\t\t  next_methods);\n \t    }\n \t}\n \n@@ -1047,28 +1092,31 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n       if (product && op0_xhigh && op1_xhigh)\n \t{\n-\t  rtx product_piece;\n \t  rtx product_high = operand_subword (product, high, 1, mode);\n \t  rtx temp = expand_binop (word_mode, binoptab, op0_low, op1_xhigh,\n \t\t\t\t   NULL_RTX, 0, OPTAB_DIRECT);\n \n-\t  if (temp)\n-\t    {\n-\t      product_piece = expand_binop (word_mode, add_optab, temp,\n-\t\t\t\t\t    product_high, product_high,\n-\t\t\t\t\t    0, OPTAB_LIB_WIDEN);\n-\t      if (product_piece != product_high)\n-\t\temit_move_insn (product_high, product_piece);\n+\t  if (temp != 0)\n+\t    temp = expand_binop (word_mode, add_optab, temp, product_high,\n+\t\t\t\t product_high, 0, next_methods);\n \n-\t      temp = expand_binop (word_mode, binoptab, op1_low, op0_xhigh, \n-\t\t\t\t   NULL_RTX, 0, OPTAB_DIRECT);\n+\t  if (temp != 0 && temp != product_high)\n+\t    emit_move_insn (product_high, temp);\n+\n+\t  if (temp != 0)\n+\t    temp = expand_binop (word_mode, binoptab, op1_low, op0_xhigh, \n+\t\t\t\t NULL_RTX, 0, OPTAB_DIRECT);\n+\n+\t  if (temp != 0)\n+\t    temp = expand_binop (word_mode, add_optab, temp,\n+\t\t\t\t product_high, product_high,\n+\t\t\t\t 0, next_methods);\n \n-\t      product_piece = expand_binop (word_mode, add_optab, temp,\n-\t\t\t\t\t    product_high, product_high,\n-\t\t\t\t\t    0, OPTAB_LIB_WIDEN);\n-\t      if (product_piece != product_high)\n-\t\temit_move_insn (product_high, product_piece);\n+\t  if (temp != 0 && temp != product_high)\n+\t    emit_move_insn (product_high, temp);\n \n+\t  if (temp != 0)\n+\t    {\n \t      temp = emit_move_insn (product, product);\n \t      REG_NOTES (temp) = gen_rtx (EXPR_LIST, REG_EQUAL,\n \t\t\t\t\t  gen_rtx (MULT, mode, copy_rtx (op0),\n@@ -1096,15 +1144,12 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n   if (class == MODE_COMPLEX_FLOAT || class == MODE_COMPLEX_INT)\n     {\n-      rtx real0 = (rtx) 0;\n-      rtx imag0 = (rtx) 0;\n-      rtx real1 = (rtx) 0;\n-      rtx imag1 = (rtx) 0;\n-      rtx realr;\n-      rtx imagr;\n-      rtx res;\n+      rtx real0 = 0, imag0 = 0;\n+      rtx real1 = 0, imag1 = 0;\n+      rtx realr, imagr, res;\n       rtx seq;\n       rtx equiv_value;\n+      int ok = 0;\n \n       /* Find the correct mode for the real and imaginary parts */\n       enum machine_mode submode\n@@ -1139,7 +1184,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       else\n \treal1 = op1;\n \n-      if (! real0 || ! real1 || ! (imag0 || imag1))\n+      if (real0 == 0 || real1 == 0 || ! (imag0 != 0|| imag1 != 0))\n \tabort ();\n \n       switch (binoptab->code)\n@@ -1150,7 +1195,10 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  /* (a+ib) - (c+id) = (a-c) + i(b-d) */\n \t  res = expand_binop (submode, binoptab, real0, real1,\n \t\t\t      realr, unsignedp, methods);\n-\t  if (res != realr)\n+\n+\t  if (res == 0)\n+\t    break;\n+\t  else if (res != realr)\n \t    emit_move_insn (realr, res);\n \n \t  if (imag0 && imag1)\n@@ -1163,43 +1211,60 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  else\n \t    res = imag1;\n \n-\t  if (res != imagr)\n+\t  if (res == 0)\n+\t    break;\n+\t  else if (res != imagr)\n \t    emit_move_insn (imagr, res);\n+\n+\t  ok = 1;\n \t  break;\n \n \tcase MULT:\n \t  /* (a+ib) * (c+id) = (ac-bd) + i(ad+cb) */\n \n \t  if (imag0 && imag1)\n \t    {\n+\t      rtx temp1, temp2;\n+\n \t      /* Don't fetch these from memory more than once.  */\n \t      real0 = force_reg (submode, real0);\n \t      real1 = force_reg (submode, real1);\n \t      imag0 = force_reg (submode, imag0);\n \t      imag1 = force_reg (submode, imag1);\n \n-\t      res = expand_binop (submode, sub_optab,\n-\t\t\t\t  expand_binop (submode, binoptab, real0,\n-\t\t\t\t\t\treal1, NULL_RTX, unsignedp,\n-\t\t\t\t\t\tmethods),\n-\t\t\t\t  expand_binop (submode, binoptab, imag0,\n-\t\t\t\t\t\timag1, NULL_RTX, unsignedp,\n-\t\t\t\t\t\tmethods),\n+\t      temp1 = expand_binop (submode, binoptab, real0, real1, NULL_RTX,\n+\t\t\t\t    unsignedp, methods);\n+\n+\t      temp2 = expand_binop (submode, binoptab, imag0, imag1, NULL_RTX,\n+\t\t\t\t    unsignedp, methods);\n+\n+\t      if (temp1 == 0 || temp2 == 0)\n+\t\tbreak;\n+\n+\t      res = expand_binop (submode, sub_optab, temp1, temp2,\n \t\t\t\t  realr, unsignedp, methods);\n \n-\t      if (res != realr)\n+\t      if (res == 0)\n+\t\tbreak;\n+\t      else if (res != realr)\n \t\temit_move_insn (realr, res);\n \n-\t      res = expand_binop (submode, add_optab,\n-\t\t\t\t  expand_binop (submode, binoptab,\n-\t\t\t\t\t\treal0, imag1,\n-\t\t\t\t\t\tNULL_RTX, unsignedp, methods),\n-\t\t\t\t  expand_binop (submode, binoptab,\n-\t\t\t\t\t\treal1, imag0,\n-\t\t\t\t\t\tNULL_RTX, unsignedp, methods),\n-\t\t\t\t  imagr, unsignedp, methods);\n-\t      if (res != imagr)\n+\t      temp1 = expand_binop (submode, binoptab, real0, imag1,\n+\t\t\t\t    NULL_RTX, unsignedp, methods);\n+\n+\t      temp2 = expand_binop (submode, binoptab, real1, imag0,\n+\t\t\t\t    NULL_RTX, unsignedp, methods);\n+\n+\t      if (temp1 == 0 || temp2 == 0)\n+\t\tres = expand_binop (submode, add_optab, temp1, temp2,\n+\t\t\t\t    imagr, unsignedp, methods);\n+\n+\t      if (res == 0)\n+\t\tbreak;\n+\t      else if (res != imagr)\n \t\temit_move_insn (imagr, res);\n+\n+\t      ok = 1;\n \t    }\n \t  else\n \t    {\n@@ -1209,25 +1274,33 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n \t      res = expand_binop (submode, binoptab, real0, real1,\n \t\t\t\t  realr, unsignedp, methods);\n-\t      if (res != realr)\n+\t      if (res == 0)\n+\t\tbreak;\n+\t      else if (res != realr)\n \t\temit_move_insn (realr, res);\n \n-\t      if (imag0)\n+\t      if (imag0 != 0)\n \t\tres = expand_binop (submode, binoptab,\n \t\t\t\t    real1, imag0, imagr, unsignedp, methods);\n \t      else\n \t\tres = expand_binop (submode, binoptab,\n \t\t\t\t    real0, imag1, imagr, unsignedp, methods);\n-\t      if (res != imagr)\n+\n+\t      if (res == 0)\n+\t\tbreak;\n+\t      else if (res != imagr)\n \t\temit_move_insn (imagr, res);\n+\n+\t      ok = 1;\n \t    }\n \t  break;\n \n \tcase DIV:\n \t  /* (a+ib) / (c+id) = ((ac+bd)/(cc+dd)) + i((bc-ad)/(cc+dd)) */\n \t  \n-\t  if (! imag1)\n-\t    {\t/* (a+ib) / (c+i0) = (a/c) + i(b/c) */\n+\t  if (imag1 == 0)\n+\t    {\n+\t      /* (a+ib) / (c+i0) = (a/c) + i(b/c) */\n \n \t      /* Don't fetch these from memory more than once.  */\n \t      real1 = force_reg (submode, real1);\n@@ -1240,7 +1313,9 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t\tres = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n \t\t\t\t     real0, real1, realr, unsignedp);\n \n-\t      if (res != realr)\n+\t      if (res == 0)\n+\t\tbreak;\n+\t      else if (res != realr)\n \t\temit_move_insn (realr, res);\n \n \t      if (class == MODE_COMPLEX_FLOAT)\n@@ -1250,68 +1325,92 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t\tres = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n \t\t\t\t     imag0, real1, imagr, unsignedp);\n \n-\t      if (res != imagr)\n+\t      if (res == 0)\n+\t\tbreak;\n+\t      else if (res != imagr)\n \t\temit_move_insn (imagr, res);\n-\t    }\n-\t  else\t\t\t/* Divisor is of complex type */\n-\t    {\t\t\t/* X/(a+ib) */\n \n+\t      ok = 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Divisor is of complex type:\n+\t\t X/(a+ib) */\n \t      rtx divisor;\n-\t      rtx real_t;\n-\t      rtx imag_t;\n+\t      rtx real_t, imag_t;\n \t      rtx lhs, rhs;\n+\t      rtx temp1, temp2;\n \t      \n \t      /* Don't fetch these from memory more than once.  */\n \t      real0 = force_reg (submode, real0);\n \t      real1 = force_reg (submode, real1);\n-\t      if (imag0)\n+\n+\t      if (imag0 != 0)\n \t\timag0 = force_reg (submode, imag0);\n+\n \t      imag1 = force_reg (submode, imag1);\n \n \t      /* Divisor: c*c + d*d */\n-\t      divisor = expand_binop (submode, add_optab,\n-\t\t\t\t      expand_binop (submode, smul_optab,\n-\t\t\t\t\t\t    real1, real1, NULL_RTX,\n-\t\t\t\t\t\t    unsignedp, methods),\n-\t\t\t\t      expand_binop (submode, smul_optab,\n-\t\t\t\t\t\t    imag1, imag1, NULL_RTX,\n-\t\t\t\t\t\t    unsignedp, methods),\n+\t      temp1 = expand_binop (submode, smul_optab, real1, real1,\n+\t\t\t\t    NULL_RTX, unsignedp, methods);\n+\n+\t      temp2 = expand_binop (submode, smul_optab, imag1, imag1,\n+\t\t\t\t    NULL_RTX, unsignedp, methods);\n+\n+\t      if (temp1 == 0 || temp2 == 0)\n+\t\tbreak;\n+\n+\t      divisor = expand_binop (submode, add_optab, temp1, temp2,\n \t\t\t\t      NULL_RTX, unsignedp, methods);\n+\t      if (divisor == 0)\n+\t\tbreak;\n+\n+\t      if (imag0 == 0)\n+\t\t{\n+\t\t  /* ((a)(c-id))/divisor */\n+\t\t  /* (a+i0) / (c+id) = (ac/(cc+dd)) + i(-ad/(cc+dd)) */\n \n-\t      if (! imag0)\t/* ((a)(c-id))/divisor */\n-\t\t{\t/* (a+i0) / (c+id) = (ac/(cc+dd)) + i(-ad/(cc+dd)) */\n \t\t  /* Calculate the dividend */\n \t\t  real_t = expand_binop (submode, smul_optab, real0, real1,\n \t\t\t\t\t NULL_RTX, unsignedp, methods);\n \t\t  \n-\t\t  imag_t\n-\t\t    = expand_unop (submode, neg_optab,\n-\t\t\t\t   expand_binop (submode, smul_optab, real0,\n-\t\t\t\t\t\t imag1, NULL_RTX, unsignedp,\n-\t\t\t\t\t\t methods),\n-\t\t\t\t   NULL_RTX, unsignedp);\n+\t\t  imag_t = expand_binop (submode, smul_optab, real0, imag1,\n+\t\t\t\t\t NULL_RTX, unsignedp, methods);\n+\n+\t\t  if (real_t == 0 || imag_t == 0)\n+\t\t    break;\n+\n+\t\t  imag_t = expand_unop (submode, neg_optab, imag_t,\n+\t\t\t\t\tNULL_RTX, unsignedp);\n \t\t}\n-\t      else\t\t/* ((a+ib)(c-id))/divider */\n+\t      else\n \t\t{\n+\t\t  /* ((a+ib)(c-id))/divider */\n \t\t  /* Calculate the dividend */\n-\t\t  real_t = expand_binop (submode, add_optab,\n-\t\t\t\t\t expand_binop (submode, smul_optab,\n-\t\t\t\t\t\t       real0, real1, NULL_RTX,\n-\t\t\t\t\t\t       unsignedp, methods),\n-\t\t\t\t\t expand_binop (submode, smul_optab,\n-\t\t\t\t\t\t       imag0, imag1, NULL_RTX,\n-\t\t\t\t\t\t       unsignedp, methods),\n+\t\t  temp1 = expand_binop (submode, smul_optab, real0, real1,\n+\t\t\t\t\tNULL_RTX, unsignedp, methods);\n+\n+\t\t  temp2 = expand_binop (submode, smul_optab, imag0, imag1,\n+\t\t\t\t\tNULL_RTX, unsignedp, methods);\n+\n+\t\t  if (temp1 == 0 || temp2 == 0)\n+\t\t    break;\n+\n+\t\t  real_t = expand_binop (submode, add_optab, temp1, temp2,\n \t\t\t\t\t NULL_RTX, unsignedp, methods);\n \t\t  \n-\t\t  imag_t = expand_binop (submode, sub_optab,\n-\t\t\t\t\t expand_binop (submode, smul_optab,\n-\t\t\t\t\t\t       imag0, real1, NULL_RTX,\n-\t\t\t\t\t\t       unsignedp, methods),\n-\t\t\t\t\t expand_binop (submode, smul_optab,\n-\t\t\t\t\t\t       real0, imag1, NULL_RTX,\n-\t\t\t\t\t\t       unsignedp, methods),\n-\t\t\t\t\t NULL_RTX, unsignedp, methods);\n+\t\t  temp1 = expand_binop (submode, smul_optab, imag0, real1,\n+\t\t\t\t\tNULL_RTX, unsignedp, methods);\n+\n+\t\t  temp2 = expand_binop (submode, smul_optab, real0, imag1,\n+\t\t\t\t\tNULL_RTX, unsignedp, methods);\n \n+\t\t  if (temp1 == 0 || temp2 == 0)\n+\t\t    imag_t = expand_binop (submode, sub_optab, temp1, temp2,\n+\t\t\t\t\t   NULL_RTX, unsignedp, methods);\n+\n+\t\t  if (real_t == 0 || imag_t == 0)\n+\t\t    break;\n \t\t}\n \n \t      if (class == MODE_COMPLEX_FLOAT)\n@@ -1321,7 +1420,9 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t\tres = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n \t\t\t\t     real_t, divisor, realr, unsignedp);\n \n-\t      if (res != realr)\n+\t      if (res == 0)\n+\t\tbreak;\n+\t      else if (res != realr)\n \t\temit_move_insn (realr, res);\n \n \t      if (class == MODE_COMPLEX_FLOAT)\n@@ -1331,8 +1432,12 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t\tres = expand_divmod (0, TRUNC_DIV_EXPR, submode,\n \t\t\t\t     imag_t, divisor, imagr, unsignedp);\n \n-\t      if (res != imagr)\n+\t      if (res == 0)\n+\t\tbreak;\n+\t      else if (res != imagr)\n \t\temit_move_insn (imagr, res);\n+\n+\t      ok = 1;\n \t    }\n \t  break;\n \t  \n@@ -1343,15 +1448,18 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       seq = get_insns ();\n       end_sequence ();\n \n-      if (binoptab->code != UNKNOWN)\n-\tequiv_value\n-\t  = gen_rtx (binoptab->code, mode, copy_rtx (op0), copy_rtx (op1));\n-      else\n-\tequiv_value = 0;\n+      if (ok)\n+\t{\n+\t  if (binoptab->code != UNKNOWN)\n+\t    equiv_value\n+\t      = gen_rtx (binoptab->code, mode, copy_rtx (op0), copy_rtx (op1));\n+\t  else\n+\t    equiv_value = 0;\n \t  \n-      emit_no_conflict_block (seq, target, op0, op1, equiv_value);\n+\t  emit_no_conflict_block (seq, target, op0, op1, equiv_value);\n       \n-      return target;\n+\t  return target;\n+\t}\n     }\n \n   /* It can't be open-coded in this mode.\n@@ -3068,6 +3176,7 @@ expand_float (to, from, unsignedp)\n       /* Look for a usable floating mode FMODE wider than the source and at\n \t least as wide as the target.  Using FMODE will avoid rounding woes\n \t with unsigned values greater than the signed maximum value.  */\n+\n       for (fmode = GET_MODE (to);  fmode != VOIDmode;\n \t   fmode = GET_MODE_WIDER_MODE (fmode))\n \tif (GET_MODE_BITSIZE (GET_MODE (from)) < GET_MODE_BITSIZE (fmode)\n@@ -3086,10 +3195,11 @@ expand_float (to, from, unsignedp)\n \t      rtx temp1;\n \t      rtx neglabel = gen_label_rtx ();\n \n-\t      /* Don't use TARGET if it isn't a register or is a\n-\t\t hard register.  */\n+\t      /* Don't use TARGET if it isn't a register, is a hard register, \n+\t\t or is the wrong mode.  */\n \t      if (GET_CODE (target) != REG\n-\t\t  || REGNO (target) < FIRST_PSEUDO_REGISTER)\n+\t\t  || REGNO (target) < FIRST_PSEUDO_REGISTER\n+\t\t  || GET_MODE (target) != fmode)\n \t\ttarget = gen_reg_rtx (fmode);\n \n \t      imode = GET_MODE (from);\n@@ -3110,15 +3220,16 @@ expand_float (to, from, unsignedp)\n \n \t      emit_label (neglabel);\n \t      temp = expand_binop (imode, and_optab, from, const1_rtx,\n-\t\t\t\t   NULL_RTX, 1, 0);\n+\t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);\n \t      temp1 = expand_shift (RSHIFT_EXPR, imode, from, integer_one_node,\n \t\t\t\t    NULL_RTX, 1);\n-\t      temp = expand_binop (imode, ior_optab, temp, temp1, temp, 1, 0);\n+\t      temp = expand_binop (imode, ior_optab, temp, temp1, temp, 1, \n+\t\t\t\t   OPTAB_LIB_WIDEN);\n \t      expand_float (target, temp, 0);\n \n \t      /* Multiply by 2 to undo the shift above.  */\n \t      target = expand_binop (fmode, add_optab, target, target,\n-\t\t\t\t     target, 0, 0);\n+\t\t\t\t     target, 0, OPTAB_LIB_WIDEN);\n \t      do_pending_stack_adjust ();\n \t      emit_label (label);\n \t      goto done;\n@@ -3129,7 +3240,7 @@ expand_float (to, from, unsignedp)\n \t unsigned operand, do it in a pseudo-register.  */\n \n       if (GET_MODE (to) != fmode\n-\t  || GET_CODE (to) != REG || REGNO (to) <= LAST_VIRTUAL_REGISTER)\n+\t  || GET_CODE (to) != REG || REGNO (to) < FIRST_PSEUDO_REGISTER)\n \ttarget = gen_reg_rtx (fmode);\n \n       /* Convert as signed integer to floating.  */\n@@ -3141,6 +3252,7 @@ expand_float (to, from, unsignedp)\n       do_pending_stack_adjust ();\n       emit_cmp_insn (from, const0_rtx, GE, NULL_RTX, GET_MODE (from), 0, 0);\n       emit_jump_insn (gen_bge (label));\n+\n       /* On SCO 3.2.1, ldexp rejects values outside [0.5, 1).\n \t Rather than setting up a dconst_dot_5, let's hope SCO\n \t fixes the bug.  */\n@@ -3153,8 +3265,8 @@ expand_float (to, from, unsignedp)\n \n       do_pending_stack_adjust ();\n       emit_label (label);\n+      goto done;\n     }\n-  else\n #endif\n \n   /* No hardware instruction available; call a library rotine to convert from"}]}