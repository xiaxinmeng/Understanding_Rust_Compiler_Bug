{"sha": "f8ec056116004ee5a3bc9363d233727c8cf72b73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhlYzA1NjExNjAwNGVlNWEzYmM5MzYzZDIzMzcyN2M4Y2Y3MmI3Mw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2014-07-12T19:09:11Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2014-07-12T19:09:11Z"}, "message": "re PR fortran/61780 (Wrong code when shifting elements of a multidimensional array)\n\n2014-07-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/61780\n\t* dependency.c (gfc_dep_resolver): Index the 'reverse' array so\n\tthat elements are skipped. This then correctly aligns 'reverse'\n\twith the scalarizer loops.\n\n2014-07-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/61780\n\t* gfortran.dg/dependency_44.f90 : New test\n\nFrom-SVN: r212486", "tree": {"sha": "9bbf04d8fa0b1753ede4a45ca61a4310a0632b0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bbf04d8fa0b1753ede4a45ca61a4310a0632b0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8ec056116004ee5a3bc9363d233727c8cf72b73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8ec056116004ee5a3bc9363d233727c8cf72b73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8ec056116004ee5a3bc9363d233727c8cf72b73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8ec056116004ee5a3bc9363d233727c8cf72b73/comments", "author": null, "committer": null, "parents": [{"sha": "fae3018dcda41a9b889561be7f3fbc2a0f62ccb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fae3018dcda41a9b889561be7f3fbc2a0f62ccb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fae3018dcda41a9b889561be7f3fbc2a0f62ccb1"}], "stats": {"total": 143, "additions": 100, "deletions": 43}, "files": [{"sha": "44bc5e0076801923eb2bf832b42449493eeaf8d5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8ec056116004ee5a3bc9363d233727c8cf72b73/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8ec056116004ee5a3bc9363d233727c8cf72b73/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f8ec056116004ee5a3bc9363d233727c8cf72b73", "patch": "@@ -1,3 +1,10 @@\n+2014-07-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/61780\n+\t* dependency.c (gfc_dep_resolver): Index the 'reverse' array so\n+\tthat elements are skipped. This then correctly aligns 'reverse'\n+\twith the scalarizer loops.\n+\n 2014-07-12  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/61628"}, {"sha": "c18482aff2e3719ccb84adfb9a58e90016793baa", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 52, "deletions": 43, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8ec056116004ee5a3bc9363d233727c8cf72b73/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8ec056116004ee5a3bc9363d233727c8cf72b73/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=f8ec056116004ee5a3bc9363d233727c8cf72b73", "patch": "@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n /* There's probably quite a bit of duplication in this file.  We currently\n    have different dependency checking functions for different types\n    if dependencies.  Ideally these would probably be merged.  */\n-   \n+\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -178,14 +178,14 @@ are_identical_variables (gfc_expr *e1, gfc_expr *e2)\n \n \t  /* If both are NULL, the end length compares equal, because we\n \t     are looking at the same variable. This can only happen for\n-\t     assumed- or deferred-length character arguments.  */ \n+\t     assumed- or deferred-length character arguments.  */\n \n \t  if (r1->u.ss.end == NULL && r2->u.ss.end == NULL)\n \t    break;\n \n \t  if (gfc_dep_compare_expr (r1->u.ss.end, r2->u.ss.end) != 0)\n \t    return false;\n-\t  \n+\n \t  break;\n \n \tdefault:\n@@ -206,7 +206,7 @@ gfc_dep_compare_functions (gfc_expr *e1, gfc_expr *e2, bool impure_ok)\n \n   gfc_actual_arglist *args1;\n   gfc_actual_arglist *args2;\n-  \n+\n   if (e1->expr_type != EXPR_FUNCTION || e2->expr_type != EXPR_FUNCTION)\n     return -2;\n \n@@ -226,18 +226,18 @@ gfc_dep_compare_functions (gfc_expr *e1, gfc_expr *e2, bool impure_ok)\n \t  /*  Bitwise xor, since C has no non-bitwise xor operator.  */\n \t  if ((args1->expr == NULL) ^ (args2->expr == NULL))\n \t    return -2;\n-\t  \n+\n \t  if (args1->expr != NULL && args2->expr != NULL\n \t      && gfc_dep_compare_expr (args1->expr, args2->expr) != 0)\n \t    return -2;\n-\t  \n+\n \t  args1 = args1->next;\n \t  args2 = args2->next;\n \t}\n       return (args1 || args2) ? -2 : 0;\n     }\n       else\n-\treturn -2;      \n+\treturn -2;\n }\n \n /* Helper function to look through parens, unary plus and widening\n@@ -496,7 +496,7 @@ gfc_dep_compare_expr (gfc_expr *e1, gfc_expr *e2)\n \n \n /* Return the difference between two expressions.  Integer expressions of\n-   the form \n+   the form\n \n    X + constant, X - constant and constant + X\n \n@@ -687,7 +687,7 @@ gfc_dep_difference (gfc_expr *e1, gfc_expr *e2, mpz_t *result)\n \t    {\n \t      e2_op1 = discard_nops (e2->value.op.op1);\n \t      e2_op2 = discard_nops (e2->value.op.op2);\n-\t      \n+\n \t      /* Case 14: (c1 - X) - (c2 - X) == c1 - c2.  */\n \t      if (gfc_dep_compare_expr (e1_op2, e2_op2) == 0)\n \t\t{\n@@ -937,7 +937,7 @@ gfc_check_argument_var_dependency (gfc_expr *var, sym_intent intent,\n   switch (expr->expr_type)\n     {\n     case EXPR_VARIABLE:\n-      /* In case of elemental subroutines, there is no dependency \n+      /* In case of elemental subroutines, there is no dependency\n          between two same-range array references.  */\n       if (gfc_ref_needs_temporary_p (expr->ref)\n \t  || gfc_check_dependency (var, expr, elemental == NOT_ELEMENTAL))\n@@ -947,24 +947,24 @@ gfc_check_argument_var_dependency (gfc_expr *var, sym_intent intent,\n \t      /* Too many false positive with pointers.  */\n \t      if (!gfc_is_data_pointer (var) && !gfc_is_data_pointer (expr))\n \t\t{\n-\t\t  /* Elemental procedures forbid unspecified intents, \n+\t\t  /* Elemental procedures forbid unspecified intents,\n \t\t     and we don't check dependencies for INTENT_IN args.  */\n \t\t  gcc_assert (intent == INTENT_OUT || intent == INTENT_INOUT);\n \n-\t\t  /* We are told not to check dependencies. \n+\t\t  /* We are told not to check dependencies.\n \t\t     We do it, however, and issue a warning in case we find one.\n-\t\t     If a dependency is found in the case \n+\t\t     If a dependency is found in the case\n \t\t     elemental == ELEM_CHECK_VARIABLE, we will generate\n \t\t     a temporary, so we don't need to bother the user.  */\n \t\t  gfc_warning (\"INTENT(%s) actual argument at %L might \"\n-\t\t\t       \"interfere with actual argument at %L.\", \n-\t\t   \t       intent == INTENT_OUT ? \"OUT\" : \"INOUT\", \n+\t\t\t       \"interfere with actual argument at %L.\",\n+\t\t   \t       intent == INTENT_OUT ? \"OUT\" : \"INOUT\",\n \t\t   \t       &var->where, &expr->where);\n \t\t}\n \t      return 0;\n \t    }\n \t  else\n-\t    return 1; \n+\t    return 1;\n \t}\n       return 0;\n \n@@ -1010,17 +1010,17 @@ gfc_check_argument_var_dependency (gfc_expr *var, sym_intent intent,\n \t dependencies, as we will make a temporary anyway.  */\n       if (elemental)\n \t{\n-\t  /* If the actual arg EXPR is an expression, we need to catch \n-\t     a dependency between variables in EXPR and VAR, \n+\t  /* If the actual arg EXPR is an expression, we need to catch\n+\t     a dependency between variables in EXPR and VAR,\n \t     an intent((IN)OUT) variable.  */\n \t  if (expr->value.op.op1\n-\t      && gfc_check_argument_var_dependency (var, intent, \n-\t\t\t\t\t\t    expr->value.op.op1, \n+\t      && gfc_check_argument_var_dependency (var, intent,\n+\t\t\t\t\t\t    expr->value.op.op1,\n \t\t\t\t\t\t    ELEM_CHECK_VARIABLE))\n \t    return 1;\n \t  else if (expr->value.op.op2\n-\t\t   && gfc_check_argument_var_dependency (var, intent, \n-\t\t\t\t\t\t\t expr->value.op.op2, \n+\t\t   && gfc_check_argument_var_dependency (var, intent,\n+\t\t\t\t\t\t\t expr->value.op.op2,\n \t\t\t\t\t\t\t ELEM_CHECK_VARIABLE))\n \t    return 1;\n \t}\n@@ -1030,8 +1030,8 @@ gfc_check_argument_var_dependency (gfc_expr *var, sym_intent intent,\n       return 0;\n     }\n }\n-  \n-  \n+\n+\n /* Like gfc_check_argument_var_dependency, but extended to any\n    array expression OTHER, not just variables.  */\n \n@@ -1154,7 +1154,7 @@ gfc_are_equivalenced_arrays (gfc_expr *e1, gfc_expr *e2)\n \t  /* Can these lengths be zero?  */\n \t  if (fl1->length <= 0 || fl2->length <= 0)\n \t    return 1;\n-\t  /* These can't overlap if [f11,fl1+length] is before \n+\t  /* These can't overlap if [f11,fl1+length] is before\n \t     [fl2,fl2+length], or [fl2,fl2+length] is before\n \t     [fl1,fl1+length], otherwise they do overlap.  */\n \t  if (fl1->offset + fl1->length > fl2->offset\n@@ -1457,7 +1457,7 @@ check_section_vs_section (gfc_array_ref *l_ar, gfc_array_ref *r_ar, int n)\n     start_comparison = gfc_dep_compare_expr (l_start, r_start);\n   else\n     start_comparison = -2;\n-      \n+\n   gfc_free_expr (one_expr);\n \n   /* Determine LHS upper and lower bounds.  */\n@@ -1559,7 +1559,7 @@ check_section_vs_section (gfc_array_ref *l_ar, gfc_array_ref *r_ar, int n)\n \n   /* Check for forward dependencies x:y:-1 vs. x-1:z:-1 and\n      x:y:-1 vs. x:y:-2.  */\n-  if (l_dir == -1 && r_dir == -1 && \n+  if (l_dir == -1 && r_dir == -1 &&\n       (start_comparison == 0 || start_comparison == 1)\n       && (stride_comparison == 0 || stride_comparison == 1))\n     return GFC_DEP_FORWARD;\n@@ -1583,7 +1583,7 @@ check_section_vs_section (gfc_array_ref *l_ar, gfc_array_ref *r_ar, int n)\n     {\n       if (l_start && IS_ARRAY_EXPLICIT (l_ar->as))\n \t{\n-      \n+\n \t  /* Check for a(high:y:-s) vs. a(z:x:-s) or\n \t     a(high:y:-s vs. a(z:x:-s-1) where a has a higher bound\n \t     of high, which is always at least a forward dependence.  */\n@@ -2023,6 +2023,7 @@ int\n gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n {\n   int n;\n+  int m;\n   gfc_dependency fin_dep;\n   gfc_dependency this_dep;\n \n@@ -2045,12 +2046,12 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \t  if (lref->u.c.component != rref->u.c.component)\n \t    return 0;\n \t  break;\n-\t  \n+\n \tcase REF_SUBSTRING:\n \t  /* Substring overlaps are handled by the string assignment code\n \t     if there is not an underlying dependency.  */\n \t  return (fin_dep == GFC_DEP_OVERLAP) ? 1 : 0;\n-\t\n+\n \tcase REF_ARRAY:\n \n \t  if (ref_same_as_full_array (lref, rref))\n@@ -2072,6 +2073,8 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \t      break;\n \t    }\n \n+\t  /* Index for the reverse array.  */\n+\t  m = -1;\n \t  for (n=0; n < lref->u.ar.dimen; n++)\n \t    {\n \t      /* Handle dependency when either of array reference is vector\n@@ -2081,7 +2084,7 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \t      if (lref->u.ar.dimen_type[n] == DIMEN_VECTOR\n \t\t  || rref->u.ar.dimen_type[n] == DIMEN_VECTOR)\n \t\t{\n-\t\t  if (lref->u.ar.dimen_type[n] == DIMEN_VECTOR \n+\t\t  if (lref->u.ar.dimen_type[n] == DIMEN_VECTOR\n \t\t      && rref->u.ar.dimen_type[n] == DIMEN_VECTOR\n \t\t      && gfc_dep_compare_expr (lref->u.ar.start[n],\n \t\t\t\t\t       rref->u.ar.start[n]) == 0)\n@@ -2101,7 +2104,7 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \t      else if (rref->u.ar.dimen_type[n] == DIMEN_ELEMENT\n \t\t       && lref->u.ar.dimen_type[n] == DIMEN_RANGE)\n \t\tthis_dep = gfc_check_element_vs_section (rref, lref, n);\n-\t      else \n+\t      else\n \t\t{\n \t\t  gcc_assert (rref->u.ar.dimen_type[n] == DIMEN_ELEMENT\n \t\t\t      && lref->u.ar.dimen_type[n] == DIMEN_ELEMENT);\n@@ -2118,38 +2121,44 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref, gfc_reverse *reverse)\n \t\t The ability to reverse or not is set by previous conditions\n \t\t in this dimension.  If reversal is not activated, the\n \t\t value GFC_DEP_BACKWARD is reset to GFC_DEP_OVERLAP.  */\n+\n+\t      /* Get the indexing right for the scalarizing loop. If this\n+\t\t is an element, there is no corresponding loop.  */\n+\t      if (lref->u.ar.dimen_type[n] != DIMEN_ELEMENT)\n+\t\tm++;\n+\n \t      if (rref->u.ar.dimen_type[n] == DIMEN_RANGE\n \t\t    && lref->u.ar.dimen_type[n] == DIMEN_RANGE)\n \t\t{\n \t\t  /* Set reverse if backward dependence and not inhibited.  */\n-\t\t  if (reverse && reverse[n] == GFC_ENABLE_REVERSE)\n-\t\t    reverse[n] = (this_dep == GFC_DEP_BACKWARD) ?\n-\t\t\t         GFC_REVERSE_SET : reverse[n];\n+\t\t  if (reverse && reverse[m] == GFC_ENABLE_REVERSE)\n+\t\t    reverse[m] = (this_dep == GFC_DEP_BACKWARD) ?\n+\t\t\t         GFC_REVERSE_SET : reverse[m];\n \n \t\t  /* Set forward if forward dependence and not inhibited.  */\n-\t\t  if (reverse && reverse[n] == GFC_ENABLE_REVERSE)\n-\t\t    reverse[n] = (this_dep == GFC_DEP_FORWARD) ?\n-\t\t\t         GFC_FORWARD_SET : reverse[n];\n+\t\t  if (reverse && reverse[m] == GFC_ENABLE_REVERSE)\n+\t\t    reverse[m] = (this_dep == GFC_DEP_FORWARD) ?\n+\t\t\t         GFC_FORWARD_SET : reverse[m];\n \n \t\t  /* Flag up overlap if dependence not compatible with\n \t\t     the overall state of the expression.  */\n-\t\t  if (reverse && reverse[n] == GFC_REVERSE_SET\n+\t\t  if (reverse && reverse[m] == GFC_REVERSE_SET\n \t\t        && this_dep == GFC_DEP_FORWARD)\n \t\t    {\n-\t              reverse[n] = GFC_INHIBIT_REVERSE;\n+\t              reverse[m] = GFC_INHIBIT_REVERSE;\n \t\t      this_dep = GFC_DEP_OVERLAP;\n \t\t    }\n-\t\t  else if (reverse && reverse[n] == GFC_FORWARD_SET\n+\t\t  else if (reverse && reverse[m] == GFC_FORWARD_SET\n \t\t        && this_dep == GFC_DEP_BACKWARD)\n \t\t    {\n-\t              reverse[n] = GFC_INHIBIT_REVERSE;\n+\t              reverse[m] = GFC_INHIBIT_REVERSE;\n \t\t      this_dep = GFC_DEP_OVERLAP;\n \t\t    }\n \n \t\t  /* If no intention of reversing or reversing is explicitly\n \t\t     inhibited, convert backward dependence to overlap.  */\n \t\t  if ((reverse == NULL && this_dep == GFC_DEP_BACKWARD)\n-\t\t      || (reverse != NULL && reverse[n] == GFC_INHIBIT_REVERSE))\n+\t\t      || (reverse != NULL && reverse[m] == GFC_INHIBIT_REVERSE))\n \t\t    this_dep = GFC_DEP_OVERLAP;\n \t\t}\n "}, {"sha": "48a6bb7fb751dfeab19cd55dc89516a5715d3829", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8ec056116004ee5a3bc9363d233727c8cf72b73/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8ec056116004ee5a3bc9363d233727c8cf72b73/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f8ec056116004ee5a3bc9363d233727c8cf72b73", "patch": "@@ -1,3 +1,8 @@\n+2014-07-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/61780\n+\t* gfortran.dg/dependency_44.f90 : New test\n+\n 2014-07-12  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.dg/coarray_atomic_1.f90: Update dg-error."}, {"sha": "ebfeec64c8d199ae24c75a1b2ba35cc235113a30", "filename": "gcc/testsuite/gfortran.dg/dependency_44.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8ec056116004ee5a3bc9363d233727c8cf72b73/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_44.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8ec056116004ee5a3bc9363d233727c8cf72b73/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_44.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_44.f90?ref=f8ec056116004ee5a3bc9363d233727c8cf72b73", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do run }\n+! Tests fix for PR61780 in which the loop reversal mechanism was\n+! not accounting for the first index being an element so that no\n+! loop in this dimension is created.\n+!\n+! Contributed by Manfred Tietze on clf.\n+!\n+program prgm3\n+    implicit none\n+    integer, parameter :: n = 10, k = 3\n+    integer :: i, j\n+    integer, dimension(n,n) :: y\n+    integer :: res1(n), res2(n)\n+\n+1   format(10i5)\n+\n+!initialize\n+    do i=1,n\n+        do j=1,n\n+            y(i,j) = n*i + j\n+        end do\n+    end do\n+    res2 = y(k,:)\n+\n+!shift right\n+    y(k,4:n) = y(k,3:n-1)\n+    y(k,3) = 0\n+    res1 = y(k,:)\n+    y(k,:) = res2\n+    y(k,n:4:-1) = y(k,n-1:3:-1)\n+    y(k,3) = 0\n+    res2 = y(k,:)\n+!    print *, res1\n+!    print *, res2\n+    if (any(res1 /= res2)) call abort ()\n+end program prgm3"}]}