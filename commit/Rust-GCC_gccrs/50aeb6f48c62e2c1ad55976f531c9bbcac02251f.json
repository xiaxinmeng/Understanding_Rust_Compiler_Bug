{"sha": "50aeb6f48c62e2c1ad55976f531c9bbcac02251f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBhZWI2ZjQ4YzYyZTJjMWFkNTU5NzZmNTMxYzliYmNhYzAyMjUxZg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2011-05-25T23:43:32Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2011-05-25T23:43:32Z"}, "message": "guard.cc: Fix comments.\n\n2011-05-26  Jonathan Wakely  <jwakely.gcc@gmail.com>\n\n\t* libsupc++/guard.cc: Fix comments.\n\nFrom-SVN: r174241", "tree": {"sha": "e82e35cd63c77bc426e272c356a0b3bacef21b29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e82e35cd63c77bc426e272c356a0b3bacef21b29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50aeb6f48c62e2c1ad55976f531c9bbcac02251f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50aeb6f48c62e2c1ad55976f531c9bbcac02251f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50aeb6f48c62e2c1ad55976f531c9bbcac02251f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50aeb6f48c62e2c1ad55976f531c9bbcac02251f/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b4e07b814b50a6f5cdf6b10d05117623d8854c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b4e07b814b50a6f5cdf6b10d05117623d8854c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b4e07b814b50a6f5cdf6b10d05117623d8854c9"}], "stats": {"total": 34, "additions": 19, "deletions": 15}, "files": [{"sha": "f1941cb4a757c5c287380a4a9cf78b1ead4d368d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50aeb6f48c62e2c1ad55976f531c9bbcac02251f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50aeb6f48c62e2c1ad55976f531c9bbcac02251f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=50aeb6f48c62e2c1ad55976f531c9bbcac02251f", "patch": "@@ -1,3 +1,7 @@\n+2011-05-26  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* libsupc++/guard.cc: Fix comments.\n+\n 2011-05-25  Ian Lance Taylor  <iant@google.com>\n \n \tPR libstdc++/49060"}, {"sha": "7514fa4c5c1a2712f9106f70cf3a5df913bd79ce", "filename": "libstdc++-v3/libsupc++/guard.cc", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50aeb6f48c62e2c1ad55976f531c9bbcac02251f/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50aeb6f48c62e2c1ad55976f531c9bbcac02251f/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc?ref=50aeb6f48c62e2c1ad55976f531c9bbcac02251f", "patch": "@@ -85,7 +85,7 @@ namespace\n # if defined(__GTHREAD_HAS_COND) && !defined(_GLIBCXX_USE_FUTEX)\n namespace\n {\n-  // A single conditional variable controlling all static initializations.\n+  // A single condition variable controlling all static initializations.\n   static __gnu_cxx::__cond* static_cond;  \n \n   // using a fake type to avoid initializing a static class.\n@@ -136,7 +136,7 @@ __set_and_release (__cxxabiv1::__guard *g)\n #endif /* __GTHREADS */\n \n //\n-// Here are C++ run-time routines for guarded initiailization of static\n+// Here are C++ run-time routines for guarded initialization of static\n // variables. There are 4 scenarios under which these routines are called:\n //\n //   1. Threads not supported (__GTHREADS not defined)\n@@ -147,24 +147,24 @@ __set_and_release (__cxxabiv1::__guard *g)\n //\n // The old code supported scenarios 1-3 but was broken since it used a global\n // mutex for all threads and had the mutex locked during the whole duration of\n-// initlization of a guarded static variable. The following created a dead-lock\n-// with the old code.\n+// initialization of a guarded static variable. The following created a\n+// dead-lock with the old code.\n //\n //\tThread 1 acquires the global mutex.\n //\tThread 1 starts initializing static variable.\n //\tThread 1 creates thread 2 during initialization.\n-//\tThread 2 attempts to acuqire mutex to initialize another variable.\n+//\tThread 2 attempts to acquire mutex to initialize another variable.\n //\tThread 2 blocks since thread 1 is locking the mutex.\n //\tThread 1 waits for result from thread 2 and also blocks. A deadlock.\n //\n-// The new code here can handle this situation and thus is more robust. Howere,\n-// we need to use the POSIX thread conditional variable, which is not supported\n+// The new code here can handle this situation and thus is more robust. However,\n+// we need to use the POSIX thread condition variable, which is not supported\n // in all platforms, notably older versions of Microsoft Windows. The gthr*.h\n // headers define a symbol __GTHREAD_HAS_COND for platforms that support POSIX\n-// like conditional variables. For platforms that do not support conditional\n+// like condition variables. For platforms that do not support condition\n // variables, we need to fall back to the old code.\n \n-// If _GLIBCXX_USE_FUTEX, no global mutex or conditional variable is used,\n+// If _GLIBCXX_USE_FUTEX, no global mutex or condition variable is used,\n // only atomic operations are used together with futex syscall.\n // Valid values of the first integer in guard are:\n // 0\t\t\t\t  No thread encountered the guarded init\n@@ -211,7 +211,7 @@ namespace __cxxabiv1\n #endif\n   }\n \n-  // acuire() is a helper function used to acquire guard if thread support is\n+  // acquire() is a helper function used to acquire guard if thread support is\n   // not compiled in or is compiled in but not enabled at run-time.\n   static int\n   acquire(__guard *g)\n@@ -284,7 +284,7 @@ namespace __cxxabiv1\n \t      {\n \t\t// The guarded static is currently being initialized by\n \t\t// another thread, so we release mutex and wait for the\n-\t\t// conditional variable. We will lock the mutex again after\n+\t\t// condition variable. We will lock the mutex again after\n \t\t// this.\n \t\tget_static_cond().wait_recursive(&get_static_mutex());\n \t      }\n@@ -295,7 +295,7 @@ namespace __cxxabiv1\n \t      }\n #  else\n \t    // This provides compatibility with older systems not supporting\n-\t    // POSIX like conditional variables.\n+\t    // POSIX like condition variables.\n \t    if (acquire(g))\n \t      {\n \t\tmw.unlock = false;\n@@ -335,7 +335,7 @@ namespace __cxxabiv1\n \tset_init_in_progress_flag(g, 0);\n \n \t// If we abort, we still need to wake up all other threads waiting for\n-\t// the conditional variable.\n+\t// the condition variable.\n         get_static_cond().broadcast();\n \treturn;\n       }\t\n@@ -344,7 +344,7 @@ namespace __cxxabiv1\n     set_init_in_progress_flag(g, 0);\n #if defined(__GTHREADS) && !defined(__GTHREAD_HAS_COND)\n     // This provides compatibility with older systems not supporting POSIX like\n-    // conditional variables.\n+    // condition variables.\n     if (__gthread_active_p ())\n       static_mutex->unlock();\n #endif\n@@ -385,7 +385,7 @@ namespace __cxxabiv1\n \n #if defined(__GTHREADS) && !defined(__GTHREAD_HAS_COND)\n     // This provides compatibility with older systems not supporting POSIX like\n-    // conditional variables.\n+    // condition variables.\n     if (__gthread_active_p())\n       static_mutex->unlock();\n #endif"}]}