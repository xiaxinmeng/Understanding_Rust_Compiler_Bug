{"sha": "4f4b36794c9ccf9527df83fcb6a18603f4b6dcab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY0YjM2Nzk0YzljY2Y5NTI3ZGY4M2ZjYjZhMTg2MDNmNGI2ZGNhYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-10-26T13:35:39Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-10-26T13:35:39Z"}, "message": "combine.c (subst): Process the inputs to a parallel asm_operands only once.\n\n        * combine.c (subst): Process the inputs to a parallel asm_operands\n        only once.\n\nFrom-SVN: r23357", "tree": {"sha": "f6a8fd72dbf212aea70ba62ce2a9b8daebca1027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6a8fd72dbf212aea70ba62ce2a9b8daebca1027"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f4b36794c9ccf9527df83fcb6a18603f4b6dcab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f4b36794c9ccf9527df83fcb6a18603f4b6dcab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f4b36794c9ccf9527df83fcb6a18603f4b6dcab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f4b36794c9ccf9527df83fcb6a18603f4b6dcab/comments", "author": null, "committer": null, "parents": [{"sha": "3fbd5c2cfd1abfe548156e87901c9c1802566c06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fbd5c2cfd1abfe548156e87901c9c1802566c06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fbd5c2cfd1abfe548156e87901c9c1802566c06"}], "stats": {"total": 222, "additions": 139, "deletions": 83}, "files": [{"sha": "f675520bc91d2df34b85a0fa12d3f2a10e390fc8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4b36794c9ccf9527df83fcb6a18603f4b6dcab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4b36794c9ccf9527df83fcb6a18603f4b6dcab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f4b36794c9ccf9527df83fcb6a18603f4b6dcab", "patch": "@@ -1,3 +1,8 @@\n+Mon Oct 26 13:35:02 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* combine.c (subst): Process the inputs to a parallel asm_operands\n+\tonly once.\n+\n Mon Oct 26 13:32:31 1998  Richard Henderson  <rth@cygnus.com>\n \n \t* stmt.c (expand_asm_operands): Accept `=' or `+' at any position."}, {"sha": "4094561fc8fd8505ed195790d2baf6938f67031a", "filename": "gcc/combine.c", "status": "modified", "additions": 134, "deletions": 83, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f4b36794c9ccf9527df83fcb6a18603f4b6dcab/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f4b36794c9ccf9527df83fcb6a18603f4b6dcab/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=4f4b36794c9ccf9527df83fcb6a18603f4b6dcab", "patch": "@@ -3048,103 +3048,154 @@ subst (x, from, to, in_dest, unique_copy)\n   if (COMBINE_RTX_EQUAL_P (x, to))\n     return to;\n \n-  len = GET_RTX_LENGTH (code);\n-  fmt = GET_RTX_FORMAT (code);\n+  /* Parallel asm_operands need special attention because all of the\n+     inputs are shared across the arms.  Furthermore, unsharing the\n+     rtl results in recognition failures.  Failure to handle this case\n+     specially can result in circular rtl.\n+\n+     Solve this by doing a normal pass across the first entry of the\n+     parallel, and only processing the SET_DESTs of the subsequent\n+     entries.  Ug.  */\n+\n+  if (code == PARALLEL\n+      && GET_CODE (XVECEXP (x, 0, 0)) == SET\n+      && GET_CODE (SET_SRC (XVECEXP (x, 0, 0))) == ASM_OPERANDS)\n+    {\n+      new = subst (XVECEXP (x, 0, 0), from, to, 0, unique_copy);\n \n-  /* We don't need to process a SET_DEST that is a register, CC0, or PC, so\n-     set up to skip this common case.  All other cases where we want to\n-     suppress replacing something inside a SET_SRC are handled via the\n-     IN_DEST operand.  */\n-  if (code == SET\n-      && (GET_CODE (SET_DEST (x)) == REG\n-        || GET_CODE (SET_DEST (x)) == CC0\n-        || GET_CODE (SET_DEST (x)) == PC))\n-    fmt = \"ie\";\n-\n-  /* Get the mode of operand 0 in case X is now a SIGN_EXTEND of a\n-     constant.  */\n-  if (fmt[0] == 'e')\n-    op0_mode = GET_MODE (XEXP (x, 0));\n+      /* If this substitution failed, this whole thing fails.  */\n+      if (GET_CODE (new) == CLOBBER\n+\t  && XEXP (new, 0) == const0_rtx)\n+\treturn new;\n \n-  for (i = 0; i < len; i++)\n-    {\n-      if (fmt[i] == 'E')\n+      SUBST (XVECEXP (x, 0, 0), new);\n+\n+      for (i = XVECLEN (x, 0) - 1; i >= 1; i--)\n \t{\n-\t  register int j;\n-\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  rtx dest = SET_DEST (XVECEXP (x, 0, i));\n+\t  \n+\t  if (GET_CODE (dest) != REG\n+\t      && GET_CODE (dest) != CC0\n+\t      && GET_CODE (dest) != PC)\n \t    {\n-\t      if (COMBINE_RTX_EQUAL_P (XVECEXP (x, i, j), from))\n-\t\t{\n-\t\t  new = (unique_copy && n_occurrences ? copy_rtx (to) : to);\n-\t\t  n_occurrences++;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  new = subst (XVECEXP (x, i, j), from, to, 0, unique_copy);\n+\t      new = subst (dest, from, to, 0, unique_copy);\n \n-\t\t  /* If this substitution failed, this whole thing fails.  */\n-\t\t  if (GET_CODE (new) == CLOBBER && XEXP (new, 0) == const0_rtx)\n-\t\t    return new;\n-\t\t}\n+\t      /* If this substitution failed, this whole thing fails.  */\n+\t      if (GET_CODE (new) == CLOBBER\n+\t\t  && XEXP (new, 0) == const0_rtx)\n+\t\treturn new;\n \n-\t      SUBST (XVECEXP (x, i, j), new);\n+\t      SUBST (SET_DEST (XVECEXP (x, 0, i)), new);\n \t    }\n \t}\n-      else if (fmt[i] == 'e')\n+    }\n+  else\n+    {\n+      len = GET_RTX_LENGTH (code);\n+      fmt = GET_RTX_FORMAT (code);\n+\n+      /* We don't need to process a SET_DEST that is a register, CC0,\n+\t or PC, so set up to skip this common case.  All other cases\n+\t where we want to suppress replacing something inside a\n+\t SET_SRC are handled via the IN_DEST operand.  */\n+      if (code == SET\n+\t  && (GET_CODE (SET_DEST (x)) == REG\n+\t      || GET_CODE (SET_DEST (x)) == CC0\n+\t      || GET_CODE (SET_DEST (x)) == PC))\n+\tfmt = \"ie\";\n+\n+      /* Get the mode of operand 0 in case X is now a SIGN_EXTEND of a\n+\t constant.  */\n+      if (fmt[0] == 'e')\n+\top0_mode = GET_MODE (XEXP (x, 0));\n+\n+      for (i = 0; i < len; i++)\n \t{\n-\t  if (COMBINE_RTX_EQUAL_P (XEXP (x, i), from))\n+\t  if (fmt[i] == 'E')\n+\t    {\n+\t      register int j;\n+\t      for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t\t{\n+\t\t  if (COMBINE_RTX_EQUAL_P (XVECEXP (x, i, j), from))\n+\t\t    {\n+\t\t      new = (unique_copy && n_occurrences\n+\t\t\t     ? copy_rtx (to) : to);\n+\t\t      n_occurrences++;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      new = subst (XVECEXP (x, i, j), from, to, 0,\n+\t\t\t\t   unique_copy);\n+\n+\t\t      /* If this substitution failed, this whole thing\n+\t\t\t fails.  */\n+\t\t      if (GET_CODE (new) == CLOBBER\n+\t\t\t  && XEXP (new, 0) == const0_rtx)\n+\t\t\treturn new;\n+\t\t    }\n+\n+\t\t  SUBST (XVECEXP (x, i, j), new);\n+\t\t}\n+\t    }\n+\t  else if (fmt[i] == 'e')\n \t    {\n-\t      /* In general, don't install a subreg involving two modes not\n-\t\t tieable.  It can worsen register allocation, and can even\n-\t\t make invalid reload insns, since the reg inside may need to\n-\t\t be copied from in the outside mode, and that may be invalid\n-\t\t if it is an fp reg copied in integer mode.\n-\n-\t\t We allow two exceptions to this: It is valid if it is inside\n-\t\t another SUBREG and the mode of that SUBREG and the mode of\n-\t\t the inside of TO is tieable and it is valid if X is a SET\n-\t\t that copies FROM to CC0.  */\n-\t      if (GET_CODE (to) == SUBREG\n-\t\t  && ! MODES_TIEABLE_P (GET_MODE (to),\n-\t\t\t\t\tGET_MODE (SUBREG_REG (to)))\n-\t\t  && ! (code == SUBREG\n-\t\t\t&& MODES_TIEABLE_P (GET_MODE (x),\n-\t\t\t\t\t    GET_MODE (SUBREG_REG (to))))\n+\t      if (COMBINE_RTX_EQUAL_P (XEXP (x, i), from))\n+\t\t{\n+\t\t  /* In general, don't install a subreg involving two\n+\t\t     modes not tieable.  It can worsen register\n+\t\t     allocation, and can even make invalid reload\n+\t\t     insns, since the reg inside may need to be copied\n+\t\t     from in the outside mode, and that may be invalid\n+\t\t     if it is an fp reg copied in integer mode.\n+\n+\t\t     We allow two exceptions to this: It is valid if\n+\t\t     it is inside another SUBREG and the mode of that\n+\t\t     SUBREG and the mode of the inside of TO is\n+\t\t     tieable and it is valid if X is a SET that copies\n+\t\t     FROM to CC0.  */\n+\n+\t\t  if (GET_CODE (to) == SUBREG\n+\t\t      && ! MODES_TIEABLE_P (GET_MODE (to),\n+\t\t\t\t\t    GET_MODE (SUBREG_REG (to)))\n+\t\t      && ! (code == SUBREG\n+\t\t\t    && MODES_TIEABLE_P (GET_MODE (x),\n+\t\t\t\t\t\tGET_MODE (SUBREG_REG (to))))\n #ifdef HAVE_cc0\n-\t\t  && ! (code == SET && i == 1 && XEXP (x, 0) == cc0_rtx)\n+\t\t      && ! (code == SET && i == 1 && XEXP (x, 0) == cc0_rtx)\n #endif\n-\t\t  )\n-\t\treturn gen_rtx_CLOBBER (VOIDmode, const0_rtx);\n+\t\t      )\n+\t\t    return gen_rtx_CLOBBER (VOIDmode, const0_rtx);\n \n-\t      new = (unique_copy && n_occurrences ? copy_rtx (to) : to);\n-\t      n_occurrences++;\n+\t\t  new = (unique_copy && n_occurrences ? copy_rtx (to) : to);\n+\t\t  n_occurrences++;\n+\t\t}\n+\t      else\n+\t\t/* If we are in a SET_DEST, suppress most cases unless we\n+\t\t   have gone inside a MEM, in which case we want to\n+\t\t   simplify the address.  We assume here that things that\n+\t\t   are actually part of the destination have their inner\n+\t\t   parts in the first expression.  This is true for SUBREG, \n+\t\t   STRICT_LOW_PART, and ZERO_EXTRACT, which are the only\n+\t\t   things aside from REG and MEM that should appear in a\n+\t\t   SET_DEST.  */\n+\t\tnew = subst (XEXP (x, i), from, to,\n+\t\t\t     (((in_dest\n+\t\t\t\t&& (code == SUBREG || code == STRICT_LOW_PART\n+\t\t\t\t    || code == ZERO_EXTRACT))\n+\t\t\t       || code == SET)\n+\t\t\t      && i == 0), unique_copy);\n+\n+\t      /* If we found that we will have to reject this combination,\n+\t\t indicate that by returning the CLOBBER ourselves, rather than\n+\t\t an expression containing it.  This will speed things up as\n+\t\t well as prevent accidents where two CLOBBERs are considered\n+\t\t to be equal, thus producing an incorrect simplification.  */\n+\n+\t      if (GET_CODE (new) == CLOBBER && XEXP (new, 0) == const0_rtx)\n+\t\treturn new;\n+\n+\t      SUBST (XEXP (x, i), new);\n \t    }\n-\t  else\n-\t    /* If we are in a SET_DEST, suppress most cases unless we\n-\t       have gone inside a MEM, in which case we want to\n-\t       simplify the address.  We assume here that things that\n-\t       are actually part of the destination have their inner\n-\t       parts in the first expression.  This is true for SUBREG, \n-\t       STRICT_LOW_PART, and ZERO_EXTRACT, which are the only\n-\t       things aside from REG and MEM that should appear in a\n-\t       SET_DEST.  */\n-\t    new = subst (XEXP (x, i), from, to,\n-\t\t\t (((in_dest\n-\t\t\t    && (code == SUBREG || code == STRICT_LOW_PART\n-\t\t\t\t|| code == ZERO_EXTRACT))\n-\t\t\t   || code == SET)\n-\t\t\t  && i == 0), unique_copy);\n-\n-\t  /* If we found that we will have to reject this combination,\n-\t     indicate that by returning the CLOBBER ourselves, rather than\n-\t     an expression containing it.  This will speed things up as\n-\t     well as prevent accidents where two CLOBBERs are considered\n-\t     to be equal, thus producing an incorrect simplification.  */\n-\n-\t  if (GET_CODE (new) == CLOBBER && XEXP (new, 0) == const0_rtx)\n-\t    return new;\n-\n-\t  SUBST (XEXP (x, i), new);\n \t}\n     }\n "}]}