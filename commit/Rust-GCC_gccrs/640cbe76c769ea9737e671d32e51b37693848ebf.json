{"sha": "640cbe76c769ea9737e671d32e51b37693848ebf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQwY2JlNzZjNzY5ZWE5NzM3ZTY3MWQzMmU1MWIzNzY5Mzg0OGViZg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2008-09-04T22:33:10Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2008-09-04T22:33:10Z"}, "message": "re PR libstdc++/36962 ([C++0x] Add constructors / assignment operators from unique_ptr to shared_ptr)\n\n\tPR libstdc++/36962\n\t* include/Makefile.am: Update headers.\n\t* include/Makefile.in: Regenerate.\n\t* include/std/memory: Update headers.\n\t* include/tr1/memory: Likewise.\n\t* include/tr1_impl/boost_shared_ptr.h: Remove, splitting into\n\tseparate implementations for std and tr1.\n\t* include/bits/boost_sp_shared_count.h: Remove.\n\t* include/tr1/boost_sp_shared_count.h: Remove.\n\t* include/bits/shared_ptr.h: New. Combines boost_sp_shared_count.h\n\tand boost_shared_ptr.h into one file.\n\t(__shared_count,__shared_ptr,shared_ptr,swap): Add unique_ptr\n\tand rvalue-reference support as per current WP.\n\t* include/tr1/shared_ptr.h: New. Combines boost_sp_shared_count.h\n\tand boost_shared_ptr.h into one file.\n\t* testsuite/20_util/shared_ptr/cons/unique_ptr.cc: New.\n\t* testsuite/20_util/shared_ptr/cons/unique_ptr_deleter.cc: New.\n\t* testsuite/20_util/shared_ptr/cons/unique_ptr_deleter_ref.cc: New.\n\t* testsuite/20_util/shared_ptr/cons/unique_ptr_neg.cc: New.\n\t* testsuite/20_util/shared_ptr/assign/auto_ptr_rvalue.cc: New.\n\t* testsuite/20_util/shared_ptr/assign/unique_ptr_lvalue_neg.cc: New.\n\t* testsuite/20_util/shared_ptr/assign/unique_ptr_rvalue.cc: New.\n\t* testsuite/20_util/shared_ptr/modifiers/swap_rvalue.cc: New.\n\t* testsuite/20_util/shared_ptr/assign/auto_ptr_rvalue_neg.cc: Remove.\n\nFrom-SVN: r140012", "tree": {"sha": "a9b85eb527c9aec92b2c0cd8c2e05c88b56d1091", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9b85eb527c9aec92b2c0cd8c2e05c88b56d1091"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/640cbe76c769ea9737e671d32e51b37693848ebf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/640cbe76c769ea9737e671d32e51b37693848ebf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/640cbe76c769ea9737e671d32e51b37693848ebf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/640cbe76c769ea9737e671d32e51b37693848ebf/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5299815b887b832f44672c5939fe7ccce119995e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5299815b887b832f44672c5939fe7ccce119995e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5299815b887b832f44672c5939fe7ccce119995e"}], "stats": {"total": 2954, "additions": 2061, "deletions": 893}, "files": [{"sha": "f82f441d749298c84b0f3b48598c625324a98102", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=640cbe76c769ea9737e671d32e51b37693848ebf", "patch": "@@ -1,3 +1,30 @@\n+2008-09-04  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\tPR libstdc++/36962\n+\t* include/Makefile.am: Update headers.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/std/memory: Update headers.\n+\t* include/tr1/memory: Likewise.\n+\t* include/tr1_impl/boost_shared_ptr.h: Remove, splitting into\n+\tseparate implementations for std and tr1.\n+\t* include/bits/boost_sp_shared_count.h: Remove.\n+\t* include/tr1/boost_sp_shared_count.h: Remove.\n+\t* include/bits/shared_ptr.h: New. Combines boost_sp_shared_count.h\n+\tand boost_shared_ptr.h into one file.\n+\t(__shared_count,__shared_ptr,shared_ptr,swap): Add unique_ptr\n+\tand rvalue-reference support as per current WP.\n+\t* include/tr1/shared_ptr.h: New. Combines boost_sp_shared_count.h\n+\tand boost_shared_ptr.h into one file.\n+\t* testsuite/20_util/shared_ptr/cons/unique_ptr.cc: New.\n+\t* testsuite/20_util/shared_ptr/cons/unique_ptr_deleter.cc: New.\n+\t* testsuite/20_util/shared_ptr/cons/unique_ptr_deleter_ref.cc: New.\n+\t* testsuite/20_util/shared_ptr/cons/unique_ptr_neg.cc: New.\n+\t* testsuite/20_util/shared_ptr/assign/auto_ptr_rvalue.cc: New.\n+\t* testsuite/20_util/shared_ptr/assign/unique_ptr_lvalue_neg.cc: New.\n+\t* testsuite/20_util/shared_ptr/assign/unique_ptr_rvalue.cc: New.\n+\t* testsuite/20_util/shared_ptr/modifiers/swap_rvalue.cc: New.\n+\t* testsuite/20_util/shared_ptr/assign/auto_ptr_rvalue_neg.cc: Remove.\n+\n 2008-09-04  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* doc/xml/manual/locale.xml: Fix typo."}, {"sha": "d5f5fa2a119c9d8c19922e4a8f7d597ae40303b8", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=640cbe76c769ea9737e671d32e51b37693848ebf", "patch": "@@ -81,7 +81,6 @@ bits_headers = \\\n \t${bits_srcdir}/basic_string.h \\\n \t${bits_srcdir}/basic_string.tcc \\\n \t${bits_srcdir}/boost_concept_check.h \\\n-\t${bits_srcdir}/boost_sp_shared_count.h \\\n \t${bits_srcdir}/char_traits.h \\\n \t${bits_srcdir}/codecvt.h \\\n \t${bits_srcdir}/concept_check.h \\\n@@ -111,6 +110,7 @@ bits_headers = \\\n \t${bits_srcdir}/postypes.h \\\n \t${bits_srcdir}/stream_iterator.h \\\n \t${bits_srcdir}/streambuf_iterator.h \\\n+\t${bits_srcdir}/shared_ptr.h \\\n \t${bits_srcdir}/slice_array.h \\\n \t${bits_srcdir}/sstream.tcc \\\n \t${bits_srcdir}/stl_algo.h \\\n@@ -522,7 +522,6 @@ tr1_headers = \\\n \t${tr1_srcdir}/array \\\n \t${tr1_srcdir}/bessel_function.tcc \\\n \t${tr1_srcdir}/beta_function.tcc \\\n-\t${tr1_srcdir}/boost_sp_shared_count.h \\\n \t${tr1_srcdir}/ccomplex \\\n \t${tr1_srcdir}/cctype \\\n \t${tr1_srcdir}/cfenv \\\n@@ -562,6 +561,7 @@ tr1_headers = \\\n \t${tr1_srcdir}/random \\\n \t${tr1_srcdir}/regex \\\n \t${tr1_srcdir}/riemann_zeta.tcc \\\n+\t${tr1_srcdir}/shared_ptr.h \\\n \t${tr1_srcdir}/special_function_util.h \\\n \t${tr1_srcdir}/stdarg.h \\\n \t${tr1_srcdir}/stdbool.h \\\n@@ -582,7 +582,6 @@ tr1_impl_srcdir = ${glibcxx_srcdir}/include/tr1_impl\n tr1_impl_builddir = ./tr1_impl\n tr1_impl_headers = \\\n \t${tr1_impl_srcdir}/array \\\n-\t${tr1_impl_srcdir}/boost_shared_ptr.h \\\n \t${tr1_impl_srcdir}/boost_sp_counted_base.h \\\n \t${tr1_impl_srcdir}/cctype \\\n \t${tr1_impl_srcdir}/cfenv \\"}, {"sha": "a82b8843191d046ccaa255861137084b4b6b19e7", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=640cbe76c769ea9737e671d32e51b37693848ebf", "patch": "@@ -335,7 +335,6 @@ bits_headers = \\\n \t${bits_srcdir}/basic_string.h \\\n \t${bits_srcdir}/basic_string.tcc \\\n \t${bits_srcdir}/boost_concept_check.h \\\n-\t${bits_srcdir}/boost_sp_shared_count.h \\\n \t${bits_srcdir}/char_traits.h \\\n \t${bits_srcdir}/codecvt.h \\\n \t${bits_srcdir}/concept_check.h \\\n@@ -365,6 +364,7 @@ bits_headers = \\\n \t${bits_srcdir}/postypes.h \\\n \t${bits_srcdir}/stream_iterator.h \\\n \t${bits_srcdir}/streambuf_iterator.h \\\n+\t${bits_srcdir}/shared_ptr.h \\\n \t${bits_srcdir}/slice_array.h \\\n \t${bits_srcdir}/sstream.tcc \\\n \t${bits_srcdir}/stl_algo.h \\\n@@ -774,7 +774,6 @@ tr1_headers = \\\n \t${tr1_srcdir}/array \\\n \t${tr1_srcdir}/bessel_function.tcc \\\n \t${tr1_srcdir}/beta_function.tcc \\\n-\t${tr1_srcdir}/boost_sp_shared_count.h \\\n \t${tr1_srcdir}/ccomplex \\\n \t${tr1_srcdir}/cctype \\\n \t${tr1_srcdir}/cfenv \\\n@@ -814,6 +813,7 @@ tr1_headers = \\\n \t${tr1_srcdir}/random \\\n \t${tr1_srcdir}/regex \\\n \t${tr1_srcdir}/riemann_zeta.tcc \\\n+\t${tr1_srcdir}/shared_ptr.h \\\n \t${tr1_srcdir}/special_function_util.h \\\n \t${tr1_srcdir}/stdarg.h \\\n \t${tr1_srcdir}/stdbool.h \\\n@@ -833,7 +833,6 @@ tr1_impl_srcdir = ${glibcxx_srcdir}/include/tr1_impl\n tr1_impl_builddir = ./tr1_impl\n tr1_impl_headers = \\\n \t${tr1_impl_srcdir}/array \\\n-\t${tr1_impl_srcdir}/boost_shared_ptr.h \\\n \t${tr1_impl_srcdir}/boost_sp_counted_base.h \\\n \t${tr1_impl_srcdir}/cctype \\\n \t${tr1_impl_srcdir}/cfenv \\"}, {"sha": "75ee16d8eb21383bb62ded1e13304462a6bb8f13", "filename": "libstdc++-v3/include/bits/boost_sp_shared_count.h", "status": "removed", "additions": 0, "deletions": 378, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5299815b887b832f44672c5939fe7ccce119995e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fboost_sp_shared_count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5299815b887b832f44672c5939fe7ccce119995e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fboost_sp_shared_count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fboost_sp_shared_count.h?ref=5299815b887b832f44672c5939fe7ccce119995e", "patch": "@@ -1,378 +0,0 @@\n-// <bits/boost_sp_shared_count.h> -*- C++ -*-\n-\n-// Copyright (C) 2007 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-//  shared_count.hpp\n-//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n-\n-//  shared_ptr.hpp\n-//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n-//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n-\n-//  weak_ptr.hpp\n-//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n-\n-//  enable_shared_from_this.hpp\n-//  Copyright (C) 2002 Peter Dimov\n-\n-// Distributed under the Boost Software License, Version 1.0. (See\n-// accompanying file LICENSE_1_0.txt or copy at\n-// http://www.boost.org/LICENSE_1_0.txt)\n-\n-// GCC Note:  based on version 1.32.0 of the Boost library.\n-\n-/** @file bits/boost_sp_shared_count.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#ifndef __GXX_EXPERIMENTAL_CXX0X__\n-# include <c++0x_warning.h>\n-#endif\n-\n-#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n-#  error C++0x header cannot be included from TR1 header\n-#endif\n-\n-namespace std\n-{\n-  // counted ptr with no deleter or allocator support\n-  template<typename _Ptr, _Lock_policy _Lp>\n-    class _Sp_counted_ptr\n-    : public _Sp_counted_base<_Lp>\n-    {\n-    public:\n-      _Sp_counted_ptr(_Ptr __p)\n-      : _M_ptr(__p) { }\n-    \n-      virtual void\n-      _M_dispose() // nothrow\n-      { delete _M_ptr; }\n-      \n-      virtual void\n-      _M_destroy() // nothrow\n-      { delete this; }\n-      \n-      virtual void*\n-      _M_get_deleter(const std::type_info& __ti)\n-      { return 0; }\n-      \n-    private:\n-      _Sp_counted_ptr(const _Sp_counted_ptr&);\n-      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&);\n-      \n-    protected:\n-      _Ptr             _M_ptr;  // copy constructor must not throw\n-    };\n-\n-  // support for custom deleter and/or allocator\n-  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>\n-    class _Sp_counted_deleter\n-    : public _Sp_counted_ptr<_Ptr, _Lp>\n-    {\n-      typedef typename _Alloc::template\n-          rebind<_Sp_counted_deleter>::other _My_alloc_type;\n-\n-      // Helper class that stores the Deleter and also acts as an allocator.\n-      // Used to dispose of the owned pointer and the internal refcount\n-      // Requires that copies of _Alloc can free each other's memory.\n-      struct _My_Deleter\n-      : public _My_alloc_type    // copy constructor must not throw\n-      {\n-        _Deleter _M_del;         // copy constructor must not throw\n-        _My_Deleter(_Deleter __d, const _Alloc& __a)\n-          : _My_alloc_type(__a), _M_del(__d) { }\n-      };\n-\n-    protected:\n-      typedef _Sp_counted_ptr<_Ptr, _Lp> _Base_type;\n-\n-    public:\n-      /**\n-       *  @brief   \n-       *  @pre     __d(__p) must not throw.\n-       */\n-      _Sp_counted_deleter(_Ptr __p, _Deleter __d)\n-      : _Base_type(__p), _M_del(__d, _Alloc()) { }\n-    \n-      /**\n-       *  @brief   \n-       *  @pre     __d(__p) must not throw.\n-       */\n-      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a)\n-      : _Base_type(__p), _M_del(__d, __a) { }\n-    \n-      virtual void\n-      _M_dispose() // nothrow\n-      { _M_del._M_del(_Base_type::_M_ptr); }\n-      \n-      virtual void\n-      _M_destroy() // nothrow\n-      {\n-        _My_alloc_type __a(_M_del);\n-        this->~_Sp_counted_deleter();\n-        __a.deallocate(this, 1);\n-      }\n-      \n-      virtual void*\n-      _M_get_deleter(const std::type_info& __ti)\n-      { return __ti == typeid(_Deleter) ? &_M_del._M_del : 0; }\n-      \n-    private:\n-      _Sp_counted_deleter(const _Sp_counted_deleter&);\n-      _Sp_counted_deleter& operator=(const _Sp_counted_deleter&);\n-      \n-    protected:\n-      _My_Deleter      _M_del;  // copy constructor must not throw\n-    };\n-\n-  // helpers for make_shared / allocate_shared\n-\n-  template<typename _Tp>\n-    struct _Sp_destroy_inplace\n-    {\n-      void operator()(_Tp* __p) const { if (__p) __p->~_Tp(); }\n-    };\n-\n-  struct _Sp_make_shared_tag { };\n-\n-  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>\n-    class _Sp_counted_ptr_inplace\n-    : public _Sp_counted_deleter<_Tp*, _Sp_destroy_inplace<_Tp>, _Alloc, _Lp>\n-    {\n-      typedef _Sp_counted_deleter<_Tp*, _Sp_destroy_inplace<_Tp>, _Alloc, _Lp>\n-        _Base_type;\n-\n-    public:\n-      _Sp_counted_ptr_inplace(_Alloc __a)\n-      : _Base_type(static_cast<_Tp*>(0), _Sp_destroy_inplace<_Tp>(), __a)\n-      , _M_storage()\n-      {\n-        void* __p = &_M_storage;\n-        ::new (__p) _Tp();  // might throw\n-        _Base_type::_Base_type::_M_ptr = static_cast<_Tp*>(__p);\n-      }\n-\n-      template<typename... _Args>\n-        _Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)\n-        : _Base_type(static_cast<_Tp*>(0), _Sp_destroy_inplace<_Tp>(), __a)\n-        , _M_storage()\n-        {\n-          void* __p = &_M_storage;\n-          ::new (__p) _Tp(std::forward<_Args>(__args)...);  // might throw\n-          _Base_type::_Base_type::_M_ptr = static_cast<_Tp*>(__p);\n-        }\n-\n-      // override because the allocator needs to know the dynamic type\n-      virtual void\n-      _M_destroy() // nothrow\n-      {\n-        typedef typename _Alloc::template\n-            rebind<_Sp_counted_ptr_inplace>::other _My_alloc_type;\n-        _My_alloc_type __a(_Base_type::_M_del);\n-        this->~_Sp_counted_ptr_inplace();\n-        __a.deallocate(this, 1);\n-      }\n-\n-      // sneaky trick so __shared_ptr can get the managed pointer\n-      virtual void*\n-      _M_get_deleter(const std::type_info& __ti)\n-      {\n-        return __ti == typeid(_Sp_make_shared_tag)\n-               ? static_cast<void*>(&_M_storage)\n-               : _Base_type::_M_get_deleter(__ti);\n-      }\n-      \n-    private:\n-      typename aligned_storage<sizeof(_Tp), alignment_of<_Tp>::value>::type\n-        _M_storage;\n-    };\n-\n-  template<_Lock_policy _Lp = __default_lock_policy>\n-    class __weak_count;\n-\n-  template<_Lock_policy _Lp = __default_lock_policy>\n-    class __shared_count\n-    {\n-    public: \n-      __shared_count()\n-      : _M_pi(0) // nothrow\n-      { }\n-  \n-      template<typename _Ptr>\n-        __shared_count(_Ptr __p) : _M_pi(0)\n-        {\n-          try\n-            {\n-              _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);\n-            }\n-          catch(...)\n-            {\n-              delete __p;\n-              __throw_exception_again;\n-            }\n-        }\n-\n-      template<typename _Ptr, typename _Deleter>\n-        __shared_count(_Ptr __p, _Deleter __d) : _M_pi(0)\n-        {\n-          // allocator's value_type doesn't matter, will rebind it anyway\n-          typedef std::allocator<int> _Alloc;\n-          typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;\n-          typedef std::allocator<_Sp_cd_type> _Alloc2;\n-          _Alloc2 __a2;\n-          try\n-            {\n-              _M_pi = __a2.allocate(1);\n-              new(static_cast<void*>(_M_pi)) _Sp_cd_type(__p, __d);\n-            }\n-          catch(...)\n-            {\n-              __d(__p); // Call _Deleter on __p.\n-              if (_M_pi)\n-                __a2.deallocate(static_cast<_Sp_cd_type*>(_M_pi), 1);\n-              __throw_exception_again;\n-            }\n-        }\n-\n-      template<typename _Ptr, typename _Deleter, typename _Alloc>\n-        __shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)\n-        {\n-          typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;\n-          typedef typename _Alloc::template rebind<_Sp_cd_type>::other _Alloc2;\n-          _Alloc2 __a2(__a);\n-          try\n-            {\n-              _M_pi = __a2.allocate(1);\n-              new(static_cast<void*>(_M_pi)) _Sp_cd_type(__p, __d, __a);\n-            }\n-          catch(...)\n-            {\n-              __d(__p); // Call _Deleter on __p.\n-              if (_M_pi)\n-                __a2.deallocate(static_cast<_Sp_cd_type*>(_M_pi), 1);\n-              __throw_exception_again;\n-            }\n-        }\n-\n-      template<typename _Tp, typename _Alloc, typename... _Args>\n-        __shared_count(_Sp_make_shared_tag, _Tp*, _Alloc __a, _Args&&... __args)\n-        : _M_pi(0)\n-        {\n-          typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;\n-          typedef typename _Alloc::template rebind<_Sp_cp_type>::other _Alloc2;\n-          _Alloc2 __a2(__a);\n-          try\n-            {\n-              _M_pi = __a2.allocate(1);\n-              new(static_cast<void*>(_M_pi)) _Sp_cp_type(__a,\n-                  std::forward<_Args>(__args)...);\n-            }\n-          catch(...)\n-            {\n-              if (_M_pi)\n-        \t__a2.deallocate(static_cast<_Sp_cp_type*>(_M_pi), 1);\n-              __throw_exception_again;\n-            }\n-        }\n-\n-#if _GLIBCXX_DEPRECATED\n-      // Special case for auto_ptr<_Tp> to provide the strong guarantee.\n-      template<typename _Tp>\n-        explicit\n-        __shared_count(std::auto_ptr<_Tp>& __r)\n-        : _M_pi(new _Sp_counted_ptr<_Tp*, _Lp>(__r.get()))\n-        { __r.release(); }\n-#endif\n-  \n-      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.\n-      explicit\n-      __shared_count(const __weak_count<_Lp>& __r);\n-  \n-      ~__shared_count() // nothrow\n-      {\n-        if (_M_pi != 0)\n-          _M_pi->_M_release();\n-      }\n-\n-      __shared_count(const __shared_count& __r)\n-      : _M_pi(__r._M_pi) // nothrow\n-      {\n-        if (_M_pi != 0)\n-          _M_pi->_M_add_ref_copy();\n-      }\n-  \n-      __shared_count&\n-      operator=(const __shared_count& __r) // nothrow\n-      {\n-        _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n-        if (__tmp != _M_pi)\n-          {\n-            if (__tmp != 0)\n-              __tmp->_M_add_ref_copy();\n-            if (_M_pi != 0)\n-              _M_pi->_M_release();\n-            _M_pi = __tmp;\n-          }\n-        return *this;\n-      }\n-  \n-      void\n-      _M_swap(__shared_count& __r) // nothrow\n-      {\n-        _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n-        __r._M_pi = _M_pi;\n-        _M_pi = __tmp;\n-      }\n-  \n-      long\n-      _M_get_use_count() const // nothrow\n-      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }\n-\n-      bool\n-      _M_unique() const // nothrow\n-      { return this->_M_get_use_count() == 1; }\n-\n-      friend inline bool\n-      operator==(const __shared_count& __a, const __shared_count& __b)\n-      { return __a._M_pi == __b._M_pi; }\n-  \n-      friend inline bool\n-      operator<(const __shared_count& __a, const __shared_count& __b)\n-      { return std::less<_Sp_counted_base<_Lp>*>()(__a._M_pi, __b._M_pi); }\n-  \n-      void*\n-      _M_get_deleter(const std::type_info& __ti) const\n-      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : 0; }\n-\n-    private:\n-      friend class __weak_count<_Lp>;\n-\n-      _Sp_counted_base<_Lp>*  _M_pi;\n-    };\n-}"}, {"sha": "964797b140a4a4eb1dccf1584e8dad9fd18ea535", "filename": "libstdc++-v3/include/bits/shared_ptr.h", "status": "added", "additions": 1451, "deletions": 0, "changes": 1451, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h?ref=640cbe76c769ea9737e671d32e51b37693848ebf", "patch": "@@ -0,0 +1,1451 @@\n+// <bits/shared_ptr.h> -*- C++ -*-\n+\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//  shared_count.hpp\n+//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n+\n+//  shared_ptr.hpp\n+//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n+//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n+\n+//  weak_ptr.hpp\n+//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n+\n+//  enable_shared_from_this.hpp\n+//  Copyright (C) 2002 Peter Dimov\n+\n+// Distributed under the Boost Software License, Version 1.0. (See\n+// accompanying file LICENSE_1_0.txt or copy at\n+// http://www.boost.org/LICENSE_1_0.txt)\n+\n+// GCC Note:  based on version 1.32.0 of the Boost library.\n+\n+/** @file bits/shared_ptr.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef __GXX_EXPERIMENTAL_CXX0X__\n+# include <c++0x_warning.h>\n+#endif\n+\n+#if defined(_GLIBCXX_INCLUDE_AS_TR1)\n+#  error C++0x header cannot be included from TR1 header\n+#endif\n+\n+namespace std\n+{\n+  // counted ptr with no deleter or allocator support\n+  template<typename _Ptr, _Lock_policy _Lp>\n+    class _Sp_counted_ptr\n+    : public _Sp_counted_base<_Lp>\n+    {\n+    public:\n+      _Sp_counted_ptr(_Ptr __p)\n+      : _M_ptr(__p) { }\n+    \n+      virtual void\n+      _M_dispose() // nothrow\n+      { delete _M_ptr; }\n+      \n+      virtual void\n+      _M_destroy() // nothrow\n+      { delete this; }\n+      \n+      virtual void*\n+      _M_get_deleter(const std::type_info& __ti)\n+      { return 0; }\n+      \n+    private:\n+      _Sp_counted_ptr(const _Sp_counted_ptr&);\n+      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&);\n+      \n+    protected:\n+      _Ptr             _M_ptr;  // copy constructor must not throw\n+    };\n+\n+  // support for custom deleter and/or allocator\n+  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>\n+    class _Sp_counted_deleter\n+    : public _Sp_counted_ptr<_Ptr, _Lp>\n+    {\n+      typedef typename _Alloc::template\n+          rebind<_Sp_counted_deleter>::other _My_alloc_type;\n+\n+      // Helper class that stores the Deleter and also acts as an allocator.\n+      // Used to dispose of the owned pointer and the internal refcount\n+      // Requires that copies of _Alloc can free each other's memory.\n+      struct _My_Deleter\n+      : public _My_alloc_type    // copy constructor must not throw\n+      {\n+        _Deleter _M_del;         // copy constructor must not throw\n+        _My_Deleter(_Deleter __d, const _Alloc& __a)\n+          : _My_alloc_type(__a), _M_del(__d) { }\n+      };\n+\n+    protected:\n+      typedef _Sp_counted_ptr<_Ptr, _Lp> _Base_type;\n+\n+    public:\n+      /**\n+       *  @brief   \n+       *  @pre     __d(__p) must not throw.\n+       */\n+      _Sp_counted_deleter(_Ptr __p, _Deleter __d)\n+      : _Base_type(__p), _M_del(__d, _Alloc()) { }\n+    \n+      /**\n+       *  @brief   \n+       *  @pre     __d(__p) must not throw.\n+       */\n+      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a)\n+      : _Base_type(__p), _M_del(__d, __a) { }\n+    \n+      virtual void\n+      _M_dispose() // nothrow\n+      { _M_del._M_del(_Base_type::_M_ptr); }\n+      \n+      virtual void\n+      _M_destroy() // nothrow\n+      {\n+        _My_alloc_type __a(_M_del);\n+        this->~_Sp_counted_deleter();\n+        __a.deallocate(this, 1);\n+      }\n+      \n+      virtual void*\n+      _M_get_deleter(const std::type_info& __ti)\n+      { return __ti == typeid(_Deleter) ? &_M_del._M_del : 0; }\n+      \n+    private:\n+      _Sp_counted_deleter(const _Sp_counted_deleter&);\n+      _Sp_counted_deleter& operator=(const _Sp_counted_deleter&);\n+      \n+    protected:\n+      _My_Deleter      _M_del;  // copy constructor must not throw\n+    };\n+\n+  // helpers for make_shared / allocate_shared\n+\n+  template<typename _Tp>\n+    struct _Sp_destroy_inplace\n+    {\n+      void operator()(_Tp* __p) const { if (__p) __p->~_Tp(); }\n+    };\n+\n+  struct _Sp_make_shared_tag { };\n+\n+  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>\n+    class _Sp_counted_ptr_inplace\n+    : public _Sp_counted_deleter<_Tp*, _Sp_destroy_inplace<_Tp>, _Alloc, _Lp>\n+    {\n+      typedef _Sp_counted_deleter<_Tp*, _Sp_destroy_inplace<_Tp>, _Alloc, _Lp>\n+        _Base_type;\n+\n+    public:\n+      _Sp_counted_ptr_inplace(_Alloc __a)\n+      : _Base_type(static_cast<_Tp*>(0), _Sp_destroy_inplace<_Tp>(), __a)\n+      , _M_storage()\n+      {\n+        void* __p = &_M_storage;\n+        ::new (__p) _Tp();  // might throw\n+        _Base_type::_Base_type::_M_ptr = static_cast<_Tp*>(__p);\n+      }\n+\n+      template<typename... _Args>\n+        _Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)\n+        : _Base_type(static_cast<_Tp*>(0), _Sp_destroy_inplace<_Tp>(), __a)\n+        , _M_storage()\n+        {\n+          void* __p = &_M_storage;\n+          ::new (__p) _Tp(std::forward<_Args>(__args)...);  // might throw\n+          _Base_type::_Base_type::_M_ptr = static_cast<_Tp*>(__p);\n+        }\n+\n+      // override because the allocator needs to know the dynamic type\n+      virtual void\n+      _M_destroy() // nothrow\n+      {\n+        typedef typename _Alloc::template\n+            rebind<_Sp_counted_ptr_inplace>::other _My_alloc_type;\n+        _My_alloc_type __a(_Base_type::_M_del);\n+        this->~_Sp_counted_ptr_inplace();\n+        __a.deallocate(this, 1);\n+      }\n+\n+      // sneaky trick so __shared_ptr can get the managed pointer\n+      virtual void*\n+      _M_get_deleter(const std::type_info& __ti)\n+      {\n+        return __ti == typeid(_Sp_make_shared_tag)\n+               ? static_cast<void*>(&_M_storage)\n+               : _Base_type::_M_get_deleter(__ti);\n+      }\n+      \n+    private:\n+      typename aligned_storage<sizeof(_Tp), alignment_of<_Tp>::value>::type\n+        _M_storage;\n+    };\n+\n+  template<_Lock_policy _Lp = __default_lock_policy>\n+    class __weak_count;\n+\n+  template<_Lock_policy _Lp = __default_lock_policy>\n+    class __shared_count\n+    {\n+    public: \n+      __shared_count()\n+      : _M_pi(0) // nothrow\n+      { }\n+  \n+      template<typename _Ptr>\n+        __shared_count(_Ptr __p) : _M_pi(0)\n+        {\n+          try\n+            {\n+              _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);\n+            }\n+          catch(...)\n+            {\n+              delete __p;\n+              __throw_exception_again;\n+            }\n+        }\n+\n+      template<typename _Ptr, typename _Deleter>\n+        __shared_count(_Ptr __p, _Deleter __d) : _M_pi(0)\n+        {\n+          // allocator's value_type doesn't matter, will rebind it anyway\n+          typedef std::allocator<int> _Alloc;\n+          typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;\n+          typedef std::allocator<_Sp_cd_type> _Alloc2;\n+          _Alloc2 __a2;\n+          try\n+            {\n+              _M_pi = __a2.allocate(1);\n+              new(static_cast<void*>(_M_pi)) _Sp_cd_type(__p, __d);\n+            }\n+          catch(...)\n+            {\n+              __d(__p); // Call _Deleter on __p.\n+              if (_M_pi)\n+                __a2.deallocate(static_cast<_Sp_cd_type*>(_M_pi), 1);\n+              __throw_exception_again;\n+            }\n+        }\n+\n+      template<typename _Ptr, typename _Deleter, typename _Alloc>\n+        __shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)\n+        {\n+          typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;\n+          typedef typename _Alloc::template rebind<_Sp_cd_type>::other _Alloc2;\n+          _Alloc2 __a2(__a);\n+          try\n+            {\n+              _M_pi = __a2.allocate(1);\n+              new(static_cast<void*>(_M_pi)) _Sp_cd_type(__p, __d, __a);\n+            }\n+          catch(...)\n+            {\n+              __d(__p); // Call _Deleter on __p.\n+              if (_M_pi)\n+                __a2.deallocate(static_cast<_Sp_cd_type*>(_M_pi), 1);\n+              __throw_exception_again;\n+            }\n+        }\n+\n+      template<typename _Tp, typename _Alloc, typename... _Args>\n+        __shared_count(_Sp_make_shared_tag, _Tp*, _Alloc __a, _Args&&... __args)\n+        : _M_pi(0)\n+        {\n+          typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;\n+          typedef typename _Alloc::template rebind<_Sp_cp_type>::other _Alloc2;\n+          _Alloc2 __a2(__a);\n+          try\n+            {\n+              _M_pi = __a2.allocate(1);\n+              new(static_cast<void*>(_M_pi)) _Sp_cp_type(__a,\n+                  std::forward<_Args>(__args)...);\n+            }\n+          catch(...)\n+            {\n+              if (_M_pi)\n+        \t__a2.deallocate(static_cast<_Sp_cp_type*>(_M_pi), 1);\n+              __throw_exception_again;\n+            }\n+        }\n+\n+#if _GLIBCXX_DEPRECATED\n+      // Special case for auto_ptr<_Tp> to provide the strong guarantee.\n+      template<typename _Tp>\n+        explicit\n+        __shared_count(std::auto_ptr<_Tp>&& __r)\n+        : _M_pi(new _Sp_counted_ptr<_Tp*, _Lp>(__r.get()))\n+        { __r.release(); }\n+#endif\n+\n+      // Special case for unique_ptr<_Tp,_Del> to provide the strong guarantee.\n+      template<typename _Tp, typename _Del>\n+        explicit\n+        __shared_count(std::unique_ptr<_Tp, _Del>&& __r)\n+        : _M_pi(_S_create_from_up(std::move(__r)))\n+        { __r.release(); }\n+\n+      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.\n+      explicit\n+      __shared_count(const __weak_count<_Lp>& __r);\n+  \n+      ~__shared_count() // nothrow\n+      {\n+        if (_M_pi != 0)\n+          _M_pi->_M_release();\n+      }\n+\n+      __shared_count(const __shared_count& __r)\n+      : _M_pi(__r._M_pi) // nothrow\n+      {\n+        if (_M_pi != 0)\n+          _M_pi->_M_add_ref_copy();\n+      }\n+  \n+      __shared_count&\n+      operator=(const __shared_count& __r) // nothrow\n+      {\n+        _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+        if (__tmp != _M_pi)\n+          {\n+            if (__tmp != 0)\n+              __tmp->_M_add_ref_copy();\n+            if (_M_pi != 0)\n+              _M_pi->_M_release();\n+            _M_pi = __tmp;\n+          }\n+        return *this;\n+      }\n+  \n+      void\n+      _M_swap(__shared_count& __r) // nothrow\n+      {\n+        _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+        __r._M_pi = _M_pi;\n+        _M_pi = __tmp;\n+      }\n+  \n+      long\n+      _M_get_use_count() const // nothrow\n+      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }\n+\n+      bool\n+      _M_unique() const // nothrow\n+      { return this->_M_get_use_count() == 1; }\n+\n+      friend inline bool\n+      operator==(const __shared_count& __a, const __shared_count& __b)\n+      { return __a._M_pi == __b._M_pi; }\n+  \n+      friend inline bool\n+      operator<(const __shared_count& __a, const __shared_count& __b)\n+      { return std::less<_Sp_counted_base<_Lp>*>()(__a._M_pi, __b._M_pi); }\n+  \n+      void*\n+      _M_get_deleter(const std::type_info& __ti) const\n+      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : 0; }\n+\n+    private:\n+      friend class __weak_count<_Lp>;\n+\n+      template<typename _Tp, typename _Del>\n+        static _Sp_counted_base<_Lp>*\n+        _S_create_from_up(std::unique_ptr<_Tp, _Del>&& __r,\n+          typename std::enable_if<!std::is_reference<_Del>::value>::type* = 0)\n+        {\n+          return new _Sp_counted_deleter<_Tp*, _Del, std::allocator<_Tp>,\n+            _Lp>(__r.get(), __r.get_deleter());\n+        }\n+\n+      template<typename _Tp, typename _Del>\n+        static _Sp_counted_base<_Lp>*\n+        _S_create_from_up(std::unique_ptr<_Tp, _Del>&& __r,\n+          typename std::enable_if<std::is_reference<_Del>::value>::type* = 0)\n+        {\n+          typedef typename std::remove_reference<_Del>::type _Del1;\n+          typedef std::reference_wrapper<_Del1> _Del2;\n+          return new _Sp_counted_deleter<_Tp*, _Del2, std::allocator<_Tp>,\n+            _Lp>(__r.get(), std::ref(__r.get_deleter()));\n+        }\n+\n+      _Sp_counted_base<_Lp>*  _M_pi;\n+    };\n+\n+\n+  template<_Lock_policy _Lp>\n+    class __weak_count\n+    {\n+    public:\n+      __weak_count()\n+      : _M_pi(0) // nothrow\n+      { }\n+  \n+      __weak_count(const __shared_count<_Lp>& __r)\n+      : _M_pi(__r._M_pi) // nothrow\n+      {\n+\tif (_M_pi != 0)\n+\t  _M_pi->_M_weak_add_ref();\n+      }\n+      \n+      __weak_count(const __weak_count<_Lp>& __r)\n+      : _M_pi(__r._M_pi) // nothrow\n+      {\n+\tif (_M_pi != 0)\n+\t  _M_pi->_M_weak_add_ref();\n+      }\n+      \n+      ~__weak_count() // nothrow\n+      {\n+\tif (_M_pi != 0)\n+\t  _M_pi->_M_weak_release();\n+      }\n+      \n+      __weak_count<_Lp>&\n+      operator=(const __shared_count<_Lp>& __r) // nothrow\n+      {\n+\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+\tif (__tmp != 0)\n+\t  __tmp->_M_weak_add_ref();\n+\tif (_M_pi != 0)\n+\t  _M_pi->_M_weak_release();\n+\t_M_pi = __tmp;  \n+\treturn *this;\n+      }\n+      \n+      __weak_count<_Lp>&\n+      operator=(const __weak_count<_Lp>& __r) // nothrow\n+      {\n+\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+\tif (__tmp != 0)\n+\t  __tmp->_M_weak_add_ref();\n+\tif (_M_pi != 0)\n+\t  _M_pi->_M_weak_release();\n+\t_M_pi = __tmp;\n+\treturn *this;\n+      }\n+\n+      void\n+      _M_swap(__weak_count<_Lp>& __r) // nothrow\n+      {\n+\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+\t__r._M_pi = _M_pi;\n+\t_M_pi = __tmp;\n+      }\n+  \n+      long\n+      _M_get_use_count() const // nothrow\n+      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }\n+\n+      friend inline bool\n+      operator==(const __weak_count<_Lp>& __a, const __weak_count<_Lp>& __b)\n+      { return __a._M_pi == __b._M_pi; }\n+      \n+      friend inline bool\n+      operator<(const __weak_count<_Lp>& __a, const __weak_count<_Lp>& __b)\n+      { return std::less<_Sp_counted_base<_Lp>*>()(__a._M_pi, __b._M_pi); }\n+\n+    private:\n+      friend class __shared_count<_Lp>;\n+\n+      _Sp_counted_base<_Lp>*  _M_pi;\n+    };\n+\n+  // now that __weak_count is defined we can define this constructor:\n+  template<_Lock_policy _Lp>\n+    inline\n+    __shared_count<_Lp>::\n+    __shared_count(const __weak_count<_Lp>& __r)\n+    : _M_pi(__r._M_pi)\n+    {\n+      if (_M_pi != 0)\n+\t_M_pi->_M_add_ref_lock();\n+      else\n+\t__throw_bad_weak_ptr();\n+    }\n+\n+  // Forward declarations.\n+  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n+    class __shared_ptr;\n+  \n+  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n+    class __weak_ptr;\n+\n+  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n+    class __enable_shared_from_this;\n+\n+  template<typename _Tp>\n+    class shared_ptr;\n+  \n+  template<typename _Tp>\n+    class weak_ptr;\n+\n+  template<typename _Tp>\n+    class enable_shared_from_this;\n+\n+  // Support for enable_shared_from_this.\n+\n+  // Friend of __enable_shared_from_this.\n+  template<_Lock_policy _Lp, typename _Tp1, typename _Tp2>\n+    void\n+    __enable_shared_from_this_helper(const __shared_count<_Lp>&,\n+\t\t\t\t     const __enable_shared_from_this<_Tp1,\n+\t\t\t\t     _Lp>*, const _Tp2*);\n+\n+  // Friend of enable_shared_from_this.\n+  template<typename _Tp1, typename _Tp2>\n+    void\n+    __enable_shared_from_this_helper(const __shared_count<>&,\n+\t\t\t\t     const enable_shared_from_this<_Tp1>*,\n+\t\t\t\t     const _Tp2*);\n+\n+  template<_Lock_policy _Lp>\n+    inline void\n+    __enable_shared_from_this_helper(const __shared_count<_Lp>&, ...)\n+    { }\n+\n+\n+  /**\n+   *  @class __shared_ptr \n+   *\n+   *  A smart pointer with reference-counted copy semantics.\n+   *  The object pointed to is deleted when the last shared_ptr pointing to\n+   *  it is destroyed or reset.\n+   */\n+  template<typename _Tp, _Lock_policy _Lp>\n+    class __shared_ptr\n+    {\n+    public:\n+      typedef _Tp   element_type;\n+      \n+      /** @brief  Construct an empty %__shared_ptr.\n+       *  @post   use_count()==0 && get()==0\n+       */\n+      __shared_ptr()\n+      : _M_ptr(0), _M_refcount() // never throws\n+      { }\n+\n+      /** @brief  Construct a %__shared_ptr that owns the pointer @a __p.\n+       *  @param  __p  A pointer that is convertible to element_type*.\n+       *  @post   use_count() == 1 && get() == __p\n+       *  @throw  std::bad_alloc, in which case @c delete @a __p is called.\n+       */\n+      template<typename _Tp1>\n+        explicit\n+        __shared_ptr(_Tp1* __p)\n+\t: _M_ptr(__p), _M_refcount(__p)\n+        {\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  // __glibcxx_function_requires(_CompleteConcept<_Tp1*>)\n+\t  __enable_shared_from_this_helper(_M_refcount, __p, __p);\n+\t}\n+\n+      //\n+      // Requirements: _Deleter's copy constructor and destructor must\n+      // not throw\n+      //\n+      // __shared_ptr will release __p by calling __d(__p)\n+      //\n+      /** @brief  Construct a %__shared_ptr that owns the pointer @a __p\n+       *          and the deleter @a __d.\n+       *  @param  __p  A pointer.\n+       *  @param  __d  A deleter.\n+       *  @post   use_count() == 1 && get() == __p\n+       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n+       */\n+      template<typename _Tp1, typename _Deleter>\n+        __shared_ptr(_Tp1* __p, _Deleter __d)\n+        : _M_ptr(__p), _M_refcount(__p, __d)\n+        {\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  // TODO requires _Deleter CopyConstructible and __d(__p) well-formed\n+\t  __enable_shared_from_this_helper(_M_refcount, __p, __p);\n+\t}\n+      \n+      //\n+      // Requirements: _Deleter's copy constructor and destructor must\n+      // not throw _Alloc's copy constructor and destructor must not\n+      // throw.\n+      //\n+      // __shared_ptr will release __p by calling __d(__p)\n+      //\n+      /** @brief  Construct a %__shared_ptr that owns the pointer @a __p\n+       *          and the deleter @a __d.\n+       *  @param  __p  A pointer.\n+       *  @param  __d  A deleter.\n+       *  @param  __a  An allocator.\n+       *  @post   use_count() == 1 && get() == __p\n+       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n+       */\n+      template<typename _Tp1, typename _Deleter, typename _Alloc>\n+        __shared_ptr(_Tp1* __p, _Deleter __d, const _Alloc& __a)\n+\t: _M_ptr(__p), _M_refcount(__p, __d, __a)\n+        {\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  // TODO requires _Deleter CopyConstructible and __d(__p) well-formed\n+\t  __enable_shared_from_this_helper(_M_refcount, __p, __p);\n+\t}\n+\n+      /** @brief  Constructs a %__shared_ptr instance that stores @a __p\n+       *          and shares ownership with @a __r.\n+       *  @param  __r  A %__shared_ptr.\n+       *  @param  __p  A pointer that will remain valid while @a *__r is valid.\n+       *  @post   get() == __p && use_count() == __r.use_count()\n+       *\n+       *  This can be used to construct a @c shared_ptr to a sub-object\n+       *  of an object managed by an existing @c shared_ptr.\n+       *\n+       * @code\n+       * shared_ptr< pair<int,int> > pii(new pair<int,int>());\n+       * shared_ptr<int> pi(pii, &pii->first);\n+       * assert(pii.use_count() == 2);\n+       * @endcode\n+       */\n+      template<typename _Tp1>\n+        __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p)\n+\t: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws\n+        { }\n+\n+      //  generated copy constructor, assignment, destructor are fine.\n+      \n+      /** @brief  If @a __r is empty, constructs an empty %__shared_ptr;\n+       *          otherwise construct a %__shared_ptr that shares ownership\n+       *          with @a __r.\n+       *  @param  __r  A %__shared_ptr.\n+       *  @post   get() == __r.get() && use_count() == __r.use_count()\n+       */\n+      template<typename _Tp1>\n+        __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r)\n+\t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n+        { __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>) }\n+\n+      /** @brief  Move-constructs a %__shared_ptr instance from @a __r.\n+       *  @param  __r  A %__shared_ptr rvalue.\n+       *  @post   *this contains the old value of @a __r, @a __r is empty.\n+       */\n+      __shared_ptr(__shared_ptr&& __r)\n+      : _M_ptr(__r._M_ptr), _M_refcount() // never throws\n+      {\n+        _M_refcount._M_swap(__r._M_refcount);\n+        __r._M_ptr = 0;\n+      }\n+\n+      /** @brief  Move-constructs a %__shared_ptr instance from @a __r.\n+       *  @param  __r  A %__shared_ptr rvalue.\n+       *  @post   *this contains the old value of @a __r, @a __r is empty.\n+       */\n+      template<typename _Tp1>\n+        __shared_ptr(__shared_ptr<_Tp1, _Lp>&& __r)\n+\t: _M_ptr(__r._M_ptr), _M_refcount() // never throws\n+        {\n+          __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+          _M_refcount._M_swap(__r._M_refcount);\n+          __r._M_ptr = 0;\n+        }\n+\n+      /** @brief  Constructs a %__shared_ptr that shares ownership with @a __r\n+       *          and stores a copy of the pointer stored in @a __r.\n+       *  @param  __r  A weak_ptr.\n+       *  @post   use_count() == __r.use_count()\n+       *  @throw  bad_weak_ptr when __r.expired(),\n+       *          in which case the constructor has no effect.\n+       */\n+      template<typename _Tp1>\n+        explicit\n+        __shared_ptr(const __weak_ptr<_Tp1, _Lp>& __r)\n+\t: _M_refcount(__r._M_refcount) // may throw\n+        {\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  // It is now safe to copy __r._M_ptr, as _M_refcount(__r._M_refcount)\n+\t  // did not throw.\n+\t  _M_ptr = __r._M_ptr;\n+\t}\n+\n+      template<typename _Tp1, typename _Del>\n+        explicit\n+        __shared_ptr(const std::unique_ptr<_Tp1, _Del>&) = delete;\n+\n+      /**\n+       * If an exception is thrown this constructor has no effect.\n+       */\n+      template<typename _Tp1, typename _Del>\n+        explicit\n+        __shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)\n+\t: _M_ptr(__r.get()), _M_refcount()\n+        {\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  _Tp1* __tmp = __r.get();\n+\t  _M_refcount = __shared_count<_Lp>(std::move(__r));\n+\t  __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp);\n+\t}\n+\n+#if _GLIBCXX_DEPRECATED\n+      /**\n+       * @post use_count() == 1 and __r.get() == 0\n+       */\n+      template<typename _Tp1>\n+        explicit\n+        __shared_ptr(std::auto_ptr<_Tp1>&& __r)\n+\t: _M_ptr(__r.get()), _M_refcount()\n+        {\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  // TODO requires _Tp1 is complete, delete __r.release() well-formed\n+\t  _Tp1* __tmp = __r.get();\n+\t  _M_refcount = __shared_count<_Lp>(std::move(__r));\n+\t  __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp);\n+\t}\n+#endif\n+\n+      template<typename _Tp1>\n+        __shared_ptr&\n+        operator=(const __shared_ptr<_Tp1, _Lp>& __r) // never throws\n+        {\n+\t  _M_ptr = __r._M_ptr;\n+\t  _M_refcount = __r._M_refcount; // __shared_count::op= doesn't throw\n+\t  return *this;\n+\t}\n+\n+#if _GLIBCXX_DEPRECATED\n+      template<typename _Tp1>\n+        __shared_ptr&\n+        operator=(std::auto_ptr<_Tp1>&& __r)\n+        {\n+\t  __shared_ptr(std::move(__r)).swap(*this);\n+\t  return *this;\n+\t}\n+#endif\n+\n+      __shared_ptr&\n+      operator=(__shared_ptr&& __r)\n+      {\n+        __shared_ptr(std::move(__r)).swap(*this);\n+        return *this;\n+      }\n+     \n+      template<class _Tp1>\n+        __shared_ptr&\n+        operator=(__shared_ptr<_Tp1, _Lp>&& __r)\n+        {\n+          __shared_ptr(std::move(__r)).swap(*this);\n+          return *this;\n+        }\n+\n+      template<typename _Tp1, typename _Del>\n+        __shared_ptr&\n+        operator=(const std::unique_ptr<_Tp1, _Del>& __r) = delete;\n+\n+      template<typename _Tp1, typename _Del>\n+        __shared_ptr&\n+        operator=(std::unique_ptr<_Tp1, _Del>&& __r)\n+        {\n+\t  __shared_ptr(std::move(__r)).swap(*this);\n+\t  return *this;\n+        }\n+\n+      void\n+      reset() // never throws\n+      { __shared_ptr().swap(*this); }\n+\n+      template<typename _Tp1>\n+        void\n+        reset(_Tp1* __p) // _Tp1 must be complete.\n+        {\n+\t  // Catch self-reset errors.\n+\t  _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != _M_ptr); \n+\t  __shared_ptr(__p).swap(*this);\n+\t}\n+\n+      template<typename _Tp1, typename _Deleter>\n+        void\n+        reset(_Tp1* __p, _Deleter __d)\n+        { __shared_ptr(__p, __d).swap(*this); }\n+\n+      template<typename _Tp1, typename _Deleter, typename _Alloc>\n+        void\n+        reset(_Tp1* __p, _Deleter __d, const _Alloc& __a)\n+        { __shared_ptr(__p, __d, __a).swap(*this); }\n+\n+      // Allow class instantiation when _Tp is [cv-qual] void.\n+      typename std::add_lvalue_reference<_Tp>::type\n+      operator*() const // never throws\n+      {\n+\t_GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n+\treturn *_M_ptr;\n+      }\n+\n+      _Tp*\n+      operator->() const // never throws\n+      {\n+\t_GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n+\treturn _M_ptr;\n+      }\n+    \n+      _Tp*\n+      get() const // never throws\n+      { return _M_ptr; }\n+\n+      // Implicit conversion to \"bool\"\n+    private:\n+      typedef _Tp* __shared_ptr::*__unspecified_bool_type;\n+\n+    public:\n+      operator __unspecified_bool_type() const // never throws\n+      { return _M_ptr == 0 ? 0 : &__shared_ptr::_M_ptr; }\n+\n+      bool\n+      unique() const // never throws\n+      { return _M_refcount._M_unique(); }\n+\n+      long\n+      use_count() const // never throws\n+      { return _M_refcount._M_get_use_count(); }\n+\n+      void\n+      swap(__shared_ptr<_Tp, _Lp>&& __other) // never throws\n+      {\n+\tstd::swap(_M_ptr, __other._M_ptr);\n+\t_M_refcount._M_swap(__other._M_refcount);\n+      }\n+\n+    protected:\n+      // This constructor is non-standard, it is used by allocate_shared.\n+      template<typename _Alloc, typename... _Args>\n+        __shared_ptr(_Sp_make_shared_tag __tag, _Alloc __a, _Args&&... __args)\n+        : _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,\n+\t\t\t\tstd::forward<_Args>(__args)...)\n+        {\n+          // _M_ptr needs to point to the newly constructed object.\n+          // This relies on _Sp_counted_ptr_inplace::_M_get_deleter.\n+          void* __p = _M_refcount._M_get_deleter(typeid(__tag));\n+          _M_ptr = static_cast<_Tp*>(__p);\n+\t  __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);\n+        }\n+\n+      template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,\n+               typename... _Args>\n+        friend __shared_ptr<_Tp1, _Lp1>\n+        __allocate_shared(_Alloc __a, _Args&&... __args);\n+\n+    private:\n+      void*\n+      _M_get_deleter(const std::type_info& __ti) const\n+      { return _M_refcount._M_get_deleter(__ti); }\n+\n+      template<typename _Tp1, _Lock_policy _Lp1>\n+        bool\n+        _M_less(const __shared_ptr<_Tp1, _Lp1>& __rhs) const\n+        { return _M_refcount < __rhs._M_refcount; }\n+\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n+\n+      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>\n+        friend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&);\n+\n+      // Friends injected into enclosing namespace and found by ADL:\n+      template<typename _Tp1>\n+        friend inline bool\n+        operator==(const __shared_ptr& __a, const __shared_ptr<_Tp1, _Lp>& __b)\n+        { return __a.get() == __b.get(); }\n+\n+      template<typename _Tp1>\n+        friend inline bool\n+        operator!=(const __shared_ptr& __a, const __shared_ptr<_Tp1, _Lp>& __b)\n+        { return __a.get() != __b.get(); }\n+\n+      template<typename _Tp1>\n+        friend inline bool\n+        operator<(const __shared_ptr& __a, const __shared_ptr<_Tp1, _Lp>& __b)\n+        { return __a._M_less(__b); }\n+\n+      _Tp*         \t   _M_ptr;         // Contained pointer.\n+      __shared_count<_Lp>  _M_refcount;    // Reference counter.\n+    };\n+\n+  // 2.2.3.8 shared_ptr specialized algorithms.\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline void\n+    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b)\n+    { __a.swap(__b); }\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline void\n+    swap(__shared_ptr<_Tp, _Lp>&& __a, __shared_ptr<_Tp, _Lp>& __b)\n+    { __a.swap(__b); }\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline void\n+    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>&& __b)\n+    { __a.swap(__b); }\n+\n+  // 2.2.3.9 shared_ptr casts\n+  /** @warning The seemingly equivalent\n+   *           <code>shared_ptr<_Tp, _Lp>(static_cast<_Tp*>(__r.get()))</code>\n+   *           will eventually result in undefined behaviour,\n+   *           attempting to delete the same object twice.\n+   */\n+  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n+    inline __shared_ptr<_Tp, _Lp>\n+    static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n+    { return __shared_ptr<_Tp, _Lp>(__r, static_cast<_Tp*>(__r.get())); }\n+\n+  /** @warning The seemingly equivalent\n+   *           <code>shared_ptr<_Tp, _Lp>(const_cast<_Tp*>(__r.get()))</code>\n+   *           will eventually result in undefined behaviour,\n+   *           attempting to delete the same object twice.\n+   */\n+  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n+    inline __shared_ptr<_Tp, _Lp>\n+    const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n+    { return __shared_ptr<_Tp, _Lp>(__r, const_cast<_Tp*>(__r.get())); }\n+\n+  /** @warning The seemingly equivalent\n+   *           <code>shared_ptr<_Tp, _Lp>(dynamic_cast<_Tp*>(__r.get()))</code>\n+   *           will eventually result in undefined behaviour,\n+   *           attempting to delete the same object twice.\n+   */\n+  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n+    inline __shared_ptr<_Tp, _Lp>\n+    dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n+    {\n+      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))\n+        return __shared_ptr<_Tp, _Lp>(__r, __p);\n+      return __shared_ptr<_Tp, _Lp>();\n+    }\n+\n+  // 2.2.3.7 shared_ptr I/O\n+  template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>\n+    std::basic_ostream<_Ch, _Tr>&\n+    operator<<(std::basic_ostream<_Ch, _Tr>& __os, \n+\t       const __shared_ptr<_Tp, _Lp>& __p)\n+    {\n+      __os << __p.get();\n+      return __os;\n+    }\n+\n+  // 2.2.3.10 shared_ptr get_deleter (experimental)\n+  template<typename _Del, typename _Tp, _Lock_policy _Lp>\n+    inline _Del*\n+    get_deleter(const __shared_ptr<_Tp, _Lp>& __p)\n+    { return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del))); }\n+\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    class __weak_ptr\n+    {\n+    public:\n+      typedef _Tp element_type;\n+      \n+      __weak_ptr()\n+      : _M_ptr(0), _M_refcount() // never throws\n+      { }\n+\n+      // Generated copy constructor, assignment, destructor are fine.\n+      \n+      // The \"obvious\" converting constructor implementation:\n+      //\n+      //  template<typename _Tp1>\n+      //    __weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r)\n+      //    : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n+      //    { }\n+      //\n+      // has a serious problem.\n+      //\n+      //  __r._M_ptr may already have been invalidated. The _M_ptr(__r._M_ptr)\n+      //  conversion may require access to *__r._M_ptr (virtual inheritance).\n+      //\n+      // It is not possible to avoid spurious access violations since\n+      // in multithreaded programs __r._M_ptr may be invalidated at any point.\n+      template<typename _Tp1>\n+        __weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r)\n+\t: _M_refcount(__r._M_refcount) // never throws\n+        {\n+\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n+\t  _M_ptr = __r.lock().get();\n+\t}\n+\n+      template<typename _Tp1>\n+        __weak_ptr(const __shared_ptr<_Tp1, _Lp>& __r)\n+\t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n+        { __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>) }\n+\n+      template<typename _Tp1>\n+        __weak_ptr&\n+        operator=(const __weak_ptr<_Tp1, _Lp>& __r) // never throws\n+        {\n+\t  _M_ptr = __r.lock().get();\n+\t  _M_refcount = __r._M_refcount;\n+\t  return *this;\n+\t}\n+      \n+      template<typename _Tp1>\n+        __weak_ptr&\n+        operator=(const __shared_ptr<_Tp1, _Lp>& __r) // never throws\n+        {\n+\t  _M_ptr = __r._M_ptr;\n+\t  _M_refcount = __r._M_refcount;\n+\t  return *this;\n+\t}\n+\n+      __shared_ptr<_Tp, _Lp>\n+      lock() const // never throws\n+      {\n+#ifdef __GTHREADS\n+\t// Optimization: avoid throw overhead.\n+\tif (expired())\n+\t  return __shared_ptr<element_type, _Lp>();\n+\n+\ttry\n+\t  {\n+\t    return __shared_ptr<element_type, _Lp>(*this);\n+\t  }\n+\tcatch(const bad_weak_ptr&)\n+\t  {\n+\t    // Q: How can we get here?\n+\t    // A: Another thread may have invalidated r after the\n+\t    //    use_count test above.\n+\t    return __shared_ptr<element_type, _Lp>();\n+\t  }\n+\t\n+#else\n+\t// Optimization: avoid try/catch overhead when single threaded.\n+\treturn expired() ? __shared_ptr<element_type, _Lp>()\n+\t                 : __shared_ptr<element_type, _Lp>(*this);\n+\n+#endif\n+      } // XXX MT\n+\n+      long\n+      use_count() const // never throws\n+      { return _M_refcount._M_get_use_count(); }\n+\n+      bool\n+      expired() const // never throws\n+      { return _M_refcount._M_get_use_count() == 0; }\n+      \n+      void\n+      reset() // never throws\n+      { __weak_ptr().swap(*this); }\n+\n+      void\n+      swap(__weak_ptr& __s) // never throws\n+      {\n+\tstd::swap(_M_ptr, __s._M_ptr);\n+\t_M_refcount._M_swap(__s._M_refcount);\n+      }\n+\n+    private:\n+      // Used by __enable_shared_from_this.\n+      void\n+      _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount)\n+      {\n+\t_M_ptr = __ptr;\n+\t_M_refcount = __refcount;\n+      }\n+\n+      template<typename _Tp1>\n+        bool\n+        _M_less(const __weak_ptr<_Tp1, _Lp>& __rhs) const\n+        { return _M_refcount < __rhs._M_refcount; }\n+\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n+      friend class __enable_shared_from_this<_Tp, _Lp>;\n+      friend class enable_shared_from_this<_Tp>;\n+\n+      // Friend injected into namespace and found by ADL.\n+      template<typename _Tp1>\n+        friend inline bool\n+        operator<(const __weak_ptr& __lhs, const __weak_ptr<_Tp1, _Lp>& __rhs)\n+        { return __lhs._M_less(__rhs); }\n+\n+      _Tp*       \t _M_ptr;         // Contained pointer.\n+      __weak_count<_Lp>  _M_refcount;    // Reference counter.\n+    };\n+\n+  // 2.2.4.7 weak_ptr specialized algorithms.\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline void\n+    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b)\n+    { __a.swap(__b); }\n+\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    class __enable_shared_from_this\n+    {\n+    protected:\n+      __enable_shared_from_this() { }\n+      \n+      __enable_shared_from_this(const __enable_shared_from_this&) { }\n+      \n+      __enable_shared_from_this&\n+      operator=(const __enable_shared_from_this&)\n+      { return *this; }\n+\n+      ~__enable_shared_from_this() { }\n+      \n+    public:\n+      __shared_ptr<_Tp, _Lp>\n+      shared_from_this()\n+      { return __shared_ptr<_Tp, _Lp>(this->_M_weak_this); }\n+\n+      __shared_ptr<const _Tp, _Lp>\n+      shared_from_this() const\n+      { return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this); }\n+\n+    private:\n+      template<typename _Tp1>\n+        void\n+        _M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const\n+        { _M_weak_this._M_assign(__p, __n); }\n+\n+      template<typename _Tp1>\n+        friend void\n+        __enable_shared_from_this_helper(const __shared_count<_Lp>& __pn,\n+\t\t\t\t\t const __enable_shared_from_this* __pe,\n+\t\t\t\t\t const _Tp1* __px)\n+        {\n+\t  if (__pe != 0)\n+\t    __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);\n+\t}\n+\n+      mutable __weak_ptr<_Tp, _Lp>  _M_weak_this;\n+    };\n+\n+\n+  /// shared_ptr\n+  // The actual shared_ptr, with forwarding constructors and\n+  // assignment operators.\n+  template<typename _Tp>\n+    class shared_ptr\n+    : public __shared_ptr<_Tp>\n+    {\n+    public:\n+      shared_ptr()\n+      : __shared_ptr<_Tp>() { }\n+\n+      template<typename _Tp1>\n+        explicit\n+        shared_ptr(_Tp1* __p)\n+\t: __shared_ptr<_Tp>(__p) { }\n+\n+      template<typename _Tp1, typename _Deleter>\n+        shared_ptr(_Tp1* __p, _Deleter __d)\n+\t: __shared_ptr<_Tp>(__p, __d) { }\n+\n+      template<typename _Tp1, typename _Deleter, typename _Alloc>\n+        shared_ptr(_Tp1* __p, _Deleter __d, const _Alloc& __a)\n+\t: __shared_ptr<_Tp>(__p, __d, __a) { }\n+\n+      // Aliasing constructor\n+      template<typename _Tp1>\n+        shared_ptr(const shared_ptr<_Tp1>& __r, _Tp* __p)\n+\t: __shared_ptr<_Tp>(__r, __p) { }\n+\n+      template<typename _Tp1>\n+        shared_ptr(const shared_ptr<_Tp1>& __r)\n+\t: __shared_ptr<_Tp>(__r) { }\n+\n+      shared_ptr(shared_ptr&& __r)\n+      : __shared_ptr<_Tp>(std::move(__r)) { }\n+\n+      template<typename _Tp1>\n+        shared_ptr(shared_ptr<_Tp1>&& __r)\n+        : __shared_ptr<_Tp>(std::move(__r)) { }\n+\n+      template<typename _Tp1>\n+        explicit\n+        shared_ptr(const weak_ptr<_Tp1>& __r)\n+\t: __shared_ptr<_Tp>(__r) { }\n+\n+#if _GLIBCXX_DEPRECATED\n+      template<typename _Tp1>\n+        explicit\n+        shared_ptr(std::auto_ptr<_Tp1>&& __r)\n+\t: __shared_ptr<_Tp>(std::move(__r)) { }\n+#endif\n+\n+      template<typename _Tp1, typename _Del>\n+        explicit\n+        shared_ptr(const std::unique_ptr<_Tp1, _Del>&) = delete;\n+\n+      template<typename _Tp1, typename _Del>\n+        explicit\n+        shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)\n+\t: __shared_ptr<_Tp>(std::move(__r)) { }\n+\n+      template<typename _Tp1>\n+        shared_ptr&\n+        operator=(const shared_ptr<_Tp1>& __r) // never throws\n+        {\n+\t  this->__shared_ptr<_Tp>::operator=(__r);\n+\t  return *this;\n+\t}\n+\n+#if _GLIBCXX_DEPRECATED\n+      template<typename _Tp1>\n+        shared_ptr&\n+        operator=(std::auto_ptr<_Tp1>&& __r)\n+        {\n+\t  this->__shared_ptr<_Tp>::operator=(std::move(__r));\n+\t  return *this;\n+\t}\n+#endif\n+\n+      shared_ptr&\n+      operator=(shared_ptr&& __r)\n+      {\n+        this->__shared_ptr<_Tp>::operator=(std::move(__r));\n+        return *this;\n+      }\n+     \n+      template<class _Tp1>\n+        shared_ptr&\n+        operator=(shared_ptr<_Tp1>&& __r)\n+        {\n+          this->__shared_ptr<_Tp>::operator=(std::move(__r));\n+          return *this;\n+        }\n+\n+      template<typename _Tp1, typename _Del>\n+        shared_ptr&\n+        operator=(const std::unique_ptr<_Tp1, _Del>& __r) = delete;\n+\n+      template<typename _Tp1, typename _Del>\n+        shared_ptr&\n+        operator=(std::unique_ptr<_Tp1, _Del>&& __r)\n+        {\n+\t  this->__shared_ptr<_Tp>::operator=(std::move(__r));\n+\t  return *this;\n+\t}\n+\n+    private:\n+      // This constructor is non-standard, it is used by allocate_shared.\n+      template<typename _Alloc, typename... _Args>\n+        shared_ptr(_Sp_make_shared_tag __tag, _Alloc __a, _Args&&... __args)\n+        : __shared_ptr<_Tp>(__tag, __a, std::forward<_Args>(__args)...)\n+        { }\n+\n+      template<typename _Tp1, typename _Alloc, typename... _Args>\n+        friend shared_ptr<_Tp1>\n+        allocate_shared(_Alloc __a, _Args&&... __args);\n+    };\n+\n+  // 20.7.12.2.9 shared_ptr specialized algorithms.\n+  template<typename _Tp>\n+    inline void\n+    swap(__shared_ptr<_Tp>& __a, __shared_ptr<_Tp>& __b)\n+    { __a.swap(__b); }\n+\n+  template<typename _Tp>\n+    inline void\n+    swap(__shared_ptr<_Tp>&& __a, __shared_ptr<_Tp>& __b)\n+    { __a.swap(__b); }\n+\n+  template<typename _Tp>\n+    inline void\n+    swap(__shared_ptr<_Tp>& __a, __shared_ptr<_Tp>&& __b)\n+    { __a.swap(__b); }\n+\n+  template<typename _Tp, typename _Tp1>\n+    inline shared_ptr<_Tp>\n+    static_pointer_cast(const shared_ptr<_Tp1>& __r)\n+    { return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get())); }\n+\n+  template<typename _Tp, typename _Tp1>\n+    inline shared_ptr<_Tp>\n+    const_pointer_cast(const shared_ptr<_Tp1>& __r)\n+    { return shared_ptr<_Tp>(__r, const_cast<_Tp*>(__r.get())); }\n+\n+  template<typename _Tp, typename _Tp1>\n+    inline shared_ptr<_Tp>\n+    dynamic_pointer_cast(const shared_ptr<_Tp1>& __r)\n+    {\n+      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))\n+        return shared_ptr<_Tp>(__r, __p);\n+      return shared_ptr<_Tp>();\n+    }\n+\n+\n+  /// weak_ptr\n+  // The actual weak_ptr, with forwarding constructors and\n+  // assignment operators.\n+  template<typename _Tp>\n+    class weak_ptr\n+    : public __weak_ptr<_Tp>\n+    {\n+    public:\n+      weak_ptr()\n+      : __weak_ptr<_Tp>() { }\n+      \n+      template<typename _Tp1>\n+        weak_ptr(const weak_ptr<_Tp1>& __r)\n+\t: __weak_ptr<_Tp>(__r) { }\n+\n+      template<typename _Tp1>\n+        weak_ptr(const shared_ptr<_Tp1>& __r)\n+\t: __weak_ptr<_Tp>(__r) { }\n+\n+      template<typename _Tp1>\n+        weak_ptr&\n+        operator=(const weak_ptr<_Tp1>& __r) // never throws\n+        {\n+\t  this->__weak_ptr<_Tp>::operator=(__r);\n+\t  return *this;\n+\t}\n+\n+      template<typename _Tp1>\n+        weak_ptr&\n+        operator=(const shared_ptr<_Tp1>& __r) // never throws\n+        {\n+\t  this->__weak_ptr<_Tp>::operator=(__r);\n+\t  return *this;\n+\t}\n+\n+      shared_ptr<_Tp>\n+      lock() const // never throws\n+      {\n+#ifdef __GTHREADS\n+\tif (this->expired())\n+\t  return shared_ptr<_Tp>();\n+\n+\ttry\n+\t  {\n+\t    return shared_ptr<_Tp>(*this);\n+\t  }\n+\tcatch(const bad_weak_ptr&)\n+\t  {\n+\t    return shared_ptr<_Tp>();\n+\t  }\n+#else\n+\treturn this->expired() ? shared_ptr<_Tp>()\n+\t                       : shared_ptr<_Tp>(*this);\n+#endif\n+      }\n+    };\n+\n+  /// enable_shared_from_this\n+  template<typename _Tp>\n+    class enable_shared_from_this\n+    {\n+    protected:\n+      enable_shared_from_this() { }\n+      \n+      enable_shared_from_this(const enable_shared_from_this&) { }\n+\n+      enable_shared_from_this&\n+      operator=(const enable_shared_from_this&)\n+      { return *this; }\n+\n+      ~enable_shared_from_this() { }\n+\n+    public:\n+      shared_ptr<_Tp>\n+      shared_from_this()\n+      { return shared_ptr<_Tp>(this->_M_weak_this); }\n+\n+      shared_ptr<const _Tp>\n+      shared_from_this() const\n+      { return shared_ptr<const _Tp>(this->_M_weak_this); }\n+\n+    private:\n+      template<typename _Tp1>\n+        void\n+        _M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const\n+        { _M_weak_this._M_assign(__p, __n); }\n+\n+      template<typename _Tp1>\n+        friend void\n+        __enable_shared_from_this_helper(const __shared_count<>& __pn,\n+\t\t\t\t\t const enable_shared_from_this* __pe,\n+\t\t\t\t\t const _Tp1* __px)\n+        {\n+\t  if (__pe != 0)\n+\t    __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);\n+\t}\n+\n+      mutable weak_ptr<_Tp>  _M_weak_this;\n+    };\n+\n+  template<typename _Tp, _Lock_policy _Lp, typename _Alloc, typename... _Args>\n+    inline __shared_ptr<_Tp, _Lp>\n+    __allocate_shared(_Alloc __a, _Args&&... __args)\n+    {\n+      return __shared_ptr<_Tp, _Lp>(_Sp_make_shared_tag(),\n+          std::forward<_Alloc>(__a), std::forward<_Args>(__args)...);\n+    }\n+\n+  template<typename _Tp, _Lock_policy _Lp, typename... _Args>\n+    inline __shared_ptr<_Tp, _Lp>\n+    __make_shared(_Args&&... __args)\n+    {\n+      typedef typename std::remove_const<_Tp>::type _Tp_nc;\n+      return __allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),\n+              std::forward<_Args>(__args)...);\n+    }\n+\n+  /** @brief  Create an object that is owned by a shared_ptr. \n+   *  @param  __a     An allocator.\n+   *  @param  __args  Arguments for the @a _Tp object's constructor.\n+   *  @return A shared_ptr that owns the newly created object.\n+   *  @throw  An exception thrown from @a _Alloc::allocate or from the\n+   *          constructor of @a _Tp.\n+   *\n+   *  A copy of @a __a will be used to allocate memory for the shared_ptr\n+   *  and the new object.\n+   */\n+  template<typename _Tp, typename _Alloc, typename... _Args>\n+    inline shared_ptr<_Tp>\n+    allocate_shared(_Alloc __a, _Args&&... __args)\n+    {\n+      return shared_ptr<_Tp>(_Sp_make_shared_tag(), std::forward<_Alloc>(__a),\n+              std::forward<_Args>(__args)...);\n+    }\n+\n+  /** @brief  Create an object that is owned by a shared_ptr. \n+   *  @param  __args  Arguments for the @a _Tp object's constructor.\n+   *  @return A shared_ptr that owns the newly created object.\n+   *  @throw  std::bad_alloc, or an exception thrown from the\n+   *          constructor of @a _Tp.\n+   */\n+  template<typename _Tp, typename... _Args>\n+    inline shared_ptr<_Tp>\n+    make_shared(_Args&&... __args)\n+    {\n+      typedef typename std::remove_const<_Tp>::type _Tp_nc;\n+      return allocate_shared<_Tp>(std::allocator<_Tp_nc>(),\n+              std::forward<_Args>(__args)...);\n+    }\n+\n+}"}, {"sha": "045477ec8cc90ae3f6db1f493b19111635f1fa7a", "filename": "libstdc++-v3/include/std/memory", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory?ref=640cbe76c769ea9737e671d32e51b37693848ebf", "patch": "@@ -72,21 +72,20 @@\n #  include <bits/unique_ptr.h>\n #  include <debug/debug.h>\n #  include <type_traits>\n+#  include <functional>\n #  if _GLIBCXX_DEPRECATED\n #    include <backward/auto_ptr.h>\n #  endif\n #  if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n #    include <tr1_impl/boost_sp_counted_base.h>\n-#    include <bits/boost_sp_shared_count.h>\n-#    include <tr1_impl/boost_shared_ptr.h>\n+#    include <bits/shared_ptr.h>\n #  else\n #    define _GLIBCXX_INCLUDE_AS_CXX0X\n #    define _GLIBCXX_BEGIN_NAMESPACE_TR1\n #    define _GLIBCXX_END_NAMESPACE_TR1\n #    define _GLIBCXX_TR1\n #    include <tr1_impl/boost_sp_counted_base.h>\n-#    include <bits/boost_sp_shared_count.h>\n-#    include <tr1_impl/boost_shared_ptr.h>\n+#    include <bits/shared_ptr.h>\n #    undef _GLIBCXX_TR1\n #    undef _GLIBCXX_END_NAMESPACE_TR1\n #    undef _GLIBCXX_BEGIN_NAMESPACE_TR1"}, {"sha": "a2de21f44399ce1138a9db3c75d0ca78e248a7f3", "filename": "libstdc++-v3/include/tr1/boost_sp_shared_count.h", "status": "removed", "additions": 0, "deletions": 214, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5299815b887b832f44672c5939fe7ccce119995e/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_sp_shared_count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5299815b887b832f44672c5939fe7ccce119995e/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_sp_shared_count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_sp_shared_count.h?ref=5299815b887b832f44672c5939fe7ccce119995e", "patch": "@@ -1,214 +0,0 @@\n-// <tr1/boost_sp_shared_count.h> -*- C++ -*-\n-\n-// Copyright (C) 2007 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-//  shared_count.hpp\n-//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n-\n-//  shared_ptr.hpp\n-//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n-//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n-\n-//  weak_ptr.hpp\n-//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n-\n-//  enable_shared_from_this.hpp\n-//  Copyright (C) 2002 Peter Dimov\n-\n-// Distributed under the Boost Software License, Version 1.0. (See\n-// accompanying file LICENSE_1_0.txt or copy at\n-// http://www.boost.org/LICENSE_1_0.txt)\n-\n-// GCC Note:  based on version 1.32.0 of the Boost library.\n-\n-/** @file tr1/boost_sp_shared_count.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n-#  error TR1 header cannot be included from C++0x header\n-#endif\n-\n-namespace std\n-{\n-namespace tr1\n-{\n-\n-  template<typename _Ptr, typename _Deleter, _Lock_policy _Lp>\n-    class _Sp_counted_base_impl\n-    : public _Sp_counted_base<_Lp>\n-    {\n-    public:\n-      /**\n-       *  @brief   \n-       *  @pre     __d(__p) must not throw.\n-       */\n-      _Sp_counted_base_impl(_Ptr __p, _Deleter __d)\n-      : _M_ptr(__p), _M_del(__d) { }\n-    \n-      virtual void\n-      _M_dispose() // nothrow\n-      { _M_del(_M_ptr); }\n-      \n-      virtual void*\n-      _M_get_deleter(const std::type_info& __ti)\n-      { return __ti == typeid(_Deleter) ? &_M_del : 0; }\n-      \n-    private:\n-      _Sp_counted_base_impl(const _Sp_counted_base_impl&);\n-      _Sp_counted_base_impl& operator=(const _Sp_counted_base_impl&);\n-      \n-      _Ptr      _M_ptr;  // copy constructor must not throw\n-      _Deleter  _M_del;  // copy constructor must not throw\n-    };\n-\n-  template<_Lock_policy _Lp = __default_lock_policy>\n-    class __weak_count;\n-\n-  template<typename _Tp>\n-    struct _Sp_deleter\n-    {\n-      typedef void result_type;\n-      typedef _Tp* argument_type;\n-      void operator()(_Tp* __p) const { delete __p; }\n-    };\n-\n-  template<_Lock_policy _Lp = __default_lock_policy>\n-    class __shared_count\n-    {\n-    public: \n-      __shared_count()\n-      : _M_pi(0) // nothrow\n-      { }\n-  \n-      template<typename _Ptr>\n-        __shared_count(_Ptr __p) : _M_pi(0)\n-        {\n-\t  try\n-\t    {\n-\t      typedef typename std::tr1::remove_pointer<_Ptr>::type _Tp;\n-\t      _M_pi = new _Sp_counted_base_impl<_Ptr, _Sp_deleter<_Tp>, _Lp>(\n-\t          __p, _Sp_deleter<_Tp>());\n-\t    }\n-\t  catch(...)\n-\t    {\n-\t      delete __p;\n-\t      __throw_exception_again;\n-\t    }\n-\t}\n-\n-      template<typename _Ptr, typename _Deleter>\n-        __shared_count(_Ptr __p, _Deleter __d) : _M_pi(0)\n-        {\n-\t  try\n-\t    {\n-\t      _M_pi = new _Sp_counted_base_impl<_Ptr, _Deleter, _Lp>(__p, __d);\n-\t    }\n-\t  catch(...)\n-\t    {\n-\t      __d(__p); // Call _Deleter on __p.\n-\t      __throw_exception_again;\n-\t    }\n-\t}\n-\n-      // Special case for auto_ptr<_Tp> to provide the strong guarantee.\n-      template<typename _Tp>\n-        explicit\n-        __shared_count(std::auto_ptr<_Tp>& __r)\n-\t: _M_pi(new _Sp_counted_base_impl<_Tp*,\n-\t\t_Sp_deleter<_Tp>, _Lp >(__r.get(), _Sp_deleter<_Tp>()))\n-        { __r.release(); }\n-\n-      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.\n-      explicit\n-      __shared_count(const __weak_count<_Lp>& __r);\n-  \n-      ~__shared_count() // nothrow\n-      {\n-\tif (_M_pi != 0)\n-\t  _M_pi->_M_release();\n-      }\n-      \n-      __shared_count(const __shared_count& __r)\n-      : _M_pi(__r._M_pi) // nothrow\n-      {\n-\tif (_M_pi != 0)\n-\t  _M_pi->_M_add_ref_copy();\n-      }\n-  \n-      __shared_count&\n-      operator=(const __shared_count& __r) // nothrow\n-      {\n-\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n-\tif (__tmp != _M_pi)\n-\t  {\n-\t    if (__tmp != 0)\n-\t      __tmp->_M_add_ref_copy();\n-\t    if (_M_pi != 0)\n-\t      _M_pi->_M_release();\n-\t    _M_pi = __tmp;\n-\t  }\n-\treturn *this;\n-      }\n-  \n-      void\n-      _M_swap(__shared_count& __r) // nothrow\n-      {\n-\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n-\t__r._M_pi = _M_pi;\n-\t_M_pi = __tmp;\n-      }\n-  \n-      long\n-      _M_get_use_count() const // nothrow\n-      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }\n-\n-      bool\n-      _M_unique() const // nothrow\n-      { return this->_M_get_use_count() == 1; }\n-      \n-      friend inline bool\n-      operator==(const __shared_count& __a, const __shared_count& __b)\n-      { return __a._M_pi == __b._M_pi; }\n-  \n-      friend inline bool\n-      operator<(const __shared_count& __a, const __shared_count& __b)\n-      { return std::less<_Sp_counted_base<_Lp>*>()(__a._M_pi, __b._M_pi); }\n-  \n-      void*\n-      _M_get_deleter(const std::type_info& __ti) const\n-      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : 0; }\n-\n-    private:\n-      friend class __weak_count<_Lp>;\n-\n-      _Sp_counted_base<_Lp>*  _M_pi;\n-    };\n-}\n-}"}, {"sha": "696a1821d1408480ba4df474bc2fb6a14bff0562", "filename": "libstdc++-v3/include/tr1/memory", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory?ref=640cbe76c769ea9737e671d32e51b37693848ebf", "patch": "@@ -55,16 +55,14 @@\n \n #if defined(_GLIBCXX_INCLUDE_AS_TR1)\n #  include <tr1_impl/boost_sp_counted_base.h>\n-#  include <tr1/boost_sp_shared_count.h>\n-#  include <tr1_impl/boost_shared_ptr.h>\n+#  include <tr1/shared_ptr.h>\n #else\n #  define _GLIBCXX_INCLUDE_AS_TR1\n #  define _GLIBCXX_BEGIN_NAMESPACE_TR1 namespace tr1 {\n #  define _GLIBCXX_END_NAMESPACE_TR1 }\n #  define _GLIBCXX_TR1 tr1::\n #  include <tr1_impl/boost_sp_counted_base.h>\n-#  include <tr1/boost_sp_shared_count.h>\n-#  include <tr1_impl/boost_shared_ptr.h>\n+#  include <tr1/shared_ptr.h>\n #  undef _GLIBCXX_TR1\n #  undef _GLIBCXX_END_NAMESPACE_TR1\n #  undef _GLIBCXX_BEGIN_NAMESPACE_TR1"}, {"sha": "2dcb90a397a29b00832c0ba53170af888168cf41", "filename": "libstdc++-v3/include/tr1/shared_ptr.h", "status": "renamed", "additions": 175, "deletions": 280, "changes": 455, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fshared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fshared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fshared_ptr.h?ref=640cbe76c769ea9737e671d32e51b37693848ebf", "patch": "@@ -1,4 +1,4 @@\n-// <tr1_impl/boost_shared_ptr.h> -*- C++ -*-\n+// <tr1/shared_ptr.h> -*- C++ -*-\n \n // Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n@@ -46,15 +46,171 @@\n \n // GCC Note:  based on version 1.32.0 of the Boost library.\n \n-/** @file tr1_impl/boost_shared_ptr.h\n+/** @file tr1/shared_ptr.h\n  *  This is an internal header file, included by other library headers.\n  *  You should not attempt to use it directly.\n  */\n \n+#if defined(_GLIBCXX_INCLUDE_AS_CXX0X)\n+#  error TR1 header cannot be included from C++0x header\n+#endif\n \n namespace std\n {\n-_GLIBCXX_BEGIN_NAMESPACE_TR1\n+namespace tr1\n+{\n+\n+  template<typename _Ptr, typename _Deleter, _Lock_policy _Lp>\n+    class _Sp_counted_base_impl\n+    : public _Sp_counted_base<_Lp>\n+    {\n+    public:\n+      /**\n+       *  @brief   \n+       *  @pre     __d(__p) must not throw.\n+       */\n+      _Sp_counted_base_impl(_Ptr __p, _Deleter __d)\n+      : _M_ptr(__p), _M_del(__d) { }\n+    \n+      virtual void\n+      _M_dispose() // nothrow\n+      { _M_del(_M_ptr); }\n+      \n+      virtual void*\n+      _M_get_deleter(const std::type_info& __ti)\n+      { return __ti == typeid(_Deleter) ? &_M_del : 0; }\n+      \n+    private:\n+      _Sp_counted_base_impl(const _Sp_counted_base_impl&);\n+      _Sp_counted_base_impl& operator=(const _Sp_counted_base_impl&);\n+      \n+      _Ptr      _M_ptr;  // copy constructor must not throw\n+      _Deleter  _M_del;  // copy constructor must not throw\n+    };\n+\n+  template<_Lock_policy _Lp = __default_lock_policy>\n+    class __weak_count;\n+\n+  template<typename _Tp>\n+    struct _Sp_deleter\n+    {\n+      typedef void result_type;\n+      typedef _Tp* argument_type;\n+      void operator()(_Tp* __p) const { delete __p; }\n+    };\n+\n+  template<_Lock_policy _Lp = __default_lock_policy>\n+    class __shared_count\n+    {\n+    public: \n+      __shared_count()\n+      : _M_pi(0) // nothrow\n+      { }\n+  \n+      template<typename _Ptr>\n+        __shared_count(_Ptr __p) : _M_pi(0)\n+        {\n+\t  try\n+\t    {\n+\t      typedef typename std::tr1::remove_pointer<_Ptr>::type _Tp;\n+\t      _M_pi = new _Sp_counted_base_impl<_Ptr, _Sp_deleter<_Tp>, _Lp>(\n+\t          __p, _Sp_deleter<_Tp>());\n+\t    }\n+\t  catch(...)\n+\t    {\n+\t      delete __p;\n+\t      __throw_exception_again;\n+\t    }\n+\t}\n+\n+      template<typename _Ptr, typename _Deleter>\n+        __shared_count(_Ptr __p, _Deleter __d) : _M_pi(0)\n+        {\n+\t  try\n+\t    {\n+\t      _M_pi = new _Sp_counted_base_impl<_Ptr, _Deleter, _Lp>(__p, __d);\n+\t    }\n+\t  catch(...)\n+\t    {\n+\t      __d(__p); // Call _Deleter on __p.\n+\t      __throw_exception_again;\n+\t    }\n+\t}\n+\n+      // Special case for auto_ptr<_Tp> to provide the strong guarantee.\n+      template<typename _Tp>\n+        explicit\n+        __shared_count(std::auto_ptr<_Tp>& __r)\n+\t: _M_pi(new _Sp_counted_base_impl<_Tp*,\n+\t\t_Sp_deleter<_Tp>, _Lp >(__r.get(), _Sp_deleter<_Tp>()))\n+        { __r.release(); }\n+\n+      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.\n+      explicit\n+      __shared_count(const __weak_count<_Lp>& __r);\n+  \n+      ~__shared_count() // nothrow\n+      {\n+\tif (_M_pi != 0)\n+\t  _M_pi->_M_release();\n+      }\n+      \n+      __shared_count(const __shared_count& __r)\n+      : _M_pi(__r._M_pi) // nothrow\n+      {\n+\tif (_M_pi != 0)\n+\t  _M_pi->_M_add_ref_copy();\n+      }\n+  \n+      __shared_count&\n+      operator=(const __shared_count& __r) // nothrow\n+      {\n+\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+\tif (__tmp != _M_pi)\n+\t  {\n+\t    if (__tmp != 0)\n+\t      __tmp->_M_add_ref_copy();\n+\t    if (_M_pi != 0)\n+\t      _M_pi->_M_release();\n+\t    _M_pi = __tmp;\n+\t  }\n+\treturn *this;\n+      }\n+  \n+      void\n+      _M_swap(__shared_count& __r) // nothrow\n+      {\n+\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+\t__r._M_pi = _M_pi;\n+\t_M_pi = __tmp;\n+      }\n+  \n+      long\n+      _M_get_use_count() const // nothrow\n+      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }\n+\n+      bool\n+      _M_unique() const // nothrow\n+      { return this->_M_get_use_count() == 1; }\n+      \n+      friend inline bool\n+      operator==(const __shared_count& __a, const __shared_count& __b)\n+      { return __a._M_pi == __b._M_pi; }\n+  \n+      friend inline bool\n+      operator<(const __shared_count& __a, const __shared_count& __b)\n+      { return std::less<_Sp_counted_base<_Lp>*>()(__a._M_pi, __b._M_pi); }\n+  \n+      void*\n+      _M_get_deleter(const std::type_info& __ti) const\n+      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : 0; }\n+\n+    private:\n+      friend class __weak_count<_Lp>;\n+\n+      _Sp_counted_base<_Lp>*  _M_pi;\n+    };\n+\n \n   template<_Lock_policy _Lp>\n     class __weak_count\n@@ -188,11 +344,9 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n     { }\n \n \n-#ifdef _GLIBCXX_INCLUDE_AS_TR1\n   struct __static_cast_tag { };\n   struct __const_cast_tag { };\n   struct __dynamic_cast_tag { };\n-#endif\n \n   /**\n    *  @class __shared_ptr \n@@ -251,52 +405,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t  __enable_shared_from_this_helper(_M_refcount, __p, __p);\n \t}\n       \n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      //\n-      // Requirements: _Deleter's copy constructor and destructor must\n-      // not throw _Alloc's copy constructor and destructor must not\n-      // throw.\n-      //\n-      // __shared_ptr will release __p by calling __d(__p)\n-      //\n-      /** @brief  Construct a %__shared_ptr that owns the pointer @a __p\n-       *          and the deleter @a __d.\n-       *  @param  __p  A pointer.\n-       *  @param  __d  A deleter.\n-       *  @param  __a  An allocator.\n-       *  @post   use_count() == 1 && get() == __p\n-       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n-       */\n-      template<typename _Tp1, typename _Deleter, typename _Alloc>\n-        __shared_ptr(_Tp1* __p, _Deleter __d, const _Alloc& __a)\n-\t: _M_ptr(__p), _M_refcount(__p, __d, __a)\n-        {\n-\t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-\t  // TODO requires _Deleter CopyConstructible and __d(__p) well-formed\n-\t  __enable_shared_from_this_helper(_M_refcount, __p, __p);\n-\t}\n-\n-      /** @brief  Constructs a %__shared_ptr instance that stores @a __p\n-       *          and shares ownership with @a __r.\n-       *  @param  __r  A %__shared_ptr.\n-       *  @param  __p  A pointer that will remain valid while @a *__r is valid.\n-       *  @post   get() == __p && use_count() == __r.use_count()\n-       *\n-       *  This can be used to construct a @c shared_ptr to a sub-object\n-       *  of an object managed by an existing @c shared_ptr.\n-       *\n-       * @code\n-       * shared_ptr< pair<int,int> > pii(new pair<int,int>());\n-       * shared_ptr<int> pi(pii, &pii->first);\n-       * assert(pii.use_count() == 2);\n-       * @endcode\n-       */\n-      template<typename _Tp1>\n-        __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p)\n-\t: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws\n-        { }\n-#endif\n-\n       //  generated copy constructor, assignment, destructor are fine.\n       \n       /** @brief  If @a __r is empty, constructs an empty %__shared_ptr;\n@@ -310,32 +418,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n         { __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>) }\n \n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      /** @brief  Move-constructs a %__shared_ptr instance from @a __r.\n-       *  @param  __r  A %__shared_ptr rvalue.\n-       *  @post   *this contains the old value of @a __r, @a __r is empty.\n-       */\n-      __shared_ptr(__shared_ptr&& __r)\n-      : _M_ptr(__r._M_ptr), _M_refcount() // never throws\n-      {\n-        _M_refcount._M_swap(__r._M_refcount);\n-        __r._M_ptr = 0;\n-      }\n-\n-      /** @brief  Move-constructs a %__shared_ptr instance from @a __r.\n-       *  @param  __r  A %__shared_ptr rvalue.\n-       *  @post   *this contains the old value of @a __r, @a __r is empty.\n-       */\n-      template<typename _Tp1>\n-        __shared_ptr(__shared_ptr<_Tp1, _Lp>&& __r)\n-\t: _M_ptr(__r._M_ptr), _M_refcount() // never throws\n-        {\n-          __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-          _M_refcount._M_swap(__r._M_refcount);\n-          __r._M_ptr = 0;\n-        }\n-#endif\n-\n       /** @brief  Constructs a %__shared_ptr that shares ownership with @a __r\n        *          and stores a copy of the pointer stored in @a __r.\n        *  @param  __r  A weak_ptr.\n@@ -354,10 +436,10 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t  _M_ptr = __r._M_ptr;\n \t}\n \n+#if !defined(__GXX_EXPERIMENTAL_CXX0X__) || _GLIBCXX_DEPRECATED\n       /**\n        * @post use_count() == 1 and __r.get() == 0\n        */\n-#if !defined(__GXX_EXPERIMENTAL_CXX0X__) || _GLIBCXX_DEPRECATED\n       template<typename _Tp1>\n         explicit\n         __shared_ptr(std::auto_ptr<_Tp1>& __r)\n@@ -369,9 +451,9 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t  _M_refcount = __shared_count<_Lp>(__r);\n \t  __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp);\n \t}\n+\n #endif\n \n-#ifdef _GLIBCXX_INCLUDE_AS_TR1\n       template<typename _Tp1>\n         __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, __static_cast_tag)\n \t: _M_ptr(static_cast<element_type*>(__r._M_ptr)),\n@@ -392,8 +474,7 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t  if (_M_ptr == 0) // need to allocate new counter -- the cast failed\n \t    _M_refcount = __shared_count<_Lp>();\n \t}\n-#endif\n-      \n+\n       template<typename _Tp1>\n         __shared_ptr&\n         operator=(const __shared_ptr<_Tp1, _Lp>& __r) // never throws\n@@ -413,23 +494,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t}\n #endif\n \n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      __shared_ptr&\n-      operator=(__shared_ptr&& __r)\n-      {\n-        __shared_ptr(std::move(__r)).swap(*this);\n-        return *this;\n-      }\n-     \n-      template<class _Tp1>\n-        __shared_ptr&\n-        operator=(__shared_ptr<_Tp1, _Lp>&& __r)\n-        {\n-          __shared_ptr(std::move(__r)).swap(*this);\n-          return *this;\n-        }\n-#endif\n-\n       void\n       reset() // never throws\n       { __shared_ptr().swap(*this); }\n@@ -448,18 +512,8 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n         reset(_Tp1* __p, _Deleter __d)\n         { __shared_ptr(__p, __d).swap(*this); }\n \n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      template<typename _Tp1, typename _Deleter, typename _Alloc>\n-        void\n-        reset(_Tp1* __p, _Deleter __d, const _Alloc& __a)\n-        { __shared_ptr(__p, __d, __a).swap(*this); }\n-\n-      // Allow class instantiation when _Tp is [cv-qual] void.\n-      typename std::add_lvalue_reference<_Tp>::type\n-#else\n       // Allow class instantiation when _Tp is [cv-qual] void.\n       typename std::tr1::add_reference<_Tp>::type\n-#endif\n       operator*() const // never throws\n       {\n \t_GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n@@ -500,27 +554,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t_M_refcount._M_swap(__other._M_refcount);\n       }\n \n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-    protected:\n-      // This constructor is non-standard, it is used by allocate_shared.\n-      template<typename _Alloc, typename... _Args>\n-        __shared_ptr(_Sp_make_shared_tag __tag, _Alloc __a, _Args&&... __args)\n-        : _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,\n-\t\t\t\tstd::forward<_Args>(__args)...)\n-        {\n-          // _M_ptr needs to point to the newly constructed object.\n-          // This relies on _Sp_counted_ptr_inplace::_M_get_deleter.\n-          void* __p = _M_refcount._M_get_deleter(typeid(__tag));\n-          _M_ptr = static_cast<_Tp*>(__p);\n-\t  __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);\n-        }\n-\n-      template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,\n-               typename... _Args>\n-        friend __shared_ptr<_Tp1, _Lp1>\n-        __allocate_shared(_Alloc __a, _Args&&... __args);\n-#endif\n-\n     private:\n       void*\n       _M_get_deleter(const std::type_info& __ti) const\n@@ -572,13 +605,7 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n   template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n     inline __shared_ptr<_Tp, _Lp>\n     static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n-    {\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      return __shared_ptr<_Tp, _Lp>(__r, static_cast<_Tp*>(__r.get()));\n-#else\n-      return __shared_ptr<_Tp, _Lp>(__r, __static_cast_tag());\n-#endif\n-    }\n+    { return __shared_ptr<_Tp, _Lp>(__r, __static_cast_tag()); }\n \n   /** @warning The seemingly equivalent\n    *           <code>shared_ptr<_Tp, _Lp>(const_cast<_Tp*>(__r.get()))</code>\n@@ -588,13 +615,7 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n   template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n     inline __shared_ptr<_Tp, _Lp>\n     const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n-    {\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      return __shared_ptr<_Tp, _Lp>(__r, const_cast<_Tp*>(__r.get()));\n-#else\n-      return __shared_ptr<_Tp, _Lp>(__r, __const_cast_tag());\n-#endif\n-    }\n+    { return __shared_ptr<_Tp, _Lp>(__r, __const_cast_tag()); }\n \n   /** @warning The seemingly equivalent\n    *           <code>shared_ptr<_Tp, _Lp>(dynamic_cast<_Tp*>(__r.get()))</code>\n@@ -604,15 +625,7 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n   template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n     inline __shared_ptr<_Tp, _Lp>\n     dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n-    {\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))\n-        return __shared_ptr<_Tp, _Lp>(__r, __p);\n-      return __shared_ptr<_Tp, _Lp>();\n-#else\n-      return __shared_ptr<_Tp, _Lp>(__r, __dynamic_cast_tag());\n-#endif\n-    }\n+    { return __shared_ptr<_Tp, _Lp>(__r, __dynamic_cast_tag()); }\n \n   // 2.2.3.7 shared_ptr I/O\n   template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>\n@@ -834,30 +847,10 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n         shared_ptr(_Tp1* __p, _Deleter __d)\n \t: __shared_ptr<_Tp>(__p, __d) { }\n \n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      template<typename _Tp1, typename _Deleter, typename _Alloc>\n-        shared_ptr(_Tp1* __p, _Deleter __d, const _Alloc& __a)\n-\t: __shared_ptr<_Tp>(__p, __d, __a) { }\n-\n-      // Aliasing constructor\n-      template<typename _Tp1>\n-        shared_ptr(const shared_ptr<_Tp1>& __r, _Tp* __p)\n-\t: __shared_ptr<_Tp>(__r, __p) { }\n-#endif\n-\n       template<typename _Tp1>\n         shared_ptr(const shared_ptr<_Tp1>& __r)\n \t: __shared_ptr<_Tp>(__r) { }\n \n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      shared_ptr(shared_ptr&& __r)\n-      : __shared_ptr<_Tp>(std::move(__r)) { }\n-\n-      template<typename _Tp1>\n-        shared_ptr(shared_ptr<_Tp1>&& __r)\n-        : __shared_ptr<_Tp>(std::move(__r)) { }\n-#endif\n-\n       template<typename _Tp1>\n         explicit\n         shared_ptr(const weak_ptr<_Tp1>& __r)\n@@ -870,7 +863,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t: __shared_ptr<_Tp>(__r) { }\n #endif\n \n-#ifdef _GLIBCXX_INCLUDE_AS_TR1\n       template<typename _Tp1>\n         shared_ptr(const shared_ptr<_Tp1>& __r, __static_cast_tag)\n \t: __shared_ptr<_Tp>(__r, __static_cast_tag()) { }\n@@ -882,7 +874,6 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n       template<typename _Tp1>\n         shared_ptr(const shared_ptr<_Tp1>& __r, __dynamic_cast_tag)\n \t: __shared_ptr<_Tp>(__r, __dynamic_cast_tag()) { }\n-#endif\n \n       template<typename _Tp1>\n         shared_ptr&\n@@ -901,72 +892,28 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n \t  return *this;\n \t}\n #endif\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      shared_ptr&\n-      operator=(shared_ptr&& __r)\n-      {\n-        this->__shared_ptr<_Tp>::operator=(std::move(__r));\n-        return *this;\n-      }\n-     \n-      template<class _Tp1>\n-        shared_ptr&\n-        operator=(shared_ptr<_Tp1>&& __r)\n-        {\n-          this->__shared_ptr<_Tp>::operator=(std::move(__r));\n-          return *this;\n-        }\n-#endif\n-\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-    private:\n-      // This constructor is non-standard, it is used by allocate_shared.\n-      template<typename _Alloc, typename... _Args>\n-        shared_ptr(_Sp_make_shared_tag __tag, _Alloc __a, _Args&&... __args)\n-        : __shared_ptr<_Tp>(__tag, __a, std::forward<_Args>(__args)...)\n-        { }\n-\n-      template<typename _Tp1, typename _Alloc, typename... _Args>\n-        friend shared_ptr<_Tp1>\n-        allocate_shared(_Alloc __a, _Args&&... __args);\n-#endif\n     };\n \n+  // 2.2.3.8 shared_ptr specialized algorithms.\n+  template<typename _Tp>\n+    inline void\n+    swap(__shared_ptr<_Tp>& __a, __shared_ptr<_Tp>& __b)\n+    { __a.swap(__b); }\n+\n   template<typename _Tp, typename _Tp1>\n     inline shared_ptr<_Tp>\n     static_pointer_cast(const shared_ptr<_Tp1>& __r)\n-    {\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n-#else\n-      return shared_ptr<_Tp>(__r, __static_cast_tag());\n-#endif\n-    }\n+    { return shared_ptr<_Tp>(__r, __static_cast_tag()); }\n \n   template<typename _Tp, typename _Tp1>\n     inline shared_ptr<_Tp>\n     const_pointer_cast(const shared_ptr<_Tp1>& __r)\n-    {\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      return shared_ptr<_Tp>(__r, const_cast<_Tp*>(__r.get()));\n-#else\n-      return shared_ptr<_Tp>(__r, __const_cast_tag());\n-#endif\n-    }\n+    { return shared_ptr<_Tp>(__r, __const_cast_tag()); }\n \n   template<typename _Tp, typename _Tp1>\n     inline shared_ptr<_Tp>\n     dynamic_pointer_cast(const shared_ptr<_Tp1>& __r)\n-    {\n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))\n-        return shared_ptr<_Tp>(__r, __p);\n-      return shared_ptr<_Tp>();\n-#else\n-      return shared_ptr<_Tp>(__r, __dynamic_cast_tag());\n-#endif\n-    }\n+    { return shared_ptr<_Tp>(__r, __dynamic_cast_tag()); }\n \n \n   /// weak_ptr\n@@ -1069,57 +1016,5 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n       mutable weak_ptr<_Tp>  _M_weak_this;\n     };\n \n-#ifdef _GLIBCXX_INCLUDE_AS_CXX0X\n-  template<typename _Tp, _Lock_policy _Lp, typename _Alloc, typename... _Args>\n-    inline __shared_ptr<_Tp, _Lp>\n-    __allocate_shared(_Alloc __a, _Args&&... __args)\n-    {\n-      return __shared_ptr<_Tp, _Lp>(_Sp_make_shared_tag(),\n-          std::forward<_Alloc>(__a), std::forward<_Args>(__args)...);\n-    }\n-\n-  template<typename _Tp, _Lock_policy _Lp, typename... _Args>\n-    inline __shared_ptr<_Tp, _Lp>\n-    __make_shared(_Args&&... __args)\n-    {\n-      typedef typename std::remove_const<_Tp>::type _Tp_nc;\n-      return __allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),\n-              std::forward<_Args>(__args)...);\n-    }\n-\n-  /** @brief  Create an object that is owned by a shared_ptr. \n-   *  @param  __a     An allocator.\n-   *  @param  __args  Arguments for the @a _Tp object's constructor.\n-   *  @return A shared_ptr that owns the newly created object.\n-   *  @throw  An exception thrown from @a _Alloc::allocate or from the\n-   *          constructor of @a _Tp.\n-   *\n-   *  A copy of @a __a will be used to allocate memory for the shared_ptr\n-   *  and the new object.\n-   */\n-  template<typename _Tp, typename _Alloc, typename... _Args>\n-    inline shared_ptr<_Tp>\n-    allocate_shared(_Alloc __a, _Args&&... __args)\n-    {\n-      return shared_ptr<_Tp>(_Sp_make_shared_tag(), std::forward<_Alloc>(__a),\n-              std::forward<_Args>(__args)...);\n-    }\n-\n-  /** @brief  Create an object that is owned by a shared_ptr. \n-   *  @param  __args  Arguments for the @a _Tp object's constructor.\n-   *  @return A shared_ptr that owns the newly created object.\n-   *  @throw  std::bad_alloc, or an exception thrown from the\n-   *          constructor of @a _Tp.\n-   */\n-  template<typename _Tp, typename... _Args>\n-    inline shared_ptr<_Tp>\n-    make_shared(_Args&&... __args)\n-    {\n-      typedef typename std::remove_const<_Tp>::type _Tp_nc;\n-      return allocate_shared<_Tp>(std::allocator<_Tp_nc>(),\n-              std::forward<_Args>(__args)...);\n-    }\n-#endif\n-\n-_GLIBCXX_END_NAMESPACE_TR1\n+}\n }", "previous_filename": "libstdc++-v3/include/tr1_impl/boost_shared_ptr.h"}, {"sha": "ae6f03ee6dc08926200f770e0ce3eef655c8cf1a", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/assign/auto_ptr_rvalue.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fauto_ptr_rvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fauto_ptr_rvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Fauto_ptr_rvalue.cc?ref=640cbe76c769ea9737e671d32e51b37693848ebf", "patch": "@@ -0,0 +1,62 @@\n+// { dg-options \"-std=gnu++0x -Wno-deprecated\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2008 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.7.12.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+std::auto_ptr<A> source() { return std::auto_ptr<A>(); }\n+\n+// 20.7.12.2.3 shared_ptr assignment [util.smartptr.shared.assign]\n+\n+// Assignment from rvalue auto_ptr\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a;\n+  a = source();\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a;\n+  std::auto_ptr<A> au;\n+  a = std::move(au);\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "a835a9acc3a4225edc5a6807d79c09b764a4c292", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/assign/unique_ptr_lvalue_neg.cc", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Funique_ptr_lvalue_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Funique_ptr_lvalue_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Funique_ptr_lvalue_neg.cc?ref=640cbe76c769ea9737e671d32e51b37693848ebf", "patch": "@@ -1,7 +1,7 @@\n // { dg-options \"-std=gnu++0x\" }\n // { dg-do compile }\n \n-// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+// Copyright (C) 2008 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -19,24 +19,24 @@\n // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n // USA.\n \n-// 20.6.6.2 Template class shared_ptr [util.smartptr.shared]\n+// 20.7.12.2 Template class shared_ptr [util.smartptr.shared]\n \n #include <memory>\n #include <testsuite_hooks.h>\n \n struct A { };\n-std::auto_ptr<A> source() { return std::auto_ptr<A>(); }\n \n-// 20.6.6.2.3 shared_ptr assignment [util.smartptr.shared.assign]\n+// 20.7.12.2.3 shared_ptr assignment [util.smartptr.shared.assign]\n \n-// Assignment from rvalue auto_ptr\n+// Assignment from lvalue unique_ptr\n int\n test01()\n {\n   bool test __attribute__((unused)) = true;\n \n   std::shared_ptr<A> a;\n-  a = source(); // { dg-error \"no match\" }\n+  std::unique_ptr<A> u;\n+  a = u; // { dg-error \"used here\" }\n \n   return 0;\n }\n@@ -47,4 +47,4 @@ main()\n   test01();\n   return 0;\n }\n-// { dg-excess-errors \"candidates are\" }\n+// { dg-excess-errors \"deleted function\" }", "previous_filename": "libstdc++-v3/testsuite/20_util/shared_ptr/assign/auto_ptr_rvalue_neg.cc"}, {"sha": "acfc1ce4411d7673c958cc04ff3e1cd7a50e137e", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/assign/unique_ptr_rvalue.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Funique_ptr_rvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Funique_ptr_rvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fassign%2Funique_ptr_rvalue.cc?ref=640cbe76c769ea9737e671d32e51b37693848ebf", "patch": "@@ -0,0 +1,62 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2008 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.7.12.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+std::unique_ptr<A> source() { return std::unique_ptr<A>(); }\n+\n+// 20.7.12.2.3 shared_ptr assignment [util.smartptr.shared.assign]\n+\n+// Assignment from rvalue unique_ptr\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a;\n+  a = source();\n+\n+  return 0;\n+}\n+\n+int\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a;\n+  std::unique_ptr<A> u;\n+  a = std::move(u);\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "99874b1fb2b04a6c3685e86490508db0aa8fad8b", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/unique_ptr.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr.cc?ref=640cbe76c769ea9737e671d32e51b37693848ebf", "patch": "@@ -0,0 +1,50 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.7.12.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 20.7.12.2.1 shared_ptr constructors [util.smartptr.shared.const]\n+\n+// Construction from unique_ptr\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::unique_ptr<A> up(new A);\n+  std::shared_ptr<A> sp(std::move(up));\n+  VERIFY( up.get() == 0 );\n+  VERIFY( sp.get() != 0 );\n+  VERIFY( sp.use_count() == 1 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "09c9e0909ebe0521a0c804b8e0df0c435515ffc9", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/unique_ptr_deleter.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr_deleter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr_deleter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr_deleter.cc?ref=640cbe76c769ea9737e671d32e51b37693848ebf", "patch": "@@ -0,0 +1,60 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.7.12.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+struct D {\n+    void operator()(A* p) const { delete p;  ++count; }\n+    static int count;\n+};\n+\n+int D::count = 0;\n+\n+// 20.7.12.2.1 shared_ptr constructors [util.smartptr.shared.const]\n+\n+// Construction from unique_ptr\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::unique_ptr<A, D> up(new A, D());\n+  {\n+      std::shared_ptr<A> sp(std::move(up));\n+      VERIFY( up.get() == 0 );\n+      VERIFY( sp.get() != 0 );\n+      VERIFY( sp.use_count() == 1 );\n+  }\n+  VERIFY( D::count == 1 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "58d7c400032819615e3291492286f630224b187d", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/unique_ptr_deleter_ref.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr_deleter_ref.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr_deleter_ref.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr_deleter_ref.cc?ref=640cbe76c769ea9737e671d32e51b37693848ebf", "patch": "@@ -0,0 +1,61 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.7.12.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+struct D {\n+    typedef void result_type;\n+    void operator()(A* p) { delete p;  ++count; }\n+    int count;\n+};\n+\n+\n+// 20.7.12.2.1 shared_ptr constructors [util.smartptr.shared.const]\n+\n+// Construction from unique_ptr\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  D d = D();\n+  std::unique_ptr<A, D&> up(new A, d);\n+  {\n+      std::shared_ptr<A> sp(std::move(up));\n+      VERIFY( up.get() == 0 );\n+      VERIFY( sp.get() != 0 );\n+      VERIFY( sp.use_count() == 1 );\n+  }\n+  VERIFY( d.count == 1 );\n+\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "8a5890c44197993b420f30baaf71c32e6a76903a", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/unique_ptr_neg.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr_neg.cc?ref=640cbe76c769ea9737e671d32e51b37693848ebf", "patch": "@@ -0,0 +1,49 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2008 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.7.12.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 20.7.12.2.1 shared_ptr constructors [util.smartptr.shared.const]\n+\n+// Construction from lvalue unique_ptr\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::unique_ptr<A> a;\n+  std::shared_ptr<A> p(a); // { dg-error \"used here\" }\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}\n+// { dg-excess-errors \"deleted function\" }"}, {"sha": "01ffefd9735d4d3d8cd00020330731d6f4de7c07", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/modifiers/swap_rvalue.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2Fswap_rvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/640cbe76c769ea9737e671d32e51b37693848ebf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2Fswap_rvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fmodifiers%2Fswap_rvalue.cc?ref=640cbe76c769ea9737e671d32e51b37693848ebf", "patch": "@@ -0,0 +1,48 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2008 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.7.12.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 20.7.12.2.4 shared_ptr modifiers [util.smartptr.shared.mod]\n+\n+// swap\n+int\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> p(new A);\n+  p.swap(std::shared_ptr<A>(new A));\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}]}