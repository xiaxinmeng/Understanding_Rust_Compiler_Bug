{"sha": "e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVhMmI2OWQzYzFhZTFlZGVmNWZiMTRiZTVkMjY0Y2JiZGJlYjBhMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-10-21T09:07:13Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-10-21T09:07:13Z"}, "message": "invoke.texi (-mpaired-single): Don't say that the option requires 64-bit code.\n\ngcc/\n\t* doc/invoke.texi (-mpaired-single): Don't say that the option\n\trequires 64-bit code.\n\t* config/mips/mips-protos.h (mips_modes_tieable_p): Declare.\n\t* config/mips/mips.h (ISA_HAS_PAIRED_SINGLE): New macro.\n\t(ISA_HAS_NMADD_NMSUB): Add a mode argument.  Return true for\n\tV2SF if ISA_MIPS32R2.\n\t(MODES_TIEABLE_P): Use mips_modes_tieable_p.\n\t* config/mips/mips.c (mips_rtx_costs): Pass a mode argument\n\tto ISA_HAS_NMADD_NMSUB.\n\t(mips_split_doubleword_move): Handle V2SF.\n\t(mips_modes_tieable_p): New function.\n\t(override_options): Report a warning rather than an error when\n\t-mpaired-single is used on ISAs that don't support it; use\n\tISA_HAS_PAIRED_SINGLE to check that case.\n\t* config/mips/mips.md (MOVE64): New mode iterator.  Replace DI\n\tand DF move splitters with a single MOVE64 splitter, thereby adding\n\ta V2SF splitter too.\n\t(SPLITF): Add TARGET_DOUBLE_FLOAT conditions to DI and DF.\n\tAdd a TARGET_FLOAT64 condition to TF.  Add V2SF to the iterator.\n\t(HALFMODE): Add V2SF.\n\t(*nmadd<mode>, *nmadd<mode>_fastmath, *nmsub<mode>)\n\t(*nmsub<mode>_fastmath): Add a mode argument to ISA_HAS_NMADD_NMSUB.\n\t(movv2sf_hardfloat_64bit): Tweak ordering of conditions.\n\t(movv2sf_hardfloat_32bit): New pattern.\n\t(load_low<mode>, load_high<mode>, store_word<mode>): Remove\n\tTARGET_DOUBLE_FLOAT conditions.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect.exp: Extend -mpaired-single handling to all\n\tMIPS targets.\n\t* g++.dg/vect/vect.exp: Likewise.\n\t* lib/fortran-torture.exp: Likewise.\n\t* gcc.target/mips/mips-ps-1.c: Use mpaired_single rather than\n\tmipsisa64*-*-* as the target selector.  Remove -mips64,\n\t-mhard-float and -mgp64 from the options list.\n\t* gcc.target/mips/mips-ps-2.c: Likewise.\n\t* gcc.target/mips/mips-ps-3.c: Likewise.\n\t* gcc.target/mips/mips-ps-4.c: Likewise.\n\t* gcc.target/mips/mips-ps-6.c: Likewise.\n\t* gcc.target/mips/mips-ps-5.c: Remove -mhard-float from the\n\toptions list.\n\t* gcc.target/mips/sb1-1.c: Likewise.\n\t* gcc.target/mips/mips-ps-type.c: Likewise.\n\t* gcc.target/mips/mips-ps-7.c: New test.\n\t* gcc.target/mips/mips-ps-type-2.c: Likewise.\n\t* gcc.target/mips/fpr-moves-6.c: Remove XFAIL.\n\t* gcc.target/mips/mips.exp (setup_mips_tests): Set mips_fp and\n\tmips_gp instead of mips_fp64 and mips_gp64.  Treat -mgp32 -mfp64\n\tas forcing an ABI and an architecture.\n\t(is_gp32_flag, is_gp64_flag): Fold into...\n\t(dg-mips-options): ...here.  Make -mpaired-single imply -mfp64,\n\tthen -mfp64 imply -mhard-float.  Apply register rules after the\n\tloop.  Handle -march=mipsN like -mipsN.\n\nFrom-SVN: r129522", "tree": {"sha": "5132c406376f0aa6ffe78d1e83a926e60d1c3b8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5132c406376f0aa6ffe78d1e83a926e60d1c3b8f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/comments", "author": null, "committer": null, "parents": [{"sha": "be1d7465396d551bfec8c7396babf8c82761f440", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be1d7465396d551bfec8c7396babf8c82761f440", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be1d7465396d551bfec8c7396babf8c82761f440"}], "stats": {"total": 482, "additions": 350, "deletions": 132}, "files": [{"sha": "3005f1133eae9de342bd0cfb1cf0895d3ced2eb5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -1,3 +1,32 @@\n+2007-10-21  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* doc/invoke.texi (-mpaired-single): Don't say that the option\n+\trequires 64-bit code.\n+\t* config/mips/mips-protos.h (mips_modes_tieable_p): Declare.\n+\t* config/mips/mips.h (ISA_HAS_PAIRED_SINGLE): New macro.\n+\t(ISA_HAS_NMADD_NMSUB): Add a mode argument.  Return true for\n+\tV2SF if ISA_MIPS32R2.\n+\t(MODES_TIEABLE_P): Use mips_modes_tieable_p.\n+\t* config/mips/mips.c (mips_rtx_costs): Pass a mode argument\n+\tto ISA_HAS_NMADD_NMSUB.\n+\t(mips_split_doubleword_move): Handle V2SF.\n+\t(mips_modes_tieable_p): New function.\n+\t(override_options): Report a warning rather than an error when\n+\t-mpaired-single is used on ISAs that don't support it; use\n+\tISA_HAS_PAIRED_SINGLE to check that case.\n+\t* config/mips/mips.md (MOVE64): New mode iterator.  Replace DI\n+\tand DF move splitters with a single MOVE64 splitter, thereby adding\n+\ta V2SF splitter too.\n+\t(SPLITF): Add TARGET_DOUBLE_FLOAT conditions to DI and DF.\n+\tAdd a TARGET_FLOAT64 condition to TF.  Add V2SF to the iterator.\n+\t(HALFMODE): Add V2SF.\n+\t(*nmadd<mode>, *nmadd<mode>_fastmath, *nmsub<mode>)\n+\t(*nmsub<mode>_fastmath): Add a mode argument to ISA_HAS_NMADD_NMSUB.\n+\t(movv2sf_hardfloat_64bit): Tweak ordering of conditions.\n+\t(movv2sf_hardfloat_32bit): New pattern.\n+\t(load_low<mode>, load_high<mode>, store_word<mode>): Remove\n+\tTARGET_DOUBLE_FLOAT conditions.\n+\n 2007-10-20  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/rs6000/linux-unwind.h (ppc_fallback_frame_state): Point"}, {"sha": "646cdcd544d5f7d3b24faf21bcf2e768172a5662", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -267,6 +267,7 @@ extern struct rtx_def *mips_function_value (const_tree, const_tree, enum machine\n extern bool mips_cannot_change_mode_class (enum machine_mode,\n \t\t\t\t\t   enum machine_mode, enum reg_class);\n extern bool mips_dangerous_for_la25_p (rtx);\n+extern bool mips_modes_tieable_p (enum machine_mode, enum machine_mode);\n extern enum reg_class mips_preferred_reload_class (rtx, enum reg_class);\n extern enum reg_class mips_secondary_reload_class (enum reg_class,\n \t\t\t\t\t\t   enum machine_mode,"}, {"sha": "419b6a498f423e62cdfba6bbb57f04d45b0db150", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -3212,7 +3212,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n \n     case MINUS:\n       if (float_mode_p\n-\t  && ISA_HAS_NMADD_NMSUB\n+\t  && ISA_HAS_NMADD_NMSUB (mode)\n \t  && TARGET_FUSED_MADD\n \t  && !HONOR_NANS (mode)\n \t  && !HONOR_SIGNED_ZEROS (mode))\n@@ -3261,7 +3261,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n \n     case NEG:\n       if (float_mode_p\n-\t  && ISA_HAS_NMADD_NMSUB\n+\t  && ISA_HAS_NMADD_NMSUB (mode)\n \t  && TARGET_FUSED_MADD\n \t  && !HONOR_NANS (mode)\n \t  && HONOR_SIGNED_ZEROS (mode))\n@@ -3459,6 +3459,8 @@ mips_split_doubleword_move (rtx dest, rtx src)\n \temit_insn (gen_move_doubleword_fprdi (dest, src));\n       else if (!TARGET_64BIT && GET_MODE (dest) == DFmode)\n \temit_insn (gen_move_doubleword_fprdf (dest, src));\n+      else if (!TARGET_64BIT && GET_MODE (dest) == V2SFmode)\n+\temit_insn (gen_move_doubleword_fprv2sf (dest, src));\n       else if (TARGET_64BIT && GET_MODE (dest) == TFmode)\n \temit_insn (gen_move_doubleword_fprtf (dest, src));\n       else\n@@ -8897,6 +8899,18 @@ mips_mode_ok_for_mov_fmt_p (enum machine_mode mode)\n     }\n }\n \n+/* Implement MODES_TIEABLE_P.  */\n+\n+bool\n+mips_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n+{\n+  /* FPRs allow no mode punning, so it's not worth tying modes if we'd\n+     prefer to put one of them in FPRs.  */\n+  return (mode1 == mode2\n+\t  || (!mips_mode_ok_for_mov_fmt_p (mode1)\n+\t      && !mips_mode_ok_for_mov_fmt_p (mode2)));\n+}\n+\n /* Implement PREFERRED_RELOAD_CLASS.  */\n \n enum reg_class\n@@ -12106,8 +12120,9 @@ override_options (void)\n \n   /* Make sure that the ISA supports TARGET_PAIRED_SINGLE_FLOAT when it is\n      enabled.  */\n-  if (TARGET_PAIRED_SINGLE_FLOAT && !ISA_MIPS64)\n-    error (\"-mips3d/-mpaired-single must be used with -mips64\");\n+  if (TARGET_PAIRED_SINGLE_FLOAT && !ISA_HAS_PAIRED_SINGLE)\n+    warning (0, \"the %qs architecture does not support paired-single\"\n+\t     \" instructions\", mips_arch_info->name);\n \n   /* If TARGET_DSPR2, enable MASK_DSP.  */\n   if (TARGET_DSPR2)"}, {"sha": "2b14f306d24cda1278908824928080640e2c2a7a", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -750,6 +750,9 @@ enum mips_code_readable_setting {\n \t\t\t\t  || ISA_MIPS64)\t\t\t\\\n \t\t\t\t && !TARGET_MIPS16)\n \n+/* ISA has paired-single instructions.  */\n+#define ISA_HAS_PAIRED_SINGLE\t(ISA_MIPS32R2 || ISA_MIPS64)\n+\n /* ISA has conditional trap instructions.  */\n #define ISA_HAS_COND_TRAP\t(!ISA_MIPS1\t\t\t\t\\\n \t\t\t\t && !TARGET_MIPS16)\n@@ -763,8 +766,10 @@ enum mips_code_readable_setting {\n /* Integer multiply-accumulate instructions should be generated.  */\n #define GENERATE_MADD_MSUB      (ISA_HAS_MADD_MSUB && !TUNE_74K)\n \n-/* ISA has floating-point nmadd and nmsub instructions.  */\n-#define ISA_HAS_NMADD_NMSUB\t((ISA_MIPS4\t\t\t\t\\\n+/* ISA has floating-point nmadd and nmsub instructions for mode MODE.  */\n+#define ISA_HAS_NMADD_NMSUB(MODE) \\\n+\t\t\t\t((ISA_MIPS4\t\t\t\t\\\n+\t\t\t\t  || (ISA_MIPS32R2 && (MODE) == V2SFmode) \\\n \t\t\t\t  || ISA_MIPS64)\t\t\t\\\n \t\t\t\t && (!TARGET_MIPS5400 || TARGET_MAD)\t\\\n \t\t\t\t && !TARGET_MIPS16)\n@@ -1562,15 +1567,7 @@ enum mips_code_readable_setting {\n #define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n   mips_hard_regno_mode_ok[ (int)(MODE) ][ (REGNO) ]\n \n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\t\\\n-  ((GET_MODE_CLASS (MODE1) == MODE_FLOAT ||\t\t\t\t\\\n-    GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\t\t\\\n-   == (GET_MODE_CLASS (MODE2) == MODE_FLOAT ||\t\t\t\t\\\n-       GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n+#define MODES_TIEABLE_P mips_modes_tieable_p\n \n /* Register to use for pushing function arguments.  */\n #define STACK_POINTER_REGNUM (GP_REG_FIRST + 29)"}, {"sha": "89edc2c0c667b6da4ee1f3a868590f18a6e3b982", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -492,6 +492,10 @@\n ;; conditional-move-type condition is needed.\n (define_mode_iterator MOVECC [SI (DI \"TARGET_64BIT\") (CC \"TARGET_HARD_FLOAT\")])\n \n+;; 64-bit modes for which we provide move patterns.\n+(define_mode_iterator MOVE64\n+  [DI DF (V2SF \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\")])\n+\n ;; This mode iterator allows the QI and HI extension patterns to be\n ;; defined from the same template.\n (define_mode_iterator SHORT [QI HI])\n@@ -510,9 +514,11 @@\n \t\t\t       (DF \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\")])\n \n ;; A floating-point mode for which moves involving FPRs may need to be split.\n-(define_mode_iterator SPLITF [(DF \"!TARGET_64BIT\")\n-\t\t\t      (DI \"!TARGET_64BIT\")\n-\t\t\t      (TF \"TARGET_64BIT\")])\n+(define_mode_iterator SPLITF\n+  [(DF \"!TARGET_64BIT && TARGET_DOUBLE_FLOAT\")\n+   (DI \"!TARGET_64BIT && TARGET_DOUBLE_FLOAT\")\n+   (V2SF \"!TARGET_64BIT && TARGET_PAIRED_SINGLE_FLOAT\")\n+   (TF \"TARGET_64BIT && TARGET_FLOAT64\")])\n \n ;; In GPR templates, a string like \"<d>subu\" will expand to \"subu\" in the\n ;; 32-bit version and \"dsubu\" in the 64-bit version.\n@@ -564,7 +570,7 @@\n \n ;; This attribute gives the integer mode that has half the size of\n ;; the controlling mode.\n-(define_mode_attr HALFMODE [(DF \"SI\") (DI \"SI\") (TF \"DI\")])\n+(define_mode_attr HALFMODE [(DF \"SI\") (DI \"SI\") (V2SF \"SI\") (TF \"DI\")])\n \n ;; This attribute works around the early SB-1 rev2 core \"F2\" erratum:\n ;;\n@@ -1861,7 +1867,8 @@\n \t\t   (mult:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\")\n \t\t\t      (match_operand:ANYF 2 \"register_operand\" \"f\"))\n \t\t   (match_operand:ANYF 3 \"register_operand\" \"f\"))))]\n-  \"ISA_HAS_NMADD_NMSUB && TARGET_FUSED_MADD\n+  \"ISA_HAS_NMADD_NMSUB (<MODE>mode)\n+   && TARGET_FUSED_MADD\n    && HONOR_SIGNED_ZEROS (<MODE>mode)\n    && !HONOR_NANS (<MODE>mode)\"\n   \"nmadd.<fmt>\\t%0,%3,%1,%2\"\n@@ -1874,7 +1881,8 @@\n \t (mult:ANYF (neg:ANYF (match_operand:ANYF 1 \"register_operand\" \"f\"))\n \t\t    (match_operand:ANYF 2 \"register_operand\" \"f\"))\n \t (match_operand:ANYF 3 \"register_operand\" \"f\")))]\n-  \"ISA_HAS_NMADD_NMSUB && TARGET_FUSED_MADD\n+  \"ISA_HAS_NMADD_NMSUB (<MODE>mode)\n+   && TARGET_FUSED_MADD\n    && !HONOR_SIGNED_ZEROS (<MODE>mode)\n    && !HONOR_NANS (<MODE>mode)\"\n   \"nmadd.<fmt>\\t%0,%3,%1,%2\"\n@@ -1887,7 +1895,8 @@\n \t\t   (mult:ANYF (match_operand:ANYF 2 \"register_operand\" \"f\")\n \t\t\t      (match_operand:ANYF 3 \"register_operand\" \"f\"))\n \t\t   (match_operand:ANYF 1 \"register_operand\" \"f\"))))]\n-  \"ISA_HAS_NMADD_NMSUB && TARGET_FUSED_MADD\n+  \"ISA_HAS_NMADD_NMSUB (<MODE>mode)\n+   && TARGET_FUSED_MADD\n    && HONOR_SIGNED_ZEROS (<MODE>mode)\n    && !HONOR_NANS (<MODE>mode)\"\n   \"nmsub.<fmt>\\t%0,%1,%2,%3\"\n@@ -1900,7 +1909,8 @@\n \t (match_operand:ANYF 1 \"register_operand\" \"f\")\n \t (mult:ANYF (match_operand:ANYF 2 \"register_operand\" \"f\")\n \t\t    (match_operand:ANYF 3 \"register_operand\" \"f\"))))]\n-  \"ISA_HAS_NMADD_NMSUB && TARGET_FUSED_MADD\n+  \"ISA_HAS_NMADD_NMSUB (<MODE>mode)\n+   && TARGET_FUSED_MADD\n    && !HONOR_SIGNED_ZEROS (<MODE>mode)\n    && !HONOR_NANS (<MODE>mode)\"\n   \"nmsub.<fmt>\\t%0,%1,%2,%3\"\n@@ -4046,19 +4056,8 @@\n    (set_attr \"length\" \"16\")])\n \n (define_split\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\")\n-\t(match_operand:DI 1 \"move_operand\"))]\n-  \"reload_completed && !TARGET_64BIT\n-   && mips_split_64bit_move_p (operands[0], operands[1])\"\n-  [(const_int 0)]\n-{\n-  mips_split_doubleword_move (operands[0], operands[1]);\n-  DONE;\n-})\n-\n-(define_split\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\")\n-\t(match_operand:DF 1 \"move_operand\"))]\n+  [(set (match_operand:MOVE64 0 \"nonimmediate_operand\")\n+\t(match_operand:MOVE64 1 \"move_operand\"))]\n   \"reload_completed && !TARGET_64BIT\n    && mips_split_64bit_move_p (operands[0], operands[1])\"\n   [(const_int 0)]\n@@ -4097,15 +4096,28 @@\n   [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"=f,f,f,m,m,*f,*d,*d,*d,*m\")\n \t(match_operand:V2SF 1 \"move_operand\" \"f,YG,m,f,YG,*d,*f,*d*YG,*m,*d\"))]\n   \"TARGET_HARD_FLOAT\n-   && TARGET_64BIT\n    && TARGET_PAIRED_SINGLE_FLOAT\n+   && TARGET_64BIT\n    && (register_operand (operands[0], V2SFmode)\n        || reg_or_0_operand (operands[1], V2SFmode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n   [(set_attr \"type\" \"fmove,mtc,fpload,fpstore,store,mtc,mfc,move,load,store\")\n    (set_attr \"mode\" \"SF\")\n    (set_attr \"length\" \"4,4,*,*,*,4,4,4,*,*\")])\n \n+(define_insn \"movv2sf_hardfloat_32bit\"\n+  [(set (match_operand:V2SF 0 \"nonimmediate_operand\" \"=f,f,f,m,m,*f,*d,*d,*d,*m\")\n+\t(match_operand:V2SF 1 \"move_operand\" \"f,YG,m,f,YG,*d,*f,*d*YG,*m,*d\"))]\n+  \"TARGET_HARD_FLOAT\n+   && TARGET_PAIRED_SINGLE_FLOAT\n+   && !TARGET_64BIT\n+   && (register_operand (operands[0], V2SFmode)\n+       || reg_or_0_operand (operands[1], V2SFmode))\"\n+  { return mips_output_move (operands[0], operands[1]); }\n+  [(set_attr \"type\" \"fmove,mtc,fpload,fpstore,store,mtc,mfc,move,load,store\")\n+   (set_attr \"mode\" \"SF\")\n+   (set_attr \"length\" \"4,8,*,*,*,8,8,8,*,*\")])\n+\n ;; The HI and LO registers are not truly independent.  If we move an mthi\n ;; instruction before an mflo instruction, it will make the result of the\n ;; mflo unpredictable.  The same goes for mtlo and mfhi.\n@@ -4185,7 +4197,7 @@\n   [(set (match_operand:SPLITF 0 \"register_operand\" \"=f,f\")\n \t(unspec:SPLITF [(match_operand:<HALFMODE> 1 \"general_operand\" \"dJ,m\")]\n \t\t       UNSPEC_LOAD_LOW))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n+  \"TARGET_HARD_FLOAT\"\n {\n   operands[0] = mips_subword (operands[0], 0);\n   return mips_output_move (operands[0], operands[1]);\n@@ -4200,7 +4212,7 @@\n \t(unspec:SPLITF [(match_operand:<HALFMODE> 1 \"general_operand\" \"dJ,m\")\n \t\t\t(match_operand:SPLITF 2 \"register_operand\" \"0,0\")]\n \t\t       UNSPEC_LOAD_HIGH))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n+  \"TARGET_HARD_FLOAT\"\n {\n   operands[0] = mips_subword (operands[0], 1);\n   return mips_output_move (operands[0], operands[1]);\n@@ -4215,7 +4227,7 @@\n \t(unspec:<HALFMODE> [(match_operand:SPLITF 1 \"register_operand\" \"f,f\")\n \t\t\t    (match_operand 2 \"const_int_operand\")]\n \t\t\t   UNSPEC_STORE_WORD))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n+  \"TARGET_HARD_FLOAT\"\n {\n   operands[1] = mips_subword (operands[1], INTVAL (operands[2]));\n   return mips_output_move (operands[0], operands[1]);"}, {"sha": "2d45abc79e07f4af8ee2a0053b69c34f18ea7a13", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -11879,9 +11879,8 @@ Use (do not use) the MIPS SmartMIPS ASE.\n @opindex mpaired-single\n @opindex mno-paired-single\n Use (do not use) paired-single floating-point instructions.\n-@xref{MIPS Paired-Single Support}.  This option can only be used\n-when generating 64-bit code and requires hardware floating-point\n-support to be enabled.\n+@xref{MIPS Paired-Single Support}.  This option requires\n+hardware floating-point support to be enabled.\n \n @item -mdmx\n @itemx -mno-mdmx"}, {"sha": "64375dc2a76a898339895dd5171167cb6cb05022", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -1,3 +1,31 @@\n+2007-10-21  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* gcc.dg/vect/vect.exp: Extend -mpaired-single handling to all\n+\tMIPS targets.\n+\t* g++.dg/vect/vect.exp: Likewise.\n+\t* lib/fortran-torture.exp: Likewise.\n+\t* gcc.target/mips/mips-ps-1.c: Use mpaired_single rather than\n+\tmipsisa64*-*-* as the target selector.  Remove -mips64,\n+\t-mhard-float and -mgp64 from the options list.\n+\t* gcc.target/mips/mips-ps-2.c: Likewise.\n+\t* gcc.target/mips/mips-ps-3.c: Likewise.\n+\t* gcc.target/mips/mips-ps-4.c: Likewise.\n+\t* gcc.target/mips/mips-ps-6.c: Likewise.\n+\t* gcc.target/mips/mips-ps-5.c: Remove -mhard-float from the\n+\toptions list.\n+\t* gcc.target/mips/sb1-1.c: Likewise.\n+\t* gcc.target/mips/mips-ps-type.c: Likewise.\n+\t* gcc.target/mips/mips-ps-7.c: New test.\n+\t* gcc.target/mips/mips-ps-type-2.c: Likewise.\n+\t* gcc.target/mips/fpr-moves-6.c: Remove XFAIL.\n+\t* gcc.target/mips/mips.exp (setup_mips_tests): Set mips_fp and\n+\tmips_gp instead of mips_fp64 and mips_gp64.  Treat -mgp32 -mfp64\n+\tas forcing an ABI and an architecture.\n+\t(is_gp32_flag, is_gp64_flag): Fold into...\n+\t(dg-mips-options): ...here.  Make -mpaired-single imply -mfp64,\n+\tthen -mfp64 imply -mhard-float.  Apply register rules after the\n+\tloop.  Handle -march=mipsN like -mipsN.\n+\n 2007-10-20  David Edelsohn  <edelsohn@gnu.org>\n \n \t* gcc.dg/vect/vect.exp: Use -mcpu=970 instead of 7400."}, {"sha": "191a773002f886b10c2421b45c5f90cba13570a9", "filename": "gcc/testsuite/g++.dg/vect/vect.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fvect.exp?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -66,7 +66,7 @@ if [istarget \"powerpc*-*-*\"] {\n } elseif { [istarget \"i?86-*-*\"] || [istarget \"x86_64-*-*\"] } {\n     lappend DEFAULT_VECTCFLAGS \"-msse2\"\n     set dg-do-what-default run\n-} elseif { [istarget \"mipsisa64*-*-*\"]\n+} elseif { [istarget \"mips*-*-*\"]\n \t   && [check_effective_target_mpaired_single]\n \t   && [check_effective_target_nomips16] } {\n     lappend DEFAULT_VECTCFLAGS \"-mpaired-single\""}, {"sha": "87a2a183ed945e8d20ea03e465ff741350b8cdbc", "filename": "gcc/testsuite/gcc.dg/vect/vect.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -57,7 +57,7 @@ if [istarget \"powerpc*-*-*\"] {\n } elseif { [istarget \"i?86-*-*\"] || [istarget \"x86_64-*-*\"] } {\n     lappend DEFAULT_VECTCFLAGS \"-msse2\"\n     set dg-do-what-default run\n-} elseif { [istarget \"mipsisa64*-*-*\"]\n+} elseif { [istarget \"mips*-*-*\"]\n \t   && [check_effective_target_mpaired_single]\n \t   && [check_effective_target_nomips16] } {\n     lappend DEFAULT_VECTCFLAGS \"-mpaired-single\""}, {"sha": "f1933feccc12f52b9ee88c160e9f361803c5faf4", "filename": "gcc/testsuite/gcc.target/mips/fpr-moves-6.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-6.c?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -29,6 +29,5 @@ bar (long double d, long double *x)\n /* { dg-final { scan-assembler \"\\tdmtc1\\t\\\\\\$0,\\\\\\$f21\\n\" } } */\n /* { dg-final { scan-assembler \"\\tsd\\t\\\\\\$8,16\\\\\\(\\\\\\$6\\\\\\)\\n\" } } */\n /* { dg-final { scan-assembler \"\\tsd\\t\\\\\\$9,24\\\\\\(\\\\\\$6\\\\\\)\\n\" } } */\n-/* We currently move this through a temporary.  */\n-/* { dg-final { scan-assembler \"\\tdmtc1\\t\\\\\\$10,\\\\\\$f0\\n\" { xfail mips*-*-* } } } */\n+/* { dg-final { scan-assembler \"\\tdmtc1\\t\\\\\\$10,\\\\\\$f0\\n\" } } */\n /* { dg-final { scan-assembler \"\\tdmtc1\\t\\\\\\$11,\\\\\\$f2\\n\" } } */"}, {"sha": "c47b57dc5c5936d847aba3f3629640509dd069ac", "filename": "gcc/testsuite/gcc.target/mips/mips-ps-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-1.c?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -1,5 +1,5 @@\n-/* { dg-do run { target mipsisa64*-*-* } } */\n-/* { dg-mips-options \"-mips64 -O2 -mpaired-single -mhard-float -mgp64\" } */\n+/* { dg-do run { target mpaired_single } } */\n+/* { dg-mips-options \"-O2 -mpaired-single\" } */\n \n /* Test v2sf calculations */\n #include <stdlib.h>"}, {"sha": "d7b33b1afc81eb4eee5379e9f2f6dd2d2298602a", "filename": "gcc/testsuite/gcc.target/mips/mips-ps-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-2.c?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -1,5 +1,5 @@\n-/* { dg-do run { target mipsisa64*-*-* } } */\n-/* { dg-mips-options \"-mips64 -O2 -mpaired-single -mhard-float -mgp64\" } */\n+/* { dg-do run { target mpaired_single } } */\n+/* { dg-mips-options \"-O2 -mpaired-single\" } */\n \n /* Test MIPS paired-single builtin functions */\n #include <stdlib.h>"}, {"sha": "a7c9545df3f97afde5659f99a22f778a2f3c5e09", "filename": "gcc/testsuite/gcc.target/mips/mips-ps-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-3.c?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -1,5 +1,5 @@\n-/* { dg-do run { target mipsisa64*-*-* } } */\n-/* { dg-mips-options \"-mips64 -O2 -mpaired-single -mhard-float -mgp64\" } */\n+/* { dg-do run { target mpaired_single } } */\n+/* { dg-mips-options \"-O2 -mpaired-single\" } */\n \n /* Test MIPS paired-single conditional move */\n #include <stdlib.h>"}, {"sha": "54efb80e464e42e63319229259534bb124bdcd29", "filename": "gcc/testsuite/gcc.target/mips/mips-ps-4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-4.c?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -1,5 +1,5 @@\n-/* { dg-do run { target mipsisa64*-*-* } } */\n-/* { dg-mips-options \"-mips64 -O2 -mpaired-single -mhard-float -mgp64\" } */\n+/* { dg-do run { target mpaired_single } } */\n+/* { dg-mips-options \"-O2 -mpaired-single\" } */\n \n /* Test MIPS paired-single comparisons */\n #include <stdlib.h>"}, {"sha": "9b748887adeb55d9d6c27710793e779e0a238bff", "filename": "gcc/testsuite/gcc.target/mips/mips-ps-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-5.c?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-mips-options \"-mips64 -O2 -mpaired-single -mhard-float -mgp64 -ftree-vectorize\" } */\n+/* { dg-mips-options \"-mips64 -O2 -mpaired-single -mgp64 -ftree-vectorize\" } */\n \n extern float a[], b[], c[];\n "}, {"sha": "fc198dc3d0982f5267c5b3bf4fc39a3696e94edc", "filename": "gcc/testsuite/gcc.target/mips/mips-ps-6.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-6.c?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -1,7 +1,7 @@\n /* mips-ps-2.c with an extra -ffinite-math-only option.  This option\n    changes the way that abs.ps is handled.  */\n-/* { dg-do run { target mipsisa64*-*-* } } */\n-/* { dg-mips-options \"-mips64 -O2 -mpaired-single -mhard-float -mgp64 -ffinite-math-only\" } */\n+/* { dg-do run { target mpaired_single } } */\n+/* { dg-mips-options \"-O2 -mpaired-single -ffinite-math-only\" } */\n \n /* Test MIPS paired-single builtin functions */\n #include <stdlib.h>"}, {"sha": "cfec230ceb120af353c32b55c32e54ae5a647e5d", "filename": "gcc/testsuite/gcc.target/mips/mips-ps-7.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-7.c?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -0,0 +1,17 @@\n+/* mips-ps-5.c with -mips32r2 instead of -mips64.  */\n+/* { dg-do compile } */\n+/* { dg-mips-options \"-mips32r2 -O2 -mpaired-single -ftree-vectorize\" } */\n+\n+extern float a[], b[], c[];\n+\n+NOMIPS16 void\n+foo (void)\n+{\n+  int i;\n+  for (i = 0; i < 16; i++)\n+    a[i] = b[i] == c[i] + 1 ? b[i] : c[i];\n+}\n+\n+/* { dg-final { scan-assembler \"add\\\\.ps\" } } */\n+/* { dg-final { scan-assembler \"c\\\\.eq\\\\.ps\" } } */\n+/* { dg-final { scan-assembler \"mov\\[tf\\]\\\\.ps\" } } */"}, {"sha": "07ce7741b0643dcf985a9b4b53fa8129fcd196ad", "filename": "gcc/testsuite/gcc.target/mips/mips-ps-type-2.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-type-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-type-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-type-2.c?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -0,0 +1,111 @@\n+/* Test v2sf calculations.  The nmadd and nmsub patterns need\n+   -ffinite-math-only.  */\n+/* { dg-do compile } */\n+/* { dg-mips-options \"-mips32r2 -O2 -mpaired-single -ffinite-math-only\" } */\n+/* { dg-final { scan-assembler \"cvt.ps.s\" } } */\n+/* { dg-final { scan-assembler \"mov.ps\" } } */\n+/* { dg-final { scan-assembler \"ldc1\" } } */\n+/* { dg-final { scan-assembler \"sdc1\" } } */\n+/* { dg-final { scan-assembler \"add.ps\" } } */\n+/* { dg-final { scan-assembler \"sub.ps\" } } */\n+/* { dg-final { scan-assembler \"neg.ps\" } } */\n+/* { dg-final { scan-assembler \"mul.ps\" } } */\n+/* { dg-final { scan-assembler \"madd.ps\" } } */\n+/* { dg-final { scan-assembler \"msub.ps\" } } */\n+/* { dg-final { scan-assembler \"nmadd.ps\" } } */\n+/* { dg-final { scan-assembler \"nmsub.ps\" } } */\n+/* { dg-final { scan-assembler \"movn.ps\" } } */\n+/* { dg-final { scan-assembler \"movz.ps\" } } */\n+\n+typedef float v2sf __attribute__ ((vector_size(8)));\n+void gobble (v2sf);\n+\n+v2sf A = {100, 200};\n+\n+/* Init from  floats */\n+NOMIPS16 v2sf init (float a, float b)\n+{\n+  return (v2sf) {a, b};\n+}\n+\n+/* Move between registers */\n+NOMIPS16 v2sf move (v2sf a)\n+{\n+  return a;\n+}\n+\n+/* Load from memory */\n+NOMIPS16 v2sf load ()\n+{\n+  return A;\n+}\n+\n+/* Store to memory */\n+NOMIPS16 void store (v2sf a)\n+{\n+  A = a;\n+}\n+\n+/* Add */\n+NOMIPS16 v2sf add (v2sf a, v2sf b)\n+{\n+  return a + b;\n+}\n+\n+/* Subtract */\n+NOMIPS16 v2sf sub (v2sf a, v2sf b)\n+{\n+  return a - b;\n+}\n+\n+/* Negate */\n+NOMIPS16 v2sf neg (v2sf a)\n+{\n+  return - a;\n+}\n+\n+/* Multiply */\n+NOMIPS16 v2sf mul (v2sf a, v2sf b)\n+{\n+  return a * b;\n+}\n+\n+/* Multiply and add */\n+NOMIPS16 v2sf madd (v2sf a, v2sf b, v2sf c)\n+{\n+  return a * b + c;\n+}\n+\n+/* Multiply and subtract */\n+NOMIPS16 v2sf msub (v2sf a, v2sf b, v2sf c)\n+{\n+  return a * b - c;\n+}\n+\n+/* Negate Multiply and add */\n+NOMIPS16 v2sf nmadd (v2sf a, v2sf b, v2sf c)\n+{\n+  return - (a * b + c);\n+}\n+\n+/* Negate Multiply and subtract */\n+NOMIPS16 v2sf nmsub (v2sf a, v2sf b, v2sf c)\n+{\n+  return - (a * b - c);\n+}\n+\n+/* Conditional Move */\n+NOMIPS16 v2sf cond_move1 (v2sf a, v2sf b, int i)\n+{\n+  if (i == 0)\n+    a = b;\n+  gobble (a);\n+}\n+\n+/* Conditional Move */\n+NOMIPS16 v2sf cond_move2 (v2sf a, v2sf b, int i)\n+{\n+  if (i != 0)\n+    a = b;\n+  gobble (a);\n+}"}, {"sha": "df1cec707aa5f060e16d6039ec201bf28c6aba20", "filename": "gcc/testsuite/gcc.target/mips/mips-ps-type.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-type.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-type.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips-ps-type.c?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -1,7 +1,7 @@\n /* Test v2sf calculations.  The nmadd and nmsub patterns need\n    -ffinite-math-only.  */\n /* { dg-do compile } */ \n-/* { dg-mips-options \"-mips64 -O2 -mpaired-single -mhard-float -mgp64 -ffinite-math-only\" } */\n+/* { dg-mips-options \"-mips64 -O2 -mpaired-single -mgp64 -ffinite-math-only\" } */\n /* { dg-final { scan-assembler \"cvt.ps.s\" } } */ \n /* { dg-final { scan-assembler \"mov.ps\" } } */ \n /* { dg-final { scan-assembler \"ldc1\" } } */ "}, {"sha": "7fcf8277da67d3b39a5afb1f9c85e91895fb6114", "filename": "gcc/testsuite/gcc.target/mips/mips.exp", "status": "modified", "additions": 81, "deletions": 71, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -31,8 +31,8 @@ load_lib gcc-dg.exp\n #    $mips_isa:\t\t the ISA level specified by __mips\n #    $mips_isa_rev:\t the ISA revision specified by __mips_isa_rev\n #    $mips_arch:\t the architecture specified by _MIPS_ARCH\n-#    $mips_gp64:\t true if 64-bit output is selected\n-#    $mips_fp64:\t true if 64-bit FPRs are selected\n+#    $mips_gp:\t\t the number of bytes in a general register\n+#    $mips_fp:\t\t the number of bytes in a floating-point register\n #    $mips_float:\t \"hard\" or \"soft\"\n #    $mips_abi:\t\t the ABI specified by _MIPS_SIM\n #\n@@ -48,8 +48,8 @@ proc setup_mips_tests {} {\n     global mips_isa\n     global mips_isa_rev\n     global mips_arch\n-    global mips_gp64\n-    global mips_fp64\n+    global mips_gp\n+    global mips_fp\n     global mips_float\n     global mips_abi\n \n@@ -76,11 +76,11 @@ proc setup_mips_tests {} {\n \t#endif\n \tconst char *arch = _MIPS_ARCH;\n \t#ifdef __mips64\n-\tint gp64 = 1;\n-\t#endif\n-\t#if __mips_fpr==64\n-\tint fp64 = 1;\n+\tint gp = 64;\n+\t#else\n+\tint gp = 32;\n \t#endif\n+\tint fp = __mips_fpr;\n \t#ifdef __mips_hard_float\n \tconst char *float = \"hard\";\n \t#else\n@@ -105,8 +105,8 @@ proc setup_mips_tests {} {\n     regexp {isa = ([^;]*)} $output dummy mips_isa\n     regexp {isa_rev = ([^;]*)} $output dummy mips_isa_rev\n     regexp {arch = \"([^\"]*)} $output dummy mips_arch\n-    set mips_gp64 [regexp {gp64 = 1} $output]\n-    set mips_fp64 [regexp {fp64 = 1} $output]\n+    regexp {gp = ([^;]*)} $output dummy mips_gp\n+    regexp {fp = ([^;]*)} $output dummy mips_fp\n     regexp {float = \"([^\"]*)} $output dummy mips_float\n     regexp {abi = \"([^\"]*)} $output dummy mips_abi\n \n@@ -118,29 +118,10 @@ proc setup_mips_tests {} {\n     set mips_forced_le [regexp -- {-(EL|mel)[[:>:]]} $compiler_flags]\n     set mips_forced_gp [regexp -- {-(G|m(|no-)((extern|local)-sdata|gpopt)|mabicalls|mrtp)} $compiler_flags]\n     set mips_forced_no_er [regexp -- {-mno-explicit-relocs} $compiler_flags]\n-}\n \n-# Return true if command-line option FLAG forces 32-bit code.\n-proc is_gp32_flag {flag} {\n-    switch -glob -- $flag {\n-\t-msmartmips -\n-\t-mips[12] -\n-\t-mips32* -\n-\t-march=mips32* -\n-\t-mabi=32 -\n-\t-mgp32 { return 1 }\n-\tdefault { return 0 }\n-    }\n-}\n-\n-# Return true if command-line option FLAG forces 64-bit code.\n-proc is_gp64_flag {flag} {\n-    switch -glob -- $flag {\n-\t-mabi=64 -\n-\t-mabi=o64 -\n-\t-mabi=n32 -\n-\t-mgp64 { return 1 }\n-\tdefault { return 0 }\n+    if {$mips_forced_regs && $mips_gp == 32 && $mips_fp == 64} {\n+\tset mips_forced_abi 1\n+\tset mips_forced_isa 1\n     }\n }\n \n@@ -157,10 +138,10 @@ proc is_gp64_flag {flag} {\n #\tflags force a 32-bit ABI or a 32-bit architecture.\n #\n #    -mfp64\n-#\tForce the use of 64-bit floating-point registers on a 32-bit target.\n-#\tAlso force -mhard-float and an architecture that supports such a\n-#\tcombination, unless these things are already specified by other\n-#\tparts of the given flags.\n+#\tForce the use of 64-bit floating-point registers, even on a\n+#\t32-bit target.  Also force -mhard-float and an architecture that\n+#\tsupports such a combination, unless these things are already\n+#\tspecified by other parts of the given flags.\n #\n #    -mabi=*\n #\tForce a particular ABI.  Skip the test if the multilib flags\n@@ -192,15 +173,18 @@ proc is_gp64_flag {flag} {\n #    -mexplicit-relocs\n #\tSelect explicit relocations.  Skip the test if the multilib flags\n #\tforce -mno-explicit-relocs.\n+#\n+#    -mpaired-single\n+#\tSelect paired-single instructions.  Also behave as for -mfp64.\n proc dg-mips-options {args} {\n     upvar dg-extra-tool-flags extra_tool_flags\n     upvar dg-do-what do_what\n \n     global mips_isa\n     global mips_isa_rev\n     global mips_arch\n-    global mips_gp64\n-    global mips_fp64\n+    global mips_gp\n+    global mips_fp\n     global mips_float\n     global mips_abi\n \n@@ -216,61 +200,87 @@ proc dg-mips-options {args} {\n     set flags [lindex $args 1]\n     set matches 1\n \n-    # First handle the -mgp* options.  Add an architecture option if necessary.\n+    # Add implied flags.\n     foreach flag $flags {\n-\tif {$flag == \"-mfp64\"} {\n-\t    if {!$mips_fp64 && $mips_forced_regs} {\n-\t\tset matches 0\n-\t    } else {\n-\t\tif {[lsearch -regexp $flags {^-m(hard|soft)-float$}] < 0} {\n-\t\t    append flags \" -mhard-float\"\n-\t\t}\n-\t\tif {[lsearch -regexp $flags {^(-mips|-march)}] < 0} {\n-\t\t    append flags \" -mips32r2\"\n-\t\t}\n-\t    }\n+\tif {[string match -mpaired-single $flag]\n+\t    && [lsearch $flags -mfp*] < 0} {\n+\t    append flags \" -mfp64\"\n \t}\n     }\n     foreach flag $flags {\n-\tif {[is_gp32_flag $flag]\n-\t    && ($mips_gp64\n-\t\t|| ($mips_fp64 && [lsearch $flags -mfp64] < 0)) } {\n-\t    if {$mips_forced_regs || $mips_forced_abi} {\n-\t\tset matches 0\n-\t    } elseif {[lsearch $flags \"-mabi=*\"] < 0} {\n-\t\tappend flags \" -mabi=32\"\n+\tif {[string match -mfp* $flag]\n+\t    && [lsearch -regexp $flags {^-m(hard|soft)-float$}] < 0} {\n+\t    append flags \" -mhard-float\"\n+\t}\n+    }\n+\n+    # Handle options that force a particular register size.  Add\n+    # architecture and ABI options if necessary.\n+    set mips_new_gp $mips_gp\n+    set mips_new_fp $mips_fp\n+    foreach flag $flags {\n+\tswitch -glob -- $flag {\n+\t    -msmartmips -\n+\t    -mips[12] -\n+\t    -mips32* -\n+\t    -march=mips32* -\n+\t    -mabi=32 -\n+\t    -mgp32 {\n+\t\tset mips_new_gp 32\n \t    }\n-\t} elseif {[is_gp64_flag $flag] && !$mips_gp64} {\n-\t    if {$mips_forced_regs || $mips_forced_abi} {\n-\t\tset matches 0\n+\t    -mabi=64 -\n+\t    -mabi=o64 -\n+\t    -mabi=n32 -\n+\t    -mgp64 {\n+\t\tset mips_new_gp 64\n+\t    }\n+\t    -mfp64 {\n+\t\tset mips_new_fp 64\n+\t    }\n+\t}\n+    }\n+\n+    if {$mips_new_gp != $mips_gp || $mips_new_fp != $mips_fp} {\n+\tif {$mips_forced_regs} {\n+\t    set matches 0\n+\t}\n+\t# Select an appropriate ABI.\n+\tif {[lsearch $flags \"-mabi=*\"] < 0} {\n+\t    if {$mips_new_gp == 32} {\n+\t\tappend flags \" -mabi=32\"\n \t    } else {\n-\t    \tif {[lsearch $flags \"-mabi=*\"] < 0} {\n-\t\t    append flags \" -mabi=o64\"\n-\t\t}\n-\t\tif {[lsearch -regexp $flags {^(-mips|-march)}] < 0} {\n-\t\t    append flags \" -mips3\"\n-\t\t}\n+\t\tappend flags \" -mabi=o64\"\n+\t    }\n+\t}\n+\t# And an appropriate architecture.\n+\tif {[lsearch -regexp $flags {^(-mips|-march)}] < 0} {\n+\t    if {$mips_new_gp == 64 && $mips_gp == 32} {\n+\t\tappend flags \" -mips3\"\n+\t    } elseif {$mips_new_gp == 32 && $mips_new_fp == 64} {\n+\t\tappend flags \" -mips32r2\"\n \t    }\n \t}\n     }\n+\n     # Handle the other options.\n     foreach flag $flags {\n \tif {[regexp -- {^-mabi=(.*)} $flag dummy abi]} {\n \t    if {$abi != $mips_abi && $mips_forced_abi} {\n \t\tset matches 0\n \t    }\n-\t} elseif {[regexp -- {^-march=(.*)} $flag dummy arch]} {\n-\t    if {$arch != $mips_arch && $mips_forced_isa} {\n-\t\tset matches 0\n-\t    }\n-\t} elseif {[regexp -- {^-mips(.*)} $flag dummy isa]} {\n+\t} elseif {[regexp -- {^-mips(.*)} $flag dummy isa]\n+\t\t  || [regexp -- {^-march=mips(.*)} $flag dummy isa]} {\n \t    if {![regexp {(.*)r(.*)} $isa dummy isa isa_rev]} {\n \t\tset isa_rev 1\n \t    }\n \t    if {($isa != $mips_isa || $isa_rev != $mips_isa_rev)\n \t\t&& $mips_forced_isa} {\n \t\tset matches 0\n \t    }\n+\t} elseif {[regexp -- {^-march=(.*)} $flag dummy arch]} {\n+\t    if {$arch != $mips_arch && $mips_forced_isa} {\n+\t\tset matches 0\n+\t    }\n \t} elseif {[regexp -- {^-m(hard|soft)-float} $flag dummy float]} {\n \t    if {$mips_float != $float && $mips_forced_float} {\n \t\tset matches 0"}, {"sha": "6bf8ea7abf8ebae976b87e73dac7b8aa02cf867d", "filename": "gcc/testsuite/gcc.target/mips/sb1-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsb1-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsb1-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsb1-1.c?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -1,6 +1,6 @@\n /* Test SB-1 v2sf extensions.  */\n /* { dg-do compile } */ \n-/* { dg-mips-options \"-march=sb1 -O2 -mpaired-single -mhard-float -mgp64 -ffast-math\" } */ \n+/* { dg-mips-options \"-march=sb1 -O2 -mpaired-single -mgp64 -ffast-math\" } */\n /* { dg-final { scan-assembler \"div.ps\" } } */ \n /* { dg-final { scan-assembler \"recip.ps\" } } */ \n /* { dg-final { scan-assembler \"sqrt.ps\" } } */ "}, {"sha": "f169c6cc729aaf2c777e23bad32eeb571df589e9", "filename": "gcc/testsuite/lib/fortran-torture.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Flib%2Ffortran-torture.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2/gcc%2Ftestsuite%2Flib%2Ffortran-torture.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ffortran-torture.exp?ref=e5a2b69d3c1ae1edef5fb14be5d264cbbdbeb0a2", "patch": "@@ -41,7 +41,7 @@ if ![info exists TORTURE_OPTIONS] {\n     } elseif { [istarget \"i?86-*-*\"] || [istarget \"x86_64-*-*\"] } {\n \tlappend vectorizer_options \"-msse2\"\n \tset test_tree_vectorize 1\n-    } elseif { [istarget \"mipsisa64*-*-*\"]\n+    } elseif { [istarget \"mips*-*-*\"]\n \t       && [check_effective_target_mpaired_single]\n \t       && [check_effective_target_nomips16] } {\n \tlappend vectorizer_options \"-mpaired-single\""}]}