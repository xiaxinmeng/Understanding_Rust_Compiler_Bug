{"sha": "128a79fb0142757127a8ded0635ce6f4f94ecbba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI4YTc5ZmIwMTQyNzU3MTI3YThkZWQwNjM1Y2U2ZjRmOTRlY2JiYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-05-19T03:05:49Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-05-19T03:05:49Z"}, "message": "cfgexpand.c, [...]: Fix comment typos.\n\ngcc/\n\t* cfgexpand.c, tree-cfg.c, tree-inline.c, tree-optimize.c,\n\ttree-ssa-forwprop.c: Fix comment typos.\n\t* doc/invoke.texi: Fix a typo.\n\ncp/\n\t* parser.c: Fix comment typos.\n\nFrom-SVN: r99944", "tree": {"sha": "2515da9a6676ddb153df106225173fc9b07d620d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2515da9a6676ddb153df106225173fc9b07d620d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/128a79fb0142757127a8ded0635ce6f4f94ecbba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/128a79fb0142757127a8ded0635ce6f4f94ecbba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/128a79fb0142757127a8ded0635ce6f4f94ecbba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/128a79fb0142757127a8ded0635ce6f4f94ecbba/comments", "author": null, "committer": null, "parents": [{"sha": "f75aac9e435b093bed7dbacf192453c2147e1503", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f75aac9e435b093bed7dbacf192453c2147e1503", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f75aac9e435b093bed7dbacf192453c2147e1503"}], "stats": {"total": 46, "additions": 28, "deletions": 18}, "files": [{"sha": "d4484759508258612896e563ce33e3f1b9fc9070", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/128a79fb0142757127a8ded0635ce6f4f94ecbba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/128a79fb0142757127a8ded0635ce6f4f94ecbba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=128a79fb0142757127a8ded0635ce6f4f94ecbba", "patch": "@@ -1,3 +1,9 @@\n+2005-05-19  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* cfgexpand.c, tree-cfg.c, tree-inline.c, tree-optimize.c,\n+\ttree-ssa-forwprop.c: Fix comment typos.\n+\t* doc/invoke.texi: Fix a typo.\n+\n 2005-05-18  Richard Henderson  <rth@redhat.com>\n \n \t* config.gcc (powerpc-*-linux*): Include linux64.opt when"}, {"sha": "cd9829e60deb95f13460ef43fd2a170ae75a707f", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/128a79fb0142757127a8ded0635ce6f4f94ecbba/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/128a79fb0142757127a8ded0635ce6f4f94ecbba/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=128a79fb0142757127a8ded0635ce6f4f94ecbba", "patch": "@@ -597,7 +597,7 @@ expand_one_register_var (tree var)\n }\n \n /* A subroutine of expand_one_var.  Called to assign rtl to a VAR_DECL that\n-   has some associated error, e.g. it's type is error-mark.  We just need\n+   has some associated error, e.g. its type is error-mark.  We just need\n    to pick something that won't crash the rest of the compiler.  */\n \n static void"}, {"sha": "1cc6dc08c4d3d581d6e7a9eee001c03db85325a6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/128a79fb0142757127a8ded0635ce6f4f94ecbba/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/128a79fb0142757127a8ded0635ce6f4f94ecbba/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=128a79fb0142757127a8ded0635ce6f4f94ecbba", "patch": "@@ -1,3 +1,7 @@\n+2005-05-19  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* parser.c: Fix comment typos.\n+\n 2005-05-18  Geoffrey Keating  <geoffk@apple.com>\n \n \t* Make-lang.in (cc1plus-dummy): New."}, {"sha": "b0dee735c4867986bd20cfb2310c6ca0fba20cc0", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/128a79fb0142757127a8ded0635ce6f4f94ecbba/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/128a79fb0142757127a8ded0635ce6f4f94ecbba/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=128a79fb0142757127a8ded0635ce6f4f94ecbba", "patch": "@@ -9687,7 +9687,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t  tree qual_type = objc_get_protocol_qualified_type (type, protos);\n \n \t  /* Clobber the \"unqualified\" type previously entered into\n-\t     DECL_SPECS with the new, improved protocol-qualifed version.  */\n+\t     DECL_SPECS with the new, improved protocol-qualified version.  */\n \t  if (decl_specs)\n \t    decl_specs->type = qual_type;\n \n@@ -17015,7 +17015,7 @@ cp_parser_objc_protocol_declaration (cp_parser* parser)\n       goto finish;\n     }\n \n-  /* See if we have a foward declaration or a definition.  */\n+  /* See if we have a forward declaration or a definition.  */\n   tok = cp_lexer_peek_nth_token (parser->lexer, 2);\n   \n   /* Try a forward declaration first.  */"}, {"sha": "1a96988ced2040d531f69e040b1d6660ff6c8dab", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/128a79fb0142757127a8ded0635ce6f4f94ecbba/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/128a79fb0142757127a8ded0635ce6f4f94ecbba/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=128a79fb0142757127a8ded0635ce6f4f94ecbba", "patch": "@@ -1937,7 +1937,7 @@ support for invoking the @code{- (id) .cxx_construct} and\n @item -fobjc-direct-dispatch\n @opindex fobjc-direct-dispatch\n Allow fast jumps to the message dispatcher.  On Darwin this is\n-accompilished via the comm page.\n+accomplished via the comm page.\n \n @item -fobjc-exceptions\n @opindex fobjc-exceptions"}, {"sha": "9eeb78392873a64dfafde04f6ab7e6db0b58bbf4", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/128a79fb0142757127a8ded0635ce6f4f94ecbba/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/128a79fb0142757127a8ded0635ce6f4f94ecbba/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=128a79fb0142757127a8ded0635ce6f4f94ecbba", "patch": "@@ -1359,7 +1359,7 @@ replace_uses_by (tree name, tree val)\n      x = w * w;\n \n      If we performed the update in the first loop, the statement\n-     would be rescanned after first occurence of w is replaced,\n+     would be rescanned after first occurrence of w is replaced,\n      the new uses would be placed to the beginning of the list,\n      and we would never process them.  */\n   for (i = 0; VEC_iterate (tree, stmts, i, stmt); i++)\n@@ -1398,7 +1398,7 @@ tree_merge_blocks (basic_block a, basic_block b)\n \t{\n \t  gcc_assert (is_gimple_reg (def));\n \n-\t  /* Note that just emiting the copies is fine -- there is no problem\n+\t  /* Note that just emitting the copies is fine -- there is no problem\n \t     with ordering of phi nodes.  This is because A is the single\n \t     predecessor of B, therefore results of the phi nodes cannot\n \t     appear as arguments of the phi nodes.  */"}, {"sha": "d9654f4d52c4481f5c6b7e382758f37afc537b95", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/128a79fb0142757127a8ded0635ce6f4f94ecbba/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/128a79fb0142757127a8ded0635ce6f4f94ecbba/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=128a79fb0142757127a8ded0635ce6f4f94ecbba", "patch": "@@ -513,7 +513,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n       if (assignment && TREE_CODE (assignment) == MODIFY_EXPR)\n \t{\n \t  /* Replace the RETURN_EXPR with (a copy of) the\n-\t     MODIFY_EXPR hangning underneath.  */\n+\t     MODIFY_EXPR hanging underneath.  */\n \t  *tp = copy_node (assignment);\n \t}\n       else /* Else the RETURN_EXPR returns no value.  */\n@@ -626,7 +626,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t  && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (*tp))))\n \tTREE_BLOCK (*tp) = id->block;\n \n-      /* We're duplicationg a CALL_EXPR.  Find any corresponding\n+      /* We're duplicating a CALL_EXPR.  Find any corresponding\n \t callgraph edges and update or duplicate them.  */\n       if (TREE_CODE (*tp) == CALL_EXPR && id->node && get_callee_fndecl (*tp))\n \t{\n@@ -750,9 +750,9 @@ copy_bb (inline_data *id, basic_block bb, int frequency_scale, int count_scale)\n   return copy_basic_block;\n }\n \n-/* Copy edges from BB into it's copy constructed ealier, scale profile\n-   accordingly.  Edges will be taken care of\n-   later.  Assume aux pointers to point to the copies of each BB  */\n+/* Copy edges from BB into its copy constructed earlier, scale profile\n+   accordingly.  Edges will be taken care of later.  Assume aux\n+   pointers to point to the copies of each BB.  */\n static void\n copy_edges_for_bb (basic_block bb, int count_scale)\n {\n@@ -770,7 +770,7 @@ copy_edges_for_bb (basic_block bb, int count_scale)\n \n       flags = old_edge->flags;\n \n-      /* Return edges do get a FALLTHU flag when the get inlined.  */\n+      /* Return edges do get a FALLTHRU flag when the get inlined.  */\n       if (old_edge->dest->index == EXIT_BLOCK && !old_edge->flags\n \t  && old_edge->dest->aux != EXIT_BLOCK_PTR)\n \tflags |= EDGE_FALLTHRU;\n@@ -885,7 +885,7 @@ copy_cfg_body (inline_data * id, gcov_type count, int frequency,\n   id->callee_cfun = cfun_to_copy;\n \n   /* If saving or cloning a function body, create new basic_block_info\n-     and label_to_block_maps.  Otherwise, we're duplicaing a function\n+     and label_to_block_maps.  Otherwise, we're duplicating a function\n      body for inlining; insert our new blocks and labels into the\n      existing varrays.  */\n   saving_or_cloning = (id->saving_p || id->cloning_p);\n@@ -1084,7 +1084,7 @@ setup_one_parameter (inline_data *id, tree p, tree value, tree fn,\n       /* If we did not create a gimple value and we did not create a gimple\n \t cast of a gimple value, then we will need to gimplify INIT_STMTS\n \t at the end.  Note that is_gimple_cast only checks the outer\n-\t tree code, not its operand.  Thus the explicit check that it's\n+\t tree code, not its operand.  Thus the explicit check that its\n \t operand is a gimple value.  */\n       if (!is_gimple_val (rhs)\n \t  && (!is_gimple_cast (rhs)\n@@ -1591,7 +1591,7 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n \n     /* We don't account constants for now.  Assume that the cost is amortized\n        by operations that do use them.  We may re-consider this decision once\n-       we are able to optimize the tree before estimating it's size and break\n+       we are able to optimize the tree before estimating its size and break\n        out static initializers.  */\n     case IDENTIFIER_NODE:\n     case INTEGER_CST:\n@@ -2231,7 +2231,7 @@ clone_body (tree clone, tree fn, void *arg_map)\n }\n \n /* Save duplicate body in FN.  MAP is used to pass around splay tree\n-   used to update argments in restore_body.  */\n+   used to update arguments in restore_body.  */\n \n /* Make and return duplicate of body in FN.  Put copies of DECL_ARGUMENTS\n    in *arg_copy and of the static chain, if any, in *sc_copy.  */"}, {"sha": "109c5bc1c0e6fce09913288b6e0d3e323eaf3011", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/128a79fb0142757127a8ded0635ce6f4f94ecbba/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/128a79fb0142757127a8ded0635ce6f4f94ecbba/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=128a79fb0142757127a8ded0635ce6f4f94ecbba", "patch": "@@ -160,7 +160,7 @@ static struct tree_opt_pass pass_free_datastructures =\n };\n \n /* Pass: fixup_cfg - IPA passes or compilation of earlier functions might've\n-   changed some properties - such as marged functions nothrow.  Remove now\n+   changed some properties - such as marked functions nothrow.  Remove now\n    redundant edges and basic blocks.  */\n \n static void"}, {"sha": "e4cae683f49dd10ddc3c3a816af3f308d594e822", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/128a79fb0142757127a8ded0635ce6f4f94ecbba/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/128a79fb0142757127a8ded0635ce6f4f94ecbba/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=128a79fb0142757127a8ded0635ce6f4f94ecbba", "patch": "@@ -45,7 +45,7 @@ Boston, MA 02111-1307, USA.  */\n    code.  One day we'll want to generalize this code.\n \n    One class of common cases we handle is forward propagating a single use\n-   variale into a COND_EXPR.  \n+   variable into a COND_EXPR.  \n \n      bb0:\n        x = a COND b;"}]}