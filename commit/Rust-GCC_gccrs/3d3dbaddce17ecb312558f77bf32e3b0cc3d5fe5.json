{"sha": "3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2QzZGJhZGRjZTE3ZWNiMzEyNTU4Zjc3YmYzMmUzYjBjYzNkNWZlNQ==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2014-12-12T10:46:00Z"}, "committer": {"name": "Marc Glisse", "email": "glisse@gcc.gnu.org", "date": "2014-12-12T10:46:00Z"}, "message": "real.h (HONOR_SNANS, [...]): Replace macros with 3 overloaded declarations.\n\n2014-12-12  Marc Glisse  <marc.glisse@inria.fr>\n\n\t* real.h (HONOR_SNANS, HONOR_INFINITIES, HONOR_SIGNED_ZEROS,\n\tHONOR_SIGN_DEPENDENT_ROUNDING): Replace macros with 3 overloaded\n\tdeclarations.\n\t* real.c (HONOR_NANS): Fix indentation.\n\t(HONOR_SNANS, HONOR_INFINITIES, HONOR_SIGNED_ZEROS,\n\tHONOR_SIGN_DEPENDENT_ROUNDING): Define three overloads.\n\t* builtins.c (fold_builtin_cproj, fold_builtin_signbit,\n\tfold_builtin_fmin_fmax, fold_builtin_classify): Simplify argument\n\tof HONOR_*.\n\t* fold-const.c (operand_equal_p, fold_comparison, fold_binary_loc):\n\tLikewise.\n\t* gimple-fold.c (gimple_val_nonnegative_real_p): Likewise.\n\t* ifcvt.c (noce_try_move, noce_try_minmax, noce_try_abs): Likewise.\n\t* omp-low.c (omp_reduction_init): Likewise.\n\t* rtlanal.c (may_trap_p_1): Likewise.\n\t* simplify-rtx.c (simplify_const_relational_operation): Likewise.\n\t* tree-ssa-dom.c (record_equality, record_edge_info): Likewise.\n\t* tree-ssa-phiopt.c (value_replacement, abs_replacement): Likewise.\n\t* tree-ssa-reassoc.c (eliminate_using_constants): Likewise.\n\t* tree-ssa-uncprop.c (associate_equivalences_with_edges): Likewise.\n\nFrom-SVN: r218663", "tree": {"sha": "6e8c286bbdbceedd094b4c74d98033969cce3446", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e8c286bbdbceedd094b4c74d98033969cce3446"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3b41b58357054c9f236e265f68a4d852b57fa62d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b41b58357054c9f236e265f68a4d852b57fa62d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b41b58357054c9f236e265f68a4d852b57fa62d"}], "stats": {"total": 186, "additions": 148, "deletions": 38}, "files": [{"sha": "e62a1e4e518a81a42c155f46f16ed6d310dea6bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5", "patch": "@@ -1,3 +1,26 @@\n+2014-12-12  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\t* real.h (HONOR_SNANS, HONOR_INFINITIES, HONOR_SIGNED_ZEROS,\n+\tHONOR_SIGN_DEPENDENT_ROUNDING): Replace macros with 3 overloaded\n+\tdeclarations.\n+\t* real.c (HONOR_NANS): Fix indentation.\n+\t(HONOR_SNANS, HONOR_INFINITIES, HONOR_SIGNED_ZEROS,\n+\tHONOR_SIGN_DEPENDENT_ROUNDING): Define three overloads.\n+\t* builtins.c (fold_builtin_cproj, fold_builtin_signbit,\n+\tfold_builtin_fmin_fmax, fold_builtin_classify): Simplify argument\n+\tof HONOR_*.\n+\t* fold-const.c (operand_equal_p, fold_comparison, fold_binary_loc):\n+\tLikewise.\n+\t* gimple-fold.c (gimple_val_nonnegative_real_p): Likewise.\n+\t* ifcvt.c (noce_try_move, noce_try_minmax, noce_try_abs): Likewise.\n+\t* omp-low.c (omp_reduction_init): Likewise.\n+\t* rtlanal.c (may_trap_p_1): Likewise.\n+\t* simplify-rtx.c (simplify_const_relational_operation): Likewise.\n+\t* tree-ssa-dom.c (record_equality, record_edge_info): Likewise.\n+\t* tree-ssa-phiopt.c (value_replacement, abs_replacement): Likewise.\n+\t* tree-ssa-reassoc.c (eliminate_using_constants): Likewise.\n+\t* tree-ssa-uncprop.c (associate_equivalences_with_edges): Likewise.\n+\n 2014-12-12  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-inline.c (ipa_inline): Fix condition on when"}, {"sha": "445bff2009854d7d7465a61ab5867c009a66679b", "filename": "gcc/builtins.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5", "patch": "@@ -7678,7 +7678,7 @@ fold_builtin_cproj (location_t loc, tree arg, tree type)\n     return NULL_TREE;\n \n   /* If there are no infinities, return arg.  */\n-  if (! HONOR_INFINITIES (TYPE_MODE (TREE_TYPE (type))))\n+  if (! HONOR_INFINITIES (type))\n     return non_lvalue_loc (loc, arg);\n \n   /* Calculate the result when the argument is a constant.  */\n@@ -8949,7 +8949,7 @@ fold_builtin_signbit (location_t loc, tree arg, tree type)\n     return omit_one_operand_loc (loc, type, integer_zero_node, arg);\n \n   /* If ARG's format doesn't have signed zeros, return \"arg < 0.0\".  */\n-  if (!HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg))))\n+  if (!HONOR_SIGNED_ZEROS (arg))\n     return fold_convert (type,\n \t\t\t fold_build2_loc (loc, LT_EXPR, boolean_type_node, arg,\n \t\t\tbuild_real (TREE_TYPE (arg), dconst0)));\n@@ -9143,12 +9143,12 @@ fold_builtin_fmin_fmax (location_t loc, tree arg0, tree arg1,\n \t omit_one_operand() ensures we create a non-lvalue.  */\n       if (TREE_CODE (arg0) == REAL_CST\n \t  && real_isnan (&TREE_REAL_CST (arg0))\n-\t  && (! HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n+\t  && (! HONOR_SNANS (arg0)\n \t      || ! TREE_REAL_CST (arg0).signalling))\n \treturn omit_one_operand_loc (loc, type, arg1, arg0);\n       if (TREE_CODE (arg1) == REAL_CST\n \t  && real_isnan (&TREE_REAL_CST (arg1))\n-\t  && (! HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg1)))\n+\t  && (! HONOR_SNANS (arg1)\n \t      || ! TREE_REAL_CST (arg1).signalling))\n \treturn omit_one_operand_loc (loc, type, arg0, arg1);\n \n@@ -9559,7 +9559,7 @@ fold_builtin_classify (location_t loc, tree fndecl, tree arg, int builtin_index)\n   switch (builtin_index)\n     {\n     case BUILT_IN_ISINF:\n-      if (!HONOR_INFINITIES (TYPE_MODE (TREE_TYPE (arg))))\n+      if (!HONOR_INFINITIES (arg))\n \treturn omit_one_operand_loc (loc, type, integer_zero_node, arg);\n \n       if (TREE_CODE (arg) == REAL_CST)\n@@ -9608,7 +9608,7 @@ fold_builtin_classify (location_t loc, tree fndecl, tree arg, int builtin_index)\n \n     case BUILT_IN_ISFINITE:\n       if (!HONOR_NANS (arg)\n-\t  && !HONOR_INFINITIES (TYPE_MODE (TREE_TYPE (arg))))\n+\t  && !HONOR_INFINITIES (arg))\n \treturn omit_one_operand_loc (loc, type, integer_one_node, arg);\n \n       if (TREE_CODE (arg) == REAL_CST)"}, {"sha": "ec5ad980430608306e4a246aa84c2a66af79c399", "filename": "gcc/fold-const.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5", "patch": "@@ -2800,7 +2800,7 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t  return 1;\n \n \n-\tif (!HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg0))))\n+\tif (!HONOR_SIGNED_ZEROS (arg0))\n \t  {\n \t    /* If we do not distinguish between signed and unsigned zero,\n \t       consider them equal.  */\n@@ -9165,7 +9165,7 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \n \t  /* x != NaN is always true, other ops are always false.  */\n \t  if (REAL_VALUE_ISNAN (cst)\n-\t      && ! HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg1))))\n+\t      && ! HONOR_SNANS (arg1))\n \t    {\n \t      tem = (code == NE_EXPR) ? integer_one_node : integer_zero_node;\n \t      return omit_one_operand_loc (loc, type, tem, arg0);\n@@ -12808,7 +12808,7 @@ fold_binary_loc (location_t loc,\n       if ((TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n \t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0)\n \t  && ((TREE_CODE (TREE_OPERAND (arg0, 1)) == REAL_CST\n-\t       && !HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0))))\n+\t       && !HONOR_SNANS (arg0))\n \t      || (TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n \t\t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))))\n \t{"}, {"sha": "a8ca53da796fb75c1e59cdb7ffe15c9db5e5fde4", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5", "patch": "@@ -5832,7 +5832,7 @@ gimple_val_nonnegative_real_p (tree val)\n \t    CASE_FLT_FN (BUILT_IN_SQRT):\n \t      /* sqrt(-0.0) is -0.0, and sqrt is not defined over other\n \t\t nonnegative inputs.  */\n-\t      if (!HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (val))))\n+\t      if (!HONOR_SIGNED_ZEROS (val))\n \t\treturn true;\n \n \t      break;"}, {"sha": "90586da835bbe30c63242f228f2f425cc480c150", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5", "patch": "@@ -1078,7 +1078,7 @@ noce_try_move (struct noce_if_info *if_info)\n   /* This optimization isn't valid if either A or B could be a NaN\n      or a signed zero.  */\n   if (HONOR_NANS (if_info->x)\n-      || HONOR_SIGNED_ZEROS (GET_MODE (if_info->x)))\n+      || HONOR_SIGNED_ZEROS (if_info->x))\n     return FALSE;\n \n   /* Check whether the operands of the comparison are A and in\n@@ -1969,7 +1969,7 @@ noce_try_minmax (struct noce_if_info *if_info)\n   /* ??? Reject modes with NaNs or signed zeros since we don't know how\n      they will be resolved with an SMIN/SMAX.  It wouldn't be too hard\n      to get the target to tell us...  */\n-  if (HONOR_SIGNED_ZEROS (GET_MODE (if_info->x))\n+  if (HONOR_SIGNED_ZEROS (if_info->x)\n       || HONOR_NANS (if_info->x))\n     return FALSE;\n \n@@ -2063,7 +2063,7 @@ noce_try_abs (struct noce_if_info *if_info)\n   bool one_cmpl = false;\n \n   /* Reject modes with signed zeros.  */\n-  if (HONOR_SIGNED_ZEROS (GET_MODE (if_info->x)))\n+  if (HONOR_SIGNED_ZEROS (if_info->x))\n     return FALSE;\n \n   /* Recognize A and B as constituting an ABS or NABS.  The canonical"}, {"sha": "a2e4737915b8fc09a751bee0e4d12cb2dc916f15", "filename": "gcc/omp-low.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5", "patch": "@@ -3039,7 +3039,7 @@ omp_reduction_init (tree clause, tree type)\n       if (SCALAR_FLOAT_TYPE_P (type))\n \t{\n \t  REAL_VALUE_TYPE max, min;\n-\t  if (HONOR_INFINITIES (TYPE_MODE (type)))\n+\t  if (HONOR_INFINITIES (type))\n \t    {\n \t      real_inf (&max);\n \t      real_arithmetic (&min, NEGATE_EXPR, &max, NULL);\n@@ -3058,7 +3058,7 @@ omp_reduction_init (tree clause, tree type)\n       if (SCALAR_FLOAT_TYPE_P (type))\n \t{\n \t  REAL_VALUE_TYPE max;\n-\t  if (HONOR_INFINITIES (TYPE_MODE (type)))\n+\t  if (HONOR_INFINITIES (type))\n \t    real_inf (&max);\n \t  else\n \t    real_maxval (&max, 0, TYPE_MODE (type));"}, {"sha": "bee42456bcade45bc8fb237b57f60b984c8267fe", "filename": "gcc/real.c", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5", "patch": "@@ -5003,6 +5003,88 @@ HONOR_NANS (const_tree t)\n bool\n HONOR_NANS (const_rtx x)\n {\n-    return HONOR_NANS (GET_MODE (x));\n+  return HONOR_NANS (GET_MODE (x));\n }\n \n+/* Like HONOR_NANs, but true if we honor signaling NaNs (or sNaNs).  */\n+\n+bool\n+HONOR_SNANS (machine_mode m)\n+{\n+  return flag_signaling_nans && HONOR_NANS (m);\n+}\n+\n+bool\n+HONOR_SNANS (const_tree t)\n+{\n+  return HONOR_SNANS (element_mode (t));\n+}\n+\n+bool\n+HONOR_SNANS (const_rtx x)\n+{\n+  return HONOR_SNANS (GET_MODE (x));\n+}\n+\n+/* As for HONOR_NANS, but true if the mode can represent infinity and\n+   the treatment of infinite values is important.  */\n+\n+bool\n+HONOR_INFINITIES (machine_mode m)\n+{\n+  return MODE_HAS_INFINITIES (m) && !flag_finite_math_only;\n+}\n+\n+bool\n+HONOR_INFINITIES (const_tree t)\n+{\n+  return HONOR_INFINITIES (element_mode (t));\n+}\n+\n+bool\n+HONOR_INFINITIES (const_rtx x)\n+{\n+  return HONOR_INFINITIES (GET_MODE (x));\n+}\n+\n+/* Like HONOR_NANS, but true if the given mode distinguishes between\n+   positive and negative zero, and the sign of zero is important.  */\n+\n+bool\n+HONOR_SIGNED_ZEROS (machine_mode m)\n+{\n+  return MODE_HAS_SIGNED_ZEROS (m) && flag_signed_zeros;\n+}\n+\n+bool\n+HONOR_SIGNED_ZEROS (const_tree t)\n+{\n+  return HONOR_SIGNED_ZEROS (element_mode (t));\n+}\n+\n+bool\n+HONOR_SIGNED_ZEROS (const_rtx x)\n+{\n+  return HONOR_SIGNED_ZEROS (GET_MODE (x));\n+}\n+\n+/* Like HONOR_NANS, but true if given mode supports sign-dependent rounding,\n+   and the rounding mode is important.  */\n+\n+bool\n+HONOR_SIGN_DEPENDENT_ROUNDING (machine_mode m)\n+{\n+  return MODE_HAS_SIGN_DEPENDENT_ROUNDING (m) && flag_rounding_math;\n+}\n+\n+bool\n+HONOR_SIGN_DEPENDENT_ROUNDING (const_tree t)\n+{\n+  return HONOR_SIGN_DEPENDENT_ROUNDING (element_mode (t));\n+}\n+\n+bool\n+HONOR_SIGN_DEPENDENT_ROUNDING (const_rtx x)\n+{\n+  return HONOR_SIGN_DEPENDENT_ROUNDING (GET_MODE (x));\n+}"}, {"sha": "aa312ad9d1eb88727fc41732ca5eafc5581d1d76", "filename": "gcc/real.h", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5", "patch": "@@ -195,6 +195,8 @@ extern const struct real_format *\n   (FLOAT_MODE_P (MODE) \\\n    && FLOAT_MODE_FORMAT (MODE)->has_sign_dependent_rounding)\n \n+/* Declare functions in real.c.  */\n+\n /* True if the given mode has a NaN representation and the treatment of\n    NaN operands is important.  Certain optimizations, such as folding\n    x * 0 into 0, are not correct for NaN operands, and are normally\n@@ -205,24 +207,27 @@ extern bool HONOR_NANS (const_tree);\n extern bool HONOR_NANS (const_rtx);\n \n /* Like HONOR_NANs, but true if we honor signaling NaNs (or sNaNs).  */\n-#define HONOR_SNANS(MODE) (flag_signaling_nans && HONOR_NANS (MODE))\n+extern bool HONOR_SNANS (machine_mode);\n+extern bool HONOR_SNANS (const_tree);\n+extern bool HONOR_SNANS (const_rtx);\n \n /* As for HONOR_NANS, but true if the mode can represent infinity and\n    the treatment of infinite values is important.  */\n-#define HONOR_INFINITIES(MODE) \\\n-  (MODE_HAS_INFINITIES (MODE) && !flag_finite_math_only)\n+extern bool HONOR_INFINITIES (machine_mode);\n+extern bool HONOR_INFINITIES (const_tree);\n+extern bool HONOR_INFINITIES (const_rtx);\n \n /* Like HONOR_NANS, but true if the given mode distinguishes between\n    positive and negative zero, and the sign of zero is important.  */\n-#define HONOR_SIGNED_ZEROS(MODE) \\\n-  (MODE_HAS_SIGNED_ZEROS (MODE) && flag_signed_zeros)\n+extern bool HONOR_SIGNED_ZEROS (machine_mode);\n+extern bool HONOR_SIGNED_ZEROS (const_tree);\n+extern bool HONOR_SIGNED_ZEROS (const_rtx);\n \n /* Like HONOR_NANS, but true if given mode supports sign-dependent rounding,\n    and the rounding mode is important.  */\n-#define HONOR_SIGN_DEPENDENT_ROUNDING(MODE) \\\n-  (MODE_HAS_SIGN_DEPENDENT_ROUNDING (MODE) && flag_rounding_math)\n-\n-/* Declare functions in real.c.  */\n+extern bool HONOR_SIGN_DEPENDENT_ROUNDING (machine_mode);\n+extern bool HONOR_SIGN_DEPENDENT_ROUNDING (const_tree);\n+extern bool HONOR_SIGN_DEPENDENT_ROUNDING (const_rtx);\n \n /* Binary or unary arithmetic on tree_code.  */\n extern bool real_arithmetic (REAL_VALUE_TYPE *, int, const REAL_VALUE_TYPE *,"}, {"sha": "2fad919b08975448bb600fe52983f0ce534fbf76", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5", "patch": "@@ -2526,7 +2526,7 @@ may_trap_p_1 (const_rtx x, unsigned flags)\n     case MOD:\n     case UDIV:\n     case UMOD:\n-      if (HONOR_SNANS (GET_MODE (x)))\n+      if (HONOR_SNANS (x))\n \treturn 1;\n       if (SCALAR_FLOAT_MODE_P (GET_MODE (x)))\n \treturn flag_trapping_math;\n@@ -2563,11 +2563,11 @@ may_trap_p_1 (const_rtx x, unsigned flags)\n \n     case EQ:\n     case NE:\n-      if (HONOR_SNANS (GET_MODE (x)))\n+      if (HONOR_SNANS (x))\n \treturn 1;\n       /* Often comparison is CC mode, so check operand modes.  */\n-      if (HONOR_SNANS (GET_MODE (XEXP (x, 0)))\n-\t  || HONOR_SNANS (GET_MODE (XEXP (x, 1))))\n+      if (HONOR_SNANS (XEXP (x, 0))\n+\t  || HONOR_SNANS (XEXP (x, 1)))\n \treturn 1;\n       break;\n "}, {"sha": "8ec416e9cc0f0887d93b18f04f23c19facfc87b5", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5", "patch": "@@ -4757,7 +4757,7 @@ simplify_const_relational_operation (enum rtx_code code,\n   if ((! HONOR_NANS (trueop0)\n        || code == UNEQ || code == UNLE || code == UNGE\n        || ((code == LT || code == GT || code == LTGT)\n-\t   && ! HONOR_SNANS (GET_MODE (trueop0))))\n+\t   && ! HONOR_SNANS (trueop0)))\n       && rtx_equal_p (trueop0, trueop1)\n       && ! side_effects_p (trueop0))\n     return comparison_result (code, CMP_EQ);"}, {"sha": "7842b79b770994b011815e0c125518c49992fce6", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5", "patch": "@@ -1659,7 +1659,7 @@ record_equality (tree x, tree y)\n      variable compared against zero.  If we're honoring signed zeros,\n      then we cannot record this value unless we know that the value is\n      nonzero.  */\n-  if (HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (x)))\n+  if (HONOR_SIGNED_ZEROS (x)\n       && (TREE_CODE (y) != REAL_CST\n \t  || REAL_VALUES_EQUAL (dconst0, TREE_REAL_CST (y))))\n     return;\n@@ -1900,7 +1900,7 @@ record_edge_info (basic_block bb)\n               tree cond = build2 (code, boolean_type_node, op0, op1);\n               tree inverted = invert_truthvalue_loc (loc, cond);\n               bool can_infer_simple_equiv\n-                = !(HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (op0)))\n+                = !(HONOR_SIGNED_ZEROS (op0)\n                     && real_zerop (op0));\n               struct edge_info *edge_info;\n \n@@ -1930,7 +1930,7 @@ record_edge_info (basic_block bb)\n               tree cond = build2 (code, boolean_type_node, op0, op1);\n               tree inverted = invert_truthvalue_loc (loc, cond);\n               bool can_infer_simple_equiv\n-                = !(HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (op1)))\n+                = !(HONOR_SIGNED_ZEROS (op1)\n                     && (TREE_CODE (op1) == SSA_NAME || real_zerop (op1)));\n               struct edge_info *edge_info;\n "}, {"sha": "be1becb964df03219b38499250a001e932765728", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5", "patch": "@@ -749,7 +749,7 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n \n   /* If the type says honor signed zeros we cannot do this\n      optimization.  */\n-  if (HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg1))))\n+  if (HONOR_SIGNED_ZEROS (arg1))\n     return 0;\n \n   /* If there is a statement in MIDDLE_BB that defines one of the PHI\n@@ -1182,7 +1182,7 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n \n   /* If the type says honor signed zeros we cannot do this\n      optimization.  */\n-  if (HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg1))))\n+  if (HONOR_SIGNED_ZEROS (arg1))\n     return false;\n \n   /* OTHER_BLOCK must have only one executable statement which must have the"}, {"sha": "52a4cae558e4ec716b73c63d1a76e3bb4b5112c7", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5", "patch": "@@ -967,7 +967,7 @@ eliminate_using_constants (enum tree_code opcode,\n \t  if (integer_zerop (oelast->op)\n \t      || (FLOAT_TYPE_P (type)\n \t\t  && !HONOR_NANS (type)\n-\t\t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (type))\n+\t\t  && !HONOR_SIGNED_ZEROS (type)\n \t\t  && real_zerop (oelast->op)))\n \t    {\n \t      if (ops->length () != 1)\n@@ -983,7 +983,7 @@ eliminate_using_constants (enum tree_code opcode,\n \t    }\n \t  else if (integer_onep (oelast->op)\n \t\t   || (FLOAT_TYPE_P (type)\n-\t\t       && !HONOR_SNANS (TYPE_MODE (type))\n+\t\t       && !HONOR_SNANS (type)\n \t\t       && real_onep (oelast->op)))\n \t    {\n \t      if (ops->length () != 1)"}, {"sha": "fd7ee3f04a4aa75621d82d5afd958ab1a975bb15", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=3d3dbaddce17ecb312558f77bf32e3b0cc3d5fe5", "patch": "@@ -160,7 +160,7 @@ associate_equivalences_with_edges (void)\n \t\t     the sign of a variable compared against zero.  If\n \t\t     we're honoring signed zeros, then we cannot record\n \t\t     this value unless we know that the value is nonzero.  */\n-\t\t  if (HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (op0)))\n+\t\t  if (HONOR_SIGNED_ZEROS (op0)\n \t\t      && (TREE_CODE (op1) != REAL_CST\n \t\t\t  || REAL_VALUES_EQUAL (dconst0, TREE_REAL_CST (op1))))\n \t\t    continue;"}]}