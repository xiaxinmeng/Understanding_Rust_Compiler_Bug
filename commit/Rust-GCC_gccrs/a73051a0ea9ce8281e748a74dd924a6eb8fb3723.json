{"sha": "a73051a0ea9ce8281e748a74dd924a6eb8fb3723", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTczMDUxYTBlYTljZTgyODFlNzQ4YTc0ZGQ5MjRhNmViOGZiMzcyMw==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-06-10T21:37:53Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-06-10T21:37:53Z"}, "message": "libstdc++: Fix some ranges algos optimizations [PR95578]\n\nranges::copy and a number of other ranges algorithms have unwrapping\noptimizations for iterators of type __normal_iterator, move_iterator and\nreverse_iterator.  But in the checks that guard these optimizations we\ncurrently only test that the iterator of the iterator/sentinel pair has\nthe appropriate type before proceeding with the corresponding\noptimization, and do not also test the sentinel type.\n\nThis breaks the testcase in this PR because this testcase constructs via\nrange adaptors a range whose begin() is a __normal_iterator and whose\nend() is a custom sentinel type, and then performs ranges::copy on it.\nFrom there we bogusly perform the __normal_iterator unwrapping\noptimization on this iterator/sentinel pair, which immediately leads to\na constraint failure since the custom sentinel type does not model\nsentinel_for<int*>.\n\nThis patch fixes this issue by refining each of the problematic checks\nto also test that the iterator and sentinel types are the same before\napplying the corresponding unwrapping optimization.  Along the way, some\ncode simplifications are made.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/95578\n\t* include/bits/ranges_algo.h (__lexicographical_compare_fn):\n\tAlso check that the iterator and sentinel have the same type before\n\tapplying the unwrapping optimization for __normal_iterator.\n\tSplit the check into two, one for the first iterator/sentinel\n\tpair and another for second iterator/sentinel pair.  Remove uses\n\tof __niter_base, and remove uses of std::move on a\n\t__normal_iterator.\n\t* include/bits/ranges_algobase.h (__equal_fn): Likewise.\n\t(__copy_or_move): Likewise.  Perform similar adjustments for\n\tthe reverse_iterator and move_iterator optimizations.  Inline\n\tthe checks into the if-constexprs, and use using-declarations to\n\tmake them less visually noisy.  Remove uses of __niter_wrap.\n\t(__copy_or_move_backward): Likewise.\n\t* testsuite/25_algorithms/copy/95578.cc: New test.\n\t* testsuite/25_algorithms/copy_backward/95578.cc: New test.\n\t* testsuite/25_algorithms/equal/95578.cc: New test.\n\t* testsuite/25_algorithms/lexicographical_compare/95578.cc: New test.\n\t* testsuite/25_algorithms/move/95578.cc: New test.\n\t* testsuite/25_algorithms/move_backward/95578.cc: New test.", "tree": {"sha": "81e44249b7c86a233ef29a170f0084c602db54ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81e44249b7c86a233ef29a170f0084c602db54ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a73051a0ea9ce8281e748a74dd924a6eb8fb3723", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a73051a0ea9ce8281e748a74dd924a6eb8fb3723", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a73051a0ea9ce8281e748a74dd924a6eb8fb3723", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a73051a0ea9ce8281e748a74dd924a6eb8fb3723/comments", "author": null, "committer": null, "parents": [{"sha": "06ef9c119c56568e5f77a5189aa382cb97c95a9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06ef9c119c56568e5f77a5189aa382cb97c95a9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06ef9c119c56568e5f77a5189aa382cb97c95a9e"}], "stats": {"total": 510, "additions": 465, "deletions": 45}, "files": [{"sha": "94ca7b6488d08469f87321c45a4b0908e9d44ff3", "filename": "libstdc++-v3/include/bits/ranges_algo.h", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a73051a0ea9ce8281e748a74dd924a6eb8fb3723/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a73051a0ea9ce8281e748a74dd924a6eb8fb3723/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h?ref=a73051a0ea9ce8281e748a74dd924a6eb8fb3723", "patch": "@@ -3452,11 +3452,15 @@ namespace ranges\n \t\t _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const\n       {\n \tif constexpr (__detail::__is_normal_iterator<_Iter1>\n-\t\t      || __detail::__is_normal_iterator<_Iter2>)\n-\t  return (*this)(std::__niter_base(std::move(__first1)),\n-\t\t\t std::__niter_base(std::move(__last1)),\n-\t\t\t std::__niter_base(std::move(__first2)),\n-\t\t\t std::__niter_base(std::move(__last2)),\n+\t\t      && same_as<_Iter1, _Sent1>)\n+\t  return (*this)(__first1.base(), __last1.base(),\n+\t\t\t std::move(__first2), std::move(__last2),\n+\t\t\t std::move(__comp),\n+\t\t\t std::move(__proj1), std::move(__proj2));\n+\telse if constexpr (__detail::__is_normal_iterator<_Iter2>\n+\t\t\t   && same_as<_Iter2, _Sent2>)\n+\t  return (*this)(std::move(__first1), std::move(__last1),\n+\t\t\t __first2.base(), __last2.base(),\n \t\t\t std::move(__comp),\n \t\t\t std::move(__proj1), std::move(__proj2));\n \telse"}, {"sha": "3bdc7cc471b665bcb05c42744db002fece7cae00", "filename": "libstdc++-v3/include/bits/ranges_algobase.h", "status": "modified", "additions": 48, "deletions": 40, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a73051a0ea9ce8281e748a74dd924a6eb8fb3723/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a73051a0ea9ce8281e748a74dd924a6eb8fb3723/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algobase.h?ref=a73051a0ea9ce8281e748a74dd924a6eb8fb3723", "patch": "@@ -85,11 +85,15 @@ namespace ranges\n \t// TODO: implement more specializations to at least have parity with\n \t// std::equal.\n \tif constexpr (__detail::__is_normal_iterator<_Iter1>\n-\t\t      || __detail::__is_normal_iterator<_Iter2>)\n-\t  return (*this)(std::__niter_base(std::move(__first1)),\n-\t\t\t std::__niter_base(std::move(__last1)),\n-\t\t\t std::__niter_base(std::move(__first2)),\n-\t\t\t std::__niter_base(std::move(__last2)),\n+\t\t      && same_as<_Iter1, _Sent1>)\n+\t  return (*this)(__first1.base(), __last1.base(),\n+\t\t\t std::move(__first2), std::move(__last2),\n+\t\t\t std::move(__pred),\n+\t\t\t std::move(__proj1), std::move(__proj2));\n+\telse if constexpr (__detail::__is_normal_iterator<_Iter2>\n+\t\t\t   && same_as<_Iter2, _Sent2>)\n+\t  return (*this)(std::move(__first1), std::move(__last1),\n+\t\t\t __first2.base(), __last2.base(),\n \t\t\t std::move(__pred),\n \t\t\t std::move(__proj1), std::move(__proj2));\n \telse if constexpr (sized_sentinel_for<_Sent1, _Iter1>\n@@ -211,38 +215,39 @@ namespace ranges\n     {\n       // TODO: implement more specializations to be at least on par with\n       // std::copy/std::move.\n-      constexpr bool __normal_iterator_p\n-\t= (__detail::__is_normal_iterator<_Iter>\n-\t   || __detail::__is_normal_iterator<_Out>);\n-      constexpr bool __reverse_p\n-\t= (__detail::__is_reverse_iterator<_Iter>\n-\t   && __detail::__is_reverse_iterator<_Out>);\n-      constexpr bool __move_iterator_p = __detail::__is_move_iterator<_Iter>;\n-      if constexpr (__move_iterator_p)\n+      using __detail::__is_move_iterator;\n+      using __detail::__is_reverse_iterator;\n+      using __detail::__is_normal_iterator;\n+      if constexpr (__is_move_iterator<_Iter> && same_as<_Iter, _Sent>)\n \t{\n \t  auto [__in, __out]\n \t    = ranges::__copy_or_move<true>(std::move(__first).base(),\n \t\t\t\t\t   std::move(__last).base(),\n \t\t\t\t\t   std::move(__result));\n \t  return {move_iterator{std::move(__in)}, std::move(__out)};\n \t}\n-      else if constexpr (__reverse_p)\n+      else if constexpr (__is_reverse_iterator<_Iter> && same_as<_Iter, _Sent>\n+\t\t\t && __is_reverse_iterator<_Out>)\n \t{\n \t  auto [__in,__out]\n-\t    = ranges::__copy_or_move_backward<_IsMove>(__last.base(),\n-\t\t\t\t\t\t       __first.base(),\n-\t\t\t\t\t\t       __result.base());\n+\t    = ranges::__copy_or_move_backward<_IsMove>(std::move(__last).base(),\n+\t\t\t\t\t\t       std::move(__first).base(),\n+\t\t\t\t\t\t       std::move(__result).base());\n \t  return {reverse_iterator{std::move(__in)},\n \t\t  reverse_iterator{std::move(__out)}};\n \t}\n-      else if constexpr (__normal_iterator_p)\n+      else if constexpr (__is_normal_iterator<_Iter> && same_as<_Iter, _Sent>)\n+\t{\n+\t  auto [__in,__out]\n+\t    = ranges::__copy_or_move<_IsMove>(__first.base(), __last.base(),\n+\t\t\t\t\t      __result);\n+\t  return {decltype(__first){__in}, std::move(__out)};\n+\t}\n+      else if constexpr (__is_normal_iterator<_Out>)\n \t{\n \t  auto [__in,__out]\n-\t    = ranges::__copy_or_move<_IsMove>(std::__niter_base(__first),\n-\t\t\t\t\t      std::__niter_base(__last),\n-\t\t\t\t\t      std::__niter_base(__result));\n-\t  return {std::__niter_wrap(__first, std::move(__in)),\n-\t\t  std::__niter_wrap(__result, std::move(__out))};\n+\t    = ranges::__copy_or_move<_IsMove>(__first, __last, __result.base());\n+\t  return {std::move(__in), decltype(__result){__out}};\n \t}\n       else if constexpr (sized_sentinel_for<_Sent, _Iter>)\n \t{\n@@ -353,30 +358,33 @@ namespace ranges\n     {\n       // TODO: implement more specializations to be at least on par with\n       // std::copy_backward/std::move_backward.\n-      constexpr bool __normal_iterator_p\n-\t= (__detail::__is_normal_iterator<_Iter>\n-\t   || __detail::__is_normal_iterator<_Out>);\n-      constexpr bool __reverse_p\n-\t= (__detail::__is_reverse_iterator<_Iter>\n-\t   && __detail::__is_reverse_iterator<_Out>);\n-      if constexpr (__reverse_p)\n+      using __detail::__is_reverse_iterator;\n+      using __detail::__is_normal_iterator;\n+      if constexpr (__is_reverse_iterator<_Iter> && same_as<_Iter, _Sent>\n+\t\t    && __is_reverse_iterator<_Out>)\n \t{\n \t  auto [__in,__out]\n-\t    = ranges::__copy_or_move<_IsMove>(__last.base(),\n-\t\t\t\t\t      __first.base(),\n-\t\t\t\t\t      __result.base());\n+\t    = ranges::__copy_or_move<_IsMove>(std::move(__last).base(),\n+\t\t\t\t\t      std::move(__first).base(),\n+\t\t\t\t\t      std::move(__result).base());\n \t  return {reverse_iterator{std::move(__in)},\n \t\t  reverse_iterator{std::move(__out)}};\n \t}\n-      else if constexpr (__normal_iterator_p)\n+      else if constexpr (__is_normal_iterator<_Iter> && same_as<_Iter, _Sent>)\n \t{\n \t  auto [__in,__out]\n-\t    = ranges::__copy_or_move_backward<_IsMove>\n-\t      (std::__niter_base(__first),\n-\t       std::__niter_base(__last),\n-\t       std::__niter_base(__result));\n-\t  return {std::__niter_wrap(__first, std::move(__in)),\n-\t\t  std::__niter_wrap(__result, std::move(__out))};\n+\t    = ranges::__copy_or_move_backward<_IsMove>(__first.base(),\n+\t\t\t\t\t\t       __last.base(),\n+\t\t\t\t\t\t       std::move(__result));\n+\t  return {decltype(__first){__in}, std::move(__out)};\n+\t}\n+      else if constexpr (__is_normal_iterator<_Out>)\n+\t{\n+\t  auto [__in,__out]\n+\t    = ranges::__copy_or_move_backward<_IsMove>(std::move(__first),\n+\t\t\t\t\t\t       std::move(__last),\n+\t\t\t\t\t\t       __result.base());\n+\t  return {std::move(__in), decltype(__result){__out}};\n \t}\n       else if constexpr (sized_sentinel_for<_Sent, _Iter>)\n \t{"}, {"sha": "7aaefba454cef31d94673810fbf6b5a3fede7795", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/95578.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a73051a0ea9ce8281e748a74dd924a6eb8fb3723/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F95578.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a73051a0ea9ce8281e748a74dd924a6eb8fb3723/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F95578.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F95578.cc?ref=a73051a0ea9ce8281e748a74dd924a6eb8fb3723", "patch": "@@ -0,0 +1,74 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+namespace ranges = std::ranges;\n+\n+template<typename It>\n+struct sentinel\n+{\n+  It it;\n+\n+  friend bool\n+  operator==(It x, sentinel y)\n+  { return x == y.it; }\n+};\n+\n+void\n+test01()\n+{\n+  std::vector<int> v = {1,2,3,4,5}, w = {0,0,0,0,0};\n+  ranges::subrange sr = {v.begin(), sentinel{v.end()}};\n+  ranges::copy(sr, w.begin());\n+  VERIFY( ranges::equal(w, (int[]){1,2,3,4,5}) );\n+}\n+\n+void\n+test02()\n+{\n+  using std::reverse_iterator;\n+  std::vector<int> v = {1,2,3,4,5}, w = {0,0,0,0,0};\n+  ranges::subrange sr\n+    = {reverse_iterator{v.end()}, sentinel{reverse_iterator{v.begin()}}};\n+  ranges::copy(sr, reverse_iterator{w.end()});\n+  VERIFY( ranges::equal(w, (int[]){1,2,3,4,5}) );\n+}\n+\n+void\n+test03()\n+{\n+  using std::move_iterator;\n+  std::vector<int> v = {1,2,3,4,5}, w = {0,0,0,0,0};\n+  ranges::subrange sr\n+    = {move_iterator{v.begin()}, sentinel{move_iterator{v.end()}}};\n+  ranges::copy(sr, w.begin());\n+  VERIFY( ranges::equal(w, (int[]){1,2,3,4,5}) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "6e3d1b6240120b72620f5bb1151e4f144cb7987d", "filename": "libstdc++-v3/testsuite/25_algorithms/copy_backward/95578.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a73051a0ea9ce8281e748a74dd924a6eb8fb3723/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_backward%2F95578.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a73051a0ea9ce8281e748a74dd924a6eb8fb3723/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_backward%2F95578.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy_backward%2F95578.cc?ref=a73051a0ea9ce8281e748a74dd924a6eb8fb3723", "patch": "@@ -0,0 +1,62 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+namespace ranges = std::ranges;\n+\n+template<typename It>\n+struct sentinel\n+{\n+  It it;\n+\n+  friend bool\n+  operator==(It x, sentinel y)\n+  { return x == y.it; }\n+};\n+\n+void\n+test01()\n+{\n+  std::vector<int> v = {1,2,3,4,5}, w = {0,0,0,0,0};\n+  ranges::subrange sr = {v.begin(), sentinel{v.end()}};\n+  ranges::copy_backward(sr, w.end());\n+  VERIFY( ranges::equal(w, (int[]){1,2,3,4,5}) );\n+}\n+\n+void\n+test02()\n+{\n+  using std::reverse_iterator;\n+  std::vector<int> v = {1,2,3,4,5}, w = {0,0,0,0,0};\n+  ranges::subrange sr\n+    = {reverse_iterator{v.end()}, sentinel{reverse_iterator{v.begin()}}};\n+  ranges::copy_backward(sr, reverse_iterator{w.begin()});\n+  VERIFY( ranges::equal(w, (int[]){1,2,3,4,5}) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "b69d877e4e3d7bab4ac816aa6f1d7ed675df2e2e", "filename": "libstdc++-v3/testsuite/25_algorithms/equal/95578.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a73051a0ea9ce8281e748a74dd924a6eb8fb3723/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal%2F95578.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a73051a0ea9ce8281e748a74dd924a6eb8fb3723/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal%2F95578.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal%2F95578.cc?ref=a73051a0ea9ce8281e748a74dd924a6eb8fb3723", "patch": "@@ -0,0 +1,74 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+namespace ranges = std::ranges;\n+\n+template<typename It>\n+struct sentinel\n+{\n+  It it;\n+\n+  friend bool\n+  operator==(It x, sentinel y)\n+  { return x == y.it; }\n+};\n+\n+void\n+test01()\n+{\n+  std::vector<int> v = {1,2,3,4,5};\n+  ranges::subrange sr = {v.begin(), sentinel{v.end()}};\n+  VERIFY( ranges::equal(sr, v) );\n+  VERIFY( ranges::equal(v, sr) );\n+}\n+\n+void\n+test02()\n+{\n+  using std::reverse_iterator;\n+  std::vector<int> v = {1,2,3,4,5};\n+  ranges::subrange sr\n+    = {reverse_iterator{v.end()}, sentinel{reverse_iterator{v.begin()}}};\n+  VERIFY( ranges::equal(sr, (int[]){5,4,3,2,1}) );\n+  VERIFY( ranges::equal((int[]){5,4,3,2,1}, sr) );\n+}\n+\n+void\n+test03()\n+{\n+  using std::move_iterator;\n+  std::vector<int> v = {1,2,3,4,5};\n+  ranges::subrange sr\n+    = {move_iterator{v.begin()}, sentinel{move_iterator{v.end()}}};\n+  VERIFY( ranges::equal(sr, v) );\n+  VERIFY( ranges::equal(v, sr) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "693506826bc5028f73be433f2424359027f3bd08", "filename": "libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/95578.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a73051a0ea9ce8281e748a74dd924a6eb8fb3723/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare%2F95578.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a73051a0ea9ce8281e748a74dd924a6eb8fb3723/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare%2F95578.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Flexicographical_compare%2F95578.cc?ref=a73051a0ea9ce8281e748a74dd924a6eb8fb3723", "patch": "@@ -0,0 +1,74 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+namespace ranges = std::ranges;\n+\n+template<typename It>\n+struct sentinel\n+{\n+  It it;\n+\n+  friend bool\n+  operator==(It x, sentinel y)\n+  { return x == y.it; }\n+};\n+\n+void\n+test01()\n+{\n+  std::vector<int> v = {1,2,3,4,5};\n+  ranges::subrange sr = {v.begin(), sentinel{v.end()}};\n+  VERIFY( ranges::lexicographical_compare(sr, (int[]){1,2,3,5,5}) );\n+  VERIFY( !ranges::lexicographical_compare((int[]){1,2,3,5,5}, sr) );\n+}\n+\n+void\n+test02()\n+{\n+  using std::reverse_iterator;\n+  std::vector<int> v = {1,2,3,4,5};\n+  ranges::subrange sr\n+    = {reverse_iterator{v.end()}, sentinel{reverse_iterator{v.begin()}}};\n+  VERIFY( ranges::lexicographical_compare(sr, (int[]){5,4,3,2,2}) );\n+  VERIFY( !ranges::lexicographical_compare((int[]){5,4,3,2,2}, sr) );\n+}\n+\n+void\n+test03()\n+{\n+  using std::move_iterator;\n+  std::vector<int> v = {1,2,3,4,5};\n+  ranges::subrange sr\n+    = {move_iterator{v.begin()}, sentinel{move_iterator{v.end()}}};\n+  VERIFY( ranges::lexicographical_compare(sr, (int[]){1,2,3,5,5}) );\n+  VERIFY( !ranges::lexicographical_compare((int[]){1,2,3,5,5}, sr) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "e5c494d55d2d7a6fe26c54f09149932847ba0cc9", "filename": "libstdc++-v3/testsuite/25_algorithms/move/95578.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a73051a0ea9ce8281e748a74dd924a6eb8fb3723/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove%2F95578.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a73051a0ea9ce8281e748a74dd924a6eb8fb3723/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove%2F95578.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove%2F95578.cc?ref=a73051a0ea9ce8281e748a74dd924a6eb8fb3723", "patch": "@@ -0,0 +1,62 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+namespace ranges = std::ranges;\n+\n+template<typename It>\n+struct sentinel\n+{\n+  It it;\n+\n+  friend bool\n+  operator==(It x, sentinel y)\n+  { return x == y.it; }\n+};\n+\n+void\n+test01()\n+{\n+  std::vector<int> v = {1,2,3,4,5}, w = {0,0,0,0,0};\n+  ranges::subrange sr = {v.begin(), sentinel{v.end()}};\n+  ranges::move(sr, w.begin());\n+  VERIFY( ranges::equal(w, (int[]){1,2,3,4,5}) );\n+}\n+\n+void\n+test02()\n+{\n+  using std::reverse_iterator;\n+  std::vector<int> v = {1,2,3,4,5}, w = {0,0,0,0,0};\n+  ranges::subrange sr\n+    = {reverse_iterator{v.end()}, sentinel{reverse_iterator{v.begin()}}};\n+  ranges::move(sr, reverse_iterator{w.end()});\n+  VERIFY( ranges::equal(w, (int[]){1,2,3,4,5}) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "694e4a75c83a26e9e26c07228a051db6c05b0c4d", "filename": "libstdc++-v3/testsuite/25_algorithms/move_backward/95578.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a73051a0ea9ce8281e748a74dd924a6eb8fb3723/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove_backward%2F95578.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a73051a0ea9ce8281e748a74dd924a6eb8fb3723/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove_backward%2F95578.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmove_backward%2F95578.cc?ref=a73051a0ea9ce8281e748a74dd924a6eb8fb3723", "patch": "@@ -0,0 +1,62 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+namespace ranges = std::ranges;\n+\n+template<typename It>\n+struct sentinel\n+{\n+  It it;\n+\n+  friend bool\n+  operator==(It x, sentinel y)\n+  { return x == y.it; }\n+};\n+\n+void\n+test01()\n+{\n+  std::vector<int> v = {1,2,3,4,5}, w = {0,0,0,0,0};\n+  ranges::subrange sr = {v.begin(), sentinel{v.end()}};\n+  ranges::move_backward(sr, w.end());\n+  VERIFY( ranges::equal(w, (int[]){1,2,3,4,5}) );\n+}\n+\n+void\n+test02()\n+{\n+  using std::reverse_iterator;\n+  std::vector<int> v = {1,2,3,4,5}, w = {0,0,0,0,0};\n+  ranges::subrange sr\n+    = {reverse_iterator{v.end()}, sentinel{reverse_iterator{v.begin()}}};\n+  ranges::move_backward(sr, reverse_iterator{w.begin()});\n+  VERIFY( ranges::equal(w, (int[]){1,2,3,4,5}) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}]}