{"sha": "73ddf95bf187bda7f85cac64974c843328a0832d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNkZGY5NWJmMTg3YmRhN2Y4NWNhYzY0OTc0Yzg0MzMyOGEwODMyZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-11-02T19:35:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-11-02T19:35:44Z"}, "message": "tree-ssa-loop-niter.c (double_int_cmp, [...]): New functions.\n\n\n\t* tree-ssa-loop-niter.c (double_int_cmp, bound_index,\n\tdiscover_iteration_bound_by_body_walk): New functions.\n\t(discover_iteration_bound_by_body_walk): Use it.\n\n\t* gcc.dg/tree-ssa/loop-38.c: New testcase.\n\nFrom-SVN: r193104", "tree": {"sha": "0e4c185682a787aa27584642ae4388814344aa43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e4c185682a787aa27584642ae4388814344aa43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73ddf95bf187bda7f85cac64974c843328a0832d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73ddf95bf187bda7f85cac64974c843328a0832d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73ddf95bf187bda7f85cac64974c843328a0832d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73ddf95bf187bda7f85cac64974c843328a0832d/comments", "author": null, "committer": null, "parents": [{"sha": "161b371fc564893df9b2b8aff9bbd887f9faefa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/161b371fc564893df9b2b8aff9bbd887f9faefa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/161b371fc564893df9b2b8aff9bbd887f9faefa8"}], "stats": {"total": 248, "additions": 248, "deletions": 0}, "files": [{"sha": "284dd8a152036b52ec3e0608254b3f5a14ae6c4c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ddf95bf187bda7f85cac64974c843328a0832d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ddf95bf187bda7f85cac64974c843328a0832d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73ddf95bf187bda7f85cac64974c843328a0832d", "patch": "@@ -1,3 +1,9 @@\n+2012-11-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-ssa-loop-niter.c (double_int_cmp, bound_index,\n+\tdiscover_iteration_bound_by_body_walk): New functions.\n+\t(discover_iteration_bound_by_body_walk): Use it.\n+\n 2012-11-02  Jan Hubicka  <jh@suse.cz>\n \n \t* predict.c (predict_loops): Predict also exits not dominating"}, {"sha": "7bf85b0c714c3fd595d0c78fbb10561e208ad787", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ddf95bf187bda7f85cac64974c843328a0832d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ddf95bf187bda7f85cac64974c843328a0832d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=73ddf95bf187bda7f85cac64974c843328a0832d", "patch": "@@ -11,6 +11,10 @@\n \t* gcc.target/powerpc/pr46728-8.c: Likewise.\n \t* gcc/testsuite/gcc.dg/pr46728-6.c: Likewise.\n \n+2012-11-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/loop-38.c: New testcase.\n+\n 2012-11-02  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.dg/tree-ssa/cunroll-10.c: New testcase."}, {"sha": "d5568d64624aaa8c24fd8b57793fa8f0039b2e29", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-38.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ddf95bf187bda7f85cac64974c843328a0832d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-38.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ddf95bf187bda7f85cac64974c843328a0832d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-38.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-38.c?ref=73ddf95bf187bda7f85cac64974c843328a0832d", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-cunrolli-details\" } */\n+int a[10];\n+int b[11];\n+t(int n)\n+{\n+   int i;\n+   int sum = 0;\n+   for (i=0;i<n;i++)\n+     if (q())\n+\tsum+=a[i];\n+     else\n+\tsum+=b[i];\n+  return sum;\n+}\n+/* { dg-final { scan-tree-dump \"Found better loop bound 10\" \"cunrolli\" } } */\n+/* { dg-final { scan-tree-dump \"Loop 1 iterates at most 10 times\" \"cunrolli\" } } */\n+/* { dg-final { cleanup-tree-dump \"cunrolli\" } } */"}, {"sha": "b769f849d0e9da8696553fc22176e7b29bea7e8d", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73ddf95bf187bda7f85cac64974c843328a0832d/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73ddf95bf187bda7f85cac64974c843328a0832d/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=73ddf95bf187bda7f85cac64974c843328a0832d", "patch": "@@ -2961,6 +2961,224 @@ gcov_type_to_double_int (gcov_type val)\n   return ret;\n }\n \n+/* Compare double ints, callback for qsort.  */\n+\n+int\n+double_int_cmp (const void *p1, const void *p2)\n+{\n+  const double_int *d1 = (const double_int *)p1;\n+  const double_int *d2 = (const double_int *)p2;\n+  if (*d1 == *d2)\n+    return 0;\n+  if (d1->ult (*d2))\n+    return -1;\n+  return 1;\n+}\n+\n+/* Return index of BOUND in BOUNDS array sorted in increasing order.\n+   Lookup by binary search.  */\n+\n+int\n+bound_index (VEC (double_int, heap) *bounds, double_int bound)\n+{\n+  unsigned int end = VEC_length (double_int, bounds);\n+  unsigned int begin = 0;\n+\n+  /* Find a matching index by means of a binary search.  */\n+  while (begin != end)\n+    {\n+      unsigned int middle = (begin + end) / 2;\n+      double_int index = VEC_index (double_int, bounds, middle);\n+\n+      if (index == bound)\n+\treturn middle;\n+      else if (index.ult (bound))\n+\tbegin = middle + 1;\n+      else\n+\tend = middle;\n+    }\n+  gcc_unreachable ();\n+}\n+\n+/* Used to hold vector of queues of basic blocks bellow.  */\n+typedef VEC (basic_block, heap) *bb_queue;\n+DEF_VEC_P(bb_queue);\n+DEF_VEC_ALLOC_P(bb_queue,heap);\n+\n+/* We recorded loop bounds only for statements dominating loop latch (and thus\n+   executed each loop iteration).  If there are any bounds on statements not\n+   dominating the loop latch we can improve the estimate by walking the loop\n+   body and seeing if every path from loop header to loop latch contains\n+   some bounded statement.  */\n+\n+static void\n+discover_iteration_bound_by_body_walk (struct loop *loop)\n+{\n+  pointer_map_t *bb_bounds;\n+  struct nb_iter_bound *elt;\n+  VEC (double_int, heap) *bounds = NULL;\n+  VEC (bb_queue, heap) *queues = NULL;\n+  bb_queue queue = NULL;\n+  ptrdiff_t queue_index;\n+  ptrdiff_t latch_index = 0;\n+  pointer_map_t *block_priority;\n+\n+  /* Discover what bounds may interest us.  */\n+  for (elt = loop->bounds; elt; elt = elt->next)\n+    {\n+      double_int bound = elt->bound;\n+\n+      /* Exit terminates loop at given iteration, while non-exits produce undefined\n+\t effect on the next iteration.  */\n+      if (!elt->is_exit)\n+\tbound += double_int_one;\n+\n+      if (!loop->any_upper_bound\n+\t  || bound.ult (loop->nb_iterations_upper_bound))\n+        VEC_safe_push (double_int, heap, bounds, bound);\n+    }\n+\n+  /* Exit early if there is nothing to do.  */\n+  if (!bounds)\n+    return;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \" Trying to walk loop body to reduce the bound.\\n\");\n+\n+  /* Sort the bounds in decreasing order.  */\n+  qsort (VEC_address (double_int, bounds), VEC_length (double_int, bounds),\n+\t sizeof (double_int), double_int_cmp);\n+\n+  /* For every basic block record the lowest bound that is guaranteed to\n+     terminate the loop.  */\n+\n+  bb_bounds = pointer_map_create ();\n+  for (elt = loop->bounds; elt; elt = elt->next)\n+    {\n+      double_int bound = elt->bound;\n+      if (!elt->is_exit)\n+\tbound += double_int_one;\n+\n+      if (!loop->any_upper_bound\n+\t  || bound.ult (loop->nb_iterations_upper_bound))\n+\t{\n+\t  ptrdiff_t index = bound_index (bounds, bound);\n+\t  void **entry = pointer_map_contains (bb_bounds,\n+\t\t\t\t\t       gimple_bb (elt->stmt));\n+\t  if (!entry)\n+\t    *pointer_map_insert (bb_bounds,\n+\t\t\t\t gimple_bb (elt->stmt)) = (void *)index;\n+\t  else if ((ptrdiff_t)*entry > index)\n+\t    *entry = (void *)index;\n+\t}\n+    }\n+\n+  block_priority = pointer_map_create ();\n+\n+  /* Perform shortest path discovery loop->header ... loop->latch.\n+\n+     The \"distance\" is given by the smallest loop bound of basic block\n+     present in the path and we look for path with largest smallest bound\n+     on it.\n+\n+     To avoid the need for fibonaci heap on double ints we simply compress\n+     double ints into indexes to BOUNDS array and then represent the queue\n+     as arrays of queues for every index.\n+     Index of VEC_length (BOUNDS) means that the execution of given BB has\n+     no bounds determined.\n+\n+     VISITED is a pointer map translating basic block into smallest index\n+     it was inserted into the priority queue with.  */\n+  latch_index = -1;\n+\n+  /* Start walk in loop header with index set to infinite bound.  */\n+  queue_index = VEC_length (double_int, bounds);\n+  VEC_safe_grow_cleared (bb_queue, heap, queues, queue_index + 1);\n+  VEC_safe_push (basic_block, heap, queue, loop->header);\n+  VEC_replace (bb_queue, queues, queue_index, queue);\n+  *pointer_map_insert (block_priority, loop->header) = (void *)queue_index;\n+\n+  for (; queue_index >= 0; queue_index--)\n+    {\n+      if (latch_index < queue_index)\n+\t{\n+\t  while (VEC_length (basic_block,\n+\t\t\t     VEC_index (bb_queue, queues, queue_index)))\n+\t    {\n+\t      basic_block bb;\n+\t      ptrdiff_t bound_index = queue_index;\n+\t      void **entry;\n+              edge e;\n+              edge_iterator ei;\n+\n+\t      queue = VEC_index (bb_queue, queues, queue_index);\n+\t      bb = VEC_pop (basic_block, queue);\n+\n+\t      /* OK, we later inserted the BB with lower priority, skip it.  */\n+\t      if ((ptrdiff_t)*pointer_map_contains (block_priority, bb) > queue_index)\n+\t\tcontinue;\n+\n+\t      /* See if we can improve the bound.  */\n+\t      entry = pointer_map_contains (bb_bounds, bb);\n+\t      if (entry && (ptrdiff_t)*entry < bound_index)\n+\t\tbound_index = (ptrdiff_t)*entry;\n+\n+\t      /* Insert succesors into the queue, watch for latch edge\n+\t\t and record greatest index we saw.  */\n+\t      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t\t{\n+\t\t  bool insert = false;\n+\t\t  void **entry;\n+\n+\t\t  if (loop_exit_edge_p (loop, e))\n+\t\t    continue;\n+\n+\t\t  if (e == loop_latch_edge (loop)\n+\t\t      && latch_index < bound_index)\n+\t\t    latch_index = bound_index;\n+\t\t  else if (!(entry = pointer_map_contains (block_priority, e->dest)))\n+\t\t    {\n+\t\t      insert = true;\n+\t\t      *pointer_map_insert (block_priority, e->dest) = (void *)bound_index;\n+\t\t    }\n+\t\t  else if ((ptrdiff_t)*entry < bound_index)\n+\t\t    {\n+\t\t      insert = true;\n+\t\t      *entry = (void *)bound_index;\n+\t\t    }\n+\t\t    \n+\t\t  if (insert)\n+\t\t    {\n+\t\t      bb_queue queue2 = VEC_index (bb_queue, queues, bound_index);\n+\t\t      VEC_safe_push (basic_block, heap, queue2, e->dest);\n+\t\t      VEC_replace (bb_queue, queues, bound_index, queue2);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\tVEC_free (basic_block, heap, VEC_index (bb_queue, queues, queue_index));\n+    }\n+\n+  gcc_assert (latch_index >= 0);\n+  if (latch_index < VEC_length (double_int, bounds))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Found better loop bound \");\n+\t  dump_double_int (dump_file,\n+\t\t\t   VEC_index (double_int, bounds, latch_index), true);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      record_niter_bound (loop, VEC_index (double_int, bounds, latch_index),\n+\t\t\t  false, true);\n+    }\n+\n+  VEC_free (bb_queue, heap, queues);\n+  pointer_map_destroy (bb_bounds);\n+  pointer_map_destroy (block_priority);\n+}\n+\n /* See if every path cross the loop goes through a statement that is known\n    to not execute at the last iteration. In that case we can decrese iteration\n    count by 1.  */\n@@ -3108,6 +3326,8 @@ estimate_numbers_of_iterations_loop (struct loop *loop)\n \n   infer_loop_bounds_from_undefined (loop);\n \n+  discover_iteration_bound_by_body_walk (loop);\n+\n   maybe_lower_iteration_bound (loop);\n \n   /* If we have a measured profile, use it to estimate the number of"}]}