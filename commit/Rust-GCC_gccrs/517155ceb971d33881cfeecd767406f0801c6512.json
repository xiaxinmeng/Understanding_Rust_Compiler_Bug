{"sha": "517155ceb971d33881cfeecd767406f0801c6512", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE3MTU1Y2ViOTcxZDMzODgxY2ZlZWNkNzY3NDA2ZjA4MDFjNjUxMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-06-03T15:50:44Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-06-03T15:56:59Z"}, "message": "Fix issue for external subtypes with -fdump-ada-spec\n\nThis works around an irregularity of the language whereby subtypes, unlike\ntypes, are not visible through a limited_with clause.\n\ngcc/c-family/\n\t* c-ada-spec.c (pp_ada_tree_identifier): Tidy up.\n\t(dump_ada_node) <POINTER_TYPE>: Deal specially with external subtypes.", "tree": {"sha": "53273eba49e65c91edd7c3fa3c0b34b252c99b77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53273eba49e65c91edd7c3fa3c0b34b252c99b77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/517155ceb971d33881cfeecd767406f0801c6512", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/517155ceb971d33881cfeecd767406f0801c6512", "html_url": "https://github.com/Rust-GCC/gccrs/commit/517155ceb971d33881cfeecd767406f0801c6512", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/517155ceb971d33881cfeecd767406f0801c6512/comments", "author": null, "committer": null, "parents": [{"sha": "5f2ef25b08f782a9f72adb8e6389ce66d302594b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f2ef25b08f782a9f72adb8e6389ce66d302594b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f2ef25b08f782a9f72adb8e6389ce66d302594b"}], "stats": {"total": 91, "additions": 53, "deletions": 38}, "files": [{"sha": "751cc0edef8deef29fc1b581ff6e850e89d5b693", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 53, "deletions": 38, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517155ceb971d33881cfeecd767406f0801c6512/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517155ceb971d33881cfeecd767406f0801c6512/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=517155ceb971d33881cfeecd767406f0801c6512", "patch": "@@ -1341,49 +1341,46 @@ pp_ada_tree_identifier (pretty_printer *buffer, tree node, tree type,\n   char *s = to_ada_name (name, &space_found);\n   tree decl = get_underlying_decl (type);\n \n-  /* If the entity comes from another file, generate a package prefix.  */\n   if (decl)\n     {\n-      expanded_location xloc = expand_location (decl_sloc (decl, false));\n+      /* If the entity comes from another file, generate a package prefix.  */\n+      const expanded_location xloc = expand_location (decl_sloc (decl, false));\n \n-      if (xloc.file && xloc.line)\n+      if (xloc.line && xloc.file && xloc.file != current_source_file)\n \t{\n-\t  if (xloc.file != current_source_file)\n+\t  switch (TREE_CODE (type))\n \t    {\n-\t      switch (TREE_CODE (type))\n-\t\t{\n-\t\t  case ENUMERAL_TYPE:\n-\t\t  case INTEGER_TYPE:\n-\t\t  case REAL_TYPE:\n-\t\t  case FIXED_POINT_TYPE:\n-\t\t  case BOOLEAN_TYPE:\n-\t\t  case REFERENCE_TYPE:\n-\t\t  case POINTER_TYPE:\n-\t\t  case ARRAY_TYPE:\n-\t\t  case RECORD_TYPE:\n-\t\t  case UNION_TYPE:\n-\t\t  case TYPE_DECL:\n-\t\t    if (package_prefix)\n-\t\t      {\n-\t\t\tchar *s1 = get_ada_package (xloc.file);\n-\t\t\tappend_withs (s1, limited_access);\n-\t\t\tpp_string (buffer, s1);\n-\t\t\tpp_dot (buffer);\n-\t\t\tfree (s1);\n-\t\t      }\n-\t\t    break;\n-\t\t  default:\n-\t\t    break;\n-\t\t}\n+\t      case ENUMERAL_TYPE:\n+\t      case INTEGER_TYPE:\n+\t      case REAL_TYPE:\n+\t      case FIXED_POINT_TYPE:\n+\t      case BOOLEAN_TYPE:\n+\t      case REFERENCE_TYPE:\n+\t      case POINTER_TYPE:\n+\t      case ARRAY_TYPE:\n+\t      case RECORD_TYPE:\n+\t      case UNION_TYPE:\n+\t      case TYPE_DECL:\n+\t\tif (package_prefix)\n+\t\t  {\n+\t\t    char *s1 = get_ada_package (xloc.file);\n+\t\t    append_withs (s1, limited_access);\n+\t\t    pp_string (buffer, s1);\n+\t\t    pp_dot (buffer);\n+\t\t    free (s1);\n+\t\t  }\n+\t\tbreak;\n+\t      default:\n+\t\tbreak;\n+\t    }\n \n-\t      /* Generate the additional package prefix for C++ classes.  */\n-\t      if (separate_class_package (decl))\n-\t\t{\n-\t\t  pp_string (buffer, \"Class_\");\n-\t\t  pp_string (buffer, s);\n-\t\t  pp_dot (buffer);\n-\t\t}\n-\t     }\n+\t  /* Generate the additional package prefix for C++ classes.  */\n+\t  if (separate_class_package (decl))\n+\t    {\n+\t      pp_string (buffer, \"Class_\");\n+\t      pp_string (buffer, s);\n+\t      pp_dot (buffer);\n+\t    }\n \t}\n     }\n \n@@ -2220,6 +2217,24 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t{\n \t\t  tree type_name = TYPE_NAME (TREE_TYPE (node));\n \n+\t\t  /* Generate \"access <type>\" instead of \"access <subtype>\"\n+\t\t     if the subtype comes from another file, because subtype\n+\t\t     declarations do not contribute to the limited view of a\n+\t\t     package and thus subtypes cannot be referenced through\n+\t\t     a limited_with clause.  */\n+\t\t  if (type_name\n+\t\t      && TREE_CODE (type_name) == TYPE_DECL\n+\t\t      && DECL_ORIGINAL_TYPE (type_name)\n+\t\t      && TYPE_NAME (DECL_ORIGINAL_TYPE (type_name)))\n+\t\t    {\n+\t\t      const expanded_location xloc\n+\t\t\t= expand_location (decl_sloc (type_name, false));\n+\t\t      if (xloc.line\n+\t\t\t  && xloc.file\n+\t\t\t  && xloc.file != current_source_file)\n+\t\t\ttype_name = DECL_ORIGINAL_TYPE (type_name);\n+\t\t    }\n+\n \t\t  /* For now, handle access-to-access as System.Address.  */\n \t\t  if (TREE_CODE (TREE_TYPE (node)) == POINTER_TYPE)\n \t\t    {\n@@ -2241,8 +2256,8 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t    {\n \t\t      if (!type || TREE_CODE (type) != FUNCTION_DECL)\n \t\t\t{\n-\t\t\t  pp_string (buffer, \"access \");\n \t\t\t  is_access = true;\n+\t\t\t  pp_string (buffer, \"access \");\n \n \t\t\t  if (quals & TYPE_QUAL_CONST)\n \t\t\t    pp_string (buffer, \"constant \");"}]}