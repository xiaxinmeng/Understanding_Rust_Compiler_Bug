{"sha": "43bfd4e87b540e883e8fd301669dcb75b6c12010", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNiZmQ0ZTg3YjU0MGU4ODNlOGZkMzAxNjY5ZGNiNzViNmMxMjAxMA==", "commit": {"author": {"name": "Jozef Lawrynowicz", "email": "jozef.l@mittosystems.com", "date": "2019-08-15T12:59:04Z"}, "committer": {"name": "Jozef Lawrynowicz", "email": "jozefl@gcc.gnu.org", "date": "2019-08-15T12:59:04Z"}, "message": "MSP430: Fix lines over 80 characters long in config/msp430/*.{c,h} files\n\n2019-08-15  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n\n\tMSP430: Fix lines over 80 characters long in\n\tconfig/msp430/*.{c,h} files\n\n\t* config/msp430/driver-msp430.c (msp430_select_cpu): Fix format\n\tspecifier in string.\n\t(msp430_select_hwmult_lib): Split line more than 80 characters long.\n\t* config/msp430/msp430-devices.c (msp430_extract_mcu_data): Remove\n\tredundant old comment.\n\t* config/msp430/msp430-protos.h (msp430_output_aligned_decl_common):\n\tSplit line more than 80 characters long.\n\t* config/msp430/msp430.c (msp430_option_override): Likewise.\n\t(msp430_return_in_memory): Likewise.\n\t(msp430_gimplify_va_arg_expr): Likewise.\n\t(TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P): Likewise.\n\t(msp430_legitimate_constant): Likewise.\n\t(TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS): Likewise.\n\t(msp430_attr): Likewise.\n\t(msp430_data_attr): Likewise.\n\t(msp430_start_function): Likewise.\n\t(gen_prefix): Likewise.\n\t(msp430_init_sections): Likewise.\n\t(msp430_select_section): Likewise.\n\t(msp430_function_section): Likewise.\n\t(msp430_unique_section): Likewise.\n\t(msp430_output_aligned_decl_common): Likewise.\n\t(msp430_do_not_relax_short_jumps): Likewise.\n\t(msp430_init_builtins): Likewise.\n\t(msp430_expand_delay_cycles): Likewise.\n\t(msp430_expand_prologue): Likewise.\n\t(msp430_expand_epilogue): Likewise.\n\t(msp430_expand_helper): Likewise.\n\t(msp430_split_movsi): Likewise.\n\t(msp430_print_operand): Likewise.\n\t(msp430_return_addr_rtx): Likewise.\n\t(msp430x_extendhisi): Likewise.\n\t* config/msp430/msp430.h (STARTFILE_SPEC): Likewise.\n\t(ASM_SPEC): Likewise.\n\tRemove very obvious comments.\n\t(LIB_SPEC): Split line more than 80 characters long.\n\t(EH_RETURN_HANDLER_RTX): Likewise.\n\t(HARD_REGNO_CALLER_SAVE_MODE): Likewise.\n\nFrom-SVN: r274537", "tree": {"sha": "2f445833674c2e3d274f1ccba98fdd3b17155314", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f445833674c2e3d274f1ccba98fdd3b17155314"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43bfd4e87b540e883e8fd301669dcb75b6c12010", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43bfd4e87b540e883e8fd301669dcb75b6c12010", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43bfd4e87b540e883e8fd301669dcb75b6c12010", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43bfd4e87b540e883e8fd301669dcb75b6c12010/comments", "author": {"login": "jozefl-mitto", "id": 36524004, "node_id": "MDQ6VXNlcjM2NTI0MDA0", "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jozefl-mitto", "html_url": "https://github.com/jozefl-mitto", "followers_url": "https://api.github.com/users/jozefl-mitto/followers", "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}", "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}", "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions", "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs", "repos_url": "https://api.github.com/users/jozefl-mitto/repos", "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}", "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "81a8845cc0797ed494d6c138049bb015a29ed5d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81a8845cc0797ed494d6c138049bb015a29ed5d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81a8845cc0797ed494d6c138049bb015a29ed5d4"}], "stats": {"total": 278, "additions": 196, "deletions": 82}, "files": [{"sha": "ce0bb0c18990b15a71b7fcad5f148640c9e1b074", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43bfd4e87b540e883e8fd301669dcb75b6c12010/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43bfd4e87b540e883e8fd301669dcb75b6c12010/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43bfd4e87b540e883e8fd301669dcb75b6c12010", "patch": "@@ -1,3 +1,47 @@\n+2019-08-15  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n+\n+\tMSP430: Fix lines over 80 characters long in\n+\tconfig/msp430/*.{c,h} files\n+\n+\t* config/msp430/driver-msp430.c (msp430_select_cpu): Fix format\n+\tspecifier in string.\n+\t(msp430_select_hwmult_lib): Split line more than 80 characters long.\n+\t* config/msp430/msp430-devices.c (msp430_extract_mcu_data): Remove\n+\tredundant old comment.\n+\t* config/msp430/msp430-protos.h (msp430_output_aligned_decl_common):\n+\tSplit line more than 80 characters long.\n+\t* config/msp430/msp430.c (msp430_option_override): Likewise.\n+\t(msp430_return_in_memory): Likewise.\n+\t(msp430_gimplify_va_arg_expr): Likewise.\n+\t(TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P): Likewise.\n+\t(msp430_legitimate_constant): Likewise.\n+\t(TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS): Likewise.\n+\t(msp430_attr): Likewise.\n+\t(msp430_data_attr): Likewise.\n+\t(msp430_start_function): Likewise.\n+\t(gen_prefix): Likewise.\n+\t(msp430_init_sections): Likewise.\n+\t(msp430_select_section): Likewise.\n+\t(msp430_function_section): Likewise.\n+\t(msp430_unique_section): Likewise.\n+\t(msp430_output_aligned_decl_common): Likewise.\n+\t(msp430_do_not_relax_short_jumps): Likewise.\n+\t(msp430_init_builtins): Likewise.\n+\t(msp430_expand_delay_cycles): Likewise.\n+\t(msp430_expand_prologue): Likewise.\n+\t(msp430_expand_epilogue): Likewise.\n+\t(msp430_expand_helper): Likewise.\n+\t(msp430_split_movsi): Likewise.\n+\t(msp430_print_operand): Likewise.\n+\t(msp430_return_addr_rtx): Likewise.\n+\t(msp430x_extendhisi): Likewise.\n+\t* config/msp430/msp430.h (STARTFILE_SPEC): Likewise.\n+\t(ASM_SPEC): Likewise.\n+\tRemove very obvious comments.\n+\t(LIB_SPEC): Split line more than 80 characters long.\n+\t(EH_RETURN_HANDLER_RTX): Likewise.\n+\t(HARD_REGNO_CALLER_SAVE_MODE): Likewise.\n+\n 2019-08-15  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \tMSP430: Fix whitespace errors and incorrect indentation in"}, {"sha": "0a3d1e14c0a6d05077cafd276a572f2d516b7e58", "filename": "gcc/config/msp430/driver-msp430.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43bfd4e87b540e883e8fd301669dcb75b6c12010/gcc%2Fconfig%2Fmsp430%2Fdriver-msp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43bfd4e87b540e883e8fd301669dcb75b6c12010/gcc%2Fconfig%2Fmsp430%2Fdriver-msp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fdriver-msp430.c?ref=43bfd4e87b540e883e8fd301669dcb75b6c12010", "patch": "@@ -35,7 +35,7 @@ msp430_select_cpu (int argc, const char ** argv)\n {\n   if (argc == 0)\n     {\n-      error (\"expected an argument to %<msp430_select_cpu>%\");\n+      error (\"expected an argument to %<msp430_select_cpu%>\");\n       return NULL;\n     }\n   msp430_extract_mcu_data (argv[0]);\n@@ -80,7 +80,8 @@ msp430_set_driver_var (int argc, const char ** argv)\n /* Implement spec function `msp430_hwmult_lib\u00b4.  */\n \n const char *\n-msp430_select_hwmult_lib (int argc ATTRIBUTE_UNUSED, const char ** argv ATTRIBUTE_UNUSED)\n+msp430_select_hwmult_lib (int argc ATTRIBUTE_UNUSED,\n+\t\t\t  const char ** argv ATTRIBUTE_UNUSED)\n {\n   int i;\n \n@@ -137,7 +138,8 @@ msp430_select_hwmult_lib (int argc ATTRIBUTE_UNUSED, const char ** argv ATTRIBUT\n \t    }\n \t}\n       else\n-\terror (\"unexpected first argument to msp430_select_hwmult_lib: %s\", argv[0]);\n+\terror (\"unexpected first argument to msp430_select_hwmult_lib: %s\",\n+\t       argv[0]);\n       break;\n \n     case 0:"}, {"sha": "537d438ea3b60b33eb982e5ff9c93c82f0bb774a", "filename": "gcc/config/msp430/msp430-devices.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43bfd4e87b540e883e8fd301669dcb75b6c12010/gcc%2Fconfig%2Fmsp430%2Fmsp430-devices.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43bfd4e87b540e883e8fd301669dcb75b6c12010/gcc%2Fconfig%2Fmsp430%2Fmsp430-devices.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430-devices.c?ref=43bfd4e87b540e883e8fd301669dcb75b6c12010", "patch": "@@ -311,7 +311,6 @@ msp430_extract_mcu_data (const char * mcu_name)\n     default:\n       gcc_unreachable ();\n     }\n-  /* FIXME: This array is alpha sorted - we could use a binary search.  */\n   for (i = ARRAY_SIZE (hard_msp430_mcu_data); i--;)\n     if (strcasecmp (mcu_name, hard_msp430_mcu_data[i].name) == 0)\n       {"}, {"sha": "267b6f59471da07dfb1e066c92bbcfaead9034d2", "filename": "gcc/config/msp430/msp430-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43bfd4e87b540e883e8fd301669dcb75b6c12010/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43bfd4e87b540e883e8fd301669dcb75b6c12010/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h?ref=43bfd4e87b540e883e8fd301669dcb75b6c12010", "patch": "@@ -38,7 +38,8 @@ int\tmsp430_initial_elimination_offset (int, int);\n bool    msp430_is_interrupt_func (void);\n const char * msp430x_logical_shift_right (rtx);\n const char * msp430_mcu_name (void);\n-void    msp430_output_aligned_decl_common (FILE *, const tree, const char *, unsigned HOST_WIDE_INT, unsigned);\n+void    msp430_output_aligned_decl_common (FILE *, const tree, const char *,\n+\t\t\t\t\t   unsigned HOST_WIDE_INT, unsigned);\n void\tmsp430_output_labelref (FILE *, const char *);\n void\tmsp430_register_pragmas (void);\n rtx\tmsp430_return_addr_rtx (int);"}, {"sha": "fedbdf52c5c3e1fb26b62b46bc72702af2c02eb0", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 126, "deletions": 66, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43bfd4e87b540e883e8fd301669dcb75b6c12010/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43bfd4e87b540e883e8fd301669dcb75b6c12010/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=43bfd4e87b540e883e8fd301669dcb75b6c12010", "patch": "@@ -97,7 +97,8 @@ msp430_init_machine_status (void)\n #define TARGET_OPTION_OVERRIDE\t\tmsp430_option_override\n \n /* Generate a C preprocessor symbol based upon the MCU selected by the user.\n-   If a specific MCU has not been selected then return a generic symbol instead.  */\n+   If a specific MCU has not been selected then return a generic symbol\n+   instead.  */\n \n const char *\n msp430_mcu_name (void)\n@@ -178,7 +179,8 @@ msp430_option_override (void)\n \t      if (target_cpu && msp430x != xisa)\n \t\twarning (0, \"MCU %qs supports %s ISA but %<-mcpu%> option \"\n \t\t\t \"is set to %s\",\n-\t\t\t target_mcu, xisa ? \"430X\" : \"430\", msp430x ? \"430X\" : \"430\");\n+\t\t\t target_mcu, xisa ? \"430X\" : \"430\",\n+\t\t\t msp430x ? \"430X\" : \"430\");\n \n \t      if (extracted_mcu_data.hwmpy == 0\n \t\t  && msp430_hwmult_type != MSP430_HWMULT_AUTO\n@@ -187,7 +189,8 @@ msp430_option_override (void)\n \t\t\t \"support, but %<-mhwmult%> is set to %s\",\n \t\t\t target_mcu,\n \t\t\t msp430_hwmult_type == MSP430_HWMULT_SMALL ? \"16-bit\"\n-\t\t\t : msp430_hwmult_type == MSP430_HWMULT_LARGE ? \"32-bit\" : \"f5series\");\n+\t\t\t : msp430_hwmult_type == MSP430_HWMULT_LARGE\n+\t\t\t ? \"32-bit\" : \"f5series\");\n \t      else if (msp430_hwmult_type == MSP430_HWMULT_SMALL\n \t\t       && extracted_mcu_data.hwmpy != 1\n \t\t       && extracted_mcu_data.hwmpy != 2)\n@@ -247,7 +250,8 @@ msp430_option_override (void)\n     }\n \n   /* The F5 series are all able to support the 430X ISA.  */\n-  if (target_cpu == NULL && target_mcu == NULL && msp430_hwmult_type == MSP430_HWMULT_F5SERIES)\n+  if (target_cpu == NULL && target_mcu == NULL\n+      && msp430_hwmult_type == MSP430_HWMULT_F5SERIES)\n     msp430x = true;\n \n   if (TARGET_LARGE && !msp430x)\n@@ -804,7 +808,8 @@ msp430_function_arg_boundary (machine_mode mode, const_tree type)\n #define TARGET_RETURN_IN_MEMORY msp430_return_in_memory\n \n static bool\n-msp430_return_in_memory (const_tree ret_type, const_tree fntype ATTRIBUTE_UNUSED)\n+msp430_return_in_memory (const_tree ret_type,\n+\t\t\t const_tree fntype ATTRIBUTE_UNUSED)\n {\n   machine_mode mode = TYPE_MODE (ret_type);\n \n@@ -886,7 +891,8 @@ msp430_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n \t  t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist_tmp,\n \t\t      fold_build2 (BIT_AND_EXPR, TREE_TYPE (valist),\n \t\t\t\t   valist_tmp,\n-\t\t\t\t   build_int_cst (TREE_TYPE (valist), -boundary)));\n+\t\t\t\t   build_int_cst (TREE_TYPE (valist),\n+\t\t\t\t\t\t  -boundary)));\n \t  gimplify_and_add (t, pre_p);\n \t}\n     }\n@@ -994,7 +1000,8 @@ msp430_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,\n }\n \n #undef  TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P\n-#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P msp430_addr_space_legitimate_address_p\n+#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P \\\n+  msp430_addr_space_legitimate_address_p\n \n bool\n msp430_addr_space_legitimate_address_p (machine_mode mode,\n@@ -1051,7 +1058,8 @@ msp430_legitimate_constant (machine_mode mode, rtx x)\n     /* GCC does not know the width of the PSImode, so make\n        sure that it does not try to use a constant value that\n        is out of range.  */\n-    || (INTVAL (x) < (1 << 20) && INTVAL (x) >= (HOST_WIDE_INT)(HOST_WIDE_INT_M1U << 20));\n+    || (INTVAL (x) < (1 << 20)\n+\t&& INTVAL (x) >= (HOST_WIDE_INT)(HOST_WIDE_INT_M1U << 20));\n }\n \n \f\n@@ -1268,7 +1276,8 @@ has_section_name (const char * name, tree decl = current_function_decl)\n }\n \n #undef  TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS\n-#define TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS\tmsp430_allocate_stack_slots_for_args\n+#define TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS \\\n+  msp430_allocate_stack_slots_for_args\n \n static bool\n msp430_allocate_stack_slots_for_args (void)\n@@ -1329,8 +1338,8 @@ msp430_attr (tree * node,\n \n \tdefault:\n \t  warning (OPT_Wattributes,\n-\t\t   \"argument of %qE attribute is not a string constant or number\",\n-\t\t   name);\n+\t\t   \"argument of %qE attribute is not a string constant \"\n+\t\t   \"or number\", name);\n \t  *no_add_attrs = true;\n \t  break;\n \t}\n@@ -1470,7 +1479,8 @@ msp430_data_attr (tree * node,\n   /* Check that it's possible for the variable to have a section.  */\n   if ((TREE_STATIC (* node) || DECL_EXTERNAL (* node) || in_lto_p)\n       && DECL_SECTION_NAME (* node))\n-    message = G_(\"%qE attribute cannot be applied to variables with specific sections\");\n+    message = G_(\"%qE attribute cannot be applied to variables with specific \"\n+\t\t \"sections\");\n \n   if (!message && TREE_NAME_EQ (name, ATTR_PERSIST) && !TREE_STATIC (* node)\n       && !TREE_PUBLIC (* node) && !DECL_EXTERNAL (* node))\n@@ -1485,7 +1495,8 @@ msp430_data_attr (tree * node,\n     set_decl_section_name (* node, \".persistent\");\n \n   /* If this var is thought to be common, then change this.  Common variables\n-     are assigned to sections before the backend has a chance to process them.  */\n+     are assigned to sections before the backend has a chance to process\n+     them.  */\n   if (DECL_COMMON (* node))\n     DECL_COMMON (* node) = 0;\n \n@@ -1552,12 +1563,19 @@ msp430_start_function (FILE *outfile)\n       fprintf (outfile, \"\\n\");\n     }\n \n-  fprintf (outfile, \"; framesize_regs:     %d\\n\", cfun->machine->framesize_regs);\n-  fprintf (outfile, \"; framesize_locals:   %d\\n\", cfun->machine->framesize_locals);\n-  fprintf (outfile, \"; framesize_outgoing: %d\\n\", cfun->machine->framesize_outgoing);\n+  fprintf (outfile, \"; framesize_regs:     %d\\n\",\n+\t   cfun->machine->framesize_regs);\n+  fprintf (outfile, \"; framesize_locals:   %d\\n\",\n+\t   cfun->machine->framesize_locals);\n+  fprintf (outfile, \"; framesize_outgoing: %d\\n\",\n+\t   cfun->machine->framesize_outgoing);\n   fprintf (outfile, \"; framesize:          %d\\n\", cfun->machine->framesize);\n-  fprintf (outfile, \"; elim ap -> fp       %d\\n\", msp430_initial_elimination_offset (ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM));\n-  fprintf (outfile, \"; elim fp -> sp       %d\\n\", msp430_initial_elimination_offset (FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM));\n+  fprintf (outfile, \"; elim ap -> fp       %d\\n\",\n+\t   msp430_initial_elimination_offset (ARG_POINTER_REGNUM,\n+\t\t\t\t\t      FRAME_POINTER_REGNUM));\n+  fprintf (outfile, \"; elim fp -> sp       %d\\n\",\n+\t   msp430_initial_elimination_offset (FRAME_POINTER_REGNUM,\n+\t\t\t\t\t      STACK_POINTER_REGNUM));\n \n   n = 0;\n   fprintf (outfile, \"; saved regs:\");\n@@ -1618,7 +1636,8 @@ msp430_start_function (FILE *file, const char *name, tree decl)\n \t     functions implies multiple definitions.  */\n \t  if (DECL_WEAK (decl))\n \t    {\n-\t      error (\"argument to interrupt attribute is unsupported for weak functions\");\n+\t      error (\"argument to interrupt attribute is unsupported for weak \"\n+\t\t     \"functions\");\n \t    }\n \n \t  intr_vector = TREE_VALUE (intr_vector);\n@@ -1660,7 +1679,8 @@ gen_prefix (tree decl)\n   if (DECL_ONE_ONLY (decl))\n     return NULL;\n \n-  /* If the user has specified a particular section then do not use any prefix.  */\n+  /* If the user has specified a particular section then do not use any\n+     prefix.  */\n   if (has_attr (\"section\", decl))\n     return NULL;\n \n@@ -1674,7 +1694,8 @@ gen_prefix (tree decl)\n   if (has_attr (ATTR_LOWER, decl))\n     return lower_prefix;\n \n-  /* If we are compiling for the MSP430 then we do not support the upper region.  */\n+  /* If we are compiling for the MSP430 then we do not support the upper\n+     region.  */\n   if (! msp430x)\n     return NULL;\n \n@@ -1719,8 +1740,10 @@ static section * persist_section;\n static void\n msp430_init_sections (void)\n {\n-  noinit_section = get_unnamed_section (0, output_section_asm_op, \".section .noinit,\\\"aw\\\"\");\n-  persist_section = get_unnamed_section (0, output_section_asm_op, \".section .persistent,\\\"aw\\\"\");\n+  noinit_section = get_unnamed_section (0, output_section_asm_op,\n+\t\t\t\t\t\".section .noinit,\\\"aw\\\"\");\n+  persist_section = get_unnamed_section (0, output_section_asm_op,\n+\t\t\t\t\t \".section .persistent,\\\"aw\\\"\");\n }\n \n #undef  TARGET_ASM_SELECT_SECTION\n@@ -1740,7 +1763,8 @@ msp430_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align)\n \n   /* In large mode we must make sure that interrupt handlers are put into\n      low memory as the vector table only accepts 16-bit addresses.  */\n-  if (TARGET_LARGE && TREE_CODE (decl) == FUNCTION_DECL && is_interrupt_func (decl))\n+  if (TARGET_LARGE && TREE_CODE (decl) == FUNCTION_DECL\n+      && is_interrupt_func (decl))\n     return get_section (\".lowtext\", SECTION_CODE | SECTION_WRITE , decl);\n \n   const char * prefix = gen_prefix (decl);\n@@ -1794,7 +1818,8 @@ msp430_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align)\n #define TARGET_ASM_FUNCTION_SECTION msp430_function_section\n \n static section *\n-msp430_function_section (tree decl, enum node_frequency freq, bool startup, bool exit)\n+msp430_function_section (tree decl, enum node_frequency freq, bool startup,\n+\t\t\t bool exit)\n {\n   const char * name;\n \n@@ -1840,7 +1865,8 @@ msp430_unique_section (tree decl, int reloc)\n \n   /* In large mode we must make sure that interrupt handlers are put into\n      low memory as the vector table only accepts 16-bit addresses.  */\n-  if (TARGET_LARGE && TREE_CODE (decl) == FUNCTION_DECL && is_interrupt_func (decl))\n+  if (TARGET_LARGE && TREE_CODE (decl) == FUNCTION_DECL\n+      && is_interrupt_func (decl))\n     {\n       set_decl_section_name (decl, \".lowtext\");\n       return;\n@@ -1891,9 +1917,15 @@ msp430_output_aligned_decl_common (FILE *\t\t  stream,\n       else\n \tswitch (msp430_data_region)\n \t  {\n-\t  case MSP430_REGION_UPPER: sec = get_named_section (NULL, \".upper.bss\", 0); break;\n-\t  case MSP430_REGION_LOWER: sec = get_named_section (NULL, \".lower.bss\", 0); break;\n-\t  case MSP430_REGION_EITHER: sec = get_named_section (NULL, \".either.bss\", 0); break;\n+\t  case MSP430_REGION_UPPER:\n+\t    sec = get_named_section (NULL, \".upper.bss\", 0);\n+\t    break;\n+\t  case MSP430_REGION_LOWER:\n+\t    sec = get_named_section (NULL, \".lower.bss\", 0);\n+\t    break;\n+\t  case MSP430_REGION_EITHER:\n+\t    sec = get_named_section (NULL, \".either.bss\", 0);\n+\t    break;\n \t  default:\n \t    gcc_unreachable ();\n \t  }\n@@ -1911,11 +1943,11 @@ msp430_output_aligned_decl_common (FILE *\t\t  stream,\n bool\n msp430_do_not_relax_short_jumps (void)\n {\n-  /* When placing code into \"either\" low or high memory we do not want the linker\n-     to grow the size of sections, which it can do if it is encounters a branch to\n-     a label that is too far away.  So we tell the cbranch patterns to avoid using\n-     short jumps when there is a chance that the instructions will end up in a low\n-     section.  */\n+  /* When placing code into \"either\" low or high memory we do not want the\n+     linker to grow the size of sections, which it can do if it is encounters a\n+     branch to a label that is too far away.  So we tell the cbranch patterns to\n+     avoid using short jumps when there is a chance that the instructions will\n+     end up in a low section.  */\n   return\n     msp430_code_region == MSP430_REGION_EITHER\n     || msp430_code_region == MSP430_REGION_LOWER\n@@ -1936,8 +1968,11 @@ static GTY(()) tree msp430_builtins[(int) MSP430_BUILTIN_max];\n static void\n msp430_init_builtins (void)\n {\n-  tree void_ftype_int = build_function_type_list (void_type_node, integer_type_node, NULL);\n-  tree void_ftype_longlong = build_function_type_list (void_type_node, long_long_integer_type_node, NULL);\n+  tree void_ftype_int = build_function_type_list (void_type_node,\n+\t\t\t\t\t\t  integer_type_node, NULL);\n+  tree void_ftype_longlong\n+    = build_function_type_list (void_type_node, long_long_integer_type_node,\n+\t\t\t\tNULL);\n \n   msp430_builtins[MSP430_BUILTIN_BIC_SR] =\n     add_builtin_function ( \"__bic_SR_register_on_exit\", void_ftype_int,\n@@ -1949,7 +1984,8 @@ msp430_init_builtins (void)\n \n   msp430_builtins[MSP430_BUILTIN_DELAY_CYCLES] =\n     add_builtin_function ( \"__delay_cycles\", void_ftype_longlong,\n-\t\t\t  MSP430_BUILTIN_DELAY_CYCLES, BUILT_IN_MD, NULL, NULL_TREE);\n+\t\t\t  MSP430_BUILTIN_DELAY_CYCLES, BUILT_IN_MD, NULL,\n+\t\t\t  NULL_TREE);\n }\n \n static tree\n@@ -2016,7 +2052,8 @@ msp430_expand_delay_cycles (rtx arg)\n   if (c > 3 * 0xffff + CYCX (7, 10))\n     {\n       n = c;\n-      /* There's 4 cycles in the short (i>0xffff) loop and 7 in the long (x<=0xffff) loop */\n+      /* There's 4 cycles in the short (i>0xffff) loop and 7 in the long\n+\t (x<=0xffff) loop.  */\n       if (c >= 0x10000 * 7 + CYCX (14, 16))\n \t{\n \t  i = 0x10000;\n@@ -2046,7 +2083,8 @@ msp430_expand_delay_cycles (rtx arg)\n \temit_insn (gen_delay_cycles_32 (GEN_INT (i), GEN_INT (n - c)));\n     }\n \n-  /* For 16-bit loops, there's 7(10) + 3x cycles - so the max cycles is 0x30004(7).  */\n+  /* For 16-bit loops, there's 7(10) + 3x cycles - so the max cycles is\n+     0x30004(7).  */\n   if (c > 12)\n     {\n       n = c;\n@@ -2168,7 +2206,8 @@ msp430_expand_prologue (void)\n \n       /* Document the stack decrement...  */\n       note = F (gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t     gen_rtx_MINUS (Pmode, stack_pointer_rtx, GEN_INT (2))));\n+\t\t\t     gen_rtx_MINUS (Pmode,\n+\t\t\t\t\t    stack_pointer_rtx, GEN_INT (2))));\n       add_reg_note (p, REG_FRAME_RELATED_EXPR, note);\n \n       /* ...and the establishment of a new location for the return address.  */\n@@ -2193,7 +2232,8 @@ msp430_expand_prologue (void)\n \n \tif (msp430x)\n \t  {\n-\t    /* Note: with TARGET_LARGE we still use PUSHM as PUSHX.A is two bytes bigger.  */\n+\t    /* Note: with TARGET_LARGE we still use PUSHM as PUSHX.A is two\n+\t       bytes bigger.  */\n \t    p = F (emit_insn (gen_pushm (gen_rtx_REG (Pmode, i),\n \t\t\t\t\t GEN_INT (count))));\n \n@@ -2203,7 +2243,8 @@ msp430_expand_prologue (void)\n \t      = F (gen_rtx_SET (stack_pointer_rtx,\n \t\t\t\tgen_rtx_PLUS (Pmode,\n \t\t\t\t\t      stack_pointer_rtx,\n-\t\t\t\t\t      GEN_INT (count * (TARGET_LARGE ? -4 : -2)))));\n+\t\t\t\t\t      GEN_INT (count * (TARGET_LARGE\n+\t\t\t\t\t\t\t\t? -4 : -2)))));\n \n \t    /* *sp-- = R[i-j] */\n \t    /* sp+N\tR10\n@@ -2276,7 +2317,8 @@ msp430_expand_epilogue (int is_eh)\n \n   emit_insn (gen_epilogue_start_marker ());\n \n-  if (cfun->decl && strcmp (IDENTIFIER_POINTER (DECL_NAME (cfun->decl)), \"main\") == 0)\n+  if (cfun->decl && strcmp (IDENTIFIER_POINTER (DECL_NAME (cfun->decl)),\n+\t\t\t    \"main\") == 0)\n     emit_insn (gen_msp430_refsym_need_exit ());\n \n   if (is_wakeup_func ())\n@@ -2305,7 +2347,9 @@ msp430_expand_epilogue (int is_eh)\n       emit_move_insn (r12, stack_pointer_rtx);\n       emit_insn (addPmode (r12, r12, EH_RETURN_STACKADJ_RTX));\n       emit_insn (addPmode (r12, r12, GEN_INT (i)));\n-      emit_move_insn (gen_rtx_MEM (Pmode, plus_constant (Pmode, stack_pointer_rtx, i)), r12);\n+      emit_move_insn (gen_rtx_MEM (Pmode, plus_constant (Pmode,\n+\t\t\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t\t\t i)), r12);\n     }\n \n   for (i = 4; i <= 15; i++)\n@@ -2330,7 +2374,8 @@ msp430_expand_epilogue (int is_eh)\n \t\t && ! is_reentrant_func ()\n \t\t && ! is_critical_func ()\n \t\t && crtl->args.pretend_args_size == 0\n-\t\t /* Calling the helper takes as many bytes as the POP;RET sequence.  */\n+\t\t /* Calling the helper takes as many bytes as the POP;RET\n+\t\t    sequence.  */\n \t\t && helper_n > 1\n \t\t && !is_eh)\n \t  {\n@@ -2346,7 +2391,8 @@ msp430_expand_epilogue (int is_eh)\n       /* Also pop SP, which puts us into the EH return frame.  Except\n \t that you can't \"pop\" sp, you have to just load it off the\n \t stack.  */\n-      emit_move_insn (stack_pointer_rtx, gen_rtx_MEM (Pmode, stack_pointer_rtx));\n+      emit_move_insn (stack_pointer_rtx, gen_rtx_MEM (Pmode,\n+\t\t\t\t\t\t      stack_pointer_rtx));\n     }\n \n   if (crtl->args.pretend_args_size)\n@@ -2453,7 +2499,8 @@ const_shift_helpers[] =\n    emit such a function, using the table above to optimize some\n    cases.  */\n void\n-msp430_expand_helper (rtx *operands, const char *helper_name, bool const_variants)\n+msp430_expand_helper (rtx *operands, const char *helper_name,\n+\t\t      bool const_variants)\n {\n   rtx c, f;\n   char *helper_const = NULL;\n@@ -2475,7 +2522,8 @@ msp430_expand_helper (rtx *operands, const char *helper_name, bool const_variant\n \t      && strcmp (helper_name, const_shift_helpers[i].name) == 0\n \t      && INTVAL (operands[2]) == const_shift_helpers[i].count)\n \t    {\n-\t      emit_insn (const_shift_helpers[i].genfunc (operands[0], operands[1]));\n+\t      emit_insn (const_shift_helpers[i].genfunc (operands[0],\n+\t\t\t\t\t\t\t operands[1]));\n \t      return;\n \t    }\n \t}\n@@ -2504,10 +2552,12 @@ msp430_expand_helper (rtx *operands, const char *helper_name, bool const_variant\n       && INTVAL (operands[2]) >= 1\n       && INTVAL (operands[2]) <= 15)\n     {\n-      /* Note that the INTVAL is limited in value and length by the conditional above.  */\n+      /* Note that the INTVAL is limited in value and length by the conditional\n+\t above.  */\n       int len = strlen (helper_name) + 4;\n       helper_const = (char *) xmalloc (len);\n-      snprintf (helper_const, len, \"%s_%d\", helper_name, (int) INTVAL (operands[2]));\n+      snprintf (helper_const, len, \"%s_%d\", helper_name,\n+\t\t(int) INTVAL (operands[2]));\n     }\n \n   emit_move_insn (gen_rtx_REG (arg1mode, arg1),\n@@ -2517,7 +2567,9 @@ msp430_expand_helper (rtx *operands, const char *helper_name, bool const_variant\n \t\t    operands[2]);\n \n   c = gen_call_value_internal (gen_rtx_REG (arg0mode, 12),\n-\t\t\t       gen_rtx_SYMBOL_REF (VOIDmode, helper_const ? helper_const : helper_name),\n+\t\t\t       gen_rtx_SYMBOL_REF (VOIDmode, helper_const\n+\t\t\t\t\t\t   ? helper_const\n+\t\t\t\t\t\t   : helper_name),\n \t\t\t       GEN_INT (0));\n   c = emit_call_insn (c);\n   RTL_CONST_CALL_P (c) = 1;\n@@ -2600,9 +2652,11 @@ msp430_split_movsi (rtx *operands)\n   if (GET_CODE (operands[1]) == CONST\n       || GET_CODE (operands[1]) == SYMBOL_REF)\n     {\n-      op10 = gen_rtx_ZERO_EXTRACT (HImode, operands[1], GEN_INT (16), GEN_INT (0));\n+      op10 = gen_rtx_ZERO_EXTRACT (HImode, operands[1], GEN_INT (16),\n+\t\t\t\t   GEN_INT (0));\n       op10 = gen_rtx_CONST (HImode, op10);\n-      op12 = gen_rtx_ZERO_EXTRACT (HImode, operands[1], GEN_INT (16), GEN_INT (16));\n+      op12 = gen_rtx_ZERO_EXTRACT (HImode, operands[1], GEN_INT (16),\n+\t\t\t\t   GEN_INT (16));\n       op12 = gen_rtx_CONST (HImode, op12);\n     }\n   else\n@@ -2698,8 +2752,10 @@ helper_function_name_mappings[] =\n     { \"__muldi3\", \"__mspabi_mpyll\" },\n #if 0\n     /* Clarify signed vs unsigned first.  */\n-    { \"__mulhisi3\", \"__mspabi_mpysl\" }, /* gcc doesn't use widening multiply (yet?) */\n-    { \"__mulsidi3\", \"__mspabi_mpysll\" }, /* gcc doesn't use widening multiply (yet?) */\n+    { \"__mulhisi3\", \"__mspabi_mpysl\" }, /* gcc doesn't use widening multiply\n+\t\t\t\t\t   (yet?) */\n+    { \"__mulsidi3\", \"__mspabi_mpysll\" }, /* gcc doesn't use widening multiply\n+\t\t\t\t\t    (yet?) */\n #endif\n \n     { \"__divhi3\", \"__mspabi_divi\" },\n@@ -3130,9 +3186,11 @@ msp430_print_operand (FILE * file, rtx op, int letter)\n     case 'O':\n       /* Computes the offset to the top of the stack for the current frame.\n \t This has to be done here rather than in, say, msp430_expand_builtin()\n-\t because builtins are expanded before the frame layout is determined.  */\n+\t because builtins are expanded before the frame layout is\n+\t determined.  */\n       fprintf (file, \"%d\",\n-\t       msp430_initial_elimination_offset (ARG_POINTER_REGNUM, STACK_POINTER_REGNUM)\n+\t       msp430_initial_elimination_offset (ARG_POINTER_REGNUM,\n+\t\t\t\t\t\t  STACK_POINTER_REGNUM)\n \t       - (TARGET_LARGE ? 4 : 2));\n       return;\n \n@@ -3216,7 +3274,8 @@ msp430_return_addr_rtx (int count)\n   if (crtl->args.pretend_args_size)\n     ra_size += 2;\n \n-  return gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, arg_pointer_rtx, GEN_INT (- ra_size)));\n+  return gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, arg_pointer_rtx,\n+\t\t\t\t\t   GEN_INT (- ra_size)));\n }\n \n rtx\n@@ -3235,8 +3294,8 @@ const char *\n msp430x_extendhisi (rtx * operands)\n {\n   if (REGNO (operands[0]) == REGNO (operands[1]))\n-    /* Low word of dest == source word.  */\n-    return \"BIT.W\\t#0x8000, %L0 { SUBC.W\\t%H0, %H0 { INV.W\\t%H0, %H0\"; /* 8-bytes.  */\n+    /* Low word of dest == source word.  8-byte sequence.  */\n+    return \"BIT.W\\t#0x8000, %L0 { SUBC.W\\t%H0, %H0 { INV.W\\t%H0, %H0\";\n \n   if (! msp430x)\n     /* Note: This sequence is approximately the same length as invoking a helper\n@@ -3248,15 +3307,16 @@ msp430x_extendhisi (rtx * operands)\n        MOV.W  r12, %H0\n \n        but this version does not involve any function calls or using argument\n-       registers, so it reduces register pressure.  */\n-    return \"MOV.W\\t%1, %L0 { BIT.W\\t#0x8000, %L0 { SUBC.W\\t%H0, %H0 { INV.W\\t%H0, %H0\"; /* 10-bytes.  */\n+       registers, so it reduces register pressure.  10-byte sequence.  */\n+    return \"MOV.W\\t%1, %L0 { BIT.W\\t#0x8000, %L0 { SUBC.W\\t%H0, %H0 \"\n+      \"{ INV.W\\t%H0, %H0\";\n \n   if (REGNO (operands[0]) + 1 == REGNO (operands[1]))\n-    /* High word of dest == source word.  */\n-    return \"MOV.W\\t%1, %L0 { RPT\\t#15 { RRAX.W\\t%H0\"; /* 6-bytes.  */\n+    /* High word of dest == source word.  6-byte sequence.  */\n+    return \"MOV.W\\t%1, %L0 { RPT\\t#15 { RRAX.W\\t%H0\";\n \n-  /* No overlap between dest and source.  */\n-  return \"MOV.W\\t%1, %L0 { MOV.W\\t%1, %H0 { RPT\\t#15 { RRAX.W\\t%H0\"; /* 8-bytes.  */\n+  /* No overlap between dest and source.  8-byte sequence.  */\n+  return \"MOV.W\\t%1, %L0 { MOV.W\\t%1, %H0 { RPT\\t#15 { RRAX.W\\t%H0\";\n }\n \n /* Likewise for logical right shifts.  */"}, {"sha": "36b715d0d0fea99349bba40cc94984c1f27eec79", "filename": "gcc/config/msp430/msp430.h", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43bfd4e87b540e883e8fd301669dcb75b6c12010/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43bfd4e87b540e883e8fd301669dcb75b6c12010/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.h?ref=43bfd4e87b540e883e8fd301669dcb75b6c12010", "patch": "@@ -45,7 +45,8 @@ extern bool msp430x;\n   while (0)\n \n #undef  STARTFILE_SPEC\n-#define STARTFILE_SPEC \"%{pg:gcrt0.o%s}%{!pg:%{minrt:crt0-minrt.o%s}%{!minrt:crt0.o%s}} %{!minrt:crtbegin.o%s}\"\n+#define STARTFILE_SPEC \"%{pg:gcrt0.o%s}\" \\\n+  \"%{!pg:%{minrt:crt0-minrt.o%s}%{!minrt:crt0.o%s}} %{!minrt:crtbegin.o%s}\"\n \n /* -lgcc is included because crtend.o needs __mspabi_func_epilog_1.  */\n #undef  ENDFILE_SPEC\n@@ -55,16 +56,20 @@ extern bool msp430x;\n #define ASM_SPEC \"-mP \" /* Enable polymorphic instructions.  */ \\\n   \"%{mcpu=*:-mcpu=%*} \" /* Pass the CPU type on to the assembler.  */ \\\n   \"%{mrelax=-mQ} \" /* Pass the relax option on to the assembler.  */ \\\n-  \"%{mlarge:-ml} \" /* Tell the assembler if we are building for the LARGE pointer model.  */ \\\n-  \"%{!msim:-md} %{msim:%{mlarge:-md}} \" /* Copy data from ROM to RAM if necessary.  */ \\\n-  \"%{msilicon-errata=*:-msilicon-errata=%*} \" /* Pass on -msilicon-errata.  */ \\\n-  \"%{msilicon-errata-warn=*:-msilicon-errata-warn=%*} \" /* Pass on -msilicon-errata-warn.  */ \\\n-  \"%{ffunction-sections:-gdwarf-sections} \" /* If function sections are being created then create DWARF line number sections as well.  */ \\\n-  \"%{mdata-region=*:-mdata-region=%*} \" /* Pass on -mdata-region.  */\n+  /* Tell the assembler if we are building for the LARGE pointer model.  */ \\\n+  \"%{mlarge:-ml} \" \\\n+  /* Copy data from ROM to RAM if necessary.  */ \\\n+  \"%{!msim:-md} %{msim:%{mlarge:-md}} \" \\\n+  \"%{msilicon-errata=*:-msilicon-errata=%*} \" \\\n+  \"%{msilicon-errata-warn=*:-msilicon-errata-warn=%*} \" \\\n+  /* Create DWARF line number sections for -ffunction-sections.  */ \\\n+  \"%{ffunction-sections:-gdwarf-sections} \" \\\n+  \"%{mdata-region=*:-mdata-region=%*} \"\n \n /* Enable linker section garbage collection by default, unless we\n    are creating a relocatable binary (gc does not work) or debugging\n-   is enabled  (the GDB testsuite relies upon unused entities not being deleted).  */\n+   is enabled  (the GDB testsuite relies upon unused entities not being\n+   deleted).  */\n #define LINK_SPEC \"%{mrelax:--relax} %{mlarge:%{!r:%{!g:--gc-sections}}} \" \\\n   \"%{mcode-region=*:--code-region=%*} %{mdata-region=*:--data-region=%*}\"\n \n@@ -110,7 +115,8 @@ extern const char * msp430_check_path_for_devices (int, const char **);\n #undef  LIB_SPEC\n #define LIB_SPEC \"\t\t\t\t\t\\\n --start-group\t\t\t\t\t\t\\\n-%{mhwmult=auto:%{mmcu=*:%:msp430_hwmult_lib(mcu %{mmcu=*:%*});:%:msp430_hwmult_lib(default)}; \\\n+%{mhwmult=auto:%{mmcu=*:%:msp430_hwmult_lib(mcu %{mmcu=*:%*});\\\n+  :%:msp430_hwmult_lib(default)};\t\t\t\\\n   mhwmult=*:%:msp430_hwmult_lib(hwmult %{mhwmult=*:%*}); \\\n   mmcu=*:%:msp430_hwmult_lib(mcu %{mmcu=*:%*});\t\t\\\n   :%:msp430_hwmult_lib(default)}\t\t\t\\\n@@ -395,7 +401,8 @@ typedef struct\n   (((N) < 3) ? ((N) + 12) : INVALID_REGNUM)\n \n #define EH_RETURN_HANDLER_RTX \\\n-  gen_rtx_MEM(Pmode, gen_rtx_PLUS (Pmode, gen_rtx_REG(Pmode, SP_REGNO), gen_rtx_REG (Pmode, 15)))\n+  gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode, SP_REGNO), \\\n+\t\t\t\t   gen_rtx_REG (Pmode, 15)))\n \n #define EH_RETURN_STACKADJ_RTX gen_rtx_REG (Pmode, 15)\n \n@@ -459,7 +466,8 @@ typedef struct\n /* Prevent reload (and others) from choosing HImode stack slots\n    when spilling hard registers when they may contain PSImode values.  */\n #define HARD_REGNO_CALLER_SAVE_MODE(REGNO,NREGS,MODE) \\\n-  ((TARGET_LARGE && ((NREGS) <= 2)) ? PSImode : choose_hard_reg_mode ((REGNO), (NREGS), false))\n+  ((TARGET_LARGE && ((NREGS) <= 2)) ? PSImode \\\n+   : choose_hard_reg_mode ((REGNO), (NREGS), false))\n \n #define ACCUMULATE_OUTGOING_ARGS 1\n "}]}