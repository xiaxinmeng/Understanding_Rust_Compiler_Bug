{"sha": "6a2a98b1a658893ecb790c90614900d7bf8bd022", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmEyYTk4YjFhNjU4ODkzZWNiNzkwYzkwNjE0OTAwZDdiZjhiZDAyMg==", "commit": {"author": {"name": "Chung-Ju Wu", "email": "jasonwucj@gmail.com", "date": "2014-07-04T07:30:04Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2014-07-04T07:30:04Z"}, "message": "Move some helper functions of predicates and constraints to nds32-predicates.c module.\n\ngcc/\n\t* config/nds32/nds32.c\n\t(nds32_consecutive_registers_load_store_p): Move to ...\n\t(nds32_valid_multiple_load_store): Move to ...\n\t(nds32_valid_stack_push_pop): Move to ...\n\t(nds32_can_use_bclr_p): Move to ...\n\t(nds32_can_use_bset_p): Move to ...\n\t(nds32_can_use_btgl_p): Move to ...\n\t(nds32_can_use_bitci_p): Move to ...\n\t* config/nds32/nds32-predicates.c: ... here.\n\nCo-Authored-By: Kito Cheng <kito@0xlab.org>\nCo-Authored-By: Monk Chiang <sh.chiang04@gmail.com>\n\nFrom-SVN: r212283", "tree": {"sha": "a53035313feca19b44de973887d95dc9c58a04e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a53035313feca19b44de973887d95dc9c58a04e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a2a98b1a658893ecb790c90614900d7bf8bd022", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a2a98b1a658893ecb790c90614900d7bf8bd022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a2a98b1a658893ecb790c90614900d7bf8bd022", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a2a98b1a658893ecb790c90614900d7bf8bd022/comments", "author": {"login": "jasonwucj", "id": 5520732, "node_id": "MDQ6VXNlcjU1MjA3MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5520732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jasonwucj", "html_url": "https://github.com/jasonwucj", "followers_url": "https://api.github.com/users/jasonwucj/followers", "following_url": "https://api.github.com/users/jasonwucj/following{/other_user}", "gists_url": "https://api.github.com/users/jasonwucj/gists{/gist_id}", "starred_url": "https://api.github.com/users/jasonwucj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jasonwucj/subscriptions", "organizations_url": "https://api.github.com/users/jasonwucj/orgs", "repos_url": "https://api.github.com/users/jasonwucj/repos", "events_url": "https://api.github.com/users/jasonwucj/events{/privacy}", "received_events_url": "https://api.github.com/users/jasonwucj/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aaa44d2d0bb56f15efc400c66415dce03a8f2da2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaa44d2d0bb56f15efc400c66415dce03a8f2da2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaa44d2d0bb56f15efc400c66415dce03a8f2da2"}], "stats": {"total": 734, "additions": 393, "deletions": 341}, "files": [{"sha": "1d08a691e52fcef028fc41d34ae91d2acea319c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a2a98b1a658893ecb790c90614900d7bf8bd022/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a2a98b1a658893ecb790c90614900d7bf8bd022/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a2a98b1a658893ecb790c90614900d7bf8bd022", "patch": "@@ -1,3 +1,17 @@\n+2014-07-04  Chung-Ju Wu  <jasonwucj@gmail.com>\n+\t    Kito Cheng  <kito@0xlab.org>\n+\t    Monk Chiang  <sh.chiang04@gmail.com>\n+\n+\t* config/nds32/nds32.c\n+\t(nds32_consecutive_registers_load_store_p): Move to ...\n+\t(nds32_valid_multiple_load_store): Move to ...\n+\t(nds32_valid_stack_push_pop): Move to ...\n+\t(nds32_can_use_bclr_p): Move to ...\n+\t(nds32_can_use_bset_p): Move to ...\n+\t(nds32_can_use_btgl_p): Move to ...\n+\t(nds32_can_use_bitci_p): Move to ...\n+\t* config/nds32/nds32-predicates.c: ... here.\n+\n 2014-07-04  Chung-Ju Wu  <jasonwucj@gmail.com>\n \t    Kito Cheng  <kito@0xlab.org>\n \t    Monk Chiang  <sh.chiang04@gmail.com>"}, {"sha": "72cd739905fd57254e6fbd42c612e3ccede19ffb", "filename": "gcc/config/nds32/nds32-predicates.c", "status": "modified", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a2a98b1a658893ecb790c90614900d7bf8bd022/gcc%2Fconfig%2Fnds32%2Fnds32-predicates.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a2a98b1a658893ecb790c90614900d7bf8bd022/gcc%2Fconfig%2Fnds32%2Fnds32-predicates.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-predicates.c?ref=6a2a98b1a658893ecb790c90614900d7bf8bd022", "patch": "@@ -17,3 +17,382 @@\n    You should have received a copy of the GNU General Public License\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n+\n+/* ------------------------------------------------------------------------ */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"stor-layout.h\"\n+#include \"varasm.h\"\n+#include \"calls.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"insn-config.h\"\t/* Required by recog.h.  */\n+#include \"conditions.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\t\t/* For DFA state_t.  */\n+#include \"insn-codes.h\"\t\t/* For CODE_FOR_xxx.  */\n+#include \"reload.h\"\t\t/* For push_reload().  */\n+#include \"flags.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"recog.h\"\n+#include \"diagnostic-core.h\"\n+#include \"df.h\"\n+#include \"tm_p.h\"\n+#include \"tm-constrs.h\"\n+#include \"optabs.h\"\t\t/* For GEN_FCN.  */\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"langhooks.h\"\t\t/* For add_builtin_function().  */\n+#include \"ggc.h\"\n+#include \"builtins.h\"\n+\n+/* ------------------------------------------------------------------------ */\n+\n+/* A subroutine that checks multiple load and store\n+   using consecutive registers.\n+     OP is a parallel rtx we would like to check.\n+     LOAD_P indicates whether we are checking load operation.\n+     PAR_INDEX is starting element of parallel rtx.\n+     FIRST_ELT_REGNO is used to tell starting register number.\n+     COUNT helps us to check consecutive register numbers.  */\n+static bool\n+nds32_consecutive_registers_load_store_p (rtx op,\n+\t\t\t\t\t  bool load_p,\n+\t\t\t\t\t  int par_index,\n+\t\t\t\t\t  int first_elt_regno,\n+\t\t\t\t\t  int count)\n+{\n+  int i;\n+  int check_regno;\n+  rtx elt;\n+  rtx elt_reg;\n+  rtx elt_mem;\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      /* Pick up each element from parallel rtx.  */\n+      elt = XVECEXP (op, 0, i + par_index);\n+\n+      /* If this element is not a 'set' rtx, return false immediately.  */\n+      if (GET_CODE (elt) != SET)\n+\treturn false;\n+\n+      /* Pick up reg and mem of this element.  */\n+      elt_reg = load_p ? SET_DEST (elt) : SET_SRC (elt);\n+      elt_mem = load_p ? SET_SRC (elt) : SET_DEST (elt);\n+\n+      /* If elt_reg is not a expected reg rtx, return false.  */\n+      if (GET_CODE (elt_reg) != REG || GET_MODE (elt_reg) != SImode)\n+\treturn false;\n+      /* If elt_mem is not a expected mem rtx, return false.  */\n+      if (GET_CODE (elt_mem) != MEM || GET_MODE (elt_mem) != SImode)\n+\treturn false;\n+\n+      /* The consecutive registers should be in (Rb,Rb+1...Re) order.  */\n+      check_regno = first_elt_regno + i;\n+\n+      /* If the register number is not continuous, return false.  */\n+      if (REGNO (elt_reg) != (unsigned int) check_regno)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Function to check whether the OP is a valid load/store operation.\n+   This is a helper function for the predicates:\n+   'nds32_load_multiple_operation' and 'nds32_store_multiple_operation'\n+   in predicates.md file.\n+\n+   The OP is supposed to be a parallel rtx.\n+   For each element within this parallel rtx:\n+     (set (reg) (mem addr)) is the form for load operation.\n+     (set (mem addr) (reg)) is the form for store operation.\n+   We have to extract reg and mem of every element and\n+   check if the information is valid for multiple load/store operation.  */\n+bool\n+nds32_valid_multiple_load_store (rtx op, bool load_p)\n+{\n+  int count;\n+  int first_elt_regno;\n+  rtx elt;\n+\n+  /* Get the counts of elements in the parallel rtx.  */\n+  count = XVECLEN (op, 0);\n+  /* Pick up the first element.  */\n+  elt = XVECEXP (op, 0, 0);\n+\n+  /* Perform some quick check for the first element in the parallel rtx.  */\n+  if (GET_CODE (elt) != SET\n+      || count <= 1\n+      || count > 8)\n+    return false;\n+\n+  /* Pick up regno of first element for further detail checking.\n+     Note that the form is different between load and store operation.  */\n+  if (load_p)\n+    {\n+      if (GET_CODE (SET_DEST (elt)) != REG\n+\t  || GET_CODE (SET_SRC (elt)) != MEM)\n+\treturn false;\n+\n+      first_elt_regno = REGNO (SET_DEST (elt));\n+    }\n+  else\n+    {\n+      if (GET_CODE (SET_SRC (elt)) != REG\n+\t  || GET_CODE (SET_DEST (elt)) != MEM)\n+\treturn false;\n+\n+      first_elt_regno = REGNO (SET_SRC (elt));\n+    }\n+\n+  /* Perform detail check for each element.\n+     Refer to nds32-multiple.md for more information\n+     about following checking.\n+     The starting element of parallel rtx is index 0.  */\n+  if (!nds32_consecutive_registers_load_store_p (op, load_p, 0,\n+\t\t\t\t\t\t first_elt_regno,\n+\t\t\t\t\t\t count))\n+    return false;\n+\n+  /* Pass all test, this is a valid rtx.  */\n+  return true;\n+}\n+\n+/* Function to check whether the OP is a valid stack push/pop operation.\n+   For a valid stack operation, it must satisfy following conditions:\n+     1. Consecutive registers push/pop operations.\n+     2. Valid $fp/$gp/$lp push/pop operations.\n+     3. The last element must be stack adjustment rtx.\n+   See the prologue/epilogue implementation for details.  */\n+bool\n+nds32_valid_stack_push_pop (rtx op, bool push_p)\n+{\n+  int index;\n+  int total_count;\n+  int rest_count;\n+  int first_regno;\n+  rtx elt;\n+  rtx elt_reg;\n+  rtx elt_mem;\n+  rtx elt_plus;\n+\n+  /* Get the counts of elements in the parallel rtx.  */\n+  total_count = XVECLEN (op, 0);\n+\n+  /* Perform some quick check for that every element should be 'set'.  */\n+  for (index = 0; index < total_count; index++)\n+    {\n+      elt = XVECEXP (op, 0, index);\n+      if (GET_CODE (elt) != SET)\n+        return false;\n+    }\n+\n+  /* For push operation, the parallel rtx looks like:\n+     (parallel [(set (mem (plus (reg:SI SP_REGNUM) (const_int -32)))\n+                     (reg:SI Rb))\n+                (set (mem (plus (reg:SI SP_REGNUM) (const_int -28)))\n+                     (reg:SI Rb+1))\n+                ...\n+                (set (mem (plus (reg:SI SP_REGNUM) (const_int -16)))\n+                     (reg:SI Re))\n+                (set (mem (plus (reg:SI SP_REGNUM) (const_int -12)))\n+                     (reg:SI FP_REGNUM))\n+                (set (mem (plus (reg:SI SP_REGNUM) (const_int -8)))\n+                     (reg:SI GP_REGNUM))\n+                (set (mem (plus (reg:SI SP_REGNUM) (const_int -4)))\n+                     (reg:SI LP_REGNUM))\n+                (set (reg:SI SP_REGNUM)\n+                     (plus (reg:SI SP_REGNUM) (const_int -32)))])\n+\n+     For pop operation, the parallel rtx looks like:\n+     (parallel [(set (reg:SI Rb)\n+                     (mem (reg:SI SP_REGNUM)))\n+                (set (reg:SI Rb+1)\n+                     (mem (plus (reg:SI SP_REGNUM) (const_int 4))))\n+                ...\n+                (set (reg:SI Re)\n+                     (mem (plus (reg:SI SP_REGNUM) (const_int 16))))\n+                (set (reg:SI FP_REGNUM)\n+                     (mem (plus (reg:SI SP_REGNUM) (const_int 20))))\n+                (set (reg:SI GP_REGNUM)\n+                     (mem (plus (reg:SI SP_REGNUM) (const_int 24))))\n+                (set (reg:SI LP_REGNUM)\n+                     (mem (plus (reg:SI SP_REGNUM) (const_int 28))))\n+                (set (reg:SI SP_REGNUM)\n+                     (plus (reg:SI SP_REGNUM) (const_int 32)))]) */\n+\n+  /* 1. Consecutive registers push/pop operations.\n+        We need to calculate how many registers should be consecutive.\n+        The $sp adjustment rtx, $fp push rtx, $gp push rtx,\n+        and $lp push rtx are excluded.  */\n+\n+  /* Exclude last $sp adjustment rtx.  */\n+  rest_count = total_count - 1;\n+  /* Exclude $fp, $gp, and $lp if they are in the parallel rtx.  */\n+  if (cfun->machine->fp_size)\n+    rest_count--;\n+  if (cfun->machine->gp_size)\n+    rest_count--;\n+  if (cfun->machine->lp_size)\n+    rest_count--;\n+\n+  if (rest_count > 0)\n+    {\n+      elt = XVECEXP (op, 0, 0);\n+      /* Pick up register element.  */\n+      elt_reg = push_p ? SET_SRC (elt) : SET_DEST (elt);\n+      first_regno = REGNO (elt_reg);\n+\n+      /* The 'push' operation is a kind of store operation.\n+         The 'pop' operation is a kind of load operation.\n+         Pass corresponding false/true as second argument (bool load_p).\n+         The par_index is supposed to start with index 0.  */\n+      if (!nds32_consecutive_registers_load_store_p (op,\n+\t\t\t\t\t\t     !push_p ? true : false,\n+\t\t\t\t\t\t     0,\n+\t\t\t\t\t\t     first_regno,\n+\t\t\t\t\t\t     rest_count))\n+        return false;\n+    }\n+\n+  /* 2. Valid $fp/$gp/$lp push/pop operations.\n+        Remember to set start index for checking them.  */\n+\n+  /* The rest_count is the start index for checking $fp/$gp/$lp.  */\n+  index = rest_count;\n+  /* If index < 0, this parallel rtx is definitely\n+     not a valid stack push/pop operation.  */\n+  if (index < 0)\n+    return false;\n+\n+  /* Check $fp/$gp/$lp one by one.\n+     We use 'push_p' to pick up reg rtx and mem rtx.  */\n+  if (cfun->machine->fp_size)\n+    {\n+      elt = XVECEXP (op, 0, index);\n+      elt_mem = push_p ? SET_DEST (elt) : SET_SRC (elt);\n+      elt_reg = push_p ? SET_SRC (elt) : SET_DEST (elt);\n+      index++;\n+\n+      if (GET_CODE (elt_mem) != MEM\n+          || GET_CODE (elt_reg) != REG\n+          || REGNO (elt_reg) != FP_REGNUM)\n+        return false;\n+    }\n+  if (cfun->machine->gp_size)\n+    {\n+      elt = XVECEXP (op, 0, index);\n+      elt_mem = push_p ? SET_DEST (elt) : SET_SRC (elt);\n+      elt_reg = push_p ? SET_SRC (elt) : SET_DEST (elt);\n+      index++;\n+\n+      if (GET_CODE (elt_mem) != MEM\n+          || GET_CODE (elt_reg) != REG\n+          || REGNO (elt_reg) != GP_REGNUM)\n+        return false;\n+    }\n+  if (cfun->machine->lp_size)\n+    {\n+      elt = XVECEXP (op, 0, index);\n+      elt_mem = push_p ? SET_DEST (elt) : SET_SRC (elt);\n+      elt_reg = push_p ? SET_SRC (elt) : SET_DEST (elt);\n+      index++;\n+\n+      if (GET_CODE (elt_mem) != MEM\n+          || GET_CODE (elt_reg) != REG\n+          || REGNO (elt_reg) != LP_REGNUM)\n+        return false;\n+    }\n+\n+  /* 3. The last element must be stack adjustment rtx.\n+        Its form of rtx should be:\n+          (set (reg:SI SP_REGNUM)\n+               (plus (reg:SI SP_REGNUM) (const_int X)))\n+        The X could be positive or negative value.  */\n+\n+  /* Pick up the last element.  */\n+  elt = XVECEXP (op, 0, total_count - 1);\n+\n+  /* Extract its destination and source rtx.  */\n+  elt_reg  = SET_DEST (elt);\n+  elt_plus = SET_SRC (elt);\n+\n+  /* Check this is (set (stack_reg) (plus stack_reg const)) pattern.  */\n+  if (GET_CODE (elt_reg) != REG\n+      || GET_CODE (elt_plus) != PLUS\n+      || REGNO (elt_reg) != SP_REGNUM)\n+    return false;\n+\n+  /* Pass all test, this is a valid rtx.  */\n+  return true;\n+}\n+\n+/* Function to check if 'bclr' instruction can be used with IVAL.  */\n+int\n+nds32_can_use_bclr_p (int ival)\n+{\n+  int one_bit_count;\n+\n+  /* Calculate the number of 1-bit of (~ival), if there is only one 1-bit,\n+     it means the original ival has only one 0-bit,\n+     So it is ok to perform 'bclr' operation.  */\n+\n+  one_bit_count = popcount_hwi ((unsigned HOST_WIDE_INT) (~ival));\n+\n+  /* 'bclr' is a performance extension instruction.  */\n+  return (TARGET_PERF_EXT && (one_bit_count == 1));\n+}\n+\n+/* Function to check if 'bset' instruction can be used with IVAL.  */\n+int\n+nds32_can_use_bset_p (int ival)\n+{\n+  int one_bit_count;\n+\n+  /* Caculate the number of 1-bit of ival, if there is only one 1-bit,\n+     it is ok to perform 'bset' operation.  */\n+\n+  one_bit_count = popcount_hwi ((unsigned HOST_WIDE_INT) (ival));\n+\n+  /* 'bset' is a performance extension instruction.  */\n+  return (TARGET_PERF_EXT && (one_bit_count == 1));\n+}\n+\n+/* Function to check if 'btgl' instruction can be used with IVAL.  */\n+int\n+nds32_can_use_btgl_p (int ival)\n+{\n+  int one_bit_count;\n+\n+  /* Caculate the number of 1-bit of ival, if there is only one 1-bit,\n+     it is ok to perform 'btgl' operation.  */\n+\n+  one_bit_count = popcount_hwi ((unsigned HOST_WIDE_INT) (ival));\n+\n+  /* 'btgl' is a performance extension instruction.  */\n+  return (TARGET_PERF_EXT && (one_bit_count == 1));\n+}\n+\n+/* Function to check if 'bitci' instruction can be used with IVAL.  */\n+int\n+nds32_can_use_bitci_p (int ival)\n+{\n+  /* If we are using V3 ISA, we have 'bitci' instruction.\n+     Try to see if we can present 'andi' semantic with\n+     such 'bit-clear-immediate' operation.\n+     For example, 'andi $r0,$r0,0xfffffffc' can be\n+     presented with 'bitci $r0,$r0,3'.  */\n+  return (TARGET_ISA_V3\n+\t  && (ival < 0)\n+\t  && satisfies_constraint_Iu15 (gen_int_mode (~ival, SImode)));\n+}\n+\n+/* ------------------------------------------------------------------------ */"}, {"sha": "922d9e41c2891a7409ec3206977f5a38f4db76aa", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 0, "deletions": 341, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a2a98b1a658893ecb790c90614900d7bf8bd022/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a2a98b1a658893ecb790c90614900d7bf8bd022/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=6a2a98b1a658893ecb790c90614900d7bf8bd022", "patch": "@@ -849,57 +849,6 @@ nds32_gen_stack_v3pop (rtx Rb,\n   return parallel_insn;\n }\n \n-/* A subroutine that checks multiple load and store\n-   using consecutive registers.\n-     OP is a parallel rtx we would like to check.\n-     LOAD_P indicates whether we are checking load operation.\n-     PAR_INDEX is starting element of parallel rtx.\n-     FIRST_ELT_REGNO is used to tell starting register number.\n-     COUNT helps us to check consecutive register numbers.  */\n-static bool\n-nds32_consecutive_registers_load_store_p (rtx op,\n-\t\t\t\t\t  bool load_p,\n-\t\t\t\t\t  int par_index,\n-\t\t\t\t\t  int first_elt_regno,\n-\t\t\t\t\t  int count)\n-{\n-  int i;\n-  int check_regno;\n-  rtx elt;\n-  rtx elt_reg;\n-  rtx elt_mem;\n-\n-  for (i = 0; i < count; i++)\n-    {\n-      /* Pick up each element from parallel rtx.  */\n-      elt = XVECEXP (op, 0, i + par_index);\n-\n-      /* If this element is not a 'set' rtx, return false immediately.  */\n-      if (GET_CODE (elt) != SET)\n-\treturn false;\n-\n-      /* Pick up reg and mem of this element.  */\n-      elt_reg = load_p ? SET_DEST (elt) : SET_SRC (elt);\n-      elt_mem = load_p ? SET_SRC (elt) : SET_DEST (elt);\n-\n-      /* If elt_reg is not a expected reg rtx, return false.  */\n-      if (GET_CODE (elt_reg) != REG || GET_MODE (elt_reg) != SImode)\n-\treturn false;\n-      /* If elt_mem is not a expected mem rtx, return false.  */\n-      if (GET_CODE (elt_mem) != MEM || GET_MODE (elt_mem) != SImode)\n-\treturn false;\n-\n-      /* The consecutive registers should be in (Rb,Rb+1...Re) order.  */\n-      check_regno = first_elt_regno + i;\n-\n-      /* If the register number is not continuous, return false.  */\n-      if (REGNO (elt_reg) != (unsigned int) check_regno)\n-\treturn false;\n-    }\n-\n-  return true;\n-}\n-\n /* Function that may creates more instructions\n    for large value on adjusting stack pointer.\n \n@@ -3499,236 +3448,6 @@ nds32_expand_movmemqi (rtx dstmem, rtx srcmem, rtx total_bytes, rtx alignment)\n   return 1;\n }\n \n-/* Function to check whether the OP is a valid load/store operation.\n-   This is a helper function for the predicates:\n-   'nds32_load_multiple_operation' and 'nds32_store_multiple_operation'\n-   in predicates.md file.\n-\n-   The OP is supposed to be a parallel rtx.\n-   For each element within this parallel rtx:\n-     (set (reg) (mem addr)) is the form for load operation.\n-     (set (mem addr) (reg)) is the form for store operation.\n-   We have to extract reg and mem of every element and\n-   check if the information is valid for multiple load/store operation.  */\n-bool\n-nds32_valid_multiple_load_store (rtx op, bool load_p)\n-{\n-  int count;\n-  int first_elt_regno;\n-  rtx elt;\n-\n-  /* Get the counts of elements in the parallel rtx.  */\n-  count = XVECLEN (op, 0);\n-  /* Pick up the first element.  */\n-  elt = XVECEXP (op, 0, 0);\n-\n-  /* Perform some quick check for the first element in the parallel rtx.  */\n-  if (GET_CODE (elt) != SET\n-      || count <= 1\n-      || count > 8)\n-    return false;\n-\n-  /* Pick up regno of first element for further detail checking.\n-     Note that the form is different between load and store operation.  */\n-  if (load_p)\n-    {\n-      if (GET_CODE (SET_DEST (elt)) != REG\n-\t  || GET_CODE (SET_SRC (elt)) != MEM)\n-\treturn false;\n-\n-      first_elt_regno = REGNO (SET_DEST (elt));\n-    }\n-  else\n-    {\n-      if (GET_CODE (SET_SRC (elt)) != REG\n-\t  || GET_CODE (SET_DEST (elt)) != MEM)\n-\treturn false;\n-\n-      first_elt_regno = REGNO (SET_SRC (elt));\n-    }\n-\n-  /* Perform detail check for each element.\n-     Refer to nds32-multiple.md for more information\n-     about following checking.\n-     The starting element of parallel rtx is index 0.  */\n-  if (!nds32_consecutive_registers_load_store_p (op, load_p, 0,\n-\t\t\t\t\t\t first_elt_regno,\n-\t\t\t\t\t\t count))\n-    return false;\n-\n-  /* Pass all test, this is a valid rtx.  */\n-  return true;\n-}\n-\n-/* Function to check whether the OP is a valid stack push/pop operation.\n-   For a valid stack operation, it must satisfy following conditions:\n-     1. Consecutive registers push/pop operations.\n-     2. Valid $fp/$gp/$lp push/pop operations.\n-     3. The last element must be stack adjustment rtx.\n-   See the prologue/epilogue implementation for details.  */\n-bool\n-nds32_valid_stack_push_pop (rtx op, bool push_p)\n-{\n-  int index;\n-  int total_count;\n-  int rest_count;\n-  int first_regno;\n-  rtx elt;\n-  rtx elt_reg;\n-  rtx elt_mem;\n-  rtx elt_plus;\n-\n-  /* Get the counts of elements in the parallel rtx.  */\n-  total_count = XVECLEN (op, 0);\n-\n-  /* Perform some quick check for that every element should be 'set'.  */\n-  for (index = 0; index < total_count; index++)\n-    {\n-      elt = XVECEXP (op, 0, index);\n-      if (GET_CODE (elt) != SET)\n-        return false;\n-    }\n-\n-  /* For push operation, the parallel rtx looks like:\n-     (parallel [(set (mem (plus (reg:SI SP_REGNUM) (const_int -32)))\n-                     (reg:SI Rb))\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -28)))\n-                     (reg:SI Rb+1))\n-                ...\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -16)))\n-                     (reg:SI Re))\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -12)))\n-                     (reg:SI FP_REGNUM))\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -8)))\n-                     (reg:SI GP_REGNUM))\n-                (set (mem (plus (reg:SI SP_REGNUM) (const_int -4)))\n-                     (reg:SI LP_REGNUM))\n-                (set (reg:SI SP_REGNUM)\n-                     (plus (reg:SI SP_REGNUM) (const_int -32)))])\n-\n-     For pop operation, the parallel rtx looks like:\n-     (parallel [(set (reg:SI Rb)\n-                     (mem (reg:SI SP_REGNUM)))\n-                (set (reg:SI Rb+1)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 4))))\n-                ...\n-                (set (reg:SI Re)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 16))))\n-                (set (reg:SI FP_REGNUM)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 20))))\n-                (set (reg:SI GP_REGNUM)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 24))))\n-                (set (reg:SI LP_REGNUM)\n-                     (mem (plus (reg:SI SP_REGNUM) (const_int 28))))\n-                (set (reg:SI SP_REGNUM)\n-                     (plus (reg:SI SP_REGNUM) (const_int 32)))]) */\n-\n-  /* 1. Consecutive registers push/pop operations.\n-        We need to calculate how many registers should be consecutive.\n-        The $sp adjustment rtx, $fp push rtx, $gp push rtx,\n-        and $lp push rtx are excluded.  */\n-\n-  /* Exclude last $sp adjustment rtx.  */\n-  rest_count = total_count - 1;\n-  /* Exclude $fp, $gp, and $lp if they are in the parallel rtx.  */\n-  if (cfun->machine->fp_size)\n-    rest_count--;\n-  if (cfun->machine->gp_size)\n-    rest_count--;\n-  if (cfun->machine->lp_size)\n-    rest_count--;\n-\n-  if (rest_count > 0)\n-    {\n-      elt = XVECEXP (op, 0, 0);\n-      /* Pick up register element.  */\n-      elt_reg = push_p ? SET_SRC (elt) : SET_DEST (elt);\n-      first_regno = REGNO (elt_reg);\n-\n-      /* The 'push' operation is a kind of store operation.\n-         The 'pop' operation is a kind of load operation.\n-         Pass corresponding false/true as second argument (bool load_p).\n-         The par_index is supposed to start with index 0.  */\n-      if (!nds32_consecutive_registers_load_store_p (op,\n-\t\t\t\t\t\t     !push_p ? true : false,\n-\t\t\t\t\t\t     0,\n-\t\t\t\t\t\t     first_regno,\n-\t\t\t\t\t\t     rest_count))\n-        return false;\n-    }\n-\n-  /* 2. Valid $fp/$gp/$lp push/pop operations.\n-        Remember to set start index for checking them.  */\n-\n-  /* The rest_count is the start index for checking $fp/$gp/$lp.  */\n-  index = rest_count;\n-  /* If index < 0, this parallel rtx is definitely\n-     not a valid stack push/pop operation.  */\n-  if (index < 0)\n-    return false;\n-\n-  /* Check $fp/$gp/$lp one by one.\n-     We use 'push_p' to pick up reg rtx and mem rtx.  */\n-  if (cfun->machine->fp_size)\n-    {\n-      elt = XVECEXP (op, 0, index);\n-      elt_mem = push_p ? SET_DEST (elt) : SET_SRC (elt);\n-      elt_reg = push_p ? SET_SRC (elt) : SET_DEST (elt);\n-      index++;\n-\n-      if (GET_CODE (elt_mem) != MEM\n-          || GET_CODE (elt_reg) != REG\n-          || REGNO (elt_reg) != FP_REGNUM)\n-        return false;\n-    }\n-  if (cfun->machine->gp_size)\n-    {\n-      elt = XVECEXP (op, 0, index);\n-      elt_mem = push_p ? SET_DEST (elt) : SET_SRC (elt);\n-      elt_reg = push_p ? SET_SRC (elt) : SET_DEST (elt);\n-      index++;\n-\n-      if (GET_CODE (elt_mem) != MEM\n-          || GET_CODE (elt_reg) != REG\n-          || REGNO (elt_reg) != GP_REGNUM)\n-        return false;\n-    }\n-  if (cfun->machine->lp_size)\n-    {\n-      elt = XVECEXP (op, 0, index);\n-      elt_mem = push_p ? SET_DEST (elt) : SET_SRC (elt);\n-      elt_reg = push_p ? SET_SRC (elt) : SET_DEST (elt);\n-      index++;\n-\n-      if (GET_CODE (elt_mem) != MEM\n-          || GET_CODE (elt_reg) != REG\n-          || REGNO (elt_reg) != LP_REGNUM)\n-        return false;\n-    }\n-\n-  /* 3. The last element must be stack adjustment rtx.\n-        Its form of rtx should be:\n-          (set (reg:SI SP_REGNUM)\n-               (plus (reg:SI SP_REGNUM) (const_int X)))\n-        The X could be positive or negative value.  */\n-\n-  /* Pick up the last element.  */\n-  elt = XVECEXP (op, 0, total_count - 1);\n-\n-  /* Extract its destination and source rtx.  */\n-  elt_reg  = SET_DEST (elt);\n-  elt_plus = SET_SRC (elt);\n-\n-  /* Check this is (set (stack_reg) (plus stack_reg const)) pattern.  */\n-  if (GET_CODE (elt_reg) != REG\n-      || GET_CODE (elt_plus) != PLUS\n-      || REGNO (elt_reg) != SP_REGNUM)\n-    return false;\n-\n-  /* Pass all test, this is a valid rtx.  */\n-  return true;\n-}\n-\n /* Computing the Length of an Insn.\n    Modifies the length assigned to instruction INSN.\n    LEN is the initially computed length of the insn.  */\n@@ -3760,66 +3479,6 @@ nds32_adjust_insn_length (rtx insn, int length)\n }\n \n \n-/* Function to check if 'bclr' instruction can be used with IVAL.  */\n-int\n-nds32_can_use_bclr_p (int ival)\n-{\n-  int one_bit_count;\n-\n-  /* Calculate the number of 1-bit of (~ival), if there is only one 1-bit,\n-     it means the original ival has only one 0-bit,\n-     So it is ok to perform 'bclr' operation.  */\n-\n-  one_bit_count = popcount_hwi ((unsigned HOST_WIDE_INT) (~ival));\n-\n-  /* 'bclr' is a performance extension instruction.  */\n-  return (TARGET_PERF_EXT && (one_bit_count == 1));\n-}\n-\n-/* Function to check if 'bset' instruction can be used with IVAL.  */\n-int\n-nds32_can_use_bset_p (int ival)\n-{\n-  int one_bit_count;\n-\n-  /* Caculate the number of 1-bit of ival, if there is only one 1-bit,\n-     it is ok to perform 'bset' operation.  */\n-\n-  one_bit_count = popcount_hwi ((unsigned HOST_WIDE_INT) (ival));\n-\n-  /* 'bset' is a performance extension instruction.  */\n-  return (TARGET_PERF_EXT && (one_bit_count == 1));\n-}\n-\n-/* Function to check if 'btgl' instruction can be used with IVAL.  */\n-int\n-nds32_can_use_btgl_p (int ival)\n-{\n-  int one_bit_count;\n-\n-  /* Caculate the number of 1-bit of ival, if there is only one 1-bit,\n-     it is ok to perform 'btgl' operation.  */\n-\n-  one_bit_count = popcount_hwi ((unsigned HOST_WIDE_INT) (ival));\n-\n-  /* 'btgl' is a performance extension instruction.  */\n-  return (TARGET_PERF_EXT && (one_bit_count == 1));\n-}\n-\n-/* Function to check if 'bitci' instruction can be used with IVAL.  */\n-int\n-nds32_can_use_bitci_p (int ival)\n-{\n-  /* If we are using V3 ISA, we have 'bitci' instruction.\n-     Try to see if we can present 'andi' semantic with\n-     such 'bit-clear-immediate' operation.\n-     For example, 'andi $r0,$r0,0xfffffffc' can be\n-     presented with 'bitci $r0,$r0,3'.  */\n-  return (TARGET_ISA_V3\n-\t  && (ival < 0)\n-\t  && satisfies_constraint_Iu15 (gen_int_mode (~ival, SImode)));\n-}\n-\n \n /* Return true if is load/store with SYMBOL_REF addressing mode\n    and memory mode is SImode.  */"}]}