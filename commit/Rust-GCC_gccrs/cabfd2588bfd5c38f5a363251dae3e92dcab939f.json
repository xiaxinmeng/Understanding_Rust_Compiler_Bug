{"sha": "cabfd2588bfd5c38f5a363251dae3e92dcab939f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FiZmQyNTg4YmZkNWMzOGY1YTM2MzI1MWRhZTNlOTJkY2FiOTM5Zg==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2003-05-16T23:45:42Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2003-05-16T23:45:42Z"}, "message": "rs6000.c (expand_block_move): Unify the TARGET_STRING and ! TARGET_STRING cases.\n\n\t* config/rs6000/rs6000.c (expand_block_move): Unify the TARGET_STRING\n\tand ! TARGET_STRING cases.\n\nFrom-SVN: r66896", "tree": {"sha": "b87bca54ee1412d56970b7edb08dc36781c6b1e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b87bca54ee1412d56970b7edb08dc36781c6b1e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cabfd2588bfd5c38f5a363251dae3e92dcab939f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cabfd2588bfd5c38f5a363251dae3e92dcab939f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cabfd2588bfd5c38f5a363251dae3e92dcab939f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cabfd2588bfd5c38f5a363251dae3e92dcab939f/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e53359d446a7904474486bfb7c1e947cca326f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e53359d446a7904474486bfb7c1e947cca326f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e53359d446a7904474486bfb7c1e947cca326f3"}], "stats": {"total": 287, "additions": 120, "deletions": 167}, "files": [{"sha": "1f0a5b0cea8b25918708ac84e76221823343f7dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cabfd2588bfd5c38f5a363251dae3e92dcab939f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cabfd2588bfd5c38f5a363251dae3e92dcab939f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cabfd2588bfd5c38f5a363251dae3e92dcab939f", "patch": "@@ -8,6 +8,9 @@\n \n 2003-05-16  Geoffrey Keating  <geoffk@apple.com>\n \n+\t* config/rs6000/rs6000.c (expand_block_move): Unify the TARGET_STRING\n+\tand ! TARGET_STRING cases.\n+\n \t* doc/cppopts.texi (-undef): Fix texinfo warning.\n \n \t* doc/cppopts.texi (-H): Document that -H works for PCH files too."}, {"sha": "adfa5cb52cd3f70bb961bc37b51c04747177576a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 117, "deletions": 167, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cabfd2588bfd5c38f5a363251dae3e92dcab939f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cabfd2588bfd5c38f5a363251dae3e92dcab939f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=cabfd2588bfd5c38f5a363251dae3e92dcab939f", "patch": "@@ -6873,6 +6873,8 @@ expand_block_move (operands)\n   int bytes;\n   int offset;\n   int move_bytes;\n+  rtx stores[MAX_MOVE_REG];\n+  int num_reg = 0;\n \n   /* If this is not a fixed size move, just call memcpy */\n   if (! constp)\n@@ -6893,182 +6895,130 @@ expand_block_move (operands)\n   if (bytes > (TARGET_POWERPC64 ? 64 : 32))\n     return 0;\n \n-  if (TARGET_STRING)\t/* string instructions are available */\n-    {\n-      for (offset = 0; bytes > 0; offset += move_bytes, bytes -= move_bytes)\n-\t{\n-\t  union {\n-\t    rtx (*movstrsi) PARAMS ((rtx, rtx, rtx, rtx));\n-\t    rtx (*mov) PARAMS ((rtx, rtx));\n-\t  } gen_func;\n-\t  enum machine_mode mode = BLKmode;\n-\t  rtx src, dest;\n-\n-\t  if (bytes > 24\t\t/* move up to 32 bytes at a time */\n-\t      && ! fixed_regs[5]\n-\t      && ! fixed_regs[6]\n-\t      && ! fixed_regs[7]\n-\t      && ! fixed_regs[8]\n-\t      && ! fixed_regs[9]\n-\t      && ! fixed_regs[10]\n-\t      && ! fixed_regs[11]\n-\t      && ! fixed_regs[12])\n-\t    {\n-\t      move_bytes = (bytes > 32) ? 32 : bytes;\n-\t      gen_func.movstrsi = gen_movstrsi_8reg;\n-\t    }\n-\t  else if (bytes > 16\t/* move up to 24 bytes at a time */\n-\t\t   && ! fixed_regs[5]\n-\t\t   && ! fixed_regs[6]\n-\t\t   && ! fixed_regs[7]\n-\t\t   && ! fixed_regs[8]\n-\t\t   && ! fixed_regs[9]\n-\t\t   && ! fixed_regs[10])\n-\t    {\n-\t      move_bytes = (bytes > 24) ? 24 : bytes;\n-\t      gen_func.movstrsi = gen_movstrsi_6reg;\n-\t    }\n-\t  else if (bytes > 8\t/* move up to 16 bytes at a time */\n-\t\t   && ! fixed_regs[5]\n-\t\t   && ! fixed_regs[6]\n-\t\t   && ! fixed_regs[7]\n-\t\t   && ! fixed_regs[8])\n-\t    {\n-\t      move_bytes = (bytes > 16) ? 16 : bytes;\n-\t      gen_func.movstrsi = gen_movstrsi_4reg;\n-\t    }\n-\t  else if (bytes >= 8 && TARGET_POWERPC64\n-\t\t   /* 64-bit loads and stores require word-aligned\n-                      displacements.  */\n-\t\t   && (align >= 8 || (! STRICT_ALIGNMENT && align >= 4)))\n-\t    {\n-\t      move_bytes = 8;\n-\t      mode = DImode;\n-\t      gen_func.mov = gen_movdi;\n-\t    }\n-\t  else if (bytes > 4 && !TARGET_POWERPC64)\n-\t    {\t\t\t/* move up to 8 bytes at a time */\n-\t      move_bytes = (bytes > 8) ? 8 : bytes;\n-\t      gen_func.movstrsi = gen_movstrsi_2reg;\n-\t    }\n-\t  else if (bytes >= 4 && (align >= 4 || ! STRICT_ALIGNMENT))\n-\t    {\t\t\t/* move 4 bytes */\n-\t      move_bytes = 4;\n-\t      mode = SImode;\n-\t      gen_func.mov = gen_movsi;\n-\t    }\n-\t  else if (bytes == 2 && (align >= 2 || ! STRICT_ALIGNMENT))\n-\t    {\t\t\t/* move 2 bytes */\n-\t      move_bytes = 2;\n-\t      mode = HImode;\n-\t      gen_func.mov = gen_movhi;\n-\t    }\n-\t  else if (bytes == 1)\t/* move 1 byte */\n-\t    {\n-\t      move_bytes = 1;\n-\t      mode = QImode;\n-\t      gen_func.mov = gen_movqi;\n-\t    }\n-\t  else\n-\t    {\t\t\t/* move up to 4 bytes at a time */\n-\t      move_bytes = (bytes > 4) ? 4 : bytes;\n-\t      gen_func.movstrsi = gen_movstrsi_1reg;\n-\t    }\n-\n-\t  src = adjust_address (orig_src, mode, offset);\n-\t  dest = adjust_address (orig_dest, mode, offset);\n-\n-\t  if (mode == BLKmode)\n-\t    {\n-\t      /* Move the address into scratch registers.  The movstrsi\n-\t\t patterns require zero offset.  */\n-\t      if (!REG_P (XEXP (src, 0)))\n-\t\t{\n-\t\t  rtx src_reg = copy_addr_to_reg (XEXP (src, 0));\n-\t\t  src = replace_equiv_address (src, src_reg);\n-\t\t}\n-\t      set_mem_size (src, GEN_INT (move_bytes));\n-\n-\t      if (!REG_P (XEXP (dest, 0)))\n-\t\t{\n-\t\t  rtx dest_reg = copy_addr_to_reg (XEXP (dest, 0));\n-\t\t  dest = replace_equiv_address (dest, dest_reg);\n-\t\t}\n-\t      set_mem_size (dest, GEN_INT (move_bytes));\n-\n-\t      emit_insn ((*gen_func.movstrsi) (dest, src,\n-\t\t\t\t\t       GEN_INT (move_bytes & 31),\n-\t\t\t\t\t       align_rtx));\n-\t    }\n-\t  else\n-\t    {\n-\t      rtx tmp_reg = gen_reg_rtx (mode);\n-\n-\t      emit_insn ((*gen_func.mov) (tmp_reg, src));\n-\t      emit_insn ((*gen_func.mov) (dest, tmp_reg));\n-\t    }\n-\t}\n-    }\n-\n-  else\t\t\t/* string instructions not available */\n+  for (offset = 0; bytes > 0; offset += move_bytes, bytes -= move_bytes)\n     {\n-      rtx stores[MAX_MOVE_REG];\n-      int num_reg = 0;\n-      int i;\n+      union {\n+\trtx (*movstrsi) PARAMS ((rtx, rtx, rtx, rtx));\n+\trtx (*mov) PARAMS ((rtx, rtx));\n+      } gen_func;\n+      enum machine_mode mode = BLKmode;\n+      rtx src, dest;\n+      \n+      if (TARGET_STRING\n+\t  && bytes > 24\t\t/* move up to 32 bytes at a time */\n+\t  && ! fixed_regs[5]\n+\t  && ! fixed_regs[6]\n+\t  && ! fixed_regs[7]\n+\t  && ! fixed_regs[8]\n+\t  && ! fixed_regs[9]\n+\t  && ! fixed_regs[10]\n+\t  && ! fixed_regs[11]\n+\t  && ! fixed_regs[12])\n+\t{\n+\t  move_bytes = (bytes > 32) ? 32 : bytes;\n+\t  gen_func.movstrsi = gen_movstrsi_8reg;\n+\t}\n+      else if (TARGET_STRING\n+\t       && bytes > 16\t/* move up to 24 bytes at a time */\n+\t       && ! fixed_regs[5]\n+\t       && ! fixed_regs[6]\n+\t       && ! fixed_regs[7]\n+\t       && ! fixed_regs[8]\n+\t       && ! fixed_regs[9]\n+\t       && ! fixed_regs[10])\n+\t{\n+\t  move_bytes = (bytes > 24) ? 24 : bytes;\n+\t  gen_func.movstrsi = gen_movstrsi_6reg;\n+\t}\n+      else if (TARGET_STRING\n+\t       && bytes > 8\t/* move up to 16 bytes at a time */\n+\t       && ! fixed_regs[5]\n+\t       && ! fixed_regs[6]\n+\t       && ! fixed_regs[7]\n+\t       && ! fixed_regs[8])\n+\t{\n+\t  move_bytes = (bytes > 16) ? 16 : bytes;\n+\t  gen_func.movstrsi = gen_movstrsi_4reg;\n+\t}\n+      else if (bytes >= 8 && TARGET_POWERPC64\n+\t       /* 64-bit loads and stores require word-aligned\n+\t\t  displacements.  */\n+\t       && (align >= 8 || (! STRICT_ALIGNMENT && align >= 4)))\n+\t{\n+\t  move_bytes = 8;\n+\t  mode = DImode;\n+\t  gen_func.mov = gen_movdi;\n+\t}\n+      else if (TARGET_STRING && bytes > 4 && !TARGET_POWERPC64)\n+\t{\t\t\t/* move up to 8 bytes at a time */\n+\t  move_bytes = (bytes > 8) ? 8 : bytes;\n+\t  gen_func.movstrsi = gen_movstrsi_2reg;\n+\t}\n+      else if (bytes >= 4 && (align >= 4 || ! STRICT_ALIGNMENT))\n+\t{\t\t\t/* move 4 bytes */\n+\t  move_bytes = 4;\n+\t  mode = SImode;\n+\t  gen_func.mov = gen_movsi;\n+\t}\n+      else if (bytes == 2 && (align >= 2 || ! STRICT_ALIGNMENT))\n+\t{\t\t\t/* move 2 bytes */\n+\t  move_bytes = 2;\n+\t  mode = HImode;\n+\t  gen_func.mov = gen_movhi;\n+\t}\n+      else if (TARGET_STRING && bytes > 1)\n+\t{\t\t\t/* move up to 4 bytes at a time */\n+\t  move_bytes = (bytes > 4) ? 4 : bytes;\n+\t  gen_func.movstrsi = gen_movstrsi_1reg;\n+\t}\n+      else /* move 1 byte at a time */\n+\t{\n+\t  move_bytes = 1;\n+\t  mode = QImode;\n+\t  gen_func.mov = gen_movqi;\n+\t}\n+      \n+      src = adjust_address (orig_src, mode, offset);\n+      dest = adjust_address (orig_dest, mode, offset);\n+      \n+      if (mode != BLKmode) \n+\t{\n+\t  rtx tmp_reg = gen_reg_rtx (mode);\n+\t  \n+\t  emit_insn ((*gen_func.mov) (tmp_reg, src));\n+\t  stores[num_reg++] = (*gen_func.mov) (dest, tmp_reg);\n+\t}\n \n-      for (offset = 0; bytes > 0; offset += move_bytes, bytes -= move_bytes)\n+      if (mode == BLKmode || num_reg >= MAX_MOVE_REG || bytes == move_bytes)\n \t{\n-\t  rtx (*gen_mov_func) PARAMS ((rtx, rtx));\n-\t  enum machine_mode mode;\n-\t  rtx src, dest, tmp_reg;\n+\t  int i;\n+\t  for (i = 0; i < num_reg; i++)\n+\t    emit_insn (stores[i]);\n+\t  num_reg = 0;\n+\t}\n \n-\t  /* Generate the appropriate load and store, saving the stores\n-\t     for later.  */\n-\t  if (bytes >= 8 && TARGET_POWERPC64\n-\t      /* 64-bit loads and stores require word-aligned\n-                 displacements.  */\n-\t      && (align >= 8 || (! STRICT_ALIGNMENT && align >= 4)))\n-\t    {\n-\t      move_bytes = 8;\n-\t      mode = DImode;\n-\t      gen_mov_func = gen_movdi;\n-\t    }\n-\t  else if (bytes >= 4 && (align >= 4 || ! STRICT_ALIGNMENT))\n-\t    {\n-\t      move_bytes = 4;\n-\t      mode = SImode;\n-\t      gen_mov_func = gen_movsi;\n-\t    }\n-\t  else if (bytes >= 2 && (align >= 2 || ! STRICT_ALIGNMENT))\n-\t    {\n-\t      move_bytes = 2;\n-\t      mode = HImode;\n-\t      gen_mov_func = gen_movhi;\n-\t    }\n-\t  else\n+      if (mode == BLKmode)\n+\t{\n+\t  /* Move the address into scratch registers.  The movstrsi\n+\t     patterns require zero offset.  */\n+\t  if (!REG_P (XEXP (src, 0)))\n \t    {\n-\t      move_bytes = 1;\n-\t      mode = QImode;\n-\t      gen_mov_func = gen_movqi;\n+\t      rtx src_reg = copy_addr_to_reg (XEXP (src, 0));\n+\t      src = replace_equiv_address (src, src_reg);\n \t    }\n-\n-\t  src = adjust_address (orig_src, mode, offset);\n-\t  dest = adjust_address (orig_dest, mode, offset);\n-\t  tmp_reg = gen_reg_rtx (mode);\n-\n-\t  emit_insn ((*gen_mov_func) (tmp_reg, src));\n-\t  stores[num_reg++] = (*gen_mov_func) (dest, tmp_reg);\n-\n-\t  if (num_reg >= MAX_MOVE_REG)\n+\t  set_mem_size (src, GEN_INT (move_bytes));\n+\t  \n+\t  if (!REG_P (XEXP (dest, 0)))\n \t    {\n-\t      for (i = 0; i < num_reg; i++)\n-\t\temit_insn (stores[i]);\n-\t      num_reg = 0;\n+\t      rtx dest_reg = copy_addr_to_reg (XEXP (dest, 0));\n+\t      dest = replace_equiv_address (dest, dest_reg);\n \t    }\n+\t  set_mem_size (dest, GEN_INT (move_bytes));\n+\t  \n+\t  emit_insn ((*gen_func.movstrsi) (dest, src,\n+\t\t\t\t\t   GEN_INT (move_bytes & 31),\n+\t\t\t\t\t   align_rtx));\n \t}\n-\n-      for (i = 0; i < num_reg; i++)\n-\temit_insn (stores[i]);\n     }\n \n   return 1;"}]}