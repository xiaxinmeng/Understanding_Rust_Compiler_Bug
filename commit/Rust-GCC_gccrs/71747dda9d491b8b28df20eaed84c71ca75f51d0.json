{"sha": "71747dda9d491b8b28df20eaed84c71ca75f51d0", "node_id": "C_kwDOANBUbNoAKDcxNzQ3ZGRhOWQ0OTFiOGIyOGRmMjBlYWVkODRjNzFjYTc1ZjUxZDA", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2022-08-13T00:04:38Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-09-06T07:14:23Z"}, "message": "[Ada] Enable lock free protected implementation by default\n\nIn the past, the Lock_Free aspect of a protected type (including an\nanonymous type) defaulted to False. In the case where an explicit\n\"Lock_Free => True\" aspect specification would be legal, the aspect now\ndefaults to True (which means that a lock-free implementation is used to\nimplement the type's protected operations); this is like the previous\nbehavior of the compiler with the -gnatd9 switch specified. Support for\nthe Lock_Free attribute (which should not be confused with the Lock_Free\naspect) is removed.\n\ngcc/ada/\n\n\t* debug.adb: Remove comment regarding the -gnatd9 switch.\n\t* doc/gnat_rm/implementation_defined_attributes.rst: Remove all\n\tmention of the Lock_Free attribute.\n\t* gnat_rm.texi, gnat_ugn.texi: Regenerate.\n\t* exp_attr.adb, sem_attr.adb: Remove all mention of the former\n\tAttribute_Lock_Free enumeration element of the Attribute_Id type.\n\t* sem_ch9.adb\n\t(Allows_Lock_Free_Implementation): Remove the Debug_Flag_9 test.\n\tReturn False in the case of a protected function whose result type\n\trequires use of the secondary stack.\n\t(Satisfies_Lock_Free_Requirements): This functions checks for\n\tcertain constructs and returns False if one is found. In the case\n\tof a protected function, there is no need to check to see if the\n\tprotected object is being modified. So it is ok to omit *some*\n\tchecks in the case of a protected function. But other checks which\n\tare required (e.g., the test for a reference to a variable that is\n\tnot part of the protected object) were being incorrectly omitted.\n\tThis could result in accepting \"Lock_Free => True\" aspect\n\tspecifications that should be rejected.\n\t* snames.adb-tmpl: Name_Lock_Free no longer requires special\n\ttreatment in Get_Pragma_Id or Is_Pragma_Name (because it is no\n\tlonger an attribute name).\n\t* snames.ads-tmpl: Move the declaration of Name_Lock_Free to\n\treflect the fact that it is no longer the name of an attribute.\n\tDelete Attribute_Lock_Free from the Attribute_Id enumeration type.", "tree": {"sha": "1312ebe331a83136add4714f4cd2f6c4a2a3c1ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1312ebe331a83136add4714f4cd2f6c4a2a3c1ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71747dda9d491b8b28df20eaed84c71ca75f51d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71747dda9d491b8b28df20eaed84c71ca75f51d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71747dda9d491b8b28df20eaed84c71ca75f51d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71747dda9d491b8b28df20eaed84c71ca75f51d0/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc737a6c2001e303a3509df7b1125b8e3d7ea651", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc737a6c2001e303a3509df7b1125b8e3d7ea651", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc737a6c2001e303a3509df7b1125b8e3d7ea651"}], "stats": {"total": 1425, "additions": 679, "deletions": 746}, "files": [{"sha": "dce460fc7012f7f73ce94e603269e0b5025cfd86", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71747dda9d491b8b28df20eaed84c71ca75f51d0/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71747dda9d491b8b28df20eaed84c71ca75f51d0/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=71747dda9d491b8b28df20eaed84c71ca75f51d0", "patch": "@@ -201,7 +201,7 @@ package body Debug is\n    --  d6   Default access unconstrained to thin pointers\n    --  d7   Suppress version/source stamp/compilation time for -gnatv/-gnatl\n    --  d8   Force opposite endianness in packed stuff\n-   --  d9   Allow lock free implementation\n+   --  d9\n \n    --  d.1  Enable unnesting of nested procedures\n    --  d.2  Allow statements in declarative part"}, {"sha": "c25e3d441582787c2eafb95a108cc8862565405f", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_attributes.rst", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71747dda9d491b8b28df20eaed84c71ca75f51d0/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71747dda9d491b8b28df20eaed84c71ca75f51d0/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst?ref=71747dda9d491b8b28df20eaed84c71ca75f51d0", "patch": "@@ -606,13 +606,6 @@ in this example:\n   end Gen;\n \n \n-Attribute Lock_Free\n-===================\n-.. index:: Lock_Free\n-\n-``P'Lock_Free``, where P is a protected object, returns True if a\n-pragma ``Lock_Free`` applies to P.\n-\n Attribute Loop_Entry\n ====================\n .. index:: Loop_Entry"}, {"sha": "2d4a4712f9d2a01f7f6fb8e30ea59d797703ddc3", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71747dda9d491b8b28df20eaed84c71ca75f51d0/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71747dda9d491b8b28df20eaed84c71ca75f51d0/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=71747dda9d491b8b28df20eaed84c71ca75f51d0", "patch": "@@ -7970,7 +7970,6 @@ package body Exp_Attr is\n          | Attribute_Large\n          | Attribute_Last_Valid\n          | Attribute_Library_Level\n-         | Attribute_Lock_Free\n          | Attribute_Machine_Emax\n          | Attribute_Machine_Emin\n          | Attribute_Machine_Mantissa"}, {"sha": "1eab1090f712ba07d34270613c2881f2e53e684d", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 486, "deletions": 498, "changes": 984, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71747dda9d491b8b28df20eaed84c71ca75f51d0/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71747dda9d491b8b28df20eaed84c71ca75f51d0/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=71747dda9d491b8b28df20eaed84c71ca75f51d0"}, {"sha": "8074cecc887960518410464077b756de39ecd683", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71747dda9d491b8b28df20eaed84c71ca75f51d0/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71747dda9d491b8b28df20eaed84c71ca75f51d0/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=71747dda9d491b8b28df20eaed84c71ca75f51d0", "patch": "@@ -29317,8 +29317,8 @@ to permit their use in free software.\n \n @printindex ge\n \n-@anchor{cf}@w{                              }\n @anchor{gnat_ugn/gnat_utility_programs switches-related-to-project-files}@w{                              }\n+@anchor{cf}@w{                              }\n \n @c %**end of body\n @bye"}, {"sha": "86c7d0f5c9eda4dcaa079bacbe97480866c0f1b6", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 43, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71747dda9d491b8b28df20eaed84c71ca75f51d0/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71747dda9d491b8b28df20eaed84c71ca75f51d0/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=71747dda9d491b8b28df20eaed84c71ca75f51d0", "patch": "@@ -4697,19 +4697,6 @@ package body Sem_Attr is\n \n          Set_Etype (N, Standard_Boolean);\n \n-      ---------------\n-      -- Lock_Free --\n-      ---------------\n-\n-      when Attribute_Lock_Free =>\n-         Check_E0;\n-         Set_Etype (N, Standard_Boolean);\n-\n-         if not Is_Protected_Type (P_Type) then\n-            Error_Attr_P\n-              (\"prefix of % attribute must be a protected object\");\n-         end if;\n-\n       ----------------\n       -- Loop_Entry --\n       ----------------\n@@ -8338,15 +8325,6 @@ package body Sem_Attr is\n \n             return;\n \n-         --  For Lock_Free, we apply the attribute to the type of the object.\n-         --  This is allowed since we have already verified that the type is a\n-         --  protected type.\n-\n-         elsif Id = Attribute_Lock_Free then\n-            P_Entity := Etype (P);\n-\n-         --  No other attributes for objects are folded\n-\n          else\n             Check_Expressions;\n             return;\n@@ -8476,7 +8454,6 @@ package body Sem_Attr is\n              Id = Attribute_Has_Access_Values            or else\n              Id = Attribute_Has_Discriminants            or else\n              Id = Attribute_Has_Tagged_Values            or else\n-             Id = Attribute_Lock_Free                    or else\n              Id = Attribute_Preelaborable_Initialization or else\n              Id = Attribute_Type_Class                   or else\n              Id = Attribute_Unconstrained_Array          or else\n@@ -8595,7 +8572,7 @@ package body Sem_Attr is\n       --  only the First, Last and Length attributes are possibly static.\n \n       --  Atomic_Always_Lock_Free, Definite, Descriptor_Size, Has_Access_Values\n-      --  Has_Discriminants, Has_Tagged_Values, Lock_Free, Type_Class, and\n+      --  Has_Discriminants, Has_Tagged_Values, Type_Class, and\n       --  Unconstrained_Array are again exceptions, because they apply as well\n       --  to unconstrained types.\n \n@@ -8614,7 +8591,6 @@ package body Sem_Attr is\n             Id = Attribute_Has_Access_Values            or else\n             Id = Attribute_Has_Discriminants            or else\n             Id = Attribute_Has_Tagged_Values            or else\n-            Id = Attribute_Lock_Free                    or else\n             Id = Attribute_Preelaborable_Initialization or else\n             Id = Attribute_Type_Class                   or else\n             Id = Attribute_Unconstrained_Array          or else\n@@ -9315,24 +9291,6 @@ package body Sem_Attr is\n                True);\n          end if;\n \n-      ---------------\n-      -- Lock_Free --\n-      ---------------\n-\n-      when Attribute_Lock_Free => Lock_Free : declare\n-         V : constant Entity_Id := Boolean_Literals (Uses_Lock_Free (P_Type));\n-\n-      begin\n-         Rewrite (N, New_Occurrence_Of (V, Loc));\n-\n-         --  Analyze and resolve as boolean. Note that this attribute is a\n-         --  static attribute in GNAT.\n-\n-         Analyze_And_Resolve (N, Standard_Boolean);\n-         Static := True;\n-         Set_Is_Static_Expression (N);\n-      end Lock_Free;\n-\n       ----------\n       -- Last --\n       ----------"}, {"sha": "7f4f65e93a3400797d956be724fd23f3126a7181", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 184, "deletions": 179, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71747dda9d491b8b28df20eaed84c71ca75f51d0/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71747dda9d491b8b28df20eaed84c71ca75f51d0/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=71747dda9d491b8b28df20eaed84c71ca75f51d0", "patch": "@@ -27,7 +27,6 @@ with Aspects;        use Aspects;\n with Atree;          use Atree;\n with Checks;         use Checks;\n with Contracts;      use Contracts;\n-with Debug;          use Debug;\n with Einfo;          use Einfo;\n with Einfo.Entities; use Einfo.Entities;\n with Einfo.Utils;    use Einfo.Utils;\n@@ -140,14 +139,6 @@ package body Sem_Ch9 is\n       pragma Assert\n         (Nkind (N) in N_Protected_Type_Declaration | N_Protected_Body);\n \n-      --  The lock-free implementation is currently enabled through a debug\n-      --  flag. When Lock_Free_Given is True, an aspect Lock_Free forces the\n-      --  lock-free implementation. In that case, the debug flag is not needed.\n-\n-      if not Lock_Free_Given and then not Debug_Flag_9 then\n-         return False;\n-      end if;\n-\n       --  Get the number of errors detected by the compiler so far\n \n       if Lock_Free_Given then\n@@ -215,6 +206,27 @@ package body Sem_Ch9 is\n                         Next (Par);\n                      end loop;\n                   end;\n+\n+               elsif Nkind (Decl) = N_Subprogram_Declaration\n+                 and then\n+                   Nkind (Specification (Decl)) = N_Function_Specification\n+                 and then\n+                   Nkind (Result_Definition (Specification (Decl)))\n+                     in N_Has_Entity\n+                 and then\n+                   Needs_Secondary_Stack\n+                     (Entity (Result_Definition (Specification (Decl))))\n+               then\n+                  if Lock_Free_Given then\n+                     --  Message text is imprecise; \"unconstrained\" is\n+                     --  similar to \"needs secondary stack\" but not identical.\n+                     Error_Msg_N\n+                       (\"unconstrained function result subtype not allowed \"\n+                        & \"when Lock_Free given\",\n+                        Decl);\n+                  else\n+                     return False;\n+                  end if;\n                end if;\n \n                --  Examine private declarations after visible declarations\n@@ -254,11 +266,6 @@ package body Sem_Ch9 is\n             function Satisfies_Lock_Free_Requirements\n               (Sub_Body : Node_Id) return Boolean\n             is\n-               Is_Procedure : constant Boolean    :=\n-                                Ekind (Corresponding_Spec (Sub_Body)) =\n-                                  E_Procedure;\n-               --  Indicates if Sub_Body is a procedure body\n-\n                Comp : Entity_Id := Empty;\n                --  Track the current component which the body references\n \n@@ -338,222 +345,220 @@ package body Sem_Ch9 is\n                --  Start of processing for Check_Node\n \n                begin\n-                  if Is_Procedure then\n-                     --  Allocators restricted\n-\n-                     if Kind = N_Allocator then\n-                        if Lock_Free_Given then\n-                           Error_Msg_N (\"allocator not allowed\", N);\n-                           return Skip;\n-                        end if;\n+                  --  Allocators restricted\n \n-                        return Abandon;\n+                  if Kind = N_Allocator then\n+                     if Lock_Free_Given then\n+                        Error_Msg_N (\"allocator not allowed\", N);\n+                        return Skip;\n+                     end if;\n \n-                     --  Aspects Address, Export and Import restricted\n+                     return Abandon;\n \n-                     elsif Kind = N_Aspect_Specification then\n-                        declare\n-                           Asp_Name : constant Name_Id   :=\n-                                        Chars (Identifier (N));\n-                           Asp_Id   : constant Aspect_Id :=\n-                                        Get_Aspect_Id (Asp_Name);\n+                  --  Aspects Address, Export and Import restricted\n \n-                        begin\n-                           if Asp_Id = Aspect_Address or else\n-                              Asp_Id = Aspect_Export  or else\n-                              Asp_Id = Aspect_Import\n-                           then\n-                              Error_Msg_Name_1 := Asp_Name;\n+                  elsif Kind = N_Aspect_Specification then\n+                     declare\n+                        Asp_Name : constant Name_Id   :=\n+                                     Chars (Identifier (N));\n+                        Asp_Id   : constant Aspect_Id :=\n+                                     Get_Aspect_Id (Asp_Name);\n \n-                              if Lock_Free_Given then\n-                                 Error_Msg_N (\"aspect% not allowed\", N);\n-                                 return Skip;\n-                              end if;\n+                     begin\n+                        if Asp_Id = Aspect_Address or else\n+                           Asp_Id = Aspect_Export  or else\n+                           Asp_Id = Aspect_Import\n+                        then\n+                           Error_Msg_Name_1 := Asp_Name;\n \n-                              return Abandon;\n+                           if Lock_Free_Given then\n+                              Error_Msg_N (\"aspect% not allowed\", N);\n+                              return Skip;\n                            end if;\n-                        end;\n \n-                     --  Address attribute definition clause restricted\n+                           return Abandon;\n+                        end if;\n+                     end;\n \n-                     elsif Kind = N_Attribute_Definition_Clause\n-                       and then Get_Attribute_Id (Chars (N)) =\n-                                  Attribute_Address\n-                     then\n-                        Error_Msg_Name_1 := Chars (N);\n+                  --  Address attribute definition clause restricted\n \n-                        if Lock_Free_Given then\n-                           if From_Aspect_Specification (N) then\n-                              Error_Msg_N (\"aspect% not allowed\", N);\n-                           else\n-                              Error_Msg_N (\"% clause not allowed\", N);\n-                           end if;\n+                  elsif Kind = N_Attribute_Definition_Clause\n+                    and then Get_Attribute_Id (Chars (N)) =\n+                               Attribute_Address\n+                  then\n+                     Error_Msg_Name_1 := Chars (N);\n \n-                           return Skip;\n+                     if Lock_Free_Given then\n+                        if From_Aspect_Specification (N) then\n+                           Error_Msg_N (\"aspect% not allowed\", N);\n+                        else\n+                           Error_Msg_N (\"% clause not allowed\", N);\n                         end if;\n \n-                        return Abandon;\n+                        return Skip;\n+                     end if;\n \n-                     --  Non-static Attribute references that don't denote a\n-                     --  static function restricted.\n+                     return Abandon;\n \n-                     elsif Kind = N_Attribute_Reference\n-                       and then not Is_OK_Static_Expression (N)\n-                       and then not Is_Static_Function (N)\n-                     then\n-                        if Lock_Free_Given then\n-                           Error_Msg_N\n-                             (\"non-static attribute reference not allowed\", N);\n-                           return Skip;\n-                        end if;\n+                  --  Non-static Attribute references that don't denote a\n+                  --  static function restricted.\n \n-                        return Abandon;\n+                  elsif Kind = N_Attribute_Reference\n+                    and then not Is_OK_Static_Expression (N)\n+                    and then not Is_Static_Function (N)\n+                  then\n+                     if Lock_Free_Given then\n+                        Error_Msg_N\n+                          (\"non-static attribute reference not allowed\", N);\n+                        return Skip;\n+                     end if;\n \n-                     --  Delay statements restricted\n+                     return Abandon;\n \n-                     elsif Kind in N_Delay_Statement then\n-                        if Lock_Free_Given then\n-                           Error_Msg_N (\"delay not allowed\", N);\n-                           return Skip;\n-                        end if;\n+                  --  Delay statements restricted\n \n-                        return Abandon;\n+                  elsif Kind in N_Delay_Statement then\n+                     if Lock_Free_Given then\n+                        Error_Msg_N (\"delay not allowed\", N);\n+                        return Skip;\n+                     end if;\n \n-                     --  Dereferences of access values restricted\n+                     return Abandon;\n \n-                     elsif Kind = N_Explicit_Dereference\n-                       or else (Kind = N_Selected_Component\n-                                 and then Is_Access_Type (Etype (Prefix (N))))\n-                     then\n-                        if Lock_Free_Given then\n-                           Error_Msg_N\n-                             (\"dereference of access value not allowed\", N);\n-                           return Skip;\n-                        end if;\n+                  --  Dereferences of access values restricted\n \n-                        return Abandon;\n+                  elsif Kind = N_Explicit_Dereference\n+                    or else (Kind = N_Selected_Component\n+                              and then Is_Access_Type (Etype (Prefix (N))))\n+                  then\n+                     if Lock_Free_Given then\n+                        Error_Msg_N\n+                          (\"dereference of access value not allowed\", N);\n+                        return Skip;\n+                     end if;\n \n-                     --  Non-static function calls restricted\n+                     return Abandon;\n \n-                     elsif Kind = N_Function_Call\n-                       and then not Is_OK_Static_Expression (N)\n-                     then\n-                        if Lock_Free_Given then\n-                           Error_Msg_N\n-                             (\"non-static function call not allowed\", N);\n-                           return Skip;\n-                        end if;\n+                  --  Non-static function calls restricted\n \n-                        return Abandon;\n+                  elsif Kind = N_Function_Call\n+                    and then not Is_OK_Static_Expression (N)\n+                  then\n+                     if Lock_Free_Given then\n+                        Error_Msg_N\n+                          (\"non-static function call not allowed\", N);\n+                        return Skip;\n+                     end if;\n \n-                     --  Goto statements restricted\n+                     return Abandon;\n \n-                     elsif Kind = N_Goto_Statement then\n-                        if Lock_Free_Given then\n-                           Error_Msg_N (\"goto statement not allowed\", N);\n-                           return Skip;\n-                        end if;\n+                  --  Goto statements restricted\n \n-                        return Abandon;\n+                  elsif Kind = N_Goto_Statement then\n+                     if Lock_Free_Given then\n+                        Error_Msg_N (\"goto statement not allowed\", N);\n+                        return Skip;\n+                     end if;\n \n-                     --  References\n+                     return Abandon;\n \n-                     elsif Kind = N_Identifier\n-                       and then Present (Entity (N))\n-                     then\n-                        declare\n-                           Id     : constant Entity_Id := Entity (N);\n-                           Sub_Id : constant Entity_Id :=\n-                                      Corresponding_Spec (Sub_Body);\n+                  --  References\n \n-                        begin\n-                           --  Prohibit references to non-constant entities\n-                           --  outside the protected subprogram scope.\n-\n-                           if Ekind (Id) in Assignable_Kind\n-                             and then not\n-                               Scope_Within_Or_Same (Scope (Id), Sub_Id)\n-                             and then not\n-                               Scope_Within_Or_Same\n-                                 (Scope (Id),\n-                                  Protected_Body_Subprogram (Sub_Id))\n-                           then\n-                              if Lock_Free_Given then\n-                                 Error_Msg_NE\n-                                   (\"reference to global variable& not \" &\n-                                    \"allowed\", N, Id);\n-                                 return Skip;\n-                              end if;\n+                  elsif Kind = N_Identifier\n+                    and then Present (Entity (N))\n+                  then\n+                     declare\n+                        Id     : constant Entity_Id := Entity (N);\n+                        Sub_Id : constant Entity_Id :=\n+                                   Corresponding_Spec (Sub_Body);\n \n-                              return Abandon;\n+                     begin\n+                        --  Prohibit references to non-constant entities\n+                        --  outside the protected subprogram scope.\n+\n+                        if Ekind (Id) in Assignable_Kind\n+                          and then not\n+                            Scope_Within_Or_Same (Scope (Id), Sub_Id)\n+                          and then not\n+                            Scope_Within_Or_Same\n+                              (Scope (Id),\n+                               Protected_Body_Subprogram (Sub_Id))\n+                        then\n+                           if Lock_Free_Given then\n+                              Error_Msg_NE\n+                                (\"reference to global variable& not \" &\n+                                 \"allowed\", N, Id);\n+                              return Skip;\n                            end if;\n-                        end;\n \n-                     --  Loop statements restricted\n-\n-                     elsif Kind = N_Loop_Statement then\n-                        if Lock_Free_Given then\n-                           Error_Msg_N (\"loop not allowed\", N);\n-                           return Skip;\n+                           return Abandon;\n                         end if;\n+                     end;\n \n-                        return Abandon;\n+                  --  Loop statements restricted\n \n-                     --  Pragmas Export and Import restricted\n+                  elsif Kind = N_Loop_Statement then\n+                     if Lock_Free_Given then\n+                        Error_Msg_N (\"loop not allowed\", N);\n+                        return Skip;\n+                     end if;\n \n-                     elsif Kind = N_Pragma then\n-                        declare\n-                           Prag_Name : constant Name_Id   :=\n-                             Pragma_Name (N);\n-                           Prag_Id   : constant Pragma_Id :=\n-                             Get_Pragma_Id (Prag_Name);\n+                     return Abandon;\n \n-                        begin\n-                           if Prag_Id = Pragma_Export\n-                             or else Prag_Id = Pragma_Import\n-                           then\n-                              Error_Msg_Name_1 := Prag_Name;\n+                  --  Pragmas Export and Import restricted\n \n-                              if Lock_Free_Given then\n-                                 if From_Aspect_Specification (N) then\n-                                    Error_Msg_N (\"aspect% not allowed\", N);\n-                                 else\n-                                    Error_Msg_N (\"pragma% not allowed\", N);\n-                                 end if;\n+                  elsif Kind = N_Pragma then\n+                     declare\n+                        Prag_Name : constant Name_Id   :=\n+                          Pragma_Name (N);\n+                        Prag_Id   : constant Pragma_Id :=\n+                          Get_Pragma_Id (Prag_Name);\n+\n+                     begin\n+                        if Prag_Id = Pragma_Export\n+                          or else Prag_Id = Pragma_Import\n+                        then\n+                           Error_Msg_Name_1 := Prag_Name;\n \n-                                 return Skip;\n+                           if Lock_Free_Given then\n+                              if From_Aspect_Specification (N) then\n+                                 Error_Msg_N (\"aspect% not allowed\", N);\n+                              else\n+                                 Error_Msg_N (\"pragma% not allowed\", N);\n                               end if;\n \n-                              return Abandon;\n+                              return Skip;\n                            end if;\n-                        end;\n \n-                     --  Procedure call statements restricted\n-\n-                     elsif Kind = N_Procedure_Call_Statement then\n-                        if Lock_Free_Given then\n-                           Error_Msg_N (\"procedure call not allowed\", N);\n-                           return Skip;\n+                           return Abandon;\n                         end if;\n+                     end;\n \n-                        return Abandon;\n+                  --  Procedure call statements restricted\n \n-                     --  Quantified expression restricted. Note that we have\n-                     --  to check the original node as well, since at this\n-                     --  stage, it may have been rewritten.\n+                  elsif Kind = N_Procedure_Call_Statement then\n+                     if Lock_Free_Given then\n+                        Error_Msg_N (\"procedure call not allowed\", N);\n+                        return Skip;\n+                     end if;\n \n-                     elsif Kind = N_Quantified_Expression\n-                       or else\n-                         Nkind (Original_Node (N)) = N_Quantified_Expression\n-                     then\n-                        if Lock_Free_Given then\n-                           Error_Msg_N\n-                             (\"quantified expression not allowed\", N);\n-                           return Skip;\n-                        end if;\n+                     return Abandon;\n+\n+                  --  Quantified expression restricted. Note that we have\n+                  --  to check the original node as well, since at this\n+                  --  stage, it may have been rewritten.\n \n-                        return Abandon;\n+                  elsif Kind = N_Quantified_Expression\n+                    or else\n+                      Nkind (Original_Node (N)) = N_Quantified_Expression\n+                  then\n+                     if Lock_Free_Given then\n+                        Error_Msg_N\n+                          (\"quantified expression not allowed\", N);\n+                        return Skip;\n                      end if;\n+\n+                     return Abandon;\n                   end if;\n \n                   --  A protected subprogram (function or procedure) may"}, {"sha": "9b087e6cd62c80a8c22d595c67c5fd30263f6d25", "filename": "gcc/ada/snames.adb-tmpl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71747dda9d491b8b28df20eaed84c71ca75f51d0/gcc%2Fada%2Fsnames.adb-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71747dda9d491b8b28df20eaed84c71ca75f51d0/gcc%2Fada%2Fsnames.adb-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb-tmpl?ref=71747dda9d491b8b28df20eaed84c71ca75f51d0", "patch": "@@ -256,8 +256,6 @@ package body Snames is\n             return Pragma_Interface;\n          when Name_Interrupt_Priority               =>\n             return Pragma_Interrupt_Priority;\n-         when Name_Lock_Free                        =>\n-            return Pragma_Lock_Free;\n          when Name_Preelaborable_Initialization     =>\n             return Pragma_Preelaborable_Initialization;\n          when Name_Priority                         =>\n@@ -489,7 +487,6 @@ package body Snames is\n         or else N = Name_Fast_Math\n         or else N = Name_Interface\n         or else N = Name_Interrupt_Priority\n-        or else N = Name_Lock_Free\n         or else N = Name_Preelaborable_Initialization\n         or else N = Name_Priority\n         or else N = Name_Secondary_Stack_Size"}, {"sha": "ee9972d4372cb8422e2d43c5f67839a1d6996ef8", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71747dda9d491b8b28df20eaed84c71ca75f51d0/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71747dda9d491b8b28df20eaed84c71ca75f51d0/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=71747dda9d491b8b28df20eaed84c71ca75f51d0", "patch": "@@ -600,12 +600,7 @@ package Snames is\n    Name_Linker_Options                 : constant Name_Id := N + $;\n    Name_Linker_Section                 : constant Name_Id := N + $; -- GNAT\n    Name_List                           : constant Name_Id := N + $;\n-\n-   --  Note: Lock_Free is not in this list because its name matches the name of\n-   --  the corresponding attribute. However, it is included in the definition\n-   --  of the type Pragma_Id and the functions Get_Pragma_Id and Is_Pragma_Name\n-   --  correctly recognize and process Lock_Free. Lock_Free is a GNAT pragma.\n-\n+   Name_Lock_Free                      : constant Name_Id := N + $; -- GNAT\n    Name_Loop_Invariant                 : constant Name_Id := N + $; -- GNAT\n    Name_Loop_Optimize                  : constant Name_Id := N + $; -- GNAT\n    Name_Loop_Variant                   : constant Name_Id := N + $; -- GNAT\n@@ -978,7 +973,6 @@ package Snames is\n    Name_Leading_Part                   : constant Name_Id := N + $;\n    Name_Length                         : constant Name_Id := N + $;\n    Name_Library_Level                  : constant Name_Id := N + $; -- GNAT\n-   Name_Lock_Free                      : constant Name_Id := N + $; -- GNAT\n    Name_Loop_Entry                     : constant Name_Id := N + $; -- GNAT\n    Name_Machine_Emax                   : constant Name_Id := N + $;\n    Name_Machine_Emin                   : constant Name_Id := N + $;\n@@ -1503,7 +1497,6 @@ package Snames is\n       Attribute_Leading_Part,\n       Attribute_Length,\n       Attribute_Library_Level,\n-      Attribute_Lock_Free,\n       Attribute_Loop_Entry,\n       Attribute_Machine_Emax,\n       Attribute_Machine_Emin,\n@@ -1889,6 +1882,7 @@ package Snames is\n       Pragma_Linker_Options,\n       Pragma_Linker_Section,\n       Pragma_List,\n+      Pragma_Lock_Free,\n       Pragma_Loop_Invariant,\n       Pragma_Loop_Optimize,\n       Pragma_Loop_Variant,\n@@ -1981,7 +1975,6 @@ package Snames is\n       Pragma_Fast_Math,\n       Pragma_Interface,\n       Pragma_Interrupt_Priority,\n-      Pragma_Lock_Free,\n       Pragma_Preelaborable_Initialization,\n       Pragma_Priority,\n       Pragma_Secondary_Stack_Size,\n@@ -2073,10 +2066,10 @@ package Snames is\n    function Is_Pragma_Name (N : Name_Id) return Boolean;\n    --  Test to see if the name N is the name of a recognized pragma. Note\n    --  that pragmas CPU, Dispatching_Domain, Fast_Math, Interrupt_Priority,\n-   --  Lock_Free, Priority, Storage_Size, and Storage_Unit are recognized\n-   --  as pragmas by this function even though their names are separate from\n-   --  the other pragma names. For this reason, clients should always use\n-   --  this function, rather than do range tests on Name_Id values.\n+   --  Priority, Storage_Size, and Storage_Unit are recognized as pragmas by\n+   --  this function even though their names are separate from the other\n+   --  pragma names. For this reason, clients should always use this function,\n+   --  rather than do range tests on Name_Id values.\n \n    function Is_Configuration_Pragma_Name (N : Name_Id) return Boolean;\n    --  Test to see if the name N is the name of a recognized configuration"}]}