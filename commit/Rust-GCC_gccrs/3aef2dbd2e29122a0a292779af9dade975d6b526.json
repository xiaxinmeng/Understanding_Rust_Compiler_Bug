{"sha": "3aef2dbd2e29122a0a292779af9dade975d6b526", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FlZjJkYmQyZTI5MTIyYTBhMjkyNzc5YWY5ZGFkZTk3NWQ2YjUyNg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-04-27T13:43:42Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-04-27T13:43:42Z"}, "message": "re PR tree-optimization/30965 (Fails to tree-combine conditions in COND_EXPRs)\n\n2007-04-27  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/30965\n\tPR tree-optimization/30978\n\t* Makefile.in (tree-ssa-forwprop.o): Depend on $(FLAGS_H).\n        * tree-ssa-forwprop.c (forward_propagate_into_cond_1): Remove.\n        (find_equivalent_equality_comparison): Likewise.\n        (simplify_cond): Likewise.\n        (get_prop_source_stmt): New helper.\n        (get_prop_dest_stmt): Likewise.\n\t(can_propagate_from): Likewise.\n\t(remove_prop_source_from_use): Likewise.\n        (combine_cond_expr_cond): Likewise.\n        (forward_propagate_comparison): New function.\n        (forward_propagate_into_cond): Rewrite to use fold for\n        tree combining.\n\t(tree_ssa_forward_propagate_single_use_vars): Call\n\tforward_propagate_comparison to propagate comparisons.\n\n\t* gcc.dg/tree-ssa/pr30978.c: New testcase.\n\t* gcc.dg/tree-ssa/bool-3.c: Remove XFAIL, explain why.\n\t* gcc.dg/tree-ssa/ssa-fre-4.c: Use char instead of bool\n\t* gcc.dg/strict-overflow-5.c: Adjust tree dump scanning.\n\nFrom-SVN: r124217", "tree": {"sha": "3c5a5da4c9f306873b3bddd33f3d5953550b2ec9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c5a5da4c9f306873b3bddd33f3d5953550b2ec9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3aef2dbd2e29122a0a292779af9dade975d6b526", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aef2dbd2e29122a0a292779af9dade975d6b526", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aef2dbd2e29122a0a292779af9dade975d6b526", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aef2dbd2e29122a0a292779af9dade975d6b526/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "891fc5e9f1b6a88f9147b68e670f0cc172acfe21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/891fc5e9f1b6a88f9147b68e670f0cc172acfe21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/891fc5e9f1b6a88f9147b68e670f0cc172acfe21"}], "stats": {"total": 804, "additions": 417, "deletions": 387}, "files": [{"sha": "34b05fefa0a618c00153a156932fe3dccab2af20", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aef2dbd2e29122a0a292779af9dade975d6b526/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aef2dbd2e29122a0a292779af9dade975d6b526/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3aef2dbd2e29122a0a292779af9dade975d6b526", "patch": "@@ -1,3 +1,22 @@\n+2007-04-27  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/30965\n+\tPR tree-optimization/30978\n+\t* Makefile.in (tree-ssa-forwprop.o): Depend on $(FLAGS_H).\n+        * tree-ssa-forwprop.c (forward_propagate_into_cond_1): Remove.\n+        (find_equivalent_equality_comparison): Likewise.\n+        (simplify_cond): Likewise.\n+        (get_prop_source_stmt): New helper.\n+        (get_prop_dest_stmt): Likewise.\n+\t(can_propagate_from): Likewise.\n+\t(remove_prop_source_from_use): Likewise.\n+        (combine_cond_expr_cond): Likewise.\n+        (forward_propagate_comparison): New function.\n+        (forward_propagate_into_cond): Rewrite to use fold for\n+        tree combining.\n+\t(tree_ssa_forward_propagate_single_use_vars): Call\n+\tforward_propagate_comparison to propagate comparisons.\n+\n 2007-04-27  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/31715"}, {"sha": "8856c6415793dce4c4ab753af41257ed7394ef6f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aef2dbd2e29122a0a292779af9dade975d6b526/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aef2dbd2e29122a0a292779af9dade975d6b526/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3aef2dbd2e29122a0a292779af9dade975d6b526", "patch": "@@ -1934,7 +1934,7 @@ tree-ssa-dse.o : tree-ssa-dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n tree-ssa-forwprop.o : tree-ssa-forwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) $(DIAGNOSTIC_H) $(TIMEVAR_H) \\\n-   langhooks.h\n+   langhooks.h $(FLAGS_H)\n tree-ssa-phiopt.o : tree-ssa-phiopt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) langhooks.h $(FLAGS_H) \\"}, {"sha": "49ed2ba7f837e760e43f1b92b50bc4d8b54ba5b8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aef2dbd2e29122a0a292779af9dade975d6b526/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aef2dbd2e29122a0a292779af9dade975d6b526/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3aef2dbd2e29122a0a292779af9dade975d6b526", "patch": "@@ -1,3 +1,12 @@\n+2007-04-27  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/30965\n+\tPR tree-optimization/30978\n+\t* gcc.dg/tree-ssa/pr30978.c: New testcase.\n+\t* gcc.dg/tree-ssa/bool-3.c: Remove XFAIL, explain why.\n+\t* gcc.dg/tree-ssa/ssa-fre-4.c: Use char instead of bool\n+\t* gcc.dg/strict-overflow-5.c: Adjust tree dump scanning.\n+\n 2007-04-27  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/31715"}, {"sha": "816bfe440f0cc7bdd1eef91baa058f36d81fc628", "filename": "gcc/testsuite/gcc.dg/strict-overflow-5.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aef2dbd2e29122a0a292779af9dade975d6b526/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aef2dbd2e29122a0a292779af9dade975d6b526/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-5.c?ref=3aef2dbd2e29122a0a292779af9dade975d6b526", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fstrict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+/* { dg-options \"-fstrict-overflow -O2 -fdump-tree-optimized\" } */\n \n /* We can only unroll when using strict overflow semantics.  */\n \n@@ -14,6 +14,6 @@ int foo (int i)\n   return r;\n }\n \n-/* { dg-final { scan-tree-dump-times \"r = 3\" 1 \"final_cleanup\" } } */\n-/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump \"return 3\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n "}, {"sha": "8fa2a57c4128b2f37e9b46811762396826da35c7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/bool-3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aef2dbd2e29122a0a292779af9dade975d6b526/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbool-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aef2dbd2e29122a0a292779af9dade975d6b526/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbool-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbool-3.c?ref=3aef2dbd2e29122a0a292779af9dade975d6b526", "patch": "@@ -11,8 +11,8 @@ int f(_Bool x)\n   return y;\n }\n \n-/* There should be no == 0. Though PHI-OPT or invert_truth does not\n-   fold its tree.  */\n-/* { dg-final { scan-tree-dump-times \"== 0\" 0 \"optimized\" { xfail *-*-* } } } */\n+/* There should be no == 0.  Though PHI-OPT or invert_truth does not\n+   fold its tree forwprop is able to clean up the mess.  */\n+/* { dg-final { scan-tree-dump-times \"== 0\" 0 \"optimized\" } } */\n \n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "5444e2d197c440deffad460a1b24467ac2662a2c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr30978.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aef2dbd2e29122a0a292779af9dade975d6b526/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr30978.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aef2dbd2e29122a0a292779af9dade975d6b526/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr30978.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr30978.c?ref=3aef2dbd2e29122a0a292779af9dade975d6b526", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+int foo(int a)\n+{\n+  unsigned int b = a > 0;\n+  char c = b;\n+  _Bool d = c == 0;\n+  int e = !d;\n+  return e;\n+}\n+\n+/* { dg-final { scan-tree-dump \"return a > 0;\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "bc62255d6666908c891ac8b0d8e8f7f8e3015373", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-4.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aef2dbd2e29122a0a292779af9dade975d6b526/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aef2dbd2e29122a0a292779af9dade975d6b526/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-4.c?ref=3aef2dbd2e29122a0a292779af9dade975d6b526", "patch": "@@ -3,13 +3,12 @@\n \n /* From PR21608.  */\n \n-#define bool _Bool\n-static inline bool wrap(bool f) { return f; }\n-bool bar(bool f)\n+static inline char wrap(char f) { return f; }\n+char bar(char f)\n {\n         return wrap(f);\n }\n \n-/* { dg-final { scan-tree-dump \"Replaced \\\\\\(_Bool\\\\\\) .*with \" \"fre\" } } */\n+/* { dg-final { scan-tree-dump \"Replaced \\\\\\(char\\\\\\) .*with \" \"fre\" } } */\n /* { dg-final { scan-tree-dump \"Replaced \\\\\\(int\\\\\\) .*with \" \"fre\" } } */\n /* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "08bc5ff31c33a9b176ae36331a6fa44803f20ef6", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 365, "deletions": 376, "changes": 741, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aef2dbd2e29122a0a292779af9dade975d6b526/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aef2dbd2e29122a0a292779af9dade975d6b526/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=3aef2dbd2e29122a0a292779af9dade975d6b526", "patch": "@@ -33,6 +33,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"tree-pass.h\"\n #include \"tree-dump.h\"\n #include \"langhooks.h\"\n+#include \"flags.h\"\n \n /* This pass propagates the RHS of assignment statements into use\n    sites of the LHS of the assignment.  It's basically a specialized\n@@ -155,424 +156,303 @@ static bool forward_propagate_addr_expr (tree name, tree rhs);\n static bool cfg_changed;\n \n \n-/* Given an SSA_NAME VAR, return true if and only if VAR is defined by\n-   a comparison.  */\n-\n-static bool\n-ssa_name_defined_by_comparison_p (tree var)\n-{\n-  tree def = SSA_NAME_DEF_STMT (var);\n-\n-  if (TREE_CODE (def) == GIMPLE_MODIFY_STMT)\n-    {\n-      tree rhs = GIMPLE_STMT_OPERAND (def, 1);\n-      return COMPARISON_CLASS_P (rhs);\n-    }\n-\n-  return 0;\n-}\n-\n-/* Forward propagate a single-use variable into COND once.  Return a\n-   new condition if successful.  Return NULL_TREE otherwise.  */\n+/* Get the next statement we can propagate NAMEs value into skipping\n+   trivial copies.  Returns the statement that is suitable as a\n+   propagation destination or NULL_TREE if there is no such one.\n+   This only returns destinations in a single-use chain.  FINAL_NAME_P\n+   if non-NULL is written to the ssa name that represents the use.  */\n \n static tree\n-forward_propagate_into_cond_1 (tree cond, tree *test_var_p)\n+get_prop_dest_stmt (tree name, tree *final_name_p)\n {\n-  tree new_cond = NULL_TREE;\n-  enum tree_code cond_code = TREE_CODE (cond);\n-  tree test_var = NULL_TREE;\n-  tree def;\n-  tree def_rhs;\n-\n-  /* If the condition is not a lone variable or an equality test of an\n-     SSA_NAME against an integral constant, then we do not have an\n-     optimizable case.\n-\n-     Note these conditions also ensure the COND_EXPR has no\n-     virtual operands or other side effects.  */\n-  if (cond_code != SSA_NAME\n-      && !((cond_code == EQ_EXPR || cond_code == NE_EXPR)\n-\t   && TREE_CODE (TREE_OPERAND (cond, 0)) == SSA_NAME\n-\t   && CONSTANT_CLASS_P (TREE_OPERAND (cond, 1))\n-\t   && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (cond, 1)))))\n-    return NULL_TREE;\n+  use_operand_p use;\n+  tree use_stmt;\n \n-  /* Extract the single variable used in the test into TEST_VAR.  */\n-  if (cond_code == SSA_NAME)\n-    test_var = cond;\n-  else\n-    test_var = TREE_OPERAND (cond, 0);\n+  do {\n+    /* If name has multiple uses, bail out.  */\n+    if (!single_imm_use (name, &use, &use_stmt))\n+      return NULL_TREE;\n \n-  /* Now get the defining statement for TEST_VAR.  Skip this case if\n-     it's not defined by some GIMPLE_MODIFY_STMT.  */\n-  def = SSA_NAME_DEF_STMT (test_var);\n-  if (TREE_CODE (def) != GIMPLE_MODIFY_STMT)\n-    return NULL_TREE;\n+    /* If this is not a trivial copy, we found it.  */\n+    if (TREE_CODE (use_stmt) != GIMPLE_MODIFY_STMT\n+\t|| TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 0)) != SSA_NAME\n+\t|| GIMPLE_STMT_OPERAND (use_stmt, 1) != name)\n+      break;\n \n-  def_rhs = GIMPLE_STMT_OPERAND (def, 1);\n+    /* Continue searching uses of the copy destination.  */\n+    name = GIMPLE_STMT_OPERAND (use_stmt, 0);\n+  } while (1);\n \n-  /* If TEST_VAR is set by adding or subtracting a constant\n-     from an SSA_NAME, then it is interesting to us as we\n-     can adjust the constant in the conditional and thus\n-     eliminate the arithmetic operation.  */\n-  if (TREE_CODE (def_rhs) == PLUS_EXPR\n-      || TREE_CODE (def_rhs) == MINUS_EXPR)\n-    {\n-      tree op0 = TREE_OPERAND (def_rhs, 0);\n-      tree op1 = TREE_OPERAND (def_rhs, 1);\n-\n-      /* The first operand must be an SSA_NAME and the second\n-\t operand must be a constant.  */\n-      if (TREE_CODE (op0) != SSA_NAME\n-\t  || !CONSTANT_CLASS_P (op1)\n-\t  || !INTEGRAL_TYPE_P (TREE_TYPE (op1)))\n-\treturn NULL_TREE;\n-\n-      /* Don't propagate if the first operand occurs in\n-\t an abnormal PHI.  */\n-      if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op0))\n-\treturn NULL_TREE;\n-\n-      if (has_single_use (test_var))\n-\t{\n-\t  enum tree_code new_code;\n-\t  tree t;\n-\n-\t  /* If the variable was defined via X + C, then we must\n-\t     subtract C from the constant in the conditional.\n-\t     Otherwise we add C to the constant in the\n-\t     conditional.  The result must fold into a valid\n-\t     gimple operand to be optimizable.  */\n-\t  new_code = (TREE_CODE (def_rhs) == PLUS_EXPR\n-\t\t      ? MINUS_EXPR : PLUS_EXPR);\n-\t  t = int_const_binop (new_code, TREE_OPERAND (cond, 1), op1, 0);\n-\t  if (!is_gimple_val (t))\n-\t    return NULL_TREE;\n-\n-\t  new_cond = build2 (cond_code, boolean_type_node, op0, t);\n-\t}\n-    }\n+  if (final_name_p)\n+    *final_name_p = name;\n \n-  /* These cases require comparisons of a naked SSA_NAME or\n-     comparison of an SSA_NAME against zero or one.  */\n-  else if (TREE_CODE (cond) == SSA_NAME\n-\t   || integer_zerop (TREE_OPERAND (cond, 1))\n-\t   || integer_onep (TREE_OPERAND (cond, 1)))\n-    {\n-      /* If TEST_VAR is set from a relational operation\n-\t between two SSA_NAMEs or a combination of an SSA_NAME\n-\t and a constant, then it is interesting.  */\n-      if (COMPARISON_CLASS_P (def_rhs))\n-\t{\n-\t  tree op0 = TREE_OPERAND (def_rhs, 0);\n-\t  tree op1 = TREE_OPERAND (def_rhs, 1);\n-\n-\t  /* Both operands of DEF_RHS must be SSA_NAMEs or\n-\t     constants.  */\n-\t  if ((TREE_CODE (op0) != SSA_NAME\n-\t       && !is_gimple_min_invariant (op0))\n-\t      || (TREE_CODE (op1) != SSA_NAME\n-\t\t  && !is_gimple_min_invariant (op1)))\n-\t    return NULL_TREE;\n-\n-\t  /* Don't propagate if the first operand occurs in\n-\t     an abnormal PHI.  */\n-\t  if (TREE_CODE (op0) == SSA_NAME\n-\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op0))\n-\t    return NULL_TREE;\n-\n-\t  /* Don't propagate if the second operand occurs in\n-\t     an abnormal PHI.  */\n-\t  if (TREE_CODE (op1) == SSA_NAME\n-\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op1))\n-\t    return NULL_TREE;\n-\n-\t  if (has_single_use (test_var))\n-\t    {\n-\t      /* TEST_VAR was set from a relational operator.  */\n-\t      new_cond = build2 (TREE_CODE (def_rhs),\n-\t\t\t\t boolean_type_node, op0, op1);\n-\n-\t      /* Invert the conditional if necessary.  */\n-\t      if ((cond_code == EQ_EXPR\n-\t\t   && integer_zerop (TREE_OPERAND (cond, 1)))\n-\t\t  || (cond_code == NE_EXPR\n-\t\t      && integer_onep (TREE_OPERAND (cond, 1))))\n-\t\t{\n-\t\t  new_cond = invert_truthvalue (new_cond);\n-\n-\t\t  /* If we did not get a simple relational\n-\t\t     expression or bare SSA_NAME, then we can\n-\t\t     not optimize this case.  */\n-\t\t  if (!COMPARISON_CLASS_P (new_cond)\n-\t\t      && TREE_CODE (new_cond) != SSA_NAME)\n-\t\t    new_cond = NULL_TREE;\n-\t\t}\n-\t    }\n-\t}\n+  return use_stmt;\n+}\n \n-      /* If TEST_VAR is set from a TRUTH_NOT_EXPR, then it\n-\t is interesting.  */\n-      else if (TREE_CODE (def_rhs) == TRUTH_NOT_EXPR)\n-\t{\n-\t  enum tree_code new_code;\n-\n-\t  def_rhs = TREE_OPERAND (def_rhs, 0);\n-\n-\t  /* DEF_RHS must be an SSA_NAME or constant.  */\n-\t  if (TREE_CODE (def_rhs) != SSA_NAME\n-\t      && !is_gimple_min_invariant (def_rhs))\n-\t    return NULL_TREE;\n-\n-\t  /* Don't propagate if the operand occurs in\n-\t     an abnormal PHI.  */\n-\t  if (TREE_CODE (def_rhs) == SSA_NAME\n-\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (def_rhs))\n-\t    return NULL_TREE;\n-\n-\t  if (cond_code == SSA_NAME\n-\t      || (cond_code == NE_EXPR\n-\t\t  && integer_zerop (TREE_OPERAND (cond, 1)))\n-\t      || (cond_code == EQ_EXPR\n-\t\t  && integer_onep (TREE_OPERAND (cond, 1))))\n-\t    new_code = EQ_EXPR;\n-\t  else\n-\t    new_code = NE_EXPR;\n+/* Get the statement we can propagate from into NAME skipping\n+   trivial copies.  Returns the statement which defines the\n+   propagation source or NULL_TREE if there is no such one.\n+   If SINGLE_USE_ONLY is set considers only sources which have\n+   a single use chain up to NAME.  If SINGLE_USE_P is non-null,\n+   it is set to whether the chain to NAME is a single use chain\n+   or not.  SINGLE_USE_P is not written to if SINGLE_USE_ONLY is set.  */\n \n-\t  new_cond = build2 (new_code, boolean_type_node, def_rhs,\n-\t\t\t     fold_convert (TREE_TYPE (def_rhs),\n-\t\t\t\t\t   integer_zero_node));\n-\t}\n+static tree\n+get_prop_source_stmt (tree name, bool single_use_only, bool *single_use_p)\n+{\n+  bool single_use = true;\n+\n+  do {\n+    tree def_stmt = SSA_NAME_DEF_STMT (name);\n+\n+    if (!has_single_use (name))\n+      {\n+\tsingle_use = false;\n+\tif (single_use_only)\n+\t  return NULL_TREE;\n+      }\n+\n+    /* If name is defined by a PHI node or is the default def, bail out.  */\n+    if (TREE_CODE (def_stmt) != GIMPLE_MODIFY_STMT)\n+      return NULL_TREE;\n+\n+    /* If name is not a simple copy destination, we found it.  */\n+    if (TREE_CODE (GIMPLE_STMT_OPERAND (def_stmt, 1)) != SSA_NAME)\n+      {\n+\tif (!single_use_only && single_use_p)\n+\t  *single_use_p = single_use;\n+\n+\treturn def_stmt;\n+      }\n+\n+    /* Continue searching the def of the copy source name.  */\n+    name = GIMPLE_STMT_OPERAND (def_stmt, 1);\n+  } while (1);\n+}\n \n-      /* If TEST_VAR was set from a cast of an integer type\n-\t to a boolean type or a cast of a boolean to an\n-\t integral, then it is interesting.  */\n-      else if (TREE_CODE (def_rhs) == NOP_EXPR\n-\t       || TREE_CODE (def_rhs) == CONVERT_EXPR)\n-\t{\n-\t  tree outer_type;\n-\t  tree inner_type;\n-\n-\t  outer_type = TREE_TYPE (def_rhs);\n-\t  inner_type = TREE_TYPE (TREE_OPERAND (def_rhs, 0));\n-\n-\t  if ((TREE_CODE (outer_type) == BOOLEAN_TYPE\n-\t       && INTEGRAL_TYPE_P (inner_type))\n-\t      || (TREE_CODE (inner_type) == BOOLEAN_TYPE\n-\t\t  && INTEGRAL_TYPE_P (outer_type)))\n-\t    ;\n-\t  else if (INTEGRAL_TYPE_P (outer_type)\n-\t\t   && INTEGRAL_TYPE_P (inner_type)\n-\t\t   && TREE_CODE (TREE_OPERAND (def_rhs, 0)) == SSA_NAME\n-\t\t   && ssa_name_defined_by_comparison_p (TREE_OPERAND (def_rhs,\n-\t\t\t\t\t\t\t\t      0)))\n-\t    ;\n-\t  else\n-\t    return NULL_TREE;\n+/* Checks if the destination ssa name in DEF_STMT can be used as\n+   propagation source.  Returns true if so, otherwise false.  */\n \n-\t  /* Don't propagate if the operand occurs in\n-\t     an abnormal PHI.  */\n-\t  if (TREE_CODE (TREE_OPERAND (def_rhs, 0)) == SSA_NAME\n-\t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND\n-\t\t\t\t\t\t  (def_rhs, 0)))\n-\t    return NULL_TREE;\n+static bool\n+can_propagate_from (tree def_stmt)\n+{\n+  tree rhs = GIMPLE_STMT_OPERAND (def_stmt, 1);\n \n-\t  if (has_single_use (test_var))\n-\t    {\n-\t      enum tree_code new_code;\n-\t      tree new_arg;\n-\n-\t      if (cond_code == SSA_NAME\n-\t\t  || (cond_code == NE_EXPR\n-\t\t      && integer_zerop (TREE_OPERAND (cond, 1)))\n-\t\t  || (cond_code == EQ_EXPR\n-\t\t      && integer_onep (TREE_OPERAND (cond, 1))))\n-\t\tnew_code = NE_EXPR;\n-\t      else\n-\t\tnew_code = EQ_EXPR;\n+  /* We cannot propagate ssa names that occur in abnormal phi nodes.  */\n+  switch (TREE_CODE_LENGTH (TREE_CODE (rhs)))\n+    {\n+    case 3:\n+      if (TREE_OPERAND (rhs, 2) != NULL_TREE\n+\t  && TREE_CODE (TREE_OPERAND (rhs, 2)) == SSA_NAME\n+\t  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (rhs, 2)))\n+\treturn false;\n+    case 2:\n+      if (TREE_OPERAND (rhs, 1) != NULL_TREE\n+\t  && TREE_CODE (TREE_OPERAND (rhs, 1)) == SSA_NAME\n+\t  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (rhs, 1)))\n+\treturn false;\n+    case 1:\n+      if (TREE_OPERAND (rhs, 0) != NULL_TREE\n+\t  && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME\n+\t  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (rhs, 0)))\n+\treturn false;\n+      break;\n \n-\t      new_arg = TREE_OPERAND (def_rhs, 0);\n-\t      new_cond = build2 (new_code, boolean_type_node, new_arg,\n-\t\t\t\t fold_convert (TREE_TYPE (new_arg),\n-\t\t\t\t\t       integer_zero_node));\n-\t    }\n-\t}\n+    default:\n+      return false;\n     }\n \n-  *test_var_p = test_var;\n-  return new_cond;\n-}\n+  /* If the definition is a conversion of a pointer to a function type,\n+     then we can not apply optimizations as some targets require function\n+     pointers to be canonicalized and in this case this optimization could\n+     eliminate a necessary canonicalization.  */\n+  if ((TREE_CODE (rhs) == NOP_EXPR\n+       || TREE_CODE (rhs) == CONVERT_EXPR)\n+      && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (rhs, 0)))\n+      && TREE_CODE (TREE_TYPE (TREE_TYPE\n+\t\t\t        (TREE_OPERAND (rhs, 0)))) == FUNCTION_TYPE)\n+    return false;\n \n-/* COND is a condition of the form:\n+  return true;\n+}\n \n-     x == const or x != const\n+/* Remove a copy chain ending in NAME along the defs but not\n+   further or including UP_TO_STMT.  If NAME was replaced in\n+   its only use then this function can be used to clean up\n+   dead stmts.  Returns true if UP_TO_STMT can be removed\n+   as well, otherwise false.  */\n \n-   Look back to x's defining statement and see if x is defined as\n+static bool\n+remove_prop_source_from_use (tree name, tree up_to_stmt)\n+{\n+  block_stmt_iterator bsi;\n+  tree stmt;\n \n-     x = (type) y;\n+  do {\n+    if (!has_zero_uses (name))\n+      return false;\n \n-   If const is unchanged if we convert it to type, then we can build\n-   the equivalent expression:\n+    stmt = SSA_NAME_DEF_STMT (name);\n+    if (stmt == up_to_stmt)\n+      return true;\n \n+    bsi = bsi_for_stmt (stmt);\n+    release_defs (stmt);\n+    bsi_remove (&bsi, true);\n \n-      y == const or y != const\n+    name = GIMPLE_STMT_OPERAND (stmt, 1);\n+  } while (TREE_CODE (name) == SSA_NAME);\n \n-   Which may allow further optimizations.\n+  return false;\n+}\n \n-   Return the equivalent comparison or NULL if no such equivalent comparison\n-   was found.  */\n+/* Combine OP0 CODE OP1 in the context of a COND_EXPR.  Returns\n+   the folded result in a form suitable for COND_EXPR_COND or\n+   NULL_TREE, if there is no suitable simplified form.  If\n+   INVARIANT_ONLY is true only gimple_min_invariant results are\n+   considered simplified.  */\n \n static tree\n-find_equivalent_equality_comparison (tree cond)\n+combine_cond_expr_cond (enum tree_code code, tree type,\n+\t\t\ttree op0, tree op1, bool invariant_only)\n {\n-  tree op0 = TREE_OPERAND (cond, 0);\n-  tree op1 = TREE_OPERAND (cond, 1);\n-  tree def_stmt = SSA_NAME_DEF_STMT (op0);\n-\n-  while (def_stmt\n-\t && TREE_CODE (def_stmt) == GIMPLE_MODIFY_STMT\n-\t && TREE_CODE (GIMPLE_STMT_OPERAND (def_stmt, 1)) == SSA_NAME)\n-    def_stmt = SSA_NAME_DEF_STMT (GIMPLE_STMT_OPERAND (def_stmt, 1));\n-\n-  /* OP0 might have been a parameter, so first make sure it\n-     was defined by a GIMPLE_MODIFY_STMT.  */\n-  if (def_stmt && TREE_CODE (def_stmt) == GIMPLE_MODIFY_STMT)\n-    {\n-      tree def_rhs = GIMPLE_STMT_OPERAND (def_stmt, 1);\n-\n-      /* If either operand to the comparison is a pointer to\n-\t a function, then we can not apply this optimization\n-\t as some targets require function pointers to be\n-\t canonicalized and in this case this optimization would\n-\t eliminate a necessary canonicalization.  */\n-      if ((POINTER_TYPE_P (TREE_TYPE (op0))\n-\t   && TREE_CODE (TREE_TYPE (TREE_TYPE (op0))) == FUNCTION_TYPE)\n-\t  || (POINTER_TYPE_P (TREE_TYPE (op1))\n-\t      && TREE_CODE (TREE_TYPE (TREE_TYPE (op1))) == FUNCTION_TYPE))\n-\treturn NULL;\n-\t      \n-      /* Now make sure the RHS of the GIMPLE_MODIFY_STMT is a typecast.  */\n-      if ((TREE_CODE (def_rhs) == NOP_EXPR\n-\t   || TREE_CODE (def_rhs) == CONVERT_EXPR)\n-\t  && TREE_CODE (TREE_OPERAND (def_rhs, 0)) == SSA_NAME)\n-\t{\n-\t  tree def_rhs_inner = TREE_OPERAND (def_rhs, 0);\n-\t  tree def_rhs_inner_type = TREE_TYPE (def_rhs_inner);\n-\t  tree new;\n-\n-\t  if (TYPE_PRECISION (def_rhs_inner_type)\n-\t      > TYPE_PRECISION (TREE_TYPE (def_rhs)))\n-\t    return NULL;\n-\n-\t  /* If the inner type of the conversion is a pointer to\n-\t     a function, then we can not apply this optimization\n-\t     as some targets require function pointers to be\n-\t     canonicalized.  This optimization would result in\n-\t     canonicalization of the pointer when it was not originally\n-\t     needed/intended.  */\n-\t  if (POINTER_TYPE_P (def_rhs_inner_type)\n-\t      && TREE_CODE (TREE_TYPE (def_rhs_inner_type)) == FUNCTION_TYPE)\n-\t    return NULL;\n-\n-\t  /* What we want to prove is that if we convert OP1 to\n-\t     the type of the object inside the NOP_EXPR that the\n-\t     result is still equivalent to SRC. \n-\n-\t     If that is true, the build and return new equivalent\n-\t     condition which uses the source of the typecast and the\n-\t     new constant (which has only changed its type).  */\n-\t  new = fold_build1 (TREE_CODE (def_rhs), def_rhs_inner_type, op1);\n-\t  STRIP_USELESS_TYPE_CONVERSION (new);\n-\t  if (is_gimple_val (new) && tree_int_cst_equal (new, op1))\n-\t    return build2 (TREE_CODE (cond), TREE_TYPE (cond),\n-\t\t\t   def_rhs_inner, new);\n-\t}\n-    }\n-  return NULL;\n-}\n+  tree t;\n \n-/* EXPR is a COND_EXPR\n-   STMT is the statement containing EXPR.\n+  gcc_assert (TREE_CODE_CLASS (code) == tcc_comparison);\n \n-   This routine attempts to find equivalent forms of the condition\n-   which we may be able to optimize better.  */\n+  t = fold_binary (code, type, op0, op1);\n+  if (!t)\n+    return NULL_TREE;\n \n-static void\n-simplify_cond (tree cond_expr, tree stmt)\n-{\n-  tree cond = COND_EXPR_COND (cond_expr);\n+  /* Require that we got a boolean type out if we put one in.  */\n+  gcc_assert (TREE_CODE (TREE_TYPE (t)) == TREE_CODE (type));\n \n-  if (COMPARISON_CLASS_P (cond))\n+  /* For (bool)x use x != 0.  */\n+  if (TREE_CODE (t) == NOP_EXPR\n+      && TREE_TYPE (t) == boolean_type_node)\n     {\n-      tree op0 = TREE_OPERAND (cond, 0);\n-      tree op1 = TREE_OPERAND (cond, 1);\n+      tree top0 = TREE_OPERAND (t, 0);\n+      t = build2 (NE_EXPR, type,\n+\t\t  top0, build_int_cst (TREE_TYPE (top0), 0));\n+    }\n+  /* For !x use x == 0.  */\n+  else if (TREE_CODE (t) == TRUTH_NOT_EXPR)\n+    {\n+      tree top0 = TREE_OPERAND (t, 0);\n+      t = build2 (EQ_EXPR, type,\n+\t\t  top0, build_int_cst (TREE_TYPE (top0), 0));\n+    }\n+  /* For cmp ? 1 : 0 use cmp.  */\n+  else if (TREE_CODE (t) == COND_EXPR\n+\t   && COMPARISON_CLASS_P (TREE_OPERAND (t, 0))\n+\t   && integer_onep (TREE_OPERAND (t, 1))\n+\t   && integer_zerop (TREE_OPERAND (t, 2)))\n+    {\n+      tree top0 = TREE_OPERAND (t, 0);\n+      t = build2 (TREE_CODE (top0), type,\n+\t\t  TREE_OPERAND (top0, 0), TREE_OPERAND (top0, 1));\n+    }\n \n-      if (TREE_CODE (op0) == SSA_NAME && is_gimple_min_invariant (op1))\n-\t{\n-\t  /* First see if we have test of an SSA_NAME against a constant\n-\t     where the SSA_NAME is defined by an earlier typecast which\n-\t     is irrelevant when performing tests against the given\n-\t     constant.  */\n-\t  if (TREE_CODE (cond) == EQ_EXPR || TREE_CODE (cond) == NE_EXPR)\n-\t    {\n-\t      tree new_cond = find_equivalent_equality_comparison (cond);\n+  /* Bail out if we required an invariant but didn't get one.  */\n+  if (invariant_only\n+      && !is_gimple_min_invariant (t))\n+    return NULL_TREE;\n \n-\t      if (new_cond)\n-\t\t{\n-\t\t  COND_EXPR_COND (cond_expr) = new_cond;\n-\t\t  update_stmt (stmt);\n-\t\t}\n-\t    }\n-\t}\n-    }\n+  /* A valid conditional for a COND_EXPR is either a gimple value\n+     or a comparison with two gimple value operands.  */\n+  if (is_gimple_val (t)\n+      || (COMPARISON_CLASS_P (t)\n+\t  && is_gimple_val (TREE_OPERAND (t, 0))\n+\t  && is_gimple_val (TREE_OPERAND (t, 1))))\n+    return t;\n+\n+  return NULL_TREE;\n }\n \n-/* Forward propagate a single-use variable into COND_EXPR as many\n-   times as possible.  */\n+/* Propagate from the ssa name definition statements of COND_EXPR\n+   in statement STMT into the conditional if that simplifies it.  */\n \n static void\n forward_propagate_into_cond (tree cond_expr, tree stmt)\n {\n-  gcc_assert (TREE_CODE (cond_expr) == COND_EXPR);\n-\n-  while (1)\n-    {\n-      tree test_var = NULL_TREE;\n-      tree cond = COND_EXPR_COND (cond_expr);\n-      tree new_cond = forward_propagate_into_cond_1 (cond, &test_var);\n-\n-      /* Return if unsuccessful.  */\n-      if (new_cond == NULL_TREE)\n-\tbreak;\n-\n-      /* Dump details.  */\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"  Replaced '\");\n-\t  print_generic_expr (dump_file, cond, dump_flags);\n-\t  fprintf (dump_file, \"' with '\");\n-\t  print_generic_expr (dump_file, new_cond, dump_flags);\n-\t  fprintf (dump_file, \"'\\n\");\n-\t}\n-\n-      COND_EXPR_COND (cond_expr) = new_cond;\n-      update_stmt (stmt);\n-\n-      if (has_zero_uses (test_var))\n-\t{\n-\t  tree def = SSA_NAME_DEF_STMT (test_var);\n-\t  block_stmt_iterator bsi = bsi_for_stmt (def);\n-\t  bsi_remove (&bsi, true);\n-\t  release_defs (def);\n-\t}\n-    }\n+  do {\n+    tree tmp = NULL_TREE;\n+    tree cond = COND_EXPR_COND (cond_expr);\n+    tree name, def_stmt, rhs;\n+    bool single_use_p;\n+\n+    /* We can do tree combining on SSA_NAME and comparison expressions.  */\n+    if (COMPARISON_CLASS_P (cond)\n+\t&& TREE_CODE (TREE_OPERAND (cond, 0)) == SSA_NAME)\n+      {\n+\t/* For comparisons use the first operand, that is likely to\n+\t   simplify comparisons against constants.  */\n+\tname = TREE_OPERAND (cond, 0);\n+\tdef_stmt = get_prop_source_stmt (name, false, &single_use_p);\n+\tif (def_stmt != NULL_TREE\n+\t    && can_propagate_from (def_stmt))\n+\t  {\n+\t    tree op1 = TREE_OPERAND (cond, 1);\n+\t    rhs = GIMPLE_STMT_OPERAND (def_stmt, 1);\n+\t    tmp = combine_cond_expr_cond (TREE_CODE (cond), boolean_type_node,\n+\t\t\t\t          fold_convert (TREE_TYPE (op1), rhs),\n+\t\t\t\t          op1, !single_use_p);\n+\t  }\n+\t/* If that wasn't successful, try the second operand.  */\n+\tif (tmp == NULL_TREE\n+\t    && TREE_CODE (TREE_OPERAND (cond, 1)) == SSA_NAME)\n+\t  {\n+\t    tree op0 = TREE_OPERAND (cond, 0);\n+\t    name = TREE_OPERAND (cond, 1);\n+\t    def_stmt = get_prop_source_stmt (name, false, &single_use_p);\n+\t    if (def_stmt == NULL_TREE\n+\t        || !can_propagate_from (def_stmt))\n+\t      return;\n+\n+\t    rhs = GIMPLE_STMT_OPERAND (def_stmt, 1);\n+\t    tmp = combine_cond_expr_cond (TREE_CODE (cond), boolean_type_node,\n+\t\t\t\t\t  op0,\n+\t\t\t\t          fold_convert (TREE_TYPE (op0), rhs),\n+\t\t\t\t\t  !single_use_p);\n+\t  }\n+      }\n+    else if (TREE_CODE (cond) == SSA_NAME)\n+      {\n+\tname = cond;\n+\tdef_stmt = get_prop_source_stmt (name, true, NULL);\n+\tif (def_stmt == NULL_TREE\n+\t    || !can_propagate_from (def_stmt))\n+\t  return;\n+\n+\trhs = GIMPLE_STMT_OPERAND (def_stmt, 1);\n+\ttmp = combine_cond_expr_cond (NE_EXPR, boolean_type_node, rhs,\n+\t\t\t\t      build_int_cst (TREE_TYPE (rhs), 0),\n+\t\t\t\t      false);\n+      }\n+\n+    if (tmp)\n+      {\n+\tif (dump_file && tmp)\n+\t  {\n+\t    fprintf (dump_file, \"  Replaced '\");\n+\t    print_generic_expr (dump_file, cond, 0);\n+\t    fprintf (dump_file, \"' with '\");\n+\t    print_generic_expr (dump_file, tmp, 0);\n+\t    fprintf (dump_file, \"'\\n\");\n+\t  }\n+\n+\tCOND_EXPR_COND (cond_expr) = unshare_expr (tmp);\n+\tupdate_stmt (stmt);\n+\n+\t/* Remove defining statements.  */\n+\tremove_prop_source_from_use (name, NULL);\n+\n+\t/* Continue combining.  */\n+\tcontinue;\n+      }\n \n-  /* There are further simplifications that can be performed\n-     on COND_EXPRs.  Specifically, when comparing an SSA_NAME\n-     against a constant where the SSA_NAME is the result of a\n-     conversion.  Perhaps this should be folded into the rest\n-     of the COND_EXPR simplification code.  */\n-  simplify_cond (cond_expr, stmt);\n+    break;\n+  } while (1);\n }\n \n /* We've just substituted an ADDR_EXPR into stmt.  Update all the \n@@ -861,6 +741,104 @@ forward_propagate_addr_expr (tree name, tree rhs)\n   return all;\n }\n \n+/* Forward propagate the comparison COND defined in STMT like\n+   cond_1 = x CMP y to uses of the form\n+     a_1 = (T')cond_1\n+     a_1 = !cond_1\n+     a_1 = cond_1 != 0\n+   Returns true if stmt is now unused.  */\n+\n+static bool\n+forward_propagate_comparison (tree cond, tree stmt)\n+{\n+  tree name = GIMPLE_STMT_OPERAND (stmt, 0);\n+  tree use_stmt, tmp = NULL_TREE;\n+\n+  /* Don't propagate ssa names that occur in abnormal phis.  */\n+  if ((TREE_CODE (TREE_OPERAND (cond, 0)) == SSA_NAME\n+       && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (cond, 0)))\n+      || (TREE_CODE (TREE_OPERAND (cond, 1)) == SSA_NAME\n+\t  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (cond, 1))))\n+    return false;\n+\n+  /* Do not un-cse comparisons.  But propagate through copies.  */\n+  use_stmt = get_prop_dest_stmt (name, &name);\n+  if (use_stmt == NULL_TREE)\n+    return false;\n+\n+  /* Conversion of the condition result to another integral type.  */\n+  if (TREE_CODE (use_stmt) == GIMPLE_MODIFY_STMT\n+      && (TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 1)) == CONVERT_EXPR\n+\t  || TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 1)) == NOP_EXPR\n+          || COMPARISON_CLASS_P (GIMPLE_STMT_OPERAND (use_stmt, 1))\n+          || TREE_CODE (GIMPLE_STMT_OPERAND (use_stmt, 1)) == TRUTH_NOT_EXPR)\n+      && INTEGRAL_TYPE_P (TREE_TYPE (GIMPLE_STMT_OPERAND (use_stmt, 0))))\n+    {\n+      tree lhs = GIMPLE_STMT_OPERAND (use_stmt, 0);\n+      tree rhs = GIMPLE_STMT_OPERAND (use_stmt, 1);\n+\n+      /* We can propagate the condition into a conversion.  */\n+      if (TREE_CODE (rhs) == CONVERT_EXPR\n+\t  || TREE_CODE (rhs) == NOP_EXPR)\n+\t{\n+\t  /* Avoid using fold here as that may create a COND_EXPR with\n+\t     non-boolean condition as canonical form.  */\n+\t  tmp = build2 (TREE_CODE (cond), TREE_TYPE (lhs),\n+\t\t\tTREE_OPERAND (cond, 0), TREE_OPERAND (cond, 1));\n+\t}\n+      /* We can propagate the condition into X op CST where op\n+\t is EQ_EXRP or NE_EXPR and CST is either one or zero.  */\n+      else if (COMPARISON_CLASS_P (rhs)\n+\t       && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME\n+\t       && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST)\n+\t{\n+\t  enum tree_code code = TREE_CODE (rhs);\n+\t  tree cst = TREE_OPERAND (rhs, 1);\n+\n+\t  tmp = combine_cond_expr_cond (code, TREE_TYPE (lhs),\n+\t\t\t\t\tfold_convert (TREE_TYPE (cst), cond),\n+\t\t\t\t\tcst, false);\n+\t  if (tmp == NULL_TREE)\n+\t    return false;\n+\t}\n+      /* We can propagate the condition into a statement that\n+\t computes the logical negation of the comparison result.  */\n+      else if (TREE_CODE (rhs) == TRUTH_NOT_EXPR)\n+\t{\n+\t  tree type = TREE_TYPE (TREE_OPERAND (cond, 0));\n+\t  bool nans = HONOR_NANS (TYPE_MODE (type));\n+\t  enum tree_code code;\n+\t  code = invert_tree_comparison (TREE_CODE (cond), nans);\n+\t  if (code == ERROR_MARK)\n+\t    return false;\n+\n+\t  tmp = build2 (code, TREE_TYPE (lhs), TREE_OPERAND (cond, 0),\n+\t\t\tTREE_OPERAND (cond, 1));\n+\t}\n+      else\n+\treturn false;\n+\n+      GIMPLE_STMT_OPERAND (use_stmt, 1) = unshare_expr (tmp);\n+      update_stmt (use_stmt);\n+\n+      /* Remove defining statements.  */\n+      remove_prop_source_from_use (name, stmt);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"  Replaced '\");\n+\t  print_generic_expr (dump_file, rhs, dump_flags);\n+\t  fprintf (dump_file, \"' with '\");\n+\t  print_generic_expr (dump_file, tmp, dump_flags);\n+\t  fprintf (dump_file, \"'\\n\");\n+\t}\n+\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* If we have lhs = ~x (STMT), look and see if earlier we had x = ~y.\n    If so, we can change STMT into lhs = y which can later be copy\n    propagated.  Similarly for negation. \n@@ -1011,6 +989,17 @@ tree_ssa_forward_propagate_single_use_vars (void)\n                   forward_propagate_into_cond (rhs, stmt);\n \t\t  bsi_next (&bsi);\n                 }\n+\t      else if (COMPARISON_CLASS_P (rhs))\n+\t\t{\n+\t\t  if (forward_propagate_comparison (rhs, stmt))\n+\t\t    {\n+\t\t      release_defs (stmt);\n+\t\t      todoflags |= TODO_remove_unused_locals;\n+\t\t      bsi_remove (&bsi, true);\n+\t\t    }\n+\t\t  else\n+\t\t    bsi_next (&bsi);\n+\t\t}\n \t      else\n \t\tbsi_next (&bsi);\n \t    }"}]}