{"sha": "4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU3ZTdhNDliNzYwYmM0NmJmMGFkZTM2YzI1YTdkOGUwODhiNmRlYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-05-06T20:06:29Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-05-06T20:06:29Z"}, "message": "More uses of backend interface for types.\n\nFrom-SVN: r173507", "tree": {"sha": "a04353390cbd4dbceb299c20d4a3c6ae273157b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a04353390cbd4dbceb299c20d4a3c6ae273157b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea/comments", "author": null, "committer": null, "parents": [{"sha": "c81e79b590707957ae3dd2ac872aebba7ad8a46e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c81e79b590707957ae3dd2ac872aebba7ad8a46e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c81e79b590707957ae3dd2ac872aebba7ad8a46e"}], "stats": {"total": 187, "additions": 79, "deletions": 108}, "files": [{"sha": "b89cb63deb10712c4f9b883aaada4d59302679fd", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 63, "deletions": 91, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea", "patch": "@@ -845,7 +845,7 @@ Type::get_tree(Gogo* gogo)\n \n   if (this->forward_declaration_type() != NULL\n       || this->named_type() != NULL)\n-    return this->get_tree_without_hash(gogo);\n+    return type_to_tree(this->get_btype_without_hash(gogo));\n \n   if (this->is_error_type())\n     return error_mark_node;\n@@ -865,7 +865,7 @@ Type::get_tree(Gogo* gogo)\n       return ins.first->second;\n     }\n \n-  tree t = this->get_tree_without_hash(gogo);\n+  tree t = type_to_tree(this->get_btype_without_hash(gogo));\n \n   if (ins.first->second == NULL_TREE)\n     ins.first->second = t;\n@@ -884,43 +884,33 @@ Type::get_tree(Gogo* gogo)\n   return t;\n }\n \n-// Return a tree for a type without looking in the hash table for\n-// identical types.  This is used for named types, since there is no\n-// point to looking in the hash table for them.\n+// Return the backend representation for a type without looking in the\n+// hash table for identical types.  This is used for named types,\n+// since a named type is never identical to any other type.\n \n-tree\n-Type::get_tree_without_hash(Gogo* gogo)\n+Btype*\n+Type::get_btype_without_hash(Gogo* gogo)\n {\n   if (this->tree_ == NULL_TREE)\n     {\n-      tree t = this->do_get_tree(gogo);\n+      Btype* bt = tree_to_type(this->do_get_tree(gogo));\n \n       // For a recursive function or pointer type, we will temporarily\n       // return a circular pointer type during the recursion.  We\n       // don't want to record that for a forwarding type, as it may\n       // confuse us later.\n       if (this->forward_declaration_type() != NULL\n-\t  && gogo->backend()->is_circular_pointer_type(tree_to_type(t)))\n-\treturn t;\n+\t  && gogo->backend()->is_circular_pointer_type(bt))\n+\treturn bt;\n \n       if (gogo == NULL || !gogo->named_types_are_converted())\n-\treturn t;\n+\treturn bt;\n \n+      tree t = type_to_tree(bt);\n       this->tree_ = t;\n-      go_preserve_from_gc(t);\n     }\n \n-  return this->tree_;\n-}\n-\n-// Return the backend representation for a type without looking in the\n-// hash table for identical types.  This is used for named types,\n-// since a named type is never identical to any other type.\n-\n-Btype*\n-Type::get_btype_without_hash(Gogo* gogo)\n-{\n-  return tree_to_type(this->get_tree_without_hash(gogo));\n+  return tree_to_type(this->tree_);\n }\n \n // Return a tree representing a zero initialization for this type.\n@@ -1596,8 +1586,8 @@ class Error_type : public Type\n \n  protected:\n   tree\n-  do_get_tree(Gogo*)\n-  { return error_mark_node; }\n+  do_get_tree(Gogo* gogo)\n+  { return type_to_tree(gogo->backend()->error_type()); }\n \n   tree\n   do_get_init_tree(Gogo*, tree, bool)\n@@ -3228,8 +3218,11 @@ class Nil_type : public Type\n \n  protected:\n   tree\n-  do_get_tree(Gogo*)\n-  { return ptr_type_node; }\n+  do_get_tree(Gogo* gogo)\n+  {\n+    Btype* bt = gogo->backend()->pointer_type(gogo->backend()->void_type());\n+    return type_to_tree(bt);\n+  }\n \n   tree\n   do_get_init_tree(Gogo*, tree type_tree, bool is_clear)\n@@ -5064,61 +5057,44 @@ Map_type::do_check_make_expression(Expression_list* args,\n   return true;\n }\n \n-// Get a tree for a map type.  A map type is represented as a pointer\n-// to a struct.  The struct is __go_map in libgo/map.h.\n+// Get the backend representation for a map type.  A map type is\n+// represented as a pointer to a struct.  The struct is __go_map in\n+// libgo/map.h.\n \n tree\n Map_type::do_get_tree(Gogo* gogo)\n {\n-  static tree type_tree;\n-  if (type_tree == NULL_TREE)\n+  static Btype* backend_map_type;\n+  if (backend_map_type == NULL)\n     {\n-      tree struct_type = make_node(RECORD_TYPE);\n-\n-      tree map_descriptor_type = gogo->map_descriptor_type();\n-      tree const_map_descriptor_type =\n-\tbuild_qualified_type(map_descriptor_type, TYPE_QUAL_CONST);\n-      tree name = get_identifier(\"__descriptor\");\n-      tree field = build_decl(BUILTINS_LOCATION, FIELD_DECL, name,\n-\t\t\t      build_pointer_type(const_map_descriptor_type));\n-      DECL_CONTEXT(field) = struct_type;\n-      TYPE_FIELDS(struct_type) = field;\n-      tree last_field = field;\n+      std::vector<Backend::Btyped_identifier> bfields(4);\n \n-      name = get_identifier(\"__element_count\");\n-      field = build_decl(BUILTINS_LOCATION, FIELD_DECL, name, sizetype);\n-      DECL_CONTEXT(field) = struct_type;\n-      DECL_CHAIN(last_field) = field;\n-      last_field = field;\n-\n-      name = get_identifier(\"__bucket_count\");\n-      field = build_decl(BUILTINS_LOCATION, FIELD_DECL, name, sizetype);\n-      DECL_CONTEXT(field) = struct_type;\n-      DECL_CHAIN(last_field) = field;\n-      last_field = field;\n+      Type* pdt = Type::make_type_descriptor_ptr_type();\n+      bfields[0].name = \"__descriptor\";\n+      bfields[0].btype = tree_to_type(pdt->get_tree(gogo));\n+      bfields[0].location = BUILTINS_LOCATION;\n \n-      name = get_identifier(\"__buckets\");\n-      field = build_decl(BUILTINS_LOCATION, FIELD_DECL, name,\n-\t\t\t build_pointer_type(ptr_type_node));\n-      DECL_CONTEXT(field) = struct_type;\n-      DECL_CHAIN(last_field) = field;\n+      Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+      bfields[1].name = \"__element_count\";\n+      bfields[1].btype = tree_to_type(uintptr_type->get_tree(gogo));\n+      bfields[1].location = BUILTINS_LOCATION;\n \n-      layout_type(struct_type);\n+      bfields[2].name = \"__bucket_count\";\n+      bfields[2].btype = bfields[1].btype;\n+      bfields[2].location = BUILTINS_LOCATION;\n \n-      // Give the struct a name for better debugging info.\n-      name = get_identifier(\"__go_map\");\n-      tree type_decl = build_decl(BUILTINS_LOCATION, TYPE_DECL, name,\n-\t\t\t\t  struct_type);\n-      DECL_ARTIFICIAL(type_decl) = 1;\n-      TYPE_NAME(struct_type) = type_decl;\n-      go_preserve_from_gc(type_decl);\n-      rest_of_decl_compilation(type_decl, 1, 0);\n+      Btype* bvt = gogo->backend()->void_type();\n+      Btype* bpvt = gogo->backend()->pointer_type(bvt);\n+      Btype* bppvt = gogo->backend()->pointer_type(bpvt);\n+      bfields[3].name = \"__buckets\";\n+      bfields[3].btype = bppvt;\n+      bfields[3].location = BUILTINS_LOCATION;\n \n-      type_tree = build_pointer_type(struct_type);\n-      go_preserve_from_gc(type_tree);\n+      Btype *bt = gogo->backend()->struct_type(bfields);\n+      bt = gogo->backend()->named_type(\"__go_map\", bt, BUILTINS_LOCATION);\n+      backend_map_type = gogo->backend()->pointer_type(bt);\n     }\n-\n-  return type_tree;\n+  return type_to_tree(backend_map_type);\n }\n \n // Initialize a map.\n@@ -5354,19 +5330,17 @@ Channel_type::do_check_make_expression(Expression_list* args,\n // libgo/runtime/channel.h.\n \n tree\n-Channel_type::do_get_tree(Gogo*)\n+Channel_type::do_get_tree(Gogo* gogo)\n {\n-  static tree type_tree;\n-  if (type_tree == NULL_TREE)\n+  static Btype* backend_channel_type;\n+  if (backend_channel_type == NULL)\n     {\n-      tree ret = make_node(RECORD_TYPE);\n-      TYPE_NAME(ret) = get_identifier(\"__go_channel\");\n-      TYPE_STUB_DECL(ret) = build_decl(BUILTINS_LOCATION, TYPE_DECL, NULL_TREE,\n-\t\t\t\t       ret);\n-      type_tree = build_pointer_type(ret);\n-      go_preserve_from_gc(type_tree);\n+      std::vector<Backend::Btyped_identifier> bfields;\n+      Btype* bt = gogo->backend()->struct_type(bfields);\n+      bt = gogo->backend()->named_type(\"__go_channel\", bt, BUILTINS_LOCATION);\n+      backend_channel_type = gogo->backend()->pointer_type(bt);\n     }\n-  return type_tree;\n+  return type_to_tree(backend_channel_type);\n }\n \n // Initialize a channel variable.\n@@ -8433,7 +8407,7 @@ Forward_declaration_type::do_traverse(Traverse* traverse)\n   return TRAVERSE_CONTINUE;\n }\n \n-// Get a tree for the type.\n+// Get the backend representation for the type.\n \n tree\n Forward_declaration_type::do_get_tree(Gogo* gogo)\n@@ -8445,15 +8419,13 @@ Forward_declaration_type::do_get_tree(Gogo* gogo)\n     return error_mark_node;\n \n   // We represent an undefined type as a struct with no fields.  That\n-  // should work fine for the middle-end, since the same case can\n-  // arise in C.\n-  Named_object* no = this->named_object();\n-  tree type_tree = make_node(RECORD_TYPE);\n-  tree id = no->get_id(gogo);\n-  tree decl = build_decl(no->location(), TYPE_DECL, id, type_tree);\n-  TYPE_NAME(type_tree) = decl;\n-  layout_type(type_tree);\n-  return type_tree;\n+  // should work fine for the backend, since the same case can arise\n+  // in C.\n+  std::vector<Backend::Btyped_identifier> fields;\n+  Btype* bt = gogo->backend()->struct_type(fields);\n+  bt = gogo->backend()->named_type(this->name(), bt,\n+\t\t\t\t   this->named_object()->location());\n+  return type_to_tree(bt);\n }\n \n // Build a type descriptor for a forwarded type."}, {"sha": "a76b653076ee6a490bccf9bae9e247144d668fe9", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea", "patch": "@@ -1098,11 +1098,6 @@ class Type\n \t\t       bool* is_method, bool* found_pointer_method,\n \t\t       std::string* ambig1, std::string* ambig2);\n \n-  // Get a tree for a type without looking in the hash table for\n-  // identical types.\n-  tree\n-  get_tree_without_hash(Gogo*);\n-\n   // Get the backend representation for a type without looking in the\n   // hash table for identical types.\n   Btype*"}, {"sha": "9dcaf7fcdbb886aa6a3d5545545e45462d61184a", "filename": "libgo/runtime/channel.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea/libgo%2Fruntime%2Fchannel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea/libgo%2Fruntime%2Fchannel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fchannel.h?ref=4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea", "patch": "@@ -74,6 +74,9 @@ struct __go_channel\n   uint64_t data[];\n };\n \n+/* Try to link up with the structure generated by the frontend.  */\n+typedef struct __go_channel __go_channel;\n+\n /* The mutex used to control access to the value pointed to by the\n    __go_channel_select selected field.  No additional mutexes may be\n    acquired while this mutex is held.  */"}, {"sha": "02a0f73f2247b7ca9807473c2ec4d929bffe6638", "filename": "libgo/runtime/go-map-index.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea/libgo%2Fruntime%2Fgo-map-index.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea/libgo%2Fruntime%2Fgo-map-index.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-map-index.c?ref=4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea", "patch": "@@ -21,11 +21,11 @@ __go_map_rehash (struct __go_map *map)\n   size_t key_offset;\n   size_t key_size;\n   size_t (*hashfn) (const void *, size_t);\n-  size_t old_bucket_count;\n+  uintptr_t old_bucket_count;\n   void **old_buckets;\n-  size_t new_bucket_count;\n+  uintptr_t new_bucket_count;\n   void **new_buckets;\n-  size_t i;\n+  uintptr_t i;\n \n   descriptor = map->__descriptor;\n "}, {"sha": "a8922b9f007f9190fdbbf1acb70b00d2e1901d11", "filename": "libgo/runtime/go-map-len.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea/libgo%2Fruntime%2Fgo-map-len.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea/libgo%2Fruntime%2Fgo-map-len.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-map-len.c?ref=4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea", "patch": "@@ -18,6 +18,6 @@ __go_map_len (struct __go_map *map)\n {\n   if (map == NULL)\n     return 0;\n-  __go_assert (map->__element_count == (size_t) (int) map->__element_count);\n+  __go_assert (map->__element_count == (uintptr_t) (int) map->__element_count);\n   return map->__element_count;\n }"}, {"sha": "54444bc21048dfdb50c75de9e65a5a6a134815c5", "filename": "libgo/runtime/go-map-range.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea/libgo%2Fruntime%2Fgo-map-range.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea/libgo%2Fruntime%2Fgo-map-range.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-map-range.c?ref=4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea", "patch": "@@ -34,7 +34,7 @@ __go_mapiternext (struct __go_hash_iter *it)\n   if (entry == NULL)\n     {\n       const struct __go_map *map;\n-      size_t bucket;\n+      uintptr_t bucket;\n \n       map = it->map;\n       bucket = it->bucket;"}, {"sha": "3a471299b225ba36b93b93c9a372dcc3555640dd", "filename": "libgo/runtime/go-new-map.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea/libgo%2Fruntime%2Fgo-new-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea/libgo%2Fruntime%2Fgo-new-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-new-map.c?ref=4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea", "patch": "@@ -73,8 +73,8 @@ static const unsigned long prime_list[] = /* 256 + 1 or 256 + 48 + 1 */\n \n /* Return the next number from PRIME_LIST >= N.  */\n \n-unsigned long\n-__go_map_next_prime (unsigned long n)\n+uintptr_t\n+__go_map_next_prime (uintptr_t n)\n {\n   size_t low;\n   size_t high;"}, {"sha": "40c31f823151d23e6057c4007c029e96680e2656", "filename": "libgo/runtime/map.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea/libgo%2Fruntime%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea/libgo%2Fruntime%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmap.h?ref=4e7e7a49b760bc46bf0ade36c25a7d8e088b6dea", "patch": "@@ -1,10 +1,11 @@\n /* map.h -- the map type for Go.\n \n-   Copyright 2009, 2010 The Go Authors. All rights reserved.\n+   Copyright 2009 The Go Authors. All rights reserved.\n    Use of this source code is governed by a BSD-style\n    license that can be found in the LICENSE file.  */\n \n #include <stddef.h>\n+#include <stdint.h>\n \n #include \"go-type.h\"\n \n@@ -38,10 +39,10 @@ struct __go_map\n   const struct __go_map_descriptor *__descriptor;\n \n   /* The number of elements in the hash table.  */\n-  size_t __element_count;\n+  uintptr_t __element_count;\n \n   /* The number of entries in the __buckets array.  */\n-  size_t __bucket_count;\n+  uintptr_t __bucket_count;\n \n   /* Each bucket is a pointer to a linked list of map entries.  */\n   void **__buckets;\n@@ -64,13 +65,13 @@ struct __go_hash_iter\n      all the entries in the current bucket.  */\n   const void *next_entry;\n   /* The bucket index of the current and next entry.  */\n-  size_t bucket;\n+  uintptr_t bucket;\n };\n \n extern struct __go_map *__go_new_map (const struct __go_map_descriptor *,\n \t\t\t\t      uintptr_t);\n \n-extern unsigned long __go_map_next_prime (unsigned long);\n+extern uintptr_t __go_map_next_prime (uintptr_t);\n \n extern void *__go_map_index (struct __go_map *, const void *, _Bool);\n "}]}