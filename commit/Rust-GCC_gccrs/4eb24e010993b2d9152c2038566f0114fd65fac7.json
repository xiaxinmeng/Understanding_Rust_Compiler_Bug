{"sha": "4eb24e010993b2d9152c2038566f0114fd65fac7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGViMjRlMDEwOTkzYjJkOTE1MmMyMDM4NTY2ZjAxMTRmZDY1ZmFjNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-06-14T20:18:34Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-06-14T20:18:34Z"}, "message": "P0145R2: Refining Expression Order for C++.\n\ngcc/c-family/\n\t* c.opt (fargs-in-order): New.\n\t* c-opts.c (c_common_post_options): Adjust flag_args_in_order.\ngcc/cp/\n\t* cp-tree.h (CALL_EXPR_OPERATOR_SYNTAX, CALL_EXPR_ORDERED_ARGS)\n\t(CALL_EXPR_REVERSE_ARGS): New.\n\t* call.c (build_new_op_1): Set them.\n\t(extract_call_expr, op_is_ordered): New.\n\t(build_over_call): Set CALL_EXPR_ORDERED_ARGS.\n\t* cp-gimplify.c (cp_gimplify_expr) [CALL_EXPR]: Handle new flags.\n\t* pt.c (tsubst_copy_and_build): Copy new flags.\n\t* semantics.c (simplify_aggr_init_expr): Likewise.\n\t* tree.c (build_aggr_init_expr): Likewise.\n\t(build_min_non_dep_op_overload): Likewise.\n\nFrom-SVN: r237459", "tree": {"sha": "072a2558b885b3a6234c21b60e349923722e60dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/072a2558b885b3a6234c21b60e349923722e60dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4eb24e010993b2d9152c2038566f0114fd65fac7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eb24e010993b2d9152c2038566f0114fd65fac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4eb24e010993b2d9152c2038566f0114fd65fac7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eb24e010993b2d9152c2038566f0114fd65fac7/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a09c81b4ba40aac99fd4c37654e1231f4836f891", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a09c81b4ba40aac99fd4c37654e1231f4836f891", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a09c81b4ba40aac99fd4c37654e1231f4836f891"}], "stats": {"total": 443, "additions": 403, "deletions": 40}, "files": [{"sha": "08302e1c5bd153cf3472da9870d872376b79945c", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=4eb24e010993b2d9152c2038566f0114fd65fac7", "patch": "@@ -1,3 +1,9 @@\n+2016-06-14  Jason Merrill  <jason@redhat.com>\n+\n+\tP0145R2: Refining Expression Order for C++.\n+\t* c.opt (fargs-in-order): New.\n+\t* c-opts.c (c_common_post_options): Adjust flag_args_in_order.\n+\n 2016-06-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR sanitizer/71498"}, {"sha": "ff6339c44b67d0e07a63d1035283f935c83e752b", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=4eb24e010993b2d9152c2038566f0114fd65fac7", "patch": "@@ -910,6 +910,12 @@ c_common_post_options (const char **pfilename)\n   else if (warn_narrowing == -1)\n     warn_narrowing = 0;\n \n+  /* C++17 requires that function arguments be evaluated left-to-right even on\n+     PUSH_ARGS_REVERSED targets.  */\n+  if (c_dialect_cxx ()\n+      && flag_args_in_order == -1)\n+    flag_args_in_order = 2 /*(cxx_dialect >= cxx1z) ? 2 : 0*/;\n+\n   /* Global sized deallocation is new in C++14.  */\n   if (flag_sized_deallocation == -1)\n     flag_sized_deallocation = (cxx_dialect >= cxx14);"}, {"sha": "83fd84ccc0f506a9cdb53ff9ce9cef6931132ce6", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=4eb24e010993b2d9152c2038566f0114fd65fac7", "patch": "@@ -1043,6 +1043,14 @@ falt-external-templates\n C++ ObjC++ Ignore Warn(switch %qs is no longer supported)\n No longer supported.\n \n+fargs-in-order\n+C++ ObjC++ Alias(fargs-in-order=, 2, 0)\n+Always evaluate function arguments in left-to-right order.\n+\n+fargs-in-order=\n+C++ ObjC++ Var(flag_args_in_order) Joined UInteger Init(-1)\n+Always evaluate function arguments in left-to-right order.\n+\n fasm\n C ObjC C++ ObjC++ Var(flag_no_asm, 0)\n Recognize the \\\"asm\\\" keyword."}, {"sha": "54e934af572b4e4606e164f4ed59dfddc6ce6a48", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4eb24e010993b2d9152c2038566f0114fd65fac7", "patch": "@@ -1,3 +1,17 @@\n+2016-06-14  Jason Merrill  <jason@redhat.com>\n+\n+\tP0145R2: Refining Expression Order for C++.\n+\t* cp-tree.h (CALL_EXPR_OPERATOR_SYNTAX, CALL_EXPR_ORDERED_ARGS)\n+\t(CALL_EXPR_REVERSE_ARGS): New.\n+\t* call.c (build_new_op_1): Set them.\n+\t(extract_call_expr, op_is_ordered): New.\n+\t(build_over_call): Set CALL_EXPR_ORDERED_ARGS.\n+\t* cp-gimplify.c (cp_gimplify_expr) [CALL_EXPR]: Handle new flags.\n+\t* pt.c (tsubst_copy_and_build): Copy new flags.\n+\t* semantics.c (simplify_aggr_init_expr): Likewise.\n+\t* tree.c (build_aggr_init_expr): Likewise.\n+\t(build_min_non_dep_op_overload): Likewise.\n+\n 2016-06-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/71528"}, {"sha": "e2b89b8a2c44ac620a89d4c75d61dda6b10da1d4", "filename": "gcc/cp/call.c", "status": "modified", "additions": 90, "deletions": 17, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4eb24e010993b2d9152c2038566f0114fd65fac7", "patch": "@@ -5372,6 +5372,40 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n     }\n }\n \n+/* Returns 1 if P0145R2 says that the LHS of operator CODE is evaluated first,\n+   -1 if the RHS is evaluated first, or 0 if the order is unspecified.  */\n+\n+static int\n+op_is_ordered (tree_code code)\n+{\n+  if (!flag_args_in_order)\n+    return 0;\n+\n+  switch (code)\n+    {\n+      // 5. b @= a\n+    case MODIFY_EXPR:\n+      return -1;\n+\n+      // 1. a.b\n+      // Not overloadable (yet).\n+      // 2. a->b\n+      // Only one argument.\n+      // 3. a->*b\n+    case MEMBER_REF:\n+      // 6. a[b]\n+    case ARRAY_REF:\n+      // 7. a << b\n+    case LSHIFT_EXPR:\n+      // 8. a >> b\n+    case RSHIFT_EXPR:\n+      return 1;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n static tree\n build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n \t\ttree arg2, tree arg3, tree *overload, tsubst_flags_t complain)\n@@ -5660,17 +5694,33 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n \t  else\n \t    result = build_over_call (cand, LOOKUP_NORMAL, complain);\n \n-\t  if (processing_template_decl\n-\t      && result != NULL_TREE\n-\t      && result != error_mark_node\n-\t      && DECL_HIDDEN_FRIEND_P (cand->fn))\n+\t  if (trivial_fn_p (cand->fn))\n+\t    /* There won't be a CALL_EXPR.  */;\n+\t  else if (result && result != error_mark_node)\n \t    {\n-\t      tree call = result;\n-\t      if (REFERENCE_REF_P (call))\n-\t\tcall = TREE_OPERAND (call, 0);\n-\t      /* This prevents build_new_function_call from discarding this\n-\t\t function during instantiation of the enclosing template.  */\n-\t      KOENIG_LOOKUP_P (call) = 1;\n+\t      tree call = extract_call_expr (result);\n+\t      CALL_EXPR_OPERATOR_SYNTAX (call) = true;\n+\n+\t      if (processing_template_decl && DECL_HIDDEN_FRIEND_P (cand->fn))\n+\t\t/* This prevents build_new_function_call from discarding this\n+\t\t   function during instantiation of the enclosing template.  */\n+\t\tKOENIG_LOOKUP_P (call) = 1;\n+\n+\t      /* Specify evaluation order as per P0145R2.  */\n+\t      CALL_EXPR_ORDERED_ARGS (call) = false;\n+\t      switch (op_is_ordered (code))\n+\t\t{\n+\t\tcase -1:\n+\t\t  CALL_EXPR_REVERSE_ARGS (call) = true;\n+\t\t  break;\n+\n+\t\tcase 1:\n+\t\t  CALL_EXPR_ORDERED_ARGS (call) = true;\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n \t    }\n \t}\n       else\n@@ -5846,6 +5896,25 @@ build_new_op (location_t loc, enum tree_code code, int flags,\n   return ret;\n }\n \n+/* CALL was returned by some call-building function; extract the actual\n+   CALL_EXPR from any bits that have been tacked on, e.g. by\n+   convert_from_reference.  */\n+\n+tree\n+extract_call_expr (tree call)\n+{\n+  while (TREE_CODE (call) == COMPOUND_EXPR)\n+    call = TREE_OPERAND (call, 1);\n+  if (REFERENCE_REF_P (call))\n+    call = TREE_OPERAND (call, 0);\n+  if (TREE_CODE (call) == TARGET_EXPR)\n+    call = TARGET_EXPR_INITIAL (call);\n+  gcc_assert (TREE_CODE (call) == CALL_EXPR\n+\t      || TREE_CODE (call) == AGGR_INIT_EXPR\n+\t      || call == error_mark_node);\n+  return call;\n+}\n+\n /* Returns true if FN has two parameters, of which the second has type\n    size_t.  */\n \n@@ -7533,10 +7602,10 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n     }\n \n   /* Ellipsis */\n+  int magic = magic_varargs_p (fn);\n   for (; arg_index < vec_safe_length (args); ++arg_index)\n     {\n       tree a = (*args)[arg_index];\n-      int magic = magic_varargs_p (fn);\n       if (magic == 2)\n \t{\n \t  /* Do no conversions for certain magic varargs.  */\n@@ -7666,9 +7735,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       if (is_really_empty_class (type))\n \t{\n \t  /* Avoid copying empty classes.  */\n-\t  val = build2 (COMPOUND_EXPR, void_type_node, to, arg);\n-\t  TREE_NO_WARNING (val) = 1;\n-\t  val = build2 (COMPOUND_EXPR, type, val, to);\n+\t  val = build2 (COMPOUND_EXPR, type, arg, to);\n \t  TREE_NO_WARNING (val) = 1;\n \t}\n       else if (tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (as_base)))\n@@ -7756,9 +7823,15 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n     }\n \n   tree call = build_cxx_call (fn, nargs, argarray, complain|decltype_flag);\n-  if (TREE_CODE (call) == CALL_EXPR\n-      && (cand->flags & LOOKUP_LIST_INIT_CTOR))\n-    CALL_EXPR_LIST_INIT_P (call) = true;\n+  if (call != error_mark_node\n+      && !magic\n+      && (flag_args_in_order > 1\n+\t  || (cand->flags & LOOKUP_LIST_INIT_CTOR)))\n+    {\n+      tree c = extract_call_expr (call);\n+      /* build_new_op_1 will clear this when appropriate.  */\n+      CALL_EXPR_ORDERED_ARGS (c) = true;\n+    }\n   return call;\n }\n "}, {"sha": "97b043acbf293ba959340c0b97747e1cf361a26c", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=4eb24e010993b2d9152c2038566f0114fd65fac7", "patch": "@@ -565,6 +565,7 @@ int\n cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n {\n   int saved_stmts_are_full_exprs_p = 0;\n+  location_t loc = EXPR_LOC_OR_LOC (*expr_p, input_location);\n   enum tree_code code = TREE_CODE (*expr_p);\n   enum gimplify_status ret;\n \n@@ -752,25 +753,49 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t  cilk_cp_gimplify_call_params_in_spawned_fn (expr_p, pre_p, post_p);\n \t  return (enum gimplify_status) gimplify_cilk_spawn (expr_p);\n \t}\n-      /* DR 1030 says that we need to evaluate the elements of an\n-\t initializer-list in forward order even when it's used as arguments to\n-\t a constructor.  So if the target wants to evaluate them in reverse\n-\t order and there's more than one argument other than 'this', gimplify\n-\t them in order.  */\n       ret = GS_OK;\n-      if (PUSH_ARGS_REVERSED && CALL_EXPR_LIST_INIT_P (*expr_p)\n-\t  && call_expr_nargs (*expr_p) > 2)\n+      if (!CALL_EXPR_FN (*expr_p))\n+\t/* Internal function call.  */;\n+      else if (CALL_EXPR_REVERSE_ARGS (*expr_p))\n \t{\n-\t  int nargs = call_expr_nargs (*expr_p);\n-\t  location_t loc = EXPR_LOC_OR_LOC (*expr_p, input_location);\n-\t  for (int i = 1; i < nargs; ++i)\n+\t  /* This is a call to a (compound) assignment operator that used\n+\t     the operator syntax; gimplify the RHS first.  */\n+\t  gcc_assert (call_expr_nargs (*expr_p) == 2);\n+\t  gcc_assert (!CALL_EXPR_ORDERED_ARGS (*expr_p));\n+\t  enum gimplify_status t\n+\t    = gimplify_arg (&CALL_EXPR_ARG (*expr_p, 1), pre_p, loc);\n+\t  if (t == GS_ERROR)\n+\t    ret = GS_ERROR;\n+\t}\n+      else if (CALL_EXPR_ORDERED_ARGS (*expr_p))\n+\t{\n+\t  /* Leave the last argument for gimplify_call_expr, to avoid problems\n+\t     with __builtin_va_arg_pack().  */\n+\t  int nargs = call_expr_nargs (*expr_p) - 1;\n+\t  for (int i = 0; i < nargs; ++i)\n \t    {\n \t      enum gimplify_status t\n \t\t= gimplify_arg (&CALL_EXPR_ARG (*expr_p, i), pre_p, loc);\n \t      if (t == GS_ERROR)\n \t\tret = GS_ERROR;\n \t    }\n \t}\n+      else if (flag_args_in_order == 1\n+\t       && !CALL_EXPR_OPERATOR_SYNTAX (*expr_p))\n+\t{\n+\t  /* If flag_args_in_order == 1, we don't force an order on all\n+\t     function arguments, but do evaluate the object argument first.  */\n+\t  tree fntype = TREE_TYPE (CALL_EXPR_FN (*expr_p));\n+\t  if (POINTER_TYPE_P (fntype))\n+\t    fntype = TREE_TYPE (fntype);\n+\t  if (TREE_CODE (fntype) == METHOD_TYPE)\n+\t    {\n+\t      enum gimplify_status t\n+\t\t= gimplify_arg (&CALL_EXPR_ARG (*expr_p, 0), pre_p, loc);\n+\t      if (t == GS_ERROR)\n+\t\tret = GS_ERROR;\n+\t    }\n+\t}\n       break;\n \n     case RETURN_EXPR:"}, {"sha": "6c6ad10804eb54b32436d0e5710fd7c231a4f7b2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4eb24e010993b2d9152c2038566f0114fd65fac7", "patch": "@@ -179,19 +179,21 @@ operator == (const cp_expr &lhs, tree rhs)\n       IDENTIFIER_CTOR_OR_DTOR_P (in IDENTIFIER_NODE)\n       BIND_EXPR_BODY_BLOCK (in BIND_EXPR)\n       DECL_NON_TRIVIALLY_INITIALIZED_P (in VAR_DECL)\n-      CALL_EXPR_LIST_INIT_P (in CALL_EXPR, AGGR_INIT_EXPR)\n+      CALL_EXPR_ORDERED_ARGS (in CALL_EXPR, AGGR_INIT_EXPR)\n    4: TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n-\t  or FIELD_DECL).\n+\t  CALL_EXPR, or FIELD_DECL).\n       IDENTIFIER_TYPENAME_P (in IDENTIFIER_NODE)\n       DECL_TINFO_P (in VAR_DECL)\n       FUNCTION_REF_QUALIFIED (in FUNCTION_TYPE, METHOD_TYPE)\n    5: C_IS_RESERVED_WORD (in IDENTIFIER_NODE)\n       DECL_VTABLE_OR_VTT_P (in VAR_DECL)\n       FUNCTION_RVALUE_QUALIFIED (in FUNCTION_TYPE, METHOD_TYPE)\n+      CALL_EXPR_REVERSE_ARGS (in CALL_EXPR, AGGR_INIT_EXPR)\n    6: IDENTIFIER_REPO_CHOSEN (in IDENTIFIER_NODE)\n       DECL_CONSTRUCTION_VTABLE_P (in VAR_DECL)\n       TYPE_MARKED_P (in _TYPE)\n       RANGE_FOR_IVDEP (in RANGE_FOR_STMT)\n+      CALL_EXPR_OPERATOR_SYNTAX (in CALL_EXPR, AGGR_INIT_EXPR)\n \n    Usage of TYPE_LANG_FLAG_?:\n    0: TYPE_DEPENDENT_P\n@@ -3379,6 +3381,9 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n #define DELETE_EXPR_USE_VEC(NODE) \\\n   TREE_LANG_FLAG_1 (DELETE_EXPR_CHECK (NODE))\n \n+#define CALL_OR_AGGR_INIT_CHECK(NODE) \\\n+  TREE_CHECK2 ((NODE), CALL_EXPR, AGGR_INIT_EXPR)\n+\n /* Indicates that this is a non-dependent COMPOUND_EXPR which will\n    resolve to a function call.  */\n #define COMPOUND_EXPR_OVERLOADED(NODE) \\\n@@ -3388,9 +3393,20 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n    should be performed at instantiation time.  */\n #define KOENIG_LOOKUP_P(NODE) TREE_LANG_FLAG_0 (CALL_EXPR_CHECK (NODE))\n \n-/* True if CALL_EXPR expresses list-initialization of an object.  */\n-#define CALL_EXPR_LIST_INIT_P(NODE) \\\n-  TREE_LANG_FLAG_3 (TREE_CHECK2 ((NODE),CALL_EXPR,AGGR_INIT_EXPR))\n+/* True if the arguments to NODE should be evaluated in left-to-right\n+   order regardless of PUSH_ARGS_REVERSED.  */\n+#define CALL_EXPR_ORDERED_ARGS(NODE) \\\n+  TREE_LANG_FLAG_3 (CALL_OR_AGGR_INIT_CHECK (NODE))\n+\n+/* True if the arguments to NODE should be evaluated in right-to-left\n+   order regardless of PUSH_ARGS_REVERSED.  */\n+#define CALL_EXPR_REVERSE_ARGS(NODE) \\\n+  TREE_LANG_FLAG_5 (CALL_OR_AGGR_INIT_CHECK (NODE))\n+\n+/* True if CALL_EXPR was written as an operator expression, not a function\n+   call.  */\n+#define CALL_EXPR_OPERATOR_SYNTAX(NODE) \\\n+  TREE_LANG_FLAG_6 (CALL_OR_AGGR_INIT_CHECK (NODE))\n \n /* Indicates whether a string literal has been parenthesized. Such\n    usages are disallowed in certain circumstances.  */\n@@ -5542,6 +5558,7 @@ extern bool null_ptr_cst_p\t\t\t(tree);\n extern bool null_member_pointer_value_p\t\t(tree);\n extern bool sufficient_parms_p\t\t\t(const_tree);\n extern tree type_decays_to\t\t\t(tree);\n+extern tree extract_call_expr\t\t\t(tree);\n extern tree build_user_type_conversion\t\t(tree, tree, int,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_new_function_call\t\t(tree, vec<tree, va_gc> **, bool, "}, {"sha": "11b5d822a351114e39a2aef5e2fa1d5ea03d51f1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4eb24e010993b2d9152c2038566f0114fd65fac7", "patch": "@@ -16652,6 +16652,20 @@ tsubst_copy_and_build (tree t,\n \n \trelease_tree_vector (call_args);\n \n+\tif (ret != error_mark_node)\n+\t  {\n+\t    bool op = CALL_EXPR_OPERATOR_SYNTAX (t);\n+\t    bool ord = CALL_EXPR_ORDERED_ARGS (t);\n+\t    bool rev = CALL_EXPR_REVERSE_ARGS (t);\n+\t    if (op || ord || rev)\n+\t      {\n+\t\tfunction = extract_call_expr (ret);\n+\t\tCALL_EXPR_OPERATOR_SYNTAX (function) = op;\n+\t\tCALL_EXPR_ORDERED_ARGS (function) = ord;\n+\t\tCALL_EXPR_REVERSE_ARGS (function) = rev;\n+\t      }\n+\t  }\n+\n \tRETURN (ret);\n       }\n "}, {"sha": "9b0cff8c3107c70857f92bfd9e6a4b11e8a8b54b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=4eb24e010993b2d9152c2038566f0114fd65fac7", "patch": "@@ -4057,8 +4057,11 @@ simplify_aggr_init_expr (tree *tp)\n \t\t\t\t    aggr_init_expr_nargs (aggr_init_expr),\n \t\t\t\t    AGGR_INIT_EXPR_ARGP (aggr_init_expr));\n   TREE_NOTHROW (call_expr) = TREE_NOTHROW (aggr_init_expr);\n-  CALL_EXPR_LIST_INIT_P (call_expr) = CALL_EXPR_LIST_INIT_P (aggr_init_expr);\n   CALL_FROM_THUNK_P (call_expr) = AGGR_INIT_FROM_THUNK_P (aggr_init_expr);\n+  CALL_EXPR_OPERATOR_SYNTAX (call_expr)\n+    = CALL_EXPR_OPERATOR_SYNTAX (aggr_init_expr);\n+  CALL_EXPR_ORDERED_ARGS (call_expr) = CALL_EXPR_ORDERED_ARGS (aggr_init_expr);\n+  CALL_EXPR_REVERSE_ARGS (call_expr) = CALL_EXPR_REVERSE_ARGS (aggr_init_expr);\n \n   if (style == ctor)\n     {"}, {"sha": "9ab964d0b132ef0bf3537e89f5b574f44a660300", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=4eb24e010993b2d9152c2038566f0114fd65fac7", "patch": "@@ -524,7 +524,9 @@ build_aggr_init_expr (tree type, tree init)\n       TREE_SIDE_EFFECTS (rval) = 1;\n       AGGR_INIT_VIA_CTOR_P (rval) = is_ctor;\n       TREE_NOTHROW (rval) = TREE_NOTHROW (init);\n-      CALL_EXPR_LIST_INIT_P (rval) = CALL_EXPR_LIST_INIT_P (init);\n+      CALL_EXPR_OPERATOR_SYNTAX (rval) = CALL_EXPR_OPERATOR_SYNTAX (init);\n+      CALL_EXPR_ORDERED_ARGS (rval) = CALL_EXPR_ORDERED_ARGS (init);\n+      CALL_EXPR_REVERSE_ARGS (rval) = CALL_EXPR_REVERSE_ARGS (init);\n     }\n   else\n     rval = init;\n@@ -2854,8 +2856,7 @@ build_min_non_dep_op_overload (enum tree_code op,\n   tree fn, call;\n   vec<tree, va_gc> *args;\n \n-  if (REFERENCE_REF_P (non_dep))\n-    non_dep = TREE_OPERAND (non_dep, 0);\n+  non_dep = extract_call_expr (non_dep);\n \n   nargs = call_expr_nargs (non_dep);\n \n@@ -2897,10 +2898,11 @@ build_min_non_dep_op_overload (enum tree_code op,\n   call = build_min_non_dep_call_vec (non_dep, fn, args);\n   release_tree_vector (args);\n \n-  tree call_expr = call;\n-  if (REFERENCE_REF_P (call_expr))\n-    call_expr = TREE_OPERAND (call_expr, 0);\n+  tree call_expr = extract_call_expr (call);\n   KOENIG_LOOKUP_P (call_expr) = KOENIG_LOOKUP_P (non_dep);\n+  CALL_EXPR_OPERATOR_SYNTAX (call_expr) = true;\n+  CALL_EXPR_ORDERED_ARGS (call_expr) = CALL_EXPR_ORDERED_ARGS (non_dep);\n+  CALL_EXPR_REVERSE_ARGS (call_expr) = CALL_EXPR_REVERSE_ARGS (non_dep);\n \n   return call;\n }"}, {"sha": "21053511dedac8bb95a9f6c73a93603b4cd6ff07", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=4eb24e010993b2d9152c2038566f0114fd65fac7", "patch": "@@ -189,7 +189,8 @@ in the following sections.\n \n @item C++ Language Options\n @xref{C++ Dialect Options,,Options Controlling C++ Dialect}.\n-@gccoptlist{-fabi-version=@var{n}  -fno-access-control  -fcheck-new @gol\n+@gccoptlist{-fabi-version=@var{n}  -fno-access-control @gol\n+-fargs-in-order=@var{n} -fcheck-new @gol\n -fconstexpr-depth=@var{n}  -ffriend-injection @gol\n -fno-elide-constructors @gol\n -fno-enforce-eh-specs @gol\n@@ -2233,6 +2234,14 @@ option is used for the warning.\n Turn off all access checking.  This switch is mainly useful for working\n around bugs in the access control code.\n \n+@item -fargs-in-order\n+@opindex fargs-in-order\n+Evaluate function arguments and operands of some binary expressions in\n+left-to-right order, and evaluate the right side of an assignment\n+before the left side, as proposed in P0145R2.  Enabled by default with\n+@option{-std=c++1z}.  @option{-fargs-in-order=1} implements all of the\n+ordering requirements except function arguments.\n+\n @item -fcheck-new\n @opindex fcheck-new\n Check that the pointer returned by @code{operator new} is non-null"}, {"sha": "278990d6f8e16a6f29a947a9fe16a333c55ad9f3", "filename": "gcc/testsuite/g++.dg/cpp1z/eval-order1.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Feval-order1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Feval-order1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Feval-order1.C?ref=4eb24e010993b2d9152c2038566f0114fd65fac7", "patch": "@@ -0,0 +1,21 @@\n+// P0145R2: Refining Expression Order for C++\n+// { dg-do run }\n+// { dg-options \"-std=c++1z\" }\n+\n+extern \"C\" int printf (const char *, ...);\n+void sink(...) { }\n+\n+int last = 0;\n+int f(int i)\n+{\n+  if (i < last)\n+    __builtin_abort ();\n+  last = i;\n+  return i;\n+}\n+\n+int main()\n+{\n+  sink(f(1), f(2));\n+  sink(f(3), f(4), f(5));\n+}"}, {"sha": "2a741d687b5f041859cb76eea6a69b802c69bfe4", "filename": "gcc/testsuite/g++.dg/cpp1z/eval-order2.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Feval-order2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Feval-order2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Feval-order2.C?ref=4eb24e010993b2d9152c2038566f0114fd65fac7", "patch": "@@ -0,0 +1,15 @@\n+// P0145R2: Refining Expression Order for C++\n+// { dg-do run }\n+// { dg-options \"-std=c++1z\" }\n+\n+#include <string>\n+#define assert(X) if (!(X)) __builtin_abort();\n+\n+int main()\n+{\n+  std::string s = \"but I have heard it works even if you don't believe in it\" ;\n+  s.replace(0, 4, \"\" ).replace( s.find( \"even\" ), 4, \"only\" )\n+    .replace( s.find( \" don't\" ), 6, \"\" );\n+\n+  assert( s == \"I have heard it works only if you believe in it\" ) ;\n+}"}, {"sha": "15df9038107a758582d3205e2af5f4cc1fb87b5f", "filename": "gcc/testsuite/g++.dg/cpp1z/eval-order3.C", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Feval-order3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eb24e010993b2d9152c2038566f0114fd65fac7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Feval-order3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Feval-order3.C?ref=4eb24e010993b2d9152c2038566f0114fd65fac7", "patch": "@@ -0,0 +1,150 @@\n+// P0145R2: Refining Expression Order for C++\n+// { dg-do run }\n+// { dg-options \"-std=c++1z -fargs-in-order=1\" }\n+\n+extern \"C\" int printf (const char *, ...);\n+void sink(...) { }\n+\n+int last = 0;\n+int f(int i)\n+{\n+  if (i < last)\n+    __builtin_abort ();\n+  last = i;\n+  return i;\n+}\n+\n+int& g(int i)\n+{\n+  static int dummy;\n+  f(i);\n+  return dummy;\n+}\n+\n+struct A\n+{\n+  int _i;\n+  A(int i): _i(f(i)) { }\n+  A& memfn(int i, int j) { f(j); return *this; }\n+  int operator<<(int i) { }\n+  A& operator=(const A&) { return *this; }\n+  A& operator+=(int i) { return *this; }\n+};\n+\n+int operator>>(A&, int i) { }\n+\n+A a(0);\n+A* afn(int i)\n+{\n+  f(i);\n+  return &a;\n+}\n+\n+A& aref(int i)\n+{\n+  f(i);\n+  return a;\n+}\n+\n+static int si;\n+int* ip (int i)\n+{\n+  f(i);\n+  return &si;\n+}\n+\n+int& iref(int i)\n+{\n+  f(i);\n+  return si;\n+}\n+\n+auto pmff(int i) {\n+  f(i);\n+  return &A::memfn;\n+}\n+\n+template <class T> void f()\n+{\n+  // a.b\n+  A(1).memfn(f(2),3).memfn(f(4),5);\n+  aref(6).memfn(f(7),8);\n+  (aref(9).*pmff(10))(f(11),12);\n+  last = 0;\n+\n+  // a->b\n+  afn(12)->memfn(f(13),14);\n+\n+  // a->*b\n+  (afn(15)->*pmff(16))(f(17),18);\n+  last = 0;\n+\n+  // a(b)\n+  // covered in eval-order1.C\n+\n+  // b @= a\n+  aref(19)=A(18);\n+  //iref(21)=f(20);\n+  aref(23)+=f(22);\n+  last = 0;\n+\n+  // a[b]\n+  afn(20)[f(21)-21].memfn(f(22),23);\n+  ip(24)[f(25)-25] = 0;\n+  last=0;\n+\n+  // a << b\n+  aref(24) << f(25);\n+  iref(26) << f(27);\n+  last=0;\n+\n+  // a >> b\n+  aref(26) >> f(27);\n+  iref(28) >> f(29);\n+}\n+\n+void g()\n+{\n+  // a.b\n+  A(1).memfn(f(2),3).memfn(f(4),5);\n+  aref(6).memfn(f(7),8);\n+  (aref(9).*pmff(10))(f(11),12);\n+  last = 0;\n+\n+  // a->b\n+  afn(12)->memfn(f(13),14);\n+\n+  // a->*b\n+  (afn(15)->*pmff(16))(f(17),18);\n+  last = 0;\n+\n+  // a(b)\n+  // covered in eval-order1.C\n+\n+  // b @= a\n+  aref(19)=A(18);\n+  //iref(21)=f(20);\n+  aref(23)+=f(22);\n+  last = 0;\n+\n+  // a[b]\n+  afn(20)[f(21)-21].memfn(f(22),23);\n+  ip(24)[f(25)-25] = 0;\n+  last=0;\n+\n+  // a << b\n+  aref(24) << f(25);\n+  iref(26) << f(27);\n+  last=0;\n+\n+  // a >> b\n+  aref(26) >> f(27);\n+  iref(28) >> f(29);\n+}\n+\n+int main()\n+{\n+  g();\n+  last = 0;\n+  f<int>();\n+}"}]}