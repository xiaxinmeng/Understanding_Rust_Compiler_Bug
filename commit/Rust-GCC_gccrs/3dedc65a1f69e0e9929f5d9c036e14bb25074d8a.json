{"sha": "3dedc65a1f69e0e9929f5d9c036e14bb25074d8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RlZGM2NWExZjY5ZTBlOTkyOWY1ZDljMDM2ZTE0YmIyNTA3NGQ4YQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@seba.cygnus.com", "date": "1997-08-27T16:58:02Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-08-27T16:58:02Z"}, "message": "c-decl.c (grokdeclarator): If array index or size calculations overflow, issue an error.\n\n        * c-decl.c (grokdeclarator): If array index or size calculations\n        overflow, issue an error.\n        * fold-const.c (int_const_binop): New static function.\n        (const_binop, size_binop): Call it.\nBrought over from the fsf.\n\nFrom-SVN: r14967", "tree": {"sha": "108a7d1cdb95f1ef6bdac97fc0a9435314db54f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/108a7d1cdb95f1ef6bdac97fc0a9435314db54f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3dedc65a1f69e0e9929f5d9c036e14bb25074d8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dedc65a1f69e0e9929f5d9c036e14bb25074d8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dedc65a1f69e0e9929f5d9c036e14bb25074d8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dedc65a1f69e0e9929f5d9c036e14bb25074d8a/comments", "author": null, "committer": null, "parents": [{"sha": "88016fb7ef61bcc40b7cf8b1d6c6511a8896f594", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88016fb7ef61bcc40b7cf8b1d6c6511a8896f594", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88016fb7ef61bcc40b7cf8b1d6c6511a8896f594"}], "stats": {"total": 358, "additions": 203, "deletions": 155}, "files": [{"sha": "4d422316d20e0c59d5863b9431aaeb55afe75e39", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dedc65a1f69e0e9929f5d9c036e14bb25074d8a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dedc65a1f69e0e9929f5d9c036e14bb25074d8a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3dedc65a1f69e0e9929f5d9c036e14bb25074d8a", "patch": "@@ -2,6 +2,11 @@ Wed Aug 27 01:56:18 1997  Doug Evans  <dje@seba.cygnus.com>\n \n \t* loop.c (combine_movables): Earlier insns don't match later ones.\n \n+\t* c-decl.c (grokdeclarator): If array index or size calculations\n+\toverflow, issue an error.\n+\t* fold-const.c (int_const_binop): New static function.\n+\t(const_binop, size_binop): Call it.\n+\n Wed Aug 27 01:24:25 1997  H.J. Lu   (hjl@gnu.ai.mit.edu)\n \n \t* config/linux.h (CC1_SPEC): Define it only if not defined."}, {"sha": "316ada7104091dacf5fd9422eb39910b3726e0bc", "filename": "gcc/c-decl.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dedc65a1f69e0e9929f5d9c036e14bb25074d8a/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dedc65a1f69e0e9929f5d9c036e14bb25074d8a/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=3dedc65a1f69e0e9929f5d9c036e14bb25074d8a", "patch": "@@ -4672,6 +4672,18 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t\t\t\t   convert (index_type, size),\n \t\t\t\t   convert (index_type, size_one_node)));\n \n+\t      /* If that overflowed, the array is too big.\n+\t\t ??? While a size of INT_MAX+1 technically shouldn't cause\n+\t\t an overflow (because we subtract 1), the overflow is recorded\n+\t\t during the conversion to index_type, before the subtraction.\n+\t\t Handling this case seems like an unnecessary complication.  */\n+\t      if (TREE_OVERFLOW (itype))\n+\t\t{\n+\t\t  error (\"size of array `%s' is too large\", name);\n+\t\t  type = error_mark_node;\n+\t\t  continue;\n+\t\t}\n+\n \t      if (size_varies)\n \t\titype = variable_size (itype);\n \t      itype = build_index_type (itype);\n@@ -4847,6 +4859,13 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \n   /* Now TYPE has the actual type.  */\n \n+  /* Did array size calculations overflow?  */\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE\n+      && TYPE_SIZE (type)\n+      && TREE_OVERFLOW (TYPE_SIZE (type)))\n+    error (\"size of array `%s' is too large\", name);\n+\n   /* If this is declaring a typedef name, return a TYPE_DECL.  */\n \n   if (specbits & (1 << (int) RID_TYPEDEF))"}, {"sha": "f62dd9460a0773c37d36ec6014c85c45623bd62d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 179, "deletions": 155, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dedc65a1f69e0e9929f5d9c036e14bb25074d8a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dedc65a1f69e0e9929f5d9c036e14bb25074d8a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=3dedc65a1f69e0e9929f5d9c036e14bb25074d8a", "patch": "@@ -62,6 +62,7 @@ int div_and_round_double\tPROTO((enum tree_code, int, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT *));\n static int split_tree\t\tPROTO((tree, enum tree_code, tree *,\n \t\t\t\t       tree *, int *));\n+static tree int_const_binop\tPROTO((enum tree_code, tree, tree, int, int));\n static tree const_binop\t\tPROTO((enum tree_code, tree, tree, int));\n static tree fold_convert\tPROTO((tree, tree));\n static enum tree_code invert_tree_comparison PROTO((enum tree_code));\n@@ -1051,192 +1052,215 @@ split_tree (in, code, varp, conp, varsignp)\n   return 0;\n }\n \f\n-/* Combine two constants ARG1 and ARG2 under operation CODE\n+/* Combine two integer constants ARG1 and ARG2 under operation CODE\n    to produce a new constant.\n-   We assume ARG1 and ARG2 have the same data type,\n-   or at least are the same kind of constant and the same machine mode.\n \n-   If NOTRUNC is nonzero, do not truncate the result to fit the data type.  */\n+   If NOTRUNC is nonzero, do not truncate the result to fit the data type.\n+   If FORSIZE is nonzero, compute overflow for unsigned types.  */\n \n static tree\n-const_binop (code, arg1, arg2, notrunc)\n+int_const_binop (code, arg1, arg2, notrunc, forsize)\n      enum tree_code code;\n      register tree arg1, arg2;\n-     int notrunc;\n+     int notrunc, forsize;\n {\n-  STRIP_NOPS (arg1); STRIP_NOPS (arg2);\n+  HOST_WIDE_INT int1l, int1h, int2l, int2h;\n+  HOST_WIDE_INT low, hi;\n+  HOST_WIDE_INT garbagel, garbageh;\n+  register tree t;\n+  int uns = TREE_UNSIGNED (TREE_TYPE (arg1));\n+  int overflow = 0;\n+  int no_overflow = 0;\n \n-  if (TREE_CODE (arg1) == INTEGER_CST)\n+  int1l = TREE_INT_CST_LOW (arg1);\n+  int1h = TREE_INT_CST_HIGH (arg1);\n+  int2l = TREE_INT_CST_LOW (arg2);\n+  int2h = TREE_INT_CST_HIGH (arg2);\n+\n+  switch (code)\n     {\n-      register HOST_WIDE_INT int1l = TREE_INT_CST_LOW (arg1);\n-      register HOST_WIDE_INT int1h = TREE_INT_CST_HIGH (arg1);\n-      HOST_WIDE_INT int2l = TREE_INT_CST_LOW (arg2);\n-      HOST_WIDE_INT int2h = TREE_INT_CST_HIGH (arg2);\n-      HOST_WIDE_INT low, hi;\n-      HOST_WIDE_INT garbagel, garbageh;\n-      register tree t;\n-      int uns = TREE_UNSIGNED (TREE_TYPE (arg1));\n-      int overflow = 0;\n-      int no_overflow = 0;\n+    case BIT_IOR_EXPR:\n+      low = int1l | int2l, hi = int1h | int2h;\n+      break;\n \n-      switch (code)\n-\t{\n-\tcase BIT_IOR_EXPR:\n-\t  low = int1l | int2l, hi = int1h | int2h;\n-\t  break;\n+    case BIT_XOR_EXPR:\n+      low = int1l ^ int2l, hi = int1h ^ int2h;\n+      break;\n \n-\tcase BIT_XOR_EXPR:\n-\t  low = int1l ^ int2l, hi = int1h ^ int2h;\n-\t  break;\n+    case BIT_AND_EXPR:\n+      low = int1l & int2l, hi = int1h & int2h;\n+      break;\n \n-\tcase BIT_AND_EXPR:\n-\t  low = int1l & int2l, hi = int1h & int2h;\n-\t  break;\n+    case BIT_ANDTC_EXPR:\n+      low = int1l & ~int2l, hi = int1h & ~int2h;\n+      break;\n \n-\tcase BIT_ANDTC_EXPR:\n-\t  low = int1l & ~int2l, hi = int1h & ~int2h;\n-\t  break;\n+    case RSHIFT_EXPR:\n+      int2l = - int2l;\n+    case LSHIFT_EXPR:\n+      /* It's unclear from the C standard whether shifts can overflow.\n+\t The following code ignores overflow; perhaps a C standard\n+\t interpretation ruling is needed.  */\n+      lshift_double (int1l, int1h, int2l,\n+\t\t     TYPE_PRECISION (TREE_TYPE (arg1)),\n+\t\t     &low, &hi,\n+\t\t     !uns);\n+      no_overflow = 1;\n+      break;\n \n-\tcase RSHIFT_EXPR:\n-\t  int2l = - int2l;\n-\tcase LSHIFT_EXPR:\n-\t  /* It's unclear from the C standard whether shifts can overflow.\n-\t     The following code ignores overflow; perhaps a C standard\n-\t     interpretation ruling is needed.  */\n-\t  lshift_double (int1l, int1h, int2l,\n-\t\t\t TYPE_PRECISION (TREE_TYPE (arg1)),\n-\t\t\t &low, &hi,\n-\t\t\t !uns);\n-\t  no_overflow = 1;\n-\t  break;\n+    case RROTATE_EXPR:\n+      int2l = - int2l;\n+    case LROTATE_EXPR:\n+      lrotate_double (int1l, int1h, int2l,\n+\t\t      TYPE_PRECISION (TREE_TYPE (arg1)),\n+\t\t      &low, &hi);\n+      break;\n \n-\tcase RROTATE_EXPR:\n-\t  int2l = - int2l;\n-\tcase LROTATE_EXPR:\n-\t  lrotate_double (int1l, int1h, int2l,\n-\t\t\t  TYPE_PRECISION (TREE_TYPE (arg1)),\n-\t\t\t  &low, &hi);\n-\t  break;\n+    case PLUS_EXPR:\n+      overflow = add_double (int1l, int1h, int2l, int2h, &low, &hi);\n+      break;\n \n-\tcase PLUS_EXPR:\n-\t  overflow = add_double (int1l, int1h, int2l, int2h, &low, &hi);\n-\t  break;\n+    case MINUS_EXPR:\n+      neg_double (int2l, int2h, &low, &hi);\n+      add_double (int1l, int1h, low, hi, &low, &hi);\n+      overflow = overflow_sum_sign (hi, int2h, int1h);\n+      break;\n \n-\tcase MINUS_EXPR:\n-\t  neg_double (int2l, int2h, &low, &hi);\n-\t  add_double (int1l, int1h, low, hi, &low, &hi);\n-\t  overflow = overflow_sum_sign (hi, int2h, int1h);\n-\t  break;\n+    case MULT_EXPR:\n+      overflow = mul_double (int1l, int1h, int2l, int2h, &low, &hi);\n+      break;\n \n-\tcase MULT_EXPR:\n-\t  overflow = mul_double (int1l, int1h, int2l, int2h, &low, &hi);\n+    case TRUNC_DIV_EXPR:\n+    case FLOOR_DIV_EXPR: case CEIL_DIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+      /* This is a shortcut for a common special case.  */\n+      if (int2h == 0 && int2l > 0\n+\t  && ! TREE_CONSTANT_OVERFLOW (arg1)\n+\t  && ! TREE_CONSTANT_OVERFLOW (arg2)\n+\t  && int1h == 0 && int1l >= 0)\n+\t{\n+\t  if (code == CEIL_DIV_EXPR)\n+\t    int1l += int2l - 1;\n+\t  low = int1l / int2l, hi = 0;\n \t  break;\n+\t}\n \n-\tcase TRUNC_DIV_EXPR:\n-\tcase FLOOR_DIV_EXPR: case CEIL_DIV_EXPR:\n-\tcase EXACT_DIV_EXPR:\n-\t  /* This is a shortcut for a common special case.  */\n-\t  if (int2h == 0 && int2l > 0\n-\t      && ! TREE_CONSTANT_OVERFLOW (arg1)\n-\t      && ! TREE_CONSTANT_OVERFLOW (arg2)\n-\t      && int1h == 0 && int1l >= 0)\n-\t    {\n-\t      if (code == CEIL_DIV_EXPR)\n-\t\tint1l += int2l - 1;\n-\t      low = int1l / int2l, hi = 0;\n-\t      break;\n-\t    }\n-\n-\t  /* ... fall through ... */\n+      /* ... fall through ... */\n \n-\tcase ROUND_DIV_EXPR: \n-\t  if (int2h == 0 && int2l == 1)\n-\t    {\n-\t      low = int1l, hi = int1h;\n-\t      break;\n-\t    }\n-\t  if (int1l == int2l && int1h == int2h\n-\t      && ! (int1l == 0 && int1h == 0))\n-\t    {\n-\t      low = 1, hi = 0;\n-\t      break;\n-\t    }\n-\t  overflow = div_and_round_double (code, uns,\n-\t\t\t\t\t   int1l, int1h, int2l, int2h,\n-\t\t\t\t\t   &low, &hi, &garbagel, &garbageh);\n+    case ROUND_DIV_EXPR: \n+      if (int2h == 0 && int2l == 1)\n+\t{\n+\t  low = int1l, hi = int1h;\n \t  break;\n-\n-\tcase TRUNC_MOD_EXPR:\n-\tcase FLOOR_MOD_EXPR: case CEIL_MOD_EXPR:\n-\t  /* This is a shortcut for a common special case.  */\n-\t  if (int2h == 0 && int2l > 0\n-\t      && ! TREE_CONSTANT_OVERFLOW (arg1)\n-\t      && ! TREE_CONSTANT_OVERFLOW (arg2)\n-\t      && int1h == 0 && int1l >= 0)\n-\t    {\n-\t      if (code == CEIL_MOD_EXPR)\n-\t\tint1l += int2l - 1;\n-\t      low = int1l % int2l, hi = 0;\n-\t      break;\n-\t    }\n-\n-\t  /* ... fall through ... */\n-\n-\tcase ROUND_MOD_EXPR: \n-\t  overflow = div_and_round_double (code, uns,\n-\t\t\t\t\t   int1l, int1h, int2l, int2h,\n-\t\t\t\t\t   &garbagel, &garbageh, &low, &hi);\n+\t}\n+      if (int1l == int2l && int1h == int2h\n+\t  && ! (int1l == 0 && int1h == 0))\n+\t{\n+\t  low = 1, hi = 0;\n \t  break;\n+\t}\n+      overflow = div_and_round_double (code, uns,\n+\t\t\t\t       int1l, int1h, int2l, int2h,\n+\t\t\t\t       &low, &hi, &garbagel, &garbageh);\n+      break;\n \n-\tcase MIN_EXPR:\n-\tcase MAX_EXPR:\n-\t  if (uns)\n-\t    {\n-\t      low = (((unsigned HOST_WIDE_INT) int1h\n-\t\t      < (unsigned HOST_WIDE_INT) int2h)\n-\t\t     || (((unsigned HOST_WIDE_INT) int1h\n-\t\t\t  == (unsigned HOST_WIDE_INT) int2h)\n-\t\t\t && ((unsigned HOST_WIDE_INT) int1l\n-\t\t\t     < (unsigned HOST_WIDE_INT) int2l)));\n-\t    }\n-\t  else\n-\t    {\n-\t      low = ((int1h < int2h)\n-\t\t     || ((int1h == int2h)\n-\t\t\t && ((unsigned HOST_WIDE_INT) int1l\n-\t\t\t     < (unsigned HOST_WIDE_INT) int2l)));\n-\t    }\n-\t  if (low == (code == MIN_EXPR))\n-\t    low = int1l, hi = int1h;\n-\t  else\n-\t    low = int2l, hi = int2h;\n+    case TRUNC_MOD_EXPR:\n+    case FLOOR_MOD_EXPR: case CEIL_MOD_EXPR:\n+      /* This is a shortcut for a common special case.  */\n+      if (int2h == 0 && int2l > 0\n+\t  && ! TREE_CONSTANT_OVERFLOW (arg1)\n+\t  && ! TREE_CONSTANT_OVERFLOW (arg2)\n+\t  && int1h == 0 && int1l >= 0)\n+\t{\n+\t  if (code == CEIL_MOD_EXPR)\n+\t    int1l += int2l - 1;\n+\t  low = int1l % int2l, hi = 0;\n \t  break;\n+\t}\n \n-\tdefault:\n-\t  abort ();\n+      /* ... fall through ... */\n+\n+    case ROUND_MOD_EXPR: \n+      overflow = div_and_round_double (code, uns,\n+\t\t\t\t       int1l, int1h, int2l, int2h,\n+\t\t\t\t       &garbagel, &garbageh, &low, &hi);\n+      break;\n+\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+      if (uns)\n+\t{\n+\t  low = (((unsigned HOST_WIDE_INT) int1h\n+\t\t  < (unsigned HOST_WIDE_INT) int2h)\n+\t\t || (((unsigned HOST_WIDE_INT) int1h\n+\t\t      == (unsigned HOST_WIDE_INT) int2h)\n+\t\t     && ((unsigned HOST_WIDE_INT) int1l\n+\t\t\t < (unsigned HOST_WIDE_INT) int2l)));\n \t}\n-    got_it:\n-      if (TREE_TYPE (arg1) == sizetype && hi == 0\n-\t  && low >= 0 && low <= TREE_INT_CST_LOW (TYPE_MAX_VALUE (sizetype))\n-\t  && ! overflow\n-\t  && ! TREE_OVERFLOW (arg1) && ! TREE_OVERFLOW (arg2))\n-\tt = size_int (low);\n       else\n \t{\n-\t  t = build_int_2 (low, hi);\n-\t  TREE_TYPE (t) = TREE_TYPE (arg1);\n+\t  low = ((int1h < int2h)\n+\t\t || ((int1h == int2h)\n+\t\t     && ((unsigned HOST_WIDE_INT) int1l\n+\t\t\t < (unsigned HOST_WIDE_INT) int2l)));\n \t}\n+      if (low == (code == MIN_EXPR))\n+\tlow = int1l, hi = int1h;\n+      else\n+\tlow = int2l, hi = int2h;\n+      break;\n \n-      TREE_OVERFLOW (t)\n-\t= ((notrunc ? !uns && overflow\n-\t    : force_fit_type (t, overflow && !uns) && ! no_overflow)\n-\t   | TREE_OVERFLOW (arg1)\n-\t   | TREE_OVERFLOW (arg2));\n-      TREE_CONSTANT_OVERFLOW (t) = (TREE_OVERFLOW (t)\n-\t\t\t\t    | TREE_CONSTANT_OVERFLOW (arg1)\n-\t\t\t\t    | TREE_CONSTANT_OVERFLOW (arg2));\n-      return t;\n+    default:\n+      abort ();\n     }\n+\n+  if (TREE_TYPE (arg1) == sizetype && hi == 0\n+      && low >= 0 && low <= TREE_INT_CST_LOW (TYPE_MAX_VALUE (sizetype))\n+      && ! overflow\n+      && ! TREE_OVERFLOW (arg1) && ! TREE_OVERFLOW (arg2))\n+    t = size_int (low);\n+  else\n+    {\n+      t = build_int_2 (low, hi);\n+      TREE_TYPE (t) = TREE_TYPE (arg1);\n+    }\n+\n+  TREE_OVERFLOW (t)\n+    = ((notrunc ? (!uns || forsize) && overflow\n+\t: force_fit_type (t, (!uns || forsize) && overflow) && ! no_overflow)\n+       | TREE_OVERFLOW (arg1)\n+       | TREE_OVERFLOW (arg2));\n+  /* If we're doing a size calculation, unsigned arithmetic does overflow.\n+     So check if force_fit_type truncated the value.  */\n+  if (forsize\n+      && ! TREE_OVERFLOW (t)\n+      && (TREE_INT_CST_HIGH (t) != hi\n+\t  || TREE_INT_CST_LOW (t) != low))\n+    TREE_OVERFLOW (t) = 1;\n+  TREE_CONSTANT_OVERFLOW (t) = (TREE_OVERFLOW (t)\n+\t\t\t\t| TREE_CONSTANT_OVERFLOW (arg1)\n+\t\t\t\t| TREE_CONSTANT_OVERFLOW (arg2));\n+  return t;\n+}\n+\n+/* Combine two constants ARG1 and ARG2 under operation CODE\n+   to produce a new constant.\n+   We assume ARG1 and ARG2 have the same data type,\n+   or at least are the same kind of constant and the same machine mode.\n+\n+   If NOTRUNC is nonzero, do not truncate the result to fit the data type.  */\n+\n+static tree\n+const_binop (code, arg1, arg2, notrunc)\n+     enum tree_code code;\n+     register tree arg1, arg2;\n+     int notrunc;\n+{\n+  STRIP_NOPS (arg1); STRIP_NOPS (arg2);\n+\n+  if (TREE_CODE (arg1) == INTEGER_CST)\n+    return int_const_binop (code, arg1, arg2, notrunc, 0);\n+\n #if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n   if (TREE_CODE (arg1) == REAL_CST)\n     {\n@@ -1450,7 +1474,7 @@ size_binop (code, arg0, arg1)\n \treturn arg1;\n \n       /* Handle general case of two integer constants.  */\n-      return const_binop (code, arg0, arg1, 0);\n+      return int_const_binop (code, arg0, arg1, 0, 1);\n     }\n \n   if (arg0 == error_mark_node || arg1 == error_mark_node)"}]}