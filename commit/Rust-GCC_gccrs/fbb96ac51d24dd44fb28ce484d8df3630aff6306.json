{"sha": "fbb96ac51d24dd44fb28ce484d8df3630aff6306", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJiOTZhYzUxZDI0ZGQ0NGZiMjhjZTQ4NGQ4ZGYzNjMwYWZmNjMwNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-08-08T15:31:00Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-08-08T15:31:00Z"}, "message": "mips.c (mips_symbolic_address_p): Delete.\n\ngcc/\n\t* config/mips/mips.c (mips_symbolic_address_p): Delete.\n\t(mips_symbol_insns_1): New function, split out from...\n\t(mips_symbol_insns): ...here.  Take a mode argument.  Treat loads\n\tand stores separately from load addresses.\n\t(mips_classify_address): Replace uses of mips_symbolic_address_p\n\twith uses of mips_symbol_insns.\n\t(mips_address_insns): Update calls to mips_symbol_insns.\n\t(mips_const_insns): Likewise.\n\t(mips_legitimize_address): Likewise.\n\nFrom-SVN: r127297", "tree": {"sha": "ea1eb4eeba9e8738339bcf707f0ec943724f852e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea1eb4eeba9e8738339bcf707f0ec943724f852e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbb96ac51d24dd44fb28ce484d8df3630aff6306", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbb96ac51d24dd44fb28ce484d8df3630aff6306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbb96ac51d24dd44fb28ce484d8df3630aff6306", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbb96ac51d24dd44fb28ce484d8df3630aff6306/comments", "author": null, "committer": null, "parents": [{"sha": "e06e2776827240de1ffe7d6a0af55dae6f45ad54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e06e2776827240de1ffe7d6a0af55dae6f45ad54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e06e2776827240de1ffe7d6a0af55dae6f45ad54"}], "stats": {"total": 131, "additions": 65, "deletions": 66}, "files": [{"sha": "a2e4f6ae352933353c8049cebca674319ceb4e2f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbb96ac51d24dd44fb28ce484d8df3630aff6306/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbb96ac51d24dd44fb28ce484d8df3630aff6306/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fbb96ac51d24dd44fb28ce484d8df3630aff6306", "patch": "@@ -1,3 +1,15 @@\n+2007-08-08  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config/mips/mips.c (mips_symbolic_address_p): Delete.\n+\t(mips_symbol_insns_1): New function, split out from...\n+\t(mips_symbol_insns): ...here.  Take a mode argument.  Treat loads\n+\tand stores separately from load addresses.\n+\t(mips_classify_address): Replace uses of mips_symbolic_address_p\n+\twith uses of mips_symbol_insns.\n+\t(mips_address_insns): Update calls to mips_symbol_insns.\n+\t(mips_const_insns): Likewise.\n+\t(mips_legitimize_address): Likewise.\n+\n 2007-08-08  Richard Sandiford  <richard@codesourcery.com>\n \n \t* config/mips/mips-protos.h (SYMBOL_FORCE_TO_MEM): New symbol type."}, {"sha": "b8e013e984d69d244e9d6c96712b8526a153658f", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 53, "deletions": 66, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbb96ac51d24dd44fb28ce484d8df3630aff6306/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbb96ac51d24dd44fb28ce484d8df3630aff6306/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=fbb96ac51d24dd44fb28ce484d8df3630aff6306", "patch": "@@ -288,12 +288,11 @@ struct mips_integer_op;\n struct mips_sim;\n \n static bool mips_valid_base_register_p (rtx, enum machine_mode, int);\n-static bool mips_symbolic_address_p (enum mips_symbol_type, enum machine_mode);\n static bool mips_classify_address (struct mips_address_info *, rtx,\n \t\t\t\t   enum machine_mode, int);\n static bool mips_cannot_force_const_mem (rtx);\n static bool mips_use_blocks_for_constant_p (enum machine_mode, rtx);\n-static int mips_symbol_insns (enum mips_symbol_type);\n+static int mips_symbol_insns (enum mips_symbol_type, enum machine_mode);\n static bool mips16_unextended_reference_p (enum machine_mode mode, rtx, rtx);\n static rtx mips_force_temporary (rtx, rtx);\n static rtx mips_unspec_offset_high (rtx, rtx, rtx, enum mips_symbol_type);\n@@ -1673,52 +1672,6 @@ mips_valid_base_register_p (rtx x, enum machine_mode mode, int strict)\n }\n \n \n-/* Return true if symbols of type SYMBOL_TYPE can directly address a value\n-   with mode MODE.  This is used for both symbolic and LO_SUM addresses.  */\n-\n-static bool\n-mips_symbolic_address_p (enum mips_symbol_type symbol_type,\n-\t\t\t enum machine_mode mode)\n-{\n-  switch (symbol_type)\n-    {\n-    case SYMBOL_ABSOLUTE:\n-    case SYMBOL_GP_RELATIVE:\n-      return true;\n-\n-    case SYMBOL_PC_RELATIVE:\n-      /* PC-relative addressing is only available for lw and ld.  */\n-      return GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8;\n-\n-    case SYMBOL_GOT_PAGE_OFST:\n-      return true;\n-\n-    case SYMBOL_FORCE_TO_MEM:\n-    case SYMBOL_GOT_DISP:\n-      /* The address will have to be loaded from the constant pool\n-\t or GOT before it is used in an address.  */\n-      return false;\n-\n-    case SYMBOL_GOTOFF_PAGE:\n-    case SYMBOL_GOTOFF_DISP:\n-    case SYMBOL_GOTOFF_CALL:\n-    case SYMBOL_GOTOFF_LOADGP:\n-    case SYMBOL_TLS:\n-    case SYMBOL_TLSGD:\n-    case SYMBOL_TLSLDM:\n-    case SYMBOL_DTPREL:\n-    case SYMBOL_GOTTPREL:\n-    case SYMBOL_TPREL:\n-    case SYMBOL_64_HIGH:\n-    case SYMBOL_64_MID:\n-    case SYMBOL_64_LOW:\n-    case SYMBOL_HALF:\n-      return true;\n-    }\n-  gcc_unreachable ();\n-}\n-\n-\n /* Return true if X is a valid address for machine mode MODE.  If it is,\n    fill in INFO appropriately.  STRICT is true if we should only accept\n    hard base registers.  */\n@@ -1750,7 +1703,7 @@ mips_classify_address (struct mips_address_info *info, rtx x,\n       return (mips_valid_base_register_p (info->reg, mode, strict)\n \t      && mips_symbolic_constant_p (info->offset, SYMBOL_CONTEXT_MEM,\n \t\t\t\t\t   &info->symbol_type)\n-\t      && mips_symbolic_address_p (info->symbol_type, mode)\n+\t      && mips_symbol_insns (info->symbol_type, mode) > 0\n \t      && mips_lo_relocs[info->symbol_type] != 0);\n \n     case CONST_INT:\n@@ -1765,7 +1718,7 @@ mips_classify_address (struct mips_address_info *info, rtx x,\n       info->type = ADDRESS_SYMBOLIC;\n       return (mips_symbolic_constant_p (x, SYMBOL_CONTEXT_MEM,\n \t\t\t\t\t&info->symbol_type)\n-\t      && mips_symbolic_address_p (info->symbol_type, mode)\n+\t      && mips_symbol_insns (info->symbol_type, mode) > 0\n \t      && !mips_split_p[info->symbol_type]);\n \n     default:\n@@ -1831,13 +1784,13 @@ mips_use_blocks_for_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n   return !TARGET_MIPS16;\n }\n \f\n-/* Return the number of instructions needed to load a symbol of the\n-   given type into a register.  If valid in an address, the same number\n-   of instructions are needed for loads and stores.  Treat extended\n-   mips16 instructions as two instructions.  */\n+/* Like mips_symbol_insns, but treat extended MIPS16 instructions as a\n+   single instruction.  We rely on the fact that, in the worst case,\n+   all instructions involved in a MIPS16 address calculation are usually\n+   extended ones.  */\n \n static int\n-mips_symbol_insns (enum mips_symbol_type type)\n+mips_symbol_insns_1 (enum mips_symbol_type type, enum machine_mode mode)\n {\n   switch (type)\n     {\n@@ -1853,23 +1806,37 @@ mips_symbol_insns (enum mips_symbol_type type)\n \n \t The final address is then $at + %lo(symbol).  With 32-bit\n \t symbols we just need a preparatory lui.  */\n-      return (ABI_HAS_64BIT_SYMBOLS ? 6 : 2);\n+      return ABI_HAS_64BIT_SYMBOLS ? 6 : 2;\n \n     case SYMBOL_GP_RELATIVE:\n-    case SYMBOL_HALF:\n+      /* Treat GP-relative accesses as taking a single instruction on\n+\t MIPS16 too; the copy of $gp can often be shared.  */\n       return 1;\n \n     case SYMBOL_PC_RELATIVE:\n-      /* This case is for mips16 only.  Assume we'll need an\n-\t extended instruction.  */\n-      return 2;\n+      /* PC-relative constants can be only be used with addiupc,\n+\t lwpc and ldpc.  */\n+      if (mode == MAX_MACHINE_MODE\n+\t  || GET_MODE_SIZE (mode) == 4\n+\t  || GET_MODE_SIZE (mode) == 8)\n+\treturn 1;\n+\n+      /* The constant must be loaded using addiupc first.  */\n+      return 0;\n \n     case SYMBOL_FORCE_TO_MEM:\n       /* The constant must be loaded from the constant pool.  */\n       return 0;\n \n-    case SYMBOL_GOT_PAGE_OFST:\n     case SYMBOL_GOT_DISP:\n+      /* The constant will have to be loaded from the GOT before it\n+\t is used in an address.  */\n+      if (mode != MAX_MACHINE_MODE)\n+\treturn 0;\n+\n+      /* Fall through.  */\n+\n+    case SYMBOL_GOT_PAGE_OFST:\n       /* Unless -funit-at-a-time is in effect, we can't be sure whether\n \t the local/global classification is accurate.  See override_options\n \t for details.\n@@ -1904,7 +1871,10 @@ mips_symbol_insns (enum mips_symbol_type type)\n     case SYMBOL_DTPREL:\n     case SYMBOL_GOTTPREL:\n     case SYMBOL_TPREL:\n-      /* Check whether the offset is a 16- or 32-bit value.  */\n+    case SYMBOL_HALF:\n+      /* A 16-bit constant formed by a single relocation, or a 32-bit\n+\t constant formed from a high 16-bit relocation and a low 16-bit\n+\t relocation.  Use mips_split_p to determine which.  */\n       return mips_split_p[type] ? 2 : 1;\n \n     case SYMBOL_TLS:\n@@ -1914,6 +1884,22 @@ mips_symbol_insns (enum mips_symbol_type type)\n   gcc_unreachable ();\n }\n \n+/* If MODE is MAX_MACHINE_MODE, return the number of instructions needed\n+   to load symbols of type TYPE into a register.  Return 0 if the given\n+   type of symbol cannot be used as an immediate operand.\n+\n+   Otherwise, return the number of instructions needed to load or store\n+   values of mode MODE to or from addresses of type TYPE.  Return 0 if\n+   the given type of symbol is not valid in addresses.\n+\n+   In both cases, treat extended MIPS16 instructions as two instructions.  */\n+\n+static int\n+mips_symbol_insns (enum mips_symbol_type type, enum machine_mode mode)\n+{\n+  return mips_symbol_insns_1 (type, mode) * (TARGET_MIPS16 ? 2 : 1);\n+}\n+\n /* Return true if X is a legitimate $sp-based address for mode MDOE.  */\n \n bool\n@@ -1985,7 +1971,7 @@ mips_address_insns (rtx x, enum machine_mode mode)\n \treturn factor;\n \n       case ADDRESS_SYMBOLIC:\n-\treturn factor * mips_symbol_insns (addr.symbol_type);\n+\treturn factor * mips_symbol_insns (addr.symbol_type, mode);\n       }\n   return 0;\n }\n@@ -2035,7 +2021,7 @@ mips_const_insns (rtx x)\n \n       /* See if we can refer to X directly.  */\n       if (mips_symbolic_constant_p (x, SYMBOL_CONTEXT_LEA, &symbol_type))\n-\treturn mips_symbol_insns (symbol_type);\n+\treturn mips_symbol_insns (symbol_type, MAX_MACHINE_MODE);\n \n       /* Otherwise try splitting the constant into a base and offset.\n \t 16-bit offsets can be added using an extra addiu.  Larger offsets\n@@ -2056,7 +2042,8 @@ mips_const_insns (rtx x)\n \n     case SYMBOL_REF:\n     case LABEL_REF:\n-      return mips_symbol_insns (mips_classify_symbol (x, SYMBOL_CONTEXT_LEA));\n+      return mips_symbol_insns (mips_classify_symbol (x, SYMBOL_CONTEXT_LEA),\n+\t\t\t\tMAX_MACHINE_MODE);\n \n     default:\n       return 0;\n@@ -2344,7 +2331,7 @@ mips_legitimize_address (rtx *xloc, enum machine_mode mode)\n \n   /* See if the address can split into a high part and a LO_SUM.  */\n   if (mips_symbolic_constant_p (*xloc, SYMBOL_CONTEXT_MEM, &symbol_type)\n-      && mips_symbolic_address_p (symbol_type, mode)\n+      && mips_symbol_insns (symbol_type, mode) > 0\n       && mips_split_p[symbol_type])\n     {\n       *xloc = mips_split_symbol (0, *xloc);"}]}