{"sha": "eeef0e452e98fe6424ce65fb25fba15c59151848", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVlZjBlNDUyZTk4ZmU2NDI0Y2U2NWZiMjVmYmExNWM1OTE1MTg0OA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2007-01-28T05:15:06Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2007-01-28T05:15:06Z"}, "message": "common.opt: Add fstrict-overflow.\n\n./:\t* common.opt: Add fstrict-overflow.\n\t* opts.c (decode_options): Set flag_strict_overflow if -O2.\n\t* flags.h (TYPE_OVERFLOW_WRAPS): Define.\n\t(TYPE_OVERFLOW_UNDEFINED): Define.\n\t(TYPE_OVERFLOW_TRAPS): Define.  This replaces TYPE_TRAP_SIGNED.\n\tReplace all uses.\n\t* tree.h (TYPE_TRAP_SIGNED): Don't define.\n\t* fold-const.c (negate_expr_p): Use TYPE_OVERFLOW_UNDEFINED.\n\t(fold_negate_expr): Likewise.\n\t(make_range): Likewise.\n\t(extract_muldiv_1): Likewise.\n\t(maybe_canonicalize_comparison): Likewise.\n\t(fold_comparison): Likewise.\n\t(fold_binary): Likewise.\n\t(tree_expr_nonnegative_p): Likewise.\n\t(tree_expr_nonzero_p): Likewise.\n\t* tree-vrp.c (compare_values): Likewise.\n\t(extract_range_from_binary_expr): Likewise.\n\t(extract_range_from_unary_expr): Likewise.\n\t* tree-ssa-loop-niter.c (infer_loop_bounds_from_signedness):\n\tLikewise.\n\t(nowrap_type_p): Likewise.\n\t* tree-scalar-evolution.c (simple_iv): Likewise.\n\t* fold-const.c (negate_expr_p): Use TYPE_OVERFLOW_WRAPS.\n\t(build_range_check): Likewise.\n\t(extract_muldiv_1): Likewise.\n\t(fold_comparison): Likewise.\n\t* tree-vrp.c (vrp_int_const_binop): Likewise.\n\t(extract_range_from_unary_expr): Likewise.\n\t* convert.c (convert_to_integer): Likewise.\n\t* fold-const.c (fold_negate_expr): Use TYPE_OVERFLOW_TRAPS.\n\t(fold_comparison): Likewise.\n\t(fold_binary): Likewise.\n\t* optabs.c (optab_for_tree_code): Likewise.\n\t* tree-vectorizer.c (vect_is_simple_reduction): Likewise.\n\t* simplify-rtx.c (simplify_const_relational_operation): Check\n\tflag_strict_overflow and flag_trapv.\n\t(simplify_const_relational_operation): Likewise.\n\t* doc/invoke.texi (Option Summary): Mention -fstrict-overflow.\n\t(Optimize Options): Add -fstrict-overflow to -O2 list.  Document\n\t-fstrict-overflow.\ntestsuite/:\n\t* gcc.dg/strict-overflow-1.c: New test.\n\t* gcc.dg/no-strict-overflow-1.c: New test.\n\t* gcc.dg/strict-overflow-2.c: New test.\n\t* gcc.dg/no-strict-overflow-2.c: New test.\n\t* gcc.dg/strict-overflow-3.c: New test.\n\t* gcc.dg/no-strict-overflow-3.c: New test.\n\t* gcc.dg/strict-overflow-4.c: New test.\n\t* gcc.dg/no-strict-overflow-4.c: New test.\n\t* gcc.dg/fold-mod-1.c: Add -fstrict-overflow option.\n\t* gcc.dg/pr15784-1.c: Likewise.\n\t* gcc.dg/pr20922-1.c: Likewise.\n\t* gcc.dg/pr20922-3.c: Likewise.\n\t* gcc.dg/pr20922-4.c: Likewise.\n\t* gcc.dg/pr20922-6.c: Likewise.\n\t* gcc.dg/compare-4.c: Likewise.\n\t* gcc.dg/torture/pr26898-1.c: Likewise.\n\t* gcc.dg/tree-ssa/divide-1.c: Likewise.\n\t* gcc.dg/tree-ssa/divide-2.c: Likewise.\n\t* gcc.dg/tree-ssa/divide-3.c: Likewise.\n\t* gcc.dg/tree-ssa/divide-4.c: Likewise.\n\t* gcc.dg/tree-ssa/pr14490-1.c: Likewise.\n\t* gcc.dg/tree-ssa/pr14490-3.c: Likewise.\n\t* gcc.dg/tree-ssa/pr21082.c: Likewise.\n\t* gcc.dg/tree-ssa/pr26899.c: Likewise.\n\t* g++.dg/tree-ssa/pr21082.C: Likewise.\n\nFrom-SVN: r121254", "tree": {"sha": "0e2fc9b10a02a481f17a188d9e01389ef7691fb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e2fc9b10a02a481f17a188d9e01389ef7691fb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eeef0e452e98fe6424ce65fb25fba15c59151848", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeef0e452e98fe6424ce65fb25fba15c59151848", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eeef0e452e98fe6424ce65fb25fba15c59151848", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeef0e452e98fe6424ce65fb25fba15c59151848/comments", "author": null, "committer": null, "parents": [{"sha": "b73a6056563470e5b99e79a0dc769c351e906e6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b73a6056563470e5b99e79a0dc769c351e906e6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b73a6056563470e5b99e79a0dc769c351e906e6e"}], "stats": {"total": 454, "additions": 355, "deletions": 99}, "files": [{"sha": "a2129d3e34b2a1056dca91917a2b97ae4c405d7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,3 +1,47 @@\n+2007-01-27  Ian Lance Taylor  <iant@google.com>\n+\n+\t* common.opt: Add fstrict-overflow.\n+\t* opts.c (decode_options): Set flag_strict_overflow if -O2.\n+\t* flags.h (TYPE_OVERFLOW_WRAPS): Define.\n+\t(TYPE_OVERFLOW_UNDEFINED): Define.\n+\t(TYPE_OVERFLOW_TRAPS): Define.  This replaces TYPE_TRAP_SIGNED.\n+\tReplace all uses.\n+\t* tree.h (TYPE_TRAP_SIGNED): Don't define.\n+\t* fold-const.c (negate_expr_p): Use TYPE_OVERFLOW_UNDEFINED.\n+\t(fold_negate_expr): Likewise.\n+\t(make_range): Likewise.\n+\t(extract_muldiv_1): Likewise.\n+\t(maybe_canonicalize_comparison): Likewise.\n+\t(fold_comparison): Likewise.\n+\t(fold_binary): Likewise.\n+\t(tree_expr_nonnegative_p): Likewise.\n+\t(tree_expr_nonzero_p): Likewise.\n+\t* tree-vrp.c (compare_values): Likewise.\n+\t(extract_range_from_binary_expr): Likewise.\n+\t(extract_range_from_unary_expr): Likewise.\n+\t* tree-ssa-loop-niter.c (infer_loop_bounds_from_signedness):\n+\tLikewise.\n+\t(nowrap_type_p): Likewise.\n+\t* tree-scalar-evolution.c (simple_iv): Likewise.\n+\t* fold-const.c (negate_expr_p): Use TYPE_OVERFLOW_WRAPS.\n+\t(build_range_check): Likewise.\n+\t(extract_muldiv_1): Likewise.\n+\t(fold_comparison): Likewise.\n+\t* tree-vrp.c (vrp_int_const_binop): Likewise.\n+\t(extract_range_from_unary_expr): Likewise.\n+\t* convert.c (convert_to_integer): Likewise.\n+\t* fold-const.c (fold_negate_expr): Use TYPE_OVERFLOW_TRAPS.\n+\t(fold_comparison): Likewise.\n+\t(fold_binary): Likewise.\n+\t* optabs.c (optab_for_tree_code): Likewise.\n+\t* tree-vectorizer.c (vect_is_simple_reduction): Likewise.\n+\t* simplify-rtx.c (simplify_const_relational_operation): Check\n+\tflag_strict_overflow and flag_trapv.\n+\t(simplify_const_relational_operation): Likewise.\n+\t* doc/invoke.texi (Option Summary): Mention -fstrict-overflow.\n+\t(Optimize Options): Add -fstrict-overflow to -O2 list.  Document\n+\t-fstrict-overflow.\n+\n 2007-01-27  Roger Sayle  <roger@eyesopen.com>\n \n \t* tree.c (tree_fold_gcd): Delete."}, {"sha": "0f6f7ec16c50dfbda01bb0a5828e54752b69d723", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -902,6 +902,10 @@ fstrict-aliasing\n Common Report Var(flag_strict_aliasing)\n Assume strict aliasing rules apply\n \n+fstrict-overflow\n+Common Report Var(flag_strict_overflow)\n+Treat signed overflow as undefined\n+\n fsyntax-only\n Common Report Var(flag_syntax_only)\n Check for syntax errors, then stop"}, {"sha": "af97d2a75901279dc3fe5b5625bbb0f4c4b4d420", "filename": "gcc/convert.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -661,11 +661,10 @@ convert_to_integer (tree type, tree expr)\n \t\t\t   PLUS_EXPR or MINUS_EXPR in an unsigned\n \t\t\t   type.  Otherwise, we would introduce\n \t\t\t   signed-overflow undefinedness.  */\n-\t\t\t|| (!flag_wrapv\n+\t\t\t|| ((!TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg0))\n+\t\t\t     || !TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg1)))\n \t\t\t    && (ex_form == PLUS_EXPR\n-\t\t\t\t|| ex_form == MINUS_EXPR)\n-\t\t\t    && (!TYPE_UNSIGNED (TREE_TYPE (arg0))\n-\t\t\t\t|| !TYPE_UNSIGNED (TREE_TYPE (arg1)))))\n+\t\t\t\t|| ex_form == MINUS_EXPR)))\n \t\t      typex = lang_hooks.types.unsigned_type (typex);\n \t\t    else\n \t\t      typex = lang_hooks.types.signed_type (typex);"}, {"sha": "eb55c9b321a5ae7ac71f91269a178c0bdf74cdb0", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -341,7 +341,7 @@ Objective-C and Objective-C++ Dialects}.\n -fsched2-use-traces -fsee -freschedule-modulo-scheduled-loops @gol\n -fsection-anchors  -fsignaling-nans  -fsingle-precision-constant @gol\n -fstack-protector  -fstack-protector-all @gol\n--fstrict-aliasing  -ftracer  -fthread-jumps @gol\n+-fstrict-aliasing  -fstrict-overflow  -ftracer  -fthread-jumps @gol\n -funroll-all-loops  -funroll-loops  -fpeel-loops @gol\n -fsplit-ivs-in-unroller -funswitch-loops @gol\n -fvariable-expansion-in-unroller @gol\n@@ -4635,7 +4635,7 @@ also turns on the following optimization flags:\n -fschedule-insns  -fschedule-insns2 @gol\n -fsched-interblock  -fsched-spec @gol\n -fregmove @gol\n--fstrict-aliasing @gol\n+-fstrict-aliasing -fstrict-overflow @gol\n -fdelete-null-pointer-checks @gol\n -freorder-blocks  -freorder-functions @gol\n -falign-functions  -falign-jumps @gol\n@@ -5465,6 +5465,32 @@ int f() @{\n \n Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.\n \n+@item -fstrict-overflow\n+@opindex fstrict-overflow\n+Allow the compiler to assume strict signed overflow rules, depending\n+on the language being compiled.  For C (and C++) this means that\n+overflow when doing arithmetic with signed numbers is undefined, which\n+means that the compiler may assume that it will not happen.  This\n+permits various optimizations.  For example, the compiler will assume\n+that an expression like @code{i + 10 > i} will always be true for\n+signed @code{i}.  This assumption is only valid if signed overflow is\n+undefined, as the expression is false if @code{i + 10} overflows when\n+using twos complement arithmetic.  When this option is in effect any\n+attempt to determine whether an operation on signed numbers will\n+overflow must be written carefully to not actually involve overflow.\n+\n+See also the @option{-fwrapv} option.  Using @option{-fwrapv} means\n+that signed overflow is fully defined: it wraps.  When\n+@option{-fwrapv} is used, there is no difference between\n+@option{-fstrict-overflow} and @option{-fno-strict-overflow}.  With\n+@option{-fwrapv} certain types of overflow are permitted.  For\n+example, if the compiler gets an overflow when doing arithmetic on\n+constants, the overflowed value can still be used with\n+@option{-fwrapv}, but not otherwise.\n+\n+The @option{-fstrict-overflow} option is enabled at levels\n+@option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -falign-functions\n @itemx -falign-functions=@var{n}\n @opindex falign-functions"}, {"sha": "d2c1ca02cf083d3157c87275aded68545da0b847", "filename": "gcc/flags.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,6 +1,6 @@\n /* Compilation switch flag definitions for GCC.\n    Copyright (C) 1987, 1988, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002,\n-   2003, 2004, 2005\n+   2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -288,4 +288,20 @@ extern const char *flag_random_seed;\n #define HONOR_SIGN_DEPENDENT_ROUNDING(MODE) \\\n   (MODE_HAS_SIGN_DEPENDENT_ROUNDING (MODE) && flag_rounding_math)\n \n+/* True if overflow wraps around for the given integral type.  That\n+   is, TYPE_MAX + 1 == TYPE_MIN.  */\n+#define TYPE_OVERFLOW_WRAPS(TYPE) \\\n+  (TYPE_UNSIGNED (TYPE) || flag_wrapv)\n+\n+/* True if overflow is undefined for the given integral type.  We may\n+   optimize on the assumption that values in the type never\n+   overflow.  */\n+#define TYPE_OVERFLOW_UNDEFINED(TYPE) \\\n+  (!TYPE_UNSIGNED (TYPE) && !flag_wrapv && !flag_trapv && flag_strict_overflow)\n+\n+/* True if overflow for the given integral type should issue a\n+   trap.  */\n+#define TYPE_OVERFLOW_TRAPS(TYPE) \\\n+  (!TYPE_UNSIGNED (TYPE) && flag_trapv)\n+\n #endif /* ! GCC_FLAGS_H */"}, {"sha": "a7a12eb1d92a8f6ca545bf166573895436d81a9b", "filename": "gcc/fold-const.c", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -994,16 +994,14 @@ negate_expr_p (tree t)\n   switch (TREE_CODE (t))\n     {\n     case INTEGER_CST:\n-      if (TYPE_UNSIGNED (type)\n-\t  || (flag_wrapv && ! flag_trapv))\n+      if (TYPE_OVERFLOW_WRAPS (type))\n \treturn true;\n \n       /* Check that -CST will not overflow type.  */\n       return may_negate_without_overflow_p (t);\n     case BIT_NOT_EXPR:\n-       return INTEGRAL_TYPE_P (type)\n-       \t      && (TYPE_UNSIGNED (type)\n-\t      \t  || (flag_wrapv && !flag_trapv));\n+      return (INTEGRAL_TYPE_P (type)\n+\t      && TYPE_OVERFLOW_WRAPS (type));\n \n     case REAL_CST:\n     case NEGATE_EXPR:\n@@ -1049,7 +1047,8 @@ negate_expr_p (tree t)\n     case FLOOR_DIV_EXPR:\n     case CEIL_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n-      if (TYPE_UNSIGNED (TREE_TYPE (t)) || flag_wrapv)\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t  && !TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (t)))\n         break;\n       return negate_expr_p (TREE_OPERAND (t, 1))\n              || negate_expr_p (TREE_OPERAND (t, 0));\n@@ -1111,8 +1110,7 @@ fold_negate_expr (tree t)\n     case INTEGER_CST:\n       tem = fold_negate_const (t, type);\n       if (!TREE_OVERFLOW (tem)\n-\t  || TYPE_UNSIGNED (type)\n-\t  || !flag_trapv)\n+\t  || !TYPE_OVERFLOW_TRAPS (type))\n \treturn tem;\n       break;\n \n@@ -1197,7 +1195,7 @@ fold_negate_expr (tree t)\n     case FLOOR_DIV_EXPR:\n     case CEIL_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n-      if (!TYPE_UNSIGNED (type) && !flag_wrapv)\n+      if (!INTEGRAL_TYPE_P (type) || TYPE_OVERFLOW_UNDEFINED (type))\n         {\n           tem = TREE_OPERAND (t, 1);\n           if (negate_expr_p (tem))\n@@ -3981,7 +3979,8 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \n \t  /* If flag_wrapv and ARG0_TYPE is signed, then we cannot\n \t     move a constant to the other side.  */\n-\t  if (flag_wrapv && !TYPE_UNSIGNED (arg0_type))\n+\t  if (!TYPE_UNSIGNED (arg0_type)\n+\t      && !TYPE_OVERFLOW_UNDEFINED (arg0_type))\n \t    break;\n \n \t  /* If EXP is signed, any overflow in the computation is undefined,\n@@ -4231,7 +4230,7 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n \n   /* If we don't have wrap-around arithmetics upfront, try to force it.  */\n   if (TREE_CODE (etype) == INTEGER_TYPE\n-      && !TYPE_UNSIGNED (etype) && !flag_wrapv)\n+      && !TYPE_OVERFLOW_WRAPS (etype))\n     {\n       tree utype, minv, maxv;\n \n@@ -5630,7 +5629,7 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t\t\t     fold_convert (ctype, c), 0);\n \t  /* We allow the constant to overflow with wrapping semantics.  */\n \t  if (op1 == 0\n-\t      || (TREE_OVERFLOW (op1) && ! flag_wrapv))\n+\t      || (TREE_OVERFLOW (op1) && !TYPE_OVERFLOW_WRAPS (ctype)))\n \t    break;\n \t}\n       else\n@@ -5704,9 +5703,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t If we have an unsigned type that is not a sizetype, we cannot do\n \t this since it will change the result if the original computation\n \t overflowed.  */\n-      if ((! TYPE_UNSIGNED (ctype)\n+      if ((TYPE_OVERFLOW_UNDEFINED (ctype)\n \t   || (TREE_CODE (ctype) == INTEGER_TYPE && TYPE_IS_SIZETYPE (ctype)))\n-\t  && ! flag_wrapv\n \t  && ((code == MULT_EXPR && tcode == EXACT_DIV_EXPR)\n \t      || (tcode == MULT_EXPR\n \t\t  && code != TRUNC_MOD_EXPR && code != CEIL_MOD_EXPR\n@@ -7929,9 +7927,8 @@ maybe_canonicalize_comparison (enum tree_code code, tree type,\n \n   /* In principle pointers also have undefined overflow behavior,\n      but that causes problems elsewhere.  */\n-  if ((flag_wrapv || flag_trapv)\n-      || (TYPE_UNSIGNED (TREE_TYPE (arg0))\n-\t  || POINTER_TYPE_P (TREE_TYPE (arg0))))\n+  if (!TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg0))\n+      || POINTER_TYPE_P (TREE_TYPE (arg0)))\n     return NULL_TREE;\n \n   /* Try canonicalization by simplifying arg0.  */\n@@ -7976,8 +7973,7 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n   if ((TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n       && (TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n \t  && !TREE_OVERFLOW (TREE_OPERAND (arg0, 1))\n-\t  && !TYPE_UNSIGNED (TREE_TYPE (arg1))\n-\t  && !(flag_wrapv || flag_trapv))\n+\t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))\n       && (TREE_CODE (arg1) == INTEGER_CST\n \t  && !TREE_OVERFLOW (arg1)))\n     {\n@@ -8104,9 +8100,15 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n      same object, then we can fold this to a comparison of the two offsets in\n      signed size type.  This is possible because pointer arithmetic is\n      restricted to retain within an object and overflow on pointer differences\n-     is undefined as of 6.5.6/8 and /9 with respect to the signed ptrdiff_t.  */\n+     is undefined as of 6.5.6/8 and /9 with respect to the signed ptrdiff_t.\n+\n+     We check flag_wrapv directly because pointers types are unsigned,\n+     and therefore TYPE_OVERFLOW_WRAPS returns true for them.  That is\n+     normally what we want to avoid certain odd overflow cases, but\n+     not here.  */\n   if (POINTER_TYPE_P (TREE_TYPE (arg0))\n-      && !flag_wrapv && !flag_trapv)\n+      && !flag_wrapv\n+      && !TYPE_OVERFLOW_TRAPS (TREE_TYPE (arg0)))\n     {\n       tree base0, offset0, base1, offset1;\n \n@@ -8139,8 +8141,7 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n      X CMP Y +- C2 +- C1 for signed X, Y.  This is valid if\n      the resulting offset is smaller in absolute value than the\n      original one.  */\n-  if (!(flag_wrapv || flag_trapv)\n-      && !TYPE_UNSIGNED (TREE_TYPE (arg0))\n+  if (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg0))\n       && (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)\n       && (TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n \t  && !TREE_OVERFLOW (TREE_OPERAND (arg0, 1)))\n@@ -8181,8 +8182,7 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n      signed arithmetic case.  That form is created by the compiler\n      often enough for folding it to be of value.  One example is in\n      computing loop trip counts after Operator Strength Reduction.  */\n-  if (!(flag_wrapv || flag_trapv)\n-      && !TYPE_UNSIGNED (TREE_TYPE (arg0))\n+  if (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg0))\n       && TREE_CODE (arg0) == MULT_EXPR\n       && (TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n           && !TREE_OVERFLOW (TREE_OPERAND (arg0, 1)))\n@@ -8802,7 +8802,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  /* ~X + X is -1.  */\n \t  if (TREE_CODE (arg0) == BIT_NOT_EXPR\n \t      && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0)\n-\t      && !TYPE_TRAP_SIGNED (type))\n+\t      && !TYPE_OVERFLOW_TRAPS (type))\n \t    {\n \t      t1 = build_int_cst_type (type, -1);\n \t      return omit_one_operand (type, t1, arg1);\n@@ -8811,7 +8811,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  /* X + ~X is -1.  */\n \t  if (TREE_CODE (arg1) == BIT_NOT_EXPR\n \t      && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0)\n-\t      && !TYPE_TRAP_SIGNED (type))\n+\t      && !TYPE_OVERFLOW_TRAPS (type))\n \t    {\n \t      t1 = build_int_cst_type (type, -1);\n \t      return omit_one_operand (type, t1, arg0);\n@@ -9158,7 +9158,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n       if (INTEGRAL_TYPE_P (type)\n \t  && TREE_CODE (arg0) == NEGATE_EXPR\n \t  && integer_onep (arg1)\n-\t  && !TYPE_TRAP_SIGNED (type))\n+\t  && !TYPE_OVERFLOW_TRAPS (type))\n \treturn fold_build1 (BIT_NOT_EXPR, type,\n \t\t\t    fold_convert (type, TREE_OPERAND (arg0, 0)));\n \n@@ -10277,12 +10277,12 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n       /* Convert -A / -B to A / B when the type is signed and overflow is\n \t undefined.  */\n-      if (!TYPE_UNSIGNED (type) && !flag_wrapv\n+      if ((!INTEGRAL_TYPE_P (type) || TYPE_OVERFLOW_UNDEFINED (type))\n \t  && TREE_CODE (arg0) == NEGATE_EXPR\n \t  && negate_expr_p (arg1))\n \treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0),\n \t\t\t    negate_expr (arg1));\n-      if (!TYPE_UNSIGNED (type) && !flag_wrapv\n+      if ((!INTEGRAL_TYPE_P (type) || TYPE_OVERFLOW_UNDEFINED (type))\n \t  && TREE_CODE (arg1) == NEGATE_EXPR\n \t  && negate_expr_p (arg0))\n \treturn fold_build2 (code, type, negate_expr (arg0),\n@@ -10357,7 +10357,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && TREE_CODE (arg1) == INTEGER_CST\n \t  && !TREE_OVERFLOW (arg1)\n \t  && TREE_INT_CST_HIGH (arg1) < 0\n-\t  && !flag_trapv\n+\t  && !TYPE_OVERFLOW_TRAPS (type)\n \t  /* Avoid this transformation if C is INT_MIN, i.e. C == -C.  */\n \t  && !sign_bit_p (arg1, arg1))\n \treturn fold_build2 (code, type, fold_convert (type, arg0),\n@@ -10367,7 +10367,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n       if (code == TRUNC_MOD_EXPR\n \t  && !TYPE_UNSIGNED (type)\n \t  && TREE_CODE (arg1) == NEGATE_EXPR\n-\t  && !flag_trapv)\n+\t  && !TYPE_OVERFLOW_TRAPS (type))\n \treturn fold_build2 (code, type, fold_convert (type, arg0),\n \t\t\t    fold_convert (type, TREE_OPERAND (arg1, 0)));\n \n@@ -11187,8 +11187,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && ((TREE_CODE (TREE_OPERAND (arg0, 1)) == REAL_CST\n \t       && !HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0))))\n \t      || (TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-\t          && !TYPE_UNSIGNED (TREE_TYPE (arg1))\n-\t\t  && !(flag_wrapv || flag_trapv))))\n+\t\t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))))\n \t{\n \t  tree arg01 = TREE_OPERAND (arg0, 1);\n \t  enum tree_code code0 = TREE_CODE (arg0);\n@@ -12556,8 +12555,10 @@ tree_expr_nonnegative_p (tree t)\n     case ABS_EXPR:\n       /* We can't return 1 if flag_wrapv is set because\n \t ABS_EXPR<INT_MIN> = INT_MIN.  */\n-      if (!(flag_wrapv && INTEGRAL_TYPE_P (TREE_TYPE (t))))\n-        return true;\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\treturn true;\n+      if (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (t)))\n+\treturn true;\n       break;\n \n     case INTEGER_CST:\n@@ -12863,7 +12864,7 @@ tree_expr_nonzero_p (tree t)\n       return !integer_zerop (t);\n \n     case PLUS_EXPR:\n-      if (!TYPE_UNSIGNED (type) && !flag_wrapv)\n+      if (TYPE_OVERFLOW_UNDEFINED (type))\n \t{\n \t  /* With the presence of negative values it is hard\n \t     to say something.  */\n@@ -12877,7 +12878,7 @@ tree_expr_nonzero_p (tree t)\n       break;\n \n     case MULT_EXPR:\n-      if (!TYPE_UNSIGNED (type) && !flag_wrapv)\n+      if (TYPE_OVERFLOW_UNDEFINED (type))\n \t{\n \t  return (tree_expr_nonzero_p (TREE_OPERAND (t, 0))\n \t          && tree_expr_nonzero_p (TREE_OPERAND (t, 1)));"}, {"sha": "c7f16c29e5991d3c33da54e38ddd3403d2ca090d", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,6 +1,7 @@\n /* Expand the basic unary and binary arithmetic operations, for GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -341,7 +342,7 @@ optab_for_tree_code (enum tree_code code, tree type)\n       break;\n     }\n \n-  trapv = flag_trapv && INTEGRAL_TYPE_P (type) && !TYPE_UNSIGNED (type);\n+  trapv = INTEGRAL_TYPE_P (type) && TYPE_OVERFLOW_TRAPS (type);\n   switch (code)\n     {\n     case PLUS_EXPR:"}, {"sha": "b75fcb39d50aead98174269551200078220efbce", "filename": "gcc/opts.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,5 +1,6 @@\n /* Command line option handling.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Neil Booth.\n \n This file is part of GCC.\n@@ -487,6 +488,7 @@ decode_options (unsigned int argc, const char **argv)\n #endif\n       flag_regmove = 1;\n       flag_strict_aliasing = 1;\n+      flag_strict_overflow = 1;\n       flag_delete_null_pointer_checks = 1;\n       flag_reorder_blocks = 1;\n       flag_reorder_functions = 1;"}, {"sha": "0ce80c7f6c2f1ff96543cda265f2b98125ad1567", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,6 +1,7 @@\n /* RTL simplification functions for GNU compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -3939,7 +3940,8 @@ simplify_const_relational_operation (enum rtx_code code,\n \t  /* Optimize abs(x) < 0.0.  */\n \t  if (trueop1 == CONST0_RTX (mode)\n \t      && !HONOR_SNANS (mode)\n-\t      && !(flag_wrapv && INTEGRAL_MODE_P (mode)))\n+\t      && (!INTEGRAL_MODE_P (mode)\n+\t\t  || (!flag_wrapv && !flag_trapv && flag_strict_overflow)))\n \t    {\n \t      tem = GET_CODE (trueop0) == FLOAT_EXTEND ? XEXP (trueop0, 0)\n \t\t\t\t\t\t       : trueop0;\n@@ -3952,7 +3954,8 @@ simplify_const_relational_operation (enum rtx_code code,\n \t  /* Optimize abs(x) >= 0.0.  */\n \t  if (trueop1 == CONST0_RTX (mode)\n \t      && !HONOR_NANS (mode)\n-\t      && !(flag_wrapv && INTEGRAL_MODE_P (mode)))\n+\t      && (!INTEGRAL_MODE_P (mode)\n+\t\t  || (!flag_wrapv && !flag_trapv && flag_strict_overflow)))\n \t    {\n \t      tem = GET_CODE (trueop0) == FLOAT_EXTEND ? XEXP (trueop0, 0)\n \t\t\t\t\t\t       : trueop0;"}, {"sha": "7278fb7fa40da2f66b02fc478a00ed87b81dbf5e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,3 +1,31 @@\n+2007-01-27  Ian Lance Taylor  <iant@google.com>\n+\n+\t* gcc.dg/strict-overflow-1.c: New test.\n+\t* gcc.dg/no-strict-overflow-1.c: New test.\n+\t* gcc.dg/strict-overflow-2.c: New test.\n+\t* gcc.dg/no-strict-overflow-2.c: New test.\n+\t* gcc.dg/strict-overflow-3.c: New test.\n+\t* gcc.dg/no-strict-overflow-3.c: New test.\n+\t* gcc.dg/strict-overflow-4.c: New test.\n+\t* gcc.dg/no-strict-overflow-4.c: New test.\n+\t* gcc.dg/fold-mod-1.c: Add -fstrict-overflow option.\n+\t* gcc.dg/pr15784-1.c: Likewise.\n+\t* gcc.dg/pr20922-1.c: Likewise.\n+\t* gcc.dg/pr20922-3.c: Likewise.\n+\t* gcc.dg/pr20922-4.c: Likewise.\n+\t* gcc.dg/pr20922-6.c: Likewise.\n+\t* gcc.dg/compare-4.c: Likewise.\n+\t* gcc.dg/torture/pr26898-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/divide-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/divide-2.c: Likewise.\n+\t* gcc.dg/tree-ssa/divide-3.c: Likewise.\n+\t* gcc.dg/tree-ssa/divide-4.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr14490-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr14490-3.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr21082.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr26899.c: Likewise.\n+\t* g++.dg/tree-ssa/pr21082.C: Likewise.\n+\n 2007-01-27  Roger Sayle  <roger@eyesopen.com>\n \n \t* gcc-dg/large-size-array-3.c: New test case."}, {"sha": "7c4261686abaf41b12e45b38d0ff1e58398f0fc8", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr21082.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr21082.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr21082.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr21082.C?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,4 +1,5 @@\n /* { dg-do link } */\n+/* { dg-options \"-fstrict-overflow\" } */\n \n void link_error();\n "}, {"sha": "aae7cbee32d888767164acb9388117e8692cd892", "filename": "gcc/testsuite/gcc.dg/compare4.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fcompare4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fcompare4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompare4.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -2,7 +2,7 @@\n    Origin: Kaveh R. Ghazi <ghazi@caip.rutgers.edu> 5/13/2001.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-Wsign-compare\" } */\n+/* { dg-options \"-Wsign-compare -fstrict-overflow\" } */\n \n extern void bar(void);\n \n@@ -21,7 +21,8 @@ int foo(int x, int y, unsigned u)\n   if ((x ? 10 : (bar(),bar(),bar(),bar(),x==y)) < u)\n     return x;\n \n-  /* Test an ABS_EXPR, which is by definition non-negative.  */\n+  /* Test an ABS_EXPR, which is by definition non-negative when\n+     -fstrict-overflow is used.  */\n   if (u < __builtin_abs(x))\n     return x;\n   if (__builtin_abs(x) < u)"}, {"sha": "bd4322e2a80fdc124b5547e84ef58a4e85e50ff9", "filename": "gcc/testsuite/gcc.dg/fold-mod-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-mod-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-mod-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-mod-1.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target int32plus } */\n-/* { dg-options \"-fdump-tree-gimple\" } */\n+/* { dg-options \"-fdump-tree-gimple -fstrict-overflow\" } */\n \n #define ABS(x) (x > 0 ? x : -x)\n "}, {"sha": "6d449cac15ebd76ea43af203f923d42ae54a40b2", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-1.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+\n+/* Source: Ian Lance Taylor.  Dual of strict-overflow-1.c.  */\n+\n+/* We can only simplify the conditional when using strict overflow\n+   semantics.  */\n+\n+int\n+foo (int i)\n+{\n+  return i - 5 < 10;\n+}\n+\n+/* { dg-final { scan-tree-dump \"-[ ]*5\" \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}, {"sha": "cfe4bc16febd7bef9bbb1136473691bc0e53c4bc", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-2.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+\n+/* Source: Ian Lance Taylor.  Dual of strict-overflow-2.c.  */\n+\n+/* We can only simplify the division when using strict overflow\n+   semantics.  */\n+\n+int\n+foo (int i)\n+{\n+  return (i * 100) / 10;\n+}\n+\n+/* { dg-final { scan-tree-dump \"100\" \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}, {"sha": "a98117981d57a875edc6e79d22374018e8dba348", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-3.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+\n+/* Source: Ian Lance Taylor.  Dual of strict-overflow-3.c.  */\n+\n+/* We can only simplify the conditional when using strict overflow\n+   semantics.  */\n+\n+int\n+foo (int i, int j)\n+{\n+  return i + 100 < j + 1000;\n+}\n+\n+/* { dg-final { scan-tree-dump \"1000\" \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}, {"sha": "da6264a7289fb6557ded0c88742181185a163fee", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-4.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-4.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+\n+/* Source: Ian Lance Taylor.  Dual of strict-overflow-4.c.  */\n+\n+/* We can only simplify the conditional when using strict overflow\n+   semantics.  */\n+\n+int\n+foo (int i)\n+{\n+  return i + 1 > i;\n+}\n+\n+/* We expect to see \"<bb N>\"; confirm that, so that we know to count\n+   it in the real test.  */\n+/* { dg-final { scan-tree-dump-times \"<bb\\[^>\\]*>\" 1 \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \">|<\" 3 \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}, {"sha": "77e398e1da8687779992301fced5f890bdad4649", "filename": "gcc/testsuite/gcc.dg/pr15784-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fpr15784-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fpr15784-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr15784-1.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fdump-tree-gimple\" } */\n+/* { dg-options \"-fstrict-overflow -fdump-tree-gimple\" } */\n /* Test for folding abs(x) where appropriate.  */\n #define abs(x) x > 0 ? x : -x\n extern double fabs (double);"}, {"sha": "cfa8a29ef7ee8d55e8304b9dd4c8a0ccd1cbe94b", "filename": "gcc/testsuite/gcc.dg/pr20922-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20922-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20922-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20922-1.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fno-wrapv -fdump-tree-gimple\" } */\n+/* { dg-options \"-fno-wrapv -fstrict-overflow -fdump-tree-gimple\" } */\n int f(int i)\n {\n   return (i - 2) > i;"}, {"sha": "84ecafef968eea6b98d16db5dc24033cdda0898a", "filename": "gcc/testsuite/gcc.dg/pr20922-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20922-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20922-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20922-3.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-ffast-math -fno-wrapv -fdump-tree-gimple\" } */\n+/* { dg-options \"-ffast-math -fno-wrapv -fstrict-overflow -fdump-tree-gimple\" } */\n int f(int i)\n {\n   return (i - 2) <= i;"}, {"sha": "0240435fad2d28cfa0b7fde6cba69f1f34466ac9", "filename": "gcc/testsuite/gcc.dg/pr20922-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20922-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20922-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20922-4.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fno-wrapv -fdump-tree-gimple\" } */\n+/* { dg-options \"-fno-wrapv -fstrict-overflow -fdump-tree-gimple\" } */\n int f(int i)\n {\n   return i < (i - 2);"}, {"sha": "65a8f1d568125d4a6d443e9f4badb891cf67f680", "filename": "gcc/testsuite/gcc.dg/pr20922-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20922-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20922-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20922-6.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-ffast-math -fno-wrapv -fdump-tree-gimple\" } */\n+/* { dg-options \"-ffast-math -fno-wrapv -fstrict-overflow -fdump-tree-gimple\" } */\n int f(int i)\n {\n   return i >= (i - 2);"}, {"sha": "1ff96f4584f75e2064503574de415f7a62c5b29f", "filename": "gcc/testsuite/gcc.dg/strict-overflow-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-1.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+\n+/* Source: Ian Lance Taylor.  Dual of no-strict-overflow-1.c.  */\n+\n+/* We can only simplify the conditional when using strict overflow\n+   semantics.  */\n+\n+int\n+foo (int i)\n+{\n+  return i - 5 < 10;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"-[ ]*5\" \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}, {"sha": "c1ec195e7ee3b7f22520525e7822e3217bae55db", "filename": "gcc/testsuite/gcc.dg/strict-overflow-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-2.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+\n+/* Source: Ian Lance Taylor.  Dual of no-strict-overflow-2.c.  */\n+\n+/* We can only simplify the division when using strict overflow\n+   semantics.  */\n+\n+int\n+foo (int i)\n+{\n+  return (i * 100) / 10;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"100\" \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}, {"sha": "f179324a2fb5e970e62b4a19a058d992138ce3e0", "filename": "gcc/testsuite/gcc.dg/strict-overflow-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-3.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+\n+/* Source: Ian Lance Taylor.  Dual of no-strict-overflow-3.c.  */\n+\n+/* We can only simplify the conditional when using strict overflow\n+   semantics.  */\n+\n+int\n+foo (int i, int j)\n+{\n+  return i + 100 < j + 1000;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"1000\" \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}, {"sha": "c89db2193ba4ab6cc3595034b15956c542c8c444", "filename": "gcc/testsuite/gcc.dg/strict-overflow-4.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-4.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+\n+/* Source: Ian Lance Taylor.  Dual of no-strict-overflow-4.c.  */\n+\n+/* We can only simplify the conditional when using strict overflow\n+   semantics.  */\n+\n+int\n+foo (int i)\n+{\n+  return i + 1 > i;\n+}\n+\n+/* We expect to see \"<bb N>\"; confirm that, so that we know to count\n+   it in the real test.  */\n+/* { dg-final { scan-tree-dump-times \"<bb\\[^>\\]*>\" 1 \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \">|<\" 2 \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}, {"sha": "6194129292d1483fa9e6e33588ef4b6ecb05e99e", "filename": "gcc/testsuite/gcc.dg/torture/pr26898-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr26898-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr26898-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr26898-1.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,4 +1,5 @@\n /* { dg-do link } */\n+/* { dg-options \"-fstrict-overflow\" } */\n \n #include <limits.h>\n "}, {"sha": "fdd3f44e0404430376f531b0d3e33e3c7a756938", "filename": "gcc/testsuite/gcc.dg/tree-ssa/divide-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-1.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-optimized\" } */\n+/* { dg-options \"-O1 -fstrict-overflow -fdump-tree-optimized\" } */\n \n int f(int a)\n {"}, {"sha": "6cd86b21f97509e46e40e34b0a4dc6f4507b5e2c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/divide-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-2.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-optimized\" } */\n+/* { dg-options \"-O1 -fstrict-overflow -fdump-tree-optimized\" } */\n \n int f(int a)\n {"}, {"sha": "d305b549cbd9ba8c82c0e71708efffbb18c8dd7b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/divide-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-3.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-optimized\" } */\n+/* { dg-options \"-O1 -fstrict-overflow -fdump-tree-optimized\" } */\n \n int f(int a)\n {"}, {"sha": "b1bb1efa9e1cc18d7fb2a7ba2324dbf2afad20d4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/divide-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fdivide-4.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-optimized\" } */\n+/* { dg-options \"-O1 -fstrict-overflow -fdump-tree-optimized\" } */\n \n int f(int a)\n {"}, {"sha": "b69bb70d305615ab072e0f5262b4e906a46fb54e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr14490-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14490-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14490-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14490-1.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fdump-tree-gimple\" } */\n+/* { dg-options \"-fstrict-overflow -fdump-tree-gimple\" } */\n int g(int x)\n {\n    return (x - 10) < 0;"}, {"sha": "bf63d3afc790d73706813dfc7c291d8485168e13", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr14490-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14490-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14490-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr14490-3.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fdump-tree-gimple\" } */\n+/* { dg-options \"-fstrict-overflow -fdump-tree-gimple\" } */\n int g(int x)\n {\n    return (x + 10) < 0;"}, {"sha": "2e9941060958e9f0a8d9527f18c1a1b7049ed54e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr26899.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr26899.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr26899.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr26899.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-fdump-tree-gimple\" } */\n+/* { dg-options \"-fstrict-overflow -fdump-tree-gimple\" } */\n \n int foo (int i, int j)\n {"}, {"sha": "c0590a5c4e590021347ba39c3048aaa2a8de1296", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,5 +1,5 @@\n /* Exception handling semantics and decomposition for trees.\n-   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1853,7 +1853,7 @@ tree_could_trap_p (tree expr)\n \t  honor_nans = flag_trapping_math && !flag_finite_math_only;\n \t  honor_snans = flag_signaling_nans != 0;\n \t}\n-      else if (INTEGRAL_TYPE_P (t) && TYPE_TRAP_SIGNED (t))\n+      else if (INTEGRAL_TYPE_P (t) && TYPE_OVERFLOW_TRAPS (t))\n \thonor_trapv = true;\n     }\n "}, {"sha": "a1fe07a9dc8230e5784cce8f235efe4d9674727f", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,5 +1,5 @@\n /* Scalar evolution detector.\n-   Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Sebastian Pop <s.pop@laposte.net>\n \n This file is part of GCC.\n@@ -2837,9 +2837,8 @@ simple_iv (struct loop *loop, tree stmt, tree op, affine_iv *iv,\n       || chrec_contains_symbols_defined_in_loop (iv->base, loop->num))\n     return false;\n \n-  iv->no_overflow = (!folded_casts\n-\t\t     && !flag_wrapv\n-\t\t     && !TYPE_UNSIGNED (type));\n+  iv->no_overflow = !folded_casts && TYPE_OVERFLOW_UNDEFINED (type);\n+\n   return true;\n }\n "}, {"sha": "48e045b2429e04622038af98e5000201a88013ad", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,5 +1,5 @@\n /* Functions to determine/estimate number of iterations of a loop.\n-   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    \n This file is part of GCC.\n    \n@@ -1874,7 +1874,7 @@ infer_loop_bounds_from_signedness (struct loop *loop, tree stmt)\n {\n   tree def, base, step, scev, type, low, high;\n \n-  if (flag_wrapv || TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return;\n \n   def = GIMPLE_STMT_OPERAND (stmt, 0);\n@@ -1884,7 +1884,7 @@ infer_loop_bounds_from_signedness (struct loop *loop, tree stmt)\n \n   type = TREE_TYPE (def);\n   if (!INTEGRAL_TYPE_P (type)\n-      || TYPE_UNSIGNED (type))\n+      || !TYPE_OVERFLOW_UNDEFINED (type))\n     return;\n \n   scev = instantiate_parameters (loop, analyze_scalar_evolution (loop, def));\n@@ -2094,9 +2094,8 @@ n_of_executions_at_most (tree stmt,\n bool\n nowrap_type_p (tree type)\n {\n-  if (!flag_wrapv\n-      && INTEGRAL_TYPE_P (type)\n-      && !TYPE_UNSIGNED (type))\n+  if (INTEGRAL_TYPE_P (type)\n+      && TYPE_OVERFLOW_UNDEFINED (type))\n     return true;\n \n   if (POINTER_TYPE_P (type))"}, {"sha": "82d4814a30efe2b6a1d1a0b3a0f157f6f0184708", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,5 +1,5 @@\n /* Lower vector operations to scalar operations.\n-   Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n    \n@@ -301,14 +301,14 @@ expand_vector_operation (block_stmt_iterator *bsi, tree type, tree compute_type,\n       {\n       case PLUS_EXPR:\n       case MINUS_EXPR:\n-        if (!TYPE_TRAP_SIGNED (type))\n+        if (!TYPE_OVERFLOW_TRAPS (type))\n           return expand_vector_addition (bsi, do_binop, do_plus_minus, type,\n \t\t      \t\t         TREE_OPERAND (rhs, 0),\n \t\t\t\t\t TREE_OPERAND (rhs, 1), code);\n \tbreak;\n \n       case NEGATE_EXPR:\n-        if (!TYPE_TRAP_SIGNED (type))\n+        if (!TYPE_OVERFLOW_TRAPS (type))\n           return expand_vector_addition (bsi, do_unop, do_negate, type,\n \t\t      \t\t         TREE_OPERAND (rhs, 0),\n \t\t\t\t\t NULL_TREE, code);"}, {"sha": "ef805955efc224db112a3d35f5c2ce0a2ae61bdf", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,5 +1,5 @@\n /* Loop Vectorization\n-   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Dorit Naishlos <dorit@il.ibm.com>\n \n This file is part of GCC.\n@@ -2033,7 +2033,7 @@ vect_is_simple_reduction (struct loop *loop, tree phi)\n         }\n       return NULL_TREE;\n     }\n-  else if (INTEGRAL_TYPE_P (type) && !TYPE_UNSIGNED (type) && flag_trapv)\n+  else if (INTEGRAL_TYPE_P (type) && TYPE_OVERFLOW_TRAPS (type))\n     {\n       /* Changing the order of operations changes the semantics.  */\n       if (vect_print_dump_info (REPORT_DETAILS))"}, {"sha": "86f3d1c3710c493590a1607da55c990e2fa996cf", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1,5 +1,5 @@\n /* Support routines for Value Range Propagation (VRP).\n-   Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>.\n \n This file is part of GCC.\n@@ -570,8 +570,7 @@ compare_values (tree val1, tree val2)\n \treturn 0;\n \n       /* If overflow is defined we cannot simplify more.  */\n-      if (TYPE_UNSIGNED (TREE_TYPE (val1))\n-\t  || flag_wrapv)\n+      if (!TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (val1)))\n \treturn -2;\n \n       if (code1 == SSA_NAME)\n@@ -1215,8 +1214,7 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2)\n \n   /* If we are not using wrapping arithmetic, operate symbolically\n      on -INF and +INF.  */\n-  if (TYPE_UNSIGNED (TREE_TYPE (val1))\n-      || flag_wrapv)\n+  if (TYPE_OVERFLOW_WRAPS (TREE_TYPE (val1)))\n     {\n       int checkz = compare_values (res, val1);\n       bool overflow = false;\n@@ -1503,7 +1501,7 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n \t point.  */\n       if (code == MULT_EXPR\n \t  && vr0.type == VR_ANTI_RANGE\n-\t  && (flag_wrapv || TYPE_UNSIGNED (TREE_TYPE (op0))))\n+\t  && !TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (op0)))\n \t{\n \t  set_value_range_to_varying (vr);\n \t  return;\n@@ -1799,11 +1797,12 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \t    ? TYPE_MIN_VALUE (TREE_TYPE (expr))\n \t    : fold_unary_to_constant (code, TREE_TYPE (expr), vr0.max);\n \n-      max = vr0.min == TYPE_MIN_VALUE (TREE_TYPE (expr))\n-\t    ? (vr0.type == VR_ANTI_RANGE || flag_wrapv\n-\t       ? TYPE_MIN_VALUE (TREE_TYPE (expr))\n-\t       : TYPE_MAX_VALUE (TREE_TYPE (expr)))\n-\t    : fold_unary_to_constant (code, TREE_TYPE (expr), vr0.min);\n+      max = (vr0.min == TYPE_MIN_VALUE (TREE_TYPE (expr))\n+\t     ? ((vr0.type == VR_ANTI_RANGE\n+\t\t || TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr)))\n+\t\t? TYPE_MIN_VALUE (TREE_TYPE (expr))\n+\t\t: TYPE_MAX_VALUE (TREE_TYPE (expr)))\n+\t     : fold_unary_to_constant (code, TREE_TYPE (expr), vr0.min));\n \n     }\n   else if (code == NEGATE_EXPR\n@@ -1828,7 +1827,7 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n     {\n       /* -TYPE_MIN_VALUE = TYPE_MIN_VALUE with flag_wrapv so we can't get a\n          useful range.  */\n-      if (flag_wrapv\n+      if (!TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (expr))\n \t  && ((vr0.type == VR_RANGE\n \t       && vr0.min == TYPE_MIN_VALUE (TREE_TYPE (expr)))\n \t      || (vr0.type == VR_ANTI_RANGE\n@@ -1865,7 +1864,8 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \t         or ~[-INF + 1, min (abs(MIN), abs(MAX))] when\n \t\t flag_wrapv is set and the original anti-range doesn't include\n \t         TYPE_MIN_VALUE, remember -TYPE_MIN_VALUE = TYPE_MIN_VALUE.  */\n-\t      min = (flag_wrapv && vr0.min != type_min_value\n+\t      min = ((TYPE_OVERFLOW_WRAPS (TREE_TYPE (expr))\n+\t\t      && vr0.min != type_min_value)\n \t\t     ? int_const_binop (PLUS_EXPR,\n \t\t\t\t\ttype_min_value,\n \t\t\t\t\tinteger_one_node, 0)"}, {"sha": "5f45c94f9389eed498542b1ba6b93e4a5a1ea59b", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eeef0e452e98fe6424ce65fb25fba15c59151848/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=eeef0e452e98fe6424ce65fb25fba15c59151848", "patch": "@@ -1237,9 +1237,6 @@ extern void omp_clause_range_check_failed (const tree, const char *, int,\n /* In integral and pointer types, means an unsigned type.  */\n #define TYPE_UNSIGNED(NODE) (TYPE_CHECK (NODE)->base.unsigned_flag)\n \n-#define TYPE_TRAP_SIGNED(NODE) \\\n-  (flag_trapv && ! TYPE_UNSIGNED (NODE))\n-\n /* Nonzero in a VAR_DECL means assembler code has been written.\n    Nonzero in a FUNCTION_DECL means that the function has been compiled.\n    This is interesting in an inline function, since it might not need"}]}