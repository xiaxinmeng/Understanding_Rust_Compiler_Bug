{"sha": "2bf86c845a89fce00ccb219adbf6002443b5b1cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJmODZjODQ1YTg5ZmNlMDBjY2IyMTlhZGJmNjAwMjQ0M2I1YjFjYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-11-18T20:44:16Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-11-18T20:44:16Z"}, "message": "ipa-cp.c (ipcp_cloning_candidate_p): Use opt_for_fn.\n\n\n\t* ipa-cp.c (ipcp_cloning_candidate_p): Use opt_for_fn.\n\t(ipa_value_from_jfunc, ipa_context_from_jfunc): Skip sanity check.\n\t(ipa_get_indirect_edge_target_1): Use opt_for_fn.\n\t(good_cloning_opportunity_p): Likewise.\n\t(ipa-cp gate): Enable ipa-cp with LTO.\n\t* ipa-profile.c (ipa_propagate_frequency): Use opt_for_fn.\n\t* ipa.c (symbol_table::remove_unreachable_nodes): Always build type\n\tinheritance.\n\t* ipa-inline-transform.c (inline_transform): Check if there are inlines\n\tto apply even at -O0.\n\t* cgraphunit.c (cgraph_node::finalize_function): Use opt_for_fn.\n\t(analyze_functions): Build type inheritance graph.\n\t* ipa-inline.c (can_inline_edge_p): Use opt_for_fn.\n\t(want_early_inline_function_p, want_inline_small_function_p):\n\tLikewise.\n\t(check_callers): Likewise.\n\t(edge_badness): Likewise.\n\t(inline_small_functions): Always be ready for indirect inlining\n\tto happend.\n\t(ipa_inline): Always use want_inline_function_to_all_callers_p.\n\t(early_inline_small_functions): Use opt_for_fn.\n\t* ipa-inline-analysis.c (estimate_function_body_sizes): use opt_for_fn.\n\t(estimate_function_body_sizes): Likewise.\n\t(compute_inline_parameters): Likewise.\n\t(estimate_edge_devirt_benefit): Likewise.\n\t(inline_analyze_function): Likewise.\n\t* ipa-devirt.c (ipa_devirt): Likewise.\n\t(gate): Use in_lto_p.\n\t* ipa-prop.c (ipa_func_spec_opts_forbid_analysis_p): Use opt_for_fn.\n\t(try_make_edge_direct_virtual_call): Likewise.\n\t(update_indirect_edges_after_inlining): Likewise.\n\t(ipa_free_all_structures_after_ipa_cp): Add in_lto_p check.\n\t* common.opt (findirect-inlining): Turn into optimization.\n\t* ipa-pure-const.c (add_new_function): Use opt_for_fn.\n\t(pure_const_generate_summary): Likewise.\n\t(gate_pure_const): Always enable with in_lto_p.\n\nFrom-SVN: r217737", "tree": {"sha": "78111324e160451c1d54ce78b9af90a1e98ffa12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78111324e160451c1d54ce78b9af90a1e98ffa12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bf86c845a89fce00ccb219adbf6002443b5b1cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf86c845a89fce00ccb219adbf6002443b5b1cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bf86c845a89fce00ccb219adbf6002443b5b1cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf86c845a89fce00ccb219adbf6002443b5b1cb/comments", "author": null, "committer": null, "parents": [{"sha": "bb59f396f8ca74c7d663c197e99d15bbe9f6e5b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb59f396f8ca74c7d663c197e99d15bbe9f6e5b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb59f396f8ca74c7d663c197e99d15bbe9f6e5b6"}], "stats": {"total": 180, "additions": 108, "deletions": 72}, "files": [{"sha": "647902bb678259697a56e38c81a373bc4e832e5c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2bf86c845a89fce00ccb219adbf6002443b5b1cb", "patch": "@@ -1,3 +1,42 @@\n+2014-11-18  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-cp.c (ipcp_cloning_candidate_p): Use opt_for_fn.\n+\t(ipa_value_from_jfunc, ipa_context_from_jfunc): Skip sanity check.\n+\t(ipa_get_indirect_edge_target_1): Use opt_for_fn.\n+\t(good_cloning_opportunity_p): Likewise.\n+\t(ipa-cp gate): Enable ipa-cp with LTO.\n+\t* ipa-profile.c (ipa_propagate_frequency): Use opt_for_fn.\n+\t* ipa.c (symbol_table::remove_unreachable_nodes): Always build type\n+\tinheritance.\n+\t* ipa-inline-transform.c (inline_transform): Check if there are inlines\n+\tto apply even at -O0.\n+\t* cgraphunit.c (cgraph_node::finalize_function): Use opt_for_fn.\n+\t(analyze_functions): Build type inheritance graph.\n+\t* ipa-inline.c (can_inline_edge_p): Use opt_for_fn.\n+\t(want_early_inline_function_p, want_inline_small_function_p):\n+\tLikewise.\n+\t(check_callers): Likewise.\n+\t(edge_badness): Likewise.\n+\t(inline_small_functions): Always be ready for indirect inlining\n+\tto happend.\n+\t(ipa_inline): Always use want_inline_function_to_all_callers_p.\n+\t(early_inline_small_functions): Use opt_for_fn.\n+\t* ipa-inline-analysis.c (estimate_function_body_sizes): use opt_for_fn.\n+\t(estimate_function_body_sizes): Likewise.\n+\t(compute_inline_parameters): Likewise.\n+\t(estimate_edge_devirt_benefit): Likewise.\n+\t(inline_analyze_function): Likewise.\n+\t* ipa-devirt.c (ipa_devirt): Likewise.\n+\t(gate): Use in_lto_p.\n+\t* ipa-prop.c (ipa_func_spec_opts_forbid_analysis_p): Use opt_for_fn.\n+\t(try_make_edge_direct_virtual_call): Likewise.\n+\t(update_indirect_edges_after_inlining): Likewise.\n+\t(ipa_free_all_structures_after_ipa_cp): Add in_lto_p check.\n+\t* common.opt (findirect-inlining): Turn into optimization.\n+\t* ipa-pure-const.c (add_new_function): Use opt_for_fn.\n+\t(pure_const_generate_summary): Likewise.\n+\t(gate_pure_const): Always enable with in_lto_p.\n+\n 2014-11-18  Maciej W. Rozycki  <macro@codesourcery.com>\n \n \t* config/mips/mips.md (compression): Add `micromips32' setting."}, {"sha": "e380e841dfdd60d6c37961c9c25f4c887279ba51", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=2bf86c845a89fce00ccb219adbf6002443b5b1cb", "patch": "@@ -450,7 +450,7 @@ cgraph_node::finalize_function (tree decl, bool no_collect)\n      declared inline and nested functions.  These were optimized out\n      in the original implementation and it is unclear whether we want\n      to change the behavior here.  */\n-  if ((!optimize\n+  if ((!opt_for_fn (decl, optimize)\n        && !node->cpp_implicit_alias\n        && !DECL_DISREGARD_INLINE_LIMITS (decl)\n        && !DECL_DECLARED_INLINE_P (decl)\n@@ -929,8 +929,7 @@ analyze_functions (void)\n     FOR_EACH_SYMBOL (node)\n       if (node->cpp_implicit_alias)\n \t  node->fixup_same_cpp_alias_visibility (node->get_alias_target ());\n-  if (optimize && flag_devirtualize)\n-    build_type_inheritance_graph ();\n+  build_type_inheritance_graph ();\n \n   /* Analysis adds static variables that in turn adds references to new functions.\n      So we need to iterate the process until it stabilize.  */\n@@ -1001,7 +1000,8 @@ analyze_functions (void)\n \t      for (edge = cnode->callees; edge; edge = edge->next_callee)\n \t\tif (edge->callee->definition)\n \t\t   enqueue_node (edge->callee);\n-\t      if (optimize && opt_for_fn (cnode->decl, flag_devirtualize))\n+\t      if (opt_for_fn (cnode->decl, optimize)\n+\t\t  && opt_for_fn (cnode->decl, flag_devirtualize))\n \t\t{\n \t\t  cgraph_edge *next;\n \n@@ -1046,8 +1046,7 @@ analyze_functions (void)\n \t  symtab->process_new_functions ();\n \t}\n     }\n-  if (optimize && flag_devirtualize)\n-    update_type_inheritance_graph ();\n+  update_type_inheritance_graph ();\n \n   /* Collect entry points to the unit.  */\n   if (symtab->dump_file)"}, {"sha": "41c8d4ed76db65d4ffe78c8dc0793de1253c4926", "filename": "gcc/common.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=2bf86c845a89fce00ccb219adbf6002443b5b1cb", "patch": "@@ -1392,7 +1392,7 @@ Common Report Var(flag_inhibit_size_directive)\n Do not generate .size directives\n \n findirect-inlining\n-Common Report Var(flag_indirect_inlining)\n+Common Report Var(flag_indirect_inlining) Optimization\n Perform indirect inlining\n \n ; General flag to enable inlining.  Specifying -fno-inline will disable"}, {"sha": "f97912ba72df5c142946fcf37013e9631e9c8221", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=2bf86c845a89fce00ccb219adbf6002443b5b1cb", "patch": "@@ -566,7 +566,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n \n   gcc_checking_assert (node->has_gimple_body_p ());\n \n-  if (!flag_ipa_cp_clone)\n+  if (!opt_for_fn (node->decl, flag_ipa_cp_clone))\n     {\n       if (dump_file)\n         fprintf (dump_file, \"Not considering %s for cloning; \"\n@@ -902,10 +902,7 @@ ipa_value_from_jfunc (struct ipa_node_params *info, struct ipa_jump_func *jfunc)\n \t  ipcp_lattice<tree> *lat;\n \n \t  if (!info->lattices)\n-\t    {\n-\t      gcc_checking_assert (!flag_ipa_cp);\n-\t      return NULL_TREE;\n-\t    }\n+\t    return NULL_TREE;\n \t  lat = ipa_get_scalar_lat (info, idx);\n \t  if (!lat->is_single_const ())\n \t    return NULL_TREE;\n@@ -967,10 +964,7 @@ ipa_context_from_jfunc (ipa_node_params *info, cgraph_edge *cs, int csidx,\n       else\n \t{\n \t  if (!info->lattices)\n-\t    {\n-\t      gcc_checking_assert (!flag_ipa_cp);\n-\t      return ctx;\n-\t    }\n+\t    return ctx;\n \t  ipcp_lattice<ipa_polymorphic_call_context> *lat;\n \t  lat = ipa_get_poly_ctx_lat (info, srcidx);\n \t  if (!lat->is_single_const ())\n@@ -1786,7 +1780,7 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n \treturn NULL_TREE;\n     }\n \n-  if (!flag_devirtualize)\n+  if (!opt_for_fn (ie->caller->decl, flag_devirtualize))\n     return NULL_TREE;\n \n   gcc_assert (!ie->indirect_info->agg_contents);\n@@ -1884,8 +1878,8 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n       struct cgraph_node *node;\n       if (*speculative)\n \treturn target;\n-      if (!flag_devirtualize_speculatively || ie->speculative\n-\t  || !ie->maybe_hot_p ())\n+      if (!opt_for_fn (ie->caller->decl, flag_devirtualize_speculatively)\n+\t  || ie->speculative || !ie->maybe_hot_p ())\n \treturn NULL;\n       node = try_speculative_devirtualization (ie->indirect_info->otr_type,\n \t\t\t\t\t       ie->indirect_info->otr_token,\n@@ -2003,7 +1997,7 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n \t\t\t    int freq_sum, gcov_type count_sum, int size_cost)\n {\n   if (time_benefit == 0\n-      || !flag_ipa_cp_clone\n+      || !opt_for_fn (node->decl, flag_ipa_cp_clone)\n       || !optimize_function_for_speed_p (DECL_STRUCT_FUNCTION (node->decl)))\n     return false;\n \n@@ -4315,7 +4309,7 @@ class pass_ipa_cp : public ipa_opt_pass_d\n     {\n       /* FIXME: We should remove the optimize check after we ensure we never run\n \t IPA passes when not optimizing.  */\n-      return flag_ipa_cp && optimize;\n+      return (flag_ipa_cp && optimize) || in_lto_p;\n     }\n \n   virtual unsigned int execute (function *) { return ipcp_driver (); }"}, {"sha": "99475f6b64051f86c476d5980fad0fdd163fb2ec", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=2bf86c845a89fce00ccb219adbf6002443b5b1cb", "patch": "@@ -2818,6 +2818,8 @@ ipa_devirt (void)\n   FOR_EACH_DEFINED_FUNCTION (n)\n     {\t\n       bool update = false;\n+      if (!opt_for_fn (n->decl, flag_devirtualize))\n+\tcontinue;\n       if (dump_file && n->indirect_calls)\n \tfprintf (dump_file, \"\\n\\nProcesing function %s/%i\\n\",\n \t\t n->name (), n->order);\n@@ -2846,7 +2848,7 @@ ipa_devirt (void)\n \n \t    npolymorphic++;\n \n-\t    if (!flag_devirtualize_speculatively)\n+\t    if (!opt_for_fn (n->decl, flag_devirtualize_speculatively))\n \t      continue;\n \n \t    if (!e->maybe_hot_p ())\n@@ -3116,6 +3118,10 @@ class pass_ipa_devirt : public ipa_opt_pass_d\n   /* opt_pass methods: */\n   virtual bool gate (function *)\n     {\n+      /* In LTO, always run the IPA passes and decide on function basis if the\n+\t pass is enabled.  */\n+      if (in_lto_p)\n+\treturn true;\n       return (flag_devirtualize\n \t      && (flag_devirtualize_speculatively\n \t\t  || (warn_suggest_final_methods"}, {"sha": "0494e0456e10a31db30cdc1ef61c548234ec2532", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=2bf86c845a89fce00ccb219adbf6002443b5b1cb", "patch": "@@ -2474,7 +2474,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   info->conds = NULL;\n   info->entry = NULL;\n \n-  if (optimize && !early)\n+  if (opt_for_fn (node->decl, optimize) && !early)\n     {\n       calculate_dominance_info (CDI_DOMINATORS);\n       loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);\n@@ -2815,7 +2815,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n   inline_summary (node)->self_time = time;\n   inline_summary (node)->self_size = size;\n   nonconstant_names.release ();\n-  if (optimize && !early)\n+  if (opt_for_fn (node->decl, optimize) && !early)\n     {\n       loop_optimizer_finalize ();\n       free_dominance_info (CDI_DOMINATORS);\n@@ -2872,8 +2872,9 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n   info->stack_frame_offset = 0;\n \n   /* Can this function be inlined at all?  */\n-  if (!optimize && !lookup_attribute (\"always_inline\",\n-\t\t\t\t      DECL_ATTRIBUTES (node->decl)))\n+  if (!opt_for_fn (node->decl, optimize)\n+      && !lookup_attribute (\"always_inline\",\n+\t\t\t    DECL_ATTRIBUTES (node->decl)))\n     info->inlinable = false;\n   else\n     info->inlinable = tree_inlinable_function_p (node->decl);\n@@ -2990,7 +2991,7 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n \n   if (!known_vals.exists () && !known_contexts.exists ())\n     return false;\n-  if (!flag_indirect_inlining)\n+  if (!opt_for_fn (ie->caller->decl, flag_indirect_inlining))\n     return false;\n \n   target = ipa_get_indirect_edge_target (ie, known_vals, known_contexts,\n@@ -3986,7 +3987,7 @@ inline_analyze_function (struct cgraph_node *node)\n   if (dump_file)\n     fprintf (dump_file, \"\\nAnalyzing function: %s/%u\\n\",\n \t     node->name (), node->order);\n-  if (optimize && !node->thunk.thunk_p)\n+  if (opt_for_fn (node->decl, optimize) && !node->thunk.thunk_p)\n     inline_indirect_intraprocedural_analysis (node);\n   compute_inline_parameters (node, false);\n   if (!optimize)"}, {"sha": "9b806c1bf6615ac7e28e214a69dc7a3c61c9bc01", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=2bf86c845a89fce00ccb219adbf6002443b5b1cb", "patch": "@@ -467,6 +467,7 @@ inline_transform (struct cgraph_node *node)\n {\n   unsigned int todo = 0;\n   struct cgraph_edge *e, *next;\n+  bool has_inline = false;\n  \n   /* FIXME: Currently the pass manager is adding inline transform more than\n      once to some clones.  This needs revisiting after WPA cleanups.  */\n@@ -480,13 +481,15 @@ inline_transform (struct cgraph_node *node)\n \n   for (e = node->callees; e; e = next)\n     {\n+      if (!e->inline_failed)\n+\thas_inline = true;\n       next = e->next_callee;\n       e->redirect_call_stmt_to_callee ();\n     }\n   node->remove_all_references ();\n \n   timevar_push (TV_INTEGRATION);\n-  if (node->callees && optimize)\n+  if (node->callees && (optimize || has_inline))\n     todo = optimize_inline_calls (current_function_decl);\n   timevar_pop (TV_INTEGRATION);\n "}, {"sha": "72c0715dc566abe7f8810032b1a87d7ea2ef6a46", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=2bf86c845a89fce00ccb219adbf6002443b5b1cb", "patch": "@@ -378,18 +378,10 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n      optimization attribute.  */\n   else if (caller_tree != callee_tree)\n     {\n-      struct cl_optimization *caller_opt\n-\t= TREE_OPTIMIZATION ((caller_tree)\n-\t\t\t     ? caller_tree\n-\t\t\t     : optimization_default_node);\n-\n-      struct cl_optimization *callee_opt\n-\t= TREE_OPTIMIZATION ((callee_tree)\n-\t\t\t     ? callee_tree\n-\t\t\t     : optimization_default_node);\n-\n-      if (((caller_opt->x_optimize > callee_opt->x_optimize)\n-\t   || (caller_opt->x_optimize_size != callee_opt->x_optimize_size))\n+      if (((opt_for_fn (e->caller->decl, optimize)\n+\t    > opt_for_fn (e->callee->decl, optimize))\n+\t    || (opt_for_fn (e->caller->decl, optimize_size)\n+\t\t!= opt_for_fn (e->callee->decl, optimize_size)))\n \t  /* gcc.dg/pr43564.c.  Look at forced inline even in -O0.  */\n \t  && !DECL_DISREGARD_INLINE_LIMITS (e->callee->decl))\n \t{\n@@ -469,7 +461,7 @@ want_early_inline_function_p (struct cgraph_edge *e)\n   else if (flag_auto_profile && afdo_callsite_hot_enough_for_early_inline (e))\n     ;\n   else if (!DECL_DECLARED_INLINE_P (callee->decl)\n-\t   && !flag_inline_small_functions)\n+\t   && !opt_for_fn (e->caller->decl, flag_inline_small_functions))\n     {\n       e->inline_failed = CIF_FUNCTION_NOT_INLINE_CANDIDATE;\n       report_inline_failed_reason (e);\n@@ -587,7 +579,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n   if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n     ;\n   else if (!DECL_DECLARED_INLINE_P (callee->decl)\n-\t   && !flag_inline_small_functions)\n+\t   && !opt_for_fn (e->caller->decl, flag_inline_small_functions))\n     {\n       e->inline_failed = CIF_FUNCTION_NOT_INLINE_CANDIDATE;\n       want_inline = false;\n@@ -639,7 +631,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t  want_inline = false;\n \t}\n       else if (!DECL_DECLARED_INLINE_P (callee->decl)\n-\t       && !flag_inline_functions)\n+\t       && !opt_for_fn (e->caller->decl, flag_inline_functions))\n \t{\n \t  /* growth_likely_positive is expensive, always test it last.  */\n           if (growth >= MAX_INLINE_INSNS_SINGLE\n@@ -816,6 +808,8 @@ check_callers (struct cgraph_node *node, void *has_hot_call)\n   struct cgraph_edge *e;\n    for (e = node->callers; e; e = e->next_caller)\n      {\n+       if (!opt_for_fn (e->caller->decl, flag_inline_functions_called_once))\n+\t return true;\n        if (!can_inline_edge_p (e, true))\n          return true;\n        if (!(*(bool *)has_hot_call) && e->maybe_hot_p ())\n@@ -1010,6 +1004,8 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \n      compensated by the inline hints.\n   */\n+  /* TODO: We ought suport mixing units where some functions are profiled\n+     and some not.  */\n   else if (flag_guess_branch_prob)\n     {\n       badness = (relative_time_benefit (callee_info, edge, edge_time)\n@@ -1575,8 +1571,7 @@ inline_small_functions (void)\n   int initial_size = 0;\n   struct cgraph_node **order = XCNEWVEC (cgraph_node *, symtab->cgraph_count);\n   struct cgraph_edge_hook_list *edge_removal_hook_holder;\n-  if (flag_indirect_inlining)\n-    new_indirect_edges.create (8);\n+  new_indirect_edges.create (8);\n \n   edge_removal_hook_holder\n     = symtab->add_edge_removal_hook (&heap_edge_removal_hook, &edge_heap);\n@@ -1773,7 +1768,8 @@ inline_small_functions (void)\n \t  if (where->global.inlined_to)\n \t    where = where->global.inlined_to;\n \t  if (!recursive_inlining (edge,\n-\t\t\t\t   flag_indirect_inlining\n+\t\t\t\t   opt_for_fn (edge->caller->decl,\n+\t\t\t\t\t       flag_indirect_inlining)\n \t\t\t\t   ? &new_indirect_edges : NULL))\n \t    {\n \t      edge->inline_failed = CIF_RECURSIVE_INLINING;\n@@ -1783,7 +1779,7 @@ inline_small_functions (void)\n \t  reset_edge_caches (where);\n \t  /* Recursive inliner inlines all recursive calls of the function\n \t     at once. Consequently we need to update all callee keys.  */\n-\t  if (flag_indirect_inlining)\n+\t  if (opt_for_fn (edge->caller->decl, flag_indirect_inlining))\n \t    add_new_edges_to_heap (&edge_heap, new_indirect_edges);\n           update_callee_keys (&edge_heap, where, updated_nodes);\n \t  bitmap_clear (updated_nodes);\n@@ -1821,8 +1817,7 @@ inline_small_functions (void)\n \n \t  gcc_checking_assert (!callee->global.inlined_to);\n \t  inline_call (edge, true, &new_indirect_edges, &overall_size, true);\n-\t  if (flag_indirect_inlining)\n-\t    add_new_edges_to_heap (&edge_heap, new_indirect_edges);\n+\t  add_new_edges_to_heap (&edge_heap, new_indirect_edges);\n \n \t  reset_edge_caches (edge->callee);\n           reset_node_growth_cache (callee);\n@@ -2246,8 +2241,7 @@ ipa_inline (void)\n \t      reset_edge_caches (where);\n \t      inline_update_overall_summary (where);\n \t    }\n-\t  if (flag_inline_functions_called_once\n-\t      && want_inline_function_to_all_callers_p (node, cold))\n+\t  if (want_inline_function_to_all_callers_p (node, cold))\n \t    {\n \t      int num_calls = 0;\n \t      node->call_for_symbol_thunks_and_aliases (sum_callers, &num_calls,\n@@ -2345,8 +2339,8 @@ early_inline_small_functions (struct cgraph_node *node)\n \n       /* Do not consider functions not declared inline.  */\n       if (!DECL_DECLARED_INLINE_P (callee->decl)\n-\t  && !flag_inline_small_functions\n-\t  && !flag_inline_functions)\n+\t  && !opt_for_fn (node->decl, flag_inline_small_functions)\n+\t  && !opt_for_fn (node->decl, flag_inline_functions))\n \tcontinue;\n \n       if (dump_file)"}, {"sha": "340d033b6a52fa2714460192e8b37c52778a66eb", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=2bf86c845a89fce00ccb219adbf6002443b5b1cb", "patch": "@@ -418,7 +418,8 @@ ipa_propagate_frequency (struct cgraph_node *node)\n      nor about virtuals.  */\n   if (!node->local.local\n       || node->alias\n-      || (flag_devirtualize && DECL_VIRTUAL_P (node->decl)))\n+      || (opt_for_fn (node->decl, flag_devirtualize)\n+\t  && DECL_VIRTUAL_P (node->decl)))\n     return false;\n   gcc_assert (node->analyzed);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -754,7 +755,7 @@ class pass_ipa_profile : public ipa_opt_pass_d\n   {}\n \n   /* opt_pass methods: */\n-  virtual bool gate (function *) { return flag_ipa_profile; }\n+  virtual bool gate (function *) { return flag_ipa_profile || in_lto_p; }\n   virtual unsigned int execute (function *) { return ipa_profile (); }\n \n }; // class pass_ipa_profile"}, {"sha": "6905f0cc79ccfc4b1eea327717af2ec88e1d9495", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=2bf86c845a89fce00ccb219adbf6002443b5b1cb", "patch": "@@ -168,12 +168,10 @@ static bool\n ipa_func_spec_opts_forbid_analysis_p (struct cgraph_node *node)\n {\n   tree fs_opts = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (node->decl);\n-  struct cl_optimization *os;\n \n   if (!fs_opts)\n     return false;\n-  os = TREE_OPTIMIZATION (fs_opts);\n-  return !os->x_optimize || !os->x_flag_ipa_cp;\n+  return !opt_for_fn (node->decl, optimize) || !opt_for_fn (node->decl, flag_ipa_cp);\n }\n \n /* Return index of the formal whose tree is PTREE in function which corresponds\n@@ -2896,13 +2894,14 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n   tree target = NULL;\n   bool speculative = false;\n \n-  if (!flag_devirtualize)\n+  if (!opt_for_fn (ie->caller->decl, flag_devirtualize))\n     return NULL;\n \n   gcc_assert (!ie->indirect_info->by_ref);\n \n   /* Try to do lookup via known virtual table pointer value.  */\n-  if (!ie->indirect_info->vptr_changed || flag_devirtualize_speculatively)\n+  if (!ie->indirect_info->vptr_changed\n+      || opt_for_fn (ie->caller->decl, flag_devirtualize_speculatively))\n     {\n       tree vtable;\n       unsigned HOST_WIDE_INT offset;\n@@ -2953,7 +2952,7 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n       else\n \ttarget = ipa_impossible_devirt_target (ie, NULL_TREE);\n     }\n-  else if (!target && flag_devirtualize_speculatively\n+  else if (!target && opt_for_fn (ie->caller->decl, flag_devirtualize_speculatively)\n \t   && !ie->speculative && ie->maybe_hot_p ())\n     {\n       cgraph_node *n;\n@@ -3025,7 +3024,7 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n       param_index = ici->param_index;\n       jfunc = ipa_get_ith_jump_func (top, param_index);\n \n-      if (!flag_indirect_inlining)\n+      if (!opt_for_fn (node->decl, flag_indirect_inlining))\n \tnew_direct_edge = NULL;\n       else if (ici->polymorphic)\n \t{\n@@ -3579,7 +3578,7 @@ ipa_unregister_cgraph_hooks (void)\n void\n ipa_free_all_structures_after_ipa_cp (void)\n {\n-  if (!optimize)\n+  if (!optimize && !in_lto_p)\n     {\n       ipa_free_all_edge_args ();\n       ipa_free_all_node_params ();"}, {"sha": "50d7300cc4f4e8766f991a2f180ae1cfecbac5d8", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=2bf86c845a89fce00ccb219adbf6002443b5b1cb", "patch": "@@ -914,7 +914,8 @@ add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n      static declarations.  We do not need to scan them more than once\n      since all we would be interested in are the addressof\n      operations.  */\n-  if (node->get_availability () > AVAIL_INTERPOSABLE)\n+  if (node->get_availability () > AVAIL_INTERPOSABLE\n+      && opt_for_fn (node->decl, flag_ipa_pure_const))\n     set_function_state (node, analyze_function (node, true));\n }\n \n@@ -984,7 +985,8 @@ pure_const_generate_summary (void)\n      when function got cloned and the clone is AVAILABLE.  */\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (node->get_availability () >= AVAIL_INTERPOSABLE)\n+    if (node->get_availability () >= AVAIL_INTERPOSABLE\n+        && opt_for_fn (node->decl, flag_ipa_pure_const))\n       set_function_state (node, analyze_function (node, true));\n }\n \n@@ -1595,9 +1597,7 @@ execute (function *)\n static bool\n gate_pure_const (void)\n {\n-  return (flag_ipa_pure_const\n-\t  /* Don't bother doing anything if the program has errors.  */\n-\t  && !seen_error ());\n+  return flag_ipa_pure_const || in_lto_p;\n }\n \n pass_ipa_pure_const::pass_ipa_pure_const(gcc::context *ctxt)"}, {"sha": "54b30aab83ce6cdb50d808e8c392945f7d7c6ca5", "filename": "gcc/ipa.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf86c845a89fce00ccb219adbf6002443b5b1cb/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=2bf86c845a89fce00ccb219adbf6002443b5b1cb", "patch": "@@ -304,8 +304,7 @@ symbol_table::remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   hash_set<void *> reachable_call_targets;\n \n   timevar_push (TV_IPA_UNREACHABLE);\n-  if (optimize && flag_devirtualize)\n-    build_type_inheritance_graph ();\n+  build_type_inheritance_graph ();\n   if (file)\n     fprintf (file, \"\\nReclaiming functions:\");\n #ifdef ENABLE_CHECKING\n@@ -391,7 +390,8 @@ symbol_table::remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t    {\n \t      struct cgraph_edge *e;\n \t      /* Keep alive possible targets for devirtualization.  */\n-\t      if (optimize && flag_devirtualize)\n+\t      if (opt_for_fn (cnode->decl, optimize)\n+\t\t  && opt_for_fn (cnode->decl, flag_devirtualize))\n \t\t{\n \t\t  struct cgraph_edge *next;\n \t\t  for (e = cnode->indirect_calls; e; e = next)"}]}