{"sha": "30aabb86ef4252ad2df0d3a56c364b824a2e5245", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBhYWJiODZlZjQyNTJhZDJkZjBkM2E1NmMzNjRiODI0YTJlNTI0NQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-09-09T00:23:09Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-09-09T00:23:09Z"}, "message": "re PR fortran/18878 ([4.0 only] erronous error message on vaild USE statement)\n\n2005-09-09  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/18878\n\t* module.c (find_use_name_n): Based on original\n\tfind_use_name. Either counts number of use names for a\n\tgiven real name or returns use name n.\n\t(find_use_name, number_use_names): Interfaces to the\n\tfunction find_use_name_n.\n\t(read_module): Add the logic and calls to these functions,\n\tso that mutiple reuses of the same real name are loaded.\n\n2005-09-09  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/22304\n\tPR fortran/23270\n\tPR fortran/18870\n\tPR fortran/16511\n\tPR fortran/17917\n\t* gfortran.h: Move definition of BLANK_COMMON_NAME from trans-\n\tcommon.c so that it is accessible to module.c. Add common_head\n\tfield to gfc_symbol structure. Add field for the equivalence\n\tname AND new attr field, in_equivalence.\n\t* match.c (gfc_match_common, gfc_match_equivalence): In loops\n\tthat flag common block equivalences, emit an error if the\n\tcommon blocks are different, using sym->common_head as the\n\tcommon block identifier. Ensure that symbols that are equivalence\n\tassociated with a common block are marked as being in_common.\n\t* module.c (write_blank_common): New.\n\t(write_common): Use unmangled common block name.\n\t(load_equiv): New function ported from g95.\n\t(read_module): Call load_equiv.\n\t(write_equiv): New function ported from g95. Correct\n\tstring referencing for gfc functions. Give module\n\tequivalences a unique name.\n\t(write_module): Call write_equiv and write_blank_common.\n\t* primary.c (match_variable) Old gfc_match_variable, made\n\tstatic and third argument provided to indicate if parent\n\tnamespace to be visited or not.\n\t(gfc_match_variable) New. Interface to match_variable.\n\t(gfc_match_equiv_variable) New. Interface to match_variable.\n\t* trans-common.c (finish_equivalences): Provide the call\n\tto create_common with a gfc_common_header so that\n\tmodule equivalences are made external, rather than local.\n\t(find_equivalences): Ensure that all members in common block\n\tequivalences are marked as used. This prevents the subsequent\n\tcall to this function from making local unions.\n\t* trans-decl.c (gfc_generate_function_code): Move the call to\n\tgfc_generate_contained_functions to after the call to\n\tgfc_trans_common so the use-associated, contained common\n\tblocks produce the correct references.\n\t(gfc_create_module_variable): Return for equivalenced symbols\n\twith existing backend declaration.\n\n2005-09-09  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/18878\n\t* gfortran.dg/module_double_reuse.f90: New.\n\n2005-09-09  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/23270\n\tPR fortran/22304\n\tPR fortran/18870\n\tPR fortran/17917\n\tPR fortran/16511\n\t* gfortran.dg/common_equivalence_1.f: New.\n\t* gfortran.dg/common_equivalence_2.f: New.\n\t* gfortran.dg/common_equivalence_3.f: New.\n\t* gfortran.dg/contained_equivalence_1.f90: New.\n\t* gfortran.dg/module_blank_common.f90: New.\n\t* gfortran.dg/module_commons_1.f90: New.\n\t* gfortran.dg/module_equivalence_1.f90: New.\n\t* gfortran.dg/nested_modules_1.f90: New.\n\t* gfortran.dg/g77/19990905-0.f: Remove XFAIL, rearrange\n\tequivalences and add comment to connect the test with\n\tthe PR.\n\nFrom-SVN: r104060", "tree": {"sha": "64f996b2d8ca7299532cce4088ad6849a5133b49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64f996b2d8ca7299532cce4088ad6849a5133b49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30aabb86ef4252ad2df0d3a56c364b824a2e5245", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30aabb86ef4252ad2df0d3a56c364b824a2e5245", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30aabb86ef4252ad2df0d3a56c364b824a2e5245", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30aabb86ef4252ad2df0d3a56c364b824a2e5245/comments", "author": null, "committer": null, "parents": [{"sha": "7afd4c375db57b7ca45338e83684d0504bc2c547", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7afd4c375db57b7ca45338e83684d0504bc2c547", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7afd4c375db57b7ca45338e83684d0504bc2c547"}], "stats": {"total": 719, "additions": 630, "deletions": 89}, "files": [{"sha": "6cc04bd6a91b76ffca5e13d0d996d4818fae554a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=30aabb86ef4252ad2df0d3a56c364b824a2e5245", "patch": "@@ -1,3 +1,56 @@\n+2005-09-09  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/18878\n+\t* module.c (find_use_name_n): Based on original\n+\tfind_use_name. Either counts number of use names for a\n+\tgiven real name or returns use name n.\n+\t(find_use_name, number_use_names): Interfaces to the\n+\tfunction find_use_name_n.\n+\t(read_module): Add the logic and calls to these functions,\n+\tso that mutiple reuses of the same real name are loaded.\n+\n+2005-09-09  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/22304\n+\tPR fortran/23270\n+\tPR fortran/18870\n+\tPR fortran/16511\n+\tPR fortran/17917\n+\t* gfortran.h: Move definition of BLANK_COMMON_NAME from trans-\n+\tcommon.c so that it is accessible to module.c. Add common_head\n+\tfield to gfc_symbol structure. Add field for the equivalence\n+\tname AND new attr field, in_equivalence.\n+\t* match.c (gfc_match_common, gfc_match_equivalence): In loops\n+\tthat flag common block equivalences, emit an error if the\n+\tcommon blocks are different, using sym->common_head as the\n+\tcommon block identifier. Ensure that symbols that are equivalence\n+\tassociated with a common block are marked as being in_common.\n+\t* module.c (write_blank_common): New.\n+\t(write_common): Use unmangled common block name.\n+\t(load_equiv): New function ported from g95.\n+\t(read_module): Call load_equiv.\n+\t(write_equiv): New function ported from g95. Correct\n+\tstring referencing for gfc functions. Give module\n+\tequivalences a unique name.\n+\t(write_module): Call write_equiv and write_blank_common.\n+\t* primary.c (match_variable) Old gfc_match_variable, made\n+\tstatic and third argument provided to indicate if parent\n+\tnamespace to be visited or not.\n+\t(gfc_match_variable) New. Interface to match_variable.\n+\t(gfc_match_equiv_variable) New. Interface to match_variable.\n+\t* trans-common.c (finish_equivalences): Provide the call\n+\tto create_common with a gfc_common_header so that\n+\tmodule equivalences are made external, rather than local.\n+\t(find_equivalences): Ensure that all members in common block\n+\tequivalences are marked as used. This prevents the subsequent\n+\tcall to this function from making local unions.\n+\t* trans-decl.c (gfc_generate_function_code): Move the call to\n+\tgfc_generate_contained_functions to after the call to\n+\tgfc_trans_common so the use-associated, contained common\n+\tblocks produce the correct references.\n+\t(gfc_create_module_variable): Return for equivalenced symbols\n+\twith existing backend declaration.\n+\n 2005-09-08  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/23765"}, {"sha": "59e1bead111907e8aa860492fc738955faa850ce", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=30aabb86ef4252ad2df0d3a56c364b824a2e5245", "patch": "@@ -77,6 +77,8 @@ char *alloca ();\n #define PREFIX(x) \"_gfortran_\" x\n #define PREFIX_LEN 10\n \n+#define BLANK_COMMON_NAME \"__BLNK__\"\n+\n /* Macro to initialize an mstring structure.  */\n #define minit(s, t) { s, NULL, t }\n \n@@ -419,7 +421,7 @@ typedef struct\n   unsigned data:1,\t\t/* Symbol is named in a DATA statement.  */\n     use_assoc:1;\t\t/* Symbol has been use-associated.  */\n \n-  unsigned in_namelist:1, in_common:1;\n+  unsigned in_namelist:1, in_common:1, in_equivalence:1;\n   unsigned function:1, subroutine:1, generic:1;\n   unsigned implicit_type:1;\t/* Type defined via implicit rules.  */\n   unsigned untyped:1;           /* No implicit type could be found.  */\n@@ -706,6 +708,11 @@ typedef struct gfc_symbol\n   gfc_component *components;\t/* Derived type components */\n \n   struct gfc_symbol *common_next;\t/* Links for COMMON syms */\n+\n+  /* This is in fact a gfc_common_head but it is only used for pointer\n+     comparisons to check if symbols are in the same common block.  */\n+  struct gfc_common_head* common_head;\n+\n   /* Make sure setup code for dummy arguments is generated in the correct\n      order.  */\n   int dummy_order;\n@@ -734,12 +741,12 @@ gfc_symbol;\n \n /* This structure is used to keep track of symbols in common blocks.  */\n \n-typedef struct\n+typedef struct gfc_common_head\n {\n   locus where;\n   int use_assoc, saved;\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n-  gfc_symbol *head;\n+  struct gfc_symbol *head;\n } \n gfc_common_head;\n \n@@ -1194,6 +1201,7 @@ typedef struct gfc_equiv\n {\n   struct gfc_equiv *next, *eq;\n   gfc_expr *expr;\n+  const char *module;\n   int used;\n }\n gfc_equiv;"}, {"sha": "5a626334272c38472fd9f114b7dd0c107ddcada8", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 73, "deletions": 2, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=30aabb86ef4252ad2df0d3a56c364b824a2e5245", "patch": "@@ -2226,10 +2226,11 @@ match_common_name (char *name)\n match\n gfc_match_common (void)\n {\n-  gfc_symbol *sym, **head, *tail, *old_blank_common;\n+  gfc_symbol *sym, **head, *tail, *other, *old_blank_common;\n   char name[GFC_MAX_SYMBOL_LEN+1];\n   gfc_common_head *t;\n   gfc_array_spec *as;\n+  gfc_equiv * e1, * e2;\n   match m;\n \n   old_blank_common = gfc_current_ns->blank_common.head;\n@@ -2348,8 +2349,46 @@ gfc_match_common (void)\n \n \t      sym->as = as;\n \t      as = NULL;\n+\n+\t    }\n+\n+\t  sym->common_head = t;\n+\n+\t  /* Check to see if the symbol is already in an equivalence group.\n+\t     If it is, set the other members as being in common.  */\n+\t  if (sym->attr.in_equivalence)\n+\t    {\n+\t      for (e1 = gfc_current_ns->equiv; e1; e1 = e1->next)\n+\t        {\n+\t          for (e2 = e1; e2; e2 = e2->eq)\n+\t            if (e2->expr->symtree->n.sym == sym)\n+\t\t      goto equiv_found;\n+\n+\t\t  continue;\n+\n+\t  equiv_found:\n+\n+\t\t  for (e2 = e1; e2; e2 = e2->eq)\n+\t\t    {\n+\t\t      other = e2->expr->symtree->n.sym;\n+\t\t      if (other->common_head\n+\t\t            && other->common_head != sym->common_head)\n+\t\t\t{\n+\t\t\t  gfc_error (\"Symbol '%s', in COMMON block '%s' at \"\n+\t\t\t\t     \"%C is being indirectly equivalenced to \"\n+\t\t\t\t     \"another COMMON block '%s'\",\n+\t\t\t\t     sym->name,\n+\t\t\t\t     sym->common_head->name,\n+\t\t\t\t     other->common_head->name);\n+\t\t\t    goto cleanup;\n+\t\t\t}\n+\t\t      other->attr.in_common = 1;\n+\t\t      other->common_head = t;\n+\t\t    }\n+\t\t}\n \t    }\n \n+\n \t  gfc_gobble_whitespace ();\n \t  if (gfc_match_eos () == MATCH_YES)\n \t    goto done;\n@@ -2553,7 +2592,10 @@ gfc_match_equivalence (void)\n {\n   gfc_equiv *eq, *set, *tail;\n   gfc_ref *ref;\n+  gfc_symbol *sym;\n   match m;\n+  gfc_common_head *common_head = NULL;\n+  bool common_flag;\n \n   tail = NULL;\n \n@@ -2570,10 +2612,11 @@ gfc_match_equivalence (void)\n \tgoto syntax;\n \n       set = eq;\n+      common_flag = FALSE;\n \n       for (;;)\n \t{\n-\t  m = gfc_match_variable (&set->expr, 1);\n+\t  m = gfc_match_equiv_variable (&set->expr);\n \t  if (m == MATCH_ERROR)\n \t    goto cleanup;\n \t  if (m == MATCH_NO)\n@@ -2588,6 +2631,14 @@ gfc_match_equivalence (void)\n \t\tgoto cleanup;\n \t      }\n \n+\t  if (set->expr->symtree->n.sym->attr.in_common)\n+\t    {\n+\t      common_flag = TRUE;\n+\t      common_head = set->expr->symtree->n.sym->common_head;\n+\t    }\n+\n+\t  set->expr->symtree->n.sym->attr.in_equivalence = 1;\n+\n \t  if (gfc_match_char (')') == MATCH_YES)\n \t    break;\n \t  if (gfc_match_char (',') != MATCH_YES)\n@@ -2597,6 +2648,26 @@ gfc_match_equivalence (void)\n \t  set = set->eq;\n \t}\n \n+      /* If one of the members of an equivalence is in common, then\n+\t mark them all as being in common.  Before doing this, check\n+\t that members of the equivalence group are not in different\n+\t common blocks. */\n+      if (common_flag)\n+\tfor (set = eq; set; set = set->eq)\n+\t  {\n+\t    sym = set->expr->symtree->n.sym;\n+\t    if (sym->common_head && sym->common_head != common_head)\n+\t      {\n+\t\tgfc_error (\"Attempt to indirectly overlap COMMON \"\n+\t\t\t   \"blocks %s and %s by EQUIVALENCE at %C\",\n+\t\t\t   sym->common_head->name,\n+\t\t\t   common_head->name);\n+\t\tgoto cleanup;\n+\t      }\n+\t    sym->attr.in_common = 1;\n+\t    sym->common_head = common_head;\n+\t  }\n+\n       if (gfc_match_eos () == MATCH_YES)\n \tbreak;\n       if (gfc_match_char (',') != MATCH_YES)"}, {"sha": "b11a16baff1a6792dabb38c0ca2508c18b078fe4", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 193, "deletions": 42, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=30aabb86ef4252ad2df0d3a56c364b824a2e5245", "patch": "@@ -47,6 +47,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    ( ( <common name> <symbol> <saved flag>)\n      ...\n    )\n+\n+   ( equivalence list )\n+\n    ( <Symbol Number (in no particular order)>\n      <True name of symbol>\n      <Module name of symbol>\n@@ -582,20 +585,34 @@ gfc_match_use (void)\n cleanup:\n   free_rename ();\n   return MATCH_ERROR;\n-}\n+ }\n \n \n-/* Given a name, return the name under which to load this symbol.\n-   Returns NULL if this symbol shouldn't be loaded.  */\n+/* Given a name and a number, inst, return the inst name\n+   under which to load this symbol. Returns NULL if this\n+   symbol shouldn't be loaded. If inst is zero, returns\n+   the number of instances of this name.  */\n \n static const char *\n-find_use_name (const char *name)\n+find_use_name_n (const char *name, int *inst)\n {\n   gfc_use_rename *u;\n+  int i;\n \n+  i = 0;\n   for (u = gfc_rename_list; u; u = u->next)\n-    if (strcmp (u->use_name, name) == 0)\n-      break;\n+    {\n+      if (strcmp (u->use_name, name) != 0)\n+\tcontinue;\n+      if (++i == *inst)\n+\tbreak;\n+    }\n+\n+  if (!*inst)\n+    {\n+      *inst = i;\n+      return NULL;\n+    }\n \n   if (u == NULL)\n     return only_flag ? NULL : name;\n@@ -605,6 +622,28 @@ find_use_name (const char *name)\n   return (u->local_name[0] != '\\0') ? u->local_name : name;\n }\n \n+/* Given a name, return the name under which to load this symbol.\n+   Returns NULL if this symbol shouldn't be loaded.  */\n+\n+static const char *\n+find_use_name (const char *name)\n+{\n+  int i = 1;\n+  return find_use_name_n (name, &i);\n+}\n+\n+/* Given a real name, return the number of use names associated\n+   with it.  */\n+\n+static int\n+number_use_names (const char *name)\n+{\n+  int i = 0;\n+  const char *c;\n+  c = find_use_name_n (name, &i);\n+  return i;\n+}\n+\n \n /* Try to find the operator in the current list.  */\n \n@@ -2920,6 +2959,48 @@ load_commons(void)\n   mio_rparen();\n }\n \n+/* load_equiv()-- Load equivalences. */\n+\n+static void\n+load_equiv(void)\n+{\n+  gfc_equiv *head, *tail, *end;\n+\n+  mio_lparen();\n+\n+  end = gfc_current_ns->equiv;\n+  while(end != NULL && end->next != NULL)\n+    end = end->next;\n+\n+  while(peek_atom() != ATOM_RPAREN) {\n+    mio_lparen();\n+    head = tail = NULL;\n+\n+    while(peek_atom() != ATOM_RPAREN)\n+      {\n+\tif (head == NULL)\n+\t  head = tail = gfc_get_equiv();\n+\telse\n+\t  {\n+\t    tail->eq = gfc_get_equiv();\n+\t    tail = tail->eq;\n+\t  }\n+\n+\tmio_pool_string(&tail->module);\n+\tmio_expr(&tail->expr);\n+      }\n+\n+    if (end == NULL)\n+      gfc_current_ns->equiv = head;\n+    else\n+      end->next = head;\n+\n+    end = head;\n+    mio_rparen();\n+  }\n+\n+  mio_rparen();\n+}\n \n /* Recursive function to traverse the pointer_info tree and load a\n    needed symbol.  We return nonzero if we load a symbol and stop the\n@@ -3020,7 +3101,7 @@ read_module (void)\n   const char *p;\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_intrinsic_op i;\n-  int ambiguous, symbol;\n+  int ambiguous, symbol, j, nuse;\n   pointer_info *info;\n   gfc_use_rename *u;\n   gfc_symtree *st;\n@@ -3032,6 +3113,9 @@ read_module (void)\n   get_module_locus (&user_operators);\n   skip_list ();\n   skip_list ();\n+\n+  /* Skip commons and equivalences for now.  */\n+  skip_list ();\n   skip_list ();\n \n   mio_lparen ();\n@@ -3084,50 +3168,60 @@ read_module (void)\n \n       info = get_integer (symbol);\n \n-      /* Get the local name for this symbol.  */\n-      p = find_use_name (name);\n-\n-      /* Skip symtree nodes not in an ONLY caluse.  */\n-      if (p == NULL)\n-\tcontinue;\n+      /* See how many use names there are.  If none, go through the start\n+\t of the loop at least once.  */\n+      nuse = number_use_names (name);\n+      if (nuse == 0)\n+\tnuse = 1;\n \n-      /* Check for ambiguous symbols.  */\n-      st = gfc_find_symtree (gfc_current_ns->sym_root, p);\n-\n-      if (st != NULL)\n-\t{\n-\t  if (st->n.sym != info->u.rsym.sym)\n-\t    st->ambiguous = 1;\n-          info->u.rsym.symtree = st;\n-\t}\n-      else\n+      for (j = 1; j <= nuse; j++)\n \t{\n-          /* Create a symtree node in the current namespace for this symbol.  */\n-\t  st = check_unique_name (p) ? get_unique_symtree (gfc_current_ns) :\n-\t    gfc_new_symtree (&gfc_current_ns->sym_root, p);\n+\t  /* Get the jth local name for this symbol.  */\n+\t  p = find_use_name_n (name, &j);\n \n-\t  st->ambiguous = ambiguous;\n+\t  /* Skip symtree nodes not in an ONLY clause.  */\n+\t  if (p == NULL)\n+\t    continue;\n \n-\t  sym = info->u.rsym.sym;\n+\t  /* Check for ambiguous symbols.  */\n+\t  st = gfc_find_symtree (gfc_current_ns->sym_root, p);\n \n-          /* Create a symbol node if it doesn't already exist.  */\n-\t  if (sym == NULL)\n+\t  if (st != NULL)\n \t    {\n-\t      sym = info->u.rsym.sym =\n-\t\tgfc_new_symbol (info->u.rsym.true_name, gfc_current_ns);\n-\n-\t      sym->module = gfc_get_string (info->u.rsym.module);\n+\t      if (st->n.sym != info->u.rsym.sym)\n+\t\tst->ambiguous = 1;\n+\t      info->u.rsym.symtree = st;\n \t    }\n+\t  else\n+\t    {\n+\t      /* Create a symtree node in the current namespace for this symbol.  */\n+\t      st = check_unique_name (p) ? get_unique_symtree (gfc_current_ns) :\n+\t      gfc_new_symtree (&gfc_current_ns->sym_root, p);\n+\n+\t      st->ambiguous = ambiguous;\n+\n+\t      sym = info->u.rsym.sym;\n+\n+\t      /* Create a symbol node if it doesn't already exist.  */\n+\t      if (sym == NULL)\n+\t\t{\n+\t\t  sym = info->u.rsym.sym =\n+\t\t      gfc_new_symbol (info->u.rsym.true_name\n+\t\t\t\t      , gfc_current_ns);\n \n-\t  st->n.sym = sym;\n-\t  st->n.sym->refs++;\n+\t\t  sym->module = gfc_get_string (info->u.rsym.module);\n+\t\t}\n+\n+\t      st->n.sym = sym;\n+\t      st->n.sym->refs++;\n \n-          /* Store the symtree pointing to this symbol.  */\n-          info->u.rsym.symtree = st;\n+\t      /* Store the symtree pointing to this symbol.  */\n+\t      info->u.rsym.symtree = st;\n \n-\t  if (info->u.rsym.state == UNUSED)\n-\t    info->u.rsym.state = NEEDED;\n-\t  info->u.rsym.referenced = 1;\n+\t      if (info->u.rsym.state == UNUSED)\n+\t        info->u.rsym.state = NEEDED;\n+\t      info->u.rsym.referenced = 1;\n+\t    }\n \t}\n     }\n \n@@ -3170,6 +3264,7 @@ read_module (void)\n   load_generic_interfaces ();\n \n   load_commons ();\n+  load_equiv();\n \n   /* At this point, we read those symbols that are needed but haven't\n      been loaded yet.  If one symbol requires another, the other gets\n@@ -3241,6 +3336,7 @@ static void\n write_common (gfc_symtree *st)\n {\n   gfc_common_head *p;\n+  const char * name;\n \n   if (st == NULL)\n     return;\n@@ -3249,7 +3345,11 @@ write_common (gfc_symtree *st)\n   write_common(st->right);\n \n   mio_lparen();\n-  mio_pool_string(&st->name);\n+\n+  /* Write the unmangled name.  */\n+  name = st->n.common->name;\n+\n+  mio_pool_string(&name);\n \n   p = st->n.common;\n   mio_symbol_ref(&p->head);\n@@ -3258,6 +3358,51 @@ write_common (gfc_symtree *st)\n   mio_rparen();\n }\n \n+/* Write the blank common block to the module */\n+\n+static void\n+write_blank_common (void)\n+{\n+  const char * name = BLANK_COMMON_NAME;\n+\n+  if (gfc_current_ns->blank_common.head == NULL)\n+    return;\n+\n+  mio_lparen();\n+\n+  mio_pool_string(&name);\n+\n+  mio_symbol_ref(&gfc_current_ns->blank_common.head);\n+  mio_integer(&gfc_current_ns->blank_common.saved);\n+\n+  mio_rparen();\n+}\n+\n+/* Write equivalences to the module.  */\n+\n+static void\n+write_equiv(void)\n+{\n+  gfc_equiv *eq, *e;\n+  int num;\n+\n+  num = 0;\n+  for(eq=gfc_current_ns->equiv; eq; eq=eq->next)\n+    {\n+      mio_lparen();\n+\n+      for(e=eq; e; e=e->eq)\n+\t{\n+\t  if (e->module == NULL)\n+\t    e->module = gfc_get_string(\"%s.eq.%d\", module_name, num);\n+\t  mio_allocated_string(e->module);\n+\t  mio_expr(&e->expr);\n+\t}\n+\n+      num++;\n+      mio_rparen();\n+    }\n+}\n \n /* Write a symbol to the module.  */\n \n@@ -3444,11 +3589,17 @@ write_module (void)\n   write_char ('\\n');\n \n   mio_lparen ();\n+  write_blank_common ();\n   write_common (gfc_current_ns->common_root);\n   mio_rparen ();\n   write_char ('\\n');\n   write_char ('\\n');\n \n+  mio_lparen();\n+  write_equiv();\n+  mio_rparen();\n+  write_char('\\n');  write_char('\\n');\n+\n   /* Write symbol information.  First we traverse all symbols in the\n      primary namespace, writing those that need to be written.\n      Sometimes writing one symbol will cause another to need to be"}, {"sha": "48a5f347d9c0cd271b5edd4e16ad43bbac25a111", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=30aabb86ef4252ad2df0d3a56c364b824a2e5245", "patch": "@@ -2173,18 +2173,23 @@ gfc_match_rvalue (gfc_expr ** result)\n    starts as a symbol, can be a structure component or an array\n    reference.  It can be a function if the function doesn't have a\n    separate RESULT variable.  If the symbol has not been previously\n-   seen, we assume it is a variable.  */\n+   seen, we assume it is a variable.\n \n-match\n-gfc_match_variable (gfc_expr ** result, int equiv_flag)\n+   This function is called by two interface functions:\n+   gfc_match_variable, which has host_flag = 1, and\n+   gfc_match_equiv_variable, with host_flag = 0, to restrict the\n+   match of the symbol to the local scope.  */\n+\n+static match\n+match_variable (gfc_expr ** result, int equiv_flag, int host_flag)\n {\n   gfc_symbol *sym;\n   gfc_symtree *st;\n   gfc_expr *expr;\n   locus where;\n   match m;\n \n-  m = gfc_match_sym_tree (&st, 1);\n+  m = gfc_match_sym_tree (&st, host_flag);\n   if (m != MATCH_YES)\n     return m;\n   where = gfc_current_locus;\n@@ -2258,3 +2263,16 @@ gfc_match_variable (gfc_expr ** result, int equiv_flag)\n   *result = expr;\n   return MATCH_YES;\n }\n+\n+match\n+gfc_match_variable (gfc_expr ** result, int equiv_flag)\n+{\n+  return match_variable (result, equiv_flag, 1);\n+}\n+\n+match\n+gfc_match_equiv_variable (gfc_expr ** result)\n+{\n+  return match_variable (result, 1, 0);\n+}\n+"}, {"sha": "039d86da662ca18ba9a1b0b7dc6b5471ea22aa32", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 51, "deletions": 36, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=30aabb86ef4252ad2df0d3a56c364b824a2e5245", "patch": "@@ -119,8 +119,6 @@ typedef struct segment_info\n static segment_info * current_segment;\n static gfc_namespace *gfc_common_ns = NULL;\n \n-#define BLANK_COMMON_NAME \"__BLNK__\"\n-\n /* Make a segment_info based on a symbol.  */\n \n static segment_info *\n@@ -665,46 +663,45 @@ add_condition (segment_info *f, gfc_equiv *eq1, gfc_equiv *eq2)\n \n \n /* Given a segment element, search through the equivalence lists for unused\n-   conditions that involve the symbol.  Add these rules to the segment.  Only\n-   checks for rules involving the first symbol in the equivalence set.  */\n- \n+   conditions that involve the symbol.  Add these rules to the segment.  */\n+\n static bool\n find_equivalence (segment_info *n)\n {\n-  gfc_equiv *e1, *e2, *eq, *other;\n+  gfc_equiv *e1, *e2, *eq;\n   bool found;\n- \n+\n   found = FALSE;\n+\n   for (e1 = n->sym->ns->equiv; e1; e1 = e1->next)\n     {\n-      other = NULL;\n-      for (e2 = e1->eq; e2; e2 = e2->eq)\n-\t{\n-\t  if (e2->used)\n-\t    continue;\n+      eq = NULL;\n \n-\t  if (e1->expr->symtree->n.sym == n->sym)\n-\t    {\n-\t      eq = e1;\n-\t      other = e2;\n-\t    }\n-\t  else if (e2->expr->symtree->n.sym == n->sym)\n+      /* Search the equivalence list, including the root (first) element\n+         for the symbol that owns the segment.  */\n+      for (e2 = e1; e2; e2 = e2->eq)\n+\t{\n+\t  if (!e2->used && e2->expr->symtree->n.sym == n->sym)\n \t    {\n \t      eq = e2;\n-\t      other = e1;\n+\t      break;\n \t    }\n-\t  else\n-\t    eq = NULL;\n-\t  \n-\t  if (eq)\n+\t}\n+\n+      /* Go to the next root element.  */\n+      if (eq == NULL)\n+\tcontinue;\n+\n+      eq->used = 1;\n+\n+      /* Now traverse the equivalence list matching the offsets.  */\n+      for (e2 = e1; e2; e2 = e2->eq)\n+\t{\n+\t  if (!e2->used && e2 != eq)\n \t    {\n-\t      add_condition (n, eq, other);\n-\t      eq->used = 1;\n+\t      add_condition (n, eq, e2);\n+\t      e2->used = 1;\n \t      found = TRUE;\n-\t      /* If this symbol is the first in the chain we may find other\n-\t\t matches. Otherwise we can skip to the next equivalence.  */\n-\t      if (eq == e2)\n-\t\tbreak;\n \t    }\n \t}\n     }\n@@ -813,12 +810,14 @@ translate_common (gfc_common_head *common, gfc_symbol *var_list)\n   /* Add symbols to the segment.  */\n   for (sym = var_list; sym; sym = sym->common_next)\n     {\n-      if (sym->equiv_built)\n-\t{\n-\t  /* Symbol has already been added via an equivalence.  */\n-\t  current_segment = common_segment;\n-\t  s = find_segment_info (sym);\n+      current_segment = common_segment;\n+      s = find_segment_info (sym);\n \n+      /* Symbol has already been added via an equivalence.  Multiple\n+\t use associations of the same common block result in equiv_built\n+\t being set but no information about the symbol in the segment.  */\n+      if (s && sym->equiv_built)\n+\t{\n \t  /* Ensure the current location is properly aligned.  */\n \t  align = TYPE_ALIGN_UNIT (s->field);\n \t  current_offset = (current_offset + align - 1) &~ (align - 1);\n@@ -893,6 +892,7 @@ finish_equivalences (gfc_namespace *ns)\n {\n   gfc_equiv *z, *y;\n   gfc_symbol *sym;\n+  gfc_common_head * c;\n   HOST_WIDE_INT offset;\n   unsigned HOST_WIDE_INT align;\n   bool dummy;\n@@ -916,8 +916,23 @@ finish_equivalences (gfc_namespace *ns)\n \n \tapply_segment_offset (current_segment, offset);\n \n-\t/* Create the decl.  */\n-        create_common (NULL, current_segment, true);\n+\t/* Create the decl. If this is a module equivalence, it has a unique\n+\t   name, pointed to by z->module. This is written to a gfc_common_header\n+\t   to push create_common into using build_common_decl, so that the\n+\t   equivalence appears as an external symbol. Otherwise, a local\n+\t   declaration is built using build_equiv_decl.*/\n+\tif (z->module)\n+\t  {\n+\t    c = gfc_get_common_head ();\n+\t    /* We've lost the real location, so use the location of the\n+\t     enclosing procedure.  */\n+\t    c->where = ns->proc_name->declared_at;\n+\t    strcpy (c->name, z->module);\n+\t  }\n+\telse\n+\t  c = NULL;\n+\n+        create_common (c, current_segment, true);\n         break;\n       }\n }"}, {"sha": "1b568407bd329d1cfb2325591d08a04af2f2b132", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=30aabb86ef4252ad2df0d3a56c364b824a2e5245", "patch": "@@ -2160,6 +2160,10 @@ gfc_create_module_variable (gfc_symbol * sym)\n   if (sym->attr.use_assoc || sym->attr.in_common)\n     return;\n \n+  /* Equivalenced variables arrive here after creation.  */\n+  if (sym->backend_decl && sym->equiv_built)\n+      return;\n+\n   if (sym->backend_decl)\n     internal_error (\"backend decl for module variable %s already exists\",\n \t\t    sym->name);\n@@ -2336,8 +2340,6 @@ gfc_generate_function_code (gfc_namespace * ns)\n \n   gfc_start_block (&block);\n \n-  gfc_generate_contained_functions (ns);\n-\n   if (ns->entries && ns->proc_name->ts.type == BT_CHARACTER)\n     {\n       /* Copy length backend_decls to all entry point result\n@@ -2354,6 +2356,8 @@ gfc_generate_function_code (gfc_namespace * ns)\n   /* Translate COMMON blocks.  */\n   gfc_trans_common (ns);\n \n+  gfc_generate_contained_functions (ns);\n+\n   generate_local_vars (ns);\n \n   current_function_return_label = NULL;"}, {"sha": "a9753daa32f2baec23aa3cb2d0dfd7373633a07d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=30aabb86ef4252ad2df0d3a56c364b824a2e5245", "patch": "@@ -1,3 +1,27 @@\n+2005-09-09  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/18878\n+\t* gfortran.dg/module_double_reuse.f90: New.\n+\n+2005-09-09  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/23270\n+\tPR fortran/22304\n+\tPR fortran/18870\n+\tPR fortran/17917\n+\tPR fortran/16511\n+\t* gfortran.dg/common_equivalence_1.f: New.\n+\t* gfortran.dg/common_equivalence_2.f: New.\n+\t* gfortran.dg/common_equivalence_3.f: New.\n+\t* gfortran.dg/contained_equivalence_1.f90: New.\n+\t* gfortran.dg/module_blank_common.f90: New. \n+\t* gfortran.dg/module_commons_1.f90: New.\n+\t* gfortran.dg/module_equivalence_1.f90: New.\n+\t* gfortran.dg/nested_modules_1.f90: New.\n+\t* gfortran.dg/g77/19990905-0.f: Remove XFAIL, rearrange\n+\tequivalences and add comment to connect the test with\n+\tthe PR.\n+\n 2005-09-08  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/23765"}, {"sha": "2f15b93a4ae83d45bdcdbde30da10f8d0567bf12", "filename": "gcc/testsuite/gfortran.dg/common_equivalence_1.f", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2Fgfortran.dg%2Fcommon_equivalence_1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2Fgfortran.dg%2Fcommon_equivalence_1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcommon_equivalence_1.f?ref=30aabb86ef4252ad2df0d3a56c364b824a2e5245", "patch": "@@ -0,0 +1,21 @@\n+c { dg-do run }\n+c This program tests the fix for PR22304.\n+c\n+c provided by Paul Thomas - pault@gcc.gnu.org\n+c\n+      integer a(2), b, c\n+      COMMON /foo/ a\n+      EQUIVALENCE (a(1),b), (c, a(2))\n+      a(1) = 101\n+      a(2) = 102\n+      call bar ()\n+      END\n+\n+      subroutine bar ()\n+      integer a(2), b, c, d\n+      COMMON /foo/ a\n+      EQUIVALENCE (a(1),b), (c, a(2))\n+      if (b.ne.101) call abort ()\n+      if (c.ne.102) call abort ()\n+      END\n+"}, {"sha": "be25fcd3d425c43817c1398030d6687d268b897a", "filename": "gcc/testsuite/gfortran.dg/common_equivalence_2.f", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2Fgfortran.dg%2Fcommon_equivalence_2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2Fgfortran.dg%2Fcommon_equivalence_2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcommon_equivalence_2.f?ref=30aabb86ef4252ad2df0d3a56c364b824a2e5245", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! PR fortran/18870\n+!\n+      program main\n+      common /foo/ a\n+      common /bar/ b\n+      equivalence (a,c)\n+      equivalence (b,c) ! { dg-error \"indirectly overlap COMMON\" }\n+      c=3.\n+      print *,a\n+      print *,b\n+      end\n+"}, {"sha": "6acd46aa3527572e52f6f9e36aaa76ed295a3aac", "filename": "gcc/testsuite/gfortran.dg/common_equivalence_3.f", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2Fgfortran.dg%2Fcommon_equivalence_3.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2Fgfortran.dg%2Fcommon_equivalence_3.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcommon_equivalence_3.f?ref=30aabb86ef4252ad2df0d3a56c364b824a2e5245", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+! PR fortran/18870\n+!\n+      program main\n+      equivalence (a,c)\n+      equivalence (b,c)\n+      common /foo/ a\n+      common /bar/ b ! { dg-error \"equivalenced to another COMMON\" }\n+      c=3.\n+      print *,a\n+      print *,b\n+      end\n+\n+"}, {"sha": "7c6b0126cdbfb0252f01cc205f7454f1be11120f", "filename": "gcc/testsuite/gfortran.dg/contained_equivalence_1.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontained_equivalence_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontained_equivalence_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontained_equivalence_1.f90?ref=30aabb86ef4252ad2df0d3a56c364b824a2e5245", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do run }\n+! This program tests that equivalence only associates variables in\n+! the same scope.\n+!\n+! provided by Paul Thomas - pault@gcc.gnu.org\n+!\n+program contained_equiv\n+  real a\n+  a = 1.0\n+  call foo ()\n+  if (a.ne.1.0) call abort ()\n+contains\n+  subroutine foo ()\n+    real b\n+    equivalence (a, b)\n+    b = 2.0\n+  end subroutine foo\n+end program contained_equiv"}, {"sha": "23bb48ab009330dec98e59298deb909f5f51a8ee", "filename": "gcc/testsuite/gfortran.dg/module_blank_common.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_blank_common.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_blank_common.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_blank_common.f90?ref=30aabb86ef4252ad2df0d3a56c364b824a2e5245", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do run }\n+!\n+! This tests that blank common works in modules. PR23270\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module global\n+  common a, b\n+  real    a, b\n+end module global\n+program blank_common\n+  use global\n+  common z\n+  complex z\n+  a = 999.0_4\n+  b = -999.0_4\n+  if (z.ne.cmplx (a,b)) call abort ()\n+end program blank_common\n+\n+"}, {"sha": "996074c0778784ec4e905b57f1a1fe801bb690e5", "filename": "gcc/testsuite/gfortran.dg/module_commons_1.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_commons_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_commons_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_commons_1.f90?ref=30aabb86ef4252ad2df0d3a56c364b824a2e5245", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do run }\n+! This program tests that use associated common blocks work.\n+!\n+! provided by Paul Thomas - pault@gcc.gnu.org\n+!\n+module m1\n+  common /x/ a\n+end module m1\n+module m2\n+  common /x/ a\n+end module m2\n+\n+subroutine foo ()\n+  use m2\n+  if (a.ne.99.0) call abort ()\n+end subroutine foo\n+\n+program collision\n+  use m1\n+  use m2, only: b=>a\n+  b = 99.0\n+  call foo ()\n+end program collision\n+"}, {"sha": "8c1b6ec6367625cc2ee93fca2e581306a39ccbbd", "filename": "gcc/testsuite/gfortran.dg/module_double_reuse.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_double_reuse.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_double_reuse.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_double_reuse.f90?ref=30aabb86ef4252ad2df0d3a56c364b824a2e5245", "patch": "@@ -0,0 +1,19 @@\n+! Test of fix for PR18878\n+!\n+! Based on example in PR by Steve Kargl\n+!\n+module a\n+  integer, parameter :: b = kind(1.d0)\n+  real(b)            :: z\n+end module a\n+program d\n+  use a, only : e => b, f => b, u => z, v => z\n+  real(e) x\n+  real(f) y\n+  x = 1.e0_e\n+  y = 1.e0_f\n+  u = 99.0\n+  if (kind(x).ne.kind(y)) call abort ()\n+  if (v.ne.u) call abort ()\n+end program d\n+"}, {"sha": "d8268ca722fecfbb54a1a6eb0e8aa21f4c69c8bf", "filename": "gcc/testsuite/gfortran.dg/module_equivalence_1.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_equivalence_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_equivalence_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_equivalence_1.f90?ref=30aabb86ef4252ad2df0d3a56c364b824a2e5245", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do run }\n+! This tests the fix for PR17917, where equivalences were not being\n+! written to and read back from modules.\n+!\n+! Contributed by Paul Thomas  pault@gcc.gnu.org\n+!\n+module test_equiv !Bug 17917\n+  common /my_common/ d\n+  real    a(2),b(4),c(4), d(8)\n+  equivalence (a(1),b(2)), (c(1),d(5))\n+end module test_equiv\n+\n+subroutine foo ()\n+  use test_equiv, z=>b\n+  if (any (d(5:8)/=z)) call abort ()\n+end subroutine foo\n+\n+program module_equiv\n+  use test_equiv\n+  b = 99.0_4\n+  a = 999.0_4\n+  c = (/99.0_4, 999.0_4, 999.0_4, 99.0_4/)\n+  call foo ()\n+end program module_equiv\n+\n+"}, {"sha": "d7ed4f346b4ef227b85468524739e80f88137209", "filename": "gcc/testsuite/gfortran.dg/nested_modules_1.f90", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30aabb86ef4252ad2df0d3a56c364b824a2e5245/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnested_modules_1.f90?ref=30aabb86ef4252ad2df0d3a56c364b824a2e5245", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do run }\n+!\n+! This tests that common blocks function with multiply nested modules.\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+       module mod0\n+         double complex FOO, KANGA\n+         common /bar/ FOO, KANGA\n+       contains\n+         subroutine eyeore ()    \n+           FOO = FOO + (1.0d0, 0.0d0)\n+           KANGA = KANGA - (1.0d0, 0.0d0)\n+         end subroutine eyeore\n+       end module mod0\n+       module mod1\n+         use mod0\n+         complex ROBIN\n+         common/owl/ROBIN\n+       end module mod1\n+       module mod2\n+         use mod0\n+         use mod1\n+         real*8 re1, im1, re2, im2, re, im\n+         common /bar/ re1, im1, re2, im2\n+         equivalence (re1, re), (im1, im)\n+       contains\n+         subroutine tigger (w)\n+           double complex w\n+           if (FOO.ne.(1.0d0, 1.0d0)) call abort ()\n+           if (KANGA.ne.(-1.0d0, -1.0d0)) call abort ()\n+           if (ROBIN.ne.(99.0d0, 99.0d0)) CALL abort ()\n+           if (w.ne.cmplx(re,im)) call abort ()\n+         end subroutine tigger\n+       end module mod2\n+\n+       use mod2\n+       use mod0, only: w=>foo\n+       FOO = (0.0d0, 1.0d0)\n+       KANGA = (0.0d0, -1.0d0)\n+       ROBIN = (99.0d0, 99.0d0)\n+       call eyeore ()\n+       call tigger (w)\n+       end"}]}