{"sha": "625ed1721782f6ec522c764e0119d1ad2214f624", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI1ZWQxNzIxNzgyZjZlYzUyMmM3NjRlMDExOWQxYWQyMjE0ZjYyNA==", "commit": {"author": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2012-06-21T12:18:23Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2012-06-21T12:18:23Z"}, "message": "re PR middle-end/53688 (191.fma3d in SPEC CPU 2000 miscompiled)\n\n\tPR middle-end/53688\n\t* builtins.c (get_memory_rtx): Always build an all-aliasing MEM_REF\n\twith correct size.\n\ntestsuite/\n\t* gcc.c-torture/execute/pr53688.c: New test.\n\nFrom-SVN: r188852", "tree": {"sha": "d911e332976285afd3b1d734436e05f199f03391", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d911e332976285afd3b1d734436e05f199f03391"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/625ed1721782f6ec522c764e0119d1ad2214f624", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/625ed1721782f6ec522c764e0119d1ad2214f624", "html_url": "https://github.com/Rust-GCC/gccrs/commit/625ed1721782f6ec522c764e0119d1ad2214f624", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/625ed1721782f6ec522c764e0119d1ad2214f624/comments", "author": null, "committer": null, "parents": [{"sha": "ccd49f5a69406c97af0ad1acc417144fbc9ec5c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccd49f5a69406c97af0ad1acc417144fbc9ec5c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccd49f5a69406c97af0ad1acc417144fbc9ec5c5"}], "stats": {"total": 180, "additions": 70, "deletions": 110}, "files": [{"sha": "ebe422d77659256a5cfc0dfb3cc62a8009237f8d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/625ed1721782f6ec522c764e0119d1ad2214f624/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/625ed1721782f6ec522c764e0119d1ad2214f624/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=625ed1721782f6ec522c764e0119d1ad2214f624", "patch": "@@ -1,3 +1,9 @@\n+2012-06-21  Michael Matz  <matz@suse.de>\n+\n+\tPR middle-end/53688\n+\t* builtins.c (get_memory_rtx): Always build an all-aliasing MEM_REF\n+\twith correct size.\n+\n 2012-06-21  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-inline.c (estimate_num_insns): Estimate call cost for"}, {"sha": "c12eb29aa02d561241ecfef3788da3e9dca4d4d7", "filename": "gcc/builtins.c", "status": "modified", "additions": 26, "deletions": 109, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/625ed1721782f6ec522c764e0119d1ad2214f624/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/625ed1721782f6ec522c764e0119d1ad2214f624/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=625ed1721782f6ec522c764e0119d1ad2214f624", "patch": "@@ -1252,7 +1252,6 @@ get_memory_rtx (tree exp, tree len)\n {\n   tree orig_exp = exp;\n   rtx addr, mem;\n-  HOST_WIDE_INT off;\n \n   /* When EXP is not resolved SAVE_EXPR, MEM_ATTRS can be still derived\n      from its expression, for expr->a.b only <variable>.a.b is recorded.  */\n@@ -1263,120 +1262,38 @@ get_memory_rtx (tree exp, tree len)\n   mem = gen_rtx_MEM (BLKmode, memory_address (BLKmode, addr));\n \n   /* Get an expression we can use to find the attributes to assign to MEM.\n-     If it is an ADDR_EXPR, use the operand.  Otherwise, dereference it if\n-     we can.  First remove any nops.  */\n+     First remove any nops.  */\n   while (CONVERT_EXPR_P (exp)\n \t && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (exp, 0))))\n     exp = TREE_OPERAND (exp, 0);\n \n-  off = 0;\n-  if (TREE_CODE (exp) == POINTER_PLUS_EXPR\n-      && TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n-      && host_integerp (TREE_OPERAND (exp, 1), 0)\n-      && (off = tree_low_cst (TREE_OPERAND (exp, 1), 0)) > 0)\n-    exp = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-  else if (TREE_CODE (exp) == ADDR_EXPR)\n-    exp = TREE_OPERAND (exp, 0);\n-  else if (POINTER_TYPE_P (TREE_TYPE (exp)))\n-    exp = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (exp)), exp);\n-  else\n-    exp = NULL;\n-\n-  /* Honor attributes derived from exp, except for the alias set\n-     (as builtin stringops may alias with anything) and the size\n-     (as stringops may access multiple array elements).  */\n-  if (exp)\n-    {\n+  /* Build a MEM_REF representing the whole accessed area as a byte blob,\n+     (as builtin stringops may alias with anything).  */\n+  exp = fold_build2 (MEM_REF,\n+\t\t     build_array_type (char_type_node,\n+\t\t\t\t       build_range_type (sizetype,\n+\t\t\t\t\t\t\t size_one_node, len)),\n+\t\t     exp, build_int_cst (ptr_type_node, 0));\n+\n+  /* If the MEM_REF has no acceptable address, try to get the base object\n+     from the original address we got, and build an all-aliasing\n+     unknown-sized access to that one.  */\n+  if (is_gimple_mem_ref_addr (TREE_OPERAND (exp, 0)))\n+    set_mem_attributes (mem, exp, 0);\n+  else if (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n+\t   && (exp = get_base_address (TREE_OPERAND (TREE_OPERAND (exp, 0),\n+\t\t\t\t\t\t     0))))\n+    {\n+      exp = build_fold_addr_expr (exp);\n+      exp = fold_build2 (MEM_REF,\n+\t\t\t build_array_type (char_type_node,\n+\t\t\t\t\t   build_range_type (sizetype,\n+\t\t\t\t\t\t\t     size_zero_node,\n+\t\t\t\t\t\t\t     NULL)),\n+\t\t\t exp, build_int_cst (ptr_type_node, 0));\n       set_mem_attributes (mem, exp, 0);\n-\n-      if (off)\n-\tmem = adjust_automodify_address_nv (mem, BLKmode, NULL, off);\n-\n-      /* Allow the string and memory builtins to overflow from one\n-\t field into another, see http://gcc.gnu.org/PR23561.\n-\t Thus avoid COMPONENT_REFs in MEM_EXPR unless we know the whole\n-\t memory accessed by the string or memory builtin will fit\n-\t within the field.  */\n-      if (MEM_EXPR (mem) && TREE_CODE (MEM_EXPR (mem)) == COMPONENT_REF)\n-\t{\n-\t  tree mem_expr = MEM_EXPR (mem);\n-\t  HOST_WIDE_INT offset = -1, length = -1;\n-\t  tree inner = exp;\n-\n-\t  while (TREE_CODE (inner) == ARRAY_REF\n-\t\t || CONVERT_EXPR_P (inner)\n-\t\t || TREE_CODE (inner) == VIEW_CONVERT_EXPR\n-\t\t || TREE_CODE (inner) == SAVE_EXPR)\n-\t    inner = TREE_OPERAND (inner, 0);\n-\n-\t  gcc_assert (TREE_CODE (inner) == COMPONENT_REF);\n-\n-\t  if (MEM_OFFSET_KNOWN_P (mem))\n-\t    offset = MEM_OFFSET (mem);\n-\n-\t  if (offset >= 0 && len && host_integerp (len, 0))\n-\t    length = tree_low_cst (len, 0);\n-\n-\t  while (TREE_CODE (inner) == COMPONENT_REF)\n-\t    {\n-\t      tree field = TREE_OPERAND (inner, 1);\n-\t      gcc_assert (TREE_CODE (mem_expr) == COMPONENT_REF);\n-\t      gcc_assert (field == TREE_OPERAND (mem_expr, 1));\n-\n-\t      /* Bitfields are generally not byte-addressable.  */\n-\t      gcc_assert (!DECL_BIT_FIELD (field)\n-\t\t\t  || ((tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)\n-\t\t\t       % BITS_PER_UNIT) == 0\n-\t\t\t      && host_integerp (DECL_SIZE (field), 0)\n-\t\t\t      && (TREE_INT_CST_LOW (DECL_SIZE (field))\n-\t\t\t\t  % BITS_PER_UNIT) == 0));\n-\n-\t      /* If we can prove that the memory starting at XEXP (mem, 0) and\n-\t\t ending at XEXP (mem, 0) + LENGTH will fit into this field, we\n-\t\t can keep the COMPONENT_REF in MEM_EXPR.  But be careful with\n-\t\t fields without DECL_SIZE_UNIT like flexible array members.  */\n-\t      if (length >= 0\n-\t\t  && DECL_SIZE_UNIT (field)\n-\t\t  && host_integerp (DECL_SIZE_UNIT (field), 0))\n-\t\t{\n-\t\t  HOST_WIDE_INT size\n-\t\t    = TREE_INT_CST_LOW (DECL_SIZE_UNIT (field));\n-\t\t  if (offset <= size\n-\t\t      && length <= size\n-\t\t      && offset + length <= size)\n-\t\t    break;\n-\t\t}\n-\n-\t      if (offset >= 0\n-\t\t  && host_integerp (DECL_FIELD_OFFSET (field), 0))\n-\t\toffset += TREE_INT_CST_LOW (DECL_FIELD_OFFSET (field))\n-\t\t\t  + tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)\n-\t\t\t    / BITS_PER_UNIT;\n-\t      else\n-\t\t{\n-\t\t  offset = -1;\n-\t\t  length = -1;\n-\t\t}\n-\n-\t      mem_expr = TREE_OPERAND (mem_expr, 0);\n-\t      inner = TREE_OPERAND (inner, 0);\n-\t    }\n-\n-\t  if (mem_expr == NULL)\n-\t    offset = -1;\n-\t  if (mem_expr != MEM_EXPR (mem))\n-\t    {\n-\t      set_mem_expr (mem, mem_expr);\n-\t      if (offset >= 0)\n-\t\tset_mem_offset (mem, offset);\n-\t      else\n-\t\tclear_mem_offset (mem);\n-\t    }\n-\t}\n-      set_mem_alias_set (mem, 0);\n-      clear_mem_size (mem);\n     }\n-\n+  set_mem_alias_set (mem, 0);\n   return mem;\n }\n \f"}, {"sha": "a16c702ef1b3f7c2263460634692b36e81f4eff9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/625ed1721782f6ec522c764e0119d1ad2214f624/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/625ed1721782f6ec522c764e0119d1ad2214f624/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=625ed1721782f6ec522c764e0119d1ad2214f624", "patch": "@@ -1,3 +1,8 @@\n+2012-06-21  Michael Matz  <matz@suse.de>\n+\n+\tPR middle-end/53688\n+\t* gcc.c-torture/execute/pr53688.c: New test.\n+\n 2012-06-20  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/30318\n@@ -24,7 +29,7 @@\n \n 2012-06-16 Ville Voutilainen <ville.voutilainen@gmail.com>\n \n-        * g++.dg/cpp0x/override4.C: New.\n+\t* g++.dg/cpp0x/override4.C: New.\n \n 2012-06-14  Jason Merrill  <jason@redhat.com>\n "}, {"sha": "c7ed4d78b04c1369f19c6564d1d311eaeef1c3df", "filename": "gcc/testsuite/gcc.c-torture/execute/pr53688.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/625ed1721782f6ec522c764e0119d1ad2214f624/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr53688.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/625ed1721782f6ec522c764e0119d1ad2214f624/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr53688.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr53688.c?ref=625ed1721782f6ec522c764e0119d1ad2214f624", "patch": "@@ -0,0 +1,32 @@\n+char headline[256];\n+struct hdr {\n+  char part1[9];\n+  char part2[8];\n+} p;\n+\n+void __attribute__((noinline,noclone))\n+init()\n+{\n+  __builtin_memcpy (p.part1, \"FOOBARFOO\", sizeof (p.part1));\n+  __builtin_memcpy (p.part2, \"SPEC CPU\", sizeof (p.part2));\n+}\n+\n+int main()\n+{\n+  char *x;\n+  int c;\n+  init();\n+  __builtin_memcpy (&headline[0], p.part1, 9);\n+  c = 9;\n+  x = &headline[0];\n+  x = x + c;\n+  __builtin_memset (x, ' ', 245);\n+  __builtin_memcpy (&headline[10], p.part2, 8);\n+  c = 18;\n+  x = &headline[0];\n+  x = x + c;\n+  __builtin_memset (x, ' ', 238);\n+  if (headline[10] != 'S')\n+    __builtin_abort ();\n+  return 0;\n+}"}]}