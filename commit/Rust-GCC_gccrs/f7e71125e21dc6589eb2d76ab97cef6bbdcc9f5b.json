{"sha": "f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdlNzExMjVlMjFkYzY1ODllYjJkNzZhYjk3Y2VmNmJiZGNjOWY1Yg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-28T09:25:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-28T09:25:52Z"}, "message": "[multiple changes]\n\n2009-07-28  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj.adb, prj.ads (Compute_All_Imported_Projects): Make sure the\n\timporting project does not end up in the list, in the case of extending\n\tprojects.\n\t* make.adb, makeutl.adb, makeutl.ads (File_Not_A_Source_Of): Moved to\n\tmakeutl.ads, for better sharing with gprbuild.\n\n2009-07-28  Arnaud Charlet  <charlet@adacore.com>\n\n\t* gnat_ugn.texi: Fix typo.\n\n2009-07-28  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Build_Derived_Concurrent_Type): Handle properly a\n\tderivation that renames some discriminants and constrain others.\n\t* exp_ch9.adb (Build_Protected_Subprogram_Call): If the type of the\n\tprefix is a derived untagged type, convert to the root type to conform\n\tto the signature of the protected operations.\n\n2009-07-28  Robert Dewar  <dewar@adacore.com>\n\n\t* sinfo.ads: Update comments.\n\t* exp_attr.adb: Minor reformatting\n\nFrom-SVN: r150152", "tree": {"sha": "409d0b1b799c65c6daebf6bc8a4193dc7ff5485e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/409d0b1b799c65c6daebf6bc8a4193dc7ff5485e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/comments", "author": null, "committer": null, "parents": [{"sha": "55603e5ee2c71c189a5677071f967f50d6f2e2c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55603e5ee2c71c189a5677071f967f50d6f2e2c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55603e5ee2c71c189a5677071f967f50d6f2e2c8"}], "stats": {"total": 503, "additions": 344, "deletions": 159}, "files": [{"sha": "69c8fee93f4e453b5ec7ffaec8972c296e7558af", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b", "patch": "@@ -1,3 +1,28 @@\n+2009-07-28  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj.adb, prj.ads (Compute_All_Imported_Projects): Make sure the\n+\timporting project does not end up in the list, in the case of extending\n+\tprojects.\n+\t* make.adb, makeutl.adb, makeutl.ads (File_Not_A_Source_Of): Moved to\n+\tmakeutl.ads, for better sharing with gprbuild.\n+\n+2009-07-28  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gnat_ugn.texi: Fix typo.\n+\n+2009-07-28  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Build_Derived_Concurrent_Type): Handle properly a\n+\tderivation that renames some discriminants and constrain others.\n+\t* exp_ch9.adb (Build_Protected_Subprogram_Call): If the type of the\n+\tprefix is a derived untagged type, convert to the root type to conform\n+\tto the signature of the protected operations.\n+\n+2009-07-28  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sinfo.ads: Update comments.\n+\t* exp_attr.adb: Minor reformatting\n+\n 2009-07-28  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_aggr.adb (Get_Value): A named association in a record aggregate"}, {"sha": "d5cce9b43ee2541961ea797387d7c3a028064f88", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b", "patch": "@@ -358,7 +358,7 @@ package body Exp_Attr is\n \n       Sub_Ref :=\n         Make_Attribute_Reference (Loc,\n-          Prefix => Sub,\n+          Prefix         => Sub,\n           Attribute_Name => Name_Access);\n \n       --  We set the type of the access reference to the already generated\n@@ -370,17 +370,13 @@ package body Exp_Attr is\n \n       Agg :=\n         Make_Aggregate (Loc,\n-          Expressions =>\n-            New_List (\n-              Obj_Ref, Sub_Ref));\n+          Expressions => New_List (Obj_Ref, Sub_Ref));\n \n       Rewrite (N, Agg);\n-\n       Analyze_And_Resolve (N, E_T);\n \n-      --  For subsequent analysis,  the node must retain its type.\n-      --  The backend will replace it with the equivalent type where\n-      --  needed.\n+      --  For subsequent analysis, the node must retain its type. The backend\n+      --  will replace it with the equivalent type where needed.\n \n       Set_Etype (N, Typ);\n    end Expand_Access_To_Protected_Op;"}, {"sha": "3a7fa25065d679c8708a92e4b42b1c4ac8b6d5bd", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b", "patch": "@@ -3193,6 +3193,18 @@ package body Exp_Ch9 is\n          Params := New_List;\n       end if;\n \n+      --  If the type is an untagged derived type, convert to the root type,\n+      --  which is the one on which the operations are defined.\n+\n+      if Nkind (Rec) = N_Unchecked_Type_Conversion\n+        and then not Is_Tagged_Type (Etype (Rec))\n+        and then Is_Derived_Type (Etype (Rec))\n+      then\n+         Set_Etype (Rec, Root_Type (Etype (Rec)));\n+         Set_Subtype_Mark (Rec,\n+           New_Occurrence_Of (Root_Type (Etype (Rec)), Sloc (N)));\n+      end if;\n+\n       Prepend (Rec, Params);\n \n       if Ekind (Sub) = E_Procedure then\n@@ -4358,8 +4370,8 @@ package body Exp_Ch9 is\n          return N;\n       else\n          return\n-           Unchecked_Convert_To (Corresponding_Record_Type (Typ),\n-             New_Copy_Tree (N));\n+           Unchecked_Convert_To\n+             (Corresponding_Record_Type (Typ), New_Copy_Tree (N));\n       end if;\n    end Convert_Concurrent;\n "}, {"sha": "3e1a8640375dadbcedc883db2ca81cc2ace74ce5", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b", "patch": "@@ -557,25 +557,6 @@ package body Make is\n    procedure List_Bad_Compilations;\n    --  Prints out the list of all files for which the compilation failed\n \n-   procedure Verbose_Msg\n-     (N1                : Name_Id;\n-      S1                : String;\n-      N2                : Name_Id := No_Name;\n-      S2                : String  := \"\";\n-      Prefix            : String  := \"  -> \";\n-      Minimum_Verbosity : Verbosity_Level_Type := Opt.Low);\n-   procedure Verbose_Msg\n-     (N1                : File_Name_Type;\n-      S1                : String;\n-      N2                : File_Name_Type := No_File;\n-      S2                : String  := \"\";\n-      Prefix            : String  := \"  -> \";\n-      Minimum_Verbosity : Verbosity_Level_Type := Opt.Low);\n-   --  If the verbose flag (Verbose_Mode) is set and the verbosity level is\n-   --  at least equal to Minimum_Verbosity, then print Prefix to standard\n-   --  output followed by N1 and S1. If N2 /= No_Name then N2 is printed after\n-   --  S1. S2 is printed last. Both N1 and N2 are printed in quotation marks.\n-\n    Usage_Needed : Boolean := True;\n    --  Flag used to make sure Makeusg is call at most once\n \n@@ -1434,10 +1415,6 @@ package body Make is\n       O_File         : out File_Name_Type;\n       O_Stamp        : out Time_Stamp_Type)\n    is\n-      function File_Not_A_Source_Of\n-        (Uname : Name_Id;\n-         Sfile : File_Name_Type) return Boolean;\n-\n       function First_New_Spec (A : ALI_Id) return File_Name_Type;\n       --  Looks in the with table entries of A and returns the spec file name\n       --  of the first withed unit (subprogram) for which no spec existed when\n@@ -1452,34 +1429,6 @@ package body Make is\n       --  services, but this causes the whole compiler to be dragged along\n       --  for gnatbind and gnatmake.\n \n-      --------------------------\n-      -- File_Not_A_Source_Of --\n-      --------------------------\n-\n-      function File_Not_A_Source_Of\n-        (Uname : Name_Id;\n-         Sfile : File_Name_Type) return Boolean\n-      is\n-         UID    : Prj.Unit_Index;\n-\n-      begin\n-         UID := Units_Htable.Get (Project_Tree.Units_HT, Uname);\n-\n-         if UID /= Prj.No_Unit_Index then\n-            if (UID.File_Names (Impl) = null\n-                 or else UID.File_Names (Impl).File /= Sfile)\n-              and then\n-                (UID.File_Names (Spec) = null\n-                  or else UID.File_Names (Spec).File /= Sfile)\n-            then\n-               Verbose_Msg (Uname, \"sources do not include \", Name_Id (Sfile));\n-               return True;\n-            end if;\n-         end if;\n-\n-         return False;\n-      end File_Not_A_Source_Of;\n-\n       --------------------\n       -- First_New_Spec --\n       --------------------\n@@ -8240,52 +8189,6 @@ package body Make is\n       end if;\n    end Usage;\n \n-   -----------------\n-   -- Verbose_Msg --\n-   -----------------\n-\n-   procedure Verbose_Msg\n-     (N1                : Name_Id;\n-      S1                : String;\n-      N2                : Name_Id := No_Name;\n-      S2                : String  := \"\";\n-      Prefix            : String := \"  -> \";\n-      Minimum_Verbosity : Verbosity_Level_Type := Opt.Low)\n-   is\n-   begin\n-      if (not Verbose_Mode) or else (Minimum_Verbosity > Verbosity_Level) then\n-         return;\n-      end if;\n-\n-      Write_Str (Prefix);\n-      Write_Str (\"\"\"\");\n-      Write_Name (N1);\n-      Write_Str (\"\"\" \");\n-      Write_Str (S1);\n-\n-      if N2 /= No_Name then\n-         Write_Str (\" \"\"\");\n-         Write_Name (N2);\n-         Write_Str (\"\"\" \");\n-      end if;\n-\n-      Write_Str (S2);\n-      Write_Eol;\n-   end Verbose_Msg;\n-\n-   procedure Verbose_Msg\n-     (N1                : File_Name_Type;\n-      S1                : String;\n-      N2                : File_Name_Type := No_File;\n-      S2                : String  := \"\";\n-      Prefix            : String := \"  -> \";\n-      Minimum_Verbosity : Verbosity_Level_Type := Opt.Low)\n-   is\n-   begin\n-      Verbose_Msg\n-        (Name_Id (N1), S1, Name_Id (N2), S2, Prefix, Minimum_Verbosity);\n-   end Verbose_Msg;\n-\n begin\n    --  Make sure that in case of failure, the temp files will be deleted\n "}, {"sha": "af5e7d6d8dd45d7d35e38263b6600e32af49b869", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b", "patch": "@@ -26,6 +26,7 @@\n with Debug;\n with Osint;    use Osint;\n with Output;   use Output;\n+with Opt;      use Opt;\n with Prj.Ext;\n with Prj.Util;\n with Snames;   use Snames;\n@@ -264,6 +265,47 @@ package body Makeutl is\n       end;\n    end Executable_Prefix_Path;\n \n+   --------------------------\n+   -- File_Not_A_Source_Of --\n+   --------------------------\n+\n+   function File_Not_A_Source_Of\n+     (Uname : Name_Id;\n+      Sfile : File_Name_Type) return Boolean\n+   is\n+      Unit : constant Unit_Index :=\n+               Units_Htable.Get (Project_Tree.Units_HT, Uname);\n+\n+      At_Least_One_File : Boolean := False;\n+\n+   begin\n+      if Unit /= No_Unit_Index then\n+         for F in Unit.File_Names'Range loop\n+            if Unit.File_Names (F) /= null then\n+               At_Least_One_File := True;\n+               if Unit.File_Names (F).File = Sfile then\n+                  return False;\n+               end if;\n+            end if;\n+         end loop;\n+\n+         if not At_Least_One_File then\n+\n+            --  The unit was probably created initially for a separate unit\n+            --  (which are initially created as IMPL when both suffixes are the\n+            --  same). Later on, Override_Kind changed the type of the file,\n+            --  and the unit is no longer valid in fact.\n+\n+            return False;\n+         end if;\n+\n+         Verbose_Msg (Uname, \"sources do not include \", Name_Id (Sfile));\n+         return True;\n+      end if;\n+\n+      return False;\n+   end File_Not_A_Source_Of;\n+\n    ----------\n    -- Hash --\n    ----------\n@@ -749,4 +791,52 @@ package body Makeutl is\n       return Result;\n    end Unit_Index_Of;\n \n+   -----------------\n+   -- Verbose_Msg --\n+   -----------------\n+\n+   procedure Verbose_Msg\n+     (N1                : Name_Id;\n+      S1                : String;\n+      N2                : Name_Id := No_Name;\n+      S2                : String  := \"\";\n+      Prefix            : String := \"  -> \";\n+      Minimum_Verbosity : Opt.Verbosity_Level_Type := Opt.Low)\n+   is\n+   begin\n+      if not Opt.Verbose_Mode\n+        or else Minimum_Verbosity > Opt.Verbosity_Level\n+      then\n+         return;\n+      end if;\n+\n+      Write_Str (Prefix);\n+      Write_Str (\"\"\"\");\n+      Write_Name (N1);\n+      Write_Str (\"\"\" \");\n+      Write_Str (S1);\n+\n+      if N2 /= No_Name then\n+         Write_Str (\" \"\"\");\n+         Write_Name (N2);\n+         Write_Str (\"\"\" \");\n+      end if;\n+\n+      Write_Str (S2);\n+      Write_Eol;\n+   end Verbose_Msg;\n+\n+   procedure Verbose_Msg\n+     (N1                : File_Name_Type;\n+      S1                : String;\n+      N2                : File_Name_Type := No_File;\n+      S2                : String  := \"\";\n+      Prefix            : String := \"  -> \";\n+      Minimum_Verbosity : Opt.Verbosity_Level_Type := Opt.Low)\n+   is\n+   begin\n+      Verbose_Msg\n+        (Name_Id (N1), S1, Name_Id (N2), S2, Prefix, Minimum_Verbosity);\n+   end Verbose_Msg;\n+\n end Makeutl;"}, {"sha": "e33369f4bd34386052043cda3b2b78e42e074d12", "filename": "gcc/ada/makeutl.ads", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2Fmakeutl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2Fmakeutl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.ads?ref=f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b", "patch": "@@ -24,6 +24,7 @@\n ------------------------------------------------------------------------------\n \n with Namet; use Namet;\n+with Opt;\n with Osint;\n with Prj;   use Prj;\n with Types; use Types;\n@@ -69,6 +70,13 @@ package Makeutl is\n    procedure Inform (N : File_Name_Type; Msg : String);\n    --  Prints out the program name followed by a colon, N and S\n \n+   function File_Not_A_Source_Of\n+     (Uname : Name_Id;\n+      Sfile : File_Name_Type) return Boolean;\n+   --  Check that file name Sfile is one of the source of unit Uname.\n+   --  Returns True if the unit is in one of the project file, but the file\n+   --  name is not one of its source. Returns False otherwise.\n+\n    function Is_External_Assignment (Argv : String) return Boolean;\n    --  Verify that an external assignment switch is syntactically correct\n    --\n@@ -82,6 +90,25 @@ package Makeutl is\n    --  been entered by a call to Prj.Ext.Add, so that in a project\n    --  file, External (\"name\") will return \"value\".\n \n+   procedure Verbose_Msg\n+     (N1                : Name_Id;\n+      S1                : String;\n+      N2                : Name_Id := No_Name;\n+      S2                : String  := \"\";\n+      Prefix            : String  := \"  -> \";\n+      Minimum_Verbosity : Opt.Verbosity_Level_Type := Opt.Low);\n+   procedure Verbose_Msg\n+     (N1                : File_Name_Type;\n+      S1                : String;\n+      N2                : File_Name_Type := No_File;\n+      S2                : String  := \"\";\n+      Prefix            : String  := \"  -> \";\n+      Minimum_Verbosity : Opt.Verbosity_Level_Type := Opt.Low);\n+   --  If the verbose flag (Verbose_Mode) is set and the verbosity level is\n+   --  at least equal to Minimum_Verbosity, then print Prefix to standard\n+   --  output followed by N1 and S1. If N2 /= No_Name then N2 is printed after\n+   --  S1. S2 is printed last. Both N1 and N2 are printed in quotation marks.\n+\n    function Linker_Options_Switches\n      (Project  : Project_Id;\n       In_Tree  : Project_Tree_Ref) return String_List;"}, {"sha": "0f4e05052103e7b058f5149c18aea2b6f0777aaf", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b", "patch": "@@ -1069,8 +1069,8 @@ package body Prj is\n       begin\n          --  A project is not importing itself\n \n-         if Project /= Prj then\n-            Prj2 := Ultimate_Extending_Project_Of (Prj);\n+         Prj2 := Ultimate_Extending_Project_Of (Prj);\n+         if Project /= Prj2 then\n \n             --  Check that the project is not already in the list. We know the\n             --  one passed to Recursive_Add have never been visited before, but"}, {"sha": "8f95c08b59ff8dffa0b9ef7e4634f0a0a65a3ad1", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b", "patch": "@@ -1061,7 +1061,8 @@ package Prj is\n       --  The list of all directly imported projects, if any\n \n       All_Imported_Projects : Project_List;\n-      --  The list of all projects imported directly or indirectly, if any\n+      --  The list of all projects imported directly or indirectly, if any.\n+      --  This does not include the project itself.\n \n       -----------------\n       -- Directories --"}, {"sha": "5696a1c64bb200cfc02c2dcb5cda2fea7d4d55b8", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 170, "deletions": 40, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b", "patch": "@@ -4826,17 +4826,72 @@ package body Sem_Ch3 is\n       Parent_Type  : Entity_Id;\n       Derived_Type : Entity_Id)\n    is\n-      D_Constraint : Node_Id;\n-      Disc_Spec    : Node_Id;\n-      Old_Disc     : Entity_Id;\n-      New_Disc     : Entity_Id;\n-\n-      Constraint_Present : constant Boolean :=\n-                             Nkind (Subtype_Indication (Type_Definition (N)))\n-                                                     = N_Subtype_Indication;\n+      Loc              : constant Source_Ptr := Sloc (N);\n+\n+      Corr_Record      : constant Entity_Id\n+              := Make_Defining_Identifier (Loc, New_Internal_Name ('C'));\n+      Corr_Decl        : Node_Id;\n+      Corr_Decl_Needed : Boolean;\n+      --  If the derived type has fewer discriminants than its parent,\n+      --  the corresponding record is also a derived type, in order to\n+      --  account for the bound discriminants. We create a full type\n+      --  declaration for it in this case.\n+\n+      Constraint_Present : constant Boolean\n+        := Nkind (Subtype_Indication (Type_Definition (N)))\n+            = N_Subtype_Indication;\n+\n+      D_Constraint   : Node_Id;\n+      New_Constraint : Elist_Id;\n+      Old_Disc       : Entity_Id;\n+      New_Disc       : Entity_Id;\n+      New_N          : Node_Id;\n \n    begin\n       Set_Stored_Constraint (Derived_Type, No_Elist);\n+      Corr_Decl_Needed := False;\n+      Old_Disc := Empty;\n+\n+      if Present (Discriminant_Specifications (N))\n+        and then Constraint_Present\n+      then\n+         Old_Disc := First_Discriminant (Parent_Type);\n+         New_Disc := First (Discriminant_Specifications (N));\n+         while Present (New_Disc) and then Present (Old_Disc) loop\n+            Next_Discriminant (Old_Disc);\n+            Next (New_Disc);\n+         end loop;\n+      end if;\n+\n+      if Present (Old_Disc) then\n+\n+         --  The new type has fewer discriminants, so we need to create a new\n+         --  corresponding record, which is derived from the corresponding\n+         --  record of the parent, and has a stored constraint that\n+         --  captures the values of the discriminant constraints.\n+         --  The type declaration for the derived corresponding record has\n+         --  the same discriminant part and constraints as the current\n+         --  declaration. Copy the unanalyzed tree to build declaration.\n+\n+         Corr_Decl_Needed := True;\n+         New_N := Copy_Separate_Tree (N);\n+\n+         Corr_Decl :=\n+           Make_Full_Type_Declaration (Loc,\n+             Defining_Identifier => Corr_Record,\n+             Discriminant_Specifications =>\n+                Discriminant_Specifications (New_N),\n+             Type_Definition =>\n+               Make_Derived_Type_Definition (Loc,\n+                 Subtype_Indication =>\n+                   Make_Subtype_Indication (Loc,\n+                     Subtype_Mark =>\n+                        New_Occurrence_Of\n+                          (Corresponding_Record_Type (Parent_Type), Loc),\n+                     Constraint =>\n+                       Constraint\n+                         (Subtype_Indication (Type_Definition (New_N))))));\n+      end if;\n \n       --  Copy Storage_Size and Relative_Deadline variables if task case\n \n@@ -4850,6 +4905,16 @@ package body Sem_Ch3 is\n       if Present (Discriminant_Specifications (N)) then\n          Push_Scope (Derived_Type);\n          Check_Or_Process_Discriminants (N, Derived_Type);\n+\n+         if Constraint_Present then\n+            New_Constraint :=\n+              Expand_To_Stored_Constraint\n+                (Parent_Type,\n+                 Build_Discriminant_Constraints\n+                   (Parent_Type,\n+                    Subtype_Indication (Type_Definition (N)), True));\n+         end if;\n+\n          End_Scope;\n \n       elsif Constraint_Present then\n@@ -4880,9 +4945,9 @@ package body Sem_Ch3 is\n          end;\n       end if;\n \n-      --  All attributes are inherited from parent. In particular,\n-      --  entries and the corresponding record type are the same.\n-      --  Discriminants may be renamed, and must be treated separately.\n+      --  By default, operations and private data are inherited from parent.\n+      --  However, in the presence of bound discriminants, a new corresponding\n+      --  record will be created, see below.\n \n       Set_Has_Discriminants\n         (Derived_Type, Has_Discriminants         (Parent_Type));\n@@ -4910,44 +4975,99 @@ package body Sem_Ch3 is\n                 (Constraints\n                   (Constraint (Subtype_Indication (Type_Definition (N)))));\n \n-            Old_Disc  := First_Discriminant (Parent_Type);\n-            New_Disc  := First_Discriminant (Derived_Type);\n-            Disc_Spec := First (Discriminant_Specifications (N));\n-            while Present (Old_Disc) and then Present (Disc_Spec) loop\n-               if Nkind (Discriminant_Type (Disc_Spec)) /=\n-                                              N_Access_Definition\n-               then\n-                  Analyze (Discriminant_Type (Disc_Spec));\n+            Old_Disc := First_Discriminant (Parent_Type);\n \n-                  if not Subtypes_Statically_Compatible (\n-                             Etype (Discriminant_Type (Disc_Spec)),\n-                               Etype (Old_Disc))\n-                  then\n-                     Error_Msg_N\n-                       (\"not statically compatible with parent discriminant\",\n-                        Discriminant_Type (Disc_Spec));\n+            while Present (D_Constraint) loop\n+               if Nkind (D_Constraint) /= N_Discriminant_Association then\n+\n+                  --  Positional constraint. If it is a reference to a\n+                  --  new discriminant, it constrains the corresponding\n+                  --  old one.\n+\n+                  if Nkind (D_Constraint) = N_Identifier then\n+                     New_Disc := First_Discriminant (Derived_Type);\n+                     while Present (New_Disc) loop\n+                        exit when\n+                          Chars (New_Disc) = Chars (D_Constraint);\n+                        Next_Discriminant (New_Disc);\n+                     end loop;\n+\n+                     if Present (New_Disc) then\n+                        Set_Corresponding_Discriminant (New_Disc, Old_Disc);\n+                     end if;\n+                  end if;\n+\n+                  Next_Discriminant (Old_Disc);\n+\n+                  --  if this is a named constraint, search by name for the\n+                  --  old discriminants constrained by the new one.\n+\n+               elsif Nkind (Expression (D_Constraint)) = N_Identifier then\n+\n+                  --  Find new discriminant with that name.\n+\n+                  New_Disc := First_Discriminant (Derived_Type);\n+                  while Present (New_Disc) loop\n+                     exit when\n+                       Chars (New_Disc) = Chars (Expression (D_Constraint));\n+                     Next_Discriminant (New_Disc);\n+                  end loop;\n+\n+                  if Present (New_Disc) then\n+\n+                     --  Verify that the new discriminant renames\n+                     --  some discriminant of the parent type, and\n+                     --  associate the new discriminant with an old\n+                     --  one that it renames (may be more than one).\n+\n+                     declare\n+                        Selector : Node_Id;\n+\n+                     begin\n+                        Selector := First (Selector_Names (D_Constraint));\n+\n+                        while Present (Selector) loop\n+                           Old_Disc := First_Discriminant (Parent_Type);\n+\n+                           while Present (Old_Disc) loop\n+                              exit when Chars (Old_Disc) = Chars (Selector);\n+                              Next_Discriminant (Old_Disc);\n+                           end loop;\n+\n+                           if Present (Old_Disc) then\n+                              Set_Corresponding_Discriminant\n+                                (New_Disc, Old_Disc);\n+\n+                           end if;\n+\n+                           Next (Selector);\n+                        end loop;\n+                     end;\n                   end if;\n                end if;\n \n-               if Nkind (D_Constraint) = N_Identifier\n-                 and then Chars (D_Constraint) /=\n-                          Chars (Defining_Identifier (Disc_Spec))\n+               Next (D_Constraint);\n+            end loop;\n+\n+            New_Disc  := First_Discriminant (Derived_Type);\n+            while Present (New_Disc) loop\n+               if No (Corresponding_Discriminant (New_Disc)) then\n+                  Error_Msg_NE\n+                    (\"new discriminant& must constraint old one\",\n+                     N, New_Disc);\n+               elsif not\n+                 Subtypes_Statically_Compatible (\n+                   Etype (New_Disc),\n+                     Etype (Corresponding_Discriminant (New_Disc)))\n                then\n-                  Error_Msg_N (\"new discriminants must constrain old ones\",\n-                    D_Constraint);\n-               else\n-                  Set_Corresponding_Discriminant (New_Disc, Old_Disc);\n+                  Error_Msg_NE\n+                    (\"& not statically compatible with parent discriminant\",\n+                      N, New_Disc);\n+\n                end if;\n \n-               Next_Discriminant (Old_Disc);\n                Next_Discriminant (New_Disc);\n-               Next (Disc_Spec);\n             end loop;\n-\n-            if Present (Old_Disc) or else Present (Disc_Spec) then\n-               Error_Msg_N (\"discriminant mismatch in derivation\", N);\n-            end if;\n-\n          end if;\n \n       elsif Present (Discriminant_Specifications (N)) then\n@@ -4956,6 +5076,9 @@ package body Sem_Ch3 is\n             N);\n       end if;\n \n+      --  The entity chain of the derived type includes the new\n+      --  discriminants but shares operations with the parent.\n+\n       if Present (Discriminant_Specifications (N)) then\n          Old_Disc := First_Discriminant (Parent_Type);\n          while Present (Old_Disc) loop\n@@ -4983,6 +5106,13 @@ package body Sem_Ch3 is\n       Set_Last_Entity  (Derived_Type, Last_Entity  (Parent_Type));\n \n       Set_Has_Completion (Derived_Type);\n+\n+      if Corr_Decl_Needed then\n+         Set_Stored_Constraint (Derived_Type, New_Constraint);\n+         Insert_After (N, Corr_Decl);\n+         Analyze (Corr_Decl);\n+         Set_Corresponding_Record_Type (Derived_Type, Corr_Record);\n+      end if;\n    end Build_Derived_Concurrent_Type;\n \n    ------------------------------------"}, {"sha": "b598b771de36676231b8e4bebb1cc6e42fb174b4", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=f7e71125e21dc6589eb2d76ab97cef6bbdcc9f5b", "patch": "@@ -6850,15 +6850,16 @@ package Sinfo is\n       --  SCIL Nodes --\n       -----------------\n \n-      --  SCIL nodes are special nodes added to the tree when the CodePeer mode\n-      --  is active. They help CodePeer backend to locate nodes that require\n-      --  special processing.\n-\n-      --  Where is the detailed description of what these nodes are for??? The\n-      --  above is not sufficient. The description should be here, or perhaps\n-      --  it could be in a new Sem_SCIL unit, with a pointer from here. But\n-      --  right now I am afraid this documentation is missing and the purpose\n-      --  of these nodes remains secret???\n+      --  SCIL nodes are special nodes added to the tree when the CodePeer\n+      --  mode is active. They help the CodePeer backend to locate nodes that\n+      --  require special processing.\n+\n+      --  Major documentation on the general design of the SCIL interface, and\n+      --  in particular detailed description of these nodes is missing and is\n+      --  to be supplied in the future, when the design has finalized ???\n+\n+      --  Meanwhile these nodes should be considered in experimental form, and\n+      --  should be ignored by all code generating back ends. ???\n \n       --  N_SCIL_Dispatch_Table_Object_Init\n       --  Sloc references a declaration node containing a dispatch table"}]}