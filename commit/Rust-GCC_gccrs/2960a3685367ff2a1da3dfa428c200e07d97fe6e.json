{"sha": "2960a3685367ff2a1da3dfa428c200e07d97fe6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk2MGEzNjg1MzY3ZmYyYTFkYTNkZmE0MjhjMjAwZTA3ZDk3ZmU2ZQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2012-08-24T07:43:23Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-08-24T07:43:23Z"}, "message": "re PR fortran/54350 (FAIL: gfortran.dg/realloc_on_assign_*.f90  -O  (internal compiler error) at r190586)\n\n2012-08-24  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/54350\n        * trans-array.c (free_ss_info): Free data.array.subscript.\n        (gfc_free_ss): No longer free data.array.subscript.\n        (walk_coarray): New function, moved from trans-intrinsic.c\n        (gfc_conv_expr_descriptor): Walk array descriptor instead\n        of taking passed \"ss\".\n        (get_array_ctor_all_strlen, gfc_add_loop_ss_code,\n        gfc_conv_array_parameter): Update call and cleanup ss handling.\n        * trans-array.h (gfc_conv_expr_descriptor,\n        gfc_conv_array_parameter): Update prototype.\n        * trans-expr.c (gfc_conv_derived_to_class,\n        conv_isocbinding_procedure, gfc_conv_procedure_call,\n        gfc_trans_alloc_subarray_assign, gfc_trans_subcomponent_assign,\n        gfc_trans_pointer_assignment, gfc_trans_arrayfunc_assign): Update\n        call to gfc_conv_expr_descriptor and gfc_conv_array_parameter,\n        and clean up.\n        * trans-intrinsic.c (walk_coarray): Moved to trans-array.c\n        (trans_this_image, trans_image_index, gfc_conv_intrinsic_rank\n        gfc_conv_intrinsic_bound, gfc_conv_intrinsic_cobound,\n        gfc_conv_intrinsic_len, gfc_conv_intrinsic_size,\n        gfc_conv_intrinsic_sizeof, gfc_conv_intrinsic_storage_size,\n        gfc_conv_intrinsic_transfer, gfc_conv_allocated,\n        gfc_conv_associated, gfc_conv_intrinsic_loc,\n        conv_intrinsic_move_alloc): Update calls.\n        * trans-io.c (gfc_convert_array_to_string, set_internal_unit,\n        gfc_trans_transfer): Ditto.\n        * trans-stmt.c (gfc_conv_elemental_dependencies,\n        gfc_trans_sync, trans_associate_var,\n        gfc_trans_pointer_assign_need_temp): Ditto.\n\nFrom-SVN: r190641", "tree": {"sha": "bb525b29f9b4369506c97032008d05c66b3c238a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb525b29f9b4369506c97032008d05c66b3c238a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2960a3685367ff2a1da3dfa428c200e07d97fe6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2960a3685367ff2a1da3dfa428c200e07d97fe6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2960a3685367ff2a1da3dfa428c200e07d97fe6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2960a3685367ff2a1da3dfa428c200e07d97fe6e/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3c5e0cc46e87e09af8363562699d716ae231a6b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c5e0cc46e87e09af8363562699d716ae231a6b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c5e0cc46e87e09af8363562699d716ae231a6b1"}], "stats": {"total": 442, "additions": 213, "deletions": 229}, "files": [{"sha": "e8b4b4168bd9f7702a86023730feb8426697f9f5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2960a3685367ff2a1da3dfa428c200e07d97fe6e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2960a3685367ff2a1da3dfa428c200e07d97fe6e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2960a3685367ff2a1da3dfa428c200e07d97fe6e", "patch": "@@ -1,3 +1,35 @@\n+2012-08-23  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/54350\n+\t* trans-array.c (free_ss_info): Free data.array.subscript.\n+\t(gfc_free_ss): No longer free data.array.subscript.\n+\t(walk_coarray): New function, moved from trans-intrinsic.c\n+\t(gfc_conv_expr_descriptor): Walk array descriptor instead\n+\tof taking passed \"ss\".\n+\t(get_array_ctor_all_strlen, gfc_add_loop_ss_code,\n+\tgfc_conv_array_parameter): Update call and cleanup ss handling.\n+\t* trans-array.h (gfc_conv_expr_descriptor,\n+\tgfc_conv_array_parameter): Update prototype.\n+\t* trans-expr.c (gfc_conv_derived_to_class,\n+\tconv_isocbinding_procedure, gfc_conv_procedure_call,\n+\tgfc_trans_alloc_subarray_assign, gfc_trans_subcomponent_assign,\n+\tgfc_trans_pointer_assignment, gfc_trans_arrayfunc_assign): Update\n+\tcall to gfc_conv_expr_descriptor and gfc_conv_array_parameter, and\n+\tclean up.\n+\t* trans-intrinsic.c (walk_coarray): Moved to trans-array.c\n+\t(trans_this_image, trans_image_index, gfc_conv_intrinsic_rank\n+\tgfc_conv_intrinsic_bound, gfc_conv_intrinsic_cobound,\n+\tgfc_conv_intrinsic_len, gfc_conv_intrinsic_size,\n+\tgfc_conv_intrinsic_sizeof, gfc_conv_intrinsic_storage_size,\n+\tgfc_conv_intrinsic_transfer, gfc_conv_allocated,\n+\tgfc_conv_associated, gfc_conv_intrinsic_loc,\n+\tconv_intrinsic_move_alloc): Update calls.\n+\t* trans-io.c (gfc_convert_array_to_string, set_internal_unit,\n+\tgfc_trans_transfer): Ditto.\n+\t* trans-stmt.c (gfc_conv_elemental_dependencies,\n+\tgfc_trans_sync, trans_associate_var,\n+\tgfc_trans_pointer_assign_need_temp): Ditto.\n+\n 2012-08-23  Jakub Jelinek  <jakub@redhat.com>\n \n \t* trans-decl.c (trans_function_start, generate_coarray_init,"}, {"sha": "c350c3b5e3abde81b7e5501ffd270037d4f08c53", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 82, "deletions": 45, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2960a3685367ff2a1da3dfa428c200e07d97fe6e/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2960a3685367ff2a1da3dfa428c200e07d97fe6e/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=2960a3685367ff2a1da3dfa428c200e07d97fe6e", "patch": "@@ -510,40 +510,36 @@ gfc_free_ss_chain (gfc_ss * ss)\n static void\n free_ss_info (gfc_ss_info *ss_info)\n {\n+  int n;\n+\n   ss_info->refcount--;\n   if (ss_info->refcount > 0)\n     return;\n \n   gcc_assert (ss_info->refcount == 0);\n-  free (ss_info);\n-}\n-\n-\n-/* Free a SS.  */\n-\n-void\n-gfc_free_ss (gfc_ss * ss)\n-{\n-  gfc_ss_info *ss_info;\n-  int n;\n-\n-  ss_info = ss->info;\n \n   switch (ss_info->type)\n     {\n     case GFC_SS_SECTION:\n-      for (n = 0; n < ss->dimen; n++)\n-\t{\n-\t  if (ss_info->data.array.subscript[ss->dim[n]])\n-\t    gfc_free_ss_chain (ss_info->data.array.subscript[ss->dim[n]]);\n-\t}\n+      for (n = 0; n < GFC_MAX_DIMENSIONS; n++)\n+\tif (ss_info->data.array.subscript[n])\n+\t  gfc_free_ss_chain (ss_info->data.array.subscript[n]);\n       break;\n \n     default:\n       break;\n     }\n \n-  free_ss_info (ss_info);\n+  free (ss_info);\n+}\n+\n+\n+/* Free a SS.  */\n+\n+void\n+gfc_free_ss (gfc_ss * ss)\n+{\n+  free_ss_info (ss->info);\n   free (ss);\n }\n \n@@ -1805,7 +1801,6 @@ static void\n get_array_ctor_all_strlen (stmtblock_t *block, gfc_expr *e, tree *len)\n {\n   gfc_se se;\n-  gfc_ss *ss;\n \n   /* Don't bother if we already know the length is a constant.  */\n   if (*len && INTEGER_CST_P (*len))\n@@ -1821,15 +1816,14 @@ get_array_ctor_all_strlen (stmtblock_t *block, gfc_expr *e, tree *len)\n   else\n     {\n       /* Otherwise, be brutal even if inefficient.  */\n-      ss = gfc_walk_expr (e);\n       gfc_init_se (&se, NULL);\n \n       /* No function call, in case of side effects.  */\n       se.no_function_call = 1;\n-      if (ss == gfc_ss_terminator)\n+      if (e->rank == 0)\n \tgfc_conv_expr (&se, e);\n       else\n-\tgfc_conv_expr_descriptor (&se, e, ss);\n+\tgfc_conv_expr_descriptor (&se, e);\n \n       /* Fix the value.  */\n       *len = gfc_evaluate_now (se.string_length, &se.pre);\n@@ -2527,7 +2521,7 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \tcase GFC_SS_VECTOR:\n \t  /* Get the vector's descriptor and store it in SS.  */\n \t  gfc_init_se (&se, NULL);\n-\t  gfc_conv_expr_descriptor (&se, expr, gfc_walk_expr (expr));\n+\t  gfc_conv_expr_descriptor (&se, expr);\n \t  gfc_add_block_to_block (&outer_loop->pre, &se.pre);\n \t  gfc_add_block_to_block (&outer_loop->post, &se.post);\n \t  info->descriptor = se.expr;\n@@ -6328,6 +6322,44 @@ transposed_dims (gfc_ss *ss)\n   return false;\n }\n \n+\n+/* Convert the last ref of a scalar coarray from an AR_ELEMENT to an\n+   AR_FULL, suitable for the scalarizer.  */\n+\n+static gfc_ss *\n+walk_coarray (gfc_expr *e)\n+{\n+  gfc_ss *ss;\n+\n+  gcc_assert (gfc_get_corank (e) > 0);\n+\n+  ss = gfc_walk_expr (e);\n+\n+  /* Fix scalar coarray.  */\n+  if (ss == gfc_ss_terminator)\n+    {\n+      gfc_ref *ref;\n+\n+      ref = e->ref;\n+      while (ref)\n+\t{\n+\t  if (ref->type == REF_ARRAY\n+\t      && ref->u.ar.codimen > 0)\n+\t    break;\n+\n+\t  ref = ref->next;\n+\t}\n+\n+      gcc_assert (ref != NULL);\n+      if (ref->u.ar.type == AR_ELEMENT)\n+\tref->u.ar.type = AR_SECTION;\n+      ss = gfc_reverse_ss (gfc_walk_array_ref (ss, e, ref));\n+    }\n+\n+  return ss;\n+}\n+\n+\n /* Convert an array for passing as an actual argument.  Expressions and\n    vector subscripts are evaluated and stored in a temporary, which is then\n    passed.  For whole arrays the descriptor is passed.  For array sections\n@@ -6358,8 +6390,9 @@ transposed_dims (gfc_ss *ss)\n    function call.  */\n \n void\n-gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n+gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n {\n+  gfc_ss *ss;\n   gfc_ss_type ss_type;\n   gfc_ss_info *ss_info;\n   gfc_loopinfo loop;\n@@ -6375,13 +6408,28 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n   bool subref_array_target = false;\n   gfc_expr *arg, *ss_expr;\n \n+  if (se->want_coarray)\n+    ss = walk_coarray (expr);\n+  else\n+    ss = gfc_walk_expr (expr);\n+\n   gcc_assert (ss != NULL);\n   gcc_assert (ss != gfc_ss_terminator);\n \n   ss_info = ss->info;\n   ss_type = ss_info->type;\n   ss_expr = ss_info->expr;\n \n+  /* Special case: TRANSPOSE which needs no temporary.  */\n+  while (expr->expr_type == EXPR_FUNCTION && expr->value.function.isym\n+      && NULL != (arg = gfc_get_noncopying_intrinsic_argument (expr)))\n+    {\n+      /* This is a call to transpose which has already been handled by the\n+\t scalarizer, so that we just need to get its argument's descriptor.  */\n+      gcc_assert (expr->value.function.isym->id == GFC_ISYM_TRANSPOSE);\n+      expr = expr->value.function.actual->expr;\n+    }\n+\n   /* Special case things we know we can pass easily.  */\n   switch (expr->expr_type)\n     {\n@@ -6411,7 +6459,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  /* Create a new descriptor if the array doesn't have one.  */\n \t  full = 0;\n \t}\n-      else if (info->ref->u.ar.type == AR_FULL)\n+      else if (info->ref->u.ar.type == AR_FULL || se->descriptor_only)\n \tfull = 1;\n       else if (se->direct_byref)\n \tfull = 0;\n@@ -6443,24 +6491,12 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  if (expr->ts.type == BT_CHARACTER)\n \t    se->string_length = gfc_get_expr_charlen (expr);\n \n+\t  gfc_free_ss_chain (ss);\n \t  return;\n \t}\n       break;\n       \n     case EXPR_FUNCTION:\n-\n-      /* We don't need to copy data in some cases.  */\n-      arg = gfc_get_noncopying_intrinsic_argument (expr);\n-      if (arg)\n-\t{\n-\t  /* This is a call to transpose...  */\n-\t  gcc_assert (expr->value.function.isym->id == GFC_ISYM_TRANSPOSE);\n-\t  /* ... which has already been handled by the scalarizer, so\n-\t     that we just need to get its argument's descriptor.  */\n-\t  gfc_conv_expr_descriptor (se, expr->value.function.actual->expr, ss);\n-\t  return;\n-\t}\n-\n       /* A transformational function return value will be a temporary\n \t array descriptor.  We still need to go through the scalarizer\n \t to create the descriptor.  Elemental functions are handled as\n@@ -6477,6 +6513,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t    gcc_assert (se->ss == ss);\n \t  se->expr = gfc_build_addr_expr (NULL_TREE, se->expr);\n \t  gfc_conv_expr (se, expr);\n+\t  gfc_free_ss_chain (ss);\n \t  return;\n \t}\n \n@@ -6896,7 +6933,7 @@ array_parameter_size (tree desc, gfc_expr *expr, tree *size)\n /* TODO: Optimize passing g77 arrays.  */\n \n void\n-gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n+gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,\n \t\t\t  const gfc_symbol *fsym, const char *proc_name,\n \t\t\t  tree *size)\n {\n@@ -6967,7 +7004,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n \n       if (sym->ts.type == BT_DERIVED || sym->ts.type == BT_CLASS)\n \t{\n-\t  gfc_conv_expr_descriptor (se, expr, ss);\n+\t  gfc_conv_expr_descriptor (se, expr);\n \t  se->expr = gfc_conv_array_data (se->expr);\n \t  return;\n \t}\n@@ -6993,7 +7030,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n         {\n \t  if (sym->attr.dummy || sym->attr.result)\n \t    {\n-\t      gfc_conv_expr_descriptor (se, expr, ss);\n+\t      gfc_conv_expr_descriptor (se, expr);\n \t      tmp = se->expr;\n \t    }\n \t  if (size)\n@@ -7037,7 +7074,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n \n   if (no_pack || array_constructor || good_allocatable || ultimate_alloc_comp)\n     {\n-      gfc_conv_expr_descriptor (se, expr, ss);\n+      gfc_conv_expr_descriptor (se, expr);\n       if (expr->ts.type == BT_CHARACTER)\n \tse->string_length = expr->ts.u.cl->backend_decl;\n       if (size)\n@@ -7049,7 +7086,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n   if (this_array_result)\n     {\n       /* Result of the enclosing function.  */\n-      gfc_conv_expr_descriptor (se, expr, ss);\n+      gfc_conv_expr_descriptor (se, expr);\n       if (size)\n \tarray_parameter_size (se->expr, expr, size);\n       se->expr = gfc_build_addr_expr (NULL_TREE, se->expr);\n@@ -7065,7 +7102,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n     {\n       /* Every other type of array.  */\n       se->want_pointer = 1;\n-      gfc_conv_expr_descriptor (se, expr, ss);\n+      gfc_conv_expr_descriptor (se, expr);\n       if (size)\n \tarray_parameter_size (build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\t       se->expr),"}, {"sha": "de0320202610e4b4f70e83e0a8f56b40666a9f4f", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2960a3685367ff2a1da3dfa428c200e07d97fe6e/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2960a3685367ff2a1da3dfa428c200e07d97fe6e/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=2960a3685367ff2a1da3dfa428c200e07d97fe6e", "patch": "@@ -131,9 +131,9 @@ void gfc_conv_tmp_array_ref (gfc_se * se);\n void gfc_conv_tmp_ref (gfc_se *);\n \n /* Evaluate an array expression.  */\n-void gfc_conv_expr_descriptor (gfc_se *, gfc_expr *, gfc_ss *);\n+void gfc_conv_expr_descriptor (gfc_se *, gfc_expr *);\n /* Convert an array for passing as an actual function parameter.  */\n-void gfc_conv_array_parameter (gfc_se *, gfc_expr *, gfc_ss *, bool,\n+void gfc_conv_array_parameter (gfc_se *, gfc_expr *, bool,\n \t\t\t       const gfc_symbol *, const char *, tree *);\n /* Evaluate and transpose a matrix expression.  */\n void gfc_conv_array_transpose (gfc_se *, gfc_expr *);"}, {"sha": "ebaa2386055caddde1fb13ead3cf702d8d73f5ec", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2960a3685367ff2a1da3dfa428c200e07d97fe6e/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2960a3685367ff2a1da3dfa428c200e07d97fe6e/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=2960a3685367ff2a1da3dfa428c200e07d97fe6e", "patch": "@@ -304,7 +304,7 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n       else\n \t{\n \t  parmse->ss = ss;\n-\t  gfc_conv_expr_descriptor (parmse, e, ss);\n+\t  gfc_conv_expr_descriptor (parmse, e);\n \n \t  if (e->rank != class_ts.u.derived->components->as->rank)\n \t    class_array_data_assign (&parmse->pre, ctree, parmse->expr, true);\n@@ -533,8 +533,8 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems)\n       loop.to[0] = nelems;\n       gfc_trans_scalarizing_loops (&loop, &loopbody);\n       gfc_add_block_to_block (&body, &loop.pre);\n-      gfc_cleanup_loop (&loop);\n       tmp = gfc_finish_block (&body);\n+      gfc_cleanup_loop (&loop);\n     }\n   else\n     {\n@@ -3385,8 +3385,7 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n \t\t\t    gfc_actual_arglist * arg)\n {\n   gfc_symbol *fsym;\n-  gfc_ss *argss;\n-    \n+\n   if (sym->intmod_sym_id == ISOCBINDING_LOC)\n     {\n       if (arg->expr->rank == 0)\n@@ -3404,9 +3403,7 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n \t    && fsym->as->type != AS_ASSUMED_SHAPE;\n \t  f = f || !sym->attr.always_explicit;\n       \n-\t  argss = gfc_walk_expr (arg->expr);\n-\t  gfc_conv_array_parameter (se, arg->expr, argss, f,\n-\t\t\t\t    NULL, NULL, NULL);\n+\t  gfc_conv_array_parameter (se, arg->expr, f, NULL, NULL, NULL);\n \t}\n \n       /* TODO -- the following two lines shouldn't be necessary, but if\n@@ -3434,7 +3431,7 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n       gfc_se cptrse;\n       gfc_se fptrse;\n       gfc_se shapese;\n-      gfc_ss *ss, *shape_ss;\n+      gfc_ss *shape_ss;\n       tree desc, dim, tmp, stride, offset;\n       stmtblock_t body, block;\n       gfc_loopinfo loop;\n@@ -3469,10 +3466,8 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n       gfc_start_block (&block);\n \n       /* Get the descriptor of the Fortran pointer.  */\n-      ss = gfc_walk_expr (arg->next->expr);\n-      gcc_assert (ss != gfc_ss_terminator);\n       fptrse.descriptor_only = 1;\n-      gfc_conv_expr_descriptor (&fptrse, arg->next->expr, ss);\n+      gfc_conv_expr_descriptor (&fptrse, arg->next->expr);\n       gfc_add_block_to_block (&block, &fptrse.pre);\n       desc = fptrse.expr;\n \n@@ -3534,7 +3529,6 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n       gfc_add_block_to_block (&block, &loop.post);\n       gfc_add_block_to_block (&block, &fptrse.post);\n       gfc_cleanup_loop (&loop);\n-      gfc_free_ss (ss);\n \n       gfc_add_modify (&block, offset, \n \t\t      fold_build1_loc (input_location, NEGATE_EXPR,\n@@ -3615,7 +3609,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   tree tmp;\n   tree fntype;\n   gfc_se parmse;\n-  gfc_ss *argss;\n   gfc_array_info *info;\n   int byref;\n   int parm_kind;\n@@ -3818,11 +3811,20 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t}\n       else\n \t{\n-\t  /* A scalar or transformational function.  */\n-\t  gfc_init_se (&parmse, NULL);\n+\t  bool scalar;\n+\t  gfc_ss *argss;\n+\n+\t  /* Check whether the expression is a scalar or not; we cannot use\n+\t     e->rank as it can be nonzero for functions arguments.  */\n \t  argss = gfc_walk_expr (e);\n+\t  scalar = argss == gfc_ss_terminator;\n+\t  if (!scalar)\n+\t    gfc_free_ss_chain (argss);\n \n-\t  if (argss == gfc_ss_terminator)\n+\t  /* A scalar or transformational function.  */\n+\t  gfc_init_se (&parmse, NULL);\n+          \n+\t  if (scalar)\n \t    {\n \t      if (e->expr_type == EXPR_VARIABLE\n \t\t    && e->symtree->n.sym->attr.cray_pointee\n@@ -3977,7 +3979,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t    {\n \t      /* Pass a class array.  */\n \t      gfc_init_se (&parmse, se);\n-\t      gfc_conv_expr_descriptor (&parmse, e, argss);\n+\t      gfc_conv_expr_descriptor (&parmse, e);\n \t      /* The conversion does not repackage the reference to a class\n \t         array - _data descriptor.  */\n \t      gfc_conv_class_to_class (&parmse, e, fsym->ts, false);\n@@ -4060,8 +4062,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\tfsym ? fsym->attr.intent : INTENT_INOUT,\n \t\t\t\tfsym && fsym->attr.pointer);\n \t      else\n-\t        gfc_conv_array_parameter (&parmse, e, argss, f, fsym,\n-\t\t\t\t\t  sym->name, NULL);\n+\t        gfc_conv_array_parameter (&parmse, e, f, fsym, sym->name, NULL);\n \n \t      /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is \n \t\t allocated on entry, it must be deallocated.  */\n@@ -5355,7 +5356,6 @@ gfc_trans_alloc_subarray_assign (tree dest, gfc_component * cm,\n \t\t\t\t gfc_expr * expr)\n {\n   gfc_se se;\n-  gfc_ss *rss;\n   stmtblock_t block;\n   tree offset;\n   int n;\n@@ -5368,9 +5368,8 @@ gfc_trans_alloc_subarray_assign (tree dest, gfc_component * cm,\n   gfc_init_se (&se, NULL);\n \n   /* Get the descriptor for the expressions.  */ \n-  rss = gfc_walk_expr (expr);\n   se.want_pointer = 0;\n-  gfc_conv_expr_descriptor (&se, expr, rss);\n+  gfc_conv_expr_descriptor (&se, expr);\n   gfc_add_block_to_block (&block, &se.pre);\n   gfc_add_modify (&block, dest, se.expr);\n \n@@ -5501,7 +5500,6 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n {\n   gfc_se se;\n   gfc_se lse;\n-  gfc_ss *rss;\n   stmtblock_t block;\n   tree tmp;\n \n@@ -5518,10 +5516,9 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n \t    gfc_conv_descriptor_data_set (&block, dest, null_pointer_node);\n \t  else\n \t    {\n-\t      rss = gfc_walk_expr (expr);\n \t      se.direct_byref = 1;\n \t      se.expr = dest;\n-\t      gfc_conv_expr_descriptor (&se, expr, rss);\n+\t      gfc_conv_expr_descriptor (&se, expr);\n \t      gfc_add_block_to_block (&block, &se.pre);\n \t      gfc_add_block_to_block (&block, &se.post);\n \t    }\n@@ -5966,25 +5963,29 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n {\n   gfc_se lse;\n   gfc_se rse;\n-  gfc_ss *lss;\n-  gfc_ss *rss;\n   stmtblock_t block;\n   tree desc;\n   tree tmp;\n   tree decl;\n+  bool scalar;\n+  gfc_ss *ss;\n \n   gfc_start_block (&block);\n \n   gfc_init_se (&lse, NULL);\n \n-  lss = gfc_walk_expr (expr1);\n-  rss = gfc_walk_expr (expr2);\n-  if (lss == gfc_ss_terminator)\n+  /* Check whether the expression is a scalar or not; we cannot use\n+     expr1->rank as it can be nonzero for proc pointers.  */\n+  ss = gfc_walk_expr (expr1);\n+  scalar = ss == gfc_ss_terminator;\n+  if (!scalar)\n+    gfc_free_ss_chain (ss);\n+ \n+  if (scalar)\n     {\n       /* Scalar pointers.  */\n       lse.want_pointer = 1;\n       gfc_conv_expr (&lse, expr1);\n-      gcc_assert (rss == gfc_ss_terminator);\n       gfc_init_se (&rse, NULL);\n       rse.want_pointer = 1;\n       gfc_conv_expr (&rse, expr2);\n@@ -6048,13 +6049,12 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n       for (remap = expr1->ref; remap; remap = remap->next)\n \tif (!remap->next && remap->type == REF_ARRAY\n \t    && remap->u.ar.type == AR_SECTION)\n-\t  {  \n-\t    remap->u.ar.type = AR_FULL;\n-\t    break;\n-\t  }\n+\t  break;\n       rank_remap = (remap && remap->u.ar.end[0]);\n \n-      gfc_conv_expr_descriptor (&lse, expr1, lss);\n+      if (remap)\n+\tlse.descriptor_only = 1;\n+      gfc_conv_expr_descriptor (&lse, expr1);\n       strlen_lhs = lse.string_length;\n       desc = lse.expr;\n \n@@ -6070,14 +6070,14 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t  gfc_init_se (&rse, NULL);\n \t  rse.direct_byref = 1;\n \t  rse.byref_noassign = 1;\n-\t  gfc_conv_expr_descriptor (&rse, expr2, rss);\n+\t  gfc_conv_expr_descriptor (&rse, expr2);\n \t  strlen_rhs = rse.string_length;\n \t}\n       else if (expr2->expr_type == EXPR_VARIABLE)\n \t{\n \t  /* Assign directly to the LHS's descriptor.  */\n \t  lse.direct_byref = 1;\n-\t  gfc_conv_expr_descriptor (&lse, expr2, rss);\n+\t  gfc_conv_expr_descriptor (&lse, expr2);\n \t  strlen_rhs = lse.string_length;\n \n \t  /* If this is a subreference array pointer assignment, use the rhs\n@@ -6103,7 +6103,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \n \t  lse.expr = tmp;\n \t  lse.direct_byref = 1;\n-\t  gfc_conv_expr_descriptor (&lse, expr2, rss);\n+\t  gfc_conv_expr_descriptor (&lse, expr2);\n \t  strlen_rhs = lse.string_length;\n \t  gfc_add_modify (&lse.pre, desc, tmp);\n \t}\n@@ -6715,7 +6715,7 @@ static tree\n gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n {\n   gfc_se se;\n-  gfc_ss *ss;\n+  gfc_ss *ss = NULL;\n   gfc_component *comp = NULL;\n   gfc_loopinfo loop;\n \n@@ -6730,13 +6730,11 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n \t      || (!comp && gfc_return_by_reference (expr2->value.function.esym)\n \t\t  && expr2->value.function.esym->result->attr.dimension));\n \n-  ss = gfc_walk_expr (expr1);\n-  gcc_assert (ss != gfc_ss_terminator);\n   gfc_init_se (&se, NULL);\n   gfc_start_block (&se.pre);\n   se.want_pointer = 1;\n \n-  gfc_conv_array_parameter (&se, expr1, ss, false, NULL, NULL, NULL);\n+  gfc_conv_array_parameter (&se, expr1, false, NULL, NULL, NULL);\n \n   if (expr1->ts.type == BT_DERIVED\n \t&& expr1->ts.u.derived->attr.alloc_comp)\n@@ -6770,8 +6768,10 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n \n       if (!expr2->value.function.isym)\n \t{\n+\t  ss = gfc_walk_expr (expr1);\n+\t  gcc_assert (ss != gfc_ss_terminator);\n+\n \t  realloc_lhs_loop_for_fcn_call (&se, &expr1->where, &ss, &loop);\n-\t  gfc_cleanup_loop (&loop);\n \t  ss->is_alloc_lhs = 1;\n \t}\n       else\n@@ -6780,7 +6780,6 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n \n   gfc_conv_function_expr (&se, expr2);\n   gfc_add_block_to_block (&se.pre, &se.post);\n-  gfc_free_ss (se.ss);\n \n   return gfc_finish_block (&se.pre);\n }"}, {"sha": "5160cf0c0f12759bd6e6efa8a09a820ad2788d53", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 41, "deletions": 116, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2960a3685367ff2a1da3dfa428c200e07d97fe6e/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2960a3685367ff2a1da3dfa428c200e07d97fe6e/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=2960a3685367ff2a1da3dfa428c200e07d97fe6e", "patch": "@@ -923,51 +923,13 @@ gfc_conv_intrinsic_exponent (gfc_se *se, gfc_expr *expr)\n }\n \n \n-/* Convert the last ref of a scalar coarray from an AR_ELEMENT to an\n-   AR_FULL, suitable for the scalarizer.  */\n-\n-static gfc_ss *\n-walk_coarray (gfc_expr *e)\n-{\n-  gfc_ss *ss;\n-\n-  gcc_assert (gfc_get_corank (e) > 0);\n-\n-  ss = gfc_walk_expr (e);\n-\n-  /* Fix scalar coarray.  */\n-  if (ss == gfc_ss_terminator)\n-    {\n-      gfc_ref *ref;\n-\n-      ref = e->ref;\n-      while (ref)\n-\t{\n-\t  if (ref->type == REF_ARRAY\n-\t      && ref->u.ar.codimen > 0)\n-\t    break;\n-\n-\t  ref = ref->next;\n-\t}\n-\n-      gcc_assert (ref != NULL);\n-      if (ref->u.ar.type == AR_ELEMENT)\n-\tref->u.ar.type = AR_SECTION;\n-      ss = gfc_reverse_ss (gfc_walk_array_ref (ss, e, ref));\n-    }\n-\n-  return ss;\n-}\n-\n-\n static void\n trans_this_image (gfc_se * se, gfc_expr *expr)\n {\n   stmtblock_t loop;\n   tree type, desc, dim_arg, cond, tmp, m, loop_var, exit_label, min_var,\n        lbound, ubound, extent, ml;\n   gfc_se argse;\n-  gfc_ss *ss;\n   int rank, corank;\n \n   /* The case -fcoarray=single is handled elsewhere.  */\n@@ -991,10 +953,8 @@ trans_this_image (gfc_se * se, gfc_expr *expr)\n \n   /* Obtain the descriptor of the COARRAY.  */\n   gfc_init_se (&argse, NULL);\n-  ss = walk_coarray (expr->value.function.actual->expr);\n-  gcc_assert (ss != gfc_ss_terminator);\n   argse.want_coarray = 1;\n-  gfc_conv_expr_descriptor (&argse, expr->value.function.actual->expr, ss);\n+  gfc_conv_expr_descriptor (&argse, expr->value.function.actual->expr);\n   gfc_add_block_to_block (&se->pre, &argse.pre);\n   gfc_add_block_to_block (&se->post, &argse.post);\n   desc = argse.expr;\n@@ -1186,7 +1146,6 @@ trans_image_index (gfc_se * se, gfc_expr *expr)\n   tree num_images, cond, coindex, type, lbound, ubound, desc, subdesc,\n        tmp, invalid_bound;\n   gfc_se argse, subse;\n-  gfc_ss *ss, *subss;\n   int rank, corank, codim;\n \n   type = gfc_get_int_type (gfc_default_integer_kind);\n@@ -1195,20 +1154,15 @@ trans_image_index (gfc_se * se, gfc_expr *expr)\n \n   /* Obtain the descriptor of the COARRAY.  */\n   gfc_init_se (&argse, NULL);\n-  ss = walk_coarray (expr->value.function.actual->expr);\n-  gcc_assert (ss != gfc_ss_terminator);\n   argse.want_coarray = 1;\n-  gfc_conv_expr_descriptor (&argse, expr->value.function.actual->expr, ss);\n+  gfc_conv_expr_descriptor (&argse, expr->value.function.actual->expr);\n   gfc_add_block_to_block (&se->pre, &argse.pre);\n   gfc_add_block_to_block (&se->post, &argse.post);\n   desc = argse.expr;\n \n   /* Obtain a handle to the SUB argument.  */\n   gfc_init_se (&subse, NULL);\n-  subss = gfc_walk_expr (expr->value.function.actual->next->expr);\n-  gcc_assert (subss != gfc_ss_terminator);\n-  gfc_conv_expr_descriptor (&subse, expr->value.function.actual->next->expr,\n-\t\t\t    subss);\n+  gfc_conv_expr_descriptor (&subse, expr->value.function.actual->next->expr);\n   gfc_add_block_to_block (&se->pre, &subse.pre);\n   gfc_add_block_to_block (&se->post, &subse.post);\n   subdesc = build_fold_indirect_ref_loc (input_location,\n@@ -1319,16 +1273,12 @@ static void\n gfc_conv_intrinsic_rank (gfc_se *se, gfc_expr *expr)\n {\n   gfc_se argse;\n-  gfc_ss *ss;\n \n-  ss = gfc_walk_expr (expr->value.function.actual->expr);\n-  gcc_assert (ss != gfc_ss_terminator);\n   gfc_init_se (&argse, NULL);\n   argse.data_not_needed = 1;\n   argse.descriptor_only = 1;\n \n-  gfc_conv_expr_descriptor (&argse, expr->value.function.actual->expr, ss);\n-  gfc_free_ss (ss);\n+  gfc_conv_expr_descriptor (&argse, expr->value.function.actual->expr);\n   gfc_add_block_to_block (&se->pre, &argse.pre);\n   gfc_add_block_to_block (&se->post, &argse.post);\n \n@@ -1352,7 +1302,6 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n   tree ubound;\n   tree lbound;\n   gfc_se argse;\n-  gfc_ss *ss;\n   gfc_array_spec * as;\n   bool assumed_rank_lb_one;\n \n@@ -1387,10 +1336,8 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n \n   /* TODO: don't re-evaluate the descriptor on each iteration.  */\n   /* Get a descriptor for the first parameter.  */\n-  ss = gfc_walk_expr (arg->expr);\n-  gcc_assert (ss != gfc_ss_terminator);\n   gfc_init_se (&argse, NULL);\n-  gfc_conv_expr_descriptor (&argse, arg->expr, ss);\n+  gfc_conv_expr_descriptor (&argse, arg->expr);\n   gfc_add_block_to_block (&se->pre, &argse.pre);\n   gfc_add_block_to_block (&se->post, &argse.post);\n \n@@ -1556,7 +1503,6 @@ conv_intrinsic_cobound (gfc_se * se, gfc_expr * expr)\n   gfc_actual_arglist *arg;\n   gfc_actual_arglist *arg2;\n   gfc_se argse;\n-  gfc_ss *ss;\n   tree bound, resbound, resbound2, desc, cond, tmp;\n   tree type;\n   int corank;\n@@ -1571,12 +1517,10 @@ conv_intrinsic_cobound (gfc_se * se, gfc_expr * expr)\n   gcc_assert (arg->expr->expr_type == EXPR_VARIABLE);\n   corank = gfc_get_corank (arg->expr);\n \n-  ss = walk_coarray (arg->expr);\n-  gcc_assert (ss != gfc_ss_terminator);\n   gfc_init_se (&argse, NULL);\n   argse.want_coarray = 1;\n \n-  gfc_conv_expr_descriptor (&argse, arg->expr, ss);\n+  gfc_conv_expr_descriptor (&argse, arg->expr);\n   gfc_add_block_to_block (&se->pre, &argse.pre);\n   gfc_add_block_to_block (&se->post, &argse.post);\n   desc = argse.expr;\n@@ -4595,7 +4539,6 @@ gfc_conv_intrinsic_len (gfc_se * se, gfc_expr * expr)\n   gfc_symbol *sym;\n   gfc_se argse;\n   gfc_expr *arg;\n-  gfc_ss *ss;\n \n   gcc_assert (!se->ss);\n \n@@ -4637,12 +4580,11 @@ gfc_conv_intrinsic_len (gfc_se * se, gfc_expr * expr)\n \n     default:\n       /* Anybody stupid enough to do this deserves inefficient code.  */\n-      ss = gfc_walk_expr (arg);\n       gfc_init_se (&argse, se);\n-      if (ss == gfc_ss_terminator)\n+      if (arg->rank == 0)\n \tgfc_conv_expr (&argse, arg);\n       else\n-\tgfc_conv_expr_descriptor (&argse, arg, ss);\n+\tgfc_conv_expr_descriptor (&argse, arg);\n       gfc_add_block_to_block (&se->pre, &argse.pre);\n       gfc_add_block_to_block (&se->post, &argse.post);\n       len = argse.string_length;\n@@ -5099,19 +5041,16 @@ gfc_conv_intrinsic_size (gfc_se * se, gfc_expr * expr)\n   tree fncall0;\n   tree fncall1;\n   gfc_se argse;\n-  gfc_ss *ss;\n \n   gfc_init_se (&argse, NULL);\n   actual = expr->value.function.actual;\n \n   if (actual->expr->ts.type == BT_CLASS)\n     gfc_add_class_array_ref (actual->expr);\n \n-  ss = gfc_walk_expr (actual->expr);\n-  gcc_assert (ss != gfc_ss_terminator);\n   argse.want_pointer = 1;\n   argse.data_not_needed = 1;\n-  gfc_conv_expr_descriptor (&argse, actual->expr, ss);\n+  gfc_conv_expr_descriptor (&argse, actual->expr);\n   gfc_add_block_to_block (&se->pre, &argse.pre);\n   gfc_add_block_to_block (&se->post, &argse.post);\n   arg1 = gfc_evaluate_now (argse.expr, &se->pre);\n@@ -5214,7 +5153,6 @@ static void\n gfc_conv_intrinsic_sizeof (gfc_se *se, gfc_expr *expr)\n {\n   gfc_expr *arg;\n-  gfc_ss *ss;\n   gfc_se argse;\n   tree source_bytes;\n   tree type;\n@@ -5226,9 +5164,8 @@ gfc_conv_intrinsic_sizeof (gfc_se *se, gfc_expr *expr)\n   arg = expr->value.function.actual->expr;\n \n   gfc_init_se (&argse, NULL);\n-  ss = gfc_walk_expr (arg);\n \n-  if (ss == gfc_ss_terminator)\n+  if (arg->rank == 0)\n     {\n       if (arg->ts.type == BT_CLASS)\n \tgfc_add_data_component (arg);\n@@ -5249,7 +5186,7 @@ gfc_conv_intrinsic_sizeof (gfc_se *se, gfc_expr *expr)\n     {\n       source_bytes = gfc_create_var (gfc_array_index_type, \"bytes\");\n       argse.want_pointer = 0;\n-      gfc_conv_expr_descriptor (&argse, arg, ss);\n+      gfc_conv_expr_descriptor (&argse, arg);\n       type = gfc_get_element_type (TREE_TYPE (argse.expr));\n \n       /* Obtain the argument's word length.  */\n@@ -5286,7 +5223,6 @@ static void\n gfc_conv_intrinsic_storage_size (gfc_se *se, gfc_expr *expr)\n {\n   gfc_expr *arg;\n-  gfc_ss *ss;\n   gfc_se argse,eight;\n   tree type, result_type, tmp;\n \n@@ -5295,10 +5231,9 @@ gfc_conv_intrinsic_storage_size (gfc_se *se, gfc_expr *expr)\n   gfc_conv_expr (&eight, gfc_get_int_expr (expr->ts.kind, NULL, 8));\n   \n   gfc_init_se (&argse, NULL);\n-  ss = gfc_walk_expr (arg);\n   result_type = gfc_get_int_type (expr->ts.kind);\n \n-  if (ss == gfc_ss_terminator)\n+  if (arg->rank == 0)\n     {\n       if (arg->ts.type == BT_CLASS)\n       {\n@@ -5316,7 +5251,7 @@ gfc_conv_intrinsic_storage_size (gfc_se *se, gfc_expr *expr)\n   else\n     {\n       argse.want_pointer = 0;\n-      gfc_conv_expr_descriptor (&argse, arg, ss);\n+      gfc_conv_expr_descriptor (&argse, arg);\n       type = gfc_get_element_type (TREE_TYPE (argse.expr));\n     }\n     \n@@ -5410,7 +5345,6 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n   tree stmt;\n   gfc_actual_arglist *arg;\n   gfc_se argse;\n-  gfc_ss *ss;\n   gfc_array_info *info;\n   stmtblock_t block;\n   int n;\n@@ -5436,12 +5370,11 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n     arg->expr->value.function.name = \"__transfer_in_transfer\";\n \n   gfc_init_se (&argse, NULL);\n-  ss = gfc_walk_expr (arg->expr);\n \n   source_bytes = gfc_create_var (gfc_array_index_type, NULL);\n \n   /* Obtain the pointer to source and the length of source in bytes.  */\n-  if (ss == gfc_ss_terminator)\n+  if (arg->expr->rank == 0)\n     {\n       gfc_conv_expr_reference (&argse, arg->expr);\n       source = argse.expr;\n@@ -5460,7 +5393,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n   else\n     {\n       argse.want_pointer = 0;\n-      gfc_conv_expr_descriptor (&argse, arg->expr, ss);\n+      gfc_conv_expr_descriptor (&argse, arg->expr);\n       source = gfc_conv_descriptor_data_get (argse.expr);\n       source_type = gfc_get_element_type (TREE_TYPE (argse.expr));\n \n@@ -5534,11 +5467,10 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n   arg = arg->next;\n \n   gfc_init_se (&argse, NULL);\n-  ss = gfc_walk_expr (arg->expr);\n \n   scalar_mold = arg->expr->rank == 0;\n \n-  if (ss == gfc_ss_terminator)\n+  if (arg->expr->rank == 0)\n     {\n       gfc_conv_expr_reference (&argse, arg->expr);\n       mold_type = TREE_TYPE (build_fold_indirect_ref_loc (input_location,\n@@ -5548,7 +5480,7 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n     {\n       gfc_init_se (&argse, NULL);\n       argse.want_pointer = 0;\n-      gfc_conv_expr_descriptor (&argse, arg->expr, ss);\n+      gfc_conv_expr_descriptor (&argse, arg->expr);\n       mold_type = gfc_get_element_type (TREE_TYPE (argse.expr));\n     }\n \n@@ -5741,7 +5673,6 @@ gfc_conv_allocated (gfc_se *se, gfc_expr *expr)\n {\n   gfc_actual_arglist *arg1;\n   gfc_se arg1se;\n-  gfc_ss *ss1;\n   tree tmp;\n \n   gfc_init_se (&arg1se, NULL);\n@@ -5758,9 +5689,7 @@ gfc_conv_allocated (gfc_se *se, gfc_expr *expr)\n \tgfc_add_data_component (arg1->expr);\n     }\n \n-  ss1 = gfc_walk_expr (arg1->expr);\n-\n-  if (ss1 == gfc_ss_terminator)\n+  if (arg1->expr->rank == 0)\n     {\n       /* Allocatable scalar.  */\n       arg1se.want_pointer = 1;\n@@ -5771,7 +5700,7 @@ gfc_conv_allocated (gfc_se *se, gfc_expr *expr)\n     {\n       /* Allocatable array.  */\n       arg1se.descriptor_only = 1;\n-      gfc_conv_expr_descriptor (&arg1se, arg1->expr, ss1);\n+      gfc_conv_expr_descriptor (&arg1se, arg1->expr);\n       tmp = gfc_conv_descriptor_data_get (arg1se.expr);\n     }\n \n@@ -5798,20 +5727,27 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n   tree tmp;\n   tree nonzero_charlen;\n   tree nonzero_arraylen;\n-  gfc_ss *ss1, *ss2;\n+  gfc_ss *ss;\n+  bool scalar;\n \n   gfc_init_se (&arg1se, NULL);\n   gfc_init_se (&arg2se, NULL);\n   arg1 = expr->value.function.actual;\n   if (arg1->expr->ts.type == BT_CLASS)\n     gfc_add_data_component (arg1->expr);\n   arg2 = arg1->next;\n-  ss1 = gfc_walk_expr (arg1->expr);\n+\n+  /* Check whether the expression is a scalar or not; we cannot use\n+     arg1->expr->rank as it can be nonzero for proc pointers.  */\n+  ss = gfc_walk_expr (arg1->expr);\n+  scalar = ss == gfc_ss_terminator;\n+  if (!scalar)\n+    gfc_free_ss_chain (ss);\n \n   if (!arg2->expr)\n     {\n       /* No optional target.  */\n-      if (ss1 == gfc_ss_terminator)\n+      if (scalar)\n         {\n \t  /* A pointer to a scalar.  */\n \t  arg1se.want_pointer = 1;\n@@ -5825,7 +5761,7 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n       else\n         {\n           /* A pointer to an array.  */\n-          gfc_conv_expr_descriptor (&arg1se, arg1->expr, ss1);\n+          gfc_conv_expr_descriptor (&arg1se, arg1->expr);\n           tmp2 = gfc_conv_descriptor_data_get (arg1se.expr);\n         }\n       gfc_add_block_to_block (&se->pre, &arg1se.pre);\n@@ -5839,19 +5775,16 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n       /* An optional target.  */\n       if (arg2->expr->ts.type == BT_CLASS)\n \tgfc_add_data_component (arg2->expr);\n-      ss2 = gfc_walk_expr (arg2->expr);\n \n       nonzero_charlen = NULL_TREE;\n       if (arg1->expr->ts.type == BT_CHARACTER)\n \tnonzero_charlen = fold_build2_loc (input_location, NE_EXPR,\n \t\t\t\t\t   boolean_type_node,\n \t\t\t\t\t   arg1->expr->ts.u.cl->backend_decl,\n \t\t\t\t\t   integer_zero_node);\n-\n-      if (ss1 == gfc_ss_terminator)\n+      if (scalar)\n         {\n \t  /* A pointer to a scalar.  */\n-\t  gcc_assert (ss2 == gfc_ss_terminator);\n \t  arg1se.want_pointer = 1;\n \t  gfc_conv_expr (&arg1se, arg1->expr);\n \t  if (arg1->expr->symtree->n.sym->attr.proc_pointer\n@@ -5894,12 +5827,11 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n \t\t\t\t\t      build_int_cst (TREE_TYPE (tmp), 0));\n \n           /* A pointer to an array, call library function _gfor_associated.  */\n-          gcc_assert (ss2 != gfc_ss_terminator);\n           arg1se.want_pointer = 1;\n-          gfc_conv_expr_descriptor (&arg1se, arg1->expr, ss1);\n+          gfc_conv_expr_descriptor (&arg1se, arg1->expr);\n \n           arg2se.want_pointer = 1;\n-          gfc_conv_expr_descriptor (&arg2se, arg2->expr, ss2);\n+          gfc_conv_expr_descriptor (&arg2se, arg2->expr);\n           gfc_add_block_to_block (&se->pre, &arg2se.pre);\n           gfc_add_block_to_block (&se->post, &arg2se.post);\n           se->expr = build_call_expr_loc (input_location,\n@@ -6254,16 +6186,14 @@ gfc_conv_intrinsic_loc (gfc_se * se, gfc_expr * expr)\n {\n   tree temp_var;\n   gfc_expr *arg_expr;\n-  gfc_ss *ss;\n \n   gcc_assert (!se->ss);\n \n   arg_expr = expr->value.function.actual->expr;\n-  ss = gfc_walk_expr (arg_expr);\n-  if (ss == gfc_ss_terminator)\n+  if (arg_expr->rank == 0)\n     gfc_conv_expr_reference (se, arg_expr);\n   else\n-    gfc_conv_array_parameter (se, arg_expr, ss, true, NULL, NULL, NULL);\n+    gfc_conv_array_parameter (se, arg_expr, true, NULL, NULL, NULL);\n   se->expr= convert (gfc_get_int_type (gfc_index_integer_kind), se->expr);\n    \n   /* Create a temporary variable for loc return value.  Without this, \n@@ -7302,7 +7232,6 @@ conv_intrinsic_move_alloc (gfc_code *code)\n   gfc_expr *from_expr, *to_expr;\n   gfc_expr *to_expr2, *from_expr2 = NULL;\n   gfc_se from_se, to_se;\n-  gfc_ss *from_ss, *to_ss;\n   tree tmp;\n   bool coarray;\n \n@@ -7428,19 +7357,15 @@ conv_intrinsic_move_alloc (gfc_code *code)\n \t}\n     }\n \n+\n   /* Deallocate \"to\".  */\n-  if (from_expr->rank != 0)\n-    {\n-      to_ss = gfc_walk_expr (to_expr);\n-      from_ss = gfc_walk_expr (from_expr);\n-    }\n-  else\n+  if (from_expr->rank == 0)\n     {\n-      to_ss = walk_coarray (to_expr);\n-      from_ss = walk_coarray (from_expr);\n+      to_se.want_coarray = 1;\n+      from_se.want_coarray = 1;\n     }\n-  gfc_conv_expr_descriptor (&to_se, to_expr, to_ss);\n-  gfc_conv_expr_descriptor (&from_se, from_expr, from_ss);\n+  gfc_conv_expr_descriptor (&to_se, to_expr);\n+  gfc_conv_expr_descriptor (&from_se, from_expr);\n \n   /* For coarrays, call SYNC ALL if TO is already deallocated as MOVE_ALLOC\n      is an image control \"statement\", cf. IR F08/0040 in 12-006A.  */"}, {"sha": "34db6fd5a116de031cc405dc826680065469fc53", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2960a3685367ff2a1da3dfa428c200e07d97fe6e/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2960a3685367ff2a1da3dfa428c200e07d97fe6e/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=2960a3685367ff2a1da3dfa428c200e07d97fe6e", "patch": "@@ -664,7 +664,7 @@ gfc_convert_array_to_string (gfc_se * se, gfc_expr * e)\n       return;\n     }\n \n-  gfc_conv_array_parameter (se, e, gfc_walk_expr (e), true, NULL, NULL, &size);\n+  gfc_conv_array_parameter (se, e, true, NULL, NULL, &size);\n   se->string_length = fold_convert (gfc_charlen_type_node, size);\n }\n \n@@ -780,8 +780,6 @@ set_internal_unit (stmtblock_t * block, stmtblock_t * post_block,\n   /* Character array.  */\n   else if (e->rank > 0)\n     {\n-      se.ss = gfc_walk_expr (e);\n-\n       if (is_subref_array (e))\n \t{\n \t  /* Use a temporary for components of arrays of derived types\n@@ -796,7 +794,7 @@ set_internal_unit (stmtblock_t * block, stmtblock_t * post_block,\n       else\n \t{\n \t  /* Return the data pointer and rank from the descriptor.  */\n-\t  gfc_conv_expr_descriptor (&se, e, se.ss);\n+\t  gfc_conv_expr_descriptor (&se, e);\n \t  tmp = gfc_conv_descriptor_data_get (se.expr);\n \t  se.expr = gfc_build_addr_expr (pchar_type_node, se.expr);\n \t}\n@@ -2236,12 +2234,10 @@ gfc_trans_transfer (gfc_code * code)\n   gfc_init_block (&body);\n \n   expr = code->expr1;\n-  ss = gfc_walk_expr (expr);\n-\n   ref = NULL;\n   gfc_init_se (&se, NULL);\n \n-  if (ss == gfc_ss_terminator)\n+  if (expr->rank == 0)\n     {\n       /* Transfer a scalar value.  */\n       gfc_conv_expr_reference (&se, expr);\n@@ -2281,15 +2277,16 @@ gfc_trans_transfer (gfc_code * code)\n \t  else\n \t    {\n \t      /* Get the descriptor.  */\n-\t      gfc_conv_expr_descriptor (&se, expr, ss);\n+\t      gfc_conv_expr_descriptor (&se, expr);\n \t      tmp = gfc_build_addr_expr (NULL_TREE, se.expr);\n \t    }\n \n \t  transfer_array_desc (&se, &expr->ts, tmp);\n \t  goto finish_block_label;\n \t}\n-      \n+\n       /* Initialize the scalarizer.  */\n+      ss = gfc_walk_expr (expr);\n       gfc_init_loopinfo (&loop);\n       gfc_add_ss_to_loop (&loop, ss);\n "}, {"sha": "9467601c08df59a5711164310acac3aad3d122b6", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2960a3685367ff2a1da3dfa428c200e07d97fe6e/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2960a3685367ff2a1da3dfa428c200e07d97fe6e/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=2960a3685367ff2a1da3dfa428c200e07d97fe6e", "patch": "@@ -274,7 +274,7 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \t  /* Obtain the argument descriptor for unpacking.  */\n \t  gfc_init_se (&parmse, NULL);\n \t  parmse.want_pointer = 1;\n-\t  gfc_conv_expr_descriptor (&parmse, e, gfc_walk_expr (e));\n+\t  gfc_conv_expr_descriptor (&parmse, e);\n \t  gfc_add_block_to_block (&se->pre, &parmse.pre);\n \n \t  /* If we've got INTENT(INOUT) or a derived type with INTENT(OUT),\n@@ -864,9 +864,7 @@ gfc_trans_sync (gfc_code *code, gfc_exec_op type)\n \t\t\t     \"implemented for image-set at %L\",\n \t\t\t     gfc_c_int_kind, &code->expr1->where);\n \n-\t  gfc_conv_array_parameter (&se, code->expr1,\n-\t\t\t\t    gfc_walk_expr (code->expr1), true, NULL,\n-\t\t\t\t    NULL, &len);\n+\t  gfc_conv_array_parameter (&se, code->expr1, true, NULL, NULL, &len);\n \t  images = se.expr;\n \n \t  tmp = gfc_typenode_for_spec (&code->expr1->ts);\n@@ -1160,21 +1158,19 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n       && (sym->as->type == AS_DEFERRED || sym->assoc->variable))\n     {\n       gfc_se se;\n-      gfc_ss *ss;\n       tree desc;\n \n       desc = sym->backend_decl;\n \n       /* If association is to an expression, evaluate it and create temporary.\n \t Otherwise, get descriptor of target for pointer assignment.  */\n       gfc_init_se (&se, NULL);\n-      ss = gfc_walk_expr (e);\n       if (sym->assoc->variable)\n \t{\n \t  se.direct_byref = 1;\n \t  se.expr = desc;\n \t}\n-      gfc_conv_expr_descriptor (&se, e, ss);\n+      gfc_conv_expr_descriptor (&se, e);\n \n       /* If we didn't already do the pointer assignment, set associate-name\n \t descriptor to the one generated for the temporary.  */\n@@ -1229,7 +1225,7 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n       if (sym->ts.type == BT_CLASS && CLASS_DATA (sym)->attr.dimension)\n \t{\n \t  /* For a class array we need a descriptor for the selector.  */\n-\t  gfc_conv_expr_descriptor (&se, e, gfc_walk_expr (e));\n+\t  gfc_conv_expr_descriptor (&se, e);\n \n \t  /* Obtain a temporary class container for the result.  */ \n \t  gfc_conv_class_to_class (&se, e, sym->ts, false);\n@@ -3502,8 +3498,7 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_init_se (&lse, NULL);\n       lse.expr = gfc_build_array_ref (tmp1, count, NULL);\n       lse.direct_byref = 1;\n-      rss = gfc_walk_expr (expr2);\n-      gfc_conv_expr_descriptor (&lse, expr2, rss);\n+      gfc_conv_expr_descriptor (&lse, expr2);\n \n       gfc_add_block_to_block (&body, &lse.pre);\n       gfc_add_block_to_block (&body, &lse.post);\n@@ -3524,9 +3519,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_modify (block, count, gfc_index_zero_node);\n \n       parm = gfc_build_array_ref (tmp1, count, NULL);\n-      lss = gfc_walk_expr (expr1);\n       gfc_init_se (&lse, NULL);\n-      gfc_conv_expr_descriptor (&lse, expr1, lss);\n+      gfc_conv_expr_descriptor (&lse, expr1);\n       gfc_add_modify (&lse.pre, lse.expr, parm);\n       gfc_start_block (&body);\n       gfc_add_block_to_block (&body, &lse.pre);"}]}