{"sha": "31350635bfd90beea79b0e9220008da12bbb5d22", "node_id": "C_kwDOANBUbNoAKDMxMzUwNjM1YmZkOTBiZWVhNzliMGU5MjIwMDA4ZGExMmJiYjVkMjI", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-04-13T12:34:49Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-04-13T14:02:57Z"}, "message": "d: Merge upstream dmd 4d1bfcf14, druntime 9ba9a6ae, phobos c0cc5e917.\n\nD front-end changes:\n\n    - Import dmd v2.099.1.\n    - Added `@mustuse' attribute, implmenting DIP 1038.\n    - Added `.tupleof` property for static arrays\n\nD runtime changes:\n\n    - Import druntime v2.099.1.\n\nPhobos changes:\n\n    - Import phobos v2.099.1.\n    - Zlib bindings have been updated to 1.2.12.\n\ngcc/d/ChangeLog:\n\n\t* Make-lang.in (D_FRONTEND_OBJS): Add d/common-bitfields.o,\n\td/mustuse.o.\n\t* d-ctfloat.cc (CTFloat::isIdentical): Don't treat NaN values as\n\tidentical.\n\t* dmd/MERGE: Merge upstream dmd 4d1bfcf14.\n\t* expr.cc (ExprVisitor::visit (VoidInitExp *)): New.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/MERGE: Merge upstream druntime 9ba9a6ae.\n\t* src/MERGE: Merge upstream phobos c0cc5e917.", "tree": {"sha": "2da5508cabb1f04bde53b7b61398bd21efec8839", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2da5508cabb1f04bde53b7b61398bd21efec8839"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31350635bfd90beea79b0e9220008da12bbb5d22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31350635bfd90beea79b0e9220008da12bbb5d22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31350635bfd90beea79b0e9220008da12bbb5d22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31350635bfd90beea79b0e9220008da12bbb5d22/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca145c6306f19272ac8756d88c4eba0bfdf01dfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca145c6306f19272ac8756d88c4eba0bfdf01dfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca145c6306f19272ac8756d88c4eba0bfdf01dfb"}], "stats": {"total": 2457, "additions": 1787, "deletions": 670}, "files": [{"sha": "f3e34c54015154edb10d569e74ce1260c3468081", "filename": "gcc/d/Make-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2FMake-lang.in?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -89,6 +89,7 @@ D_FRONTEND_OBJS = \\\n \td/canthrow.o \\\n \td/chkformat.o \\\n \td/clone.o \\\n+\td/common-bitfields.o \\\n \td/common-file.o \\\n \td/common-outbuffer.o \\\n \td/common-string.o \\\n@@ -143,6 +144,7 @@ D_FRONTEND_OBJS = \\\n \td/lambdacomp.o \\\n \td/lexer.o \\\n \td/mtype.o \\\n+\td/mustuse.o \\\n \td/nogc.o \\\n \td/nspace.o \\\n \td/ob.o \\"}, {"sha": "c4d9a44c59ba14ed46f2c7d2dfd81f08fb7b14ff", "filename": "gcc/d/d-ctfloat.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fd-ctfloat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fd-ctfloat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-ctfloat.cc?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -55,8 +55,7 @@ CTFloat::isIdentical (real_t x, real_t y)\n {\n   real_value rx = x.rv ();\n   real_value ry = y.rv ();\n-  return (REAL_VALUE_ISNAN (rx) && REAL_VALUE_ISNAN (ry))\n-    || real_identical (&rx, &ry);\n+  return real_identical (&rx, &ry);\n }\n \n /* Return true if real_t value R is NaN.  */"}, {"sha": "f36d65e7d84eaf47c9895ddccee93731682223d5", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -1,4 +1,4 @@\n-47871363d804f54b29ccfd444b082c19716c2301\n+4d1bfcf142928cf1c097b0a2689485c1b14f4f53\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "b14310312cda575a4d9339d72e25edc43151be5e", "filename": "gcc/d/dmd/README.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FREADME.md?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -130,6 +130,8 @@ Note that these groups have no strict meaning, the category assignments are a bi\n | [impcnvtab.d](https://github.com/dlang/dmd/blob/master/src/dmd/impcnvtab.d)   | Define an implicit conversion table for basic types                                        |\n | [importc.d](https://github.com/dlang/dmd/blob/master/src/dmd/importc.d)       | Helpers specific to ImportC                                                                |\n | [sideeffect.d](https://github.com/dlang/dmd/blob/master/src/dmd/sideeffect.d) | Extract side-effects of expressions for certain lowerings.                                 |\n+| [mustuse.d](https://github.com/dlang/dmd/blob/master/src/dmd/mustuse.d)       | Helpers related to the `@mustuse` attribute                                                |\n+\n \n **Compile Time Function Execution (CTFE)**\n "}, {"sha": "28a360921abff987bf4460d9deabca92de7913c9", "filename": "gcc/d/dmd/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FVERSION?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -1 +1 @@\n-v2.099.1-beta.1\n+v2.099.1"}, {"sha": "16cbe620bc5cb1ad8d588a06acb29d2c43bf8a6a", "filename": "gcc/d/dmd/arrayop.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Farrayop.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Farrayop.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farrayop.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -158,7 +158,7 @@ Expression arrayOp(BinExp e, Scope* sc)\n /// ditto\n Expression arrayOp(BinAssignExp e, Scope* sc)\n {\n-    //printf(\"BinAssignExp.arrayOp() %s\\n\", toChars());\n+    //printf(\"BinAssignExp.arrayOp() %s\\n\", e.toChars());\n \n     /* Check that the elements of e1 can be assigned to\n      */"}, {"sha": "1e84b55d181a194c3eb4c52f4d53af0dc5485136", "filename": "gcc/d/dmd/attrib.d", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fattrib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fattrib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -44,7 +44,6 @@ import dmd.mtype;\n import dmd.objc; // for objc.addSymbols\n import dmd.common.outbuffer;\n import dmd.root.array; // for each\n-import dmd.target; // for target.systemLinkage\n import dmd.tokens;\n import dmd.visitor;\n \n@@ -399,7 +398,7 @@ extern (C++) final class LinkDeclaration : AttribDeclaration\n     {\n         super(loc, null, decl);\n         //printf(\"LinkDeclaration(linkage = %d, decl = %p)\\n\", linkage, decl);\n-        this.linkage = (linkage == LINK.system) ? target.systemLinkage() : linkage;\n+        this.linkage = linkage;\n     }\n \n     static LinkDeclaration create(const ref Loc loc, LINK p, Dsymbols* decl)\n@@ -994,7 +993,7 @@ extern (C++) class ConditionalDeclaration : AttribDeclaration\n     // Decide if 'then' or 'else' code should be included\n     override Dsymbols* include(Scope* sc)\n     {\n-        //printf(\"ConditionalDeclaration::include(sc = %p) scope = %p\\n\", sc, scope);\n+        //printf(\"ConditionalDeclaration::include(sc = %p) scope = %p\\n\", sc, _scope);\n \n         if (errors)\n             return null;\n@@ -1057,7 +1056,7 @@ extern (C++) final class StaticIfDeclaration : ConditionalDeclaration\n      */\n     override Dsymbols* include(Scope* sc)\n     {\n-        //printf(\"StaticIfDeclaration::include(sc = %p) scope = %p\\n\", sc, scope);\n+        //printf(\"StaticIfDeclaration::include(sc = %p) scope = %p\\n\", sc, _scope);\n \n         if (errors || onStack)\n             return null;\n@@ -1496,12 +1495,7 @@ extern (C++) final class UserAttributeDeclaration : AttribDeclaration\n         if (global.params.cplusplus < CppStdRevision.cpp11)\n             return;\n \n-        // Avoid `if` at the call site\n-        if (sym.userAttribDecl is null || sym.userAttribDecl.atts is null)\n-            return;\n-\n-        foreach (exp; *sym.userAttribDecl.atts)\n-        {\n+        foreachUdaNoSemantic(sym, (exp) {\n             if (isGNUABITag(exp))\n             {\n                 if (sym.isCPPNamespaceDeclaration() || sym.isNspace())\n@@ -1515,9 +1509,10 @@ extern (C++) final class UserAttributeDeclaration : AttribDeclaration\n                     sym.errors = true;\n                 }\n                 // Only one `@gnuAbiTag` is allowed by semantic2\n-                return;\n+                return 1; // break\n             }\n-        }\n+            return 0; // continue\n+        });\n     }\n }\n \n@@ -1544,14 +1539,14 @@ bool isCoreUda(Dsymbol sym, Identifier ident)\n /**\n  * Iterates the UDAs attached to the given symbol.\n  *\n- * If `dg` returns `!= 0`, it will stop the iteration and return that\n- * value, otherwise it will return 0.\n- *\n  * Params:\n  *  sym = the symbol to get the UDAs from\n  *  sc = scope to use for semantic analysis of UDAs\n- *  dg = called once for each UDA. If `dg` returns `!= 0`, it will stop the\n- *      iteration and return that value, otherwise it will return `0`.\n+ *  dg = called once for each UDA\n+ *\n+ * Returns:\n+ *  If `dg` returns `!= 0`, stops the iteration and returns that value.\n+ *  Otherwise, returns 0.\n  */\n int foreachUda(Dsymbol sym, Scope* sc, int delegate(Expression) dg)\n {\n@@ -1577,3 +1572,32 @@ int foreachUda(Dsymbol sym, Scope* sc, int delegate(Expression) dg)\n         });\n     });\n }\n+\n+/**\n+ * Iterates the UDAs attached to the given symbol, without performing semantic\n+ * analysis.\n+ *\n+ * Use this function instead of `foreachUda` if semantic analysis of `sym` is\n+ * still in progress.\n+ *\n+ * Params:\n+ *  sym = the symbol to get the UDAs from\n+ *  dg = called once for each UDA\n+ *\n+ * Returns:\n+ *  If `dg` returns `!= 0`, stops the iteration and returns that value.\n+ *  Otherwise, returns 0.\n+ */\n+int foreachUdaNoSemantic(Dsymbol sym, int delegate(Expression) dg)\n+{\n+    if (sym.userAttribDecl is null || sym.userAttribDecl.atts is null)\n+        return 0;\n+\n+    foreach (exp; *sym.userAttribDecl.atts)\n+    {\n+        if (auto result = dg(exp))\n+            return result;\n+    }\n+\n+    return 0;\n+}"}, {"sha": "fb282dcf0a1daa4ac7abd5ad2105a805111817fa", "filename": "gcc/d/dmd/common/README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fcommon%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fcommon%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcommon%2FREADME.md?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -2,6 +2,7 @@\n \n | File                                                                               | Purpose                                                         |\n |------------------------------------------------------------------------------------|-----------------------------------------------------------------|\n+| [bitfields.d](https://github.com/dlang/dmd/blob/master/src/dmd/common/bitfields.d) | Pack multiple boolean fields into bit fields                    |\n | [file.d](https://github.com/dlang/dmd/blob/master/src/dmd/common/file.d)           | Functions and objects dedicated to file I/O and management      |\n | [outbuffer.d](https://github.com/dlang/dmd/blob/master/src/dmd/common/outbuffer.d) | An expandable buffer in which you can write text or binary data |\n | [string.d](https://github.com/dlang/dmd/blob/master/src/dmd/common/string.d)       | Common string functions including filename manipulation         |"}, {"sha": "d17983d66b4416c674e0ff30653b44e273b97e49", "filename": "gcc/d/dmd/common/bitfields.d", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fcommon%2Fbitfields.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fcommon%2Fbitfields.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcommon%2Fbitfields.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,70 @@\n+/**\n+ * A library bitfields utility\n+ *\n+ * Copyright: Copyright (C) 1999-2022 by The D Language Foundation, All Rights Reserved\n+ * Authors:   Dennis Korpel\n+ * License:   $(LINK2 https://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:    $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/common/bitfields.d, common/bitfields.d)\n+ * Documentation: https://dlang.org/phobos/dmd_common_bitfields.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/common/bitfields.d\n+ */\n+module dmd.common.bitfields;\n+\n+/**\n+ * Generate code for bit fields inside a struct/class body\n+ * Params:\n+ *   S = type of a struct with only boolean fields, which should become bit fields\n+ *   T = type of bit fields variable, must have enough bits to store all booleans\n+ * Returns: D code with a bit fields variable and getter / setter functions\n+ */\n+extern (D) string generateBitFields(S, T)()\n+if (__traits(isUnsigned, T))\n+{\n+    string result = \"extern (C++) pure nothrow @nogc @safe final {\";\n+    enum structName = __traits(identifier, S);\n+\n+    foreach (size_t i, mem; __traits(allMembers, S))\n+    {\n+        static assert(is(typeof(__traits(getMember, S, mem)) == bool));\n+        static assert(i < T.sizeof * 8, \"too many fields for bit field storage of type `\"~T.stringof~\"`\");\n+        enum mask = \"(1 << \"~i.stringof~\")\";\n+        result ~= \"\n+        /// set or get the corresponding \"~structName~\" member\n+        bool \"~mem~\"() const { return !!(bitFields & \"~mask~\"); }\n+        /// ditto\n+        bool \"~mem~\"(bool v)\n+        {\n+            v ? (bitFields |= \"~mask~\") : (bitFields &= ~\"~mask~\");\n+            return v;\n+        }\";\n+    }\n+    return result ~ \"}\\n private \"~T.stringof~\" bitFields;\\n\";\n+}\n+\n+///\n+unittest\n+{\n+    static struct B\n+    {\n+        bool x;\n+        bool y;\n+        bool z;\n+    }\n+\n+    static struct S\n+    {\n+        mixin(generateBitFields!(B, ubyte));\n+    }\n+\n+    S s;\n+    assert(!s.x);\n+    s.x = true;\n+    assert(s.x);\n+    s.x = false;\n+    assert(!s.x);\n+\n+    s.y = true;\n+    assert(s.y);\n+    assert(!s.x);\n+    assert(!s.z);\n+}"}, {"sha": "8f34b5319a9814754a27b894c4282e99f2cc975a", "filename": "gcc/d/dmd/common/file.d", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fcommon%2Ffile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fcommon%2Ffile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcommon%2Ffile.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -25,6 +25,8 @@ import core.sys.posix.unistd;\n \n import dmd.common.string;\n \n+nothrow:\n+\n /**\n Encapsulated management of a memory-mapped file.\n \n@@ -52,6 +54,8 @@ struct FileMapping(Datum)\n     private const(char)* name;\n     // state }\n \n+  nothrow:\n+\n     /**\n     Open `filename` and map it in memory. If `Datum` is `const`, opens for\n     read-only and maps the content in memory; no error is issued if the file"}, {"sha": "7e46d294f3d3d4dd807261dc95ff93d343a8d3cb", "filename": "gcc/d/dmd/common/outbuffer.d", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -16,6 +16,8 @@ import core.stdc.stdio;\n import core.stdc.string;\n import core.stdc.stdlib;\n \n+nothrow:\n+\n // In theory these functions should also restore errno, but we don't care because\n // we abort application on error anyway.\n extern (C) private pure @system @nogc nothrow\n@@ -54,6 +56,8 @@ struct OutBuffer\n     int level;\n     // state }\n \n+  nothrow:\n+\n     /**\n     Construct given size.\n     */"}, {"sha": "48bf9bb5b553839e1af59f89dd9d02d362f60c71", "filename": "gcc/d/dmd/common/string.d", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fcommon%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fcommon%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcommon%2Fstring.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -10,6 +10,8 @@\n  */\n module dmd.common.string;\n \n+nothrow:\n+\n /**\n Defines a temporary array using a fixed-length buffer as back store. If the length\n of the buffer suffices, it is readily used. Otherwise, `malloc` is used to\n@@ -26,6 +28,8 @@ struct SmallBuffer(T)\n     private T[] _extent;\n     private bool needsFree;\n \n+  nothrow:\n+\n     @disable this(); // no default ctor\n     @disable this(ref const SmallBuffer!T); // noncopyable, nonassignable\n "}, {"sha": "bf66408f1d4e69d362fcf56a2017eaad81b8b2bf", "filename": "gcc/d/dmd/constfold.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fconstfold.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fconstfold.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fconstfold.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -936,7 +936,7 @@ UnionExp Identity(EXP op, const ref Loc loc, Type type, Expression e1, Expressio\n     {\n         if (e1.type.isreal())\n         {\n-            cmp = RealIdentical(e1.toReal(), e2.toReal());\n+            cmp = CTFloat.isIdentical(e1.toReal(), e2.toReal());\n         }\n         else if (e1.type.isimaginary())\n         {"}, {"sha": "11229d4bd4f5d24addb8dd97aff6712456ab9cbe", "filename": "gcc/d/dmd/ctfeexpr.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fctfeexpr.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fctfeexpr.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -1269,7 +1269,7 @@ private int ctfeRawCmp(const ref Loc loc, Expression e1, Expression e2, bool ide\n         real_t r1 = e1.type.isreal() ? e1.toReal() : e1.toImaginary();\n         real_t r2 = e1.type.isreal() ? e2.toReal() : e2.toImaginary();\n         if (identity)\n-            return !RealIdentical(r1, r2);\n+            return !CTFloat.isIdentical(r1, r2);\n         if (CTFloat.isNaN(r1) || CTFloat.isNaN(r2)) // if unordered\n         {\n             return 1;   // they are not equal\n@@ -1399,7 +1399,7 @@ bool ctfeIdentity(const ref Loc loc, EXP op, Expression e1, Expression e2)\n         cmp = (es1.var == es2.var && es1.offset == es2.offset);\n     }\n     else if (e1.type.isreal())\n-        cmp = RealIdentical(e1.toReal(), e2.toReal());\n+        cmp = CTFloat.isIdentical(e1.toReal(), e2.toReal());\n     else if (e1.type.isimaginary())\n         cmp = RealIdentical(e1.toImaginary(), e2.toImaginary());\n     else if (e1.type.iscomplex())"}, {"sha": "83978391e42657c60977eb73c880bc6c075a5d01", "filename": "gcc/d/dmd/dcast.d", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fdcast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fdcast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -432,7 +432,7 @@ MATCH implicitConvTo(Expression e, Type t)\n                 return MATCH.nomatch;\n             goto case Tuns8;\n         case Tuns8:\n-            //printf(\"value = %llu %llu\\n\", (dinteger_t)(unsigned char)value, value);\n+            //printf(\"value = %llu %llu\\n\", cast(dinteger_t)cast(ubyte)value, value);\n             if (cast(ubyte)value != value)\n                 return MATCH.nomatch;\n             break;\n@@ -492,8 +492,8 @@ MATCH implicitConvTo(Expression e, Type t)\n             break;\n \n         case Tpointer:\n-            //printf(\"type = %s\\n\", type.toBasetype()->toChars());\n-            //printf(\"t = %s\\n\", t.toBasetype()->toChars());\n+            //printf(\"type = %s\\n\", type.toBasetype().toChars());\n+            //printf(\"t = %s\\n\", t.toBasetype().toChars());\n             if (ty == Tpointer && e.type.toBasetype().nextOf().ty == t.toBasetype().nextOf().ty)\n             {\n                 /* Allow things like:\n@@ -1107,6 +1107,10 @@ MATCH implicitConvTo(Expression e, Type t)\n \n     MATCH visitCond(CondExp e)\n     {\n+        auto result = visit(e);\n+        if (result != MATCH.nomatch)\n+            return result;\n+\n         MATCH m1 = e.e1.implicitConvTo(t);\n         MATCH m2 = e.e2.implicitConvTo(t);\n         //printf(\"CondExp: m1 %d m2 %d\\n\", m1, m2);\n@@ -2077,7 +2081,7 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n         if (auto tsa = tb.isTypeSArray())\n         {\n             size_t dim2 = cast(size_t)tsa.dim.toInteger();\n-            //printf(\"dim from = %d, to = %d\\n\", (int)se.len, (int)dim2);\n+            //printf(\"dim from = %d, to = %d\\n\", cast(int)se.len, cast(int)dim2);\n \n             // Changing dimensions\n             if (dim2 != se.len)"}, {"sha": "45eb582745a21ac34f6d5af9e3a46ec900a88e11", "filename": "gcc/d/dmd/declaration.d", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fdeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fdeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -1083,29 +1083,12 @@ extern (C++) class VarDeclaration : Declaration\n         bool isArgDtorVar;      /// temporary created to handle scope destruction of a function argument\n     }\n \n-    private ushort bitFields;       // stores multiple booleans for BitFields\n+    import dmd.common.bitfields : generateBitFields;\n+    mixin(generateBitFields!(BitFields, ushort));\n+\n     byte canassign;                 // it can be assigned to\n     ubyte isdataseg;                // private data for isDataseg 0 unset, 1 true, 2 false\n \n-    // Generate getter and setter functions for `bitFields`\n-    extern (D) mixin(() {\n-        string result = \"extern (C++) pure nothrow @nogc @safe final {\";\n-        foreach (size_t i, mem; __traits(allMembers, BitFields))\n-        {\n-            result ~= \"\n-            /// set or get the corresponding BitFields member\n-            bool \"~mem~\"() const { return !!(bitFields & (1 << \"~i.stringof~\")); }\n-            /// ditto\n-            bool \"~mem~\"(bool v)\n-            {\n-                v ? (bitFields |= (1 << \"~i.stringof~\")) : (bitFields &= ~(1 << \"~i.stringof~\"));\n-                return v;\n-            }\";\n-        }\n-        return result ~ \"}\";\n-    }());\n-\n-\n     final extern (D) this(const ref Loc loc, Type type, Identifier ident, Initializer _init, StorageClass storage_class = STC.undefined_)\n     in\n     {"}, {"sha": "1f895e03af05eb66afba9e954b02ac4d73c7e64f", "filename": "gcc/d/dmd/dmangle.d", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fdmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fdmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -340,7 +340,6 @@ public:\n         final switch (t.linkage)\n         {\n         case LINK.default_:\n-        case LINK.system:\n         case LINK.d:\n             mc = 'F';\n             break;\n@@ -356,6 +355,8 @@ public:\n         case LINK.objc:\n             mc = 'Y';\n             break;\n+        case LINK.system:\n+            assert(0);\n         }\n         buf.writeByte(mc);\n \n@@ -1340,7 +1341,9 @@ extern (D) const(char)[] externallyMangledIdentifier(Declaration d)\n     {\n         if (d.linkage != LINK.d && d.localNum)\n             d.error(\"the same declaration cannot be in multiple scopes with non-D linkage\");\n-        final switch (d.linkage)\n+\n+        const l = d.linkage == LINK.system ? target.systemLinkage() : d.linkage;\n+        final switch (l)\n         {\n             case LINK.d:\n                 break;\n@@ -1354,9 +1357,10 @@ extern (D) const(char)[] externallyMangledIdentifier(Declaration d)\n                 return p.toDString();\n             }\n             case LINK.default_:\n-            case LINK.system:\n                 d.error(\"forward declaration\");\n                 return d.ident.toString();\n+            case LINK.system:\n+                assert(0);\n         }\n     }\n     return null;"}, {"sha": "e9c4c954efdd2dccef574d6ee15ff8d95445b8cb", "filename": "gcc/d/dmd/dmodule.d", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fdmodule.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fdmodule.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -69,7 +69,7 @@ void semantic3OnDependencies(Module m)\n /**\n  * Remove generated .di files on error and exit\n  */\n-void removeHdrFilesAndFail(ref Param params, ref Modules modules)\n+void removeHdrFilesAndFail(ref Param params, ref Modules modules) nothrow\n {\n     if (params.doHdrGeneration)\n     {\n@@ -94,7 +94,7 @@ void removeHdrFilesAndFail(ref Param params, ref Modules modules)\n  * Returns:\n  *  the filename of the child package or module\n  */\n-private const(char)[] getFilename(Identifier[] packages, Identifier ident)\n+private const(char)[] getFilename(Identifier[] packages, Identifier ident) nothrow\n {\n     const(char)[] filename = ident.toString();\n \n@@ -157,14 +157,14 @@ extern (C++) class Package : ScopeDsymbol\n     uint tag;        // auto incremented tag, used to mask package tree in scopes\n     Module mod;     // !=null if isPkgMod == PKG.module_\n \n-    final extern (D) this(const ref Loc loc, Identifier ident)\n+    final extern (D) this(const ref Loc loc, Identifier ident) nothrow\n     {\n         super(loc, ident);\n         __gshared uint packageTag;\n         this.tag = packageTag++;\n     }\n \n-    override const(char)* kind() const\n+    override const(char)* kind() const nothrow\n     {\n         return \"package\";\n     }\n@@ -664,7 +664,7 @@ extern (C++) final class Module : Package\n         //printf(\"Module::read('%s') file '%s'\\n\", toChars(), srcfile.toChars());\n         if (auto result = global.fileManager.lookup(srcfile))\n         {\n-            this.src = result.data;\n+            this.src = result;\n             if (global.params.emitMakeDeps)\n                 global.params.makeDeps.push(srcfile.toChars());\n             return true;\n@@ -1380,7 +1380,7 @@ extern (C++) final class Module : Package\n         a.setDim(0);\n     }\n \n-    extern (D) static void clearCache()\n+    extern (D) static void clearCache() nothrow\n     {\n         foreach (Module m; amodules)\n             m.searchCacheIdent = null;\n@@ -1391,7 +1391,7 @@ extern (C++) final class Module : Package\n      * return true if it imports m.\n      * Can be used to detect circular imports.\n      */\n-    int imports(Module m)\n+    int imports(Module m) nothrow\n     {\n         //printf(\"%s Module::imports(%s)\\n\", toChars(), m.toChars());\n         version (none)\n@@ -1414,14 +1414,14 @@ extern (C++) final class Module : Package\n         return false;\n     }\n \n-    bool isRoot()\n+    bool isRoot() nothrow\n     {\n         return this.importedFrom == this;\n     }\n \n     // true if the module source file is directly\n     // listed in command line.\n-    bool isCoreModule(Identifier ident)\n+    bool isCoreModule(Identifier ident) nothrow\n     {\n         return this.ident == ident && parent && parent.ident == Id.core && !parent.parent;\n     }\n@@ -1440,7 +1440,7 @@ extern (C++) final class Module : Package\n \n     uint[uint] ctfe_cov; /// coverage information from ctfe execution_count[line]\n \n-    override inout(Module) isModule() inout\n+    override inout(Module) isModule() inout nothrow\n     {\n         return this;\n     }\n@@ -1455,7 +1455,7 @@ extern (C++) final class Module : Package\n      * Params:\n      *    buf = The buffer to write to\n      */\n-    void fullyQualifiedName(ref OutBuffer buf)\n+    void fullyQualifiedName(ref OutBuffer buf) nothrow\n     {\n         buf.writestring(ident.toString());\n \n@@ -1469,7 +1469,7 @@ extern (C++) final class Module : Package\n     /** Lazily initializes and returns the escape table.\n     Turns out it eats a lot of memory.\n     */\n-    extern(D) Escape* escapetable()\n+    extern(D) Escape* escapetable() nothrow\n     {\n         if (!_escapetable)\n             _escapetable = new Escape();"}, {"sha": "2021e2afd8e1e70fddfabe85ff06bf78255bfbb6", "filename": "gcc/d/dmd/dsymbol.d", "status": "modified", "additions": 47, "deletions": 35, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fdsymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fdsymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -112,12 +112,12 @@ struct Ungag\n {\n     uint oldgag;\n \n-    extern (D) this(uint old)\n+    extern (D) this(uint old) nothrow\n     {\n         this.oldgag = old;\n     }\n \n-    extern (C++) ~this()\n+    extern (C++) ~this() nothrow\n     {\n         global.gag = oldgag;\n     }\n@@ -255,27 +255,27 @@ extern (C++) class Dsymbol : ASTNode\n     DeprecatedDeclaration depdecl;           // customized deprecation message\n     UserAttributeDeclaration userAttribDecl;    // user defined attributes\n \n-    final extern (D) this()\n+    final extern (D) this() nothrow\n     {\n         //printf(\"Dsymbol::Dsymbol(%p)\\n\", this);\n         loc = Loc(null, 0, 0);\n     }\n \n-    final extern (D) this(Identifier ident)\n+    final extern (D) this(Identifier ident) nothrow\n     {\n         //printf(\"Dsymbol::Dsymbol(%p, ident)\\n\", this);\n         this.loc = Loc(null, 0, 0);\n         this.ident = ident;\n     }\n \n-    final extern (D) this(const ref Loc loc, Identifier ident)\n+    final extern (D) this(const ref Loc loc, Identifier ident) nothrow\n     {\n         //printf(\"Dsymbol::Dsymbol(%p, ident)\\n\", this);\n         this.loc = loc;\n         this.ident = ident;\n     }\n \n-    static Dsymbol create(Identifier ident)\n+    static Dsymbol create(Identifier ident) nothrow\n     {\n         return new Dsymbol(ident);\n     }\n@@ -800,6 +800,22 @@ extern (C++) class Dsymbol : ASTNode\n             if (isAliasDeclaration() && !_scope)\n                 setScope(sc);\n             Dsymbol s2 = sds.symtabLookup(this,ident);\n+            /* https://issues.dlang.org/show_bug.cgi?id=17434\n+             *\n+             * If we are trying to add an import to the symbol table\n+             * that has already been introduced, then keep the one with\n+             * larger visibility. This is fine for imports because if\n+             * we have multiple imports of the same file, if a single one\n+             * is public then the symbol is reachable.\n+             */\n+            if (auto i1 = isImport())\n+            {\n+                if (auto i2 = s2.isImport())\n+                {\n+                    if (sc.explicitVisibility && sc.visibility > i2.visibility)\n+                        sds.symtab.update(this);\n+                }\n+            }\n \n             // If using C tag/prototype/forward declaration rules\n             if (sc.flags & SCOPE.Cfile && !this.isImport())\n@@ -933,14 +949,7 @@ extern (C++) class Dsymbol : ASTNode\n                 TemplateInstance ti = st.isTemplateInstance();\n                 sm = s.search(loc, ti.name);\n                 if (!sm)\n-                {\n-                    sm = s.search_correct(ti.name);\n-                    if (sm)\n-                        .error(loc, \"template identifier `%s` is not a member of %s `%s`, did you mean %s `%s`?\", ti.name.toChars(), s.kind(), s.toPrettyChars(), sm.kind(), sm.toChars());\n-                    else\n-                        .error(loc, \"template identifier `%s` is not a member of %s `%s`\", ti.name.toChars(), s.kind(), s.toPrettyChars());\n                     return null;\n-                }\n                 sm = sm.toAlias();\n                 TemplateDeclaration td = sm.isTemplateDeclaration();\n                 if (!td)\n@@ -1381,16 +1390,16 @@ private:\n     BitArray accessiblePackages, privateAccessiblePackages;// whitelists of accessible (imported) packages\n \n public:\n-    final extern (D) this()\n+    final extern (D) this() nothrow\n     {\n     }\n \n-    final extern (D) this(Identifier ident)\n+    final extern (D) this(Identifier ident) nothrow\n     {\n         super(ident);\n     }\n \n-    final extern (D) this(const ref Loc loc, Identifier ident)\n+    final extern (D) this(const ref Loc loc, Identifier ident) nothrow\n     {\n         super(loc, ident);\n     }\n@@ -1604,7 +1613,7 @@ public:\n         return os;\n     }\n \n-    void importScope(Dsymbol s, Visibility visibility)\n+    void importScope(Dsymbol s, Visibility visibility) nothrow\n     {\n         //printf(\"%s.ScopeDsymbol::importScope(%s, %d)\\n\", toChars(), s.toChars(), visibility);\n         // No circular or redundant import's\n@@ -1631,15 +1640,15 @@ public:\n         }\n     }\n \n-    extern (D) final void addAccessiblePackage(Package p, Visibility visibility)\n+    extern (D) final void addAccessiblePackage(Package p, Visibility visibility) nothrow\n     {\n         auto pary = visibility.kind == Visibility.Kind.private_ ? &privateAccessiblePackages : &accessiblePackages;\n         if (pary.length <= p.tag)\n             pary.length = p.tag + 1;\n         (*pary)[p.tag] = true;\n     }\n \n-    bool isPackageAccessible(Package p, Visibility visibility, int flags = 0)\n+    bool isPackageAccessible(Package p, Visibility visibility, int flags = 0) nothrow\n     {\n         if (p.tag < accessiblePackages.length && accessiblePackages[p.tag] ||\n             visibility.kind == Visibility.Kind.private_ && p.tag < privateAccessiblePackages.length && privateAccessiblePackages[p.tag])\n@@ -1654,7 +1663,7 @@ public:\n         return false;\n     }\n \n-    override final bool isforwardRef()\n+    override final bool isforwardRef() nothrow\n     {\n         return (members is null);\n     }\n@@ -1742,7 +1751,7 @@ public:\n      * Returns:\n      *   null if already in table, `s` if inserted\n      */\n-    Dsymbol symtabInsert(Dsymbol s)\n+    Dsymbol symtabInsert(Dsymbol s) nothrow\n     {\n         return symtab.insert(s);\n     }\n@@ -1755,7 +1764,7 @@ public:\n      * Returns:\n      *   Dsymbol if found, null if not\n      */\n-    Dsymbol symtabLookup(Dsymbol s, Identifier id)\n+    Dsymbol symtabLookup(Dsymbol s, Identifier id) nothrow\n     {\n         return symtab.lookup(id);\n     }\n@@ -1838,7 +1847,7 @@ extern (C++) final class WithScopeSymbol : ScopeDsymbol\n {\n     WithStatement withstate;\n \n-    extern (D) this(WithStatement withstate)\n+    extern (D) this(WithStatement withstate) nothrow\n     {\n         this.withstate = withstate;\n     }\n@@ -1898,21 +1907,21 @@ extern (C++) final class ArrayScopeSymbol : ScopeDsymbol\n     private RootObject arrayContent;\n     Scope* sc;\n \n-    extern (D) this(Scope* sc, Expression exp)\n+    extern (D) this(Scope* sc, Expression exp) nothrow\n     {\n         super(exp.loc, null);\n         assert(exp.op == EXP.index || exp.op == EXP.slice || exp.op == EXP.array);\n         this.sc = sc;\n         this.arrayContent = exp;\n     }\n \n-    extern (D) this(Scope* sc, TypeTuple type)\n+    extern (D) this(Scope* sc, TypeTuple type) nothrow\n     {\n         this.sc = sc;\n         this.arrayContent = type;\n     }\n \n-    extern (D) this(Scope* sc, TupleDeclaration td)\n+    extern (D) this(Scope* sc, TupleDeclaration td) nothrow\n     {\n         this.sc = sc;\n         this.arrayContent = td;\n@@ -2109,7 +2118,7 @@ extern (C++) final class OverloadSet : Dsymbol\n {\n     Dsymbols a;     // array of Dsymbols\n \n-    extern (D) this(Identifier ident, OverloadSet os = null)\n+    extern (D) this(Identifier ident, OverloadSet os = null) nothrow\n     {\n         super(ident);\n         if (os)\n@@ -2118,7 +2127,7 @@ extern (C++) final class OverloadSet : Dsymbol\n         }\n     }\n \n-    void push(Dsymbol s)\n+    void push(Dsymbol s) nothrow\n     {\n         a.push(s);\n     }\n@@ -2152,12 +2161,13 @@ extern (C++) final class ForwardingScopeDsymbol : ScopeDsymbol\n      * Can be `null` before being lazily initialized.\n      */\n     ScopeDsymbol forward;\n-    extern (D) this(ScopeDsymbol forward)\n+    extern (D) this(ScopeDsymbol forward) nothrow\n     {\n         super(null);\n         this.forward = forward;\n     }\n-    override Dsymbol symtabInsert(Dsymbol s)\n+\n+    override Dsymbol symtabInsert(Dsymbol s) nothrow\n     {\n         assert(forward);\n         if (auto d = s.isDeclaration())\n@@ -2188,7 +2198,7 @@ extern (C++) final class ForwardingScopeDsymbol : ScopeDsymbol\n      * and\n      *     static foreach (i; [0]) { enum i = 2; }\n      */\n-    override Dsymbol symtabLookup(Dsymbol s, Identifier id)\n+    override Dsymbol symtabLookup(Dsymbol s, Identifier id) nothrow\n     {\n         assert(forward);\n         // correctly diagnose clashing foreach loop variables.\n@@ -2219,7 +2229,7 @@ extern (C++) final class ForwardingScopeDsymbol : ScopeDsymbol\n \n     override const(char)* kind()const{ return \"local scope\"; }\n \n-    override inout(ForwardingScopeDsymbol) isForwardingScopeDsymbol() inout\n+    override inout(ForwardingScopeDsymbol) isForwardingScopeDsymbol() inout nothrow\n     {\n         return this;\n     }\n@@ -2234,13 +2244,13 @@ extern (C++) final class ForwardingScopeDsymbol : ScopeDsymbol\n extern (C++) final class ExpressionDsymbol : Dsymbol\n {\n     Expression exp;\n-    this(Expression exp)\n+    this(Expression exp) nothrow\n     {\n         super();\n         this.exp = exp;\n     }\n \n-    override inout(ExpressionDsymbol) isExpressionDsymbol() inout\n+    override inout(ExpressionDsymbol) isExpressionDsymbol() inout nothrow\n     {\n         return this;\n     }\n@@ -2259,7 +2269,7 @@ extern (C++) final class AliasAssign : Dsymbol\n     Dsymbol aliassym; /// replace previous RHS of AliasDeclaration with `aliassym`\n                       /// only one of type and aliassym can be != null\n \n-    extern (D) this(const ref Loc loc, Identifier ident, Type type, Dsymbol aliassym)\n+    extern (D) this(const ref Loc loc, Identifier ident, Type type, Dsymbol aliassym) nothrow\n     {\n         super(loc, null);\n         this.ident = ident;\n@@ -2299,6 +2309,8 @@ extern (C++) final class DsymbolTable : RootObject\n {\n     AssocArray!(Identifier, Dsymbol) tab;\n \n+  nothrow:\n+\n    /***************************\n     * Look up Identifier in symbol table\n     * Params:"}, {"sha": "1ccaab56da6a3240696f6a84d89b7be3ea394afd", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -51,6 +51,7 @@ import dmd.init;\n import dmd.initsem;\n import dmd.hdrgen;\n import dmd.mtype;\n+import dmd.mustuse;\n import dmd.nogc;\n import dmd.nspace;\n import dmd.objc;\n@@ -542,7 +543,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                     Parameter arg = Parameter.getNth(tt.arguments, pos);\n                     arg.type = arg.type.typeSemantic(dsym.loc, sc);\n                     //printf(\"[%d] iexps.dim = %d, \", pos, iexps.dim);\n-                    //printf(\"e = (%s %s, %s), \", Token::tochars[e.op], e.toChars(), e.type.toChars());\n+                    //printf(\"e = (%s %s, %s), \", Token.tochars[e.op], e.toChars(), e.type.toChars());\n                     //printf(\"arg = (%s, %s)\\n\", arg.toChars(), arg.type.toChars());\n \n                     if (e != ie)\n@@ -581,7 +582,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                             arg = Parameter.getNth(tt.arguments, pos + u);\n                             arg.type = arg.type.typeSemantic(dsym.loc, sc);\n                             //printf(\"[%d+%d] exps.dim = %d, \", pos, u, exps.dim);\n-                            //printf(\"ee = (%s %s, %s), \", Token::tochars[ee.op], ee.toChars(), ee.type.toChars());\n+                            //printf(\"ee = (%s %s, %s), \", Token.tochars[ee.op], ee.toChars(), ee.type.toChars());\n                             //printf(\"arg = (%s, %s)\\n\", arg.toChars(), arg.type.toChars());\n \n                             size_t iexps_dim = iexps.dim - 1 + exps.dim;\n@@ -2046,6 +2047,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n         ed.semanticRun = PASS.semantic;\n         UserAttributeDeclaration.checkGNUABITag(ed, sc.linkage);\n+        checkMustUseReserved(ed);\n \n         if (!ed.members && !ed.memtype) // enum ident;\n         {\n@@ -3017,7 +3019,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         if ((funcdecl.storage_class & STC.TYPECTOR) && !(ad || funcdecl.isNested()))\n             funcdecl.storage_class &= ~STC.TYPECTOR;\n \n-        //printf(\"function storage_class = x%llx, sc.stc = x%llx, %x\\n\", storage_class, sc.stc, Declaration::isFinal());\n+        //printf(\"function storage_class = x%llx, sc.stc = x%llx, %x\\n\", storage_class, sc.stc, Declaration.isFinal());\n \n         if (sc.flags & SCOPE.compile)\n             funcdecl.flags |= FUNCFLAG.compileTimeOnly; // don't emit code for this function\n@@ -3056,6 +3058,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         funcdecl.visibility = sc.visibility;\n         funcdecl.userAttribDecl = sc.userAttribDecl;\n         UserAttributeDeclaration.checkGNUABITag(funcdecl, funcdecl.linkage);\n+        checkMustUseReserved(funcdecl);\n \n         if (!funcdecl.originalType)\n             funcdecl.originalType = funcdecl.type.syntaxCopy();\n@@ -4092,7 +4095,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n     override void visit(PostBlitDeclaration pbd)\n     {\n         //printf(\"PostBlitDeclaration::semantic() %s\\n\", toChars());\n-        //printf(\"ident: %s, %s, %p, %p\\n\", ident.toChars(), Id::dtor.toChars(), ident, Id::dtor);\n+        //printf(\"ident: %s, %s, %p, %p\\n\", ident.toChars(), Id.dtor.toChars(), ident, Id.dtor);\n         //printf(\"stc = x%llx\\n\", sc.stc);\n         if (pbd.semanticRun >= PASS.semanticdone)\n             return;\n@@ -4129,7 +4132,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n     override void visit(DtorDeclaration dd)\n     {\n         //printf(\"DtorDeclaration::semantic() %s\\n\", toChars());\n-        //printf(\"ident: %s, %s, %p, %p\\n\", ident.toChars(), Id::dtor.toChars(), ident, Id::dtor);\n+        //printf(\"ident: %s, %s, %p, %p\\n\", ident.toChars(), Id.dtor.toChars(), ident, Id.dtor);\n         if (dd.semanticRun >= PASS.semanticdone)\n             return;\n         if (dd._scope)\n@@ -4770,6 +4773,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         }\n         cldec.semanticRun = PASS.semantic;\n         UserAttributeDeclaration.checkGNUABITag(cldec, sc.linkage);\n+        checkMustUseReserved(cldec);\n \n         if (cldec.baseok < Baseok.done)\n         {\n@@ -5475,6 +5479,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                 idec.classKind = ClassKind.cpp;\n             idec.cppnamespace = sc.namespace;\n             UserAttributeDeclaration.checkGNUABITag(idec, sc.linkage);\n+            checkMustUseReserved(idec);\n \n             if (sc.linkage == LINK.objc)\n                 objc.setObjc(idec);"}, {"sha": "fb41e2bd05f5c4e224d6f4c118862d18ab5e579a", "filename": "gcc/d/dmd/dtemplate.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fdtemplate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fdtemplate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -2626,7 +2626,7 @@ void functionResolve(ref MatchAccumulator m, Dsymbol dstart, Loc loc, Scope* sc,\n             printf(\"\\t%s %s\\n\", arg.type.toChars(), arg.toChars());\n             //printf(\"\\tty = %d\\n\", arg.type.ty);\n         }\n-        //printf(\"stc = %llx\\n\", dstart.scope.stc);\n+        //printf(\"stc = %llx\\n\", dstart._scope.stc);\n         //printf(\"match:t/f = %d/%d\\n\", ta_last, m.last);\n     }\n \n@@ -4332,7 +4332,7 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n             {\n                 TypeStruct tp = cast(TypeStruct)tparam;\n \n-                //printf(\"\\t%d\\n\", (MATCH) t.implicitConvTo(tp));\n+                //printf(\"\\t%d\\n\", cast(MATCH) t.implicitConvTo(tp));\n                 if (wm && t.deduceWild(tparam, false))\n                 {\n                     result = MATCH.constant;\n@@ -4513,7 +4513,7 @@ MATCH deduceType(RootObject o, Scope* sc, Type tparam, TemplateParameters* param\n             {\n                 TypeClass tp = cast(TypeClass)tparam;\n \n-                //printf(\"\\t%d\\n\", (MATCH) t.implicitConvTo(tp));\n+                //printf(\"\\t%d\\n\", cast(MATCH) t.implicitConvTo(tp));\n                 if (wm && t.deduceWild(tparam, false))\n                 {\n                     result = MATCH.constant;"}, {"sha": "78b9a07f3a37e098377a02a1f27bd8508f7ac73b", "filename": "gcc/d/dmd/escape.d", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fescape.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fescape.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -440,22 +440,33 @@ bool checkParamArgumentEscape(Scope* sc, FuncDeclaration fdc, Parameter par, Exp\n  *      sc = used to determine current function and module\n  *      firstArg = `ref` argument through which `arg` may be assigned\n  *      arg = initializer for parameter\n+ *      param = parameter declaration corresponding to `arg`\n  *      gag = do not print error messages\n  * Returns:\n  *      `true` if assignment to `firstArg` would cause an error\n  */\n-bool checkParamArgumentReturn(Scope* sc, Expression firstArg, Expression arg, bool gag)\n+bool checkParamArgumentReturn(Scope* sc, Expression firstArg, Expression arg, Parameter param, bool gag)\n {\n     enum log = false;\n     if (log) printf(\"checkParamArgumentReturn(firstArg: %s arg: %s)\\n\",\n         firstArg.toChars(), arg.toChars());\n     //printf(\"type = %s, %d\\n\", arg.type.toChars(), arg.type.hasPointers());\n \n-    if (!arg.type.hasPointers())\n+    if (!(param.storageClass & STC.return_))\n+        return false;\n+\n+    if (!arg.type.hasPointers() && !param.isReference())\n         return false;\n \n+    // `byRef` needed for `assign(ref int* x, ref int i) {x = &i};`\n+    // Note: taking address of scope pointer is not allowed\n+    // `assign(ref int** x, return ref scope int* i) {x = &i};`\n+    // Thus no return ref/return scope ambiguity here\n+    const byRef = param.isReference() && !(param.storageClass & STC.scope_)\n+        && !(param.storageClass & STC.returnScope); // fixme: it's possible to infer returnScope without scope with vaIsFirstRef\n+\n     scope e = new AssignExp(arg.loc, firstArg, arg);\n-    return checkAssignEscape(sc, e, gag);\n+    return checkAssignEscape(sc, e, gag, byRef);\n }\n \n /*****************************************************\n@@ -496,23 +507,13 @@ bool checkConstructorEscape(Scope* sc, CallExp ce, bool gag)\n     foreach (const i; 0 .. n)\n     {\n         Expression arg = (*ce.arguments)[i];\n-        if (!arg.type.hasPointers())\n-            continue;\n-\n         //printf(\"\\targ[%d]: %s\\n\", i, arg.toChars());\n \n         if (i - j < nparams && i >= j)\n         {\n             Parameter p = tf.parameterList[i - j];\n-\n-            if (p.storageClass & STC.return_)\n-            {\n-                /* Fake `dve.e1 = arg;` and look for scope violations\n-                 */\n-                scope e = new AssignExp(arg.loc, dve.e1, arg);\n-                if (checkAssignEscape(sc, e, gag))\n-                    return true;\n-            }\n+            if (checkParamArgumentReturn(sc, dve.e1, arg, p, gag))\n+                return true;\n         }\n     }\n \n@@ -529,13 +530,14 @@ bool checkConstructorEscape(Scope* sc, CallExp ce, bool gag)\n  *      sc = used to determine current function and module\n  *      e = `AssignExp` or `CatAssignExp` to check for any pointers to the stack\n  *      gag = do not print error messages\n+ *      byRef = set to `true` if `e1` of `e` gets assigned a reference to `e2`\n  * Returns:\n  *      `true` if pointers to the stack can escape via assignment\n  */\n-bool checkAssignEscape(Scope* sc, Expression e, bool gag)\n+bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n {\n     enum log = false;\n-    if (log) printf(\"checkAssignEscape(e: %s)\\n\", e.toChars());\n+    if (log) printf(\"checkAssignEscape(e: %s, byRef: %d)\\n\", e.toChars(), byRef);\n     if (e.op != EXP.assign && e.op != EXP.blit && e.op != EXP.construct &&\n         e.op != EXP.concatenateAssign && e.op != EXP.concatenateElemAssign && e.op != EXP.concatenateDcharAssign)\n         return false;\n@@ -561,7 +563,10 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag)\n \n     EscapeByResults er;\n \n-    escapeByValue(e2, &er);\n+    if (byRef)\n+        escapeByRef(e2, &er);\n+    else\n+        escapeByValue(e2, &er);\n \n     if (!er.byref.dim && !er.byvalue.dim && !er.byfunc.dim && !er.byexp.dim)\n         return false;\n@@ -789,8 +794,18 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag)\n \n         Dsymbol p = v.toParent2();\n \n+        if (vaIsFirstRef && v.isParameter() &&\n+            !(v.storage_class & STC.return_) &&\n+            fd.flags & FUNCFLAG.returnInprocess &&\n+            p == fd)\n+        {\n+            //if (log) printf(\"inferring 'return' for parameter %s in function %s\\n\", v.toChars(), fd.toChars());\n+            inferReturn(fd, v, /*returnScope:*/ false);\n+        }\n+\n         // If va's lifetime encloses v's, then error\n         if (va &&\n+            !(vaIsFirstRef && (v.storage_class & STC.return_)) &&\n             (va.enclosesLifetimeOf(v) || (va.isReference() && !(va.storage_class & STC.temp)) || va.isDataseg()) &&\n             fd.setUnsafe())\n         {"}, {"sha": "24030eb42d029a5d08f90e05672a477ca66b28a2", "filename": "gcc/d/dmd/expression.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fexpression.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fexpression.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -1660,6 +1660,7 @@ extern (C++) abstract class Expression : ASTNode\n         inout(MixinExp)     isMixinExp() { return op == EXP.mixin_ ? cast(typeof(return))this : null; }\n         inout(ImportExp)    isImportExp() { return op == EXP.import_ ? cast(typeof(return))this : null; }\n         inout(AssertExp)    isAssertExp() { return op == EXP.assert_ ? cast(typeof(return))this : null; }\n+        inout(ThrowExp)     isThrowExp() { return op == EXP.throw_ ? cast(typeof(return))this : null; }\n         inout(DotIdExp)     isDotIdExp() { return op == EXP.dotIdentifier ? cast(typeof(return))this : null; }\n         inout(DotTemplateExp) isDotTemplateExp() { return op == EXP.dotTemplateDeclaration ? cast(typeof(return))this : null; }\n         inout(DotVarExp)    isDotVarExp() { return op == EXP.dotVariable ? cast(typeof(return))this : null; }\n@@ -2684,7 +2685,7 @@ extern (C++) final class StringExp : Expression\n         const len2 = se2.len;\n \n         assert(this.sz == se2.sz, \"Comparing string expressions of different sizes\");\n-        //printf(\"sz = %d, len1 = %d, len2 = %d\\n\", sz, (int)len1, (int)len2);\n+        //printf(\"sz = %d, len1 = %d, len2 = %d\\n\", sz, cast(int)len1, cast(int)len2);\n         if (len1 == len2)\n         {\n             switch (sz)"}, {"sha": "64cd7ab849c076adf276cd72d5fa0753cf03ddf5", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 79, "deletions": 81, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -56,6 +56,7 @@ import dmd.initsem;\n import dmd.inline;\n import dmd.intrange;\n import dmd.mtype;\n+import dmd.mustuse;\n import dmd.nspace;\n import dmd.opover;\n import dmd.optimize;\n@@ -713,7 +714,7 @@ private Expression resolveUFCSProperties(Scope* sc, Expression e1, Expression e2\n  */\n Expression resolvePropertiesOnly(Scope* sc, Expression e1)\n {\n-    //printf(\"e1 = %s %s\\n\", Token::toChars(e1.op), e1.toChars());\n+    //printf(\"e1 = %s %s\\n\", Token.toChars(e1.op), e1.toChars());\n \n     Expression handleOverloadSet(OverloadSet os)\n     {\n@@ -2033,7 +2034,7 @@ private bool functionParameters(const ref Loc loc, Scope* sc,\n                  * Check arg to see if it matters.\n                  */\n                 if (global.params.useDIP1000 == FeatureState.enabled)\n-                    err |= checkParamArgumentReturn(sc, firstArg, arg, false);\n+                    err |= checkParamArgumentReturn(sc, firstArg, arg, p, false);\n             }\n             else if (tf.parameterEscapes(tthis, p))\n             {\n@@ -3261,7 +3262,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 // printf(\"apply fix for issue 9490: add `this.` to `%s`...\\n\", e.toChars());\n                 e = new DotVarExp(exp.loc, new ThisExp(exp.loc), ve.var, false);\n             }\n-            //printf(\"e = %s %s\\n\", Token::toChars(e.op), e.toChars());\n+            //printf(\"e = %s %s\\n\", Token.toChars(e.op), e.toChars());\n             e = e.expressionSemantic(sc);\n         }\n         else if (t)\n@@ -6032,7 +6033,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             auto fileName = FileName(name.toDString);\n             if (auto fmResult = global.fileManager.lookup(fileName))\n             {\n-                se = new StringExp(e.loc, fmResult.data);\n+                se = new StringExp(e.loc, fmResult);\n             }\n             else\n             {\n@@ -6047,9 +6048,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                     // take ownership of buffer (probably leaking)\n                     auto data = readResult.extractSlice();\n                     se = new StringExp(e.loc, data);\n-\n-                    FileBuffer* fileBuffer = new FileBuffer(data);\n-                    global.fileManager.add(fileName, fileBuffer);\n+                    global.fileManager.add(fileName, data);\n                 }\n             }\n         }\n@@ -6388,7 +6387,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         static if (LOGSEMANTIC)\n         {\n             printf(\"DotIdExp::semantic(this = %p, '%s')\\n\", exp, exp.toChars());\n-            //printf(\"e1.op = %d, '%s'\\n\", e1.op, Token::toChars(e1.op));\n+            //printf(\"e1.op = %d, '%s'\\n\", e1.op, Token.toChars(e1.op));\n         }\n \n         if (sc.flags & SCOPE.Cfile)\n@@ -8177,7 +8176,10 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             return;\n \n         if (e.type is Type.tvoid)\n+        {\n+            checkMustUse(e.e1, sc);\n             discardValue(e.e1);\n+        }\n         else if (!e.allowCommaExp && !e.isGenerated)\n             e.error(\"Using the result of a comma expression is not allowed\");\n     }\n@@ -8956,7 +8958,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n                     Parameter arg = Parameter.getNth(tt.arguments, u);\n                     //printf(\"[%d] iexps.dim = %d, \", u, iexps.dim);\n-                    //printf(\"e = (%s %s, %s), \", Token::tochars[e.op], e.toChars(), e.type.toChars());\n+                    //printf(\"e = (%s %s, %s), \", Token.toChars[e.op], e.toChars(), e.type.toChars());\n                     //printf(\"arg = (%s, %s)\\n\", arg.toChars(), arg.type.toChars());\n \n                     if (!arg || !e.type.implicitConvTo(arg.type))\n@@ -9849,7 +9851,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n          * `reorderSettingAAElem` creates a tree of comma expressions, however,\n          * `checkAssignExp` expects only AssignExps.\n          */\n-        checkAssignEscape(sc, Expression.extractLast(res, tmp), false);\n+        checkAssignEscape(sc, Expression.extractLast(res, tmp), false, false);\n \n         if (auto ae = res.isConstructExp())\n         {\n@@ -10124,7 +10126,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                  */\n                 if (isRecursiveAliasThis(exp.att1, exp.e1.type))\n                     return null;\n-                //printf(\"att %s e1 = %s\\n\", Token::toChars(e.op), e.e1.type.toChars());\n+                //printf(\"att %s e1 = %s\\n\", Token.toChars(e.op), e.e1.type.toChars());\n                 Expression e1 = new DotIdExp(exp.loc, exp.e1, ad1.aliasthis.ident);\n                 BinExp be = cast(BinExp)exp.copy();\n                 be.e1 = e1;\n@@ -10142,7 +10144,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                  */\n                 if (isRecursiveAliasThis(exp.att2, exp.e2.type))\n                     return null;\n-                //printf(\"att %s e2 = %s\\n\", Token::toChars(e.op), e.e2.type.toChars());\n+                //printf(\"att %s e2 = %s\\n\", Token.toChars(e.op), e.e2.type.toChars());\n                 Expression e2 = new DotIdExp(exp.loc, exp.e2, ad2.aliasthis.ident);\n                 BinExp be = cast(BinExp)exp.copy();\n                 be.e2 = e2;\n@@ -10169,7 +10171,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         auto res = exp.reorderSettingAAElem(sc);\n         if ((exp.op == EXP.concatenateElemAssign || exp.op == EXP.concatenateDcharAssign) &&\n             global.params.useDIP1000 == FeatureState.enabled)\n-            checkAssignEscape(sc, res, false);\n+            checkAssignEscape(sc, res, false, false);\n         result = res;\n     }\n \n@@ -12803,129 +12805,125 @@ bool checkSharedAccess(Expression e, Scope* sc, bool returnRef = false)\n         return false;\n     }\n \n-    //printf(\"checkSharedAccess() %s\\n\", e.toChars());\n-\n-    static extern(C++) final class SharedCheckVisitor : SemanticTimeTransitiveVisitor\n-    {\n-        /// In case we don't know which expression triggered it,\n-        /// e.g. for `visit(Type)` overload\n-        Expression original;\n-        /// Where the result is stored (`true` == error)\n-        bool result;\n-        /// Whether we should allow one level of dereferencing\n-        bool allowRef;\n+    //printf(\"checkSharedAccess() `%s` returnRef: %d\\n\", e.toChars(), returnRef);\n \n-        /// Ctor\n-        this(Expression oe, bool allowRef_)\n-        {\n-            this.original = oe;\n-            this.allowRef = allowRef_;\n-        }\n+    /* In case we don't know which expression triggered it,\n+     * e.g. for `visit(Type)` overload\n+     */\n+    Expression original = e;\n \n-        void sharedError(Expression e)\n+    bool check(Expression e, bool allowRef)\n+    {\n+        bool sharedError(Expression e)\n         {\n             // https://dlang.org/phobos/core_atomic.html\n             e.error(\"direct access to shared `%s` is not allowed, see `core.atomic`\", e.toChars());\n-            this.result = true;\n+            return true;\n         }\n \n-        /// Introduce base class overrides\n-        alias visit = SemanticTimeTransitiveVisitor.visit;\n-\n         // Error by default\n-        override void visit(Expression e)\n+        bool visit(Expression e)\n         {\n             if (e.type.isShared())\n-                this.sharedError(e);\n+                return sharedError(e);\n+            return false;\n         }\n \n-        /// Ditto\n-        override void visit(Type t)\n+        bool visitNew(NewExp e)\n         {\n+            if (e.thisexp)\n+                check(e.thisexp, false);\n             // Note: This handles things like `new shared(Throwable).msg`,\n             // where accessing `msg` would violate `shared`.\n-            if (t.isShared())\n-                this.sharedError(this.original);\n+            if (e.newtype.isShared())\n+                return sharedError(original);\n+            return false;\n         }\n \n-        // Those have no indirections / can be ignored\n-        override void visit(ErrorExp e) {}\n-        override void visit(ComplexExp e) {}\n-        override void visit(IntegerExp e) {}\n-        override void visit(NullExp e) {}\n-\n-        override void visit(VarExp e)\n+        bool visitVar(VarExp e)\n         {\n-            if (!this.allowRef && e.var.type.isShared())\n-                this.sharedError(e);\n+            if (!allowRef && e.var.type.isShared())\n+                return sharedError(e);\n+            return false;\n         }\n \n-        override void visit(AddrExp e)\n+        bool visitAddr(AddrExp e)\n         {\n-            this.allowRef = true;\n-            e.e1.accept(this);\n+            return check(e.e1, true);\n         }\n \n-        override void visit(PtrExp e)\n+        bool visitPtr(PtrExp e)\n         {\n-            if (!this.allowRef && e.type.isShared())\n-                return this.sharedError(e);\n+            if (!allowRef && e.type.isShared())\n+                return sharedError(e);\n \n             if (e.e1.type.isShared())\n-                return this.sharedError(e);\n+                return sharedError(e);\n \n-            this.allowRef = false;\n-            e.e1.accept(this);\n+            return check(e.e1, false);\n         }\n \n-        override void visit(DotVarExp e)\n+        bool visitDotVar(DotVarExp e)\n         {\n             auto fd = e.var.isFuncDeclaration();\n             const sharedFunc = fd && fd.type.isShared;\n \n-            if (!this.allowRef && e.type.isShared() && !sharedFunc)\n-                return this.sharedError(e);\n+            if (!allowRef && e.type.isShared() && !sharedFunc)\n+                return sharedError(e);\n \n-            // Allow to use `DotVarExp` within value types\n-            if (e.e1.type.ty == Tsarray || e.e1.type.ty == Tstruct)\n-                return e.e1.accept(this);\n+            // Allow using `DotVarExp` within value types\n+            if (e.e1.type.isTypeSArray() || e.e1.type.isTypeStruct())\n+                return check(e.e1, allowRef);\n \n             // If we end up with a single `VarExp`, it might be a `ref` param\n             // `shared ref T` param == `shared(T)*`.\n             if (auto ve = e.e1.isVarExp())\n             {\n-                this.allowRef = this.allowRef && (ve.var.storage_class & STC.ref_);\n-                return e.e1.accept(this);\n+                return check(e.e1, allowRef && (ve.var.storage_class & STC.ref_));\n             }\n \n-            this.allowRef = false;\n-            return e.e1.accept(this);\n+            return check(e.e1, false);\n         }\n \n-        override void visit(IndexExp e)\n+        bool visitIndex(IndexExp e)\n         {\n-            if (!this.allowRef && e.type.isShared())\n-                return this.sharedError(e);\n+            if (!allowRef && e.type.isShared())\n+                return sharedError(e);\n \n             if (e.e1.type.isShared())\n-                return this.sharedError(e);\n+                return sharedError(e);\n \n-            this.allowRef = false;\n-            e.e1.accept(this);\n+            return check(e.e1, false);\n         }\n \n-        override void visit(CommaExp e)\n+        bool visitComma(CommaExp e)\n         {\n             // Cannot be `return ref` since we can't use the return,\n             // but it's better to show that error than an unrelated `shared` one\n-            this.allowRef = true;\n-            e.e2.accept(this);\n+            return check(e.e2, true);\n+        }\n+\n+        switch (e.op)\n+        {\n+            default:              return visit(e);\n+\n+            // Those have no indirections / can be ignored\n+            case EXP.call:\n+            case EXP.error:\n+            case EXP.complex80:\n+            case EXP.int64:\n+            case EXP.null_:       return false;\n+\n+            case EXP.variable:    return visitVar(e.isVarExp());\n+            case EXP.new_:        return visitNew(e.isNewExp());\n+            case EXP.address:     return visitAddr(e.isAddrExp());\n+            case EXP.star:        return visitPtr(e.isPtrExp());\n+            case EXP.dotVariable: return visitDotVar(e.isDotVarExp());\n+            case EXP.index:       return visitIndex(e.isIndexExp());\n         }\n     }\n \n-    scope visitor = new SharedCheckVisitor(e, returnRef);\n-    e.accept(visitor);\n-    return visitor.result;\n+    return check(e, returnRef);\n }\n \n "}, {"sha": "9fe40bf06036f28de425e9fbd1e4b3494872f394", "filename": "gcc/d/dmd/file_manager.d", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Ffile_manager.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Ffile_manager.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffile_manager.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -11,7 +11,7 @@\n module dmd.file_manager;\n \n import dmd.root.stringtable : StringTable;\n-import dmd.root.file : File, FileBuffer;\n+import dmd.root.file : File, Buffer;\n import dmd.root.filename : FileName;\n import dmd.root.string : toDString;\n import dmd.globals;\n@@ -22,7 +22,7 @@ enum package_di = \"package.\" ~ hdr_ext;\n \n final class FileManager\n {\n-    private StringTable!(FileBuffer*) files;\n+    private StringTable!(const(ubyte)[]) files;\n \n     ///\n     public this () nothrow\n@@ -146,15 +146,15 @@ nothrow:\n      * Returns: the loaded source file if it was found in memory,\n      *      otherwise `null`\n      */\n-    const(FileBuffer)* lookup(FileName filename)\n+    const(ubyte)[] lookup(FileName filename)\n     {\n         const name = filename.toString;\n         if (auto val = files.lookup(name))\n             return val.value;\n \n         if (name == \"__stdin.d\")\n         {\n-            auto buffer = new FileBuffer(readFromStdin().extractSlice());\n+            auto buffer = readFromStdin().extractSlice();\n             if (this.files.insert(name, buffer) is null)\n                 assert(0, \"stdin: Insert after lookup failure should never return `null`\");\n             return buffer;\n@@ -167,7 +167,7 @@ nothrow:\n         if (!readResult.success)\n             return null;\n \n-        FileBuffer* fb = new FileBuffer(readResult.extractSlice());\n+        auto fb = readResult.extractSlice();\n         if (files.insert(name, fb) is null)\n             assert(0, \"Insert after lookup failure should never return `null`\");\n \n@@ -187,17 +187,17 @@ nothrow:\n         const(char)[][] lines;\n         if (const buffer = lookup(file))\n         {\n-            const slice = buffer.data[0 .. buffer.data.length];\n+            const slice = buffer;\n             size_t start, end;\n-            ubyte c;\n             for (auto i = 0; i < slice.length; i++)\n             {\n-                c = slice[i];\n+                const c = slice[i];\n                 if (c == '\\n' || c == '\\r')\n                 {\n                     if (i != 0)\n                     {\n                         end = i;\n+                        // Appending lines one at a time will certainly be slow\n                         lines ~= cast(const(char)[])slice[start .. end];\n                     }\n                     // Check for Windows-style CRLF newlines\n@@ -234,18 +234,21 @@ nothrow:\n     }\n \n     /**\n-     * Adds a FileBuffer to the table.\n-     *\n-     * Returns: The FileBuffer added, or null\n+     * Adds the contents of a file to the table.\n+     * Params:\n+     *  filename = name of the file\n+     *  buffer = contents of the file\n+     * Returns:\n+     *  the buffer added, or null\n      */\n-    FileBuffer* add(FileName filename, FileBuffer* filebuffer)\n+    const(ubyte)[] add(FileName filename, const(ubyte)[] buffer)\n     {\n-        auto val = files.insert(filename.toString, filebuffer);\n+        auto val = files.insert(filename.toString, buffer);\n         return val == null ? null : val.value;\n     }\n }\n \n-private FileBuffer readFromStdin() nothrow\n+private Buffer readFromStdin() nothrow\n {\n     import core.stdc.stdio;\n     import dmd.errors;\n@@ -277,7 +280,7 @@ private FileBuffer readFromStdin() nothrow\n                 // We're done\n                 assert(pos < sz + 2);\n                 buffer[pos .. pos + 4] = '\\0';\n-                return FileBuffer(buffer[0 .. pos]);\n+                return Buffer(buffer[0 .. pos]);\n             }\n         } while (pos < sz);\n "}, {"sha": "69fdf27e1dbd9af39846306a1e49243e57136319", "filename": "gcc/d/dmd/hdrgen.d", "status": "modified", "additions": 183, "deletions": 99, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fhdrgen.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fhdrgen.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -1538,6 +1538,13 @@ public:\n             }\n             else if (hgs.tpltMember == 0 && global.params.hdrStripPlainFunctions)\n             {\n+                if (!f.fbody)\n+                {\n+                    // this can happen on interfaces / abstract functions, see `allowsContractWithoutBody`\n+                    if (f.fensures || f.frequires)\n+                        buf.writenl();\n+                    contractsToBuffer(f);\n+                }\n                 buf.writeByte(';');\n                 buf.writenl();\n             }\n@@ -1548,19 +1555,9 @@ public:\n             bodyToBuffer(f);\n     }\n \n-    void bodyToBuffer(FuncDeclaration f)\n+    /// Returns: whether `do` is needed to write the function body\n+    bool contractsToBuffer(FuncDeclaration f)\n     {\n-        if (!f.fbody || (hgs.hdrgen && global.params.hdrStripPlainFunctions && !hgs.autoMember && !hgs.tpltMember))\n-        {\n-            buf.writeByte(';');\n-            buf.writenl();\n-            return;\n-        }\n-        const savetlpt = hgs.tpltMember;\n-        const saveauto = hgs.autoMember;\n-        hgs.tpltMember = 0;\n-        hgs.autoMember = 0;\n-        buf.writenl();\n         bool requireDo = false;\n         // in{}\n         if (f.frequires)\n@@ -1619,6 +1616,29 @@ public:\n                 }\n             }\n         }\n+        return requireDo;\n+    }\n+\n+    void bodyToBuffer(FuncDeclaration f)\n+    {\n+        if (!f.fbody || (hgs.hdrgen && global.params.hdrStripPlainFunctions && !hgs.autoMember && !hgs.tpltMember))\n+        {\n+            if (!f.fbody && (f.fensures || f.frequires))\n+            {\n+                buf.writenl();\n+                contractsToBuffer(f);\n+            }\n+            buf.writeByte(';');\n+            buf.writenl();\n+            return;\n+        }\n+        const savetlpt = hgs.tpltMember;\n+        const saveauto = hgs.autoMember;\n+        hgs.tpltMember = 0;\n+        hgs.autoMember = 0;\n+        buf.writenl();\n+        bool requireDo = contractsToBuffer(f);\n+\n         if (requireDo)\n         {\n             buf.writestring(\"do\");\n@@ -1788,26 +1808,17 @@ public:\n     }\n }\n \n-private extern (C++) final class ExpressionPrettyPrintVisitor : Visitor\n+/*********************************************\n+ * Print expression to buffer.\n+ */\n+private void expressionPrettyPrint(Expression e, OutBuffer* buf, HdrGenState* hgs)\n {\n-    alias visit = Visitor.visit;\n-public:\n-    OutBuffer* buf;\n-    HdrGenState* hgs;\n-\n-    extern (D) this(OutBuffer* buf, HdrGenState* hgs)\n-    {\n-        this.buf = buf;\n-        this.hgs = hgs;\n-    }\n-\n-    ////////////////////////////////////////////////////////////////////////////\n-    override void visit(Expression e)\n+    void visit(Expression e)\n     {\n         buf.writestring(EXPtoString(e.op));\n     }\n \n-    override void visit(IntegerExp e)\n+    void visitInteger(IntegerExp e)\n     {\n         const dinteger_t v = e.toInteger();\n         if (e.type)\n@@ -1907,12 +1918,12 @@ public:\n             buf.print(v);\n     }\n \n-    override void visit(ErrorExp e)\n+    void visitError(ErrorExp e)\n     {\n         buf.writestring(\"__error\");\n     }\n \n-    override void visit(VoidInitExp e)\n+    void visitVoidInit(VoidInitExp e)\n     {\n         buf.writestring(\"__void\");\n     }\n@@ -1922,12 +1933,12 @@ public:\n         .floatToBuffer(type, value, buf, hgs.hdrgen);\n     }\n \n-    override void visit(RealExp e)\n+    void visitReal(RealExp e)\n     {\n         floatToBuffer(e.type, e.value);\n     }\n \n-    override void visit(ComplexExp e)\n+    void visitComplex(ComplexExp e)\n     {\n         /* Print as:\n          *  (re+imi)\n@@ -1939,35 +1950,35 @@ public:\n         buf.writestring(\"i)\");\n     }\n \n-    override void visit(IdentifierExp e)\n+    void visitIdentifier(IdentifierExp e)\n     {\n         if (hgs.hdrgen || hgs.ddoc)\n             buf.writestring(e.ident.toHChars2());\n         else\n             buf.writestring(e.ident.toString());\n     }\n \n-    override void visit(DsymbolExp e)\n+    void visitDsymbol(DsymbolExp e)\n     {\n         buf.writestring(e.s.toChars());\n     }\n \n-    override void visit(ThisExp e)\n+    void visitThis(ThisExp e)\n     {\n         buf.writestring(\"this\");\n     }\n \n-    override void visit(SuperExp e)\n+    void visitSuper(SuperExp e)\n     {\n         buf.writestring(\"super\");\n     }\n \n-    override void visit(NullExp e)\n+    void visitNull(NullExp e)\n     {\n         buf.writestring(\"null\");\n     }\n \n-    override void visit(StringExp e)\n+    void visitString(StringExp e)\n     {\n         buf.writeByte('\"');\n         const o = buf.length;\n@@ -1982,14 +1993,14 @@ public:\n             buf.writeByte(e.postfix);\n     }\n \n-    override void visit(ArrayLiteralExp e)\n+    void visitArrayLiteral(ArrayLiteralExp e)\n     {\n         buf.writeByte('[');\n         argsToBuffer(e.elements, buf, hgs, e.basis);\n         buf.writeByte(']');\n     }\n \n-    override void visit(AssocArrayLiteralExp e)\n+    void visitAssocArrayLiteral(AssocArrayLiteralExp e)\n     {\n         buf.writeByte('[');\n         foreach (i, key; *e.keys)\n@@ -2004,7 +2015,7 @@ public:\n         buf.writeByte(']');\n     }\n \n-    override void visit(StructLiteralExp e)\n+    void visitStructLiteral(StructLiteralExp e)\n     {\n         buf.writestring(e.sd.toChars());\n         buf.writeByte('(');\n@@ -2024,20 +2035,20 @@ public:\n         buf.writeByte(')');\n     }\n \n-    override void visit(CompoundLiteralExp e)\n+    void visitCompoundLiteral(CompoundLiteralExp e)\n     {\n         buf.writeByte('(');\n         typeToBuffer(e.type, null, buf, hgs);\n         buf.writeByte(')');\n         e.initializer.initializerToBuffer(buf, hgs);\n     }\n \n-    override void visit(TypeExp e)\n+    void visitType(TypeExp e)\n     {\n         typeToBuffer(e.type, null, buf, hgs);\n     }\n \n-    override void visit(ScopeExp e)\n+    void visitScope(ScopeExp e)\n     {\n         if (e.sds.isTemplateInstance())\n         {\n@@ -2059,12 +2070,12 @@ public:\n         }\n     }\n \n-    override void visit(TemplateExp e)\n+    void visitTemplate(TemplateExp e)\n     {\n         buf.writestring(e.td.toChars());\n     }\n \n-    override void visit(NewExp e)\n+    void visitNew(NewExp e)\n     {\n         if (e.thisexp)\n         {\n@@ -2081,7 +2092,7 @@ public:\n         }\n     }\n \n-    override void visit(NewAnonClassExp e)\n+    void visitNewAnonClass(NewAnonClassExp e)\n     {\n         if (e.thisexp)\n         {\n@@ -2100,7 +2111,7 @@ public:\n             e.cd.dsymbolToBuffer(buf, hgs);\n     }\n \n-    override void visit(SymOffExp e)\n+    void visitSymOff(SymOffExp e)\n     {\n         if (e.offset)\n             buf.printf(\"(& %s%+lld)\", e.var.toChars(), e.offset);\n@@ -2110,22 +2121,22 @@ public:\n             buf.printf(\"& %s\", e.var.toChars());\n     }\n \n-    override void visit(VarExp e)\n+    void visitVar(VarExp e)\n     {\n         buf.writestring(e.var.toChars());\n     }\n \n-    override void visit(OverExp e)\n+    void visitOver(OverExp e)\n     {\n         buf.writestring(e.vars.ident.toString());\n     }\n \n-    override void visit(TupleExp e)\n+    void visitTuple(TupleExp e)\n     {\n         if (e.e0)\n         {\n             buf.writeByte('(');\n-            e.e0.accept(this);\n+            e.e0.expressionPrettyPrint(buf, hgs);\n             buf.writestring(\", tuple(\");\n             argsToBuffer(e.exps, buf, hgs);\n             buf.writestring(\"))\");\n@@ -2138,13 +2149,13 @@ public:\n         }\n     }\n \n-    override void visit(FuncExp e)\n+    void visitFunc(FuncExp e)\n     {\n         e.fd.dsymbolToBuffer(buf, hgs);\n         //buf.writestring(e.fd.toChars());\n     }\n \n-    override void visit(DeclarationExp e)\n+    void visitDeclaration(DeclarationExp e)\n     {\n         /* Normal dmd execution won't reach here - regular variable declarations\n          * are handled in visit(ExpStatement), so here would be used only when\n@@ -2170,14 +2181,14 @@ public:\n         }\n     }\n \n-    override void visit(TypeidExp e)\n+    void visitTypeid(TypeidExp e)\n     {\n         buf.writestring(\"typeid(\");\n         objectToBuffer(e.obj, buf, hgs);\n         buf.writeByte(')');\n     }\n \n-    override void visit(TraitsExp e)\n+    void visitTraits(TraitsExp e)\n     {\n         buf.writestring(\"__traits(\");\n         if (e.ident)\n@@ -2193,12 +2204,12 @@ public:\n         buf.writeByte(')');\n     }\n \n-    override void visit(HaltExp e)\n+    void visitHalt(HaltExp e)\n     {\n         buf.writestring(\"halt\");\n     }\n \n-    override void visit(IsExp e)\n+    void visitIs(IsExp e)\n     {\n         buf.writestring(\"is(\");\n         typeToBuffer(e.targ, e.id, buf, hgs);\n@@ -2223,13 +2234,13 @@ public:\n         buf.writeByte(')');\n     }\n \n-    override void visit(UnaExp e)\n+    void visitUna(UnaExp e)\n     {\n         buf.writestring(EXPtoString(e.op));\n         expToBuffer(e.e1, precedence[e.op], buf, hgs);\n     }\n \n-    override void visit(BinExp e)\n+    void visitBin(BinExp e)\n     {\n         expToBuffer(e.e1, precedence[e.op], buf, hgs);\n         buf.writeByte(' ');\n@@ -2238,7 +2249,7 @@ public:\n         expToBuffer(e.e2, cast(PREC)(precedence[e.op] + 1), buf, hgs);\n     }\n \n-    override void visit(CommaExp e)\n+    void visitComma(CommaExp e)\n     {\n         // CommaExp is generated by the compiler so it shouldn't\n         // appear in error messages or header files.\n@@ -2251,7 +2262,7 @@ public:\n         // the old path\n         if (!ve || !(ve.var.storage_class & STC.temp))\n         {\n-            visit(cast(BinExp)e);\n+            visitBin(cast(BinExp)e);\n             return;\n         }\n \n@@ -2281,25 +2292,25 @@ public:\n         }\n \n         // not one of the known cases, go on the old path\n-        visit(cast(BinExp)e);\n+        visitBin(cast(BinExp)e);\n         return;\n     }\n \n-    override void visit(MixinExp e)\n+    void visitMixin(MixinExp e)\n     {\n         buf.writestring(\"mixin(\");\n         argsToBuffer(e.exps, buf, hgs, null);\n         buf.writeByte(')');\n     }\n \n-    override void visit(ImportExp e)\n+    void visitImport(ImportExp e)\n     {\n         buf.writestring(\"import(\");\n         expToBuffer(e.e1, PREC.assign, buf, hgs);\n         buf.writeByte(')');\n     }\n \n-    override void visit(AssertExp e)\n+    void visitAssert(AssertExp e)\n     {\n         buf.writestring(\"assert(\");\n         expToBuffer(e.e1, PREC.assign, buf, hgs);\n@@ -2311,13 +2322,13 @@ public:\n         buf.writeByte(')');\n     }\n \n-    override void visit(ThrowExp e)\n+    void visitThrow(ThrowExp e)\n     {\n         buf.writestring(\"throw \");\n         expToBuffer(e.e1, PREC.unary, buf, hgs);\n     }\n \n-    override void visit(DotIdExp e)\n+    void visitDotId(DotIdExp e)\n     {\n         expToBuffer(e.e1, PREC.primary, buf, hgs);\n         if (e.arrow)\n@@ -2327,28 +2338,28 @@ public:\n         buf.writestring(e.ident.toString());\n     }\n \n-    override void visit(DotTemplateExp e)\n+    void visitDotTemplate(DotTemplateExp e)\n     {\n         expToBuffer(e.e1, PREC.primary, buf, hgs);\n         buf.writeByte('.');\n         buf.writestring(e.td.toChars());\n     }\n \n-    override void visit(DotVarExp e)\n+    void visitDotVar(DotVarExp e)\n     {\n         expToBuffer(e.e1, PREC.primary, buf, hgs);\n         buf.writeByte('.');\n         buf.writestring(e.var.toChars());\n     }\n \n-    override void visit(DotTemplateInstanceExp e)\n+    void visitDotTemplateInstance(DotTemplateInstanceExp e)\n     {\n         expToBuffer(e.e1, PREC.primary, buf, hgs);\n         buf.writeByte('.');\n         e.ti.dsymbolToBuffer(buf, hgs);\n     }\n \n-    override void visit(DelegateExp e)\n+    void visitDelegate(DelegateExp e)\n     {\n         buf.writeByte('&');\n         if (!e.func.isNested() || e.func.needThis())\n@@ -2359,14 +2370,14 @@ public:\n         buf.writestring(e.func.toChars());\n     }\n \n-    override void visit(DotTypeExp e)\n+    void visitDotType(DotTypeExp e)\n     {\n         expToBuffer(e.e1, PREC.primary, buf, hgs);\n         buf.writeByte('.');\n         buf.writestring(e.sym.toChars());\n     }\n \n-    override void visit(CallExp e)\n+    void visitCall(CallExp e)\n     {\n         if (e.e1.op == EXP.type)\n         {\n@@ -2375,7 +2386,7 @@ public:\n              * This is ok since types in constructor calls\n              * can never depend on parens anyway\n              */\n-            e.e1.accept(this);\n+            e.e1.expressionPrettyPrint(buf, hgs);\n         }\n         else\n             expToBuffer(e.e1, precedence[e.op], buf, hgs);\n@@ -2384,19 +2395,19 @@ public:\n         buf.writeByte(')');\n     }\n \n-    override void visit(PtrExp e)\n+    void visitPtr(PtrExp e)\n     {\n         buf.writeByte('*');\n         expToBuffer(e.e1, precedence[e.op], buf, hgs);\n     }\n \n-    override void visit(DeleteExp e)\n+    void visitDelete(DeleteExp e)\n     {\n         buf.writestring(\"delete \");\n         expToBuffer(e.e1, precedence[e.op], buf, hgs);\n     }\n \n-    override void visit(CastExp e)\n+    void visitCast(CastExp e)\n     {\n         buf.writestring(\"cast(\");\n         if (e.to)\n@@ -2409,21 +2420,21 @@ public:\n         expToBuffer(e.e1, precedence[e.op], buf, hgs);\n     }\n \n-    override void visit(VectorExp e)\n+    void visitVector(VectorExp e)\n     {\n         buf.writestring(\"cast(\");\n         typeToBuffer(e.to, null, buf, hgs);\n         buf.writeByte(')');\n         expToBuffer(e.e1, precedence[e.op], buf, hgs);\n     }\n \n-    override void visit(VectorArrayExp e)\n+    void visitVectorArray(VectorArrayExp e)\n     {\n         expToBuffer(e.e1, PREC.primary, buf, hgs);\n         buf.writestring(\".array\");\n     }\n \n-    override void visit(SliceExp e)\n+    void visitSlice(SliceExp e)\n     {\n         expToBuffer(e.e1, precedence[e.op], buf, hgs);\n         buf.writeByte('[');\n@@ -2442,75 +2453,75 @@ public:\n         buf.writeByte(']');\n     }\n \n-    override void visit(ArrayLengthExp e)\n+    void visitArrayLength(ArrayLengthExp e)\n     {\n         expToBuffer(e.e1, PREC.primary, buf, hgs);\n         buf.writestring(\".length\");\n     }\n \n-    override void visit(IntervalExp e)\n+    void visitInterval(IntervalExp e)\n     {\n         expToBuffer(e.lwr, PREC.assign, buf, hgs);\n         buf.writestring(\"..\");\n         expToBuffer(e.upr, PREC.assign, buf, hgs);\n     }\n \n-    override void visit(DelegatePtrExp e)\n+    void visitDelegatePtr(DelegatePtrExp e)\n     {\n         expToBuffer(e.e1, PREC.primary, buf, hgs);\n         buf.writestring(\".ptr\");\n     }\n \n-    override void visit(DelegateFuncptrExp e)\n+    void visitDelegateFuncptr(DelegateFuncptrExp e)\n     {\n         expToBuffer(e.e1, PREC.primary, buf, hgs);\n         buf.writestring(\".funcptr\");\n     }\n \n-    override void visit(ArrayExp e)\n+    void visitArray(ArrayExp e)\n     {\n         expToBuffer(e.e1, PREC.primary, buf, hgs);\n         buf.writeByte('[');\n         argsToBuffer(e.arguments, buf, hgs);\n         buf.writeByte(']');\n     }\n \n-    override void visit(DotExp e)\n+    void visitDot(DotExp e)\n     {\n         expToBuffer(e.e1, PREC.primary, buf, hgs);\n         buf.writeByte('.');\n         expToBuffer(e.e2, PREC.primary, buf, hgs);\n     }\n \n-    override void visit(IndexExp e)\n+    void visitIndex(IndexExp e)\n     {\n         expToBuffer(e.e1, PREC.primary, buf, hgs);\n         buf.writeByte('[');\n         sizeToBuffer(e.e2, buf, hgs);\n         buf.writeByte(']');\n     }\n \n-    override void visit(PostExp e)\n+    void visitPost(PostExp e)\n     {\n         expToBuffer(e.e1, precedence[e.op], buf, hgs);\n         buf.writestring(EXPtoString(e.op));\n     }\n \n-    override void visit(PreExp e)\n+    void visitPre(PreExp e)\n     {\n         buf.writestring(EXPtoString(e.op));\n         expToBuffer(e.e1, precedence[e.op], buf, hgs);\n     }\n \n-    override void visit(RemoveExp e)\n+    void visitRemove(RemoveExp e)\n     {\n         expToBuffer(e.e1, PREC.primary, buf, hgs);\n         buf.writestring(\".remove(\");\n         expToBuffer(e.e2, PREC.assign, buf, hgs);\n         buf.writeByte(')');\n     }\n \n-    override void visit(CondExp e)\n+    void visitCond(CondExp e)\n     {\n         expToBuffer(e.econd, PREC.oror, buf, hgs);\n         buf.writestring(\" ? \");\n@@ -2519,15 +2530,90 @@ public:\n         expToBuffer(e.e2, PREC.cond, buf, hgs);\n     }\n \n-    override void visit(DefaultInitExp e)\n+    void visitDefaultInit(DefaultInitExp e)\n     {\n         buf.writestring(EXPtoString(e.op));\n     }\n \n-    override void visit(ClassReferenceExp e)\n+    void visitClassReference(ClassReferenceExp e)\n     {\n         buf.writestring(e.value.toChars());\n     }\n+\n+    switch (e.op)\n+    {\n+        default:\n+            if (auto be = e.isBinExp())\n+                return visitBin(be);\n+            else if (auto ue = e.isUnaExp())\n+                return visitUna(ue);\n+            else if (auto de = e.isDefaultInitExp())\n+                return visitDefaultInit(e.isDefaultInitExp());\n+            return visit(e);\n+\n+        case EXP.int64:         return visitInteger(e.isIntegerExp());\n+        case EXP.error:         return visitError(e.isErrorExp());\n+        case EXP.void_:         return visitVoidInit(e.isVoidInitExp());\n+        case EXP.float64:       return visitReal(e.isRealExp());\n+        case EXP.complex80:     return visitComplex(e.isComplexExp());\n+        case EXP.identifier:    return visitIdentifier(e.isIdentifierExp());\n+        case EXP.dSymbol:       return visitDsymbol(e.isDsymbolExp());\n+        case EXP.this_:         return visitThis(e.isThisExp());\n+        case EXP.super_:        return visitSuper(e.isSuperExp());\n+        case EXP.null_:         return visitNull(e.isNullExp());\n+        case EXP.string_:       return visitString(e.isStringExp());\n+        case EXP.arrayLiteral:  return visitArrayLiteral(e.isArrayLiteralExp());\n+        case EXP.assocArrayLiteral:     return visitAssocArrayLiteral(e.isAssocArrayLiteralExp());\n+        case EXP.structLiteral: return visitStructLiteral(e.isStructLiteralExp());\n+        case EXP.compoundLiteral:       return visitCompoundLiteral(e.isCompoundLiteralExp());\n+        case EXP.type:          return visitType(e.isTypeExp());\n+        case EXP.scope_:        return visitScope(e.isScopeExp());\n+        case EXP.template_:     return visitTemplate(e.isTemplateExp());\n+        case EXP.new_:          return visitNew(e.isNewExp());\n+        case EXP.newAnonymousClass:     return visitNewAnonClass(e.isNewAnonClassExp());\n+        case EXP.symbolOffset:  return visitSymOff(e.isSymOffExp());\n+        case EXP.variable:      return visitVar(e.isVarExp());\n+        case EXP.overloadSet:   return visitOver(e.isOverExp());\n+        case EXP.tuple:         return visitTuple(e.isTupleExp());\n+        case EXP.function_:     return visitFunc(e.isFuncExp());\n+        case EXP.declaration:   return visitDeclaration(e.isDeclarationExp());\n+        case EXP.typeid_:       return visitTypeid(e.isTypeidExp());\n+        case EXP.traits:        return visitTraits(e.isTraitsExp());\n+        case EXP.halt:          return visitHalt(e.isHaltExp());\n+        case EXP.is_:           return visitIs(e.isExp());\n+        case EXP.comma:         return visitComma(e.isCommaExp());\n+        case EXP.mixin_:        return visitMixin(e.isMixinExp());\n+        case EXP.import_:       return visitImport(e.isImportExp());\n+        case EXP.assert_:       return visitAssert(e.isAssertExp());\n+        case EXP.throw_:        return visitThrow(e.isThrowExp());\n+        case EXP.dotIdentifier: return visitDotId(e.isDotIdExp());\n+        case EXP.dotTemplateDeclaration:        return visitDotTemplate(e.isDotTemplateExp());\n+        case EXP.dotVariable:   return visitDotVar(e.isDotVarExp());\n+        case EXP.dotTemplateInstance:   return visitDotTemplateInstance(e.isDotTemplateInstanceExp());\n+        case EXP.delegate_:     return visitDelegate(e.isDelegateExp());\n+        case EXP.dotType:       return visitDotType(e.isDotTypeExp());\n+        case EXP.call:          return visitCall(e.isCallExp());\n+        case EXP.star:          return visitPtr(e.isPtrExp());\n+        case EXP.delete_:       return visitDelete(e.isDeleteExp());\n+        case EXP.cast_:         return visitCast(e.isCastExp());\n+        case EXP.vector:        return visitVector(e.isVectorExp());\n+        case EXP.vectorArray:   return visitVectorArray(e.isVectorArrayExp());\n+        case EXP.slice:         return visitSlice(e.isSliceExp());\n+        case EXP.arrayLength:   return visitArrayLength(e.isArrayLengthExp());\n+        case EXP.interval:      return visitInterval(e.isIntervalExp());\n+        case EXP.delegatePointer:       return visitDelegatePtr(e.isDelegatePtrExp());\n+        case EXP.delegateFunctionPointer:       return visitDelegateFuncptr(e.isDelegateFuncptrExp());\n+        case EXP.array:         return visitArray(e.isArrayExp());\n+        case EXP.dot:           return visitDot(e.isDotExp());\n+        case EXP.index:         return visitIndex(e.isIndexExp());\n+        case EXP.minusMinus:\n+        case EXP.plusPlus:      return visitPost(e.isPostExp());\n+        case EXP.preMinusMinus:\n+        case EXP.prePlusPlus:   return visitPre(e.isPreExp());\n+        case EXP.remove:        return visitRemove(e.isRemoveExp());\n+        case EXP.question:      return visitCond(e.isCondExp());\n+        case EXP.classReference:        return visitClassReference(e.isClassReferenceExp());\n+    }\n }\n \n /**\n@@ -2547,7 +2633,7 @@ void floatToBuffer(Type type, const real_t value, OutBuffer* buf, const bool all\n         (ie, 8 chars more than mantissa). Plus one for trailing \\0.\n         Plus one for rounding. */\n     const(size_t) BUFFER_LEN = value.sizeof * 3 + 8 + 1 + 1;\n-    char[BUFFER_LEN] buffer;\n+    char[BUFFER_LEN] buffer = void;\n     CTFloat.sprint(buffer.ptr, 'g', value);\n     assert(strlen(buffer.ptr) < BUFFER_LEN);\n     if (allowHex)\n@@ -2754,7 +2840,7 @@ bool stcToBuffer(OutBuffer* buf, StorageClass stc)\n     }\n     if (stc & STC.returninferred)\n     {\n-        //buf.writestring(\"return-inferred \");\n+        //buf.writestring((stc & STC.returnScope) ? \"return-scope-inferred \" : \"return-ref-inferred \");\n         stc &= ~(STC.return_ | STC.returninferred);\n     }\n \n@@ -2958,8 +3044,7 @@ void functionToBufferWithIdent(TypeFunction tf, OutBuffer* buf, const(char)* ide\n \n void toCBuffer(const Expression e, OutBuffer* buf, HdrGenState* hgs)\n {\n-    scope v = new ExpressionPrettyPrintVisitor(buf, hgs);\n-    (cast() e).accept(v);\n+    expressionPrettyPrint(cast()e, buf, hgs);\n }\n \n /**************************************************\n@@ -3221,8 +3306,7 @@ private void sizeToBuffer(Expression e, OutBuffer* buf, HdrGenState* hgs)\n \n private void expressionToBuffer(Expression e, OutBuffer* buf, HdrGenState* hgs)\n {\n-    scope v = new ExpressionPrettyPrintVisitor(buf, hgs);\n-    e.accept(v);\n+    expressionPrettyPrint(e, buf, hgs);\n }\n \n /**************************************************"}, {"sha": "11455afe263770003b194dfd16ad762c79daae58", "filename": "gcc/d/dmd/id.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fid.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -491,6 +491,7 @@ immutable Msgtable[] msgtable =\n     { \"udaGNUAbiTag\", \"gnuAbiTag\" },\n     { \"udaSelector\", \"selector\" },\n     { \"udaOptional\", \"optional\"},\n+    { \"udaMustUse\", \"mustuse\" },\n \n     // C names, for undefined identifier error messages\n     { \"NULL\" },"}, {"sha": "616712b463d81668817310cbe6c0f8b3292dc612", "filename": "gcc/d/dmd/initsem.d", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Finitsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Finitsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -554,26 +554,39 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                     i.exp = e.optimize(WANTvalue);\n             }\n         }\n+        {\n         // Look for the case of statically initializing an array\n         // with a single member.\n-        if (tb.ty == Tsarray && !tb.nextOf().equals(ti.toBasetype().nextOf()) && i.exp.implicitConvTo(tb.nextOf()))\n+        auto tba = tb.isTypeSArray();\n+        if (tba && !tba.next.equals(ti.toBasetype().nextOf()) && i.exp.implicitConvTo(tba.next))\n         {\n             /* If the variable is not actually used in compile time, array creation is\n              * redundant. So delay it until invocation of toExpression() or toDt().\n              */\n             t = tb.nextOf();\n         }\n+\n+        auto tta = t.isTypeSArray();\n         if (i.exp.implicitConvTo(t))\n         {\n             i.exp = i.exp.implicitCastTo(sc, t);\n         }\n+        else if (sc.flags & SCOPE.Cfile && i.exp.isStringExp() &&\n+            tta && (tta.next.ty == Tint8 || tta.next.ty == Tuns8) &&\n+            ti.ty == Tpointer && ti.nextOf().ty == Tchar)\n+        {\n+            /* unsigned char bbb[1] = \"\";\n+             *   signed char ccc[1] = \"\";\n+             */\n+            i.exp = i.exp.castTo(sc, t);\n+        }\n         else\n         {\n             // Look for mismatch of compile-time known length to emit\n             // better diagnostic message, as same as AssignExp::semantic.\n-            if (tb.ty == Tsarray && i.exp.implicitConvTo(tb.nextOf().arrayOf()) > MATCH.nomatch)\n+            if (tba && i.exp.implicitConvTo(tba.next.arrayOf()) > MATCH.nomatch)\n             {\n-                uinteger_t dim1 = tb.isTypeSArray().dim.toInteger();\n+                uinteger_t dim1 = tba.dim.toInteger();\n                 uinteger_t dim2 = dim1;\n                 if (auto ale = i.exp.isArrayLiteralExp())\n                 {\n@@ -596,6 +609,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n             if (global.endGagging(errors))\n                 currExp.error(\"cannot implicitly convert expression `%s` of type `%s` to `%s`\", currExp.toChars(), et.toChars(), t.toChars());\n         }\n+        }\n     L1:\n         if (i.exp.op == EXP.error)\n         {\n@@ -1059,7 +1073,7 @@ Initializer inferType(Initializer init, Scope* sc)\n \n     Initializer visitC(CInitializer i)\n     {\n-        //printf(CInitializer::inferType()\\n\");\n+        //printf(\"CInitializer.inferType()\\n\");\n         error(i.loc, \"TODO C inferType initializers not supported yet\");\n         return new ErrorInitializer();\n     }\n@@ -1331,6 +1345,10 @@ private bool hasNonConstPointers(Expression e)\n     }\n     if (auto ae = e.isAddrExp())\n     {\n+        if (ae.type.nextOf().isImmutable() || ae.type.nextOf().isConst())\n+        {\n+            return false;\n+        }\n         if (auto se = ae.e1.isStructLiteralExp())\n         {\n             if (!(se.stageflags & stageSearchPointers))"}, {"sha": "fc270390fa4ac18662696f36eea667828277a09e", "filename": "gcc/d/dmd/json.d", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fjson.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fjson.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fjson.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -319,10 +319,7 @@ public:\n             // Should not be printed\n             //property(name, \"d\");\n             break;\n-        case LINK.system:\n-            // Should not be printed\n-            //property(name, \"system\");\n-            break;\n+        case LINK.system:   return property(name, \"system\");\n         case LINK.c:        return property(name, \"c\");\n         case LINK.cpp:      return property(name, \"cpp\");\n         case LINK.windows:  return property(name, \"windows\");"}, {"sha": "b778bc82d77ca61bd5993dae22f4b8dbf5e09776", "filename": "gcc/d/dmd/lexer.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -108,8 +108,8 @@ class Lexer\n         size_t endoffset, bool doDocComment, bool commentToken) pure\n     {\n         scanloc = Loc(filename, 1, 1);\n-        //printf(\"Lexer::Lexer(%p,%d)\\n\",base,length);\n-        //printf(\"lexer.filename = %s\\n\", filename);\n+        // debug printf(\"Lexer::Lexer(%p)\\n\", base);\n+        // debug printf(\"lexer.filename = %s\\n\", filename);\n         token = Token.init;\n         this.base = base;\n         this.end = base + endoffset;\n@@ -2122,7 +2122,7 @@ class Lexer\n                 // can't translate invalid octal value, just show a generic message\n                 error(\"octal literals larger than 7 are no longer supported\");\n             else\n-                error(\"octal literals `0%llo%.*s` are no longer supported, use `std.conv.octal!%llo%.*s` instead\",\n+                error(\"octal literals `0%llo%.*s` are no longer supported, use `std.conv.octal!\\\"%llo%.*s\\\"` instead\",\n                     n, cast(int)(p - psuffix), psuffix, n, cast(int)(p - psuffix), psuffix);\n         }\n         TOK result;\n@@ -2926,7 +2926,7 @@ class Lexer\n      */\n     static const(char)* combineComments(const(char)[] c1, const(char)[] c2, bool newParagraph) pure\n     {\n-        //printf(\"Lexer::combineComments('%s', '%s', '%i')\\n\", c1, c2, newParagraph);\n+        //debug printf(\"Lexer::combineComments('%*.s', '%*.s', '%i')\\n\", cast(int) c1.length, c1.ptr, cast(int) c2.length, c2.ptr, newParagraph);\n         const(int) newParagraphSize = newParagraph ? 1 : 0; // Size of the combining '\\n'\n         if (!c1)\n             return c2.ptr;"}, {"sha": "50dd20b70b991a2a6cbaed2ad40680d9367a8a5d", "filename": "gcc/d/dmd/mtype.d", "status": "modified", "additions": 34, "deletions": 43, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fmtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fmtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -4200,27 +4200,28 @@ extern (C++) final class TypeFunction : TypeNext\n \n     // These flags can be accessed like `bool` properties,\n     // getters and setters are generated for them\n-    private enum FunctionFlag : uint\n-    {\n-        none            = 0,\n-        isnothrow       = 0x0001, // nothrow\n-        isnogc          = 0x0002, // is @nogc\n-        isproperty      = 0x0004, // can be called without parentheses\n-        isref           = 0x0008, // returns a reference\n-        isreturn        = 0x0010, // 'this' is returned by ref\n-        isScopeQual     = 0x0020, // 'this' is scope\n-        isreturninferred= 0x0040, // 'this' is return from inference\n-        isscopeinferred = 0x0080, // 'this' is scope from inference\n-        islive          = 0x0100, // is @live\n-        incomplete      = 0x0200, // return type or default arguments removed\n-        isInOutParam    = 0x0400, // inout on the parameters\n-        isInOutQual     = 0x0800, // inout on the qualifier\n-        isctor          = 0x1000, // the function is a constructor\n-        isreturnscope   = 0x2000, // `this` is returned by value\n-    }\n+    private extern (D) static struct BitFields\n+    {\n+        bool isnothrow;        /// nothrow\n+        bool isnogc;           /// is @nogc\n+        bool isproperty;       /// can be called without parentheses\n+        bool isref;            /// returns a reference\n+        bool isreturn;         /// 'this' is returned by ref\n+        bool isScopeQual;      /// 'this' is scope\n+        bool isreturninferred; /// 'this' is return from inference\n+        bool isscopeinferred;  /// 'this' is scope from inference\n+        bool islive;           /// is @live\n+        bool incomplete;       /// return type or default arguments removed\n+        bool isInOutParam;     /// inout on the parameters\n+        bool isInOutQual;      /// inout on the qualifier\n+        bool isctor;           /// the function is a constructor\n+        bool isreturnscope;    /// `this` is returned by value\n+    }\n+\n+    import dmd.common.bitfields : generateBitFields;\n+    mixin(generateBitFields!(BitFields, ushort));\n \n     LINK linkage;               // calling convention\n-    FunctionFlag funcFlags;\n     TRUST trust;                // level of trust\n     PURE purity = PURE.impure;\n     byte inuse;\n@@ -4684,6 +4685,16 @@ extern (C++) final class TypeFunction : TypeNext\n             match = MATCH.convert; // match ... with a \"conversion\" match level\n         }\n \n+        // https://issues.dlang.org/show_bug.cgi?id=22997\n+        if (parameterList.varargs == VarArg.none && nparams > nargs && !parameterList[nargs].defaultArg)\n+        {\n+            OutBuffer buf;\n+            buf.printf(\"too few arguments, expected `%d`, got `%d`\", cast(int)nparams, cast(int)nargs);\n+            if (pMessage)\n+                *pMessage = buf.extractChars();\n+            goto Nomatch;\n+        }\n+\n         foreach (u, p; parameterList)\n         {\n             if (u == nargs)\n@@ -5086,41 +5097,21 @@ extern (C++) final class TypeFunction : TypeNext\n         return false;\n     }\n \n-    // Generate getter / setter functions for `FunctionFlag` members so they can be\n-    // treated like regular `bool` fields, instead of requiring bit twiddling to read/write\n-    extern (D) mixin(() {\n-        string result = \"extern(C++) pure nothrow @safe @nogc {\";\n-        foreach (string mem; __traits(allMembers, FunctionFlag))\n-        {\n-            result ~= \"\n-            /// set or get if the function has the FunctionFlag attribute of the same name\n-            bool \"~mem~\"() const { return (funcFlags & FunctionFlag.\"~mem~\") != 0; }\n-            /// ditto\n-            void \"~mem~\"(bool v)\n-            {\n-                if (v) funcFlags |= FunctionFlag.\"~mem~\";\n-                else funcFlags &= ~FunctionFlag.\"~mem~\";\n-            }\";\n-        }\n-        return result ~ \"}\\n\";\n-    }());\n \n     /// Returns: `true` the function is `isInOutQual` or `isInOutParam` ,`false` otherwise.\n     bool iswild() const pure nothrow @safe @nogc\n     {\n-        return (funcFlags & (FunctionFlag.isInOutParam | FunctionFlag.isInOutQual)) != 0;\n+        return isInOutParam || isInOutQual;\n     }\n \n     /// Returns: whether `this` function type has the same attributes (`@safe`,...) as `other`\n     bool attributesEqual(const scope TypeFunction other) const pure nothrow @safe @nogc\n     {\n-        enum attributes = FunctionFlag.isnothrow\n-                        | FunctionFlag.isnogc\n-                        | FunctionFlag.islive;\n-\n         return this.trust == other.trust &&\n                 this.purity == other.purity &&\n-                (this.funcFlags & attributes) == (other.funcFlags & attributes);\n+                this.isnothrow == other.isnothrow &&\n+                this.isnogc == other.isnogc &&\n+                this.islive == other.islive;\n     }\n \n     override void accept(Visitor v)"}, {"sha": "e0b6339bf23c89a26df15e78171a7e8290e1c01f", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -595,8 +595,8 @@ class TypeFunction : public TypeNext\n     // .next is the return type\n \n     ParameterList parameterList; // function parameters\n+    uint16_t bitFields;\n     LINK linkage;                // calling convention\n-    unsigned funcFlags;\n     TRUST trust;                 // level of trust\n     PURE purity;                 // PURExxxx\n     char inuse;"}, {"sha": "4eb422805db8ed765986edea48d791700a7b2d63", "filename": "gcc/d/dmd/mustuse.d", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fmustuse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fmustuse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmustuse.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,244 @@\n+/**\n+ * Compile-time checks associated with the @mustuse attribute.\n+ *\n+ * Copyright: Copyright (C) 2022 by The D Language Foundation, All Rights Reserved\n+ * License:   $(LINK2 https://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Source:    $(LINK2 https://github.com/dlang/dmd/blob/master/src/dmd/mustuse.d, _mustuse.d)\n+ * Documentation:  https://dlang.org/phobos/dmd_mustuse.html\n+ * Coverage:    https://codecov.io/gh/dlang/dmd/src/master/src/dmd/mustuse.d\n+ */\n+\n+module dmd.mustuse;\n+\n+import dmd.dscope;\n+import dmd.dsymbol;\n+import dmd.expression;\n+import dmd.globals;\n+import dmd.identifier;\n+\n+// Used in isIncrementOrDecrement\n+private static const StringExp plusPlus, minusMinus;\n+\n+// Loc.initial cannot be used in static initializers, so\n+// these need a static constructor.\n+static this()\n+{\n+    plusPlus = new StringExp(Loc.initial, \"++\");\n+    minusMinus = new StringExp(Loc.initial, \"--\");\n+}\n+\n+/**\n+ * Check whether discarding an expression would violate the requirements of\n+ * @mustuse. If so, emit an error.\n+ *\n+ * Params:\n+ *   e = the expression to check\n+ *   sc = scope in which `e` was semantically analyzed\n+ *\n+ * Returns: true on error, false on success.\n+ */\n+bool checkMustUse(Expression e, Scope* sc)\n+{\n+    import dmd.id : Id;\n+\n+    assert(e.type);\n+    if (auto sym = e.type.toDsymbol(sc))\n+    {\n+        auto sd = sym.isStructDeclaration();\n+        // isStructDeclaration returns non-null for both structs and unions\n+        if (sd && hasMustUseAttribute(sd, sc) && !isAssignment(e) && !isIncrementOrDecrement(e))\n+        {\n+            e.error(\"ignored value of `@%s` type `%s`; prepend a `cast(void)` if intentional\",\n+                Id.udaMustUse.toChars(), e.type.toPrettyChars(true));\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+/**\n+ * Called from a symbol's semantic to check for reserved usage of @mustuse.\n+ *\n+ * If such usage is found, emits an errror.\n+ *\n+ * Params:\n+ *   sym = symbol to check\n+ */\n+void checkMustUseReserved(Dsymbol sym)\n+{\n+    import dmd.attrib : foreachUdaNoSemantic;\n+    import dmd.errors : error;\n+    import dmd.id : Id;\n+\n+    // Can't use foreachUda (and by extension hasMustUseAttribute) while\n+    // semantic analysis of `sym` is still in progress\n+    foreachUdaNoSemantic(sym, (exp) {\n+        if (isMustUseAttribute(exp))\n+        {\n+            if (sym.isFuncDeclaration())\n+            {\n+                error(sym.loc, \"`@%s` on functions is reserved for future use\",\n+                    Id.udaMustUse.toChars());\n+                sym.errors = true;\n+            }\n+            else if (sym.isClassDeclaration() || sym.isEnumDeclaration())\n+            {\n+                error(sym.loc, \"`@%s` on `%s` types is reserved for future use\",\n+                    Id.udaMustUse.toChars(), sym.kind());\n+                sym.errors = true;\n+            }\n+        }\n+        return 0; // continue\n+    });\n+}\n+\n+/**\n+ * Returns: true if the given expression is an assignment, either simple (a = b)\n+ * or compound (a += b, etc).\n+ */\n+private bool isAssignment(Expression e)\n+{\n+    if (e.isAssignExp || e.isBinAssignExp)\n+        return true;\n+    if (auto ce = e.isCallExp())\n+    {\n+        if (auto fd = ce.f)\n+        {\n+            auto id = fd.ident;\n+            if (id && isAssignmentOpId(id))\n+                return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+/**\n+ * Returns: true if id is the identifier of an assignment operator overload.\n+ */\n+private bool isAssignmentOpId(Identifier id)\n+{\n+    import dmd.id : Id;\n+\n+    return id == Id.assign\n+        || id == Id.addass\n+        || id == Id.subass\n+        || id == Id.mulass\n+        || id == Id.divass\n+        || id == Id.modass\n+        || id == Id.andass\n+        || id == Id.orass\n+        || id == Id.xorass\n+        || id == Id.shlass\n+        || id == Id.shrass\n+        || id == Id.ushrass\n+        || id == Id.catass\n+        || id == Id.indexass\n+        || id == Id.slice\n+        || id == Id.sliceass\n+        || id == Id.opOpAssign\n+        || id == Id.opIndexOpAssign\n+        || id == Id.opSliceOpAssign\n+        || id == Id.powass;\n+}\n+\n+/**\n+ * Returns: true if the given expression is an increment (++) or decrement (--).\n+ */\n+private bool isIncrementOrDecrement(Expression e)\n+{\n+    import dmd.dtemplate : isExpression;\n+    import dmd.globals : Loc;\n+    import dmd.id : Id;\n+    import dmd.tokens : EXP;\n+\n+    if (e.op == EXP.plusPlus\n+        || e.op == EXP.minusMinus\n+        || e.op == EXP.prePlusPlus\n+        || e.op == EXP.preMinusMinus)\n+        return true;\n+    if (auto call = e.isCallExp())\n+    {\n+        // Check for overloaded preincrement\n+        // e.g., a.opUnary!\"++\"\n+        if (auto fd = call.f)\n+        {\n+            if (fd.ident == Id.opUnary && fd.parent)\n+            {\n+                if (auto ti = fd.parent.isTemplateInstance())\n+                {\n+                    auto tiargs = ti.tiargs;\n+                    if (tiargs && tiargs.length >= 1)\n+                    {\n+                        if (auto argExp = (*tiargs)[0].isExpression())\n+                        {\n+                            auto op = argExp.isStringExp();\n+                            if (op && (op.compare(plusPlus) == 0 || op.compare(minusMinus) == 0))\n+                                return true;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    else if (auto comma = e.isCommaExp())\n+    {\n+        // Check for overloaded postincrement\n+        // e.g., (auto tmp = a, ++a, tmp)\n+        if (comma.e1)\n+        {\n+            if (auto left = comma.e1.isCommaExp())\n+            {\n+                if (auto middle = left.e2)\n+                {\n+                    if (middle && isIncrementOrDecrement(middle))\n+                        return true;\n+                }\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+/**\n+ * Returns: true if the given symbol has the @mustuse attribute.\n+ */\n+private bool hasMustUseAttribute(Dsymbol sym, Scope* sc)\n+{\n+    import dmd.attrib : foreachUda;\n+\n+    bool result = false;\n+\n+    foreachUda(sym, sc, (Expression uda) {\n+        if (isMustUseAttribute(uda))\n+        {\n+            result = true;\n+            return 1; // break\n+        }\n+        return 0; // continue\n+    });\n+\n+    return result;\n+}\n+\n+/**\n+ * Returns: true if the given expression is core.attribute.mustuse.\n+ */\n+private bool isMustUseAttribute(Expression e)\n+{\n+    import dmd.attrib : isCoreUda;\n+    import dmd.id : Id;\n+\n+    // Logic based on dmd.objc.Supported.declaredAsOptionalCount\n+    auto typeExp = e.isTypeExp;\n+    if (!typeExp)\n+        return false;\n+\n+    auto typeEnum = typeExp.type.isTypeEnum();\n+    if (!typeEnum)\n+        return false;\n+\n+    if (isCoreUda(typeEnum.sym, Id.udaMustUse))\n+        return true;\n+\n+    return false;\n+}"}, {"sha": "4f6903cbab721284a49b34cb0fa781a223477743", "filename": "gcc/d/dmd/opover.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fopover.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fopover.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fopover.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -213,7 +213,7 @@ private Expression checkAliasThisForLhs(AggregateDeclaration ad, Scope* sc, BinE\n      */\n     if (isRecursiveAliasThis(e.att1, e.e1.type))\n         return null;\n-    //printf(\"att %s e1 = %s\\n\", Token::toChars(e.op), e.e1.type.toChars());\n+    //printf(\"att %s e1 = %s\\n\", Token.toChars(e.op), e.e1.type.toChars());\n     BinExp be = cast(BinExp)e.copy();\n     // Resolve 'alias this' but in case of assigment don't resolve properties yet\n     // because 'e1 = e2' could mean 'e1(e2)' or 'e1() = e2'\n@@ -241,7 +241,7 @@ private Expression checkAliasThisForRhs(AggregateDeclaration ad, Scope* sc, BinE\n      */\n     if (isRecursiveAliasThis(e.att2, e.e2.type))\n         return null;\n-    //printf(\"att %s e2 = %s\\n\", Token::toChars(e.op), e.e2.type.toChars());\n+    //printf(\"att %s e2 = %s\\n\", Token.toChars(e.op), e.e2.type.toChars());\n     BinExp be = cast(BinExp)e.copy();\n     be.e2 = resolveAliasThis(sc, e.e2, true);\n     if (!be.e2)"}, {"sha": "3b8b1b6fa6c988c1d7b67522156cda8e3e26a3af", "filename": "gcc/d/dmd/optimize.d", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Foptimize.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Foptimize.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Foptimize.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -271,7 +271,7 @@ package void setLengthVarIfKnown(VarDeclaration lengthVar, Type type)\n  */\n Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n {\n-    //printf(\"Expression_optimize() %s\\n\", e.toChars());\n+    //printf(\"Expression_optimize() e: %s result: %d keepLvalue %d\\n\", e.toChars(), result, keepLvalue);\n     Expression ret = e;\n \n     void error()\n@@ -426,7 +426,7 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n \n     void visitAddr(AddrExp e)\n     {\n-        //printf(\"AddrExp::optimize(result = %d) %s\\n\", result, e.toChars());\n+        //printf(\"AddrExp::optimize(result = %d, keepLvalue = %d) %s\\n\", result, keepLvalue, e.toChars());\n         /* Rewrite &(a,b) as (a,&b)\n          */\n         if (auto ce = e.e1.isCommaExp())\n@@ -438,7 +438,8 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n         }\n         // Keep lvalue-ness\n         if (expOptimize(e.e1, result, true))\n-            return;\n+            return;                     // error return\n+\n         // Convert &*ex to ex\n         if (auto pe = e.e1.isPtrExp())\n         {\n@@ -515,6 +516,23 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n                         }\n                     }\n                 }\n+                else if (auto ei = e.isIndexExp())\n+                {\n+                    if (auto ve = ei.e1.isVarExp())\n+                    {\n+                        if (!ve.var.isReference() &&\n+                            !ve.var.isImportedSymbol() &&\n+                            ve.var.isDataseg() &&\n+                            ve.var.isCsymbol())\n+                        {\n+                            if (auto ie = ei.e2.isIntegerExp())\n+                            {\n+                                var = ve.var.isVarDeclaration();\n+                                offset += ie.toInteger() * ve.type.toBasetype().nextOf().size();\n+                            }\n+                        }\n+                    }\n+                }\n                 return false;\n             }\n \n@@ -538,7 +556,7 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n                 return;\n             }\n         }\n-        if (auto ae = e.e1.isIndexExp())\n+        else if (auto ae = e.e1.isIndexExp())\n         {\n             // Convert &array[n] to &array+n\n             if (ae.e2.isIntegerExp() && ae.e1.isVarExp())\n@@ -551,9 +569,10 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n                     sinteger_t dim = ts.dim.toInteger();\n                     if (index < 0 || index >= dim)\n                     {\n-                        /* 0 for C static arrays means size is unknown, no need to check\n+                        /* 0 for C static arrays means size is unknown, no need to check,\n+                         * and address one past the end is OK, too\n                          */\n-                        if (!(dim == 0 && ve.var.isCsymbol()))\n+                        if (!((dim == 0 || dim == index) && ve.var.isCsymbol()))\n                         {\n                             e.error(\"array index %lld is out of bounds `[0..%lld]`\", index, dim);\n                             return error();\n@@ -585,9 +604,10 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n                     sinteger_t dim = ts.dim.toInteger();\n                     if (index < 0 || index >= dim)\n                     {\n-                        /* 0 for C static arrays means size is unknown, no need to check\n+                        /* 0 for C static arrays means size is unknown, no need to check,\n+                         * and address one past the end is OK, too\n                          */\n-                        if (!(dim == 0 && ve.var.isCsymbol()))\n+                        if (!((dim == 0 || dim == index) && ve.var.isCsymbol()))\n                         {\n                             e.error(\"array index %lld is out of bounds `[0..%lld]`\", index, dim);\n                             return error();"}, {"sha": "beceb0f0707b395058bdf70ba606fd80b55bc705", "filename": "gcc/d/dmd/root/aav.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Froot%2Faav.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Froot%2Faav.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Faav.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -14,6 +14,8 @@ module dmd.root.aav;\n import core.stdc.string;\n import dmd.root.rmem;\n \n+nothrow:\n+\n private size_t hash(size_t a) pure nothrow @nogc @safe\n {\n     a ^= (a >> 20) ^ (a >> 12);"}, {"sha": "c2eb3e15c2cd02aed45044300844d886893b3e00", "filename": "gcc/d/dmd/root/array.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Froot%2Farray.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Froot%2Farray.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Farray.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -137,7 +137,7 @@ public:\n \n     void reserve(size_t nentries) pure nothrow\n     {\n-        //printf(\"Array::reserve: length = %d, data.length = %d, nentries = %d\\n\", (int)length, (int)data.length, (int)nentries);\n+        //printf(\"Array::reserve: length = %d, data.length = %d, nentries = %d\\n\", cast(int)length, cast(int)data.length, cast(int)nentries);\n \n         // Cold path\n         void enlarge(size_t nentries)"}, {"sha": "a7a74381ef999a6c2f77a23f205e8e87c8e6ad80", "filename": "gcc/d/dmd/root/complex.d", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Froot%2Fcomplex.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Froot%2Fcomplex.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fcomplex.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -13,11 +13,15 @@ module dmd.root.complex;\n \n import dmd.root.ctfloat;\n \n+nothrow:\n+\n extern (C++) struct complex_t\n {\n     real_t re;\n     real_t im;\n \n+  nothrow:\n+\n     this() @disable;\n \n     this(real_t re)"}, {"sha": "b40413c9ef15790e81120d7a556b8e6e9f4b71bd", "filename": "gcc/d/dmd/root/file.d", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Froot%2Ffile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Froot%2Ffile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffile.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -26,11 +26,15 @@ import dmd.root.string;\n import dmd.common.file;\n import dmd.common.string;\n \n-/// Owns a (rmem-managed) file buffer.\n-struct FileBuffer\n+nothrow:\n+\n+/// Owns a (rmem-managed) buffer.\n+struct Buffer\n {\n     ubyte[] data;\n \n+  nothrow:\n+\n     this(this) @disable;\n \n     ~this() pure nothrow\n@@ -54,7 +58,7 @@ struct File\n     static struct ReadResult\n     {\n         bool success;\n-        FileBuffer buffer;\n+        Buffer buffer;\n \n         /// Transfers ownership of the buffer to the caller.\n         ubyte[] extractSlice() pure nothrow @nogc @safe"}, {"sha": "d6753aa84906e0b6c6c6c708ddb2245e70aad1e3", "filename": "gcc/d/dmd/root/longdouble.d", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Froot%2Flongdouble.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Froot%2Flongdouble.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Flongdouble.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -29,6 +29,8 @@ nothrow:\n // Type used by the front-end for compile-time reals\n struct longdouble\n {\n+nothrow:\n+@nogc:\n     extern (D) this(T)(T r)\n     {\n         this.set(cast(SetType!T)r);"}, {"sha": "266846bcb0b23f58c6be8da33b6167130ad28ae1", "filename": "gcc/d/dmd/root/optional.d", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Froot%2Foptional.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Froot%2Foptional.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Foptional.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -10,6 +10,8 @@\n  */\n module dmd.root.optional;\n \n+nothrow:\n+\n ///\n unittest\n {\n@@ -45,6 +47,8 @@ extern (C++) struct Optional(T)\n     /// whether `value` is set\n     private bool present;\n \n+  nothrow:\n+\n     /// Creates an `Optional` with the given value\n     this(T value)\n     {"}, {"sha": "cd65920e38b66009a8f16f29870700a21c34c962", "filename": "gcc/d/dmd/semantic2.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fsemantic2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fsemantic2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic2.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -478,7 +478,7 @@ private extern(C++) final class Semantic2Visitor : Visitor\n         i.mod.semantic2(null);\n         if (i.mod.needmoduleinfo)\n         {\n-            //printf(\"module5 %s because of %s\\n\", sc.module.toChars(), mod.toChars());\n+            //printf(\"module5 %s because of %s\\n\", sc._module.toChars(), mod.toChars());\n             if (sc)\n                 sc._module.needmoduleinfo = 1;\n         }"}, {"sha": "2916bbc38dd79282abfdd7bf2e426f95473e94c6", "filename": "gcc/d/dmd/statementsem.d", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fstatementsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Fstatementsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -51,6 +51,7 @@ import dmd.importc;\n import dmd.init;\n import dmd.intrange;\n import dmd.mtype;\n+import dmd.mustuse;\n import dmd.nogc;\n import dmd.opover;\n import dmd.parse;\n@@ -211,7 +212,8 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n             if (f.checkForwardRef(s.exp.loc))\n                 s.exp = ErrorExp.get();\n         }\n-\n+        if (checkMustUse(s.exp, sc))\n+            s.exp = ErrorExp.get();\n         if (!(sc.flags & SCOPE.Cfile) && discardValue(s.exp))\n             s.exp = ErrorExp.get();\n "}, {"sha": "03e80245a744a0e57422ebf4436d21d1e33ed0cf", "filename": "gcc/d/dmd/tokens.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Ftokens.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Ftokens.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -591,7 +591,7 @@ shared static this() nothrow\n     Identifier.initTable();\n     foreach (kw; keywords)\n     {\n-        //printf(\"keyword[%d] = '%s'\\n\",kw, tochars[kw].ptr);\n+        //printf(\"keyword[%d] = '%s'\\n\",kw, Token.tochars[kw].ptr);\n         Identifier.idPool(Token.tochars[kw].ptr, Token.tochars[kw].length, cast(uint)kw);\n     }\n }"}, {"sha": "04e1c47d16e944c8f1a5ab26f041dc4618a54d49", "filename": "gcc/d/dmd/traits.d", "status": "modified", "additions": 23, "deletions": 57, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -1278,7 +1278,7 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n             {\n                 s = s.isImport().mod;\n             }\n-            //printf(\"getAttributes %s, attrs = %p, scope = %p\\n\", s.toChars(), s.userAttribDecl, s.scope);\n+            //printf(\"getAttributes %s, attrs = %p, scope = %p\\n\", s.toChars(), s.userAttribDecl, s._scope);\n             udad = s.userAttribDecl;\n         }\n         else\n@@ -1514,7 +1514,9 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n         TypeFunction tf = toTypeFunction(o, fd);\n \n         if (tf)\n-            link = tf.linkage;\n+        {\n+            link = fd ? fd.linkage : tf.linkage;\n+        }\n         else\n         {\n             auto s = getDsymbol(o);\n@@ -1730,69 +1732,33 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n             bool err = false;\n \n             auto t = isType(o);\n-            while (t)\n+            auto ex = isExpression(o);\n+            if (t)\n             {\n-                if (auto tm = t.isTypeMixin())\n+                Dsymbol s;\n+                t.resolve(e.loc, sc2, ex, t, s);\n+                if (t)\n                 {\n-                    /* The mixin string could be a type or an expression.\n-                     * Have to try compiling it to see.\n-                     */\n-                    OutBuffer buf;\n-                    if (expressionsToString(buf, sc, tm.exps))\n-                    {\n+                    t.typeSemantic(e.loc, sc2);\n+                    if (t.ty == Terror)\n                         err = true;\n-                        break;\n-                    }\n-                    const olderrors = global.errors;\n-                    const len = buf.length;\n-                    buf.writeByte(0);\n-                    const str = buf.extractSlice()[0 .. len];\n-                    scope p = new Parser!ASTCodegen(e.loc, sc._module, str, false);\n-                    p.nextToken();\n-                    //printf(\"p.loc.linnum = %d\\n\", p.loc.linnum);\n-\n-                    o = p.parseTypeOrAssignExp(TOK.endOfFile);\n-                    if (olderrors != global.errors || p.token.value != TOK.endOfFile)\n-                    {\n-                        err = true;\n-                        break;\n-                    }\n-                    t = o.isType();\n                 }\n-                else\n-                    break;\n+                else if (s && s.errors)\n+                    err = true;\n             }\n-\n-            if (!err)\n+            if (ex)\n             {\n-                auto ex = t ? t.typeToExpression() : isExpression(o);\n-                if (!ex && t)\n-                {\n-                    Dsymbol s;\n-                    t.resolve(e.loc, sc2, ex, t, s);\n-                    if (t)\n-                    {\n-                        t.typeSemantic(e.loc, sc2);\n-                        if (t.ty == Terror)\n-                            err = true;\n-                    }\n-                    else if (s && s.errors)\n-                        err = true;\n-                }\n-                if (ex)\n+                ex = ex.expressionSemantic(sc2);\n+                ex = resolvePropertiesOnly(sc2, ex);\n+                ex = ex.optimize(WANTvalue);\n+                if (sc2.func && sc2.func.type.ty == Tfunction)\n                 {\n-                    ex = ex.expressionSemantic(sc2);\n-                    ex = resolvePropertiesOnly(sc2, ex);\n-                    ex = ex.optimize(WANTvalue);\n-                    if (sc2.func && sc2.func.type.ty == Tfunction)\n-                    {\n-                        const tf = cast(TypeFunction)sc2.func.type;\n-                        err |= tf.isnothrow && canThrow(ex, sc2.func, false);\n-                    }\n-                    ex = checkGC(sc2, ex);\n-                    if (ex.op == EXP.error)\n-                        err = true;\n+                    const tf = cast(TypeFunction)sc2.func.type;\n+                    err |= tf.isnothrow && canThrow(ex, sc2.func, false);\n                 }\n+                ex = checkGC(sc2, ex);\n+                if (ex.op == EXP.error)\n+                    err = true;\n             }\n \n             // Carefully detach the scope from the parent and throw it away as"}, {"sha": "b26741242f9ed5c65a7c40060748411ee133e627", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -1220,6 +1220,9 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n             tf.islive = true;\n \n         tf.linkage = sc.linkage;\n+        if (tf.linkage == LINK.system)\n+            tf.linkage = target.systemLinkage();\n+\n         version (none)\n         {\n             /* If the parent is @safe, then this function defaults to safe\n@@ -2281,10 +2284,7 @@ RootObject compileTypeMixin(TypeMixin tm, Loc loc, Scope* sc)\n         return null;\n     }\n \n-    Type t = o.isType();\n-    Expression e = t ? t.typeToExpression() : o.isExpression();\n-\n-    return (!e && t) ? t : e;\n+    return o;\n }\n \n \n@@ -3619,12 +3619,31 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n                 e.error(\"`%s` is not an expression\", e.toChars());\n                 return ErrorExp.get();\n             }\n-            else if (checkUnsafeDotExp(sc, e, ident, flag))\n+            else if (mt.dim.toUInteger() < 1 && checkUnsafeDotExp(sc, e, ident, flag))\n             {\n+                // .ptr on static array is @safe unless size is 0\n+                // https://issues.dlang.org/show_bug.cgi?id=20853\n                 return ErrorExp.get();\n             }\n             e = e.castTo(sc, e.type.nextOf().pointerTo());\n         }\n+        else if (ident == Id._tupleof)\n+        {\n+            if (e.isTypeExp())\n+            {\n+                e.error(\"`.tupleof` cannot be used on type `%s`\", mt.toChars);\n+                return ErrorExp.get();\n+            }\n+            else\n+            {\n+                const length = cast(size_t)mt.dim.toUInteger();\n+                auto exps = new Expressions();\n+                exps.reserve(length);\n+                foreach (i; 0 .. length)\n+                    exps.push(new IndexExp(e.loc, e, new IntegerExp(e.loc, i, Type.tsize_t)));\n+                e = new TupleExp(e.loc, exps);\n+            }\n+        }\n         else\n         {\n             e = visitArray(mt);"}, {"sha": "cdfe3cb61aab66da8c703a4a8a50c47c8f941611", "filename": "gcc/d/dmd/utils.d", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Futils.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fdmd%2Futils.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Futils.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -19,6 +19,7 @@ import dmd.root.filename;\n import dmd.common.outbuffer;\n import dmd.root.string;\n \n+nothrow:\n \n /**\n  * Normalize path by turning forward slashes into backslashes\n@@ -52,21 +53,21 @@ const(char)* toWinPath(const(char)* src)\n  *   loc = The line number information from where the call originates\n  *   filename = Path to file\n  */\n-FileBuffer readFile(Loc loc, const(char)* filename)\n+Buffer readFile(Loc loc, const(char)* filename)\n {\n     return readFile(loc, filename.toDString());\n }\n \n /// Ditto\n-FileBuffer readFile(Loc loc, const(char)[] filename)\n+Buffer readFile(Loc loc, const(char)[] filename)\n {\n     auto result = File.read(filename);\n     if (!result.success)\n     {\n         error(loc, \"error reading file `%.*s`\", cast(int)filename.length, filename.ptr);\n         fatal();\n     }\n-    return FileBuffer(result.extractSlice());\n+    return Buffer(result.extractSlice());\n }\n \n "}, {"sha": "c683d9da333da36724998a5bee87385b263de0a2", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -3006,6 +3006,16 @@ class ExprVisitor : public Visitor\n     this->result_ = var;\n   }\n \n+  /* Build an uninitialized value, generated from void initializers.  */\n+\n+  void visit (VoidInitExp *e)\n+  {\n+    /* The front-end only generates these for the initializer of globals.\n+       Represent `void' as zeroes, regardless of the type's default value.  */\n+    gcc_assert (this->constp_);\n+    this->result_ = build_zero_cst (build_ctype (e->type));\n+  }\n+\n   /* These expressions are mainly just a placeholders in the frontend.\n      We shouldn't see them here.  */\n "}, {"sha": "93f05a50c31f71558122cc198f53327cb5b8e9de", "filename": "gcc/testsuite/gdc.test/compilable/extra-files/header1.d", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fheader1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fheader1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fheader1.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -607,3 +607,13 @@ T throwStuff(T)(T t)\n     if (false) test13x(1, throw new Exception(\"\"), 2);\n     return t ? t : throw new Exception(\"Bad stuff happens!\");\n }\n+\n+class C12344\n+{\n+    abstract int c12344(int x) in(x > 0) out(result) {assert(result > 0);};\n+}\n+\n+interface I12344\n+{\n+    int i12344(int x) in(x > 0) out(result) {assert(result > 0);};\n+}"}, {"sha": "5046cbb31ce7472e9dc4778dc01bcb1b88ff2084", "filename": "gcc/testsuite/gdc.test/compilable/imports/imp17434a.d", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fimp17434a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fimp17434a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fimp17434a.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1 @@\n+module imp17434a.test1;"}, {"sha": "88c37ab488a412bf4e332b35642b8daee5df5d4a", "filename": "gcc/testsuite/gdc.test/compilable/imports/imp17434b.d", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fimp17434b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fimp17434b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fimp17434b.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,6 @@\n+module imp.imports17434b;\n+\n+void testing()\n+{\n+    return;\n+}"}, {"sha": "2c9a84eddfb804ac7185e52a3b8798458bb91871", "filename": "gcc/testsuite/gdc.test/compilable/interpret3.d", "status": "modified", "additions": 100, "deletions": 2, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Finterpret3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Finterpret3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Finterpret3.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -2473,12 +2473,12 @@ static assert(checkPass(\"foobar\") == 1);\n \n struct Toq\n {\n-    const(char)* m;\n+    char* m;\n }\n \n Toq ptrRet(bool b)\n {\n-    string x = \"abc\";\n+    char[] x = \"abc\".dup;\n     return Toq(b ? x[0 .. 1].ptr : null);\n }\n \n@@ -7808,3 +7808,101 @@ int test9937()\n }\n \n static assert(test9937());\n+\n+/************************************************/\n+// static array .tupleof\n+\n+struct SArrayTupleEquiv(T)\n+{\n+    T f1;\n+    T f2;\n+}\n+\n+// basic .tupleof invariants\n+bool testSArrayTupleA()\n+{\n+    int[2] xs;\n+    assert(xs.tupleof == TypeTuple!(0, 0));\n+    assert(xs.tupleof == (cast(int[2])[0, 0]).tupleof);\n+\n+    xs.tupleof = TypeTuple!(1, 2);\n+    assert(xs.tupleof == TypeTuple!(1, 2));\n+\n+    auto ys = SArrayTupleEquiv!int(1, 2);\n+    assert(xs.tupleof == ys.tupleof);\n+\n+    return true;\n+}\n+static assert(testSArrayTupleA());\n+\n+// tuples with side effects\n+bool testSArrayTupleB()\n+{\n+    // Counter records lifetime events in copies/dtors, as a cheap way to check that .tupleof for\n+    // static arrays exhibit all the same side effects as an equivalent struct's .tupleof\n+    int[int] copies;\n+    int[int] dtors;\n+    struct Counter\n+    {\n+        int id = -1;\n+\n+        this(this)\n+        {\n+            copies[id] = copies.get(id, 0) + 1;\n+        }\n+\n+        ~this()\n+        {\n+            dtors[id] = dtors.get(id, 0) + 1;\n+        }\n+    }\n+\n+    void consume(Counter, Counter) {}\n+    Counter[2] produce(int id1, int id2)\n+    {\n+        return [Counter(id1), Counter(id2)];\n+    }\n+\n+    // first sample expected behavior from struct .tupleof\n+    // braces create a subscope, shortening lifetimes\n+    {\n+        auto a = SArrayTupleEquiv!Counter(Counter(0), Counter(1));\n+\n+        typeof(a) b;\n+        b.tupleof = a.tupleof;\n+\n+        Counter x, y;\n+        TypeTuple!(x, y) = a.tupleof;\n+\n+        a.tupleof[0] = Counter(2);\n+        a.tupleof[1] = Counter(3);\n+        consume(a.tupleof);\n+\n+        a.tupleof = produce(4, 5).tupleof;\n+    }\n+    int[int][2] expected = [copies.dup, dtors.dup];\n+    copies = null; // .clear is not CTFE friendly\n+    dtors = null;\n+\n+    // the real test -- sample behavior of array .tupleof\n+    {\n+        Counter[2] a = [Counter(0), Counter(1)];\n+\n+        typeof(a) b;\n+        b.tupleof = a.tupleof;\n+\n+        Counter x, y;\n+        TypeTuple!(x, y) = a.tupleof;\n+\n+        a.tupleof[0] = Counter(2);\n+        a.tupleof[1] = Counter(3);\n+        consume(a.tupleof);\n+\n+        a.tupleof = produce(4, 5).tupleof;\n+    }\n+    assert(expected[0] == copies);\n+    assert(expected[1] == dtors);\n+\n+    return true;\n+}\n+static assert(testSArrayTupleB());"}, {"sha": "f4d68e7dc8c6ef13bbeb3ad2c90924012c878926", "filename": "gcc/testsuite/gdc.test/compilable/json.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fjson.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fjson.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fjson.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -203,14 +203,14 @@ extern(C) int vlinakgeC;\n extern(C++) __gshared int vlinkageCpp;\n extern(Windows) int vlinkageWindows;\n extern(Objective-C) int vlinkageObjc;\n-\n+extern(System) int vlinkageSystem;\n extern int flinkageDefault();\n extern(D) int flinkageD();\n extern(C) int linakgeC();\n extern(C++) int flinkageCpp();\n extern(Windows) int flinkageWindows();\n extern(Objective-C) int flinkageObjc();\n-\n+extern(System) int flinkageSystem();\n mixin template test18211(int n)\n {\n     static foreach (i; 0 .. n>10 ? 10 : n)"}, {"sha": "a61adc570fa885de50087f3514eea647447e2e80", "filename": "gcc/testsuite/gdc.test/compilable/mixintype2.d", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmixintype2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmixintype2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmixintype2.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -115,3 +115,9 @@ void test_statements_22356()\n     mixin(\"int\") y22356, z22356;\n     static assert(is(typeof(y22356) == int) && is(typeof(z22356) == int));\n }\n+\n+/**************************************************/\n+// https://issues.dlang.org/show_bug.cgi?id=22969\n+\n+enum e = 0;\n+alias a = mixin(\"e\");"}, {"sha": "bd1983a40e6330cf7ec369495b1796988d6d0746", "filename": "gcc/testsuite/gdc.test/compilable/must_use_assign.d", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_assign.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_assign.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_assign.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,9 @@\n+import core.attribute;\n+\n+@mustuse struct S {}\n+\n+void test()\n+{\n+    S a, b;\n+    a = b;\n+}"}, {"sha": "c600119848908249e883359373defde04ad9a83f", "filename": "gcc/testsuite/gdc.test/compilable/must_use_not_reserved.d", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_not_reserved.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_not_reserved.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_not_reserved.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,5 @@\n+import core.attribute;\n+\n+@mustuse int n;\n+@mustuse alias A = int;\n+@mustuse template tpl() {}"}, {"sha": "8e877dd69b6d3dd4594193dc770ec580dd82ec40", "filename": "gcc/testsuite/gdc.test/compilable/must_use_opassign.d", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_opassign.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_opassign.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_opassign.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,15 @@\n+import core.attribute;\n+\n+@mustuse struct S\n+{\n+    ref S opAssign(S rhs) return\n+    {\n+        return this;\n+    }\n+}\n+\n+void test()\n+{\n+    S a, b;\n+    a = b;\n+}"}, {"sha": "0176354ed1d7596b9b7bf945da351fc5d0194157", "filename": "gcc/testsuite/gdc.test/compilable/must_use_opopassign.d", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_opopassign.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_opopassign.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_opopassign.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,15 @@\n+import core.attribute;\n+\n+@mustuse struct S\n+{\n+    ref S opOpAssign(string op)(S rhs) return\n+    {\n+        return this;\n+    }\n+}\n+\n+void test()\n+{\n+    S a, b;\n+    a += b;\n+}"}, {"sha": "fc9650ebed5c3ab640e6605a5a779942ced7d5a9", "filename": "gcc/testsuite/gdc.test/compilable/must_use_opunary.d", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_opunary.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_opunary.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_opunary.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,18 @@\n+import core.attribute;\n+\n+@mustuse struct S\n+{\n+    ref S opUnary(string op)() return\n+    {\n+        return this;\n+    }\n+}\n+\n+void test()\n+{\n+    S s;\n+    ++s;\n+    --s;\n+    s++;\n+    s--;\n+}"}, {"sha": "63ad75c2928df65495b47e23f60acfd1f40983cd", "filename": "gcc/testsuite/gdc.test/compilable/must_use_suppress.d", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_suppress.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_suppress.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_suppress.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,10 @@\n+import core.attribute;\n+\n+@mustuse struct S {}\n+\n+S fun() { return S(); }\n+\n+void test()\n+{\n+    cast(void) fun();\n+}"}, {"sha": "1a92a1c9112a2e32d2e79bd99dba2e0310a2033f", "filename": "gcc/testsuite/gdc.test/compilable/test17419.d", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17419.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17419.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17419.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -17,10 +17,7 @@ static assert(__traits(getLinkage, food) == \"D\");\n static assert(__traits(getLinkage, foocpp) == \"C++\");\n static assert(__traits(getLinkage, foow) == \"Windows\");\n static assert(__traits(getLinkage, fooobjc) == \"Objective-C\");\n-version (Windows)\n-    static assert(__traits(getLinkage, foos) == \"Windows\");\n-else\n-    static assert(__traits(getLinkage, foos) == \"C\");\n+static assert(__traits(getLinkage, foos) == \"System\");\n \n extern (C) int global;\n static assert(__traits(getLinkage, global) == \"C\");"}, {"sha": "82bfa570b5ff251ac565b788ca45513e67648416", "filename": "gcc/testsuite/gdc.test/compilable/test17434.d", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17434.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17434.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17434.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,11 @@\n+// https://issues.dlang.org/show_bug.cgi?id=17434\n+\n+// EXTRA_FILES: test17434a.d imports/imp17434a.d imports/imp17434b.d\n+module test17434;\n+\n+import test17434a;\n+\n+void main()\n+{\n+    imports.imp17434b.testing();\n+}"}, {"sha": "c9175fe385b3b64053146ab0f7db300d016c8923", "filename": "gcc/testsuite/gdc.test/compilable/test17434a.d", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17434a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17434a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17434a.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,5 @@\n+// EXTRA_FILES: imports/imp17434a.d imports/imp17434b.d\n+module test17434a;\n+\n+private import imports.imp17434a;\n+public  import imports.imp17434b;"}, {"sha": "a6d300248816d8788e8a6317ce2c54eba661a260", "filename": "gcc/testsuite/gdc.test/compilable/test19097.d", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19097.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19097.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19097.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -21,3 +21,43 @@ void foo(scope int* pf)\n     betty(rf, pf);\n     boop(rf, pf);\n }\n+\n+// https://issues.dlang.org/show_bug.cgi?id=22801\n+struct Wrapper\n+{\n+    int* ptr;\n+\n+    this(return ref int var) @safe\n+    {\n+        this.ptr = &var;\n+    }\n+}\n+\n+void main() @safe\n+{\n+    int i;\n+    auto w = Wrapper(i);\n+    auto wt = WrapperT!()(i);\n+}\n+\n+void assign(ref scope int* x, return ref int y) @safe\n+{\n+    x = &y;\n+}\n+\n+// https://issues.dlang.org/show_bug.cgi?id=22967\n+// inference of `return ref` when assigned to first parameter\n+struct WrapperT()\n+{\n+    int* ptr;\n+\n+    this(ref int var) @safe\n+    {\n+        this.ptr = &var;\n+    }\n+\n+    static void assignInferred(ref scope int* xi, ref int yi) @safe\n+    {\n+        xi = &yi;\n+    }\n+}"}, {"sha": "6be3921e67b0e7a7781de938b94ec9c67a3ef1c4", "filename": "gcc/testsuite/gdc.test/compilable/test22988.d", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22988.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22988.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22988.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,15 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22988\n+\n+enum a1 = 0;\n+enum b1 = a1 ? 1 << a1 - 1 : 0;\n+\n+enum l = 0;\n+enum int[l] a2 = [];\n+enum b2 = l ? a2[l - 1] : 0;\n+\n+enum a3 = 0 ? 1 << -1 : 0;\n+\n+enum int[0] a4 = [];\n+enum b4 = 0 ? a4[0] : 0;\n+\n+enum b5 = false ? (1 << -1) : 0;"}, {"sha": "3cad527b4c2ed9441d23c604e1cc6def96a452fd", "filename": "gcc/testsuite/gdc.test/compilable/test22997.d", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22997.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22997.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22997.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,14 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22997\n+\n+struct Forward {}\n+\n+struct Foo\n+{\n+    this(ref typeof(this) rhs)\n+    {\n+        this(rhs, Forward.init);\n+    }\n+\n+    this(ref typeof(this) rhs, Forward) {}\n+    this(typeof(this) rhs, int i, double d, string s) {}\n+}"}, {"sha": "29261b4ea1c266f4a3fae67a5c5f971bfda52607", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag14235.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag14235.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag14235.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag14235.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -2,8 +2,8 @@\n EXTRA_FILES: imports/a14235.d\n TEST_OUTPUT:\n ---\n-fail_compilation/diag14235.d(12): Error: template identifier `Undefined` is not a member of module `imports.a14235`\n-fail_compilation/diag14235.d(13): Error: template identifier `Something` is not a member of module `imports.a14235`, did you mean struct `SomeThing(T...)`?\n+fail_compilation/diag14235.d(12): Error: undefined identifier `Undefined` in module `imports.a14235`\n+fail_compilation/diag14235.d(13): Error: undefined identifier `Something` in module `imports.a14235`, did you mean struct `SomeThing(T...)`?\n fail_compilation/diag14235.d(14): Error: `imports.a14235.SomeClass` is not a template, it is a class\n ---\n */"}, {"sha": "301472ca28a89a1a5d3f377ac67f32365c0f6c67", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag8101.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8101.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8101.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8101.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/diag8101.d(57): Error: function `diag8101.f_0(int)` is not callable using argument types `()`\n-fail_compilation/diag8101.d(57):        missing argument for parameter #1: `int`\n+fail_compilation/diag8101.d(57):        too few arguments, expected `1`, got `0`\n fail_compilation/diag8101.d(58): Error: none of the overloads of `f_1` are callable using argument types `()`\n fail_compilation/diag8101.d(33):        Candidates are: `diag8101.f_1(int)`\n fail_compilation/diag8101.d(34):                        `diag8101.f_1(int, int)`"}, {"sha": "1279d7c2a2a8eb6f9a4c39935665436cafd69e47", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag_funclit.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag_funclit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag_funclit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag_funclit.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/diag_funclit.d(103): Error: function literal `__lambda1(x, y, z)` is not callable using argument types `()`\n-fail_compilation/diag_funclit.d(103):        missing argument for parameter #1: `x`\n+fail_compilation/diag_funclit.d(103):        too few arguments, expected `3`, got `0`\n fail_compilation/diag_funclit.d(106): Error: function literal `__lambda2(x, y, z)` is not callable using argument types `(int, string, int, int)`\n fail_compilation/diag_funclit.d(106):        too many arguments, expected `3`, got `4`\n fail_compilation/diag_funclit.d(108): Error: function literal `__lambda3(x, y, string z = \"Hello\")` is not callable using argument types `(int, int, string, string)`"}, {"sha": "1418ced43a2558b565a387031b0e8f84f4d0076a", "filename": "gcc/testsuite/gdc.test/fail_compilation/diagin.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiagin.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiagin.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiagin.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -3,7 +3,7 @@ PERMUTE_ARGS: -preview=in\n TEST_OUTPUT:\n ---\n fail_compilation/diagin.d(14): Error: function `diagin.foo(in int)` is not callable using argument types `()`\n-fail_compilation/diagin.d(14):        missing argument for parameter #1: `in int`\n+fail_compilation/diagin.d(14):        too few arguments, expected `1`, got `0`\n fail_compilation/diagin.d(16): Error: none of the overloads of template `diagin.foo1` are callable using argument types `!()(bool[])`\n fail_compilation/diagin.d(20):        Candidate is: `foo1(T)(in T v, string)`\n ---"}, {"sha": "520c1b14bfb95fa9f092cbb2dcf6742719b6067c", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail2656.d", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail2656.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail2656.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail2656.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -1,20 +1,20 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail2656.d(21): Error: octal literals `0123` are no longer supported, use `std.conv.octal!123` instead\n-fail_compilation/fail2656.d(22): Error: octal literals `01000000000000000000000` are no longer supported, use `std.conv.octal!1000000000000000000000` instead\n-fail_compilation/fail2656.d(23): Error: octal literals `0100000L` are no longer supported, use `std.conv.octal!100000L` instead\n-fail_compilation/fail2656.d(24): Error: octal literals `01777777777777777777777u` are no longer supported, use `std.conv.octal!1777777777777777777777u` instead\n-fail_compilation/fail2656.d(25): Error: octal literals `017777777777uL` are no longer supported, use `std.conv.octal!17777777777uL` instead\n-fail_compilation/fail2656.d(26): Error: octal literals `0177777` are no longer supported, use `std.conv.octal!177777` instead\n-fail_compilation/fail2656.d(27): Error: octal literals `020000000000L` are no longer supported, use `std.conv.octal!20000000000L` instead\n-fail_compilation/fail2656.d(28): Error: octal literals `0200000u` are no longer supported, use `std.conv.octal!200000u` instead\n-fail_compilation/fail2656.d(29): Error: octal literals `037777777777uL` are no longer supported, use `std.conv.octal!37777777777uL` instead\n-fail_compilation/fail2656.d(30): Error: octal literals `040000000000` are no longer supported, use `std.conv.octal!40000000000` instead\n-fail_compilation/fail2656.d(31): Error: octal literals `0777777777777777777777L` are no longer supported, use `std.conv.octal!777777777777777777777L` instead\n-fail_compilation/fail2656.d(32): Error: octal literals `077777u` are no longer supported, use `std.conv.octal!77777u` instead\n-fail_compilation/fail2656.d(33): Error: octal literals `077777uL` are no longer supported, use `std.conv.octal!77777uL` instead\n-fail_compilation/fail2656.d(34): Error: octal literals `077777uL` are no longer supported, use `std.conv.octal!77777uL` instead\n+fail_compilation/fail2656.d(21): Error: octal literals `0123` are no longer supported, use `std.conv.octal!\"123\"` instead\n+fail_compilation/fail2656.d(22): Error: octal literals `01000000000000000000000` are no longer supported, use `std.conv.octal!\"1000000000000000000000\"` instead\n+fail_compilation/fail2656.d(23): Error: octal literals `0100000L` are no longer supported, use `std.conv.octal!\"100000L\"` instead\n+fail_compilation/fail2656.d(24): Error: octal literals `01777777777777777777777u` are no longer supported, use `std.conv.octal!\"1777777777777777777777u\"` instead\n+fail_compilation/fail2656.d(25): Error: octal literals `017777777777uL` are no longer supported, use `std.conv.octal!\"17777777777uL\"` instead\n+fail_compilation/fail2656.d(26): Error: octal literals `0177777` are no longer supported, use `std.conv.octal!\"177777\"` instead\n+fail_compilation/fail2656.d(27): Error: octal literals `020000000000L` are no longer supported, use `std.conv.octal!\"20000000000L\"` instead\n+fail_compilation/fail2656.d(28): Error: octal literals `0200000u` are no longer supported, use `std.conv.octal!\"200000u\"` instead\n+fail_compilation/fail2656.d(29): Error: octal literals `037777777777uL` are no longer supported, use `std.conv.octal!\"37777777777uL\"` instead\n+fail_compilation/fail2656.d(30): Error: octal literals `040000000000` are no longer supported, use `std.conv.octal!\"40000000000\"` instead\n+fail_compilation/fail2656.d(31): Error: octal literals `0777777777777777777777L` are no longer supported, use `std.conv.octal!\"777777777777777777777L\"` instead\n+fail_compilation/fail2656.d(32): Error: octal literals `077777u` are no longer supported, use `std.conv.octal!\"77777u\"` instead\n+fail_compilation/fail2656.d(33): Error: octal literals `077777uL` are no longer supported, use `std.conv.octal!\"77777uL\"` instead\n+fail_compilation/fail2656.d(34): Error: octal literals `077777uL` are no longer supported, use `std.conv.octal!\"77777uL\"` instead\n ---\n */\n "}, {"sha": "e4cba9530bfcb8f5c2159ad1a64d81ddb93832e1", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail99.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail99.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail99.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail99.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/fail99.d(13): Error: delegate `dg(int)` is not callable using argument types `()`\n-fail_compilation/fail99.d(13):        missing argument for parameter #1: `int`\n+fail_compilation/fail99.d(13):        too few arguments, expected `1`, got `0`\n ---\n */\n "}, {"sha": "b6bd9d33cf91e0d8bc20e1a33e2cc691f601569c", "filename": "gcc/testsuite/gdc.test/fail_compilation/fix19059.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffix19059.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffix19059.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffix19059.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -5,7 +5,7 @@ fail_compilation/fix19059.d(16): Error: octal digit expected, not `8`\n fail_compilation/fix19059.d(16): Error: octal literals larger than 7 are no longer supported\n fail_compilation/fix19059.d(17): Error: octal digit expected, not `9`\n fail_compilation/fix19059.d(17): Error: octal literals larger than 7 are no longer supported\n-fail_compilation/fix19059.d(18): Error: octal literals `010` are no longer supported, use `std.conv.octal!10` instead\n+fail_compilation/fix19059.d(18): Error: octal literals `010` are no longer supported, use `std.conv.octal!\"10\"` instead\n ---\n  */\n "}, {"sha": "f3a7a57a689546d188ec1172b23f4c5fa6748f3d", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice10922.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10922.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10922.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice10922.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/ice10922.d(10): Error: function `ice10922.__lambda4(in uint n)` is not callable using argument types `()`\n-fail_compilation/ice10922.d(10):        missing argument for parameter #1: `in uint n`\n+fail_compilation/ice10922.d(10):        too few arguments, expected `1`, got `0`\n ---\n */\n "}, {"sha": "ce705078ac0c2791180e9173a94e4a5ca81b1228", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice9540.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice9540.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice9540.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice9540.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/ice9540.d(35): Error: function `ice9540.A.test.AddFront!(this, f).AddFront.dg(int _param_0)` is not callable using argument types `()`\n-fail_compilation/ice9540.d(35):        missing argument for parameter #1: `int _param_0`\n+fail_compilation/ice9540.d(35):        too few arguments, expected `1`, got `0`\n fail_compilation/ice9540.d(26): Error: template instance `ice9540.A.test.AddFront!(this, f)` error instantiating\n ---\n */"}, {"sha": "e3b5fedfd4d79ce44b822f97c04215f18b689e77", "filename": "gcc/testsuite/gdc.test/fail_compilation/must_use.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmust_use.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmust_use.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmust_use.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,16 @@\n+/+\n+TEST_OUTPUT:\n+---\n+fail_compilation/must_use.d(15): Error: ignored value of `@mustuse` type `must_use.S`; prepend a `cast(void)` if intentional\n+---\n++/\n+import core.attribute;\n+\n+@mustuse struct S {}\n+\n+S fun() { return S(); }\n+\n+void test()\n+{\n+    fun();\n+}"}, {"sha": "4621ab5ec2983c249039eea08e68a6958db3b2f2", "filename": "gcc/testsuite/gdc.test/fail_compilation/must_use_comma.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmust_use_comma.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmust_use_comma.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmust_use_comma.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,17 @@\n+/+\n+TEST_OUTPUT:\n+---\n+fail_compilation/must_use_comma.d(16): Error: ignored value of `@mustuse` type `must_use_comma.S`; prepend a `cast(void)` if intentional\n+---\n++/\n+import core.attribute;\n+\n+@mustuse struct S {}\n+\n+S fun() { return S(); }\n+void sideEffect() {}\n+\n+void test()\n+{\n+    (fun(), sideEffect());\n+}"}, {"sha": "59248a969c4e5e4dae35e1da0bff4b7cee5ccd9f", "filename": "gcc/testsuite/gdc.test/fail_compilation/must_use_opunary.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmust_use_opunary.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmust_use_opunary.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmust_use_opunary.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,21 @@\n+/+\n+TEST_OUTPUT:\n+---\n+fail_compilation/must_use_opunary.d(20): Error: ignored value of `@mustuse` type `must_use_opunary.S`; prepend a `cast(void)` if intentional\n+---\n++/\n+import core.attribute;\n+\n+@mustuse struct S\n+{\n+    ref S opUnary(string op)() return\n+    {\n+        return this;\n+    }\n+}\n+\n+void test()\n+{\n+    S s;\n+    -s;\n+}"}, {"sha": "96edbd3cbe4cc77324847cacccd8d5b1fb7fba24", "filename": "gcc/testsuite/gdc.test/fail_compilation/must_use_reserved.d", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmust_use_reserved.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmust_use_reserved.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmust_use_reserved.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,20 @@\n+/+\n+TEST_OUTPUT:\n+---\n+fail_compilation/must_use_reserved.d(14): Error: `@mustuse` on `class` types is reserved for future use\n+fail_compilation/must_use_reserved.d(15): Error: `@mustuse` on `interface` types is reserved for future use\n+fail_compilation/must_use_reserved.d(16): Error: `@mustuse` on `enum` types is reserved for future use\n+fail_compilation/must_use_reserved.d(17): Error: `@mustuse` on functions is reserved for future use\n+fail_compilation/must_use_reserved.d(19): Error: `@mustuse` on `class` types is reserved for future use\n+fail_compilation/must_use_reserved.d(20): Error: template instance `must_use_reserved.CT!int` error instantiating\n+---\n++/\n+import core.attribute;\n+\n+@mustuse class C {}\n+@mustuse interface I {}\n+@mustuse enum E { x }\n+@mustuse int fun() { return 0; }\n+\n+@mustuse class CT(T) {}\n+alias _ = CT!int;"}, {"sha": "eeaa774ea20b720690775911451b531f023a0f59", "filename": "gcc/testsuite/gdc.test/fail_compilation/must_use_template.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmust_use_template.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmust_use_template.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmust_use_template.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,16 @@\n+/+\n+TEST_OUTPUT:\n+---\n+fail_compilation/must_use_template.d(15): Error: ignored value of `@mustuse` type `must_use_template.S!int`; prepend a `cast(void)` if intentional\n+---\n++/\n+import core.attribute;\n+\n+@mustuse struct S(T) {}\n+\n+S!int fun() { return S!int(); }\n+\n+void test()\n+{\n+    fun();\n+}"}, {"sha": "d42b324ee9b3f79d7d009322cf737aa7a7033f64", "filename": "gcc/testsuite/gdc.test/fail_compilation/must_use_union.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmust_use_union.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmust_use_union.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmust_use_union.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,16 @@\n+/+\n+TEST_OUTPUT:\n+---\n+fail_compilation/must_use_union.d(15): Error: ignored value of `@mustuse` type `must_use_union.U`; prepend a `cast(void)` if intentional\n+---\n++/\n+import core.attribute;\n+\n+@mustuse union U {}\n+\n+U fun() { return U(); }\n+\n+void test()\n+{\n+    fun();\n+}"}, {"sha": "5ef7324ce8ca8a94f0ada34077fa018dd99214de", "filename": "gcc/testsuite/gdc.test/fail_compilation/test11176.d", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest11176.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest11176.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest11176.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -12,6 +12,10 @@ fail_compilation/test11176.d(16): Error: `b.ptr` cannot be used in `@safe` code,\n     return *b.ptr;\n }\n \n-@safe ubyte oops(ubyte[3] b) {\n+@safe ubyte oops(ubyte[0] b) {\n+    return *b.ptr;\n+}\n+\n+@safe ubyte cool(ubyte[1] b) {\n     return *b.ptr;\n }"}, {"sha": "5bb3c2cc9f6dacf558c6141e41592236ae772e45", "filename": "gcc/testsuite/gdc.test/fail_compilation/test17284.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17284.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17284.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17284.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -1,8 +1,8 @@\n+/*\n TEST_OUTPUT:\n ---\n-fail_compilation/test17284.d(1): Error: no identifier for declarator `TEST_OUTPUT`\n-fail_compilation/test17284.d(1): Error: declaration expected, not `:`\n-fail_compilation/test17284.d(12): Error: unmatched closing brace\n+fail_compilation/test17284.d(16): Error: field `U.c` cannot access pointers in `@safe` code that overlap other fields\n+pure nothrow @safe void(U t)\n ---\n */\n "}, {"sha": "9c025a83ff052210c1015a84adb923eed4c3aee5", "filename": "gcc/testsuite/gdc.test/fail_compilation/test19097.d", "status": "modified", "additions": 59, "deletions": 5, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest19097.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest19097.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest19097.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -1,12 +1,19 @@\n /* REQUIRED_ARGS: -preview=dip1000\n  * TEST_OUTPUT:\n ---\n-fail_compilation/test19097.d(37): Error: scope variable `s` may not be returned\n-fail_compilation/test19097.d(66): Error: scope variable `z` assigned to `refPtr` with longer lifetime\n-fail_compilation/test19097.d(97): Error: scope variable `s` may not be returned\n+fail_compilation/test19097.d(44): Error: scope variable `s` may not be returned\n+fail_compilation/test19097.d(48): Error: scope variable `s1` may not be returned\n+fail_compilation/test19097.d(77): Error: scope variable `z` assigned to `refPtr` with longer lifetime\n+fail_compilation/test19097.d(108): Error: scope variable `s4` may not be returned\n+fail_compilation/test19097.d(126): Error: scope variable `s5c` may not be returned\n+fail_compilation/test19097.d(130): Error: scope variable `s5m` may not be returned\n+fail_compilation/test19097.d(147): Error: scope variable `s6c` may not be returned\n+fail_compilation/test19097.d(151): Error: scope variable `s6m` may not be returned\n ---\n  */\n \n+// Test extended return-scope / return-ref semantics, e.g. assigning to `this` or the first parameter\n+\n // https://issues.dlang.org/show_bug.cgi?id=19097\n \n @safe:\n@@ -35,6 +42,10 @@ S thorin()\n     int i;\n     S s = S(&i); // should infer scope for s\n     return s;    // so this should error\n+\n+    S s1;\n+    s1.mem(&i);\n+    return s1;\n }\n \n /************************/\n@@ -93,6 +104,49 @@ struct S4\n int* escape2()\n {\n     int x;\n-    auto s = S4(0, &x);\n-    return s.p;\n+    auto s4 = S4(0, &x);\n+    return s4.p;\n+}\n+\n+/************************/\n+// https://issues.dlang.org/show_bug.cgi?id=22801\n+struct S5\n+{\n+    int* a;\n+    this(return ref int b) { a = &b; }\n+\n+    int* c;\n+    void mem(return ref int d) scope { c = &d; }\n+}\n+\n+S5 frerin()\n+{\n+    int i;\n+    S5 s5c = S5(i); // should infer scope for s\n+    return s5c;    // so this should error\n+\n+    S5 s5m;\n+    s5m.mem(i);\n+    return s5m;\n+}\n+\n+\n+struct S6\n+{\n+    int** a;\n+    this(return ref int* b) { a = &b; }\n+\n+    int** c;\n+    void mem(return ref int* d) scope { c = &d; }\n+}\n+\n+S6 dis()\n+{\n+    int* i = null;\n+    S6 s6c = S6(i); // should infer scope for s\n+    return s6c;    // so this should error\n+\n+    S6 s6m;\n+    s6m.mem(i);\n+    return s6m;\n }"}, {"sha": "998cf1752d0269b547e8f09e8a0f25114615aeab", "filename": "gcc/testsuite/gdc.test/fail_compilation/test21008.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21008.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21008.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21008.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -5,12 +5,12 @@ fail_compilation/test21008.d(110): Error: function `test21008.C.after` circular\n fail_compilation/test21008.d(117): Error: need `this` for `toString` of type `string()`\n fail_compilation/test21008.d(117): Error: need `this` for `toHash` of type `nothrow @trusted $?:32=uint|64=ulong$()`\n fail_compilation/test21008.d(117): Error: function `object.Object.opCmp(Object o)` is not callable using argument types `()`\n-fail_compilation/test21008.d(117):        missing argument for parameter #1: `Object o`\n+fail_compilation/test21008.d(117):        too few arguments, expected `1`, got `0`\n fail_compilation/test21008.d(117): Error: function `object.Object.opEquals(Object o)` is not callable using argument types `()`\n-fail_compilation/test21008.d(117):        missing argument for parameter #1: `Object o`\n+fail_compilation/test21008.d(117):        too few arguments, expected `1`, got `0`\n fail_compilation/test21008.d(117): Error: `Monitor` has no effect\n fail_compilation/test21008.d(117): Error: function `object.Object.factory(string classname)` is not callable using argument types `()`\n-fail_compilation/test21008.d(117):        missing argument for parameter #1: `string classname`\n+fail_compilation/test21008.d(117):        too few arguments, expected `1`, got `0`\n fail_compilation/test21008.d(105):        called from here: `handleMiddlewareAnnotation()`\n fail_compilation/test21008.d(108): Error: class `test21008.C` no size because of forward reference\n ---"}, {"sha": "47fd3985555c06ecadcec582dac49177e13467f0", "filename": "gcc/testsuite/gdc.test/runnable/test20603.d", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest20603.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest20603.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest20603.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -0,0 +1,31 @@\n+// https://issues.dlang.org/show_bug.cgi?id=20603\n+\n+enum immutable(int)* x = new int(3);\n+enum const(int)* y = new int(5);\n+\n+struct Base {\n+    union {\n+        int overlap;\n+        immutable(Sub)* sub;\n+    }\n+\n+    this(Sub) {\n+        sub = new Sub;\n+    }\n+}\n+\n+struct Sub {\n+    Base base;\n+}\n+\n+immutable c0 = Base(Sub.init);\n+\n+void main()\n+{\n+    enum const(int)* z = new int(9);\n+\n+    assert(*x == 3);\n+    assert(*y == 5);\n+    assert(*z == 9);\n+    assert(c0.sub.base.sub == null);\n+}"}, {"sha": "8ae08ad2e47e148920e75dc881862db448ee2b58", "filename": "gcc/testsuite/gdc.test/runnable/xtest46.d", "status": "modified", "additions": 84, "deletions": 2, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fxtest46.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fxtest46.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fxtest46.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -3816,8 +3816,8 @@ void test153()\n /***************************************************/\n // https://issues.dlang.org/show_bug.cgi?id=3632\n \n-\n-void test154() {\n+void test154()\n+{\n     float f;\n     assert(f is float.init);\n     double d;\n@@ -3832,6 +3832,87 @@ void test154() {\n \n /***************************************************/\n \n+__gshared int global3632 = 1;\n+\n+void test3632()\n+{\n+    int test(T)()\n+    {\n+        static struct W\n+        {\n+            T f;\n+            this(T g) { if (__ctfe || global3632) f = g; }\n+        }\n+        auto nan = W(T.nan);\n+        auto nan2 = W(T.nan);\n+        auto init = W(T.init);\n+        auto init2 = W(T.init);\n+        auto zero = W(cast(T)0);\n+        auto zero2 = W(cast(T)0);\n+        auto nzero2 = W(-cast(T)0);\n+\n+        // Struct equality\n+        assert(!(nan == nan2));\n+        assert(!(nan == init2));\n+        assert(!(init == init2));\n+        assert( (zero == zero2));\n+        assert( (zero == nzero2));\n+\n+        // Float equality\n+        assert(!(nan.f == nan2.f));\n+        assert(!(nan.f == init2.f));\n+        assert(!(init.f == init2.f));\n+        assert( (zero.f == zero2.f));\n+        assert( (zero.f == nzero2.f));\n+\n+        // Struct identity\n+        assert( (nan is nan2));\n+        assert( (nan is init2));\n+        assert( (init is init2));\n+        assert( (zero is zero2));\n+        assert(!(zero is nzero2));\n+\n+        // Float identity\n+        assert( (nan.f is nan2.f));\n+        assert( (nan.f is init2.f));\n+        assert( (init.f is init2.f));\n+        assert( (zero.f is zero2.f));\n+        assert(!(zero.f is nzero2.f));\n+\n+        // Struct !identity\n+        assert(!(nan !is nan2));\n+        assert( (nan  is init2));\n+        assert(!(init !is init2));\n+        assert(!(zero !is zero2));\n+        assert( (zero !is nzero2));\n+\n+        // float !identity\n+        assert(!(nan.f !is nan2.f));\n+        assert( (nan.f is init2.f));\n+        assert(!(init.f !is init2.f));\n+        assert(!(zero.f !is zero2.f));\n+        assert( (zero.f !is nzero2.f));\n+\n+        // .init identity\n+        assert(W.init is W.init);\n+\n+        return 1;\n+    }\n+\n+    auto rtF = test!float();\n+    enum ctF = test!float();\n+    auto rtD = test!double();\n+    enum ctD = test!double();\n+    auto rtR = test!real();\n+    enum ctR = test!real();\n+\n+    assert(float.nan !is -float.nan);\n+    assert(double.nan !is -double.nan);\n+    assert(real.nan !is -real.nan);\n+}\n+\n+/***************************************************/\n+\n void test6545()\n {\n     static int[] func()\n@@ -8142,6 +8223,7 @@ int main()\n     test155();\n     test156();\n     test658();\n+    test3632();\n     test4258();\n     test4539();\n     test4963();"}, {"sha": "5e2566c9ceb99288b94c04ea04759f13a76ed2fc", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -1,4 +1,4 @@\n-c52e28b723ccfbe845a95e8e7b528e3cc0b9d790\n+9ba9a6ae2b8f6811cb85107cb56701df04f36ac6\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "e4326fd54c36e6aaab602ef16224834c2836421b", "filename": "libphobos/libdruntime/core/int128.d", "status": "modified", "additions": 91, "deletions": 65, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/libphobos%2Flibdruntime%2Fcore%2Fint128.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/libphobos%2Flibdruntime%2Fcore%2Fint128.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fint128.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -18,15 +18,26 @@ alias I = long;\n alias U = ulong;\n enum Ubits = uint(U.sizeof * 8);\n \n-align(16) struct Cent\n+version (X86_64) private enum Cent_alignment = 16;\n+else             private enum Cent_alignment = (size_t.sizeof * 2);\n+\n+align(Cent_alignment) struct Cent\n {\n-    U lo;      // low 64 bits\n-    U hi;      // high 64 bits\n+    version (LittleEndian)\n+    {\n+        U lo;  // low 64 bits\n+        U hi;  // high 64 bits\n+    }\n+    else\n+    {\n+        U hi;  // high 64 bits\n+        U lo;  // low 64 bits\n+    }\n }\n \n-enum One = Cent(1);\n-enum Zero = Cent();\n-enum MinusOne = neg(One);\n+enum Cent One = { lo:1 };\n+enum Cent Zero = { lo:0 };\n+enum Cent MinusOne = neg(One);\n \n /*****************************\n  * Test against 0\n@@ -320,7 +331,8 @@ Cent ror(Cent c, uint n)\n pure\n Cent and(Cent c1, Cent c2)\n {\n-    return Cent(c1.lo & c2.lo, c1.hi & c2.hi);\n+    const Cent ret = { lo:c1.lo & c2.lo, hi:c1.hi & c2.hi };\n+    return ret;\n }\n \n /****************************\n@@ -334,7 +346,8 @@ Cent and(Cent c1, Cent c2)\n pure\n Cent or(Cent c1, Cent c2)\n {\n-    return Cent(c1.lo | c2.lo, c1.hi | c2.hi);\n+    const Cent ret = { lo:c1.lo | c2.lo, hi:c1.hi | c2.hi };\n+    return ret;\n }\n \n /****************************\n@@ -348,7 +361,8 @@ Cent or(Cent c1, Cent c2)\n pure\n Cent xor(Cent c1, Cent c2)\n {\n-    return Cent(c1.lo ^ c2.lo, c1.hi ^ c2.hi);\n+    const Cent ret = { lo:c1.lo ^ c2.lo, hi:c1.hi ^ c2.hi };\n+    return ret;\n }\n \n /****************************\n@@ -363,7 +377,8 @@ pure\n Cent add(Cent c1, Cent c2)\n {\n     U r = cast(U)(c1.lo + c2.lo);\n-    return Cent(r, cast(U)(c1.hi + c2.hi + (r < c1.lo)));\n+    const Cent ret = { lo:r, hi:cast(U)(c1.hi + c2.hi + (r < c1.lo)) };\n+    return ret;\n }\n \n /****************************\n@@ -419,9 +434,9 @@ Cent mul(Cent c1, Cent c2)\n     const c1h1 = c1.hi >> mulshift;\n     r3 = c1h1 * c2l0 + (r3 & mulmask);\n \n-    return Cent((r0 & mulmask) + (r1 & mulmask) * (mulmask + 1),\n-                (r2 & mulmask) + (r3 & mulmask) * (mulmask + 1));\n-\n+    const Cent ret = { lo:(r0 & mulmask) + (r1 & mulmask) * (mulmask + 1),\n+                       hi:(r2 & mulmask) + (r3 & mulmask) * (mulmask + 1) };\n+    return ret;\n }\n \n \n@@ -523,8 +538,10 @@ Cent udivmod(Cent c1, Cent c2, out Cent modulus)\n     if (c1.hi == 0 && c2.hi == 0)\n     {\n         // Single precision divide\n-        modulus = Cent(c1.lo % c2.lo);\n-        return Cent(c1.lo / c2.lo);\n+        const Cent rem = { lo:c1.lo % c2.lo };\n+        modulus = rem;\n+        const Cent ret = { lo:c1.lo / c2.lo };\n+        return ret;\n     }\n     if (c1.hi == 0)\n     {\n@@ -539,10 +556,11 @@ Cent udivmod(Cent c1, Cent c2, out Cent modulus)\n         const q1 = (c1.hi < c2.lo) ? 0 : (c1.hi / c2.lo);\n         if (q1)\n             c1.hi = c1.hi % c2.lo;\n-        U rem;\n-        const q0 = udivmod128_64(c1, c2.lo, rem);\n-        modulus = Cent(rem);\n-        return Cent(q0, q1);\n+        Cent rem;\n+        const q0 = udivmod128_64(c1, c2.lo, rem.lo);\n+        modulus = rem;\n+        const Cent ret = { lo:q0, hi:q1 };\n+        return ret;\n     }\n \n     // Full cent precision division.\n@@ -560,10 +578,10 @@ Cent udivmod(Cent c1, Cent c2, out Cent modulus)\n \n     // Get quotient from divide unsigned operation.\n     U rem_ignored;\n-    const q1 = udivmod128_64(u1, v1, rem_ignored);\n+    const Cent q1 = { lo:udivmod128_64(u1, v1, rem_ignored) };\n \n     // Undo normalization and division of c1 by 2.\n-    Cent quotient = shr(shl(Cent(q1), shift), 63);\n+    Cent quotient = shr(shl(q1, shift), 63);\n \n     // Make quotient correct or too small by 1\n     if (tst(quotient))\n@@ -770,44 +788,44 @@ version (unittest)\n \n unittest\n {\n-    const C0 = Zero;\n-    const C1 = One;\n-    const C2 = Cent(2);\n-    const C3 = Cent(3);\n-    const C5 = Cent(5);\n-    const C10 = Cent(10);\n-    const C20 = Cent(20);\n-    const C30 = Cent(30);\n-    const C100 = Cent(100);\n-\n-    const Cm1 =  neg(One);\n-    const Cm3 =  neg(C3);\n-    const Cm10 = neg(C10);\n-\n-    const C3_1 = Cent(1,3);\n-    const C3_2 = Cent(2,3);\n-    const C4_8  = Cent(8, 4);\n-    const C5_0  = Cent(0, 5);\n-    const C7_1 = Cent(1,7);\n-    const C7_9 = Cent(9,7);\n-    const C9_3 = Cent(3,9);\n-    const C10_0 = Cent(0,10);\n-    const C10_1 = Cent(1,10);\n-    const C10_3 = Cent(3,10);\n-    const C11_3 = Cent(3,11);\n-    const C20_0 = Cent(0,20);\n-    const C90_30 = Cent(30,90);\n-\n-    const Cm10_0 = inc(com(C10_0)); // Cent(0, -10);\n-    const Cm10_1 = inc(com(C10_1)); // Cent(-1, -11);\n-    const Cm10_3 = inc(com(C10_3)); // Cent(-3, -11);\n-    const Cm20_0 = inc(com(C20_0)); // Cent(0, -20);\n-\n-    enum Cs_3 = Cent(3, I.min);\n-\n-    const Cbig_1 = Cent(0xa3ccac1832952398, 0xc3ac542864f652f8);\n-    const Cbig_2 = Cent(0x5267b85f8a42fc20, 0);\n-    const Cbig_3 = Cent(0xf0000000ffffffff, 0);\n+    const Cent C0 = Zero;\n+    const Cent C1 = One;\n+    const Cent C2 = { lo:2 };\n+    const Cent C3 = { lo:3 };\n+    const Cent C5 = { lo:5 };\n+    const Cent C10 = { lo:10 };\n+    const Cent C20 = { lo:20 };\n+    const Cent C30 = { lo:30 };\n+    const Cent C100 = { lo:100 };\n+\n+    const Cent Cm1 =  neg(One);\n+    const Cent Cm3 =  neg(C3);\n+    const Cent Cm10 = neg(C10);\n+\n+    const Cent C3_1 = { lo:1, hi:3 };\n+    const Cent C3_2 = { lo:2, hi:3 };\n+    const Cent C4_8  = { lo:8, hi:4 };\n+    const Cent C5_0  = { lo:0, hi:5 };\n+    const Cent C7_1 = { lo:1, hi:7 };\n+    const Cent C7_9 = { lo:9, hi:7 };\n+    const Cent C9_3 = { lo:3, hi:9 };\n+    const Cent C10_0 = { lo:0, hi:10 };\n+    const Cent C10_1 = { lo:1, hi:10 };\n+    const Cent C10_3 = { lo:3, hi:10 };\n+    const Cent C11_3 = { lo:3, hi:11 };\n+    const Cent C20_0 = { lo:0, hi:20 };\n+    const Cent C90_30 = { lo:30, hi:90 };\n+\n+    const Cent Cm10_0 = inc(com(C10_0)); // Cent(lo=0,  hi=-10);\n+    const Cent Cm10_1 = inc(com(C10_1)); // Cent(lo=-1, hi=-11);\n+    const Cent Cm10_3 = inc(com(C10_3)); // Cent(lo=-3, hi=-11);\n+    const Cent Cm20_0 = inc(com(C20_0)); // Cent(lo=0,  hi=-20);\n+\n+    enum Cent Cs_3 = { lo:3, hi:I.min };\n+\n+    const Cent Cbig_1 = { lo:0xa3ccac1832952398, hi:0xc3ac542864f652f8 };\n+    const Cent Cbig_2 = { lo:0x5267b85f8a42fc20, hi:0 };\n+    const Cent Cbig_3 = { lo:0xf0000000ffffffff, hi:0 };\n \n     /************************/\n \n@@ -893,12 +911,20 @@ unittest\n     assert(div(mul(C90_30, C2), C2) == C90_30);\n     assert(div(mul(C90_30, C2), C90_30) == C2);\n \n-    assert(divmod(Cbig_1, Cbig_2, modulus) == Cent(0x4496aa309d4d4a2f, U.max));\n-    assert(modulus == Cent(0xd83203d0fdc799b8, U.max));\n-    assert(udivmod(Cbig_1, Cbig_2, modulus) == Cent(0x5fe0e9bace2bedad, 2));\n-    assert(modulus == Cent(0x2c923125a68721f8, 0));\n-    assert(div(Cbig_1, Cbig_3) == Cent(0xbfa6c02b5aff8b86, U.max));\n-    assert(udiv(Cbig_1, Cbig_3) == Cent(0xd0b7d13b48cb350f, 0));\n+    const Cent Cb1divb2 = { lo:0x4496aa309d4d4a2f, hi:U.max };\n+    const Cent Cb1modb2 = { lo:0xd83203d0fdc799b8, hi:U.max };\n+    assert(divmod(Cbig_1, Cbig_2, modulus) == Cb1divb2);\n+    assert(modulus == Cb1modb2);\n+\n+    const Cent Cb1udivb2 = { lo:0x5fe0e9bace2bedad, hi:2 };\n+    const Cent Cb1umodb2 = { lo:0x2c923125a68721f8, hi:0 };\n+    assert(udivmod(Cbig_1, Cbig_2, modulus) == Cb1udivb2);\n+    assert(modulus == Cb1umodb2);\n+\n+    const Cent Cb1divb3 = { lo:0xbfa6c02b5aff8b86, hi:U.max };\n+    const Cent Cb1udivb3 = { lo:0xd0b7d13b48cb350f, hi:0 };\n+    assert(div(Cbig_1, Cbig_3) == Cb1divb3);\n+    assert(udiv(Cbig_1, Cbig_3) == Cb1udivb3);\n \n     assert(mul(Cm10, C1) == Cm10);\n     assert(mul(C1, Cm10) == Cm10);"}, {"sha": "47fed9dc5140f7b88d2f0b37724806956d1c2aef", "filename": "libphobos/libdruntime/core/lifetime.d", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/libphobos%2Flibdruntime%2Fcore%2Flifetime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/libphobos%2Flibdruntime%2Fcore%2Flifetime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Flifetime.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -1273,7 +1273,9 @@ void copyEmplace(S, T)(ref S source, ref T target) @system\n         }\n         else static if (__traits(hasCopyConstructor, T))\n         {\n-            emplace(cast(Unqual!(T)*) &target); // blit T.init\n+            // https://issues.dlang.org/show_bug.cgi?id=22766\n+            import core.internal.lifetime : emplaceInitializer;\n+            emplaceInitializer(*(cast(Unqual!T*)&target));\n             static if (__traits(isNested, T))\n             {\n                  // copy context pointer\n@@ -1373,6 +1375,22 @@ void copyEmplace(S, T)(ref S source, ref T target) @system\n     static assert(!__traits(compiles, copyEmplace(ss, t)));\n }\n \n+// https://issues.dlang.org/show_bug.cgi?id=22766\n+@system pure nothrow @nogc unittest\n+{\n+    static struct S\n+    {\n+        @disable this();\n+        this(int) @safe pure nothrow @nogc{}\n+        this(ref const(S) other) @safe pure nothrow @nogc {}\n+    }\n+\n+    S s1 = S(1);\n+    S s2 = void;\n+    copyEmplace(s1, s2);\n+    assert(s2 == S(1));\n+}\n+\n version (DigitalMars) version (X86) version (Posix) version = DMD_X86_Posix;\n \n // don't violate immutability for reference types"}, {"sha": "0feb0b01ef5fec762df27b150ff576b840825137", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -1,4 +1,4 @@\n-99e9c1b7741e0f4e6f2a8c14883c4828d092701d\n+c0cc5e917db105301dd1199b4b3c854626526407\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "73c6534d8da5df0c331e15c2c2a2e75ab83a18ed", "filename": "libphobos/src/etc/c/zlib.d", "status": "modified", "additions": 114, "deletions": 97, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/libphobos%2Fsrc%2Fetc%2Fc%2Fzlib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/libphobos%2Fsrc%2Fetc%2Fc%2Fzlib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fetc%2Fc%2Fzlib.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -2,15 +2,16 @@\n /* updated from 1.2.1 to 1.2.3 by Thomas Kuehne */\n /* updated from 1.2.3 to 1.2.8 by Dmitry Atamanov */\n /* updated from 1.2.8 to 1.2.11 by Iain Buclaw */\n+/* updated from 1.2.11 to 1.2.12 by Brian Callahan */\n \n module etc.c.zlib;\n \n import core.stdc.config;\n \n /* zlib.h -- interface of the 'zlib' general purpose compression library\n-  version 1.2.11, January 15th, 2017\n+  version 1.2.12, March 11th, 2022\n \n-  Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler\n+  Copyright (C) 1995-2022 Jean-loup Gailly and Mark Adler\n \n   This software is provided 'as-is', without any express or implied\n   warranty.  In no event will the authors be held liable for any damages\n@@ -42,8 +43,8 @@ nothrow:\n extern (C):\n \n // Those are extern(D) as they should be mangled\n-extern(D) immutable string ZLIB_VERSION = \"1.2.11\";\n-extern(D) immutable ZLIB_VERNUM = 0x12b0;\n+extern(D) immutable string ZLIB_VERSION = \"1.2.12\";\n+extern(D) immutable ZLIB_VERNUM = 0x12c0;\n \n /*\n     The 'zlib' compression library provides in-memory compression and\n@@ -566,8 +567,7 @@ int deflateInit2(z_streamp strm,\n }\n /*\n      This is another version of deflateInit with more compression options.  The\n-   fields next_in, zalloc, zfree and opaque must be initialized before by the\n-   caller.\n+   fields zalloc, zfree and opaque must be initialized before by the caller.\n \n      The method parameter is the compression method.  It must be Z_DEFLATED in\n    this version of the library.\n@@ -586,7 +586,7 @@ int deflateInit2(z_streamp strm,\n    with deflateInit2() with this initialization, or at least in that case use 9\n    with inflateInit2().\n \n-     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits\n+     windowBits can also be -8 .. -15 for raw deflate.  In this case, -windowBits\n    determines the window size.  deflate() will then generate raw deflate data\n    with no zlib header or trailer, and will not compute a check value.\n \n@@ -728,11 +728,12 @@ int deflateParams(z_streamp strm, int level, int strategy);\n    used to switch between compression and straight copy of the input data, or\n    to switch to a different kind of input data requiring a different strategy.\n    If the compression approach (which is a function of the level) or the\n-   strategy is changed, and if any input has been consumed in a previous\n-   deflate() call, then the input available so far is compressed with the old\n-   level and strategy using deflate(strm, Z_BLOCK).  There are three approaches\n-   for the compression levels 0, 1 .. 3, and 4 .. 9 respectively.  The new level\n-   and strategy will take effect at the next call of deflate().\n+   strategy is changed, and if there have been any deflate() calls since the\n+   state was initialized or reset, then the input available so far is\n+   compressed with the old level and strategy using deflate(strm, Z_BLOCK).\n+   There are three approaches for the compression levels 0, 1 .. 3, and 4 .. 9\n+   respectively.  The new level and strategy will take effect at the next call\n+   of deflate().\n \n      If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does\n    not have enough output space to complete, then the parameter change will not\n@@ -856,7 +857,7 @@ int inflateInit2(z_streamp strm, int windowBits)\n      windowBits can also be zero to request that inflate use the window size in\n    the zlib header of the compressed stream.\n \n-     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits\n+     windowBits can also be -8 .. -15 for raw inflate.  In this case, -windowBits\n    determines the window size.  inflate() will then process raw deflate data,\n    not looking for a zlib or gzip header, not generating a check value, and not\n    looking for any check values for comparison at the end of the stream.  This\n@@ -873,9 +874,11 @@ int inflateInit2(z_streamp strm, int windowBits)\n    detection, or add 16 to decode only the gzip format (the zlib format will\n    return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a\n    CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see\n-   below), inflate() will not automatically decode concatenated gzip streams.\n-   inflate() will return Z_STREAM_END at the end of the gzip stream.  The state\n-   would need to be reset to continue decoding a subsequent gzip stream.\n+   below), inflate() will *not* automatically decode concatenated gzip members.\n+   inflate() will return Z_STREAM_END at the end of the gzip member.  The state\n+   would need to be reset to continue decoding a subsequent gzip member.  This\n+   *must* be done if there is more data after a gzip member, in order for the\n+   decompression to be compliant with the gzip standard (RFC 1952).\n \n      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n    memory, Z_VERSION_ERROR if the zlib library version is incompatible with the\n@@ -1311,14 +1314,14 @@ alias z_size_t = size_t;\n \n gzFile gzopen(const(char)* path, const(char)* mode);\n /*\n-     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as\n-   in fopen (\"rb\" or \"wb\") but can also include a compression level (\"wb9\") or\n-   a strategy: 'f' for filtered data as in \"wb6f\", 'h' for Huffman-only\n-   compression as in \"wb1h\", 'R' for run-length encoding as in \"wb1R\", or 'F'\n-   for fixed code compression as in \"wb9F\".  (See the description of\n-   deflateInit2 for more information about the strategy parameter.)  'T' will\n-   request transparent writing or appending with no compression and not using\n-   the gzip format.\n+     Open the gzip (.gz) file at path for reading and decompressing, or\n+   compressing and writing.  The mode parameter is as in fopen (\"rb\" or \"wb\")\n+   but can also include a compression level (\"wb9\") or a strategy: 'f' for\n+   filtered data as in \"wb6f\", 'h' for Huffman-only compression as in \"wb1h\",\n+   'R' for run-length encoding as in \"wb1R\", or 'F' for fixed code compression\n+   as in \"wb9F\".  (See the description of deflateInit2 for more information\n+   about the strategy parameter.)  'T' will request transparent writing or\n+   appending with no compression and not using the gzip format.\n \n      \"a\" can be used instead of \"w\" to request that the gzip stream that will\n    be written be appended to the file.  \"+\" will result in an error, since\n@@ -1348,9 +1351,9 @@ gzFile gzopen(const(char)* path, const(char)* mode);\n \n gzFile gzdopen(int fd, const(char)* mode);\n /*\n-     gzdopen associates a gzFile with the file descriptor fd.  File descriptors\n-   are obtained from calls like open, dup, creat, pipe or fileno (if the file\n-   has been previously opened with fopen).  The mode parameter is as in gzopen.\n+     Associate a gzFile with the file descriptor fd.  File descriptors are\n+   obtained from calls like open, dup, creat, pipe or fileno (if the file has\n+   been previously opened with fopen).  The mode parameter is as in gzopen.\n \n      The next call of gzclose on the returned gzFile will also close the file\n    descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor\n@@ -1371,13 +1374,13 @@ gzFile gzdopen(int fd, const(char)* mode);\n \n int gzbuffer(gzFile file, uint size);\n /*\n-     Set the internal buffer size used by this library's functions.  The\n-   default buffer size is 8192 bytes.  This function must be called after\n-   gzopen() or gzdopen(), and before any other calls that read or write the\n-   file.  The buffer memory allocation is always deferred to the first read or\n-   write.  Three times that size in buffer space is allocated.  A larger buffer\n-   size of, for example, 64K or 128K bytes will noticeably increase the speed\n-   of decompression (reading).\n+     Set the internal buffer size used by this library's functions for file to\n+   size.  The default buffer size is 8192 bytes.  This function must be called\n+   after gzopen() or gzdopen(), and before any other calls that read or write\n+   the file.  The buffer memory allocation is always deferred to the first read\n+   or write.  Three times that size in buffer space is allocated.  A larger\n+   buffer size of, for example, 64K or 128K bytes will noticeably increase the\n+   speed of decompression (reading).\n \n      The new buffer size also affects the maximum length for gzprintf().\n \n@@ -1387,9 +1390,9 @@ int gzbuffer(gzFile file, uint size);\n \n int gzsetparams(gzFile file, int level, int strategy);\n /*\n-     Dynamically update the compression level or strategy.  See the description\n-   of deflateInit2 for the meaning of these parameters.  Previously provided\n-   data is flushed before the parameter change.\n+     Dynamically update the compression level and strategy for file.  See the\n+   description of deflateInit2 for the meaning of these parameters. Previously\n+   provided data is flushed before applying the parameter changes.\n \n      gzsetparams returns Z_OK if success, Z_STREAM_ERROR if the file was not\n    opened for writing, Z_ERRNO if there is an error writing the flushed data,\n@@ -1398,7 +1401,7 @@ int gzsetparams(gzFile file, int level, int strategy);\n \n int gzread(gzFile file, void* buf, uint len);\n /*\n-     Reads the given number of uncompressed bytes from the compressed file.  If\n+     Read and decompress up to len uncompressed bytes from file into buf.  If\n    the input file is not in gzip format, gzread copies the given number of\n    bytes into the buffer directly from the file.\n \n@@ -1428,11 +1431,11 @@ int gzread(gzFile file, void* buf, uint len);\n \n z_size_t gzfread(void* buf, z_size_t size, z_size_t nitems, gzFile file);\n /*\n-     Read up to nitems items of size size from file to buf, otherwise operating\n-   as gzread() does.  This duplicates the interface of stdio's fread(), with\n-   size_t request and return types.  If the library defines size_t, then\n-   z_size_t is identical to size_t.  If not, then z_size_t is an unsigned\n-   integer type that can contain a pointer.\n+     Read and decompress up to nitems items of size size from file into buf,\n+   otherwise operating as gzread() does.  This duplicates the interface of\n+   stdio's fread(), with size_t request and return types.  If the library\n+   defines size_t, then z_size_t is identical to size_t.  If not, then z_size_t\n+   is an unsigned integer type that can contain a pointer.\n \n      gzfread() returns the number of full items read of size size, or zero if\n    the end of the file was reached and a full item could not be read, or if\n@@ -1453,14 +1456,13 @@ z_size_t gzfread(void* buf, z_size_t size, z_size_t nitems, gzFile file);\n \n int gzwrite(gzFile file, void* buf, uint len);\n /*\n-     Writes the given number of uncompressed bytes into the compressed file.\n-   gzwrite returns the number of uncompressed bytes written or 0 in case of\n-   error.\n+     Compress and write the len uncompressed bytes at buf to file. gzwrite\n+   returns the number of uncompressed bytes written or 0 in case of error.\n */\n \n z_size_t gzfwrite(void* buf, z_size_t size, z_size_t nitems, gzFile file);\n /*\n-     gzfwrite() writes nitems items of size size from buf to file, duplicating\n+     Compress and write nitems items of size size from buf to file, duplicating\n    the interface of stdio's fwrite(), with size_t request and return types.  If\n    the library defines size_t, then z_size_t is identical to size_t.  If not,\n    then z_size_t is an unsigned integer type that can contain a pointer.\n@@ -1473,34 +1475,35 @@ z_size_t gzfwrite(void* buf, z_size_t size, z_size_t nitems, gzFile file);\n \n int gzprintf(gzFile file, const(char)* format, ...);\n /*\n-     Converts, formats, and writes the arguments to the compressed file under\n-   control of the format string, as in fprintf.  gzprintf returns the number of\n+     Convert, format, compress, and write the arguments (...) to file under\n+   control of the string format, as in fprintf.  gzprintf returns the number of\n    uncompressed bytes actually written, or a negative zlib error code in case\n    of error.  The number of uncompressed bytes written is limited to 8191, or\n    one less than the buffer size given to gzbuffer().  The caller should assure\n    that this limit is not exceeded.  If it is exceeded, then gzprintf() will\n    return an error (0) with nothing written.  In this case, there may also be a\n    buffer overflow with unpredictable consequences, which is possible only if\n-   zlib was compiled with the insecure functions sprintf() or vsprintf()\n+   zlib was compiled with the insecure functions sprintf() or vsprintf(),\n    because the secure snprintf() or vsnprintf() functions were not available.\n    This can be determined using zlibCompileFlags().\n */\n \n int gzputs(gzFile file, const(char)* s);\n /*\n-     Writes the given null-terminated string to the compressed file, excluding\n+     Compress and write the given null-terminated string s to file, excluding\n    the terminating null character.\n \n      gzputs returns the number of characters written, or -1 in case of error.\n */\n \n const(char)* gzgets(gzFile file, const(char)* buf, int len);\n /*\n-     Reads bytes from the compressed file until len-1 characters are read, or a\n-   newline character is read and transferred to buf, or an end-of-file\n-   condition is encountered.  If any characters are read or if len == 1, the\n-   string is terminated with a null character.  If no characters are read due\n-   to an end-of-file or len < 1, then the buffer is left untouched.\n+     Read and decompress bytes from file into buf, until len-1 characters are\n+   read, or until a newline character is read and transferred to buf, or an\n+   end-of-file condition is encountered.  If any characters are read or if len\n+   is one, the string is terminated with a null character.  If no characters\n+   are read due to an end-of-file or len is less than one, then the buffer is\n+   left untouched.\n \n      gzgets returns buf which is a null-terminated string, or it returns NULL\n    for end-of-file or in case of error.  If there was an error, the contents at\n@@ -1509,13 +1512,13 @@ const(char)* gzgets(gzFile file, const(char)* buf, int len);\n \n int gzputc(gzFile file, int c);\n /*\n-     Writes c, converted to an unsigned char, into the compressed file.  gzputc\n+     Compress and write c, converted to an unsigned char, into file.  gzputc\n    returns the value that was written, or -1 in case of error.\n */\n \n int gzgetc(gzFile file);\n /*\n-     Reads one byte from the compressed file.  gzgetc returns this byte or -1\n+     Read and decompress one byte from file.  gzgetc returns this byte or -1\n    in case of end of file or error.  This is implemented as a macro for speed.\n    As such, it does not do all of the checking the other functions do.  I.e.\n    it does not check to see if file is NULL, nor whether the structure file\n@@ -1524,8 +1527,8 @@ int gzgetc(gzFile file);\n \n int gzungetc(int c, gzFile file);\n /*\n-     Push one character back onto the stream to be read as the first character\n-   on the next read.  At least one character of push-back is allowed.\n+     Push c back onto the stream for file to be read as the first character on\n+   the next read.  At least one character of push-back is always allowed.\n    gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will\n    fail if c is -1, and may fail if a character has been pushed but not read\n    yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the\n@@ -1536,9 +1539,9 @@ int gzungetc(int c, gzFile file);\n \n int gzflush(gzFile file, int flush);\n /*\n-     Flushes all pending output into the compressed file.  The parameter flush\n-   is as in the deflate() function.  The return value is the zlib error number\n-   (see function gzerror below).  gzflush is only permitted when writing.\n+     Flush all pending output to file.  The parameter flush is as in the\n+   deflate() function.  The return value is the zlib error number (see function\n+   gzerror below).  gzflush is only permitted when writing.\n \n      If the flush parameter is Z_FINISH, the remaining data is written and the\n    gzip stream is completed in the output.  If gzwrite() is called again, a new\n@@ -1551,8 +1554,8 @@ int gzflush(gzFile file, int flush);\n \n z_off_t gzseek(gzFile file, z_off_t offset, int whence);\n /*\n-     Sets the starting position for the next gzread or gzwrite on the given\n-   compressed file.  The offset represents a number of bytes in the\n+     Set the starting position to offset relative to whence for the next gzread\n+   or gzwrite on file.  The offset represents a number of bytes in the\n    uncompressed data stream.  The whence parameter is defined as in lseek(2);\n    the value SEEK_END is not supported.\n \n@@ -1569,39 +1572,39 @@ z_off_t gzseek(gzFile file, z_off_t offset, int whence);\n \n int gzrewind(gzFile file);\n /*\n-     Rewinds the given file. This function is supported only for reading.\n+     Rewind file. This function is supported only for reading.\n \n-     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)\n+     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET).\n */\n \n z_off_t gztell(gzFile file);\n /*\n-     Returns the starting position for the next gzread or gzwrite on the given\n-   compressed file.  This position represents a number of bytes in the\n-   uncompressed data stream, and is zero when starting, even if appending or\n-   reading a gzip stream from the middle of a file using gzdopen().\n+     Return the starting position for the next gzread or gzwrite on file.\n+   This position represents a number of bytes in the uncompressed data stream,\n+   and is zero when starting, even if appending or reading a gzip stream from\n+   the middle of a file using gzdopen().\n \n      gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)\n */\n \n z_off_t gzoffset(gzFile file);\n /*\n-     Returns the current offset in the file being read or written.  This offset\n-   includes the count of bytes that precede the gzip stream, for example when\n-   appending or when using gzdopen() for reading.  When reading, the offset\n-   does not include as yet unused buffered input.  This information can be used\n-   for a progress indicator.  On error, gzoffset() returns -1.\n+     Return the current compressed (actual) read or write offset of file.  This\n+   offset includes the count of bytes that precede the gzip stream, for example\n+   when appending or when using gzdopen() for reading.  When reading, the\n+   offset does not include as yet unused buffered input.  This information can\n+   be used for a progress indicator.  On error, gzoffset() returns -1.\n */\n \n int gzeof(gzFile file);\n /*\n-     Returns true (1) if the end-of-file indicator has been set while reading,\n-   false (0) otherwise.  Note that the end-of-file indicator is set only if the\n-   read tried to go past the end of the input, but came up short.  Therefore,\n-   just like feof(), gzeof() may return false even if there is no more data to\n-   read, in the event that the last read request was for the exact number of\n-   bytes remaining in the input file.  This will happen if the input file size\n-   is an exact multiple of the buffer size.\n+     Return true (1) if the end-of-file indicator for file has been set while\n+   reading, false (0) otherwise.  Note that the end-of-file indicator is set\n+   only if the read tried to go past the end of the input, but came up short.\n+   Therefore, just like feof(), gzeof() may return false even if there is no\n+   more data to read, in the event that the last read request was for the exact\n+   number of bytes remaining in the input file.  This will happen if the input\n+   file size is an exact multiple of the buffer size.\n \n      If gzeof() returns true, then the read functions will return no more data,\n    unless the end-of-file indicator is reset by gzclearerr() and the input file\n@@ -1610,7 +1613,7 @@ int gzeof(gzFile file);\n \n int gzdirect(gzFile file);\n /*\n-     Returns true (1) if file is being copied directly while reading, or false\n+     Return true (1) if file is being copied directly while reading, or false\n    (0) if file is a gzip stream being decompressed.\n \n      If the input file is empty, gzdirect() will return true, since the input\n@@ -1631,8 +1634,8 @@ int gzdirect(gzFile file);\n \n int gzclose(gzFile file);\n /*\n-     Flushes all pending output if necessary, closes the compressed file and\n-   deallocates the (de)compression state.  Note that once file is closed, you\n+     Flush all pending output for file, if necessary, close file and\n+   deallocate the (de)compression state.  Note that once file is closed, you\n    cannot call gzerror with file, since its structures have been deallocated.\n    gzclose must not be called more than once on the same file, just as free\n    must not be called more than once on the same allocation.\n@@ -1656,10 +1659,10 @@ int gzclose_w(gzFile file);\n \n const(char)* gzerror(gzFile file, int* errnum);\n /*\n-     Returns the error message for the last error which occurred on the given\n-   compressed file.  errnum is set to zlib error number.  If an error occurred\n-   in the file system and not in the compression library, errnum is set to\n-   Z_ERRNO and the application may consult errno to get the exact error code.\n+     Return the error message for the last error which occurred on file.\n+   errnum is set to zlib error number.  If an error occurred in the file system\n+   and not in the compression library, errnum is set to Z_ERRNO and the\n+   application may consult errno to get the exact error code.\n \n      The application must not modify the returned string.  Future calls to\n    this function may invalidate the previously returned string.  If file is\n@@ -1672,7 +1675,7 @@ const(char)* gzerror(gzFile file, int* errnum);\n \n void gzclearerr(gzFile file);\n /*\n-     Clears the error and end-of-file flags for file.  This is analogous to the\n+     Clear the error and end-of-file flags for file.  This is analogous to the\n    clearerr() function in stdio.  This is useful for continuing to read a gzip\n    file that is being written concurrently.\n */\n@@ -1688,8 +1691,9 @@ void gzclearerr(gzFile file);\n uint adler32(uint adler, const(ubyte)* buf, uint len);\n /*\n      Update a running Adler-32 checksum with the bytes buf[0 .. len-1] and\n-   return the updated checksum.  If buf is Z_NULL, this function returns the\n-   required initial value for the checksum.\n+   return the updated checksum. An Adler-32 value is in the range of a 32-bit\n+   unsigned integer. If buf is Z_NULL, this function returns the required\n+   initial value for the checksum.\n \n      An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed\n    much faster.\n@@ -1722,9 +1726,10 @@ uint adler32_combine(uint adler1, uint adler2, z_off_t len2);\n uint crc32(uint crc, const(ubyte)* buf, uint len);\n /*\n      Update a running CRC-32 with the bytes buf[0 .. len-1] and return the\n-   updated CRC-32.  If buf is Z_NULL, this function returns the required\n-   initial value for the crc.  Pre- and post-conditioning (one's complement) is\n-   performed within this function so it shouldn't be done by the application.\n+   updated CRC-32. A CRC-32 value is in the range of a 32-bit unsigned integer.\n+   If buf is Z_NULL, this function returns the required initial value for the\n+   crc. Pre- and post-conditioning (one's complement) is performed within this\n+   function so it shouldn't be done by the application.\n \n    Usage example:\n \n@@ -1736,7 +1741,7 @@ uint crc32(uint crc, const(ubyte)* buf, uint len);\n      if (crc != original_crc) error();\n */\n \n-uint crc32_z(uint adler, const(ubyte)* buf, z_size_t len);\n+uint crc32_z(uint crc, const(ubyte)* buf, z_size_t len);\n /*\n      Same as crc32(), but with a size_t length.\n */\n@@ -1751,6 +1756,18 @@ uint crc32_combine(uint crc1, uint crc2, z_off_t len2);\n    len2.\n */\n \n+uint crc32_combine_gen(z_off_t len2);\n+/*\n+     Return the operator corresponding to length len2, to be used with\n+   crc32_combine_op().\n+*/\n+\n+uint crc32_combine_op(uint crc1, uint crc2, uint op);\n+/*\n+     Give the same result as crc32_combine(), using op in place of len2. op is\n+   is generated from len2 by crc32_combine_gen(). This will be faster than\n+   crc32_combine() if the generated op is used more than once.\n+*/\n \n                         /* various hacks, don't look :) */\n "}, {"sha": "448bb99a9a132fd2a7c37cae59abec446b316a40", "filename": "libphobos/src/std/regex/internal/parser.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31350635bfd90beea79b0e9220008da12bbb5d22/libphobos%2Fsrc%2Fstd%2Fregex%2Finternal%2Fparser.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31350635bfd90beea79b0e9220008da12bbb5d22/libphobos%2Fsrc%2Fstd%2Fregex%2Finternal%2Fparser.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fregex%2Finternal%2Fparser.d?ref=31350635bfd90beea79b0e9220008da12bbb5d22", "patch": "@@ -841,7 +841,7 @@ if (isForwardRange!R && is(ElementType!R : dchar))\n         switch (front)\n         {\n         case '*', '?', '+', '|', '{', '}':\n-            error(\"'*', '+', '?', '{', '}' not allowed in atom\");\n+            return error(\"'*', '+', '?', '{', '}' not allowed in atom\");\n         case '.':\n             if (re_flags & RegexOption.singleline)\n                 g.put(Bytecode(IR.Any, 0));"}]}