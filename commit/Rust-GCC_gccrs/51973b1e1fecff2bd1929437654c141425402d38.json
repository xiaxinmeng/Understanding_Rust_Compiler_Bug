{"sha": "51973b1e1fecff2bd1929437654c141425402d38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE5NzNiMWUxZmVjZmYyYmQxOTI5NDM3NjU0YzE0MTQyNTQwMmQzOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-10-20T11:49:31Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-10-20T11:49:31Z"}, "message": "lto.c (node_cmp, [...]): New functions.\n\n\n\t* lto.c (node_cmp, varpool_node_cmp): New functions.\n\t(lto_balanced_map): Honnor -fno-toplevel-reorder of vars&functions.\n\t(cmp_partitions): Rename to ...\n\t(cmp_partitions_size): ... this one.\n\t(cmp_partitions_order): New function.\n\t(lto_wpa_write_files): Sort partitions by order when\n\t-fno-toplevel-reorder is used.\n\nFrom-SVN: r180248", "tree": {"sha": "644d8527947266a707ace73a535961b21cadea3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/644d8527947266a707ace73a535961b21cadea3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51973b1e1fecff2bd1929437654c141425402d38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51973b1e1fecff2bd1929437654c141425402d38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51973b1e1fecff2bd1929437654c141425402d38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51973b1e1fecff2bd1929437654c141425402d38/comments", "author": null, "committer": null, "parents": [{"sha": "8ec802d7d8812cdaaa7516edc624b6e66e419f94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ec802d7d8812cdaaa7516edc624b6e66e419f94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ec802d7d8812cdaaa7516edc624b6e66e419f94"}], "stats": {"total": 118, "additions": 110, "deletions": 8}, "files": [{"sha": "5de85dd4f33ecdea105a1d3f8426cef7fdd67b8d", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51973b1e1fecff2bd1929437654c141425402d38/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51973b1e1fecff2bd1929437654c141425402d38/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=51973b1e1fecff2bd1929437654c141425402d38", "patch": "@@ -1,3 +1,13 @@\n+2011-10-09  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (node_cmp, varpool_node_cmp): New functions.\n+\t(lto_balanced_map): Honnor -fno-toplevel-reorder of vars&functions.\n+\t(cmp_partitions): Rename to ...\n+\t(cmp_partitions_size): ... this one.\n+\t(cmp_partitions_order): New function.\n+\t(lto_wpa_write_files): Sort partitions by order when\n+\t-fno-toplevel-reorder is used.\n+\n 2011-10-09  Andi Kleen  <ak@linux.intel.com>\n \n \t* lto.c (lto_section_read): Call fatal_error on IO or mmap errors."}, {"sha": "40afc7f1c9b280badcf34ef9c0e938810779f0c7", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 100, "deletions": 8, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51973b1e1fecff2bd1929437654c141425402d38/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51973b1e1fecff2bd1929437654c141425402d38/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=51973b1e1fecff2bd1929437654c141425402d38", "patch": "@@ -1665,6 +1665,23 @@ lto_1_to_1_map (void)\n \t\t\t\t\t\t ltrans_partitions);\n }\n \n+/* Helper function for qsort; sort nodes by order.  */\n+static int\n+node_cmp (const void *pa, const void *pb)\n+{\n+  const struct cgraph_node *a = *(const struct cgraph_node * const *) pa;\n+  const struct cgraph_node *b = *(const struct cgraph_node * const *) pb;\n+  return b->order - a->order;\n+}\n+\n+/* Helper function for qsort; sort nodes by order.  */\n+static int\n+varpool_node_cmp (const void *pa, const void *pb)\n+{\n+  const struct varpool_node *a = *(const struct varpool_node * const *) pa;\n+  const struct varpool_node *b = *(const struct varpool_node * const *) pb;\n+  return b->order - a->order;\n+}\n \n /* Group cgraph nodes into equally-sized partitions.\n \n@@ -1708,9 +1725,11 @@ static void\n lto_balanced_map (void)\n {\n   int n_nodes = 0;\n+  int n_varpool_nodes = 0, varpool_pos = 0;\n   struct cgraph_node **postorder =\n     XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);\n   struct cgraph_node **order = XNEWVEC (struct cgraph_node *, cgraph_max_uid);\n+  struct varpool_node **varpool_order = NULL;\n   int i, postorder_len;\n   struct cgraph_node *node;\n   int total_size = 0, best_total_size = 0;\n@@ -1722,6 +1741,7 @@ lto_balanced_map (void)\n   int best_n_nodes = 0, best_n_varpool_nodes = 0, best_i = 0, best_cost =\n     INT_MAX, best_internal = 0;\n   int npartitions;\n+  int current_order = -1;\n \n   for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n     gcc_assert (!vnode->aux);\n@@ -1731,6 +1751,7 @@ lto_balanced_map (void)\n      multiple partitions, this is just an estimate of real size.  This is why\n      we keep partition_size updated after every partition is finalized.  */\n   postorder_len = ipa_reverse_postorder (postorder);\n+    \n   for (i = 0; i < postorder_len; i++)\n     {\n       node = postorder[i];\n@@ -1742,6 +1763,23 @@ lto_balanced_map (void)\n     }\n   free (postorder);\n \n+  if (!flag_toplevel_reorder)\n+    {\n+      qsort (order, n_nodes, sizeof (struct cgraph_node *), node_cmp);\n+\n+      for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+\tif (partition_varpool_node_p (vnode))\n+\t  n_varpool_nodes++;\n+      varpool_order = XNEWVEC (struct varpool_node *, n_varpool_nodes);\n+\n+      n_varpool_nodes = 0;\n+      for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+\tif (partition_varpool_node_p (vnode))\n+\t  varpool_order[n_varpool_nodes++] = vnode;\n+      qsort (varpool_order, n_varpool_nodes, sizeof (struct varpool_node *),\n+\t     varpool_node_cmp);\n+    }\n+\n   /* Compute partition size and create the first partition.  */\n   partition_size = total_size / PARAM_VALUE (PARAM_LTO_PARTITIONS);\n   if (partition_size < PARAM_VALUE (MIN_PARTITION_SIZE))\n@@ -1756,8 +1794,20 @@ lto_balanced_map (void)\n     {\n       if (order[i]->aux)\n \tcontinue;\n+\n+      current_order = order[i]->order;\n+\n+      if (!flag_toplevel_reorder)\n+\twhile (varpool_pos < n_varpool_nodes && varpool_order[varpool_pos]->order < current_order)\n+\t  {\n+\t    if (!varpool_order[varpool_pos]->aux)\n+\t      add_varpool_node_to_partition (partition, varpool_order[varpool_pos]);\n+\t    varpool_pos++;\n+\t  }\n+\n       add_cgraph_node_to_partition (partition, order[i]);\n       total_size -= inline_summary (order[i])->size;\n+\t  \n \n       /* Once we added a new node to the partition, we also want to add\n          all referenced variables unless they was already added into some\n@@ -1796,7 +1846,7 @@ lto_balanced_map (void)\n \n \t      gcc_assert (node->analyzed);\n \n-\t      /* Compute boundary cost of callgrpah edges.  */\n+\t      /* Compute boundary cost of callgraph edges.  */\n \t      for (edge = node->callees; edge; edge = edge->next_callee)\n \t\tif (edge->callee->analyzed)\n \t\t  {\n@@ -1848,7 +1898,8 @@ lto_balanced_map (void)\n \t\tvnode = ipa_ref_varpool_node (ref);\n \t\tif (!vnode->finalized)\n \t\t  continue;\n-\t\tif (!vnode->aux && partition_varpool_node_p (vnode))\n+\t\tif (!vnode->aux && flag_toplevel_reorder\n+\t\t    && partition_varpool_node_p (vnode))\n \t\t  add_varpool_node_to_partition (partition, vnode);\n \t\tvsi = varpool_node_set_find (partition->varpool_set, vnode);\n \t\tif (!vsi_end_p (vsi)\n@@ -1878,7 +1929,8 @@ lto_balanced_map (void)\n \n \t\tvnode = ipa_ref_refering_varpool_node (ref);\n \t\tgcc_assert (vnode->finalized);\n-\t\tif (!vnode->aux && partition_varpool_node_p (vnode))\n+\t\tif (!vnode->aux && flag_toplevel_reorder\n+\t\t    && partition_varpool_node_p (vnode))\n \t\t  add_varpool_node_to_partition (partition, vnode);\n \t\tvsi = varpool_node_set_find (partition->varpool_set, vnode);\n \t\tif (!vsi_end_p (vsi)\n@@ -1967,9 +2019,22 @@ lto_balanced_map (void)\n     }\n \n   /* Varables that are not reachable from the code go into last partition.  */\n-  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n-    if (partition_varpool_node_p (vnode) && !vnode->aux)\n-      add_varpool_node_to_partition (partition, vnode);\n+  if (flag_toplevel_reorder)\n+    {\n+      for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n+        if (partition_varpool_node_p (vnode) && !vnode->aux)\n+\t  add_varpool_node_to_partition (partition, vnode);\n+    }\n+  else\n+    {\n+      while (varpool_pos < n_varpool_nodes)\n+\t{\n+\t  if (!varpool_order[varpool_pos]->aux)\n+\t    add_varpool_node_to_partition (partition, varpool_order[varpool_pos]);\n+\t  varpool_pos++;\n+\t}\n+      free (varpool_order);\n+    }\n   free (order);\n }\n \n@@ -2134,7 +2199,7 @@ static lto_file *current_lto_file;\n    longest compilation being executed too late.  */\n \n static int\n-cmp_partitions (const void *a, const void *b)\n+cmp_partitions_size (const void *a, const void *b)\n {\n   const struct ltrans_partition_def *pa\n      = *(struct ltrans_partition_def *const *)a;\n@@ -2143,6 +2208,28 @@ cmp_partitions (const void *a, const void *b)\n   return pb->insns - pa->insns;\n }\n \n+/* Helper for qsort; compare partitions and return one with smaller order.  */\n+\n+static int\n+cmp_partitions_order (const void *a, const void *b)\n+{\n+  const struct ltrans_partition_def *pa\n+     = *(struct ltrans_partition_def *const *)a;\n+  const struct ltrans_partition_def *pb\n+     = *(struct ltrans_partition_def *const *)b;\n+  int ordera = -1, orderb = -1;\n+\n+  if (VEC_length (cgraph_node_ptr, pa->cgraph_set->nodes))\n+    ordera = VEC_index (cgraph_node_ptr, pa->cgraph_set->nodes, 0)->order;\n+  else if (VEC_length (varpool_node_ptr, pa->varpool_set->nodes))\n+    ordera = VEC_index (varpool_node_ptr, pa->varpool_set->nodes, 0)->order;\n+  if (VEC_length (cgraph_node_ptr, pb->cgraph_set->nodes))\n+    orderb = VEC_index (cgraph_node_ptr, pb->cgraph_set->nodes, 0)->order;\n+  else if (VEC_length (varpool_node_ptr, pb->varpool_set->nodes))\n+    orderb = VEC_index (varpool_node_ptr, pb->varpool_set->nodes, 0)->order;\n+  return orderb - ordera;\n+}\n+\n /* Write all output files in WPA mode and the file with the list of\n    LTRANS units.  */\n \n@@ -2191,7 +2278,12 @@ lto_wpa_write_files (void)\n   blen = strlen (temp_filename);\n \n   n_sets = VEC_length (ltrans_partition, ltrans_partitions);\n-  VEC_qsort (ltrans_partition, ltrans_partitions, cmp_partitions);\n+\n+  /* Sort partitions by size so small ones are compiled last.\n+     FIXME: Even when not reordering we may want to output one list for parallel make\n+     and other for final link command.  */\n+  VEC_qsort (ltrans_partition, ltrans_partitions,\n+\t    flag_toplevel_reorder ? cmp_partitions_size : cmp_partitions_order);\n   for (i = 0; i < n_sets; i++)\n     {\n       size_t len;"}]}