{"sha": "75ec21db305f832534b2072c02a2a785c3cc0b4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVlYzIxZGIzMDVmODMyNTM0YjIwNzJjMDJhMmE3ODVjM2NjMGI0Yw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-01-27T22:29:07Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-01-27T22:29:07Z"}, "message": "cppinit.c (cpp_handle_option): Recognize C++ comments under -std=gnu89.\n\n\t* cppinit.c (cpp_handle_option): Recognize C++ comments under\n\t-std=gnu89.\n\t* cpplib.c (skip_block_comment, skip_line_comment): Split code\n\tout of...\n\t(skip_comment) ... here.  Permit C++ comments in system\n\theaders always.  Warn about C++ comments in user code under\n\t-std=gnu89 -pedantic.\n\t(copy_comment): Use skip_comment.\n\t(cpp_skip_hspace, cpp_get_token): skip_comment can no longer\n\treturn EOF.\n\t(consider_directive_while_skipping, do_else, do_endif): Call\n\tvalidate_else unconditionally.\n\t(validate_else): Check CPP_PEDANTIC here.  Accept non-comment\n\ttext after the conditional in a system header.\n\t* cpplib.h (struct cpp_buffer): Add flag\n\twarned_cplusplus_comments.\n\nFrom-SVN: r31654", "tree": {"sha": "8fbdbe32865dcaea5f37fa4f80adc6849f91f96d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fbdbe32865dcaea5f37fa4f80adc6849f91f96d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75ec21db305f832534b2072c02a2a785c3cc0b4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75ec21db305f832534b2072c02a2a785c3cc0b4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75ec21db305f832534b2072c02a2a785c3cc0b4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75ec21db305f832534b2072c02a2a785c3cc0b4c/comments", "author": null, "committer": null, "parents": [{"sha": "73b5cdf98ad368b41766577395b2a5bbd91e3f1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73b5cdf98ad368b41766577395b2a5bbd91e3f1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73b5cdf98ad368b41766577395b2a5bbd91e3f1b"}], "stats": {"total": 270, "additions": 139, "deletions": 131}, "files": [{"sha": "2f5b33d54d6214fa156e98116dab88761c198db7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ec21db305f832534b2072c02a2a785c3cc0b4c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ec21db305f832534b2072c02a2a785c3cc0b4c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75ec21db305f832534b2072c02a2a785c3cc0b4c", "patch": "@@ -1,3 +1,22 @@\n+2000-01-27  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cppinit.c (cpp_handle_option): Recognize C++ comments under\n+\t-std=gnu89.\n+\t* cpplib.c (skip_block_comment, skip_line_comment): Split code\n+\tout of...\n+\t(skip_comment) ... here.  Permit C++ comments in system\n+\theaders always.  Warn about C++ comments in user code under\n+\t-std=gnu89 -pedantic.\n+\t(copy_comment): Use skip_comment.\n+\t(cpp_skip_hspace, cpp_get_token): skip_comment can no longer\n+\treturn EOF.\n+\t(consider_directive_while_skipping, do_else, do_endif): Call\n+\tvalidate_else unconditionally.\n+\t(validate_else): Check CPP_PEDANTIC here.  Accept non-comment\n+\ttext after the conditional in a system header.\n+\t* cpplib.h (struct cpp_buffer): Add flag\n+\twarned_cplusplus_comments.\n+\n 2000-01-27  Geoffrey Keating  <geoffk@cygnus.com>\n \n \t* emit-rtl.c (unshare_all_rtl): Unshare virtual parameters too."}, {"sha": "2ee6e78d9cd0c2a8a21d9100ad7135b798f3c6ef", "filename": "gcc/cppinit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ec21db305f832534b2072c02a2a785c3cc0b4c/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ec21db305f832534b2072c02a2a785c3cc0b4c/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=75ec21db305f832534b2072c02a2a785c3cc0b4c", "patch": "@@ -1345,7 +1345,7 @@ cpp_handle_option (pfile, argc, argv)\n       case 's':\n \tif (!strcmp (argv[i], \"-std=gnu89\"))\n \t  {\n-\t    opts->cplusplus = 0, opts->cplusplus_comments = 0;\n+\t    opts->cplusplus = 0, opts->cplusplus_comments = 1;\n \t    opts->c89 = 1, opts->c9x = 0, opts->objc = 0;\n \t  }\n \telse if (!strcmp (argv[i], \"-std=gnu9x\"))"}, {"sha": "44134e605cd8481eded14059e722d105ab5bc653", "filename": "gcc/cpplib.c", "status": "modified", "additions": 114, "deletions": 130, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ec21db305f832534b2072c02a2a785c3cc0b4c/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ec21db305f832534b2072c02a2a785c3cc0b4c/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=75ec21db305f832534b2072c02a2a785c3cc0b4c", "patch": "@@ -255,11 +255,70 @@ null_cleanup (pbuf, pfile)\n   return 0;\n }\n \n+/* Skip a C-style block comment.  We know it's a comment, and point is\n+   at the second character of the starter.  */\n+static void\n+skip_block_comment (pfile)\n+     cpp_reader *pfile;\n+{\n+  int c, prev_c = -1;\n+  long line, col;\n+\n+  FORWARD(1);\n+  cpp_buf_line_and_col (CPP_BUFFER (pfile), &line, &col);\n+  for (;;)\n+    {\n+      c = GETC ();\n+      if (c == EOF)\n+\t{\n+\t  cpp_error_with_line (pfile, line, col, \"unterminated comment\");\n+\t  return;\n+\t}\n+      else if (c == '\\n' || c == '\\r')\n+\t/* \\r cannot be a macro escape marker here. */\n+\tCPP_BUMP_LINE (pfile);\n+      else if (c == '/' && prev_c == '*')\n+\treturn;\n+      else if (c == '*' && prev_c == '/'\n+\t       && CPP_OPTIONS (pfile)->warn_comments)\n+\tcpp_warning (pfile, \"`/*' within comment\");\n+\n+      prev_c = c;\n+    }\n+}\n+\n+/* Skip a C++/Chill line comment.  We know it's a comment, and point\n+   is at the second character of the initiator.  */\n+static void\n+skip_line_comment (pfile)\n+     cpp_reader *pfile;\n+{\n+  FORWARD(1);\n+  for (;;)\n+    {\n+      int c = GETC ();\n+\n+      /* We don't have to worry about EOF in here.  */\n+      if (c == '\\n')\n+\t{\n+\t  /* Don't consider final '\\n' to be part of comment.  */\n+\t  FORWARD(-1);\n+\t  return;\n+\t}\n+      else if (c == '\\r')\n+\t{\n+\t  /* \\r cannot be a macro escape marker here. */\n+\t  CPP_BUMP_LINE (pfile);\n+\t  if (CPP_OPTIONS (pfile)->warn_comments)\n+\t    cpp_warning (pfile, \"backslash-newline within line comment\");\n+\t}\n+    }\n+}\n+\n /* Skip a comment - C, C++, or Chill style.  M is the first character\n    of the comment marker.  If this really is a comment, skip to its\n-   end and return ' '.  If we hit end-of-file before end-of-comment,\n-   return EOF.  If this is not a comment, return M (which will be\n-   '/' or '-').  */\n+   end and return ' '.  If this is not a comment, return M (which will\n+   be '/' or '-').  */\n \n static int\n skip_comment (pfile, m)\n@@ -268,52 +327,42 @@ skip_comment (pfile, m)\n {\n   if (m == '/' && PEEKC() == '*')\n     {\n-      int c, prev_c = -1;\n-      long line, col;\n-      \n-      FORWARD(1);\n-      cpp_buf_line_and_col (CPP_BUFFER (pfile), &line, &col);\n-      for (;;)\n+      skip_block_comment (pfile);\n+      return ' ';\n+    }\n+  else if (m == '/' && PEEKC() == '/')\n+    {\n+      if (CPP_BUFFER (pfile)->system_header_p)\n \t{\n-\t  c = GETC ();\n-\t  if (c == EOF)\n+\t  /* We silently allow C++ comments in system headers, irrespective\n+\t     of conformance mode, because lots of busted systems do that\n+\t     and trying to clean it up in fixincludes is a nightmare.  */\n+\t  skip_line_comment (pfile);\n+\t  return ' ';\n+\t}\n+      else if (CPP_OPTIONS (pfile)->cplusplus_comments)\n+\t{\n+\t  if (CPP_OPTIONS (pfile)->c89\n+\t      && CPP_PEDANTIC (pfile)\n+\t      && ! CPP_BUFFER (pfile)->warned_cplusplus_comments)\n \t    {\n-\t      cpp_error_with_line (pfile, line, col, \"unterminated comment\");\n-\t      return EOF;\n+\t      cpp_pedwarn (pfile,\n+\t\t\t   \"C++ style comments are not allowed in ISO C89\");\n+\t      cpp_pedwarn (pfile,\n+\t\t\t   \"(this will be reported only once per input file)\");\n+\t      CPP_BUFFER (pfile)->warned_cplusplus_comments = 1;\n \t    }\n-\t  else if (c == '\\n' || c == '\\r')\n-\t    /* \\r cannot be a macro escape marker here. */\n-\t    CPP_BUMP_LINE (pfile);\n-\t  else if (c == '/' && prev_c == '*')\n-\t    return ' ';\n-\t  else if (c == '*' && prev_c == '/'\n-\t\t   && CPP_OPTIONS (pfile)->warn_comments)\n-\t    cpp_warning (pfile, \"`/*' within comment\");\n-\n-\t  prev_c = c;\n+\t  skip_line_comment (pfile);\n+\t  return ' ';\n \t}\n+      else\n+\treturn m;\n     }\n-  else if ((m == '/' && PEEKC() == '/'\n-\t    && CPP_OPTIONS (pfile)->cplusplus_comments)\n-\t   || (m == '-' && PEEKC() == '-'\n-\t       && CPP_OPTIONS (pfile)->chill))\n+  else if (m == '-' && PEEKC() == '-'\n+\t   && CPP_OPTIONS (pfile)->chill)\n     {\n-      FORWARD(1);\n-      for (;;)\n-\t{\n-\t  int c = GETC ();\n-\t  if (c == EOF)\n-\t    return ' '; /* Allow // to be terminated by EOF.  */\n-\t      if (c == '\\n')\n-\t\t{\n-\t\t  /* Don't consider final '\\n' to be part of comment.  */\n-\t\t  FORWARD(-1);\n-\t\t  return ' ';\n-\t\t}\n-\t      else if (c == '\\r')\n-\t\t/* \\r cannot be a macro escape marker here. */\n-\t\tCPP_BUMP_LINE (pfile);\n-\t}\n+      skip_line_comment (pfile);\n+      return ' ';\n     }\n   else\n     return m;\n@@ -326,77 +375,18 @@ copy_comment (pfile, m)\n      cpp_reader *pfile;\n      int m;\n {\n-  if (m == '/' && PEEKC() == '*')\n-    {\n-      int c, prev_c = -1;\n-      long line, col;\n+  U_CHAR *start = CPP_BUFFER (pfile)->cur;  /* XXX Layering violation */\n+  U_CHAR *limit;\n \n-      CPP_PUTC (pfile, '/');\n-      CPP_PUTC (pfile, '*');\n-      FORWARD(1);\n-      cpp_buf_line_and_col (CPP_BUFFER (pfile), &line, &col);\n-      for (;;)\n-\t{\n-\t  c = GETC ();\n-\t  if (c == EOF)\n-\t    {\n-\t      cpp_error_with_line (pfile, line, col, \"unterminated comment\");\n-\t      /* We must pretend this was a legitimate comment, so that the\n-\t\t output in token_buffer is not passed back tagged CPP_POP. */\n-\t      return ' ';\n-\t    }\n-\t  else if (c == '\\r')\n-\t    {\n-\t      /* \\r cannot be a macro escape marker here. */\n-\t      CPP_BUMP_LINE (pfile);\n-\t      continue;\n-\t    }\n-\n-\t  CPP_PUTC (pfile, c);\n-\t  if (c == '\\n')\n-\t    {\n-\t      pfile->lineno++;\n-\t      CPP_BUMP_LINE (pfile);\n-\t    }\n-\t  else if (c == '/' && prev_c == '*')\n-\t    return ' ';\n-\t  else if (c == '*' && prev_c == '/'\n-\t\t   && CPP_OPTIONS (pfile)->warn_comments)\n-\t    cpp_warning (pfile, \"`/*' within comment\");\n-\n-\t  prev_c = c;\n-\t}\n-    }\n-  else if ((m == '/' && PEEKC() == '/'\n-\t    && CPP_OPTIONS (pfile)->cplusplus_comments)\n-\t   || (m == '-' && PEEKC() == '-'\n-\t       && CPP_OPTIONS (pfile)->chill))\n-    {\n-      CPP_PUTC (pfile, m);\n-      CPP_PUTC (pfile, m);\n-      FORWARD(1);\n-      for (;;)\n-\t{\n-\t  int c = GETC ();\n-\t  if (c == EOF)\n-\t    return ' '; /* Allow line comments to be terminated by EOF. */\n-\t  else if (c == '\\n')\n-\t    {\n-\t      /* Don't consider final '\\n' to be part of comment.  */\n-\t      FORWARD(-1);\n-\t      return ' ';\n-\t    }\n-\t  else if (c == '\\r')\n-\t    /* \\r cannot be a macro escape marker here. */\n-\t    CPP_BUMP_LINE (pfile);\n-\n-\t  CPP_PUTC (pfile, c);\n-\t}\n-    }\n-  else\n+  if (skip_comment (pfile, m) == m)\n     return m;\n-}\n \n+  CPP_PUTC (pfile, m);\n+  for (limit = CPP_BUFFER (pfile)->cur; start <= limit; start++)\n+    if (*start != '\\r')\n+      CPP_PUTC (pfile, *start);\n+  return ' ';\n+}\n \n /* Skip whitespace \\-newline and comments.  Does not macro-expand.  */\n \n@@ -433,9 +423,7 @@ cpp_skip_hspace (pfile)\n       else if (c == '/' || c == '-')\n \t{\n \t  c = skip_comment (pfile, c);\n-\t  if (c == EOF)\n-\t    return;\n-\t  else if (c != ' ')\n+\t  if (c  != ' ')\n \t    break;\n \t}\n       else\n@@ -2008,7 +1996,7 @@ consider_directive_while_skipping (pfile, stack)\n \t    return 0;\n \n \tcase T_ELSE:\n-\t    if (CPP_PEDANTIC (pfile) && pfile->if_stack != stack)\n+\t    if (pfile->if_stack != stack)\n \t      validate_else (pfile, \"#else\");\n \t    /* fall through */\n \tcase T_ELIF:\n@@ -2024,7 +2012,7 @@ consider_directive_while_skipping (pfile, stack)\n \t      }\n \n \t    case T_ENDIF:\n-\t\tif (CPP_PEDANTIC (pfile) && pfile->if_stack != stack)\n+\t\tif (pfile->if_stack != stack)\n \t\t  validate_else (pfile, \"#endif\");\n \n \t\tif (pfile->if_stack == stack)\n@@ -2140,8 +2128,7 @@ do_else (pfile, keyword)\n {\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n \n-  if (CPP_PEDANTIC (pfile))\n-    validate_else (pfile, \"#else\");\n+  validate_else (pfile, \"#else\");\n   skip_rest_of_line (pfile);\n \n   if (pfile->if_stack == CPP_BUFFER (pfile)->if_stack) {\n@@ -2180,8 +2167,7 @@ do_endif (pfile, keyword)\n      cpp_reader *pfile;\n      const struct directive *keyword ATTRIBUTE_UNUSED;\n {\n-  if (CPP_PEDANTIC (pfile))\n-    validate_else (pfile, \"#endif\");\n+  validate_else (pfile, \"#endif\");\n   skip_rest_of_line (pfile);\n \n   if (pfile->if_stack == CPP_BUFFER (pfile)->if_stack)\n@@ -2226,19 +2212,20 @@ do_endif (pfile, keyword)\n   return 0;\n }\n \n-/* When an #else or #endif is found while skipping failed conditional,\n-   if -pedantic was specified, this is called to warn about text after\n-   the command name.  P points to the first char after the command name.  */\n+/* Issue -pedantic warning for text which is not a comment following\n+   an #else or #endif.  Do not warn in system headers, as this is harmless\n+   and very common on old systems.  */\n \n static void\n validate_else (pfile, directive)\n      cpp_reader *pfile;\n      const char *directive;\n {\n-  int c;\n+  if (! CPP_PEDANTIC (pfile) || CPP_BUFFER (pfile)->system_header_p)\n+    return;\n+\n   cpp_skip_hspace (pfile);\n-  c = PEEKC ();\n-  if (c != EOF && c != '\\n')\n+  if (PEEKC () != '\\n')\n     cpp_pedwarn (pfile,\n \t\t \"text following `%s' violates ANSI standard\", directive);\n }\n@@ -2277,7 +2264,6 @@ cpp_get_token (pfile)\n   c = GETC();\n   if (c == EOF)\n     {\n-    handle_eof:\n       if (CPP_BUFFER (pfile)->manual_pop)\n \t/* If we've been reading from redirected input, the\n \t   frontend will pop the buffer.  */\n@@ -2339,9 +2325,7 @@ cpp_get_token (pfile)\n \t    c = copy_comment (pfile, c);\n \t  else\n \t    c = skip_comment (pfile, c);\n-\t  if (c == EOF)\n-\t    goto handle_eof;\n-\t  else if (c != ' ')\n+\t  if (c != ' ')\n \t    goto randomchar;\n \t  \n \t  /* Comments are equivalent to spaces."}, {"sha": "29514a13ec8e617755e193a20fe4c49a9319c909", "filename": "gcc/cpplib.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75ec21db305f832534b2072c02a2a785c3cc0b4c/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75ec21db305f832534b2072c02a2a785c3cc0b4c/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=75ec21db305f832534b2072c02a2a785c3cc0b4c", "patch": "@@ -140,6 +140,11 @@ struct cpp_buffer\n   /* Used by the C++ frontend to implement redirected input (such as for\n      default argument and/or template parsing).  */\n   char manual_pop;\n+\n+  /* True if we have already warned about C++ comments in this file.\n+     The warning happens only for C89 extended mode with -pedantic on,\n+     and only once per file (otherwise it would be far too noisy).  */\n+  char warned_cplusplus_comments;\n };\n \n struct file_name_map_list;"}]}