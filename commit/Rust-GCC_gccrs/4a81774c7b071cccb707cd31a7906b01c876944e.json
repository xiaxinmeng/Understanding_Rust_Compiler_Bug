{"sha": "4a81774c7b071cccb707cd31a7906b01c876944e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE4MTc3NGM3YjA3MWNjY2I3MDdjZDMxYTc5MDZiMDFjODc2OTQ0ZQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2009-04-26T12:28:53Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2009-04-26T12:28:53Z"}, "message": "df-scan.c (df_insn_rescan): Salvage insn's LUID if the insn is not new but only being rescanned.\n\n\t* df-scan.c (df_insn_rescan): Salvage insn's LUID if the insn is\n\tnot new but only being rescanned.\n\t* gcse.c (uid_cuid, max_uid, INSN_CUID, max_cuid, struct reg_set,\n\treg_set_table, REG_SET_TABLE_SLOP, reg_set_in_block,\n\talloc_reg_set_mem, free_reg_set_mem, record_one_set,\n\trecord_set_info, compute_set, grealloc): Remove.\n\t(recompute_all_luids): New function.\n\t(gcse_main): Don't compute sets, and don't do related memory\n\tallocations/free-ing.  If something changed before the end of the\n\tpass, update LUIDs using recompute_all_luids.\n\t(alloc_gcse_mem): Don't compute LUIDs.  Don't allocate reg_set memory.\n\t(free_gcse_mem): Don't free it either.\n\t(oprs_unchanged_p, load_killed_in_block, record_last_reg_set_info):\n\tUse the df insn LUIDs.\n\t(load_killed_in_block): Likewise.\n\t(compute_hash_table_work): Don't compute reg_set_in_block.\n\t(compute_transp): Use DF_REG_DEF_CHAINs.\n\t(local_cprop_pass): Don't use compute_sets and related functions.\n\t(one_cprop_pass, pre_gcse, one_pre_gcse_pass, one_code_hoisting_pass):\n\tUse get_max_uid() instead of max_cuid.\n\t(insert_insn_end_basic_block, pre_insert_copy_insn,\n\tupdate_ld_motion_stores): Don't try to\n\tkeep reg_set tables up to date.\n\t(pre_insert_copies): Use df insn LUIDs.\n\t(sbitmap pre_redundant_insns): Replace with uses of INSN_DELETED_P.\n\t(reg_set_info): Don't use extra bitmap argument.\n\t(compute_store_table): Don't compute reg_set_in_block.  Use DF scan\n\tinformation to compute regs_set_in_block.\n\t(free_store_memory, store_motion): Don't nullify reg_set_in_block.\n\t(bypass_jumps): Don't use compute_sets and friends.\n\nFrom-SVN: r146799", "tree": {"sha": "ba68c087a6658019b7bd358d32f6fa131ac208c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba68c087a6658019b7bd358d32f6fa131ac208c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a81774c7b071cccb707cd31a7906b01c876944e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a81774c7b071cccb707cd31a7906b01c876944e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a81774c7b071cccb707cd31a7906b01c876944e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a81774c7b071cccb707cd31a7906b01c876944e/comments", "author": null, "committer": null, "parents": [{"sha": "cca36d72b941a1d02cfbcf0eebe5113c906222f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cca36d72b941a1d02cfbcf0eebe5113c906222f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cca36d72b941a1d02cfbcf0eebe5113c906222f5"}], "stats": {"total": 448, "additions": 105, "deletions": 343}, "files": [{"sha": "b5887e8d48b2742e318caeefb04b2ccb1e47e3e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a81774c7b071cccb707cd31a7906b01c876944e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a81774c7b071cccb707cd31a7906b01c876944e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a81774c7b071cccb707cd31a7906b01c876944e", "patch": "@@ -1,3 +1,36 @@\n+2009-04-26  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* df-scan.c (df_insn_rescan): Salvage insn's LUID if the insn is\n+\tnot new but only being rescanned.\n+\t* gcse.c (uid_cuid, max_uid, INSN_CUID, max_cuid, struct reg_set,\n+\treg_set_table, REG_SET_TABLE_SLOP, reg_set_in_block,\n+\talloc_reg_set_mem, free_reg_set_mem, record_one_set,\n+\trecord_set_info, compute_set, grealloc): Remove.\n+\t(recompute_all_luids): New function.\n+\t(gcse_main): Don't compute sets, and don't do related memory\n+\tallocations/free-ing.  If something changed before the end of the\n+\tpass, update LUIDs using recompute_all_luids.\n+\t(alloc_gcse_mem): Don't compute LUIDs.  Don't allocate reg_set memory.\n+\t(free_gcse_mem): Don't free it either.\n+\t(oprs_unchanged_p, load_killed_in_block, record_last_reg_set_info):\n+\tUse the df insn LUIDs.\n+\t(load_killed_in_block): Likewise.\n+\t(compute_hash_table_work): Don't compute reg_set_in_block.\n+\t(compute_transp): Use DF_REG_DEF_CHAINs.\n+\t(local_cprop_pass): Don't use compute_sets and related functions.\n+\t(one_cprop_pass, pre_gcse, one_pre_gcse_pass, one_code_hoisting_pass):\n+\tUse get_max_uid() instead of max_cuid.\n+\t(insert_insn_end_basic_block, pre_insert_copy_insn,\n+\tupdate_ld_motion_stores): Don't try to\n+\tkeep reg_set tables up to date.\n+\t(pre_insert_copies): Use df insn LUIDs.\n+\t(sbitmap pre_redundant_insns): Replace with uses of INSN_DELETED_P.\n+\t(reg_set_info): Don't use extra bitmap argument.\n+\t(compute_store_table): Don't compute reg_set_in_block.  Use DF scan\n+\tinformation to compute regs_set_in_block.\n+\t(free_store_memory, store_motion): Don't nullify reg_set_in_block.\n+\t(bypass_jumps): Don't use compute_sets and friends.\n+\n 2009-04-26  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \tPR testsuite/39710"}, {"sha": "7ffaa668c516f622c901c6d278c6a44cec64f34a", "filename": "gcc/df-scan.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a81774c7b071cccb707cd31a7906b01c876944e/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a81774c7b071cccb707cd31a7906b01c876944e/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=4a81774c7b071cccb707cd31a7906b01c876944e", "patch": "@@ -1258,6 +1258,7 @@ df_insn_rescan (rtx insn)\n   bitmap_clear_bit (df->insns_to_notes_rescan, uid);\n   if (insn_info)\n     {\n+      int luid;\n       bool the_same = df_insn_refs_verify (&collection_rec, bb, insn, false);\n       /* If there's no change, return false. */\n       if (the_same)\n@@ -1270,9 +1271,12 @@ df_insn_rescan (rtx insn)\n       if (dump_file)\n \tfprintf (dump_file, \"rescanning insn with uid = %d.\\n\", uid);\n \n-      /* There's change - we need to delete the existing info. */\n+      /* There's change - we need to delete the existing info.\n+\t Since the insn isn't moved, we can salvage its LUID.  */\n+      luid = DF_INSN_LUID (insn);\n       df_insn_delete (NULL, uid);\n       df_insn_create_insn_record (insn);\n+      DF_INSN_LUID (insn) = luid;\n     }\n   else\n     {"}, {"sha": "6bf1d502bbea0e9b530fdb1d510d50b86936e632", "filename": "gcc/gcse.c", "status": "modified", "additions": 67, "deletions": 342, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a81774c7b071cccb707cd31a7906b01c876944e/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a81774c7b071cccb707cd31a7906b01c876944e/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=4a81774c7b071cccb707cd31a7906b01c876944e", "patch": "@@ -27,9 +27,6 @@ along with GCC; see the file COPYING3.  If not see\n    - a store to the same address as a load does not kill the load if the\n      source of the store is also the destination of the load.  Handling this\n      allows more load motion, particularly out of loops.\n-   - ability to realloc sbitmap vectors would allow one initial computation\n-     of reg_set_in_block with only subsequent additions, rather than\n-     recomputing it for each pass\n \n */\n \n@@ -373,70 +370,11 @@ static struct hash_table expr_hash_table;\n /* Copy propagation hash table.  */\n static struct hash_table set_hash_table;\n \n-/* Mapping of uids to cuids.\n-   Only real insns get cuids.  */\n-static int *uid_cuid;\n-\n-/* Highest UID in UID_CUID.  */\n-static int max_uid;\n-\n-/* Get the cuid of an insn.  */\n-#ifdef ENABLE_CHECKING\n-#define INSN_CUID(INSN) \\\n-  (gcc_assert (INSN_UID (INSN) <= max_uid), uid_cuid[INSN_UID (INSN)])\n-#else\n-#define INSN_CUID(INSN) (uid_cuid[INSN_UID (INSN)])\n-#endif\n-\n-/* Number of cuids.  */\n-static int max_cuid;\n-\n /* Maximum register number in function prior to doing gcse + 1.\n    Registers created during this pass have regno >= max_gcse_regno.\n    This is named with \"gcse\" to not collide with global of same name.  */\n static unsigned int max_gcse_regno;\n \n-/* Table of registers that are modified.\n-\n-   For each register, each element is a list of places where the pseudo-reg\n-   is set.\n-\n-   For simplicity, GCSE is done on sets of pseudo-regs only.  PRE GCSE only\n-   requires knowledge of which blocks kill which regs [and thus could use\n-   a bitmap instead of the lists `reg_set_table' uses].\n-\n-   `reg_set_table' and could be turned into an array of bitmaps (num-bbs x\n-   num-regs) [however perhaps it may be useful to keep the data as is].  One\n-   advantage of recording things this way is that `reg_set_table' is fairly\n-   sparse with respect to pseudo regs but for hard regs could be fairly dense\n-   [relatively speaking].  And recording sets of pseudo-regs in lists speeds\n-   up functions like compute_transp since in the case of pseudo-regs we only\n-   need to iterate over the number of times a pseudo-reg is set, not over the\n-   number of basic blocks [clearly there is a bit of a slow down in the cases\n-   where a pseudo is set more than once in a block, however it is believed\n-   that the net effect is to speed things up].  This isn't done for hard-regs\n-   because recording call-clobbered hard-regs in `reg_set_table' at each\n-   function call can consume a fair bit of memory, and iterating over\n-   hard-regs stored this way in compute_transp will be more expensive.  */\n-\n-typedef struct reg_set\n-{\n-  /* The next setting of this register.  */\n-  struct reg_set *next;\n-  /* The index of the block where it was set.  */\n-  int bb_index;\n-} reg_set;\n-\n-static reg_set **reg_set_table;\n-\n-/* Size of `reg_set_table'.\n-   The table starts out at max_gcse_regno + slop, and is enlarged as\n-   necessary.  */\n-static int reg_set_table_size;\n-\n-/* Amount to grow `reg_set_table' by when it's full.  */\n-#define REG_SET_TABLE_SLOP 100\n-\n /* This is a list of expressions which are MEMs and will be used by load\n    or store motion.\n    Load motion tracks MEMs which aren't killed by\n@@ -476,13 +414,6 @@ static htab_t pre_ldst_table = NULL;\n    the start of the basic block.  */\n static regset reg_set_bitmap;\n \n-/* For each block, a bitmap of registers set in the block.\n-   This is used by compute_transp.\n-   It is computed during hash table computation and not by compute_sets\n-   as it includes registers added since the last pass (or between cprop and\n-   gcse) and it's currently not easy to realloc sbitmap vectors.  */\n-static sbitmap *reg_set_in_block;\n-\n /* Array, indexed by basic block number for a list of insns which modify\n    memory within that block.  */\n static rtx * modify_mem_list;\n@@ -519,17 +450,12 @@ static int global_copy_prop_count;\n static sbitmap *ae_kill, *ae_gen;\n \f\n static void compute_can_copy (void);\n+static void recompute_all_luids (void);\n static void *gmalloc (size_t) ATTRIBUTE_MALLOC;\n static void *gcalloc (size_t, size_t) ATTRIBUTE_MALLOC;\n-static void *grealloc (void *, size_t);\n static void *gcse_alloc (unsigned long);\n static void alloc_gcse_mem (void);\n static void free_gcse_mem (void);\n-static void alloc_reg_set_mem (int);\n-static void free_reg_set_mem (void);\n-static void record_one_set (int, rtx);\n-static void record_set_info (rtx, const_rtx, void *);\n-static void compute_sets (void);\n static void hash_scan_insn (rtx, struct hash_table *);\n static void hash_scan_set (rtx, rtx, struct hash_table *);\n static void hash_scan_clobber (rtx, rtx, struct hash_table *);\n@@ -655,11 +581,9 @@ static bool is_too_expensive (const char *);\n \n #define GNEWVEC(T, N)\t\t((T *) gmalloc (sizeof (T) * (N)))\n #define GCNEWVEC(T, N)\t\t((T *) gcalloc ((N), sizeof (T)))\n-#define GRESIZEVEC(T, P, N)\t((T *) grealloc ((void *) (P), sizeof (T) * (N)))\n \n #define GNEWVAR(T, S)\t\t((T *) gmalloc ((S)))\n #define GCNEWVAR(T, S)\t\t((T *) gcalloc (1, (S)))\n-#define GRESIZEVAR(T, P, S)\t((T *) grealloc ((P), (S)))\n \n #define GOBNEW(T)\t\t((T *) gcse_alloc (sizeof (T)))\n #define GOBNEWVAR(T, S)\t\t((T *) gcse_alloc ((S)))\n@@ -705,21 +629,6 @@ gcse_main (rtx f ATTRIBUTE_UNUSED)\n   /* We need alias.  */\n   init_alias_analysis ();\n \n-  /* Record where pseudo-registers are set.  This data is kept accurate\n-     during each pass.  ??? We could also record hard-reg information here\n-     [since it's unchanging], however it is currently done during hash table\n-     computation.\n-\n-     It may be tempting to compute MEM set information here too, but MEM sets\n-     will be subject to code motion one day and thus we need to compute\n-     information about memory sets when we build the hash tables.\n-     \n-     ??? Actually, we already know the information that compute_sets computes\n-     because it is available from DF.  FIXME.  */\n-\n-  alloc_reg_set_mem (max_gcse_regno);\n-  compute_sets ();\n-\n   gcse_obstack_bottom = GOBNEWVAR (char, 1);\n   changed = 0;\n  \n@@ -736,6 +645,8 @@ gcse_main (rtx f ATTRIBUTE_UNUSED)\n     {\n       timevar_push (TV_CPROP1);\n       changed = one_cprop_pass (1, false, false);\n+      if (changed)\n+        recompute_all_luids ();\n       timevar_pop (TV_CPROP1);\n     }\n \n@@ -757,12 +668,7 @@ gcse_main (rtx f ATTRIBUTE_UNUSED)\n \t  canon_modify_mem_list = GCNEWVEC (rtx, last_basic_block);\n \t}\n \n-      /* ??? When we allocate this at the start of the function,\n-\t the comment says that \"this data is kept accurate during\n-\t each pass\".  Apparently this is not so?  FIXME.  */\n-      free_reg_set_mem ();\n-      alloc_reg_set_mem (max_reg_num ());\n-      compute_sets ();\n+      df_analyze ();\n       run_jump_opt_after_gcse = 1;\n       timevar_pop (TV_PRE);\n     }\n@@ -799,7 +705,9 @@ gcse_main (rtx f ATTRIBUTE_UNUSED)\n \n       /* This time, go ahead and allow cprop to alter jumps.  */\n       timevar_push (TV_CPROP2);\n-      one_cprop_pass (2, true, true);\n+      changed = one_cprop_pass (2, true, true);\n+      if (changed)\n+        recompute_all_luids ();\n       timevar_pop (TV_CPROP2);\n       free_gcse_mem ();\n     }\n@@ -812,7 +720,6 @@ gcse_main (rtx f ATTRIBUTE_UNUSED)\n     }\n \n   obstack_free (&gcse_obstack, NULL);\n-  free_reg_set_mem ();\n \n   /* We are finished with alias.\n      ??? Actually we recompute alias in store_motion.  */\n@@ -882,6 +789,20 @@ can_copy_p (enum machine_mode mode)\n \n   return can_copy[mode] != 0;\n }\n+\n+/* Recompute the DF LUIDs for all basic blocks.  If a sub-pass in this\n+   file changes something, we have to recompute them for the next pass.\n+   FIXME: If we would track which basic blocks we touch, we could\n+\t  update LUIDs in only those basic blocks.  */\n+\n+static void\n+recompute_all_luids (void)\n+{\n+  basic_block bb;\n+  FOR_EACH_BB (bb)\n+    df_recompute_luids (bb);\n+}\n+\n \f\n /* Cover function to xmalloc to record bytes allocated.  */\n \n@@ -901,16 +822,6 @@ gcalloc (size_t nelem, size_t elsize)\n   return xcalloc (nelem, elsize);\n }\n \n-/* Cover function to xrealloc.\n-   We don't record the additional size since we don't know it.\n-   It won't affect memory usage stats much anyway.  */\n-\n-static void *\n-grealloc (void *ptr, size_t size)\n-{\n-  return xrealloc (ptr, size);\n-}\n-\n /* Cover function to obstack_alloc.  */\n \n static void *\n@@ -920,43 +831,15 @@ gcse_alloc (unsigned long size)\n   return obstack_alloc (&gcse_obstack, size);\n }\n \n-/* Allocate memory for the cuid mapping array,\n-   and reg/memory set tracking tables.\n-\n+/* Allocate memory for the reg/memory set tracking tables.\n    This is called at the start of each pass.  */\n \n static void\n alloc_gcse_mem (void)\n {\n-  int i;\n-  basic_block bb;\n-  rtx insn;\n-\n-  /* Find the largest UID and create a mapping from UIDs to CUIDs.\n-     CUIDs are like UIDs except they increase monotonically, have no gaps,\n-     and only apply to real insns.\n-     (Actually, there are gaps, for insn that are not inside a basic block.\n-     but we should never see those anyway, so this is OK.)  */\n-\n-  max_uid = get_max_uid ();\n-  uid_cuid = GCNEWVEC (int, max_uid + 1);\n-  i = 0;\n-  FOR_EACH_BB (bb)\n-    FOR_BB_INSNS (bb, insn)\n-      {\n-\tif (INSN_P (insn))\n-\t  uid_cuid[INSN_UID (insn)] = i++;\n-\telse\n-\t  uid_cuid[INSN_UID (insn)] = i;\n-      }\n-\n-  max_cuid = i;\n-\n   /* Allocate vars to track sets of regs.  */\n   reg_set_bitmap = BITMAP_ALLOC (NULL);\n \n-  /* Allocate vars to track sets of regs, memory per block.  */\n-  reg_set_in_block = sbitmap_vector_alloc (last_basic_block, max_gcse_regno);\n   /* Allocate array to keep a list of insns which modify memory in each\n      basic block.  */\n   modify_mem_list = GCNEWVEC (rtx, last_basic_block);\n@@ -970,11 +853,6 @@ alloc_gcse_mem (void)\n static void\n free_gcse_mem (void)\n {\n-  free (uid_cuid);\n-\n-  BITMAP_FREE (reg_set_bitmap);\n-\n-  sbitmap_vector_free (reg_set_in_block);\n   free_modify_mem_tables ();\n   BITMAP_FREE (modify_mem_list_set);\n   BITMAP_FREE (blocks_with_calls);\n@@ -1073,85 +951,6 @@ compute_local_properties (sbitmap *transp, sbitmap *comp, sbitmap *antloc,\n     }\n }\n \f\n-/* Register set information.\n-\n-   `reg_set_table' records where each register is set or otherwise\n-   modified.  */\n-\n-static struct obstack reg_set_obstack;\n-\n-static void\n-alloc_reg_set_mem (int n_regs)\n-{\n-  reg_set_table_size = n_regs + REG_SET_TABLE_SLOP;\n-  reg_set_table = GCNEWVEC (struct reg_set *, reg_set_table_size);\n-\n-  gcc_obstack_init (&reg_set_obstack);\n-}\n-\n-static void\n-free_reg_set_mem (void)\n-{\n-  free (reg_set_table);\n-  obstack_free (&reg_set_obstack, NULL);\n-}\n-\n-/* Record REGNO in the reg_set table.  */\n-\n-static void\n-record_one_set (int regno, rtx insn)\n-{\n-  /* Allocate a new reg_set element and link it onto the list.  */\n-  struct reg_set *new_reg_info;\n-\n-  /* If the table isn't big enough, enlarge it.  */\n-  if (regno >= reg_set_table_size)\n-    {\n-      int new_size = regno + REG_SET_TABLE_SLOP;\n-\n-      reg_set_table = GRESIZEVEC (struct reg_set *, reg_set_table, new_size);\n-      memset (reg_set_table + reg_set_table_size, 0,\n-\t      (new_size - reg_set_table_size) * sizeof (struct reg_set *));\n-      reg_set_table_size = new_size;\n-    }\n-\n-  new_reg_info = XOBNEW (&reg_set_obstack, struct reg_set);\n-  bytes_used += sizeof (struct reg_set);\n-  new_reg_info->bb_index = BLOCK_NUM (insn);\n-  new_reg_info->next = reg_set_table[regno];\n-  reg_set_table[regno] = new_reg_info;\n-}\n-\n-/* Called from compute_sets via note_stores to handle one SET or CLOBBER in\n-   an insn.  The DATA is really the instruction in which the SET is\n-   occurring.  */\n-\n-static void\n-record_set_info (rtx dest, const_rtx setter ATTRIBUTE_UNUSED, void *data)\n-{\n-  rtx record_set_insn = (rtx) data;\n-\n-  if (REG_P (dest) && REGNO (dest) >= FIRST_PSEUDO_REGISTER)\n-    record_one_set (REGNO (dest), record_set_insn);\n-}\n-\n-/* Scan the function and record each set of each pseudo-register.\n-\n-   This is called once, at the start of the gcse pass.  See the comments for\n-   `reg_set_table' for further documentation.  */\n-\n-static void\n-compute_sets (void)\n-{\n-  basic_block bb;\n-  rtx insn;\n-\n-  FOR_EACH_BB (bb)\n-    FOR_BB_INSNS (bb, insn)\n-      if (INSN_P (insn))\n-\tnote_stores (PATTERN (insn), record_set_info, insn);\n-}\n-\f\n /* Hash table support.  */\n \n struct reg_avail_info\n@@ -1257,13 +1056,13 @@ oprs_unchanged_p (const_rtx x, const_rtx insn, int avail_p)\n \tif (info->last_bb != current_bb)\n \t  return 1;\n \tif (avail_p)\n-\t  return info->last_set < INSN_CUID (insn);\n+\t  return info->last_set < DF_INSN_LUID (insn);\n \telse\n-\t  return info->first_set >= INSN_CUID (insn);\n+\t  return info->first_set >= DF_INSN_LUID (insn);\n       }\n \n     case MEM:\n-      if (load_killed_in_block_p (current_bb, INSN_CUID (insn),\n+      if (load_killed_in_block_p (current_bb, DF_INSN_LUID (insn),\n \t\t\t\t  x, avail_p))\n \treturn 0;\n       else\n@@ -1362,7 +1161,7 @@ mems_conflict_for_gcse_p (rtx dest, const_rtx setter ATTRIBUTE_UNUSED,\n }\n \n /* Return nonzero if the expression in X (a memory reference) is killed\n-   in block BB before or after the insn with the CUID in UID_LIMIT.\n+   in block BB before or after the insn with the LUID in UID_LIMIT.\n    AVAIL_P is nonzero for kills after UID_LIMIT, and zero for kills\n    before UID_LIMIT.\n \n@@ -1383,9 +1182,9 @@ load_killed_in_block_p (const_basic_block bb, int uid_limit, const_rtx x, int av\n       rtx setter;\n       /* Ignore entries in the list that do not apply.  */\n       if ((avail_p\n-\t   && INSN_CUID (XEXP (list_entry, 0)) < uid_limit)\n+\t   && DF_INSN_LUID (XEXP (list_entry, 0)) < uid_limit)\n \t  || (! avail_p\n-\t      && INSN_CUID (XEXP (list_entry, 0)) > uid_limit))\n+\t      && DF_INSN_LUID (XEXP (list_entry, 0)) > uid_limit))\n \t{\n \t  list_entry = XEXP (list_entry, 1);\n \t  continue;\n@@ -1923,23 +1722,19 @@ dump_hash_table (FILE *file, const char *name, struct hash_table *table)\n    is set and is used to compute \"availability\".\n \n    last_bb records the block for which first_set and last_set are\n-   valid, as a quick test to invalidate them.\n-\n-   reg_set_in_block records whether the register is set in the block\n-   and is used to compute \"transparency\".  */\n+   valid, as a quick test to invalidate them.  */\n \n static void\n record_last_reg_set_info (rtx insn, int regno)\n {\n   struct reg_avail_info *info = &reg_avail_info[regno];\n-  int cuid = INSN_CUID (insn);\n+  int luid = DF_INSN_LUID (insn);\n \n-  info->last_set = cuid;\n+  info->last_set = luid;\n   if (info->last_bb != current_bb)\n     {\n       info->last_bb = current_bb;\n-      info->first_set = cuid;\n-      SET_BIT (reg_set_in_block[current_bb->index], regno);\n+      info->first_set = luid;\n     }\n }\n \n@@ -2046,12 +1841,6 @@ compute_hash_table_work (struct hash_table *table)\n {\n   unsigned int i;\n \n-  /* While we compute the hash table we also compute a bit array of which\n-     registers are set in which blocks.\n-     ??? This isn't needed during const/copy propagation, but it's cheap to\n-     compute.  Later.  */\n-  sbitmap_vector_zero (reg_set_in_block, last_basic_block);\n-\n   /* re-Cache any INSN_LIST nodes we have allocated.  */\n   clear_modify_mem_tables ();\n   /* Some working arrays used to track first and last set in each block.  */\n@@ -2066,10 +1855,7 @@ compute_hash_table_work (struct hash_table *table)\n       unsigned int regno;\n \n       /* First pass over the instructions records information used to\n-\t determine when registers and memory are first and last set.\n-\t ??? hard-reg reg_set_in_block computation\n-\t could be moved to compute_sets since they currently don't change.  */\n-\n+\t determine when registers and memory are first and last set.  */\n       FOR_BB_INSNS (current_bb, insn)\n \t{\n \t  if (! INSN_P (insn))\n@@ -2274,7 +2060,7 @@ oprs_not_set_p (const_rtx x, const_rtx insn)\n \n     case MEM:\n       if (load_killed_in_block_p (BLOCK_FOR_INSN (insn),\n-\t\t\t\t  INSN_CUID (insn), x, 0))\n+\t\t\t\t  DF_INSN_LUID (insn), x, 0))\n \treturn 0;\n       else\n \treturn oprs_not_set_p (XEXP (x, 0), insn);\n@@ -2429,9 +2215,7 @@ static void\n compute_transp (const_rtx x, int indx, sbitmap *bmap, int set_p)\n {\n   int i, j;\n-  basic_block bb;\n   enum rtx_code code;\n-  reg_set *r;\n   const char *fmt;\n \n   /* repeat is used to turn tail-recursion into iteration since GCC\n@@ -2447,31 +2231,19 @@ compute_transp (const_rtx x, int indx, sbitmap *bmap, int set_p)\n     case REG:\n       if (set_p)\n \t{\n-\t  if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n-\t    {\n-\t      FOR_EACH_BB (bb)\n-\t\tif (TEST_BIT (reg_set_in_block[bb->index], REGNO (x)))\n-\t\t  SET_BIT (bmap[bb->index], indx);\n-\t    }\n-\t  else\n-\t    {\n-\t      for (r = reg_set_table[REGNO (x)]; r != NULL; r = r->next)\n-\t\tSET_BIT (bmap[r->bb_index], indx);\n-\t    }\n+\t  df_ref def;\n+\t  for (def = DF_REG_DEF_CHAIN (REGNO (x));\n+\t       def;\n+\t       def = DF_REF_NEXT_REG (def))\n+\t    SET_BIT (bmap[DF_REF_BB (def)->index], indx);\n \t}\n       else\n \t{\n-\t  if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n-\t    {\n-\t      FOR_EACH_BB (bb)\n-\t\tif (TEST_BIT (reg_set_in_block[bb->index], REGNO (x)))\n-\t\t  RESET_BIT (bmap[bb->index], indx);\n-\t    }\n-\t  else\n-\t    {\n-\t      for (r = reg_set_table[REGNO (x)]; r != NULL; r = r->next)\n-\t\tRESET_BIT (bmap[r->bb_index], indx);\n-\t    }\n+\t  df_ref def;\n+\t  for (def = DF_REG_DEF_CHAIN (REGNO (x));\n+\t       def;\n+\t       def = DF_REF_NEXT_REG (def))\n+\t    RESET_BIT (bmap[DF_REF_BB (def)->index], indx);\n \t}\n \n       return;\n@@ -3188,12 +2960,7 @@ local_cprop_pass (bool alter_jumps)\n \n   /* Global analysis may get into infinite loops for unreachable blocks.  */\n   if (changed && alter_jumps)\n-    {\n-      delete_unreachable_blocks ();\n-      free_reg_set_mem ();\n-      alloc_reg_set_mem (max_reg_num ());\n-      compute_sets ();\n-    }\n+    delete_unreachable_blocks ();\n }\n \n /* Forward propagate copies.  This includes copies and constants.  Return\n@@ -3359,7 +3126,7 @@ one_cprop_pass (int pass, bool cprop_jumps, bool bypass_jumps)\n   implicit_sets = XCNEWVEC (rtx, last_basic_block);\n   find_implicit_sets ();\n \n-  alloc_hash_table (max_cuid, &set_hash_table, 1);\n+  alloc_hash_table (get_max_uid (), &set_hash_table, 1);\n   compute_hash_table (&set_hash_table);\n \n   /* Free implicit_sets before peak usage.  */\n@@ -3720,9 +3487,6 @@ static sbitmap *pre_delete_map;\n /* Contains the edge_list returned by pre_edge_lcm.  */\n static struct edge_list *edge_list;\n \n-/* Redundant insns.  */\n-static sbitmap pre_redundant_insns;\n-\n /* Allocate vars used for PRE analysis.  */\n \n static void\n@@ -4045,10 +3809,7 @@ insert_insn_end_basic_block (struct expr *expr, basic_block bb, int pre)\n   while (1)\n     {\n       if (INSN_P (pat))\n-\t{\n-\t  add_label_notes (PATTERN (pat), new_insn);\n-\t  note_stores (PATTERN (pat), record_set_info, pat);\n-\t}\n+\tadd_label_notes (PATTERN (pat), new_insn);\n       if (pat == pat_end)\n \tbreak;\n       pat = NEXT_INSN (pat);\n@@ -4221,17 +3982,11 @@ pre_insert_copy_insn (struct expr *expr, rtx insn)\n         {\n           new_insn = gen_move_insn (old_reg, reg);\n           new_insn = emit_insn_after (new_insn, insn);\n-\n-          /* Keep register set table up to date.  */\n-          record_one_set (regno, insn);\n         }\n       else\n         {\n           new_insn = gen_move_insn (reg, old_reg);\n           new_insn = emit_insn_after (new_insn, insn);\n-\n-          /* Keep register set table up to date.  */\n-          record_one_set (regno, new_insn);\n         }\n     }\n   else /* This is possible only in case of a store to memory.  */\n@@ -4244,9 +3999,6 @@ pre_insert_copy_insn (struct expr *expr, rtx insn)\n         new_insn = emit_insn_before (new_insn, insn);\n       else\n         new_insn = emit_insn_after (new_insn, insn);\n-\n-      /* Keep register set table up to date.  */\n-      record_one_set (regno, new_insn);\n     }\n \n   gcse_create_count++;\n@@ -4303,7 +4055,7 @@ pre_insert_copies (void)\n \t\t  continue;\n \n \t\t/* Don't handle this one if it's a redundant one.  */\n-\t\tif (TEST_BIT (pre_redundant_insns, INSN_CUID (insn)))\n+\t\tif (INSN_DELETED_P (insn))\n \t\t  continue;\n \n \t\t/* Or if the expression doesn't reach the deleted one.  */\n@@ -4400,7 +4152,6 @@ pre_delete (void)\n \t\tgcse_emit_move_after (expr->reaching_reg, SET_DEST (set), insn);\n \t\tdelete_insn (insn);\n \t\toccr->deleted_p = 1;\n-\t\tSET_BIT (pre_redundant_insns, INSN_CUID (insn));\n \t\tchanged = 1;\n \t\tgcse_subst_count++;\n \n@@ -4455,10 +4206,6 @@ pre_gcse (void)\n     for (expr = expr_hash_table.table[i]; expr != NULL; expr = expr->next_same_hash)\n       index_map[expr->bitmap_index] = expr;\n \n-  /* Reset bitmap used to track which insns are redundant.  */\n-  pre_redundant_insns = sbitmap_alloc (max_cuid);\n-  sbitmap_zero (pre_redundant_insns);\n-\n   /* Delete the redundant insns first so that\n      - we know what register to use for the new insns and for the other\n        ones with reaching expressions\n@@ -4477,7 +4224,6 @@ pre_gcse (void)\n     }\n \n   free (index_map);\n-  sbitmap_free (pre_redundant_insns);\n   return changed;\n }\n \n@@ -4493,7 +4239,7 @@ one_pre_gcse_pass (int pass)\n   gcse_subst_count = 0;\n   gcse_create_count = 0;\n \n-  alloc_hash_table (max_cuid, &expr_hash_table, 0);\n+  alloc_hash_table (get_max_uid (), &expr_hash_table, 0);\n   add_noreturn_fake_exit_edges ();\n   if (flag_gcse_lm)\n     compute_ld_motion_mems ();\n@@ -4947,7 +4693,7 @@ one_code_hoisting_pass (void)\n {\n   int changed = 0;\n \n-  alloc_hash_table (max_cuid, &expr_hash_table, 0);\n+  alloc_hash_table (get_max_uid (), &expr_hash_table, 0);\n   compute_hash_table (&expr_hash_table);\n   if (dump_file)\n     dump_hash_table (dump_file, \"Code Hosting Expressions\", &expr_hash_table);\n@@ -5393,9 +5139,8 @@ update_ld_motion_stores (struct expr * expr)\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \n-\t  copy = gen_move_insn ( reg, copy_rtx (SET_SRC (pat)));\n+\t  copy = gen_move_insn (reg, copy_rtx (SET_SRC (pat)));\n \t  new_rtx = emit_insn_before (copy, insn);\n-\t  record_one_set (REGNO (reg), new_rtx);\n \t  SET_SRC (pat) = reg;\n \t  df_insn_rescan (insn);\n \n@@ -5430,19 +5175,13 @@ static int num_stores;\n \n static void\n reg_set_info (rtx dest, const_rtx setter ATTRIBUTE_UNUSED,\n-\t      void *data)\n+\t      void *data ATTRIBUTE_UNUSED)\n {\n-  sbitmap bb_reg = (sbitmap) data;\n-\n   if (GET_CODE (dest) == SUBREG)\n     dest = SUBREG_REG (dest);\n \n   if (REG_P (dest))\n-    {\n-      regvec[REGNO (dest)] = INSN_UID (compute_store_table_current_insn);\n-      if (bb_reg)\n-\tSET_BIT (bb_reg, REGNO (dest));\n-    }\n+    regvec[REGNO (dest)] = INSN_UID (compute_store_table_current_insn);\n }\n \n /* Clear any mark that says that this insn sets dest.  Called from\n@@ -5705,9 +5444,6 @@ compute_store_table (void)\n \n   max_gcse_regno = max_reg_num ();\n \n-  reg_set_in_block = sbitmap_vector_alloc (last_basic_block,\n-\t\t\t\t\t\t       max_gcse_regno);\n-  sbitmap_vector_zero (reg_set_in_block, last_basic_block);\n   pre_ldst_mems = 0;\n   pre_ldst_table = htab_create (13, pre_ldst_expr_hash,\n \t\t\t\tpre_ldst_expr_eq, NULL);\n@@ -5729,15 +5465,12 @@ compute_store_table (void)\n \t    {\n \t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t\tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n-\t\t  {\n-\t\t    last_set_in[regno] = INSN_UID (insn);\n-\t\t    SET_BIT (reg_set_in_block[bb->index], regno);\n-\t\t  }\n+\t\t  last_set_in[regno] = INSN_UID (insn);\n \t    }\n \n \t  pat = PATTERN (insn);\n \t  compute_store_table_current_insn = insn;\n-\t  note_stores (pat, reg_set_info, reg_set_in_block[bb->index]);\n+\t  note_stores (pat, reg_set_info, NULL);\n \t}\n \n       /* Now find the stores.  */\n@@ -6029,7 +5762,6 @@ build_store_vectors (void)\n   int *regs_set_in_block;\n   rtx insn, st;\n   struct ls_expr * ptr;\n-  unsigned regno;\n \n   /* Build the gen_vector. This is any store in the table which is not killed\n      by aliasing later in its block.  */\n@@ -6078,8 +5810,17 @@ build_store_vectors (void)\n \n   FOR_EACH_BB (bb)\n     {\n-      for (regno = 0; regno < max_gcse_regno; regno++)\n-\tregs_set_in_block[regno] = TEST_BIT (reg_set_in_block[bb->index], regno);\n+      FOR_BB_INSNS (bb, insn)\n+\tif (INSN_P (insn))\n+\t  {\n+\t    df_ref *def_rec;\n+\t    for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+\t      {\n+\t\tunsigned int ref_regno = DF_REF_REGNO (*def_rec);\n+\t\tif (ref_regno < max_gcse_regno)\n+\t\t  regs_set_in_block[DF_REF_REGNO (*def_rec)] = 1;\n+\t      }\n+\t  }\n \n       for (ptr = first_ls_expr (); ptr != NULL; ptr = next_ls_expr (ptr))\n \t{\n@@ -6395,11 +6136,9 @@ free_store_memory (void)\n     sbitmap_vector_free (pre_insert_map);\n   if (pre_delete_map)\n     sbitmap_vector_free (pre_delete_map);\n-  if (reg_set_in_block)\n-    sbitmap_vector_free (reg_set_in_block);\n \n   ae_gen = ae_kill = transp = st_antloc = NULL;\n-  pre_insert_map = pre_delete_map = reg_set_in_block = NULL;\n+  pre_insert_map = pre_delete_map = NULL;\n }\n \n /* Perform store motion. Much like gcse, except we move expressions the\n@@ -6427,7 +6166,6 @@ store_motion (void)\n     {\n       htab_delete (pre_ldst_table);\n       pre_ldst_table = NULL;\n-      sbitmap_vector_free (reg_set_in_block);\n       end_alias_analysis ();\n       return;\n     }\n@@ -6512,18 +6250,6 @@ bypass_jumps (void)\n   /* We need alias.  */\n   init_alias_analysis ();\n \n-  /* Record where pseudo-registers are set.  This data is kept accurate\n-     during each pass.  ??? We could also record hard-reg information here\n-     [since it's unchanging], however it is currently done during hash table\n-     computation.\n-\n-     It may be tempting to compute MEM set information here too, but MEM sets\n-     will be subject to code motion one day and thus we need to compute\n-     information about memory sets when we build the hash tables.  */\n-\n-  alloc_reg_set_mem (max_gcse_regno);\n-  compute_sets ();\n-\n   max_gcse_regno = max_reg_num ();\n   alloc_gcse_mem ();\n   changed = one_cprop_pass (3, true, true);\n@@ -6537,7 +6263,6 @@ bypass_jumps (void)\n     }\n \n   obstack_free (&gcse_obstack, NULL);\n-  free_reg_set_mem ();\n \n   /* We are finished with alias.  */\n   end_alias_analysis ();"}]}