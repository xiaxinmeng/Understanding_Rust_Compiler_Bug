{"sha": "d80c73318785edec642b04dfe00db2e61503bf20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgwYzczMzE4Nzg1ZWRlYzY0MmIwNGRmZTAwZGIyZTYxNTAzYmYyMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-06-08T11:24:46Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-07-09T12:35:26Z"}, "message": "[Ada] Update internal documentation of debugging information\n\ngcc/ada/\n\n\t* exp_dbug.ads: Update documentation of various items.", "tree": {"sha": "2280541db3ed15ed3440c1f36bcf8d3bce85cdbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2280541db3ed15ed3440c1f36bcf8d3bce85cdbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d80c73318785edec642b04dfe00db2e61503bf20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d80c73318785edec642b04dfe00db2e61503bf20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d80c73318785edec642b04dfe00db2e61503bf20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d80c73318785edec642b04dfe00db2e61503bf20/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81956c08f74be83aa61cba6c112b92cdc0198a66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81956c08f74be83aa61cba6c112b92cdc0198a66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81956c08f74be83aa61cba6c112b92cdc0198a66"}], "stats": {"total": 409, "additions": 191, "deletions": 218}, "files": [{"sha": "09921f0e42d0d911fa9a4370b9657a20a6ac90c1", "filename": "gcc/ada/exp_dbug.ads", "status": "modified", "additions": 191, "deletions": 218, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d80c73318785edec642b04dfe00db2e61503bf20/gcc%2Fada%2Fexp_dbug.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d80c73318785edec642b04dfe00db2e61503bf20/gcc%2Fada%2Fexp_dbug.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.ads?ref=d80c73318785edec642b04dfe00db2e61503bf20", "patch": "@@ -23,9 +23,11 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  Expand routines for generation of special declarations used by the\n---  debugger. In accordance with the Dwarf 2.2 specification, certain\n---  type names are encoded to provide information to the debugger.\n+--  Expand routines for the generation of special declarations used by the\n+--  debugger. In accordance with the DWARF specification, certain type names\n+--  may also be encoded to provide additional information to the debugger, but\n+--  this practice is being deprecated and some encodings described below are no\n+--  longer generated by default (they are marked OBSOLETE).\n \n with Namet; use Namet;\n with Types; use Types;\n@@ -496,53 +498,104 @@ package Exp_Dbug is\n    --  corresponding positive value followed by a lower case m for minus to\n    --  indicate that the value is negative (e.g. 2m for -2).\n \n-   -------------------------\n-   -- Type Name Encodings --\n-   -------------------------\n+   ------------------------\n+   -- Encapsulated Types --\n+   ------------------------\n+\n+   --  In some cases, the compiler may encapsulate a type by wrapping it in a\n+   --  record. For example, this is used when a size or alignment specification\n+   --  requires a larger type. Consider:\n+\n+   --    type x is mod 2 ** 64;\n+   --    for x'size use 256;\n+\n+   --  In this case, the compiler generates a record type x___PAD, which has\n+   --  a single field whose name is F. This single field is 64-bit long and\n+   --  contains the actual value. This kind of padding is used when the logical\n+   --  value to be stored is shorter than the object in which it is allocated.\n+\n+   --  A similar encapsulation is done for some packed array types, in which\n+   --  case the record type is x___JM and the field name is OBJECT. This is\n+   --  used in the case of a packed array stored using modular representation\n+   --  (see the section on representation of packed array objects). In this\n+   --  case the wrapping is used to achieve correct positioning of the packed\n+   --  array value (left/right justified in its field depending on endianness).\n+\n+   --  When the debugger sees an object of a type whose name has a suffix of\n+   --  ___PAD or ___JM, the type will be a record containing a single field,\n+   --  and the name of that field will be all upper case. In this case, it\n+   --  should look inside to get the value of the inner field, and neither\n+   --  the outer structure name, nor the field name should appear when the\n+   --  value is printed.\n+\n+   --  Similarly, when the debugger sees a record named REP being the type of\n+   --  a field inside another record type, it should treat the fields inside\n+   --  REP as being part of the outer record (this REP field is only present\n+   --  for code generation purposes). The REP record should not appear in the\n+   --  values printed by the debugger.\n+\n+   --------------------\n+   -- Implicit Types --\n+   --------------------\n+\n+   --  The compiler creates implicit type names in many situations where a\n+   --  type is present semantically, but no specific name is present. For\n+   --  example:\n+\n+   --     S : Integer range M .. N;\n+\n+   --  Here the subtype of S is not integer, but rather an anonymous subtype\n+   --  of Integer. Where possible, the compiler generates names for such\n+   --  anonymous types that are related to the type from which the subtype\n+   --  is obtained as follows:\n+\n+   --     T name suffix\n+\n+   --  where name is the name from which the subtype is obtained, using\n+   --  lower case letters and underscores, and suffix starts with an upper\n+   --  case letter. For example the name for the above declaration might be:\n+\n+   --     TintegerS4b\n+\n+   --  If the debugger is asked to give the type of an entity and the type\n+   --  has the form T name suffix, it is probably appropriate to just use\n+   --  \"name\" in the response since this is what is meaningful to the\n+   --  programmer.\n+\n+   -------------------\n+   -- Modular Types --\n+   -------------------\n+\n+   --  A type declared\n+\n+   --    type x is mod N;\n+\n+   --  is encoded as a subrange of an unsigned base type with lower bound zero\n+   --  and upper bound N - 1. Thus we give these types a somewhat nonstandard\n+   --  interpretation: the standard interpretation would not, in general, imply\n+   --  that arithmetic operations on type x are performed modulo N (especially\n+   --  not when N is not a power of 2).\n+\n+   --------------------------------------\n+   -- Tagged Types and Type Extensions --\n+   --------------------------------------\n+\n+   --  A type D derived from a tagged type P has a field named \"_parent\" of\n+   --  type P that contains its inherited fields. The type of this field is\n+   --  usually P, but may be a more distant ancestor, if P is a null extension\n+   --  of that type.\n+\n+   --  The type tag of a tagged type is a field named \"_tag\" of a pointer type.\n+   --  If the type is derived from another tagged type, its _tag field is found\n+   --  in its _parent field.\n+\n+   ------------------------------------\n+   -- Type Name Encodings (OBSOLETE) --\n+   ------------------------------------\n \n    --  In the following typ is the name of the type as normally encoded by the\n    --  debugger rules, i.e. a non-qualified name, all in lower case, with\n-   --  standard encoding of upper half and wide characters\n-\n-      ------------------------\n-      -- Encapsulated Types --\n-      ------------------------\n-\n-      --  In some cases, the compiler encapsulates a type by wrapping it in a\n-      --  structure. For example, this is used when a size or alignment\n-      --  specification requires a larger type. Consider:\n-\n-      --    type y is mod 2 ** 64;\n-      --    for y'size use 256;\n-\n-      --  In this case the compile generates a structure type y___PAD, which\n-      --  has a single field whose name is F. This single field is 64 bits\n-      --  long and contains the actual value. This kind of padding is used\n-      --  when the logical value to be stored is shorter than the object in\n-      --  which it is allocated. For example if a size clause is used to set\n-      --  a size of 256 for a signed integer value, then a typical choice is\n-      --  to wrap a 64-bit integer in a 256 bit PAD structure.\n-\n-      --  A similar encapsulation is done for some packed array types, in which\n-      --  case the structure type is y___JM and the field name is OBJECT.\n-      --  This is used in the case of a packed array stored using modular\n-      --  representation (see section on representation of packed array\n-      --  objects). In this case the JM wrapping is used to achieve correct\n-      --  positioning of the packed array value (left or right justified in its\n-      --  field depending on endianness.\n-\n-      --  When the debugger sees an object of a type whose name has a suffix of\n-      --  ___PAD or ___JM, the type will be a record containing a single field,\n-      --  and the name of that field will be all upper case. In this case, it\n-      --  should look inside to get the value of the inner field, and neither\n-      --  the outer structure name, nor the field name should appear when the\n-      --  value is printed.\n-\n-      --  When the debugger sees a record named REP being a field inside\n-      --  another record, it should treat the fields inside REP as being part\n-      --  of the outer record (this REP field is only present for code\n-      --  generation purposes). The REP record should not appear in the values\n-      --  printed by the debugger.\n+   --  standard encoding of upper half and wide characters.\n \n       -----------------------\n       -- Fixed-Point Types --\n@@ -613,22 +666,6 @@ package Exp_Dbug is\n       --   or compile time known values, with the encoding first for the lower\n       --   bound, then for the upper bound, as previously described.\n \n-      -------------------\n-      -- Modular Types --\n-      -------------------\n-\n-      --  A type declared\n-\n-      --    type x is mod N;\n-\n-      --  Is encoded as a subrange of an unsigned base type with lower bound\n-      --  zero and upper bound N. That is, there is no name encoding. We use\n-      --  the standard encodings provided by the debugging format. Thus we\n-      --  give these types a non-standard interpretation: the standard\n-      --  interpretation of our encoding would not, in general, imply that\n-      --  arithmetic on type x was to be performed modulo N (especially not\n-      --  when N is not a power of 2).\n-\n       ------------------\n       -- Biased Types --\n       ------------------\n@@ -887,34 +924,6 @@ package Exp_Dbug is\n       --  redundantly, particularly in the fixed-point case, but this\n       --  information can in any case be ignored by the debugger.\n \n-      ----------------------------\n-      -- Note on Implicit Types --\n-      ----------------------------\n-\n-      --  The compiler creates implicit type names in many situations where a\n-      --  type is present semantically, but no specific name is present. For\n-      --  example:\n-\n-      --     S : Integer range M .. N;\n-\n-      --  Here the subtype of S is not integer, but rather an anonymous subtype\n-      --  of Integer. Where possible, the compiler generates names for such\n-      --  anonymous types that are related to the type from which the subtype\n-      --  is obtained as follows:\n-\n-      --     T name suffix\n-\n-      --  where name is the name from which the subtype is obtained, using\n-      --  lower case letters and underscores, and suffix starts with an upper\n-      --  case letter. For example the name for the above declaration might be:\n-\n-      --     TintegerS4b\n-\n-      --  If the debugger is asked to give the type of an entity and the type\n-      --  has the form T name suffix, it is probably appropriate to just use\n-      --  \"name\" in the response since this is what is meaningful to the\n-      --  programmer.\n-\n    -------------------------------------------------\n    -- Subprograms for Handling Encoded Type Names --\n    -------------------------------------------------\n@@ -1062,51 +1071,6 @@ package Exp_Dbug is\n    --  debug declaration, then Empty is returned. This function also takes care\n    --  of setting Materialize_Entity on the renamed entity where required.\n \n-   ---------------------------\n-   -- Packed Array Encoding --\n-   ---------------------------\n-\n-   --  For every constrained packed array, two types are created, and both\n-   --  appear in the debugging output:\n-\n-   --    The original declared array type is a perfectly normal array type, and\n-   --    its index bounds indicate the original bounds of the array.\n-\n-   --    The corresponding packed array type, which may be a modular type, or\n-   --    may be an array of bytes type (see Exp_Pakd for full details). This is\n-   --    the type that is actually used in the generated code and for debugging\n-   --    information for all objects of the packed type.\n-\n-   --  The name of the corresponding packed array type is:\n-\n-   --    ttt___XPnnn\n-\n-   --  where\n-\n-   --    ttt is the name of the original declared array\n-   --    nnn is the component size in bits (1-31)\n-\n-   --  Note that if the packed array is not bit-packed, the name will simply\n-   --  be tttP.\n-\n-   --  When the debugger sees that an object is of a type that is encoded in\n-   --  this manner, it can use the original type to determine the bounds and\n-   --  the component type, and the component size to determine the packing\n-   --  details.\n-\n-   --  For an unconstrained packed array, the corresponding packed array type\n-   --  is neither used in the generated code nor for debugging information,\n-   --  only the original type is used. In order to convey the packing in the\n-   --  debugging information, the compiler generates the associated fat- and\n-   --  thin-pointer types (see the Pointers to Unconstrained Array section\n-   --  below) using the name of the corresponding packed array type as the\n-   --  base name, i.e. ttt___XPnnn___XUP and ttt___XPnnn___XUT respectively.\n-\n-   --  When the debugger sees that an object is of a type that is encoded in\n-   --  this manner, it can use the type of the fields to determine the bounds\n-   --  and the component type, and the component size to determine the packing\n-   --  details.\n-\n    -------------------------------------------\n    -- Packed Array Representation in Memory --\n    -------------------------------------------\n@@ -1204,6 +1168,51 @@ package Exp_Dbug is\n    --  would mean that an assignment such as a := above would require shifts\n    --  when one value is in a register and the other value is in memory.\n \n+   -------------------------------------------\n+   -- Packed Array Name Encoding (OBSOLETE) --\n+   -------------------------------------------\n+\n+   --  For every constrained packed array, two types are created, and both\n+   --  appear in the debugging output:\n+\n+   --    The original declared array type is a perfectly normal array type, and\n+   --    its index bounds indicate the original bounds of the array.\n+\n+   --    The corresponding packed array type, which may be a modular type, or\n+   --    may be an array of bytes type (see Exp_Pakd for full details). This is\n+   --    the type that is actually used in the generated code and for debugging\n+   --    information for all objects of the packed type.\n+\n+   --  The name of the corresponding packed array type is:\n+\n+   --    ttt___XPnnn\n+\n+   --  where\n+\n+   --    ttt is the name of the original declared array\n+   --    nnn is the component size in bits (1-31)\n+\n+   --  Note that if the packed array is not bit-packed, the name will simply\n+   --  be tttP.\n+\n+   --  When the debugger sees that an object is of a type that is encoded in\n+   --  this manner, it can use the original type to determine the bounds and\n+   --  the component type, and the component size to determine the packing\n+   --  details.\n+\n+   --  For an unconstrained packed array, the corresponding packed array type\n+   --  is neither used in the generated code nor for debugging information,\n+   --  only the original type is used. In order to convey the packing in the\n+   --  debugging information, the compiler generates the associated fat- and\n+   --  thin-pointer types (see the Pointers to Unconstrained Array section\n+   --  below) using the name of the corresponding packed array type as the\n+   --  base name, i.e. ttt___XPnnn___XUP and ttt___XPnnn___XUT respectively.\n+\n+   --  When the debugger sees that an object is of a type that is encoded in\n+   --  this manner, it can use the type of the fields to determine the bounds\n+   --  and the component type, and the component size to determine the packing\n+   --  details.\n+\n    ------------------------------------------------------\n    -- Subprograms for Handling Packed Array Type Names --\n    ------------------------------------------------------\n@@ -1219,58 +1228,67 @@ package Exp_Dbug is\n    -- Pointers to Unconstrained Arrays --\n    --------------------------------------\n \n-   --  There are two kinds of pointers to arrays. The debugger can tell which\n-   --  format is in use by the form of the type of the pointer.\n+   --  There are two kinds of pointer to unconstrained arrays. The debugger can\n+   --  tell which format is in use by the form of the type of the pointer.\n \n    --    Fat Pointers\n \n-   --      Fat pointers are represented as a struct with two fields. This\n-   --      struct has two distinguished field names:\n+   --      Fat pointers are represented as a structure with two fields. This\n+   --      structure has two distinguished field names:\n \n    --        P_ARRAY is a pointer to the array type. The name of this type is\n-   --        the unconstrained type followed by \"___XUA\". This array will have\n-   --        bounds which are the discriminants, and hence are unparsable, but\n-   --        will give the number of subscripts and the component type.\n+   --        the unconstrained type followed by \"___XUA\". The bounds of this\n+   --        array will be obtained through dereferences of P_BOUNDS below.\n \n-   --        P_BOUNDS is a pointer to a struct, the name of  whose type is the\n-   --        unconstrained array name followed by \"___XUB\" and which has\n-   --        fields of the form\n+   --        P_BOUNDS is a pointer to a structure. The name of this type is\n+   --        the unconstrained array name followed by \"___XUB\" and it has\n+   --        fields of the form:\n \n    --           LBn (n a decimal integer) lower bound of n'th dimension\n    --           UBn (n a decimal integer) upper bound of n'th dimension\n \n-   --        The bounds may be any integral type. In the case of an enumeration\n-   --        type, Enum_Rep values are used.\n+   --        The bounds may be of any integral type. In the case of enumeration\n+   --        types, Enum_Rep values are used.\n+\n+   --      For a given unconstrained array type, the compiler will generate a\n+   --      fat pointer type whose name is the name of the array type, and use\n+   --      it to represent the array type itself in the debugging information.\n \n-   --      For a given unconstrained array type, the compiler will generate one\n-   --      fat-pointer type whose name is \"arr___XUP\", where \"arr\" is the name\n-   --      of the array type, and use it to represent the array type itself in\n-   --      the debugging information.\n+   --      This name was historically followed by \"___XUP\" (OBSOLETE).\n \n    --      For each pointer to this unconstrained array type, the compiler will\n-   --      generate a typedef that points to the above \"arr___XUP\" fat-pointer\n-   --      type. As a consequence, when it comes to fat-pointer types:\n+   --      generate a typedef that points to the above fat pointer type. As a\n+   --      consequence, when it comes to fat pointer types:\n \n-   --        1. The type name is given by the typedef\n+   --        1. The type name is given by the typedef, if any\n \n    --        2. If the debugger is asked to output the type, the appropriate\n-   --           form is \"access arr\", except if the type name is \"arr___XUP\"\n-   --           for which it is the array definition.\n+   --           form is \"access arr\" if there is the typedef, otherwise it is\n+   --           the array definition.\n \n    --    Thin Pointers\n \n+   --      The value of a thin pointer is a pointer to the second field of a\n+   --      structure with two fields. The first field of the structure is of\n+   --      the type ___XUB described for fat pointer types above. The second\n+   --      field of the structure contains the actual array.\n+\n+   --      Thin pointers are represented as a regular pointer to array in the\n+   --      debugging information. The bounds of this array will be the contents\n+   --      of the first field above obtained through (shifted) dereferences.\n+\n+   --    Thin Pointers (OBSOLETE)\n+\n    --      The value of a thin pointer is a pointer to the second field of a\n    --      structure with two fields. The name of this structure's type is\n    --      \"arr___XUT\", where \"arr\" is the name of the unconstrained array\n-   --      type. Even though it actually points into middle of this structure,\n-   --      the thin pointer's type in debugging information is\n-   --      pointer-to-arr___XUT.\n+   --      type. Even though it points into the middle of this structure,\n+   --      the type in the debugging information is pointer to structure.\n \n-   --      The first field of arr___XUT is named BOUNDS, and has a type named\n-   --      arr___XUB, with the structure described for such types in fat\n-   --      pointers, as described above.\n+   --      The first field of the structure is named BOUNDS and is of the type\n+   --      ___XUB described for fat pointer types above.\n \n-   --      The second field of arr___XUT is named ARRAY, and contains the\n+   --      The second field of the structure is named ARRAY, and contains the\n    --      actual array. Because this array has a dynamic size, determined by\n    --      the BOUNDS field that precedes it, all of the information about\n    --      arr___XUT is encoded in a parallel type named arr___XUT___XVE, with\n@@ -1279,19 +1297,6 @@ package Exp_Dbug is\n    --      type in this case is named arr___XUA and only its element type is\n    --      meaningful, just as described for fat pointers.\n \n-   --------------------------------------\n-   -- Tagged Types and Type Extensions --\n-   --------------------------------------\n-\n-   --  A type C derived from a tagged type P has a field named \"_parent\" of\n-   --  type P that contains its inherited fields. The type of this field is\n-   --  usually P (encoded as usual if it has a dynamic size), but may be a more\n-   --  distant ancestor, if P is a null extension of that type.\n-\n-   --  The type tag of a tagged type is a field named _tag, of type void*. If\n-   --  the type is derived from another tagged type, its _tag field is found in\n-   --  its _parent field.\n-\n    -----------------------------\n    -- Variant Record Encoding --\n    -----------------------------\n@@ -1311,8 +1316,7 @@ package Exp_Dbug is\n    --  union, in which each member of the union corresponds to one variant.\n    --  However, unlike a C union, the size of the type may be variable even if\n    --  each of the components are fixed size, since it includes a computation\n-   --  of which variant is present. In that case, it will be encoded as above\n-   --  and a type with the suffix \"___XVN___XVU\" will be present.\n+   --  of which variant is present.\n \n    --  The name of the union member is encoded to indicate the choices, and\n    --  is a string given by the following grammar:\n@@ -1335,9 +1339,7 @@ package Exp_Dbug is\n    --  to the use of the Enum_Rep attribute).\n \n    --  The type of the inner record is given by the name of the union type (as\n-   --  above) concatenated with the above string. Since that type may itself be\n-   --  variable-sized, it may also be encoded as above with a new type with a\n-   --  further suffix of \"___XVU\".\n+   --  above) concatenated with the above string.\n \n    --  As an example, consider:\n \n@@ -1375,9 +1377,7 @@ package Exp_Dbug is\n    --        be encoded, as in ordinary C unions, as a single field of the\n    --        enclosing union type named \"x\" of type \"T\", dispensing with the\n    --        enclosing struct. In this case, of course, the discriminant values\n-   --        corresponding to the variant are unavailable. As for normal\n-   --        variants, the field name \"x\" may be suffixed with ___XVL if it\n-   --        has dynamic size.\n+   --        corresponding to the variant are unavailable.\n \n    --  For example, the type Var in the preceding section, if followed by\n    --  \"pragma Unchecked_Union (Var);\" may be encoded as a struct with two\n@@ -1549,46 +1549,19 @@ package Exp_Dbug is\n    --  are missing and deal as best as it can with the limited information\n    --  available.\n \n-   ---------------------------------\n-   -- GNAT Extensions to DWARF2/3 --\n-   ---------------------------------\n-\n-   --  If the compiler switch \"-gdwarf+\" is specified, GNAT Vendor extensions\n-   --  to DWARF2/3 are generated, with the following variations from the above\n-   --  specification.\n-\n-   --   Change in the contents of the DW_AT_name attribute\n-\n-   --     The operators are represented in their natural form. (for example,\n-   --     the addition operator is written as \"+\" instead of \"Oadd\"). The\n-   --     component separator is \".\" instead of \"__\"\n+   -----------------------------------------\n+   -- GNAT Extensions to DWARF (OBSOLETE) --\n+   -----------------------------------------\n \n-   --   Introduction of DW_AT_GNAT_encoding, encoded with value 0x2301\n+   --   DW_AT_use_GNAT_descriptive_type, encoded with value 0x2301\n \n-   --     Any debugging information entry representing a program entity, named\n-   --     or implicit, may have a DW_AT_GNAT_encoding attribute. The value of\n-   --     this attribute is a string representing the suffix internally added\n-   --     by GNAT for various purposes, mainly for representing debug\n-   --     information compatible with other formats. In particular this is\n-   --     useful for IDEs which need to filter out information internal to\n-   --     GNAT from their graphical interfaces.\n+   --     This extension has never been implemented in the compiler.\n \n-   --     If a debugging information entry has multiple encodings, all of them\n-   --     will be listed in DW_AT_GNAT_encoding using the list separator ':'.\n-\n-   --   Introduction of DW_AT_GNAT_descriptive_type, encoded with value 0x2302\n+   --   DW_AT_GNAT_descriptive_type, encoded with value 0x2302\n \n    --     Any debugging information entry representing a type may have a\n    --     DW_AT_GNAT_descriptive_type attribute whose value is a reference,\n    --     pointing to a debugging information entry representing another type\n    --     associated to the type.\n \n-   --   Modification of the contents of the DW_AT_producer string\n-\n-   --     When emitting full GNAT Vendor extensions to DWARF2/3, \"-gdwarf+\"\n-   --     is appended to the DW_AT_producer string.\n-   --\n-   --     When emitting only DW_AT_GNAT_descriptive_type, \"-gdwarf+-\" is\n-   --     appended to the DW_AT_producer string.\n-\n end Exp_Dbug;"}]}