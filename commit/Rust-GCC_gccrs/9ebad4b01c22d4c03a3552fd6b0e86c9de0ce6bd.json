{"sha": "9ebad4b01c22d4c03a3552fd6b0e86c9de0ce6bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWViYWQ0YjAxYzIyZDRjMDNhMzU1MmZkNmIwZTg2YzlkZTBjZTZiZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-11-28T14:48:54Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-11-30T20:22:14Z"}, "message": "compiler, runtime: check len/cap for append(s, make(T, l)...)\n\nThe overflow checks done in growslice always reported an error for the\ncapacity argument, even if it was the length argument that overflowed.\nThis change lets the code pass the current issue4085b.go test.\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/273806", "tree": {"sha": "ff2741f17fb80f494bd1ce08b2b31e8605e0c90d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff2741f17fb80f494bd1ce08b2b31e8605e0c90d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ebad4b01c22d4c03a3552fd6b0e86c9de0ce6bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ebad4b01c22d4c03a3552fd6b0e86c9de0ce6bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ebad4b01c22d4c03a3552fd6b0e86c9de0ce6bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ebad4b01c22d4c03a3552fd6b0e86c9de0ce6bd/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e848a83f46f15280ad654f05545cc5ec4f5b8e50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e848a83f46f15280ad654f05545cc5ec4f5b8e50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e848a83f46f15280ad654f05545cc5ec4f5b8e50"}], "stats": {"total": 53, "additions": 28, "deletions": 25}, "files": [{"sha": "eec3d0708e56ac17532ea71a6226e146e63f3050", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ebad4b01c22d4c03a3552fd6b0e86c9de0ce6bd/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ebad4b01c22d4c03a3552fd6b0e86c9de0ce6bd/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=9ebad4b01c22d4c03a3552fd6b0e86c9de0ce6bd", "patch": "@@ -1,4 +1,4 @@\n-be1738f1fff0e817d921ed568791f9b0585a6982\n+84506e0f6bf282765856cb5aeb17124222f73042\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "23caf61db93d9737004f36432f0754ec39990c97", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ebad4b01c22d4c03a3552fd6b0e86c9de0ce6bd/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ebad4b01c22d4c03a3552fd6b0e86c9de0ce6bd/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=9ebad4b01c22d4c03a3552fd6b0e86c9de0ce6bd", "patch": "@@ -8893,8 +8893,8 @@ Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n           // We will optimize this to directly zeroing the tail,\n           // instead of allocating a new slice then copy.\n \n-          // Retrieve the length. Cannot reference s2 as we will remove\n-          // the makeslice call.\n+          // Retrieve the length and capacity. Cannot reference s2 as\n+          // we will remove the makeslice call.\n           Expression* len_arg = makecall->args()->at(1);\n           len_arg = Expression::make_cast(int_type, len_arg, loc);\n           l2tmp = Statement::make_temporary(int_type, len_arg, loc);\n@@ -8907,28 +8907,19 @@ Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n           inserter->insert(c2tmp);\n \n           // Check bad len/cap here.\n-          // if len2 < 0 { panicmakeslicelen(); }\n+\t  // checkmakeslice(type, len, cap)\n+\t  // (Note that if len and cap are constants, we won't see a\n+\t  // makeslice call here, as it will be rewritten to a stack\n+\t  // allocated array by Mark_address_taken::expression.)\n+\t  Expression* elem = Expression::make_type_descriptor(element_type,\n+\t\t\t\t\t\t\t      loc);\n           len2 = Expression::make_temporary_reference(l2tmp, loc);\n-          Expression* zero = Expression::make_integer_ul(0, int_type, loc);\n-          Expression* cond = Expression::make_binary(OPERATOR_LT, len2,\n-                                                     zero, loc);\n-\t  Expression* call = Runtime::make_call(Runtime::PANIC_MAKE_SLICE_LEN,\n-\t\t\t\t\t\tloc, 0);\n-          cond = Expression::make_conditional(cond, call, zero->copy(), loc);\n-          gogo->lower_expression(function, inserter, &cond);\n-          gogo->flatten_expression(function, inserter, &cond);\n-          Statement* s = Statement::make_statement(cond, false);\n-          inserter->insert(s);\n-\n-          // if cap2 < 0 { panicmakeslicecap(); }\n           Expression* cap2 = Expression::make_temporary_reference(c2tmp, loc);\n-          cond = Expression::make_binary(OPERATOR_LT, cap2,\n-                                         zero->copy(), loc);\n-\t  call = Runtime::make_call(Runtime::PANIC_MAKE_SLICE_CAP, loc, 0);\n-          cond = Expression::make_conditional(cond, call, zero->copy(), loc);\n-          gogo->lower_expression(function, inserter, &cond);\n-          gogo->flatten_expression(function, inserter, &cond);\n-          s = Statement::make_statement(cond, false);\n+\t  Expression* check = Runtime::make_call(Runtime::CHECK_MAKE_SLICE,\n+\t\t\t\t\t\t loc, 3, elem, len2, cap2);\n+          gogo->lower_expression(function, inserter, &check);\n+          gogo->flatten_expression(function, inserter, &check);\n+          Statement* s = Statement::make_statement(check, false);\n           inserter->insert(s);\n \n           // Remove the original makeslice call."}, {"sha": "9a3c68091308fd499988f3a99a08f61e543442e6", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ebad4b01c22d4c03a3552fd6b0e86c9de0ce6bd/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ebad4b01c22d4c03a3552fd6b0e86c9de0ce6bd/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=9ebad4b01c22d4c03a3552fd6b0e86c9de0ce6bd", "patch": "@@ -265,6 +265,11 @@ DEF_GO_RUNTIME(GROWSLICE, \"runtime.growslice\",\n                P5(TYPE, POINTER, INT, INT, INT), R1(SLICE))\n \n \n+// Check the length and cap passed to make, without making a slice.\n+// This is used for apend(s, make([]T, len)...).\n+DEF_GO_RUNTIME(CHECK_MAKE_SLICE, \"runtime.checkMakeSlice\", P3(TYPE, INT, INT),\n+\t       R1(UINTPTR))\n+\n // Register roots (global variables) for the garbage collector.\n DEF_GO_RUNTIME(REGISTER_GC_ROOTS, \"runtime.registerGCRoots\", P1(POINTER), R0())\n "}, {"sha": "ddd588ed5b937b7d98ae037e4e6e3956ee7d6561", "filename": "libgo/go/runtime/slice.go", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ebad4b01c22d4c03a3552fd6b0e86c9de0ce6bd/libgo%2Fgo%2Fruntime%2Fslice.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ebad4b01c22d4c03a3552fd6b0e86c9de0ce6bd/libgo%2Fgo%2Fruntime%2Fslice.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fslice.go?ref=9ebad4b01c22d4c03a3552fd6b0e86c9de0ce6bd", "patch": "@@ -15,6 +15,7 @@ import (\n //go:linkname panicmakeslicelen\n //go:linkname panicmakeslicecap\n //go:linkname makeslice\n+//go:linkname checkMakeSlice\n //go:linkname makeslice64\n //go:linkname growslice\n //go:linkname slicecopy\n@@ -91,6 +92,13 @@ func makeslicecopy(et *_type, tolen int, fromlen int, from unsafe.Pointer) unsaf\n }\n \n func makeslice(et *_type, len, cap int) unsafe.Pointer {\n+\tmem := checkMakeSlice(et, len, cap)\n+\treturn mallocgc(mem, et, true)\n+}\n+\n+// checkMakeSlice is called for append(s, make([]T, len, cap)...) to check\n+// the values of len and cap.\n+func checkMakeSlice(et *_type, len, cap int) uintptr {\n \tmem, overflow := math.MulUintptr(et.size, uintptr(cap))\n \tif overflow || mem > maxAlloc || len < 0 || len > cap {\n \t\t// NOTE: Produce a 'len out of range' error instead of a\n@@ -104,8 +112,7 @@ func makeslice(et *_type, len, cap int) unsafe.Pointer {\n \t\t}\n \t\tpanicmakeslicecap()\n \t}\n-\n-\treturn mallocgc(mem, et, true)\n+\treturn mem\n }\n \n func makeslice64(et *_type, len64, cap64 int64) unsafe.Pointer {"}]}