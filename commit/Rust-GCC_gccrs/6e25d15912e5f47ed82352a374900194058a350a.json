{"sha": "6e25d15912e5f47ed82352a374900194058a350a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUyNWQxNTkxMmU1ZjQ3ZWQ4MjM1MmEzNzQ5MDAxOTQwNThhMzUwYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-19T22:13:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-19T22:13:23Z"}, "message": "(newpat_used_regs): New variable.\n\n(mark_used_regs_combine): New function.\n(try_combine): Use them.\n(reg_dead_at_p): Registers marked in newpat_used_regs must always be\nconsidered to be live.\n\nFrom-SVN: r6826", "tree": {"sha": "254f01a4aba84e9228b757b24ed1ff206e139a5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/254f01a4aba84e9228b757b24ed1ff206e139a5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e25d15912e5f47ed82352a374900194058a350a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e25d15912e5f47ed82352a374900194058a350a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e25d15912e5f47ed82352a374900194058a350a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e25d15912e5f47ed82352a374900194058a350a/comments", "author": null, "committer": null, "parents": [{"sha": "1c78fc52207e5b20fb4b4acddbb6a02af240fcf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c78fc52207e5b20fb4b4acddbb6a02af240fcf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c78fc52207e5b20fb4b4acddbb6a02af240fcf0"}], "stats": {"total": 125, "additions": 124, "deletions": 1}, "files": [{"sha": "5c209ae873202b4c3a747fa5ecf8d65170ce2930", "filename": "gcc/combine.c", "status": "modified", "additions": 124, "deletions": 1, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e25d15912e5f47ed82352a374900194058a350a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e25d15912e5f47ed82352a374900194058a350a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=6e25d15912e5f47ed82352a374900194058a350a", "patch": "@@ -184,6 +184,11 @@ static rtx subst_prev_insn;\n \n static int subst_low_cuid;\n \n+/* This contains any hard registers that are used in newpat; reg_dead_at_p\n+   must consider all these registers to be always live.  */\n+\n+static HARD_REG_SET newpat_used_regs;\n+\n /* This is an insn to which a LOG_LINKS entry has been added.  If this\n    insn is the earlier than I2 or I3, combine should rescan starting at\n    that location.  */\n@@ -433,6 +438,7 @@ static void move_deaths\t\tPROTO((rtx, int, rtx, rtx *));\n static int reg_bitfield_target_p  PROTO((rtx, rtx));\n static void distribute_notes\tPROTO((rtx, rtx, rtx, rtx, rtx, rtx));\n static void distribute_links\tPROTO((rtx));\n+static void mark_used_regs_combine PROTO((rtx));\n \f\n /* Main entry point for combiner.  F is the first insn of the function.\n    NREGS is the first unused pseudo-reg number.  */\n@@ -1219,6 +1225,9 @@ try_combine (i3, i2, i1)\n      accept this combination.  */\n   undobuf.storage = (char *) oballoc (0);\n \n+  /* Reset the hard register usage information.  */\n+  CLEAR_HARD_REG_SET (newpat_used_regs);\n+\n   /* If I1 and I2 both feed I3, they can be in any order.  To simplify the\n      code below, set I1 to be the earlier of the two insns.  */\n   if (i1 && INSN_CUID (i1) > INSN_CUID (i2))\n@@ -1640,6 +1649,9 @@ try_combine (i3, i2, i1)\n      destination of I3.  */\n  validate_replacement:\n \n+  /* Note which hard regs this insn has as inputs.  */\n+  mark_used_regs_combine (newpat);\n+\n   /* Is the result of combination a valid instruction?  */\n   insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n \n@@ -1999,6 +2011,8 @@ try_combine (i3, i2, i1)\n       rtx new_other_notes;\n       rtx note, next;\n \n+      CLEAR_HARD_REG_SET (newpat_used_regs);\n+\n       other_code_number = recog_for_combine (&other_pat, undobuf.other_insn,\n \t\t\t\t\t     &new_other_notes);\n \n@@ -9875,7 +9889,8 @@ reg_dead_at_p_1 (dest, x)\n    We scan backwards from INSN.  If we hit a REG_DEAD note or a CLOBBER\n    referencing REG, it is dead.  If we hit a SET referencing REG, it is\n    live.  Otherwise, see if it is live or dead at the start of the basic\n-   block we are in.  */\n+   block we are in.  Hard regs marked as being live in NEWPAT_USED_REGS\n+   must be assumed to be always live.  */\n \n static int\n reg_dead_at_p (reg, insn)\n@@ -9893,6 +9908,14 @@ reg_dead_at_p (reg, insn)\n \n   reg_dead_flag = 0;\n \n+  /* Check that reg isn't mentioned in NEWPAT_USED_REGS.  */\n+  if (reg_dead_regno < FIRST_PSEUDO_REGISTER)\n+    {\n+      for (i = reg_dead_regno; i < reg_dead_endregno; i++)\n+\tif (TEST_HARD_REG_BIT (newpat_used_regs, i))\n+\t  return 0;\n+    }\n+\n   /* Scan backwards until we find a REG_DEAD note, SET, CLOBBER, label, or\n      beginning of function.  */\n   for (; insn && GET_CODE (insn) != CODE_LABEL;\n@@ -9926,6 +9949,106 @@ reg_dead_at_p (reg, insn)\n \n   return 1;\n }\n+\f\n+/* Note hard registers in X that are used.  This code is similar to\n+   that in flow.c, but much simpler since we don't care about pseudos.  */\n+\n+static void\n+mark_used_regs_combine (x)\n+     rtx x;\n+{\n+  register RTX_CODE code = GET_CODE (x);\n+  register int regno;\n+  int i;\n+\n+  switch (code)\n+    {\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_INT:\n+    case CONST:\n+    case CONST_DOUBLE:\n+    case PC:\n+    case ADDR_VEC:\n+    case ADDR_DIFF_VEC:\n+    case ASM_INPUT:\n+#ifdef HAVE_cc0\n+    /* CC0 must die in the insn after it is set, so we don't need to take\n+       special note of it here.  */\n+    case CC0:\n+#endif\n+      return;\n+\n+    case CLOBBER:\n+      /* If we are clobbering a MEM, mark any hard registers inside the\n+\t address as used.  */\n+      if (GET_CODE (XEXP (x, 0)) == MEM)\n+\tmark_used_regs_combine (XEXP (XEXP (x, 0), 0));\n+      return;\n+\n+    case REG:\n+      regno = REGNO (x);\n+      /* A hard reg in a wide mode may really be multiple registers.\n+\t If so, mark all of them just like the first.  */\n+      if (regno < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  /* None of this applies to the stack, frame or arg pointers */\n+\t  if (regno == STACK_POINTER_REGNUM\n+#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n+\t      || regno == HARD_FRAME_POINTER_REGNUM\n+#endif\n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+\t      || (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n+#endif\n+\t      || regno == FRAME_POINTER_REGNUM)\n+\t    return;\n+\n+\t  i = HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\t  while (i-- > 0)\n+\t    SET_HARD_REG_BIT (newpat_used_regs, regno + i);\n+\t}\n+      return;\n+\n+    case SET:\n+      {\n+\t/* If setting a MEM, or a SUBREG of a MEM, then note any hard regs in\n+\t   the address.  */\n+\tregister rtx testreg = SET_DEST (x);\n+\n+\twhile (GET_CODE (x) == SUBREG\n+\t       || GET_CODE (x) == ZERO_EXTRACT\n+\t       || GET_CODE (x) == SIGN_EXTRACT\n+\t       || GET_CODE (x) == STRICT_LOW_PART)\n+\t  testreg = XEXP (testreg, 0);\n+\n+\tif (GET_CODE (testreg) == MEM)\n+\t  mark_used_regs_combine (XEXP (testreg, 0));\n+\n+\tmark_used_regs_combine (SET_SRC (x));\n+\treturn;\n+      }\n+    }\n+\n+  /* Recursively scan the operands of this expression.  */\n+\n+  {\n+    register char *fmt = GET_RTX_FORMAT (code);\n+\n+    for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+      {\n+        if (fmt[i] == 'e')\n+\t  mark_used_regs_combine (XEXP (x, i));\n+        else if (fmt[i] == 'E')\n+          {\n+            register int j;\n+\n+            for (j = 0; j < XVECLEN (x, i); j++)\n+              mark_used_regs_combine (XVECEXP (x, i, j));\n+          }\n+      }\n+  }\n+}\n+\n \f\n /* Remove register number REGNO from the dead registers list of INSN.\n "}]}