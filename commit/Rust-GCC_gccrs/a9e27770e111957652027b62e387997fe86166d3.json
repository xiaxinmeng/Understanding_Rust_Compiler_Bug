{"sha": "a9e27770e111957652027b62e387997fe86166d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTllMjc3NzBlMTExOTU3NjUyMDI3YjYyZTM4Nzk5N2ZlODYxNjZkMw==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-01-25T14:02:16Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-01-25T14:02:16Z"}, "message": "(*): Replace TARGET_V9 with TARGET_ARCH64.\n\n(hard_32bit_mode_classes): Add v9 regs.\n(gen_v9_scc): Handle 32 bit v9 case.  Call v9_regcmp_p.\n\nFrom-SVN: r11099", "tree": {"sha": "64dce9efa23709ff4bf7a78acebe808ddf7c826e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64dce9efa23709ff4bf7a78acebe808ddf7c826e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9e27770e111957652027b62e387997fe86166d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9e27770e111957652027b62e387997fe86166d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9e27770e111957652027b62e387997fe86166d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9e27770e111957652027b62e387997fe86166d3/comments", "author": null, "committer": null, "parents": [{"sha": "fa0f39e4cac56ac11ae8faa905c3bd5f5da6be92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa0f39e4cac56ac11ae8faa905c3bd5f5da6be92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa0f39e4cac56ac11ae8faa905c3bd5f5da6be92"}], "stats": {"total": 99, "additions": 54, "deletions": 45}, "files": [{"sha": "b79b6a19b41a6990a3f9013b55756b6e94fa85af", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 54, "deletions": 45, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9e27770e111957652027b62e387997fe86166d3/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9e27770e111957652027b62e387997fe86166d3/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=a9e27770e111957652027b62e387997fe86166d3", "patch": "@@ -41,7 +41,7 @@ Boston, MA 02111-1307, USA.  */\n    This is used in v8 code when calling a function that returns a structure.\n    v9 doesn't have this.  */\n \n-#define SKIP_CALLERS_UNIMP_P (!TARGET_V9 && current_function_returns_struct)\n+#define SKIP_CALLERS_UNIMP_P (!TARGET_ARCH64 && current_function_returns_struct)\n \n /* Global variables for machine-dependent things.  */\n \n@@ -123,7 +123,7 @@ sparc_override_options ()\n   /* Check for any conflicts in the choice of options.  */\n   /* ??? This stuff isn't really usable yet.  */\n \n-  if (! TARGET_V9)\n+  if (! TARGET_ARCH64)\n     {\n       if (target_flags & MASK_CODE_MODEL)\n \terror (\"code model support is only available with -mv9\");\n@@ -133,8 +133,6 @@ sparc_override_options ()\n \terror (\"-mlong64 is only available with -mv9\");\n       if (TARGET_PTR64)\n \terror (\"-mptr64 is only available with -mv9\");\n-      if (TARGET_ENV32)\n-\terror (\"-menv32 is only available with -mv9\");\n       if (TARGET_STACK_BIAS)\n \terror (\"-mstack-bias is only available with -mv9\");\n     }\n@@ -242,7 +240,7 @@ intreg_operand (op, mode)\n      enum machine_mode mode;\n {\n   return (register_operand (op, SImode)\n-\t  || (TARGET_V9 && register_operand (op, DImode)));\n+\t  || (TARGET_ARCH64 && register_operand (op, DImode)));\n }\n \n /* Nonzero if OP is a floating point condition code register.  */\n@@ -653,11 +651,11 @@ arith_double_operand (op, mode)\n {\n   return (register_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && SMALL_INT (op))\n-\t  || (! TARGET_V9\n+\t  || (! TARGET_ARCH64\n \t      && GET_CODE (op) == CONST_DOUBLE\n \t      && (unsigned) (CONST_DOUBLE_LOW (op) + 0x1000) < 0x2000\n \t      && (unsigned) (CONST_DOUBLE_HIGH (op) + 0x1000) < 0x2000)\n-\t  || (TARGET_V9\n+\t  || (TARGET_ARCH64\n \t      && GET_CODE (op) == CONST_DOUBLE\n \t      && (unsigned) (CONST_DOUBLE_LOW (op) + 0x1000) < 0x2000\n \t      && ((CONST_DOUBLE_HIGH (op) == -1\n@@ -854,8 +852,7 @@ gen_compare_reg (code, x, y)\n    use the \"movrCC\" insns. This reduces the generated code from three to two\n    insns.  This way seems too brute force though.  Is there a more elegant way\n    to achieve the same effect?\n-\n-   Currently, this function always returns 1.  ??? Can it ever fail?  */\n+*/\n \n int\n gen_v9_scc (compare_code, operands)\n@@ -864,11 +861,18 @@ gen_v9_scc (compare_code, operands)\n {\n   rtx temp;\n \n-  if (GET_MODE_CLASS (GET_MODE (sparc_compare_op0)) == MODE_INT\n+  /* It might be that we'll never be called if this is true,\n+     but keep this here for documentation at least.  */\n+  if (! TARGET_ARCH64\n+      && (GET_MODE (sparc_compare_op0) == DImode\n+\t  || GET_MODE (operands[0]) == DImode))\n+    return 0;\n+\n+  /* Try to use the movrCC insns.  */\n+  if (TARGET_ARCH64\n+      && GET_MODE_CLASS (GET_MODE (sparc_compare_op0)) == MODE_INT\n       && sparc_compare_op1 == const0_rtx\n-      && (compare_code == EQ || compare_code == NE\n-\t  || compare_code == LT || compare_code == LE\n-\t  || compare_code == GT || compare_code == GE))\n+      && v9_regcmp_p (compare_code))\n     {\n       /* Special case for op0 != 0.  This can be done with one instruction if\n \t op0 can be clobbered.  We store to a temp, and then clobber the temp,\n@@ -1385,7 +1389,7 @@ emit_move_sequence (operands, mode)\n \t  rtx temp = ((reload_in_progress || mode == DImode)\n \t\t      ? operand0 : gen_reg_rtx (mode));\n \n-\t  if (TARGET_V9 && mode == DImode)\n+\t  if (TARGET_ARCH64 && mode == DImode)\n \t    {\n \t      int high_operand = 0;\n \n@@ -1629,7 +1633,7 @@ output_move_double (operands)\n     latehalf[1] = adj_offsettable_operand (op1, 4);\n   else if (optype1 == CNSTOP)\n     {\n-      if (TARGET_V9)\n+      if (TARGET_ARCH64)\n \t{\n \t  if (arith_double_operand (op1, DImode))\n \t    {\n@@ -1657,9 +1661,9 @@ output_move_double (operands)\n   /* Easy case: try moving both words at once.  Check for moving between\n      an even/odd register pair and a memory location.  */\n   if ((optype0 == REGOP && optype1 != REGOP && optype1 != CNSTOP\n-       && (TARGET_V9 || (REGNO (op0) & 1) == 0))\n+       && (TARGET_ARCH64 || (REGNO (op0) & 1) == 0))\n       || (optype0 != REGOP && optype0 != CNSTOP && optype1 == REGOP\n-\t  && (TARGET_V9 || (REGNO (op1) & 1) == 0)))\n+\t  && (TARGET_ARCH64 || (REGNO (op1) & 1) == 0)))\n     {\n       register rtx mem,reg;\n \n@@ -1678,14 +1682,14 @@ output_move_double (operands)\n \t     the register number.  */\n \t  || (TARGET_V9 && REGNO (reg) >= 64))\n \t{\n-\t  if (FP_REG_P (reg) || ! TARGET_V9)\n+\t  if (FP_REG_P (reg) || ! TARGET_ARCH64)\n \t    return (mem == op1 ? \"ldd %1,%0\" : \"std %1,%0\");\n \t  else\n \t    return (mem == op1 ? \"ldx %1,%0\" : \"stx %1,%0\");\n \t}\n     }\n \n-  if (TARGET_V9)\n+  if (TARGET_ARCH64)\n     {\n       if (optype0 == REGOP && optype1 == REGOP)\n \t{\n@@ -1917,9 +1921,9 @@ output_move_quad (operands)\n \t    }\n \t  operands[2] = adj_offsettable_operand (mem, 8);\n \t  if (mem == op1)\n-\t    return TARGET_V9 ? \"ldx %1,%0;ldx %2,%R0\" : \"ldd %1,%0;ldd %2,%S0\";\n+\t    return TARGET_ARCH64 ? \"ldx %1,%0;ldx %2,%R0\" : \"ldd %1,%0;ldd %2,%S0\";\n \t  else\n-\t    return TARGET_V9 ? \"stx %1,%0;stx %R1,%2\" : \"std %1,%0;std %S1,%2\";\n+\t    return TARGET_ARCH64 ? \"stx %1,%0;stx %R1,%2\" : \"std %1,%0;std %S1,%2\";\n \t}\n     }\n \n@@ -2300,7 +2304,7 @@ output_block_move (operands)\n       if (align > UNITS_PER_WORD)\n \tabort ();\n \n-      if (TARGET_V9 && align >= 8)\n+      if (TARGET_ARCH64 && align >= 8)\n \t{\n \t  for (i = (size >> 3) - 1; i >= 0; i--)\n \t    {\n@@ -2421,9 +2425,9 @@ output_block_move (operands)\n   {\n     char pattern[200];\n     register char *ld_suffix = ((align == 1) ? \"ub\" : (align == 2) ? \"uh\"\n-\t\t\t\t: (align == 8 && TARGET_V9) ? \"x\" : \"\");\n+\t\t\t\t: (align == 8 && TARGET_ARCH64) ? \"x\" : \"\");\n     register char *st_suffix = ((align == 1) ? \"b\" : (align == 2) ? \"h\"\n-\t\t\t\t: (align == 8 && TARGET_V9) ? \"x\" : \"\");\n+\t\t\t\t: (align == 8 && TARGET_ARCH64) ? \"x\" : \"\");\n \n     sprintf (pattern, \"ld%s [%%1+%%2],%%%%g1\\n\\tsubcc %%2,%%4,%%2\\n\\tbge %s\\n\\tst%s %%%%g1,[%%0+%%2]\\n%s:\", ld_suffix, &label3[1], st_suffix, &label5[1]);\n     output_asm_insn (pattern, xoperands);\n@@ -2596,6 +2600,16 @@ static int hard_32bit_mode_classes[] = {\n   TF_MODES, SF_MODES, DF_MODES, SF_MODES, TF_MODES, SF_MODES, DF_MODES, SF_MODES,\n   TF_MODES, SF_MODES, DF_MODES, SF_MODES, TF_MODES, SF_MODES, DF_MODES, SF_MODES,\n   TF_MODES, SF_MODES, DF_MODES, SF_MODES, TF_MODES, SF_MODES, DF_MODES, SF_MODES,\n+\n+  /* FP regs f32 to f63.  Only the even numbered registers actually exist,\n+     and none can hold SFmode/SImode values.  */\n+  DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n+  DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n+  DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n+  DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n+\n+  /* %fcc[0123] */\n+  CCFP_MODE, CCFP_MODE, CCFP_MODE, CCFP_MODE\n };\n \n static int hard_64bit_mode_classes[] = {\n@@ -2609,8 +2623,7 @@ static int hard_64bit_mode_classes[] = {\n   TF_MODES64, SF_MODES, DF_MODES64, SF_MODES, TF_MODES64, SF_MODES, DF_MODES64, SF_MODES,\n   TF_MODES64, SF_MODES, DF_MODES64, SF_MODES, TF_MODES64, SF_MODES, DF_MODES64, SF_MODES,\n \n-  /* The remaining registers do not exist on a non-v9 sparc machine.\n-     FP regs f32 to f63.  Only the even numbered registers actually exist,\n+  /* FP regs f32 to f63.  Only the even numbered registers actually exist,\n      and none can hold SFmode/SImode values.  */\n   DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n   DF_UP_MODES, 0, DF_ONLY_MODES, 0, DF_UP_MODES, 0, DF_ONLY_MODES, 0,\n@@ -2628,7 +2641,7 @@ sparc_init_modes ()\n {\n   int i;\n \n-  sparc_arch_type = TARGET_V9 ? ARCH_64BIT : ARCH_32BIT;\n+  sparc_arch_type = TARGET_ARCH64 ? ARCH_64BIT : ARCH_32BIT;\n \n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n     {\n@@ -2668,19 +2681,15 @@ sparc_init_modes ()\n \t  if (i == (int) CCFPmode || i == (int) CCFPEmode)\n \t    sparc_mode_class[i] = 1 << (int) CCFP_MODE;\n \t  else if (i == (int) CCmode || i == (int) CC_NOOVmode\n-#ifdef SPARCV9\n-\t\t   || i == (int) CCXmode\n-\t\t   || i == (int) CCX_NOOVmode\n-#endif\n-\t\t   )\n+\t\t   || i == (int) CCXmode || i == (int) CCX_NOOVmode)\n \t    sparc_mode_class[i] = 1 << (int) C_MODE;\n \t  else\n \t    sparc_mode_class[i] = 0;\n \t  break;\n \t}\n     }\n \n-  if (TARGET_V9)\n+  if (TARGET_ARCH64)\n     hard_regno_mode_classes = hard_64bit_mode_classes;\n   else\n     hard_regno_mode_classes = hard_32bit_mode_classes;\n@@ -2703,7 +2712,7 @@ save_regs (file, low, high, base, offset, n_regs)\n {\n   int i;\n \n-  if (TARGET_V9 && high <= 32)\n+  if (TARGET_ARCH64 && high <= 32)\n     {\n       for (i = low; i < high; i++)\n \t{\n@@ -2753,7 +2762,7 @@ restore_regs (file, low, high, base, offset, n_regs)\n {\n   int i;\n \n-  if (TARGET_V9 && high <= 32)\n+  if (TARGET_ARCH64 && high <= 32)\n     {\n       for (i = low; i < high; i++)\n \t{\n@@ -2801,7 +2810,7 @@ compute_frame_size (size, leaf_function)\n {\n   int n_regs = 0, i;\n   int outgoing_args_size = (current_function_outgoing_args_size\n-#ifndef SPARCV9\n+#if ! SPARC_ARCH64\n \t\t\t    + REG_PARM_STACK_SPACE (current_function_decl)\n #endif\n \t\t\t    );\n@@ -2811,7 +2820,7 @@ compute_frame_size (size, leaf_function)\n       /* N_REGS is the number of 4-byte regs saved thus far.  This applies\n \t even to v9 int regs to be consistent with save_regs/restore_regs.  */\n \n-      if (TARGET_V9)\n+      if (TARGET_ARCH64)\n \t{\n \t  for (i = 0; i < 8; i++)\n \t    if (regs_ever_live[i] && ! call_used_regs[i])\n@@ -2868,13 +2877,13 @@ build_big_number (file, num, reg)\n      int num;\n      char *reg;\n {\n-  if (num >= 0 || ! TARGET_V9)\n+  if (num >= 0 || ! TARGET_ARCH64)\n     {\n       fprintf (file, \"\\tsethi %%hi(%d),%s\\n\", num, reg);\n       if ((num & 0x3ff) != 0)\n \tfprintf (file, \"\\tor %s,%%lo(%d),%s\\n\", reg, num, reg);\n     }\n-  else /* num < 0 && TARGET_V9 */\n+  else /* num < 0 && TARGET_ARCH64 */\n     {\n       /* Sethi does not sign extend, so we must use a little trickery\n \t to use it for negative numbers.  Invert the constant before\n@@ -3112,10 +3121,10 @@ output_function_epilogue (file, size, leaf_function)\n    is used and return the address of the first unnamed parameter.\n    v9: We save the argument integer and floating point regs in a buffer, and\n    return the address of this buffer.  The rest is handled in va-sparc.h.  */\n-/* ??? This is currently conditioned on #ifdef SPARCV9 because\n+/* ??? This is currently conditioned on SPARC_ARCH64 because\n    current_function_args_info is different in each compiler.  */\n \n-#ifdef SPARCV9\n+#if SPARC_ARCH64\n \n rtx\n sparc_builtin_saveregs (arglist)\n@@ -3186,7 +3195,7 @@ sparc_builtin_saveregs (arglist)\n   return XEXP (regbuf, 0);\n }\n \n-#else /* ! SPARCV9 */\n+#else /* ! SPARC_ARCH64 */\n \n rtx\n sparc_builtin_saveregs (arglist)\n@@ -3223,7 +3232,7 @@ sparc_builtin_saveregs (arglist)\n   return address;\n }\n \n-#endif /* ! SPARCV9 */\n+#endif /* ! SPARC_ARCH64 */\n \f\n /* Return the string to output a conditional branch to LABEL, which is\n    the operand number of the label.  OP is the conditional expression.  The\n@@ -3903,12 +3912,12 @@ output_double_int (file, value)\n   else if (GET_CODE (value) == SYMBOL_REF\n \t   || GET_CODE (value) == CONST\n \t   || GET_CODE (value) == PLUS\n-\t   || (TARGET_V9 &&\n+\t   || (TARGET_ARCH64 &&\n \t       (GET_CODE (value) == LABEL_REF\n \t\t|| GET_CODE (value) == CODE_LABEL\n \t\t|| GET_CODE (value) == MINUS)))\n     {\n-      if (!TARGET_V9 || TARGET_ENV32)\n+      if (!TARGET_V9 || TARGET_MEDLOW)\n \t{\n \t  ASM_OUTPUT_INT (file, const0_rtx);\n \t  ASM_OUTPUT_INT (file, value);"}]}