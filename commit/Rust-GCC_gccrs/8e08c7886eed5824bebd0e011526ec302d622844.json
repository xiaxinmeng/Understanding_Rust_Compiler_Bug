{"sha": "8e08c7886eed5824bebd0e011526ec302d622844", "node_id": "C_kwDOANBUbNoAKDhlMDhjNzg4NmVlZDU4MjRiZWJkMGUwMTE1MjZlYzMwMmQ2MjI4NDQ", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2023-04-17T10:59:51Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2023-04-17T11:04:49Z"}, "message": "ipa: Fix double reference-count decrements for the same edge (PR 107769, PR 109318)\n\nIt turns out that since addition of the code that can identify globals\nwhich are only read from, the code that keeps track of the references\ncan decrement their count for the same calls, once during IPA-CP and\nthen again during inlining.  Fixed by adding a special flag to the\npass-through variant and simply wiping out the reference to the\nrefdesc structure from the constant ones.\n\nMoreover, during debugging of the issue I have discovered that the\ncode removing references could remove a reference associated with the\nsame statement but of a wrong type.  In all cases it wanted to remove\nan IPA_REF_ADDR reference so removing a lesser one instead should do\nno harm in practice, but we should try to be consistent and so this\npatch extends symtab_node::find_reference so that it searches for a\nreference of a given type only.\n\ngcc/ChangeLog:\n\n2023-04-14  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/107769\n\tPR ipa/109318\n\t* cgraph.h (symtab_node::find_reference): Add parameter use_type.\n\t* ipa-prop.h (ipa_pass_through_data): New flag refdesc_decremented.\n\t(ipa_zap_jf_refdesc): New function.\n\t(ipa_get_jf_pass_through_refdesc_decremented): Likewise.\n\t(ipa_set_jf_pass_through_refdesc_decremented): Likewise.\n\t* ipa-cp.cc (ipcp_discover_new_direct_edges): Provide a value for\n\tthe new parameter of find_reference.\n\t(adjust_references_in_caller): Likewise. Make sure the constant jump\n\tfunction is not used to decrement a refdec counter again.  Only\n\tdecrement refdesc counters when the pass_through jump function allows\n\tit.  Added a detailed dump when decrementing refdesc counters.\n\t* ipa-prop.cc (ipa_print_node_jump_functions_for_edge): Dump new flag.\n\t(ipa_set_jf_simple_pass_through): Initialize the new flag.\n\t(ipa_set_jf_unary_pass_through): Likewise.\n\t(ipa_set_jf_arith_pass_through): Likewise.\n\t(remove_described_reference): Provide a value for the new parameter of\n\tfind_reference.\n\t(update_jump_functions_after_inlining): Zap refdesc of new jfunc if\n\tthe previous pass_through had a flag mandating that we do so.\n\t(propagate_controlled_uses): Likewise.  Only decrement refdesc\n\tcounters when the pass_through jump function allows it.\n\t(ipa_edge_args_sum_t::duplicate): Provide a value for the new\n\tparameter of find_reference.\n\t(ipa_write_jump_function): Assert the new flag does not have to be\n\tstreamed.\n\t* symtab.cc (symtab_node::find_reference): Add parameter use_type, use\n\tit in searching.\n\ngcc/testsuite/ChangeLog:\n\n2023-04-06  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/107769\n\tPR ipa/109318\n\t* gcc.dg/ipa/pr109318.c: New test.\n\t* gcc.dg/lto/pr107769_0.c: Likewise.", "tree": {"sha": "3e5654b8eac97fa1f39e30e9a65e0abc3ad86d32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e5654b8eac97fa1f39e30e9a65e0abc3ad86d32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e08c7886eed5824bebd0e011526ec302d622844", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmQ9J9EACgkQv2PBvD+k\nNUDmlQ/+LOdR5jOVd7f02j2/KvK7nf6FtiPuJE1S8/Hm2Ea28zTUaqut+L8m4qn+\nJdo82xrUrOMZkcQkIcf55/gaIu+KIcEQ8neWmVRlmOXO1fip98v6Oqxnzp//zQo+\nxtuVUoZmEzYR8NvLVWojI1Ri4A1J5Yv5eDOp7NXQJlFy+xE0GNCf+UMxGFV7MjTY\nqd3nqHIq5nGwbd+S6WzZiGZ8ekNzV48mIuTUUm0Aup8QtcfGIMoXlmhzt/ktjWi2\nbkHP+wVli7SJiK4CeXZ22lOOMBD+ebeN6pP1p/6PO/jwk+OpOoOn5V2/lge1408t\nVw+XFt21lkSolNUwdsvRFHRjHj9lQb4hMetLACthxGvhB5c1ayCzuXmdY/Mwwfg+\nezjOkFBQNsx14jqxxOUmxdHRP6rnplZfwHUpM4PIwO8nk3SzzxWjyKFTWWKV7937\np+rEA6m6/5LFgb++WjEqxjFoHhIwpo+fpuhvVIuTTUwAR3r4kfkptZJ2MB2obBUM\nsszKqG/HMYsj7dufjdNlp9m95CLbn9l+2CKRsJOzdL4iVAPKp84QjYuqIkXrvwoG\n76Y2C7GxF2SZTJUf06BuLQjJoeHi6g76Dy0q2ECNGesu6gloEORX2dS9ThA9KbRu\ntupTAoRLktoOblOISLwVb2D1fe5gn2IBx4uCDzeMrwd41yRmOg0=\n=/MmZ\n-----END PGP SIGNATURE-----", "payload": "tree 3e5654b8eac97fa1f39e30e9a65e0abc3ad86d32\nparent f200c56787f2c6f93ffb739d57d01a294ab72f68\nauthor Martin Jambor <mjambor@suse.cz> 1681729191 +0200\ncommitter Martin Jambor <mjambor@suse.cz> 1681729489 +0200\n\nipa: Fix double reference-count decrements for the same edge (PR 107769, PR 109318)\n\nIt turns out that since addition of the code that can identify globals\nwhich are only read from, the code that keeps track of the references\ncan decrement their count for the same calls, once during IPA-CP and\nthen again during inlining.  Fixed by adding a special flag to the\npass-through variant and simply wiping out the reference to the\nrefdesc structure from the constant ones.\n\nMoreover, during debugging of the issue I have discovered that the\ncode removing references could remove a reference associated with the\nsame statement but of a wrong type.  In all cases it wanted to remove\nan IPA_REF_ADDR reference so removing a lesser one instead should do\nno harm in practice, but we should try to be consistent and so this\npatch extends symtab_node::find_reference so that it searches for a\nreference of a given type only.\n\ngcc/ChangeLog:\n\n2023-04-14  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/107769\n\tPR ipa/109318\n\t* cgraph.h (symtab_node::find_reference): Add parameter use_type.\n\t* ipa-prop.h (ipa_pass_through_data): New flag refdesc_decremented.\n\t(ipa_zap_jf_refdesc): New function.\n\t(ipa_get_jf_pass_through_refdesc_decremented): Likewise.\n\t(ipa_set_jf_pass_through_refdesc_decremented): Likewise.\n\t* ipa-cp.cc (ipcp_discover_new_direct_edges): Provide a value for\n\tthe new parameter of find_reference.\n\t(adjust_references_in_caller): Likewise. Make sure the constant jump\n\tfunction is not used to decrement a refdec counter again.  Only\n\tdecrement refdesc counters when the pass_through jump function allows\n\tit.  Added a detailed dump when decrementing refdesc counters.\n\t* ipa-prop.cc (ipa_print_node_jump_functions_for_edge): Dump new flag.\n\t(ipa_set_jf_simple_pass_through): Initialize the new flag.\n\t(ipa_set_jf_unary_pass_through): Likewise.\n\t(ipa_set_jf_arith_pass_through): Likewise.\n\t(remove_described_reference): Provide a value for the new parameter of\n\tfind_reference.\n\t(update_jump_functions_after_inlining): Zap refdesc of new jfunc if\n\tthe previous pass_through had a flag mandating that we do so.\n\t(propagate_controlled_uses): Likewise.  Only decrement refdesc\n\tcounters when the pass_through jump function allows it.\n\t(ipa_edge_args_sum_t::duplicate): Provide a value for the new\n\tparameter of find_reference.\n\t(ipa_write_jump_function): Assert the new flag does not have to be\n\tstreamed.\n\t* symtab.cc (symtab_node::find_reference): Add parameter use_type, use\n\tit in searching.\n\ngcc/testsuite/ChangeLog:\n\n2023-04-06  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/107769\n\tPR ipa/109318\n\t* gcc.dg/ipa/pr109318.c: New test.\n\t* gcc.dg/lto/pr107769_0.c: Likewise.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e08c7886eed5824bebd0e011526ec302d622844", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e08c7886eed5824bebd0e011526ec302d622844", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e08c7886eed5824bebd0e011526ec302d622844/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f200c56787f2c6f93ffb739d57d01a294ab72f68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f200c56787f2c6f93ffb739d57d01a294ab72f68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f200c56787f2c6f93ffb739d57d01a294ab72f68"}], "stats": {"total": 160, "additions": 143, "deletions": 17}, "files": [{"sha": "f5f54769edaa4e5d10e95ac8ded1409bfea8489d", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e08c7886eed5824bebd0e011526ec302d622844/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e08c7886eed5824bebd0e011526ec302d622844/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=8e08c7886eed5824bebd0e011526ec302d622844", "patch": "@@ -196,10 +196,11 @@ struct GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Clone reference REF to this symtab_node and set its stmt to STMT.  */\n   ipa_ref *clone_reference (ipa_ref *ref, gimple *stmt);\n \n-  /* Find the structure describing a reference to REFERRED_NODE\n-     and associated with statement STMT.  */\n+  /* Find the structure describing a reference to REFERRED_NODE of USE_TYPE and\n+     associated with statement STMT or LTO_STMT_UID.  */\n   ipa_ref *find_reference (symtab_node *referred_node, gimple *stmt,\n-\t\t\t   unsigned int lto_stmt_uid);\n+\t\t\t   unsigned int lto_stmt_uid,\n+\t\t\t   enum ipa_ref_use use_type);\n \n   /* Remove all references that are associated with statement STMT.  */\n   void remove_stmt_references (gimple *stmt);"}, {"sha": "b3e0f62e400359ff901997b73fcee32982d85a47", "filename": "gcc/ipa-cp.cc", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e08c7886eed5824bebd0e011526ec302d622844/gcc%2Fipa-cp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e08c7886eed5824bebd0e011526ec302d622844/gcc%2Fipa-cp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.cc?ref=8e08c7886eed5824bebd0e011526ec302d622844", "patch": "@@ -4348,7 +4348,8 @@ ipcp_discover_new_direct_edges (struct cgraph_node *node,\n \t\t    fprintf (dump_file, \"     controlled uses count of param \"\n \t\t\t     \"%i bumped down to %i\\n\", param_index, c);\n \t\t  if (c == 0\n-\t\t      && (to_del = node->find_reference (cs->callee, NULL, 0)))\n+\t\t      && (to_del = node->find_reference (cs->callee, NULL, 0,\n+\t\t\t\t\t\t\t IPA_REF_ADDR)))\n \t\t    {\n \t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t\tfprintf (dump_file, \"       and even removing its \"\n@@ -5180,18 +5181,21 @@ adjust_references_in_caller (cgraph_edge *cs, symtab_node *symbol, int index)\n   if (jfunc->type == IPA_JF_CONST)\n     {\n       ipa_ref *to_del = cs->caller->find_reference (symbol, cs->call_stmt,\n-\t\t\t\t\t\t    cs->lto_stmt_uid);\n+\t\t\t\t\t\t    cs->lto_stmt_uid,\n+\t\t\t\t\t\t    IPA_REF_ADDR);\n       if (!to_del)\n \treturn;\n       to_del->remove_reference ();\n+      ipa_zap_jf_refdesc (jfunc);\n       if (dump_file)\n \tfprintf (dump_file, \"    Removed a reference from %s to %s.\\n\",\n \t\t cs->caller->dump_name (), symbol->dump_name ());\n       return;\n     }\n \n   if (jfunc->type != IPA_JF_PASS_THROUGH\n-      || ipa_get_jf_pass_through_operation (jfunc) != NOP_EXPR)\n+      || ipa_get_jf_pass_through_operation (jfunc) != NOP_EXPR\n+      || ipa_get_jf_pass_through_refdesc_decremented (jfunc))\n     return;\n \n   int fidx = ipa_get_jf_pass_through_formal_id (jfunc);\n@@ -5218,15 +5222,19 @@ adjust_references_in_caller (cgraph_edge *cs, symtab_node *symbol, int index)\n   gcc_assert (cuses > 0);\n   cuses--;\n   ipa_set_controlled_uses (caller_info, fidx, cuses);\n+  ipa_set_jf_pass_through_refdesc_decremented (jfunc, true);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"    Controlled uses of parameter %i of %s dropped \"\n+\t     \"to %i.\\n\", fidx, caller->dump_name (), cuses);\n   if (cuses)\n     return;\n \n   if (caller_info->ipcp_orig_node)\n     {\n       /* Cloning machinery has created a reference here, we need to either\n \t remove it or change it to a read one.  */\n-      ipa_ref *to_del = caller->find_reference (symbol, NULL, 0);\n-      if (to_del && to_del->use == IPA_REF_ADDR)\n+      ipa_ref *to_del = caller->find_reference (symbol, NULL, 0, IPA_REF_ADDR);\n+      if (to_del)\n \t{\n \t  to_del->remove_reference ();\n \t  if (dump_file)"}, {"sha": "0d8167495341f7c8416e24e209588f7b6e9d1135", "filename": "gcc/ipa-prop.cc", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e08c7886eed5824bebd0e011526ec302d622844/gcc%2Fipa-prop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e08c7886eed5824bebd0e011526ec302d622844/gcc%2Fipa-prop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.cc?ref=8e08c7886eed5824bebd0e011526ec302d622844", "patch": "@@ -347,6 +347,8 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \t    }\n \t  if (jump_func->value.pass_through.agg_preserved)\n \t    fprintf (f, \", agg_preserved\");\n+\t  if (jump_func->value.pass_through.refdesc_decremented)\n+\t    fprintf (f, \", refdesc_decremented\");\n \t  fprintf (f, \"\\n\");\n \t}\n       else if (type == IPA_JF_ANCESTOR)\n@@ -572,6 +574,7 @@ ipa_set_jf_simple_pass_through (struct ipa_jump_func *jfunc, int formal_id,\n   jfunc->value.pass_through.formal_id = formal_id;\n   jfunc->value.pass_through.operation = NOP_EXPR;\n   jfunc->value.pass_through.agg_preserved = agg_preserved;\n+  jfunc->value.pass_through.refdesc_decremented = false;\n }\n \n /* Set JFUNC to be an unary pass through jump function.  */\n@@ -585,6 +588,7 @@ ipa_set_jf_unary_pass_through (struct ipa_jump_func *jfunc, int formal_id,\n   jfunc->value.pass_through.formal_id = formal_id;\n   jfunc->value.pass_through.operation = operation;\n   jfunc->value.pass_through.agg_preserved = false;\n+  jfunc->value.pass_through.refdesc_decremented = false;\n }\n /* Set JFUNC to be an arithmetic pass through jump function.  */\n \n@@ -597,6 +601,7 @@ ipa_set_jf_arith_pass_through (struct ipa_jump_func *jfunc, int formal_id,\n   jfunc->value.pass_through.formal_id = formal_id;\n   jfunc->value.pass_through.operation = operation;\n   jfunc->value.pass_through.agg_preserved = false;\n+  jfunc->value.pass_through.refdesc_decremented = false;\n }\n \n /* Set JFUNC to be an ancestor jump function.  */\n@@ -3314,7 +3319,13 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t\t  ipa_set_jf_unknown (dst);\n \t\t  break;\n \t\tcase IPA_JF_CONST:\n-\t\t  ipa_set_jf_cst_copy (dst, src);\n+\t\t  {\n+\t\t    bool rd = ipa_get_jf_pass_through_refdesc_decremented (dst);\n+\t\t    ipa_set_jf_cst_copy (dst, src);\n+\t\t    if (rd)\n+\t\t      ipa_zap_jf_refdesc (dst);\n+\t\t  }\n+\n \t\t  break;\n \n \t\tcase IPA_JF_PASS_THROUGH:\n@@ -3671,7 +3682,7 @@ remove_described_reference (symtab_node *symbol, struct ipa_cst_ref_desc *rdesc)\n   if (!origin)\n     return false;\n   to_del = origin->caller->find_reference (symbol, origin->call_stmt,\n-\t\t\t\t\t   origin->lto_stmt_uid);\n+\t\t\t\t\t   origin->lto_stmt_uid, IPA_REF_ADDR);\n   if (!to_del)\n     return false;\n \n@@ -4130,7 +4141,8 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n       struct ipa_jump_func *jf = ipa_get_ith_jump_func (args, i);\n       struct ipa_cst_ref_desc *rdesc;\n \n-      if (jf->type == IPA_JF_PASS_THROUGH)\n+      if (jf->type == IPA_JF_PASS_THROUGH\n+\t  && !ipa_get_jf_pass_through_refdesc_decremented (jf))\n \t{\n \t  int src_idx, c, d;\n \t  src_idx = ipa_get_jf_pass_through_formal_id (jf);\n@@ -4158,7 +4170,8 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t      if (t && TREE_CODE (t) == ADDR_EXPR\n \t\t  && TREE_CODE (TREE_OPERAND (t, 0)) == FUNCTION_DECL\n \t\t  && (n = cgraph_node::get (TREE_OPERAND (t, 0)))\n-\t\t  && (ref = new_root->find_reference (n, NULL, 0)))\n+\t\t  && (ref = new_root->find_reference (n, NULL, 0,\n+\t\t\t\t\t\t      IPA_REF_ADDR)))\n \t\t{\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"ipa-prop: Removing cloning-created \"\n@@ -4206,7 +4219,7 @@ propagate_controlled_uses (struct cgraph_edge *cs)\n \t\t\t && clone != rdesc->cs->caller)\n \t\t    {\n \t\t      struct ipa_ref *ref;\n-\t\t      ref = clone->find_reference (n, NULL, 0);\n+\t\t      ref = clone->find_reference (n, NULL, 0, IPA_REF_ADDR);\n \t\t      if (ref)\n \t\t\t{\n \t\t\t  if (dump_file)\n@@ -4432,7 +4445,8 @@ ipa_edge_args_sum_t::duplicate (cgraph_edge *src, cgraph_edge *dst,\n \t\t   gcc_checking_assert (n);\n \t\t   ipa_ref *ref\n \t\t     = src->caller->find_reference (n, src->call_stmt,\n-\t\t\t\t\t\t    src->lto_stmt_uid);\n+\t\t\t\t\t\t    src->lto_stmt_uid,\n+\t\t\t\t\t\t    IPA_REF_ADDR);\n \t\t   gcc_checking_assert (ref);\n \t\t   dst->caller->clone_reference (ref, ref->stmt);\n \n@@ -4692,6 +4706,7 @@ ipa_write_jump_function (struct output_block *ob,\n \t  streamer_write_uhwi (ob, jump_func->value.pass_through.formal_id);\n \t  bp = bitpack_create (ob->main_stream);\n \t  bp_pack_value (&bp, jump_func->value.pass_through.agg_preserved, 1);\n+\t  gcc_assert (!jump_func->value.pass_through.refdesc_decremented);\n \t  streamer_write_bitpack (&bp);\n \t}\n       else if (TREE_CODE_CLASS (jump_func->value.pass_through.operation)"}, {"sha": "7eb5c8f44ea5b6926edd00df9b229843ad8cd47f", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e08c7886eed5824bebd0e011526ec302d622844/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e08c7886eed5824bebd0e011526ec302d622844/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=8e08c7886eed5824bebd0e011526ec302d622844", "patch": "@@ -115,6 +115,9 @@ struct GTY(()) ipa_pass_through_data\n      ipa_agg_jump_function).  The flag is used only when the operation is\n      NOP_EXPR.  */\n   unsigned agg_preserved : 1;\n+  /* Set when the edge has already been used to decrement an appropriate\n+     reference description counter and should not be decremented again.  */\n+  unsigned refdesc_decremented : 1;\n };\n \n /* Structure holding data required to describe a load-value-from-aggregate\n@@ -362,6 +365,15 @@ ipa_get_jf_constant_rdesc (struct ipa_jump_func *jfunc)\n   return jfunc->value.constant.rdesc;\n }\n \n+/* Make JFUNC not participate in any further reference counting.  */\n+\n+inline void\n+ipa_zap_jf_refdesc (ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_CONST);\n+  jfunc->value.constant.rdesc = NULL;\n+}\n+\n /* Return the operand of a pass through jmp function JFUNC.  */\n \n inline tree\n@@ -399,6 +411,26 @@ ipa_get_jf_pass_through_agg_preserved (struct ipa_jump_func *jfunc)\n   return jfunc->value.pass_through.agg_preserved;\n }\n \n+/* Return the refdesc_decremented flag of a pass through jump function\n+   JFUNC.  */\n+\n+inline bool\n+ipa_get_jf_pass_through_refdesc_decremented (struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_PASS_THROUGH);\n+  return jfunc->value.pass_through.refdesc_decremented;\n+}\n+\n+/* Set the refdesc_decremented flag of a pass through jump function JFUNC to\n+   VALUE.  */\n+\n+inline void\n+ipa_set_jf_pass_through_refdesc_decremented (ipa_jump_func *jfunc, bool value)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_PASS_THROUGH);\n+  jfunc->value.pass_through.refdesc_decremented = value;\n+}\n+\n /* Return true if pass through jump function JFUNC preserves type\n    information.  */\n "}, {"sha": "0470509a98d2a4a9463444b248efafa0ff49906f", "filename": "gcc/symtab.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e08c7886eed5824bebd0e011526ec302d622844/gcc%2Fsymtab.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e08c7886eed5824bebd0e011526ec302d622844/gcc%2Fsymtab.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.cc?ref=8e08c7886eed5824bebd0e011526ec302d622844", "patch": "@@ -748,19 +748,21 @@ symtab_node::clone_reference (ipa_ref *ref, gimple *stmt)\n   return ref2;\n }\n \n-/* Find the structure describing a reference to REFERRED_NODE\n-   and associated with statement STMT.  */\n+/* Find the structure describing a reference to REFERRED_NODE of USE_TYPE and\n+   associated with statement STMT or LTO_STMT_UID.  */\n \n ipa_ref *\n symtab_node::find_reference (symtab_node *referred_node,\n-\t\t\t     gimple *stmt, unsigned int lto_stmt_uid)\n+\t\t\t     gimple *stmt, unsigned int lto_stmt_uid,\n+\t\t\t     enum ipa_ref_use use_type)\n {\n   ipa_ref *r = NULL;\n   int i;\n \n   for (i = 0; iterate_reference (i, r); i++)\n     if (r->referred == referred_node\n \t&& !r->speculative\n+\t&& r->use == use_type\n \t&& ((stmt && r->stmt == stmt)\n \t    || (lto_stmt_uid && r->lto_stmt_uid == lto_stmt_uid)\n \t    || (!stmt && !lto_stmt_uid && !r->stmt && !r->lto_stmt_uid)))"}, {"sha": "c5d9e3d12c7b1c637a37d1f5f8e709495e9a7426", "filename": "gcc/testsuite/gcc.dg/ipa/pr109318.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e08c7886eed5824bebd0e011526ec302d622844/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr109318.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e08c7886eed5824bebd0e011526ec302d622844/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr109318.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr109318.c?ref=8e08c7886eed5824bebd0e011526ec302d622844", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fno-early-inlining\" } */\n+\n+#pragma pack(1)\n+struct S {\n+  signed : 31;\n+  unsigned f4 : 20;\n+};\n+\n+static struct S global;\n+\n+static struct S func_16(struct S *ptr) { return *ptr; }\n+\n+int\n+main()\n+{\n+  struct S *local = &global;\n+  *local = func_16(local);\n+  return 0;\n+}"}, {"sha": "7a49ea625232d2d86f45bd531d1646510b696a8b", "filename": "gcc/testsuite/gcc.dg/lto/pr107769_0.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e08c7886eed5824bebd0e011526ec302d622844/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr107769_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e08c7886eed5824bebd0e011526ec302d622844/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr107769_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr107769_0.c?ref=8e08c7886eed5824bebd0e011526ec302d622844", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-lto-do run } */\n+/* { dg-lto-options { { -flto -O2 -finline-limit=150 } } } */\n+\n+[[gnu::noipa]]\n+void hjj (unsigned int lk)\n+{\n+    (void)lk;\n+}\n+void nn(int i, int n);\n+[[gnu::noinline]]\n+int ll(void) {\n+    return 1;\n+}\n+void hh(int* dest, int src)\n+{\n+    if (!ll() && !src)\n+        hjj(100);\n+    (*dest) = 1;\n+}\n+void gg(int* result, int x)\n+{\n+    if (x >= 0)\n+        return;\n+\n+    int xx;\n+    xx = *result;\n+    hh(result, ll());\n+    if (xx >= *result)\n+        nn(xx, *result);\n+}\n+void nn(int i, int n) {\n+    int T8_;\n+    if (n < 0)\n+        __builtin_exit(0);\n+    T8_ = 0;\n+    gg(&T8_, i);\n+    __builtin_exit(0);\n+}\n+void kk(int* x, int i) {\n+    hh(x, ll());\n+    if (i < 0 || i >= *x)\n+        nn(i,*x);\n+}\n+int g__r_1 = 0;\n+int main() {\n+    kk(&g__r_1, 0);\n+    return 0;\n+}"}]}