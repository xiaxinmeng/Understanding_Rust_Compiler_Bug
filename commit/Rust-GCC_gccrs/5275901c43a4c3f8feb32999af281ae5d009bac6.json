{"sha": "5275901c43a4c3f8feb32999af281ae5d009bac6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI3NTkwMWM0M2E0YzNmOGZlYjMyOTk5YWYyODFhZTVkMDA5YmFjNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-12-05T08:15:23Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-12-05T08:15:23Z"}, "message": "re PR middle-end/51323 (g++ confuses this with function argument in optimized call)\n\n\tPR middle-end/51323\n\tPR middle-end/50074\n\t* calls.c (internal_arg_pointer_exp_state): New variable.\n\t(internal_arg_pointer_based_exp_1,\n\tinternal_arg_pointer_exp_scan): New functions.\n\t(internal_arg_pointer_based_exp): New function.\n\t(mem_overlaps_already_clobbered_arg_p): Use it.\n\t(expand_call): Free internal_arg_pointer_exp_state.cache vector\n\tand clear internal_arg_pointer_exp_state.scan_start.\n\n\t* gcc.c-torture/execute/pr51323.c: New test.\n\nCo-Authored-By: Eric Botcazou <ebotcazou@adacore.com>\n\nFrom-SVN: r182000", "tree": {"sha": "94692863619a18f281ead69f54e9055cdfeffd93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94692863619a18f281ead69f54e9055cdfeffd93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5275901c43a4c3f8feb32999af281ae5d009bac6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5275901c43a4c3f8feb32999af281ae5d009bac6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5275901c43a4c3f8feb32999af281ae5d009bac6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5275901c43a4c3f8feb32999af281ae5d009bac6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2adac2a72b5a63a0e264bf7d345cd31edfe4e700", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2adac2a72b5a63a0e264bf7d345cd31edfe4e700", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2adac2a72b5a63a0e264bf7d345cd31edfe4e700"}], "stats": {"total": 201, "additions": 186, "deletions": 15}, "files": [{"sha": "296838111f8140ee3d51910a411b32d06f02de90", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5275901c43a4c3f8feb32999af281ae5d009bac6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5275901c43a4c3f8feb32999af281ae5d009bac6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5275901c43a4c3f8feb32999af281ae5d009bac6", "patch": "@@ -1,3 +1,16 @@\n+2011-12-05  Jakub Jelinek  <jakub@redhat.com>\n+\t    Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR middle-end/51323\n+\tPR middle-end/50074\n+\t* calls.c (internal_arg_pointer_exp_state): New variable.\n+\t(internal_arg_pointer_based_exp_1,\n+\tinternal_arg_pointer_exp_scan): New functions.\n+\t(internal_arg_pointer_based_exp): New function.\n+\t(mem_overlaps_already_clobbered_arg_p): Use it.\n+\t(expand_call): Free internal_arg_pointer_exp_state.cache vector\n+\tand clear internal_arg_pointer_exp_state.scan_start.\n+\n 2011-12-04  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/linux.h (TARGET_DEFAULT): Add MASK_SOFT_ATOMIC."}, {"sha": "95369b7baef9d913d2142c72020cb8b13f9f46de", "filename": "gcc/calls.c", "status": "modified", "additions": 131, "deletions": 15, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5275901c43a4c3f8feb32999af281ae5d009bac6/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5275901c43a4c3f8feb32999af281ae5d009bac6/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=5275901c43a4c3f8feb32999af281ae5d009bac6", "patch": "@@ -1658,6 +1658,129 @@ rtx_for_function_call (tree fndecl, tree addr)\n   return funexp;\n }\n \n+/* Internal state for internal_arg_pointer_based_exp and its helpers.  */\n+static struct\n+{\n+  /* Last insn that has been scanned by internal_arg_pointer_based_exp_scan,\n+     or NULL_RTX if none has been scanned yet.  */\n+  rtx scan_start;\n+  /* Vector indexed by REGNO - FIRST_PSEUDO_REGISTER, recording if a pseudo is\n+     based on crtl->args.internal_arg_pointer.  The element is NULL_RTX if the\n+     pseudo isn't based on it, a CONST_INT offset if the pseudo is based on it\n+     with fixed offset, or PC if this is with variable or unknown offset.  */\n+  VEC(rtx, heap) *cache;\n+} internal_arg_pointer_exp_state;\n+\n+static rtx internal_arg_pointer_based_exp (rtx, bool);\n+\n+/* Helper function for internal_arg_pointer_based_exp.  Scan insns in\n+   the tail call sequence, starting with first insn that hasn't been\n+   scanned yet, and note for each pseudo on the LHS whether it is based\n+   on crtl->args.internal_arg_pointer or not, and what offset from that\n+   that pointer it has.  */\n+\n+static void\n+internal_arg_pointer_based_exp_scan (void)\n+{\n+  rtx insn, scan_start = internal_arg_pointer_exp_state.scan_start;\n+\n+  if (scan_start == NULL_RTX)\n+    insn = get_insns ();\n+  else\n+    insn = NEXT_INSN (scan_start);\n+\n+  while (insn)\n+    {\n+      rtx set = single_set (insn);\n+      if (set && REG_P (SET_DEST (set)) && !HARD_REGISTER_P (SET_DEST (set)))\n+\t{\n+\t  rtx val = NULL_RTX;\n+\t  unsigned int idx = REGNO (SET_DEST (set)) - FIRST_PSEUDO_REGISTER;\n+\t  /* Punt on pseudos set multiple times.  */\n+\t  if (idx < VEC_length (rtx, internal_arg_pointer_exp_state.cache)\n+\t      && (VEC_index (rtx, internal_arg_pointer_exp_state.cache, idx)\n+\t\t  != NULL_RTX))\n+\t    val = pc_rtx;\n+\t  else\n+\t    val = internal_arg_pointer_based_exp (SET_SRC (set), false);\n+\t  if (val != NULL_RTX)\n+\t    {\n+\t      VEC_safe_grow_cleared (rtx, heap,\n+\t\t\t\t     internal_arg_pointer_exp_state.cache,\n+\t\t\t\t     idx + 1);\n+\t      VEC_replace (rtx, internal_arg_pointer_exp_state.cache,\n+\t\t\t   idx, val);\n+\t    }\n+\t}\n+      if (NEXT_INSN (insn) == NULL_RTX)\n+\tscan_start = insn;\n+      insn = NEXT_INSN (insn);\n+    }\n+\n+  internal_arg_pointer_exp_state.scan_start = scan_start;\n+}\n+\n+/* Helper function for internal_arg_pointer_based_exp, called through\n+   for_each_rtx.  Return 1 if *LOC is a register based on\n+   crtl->args.internal_arg_pointer.  Return -1 if *LOC is not based on it\n+   and the subexpressions need not be examined.  Otherwise return 0.  */\n+\n+static int\n+internal_arg_pointer_based_exp_1 (rtx *loc, void *data ATTRIBUTE_UNUSED)\n+{\n+  if (REG_P (*loc) && internal_arg_pointer_based_exp (*loc, false) != NULL_RTX)\n+    return 1;\n+  if (MEM_P (*loc))\n+    return -1;\n+  return 0;\n+}\n+\n+/* Compute whether RTL is based on crtl->args.internal_arg_pointer.  Return\n+   NULL_RTX if RTL isn't based on it, a CONST_INT offset if RTL is based on\n+   it with fixed offset, or PC if this is with variable or unknown offset.\n+   TOPLEVEL is true if the function is invoked at the topmost level.  */\n+\n+static rtx\n+internal_arg_pointer_based_exp (rtx rtl, bool toplevel)\n+{\n+  if (CONSTANT_P (rtl))\n+    return NULL_RTX;\n+\n+  if (rtl == crtl->args.internal_arg_pointer)\n+    return const0_rtx;\n+\n+  if (REG_P (rtl) && HARD_REGISTER_P (rtl))\n+    return NULL_RTX;\n+\n+  if (GET_CODE (rtl) == PLUS && CONST_INT_P (XEXP (rtl, 1)))\n+    {\n+      rtx val = internal_arg_pointer_based_exp (XEXP (rtl, 0), toplevel);\n+      if (val == NULL_RTX || val == pc_rtx)\n+\treturn val;\n+      return plus_constant (val, INTVAL (XEXP (rtl, 1)));\n+    }\n+\n+  /* When called at the topmost level, scan pseudo assignments in between the\n+     last scanned instruction in the tail call sequence and the latest insn\n+     in that sequence.  */\n+  if (toplevel)\n+    internal_arg_pointer_based_exp_scan ();\n+\n+  if (REG_P (rtl))\n+    {\n+      unsigned int idx = REGNO (rtl) - FIRST_PSEUDO_REGISTER;\n+      if (idx < VEC_length (rtx, internal_arg_pointer_exp_state.cache))\n+\treturn VEC_index (rtx, internal_arg_pointer_exp_state.cache, idx);\n+\n+      return NULL_RTX;\n+    }\n+\n+  if (for_each_rtx (&rtl, internal_arg_pointer_based_exp_1, NULL))\n+    return pc_rtx;\n+\n+  return NULL_RTX;\n+}\n+\n /* Return true if and only if SIZE storage units (usually bytes)\n    starting from address ADDR overlap with already clobbered argument\n    area.  This function is used to determine if we should give up a\n@@ -1667,26 +1790,17 @@ static bool\n mem_overlaps_already_clobbered_arg_p (rtx addr, unsigned HOST_WIDE_INT size)\n {\n   HOST_WIDE_INT i;\n+  rtx val;\n \n   if (sbitmap_empty_p (stored_args_map))\n     return false;\n-  if (addr == crtl->args.internal_arg_pointer)\n-    i = 0;\n-  else if (GET_CODE (addr) == PLUS\n-\t   && XEXP (addr, 0) == crtl->args.internal_arg_pointer\n-\t   && CONST_INT_P (XEXP (addr, 1)))\n-    i = INTVAL (XEXP (addr, 1));\n-  /* Return true for arg pointer based indexed addressing.  */\n-  else if (GET_CODE (addr) == PLUS\n-\t   && (XEXP (addr, 0) == crtl->args.internal_arg_pointer\n-\t       || XEXP (addr, 1) == crtl->args.internal_arg_pointer))\n-    return true;\n-  /* If the address comes in a register, we have no idea of its origin so\n-     give up and conservatively return true.  */\n-  else if (REG_P(addr))\n+  val = internal_arg_pointer_based_exp (addr, true);\n+  if (val == NULL_RTX)\n+    return false;\n+  else if (val == pc_rtx)\n     return true;\n   else\n-    return false;\n+    i = INTVAL (val);\n \n #ifdef ARGS_GROW_DOWNWARD\n   i = -i - size;\n@@ -3294,6 +3408,8 @@ expand_call (tree exp, rtx target, int ignore)\n \t    }\n \n \t  sbitmap_free (stored_args_map);\n+\t  internal_arg_pointer_exp_state.scan_start = NULL_RTX;\n+\t  VEC_free (rtx, heap, internal_arg_pointer_exp_state.cache);\n \t}\n       else\n \t{"}, {"sha": "7c6b9b2a1b59e52d13f61f8ec6af65fae1356541", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5275901c43a4c3f8feb32999af281ae5d009bac6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5275901c43a4c3f8feb32999af281ae5d009bac6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5275901c43a4c3f8feb32999af281ae5d009bac6", "patch": "@@ -1,3 +1,10 @@\n+2011-12-05  Jakub Jelinek  <jakub@redhat.com>\n+\t    Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR middle-end/51323\n+\tPR middle-end/50074\n+\t* gcc.c-torture/execute/pr51323.c: New test.\n+\n 2011-12-04  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/51383"}, {"sha": "929579983261d4dfc58d3746315828dbc9c83fe0", "filename": "gcc/testsuite/gcc.c-torture/execute/pr51323.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5275901c43a4c3f8feb32999af281ae5d009bac6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr51323.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5275901c43a4c3f8feb32999af281ae5d009bac6/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr51323.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr51323.c?ref=5275901c43a4c3f8feb32999af281ae5d009bac6", "patch": "@@ -0,0 +1,35 @@\n+/* PR middle-end/51323 */\n+\n+extern void abort (void);\n+struct S { int a, b, c; };\n+int v;\n+\n+__attribute__((noinline, noclone)) void\n+foo (int x, int y, int z)\n+{\n+  if (x != v || y != 0 || z != 9)\n+    abort ();\n+}\n+\n+static inline int\n+baz (const struct S *p)\n+{\n+  return p->b;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+bar (int x, struct S y)\n+{\n+  foo (baz (&y), 0, x);\n+}\n+\n+int\n+main ()\n+{\n+  struct S s;\n+  v = 3; s.a = v - 1; s.b = v; s.c = v + 1;\n+  bar (9, s);\n+  v = 17; s.a = v - 1; s.b = v; s.c = v + 1;\n+  bar (9, s);\n+  return 0;\n+}"}]}