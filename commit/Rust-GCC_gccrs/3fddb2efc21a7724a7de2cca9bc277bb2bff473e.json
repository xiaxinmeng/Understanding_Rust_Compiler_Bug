{"sha": "3fddb2efc21a7724a7de2cca9bc277bb2bff473e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZkZGIyZWZjMjFhNzcyNGE3ZGUyY2NhOWJjMjc3YmIyYmZmNDczZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-12-16T04:58:13Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-12-16T04:58:13Z"}, "message": "re PR middle-end/68878 (471.omnetpp in SPEC CPU 2006 is miscompiled with LTO)\n\n\n\tPR lto/68878\n\t* lto-symtab.c (lto_symtab_prevailing_virtual_decl): New function.\n\t* lto-symtab.h (lto_symtab_prevailing_virtual_decl): Declare.\n\t(lto_symtab_prevailing_decl): Use it.\n\nFrom-SVN: r231671", "tree": {"sha": "50380b892bb7c1e747b43a8008d0ed35b5021ef3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50380b892bb7c1e747b43a8008d0ed35b5021ef3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fddb2efc21a7724a7de2cca9bc277bb2bff473e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fddb2efc21a7724a7de2cca9bc277bb2bff473e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fddb2efc21a7724a7de2cca9bc277bb2bff473e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fddb2efc21a7724a7de2cca9bc277bb2bff473e/comments", "author": null, "committer": null, "parents": [{"sha": "f36932a2c7418a5a2f1f62f4a968147e054d45d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f36932a2c7418a5a2f1f62f4a968147e054d45d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f36932a2c7418a5a2f1f62f4a968147e054d45d4"}], "stats": {"total": 55, "additions": 54, "deletions": 1}, "files": [{"sha": "1e509b1c7a9fe36a8464871b3fb0d0618160a439", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fddb2efc21a7724a7de2cca9bc277bb2bff473e/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fddb2efc21a7724a7de2cca9bc277bb2bff473e/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=3fddb2efc21a7724a7de2cca9bc277bb2bff473e", "patch": "@@ -1,3 +1,10 @@\n+2015-12-10  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/68878\n+\t* lto-symtab.c (lto_symtab_prevailing_virtual_decl): New function.\n+\t* lto-symtab.h (lto_symtab_prevailing_virtual_decl): Declare.\n+\t(lto_symtab_prevailing_decl): Use it.\n+\n 2015-12-15  Ilya Verbin  <ilya.verbin@intel.com>\n \n \t* lto.c: Include stringpool.h and fold-const.h."}, {"sha": "957fbf6a6b103c8c5e12f08e996f1914106fc044", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fddb2efc21a7724a7de2cca9bc277bb2bff473e/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fddb2efc21a7724a7de2cca9bc277bb2bff473e/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=3fddb2efc21a7724a7de2cca9bc277bb2bff473e", "patch": "@@ -517,6 +517,8 @@ lto_symtab_merge_p (tree prevailing, tree decl)\n \t\t \"TREE_CODE mismatch\\n\");\n       return false;\n     }\n+  gcc_checking_assert (TREE_CHAIN (prevailing) == TREE_CHAIN (decl));\n+  \n   if (TREE_CODE (prevailing) == FUNCTION_DECL)\n     {\n       if (DECL_BUILT_IN (prevailing) != DECL_BUILT_IN (decl))\n@@ -883,6 +885,11 @@ lto_symtab_merge_symbols_1 (symtab_node *prevailing)\n \t  else\n \t    {\n \t      DECL_INITIAL (e->decl) = error_mark_node;\n+\t      if (e->lto_file_data)\n+\t\t{\n+\t\t  lto_free_function_in_decl_state_for_node (e);\n+\t\t  e->lto_file_data = NULL;\n+\t\t}\n \t      symtab->call_varpool_removal_hooks (dyn_cast<varpool_node *> (e));\n \t    }\n \t  e->remove_all_references ();\n@@ -968,3 +975,33 @@ lto_symtab_merge_symbols (void)\n \t}\n     }\n }\n+\n+/* Virtual tables may matter for code generation even if they are not\n+   directly refernced by the code because they may be used for devirtualizaiton.\n+   For this reason it is important to merge even virtual tables that have no\n+   associated symbol table entries.  Without doing so we lose optimization\n+   oppurtunities by losing track of the vtable constructor.\n+   FIXME: we probably ought to introduce explicit symbol table entries for\n+   those before streaming.  */\n+\n+tree\n+lto_symtab_prevailing_virtual_decl (tree decl)\n+{\n+  gcc_checking_assert (!type_in_anonymous_namespace_p (DECL_CONTEXT (decl))\n+\t\t       && DECL_ASSEMBLER_NAME_SET_P (decl));\n+\n+  symtab_node *n = symtab_node::get_for_asmname\n+\t\t     (DECL_ASSEMBLER_NAME (decl));\n+  while (n && ((!DECL_EXTERNAL (n->decl) && !TREE_PUBLIC (n->decl))\n+\t       || !DECL_VIRTUAL_P (n->decl)))\n+    n = n->next_sharing_asm_name;\n+  if (n)\n+    {\n+      lto_symtab_prevail_decl (n->decl, decl);\n+      decl = n->decl;\n+    }\n+  else\n+    symtab_node::get_create (decl);\n+\n+  return decl;\n+}"}, {"sha": "4c446312cfb587423c370218367c77cb565b28b4", "filename": "gcc/lto/lto-symtab.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fddb2efc21a7724a7de2cca9bc277bb2bff473e/gcc%2Flto%2Flto-symtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fddb2efc21a7724a7de2cca9bc277bb2bff473e/gcc%2Flto%2Flto-symtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.h?ref=3fddb2efc21a7724a7de2cca9bc277bb2bff473e", "patch": "@@ -20,6 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n extern void lto_symtab_merge_decls (void);\n extern void lto_symtab_merge_symbols (void);\n extern tree lto_symtab_prevailing_decl (tree decl);\n+extern tree lto_symtab_prevailing_virtual_decl (tree decl);\n \n /* Mark DECL to be previailed by PREVAILING.\n    Use DECL_ABSTRACT_ORIGIN and DECL_CHAIN as special markers; those do not\n@@ -31,6 +32,7 @@ inline void\n lto_symtab_prevail_decl (tree prevailing, tree decl)\n {\n   gcc_checking_assert (DECL_ABSTRACT_ORIGIN (decl) != error_mark_node);\n+  gcc_assert (TREE_PUBLIC (decl) || DECL_EXTERNAL (decl));\n   DECL_CHAIN (decl) = prevailing;\n   DECL_ABSTRACT_ORIGIN (decl) = error_mark_node;\n }\n@@ -43,5 +45,12 @@ lto_symtab_prevailing_decl (tree decl)\n   if (DECL_ABSTRACT_ORIGIN (decl) == error_mark_node)\n     return DECL_CHAIN (decl);\n   else\n-    return decl;\n+    {\n+      if ((TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == FUNCTION_DECL)\n+\t  && DECL_VIRTUAL_P (decl)\n+\t  && (TREE_PUBLIC (decl) || DECL_EXTERNAL (decl))\n+\t  && !symtab_node::get (decl))\n+\treturn lto_symtab_prevailing_virtual_decl (decl);\n+      return decl;\n+    }\n }"}]}