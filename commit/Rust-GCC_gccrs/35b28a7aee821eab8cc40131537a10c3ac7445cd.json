{"sha": "35b28a7aee821eab8cc40131537a10c3ac7445cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzViMjhhN2FlZTgyMWVhYjhjYzQwMTMxNTM3YTEwYzNhYzc0NDVjZA==", "commit": {"author": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1996-02-21T03:55:32Z"}, "committer": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1996-02-21T03:55:32Z"}, "message": "(validate_else): Don't loop given `#endif /'.\n\nHandle multiple\tadjacent backslash-newlines correctly.\nAccept a new parameter LIMIT to specify end of input;\nthis prevents confusion when the input contains '\\0' characters.\n\n(collect_expansion): Fix off-by-1 error when searching for `*/'\nat end of a comment used for traditional token concatenation.\n\n(macarg1): Fix off-by-1 error when skipping past `*/'\nat end of comment.\n\nFrom-SVN: r11330", "tree": {"sha": "68d5093708d0332371f1d301ea5f1b1987288f7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68d5093708d0332371f1d301ea5f1b1987288f7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35b28a7aee821eab8cc40131537a10c3ac7445cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35b28a7aee821eab8cc40131537a10c3ac7445cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35b28a7aee821eab8cc40131537a10c3ac7445cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35b28a7aee821eab8cc40131537a10c3ac7445cd/comments", "author": null, "committer": null, "parents": [{"sha": "a8526922fc48b77899bbc19495b2da3ce95c6dc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8526922fc48b77899bbc19495b2da3ce95c6dc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8526922fc48b77899bbc19495b2da3ce95c6dc8"}], "stats": {"total": 54, "additions": 30, "deletions": 24}, "files": [{"sha": "6f921861221d36c5e502f552684478d46fa2cb1e", "filename": "gcc/cccp.c", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b28a7aee821eab8cc40131537a10c3ac7445cd/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b28a7aee821eab8cc40131537a10c3ac7445cd/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=35b28a7aee821eab8cc40131537a10c3ac7445cd", "patch": "@@ -1143,7 +1143,7 @@ static void do_once PROTO((void));\n static HOST_WIDE_INT eval_if_expression PROTO((U_CHAR *, int));\n static void conditional_skip PROTO((FILE_BUF *, int, enum node_type, U_CHAR *, FILE_BUF *));\n static void skip_if_group PROTO((FILE_BUF *, int, FILE_BUF *));\n-static void validate_else PROTO((U_CHAR *));\n+static void validate_else PROTO((U_CHAR *, U_CHAR *));\n \n static U_CHAR *skip_to_end_of_comment PROTO((FILE_BUF *, int *, int));\n static U_CHAR *skip_quoted_string PROTO((U_CHAR *, U_CHAR *, int, int *, int *, int *));\n@@ -5982,9 +5982,12 @@ collect_expansion (buf, end, nargs, arglist)\n \t     this must be -traditional.  So replace the comment with\n \t     nothing at all.  */\n \t  exp_p--;\n-\t  p += 1;\n-\t  while (p < limit && !(p[-2] == '*' && p[-1] == '/'))\n-\t    p++;\n+\t  while (++p < limit) {\n+\t    if (p[0] == '*' && p[1] == '/') {\n+\t      p += 2;\n+\t      break;\n+\t    }\n+\t  }\n #if 0\n \t  /* Mark this as a concatenation-point, as if it had been ##.  */\n \t  concat = p;\n@@ -7341,7 +7344,7 @@ skip_if_group (ip, any, op)\n \t  case T_ELSE:\n \t  case T_ENDIF:\n \t    if (pedantic && if_stack != save_if_stack)\n-\t      validate_else (bp);\n+\t      validate_else (bp, endb);\n \t  case T_ELIF:\n \t    if (if_stack == instack[indepth].if_stack) {\n \t      error (\"`#%s' not within a conditional\", kt->name);\n@@ -7516,40 +7519,41 @@ do_endif (buf, limit, op, keyword)\n    the directive name.  P points to the first char after the directive name.  */\n \n static void\n-validate_else (p)\n+validate_else (p, limit)\n      register U_CHAR *p;\n+     register U_CHAR *limit;\n {\n   /* Advance P over whitespace and comments.  */\n   while (1) {\n-    if (*p == '\\\\' && p[1] == '\\n')\n+    while (*p == '\\\\' && p[1] == '\\n')\n       p += 2;\n     if (is_hor_space[*p])\n       p++;\n     else if (*p == '/') {\n-      if (p[1] == '\\\\' && p[2] == '\\n')\n-\tnewline_fix (p + 1);\n-      if (p[1] == '*') {\n+      while (p[1] == '\\\\' && p[2] == '\\n')\n \tp += 2;\n+      if (p[1] == '*') {\n \t/* Don't bother warning about unterminated comments\n \t   since that will happen later.  Just be sure to exit.  */\n-\twhile (*p) {\n-\t  if (p[1] == '\\\\' && p[2] == '\\n')\n-\t    newline_fix (p + 1);\n-\t  if (*p == '*' && p[1] == '/') {\n-\t    p += 2;\n-\t    break;\n+\tfor (p += 2; ; p++) {\n+\t  if (p == limit)\n+\t    return;\n+\t  if (*p == '*') {\n+\t    while (p[1] == '\\\\' && p[2] == '\\n')\n+\t      p += 2;\n+\t    if (p[1] == '/') {\n+\t      p += 2;\n+\t      break;\n+\t    }\n \t  }\n-\t  p++;\n \t}\n       }\n-      else if (cplusplus_comments && p[1] == '/') {\n-\tp += 2;\n-\twhile (*p && (*p != '\\n' || p[-1] == '\\\\'))\n-\t  p++;\n-      }\n+      else if (cplusplus_comments && p[1] == '/')\n+\treturn;\n+      else break;\n     } else break;\n   }\n-  if (*p && *p != '\\n')\n+  if (*p != '\\n')\n     pedwarn (\"text following `#else' or `#endif' violates ANSI standard\");\n }\n \f\n@@ -8493,8 +8497,10 @@ macarg1 (start, limit, depthptr, newlines, comments, rest_args)\n \t      warning (\"`/*' within comment\");\n \t    if (bp[1] == '\\\\' && bp[2] == '\\n')\n \t      newline_fix (bp + 1);\n-\t    if (bp[1] == '/')\n+\t    if (bp[1] == '/') {\n+\t      bp++;\n \t      break;\n+\t    }\n \t  }\n \t}\n       } else if (bp[1] == '/' && cplusplus_comments) {"}]}