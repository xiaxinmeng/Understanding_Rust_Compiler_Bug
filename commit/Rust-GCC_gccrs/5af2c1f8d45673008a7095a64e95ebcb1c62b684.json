{"sha": "5af2c1f8d45673008a7095a64e95ebcb1c62b684", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFmMmMxZjhkNDU2NzMwMDhhNzA5NWE2NGU5NWViY2IxYzYyYjY4NA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-07-03T17:19:19Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-07-03T17:19:19Z"}, "message": "pa.c (fmpy_operands): Define.\n\n        * pa.c (fmpy_operands): Define.\n        (combinable_fmpy): New function.\n        (combinable_fadd, combinable_fsub): Likewise.\n\nFrom-SVN: r12385", "tree": {"sha": "ca04b9171b813eed2c530ae4fb4fe3b5e673cc8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca04b9171b813eed2c530ae4fb4fe3b5e673cc8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5af2c1f8d45673008a7095a64e95ebcb1c62b684", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5af2c1f8d45673008a7095a64e95ebcb1c62b684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5af2c1f8d45673008a7095a64e95ebcb1c62b684", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5af2c1f8d45673008a7095a64e95ebcb1c62b684/comments", "author": null, "committer": null, "parents": [{"sha": "e45539c0d5e9e4f968c2ce4fa3b66260e3915850", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e45539c0d5e9e4f968c2ce4fa3b66260e3915850", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e45539c0d5e9e4f968c2ce4fa3b66260e3915850"}], "stats": {"total": 171, "additions": 171, "deletions": 0}, "files": [{"sha": "8ddbf0e5d3059a0760589445b327dfe7cebdbaa4", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af2c1f8d45673008a7095a64e95ebcb1c62b684/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af2c1f8d45673008a7095a64e95ebcb1c62b684/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=5af2c1f8d45673008a7095a64e95ebcb1c62b684", "patch": "@@ -61,6 +61,14 @@ static int out_of_line_prologue_epilogue;\n \n static rtx find_addr_reg ();\n \n+/* Kludgery.  We hold the operands to a fmpy insn here so we can\n+   compare them with the operands for an fadd/fsub to determine if\n+   they can be combined into a fmpyadd/fmpysub insn.\n+\n+   This _WILL_ disappear as the code to combine independent insns\n+   matures.  */\n+static rtx fmpy_operands[3];\n+\n /* Keep track of the number of bytes we have output in the CODE subspaces\n    during this compilation so we'll know when to emit inline long-calls.  */\n \n@@ -5299,6 +5307,169 @@ following_call (insn)\n   return 0;\n }\n \n+/* Return nonzero if this is a floating point multiply (fmpy) which\n+   could be combined with a suitable floating point add or sub insn.  */\n+\n+combinable_fmpy (insn)\n+     rtx insn;\n+{\n+  rtx src, dest, pattern = PATTERN (insn);\n+  enum machine_mode mode;\n+\n+  /* Only on 1.1 and later cpus.  */\n+  if (!TARGET_SNAKE)\n+    return 0;\n+\n+  /* Must be a (set (reg) (mult (reg) (reg))).  */\n+  if (GET_CODE (pattern) != SET\n+      || GET_CODE (SET_SRC (pattern)) != MULT\n+      || GET_CODE (SET_DEST (pattern)) != REG)\n+    return 0;\n+\n+  src = SET_SRC (pattern);\n+  dest = SET_DEST (pattern);\n+\n+  /* Must be registers.  */\n+  if (GET_CODE (XEXP (src, 0)) != REG\n+      || GET_CODE (XEXP (src, 1)) != REG)\n+    return 0;\n+\n+  /* Must be a floating point mode.  Must match the mode of the fmul.  */\n+  mode = GET_MODE (dest);\n+  if (mode != DFmode && mode != SFmode)\n+    return 0;\n+ \n+  /* SFmode limits the registers which can be used to the upper\n+     32 32bit FP registers.  */\n+  if (mode == SFmode\n+      && (REGNO (dest) < 57\n+\t  || REGNO (XEXP (src, 0)) < 57\n+\t  || REGNO (XEXP (src, 1)) < 57))\n+    return 0;\n+     \n+  /* Save our operands, we'll need to verify they don't conflict with\n+     those in the fadd or fsub.  XXX This needs to disasppear soon.  */\n+  fmpy_operands[0] = dest;\n+  fmpy_operands[1] = XEXP (src, 0);\n+  fmpy_operands[2] = XEXP (src, 1);\n+\n+  return 1;\n+}\n+\n+/* Return nonzero if INSN is a floating point add suitable for combining\n+   with the most recently examined floating point multiply.  */\n+\n+combinable_fadd (insn)\n+     rtx insn;\n+{\n+  rtx src, dest, pattern = PATTERN (insn);\n+  enum machine_mode mode;\n+\n+  /* Must be a (set (reg) (plus (reg) (reg))).  */\n+  if (GET_CODE (pattern) != SET\n+      || GET_CODE (SET_SRC (pattern)) != PLUS\n+      || GET_CODE (SET_DEST (pattern)) != REG)\n+    return 0;\n+\n+  src = SET_SRC (pattern);\n+  dest = SET_DEST (pattern);\n+\n+  /* Must be registers.  */\n+  if (GET_CODE (XEXP (src, 0)) != REG\n+      || GET_CODE (XEXP (src, 1)) != REG)\n+    return 0;\n+\n+  /* Must be a floating point mode.  Must match the mode of the fmul.  */\n+  mode = GET_MODE (dest);\n+  if (mode != DFmode && mode != SFmode)\n+    return 0;\n+ \n+  if (mode != GET_MODE (fmpy_operands[0]))\n+    return 0;\n+\n+  /* SFmode limits the registers which can be used to the upper\n+     32 32bit FP registers.  */\n+  if (mode == SFmode\n+      && (REGNO (dest) < 57\n+\t  || REGNO (XEXP (src, 0)) < 57\n+\t  || REGNO (XEXP (src, 1)) < 57))\n+    return 0;\n+     \n+  /* Only 2 real operands to the addition.  One of the input operands\n+     must be the same as the output operand.  */\n+  if (! rtx_equal_p (dest, XEXP (src, 0))\n+      && ! rtx_equal_p (dest, XEXP (src, 1)))\n+    return 0;\n+\n+  /* Inout operand of the add can not conflict with any operands from the\n+     multiply.  */\n+  if (rtx_equal_p (dest, fmpy_operands[0])\n+      || rtx_equal_p (dest, fmpy_operands[1])\n+      || rtx_equal_p (dest, fmpy_operands[2]))\n+    return 0;\n+\n+  /* The multiply can not feed into the addition.  */\n+  if (rtx_equal_p (fmpy_operands[0], XEXP (src, 0))\n+      || rtx_equal_p (fmpy_operands[0], XEXP (src, 1)))\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Return nonzero if INSN is a floating point sub suitable for combining\n+   with the most recently examined floating point multiply.  */\n+\n+combinable_fsub (insn)\n+     rtx insn;\n+{\n+  rtx src, dest, pattern = PATTERN (insn);\n+  enum machine_mode mode;\n+\n+  /* Must be (set (reg) (minus (reg) (reg))).  */\n+  if (GET_CODE (pattern) != SET\n+      || GET_CODE (SET_SRC (pattern)) != MINUS\n+      || GET_CODE (SET_DEST (pattern)) != REG)\n+    return 0;\n+\n+  src = SET_SRC (pattern);\n+  dest = SET_DEST (pattern);\n+\n+  if (GET_CODE (XEXP (src, 0)) != REG\n+      || GET_CODE (XEXP (src, 1)) != REG)\n+    return 0;\n+\n+  /* Must be a floating point mode.  Must match the mode of the fmul.  */\n+  mode = GET_MODE (dest);\n+  if (mode != DFmode && mode != SFmode)\n+    return 0;\n+ \n+  if (mode != GET_MODE (fmpy_operands[0]))\n+    return 0;\n+\n+  /* SFmode limits the registers which can be used to the upper\n+     32 32bit FP registers.  */\n+  if (mode == SFmode && (REGNO (dest) < 57 || REGNO (XEXP (src, 1)) < 57))\n+    return 0;\n+     \n+  /* Only 2 real operands to the subtraction.  Output must be the\n+     same as the first operand of the MINUS.  */\n+  if (! rtx_equal_p (dest, XEXP (src, 0)))\n+    return;\n+\n+  /* Inout operand of the sub can not conflict with any operands from the\n+     multiply.  */\n+  if (rtx_equal_p (dest, fmpy_operands[0])\n+      || rtx_equal_p (dest, fmpy_operands[1])\n+      || rtx_equal_p (dest, fmpy_operands[2]))\n+    return 0;\n+\n+  /* The multiply can not feed into the subtraction.  */\n+  if (rtx_equal_p (fmpy_operands[0], XEXP (src, 0))\n+      || rtx_equal_p (fmpy_operands[0], XEXP (src, 1)))\n+    return 0;\n+\n+  return 1;\n+}\n \n /* We use this hook to perform a PA specific optimization which is difficult\n    to do in earlier passes."}]}