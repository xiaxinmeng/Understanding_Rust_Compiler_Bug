{"sha": "d4f5cd5e82aca858b37d6cb927874e018bacce6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRmNWNkNWU4MmFjYTg1OGIzN2Q2Y2I5Mjc4NzRlMDE4YmFjY2U2YQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-10-13T07:58:05Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-10-13T07:58:05Z"}, "message": "re PR c++/63419 (verify_gimple failed: \"vector CONSTRUCTOR element is not a GIMPLE value\")\n\n2014-10-13  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/63419\n\t* gimple-fold.h (gimple_convert): New function.\n\t* gimple-fold.c (gimple_convert): Likewise.\n\t* tree-ssa-pre.c (create_expression_by_pieces): Use gimple_convert\n\tto split out required conversions early.\n\n\t* g++.dg/torture/pr63419.C: New testcase.\n\nFrom-SVN: r216138", "tree": {"sha": "f3f3e955cc37835a4a5c65ea164c26f86aee90a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3f3e955cc37835a4a5c65ea164c26f86aee90a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4f5cd5e82aca858b37d6cb927874e018bacce6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4f5cd5e82aca858b37d6cb927874e018bacce6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4f5cd5e82aca858b37d6cb927874e018bacce6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4f5cd5e82aca858b37d6cb927874e018bacce6a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "641123eb5e66fc3794eaa102def2da24a36b7da9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/641123eb5e66fc3794eaa102def2da24a36b7da9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/641123eb5e66fc3794eaa102def2da24a36b7da9"}], "stats": {"total": 275, "additions": 271, "deletions": 4}, "files": [{"sha": "a8359339684339cf780f06fbb5328e6eb24c2fa2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4f5cd5e82aca858b37d6cb927874e018bacce6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4f5cd5e82aca858b37d6cb927874e018bacce6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4f5cd5e82aca858b37d6cb927874e018bacce6a", "patch": "@@ -1,3 +1,11 @@\n+2014-10-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/63419\n+\t* gimple-fold.h (gimple_convert): New function.\n+\t* gimple-fold.c (gimple_convert): Likewise.\n+\t* tree-ssa-pre.c (create_expression_by_pieces): Use gimple_convert\n+\tto split out required conversions early.\n+\n 2014-10-13  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* rtlanal.c (generic_subrtx_iterator <T>::add_subrtxes_to_queue):"}, {"sha": "a0ce0db9766f2ce7e1eace92b01826b00f981bd6", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4f5cd5e82aca858b37d6cb927874e018bacce6a/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4f5cd5e82aca858b37d6cb927874e018bacce6a/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=d4f5cd5e82aca858b37d6cb927874e018bacce6a", "patch": "@@ -5295,3 +5295,20 @@ rewrite_to_defined_overflow (gimple stmt)\n \n   return stmts;\n }\n+\n+/* Return OP converted to TYPE by emitting a conversion statement on SEQ\n+   if required using location LOC.  Note that OP will be returned\n+   unmodified if GIMPLE does not require an explicit conversion between\n+   its type and TYPE.  */\n+\n+tree\n+gimple_convert (gimple_seq *seq, location_t loc, tree type, tree op)\n+{\n+  if (useless_type_conversion_p (type, TREE_TYPE (op)))\n+    return op;\n+  op = fold_convert_loc (loc, type, op);\n+  gimple_seq stmts = NULL;\n+  op = force_gimple_operand (op, &stmts, true, NULL_TREE);\n+  gimple_seq_add_seq_without_update (seq, stmts);\n+  return op;\n+}"}, {"sha": "b55a3ef8b3e878b82122506b09d6da10395e573b", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4f5cd5e82aca858b37d6cb927874e018bacce6a/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4f5cd5e82aca858b37d6cb927874e018bacce6a/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=d4f5cd5e82aca858b37d6cb927874e018bacce6a", "patch": "@@ -45,4 +45,11 @@ extern tree gimple_fold_indirect_ref (tree);\n extern bool arith_code_with_undefined_signed_overflow (tree_code);\n extern gimple_seq rewrite_to_defined_overflow (gimple);\n \n+extern tree gimple_convert (gimple_seq *, location_t, tree, tree);\n+inline tree\n+gimple_convert (gimple_seq *seq, tree type, tree op)\n+{\n+  return gimple_convert (seq, UNKNOWN_LOCATION, type, op);\n+}\n+\n #endif  /* GCC_GIMPLE_FOLD_H */"}, {"sha": "1ab2f218049f1abfdf36d332ef3adf76c3d6b2df", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4f5cd5e82aca858b37d6cb927874e018bacce6a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4f5cd5e82aca858b37d6cb927874e018bacce6a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d4f5cd5e82aca858b37d6cb927874e018bacce6a", "patch": "@@ -1,3 +1,8 @@\n+2014-10-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/63419\n+\t* g++.dg/torture/pr63419.C: New testcase.\n+\n 2014-10-12  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/59401"}, {"sha": "53f7c3e8c27964504f9785a9d3eaeac9f08b66c0", "filename": "gcc/testsuite/g++.dg/torture/pr63419.C", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4f5cd5e82aca858b37d6cb927874e018bacce6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr63419.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4f5cd5e82aca858b37d6cb927874e018bacce6a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr63419.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr63419.C?ref=d4f5cd5e82aca858b37d6cb927874e018bacce6a", "patch": "@@ -0,0 +1,225 @@\n+// { dg-do compile }\n+\n+typedef float __m128 __attribute__ ((__vector_size__ (16)));\n+const int a = 0;\n+enum\n+{\n+  ReadOnlyAccessors\n+};\n+template <typename> struct traits;\n+struct A\n+{\n+  enum\n+  {\n+    value = 1\n+  };\n+};\n+template <typename> struct EigenBase;\n+template <typename> class J;\n+template <typename, int = A::value> class DenseCoeffsBase;\n+template <typename, int, int, int = 0, int = 0, int = 0> class K;\n+template <typename> class N;\n+template <typename, typename> class CwiseUnaryOp;\n+template <typename> class L;\n+template <typename> class P;\n+template <typename> struct B;\n+template <typename> struct C;\n+template <typename Derived> struct dense_xpr_base\n+{\n+  typedef N<Derived> type;\n+};\n+template <typename Packet> void padd (Packet);\n+template <> struct C<float>\n+{\n+  typedef __m128 type;\n+};\n+struct D\n+{\n+  void\n+  packetOp (C<float>::type)\n+  {\n+    __m128 b = { m_other };\n+    padd (b);\n+  }\n+  float m_other;\n+};\n+template <typename Derived>\n+class DenseCoeffsBase<Derived, ReadOnlyAccessors> : public EigenBase<Derived>\n+{\n+public:\n+  typedef typename C<typename traits<Derived>::Scalar>::type PacketScalar;\n+};\n+template <typename Derived>\n+class DenseCoeffsBase<Derived>\n+    : public DenseCoeffsBase<Derived, ReadOnlyAccessors>\n+{\n+public:\n+  template <typename OtherDerived, int, int LoadMode>\n+  void\n+  copyPacket (typename traits<Derived>::Index, J<OtherDerived> p2)\n+  {\n+    p2.derived ().template packet<LoadMode> (0);\n+  }\n+};\n+template <typename Derived> class J : public DenseCoeffsBase<Derived>\n+{\n+public:\n+  using DenseCoeffsBase<Derived>::derived;\n+  template <typename OtherDerived>\n+  Derived &lazyAssign (const J<OtherDerived> &);\n+};\n+template <typename Derived> class N : public J<Derived>\n+{\n+public:\n+  template <typename OtherDerived>\n+  typename B<OtherDerived>::Type operator*(N<OtherDerived>);\n+  L<Derived> array ();\n+};\n+template <typename Derived> struct EigenBase\n+{\n+  Derived\n+  derived () const\n+  {\n+    return *static_cast<const Derived *> (this);\n+  }\n+};\n+template <typename Derived1, typename Derived2> struct F\n+{\n+  static void\n+  run (Derived1 p1, Derived2 p2)\n+  {\n+    enum\n+    {\n+      srcAlignment\n+    };\n+    for (;;)\n+      p1.template copyPacket<Derived2, 0, srcAlignment> (0, p2);\n+  }\n+};\n+template <typename Derived>\n+template <typename OtherDerived>\n+Derived &\n+J<Derived>::lazyAssign (const J<OtherDerived> &p1)\n+{\n+  F<Derived, OtherDerived>::run (derived (), p1.derived ());\n+}\n+template <typename Derived, typename OtherDerived> struct G\n+{\n+  static Derived\n+  run (Derived p1, OtherDerived p2)\n+  {\n+    p1.lazyAssign (p2);\n+  }\n+};\n+class H\n+{\n+public:\n+  H (int, int, int);\n+};\n+template <typename Derived> class M : public dense_xpr_base<Derived>::type\n+{\n+public:\n+  typedef typename traits<Derived>::Index Index;\n+  H m_storage;\n+  M (Index, Index, Index) : m_storage (0, 0, 0) {}\n+  template <typename OtherDerived>\n+  void\n+  _set_noalias (J<OtherDerived> p1)\n+  {\n+    G<Derived, OtherDerived>::run (this->derived (), p1.derived ());\n+  }\n+};\n+template <typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows,\n+          int _MaxCols>\n+struct traits<K<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >\n+{\n+  typedef _Scalar Scalar;\n+  typedef int StorageKind;\n+  typedef int Index;\n+};\n+template <typename, int _Rows, int _Cols, int, int, int>\n+class K : public M<K<float, _Rows, _Cols> >\n+{\n+public:\n+  typedef M<K> Base;\n+  typedef K Nested;\n+  template <typename T0, typename T1> K (T0, T1);\n+  template <typename OtherDerived> K (N<OtherDerived> p1) : Base (0, 0, 0)\n+  {\n+    Base::_set_noalias (p1);\n+  }\n+};\n+template <typename UnaryOp, typename XprType>\n+struct traits<CwiseUnaryOp<UnaryOp, XprType> > : traits<XprType>\n+{\n+};\n+template <typename, typename, typename> class I;\n+template <typename, typename XprType>\n+class CwiseUnaryOp\n+    : public I<D, XprType, typename traits<XprType>::StorageKind>\n+{\n+public:\n+  D\n+  functor ()\n+  {\n+    return m_functor;\n+  }\n+  typename XprType::Nested nestedExpression ();\n+  D m_functor;\n+};\n+template <typename UnaryOp, typename XprType>\n+class I<UnaryOp, XprType, int>\n+    : public dense_xpr_base<CwiseUnaryOp<UnaryOp, XprType> >::type\n+{\n+public:\n+  typedef CwiseUnaryOp<UnaryOp, XprType> Derived;\n+  typedef typename dense_xpr_base<CwiseUnaryOp<UnaryOp, XprType> >::type Base;\n+  typedef Derived Nested;\n+  using Base::derived;\n+  template <int LoadMode> void packet (typename traits<Derived>::Index)\n+  {\n+    derived ().functor ().packetOp (\n+        derived ().nestedExpression ().template packet<LoadMode> (0));\n+  }\n+};\n+template <typename> struct B\n+{\n+  typedef P<CwiseUnaryOp<D, L<K<float, 0, 1> > > > Type;\n+};\n+template <typename Derived> class O : public J<Derived>\n+{\n+public:\n+  P<Derived> matrix ();\n+};\n+template <typename ExpressionType>\n+struct traits<L<ExpressionType> > : traits<typename ExpressionType::Nested>\n+{\n+};\n+template <typename ExpressionType> class L : public O<L<ExpressionType> >\n+{\n+public:\n+  typedef L Nested;\n+  template <int>\n+  typename O<L>::PacketScalar packet (typename traits<L>::Index);\n+};\n+template <typename ExpressionType>\n+struct traits<P<ExpressionType> > : traits<typename ExpressionType::Nested>\n+{\n+};\n+template <typename ExpressionType> class P : public N<P<ExpressionType> >\n+{\n+public:\n+  N<P> Base;\n+  template <int LoadMode> void packet (typename traits<P>::Index)\n+  {\n+    m_expression.template packet<LoadMode> (0);\n+  }\n+  ExpressionType m_expression;\n+};\n+int\n+main ()\n+{\n+  K<float, 0, a> m (0, 0);\n+  K<float, 0, 1> c (0, 0);\n+  c = m.array ().matrix () * m;\n+}"}, {"sha": "60ff70fa42b09c2374327973ff753e0f9a1e60d6", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4f5cd5e82aca858b37d6cb927874e018bacce6a/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4f5cd5e82aca858b37d6cb927874e018bacce6a/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=d4f5cd5e82aca858b37d6cb927874e018bacce6a", "patch": "@@ -2819,12 +2819,15 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n \t    if (nary->opcode == POINTER_PLUS_EXPR)\n \t      {\n \t\tif (i == 0)\n-\t\t  genop[i] = fold_convert (nary->type, genop[i]);\n+\t\t  genop[i] = gimple_convert (&forced_stmts,\n+\t\t\t\t\t     nary->type, genop[i]);\n \t\telse if (i == 1)\n-\t\t  genop[i] = convert_to_ptrofftype (genop[i]);\n+\t\t  genop[i] = gimple_convert (&forced_stmts,\n+\t\t\t\t\t     sizetype, genop[i]);\n \t      }\n \t    else\n-\t      genop[i] = fold_convert (TREE_TYPE (nary->op[i]), genop[i]);\n+\t      genop[i] = gimple_convert (&forced_stmts,\n+\t\t\t\t\t TREE_TYPE (nary->op[i]), genop[i]);\n \t  }\n \tif (nary->opcode == CONSTRUCTOR)\n \t  {\n@@ -2866,8 +2869,10 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n      statements.\n      We have to call unshare_expr because force_gimple_operand may\n      modify the tree we pass to it.  */\n-  folded = force_gimple_operand (unshare_expr (folded), &forced_stmts,\n+  gimple_seq tem = NULL;\n+  folded = force_gimple_operand (unshare_expr (folded), &tem,\n \t\t\t\t false, NULL);\n+  gimple_seq_add_seq_without_update (&forced_stmts, tem);\n \n   /* If we have any intermediate expressions to the value sets, add them\n      to the value sets and chain them in the instruction stream.  */"}]}