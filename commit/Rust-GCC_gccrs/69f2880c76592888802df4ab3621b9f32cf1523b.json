{"sha": "69f2880c76592888802df4ab3621b9f32cf1523b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjlmMjg4MGM3NjU5Mjg4ODgwMmRmNGFiMzYyMWI5ZjMyY2YxNTIzYg==", "commit": {"author": {"name": "Jan Sjodin", "email": "jan.sjodin@amd.com", "date": "2007-06-06T06:08:58Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2007-06-06T06:08:58Z"}, "message": "lambda.h (build_linear_expr): New.\n\n\t* lambda.h (build_linear_expr): New.\n\t* lambda-code.c (lbv_to_gcc_expression, lle_to_gcc_expression): \n\tUse build_linear_expr, call fold and force_gimple_operand.\n\t(lambda_loopnest_to_gcc_loopnest): Check that there is\n\tsomething to insert.\n\t* testsuite/gcc.dg/tree-ssa/ltrans-6.c: New.\n\n\nCo-Authored-By: Sebastian Pop <sebpop@gmail.com>\n\nFrom-SVN: r125355", "tree": {"sha": "bd5186af1c19a3521332d48b13b46ab6820faad1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd5186af1c19a3521332d48b13b46ab6820faad1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69f2880c76592888802df4ab3621b9f32cf1523b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69f2880c76592888802df4ab3621b9f32cf1523b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69f2880c76592888802df4ab3621b9f32cf1523b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69f2880c76592888802df4ab3621b9f32cf1523b/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "518a0b783878a8e1056a79ff31f18170775530a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/518a0b783878a8e1056a79ff31f18170775530a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/518a0b783878a8e1056a79ff31f18170775530a3"}], "stats": {"total": 348, "additions": 117, "deletions": 231}, "files": [{"sha": "99faa9725440f97efd0430f00bee716a533acd00", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f2880c76592888802df4ab3621b9f32cf1523b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f2880c76592888802df4ab3621b9f32cf1523b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=69f2880c76592888802df4ab3621b9f32cf1523b", "patch": "@@ -1,3 +1,13 @@\n+2007-06-06  Jan Sjodin  <jan.sjodin@amd.com>\n+\t    Sebastian Pop  <sebpop@gmail.com>\n+\n+\t* lambda.h (build_linear_expr): New.\n+\t* lambda-code.c (lbv_to_gcc_expression, lle_to_gcc_expression): \n+\tUse build_linear_expr, call fold and force_gimple_operand.\n+\t(lambda_loopnest_to_gcc_loopnest): Check that there is\n+\tsomething to insert.\n+\t* testsuite/gcc.dg/tree-ssa/ltrans-6.c: New.\n+\n 2007-06-05  Joerg Wunsch  <j.gnu@uriah.heep.sax.de>\n \n \tPR preprocessor/23479"}, {"sha": "96aaaa07e55a1a4496ea74f431442d387b83b109", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 59, "deletions": 231, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f2880c76592888802df4ab3621b9f32cf1523b/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f2880c76592888802df4ab3621b9f32cf1523b/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=69f2880c76592888802df4ab3621b9f32cf1523b", "patch": "@@ -1528,71 +1528,18 @@ lbv_to_gcc_expression (lambda_body_vector lbv,\n \t\t       tree type, VEC(tree,heap) *induction_vars, \n \t\t       tree *stmts_to_insert)\n {\n-  tree stmts, stmt, resvar, name;\n-  tree iv;\n-  size_t i;\n-  tree_stmt_iterator tsi;\n+  int k;\n+  tree resvar;\n+  tree expr = build_linear_expr (type, LBV_COEFFICIENTS (lbv), induction_vars);\n+\n+  k = LBV_DENOMINATOR (lbv);\n+  gcc_assert (k != 0);\n+  if (k != 1)\n+    expr = fold_build2 (CEIL_DIV_EXPR, type, expr, build_int_cst (type, k));\n \n-  /* Create a statement list and a linear expression temporary.  */\n-  stmts = alloc_stmt_list ();\n   resvar = create_tmp_var (type, \"lbvtmp\");\n   add_referenced_var (resvar);\n-\n-  /* Start at 0.  */\n-  stmt = build_gimple_modify_stmt (resvar,\n-\t\t\t\t   fold_convert (type, integer_zero_node));\n-  name = make_ssa_name (resvar, stmt);\n-  GIMPLE_STMT_OPERAND (stmt, 0) = name;\n-  tsi = tsi_last (stmts);\n-  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n-\n-  for (i = 0; VEC_iterate (tree, induction_vars, i, iv); i++)\n-    {\n-      if (LBV_COEFFICIENTS (lbv)[i] != 0)\n-\t{\n-\t  tree newname;\n-\t  tree coeffmult;\n-\t  \n-\t  /* newname = coefficient * induction_variable */\n-\t  coeffmult = build_int_cst (type, LBV_COEFFICIENTS (lbv)[i]);\n-\t  stmt = build_gimple_modify_stmt (resvar,\n-\t\t\t\t\t   fold_build2 (MULT_EXPR, type,\n-\t\t\t\t\t\t\tiv, coeffmult));\n-\n-\t  newname = make_ssa_name (resvar, stmt);\n-\t  GIMPLE_STMT_OPERAND (stmt, 0) = newname;\n-\t  fold_stmt (&stmt);\n-\t  tsi = tsi_last (stmts);\n-\t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n-\n-\t  /* name = name + newname */\n-\t  stmt = build_gimple_modify_stmt (resvar,\n-\t\t\t\t\t   build2 (PLUS_EXPR, type,\n-\t\t\t\t\t\t   name, newname));\n-\t  name = make_ssa_name (resvar, stmt);\n-\t  GIMPLE_STMT_OPERAND (stmt, 0) = name;\n-\t  fold_stmt (&stmt);\n-\t  tsi = tsi_last (stmts);\n-\t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n-\n-\t}\n-    }\n-\n-  /* Handle any denominator that occurs.  */\n-  if (LBV_DENOMINATOR (lbv) != 1)\n-    {\n-      tree denominator = build_int_cst (type, LBV_DENOMINATOR (lbv));\n-      stmt = build_gimple_modify_stmt (resvar,\n-\t\t\t\t       build2 (CEIL_DIV_EXPR, type,\n-\t\t\t\t\t       name, denominator));\n-      name = make_ssa_name (resvar, stmt);\n-      GIMPLE_STMT_OPERAND (stmt, 0) = name;\n-      fold_stmt (&stmt);\n-      tsi = tsi_last (stmts);\n-      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n-    }\n-  *stmts_to_insert = stmts;\n-  return name;\n+  return force_gimple_operand (fold (expr), stmts_to_insert, true, resvar);\n }\n \n /* Convert a linear expression from coefficient and constant form to a\n@@ -1616,182 +1563,57 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \t\t       VEC(tree,heap) *invariants,\n \t\t       enum tree_code wrap, tree *stmts_to_insert)\n {\n-  tree stmts, stmt, resvar, name;\n-  size_t i;\n-  tree_stmt_iterator tsi;\n-  tree iv, invar;\n+  int k;\n+  tree resvar;\n+  tree expr = NULL_TREE;\n   VEC(tree,heap) *results = NULL;\n \n   gcc_assert (wrap == MAX_EXPR || wrap == MIN_EXPR);\n-  name = NULL_TREE;\n-  /* Create a statement list and a linear expression temporary.  */\n-  stmts = alloc_stmt_list ();\n-  resvar = create_tmp_var (type, \"lletmp\");\n-  add_referenced_var (resvar);\n \n-  /* Build up the linear expressions, and put the variable representing the\n-     result in the results array.  */\n+  /* Build up the linear expressions.  */\n   for (; lle != NULL; lle = LLE_NEXT (lle))\n     {\n-      /* Start at name = 0.  */\n-      stmt = build_gimple_modify_stmt (resvar,\n-\t\t\t\t       fold_convert (type, integer_zero_node));\n-      name = make_ssa_name (resvar, stmt);\n-      GIMPLE_STMT_OPERAND (stmt, 0) = name;\n-      fold_stmt (&stmt);\n-      tsi = tsi_last (stmts);\n-      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n-\n-      /* First do the induction variables.  \n-         at the end, name = name + all the induction variables added\n-         together.  */\n-      for (i = 0; VEC_iterate (tree, induction_vars, i, iv); i++)\n-\t{\n-\t  if (LLE_COEFFICIENTS (lle)[i] != 0)\n-\t    {\n-\t      tree newname;\n-\t      tree mult;\n-\t      tree coeff;\n-\n-\t      /* mult = induction variable * coefficient.  */\n-\t      if (LLE_COEFFICIENTS (lle)[i] == 1)\n-\t\t{\n-\t\t  mult = VEC_index (tree, induction_vars, i);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  coeff = build_int_cst (type,\n-\t\t\t\t\t LLE_COEFFICIENTS (lle)[i]);\n-\t\t  mult = fold_build2 (MULT_EXPR, type, iv, coeff);\n-\t\t}\n-\n-\t      /* newname = mult */\n-\t      stmt = build_gimple_modify_stmt (resvar, mult);\n-\t      newname = make_ssa_name (resvar, stmt);\n-\t      GIMPLE_STMT_OPERAND (stmt, 0) = newname;\n-\t      fold_stmt (&stmt);\n-\t      tsi = tsi_last (stmts);\n-\t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n-\n-\t      /* name = name + newname */\n-\t      stmt = build_gimple_modify_stmt (resvar,\n-\t\t\t\t\t       build2 (PLUS_EXPR, type,\n-\t\t\t\t\t\t       name, newname));\n-\t      name = make_ssa_name (resvar, stmt);\n-\t      GIMPLE_STMT_OPERAND (stmt, 0) = name;\n-\t      fold_stmt (&stmt);\n-\t      tsi = tsi_last (stmts);\n-\t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n-\t    }\n-\t}\n-\n-      /* Handle our invariants.\n-         At the end, we have name = name + result of adding all multiplied\n-         invariants.  */\n-      for (i = 0; VEC_iterate (tree, invariants, i, invar); i++)\n-\t{\n-\t  if (LLE_INVARIANT_COEFFICIENTS (lle)[i] != 0)\n-\t    {\n-\t      tree newname;\n-\t      tree mult;\n-\t      tree coeff;\n-\t      int invcoeff = LLE_INVARIANT_COEFFICIENTS (lle)[i];\n-\t      /* mult = invariant * coefficient  */\n-\t      if (invcoeff == 1)\n-\t\t{\n-\t\t  mult = invar;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  coeff = build_int_cst (type, invcoeff);\n-\t\t  mult = fold_build2 (MULT_EXPR, type, invar, coeff);\n-\t\t}\n-\n-\t      /* newname = mult */\n-\t      stmt = build_gimple_modify_stmt (resvar, mult);\n-\t      newname = make_ssa_name (resvar, stmt);\n-\t      GIMPLE_STMT_OPERAND (stmt, 0) = newname;\n-\t      fold_stmt (&stmt);\n-\t      tsi = tsi_last (stmts);\n-\t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n-\n-\t      /* name = name + newname */\n-\t      stmt = build_gimple_modify_stmt (resvar,\n-\t\t\t\t\t       build2 (PLUS_EXPR, type,\n-\t\t\t\t\t\t       name, newname));\n-\t      name = make_ssa_name (resvar, stmt);\n-\t      GIMPLE_STMT_OPERAND (stmt, 0) = name;\n-\t      fold_stmt (&stmt);\n-\t      tsi = tsi_last (stmts);\n-\t      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n-\t    }\n-\t}\n-\n-      /* Now handle the constant.\n-         name = name + constant.  */\n-      if (LLE_CONSTANT (lle) != 0)\n-\t{\n-\t  tree incr = build_int_cst (type, LLE_CONSTANT (lle));\n-\t  stmt = build_gimple_modify_stmt (resvar, build2 (PLUS_EXPR, type,\n-\t\t\t\t\t\t\t   name, incr));\n-\t  name = make_ssa_name (resvar, stmt);\n-\t  GIMPLE_STMT_OPERAND (stmt, 0) = name;\n-\t  fold_stmt (&stmt);\n-\t  tsi = tsi_last (stmts);\n-\t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n-\t}\n-\n-      /* Now handle the offset.\n-         name = name + linear offset.  */\n-      if (LLE_CONSTANT (offset) != 0)\n-\t{\n-\t  tree incr = build_int_cst (type, LLE_CONSTANT (offset));\n-\t  stmt = build_gimple_modify_stmt (resvar, build2 (PLUS_EXPR, type,\n-\t\t\t\t\t\t\t   name, incr));\n-\t  name = make_ssa_name (resvar, stmt);\n-\t  GIMPLE_STMT_OPERAND (stmt, 0) = name;\n-\t  fold_stmt (&stmt);\n-\t  tsi = tsi_last (stmts);\n-\t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n-\t}\n-\n-      /* Handle any denominator that occurs.  */\n-      if (LLE_DENOMINATOR (lle) != 1)\n-\t{\n-\t  stmt = build_int_cst (type, LLE_DENOMINATOR (lle));\n-\t  stmt = build2 (wrap == MAX_EXPR ? CEIL_DIV_EXPR : FLOOR_DIV_EXPR,\n-\t\t\t type, name, stmt);\n-\t  stmt = build_gimple_modify_stmt (resvar, stmt);\n-\n-\t  /* name = {ceil, floor}(name/denominator) */\n-\t  name = make_ssa_name (resvar, stmt);\n-\t  GIMPLE_STMT_OPERAND (stmt, 0) = name;\n-\t  tsi = tsi_last (stmts);\n-\t  tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n-\t}\n-      VEC_safe_push (tree, heap, results, name);\n+      expr = build_linear_expr (type, LLE_COEFFICIENTS (lle), induction_vars);\n+      expr = fold_build2 (PLUS_EXPR, type, expr,\n+\t\t\t  build_linear_expr (type, \n+\t\t\t\t\t     LLE_INVARIANT_COEFFICIENTS (lle),\n+\t\t\t\t\t     invariants));\n+\n+      k = LLE_CONSTANT (lle);\n+      if (k)\n+\texpr = fold_build2 (PLUS_EXPR, type, expr, build_int_cst (type, k));\n+\n+      k = LLE_CONSTANT (offset);\n+      if (k)\n+\texpr = fold_build2 (PLUS_EXPR, type, expr, build_int_cst (type, k));\n+\n+      k = LLE_DENOMINATOR (lle);\n+      if (k != 1)\n+\texpr = fold_build2 (wrap == MAX_EXPR ? CEIL_DIV_EXPR : FLOOR_DIV_EXPR,\n+\t\t\t    type, expr, build_int_cst (type, k));\n+\n+      expr = fold (expr);\n+      VEC_safe_push (tree, heap, results, expr);\n     }\n \n-  /* Again, out of laziness, we don't handle this case yet.  It's not\n-     hard, it just hasn't occurred.  */\n-  gcc_assert (VEC_length (tree, results) <= 2);\n-  \n+  gcc_assert (expr);\n+\n   /* We may need to wrap the results in a MAX_EXPR or MIN_EXPR.  */\n   if (VEC_length (tree, results) > 1)\n     {\n-      tree op1 = VEC_index (tree, results, 0);\n-      tree op2 = VEC_index (tree, results, 1);\n-      stmt = build_gimple_modify_stmt (resvar, build2 (wrap, type, op1, op2));\n-      name = make_ssa_name (resvar, stmt);\n-      GIMPLE_STMT_OPERAND (stmt, 0) = name;\n-      tsi = tsi_last (stmts);\n-      tsi_link_after (&tsi, stmt, TSI_CONTINUE_LINKING);\n+      size_t i;\n+      tree op;\n+\n+      expr = VEC_index (tree, results, 0);\n+      for (i = 1; VEC_iterate (tree, results, i, op); i++)\n+\texpr = fold_build2 (wrap, type, expr, op);\n     }\n \n   VEC_free (tree, heap, results);\n-  \n-  *stmts_to_insert = stmts;\n-  return name;\n+\n+  resvar = create_tmp_var (type, \"lletmp\");\n+  add_referenced_var (resvar);\n+  return force_gimple_operand (fold (expr), stmts_to_insert, true, resvar);\n }\n \n /* Transform a lambda loopnest NEW_LOOPNEST, which had TRANSFORM applied to\n@@ -1869,8 +1691,12 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \t\t\t\t\t     type,\n \t\t\t\t\t     new_ivs,\n \t\t\t\t\t     invariants, MAX_EXPR, &stmts);\n-      bsi_insert_on_edge (loop_preheader_edge (temp), stmts);\n-      bsi_commit_edge_inserts ();\n+\n+      if (stmts)\n+\t{\n+\t  bsi_insert_on_edge (loop_preheader_edge (temp), stmts);\n+\t  bsi_commit_edge_inserts ();\n+\t}\n       /* Build the new upper bound and insert its statements in the\n          basic block of the exit condition */\n       newupperbound = lle_to_gcc_expression (LL_UPPER_BOUND (newloop),\n@@ -1882,7 +1708,8 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n       exitcond = get_loop_exit_condition (temp);\n       bb = bb_for_stmt (exitcond);\n       bsi = bsi_after_labels (bb);\n-      bsi_insert_before (&bsi, stmts, BSI_NEW_STMT);\n+      if (stmts)\n+\tbsi_insert_before (&bsi, stmts, BSI_NEW_STMT);\n \n       /* Create the new iv.  */\n \n@@ -1960,10 +1787,11 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n \n \t  newiv = lbv_to_gcc_expression (newlbv, TREE_TYPE (oldiv),\n \t\t\t\t\t new_ivs, &stmts);\n-\t  bsi = bsi_for_stmt (stmt);\n-\t  /* Insert the statements to build that\n-\t     expression.  */\n-\t  bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n+\t  if (stmts)\n+\t    {\n+\t      bsi = bsi_for_stmt (stmt);\n+\t      bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n+\t    }\n \n \t  FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n \t    propagate_value (use_p, newiv);"}, {"sha": "e6fbc8ff6adfe554a57598bc0dbd821bdb9c5511", "filename": "gcc/lambda.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f2880c76592888802df4ab3621b9f32cf1523b/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f2880c76592888802df4ab3621b9f32cf1523b/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=69f2880c76592888802df4ab3621b9f32cf1523b", "patch": "@@ -434,5 +434,32 @@ lambda_vector_lexico_pos (lambda_vector v,\n   return true;\n }\n \n+/* Given a vector of induction variables IVS, and a vector of\n+   coefficients COEFS, build a tree that is a linear combination of\n+   the induction variables.  */\n+\n+static inline tree\n+build_linear_expr (tree type, lambda_vector coefs, VEC (tree, heap) *ivs)\n+{\n+  unsigned i;\n+  tree iv;\n+  tree expr = fold_convert (type, integer_zero_node);\n+\n+  for (i = 0; VEC_iterate (tree, ivs, i, iv); i++)\n+    {\n+      int k = coefs[i];\n+\n+      if (k == 1)\n+\texpr = fold_build2 (PLUS_EXPR, type, expr, iv);\n+\n+      else if (k != 0)\n+\texpr = fold_build2 (PLUS_EXPR, type, expr,\n+\t\t\t    fold_build2 (MULT_EXPR, type, iv,\n+\t\t\t\t\t build_int_cst (type, k)));\n+    }\n+\n+  return expr;\n+}\n+\n #endif /* LAMBDA_H  */\n "}, {"sha": "edf30a3d57315935c2ba903ff981791533824c47", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ltrans-6.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f2880c76592888802df4ab3621b9f32cf1523b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f2880c76592888802df4ab3621b9f32cf1523b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-6.c?ref=69f2880c76592888802df4ab3621b9f32cf1523b", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n+/* { dg-require-effective-target size32plus } */\n+\n+\n+\n+int medium_loop_interchange(int A[100][200])\n+{\n+  int i,j;\n+\n+  /* This loop should be interchanged. */\n+\n+  for(j = 0; j < 200; j++)\n+    for(i = 0; i < 100; i++)\n+      A[i][j] = A[i][j] + A[i][j];\n+\n+  return A[1][1];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"transformed loop\" 1 \"ltrans\"} } */ \n+/* { dg-final { cleanup-tree-dump \"ltrans\" } } */"}]}