{"sha": "c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdlMjc2Yjg2OWJkZWI0YTk1NzM1YzFmMDM3ZWUxYTVmNjI5ZGUzZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-01-18T14:24:46Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-01-18T14:24:46Z"}, "message": "analyzer: use \"malloc\" attribute\n\nIn dce6c58db87ebf7f4477bd3126228e73e4eeee97 msebor extended the\n\"malloc\" attribute to support user-defined allocator/deallocator\npairs.\n\nThis patch extends the \"malloc\" checker within -fanalyzer to use\nthese attributes.  It is based on an earlier patch:\n  'RFC: add \"deallocated_by\" attribute for use by analyzer'\n    https://gcc.gnu.org/pipermail/gcc-patches/2020-October/555544.html\nwhich added a different attribute.  The patch needed a lot of reworking\nto support multiple deallocators per allocator.\n\nMy hope was that this would provide a minimal level of markup that would\nsupport library-checking without requiring lots of further markup.\nI attempted to use this to detect a memory leak within a Linux\ndriver (CVE-2019-19078), by adding the attribute to mark these fns:\nextern struct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags);\nextern void usb_free_urb(struct urb *urb);\nwhere there is a leak of a \"urb\" on an error-handling path.\nUnfortunately I ran into the problem that there are various other fns\nthat take \"struct urb *\" and the analyzer conservatively assumes that a\nurb passed to them might or might not be freed and thus stops tracking\nstate for them.\n\nHence this will only detect issues for the simplest cases (without\nadding another attribute).\n\ngcc/analyzer/ChangeLog:\n\t* analyzer.h (is_std_named_call_p): New decl.\n\t* diagnostic-manager.cc (path_builder::get_sm): New.\n\t(state_change_event_creator::state_change_event_creator): Add \"pb\"\n\tparam.\n\t(state_change_event_creator::on_global_state_change): Don't consider\n\tstate changes affecting other state_machines.\n\t(state_change_event_creator::on_state_change): Likewise.\n\t(state_change_event_creator::m_pb): New field.\n\t(diagnostic_manager::add_events_for_eedge): Pass pb to visitor\n\tctor.\n\t* region-model-impl-calls.cc\n\t(region_model::impl_deallocation_call): New.\n\t* region-model.cc: Include \"attribs.h\".\n\t(region_model::on_call_post): Handle fndecls referenced by\n\t__attribute__((deallocated_by(FOO))).\n\t* region-model.h (region_model::impl_deallocation_call): New decl.\n\t* sm-malloc.cc: Include \"stringpool.h\" and \"attribs.h\".  Add\n\tleading comment.\n\t(class api): Delete.\n\t(enum resource_state): Update comment for change from api to\n\tdeallocator and deallocator_set.\n\t(allocation_state::allocation_state): Drop api param.  Add\n\t\"deallocators\" and \"deallocator\".\n\t(allocation_state::m_api): Drop field in favor of...\n\t(allocation_state::m_deallocators): New field.\n\t(allocation_state::m_deallocator): New field.\n\t(enum wording): Add WORDING_DEALLOCATED.\n\t(struct deallocator): New.\n\t(struct standard_deallocator): New.\n\t(struct custom_deallocator): New.\n\t(struct deallocator_set): New.\n\t(struct custom_deallocator_set): New.\n\t(struct standard_deallocator_set): New.\n\t(struct deallocator_set_map_traits): New.\n\t(malloc_state_machine::m_malloc): Drop field\n\t(malloc_state_machine::m_scalar_new): Likewise.\n\t(malloc_state_machine::m_vector_new): Likewise.\n\t(malloc_state_machine::m_free): New field\n\t(malloc_state_machine::m_scalar_delete): Likewise.\n\t(malloc_state_machine::m_vector_delete): Likewise.\n\t(malloc_state_machine::deallocator_map_t): New typedef.\n\t(malloc_state_machine::m_deallocator_map): New field.\n\t(malloc_state_machine::deallocator_set_cache_t): New typedef.\n\t(malloc_state_machine::m_custom_deallocator_set_cache): New field.\n\t(malloc_state_machine::custom_deallocator_set_map_t): New typedef.\n\t(malloc_state_machine::m_custom_deallocator_set_map): New field.\n\t(malloc_state_machine::m_dynamic_sets): New field.\n\t(malloc_state_machine::m_dynamic_deallocators): New field.\n\t(api::api): Delete.\n\t(deallocator::deallocator): New ctor.\n\t(deallocator::hash): New.\n\t(deallocator::dump_to_pp): New.\n\t(deallocator::cmp): New.\n\t(deallocator::cmp_ptr_ptr): New.\n\t(standard_deallocator::standard_deallocator): New ctor.\n\t(deallocator_set::deallocator_set): New ctor.\n\t(deallocator_set::dump): New.\n\t(custom_deallocator_set::custom_deallocator_set): New ctor.\n\t(custom_deallocator_set::contains_p): New.\n\t(custom_deallocator_set::maybe_get_single): New.\n\t(custom_deallocator_set::dump_to_pp): New.\n\t(standard_deallocator_set::standard_deallocator_set): New ctor.\n\t(standard_deallocator_set::contains_p): New.\n\t(standard_deallocator_set::maybe_get_single): New.\n\t(standard_deallocator_set::dump_to_pp): New.\n\t(start_p): New.\n\t(class mismatching_deallocation): Update for conversion from api\n\tto deallocator_set and deallocator.\n\t(double_free::emit): Use %qs.\n\t(class use_after_free): Update for conversion from api to\n\tdeallocator_set and deallocator.\n\t(malloc_leak::describe_state_change): Only emit \"allocated here\" on\n\ta start->nonnull transition, rather than on other transitions to\n\tnonnull.\n\t(allocation_state::dump_to_pp): Update for conversion from api to\n\tdeallocator_set.\n\t(allocation_state::get_nonnull): Likewise.\n\t(malloc_state_machine::malloc_state_machine): Likewise.\n\t(malloc_state_machine::~malloc_state_machine): New.\n\t(malloc_state_machine::add_state): Update for conversion from api\n\tto deallocator_set.\n\t(malloc_state_machine::get_or_create_custom_deallocator_set): New.\n\t(malloc_state_machine::maybe_create_custom_deallocator_set): New.\n\t(malloc_state_machine::get_or_create_deallocator): New.\n\t(malloc_state_machine::on_stmt): Update for conversion from api\n\tto deallocator_set.  Handle \"__attribute__((malloc(FOO)))\", and\n\tthe special attribute set on FOO.\n\t(malloc_state_machine::on_allocator_call): Update for conversion\n\tfrom api to deallocator_set.  Add \"returns_nonnull\" param and use\n\tit to affect which state to transition to.\n\t(malloc_state_machine::on_deallocator_call): Update for conversion\n\tfrom api to deallocator_set.\n\ngcc/ChangeLog:\n\t* attribs.h (fndecl_dealloc_argno): New decl.\n\t* builtins.c (call_dealloc_argno): Split out second half of\n\tfunction into...\n\t(fndecl_dealloc_argno): New.\n\t* doc/extend.texi (Common Function Attributes): Document the\n\tinteraction between the analyzer and the malloc attribute.\n\t* doc/invoke.texi (Static Analyzer Options): Likewise.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/attr-malloc-1.c: New test.\n\t* gcc.dg/analyzer/attr-malloc-2.c: New test.\n\t* gcc.dg/analyzer/attr-malloc-4.c: New test.\n\t* gcc.dg/analyzer/attr-malloc-5.c: New test.\n\t* gcc.dg/analyzer/attr-malloc-6.c: New test.\n\t* gcc.dg/analyzer/attr-malloc-CVE-2019-19078-usb-leak.c: New test.\n\t* gcc.dg/analyzer/attr-malloc-misuses.c: New test.", "tree": {"sha": "04c4f55a4275afaf736344d1824aeccb4cbe195e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04c4f55a4275afaf736344d1824aeccb4cbe195e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec153f96f8943f1d2418d2248ed219358990bb5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec153f96f8943f1d2418d2248ed219358990bb5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec153f96f8943f1d2418d2248ed219358990bb5f"}], "stats": {"total": 1482, "additions": 1354, "deletions": 128}, "files": [{"sha": "f50ac662516e2de42f8257c3eee472c7177ca434", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "patch": "@@ -205,6 +205,7 @@ extern bool is_special_named_call_p (const gcall *call, const char *funcname,\n extern bool is_named_call_p (tree fndecl, const char *funcname);\n extern bool is_named_call_p (tree fndecl, const char *funcname,\n \t\t\t     const gcall *call, unsigned int num_args);\n+extern bool is_std_named_call_p (tree fndecl, const char *funcname);\n extern bool is_std_named_call_p (tree fndecl, const char *funcname,\n \t\t\t\t const gcall *call, unsigned int num_args);\n extern bool is_setjmp_call_p (const gcall *call);"}, {"sha": "22ca024f28e95823a7a3d8c3902fbba80e0e22b6", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "patch": "@@ -189,6 +189,8 @@ class path_builder\n     return m_feasibility_problem;\n   }\n \n+  const state_machine *get_sm () const { return m_sd.m_sm; }\n+\n private:\n   typedef reachability<eg_traits> enode_reachability;\n \n@@ -709,9 +711,11 @@ diagnostic_manager::build_emission_path (const path_builder &pb,\n class state_change_event_creator : public state_change_visitor\n {\n public:\n-  state_change_event_creator (const exploded_edge &eedge,\n+  state_change_event_creator (const path_builder &pb,\n+\t\t\t      const exploded_edge &eedge,\n \t\t\t      checker_path *emission_path)\n-    : m_eedge (eedge),\n+    : m_pb (pb),\n+      m_eedge (eedge),\n       m_emission_path (emission_path)\n   {}\n \n@@ -720,6 +724,8 @@ class state_change_event_creator : public state_change_visitor\n \t\t\t       state_machine::state_t dst_sm_val)\n     FINAL OVERRIDE\n   {\n+    if (&sm != m_pb.get_sm ())\n+      return false;\n     const exploded_node *src_node = m_eedge.m_src;\n     const program_point &src_point = src_node->get_point ();\n     const int src_stack_depth = src_point.get_stack_depth ();\n@@ -748,6 +754,8 @@ class state_change_event_creator : public state_change_visitor\n \t\t\tconst svalue *sval,\n \t\t\tconst svalue *dst_origin_sval) FINAL OVERRIDE\n   {\n+    if (&sm != m_pb.get_sm ())\n+      return false;\n     const exploded_node *src_node = m_eedge.m_src;\n     const program_point &src_point = src_node->get_point ();\n     const int src_stack_depth = src_point.get_stack_depth ();\n@@ -783,6 +791,7 @@ class state_change_event_creator : public state_change_visitor\n     return false;\n   }\n \n+  const path_builder &m_pb;\n   const exploded_edge &m_eedge;\n   checker_path *m_emission_path;\n };\n@@ -1002,7 +1011,7 @@ diagnostic_manager::add_events_for_eedge (const path_builder &pb,\n       | ~~~~~~~~~~~~~^~~~~\n       |              |\n       |              (3) ...to here        (end_cfg_edge_event).  */\n-  state_change_event_creator visitor (eedge, emission_path);\n+  state_change_event_creator visitor (pb, eedge, emission_path);\n   for_each_state_change (src_state, dst_state, pb.get_ext_state (),\n \t\t\t &visitor);\n "}, {"sha": "d3b66ba737569ca84f57659f88fd96d81fd10ffd", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "patch": "@@ -436,6 +436,15 @@ region_model::impl_call_strlen (const call_details &cd)\n   return true;\n }\n \n+/* Handle calls to functions referenced by\n+   __attribute__((malloc(FOO))).  */\n+\n+void\n+region_model::impl_deallocation_call (const call_details &cd)\n+{\n+  impl_call_free (cd);\n+}\n+\n } // namespace ana\n \n #endif /* #if ENABLE_ANALYZER */"}, {"sha": "cfe8a391dd9e56555fc21badb3e3aa02dff0a36a", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "patch": "@@ -65,6 +65,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/region-model-reachability.h\"\n #include \"analyzer/analyzer-selftests.h\"\n #include \"stor-layout.h\"\n+#include \"attribs.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -917,6 +918,14 @@ region_model::on_call_post (const gcall *call,\n \t  impl_call_operator_delete (cd);\n \t  return;\n \t}\n+      /* Was this fndecl referenced by\n+\t __attribute__((malloc(FOO)))?  */\n+      if (lookup_attribute (\"*dealloc\", DECL_ATTRIBUTES (callee_fndecl)))\n+\t{\n+\t  call_details cd (call, this, ctxt);\n+\t  impl_deallocation_call (cd);\n+\t  return;\n+\t}\n     }\n \n   if (unknown_side_effects)"}, {"sha": "efd1a09e3625c1bd4504a243800b133595298816", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "patch": "@@ -463,6 +463,7 @@ class region_model\n   bool impl_call_strlen (const call_details &cd);\n   bool impl_call_operator_new (const call_details &cd);\n   bool impl_call_operator_delete (const call_details &cd);\n+  void impl_deallocation_call (const call_details &cd);\n \n   void handle_unrecognized_call (const gcall *call,\n \t\t\t\t region_model_context *ctxt);"}, {"sha": "d7c76e343ff6a0d3732b2cbb647462562086a0ed", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 646, "deletions": 121, "changes": 767, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "patch": "@@ -42,21 +42,47 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/region-model.h\"\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n \n #if ENABLE_ANALYZER\n \n namespace ana {\n \n namespace {\n \n-class api;\n+/* This state machine and its various support classes track allocations\n+   and deallocations.\n+\n+   It has a few standard allocation/deallocation pairs (e.g. new/delete),\n+   and also supports user-defined ones via\n+   __attribute__ ((malloc(DEALLOCATOR))).\n+\n+   There can be more than one valid deallocator for a given allocator,\n+   for example:\n+     __attribute__ ((malloc (fclose)))\n+     __attribute__ ((malloc (freopen, 3)))\n+     FILE* fopen (const char*, const char*);\n+   A deallocator_set represents a particular set of valid deallocators.\n+\n+   We track the expected deallocator_set for a value, but not the allocation\n+   function - there could be more than one allocator per deallocator_set.\n+   For example, there could be dozens of allocators for \"free\" beyond just\n+   malloc e.g. calloc, xstrdup, etc.  We don't want to explode the number\n+   of states by tracking individual allocators in the exploded graph;\n+   we merely want to track \"this value expects to have 'free' called on it\".\n+   Perhaps we can reconstruct which allocator was used later, when emitting\n+   the path, if it's necessary for precision of wording of diagnostics.  */\n+\n+class deallocator;\n+class deallocator_set;\n class malloc_state_machine;\n \n /* An enum for discriminating between different kinds of allocation_state.  */\n \n enum resource_state\n {\n-  /* States that are independent of api.  */\n+  /* States that are independent of allocator/deallocator.  */\n \n   /* The start state.  */\n   RS_START,\n@@ -71,36 +97,42 @@ enum resource_state\n   /* Stop state, for pointers we don't want to track any more.  */\n   RS_STOP,\n \n-  /* States that relate to a specific api.  */\n+  /* States that relate to a specific deallocator_set.  */\n \n-  /* State for a pointer returned from the api's allocator that hasn't\n+  /* State for a pointer returned from an allocator that hasn't\n      been checked for NULL.\n      It could be a pointer to heap-allocated memory, or could be NULL.  */\n   RS_UNCHECKED,\n \n-  /* State for a pointer returned from the api's allocator,\n+  /* State for a pointer returned from an allocator,\n      known to be non-NULL.  */\n   RS_NONNULL,\n \n-  /* State for a pointer passed to the api's deallocator.  */\n+  /* State for a pointer passed to a deallocator.  */\n   RS_FREED\n };\n \n-/* Custom state subclass, which can optionally refer to an an api.  */\n+/* Custom state subclass, which can optionally refer to an a\n+   deallocator_set.  */\n \n struct allocation_state : public state_machine::state\n {\n   allocation_state (const char *name, unsigned id,\n-\t\t    enum resource_state rs, const api *a)\n-  : state (name, id), m_rs (rs), m_api (a)\n+\t\t    enum resource_state rs,\n+\t\t    const deallocator_set *deallocators,\n+\t\t    const deallocator *deallocator)\n+  : state (name, id), m_rs (rs),\n+    m_deallocators (deallocators),\n+    m_deallocator (deallocator)\n   {}\n \n   void dump_to_pp (pretty_printer *pp) const FINAL OVERRIDE;\n \n   const allocation_state *get_nonnull () const;\n \n   enum resource_state m_rs;\n-  const api *m_api;\n+  const deallocator_set *m_deallocators;\n+  const deallocator *m_deallocator;\n };\n \n /* An enum for choosing which wording to use in various diagnostics\n@@ -109,52 +141,186 @@ struct allocation_state : public state_machine::state\n enum wording\n {\n   WORDING_FREED,\n-  WORDING_DELETED\n+  WORDING_DELETED,\n+  WORDING_DEALLOCATED\n };\n \n-/* Represents a particular family of API calls for allocating/deallocating\n-   heap memory that should be matched e.g.\n-   - malloc/free\n-   - scalar new/delete\n-   - vector new[]/delete[]\n-   etc.\n+/* Base class representing a deallocation function,\n+   either a built-in one we know about, or one exposed via\n+   __attribute__((malloc(DEALLOCATOR))).  */\n \n-   We track the expected deallocation function, but not the allocation\n-   function - there could be more than one allocator per deallocator.  For\n-   example, there could be dozens of allocators for \"free\" beyond just\n-   malloc e.g. calloc, xstrdup, etc.  We don't want to explode the number\n-   of states by tracking individual allocators in the exploded graph;\n-   we merely want to track \"this value expects to have 'free' called on it\".\n-   Perhaps we can reconstruct which allocator was used later, when emitting\n-   the path, if it's necessary for precision of wording of diagnostics.  */\n-\n-struct api\n+struct deallocator\n {\n-  api (malloc_state_machine *sm,\n-       const char *name,\n-       const char *dealloc_funcname,\n-       enum wording wording);\n+  hashval_t hash () const;\n+  void dump_to_pp (pretty_printer *pp) const;\n+  static int cmp (const deallocator *a, const deallocator *b);\n+  static int cmp_ptr_ptr (const void *, const void *);\n \n-  /* An internal name for identifying this API in dumps.  */\n+  /* Name to use in diagnostics.  */\n   const char *m_name;\n \n-  /* The name of the deallocation function, for use in diagnostics.  */\n-  const char *m_dealloc_funcname;\n+  /* Which wording to use in diagnostics.  */\n+  enum wording m_wording;\n+\n+  /* State for a value passed to one of the deallocators.  */\n+  state_machine::state_t m_freed;\n+\n+protected:\n+  deallocator (malloc_state_machine *sm,\n+\t       const char *name,\n+\t       enum wording wording);\n+};\n+\n+/* Subclass representing a predefined deallocator.\n+   e.g. \"delete []\", without needing a specific FUNCTION_DECL\n+   ahead of time.  */\n+\n+struct standard_deallocator : public deallocator\n+{\n+  standard_deallocator (malloc_state_machine *sm,\n+\t\t\tconst char *name,\n+\t\t\tenum wording wording);\n+};\n+\n+/* Subclass representing a user-defined deallocator\n+   via __attribute__((malloc(DEALLOCATOR))) given\n+   a specific FUNCTION_DECL.  */\n+\n+struct custom_deallocator : public deallocator\n+{\n+  custom_deallocator (malloc_state_machine *sm,\n+\t\t      tree deallocator_fndecl,\n+\t\t      enum wording wording)\n+  : deallocator (sm, IDENTIFIER_POINTER (DECL_NAME (deallocator_fndecl)),\n+\t\t wording)\n+  {\n+  }\n+};\n+\n+/* Base class representing a set of possible deallocators.\n+   Often this will be just a single deallocator, but some\n+   allocators have multiple valid deallocators (e.g. the result of\n+   \"fopen\" can be closed by either \"fclose\" or \"freopen\").  */\n+\n+struct deallocator_set\n+{\n+  deallocator_set (malloc_state_machine *sm,\n+\t\t   enum wording wording);\n+  virtual ~deallocator_set () {}\n+\n+  virtual bool contains_p (const deallocator *d) const = 0;\n+  virtual const deallocator *maybe_get_single () const = 0;\n+  virtual void dump_to_pp (pretty_printer *pp) const = 0;\n+  void dump () const;\n \n   /* Which wording to use in diagnostics.  */\n   enum wording m_wording;\n \n-  /* Pointers to api-specific states.\n+  /* Pointers to states.\n      These states are owned by the state_machine base class.  */\n \n-  /* State for an unchecked result from this api's allocator.  */\n+  /* State for an unchecked result from an allocator using this set.  */\n   state_machine::state_t m_unchecked;\n \n-  /* State for a known non-NULL result from this apis's allocator.  */\n+  /* State for a known non-NULL result from such an allocator.  */\n   state_machine::state_t m_nonnull;\n+};\n \n-  /* State for a value passed to this api's deallocator.  */\n-  state_machine::state_t m_freed;\n+/* Subclass of deallocator_set representing a set of deallocators\n+   defined by one or more __attribute__((malloc(DEALLOCATOR))).  */\n+\n+struct custom_deallocator_set : public deallocator_set\n+{\n+  typedef const auto_vec <const deallocator *> *key_t;\n+\n+  custom_deallocator_set (malloc_state_machine *sm,\n+\t\t\t  const auto_vec <const deallocator *> *vec,\n+\t\t\t  //const char *name,\n+\t\t\t  //const char *dealloc_funcname,\n+\t\t\t  //unsigned arg_idx,\n+\t\t\t  enum wording wording);\n+\n+  bool contains_p (const deallocator *d) const FINAL OVERRIDE;\n+  const deallocator *maybe_get_single () const FINAL OVERRIDE;\n+  void dump_to_pp (pretty_printer *pp) const FINAL OVERRIDE;\n+\n+  auto_vec <const deallocator *> m_deallocator_vec;\n+};\n+\n+/* Subclass of deallocator_set representing a set of deallocators\n+   with a single standard_deallocator, e.g. \"delete []\".  */\n+\n+struct standard_deallocator_set : public deallocator_set\n+{\n+  standard_deallocator_set (malloc_state_machine *sm,\n+\t\t\t    const char *name,\n+\t\t\t    enum wording wording);\n+\n+  bool contains_p (const deallocator *d) const FINAL OVERRIDE;\n+  const deallocator *maybe_get_single () const FINAL OVERRIDE;\n+  void dump_to_pp (pretty_printer *pp) const FINAL OVERRIDE;\n+\n+  standard_deallocator m_deallocator;\n+};\n+\n+/* Traits class for ensuring uniqueness of deallocator_sets within\n+   malloc_state_machine.  */\n+\n+struct deallocator_set_map_traits\n+{\n+  typedef custom_deallocator_set::key_t key_type;\n+  typedef custom_deallocator_set *value_type;\n+  typedef custom_deallocator_set *compare_type;\n+\n+  static inline hashval_t hash (const key_type &k)\n+  {\n+    gcc_assert (k != NULL);\n+    gcc_assert (k != reinterpret_cast<key_type> (1));\n+\n+    hashval_t result = 0;\n+    unsigned i;\n+    const deallocator *d;\n+    FOR_EACH_VEC_ELT (*k, i, d)\n+      result ^= d->hash ();\n+    return result;\n+  }\n+  static inline bool equal_keys (const key_type &k1, const key_type &k2)\n+  {\n+    if (k1->length () != k2->length ())\n+      return false;\n+\n+    for (unsigned i = 0; i < k1->length (); i++)\n+      if ((*k1)[i] != (*k2)[i])\n+\treturn false;\n+\n+    return true;\n+  }\n+  template <typename T>\n+  static inline void remove (T &)\n+  {\n+    /* empty; the nodes are handled elsewhere.  */\n+  }\n+  template <typename T>\n+  static inline void mark_deleted (T &entry)\n+  {\n+    entry.m_key = reinterpret_cast<key_type> (1);\n+  }\n+  template <typename T>\n+  static inline void mark_empty (T &entry)\n+  {\n+    entry.m_key = NULL;\n+  }\n+  template <typename T>\n+  static inline bool is_deleted (const T &entry)\n+  {\n+    return entry.m_key == reinterpret_cast<key_type> (1);\n+  }\n+  template <typename T>\n+  static inline bool is_empty (const T &entry)\n+  {\n+    return entry.m_key == NULL;\n+  }\n+  static const bool empty_zero_p = false;\n };\n \n /* A state machine for detecting misuses of the malloc/free API.\n@@ -167,9 +333,12 @@ class malloc_state_machine : public state_machine\n   typedef allocation_state custom_data_t;\n \n   malloc_state_machine (logger *logger);\n+  ~malloc_state_machine ();\n \n   state_t\n-  add_state (const char *name, enum resource_state rs, const api *a);\n+  add_state (const char *name, enum resource_state rs,\n+\t     const deallocator_set *deallocators,\n+\t     const deallocator *deallocator);\n \n   bool inherited_state_p () const FINAL OVERRIDE { return false; }\n \n@@ -214,9 +383,9 @@ class malloc_state_machine : public state_machine\n   bool reset_when_passed_to_unknown_fn_p (state_t s,\n \t\t\t\t\t  bool is_mutable) const FINAL OVERRIDE;\n \n-  api m_malloc;\n-  api m_scalar_new;\n-  api m_vector_new;\n+  standard_deallocator_set m_free;\n+  standard_deallocator_set m_scalar_delete;\n+  standard_deallocator_set m_vector_delete;\n \n   /* States that are independent of api.  */\n \n@@ -232,33 +401,194 @@ class malloc_state_machine : public state_machine\n   state_t m_stop;\n \n private:\n+  const custom_deallocator_set *\n+  get_or_create_custom_deallocator_set (tree allocator_fndecl);\n+  custom_deallocator_set *\n+  maybe_create_custom_deallocator_set (tree allocator_fndecl);\n+  const deallocator *\n+  get_or_create_deallocator (tree deallocator_fndecl);\n+\n   void on_allocator_call (sm_context *sm_ctxt,\n \t\t\t  const gcall *call,\n-\t\t\t  const api &ap) const;\n+\t\t\t  const deallocator_set *deallocators,\n+\t\t\t  bool returns_nonnull = false) const;\n   void on_deallocator_call (sm_context *sm_ctxt,\n \t\t\t    const supernode *node,\n \t\t\t    const gcall *call,\n-\t\t\t    const api &ap) const;\n+\t\t\t    const deallocator *d,\n+\t\t\t    unsigned argno) const;\n   void on_zero_assignment (sm_context *sm_ctxt,\n \t\t\t   const gimple *stmt,\n \t\t\t   tree lhs) const;\n+\n+  /* A map for consolidating deallocators so that they are\n+     unique per deallocator FUNCTION_DECL.  */\n+  typedef hash_map<tree, deallocator *> deallocator_map_t;\n+  deallocator_map_t m_deallocator_map;\n+\n+  /* Memoized lookups from FUNCTION_DECL to custom_deallocator_set *.  */\n+  typedef hash_map<tree, custom_deallocator_set *> deallocator_set_cache_t;\n+  deallocator_set_cache_t m_custom_deallocator_set_cache;\n+\n+  /* A map for consolidating custom_deallocator_set instances.  */\n+  typedef hash_map<custom_deallocator_set::key_t,\n+\t\t   custom_deallocator_set *,\n+\t\t   deallocator_set_map_traits> custom_deallocator_set_map_t;\n+  custom_deallocator_set_map_t m_custom_deallocator_set_map;\n+\n+  /* Record of dynamically-allocated objects,  for cleanup.  */\n+  auto_vec <custom_deallocator_set *> m_dynamic_sets;\n+  auto_vec <custom_deallocator *> m_dynamic_deallocators;\n };\n \n-/* struct api.  */\n+/* struct deallocator.  */\n \n-api::api (malloc_state_machine *sm,\n-\t  const char *name,\n-\t  const char *dealloc_funcname,\n-\t  enum wording wording)\n+deallocator::deallocator (malloc_state_machine *sm,\n+\t\t\t  const char *name,\n+\t\t\t  enum wording wording)\n : m_name (name),\n-  m_dealloc_funcname (dealloc_funcname),\n   m_wording (wording),\n-  m_unchecked (sm->add_state (\"unchecked\", RS_UNCHECKED, this)),\n-  m_nonnull (sm->add_state (\"nonnull\", RS_NONNULL, this)),\n-  m_freed (sm->add_state (\"freed\", RS_FREED, this))\n+  m_freed (sm->add_state (\"freed\", RS_FREED, NULL, this))\n+{\n+}\n+\n+hashval_t\n+deallocator::hash () const\n+{\n+  return (hashval_t)m_freed->get_id ();\n+}\n+\n+void\n+deallocator::dump_to_pp (pretty_printer *pp) const\n+{\n+  pp_printf (pp, \"%qs\", m_name);\n+}\n+\n+int\n+deallocator::cmp (const deallocator *a, const deallocator *b)\n+{\n+  return (int)a->m_freed->get_id () - (int)b->m_freed->get_id ();\n+}\n+\n+int\n+deallocator::cmp_ptr_ptr (const void *a, const void *b)\n+{\n+  return cmp (*(const deallocator * const *)a,\n+\t      *(const deallocator * const *)b);\n+}\n+\n+\n+/* struct standard_deallocator : public deallocator.  */\n+\n+standard_deallocator::standard_deallocator (malloc_state_machine *sm,\n+\t\t\t\t\t    const char *name,\n+\t\t\t\t\t    enum wording wording)\n+: deallocator (sm, name, wording)\n+{\n+}\n+\n+/* struct deallocator_set.  */\n+\n+deallocator_set::deallocator_set (malloc_state_machine *sm,\n+\t\t\t\t  enum wording wording)\n+: m_wording (wording),\n+  m_unchecked (sm->add_state (\"unchecked\", RS_UNCHECKED, this, NULL)),\n+  m_nonnull (sm->add_state (\"nonnull\", RS_NONNULL, this, NULL))\n+{\n+}\n+\n+/* Dump a description of this deallocator_set to stderr.  */\n+\n+DEBUG_FUNCTION void\n+deallocator_set::dump () const\n+{\n+  pretty_printer pp;\n+  pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+  pp.buffer->stream = stderr;\n+  dump_to_pp (&pp);\n+  pp_newline (&pp);\n+  pp_flush (&pp);\n+}\n+\n+/* struct custom_deallocator_set : public deallocator_set.  */\n+\n+custom_deallocator_set::\n+custom_deallocator_set (malloc_state_machine *sm,\n+\t\t\tconst auto_vec <const deallocator *> *vec,\n+\t\t\tenum wording wording)\n+: deallocator_set (sm, wording),\n+  m_deallocator_vec (vec->length ())\n+{\n+  unsigned i;\n+  const deallocator *d;\n+  FOR_EACH_VEC_ELT (*vec, i, d)\n+    m_deallocator_vec.safe_push (d);\n+}\n+\n+bool\n+custom_deallocator_set::contains_p (const deallocator *d) const\n+{\n+  unsigned i;\n+  const deallocator *cd;\n+  FOR_EACH_VEC_ELT (m_deallocator_vec, i, cd)\n+    if (cd == d)\n+      return true;\n+  return false;\n+}\n+\n+const deallocator *\n+custom_deallocator_set::maybe_get_single () const\n+{\n+  if (m_deallocator_vec.length () == 1)\n+    return m_deallocator_vec[0];\n+  return NULL;\n+}\n+\n+void\n+custom_deallocator_set::dump_to_pp (pretty_printer *pp) const\n+{\n+  pp_character (pp, '{');\n+  unsigned i;\n+  const deallocator *d;\n+  FOR_EACH_VEC_ELT (m_deallocator_vec, i, d)\n+    {\n+      if (i > 0)\n+\tpp_string (pp, \", \");\n+      d->dump_to_pp (pp);\n+    }\n+  pp_character (pp, '}');\n+}\n+\n+/* struct standard_deallocator_set : public deallocator_set.  */\n+\n+standard_deallocator_set::standard_deallocator_set (malloc_state_machine *sm,\n+\t\t\t\t\t\t    const char *name,\n+\t\t\t\t\t\t    enum wording wording)\n+: deallocator_set (sm, wording),\n+  m_deallocator (sm, name, wording)\n {\n }\n \n+bool\n+standard_deallocator_set::contains_p (const deallocator *d) const\n+{\n+  return d == &m_deallocator;\n+}\n+\n+const deallocator *\n+standard_deallocator_set::maybe_get_single () const\n+{\n+  return &m_deallocator;\n+}\n+\n+void\n+standard_deallocator_set::dump_to_pp (pretty_printer *pp) const\n+{\n+  pp_character (pp, '{');\n+  pp_string (pp, m_deallocator.m_name);\n+  pp_character (pp, '}');\n+}\n+\n /* Return STATE cast to the custom state subclass, or NULL for the start state.\n    Everything should be an allocation_state apart from the start state.  */\n \n@@ -291,6 +621,14 @@ get_rs (state_machine::state_t state)\n     return RS_START;\n }\n \n+/* Return true if STATE is the start state.  */\n+\n+static bool\n+start_p (state_machine::state_t state)\n+{\n+  return get_rs (state) == RS_START;\n+}\n+\n /* Return true if STATE is an unchecked result from an allocator.  */\n \n static bool\n@@ -383,10 +721,10 @@ class mismatching_deallocation : public malloc_diagnostic\n {\n public:\n   mismatching_deallocation (const malloc_state_machine &sm, tree arg,\n-\t\t\t    const api *expected_dealloc,\n-\t\t\t    const api *actual_dealloc)\n+\t\t\t    const deallocator_set *expected_deallocators,\n+\t\t\t    const deallocator *actual_dealloc)\n   : malloc_diagnostic (sm, arg),\n-    m_expected_dealloc (expected_dealloc),\n+    m_expected_deallocators (expected_deallocators),\n     m_actual_dealloc (actual_dealloc)\n   {}\n \n@@ -400,11 +738,18 @@ class mismatching_deallocation : public malloc_diagnostic\n     auto_diagnostic_group d;\n     diagnostic_metadata m;\n     m.add_cwe (762); /* CWE-762: Mismatched Memory Management Routines.  */\n-    return warning_meta (rich_loc, m, OPT_Wanalyzer_mismatching_deallocation,\n-\t\t\t \"%qE should have been deallocated with %qs\"\n-\t\t\t \" but was deallocated with %qs\",\n-\t\t\t m_arg, m_expected_dealloc->m_dealloc_funcname,\n-\t\t\t m_actual_dealloc->m_dealloc_funcname);\n+    if (const deallocator *expected_dealloc\n+\t  = m_expected_deallocators->maybe_get_single ())\n+      return warning_meta (rich_loc, m, OPT_Wanalyzer_mismatching_deallocation,\n+\t\t\t   \"%qE should have been deallocated with %qs\"\n+\t\t\t   \" but was deallocated with %qs\",\n+\t\t\t   m_arg, expected_dealloc->m_name,\n+\t\t\t   m_actual_dealloc->m_name);\n+    else\n+      return warning_meta (rich_loc, m, OPT_Wanalyzer_mismatching_deallocation,\n+\t\t\t   \"%qs called on %qE returned from a mismatched\"\n+\t\t\t   \" allocation function\",\n+\t\t\t   m_actual_dealloc->m_name, m_arg);\n   }\n \n   label_text describe_state_change (const evdesc::state_change &change)\n@@ -413,29 +758,42 @@ class mismatching_deallocation : public malloc_diagnostic\n     if (unchecked_p (change.m_new_state))\n       {\n \tm_alloc_event = change.m_event_id;\n-\treturn change.formatted_print (\"allocated here\"\n-\t\t\t\t       \" (expects deallocation with %qs)\",\n-\t\t\t\t       m_expected_dealloc->m_dealloc_funcname);\n+\tif (const deallocator *expected_dealloc\n+\t    = m_expected_deallocators->maybe_get_single ())\n+\t  return change.formatted_print (\"allocated here\"\n+\t\t\t\t\t \" (expects deallocation with %qs)\",\n+\t\t\t\t\t expected_dealloc->m_name);\n+\telse\n+\t  return change.formatted_print (\"allocated here\");\n       }\n     return malloc_diagnostic::describe_state_change (change);\n   }\n \n   label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n   {\n     if (m_alloc_event.known_p ())\n-      return ev.formatted_print\n-\t(\"deallocated with %qs here;\"\n-\t \" allocation at %@ expects deallocation with %qs\",\n-\t m_actual_dealloc->m_dealloc_funcname, &m_alloc_event,\n-\t m_expected_dealloc->m_dealloc_funcname);\n+      {\n+\tif (const deallocator *expected_dealloc\n+\t    = m_expected_deallocators->maybe_get_single ())\n+\t  return ev.formatted_print\n+\t    (\"deallocated with %qs here;\"\n+\t     \" allocation at %@ expects deallocation with %qs\",\n+\t     m_actual_dealloc->m_name, &m_alloc_event,\n+\t     expected_dealloc->m_name);\n+\telse\n+\t  return ev.formatted_print\n+\t    (\"deallocated with %qs here;\"\n+\t     \" allocated at %@\",\n+\t     m_actual_dealloc->m_name, &m_alloc_event);\n+      }\n     return ev.formatted_print (\"deallocated with %qs here\",\n-\t\t\t       m_actual_dealloc->m_dealloc_funcname);\n+\t\t\t       m_actual_dealloc->m_name);\n   }\n \n private:\n   diagnostic_event_id_t m_alloc_event;\n-  const api *m_expected_dealloc;\n-  const api *m_actual_dealloc;\n+  const deallocator_set *m_expected_deallocators;\n+  const deallocator *m_actual_dealloc;\n };\n \n /* Concrete subclass for reporting double-free diagnostics.  */\n@@ -455,7 +813,7 @@ class double_free : public malloc_diagnostic\n     diagnostic_metadata m;\n     m.add_cwe (415); /* CWE-415: Double Free.  */\n     return warning_meta (rich_loc, m, OPT_Wanalyzer_double_free,\n-\t\t\t \"double-%<%s%> of %qE\", m_funcname, m_arg);\n+\t\t\t \"double-%qs of %qE\", m_funcname, m_arg);\n   }\n \n   label_text describe_state_change (const evdesc::state_change &change)\n@@ -765,9 +1123,12 @@ class use_after_free : public malloc_diagnostic\n {\n public:\n   use_after_free (const malloc_state_machine &sm, tree arg,\n-\t\t  const api *a)\n-  : malloc_diagnostic (sm, arg), m_api (a)\n-  {}\n+\t\t  const deallocator *deallocator)\n+  : malloc_diagnostic (sm, arg),\n+    m_deallocator (deallocator)\n+  {\n+    gcc_assert (deallocator);\n+  }\n \n   const char *get_kind () const FINAL OVERRIDE { return \"use_after_free\"; }\n \n@@ -778,7 +1139,7 @@ class use_after_free : public malloc_diagnostic\n     m.add_cwe (416);\n     return warning_meta (rich_loc, m, OPT_Wanalyzer_use_after_free,\n \t\t\t \"use after %<%s%> of %qE\",\n-\t\t\t m_api->m_dealloc_funcname, m_arg);\n+\t\t\t m_deallocator->m_name, m_arg);\n   }\n \n   label_text describe_state_change (const evdesc::state_change &change)\n@@ -787,24 +1148,26 @@ class use_after_free : public malloc_diagnostic\n     if (freed_p (change.m_new_state))\n       {\n \tm_free_event = change.m_event_id;\n-\tswitch (m_api->m_wording)\n+\tswitch (m_deallocator->m_wording)\n \t  {\n \t  default:\n \t    gcc_unreachable ();\n \t  case WORDING_FREED:\n \t    return label_text::borrow (\"freed here\");\n \t  case WORDING_DELETED:\n \t    return label_text::borrow (\"deleted here\");\n+\t  case WORDING_DEALLOCATED:\n+\t    return label_text::borrow (\"deallocated here\");\n \t  }\n       }\n     return malloc_diagnostic::describe_state_change (change);\n   }\n \n   label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n   {\n-    const char *funcname = m_api->m_dealloc_funcname;\n+    const char *funcname = m_deallocator->m_name;\n     if (m_free_event.known_p ())\n-      switch (m_api->m_wording)\n+      switch (m_deallocator->m_wording)\n \t{\n \tdefault:\n \t  gcc_unreachable ();\n@@ -814,6 +1177,10 @@ class use_after_free : public malloc_diagnostic\n \tcase WORDING_DELETED:\n \t  return ev.formatted_print (\"use after %<%s%> of %qE; deleted at %@\",\n \t\t\t\t     funcname, ev.m_expr, &m_free_event);\n+\tcase WORDING_DEALLOCATED:\n+\t  return ev.formatted_print (\"use after %<%s%> of %qE;\"\n+\t\t\t\t     \" deallocated at %@\",\n+\t\t\t\t     funcname, ev.m_expr, &m_free_event);\n \t}\n     else\n       return ev.formatted_print (\"use after %<%s%> of %qE\",\n@@ -822,7 +1189,7 @@ class use_after_free : public malloc_diagnostic\n \n private:\n   diagnostic_event_id_t m_free_event;\n-  const api *m_api;\n+  const deallocator *m_deallocator;\n };\n \n class malloc_leak : public malloc_diagnostic\n@@ -848,7 +1215,8 @@ class malloc_leak : public malloc_diagnostic\n   label_text describe_state_change (const evdesc::state_change &change)\n     FINAL OVERRIDE\n   {\n-    if (unchecked_p (change.m_new_state))\n+    if (unchecked_p (change.m_new_state)\n+\t|| (start_p (change.m_old_state) && nonnull_p (change.m_new_state)))\n       {\n \tm_alloc_event = change.m_event_id;\n \treturn label_text::borrow (\"allocated here\");\n@@ -969,40 +1337,161 @@ void\n allocation_state::dump_to_pp (pretty_printer *pp) const\n {\n   state_machine::state::dump_to_pp (pp);\n-  if (m_api)\n-    pp_printf (pp, \" (%s)\", m_api->m_name);\n+  if (m_deallocators)\n+    {\n+      pp_string (pp, \" (\");\n+      m_deallocators->dump_to_pp (pp);\n+      pp_character (pp, ')');\n+    }\n }\n \n-/* Given a allocation_state for an api, get the \"nonnull\" state\n-   for the corresponding allocator.  */\n+/* Given a allocation_state for a deallocator_set, get the \"nonnull\" state\n+   for the corresponding allocator(s).  */\n \n const allocation_state *\n allocation_state::get_nonnull () const\n {\n-  gcc_assert (m_api);\n-  return as_a_allocation_state (m_api->m_nonnull);\n+  gcc_assert (m_deallocators);\n+  return as_a_allocation_state (m_deallocators->m_nonnull);\n }\n \n /* malloc_state_machine's ctor.  */\n \n malloc_state_machine::malloc_state_machine (logger *logger)\n : state_machine (\"malloc\", logger),\n-  m_malloc (this, \"malloc\", \"free\", WORDING_FREED),\n-  m_scalar_new (this, \"new\", \"delete\", WORDING_DELETED),\n-  m_vector_new (this, \"new[]\", \"delete[]\", WORDING_DELETED)\n+  m_free (this, \"free\", WORDING_FREED),\n+  m_scalar_delete (this, \"delete\", WORDING_DELETED),\n+  m_vector_delete (this, \"delete[]\", WORDING_DELETED)\n {\n   gcc_assert (m_start->get_id () == 0);\n-  m_null = add_state (\"null\", RS_FREED, NULL);\n-  m_non_heap = add_state (\"non-heap\", RS_NON_HEAP, NULL);\n-  m_stop = add_state (\"stop\", RS_STOP, NULL);\n+  m_null = add_state (\"null\", RS_FREED, NULL, NULL);\n+  m_non_heap = add_state (\"non-heap\", RS_NON_HEAP, NULL, NULL);\n+  m_stop = add_state (\"stop\", RS_STOP, NULL, NULL);\n+}\n+\n+malloc_state_machine::~malloc_state_machine ()\n+{\n+  unsigned i;\n+  custom_deallocator_set *set;\n+  FOR_EACH_VEC_ELT (m_dynamic_sets, i, set)\n+    delete set;\n+  custom_deallocator *d;\n+  FOR_EACH_VEC_ELT (m_dynamic_deallocators, i, d)\n+    delete d;\n }\n \n state_machine::state_t\n malloc_state_machine::add_state (const char *name, enum resource_state rs,\n-\t\t\t\t const api *a)\n+\t\t\t\t const deallocator_set *deallocators,\n+\t\t\t\t const deallocator *deallocator)\n {\n   return add_custom_state (new allocation_state (name, alloc_state_id (),\n-\t\t\t\t\t\t rs, a));\n+\t\t\t\t\t\t rs, deallocators,\n+\t\t\t\t\t\t deallocator));\n+}\n+\n+/* If ALLOCATOR_FNDECL has any \"__attribute__((malloc(FOO)))\",\n+   return a custom_deallocator_set for them, consolidating them\n+   to ensure uniqueness of the sets.\n+\n+   Return NULL if it has no such attributes.  */\n+\n+const custom_deallocator_set *\n+malloc_state_machine::\n+get_or_create_custom_deallocator_set (tree allocator_fndecl)\n+{\n+  /* Early rejection of decls without attributes.  */\n+  tree attrs = DECL_ATTRIBUTES (allocator_fndecl);\n+  if (!attrs)\n+    return NULL;\n+\n+  /* Otherwise, call maybe_create_custom_deallocator_set,\n+     memoizing the result.  */\n+  if (custom_deallocator_set **slot\n+      = m_custom_deallocator_set_cache.get (allocator_fndecl))\n+    return *slot;\n+  custom_deallocator_set *set\n+    = maybe_create_custom_deallocator_set (allocator_fndecl);\n+  m_custom_deallocator_set_cache.put (allocator_fndecl, set);\n+  return set;\n+}\n+\n+/* Given ALLOCATOR_FNDECL, a FUNCTION_DECL with attributes,\n+   look for any \"__attribute__((malloc(FOO)))\" and return a\n+   custom_deallocator_set for them, consolidating them\n+   to ensure uniqueness of the sets.\n+\n+   Return NULL if it has no such attributes.\n+\n+   Subroutine of get_or_create_custom_deallocator_set which\n+   memoizes the result.  */\n+\n+custom_deallocator_set *\n+malloc_state_machine::\n+maybe_create_custom_deallocator_set (tree allocator_fndecl)\n+{\n+  tree attrs = DECL_ATTRIBUTES (allocator_fndecl);\n+  gcc_assert (attrs);\n+\n+  /* Look for instances of __attribute__((malloc(FOO))).  */\n+  auto_vec<const deallocator *> deallocator_vec;\n+  for (tree allocs = attrs;\n+       (allocs = lookup_attribute (\"malloc\", allocs));\n+       allocs = TREE_CHAIN (allocs))\n+    {\n+      tree args = TREE_VALUE (allocs);\n+      if (!args)\n+\tcontinue;\n+      if (TREE_VALUE (args))\n+\t{\n+\t  const deallocator *d\n+\t    = get_or_create_deallocator (TREE_VALUE (args));\n+\t  deallocator_vec.safe_push (d);\n+\t}\n+    }\n+\n+  /* If there weren't any deallocators, bail.  */\n+  if (deallocator_vec.length () == 0)\n+    return NULL;\n+\n+  /* Consolidate, so that we reuse existing deallocator_set\n+     instances.  */\n+  deallocator_vec.qsort (deallocator::cmp_ptr_ptr);\n+  custom_deallocator_set **slot\n+    = m_custom_deallocator_set_map.get (&deallocator_vec);\n+  if (slot)\n+    return *slot;\n+  custom_deallocator_set *set\n+    = new custom_deallocator_set (this, &deallocator_vec, WORDING_DEALLOCATED);\n+  m_custom_deallocator_set_map.put (&set->m_deallocator_vec, set);\n+  m_dynamic_sets.safe_push (set);\n+  return set;\n+}\n+\n+/* Get the deallocator for DEALLOCATOR_FNDECL, creating it if necessary.  */\n+\n+const deallocator *\n+malloc_state_machine::get_or_create_deallocator (tree deallocator_fndecl)\n+{\n+  deallocator **slot = m_deallocator_map.get (deallocator_fndecl);\n+  if (slot)\n+    return *slot;\n+\n+  /* Reuse \"free\".  */\n+  deallocator *d;\n+  if (is_named_call_p (deallocator_fndecl, \"free\")\n+      || is_std_named_call_p (deallocator_fndecl, \"free\"))\n+    d = &m_free.m_deallocator;\n+  else\n+    {\n+      custom_deallocator *cd\n+\t= new custom_deallocator (this, deallocator_fndecl,\n+\t\t\t\t  WORDING_DEALLOCATED);\n+      m_dynamic_deallocators.safe_push (cd);\n+      d = cd;\n+    }\n+  m_deallocator_map.put (deallocator_fndecl, d);\n+  return d;\n }\n \n /* Implementation of state_machine::on_stmt vfunc for malloc_state_machine.  */\n@@ -1024,23 +1513,25 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t    || is_named_call_p (callee_fndecl, \"strdup\", call, 1)\n \t    || is_named_call_p (callee_fndecl, \"strndup\", call, 2))\n \t  {\n-\t    on_allocator_call (sm_ctxt, call, m_malloc);\n+\t    on_allocator_call (sm_ctxt, call, &m_free);\n \t    return true;\n \t  }\n \n \tif (is_named_call_p (callee_fndecl, \"operator new\", call, 1))\n-\t  on_allocator_call (sm_ctxt, call, m_scalar_new);\n+\t  on_allocator_call (sm_ctxt, call, &m_scalar_delete);\n \telse if (is_named_call_p (callee_fndecl, \"operator new []\", call, 1))\n-\t  on_allocator_call (sm_ctxt, call, m_vector_new);\n+\t  on_allocator_call (sm_ctxt, call, &m_vector_delete);\n \telse if (is_named_call_p (callee_fndecl, \"operator delete\", call, 1)\n \t\t || is_named_call_p (callee_fndecl, \"operator delete\", call, 2))\n \t  {\n-\t    on_deallocator_call (sm_ctxt, node, call, m_scalar_new);\n+\t    on_deallocator_call (sm_ctxt, node, call,\n+\t\t\t\t &m_scalar_delete.m_deallocator, 0);\n \t    return true;\n \t  }\n \telse if (is_named_call_p (callee_fndecl, \"operator delete []\", call, 1))\n \t  {\n-\t    on_deallocator_call (sm_ctxt, node, call, m_vector_new);\n+\t    on_deallocator_call (sm_ctxt, node, call,\n+\t\t\t\t &m_vector_delete.m_deallocator, 0);\n \t    return true;\n \t  }\n \n@@ -1057,10 +1548,26 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t    || is_std_named_call_p (callee_fndecl, \"free\", call, 1)\n \t    || is_named_call_p (callee_fndecl, \"__builtin_free\", call, 1))\n \t  {\n-\t    on_deallocator_call (sm_ctxt, node, call, m_malloc);\n+\t    on_deallocator_call (sm_ctxt, node, call,\n+\t\t\t\t &m_free.m_deallocator, 0);\n \t    return true;\n \t  }\n \n+\t/* Cast away const-ness for cache-like operations.  */\n+\tmalloc_state_machine *mutable_this\n+\t  = const_cast <malloc_state_machine *> (this);\n+\n+\t/* Handle \"__attribute__((malloc(FOO)))\".   */\n+\tif (const deallocator_set *deallocators\n+\t      = mutable_this->get_or_create_custom_deallocator_set\n+\t\t  (callee_fndecl))\n+\t  {\n+\t    tree attrs = TYPE_ATTRIBUTES (TREE_TYPE (callee_fndecl));\n+\t    bool returns_nonnull\n+\t      = lookup_attribute (\"returns_nonnull\", attrs);\n+\t    on_allocator_call (sm_ctxt, call, deallocators, returns_nonnull);\n+\t  }\n+\n \t/* Handle \"__attribute__((nonnull))\".   */\n \t{\n \t  tree fntype = TREE_TYPE (callee_fndecl);\n@@ -1103,6 +1610,16 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t      BITMAP_FREE (nonnull_args);\n \t    }\n \t}\n+\n+\t/* Check for this after nonnull, so that if we have both\n+\t   then we transition to \"freed\", rather than \"checked\".  */\n+\tunsigned dealloc_argno = fndecl_dealloc_argno (callee_fndecl);\n+\tif (dealloc_argno != UINT_MAX)\n+\t  {\n+\t    const deallocator *d\n+\t      = mutable_this->get_or_create_deallocator (callee_fndecl);\n+\t    on_deallocator_call (sm_ctxt, node, call, d, dealloc_argno);\n+\t  }\n       }\n \n   if (tree lhs = sm_ctxt->is_zero_assignment (stmt))\n@@ -1162,26 +1679,32 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t      const allocation_state *astate = as_a_allocation_state (state);\n \t      sm_ctxt->warn (node, stmt, arg,\n \t\t\t     new use_after_free (*this, diag_arg,\n-\t\t\t\t\t\t astate->m_api));\n+\t\t\t\t\t\t astate->m_deallocator));\n \t      sm_ctxt->set_next_state (stmt, arg, m_stop);\n \t    }\n \t}\n     }\n   return false;\n }\n \n-/* Handle a call to an allocator.  */\n+/* Handle a call to an allocator.\n+   RETURNS_NONNULL is true if CALL is to a fndecl known to have\n+   __attribute__((returns_nonnull)).  */\n \n void\n malloc_state_machine::on_allocator_call (sm_context *sm_ctxt,\n \t\t\t\t\t const gcall *call,\n-\t\t\t\t\t const api &ap) const\n+\t\t\t\t\t const deallocator_set *deallocators,\n+\t\t\t\t\t bool returns_nonnull) const\n {\n   tree lhs = gimple_call_lhs (call);\n   if (lhs)\n     {\n       if (sm_ctxt->get_state (call, lhs) == m_start)\n-\tsm_ctxt->set_next_state (call, lhs, ap.m_unchecked);\n+\tsm_ctxt->set_next_state (call, lhs,\n+\t\t\t\t (returns_nonnull\n+\t\t\t\t  ? deallocators->m_nonnull\n+\t\t\t\t  : deallocators->m_unchecked));\n     }\n   else\n     {\n@@ -1193,48 +1716,50 @@ void\n malloc_state_machine::on_deallocator_call (sm_context *sm_ctxt,\n \t\t\t\t\t   const supernode *node,\n \t\t\t\t\t   const gcall *call,\n-\t\t\t\t\t   const api &ap) const\n+\t\t\t\t\t   const deallocator *d,\n+\t\t\t\t\t   unsigned argno) const\n {\n-  tree arg = gimple_call_arg (call, 0);\n+  if (argno >= gimple_call_num_args (call))\n+    return;\n+  tree arg = gimple_call_arg (call, argno);\n   tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \n   state_t state = sm_ctxt->get_state (call, arg);\n \n   /* start/unchecked/nonnull -> freed.  */\n   if (state == m_start)\n-    sm_ctxt->set_next_state (call, arg, ap.m_freed);\n+    sm_ctxt->set_next_state (call, arg, d->m_freed);\n   else if (unchecked_p (state) || nonnull_p (state))\n     {\n       const allocation_state *astate = as_a_allocation_state (state);\n-\n-      if (astate->m_api != &ap)\n+      gcc_assert (astate->m_deallocators);\n+      if (!astate->m_deallocators->contains_p (d))\n \t{\n \t  /* Wrong allocator.  */\n-\t  pending_diagnostic *d\n+\t  pending_diagnostic *pd\n \t    = new mismatching_deallocation (*this, diag_arg,\n-\t\t\t\t\t    astate->m_api, &ap);\n-\t  sm_ctxt->warn (node, call, arg, d);\n+\t\t\t\t\t    astate->m_deallocators,\n+\t\t\t\t\t    d);\n+\t  sm_ctxt->warn (node, call, arg, pd);\n \t}\n-      sm_ctxt->set_next_state (call, arg, ap.m_freed);\n+      sm_ctxt->set_next_state (call, arg, d->m_freed);\n     }\n \n   /* Keep state \"null\" as-is, rather than transitioning to \"freed\";\n      we don't want to complain about double-free of NULL.  */\n-\n-  else if (state == ap.m_freed)\n+  else if (state == d->m_freed)\n     {\n       /* freed -> stop, with warning.  */\n       sm_ctxt->warn (node, call, arg,\n-\t\t     new double_free (*this, diag_arg,\n-\t\t\t\t      ap.m_dealloc_funcname));\n+\t\t     new double_free (*this, diag_arg, d->m_name));\n       sm_ctxt->set_next_state (call, arg, m_stop);\n     }\n   else if (state == m_non_heap)\n     {\n       /* non-heap -> stop, with warning.  */\n       sm_ctxt->warn (node, call, arg,\n \t\t     new free_of_non_heap (*this, diag_arg,\n-\t\t\t\t\t   ap.m_dealloc_funcname));\n+\t\t\t\t\t   d->m_name));\n       sm_ctxt->set_next_state (call, arg, m_stop);\n     }\n }"}, {"sha": "21d28a47f39f2c7517b250ce8ba02ed74a763a65", "filename": "gcc/attribs.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fattribs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fattribs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.h?ref=c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "patch": "@@ -310,4 +310,6 @@ extern void init_attr_rdwr_indices (rdwr_map *, tree);\n extern attr_access *get_parm_access (rdwr_map &, tree,\n \t\t\t\t     tree = current_function_decl);\n \n+extern unsigned fndecl_dealloc_argno (tree fndecl);\n+\n #endif // GCC_ATTRIBS_H"}, {"sha": "c1115a32d91c08dd0e8075af654a51fae7de2f7d", "filename": "gcc/builtins.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "patch": "@@ -13014,6 +13014,16 @@ call_dealloc_argno (tree exp)\n   if (!fndecl)\n     return UINT_MAX;\n \n+  return fndecl_dealloc_argno (fndecl);\n+}\n+\n+/* Return the zero-based number corresponding to the argument being\n+   deallocated if FNDECL is a deallocation function or UINT_MAX\n+   if it isn't.  */\n+\n+unsigned\n+fndecl_dealloc_argno (tree fndecl)\n+{\n   /* A call to operator delete isn't recognized as one to a built-in.  */\n   if (DECL_IS_OPERATOR_DELETE_P (fndecl))\n     return 0;"}, {"sha": "8daa1c67974898e212914410e0bbeb1152595d43", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "patch": "@@ -3291,6 +3291,58 @@ __attribute__ ((malloc, malloc (fclose (1))))\n   FILE* tmpfile (void);\n @end smallexample\n \n+The warnings guarded by @option{-fanalyzer} respect allocation and\n+deallocation pairs marked with the @code{malloc}.  In particular:\n+\n+@itemize @bullet\n+\n+@item\n+The analyzer will emit a @option{-Wanalyzer-mismatching-deallocation}\n+diagnostic if there is an execution path in which the result of an\n+allocation call is passed to a different deallocator.\n+\n+@item\n+The analyzer will emit a @option{-Wanalyzer-double-free}\n+diagnostic if there is an execution path in which a value is passed\n+more than once to a deallocation call.\n+\n+@item\n+The analyzer will consider the possibility that an allocation function\n+could fail and return NULL.  It will emit\n+@option{-Wanalyzer-possible-null-dereference} and\n+@option{-Wanalyzer-possible-null-argument} diagnostics if there are\n+execution paths in which an unchecked result of an allocation call is\n+dereferenced or passed to a function requiring a non-null argument.\n+If the allocator always returns non-null, use\n+@code{__attribute__ ((returns_nonnull))} to suppress these warnings.\n+For example:\n+@smallexample\n+char *xstrdup (const char *)\n+  __attribute__((malloc (free), returns_nonnull));\n+@end smallexample\n+\n+@item\n+The analyzer will emit a @option{-Wanalyzer-use-after-free}\n+diagnostic if there is an execution path in which the memory passed\n+by pointer to a deallocation call is used after the deallocation.\n+\n+@item\n+The analyzer will emit a @option{-Wanalyzer-malloc-leak} diagnostic if\n+there is an execution path in which the result of an allocation call\n+is leaked (without being passed to the deallocation function).\n+\n+@item\n+The analyzer will emit a @option{-Wanalyzer-free-of-non-heap} diagnostic\n+if a deallocation function is used on a global or on-stack variable.\n+\n+@end itemize\n+\n+The analyzer assumes that deallocators can gracefully handle the @code{NULL}\n+pointer.  If this is not the case, the deallocator can be marked with\n+@code{__attribute__((nonnull))} so that @option{-fanalyzer} can emit\n+a @option{-Wanalyzer-possible-null-argument} diagnostic for code paths\n+in which the deallocator is called with NULL.\n+\n @item no_icf\n @cindex @code{no_icf} function attribute\n This function attribute prevents a functions from being merged with another"}, {"sha": "5077ea7df139db40d1766bc6ed3826ae18ad3018", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "patch": "@@ -9155,7 +9155,8 @@ This warning requires @option{-fanalyzer}, which enables it; use\n @option{-Wno-analyzer-double-free} to disable it.\n \n This diagnostic warns for paths through the code in which a pointer\n-can have @code{free} called on it more than once.\n+can have a deallocator called on it more than once, either @code{free},\n+or a deallocator referenced by attribute @code{malloc}.\n \n @item -Wno-analyzer-exposure-through-output-file\n @opindex Wanalyzer-exposure-through-output-file\n@@ -9196,7 +9197,8 @@ This warning requires @option{-fanalyzer}, which enables it; use\n to disable it.\n \n This diagnostic warns for paths through the code in which a\n-pointer allocated via @code{malloc} is leaked.\n+pointer allocated via an allocator is leaked: either @code{malloc},\n+or a function marked with attribute @code{malloc}.\n \n @item -Wno-analyzer-mismatching-deallocation\n @opindex Wanalyzer-mismatching-deallocation\n@@ -9207,7 +9209,10 @@ to disable it.\n \n This diagnostic warns for paths through the code in which the\n wrong deallocation function is called on a pointer value, based on\n-which function was used to allocate the pointer value.\n+which function was used to allocate the pointer value.  The diagnostic\n+will warn about mismatches between @code{free}, scalar @code{delete}\n+and vector @code{delete[]}, and those marked as allocator/deallocator\n+pairs using attribute @code{malloc}.\n \n @item -Wno-analyzer-possible-null-argument\n @opindex Wanalyzer-possible-null-argument\n@@ -9322,7 +9327,8 @@ This warning requires @option{-fanalyzer}, which enables it; use\n @option{-Wno-analyzer-use-after-free} to disable it.\n \n This diagnostic warns for paths through the code in which a\n-pointer is used after @code{free} is called on it.\n+pointer is used after a deallocator is called on it: either @code{free},\n+or a deallocator referenced by attribute @code{malloc}.\n \n @item -Wno-analyzer-use-of-pointer-in-stale-stack-frame\n @opindex Wanalyzer-use-of-pointer-in-stale-stack-frame"}, {"sha": "3de32b1b14b8cb1a0b779fdd7417bbbae286e8d2", "filename": "gcc/testsuite/gcc.dg/analyzer/attr-malloc-1.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-1.c?ref=c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "patch": "@@ -0,0 +1,75 @@\n+extern void free (void *);\n+\n+struct foo\n+{\n+  int m_int;\n+};\n+\n+extern void foo_release (struct foo *);\n+extern struct foo *foo_acquire (void)\n+  __attribute__ ((malloc (foo_release)));\n+extern void use_foo (const struct foo *)\n+  __attribute__((nonnull));\n+\n+void test_1 (void)\n+{\n+  struct foo *p = foo_acquire ();\n+  foo_release (p);\n+}\n+\n+void test_2 (void)\n+{\n+  struct foo *p = foo_acquire (); /* { dg-message \"this call could return NULL\" } */\n+  p->m_int = 42; /* { dg-warning \"dereference of possibly-NULL 'p'\" } */\n+  foo_release (p);\n+}\n+\n+void test_2a (void)\n+{\n+  struct foo *p = foo_acquire (); /* { dg-message \"this call could return NULL\" } */\n+  use_foo (p); /* { dg-warning \"use of possibly-NULL 'p' where non-null expected\" } */\n+  foo_release (p);\n+}\n+\n+void test_3 (void)\n+{\n+  struct foo *p = foo_acquire (); /* { dg-message \"allocated here\" } */\n+} /* { dg-warning \"leak of 'p'\" } */\n+\n+void test_4 (struct foo *p)\n+{\n+  foo_release (p);\n+  foo_release (p); /* { dg-warning \"double-'foo_release' of 'p'\" } */\n+}\n+\n+void test_4a (void)\n+{\n+  struct foo *p = foo_acquire ();\n+  foo_release (p);\n+  foo_release (p); /* { dg-warning \"double-'foo_release' of 'p'\" } */\n+}\n+\n+void test_5 (void)\n+{\n+  struct foo *p = foo_acquire (); /* { dg-message \"allocated here \\\\(expects deallocation with 'foo_release'\\\\)\" } */\n+  free (p); /* { dg-warning \"'p' should have been deallocated with 'foo_release' but was deallocated with 'free'\" } */\n+}\n+\n+void test_6 (struct foo *p)\n+{\n+  foo_release (p);\n+  free (p); // TODO: double-release warning!\n+}\n+\n+void test_7 ()\n+{\n+  struct foo f;\n+  foo_release (&f); /* { dg-warning \"not on the heap\" \"analyzer\" } */\n+  /* { dg-warning \"'foo_release' called on unallocated object 'f'\" \"non-analyzer\" { target *-*-* } .-1 } */\n+}\n+\n+int test_8 (struct foo *p)\n+{\n+  foo_release (p);\n+  return p->m_int; /* { dg-warning \"use after 'foo_release' of 'p'\" } */\n+}"}, {"sha": "09d941fe082064c67395ff5cf6ed7d4e25447cd2", "filename": "gcc/testsuite/gcc.dg/analyzer/attr-malloc-2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-2.c?ref=c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "patch": "@@ -0,0 +1,24 @@\n+extern void free (void *);\n+char *xstrdup (const char *)\n+  __attribute__((malloc (free), returns_nonnull));\n+\n+void test_1 (const char *s)\n+{\n+  char *p = xstrdup (s);\n+  free (p);\n+}\n+\n+/* Verify that we don't issue -Wanalyzer-possible-null-dereference\n+   when the allocator has __attribute__((returns_nonnull)).  */\n+\n+char *test_2 (const char *s)\n+{\n+  char *p = xstrdup (s);\n+  p[0] = 'a'; /* { dg-bogus \"possibly-NULL\" } */\n+  return p;\n+}\n+\n+void test_3 (const char *s)\n+{\n+  char *p = xstrdup (s); /* { dg-message \"allocated here\" } */\n+} /* { dg-warning \"leak of 'p'\" } */"}, {"sha": "1517667dfb21e4fa8fda2a4d0a66bce1ed311d1d", "filename": "gcc/testsuite/gcc.dg/analyzer/attr-malloc-4.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-4.c?ref=c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "patch": "@@ -0,0 +1,21 @@\n+/* An example where the deallocator requires non-NULL.  */\n+\n+struct foo;\n+extern void foo_release (struct foo *)\n+  __attribute__((nonnull));\n+extern struct foo *foo_acquire (void)\n+  __attribute__ ((malloc (foo_release)));\n+\n+void test_1 (void)\n+{\n+  struct foo *p = foo_acquire (); /* { dg-message \"this call could return NULL\" } */\n+  foo_release (p); /* { dg-warning \"use of possibly-NULL 'p' where non-null\" } */\n+}\n+\n+void test_2 (void)\n+{\n+  struct foo *p = foo_acquire ();\n+  if (!p)\n+    return;\n+  foo_release (p);\n+}"}, {"sha": "7ff4e57fcfbfd4f7d79efbf095b385832db2ca9b", "filename": "gcc/testsuite/gcc.dg/analyzer/attr-malloc-5.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-5.c?ref=c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "patch": "@@ -0,0 +1,12 @@\n+/* Example of extra argument to \"malloc\" attribute.  */\n+\n+struct foo;\n+extern void foo_release (int, struct foo *);\n+extern struct foo *foo_acquire (void)\n+  __attribute__ ((malloc (foo_release, 2)));\n+\n+void test_1 (void)\n+{\n+  struct foo *p = foo_acquire ();\n+  foo_release (0, p);\n+}"}, {"sha": "bd28107d0d7449c886576909bdd4e0a9cc46b279", "filename": "gcc/testsuite/gcc.dg/analyzer/attr-malloc-6.c", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-6.c?ref=c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "patch": "@@ -0,0 +1,228 @@\n+/* Adapted from gcc.dg/Wmismatched-dealloc.c.  */\n+\n+#define A(...) __attribute__ ((malloc (__VA_ARGS__)))\n+\n+typedef struct FILE   FILE;\n+typedef __SIZE_TYPE__ size_t;\n+\n+void  free (void*);\n+void* malloc (size_t);\n+void* realloc (void*, size_t);\n+\n+int   fclose (FILE*);\n+FILE* freopen (const char*, const char*, FILE*);\n+int   pclose (FILE*);\n+\n+A (fclose) A (freopen, 3)\n+  FILE* fdopen (int);\n+A (fclose) A (freopen, 3)\n+  FILE* fopen (const char*, const char*);\n+A (fclose) A (freopen, 3)\n+  FILE* fmemopen(void *, size_t, const char *);\n+A (fclose) A (freopen, 3)\n+  FILE* freopen (const char*, const char*, FILE*);\n+A (pclose) A (freopen, 3)\n+  FILE* popen (const char*, const char*);\n+A (fclose) A (freopen, 3)\n+  FILE* tmpfile (void);\n+\n+void sink (FILE*);\n+\n+\n+            void  release (void*);\n+A (release) FILE* acquire (void);\n+\n+void nowarn_fdopen (void)\n+{\n+  {\n+    FILE *q = fdopen (0);\n+    if (!q)\n+      return;\n+\n+    fclose (q);\n+  }\n+\n+  {\n+    FILE *q = fdopen (0);\n+    if (!q)\n+      return;\n+\n+    q = freopen (\"1\", \"r\", q);\n+    fclose (q);\n+  }\n+\n+  {\n+    FILE *q = fdopen (0);\n+    if (!q)\n+      return;\n+\n+    sink (q);\n+  }\n+}\n+\n+\n+void warn_fdopen (void)\n+{\n+  {\n+    FILE *q = fdopen (0);     // { dg-message \"allocated here\" }\n+    release (q);              // { dg-warning \"'release' called on 'q' returned from a mismatched allocation function\" }\n+  }\n+  {\n+    FILE *q = fdopen (0);     // { dg-message \"allocated here\" }\n+    free (q);                 // { dg-warning \"'free' called on 'q' returned from a mismatched allocation function\" }\n+  }\n+\n+  {\n+    FILE *q = fdopen (0);     // { dg-message \"allocated here\" }\n+    q = realloc (q, 7);       // { dg-warning \"'realloc' called on 'q' returned from a mismatched allocation function\" }\n+    sink (q);\n+  }\n+}\n+\n+\n+void nowarn_fopen (void)\n+{\n+  {\n+    FILE *q = fopen (\"1\", \"r\");\n+    sink (q);\n+    fclose (q);\n+  }\n+\n+  {\n+    FILE *q = fopen (\"2\", \"r\");\n+    sink (q);\n+    q = freopen (\"3\", \"r\", q);\n+    sink (q);\n+    fclose (q);\n+  }\n+\n+  {\n+    FILE *q = fopen (\"4\", \"r\");\n+    sink (q);\n+  }\n+}\n+\n+\n+void warn_fopen (void)\n+{\n+  {\n+    FILE *q = fopen (\"1\", \"r\");\n+    release (q);              // { dg-warning \"'release' called on 'q' returned from a mismatched allocation function\" }\n+    fclose (q);\n+  }\n+  {\n+    FILE *q = fdopen (0);\n+    free (q);                 // { dg-warning \"'free' called on 'q' returned from a mismatched allocation function\" }\n+  }\n+\n+  {\n+    FILE *q = fdopen (0);\n+    q = realloc (q, 7);       // { dg-warning \"'realloc' called on 'q' returned from a mismatched allocation function\" }\n+    sink (q);\n+  }\n+}\n+\n+\n+void test_popen (void)\n+{\n+  {\n+    FILE *p = popen (\"1\", \"r\");\n+    sink (p);\n+    pclose (p);\n+  }\n+\n+  {\n+    FILE *p;\n+    p = popen (\"2\", \"r\");     // { dg-message \"allocated here\" }\n+    fclose (p);               // { dg-warning \"'fclose' called on 'p' returned from a mismatched allocation function\" }\n+  }\n+\n+  {\n+    /* freopen() can close a stream open by popen() but pclose() can't\n+       close the stream returned from freopen().  */\n+    FILE *p = popen (\"2\", \"r\");\n+    p = freopen (\"3\", \"r\", p);  // { dg-message \"allocated here\" }\n+    pclose (p);               // { dg-warning \"'pclose' called on 'p' returned from a mismatched allocation function\" }\n+  }\n+}\n+\n+\n+void test_tmpfile (void)\n+{\n+  {\n+    FILE *p = tmpfile ();\n+    fclose (p);\n+  }\n+\n+  {\n+    FILE *p = tmpfile ();\n+    p = freopen (\"1\", \"r\", p);\n+    fclose (p);\n+  }\n+\n+  {\n+    FILE *p = tmpfile ();     // { dg-message \"allocated here\" }\n+    pclose (p);               // { dg-warning \"'pclose' called on 'p' returned from a mismatched allocation function\" }\n+  }\n+}\n+\n+\n+void warn_malloc (void)\n+{\n+  {\n+    FILE *p = malloc (100);   // { dg-message \"allocated here\" }\n+    fclose (p);               // { dg-warning \"'p' should have been deallocated with 'free' but was deallocated with 'fclose'\" }\n+  }\n+\n+  {\n+    FILE *p = malloc (100);   // { dg-message \"allocated here\" }\n+    p = freopen (\"1\", \"r\", p);// { dg-warning \"'p' should have been deallocated with 'free' but was deallocated with 'freopen'\" }\n+    fclose (p);\n+  }\n+\n+  {\n+    FILE *p = malloc (100);   // { dg-message \"allocated here\" }\n+    pclose (p);               // { dg-warning \"'p' should have been deallocated with 'free' but was deallocated with 'pclose'\" }\n+  }\n+}\n+\n+\n+void test_acquire (void)\n+{\n+  {\n+    FILE *p = acquire ();\n+    release (p);\n+  }\n+\n+  {\n+    FILE *p = acquire ();\n+    release (p);\n+  }\n+\n+  {\n+    FILE *p = acquire ();     // { dg-message \"allocated here \\\\(expects deallocation with 'release'\\\\)\" }\n+    fclose (p);               // { dg-warning \"'p' should have been deallocated with 'release' but was deallocated with 'fclose'\" }\n+  }\n+\n+  {\n+    FILE *p = acquire ();     // { dg-message \"allocated here \\\\(expects deallocation with 'release'\\\\)\" }\n+    pclose (p);               // { dg-warning \"'p' should have been deallocated with 'release' but was deallocated with 'pclose'\" }\n+  }\n+\n+  {\n+    FILE *p = acquire ();      // { dg-message \"allocated here \\\\(expects deallocation with 'release'\\\\)\" }\n+    p = freopen (\"1\", \"r\", p); // { dg-warning \"'p' should have been deallocated with 'release' but was deallocated with 'freopen'\" }\n+    sink (p);\n+  }\n+\n+  {\n+    FILE *p = acquire ();   // { dg-message \"allocated here \\\\(expects deallocation with 'release'\\\\)\" }\n+    free (p);               // { dg-warning \"'p' should have been deallocated with 'release' but was deallocated with 'free'\" }\n+  }\n+\n+  {\n+    FILE *p = acquire ();     // { dg-message \"allocated here \\\\(expects deallocation with 'release'\\\\)\" }\n+    p = realloc (p, 123);     // { dg-warning \"'p' should have been deallocated with 'release' but was deallocated with 'realloc'\" }\n+    sink (p);\n+  }\n+}"}, {"sha": "905d50ec3f9598e5b9a5ec85bc29a4c6b85485f1", "filename": "gcc/testsuite/gcc.dg/analyzer/attr-malloc-CVE-2019-19078-usb-leak.c", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-CVE-2019-19078-usb-leak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-CVE-2019-19078-usb-leak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-CVE-2019-19078-usb-leak.c?ref=c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "patch": "@@ -0,0 +1,224 @@\n+/* Adapted from linux 5.3.11: drivers/net/wireless/ath/ath10k/usb.c\n+   Reduced reproducer for CVE-2019-19078 (leak of struct urb).  */\n+\n+typedef unsigned char u8;\n+typedef unsigned short u16;\n+typedef _Bool bool;\n+\n+#define\tENOMEM\t\t12\n+#define\tEINVAL\t\t22\n+\n+/* The original file has this licence header.  */\n+\n+// SPDX-License-Identifier: ISC\n+/*\n+ * Copyright (c) 2007-2011 Atheros Communications Inc.\n+ * Copyright (c) 2011-2012,2017 Qualcomm Atheros, Inc.\n+ * Copyright (c) 2016-2017 Erik Stromdahl <erik.stromdahl@gmail.com>\n+ */\n+\n+/* Adapted from include/linux/compiler_attributes.h.  */\n+#define __aligned(x)                    __attribute__((__aligned__(x)))\n+#define __printf(a, b)                  __attribute__((__format__(printf, a, b)))\n+\n+/* Possible macro for the new attribute.  */\n+#define __malloc(f)      __attribute__((malloc(f)));\n+\n+/* From include/linux/types.h.  */\n+\n+typedef unsigned int gfp_t;\n+\n+/* Not the real value, which is in include/linux/gfp.h.  */\n+#define GFP_ATOMIC\t32\n+\n+/* From include/linux/usb.h.  */\n+\n+struct urb;\n+extern void usb_free_urb(struct urb *urb);\n+extern struct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags)\n+  __malloc(usb_free_urb);\n+/* attribute added as part of testcase */\n+\n+extern int usb_submit_urb(/*struct urb *urb, */gfp_t mem_flags);\n+extern void usb_unanchor_urb(struct urb *urb);\n+\n+/* From drivers/net/wireless/ath/ath10k/core.h.  */\n+\n+struct ath10k;\n+\n+struct ath10k {\n+\t/* [...many other fields removed...]  */\n+\n+\t/* must be last */\n+\tu8 drv_priv[0] __aligned(sizeof(void *));\n+};\n+\n+/* From drivers/net/wireless/ath/ath10k/debug.h.  */\n+\n+enum ath10k_debug_mask {\n+\t/* [...other values removed...]  */\n+\tATH10K_DBG_USB_BULK\t= 0x00080000,\n+};\n+\n+extern unsigned int ath10k_debug_mask;\n+\n+__printf(3, 4) void __ath10k_dbg(struct ath10k *ar,\n+\t\t\t\t enum ath10k_debug_mask mask,\n+\t\t\t\t const char *fmt, ...);\n+\n+/* Simplified for now, to avoid pulling in tracepoint code.  */\n+static inline\n+bool trace_ath10k_log_dbg_enabled(void) { return 0; }\n+\n+#define ath10k_dbg(ar, dbg_mask, fmt, ...)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+\tif ((ath10k_debug_mask & dbg_mask) ||\t\t\t\\\n+\t    trace_ath10k_log_dbg_enabled())\t\t\t\\\n+\t\t__ath10k_dbg(ar, dbg_mask, fmt, ##__VA_ARGS__); \\\n+} while (0)\n+\n+/* From drivers/net/wireless/ath/ath10k/hif.h.  */\n+\n+struct ath10k_hif_sg_item {\n+\t/* [...other fields removed...]  */\n+\tvoid *transfer_context; /* NULL = tx completion callback not called */\n+};\n+\n+struct ath10k_hif_ops {\n+\t/* send a scatter-gather list to the target */\n+\tint (*tx_sg)(struct ath10k *ar, u8 pipe_id,\n+\t\t     struct ath10k_hif_sg_item *items, int n_items);\n+\t/* [...other fields removed...]  */\n+};\n+\n+/* From drivers/net/wireless/ath/ath10k/usb.h.  */\n+\n+/* tx/rx pipes for usb */\n+enum ath10k_usb_pipe_id {\n+\t/* [...other values removed...]  */\n+\tATH10K_USB_PIPE_MAX = 8\n+};\n+\n+struct ath10k_usb_pipe {\n+\t/* [...all fields removed...]  */\n+};\n+\n+/* usb device object */\n+struct ath10k_usb {\n+\t/* [...other fields removed...]  */\n+\tstruct ath10k_usb_pipe pipes[ATH10K_USB_PIPE_MAX];\n+};\n+\n+/* usb urb object */\n+struct ath10k_urb_context {\n+\t/* [...other fields removed...]  */\n+\tstruct ath10k_usb_pipe *pipe;\n+\tstruct sk_buff *skb;\n+};\n+\n+static inline struct ath10k_usb *ath10k_usb_priv(struct ath10k *ar)\n+{\n+\treturn (struct ath10k_usb *)ar->drv_priv;\n+}\n+\n+/* The source file.  */\n+\n+static void ath10k_usb_post_recv_transfers(struct ath10k *ar,\n+\t\t\t\t\t   struct ath10k_usb_pipe *recv_pipe);\n+\n+struct ath10k_urb_context *\n+ath10k_usb_alloc_urb_from_pipe(struct ath10k_usb_pipe *pipe);\n+\n+void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,\n+\t\t\t\t struct ath10k_urb_context *urb_context);\n+\n+static int ath10k_usb_hif_tx_sg(struct ath10k *ar, u8 pipe_id,\n+\t\t\t\tstruct ath10k_hif_sg_item *items, int n_items)\n+{\n+\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n+\tstruct ath10k_usb_pipe *pipe = &ar_usb->pipes[pipe_id];\n+\tstruct ath10k_urb_context *urb_context;\n+\tstruct sk_buff *skb;\n+\tstruct urb *urb;\n+\tint ret, i;\n+\n+\tfor (i = 0; i < n_items; i++) {\n+\t\turb_context = ath10k_usb_alloc_urb_from_pipe(pipe);\n+\t\tif (!urb_context) {\n+\t\t\tret = -ENOMEM;\n+\t\t\tgoto err;\n+\t\t}\n+\n+\t\tskb = items[i].transfer_context;\n+\t\turb_context->skb = skb;\n+\n+\t\turb = usb_alloc_urb(0, GFP_ATOMIC); /* { dg-message \"allocated here\" } */\n+\t\tif (!urb) {\n+\t\t\tret = -ENOMEM;\n+\t\t\tgoto err_free_urb_to_pipe;\n+\t\t}\n+\n+\t\t/* TODO: these are disabled, otherwise we conservatively\n+\t\t   assume that they could free urb.  */\n+#if 0\n+\t\tusb_fill_bulk_urb(urb,\n+\t\t\t\t  ar_usb->udev,\n+\t\t\t\t  pipe->usb_pipe_handle,\n+\t\t\t\t  skb->data,\n+\t\t\t\t  skb->len,\n+\t\t\t\t  ath10k_usb_transmit_complete, urb_context);\n+\t\tif (!(skb->len % pipe->max_packet_size)) {\n+\t\t\t/* hit a max packet boundary on this pipe */\n+\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n+\t\t}\n+\n+\t\tusb_anchor_urb(urb, &pipe->urb_submitted);\n+#endif\n+\t\t/* TODO: initial argument disabled, otherwise we conservatively\n+\t\t   assume that it could free urb.  */\n+\t\tret = usb_submit_urb(/*urb, */GFP_ATOMIC);\n+\t\tif (ret) { /* TODO: why doesn't it show this condition at default verbosity?  */\n+\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n+\t\t\t\t   \"usb bulk transmit failed: %d\\n\", ret);\n+\n+\t\t\t/* TODO: this is disabled, otherwise we conservatively\n+\t\t\t   assume that it could free urb.  */\n+#if 0\n+\t\t\tusb_unanchor_urb(urb);\n+#endif\n+\n+\t\t\tret = -EINVAL;\n+\t\t\t/* Leak of urb happens here.  */\n+\t\t\tgoto err_free_urb_to_pipe;\n+\t\t}\n+\n+\t\t/* TODO: the loop confuses the double-free checker (another\n+\t\t   instance of PR analyzer/93695).  */\n+\t\tusb_free_urb(urb); /* { dg-bogus \"double-'usb_free_urb' of 'urb'\" \"\" { xfail *-*-* } } */\n+\t}\n+\n+\treturn 0;\n+\n+err_free_urb_to_pipe:\n+\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\n+err:\n+\treturn ret; /* { dg-warning \"leak of 'urb'\" } */\n+}\n+\n+static const struct ath10k_hif_ops ath10k_usb_hif_ops = {\n+\t.tx_sg\t\t\t= ath10k_usb_hif_tx_sg,\n+};\n+\n+/* Simulate code to register the callback.  */\n+extern void callback_registration (const void *);\n+int ath10k_usb_probe(void)\n+{\n+  callback_registration(&ath10k_usb_hif_ops);\n+}\n+\n+\n+/* The original source file ends with:\n+MODULE_AUTHOR(\"Atheros Communications, Inc.\");\n+MODULE_DESCRIPTION(\"Driver support for Qualcomm Atheros 802.11ac WLAN USB devices\");\n+MODULE_LICENSE(\"Dual BSD/GPL\");\n+*/"}, {"sha": "3c6c17bdddef62f5d2abdb683dc30562a954dd60", "filename": "gcc/testsuite/gcc.dg/analyzer/attr-malloc-misuses.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-misuses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e276b869bdeb4a95735c1f037ee1a5f629de3d/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-misuses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-malloc-misuses.c?ref=c7e276b869bdeb4a95735c1f037ee1a5f629de3d", "patch": "@@ -0,0 +1,18 @@\n+extern void free (void *);\n+\n+int not_a_fn __attribute__ ((malloc (free))); /* { dg-warning \"'malloc' attribute ignored; valid only for functions\" } */\n+\n+void void_return (void) __attribute__ ((malloc(free))); /* { dg-warning \"'malloc' attribute ignored on functions returning 'void'\" } */\n+\n+void test_void_return (void)\n+{\n+  void_return ();\n+}\n+\n+extern void void_args (void); /* { dg-message \"declared here\" } */\n+void *has_malloc_with_void_args (void)\n+  __attribute__ ((malloc(void_args))); /* { dg-error \"'malloc' attribute argument 1 must take a pointer type as its first argument; have 'void'\" } */\n+\n+extern void no_args (); /* { dg-message \"declared here\" } */\n+void *has_malloc_with_no_args (void)\n+  __attribute__ ((malloc(no_args))); /* { dg-error \"'malloc' attribute argument 1 must take a pointer type as its first argument\" } */"}]}