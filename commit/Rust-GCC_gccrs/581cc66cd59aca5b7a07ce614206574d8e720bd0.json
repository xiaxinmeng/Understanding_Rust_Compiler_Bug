{"sha": "581cc66cd59aca5b7a07ce614206574d8e720bd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgxY2M2NmNkNTlhY2E1YjdhMDdjZTYxNDIwNjU3NGQ4ZTcyMGJkMA==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1991-05-31T19:51:09Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1991-05-31T19:51:09Z"}, "message": "entered into RCS\n\nFrom-SVN: r24", "tree": {"sha": "bbfe02681cc56901f0b03921760f7b7f1b842a43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbfe02681cc56901f0b03921760f7b7f1b842a43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/581cc66cd59aca5b7a07ce614206574d8e720bd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/581cc66cd59aca5b7a07ce614206574d8e720bd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/581cc66cd59aca5b7a07ce614206574d8e720bd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/581cc66cd59aca5b7a07ce614206574d8e720bd0/comments", "author": null, "committer": null, "parents": [{"sha": "8763cbe8382f82232862f753c46e3fdfc0f35e4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8763cbe8382f82232862f753c46e3fdfc0f35e4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8763cbe8382f82232862f753c46e3fdfc0f35e4e"}], "stats": {"total": 326, "additions": 326, "deletions": 0}, "files": [{"sha": "48c65a2866e0491f0829121b4522bbbec44090f1", "filename": "gcc/config/spur/spur.c", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/581cc66cd59aca5b7a07ce614206574d8e720bd0/gcc%2Fconfig%2Fspur%2Fspur.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/581cc66cd59aca5b7a07ce614206574d8e720bd0/gcc%2Fconfig%2Fspur%2Fspur.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspur%2Fspur.c?ref=581cc66cd59aca5b7a07ce614206574d8e720bd0", "patch": "@@ -0,0 +1,326 @@\n+/* Subroutines for insn-output.c for SPUR.  Adapted from routines for\n+   the Motorola 68000 family.\n+   Copyright (C) 1988, 1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+\n+static rtx find_addr_reg ();\n+\n+char *\n+output_compare (operands, opcode, exchange_opcode, \n+\t\tneg_opcode, neg_exchange_opcode)\n+     rtx *operands;\n+     char *opcode;\n+     char *exchange_opcode;\n+     char *neg_opcode;\n+     char *neg_exchange_opcode;\n+{\n+  static char buf[100];\n+  operands[2] = operands[0];\n+  if (GET_CODE (cc_prev_status.value1) == CONST_INT)\n+    {\n+      operands[1] = cc_prev_status.value1;\n+      operands[0] = cc_prev_status.value2;\n+      opcode = exchange_opcode, neg_opcode = neg_exchange_opcode;\n+    }\n+  else\n+    {\n+      operands[0] = cc_prev_status.value1;\n+      operands[1] = cc_prev_status.value2;\n+    }\n+  if (TARGET_LONG_JUMPS)\n+    sprintf (buf,\n+\t     \"cmp_br_delayed %s,%%0,%%1,1f\\n\\tnop\\n\\tjump %%l2\\n\\tnop\\n1:\",\n+\t     neg_opcode);\n+  else \n+    sprintf (buf, \"cmp_br_delayed %s,%%0,%%1,%%l2\\n\\tnop\", opcode);\n+  return buf;\n+}\n+\n+/* Return the best assembler insn template\n+   for moving operands[1] into operands[0] as a fullword.  */\n+\n+static char *\n+singlemove_string (operands)\n+     rtx *operands;\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    return \"st_32 %r1,%0\";\n+  if (GET_CODE (operands[1]) == MEM)\n+    return \"ld_32 %0,%1\\n\\tnop\";\n+  if (GET_CODE (operands[1]) == REG)\n+    return \"add_nt %0,%1,$0\";\n+  return \"add_nt %0,r0,%1\";\n+}\n+\f\n+/* Output assembler code to perform a doubleword move insn\n+   with operands OPERANDS.  */\n+\n+char *\n+output_move_double (operands)\n+     rtx *operands;\n+{\n+  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n+  rtx latehalf[2];\n+  rtx addreg0 = 0, addreg1 = 0;\n+\n+  /* First classify both operands.  */\n+\n+  if (REG_P (operands[0]))\n+    optype0 = REGOP;\n+  else if (offsettable_memref_p (operands[0]))\n+    optype0 = OFFSOP;\n+  else if (GET_CODE (operands[0]) == MEM)\n+    optype0 = MEMOP;\n+  else\n+    optype0 = RNDOP;\n+\n+  if (REG_P (operands[1]))\n+    optype1 = REGOP;\n+  else if (CONSTANT_P (operands[1]))\n+    optype1 = CNSTOP;\n+  else if (offsettable_memref_p (operands[1]))\n+    optype1 = OFFSOP;\n+  else if (GET_CODE (operands[1]) == MEM)\n+    optype1 = MEMOP;\n+  else\n+    optype1 = RNDOP;\n+\n+  /* Check for the cases that the operand constraints are not\n+     supposed to allow to happen.  Abort if we get one,\n+     because generating code for these cases is painful.  */\n+\n+  if (optype0 == RNDOP || optype1 == RNDOP)\n+    abort ();\n+\n+  /* If an operand is an unoffsettable memory ref, find a register\n+     we can increment temporarily to make it refer to the second word.  */\n+\n+  if (optype0 == MEMOP)\n+    addreg0 = find_addr_reg (XEXP (operands[0], 0));\n+\n+  if (optype1 == MEMOP)\n+    addreg1 = find_addr_reg (XEXP (operands[1], 0));\n+\n+  /* Ok, we can do one word at a time.\n+     Normally we do the low-numbered word first,\n+     but if either operand is autodecrementing then we\n+     do the high-numbered word first.\n+\n+     In either case, set up in LATEHALF the operands to use\n+     for the high-numbered word and in some cases alter the\n+     operands in OPERANDS to be suitable for the low-numbered word.  */\n+\n+  if (optype0 == REGOP)\n+    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else if (optype0 == OFFSOP)\n+    latehalf[0] = adj_offsettable_operand (operands[0], 4);\n+  else\n+    latehalf[0] = operands[0];\n+\n+  if (optype1 == REGOP)\n+    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  else if (optype1 == OFFSOP)\n+    latehalf[1] = adj_offsettable_operand (operands[1], 4);\n+  else if (optype1 == CNSTOP)\n+    {\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t{\n+\t  latehalf[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t CONST_DOUBLE_HIGH (operands[1]));\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t CONST_DOUBLE_LOW (operands[1]));\n+\t}\n+      else if (CONSTANT_P (operands[1]))\n+\tlatehalf[1] = const0_rtx;\n+    }\n+  else\n+    latehalf[1] = operands[1];\n+\n+  /* If the first move would clobber the source of the second one,\n+     do them in the other order.  This happens only for registers;\n+     such overlap can't happen in memory unless the user explicitly\n+     sets it up, and that is an undefined circumstance.  */\n+\n+  if (optype0 == REGOP && optype1 == REGOP\n+      && REGNO (operands[0]) == REGNO (latehalf[1]))\n+    {\n+      /* Make any unoffsettable addresses point at high-numbered word.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"add_nt %0,%0,$4\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"add_nt %0,%0,$4\", &addreg1);\n+\n+      /* Do that word.  */\n+      output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+      /* Undo the adds we just did.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"add_nt %0,%0,$-4\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"add_nt %0,%0,$-4\", &addreg0);\n+\n+      /* Do low-numbered word.  */\n+      return singlemove_string (operands);\n+    }\n+\n+  /* Normal case: do the two words, low-numbered first.  */\n+\n+  output_asm_insn (singlemove_string (operands), operands);\n+\n+  /* Make any unoffsettable addresses point at high-numbered word.  */\n+  if (addreg0)\n+    output_asm_insn (\"add_nt %0,%0,$4\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"add_nt %0,%0,$4\", &addreg1);\n+\n+  /* Do that word.  */\n+  output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+  /* Undo the adds we just did.  */\n+  if (addreg0)\n+    output_asm_insn (\"add_nt %0,%0,$-4\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"add_nt %0,%0,$-4\", &addreg1);\n+\n+  return \"\";\n+}\n+\f\n+static char *\n+output_fp_move_double (operands)\n+     rtx *operands;\n+{\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (FP_REG_P (operands[1]))\n+\treturn \"fmov %0,%1\";\n+      if (GET_CODE (operands[1]) == REG)\n+\t{\n+\t  rtx xoperands[2];\n+\t  int offset = - get_frame_size () - 8;\n+\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t  xoperands[0] = gen_rtx (CONST_INT, VOIDmode, offset + 4);\n+\t  output_asm_insn (\"st_32 %1,r25,%0\", xoperands);\n+\t  xoperands[1] = operands[1];\n+\t  xoperands[0] = gen_rtx (CONST_INT, VOIDmode, offset);\n+\t  output_asm_insn (\"st_32 %1,r25,%0\", xoperands);\n+\t  xoperands[1] = operands[0];\n+\t  output_asm_insn (\"ld_dbl %1,r25,%0\\n\\tnop\", xoperands);\n+\t  return \"\";\n+\t}\n+      return \"ld_dbl %0,%1\\n\\tnop\";\n+    }\n+  else if (FP_REG_P (operands[1]))\n+    {\n+      if (GET_CODE (operands[0]) == REG)\n+\t{\n+\t  rtx xoperands[2];\n+\t  int offset = - get_frame_size () - 8;\n+\t  xoperands[0] = gen_rtx (CONST_INT, VOIDmode, offset);\n+\t  xoperands[1] = operands[1];\n+\t  output_asm_insn (\"st_dbl %1,r25,%0\", xoperands);\n+\t  xoperands[1] = operands[0];\n+\t  output_asm_insn (\"ld_32 %1,r25,%0\\n\\tnop\", xoperands);\n+\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  xoperands[0] = gen_rtx (CONST_INT, VOIDmode, offset + 4);\n+\t  output_asm_insn (\"ld_32 %1,r25,%0\\n\\tnop\", xoperands);\n+\t  return \"\";\n+\t}\n+      return \"st_dbl %1,%0\";\n+    }\n+}\n+\f\n+/* Return a REG that occurs in ADDR with coefficient 1.\n+   ADDR can be effectively incremented by incrementing REG.  */\n+\n+static rtx\n+find_addr_reg (addr)\n+     rtx addr;\n+{\n+  while (GET_CODE (addr) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (addr, 0)) == REG)\n+\taddr = XEXP (addr, 0);\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\n+\taddr = XEXP (addr, 1);\n+      else if (CONSTANT_P (XEXP (addr, 0)))\n+\taddr = XEXP (addr, 1);\n+      else if (CONSTANT_P (XEXP (addr, 1)))\n+\taddr = XEXP (addr, 0);\n+      else\n+\tabort ();\n+    }\n+  if (GET_CODE (addr) == REG)\n+    return addr;\n+  abort ();\n+}\n+\f\n+/* Generate code to add a large integer constant to register, reg, storing\n+ * the result in a register, target.  Offset must be 27-bit signed quantity */\n+\n+static char *\n+output_add_large_offset (target, reg, offset)\n+     rtx target, reg;\n+     int offset;\n+{\n+  rtx operands[3];\n+  int high, n, i;\n+  operands[0] = target, operands[1] = reg;\n+    \n+  for (high = offset, n = 0; \n+       (unsigned) (high + 0x2000) >= 0x4000; \n+       high >>= 1, n += 1)\n+    ;\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode, high);\n+  output_asm_insn (\"add_nt r2,r0,%2\", operands);\n+  i = n;\n+  while (i >= 3)\n+    output_asm_insn (\"sll r2,r2,$3\", operands), i -= 3;\n+  if (i == 2) \n+    output_asm_insn (\"sll r2,r2,$2\", operands);\n+  else if (i == 1)\n+    output_asm_insn (\"sll r2,r2,$1\", operands);\n+  output_asm_insn (\"add_nt %0,r2,%1\", operands);\n+  if (offset - (high << n) != 0)\n+    {\n+      operands[2] = gen_rtx (CONST_INT, VOIDmode, offset - (high << n));\n+      output_asm_insn (\"add_nt %0,%0,%2\", operands);\n+    }\n+  return \"\";\n+}\n+\f\n+/* Additional TESTFN for matching. Like immediate_operand, but matches big\n+ * constants */\n+\n+int\n+big_immediate_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_INT);\n+}"}]}