{"sha": "5780a46bcae17e818621eb71d91b067eda11ce10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc4MGE0NmJjYWUxN2U4MTg2MjFlYjcxZDkxYjA2N2VkYTExY2UxMA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-07-26T06:51:38Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-07-26T06:51:38Z"}, "message": "configure.in: Change AM_PROG_LIBTOOL to AC_PROG_LIBTOOL.\n\n\n2000-07-25  Benjamin Kosnik  <bkoz@gnu.org>\n\n\t* configure.in: Change AM_PROG_LIBTOOL to AC_PROG_LIBTOOL. Change\n\tit back for current versions of maintainer-tools...\n\t* acinclude.m4: Some cleanups...\n\t* aclocal: Regenerated.\n\t* configure: Regenerated.\n\n\t* src/Makefile.am (CXXLINK): Add -Wl,-01 to the link line for\n\toptimizing/adapting the hash table using GNU ld.\n\t* src/Makefile.in: Regenerate.\n\n\t* bits/std_fstream.h: Parameterize __basic_file.\n\t* config/c_io_libio.cc: Add wchar_t methods for parameterization.\n\t* bits/basic_file.h: Same here.\n\n\t* bits/fstream.tcc: Shorten __retval to __ret.\n\t* bits/ostream.tcc: Same.\n\t* bits/sbuf_iter.h: Same.\n\t* bits/sstream.tcc: Same.\n\t* bits/streambuf.tcc: Same.\n\t* bits/std_fstream.h: Same.\n\t* src/string-inst.cc: Same.\n\t* src/ios.cc: Same.\n\t* config/c_io_libio.cc: Same.\n\t* bits/string.tcc: Same.\n\t* bits/std_streambuf.h: Same.\n\nFrom-SVN: r35262", "tree": {"sha": "a9919fcb1d033bf6ff836a8e87b4e1f17d8ec88e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9919fcb1d033bf6ff836a8e87b4e1f17d8ec88e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5780a46bcae17e818621eb71d91b067eda11ce10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5780a46bcae17e818621eb71d91b067eda11ce10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5780a46bcae17e818621eb71d91b067eda11ce10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5780a46bcae17e818621eb71d91b067eda11ce10/comments", "author": null, "committer": null, "parents": [{"sha": "44fc6a025a220f9db7ac0c44beba3b922b04588e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44fc6a025a220f9db7ac0c44beba3b922b04588e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44fc6a025a220f9db7ac0c44beba3b922b04588e"}], "stats": {"total": 3451, "additions": 1803, "deletions": 1648}, "files": [{"sha": "f2c350a7f54324c7da8f68e9507ee365efb30933", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5780a46bcae17e818621eb71d91b067eda11ce10", "patch": "@@ -1,7 +1,43 @@\n+2000-07-25  Benjamin Kosnik  <bkoz@gnu.org>\n+\n+\t* configure.in: Change AM_PROG_LIBTOOL to AC_PROG_LIBTOOL. Change\n+\tit back for current versions of maintainer-tools...\n+\t* acinclude.m4: Some cleanups...\n+\t* aclocal: Regenerated.\n+\t* configure: Regenerated.\n+\t\n+\t* src/Makefile.am (CXXLINK): Add -Wl,-01 to the link line for\n+\toptimizing/adapting the hash table using GNU ld.\n+\t* src/Makefile.in: Regenerate.\n+\t\n+2000-07-24  H.J. Lu  <hjl@gnu.org>\n+\n+        * src/Makefile.am (LIBIO_INCLUDES): Set to -I$(top_srcdir)/libio\n+        even if GLIBCPP_NEED_LIBIO is false. The installed glibc header\n+        files don't include private libio header files needed by\n+        libstdc++ v3.\n+        * src/Makefile.in: Rebuild.\n+\n 2000-07-24  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n \n+\t* bits/std_fstream.h: Parameterize __basic_file.\n+\t* config/c_io_libio.cc: Add wchar_t methods for parameterization.\n+\t* bits/basic_file.h: Same here.\n+\n \t* bits/istream.tcc (getline): Tweaks.\n \n+\t* bits/fstream.tcc: Shorten __retval to __ret.\n+\t* bits/ostream.tcc: Same.\n+\t* bits/sbuf_iter.h: Same.\n+\t* bits/sstream.tcc: Same.\n+\t* bits/streambuf.tcc: Same.\n+\t* bits/std_fstream.h: Same.\n+\t* src/string-inst.cc: Same.\n+\t* src/ios.cc: Same.\n+\t* config/c_io_libio.cc: Same.\n+\t* bits/string.tcc: Same.\n+\t* bits/std_streambuf.h: Same.\n+\n 2000-07-23  Brent Verner <brent@rcfile.org>\n \n         * bits/istream.tcc: istream::getline(char_type*, streamsize,"}, {"sha": "4a9121ece18c6f312bd78b3faf590d90b4d86ba5", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 70, "deletions": 65, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=5780a46bcae17e818621eb71d91b067eda11ce10", "patch": "@@ -1,3 +1,4 @@\n+\n dnl\n dnl Initialize configure bits.\n dnl\n@@ -27,10 +28,11 @@ AC_DEFUN(GLIBCPP_CONFIGURE, [\n   fi\n   AC_SUBST(glibcpp_basedir)\n \n-  AC_CANONICAL_HOST\n-\n   AM_INIT_AUTOMAKE(libstdc++, 2.90.8)\n \n+\n+#  AC_PROG_CC\n+\n # FIXME: We temporarily define our own version of AC_PROG_CC.  This is\n # copied from autoconf 2.12, but does not call AC_PROG_CC_WORKS.  We\n # are probably using a cross compiler, which will not be able to fully\n@@ -73,6 +75,9 @@ fi\n \n LIB_AC_PROG_CC\n \n+# Can't just call these here as g++ requires libstc++ to be built....\n+#  AC_PROG_CXX\n+\n # Likewise for AC_PROG_CXX.\n AC_DEFUN(LIB_AC_PROG_CXX,\n [AC_BEFORE([$0], [AC_PROG_CXXCPP])dnl\n@@ -107,49 +112,42 @@ fi\n \n LIB_AC_PROG_CXX\n \n-# AC_CHECK_TOOL does AC_REQUIRE (AC_CANONICAL_BUILD).  If we dont\n-# run it explicitly here, it will be run implicitly before\n-# LIBGCJ_CONFIGURE, which doesn't work because that means that it will\n-# be run before AC_CANONICAL_HOST.\n-AC_CANONICAL_BUILD\n-\n-AC_CHECK_TOOL(AS, as)\n-AC_CHECK_TOOL(AR, ar)\n-AC_CHECK_TOOL(RANLIB, ranlib, :)\n-\n-AC_PROG_INSTALL\n-\n-AM_MAINTAINER_MODE\n-\n-# We need AC_EXEEXT to keep automake happy in cygnus mode.  However,\n-# at least currently, we never actually build a program, so we never\n-# need to use $(EXEEXT).  Moreover, the test for EXEEXT normally\n-# fails, because we are probably configuring with a cross compiler\n-# which cant create executables.  So we include AC_EXEEXT to keep\n-# automake happy, but we dont execute it, since we dont care about\n-# the result.\n-if false; then\n-  AC_EXEEXT\n-fi\n+  AC_CHECK_TOOL(AS, as)\n+  AC_CHECK_TOOL(AR, ar)\n+  AC_CHECK_TOOL(RANLIB, ranlib, :)\n+\n+  AC_PROG_INSTALL\n \n-# configure.host sets the following important variables\n-#\tglibcpp_cflags    - host specific C compiler flags\n-#\tglibcpp_cxxflags  - host specific C++ compiler flags\n+  AM_MAINTAINER_MODE\n \n-glibcpp_cflags=\n-glibcpp_cxxflags=\n+  # We need AC_EXEEXT to keep automake happy in cygnus mode.  However,\n+  # at least currently, we never actually build a program, so we never\n+  # need to use $(EXEEXT).  Moreover, the test for EXEEXT normally\n+  # fails, because we are probably configuring with a cross compiler\n+  # which cant create executables.  So we include AC_EXEEXT to keep\n+  # automake happy, but we dont execute it, since we dont care about\n+  # the result.\n+  if false; then\n+    AC_EXEEXT\n+  fi\n \n-. [$]{glibcpp_basedir}/configure.host\n+  # configure.host sets the following important variables\n+  #\tglibcpp_cflags    - host specific C compiler flags\n+  #\tglibcpp_cxxflags  - host specific C++ compiler flags\n+  glibcpp_cflags=\n+  glibcpp_cxxflags=\n \n-case [$]{glibcpp_basedir} in\n-/* | [A-Za-z]:[/\\\\]*) libgcj_flagbasedir=[$]{glibcpp_basedir} ;;\n-*) glibcpp_flagbasedir='[$](top_builddir)/'[$]{glibcpp_basedir} ;;\n-esac\n+  . [$]{glibcpp_basedir}/configure.host\n+\n+  case [$]{glibcpp_basedir} in\n+    /* | [A-Za-z]:[/\\\\]*) libgcj_flagbasedir=[$]{glibcpp_basedir} ;;\n+    *) glibcpp_flagbasedir='[$](top_builddir)/'[$]{glibcpp_basedir} ;;\n+  esac\n \n-GLIBCPP_CFLAGS=\"[$]{glibcpp_cflags}\"\n-GLIBCPP_CXXFLAGS=\"[$]{glibcpp_cxxflags}\"\n-AC_SUBST(GLIBCPP_CFLAGS)\n-AC_SUBST(GLIBCPP_CXXFLAGS)\n+  GLIBCPP_CFLAGS=\"[$]{glibcpp_cflags}\"\n+  GLIBCPP_CXXFLAGS=\"[$]{glibcpp_cxxflags}\"\n+  AC_SUBST(GLIBCPP_CFLAGS)\n+  AC_SUBST(GLIBCPP_CXXFLAGS)\n ])\n \n \n@@ -676,7 +674,7 @@ dnl GLIBCPP_CHECK_CPU\n AC_DEFUN(GLIBCPP_CHECK_CPU, [\n     AC_MSG_CHECKING([for cpu primitives directory])\n     CPU_FLAGS=\t\t\t\n-    case \"$target_cpu\" in\n+    case \"${target_cpu}\" in\n       alpha*)\n \tcpu_include_dir=\"config/cpu/alpha\"\n         ;;\n@@ -1039,14 +1037,15 @@ AC_ARG_ENABLE(debug,\n changequote(<<, >>)dnl\n <<  --enable-debug          extra debugging, turn off optimization [default=>>GLIBCPP_ENABLE_DEBUG_DEFAULT],\n changequote([, ])dnl\n-[case \"$enableval\" in\n+[case \"${enableval}\" in\n  yes) enable_debug=yes ;;\n  no)  enable_debug=no ;;\n  *)   AC_MSG_ERROR([Unknown argument to enable/disable extra debugging]) ;;\n  esac],\n enable_debug=GLIBCPP_ENABLE_DEBUG_DEFAULT)dnl\n+\n dnl Option parsed, now set things appropriately\n-case \"$enable_debug\" in\n+case \"${enable_debug}\" in\n     yes) \n \tDEBUG_FLAGS='-O0 -ggdb'\t\t\t\n \t;;\n@@ -1081,13 +1080,20 @@ changequote(<<, >>)dnl\n                                 [default=>>GLIBCPP_ENABLE_CXX_FLAGS_DEFAULT],\n changequote([, ])dnl\n [case \"x$enableval\" in\n- xyes)   AC_MSG_ERROR([--enable-cxx-flags needs compiler flags as arguments]) ;;\n- xno|x)  enable_cxx_flags='' ;;\n- *)      enable_cxx_flags=\"$enableval\" ;;\n+ xyes)   \n+\tAC_MSG_ERROR([--enable-cxx-flags needs compiler flags as arguments]) ;;\n+ xno|x)  \n+\tenable_cxx_flags='' ;;\n+ *)      \n+\tenable_cxx_flags=\"$enableval\" ;;\n  esac],\n-enable_cxx_flags='GLIBCPP_ENABLE_CXX_FLAGS_DEFAULT')dnl\n+enable_cxx_flags='GLIBCPP_ENABLE_CXX_FLAGS_DEFAULT')\n+\n dnl Thinko on my part during design.  This kludge is the workaround.\n-if test \"$enable_cxx_flags\" = \"none\"; then enable_cxx_flags=''; fi\n+if test \"$enable_cxx_flags\" = \"none\"; then \n+  enable_cxx_flags=''; \n+fi\n+\n dnl Run through flags (either default or command-line) and set anything\n dnl extra (e.g., #defines) that must accompany particular g++ options.\n if test -n \"$enable_cxx_flags\"; then\n@@ -1389,30 +1395,31 @@ AC_ARG_ENABLE(cshadow-headers,\n changequote(<<, >>)dnl\n <<  --enable-cshadow-headers construct \"shadowed\" C header files for\n                            g++ [default=>>GLIBCPP_ENABLE_SHADOW_DEFAULT],\n-changequote([, ])dnl\n-[case \"$enableval\" in\n- yes) enable_cshadow_headers=yes \n+changequote([, ])\n+  [case \"$enableval\" in\n+   yes) enable_cshadow_headers=yes \n \t;;\n- no)  enable_cshadow_headers=no \n+   no)  enable_cshadow_headers=no \n \t;;\n- *)   AC_MSG_ERROR([Unknown argument to enable/disable shadowed C headers]) \n+   *)   AC_MSG_ERROR([Unknown argument to enable/disable shadowed C headers]) \n \t;;\n- esac],\n-enable_cshadow_headers=GLIBCPP_ENABLE_SHADOW_DEFAULT)dnl\n-AC_MSG_RESULT($enable_cshadow_headers)\n-dnl Option parsed, now set things appropriately\n-dnl CSHADOWFLAGS is currently unused, but may be useful in the future.\n-case \"$enable_cshadow_headers\" in\n+  esac],\n+  enable_cshadow_headers=GLIBCPP_ENABLE_SHADOW_DEFAULT)\n+  AC_MSG_RESULT($enable_cshadow_headers)\n+\n+  dnl Option parsed, now set things appropriately\n+  dnl CSHADOWFLAGS is currently unused, but may be useful in the future.\n+  case \"$enable_cshadow_headers\" in\n     yes) \n \tCSHADOWFLAGS=\"\"\n \t;;\n     no)   \n \tCSHADOWFLAGS=\"\"\n         ;;\n-esac\n+  esac\n \n-AC_SUBST(CSHADOWFLAGS)\n-AM_CONDITIONAL(GLIBCPP_USE_CSHADOW, test \"$enable_cshadow_headers\" = yes)\n+  AC_SUBST(CSHADOWFLAGS)\n+  AM_CONDITIONAL(GLIBCPP_USE_CSHADOW, test \"$enable_cshadow_headers\" = yes)\n ])\n \n \n@@ -1508,7 +1515,7 @@ dnl Then, if any (well almost any) other make is called, and GNU make also\n dnl exists, then the other make wraps the GNU make.\n dnl\n dnl @author John Darrington <j.darrington@elvis.murdoch.edu.au>\n-dnl @version $Id: acinclude.m4,v 1.45 2000/07/21 20:59:23 gdr Exp $\n+dnl @version $Id: acinclude.m4,v 1.46 2000/07/24 16:33:55 bkoz Exp $\n dnl\n dnl #### Changes for libstdc++-v3:  reformatting and linewrapping; prepending\n dnl #### GLIBCPP_ to the macro name; adding the :-make fallback in the\n@@ -1534,5 +1541,3 @@ dnl string, '#' otherwise\n   fi\n   AC_SUBST(ifGNUmake)\n ])\n-\n-"}, {"sha": "9949c2dc20e6d08d72d6650a9f301b30347941a6", "filename": "libstdc++-v3/aclocal.m4", "status": "modified", "additions": 69, "deletions": 64, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Faclocal.m4?ref=5780a46bcae17e818621eb71d91b067eda11ce10", "patch": "@@ -10,6 +10,7 @@ dnl but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n dnl even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n dnl PARTICULAR PURPOSE.\n \n+\n dnl\n dnl Initialize configure bits.\n dnl\n@@ -39,10 +40,11 @@ AC_DEFUN(GLIBCPP_CONFIGURE, [\n   fi\n   AC_SUBST(glibcpp_basedir)\n \n-  AC_CANONICAL_HOST\n-\n   AM_INIT_AUTOMAKE(libstdc++, 2.90.8)\n \n+\n+#  AC_PROG_CC\n+\n # FIXME: We temporarily define our own version of AC_PROG_CC.  This is\n # copied from autoconf 2.12, but does not call AC_PROG_CC_WORKS.  We\n # are probably using a cross compiler, which will not be able to fully\n@@ -85,6 +87,9 @@ fi\n \n LIB_AC_PROG_CC\n \n+# Can't just call these here as g++ requires libstc++ to be built....\n+#  AC_PROG_CXX\n+\n # Likewise for AC_PROG_CXX.\n AC_DEFUN(LIB_AC_PROG_CXX,\n [AC_BEFORE([$0], [AC_PROG_CXXCPP])dnl\n@@ -119,49 +124,42 @@ fi\n \n LIB_AC_PROG_CXX\n \n-# AC_CHECK_TOOL does AC_REQUIRE (AC_CANONICAL_BUILD).  If we dont\n-# run it explicitly here, it will be run implicitly before\n-# LIBGCJ_CONFIGURE, which doesn't work because that means that it will\n-# be run before AC_CANONICAL_HOST.\n-AC_CANONICAL_BUILD\n-\n-AC_CHECK_TOOL(AS, as)\n-AC_CHECK_TOOL(AR, ar)\n-AC_CHECK_TOOL(RANLIB, ranlib, :)\n-\n-AC_PROG_INSTALL\n-\n-AM_MAINTAINER_MODE\n-\n-# We need AC_EXEEXT to keep automake happy in cygnus mode.  However,\n-# at least currently, we never actually build a program, so we never\n-# need to use $(EXEEXT).  Moreover, the test for EXEEXT normally\n-# fails, because we are probably configuring with a cross compiler\n-# which cant create executables.  So we include AC_EXEEXT to keep\n-# automake happy, but we dont execute it, since we dont care about\n-# the result.\n-if false; then\n-  AC_EXEEXT\n-fi\n+  AC_CHECK_TOOL(AS, as)\n+  AC_CHECK_TOOL(AR, ar)\n+  AC_CHECK_TOOL(RANLIB, ranlib, :)\n+\n+  AC_PROG_INSTALL\n \n-# configure.host sets the following important variables\n-#\tglibcpp_cflags    - host specific C compiler flags\n-#\tglibcpp_cxxflags  - host specific C++ compiler flags\n+  AM_MAINTAINER_MODE\n \n-glibcpp_cflags=\n-glibcpp_cxxflags=\n+  # We need AC_EXEEXT to keep automake happy in cygnus mode.  However,\n+  # at least currently, we never actually build a program, so we never\n+  # need to use $(EXEEXT).  Moreover, the test for EXEEXT normally\n+  # fails, because we are probably configuring with a cross compiler\n+  # which cant create executables.  So we include AC_EXEEXT to keep\n+  # automake happy, but we dont execute it, since we dont care about\n+  # the result.\n+  if false; then\n+    AC_EXEEXT\n+  fi\n \n-. [$]{glibcpp_basedir}/configure.host\n+  # configure.host sets the following important variables\n+  #\tglibcpp_cflags    - host specific C compiler flags\n+  #\tglibcpp_cxxflags  - host specific C++ compiler flags\n+  glibcpp_cflags=\n+  glibcpp_cxxflags=\n \n-case [$]{glibcpp_basedir} in\n-/* | [A-Za-z]:[/\\\\]*) libgcj_flagbasedir=[$]{glibcpp_basedir} ;;\n-*) glibcpp_flagbasedir='[$](top_builddir)/'[$]{glibcpp_basedir} ;;\n-esac\n+  . [$]{glibcpp_basedir}/configure.host\n+\n+  case [$]{glibcpp_basedir} in\n+    /* | [A-Za-z]:[/\\\\]*) libgcj_flagbasedir=[$]{glibcpp_basedir} ;;\n+    *) glibcpp_flagbasedir='[$](top_builddir)/'[$]{glibcpp_basedir} ;;\n+  esac\n \n-GLIBCPP_CFLAGS=\"[$]{glibcpp_cflags}\"\n-GLIBCPP_CXXFLAGS=\"[$]{glibcpp_cxxflags}\"\n-AC_SUBST(GLIBCPP_CFLAGS)\n-AC_SUBST(GLIBCPP_CXXFLAGS)\n+  GLIBCPP_CFLAGS=\"[$]{glibcpp_cflags}\"\n+  GLIBCPP_CXXFLAGS=\"[$]{glibcpp_cxxflags}\"\n+  AC_SUBST(GLIBCPP_CFLAGS)\n+  AC_SUBST(GLIBCPP_CXXFLAGS)\n ])\n \n \n@@ -688,7 +686,7 @@ dnl GLIBCPP_CHECK_CPU\n AC_DEFUN(GLIBCPP_CHECK_CPU, [\n     AC_MSG_CHECKING([for cpu primitives directory])\n     CPU_FLAGS=\t\t\t\n-    case \"$target_cpu\" in\n+    case \"${target_cpu}\" in\n       alpha*)\n \tcpu_include_dir=\"config/cpu/alpha\"\n         ;;\n@@ -1051,14 +1049,15 @@ AC_ARG_ENABLE(debug,\n changequote(<<, >>)dnl\n <<  --enable-debug          extra debugging, turn off optimization [default=>>GLIBCPP_ENABLE_DEBUG_DEFAULT],\n changequote([, ])dnl\n-[case \"$enableval\" in\n+[case \"${enableval}\" in\n  yes) enable_debug=yes ;;\n  no)  enable_debug=no ;;\n  *)   AC_MSG_ERROR([Unknown argument to enable/disable extra debugging]) ;;\n  esac],\n enable_debug=GLIBCPP_ENABLE_DEBUG_DEFAULT)dnl\n+\n dnl Option parsed, now set things appropriately\n-case \"$enable_debug\" in\n+case \"${enable_debug}\" in\n     yes) \n \tDEBUG_FLAGS='-O0 -ggdb'\t\t\t\n \t;;\n@@ -1093,13 +1092,20 @@ changequote(<<, >>)dnl\n                                 [default=>>GLIBCPP_ENABLE_CXX_FLAGS_DEFAULT],\n changequote([, ])dnl\n [case \"x$enableval\" in\n- xyes)   AC_MSG_ERROR([--enable-cxx-flags needs compiler flags as arguments]) ;;\n- xno|x)  enable_cxx_flags='' ;;\n- *)      enable_cxx_flags=\"$enableval\" ;;\n+ xyes)   \n+\tAC_MSG_ERROR([--enable-cxx-flags needs compiler flags as arguments]) ;;\n+ xno|x)  \n+\tenable_cxx_flags='' ;;\n+ *)      \n+\tenable_cxx_flags=\"$enableval\" ;;\n  esac],\n-enable_cxx_flags='GLIBCPP_ENABLE_CXX_FLAGS_DEFAULT')dnl\n+enable_cxx_flags='GLIBCPP_ENABLE_CXX_FLAGS_DEFAULT')\n+\n dnl Thinko on my part during design.  This kludge is the workaround.\n-if test \"$enable_cxx_flags\" = \"none\"; then enable_cxx_flags=''; fi\n+if test \"$enable_cxx_flags\" = \"none\"; then \n+  enable_cxx_flags=''; \n+fi\n+\n dnl Run through flags (either default or command-line) and set anything\n dnl extra (e.g., #defines) that must accompany particular g++ options.\n if test -n \"$enable_cxx_flags\"; then\n@@ -1401,30 +1407,31 @@ AC_ARG_ENABLE(cshadow-headers,\n changequote(<<, >>)dnl\n <<  --enable-cshadow-headers construct \"shadowed\" C header files for\n                            g++ [default=>>GLIBCPP_ENABLE_SHADOW_DEFAULT],\n-changequote([, ])dnl\n-[case \"$enableval\" in\n- yes) enable_cshadow_headers=yes \n+changequote([, ])\n+  [case \"$enableval\" in\n+   yes) enable_cshadow_headers=yes \n \t;;\n- no)  enable_cshadow_headers=no \n+   no)  enable_cshadow_headers=no \n \t;;\n- *)   AC_MSG_ERROR([Unknown argument to enable/disable shadowed C headers]) \n+   *)   AC_MSG_ERROR([Unknown argument to enable/disable shadowed C headers]) \n \t;;\n- esac],\n-enable_cshadow_headers=GLIBCPP_ENABLE_SHADOW_DEFAULT)dnl\n-AC_MSG_RESULT($enable_cshadow_headers)\n-dnl Option parsed, now set things appropriately\n-dnl CSHADOWFLAGS is currently unused, but may be useful in the future.\n-case \"$enable_cshadow_headers\" in\n+  esac],\n+  enable_cshadow_headers=GLIBCPP_ENABLE_SHADOW_DEFAULT)\n+  AC_MSG_RESULT($enable_cshadow_headers)\n+\n+  dnl Option parsed, now set things appropriately\n+  dnl CSHADOWFLAGS is currently unused, but may be useful in the future.\n+  case \"$enable_cshadow_headers\" in\n     yes) \n \tCSHADOWFLAGS=\"\"\n \t;;\n     no)   \n \tCSHADOWFLAGS=\"\"\n         ;;\n-esac\n+  esac\n \n-AC_SUBST(CSHADOWFLAGS)\n-AM_CONDITIONAL(GLIBCPP_USE_CSHADOW, test \"$enable_cshadow_headers\" = yes)\n+  AC_SUBST(CSHADOWFLAGS)\n+  AM_CONDITIONAL(GLIBCPP_USE_CSHADOW, test \"$enable_cshadow_headers\" = yes)\n ])\n \n \n@@ -1547,8 +1554,6 @@ dnl string, '#' otherwise\n   AC_SUBST(ifGNUmake)\n ])\n \n-\n-\n # Do all the work for Automake.  This macro actually does too much --\n # some checks are only needed if your package does certain things.\n # But this isn't really a big deal."}, {"sha": "4d5d41f77933a7f86eb7636c62ea4d36df47cc29", "filename": "libstdc++-v3/bits/basic_file.h", "status": "modified", "additions": 192, "deletions": 115, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Fbasic_file.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Fbasic_file.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fbasic_file.h?ref=5780a46bcae17e818621eb71d91b067eda11ce10", "patch": "@@ -42,129 +42,206 @@ namespace std {\n   // Some of these member functions are based on libio/filebuf.cc.\n   // Also note that the order and number of virtual functions has to precisely\n   // match the order and number in the _IO_jump_t struct defined in libioP.h.\n+  template<typename _CharT>\n #if _GLIBCPP_BASIC_FILE_INHERITANCE\n-  class __basic_file: public __c_file_type\n+    class __basic_file: public __c_file_type\n #else\n-  class __basic_file\n+    class __basic_file\n #endif\n-  {\n+    {\n #if _GLIBCPP_BASIC_FILE_ENCAPSULATION\n-    int \t\t_M_fileno;\n-    __c_file_type* \t_M_cfile;\n+      int \t\t_M_fileno;\n+      __c_file_type* \t_M_cfile;\n #endif\n \n-  public:\n-    __basic_file(__c_lock* __lock = 0);\n-\n-    void \n-    __basic_file::_M_open_mode(ios_base::openmode __mode, int& __p_mode, \n-\t\t\t       int& __rw_mode);\n-\n-    // Eqivalent to the normal fopen function.\n-    __basic_file* \n-    open(const char* __name, ios_base::openmode __mode, int __prot = 0664);\n-\n-    // Used for opening the standard streams, cin, cout, cerr, clog,\n-    // and their wide-stream equivalents. Instead of calling open, it\n-    // just sets __c_file_type->_fileno and the respective _flags bits, and\n-    // returns.\n-    __basic_file*\n-    sys_open(int __fd, ios_base::openmode __mode);\n-\n-    __basic_file* \n-    close(); \n-\n-    bool \n-    is_open();\n-\n-    // Needed by ios_base::sync_with_stdio.\n-    int get_fileno(void);\n-\n-    // NB: Must match FILE specific jump table starting here--this\n-    // means all virtual functions starting with the dtor must match,\n-    // slot by slot. For glibc-based dystems, this means the _IO_FILE\n-    // as the FILE struct and _IO_jump_t as the jump table.\n-    virtual \n-    ~__basic_file(); // Takes the place of __finish.\n-\n-    virtual int \n-    overflow(int __c = EOF);\n-\n-    virtual int \n-    underflow();\n-\n-    virtual int \n-    uflow();\n-\n-    virtual int \n-    pbackfail(int __c);\n-\n-    // A complex \"write\" function that sets all of __c_file_type's\n-    // ponters and associated data members correctly and manages it's\n-    // relation to the external byte sequence.\n-    virtual streamsize \n-    xsputn(const char* __s, streamsize __n);\n-\n-    // A complex \"read\" function that sets all of __c_file_type's\n-    // ponters and associated data members correctly and manages it's\n-    // relation to the external byte sequence.\n-    virtual streamsize \n-    xsgetn(char* __s, streamsize __n);\n-\n-    // A complex \"seekoff\" function that sets all of __c_file_type's\n-    // ponters and associated data members correctly and manages it's\n-    // relation to the external byte sequence.\n-    virtual streamoff\n-    seekoff(streamoff __off, ios_base::seekdir __way,\n-\t    ios_base::openmode __mode = ios_base::in | ios_base::out);\n-\n-    // A complex \"seekpos\" function that sets all of __c_file_type's\n-    // pointers and associated data members correctly and manages it's\n-    // relation to the external byte sequence.\n-    virtual streamoff\n-    seekpos(streamoff __pos, \n-\t    ios_base::openmode __mode = ios_base::in | ios_base::out);\n-\n-    virtual streambuf* \n-    setbuf(char* __b, int __len);\n-\n-    virtual int \n-    sync();\n-\n-    virtual int \n-    doallocate();\n-\n-    // A simple read function for the external byte sequence, that\n-    // does no mucking around with or setting of the pointers or flags\n-    // in __c_file_type.\n-    virtual streamsize \n-    sys_read(char* __s, streamsize __n);\n-\n-    // A simple write function for the external byte sequence, that\n-    // does no mucking around with or setting of the pointers or flags\n-    // in __c_file_type.\n-    virtual streamsize \n-    sys_write(const char* __s, streamsize __n);\n-\n-    // A simple seek function for the external byte sequence, that\n-    // does no mucking around with or setting of the pointers or flags\n-    // in __c_file_type.\n-    virtual streamoff\n-    sys_seek(streamoff __off, ios_base::seekdir __way);\n-\n-    virtual int \n-    sys_close();\n-\n-    virtual int \n-    sys_stat(void* __v);\n-\n-    virtual int \n-    showmanyc();\n-\n-    virtual void \n-    imbue(void* __v);\n+    public:\n+      __basic_file(__c_lock* __lock = 0);\n+      \n+      void \n+      __basic_file::_M_open_mode(ios_base::openmode __mode, int& __p_mode, \n+\t\t\t\t int& __rw_mode);\n+      \n+      // Eqivalent to the normal fopen function.\n+      __basic_file* \n+      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);\n+\n+      // Used for opening the standard streams, cin, cout, cerr, clog,\n+      // and their wide-stream equivalents. Instead of calling open, it\n+      // just sets __c_file_type->_fileno and the respective _flags bits, and\n+      // returns.\n+      __basic_file*\n+      sys_open(int __fd, ios_base::openmode __mode);\n+\n+      __basic_file* \n+      close(); \n+\n+      bool \n+      is_open();\n+\n+      // Needed by ios_base::sync_with_stdio.\n+      int get_fileno(void);\n+\n+      // NB: Must match FILE specific jump table starting here--this\n+      // means all virtual functions starting with the dtor must match,\n+      // slot by slot. For glibc-based dystems, this means the _IO_FILE\n+      // as the FILE struct and _IO_jump_t as the jump table.\n+      virtual \n+      ~__basic_file(); // Takes the place of __finish.\n+\n+      virtual int \n+      overflow(int __c = EOF);\n+\n+      virtual int \n+      underflow();\n+\n+      virtual int \n+      uflow();\n+\n+      virtual int \n+      pbackfail(int __c);\n+\n+      // A complex \"write\" function that sets all of __c_file_type's\n+      // ponters and associated data members correctly and manages it's\n+      // relation to the external byte sequence.\n+      virtual streamsize \n+      xsputn(const char* __s, streamsize __n);\n+\n+      // A complex \"read\" function that sets all of __c_file_type's\n+      // ponters and associated data members correctly and manages it's\n+      // relation to the external byte sequence.\n+      virtual streamsize \n+      xsgetn(char* __s, streamsize __n);\n+\n+      // A complex \"seekoff\" function that sets all of __c_file_type's\n+      // ponters and associated data members correctly and manages it's\n+      // relation to the external byte sequence.\n+      virtual streamoff\n+      seekoff(streamoff __off, ios_base::seekdir __way,\n+\t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n+\n+      // A complex \"seekpos\" function that sets all of __c_file_type's\n+      // pointers and associated data members correctly and manages it's\n+      // relation to the external byte sequence.\n+      virtual streamoff\n+      seekpos(streamoff __pos, \n+\t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n+\n+      virtual streambuf* \n+      setbuf(_CharT* __b, int __len);\n+\n+      virtual int \n+      sync();\n+\n+      virtual int \n+      doallocate();\n+\n+      // A simple read function for the external byte sequence, that\n+      // does no mucking around with or setting of the pointers or flags\n+      // in __c_file_type.\n+      virtual streamsize \n+      sys_read(char* __s, streamsize __n);\n+\n+      // A simple write function for the external byte sequence, that\n+      // does no mucking around with or setting of the pointers or flags\n+      // in __c_file_type.\n+      virtual streamsize \n+      sys_write(const char* __s, streamsize __n);\n+\n+      // A simple seek function for the external byte sequence, that\n+      // does no mucking around with or setting of the pointers or flags\n+      // in __c_file_type.\n+      virtual streamoff\n+      sys_seek(streamoff __off, ios_base::seekdir __way);\n+\n+      virtual int \n+      sys_close();\n+\n+      virtual int \n+      sys_stat(void* __v);\n+\n+      virtual int \n+      showmanyc();\n+\n+      virtual void \n+      imbue(void* __v);\n     };\n \n+  // __basic_file<char> specializations\n+  template<>\n+    __basic_file<char>::__basic_file(__c_lock* __lock);\n+\n+  template<>\n+    int \n+    __basic_file<char>::overflow(int __c);\n+\n+  template<>\n+    int \n+    __basic_file<char>::underflow();\n+\n+  template<>\n+    streamsize \n+    __basic_file<char>::xsputn(const char* __s, streamsize __n);\n+\n+  template<>\n+    streamoff\n+    __basic_file<char>::seekoff(streamoff __off, ios_base::seekdir __way, \n+\t\t\t\tios_base::openmode __mode);\n+\n+  template<>\n+    streamoff\n+    __basic_file<char>::seekpos(streamoff __pos, ios_base::openmode __mode);\n+\n+  template<>\n+    streambuf* \n+    __basic_file<char>::setbuf(char* __b, int __len);\n+\n+  template<>\n+    int \n+    __basic_file<char>::sync();\n+\n+  template<>\n+    int \n+    __basic_file<char>::doallocate();\n+\n+  // __basic_file<wchar_t> specializations\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    __basic_file<wchar_t>::__basic_file(__c_lock* __lock);\n+\n+  template<>\n+    int \n+    __basic_file<wchar_t>::overflow(int __c);\n+\n+  template<>\n+    int \n+    __basic_file<wchar_t>::underflow();\n+\n+  template<>\n+    streamsize \n+    __basic_file<wchar_t>::xsputn(const char* __s, streamsize __n);\n+\n+  template<>\n+    streamoff\n+    __basic_file<wchar_t>::seekoff(streamoff __off, ios_base::seekdir __way, \n+\t\t\t\tios_base::openmode __mode);\n+\n+  template<>\n+    streamoff\n+    __basic_file<wchar_t>::seekpos(streamoff __pos, ios_base::openmode __mode);\n+\n+  template<>\n+    streambuf* \n+    __basic_file<wchar_t>::setbuf(wchar_t* __b, int __len);\n+\n+  template<>\n+    int \n+    __basic_file<wchar_t>::sync();\n+\n+  template<>\n+    int \n+    __basic_file<wchar_t>::doallocate();\n+#endif\n+\n } // namespace std\n \n #endif\t/* _CPP_BASIC_FILE */"}, {"sha": "57968a769bd361461c2d3da4d277daa7c01e0ad7", "filename": "libstdc++-v3/bits/fstream.tcc", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Ffstream.tcc?ref=5780a46bcae17e818621eb71d91b067eda11ce10", "patch": "@@ -111,7 +111,7 @@ namespace std\n     basic_filebuf<_CharT, _Traits>::\n     open(const char* __s, ios_base::openmode __mode)\n     {\n-      __filebuf_type *__retval = NULL;\n+      __filebuf_type *__ret = NULL;\n       if (!this->is_open())\n \t{\n \t  _M_filebuf_init();\n@@ -126,18 +126,18 @@ namespace std\n \t      if (__mode & ios_base::ate\n \t\t  && this->seekoff(0, ios_base::end, __mode) < 0)\n \t\tthis->close();\n-\t      __retval = this;\n+\t      __ret = this;\n \t    }\n \t}\n-      return __retval;\n+      return __ret;\n     }\n \n   template<typename _CharT, typename _Traits>\n     basic_filebuf<_CharT, _Traits>::__filebuf_type* \n     basic_filebuf<_CharT, _Traits>::\n     close()\n     {\n-      __filebuf_type *__retval = NULL;\n+      __filebuf_type *__ret = NULL;\n       if (this->is_open())\n \t{\n \t  bool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n@@ -164,7 +164,7 @@ namespace std\n \t  _M_pback = NULL;\n \t  this->setg(NULL, NULL, NULL);\n \t  this->setp(NULL, NULL);\n-\t  __retval = this;\n+\t  __ret = this;\n \t}\n \n       // Can actually allocate this file as part of an open and never\n@@ -175,15 +175,15 @@ namespace std\n \t  _M_file = NULL;\n \t}\n       _M_last_overflowed = false;\t\n-      return __retval;\n+      return __ret;\n     }\n \n   template<typename _CharT, typename _Traits>\n     streamsize \n     basic_filebuf<_CharT, _Traits>::\n     showmanyc()\n     {\n-      streamsize __retval = -1;\n+      streamsize __ret = -1;\n       bool __testin = _M_mode & ios_base::in;\n \n       if (__testin)\n@@ -192,18 +192,18 @@ namespace std\n \t  if (_M_in_cur >= _M_in_end)\n \t    __testeof = this->underflow() == traits_type::eof();\n \t  if (!__testeof)\n-\t    __retval = _M_in_end - _M_in_cur;\n+\t    __ret = _M_in_end - _M_in_cur;\n \t}\n       _M_last_overflowed = false;\t\n-      return __retval;\n+      return __ret;\n     }\n \n   template<typename _CharT, typename _Traits>\n     basic_filebuf<_CharT, _Traits>::int_type \n     basic_filebuf<_CharT, _Traits>::\n     underflow()\n     {\n-      int_type __retval = traits_type::eof();\n+      int_type __ret = traits_type::eof();\n       bool __testin = _M_mode & ios_base::in;\n       \n       if (__testin)\n@@ -265,7 +265,7 @@ namespace std\n \t\t    {\n \t\t      if (__testout)\n \t\t\t_M_out_cur = _M_in_cur;\n-\t\t      __retval = traits_type::to_int_type(*_M_in_cur);\n+\t\t      __ret = traits_type::to_int_type(*_M_in_cur);\n \t\t    }\n \n \t\t  // Part three: Sync the current internal buffer\n@@ -281,22 +281,22 @@ namespace std\n \t    }\t      \n \t}\n       _M_last_overflowed = false;\t\n-      return __retval;\n+      return __ret;\n     }\n   \n   template<typename _CharT, typename _Traits>\n     basic_filebuf<_CharT, _Traits>::int_type \n     basic_filebuf<_CharT, _Traits>::\n     pbackfail(int_type __i)\n     {\n-      int_type __retval = traits_type::eof();\n+      int_type __ret = traits_type::eof();\n       bool __testin = _M_mode & ios_base::in;\n \n       if (__testin)\n \t{\n \t  bool __testpb = _M_in_beg < _M_in_cur;\n \t  char_type __c = traits_type::to_char_type(__i);\n-\t  bool __testeof = traits_type::eq_int_type(__i, __retval);\n+\t  bool __testeof = traits_type::eq_int_type(__i, __ret);\n \n \t  if (__testpb)\n \t    {\n@@ -310,14 +310,14 @@ namespace std\n \t\t  --_M_in_cur;\n \t\t  if (__testout)\n \t\t    --_M_out_cur;\n-\t\t  __retval = __i;\n+\t\t  __ret = __i;\n \t\t}\n \t      else if (__testeof)\n \t\t{\n \t\t  --_M_in_cur;\n \t\t  if (__testout)\n \t\t    --_M_out_cur;\n-\t\t  __retval = traits_type::not_eof(__i);\n+\t\t  __ret = traits_type::not_eof(__i);\n \t\t}\n \t      else if (!__testeof)\n \t\t{\n@@ -326,7 +326,7 @@ namespace std\n \t\t    --_M_out_cur;\n \t\t  _M_pback_create();\n \t\t  *_M_in_cur = __c; \n-\t\t  __retval = __i;\n+\t\t  __ret = __i;\n \t\t}\n \t    }\n \t  else\n@@ -342,22 +342,22 @@ namespace std\n \t\t      _M_pback_create();\n \t\t      *_M_in_cur = __c;\n \t\t    }\n- \t\t  __retval = __i;\n+ \t\t  __ret = __i;\n  \t\t}\n  \t      else\n- \t\t__retval = traits_type::not_eof(__i);\n+ \t\t__ret = traits_type::not_eof(__i);\n  \t    }\n \t}\n       _M_last_overflowed = false;\t\n-      return __retval;\n+      return __ret;\n     }\n \n   template<typename _CharT, typename _Traits>\n     basic_filebuf<_CharT, _Traits>::int_type \n     basic_filebuf<_CharT, _Traits>::\n     overflow(int_type __c)\n     {\n-      int_type __retval = traits_type::eof();\n+      int_type __ret = traits_type::eof();\n       bool __testpos = _M_out_cur && _M_out_cur >= _M_buf + _M_buf_size;\n       bool __testout = _M_mode & ios_base::out;\n       \n@@ -367,22 +367,22 @@ namespace std\n \t    {\n \t      *_M_out_cur = traits_type::to_char_type(__c);\n \t      _M_out_cur_move(1);\n-\t      __retval = traits_type::not_eof(__c);\n+\t      __ret = traits_type::not_eof(__c);\n \t    }\n \t  else \n-\t    __retval = this->_M_really_overflow(__c);\n+\t    __ret = this->_M_really_overflow(__c);\n \t}\n \n       _M_last_overflowed = false;    // Set in _M_really_overflow, below.\n-      return __retval;\n+      return __ret;\n     }\n   \n   template<typename _CharT, typename _Traits>\n     basic_filebuf<_CharT, _Traits>::int_type \n     basic_filebuf<_CharT, _Traits>::\n     _M_really_overflow(int_type __c)\n     {\n-      int_type __retval = traits_type::eof();\n+      int_type __ret = traits_type::eof();\n       bool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n       bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());\n       \n@@ -424,20 +424,20 @@ namespace std\n \t      if (__len == __plen)\n \t\t{\n \t\t  _M_set_indeterminate();\n-\t\t  __retval = traits_type::not_eof(__c);\n+\t\t  __ret = traits_type::not_eof(__c);\n \t\t}\n \t    }\n \t}\t      \n       _M_last_overflowed = true;\t\n-      return __retval;\n+      return __ret;\n     }\n \n   template<typename _CharT, typename _Traits>\n     basic_filebuf<_CharT, _Traits>::pos_type\n     basic_filebuf<_CharT, _Traits>::\n     seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)\n     {\n-      pos_type __retval =  pos_type(off_type(-1)); \n+      pos_type __ret =  pos_type(off_type(-1)); \n       bool __testopen = this->is_open();\n       bool __testin = __mode & ios_base::in && _M_mode & ios_base::in;\n       bool __testout = __mode & ios_base::out && _M_mode & ios_base::out;\n@@ -471,33 +471,33 @@ namespace std\n \t      else if (__testget && __way == ios_base::cur)\n \t\t__computed_off += _M_in_cur - _M_in_beg;\n \t  \n-\t      __retval = _M_file->seekoff(__computed_off, __way, __mode);\n+\t      __ret = _M_file->seekoff(__computed_off, __way, __mode);\n \t      _M_set_indeterminate();\n \t    }\n \t  // NB: Need to do this in case _M_file in indeterminate\n \t  // state, ie _M_file->_offset == -1\n \t  else\n \t    {\n-\t      __retval = _M_file->seekoff(__off, ios_base::cur, __mode);\n-\t      __retval += max(_M_out_cur, _M_in_cur) - _M_buf;\n+\t      __ret = _M_file->seekoff(__off, ios_base::cur, __mode);\n+\t      __ret += max(_M_out_cur, _M_in_cur) - _M_buf;\n \t    }\n \t}\n       _M_last_overflowed = false;\t\n-      return __retval;\n+      return __ret;\n     }\n \n   template<typename _CharT, typename _Traits>\n     basic_filebuf<_CharT, _Traits>::pos_type\n     basic_filebuf<_CharT, _Traits>::\n     seekpos(pos_type __pos, ios_base::openmode __mode)\n     {\n-      pos_type __retval;\n+      pos_type __ret;\n       off_type __off = __pos;\n \n-      __retval = this->seekoff(__off, ios_base::beg, __mode); \n+      __ret = this->seekoff(__off, ios_base::beg, __mode); \n \n       _M_last_overflowed = false;\t\n-      return __retval;\n+      return __ret;\n     }\n \n   template<typename _CharT, typename _Traits>"}, {"sha": "8ad2de04862bd9b1b0819af63e6114a39d41088b", "filename": "libstdc++-v3/bits/istream.tcc", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Fistream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Fistream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fistream.tcc?ref=5780a46bcae17e818621eb71d91b067eda11ce10", "patch": "@@ -876,17 +876,17 @@ namespace std {\n     basic_istream<_CharT, _Traits>::\n     sync(void)\n     {\n-      int __retval = traits_type::eof();\n+      int __ret = traits_type::eof();\n       _M_gcount = 0;\n       sentry __cerb(*this, true);\n       if (__cerb) \n \t{\n \t  try {\n \t    __streambuf_type* __sb = this->rdbuf();\n-\t    if (!__sb || __retval == __sb->pubsync())\n+\t    if (!__sb || __ret == __sb->pubsync())\n \t      this->setstate(ios_base::badbit);\t\t    \n \t    else \n-\t      __retval = 0;\n+\t      __ret = 0;\n \t  }\n \t  catch(exception& __fail){\n \t    // 27.6.1.3 paragraph 1\n@@ -896,22 +896,21 @@ namespace std {\n \t      throw;\n \t  }\n \t}\n-      return __retval;\n+      return __ret;\n     }\n   \n   template<typename _CharT, typename _Traits>\n     typename basic_istream<_CharT, _Traits>::pos_type\n     basic_istream<_CharT, _Traits>::\n     tellg(void)\n     {\n-      pos_type __retval = pos_type(-1);\n+      pos_type __ret = pos_type(-1);\n       _M_gcount = 0;\n       sentry __cerb(*this, true);\n       if (__cerb) \n \t{\n \t  try {\n-\t    __retval = this->rdbuf()->pubseekoff(0, ios_base::cur, \n-\t\t\t\t\t\t ios_base::in);\n+\t    __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);\n \t  }\n \t  catch(exception& __fail){\n \t    // 27.6.1.3 paragraph 1\n@@ -921,7 +920,7 @@ namespace std {\n \t      throw;\n \t  }\n \t}\n-      return __retval;\n+      return __ret;\n     }\n \n "}, {"sha": "2bddf57da489e5497858945b5b514b2aaf894459", "filename": "libstdc++-v3/bits/ostream.tcc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Fostream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Fostream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fostream.tcc?ref=5780a46bcae17e818621eb71d91b067eda11ce10", "patch": "@@ -360,12 +360,12 @@ namespace std {\n     typename basic_ostream<_CharT, _Traits>::pos_type\n     basic_ostream<_CharT, _Traits>::tellp()\n     {\n-      pos_type __retval = pos_type(-1);\n+      pos_type __ret = pos_type(-1);\n       bool __testok = this->fail() != true;\n       \n       if (__testok)\n-\t__retval = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);\n-      return __retval;\n+\t__ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);\n+      return __ret;\n     }\n \n "}, {"sha": "1463479043936bb2d6e2e08100eec00c32e81899", "filename": "libstdc++-v3/bits/sbuf_iter.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Fsbuf_iter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Fsbuf_iter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fsbuf_iter.h?ref=5780a46bcae17e818621eb71d91b067eda11ce10", "patch": "@@ -164,14 +164,14 @@ namespace std\n       operator*() const\n       { \n \t// The result of operator*() on an end of stream is undefined.\n-\tchar_type __retval;\n+\tchar_type __ret;\n \tif (_M_istreambuf && _M_c != static_cast<int_type>(-2))\n-\t  __retval = _M_c;\n+\t  __ret = _M_c;\n \telse if (_M_istreambuf)\n-\t  __retval = traits_type::to_char_type(_M_istreambuf->sgetc()); \n+\t  __ret = traits_type::to_char_type(_M_istreambuf->sgetc()); \n \telse\n-\t  __retval = static_cast<char_type>(traits_type::eof());\n-\treturn __retval;\n+\t  __ret = static_cast<char_type>(traits_type::eof());\n+\treturn __ret;\n       }\n \t\n       __istreambufiter_type& "}, {"sha": "5c737b4fa2e5888c20b96f8fcc6b7bc50dd587e7", "filename": "libstdc++-v3/bits/sstream.tcc", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Fsstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Fsstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fsstream.tcc?ref=5780a46bcae17e818621eb71d91b067eda11ce10", "patch": "@@ -43,7 +43,7 @@ namespace std {\n     basic_stringbuf<_CharT, _Traits, _Alloc>::\n     pbackfail(int_type __c)\n     {\n-      int_type __retval = traits_type::eof();\n+      int_type __ret = traits_type::eof();\n       bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());\n       bool __testpos = _M_in_cur && _M_in_beg < _M_in_cur; \n       \n@@ -55,30 +55,30 @@ namespace std {\n \t      && !__testeof)\n \t    {\n \t      --_M_in_cur;\n-\t      __retval = __c;\n+\t      __ret = __c;\n \t    }\n \t  else if (!__testeof)\n \t    {\n \t      --_M_in_cur;\n \t      *_M_in_cur = traits_type::to_char_type(__c);\n-\t      __retval = __c;\n+\t      __ret = __c;\n \t    }\n \t  else if (__testeof)\n \t    {\n \t      --_M_in_cur;\n-\t      __retval = traits_type::not_eof(__c);\n+\t      __ret = traits_type::not_eof(__c);\n \t    }\n \t}\n-      return __retval;\n+      return __ret;\n     }\n   \n   template <class _CharT, class _Traits, class _Alloc>\n     basic_stringbuf<_CharT, _Traits, _Alloc>::int_type \n     basic_stringbuf<_CharT, _Traits, _Alloc>::\n     overflow(int_type __c)\n     {\n-      int_type __retval = traits_type::eof();\n-      bool __testeof = traits_type::eq_int_type(__c, __retval);\n+      int_type __ret = traits_type::eof();\n+      bool __testeof = traits_type::eq_int_type(__c, __ret);\n       bool __testwrite = _M_out_cur < _M_buf + _M_buf_size;\n       bool __testout = _M_mode & ios_base::out;\n \n@@ -92,7 +92,7 @@ namespace std {\n \t      __len *= 2;\n \n \t      if (__testwrite)\n-\t\t__retval = this->sputc(__c);\n+\t\t__ret = this->sputc(__c);\n \t      else if (__len <= _M_string.max_size())\n \t\t{\n \t\t  // Force-allocate, re-sync.\n@@ -103,21 +103,21 @@ namespace std {\n \t\t\t\t _M_out_cur - _M_out_beg);\n \t\t  *_M_out_cur = traits_type::to_char_type(__c);\n \t\t  _M_out_cur_move(1);\n-\t\t  __retval = __c;\n+\t\t  __ret = __c;\n \t\t}\n \t    }\n \t  else\n-\t    __retval = traits_type::not_eof(__c);\n+\t    __ret = traits_type::not_eof(__c);\n \t}\n-      return __retval;\n+      return __ret;\n     }\n \n   template <class _CharT, class _Traits, class _Alloc>\n     basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type\n     basic_stringbuf<_CharT, _Traits, _Alloc>::\n     seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)\n     {\n-      pos_type __retval =  pos_type(off_type(-1)); \n+      pos_type __ret =  pos_type(off_type(-1)); \n       bool __testin = __mode & ios_base::in && _M_mode & ios_base::in;\n       bool __testout = __mode & ios_base::out && _M_mode & ios_base::out;\n       bool __testboth = __testin && __testout && __way != ios_base::cur;\n@@ -158,24 +158,24 @@ namespace std {\n \t      && __newoffi + __off >= 0 && __endi - __beg >= __newoffi + __off)\n \t    {\n \t      _M_in_cur = __beg + __newoffi + __off;\n-\t      __retval = pos_type(__newoffi);\n+\t      __ret = pos_type(__newoffi);\n \t    }\n \t  if (__testout\n \t      && __newoffo + __off >= 0 && __endo - __beg >= __newoffo + __off)\n \t    {\n \t      _M_out_cur_move(__newoffo + __off - (_M_out_cur - __beg));\n-\t      __retval = pos_type(__newoffo);\n+\t      __ret = pos_type(__newoffo);\n \t    }\n \t}\n-      return __retval;\n+      return __ret;\n     }\n \n   template <class _CharT, class _Traits, class _Alloc>\n     basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type\n     basic_stringbuf<_CharT, _Traits, _Alloc>::\n     seekpos(pos_type __sp, ios_base::openmode __mode)\n     {\n-      pos_type __retval =  pos_type(off_type(-1)); \n+      pos_type __ret =  pos_type(off_type(-1)); \n       off_type __pos = __sp._M_position();\n       char_type* __beg = NULL;\n       char_type* __end = NULL;\n@@ -200,10 +200,10 @@ namespace std {\n \t    _M_in_cur = _M_in_beg + __pos;\n \t  if (__testout)\n \t    _M_out_cur_move((__pos) - (_M_out_cur - __beg));\n-\t  __retval = pos_type(off_type(__pos));\n+\t  __ret = pos_type(off_type(__pos));\n \t}\n       \n-      return __retval;\n+      return __ret;\n     }\n \n } // namespace std"}, {"sha": "b727b08251569cbd39aeb4dbae361ba831abb301", "filename": "libstdc++-v3/bits/std_fstream.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Fstd_fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Fstd_fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_fstream.h?ref=5780a46bcae17e818621eb71d91b067eda11ce10", "patch": "@@ -56,7 +56,7 @@ namespace std {\n       // Non-standard Types:\n       typedef basic_streambuf<char_type, traits_type>  \t__streambuf_type;\n       typedef basic_filebuf<char_type, traits_type>     __filebuf_type;\n-      typedef __basic_file\t\t\t        __file_type;\n+      typedef __basic_file<char_type>\t\t        __file_type;\n       typedef typename traits_type::state_type          __state_type;\n       typedef codecvt<char_type, char, __state_type>    __codecvt_type;\n       typedef typename __codecvt_type::result \t        __res_type;\n@@ -199,22 +199,22 @@ namespace std {\n       virtual streamsize \n       xsgetn(char_type* __s, streamsize __n)\n       {\n-\tstreamsize __retval = 0;\n+\tstreamsize __ret = 0;\n \t// Clear out pback buffer before going on to the real deal...\n \tif (_M_pback_init)\n \t  {\n-\t    while (__retval < __n && _M_in_cur < _M_in_end)\n+\t    while (__ret < __n && _M_in_cur < _M_in_end)\n \t      {\n \t\t*__s = *_M_in_cur;\n-\t\t++__retval;\n+\t\t++__ret;\n \t\t++__s;\n \t\t++_M_in_cur;\n \t      }\n \t    _M_pback_destroy();\n \t  }\n-\tif (__retval < __n)\n-\t  __retval += __streambuf_type::xsgetn(__s, __n - __retval);\n-\treturn __retval;\n+\tif (__ret < __n)\n+\t  __ret += __streambuf_type::xsgetn(__s, __n - __ret);\n+\treturn __ret;\n       }\n  \n       virtual streamsize "}, {"sha": "e473af5c032805f2de5e99d39b6beaa410366c50", "filename": "libstdc++-v3/bits/std_streambuf.h", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Fstd_streambuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Fstd_streambuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_streambuf.h?ref=5780a46bcae17e818621eb71d91b067eda11ce10", "patch": "@@ -232,12 +232,12 @@ namespace std {\n       bool\n       _M_is_indeterminate(void)\n       { \n-\tbool __retval = false;\n+\tbool __ret = false;\n \tif (_M_mode & ios_base::in)\n-\t  __retval = _M_in_beg == _M_in_cur && _M_in_cur == _M_in_end;\n+\t  __ret = _M_in_beg == _M_in_cur && _M_in_cur == _M_in_end;\n \tif (_M_mode & ios_base::out)\n-\t  __retval = _M_out_beg == _M_out_cur && _M_out_cur == _M_out_end;\n-\treturn __retval;\n+\t  __ret = _M_out_beg == _M_out_cur && _M_out_cur == _M_out_end;\n+\treturn __ret;\n       }\n \n   public:\n@@ -294,21 +294,21 @@ namespace std {\n       streamsize \n       in_avail() \n       { \n-\tstreamsize __retval;\n+\tstreamsize __ret;\n \tif (_M_in_cur && _M_in_cur < _M_in_end)\n \t  {\n \t    if (_M_pback_init)\n \t      {\n \t\tint_type __save_len =  _M_pback_end_save - _M_pback_cur_save;\n \t\tint_type __pback_len = _M_in_cur - _M_pback;\n-\t\t__retval = __save_len - __pback_len;\n+\t\t__ret = __save_len - __pback_len;\n \t      }\n \t    else\n-\t      __retval = this->egptr() - this->gptr();\n+\t      __ret = this->egptr() - this->gptr();\n \t  }\n \telse\n-\t  __retval = this->showmanyc();\n-\treturn __retval;\n+\t  __ret = this->showmanyc();\n+\treturn __ret;\n       }\n \n       int_type \n@@ -324,12 +324,12 @@ namespace std {\n       int_type \n       sgetc()\n       {\n-\tint_type __retval;\n+\tint_type __ret;\n \tif (_M_in_cur && _M_in_cur < _M_in_end)\n-\t  __retval = traits_type::to_int_type(*gptr());\n+\t  __ret = traits_type::to_int_type(*gptr());\n \telse \n-\t  __retval = this->underflow();\n-\treturn __retval;\n+\t  __ret = this->underflow();\n+\treturn __ret;\n       }\n \n       streamsize \n@@ -457,18 +457,18 @@ namespace std {\n       virtual int_type \n       uflow() \n       {\n-\tint_type __retval = traits_type::eof();\n-\tbool __testeof = this->underflow() == __retval;\n+\tint_type __ret = traits_type::eof();\n+\tbool __testeof = this->underflow() == __ret;\n \tbool __testpending = _M_in_cur && _M_in_cur < _M_in_end;\n \t\n \tif (!__testeof && __testpending)\n \t  {\n-\t    __retval = traits_type::to_int_type(*_M_in_cur);\n+\t    __ret = traits_type::to_int_type(*_M_in_cur);\n \t    ++_M_in_cur;\n \t    if (_M_buf_unified && _M_mode & ios_base::out)\n \t      ++_M_out_cur;\n \t  }\n-\treturn __retval;    \n+\treturn __ret;    \n       }\n \n       // Putback:"}, {"sha": "d03b7bca104ee88ba6d51ce9921d6e37524b67dd", "filename": "libstdc++-v3/bits/streambuf.tcc", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Fstreambuf.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Fstreambuf.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstreambuf.tcc?ref=5780a46bcae17e818621eb71d91b067eda11ce10", "patch": "@@ -41,56 +41,56 @@ namespace std {\n     basic_streambuf<_CharT, _Traits>::\n     sbumpc()\n     {\n-      int_type __retval;\n+      int_type __ret;\n       if (_M_in_cur && _M_in_cur < _M_in_end)\n \t{\n \t  char_type __c = *gptr();\n \t  ++_M_in_cur;\n \t  if (_M_buf_unified &&  _M_mode & ios_base::out)\n \t    ++_M_out_cur;\n-\t  __retval = traits_type::to_int_type(__c);\n+\t  __ret = traits_type::to_int_type(__c);\n \t}\n       else \n-\t__retval = this->uflow();\n-      return __retval;\n+\t__ret = this->uflow();\n+      return __ret;\n     }\n \n   template<typename _CharT, typename _Traits>\n     basic_streambuf<_CharT, _Traits>::int_type\n     basic_streambuf<_CharT, _Traits>::\n     sputbackc(char_type __c) \n     {\n-      int_type __retval;\n+      int_type __ret;\n       bool __testpos = _M_in_cur && _M_in_beg < _M_in_cur;\n       bool __testne = _M_in_cur && !traits_type::eq(__c, this->gptr()[-1]);\n       if (!__testpos || __testne)\n-\t__retval = pbackfail(traits_type::to_int_type(__c));\n+\t__ret = pbackfail(traits_type::to_int_type(__c));\n       else \n \t{\n \t  --_M_in_cur;\n \t  if (_M_buf_unified && _M_mode & ios_base::out)\n \t    --_M_out_cur;\n-\t  __retval = traits_type::to_int_type(*this->gptr());\n+\t  __ret = traits_type::to_int_type(*this->gptr());\n \t}\n-      return __retval;\n+      return __ret;\n     }\n   \n   template<typename _CharT, typename _Traits>\n     basic_streambuf<_CharT, _Traits>::int_type\n     basic_streambuf<_CharT, _Traits>::\n     sungetc()\n     {\n-      int_type __retval;\n+      int_type __ret;\n       if (_M_in_cur && _M_in_beg < _M_in_cur)\n \t{\n \t  --_M_in_cur;\n \t  if (_M_buf_unified && _M_mode & ios_base::out)\n \t    --_M_out_cur;\n-\t  __retval = traits_type::to_int_type(*_M_in_cur);\n+\t  __ret = traits_type::to_int_type(*_M_in_cur);\n \t}\n       else \n-\t__retval = this->pbackfail();\n-      return __retval;\n+\t__ret = this->pbackfail();\n+      return __ret;\n     }\n \n   // Don't test against _M_buf + _M_buf_size, because _M_buf reflects\n@@ -103,17 +103,17 @@ namespace std {\n     basic_streambuf<_CharT, _Traits>::\n     sputc(char_type __c)\n     {\n-      int_type __retval;\n+      int_type __ret;\n \n       if (_M_out_cur && _M_out_cur < _M_out_beg + _M_buf_size)\n \t{\n \t  *_M_out_cur = __c;\n \t  _M_out_cur_move(1);\n-\t  __retval = traits_type::to_int_type(__c);\n+\t  __ret = traits_type::to_int_type(__c);\n \t}\n       else\n-\t__retval = this->overflow(traits_type::to_int_type(__c));\n-      return __retval;\n+\t__ret = this->overflow(traits_type::to_int_type(__c));\n+      return __ret;\n     }\n \n   template<typename _CharT, typename _Traits>\n@@ -122,39 +122,39 @@ namespace std {\n     xsgetn(char_type* __s, streamsize __n)\n     {\n       bool __testout = _M_mode & ios_base::out;\n-      streamsize __retval = 0;\n+      streamsize __ret = 0;\n \n       if (__n)\n \t{\n-\t  while (__retval < __n)\n+\t  while (__ret < __n)\n \t    {\n \t      if (_M_in_cur < _M_in_end)\n \t\t{\n \t\t  size_t __len;\n-\t\t  if (_M_in_cur + __n - __retval <= _M_in_end)\n-\t\t    __len = __n - __retval;\n+\t\t  if (_M_in_cur + __n - __ret <= _M_in_end)\n+\t\t    __len = __n - __ret;\n \t\t  else\n \t\t    __len = _M_in_end - _M_in_cur;\n \t\t  traits_type::copy(__s, _M_in_cur, __len);\n-\t\t  __retval += __len;\n+\t\t  __ret += __len;\n \t\t  __s += __len;\n \t\t  _M_in_cur += __len;\n \t\t  if (_M_buf_unified && __testout)\n \t\t    _M_out_cur += __len;\n \t\t}\n \t      \n-\t      if (__retval != __n)\n+\t      if (__ret != __n)\n \t\t{\n \t\t  int_type __c = this->uflow();  \n \t\t  if (traits_type::eq_int_type(__c, traits_type::eof()))\n                     break;\n \n \t\t  traits_type::assign(*__s++, traits_type::to_char_type(__c));\n-                  ++__retval;\n+                  ++__ret;\n \t\t}\n \t    }\n \t}\n-      return __retval;\n+      return __ret;\n     }\n \n   // Don't test against _M_buf + _M_buf_size, because _M_buf reflects\n@@ -167,11 +167,11 @@ namespace std {\n     basic_streambuf<_CharT, _Traits>::\n     xsputn(const char_type* __s, streamsize __n)\n     {\n-      streamsize __retval = 0;\n+      streamsize __ret = 0;\n \n       if (__n)\n \t{\n-\t  while (__retval < __n)\n+\t  while (__ret < __n)\n \t    {\n \t      bool __testput = _M_out_cur < _M_out_beg + _M_buf_size;\n \t      bool __testout = _M_mode & ios_base::out;\n@@ -181,28 +181,28 @@ namespace std {\n \t\t  int_type __overfc = this->overflow(__c);\n \t\t  if (traits_type::eq_int_type(__c, __overfc))\n \t\t    {\n-\t\t      ++__retval;\n+\t\t      ++__ret;\n \t\t      ++__s;\n \t\t    }\n \t\t  else\n \t\t    break;\n \t\t}\n \t      \n-\t      if (__retval != __n)\n+\t      if (__ret != __n)\n \t\t{\n \t\t  size_t __len;\n-\t\t  if (_M_out_cur + __n - __retval <= _M_out_beg + _M_buf_size)\n-\t\t    __len = __n - __retval;\n+\t\t  if (_M_out_cur + __n - __ret <= _M_out_beg + _M_buf_size)\n+\t\t    __len = __n - __ret;\n \t\t  else\n \t\t    __len = _M_out_beg + _M_buf_size - _M_out_cur;\n \t\t  traits_type::copy(_M_out_cur, __s, __len);\n-\t\t  __retval += __len;\n+\t\t  __ret += __len;\n \t\t  __s += __len;\n \t\t  _M_out_cur_move(__len);\n \t\t}\n \t    }\n \t}\n-      return __retval;\n+      return __ret;\n     }\n \n \n@@ -218,7 +218,7 @@ namespace std {\n     {\n       typedef typename _Traits::int_type\tint_type;\n \n-      streamsize __retval = 0;\n+      streamsize __ret = 0;\n       streamsize __bufsize = __sbin->in_avail();\n       streamsize __xtrct;\n       bool __testout = __sbin->_M_mode & ios_base::out;\n@@ -227,7 +227,7 @@ namespace std {\n \twhile (__testput && __bufsize != -1)\n \t  {\n \t    __xtrct = __sbout->sputn(__sbin->gptr(), __bufsize);\n-\t    __retval += __xtrct;\n+\t    __ret += __xtrct;\n \t    __sbin->_M_in_cur += __xtrct;\n \t    if (__testout && __sbin->_M_buf_unified)\n \t      __sbin->_M_out_cur += __xtrct;\n@@ -249,7 +249,7 @@ namespace std {\n \tif ((__ios.exceptions() & ios_base::failbit) != 0)\n \t  throw;\n       }\n-      return __retval;\n+      return __ret;\n     }\n \n } // namespace std"}, {"sha": "20838e5aa0b54d6fe4f527773753995005ca4194", "filename": "libstdc++-v3/bits/string.tcc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Fstring.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fbits%2Fstring.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstring.tcc?ref=5780a46bcae17e818621eb71d91b067eda11ce10", "patch": "@@ -613,16 +613,16 @@ namespace std\n     find(_CharT __c, size_type __pos) const\n     {\n       size_type __size = this->size();\n-      size_type __retval = npos;\n+      size_type __ret = npos;\n       if (__pos < __size)\n \t{\n \t  const _CharT* __data = _M_data();\n \t  const _CharT* __end = __data + __size;\n \t  const _CharT* __p = _S_find(__data + __pos, __end, __c);\n \t  if (__p != __end)\n-\t    __retval = __p - __data;\n+\t    __ret = __p - __data;\n \t}\n-      return __retval;\n+      return __ret;\n     }\n \n "}, {"sha": "caefddc7f1b802f0723211394f593cd6239f160e", "filename": "libstdc++-v3/config/c_io_libio.cc", "status": "modified", "additions": 217, "deletions": 150, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fconfig%2Fc_io_libio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fconfig%2Fc_io_libio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fc_io_libio.cc?ref=5780a46bcae17e818621eb71d91b067eda11ce10", "patch": "@@ -37,206 +37,273 @@\n \n namespace std {\n   \n-  __basic_file::__basic_file(__c_lock* __lock)\n-  {\n-#ifdef _IO_MTSAFE_IO\n-    _lock = __lock;\n-#endif\n-    _IO_no_init(this, 0 /* ??? */, -1, 0, 0);\n-    _IO_JUMPS(this) = &_IO_file_jumps;\n-    _IO_file_init((_IO_FILE_plus*)this);\n-  }\n-\n-  int \n-  __basic_file::get_fileno(void)\n-  { return _fileno; }\n+  template<typename _CharT>\n+    int \n+    __basic_file<_CharT>::get_fileno(void)\n+    { return _fileno; }\n  \n-  __basic_file::~__basic_file()\n-  { _IO_file_finish(this, 0); }\n+  template<typename _CharT>\n+    __basic_file<_CharT>::~__basic_file()\n+    { _IO_file_finish(this, 0); }\n       \n-  void \n-  __basic_file::_M_open_mode(ios_base::openmode __mode, int& __p_mode, \n-\t\t\t     int& __rw_mode)\n-  {\n+  template<typename _CharT>\n+    void \n+    __basic_file<_CharT>::_M_open_mode(ios_base::openmode __mode, \n+\t\t\t\t       int& __p_mode, int& __rw_mode)\n+    {  \n #ifdef O_BINARY\n-    bool __testb = __mode & ios_base::binary;\n+      bool __testb = __mode & ios_base::binary;\n #endif\n-    bool __testi = __mode & ios_base::in;\n-    bool __testo = __mode & ios_base::out;\n-    bool __testt = __mode & ios_base::trunc;\n-    bool __testa = __mode & ios_base::app;\n-    \n-    if (!__testi && __testo && !__testt && !__testa)\n-      {\n-\t__p_mode = O_WRONLY | O_TRUNC | O_CREAT;\n-\t__rw_mode = _IO_NO_READS;\n-      }\n-    if (!__testi && __testo && !__testt && __testa)\n-      {\n-\t__p_mode = O_WRONLY | O_APPEND | O_CREAT;\n-\t__rw_mode = _IO_NO_READS | _IO_IS_APPENDING;\n-      }\n-    if (!__testi && __testo && __testt && !__testa)\n-      {\n-\t__p_mode = O_WRONLY | O_TRUNC | O_CREAT;\n-\t__rw_mode = _IO_NO_READS;\n-      }\n-    if (__testi && !__testo && !__testt && !__testa)\n-      {\n-\t__p_mode = O_RDONLY;\n-\t__rw_mode = _IO_NO_WRITES;\n-      }\n-    if (__testi && __testo && !__testt && !__testa)\n+      bool __testi = __mode & ios_base::in;\n+      bool __testo = __mode & ios_base::out;\n+      bool __testt = __mode & ios_base::trunc;\n+      bool __testa = __mode & ios_base::app;\n+      \n+      if (!__testi && __testo && !__testt && !__testa)\n+\t{\n+\t  __p_mode = O_WRONLY | O_TRUNC | O_CREAT;\n+\t  __rw_mode = _IO_NO_READS;\n+\t}\n+      if (!__testi && __testo && !__testt && __testa)\n+\t{\n+\t  __p_mode = O_WRONLY | O_APPEND | O_CREAT;\n+\t  __rw_mode = _IO_NO_READS | _IO_IS_APPENDING;\n+\t}\n+      if (!__testi && __testo && __testt && !__testa)\n+\t{\n+\t  __p_mode = O_WRONLY | O_TRUNC | O_CREAT;\n+\t  __rw_mode = _IO_NO_READS;\n+\t}\n+      if (__testi && !__testo && !__testt && !__testa)\n+\t{\n+\t  __p_mode = O_RDONLY;\n+\t  __rw_mode = _IO_NO_WRITES;\n+\t}\n+      if (__testi && __testo && !__testt && !__testa)\n \t{\n \t  __p_mode = O_RDWR;\n \t  __rw_mode = 0;\n \t}\n-    if (__testi && __testo && __testt && !__testa)\n-      {\n-\t__p_mode = O_RDWR | O_TRUNC | O_CREAT;\n-\t__rw_mode = 0;\n-      }\n+      if (__testi && __testo && __testt && !__testa)\n+\t{\n+\t  __p_mode = O_RDWR | O_TRUNC | O_CREAT;\n+\t  __rw_mode = 0;\n+\t}\n #ifdef O_BINARY\n-    if (__testb)\n-      __p_mode |= O_BINARY;\n+      if (__testb)\n+\t__p_mode |= O_BINARY;\n #endif\t   \n     }\n-\n-  __basic_file*\n-  __basic_file::sys_open(int __fd, ios_base::openmode __mode) \n-  {\n-    __basic_file* __retval = NULL;\n-    int __p_mode = 0;\n-    int __rw_mode = _IO_NO_READS + _IO_NO_WRITES; \n-\n-    _M_open_mode(__mode, __p_mode, __rw_mode);\n-    // _IO_file_attach \n-    //  sets _IO_DELETE_DONT_CLOSE\n-    //  clears _IO_NO_READS + _IO_NO_WRITES\n-    if (_IO_file_attach(this, __fd) != NULL)\n-      {\n-\t// Set flags appropriately for openmode...\n-\tint __mask = _IO_NO_READS + _IO_NO_WRITES + _IO_IS_APPENDING;\n-\t_IO_mask_flags(this, __rw_mode, __mask);\n-      }\n-    else\n-      {\n+  \n+  template<typename _CharT>\n+    __basic_file<_CharT>*\n+    __basic_file<_CharT>::sys_open(int __fd, ios_base::openmode __mode) \n+    {\n+      __basic_file* __ret = NULL;\n+      int __p_mode = 0;\n+      int __rw_mode = _IO_NO_READS + _IO_NO_WRITES; \n+      \n+      _M_open_mode(__mode, __p_mode, __rw_mode);\n+      // _IO_file_attach \n+      //  sets _IO_DELETE_DONT_CLOSE\n+      //  clears _IO_NO_READS + _IO_NO_WRITES\n+      if (_IO_file_attach(this, __fd) != NULL)\n+\t{\n+\t  // Set flags appropriately for openmode...\n+\t  int __mask = _IO_NO_READS + _IO_NO_WRITES + _IO_IS_APPENDING;\n+\t  _IO_mask_flags(this, __rw_mode, __mask);\n+\t}\n+      else\n \t_IO_un_link((_IO_FILE_plus*) this);\n-\t// XXX Extended error checking?? Note that v2 does not even have this.\n-      }\n-    return __retval;\n-  }\n+      return __ret;\n+    }\n+  \n+  template<typename _CharT>\n+    __basic_file<_CharT>* \n+    __basic_file<_CharT>::open(const char* __name, ios_base::openmode __mode, \n+\t\t\t       int __prot = 0664)\n+    {\n+      __basic_file* __ret = NULL;\n+      int __p_mode = 0;\n+      int __rw_mode = _IO_NO_READS + _IO_NO_WRITES; \n+      \n+      _M_open_mode(__mode, __p_mode, __rw_mode);\n+      if (!_IO_file_is_open(this))\n+\t{\n+\t  __c_file_type* __f;\n+\t  __f = _IO_file_open(this, __name, __p_mode, __prot, __rw_mode, 0);\n+\t  __ret = __f ? this: NULL;\n+\t}\n+      return __ret;\n+    }\n+  \n+  template<typename _CharT>\n+    bool \n+    __basic_file<_CharT>::is_open() { return _fileno >= 0; }\n+  \n+  template<typename _CharT>\n+    __basic_file<_CharT>* \n+    __basic_file<_CharT>::close()\n+    { \n+      return _IO_file_close_it(this) ? static_cast<__basic_file*>(NULL) : this;\n+    }\n \n-  __basic_file* \n-  __basic_file::open(const char* __name, ios_base::openmode __mode, \n-\t\t     int __prot = 0664)\n-  {\n-    __basic_file* __retval = NULL;\n-    int __p_mode = 0;\n-    int __rw_mode = _IO_NO_READS + _IO_NO_WRITES; \n-\n-    _M_open_mode(__mode, __p_mode, __rw_mode);\n-    if (!_IO_file_is_open(this))\n-      {\n-\t//#if _G_HAVE_IO_FILE_OPEN\n-\t__c_file_type* __f;\n-\t__f = _IO_file_open(this, __name, __p_mode, __prot, __rw_mode, 0);\n-\t//\t_flags &= ~_IO_DELETE_DONT_CLOSE;\n-\t__retval = __f ? this: NULL;\n-      }\n-    return __retval;\n-  }\n+  // NB: Unused.\n+  template<typename _CharT>\n+    int \n+    __basic_file<_CharT>::uflow()  \n+    { return _IO_default_uflow(this); }\n   \n-  bool \n-  __basic_file::is_open() { return _fileno >= 0; }\n+  // NB: Unused.\n+  template<typename _CharT>\n+    int \n+    __basic_file<_CharT>::pbackfail(int __c) \n+    { return _IO_default_pbackfail(this, __c); }\n   \n-  __basic_file* \n-  __basic_file::close()\n-  { return _IO_file_close_it(this) ? static_cast<__basic_file*>(NULL) : this; }\n+  template<typename _CharT>\n+    streamsize \n+    __basic_file<_CharT>::xsgetn(char* __s, streamsize __n)\n+    { return _IO_file_xsgetn(this, __s, __n); }\n \n   // NB: Unused.\n-  int \n-  __basic_file::overflow(int __c) \n-  { return _IO_file_overflow(this, __c); }\n+  template<typename _CharT>\n+    streamsize \n+    __basic_file<_CharT>::sys_read(char* __s, streamsize __n) \n+    { return _IO_file_read(this, __s, __n); }\n+\n+  // NB: Unused.    \n+  template<typename _CharT>\n+    streamsize \n+    __basic_file<_CharT>::sys_write(const char* __s, streamsize __n) \n+    { return _IO_file_write(this, __s, __n); }\n \n   // NB: Unused.\n-  int \n-  __basic_file::underflow()  \n-  { return _IO_file_underflow(this); }\n+  template<typename _CharT>\n+    streamoff\n+    __basic_file<_CharT>::sys_seek(streamoff __pos, ios_base::seekdir __way)\n+    { return _IO_file_seek(this, __pos, __way); }\n+  \n+  // NB: Unused.\n+  template<typename _CharT>\n+    int \n+    __basic_file<_CharT>::sys_close() \n+    { return _IO_file_close(this); }\n+\n+  // NB: Unused.\n+  template<typename _CharT>\n+    int \n+    __basic_file<_CharT>::sys_stat(void* __v) \n+    { return _IO_file_stat(this, __v); }\n+\n+  // NB: Unused.\n+  template<typename _CharT>\n+    int \n+    __basic_file<_CharT>::showmanyc() { return EOF; }\n+\n+  // NB: Unused.\n+  template<typename _CharT>\n+    void \n+    __basic_file<_CharT>::imbue(void* /*__v*/) { }\n+\n+  // __basic_file<char> definitions\n+  __basic_file<char>::__basic_file(__c_lock* __lock)\n+  {\n+#ifdef _IO_MTSAFE_IO\n+    _lock = __lock;\n+#endif\n+    _IO_no_init(this, 0 /* ??? */, -1, 0, 0);\n+    _IO_JUMPS(this) = &_IO_file_jumps;\n+    _IO_file_init((_IO_FILE_plus*)this);\n+  }\n \n   // NB: Unused.\n   int \n-  __basic_file::uflow()  \n-  { return _IO_default_uflow(this); }\n-  \n+  __basic_file<char>::overflow(int __c) \n+  { return _IO_file_overflow(this, __c); }\n+\n   // NB: Unused.\n   int \n-  __basic_file::pbackfail(int __c) \n-  { return _IO_default_pbackfail(this, __c); }\n-  \n+  __basic_file<char>::underflow()  \n+  { return _IO_file_underflow(this); }\n+\n   streamsize \n-  __basic_file::xsputn(const char* __s, streamsize __n)\n+  __basic_file<char>::xsputn(const char* __s, streamsize __n)\n   { return _IO_file_xsputn(this, __s, __n); }\n-  \n-  streamsize \n-  __basic_file::xsgetn(char* __s, streamsize __n)\n-  { return _IO_file_xsgetn(this, __s, __n); }\n \n   streamoff\n-  __basic_file::seekoff(streamoff __off, ios_base::seekdir __way, \n-\t\t\tios_base::openmode __mode)\n+  __basic_file<char>::seekoff(streamoff __off, ios_base::seekdir __way, \n+\t\t\t      ios_base::openmode __mode)\n   { return _IO_file_seekoff(this, __off, __way, __mode); }\n \n   streamoff\n-  __basic_file::seekpos(streamoff __pos, ios_base::openmode __mode)\n+  __basic_file<char>::seekpos(streamoff __pos, ios_base::openmode __mode)\n   { return _IO_file_seekoff(this, __pos, ios_base::beg, __mode); }\n \n-  // NB: Unused.\n+ // NB: Unused.\n   streambuf* \n-  __basic_file::setbuf(char* __b, int __len)\n+  __basic_file<char>::setbuf(char* __b, int __len)\n   { return (streambuf*) _IO_file_setbuf(this,__b, __len); }\n \n-  int \n-  __basic_file::sync()\n+ int \n+  __basic_file<char>::sync()\n   { return _IO_file_sync(this); }\n \n   // NB: Unused.\n   int \n-  __basic_file::doallocate() \n+  __basic_file<char>::doallocate() \n   { return _IO_file_doallocate(this); }\n \n-  // NB: Unused.\n-  streamsize \n-  __basic_file::sys_read(char* __s, streamsize __n) \n-  { return _IO_file_read(this, __s, __n); }\n+  template class __basic_file<char>;\n+\n+  // __basic_file<wchar_t> definitions\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  __basic_file<wchar_t>::__basic_file(__c_lock* __lock)\n+  {\n+#ifdef _IO_MTSAFE_IO\n+    _lock = __lock;\n+#endif\n+    // bkoz this should be -1\n+    //    _IO_no_init(this, 0 /* ??? */, 1, 0, 0);\n+    _IO_no_init(this, 0 /* ??? */, -1, 0, 0);\n+    _IO_JUMPS(this) = &_IO_file_jumps;\n+    _IO_file_init((_IO_FILE_plus*)this);\n+  }\n+\n+ int \n+  __basic_file<wchar_t>::overflow(int __c) \n+  { return _IO_wfile_overflow(this, __c); }\n+\n+  int \n+  __basic_file<wchar_t>::underflow()  \n+  { return _IO_wfile_underflow(this); }\n \n-  // NB: Unused.    \n   streamsize \n-  __basic_file::sys_write(const char* __s, streamsize __n) \n-  { return _IO_file_write(this, __s, __n); }\n+  __basic_file<wchar_t>::xsputn(const char* __s, streamsize __n)\n+  { return _IO_wfile_xsputn(this, __s, __n); }\n+  \n+  streamoff\n+  __basic_file<wchar_t>::seekoff(streamoff __off, ios_base::seekdir __way, \n+\t\t\t\t ios_base::openmode __mode)\n+  { return _IO_wfile_seekoff(this, __off, __way, __mode); }\n \n-  // NB: Unused.\n   streamoff\n-  __basic_file::sys_seek(streamoff __pos, ios_base::seekdir __way)\n-  { return _IO_file_seek(this, __pos, __way); }\n-  \n-  // NB: Unused.\n-  int \n-  __basic_file::sys_close() \n-  { return _IO_file_close(this); }\n+  __basic_file<wchar_t>::seekpos(streamoff __pos, ios_base::openmode __mode)\n+  { return _IO_wfile_seekoff(this, __pos, ios_base::beg, __mode); }\n \n-  // NB: Unused.\n-  int \n-  __basic_file::sys_stat(void* __v) \n-  { return _IO_file_stat(this, __v); }\n+   streambuf* \n+  __basic_file<wchar_t>::setbuf(wchar_t* __b, int __len)\n+  { return (streambuf*) _IO_wfile_setbuf(this,__b, __len); }\n+\n+   int \n+  __basic_file<wchar_t>::sync()\n+  { return _IO_wfile_sync(this); }\n \n-  // NB: Unused.\n   int \n-  __basic_file::showmanyc() { return EOF; }\n+  __basic_file<wchar_t>::doallocate() \n+  { return _IO_wfile_doallocate(this); }\n \n-  // NB: Unused.\n-  void \n-  __basic_file::imbue(void* /*__v*/) { }\n+  template class __basic_file<wchar_t>;\n+#endif\n \n }  // namespace std\n "}, {"sha": "565e2b357d64951e55ad2056b7ceaf138c5a9130", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 1070, "deletions": 1104, "changes": 2174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=5780a46bcae17e818621eb71d91b067eda11ce10"}, {"sha": "2e71c76bf317a0faa550d240f3c57b495bcd883e", "filename": "libstdc++-v3/configure.in", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.in?ref=5780a46bcae17e818621eb71d91b067eda11ce10", "patch": "@@ -17,11 +17,11 @@ AC_ARG_WITH(cross-host,\n \n GLIBCPP_CONFIGURE(.)\n AC_LIBTOOL_DLOPEN\n+AM_PROG_LIBTOOL\n GLIBCPP_CHECK_GNU_MAKE\n   if test \"x$_cv_gnu_make_command\" = \"x\"; then\n     AC_MSG_ERROR([GNU make not found. Please install it or correct your path.])\n   fi\n-AM_PROG_LIBTOOL\n AM_CONFIG_HEADER(config.h)\n \n # Check for c++ or library specific bits that don't require linking.\n@@ -185,23 +185,23 @@ then\n   AC_MSG_WARN([no point in rebuilding libgcc.a if namespaces aren't used])\n fi\n \n-# Trying to get more people to read documentation.  Possibly remove check\n-# and warn all the time.\n+# Trying to get more people to read documentation.  Possibly remove\n+# check and warn all the time. There is no \"informational\" AC_MSG_\n+# macro, so these are going to be printed even when --quiet/--silent\n+# is given.\n if test ! -f stamp-sanity-warned; then\n   touch stamp-sanity-warned\n-  # There is no \"informational\" AC_MSG_ macro, so these are going to be\n-  # printed even when --quiet/--silent is given.\n-  echo ''\n-  echo 'Please make certain that you read the installation information here:'\n+  echo \"\"\n+  echo \"Please make certain that you read the installation information here:\"\n   echo \"  faster => ${srcdir}/docs/install.html\"\n-  echo '  slower => <URL:http://sources.redhat.com/libstdc++/install.html>'\n-  echo ''\n-  echo 'and the configuration information here:'\n+  echo \"  slower => <URL:http://sources.redhat.com/libstdc++/install.html>\"\n+  echo \"\"\n+  echo \"and the configuration information here:\"\n   echo \"  faster => ${srcdir}/docs/configopts.html\"\n-  echo '  slower => <URL:http://sources.redhat.com/libstdc++/configopts.html>'\n-  echo ''\n-  echo 'before proceeding with \"make\".'\n-  echo ''\n+  echo \"  slower => <URL:http://sources.redhat.com/libstdc++/configopts.html>\"\n+  echo \"\"\n+  echo \"before proceeding with make.\"\n+  echo \"\"\n fi\n \n "}, {"sha": "af0ba56f3ceede67f26a92bd2d812387d3fbeddb", "filename": "libstdc++-v3/src/ios.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fsrc%2Fios.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fsrc%2Fios.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fios.cc?ref=5780a46bcae17e818621eb71d91b067eda11ce10", "patch": "@@ -271,10 +271,10 @@ namespace std {\n   { \n #ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n     // 49.  Underspecification of ios_base::sync_with_stdio\n-    bool __retval = __ioinit._M_cin->_M_file->get_fileno() == 0;\n+    bool __ret = __ioinit._M_cin->_M_file->get_fileno() == 0;\n \n     // Turn off sync with C FILE* for cin, cout, cerr, clog.\n-    if (!__sync && __retval)\n+    if (!__sync && __ret)\n       {\n \t// Need to dispose of the buffers created at initialization.\n \t__ioinit._M_cout->~filebuf();\n@@ -309,7 +309,7 @@ namespace std {\n #endif\n       }\n     \n-    return __retval; \n+    return __ret; \n #endif\n   }\n "}, {"sha": "e883ef3ff0c79dd84dc25d6a4df195b231ed551f", "filename": "libstdc++-v3/src/string-inst.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fsrc%2Fstring-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5780a46bcae17e818621eb71d91b067eda11ce10/libstdc%2B%2B-v3%2Fsrc%2Fstring-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fstring-inst.cc?ref=5780a46bcae17e818621eb71d91b067eda11ce10", "patch": "@@ -209,8 +209,8 @@ namespace std\n     const char* \n     string::_S_find(const char* __beg, const char* __end, char __c)\n     { \n-      const char* __retval = strchr(__beg, __c); \n-      return (__retval ? __retval : __end);\n+      const char* __ret = strchr(__beg, __c); \n+      return (__ret ? __ret : __end);\n     }\n #else\n   template<>"}]}