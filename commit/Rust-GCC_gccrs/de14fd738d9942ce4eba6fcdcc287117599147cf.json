{"sha": "de14fd738d9942ce4eba6fcdcc287117599147cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGUxNGZkNzM4ZDk5NDJjZTRlYmE2ZmNkY2MyODcxMTc1OTkxNDdjZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-02-28T10:22:39Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-02-28T10:22:39Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r362", "tree": {"sha": "995652e5cf83cade9ea604eb887248dcf94af93f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/995652e5cf83cade9ea604eb887248dcf94af93f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de14fd738d9942ce4eba6fcdcc287117599147cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de14fd738d9942ce4eba6fcdcc287117599147cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de14fd738d9942ce4eba6fcdcc287117599147cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de14fd738d9942ce4eba6fcdcc287117599147cf/comments", "author": null, "committer": null, "parents": [{"sha": "98ccf8fe7788adb5061704d0c90b659da97fe2cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98ccf8fe7788adb5061704d0c90b659da97fe2cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98ccf8fe7788adb5061704d0c90b659da97fe2cd"}], "stats": {"total": 21, "additions": 14, "deletions": 7}, "files": [{"sha": "3b38530d684c2389d5c4d1f5da0b1c4aeacf98c3", "filename": "gcc/stmt.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de14fd738d9942ce4eba6fcdcc287117599147cf/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de14fd738d9942ce4eba6fcdcc287117599147cf/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=de14fd738d9942ce4eba6fcdcc287117599147cf", "patch": "@@ -145,8 +145,8 @@ static tree empty_cleanup_list;\n    The alternative to the use of a branch table is to generate a series\n    of compare and jump insns.  When that is done, we use the LEFT, RIGHT,\n    and PARENT fields to hold a binary tree.  Initially the tree is\n-   totally unbalanced, with everything on the right.  The tree is the\n-   balanced, with nodes on the left having lower case values than the parent\n+   totally unbalanced, with everything on the right.  We balance the tree\n+   with nodes on the left having lower case values than the parent\n    and nodes on the right having higher values.  We then output the tree\n    in order.  */\n \n@@ -535,6 +535,7 @@ expand_computed_goto (exp)\n      tree exp;\n {\n   rtx x = expand_expr (exp, 0, VOIDmode, 0);\n+  emit_queue ();\n   emit_indirect_jump (x);\n   emit_barrier ();\n }\n@@ -3547,6 +3548,7 @@ expand_end_case (orig_index)\n \t       || TREE_CODE (index_expr) == INTEGER_CST\n \t       /* This will reduce to a constant.  */\n \t       || (TREE_CODE (index_expr) == CALL_EXPR\n+\t\t   && TREE_CODE (TREE_OPERAND (index_expr, 0)) == ADDR_EXPR\n \t\t   && TREE_CODE (TREE_OPERAND (TREE_OPERAND (index_expr, 0), 0)) == FUNCTION_DECL\n \t\t   && DECL_FUNCTION_CODE (TREE_OPERAND (TREE_OPERAND (index_expr, 0), 0)) == BUILT_IN_CLASSIFY_TYPE))\n \t{\n@@ -4245,7 +4247,7 @@ emit_case_nodes (index, node, default_label, index_type)\n \t     Omit the conditional branch to default if we it avoid only one\n \t     right child; it costs too much space to save so little time.  */\n \n-\t  if (node->right->right\n+\t  if (node->right->right || node->right->left\n \t      || !tree_int_cst_equal (node->right->low, node->right->high))\n \t    {\n \t      if (!node_has_low_bound (node, index_type))\n@@ -4270,15 +4272,20 @@ emit_case_nodes (index, node, default_label, index_type)\n \t{\n \t  /* Just one subtree, on the left.  */\n \n-\t  /* If our \"most probably entry\" is less probable\n+#if 0 /* The following code and comment were formerly part\n+\t of the condition here, but they didn't work\n+\t and I don't understand what the idea was.  -- rms.  */\n+\t  /* If our \"most probable entry\" is less probable\n \t     than the default label, emit a jump to\n \t     the default label using condition codes\n \t     already lying around.  With no right branch,\n \t     a branch-greater-than will get us to the default\n \t     label correctly.  */\n-\t  if ((use_cost_table\n-\t       ? cost_table[TREE_INT_CST_LOW (node->high)] < 12\n-\t       : node->left->left != 0)\n+\t  if (use_cost_table\n+\t       && cost_table[TREE_INT_CST_LOW (node->high)] < 12)\n+\t    ;\n+#endif /* 0 */\n+ \t  if (node->left->left || node->left->right\n \t      || !tree_int_cst_equal (node->left->low, node->left->high))\n \t    {\n \t      if (!node_has_high_bound (node, index_type))"}]}