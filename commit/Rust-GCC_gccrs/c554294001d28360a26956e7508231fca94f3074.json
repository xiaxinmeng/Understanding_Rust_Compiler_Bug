{"sha": "c554294001d28360a26956e7508231fca94f3074", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU1NDI5NDAwMWQyODM2MGEyNjk1NmU3NTA4MjMxZmNhOTRmMzA3NA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenth@gcc.gnu.org", "date": "2005-05-11T08:14:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2005-05-11T08:14:44Z"}, "message": "re PR middle-end/19807 (fold does not fold &a[4]-1)\n\n2005-05-11  Richard Guenther  <rguenth@gcc.gnu.org>\n\n\tPR middle-end/19807\n\tPR tree-optimization/19639\n\t* fold-const.c (try_move_mult_to_index): Handle INTEGER_CST\n\tand generic summands for char* as s * delta, too, folding &a[i]\n\tCODE x to &a[i CODE x/s].  Use tree_int_cst_equal\n\tfor comparison of steps.  Convert types for index addition.\n\t(fold_binary): Adjust the callers to always dispatch to\n\ttry_move_mult_to_index.\n\t* tree-ssa-propagate.c (set_rhs): Avoid setting rhs to\n\texpr with non-gimple ARRAY_REF offset.\n\n\t* g++.dg/tree-ssa/pr19807.C: New testcase.\n\nFrom-SVN: r99568", "tree": {"sha": "1f93266ba272ee270a6ad7b854a342625fa9c228", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f93266ba272ee270a6ad7b854a342625fa9c228"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c554294001d28360a26956e7508231fca94f3074", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c554294001d28360a26956e7508231fca94f3074", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c554294001d28360a26956e7508231fca94f3074", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c554294001d28360a26956e7508231fca94f3074/comments", "author": null, "committer": null, "parents": [{"sha": "8a29ce604bdb9588fa66aaabe27c92bf955cab3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a29ce604bdb9588fa66aaabe27c92bf955cab3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a29ce604bdb9588fa66aaabe27c92bf955cab3d"}], "stats": {"total": 131, "additions": 102, "deletions": 29}, "files": [{"sha": "d6dd1b7d8fe7cc01ec03f7b6907363c418a61d9b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c554294001d28360a26956e7508231fca94f3074/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c554294001d28360a26956e7508231fca94f3074/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c554294001d28360a26956e7508231fca94f3074", "patch": "@@ -1,3 +1,16 @@\n+2005-05-11  Richard Guenther  <rguenth@gcc.gnu.org>\n+\n+\tPR middle-end/19807\n+\tPR tree-optimization/19639\n+\t* fold-const.c (try_move_mult_to_index): Handle INTEGER_CST\n+\tand generic summands for char* as s * delta, too, folding &a[i]\n+\tCODE x to &a[i CODE x/s].  Use tree_int_cst_equal\n+\tfor comparison of steps.  Convert types for index addition.\n+\t(fold_binary): Adjust the callers to always dispatch to\n+\ttry_move_mult_to_index.\n+\t* tree-ssa-propagate.c (set_rhs): Avoid setting rhs to\n+\texpr with non-gimple ARRAY_REF offset.\n+\n 2005-05-11  Richard Guenther  <rguenth@gcc.gnu.org>\n \n \t* fold-const.c (fold_indirect_ref_1): Avoid removing"}, {"sha": "21250f6c4b2d0afee141f97db590f915221fc18e", "filename": "gcc/fold-const.c", "status": "modified", "additions": 53, "deletions": 29, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c554294001d28360a26956e7508231fca94f3074/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c554294001d28360a26956e7508231fca94f3074/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=c554294001d28360a26956e7508231fca94f3074", "patch": "@@ -6259,55 +6259,81 @@ fold_sign_changed_comparison (enum tree_code code, tree type,\n }\n \n /* Tries to replace &a[idx] CODE s * delta with &a[idx CODE delta], if s is\n-   step of the array.  ADDR is the address. MULT is the multiplicative expression.\n+   step of the array.  Reconstructs s and delta in the case of s * delta\n+   being an integer constant (and thus already folded).\n+   ADDR is the address. MULT is the multiplicative expression.\n    If the function succeeds, the new address expression is returned.  Otherwise\n    NULL_TREE is returned.  */\n \n static tree\n-try_move_mult_to_index (enum tree_code code, tree addr, tree mult)\n+try_move_mult_to_index (enum tree_code code, tree addr, tree op1)\n {\n   tree s, delta, step;\n-  tree arg0 = TREE_OPERAND (mult, 0), arg1 = TREE_OPERAND (mult, 1);\n   tree ref = TREE_OPERAND (addr, 0), pref;\n   tree ret, pos;\n   tree itype;\n \n-  STRIP_NOPS (arg0);\n-  STRIP_NOPS (arg1);\n-  \n-  if (TREE_CODE (arg0) == INTEGER_CST)\n+  /* Canonicalize op1 into a possibly non-constant delta\n+     and an INTEGER_CST s.  */\n+  if (TREE_CODE (op1) == MULT_EXPR)\n     {\n-      s = arg0;\n-      delta = arg1;\n+      tree arg0 = TREE_OPERAND (op1, 0), arg1 = TREE_OPERAND (op1, 1);\n+\n+      STRIP_NOPS (arg0);\n+      STRIP_NOPS (arg1);\n+  \n+      if (TREE_CODE (arg0) == INTEGER_CST)\n+        {\n+          s = arg0;\n+          delta = arg1;\n+        }\n+      else if (TREE_CODE (arg1) == INTEGER_CST)\n+        {\n+          s = arg1;\n+          delta = arg0;\n+        }\n+      else\n+        return NULL_TREE;\n     }\n-  else if (TREE_CODE (arg1) == INTEGER_CST)\n+  else if (TREE_CODE (op1) == INTEGER_CST)\n     {\n-      s = arg1;\n-      delta = arg0;\n+      delta = op1;\n+      s = NULL_TREE;\n     }\n   else\n-    return NULL_TREE;\n+    {\n+      /* Simulate we are delta * 1.  */\n+      delta = op1;\n+      s = integer_one_node;\n+    }\n \n   for (;; ref = TREE_OPERAND (ref, 0))\n     {\n       if (TREE_CODE (ref) == ARRAY_REF)\n \t{\n \t  step = array_ref_element_size (ref);\n-\n \t  if (TREE_CODE (step) != INTEGER_CST)\n \t    continue;\n \n-\t  itype = TREE_TYPE (step);\n+\t  if (s)\n+\t    {\n+\t      if (! tree_int_cst_equal (step, s))\n+                continue;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Try if delta is a multiple of step.  */\n+\t      tree mod = int_const_binop (TRUNC_MOD_EXPR, delta, step, 0);\n+\t      if (!integer_zerop (mod))\n+\t\tcontinue;\n \n-\t  /* If the type sizes do not match, we might run into problems\n-\t     when one of them would overflow.  */\n-\t  if (TYPE_PRECISION (itype) != TYPE_PRECISION (TREE_TYPE (s)))\n-\t    continue;\n+\t      delta = int_const_binop (EXACT_DIV_EXPR, delta, step, 0);\n+\t    }\n \n-\t  if (!operand_equal_p (step, fold_convert (itype, s), 0))\n+\t  itype = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (ref, 0)));\n+\t  if (! itype)\n \t    continue;\n \n-\t  delta = fold_convert (itype, delta);\n \t  break;\n \t}\n \n@@ -6330,8 +6356,9 @@ try_move_mult_to_index (enum tree_code code, tree addr, tree mult)\n     }\n \n   TREE_OPERAND (pos, 1) = fold_build2 (code, itype,\n-\t\t\t\t       TREE_OPERAND (pos, 1),\n-\t\t\t\t       delta);\n+\t\t\t\t       fold_convert (itype,\n+\t\t\t\t\t\t     TREE_OPERAND (pos, 1)),\n+\t\t\t\t       fold_convert (itype, delta));\n \n   return build1 (ADDR_EXPR, TREE_TYPE (addr), ret);\n }\n@@ -7441,15 +7468,13 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  /* Try replacing &a[i1] + c * i2 with &a[i1 + i2], if c is step\n \t     of the array.  Loop optimizer sometimes produce this type of\n \t     expressions.  */\n-\t  if (TREE_CODE (arg0) == ADDR_EXPR\n-\t      && TREE_CODE (arg1) == MULT_EXPR)\n+\t  if (TREE_CODE (arg0) == ADDR_EXPR)\n \t    {\n \t      tem = try_move_mult_to_index (PLUS_EXPR, arg0, arg1);\n \t      if (tem)\n \t\treturn fold_convert (type, fold (tem));\n \t    }\n-\t  else if (TREE_CODE (arg1) == ADDR_EXPR\n-\t\t   && TREE_CODE (arg0) == MULT_EXPR)\n+\t  else if (TREE_CODE (arg1) == ADDR_EXPR)\n \t    {\n \t      tem = try_move_mult_to_index (PLUS_EXPR, arg1, arg0);\n \t      if (tem)\n@@ -7867,8 +7892,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n       /* Try replacing &a[i1] - c * i2 with &a[i1 - i2], if c is step\n \t of the array.  Loop optimizer sometimes produce this type of\n \t expressions.  */\n-      if (TREE_CODE (arg0) == ADDR_EXPR\n-\t  && TREE_CODE (arg1) == MULT_EXPR)\n+      if (TREE_CODE (arg0) == ADDR_EXPR)\n \t{\n \t  tem = try_move_mult_to_index (MINUS_EXPR, arg0, arg1);\n \t  if (tem)"}, {"sha": "030b2feebed51b5b2ca531de046fc171d526e9c7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c554294001d28360a26956e7508231fca94f3074/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c554294001d28360a26956e7508231fca94f3074/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c554294001d28360a26956e7508231fca94f3074", "patch": "@@ -1,3 +1,9 @@\n+2005-05-11  Richard Guenther  <rguenth@gcc.gnu.org>\n+\n+\tPR middle-end/19807\n+\tPR tree-optimization/19639\n+\t* g++.dg/tree-ssa/pr19807.C: New testcase.\n+\n 2005-05-10  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR libfortran/21471"}, {"sha": "0ff10db8eb49598e71f723ddf08ecfe260517e48", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr19807.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c554294001d28360a26956e7508231fca94f3074/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr19807.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c554294001d28360a26956e7508231fca94f3074/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr19807.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr19807.C?ref=c554294001d28360a26956e7508231fca94f3074", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-optimized\" } */\n+\n+int a[4];\n+int *x, *y, *z;\n+\n+void foo(void)\n+{\n+\tx = &a[3] - 1;\n+\ty = &a[1] + 1;\n+\tz = 1 + &a[1];\n+}\n+\n+void bar(int i)\n+{\n+\tx = &a[i] - 1;\n+\ty = &a[i] + 1;\n+\tz = 1 + &a[i];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"&a\\\\\\[2\\\\\\]\" 3 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"&a\\\\\\[.* - 1\\\\\\]\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"&a\\\\\\[.* \\\\+ 1\\\\\\]\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "c83d2cdff9d10c80380d7d7c738b811ef53cd8e1", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c554294001d28360a26956e7508231fca94f3074/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c554294001d28360a26956e7508231fca94f3074/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=c554294001d28360a26956e7508231fca94f3074", "patch": "@@ -576,6 +576,12 @@ set_rhs (tree *stmt_p, tree expr)\n       if (!is_gimple_val (TREE_OPERAND (expr, 0)))\n \treturn false;\n     }\n+  else if (code == ADDR_EXPR)\n+    {\n+      if (TREE_CODE (TREE_OPERAND (expr, 0)) == ARRAY_REF\n+\t  && !is_gimple_val (TREE_OPERAND (TREE_OPERAND (expr, 0), 1)))\n+\treturn false;\n+    }\n   else if (code == COMPOUND_EXPR)\n     return false;\n "}]}