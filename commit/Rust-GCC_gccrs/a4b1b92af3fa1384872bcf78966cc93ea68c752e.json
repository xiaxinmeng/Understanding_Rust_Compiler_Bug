{"sha": "a4b1b92af3fa1384872bcf78966cc93ea68c752e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRiMWI5MmFmM2ZhMTM4NDg3MmJjZjc4OTY2Y2M5M2VhNjhjNzUyZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-01-20T23:20:18Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-01-20T23:20:18Z"}, "message": "expr.h (MUST_PASS_IN_STACK): Move implementation...\n\n        * expr.h (MUST_PASS_IN_STACK): Move implementation...\n        * calls.c (default_must_pass_in_stack): ... here.\n\nFrom-SVN: r61514", "tree": {"sha": "0e621df774f2b6ae7e3e0299e68ea6fb231b0044", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e621df774f2b6ae7e3e0299e68ea6fb231b0044"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4b1b92af3fa1384872bcf78966cc93ea68c752e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4b1b92af3fa1384872bcf78966cc93ea68c752e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4b1b92af3fa1384872bcf78966cc93ea68c752e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4b1b92af3fa1384872bcf78966cc93ea68c752e/comments", "author": null, "committer": null, "parents": [{"sha": "d530b07f81e389fde99a626460ea3b33a34b9a83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d530b07f81e389fde99a626460ea3b33a34b9a83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d530b07f81e389fde99a626460ea3b33a34b9a83"}], "stats": {"total": 79, "additions": 53, "deletions": 26}, "files": [{"sha": "6b827d4a888db75ee1f1351b064420ecb0ce55ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4b1b92af3fa1384872bcf78966cc93ea68c752e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4b1b92af3fa1384872bcf78966cc93ea68c752e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4b1b92af3fa1384872bcf78966cc93ea68c752e", "patch": "@@ -1,3 +1,8 @@\n+2003-01-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* expr.h (MUST_PASS_IN_STACK): Move implementation...\n+\t* calls.c (default_must_pass_in_stack): ... here.\n+\n 2003-01-20  Vladimir Makarov  <vmakarov@redhat.com>\n \n         * genattrtab.h (INSN_ALTS_FUNC_NAME): Move it from genautomata.c."}, {"sha": "8296b84b65cddd0f361aef326755b40b2de81ef2", "filename": "gcc/calls.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4b1b92af3fa1384872bcf78966cc93ea68c752e/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4b1b92af3fa1384872bcf78966cc93ea68c752e/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=a4b1b92af3fa1384872bcf78966cc93ea68c752e", "patch": "@@ -4656,3 +4656,48 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n \n   return sibcall_failure;\n }\n+\n+\n+/* Nonzero if we do not know how to pass TYPE solely in registers.\n+   We cannot do so in the following cases:\n+\n+   - if the type has variable size\n+   - if the type is marked as addressable (it is required to be constructed\n+     into the stack)\n+   - if the padding and mode of the type is such that a copy into a register\n+     would put it into the wrong part of the register.\n+\n+   Which padding can't be supported depends on the byte endianness.\n+\n+   A value in a register is implicitly padded at the most significant end.\n+   On a big-endian machine, that is the lower end in memory.\n+   So a value padded in memory at the upper end can't go in a register.\n+   For a little-endian machine, the reverse is true.  */\n+\n+bool\n+default_must_pass_in_stack (mode, type)\n+     enum machine_mode mode;\n+     tree type;\n+{\n+  if (!type)\n+    return true;\n+\n+  /* If the type has variable size...  */\n+  if (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+    return true;\n+\n+  /* If the type is marked as addressable (it is required\n+     to be constructed into the stack)...  */\n+  if (TREE_ADDRESSABLE (type))\n+    return true;\n+\n+  /* If the padding and mode of the type is such that a copy into\n+     a register would put it into the wrong part of the register.  */\n+  if (mode == BLKmode\n+      && int_size_in_bytes (type) % (PARM_BOUNDARY / BITS_PER_UNIT)\n+      && (FUNCTION_ARG_PADDING (mode, type)\n+\t  == (BYTES_BIG_ENDIAN ? upward : downward)))\n+    return true;\n+\n+  return false;\n+}"}, {"sha": "8db91189fe6f1c6434e00004afb786820354d8c7", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 26, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4b1b92af3fa1384872bcf78966cc93ea68c752e/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4b1b92af3fa1384872bcf78966cc93ea68c752e/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=a4b1b92af3fa1384872bcf78966cc93ea68c752e", "patch": "@@ -153,33 +153,10 @@ enum direction {none, upward, downward};  /* Value has this type.  */\n #define PRETEND_OUTGOING_VARARGS_NAMED 0\n #endif\n \n-/* Nonzero if we do not know how to pass TYPE solely in registers.\n-   We cannot do so in the following cases:\n-\n-   - if the type has variable size\n-   - if the type is marked as addressable (it is required to be constructed\n-     into the stack)\n-   - if the padding and mode of the type is such that a copy into a register\n-     would put it into the wrong part of the register.\n-\n-   Which padding can't be supported depends on the byte endianness.\n-\n-   A value in a register is implicitly padded at the most significant end.\n-   On a big-endian machine, that is the lower end in memory.\n-   So a value padded in memory at the upper end can't go in a register.\n-   For a little-endian machine, the reverse is true.  */\n-\n+/* Nonzero if we do not know how to pass TYPE solely in registers.  */\n #ifndef MUST_PASS_IN_STACK\n-#define MUST_PASS_IN_STACK(MODE,TYPE)\t\t\t\\\n-  ((TYPE) != 0\t\t\t\t\t\t\\\n-   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\\\n-       || TREE_ADDRESSABLE (TYPE)\t\t\t\\\n-       || ((MODE) == BLKmode \t\t\t\t\\\n-\t   && ! ((TYPE) != 0 && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST \\\n-\t\t && 0 == (int_size_in_bytes (TYPE)\t\\\n-\t\t\t  % (PARM_BOUNDARY / BITS_PER_UNIT))) \\\n-\t   && (FUNCTION_ARG_PADDING (MODE, TYPE)\t\\\n-\t       == (BYTES_BIG_ENDIAN ? upward : downward)))))\n+extern bool default_must_pass_in_stack PARAMS((enum machine_mode, tree));\n+#define MUST_PASS_IN_STACK(MODE,TYPE) default_must_pass_in_stack(MODE, TYPE)\n #endif\n \n /* Nonzero if type TYPE should be returned in memory."}]}