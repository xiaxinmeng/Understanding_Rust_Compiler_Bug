{"sha": "25adc5fbf5c9ac211442106de78cba432212449c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVhZGM1ZmJmNWM5YWMyMTE0NDIxMDZkZTc4Y2JhNDMyMjEyNDQ5Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2010-06-16T16:30:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-16T16:30:48Z"}, "message": "get_scos.adb, [...]: Code clean up, update documentation.\n\n\t* get_scos.adb, par_sco.adb, par_sco.ads, put_scos.adb, scos.adb,\n\tscos.ads, exp_ch4.adb, sem_warn.adb: Code clean up, update\n\tdocumentation.\n\nFrom-SVN: r160849", "tree": {"sha": "c15915818fefe732dbe57105e1e89f4316dbd193", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c15915818fefe732dbe57105e1e89f4316dbd193"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25adc5fbf5c9ac211442106de78cba432212449c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25adc5fbf5c9ac211442106de78cba432212449c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25adc5fbf5c9ac211442106de78cba432212449c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25adc5fbf5c9ac211442106de78cba432212449c/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e1578ff354a8d03c4c46eaef6825d0b77885d6a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1578ff354a8d03c4c46eaef6825d0b77885d6a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1578ff354a8d03c4c46eaef6825d0b77885d6a3"}], "stats": {"total": 1260, "additions": 776, "deletions": 484}, "files": [{"sha": "a6243129b827f893895bb1aafca0d996d56b9ea4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25adc5fbf5c9ac211442106de78cba432212449c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25adc5fbf5c9ac211442106de78cba432212449c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=25adc5fbf5c9ac211442106de78cba432212449c", "patch": "@@ -1,3 +1,9 @@\n+2010-06-16  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* get_scos.adb, par_sco.adb, par_sco.ads, put_scos.adb, scos.adb,\n+\tscos.ads, exp_ch4.adb, sem_warn.adb: Code clean up, update\n+\tdocumentation.\n+\n 2010-06-16  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_disp.adb (Expand_Dispatching_Call): Adjust the decoration of the"}, {"sha": "6846b75c64d9cc403d2c20ac82eda47839c561cf", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 80, "deletions": 31, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25adc5fbf5c9ac211442106de78cba432212449c/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25adc5fbf5c9ac211442106de78cba432212449c/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=25adc5fbf5c9ac211442106de78cba432212449c", "patch": "@@ -47,6 +47,7 @@ with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n+with Par_SCO;  use Par_SCO;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n@@ -8676,7 +8677,6 @@ package body Exp_Ch4 is\n \n       Result := New_Reference_To (Standard_True, Loc);\n       C := Suitable_Element (First_Entity (Typ));\n-\n       while Present (C) loop\n          declare\n             New_Lhs : Node_Id;\n@@ -8745,7 +8745,28 @@ package body Exp_Ch4 is\n       Shortcut_Ent   : constant Entity_Id := Boolean_Literals (Shortcut_Value);\n       --  If Left = Shortcut_Value then Right need not be evaluated\n \n-      Expr_If_Left_True, Expr_If_Left_False : Node_Id;\n+      function Make_Test_Expr (Opnd : Node_Id) return Node_Id;\n+      --  For Opnd a boolean expression, return a Boolean expression equivalent\n+      --  to Opnd /= Shortcut_Value.\n+\n+      --------------------\n+      -- Make_Test_Expr --\n+      --------------------\n+\n+      function Make_Test_Expr (Opnd : Node_Id) return Node_Id is\n+      begin\n+         if Shortcut_Value then\n+            return Make_Op_Not (Sloc (Opnd), Opnd);\n+         else\n+            return Opnd;\n+         end if;\n+      end Make_Test_Expr;\n+\n+      Op_Var : Entity_Id;\n+      --  Entity for a temporary variable holding the value of the operator,\n+      --  used for expansion in the case where actions are present.\n+\n+   --  Start of processing for Expand_Short_Circuit_Operator\n \n    begin\n       --  Deal with non-standard booleans\n@@ -8759,6 +8780,13 @@ package body Exp_Ch4 is\n       --  Check for cases where left argument is known to be True or False\n \n       if Compile_Time_Known_Value (Left) then\n+\n+         --  Mark SCO for left condition as compile time known\n+\n+         if Generate_SCO and then Comes_From_Source (Left) then\n+            Set_SCO_Condition (Left, Expr_Value_E (Left) = Standard_True);\n+         end if;\n+\n          --  Rewrite True AND THEN Right / False OR ELSE Right to Right.\n          --  Any actions associated with Right will be executed unconditionally\n          --  and can thus be inserted into the tree unconditionally.\n@@ -8787,40 +8815,60 @@ package body Exp_Ch4 is\n       --  If Actions are present, we expand\n \n       --     left AND THEN right\n-      --     left OR ELSE right\n \n       --  into\n \n-      --     if left then right else false end\n-      --     if left then true else right end\n+      --     C : Boolean := False;\n+      --     IF left THEN\n+      --        Actions;\n+      --        IF right THEN\n+      --           C := True;\n+      --        END IF;\n+      --     END IF;\n \n-      --  with the actions for the right operand being transferred to the\n-      --  approriate actions list of the conditional expression. This\n-      --  conditional expression is then further expanded (and will eventually\n-      --  disappear).\n+      --  and finally rewrite the operator into a reference to C. Similarly\n+      --  for left OR ELSE right, with negated values. Note that this rewriting\n+      --  preserves two invariants that traces-based coverage analysis depends\n+      --  upon:\n+\n+      --    - there is exactly one conditional jump for each operand;\n+\n+      --    - for each possible values of the expression, there is exactly\n+      --      one location in the generated code that is branched to\n+      --      (the inner assignment in one case, the point just past the\n+      --      outer END IF; in the other case).\n \n       if Present (Actions (N)) then\n          Actlist := Actions (N);\n \n-         if Kind = N_And_Then then\n-            Expr_If_Left_True  := Right;\n-            Expr_If_Left_False := New_Occurrence_Of (Standard_False, Loc);\n+         Op_Var := Make_Temporary (Loc, 'C', Related_Node => N);\n \n-         else\n-            Expr_If_Left_True  := New_Occurrence_Of (Standard_True, Loc);\n-            Expr_If_Left_False := Right;\n-         end if;\n+         Insert_Action (N,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier =>\n+               Op_Var,\n+             Object_Definition =>\n+               New_Occurrence_Of (Standard_Boolean, Loc),\n+             Expression =>\n+               New_Occurrence_Of (Shortcut_Ent, Loc)));\n+\n+         Append_To (Actlist,\n+           Make_Implicit_If_Statement (Right,\n+             Condition       => Make_Test_Expr (Right),\n+             Then_Statements => New_List (\n+               Make_Assignment_Statement (Sloc (Right),\n+                 Name =>\n+                   New_Occurrence_Of (Op_Var, Sloc (Right)),\n+                 Expression =>\n+                   New_Occurrence_Of\n+                     (Boolean_Literals (not Shortcut_Value), Sloc (Right))))));\n \n-         Rewrite (N,\n-            Make_Conditional_Expression (Loc,\n-              Expressions => New_List (\n-                Left,\n-                Expr_If_Left_True,\n-                Expr_If_Left_False)));\n+         Insert_Action (N,\n+           Make_Implicit_If_Statement (Left,\n+             Condition       => Make_Test_Expr (Left),\n+             Then_Statements => Actlist));\n \n-         --  If the right part of an AND THEN is a function call then it can\n-         --  be part of the expansion of the predefined equality operator of a\n-         --  tagged type and we may need to adjust its SCIL dispatching node.\n+         Rewrite (N, New_Occurrence_Of (Op_Var, Loc));\n \n          if Generate_SCIL\n            and then Kind = N_And_Then\n@@ -8829,12 +8877,6 @@ package body Exp_Ch4 is\n             Adjust_SCIL_Node (N, Right);\n          end if;\n \n-         if Kind = N_And_Then then\n-            Set_Then_Actions (N, Actlist);\n-         else\n-            Set_Else_Actions (N, Actlist);\n-         end if;\n-\n          Analyze_And_Resolve (N, Standard_Boolean);\n          Adjust_Result_Type (N, Typ);\n          return;\n@@ -8843,6 +8885,13 @@ package body Exp_Ch4 is\n       --  No actions present, check for cases of right argument True/False\n \n       if Compile_Time_Known_Value (Right) then\n+\n+         --  Mark SCO for left condition as compile time known\n+\n+         if Generate_SCO and then Comes_From_Source (Right) then\n+            Set_SCO_Condition (Right, Expr_Value_E (Right) = Standard_True);\n+         end if;\n+\n          --  Change (Left and then True), (Left or else False) to Left.\n          --  Note that we know there are no actions associated with the right\n          --  operand, since we just checked for this case above."}, {"sha": "04fbd51db46ef19b721522bf14d658ac12a8b6fb", "filename": "gcc/ada/get_scos.adb", "status": "modified", "additions": 98, "deletions": 64, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25adc5fbf5c9ac211442106de78cba432212449c/gcc%2Fada%2Fget_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25adc5fbf5c9ac211442106de78cba432212449c/gcc%2Fada%2Fget_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_scos.adb?ref=25adc5fbf5c9ac211442106de78cba432212449c", "patch": "@@ -54,7 +54,12 @@ procedure Get_SCOs is\n    --  value read. Data_Error is raised for overflow (value greater than\n    --  Int'Last), or if the initial character is not a digit.\n \n-   procedure Get_Sloc_Range (Loc1, Loc2 : out Source_Location);\n+   procedure Get_Source_Location (Loc : out Source_Location);\n+   --  Reads a source location in the form line:col and places the source\n+   --  location in Loc. Raises Data_Error if the format does not match this\n+   --  requirement. Note that initial spaces are not skipped.\n+\n+   procedure Get_Source_Location_Range (Loc1, Loc2 : out Source_Location);\n    --  Skips initial spaces, then reads a source location range in the form\n    --  line:col-line:col and places the two source locations in Loc1 and Loc2.\n    --  Raises Data_Error if format does not match this requirement.\n@@ -129,31 +134,32 @@ procedure Get_SCOs is\n          raise Data_Error;\n    end Get_Int;\n \n-   --------------------\n-   -- Get_Sloc_Range --\n-   --------------------\n+   -------------------------\n+   -- Get_Source_Location --\n+   -------------------------\n \n-   procedure Get_Sloc_Range (Loc1, Loc2 : out Source_Location) is\n+   procedure Get_Source_Location (Loc : out Source_Location) is\n       pragma Unsuppress (Range_Check);\n-\n    begin\n-      Skip_Spaces;\n-\n-      Loc1.Line := Logical_Line_Number (Get_Int);\n-      Check (':');\n-      Loc1.Col := Column_Number (Get_Int);\n-\n-      Check ('-');\n-\n-      Loc2.Line := Logical_Line_Number (Get_Int);\n+      Loc.Line := Logical_Line_Number (Get_Int);\n       Check (':');\n-      Loc2.Col := Column_Number (Get_Int);\n-\n+      Loc.Col := Column_Number (Get_Int);\n    exception\n       when Constraint_Error =>\n          raise Data_Error;\n-   end Get_Sloc_Range;\n+   end Get_Source_Location;\n+\n+   -------------------------------\n+   -- Get_Source_Location_Range --\n+   -------------------------------\n \n+   procedure Get_Source_Location_Range (Loc1, Loc2 : out Source_Location) is\n+   begin\n+      Skip_Spaces;\n+      Get_Source_Location (Loc1);\n+      Check ('-');\n+      Get_Source_Location (Loc2);\n+   end Get_Source_Location_Range;\n    --------------\n    -- Skip_EOL --\n    --------------\n@@ -222,8 +228,8 @@ begin\n             --  Scan out dependency number and file name\n \n             declare\n-               Ptr  : String_Ptr := new String (1 .. 32768);\n-               N    : Integer;\n+               Ptr : String_Ptr := new String (1 .. 32768);\n+               N   : Integer;\n \n             begin\n                Skip_Spaces;\n@@ -250,14 +256,31 @@ begin\n \n          --  Statement entry\n \n-         when 'S' =>\n+         when 'S' | 's' =>\n             declare\n                Typ : Character;\n                Key : Character;\n \n             begin\n+               --  If continuation, reset Last indication in last entry\n+               --  stored for previous CS or cs line, and start with key\n+               --  set to s for continuations.\n+\n+               if C = 's' then\n+                  SCO_Table.Table (SCO_Table.Last).Last := False;\n+                  Key := 's';\n+\n+               --  CS case (first line, so start with key set to S)\n+\n+               else\n+                  Key := 'S';\n+               end if;\n+\n+               --  Initialize to scan items on one line\n+\n                Skip_Spaces;\n-               Key := 'S';\n+\n+               --  Loop through items on one line\n \n                loop\n                   Typ := Nextc;\n@@ -268,7 +291,7 @@ begin\n                      Skipc;\n                   end if;\n \n-                  Get_Sloc_Range (Loc1, Loc2);\n+                  Get_Source_Location_Range (Loc1, Loc2);\n \n                   Add_SCO\n                     (C1   => Key,\n@@ -287,60 +310,71 @@ begin\n          when 'I' | 'E' | 'P' | 'W' | 'X' =>\n             Dtyp := C;\n             Skip_Spaces;\n-            C := Getc;\n \n-            --  Case of simple condition\n+            --  Output header\n+\n+            declare\n+               Loc : Source_Location;\n+\n+            begin\n+               --  Acquire location information\n+\n+               if Dtyp = 'X' then\n+                  Loc := No_Source_Location;\n+               else\n+                  Get_Source_Location (Loc);\n+               end if;\n \n-            if C = 'c' or else C = 't' or else C = 'f' then\n-               Cond := C;\n-               Get_Sloc_Range (Loc1, Loc2);\n                Add_SCO\n                  (C1   => Dtyp,\n-                  C2   => Cond,\n-                  From => Loc1,\n-                  To   => Loc2,\n-                  Last => True);\n+                  C2   => ' ',\n+                  From => Loc,\n+                  To   => No_Source_Location,\n+                  Last => False);\n+            end;\n \n-            --  Complex expression\n+            --  Loop through terms in complex expression\n+\n+            C := Nextc;\n+            while C /= CR and then C /= LF loop\n+               if C = 'c' or else C = 't' or else C = 'f' then\n+                  Cond := C;\n+                  Skipc;\n+                  Get_Source_Location_Range (Loc1, Loc2);\n+                  Add_SCO\n+                    (C2   => Cond,\n+                     From => Loc1,\n+                     To   => Loc2,\n+                     Last => False);\n \n-            else\n-               Add_SCO (C1 => Dtyp, Last => False);\n+               elsif C = '!' or else\n+                     C = '&' or else\n+                     C = '|'\n+               then\n+                  Skipc;\n \n-               --  Loop through terms in complex expression\n+                  declare\n+                     Loc : Source_Location;\n+                  begin\n+                     Get_Source_Location (Loc);\n+                     Add_SCO (C1 => C, From => Loc, Last => False);\n+                  end;\n \n-               while C /= CR and then C /= LF loop\n-                  if C = 'c' or else C = 't' or else C = 'f' then\n-                     Cond := C;\n-                     Skipc;\n-                     Get_Sloc_Range (Loc1, Loc2);\n-                     Add_SCO\n-                       (C2   => Cond,\n-                        From => Loc1,\n-                        To   => Loc2,\n-                        Last => False);\n-\n-                  elsif C = '!' or else\n-                        C = '^' or else\n-                        C = '&' or else\n-                        C = '|'\n-                  then\n-                     Skipc;\n-                     Add_SCO (C1 => C, Last => False);\n+               elsif C = ' ' then\n+                  Skip_Spaces;\n \n-                  elsif C = ' ' then\n-                     Skip_Spaces;\n+               else\n+                  raise Data_Error;\n+               end if;\n \n-                  else\n-                     raise Data_Error;\n-                  end if;\n+               C := Nextc;\n+            end loop;\n \n-                  C := Nextc;\n-               end loop;\n+            --  Reset Last indication to True for last entry\n \n-               --  Reset Last indication to True for last entry\n+            SCO_Table.Table (SCO_Table.Last).Last := True;\n \n-               SCO_Table.Table (SCO_Table.Last).Last := True;\n-            end if;\n+         --  No other SCO lines are possible\n \n          when others =>\n             raise Data_Error;"}, {"sha": "5b5e4cf4d494fbb1084334c3998c9f9afe5879a3", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 402, "deletions": 150, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25adc5fbf5c9ac211442106de78cba432212449c/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25adc5fbf5c9ac211442106de78cba432212449c/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=25adc5fbf5c9ac211442106de78cba432212449c", "patch": "@@ -104,8 +104,9 @@ package body Par_SCO is\n    --  If N is Empty, has no effect. Otherwise scans the tree for the node N,\n    --  to output any decisions it contains. T is one of IEPWX (for context of\n    --  expresion: if/exit when/pragma/while/expression). If T is other than X,\n-   --  then a decision is always present (at the very least a simple decision\n-   --  is present at the top level).\n+   --  the node N is the conditional expression involved, and a decision is\n+   --  always present (at the very least a simple decision is present at the\n+   --  top level).\n \n    procedure Process_Decisions (L : List_Id; T : Character);\n    --  Calls above procedure for each element of the list L\n@@ -115,15 +116,18 @@ package body Par_SCO is\n       C2   : Character;\n       From : Source_Ptr;\n       To   : Source_Ptr;\n+      Node : Node_Id;\n       Last : Boolean);\n    --  Append an entry to SCO_Table with fields set as per arguments\n \n    procedure Traverse_Declarations_Or_Statements  (L : List_Id);\n+   procedure Traverse_Generic_Instantiation       (N : Node_Id);\n    procedure Traverse_Generic_Package_Declaration (N : Node_Id);\n    procedure Traverse_Handled_Statement_Sequence  (N : Node_Id);\n    procedure Traverse_Package_Body                (N : Node_Id);\n    procedure Traverse_Package_Declaration         (N : Node_Id);\n    procedure Traverse_Subprogram_Body             (N : Node_Id);\n+   procedure Traverse_Subprogram_Declaration      (N : Node_Id);\n    --  Traverse the corresponding construct, generating SCO table entries\n \n    procedure Write_SCOs_To_ALI_File is new Put_SCOs;\n@@ -228,6 +232,11 @@ package body Par_SCO is\n                Write_Str (\"  False\");\n             end if;\n \n+            if Present (T.Node) then\n+               Write_Str (\"  Node = \");\n+               Write_Int (Int (T.Node));\n+            end if;\n+\n             Write_Eol;\n          end;\n       end loop;\n@@ -299,8 +308,7 @@ package body Par_SCO is\n \n    function Is_Logical_Operator (N : Node_Id) return Boolean is\n    begin\n-      return Nkind_In (N, N_Op_Xor,\n-                          N_Op_Not,\n+      return Nkind_In (N, N_Op_Not,\n                           N_And_Then,\n                           N_Or_Else);\n    end Is_Logical_Operator;\n@@ -327,6 +335,17 @@ package body Par_SCO is\n \n    procedure Process_Decisions (N : Node_Id; T : Character) is\n \n+      Mark : Nat;\n+      --  This is used to mark the location of a decision sequence in the SCO\n+      --  table. We use it for backing out a simple decision in an expression\n+      --  context that contains only NOT operators.\n+\n+      X_Not_Decision : Boolean;\n+      --  This flag keeps track of whether a decision sequence in the SCO table\n+      --  contains only NOT operators, and is for an expression context (T=X).\n+      --  The flag will be set False if T is other than X, or if an operator\n+      --  other than NOT is in the sequence.\n+\n       function Process_Node (N : Node_Id) return Traverse_Result;\n       --  Processes one node in the traversal, looking for logical operators,\n       --  and if one is found, outputs the appropriate table entries.\n@@ -340,13 +359,15 @@ package body Par_SCO is\n       --  Process_Decision_Operand, because we can't get decisions mixed up in\n       --  the global table. Call has no effect if N is Empty.\n \n-      procedure Output_Element (N : Node_Id; T : Character);\n+      procedure Output_Element (N : Node_Id);\n       --  Node N is an operand of a logical operator that is not itself a\n       --  logical operator, or it is a simple decision. This routine outputs\n-      --  the table entry for the element, with C1 set to T (' ' for one of\n-      --  the elements of a complex decision, or 'I'/'W'/'E' for a simple\n-      --  decision (from an IF, WHILE, or EXIT WHEN). Last is set to False,\n-      --  and an entry is made in the condition hash table.\n+      --  the table entry for the element, with C1 set to ' '. Last is set\n+      --  False, and an entry is made in the condition hash table.\n+\n+      procedure Output_Header (T : Character);\n+      --  Outputs a decision header node. T is I/W/E/P for IF/WHILE/EXIT WHEN/\n+      --  PRAGMA, and 'X' for the expression case.\n \n       procedure Process_Decision_Operand (N : Node_Id);\n       --  This is called on node N, the top level node of a decision, or on one\n@@ -376,40 +397,108 @@ package body Par_SCO is\n             else\n                L := Left_Opnd (N);\n \n-               if Nkind (N) = N_Op_Xor then\n-                  C := '^';\n-               elsif Nkind_In (N, N_Op_Or, N_Or_Else) then\n+               if Nkind_In (N, N_Op_Or, N_Or_Else) then\n                   C := '|';\n                else\n                   C := '&';\n                end if;\n             end if;\n \n-            Set_Table_Entry (C, ' ', No_Location, No_Location, False);\n+            Set_Table_Entry\n+              (C1   => C,\n+               C2   => ' ',\n+               From => Sloc (N),\n+               To   => No_Location,\n+               Node => Empty,\n+               Last => False);\n \n             Output_Decision_Operand (L);\n             Output_Decision_Operand (Right_Opnd (N));\n \n          --  Not a logical operator\n \n          else\n-            Output_Element (N, ' ');\n+            Output_Element (N);\n          end if;\n       end Output_Decision_Operand;\n \n       --------------------\n       -- Output_Element --\n       --------------------\n \n-      procedure Output_Element (N : Node_Id; T : Character) is\n+      procedure Output_Element (N : Node_Id) is\n          FSloc : Source_Ptr;\n          LSloc : Source_Ptr;\n       begin\n          Sloc_Range (N, FSloc, LSloc);\n-         Set_Table_Entry (T, 'c', FSloc, LSloc, False);\n+         Set_Table_Entry\n+           (C1   => ' ',\n+            C2   => 'c',\n+            From => FSloc,\n+            To   => LSloc,\n+            Node => Empty,\n+            Last => False);\n          Condition_Hash_Table.Set (FSloc, SCO_Table.Last);\n       end Output_Element;\n \n+      -------------------\n+      -- Output_Header --\n+      -------------------\n+\n+      procedure Output_Header (T : Character) is\n+      begin\n+         case T is\n+            when 'I' | 'E' | 'W' =>\n+\n+               --  For IF, EXIT, WHILE, the token SLOC can be found from\n+               --  the SLOC of the parent of the expression.\n+\n+               Set_Table_Entry\n+                 (C1   => T,\n+                  C2   => ' ',\n+                  From => Sloc (Parent (N)),\n+                  To   => No_Location,\n+                  Node => Empty,\n+                  Last => False);\n+\n+            when 'P' =>\n+\n+               --  For PRAGMA, we must record the pragma node. Argument N\n+               --  is the pragma argument, and we have to go up two levels\n+               --  (through the pragma argument association) to get to the\n+               --  pragma node itself.\n+\n+               declare\n+                  Pnode : constant Node_Id := Parent (Parent (N));\n+               begin\n+                  Set_Table_Entry\n+                    (C1   => 'P',\n+                     C2   => ' ',\n+                     From => Sloc (Pnode),\n+                     To   => No_Location,\n+                     Node => Pnode,\n+                     Last => False);\n+               end;\n+\n+            when 'X' =>\n+\n+               --  For an expression, no Sloc\n+\n+               Set_Table_Entry\n+                 (C1   => 'X',\n+                  C2   => ' ',\n+                  From => No_Location,\n+                  To   => No_Location,\n+                  Node => Empty,\n+                  Last => False);\n+\n+            --  No other possibilities\n+\n+            when others =>\n+               raise Program_Error;\n+         end case;\n+      end Output_Header;\n+\n       ------------------------------\n       -- Process_Decision_Operand --\n       ------------------------------\n@@ -419,6 +508,7 @@ package body Par_SCO is\n          if Is_Logical_Operator (N) then\n             if Nkind (N) /= N_Op_Not then\n                Process_Decision_Operand (Left_Opnd (N));\n+               X_Not_Decision := False;\n             end if;\n \n             Process_Decision_Operand (Right_Opnd (N));\n@@ -439,9 +529,9 @@ package body Par_SCO is\n                --  Logical operators, output table entries and then process\n                --  operands recursively to deal with nested conditions.\n \n-            when N_And_Then                    |\n-                 N_Or_Else                     |\n-                 N_Op_Not                      =>\n+            when N_And_Then |\n+                 N_Or_Else  |\n+                 N_Op_Not   =>\n \n                declare\n                   T : Character;\n@@ -458,15 +548,26 @@ package body Par_SCO is\n \n                   --  Output header for sequence\n \n-                  Set_Table_Entry (T, ' ', No_Location, No_Location, False);\n+                  X_Not_Decision := T = 'X' and then Nkind (N) = N_Op_Not;\n+                  Mark := SCO_Table.Last;\n+                  Output_Header (T);\n \n                   --  Output the decision\n \n                   Output_Decision_Operand (N);\n \n-                  --  Change Last in last table entry to True to mark end\n+                  --  If the decision was in an expression context (T = 'X')\n+                  --  and contained only NOT operators, then we don't output\n+                  --  it, so delete it.\n \n-                  SCO_Table.Table (SCO_Table.Last).Last := True;\n+                  if X_Not_Decision then\n+                     SCO_Table.Set_Last (Mark);\n+\n+                  --  Otherwise, set Last in last table entry to mark end\n+\n+                  else\n+                     SCO_Table.Table (SCO_Table.Last).Last := True;\n+                  end if;\n \n                   --  Process any embedded decisions\n \n@@ -476,7 +577,7 @@ package body Par_SCO is\n \n             --  Conditional expression, processed like an if statement\n \n-            when N_Conditional_Expression      =>\n+            when N_Conditional_Expression =>\n                declare\n                   Cond : constant Node_Id := First (Expressions (N));\n                   Thnx : constant Node_Id := Next (Cond);\n@@ -508,11 +609,12 @@ package body Par_SCO is\n       --  See if we have simple decision at outer level and if so then\n       --  generate the decision entry for this simple decision. A simple\n       --  decision is a boolean expression (which is not a logical operator\n-      --  or short circuit form) appearing as the operand of an IF, WHILE\n-      --  or EXIT WHEN construct.\n+      --  or short circuit form) appearing as the operand of an IF, WHILE,\n+      --  EXIT WHEN, or special PRAGMA construct.\n \n       if T /= 'X' and then not Is_Logical_Operator (N) then\n-         Output_Element (N, T);\n+         Output_Header (T);\n+         Output_Element (N);\n \n          --  Change Last in last table entry to True to mark end of\n          --  sequence, which is this case is only one element long.\n@@ -671,6 +773,9 @@ package body Par_SCO is\n       if Nkind (Lu) = N_Subprogram_Body then\n          Traverse_Subprogram_Body (Lu);\n \n+      elsif Nkind (Lu) = N_Subprogram_Declaration then\n+         Traverse_Subprogram_Declaration (Lu);\n+\n       elsif Nkind (Lu) = N_Package_Declaration then\n          Traverse_Package_Declaration (Lu);\n \n@@ -680,12 +785,14 @@ package body Par_SCO is\n       elsif Nkind (Lu) = N_Generic_Package_Declaration then\n          Traverse_Generic_Package_Declaration (Lu);\n \n-      --  For anything else, the only issue is default expressions for\n-      --  parameters, where we have to worry about possible embedded decisions\n-      --  but nothing else.\n+      elsif Nkind (Lu) in N_Generic_Instantiation then\n+         Traverse_Generic_Instantiation (Lu);\n+\n+      --  All other cases of compilation units (e.g. renamings), generate\n+      --  no SCO information.\n \n       else\n-         Process_Decisions (Lu, 'X');\n+         null;\n       end if;\n \n       --  Make entry for new unit in unit tables, we will fill in the file\n@@ -704,11 +811,20 @@ package body Par_SCO is\n    -- Set_SCO_Condition --\n    -----------------------\n \n-   procedure Set_SCO_Condition (First_Loc : Source_Ptr; Typ : Character) is\n-      Index : constant Nat := Condition_Hash_Table.Get (First_Loc);\n+   procedure Set_SCO_Condition (Cond : Node_Id; Val : Boolean) is\n+      Orig  : constant Node_Id := Original_Node (Cond);\n+      Index : Nat;\n+      Start : Source_Ptr;\n+      Dummy : Source_Ptr;\n+\n+      Constant_Condition_Code : constant array (Boolean) of Character :=\n+                                  (False => 'f', True => 't');\n    begin\n+      Sloc_Range (Orig, Start, Dummy);\n+      Index := Condition_Hash_Table.Get (Start);\n+\n       if Index /= 0 then\n-         SCO_Table.Table (Index).C2 := Typ;\n+         SCO_Table.Table (Index).C2 := Constant_Condition_Code (Val);\n       end if;\n    end Set_SCO_Condition;\n \n@@ -721,6 +837,7 @@ package body Par_SCO is\n       C2   : Character;\n       From : Source_Ptr;\n       To   : Source_Ptr;\n+      Node : Node_Id;\n       Last : Boolean)\n    is\n       function To_Source_Location (S : Source_Ptr) return Source_Location;\n@@ -749,41 +866,81 @@ package body Par_SCO is\n          C2   => C2,\n          From => To_Source_Location (From),\n          To   => To_Source_Location (To),\n+         Node => Node,\n          Last => Last);\n    end Set_Table_Entry;\n \n    -----------------------------------------\n    -- Traverse_Declarations_Or_Statements --\n    -----------------------------------------\n \n+   --  Tables used by Traverse_Declarations_Or_Statements for temporarily\n+   --  holding statement and decision entries. These are declared globally\n+   --  since they are shared by recursive calls to this procedure.\n+\n+   type SC_Entry is record\n+      From : Source_Ptr;\n+      To   : Source_Ptr;\n+      Typ  : Character;\n+   end record;\n+   --  Used to store a single entry in the following table, From:To represents\n+   --  the range of entries in the CS line entry, and typ is the type, with\n+   --  space meaning that no type letter will accompany the entry.\n+\n+   package SC is new Table.Table (\n+     Table_Component_Type => SC_Entry,\n+     Table_Index_Type     => Nat,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 1000,\n+     Table_Increment      => 200,\n+     Table_Name           => \"SCO_SC\");\n+      --  Used to store statement components for a CS entry to be output\n+      --  as a result of the call to this procedure. SC.Last is the last\n+      --  entry stored, so the current statement sequence is represented\n+      --  by SC_Array (SC_First .. SC.Last), where SC_First is saved on\n+      --  entry to each recursive call to the routine.\n+      --\n+      --  Extend_Statement_Sequence adds an entry to this array, and then\n+      --  Set_Statement_Entry clears the entries starting with SC_First,\n+      --  copying these entries to the main SCO output table. The reason that\n+      --  we do the temporary caching of results in this array is that we want\n+      --  the SCO table entries for a given CS line to be contiguous, and the\n+      --  processing may output intermediate entries such as decision entries.\n+\n+   type SD_Entry is record\n+      Nod : Node_Id;\n+      Lst : List_Id;\n+      Typ : Character;\n+   end record;\n+   --  Used to store a single entry in the following table. Nod is the node to\n+   --  be searched for decisions for the case of Process_Decisions_Defer with a\n+   --  node argument (with Lst set to No_List. Lst is the list to be searched\n+   --  for decisions for the case of Process_Decisions_Defer with a List\n+   --  argument (in which case Nod is set to Empty).\n+\n+   package SD is new Table.Table (\n+     Table_Component_Type => SD_Entry,\n+     Table_Index_Type     => Nat,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 1000,\n+     Table_Increment      => 200,\n+     Table_Name           => \"SCO_SD\");\n+   --  Used to store possible decision information. Instead of calling the\n+   --  Process_Decisions procedures directly, we call Process_Decisions_Defer,\n+   --  which simply stores the arguments in this table. Then when we clear\n+   --  out a statement sequence using Set_Statement_Entry, after generating\n+   --  the CS lines for the statements, the entries in this table result in\n+   --  calls to Process_Decision. The reason for doing things this way is to\n+   --  ensure that decisions are output after the CS line for the statements\n+   --  in which the decisions occur.\n+\n    procedure Traverse_Declarations_Or_Statements (L : List_Id) is\n       N     : Node_Id;\n       Dummy : Source_Ptr;\n \n-      type SC_Entry is record\n-         From : Source_Ptr;\n-         To   : Source_Ptr;\n-         Typ  : Character;\n-      end record;\n-      --  Used to store a single entry in the following array\n-\n-      SC_Array : array (Nat range 1 .. 10_000) of SC_Entry;\n-      SC_Last  : Nat;\n-      --  Used to store statement components for a CS entry to be output\n-      --  as a result of the call to this procedure. SC_Last is the last\n-      --  entry stored, so the current statement sequence is represented\n-      --  by SC_Array (1 .. SC_Last). Extend_Statement_Sequence adds an\n-      --  entry to this array, and Set_Statement_Entry clears it, copying\n-      --  the entries to the main SCO output table. The reason that we do\n-      --  the temporary caching of results in this array is that we want\n-      --  the SCO table entries for a given CS line to be contiguous, and\n-      --  the processing may output intermediate entries such as decision\n-      --  entries. Note that the limit of 10_000 here is arbitrary, but does\n-      --  not cause any trouble, if we encounter more than 10_000 statements\n-      --  we simply break the current CS sequence at that point, which is\n-      --  harmless, since this is only used for back annotation and it is\n-      --  not critical that back annotation always work in all cases. Anyway\n-      --  exceeding 10,000 statements in a basic block is very unlikely.\n+      SC_First : constant Nat := SC.Last + 1;\n+      SD_First : constant Nat := SD.Last + 1;\n+      --  Record first entries used in SC/SD at this recursive level\n \n       procedure Extend_Statement_Sequence (N : Node_Id; Typ : Character);\n       --  Extend the current statement sequence to encompass the node N. Typ\n@@ -806,81 +963,115 @@ package body Par_SCO is\n       --  called when we find a statement or declaration that generates its\n       --  own table entry, so that we must end the current statement sequence.\n \n+      procedure Process_Decisions_Defer (N : Node_Id; T : Character);\n+      pragma Inline (Process_Decisions_Defer);\n+      --  This routine is logically the same as Process_Decisions, except that\n+      --  the arguments are saved in the SD table, for later processing when\n+      --  Set_Statement_Entry is called, which goes through the saved entries\n+      --  making the corresponding calls to Process_Decision.\n+\n+      procedure Process_Decisions_Defer (L : List_Id; T : Character);\n+      pragma Inline (Process_Decisions_Defer);\n+      --  Same case for list arguments, deferred call to Process_Decisions\n+\n       -------------------------\n       -- Set_Statement_Entry --\n       -------------------------\n \n       procedure Set_Statement_Entry is\n-         C1   : Character;\n+         C1      : Character;\n+         SC_Last : constant Int := SC.Last;\n+         SD_Last : constant Int := SD.Last;\n \n       begin\n-         if SC_Last /= 0 then\n-            for J in 1 .. SC_Last loop\n-               if J = 1 then\n-                  C1 := 'S';\n-               else\n-                  C1 := 's';\n-               end if;\n+         --  Output statement entries from saved entries in SC table\n+\n+         for J in SC_First .. SC_Last loop\n+            if J = SC_First then\n+               C1 := 'S';\n+            else\n+               C1 := 's';\n+            end if;\n \n+            declare\n+               SCE : SC_Entry renames SC.Table (J);\n+            begin\n                Set_Table_Entry\n                  (C1   => C1,\n-                  C2   => SC_Array (J).Typ,\n-                  From => SC_Array (J).From,\n-                  To   => SC_Array (J).To,\n+                  C2   => SCE.Typ,\n+                  From => SCE.From,\n+                  To   => SCE.To,\n+                  Node => Empty,\n                   Last => (J = SC_Last));\n-            end loop;\n+            end;\n+         end loop;\n \n-            SC_Last := 0;\n-         end if;\n+         --  Clear out used section of SC table\n+\n+         SC.Set_Last (SC_First - 1);\n+\n+         --  Output any embedded decisions\n+\n+         for J in SD_First .. SD_Last loop\n+            declare\n+               SDE : SD_Entry renames SD.Table (J);\n+            begin\n+               if Present (SDE.Nod) then\n+                  Process_Decisions (SDE.Nod, SDE.Typ);\n+               else\n+                  Process_Decisions (SDE.Lst, SDE.Typ);\n+               end if;\n+            end;\n+         end loop;\n+\n+         --  Clear out used section of SD table\n+\n+         SD.Set_Last (SD_First - 1);\n       end Set_Statement_Entry;\n \n       -------------------------------\n       -- Extend_Statement_Sequence --\n       -------------------------------\n \n       procedure Extend_Statement_Sequence (N : Node_Id; Typ : Character) is\n+         F : Source_Ptr;\n+         T : Source_Ptr;\n       begin\n-         --  Clear out statement sequence if array full\n-\n-         if SC_Last = SC_Array'Last then\n-            Set_Statement_Entry;\n-         else\n-            SC_Last := SC_Last + 1;\n-         end if;\n-\n-         --  Record new entry\n-\n-         Sloc_Range\n-           (N, SC_Array (SC_Last).From, SC_Array (SC_Last).To);\n-         SC_Array (SC_Last).Typ := Typ;\n+         Sloc_Range (N, F, T);\n+         SC.Append ((F, T, Typ));\n       end Extend_Statement_Sequence;\n \n       procedure Extend_Statement_Sequence\n         (From : Node_Id;\n          To   : Node_Id;\n          Typ  : Character)\n       is\n+         F : Source_Ptr;\n+         T : Source_Ptr;\n       begin\n-         --  Clear out statement sequence if array full\n+         Sloc_Range (From, F, Dummy);\n+         Sloc_Range (To, Dummy, T);\n+         SC.Append ((F, T, Typ));\n+      end Extend_Statement_Sequence;\n \n-         if SC_Last = SC_Array'Last then\n-            Set_Statement_Entry;\n-         else\n-            SC_Last := SC_Last + 1;\n-         end if;\n+      -----------------------------\n+      -- Process_Decisions_Defer --\n+      -----------------------------\n \n-         --  Make new entry\n+      procedure Process_Decisions_Defer (N : Node_Id; T : Character) is\n+      begin\n+         SD.Append ((N, No_List, T));\n+      end Process_Decisions_Defer;\n \n-         Sloc_Range (From, SC_Array (SC_Last).From, Dummy);\n-         Sloc_Range (To, Dummy, SC_Array (SC_Last).To);\n-         SC_Array (SC_Last).Typ := Typ;\n-      end Extend_Statement_Sequence;\n+      procedure Process_Decisions_Defer (L : List_Id; T : Character) is\n+      begin\n+         SD.Append ((Empty, L, T));\n+      end Process_Decisions_Defer;\n \n    --  Start of processing for Traverse_Declarations_Or_Statements\n \n    begin\n       if Is_Non_Empty_List (L) then\n-         SC_Last := 0;\n \n          --  Loop through statements or declarations\n \n@@ -915,17 +1106,18 @@ package body Par_SCO is\n                --  Subprogram declaration\n \n                when N_Subprogram_Declaration =>\n-                  Set_Statement_Entry;\n-                  Process_Decisions\n+                  Process_Decisions_Defer\n                     (Parameter_Specifications (Specification (N)), 'X');\n+                  Set_Statement_Entry;\n \n                --  Generic subprogram declaration\n \n                when N_Generic_Subprogram_Declaration =>\n-                  Set_Statement_Entry;\n-                  Process_Decisions (Generic_Formal_Declarations (N), 'X');\n-                  Process_Decisions\n+                  Process_Decisions_Defer\n+                    (Generic_Formal_Declarations (N), 'X');\n+                  Process_Decisions_Defer\n                     (Parameter_Specifications (Specification (N)), 'X');\n+                  Set_Statement_Entry;\n \n                --  Subprogram_Body\n \n@@ -940,8 +1132,8 @@ package body Par_SCO is\n \n                when N_Exit_Statement =>\n                   Extend_Statement_Sequence (N, ' ');\n+                  Process_Decisions_Defer (Condition (N), 'E');\n                   Set_Statement_Entry;\n-                  Process_Decisions (Condition (N), 'E');\n \n                --  Label, which breaks the current statement sequence, but the\n                --  label itself is not included in the next statement sequence,\n@@ -963,38 +1155,56 @@ package body Par_SCO is\n \n                when N_If_Statement =>\n                   Extend_Statement_Sequence (N, Condition (N), 'I');\n+                  Process_Decisions_Defer (Condition (N), 'I');\n                   Set_Statement_Entry;\n-                  Process_Decisions (Condition (N), 'I');\n+\n+                  --  Now we traverse the statements in the THEN part\n+\n                   Traverse_Declarations_Or_Statements (Then_Statements (N));\n \n+                  --  Loop through ELSIF parts if present\n+\n                   if Present (Elsif_Parts (N)) then\n                      declare\n                         Elif : Node_Id := First (Elsif_Parts (N));\n+\n                      begin\n                         while Present (Elif) loop\n-                           Process_Decisions (Condition (Elif), 'I');\n+\n+                           --  We generate a statement sequence for the\n+                           --  construct \"ELSIF condition\", so that we have\n+                           --  a statement for the resulting decisions.\n+\n+                           Extend_Statement_Sequence\n+                             (Elif, Condition (Elif), 'I');\n+                           Process_Decisions_Defer (Condition (Elif), 'I');\n+                           Set_Statement_Entry;\n+\n+                           --  Traverse the statements in the ELSIF\n+\n                            Traverse_Declarations_Or_Statements\n                              (Then_Statements (Elif));\n                            Next (Elif);\n                         end loop;\n                      end;\n                   end if;\n \n+                  --  Finally traverse the ELSE statements if present\n+\n                   Traverse_Declarations_Or_Statements (Else_Statements (N));\n \n                --  Case statement, which breaks the current statement sequence,\n                --  but we include the expression in the current sequence.\n \n                when N_Case_Statement =>\n                   Extend_Statement_Sequence (N, Expression (N), 'C');\n+                  Process_Decisions_Defer (Expression (N), 'X');\n                   Set_Statement_Entry;\n-                  Process_Decisions (Expression (N), 'X');\n \n                   --  Process case branches\n \n                   declare\n                      Alt : Node_Id;\n-\n                   begin\n                      Alt := First (Alternatives (N));\n                      while Present (Alt) loop\n@@ -1017,22 +1227,17 @@ package body Par_SCO is\n \n                when N_Simple_Return_Statement =>\n                   Extend_Statement_Sequence (N, ' ');\n+                  Process_Decisions_Defer (Expression (N), 'X');\n                   Set_Statement_Entry;\n-                  Process_Decisions (Expression (N), 'X');\n \n                --  Extended return statement\n \n                when N_Extended_Return_Statement =>\n-                  declare\n-                     Odecl : constant Node_Id :=\n-                               First (Return_Object_Declarations (N));\n-                  begin\n-                     if Present (Expression (Odecl)) then\n-                        Extend_Statement_Sequence\n-                          (N, Expression (Odecl), 'R');\n-                        Process_Decisions (Expression (Odecl), 'X');\n-                     end if;\n-                  end;\n+                  Extend_Statement_Sequence\n+                    (N, Last (Return_Object_Declarations (N)), 'R');\n+                  Process_Decisions_Defer\n+                    (Return_Object_Declarations (N), 'X');\n+                  Set_Statement_Entry;\n \n                   Traverse_Handled_Statement_Sequence\n                     (Handled_Statement_Sequence (N));\n@@ -1057,13 +1262,13 @@ package body Par_SCO is\n \n                         if Present (Condition (ISC)) then\n                            Extend_Statement_Sequence (N, ISC, 'W');\n-                           Process_Decisions (Condition (ISC), 'W');\n+                           Process_Decisions_Defer (Condition (ISC), 'W');\n \n                         --  For statement\n \n                         else\n                            Extend_Statement_Sequence (N, ISC, 'F');\n-                           Process_Decisions\n+                           Process_Decisions_Defer\n                              (Loop_Parameter_Specification (ISC), 'X');\n                         end if;\n                      end;\n@@ -1077,42 +1282,55 @@ package body Par_SCO is\n                when N_Pragma =>\n                   Extend_Statement_Sequence (N, 'P');\n \n-                  --  For pragmas Assert, Check, Precondition, and\n-                  --  Postcondition, we generate decision entries for the\n-                  --  condition only if the pragma is enabled. For now, we just\n-                  --  check Assertions_Enabled, which will be set to reflect\n-                  --  the presence of -gnata.\n+                  --  Processing depends on the kind of pragma\n \n-                  --  Later we should move processing of the relevant pragmas\n-                  --  to Par_Prag, and properly set the flag Pragma_Enabled at\n-                  --  parse time, so that we can check this flag instead ???\n+                  case Pragma_Name (N) is\n+                     when Name_Assert        |\n+                          Name_Check         |\n+                          Name_Precondition  |\n+                          Name_Postcondition =>\n \n-                  --  For all other pragmas, we always generate decision\n-                  --  entries for any embedded expressions.\n+                        --  For Assert/Check/Precondition/Postcondition, we\n+                        --  must generate a P entry for the decision. Note that\n+                        --  this is done unconditionally at this stage. Output\n+                        --  for disabled pragmas is suppressed later on, when\n+                        --  we output the decision line in Put_SCOs.\n \n-                  declare\n-                     Nam : constant Name_Id :=\n-                             Chars (Pragma_Identifier (N));\n-                     Arg : Node_Id := First (Pragma_Argument_Associations (N));\n-                  begin\n-                     case Nam is\n-                        when Name_Assert        |\n-                             Name_Check         |\n-                             Name_Precondition  |\n-                             Name_Postcondition =>\n+                        declare\n+                           Nam : constant Name_Id :=\n+                                   Chars (Pragma_Identifier (N));\n+                           Arg : Node_Id :=\n+                                   First (Pragma_Argument_Associations (N));\n \n+                        begin\n                            if Nam = Name_Check then\n                               Next (Arg);\n                            end if;\n \n-                           if Assertions_Enabled then\n-                              Process_Decisions (Expression (Arg), 'P');\n-                           end if;\n+                           Process_Decisions_Defer (Expression (Arg), 'P');\n+                        end;\n \n-                        when others =>\n-                           Process_Decisions (N, 'X');\n-                     end case;\n-                  end;\n+                     --  For all other pragmas, we generate decision entries\n+                     --  for any embedded expressions.\n+\n+                     when others =>\n+                        Process_Decisions_Defer (N, 'X');\n+                  end case;\n+\n+               --  Object declaration. Ignored if Prev_Ids is set, since the\n+               --  parser generates multiple instances of the whole declaration\n+               --  if there is more than one identifier declared, and we only\n+               --  want one entry in the SCO's, so we take the first, for which\n+               --  Prev_Ids is False.\n+\n+               when N_Object_Declaration =>\n+                  if not Prev_Ids (N) then\n+                     Extend_Statement_Sequence (N, 'o');\n+\n+                     if Has_Decision (N) then\n+                        Process_Decisions_Defer (N, 'X');\n+                     end if;\n+                  end if;\n \n                --  All other cases, which extend the current statement sequence\n                --  but do not terminate it, even if they have nested decisions.\n@@ -1135,9 +1353,6 @@ package body Par_SCO is\n                         when N_Subtype_Declaration           =>\n                            Typ := 's';\n \n-                        when N_Object_Declaration            =>\n-                           Typ := 'o';\n-\n                         when N_Renaming_Declaration          =>\n                            Typ := 'r';\n \n@@ -1154,7 +1369,7 @@ package body Par_SCO is\n                   --  Process any embedded decisions\n \n                   if Has_Decision (N) then\n-                     Process_Decisions (N, 'X');\n+                     Process_Decisions_Defer (N, 'X');\n                   end if;\n             end case;\n \n@@ -1165,6 +1380,31 @@ package body Par_SCO is\n       end if;\n    end Traverse_Declarations_Or_Statements;\n \n+   ------------------------------------\n+   -- Traverse_Generic_Instantiation --\n+   ------------------------------------\n+\n+   procedure Traverse_Generic_Instantiation (N : Node_Id) is\n+      First : Source_Ptr;\n+      Last  : Source_Ptr;\n+\n+   begin\n+      --  First we need a statement entry to cover the instantiation\n+\n+      Sloc_Range (N, First, Last);\n+      Set_Table_Entry\n+        (C1   => 'S',\n+         C2   => ' ',\n+         From => First,\n+         To   => Last,\n+         Node => Empty,\n+         Last => True);\n+\n+      --  Now output any embedded decisions\n+\n+      Process_Decisions (N, 'X');\n+   end Traverse_Generic_Instantiation;\n+\n    ------------------------------------------\n    -- Traverse_Generic_Package_Declaration --\n    ------------------------------------------\n@@ -1232,4 +1472,16 @@ package body Par_SCO is\n       Traverse_Handled_Statement_Sequence (Handled_Statement_Sequence (N));\n    end Traverse_Subprogram_Body;\n \n+   -------------------------------------\n+   -- Traverse_Subprogram_Declaration --\n+   -------------------------------------\n+\n+   procedure Traverse_Subprogram_Declaration (N : Node_Id) is\n+      ADN : constant Node_Id := Aux_Decls_Node (Parent (N));\n+   begin\n+      Traverse_Declarations_Or_Statements (Config_Pragmas (ADN));\n+      Traverse_Declarations_Or_Statements (Declarations   (ADN));\n+      Traverse_Declarations_Or_Statements (Pragmas_After  (ADN));\n+   end Traverse_Subprogram_Declaration;\n+\n end Par_SCO;"}, {"sha": "9bbe04ffee0dae7bf5b00b5ee90b899bc706912b", "filename": "gcc/ada/par_sco.ads", "status": "modified", "additions": 7, "deletions": 151, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25adc5fbf5c9ac211442106de78cba432212449c/gcc%2Fada%2Fpar_sco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25adc5fbf5c9ac211442106de78cba432212449c/gcc%2Fada%2Fpar_sco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.ads?ref=25adc5fbf5c9ac211442106de78cba432212449c", "patch": "@@ -25,156 +25,12 @@\n \n --  This package contains the routines used to deal with generation and output\n --  of Soure Coverage Obligations (SCO's) used for coverage analysis purposes.\n+--  See package SCOs for full documentation of format of SCO information.\n \n with Types; use Types;\n \n package Par_SCO is\n \n-   ----------------\n-   -- SCO Format --\n-   ----------------\n-\n-   --  Source coverage obligations are generated on a unit-by-unit basis in the\n-   --  ALI file, using lines that start with the identifying character C. These\n-   --  lines are generated if the -gnatC switch is set.\n-\n-   --  Sloc Ranges\n-\n-   --    In several places in the SCO lines, Sloc ranges appear. These are used\n-   --    to indicate the first and last Sloc of some construct in the tree and\n-   --    they have the form:\n-\n-   --      line:col-line:col\n-\n-   --    Note that SCO's are generated only for generic templates, not for\n-   --    generic instances (since only the first are part of the source). So\n-   --    we don't need generic instantiation stuff in these line:col items.\n-\n-   --  SCO File headers\n-\n-   --    The SCO information follows the cross-reference information, so it\n-   --    need not be read by tools like gnatbind, gnatmake etc. The SCO output\n-   --    is divided into sections, one section for each unit for which SCO's\n-   --    are generated. A SCO section has a header of the form:\n-\n-   --      C  dependency-number  filename\n-\n-   --        This header precedes SCO information for the unit identified by\n-   --        dependency number and file name. The dependency number is the\n-   --        index into the generated D lines and is ones origin (i.e. 2 =\n-   --        reference to second generated D line).\n-\n-   --        Note that the filename here will reflect the original name if\n-   --        a Source_Reference pragma was encountered (since all line number\n-   --        references will be with respect to the original file).\n-\n-   --  Statements\n-\n-   --    For the purpose of SCO generation, the notion of statement includes\n-   --    simple statements and also the following declaration types:\n-\n-   --      type_declaration\n-   --      subtype_declaration\n-   --      object_declaration\n-   --      renaming_declaration\n-   --      generic_instantiation\n-\n-   --  Statement lines\n-\n-   --    These lines correspond to a sequence of one or more statements which\n-   --    are always exeecuted in sequence, The first statement may be an entry\n-   --    point (e.g. statement after a label), and the last statement may be\n-   --    an exit point (e.g. an exit statement), but no other entry or exit\n-   --    points may occur within the sequence of statements. The idea is that\n-   --    the sequence can be treated as a single unit from a coverage point of\n-   --    view, if any of the code for the statement sequence is executed, this\n-   --    corresponds to coverage of the entire statement sequence. The form of\n-   --    a statement line in the ALI file is:\n-\n-   --      CS sloc-range\n-\n-   --  Exit points\n-\n-   --    An exit point is a statement that causes transfer of control. Examples\n-   --    are exit statements, raise statements and return statements. The form\n-   --    of an exit point in the ALI file is:\n-\n-   --      CT sloc-range\n-\n-   --  Decisions\n-\n-   --    Decisions represent the most significant section of the SCO lines\n-\n-   --    Note: in the following description, logical operator includes the\n-   --    short circuited forms (so can be any of AND, OR, XOR, NOT, AND THEN,\n-   --    or OR ELSE).\n-\n-   --    Decisions are either simple or complex. A simple decision is a boolean\n-   --    expresssion that occurs in the context of a control structure in the\n-   --    source program, including WHILE, IF, EXIT WHEN. Note that a boolean\n-   --    expression in any other context, e.g. on the right side of an\n-   --    assignment, is not considered to be a decision.\n-\n-   --    A complex decision is an occurrence of a logical operator which is not\n-   --    itself an operand of some other logical operator. If any operand of\n-   --    the logical operator is itself a logical operator, this is not a\n-   --    separate decision, it is part of the same decision.\n-\n-   --    So for example, if we have\n-\n-   --        A, B, C, D : Boolean;\n-   --        function F (Arg : Boolean) return Boolean);\n-   --        ...\n-   --        A and then (B or else F (C and then D))\n-\n-   --    There are two (complex) decisions here:\n-\n-   --        1. X and then (Y or else Z)\n-\n-   --           where X = A, Y = B, and Z = F (C and then D)\n-\n-   --        2. C and then D\n-\n-   --    For each decision, a decision line is generated with the form:\n-\n-   --      C* expression\n-\n-   --    Here * is one of the following characters:\n-\n-   --      I  decision in IF statement or conditional expression\n-   --      E  decision in EXIT WHEN statement\n-   --      W  decision in WHILE iteration scheme\n-   --      X  decision appearing in some other expression context\n-\n-   --    The expression is a prefix polish form indicating the structure of\n-   --    the decision, including logical operators and short circuit forms.\n-   --    The following is a grammar showing the structure of expression:\n-\n-   --      expression ::= term             (if expr is not logical operator)\n-   --      expression ::= & term term      (if expr is AND THEN)\n-   --      expression ::= | term term      (if expr is OR ELSE)\n-   --      expression ::= !term            (if expr is NOT)\n-\n-   --      term ::= element\n-   --      term ::= expression\n-\n-   --      element ::= outcome sloc-range\n-\n-   --    outcome is one of the following letters:\n-\n-   --      c  condition\n-   --      t  true condition\n-   --      f  false condition\n-\n-   --      where t/f are used to mark a condition that has been recognized by\n-   --      the compiler as always being true or false.\n-\n-   --    & indicates either AND THEN connecting two conditions\n-\n-   --    | indicates either OR ELSE connection two conditions\n-\n-   --    ! indicates NOT applied to the expression\n-\n    -----------------\n    -- Subprograms --\n    -----------------\n@@ -187,20 +43,20 @@ package Par_SCO is\n    --  internal tables recording the SCO information. Note that this is done\n    --  before any semantic analysis/expansion happens.\n \n-   procedure Set_SCO_Condition (First_Loc : Source_Ptr; Typ : Character);\n+   procedure Set_SCO_Condition (Cond : Node_Id; Val : Boolean);\n    --  This procedure is called during semantic analysis to record a condition\n-   --  which has been identified as always True (Typ = 't') or always False\n-   --  (Typ = 'f') by the compiler. The condition is identified by the\n-   --  First_Sloc value in the original tree.\n+   --  which has been identified as always True or always False, as indicated\n+   --  by Val. The condition is identified by the First_Sloc value in the\n+   --  original tree associated with Cond.\n \n    procedure SCO_Output;\n    --  Outputs SCO lines for all units, with appropriate section headers, for\n    --  unit U in the ALI file, as recorded by previous calls to SCO_Record,\n    --  possibly modified by calls to Set_SCO_Condition.\n \n    procedure dsco;\n-   --  Debug routine to dump SCO table. This is a raw format dump showing\n-   --  exactly what the tables contain.\n+   --  Debug routine to dump internal SCO table. This is a raw format dump\n+   --  showing exactly what the table contains.\n \n    procedure pscos;\n    --  Debugging procedure to output contents of SCO binary tables in the"}, {"sha": "53962b2545a812264a01f55d78d4210ace251c5e", "filename": "gcc/ada/put_scos.adb", "status": "modified", "additions": 99, "deletions": 46, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25adc5fbf5c9ac211442106de78cba432212449c/gcc%2Fada%2Fput_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25adc5fbf5c9ac211442106de78cba432212449c/gcc%2Fada%2Fput_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_scos.adb?ref=25adc5fbf5c9ac211442106de78cba432212449c", "patch": "@@ -23,9 +23,43 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with SCOs; use SCOs;\n+with Atree; use Atree;\n+with SCOs;  use SCOs;\n+with Sinfo; use Sinfo;\n \n procedure Put_SCOs is\n+   Ctr : Nat;\n+\n+   procedure Output_Range (T : SCO_Table_Entry);\n+   --  Outputs T.From and T.To in line:col-line:col format\n+\n+   procedure Output_Source_Location (Loc : Source_Location);\n+   --  Output source location in line:col format\n+\n+   ------------------\n+   -- Output_Range --\n+   ------------------\n+\n+   procedure Output_Range (T : SCO_Table_Entry) is\n+   begin\n+      Output_Source_Location (T.From);\n+      Write_Info_Char ('-');\n+      Output_Source_Location (T.To);\n+   end Output_Range;\n+\n+   ----------------------------\n+   -- Output_Source_Location --\n+   ----------------------------\n+\n+   procedure Output_Source_Location (Loc : Source_Location) is\n+   begin\n+      Write_Info_Nat  (Nat (Loc.Line));\n+      Write_Info_Char (':');\n+      Write_Info_Nat  (Nat (Loc.Col));\n+   end Output_Source_Location;\n+\n+--  Start of processing for Put_SCOs\n+\n begin\n    --  Loop through entries in SCO_Unit_Table\n \n@@ -64,35 +98,16 @@ begin\n             Output_SCO_Line : declare\n                T : SCO_Table_Entry renames SCO_Table.Table (Start);\n \n-               procedure Output_Range (T : SCO_Table_Entry);\n-               --  Outputs T.From and T.To in line:col-line:col format\n-\n-               ------------------\n-               -- Output_Range --\n-               ------------------\n-\n-               procedure Output_Range (T : SCO_Table_Entry) is\n-               begin\n-                  Write_Info_Nat  (Nat (T.From.Line));\n-                  Write_Info_Char (':');\n-                  Write_Info_Nat  (Nat (T.From.Col));\n-                  Write_Info_Char ('-');\n-                  Write_Info_Nat  (Nat (T.To.Line));\n-                  Write_Info_Char (':');\n-                  Write_Info_Nat  (Nat (T.To.Col));\n-               end Output_Range;\n-\n-            --  Start of processing for Output_SCO_Line\n-\n             begin\n-               Write_Info_Initiate ('C');\n-               Write_Info_Char (T.C1);\n-\n                case T.C1 is\n \n                   --  Statements\n \n                   when 'S' =>\n+                     Write_Info_Initiate ('C');\n+                     Write_Info_Char ('S');\n+\n+                     Ctr := 0;\n                      loop\n                         Write_Info_Char (' ');\n \n@@ -105,6 +120,18 @@ begin\n \n                         Start := Start + 1;\n                         pragma Assert (SCO_Table.Table (Start).C1 = 's');\n+\n+                        Ctr := Ctr + 1;\n+\n+                        --  Up to 6 items on a line, if more than 6 items,\n+                        --  continuation lines are marked Cs.\n+\n+                        if Ctr = 6 then\n+                           Write_Info_Terminate;\n+                           Write_Info_Initiate ('C');\n+                           Write_Info_Char ('s');\n+                           Ctr := 0;\n+                        end if;\n                      end loop;\n \n                   --  Statement continuations should not occur since they\n@@ -116,35 +143,61 @@ begin\n                   --  Decision\n \n                   when 'I' | 'E' | 'P' | 'W' | 'X' =>\n-                     if T.C2 = ' ' then\n-                        Start := Start + 1;\n-                     end if;\n+                     Start := Start + 1;\n+\n+                     --  For disabled pragma, skip decision output. Note that\n+                     --  if the SCO table has been populated by Get_SCOs\n+                     --  (re-reading previously generated SCO information),\n+                     --  then the Node field of pragma entries is Empty. This\n+                     --  is the only way that Node can be Empty, so if we see\n+                     --  an Empty node field, we know the pragma is enabled.\n+\n+                     if T.C1 = 'P'\n+                       and then Present (T.Node)\n+                       and then not Pragma_Enabled (Original_Node (T.Node))\n+                     then\n+                        while not SCO_Table.Table (Start).Last loop\n+                           Start := Start + 1;\n+                        end loop;\n \n-                     --  Loop through table entries for this decision\n+                     --  For all other cases output decision line\n \n-                     loop\n-                        declare\n-                           T : SCO_Table_Entry renames SCO_Table.Table (Start);\n+                     else\n+                        Write_Info_Initiate ('C');\n+                        Write_Info_Char (T.C1);\n \n-                        begin\n+                        if T.C1 /= 'X' then\n                            Write_Info_Char (' ');\n+                           Output_Source_Location (T.From);\n+                        end if;\n \n-                           if T.C1 = '!' or else\n-                              T.C1 = '^' or else\n-                              T.C1 = '&' or else\n-                              T.C1 = '|'\n-                           then\n-                              Write_Info_Char (T.C1);\n+                        --  Loop through table entries for this decision\n \n-                           else\n-                              Write_Info_Char (T.C2);\n-                              Output_Range (T);\n-                           end if;\n+                        loop\n+                           declare\n+                              T : SCO_Table_Entry\n+                                    renames SCO_Table.Table (Start);\n \n-                           exit when T.Last;\n-                           Start := Start + 1;\n-                        end;\n-                     end loop;\n+                           begin\n+                              Write_Info_Char (' ');\n+\n+                              if T.C1 = '!' or else\n+                                 T.C1 = '&' or else\n+                                 T.C1 = '|'\n+                              then\n+                                 Write_Info_Char (T.C1);\n+                                 Output_Source_Location (T.From);\n+\n+                              else\n+                                 Write_Info_Char (T.C2);\n+                                 Output_Range (T);\n+                              end if;\n+\n+                              exit when T.Last;\n+                              Start := Start + 1;\n+                           end;\n+                        end loop;\n+                     end if;\n \n                   when others =>\n                      raise Program_Error;"}, {"sha": "3c0caeec2d03ee753e9eb416b43adc5c70c6f1f0", "filename": "gcc/ada/scos.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25adc5fbf5c9ac211442106de78cba432212449c/gcc%2Fada%2Fscos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25adc5fbf5c9ac211442106de78cba432212449c/gcc%2Fada%2Fscos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.adb?ref=25adc5fbf5c9ac211442106de78cba432212449c", "patch": "@@ -34,10 +34,11 @@ package body SCOs is\n       To   : Source_Location := No_Source_Location;\n       C1   : Character       := ' ';\n       C2   : Character       := ' ';\n+      Node : Node_Id         := Empty;\n       Last : Boolean         := False)\n    is\n    begin\n-      SCO_Table.Append ((From, To, C1, C2, Last));\n+      SCO_Table.Append ((From, To, Node, C1, C2, Last));\n    end Add_SCO;\n \n    ----------------"}, {"sha": "9e6a973a0cd7378c26539ae939295e2e1f0e9d4f", "filename": "gcc/ada/scos.ads", "status": "modified", "additions": 81, "deletions": 30, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25adc5fbf5c9ac211442106de78cba432212449c/gcc%2Fada%2Fscos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25adc5fbf5c9ac211442106de78cba432212449c/gcc%2Fada%2Fscos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.ads?ref=25adc5fbf5c9ac211442106de78cba432212449c", "patch": "@@ -148,21 +148,27 @@ package SCOs is\n    --      o  object declaration\n    --      r  renaming declaration\n    --      i  generic instantiation\n-   --      C  CASE statement (includes only the expression)\n+   --      C  CASE statement (from CASE through end of expression)\n    --      E  EXIT statement\n-   --      F  FOR loop statement (includes only the iteration scheme)\n-   --      I  IF statement (includes only the condition [in the RM sense, which\n-   --         is a decision in the SCO sense])\n+   --      F  FOR loop statement (from FOR through end of iteration scheme)\n+   --      I  IF statement (from IF through end of condition)\n    --      P  PRAGMA\n    --      R  extended RETURN statement\n-   --      W  WHILE loop statement (includes only the condition)\n+   --      W  WHILE loop statement (from WHILE through end of condition)\n+\n+   --      Note: for I and W, condition above is in the RM syntax sense (this\n+   --      condition is a decision in SCO terminology).\n \n    --    and is omitted for all other cases.\n \n+   --  Note: up to 6 entries can appear on a single CS line. If more than 6\n+   --  entries appear in one logical statement sequence, continuation lines are\n+   --  marked by Cs and appear immediately after the CS line they continue.\n+\n    --  Decisions\n \n    --    Note: in the following description, logical operator includes only the\n-   --    short circuited forms and NOT (so can be only NOT, AND THEN, OR ELSE).\n+   --    short-circuited forms and NOT (so can be only NOT, AND THEN, OR ELSE).\n    --    The reason that we can exclude AND/OR/XOR is that we expect SCO's to\n    --    be generated using the restriction No_Direct_Boolean_Operators if we\n    --    are interested in decision coverage, which does not permit the use of\n@@ -171,18 +177,27 @@ package SCOs is\n    --    we are generating SCO's only for simple coverage, then we are not\n    --    interested in decisions in any case.\n \n-   --    Decisions are either simple or complex. A simple decision is a boolean\n-   --    expresssion that occurs in the context of a control structure in the\n-   --    source program, including WHILE, IF, EXIT WHEN, or in an Assert,\n-   --    Check, Pre_Condition or Post_Condition pragma. For pragmas, decision\n-   --    SCOs are generated only if the corresponding pragma is enabled. Note\n-   --    that a boolean expression in any other context, for example as right\n-   --    hand side of an assignment, is not considered to be a simple decision.\n+   --    Note: the reason we include NOT is for informational purposes. The\n+   --    presence of NOT does not generate additional coverage obligations,\n+   --    but if we know where the NOT's are, the coverage tool can generate\n+   --    more accurate diagnostics on uncovered tests.\n+\n+   --    A top level boolean expression is a boolean expression that is not an\n+   --    operand of a logical operator.\n+\n+   --    Decisions are either simple or complex. A simple decision is a top\n+   --    level boolean expresssion that has only one condition and that occurs\n+   --    in the context of a control structure in the source program, including\n+   --    WHILE, IF, EXIT WHEN, or in an Assert, Check, Pre_Condition or\n+   --    Post_Condition pragma. For pragmas, decision SCOs are generated only\n+   --    if the corresponding pragma is enabled. Note that a top level boolean\n+   --    expression with only one condition that occurs in any other context,\n+   --    for example as right hand side of an assignment, is not considered to\n+   --    be a (simple) decision.\n \n-   --    A complex decision is an occurrence of a logical operator which is not\n-   --    itself an operand of some other logical operator. If any operand of\n-   --    the logical operator is itself a logical operator, this is not a\n-   --    separate decision, it is part of the same decision.\n+   --    A complex decision is a top level boolean expression that has more\n+   --    than one condition. A complex decision may occur in any boolean\n+   --    expression context.\n \n    --    So for example, if we have\n \n@@ -201,7 +216,7 @@ package SCOs is\n \n    --    For each decision, a decision line is generated with the form:\n \n-   --      C*sloc expression\n+   --      C* sloc expression\n \n    --    Here * is one of the following characters:\n \n@@ -217,7 +232,7 @@ package SCOs is\n    --    For X, sloc is omitted.\n \n    --    The expression is a prefix polish form indicating the structure of\n-   --    the decision, including logical operators and short circuit forms.\n+   --    the decision, including logical operators and short-circuit forms.\n    --    The following is a grammar showing the structure of expression:\n \n    --      expression ::= term             (if expr is not logical operator)\n@@ -248,8 +263,14 @@ package SCOs is\n \n    --    ! indicates NOT applied to the expression.\n \n-   --    In the context of Couverture, the No_Direct_Boolean_Opeartors\n-   --    restriction is assumed, and no other operator can appear.\n+   --    Note that complex decisions do NOT include non-short-circuited logical\n+   --    operators (AND/XOR/OR). In the context of existing coverage tools the\n+   --    No_Direct_Boolean_Operators restriction is assumed, so these operators\n+   --    cannot appear in the source in any case.\n+\n+   --    The SCO line for a decision always occurs after the CS line for the\n+   --    enclosing statement. The SCO line for a nested decision always occurs\n+   --    after the line for the enclosing decision.\n \n    ---------------------------------------------------------------------\n    -- Internal table used to store Source Coverage Obligations (SCOs) --\n@@ -265,6 +286,7 @@ package SCOs is\n    type SCO_Table_Entry is record\n       From : Source_Location;\n       To   : Source_Location;\n+      Node : Node_Id;\n       C1   : Character;\n       C2   : Character;\n       Last : Boolean;\n@@ -284,40 +306,68 @@ package SCOs is\n    --      C2   = statement type code to appear on CS line (or ' ' if none)\n    --      From = starting source location\n    --      To   = ending source location\n+   --      Node = Empty\n    --      Last = False for all but the last entry, True for last entry\n \n    --    Note: successive statements (possibly interspersed with entries of\n    --    other kinds, that are ignored for this purpose), starting with one\n    --    labeled with C1 = 'S', up to and including the first one labeled with\n-   --    Last=True, indicate the sequence to be output for a sequence of\n-   --    statements on a single CS line.\n+   --    Last = True, indicate the sequence to be output for a sequence of\n+   --    statements on a single CS line (possibly followed by Cs continuation\n+   --    lines).\n+\n+   --    Decision (IF/EXIT/WHILE)\n+   --      C1   = 'I'/'E'/'W' (for IF/EXIT/WHILE)\n+   --      C2   = ' '\n+   --      From = IF/EXIT/WHILE token\n+   --      To   = No_Source_Location\n+   --      Node = Empty\n+   --      Last = unused\n+\n+   --    Decision (PRAGMA)\n+   --      C1   = 'P'\n+   --      C2   = ' '\n+   --      From = PRAGMA token\n+   --      To   = No_Source_Location\n+   --      Node = N_Pragma node or Empty when reading SCO data (see below)\n+   --      Last = unused\n \n-   --    Decision\n-   --      C1   = decision type code\n+   --      Note: when the parse tree is first scanned, we unconditionally build\n+   --      a pragma decision entry for any decision in a pragma (here as always\n+   --      in SCO contexts, the only relevant pragmas are Assert, Check,\n+   --      Precondition and Postcondition). Then when we output the SCO info\n+   --      to the ALI file, we use the Node field to check the Pragma_Enabled\n+   --      flag, and if it is False, we suppress output of the pragma decision\n+   --      line. On reading back SCO data from an ALI file, the Node field is\n+   --      always set to Empty.\n+\n+   --    Decision (Expression)\n+   --      C1   = 'X'\n    --      C2   = ' '\n-   --      From = location of IF/EXIT/PRAGMA/WHILE token,\n-   --             No_Source_Location for X\n+   --      From = No_Source_Location\n    --      To   = No_Source_Location\n+   --      Node = Empty\n    --      Last = unused\n \n    --    Operator\n-   --      C1   = '!', '^', '&', '|'\n+   --      C1   = '!', '&', '|'\n    --      C2   = ' '\n    --      From = location of NOT/AND/OR token\n    --      To   = No_Source_Location\n+   --      Node = Empty\n    --      Last = False\n \n    --    Element (condition)\n    --      C1   = ' '\n    --      C2   = 'c', 't', or 'f' (condition/true/false)\n    --      From = starting source location\n    --      To   = ending source location\n+   --      Node = Empty\n    --      Last = False for all but the last entry, True for last entry\n \n    --    Note: the sequence starting with a decision, and continuing with\n    --    operators and elements up to and including the first one labeled with\n-   --    Last = True, indicate the sequence to be output for a complex decision\n-   --    on a single CD decision line.\n+   --    Last = True, indicate the sequence to be output on one decision line.\n \n    ----------------\n    -- Unit Table --\n@@ -365,6 +415,7 @@ package SCOs is\n       To   : Source_Location := No_Source_Location;\n       C1   : Character       := ' ';\n       C2   : Character       := ' ';\n+      Node : Node_Id         := Empty;\n       Last : Boolean         := False);\n    --  Adds one entry to SCO table with given field values\n "}, {"sha": "7a5414fe879e80732ffee6cb282d5cde557f4c37", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25adc5fbf5c9ac211442106de78cba432212449c/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25adc5fbf5c9ac211442106de78cba432212449c/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=25adc5fbf5c9ac211442106de78cba432212449c", "patch": "@@ -3507,26 +3507,16 @@ package body Sem_Warn is\n         and then Is_Known_Branch\n       then\n          declare\n-            Start : Source_Ptr;\n-            Dummy : Source_Ptr;\n-            Typ   : Character;\n             Atrue : Boolean;\n \n          begin\n-            Sloc_Range (Orig, Start, Dummy);\n             Atrue := Test_Result;\n \n             if Present (Parent (C)) and then Nkind (Parent (C)) = N_Op_Not then\n                Atrue := not Atrue;\n             end if;\n \n-            if Atrue then\n-               Typ := 't';\n-            else\n-               Typ := 'f';\n-            end if;\n-\n-            Set_SCO_Condition (Start, Typ);\n+            Set_SCO_Condition (Orig, Atrue);\n          end;\n       end if;\n "}]}