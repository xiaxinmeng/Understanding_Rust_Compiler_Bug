{"sha": "0c30bf43eb2325caa4cb32a697ac1127c15205d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMzMGJmNDNlYjIzMjVjYWE0Y2IzMmE2OTdhYzExMjdjMTUyMDVkNw==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-10-24T14:51:46Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-11-07T11:45:46Z"}, "message": "Objective-C : Implement NSObject attribute.\n\nThis attribute allows pointers to be marked as pointers to\nan NSObject-compatible object.  This allows for additional\nchecking of assignment etc. when refering to pointers to\nopaque types.\n\ngcc/c-family/ChangeLog:\n\n\t* c-attribs.c (handle_nsobject_attribute): New.\n\t* c.opt: Add WNSObject-attribute.\n\ngcc/objc/ChangeLog:\n\n\t* objc-act.c (objc_compare_types): Handle NSObject type\n\tattributes.\n\t(objc_type_valid_for_messaging): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* obj-c++.dg/attributes/nsobject-01.mm: New test.\n\t* objc.dg/attributes/nsobject-01.m: New test.", "tree": {"sha": "b48fce515527857a67855662c4fde50b90cb6328", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b48fce515527857a67855662c4fde50b90cb6328"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c30bf43eb2325caa4cb32a697ac1127c15205d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c30bf43eb2325caa4cb32a697ac1127c15205d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c30bf43eb2325caa4cb32a697ac1127c15205d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c30bf43eb2325caa4cb32a697ac1127c15205d7/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df784801daf0185a1e22ebf03d48363530717882", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df784801daf0185a1e22ebf03d48363530717882", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df784801daf0185a1e22ebf03d48363530717882"}], "stats": {"total": 214, "additions": 207, "deletions": 7}, "files": [{"sha": "f1680820ecd6a2761939a196955ffaad003018c3", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c30bf43eb2325caa4cb32a697ac1127c15205d7/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c30bf43eb2325caa4cb32a697ac1127c15205d7/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=0c30bf43eb2325caa4cb32a697ac1127c15205d7", "patch": "@@ -157,6 +157,7 @@ static tree handle_designated_init_attribute (tree *, tree, tree, int, bool *);\n static tree handle_patchable_function_entry_attribute (tree *, tree, tree,\n \t\t\t\t\t\t       int, bool *);\n static tree handle_copy_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_nsobject_attribute (tree *, tree, tree, int, bool *);\n \n /* Helper to define attribute exclusions.  */\n #define ATTR_EXCL(name, function, type, variable)\t\\\n@@ -509,6 +510,9 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_noinit_attribute, attr_noinit_exclusions },\n   { \"access\",\t\t      1, 3, false, true, true, false,\n \t\t\t      handle_access_attribute, NULL },\n+  /* Attributes used by Objective-C.  */\n+  { \"NSObject\",\t\t      0, 0, true, false, false, false,\n+\t\t\t      handle_nsobject_attribute, NULL },\n   { NULL,                     0, 0, false, false, false, false, NULL, NULL }\n };\n \n@@ -5124,6 +5128,41 @@ handle_patchable_function_entry_attribute (tree *, tree name, tree args,\n   return NULL_TREE;\n }\n \n+/* Handle a \"NSObject\" attributes; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_nsobject_attribute (tree *node, tree name, tree args,\n+\t\t\t   int /*flags*/, bool *no_add_attrs)\n+{\n+  *no_add_attrs = true;\n+\n+  /* This attribute only applies to typedefs (or field decls for properties),\n+     we drop it otherwise - but warn about this if enabled.  */\n+  if (TREE_CODE (*node) != TYPE_DECL && TREE_CODE (*node) != FIELD_DECL)\n+    {\n+      warning (OPT_WNSObject_attribute, \"%qE attribute may be put on a\"\n+\t       \" typedef only; attribute is ignored\", name);\n+      return NULL_TREE;\n+    }\n+\n+  /* The original implementation only allowed pointers to records, however\n+     recent implementations also allow void *.  */\n+  tree type = TREE_TYPE (*node);\n+  if (!type || !POINTER_TYPE_P (type)\n+      || (TREE_CODE (TREE_TYPE (type)) != RECORD_TYPE\n+          && !VOID_TYPE_P (TREE_TYPE (type))))\n+    {\n+      error (\"%qE attribute is for pointer types only\", name);\n+      return NULL_TREE;\n+    }\n+\n+  tree t = tree_cons (name, args, TYPE_ATTRIBUTES (type));\n+  TREE_TYPE (*node) = build_type_attribute_variant (type, t);\n+\n+  return NULL_TREE;\n+}\n+\n /* Attempt to partially validate a single attribute ATTR as if\n    it were to be applied to an entity OPER.  */\n "}, {"sha": "fe16357db85c88ea42cf00715b72c606b6079064", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c30bf43eb2325caa4cb32a697ac1127c15205d7/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c30bf43eb2325caa4cb32a697ac1127c15205d7/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=0c30bf43eb2325caa4cb32a697ac1127c15205d7", "patch": "@@ -256,6 +256,10 @@ U\n C ObjC C++ ObjC++ Joined Separate MissingArgError(macro name missing after %qs)\n -U<macro>\tUndefine <macro>.\n \n+WNSObject-attribute\n+C ObjC C++ ObjC++ LTO Var(warn_nsobject_attribute) Warning Init(1)\n+Warn if the NSObject attribute is applied to a non-typedef.\n+\n Wabi\n C ObjC C++ ObjC++ LTO Var(warn_abi) Warning\n Warn about things that will change when compiling with an ABI-compliant compiler."}, {"sha": "8be4beadf3bccd7f7d61d2a485836cf665da729b", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c30bf43eb2325caa4cb32a697ac1127c15205d7/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c30bf43eb2325caa4cb32a697ac1127c15205d7/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=0c30bf43eb2325caa4cb32a697ac1127c15205d7", "patch": "@@ -2476,9 +2476,14 @@ objc_compare_types (tree ltyp, tree rtyp, int argno, tree callee)\n   if (!POINTER_TYPE_P (ltyp) || !POINTER_TYPE_P (rtyp))\n     return false;\n \n+  tree ltyp_attr, rtyp_attr;\n   do\n     {\n-      ltyp = TREE_TYPE (ltyp);  /* Remove indirections.  */\n+      /* Remove indirections, but keep the type attributes from the innermost\n+\t pointer type, to check for NSObject.  */\n+      ltyp_attr = TYPE_ATTRIBUTES (ltyp);\n+      ltyp = TREE_TYPE (ltyp);\n+      rtyp_attr = TYPE_ATTRIBUTES (rtyp);\n       rtyp = TREE_TYPE (rtyp);\n     }\n   while (POINTER_TYPE_P (ltyp) && POINTER_TYPE_P (rtyp));\n@@ -2523,17 +2528,23 @@ objc_compare_types (tree ltyp, tree rtyp, int argno, tree callee)\n       return true;\n     }\n \n+  /* We might have void * with NSObject type attr.  */\n+  bool l_NSObject_p = ltyp_attr && lookup_attribute (\"NSObject\", ltyp_attr);\n+  bool r_NSObject_p = rtyp_attr && lookup_attribute (\"NSObject\", rtyp_attr);\n+\n   /* Past this point, we are only interested in ObjC class instances,\n-     or 'id' or 'Class'.  */\n-  if (TREE_CODE (ltyp) != RECORD_TYPE || TREE_CODE (rtyp) != RECORD_TYPE)\n+     or 'id' or 'Class' (except if the user applied the NSObject type\n+     attribute).  */\n+  if ((TREE_CODE (ltyp) != RECORD_TYPE && !l_NSObject_p)\n+      || (TREE_CODE (rtyp) != RECORD_TYPE && !r_NSObject_p))\n     return false;\n \n   if (!objc_is_object_id (ltyp) && !objc_is_class_id (ltyp)\n-      && !TYPE_HAS_OBJC_INFO (ltyp))\n+      && !TYPE_HAS_OBJC_INFO (ltyp) && !l_NSObject_p)\n     return false;\n \n   if (!objc_is_object_id (rtyp) && !objc_is_class_id (rtyp)\n-      && !TYPE_HAS_OBJC_INFO (rtyp))\n+      && !TYPE_HAS_OBJC_INFO (rtyp) && !r_NSObject_p)\n     return false;\n \n   /* Past this point, we are committed to returning 'true' to the caller\n@@ -2567,20 +2578,23 @@ objc_compare_types (tree ltyp, tree rtyp, int argno, tree callee)\n     rcls = NULL_TREE;\n \n   /* If either type is an unqualified 'id', we're done.  This is because\n-     an 'id' can be assigned to or from any type with no warnings.  */\n+     an 'id' can be assigned to or from any type with no warnings.  When\n+     the pointer has NSObject attribute, consider that to be equivalent.  */\n   if (argno != -5)\n     {\n       if ((!lproto && objc_is_object_id (ltyp))\n \t  || (!rproto && objc_is_object_id (rtyp)))\n \treturn true;\n+      if (l_NSObject_p || r_NSObject_p)\n+\treturn true;\n     }\n   else\n     {\n       /* For property checks, though, an 'id' is considered the most\n \t general type of object, hence if you try to specialize an\n \t 'NSArray *' (ltyp) property with an 'id' (rtyp) one, we need\n \t to warn.  */\n-      if (!lproto && objc_is_object_id (ltyp))\n+      if (!lproto && (objc_is_object_id (ltyp) || l_NSObject_p))\n \treturn true;\n     }\n \n@@ -8659,11 +8673,19 @@ objc_type_valid_for_messaging (tree type, bool accept_classes)\n   if (!POINTER_TYPE_P (type))\n     return false;\n \n+  /* We will check for an NSObject type attribute  on the pointer if other\n+     tests fail.  */\n+  tree type_attr = TYPE_ATTRIBUTES (type);\n+\n   /* Remove the pointer indirection; don't remove more than one\n      otherwise we'd consider \"NSObject **\" a valid type for messaging,\n      which it isn't.  */\n   type = TREE_TYPE (type);\n \n+  /* We allow void * to have an NSObject type attr.  */\n+  if (VOID_TYPE_P (type) && type_attr)\n+    return lookup_attribute (\"NSObject\", type_attr) != NULL_TREE;\n+\n   if (TREE_CODE (type) != RECORD_TYPE)\n     return false;\n \n@@ -8676,6 +8698,9 @@ objc_type_valid_for_messaging (tree type, bool accept_classes)\n   if (TYPE_HAS_OBJC_INFO (type))\n     return true;\n \n+  if (type_attr)\n+    return lookup_attribute (\"NSObject\", type_attr) != NULL_TREE;\n+\n   return false;\n }\n "}, {"sha": "498fbc7e8fd55817a8576c369f00c97d75d54025", "filename": "gcc/testsuite/obj-c++.dg/attributes/nsobject-01.mm", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c30bf43eb2325caa4cb32a697ac1127c15205d7/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fattributes%2Fnsobject-01.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c30bf43eb2325caa4cb32a697ac1127c15205d7/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fattributes%2Fnsobject-01.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fattributes%2Fnsobject-01.mm?ref=0c30bf43eb2325caa4cb32a697ac1127c15205d7", "patch": "@@ -0,0 +1,66 @@\n+/* Test handling of the NSObject attribute.  */\n+/*  { dg-additional-options \"-fsyntax-only \" } */\n+\n+typedef struct AnObj * __attribute__ ((NSObject)) AnObjRef;\n+typedef struct AnObj * __attribute__ ((__NSObject__)) AnotherObjRef;\n+\n+/* We allow a void * to be labeled as NSObject.  */\n+typedef void *  __attribute__((NSObject)) AnonRef;\n+\n+typedef struct AnObj * __attribute__((NSObject(\"foo\"))) Bad; // { dg-error {wrong number of arguments specified for 'NSObject' attribute} }\n+typedef struct AnObj * __attribute__((NSObject(42))) Wrong; // { dg-error {wrong number of arguments specified for 'NSObject' attribute} }\n+\n+/* Must be a pointer.  */\n+typedef struct AnObj  __attribute__((NSObject)) BadRef; // { dg-error {'NSObject' attribute is for pointer types only} }\n+\n+typedef void * VPtr;\n+\n+@interface CheckAttrNSObject\n+{\n+@public\n+  AnObjRef aor;\n+  /* TODO: synthesize without pre-defined ivars.  */\n+  VPtr obj_v;\n+  int bar;\n+  /* TODO: This should warn, even tho the property does not   */\n+   __attribute__((NSObject)) struct AnObj *Thing;\n+}\n+\n+@property(copy) AnObjRef aor;\n+\n+typedef struct AnObj * __attribute__((NSObject)) AnObjPtr3;\n+@property (nonatomic, retain) AnObjPtr3 obj_3;\n+\n+@property (retain) __attribute__((NSObject)) VPtr obj_v;\n+\n+//@property (strong, nullable) AnObjPtr3 objp_4;\n+\n+@property(retain) __attribute__((NSObject)) int bar;\n+ // { dg-error {'NSObject' attribute is for pointer types only} \"\" { target *-*-* } .-1 }\n+ // { dg-error {'retain' attribute is only valid for Objective-C objects} \"\" { target *-*-* } .-2 }\n+\n+@end\n+\n+void foo ()\n+{\n+   __attribute__((NSObject)) struct AnObj *AnotherThing; // { dg-warning {'NSObject' attribute may be put on a typedef only; attribute is ignored} }\n+}\n+\n+void\n+setProperty(id self, id value)\n+{\n+  ((CheckAttrNSObject *)self)->aor = value;\n+}\n+\n+id \n+getProperty(id self)\n+{\n+ return (id)((CheckAttrNSObject *)self)->aor;\n+}\n+\n+@implementation CheckAttrNSObject\n+@synthesize aor;\n+@dynamic obj_3;\n+@synthesize obj_v;\n+@synthesize bar;\n+@end // { dg-error {invalid conversion} }"}, {"sha": "5b568490391061ca63c91182546fdeca0f4c006e", "filename": "gcc/testsuite/objc.dg/attributes/nsobject-01.m", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c30bf43eb2325caa4cb32a697ac1127c15205d7/gcc%2Ftestsuite%2Fobjc.dg%2Fattributes%2Fnsobject-01.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c30bf43eb2325caa4cb32a697ac1127c15205d7/gcc%2Ftestsuite%2Fobjc.dg%2Fattributes%2Fnsobject-01.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fattributes%2Fnsobject-01.m?ref=0c30bf43eb2325caa4cb32a697ac1127c15205d7", "patch": "@@ -0,0 +1,66 @@\n+/* Test handling of the NSObject attribute.  */\n+/*  { dg-additional-options \"-fsyntax-only \" } */\n+\n+typedef struct AnObj * __attribute__ ((NSObject)) AnObjRef;\n+typedef struct AnObj * __attribute__ ((__NSObject__)) AnotherObjRef;\n+\n+/* We allow a void * to be labeled as NSObject.  */\n+typedef void *  __attribute__((NSObject)) AnonRef;\n+\n+typedef struct AnObj * __attribute__((NSObject(\"foo\"))) Bad; // { dg-error {wrong number of arguments specified for 'NSObject' attribute} }\n+typedef struct AnObj * __attribute__((NSObject(42))) Wrong; // { dg-error {wrong number of arguments specified for 'NSObject' attribute} }\n+\n+/* Must be a pointer.  */\n+typedef struct AnObj  __attribute__((NSObject)) BadRef; // { dg-error {'NSObject' attribute is for pointer types only} }\n+\n+typedef void * VPtr;\n+\n+@interface CheckAttrNSObject\n+{\n+@public\n+  AnObjRef aor;\n+  /* TODO: synthesize without pre-defined ivars.  */\n+  VPtr obj_v;\n+  int bar;\n+  /* TODO: This should warn, even tho the property does not   */\n+   __attribute__((NSObject)) struct AnObj *Thing;\n+}\n+\n+@property(copy) AnObjRef aor;\n+\n+typedef struct AnObj * __attribute__((NSObject)) AnObjPtr3;\n+@property (nonatomic, retain) AnObjPtr3 obj_3;\n+\n+@property (retain) __attribute__((NSObject)) VPtr obj_v;\n+\n+//@property (strong, nullable) AnObjPtr3 objp_4;\n+\n+@property(retain) __attribute__((NSObject)) int bar;\n+ // { dg-error {'NSObject' attribute is for pointer types only} \"\" { target *-*-* } .-1 }\n+ // { dg-error {'retain' attribute is only valid for Objective-C objects} \"\" { target *-*-* } .-2 }\n+\n+@end\n+\n+void foo ()\n+{\n+   __attribute__((NSObject)) struct AnObj *AnotherThing; // { dg-warning {'NSObject' attribute may be put on a typedef only; attribute is ignored} }\n+}\n+\n+void\n+setProperty(id self, id value)\n+{\n+  ((CheckAttrNSObject *)self)->aor = value;\n+}\n+\n+id \n+getProperty(id self)\n+{\n+ return (id)((CheckAttrNSObject *)self)->aor;\n+}\n+\n+@implementation CheckAttrNSObject\n+@synthesize aor;\n+@dynamic obj_3;\n+@synthesize obj_v;\n+@synthesize bar; // { dg-warning {returning 'id' from a function with return type 'int'} }\n+@end // { dg-warning {passing argument} }"}]}