{"sha": "e18d6a151c6c0a45cd30f150de87f1fb5c10f199", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE4ZDZhMTUxYzZjMGE0NWNkMzBmMTUwZGU4N2YxZmI1YzEwZjE5OQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2007-09-11T13:31:51Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-09-11T13:31:51Z"}, "message": "Put back previous change, the random failure was caused by a makefile bug,\n\ncausing the Ada run-time not to be recompiled by the new compiler.\n\nFrom-SVN: r128374", "tree": {"sha": "dc0e60fcea3bc13264723d599875a7d3ad8ed3c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc0e60fcea3bc13264723d599875a7d3ad8ed3c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e18d6a151c6c0a45cd30f150de87f1fb5c10f199", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e18d6a151c6c0a45cd30f150de87f1fb5c10f199", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e18d6a151c6c0a45cd30f150de87f1fb5c10f199", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e18d6a151c6c0a45cd30f150de87f1fb5c10f199/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0f4cb75c685714ba7afc832dd9eb792bcb1fbaf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f4cb75c685714ba7afc832dd9eb792bcb1fbaf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f4cb75c685714ba7afc832dd9eb792bcb1fbaf4"}], "stats": {"total": 564, "additions": 317, "deletions": 247}, "files": [{"sha": "1ad4a404e8e04f76063c939cc355fb14a320e140", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18d6a151c6c0a45cd30f150de87f1fb5c10f199/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18d6a151c6c0a45cd30f150de87f1fb5c10f199/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e18d6a151c6c0a45cd30f150de87f1fb5c10f199", "patch": "@@ -1,3 +1,24 @@\n+2007-09-11  Javier Miranda  <miranda@adacore.com>\n+\n+\t* einfo.ads, einfo.adb (Dispatch_Table_Wrapper): New attribute. Present\n+\tin library level record type entities if we are generating statically\n+\tallocated dispatch tables.\n+\n+\t* exp_disp.adb (Make_Tags/Make_DT): Replace previous code\n+\timporting/exporting the _tag declaration by new code\n+\timporting/exporting the dispatch table wrapper. This change allows us\n+\tto statically allocate of the TSD.\n+\t(Make_DT.Export_DT): New procedure.\n+\t(Build_Static_DT): New function.\n+\t(Has_DT): New function.\n+\n+\t* freeze.adb (Freeze_Static_Object): Code cleanup: Do not reset flags\n+\tTrue_Constant and Current_Value. Required to statically\n+\tallocate the dispatch tables.\n+\t(Check_Allocator): Make function iterative instead of recursive.\n+ \tAlso return inner allocator node, when present, so that we do not have\n+ \tto look for that node again in the caller.\n+\n 2007-09-11  Jan Hubicka <jh@suse.cz>\n \n \t* misc.c (gnat_expand_body): Kill."}, {"sha": "fad178003e5a7fd7a3a873865acd3eb92727118d", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18d6a151c6c0a45cd30f150de87f1fb5c10f199/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18d6a151c6c0a45cd30f150de87f1fb5c10f199/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=e18d6a151c6c0a45cd30f150de87f1fb5c10f199", "patch": "@@ -217,6 +217,7 @@ package body Einfo is\n    --    DT_Offset_To_Top_Func           Node25\n    --    Task_Body_Procedure             Node25\n \n+   --    Dispatch_Table_Wrapper          Node16\n    --    Overridden_Operation            Node26\n    --    Package_Instantiation           Node26\n    --    Related_Interface               Node26\n@@ -842,6 +843,12 @@ package body Einfo is\n       return Uint15 (Id);\n    end Discriminant_Number;\n \n+   function Dispatch_Table_Wrapper (Id : E) return E is\n+   begin\n+      pragma Assert (Is_Tagged_Type (Id));\n+      return Node26 (Implementation_Base_Type (Id));\n+   end Dispatch_Table_Wrapper;\n+\n    function DT_Entry_Count (Id : E) return U is\n    begin\n       pragma Assert (Ekind (Id) = E_Component and then Is_Tag (Id));\n@@ -3116,6 +3123,12 @@ package body Einfo is\n       Set_Uint15 (Id, V);\n    end Set_Discriminant_Number;\n \n+   procedure Set_Dispatch_Table_Wrapper (Id : E; V : E) is\n+   begin\n+      pragma Assert (Is_Tagged_Type (Id) and then Id = Base_Type (Id));\n+      Set_Node26 (Id, V);\n+   end Set_Dispatch_Table_Wrapper;\n+\n    procedure Set_DT_Entry_Count (Id : E; V : U) is\n    begin\n       pragma Assert (Ekind (Id) = E_Component);\n@@ -8253,6 +8266,10 @@ package body Einfo is\n                Write_Str (\"Static_Initialization\");\n             end if;\n \n+         when E_Record_Type                                |\n+              E_Record_Type_With_Private                   =>\n+            Write_Str (\"Dispatch_Table_Wrapper\");\n+\n          when others                                       =>\n             Write_Str (\"Field26??\");\n       end case;"}, {"sha": "b95165ba3b0db464a42943415fe7827864359d69", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18d6a151c6c0a45cd30f150de87f1fb5c10f199/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18d6a151c6c0a45cd30f150de87f1fb5c10f199/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=e18d6a151c6c0a45cd30f150de87f1fb5c10f199", "patch": "@@ -819,6 +819,12 @@ package Einfo is\n --       the list of discriminants of the type, i.e. a sequential integer\n --       index starting at 1 and ranging up to Number_Discriminants.\n \n+--    Dispatch_Table_Wrapper (Node26) [implementation base type only]\n+--       Present in library level record type entities if we are generating\n+--       statically allocated dispatch tables. For a tagged type, points to\n+--       the dispatch table wrapper associated with the tagged type. For a\n+--       non-tagged record, contains Empty.\n+\n --    DTC_Entity (Node16)\n --       Present in function and procedure entities. Set to Empty unless\n --       the subprogram is dispatching in which case it references the\n@@ -5120,6 +5126,7 @@ package Einfo is\n    --  E_Record_Subtype\n    --    Primitive_Operations                (Elist15)\n    --    Access_Disp_Table                   (Elist16)  (base type only)\n+   --    Dispatch_Table_Wrapper              (Node26)   (base type only)\n    --    Cloned_Subtype                      (Node16)   (subtype case only)\n    --    First_Entity                        (Node17)\n    --    Corresponding_Concurrent_Type       (Node18)\n@@ -5153,6 +5160,7 @@ package Einfo is\n    --  E_Record_Subtype_With_Private\n    --    Primitive_Operations                (Elist15)\n    --    Access_Disp_Table                   (Elist16)  (base type only)\n+   --    Dispatch_Table_Wrapper              (Node26)   (base type only)\n    --    First_Entity                        (Node17)\n    --    Private_Dependents                  (Elist18)\n    --    Underlying_Full_View                (Node19)\n@@ -5547,6 +5555,7 @@ package Einfo is\n    function Current_Value                       (Id : E) return N;\n    function Debug_Info_Off                      (Id : E) return B;\n    function Debug_Renaming_Link                 (Id : E) return E;\n+   function Dispatch_Table_Wrapper              (Id : E) return E;\n    function DTC_Entity                          (Id : E) return E;\n    function DT_Entry_Count                      (Id : E) return U;\n    function DT_Offset_To_Top_Func               (Id : E) return E;\n@@ -6048,6 +6057,7 @@ package Einfo is\n    procedure Set_Abstract_Interfaces             (Id : E; V : L);\n    procedure Set_Accept_Address                  (Id : E; V : L);\n    procedure Set_Access_Disp_Table               (Id : E; V : L);\n+   procedure Set_Dispatch_Table_Wrapper          (Id : E; V : E);\n    procedure Set_Actual_Subtype                  (Id : E; V : E);\n    procedure Set_Address_Taken                   (Id : E; V : B := True);\n    procedure Set_Alias                           (Id : E; V : E);\n@@ -6676,6 +6686,7 @@ package Einfo is\n    pragma Inline (Current_Value);\n    pragma Inline (Debug_Info_Off);\n    pragma Inline (Debug_Renaming_Link);\n+   pragma Inline (Dispatch_Table_Wrapper);\n    pragma Inline (DTC_Entity);\n    pragma Inline (DT_Entry_Count);\n    pragma Inline (DT_Offset_To_Top_Func);\n@@ -7080,6 +7091,7 @@ package Einfo is\n    pragma Inline (Set_Current_Value);\n    pragma Inline (Set_Debug_Info_Off);\n    pragma Inline (Set_Debug_Renaming_Link);\n+   pragma Inline (Set_Dispatch_Table_Wrapper);\n    pragma Inline (Set_DTC_Entity);\n    pragma Inline (Set_DT_Entry_Count);\n    pragma Inline (Set_DT_Offset_To_Top_Func);"}, {"sha": "2d663baf6c2d67265f17c6b7b5baa182f517fe6b", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 223, "deletions": 196, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18d6a151c6c0a45cd30f150de87f1fb5c10f199/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18d6a151c6c0a45cd30f150de87f1fb5c10f199/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=e18d6a151c6c0a45cd30f150de87f1fb5c10f199", "patch": "@@ -10,14 +10,13 @@\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n -- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n -- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n -- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n -- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n--- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n--- Boston, MA 02110-1301, USA.                                              --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n --                                                                          --\n -- GNAT was originally developed  by the GNAT team at  New York University. --\n -- Extensive contributions were provided by Ada Core Technologies Inc.      --\n@@ -67,10 +66,18 @@ package body Exp_Disp is\n    -- Local Subprograms --\n    -----------------------\n \n+   function Building_Static_DT (Typ : Entity_Id) return Boolean;\n+   pragma Inline (Building_Static_DT);\n+   --  Returns true when building statically allocated dispatch tables\n+\n    function Default_Prim_Op_Position (E : Entity_Id) return Uint;\n    --  Ada 2005 (AI-251): Returns the fixed position in the dispatch table\n    --  of the default primitive operations.\n \n+   function Has_DT (Typ : Entity_Id) return Boolean;\n+   pragma Inline (Has_DT);\n+   --  Returns true if we generate a dispatch table for tagged type Typ\n+\n    function Is_Predefined_Dispatching_Alias (Prim : Entity_Id) return Boolean;\n    --  Returns true if Prim is not a predefined dispatching primitive but it is\n    --  an alias of a predefined dispatching primitive (ie. through a renaming)\n@@ -90,6 +97,16 @@ package body Exp_Disp is\n    --  Ada 2005 (AI-345): Determine the tagged kind of T and return a reference\n    --  to an RE_Tagged_Kind enumeration value.\n \n+   ------------------------\n+   -- Building_Static_DT --\n+   ------------------------\n+\n+   function Building_Static_DT (Typ : Entity_Id) return Boolean is\n+   begin\n+      return Static_Dispatch_Tables\n+               and then Is_Library_Level_Tagged_Type (Typ);\n+   end Building_Static_DT;\n+\n    ----------------------------------\n    -- Build_Static_Dispatch_Tables --\n    ----------------------------------\n@@ -1428,6 +1445,16 @@ package body Exp_Disp is\n       end if;\n    end Expand_Interface_Thunk;\n \n+   ------------\n+   -- Has_DT --\n+   ------------\n+\n+   function Has_DT (Typ : Entity_Id) return Boolean is\n+   begin\n+      return not Is_Interface (Typ)\n+               and then not Restriction_Active (No_Dispatching_Calls);\n+   end Has_DT;\n+\n    -------------------------------------\n    -- Is_Predefined_Dispatching_Alias --\n    -------------------------------------\n@@ -2434,14 +2461,6 @@ package body Exp_Disp is\n    function Make_DT (Typ : Entity_Id; N : Node_Id := Empty) return List_Id is\n       Loc : constant Source_Ptr := Sloc (Typ);\n \n-      Has_DT : constant Boolean :=\n-                 not Is_Interface (Typ)\n-               and then not Restriction_Active (No_Dispatching_Calls);\n-\n-      Build_Static_DT : constant Boolean :=\n-                          Static_Dispatch_Tables\n-                            and then Is_Library_Level_Tagged_Type (Typ);\n-\n       Max_Predef_Prims : constant Int :=\n                            UI_To_Int\n                              (Intval\n@@ -2460,6 +2479,10 @@ package body Exp_Disp is\n       --  freezes a tagged type, when one of its primitive operations has a\n       --  type in its profile whose full view has not been analyzed yet.\n \n+      procedure Export_DT (Typ : Entity_Id; DT : Entity_Id);\n+      --  Export the dispatch table entity DT of tagged type Typ. Required to\n+      --  generate forward references and statically allocate the table.\n+\n       procedure Make_Secondary_DT\n         (Typ          : Entity_Id;\n          Iface        : Entity_Id;\n@@ -2496,6 +2519,28 @@ package body Exp_Disp is\n          end if;\n       end Check_Premature_Freezing;\n \n+      ---------------\n+      -- Export_DT --\n+      ---------------\n+\n+      procedure Export_DT (Typ : Entity_Id; DT : Entity_Id) is\n+      begin\n+         Set_Is_Statically_Allocated (DT);\n+         Set_Is_True_Constant (DT);\n+         Set_Is_Exported (DT);\n+\n+         pragma Assert (Present (Dispatch_Table_Wrapper (Typ)));\n+         Get_External_Name (Dispatch_Table_Wrapper (Typ), True);\n+         Set_Interface_Name (DT,\n+           Make_String_Literal (Loc,\n+             Strval => String_From_Name_Buffer));\n+\n+         --  Ensure proper Sprint output of this implicit importation\n+\n+         Set_Is_Internal (DT);\n+         Set_Is_Public (DT);\n+      end Export_DT;\n+\n       -----------------------\n       -- Make_Secondary_DT --\n       -----------------------\n@@ -2508,7 +2553,6 @@ package body Exp_Disp is\n          Result       : List_Id)\n       is\n          Loc                : constant Source_Ptr := Sloc (Typ);\n-         Generalized_Tag    : constant Entity_Id := RTE (RE_Interface_Tag);\n          Name_DT            : constant Name_Id := New_Internal_Name ('T');\n          Iface_DT           : constant Entity_Id :=\n                                 Make_Defining_Identifier (Loc, Name_DT);\n@@ -2533,7 +2577,7 @@ package body Exp_Disp is\n          --  Handle cases in which we do not generate statically allocated\n          --  dispatch tables.\n \n-         if not Build_Static_DT then\n+         if not Building_Static_DT (Typ) then\n             Set_Ekind (Predef_Prims, E_Variable);\n             Set_Is_Statically_Allocated (Predef_Prims);\n \n@@ -2576,7 +2620,7 @@ package body Exp_Disp is\n \n          --  Stage 1: Calculate the number of predefined primitives\n \n-         if not Build_Static_DT then\n+         if not Building_Static_DT (Typ) then\n             Nb_Predef_Prims := Max_Predef_Prims;\n          else\n             Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n@@ -2650,7 +2694,7 @@ package body Exp_Disp is\n             Append_To (Result,\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => Predef_Prims,\n-                Constant_Present    => Build_Static_DT,\n+                Constant_Present    => Building_Static_DT (Typ),\n                 Aliased_Present     => True,\n                 Object_Definition   =>\n                   New_Reference_To (RTE (RE_Address_Array), Loc),\n@@ -2858,7 +2902,7 @@ package body Exp_Disp is\n               New_Reference_To (RTE (RE_Null_Address), Loc));\n \n          elsif Is_Abstract_Type (Typ)\n-           or else not Build_Static_DT\n+           or else not Building_Static_DT (Typ)\n          then\n             for J in 1 .. Nb_Prim loop\n                Append_To (Prim_Ops_Aggr_List,\n@@ -2963,7 +3007,7 @@ package body Exp_Disp is\n              Object_Definition =>\n                New_Reference_To (RTE (RE_Interface_Tag), Loc),\n              Expression =>\n-               Unchecked_Convert_To (Generalized_Tag,\n+               Unchecked_Convert_To (RTE (RE_Interface_Tag),\n                  Make_Attribute_Reference (Loc,\n                    Prefix =>\n                      Make_Selected_Component (Loc,\n@@ -2978,14 +3022,13 @@ package body Exp_Disp is\n       --  Local variables\n \n       Elab_Code          : constant List_Id   := New_List;\n-      Generalized_Tag    : constant Entity_Id := RTE (RE_Tag);\n       Result             : constant List_Id   := New_List;\n       Tname              : constant Name_Id   := Chars (Typ);\n       AI                 : Elmt_Id;\n-      AI_Tag_Comp        : Elmt_Id;\n       AI_Ptr_Elmt        : Elmt_Id;\n-      DT_Constr_List     : List_Id;\n+      AI_Tag_Comp        : Elmt_Id;\n       DT_Aggr_List       : List_Id;\n+      DT_Constr_List     : List_Id;\n       DT_Ptr             : Entity_Id;\n       ITable             : Node_Id;\n       I_Depth            : Nat := 0;\n@@ -3066,7 +3109,7 @@ package body Exp_Disp is\n              Object_Definition   => New_Reference_To (RTE (RE_Tag), Loc),\n              Constant_Present    => True,\n              Expression =>\n-               Unchecked_Convert_To (Generalized_Tag,\n+               Unchecked_Convert_To (RTE (RE_Tag),\n                  New_Reference_To (RTE (RE_Null_Address), Loc))));\n \n          Analyze_List (Result, Suppress => All_Checks);\n@@ -3096,10 +3139,10 @@ package body Exp_Disp is\n       --  be referenced (otherwise we have problems with the backend). It is\n       --  not a requirement with nonstatic dispatch tables because in this case\n       --  we generate now an empty dispatch table; the extra code required to\n-      --  register the primitive in the slot will be generated later --- when\n+      --  register the primitives in the slots will be generated later --- when\n       --  each primitive is frozen (see Freeze_Subprogram).\n \n-      if Build_Static_DT\n+      if Building_Static_DT (Typ)\n         and then not Is_CPP_Class (Typ)\n       then\n          declare\n@@ -3137,49 +3180,6 @@ package body Exp_Disp is\n          end;\n       end if;\n \n-      --  In case of locally defined tagged type we declare the object\n-      --  contanining the dispatch table by means of a variable. Its\n-      --  initialization is done later by means of an assignment. This is\n-      --  required to generate its External_Tag.\n-\n-      if not Build_Static_DT then\n-         DT_Ptr := Node (First_Elmt (Access_Disp_Table (Typ)));\n-         Set_Ekind (DT, E_Variable);\n-\n-      --  Export the declaration of the tag previously generated and imported\n-      --  by Make_Tags.\n-\n-      else\n-         DT_Ptr :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => New_External_Name (Tname, 'C', Suffix_Index => -1));\n-         Set_Ekind (DT_Ptr, E_Constant);\n-         Set_Is_Statically_Allocated (DT_Ptr);\n-         Set_Is_True_Constant (DT_Ptr);\n-\n-         Set_Is_Exported (DT_Ptr);\n-         Get_External_Name (Node (First_Elmt (Access_Disp_Table (Typ))), True);\n-         Set_Interface_Name (DT_Ptr,\n-           Make_String_Literal (Loc,\n-             Strval => String_From_Name_Buffer));\n-\n-         --  Set tag as internal to ensure proper Sprint output of its implicit\n-         --  exportation.\n-\n-         Set_Is_Internal (DT_Ptr);\n-\n-         Set_Ekind (DT, E_Constant);\n-         Set_Is_True_Constant (DT);\n-\n-         --  The tag is made public to ensure its availability to the linker\n-         --  (to handle the forward reference). This is required to handle\n-         --  tagged types defined in library level package bodies.\n-\n-         Set_Is_Public (DT_Ptr);\n-      end if;\n-\n-      Set_Is_Statically_Allocated (DT);\n-\n       --  Ada 2005 (AI-251): Build the secondary dispatch tables\n \n       if Has_Abstract_Interfaces (Typ) then\n@@ -3204,24 +3204,15 @@ package body Exp_Disp is\n          end loop;\n       end if;\n \n-      --  Calculate the number of primitives of the dispatch table and the\n-      --  size of the Type_Specific_Data record.\n+      --  Get the _tag entity and the number of primitives of its dispatch\n+      --  table.\n \n-      if Has_DT then\n-         Nb_Prim := UI_To_Int (DT_Entry_Count (First_Tag_Component (Typ)));\n-      end if;\n+      DT_Ptr  := Node (First_Elmt (Access_Disp_Table (Typ)));\n+      Nb_Prim := UI_To_Int (DT_Entry_Count (First_Tag_Component (Typ)));\n \n-      Set_Ekind (SSD, E_Constant);\n+      Set_Is_Statically_Allocated (DT);\n       Set_Is_Statically_Allocated (SSD);\n-      Set_Is_True_Constant (SSD);\n-\n-      Set_Ekind (TSD, E_Constant);\n       Set_Is_Statically_Allocated (TSD);\n-      Set_Is_True_Constant (TSD);\n-\n-      Set_Ekind (Exname, E_Constant);\n-      Set_Is_Statically_Allocated (Exname);\n-      Set_Is_True_Constant (Exname);\n \n       --  Generate code to define the boolean that controls registration, in\n       --  order to avoid multiple registrations for tagged types defined in\n@@ -3246,14 +3237,14 @@ package body Exp_Disp is\n       --  initialization is done later by means of an assignment. This is\n       --  required to generate its External_Tag.\n \n-      if not Build_Static_DT then\n+      if not Building_Static_DT (Typ) then\n \n          --  Generate:\n          --    DT     : No_Dispatch_Table_Wrapper;\n          --    for DT'Alignment use Address'Alignment;\n          --    DT_Ptr : Tag := !Tag (DT.NDT_Prims_Ptr'Address);\n \n-         if not Has_DT then\n+         if not Has_DT (Typ) then\n             Append_To (Result,\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => DT,\n@@ -3279,7 +3270,7 @@ package body Exp_Disp is\n                 Object_Definition   => New_Reference_To (RTE (RE_Tag), Loc),\n                 Constant_Present    => True,\n                 Expression =>\n-                  Unchecked_Convert_To (Generalized_Tag,\n+                  Unchecked_Convert_To (RTE (RE_Tag),\n                     Make_Attribute_Reference (Loc,\n                       Prefix =>\n                         Make_Selected_Component (Loc,\n@@ -3334,7 +3325,7 @@ package body Exp_Disp is\n                 Object_Definition   => New_Reference_To (RTE (RE_Tag), Loc),\n                 Constant_Present    => True,\n                 Expression =>\n-                  Unchecked_Convert_To (Generalized_Tag,\n+                  Unchecked_Convert_To (RTE (RE_Tag),\n                     Make_Attribute_Reference (Loc,\n                       Prefix =>\n                         Make_Selected_Component (Loc,\n@@ -3359,6 +3350,9 @@ package body Exp_Disp is\n             Make_String_Literal (Loc,\n               Full_Qualified_Name (First_Subtype (Typ)))));\n \n+      Set_Is_Statically_Allocated (Exname);\n+      Set_Is_True_Constant (Exname);\n+\n       --  Generate code to create the storage for the type specific data object\n       --  with enough space to store the tags of the ancestors plus the tags\n       --  of all the implemented interfaces (as described in a-tags.adb).\n@@ -3372,7 +3366,7 @@ package body Exp_Disp is\n       --            Transportable      => <<boolean-value>>,\n       --            RC_Offset          => <<integer-value>>,\n       --            [ Interfaces_Table  => <<access-value>> ]\n-      --            [  SSD              => SSD_Table'Address ]\n+      --            [ SSD               => SSD_Table'Address ]\n       --            Tags_Table         => (0 => null,\n       --                                   1 => Parent'Tag\n       --                                   ...);\n@@ -3711,7 +3705,7 @@ package body Exp_Disp is\n \n                         --  Iface_Tag\n \n-                        Unchecked_Convert_To (Generalized_Tag,\n+                        Unchecked_Convert_To (RTE (RE_Tag),\n                           New_Reference_To\n                             (Node (First_Elmt (Access_Disp_Table (Node (AI)))),\n                              Loc)),\n@@ -3787,7 +3781,7 @@ package body Exp_Disp is\n \n       if RTE_Record_Component_Available (RE_SSD) then\n          if Ada_Version >= Ada_05\n-           and then Has_DT\n+           and then Has_DT (Typ)\n            and then Is_Concurrent_Record_Type (Typ)\n            and then Has_Abstract_Interfaces (Typ)\n            and then Nb_Prim > 0\n@@ -3845,48 +3839,18 @@ package body Exp_Disp is\n          --  must fill position 0 with null because we still have not\n          --  generated the tag of Typ.\n \n-         if not Build_Static_DT\n+         if not Building_Static_DT (Typ)\n            or else Is_Interface (Typ)\n          then\n             Append_To (TSD_Tags_List,\n               Unchecked_Convert_To (RTE (RE_Tag),\n                 New_Reference_To (RTE (RE_Null_Address), Loc)));\n \n-         --  Otherwise we can safely import the tag. The name must be unique\n-         --  over the compilation unit, to avoid conflicts when types of the\n-         --  same name appear in different nested packages. We don't need to\n-         --  use an external name because this name is only locally used.\n+         --  Otherwise we can safely reference the tag.\n \n          else\n-            declare\n-               Imported_DT_Ptr : constant Entity_Id :=\n-                                   Make_Defining_Identifier (Loc,\n-                                     Chars => New_Internal_Name ('D'));\n-\n-            begin\n-               Set_Is_Imported (Imported_DT_Ptr);\n-               Set_Is_Statically_Allocated (Imported_DT_Ptr);\n-               Set_Is_True_Constant (Imported_DT_Ptr);\n-               Get_External_Name\n-                 (Node (First_Elmt (Access_Disp_Table (Typ))), True);\n-               Set_Interface_Name (Imported_DT_Ptr,\n-                 Make_String_Literal (Loc, String_From_Name_Buffer));\n-\n-               --  Set tag as internal to ensure proper Sprint output of its\n-               --  implicit importation.\n-\n-               Set_Is_Internal (Imported_DT_Ptr);\n-\n-               Append_To (Result,\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Imported_DT_Ptr,\n-                   Constant_Present    => True,\n-                   Object_Definition   => New_Reference_To (RTE (RE_Tag),\n-                                            Loc)));\n-\n-               Append_To (TSD_Tags_List,\n-                 New_Reference_To (Imported_DT_Ptr, Loc));\n-            end;\n+            Append_To (TSD_Tags_List,\n+              New_Reference_To (DT_Ptr, Loc));\n          end if;\n \n          --  Fill the rest of the table with the tags of the ancestors\n@@ -3936,7 +3900,7 @@ package body Exp_Disp is\n         Make_Object_Declaration (Loc,\n           Defining_Identifier => TSD,\n           Aliased_Present     => True,\n-          Constant_Present    => Build_Static_DT,\n+          Constant_Present    => Building_Static_DT (Typ),\n           Object_Definition   =>\n             Make_Subtype_Indication (Loc,\n               Subtype_Mark => New_Reference_To (\n@@ -3949,6 +3913,8 @@ package body Exp_Disp is\n           Expression => Make_Aggregate (Loc,\n             Expressions => TSD_Aggr_List)));\n \n+      Set_Is_True_Constant (TSD, Building_Static_DT (Typ));\n+\n       Append_To (Result,\n         Make_Attribute_Definition_Clause (Loc,\n           Name       => New_Reference_To (TSD, Loc),\n@@ -3958,15 +3924,9 @@ package body Exp_Disp is\n               Prefix => New_Reference_To (RTE (RE_Integer_Address), Loc),\n               Attribute_Name => Name_Alignment)));\n \n-      --  Generate the dummy Dispatch_Table object associated with tagged\n-      --  types that have no dispatch table.\n-\n-      --   DT : No_Dispatch_Table :=\n-      --          (NDT_TSD       => TSD'Address;\n-      --           NDT_Prims_Ptr => 0);\n-      --   for DT'Alignment use Address'Alignment\n+      --  Initialize or declare the dispatch table object\n \n-      if not Has_DT then\n+      if not Has_DT (Typ) then\n          DT_Constr_List := New_List;\n          DT_Aggr_List   := New_List;\n \n@@ -3983,17 +3943,26 @@ package body Exp_Disp is\n \n          --  In case of locally defined tagged types we have already declared\n          --  and uninitialized object for the dispatch table, which is now\n-         --  initialized by means of an assignment.\n+         --  initialized by means of the following assignment:\n+\n+         --    DT := (TSD'Address, 0);\n \n-         if not Build_Static_DT then\n+         if not Building_Static_DT (Typ) then\n             Append_To (Result,\n               Make_Assignment_Statement (Loc,\n                 Name => New_Reference_To (DT, Loc),\n                 Expression => Make_Aggregate (Loc,\n                   Expressions => DT_Aggr_List)));\n \n-         --  In case of library level tagged types we declare now the constant\n-         --  object containing the dispatch table.\n+         --  In case of library level tagged types we declare and export now\n+         --  the constant object containing the dummy dispatch table. There\n+         --  is no need to declare the tag here because it has been previously\n+         --  declared by Make_Tags\n+\n+         --   DT : aliased constant No_Dispatch_Table :=\n+         --          (NDT_TSD       => TSD'Address;\n+         --           NDT_Prims_Ptr => 0);\n+         --   for DT'Alignment use Address'Alignment;\n \n          else\n             Append_To (Result,\n@@ -4016,21 +3985,7 @@ package body Exp_Disp is\n                       New_Reference_To (RTE (RE_Integer_Address), Loc),\n                     Attribute_Name => Name_Alignment)));\n \n-            Append_To (Result,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => DT_Ptr,\n-                Object_Definition   => New_Reference_To (RTE (RE_Tag), Loc),\n-                Constant_Present    => True,\n-                Expression =>\n-                  Unchecked_Convert_To (Generalized_Tag,\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix =>\n-                        Make_Selected_Component (Loc,\n-                          Prefix => New_Reference_To (DT, Loc),\n-                        Selector_Name =>\n-                          New_Occurrence_Of\n-                            (RTE_Record_Component (RE_NDT_Prims_Ptr), Loc)),\n-                      Attribute_Name => Name_Address))));\n+            Export_DT (Typ, DT);\n          end if;\n \n       --  Common case: Typ has a dispatch table\n@@ -4061,7 +4016,7 @@ package body Exp_Disp is\n             Pos : Nat;\n \n          begin\n-            if not Build_Static_DT then\n+            if not Building_Static_DT (Typ) then\n                Nb_Predef_Prims := Max_Predef_Prims;\n \n             else\n@@ -4097,7 +4052,7 @@ package body Exp_Disp is\n                while Present (Prim_Elmt) loop\n                   Prim := Node (Prim_Elmt);\n \n-                  if Build_Static_DT\n+                  if Building_Static_DT (Typ)\n                     and then Is_Predefined_Dispatching_Operation (Prim)\n                     and then not Is_Abstract_Subprogram (Prim)\n                     and then not Present (Prim_Table\n@@ -4132,7 +4087,7 @@ package body Exp_Disp is\n                  Make_Object_Declaration (Loc,\n                    Defining_Identifier => Predef_Prims,\n                    Aliased_Present     => True,\n-                   Constant_Present    => Build_Static_DT,\n+                   Constant_Present    => Building_Static_DT (Typ),\n                    Object_Definition   =>\n                      New_Reference_To (RTE (RE_Address_Array), Loc),\n                    Expression => Make_Aggregate (Loc,\n@@ -4208,7 +4163,7 @@ package body Exp_Disp is\n             Append_To (Prim_Ops_Aggr_List,\n               New_Reference_To (RTE (RE_Null_Address), Loc));\n \n-         elsif not Build_Static_DT then\n+         elsif not Building_Static_DT (Typ) then\n             for J in 1 .. Nb_Prim loop\n                Append_To (Prim_Ops_Aggr_List,\n                  New_Reference_To (RTE (RE_Null_Address), Loc));\n@@ -4279,15 +4234,15 @@ package body Exp_Disp is\n          --  and uninitialized object for the dispatch table, which is now\n          --  initialized by means of an assignment.\n \n-         if not Build_Static_DT then\n+         if not Building_Static_DT (Typ) then\n             Append_To (Result,\n               Make_Assignment_Statement (Loc,\n                 Name => New_Reference_To (DT, Loc),\n                 Expression => Make_Aggregate (Loc,\n                   Expressions => DT_Aggr_List)));\n \n-         --  In case of library level tagged types we declare now the constant\n-         --  object containing the dispatch table.\n+         --  In case of library level tagged types we declare now and export\n+         --  the constant object containing the dispatch table.\n \n          else\n             Append_To (Result,\n@@ -4314,27 +4269,13 @@ package body Exp_Disp is\n                       New_Reference_To (RTE (RE_Integer_Address), Loc),\n                     Attribute_Name => Name_Alignment)));\n \n-            Append_To (Result,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => DT_Ptr,\n-                Object_Definition   => New_Reference_To (RTE (RE_Tag), Loc),\n-                Constant_Present    => True,\n-                Expression =>\n-                  Unchecked_Convert_To (Generalized_Tag,\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix =>\n-                        Make_Selected_Component (Loc,\n-                          Prefix => New_Reference_To (DT, Loc),\n-                        Selector_Name =>\n-                          New_Occurrence_Of\n-                            (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n-                      Attribute_Name => Name_Address))));\n+            Export_DT (Typ, DT);\n          end if;\n       end if;\n \n       --  Initialize the table of ancestor tags\n \n-      if not Build_Static_DT\n+      if not Building_Static_DT (Typ)\n         and then not Is_Interface (Typ)\n         and then not Is_CPP_Class (Typ)\n       then\n@@ -4357,7 +4298,7 @@ package body Exp_Disp is\n                  (Node (First_Elmt (Access_Disp_Table (Typ))), Loc)));\n       end if;\n \n-      if Build_Static_DT then\n+      if Building_Static_DT (Typ) then\n          null;\n \n       --  If the ancestor is a CPP_Class type we inherit the dispatch tables\n@@ -4376,10 +4317,10 @@ package body Exp_Disp is\n             Null_Parent_Tag := True;\n \n             Old_Tag1 :=\n-              Unchecked_Convert_To (Generalized_Tag,\n+              Unchecked_Convert_To (RTE (RE_Tag),\n                 Make_Integer_Literal (Loc, 0));\n             Old_Tag2 :=\n-              Unchecked_Convert_To (Generalized_Tag,\n+              Unchecked_Convert_To (RTE (RE_Tag),\n                 Make_Integer_Literal (Loc, 0));\n \n          else\n@@ -4763,14 +4704,14 @@ package body Exp_Disp is\n \n    function Make_Tags (Typ : Entity_Id) return List_Id is\n       Loc             : constant Source_Ptr := Sloc (Typ);\n-      Build_Static_DT : constant Boolean :=\n-                          Static_Dispatch_Tables\n-                            and then Is_Library_Level_Tagged_Type (Typ);\n       Tname           : constant Name_Id := Chars (Typ);\n       Result          : constant List_Id := New_List;\n       AI_Tag_Comp     : Elmt_Id;\n+      DT              : Node_Id;\n+      DT_Constr_List  : List_Id;\n       DT_Ptr          : Node_Id;\n       Iface_DT_Ptr    : Node_Id;\n+      Nb_Prim         : Nat;\n       Suffix_Index    : Int;\n       Typ_Name        : Name_Id;\n       Typ_Comps       : Elist_Id;\n@@ -4789,30 +4730,116 @@ package body Exp_Disp is\n       DT_Ptr := Make_Defining_Identifier (Loc,\n                   New_External_Name (Tname, 'P'));\n       Set_Etype (DT_Ptr, RTE (RE_Tag));\n-      Set_Ekind (DT_Ptr, E_Variable);\n \n-      --  Import the forward declaration of the tag (Make_DT will take care of\n-      --  its exportation)\n+      --  Import the forward declaration of the Dispatch Table wrapper record\n+      --  (Make_DT will take care of its exportation)\n \n-      if Build_Static_DT then\n-         Set_Is_Imported (DT_Ptr);\n-         Set_Is_True_Constant (DT_Ptr);\n-         Set_Scope (DT_Ptr, Current_Scope);\n-         Get_External_Name (DT_Ptr, True);\n-         Set_Interface_Name (DT_Ptr,\n+      if Building_Static_DT (Typ)\n+        and then not Is_CPP_Class (Typ)\n+      then\n+         DT := Make_Defining_Identifier (Loc,\n+                 New_External_Name (Tname, 'T'));\n+\n+         --  Generate:\n+         --    DT : static aliased constant Dispatch_Table_Wrapper (Nb_Prim);\n+         --    $pragma import (ada, DT);\n+\n+         Set_Is_Imported (DT);\n+\n+         --  Set_Is_True_Constant (DT);\n+         --  Why is the above commented out???\n+\n+         --  The scope must be set now to call Get_External_Name\n+\n+         Set_Scope (DT, Current_Scope);\n+\n+         Get_External_Name (DT, True);\n+         Set_Interface_Name (DT,\n            Make_String_Literal (Loc,\n              Strval => String_From_Name_Buffer));\n \n-         --  Set tag entity as internal to ensure proper Sprint output of its\n-         --  implicit importation.\n+         --  Ensure proper Sprint output of this implicit importation\n \n-         Set_Is_Internal (DT_Ptr);\n+         Set_Is_Internal (DT);\n \n-         Append_To (Result,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => DT_Ptr,\n-             Constant_Present    => True,\n-             Object_Definition   => New_Reference_To (RTE (RE_Tag), Loc)));\n+         --  Save this entity to allow Make_DT to generate its exportation\n+\n+         Set_Dispatch_Table_Wrapper (Typ, DT);\n+\n+         if Has_DT (Typ) then\n+            --  Calculate the number of primitives of the dispatch table and\n+            --  the size of the Type_Specific_Data record.\n+\n+            Nb_Prim := UI_To_Int (DT_Entry_Count (First_Tag_Component (Typ)));\n+\n+            --  If the tagged type has no primitives we add a dummy slot\n+            --  whose address will be the tag of this type.\n+\n+            if Nb_Prim = 0 then\n+               DT_Constr_List :=\n+                 New_List (Make_Integer_Literal (Loc, 1));\n+            else\n+               DT_Constr_List :=\n+                 New_List (Make_Integer_Literal (Loc, Nb_Prim));\n+            end if;\n+\n+            Append_To (Result,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => DT,\n+                Aliased_Present     => True,\n+                Constant_Present    => True,\n+                Object_Definition   =>\n+                  Make_Subtype_Indication (Loc,\n+                    Subtype_Mark =>\n+                      New_Reference_To (RTE (RE_Dispatch_Table_Wrapper), Loc),\n+                    Constraint => Make_Index_Or_Discriminant_Constraint (Loc,\n+                                    Constraints => DT_Constr_List))));\n+\n+            Append_To (Result,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => DT_Ptr,\n+                Constant_Present    => True,\n+                Object_Definition   => New_Reference_To (RTE (RE_Tag), Loc),\n+                Expression =>\n+                  Unchecked_Convert_To (RTE (RE_Tag),\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix =>\n+                        Make_Selected_Component (Loc,\n+                          Prefix => New_Reference_To (DT, Loc),\n+                        Selector_Name =>\n+                          New_Occurrence_Of\n+                            (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n+                      Attribute_Name => Name_Address))));\n+\n+         --  No dispatch table required\n+\n+         else\n+            Append_To (Result,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => DT,\n+                Aliased_Present     => True,\n+                Constant_Present    => True,\n+                Object_Definition   =>\n+                  New_Reference_To (RTE (RE_No_Dispatch_Table_Wrapper), Loc)));\n+\n+            Append_To (Result,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => DT_Ptr,\n+                Constant_Present    => True,\n+                Object_Definition   => New_Reference_To (RTE (RE_Tag), Loc),\n+                Expression =>\n+                  Unchecked_Convert_To (RTE (RE_Tag),\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix =>\n+                        Make_Selected_Component (Loc,\n+                          Prefix => New_Reference_To (DT, Loc),\n+                        Selector_Name =>\n+                          New_Occurrence_Of\n+                            (RTE_Record_Component (RE_NDT_Prims_Ptr), Loc)),\n+                      Attribute_Name => Name_Address))));\n+         end if;\n+\n+         Set_Is_True_Constant (DT_Ptr);\n       end if;\n \n       pragma Assert (No (Access_Disp_Table (Typ)));"}, {"sha": "787363898f57c068be7a44e269ab1b52a7d3ae1b", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 44, "deletions": 51, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e18d6a151c6c0a45cd30f150de87f1fb5c10f199/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e18d6a151c6c0a45cd30f150de87f1fb5c10f199/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=e18d6a151c6c0a45cd30f150de87f1fb5c10f199", "patch": "@@ -1461,9 +1461,10 @@ package body Freeze is\n          --  Set True if we find at least one component with a component\n          --  clause (used to warn about useless Bit_Order pragmas).\n \n-         function Check_Allocator (N : Node_Id) return Boolean;\n-         --  Returns True if N is an expression or a qualified expression with\n-         --  an allocator.\n+         function Check_Allocator (N : Node_Id) return Node_Id;\n+         --  If N is an allocator, possibly wrapped in one or more level of\n+         --  qualified expression(s), return the inner allocator node, else\n+         --  return Empty.\n \n          procedure Check_Itype (Typ : Entity_Id);\n          --  If the component subtype is an access to a constrained subtype of\n@@ -1479,15 +1480,22 @@ package body Freeze is\n          -- Check_Allocator --\n          ---------------------\n \n-         function Check_Allocator (N : Node_Id) return Boolean is\n+         function Check_Allocator (N : Node_Id) return Node_Id is\n+            Inner : Node_Id;\n          begin\n-            if Nkind (N) = N_Allocator then\n-               return True;\n-            elsif Nkind (N) = N_Qualified_Expression then\n-               return Check_Allocator (Expression (N));\n-            else\n-               return False;\n-            end if;\n+            Inner := N;\n+\n+            loop\n+               if Nkind (Inner) = N_Allocator then\n+                  return Inner;\n+\n+               elsif Nkind (Inner) = N_Qualified_Expression then\n+                  Inner := Expression (Inner);\n+\n+               else\n+                  return Empty;\n+               end if;\n+            end loop;\n          end Check_Allocator;\n \n          -----------------\n@@ -1838,43 +1846,40 @@ package body Freeze is\n             elsif Is_Access_Type (Etype (Comp))\n               and then Present (Parent (Comp))\n               and then Present (Expression (Parent (Comp)))\n-              and then Check_Allocator (Expression (Parent (Comp)))\n             then\n                declare\n-                  Alloc : Node_Id;\n+                  Alloc : constant Node_Id :=\n+                            Check_Allocator (Expression (Parent (Comp)));\n \n                begin\n-                  --  Handle qualified expressions\n+                  if Present (Alloc) then\n \n-                  Alloc := Expression (Parent (Comp));\n-                  while Nkind (Alloc) /= N_Allocator loop\n-                     pragma Assert (Nkind (Alloc) = N_Qualified_Expression);\n-                     Alloc := Expression (Alloc);\n-                  end loop;\n-\n-                  --  If component is pointer to a classwide type, freeze the\n-                  --  specific type in the expression being allocated. The\n-                  --  expression may be a subtype indication, in which case\n-                  --  freeze the subtype mark.\n+                     --  If component is pointer to a classwide type, freeze\n+                     --  the specific type in the expression being allocated.\n+                     --  The expression may be a subtype indication, in which\n+                     --  case freeze the subtype mark.\n \n-                  if Is_Class_Wide_Type (Designated_Type (Etype (Comp))) then\n-                     if Is_Entity_Name (Expression (Alloc)) then\n-                        Freeze_And_Append\n-                          (Entity (Expression (Alloc)), Loc, Result);\n-                     elsif\n-                       Nkind (Expression (Alloc)) = N_Subtype_Indication\n+                     if Is_Class_Wide_Type\n+                          (Designated_Type (Etype (Comp)))\n                      then\n-                        Freeze_And_Append\n-                         (Entity (Subtype_Mark (Expression (Alloc))),\n-                           Loc, Result);\n-                     end if;\n+                        if Is_Entity_Name (Expression (Alloc)) then\n+                           Freeze_And_Append\n+                             (Entity (Expression (Alloc)), Loc, Result);\n+                        elsif\n+                          Nkind (Expression (Alloc)) = N_Subtype_Indication\n+                        then\n+                           Freeze_And_Append\n+                            (Entity (Subtype_Mark (Expression (Alloc))),\n+                              Loc, Result);\n+                        end if;\n \n-                  elsif Is_Itype (Designated_Type (Etype (Comp))) then\n-                     Check_Itype (Etype (Comp));\n+                     elsif Is_Itype (Designated_Type (Etype (Comp))) then\n+                        Check_Itype (Etype (Comp));\n \n-                  else\n-                     Freeze_And_Append\n-                       (Designated_Type (Etype (Comp)), Loc, Result);\n+                     else\n+                        Freeze_And_Append\n+                          (Designated_Type (Etype (Comp)), Loc, Result);\n+                     end if;\n                   end if;\n                end;\n \n@@ -4697,18 +4702,6 @@ package body Freeze is\n    begin\n       Ensure_Type_Is_SA (Etype (E));\n \n-      --  Reset True_Constant flag, since something strange is going on with\n-      --  the scoping here, and our simple value tracing may not be sufficient\n-      --  for this indication to be reliable. We kill the Constant_Value\n-      --  and Last_Assignment indications for the same reason.\n-\n-      Set_Is_True_Constant (E, False);\n-      Set_Current_Value    (E, Empty);\n-\n-      if Ekind (E) = E_Variable then\n-         Set_Last_Assignment  (E, Empty);\n-      end if;\n-\n    exception\n       when Cannot_Be_Static =>\n "}]}