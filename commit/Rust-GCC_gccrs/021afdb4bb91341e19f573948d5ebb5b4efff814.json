{"sha": "021afdb4bb91341e19f573948d5ebb5b4efff814", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIxYWZkYjRiYjkxMzQxZTE5ZjU3Mzk0OGQ1ZWJiNWI0ZWZmZjgxNA==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2012-03-21T10:41:46Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@gcc.gnu.org", "date": "2012-03-21T10:41:46Z"}, "message": "arm.c (thumb2_reorg): Add complete support for 16-bit instructions.\n\n2012-03-21  Andrew Stubbs  <ams@codesourcery.com>\n\n\tgcc/\n\t* config/arm/arm.c (thumb2_reorg): Add complete support\n\tfor 16-bit instructions.\n\t* config/arm/thumb2.md: Delete obsolete flag-clobbering peepholes.\n\n\tgcc/testsuite/\n\t* gcc.target/arm/thumb-16bit-ops.c: New file.\n\t* gcc.target/arm/thumb-ifcvt.c: New file.\n\nFrom-SVN: r185601", "tree": {"sha": "15e4126fd368565bddf08535387180334c3bf73e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15e4126fd368565bddf08535387180334c3bf73e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/021afdb4bb91341e19f573948d5ebb5b4efff814", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/021afdb4bb91341e19f573948d5ebb5b4efff814", "html_url": "https://github.com/Rust-GCC/gccrs/commit/021afdb4bb91341e19f573948d5ebb5b4efff814", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/021afdb4bb91341e19f573948d5ebb5b4efff814/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "50eeef0975bf57ba5c1d5f1da1c74fbc09de6473", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50eeef0975bf57ba5c1d5f1da1c74fbc09de6473", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50eeef0975bf57ba5c1d5f1da1c74fbc09de6473"}], "stats": {"total": 491, "additions": 355, "deletions": 136}, "files": [{"sha": "444ddc2f3576e5681870228329f11c3b5ead341d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/021afdb4bb91341e19f573948d5ebb5b4efff814/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/021afdb4bb91341e19f573948d5ebb5b4efff814/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=021afdb4bb91341e19f573948d5ebb5b4efff814", "patch": "@@ -1,3 +1,9 @@\n+2012-03-21  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* config/arm/arm.c (thumb2_reorg): Add complete support\n+\tfor 16-bit instructions.\n+\t* config/arm/thumb2.md: Delete obsolete flag-clobbering peepholes.\n+\n 2012-03-21  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimizer/52636"}, {"sha": "9af66dd8ace6c952428bc5f604f60a6444b49be8", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 129, "deletions": 28, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/021afdb4bb91341e19f573948d5ebb5b4efff814/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/021afdb4bb91341e19f573948d5ebb5b4efff814/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=021afdb4bb91341e19f573948d5ebb5b4efff814", "patch": "@@ -13300,47 +13300,148 @@ thumb2_reorg (void)\n       FOR_BB_INSNS_REVERSE (bb, insn)\n \t{\n \t  if (NONJUMP_INSN_P (insn)\n-\t      && !REGNO_REG_SET_P (&live, CC_REGNUM))\n+\t      && !REGNO_REG_SET_P (&live, CC_REGNUM)\n+\t      && GET_CODE (PATTERN (insn)) == SET)\n \t    {\n+\t      enum {SKIP, CONV, SWAP_CONV} action = SKIP;\n \t      rtx pat = PATTERN (insn);\n-\t      if (GET_CODE (pat) == SET\n-\t\t  && low_register_operand (XEXP (pat, 0), SImode)\n-\t\t  && thumb_16bit_operator (XEXP (pat, 1), SImode)\n-\t\t  && low_register_operand (XEXP (XEXP (pat, 1), 0), SImode)\n-\t\t  && low_register_operand (XEXP (XEXP (pat, 1), 1), SImode))\n+\t      rtx dst = XEXP (pat, 0);\n+\t      rtx src = XEXP (pat, 1);\n+\t      rtx op0 = NULL_RTX, op1 = NULL_RTX;\n+\n+\t      if (!OBJECT_P (src))\n+\t\t  op0 = XEXP (src, 0);\n+\n+\t      if (BINARY_P (src))\n+\t\t  op1 = XEXP (src, 1);\n+\n+\t      if (low_register_operand (dst, SImode))\n \t\t{\n-\t\t  rtx dst = XEXP (pat, 0);\n-\t\t  rtx src = XEXP (pat, 1);\n-\t\t  rtx op0 = XEXP (src, 0);\n-\t\t  rtx op1 = (GET_RTX_CLASS (GET_CODE (src)) == RTX_COMM_ARITH\n-\t\t\t     ? XEXP (src, 1) : NULL);\n-\n-\t\t  if (rtx_equal_p (dst, op0)\n-\t\t      || GET_CODE (src) == PLUS || GET_CODE (src) == MINUS)\n+\t\t  switch (GET_CODE (src))\n \t\t    {\n-\t\t      rtx ccreg = gen_rtx_REG (CCmode, CC_REGNUM);\n-\t\t      rtx clobber = gen_rtx_CLOBBER (VOIDmode, ccreg);\n-\t\t      rtvec vec = gen_rtvec (2, pat, clobber);\n+\t\t    case PLUS:\n+\t\t      if (low_register_operand (op0, SImode))\n+\t\t\t{\n+\t\t\t  /* ADDS <Rd>,<Rn>,<Rm>  */\n+\t\t\t  if (low_register_operand (op1, SImode))\n+\t\t\t    action = CONV;\n+\t\t\t  /* ADDS <Rdn>,#<imm8>  */\n+\t\t\t  /* SUBS <Rdn>,#<imm8>  */\n+\t\t\t  else if (rtx_equal_p (dst, op0)\n+\t\t\t\t   && CONST_INT_P (op1)\n+\t\t\t\t   && IN_RANGE (INTVAL (op1), -255, 255))\n+\t\t\t    action = CONV;\n+\t\t\t  /* ADDS <Rd>,<Rn>,#<imm3>  */\n+\t\t\t  /* SUBS <Rd>,<Rn>,#<imm3>  */\n+\t\t\t  else if (CONST_INT_P (op1)\n+\t\t\t\t   && IN_RANGE (INTVAL (op1), -7, 7))\n+\t\t\t    action = CONV;\n+\t\t\t}\n+\t\t      break;\n+\n+\t\t    case MINUS:\n+\t\t      /* RSBS <Rd>,<Rn>,#0  \n+\t\t\t Not handled here: see NEG below.  */\n+\t\t      /* SUBS <Rd>,<Rn>,#<imm3>\n+\t\t\t SUBS <Rdn>,#<imm8>\n+\t\t\t Not handled here: see PLUS above.  */\n+\t\t      /* SUBS <Rd>,<Rn>,<Rm>  */\n+\t\t      if (low_register_operand (op0, SImode)\n+\t\t\t  && low_register_operand (op1, SImode))\n+\t\t\t    action = CONV;\n+\t\t      break;\n+\n+\t\t    case MULT:\n+\t\t      /* MULS <Rdm>,<Rn>,<Rdm>\n+\t\t\t As an exception to the rule, this is only used\n+\t\t\t when optimizing for size since MULS is slow on all\n+\t\t\t known implementations.  We do not even want to use\n+\t\t\t MULS in cold code, if optimizing for speed, so we\n+\t\t\t test the global flag here.  */\n+\t\t      if (!optimize_size)\n+\t\t\tbreak;\n+\t\t      /* else fall through.  */\n+\t\t    case AND:\n+\t\t    case IOR:\n+\t\t    case XOR:\n+\t\t      /* ANDS <Rdn>,<Rm>  */\n+\t\t      if (rtx_equal_p (dst, op0)\n+\t\t\t  && low_register_operand (op1, SImode))\n+\t\t\taction = CONV;\n+\t\t      else if (rtx_equal_p (dst, op1)\n+\t\t\t       && low_register_operand (op0, SImode))\n+\t\t\taction = SWAP_CONV;\n+\t\t      break;\n+\n+\t\t    case ASHIFTRT:\n+\t\t    case ASHIFT:\n+\t\t    case LSHIFTRT:\n+\t\t      /* ASRS <Rdn>,<Rm> */\n+\t\t      /* LSRS <Rdn>,<Rm> */\n+\t\t      /* LSLS <Rdn>,<Rm> */\n+\t\t      if (rtx_equal_p (dst, op0)\n+\t\t\t  && low_register_operand (op1, SImode))\n+\t\t\taction = CONV;\n+\t\t      /* ASRS <Rd>,<Rm>,#<imm5> */\n+\t\t      /* LSRS <Rd>,<Rm>,#<imm5> */\n+\t\t      /* LSLS <Rd>,<Rm>,#<imm5> */\n+\t\t      else if (low_register_operand (op0, SImode)\n+\t\t\t       && CONST_INT_P (op1)\n+\t\t\t       && IN_RANGE (INTVAL (op1), 0, 31))\n+\t\t\taction = CONV;\n+\t\t      break;\n+\n+\t\t    case ROTATERT:\n+\t\t      /* RORS <Rdn>,<Rm>  */\n+\t\t      if (rtx_equal_p (dst, op0)\n+\t\t\t  && low_register_operand (op1, SImode))\n+\t\t\taction = CONV;\n+\t\t      break;\n \n-\t\t      PATTERN (insn) = gen_rtx_PARALLEL (VOIDmode, vec);\n-\t\t      INSN_CODE (insn) = -1;\n+\t\t    case NOT:\n+\t\t    case NEG:\n+\t\t      /* MVNS <Rd>,<Rm>  */\n+\t\t      /* NEGS <Rd>,<Rm>  (a.k.a RSBS)  */\n+\t\t      if (low_register_operand (op0, SImode))\n+\t\t\taction = CONV;\n+\t\t      break;\n+\n+\t\t    case CONST_INT:\n+\t\t      /* MOVS <Rd>,#<imm8>  */\n+\t\t      if (CONST_INT_P (src)\n+\t\t\t  && IN_RANGE (INTVAL (src), 0, 255))\n+\t\t\taction = CONV;\n+\t\t      break;\n+\n+\t\t    case REG:\n+\t\t      /* MOVS and MOV<c> with registers have different\n+\t\t\t encodings, so are not relevant here.  */\n+\t\t      break;\n+\n+\t\t    default:\n+\t\t      break;\n \t\t    }\n-\t\t  /* We can also handle a commutative operation where the\n-\t\t     second operand matches the destination.  */\n-\t\t  else if (op1 && rtx_equal_p (dst, op1))\n-\t\t    {\n-\t\t      rtx ccreg = gen_rtx_REG (CCmode, CC_REGNUM);\n-\t\t      rtx clobber = gen_rtx_CLOBBER (VOIDmode, ccreg);\n-\t\t      rtvec vec;\n+\t\t}\n \n+\t      if (action != SKIP)\n+\t\t{\n+\t\t  rtx ccreg = gen_rtx_REG (CCmode, CC_REGNUM);\n+\t\t  rtx clobber = gen_rtx_CLOBBER (VOIDmode, ccreg);\n+\t\t  rtvec vec;\n+\n+\t\t  if (action == SWAP_CONV)\n+\t\t    {\n \t\t      src = copy_rtx (src);\n \t\t      XEXP (src, 0) = op1;\n \t\t      XEXP (src, 1) = op0;\n \t\t      pat = gen_rtx_SET (VOIDmode, dst, src);\n \t\t      vec = gen_rtvec (2, pat, clobber);\n-\t\t      PATTERN (insn) = gen_rtx_PARALLEL (VOIDmode, vec);\n-\t\t      INSN_CODE (insn) = -1;\n \t\t    }\n+\t\t  else /* action == CONV */\n+\t\t    vec = gen_rtvec (2, pat, clobber);\n+\n+\t\t  PATTERN (insn) = gen_rtx_PARALLEL (VOIDmode, vec);\n+\t\t  INSN_CODE (insn) = -1;\n \t\t}\n \t    }\n "}, {"sha": "337717efcf7d5b41d972f9719fd0e94bf86e1828", "filename": "gcc/config/arm/thumb2.md", "status": "modified", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/021afdb4bb91341e19f573948d5ebb5b4efff814/gcc%2Fconfig%2Farm%2Fthumb2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/021afdb4bb91341e19f573948d5ebb5b4efff814/gcc%2Fconfig%2Farm%2Fthumb2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb2.md?ref=021afdb4bb91341e19f573948d5ebb5b4efff814", "patch": "@@ -677,27 +677,6 @@\n    (set_attr \"length\" \"2\")]\n )\n \n-;; Similarly for 16-bit shift instructions\n-;; There is no 16-bit rotate by immediate instruction.\n-(define_peephole2\n-  [(set (match_operand:SI   0 \"low_register_operand\" \"\")\n-\t(match_operator:SI  3 \"shift_operator\"\n-\t [(match_operand:SI 1 \"low_register_operand\" \"\")\n-\t  (match_operand:SI 2 \"low_reg_or_int_operand\" \"\")]))]\n-  \"TARGET_THUMB2\n-   && peep2_regno_dead_p(0, CC_REGNUM)\n-   && (CONST_INT_P (operands[2]) || operands[1] == operands[0])\n-   && ((GET_CODE(operands[3]) != ROTATE && GET_CODE(operands[3]) != ROTATERT)\n-       || REG_P(operands[2]))\"\n-  [(parallel\n-    [(set (match_dup 0)\n-\t  (match_op_dup 3\n-\t   [(match_dup 1)\n-\t    (match_dup 2)]))\n-     (clobber (reg:CC CC_REGNUM))])]\n-  \"\"\n-)\n-\n (define_insn \"*thumb2_shiftsi3_short\"\n   [(set (match_operand:SI   0 \"low_register_operand\" \"=l,l\")\n \t(match_operator:SI  3 \"shift_operator\"\n@@ -716,20 +695,6 @@\n \t\t      (const_string \"alu_shift_reg\")))]\n )\n \n-;; 16-bit load immediate\n-(define_peephole2\n-  [(set (match_operand:QHSI 0 \"low_register_operand\" \"\")\n-\t(match_operand:QHSI 1 \"const_int_operand\" \"\"))]\n-  \"TARGET_THUMB2\n-   && peep2_regno_dead_p(0, CC_REGNUM)\n-   && (unsigned HOST_WIDE_INT) INTVAL(operands[1]) < 256\"\n-  [(parallel\n-    [(set (match_dup 0)\n-\t  (match_dup 1))\n-     (clobber (reg:CC CC_REGNUM))])]\n-  \"\"\n-)\n-\n (define_insn \"*thumb2_mov<mode>_shortim\"\n   [(set (match_operand:QHSI 0 \"low_register_operand\" \"=l\")\n \t(match_operand:QHSI 1 \"const_int_operand\" \"I\"))\n@@ -740,24 +705,6 @@\n    (set_attr \"length\" \"2\")]\n )\n \n-;; 16-bit add/sub immediate\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"low_register_operand\" \"\")\n-\t(plus:SI (match_operand:SI 1 \"low_register_operand\" \"\")\n-\t\t (match_operand:SI 2 \"const_int_operand\" \"\")))]\n-  \"TARGET_THUMB2\n-   && peep2_regno_dead_p(0, CC_REGNUM)\n-   && ((rtx_equal_p(operands[0], operands[1])\n-\t&& INTVAL(operands[2]) > -256 && INTVAL(operands[2]) < 256)\n-       || (INTVAL(operands[2]) > -8 && INTVAL(operands[2]) < 8))\"\n-  [(parallel\n-    [(set (match_dup 0)\n-\t  (plus:SI (match_dup 1)\n-\t\t   (match_dup 2)))\n-     (clobber (reg:CC CC_REGNUM))])]\n-  \"\"\n-)\n-\n (define_insn \"*thumb2_addsi_short\"\n   [(set (match_operand:SI 0 \"low_register_operand\" \"=l,l\")\n \t(plus:SI (match_operand:SI 1 \"low_register_operand\" \"l,0\")\n@@ -869,35 +816,6 @@\n    (set_attr \"length\" \"2,4\")]\n )\n \n-;; 16-bit encodings of \"muls\" and \"mul<c>\".  We only use these when\n-;; optimizing for size since \"muls\" is slow on all known\n-;; implementations and since \"mul<c>\" will be generated by\n-;; \"*arm_mulsi3_v6\" anyhow.  The assembler will use a 16-bit encoding\n-;; for \"mul<c>\" whenever possible anyhow.\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"low_register_operand\" \"\")\n-        (mult:SI (match_operand:SI 1 \"low_register_operand\" \"\")\n-                 (match_dup 0)))]\n-  \"TARGET_THUMB2 && optimize_size && peep2_regno_dead_p (0, CC_REGNUM)\"\n-  [(parallel\n-    [(set (match_dup 0)\n-           (mult:SI (match_dup 0) (match_dup 1)))\n-     (clobber (reg:CC CC_REGNUM))])]\n-  \"\"\n-)\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"low_register_operand\" \"\")\n-        (mult:SI (match_dup 0)\n-\t         (match_operand:SI 1 \"low_register_operand\" \"\")))]\n-  \"TARGET_THUMB2 && optimize_size && peep2_regno_dead_p (0, CC_REGNUM)\"\n-  [(parallel\n-    [(set (match_dup 0)\n-           (mult:SI (match_dup 0) (match_dup 1)))\n-     (clobber (reg:CC CC_REGNUM))])]\n-  \"\"\n-)\n-\n (define_insn \"*thumb2_mulsi_short\"\n   [(set (match_operand:SI 0 \"low_register_operand\" \"=l\")\n         (mult:SI (match_operand:SI 1 \"low_register_operand\" \"%0\")\n@@ -980,19 +898,6 @@\n \t    (const_int 8)))]\n )\n \n-;; 16-bit complement\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"low_register_operand\" \"\")\n-\t(not:SI (match_operand:SI 1 \"low_register_operand\" \"\")))]\n-  \"TARGET_THUMB2\n-   && peep2_regno_dead_p(0, CC_REGNUM)\"\n-  [(parallel\n-    [(set (match_dup 0)\n-\t  (not:SI (match_dup 1)))\n-     (clobber (reg:CC CC_REGNUM))])]\n-  \"\"\n-)\n-\n (define_insn \"*thumb2_one_cmplsi2_short\"\n   [(set (match_operand:SI 0 \"low_register_operand\" \"=l\")\n \t(not:SI (match_operand:SI 1 \"low_register_operand\" \"l\")))\n@@ -1003,19 +908,6 @@\n    (set_attr \"length\" \"2\")]\n )\n \n-;; 16-bit negate\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"low_register_operand\" \"\")\n-\t(neg:SI (match_operand:SI 1 \"low_register_operand\" \"\")))]\n-  \"TARGET_THUMB2\n-   && peep2_regno_dead_p(0, CC_REGNUM)\"\n-  [(parallel\n-    [(set (match_dup 0)\n-\t  (neg:SI (match_dup 1)))\n-     (clobber (reg:CC CC_REGNUM))])]\n-  \"\"\n-)\n-\n (define_insn \"*thumb2_negsi2_short\"\n   [(set (match_operand:SI 0 \"low_register_operand\" \"=l\")\n \t(neg:SI (match_operand:SI 1 \"low_register_operand\" \"l\")))"}, {"sha": "a640b1365f20f975ee3183e14226099f342bca50", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/021afdb4bb91341e19f573948d5ebb5b4efff814/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/021afdb4bb91341e19f573948d5ebb5b4efff814/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=021afdb4bb91341e19f573948d5ebb5b4efff814", "patch": "@@ -1,3 +1,8 @@\n+2012-03-21  Andrew Stubbs  <ams@codesourcery.com>\n+\n+\t* gcc.target/arm/thumb-16bit-ops.c: New file.\n+\t* gcc.target/arm/thumb-ifcvt.c: New file.\n+\n 2012-03-20  Jason Merrill  <jason@redhat.com>\n \n \t* lib/target-supports.exp: Add { target c++1y }."}, {"sha": "2b712380bf22c26ec0908aba494acad501d83d1c", "filename": "gcc/testsuite/gcc.target/arm/thumb-16bit-ops.c", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/021afdb4bb91341e19f573948d5ebb5b4efff814/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fthumb-16bit-ops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/021afdb4bb91341e19f573948d5ebb5b4efff814/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fthumb-16bit-ops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fthumb-16bit-ops.c?ref=021afdb4bb91341e19f573948d5ebb5b4efff814", "patch": "@@ -0,0 +1,196 @@\n+/* Check that the compiler properly uses 16-bit encodings where available.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_thumb2_ok } */\n+/* { dg-options \"-Os -fno-builtin\" } */\n+\n+int\n+f (int a, int b )\n+{\n+  return a + b;\n+}\n+\n+/* { dg-final { scan-assembler \"adds\tr0, r0, r1\" } } */\n+\n+int\n+g1 (int a)\n+{\n+  return a + 255;\n+}\n+\n+/* { dg-final { scan-assembler \"adds\tr0, r0, #255\" } } */\n+\n+int\n+g2 (int a)\n+{\n+  return a + 256;\n+}\n+\n+/* { dg-final { scan-assembler \"add\tr0, r0, #256\" } } */\n+\n+int\n+g3 (int a)\n+{\n+  return a - 255;\n+}\n+\n+/* { dg-final { scan-assembler \"subs\tr0, r0, #255\" } } */\n+\n+int\n+g4 (int a)\n+{\n+  return a - 256;\n+}\n+\n+/* { dg-final { scan-assembler \"sub\tr0, r0, #256\" } } */\n+\n+int\n+h1 (int a, int b)\n+{\n+  return b + 7;\n+}\n+\n+/* { dg-final { scan-assembler \"adds\tr0, r1, #7\" } } */\n+\n+int\n+h2 (int a, int b)\n+{\n+  return b + 8;\n+}\n+\n+/* { dg-final { scan-assembler \"add\tr0, r1, #8\" } } */\n+\n+int\n+h3 (int a, int b)\n+{\n+  return b - 7;\n+}\n+\n+/* { dg-final { scan-assembler \"subs\tr0, r1, #7\" } } */\n+\n+int\n+h4 (int a, int b)\n+{\n+  return b - 8;\n+}\n+\n+/* { dg-final { scan-assembler \"sub\tr0, r1, #8\" } } */\n+\n+int\n+i (int a, int b)\n+{\n+  return b;\n+}\n+\n+/* { dg-final { scan-assembler \"mov\tr0, r1\" } } */\n+\n+int\n+j1 ()\n+{\n+  return 255;\n+}\n+\n+/* { dg-final { scan-assembler \"movs\tr0, #255\" } } */\n+\n+int\n+j2 ()\n+{\n+  return 256;\n+}\n+\n+/* { dg-final { scan-assembler \"mov\tr0, #256\" } } */\n+\n+int\n+k (int a, int b)\n+{\n+  return b << 15;\n+}\n+\n+/* { dg-final { scan-assembler \"lsls\tr0, r1, #15\" } } */\n+\n+int\n+l1 (int a, int b)\n+{\n+  return a << b;\n+}\n+\n+/* { dg-final { scan-assembler \"lsls\tr0, r0, r1\" } } */\n+\n+int\n+l2 (int a, int b, int c)\n+{\n+  return b << c;\n+}\n+\n+/* { dg-final { scan-assembler \"lsl\tr0, r1, r2\" } } */\n+\n+int\n+m (int a, int b)\n+{\n+  return b >> 15;\n+}\n+\n+/* { dg-final { scan-assembler \"asrs\tr0, r1, #15\" } } */\n+\n+int\n+n1 (int a, int b)\n+{\n+  return a >> b;\n+}\n+\n+/* { dg-final { scan-assembler \"asrs\tr0, r0, r1\" } } */\n+\n+int\n+n2 (int a, int b, int c)\n+{\n+  return b >> c;\n+}\n+\n+/* { dg-final { scan-assembler \"asr\tr0, r1, r2\" } } */\n+\n+unsigned int\n+o (unsigned int a, unsigned int b)\n+{\n+  return b >> 15;\n+}\n+\n+/* { dg-final { scan-assembler \"lsrs\tr0, r1, #15\" } } */\n+\n+unsigned int\n+p1 (unsigned int a, unsigned int b)\n+{\n+  return a >> b;\n+}\n+\n+/* { dg-final { scan-assembler \"lsrs\tr0, r0, r1\" } } */\n+\n+unsigned int\n+p2 (unsigned int a, unsigned int b, unsigned int c)\n+{\n+  return b >> c;\n+}\n+\n+/* { dg-final { scan-assembler \"lsr\tr0, r1, r2\" } } */\n+\n+int\n+q (int a, int b)\n+{\n+  return b * a;\n+}\n+\n+/* { dg-final { scan-assembler \"muls\tr0, r1, r0\" } } */\n+\n+int\n+r (int a, int b)\n+{\n+  return ~b;\n+}\n+\n+/* { dg-final { scan-assembler \"mvns\tr0, r1\" } } */\n+\n+int\n+s (int a, int b)\n+{\n+  return -b;\n+}\n+\n+/* { dg-final { scan-assembler \"negs\tr0, r1\" } } */"}, {"sha": "b03bbce77fe14cc8c98dc64649682b7f088032a9", "filename": "gcc/testsuite/gcc.target/arm/thumb-ifcvt.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/021afdb4bb91341e19f573948d5ebb5b4efff814/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fthumb-ifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/021afdb4bb91341e19f573948d5ebb5b4efff814/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fthumb-ifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fthumb-ifcvt.c?ref=021afdb4bb91341e19f573948d5ebb5b4efff814", "patch": "@@ -0,0 +1,19 @@\n+/* Check that Thumb 16-bit shifts can be if-converted.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_thumb2_ok } */\n+/* { dg-options \"-O2\" } */\n+\n+int\n+foo (int a, int b)\n+{\n+  if (a != b)\n+    {\n+      a = a << b;\n+      a = a >> 1;\n+    }\n+\n+  return a + b;\n+}\n+\n+/* { dg-final { scan-assembler \"lslne\" } } */\n+/* { dg-final { scan-assembler \"asrne\" } } */"}]}