{"sha": "3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZkMmIwMDc1ZTZjN2I3ZTliNGNlMTFkMmNkMzg5NjVhMzZlNDQ4Yw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-05-11T18:38:10Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-05-11T18:38:10Z"}, "message": "predicates.md (quad_memory_operand): Move most of the code into quad_address_p and call it to share code with...\n\n[gcc]\n2016-05-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/predicates.md (quad_memory_operand): Move most of\n\tthe code into quad_address_p and call it to share code with\n\tvsx_quad_dform_memory_operand.\n\t(vsx_quad_dform_memory_operand): New predicate for ISA 3.0 vector\n\td-form support.\n\t* config/rs6000/rs6000.opt (-mlra): Switch to being an option mask\n\tbit instead of being a separate word.  Split -mpower9-dform into\n\ttwo switches, -mpower9-dform-scalar and -mpower9-dform-vector.\n\t* config/rs6000/rs6000.c (RELOAD_REG_QUAD_OFFSET): New addr_mask\n\tfor the register class supporting 128-bit quad word memory\n\toffsets.\n\t(mode_supports_vsx_dform_quad): Helper function to return if the\n\tregister class uses quad word memory offsets.\n\t(rs6000_debug_addr_mask): Add support for quad word memory\n\toffsets.\n\t(rs6000_debug_reg_global): Always print if we are using LRA or\n\tnot.\n\t(rs6000_setup_reg_addr_masks): If ISA 3.0 vector d-form\n\tinstructions are enabled, set up the appropriate addr_masks for\n\t128-bit types.\n\t(rs6000_init_hard_regno_mode_ok): wb constraint is now based on\n\t-mpower9-dform-scalar, instead of -mpower9-dform.\n\t(rs6000_option_override_internal): Split -mpower9-dform into two\n\tswitches, -mpower9-dform-scalar and -mpower9-dform-vector.  The\n\t-mpower9-dform switch sets or clears both.  If we are not using\n\tthe LRA register allocator, do not enable -mpower9-dform-vector by\n\tdefault.  If we are using LRA, enable -mpower9-dform-vector and\n\t-mvsx-timode if it is appropriate.  Issue a warning if either\n\t-mpower9-dform-vector or -mvsx-timode are explicitly used without\n\tenabling LRA.\n\t(quad_address_offset_p): New helper function to return if the\n\toffset is legal for quad word memory instructions.\n\t(quad_address_p): New function to determin if GPR or vector\n\tregister quad word memory addresses are legal.\n\t(mem_operand_gpr): Validate quad word address offsets.\n\t(reg_offset_addressing_ok_p): Add support for ISA 3.0 vector\n\td-form (register + offset) instructions.\n\t(offsettable_ok_by_alignment): Likewise.\n\t(rs6000_legitimate_offset_address_p): Likewise.\n\t(legitimate_lo_sum_address_p): Likewise.\n\t(rs6000_legitimize_address): Likewise.\n\t(rs6000_legitimize_reload_address): Add more debug statements for\n\t-mdebug=addr.\n\t(rs6000_legitimate_address_p): Add support for ISA 3.0 vector\n\td-form instructions.\n\t(rs6000_secondary_reload_memory): Add support for ISA 3.0 vector\n\td-form instructions.  Distinguish different cases in debug\n\toutput.\t(rs6000_secondary_reload_inner): Add support for ISA 3.0 vector\n\td-form instructions.\n\t(rs6000_preferred_reload_class): Likewise.\n\t(rs6000_output_move_128bit): Add support for ISA 3.0 d-form\n\tinstructions.  If ISA 3.0 is available, generate lxvx/stxvx instead\n\tof the ISA 2.06 indexed memory instructions.\n\t(rs6000_emit_prologue): If we have ISA 3.0 d-form instructions,\n\tuse them to save/restore the saved vector registers instead of\n\tusing Altivec instructions.\n\t(rs6000_emit_epilogue): Likewise.\n\t(rs6000_lra_p): Use TARGET_LRA instead of the old option word.\n\t(rs6000_opt_masks): Split -mpower9-dform into\n\t-mpower9-dform-scalar and -mpower9-dform-vector.\n\t(rs6000_print_options_internal): Print -mno-<switch> if <switch>\n\twas not selected.\n\t* config/rs6000/vsx.md (p9_vecload_<mode>): Delete hack to emit\n\tISA 3.0 vector indexed memory instructions, and fold the code into\n\tthe normal mov<mode> patterns.\n\t(p9_vecstore_<mode>): Likewise.\n\t(vsx_mov<mode>): Add support for ISA 3.0 vector d-form\n\tinstructions.\n\t(vsx_movti_64bit): Likewise.\n\t(vsx_movti_32bit): Likewise.\n\t* config/rs6000/constraints.md (wO constraint): New constraint for\n\tISA 3.0 vector d-form support.\n\t* config/rs6000/rs6000-cpus.def (ISA_3_0_MASKS_SERVER): Use\n\t-mpower9-dform-scalar instead of -mpower9-dform.  Add note not to\n\tinclude -mpower9-dform-vector until we switch over to LRA.\n\t(POWERPC_MASKS): Add -mlra. Split -mpower9-dform into two. \n\tswitches, -mpower9-dform-scalar and -mpower9-dform-vector.\n\t* config/rs6000/rs6000-protos.h (quad_address_p): Add declaration.\n\t* doc/invoke.texi (RS/6000 and PowerPC Options): Add documentation\n\tfor -mpower9-dform and -mlra.\n\t* doc/md.texi (wO constraint): Document wO constraint.\n\n[gcc/testsuite]\n2016-05-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/dform-3.c: New test for ISA 3.0 vector d-form\n\tsupport.\n\t* gcc.target/powerpc/dform-1.c: Add -mlra option to silence\n\twarning when using -mvsx-timode.\n\t* gcc.target/powerpc/p8vector-int128-1.c: Likewise.\n\t* gcc.target/powerpc/dform-2.c: Likewise.\n\t* gcc.target/powerpc/pr68805.c: Likewise.\n\nFrom-SVN: r236133", "tree": {"sha": "a4551a7e47df556e71aa0a1d17bb37759f7e3412", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4551a7e47df556e71aa0a1d17bb37759f7e3412"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/comments", "author": null, "committer": null, "parents": [{"sha": "d8aecc553d987a25393661eb961c745cc7e800a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8aecc553d987a25393661eb961c745cc7e800a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8aecc553d987a25393661eb961c745cc7e800a0"}], "stats": {"total": 816, "additions": 636, "deletions": 180}, "files": [{"sha": "88f92359955e81248170e29ce8b66028c17dde2f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "patch": "@@ -1,3 +1,87 @@\n+2016-05-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/predicates.md (quad_memory_operand): Move most of\n+\tthe code into quad_address_p and call it to share code with\n+\tvsx_quad_dform_memory_operand.\n+\t(vsx_quad_dform_memory_operand): New predicate for ISA 3.0 vector\n+\td-form support.\n+\t* config/rs6000/rs6000.opt (-mlra): Switch to being an option mask\n+\tbit instead of being a separate word.  Split -mpower9-dform into\n+\ttwo switches, -mpower9-dform-scalar and -mpower9-dform-vector.\n+\t* config/rs6000/rs6000.c (RELOAD_REG_QUAD_OFFSET): New addr_mask\n+\tfor the register class supporting 128-bit quad word memory\n+\toffsets.\n+\t(mode_supports_vsx_dform_quad): Helper function to return if the\n+\tregister class uses quad word memory offsets.\n+\t(rs6000_debug_addr_mask): Add support for quad word memory\n+\toffsets.\n+\t(rs6000_debug_reg_global): Always print if we are using LRA or\n+\tnot.\n+\t(rs6000_setup_reg_addr_masks): If ISA 3.0 vector d-form\n+\tinstructions are enabled, set up the appropriate addr_masks for\n+\t128-bit types.\n+\t(rs6000_init_hard_regno_mode_ok): wb constraint is now based on\n+\t-mpower9-dform-scalar, instead of -mpower9-dform.\n+\t(rs6000_option_override_internal): Split -mpower9-dform into two\n+\tswitches, -mpower9-dform-scalar and -mpower9-dform-vector.  The\n+\t-mpower9-dform switch sets or clears both.  If we are not using\n+\tthe LRA register allocator, do not enable -mpower9-dform-vector by\n+\tdefault.  If we are using LRA, enable -mpower9-dform-vector and\n+\t-mvsx-timode if it is appropriate.  Issue a warning if either\n+\t-mpower9-dform-vector or -mvsx-timode are explicitly used without\n+\tenabling LRA.\n+\t(quad_address_offset_p): New helper function to return if the\n+\toffset is legal for quad word memory instructions.\n+\t(quad_address_p): New function to determin if GPR or vector\n+\tregister quad word memory addresses are legal.\n+\t(mem_operand_gpr): Validate quad word address offsets.\n+\t(reg_offset_addressing_ok_p): Add support for ISA 3.0 vector\n+\td-form (register + offset) instructions.\n+\t(offsettable_ok_by_alignment): Likewise.\n+\t(rs6000_legitimate_offset_address_p): Likewise.\n+\t(legitimate_lo_sum_address_p): Likewise.\n+\t(rs6000_legitimize_address): Likewise.\n+\t(rs6000_legitimize_reload_address): Add more debug statements for\n+\t-mdebug=addr.\n+\t(rs6000_legitimate_address_p): Add support for ISA 3.0 vector\n+\td-form instructions.\n+\t(rs6000_secondary_reload_memory): Add support for ISA 3.0 vector\n+\td-form instructions.  Distinguish different cases in debug\n+\toutput.\t(rs6000_secondary_reload_inner): Add support for ISA 3.0 vector\n+\td-form instructions.\n+\t(rs6000_preferred_reload_class): Likewise.\n+\t(rs6000_output_move_128bit): Add support for ISA 3.0 d-form\n+\tinstructions.  If ISA 3.0 is available, generate lxvx/stxvx instead\n+\tof the ISA 2.06 indexed memory instructions.\n+\t(rs6000_emit_prologue): If we have ISA 3.0 d-form instructions,\n+\tuse them to save/restore the saved vector registers instead of\n+\tusing Altivec instructions.\n+\t(rs6000_emit_epilogue): Likewise.\n+\t(rs6000_lra_p): Use TARGET_LRA instead of the old option word.\n+\t(rs6000_opt_masks): Split -mpower9-dform into\n+\t-mpower9-dform-scalar and -mpower9-dform-vector.\n+\t(rs6000_print_options_internal): Print -mno-<switch> if <switch>\n+\twas not selected.\n+\t* config/rs6000/vsx.md (p9_vecload_<mode>): Delete hack to emit\n+\tISA 3.0 vector indexed memory instructions, and fold the code into\n+\tthe normal mov<mode> patterns.\n+\t(p9_vecstore_<mode>): Likewise.\n+\t(vsx_mov<mode>): Add support for ISA 3.0 vector d-form\n+\tinstructions.\n+\t(vsx_movti_64bit): Likewise.\n+\t(vsx_movti_32bit): Likewise.\n+\t* config/rs6000/constraints.md (wO constraint): New constraint for\n+\tISA 3.0 vector d-form support.\n+\t* config/rs6000/rs6000-cpus.def (ISA_3_0_MASKS_SERVER): Use\n+\t-mpower9-dform-scalar instead of -mpower9-dform.  Add note not to\n+\tinclude -mpower9-dform-vector until we switch over to LRA.\n+\t(POWERPC_MASKS): Add -mlra. Split -mpower9-dform into two. \n+\tswitches, -mpower9-dform-scalar and -mpower9-dform-vector.\n+\t* config/rs6000/rs6000-protos.h (quad_address_p): Add declaration.\n+\t* doc/invoke.texi (RS/6000 and PowerPC Options): Add documentation\n+\tfor -mpower9-dform and -mlra.\n+\t* doc/md.texi (wO constraint): Document wO constraint.\n+\n 2016-05-11  Alexander Monakov  <amonakov@ispras.ru>\n \n \t* genattr.c (main): Change 'rtx' to 'rtx_insn *' in prototypes of"}, {"sha": "a3abe6ab80a762a5c73aaff21322d242be3b591b", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "patch": "@@ -156,6 +156,11 @@\n        (and (match_test \"TARGET_DIRECT_MOVE_128\")\n \t    (match_test \"(ival == VECTOR_ELEMENT_MFVSRLD_64BIT)\"))))\n \n+;; ISA 3.0 vector d-form addresses\n+(define_memory_constraint \"wO\"\n+  \"Memory operand suitable for the ISA 3.0 vector d-form instructions.\"\n+  (match_operand 0 \"vsx_quad_dform_memory_operand\"))\n+\n ;; Lq/stq validates the address for load/store quad\n (define_memory_constraint \"wQ\"\n   \"Memory operand suitable for the load/store quad instructions\""}, {"sha": "ebc924673445c13cfba3cef64c1694149dce8a2b", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 14, "deletions": 37, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "patch": "@@ -691,48 +691,25 @@\n (define_predicate \"quad_memory_operand\"\n   (match_code \"mem\")\n {\n-  rtx addr, op0, op1;\n-  int ret;\n-\n   if (!TARGET_QUAD_MEMORY && !TARGET_SYNC_TI)\n-    ret = 0;\n-\n-  else if (!memory_operand (op, mode))\n-    ret = 0;\n-\n-  else if (GET_MODE_SIZE (GET_MODE (op)) != 16)\n-    ret = 0;\n-\n-  else if (MEM_ALIGN (op) < 128)\n-    ret = 0;\n-\n-  else\n-    {\n-      addr = XEXP (op, 0);\n-      if (int_reg_operand (addr, Pmode))\n-\tret = 1;\n+    return false;\n \n-      else if (GET_CODE (addr) != PLUS)\n-\tret = 0;\n+  if (GET_MODE_SIZE (mode) != 16 || !MEM_P (op) || MEM_ALIGN (op) < 128)\n+    return false;\n \n-      else\n-\t{\n-\t  op0 = XEXP (addr, 0);\n-\t  op1 = XEXP (addr, 1);\n-\t  ret = (int_reg_operand (op0, Pmode)\n-\t\t && GET_CODE (op1) == CONST_INT\n-\t\t && IN_RANGE (INTVAL (op1), -32768, 32767)\n-\t\t && (INTVAL (op1) & 15) == 0);\n-\t}\n-    }\n+  return quad_address_p (XEXP (op, 0), mode, true);\n+})\n \n-  if (TARGET_DEBUG_ADDR)\n-    {\n-      fprintf (stderr, \"\\nquad_memory_operand, ret = %s\\n\", ret ? \"true\" : \"false\");\n-      debug_rtx (op);\n-    }\n+;; Return 1 if the operand is suitable for load/store to vector registers with\n+;; d-form addressing (register+offset), which was added in ISA 3.0.\n+;; Unlike quad_memory_operand, we do not have to check for alignment.\n+(define_predicate \"vsx_quad_dform_memory_operand\"\n+  (match_code \"mem\")\n+{\n+  if (!TARGET_P9_DFORM_VECTOR || !MEM_P (op) || GET_MODE_SIZE (mode) != 16)\n+    return false;\n \n-  return ret;\n+  return quad_address_p (XEXP (op, 0), mode, false);\n })\n \n ;; Return 1 if the operand is an indexed or indirect memory operand."}, {"sha": "27239f1d3718d0c4c65ff71a67ac5a6660ae91bc", "filename": "gcc/config/rs6000/rs6000-cpus.def", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-cpus.def?ref=3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "patch": "@@ -60,13 +60,14 @@\n \t\t\t\t | OPTION_MASK_UPPER_REGS_SF)\n \n /* Add ISEL back into ISA 3.0, since it is supposed to be a win.  Do not add\n-   P9_DFORM or P9_MINMAX until they are fully debugged.  */\n+   P9_MINMAX until the hardware that supports it is available. Do not add\n+   P9_DFORM_VECTOR until LRA is the default register allocator.  */\n #define ISA_3_0_MASKS_SERVER\t(ISA_2_7_MASKS_SERVER\t\t\t\\\n \t\t\t\t | OPTION_MASK_FLOAT128_HW\t\t\\\n \t\t\t\t | OPTION_MASK_ISEL\t\t\t\\\n \t\t\t\t | OPTION_MASK_MODULO\t\t\t\\\n \t\t\t\t | OPTION_MASK_P9_FUSION\t\t\\\n-\t\t\t\t | OPTION_MASK_P9_DFORM\t\t\t\\\n+\t\t\t\t | OPTION_MASK_P9_DFORM_SCALAR\t\t\\\n \t\t\t\t | OPTION_MASK_P9_VECTOR)\n \n #define POWERPC_7400_MASK\t(OPTION_MASK_PPC_GFXOPT | OPTION_MASK_ALTIVEC)\n@@ -94,14 +95,16 @@\n \t\t\t\t | OPTION_MASK_FPRND\t\t\t\\\n \t\t\t\t | OPTION_MASK_HTM\t\t\t\\\n \t\t\t\t | OPTION_MASK_ISEL\t\t\t\\\n+\t\t\t\t | OPTION_MASK_LRA\t\t\t\\\n \t\t\t\t | OPTION_MASK_MFCRF\t\t\t\\\n \t\t\t\t | OPTION_MASK_MFPGPR\t\t\t\\\n \t\t\t\t | OPTION_MASK_MODULO\t\t\t\\\n \t\t\t\t | OPTION_MASK_MULHW\t\t\t\\\n \t\t\t\t | OPTION_MASK_NO_UPDATE\t\t\\\n \t\t\t\t | OPTION_MASK_P8_FUSION\t\t\\\n \t\t\t\t | OPTION_MASK_P8_VECTOR\t\t\\\n-\t\t\t\t | OPTION_MASK_P9_DFORM\t\t\t\\\n+\t\t\t\t | OPTION_MASK_P9_DFORM_SCALAR\t\t\\\n+\t\t\t\t | OPTION_MASK_P9_DFORM_VECTOR\t\t\\\n \t\t\t\t | OPTION_MASK_P9_FUSION\t\t\\\n \t\t\t\t | OPTION_MASK_P9_MINMAX\t\t\\\n \t\t\t\t | OPTION_MASK_P9_VECTOR\t\t\\"}, {"sha": "f75624f70d8ebe9bf4690d1073c25758263ea916", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "patch": "@@ -86,6 +86,7 @@ extern int registers_ok_for_quad_peep (rtx, rtx);\n extern int mems_ok_for_quad_peep (rtx, rtx);\n extern bool gpr_or_gpr_p (rtx, rtx);\n extern bool direct_move_p (rtx, rtx);\n+extern bool quad_address_p (rtx, machine_mode, bool);\n extern bool quad_load_store_p (rtx, rtx);\n extern bool fusion_gpr_load_p (rtx, rtx, rtx, rtx);\n extern void expand_fusion_gpr_load (rtx *);"}, {"sha": "3f721c67cd58576a72b3ccfa25f196190bf4b22c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 433, "deletions": 104, "changes": 537, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "patch": "@@ -452,6 +452,7 @@ typedef unsigned char addr_mask_type;\n #define RELOAD_REG_PRE_INCDEC\t0x10\t/* PRE_INC/PRE_DEC valid.  */\n #define RELOAD_REG_PRE_MODIFY\t0x20\t/* PRE_MODIFY valid.  */\n #define RELOAD_REG_AND_M16\t0x40\t/* AND -16 addressing.  */\n+#define RELOAD_REG_QUAD_OFFSET\t0x80\t/* quad offset is limited.  */\n \n /* Register type masks based on the type, of valid addressing modes.  */\n struct rs6000_reg_addr {\n@@ -499,6 +500,16 @@ mode_supports_vmx_dform (machine_mode mode)\n   return ((reg_addr[mode].addr_mask[RELOAD_REG_VMX] & RELOAD_REG_OFFSET) != 0);\n }\n \n+/* Return true if we have D-form addressing in VSX registers.  This addressing\n+   is more limited than normal d-form addressing in that the offset must be\n+   aligned on a 16-byte boundary.  */\n+static inline bool\n+mode_supports_vsx_dform_quad (machine_mode mode)\n+{\n+  return ((reg_addr[mode].addr_mask[RELOAD_REG_ANY] & RELOAD_REG_QUAD_OFFSET)\n+\t  != 0);\n+}\n+\n \f\n /* Target cpu costs.  */\n \n@@ -2111,7 +2122,9 @@ rs6000_debug_addr_mask (addr_mask_type mask, bool keep_spaces)\n   else if (keep_spaces)\n     *p++ = ' ';\n \n-  if ((mask & RELOAD_REG_OFFSET) != 0)\n+  if ((mask & RELOAD_REG_QUAD_OFFSET) != 0)\n+    *p++ = 'O';\n+  else if ((mask & RELOAD_REG_OFFSET) != 0)\n     *p++ = 'o';\n   else if (keep_spaces)\n     *p++ = ' ';\n@@ -2648,8 +2661,7 @@ rs6000_debug_reg_global (void)\n   if (TARGET_LINK_STACK)\n     fprintf (stderr, DEBUG_FMT_S, \"link_stack\", \"true\");\n \n-  if (targetm.lra_p ())\n-    fprintf (stderr, DEBUG_FMT_S, \"lra\", \"true\");\n+  fprintf (stderr, DEBUG_FMT_S, \"lra\", TARGET_LRA ? \"true\" : \"false\");\n \n   if (TARGET_P8_FUSION)\n     {\n@@ -2784,17 +2796,31 @@ rs6000_setup_reg_addr_masks (void)\n \t    }\n \n \t  /* GPR and FPR registers can do REG+OFFSET addressing, except\n-\t     possibly for SDmode.  ISA 3.0 (i.e. power9) adds D-form\n-\t     addressing for scalars to altivec registers.  */\n+\t     possibly for SDmode.  ISA 3.0 (i.e. power9) adds D-form addressing\n+\t     for 64-bit scalars and 32-bit SFmode to altivec registers.  */\n \t  if ((addr_mask != 0) && !indexed_only_p\n \t      && msize <= 8\n \t      && (rc == RELOAD_REG_GPR\n-\t\t  || rc == RELOAD_REG_FPR\n-\t\t  || (rc == RELOAD_REG_VMX\n-\t\t      && TARGET_P9_DFORM\n-\t\t      && (m2 == DFmode || m2 == SFmode))))\n+\t\t  || ((msize == 8 || m2 == SFmode)\n+\t\t      && (rc == RELOAD_REG_FPR\n+\t\t\t  || (rc == RELOAD_REG_VMX\n+\t\t\t      && TARGET_P9_DFORM_SCALAR)))))\n \t    addr_mask |= RELOAD_REG_OFFSET;\n \n+\t  /* VSX registers can do REG+OFFSET addresssing if ISA 3.0\n+\t     instructions are enabled.  The offset for 128-bit VSX registers is\n+\t     only 12-bits.  While GPRs can handle the full offset range, VSX\n+\t     registers can only handle the restricted range.  */\n+\t  else if ((addr_mask != 0) && !indexed_only_p\n+\t\t   && msize == 16 && TARGET_P9_DFORM_VECTOR\n+\t\t   && (ALTIVEC_OR_VSX_VECTOR_MODE (m2)\n+\t\t       || (m2 == TImode && TARGET_VSX_TIMODE)))\n+\t    {\n+\t      addr_mask |= RELOAD_REG_OFFSET;\n+\t      if (rc == RELOAD_REG_FPR || rc == RELOAD_REG_VMX)\n+\t\taddr_mask |= RELOAD_REG_QUAD_OFFSET;\n+\t    }\n+\n \t  /* VMX registers can do (REG & -16) and ((REG+REG) & -16)\n \t     addressing on 128-bit types.  */\n \t  if (rc == RELOAD_REG_VMX && msize == 16\n@@ -3117,7 +3143,7 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n     }\n \n   /* Support for new D-form instructions.  */\n-  if (TARGET_P9_DFORM)\n+  if (TARGET_P9_DFORM_SCALAR)\n     rs6000_constraints[RS6000_CONSTRAINT_wb] = ALTIVEC_REGS;\n \n   /* Support for ISA 3.0 (power9) vectors.  */\n@@ -3990,7 +4016,8 @@ rs6000_option_override_internal (bool global_init_p)\n \n   /* For the newer switches (vsx, dfp, etc.) set some of the older options,\n      unless the user explicitly used the -mno-<option> to disable the code.  */\n-  if (TARGET_P9_VECTOR || TARGET_MODULO || TARGET_P9_DFORM || TARGET_P9_MINMAX)\n+  if (TARGET_P9_VECTOR || TARGET_MODULO || TARGET_P9_DFORM_SCALAR\n+      || TARGET_P9_DFORM_VECTOR || TARGET_P9_DFORM_BOTH > 0 || TARGET_P9_MINMAX)\n     rs6000_isa_flags |= (ISA_3_0_MASKS_SERVER & ~rs6000_isa_flags_explicit);\n   else if (TARGET_P8_VECTOR || TARGET_DIRECT_MOVE || TARGET_CRYPTO)\n     rs6000_isa_flags |= (ISA_2_7_MASKS_SERVER & ~rs6000_isa_flags_explicit);\n@@ -4204,26 +4231,49 @@ rs6000_option_override_internal (bool global_init_p)\n       && !(rs6000_isa_flags_explicit & OPTION_MASK_TOC_FUSION))\n     rs6000_isa_flags |= OPTION_MASK_TOC_FUSION;\n \n+  /* -mpower9-dform turns on both -mpower9-dform-scalar and\n+      -mpower9-dform-vector. There are currently problems if\n+      -mpower9-dform-vector instructions are enabled when we use the RELOAD\n+      register allocator.  */\n+  if (TARGET_P9_DFORM_BOTH > 0)\n+    {\n+      if (!(rs6000_isa_flags_explicit & OPTION_MASK_P9_DFORM_VECTOR)\n+\t  && TARGET_LRA)\n+\trs6000_isa_flags |= OPTION_MASK_P9_DFORM_VECTOR;\n+\n+      if (!(rs6000_isa_flags_explicit & OPTION_MASK_P9_DFORM_SCALAR))\n+\trs6000_isa_flags |= OPTION_MASK_P9_DFORM_SCALAR;\n+    }\n+  else if (TARGET_P9_DFORM_BOTH == 0)\n+    {\n+      if (!(rs6000_isa_flags_explicit & OPTION_MASK_P9_DFORM_VECTOR))\n+\trs6000_isa_flags &= ~OPTION_MASK_P9_DFORM_VECTOR;\n+\n+      if (!(rs6000_isa_flags_explicit & OPTION_MASK_P9_DFORM_SCALAR))\n+\trs6000_isa_flags &= ~OPTION_MASK_P9_DFORM_SCALAR;\n+    }\n+\n   /* ISA 3.0 D-form instructions require p9-vector and upper-regs.  */\n-  if (TARGET_P9_DFORM && !TARGET_P9_VECTOR)\n+  if ((TARGET_P9_DFORM_SCALAR || TARGET_P9_DFORM_VECTOR) && !TARGET_P9_VECTOR)\n     {\n       if (rs6000_isa_flags_explicit & OPTION_MASK_P9_VECTOR)\n \terror (\"-mpower9-dform requires -mpower9-vector\");\n-      rs6000_isa_flags &= ~OPTION_MASK_P9_DFORM;\n+      rs6000_isa_flags &= ~(OPTION_MASK_P9_DFORM_SCALAR\n+\t\t\t    | OPTION_MASK_P9_DFORM_VECTOR);\n     }\n \n-  if (TARGET_P9_DFORM && !TARGET_UPPER_REGS_DF)\n+  if (TARGET_P9_DFORM_SCALAR && !TARGET_UPPER_REGS_DF)\n     {\n       if (rs6000_isa_flags_explicit & OPTION_MASK_UPPER_REGS_DF)\n \terror (\"-mpower9-dform requires -mupper-regs-df\");\n-      rs6000_isa_flags &= ~OPTION_MASK_P9_DFORM;\n+      rs6000_isa_flags &= ~OPTION_MASK_P9_DFORM_SCALAR;\n     }\n \n-  if (TARGET_P9_DFORM && !TARGET_UPPER_REGS_SF)\n+  if (TARGET_P9_DFORM_SCALAR && !TARGET_UPPER_REGS_SF)\n     {\n       if (rs6000_isa_flags_explicit & OPTION_MASK_UPPER_REGS_SF)\n \terror (\"-mpower9-dform requires -mupper-regs-sf\");\n-      rs6000_isa_flags &= ~OPTION_MASK_P9_DFORM;\n+      rs6000_isa_flags &= ~OPTION_MASK_P9_DFORM_SCALAR;\n     }\n \n   /* ISA 3.0 vector instructions include ISA 2.07.  */\n@@ -4234,6 +4284,47 @@ rs6000_option_override_internal (bool global_init_p)\n       rs6000_isa_flags &= ~OPTION_MASK_P9_VECTOR;\n     }\n \n+  /* There have been bugs with both -mvsx-timode and -mpower9-dform-vector that\n+     don't show up with -mlra, but do show up with -mno-lra.  Given -mlra will\n+     become the default once PR 69847 is fixed, turn off the options with\n+     problems by default if -mno-lra was used, and warn if the user explicitly\n+     asked for the option.\n+\n+     Enable -mpower9-dform-vector by default if LRA and other power9 options.\n+     Enable -mvsx-timode by default if LRA and VSX.  */\n+  if (!TARGET_LRA)\n+    {\n+      if (TARGET_VSX_TIMODE)\n+\t{\n+\t  if ((rs6000_isa_flags_explicit & OPTION_MASK_VSX_TIMODE) != 0)\n+\t    warning (0, \"-mvsx-timode might need -mlra\");\n+\n+\t  else\n+\t    rs6000_isa_flags &= ~OPTION_MASK_VSX_TIMODE;\n+\t}\n+\n+      if (TARGET_P9_DFORM_VECTOR)\n+\t{\n+\t  if ((rs6000_isa_flags_explicit & OPTION_MASK_P9_DFORM_VECTOR) != 0)\n+\t    warning (0, \"-mpower9-dform-vector might need -mlra\");\n+\n+\t  else\n+\t    rs6000_isa_flags &= ~OPTION_MASK_P9_DFORM_VECTOR;\n+\t}\n+    }\n+\n+  else\n+    {\n+      if (TARGET_VSX && !TARGET_VSX_TIMODE\n+\t  && (rs6000_isa_flags_explicit & OPTION_MASK_VSX_TIMODE) == 0)\n+\trs6000_isa_flags |= OPTION_MASK_VSX_TIMODE;\n+\n+      if (TARGET_VSX && TARGET_P9_VECTOR && !TARGET_P9_DFORM_VECTOR\n+\t  && TARGET_P9_DFORM_SCALAR && TARGET_P9_DFORM_BOTH < 0\n+\t  && (rs6000_isa_flags_explicit & OPTION_MASK_P9_DFORM_VECTOR) == 0)\n+\trs6000_isa_flags |= OPTION_MASK_P9_DFORM_VECTOR;\n+    }\n+\n   /* Set -mallow-movmisalign to explicitly on if we have full ISA 2.07\n      support. If we only have ISA 2.06 support, and the user did not specify\n      the switch, leave it set to -1 so the movmisalign patterns are enabled,\n@@ -6918,6 +7009,59 @@ direct_move_p (rtx op0, rtx op1)\n   return false;\n }\n \n+/* Return true if the OFFSET is valid for the quad address instructions that\n+   use d-form (register + offset) addressing.  */\n+\n+static inline bool\n+quad_address_offset_p (HOST_WIDE_INT offset)\n+{\n+  return (IN_RANGE (offset, -32768, 32767) && ((offset) & 0xf) == 0);\n+}\n+\n+/* Return true if the ADDR is an acceptable address for a quad memory\n+   operation of mode MODE (either LQ/STQ for general purpose registers, or\n+   LXV/STXV for vector registers under ISA 3.0.  GPR_P is true if this address\n+   is intended for LQ/STQ.  If it is false, the address is intended for the ISA\n+   3.0 LXV/STXV instruction.  */\n+\n+bool\n+quad_address_p (rtx addr, machine_mode mode, bool gpr_p)\n+{\n+  rtx op0, op1;\n+\n+  if (GET_MODE_SIZE (mode) != 16)\n+    return false;\n+\n+  if (gpr_p)\n+    {\n+      if (!TARGET_QUAD_MEMORY && !TARGET_SYNC_TI)\n+\treturn false;\n+\n+      /* LQ/STQ can handle indirect addresses.  */\n+      if (base_reg_operand (addr, Pmode))\n+\treturn true;\n+    }\n+\n+  else\n+    {\n+      if (!mode_supports_vsx_dform_quad (mode))\n+\treturn false;\n+    }\n+\n+  if (GET_CODE (addr) != PLUS)\n+    return false;\n+\n+  op0 = XEXP (addr, 0);\n+  if (!base_reg_operand (op0, Pmode))\n+    return false;\n+\n+  op1 = XEXP (addr, 1);\n+  if (!CONST_INT_P (op1))\n+    return false;\n+\n+  return quad_address_offset_p (INTVAL (op1));\n+}\n+\n /* Return true if this is a load or store quad operation.  This function does\n    not handle the atomic quad memory instructions.  */\n \n@@ -7010,6 +7154,10 @@ mem_operand_gpr (rtx op, machine_mode mode)\n   if (TARGET_POWERPC64 && (offset & 3) != 0)\n     return false;\n \n+  if (mode_supports_vsx_dform_quad (mode)\n+      && !quad_address_offset_p (offset))\n+    return false;\n+\n   extra = GET_MODE_SIZE (mode) - UNITS_PER_WORD;\n   if (extra < 0)\n     extra = 0;\n@@ -7039,13 +7187,14 @@ reg_offset_addressing_ok_p (machine_mode mode)\n     case TImode:\n     case TFmode:\n     case KFmode:\n-      /* AltiVec/VSX vector modes.  Only reg+reg addressing is valid.  While\n-\t TImode is not a vector mode, if we want to use the VSX registers to\n-\t move it around, we need to restrict ourselves to reg+reg addressing.\n-\t Similarly for IEEE 128-bit floating point that is passed in a single\n-\t vector register.  */\n+      /* AltiVec/VSX vector modes.  Only reg+reg addressing was valid until the\n+\t ISA 3.0 vector d-form addressing mode was added.  While TImode is not\n+\t a vector mode, if we want to use the VSX registers to move it around,\n+\t we need to restrict ourselves to reg+reg addressing.  Similarly for\n+\t IEEE 128-bit floating point that is passed in a single vector\n+\t register.  */\n       if (VECTOR_MEM_ALTIVEC_OR_VSX_P (mode))\n-\treturn false;\n+\treturn mode_supports_vsx_dform_quad (mode);\n       break;\n \n     case V4HImode:\n@@ -7112,6 +7261,11 @@ offsettable_ok_by_alignment (rtx op, HOST_WIDE_INT offset,\n   if (GET_CODE (op) != SYMBOL_REF)\n     return false;\n \n+  /* ISA 3.0 vector d-form addressing is restricted, don't allow\n+     SYMBOL_REF.  */\n+  if (mode_supports_vsx_dform_quad (mode))\n+    return false;\n+\n   dsize = GET_MODE_SIZE (mode);\n   decl = SYMBOL_REF_DECL (op);\n   if (!decl)\n@@ -7266,6 +7420,9 @@ rs6000_legitimate_offset_address_p (machine_mode mode, rtx x,\n     return false;\n   if (!INT_REG_OK_FOR_BASE_P (XEXP (x, 0), strict))\n     return false;\n+  if (mode_supports_vsx_dform_quad (mode))\n+    return (virtual_stack_registers_memory_p (x)\n+\t    || quad_address_p (x, mode, false));\n   if (!reg_offset_addressing_ok_p (mode))\n     return virtual_stack_registers_memory_p (x);\n   if (legitimate_constant_pool_address_p (x, mode, strict || lra_in_progress))\n@@ -7404,6 +7561,9 @@ legitimate_lo_sum_address_p (machine_mode mode, rtx x, int strict)\n     return false;\n   if (!INT_REG_OK_FOR_BASE_P (XEXP (x, 0), strict))\n     return false;\n+  /* quad word addresses are restricted, and we can't use LO_SUM.  */\n+  if (mode_supports_vsx_dform_quad (mode))\n+    return false;\n   /* Restrict addressing for DI because of our SUBREG hackery.  */\n   if (TARGET_E500_DOUBLE && GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n     return false;\n@@ -7415,7 +7575,7 @@ legitimate_lo_sum_address_p (machine_mode mode, rtx x, int strict)\n \n       if (DEFAULT_ABI == ABI_V4 && flag_pic)\n \treturn false;\n-      /* LRA don't use LEGITIMIZE_RELOAD_ADDRESS as it usually calls\n+      /* LRA doesn't use LEGITIMIZE_RELOAD_ADDRESS as it usually calls\n \t push_reload from reload pass code.  LEGITIMIZE_RELOAD_ADDRESS\n \t recognizes some LO_SUM addresses as valid although this\n \t function says opposite.  In most cases, LRA through different\n@@ -7469,7 +7629,8 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n {\n   unsigned int extra;\n \n-  if (!reg_offset_addressing_ok_p (mode))\n+  if (!reg_offset_addressing_ok_p (mode)\n+      || mode_supports_vsx_dform_quad (mode))\n     {\n       if (virtual_stack_registers_memory_p (x))\n \treturn x;\n@@ -8180,6 +8341,11 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n       && GET_CODE (XEXP (x, 1)) == CONST_INT)\n     {\n+      if (TARGET_DEBUG_ADDR)\n+\t{\n+\t  fprintf (stderr, \"\\nlegitimize_reload_address push_reload #1:\\n\");\n+\t  debug_rtx (x);\n+\t}\n       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n \t\t   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n \t\t   opnum, (enum reload_type) type);\n@@ -8191,6 +8357,11 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n   if (GET_CODE (x) == LO_SUM\n       && GET_CODE (XEXP (x, 0)) == HIGH)\n     {\n+      if (TARGET_DEBUG_ADDR)\n+\t{\n+\t  fprintf (stderr, \"\\nlegitimize_reload_address push_reload #2:\\n\");\n+\t  debug_rtx (x);\n+\t}\n       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n \t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n \t\t   opnum, (enum reload_type) type);\n@@ -8223,6 +8394,11 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n     {\n       rtx hi = gen_rtx_HIGH (Pmode, copy_rtx (x));\n       x = gen_rtx_LO_SUM (Pmode, hi, x);\n+      if (TARGET_DEBUG_ADDR)\n+\t{\n+\t  fprintf (stderr, \"\\nlegitimize_reload_address push_reload #3:\\n\");\n+\t  debug_rtx (x);\n+\t}\n       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n \t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n \t\t   opnum, (enum reload_type) type);\n@@ -8260,6 +8436,11 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n \t\t\t\t      GEN_INT (high)),\n \t\t\tGEN_INT (low));\n \n+      if (TARGET_DEBUG_ADDR)\n+\t{\n+\t  fprintf (stderr, \"\\nlegitimize_reload_address push_reload #4:\\n\");\n+\t  debug_rtx (x);\n+\t}\n       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n \t\t   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n \t\t   opnum, (enum reload_type) type);\n@@ -8320,6 +8501,11 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n \tx = gen_rtx_LO_SUM (GET_MODE (x),\n \t      gen_rtx_HIGH (Pmode, x), x);\n \n+      if (TARGET_DEBUG_ADDR)\n+\t{\n+\t  fprintf (stderr, \"\\nlegitimize_reload_address push_reload #5:\\n\");\n+\t  debug_rtx (x);\n+\t}\n       push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n \t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n \t\t   opnum, (enum reload_type) type);\n@@ -8353,9 +8539,16 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n     {\n       x = create_TOC_reference (x, NULL_RTX);\n       if (TARGET_CMODEL != CMODEL_SMALL)\n-\tpush_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n-\t\t     BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n-\t\t     opnum, (enum reload_type) type);\n+\t{\n+\t  if (TARGET_DEBUG_ADDR)\n+\t    {\n+\t      fprintf (stderr, \"\\nlegitimize_reload_address push_reload #6:\\n\");\n+\t      debug_rtx (x);\n+\t    }\n+\t  push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n+\t\t       BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n+\t\t       opnum, (enum reload_type) type);\n+\t}\n       *win = 1;\n       return x;\n     }\n@@ -8411,6 +8604,7 @@ static bool\n rs6000_legitimate_address_p (machine_mode mode, rtx x, bool reg_ok_strict)\n {\n   bool reg_offset_p = reg_offset_addressing_ok_p (mode);\n+  bool quad_offset_p = mode_supports_vsx_dform_quad (mode);\n \n   /* If this is an unaligned stvx/ldvx type address, discard the outer AND.  */\n   if (VECTOR_MEM_ALTIVEC_P (mode)\n@@ -8430,15 +8624,26 @@ rs6000_legitimate_address_p (machine_mode mode, rtx x, bool reg_ok_strict)\n     return 1;\n   if (virtual_stack_registers_memory_p (x))\n     return 1;\n-  if (reg_offset_p && legitimate_small_data_p (mode, x))\n-    return 1;\n-  if (reg_offset_p\n-      && legitimate_constant_pool_address_p (x, mode,\n+\n+  /* Handle restricted vector d-form offsets in ISA 3.0.  */\n+  if (quad_offset_p)\n+    {\n+      if (quad_address_p (x, mode, false))\n+\treturn 1;\n+    }\n+\n+  else if (reg_offset_p)\n+    {\n+      if (legitimate_small_data_p (mode, x))\n+\treturn 1;\n+      if (legitimate_constant_pool_address_p (x, mode,\n \t\t\t\t\t     reg_ok_strict || lra_in_progress))\n-    return 1;\n-  if (reg_offset_p && reg_addr[mode].fused_toc && GET_CODE (x) == UNSPEC\n-      && XINT (x, 1) == UNSPEC_FUSION_ADDIS)\n-    return 1;\n+\treturn 1;\n+      if (reg_addr[mode].fused_toc && GET_CODE (x) == UNSPEC\n+\t  && XINT (x, 1) == UNSPEC_FUSION_ADDIS)\n+\treturn 1;\n+    }\n+\n   /* For TImode, if we have load/store quad and TImode in VSX registers, only\n      allow register indirect addresses.  This will allow the values to go in\n      either GPRs or VSX registers without reloading.  The vector types would\n@@ -8477,7 +8682,8 @@ rs6000_legitimate_address_p (machine_mode mode, rtx x, bool reg_ok_strict)\n \t      && legitimate_indexed_address_p (XEXP (x, 1), reg_ok_strict)))\n       && rtx_equal_p (XEXP (XEXP (x, 1), 0), XEXP (x, 0)))\n     return 1;\n-  if (reg_offset_p && legitimate_lo_sum_address_p (mode, x, reg_ok_strict))\n+  if (reg_offset_p && !quad_offset_p\n+      && legitimate_lo_sum_address_p (mode, x, reg_ok_strict))\n     return 1;\n   return 0;\n }\n@@ -18423,13 +18629,23 @@ rs6000_secondary_reload_memory (rtx addr,\n \t    }\n \t}\n \n+      else if ((addr_mask & RELOAD_REG_QUAD_OFFSET) != 0\n+\t       && CONST_INT_P (plus_arg1))\n+\t{\n+\t  if (!quad_address_offset_p (INTVAL (plus_arg1)))\n+\t    {\n+\t      extra_cost = 1;\n+\t      type = \"vector d-form offset\";\n+\t    }\n+\t}\n+\n       /* Make sure the register class can handle offset addresses.  */\n       else if (rs6000_legitimate_offset_address_p (mode, addr, false, true))\n \t{\n \t  if ((addr_mask & RELOAD_REG_OFFSET) == 0)\n \t    {\n \t      extra_cost = 1;\n-\t      type = \"offset\";\n+\t      type = \"offset #2\";\n \t    }\n \t}\n \n@@ -18442,7 +18658,14 @@ rs6000_secondary_reload_memory (rtx addr,\n       break;\n \n     case LO_SUM:\n-      if (!legitimate_lo_sum_address_p (mode, addr, false))\n+      /* Quad offsets are restricted and can't handle normal addresses.  */\n+      if ((addr_mask & RELOAD_REG_QUAD_OFFSET) != 0)\n+\t{\n+\t  extra_cost = -1;\n+\t  type = \"vector d-form lo_sum\";\n+\t}\n+\n+      else if (!legitimate_lo_sum_address_p (mode, addr, false))\n \t{\n \t  fail_msg = \"bad LO_SUM\";\n \t  extra_cost = -1;\n@@ -18459,8 +18682,17 @@ rs6000_secondary_reload_memory (rtx addr,\n     case CONST:\n     case SYMBOL_REF:\n     case LABEL_REF:\n-      type = \"address\";\n-      extra_cost = rs6000_secondary_reload_toc_costs (addr_mask);\n+      if ((addr_mask & RELOAD_REG_QUAD_OFFSET) != 0)\n+\t{\n+\t  extra_cost = -1;\n+\t  type = \"vector d-form lo_sum #2\";\n+\t}\n+\n+      else\n+\t{\n+\t  type = \"address\";\n+\t  extra_cost = rs6000_secondary_reload_toc_costs (addr_mask);\n+\t}\n       break;\n \n       /* TOC references look like offsetable memory.  */\n@@ -18471,6 +18703,12 @@ rs6000_secondary_reload_memory (rtx addr,\n \t  extra_cost = -1;\n \t}\n \n+      else if ((addr_mask & RELOAD_REG_QUAD_OFFSET) != 0)\n+\t{\n+\t  extra_cost = -1;\n+\t  type = \"vector d-form lo_sum #3\";\n+\t}\n+\n       else if ((addr_mask & RELOAD_REG_OFFSET) == 0)\n \t{\n \t  extra_cost = 1;\n@@ -19101,6 +19339,16 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n \t    }\n \t}\n \n+      else if (mode_supports_vsx_dform_quad (mode) && CONST_INT_P (op1))\n+\t{\n+\t  if (((addr_mask & RELOAD_REG_QUAD_OFFSET) == 0)\n+\t      || !quad_address_p (addr, mode, false))\n+\t    {\n+\t      emit_insn (gen_rtx_SET (scratch, addr));\n+\t      new_addr = scratch;\n+\t    }\n+\t}\n+\n       /* Make sure the register class can handle offset addresses.  */\n       else if (rs6000_legitimate_offset_address_p (mode, addr, false, true))\n \t{\n@@ -19131,6 +19379,13 @@ rs6000_secondary_reload_inner (rtx reg, rtx mem, rtx scratch, bool store_p)\n \t    }\n \t}\n \n+      /* Quad offsets are restricted and can't handle normal addresses.  */\n+      else if (mode_supports_vsx_dform_quad (mode))\n+\t{\n+\t  emit_insn (gen_rtx_SET (scratch, addr));\n+\t  new_addr = scratch;\n+\t}\n+\n       /* Make sure the register class can handle offset addresses.  */\n       else if (legitimate_lo_sum_address_p (mode, addr, false))\n \t{\n@@ -19351,7 +19606,8 @@ rs6000_preferred_reload_class (rtx x, enum reg_class rclass)\n \t}\n \n       /* D-form addressing can easily reload the value.  */\n-      if (mode_supports_vmx_dform (mode))\n+      if (mode_supports_vmx_dform (mode)\n+\t  || mode_supports_vsx_dform_quad (mode))\n \treturn rclass;\n \n       /* If this is a scalar floating point value and we don't have D-form\n@@ -19786,8 +20042,16 @@ rs6000_output_move_128bit (rtx operands[])\n \n       else if (TARGET_VSX && dest_vsx_p)\n \t{\n-\t  if (mode == V16QImode || mode == V8HImode || mode == V4SImode)\n+\t  if (mode_supports_vsx_dform_quad (mode)\n+\t      && quad_address_p (XEXP (src, 0), mode, false))\n+\t    return \"lxv %x0,%1\";\n+\n+\t  else if (TARGET_P9_VECTOR)\n+\t    return \"lxvx %x0,%y1\";\n+\n+\t  else if (mode == V16QImode || mode == V8HImode || mode == V4SImode)\n \t    return \"lxvw4x %x0,%y1\";\n+\n \t  else\n \t    return \"lxvd2x %x0,%y1\";\n \t}\n@@ -19816,8 +20080,16 @@ rs6000_output_move_128bit (rtx operands[])\n \n       else if (TARGET_VSX && src_vsx_p)\n \t{\n-\t  if (mode == V16QImode || mode == V8HImode || mode == V4SImode)\n+\t  if (mode_supports_vsx_dform_quad (mode)\n+\t      && quad_address_p (XEXP (dest, 0), mode, false))\n+\t    return \"stxv %x1,%0\";\n+\n+\t  else if (TARGET_P9_VECTOR)\n+\t    return \"stxvx %x1,%y0\";\n+\n+\t  else if (mode == V16QImode || mode == V8HImode || mode == V4SImode)\n \t    return \"stxvw4x %x1,%y0\";\n+\n \t  else\n \t    return \"stxvd2x %x1,%y0\";\n \t}\n@@ -26236,25 +26508,37 @@ rs6000_emit_prologue (void)\n \tif (info->vrsave_mask & ALTIVEC_REG_BIT (i))\n \t  {\n \t    rtx areg, savereg, mem;\n-\t    int offset;\n+\t    HOST_WIDE_INT offset;\n \n \t    offset = (info->altivec_save_offset + frame_off\n \t\t      + 16 * (i - info->first_altivec_reg_save));\n \n \t    savereg = gen_rtx_REG (V4SImode, i);\n \n-\t    NOT_INUSE (0);\n-\t    areg = gen_rtx_REG (Pmode, 0);\n-\t    emit_move_insn (areg, GEN_INT (offset));\n-\n-\t    /* AltiVec addressing mode is [reg+reg].  */\n-\t    mem = gen_frame_mem (V4SImode,\n-\t\t\t\t gen_rtx_PLUS (Pmode, frame_reg_rtx, areg));\n+\t    if (TARGET_P9_DFORM_VECTOR && quad_address_offset_p (offset))\n+\t      {\n+\t\tmem = gen_frame_mem (V4SImode,\n+\t\t\t\t     gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t\t\t\t   GEN_INT (offset)));\n+\t\tinsn = emit_insn (gen_rtx_SET (mem, savereg));\n+\t\tareg = NULL_RTX;\n+\t      }\n+\t    else\n+\t      {\n+\t\tNOT_INUSE (0);\n+\t\tareg = gen_rtx_REG (Pmode, 0);\n+\t\temit_move_insn (areg, GEN_INT (offset));\n \n-\t    /* Rather than emitting a generic move, force use of the stvx\n-\t       instruction, which we always want.  In particular we don't\n-\t       want xxpermdi/stxvd2x for little endian.  */\n-\t    insn = emit_insn (gen_altivec_stvx_v4si_internal (mem, savereg));\n+\t\t/* AltiVec addressing mode is [reg+reg].  */\n+\t\tmem = gen_frame_mem (V4SImode,\n+\t\t\t\t     gen_rtx_PLUS (Pmode, frame_reg_rtx, areg));\n+\n+\t\t/* Rather than emitting a generic move, force use of the stvx\n+\t\t   instruction, which we always want on ISA 2.07 (power8) systems.\n+\t\t   In particular we don't want xxpermdi/stxvd2x for little\n+\t\t   endian.  */\n+\t\tinsn = emit_insn (gen_altivec_stvx_v4si_internal (mem, savereg));\n+\t      }\n \n \t    rs6000_frame_related (insn, frame_reg_rtx, sp_off - frame_off,\n \t\t\t\t  areg, GEN_INT (offset));\n@@ -26974,23 +27258,35 @@ rs6000_emit_epilogue (int sibcall)\n \t  for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)\n \t    if (info->vrsave_mask & ALTIVEC_REG_BIT (i))\n \t      {\n-\t\trtx addr, areg, mem, reg;\n+\t\trtx addr, areg, mem, insn;\n+\t\trtx reg = gen_rtx_REG (V4SImode, i);\n+\t\tHOST_WIDE_INT offset\n+\t\t  = (info->altivec_save_offset + frame_off\n+\t\t     + 16 * (i - info->first_altivec_reg_save));\n \n-\t\tareg = gen_rtx_REG (Pmode, 0);\n-\t\temit_move_insn\n-\t\t  (areg, GEN_INT (info->altivec_save_offset\n-\t\t\t\t  + frame_off\n-\t\t\t\t  + 16 * (i - info->first_altivec_reg_save)));\n+\t\tif (TARGET_P9_DFORM_VECTOR && quad_address_offset_p (offset))\n+\t\t  {\n+\t\t    mem = gen_frame_mem (V4SImode,\n+\t\t\t\t\t gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t\t\t\t       GEN_INT (offset)));\n+\t\t    insn = gen_rtx_SET (reg, mem);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    areg = gen_rtx_REG (Pmode, 0);\n+\t\t    emit_move_insn (areg, GEN_INT (offset));\n \n-\t\t/* AltiVec addressing mode is [reg+reg].  */\n-\t\taddr = gen_rtx_PLUS (Pmode, frame_reg_rtx, areg);\n-\t\tmem = gen_frame_mem (V4SImode, addr);\n-\n-\t\treg = gen_rtx_REG (V4SImode, i);\n-\t\t/* Rather than emitting a generic move, force use of the\n-\t\t   lvx instruction, which we always want.  In particular\n-\t\t   we don't want lxvd2x/xxpermdi for little endian.  */\n-\t\t(void) emit_insn (gen_altivec_lvx_v4si_internal (reg, mem));\n+\t\t    /* AltiVec addressing mode is [reg+reg].  */\n+\t\t    addr = gen_rtx_PLUS (Pmode, frame_reg_rtx, areg);\n+\t\t    mem = gen_frame_mem (V4SImode, addr);\n+\n+\t\t    /* Rather than emitting a generic move, force use of the\n+\t\t       lvx instruction, which we always want.  In particular we\n+\t\t       don't want lxvd2x/xxpermdi for little endian.  */\n+\t\t    insn = gen_altivec_lvx_v4si_internal (reg, mem);\n+\t\t  }\n+\n+\t\t(void) emit_insn (insn);\n \t      }\n \t}\n \n@@ -27177,23 +27473,35 @@ rs6000_emit_epilogue (int sibcall)\n \t  for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)\n \t    if (info->vrsave_mask & ALTIVEC_REG_BIT (i))\n \t      {\n-\t\trtx addr, areg, mem, reg;\n+\t\trtx addr, areg, mem, insn;\n+\t\trtx reg = gen_rtx_REG (V4SImode, i);\n+\t\tHOST_WIDE_INT offset\n+\t\t  = (info->altivec_save_offset + frame_off\n+\t\t     + 16 * (i - info->first_altivec_reg_save));\n \n-\t\tareg = gen_rtx_REG (Pmode, 0);\n-\t\temit_move_insn\n-\t\t  (areg, GEN_INT (info->altivec_save_offset\n-\t\t\t\t  + frame_off\n-\t\t\t\t  + 16 * (i - info->first_altivec_reg_save)));\n+\t\tif (TARGET_P9_DFORM_VECTOR && quad_address_offset_p (offset))\n+\t\t  {\n+\t\t    mem = gen_frame_mem (V4SImode,\n+\t\t\t\t\t gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t\t\t\t       GEN_INT (offset)));\n+\t\t    insn = gen_rtx_SET (reg, mem);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    areg = gen_rtx_REG (Pmode, 0);\n+\t\t    emit_move_insn (areg, GEN_INT (offset));\n \n-\t\t/* AltiVec addressing mode is [reg+reg].  */\n-\t\taddr = gen_rtx_PLUS (Pmode, frame_reg_rtx, areg);\n-\t\tmem = gen_frame_mem (V4SImode, addr);\n-\n-\t\treg = gen_rtx_REG (V4SImode, i);\n-\t\t/* Rather than emitting a generic move, force use of the\n-\t\t   lvx instruction, which we always want.  In particular\n-\t\t   we don't want lxvd2x/xxpermdi for little endian.  */\n-\t\t(void) emit_insn (gen_altivec_lvx_v4si_internal (reg, mem));\n+\t\t    /* AltiVec addressing mode is [reg+reg].  */\n+\t\t    addr = gen_rtx_PLUS (Pmode, frame_reg_rtx, areg);\n+\t\t    mem = gen_frame_mem (V4SImode, addr);\n+\n+\t\t    /* Rather than emitting a generic move, force use of the\n+\t\t       lvx instruction, which we always want.  In particular we\n+\t\t       don't want lxvd2x/xxpermdi for little endian.  */\n+\t\t    insn = gen_altivec_lvx_v4si_internal (reg, mem);\n+\t\t  }\n+\n+\t\t(void) emit_insn (insn);\n \t      }\n \t}\n \n@@ -34365,7 +34673,7 @@ rs6000_libcall_value (machine_mode mode)\n static bool\n rs6000_lra_p (void)\n {\n-  return rs6000_lra_flag;\n+  return TARGET_LRA;\n }\n \n /* Given FROM and TO register numbers, say whether this elimination is allowed.\n@@ -34726,7 +35034,8 @@ static struct rs6000_opt_mask const rs6000_opt_masks[] =\n   { \"power8-fusion\",\t\tOPTION_MASK_P8_FUSION,\t\tfalse, true  },\n   { \"power8-fusion-sign\",\tOPTION_MASK_P8_FUSION_SIGN,\tfalse, true  },\n   { \"power8-vector\",\t\tOPTION_MASK_P8_VECTOR,\t\tfalse, true  },\n-  { \"power9-dform\",\t\tOPTION_MASK_P9_DFORM,\t\tfalse, true  },\n+  { \"power9-dform-scalar\",\tOPTION_MASK_P9_DFORM_SCALAR,\tfalse, true  },\n+  { \"power9-dform-vector\",\tOPTION_MASK_P9_DFORM_VECTOR,\tfalse, true  },\n   { \"power9-fusion\",\t\tOPTION_MASK_P9_FUSION,\t\tfalse, true  },\n   { \"power9-minmax\",\t\tOPTION_MASK_P9_MINMAX,\t\tfalse, true  },\n   { \"power9-vector\",\t\tOPTION_MASK_P9_VECTOR,\t\tfalse, true  },\n@@ -35359,7 +35668,9 @@ rs6000_print_options_internal (FILE *file,\n   size_t i;\n   size_t start_column = 0;\n   size_t cur_column;\n-  size_t max_column = 76;\n+  size_t max_column = 120;\n+  size_t prefix_len = strlen (prefix);\n+  size_t comma_len = 0;\n   const char *comma = \"\";\n \n   if (indent)\n@@ -35377,27 +35688,45 @@ rs6000_print_options_internal (FILE *file,\n   cur_column = start_column;\n   for (i = 0; i < num_elements; i++)\n     {\n-      if ((flags & opts[i].mask) != 0)\n+      bool invert = opts[i].invert;\n+      const char *name = opts[i].name;\n+      const char *no_str = \"\";\n+      HOST_WIDE_INT mask = opts[i].mask;\n+      size_t len = comma_len + prefix_len + strlen (name);\n+\n+      if (!invert)\n \t{\n-\t  const char *no_str = rs6000_opt_masks[i].invert ? \"no-\" : \"\";\n-\t  size_t len = (strlen (comma)\n-\t\t\t+ strlen (prefix)\n-\t\t\t+ strlen (no_str)\n-\t\t\t+ strlen (rs6000_opt_masks[i].name));\n+\t  if ((flags & mask) == 0)\n+\t    {\n+\t      no_str = \"no-\";\n+\t      len += sizeof (\"no-\") - 1;\n+\t    }\n \n-\t  cur_column += len;\n-\t  if (cur_column > max_column)\n+\t  flags &= ~mask;\n+\t}\n+\n+      else\n+\t{\n+\t  if ((flags & mask) != 0)\n \t    {\n-\t      fprintf (stderr, \", \\\\\\n%*s\", (int)start_column, \"\");\n-\t      cur_column = start_column + len;\n-\t      comma = \"\";\n+\t      no_str = \"no-\";\n+\t      len += sizeof (\"no-\") - 1;\n \t    }\n \n-\t  fprintf (file, \"%s%s%s%s\", comma, prefix, no_str,\n-\t\t   rs6000_opt_masks[i].name);\n-\t  flags &= ~ opts[i].mask;\n-\t  comma = \", \";\n+\t  flags |= mask;\n \t}\n+\n+      cur_column += len;\n+      if (cur_column > max_column)\n+\t{\n+\t  fprintf (stderr, \", \\\\\\n%*s\", (int)start_column, \"\");\n+\t  cur_column = start_column + len;\n+\t  comma = \"\";\n+\t}\n+\n+      fprintf (file, \"%s%s%s%s\", comma, prefix, no_str, name);\n+      comma = \", \";\n+      comma_len = sizeof (\", \") - 1;\n     }\n \n   fputs (\"\\n\", file);"}, {"sha": "92c5396c47ee455c3e7c29d35181b2ade47315bb", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "patch": "@@ -470,8 +470,8 @@ Target RejectNegative Joined UInteger Var(rs6000_long_double_type_size) Save\n -mlong-double-<n>\tSpecify size of long double (64 or 128 bits).\n \n mlra\n-Target Report Var(rs6000_lra_flag) Init(0) Save\n-Use LRA instead of reload.\n+Target Report Mask(LRA) Var(rs6000_isa_flags)\n+Enable Local Register Allocation.\n \n msched-costly-dep=\n Target RejectNegative Joined Var(rs6000_sched_costly_dep_str)\n@@ -609,9 +609,17 @@ mpower9-vector\n Target Report Mask(P9_VECTOR) Var(rs6000_isa_flags)\n Use/do not use vector and scalar instructions added in ISA 3.0.\n \n+mpower9-dform-scalar\n+Target Undocumented Mask(P9_DFORM_SCALAR) Var(rs6000_isa_flags)\n+Use/do not use scalar register+offset memory instructions added in ISA 3.0.\n+\n+mpower9-dform-vector\n+Target Undocumented Mask(P9_DFORM_VECTOR) Var(rs6000_isa_flags)\n+Use/do not use vector register+offset memory instructions added in ISA 3.0.\n+\n mpower9-dform\n-Target Undocumented Mask(P9_DFORM) Var(rs6000_isa_flags)\n-Use/do not use vector and scalar instructions added in ISA 3.0.\n+Target Report Var(TARGET_P9_DFORM_BOTH) Init(-1) Save\n+Use/do not use register+offset memory instructions added in ISA 3.0.\n \n mpower9-minmax\n Target Undocumented Mask(P9_MINMAX) Var(rs6000_isa_flags)"}, {"sha": "57cee7934ba48d01420535dba668e7586c8e552f", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "patch": "@@ -301,24 +301,6 @@\n    UNSPEC_VSX_XVCVDPUXDS\n   ])\n \n-;; VSX (P9) moves\n-\n-(define_insn \"*p9_vecload_<mode>\"\n-  [(set (match_operand:VSX_M2 0 \"vsx_register_operand\" \"=<VSa>\")\n-        (match_operand:VSX_M2 1 \"memory_operand\" \"Z\"))]\n-  \"TARGET_P9_VECTOR\"\n-  \"lxvx %x0,%y1\"\n-  [(set_attr \"type\" \"vecload\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"*p9_vecstore_<mode>\"\n-  [(set (match_operand:VSX_M2 0 \"memory_operand\" \"=Z\")\n-        (match_operand:VSX_M2 1 \"vsx_register_operand\" \"<VSa>\"))]\n-  \"TARGET_P9_VECTOR\"\n-  \"stxvx %x1,%y0\"\n-  [(set_attr \"type\" \"vecstore\")\n-   (set_attr \"length\" \"4\")])\n-\n ;; VSX moves\n \n ;; The patterns for LE permuted loads and stores come before the general\n@@ -788,8 +770,8 @@\n   \"\")\n \n (define_insn \"*vsx_mov<mode>\"\n-  [(set (match_operand:VSX_M 0 \"nonimmediate_operand\" \"=Z,<VSr>,<VSr>,?Z,?<VSa>,?<VSa>,r,we,wQ,?&r,??Y,??r,??r,<VSr>,?<VSa>,*r,v,wZ,v\")\n-\t(match_operand:VSX_M 1 \"input_operand\" \"<VSr>,Z,<VSr>,<VSa>,Z,<VSa>,we,b,r,wQ,r,Y,r,j,j,j,W,v,wZ\"))]\n+  [(set (match_operand:VSX_M 0 \"nonimmediate_operand\" \"=ZwO,<VSr>,<VSr>,?ZwO,?<VSa>,?<VSa>,r,we,wQ,?&r,??Y,??r,??r,<VSr>,?<VSa>,*r,v,wZ,v\")\n+\t(match_operand:VSX_M 1 \"input_operand\" \"<VSr>,ZwO,<VSr>,<VSa>,ZwO,<VSa>,we,b,r,wQ,r,Y,r,j,j,j,W,v,wZ\"))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\n    && (register_operand (operands[0], <MODE>mode) \n        || register_operand (operands[1], <MODE>mode))\"\n@@ -803,8 +785,8 @@\n ;; use of TImode is for unions.  However for plain data movement, slightly\n ;; favor the vector loads\n (define_insn \"*vsx_movti_64bit\"\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=Z,wa,wa,wa,r,we,v,v,wZ,wQ,&r,Y,r,r,?r\")\n-\t(match_operand:TI 1 \"input_operand\" \"wa,Z,wa,O,we,b,W,wZ,v,r,wQ,r,Y,r,n\"))]\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=ZwO,wa,wa,wa,r,we,v,v,wZ,wQ,&r,Y,r,r,?r\")\n+\t(match_operand:TI 1 \"input_operand\" \"wa,ZwO,wa,O,we,b,W,wZ,v,r,wQ,r,Y,r,n\"))]\n   \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (TImode)\n    && (register_operand (operands[0], TImode) \n        || register_operand (operands[1], TImode))\"\n@@ -815,8 +797,8 @@\n    (set_attr \"length\" \"4,4,4,4,8,4,16,4,4,8,8,8,8,8,8\")])\n \n (define_insn \"*vsx_movti_32bit\"\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=Z,wa,wa,wa,v, v,wZ,Q,Y,????r,????r,????r,r\")\n-\t(match_operand:TI 1 \"input_operand\"        \"wa, Z,wa, O,W,wZ, v,r,r,    Q,    Y,    r,n\"))]\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=ZwO,wa,wa,wa,v,v,wZ,Q,Y,????r,????r,????r,r\")\n+\t(match_operand:TI 1 \"input_operand\"        \"wa,ZwO,wa,O,W,wZ,v,r,r,Q,Y,r,n\"))]\n   \"! TARGET_POWERPC64 && VECTOR_MEM_VSX_P (TImode)\n    && (register_operand (operands[0], TImode)\n        || register_operand (operands[1], TImode))\""}, {"sha": "d3e25380df62bff80acbfb1e5c40e3e5f4dfeafa", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "patch": "@@ -1006,7 +1006,8 @@ See RS/6000 and PowerPC Options.\n -mupper-regs-df -mno-upper-regs-df -mupper-regs-sf -mno-upper-regs-sf @gol\n -mupper-regs -mno-upper-regs -mmodulo -mno-modulo @gol\n -mfloat128 -mno-float128 -mfloat128-hardware -mno-float128-hardware @gol\n--mpower9-fusion -mno-mpower9-fusion -mpower9-vector -mno-power9-vector}\n+-mpower9-fusion -mno-mpower9-fusion -mpower9-vector -mno-power9-vector @gol\n+-mpower9-dform -mno-power9-dform -mlra -mno-lra}\n \n @emph{RX Options}\n @gccoptlist{-m64bit-doubles  -m32bit-doubles  -fpu  -nofpu@gol\n@@ -13702,7 +13703,6 @@ Enable the use of indexed loads.  This can be problematic because some\n optimizers then assume that indexed stores exist, which is not\n the case.\n \n-@item -mlra\n @opindex mlra\n Enable Local Register Allocation.  This is still experimental for ARC,\n so by default the compiler uses standard reload\n@@ -19928,7 +19928,7 @@ following options:\n -msimple-fpu -mstring  -mmulhw  -mdlmzb  -mmfpgpr -mvsx @gol\n -mcrypto -mdirect-move -mpower8-fusion -mpower8-vector @gol\n -mquad-memory -mquad-memory-atomic -mmodulo -mfloat128 -mfloat128-hardware @gol\n--mpower9-fusion -mpower9-vector}\n+-mpower9-fusion -mpower9-vector -mpower9-dform}\n \n The particular options set for any particular CPU varies between\n compiler versions, depending on what setting seems to produce optimal\n@@ -20052,6 +20052,12 @@ This switch enables or disables the generation of ISEL instructions.\n This switch has been deprecated.  Use @option{-misel} and\n @option{-mno-isel} instead.\n \n+@item -mlra\n+@opindex mlra\n+Enable Local Register Allocation.  This is still experimental for PowerPC,\n+so by default the compiler uses standard reload\n+(i.e. @option{-mno-lra}).\n+\n @item -mspe\n @itemx -mno-spe\n @opindex mspe\n@@ -20201,10 +20207,19 @@ processors.\n @opindex mpower9-vector\n @opindex mno-power9-vector\n Generate code that uses (does not use) the vector and scalar\n-instructions that were added in version 2.07 of the PowerPC ISA.  Also\n+instructions that were added in version 3.0 of the PowerPC ISA.  Also\n enable the use of built-in functions that allow more direct access to\n the vector instructions.\n \n+@item -mpower9-dform\n+@itemx -mno-power9-dform\n+@opindex mpower9-dform\n+@opindex mno-power9-dform\n+Enable (disable) scalar d-form (register + offset) memory instructions\n+to load/store traditional Altivec registers. If the @var{LRA} register\n+allocator is enabled, also enable (disable) vector d-form memory\n+instructions.\n+\n @item -mfloat-gprs=@var{yes/single/double/no}\n @itemx -mfloat-gprs\n @opindex mfloat-gprs"}, {"sha": "f2360c8dfb62c24650e5b9f68238430f4ae75989", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "patch": "@@ -3224,6 +3224,9 @@ Memory operand suitable for TOC fusion memory references.\n Int constant that is the element number that the MFVSRLD instruction\n targets.\n \n+@item wO\n+A memory operand suitable for the ISA 3.0 vector d-form instructions.\n+\n @item wQ\n A memory address that will work with the @code{lq} and @code{stq}\n instructions."}, {"sha": "77b1856371c038baa9cd29efa47b59f23c8435fb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "patch": "@@ -1,3 +1,13 @@\n+2016-05-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/dform-3.c: New test for ISA 3.0 vector d-form\n+\tsupport.\n+\t* gcc.target/powerpc/dform-1.c: Add -mlra option to silence\n+\twarning when using -mvsx-timode.\n+\t* gcc.target/powerpc/p8vector-int128-1.c: Likewise.\n+\t* gcc.target/powerpc/dform-2.c: Likewise.\n+\t* gcc.target/powerpc/pr68805.c: Likewise.\n+\n 2016-05-11  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/71024"}, {"sha": "12623f20262cf402f33051de5d110933aa39cbd2", "filename": "gcc/testsuite/gcc.target/powerpc/dform-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdform-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdform-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdform-1.c?ref=3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n /* { dg-require-effective-target powerpc_p9vector_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n-/* { dg-options \"-mcpu=power9 -mpower9-dform -O2\" } */\n+/* { dg-options \"-mcpu=power9 -mpower9-dform -O2 -mlra\" } */\n \n #ifndef TYPE\n #define TYPE double"}, {"sha": "86d65b5b1fdcec7581dae973d12b67e4c9976b9f", "filename": "gcc/testsuite/gcc.target/powerpc/dform-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdform-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdform-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdform-2.c?ref=3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n /* { dg-require-effective-target powerpc_p9vector_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n-/* { dg-options \"-mcpu=power9 -mpower9-dform -O2\" } */\n+/* { dg-options \"-mcpu=power9 -mpower9-dform -O2 -mlra\" } */\n \n #ifndef TYPE\n #define TYPE float"}, {"sha": "b1c481fbf6d1802b1da032a7a6808fb3a53f6ab1", "filename": "gcc/testsuite/gcc.target/powerpc/dform-3.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdform-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdform-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdform-3.c?ref=3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -mpower9-dform -O2 -mlra\" } */\n+\n+#ifndef TYPE\n+#define TYPE vector double\n+#endif\n+\n+struct foo {\n+  TYPE a, b, c, d;\n+};\n+\n+/* Test whether ISA 3.0 vector d-form instructions are implemented.  */\n+void\n+add (struct foo *p)\n+{\n+  p->b = p->c + p->d;\n+}\n+\n+/* Make sure we don't use direct moves to get stuff into GPR registers.  */\n+void\n+gpr (struct foo *p)\n+{\n+  TYPE x = p->c;\n+\n+  __asm__ (\" # reg = %0\" : \"+r\" (x));\n+\n+  p->b = x;\n+}\n+\n+/* { dg-final { scan-assembler     \"lxv \"      } } */\n+/* { dg-final { scan-assembler     \"stxv \"     } } */\n+/* { dg-final { scan-assembler-not \"lxvx \"     } } */\n+/* { dg-final { scan-assembler-not \"stxvx \"    } } */\n+/* { dg-final { scan-assembler-not \"mfvsrd \"   } } */\n+/* { dg-final { scan-assembler-not \"mfvsrld \"  } } */\n+/* { dg-final { scan-assembler     \"l\\[dq\\] \"  } } */\n+/* { dg-final { scan-assembler     \"st\\[dq\\] \" } } */"}, {"sha": "5ba772f53015716343ef69a3f1cc06ff4c02536a", "filename": "gcc/testsuite/gcc.target/powerpc/p8vector-int128-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp8vector-int128-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp8vector-int128-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp8vector-int128-1.c?ref=3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "patch": "@@ -2,7 +2,7 @@\n /* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n /* { dg-require-effective-target powerpc_p8vector_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n-/* { dg-options \"-mcpu=power8 -O3 -mvsx-timode\" } */\n+/* { dg-options \"-mcpu=power8 -O3 -mvsx-timode -mlra\" } */\n \n #include <altivec.h>\n "}, {"sha": "5510811107da4e03ff33555109c360743007ae92", "filename": "gcc/testsuite/gcc.target/powerpc/pr68805.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr68805.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr68805.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr68805.c?ref=3fd2b0075e6c7b7e9b4ce11d2cd38965a36e448c", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile { target powerpc64le-*-* } } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n-/* { dg-options \"-O2 -mvsx-timode -mcpu=power8\" } */\n+/* { dg-options \"-O2 -mvsx-timode -mcpu=power8 -mlra\" } */\n \n typedef struct bar {\n   void *a;"}]}