{"sha": "bce29d65ebe1316d15ec7582a1d257ef1be163f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNlMjlkNjVlYmUxMzE2ZDE1ZWM3NTgyYTFkMjU3ZWYxYmUxNjNmNw==", "commit": {"author": {"name": "Alejandro Martinez", "email": "alejandro.martinezvicente@arm.com", "date": "2019-06-18T08:09:00Z"}, "committer": {"name": "Alejandro Martinez", "email": "alejandro@gcc.gnu.org", "date": "2019-06-18T08:09:00Z"}, "message": "[Vectorizer] Support masking fold left reductions\n\nThis patch adds support in the vectorizer for masking fold left reductions.\nThis avoids the need to insert a conditional assignement with some identity\nvalue.\n\nFrom-SVN: r272407", "tree": {"sha": "5e31c8b01fcf9fd667adb0a813ad377f34961fae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e31c8b01fcf9fd667adb0a813ad377f34961fae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bce29d65ebe1316d15ec7582a1d257ef1be163f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bce29d65ebe1316d15ec7582a1d257ef1be163f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bce29d65ebe1316d15ec7582a1d257ef1be163f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bce29d65ebe1316d15ec7582a1d257ef1be163f7/comments", "author": null, "committer": null, "parents": [{"sha": "9553f0d2216d4475d4d1afaa748b6b02f56c057b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9553f0d2216d4475d4d1afaa748b6b02f56c057b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9553f0d2216d4475d4d1afaa748b6b02f56c057b"}], "stats": {"total": 97, "additions": 89, "deletions": 8}, "files": [{"sha": "51f9cd22ebc70702802cb5b3c4407912b8f14c7f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce29d65ebe1316d15ec7582a1d257ef1be163f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce29d65ebe1316d15ec7582a1d257ef1be163f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bce29d65ebe1316d15ec7582a1d257ef1be163f7", "patch": "@@ -1,3 +1,17 @@\n+2019-06-18  Alejandro Martinez  <alejandro.martinezvicente@arm.com>\n+\n+\t* config/aarch64/aarch64-sve.md (mask_fold_left_plus_<mode>): Renamed\n+\tfrom \"*fold_left_plus_<mode>\", updated operands order.\n+\t* doc/md.texi (mask_fold_left_plus_@var{m}): Documented new optab.\n+\t* internal-fn.c (mask_fold_left_direct): New define.\n+\t(expand_mask_fold_left_optab_fn): Likewise.\n+\t(direct_mask_fold_left_optab_supported_p): Likewise.\n+\t* internal-fn.def (MASK_FOLD_LEFT_PLUS): New internal function.\n+\t* optabs.def (mask_fold_left_plus_optab): New optab.\n+\t* tree-vect-loop.c (mask_fold_left_plus_optab): New function to get a\n+\tmasked internal_fn for a reduction ifn.\n+\t(vectorize_fold_left_reduction): Add support for masking reductions.\n+\n 2019-06-18  Kewen Lin  <linkw@gcc.gnu.org>\n \n \tPR middle-end/80791"}, {"sha": "806823f321f6ec6db15ee8ca7ae30b691585607c", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce29d65ebe1316d15ec7582a1d257ef1be163f7/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce29d65ebe1316d15ec7582a1d257ef1be163f7/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=bce29d65ebe1316d15ec7582a1d257ef1be163f7", "patch": "@@ -2180,14 +2180,14 @@\n )\n \n ;; In-order FP reductions predicated with PTRUE.\n-(define_insn \"*fold_left_plus_<mode>\"\n+(define_insn \"mask_fold_left_plus_<mode>\"\n   [(set (match_operand:<VEL> 0 \"register_operand\" \"=w\")\n-\t(unspec:<VEL> [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n-\t\t       (match_operand:<VEL> 2 \"register_operand\" \"0\")\n-\t\t       (match_operand:SVE_F 3 \"register_operand\" \"w\")]\n+\t(unspec:<VEL> [(match_operand:<VPRED> 3 \"register_operand\" \"Upl\")\n+\t\t       (match_operand:<VEL> 1 \"register_operand\" \"0\")\n+\t\t       (match_operand:SVE_F 2 \"register_operand\" \"w\")]\n \t\t      UNSPEC_FADDA))]\n   \"TARGET_SVE\"\n-  \"fadda\\t%<Vetype>0, %1, %<Vetype>0, %3.<Vetype>\"\n+  \"fadda\\t%<Vetype>0, %3, %<Vetype>0, %2.<Vetype>\"\n )\n \n ;; Predicated form of the above in-order reduction."}, {"sha": "40c2b8b20cc0e94d80c1e059a728496d1d2ed390", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce29d65ebe1316d15ec7582a1d257ef1be163f7/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce29d65ebe1316d15ec7582a1d257ef1be163f7/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=bce29d65ebe1316d15ec7582a1d257ef1be163f7", "patch": "@@ -5417,6 +5417,11 @@ mode @var{m} and the scalars have the mode appropriate for one\n element of @var{m}.  The operation is strictly in-order: there is\n no reassociation.\n \n+@cindex @code{mask_fold_left_plus_@var{m}} instruction pattern\n+@item @code{mask_fold_left_plus_@var{m}}\n+Like @samp{fold_left_plus_@var{m}}, but takes an additional mask operand\n+(operand 3) that specifies which elements of the source vector should be added.\n+\n @cindex @code{sdot_prod@var{m}} instruction pattern\n @item @samp{sdot_prod@var{m}}\n @cindex @code{udot_prod@var{m}} instruction pattern"}, {"sha": "90f8e567d57cf6a6cc14fe688c9c146fecac2991", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce29d65ebe1316d15ec7582a1d257ef1be163f7/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce29d65ebe1316d15ec7582a1d257ef1be163f7/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=bce29d65ebe1316d15ec7582a1d257ef1be163f7", "patch": "@@ -117,6 +117,7 @@ init_internal_fns ()\n #define while_direct { 0, 2, false }\n #define fold_extract_direct { 2, 2, false }\n #define fold_left_direct { 1, 1, false }\n+#define mask_fold_left_direct { 1, 1, false }\n \n const direct_internal_fn_info direct_internal_fn_array[IFN_LAST + 1] = {\n #define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC) not_direct,\n@@ -3000,6 +3001,9 @@ expand_while_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n #define expand_fold_left_optab_fn(FN, STMT, OPTAB) \\\n   expand_direct_optab_fn (FN, STMT, OPTAB, 2)\n \n+#define expand_mask_fold_left_optab_fn(FN, STMT, OPTAB) \\\n+  expand_direct_optab_fn (FN, STMT, OPTAB, 3)\n+\n /* RETURN_TYPE and ARGS are a return type and argument list that are\n    in principle compatible with FN (which satisfies direct_internal_fn_p).\n    Return the types that should be used to determine whether the\n@@ -3088,6 +3092,7 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types,\n #define direct_while_optab_supported_p convert_optab_supported_p\n #define direct_fold_extract_optab_supported_p direct_optab_supported_p\n #define direct_fold_left_optab_supported_p direct_optab_supported_p\n+#define direct_mask_fold_left_optab_supported_p direct_optab_supported_p\n \n /* Return the optab used by internal function FN.  */\n "}, {"sha": "906d74b1d08b9f14f3cf81aff10f902d472ef326", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce29d65ebe1316d15ec7582a1d257ef1be163f7/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce29d65ebe1316d15ec7582a1d257ef1be163f7/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=bce29d65ebe1316d15ec7582a1d257ef1be163f7", "patch": "@@ -199,6 +199,9 @@ DEF_INTERNAL_OPTAB_FN (FOLD_EXTRACT_LAST, ECF_CONST | ECF_NOTHROW,\n DEF_INTERNAL_OPTAB_FN (FOLD_LEFT_PLUS, ECF_CONST | ECF_NOTHROW,\n \t\t       fold_left_plus, fold_left)\n \n+DEF_INTERNAL_OPTAB_FN (MASK_FOLD_LEFT_PLUS, ECF_CONST | ECF_NOTHROW,\n+\t\t       mask_fold_left_plus, mask_fold_left)\n+\n /* Unary math functions.  */\n DEF_INTERNAL_FLT_FN (ACOS, ECF_CONST, acos, unary)\n DEF_INTERNAL_FLT_FN (ACOSH, ECF_CONST, acosh, unary)"}, {"sha": "75c8a0aee2ac9a7fc928d38f9575288893d42521", "filename": "gcc/optabs.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce29d65ebe1316d15ec7582a1d257ef1be163f7/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce29d65ebe1316d15ec7582a1d257ef1be163f7/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=bce29d65ebe1316d15ec7582a1d257ef1be163f7", "patch": "@@ -323,6 +323,7 @@ OPTAB_D (reduc_and_scal_optab,  \"reduc_and_scal_$a\")\n OPTAB_D (reduc_ior_scal_optab,  \"reduc_ior_scal_$a\")\n OPTAB_D (reduc_xor_scal_optab,  \"reduc_xor_scal_$a\")\n OPTAB_D (fold_left_plus_optab, \"fold_left_plus_$a\")\n+OPTAB_D (mask_fold_left_plus_optab, \"mask_fold_left_plus_$a\")\n \n OPTAB_D (extract_last_optab, \"extract_last_$a\")\n OPTAB_D (fold_extract_last_optab, \"fold_extract_last_$a\")"}, {"sha": "56c4e7f127171117858c0ca5c2065cf8aea0acda", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce29d65ebe1316d15ec7582a1d257ef1be163f7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce29d65ebe1316d15ec7582a1d257ef1be163f7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bce29d65ebe1316d15ec7582a1d257ef1be163f7", "patch": "@@ -1,3 +1,6 @@\n+2019-06-18  Alejandro Martinez  <alejandro.martinezvicente@arm.com>\n+\t* gcc.target/aarch64/sve/fadda_1.c: New test.\n+\n 2019-06-17  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/vect/vect-simd-8.c: New test."}, {"sha": "158cd6c8470279ce63dc4159876871ab47376cef", "filename": "gcc/testsuite/gcc.target/aarch64/sve/fadda_1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce29d65ebe1316d15ec7582a1d257ef1be163f7/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Ffadda_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce29d65ebe1316d15ec7582a1d257ef1be163f7/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Ffadda_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Ffadda_1.c?ref=bce29d65ebe1316d15ec7582a1d257ef1be163f7", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do assemble { target aarch64_asm_sve_ok } } */\n+/* { dg-options \"-O2 -ftree-vectorize --save-temps\" } */\n+\n+#define DO_OPS(TYPE)\t\t\t\t\t\\\n+TYPE fold_##TYPE (TYPE *src, int count)\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  TYPE res = 0;\t\t\t\t\t\t\\\n+  for (int i = 0; i < count; ++i)\t\t\t\\\n+    res += src[i];\t\t\t\t\t\\\n+  return res;\t\t\t\t\t\t\\\n+}\n+\n+DO_OPS (_Float16)\n+DO_OPS (float)\n+DO_OPS (double)\n+\n+/* { dg-final { scan-assembler-times {\\tfadda\\th[0-9]+, p[0-7], h[0-9]+, z[0-9]+\\.h\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfadda\\ts[0-9]+, p[0-7], s[0-9]+, z[0-9]+\\.s\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfadda\\td[0-9]+, p[0-7], d[0-9]+, z[0-9]+\\.d\\n} 1 } } */\n+/* { dg-final { scan-assembler-not \"sel\" } } */"}, {"sha": "a27eda675ad61c392a596f2dd321eccde0e669f5", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bce29d65ebe1316d15ec7582a1d257ef1be163f7/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bce29d65ebe1316d15ec7582a1d257ef1be163f7/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=bce29d65ebe1316d15ec7582a1d257ef1be163f7", "patch": "@@ -5916,6 +5916,30 @@ vect_expand_fold_left (gimple_stmt_iterator *gsi, tree scalar_dest,\n   return lhs;\n }\n \n+/* Get a masked internal function equivalent to REDUC_FN.  VECTYPE_IN is the\n+   type of the vector input.  */\n+\n+static internal_fn\n+get_masked_reduction_fn (internal_fn reduc_fn, tree vectype_in)\n+{\n+  internal_fn mask_reduc_fn;\n+\n+  switch (reduc_fn)\n+    {\n+    case IFN_FOLD_LEFT_PLUS:\n+      mask_reduc_fn = IFN_MASK_FOLD_LEFT_PLUS;\n+      break;\n+\n+    default:\n+      return IFN_LAST;\n+    }\n+\n+  if (direct_internal_fn_supported_p (mask_reduc_fn, vectype_in,\n+\t\t\t\t      OPTIMIZE_FOR_SPEED))\n+    return mask_reduc_fn;\n+  return IFN_LAST;\n+}\n+\n /* Perform an in-order reduction (FOLD_LEFT_REDUCTION).  STMT_INFO is the\n    statement that sets the live-out value.  REDUC_DEF_STMT is the phi\n    statement.  CODE is the operation performed by STMT_INFO and OPS are\n@@ -5938,6 +5962,7 @@ vectorize_fold_left_reduction (stmt_vec_info stmt_info,\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n   stmt_vec_info new_stmt_info = NULL;\n+  internal_fn mask_reduc_fn = get_masked_reduction_fn (reduc_fn, vectype_in);\n \n   int ncopies;\n   if (slp_node)\n@@ -6014,16 +6039,21 @@ vectorize_fold_left_reduction (stmt_vec_info stmt_info,\n \t  def0 = negated;\n \t}\n \n-      if (mask)\n+      if (mask && mask_reduc_fn == IFN_LAST)\n \tdef0 = merge_with_identity (gsi, mask, vectype_out, def0,\n \t\t\t\t    vector_identity);\n \n       /* On the first iteration the input is simply the scalar phi\n \t result, and for subsequent iterations it is the output of\n \t the preceding operation.  */\n-      if (reduc_fn != IFN_LAST)\n+      if (reduc_fn != IFN_LAST || (mask && mask_reduc_fn != IFN_LAST))\n \t{\n-\t  new_stmt = gimple_build_call_internal (reduc_fn, 2, reduc_var, def0);\n+\t  if (mask && mask_reduc_fn != IFN_LAST)\n+\t    new_stmt = gimple_build_call_internal (mask_reduc_fn, 3, reduc_var,\n+\t\t\t\t\t\t   def0, mask);\n+\t  else\n+\t    new_stmt = gimple_build_call_internal (reduc_fn, 2, reduc_var,\n+\t\t\t\t\t\t   def0);\n \t  /* For chained SLP reductions the output of the previous reduction\n \t     operation serves as the input of the next. For the final statement\n \t     the output cannot be a temporary - we reuse the original"}]}