{"sha": "fb3712f61f4ecb0fca8738013f68f75b901a33b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmIzNzEyZjYxZjRlY2IwZmNhODczODAxM2Y2OGY3NWI5MDFhMzNiNA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2005-11-09T11:45:01Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2005-11-09T11:45:01Z"}, "message": "s390.c (struct s390_frame_layout): New fields first_save_gpr_slot and last_save_gpr_slot.\n\n2005-11-09  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* config/s390/s390.c (struct s390_frame_layout): New fields \n\tfirst_save_gpr_slot and last_save_gpr_slot.\n\t(cfun_grps_save_area_size, s390_frame_info, s390_emit_prologue,  \n\ts390_emit_epilogue, s390_initial_elimination_offset): Replaced \n\tfirst_save_gpr and last_save_gpr with the _slot variants.\n\t(s390_register_info): Calculate first_save_gpr_slot and \n\tlast_save_gpr_slot using regs_ever_live.\n\t* testsuite/gcc.dg/pr24624.c: Testcase added.\n\nFrom-SVN: r106688", "tree": {"sha": "5c9c08a409a2a9a4f8f36f1eb4288998c6d45c18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c9c08a409a2a9a4f8f36f1eb4288998c6d45c18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb3712f61f4ecb0fca8738013f68f75b901a33b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb3712f61f4ecb0fca8738013f68f75b901a33b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb3712f61f4ecb0fca8738013f68f75b901a33b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb3712f61f4ecb0fca8738013f68f75b901a33b4/comments", "author": null, "committer": null, "parents": [{"sha": "297a777d4748114bc58d17eb41d7b8026f20a711", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/297a777d4748114bc58d17eb41d7b8026f20a711", "html_url": "https://github.com/Rust-GCC/gccrs/commit/297a777d4748114bc58d17eb41d7b8026f20a711"}], "stats": {"total": 156, "additions": 137, "deletions": 19}, "files": [{"sha": "d3dc23e04651d2bf5346e78cb9a68b4c1dab5c48", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3712f61f4ecb0fca8738013f68f75b901a33b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3712f61f4ecb0fca8738013f68f75b901a33b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb3712f61f4ecb0fca8738013f68f75b901a33b4", "patch": "@@ -1,3 +1,14 @@\n+2005-11-09  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* config/s390/s390.c (struct s390_frame_layout): New fields \n+\tfirst_save_gpr_slot and last_save_gpr_slot.\n+\t(cfun_grps_save_area_size, s390_frame_info, s390_emit_prologue,  \n+\ts390_emit_epilogue, s390_initial_elimination_offset): Replaced \n+\tfirst_save_gpr and last_save_gpr with the _slot variants.\n+\t(s390_register_info): Calculate first_save_gpr_slot and \n+\tlast_save_gpr_slot using regs_ever_live.\n+\t* testsuite/gcc.dg/pr24624.c: Testcase added.\n+\n 2005-11-09  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* config/s390/s390.c (s390_regs_ever_clobbered): Only save live eh regs"}, {"sha": "de049bf1c0eb91df3a92f01d4fd378ad38a6b8af", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 59, "deletions": 19, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3712f61f4ecb0fca8738013f68f75b901a33b4/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3712f61f4ecb0fca8738013f68f75b901a33b4/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=fb3712f61f4ecb0fca8738013f68f75b901a33b4", "patch": "@@ -233,7 +233,12 @@ struct s390_frame_layout GTY (())\n   HOST_WIDE_INT f4_offset;\n   HOST_WIDE_INT f8_offset;\n   HOST_WIDE_INT backchain_offset;\n-  \n+\n+  /* Number of first and last gpr where slots in the register\n+     save area are reserved for.  */\n+  int first_save_gpr_slot;\n+  int last_save_gpr_slot;\n+\n   /* Number of first and last gpr to be saved, restored.  */\n   int first_save_gpr;\n   int first_restore_gpr;\n@@ -283,8 +288,8 @@ struct machine_function GTY(())\n \n #define cfun_frame_layout (cfun->machine->frame_layout)\n #define cfun_save_high_fprs_p (!!cfun_frame_layout.high_fprs)\n-#define cfun_gprs_save_area_size ((cfun_frame_layout.last_save_gpr -           \\\n-  cfun_frame_layout.first_save_gpr + 1) * UNITS_PER_WORD)\n+#define cfun_gprs_save_area_size ((cfun_frame_layout.last_save_gpr_slot -           \\\n+  cfun_frame_layout.first_save_gpr_slot + 1) * UNITS_PER_WORD)\n #define cfun_set_fpr_bit(BITNUM) (cfun->machine->frame_layout.fpr_bitmap |=    \\\n   (1 << (BITNUM)))\n #define cfun_fpr_bit_p(BITNUM) (!!(cfun->machine->frame_layout.fpr_bitmap &    \\\n@@ -6135,27 +6140,54 @@ s390_register_info (int clobbered_regs[])\n \t|| current_function_stdarg);\n \n   for (i = 6; i < 16; i++)\n-    if (clobbered_regs[i])\n+    if (regs_ever_live[i] || clobbered_regs[i])\n       break;\n   for (j = 15; j > i; j--)\n-    if (clobbered_regs[j])\n+    if (regs_ever_live[j] || clobbered_regs[j])\n       break;\n \n   if (i == 16)\n     {\n       /* Nothing to save/restore.  */\n+      cfun_frame_layout.first_save_gpr_slot = -1;\n+      cfun_frame_layout.last_save_gpr_slot = -1;\n       cfun_frame_layout.first_save_gpr = -1;\n       cfun_frame_layout.first_restore_gpr = -1;\n       cfun_frame_layout.last_save_gpr = -1;\n       cfun_frame_layout.last_restore_gpr = -1;\n     }\n   else\n     {\n-      /* Save / Restore from gpr i to j.  */\n-      cfun_frame_layout.first_save_gpr = i;\n-      cfun_frame_layout.first_restore_gpr = i;\n-      cfun_frame_layout.last_save_gpr = j;\n-      cfun_frame_layout.last_restore_gpr = j;\n+      /* Save slots for gprs from i to j.  */\n+      cfun_frame_layout.first_save_gpr_slot = i;\n+      cfun_frame_layout.last_save_gpr_slot = j;\n+\n+      for (i = cfun_frame_layout.first_save_gpr_slot; \n+\t   i < cfun_frame_layout.last_save_gpr_slot + 1; \n+\t   i++)\n+\tif (clobbered_regs[i])\n+\t  break;\n+\n+      for (j = cfun_frame_layout.last_save_gpr_slot; j > i; j--)\n+\tif (clobbered_regs[j])\n+\t  break;\n+      \n+      if (i == cfun_frame_layout.last_save_gpr_slot + 1)\n+\t{\n+\t  /* Nothing to save/restore.  */\n+\t  cfun_frame_layout.first_save_gpr = -1;\n+\t  cfun_frame_layout.first_restore_gpr = -1;\n+\t  cfun_frame_layout.last_save_gpr = -1;\n+\t  cfun_frame_layout.last_restore_gpr = -1;\n+\t}\n+      else\n+\t{\n+\t  /* Save / Restore from gpr i to j.  */\n+\t  cfun_frame_layout.first_save_gpr = i;\n+\t  cfun_frame_layout.first_restore_gpr = i;\n+\t  cfun_frame_layout.last_save_gpr = j;\n+\t  cfun_frame_layout.last_restore_gpr = j;\n+\t}\n     }\n \n   if (current_function_stdarg)\n@@ -6171,11 +6203,17 @@ s390_register_info (int clobbered_regs[])\n \n \t  if (cfun_frame_layout.first_save_gpr == -1\n \t      || cfun_frame_layout.first_save_gpr > 2 + min_gpr)\n-\t    cfun_frame_layout.first_save_gpr = 2 + min_gpr;\n+\t    {\n+\t      cfun_frame_layout.first_save_gpr = 2 + min_gpr;\n+\t      cfun_frame_layout.first_save_gpr_slot = 2 + min_gpr;\n+\t    }\n \n \t  if (cfun_frame_layout.last_save_gpr == -1\n \t      || cfun_frame_layout.last_save_gpr < 2 + max_gpr - 1)\n-\t    cfun_frame_layout.last_save_gpr = 2 + max_gpr - 1;\n+\t    {\n+\t      cfun_frame_layout.last_save_gpr = 2 + max_gpr - 1;\n+\t      cfun_frame_layout.last_save_gpr_slot = 2 + max_gpr - 1;\n+\t    }\n \t}\n \n       /* Mark f0, f2 for 31 bit and f0-f4 for 64 bit to be saved.  */\n@@ -6220,7 +6258,7 @@ s390_frame_info (void)\n       cfun_frame_layout.f0_offset = 16 * UNITS_PER_WORD;\n       cfun_frame_layout.f4_offset = cfun_frame_layout.f0_offset + 2 * 8;\n       cfun_frame_layout.f8_offset = -cfun_frame_layout.high_fprs * 8;\n-      cfun_frame_layout.gprs_offset = (cfun_frame_layout.first_save_gpr\n+      cfun_frame_layout.gprs_offset = (cfun_frame_layout.first_save_gpr_slot\n \t\t\t\t       * UNITS_PER_WORD);\n     }\n   else if (TARGET_BACKCHAIN) /* kernel stack layout */\n@@ -6229,7 +6267,7 @@ s390_frame_info (void)\n \t\t\t\t\t    - UNITS_PER_WORD);\n       cfun_frame_layout.gprs_offset \n \t= (cfun_frame_layout.backchain_offset \n-\t   - (STACK_POINTER_REGNUM - cfun_frame_layout.first_save_gpr + 1)\n+\t   - (STACK_POINTER_REGNUM - cfun_frame_layout.first_save_gpr_slot + 1)\n \t   * UNITS_PER_WORD);\n \t  \n       if (TARGET_64BIT)\n@@ -6460,7 +6498,7 @@ s390_initial_elimination_offset (int from, int to)\n \n     case RETURN_ADDRESS_POINTER_REGNUM:\n       s390_init_frame_layout ();\n-      index = RETURN_REGNUM - cfun_frame_layout.first_save_gpr;\n+      index = RETURN_REGNUM - cfun_frame_layout.first_save_gpr_slot;\n       gcc_assert (index >= 0);\n       offset = cfun_frame_layout.frame_size + cfun_frame_layout.gprs_offset;\n       offset += index * UNITS_PER_WORD;\n@@ -6705,7 +6743,9 @@ s390_emit_prologue (void)\n   if (cfun_frame_layout.first_save_gpr != -1)\n     {\n       insn = save_gprs (stack_pointer_rtx, \n-\t\t\tcfun_frame_layout.gprs_offset,\n+\t\t\tcfun_frame_layout.gprs_offset + \n+\t\t\tUNITS_PER_WORD * (cfun_frame_layout.first_save_gpr \n+\t\t\t\t\t  - cfun_frame_layout.first_save_gpr_slot),\n \t\t\tcfun_frame_layout.first_save_gpr, \n \t\t\tcfun_frame_layout.last_save_gpr);\n       emit_insn (insn);\n@@ -7059,7 +7099,7 @@ s390_emit_epilogue (bool sibcall)\n \t    {\n \t      addr = plus_constant (frame_pointer,\n \t\t\t\t    offset + cfun_frame_layout.gprs_offset \n-\t\t\t\t    + (i - cfun_frame_layout.first_save_gpr)\n+\t\t\t\t    + (i - cfun_frame_layout.first_save_gpr_slot)\n \t\t\t\t    * UNITS_PER_WORD);\n \t      addr = gen_rtx_MEM (Pmode, addr);\n \t      set_mem_alias_set (addr, get_frame_alias_set ());\n@@ -7084,7 +7124,7 @@ s390_emit_epilogue (bool sibcall)\n \t      addr = plus_constant (frame_pointer,\n \t\t\t\t    offset + cfun_frame_layout.gprs_offset\n \t\t\t\t    + (RETURN_REGNUM \n-\t\t\t\t       - cfun_frame_layout.first_save_gpr)\n+\t\t\t\t       - cfun_frame_layout.first_save_gpr_slot)\n \t\t\t\t    * UNITS_PER_WORD);\n \t      addr = gen_rtx_MEM (Pmode, addr);\n \t      set_mem_alias_set (addr, get_frame_alias_set ());\n@@ -7095,7 +7135,7 @@ s390_emit_epilogue (bool sibcall)\n       insn = restore_gprs (frame_pointer,\n \t\t\t   offset + cfun_frame_layout.gprs_offset\n \t\t\t   + (cfun_frame_layout.first_restore_gpr \n-\t\t\t      - cfun_frame_layout.first_save_gpr)\n+\t\t\t      - cfun_frame_layout.first_save_gpr_slot)\n \t\t\t   * UNITS_PER_WORD,\n \t\t\t   cfun_frame_layout.first_restore_gpr,\n \t\t\t   cfun_frame_layout.last_restore_gpr);"}, {"sha": "bc2070c4b799cf3fae99491ae4ea9e12bc3d0cc6", "filename": "gcc/testsuite/gcc.dg/pr24624.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb3712f61f4ecb0fca8738013f68f75b901a33b4/gcc%2Ftestsuite%2Fgcc.dg%2Fpr24624.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb3712f61f4ecb0fca8738013f68f75b901a33b4/gcc%2Ftestsuite%2Fgcc.dg%2Fpr24624.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr24624.c?ref=fb3712f61f4ecb0fca8738013f68f75b901a33b4", "patch": "@@ -0,0 +1,67 @@\n+/* This used to ICE due to a backend problem on s390.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -mpacked-stack\" } */\n+\n+typedef unsigned int __u32;\n+typedef struct\n+{\n+  volatile int counter;\n+} __attribute__ ((aligned (4))) atomic_t;\n+static __inline__ __attribute__ ((always_inline))\n+     void atomic_inc (volatile atomic_t * v)\n+{\n+  (\n+    {\n+    typeof (v->counter) old_val, new_val;\n+  __asm__ __volatile__ (\n+\t\"   l     %0,0(%3)\\n\" \n+\t\"0: lr    %1,%0\\n\" \n+\t\"   ar    %1,%4\\n\" \n+\t\"   cs    %0,%1,0(%3)\\n\" \n+\t\"   jl    0b\": \n+\t\"=&d\" (old_val), \"=&d\" (new_val), \"=m\" (((atomic_t *) (v))->counter): \n+\t\"a\" (v), \"d\" (1), \"m\" (((atomic_t *) (v))->counter):\n+\t\"cc\", \"memory\");\n+    });\n+}\n+extern unsigned long volatile __attribute__ ((section (\".data\"))) jiffies;\n+struct inet_peer\n+{\n+  unsigned long dtime;\n+  atomic_t refcnt;\n+};\n+static volatile int peer_total;\n+int inet_peer_threshold = 65536 + 128;\n+int inet_peer_minttl = 120 * 100;\n+int inet_peer_maxttl = 10 * 60 * 100;\n+static int\n+cleanup_once (unsigned long ttl)\n+{\n+  struct inet_peer *p;\n+  if (p != ((void *) 0))\n+    {\n+      if (((\n+\t     {\n+\t     1;}\n+\t   ) && ((long) (jiffies) - (long) (p->dtime + ttl) < 0)))\n+\t{\n+\t  return -1;\n+\t}\n+      atomic_inc (&p->refcnt);\n+    }\n+}\n+struct inet_peer *\n+inet_getpeer (__u32 daddr, int create)\n+{\n+  int i;\n+  int ttl;\n+  if (peer_total >= inet_peer_threshold)\n+    ttl = inet_peer_minttl;\n+  else\n+    ttl =\n+      inet_peer_maxttl - (inet_peer_maxttl -\n+\t\t\t  inet_peer_minttl) / 100 * peer_total /\n+      inet_peer_threshold * 100;\n+  for (i = 0; i < 30 && !cleanup_once (ttl); i++);\n+}"}]}