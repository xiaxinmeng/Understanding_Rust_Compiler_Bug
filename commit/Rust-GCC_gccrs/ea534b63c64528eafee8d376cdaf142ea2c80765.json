{"sha": "ea534b63c64528eafee8d376cdaf142ea2c80765", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE1MzRiNjNjNjQ1MjhlYWZlZThkMzc2Y2RhZjE0MmVhMmM4MDc2NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-03T22:12:15Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-03T22:12:15Z"}, "message": "(convert_memory_address): New function.\n\n(memory_address): Call if it needed.\n(promote_mode, case POINTER_TYPE): Use Pmode and pointer extension.\n(allocate_dynamic_stack_space): Convert size from ptr_mode.\n\nFrom-SVN: r9304", "tree": {"sha": "31991151d1cb4fc5c94764fba5cfde60362d6b01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31991151d1cb4fc5c94764fba5cfde60362d6b01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea534b63c64528eafee8d376cdaf142ea2c80765", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea534b63c64528eafee8d376cdaf142ea2c80765", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea534b63c64528eafee8d376cdaf142ea2c80765", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea534b63c64528eafee8d376cdaf142ea2c80765/comments", "author": null, "committer": null, "parents": [{"sha": "ff0dbdd176ddd2bd1f40030e7adedb4d7e090fc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff0dbdd176ddd2bd1f40030e7adedb4d7e090fc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff0dbdd176ddd2bd1f40030e7adedb4d7e090fc1"}], "stats": {"total": 51, "additions": 50, "deletions": 1}, "files": [{"sha": "ac73f4b4afd1240c697853dcfe69fb5b89eeb3cc", "filename": "gcc/explow.c", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea534b63c64528eafee8d376cdaf142ea2c80765/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea534b63c64528eafee8d376cdaf142ea2c80765/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=ea534b63c64528eafee8d376cdaf142ea2c80765", "patch": "@@ -29,6 +29,9 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"insn-flags.h\"\n #include \"insn-codes.h\"\n \n+static rtx break_out_memory_refs\tPROTO((rtx));\n+static rtx convert_memory_address\tPROTO((rtx));\n+\n /* Return an rtx for the sum of X and the integer C.\n \n    This function should be used via the `plus_constant' macro.  */\n@@ -288,6 +291,38 @@ break_out_memory_refs (x)\n   return x;\n }\n \n+#ifdef POINTERS_EXTEND_UNSIGNED\n+\n+/* Given X, a memory address in ptr_mode, convert it to an address\n+   in Pmode.  We take advantage of the fact that pointers are not\n+   allowed to overflow by commuting arithmetic operations over\n+   conversions so that address arithmetic insns can be used.  */\n+\n+static rtx\n+convert_memory_address (x)\n+     rtx x;\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST:\n+      return x;\n+\n+    case PLUS:\n+    case MULT:\n+      return gen_rtx (GET_CODE (x), Pmode, \n+\t\t      convert_memory_address (XEXP (x, 0)),\n+\t\t      convert_memory_address (XEXP (x, 1)));\n+\n+    default:\n+      return convert_modes (Pmode, ptr_mode, x, POINTERS_EXTEND_UNSIGNED);\n+    }\n+}\n+#endif\n+\n /* Given a memory address or facsimile X, construct a new address,\n    currently equivalent, that is stable: future stores won't change it.\n \n@@ -338,6 +373,11 @@ memory_address (mode, x)\n {\n   register rtx oldx = x;\n \n+#ifdef POINTERS_EXTEND_UNSIGNED\n+  if (GET_MODE (x) == ptr_mode)\n+    x = convert_memory_address (x);\n+#endif\n+\n   /* By passing constant addresses thru registers\n      we get a chance to cse them.  */\n   if (! cse_not_expected && CONSTANT_P (x) && CONSTANT_ADDRESS_P (x))\n@@ -667,8 +707,12 @@ promote_mode (type, mode, punsignedp, for_call)\n       break;\n #endif\n \n+#ifdef POINTERS_EXTEND_UNSIGNED\n     case POINTER_TYPE:\n+      mode = Pmode;\n+      unsignedp = POINTERS_EXTEND_UNSIGNED;\n       break;\n+#endif\n     }\n \n   *punsignedp = unsignedp;\n@@ -1026,6 +1070,8 @@ allocate_dynamic_stack_space (size, target, known_align)\n       enum machine_mode mode\n \t= insn_operand_mode[(int) CODE_FOR_allocate_stack][0];\n \n+      size = convert_modes (mode, ptr_mode, size, 1);\n+\n       if (insn_operand_predicate[(int) CODE_FOR_allocate_stack][0]\n \t  && ! ((*insn_operand_predicate[(int) CODE_FOR_allocate_stack][0])\n \t\t(size, mode)))\n@@ -1035,7 +1081,10 @@ allocate_dynamic_stack_space (size, target, known_align)\n     }\n   else\n #endif\n-    anti_adjust_stack (size);\n+    {\n+      size = convert_modes (Pmode, ptr_mode, size, 1);\n+      anti_adjust_stack (size);\n+    }\n \n #ifdef STACK_GROWS_DOWNWARD\n   emit_move_insn (target, virtual_stack_dynamic_rtx);"}]}