{"sha": "84c54629c2fb6dae0e7d97a2c57e894899f2b944", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRjNTQ2MjljMmZiNmRhZTBlN2Q5N2EyYzU3ZTg5NDg5OWYyYjk0NA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-11-02T21:54:01Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-11-27T09:15:47Z"}, "message": "[Ada] Optimize generation of checks for fixed-point types\n\ngcc/ada/\n\n\t* checks.ads (Determine_Range_To_Discrete): New procedure.\n\t* checks.adb (Apply_Scalar_Range_Check): Call it to determine\n\ta range for the expression when the target type is discrete.\n\tAnd also apply the tests for discrete types to fixed-point\n\ttypes when they are treated as integers.\n\t(Apply_Type_Conversion_Checks): Apply checks to conversions\n\tinvolving fixed-point types when they are treated as integers.\n\t(Determine_Range) <N_Type_Conversion>: Factor out code into...\n\t(Determine_Range_To_Discrete): ...this new procedure and add\n\tsupport for fixed-point types when they are treated as integers.\n\t* einfo.ads (Type_High_Bound): Remove obsolete sentence.\n\t(Type_Low_Bound): Likewise.\n\t* exp_ch4.adb (Discrete_Range_Check): Remove obsolete code.\n\t(Real_Range_Check): Likewise.\n\t(Expand_N_Type_Conversion): In case of a no-op conversion, clear\n\tthe Do_Range_Check flag on the operand before substituting it.\n\tRemove calls to Real_Range_Check and Discrete_Range_Check that\n\tare not guarded by the Do_Range_Check flag, and an assertion.\n\t* sem_res.adb (Resolve_Type_Conversion): Always apply range\n\tchecks in GNATprove mode; in normal mode, use the updated type\n\tof the operand in the test against Universal_Fixed.  Remove\n\tobsolete code setting the Do_Range_Check flag at the end.", "tree": {"sha": "dde824100727d455c32afe4c3f0770b46f2b02ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dde824100727d455c32afe4c3f0770b46f2b02ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84c54629c2fb6dae0e7d97a2c57e894899f2b944", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84c54629c2fb6dae0e7d97a2c57e894899f2b944", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84c54629c2fb6dae0e7d97a2c57e894899f2b944", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84c54629c2fb6dae0e7d97a2c57e894899f2b944/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d1504186ee9d83fbc93f4b6880d55dcdd8daaff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d1504186ee9d83fbc93f4b6880d55dcdd8daaff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d1504186ee9d83fbc93f4b6880d55dcdd8daaff"}], "stats": {"total": 261, "additions": 139, "deletions": 122}, "files": [{"sha": "c7a33217064c10550cce38077f0a89f4fd54d6b4", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 111, "deletions": 77, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c54629c2fb6dae0e7d97a2c57e894899f2b944/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c54629c2fb6dae0e7d97a2c57e894899f2b944/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=84c54629c2fb6dae0e7d97a2c57e894899f2b944", "patch": "@@ -3258,23 +3258,16 @@ package body Checks is\n       end if;\n \n       --  Return if we know expression is definitely in the range of the target\n-      --  type as determined by Determine_Range. Right now we only do this for\n-      --  discrete types, and not fixed-point or floating-point types.\n-\n-      --  The additional less-precise tests below catch these cases\n-\n-      --  In GNATprove_Mode, also deal with the case of a conversion from\n-      --  floating-point to integer. It is only possible because analysis\n-      --  in GNATprove rules out the possibility of a NaN or infinite value.\n+      --  type as determined by Determine_Range_To_Discrete. Right now we only\n+      --  do this for discrete target types, i.e. neither for fixed-point nor\n+      --  for floating-point types. But the additional less precise tests below\n+      --  catch these cases.\n \n       --  Note: skip this if we are given a source_typ, since the point of\n       --  supplying a Source_Typ is to stop us looking at the expression.\n       --  We could sharpen this test to be out parameters only ???\n \n       if Is_Discrete_Type (Target_Typ)\n-        and then (Is_Discrete_Type (Etype (Expr))\n-                   or else (GNATprove_Mode\n-                             and then Is_Floating_Point_Type (Etype (Expr))))\n         and then not Is_Unconstrained_Subscr_Ref\n         and then No (Source_Typ)\n       then\n@@ -3318,35 +3311,8 @@ package body Checks is\n \n                   --  Otherwise determine range of value\n \n-                  if Is_Discrete_Type (Etype (Expr)) then\n-                     Determine_Range\n-                       (Expr, OK, Lo, Hi, Assume_Valid => True);\n-\n-                  --  When converting a float to an integer type, determine the\n-                  --  range in real first, and then convert the bounds using\n-                  --  UR_To_Uint which correctly rounds away from zero when\n-                  --  half way between two integers, as required by normal\n-                  --  Ada 95 rounding semantics. It is only possible because\n-                  --  analysis in GNATprove rules out the possibility of a NaN\n-                  --  or infinite value.\n-\n-                  elsif GNATprove_Mode\n-                    and then Is_Floating_Point_Type (Etype (Expr))\n-                  then\n-                     declare\n-                        Hir : Ureal;\n-                        Lor : Ureal;\n-\n-                     begin\n-                        Determine_Range_R\n-                          (Expr, OK, Lor, Hir, Assume_Valid => True);\n-\n-                        if OK then\n-                           Lo := UR_To_Uint (Lor);\n-                           Hi := UR_To_Uint (Hir);\n-                        end if;\n-                     end;\n-                  end if;\n+                  Determine_Range_To_Discrete\n+                    (Expr, OK, Lo, Hi, Fixed_Int, Assume_Valid => True);\n \n                   if OK then\n \n@@ -3389,10 +3355,12 @@ package body Checks is\n       --  Check if we can determine at compile time whether Expr is in the\n       --  range of the target type. Note that if S_Typ is within the bounds\n       --  of Target_Typ then this must be the case. This check is meaningful\n-      --  only if this is not a conversion between integer and real types.\n+      --  only if this is not a conversion between integer and real types,\n+      --  unless for a fixed-point type if Fixed_Int is set.\n \n       if not Is_Unconstrained_Subscr_Ref\n-        and then Is_Discrete_Type (S_Typ) = Is_Discrete_Type (Target_Typ)\n+        and then (Is_Discrete_Type (S_Typ) = Is_Discrete_Type (Target_Typ)\n+                   or else (Fixed_Int and then Is_Discrete_Type (Target_Typ)))\n         and then\n           (In_Subrange_Of (S_Typ, Target_Typ, Fixed_Int)\n \n@@ -3705,12 +3673,15 @@ package body Checks is\n                then\n                   Apply_Float_Conversion_Check (Expr, Target_Type);\n                else\n-                  --  Conversions involving fixed-point types are expanded\n-                  --  separately, and do not need a Range_Check flag, except\n-                  --  in GNATprove_Mode, where the explicit constraint check\n-                  --  will not be generated.\n+                  --  Raw conversions involving fixed-point types are expanded\n+                  --  separately and do not need a Range_Check flag yet, except\n+                  --  in GNATprove_Mode where this expansion is not performed.\n+                  --  This does not apply to conversion where fixed-point types\n+                  --  are treated as integers, which are precisely generated by\n+                  --  this expansion.\n \n                   if GNATprove_Mode\n+                    or else Conv_OK\n                     or else (not Is_Fixed_Point_Type (Expr_Type)\n                               and then not Is_Fixed_Point_Type (Target_Type))\n                   then\n@@ -5354,38 +5325,11 @@ package body Checks is\n             end case;\n \n          when N_Type_Conversion =>\n+            --  For a type conversion, we can try to refine the range using the\n+            --  converted value.\n \n-            --  For type conversion from one discrete type to another, we can\n-            --  refine the range using the converted value.\n-\n-            if Is_Discrete_Type (Etype (Expression (N))) then\n-               Determine_Range (Expression (N), OK1, Lor, Hir, Assume_Valid);\n-\n-            --  When converting a float to an integer type, determine the range\n-            --  in real first, and then convert the bounds using UR_To_Uint\n-            --  which correctly rounds away from zero when half way between two\n-            --  integers, as required by normal Ada 95 rounding semantics. It\n-            --  is only possible because analysis in GNATprove rules out the\n-            --  possibility of a NaN or infinite value.\n-\n-            elsif GNATprove_Mode\n-              and then Is_Floating_Point_Type (Etype (Expression (N)))\n-            then\n-               declare\n-                  Lor_Real, Hir_Real : Ureal;\n-               begin\n-                  Determine_Range_R (Expression (N), OK1, Lor_Real, Hir_Real,\n-                                     Assume_Valid);\n-\n-                  if OK1 then\n-                     Lor := UR_To_Uint (Lor_Real);\n-                     Hir := UR_To_Uint (Hir_Real);\n-                  end if;\n-               end;\n-\n-            else\n-               OK1 := False;\n-            end if;\n+            Determine_Range_To_Discrete\n+              (Expression (N), OK1, Lor, Hir, Conversion_OK (N), Assume_Valid);\n \n          --  Nothing special to do for all other expression kinds\n \n@@ -5905,6 +5849,96 @@ package body Checks is\n          end if;\n    end Determine_Range_R;\n \n+   ---------------------------------\n+   -- Determine_Range_To_Discrete --\n+   ---------------------------------\n+\n+   procedure Determine_Range_To_Discrete\n+     (N            : Node_Id;\n+      OK           : out Boolean;\n+      Lo           : out Uint;\n+      Hi           : out Uint;\n+      Fixed_Int    : Boolean := False;\n+      Assume_Valid : Boolean := False)\n+   is\n+      Typ : constant Entity_Id := Etype (N);\n+\n+   begin\n+      --  For a discrete type, simply defer to Determine_Range\n+\n+      if Is_Discrete_Type (Typ) then\n+         Determine_Range (N, OK, Lo, Hi, Assume_Valid);\n+\n+      --  For a fixed point type treated as an integer, we can determine the\n+      --  range using the Corresponding_Integer_Value of the bounds of the\n+      --  type or base type. This is done by the calls to Expr_Value below.\n+\n+      elsif Is_Fixed_Point_Type (Typ) and then Fixed_Int then\n+         declare\n+            Btyp, Ftyp : Entity_Id;\n+            Bound      : Node_Id;\n+\n+         begin\n+            if Assume_Valid then\n+               Ftyp := Typ;\n+            else\n+               Ftyp := Underlying_Type (Base_Type (Typ));\n+            end if;\n+\n+            Btyp := Base_Type (Ftyp);\n+\n+            --  First the low bound\n+\n+            Bound := Type_Low_Bound (Ftyp);\n+\n+            if Compile_Time_Known_Value (Bound) then\n+               Lo := Expr_Value (Bound);\n+            else\n+               Lo := Expr_Value (Type_Low_Bound (Btyp));\n+            end if;\n+\n+            --  Then the high bound\n+\n+            Bound := Type_High_Bound (Ftyp);\n+\n+            if Compile_Time_Known_Value (Bound) then\n+               Hi := Expr_Value (Bound);\n+            else\n+               Hi := Expr_Value (Type_High_Bound (Btyp));\n+            end if;\n+\n+            OK := True;\n+         end;\n+\n+      --  For a floating-point type, we can determine the range in real first,\n+      --  and then convert the bounds using UR_To_Uint, which correctly rounds\n+      --  away from zero when half way between two integers, as required by\n+      --  normal Ada 95 rounding semantics. But this is only possible because\n+      --  GNATprove's analysis rules out the possibility of a NaN or infinite.\n+\n+      elsif GNATprove_Mode and then Is_Floating_Point_Type (Typ) then\n+         declare\n+            Lo_Real, Hi_Real : Ureal;\n+\n+         begin\n+            Determine_Range_R (N, OK, Lo_Real, Hi_Real, Assume_Valid);\n+\n+            if OK then\n+               Lo := UR_To_Uint (Lo_Real);\n+               Hi := UR_To_Uint (Hi_Real);\n+            else\n+               Lo := No_Uint;\n+               Hi := No_Uint;\n+            end if;\n+         end;\n+\n+      else\n+         Lo := No_Uint;\n+         Hi := No_Uint;\n+         OK := False;\n+      end if;\n+   end Determine_Range_To_Discrete;\n+\n    ------------------------------------\n    -- Discriminant_Checks_Suppressed --\n    ------------------------------------"}, {"sha": "d75c6022097b51cbb4d4a2fcfd71dda1255f26a1", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c54629c2fb6dae0e7d97a2c57e894899f2b944/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c54629c2fb6dae0e7d97a2c57e894899f2b944/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=84c54629c2fb6dae0e7d97a2c57e894899f2b944", "patch": "@@ -338,6 +338,21 @@ package Checks is\n    --  For that to happen, the possibility of arguments of infinite or NaN\n    --  value should be taken into account, which is not the case currently.\n \n+   procedure Determine_Range_To_Discrete\n+     (N            : Node_Id;\n+      OK           : out Boolean;\n+      Lo           : out Uint;\n+      Hi           : out Uint;\n+      Fixed_Int    : Boolean := False;\n+      Assume_Valid : Boolean := False);\n+   --  Similar to Determine_Range, but attempts to return a discrete range even\n+   --  if N is not of a discrete type by doing a conversion. The Fixed_Int flag\n+   --  if set causes any fixed-point values to be treated as though they were\n+   --  discrete values (i.e. the underlying integer value is used), in which\n+   --  case no conversion is needed. At the current time, this is used only for\n+   --  discrete types, for fixed-point types if Fixed_Int is set, and also for\n+   --  floating-point types in GNATprove, see Determine_Range_R above.\n+\n    procedure Install_Null_Excluding_Check (N : Node_Id);\n    --  Determines whether an access node requires a run-time access check and\n    --  if so inserts the appropriate run-time check."}, {"sha": "a4b4f0fcf765aa59c3a7b3057e23fe0e48c5e801", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c54629c2fb6dae0e7d97a2c57e894899f2b944/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c54629c2fb6dae0e7d97a2c57e894899f2b944/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=84c54629c2fb6dae0e7d97a2c57e894899f2b944", "patch": "@@ -4596,15 +4596,13 @@ package Einfo is\n --       Applies to scalar types. Returns the tree node (Node_Id) that contains\n --       the high bound of a scalar type. The returned value is literal for a\n --       base type, but may be an expression in the case of scalar type with\n---       dynamic bounds. Note that in the case of a fixed point type, the high\n---       bound is in units of small, and is an integer.\n+--       dynamic bounds.\n \n --    Type_Low_Bound (synthesized)\n --       Applies to scalar types. Returns the tree node (Node_Id) that contains\n --       the low bound of a scalar type. The returned value is literal for a\n --       base type, but may be an expression in the case of scalar type with\n---       dynamic bounds. Note that in the case of a fixed point type, the low\n---       bound is in units of small, and is an integer.\n+--       dynamic bounds.\n \n --    Underlying_Full_View (Node19)\n --       Defined in private subtypes that are the completion of other private"}, {"sha": "efdc235aa00abe4c135f383859c366c6b73bc098", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c54629c2fb6dae0e7d97a2c57e894899f2b944/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c54629c2fb6dae0e7d97a2c57e894899f2b944/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=84c54629c2fb6dae0e7d97a2c57e894899f2b944", "patch": "@@ -11465,11 +11465,6 @@ package body Exp_Ch4 is\n       --  Start of processing for Discrete_Range_Check\n \n       begin\n-         --  Clear the Do_Range_Check flag on N if needed: this can occur when\n-         --  e.g. a trivial type conversion is rewritten by its expression.\n-\n-         Set_Do_Range_Check (N, False);\n-\n          --  Nothing more to do if conversion was rewritten\n \n          if Nkind (N) /= N_Type_Conversion then\n@@ -11478,12 +11473,6 @@ package body Exp_Ch4 is\n \n          Expr := Expression (N);\n \n-         --  Nothing to do if no range check flag set\n-\n-         if not Do_Range_Check (Expr) then\n-            return;\n-         end if;\n-\n          --  Clear the Do_Range_Check flag on Expr\n \n          Set_Do_Range_Check (Expr, False);\n@@ -11756,11 +11745,6 @@ package body Exp_Ch4 is\n          Tnn    : Entity_Id;\n \n       begin\n-         --  Clear the Do_Range_Check flag on N if needed: this can occur when\n-         --  e.g. a trivial type conversion is rewritten by its expression.\n-\n-         Set_Do_Range_Check (N, False);\n-\n          --  Nothing more to do if conversion was rewritten\n \n          if Nkind (N) /= N_Type_Conversion then\n@@ -12032,20 +12016,16 @@ package body Exp_Ch4 is\n       --  Nothing at all to do if conversion is to the identical type so remove\n       --  the conversion completely, it is useless, except that it may carry\n       --  an Assignment_OK attribute, which must be propagated to the operand\n-      --  and the Do_Range_Check flag on Operand should be taken into account.\n+      --  and the Do_Range_Check flag on the operand must be cleared, if any.\n \n       if Operand_Type = Target_Type then\n          if Assignment_OK (N) then\n             Set_Assignment_OK (Operand);\n          end if;\n \n-         Rewrite (N, Relocate_Node (Operand));\n-\n-         if Do_Range_Check (Operand) then\n-            pragma Assert (Is_Discrete_Type (Operand_Type));\n+         Set_Do_Range_Check (Operand, False);\n \n-            Discrete_Range_Check;\n-         end if;\n+         Rewrite (N, Relocate_Node (Operand));\n \n          goto Done;\n       end if;\n@@ -12468,16 +12448,11 @@ package body Exp_Ch4 is\n \n          if Is_Fixed_Point_Type (Target_Type) then\n             Expand_Convert_Fixed_To_Fixed (N);\n-            Real_Range_Check;\n-\n          elsif Is_Integer_Type (Target_Type) then\n             Expand_Convert_Fixed_To_Integer (N);\n-            Discrete_Range_Check;\n-\n          else\n             pragma Assert (Is_Floating_Point_Type (Target_Type));\n             Expand_Convert_Fixed_To_Float (N);\n-            Real_Range_Check;\n          end if;\n \n       --  Case of conversions to a fixed-point type\n@@ -12492,11 +12467,9 @@ package body Exp_Ch4 is\n       then\n          if Is_Integer_Type (Operand_Type) then\n             Expand_Convert_Integer_To_Fixed (N);\n-            Real_Range_Check;\n          else\n             pragma Assert (Is_Floating_Point_Type (Operand_Type));\n             Expand_Convert_Float_To_Fixed (N);\n-            Real_Range_Check;\n          end if;\n \n       --  Case of array conversions\n@@ -12656,8 +12629,6 @@ package body Exp_Ch4 is\n       --  Here at end of processing\n \n    <<Done>>\n-      pragma Assert (not Do_Range_Check (N));\n-\n       --  Apply predicate check if required. Note that we can't just call\n       --  Apply_Predicate_Check here, because the type looks right after\n       --  the conversion and it would omit the check. The Comes_From_Source"}, {"sha": "8256b8385f5467f195c10bd6e8302a6cc10e40b9", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c54629c2fb6dae0e7d97a2c57e894899f2b944/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c54629c2fb6dae0e7d97a2c57e894899f2b944/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=84c54629c2fb6dae0e7d97a2c57e894899f2b944", "patch": "@@ -11747,16 +11747,14 @@ package body Sem_Res is\n       Simplify_Type_Conversion (N);\n \n       --  If after evaluation we still have a type conversion, then we may need\n-      --  to apply checks required for a subtype conversion.\n-\n-      --  Skip these type conversion checks if universal fixed operands\n-      --  are involved, since range checks are handled separately for\n-      --  these cases (in the appropriate Expand routines in unit Exp_Fixd).\n+      --  to apply checks required for a subtype conversion. But skip them if\n+      --  universal fixed operands are involved, since range checks are handled\n+      --  separately for these cases, after the expansion done by Exp_Fixd.\n \n       if Nkind (N) = N_Type_Conversion\n         and then not Is_Generic_Type (Root_Type (Target_Typ))\n         and then Target_Typ /= Universal_Fixed\n-        and then Operand_Typ /= Universal_Fixed\n+        and then Etype (Operand) /= Universal_Fixed\n       then\n          Apply_Type_Conversion_Checks (N);\n       end if;\n@@ -11995,11 +11993,12 @@ package body Sem_Res is\n            (N, Target_Typ, Static_Failure_Is_Error => True);\n       end if;\n \n-      --  If at this stage we have a fixed point to integer conversion, make\n-      --  sure that the Do_Range_Check flag is set which is not always done\n-      --  by exp_fixd.adb.\n+      --  If at this stage we have a fixed to integer conversion, make sure the\n+      --  Do_Range_Check flag is set, because such conversions in general need\n+      --  a range check. We only need this if expansion is off, see above why.\n \n       if Nkind (N) = N_Type_Conversion\n+        and then not Expander_Active\n         and then Is_Integer_Type (Target_Typ)\n         and then Is_Fixed_Point_Type (Operand_Typ)\n         and then not Range_Checks_Suppressed (Target_Typ)"}]}