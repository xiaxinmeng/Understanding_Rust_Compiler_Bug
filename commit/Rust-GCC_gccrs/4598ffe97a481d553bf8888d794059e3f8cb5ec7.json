{"sha": "4598ffe97a481d553bf8888d794059e3f8cb5ec7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU5OGZmZTk3YTQ4MWQ1NTNiZjg4ODhkNzk0MDU5ZTNmOGNiNWVjNw==", "commit": {"author": {"name": "Catherine Moore", "email": "clm@redhat.com", "date": "2000-09-07T13:10:51Z"}, "committer": {"name": "Catherine Moore", "email": "clm@gcc.gnu.org", "date": "2000-09-07T13:10:51Z"}, "message": "unroll.c (unroll_loop): Check for unconditional jumps to loop continuation.\n\n        * unroll.c (unroll_loop): Check for unconditional jumps\n        to loop continuation.  Delete if n_iterations is 1.\n        (ujump_to_loop_cont): New routine.\n\nFrom-SVN: r36235", "tree": {"sha": "2dcd5b408e11f22df2a0bbc750dd91e6b361bd55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2dcd5b408e11f22df2a0bbc750dd91e6b361bd55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4598ffe97a481d553bf8888d794059e3f8cb5ec7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4598ffe97a481d553bf8888d794059e3f8cb5ec7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4598ffe97a481d553bf8888d794059e3f8cb5ec7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4598ffe97a481d553bf8888d794059e3f8cb5ec7/comments", "author": null, "committer": null, "parents": [{"sha": "f52c723967006d4c135e46bb3e2974e54657a5d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f52c723967006d4c135e46bb3e2974e54657a5d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f52c723967006d4c135e46bb3e2974e54657a5d8"}], "stats": {"total": 53, "additions": 53, "deletions": 0}, "files": [{"sha": "186abc4e9cd93d5e1294c39657bf095303bb6f5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4598ffe97a481d553bf8888d794059e3f8cb5ec7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4598ffe97a481d553bf8888d794059e3f8cb5ec7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4598ffe97a481d553bf8888d794059e3f8cb5ec7", "patch": "@@ -1,3 +1,9 @@\n+2000-09-07  Catherine Moore  <clm@redhat.com>\n+\n+        * unroll.c (unroll_loop): Check for unconditional jumps\n+        to loop continuation.  Delete if n_iterations is 1.\n+        (ujump_to_loop_cont): New routine.\n+\n 2000-09-07  Bernd Schmidt  <bernds@redhat.co.uk>\n \n \t* rtl.c (class_narrowest_mode): Add entries for MODE_VECTOR_INT and"}, {"sha": "36e6c57b9f81b4a127b98f15dab23debf5c99c3a", "filename": "gcc/unroll.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4598ffe97a481d553bf8888d794059e3f8cb5ec7/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4598ffe97a481d553bf8888d794059e3f8cb5ec7/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=4598ffe97a481d553bf8888d794059e3f8cb5ec7", "patch": "@@ -216,6 +216,7 @@ static rtx remap_split_bivs PARAMS ((rtx));\n static rtx find_common_reg_term PARAMS ((rtx, rtx));\n static rtx subtract_reg_term PARAMS ((rtx, rtx));\n static rtx loop_find_equiv_value PARAMS ((const struct loop *, rtx));\n+static rtx ujump_to_loop_cont PARAMS ((rtx, rtx));\n \n /* Try to unroll one loop and split induction variables in the loop.\n \n@@ -348,6 +349,14 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n \n   if (loop_info->n_iterations == 1)\n     {\n+      /* Handle the case where the loop begins with an unconditional\n+\t jump to the loop condition.  Make sure to delete the jump\n+\t insn, otherwise the loop body will never execute.  */\n+\n+      rtx ujump = ujump_to_loop_cont (loop->start, loop->cont);\n+      if (ujump)\n+\tdelete_insn (ujump);\n+\t\n       /* If number of iterations is exactly 1, then eliminate the compare and\n \t branch at the end of the loop since they will never be taken.\n \t Then return, since no other action is needed here.  */\n@@ -4152,3 +4161,41 @@ set_dominates_use (regno, first_uid, last_uid, copy_start, copy_end)\n   /* FIRST_UID is always executed if LAST_UID is executed.  */\n   return 1;\n }\n+\n+/* This routine is called when the number of iterations for the unrolled\n+   loop is one.   The goal is to identify a loop that begins with an\n+   unconditional branch to the loop continuation note (or a label just after).\n+   In this case, the unconditional branch that starts the loop needs to be\n+   deleted so that we execute the single iteration.  */\n+static rtx\n+ujump_to_loop_cont (loop_start, loop_cont)\n+      rtx loop_start;\n+      rtx loop_cont;\n+{\n+  rtx x, label, label_ref;\n+\n+  /* See if loop start, or the next insn is an unconditional jump.  */\n+  loop_start = next_nonnote_insn (loop_start);\n+\n+  x = pc_set (loop_start);\n+  if (!x)\n+    return NULL_RTX;\n+\n+  label_ref = SET_SRC (x);\n+  if (!label_ref)\n+    return NULL_RTX;\n+\n+  /* Examine insn after loop continuation note.  Return if not a label.  */\n+  label = next_nonnote_insn (loop_cont);\n+  if (label == 0 || GET_CODE (label) != CODE_LABEL)\n+    return NULL_RTX;\n+\n+  /* Return the loop start if the branch label matches the code label.  */\n+  if (CODE_LABEL_NUMBER (label) == CODE_LABEL_NUMBER (XEXP (label_ref,0)))\n+    return loop_start;\n+  else\n+    return NULL_RTX;\n+\n+}\n+\n+"}]}