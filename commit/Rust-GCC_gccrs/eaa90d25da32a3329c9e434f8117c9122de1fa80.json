{"sha": "eaa90d25da32a3329c9e434f8117c9122de1fa80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFhOTBkMjVkYTMyYTMzMjljOWU0MzRmODExN2M5MTIyZGUxZmE4MA==", "commit": {"author": {"name": "Thomas Koenig", "email": "Thomas.Koenig@online.de", "date": "2006-02-06T20:12:44Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2006-02-06T20:12:44Z"}, "message": "re PR fortran/23815 (Add -byteswapio flag)\n\n2005-02-06  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR libfortran/23815\n\t* gfortran.texi: Document the GFORTRAN_CONVERT_UNIT environment\n\tvariable.\n\t* invoke.texi:  Mention the \"Runtime\" chapter.\n\tDocument the -fconvert= option.\n\t* gfortran.h:  Add options_convert.\n\t* lang.opt:  Add fconvert=little-endian, fconvert=big-endian,\n\tfconvert=native and fconvert=swap.\n\t* trans-decl.c (top level):  Add gfor_fndecl_set_convert.\n\t(gfc_build_builtin_function_decls):  Set gfor_fndecl_set_convert.\n\t(gfc_generate_function_code):  If -fconvert was specified,\n\tand this is the main program, add a call to set_convert().\n\t* options.c:  Handle the -fconvert options.\n\n2005-02-06  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR libfortran/23815\n\t* runtime/environ.c (init_unformatted):  Add GFORTRAN_CONVERT_UNIT\n\tenvironment variable.\n\t(top level):  Add defines, type and static variables for\n\tGFORTRAN_CONVERT_UNIT handling.\n\t(search_unit):  New function.\n\t(match_word): New function.\n\t(match_integer): New function.\n\t(next_token): New function.\n\t(push_token): New function.\n\t(mark_single): New function.\n\t(mark_range): New funciton.\n\t(do_parse): New function.\n\t(init_unformatted): New function.\n\t(get_unformatted_convert): New function.\n\t* runtime/compile_options.c:  Add set_convert().\n\t* libgfortran.h:  Add convert to compile_options_t.\n\t* io/open.c (st_open): Call get_unformatted_convert to get\n\tunit default; if CONVERT_NONE is returned, check for\n\tthe presence of a CONVERT specifier and use it.\n\tAs default, use compile_options.convert.\n\t* io/io.h (top level): Add CONVERT_NONE to unit_convert, to signal\n\t\"nothing has been set\".\n\t(top level): Add prototype for get_unformatted_convert.\n\n2005-02-06  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR libfortran/23815\n\t* unf_io_convert_4.f90:  New test.\n\nFrom-SVN: r110664", "tree": {"sha": "26ecd24fc3063b5ecd6f0ba237736b4549d61fd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26ecd24fc3063b5ecd6f0ba237736b4549d61fd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaa90d25da32a3329c9e434f8117c9122de1fa80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaa90d25da32a3329c9e434f8117c9122de1fa80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaa90d25da32a3329c9e434f8117c9122de1fa80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaa90d25da32a3329c9e434f8117c9122de1fa80/comments", "author": null, "committer": null, "parents": [{"sha": "431ef78e8e7568263dbd2b56d55460c5b0b45c6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/431ef78e8e7568263dbd2b56d55460c5b0b45c6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/431ef78e8e7568263dbd2b56d55460c5b0b45c6e"}], "stats": {"total": 769, "additions": 733, "deletions": 36}, "files": [{"sha": "66f638f6301470d6e9915b50a500d2fdf821e87d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa90d25da32a3329c9e434f8117c9122de1fa80/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa90d25da32a3329c9e434f8117c9122de1fa80/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=eaa90d25da32a3329c9e434f8117c9122de1fa80", "patch": "@@ -1,3 +1,19 @@\n+2005-02-06  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/23815\n+\t* gfortran.texi: Document the GFORTRAN_CONVERT_UNIT environment\n+\tvariable.\n+\t* invoke.texi:  Mention the \"Runtime\" chapter.\n+\tDocument the -fconvert= option.\n+\t* gfortran.h:  Add options_convert.\n+\t* lang.opt:  Add fconvert=little-endian, fconvert=big-endian,\n+\tfconvert=native and fconvert=swap.\n+\t* trans-decl.c (top level):  Add gfor_fndecl_set_convert.\n+\t(gfc_build_builtin_function_decls):  Set gfor_fndecl_set_convert.\n+\t(gfc_generate_function_code):  If -fconvert was specified,\n+\tand this is the main program, add a call to set_convert().\n+\t* options.c:  Handle the -fconvert options.\n+\n 2006-02-06  Roger Sayle  <roger@eyesopen.com>\n \n \t* trans-stmt.c (gfc_evaluate_where_mask): Allow the NMASK argument"}, {"sha": "31d5a4eca0e3735a97d0c14e71bc49969bad2583", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa90d25da32a3329c9e434f8117c9122de1fa80/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa90d25da32a3329c9e434f8117c9122de1fa80/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=eaa90d25da32a3329c9e434f8117c9122de1fa80", "patch": "@@ -111,6 +111,12 @@ mstring;\n #define GFC_FPE_UNDERFLOW  (1<<4)\n #define GFC_FPE_PRECISION  (1<<5)\n \n+/* Keep this in sync with libgfortran/io/io.h ! */\n+\n+typedef enum\n+  { CONVERT_NATIVE=0, CONVERT_SWAP, CONVERT_BIG, CONVERT_LITTLE }\n+options_convert;\n+\n \n /*************************** Enums *****************************/\n \n@@ -1531,6 +1537,7 @@ typedef struct\n   int allow_std;\n   int warn_nonstd_intrinsics;\n   int fshort_enums;\n+  int convert;\n }\n gfc_option_t;\n "}, {"sha": "65a2542de6edcecb345ce06c81e41c8403aa4350", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 89, "deletions": 7, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa90d25da32a3329c9e434f8117c9122de1fa80/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa90d25da32a3329c9e434f8117c9122de1fa80/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=eaa90d25da32a3329c9e434f8117c9122de1fa80", "patch": "@@ -125,6 +125,7 @@ not accurately reflect the status of the most recent @command{gfortran}.\n * Project Status::       Status of @command{gfortran}, roadmap, proposed extensions.\n * Contributing::         How you can help.\n * Standards::\t         Standards supported by @command{gfortran}\n+* Runtime::              Influencing runtime behavior with environment variables.\n * Extensions::           Language extensions implemented by @command{gfortran}\n * Intrinsic Procedures:: Intrinsic procedures supported by @command{gfortran}\n * Copying::              GNU General Public License says\n@@ -545,13 +546,82 @@ Environment variable for temporary file directory.\n @item\n Environment variable forcing standard output to be line buffered (unix).\n \n-@item\n-Variable for swapping endianness during unformatted read.\n+@end itemize\n \n-@item\n-Variable for swapping Endianness during unformatted write.\n+@node Runtime\n+@chapter Runtime:  Influencing runtime behavior with environment variables\n+@cindex Runtime\n+\n+The behaviour of the @command{gfortran} can be influenced by\n+environment variables.\n+@menu\n+* GFORTRAN_CONVERT_UNIT::  Set endianness for unformatted I/O\n+@end menu\n+\n+@node GFORTRAN_CONVERT_UNIT\n+@section GFORTRAN_CONVERT_UNIT --- Set endianness for unformatted I/O\n+\n+By setting the @code{GFORTRAN_CONVERT_UNIT variable}, it is possible\n+to change the representation of data for unformatted files.\n+The syntax for the @code{GFORTRAN_CONVERT_UNIT} variable is:\n+@smallexample\n+GFORTRAN_CONVERT_UNIT: mode | mode ';' exception ;\n+mode: 'native' | 'swap' | 'big_endian' | 'little_endian' ;\n+exception: mode ':' unit_list | unit_list ;\n+unit_list: unit_spec | unit_list unit_spec ;\n+unit_spec: INTEGER | INTEGER '-' INTEGER ;\n+@end smallexample\n+The variable consists of an optional default mode, followed by\n+a list of optional exceptions, which are separated by semicolons\n+from the preceding default and each other.  Each exception consists\n+of a format and a comma-separated list of units.  Valid values for\n+the modes are the same as for the @code{CONVERT} specifier:\n+\n+@itemize @w{}\n+@item @code{NATIVE} Use the native format.  This is the default.\n+@item @code{SWAP} Swap between little- and big-endian.\n+@item @code{LITTLE_ENDIAN} Use the little-endian format\n+        for unformatted files.\n+@item @code{BIG_ENDIAN} Use the big-endian format for unformatted files.\n+@end itemize\n+A missing mode for an exception is taken to mean @code{BIG_ENDIAN}.\n+Examples of values for @code{GFORTRAN_CONVERT_UNIT} are:\n+@itemize @w{}\n+@item @code{'big_endian'}  Do all unformatted I/O in big_endian mode.\n+@item @code{'little_endian;native:10-20,25'}  Do all unformatted I/O \n+in little_endian mode, except for units 10 to 20 and 25, which are in\n+native format.\n+@item @code{'10-20'}  Units 10 to 20 are big-endian, the rest is native.\n @end itemize\n \n+Setting the environment variables should be done on the command\n+line or via the @code{export}\n+command for @code{sh}-compatible shells and via @code{setenv}\n+for @code{csh}-compatible shells.\n+\n+Example for @code{sh}:\n+@smallexample\n+$ gfortran foo.f90\n+$ GFORTRAN_CONVERT_UNIT='big_endian;native:10-20' ./a.out\n+@end smallexample\n+\n+Example code for @code{csh}:\n+@smallexample\n+% gfortran foo.f90\n+% setenv GFORTRAN_CONVERT_UNIT 'big_endian;native:10-20'\n+% ./a.out\n+@end smallexample\n+\n+Using anything but the native representation for unformatted data\n+carries a significant speed overhead.  If speed in this area matters\n+to you, it is best if you use this only for data that needs to be\n+portable.\n+\n+@xref{CONVERT specifier}, for an alternative way to specify the\n+data representation for unformatted files.  @xref{Runtime Options}, for\n+setting a default data representation for the whole program.  The\n+@code{CONVERT} specifier overrides the @code{-fconvert} compile options.\n+\n @c ---------------------------------------------------------------------\n @c Extensions\n @c ---------------------------------------------------------------------\n@@ -937,16 +1007,18 @@ will not change the base address of the array that was passed.\n \n gfortran allows the conversion of unformatted data between little-\n and big-endian representation to facilitate moving of data\n-between different systems.  The conversion is indicated with\n+between different systems.  The conversion can be indicated with\n the @code{CONVERT} specifier on the @code{OPEN} statement.\n+@xref{GFORTRAN_CONVERT_UNIT}, for an alternative way of specifying\n+the data format via an environment variable.\n \n Valid values for @code{CONVERT} are:\n @itemize @w{}\n @item @code{CONVERT='NATIVE'} Use the native format.  This is the default.\n @item @code{CONVERT='SWAP'} Swap between little- and big-endian.\n-@item @code{CONVERT='LITTLE_ENDIAN'} Use the little-endian format\n+@item @code{CONVERT='LITTLE_ENDIAN'} Use the little-endian representation\n         for unformatted files.\n-@item @code{CONVERT='BIG_ENDIAN'} Use the big-endian format for\n+@item @code{CONVERT='BIG_ENDIAN'} Use the big-endian representation for\n         unformatted files.\n @end itemize\n \n@@ -967,6 +1039,16 @@ on IEEE systems of kinds 4 and 8.  Conversion between different\n m68k and x86_64, which gfortran\n supports as @code{REAL(KIND=10)} will probably not work.\n \n+@emph{Note that the values specified via the GFORTRAN_CONVERT_UNIT\n+environment variable will override the CONVERT specifier in the\n+open statement}.  This is to give control over data formats to\n+a user who does not have the source code of his program available.\n+\n+Using anything but the native representation for unformatted data\n+carries a significant speed overhead.  If speed in this area matters\n+to you, it is best if you use this only for data that needs to be\n+portable.\n+\n @c ---------------------------------------------------------------------\n @include intrinsic.texi\n @c ---------------------------------------------------------------------"}, {"sha": "8d7a1d52f1133ce4e959c3daa6d2b8cd662005e2", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa90d25da32a3329c9e434f8117c9122de1fa80/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa90d25da32a3329c9e434f8117c9122de1fa80/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=eaa90d25da32a3329c9e434f8117c9122de1fa80", "patch": "@@ -98,6 +98,7 @@ one is not the default.\n * Warning Options::     How picky should the compiler be?\n * Debugging Options::   Symbol tables, measurements, and debugging dumps.\n * Directory Options::   Where to find module files\n+* Runtime Options::     Influencing runtime behavior\n * Code Gen Options::    Specifying conventions for function calls, data layout\n                         and register usage.\n * Environment Variables:: Env vars that affect GNU Fortran.\n@@ -141,6 +142,11 @@ by type.  Explanations are in the following sections.\n @gccoptlist{\n -I@var{dir}  -M@var{dir}}\n \n+@item Runtime Options\n+@xref{Runtime Options,,Options for influencing runtime behavior}.\n+@gccoptlist{\n+-fconvert=@var{conversion}}\n+\n @item Code Generation Options\n @xref{Code Gen Options,,Options for Code Generation Conventions}.\n @gccoptlist{\n@@ -155,6 +161,7 @@ by type.  Explanations are in the following sections.\n * Warning Options::     How picky should the compiler be?\n * Debugging Options::   Symbol tables, measurements, and debugging dumps.\n * Directory Options::   Where to find module files\n+* Runtime Options::     Influencing runtime behavior\n * Code Gen Options::    Specifying conventions for function calls, data layout\n                         and register usage.\n @end menu\n@@ -557,6 +564,25 @@ The default is the current directory.\n GCC options.\n @end table\n \n+@node Runtime Options\n+@section Influencing runtime behavior\n+@cindex runtime, options\n+\n+These options affect the runtime behavior of @command{gfortran}.\n+@table @gcctabopt\n+@cindex -fconvert=@var{conversion} option\n+@item -fconvert=@var{conversion}\n+Specify the representation of data for unformatted files.  Valid\n+values for conversion are: @samp{native}, the default; @samp{swap},\n+swap between big- and little-endian; @samp{big-endian}, use big-endian\n+representation for unformatted files; @samp{little-endian}, use little-endian\n+representation for unformatted files.\n+\n+@emph{This option has an effect only when used in the main program.\n+The @code{CONVERT} specifier and the GFORTRAN_CONVERT_UNIT environment\n+variable override the default specified by -fconvert.}\n+@end table\n+\n @node Code Gen Options\n @section Options for Code Generation Conventions\n @cindex code generation, conventions\n@@ -796,4 +822,6 @@ that affect the operation of @command{gcc}.\n gcc,Using the GNU Compiler Collection (GCC)}, for information on environment\n variables.\n \n+@xref{Runtime}, for environment variables that affect the\n+run-time behavior of @command{gfortran} programs.\n @c man end"}, {"sha": "5ce2934f590d24d1f037bb285b7e9edcd58c4218", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa90d25da32a3329c9e434f8117c9122de1fa80/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa90d25da32a3329c9e434f8117c9122de1fa80/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=eaa90d25da32a3329c9e434f8117c9122de1fa80", "patch": "@@ -205,4 +205,20 @@ fshort-enums\n Fortran\n Use the narrowest integer type possible for enumeration types\n \n+fconvert=little-endian\n+Fortran RejectNegative\n+Use little-endian format for unformatted files\n+\n+fconvert=big-endian\n+Fortran RejectNegative\n+Use big-endian format for unformatted files\n+\n+fconvert=native\n+Fortran RejectNegative\n+Use native format for unformatted files\n+\n+fconvert=swap\n+Fortran RejectNegative\n+Swap endianness for unformatted files\n+\n ; This comment is to ensure we retain the blank line above."}, {"sha": "0b2f7b36f21fd495afaa6a7194b10c9d0054b99d", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa90d25da32a3329c9e434f8117c9122de1fa80/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa90d25da32a3329c9e434f8117c9122de1fa80/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=eaa90d25da32a3329c9e434f8117c9122de1fa80", "patch": "@@ -573,6 +573,22 @@ gfc_handle_option (size_t scode, const char *arg, int value)\n     case OPT_fshort_enums:\n       gfc_option.fshort_enums = 1;\n       break;\n+\n+    case OPT_fconvert_little_endian:\n+      gfc_option.convert = CONVERT_LITTLE;\n+      break;\n+\n+    case OPT_fconvert_big_endian:\n+      gfc_option.convert = CONVERT_BIG;\n+      break;\n+\n+    case OPT_fconvert_native:\n+      gfc_option.convert = CONVERT_NATIVE;\n+      break;\n+\n+    case OPT_fconvert_swap:\n+      gfc_option.convert = CONVERT_SWAP;\n+      break;\n     }\n \n   return result;"}, {"sha": "4811b7a1d6038aa82e2f5449582f7bdb5c0ebe67", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa90d25da32a3329c9e434f8117c9122de1fa80/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa90d25da32a3329c9e434f8117c9122de1fa80/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=eaa90d25da32a3329c9e434f8117c9122de1fa80", "patch": "@@ -88,6 +88,7 @@ tree gfor_fndecl_select_string;\n tree gfor_fndecl_runtime_error;\n tree gfor_fndecl_set_fpe;\n tree gfor_fndecl_set_std;\n+tree gfor_fndecl_set_convert;\n tree gfor_fndecl_ctime;\n tree gfor_fndecl_fdate;\n tree gfor_fndecl_ttynam;\n@@ -2229,6 +2230,10 @@ gfc_build_builtin_function_decls (void)\n \t\t\t\t    gfc_int4_type_node,\n \t\t\t\t    gfc_int4_type_node);\n \n+  gfor_fndecl_set_convert =\n+    gfc_build_library_function_decl (get_identifier (PREFIX(\"set_convert\")),\n+\t\t\t\t     void_type_node, 1, gfc_c_int_type_node);\n+\n   gfor_fndecl_in_pack = gfc_build_library_function_decl (\n         get_identifier (PREFIX(\"internal_pack\")),\n         pvoid_type_node, 1, pvoid_type_node);\n@@ -2845,6 +2850,22 @@ gfc_generate_function_code (gfc_namespace * ns)\n       gfc_add_expr_to_block (&body, tmp);\n     }\n \n+  /* If this is the main program and an -fconvert option was provided,\n+     add a call to set_convert.  */\n+\n+  if (sym->attr.is_main_program && gfc_option.convert != CONVERT_NATIVE)\n+    {\n+      tree arglist, gfc_c_int_type_node;\n+\n+      gfc_c_int_type_node = gfc_get_int_type (gfc_c_int_kind);\n+      arglist = gfc_chainon_list (NULL_TREE,\n+\t\t\t\t  build_int_cst (gfc_c_int_type_node,\n+\t\t\t\t\t\t gfc_option.convert));\n+      tmp = build_function_call_expr (gfor_fndecl_set_convert, arglist);\n+      gfc_add_expr_to_block (&body, tmp);\n+    }\n+\n+\n   if (TREE_TYPE (DECL_RESULT (fndecl)) != void_type_node\n       && sym->attr.subroutine)\n     {"}, {"sha": "3262a6ab82ef26602edfb7dac970fe2e8d9a7e45", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa90d25da32a3329c9e434f8117c9122de1fa80/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa90d25da32a3329c9e434f8117c9122de1fa80/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eaa90d25da32a3329c9e434f8117c9122de1fa80", "patch": "@@ -1,3 +1,8 @@\n+2005-02-06  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/23815\n+\t* unf_io_convert_4.f90:  New test.\n+\n 2006-02-06  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* gcc.dg/tree-ssa/loadpre10.c: New test."}, {"sha": "88cb78ff0b5146865ba770a6807472593046dede", "filename": "gcc/testsuite/gfortran.dg/unf_io_convert_4.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa90d25da32a3329c9e434f8117c9122de1fa80/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_io_convert_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa90d25da32a3329c9e434f8117c9122de1fa80/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_io_convert_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funf_io_convert_4.f90?ref=eaa90d25da32a3329c9e434f8117c9122de1fa80", "patch": "@@ -0,0 +1,14 @@\n+!  { dg-do run }\n+!  { dg-options \"-fconvert=big-endian\" }\n+program main\n+  character (len=30) ch\n+  open (10,form=\"unformatted\",convert=\"little_endian\") \n+  inquire (10, convert=ch) \n+  if (ch .ne. \"LITTLE_ENDIAN\") call abort\n+  close (10, status=\"delete\")\n+\n+  open(11,form=\"unformatted\")\n+  inquire (11, convert=ch)\n+  if (ch .ne. \"BIG_ENDIAN\") call abort\n+  close (11, status=\"delete\")\n+end program main"}, {"sha": "4bcdb84667de1f78f09f656ee0b4c4169aa797ef", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa90d25da32a3329c9e434f8117c9122de1fa80/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa90d25da32a3329c9e434f8117c9122de1fa80/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=eaa90d25da32a3329c9e434f8117c9122de1fa80", "patch": "@@ -1,3 +1,30 @@\n+2005-02-06  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/23815\n+\t* runtime/environ.c (init_unformatted):  Add GFORTRAN_CONVERT_UNIT\n+\tenvironment variable.\n+\t(top level):  Add defines, type and static variables for\n+\tGFORTRAN_CONVERT_UNIT handling.\n+\t(search_unit):  New function.\n+\t(match_word): New function.\n+\t(match_integer): New function.\n+\t(next_token): New function.\n+\t(push_token): New function.\n+\t(mark_single): New function.\n+\t(mark_range): New funciton.\n+\t(do_parse): New function.\n+\t(init_unformatted): New function.\n+\t(get_unformatted_convert): New function.\n+\t* runtime/compile_options.c:  Add set_convert().\n+\t* libgfortran.h:  Add convert to compile_options_t.\n+\t* io/open.c (st_open): Call get_unformatted_convert to get\n+\tunit default; if CONVERT_NONE is returned, check for\n+\tthe presence of a CONVERT specifier and use it.\n+\tAs default, use compile_options.convert.\n+\t* io/io.h (top level): Add CONVERT_NONE to unit_convert, to signal\n+\t\"nothing has been set\".\n+\t(top level): Add prototype for get_unformatted_convert.\n+\n 2006-02-06  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR libfortran/24685"}, {"sha": "31b4927cb6e64220377f2a6d69e8ba58b9334724", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa90d25da32a3329c9e434f8117c9122de1fa80/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa90d25da32a3329c9e434f8117c9122de1fa80/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=eaa90d25da32a3329c9e434f8117c9122de1fa80", "patch": "@@ -207,7 +207,7 @@ typedef enum\n unit_mode;\n \n typedef enum\n-{ CONVERT_NATIVE, CONVERT_SWAP, CONVERT_BIG, CONVERT_LITTLE }\n+{ CONVERT_NONE=-1, CONVERT_NATIVE, CONVERT_SWAP, CONVERT_BIG, CONVERT_LITTLE }\n unit_convert;\n \n #define CHARACTER1(name) \\\n@@ -884,3 +884,8 @@ dec_waiting_unlocked (gfc_unit *u)\n }\n \n #endif\n+\n+/* ../runtime/environ.c  This is here because we return unit_convert.  */\n+\n+unit_convert get_unformatted_convert (int);\n+internal_proto(get_unformatted_convert);"}, {"sha": "1459f8f310ae6f7da0528286a06e77944e6db698", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa90d25da32a3329c9e434f8117c9122de1fa80/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa90d25da32a3329c9e434f8117c9122de1fa80/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=eaa90d25da32a3329c9e434f8117c9122de1fa80", "patch": "@@ -502,6 +502,7 @@ st_open (st_parameter_open *opp)\n   unit_flags flags;\n   gfc_unit *u = NULL;\n   GFC_INTEGER_4 cf = opp->common.flags;\n+  unit_convert conv;\n  \n   library_start (&opp->common);\n \n@@ -539,35 +540,44 @@ st_open (st_parameter_open *opp)\n     find_option (&opp->common, opp->status, opp->status_len,\n \t\t status_opt, \"Bad STATUS parameter in OPEN statement\");\n \n-  if (cf & IOPARM_OPEN_HAS_CONVERT)\n+  /* First, we check wether the convert flag has been set via environment\n+     variable.  This overrides the convert tag in the open statement.  */\n+\n+  conv = get_unformatted_convert (opp->common.unit);\n+\n+  if (conv == CONVERT_NONE)\n     {\n-      unit_convert conv;\n-      conv = find_option (&opp->common, opp->convert, opp->convert_len,\n-\t\t\t  convert_opt, \"Bad CONVERT parameter in OPEN statement\");\n-      /* We use l8_to_l4_offset, which is 0 on little-endian machines\n- \t and 1 on big-endian machines.  */\n-      switch (conv)\n- \t{\n- \tcase CONVERT_NATIVE:\n- \tcase CONVERT_SWAP:\n- \t  break;\n-\t  \n- \tcase CONVERT_BIG:\n- \t  conv = l8_to_l4_offset ? CONVERT_NATIVE : CONVERT_SWAP;\n- \t  break;\n-\t  \n- \tcase CONVERT_LITTLE:\n- \t  conv = l8_to_l4_offset ? CONVERT_SWAP : CONVERT_NATIVE;\n- \t  break;\n- \n- \tdefault:\n- \t  internal_error (&opp->common,\t\"Illegal value for CONVERT\");\n- \t  break;\n- \t}\n-      flags.convert = conv;\n+      /* Nothing has been set by environment variable, check the convert tag.  */\n+      if (cf & IOPARM_OPEN_HAS_CONVERT)\n+\tconv = find_option (&opp->common, opp->convert, opp->convert_len,\n+\t\t\t    convert_opt,\n+\t\t\t    \"Bad CONVERT parameter in OPEN statement\");\n+      else\n+\tconv = compile_options.convert;\n     }\n-  else\n-    flags.convert = CONVERT_NATIVE;\n+  \n+  /* We use l8_to_l4_offset, which is 0 on little-endian machines\n+     and 1 on big-endian machines.  */\n+  switch (conv)\n+    {\n+    case CONVERT_NATIVE:\n+    case CONVERT_SWAP:\n+      break;\n+      \n+    case CONVERT_BIG:\n+      conv = l8_to_l4_offset ? CONVERT_NATIVE : CONVERT_SWAP;\n+      break;\n+      \n+    case CONVERT_LITTLE:\n+      conv = l8_to_l4_offset ? CONVERT_SWAP : CONVERT_NATIVE;\n+      break;\n+      \n+    default:\n+      internal_error (&opp->common, \"Illegal value for CONVERT\");\n+      break;\n+    }\n+\n+  flags.convert = conv;\n \n   if (opp->common.unit < 0)\n     generate_error (&opp->common, ERROR_BAD_OPTION,"}, {"sha": "fac9b4ab328b19cc5ee2850533064cc32c2126fb", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa90d25da32a3329c9e434f8117c9122de1fa80/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa90d25da32a3329c9e434f8117c9122de1fa80/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=eaa90d25da32a3329c9e434f8117c9122de1fa80", "patch": "@@ -336,6 +336,7 @@ typedef struct\n {\n   int warn_std;\n   int allow_std;\n+  int convert;\n }\n compile_options_t;\n "}, {"sha": "e2a2ffa4c802534052f1133682f1fe12f1d29aa9", "filename": "libgfortran/runtime/compile_options.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa90d25da32a3329c9e434f8117c9122de1fa80/libgfortran%2Fruntime%2Fcompile_options.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa90d25da32a3329c9e434f8117c9122de1fa80/libgfortran%2Fruntime%2Fcompile_options.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fcompile_options.c?ref=eaa90d25da32a3329c9e434f8117c9122de1fa80", "patch": "@@ -59,3 +59,15 @@ init_compile_options (void)\n   compile_options.allow_std = GFC_STD_F95_OBS | GFC_STD_F95_DEL\n     | GFC_STD_F2003 | GFC_STD_F95 | GFC_STD_F77 | GFC_STD_GNU | GFC_STD_LEGACY;\n }\n+\n+/* Function called by the front-end to tell us the\n+   default for unformatted data conversion.  */\n+\n+extern void set_convert (int);\n+export_proto (set_convert);\n+\n+void\n+set_convert (int conv)\n+{\n+  compile_options.convert = conv;\n+}"}, {"sha": "c519f0845737f3260fb28edd8b4d635ff107ad14", "filename": "libgfortran/runtime/environ.c", "status": "modified", "additions": 438, "deletions": 1, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaa90d25da32a3329c9e434f8117c9122de1fa80/libgfortran%2Fruntime%2Fenviron.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaa90d25da32a3329c9e434f8117c9122de1fa80/libgfortran%2Fruntime%2Fenviron.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fenviron.c?ref=eaa90d25da32a3329c9e434f8117c9122de1fa80", "patch": "@@ -61,8 +61,9 @@ typedef struct variable\n }\n variable;\n \n+static void init_unformatted (variable *);\n \n-/* print_spaces()-- Print a particular number of spaces */\n+/* print_spaces()-- Print a particular number of spaces.  */\n \n static void\n print_spaces (int n)\n@@ -533,6 +534,11 @@ static variable variable_table[] = {\n    show_precision,\n    \"Precision of intermediate results.  Values are 24, 53 and 64.\", 0},\n \n+  /* GFORTRAN_CONVERT_UNIT - Set the default data conversion for\n+   unformatted I/O.  */\n+  {\"GFORTRAN_CONVERT_UNIT\", 0, 0, init_unformatted, show_string,\n+   \"Set format for unformatted files\", 0},\n+\n   {NULL, 0, NULL, NULL, NULL, NULL, 0}\n };\n \n@@ -623,3 +629,434 @@ show_variables (void)\n \n   sys_exit (0);\n }\n+\n+/* This is the handling of the GFORTRAN_CONVERT_UNITS environment variable.\n+   It is called from environ.c to parse this variable, and from\n+   open.c to determine if the user specified a default for an\n+   unformatted file.\n+   The syntax of the environment variable is, in bison grammar:\n+\n+   GFORTRAN_CONVERT_UNITS: mode | mode ';' exception ;\n+   mode: 'native' | 'swap' | 'big_endian' | 'little_endian' ;\n+   exception: mode ':' unit_list | unit_list ;\n+   unit_list: unit_spec | unit_list unit_spec ;\n+   unit_spec: INTEGER | INTEGER '-' INTEGER ;\n+*/\n+\n+/* Defines for the tokens.  Other valid tokens are ',', ':', '-'.  */\n+\n+\n+#define NATIVE   257\n+#define SWAP     258\n+#define BIG      259\n+#define LITTLE   260\n+/* Some space for additional tokens later.  */\n+#define INTEGER  273\n+#define END      (-1)\n+#define ILLEGAL  (-2)\n+\n+typedef struct\n+{\n+  int unit;\n+  unit_convert conv;\n+} exception_t;\n+\n+\n+static char *p;            /* Main character pointer for parsing.  */\n+static char *lastpos;      /* Auxiliary pointer, for backing up.  */\n+static int unit_num;       /* The last unit number read.  */\n+static int unit_count;     /* The number of units found. */\n+static int do_count;       /* Parsing is done twice - first to count the number\n+\t\t\t      of units, then to fill in the table.  This\n+\t\t\t      variable controls what to do.  */\n+static exception_t *elist; /* The list of exceptions to the default. This is\n+\t\t\t      sorted according to unit number.  */\n+static int n_elist;        /* Number of exceptions to the default.  */\n+\n+static unit_convert endian; /* Current endianness.  */\n+\n+static unit_convert def; /* Default as specified (if any).  */\n+\n+/* Search for a unit number, using a binary search.  The\n+   first argument is the unit number to search for.  The second argument\n+   is a pointer to an index.\n+   If the unit number is found, the function returns 1, and the index\n+   is that of the element.\n+   If the unit number is not found, the function returns 0, and the\n+   index is the one where the element would be inserted.  */\n+\n+static int\n+search_unit (int unit, int *ip)\n+{\n+  int low, high, mid;\n+\n+  low = -1;\n+  high = n_elist;\n+  while (high - low > 1)\n+    {\n+      mid = (low + high) / 2;\n+      if (unit <= elist[mid].unit)\n+\thigh = mid;\n+      else\n+\tlow = mid;\n+    }\n+  *ip = high;\n+  if (elist[high].unit == unit)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* This matches a keyword.  If it is found, return the token supplied,\n+   otherwise return ILLEGAL.  */\n+\n+static int\n+match_word (const char *word, int tok)\n+{\n+  int res;\n+\n+  if (strncasecmp (p, word, strlen (word)) == 0)\n+    {\n+      p += strlen (word);\n+      res = tok;\n+    }\n+  else\n+    res = ILLEGAL;\n+  return res;\n+\n+}\n+\n+/* Match an integer and store its value in unit_num.  This only works\n+   if p actually points to the start of an integer.  The caller has\n+   to ensure this.  */\n+\n+static int\n+match_integer (void)\n+{\n+  unit_num = 0;\n+  while (isdigit (*p))\n+    unit_num = unit_num * 10 + (*p++ - '0');\n+  return INTEGER;\n+\n+}\n+\n+/* This reads the next token from the GFORTRAN_CONVERT_UNITS variable.\n+   Returned values are the different tokens.  */\n+\n+static int\n+next_token (void)\n+{\n+  int result;\n+\n+  lastpos = p;\n+  switch (*p)\n+    {\n+    case '\\0':\n+      result = END;\n+      break;\n+      \n+    case ':':\n+    case ',': \n+    case '-':\n+    case ';':\n+      result = *p;\n+      p++;\n+      break;\n+\n+    case 'b':\n+    case 'B':\n+      result = match_word (\"big_endian\", BIG);\n+      break;\n+\n+    case 'l':\n+    case 'L':\n+      result = match_word (\"little_endian\", LITTLE);\n+      break;\n+\n+    case 'n':\n+    case 'N':\n+      result = match_word (\"native\", NATIVE);\n+      break;\n+\n+    case 's':\n+    case 'S':\n+      result = match_word (\"swap\", SWAP);\n+      break;\n+\n+    case '1': case '2': case '3': case '4': case '5':\n+    case '6': case '7': case '8': case '9':\n+      result = match_integer ();\n+      break;\n+\n+    default:\n+      result = ILLEGAL;\n+      break;\n+    }\n+  return result;\n+}\n+\n+/* Back up the last token by setting back the character pointer.  */\n+\n+static void\n+push_token (void)\n+{\n+  p = lastpos;\n+}\n+\n+/* This is called when a unit is identified.  If do_count is nonzero,\n+   increment the number of units by one.  If do_count is zero,\n+   put the unit into the table.  */\n+\n+static void\n+mark_single (int unit)\n+{\n+  int i,j;\n+\n+  if (do_count)\n+    {\n+      unit_count++;\n+      return;\n+    }\n+  if (search_unit (unit, &i))\n+    {\n+      elist[unit].conv = endian;\n+    }\n+  else\n+    {\n+      for (j=n_elist; j>=i; j--)\n+\telist[j+1] = elist[j];\n+    \n+      n_elist += 1;\n+      elist[i].unit = unit;\n+      elist[i].conv = endian;\n+    }\n+}\n+\n+/* This is called when a unit range is identified.  If do_count is\n+   nonzero, increase the number of units.  If do_count is zero,\n+   put the unit into the table.  */\n+\n+static void\n+mark_range (int unit1, int unit2)\n+{\n+  int i;\n+  if (do_count)\n+    unit_count += abs (unit2 - unit1) + 1;\n+  else\n+    {\n+      if (unit2 < unit1)\n+\tfor (i=unit2; i<=unit1; i++)\n+\t  mark_single (i);\n+      else\n+\tfor (i=unit1; i<=unit2; i++)\n+\t  mark_single (i);\n+    }\n+}\n+\n+/* Parse the GFORTRAN_CONVERT_UNITS variable.  This is called\n+   twice, once to count the units and once to actually mark them in\n+   the table.  When counting, we don't check for double occurences\n+   of units.  */\n+\n+static int\n+do_parse (void)\n+{\n+  int tok, def;\n+  int unit1;\n+  int continue_ulist;\n+  char *start;\n+\n+  unit_count = 0;\n+\n+  def = 0;\n+  start = p;\n+\n+  /* Parse the string.  First, let's look for a default.  */\n+  tok = next_token ();\n+  switch (tok)\n+    {\n+    case NATIVE:\n+      endian = CONVERT_NATIVE;\n+      break;\n+\n+    case SWAP:\n+      endian = CONVERT_SWAP;\n+      break;\n+\n+    case BIG:\n+      endian = CONVERT_BIG;\n+      break;\n+\n+    case LITTLE:\n+      endian = CONVERT_LITTLE;\n+      break;\n+\n+    case INTEGER:\n+      /* A leading digit means that we are looking at an exception.\n+\t Reset the position to the beginning, and continue processing\n+\t at the exception list.  */\n+      p = start;\n+      goto exceptions;\n+      break;\n+\n+    case END:\n+      goto end;\n+      break;\n+\n+    default:\n+      goto error;\n+      break;\n+    }\n+\n+  tok = next_token ();\n+  switch (tok)\n+    {\n+    case ';':\n+      def = endian;\n+      break;\n+\n+    case ':':\n+      /* This isn't a default after all.  Reset the position to the\n+\t beginning, and continue processing at the exception list.  */\n+      p = start;\n+      goto exceptions;\n+      break;\n+\n+    case END:\n+      goto end;\n+      break;\n+\n+    default:\n+      goto error;\n+      break;\n+    }\n+\n+ exceptions:\n+\n+  /* Loop over all exceptions.  */\n+  while(1)\n+    {\n+      tok = next_token ();\n+      switch (tok)\n+\t{\n+\tcase LITTLE:\n+\t  if (next_token () != ':')\n+\t    goto error;\n+\t  endian = CONVERT_LITTLE;\n+\t  break;\n+\n+\tcase BIG:\n+\t  if (next_token () != ':')\n+\t    goto error;\n+\t  endian = CONVERT_BIG;\n+\t  break;\n+\n+\tcase INTEGER:\n+\t  push_token ();\n+\t  break;\n+\n+\tcase END:\n+\t  goto end;\n+\t  break;\n+\n+\tdefault:\n+\t  goto error;\n+\t  break;\n+\t}\n+      /* We arrive here when we want to parse a list of\n+\t numbers.  */\n+      continue_ulist = 1;\n+      do\n+\t{\n+\t  tok = next_token ();\n+\t  if (tok != INTEGER)\n+\t    goto error;\n+\n+\t  unit1 = unit_num;\n+\t  tok = next_token ();\n+\t  /* The number can be followed by a - and another number,\n+\t     which means that this is a unit range, a comma\n+\t     or a semicolon.  */\n+\t  if (tok == '-')\n+\t    {\n+\t      if (next_token () != INTEGER)\n+\t\tgoto error;\n+\n+\t      mark_range (unit1, unit_num);\n+\t      tok = next_token ();\n+\t      if (tok == END)\n+\t\tgoto end;\n+\t      else if (tok == ';')\n+\t\tcontinue_ulist = 0;\n+\t      else if (tok != ',')\n+\t\tgoto error;\n+\t    }\n+\t  else\n+\t    {\n+\t      mark_single (unit1);\n+\t      switch (tok)\n+\t\t{\n+\t\tcase ';':\n+\t\t  continue_ulist = 0;\n+\t\t  break;\n+\n+\t\tcase ',':\n+\t\t  break;\n+\n+\t\tcase END:\n+\t\t  goto end;\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  goto error;\n+\t\t}\n+\t    }\n+\t} while (continue_ulist);\n+    }\n+ end:\n+  return 0;\n+ error:\n+  def = CONVERT_NONE;\n+  return -1;\n+}\n+\n+void init_unformatted (variable * v)\n+{\n+  char *val;\n+  val = getenv (v->name);\n+  def = CONVERT_NONE;\n+  n_elist = 0;\n+\n+  if (val == NULL)\n+    return;\n+  do_count = 1;\n+  p = val;\n+  do_parse ();\n+  if (do_count <= 0)\n+    {\n+      n_elist = 0;\n+      elist = NULL;\n+    }\n+  else\n+    {\n+      elist = get_mem (unit_count * sizeof (exception_t));\n+      do_count = 0;\n+      p = val;\n+      do_parse ();\n+    }\n+}\n+\n+/* Get the default conversion for for an unformatted unit.  */\n+\n+unit_convert\n+get_unformatted_convert (int unit)\n+{\n+  int i;\n+\n+  if (elist == NULL)\n+    return def;\n+  else if (search_unit (unit, &i))\n+    return elist[i].conv;\n+  else\n+    return def;\n+}"}]}