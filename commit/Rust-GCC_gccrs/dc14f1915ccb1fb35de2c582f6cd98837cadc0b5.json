{"sha": "dc14f1915ccb1fb35de2c582f6cd98837cadc0b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMxNGYxOTE1Y2NiMWZiMzVkZTJjNTgyZjZjZDk4ODM3Y2FkYzBiNQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-08-30T08:14:29Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-08-30T08:14:29Z"}, "message": "re PR rtl-optimization/27735 (ICE at -O3 caused by loop unswitching)\n\n\tPR rtl-optimization/27735\n\t* cfgloopmanip.c (fix_loop_placements, fix_bb_placements, unloop):\n\tAdd new argument to keep track of whether an irreducible region\n\twas affected.  All callers changed.\n\t(fix_irreducible_loops): Removed.\n\t(remove_path): Call mark_irreducible_loops if EDGE_IRREDUCIBLE_LOOP\n\tflags were invalidated.\n\n\t* gcc.dg/loop-unswitch-1.c: New test.\n\nFrom-SVN: r116582", "tree": {"sha": "60331baa5669c81c73c3772f0667c674953ff487", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60331baa5669c81c73c3772f0667c674953ff487"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc14f1915ccb1fb35de2c582f6cd98837cadc0b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc14f1915ccb1fb35de2c582f6cd98837cadc0b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc14f1915ccb1fb35de2c582f6cd98837cadc0b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc14f1915ccb1fb35de2c582f6cd98837cadc0b5/comments", "author": null, "committer": null, "parents": [{"sha": "b0d3a6aeb8b18937740877996a862d7dd7e65557", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d3a6aeb8b18937740877996a862d7dd7e65557", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0d3a6aeb8b18937740877996a862d7dd7e65557"}], "stats": {"total": 219, "additions": 113, "deletions": 106}, "files": [{"sha": "bdb88b2d2f2d0b22718da656c43c7372ad5210da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc14f1915ccb1fb35de2c582f6cd98837cadc0b5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc14f1915ccb1fb35de2c582f6cd98837cadc0b5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc14f1915ccb1fb35de2c582f6cd98837cadc0b5", "patch": "@@ -1,3 +1,13 @@\n+2006-08-30  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR rtl-optimization/27735\n+\t* cfgloopmanip.c (fix_loop_placements, fix_bb_placements, unloop):\n+\tAdd new argument to keep track of whether an irreducible region\n+\twas affected.  All callers changed.\n+\t(fix_irreducible_loops): Removed.\n+\t(remove_path): Call mark_irreducible_loops if EDGE_IRREDUCIBLE_LOOP\n+\tflags were invalidated.\n+\n 2006-08-29  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/i386.md (*fop_df_comm_mixed): Match DF operands"}, {"sha": "638b2996584052c535005b4f6b9acc61cd3dfea8", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 64, "deletions": 106, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc14f1915ccb1fb35de2c582f6cd98837cadc0b5/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc14f1915ccb1fb35de2c582f6cd98837cadc0b5/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=dc14f1915ccb1fb35de2c582f6cd98837cadc0b5", "patch": "@@ -41,14 +41,13 @@ static bool rpe_enum_p (basic_block, void *);\n static int find_path (edge, basic_block **);\n static bool alp_enum_p (basic_block, void *);\n static void add_loop (struct loops *, struct loop *);\n-static void fix_loop_placements (struct loops *, struct loop *);\n+static void fix_loop_placements (struct loops *, struct loop *, bool *);\n static bool fix_bb_placement (struct loops *, basic_block);\n-static void fix_bb_placements (struct loops *, basic_block);\n+static void fix_bb_placements (struct loops *, basic_block, bool *);\n static void place_new_loop (struct loops *, struct loop *);\n static void scale_loop_frequencies (struct loop *, int, int);\n static basic_block create_preheader (struct loop *, int);\n-static void fix_irreducible_loops (basic_block);\n-static void unloop (struct loops *, struct loop *);\n+static void unloop (struct loops *, struct loop *, bool *);\n \n #define RDIV(X,Y) (((X) + (Y) / 2) / (Y))\n \n@@ -133,9 +132,14 @@ fix_bb_placement (struct loops *loops, basic_block bb)\n    its predecessors that may change if placement of FROM changed.  Also fix\n    placement of subloops of FROM->loop_father, that might also be altered due\n    to this change; the condition for them is similar, except that instead of\n-   successors we consider edges coming out of the loops.  */\n+   successors we consider edges coming out of the loops.\n+ \n+   If the changes may invalidate the information about irreducible regions,\n+   IRRED_INVALIDATED is set to true.  */\n+\n static void\n-fix_bb_placements (struct loops *loops, basic_block from)\n+fix_bb_placements (struct loops *loops, basic_block from,\n+\t\t   bool *irred_invalidated)\n {\n   sbitmap in_queue;\n   basic_block *queue, *qtop, *qbeg, *qend;\n@@ -187,12 +191,21 @@ fix_bb_placements (struct loops *loops, basic_block from)\n \t    continue;\n \t}\n \n+      FOR_EACH_EDGE (e, ei, from->succs)\n+\t{\n+\t  if (e->flags & EDGE_IRREDUCIBLE_LOOP)\n+\t    *irred_invalidated = true;\n+\t}\n+\n       /* Something has changed, insert predecessors into queue.  */\n       FOR_EACH_EDGE (e, ei, from->preds)\n \t{\n \t  basic_block pred = e->src;\n \t  struct loop *nca;\n \n+\t  if (e->flags & EDGE_IRREDUCIBLE_LOOP)\n+\t    *irred_invalidated = true;\n+\n \t  if (TEST_BIT (in_queue, pred->index))\n \t    continue;\n \n@@ -225,76 +238,6 @@ fix_bb_placements (struct loops *loops, basic_block from)\n   free (queue);\n }\n \n-/* Basic block from has lost one or more of its predecessors, so it might\n-   mo longer be part irreducible loop.  Fix it and proceed recursively\n-   for its successors if needed.  */\n-static void\n-fix_irreducible_loops (basic_block from)\n-{\n-  basic_block bb;\n-  basic_block *stack;\n-  int stack_top;\n-  sbitmap on_stack;\n-  edge *edges, e;\n-  unsigned num_edges, i;\n-\n-  if (!(from->flags & BB_IRREDUCIBLE_LOOP))\n-    return;\n-\n-  on_stack = sbitmap_alloc (last_basic_block);\n-  sbitmap_zero (on_stack);\n-  SET_BIT (on_stack, from->index);\n-  stack = XNEWVEC (basic_block, from->loop_father->num_nodes);\n-  stack[0] = from;\n-  stack_top = 1;\n-\n-  while (stack_top)\n-    {\n-      edge_iterator ei;\n-      bb = stack[--stack_top];\n-      RESET_BIT (on_stack, bb->index);\n-\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\tif (e->flags & EDGE_IRREDUCIBLE_LOOP)\n-\t  break;\n-      if (e)\n-\tcontinue;\n-\n-      bb->flags &= ~BB_IRREDUCIBLE_LOOP;\n-      if (bb->loop_father->header == bb)\n-\tedges = get_loop_exit_edges (bb->loop_father, &num_edges);\n-      else\n-\t{\n-\t  num_edges = EDGE_COUNT (bb->succs);\n-\t  edges = XNEWVEC (edge, num_edges);\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    edges[ei.index] = e;\n-\t}\n-\n-      for (i = 0; i < num_edges; i++)\n-\t{\n-\t  e = edges[i];\n-\n-\t  if (e->flags & EDGE_IRREDUCIBLE_LOOP)\n-\t    {\n-\t      if (!flow_bb_inside_loop_p (from->loop_father, e->dest))\n-\t\tcontinue;\n-\n-\t      e->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n-\t      if (TEST_BIT (on_stack, e->dest->index))\n-\t\tcontinue;\n-\n-\t      SET_BIT (on_stack, e->dest->index);\n-\t      stack[stack_top++] = e->dest;\n-\t    }\n-\t}\n-      free (edges);\n-    }\n-\n-  free (on_stack);\n-  free (stack);\n-}\n-\n /* Removes path beginning at edge E, i.e. remove basic blocks dominated by E\n    and update loop structure stored in LOOPS and dominators.  Return true if\n    we were able to remove the path, false otherwise (and nothing is affected\n@@ -306,11 +249,19 @@ remove_path (struct loops *loops, edge e)\n   basic_block *rem_bbs, *bord_bbs, *dom_bbs, from, bb;\n   int i, nrem, n_bord_bbs, n_dom_bbs;\n   sbitmap seen;\n-  bool deleted;\n+  bool deleted, irred_invalidated = false;\n \n   if (!loop_delete_branch_edge (e, 0))\n     return false;\n \n+  /* Keep track of whether we need to update information about irreducible\n+     regions.  This is the case if the removed area is a part of the\n+     irreducible region, or if the set of basic blocks that belong to a loop\n+     that is inside an irreducible region is changed, or if such a loop is\n+     removed.  */\n+  if (e->flags & EDGE_IRREDUCIBLE_LOOP)\n+    irred_invalidated = true;\n+\n   /* We need to check whether basic blocks are dominated by the edge\n      e, but we only have basic block dominators.  This is easy to\n      fix -- when e->dest has exactly one predecessor, this corresponds\n@@ -325,7 +276,7 @@ remove_path (struct loops *loops, edge e)\n   while (e->src->loop_father->outer\n \t && dominated_by_p (CDI_DOMINATORS,\n \t\t\t    e->src->loop_father->latch, e->dest))\n-    unloop (loops, e->src->loop_father);\n+    unloop (loops, e->src->loop_father, &irred_invalidated);\n \n   /* Identify the path.  */\n   nrem = find_path (e, &rem_bbs);\n@@ -347,6 +298,9 @@ remove_path (struct loops *loops, edge e)\n \t  {\n \t    SET_BIT (seen, ae->dest->index);\n \t    bord_bbs[n_bord_bbs++] = ae->dest;\n+\t  \n+\t    if (ae->flags & EDGE_IRREDUCIBLE_LOOP)\n+\t      irred_invalidated = true;\n \t  }\n     }\n \n@@ -388,17 +342,16 @@ remove_path (struct loops *loops, edge e)\n   /* Recount dominators.  */\n   iterate_fix_dominators (CDI_DOMINATORS, dom_bbs, n_dom_bbs);\n   free (dom_bbs);\n-\n-  /* These blocks have lost some predecessor(s), thus their irreducible\n-     status could be changed.  */\n-  for (i = 0; i < n_bord_bbs; i++)\n-    fix_irreducible_loops (bord_bbs[i]);\n   free (bord_bbs);\n \n   /* Fix placements of basic blocks inside loops and the placement of\n      loops in the loop tree.  */\n-  fix_bb_placements (loops, from);\n-  fix_loop_placements (loops, from->loop_father);\n+  fix_bb_placements (loops, from, &irred_invalidated);\n+  fix_loop_placements (loops, from->loop_father, &irred_invalidated);\n+\n+  if (irred_invalidated\n+      && (loops->state & LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS) != 0)\n+    mark_irreducible_loops (loops);\n \n   return true;\n }\n@@ -549,16 +502,22 @@ loopify (struct loops *loops, edge latch_edge, edge header_edge,\n \n /* Remove the latch edge of a LOOP and update LOOPS tree to indicate that\n    the LOOP was removed.  After this function, original loop latch will\n-   have no successor, which caller is expected to fix somehow.  */\n+   have no successor, which caller is expected to fix somehow.\n+\n+   If this may cause the information about irreducible regions to become\n+   invalid, IRRED_INVALIDATED is set to true.  */\n+\n static void\n-unloop (struct loops *loops, struct loop *loop)\n+unloop (struct loops *loops, struct loop *loop, bool *irred_invalidated)\n {\n   basic_block *body;\n   struct loop *ploop;\n   unsigned i, n;\n   basic_block latch = loop->latch;\n-  edge *edges;\n-  unsigned num_edges;\n+  bool dummy = false;\n+\n+  if (loop_preheader_edge (loop)->flags & EDGE_IRREDUCIBLE_LOOP)\n+    *irred_invalidated = true;\n \n   /* This is relatively straightforward.  The dominators are unchanged, as\n      loop header dominates loop latch, so the only thing we have to care of\n@@ -567,7 +526,6 @@ unloop (struct loops *loops, struct loop *loop)\n      its work.  */\n \n   body = get_loop_body (loop);\n-  edges = get_loop_exit_edges (loop, &num_edges);\n   n = loop->num_nodes;\n   for (i = 0; i < n; i++)\n     if (body[i]->loop_father == loop)\n@@ -590,24 +548,18 @@ unloop (struct loops *loops, struct loop *loop)\n   flow_loop_free (loop);\n \n   remove_edge (single_succ_edge (latch));\n-  fix_bb_placements (loops, latch);\n-\n-  /* If the loop was inside an irreducible region, we would have to somehow\n-     update the irreducible marks inside its body.  While it is certainly\n-     possible to do, it is a bit complicated and this situation should be\n-     very rare, so we just remark all loops in this case.  */\n-  for (i = 0; i < num_edges; i++)\n-    if (edges[i]->flags & EDGE_IRREDUCIBLE_LOOP)\n-      break;\n-  if (i != num_edges)\n-    mark_irreducible_loops (loops);\n-  free (edges);\n+\n+  /* We do not pass IRRED_INVALIDATED to fix_bb_placements here, as even if\n+     there is an irreducible region inside the cancelled loop, the flags will\n+     be still correct.  */\n+  fix_bb_placements (loops, latch, &dummy);\n }\n \n /* Fix placement of LOOP inside loop tree, i.e. find the innermost superloop\n    FATHER of LOOP such that all of the edges coming out of LOOP belong to\n-   FATHER, and set it as outer loop of LOOP.  Return 1 if placement of\n+   FATHER, and set it as outer loop of LOOP.  Return true if placement of\n    LOOP changed.  */\n+\n int\n fix_loop_placement (struct loop *loop)\n {\n@@ -642,9 +594,14 @@ fix_loop_placement (struct loop *loop)\n /* Fix placement of superloops of LOOP inside loop tree, i.e. ensure that\n    condition stated in description of fix_loop_placement holds for them.\n    It is used in case when we removed some edges coming out of LOOP, which\n-   may cause the right placement of LOOP inside loop tree to change.  */\n+   may cause the right placement of LOOP inside loop tree to change.\n+ \n+   IRRED_INVALIDATED is set to true if a change in the loop structures might\n+   invalidate the information about irreducible regions.  */\n+\n static void\n-fix_loop_placements (struct loops *loops, struct loop *loop)\n+fix_loop_placements (struct loops *loops, struct loop *loop,\n+\t\t     bool *irred_invalidated)\n {\n   struct loop *outer;\n \n@@ -659,7 +616,8 @@ fix_loop_placements (struct loops *loops, struct loop *loop)\n \t for its preheader, because the successor is the header and belongs\n \t to the loop.  So call fix_bb_placements to fix up the placement\n \t of the preheader and (possibly) of its predecessors.  */\n-      fix_bb_placements (loops, loop_preheader_edge (loop)->src);\n+      fix_bb_placements (loops, loop_preheader_edge (loop)->src,\n+\t\t\t irred_invalidated);\n       loop = outer;\n     }\n }"}, {"sha": "8ccee1cc025afc4a8971c2f1078a489bc6d14fa0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc14f1915ccb1fb35de2c582f6cd98837cadc0b5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc14f1915ccb1fb35de2c582f6cd98837cadc0b5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dc14f1915ccb1fb35de2c582f6cd98837cadc0b5", "patch": "@@ -1,3 +1,8 @@\n+2006-08-30  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\tPR rtl-optimization/27735\n+\t* gcc.dg/loop-unswitch-1.c: New test.\n+\n 2006-08-30  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/28885"}, {"sha": "930364c8175b9a31717dc8db9097bd61c749d9a2", "filename": "gcc/testsuite/gcc.dg/loop-unswitch-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc14f1915ccb1fb35de2c582f6cd98837cadc0b5/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc14f1915ccb1fb35de2c582f6cd98837cadc0b5/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-1.c?ref=dc14f1915ccb1fb35de2c582f6cd98837cadc0b5", "patch": "@@ -0,0 +1,34 @@\n+/* For PR rtl-optimization/27735  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funswitch-loops\" } */\n+\n+void set_color(void);\n+void xml_colorize_line(unsigned int *p, int state)\n+{\n+  int c;\n+  switch(state) \n+    {\n+    case 1:\n+      goto parse_tag;\n+    case 2:\n+      goto parse_comment;\n+    }\n+\n+  for(;;) \n+    {\n+      c = *p;  \n+      if (c == '<' && state == 0) \n+\t{\n+parse_comment: ;\n+\t  while (*p != '\\n') \n+\t    state = 3;\n+parse_tag: ;\n+\t  while (*p != '\\n') \n+\t    state = 0;\n+\t  set_color();\n+\t}\n+      else\n+\tp++;\n+    }\n+}\n+"}]}