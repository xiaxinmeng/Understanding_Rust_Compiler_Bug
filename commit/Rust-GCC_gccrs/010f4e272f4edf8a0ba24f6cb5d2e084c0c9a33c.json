{"sha": "010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEwZjRlMjcyZjRlZGY4YTBiYTI0ZjZjYjVkMmUwODRjMGM5YTMzYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-06-30T22:18:25Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-06-30T22:18:25Z"}, "message": "revert: tree-streamer-out.c (pack_ts_type_common_value_fields): Stream if type is complete.\n\n\n\tRevert:\n\t* tree-streamer-out.c (pack_ts_type_common_value_fields): Stream if type\n\tis complete.\n\t(write_ts_type_common_tree_pointers): Do not stream fields not set for incomplete\n\ttypes; do not stream duplicated fields for variants; sanity check that variant\n\tand type match.\n\t(write_ts_type_non_common_tree_pointers): Likewise.\n\t* tree-streamer-in.c (unpack_ts_type_common_value_fields): Mark in TYPE_SIZE whether\n\ttype is complete.\n\t(lto_input_ts_type_common_tree_pointers): Do same changes as in\n\twrite_ts_type_common_tree_pointers\n\t(lto_input_ts_type_non_common_tree_pointers): Likewise.\n\n\t* lto.c (lto_copy_fields_not_streamed): New function.\n\t(compare_tree_sccs_1): Do not compare fields shared in between type\n\tand variant.\n\t(lto_read_decls): Fixup types first before inserting into hash.\n\nFrom-SVN: r212179", "tree": {"sha": "ce37885e67fa8bfe2a2d91dc28440fe76b1ba05b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce37885e67fa8bfe2a2d91dc28440fe76b1ba05b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c/comments", "author": null, "committer": null, "parents": [{"sha": "0ca59830558c865ea8329e387207d9682021f405", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ca59830558c865ea8329e387207d9682021f405", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ca59830558c865ea8329e387207d9682021f405"}], "stats": {"total": 339, "additions": 79, "deletions": 260}, "files": [{"sha": "b769bf022e1420d672340e30ed18fefc883b19ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c", "patch": "@@ -1,3 +1,18 @@\n+2014-06-28  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tRevert:\n+\t* tree-streamer-out.c (pack_ts_type_common_value_fields): Stream if type\n+\tis complete.\n+\t(write_ts_type_common_tree_pointers): Do not stream fields not set for incomplete\n+\ttypes; do not stream duplicated fields for variants; sanity check that variant\n+\tand type match.\n+\t(write_ts_type_non_common_tree_pointers): Likewise.\n+\t* tree-streamer-in.c (unpack_ts_type_common_value_fields): Mark in TYPE_SIZE whether\n+\ttype is complete.\n+\t(lto_input_ts_type_common_tree_pointers): Do same changes as in\n+\twrite_ts_type_common_tree_pointers\n+\t(lto_input_ts_type_non_common_tree_pointers): Likewise.\n+\n 2014-06-30  Joseph Myers  <joseph@codesourcery.com>\n \n \t* var-tracking.c (add_stores): Return instead of asserting if old"}, {"sha": "4a5d265c5ce7cf6af722df1f7caec75daccba06b", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c", "patch": "@@ -1,3 +1,11 @@\n+2014-06-28  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tRevert:\n+\t* lto.c (lto_copy_fields_not_streamed): New function.\n+\t(compare_tree_sccs_1): Do not compare fields shared in between type\n+\tand variant.\n+\t(lto_read_decls): Fixup types first before inserting into hash.\n+\n 2014-06-28  Andrew Pinski  <apinski@cavium.com>\n \n \t* lto.c (lto_read_decls): Fix comment in comment."}, {"sha": "20b78a8c499fe1d94324a376dcc5c132c8455a18", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 16, "deletions": 93, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c", "patch": "@@ -1050,57 +1050,6 @@ lto_register_function_decl_in_symtab (struct data_in *data_in, tree decl,\n \t\t\t decl, get_resolution (data_in, ix));\n }\n \n-/* Copy fields that are not streamed but copied from other nodes.  */\n-static void\n-lto_copy_fields_not_streamed (tree t)\n-{\n-  if (TYPE_P (t) && TYPE_MAIN_VARIANT (t) != t)\n-    {\n-      tree mv = TYPE_MAIN_VARIANT (t);\n-\n-      if (COMPLETE_TYPE_P (t))\n-\t{\n-\t  TYPE_SIZE (t) = TYPE_SIZE (mv);\n-\t  TYPE_SIZE_UNIT (t) = TYPE_SIZE_UNIT (mv);\n-\t}\n-      TYPE_ATTRIBUTES (t) = TYPE_ATTRIBUTES (mv);\n-\n-      if (CODE_CONTAINS_STRUCT (TREE_CODE (t), TS_TYPE_NON_COMMON))\n-\t{\n-\t  if (TREE_CODE (t) == ENUMERAL_TYPE && COMPLETE_TYPE_P (t))\n-\t    TYPE_VALUES (t) = TYPE_VALUES (mv);\n-\t  else if (TREE_CODE (t) == ARRAY_TYPE)\n-\t    TYPE_DOMAIN (t) = TYPE_DOMAIN (mv);\n-\n-          if (RECORD_OR_UNION_TYPE_P (t) && COMPLETE_TYPE_P (t))\n-\t    TYPE_VFIELD (t) = TYPE_VFIELD (mv);\n-\t  else if ((TREE_CODE (t) == ENUMERAL_TYPE && COMPLETE_TYPE_P (t))\n-\t\t   || TREE_CODE (t) == INTEGER_TYPE\n-\t\t   || TREE_CODE (t) == BOOLEAN_TYPE\n-\t\t   || TREE_CODE (t) == REAL_TYPE\n-\t\t   || TREE_CODE (t) == FIXED_POINT_TYPE)\n-\t    TYPE_MIN_VALUE (t) = TYPE_MIN_VALUE (mv);\n-\n-\t  if (TREE_CODE (t) == METHOD_TYPE)\n-\t    TYPE_METHOD_BASETYPE (t) = TYPE_METHOD_BASETYPE (mv);\n-\t  else if (RECORD_OR_UNION_TYPE_P (t) && COMPLETE_TYPE_P (t))\n-\t    TYPE_METHODS (t) = TYPE_METHODS (mv);\n-\t  else if (TREE_CODE (t) == OFFSET_TYPE)\n-\t    TYPE_OFFSET_BASETYPE (t) = TYPE_OFFSET_BASETYPE (mv);\n-\t  else if (TREE_CODE (t) == ARRAY_TYPE)\n-\t    TYPE_ARRAY_MAX_SIZE (t) = TYPE_ARRAY_MAX_SIZE (mv);\n-\t  else if ((TREE_CODE (t) == ENUMERAL_TYPE && COMPLETE_TYPE_P (t))\n-\t\t   || TREE_CODE (t) == INTEGER_TYPE\n-\t\t   || TREE_CODE (t) == BOOLEAN_TYPE\n-\t\t   || TREE_CODE (t) == REAL_TYPE\n-\t\t   || TREE_CODE (t) == FIXED_POINT_TYPE)\n-\t    TYPE_MAX_VALUE (t) = TYPE_MAX_VALUE (mv);\n-\n-\t  if (RECORD_OR_UNION_TYPE_P (t) && COMPLETE_TYPE_P (t))\n-\t    TYPE_BINFO (t) = TYPE_BINFO (mv);\n-\t}\n-    }\n-}\n \n /* For the type T re-materialize it in the type variant list and\n    the pointer/reference-to chains.  */\n@@ -1597,28 +1546,15 @@ compare_tree_sccs_1 (tree t1, tree t2, tree **map)\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n     {\n-      /* See if type is the main variant.  */\n-      if (TYPE_MAIN_VARIANT (t1) == t1)\n-\t{\n-\t  /* Main variant can match only another main variant.  */\n-\t  if (TYPE_MAIN_VARIANT (t2) != t2)\n-\t    return false;\n-\n-\t  compare_tree_edges (TYPE_SIZE (t1), TYPE_SIZE (t2));\n-\t  compare_tree_edges (TYPE_SIZE_UNIT (t1), TYPE_SIZE_UNIT (t2));\n-\t  compare_tree_edges (TYPE_ATTRIBUTES (t1), TYPE_ATTRIBUTES (t2));\n-\t}\n-      else\n-\t/* Compare main variant pointers, but do not compare fields that are\n-\t   shared in between type and the main variant since those are not\n-\t   streamed and not copied yet.  */\n-        compare_tree_edges (TYPE_MAIN_VARIANT (t1), TYPE_MAIN_VARIANT (t2));\n-\n+      compare_tree_edges (TYPE_SIZE (t1), TYPE_SIZE (t2));\n+      compare_tree_edges (TYPE_SIZE_UNIT (t1), TYPE_SIZE_UNIT (t2));\n+      compare_tree_edges (TYPE_ATTRIBUTES (t1), TYPE_ATTRIBUTES (t2));\n+      compare_tree_edges (TYPE_NAME (t1), TYPE_NAME (t2));\n       /* Do not compare TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n \t reconstructed during fixup.  */\n       /* Do not compare TYPE_NEXT_VARIANT, we reconstruct the variant lists\n \t during fixup.  */\n-      compare_tree_edges (TYPE_NAME (t1), TYPE_NAME (t2));\n+      compare_tree_edges (TYPE_MAIN_VARIANT (t1), TYPE_MAIN_VARIANT (t2));\n       /* ???  Global types from different TUs have non-matching\n \t TRANSLATION_UNIT_DECLs.  Still merge them if they are otherwise\n \t equal.  */\n@@ -1633,31 +1569,25 @@ compare_tree_sccs_1 (tree t1, tree t2, tree **map)\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n     {\n-      if (TYPE_MAIN_VARIANT (t1) == t1)\n-\t{\n-\t  if (code == ENUMERAL_TYPE)\n-\t    compare_tree_edges (TYPE_VALUES (t1), TYPE_VALUES (t2));\n-\t  else if (code == ARRAY_TYPE)\n-\t    compare_tree_edges (TYPE_DOMAIN (t1), TYPE_DOMAIN (t2));\n-\t  else if (RECORD_OR_UNION_TYPE_P (t1))\n-\t    compare_tree_edges (TYPE_BINFO (t1), TYPE_BINFO (t2));\n-\t  if (!POINTER_TYPE_P (t1))\n-\t    compare_tree_edges (TYPE_MINVAL (t1), TYPE_MINVAL (t2));\n-\t  compare_tree_edges (TYPE_MAXVAL (t1), TYPE_MAXVAL (t2));\n-\t}\n-      if (RECORD_OR_UNION_TYPE_P (t1)\n-\t  && TYPE_FIELDS (t1) != TYPE_FIELDS (t2))\n+      if (code == ENUMERAL_TYPE)\n+\tcompare_tree_edges (TYPE_VALUES (t1), TYPE_VALUES (t2));\n+      else if (code == ARRAY_TYPE)\n+\tcompare_tree_edges (TYPE_DOMAIN (t1), TYPE_DOMAIN (t2));\n+      else if (RECORD_OR_UNION_TYPE_P (t1))\n \t{\n \t  tree f1, f2;\n-\n \t  for (f1 = TYPE_FIELDS (t1), f2 = TYPE_FIELDS (t2);\n \t       f1 || f2;\n \t       f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n \t    compare_tree_edges (f1, f2);\n+\t  compare_tree_edges (TYPE_BINFO (t1), TYPE_BINFO (t2));\n \t}\n-      if (code == FUNCTION_TYPE\n-\t  || code == METHOD_TYPE)\n+      else if (code == FUNCTION_TYPE\n+\t       || code == METHOD_TYPE)\n \tcompare_tree_edges (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2));\n+      if (!POINTER_TYPE_P (t1))\n+\tcompare_tree_edges (TYPE_MINVAL (t1), TYPE_MINVAL (t2));\n+      compare_tree_edges (TYPE_MAXVAL (t1), TYPE_MAXVAL (t2));\n     }\n \n   if (CODE_CONTAINS_STRUCT (code, TS_LIST))\n@@ -1958,19 +1888,12 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \t\t  || streamer_handle_as_builtin_p (first)))\n \t    continue;\n \n-\t  /* Copy fileds we do not stream before unification so we can compare them\n-\t     without being worried if they are already initialized.  */\n-\t  for (unsigned i = 0; i < len; ++i)\n-\t    lto_copy_fields_not_streamed\n-\t       (streamer_tree_cache_get_tree (data_in->reader_cache, from + i));\n-\n \t  /* Try to unify the SCC with already existing ones.  */\n \t  if (!flag_ltrans\n \t      && unify_scc (data_in->reader_cache, from,\n \t\t\t    len, scc_entry_len, scc_hash))\n \t    continue;\n \n-\t  /* Do remaining fixup tasks for prevailing nodes.  */\n \t  bool seen_type = false;\n \t  for (unsigned i = 0; i < len; ++i)\n \t    {"}, {"sha": "ee1c955f159bf901425bfa5050d9590015158aed", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 18, "deletions": 62, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c", "patch": "@@ -357,13 +357,6 @@ unpack_ts_type_common_value_fields (struct bitpack_d *bp, tree expr)\n   TYPE_RESTRICT (expr) = (unsigned) bp_unpack_value (bp, 1);\n   TYPE_USER_ALIGN (expr) = (unsigned) bp_unpack_value (bp, 1);\n   TYPE_READONLY (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  /* This bit represent if type is complete, or if the TYPE_SIZE\n-     is non-NULL.  Mark this fact into TYPE_SIZE. The actual values\n-     will be filled in later.  */\n-  if ((unsigned) bp_unpack_value (bp, 1))\n-    TYPE_SIZE (expr) = error_mark_node;\n-  else\n-    TYPE_SIZE (expr) = NULL_TREE;\n   TYPE_PRECISION (expr) = bp_unpack_var_len_unsigned (bp);\n   TYPE_ALIGN (expr) = bp_unpack_var_len_unsigned (bp);\n   TYPE_ALIAS_SET (expr) = bp_unpack_var_len_int (bp);\n@@ -801,29 +794,19 @@ static void\n lto_input_ts_type_common_tree_pointers (struct lto_input_block *ib,\n \t\t\t\t\tstruct data_in *data_in, tree expr)\n {\n-  TYPE_MAIN_VARIANT (expr) = stream_read_tree (ib, data_in);\n-\n-  /* Variants share most the properties with the main variant.  */\n-  if (TYPE_MAIN_VARIANT (expr) == expr)\n-    {\n-      if (COMPLETE_TYPE_P (expr))\n-\t{\n-\t  TYPE_SIZE (expr) = stream_read_tree (ib, data_in);\n-\t  TYPE_SIZE_UNIT (expr) = stream_read_tree (ib, data_in);\n-\t}\n-      TYPE_ATTRIBUTES (expr) = stream_read_tree (ib, data_in);\n-    }\n-  /* The fileds not streamed will be copied by\n-     lto_copy_fields_not_streamed.  */\n+  TYPE_SIZE (expr) = stream_read_tree (ib, data_in);\n+  TYPE_SIZE_UNIT (expr) = stream_read_tree (ib, data_in);\n+  TYPE_ATTRIBUTES (expr) = stream_read_tree (ib, data_in);\n   TYPE_NAME (expr) = stream_read_tree (ib, data_in);\n-  TYPE_CONTEXT (expr) = stream_read_tree (ib, data_in);\n-  TYPE_STUB_DECL (expr) = stream_read_tree (ib, data_in);\n   /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n      reconstructed during fixup.  */\n   /* Do not stream TYPE_NEXT_VARIANT, we reconstruct the variant lists\n      during fixup.  */\n+  TYPE_MAIN_VARIANT (expr) = stream_read_tree (ib, data_in);\n+  TYPE_CONTEXT (expr) = stream_read_tree (ib, data_in);\n   /* TYPE_CANONICAL gets re-computed during type merging.  */\n   TYPE_CANONICAL (expr) = NULL_TREE;\n+  TYPE_STUB_DECL (expr) = stream_read_tree (ib, data_in);\n }\n \n /* Read all pointer fields in the TS_TYPE_NON_COMMON structure of EXPR\n@@ -835,48 +818,21 @@ lto_input_ts_type_non_common_tree_pointers (struct lto_input_block *ib,\n \t\t\t\t\t    struct data_in *data_in,\n \t\t\t\t\t    tree expr)\n {\n-  if (TYPE_MAIN_VARIANT (expr) == expr)\n-    {\n-      if (TREE_CODE (expr) == ENUMERAL_TYPE && COMPLETE_TYPE_P (expr))\n-\tTYPE_VALUES (expr) = stream_read_tree (ib, data_in);\n-      else if (TREE_CODE (expr) == ARRAY_TYPE)\n-\tTYPE_DOMAIN (expr) = stream_read_tree (ib, data_in);\n-\n-      /* TYPE_NEXT_PTR_TO and TYPE_NEXT_REF_TO is recomputed.  */\n-      if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n-\tTYPE_VFIELD (expr) = stream_read_tree (ib, data_in);\n-      else if ((TREE_CODE (expr) == ENUMERAL_TYPE && COMPLETE_TYPE_P (expr))\n-\t       || TREE_CODE (expr) == INTEGER_TYPE\n-\t       || TREE_CODE (expr) == BOOLEAN_TYPE\n-\t       || TREE_CODE (expr) == REAL_TYPE\n-\t       || TREE_CODE (expr) == FIXED_POINT_TYPE)\n-\tTYPE_MIN_VALUE (expr) = stream_read_tree (ib, data_in);\n-\n-      if (TREE_CODE (expr) == METHOD_TYPE)\n-\tTYPE_METHOD_BASETYPE (expr) = stream_read_tree (ib, data_in);\n-      else if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n-\tTYPE_METHODS (expr) = stream_read_tree (ib, data_in);\n-      else if (TREE_CODE (expr) == OFFSET_TYPE)\n-\tTYPE_OFFSET_BASETYPE (expr) = stream_read_tree (ib, data_in);\n-      else if (TREE_CODE (expr) == ARRAY_TYPE)\n-\tTYPE_ARRAY_MAX_SIZE (expr) = stream_read_tree (ib, data_in);\n-      else if ((TREE_CODE (expr) == ENUMERAL_TYPE && COMPLETE_TYPE_P (expr))\n-\t       || TREE_CODE (expr) == INTEGER_TYPE\n-\t       || TREE_CODE (expr) == BOOLEAN_TYPE\n-\t       || TREE_CODE (expr) == REAL_TYPE\n-\t       || TREE_CODE (expr) == FIXED_POINT_TYPE)\n-\tTYPE_MAX_VALUE (expr) = stream_read_tree (ib, data_in);\n-\n-      if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n-\tTYPE_BINFO (expr) = stream_read_tree (ib, data_in);\n-    }\n-  /* The fileds not streamed will be copied by\n-     lto_copy_fields_not_streamed.  */\n-  if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n+  if (TREE_CODE (expr) == ENUMERAL_TYPE)\n+    TYPE_VALUES (expr) = stream_read_tree (ib, data_in);\n+  else if (TREE_CODE (expr) == ARRAY_TYPE)\n+    TYPE_DOMAIN (expr) = stream_read_tree (ib, data_in);\n+  else if (RECORD_OR_UNION_TYPE_P (expr))\n     TYPE_FIELDS (expr) = streamer_read_chain (ib, data_in);\n   else if (TREE_CODE (expr) == FUNCTION_TYPE\n-           || TREE_CODE (expr) == METHOD_TYPE)\n+\t   || TREE_CODE (expr) == METHOD_TYPE)\n     TYPE_ARG_TYPES (expr) = stream_read_tree (ib, data_in);\n+\n+  if (!POINTER_TYPE_P (expr))\n+    TYPE_MINVAL (expr) = stream_read_tree (ib, data_in);\n+  TYPE_MAXVAL (expr) = stream_read_tree (ib, data_in);\n+  if (RECORD_OR_UNION_TYPE_P (expr))\n+    TYPE_BINFO (expr) = stream_read_tree (ib, data_in);\n }\n \n "}, {"sha": "52e714ef29ebec81aea578f993061f13af88e658", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 22, "deletions": 105, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=010f4e272f4edf8a0ba24f6cb5d2e084c0c9a33c", "patch": "@@ -313,7 +313,6 @@ pack_ts_type_common_value_fields (struct bitpack_d *bp, tree expr)\n   bp_pack_value (bp, TYPE_RESTRICT (expr), 1);\n   bp_pack_value (bp, TYPE_USER_ALIGN (expr), 1);\n   bp_pack_value (bp, TYPE_READONLY (expr), 1);\n-  bp_pack_value (bp, COMPLETE_TYPE_P (expr), 1);\n   bp_pack_var_len_unsigned (bp, TYPE_PRECISION (expr));\n   bp_pack_var_len_unsigned (bp, TYPE_ALIGN (expr));\n   /* Make sure to preserve the fact whether the frontend would assign\n@@ -699,37 +698,19 @@ static void\n write_ts_type_common_tree_pointers (struct output_block *ob, tree expr,\n \t\t\t\t    bool ref_p)\n {\n+  stream_write_tree (ob, TYPE_SIZE (expr), ref_p);\n+  stream_write_tree (ob, TYPE_SIZE_UNIT (expr), ref_p);\n+  stream_write_tree (ob, TYPE_ATTRIBUTES (expr), ref_p);\n+  stream_write_tree (ob, TYPE_NAME (expr), ref_p);\n+  /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n+     reconstructed during fixup.  */\n   /* Do not stream TYPE_NEXT_VARIANT, we reconstruct the variant lists\n      during fixup.  */\n   stream_write_tree (ob, TYPE_MAIN_VARIANT (expr), ref_p);\n-  if (TYPE_MAIN_VARIANT (expr) == expr)\n-    {\n-      if (COMPLETE_TYPE_P (expr))\n-\t{\n-\t  stream_write_tree (ob, TYPE_SIZE (expr), ref_p);\n-\t  stream_write_tree (ob, TYPE_SIZE_UNIT (expr), ref_p);\n-\t}\n-      stream_write_tree (ob, TYPE_ATTRIBUTES (expr), ref_p);\n-    }\n-  else\n-    {\n-      tree mv = TYPE_MAIN_VARIANT (expr);\n-\n-      gcc_checking_assert (TYPE_MAIN_VARIANT (mv) == mv);\n-      if (COMPLETE_TYPE_P (expr))\n-\t{\n-\t  gcc_checking_assert (TYPE_SIZE (expr) == TYPE_SIZE (mv));\n-\t  gcc_checking_assert (TYPE_SIZE_UNIT (expr) == TYPE_SIZE_UNIT (mv));\n-\t}\n-      gcc_checking_assert (TYPE_ATTRIBUTES (expr) == TYPE_ATTRIBUTES (mv));\n-    }\n-  stream_write_tree (ob, TYPE_NAME (expr), ref_p);\n   stream_write_tree (ob, TYPE_CONTEXT (expr), ref_p);\n-  stream_write_tree (ob, TYPE_STUB_DECL (expr), ref_p);\n-  /* Do not stream TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n-     reconstructed during fixup.  */\n   /* TYPE_CANONICAL is re-computed during type merging, so no need\n      to stream it here.  */\n+  stream_write_tree (ob, TYPE_STUB_DECL (expr), ref_p);\n }\n \n /* Write all pointer fields in the TS_TYPE_NON_COMMON structure of EXPR\n@@ -740,85 +721,21 @@ static void\n write_ts_type_non_common_tree_pointers (struct output_block *ob, tree expr,\n \t\t\t\t\tbool ref_p)\n {\n-  if (TYPE_MAIN_VARIANT (expr) == expr)\n-    {\n-      if (TREE_CODE (expr) == ENUMERAL_TYPE && COMPLETE_TYPE_P (expr))\n-\tstream_write_tree (ob, TYPE_VALUES (expr), ref_p);\n-      else if (TREE_CODE (expr) == ARRAY_TYPE)\n-\tstream_write_tree (ob, TYPE_DOMAIN (expr), ref_p);\n-\n-      /* TYPE_NEXT_PTR_TO and TYPE_NEXT_REF_TO is recomputed.  */\n-      if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n-\tstream_write_tree (ob, TYPE_VFIELD (expr), ref_p);\n-      else if ((TREE_CODE (expr) == ENUMERAL_TYPE && COMPLETE_TYPE_P (expr))\n-\t       || TREE_CODE (expr) == INTEGER_TYPE\n-\t       || TREE_CODE (expr) == BOOLEAN_TYPE\n-\t       || TREE_CODE (expr) == REAL_TYPE\n-\t       || TREE_CODE (expr) == FIXED_POINT_TYPE)\n-\tstream_write_tree (ob, TYPE_MIN_VALUE (expr), ref_p);\n-\n-      if (TREE_CODE (expr) == METHOD_TYPE)\n-\tstream_write_tree (ob, TYPE_METHOD_BASETYPE (expr), ref_p);\n-      else if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n-\tstream_write_tree (ob, TYPE_METHODS (expr), ref_p);\n-      else if (TREE_CODE (expr) == OFFSET_TYPE)\n-\tstream_write_tree (ob, TYPE_OFFSET_BASETYPE (expr), ref_p);\n-      else if (TREE_CODE (expr) == ARRAY_TYPE)\n-\tstream_write_tree (ob, TYPE_ARRAY_MAX_SIZE (expr), ref_p);\n-      else if ((TREE_CODE (expr) == ENUMERAL_TYPE && COMPLETE_TYPE_P (expr))\n-\t       || TREE_CODE (expr) == INTEGER_TYPE\n-\t       || TREE_CODE (expr) == BOOLEAN_TYPE\n-\t       || TREE_CODE (expr) == REAL_TYPE\n-\t       || TREE_CODE (expr) == FIXED_POINT_TYPE)\n-\tstream_write_tree (ob, TYPE_MAX_VALUE (expr), ref_p);\n-\n-      if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n-\tstream_write_tree (ob, TYPE_BINFO (expr), ref_p);\n-    }\n-  else\n-    {\n-      tree mv = TYPE_MAIN_VARIANT (expr);\n-\n-      if (TREE_CODE (expr) == ENUMERAL_TYPE)\n-        gcc_checking_assert (TYPE_VALUES (expr) == TYPE_VALUES (mv));\n-      else if (TREE_CODE (expr) == ARRAY_TYPE)\n-        gcc_checking_assert (TYPE_DOMAIN (expr) == TYPE_DOMAIN (mv));\n-\n-      if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n-        gcc_checking_assert (TYPE_VFIELD (expr) == TYPE_VFIELD (mv));\n-      else if ((TREE_CODE (expr) == ENUMERAL_TYPE && COMPLETE_TYPE_P (expr))\n-\t       || TREE_CODE (expr) == INTEGER_TYPE\n-\t       || TREE_CODE (expr) == BOOLEAN_TYPE\n-\t       || TREE_CODE (expr) == REAL_TYPE\n-\t       || TREE_CODE (expr) == FIXED_POINT_TYPE)\n-        gcc_checking_assert (TYPE_MINVAL (expr) == TYPE_MINVAL (mv));\n-\n-      if (TREE_CODE (expr) == METHOD_TYPE)\n-        gcc_checking_assert (TYPE_METHOD_BASETYPE (expr) == TYPE_METHOD_BASETYPE (mv));\n-      else if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n-        gcc_checking_assert (TYPE_METHODS (expr) == TYPE_METHODS (mv));\n-      else if (TREE_CODE (expr) == OFFSET_TYPE)\n-        gcc_checking_assert (TYPE_OFFSET_BASETYPE (expr) == TYPE_OFFSET_BASETYPE (mv));\n-      else if (TREE_CODE (expr) == ARRAY_TYPE)\n-        gcc_checking_assert (TYPE_ARRAY_MAX_SIZE (expr) == TYPE_ARRAY_MAX_SIZE (mv));\n-      else if ((TREE_CODE (expr) == ENUMERAL_TYPE && COMPLETE_TYPE_P (expr))\n-\t       || TREE_CODE (expr) == INTEGER_TYPE\n-\t       || TREE_CODE (expr) == BOOLEAN_TYPE\n-\t       || TREE_CODE (expr) == REAL_TYPE\n-\t       || TREE_CODE (expr) == FIXED_POINT_TYPE)\n-        gcc_checking_assert (TYPE_MAX_VALUE (expr) == TYPE_MAX_VALUE (mv));\n-\n-      if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n-        gcc_checking_assert (TYPE_BINFO (expr) == TYPE_BINFO (mv));\n-    }\n-   /* Fortran's gfc_nonrestricted_type may build variant that has different fields.  */\n-   if (RECORD_OR_UNION_TYPE_P (expr) && COMPLETE_TYPE_P (expr))\n-      streamer_write_chain (ob, TYPE_FIELDS (expr), ref_p);\n-   /* Parameters of variant may by modified in case ipa-prop decides to remove\n-      some.  */\n-   else if (TREE_CODE (expr) == FUNCTION_TYPE\n-       || TREE_CODE (expr) == METHOD_TYPE)\n-     stream_write_tree (ob, TYPE_ARG_TYPES (expr), ref_p);\n+  if (TREE_CODE (expr) == ENUMERAL_TYPE)\n+    stream_write_tree (ob, TYPE_VALUES (expr), ref_p);\n+  else if (TREE_CODE (expr) == ARRAY_TYPE)\n+    stream_write_tree (ob, TYPE_DOMAIN (expr), ref_p);\n+  else if (RECORD_OR_UNION_TYPE_P (expr))\n+    streamer_write_chain (ob, TYPE_FIELDS (expr), ref_p);\n+  else if (TREE_CODE (expr) == FUNCTION_TYPE\n+\t   || TREE_CODE (expr) == METHOD_TYPE)\n+    stream_write_tree (ob, TYPE_ARG_TYPES (expr), ref_p);\n+\n+  if (!POINTER_TYPE_P (expr))\n+    stream_write_tree (ob, TYPE_MINVAL (expr), ref_p);\n+  stream_write_tree (ob, TYPE_MAXVAL (expr), ref_p);\n+  if (RECORD_OR_UNION_TYPE_P (expr))\n+    stream_write_tree (ob, TYPE_BINFO (expr), ref_p);\n }\n \n "}]}