{"sha": "03988cac5874b40b3e9e2897daeba097cbe4aff9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM5ODhjYWM1ODc0YjQwYjNlOWUyODk3ZGFlYmEwOTdjYmU0YWZmOQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2003-07-17T00:59:52Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2003-07-17T00:59:52Z"}, "message": "loop.c (check_ext_dependent_givs): Pass const struct loop * instead of struct loop_info * as argument.\n\n\t* loop.c (check_ext_dependent_givs): Pass const struct loop *\n\tinstead of struct loop_info * as argument.  Accept BIVs with\n\tincrement +/- 1 provided there is a friendly exit test against\n\ta loop-invariant value.\n\t(strength_reduce): Adapt call to check_ext_dependent_givs.\n\nFrom-SVN: r69489", "tree": {"sha": "ae922b870910eab8b5ee7299ca8a8b4c8c16c132", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae922b870910eab8b5ee7299ca8a8b4c8c16c132"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03988cac5874b40b3e9e2897daeba097cbe4aff9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03988cac5874b40b3e9e2897daeba097cbe4aff9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03988cac5874b40b3e9e2897daeba097cbe4aff9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03988cac5874b40b3e9e2897daeba097cbe4aff9/comments", "author": null, "committer": null, "parents": [{"sha": "1129e7f414d67ef43b48065c78d5bdfb5e891909", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1129e7f414d67ef43b48065c78d5bdfb5e891909", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1129e7f414d67ef43b48065c78d5bdfb5e891909"}], "stats": {"total": 54, "additions": 46, "deletions": 8}, "files": [{"sha": "fc5e9674fc21f6ae1f6910df92acd9b13b34a02e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03988cac5874b40b3e9e2897daeba097cbe4aff9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03988cac5874b40b3e9e2897daeba097cbe4aff9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03988cac5874b40b3e9e2897daeba097cbe4aff9", "patch": "@@ -1,3 +1,11 @@\n+2003-07-16  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* loop.c (check_ext_dependent_givs): Pass const struct loop *\n+\tinstead of struct loop_info * as argument.  Accept BIVs with\n+\tincrement +/- 1 provided there is a friendly exit test against\n+\ta loop-invariant value.\n+\t(strength_reduce): Adapt call to check_ext_dependent_givs.\n+\n 2003-07-16  J\"orn Rennecke <joern.rennecke@superh.com>\n \t    Con Bradley <con.bradley@superh.com>\n "}, {"sha": "71c322c254bcbb1e51db288b32dfec785d5b9b9e", "filename": "gcc/loop.c", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03988cac5874b40b3e9e2897daeba097cbe4aff9/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03988cac5874b40b3e9e2897daeba097cbe4aff9/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=03988cac5874b40b3e9e2897daeba097cbe4aff9", "patch": "@@ -293,7 +293,7 @@ static void record_giv (const struct loop *, struct induction *, rtx, rtx,\n \t\t\trtx, rtx, rtx, rtx, int, enum g_types, int, int,\n \t\t\trtx *);\n static void update_giv_derive (const struct loop *, rtx);\n-static void check_ext_dependent_givs (struct iv_class *, struct loop_info *);\n+static void check_ext_dependent_givs (const struct loop *, struct iv_class *);\n static int basic_induction_var (const struct loop *, rtx, enum machine_mode,\n \t\t\t\trtx, rtx, rtx *, rtx *, rtx **);\n static rtx simplify_giv_expr (const struct loop *, rtx, rtx *, int *);\n@@ -5143,7 +5143,7 @@ strength_reduce (struct loop *loop, int flags)\n \n       /* Check each extension dependent giv in this class to see if its\n \t root biv is safe from wrapping in the interior mode.  */\n-      check_ext_dependent_givs (bl, loop_info);\n+      check_ext_dependent_givs (loop, bl);\n \n       /* Combine all giv's for this iv_class.  */\n       combine_givs (regs, bl);\n@@ -7286,8 +7286,9 @@ combine_givs_p (struct induction *g1, struct induction *g2)\n    make the giv illegal.  */\n \n static void\n-check_ext_dependent_givs (struct iv_class *bl, struct loop_info *loop_info)\n+check_ext_dependent_givs (const struct loop *loop, struct iv_class *bl)\n {\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n   int ze_ok = 0, se_ok = 0, info_ok = 0;\n   enum machine_mode biv_mode = GET_MODE (bl->biv->src_reg);\n   HOST_WIDE_INT start_val;\n@@ -7298,9 +7299,6 @@ check_ext_dependent_givs (struct iv_class *bl, struct loop_info *loop_info)\n \n   /* Make sure the iteration data is available.  We must have\n      constants in order to be certain of no overflow.  */\n-  /* ??? An unknown iteration count with an increment of +-1\n-     combined with friendly exit tests of against an invariant\n-     value is also amenable to optimization.  Not implemented.  */\n   if (loop_info->n_iterations > 0\n       && bl->initial_value\n       && GET_CODE (bl->initial_value) == CONST_INT\n@@ -7367,6 +7365,37 @@ check_ext_dependent_givs (struct iv_class *bl, struct loop_info *loop_info)\n \t}\n     }\n \n+  /* If we know the BIV is compared at run-time against an \n+     invariant value, and the increment is +/- 1, we may also \n+     be able to prove that the BIV cannot overflow.  */\n+  else if (bl->biv->src_reg == loop_info->iteration_var\n+           && loop_info->comparison_value\n+           && loop_invariant_p (loop, loop_info->comparison_value)\n+           && (incr = biv_total_increment (bl))\n+           && GET_CODE (incr) == CONST_INT)\n+    {\n+      /* If the increment is +1, and the exit test is a <,\n+         the BIV cannot overflow.  (For <=, we have the \n+         problematic case that the comparison value might\n+         be the maximum value of the range.)  */\n+       if (INTVAL (incr) == 1)\n+         {\n+           if (loop_info->comparison_code == LT)\n+             se_ok = ze_ok = 1;\n+           else if (loop_info->comparison_code == LTU)\n+             ze_ok = 1;\n+         }\n+\n+       /* Likewise for increment -1 and exit test >.  */\n+       if (INTVAL (incr) == -1)\n+         {\n+           if (loop_info->comparison_code == GT)\n+             se_ok = ze_ok = 1;\n+           else if (loop_info->comparison_code == GTU)\n+             ze_ok = 1;\n+         }\n+    }\n+\n   /* Invalidate givs that fail the tests.  */\n   for (v = bl->giv; v; v = v->next_iv)\n     if (v->ext_dependent)\n@@ -7388,8 +7417,9 @@ check_ext_dependent_givs (struct iv_class *bl, struct loop_info *loop_info)\n \t       signed or unsigned, so to safely truncate we must satisfy\n \t       both.  The initial check here verifies the BIV itself;\n \t       once that is successful we may check its range wrt the\n-\t       derived GIV.  */\n-\t    if (se_ok && ze_ok)\n+\t       derived GIV.  This works only if we were able to determine\n+\t       constant start and end values above.  */\n+\t    if (se_ok && ze_ok && info_ok)\n \t      {\n \t\tenum machine_mode outer_mode = GET_MODE (v->ext_dependent);\n \t\tunsigned HOST_WIDE_INT max = GET_MODE_MASK (outer_mode) >> 1;"}]}