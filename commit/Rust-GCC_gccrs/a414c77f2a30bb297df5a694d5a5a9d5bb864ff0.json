{"sha": "a414c77f2a30bb297df5a694d5a5a9d5bb864ff0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQxNGM3N2YyYTMwYmIyOTdkZjVhNjk0ZDVhNWE5ZDViYjg2NGZmMA==", "commit": {"author": {"name": "Ilya Enkovich", "email": "enkovich.gnu@gmail.com", "date": "2015-11-10T12:14:19Z"}, "committer": {"name": "Ilya Enkovich", "email": "ienkovich@gcc.gnu.org", "date": "2015-11-10T12:14:19Z"}, "message": "optabs-query.h (get_vcond_mask_icode): New.\n\ngcc/\n\n2015-11-10  Ilya Enkovich  <enkovich.gnu@gmail.com>\n\n\t* optabs-query.h (get_vcond_mask_icode): New.\n\t* optabs-tree.c (expand_vec_cond_expr_p): Use\n\tget_vcond_mask_icode for VEC_COND_EXPR with mask.\n\t* optabs.c (expand_vec_cond_mask_expr): New.\n\t(expand_vec_cond_expr): Use get_vcond_mask_icode\n\twhen possible.\n\t* optabs.def (vcond_mask_optab): New.\n\t* tree-vect-patterns.c (vect_recog_bool_pattern): Don't\n\tgenerate redundant comparison for COND_EXPR.\n\t* tree-vect-stmts.c (vect_is_simple_cond): Allow SSA_NAME\n\tas a condition.\n\t(vectorizable_condition): Likewise.\n\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Allow\n\tcond_exp with no embedded comparison.\n\t(vect_build_slp_tree_1): Likewise.\n\nFrom-SVN: r230101", "tree": {"sha": "98ceea7a2dde64ee53313efd5b9861e249694e69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98ceea7a2dde64ee53313efd5b9861e249694e69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0/comments", "author": null, "committer": null, "parents": [{"sha": "1ab8a1b176a006c47b61031a0d5b4bf07c98c316", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ab8a1b176a006c47b61031a0d5b4bf07c98c316", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ab8a1b176a006c47b61031a0d5b4bf07c98c316"}], "stats": {"total": 225, "additions": 159, "deletions": 66}, "files": [{"sha": "7b740a79430072613c4160ea16081590db130884", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a414c77f2a30bb297df5a694d5a5a9d5bb864ff0", "patch": "@@ -1,3 +1,21 @@\n+2015-11-10  Ilya Enkovich  <enkovich.gnu@gmail.com>\n+\n+\t* optabs-query.h (get_vcond_mask_icode): New.\n+\t* optabs-tree.c (expand_vec_cond_expr_p): Use\n+\tget_vcond_mask_icode for VEC_COND_EXPR with mask.\n+\t* optabs.c (expand_vec_cond_mask_expr): New.\n+\t(expand_vec_cond_expr): Use get_vcond_mask_icode\n+\twhen possible.\n+\t* optabs.def (vcond_mask_optab): New.\n+\t* tree-vect-patterns.c (vect_recog_bool_pattern): Don't\n+\tgenerate redundant comparison for COND_EXPR.\n+\t* tree-vect-stmts.c (vect_is_simple_cond): Allow SSA_NAME\n+\tas a condition.\n+\t(vectorizable_condition): Likewise.\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Allow\n+\tcond_exp with no embedded comparison.\n+\t(vect_build_slp_tree_1): Likewise.\n+\n 2015-11-10  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \t* config/i386/sse.md (maskload<mode>): Rename to ..."}, {"sha": "48bcf7c71d2efb4e570e2a003c62b8c6e681b9fc", "filename": "gcc/optabs-query.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0/gcc%2Foptabs-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0/gcc%2Foptabs-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.h?ref=a414c77f2a30bb297df5a694d5a5a9d5bb864ff0", "patch": "@@ -98,6 +98,15 @@ get_vcond_icode (machine_mode vmode, machine_mode cmode, bool uns)\n   return icode;\n }\n \n+/* Return insn code for a conditional operator with a mask mode\n+   MMODE resulting in a value of mode VMODE.  */\n+\n+static inline enum insn_code\n+get_vcond_mask_icode (machine_mode vmode, machine_mode mmode)\n+{\n+  return convert_optab_handler (vcond_mask_optab, vmode, mmode);\n+}\n+\n /* Enumerates the possible extraction_insn operations.  */\n enum extraction_pattern { EP_insv, EP_extv, EP_extzv };\n "}, {"sha": "d8876199496654ab810863475ea0c651c7db9037", "filename": "gcc/optabs-tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0/gcc%2Foptabs-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0/gcc%2Foptabs-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.c?ref=a414c77f2a30bb297df5a694d5a5a9d5bb864ff0", "patch": "@@ -342,6 +342,9 @@ expand_vec_cond_expr_p (tree value_type, tree cmp_op_type)\n {\n   machine_mode value_mode = TYPE_MODE (value_type);\n   machine_mode cmp_op_mode = TYPE_MODE (cmp_op_type);\n+  if (VECTOR_BOOLEAN_TYPE_P (cmp_op_type))\n+    return get_vcond_mask_icode (TYPE_MODE (value_type),\n+\t\t\t\t TYPE_MODE (cmp_op_type)) != CODE_FOR_nothing;\n   if (GET_MODE_SIZE (value_mode) != GET_MODE_SIZE (cmp_op_mode)\n       || GET_MODE_NUNITS (value_mode) != GET_MODE_NUNITS (cmp_op_mode)\n       || get_vcond_icode (TYPE_MODE (value_type), TYPE_MODE (cmp_op_type),"}, {"sha": "9b8e95855c9e9be78e263ec93b41d37ca3c884de", "filename": "gcc/optabs.c", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=a414c77f2a30bb297df5a694d5a5a9d5bb864ff0", "patch": "@@ -5426,6 +5426,38 @@ expand_vec_perm (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n   return tmp;\n }\n \n+/* Generate insns for a VEC_COND_EXPR with mask, given its TYPE and its\n+   three operands.  */\n+\n+rtx\n+expand_vec_cond_mask_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n+\t\t\t   rtx target)\n+{\n+  struct expand_operand ops[4];\n+  machine_mode mode = TYPE_MODE (vec_cond_type);\n+  machine_mode mask_mode = TYPE_MODE (TREE_TYPE (op0));\n+  enum insn_code icode = get_vcond_mask_icode (mode, mask_mode);\n+  rtx mask, rtx_op1, rtx_op2;\n+\n+  if (icode == CODE_FOR_nothing)\n+    return 0;\n+\n+  mask = expand_normal (op0);\n+  rtx_op1 = expand_normal (op1);\n+  rtx_op2 = expand_normal (op2);\n+\n+  mask = force_reg (GET_MODE (mask), mask);\n+  rtx_op1 = force_reg (GET_MODE (rtx_op1), rtx_op1);\n+\n+  create_output_operand (&ops[0], target, mode);\n+  create_input_operand (&ops[1], rtx_op1, mode);\n+  create_input_operand (&ops[2], rtx_op2, mode);\n+  create_input_operand (&ops[3], mask, mask_mode);\n+  expand_insn (icode, 4, ops);\n+\n+  return ops[0].value;\n+}\n+\n /* Generate insns for a VEC_COND_EXPR, given its TYPE and its\n    three operands.  */\n \n@@ -5450,11 +5482,20 @@ expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n     }\n   else\n     {\n-      /* Fake op0 < 0.  */\n       gcc_assert (VECTOR_BOOLEAN_TYPE_P (TREE_TYPE (op0)));\n-      op0a = op0;\n-      op0b = build_zero_cst (TREE_TYPE (op0));\n-      tcode = LT_EXPR;\n+      if (get_vcond_mask_icode (mode, TYPE_MODE (TREE_TYPE (op0)))\n+\t  != CODE_FOR_nothing)\n+\treturn expand_vec_cond_mask_expr (vec_cond_type, op0, op1,\n+\t\t\t\t\t  op2, target);\n+      /* Fake op0 < 0.  */\n+      else\n+\t{\n+\t  gcc_assert (GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (op0)))\n+\t\t      == MODE_VECTOR_INT);\n+\t  op0a = op0;\n+\t  op0b = build_zero_cst (TREE_TYPE (op0));\n+\t  tcode = LT_EXPR;\n+\t}\n     }\n   cmp_op_mode = TYPE_MODE (TREE_TYPE (op0a));\n   unsignedp = TYPE_UNSIGNED (TREE_TYPE (op0a));"}, {"sha": "0ca2333eeff63cadb46298e3cee61caa786126bf", "filename": "gcc/optabs.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=a414c77f2a30bb297df5a694d5a5a9d5bb864ff0", "patch": "@@ -61,6 +61,7 @@ OPTAB_CD(vec_load_lanes_optab, \"vec_load_lanes$a$b\")\n OPTAB_CD(vec_store_lanes_optab, \"vec_store_lanes$a$b\")\n OPTAB_CD(vcond_optab, \"vcond$a$b\")\n OPTAB_CD(vcondu_optab, \"vcondu$a$b\")\n+OPTAB_CD(vcond_mask_optab, \"vcond_mask_$a$b\")\n OPTAB_CD(vec_cmp_optab, \"vec_cmp$a$b\")\n OPTAB_CD(vec_cmpu_optab, \"vec_cmpu$a$b\")\n OPTAB_CD(maskload_optab, \"maskload$a$b\")"}, {"sha": "917eeb799b62f3d0b0250aff01c8ddc6c40f12ca", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=a414c77f2a30bb297df5a694d5a5a9d5bb864ff0", "patch": "@@ -3302,7 +3302,7 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n       else\n \t{\n \t  tree type = search_type_for_mask (var, vinfo);\n-\t  tree cst0, cst1, cmp, tmp;\n+\t  tree cst0, cst1, tmp;\n \n \t  if (!type)\n \t    return NULL;\n@@ -3318,9 +3318,7 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n \t  cst0 = build_int_cst (type, 0);\n \t  cst1 = build_int_cst (type, 1);\n \t  tmp = vect_recog_temp_ssa_var (type, NULL);\n-\t  cmp = build2 (NE_EXPR, boolean_type_node,\n-\t\t\tvar, build_int_cst (TREE_TYPE (var), 0));\n-\t  pattern_stmt = gimple_build_assign (tmp, COND_EXPR, cmp, cst1, cst0);\n+\t  pattern_stmt = gimple_build_assign (tmp, COND_EXPR, var, cst1, cst0);\n \n \t  if (!useless_type_conversion_p (type, TREE_TYPE (lhs)))\n \t    {\n@@ -3363,19 +3361,16 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n       if (get_vectype_for_scalar_type (type) == NULL_TREE)\n \treturn NULL;\n \n-      if (check_bool_pattern (var, vinfo))\n-\t{\n-\t  rhs = adjust_bool_pattern (var, type, NULL_TREE, stmts);\n-\t  rhs = build2 (NE_EXPR, boolean_type_node,\n-\t\t\trhs, build_int_cst (type, 0));\n-\t}\n-      else\n-\trhs = build2 (NE_EXPR, boolean_type_node,\n-\t\t      var, build_int_cst (TREE_TYPE (var), 0)),\n+      if (!check_bool_pattern (var, vinfo))\n+\treturn NULL;\n+\n+      rhs = adjust_bool_pattern (var, type, NULL_TREE, stmts);\n \n       lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n       pattern_stmt \n-\t  = gimple_build_assign (lhs, COND_EXPR, rhs,\n+\t  = gimple_build_assign (lhs, COND_EXPR,\n+\t\t\t\t build2 (NE_EXPR, boolean_type_node,\n+\t\t\t\t\t rhs, build_int_cst (type, 0)),\n \t\t\t\t gimple_assign_rhs2 (last_stmt),\n \t\t\t\t gimple_assign_rhs3 (last_stmt));\n       *type_out = vectype;\n@@ -3402,7 +3397,7 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n       else\n \t{\n \t  tree type = search_type_for_mask (var, vinfo);\n-\t  tree cst0, cst1, cmp, new_vectype;\n+\t  tree cst0, cst1, new_vectype;\n \n \t  if (!type)\n \t    return NULL;\n@@ -3415,10 +3410,7 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n \t  new_vectype = get_vectype_for_scalar_type (type);\n \n \t  rhs = vect_recog_temp_ssa_var (type, NULL);\n-\t  cmp = build2 (NE_EXPR, boolean_type_node,\n-\t\t\tvar, build_int_cst (TREE_TYPE (var), 0));\n-\t  pattern_stmt = gimple_build_assign (rhs, COND_EXPR,\n-\t\t\t\t\t      cmp, cst1, cst0);\n+\t  pattern_stmt = gimple_build_assign (rhs, COND_EXPR, var, cst1, cst0);\n \n \t  pattern_stmt_info = new_stmt_vec_info (pattern_stmt, vinfo);\n \t  set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);"}, {"sha": "9d971405e07c0ac20570b91c390c3253bace2e4e", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=a414c77f2a30bb297df5a694d5a5a9d5bb864ff0", "patch": "@@ -226,7 +226,8 @@ vect_get_and_check_slp_defs (vec_info *vinfo,\n     {\n       enum tree_code code = gimple_assign_rhs_code (stmt);\n       number_of_oprnds = gimple_num_ops (stmt) - 1;\n-      if (gimple_assign_rhs_code (stmt) == COND_EXPR)\n+      if (gimple_assign_rhs_code (stmt) == COND_EXPR\n+\t  && COMPARISON_CLASS_P (gimple_assign_rhs1 (stmt)))\n \t{\n \t  first_op_cond = true;\n \t  commutative = true;\n@@ -447,7 +448,6 @@ vect_build_slp_tree_1 (vec_info *vinfo,\n   machine_mode vec_mode;\n   HOST_WIDE_INT dummy;\n   gimple *first_load = NULL, *prev_first_load = NULL;\n-  tree cond;\n \n   /* For every stmt in NODE find its def stmt/s.  */\n   FOR_EACH_VEC_ELT (stmts, i, stmt)\n@@ -492,24 +492,6 @@ vect_build_slp_tree_1 (vec_info *vinfo,\n \t  return false;\n \t}\n \n-       if (is_gimple_assign (stmt)\n-\t   && gimple_assign_rhs_code (stmt) == COND_EXPR\n-           && (cond = gimple_assign_rhs1 (stmt))\n-           && !COMPARISON_CLASS_P (cond))\n-        {\n-          if (dump_enabled_p ())\n-            {\n-              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-\t\t\t       \"Build SLP failed: condition is not \"\n-\t\t\t       \"comparison \");\n-              dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-            }\n-\t  /* Fatal mismatch.  */\n-\t  matches[0] = false;\n-          return false;\n-        }\n-\n       scalar_type = vect_get_smallest_scalar_type (stmt, &dummy, &dummy);\n       vectype = get_vectype_for_scalar_type (scalar_type);\n       if (!vectype)"}, {"sha": "c024348cef1cf5aa1312b28b686a6f922ba60e35", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 70, "deletions": 23, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a414c77f2a30bb297df5a694d5a5a9d5bb864ff0/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=a414c77f2a30bb297df5a694d5a5a9d5bb864ff0", "patch": "@@ -7168,6 +7168,19 @@ vect_is_simple_cond (tree cond, vec_info *vinfo, tree *comp_vectype)\n   enum vect_def_type dt;\n   tree vectype1 = NULL_TREE, vectype2 = NULL_TREE;\n \n+  /* Mask case.  */\n+  if (TREE_CODE (cond) == SSA_NAME\n+      && TREE_CODE (TREE_TYPE (cond)) == BOOLEAN_TYPE)\n+    {\n+      gimple *lhs_def_stmt = SSA_NAME_DEF_STMT (cond);\n+      if (!vect_is_simple_use (cond, vinfo, &lhs_def_stmt,\n+\t\t\t       &dt, comp_vectype)\n+\t  || !*comp_vectype\n+\t  || !VECTOR_BOOLEAN_TYPE_P (*comp_vectype))\n+\treturn false;\n+      return true;\n+    }\n+\n   if (!COMPARISON_CLASS_P (cond))\n     return false;\n \n@@ -7237,6 +7250,7 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n   vec<tree> vec_oprnds2 = vNULL;\n   vec<tree> vec_oprnds3 = vNULL;\n   tree vec_cmp_type;\n+  bool masked = false;\n \n   if (reduc_index && STMT_SLP_TYPE (stmt_info))\n     return false;\n@@ -7296,7 +7310,13 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (!vect_is_simple_use (else_clause, stmt_info->vinfo, &def_stmt, &dt))\n     return false;\n \n-  vec_cmp_type = build_same_sized_truth_vector_type (comp_vectype);\n+  if (VECTOR_BOOLEAN_TYPE_P (comp_vectype))\n+    {\n+      vec_cmp_type = comp_vectype;\n+      masked = true;\n+    }\n+  else\n+    vec_cmp_type = build_same_sized_truth_vector_type (comp_vectype);\n   if (vec_cmp_type == NULL_TREE)\n     return false;\n \n@@ -7331,14 +7351,20 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n               auto_vec<tree, 4> ops;\n \t      auto_vec<vec<tree>, 4> vec_defs;\n \n-              ops.safe_push (TREE_OPERAND (cond_expr, 0));\n-              ops.safe_push (TREE_OPERAND (cond_expr, 1));\n+\t      if (masked)\n+\t\t  ops.safe_push (cond_expr);\n+\t      else\n+\t\t{\n+\t\t  ops.safe_push (TREE_OPERAND (cond_expr, 0));\n+\t\t  ops.safe_push (TREE_OPERAND (cond_expr, 1));\n+\t\t}\n               ops.safe_push (then_clause);\n               ops.safe_push (else_clause);\n               vect_get_slp_defs (ops, slp_node, &vec_defs, -1);\n \t      vec_oprnds3 = vec_defs.pop ();\n \t      vec_oprnds2 = vec_defs.pop ();\n-\t      vec_oprnds1 = vec_defs.pop ();\n+\t      if (!masked)\n+\t\tvec_oprnds1 = vec_defs.pop ();\n \t      vec_oprnds0 = vec_defs.pop ();\n \n               ops.release ();\n@@ -7347,17 +7373,28 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n           else\n             {\n \t      gimple *gtemp;\n-\t      vec_cond_lhs =\n-\t\tvect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 0),\n-\t\t\t\t\t      stmt, comp_vectype);\n-\t      vect_is_simple_use (TREE_OPERAND (cond_expr, 0),\n-\t\t\t\t  loop_vinfo, &gtemp, &dts[0]);\n-\n-\t      vec_cond_rhs =\n-\t\tvect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 1),\n-\t\t\t\t\t      stmt, comp_vectype);\n-\t      vect_is_simple_use (TREE_OPERAND (cond_expr, 1),\n-\t\t\t\t  loop_vinfo, &gtemp, &dts[1]);\n+\t      if (masked)\n+\t\t{\n+\t\t  vec_cond_lhs\n+\t\t    = vect_get_vec_def_for_operand (cond_expr, stmt,\n+\t\t\t\t\t\t    comp_vectype);\n+\t\t  vect_is_simple_use (cond_expr, stmt_info->vinfo,\n+\t\t\t\t      &gtemp, &dts[0]);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  vec_cond_lhs =\n+\t\t    vect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 0),\n+\t\t\t\t\t\t  stmt, comp_vectype);\n+\t\t  vect_is_simple_use (TREE_OPERAND (cond_expr, 0),\n+\t\t\t\t      loop_vinfo, &gtemp, &dts[0]);\n+\n+\t\t  vec_cond_rhs =\n+\t\t    vect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 1),\n+\t\t\t\t\t\t  stmt, comp_vectype);\n+\t\t  vect_is_simple_use (TREE_OPERAND (cond_expr, 1),\n+\t\t\t\t      loop_vinfo, &gtemp, &dts[1]);\n+\t\t}\n \t      if (reduc_index == 1)\n \t\tvec_then_clause = reduc_def;\n \t      else\n@@ -7379,10 +7416,14 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n \t}\n       else\n \t{\n-\t  vec_cond_lhs = vect_get_vec_def_for_stmt_copy (dts[0],\n-\t\t\t\t\t\t\t vec_oprnds0.pop ());\n-\t  vec_cond_rhs = vect_get_vec_def_for_stmt_copy (dts[1],\n-\t\t\t\t\t\t\t vec_oprnds1.pop ());\n+\t  vec_cond_lhs\n+\t    = vect_get_vec_def_for_stmt_copy (dts[0],\n+\t\t\t\t\t      vec_oprnds0.pop ());\n+\t  if (!masked)\n+\t    vec_cond_rhs\n+\t      = vect_get_vec_def_for_stmt_copy (dts[1],\n+\t\t\t\t\t\tvec_oprnds1.pop ());\n+\n \t  vec_then_clause = vect_get_vec_def_for_stmt_copy (dts[2],\n \t\t\t\t\t\t\t    vec_oprnds2.pop ());\n \t  vec_else_clause = vect_get_vec_def_for_stmt_copy (dts[3],\n@@ -7392,20 +7433,26 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (!slp_node)\n         {\n \t  vec_oprnds0.quick_push (vec_cond_lhs);\n-\t  vec_oprnds1.quick_push (vec_cond_rhs);\n+\t  if (!masked)\n+\t    vec_oprnds1.quick_push (vec_cond_rhs);\n \t  vec_oprnds2.quick_push (vec_then_clause);\n \t  vec_oprnds3.quick_push (vec_else_clause);\n \t}\n \n       /* Arguments are ready.  Create the new vector stmt.  */\n       FOR_EACH_VEC_ELT (vec_oprnds0, i, vec_cond_lhs)\n         {\n-          vec_cond_rhs = vec_oprnds1[i];\n           vec_then_clause = vec_oprnds2[i];\n           vec_else_clause = vec_oprnds3[i];\n \n-\t  vec_compare = build2 (TREE_CODE (cond_expr), vec_cmp_type,\n-\t\t\t\tvec_cond_lhs, vec_cond_rhs);\n+\t  if (masked)\n+\t    vec_compare = vec_cond_lhs;\n+\t  else\n+\t    {\n+\t      vec_cond_rhs = vec_oprnds1[i];\n+\t      vec_compare = build2 (TREE_CODE (cond_expr), vec_cmp_type,\n+\t\t\t\t    vec_cond_lhs, vec_cond_rhs);\n+\t    }\n           vec_cond_expr = build3 (VEC_COND_EXPR, vectype,\n  \t\t         vec_compare, vec_then_clause, vec_else_clause);\n "}]}