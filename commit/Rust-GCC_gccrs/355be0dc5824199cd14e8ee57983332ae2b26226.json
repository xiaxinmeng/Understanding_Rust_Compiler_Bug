{"sha": "355be0dc5824199cd14e8ee57983332ae2b26226", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU1YmUwZGM1ODI0MTk5Y2QxNGU4ZWU1Nzk4MzMzMmFlMmIyNjIyNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-06-20T17:51:06Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-06-20T17:51:06Z"}, "message": "Mon Jun 10 20:42:34 CEST 2002  Jan Hubicka  <jh@suse.cz>\n\n\t* basic-block.h: Do not include et-forest.h\n\t(dominance_info): Declare as struct dominance-info.\n\t* cfglayout.c (cleanup_unconditional_jumps): Remove the edge before\n\tdeleting block.\n\t* dominance.c (struct dominance_info): Define.\n\t(BB_NODE, SET_BB_NODE): New macros.\n\t(bb_hash_func, bb_eq_func): Kill.\n\t(calculate_dominace_info, free_dominacne_info, set_immediate_dominator,\n\tnearest_common_dominator, dominated_by_p, recount_dominator,\n\tadd_to_dominance_info, delete_from_dominance_info): update for new\n\trepresentation.\n\t(get_dominated_by, redirect_immediate_dominators): Rewrite using\n\tenumerate_sons.\n\t* ifcvt.c (process_double_test_block, merge_if_block, find_cond_trap,\n\tfind_if_case_1, find_if_case_2): Remove killed blocks from dominance\n\tstructure.\n\n\t* et-forest.h: Update copyright; revamp all function to operate on\n\tnodes\n\t(et_forest_value): Kill.\n\t(et_forest_enumerate_sons, et_forest_node_value): New.\n\t* et-forest.c: Update copyright.\n\t* et-forest.h: Update copyright; revamp all function to operate on\n\tnodes\n\t(et_forest_value): Kill.\n\t(et_forest_enumerate_sons, et_forest_node_value): New.\n\n\tThu Jun  6 22:43:43 CEST 2002  Jan Hubicka  <jh@suse.cz>\n\n\t* basic-block.h: Inlude et-forest.h\n\t(basic_block_def): Kill dominator.\n\t(dominance_info): New type.\n\t(loops): Use dominace_info.\n\t(dominace handling functions): Take dominace_info as argument\n\tinstead of bitmaps.\n\t(create_preheader): Likewise.\n\t* cfg.c (entry_exit_blocks): Kill dominator.\n\t(dump_flow_info): Do not dump dominators.\n\t* cfglayout.c (cleanup_unconditonal_jumps): Delete deleted block from\n\tdominators.\n\t* cfgloop.c (flow_pre_header_find): Use dominacne_info.\n\t(flow_loops_pre_header_scan, make_forwarder_block,\n\tcanonicale_loop_headers, flow_loops_find): Likewise.\n\t* dominance.c: Include error.h\n\t(idoms_to_doms): Kill.\n\t(bb_hash_func, bb_eq_func): New static functions.\n\t(debug_dominace_info): New global function.\n\t(calculate_dominance_info): Use new et forest structure.\n\t(free_dominace_info, get_immediate_dominator, set_immediate_dominator,\n\tget_dominated_by, redirect_immediate_dominators,\n\tnearest_common_dominator, dominated_by_p, verify_dominators,\n\trecount_dominator, iterate_fix_dominators, add_to_dominace_info,\n\tdelete_from_dominance_info): New global functions.\n\t* gcse.c (domnators): CHange to dominance_info.\n\t(alloc_hoist_mem): Do not alloc dominators\n\t(free_code_hoist_mem): Use free_dominance_info.\n\t(compute_code_hoist_data): Use dominance_info.\n\t(hoist_code): Likewise.\n\t* ifcvt.c (post_dominators): Likewise.\n\t(find_if_case_2, if_convert): Likewise.\n\t* predict.c (process_note_predictions, process_note_prediction,\n\testimate-probability): Likewise.\n\t* sched-rgn.c (find_rgns, init_regions): Likewise.\n\t* ssa-dce.c (find_all_control_dependences, fint_control_depemndence,\n\tfind_pdom, delete_insn_bb, ssa_eliminate_dead_code): Likewise.\n\t* ssa.c (compute_dominance_frontiers_1, rename_block, rename_registers,\n\tfind_evaluations, convert_to_ssa): Likewise.\n\t* ssa.h (compute_dominance_frontiers): Likewise.\n\n\tThu Jun  6 22:57:34 CEST 2002  Pavel Nejedly <bim@atrey.karlin.mff.cuni.cz>\n\n\t* Makefile.in (et-forest.c): Add.\n\t* et-forest.c: New file.\n\t* at-forest.h: New file.\n\nCo-Authored-By: Pavel Nejedly <bim@atrey.karlin.mff.cuni.cz>\n\nFrom-SVN: r54843", "tree": {"sha": "8635e8934338aabce3b83e28ee4e39d8b3df5645", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8635e8934338aabce3b83e28ee4e39d8b3df5645"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/355be0dc5824199cd14e8ee57983332ae2b26226", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355be0dc5824199cd14e8ee57983332ae2b26226", "html_url": "https://github.com/Rust-GCC/gccrs/commit/355be0dc5824199cd14e8ee57983332ae2b26226", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355be0dc5824199cd14e8ee57983332ae2b26226/comments", "author": null, "committer": null, "parents": [{"sha": "62c71f4bc29a578f50b161f20fb5f56826f4f019", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62c71f4bc29a578f50b161f20fb5f56826f4f019", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62c71f4bc29a578f50b161f20fb5f56826f4f019"}], "stats": {"total": 661, "additions": 478, "deletions": 183}, "files": [{"sha": "3394b0453650416ef238f8d85299db7d0a55b922", "filename": "gcc/ChangeLog", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=355be0dc5824199cd14e8ee57983332ae2b26226", "patch": "@@ -1,3 +1,83 @@\n+Thu Jun 20 19:42:21 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\t\t\t       Pavel Nejedly  <bim@atrey.karlin.mff.cuni.cz>\n+\n+\tMon Jun 10 20:42:34 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h: Do not include et-forest.h\n+\t(dominance_info): Declare as struct dominance-info.\n+\t* cfglayout.c (cleanup_unconditional_jumps): Remove the edge before\n+\tdeleting block.\n+\t* dominance.c (struct dominance_info): Define.\n+\t(BB_NODE, SET_BB_NODE): New macros.\n+\t(bb_hash_func, bb_eq_func): Kill.\n+\t(calculate_dominace_info, free_dominacne_info, set_immediate_dominator,\n+\tnearest_common_dominator, dominated_by_p, recount_dominator,\n+\tadd_to_dominance_info, delete_from_dominance_info): update for new\n+\trepresentation.\n+\t(get_dominated_by, redirect_immediate_dominators): Rewrite using\n+\tenumerate_sons.\n+\t* ifcvt.c (process_double_test_block, merge_if_block, find_cond_trap,\n+\tfind_if_case_1, find_if_case_2): Remove killed blocks from dominance\n+\tstructure.\n+\n+\t* et-forest.h: Update copyright; revamp all function to operate on\n+\tnodes\n+\t(et_forest_value): Kill.\n+\t(et_forest_enumerate_sons, et_forest_node_value): New.\n+\t* et-forest.c: Update copyright.\n+\t* et-forest.h: Update copyright; revamp all function to operate on\n+\tnodes\n+\t(et_forest_value): Kill.\n+\t(et_forest_enumerate_sons, et_forest_node_value): New.\n+\n+\tThu Jun  6 22:43:43 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h: Inlude et-forest.h\n+\t(basic_block_def): Kill dominator.\n+\t(dominance_info): New type.\n+\t(loops): Use dominace_info.\n+\t(dominace handling functions): Take dominace_info as argument\n+\tinstead of bitmaps.\n+\t(create_preheader): Likewise.\n+\t* cfg.c (entry_exit_blocks): Kill dominator.\n+\t(dump_flow_info): Do not dump dominators.\n+\t* cfglayout.c (cleanup_unconditonal_jumps): Delete deleted block from\n+\tdominators.\n+\t* cfgloop.c (flow_pre_header_find): Use dominacne_info.\n+\t(flow_loops_pre_header_scan, make_forwarder_block,\n+\tcanonicale_loop_headers, flow_loops_find): Likewise.\n+\t* dominance.c: Include error.h\n+\t(idoms_to_doms): Kill.\n+\t(bb_hash_func, bb_eq_func): New static functions.\n+\t(debug_dominace_info): New global function.\n+\t(calculate_dominance_info): Use new et forest structure.\n+\t(free_dominace_info, get_immediate_dominator, set_immediate_dominator,\n+\tget_dominated_by, redirect_immediate_dominators,\n+\tnearest_common_dominator, dominated_by_p, verify_dominators,\n+\trecount_dominator, iterate_fix_dominators, add_to_dominace_info,\n+\tdelete_from_dominance_info): New global functions.\n+\t* gcse.c (domnators): CHange to dominance_info.\n+\t(alloc_hoist_mem): Do not alloc dominators\n+\t(free_code_hoist_mem): Use free_dominance_info.\n+\t(compute_code_hoist_data): Use dominance_info.\n+\t(hoist_code): Likewise.\n+\t* ifcvt.c (post_dominators): Likewise.\n+\t(find_if_case_2, if_convert): Likewise.\n+\t* predict.c (process_note_predictions, process_note_prediction,\n+\testimate-probability): Likewise.\n+\t* sched-rgn.c (find_rgns, init_regions): Likewise.\n+\t* ssa-dce.c (find_all_control_dependences, fint_control_depemndence,\n+\tfind_pdom, delete_insn_bb, ssa_eliminate_dead_code): Likewise.\n+\t* ssa.c (compute_dominance_frontiers_1, rename_block, rename_registers,\n+\tfind_evaluations, convert_to_ssa): Likewise.\n+\t* ssa.h (compute_dominance_frontiers): Likewise.\n+\n+\tThu Jun  6 22:57:34 CEST 2002  Pavel Nejedly <bim@atrey.karlin.mff.cuni.cz>\n+\n+\t* Makefile.in (et-forest.c): Add.\n+\t* et-forest.c: New file.\n+\t* at-forest.h: New file.\n+\n 2002-06-20  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* c-decl.c (c_decode_option): Use ARRAY_SIZE in lieu of explicit"}, {"sha": "07a3b8c1808176c581e509c40957b11d6f88010f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=355be0dc5824199cd14e8ee57983332ae2b26226", "patch": "@@ -736,7 +736,7 @@ OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t   \\\n  sibcall.o simplify-rtx.o ssa.o ssa-ccp.o ssa-dce.o stmt.o\t\t   \\\n  stor-layout.o stringpool.o timevar.o toplev.o tracer.o tree.o tree-dump.o \\\n  tree-inline.o unroll.o varasm.o varray.o version.o vmsdbgout.o xcoffout.o \\\n- $(GGC) $(out_object_file) $(EXTRA_OBJS)\n+ et-forest.o $(GGC) $(out_object_file) $(EXTRA_OBJS)\n \n BACKEND = main.o libbackend.a\n \n@@ -1543,7 +1543,8 @@ cfgcleanup.o : cfgcleanup.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TIMEVAR_H)\\\n cfgloop.o : cfgloop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h\n dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) hard-reg-set.h \\\n-   $(BASIC_BLOCK_H)\n+   $(BASIC_BLOCK_H) et-forest.h\n+et-forest.o : et-forest.c $(CONFIG_H) $(SYSTEM_H) et-forest.h\n combine.o : combine.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h function.h \\\n    insn-config.h $(INSN_ATTR_H) $(REGS_H) $(EXPR_H) \\\n    $(BASIC_BLOCK_H) $(RECOG_H) real.h hard-reg-set.h toplev.h $(TM_P_H)"}, {"sha": "9e3e7a546834be7247675b85ceeae77655afa894", "filename": "gcc/basic-block.h", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=355be0dc5824199cd14e8ee57983332ae2b26226", "patch": "@@ -350,6 +350,10 @@ extern void clear_edges\t\t\tPARAMS ((void));\n extern void mark_critical_edges\t\tPARAMS ((void));\n extern rtx first_insn_after_basic_block_note\tPARAMS ((basic_block));\n \n+/* Dominator information for basic blocks.  */\n+\n+typedef struct dominance_info *dominance_info;\n+\n /* Structure to hold information for each natural loop.  */\n struct loop\n {\n@@ -498,7 +502,7 @@ struct loops\n   struct cfg\n   {\n     /* The bitmap vector of dominators or NULL if not computed.  */\n-    sbitmap *dom;\n+    dominance_info dom;\n \n     /* The ordering of the basic blocks in a depth first search.  */\n     int *dfs_order;\n@@ -770,7 +774,21 @@ enum cdi_direction\n   CDI_POST_DOMINATORS\n };\n \n-extern void calculate_dominance_info\tPARAMS ((int *, sbitmap *,\n-\t\t\t\t\t\t enum cdi_direction));\n-\n+extern dominance_info calculate_dominance_info\tPARAMS ((enum cdi_direction));\n+extern void free_dominance_info\t\t\tPARAMS ((dominance_info));\n+extern basic_block nearest_common_dominator\tPARAMS ((dominance_info,\n+\t\t\t\t\t\t basic_block, basic_block));\n+extern void set_immediate_dominator\tPARAMS ((dominance_info,\n+\t\t\t\t\t\t basic_block, basic_block));\n+extern basic_block get_immediate_dominator\tPARAMS ((dominance_info,\n+\t\t\t\t\t\t basic_block));\n+extern bool dominated_by_p\tPARAMS ((dominance_info, basic_block, basic_block));\n+extern int get_dominated_by PARAMS ((dominance_info, basic_block, basic_block **));\n+extern void add_to_dominance_info PARAMS ((dominance_info, basic_block));\n+extern void delete_from_dominance_info PARAMS ((dominance_info, basic_block));\n+basic_block recount_dominator PARAMS ((dominance_info, basic_block));\n+extern void redirect_immediate_dominators PARAMS ((dominance_info, basic_block,\n+\t\t\t\t\t\t basic_block));\n+void iterate_fix_dominators PARAMS ((dominance_info, basic_block *, int));\n+extern void verify_dominators PARAMS ((dominance_info));\n #endif /* GCC_BASIC_BLOCK_H */"}, {"sha": "09a1fb24a1e90c3397ed66d55dabaee27d7d3458", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=355be0dc5824199cd14e8ee57983332ae2b26226", "patch": "@@ -36,7 +36,7 @@ static void flow_loop_exit_edges_find\tPARAMS ((struct loop *));\n static int flow_loop_nodes_find\t\tPARAMS ((basic_block, struct loop *));\n static void flow_loop_pre_header_scan\tPARAMS ((struct loop *));\n static basic_block flow_loop_pre_header_find PARAMS ((basic_block,\n-\t\t\t\t\t\t      const sbitmap *));\n+\t\t\t\t\t\t      dominance_info));\n static int flow_loop_level_compute\tPARAMS ((struct loop *));\n static int flow_loops_level_compute\tPARAMS ((struct loops *));\n static basic_block make_forwarder_block PARAMS ((basic_block, int, int,\n@@ -224,7 +224,7 @@ flow_loops_free (loops)\n       loops->parray = NULL;\n \n       if (loops->cfg.dom)\n-\tsbitmap_vector_free (loops->cfg.dom);\n+\tfree_dominance_info (loops->cfg.dom);\n \n       if (loops->cfg.dfs_order)\n \tfree (loops->cfg.dfs_order);\n@@ -415,7 +415,7 @@ flow_loop_pre_header_scan (loop)\n static basic_block\n flow_loop_pre_header_find (header, dom)\n      basic_block header;\n-     const sbitmap *dom;\n+     dominance_info dom;\n {\n   basic_block pre_header;\n   edge e;\n@@ -428,7 +428,7 @@ flow_loop_pre_header_find (header, dom)\n       basic_block node = e->src;\n \n       if (node != ENTRY_BLOCK_PTR\n-\t  && ! TEST_BIT (dom[node->index], header->index))\n+\t  && ! dominated_by_p (dom, node, header))\n \t{\n \t  if (pre_header == NULL)\n \t    pre_header = node;\n@@ -645,13 +645,12 @@ make_forwarder_block (bb, redirect_latch, redirect_nonlatch, except,\n static void\n canonicalize_loop_headers ()\n {\n-  sbitmap *dom;\n+  dominance_info dom;\n   basic_block header;\n   edge e;\n   \n   /* Compute the dominators.  */\n-  dom = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n-  calculate_dominance_info (NULL, dom, CDI_DOMINATORS);\n+  dom = calculate_dominance_info (CDI_DOMINATORS);\n \n   alloc_aux_for_blocks (sizeof (int));\n   alloc_aux_for_edges (sizeof (int));\n@@ -670,7 +669,7 @@ canonicalize_loop_headers ()\n \t    have_abnormal_edge = 1;\n \n \t  if (latch != ENTRY_BLOCK_PTR\n-\t      && TEST_BIT (dom[latch->index], header->index))\n+\t      && dominated_by_p (dom, latch, header))\n \t    {\n \t      num_latches++;\n \t      LATCH_EDGE (e) = 1;\n@@ -747,7 +746,7 @@ canonicalize_loop_headers ()\n \n   free_aux_for_blocks ();\n   free_aux_for_edges ();\n-  sbitmap_vector_free (dom);\n+  free_dominance_info (dom);\n }\n \n /* Find all the natural loops in the function and save in LOOPS structure and\n@@ -765,10 +764,11 @@ flow_loops_find (loops, flags)\n   int num_loops;\n   edge e;\n   sbitmap headers;\n-  sbitmap *dom;\n+  dominance_info dom;\n   int *dfs_order;\n   int *rc_order;\n-  basic_block header, bb;\n+  basic_block header;\n+  basic_block bb;\n \n   /* This function cannot be repeatedly called with different\n      flags to build up the loop information.  The loop tree\n@@ -790,8 +790,7 @@ flow_loops_find (loops, flags)\n   canonicalize_loop_headers ();\n \n   /* Compute the dominators.  */\n-  loops->cfg.dom = dom = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n-  calculate_dominance_info (NULL, dom, CDI_DOMINATORS);\n+  dom = loops->cfg.dom = calculate_dominance_info (CDI_DOMINATORS);\n \n   /* Count the number of loop headers.  This should be the\n      same as the number of natural loops.  */\n@@ -824,8 +823,7 @@ flow_loops_find (loops, flags)\n \t     node (header) that dominates all the nodes in the\n \t     loop.  It also has single back edge to the header\n \t     from a latch node.  */\n-\t  if (latch != ENTRY_BLOCK_PTR && TEST_BIT (dom[latch->index],\n-\t\t\t\t\t\t    header->index))\n+\t  if (latch != ENTRY_BLOCK_PTR && dominated_by_p (dom, latch, header))\n \t    {\n \t      /* Shared headers should be eliminated by now.  */\n \t      if (more_latches)\n@@ -899,7 +897,7 @@ flow_loops_find (loops, flags)\n \t      basic_block latch = e->src;\n \n \t      if (latch != ENTRY_BLOCK_PTR\n-\t\t  && TEST_BIT (dom[latch->index], header->index))\n+\t\t  && dominated_by_p (dom, latch, header))\n \t\t{\n \t\t  loop->latch = latch;\n \t\t  break;\n@@ -925,7 +923,7 @@ flow_loops_find (loops, flags)\n   else\n     {\n       loops->cfg.dom = NULL;\n-      sbitmap_vector_free (dom);\n+      free_dominance_info (dom);\n     }\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();"}, {"sha": "d080957eb46e9daf38c7253f92f940a374633aeb", "filename": "gcc/dominance.c", "status": "modified", "additions": 253, "deletions": 64, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=355be0dc5824199cd14e8ee57983332ae2b26226", "patch": "@@ -38,7 +38,19 @@\n #include \"rtl.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n+#include \"error.h\"\n+#include \"et-forest.h\"\n \n+struct dominance_info\n+{\n+  et_forest_t forest;\n+  varray_type varray;\n+};\n+\n+#define BB_NODE(info, bb) \\\n+  ((et_forest_node_t)VARRAY_GENERIC_PTR ((info)->varray, (bb)->index + 2))\n+#define SET_BB_NODE(info, bb, node) \\\n+  (VARRAY_GENERIC_PTR ((info)->varray, (bb)->index + 2) = (node))\n \n /* We name our nodes with integers, beginning with 1.  Zero is reserved for\n    'undefined' or 'end of list'.  The name of each node is given by the dfs\n@@ -113,8 +125,7 @@ static TBB eval\t\t\t\tPARAMS ((struct dom_info *, TBB));\n static void link_roots\t\t\tPARAMS ((struct dom_info *, TBB, TBB));\n static void calc_idoms\t\t\tPARAMS ((struct dom_info *,\n \t\t\t\t\t\t enum cdi_direction));\n-static void idoms_to_doms\t\tPARAMS ((struct dom_info *,\n-\t\t\t\t\t\t sbitmap *));\n+void debug_dominance_info\t\tPARAMS ((dominance_info));\n \n /* Helper macro for allocating and initializing an array,\n    for aesthetic reasons.  */\n@@ -531,50 +542,6 @@ calc_idoms (di, reverse)\n       di->dom[v] = di->dom[di->dom[v]];\n }\n \n-/* Convert the information about immediate dominators (in DI) to sets of all\n-   dominators (in DOMINATORS).  */\n-\n-static void\n-idoms_to_doms (di, dominators)\n-     struct dom_info *di;\n-     sbitmap *dominators;\n-{\n-  TBB i, e_index;\n-  int bb, bb_idom;\n-  sbitmap_vector_zero (dominators, last_basic_block);\n-  /* We have to be careful, to not include the ENTRY_BLOCK or EXIT_BLOCK\n-     in the list of (post)-doms, so remember that in e_index.  */\n-  e_index = di->dfs_order[last_basic_block];\n-\n-  for (i = 1; i <= di->nodes; i++)\n-    {\n-      if (i == e_index)\n-\tcontinue;\n-      bb = di->dfs_to_bb[i]->index;\n-\n-      if (di->dom[i] && (di->dom[i] != e_index))\n-\t{\n-\t  bb_idom = di->dfs_to_bb[di->dom[i]]->index;\n-\t  sbitmap_copy (dominators[bb], dominators[bb_idom]);\n-\t}\n-      else\n-\t{\n-\t  /* It has no immediate dom or only ENTRY_BLOCK or EXIT_BLOCK.\n-\t     If it is a child of ENTRY_BLOCK that's OK, and it's only\n-\t     dominated by itself; if it's _not_ a child of ENTRY_BLOCK, it\n-\t     means, it is unreachable.  That case has been disallowed in the\n-\t     building of the DFS tree, so we are save here.  For the reverse\n-\t     flow graph it means, it has no children, so, to be compatible\n-\t     with the old code, we set the post_dominators to all one.  */\n-\t  if (!di->dom[i])\n-\t    {\n-\t      sbitmap_ones (dominators[bb]);\n-\t    }\n-\t}\n-      SET_BIT (dominators[bb], bb);\n-    }\n-}\n-\n /* The main entry point into this module.  IDOM is an integer array with room\n    for last_basic_block integers, DOMS is a preallocated sbitmap array having\n    room for last_basic_block^2 bits, and POST is true if the caller wants to\n@@ -587,37 +554,259 @@ idoms_to_doms (di, dominators)\n    Either IDOM or DOMS may be NULL (meaning the caller is not interested in\n    immediate resp. all dominators).  */\n \n-void\n-calculate_dominance_info (idom, doms, reverse)\n-     int *idom;\n-     sbitmap *doms;\n+dominance_info\n+calculate_dominance_info (reverse)\n      enum cdi_direction reverse;\n {\n   struct dom_info di;\n+  dominance_info info;\n+  basic_block b;\n+\n+  /* allocate structure for dominance information.  */\n+  info = xmalloc (sizeof (struct dominance_info));\n+  info->forest = et_forest_create ();\n+  VARRAY_GENERIC_PTR_INIT (info->varray, last_basic_block + 3, \"dominance info\");\n+\n+  /* Add the two well-known basic blocks.  */\n+  SET_BB_NODE (info, ENTRY_BLOCK_PTR, et_forest_add_node (info->forest,\n+\t\t\t\t\t\t\t  ENTRY_BLOCK_PTR));\n+  SET_BB_NODE (info, EXIT_BLOCK_PTR, et_forest_add_node (info->forest,\n+\t\t\t\t\t\t\t EXIT_BLOCK_PTR));\n+  FOR_EACH_BB (b)\n+    SET_BB_NODE (info, b, et_forest_add_node (info->forest, b));\n \n-  if (!doms && !idom)\n-    return;\n   init_dom_info (&di);\n   calc_dfs_tree (&di, reverse);\n   calc_idoms (&di, reverse);\n \n-  if (idom)\n+\n+  FOR_EACH_BB (b)\n     {\n-      basic_block b;\n+      TBB d = di.dom[di.dfs_order[b->index]];\n \n-      FOR_EACH_BB (b)\n+      if (di.dfs_to_bb[d])\n+        et_forest_add_edge (info->forest, BB_NODE (info, di.dfs_to_bb[d]), BB_NODE (info, b));\n+    }\n+\n+  free_dom_info (&di);\n+  return info;\n+}\n+\n+/* Free dominance information.  */\n+void\n+free_dominance_info (info)\n+     dominance_info info;\n+{\n+  basic_block bb;\n+\n+  /* Allow users to create new basic block without setting up the dominance\n+     information for them.  */\n+  FOR_EACH_BB (bb)\n+    if (bb->index < (int)(info->varray->num_elements - 2)\n+\t&& BB_NODE (info, bb))\n+      delete_from_dominance_info (info, bb);\n+  delete_from_dominance_info (info, ENTRY_BLOCK_PTR);\n+  delete_from_dominance_info (info, EXIT_BLOCK_PTR);\n+  et_forest_delete (info->forest);\n+  VARRAY_GROW (info->varray, 0);\n+  free (info);\n+}\n+\n+/* Return the immediate dominator of basic block BB.  */\n+basic_block\n+get_immediate_dominator (dom, bb)\n+     dominance_info dom;\n+     basic_block bb;\n+{\n+  return et_forest_node_value (dom->forest,\n+\t\t\t       et_forest_parent (dom->forest,\n+\t\t\t\t\t\t BB_NODE (dom, bb)));\n+}\n+\n+/* Set the immediate dominator of the block possibly removing\n+   existing edge.  NULL can be used to remove any edge.  */\n+inline void\n+set_immediate_dominator (dom, bb, dominated_by)\n+     dominance_info dom;\n+     basic_block bb, dominated_by;\n+{\n+  void *aux_bb_node;\n+  et_forest_node_t bb_node = BB_NODE (dom, bb);\n+\n+  aux_bb_node = et_forest_parent (dom->forest, bb_node);\n+  if (aux_bb_node)\n+    et_forest_remove_edge (dom->forest, aux_bb_node, bb_node);\n+  if (dominated_by != NULL)\n+    {\n+      if (bb == dominated_by)\n+\tabort ();\n+      if (!et_forest_add_edge (dom->forest, BB_NODE (dom, dominated_by), bb_node))\n+\tabort ();\n+    }\n+}\n+\n+/* Store all basic blocks dominated by BB into BBS and return their number.  */\n+int\n+get_dominated_by (dom, bb, bbs)\n+     dominance_info dom;\n+     basic_block bb;\n+     basic_block **bbs;\n+{\n+  int n, i;\n+\n+  *bbs = xmalloc (n_basic_blocks * sizeof (basic_block));\n+  n = et_forest_enumerate_sons (dom->forest, BB_NODE (dom, bb), (et_forest_node_t *)*bbs);\n+  for (i = 0; i < n; i++)\n+   (*bbs)[i] = et_forest_node_value (dom->forest, (et_forest_node_t)(*bbs)[i]);\n+  return n;\n+}\n+\n+/* Redirect all edges pointing to BB to TO.  */\n+void\n+redirect_immediate_dominators (dom, bb, to)\n+     dominance_info dom;\n+     basic_block bb;\n+     basic_block to;\n+{\n+  et_forest_node_t *bbs = xmalloc (n_basic_blocks * sizeof (basic_block));\n+  et_forest_node_t node = BB_NODE (dom, bb);\n+  et_forest_node_t node2 = BB_NODE (dom, to);\n+  int n = et_forest_enumerate_sons (dom->forest, node, bbs);\n+  int i;\n+\n+  for (i = 0; i < n; i++)\n+    {\n+      et_forest_remove_edge (dom->forest, node, bbs[i]);\n+      et_forest_add_edge (dom->forest, node2, bbs[i]);\n+    }\n+  free (bbs);\n+}\n+\n+/* Find first basic block in the tree dominating both BB1 and BB2.  */\n+basic_block\n+nearest_common_dominator (dom, bb1, bb2)\n+     dominance_info dom;\n+     basic_block bb1;\n+     basic_block bb2;\n+{\n+  if (!bb1)\n+    return bb2;\n+  if (!bb2)\n+    return bb1;\n+  return et_forest_node_value (dom->forest,\n+\t\t\t       et_forest_common_ancestor (dom->forest,\n+\t\t\t\t\t\t\t  BB_NODE (dom, bb1),\n+\t\t\t\t\t\t\t  BB_NODE (dom,\n+\t\t\t\t\t\t\t\t   bb2)));\n+}\n+\n+/* Return TRUE in case BB1 is dominated by BB2.  */\n+bool\n+dominated_by_p (dom, bb1, bb2)\n+     dominance_info dom;\n+     basic_block bb1;\n+     basic_block bb2;\n+{\n+  return nearest_common_dominator (dom, bb1, bb2) == bb2;\n+}\n+\n+/* Verify invariants of dominator structure.  */\n+void\n+verify_dominators (dom)\n+     dominance_info dom;\n+{\n+  int err = 0;\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      basic_block dom_bb;\n+\n+      dom_bb = recount_dominator (dom, bb);\n+      if (dom_bb != get_immediate_dominator (dom, bb))\n \t{\n-\t  TBB d = di.dom[di.dfs_order[b->index]];\n+\t  error (\"dominator of %d should be %d, not %d\",\n+\t   bb->index, dom_bb->index, get_immediate_dominator(dom, bb)->index);\n+\t  err = 1;\n+\t}\n+    }\n+  if (err)\n+    abort ();\n+}\n+\n+/* Recount dominator of BB.  */\n+basic_block\n+recount_dominator (dom, bb)\n+     dominance_info dom;\n+     basic_block bb;\n+{\n+   basic_block dom_bb = NULL;\n+   edge e;\n+\n+   for (e = bb->pred; e; e = e->pred_next)\n+     {\n+       if (!dominated_by_p (dom, e->src, bb))\n+         dom_bb = nearest_common_dominator (dom, dom_bb, e->src);\n+     }\n \n-\t  /* The old code didn't modify array elements of nodes having only\n-\t     itself as dominator (d==0) or only ENTRY_BLOCK (resp. EXIT_BLOCK)\n-\t     (d==1).  */\n-\t  if (d > 1)\n-\t    idom[b->index] = di.dfs_to_bb[d]->index;\n+   return dom_bb;\n+}\n+\n+/* Iteratively recount dominators of BBS. The change is supposed to be local\n+   and not to grow further.  */\n+void\n+iterate_fix_dominators (dom, bbs, n)\n+     dominance_info dom;\n+     basic_block *bbs;\n+     int n;\n+{\n+  int i, changed = 1;\n+  basic_block old_dom, new_dom;\n+\n+  while (changed)\n+    {\n+      changed = 0;\n+      for (i = 0; i < n; i++)\n+\t{\n+\t  old_dom = get_immediate_dominator (dom, bbs[i]);\n+\t  new_dom = recount_dominator (dom, bbs[i]);\n+\t  if (old_dom != new_dom)\n+\t    {\n+\t      changed = 1;\n+\t      set_immediate_dominator (dom, bbs[i], new_dom);\n+\t    }\n \t}\n     }\n-  if (doms)\n-    idoms_to_doms (&di, doms);\n+}\n \n-  free_dom_info (&di);\n+void\n+add_to_dominance_info (dom, bb)\n+     dominance_info dom;\n+     basic_block bb;\n+{\n+  VARRAY_GROW (dom->varray, last_basic_block + 3);\n+#ifdef ENABLE_CHECKING\n+  if (BB_NODE (dom, bb))\n+    abort ();\n+#endif\n+  SET_BB_NODE (dom, bb, et_forest_add_node (dom->forest, bb));\n+}\n+\n+void\n+delete_from_dominance_info (dom, bb)\n+     dominance_info dom;\n+     basic_block bb;\n+{\n+  et_forest_remove_node (dom->forest, BB_NODE (dom, bb));\n+  SET_BB_NODE (dom, bb, NULL);\n+}\n+\n+void\n+debug_dominance_info (dom)\n+  dominance_info dom;\n+{\n+  basic_block bb, bb2;\n+  FOR_EACH_BB (bb)\n+    if ((bb2 = get_immediate_dominator (dom, bb)))\n+      fprintf (stderr, \"%i %i\\n\", bb->index, bb2->index);\n }"}, {"sha": "e73200840a29d8cd15f92026a0c4b0e46efb1dc9", "filename": "gcc/gcse.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=355be0dc5824199cd14e8ee57983332ae2b26226", "patch": "@@ -5752,7 +5752,7 @@ static sbitmap *hoist_vbeout;\n static sbitmap *hoist_exprs;\n \n /* Dominator bitmaps.  */\n-static sbitmap *dominators;\n+dominance_info dominators;\n \n /* ??? We could compute post dominators and run this algorithm in\n    reverse to to perform tail merging, doing so would probably be\n@@ -5775,8 +5775,6 @@ alloc_code_hoist_mem (n_blocks, n_exprs)\n   hoist_vbeout = sbitmap_vector_alloc (n_blocks, n_exprs);\n   hoist_exprs = sbitmap_vector_alloc (n_blocks, n_exprs);\n   transpout = sbitmap_vector_alloc (n_blocks, n_exprs);\n-\n-  dominators = sbitmap_vector_alloc (n_blocks, n_blocks);\n }\n \n /* Free vars used for code hoisting analysis.  */\n@@ -5793,7 +5791,7 @@ free_code_hoist_mem ()\n   sbitmap_vector_free (hoist_exprs);\n   sbitmap_vector_free (transpout);\n \n-  sbitmap_vector_free (dominators);\n+  free_dominance_info (dominators);\n }\n \n /* Compute the very busy expressions at entry/exit from each block.\n@@ -5842,7 +5840,7 @@ compute_code_hoist_data ()\n   compute_local_properties (transp, comp, antloc, 0);\n   compute_transpout ();\n   compute_code_hoist_vbeinout ();\n-  calculate_dominance_info (NULL, dominators, CDI_DOMINATORS);\n+  dominators = calculate_dominance_info (CDI_DOMINATORS);\n   if (gcse_file)\n     fprintf (gcse_file, \"\\n\");\n }\n@@ -5949,7 +5947,7 @@ hoist_code ()\n \t\t{\n \t\t  /* Ignore self dominance.  */\n \t\t  if (bb == dominated\n-\t\t      || ! TEST_BIT (dominators[dominated->index], bb->index))\n+\t\t      || dominated_by_p (dominators, dominated, bb))\n \t\t    continue;\n \n \t\t  /* We've found a dominated block, now see if it computes\n@@ -6006,7 +6004,7 @@ hoist_code ()\n \t\t{\n \t\t  /* Ignore self dominance.  */\n \t\t  if (bb == dominated\n-\t\t      || ! TEST_BIT (dominators[dominated->index], bb->index))\n+\t\t      || ! dominated_by_p (dominators, dominated, bb))\n \t\t    continue;\n \n \t\t  /* We've found a dominated block, now see if it computes"}, {"sha": "6bc522d0fe6262943137a986220b7db146486ffd", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=355be0dc5824199cd14e8ee57983332ae2b26226", "patch": "@@ -77,7 +77,7 @@ static int num_removed_blocks;\n static bool life_data_ok;\n \n /* The post-dominator relation on the original block numbers.  */\n-static sbitmap *post_dominators;\n+static dominance_info post_dominators;\n \n /* Forward references.  */\n static int count_bb_insns\t\tPARAMS ((basic_block));\n@@ -1814,6 +1814,8 @@ merge_if_block (test_bb, then_bb, else_bb, join_bb)\n       if (combo_bb->global_live_at_end)\n \tCOPY_REG_SET (combo_bb->global_live_at_end,\n \t\t      then_bb->global_live_at_end);\n+      if (post_dominators)\n+\tdelete_from_dominance_info (post_dominators, then_bb);\n       merge_blocks_nomove (combo_bb, then_bb);\n       num_removed_blocks++;\n     }\n@@ -1823,6 +1825,8 @@ merge_if_block (test_bb, then_bb, else_bb, join_bb)\n      get their addresses taken.  */\n   if (else_bb)\n     {\n+      if (post_dominators)\n+\tdelete_from_dominance_info (post_dominators, else_bb);\n       merge_blocks_nomove (combo_bb, else_bb);\n       num_removed_blocks++;\n     }\n@@ -1877,6 +1881,8 @@ merge_if_block (test_bb, then_bb, else_bb, join_bb)\n       if (combo_bb->global_live_at_end)\n \tCOPY_REG_SET (combo_bb->global_live_at_end,\n \t\t      join_bb->global_live_at_end);\n+      if (post_dominators)\n+\tdelete_from_dominance_info (post_dominators, join_bb);\n       merge_blocks_nomove (combo_bb, join_bb);\n       num_removed_blocks++;\n     }\n@@ -2135,6 +2141,8 @@ find_cond_trap (test_bb, then_edge, else_edge)\n   remove_edge (trap_bb == then_bb ? then_edge : else_edge);\n   if (trap_bb->pred == NULL)\n     {\n+      if (post_dominators)\n+\tdelete_from_dominance_info (post_dominators, trap_bb);\n       flow_delete_block (trap_bb);\n       num_removed_blocks++;\n     }\n@@ -2316,6 +2324,8 @@ find_if_case_1 (test_bb, then_edge, else_edge)\n   \n   new_bb = redirect_edge_and_branch_force (FALLTHRU_EDGE (test_bb), else_bb);\n   then_bb_index = then_bb->index;\n+  if (post_dominators)\n+    delete_from_dominance_info (post_dominators, then_bb);\n   flow_delete_block (then_bb);\n   /* Make rest of code believe that the newly created block is the THEN_BB\n      block we removed.  */\n@@ -2366,8 +2376,8 @@ find_if_case_2 (test_bb, then_edge, else_edge)\n   if (note && INTVAL (XEXP (note, 0)) >= REG_BR_PROB_BASE / 2)\n     ;\n   else if (else_succ->dest->index < 0\n-\t   || TEST_BIT (post_dominators[then_bb->index], \n-\t\t\telse_succ->dest->index))\n+\t   || dominated_by_p (post_dominators, then_bb, \n+\t\t\t      else_succ->dest))\n     ;\n   else\n     return FALSE;\n@@ -2393,6 +2403,8 @@ find_if_case_2 (test_bb, then_edge, else_edge)\n \t\t    then_bb->global_live_at_start,\n \t\t    else_bb->global_live_at_end, BITMAP_IOR);\n   \n+  if (post_dominators)\n+    delete_from_dominance_info (post_dominators, else_bb);\n   flow_delete_block (else_bb);\n \n   num_removed_blocks++;\n@@ -2700,8 +2712,7 @@ if_convert (x_life_data_ok)\n   post_dominators = NULL;\n   if (HAVE_conditional_execution || life_data_ok)\n     {\n-      post_dominators = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n-      calculate_dominance_info (NULL, post_dominators, CDI_POST_DOMINATORS);\n+      post_dominators = calculate_dominance_info (CDI_POST_DOMINATORS);\n     }\n   if (life_data_ok)\n     clear_bb_flags ();\n@@ -2712,7 +2723,7 @@ if_convert (x_life_data_ok)\n       continue;\n \n   if (post_dominators)\n-    sbitmap_vector_free (post_dominators);\n+    free_dominance_info (post_dominators);\n \n   if (rtl_dump_file)\n     fflush (rtl_dump_file);"}, {"sha": "71950ee6766f1b119b2d67f76618c0efce35e537", "filename": "gcc/predict.c", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=355be0dc5824199cd14e8ee57983332ae2b26226", "patch": "@@ -49,6 +49,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"real.h\"\n #include \"params.h\"\n #include \"target.h\"\n+#include \"loop.h\"\n \n /* real constants: 0, 1, 1-1/REG_BR_PROB_BASE, REG_BR_PROB_BASE, 0.5,\n                    REAL_BB_FREQ_MAX.  */\n@@ -73,10 +74,12 @@ static void estimate_loops_at_level\t PARAMS ((struct loop *loop));\n static void propagate_freq\t\t PARAMS ((struct loop *));\n static void estimate_bb_frequencies\t PARAMS ((struct loops *));\n static void counts_to_freqs\t\t PARAMS ((void));\n-static void process_note_predictions\t PARAMS ((basic_block, int *, int *,\n-\t\t\t\t\t\t  sbitmap *));\n-static void process_note_prediction\t PARAMS ((basic_block, int *, int *,\n-\t\t\t\t\t\t  sbitmap *, int, int));\n+static void process_note_predictions\t PARAMS ((basic_block, int *,\n+\t\t\t\t\t\t  dominance_info,\n+\t\t\t\t\t\t  dominance_info));\n+static void process_note_prediction\t PARAMS ((basic_block, int *, \n+\t\t\t\t\t\t  dominance_info,\n+\t\t\t\t\t\t  dominance_info, int, int));\n static bool last_basic_block_p           PARAMS ((basic_block));\n static void compute_function_frequency\t PARAMS ((void));\n static void choose_function_section\t PARAMS ((void));\n@@ -408,14 +411,13 @@ void\n estimate_probability (loops_info)\n      struct loops *loops_info;\n {\n-  sbitmap *dominators, *post_dominators;\n+  dominance_info dominators, post_dominators;\n   basic_block bb;\n   int i;\n \n-  dominators = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n-  post_dominators = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n-  calculate_dominance_info (NULL, dominators, CDI_DOMINATORS);\n-  calculate_dominance_info (NULL, post_dominators, CDI_POST_DOMINATORS);\n+  connect_infinite_loops_to_exit ();\n+  dominators = calculate_dominance_info (CDI_DOMINATORS);\n+  post_dominators = calculate_dominance_info (CDI_POST_DOMINATORS);\n \n   /* Try to predict out blocks in a loop that are not part of a\n      natural loop.  */\n@@ -495,8 +497,8 @@ estimate_probability (loops_info)\n \t  /* Look for block we are guarding (ie we dominate it,\n \t     but it doesn't postdominate us).  */\n \t  if (e->dest != EXIT_BLOCK_PTR && e->dest != bb\n-\t      && TEST_BIT (dominators[e->dest->index], e->src->index)\n-\t      && !TEST_BIT (post_dominators[e->src->index], e->dest->index))\n+\t      && dominated_by_p (dominators, e->dest, e->src)\n+\t      && !dominated_by_p (post_dominators, e->src, e->dest))\n \t    {\n \t      rtx insn;\n \n@@ -613,9 +615,10 @@ estimate_probability (loops_info)\n \t&& bb->succ->succ_next != NULL)\n       combine_predictions_for_insn (bb->end, bb);\n \n-  sbitmap_vector_free (post_dominators);\n-  sbitmap_vector_free (dominators);\n+  free_dominance_info (post_dominators);\n+  free_dominance_info (dominators);\n \n+  remove_fake_edges ();\n   estimate_bb_frequencies (loops_info);\n }\n \f\n@@ -717,8 +720,8 @@ static void\n process_note_prediction (bb, heads, dominators, post_dominators, pred, flags)\n      basic_block bb;\n      int *heads;\n-     int *dominators;\n-     sbitmap *post_dominators;\n+     dominance_info dominators;\n+     dominance_info post_dominators;\n      int pred;\n      int flags;\n {\n@@ -733,27 +736,30 @@ process_note_prediction (bb, heads, dominators, post_dominators, pred, flags)\n       /* This is first time we need this field in heads array; so\n          find first dominator that we do not post-dominate (we are\n          using already known members of heads array).  */\n-      int ai = bb->index;\n-      int next_ai = dominators[bb->index];\n+      basic_block ai = bb;\n+      basic_block next_ai = get_immediate_dominator (dominators, bb);\n       int head;\n \n-      while (heads[next_ai] < 0)\n+      while (heads[next_ai->index] < 0)\n \t{\n-\t  if (!TEST_BIT (post_dominators[next_ai], bb->index))\n+\t  if (!dominated_by_p (post_dominators, next_ai, bb))\n \t    break;\n-\t  heads[next_ai] = ai;\n+\t  heads[next_ai->index] = ai->index;\n \t  ai = next_ai;\n-\t  next_ai = dominators[next_ai];\n+\t  next_ai = get_immediate_dominator (dominators, next_ai);\n \t}\n-      if (!TEST_BIT (post_dominators[next_ai], bb->index))\n-\thead = next_ai;\n+      if (!dominated_by_p (post_dominators, next_ai, bb))\n+\thead = next_ai->index;\n       else\n-\thead = heads[next_ai];\n-      while (next_ai != bb->index)\n+\thead = heads[next_ai->index];\n+      while (next_ai != bb)\n \t{\n \t  next_ai = ai;\n-\t  ai = heads[ai];\n-\t  heads[next_ai] = head;\n+\t  if (heads[ai->index] == ENTRY_BLOCK)\n+\t    ai = ENTRY_BLOCK_PTR;\n+\t  else\n+\t    ai = BASIC_BLOCK (heads[ai->index]);\n+\t  heads[next_ai->index] = head;\n \t}\n     }\n   y = heads[bb->index];\n@@ -764,7 +770,7 @@ process_note_prediction (bb, heads, dominators, post_dominators, pred, flags)\n     return;\n   for (e = BASIC_BLOCK (y)->succ; e; e = e->succ_next)\n     if (e->dest->index >= 0\n-\t&& TEST_BIT (post_dominators[e->dest->index], bb->index))\n+\t&& dominated_by_p (post_dominators, e->dest, bb))\n       predict_edge_def (e, pred, taken);\n }\n \n@@ -776,8 +782,8 @@ static void\n process_note_predictions (bb, heads, dominators, post_dominators)\n      basic_block bb;\n      int *heads;\n-     int *dominators;\n-     sbitmap *post_dominators;\n+     dominance_info dominators;\n+     dominance_info post_dominators;\n {\n   rtx insn;\n   edge e;\n@@ -838,18 +844,15 @@ void\n note_prediction_to_br_prob ()\n {\n   basic_block bb;\n-  sbitmap *post_dominators;\n-  int *dominators, *heads;\n+  dominance_info post_dominators, dominators;\n+  int *heads;\n \n   /* To enable handling of noreturn blocks.  */\n   add_noreturn_fake_exit_edges ();\n   connect_infinite_loops_to_exit ();\n \n-  dominators = xmalloc (sizeof (int) * last_basic_block);\n-  memset (dominators, -1, sizeof (int) * last_basic_block);\n-  post_dominators = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n-  calculate_dominance_info (NULL, post_dominators, CDI_POST_DOMINATORS);\n-  calculate_dominance_info (dominators, NULL, CDI_DOMINATORS);\n+  post_dominators = calculate_dominance_info (CDI_POST_DOMINATORS);\n+  dominators = calculate_dominance_info (CDI_DOMINATORS);\n \n   heads = xmalloc (sizeof (int) * last_basic_block);\n   memset (heads, -1, sizeof (int) * last_basic_block);\n@@ -860,8 +863,8 @@ note_prediction_to_br_prob ()\n   FOR_EACH_BB (bb)\n     process_note_predictions (bb, heads, dominators, post_dominators);\n \n-  sbitmap_vector_free (post_dominators);\n-  free (dominators);\n+  free_dominance_info (post_dominators);\n+  free_dominance_info (dominators);\n   free (heads);\n \n   remove_fake_edges ();"}, {"sha": "4a9989758c89b7a3ec7e25fa0b4f99430c2b363c", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=355be0dc5824199cd14e8ee57983332ae2b26226", "patch": "@@ -153,7 +153,7 @@ static int *containing_rgn;\n \n void debug_regions PARAMS ((void));\n static void find_single_block_region PARAMS ((void));\n-static void find_rgns PARAMS ((struct edge_list *, sbitmap *));\n+static void find_rgns PARAMS ((struct edge_list *, dominance_info));\n static int too_large PARAMS ((int, int *, int *));\n \n extern void debug_live PARAMS ((int, int));\n@@ -624,7 +624,7 @@ too_large (block, num_bbs, num_insns)\n static void\n find_rgns (edge_list, dom)\n      struct edge_list *edge_list;\n-     sbitmap *dom;\n+     dominance_info dom;\n {\n   int *max_hdr, *dfs_nr, *stack, *degree;\n   char no_loops = 1;\n@@ -837,7 +837,7 @@ find_rgns (edge_list, dom)\n \t\t    {\n \t\t      /* Now verify that the block is dominated by the loop\n \t\t\t header.  */\n-\t\t      if (!TEST_BIT (dom[jbb->index], bb->index))\n+\t\t      if (!dominated_by_p (dom, jbb, bb))\n \t\t\tbreak;\n \t\t    }\n \t\t}\n@@ -2909,11 +2909,9 @@ init_regions ()\n \t}\n       else\n \t{\n-\t  sbitmap *dom;\n+\t  dominance_info dom;\n \t  struct edge_list *edge_list;\n \n-\t  dom = sbitmap_vector_alloc (last_basic_block, last_basic_block);\n-\n \t  /* The scheduler runs after flow; therefore, we can't blindly call\n \t     back into find_basic_blocks since doing so could invalidate the\n \t     info in global_live_at_start.\n@@ -2928,7 +2926,7 @@ init_regions ()\n \t  edge_list = create_edge_list ();\n \n \t  /* Compute the dominators and post dominators.  */\n-\t  calculate_dominance_info (NULL, dom, CDI_DOMINATORS);\n+\t  dom = calculate_dominance_info (CDI_DOMINATORS);\n \n \t  /* build_control_flow will return nonzero if it detects unreachable\n \t     blocks or any other irregularity with the cfg which prevents\n@@ -2946,7 +2944,7 @@ init_regions ()\n \n \t  /* For now.  This will move as more and more of haifa is converted\n \t     to using the cfg code in flow.c.  */\n-\t  free (dom);\n+\t  free_dominance_info (dom);\n \t}\n     }\n "}, {"sha": "09fcc7ad65a3d2bc7e25b182f003789977f23f62", "filename": "gcc/ssa-dce.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-dce.c?ref=355be0dc5824199cd14e8ee57983332ae2b26226", "patch": "@@ -98,13 +98,13 @@ static void set_control_dependent_block_to_edge_map_bit\n static void control_dependent_block_to_edge_map_free\n   PARAMS ((control_dependent_block_to_edge_map c));\n static void find_all_control_dependences\n-  PARAMS ((struct edge_list *el, int *pdom,\n+  PARAMS ((struct edge_list *el, dominance_info pdom,\n \t   control_dependent_block_to_edge_map cdbte));\n static void find_control_dependence\n-  PARAMS ((struct edge_list *el, int edge_index, int *pdom,\n+  PARAMS ((struct edge_list *el, int edge_index, dominance_info pdom,\n \t   control_dependent_block_to_edge_map cdbte));\n static basic_block find_pdom\n-  PARAMS ((int *pdom, basic_block block));\n+  PARAMS ((dominance_info pdom, basic_block block));\n static int inherently_necessary_register_1\n   PARAMS ((rtx *current_rtx, void *data));\n static int inherently_necessary_register\n@@ -218,7 +218,7 @@ control_dependent_block_to_edge_map_free (c)\n static void\n find_all_control_dependences (el, pdom, cdbte)\n    struct edge_list *el;\n-   int *pdom;\n+   dominance_info pdom;\n    control_dependent_block_to_edge_map cdbte;\n {\n   int i;\n@@ -237,7 +237,7 @@ static void\n find_control_dependence (el, edge_index, pdom, cdbte)\n    struct edge_list *el;\n    int edge_index;\n-   int *pdom;\n+   dominance_info pdom;\n    control_dependent_block_to_edge_map cdbte;\n {\n   basic_block current_block;\n@@ -266,7 +266,7 @@ find_control_dependence (el, edge_index, pdom, cdbte)\n \n static basic_block\n find_pdom (pdom, block)\n-     int *pdom;\n+     dominance_info pdom;\n      basic_block block;\n {\n   if (!block)\n@@ -276,10 +276,15 @@ find_pdom (pdom, block)\n \n   if (block == ENTRY_BLOCK_PTR)\n     return ENTRY_BLOCK_PTR->next_bb;\n-  else if (block == EXIT_BLOCK_PTR || pdom[block->index] == EXIT_BLOCK)\n+  else if (block == EXIT_BLOCK_PTR)\n     return EXIT_BLOCK_PTR;\n   else\n-    return BASIC_BLOCK (pdom[block->index]);\n+    {\n+      basic_block bb = get_immediate_dominator (pdom, block);\n+      if (!bb)\n+\treturn EXIT_BLOCK_PTR;\n+      return bb;\n+    }\n }\n \n /* Determine if the given CURRENT_RTX uses a hard register not\n@@ -488,7 +493,6 @@ delete_insn_bb (insn)\n void\n ssa_eliminate_dead_code ()\n {\n-  int i;\n   rtx insn;\n   basic_block bb;\n   /* Necessary instructions with operands to explore.  */\n@@ -497,7 +501,7 @@ ssa_eliminate_dead_code ()\n      edge.  \"cdbte\" abbreviates control dependent block to edge.  */\n   control_dependent_block_to_edge_map cdbte;\n  /* Element I is the immediate postdominator of block I.  */\n-  int *pdom;\n+  dominance_info pdom;\n   struct edge_list *el;\n \n   /* Initialize the data structures.  */\n@@ -510,14 +514,7 @@ ssa_eliminate_dead_code ()\n   connect_infinite_loops_to_exit ();\n \n   /* Compute control dependence.  */\n-  pdom = (int *) xmalloc (last_basic_block * sizeof (int));\n-  for (i = 0; i < last_basic_block; ++i)\n-    pdom[i] = INVALID_BLOCK;\n-  calculate_dominance_info (pdom, NULL, CDI_POST_DOMINATORS);\n-  /* Assume there is a path from each node to the exit block.  */\n-  for (i = 0; i < last_basic_block; ++i)\n-    if (pdom[i] == INVALID_BLOCK)\n-      pdom[i] = EXIT_BLOCK;\n+  pdom = calculate_dominance_info (CDI_POST_DOMINATORS);\n   el = create_edge_list ();\n   find_all_control_dependences (el, pdom, cdbte);\n "}, {"sha": "71be1a9d9577ede99c0a3c89bca55b5914819e55", "filename": "gcc/ssa.c", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=355be0dc5824199cd14e8ee57983332ae2b26226", "patch": "@@ -165,7 +165,7 @@ struct rename_context;\n static inline rtx * phi_alternative\n   PARAMS ((rtx, int));\n static void compute_dominance_frontiers_1\n-  PARAMS ((sbitmap *frontiers, int *idom, int bb, sbitmap done));\n+  PARAMS ((sbitmap *frontiers, dominance_info idom, int bb, sbitmap done));\n static void find_evaluations_1\n   PARAMS ((rtx dest, rtx set, void *data));\n static void find_evaluations\n@@ -183,9 +183,9 @@ static void apply_delayed_renames\n static int rename_insn_1\n   PARAMS ((rtx *ptr, void *data));\n static void rename_block\n-  PARAMS ((int b, int *idom));\n+  PARAMS ((int b, dominance_info dom));\n static void rename_registers\n-  PARAMS ((int nregs, int *idom));\n+  PARAMS ((int nregs, dominance_info idom));\n \n static inline int ephi_add_node\n   PARAMS ((rtx reg, rtx *nodes, int *n_nodes));\n@@ -516,7 +516,7 @@ find_evaluations (evals, nregs)\n static void\n compute_dominance_frontiers_1 (frontiers, idom, bb, done)\n      sbitmap *frontiers;\n-     int *idom;\n+     dominance_info idom;\n      int bb;\n      sbitmap done;\n {\n@@ -531,26 +531,27 @@ compute_dominance_frontiers_1 (frontiers, idom, bb, done)\n      dominator tree (blocks dominated by this one) are children in the\n      CFG, so check all blocks.  */\n   FOR_EACH_BB (c)\n-    if (idom[c->index] == bb && ! TEST_BIT (done, c->index))\n+    if (get_immediate_dominator (idom, c)->index == bb\n+\t&& ! TEST_BIT (done, c->index))\n       compute_dominance_frontiers_1 (frontiers, idom, c->index, done);\n \n   /* Find blocks conforming to rule (1) above.  */\n   for (e = b->succ; e; e = e->succ_next)\n     {\n       if (e->dest == EXIT_BLOCK_PTR)\n \tcontinue;\n-      if (idom[e->dest->index] != bb)\n+      if (get_immediate_dominator (idom, e->dest)->index != bb)\n \tSET_BIT (frontiers[bb], e->dest->index);\n     }\n \n   /* Find blocks conforming to rule (2).  */\n   FOR_EACH_BB (c)\n-    if (idom[c->index] == bb)\n+    if (get_immediate_dominator (idom, c)->index == bb)\n       {\n \tint x;\n \tEXECUTE_IF_SET_IN_SBITMAP (frontiers[c->index], 0, x,\n \t  {\n-\t    if (idom[x] != bb)\n+\t    if (get_immediate_dominator (idom, BASIC_BLOCK (x))->index != bb)\n \t      SET_BIT (frontiers[bb], x);\n \t  });\n       }\n@@ -559,7 +560,7 @@ compute_dominance_frontiers_1 (frontiers, idom, bb, done)\n void\n compute_dominance_frontiers (frontiers, idom)\n      sbitmap *frontiers;\n-     int *idom;\n+     dominance_info idom;\n {\n   sbitmap done = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (done);\n@@ -1001,7 +1002,7 @@ gen_sequence ()\n static void\n rename_block (bb, idom)\n      int bb;\n-     int *idom;\n+     dominance_info idom;\n {\n   basic_block b = BASIC_BLOCK (bb);\n   edge e;\n@@ -1111,7 +1112,7 @@ rename_block (bb, idom)\n      dominator order.  */\n \n   FOR_EACH_BB (c)\n-    if (idom[c->index] == bb)\n+    if (get_immediate_dominator (idom, c)->index == bb)\n       rename_block (c->index, idom);\n \n   /* Step Four: Update the sets to refer to their new register,\n@@ -1137,7 +1138,7 @@ rename_block (bb, idom)\n static void\n rename_registers (nregs, idom)\n      int nregs;\n-     int *idom;\n+     dominance_info idom;\n {\n   VARRAY_RTX_INIT (ssa_definition, nregs * 3, \"ssa_definition\");\n   ssa_rename_from_initialize ();\n@@ -1168,7 +1169,7 @@ convert_to_ssa ()\n   sbitmap *idfs;\n \n   /* Element I is the immediate dominator of block I.  */\n-  int *idom;\n+  dominance_info idom;\n \n   int nregs;\n \n@@ -1182,15 +1183,14 @@ convert_to_ssa ()\n      dead code.  We'll let the SSA optimizers do that.  */\n   life_analysis (get_insns (), NULL, 0);\n \n-  idom = (int *) alloca (last_basic_block * sizeof (int));\n-  memset ((void *) idom, -1, (size_t) last_basic_block * sizeof (int));\n-  calculate_dominance_info (idom, NULL, CDI_DOMINATORS);\n+  idom = calculate_dominance_info (CDI_DOMINATORS);\n \n   if (rtl_dump_file)\n     {\n       fputs (\";; Immediate Dominators:\\n\", rtl_dump_file);\n       FOR_EACH_BB (bb)\n-\tfprintf (rtl_dump_file, \";\\t%3d = %3d\\n\", bb->index, idom[bb->index]);\n+\tfprintf (rtl_dump_file, \";\\t%3d = %3d\\n\", bb->index,\n+\t\t get_immediate_dominator (idom, bb)->index);\n       fflush (rtl_dump_file);\n     }\n \n@@ -1241,6 +1241,7 @@ convert_to_ssa ()\n   in_ssa_form = 1;\n \n   reg_scan (get_insns (), max_reg_num (), 1);\n+  free_dominance_info (idom);\n }\n \n /* REG is the representative temporary of its partition.  Add it to the"}, {"sha": "115f77d74d8ff4ab7a8fe01b130b22e10afc70a6", "filename": "gcc/ssa.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355be0dc5824199cd14e8ee57983332ae2b26226/gcc%2Fssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.h?ref=355be0dc5824199cd14e8ee57983332ae2b26226", "patch": "@@ -27,7 +27,8 @@ typedef int (*successor_phi_fn)         PARAMS ((rtx, int, int, void *));\n extern int for_each_successor_phi       PARAMS ((basic_block bb,\n \t\t\t\t\t\t successor_phi_fn,\n \t\t\t\t\t\t void *));\n-void compute_dominance_frontiers\tPARAMS ((sbitmap *frontiers, int *idom));\n+void compute_dominance_frontiers\tPARAMS ((sbitmap *frontiers,\n+\t\t\t\t\t\t dominance_info idom));\n extern int remove_phi_alternative\tPARAMS ((rtx, basic_block));\n \n "}]}