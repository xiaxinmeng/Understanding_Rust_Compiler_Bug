{"sha": "57a8057af4d9cafef111626b162b9ce2b096d63f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdhODA1N2FmNGQ5Y2FmZWYxMTE2MjZiMTYyYjljZTJiMDk2ZDYzZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T13:54:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T13:54:30Z"}, "message": "[multiple changes]\n\n2011-08-29  Yannick Moy  <moy@adacore.com>\n\n\t* gnat1drv.adb (Adjust_Global_Switches): Restore expansion of tagged\n\ttypes and dispatching calls in Alfa mode.\n\t* lib-xref-alfa.adb (Collect_ALFA): Rewrite computation of\n\tcorrespondance between body and spec scopes, to reuse utility functions\n\t(Traverse_Declarations_Or_Statements): Protect access to body for stub\n\tby testing the presence of the library unit for the body\n\t* sem_ch6.adb (Set_Actual_Subtypes): take into account that in Alfa\n\tmode the expansion of accept statements is skipped\n\t* sem_util.adb, sem_util.ads (Unique_Entity): New function returning\n\tthe unique entity corresponding to the one returned by\n\tUnique_Defining_Entity applied to the enclosing declaration of the\n\targument.\n\n2011-08-29  Bob Duff  <duff@adacore.com>\n\n\t* treepr.ads: Improve debugging facilities. pn(x) no longer crashes in\n\tgdb when x is not a node (it can be a node list, name_id, etc). pp is\n\tan alias for pn. ppp is an alias for pt.\n\n2011-08-29  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_aggr.adb (Expand_Record_Aggregate): Use the top-level enclosing\n\taggregate to take a consistent decision on the need to convert into\n\tassignments aggregates that initialize constant objects.\n\n2011-08-29  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Expand_Allocator_Expression): Add a call to\n\tBuild_Allocate_Deallocate_Proc in order to handle allocation of\n\tnon-controlled objects on subpools.\n\t* impunit.adb: Remove s-finmas and s-spsufi since they were never meant\n\tto be end-user visible.\n\t* s-finmas.adb: Add with and use clause for System.HTable.\n\tAdd an instantiation of Simple_HTable which provides a mapping between\n\tthe address of a controlled object and the corresponding\n\tFinalize_Address used to clean up the object. The table is used when a\n\tmaster is operating in heterogeneous mode.\n\t(Attach): Explain why the input node is not verified on being already\n\tattached.\n\t(Delete_Finalize_Address): New routine.\n\t(Detach): Add pragma Assert which ensures that a node is already\n\tattached.\n\t(Finalize): Add local variable Cleanup. Rewrite the iteration scheme\n\tsince nodes are no longer removed on traversal. Explain why node\n\tdetachment is undesirable in this case.\n\t(Get_Finalize_Address): New routine.\n\t(Hash): New routine.\n\t(Is_Empty_List): Removed.\n\t(pm): Renamed to Print_Master. Add output for discriminant\n\tIs_Homogeneous.\n\tComment reformatting.\n\t(Set_Finalize_Address (Address, Finalize_Address_Ptr)): New routine.\n\t* s-finmas.ads: Various comments additions / improvements.\n\tType Finalization_Master has a discriminant which determines the mode of\n\toperation.\n\t(Delete_Finalize_Address): New routine.\n\t(Get_Finalize_Address): New routine.\n\t(pm): Renamed to Print_Master.\n\t(Set_Finalize_Address (Address, Finalize_Address_Ptr)): New routine.\n\t* s-stposu.adb: Add with clause for System.Address_Image; Add with and\n\tuse clause for System.IO.\n\t(Allocate_Any_Controlled): Add machinery to set TSS primitive\n\tFinalize_Address depending on the mode of allocation and the mode of\n\tthe master.\n\t(Deallocate_Any_Controlled): Remove the relation pair object -\n\tFinalize_Address regardless of the master mode. Add comment explaining\n\tthe reason.\n\t(Detach): Ensure that fields Prev and Next are null after detachment.\n\t(Finalize_Pool): Remove local variable Next_Ptr. Rewrite the iteration\n\tscheme to check whether the list of subpools is empty. There is no\n\tlonger need to store the next subpool or advance the current pointer.\n\t(Is_Empty_List): New routine.\n\t(Print_Pool): New routine.\n\t(Print_Subpool): New routine.\n\t* s-stposu.ads: Various comments additions / improvements.\n\tField Master of type Root_Subpool is now a heterogeneous collection.\n\t(Print_Pool): New routine.\n\t(Print_Subpool): New routine.\n\n2011-08-29  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch5.adb (Expand_N_Iterator_Loop): Implement Ada2012 loop iterator\n\tforms, using aspects of container types.\n\t* sem_ch3.adb (Find_Type_Name): Preserve Has_Delayed_Aspects and\n\tHas_Implicit_Dereference flags, that may be set on the partial view.\n\t* sem_ch4.adb (Process_Overloaded_Indexed_Component): Prefix may be a\n\tcontainer type with an indexing aspect.\n\t(Analyze_Quantified_Expression): Analyze construct with expansion\n\tdisabled, because it will be rewritten as a loop during expansion.\n\t(Try_Container_Indexing): The prefix itself may be a container type\n\twith an indexing aspect, as with a vector of vectors.\n\t* sem_ch5.adb (Analyze_Iteration_Scheme): In a generic context, analyze\n\tthe original doamin of iteration, for name capture.\n\t(Analyze_Iterator_Specification): If the domain is an expression that\n\tneeds finalization, create a separate declaration for it.\n\tFor an iterator with \"of\" retrieve default iterator info from aspect of\n\tcontainer type. For \"in\" iterator, retrieve type of Iterate function.\n\t* sem_ch13.adb (Check_Iterator_Function): Fix typo.\n\t(Check_Aspect_At_End_Of_Declaration): Make type unfrozen before\n\tanalysis, to prevent spurious errors about late attributes.\n\t* sprint.adb: Handle quantified expression with either loop or iterator\n\tspecification.\n\t* a-convec.ads, a-convec.adb: Iterate function returns a reversible\n\titerator.\n\nFrom-SVN: r178235", "tree": {"sha": "dd6c79976a1022d09f477d90a77c354e8c0153d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd6c79976a1022d09f477d90a77c354e8c0153d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57a8057af4d9cafef111626b162b9ce2b096d63f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57a8057af4d9cafef111626b162b9ce2b096d63f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57a8057af4d9cafef111626b162b9ce2b096d63f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57a8057af4d9cafef111626b162b9ce2b096d63f/comments", "author": null, "committer": null, "parents": [{"sha": "9fdf1422c77cefdb02566f77fde575daa66a1bbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fdf1422c77cefdb02566f77fde575daa66a1bbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fdf1422c77cefdb02566f77fde575daa66a1bbb"}], "stats": {"total": 1204, "additions": 934, "deletions": 270}, "files": [{"sha": "be0713a634ae0e48475d564d3491ff1437159b5a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -1,3 +1,110 @@\n+2011-08-29  Yannick Moy  <moy@adacore.com>\n+\n+\t* gnat1drv.adb (Adjust_Global_Switches): Restore expansion of tagged\n+\ttypes and dispatching calls in Alfa mode.\n+\t* lib-xref-alfa.adb (Collect_ALFA): Rewrite computation of\n+\tcorrespondance between body and spec scopes, to reuse utility functions\n+\t(Traverse_Declarations_Or_Statements): Protect access to body for stub\n+\tby testing the presence of the library unit for the body\n+\t* sem_ch6.adb (Set_Actual_Subtypes): take into account that in Alfa\n+\tmode the expansion of accept statements is skipped\n+\t* sem_util.adb, sem_util.ads (Unique_Entity): New function returning\n+\tthe unique entity corresponding to the one returned by\n+\tUnique_Defining_Entity applied to the enclosing declaration of the\n+\targument.\n+\n+2011-08-29  Bob Duff  <duff@adacore.com>\n+\n+\t* treepr.ads: Improve debugging facilities. pn(x) no longer crashes in\n+\tgdb when x is not a node (it can be a node list, name_id, etc). pp is\n+\tan alias for pn. ppp is an alias for pt.\n+\n+2011-08-29  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_aggr.adb (Expand_Record_Aggregate): Use the top-level enclosing\n+\taggregate to take a consistent decision on the need to convert into\n+\tassignments aggregates that initialize constant objects.\n+\n+2011-08-29  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Allocator_Expression): Add a call to\n+\tBuild_Allocate_Deallocate_Proc in order to handle allocation of\n+\tnon-controlled objects on subpools.\n+\t* impunit.adb: Remove s-finmas and s-spsufi since they were never meant\n+\tto be end-user visible.\n+\t* s-finmas.adb: Add with and use clause for System.HTable.\n+\tAdd an instantiation of Simple_HTable which provides a mapping between\n+\tthe address of a controlled object and the corresponding\n+\tFinalize_Address used to clean up the object. The table is used when a\n+\tmaster is operating in heterogeneous mode.\n+\t(Attach): Explain why the input node is not verified on being already\n+\tattached.\n+\t(Delete_Finalize_Address): New routine.\n+\t(Detach): Add pragma Assert which ensures that a node is already\n+\tattached.\n+\t(Finalize): Add local variable Cleanup. Rewrite the iteration scheme\n+\tsince nodes are no longer removed on traversal. Explain why node\n+\tdetachment is undesirable in this case.\n+\t(Get_Finalize_Address): New routine.\n+\t(Hash): New routine.\n+\t(Is_Empty_List): Removed.\n+\t(pm): Renamed to Print_Master. Add output for discriminant\n+\tIs_Homogeneous.\n+\tComment reformatting.\n+\t(Set_Finalize_Address (Address, Finalize_Address_Ptr)): New routine.\n+\t* s-finmas.ads: Various comments additions / improvements.\n+\tType Finalization_Master has a discriminant which determines the mode of\n+\toperation.\n+\t(Delete_Finalize_Address): New routine.\n+\t(Get_Finalize_Address): New routine.\n+\t(pm): Renamed to Print_Master.\n+\t(Set_Finalize_Address (Address, Finalize_Address_Ptr)): New routine.\n+\t* s-stposu.adb: Add with clause for System.Address_Image; Add with and\n+\tuse clause for System.IO.\n+\t(Allocate_Any_Controlled): Add machinery to set TSS primitive\n+\tFinalize_Address depending on the mode of allocation and the mode of\n+\tthe master.\n+\t(Deallocate_Any_Controlled): Remove the relation pair object -\n+\tFinalize_Address regardless of the master mode. Add comment explaining\n+\tthe reason.\n+\t(Detach): Ensure that fields Prev and Next are null after detachment.\n+\t(Finalize_Pool): Remove local variable Next_Ptr. Rewrite the iteration\n+\tscheme to check whether the list of subpools is empty. There is no\n+\tlonger need to store the next subpool or advance the current pointer.\n+\t(Is_Empty_List): New routine.\n+\t(Print_Pool): New routine.\n+\t(Print_Subpool): New routine.\n+\t* s-stposu.ads: Various comments additions / improvements.\n+\tField Master of type Root_Subpool is now a heterogeneous collection.\n+\t(Print_Pool): New routine.\n+\t(Print_Subpool): New routine.\n+\n+2011-08-29  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch5.adb (Expand_N_Iterator_Loop): Implement Ada2012 loop iterator\n+\tforms, using aspects of container types.\n+\t* sem_ch3.adb (Find_Type_Name): Preserve Has_Delayed_Aspects and\n+\tHas_Implicit_Dereference flags, that may be set on the partial view.\n+\t* sem_ch4.adb (Process_Overloaded_Indexed_Component): Prefix may be a\n+\tcontainer type with an indexing aspect.\n+\t(Analyze_Quantified_Expression): Analyze construct with expansion\n+\tdisabled, because it will be rewritten as a loop during expansion.\n+\t(Try_Container_Indexing): The prefix itself may be a container type\n+\twith an indexing aspect, as with a vector of vectors.\n+\t* sem_ch5.adb (Analyze_Iteration_Scheme): In a generic context, analyze\n+\tthe original doamin of iteration, for name capture.\n+\t(Analyze_Iterator_Specification): If the domain is an expression that\n+\tneeds finalization, create a separate declaration for it.\n+\tFor an iterator with \"of\" retrieve default iterator info from aspect of\n+\tcontainer type. For \"in\" iterator, retrieve type of Iterate function.\n+\t* sem_ch13.adb (Check_Iterator_Function): Fix typo.\n+\t(Check_Aspect_At_End_Of_Declaration): Make type unfrozen before\n+\tanalysis, to prevent spurious errors about late attributes.\n+\t* sprint.adb: Handle quantified expression with either loop or iterator\n+\tspecification.\n+\t* a-convec.ads, a-convec.adb: Iterate function returns a reversible\n+\titerator.\n+\n 2011-08-29  Vincent Celier  <celier@adacore.com>\n \n \t* make.adb (Scan_Make_Arg): Take any option as is in packages Compiler,"}, {"sha": "08220e9e36b7764801429c81944bc61b82bdd0a4", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -2042,7 +2042,7 @@ package body Ada.Containers.Vectors is\n    end Iterate;\n \n    function Iterate (Container : Vector; Start : Cursor)\n-      return Vector_Iterator_Interfaces.Forward_Iterator'Class\n+      return Vector_Iterator_Interfaces.Reversible_Iterator'class\n    is\n       It : constant Iterator :=\n              (Container'Unchecked_Access, Start.Index);"}, {"sha": "e2532f8580379b42ff607dffd247bc9568e1b60a", "filename": "gcc/ada/a-convec.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fa-convec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fa-convec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.ads?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -358,7 +358,7 @@ package Ada.Containers.Vectors is\n       return Vector_Iterator_Interfaces.Reversible_Iterator'Class;\n \n    function Iterate (Container : Vector; Start : Cursor)\n-      return Vector_Iterator_Interfaces.Forward_Iterator'Class;\n+      return Vector_Iterator_Interfaces.Reversible_Iterator'class;\n \n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;"}, {"sha": "fe9cef0828901573774335d33724f55f207b9f8e", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -5099,6 +5099,16 @@ package body Exp_Aggr is\n       --  semantics of Ada complicate the analysis and lead to anomalies in\n       --  the gcc back-end if the aggregate is not expanded into assignments.\n \n+      function Has_Visible_Private_Ancestor (Id : E) return Boolean;\n+      --  If any ancestor of the current type is private, the aggregate\n+      --  cannot be built in place. We canot rely on Has_Private_Ancestor,\n+      --  because it will not be set when type and its parent are in the\n+      --  same scope, and the parent component needs expansion.\n+\n+      function Top_Level_Aggregate (N : Node_Id) return Node_Id;\n+      --  For nested aggregates return the ultimate enclosing aggregate; for\n+      --  non-nested aggregates return N.\n+\n       ----------------------------------\n       -- Component_Not_OK_For_Backend --\n       ----------------------------------\n@@ -5178,25 +5188,14 @@ package body Exp_Aggr is\n          return False;\n       end Component_Not_OK_For_Backend;\n \n-      --  Remaining Expand_Record_Aggregate variables\n-\n-      Tag_Value : Node_Id;\n-      Comp      : Entity_Id;\n-      New_Comp  : Node_Id;\n-\n-      function Has_Visible_Private_Ancestor (Id : E) return Boolean;\n-      --  If any ancestor of the current type is private, the aggregate\n-      --  cannot be built in place. We canot rely on Has_Private_Ancestor,\n-      --  because it will not be set when type and its parent are in the\n-      --  same scope, and the parent component needs expansion.\n-\n       -----------------------------------\n       --  Has_Visible_Private_Ancestor --\n       -----------------------------------\n \n       function Has_Visible_Private_Ancestor (Id : E) return Boolean is\n          R  : constant Entity_Id := Root_Type (Id);\n          T1 : Entity_Id := Id;\n+\n       begin\n          loop\n             if Is_Private_Type (T1) then\n@@ -5211,6 +5210,31 @@ package body Exp_Aggr is\n          end loop;\n       end Has_Visible_Private_Ancestor;\n \n+      -------------------------\n+      -- Top_Level_Aggregate --\n+      -------------------------\n+\n+      function Top_Level_Aggregate (N : Node_Id) return Node_Id is\n+         Aggr : Node_Id := N;\n+\n+      begin\n+         while Present (Parent (Aggr))\n+           and then Nkind_In (Parent (Aggr), N_Component_Association,\n+                                             N_Aggregate)\n+         loop\n+            Aggr := Parent (Aggr);\n+         end loop;\n+\n+         return Aggr;\n+      end Top_Level_Aggregate;\n+\n+      --  Local variables\n+\n+      Top_Level_Aggr : constant Node_Id := Top_Level_Aggregate (N);\n+      Tag_Value      : Node_Id;\n+      Comp           : Entity_Id;\n+      New_Comp       : Node_Id;\n+\n    --  Start of processing for Expand_Record_Aggregate\n \n    begin\n@@ -5317,8 +5341,8 @@ package body Exp_Aggr is\n \n       elsif Has_Mutable_Components (Typ)\n         and then\n-          (Nkind (Parent (N)) /= N_Object_Declaration\n-            or else not Constant_Present (Parent (N)))\n+          (Nkind (Parent (Top_Level_Aggr)) /= N_Object_Declaration\n+            or else not Constant_Present (Parent (Top_Level_Aggr)))\n       then\n          Convert_To_Assignments (N, Typ);\n "}, {"sha": "4824df02583b86cb3660407684be6b0b2a5c5375", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -1137,6 +1137,8 @@ package body Exp_Ch4 is\n             Rewrite (Exp, New_Copy (Expression (Exp)));\n          end if;\n       else\n+         Build_Allocate_Deallocate_Proc (N, True);\n+\n          --  If we have:\n          --    type A is access T1;\n          --    X : A := new T2'(...);"}, {"sha": "21b14d725fce639ab05820f07ca7f8cb3c0cd811", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 119, "deletions": 87, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -2825,6 +2825,7 @@ package body Exp_Ch5 is\n       Container     : constant Node_Id   := Name (I_Spec);\n       Container_Typ : constant Entity_Id := Etype (Container);\n       Cursor        : Entity_Id;\n+      Iterator      : Entity_Id;\n       New_Loop      : Node_Id;\n       Stats         : List_Id := Statements (N);\n \n@@ -2839,10 +2840,10 @@ package body Exp_Ch5 is\n          --  the array.\n \n          if Of_Present (I_Spec) then\n-            Cursor := Make_Temporary (Loc, 'C');\n+            Iterator := Make_Temporary (Loc, 'C');\n \n             --  Generate:\n-            --    Element : Component_Type renames Container (Cursor);\n+            --    Element : Component_Type renames Container (Iterator);\n \n             Prepend_To (Stats,\n               Make_Object_Renaming_Declaration (Loc,\n@@ -2853,19 +2854,19 @@ package body Exp_Ch5 is\n                   Make_Indexed_Component (Loc,\n                     Prefix => Relocate_Node (Container),\n                     Expressions => New_List (\n-                      New_Reference_To (Cursor, Loc)))));\n+                      New_Reference_To (Iterator, Loc)))));\n \n          --  for Index in Array loop\n          --\n-         --  This case utilizes the already given cursor name\n+         --  This case utilizes the already given iterator name\n \n          else\n-            Cursor := Id;\n+            Iterator := Id;\n          end if;\n \n          --  Generate:\n-         --    for Cursor in [reverse] Container'Range loop\n-         --       Element : Component_Type renames Container (Cursor);\n+         --    for Iterator in [reverse] Container'Range loop\n+         --       Element : Component_Type renames Container (Iterator);\n          --       --  for the \"of\" form\n          --\n          --       <original loop statements>\n@@ -2877,7 +2878,7 @@ package body Exp_Ch5 is\n                Make_Iteration_Scheme (Loc,\n                  Loop_Parameter_Specification =>\n                    Make_Loop_Parameter_Specification (Loc,\n-                     Defining_Identifier => Cursor,\n+                     Defining_Identifier => Iterator,\n                        Discrete_Subtype_Definition =>\n                          Make_Attribute_Reference (Loc,\n                            Prefix => Relocate_Node (Container),\n@@ -2889,21 +2890,28 @@ package body Exp_Ch5 is\n       --  Processing for containers\n \n       else\n+         --  For an iterator of the form \"Of\" then name is some expression,\n+         --  which is transformed into a call to the default iterator.\n+\n+         --  For an iterator of the form \"in\" then name is a function call\n+         --  that delivers an iterator.\n+\n          --  The for loop is expanded into a while loop which uses a container\n          --  specific cursor to examine each element.\n \n-         --    Cursor : Pack.Cursor := Container.First;\n-         --    while Cursor /= Pack.No_Element loop\n+         --    Iter : Iterator_Type := Container.Iterate;\n+         --    Cursor : Cursor_type := First (Iter);\n+         --    while Has_Element (Iter) loop\n          --       declare\n          --       --  the block is added when Element_Type is controlled\n \n-         --          Obj : Pack.Element_Type := Element (Cursor);\n+         --          Obj : Pack.Element_Type := Element (Iterator);\n          --          --  for the \"of\" loop form\n          --       begin\n          --          <original loop statements>\n          --       end;\n \n-         --       Pack.Next (Cursor);\n+         --       Cursor := Iter.Next (Cursor);\n          --    end loop;\n \n          --  If \"reverse\" is present, then the initialization of the cursor\n@@ -2912,30 +2920,48 @@ package body Exp_Ch5 is\n \n          declare\n             Element_Type : constant Entity_Id := Etype (Id);\n-            Pack         : constant Entity_Id :=\n-                             Scope (Base_Type (Container_Typ));\n+            Pack         : Entity_Id;\n             Decl         : Node_Id;\n-            Cntr         : Node_Id;\n             Name_Init    : Name_Id;\n             Name_Step    : Name_Id;\n \n          begin\n-            --  The \"of\" case uses an internally generated cursor\n+            if Is_Entity_Name (Container) then\n+               Pack := Scope (Etype (Container));\n+\n+            else\n+               Pack := Scope (Entity (Name (Container)));\n+            end if;\n+\n+            --  The \"of\" case uses an internally generated cursor whose type\n+            --  is found in the container package.\n \n             if Of_Present (I_Spec) then\n-               Cursor := Make_Temporary (Loc, 'C');\n+               Cursor := Make_Temporary (Loc, 'I');\n+\n+               declare\n+                  Ent : Entity_Id;\n+               begin\n+                  Ent := First_Entity (Pack);\n+                  while Present (Ent) loop\n+                     if Chars (Ent) = Name_Cursor then\n+                        Set_Etype (Cursor, Etype (Ent));\n+                        exit;\n+                     end if;\n+                     Next_Entity (Ent);\n+                  end loop;\n+               end;\n+\n             else\n                Cursor := Id;\n             end if;\n \n-            --  The code below only handles containers where Element is not a\n-            --  primitive operation of the container. This excludes for now the\n-            --  Hi-Lite formal containers.\n+            Iterator := Make_Temporary (Loc, 'I');\n \n             if Of_Present (I_Spec) then\n \n                --  Generate:\n-               --    Id : Element_Type := Pack.Element (Cursor);\n+               --    Id : Element_Type renames Pack.Element (Cursor);\n \n                Decl :=\n                  Make_Object_Renaming_Declaration (Loc,\n@@ -2951,18 +2977,18 @@ package body Exp_Ch5 is\n                            Selector_Name =>\n                              Make_Identifier (Loc, Chars => Name_Element)),\n                        Expressions => New_List (\n-                         New_Reference_To (Cursor, Loc))));\n+                          New_Occurrence_Of (Cursor, Loc))));\n \n                --  When the container holds controlled objects, wrap the loop\n                --  statements and element renaming declaration with a block.\n-               --  This ensures that the transient result of Element (Cursor)\n+               --  This ensures that the transient result of Element (Iterator)\n                --  is cleaned up after each iteration of the loop.\n \n                if Needs_Finalization (Element_Type) then\n \n                   --  Generate:\n                   --    declare\n-                  --       Id : Element_Type := Pack.Element (Cursor);\n+                  --       Id : Element_Type := Pack.Element (Iterator);\n                   --    begin\n                   --       <original loop statements>\n                   --    end;\n@@ -2994,22 +3020,38 @@ package body Exp_Ch5 is\n             --  For both iterator forms, add a call to the step operation to\n             --  advance the cursor. Generate:\n             --\n-            --    Pack.[Next | Prev] (Cursor);\n+            --    Cursor := Iterator.Next (Cursor);\n+            --   or else\n+            --    Cursor := Next (Cursor);\n \n-            Append_To (Stats,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name =>\n-                  Make_Selected_Component (Loc,\n-                    Prefix =>\n-                      New_Reference_To (Pack, Loc),\n-                    Selector_Name =>\n-                      Make_Identifier (Loc, Name_Step)),\n+            declare\n+               Rhs : Node_Id;\n+            begin\n+               if Of_Present (I_Spec) then\n+                  Rhs :=\n+                    Make_Function_Call (Loc,\n+                      Name => Make_Identifier (Loc, Name_Step),\n+                      Parameter_Associations =>\n+                        New_List (New_Reference_To (Cursor, Loc)));\n+               else\n+                  Rhs :=\n+                    Make_Function_Call (Loc,\n+                      Name =>\n+                        Make_Selected_Component (Loc,\n+                          Prefix => New_Reference_To (Iterator, Loc),\n+                          Selector_Name => Make_Identifier (Loc, Name_Step)),\n+                      Parameter_Associations => New_List (\n+                         New_Reference_To (Cursor, Loc)));\n+               end if;\n \n-                Parameter_Associations => New_List (\n-                  New_Reference_To (Cursor, Loc))));\n+               Append_To (Stats,\n+                 Make_Assignment_Statement (Loc,\n+                    Name       => New_Occurrence_Of (Cursor, Loc),\n+                    Expression => Rhs));\n+            end;\n \n             --  Generate:\n-            --    while Cursor /= Pack.No_Element loop\n+            --    while Iterator.Has_Element loop\n             --       <Stats>\n             --    end loop;\n \n@@ -3018,71 +3060,61 @@ package body Exp_Ch5 is\n                 Iteration_Scheme =>\n                   Make_Iteration_Scheme (Loc,\n                     Condition =>\n-                      Make_Op_Ne (Loc,\n-                        Left_Opnd =>\n-                          New_Reference_To (Cursor, Loc),\n-                        Right_Opnd =>\n+                      Make_Function_Call (Loc,\n+                        Name =>\n                           Make_Selected_Component (Loc,\n-                            Prefix =>\n-                              New_Reference_To (Pack, Loc),\n-                            Selector_Name =>\n-                              Make_Identifier (Loc, Name_No_Element)))),\n+                           Prefix => New_Occurrence_Of (Pack, Loc),\n+                           Selector_Name =>\n+                             Make_Identifier (Loc,  Name_Has_Element)),\n+\n+                        Parameter_Associations =>\n+                          New_List (\n+                            New_Reference_To (Cursor, Loc)))),\n                 Statements => Stats,\n                 End_Label  => Empty);\n \n-            Cntr := Relocate_Node (Container);\n-\n-            --  When the container is provided by a function call, create an\n-            --  explicit renaming of the function result. Generate:\n-            --\n-            --    Cnn : Container_Typ renames Func_Call (...);\n+            --  Create the declarations for Iterator and cursor and insert then\n+            --  before the source loop. Generate:\n             --\n-            --  The renaming avoids the generation of a transient scope when\n-            --  initializing the cursor and the premature finalization of the\n-            --  container.\n+            --    I : Iterator_Type := Iterate (Container);\n+            --    C : Pack.Cursor_Type := Container.[First | Last];\n \n-            if Nkind (Cntr) = N_Function_Call then\n-               declare\n-                  Ren_Id : constant Entity_Id := Make_Temporary (Loc, 'C');\n+            declare\n+               Decl1 : Node_Id;\n+               Decl2 : Node_Id;\n+            begin\n+               Decl1 :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Iterator,\n+                 Object_Definition =>\n+                   New_Occurrence_Of (Etype (Name (I_Spec)), Loc),\n \n-               begin\n-                  Insert_Action (N,\n-                    Make_Object_Renaming_Declaration (Loc,\n-                      Defining_Identifier => Ren_Id,\n-                      Subtype_Mark =>\n-                        New_Reference_To (Container_Typ, Loc),\n-                      Name => Cntr));\n-\n-                  Cntr := New_Reference_To (Ren_Id, Loc);\n-               end;\n-            end if;\n+                 Expression => Relocate_Node (Name (I_Spec)));\n+               Set_Assignment_OK (Decl1);\n \n-            --  Create the declaration of the cursor and insert it before the\n-            --  source loop. Generate:\n-            --\n-            --    C : Pack.Cursor_Type := Container.[First | Last];\n+               Decl2 :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Cursor,\n+                   Object_Definition =>\n+                     New_Occurrence_Of (Etype (Cursor), Loc),\n \n-            Insert_Action (N,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Cursor,\n-                Object_Definition =>\n-                  Make_Selected_Component (Loc,\n-                    Prefix =>\n-                      New_Reference_To (Pack, Loc),\n-                    Selector_Name =>\n-                      Make_Identifier (Loc, Name_Cursor)),\n+                   Expression =>\n+                     Make_Selected_Component (Loc,\n+                       Prefix => New_Reference_To (Iterator, Loc),\n+                       Selector_Name =>\n+                         Make_Identifier (Loc, Name_Init)));\n \n-                Expression =>\n-                  Make_Selected_Component (Loc,\n-                    Prefix => Cntr,\n-                    Selector_Name =>\n-                      Make_Identifier (Loc, Name_Init))));\n+               Set_Assignment_OK (Decl2);\n+\n+               Insert_Actions (N,\n+                 New_List (Decl1, Decl2));\n+            end;\n \n-            --  The cursor is not modified in the source, but of course will\n+            --  The Iterator is not modified in the source, but of course will\n             --  be updated in the generated code. Indicate that it is actually\n             --  set to prevent spurious warnings.\n \n-            Set_Never_Set_In_Source (Cursor, False);\n+            Set_Never_Set_In_Source (Iterator, False);\n \n             --  If the range of iteration is given by a function call that\n             --  returns a container, the finalization actions have been saved"}, {"sha": "8ec020437ef9a923c533b4d1de738f9d15bade3b", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -476,9 +476,12 @@ procedure Gnat1drv is\n \n          Global_Discard_Names := True;\n \n-         --  Suppress the expansion of tagged types and dispatching calls\n+         --  We would prefer to suppress the expansion of tagged types and\n+         --  dispatching calls, so that one day GNATprove can handle them\n+         --  directly. Unfortunately, this is causing problems on H513-015, so\n+         --  keep this expansion for the time being.\n \n-         Tagged_Type_Expansion := False;\n+         Tagged_Type_Expansion := True;\n       end if;\n    end Adjust_Global_Switches;\n "}, {"sha": "9aa86d523f6914297e8c9ea05e1f6504a9a8d650", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -346,7 +346,6 @@ package body Impunit is\n \n      \"s-addima\",    -- System.Address_Image\n      \"s-assert\",    -- System.Assertions\n-     \"s-finmas\",    -- System.Finalization_Masters\n      \"s-memory\",    -- System.Memory\n      \"s-parint\",    -- System.Partition_Interface\n      \"s-pooglo\",    -- System.Pool_Global\n@@ -529,7 +528,6 @@ package body Impunit is\n    -- GNAT Defined Additions to Ada 20012 --\n    -----------------------------------------\n \n-     \"s-spsufi\",    -- System.Storage_Pools.Subpools.Finalization\n      \"a-cofove\",    -- Ada.Containers.Formal_Vectors\n      \"a-cfdlli\",    -- Ada.Containers.Formal_Doubly_Linked_Lists\n      \"a-cforse\",    -- Ada.Containers.Formal_Ordered_Sets"}, {"sha": "70d5062f10374e1362c231f6c4b852c2616ef1d1", "filename": "gcc/ada/lib-xref-alfa.adb", "status": "modified", "additions": 38, "deletions": 49, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Flib-xref-alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Flib-xref-alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-alfa.adb?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -835,38 +835,22 @@ package body ALFA is\n             declare\n                Srec : ALFA_Scope_Record renames ALFA_Scope_Table.Table (S);\n \n-               Body_Entity : Entity_Id;\n-               Spec_Entity : Entity_Id;\n-               Spec_Scope  : Scope_Index;\n+               Spec_Entity : constant Entity_Id :=\n+                               Unique_Entity (Srec.Scope_Entity);\n+               Spec_Scope  : constant Scope_Index :=\n+                               Entity_Hash_Table.Get (Spec_Entity);\n \n             begin\n-               if Ekind (Srec.Scope_Entity) = E_Subprogram_Body then\n-                  Body_Entity := Parent (Parent (Srec.Scope_Entity));\n-               elsif Ekind (Srec.Scope_Entity) = E_Package_Body then\n-                  Body_Entity := Parent (Srec.Scope_Entity);\n-               else\n-                  Body_Entity := Empty;\n-               end if;\n-\n-               if Present (Body_Entity) then\n-                  if Nkind (Body_Entity) = N_Defining_Program_Unit_Name then\n-                     Body_Entity := Parent (Body_Entity);\n-                  elsif Nkind (Body_Entity) = N_Subprogram_Body_Stub then\n-                     Body_Entity :=\n-                       Proper_Body (Unit (Library_Unit (Body_Entity)));\n-                  end if;\n-\n-                  Spec_Entity := Corresponding_Spec (Body_Entity);\n-                  Spec_Scope := Entity_Hash_Table.Get (Spec_Entity);\n-\n-                  --  Spec of generic may be missing\n+               --  Spec of generic may be missing, in which case Spec_Scope is\n+               --  zero.\n \n-                  if Spec_Scope /= 0 then\n-                     Srec.Spec_File_Num :=\n-                       ALFA_Scope_Table.Table (Spec_Scope).File_Num;\n-                     Srec.Spec_Scope_Num :=\n-                       ALFA_Scope_Table.Table (Spec_Scope).Scope_Num;\n-                  end if;\n+               if Spec_Entity /= Srec.Scope_Entity\n+                 and then Spec_Scope /= 0\n+               then\n+                  Srec.Spec_File_Num :=\n+                    ALFA_Scope_Table.Table (Spec_Scope).File_Num;\n+                  Srec.Spec_Scope_Num :=\n+                    ALFA_Scope_Table.Table (Spec_Scope).Scope_Num;\n                end if;\n             end;\n          end loop;\n@@ -1019,16 +1003,18 @@ package body ALFA is\n                end if;\n \n             when N_Package_Body_Stub =>\n-               declare\n-                  Body_N : constant Node_Id := Get_Body_From_Stub (N);\n-               begin\n-                  if Inside_Stubs\n-                    and then\n-                      Ekind (Defining_Entity (Body_N)) /= E_Generic_Package\n-                  then\n-                     Traverse_Package_Body (Body_N, Process, Inside_Stubs);\n-                  end if;\n-               end;\n+               if Present (Library_Unit (N)) then\n+                  declare\n+                     Body_N : constant Node_Id := Get_Body_From_Stub (N);\n+                  begin\n+                     if Inside_Stubs\n+                       and then\n+                         Ekind (Defining_Entity (Body_N)) /= E_Generic_Package\n+                     then\n+                        Traverse_Package_Body (Body_N, Process, Inside_Stubs);\n+                     end if;\n+                  end;\n+               end if;\n \n             --  Subprogram declaration\n \n@@ -1048,16 +1034,19 @@ package body ALFA is\n                end if;\n \n             when N_Subprogram_Body_Stub =>\n-               declare\n-                  Body_N : constant Node_Id := Get_Body_From_Stub (N);\n-               begin\n-                  if Inside_Stubs\n-                    and then\n-                      not Is_Generic_Subprogram (Defining_Entity (Body_N))\n-                  then\n-                     Traverse_Subprogram_Body (Body_N, Process, Inside_Stubs);\n-                  end if;\n-               end;\n+               if Present (Library_Unit (N)) then\n+                  declare\n+                     Body_N : constant Node_Id := Get_Body_From_Stub (N);\n+                  begin\n+                     if Inside_Stubs\n+                       and then\n+                         not Is_Generic_Subprogram (Defining_Entity (Body_N))\n+                     then\n+                        Traverse_Subprogram_Body\n+                          (Body_N, Process, Inside_Stubs);\n+                     end if;\n+                  end;\n+               end if;\n \n             --  Block statement\n "}, {"sha": "4ab8a301b674634063b665aa9b02c0abcfd4a02a", "filename": "gcc/ada/s-finmas.adb", "status": "modified", "additions": 122, "deletions": 28, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fs-finmas.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fs-finmas.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finmas.adb?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -31,12 +31,32 @@\n \n with Ada.Exceptions;          use Ada.Exceptions;\n with System.Address_Image;\n+with System.HTable;           use System.HTable;\n with System.IO;               use System.IO;\n with System.Soft_Links;       use System.Soft_Links;\n with System.Storage_Elements; use System.Storage_Elements;\n \n package body System.Finalization_Masters is\n \n+   --  Finalize_Address hash table types. In general, masters are homogeneous\n+   --  collections of controlled objects. Rare cases such as allocations on a\n+   --  subpool require heterogeneous masters. The following table provides a\n+   --  relation between object address and its Finalize_Address routine.\n+\n+   type Header_Num is range 0 .. 127;\n+\n+   function Hash (Key : System.Address) return Header_Num;\n+\n+   --  Address --> Finalize_Address_Ptr\n+\n+   package Finalize_Address_Table is new Simple_HTable\n+     (Header_Num => Header_Num,\n+      Element    => Finalize_Address_Ptr,\n+      No_Element => null,\n+      Key        => System.Address,\n+      Hash       => Hash,\n+      Equal      => \"=\");\n+\n    ---------------------------\n    -- Add_Offset_To_Address --\n    ---------------------------\n@@ -79,6 +99,17 @@ package body System.Finalization_Masters is\n       return Master.Base_Pool;\n    end Base_Pool;\n \n+   -----------------------------\n+   -- Delete_Finalize_Address --\n+   -----------------------------\n+\n+   procedure Delete_Finalize_Address (Obj : System.Address) is\n+   begin\n+      Lock_Task.all;\n+      Finalize_Address_Table.Remove (Obj);\n+      Unlock_Task.all;\n+   end Delete_Finalize_Address;\n+\n    ------------\n    -- Detach --\n    ------------\n@@ -94,17 +125,18 @@ package body System.Finalization_Masters is\n          N.Next := null;\n \n          Unlock_Task.all;\n-      end if;\n \n-      --  Note: No need to unlock in case of an exception because the above\n-      --  code can never raise one.\n+         --  Note: No need to unlock in case of an exception because the above\n+         --  code can never raise one.\n+      end if;\n    end Detach;\n \n    --------------\n    -- Finalize --\n    --------------\n \n    overriding procedure Finalize (Master : in out Finalization_Master) is\n+      Cleanup  : Finalize_Address_Ptr;\n       Curr_Ptr : FM_Node_Ptr;\n       Ex_Occur : Exception_Occurrence;\n       Obj_Addr : Address;\n@@ -144,23 +176,41 @@ package body System.Finalization_Masters is\n \n          Detach (Curr_Ptr);\n \n-         if Master.Finalize_Address /= null then\n+         --  Skip the list header in order to offer proper object layout for\n+         --  finalization.\n+\n+         Obj_Addr := Curr_Ptr.all'Address + Header_Offset;\n+\n+         --  Retrieve TSS primitive Finalize_Address depending on the master's\n+         --  mode of operation.\n+\n+         if Master.Is_Homogeneous then\n+            Cleanup := Master.Finalize_Address;\n+         else\n+            Cleanup := Get_Finalize_Address (Obj_Addr);\n+         end if;\n+\n+         --  If Finalize_Address is not available, then this is most likely an\n+         --  error in the expansion of the designated type or the allocator.\n+\n+         pragma Assert (Cleanup /= null);\n \n-            --  Skip the list header in order to offer proper object layout for\n-            --  finalization and call Finalize_Address.\n+         begin\n+            Cleanup (Obj_Addr);\n \n-            Obj_Addr := Curr_Ptr.all'Address + Header_Offset;\n+         exception\n+            when Fin_Occur : others =>\n+               if not Raised then\n+                  Raised := True;\n+                  Save_Occurrence (Ex_Occur, Fin_Occur);\n+               end if;\n+         end;\n \n-            begin\n-               Master.Finalize_Address (Obj_Addr);\n+         --  When the master is a heterogeneous collection, destroy the object\n+         --  - Finalize_Address pair since it is no longer needed.\n \n-            exception\n-               when Fin_Occur : others =>\n-                  if not Raised then\n-                     Raised := True;\n-                     Save_Occurrence (Ex_Occur, Fin_Occur);\n-                  end if;\n-            end;\n+         if not Master.Is_Homogeneous then\n+            Delete_Finalize_Address (Obj_Addr);\n          end if;\n       end loop;\n \n@@ -172,6 +222,23 @@ package body System.Finalization_Masters is\n       end if;\n    end Finalize;\n \n+   --------------------------\n+   -- Get_Finalize_Address --\n+   --------------------------\n+\n+   function Get_Finalize_Address\n+     (Obj : System.Address) return Finalize_Address_Ptr\n+   is\n+      Result : Finalize_Address_Ptr;\n+\n+   begin\n+      Lock_Task.all;\n+      Result := Finalize_Address_Table.Get (Obj);\n+      Unlock_Task.all;\n+\n+      return Result;\n+   end Get_Finalize_Address;\n+\n    -----------------\n    -- Header_Size --\n    -----------------\n@@ -181,6 +248,17 @@ package body System.Finalization_Masters is\n       return FM_Node'Size / Storage_Unit;\n    end Header_Size;\n \n+   ----------\n+   -- Hash --\n+   ----------\n+\n+   function Hash (Key : System.Address) return Header_Num is\n+   begin\n+      return\n+        Header_Num\n+          (To_Integer (Key) mod Integer_Address (Header_Num'Range_Length));\n+   end Hash;\n+\n    -------------------\n    -- Header_Offset --\n    -------------------\n@@ -202,11 +280,11 @@ package body System.Finalization_Masters is\n       Master.Objects.Prev := Master.Objects'Unchecked_Access;\n    end Initialize;\n \n-   --------\n-   -- pm --\n-   --------\n+   ------------------\n+   -- Print_Master --\n+   ------------------\n \n-   procedure pm (Master : Finalization_Master) is\n+   procedure Print_Master (Master : Finalization_Master) is\n       Head      : constant FM_Node_Ptr := Master.Objects'Unrestricted_Access;\n       Head_Seen : Boolean := False;\n       N_Ptr     : FM_Node_Ptr;\n@@ -215,23 +293,25 @@ package body System.Finalization_Masters is\n       --  Output the basic contents of a master\n \n       --    Master   : 0x123456789\n+      --    Is_Hmgen : TURE <or> FALSE\n       --    Base_Pool: null <or> 0x123456789\n       --    Fin_Addr : null <or> 0x123456789\n       --    Fin_Start: TRUE <or> FALSE\n \n       Put (\"Master   : \");\n       Put_Line (Address_Image (Master'Address));\n \n-      Put (\"Base_Pool: \");\n+      Put (\"Is_Hmgen : \");\n+      Put_Line (Master.Is_Homogeneous'Img);\n \n+      Put (\"Base_Pool: \");\n       if Master.Base_Pool = null then\n-         Put_Line (\" null\");\n+         Put_Line (\"null\");\n       else\n          Put_Line (Address_Image (Master.Base_Pool'Address));\n       end if;\n \n       Put (\"Fin_Addr : \");\n-\n       if Master.Finalize_Address = null then\n          Put_Line (\"null\");\n       else\n@@ -255,17 +335,17 @@ package body System.Finalization_Masters is\n \n       --  Header - the address of the list header\n       --  Prev   - the address of the list header which the current element\n-      --         - points back to\n+      --           points back to\n       --  Next   - the address of the list header which the current element\n-      --         - points to\n+      --           points to\n       --  (dummy head) - present if dummy head\n \n       N_Ptr := Head;\n-      while N_Ptr /= null loop -- Should never be null; we being defensive\n+      while N_Ptr /= null loop  --  Should never be null\n          Put_Line (\"V\");\n \n          --  We see the head initially; we want to exit when we see the head a\n-         --  SECOND time.\n+         --  second time.\n \n          if N_Ptr = Head then\n             exit when Head_Seen;\n@@ -321,7 +401,7 @@ package body System.Finalization_Masters is\n \n          N_Ptr := N_Ptr.Next;\n       end loop;\n-   end pm;\n+   end Print_Master;\n \n    -------------------\n    -- Set_Base_Pool --\n@@ -347,4 +427,18 @@ package body System.Finalization_Masters is\n       Master.Finalize_Address := Fin_Addr_Ptr;\n    end Set_Finalize_Address;\n \n+   --------------------------\n+   -- Set_Finalize_Address --\n+   --------------------------\n+\n+   procedure Set_Finalize_Address\n+     (Obj          : System.Address;\n+      Fin_Addr_Ptr : Finalize_Address_Ptr)\n+   is\n+   begin\n+      Lock_Task.all;\n+      Finalize_Address_Table.Set (Obj, Fin_Addr_Ptr);\n+      Unlock_Task.all;\n+   end Set_Finalize_Address;\n+\n end System.Finalization_Masters;"}, {"sha": "6dd5e38fba7e8ae5ddfe4465fae74a896586f7f2", "filename": "gcc/ada/s-finmas.ads", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fs-finmas.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fs-finmas.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finmas.ads?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -31,7 +31,6 @@\n \n with Ada.Finalization;\n with Ada.Unchecked_Conversion;\n-\n with System.Storage_Elements;\n with System.Storage_Pools;\n \n@@ -69,9 +68,10 @@ package System.Finalization_Masters is\n \n    --  Finalization master type structure. A unique master is associated with\n    --  each access-to-controlled or access-to-class-wide type. Masters also act\n-   --  as components of subpools.\n+   --  as components of subpools. By default, a master contains objects of the\n+   --  same designated type but it may also accomodate heterogeneous objects.\n \n-   type Finalization_Master is\n+   type Finalization_Master (Is_Homogeneous : Boolean := True) is\n      new Ada.Finalization.Limited_Controlled with\n    record\n       Base_Pool : Any_Storage_Pool_Ptr := null;\n@@ -83,7 +83,8 @@ package System.Finalization_Masters is\n       --  objects allocated in a [sub]pool.\n \n       Finalize_Address : Finalize_Address_Ptr := null;\n-      --  A reference to the routine reponsible for object finalization\n+      --  A reference to the routine reponsible for object finalization. This\n+      --  is used only when the master is in homogeneous mode.\n \n       Finalization_Started : Boolean := False;\n       pragma Atomic (Finalization_Started);\n@@ -114,6 +115,10 @@ package System.Finalization_Masters is\n    --  Return a reference to the underlying storage pool on which the master\n    --  operates.\n \n+   procedure Delete_Finalize_Address (Obj : System.Address);\n+   --  Destroy the relation pair object - Finalize_Address from the internal\n+   --  hash table.\n+\n    procedure Detach (N : not null FM_Node_Ptr);\n    --  Remove a node from an arbitrary finalization master\n \n@@ -122,6 +127,11 @@ package System.Finalization_Masters is\n    --  the list of allocated controlled objects, finalizing each one by calling\n    --  its specific Finalize_Address. In the end, deallocate the dummy head.\n \n+   function Get_Finalize_Address\n+     (Obj : System.Address) return Finalize_Address_Ptr;\n+   --  Retrieve the Finalize_Address primitive associated with a particular\n+   --  object.\n+\n    function Header_Offset return System.Storage_Elements.Storage_Offset;\n    --  Return the size of type FM_Node as Storage_Offset\n \n@@ -131,7 +141,7 @@ package System.Finalization_Masters is\n    overriding procedure Initialize (Master : in out Finalization_Master);\n    --  Initialize the dummy head of a finalization master\n \n-   procedure pm (Master : Finalization_Master);\n+   procedure Print_Master (Master : Finalization_Master);\n    --  Debug routine, outputs the contents of a master\n \n    procedure Set_Base_Pool\n@@ -144,4 +154,9 @@ package System.Finalization_Masters is\n       Fin_Addr_Ptr : Finalize_Address_Ptr);\n    --  Set the clean up routine of a finalization master\n \n+   procedure Set_Finalize_Address\n+     (Obj          : System.Address;\n+      Fin_Addr_Ptr : Finalize_Address_Ptr);\n+   --  Add a relation pair object - Finalize_Address to the internal hash table\n+\n end System.Finalization_Masters;"}, {"sha": "0cdc90b7084b14bca8fecd48f35641103c62fa1e", "filename": "gcc/ada/s-stposu.adb", "status": "modified", "additions": 195, "deletions": 14, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fs-stposu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fs-stposu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stposu.adb?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -31,8 +31,9 @@\n \n with Ada.Exceptions;              use Ada.Exceptions;\n with Ada.Unchecked_Deallocation;\n-\n+with System.Address_Image;\n with System.Finalization_Masters; use System.Finalization_Masters;\n+with System.IO;                   use System.IO;\n with System.Soft_Links;           use System.Soft_Links;\n with System.Storage_Elements;     use System.Storage_Elements;\n \n@@ -248,21 +249,39 @@ package body System.Storage_Pools.Subpools is\n          --     +- Header_And_Padding --+\n \n          N_Ptr := Address_To_FM_Node_Ptr\n-                   (N_Addr + Header_And_Padding - Header_Offset);\n+                    (N_Addr + Header_And_Padding - Header_Offset);\n \n          --  Prepend the allocated object to the finalization master\n \n          Attach (N_Ptr, Master.Objects'Unchecked_Access);\n \n-         if Master.Finalize_Address = null then\n-            Master.Finalize_Address := Fin_Address;\n-         end if;\n-\n          --  Move the address from the hidden list header to the start of the\n          --  object. This operation effectively hides the list header.\n \n          Addr := N_Addr + Header_And_Padding;\n \n+         --  Subpool allocations use heterogeneous masters to manage various\n+         --  controlled objects. Associate a Finalize_Address with the object.\n+         --  This relation pair is deleted when the object is deallocated or\n+         --  when the associated master is finalized.\n+\n+         if Is_Subpool_Allocation then\n+            pragma Assert (not Master.Is_Homogeneous);\n+\n+            Set_Finalize_Address (Addr, Fin_Address);\n+\n+         --  Normal allocations chain objects on homogeneous collections\n+\n+         else\n+            pragma Assert (Master.Is_Homogeneous);\n+\n+            if Master.Finalize_Address = null then\n+               Master.Finalize_Address := Fin_Address;\n+            end if;\n+         end if;\n+\n+      --  Non-controlled allocation\n+\n       else\n          Addr := N_Addr;\n       end if;\n@@ -315,6 +334,14 @@ package body System.Storage_Pools.Subpools is\n \n       if Is_Controlled then\n \n+         --  Destroy the relation pair object - Finalize_Address since it is no\n+         --  longer needed. If the object was chained on a homogeneous master,\n+         --  this call does nothing. This is unconditional destruction since we\n+         --  do not want to drag in additional data to determine the master\n+         --  kind.\n+\n+         Delete_Finalize_Address (Addr);\n+\n          --  Account for possible padding space before the header due to a\n          --  larger alignment.\n \n@@ -382,6 +409,8 @@ package body System.Storage_Pools.Subpools is\n \n       N.Prev.Next := N.Next;\n       N.Next.Prev := N.Prev;\n+      N.Prev := null;\n+      N.Next := null;\n \n       Unlock_Task.all;\n \n@@ -405,9 +434,22 @@ package body System.Storage_Pools.Subpools is\n    procedure Finalize_Pool (Pool : in out Root_Storage_Pool_With_Subpools) is\n       Curr_Ptr : SP_Node_Ptr;\n       Ex_Occur : Exception_Occurrence;\n-      Next_Ptr : SP_Node_Ptr;\n       Raised   : Boolean := False;\n \n+      function Is_Empty_List (L : not null SP_Node_Ptr) return Boolean;\n+      --  Determine whether a list contains only one element, the dummy head\n+\n+      -------------------\n+      -- Is_Empty_List --\n+      -------------------\n+\n+      function Is_Empty_List (L : not null SP_Node_Ptr) return Boolean is\n+      begin\n+         return L.Next = L and then L.Prev = L;\n+      end Is_Empty_List;\n+\n+   --  Start of processing for Finalize_Pool\n+\n    begin\n       --  It is possible for multiple tasks to cause the finalization of a\n       --  common pool. Allow only one task to finalize the contents.\n@@ -423,11 +465,8 @@ package body System.Storage_Pools.Subpools is\n \n       Pool.Finalization_Started := True;\n \n-      --  Skip the dummy head\n-\n-      Curr_Ptr := Pool.Subpools.Next;\n-      while Curr_Ptr /= Pool.Subpools'Unchecked_Access loop\n-         Next_Ptr := Curr_Ptr.Next;\n+      while not Is_Empty_List (Pool.Subpools'Unchecked_Access) loop\n+         Curr_Ptr := Pool.Subpools.Next;\n \n          --  Perform the following actions:\n \n@@ -446,8 +485,6 @@ package body System.Storage_Pools.Subpools is\n                   Save_Occurrence (Ex_Occur, Fin_Occur);\n                end if;\n          end;\n-\n-         Curr_Ptr := Next_Ptr;\n       end loop;\n \n       --  If the finalization of a particular master failed, reraise the\n@@ -537,6 +574,150 @@ package body System.Storage_Pools.Subpools is\n       return Subpool.Owner;\n    end Pool_Of_Subpool;\n \n+   ----------------\n+   -- Print_Pool --\n+   ----------------\n+\n+   procedure Print_Pool (Pool : Root_Storage_Pool_With_Subpools) is\n+      Head      : constant SP_Node_Ptr := Pool.Subpools'Unrestricted_Access;\n+      Head_Seen : Boolean := False;\n+      SP_Ptr    : SP_Node_Ptr;\n+\n+   begin\n+      --  Output the contents of the pool\n+\n+      --    Pool      : 0x123456789\n+      --    Subpools  : 0x123456789\n+      --    Fin_Start : TRUE <or> FALSE\n+      --    Controller: OK <or> NOK\n+\n+      Put (\"Pool      : \");\n+      Put_Line (Address_Image (Pool'Address));\n+\n+      Put (\"Subpools  : \");\n+      Put_Line (Address_Image (Pool.Subpools'Address));\n+\n+      Put (\"Fin_Start : \");\n+      Put_Line (Pool.Finalization_Started'Img);\n+\n+      Put (\"Controlled: \");\n+      if Pool.Controller.Enclosing_Pool = Pool'Unrestricted_Access then\n+         Put_Line (\"OK\");\n+      else\n+         Put_Line (\"NOK (ERROR)\");\n+      end if;\n+\n+      SP_Ptr := Head;\n+      while SP_Ptr /= null loop  --  Should never be null\n+         Put_Line (\"V\");\n+\n+         --  We see the head initially; we want to exit when we see the head a\n+         --  second time.\n+\n+         if SP_Ptr = Head then\n+            exit when Head_Seen;\n+\n+            Head_Seen := True;\n+         end if;\n+\n+         --  The current element is null. This should never happend since the\n+         --  list is circular.\n+\n+         if SP_Ptr.Prev = null then\n+            Put_Line (\"null (ERROR)\");\n+\n+         --  The current element points back to the correct element\n+\n+         elsif SP_Ptr.Prev.Next = SP_Ptr then\n+            Put_Line (\"^\");\n+\n+         --  The current element points to an erroneous element\n+\n+         else\n+            Put_Line (\"? (ERROR)\");\n+         end if;\n+\n+         --  Output the contents of the node\n+\n+         Put (\"|Header: \");\n+         Put (Address_Image (SP_Ptr.all'Address));\n+         if SP_Ptr = Head then\n+            Put_Line (\" (dummy head)\");\n+         else\n+            Put_Line (\"\");\n+         end if;\n+\n+         Put (\"|  Prev: \");\n+\n+         if SP_Ptr.Prev = null then\n+            Put_Line (\"null\");\n+         else\n+            Put_Line (Address_Image (SP_Ptr.Prev.all'Address));\n+         end if;\n+\n+         Put (\"|  Next: \");\n+\n+         if SP_Ptr.Next = null then\n+            Put_Line (\"null\");\n+         else\n+            Put_Line (Address_Image (SP_Ptr.Next.all'Address));\n+         end if;\n+\n+         Put (\"|  Subp: \");\n+\n+         if SP_Ptr.Subpool = null then\n+            Put_Line (\"null\");\n+         else\n+            Put_Line (Address_Image (SP_Ptr.Subpool.all'Address));\n+         end if;\n+\n+         SP_Ptr := SP_Ptr.Next;\n+      end loop;\n+   end Print_Pool;\n+\n+   -------------------\n+   -- Print_Subpool --\n+   -------------------\n+\n+   procedure Print_Subpool (Subpool : Subpool_Handle) is\n+   begin\n+      if Subpool = null then\n+         Put_Line (\"null\");\n+         return;\n+      end if;\n+\n+      --  Output the contents of a subpool\n+\n+      --    Owner : 0x123456789\n+      --    Master: 0x123456789\n+      --    Node  : 0x123456789\n+\n+      Put (\"Owner : \");\n+      if Subpool.Owner = null then\n+         Put_Line (\"null\");\n+      else\n+         Put_Line (Address_Image (Subpool.Owner'Address));\n+      end if;\n+\n+      Put (\"Master: \");\n+      Put_Line (Address_Image (Subpool.Master'Address));\n+\n+      Put (\"Node  : \");\n+      if Subpool.Node = null then\n+         Put (\"null\");\n+\n+         if Subpool.Owner = null then\n+            Put_Line (\" OK\");\n+         else\n+            Put_Line (\" (ERROR)\");\n+         end if;\n+      else\n+         Put_Line (Address_Image (Subpool.Node'Address));\n+      end if;\n+\n+      Print_Master (Subpool.Master);\n+   end Print_Subpool;\n+\n    -------------------------\n    -- Set_Pool_Of_Subpool --\n    -------------------------"}, {"sha": "79ff97cfdce1ba1598682eaa392891637210cd69", "filename": "gcc/ada/s-stposu.ads", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fs-stposu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fs-stposu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stposu.ads?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -34,7 +34,6 @@\n ------------------------------------------------------------------------------\n \n with Ada.Finalization;\n-\n with System.Finalization_Masters;\n with System.Storage_Elements;\n \n@@ -241,8 +240,8 @@ private\n       Owner : Any_Storage_Pool_With_Subpools_Ptr := null;\n       --  A reference to the master pool_with_subpools\n \n-      Master : aliased System.Finalization_Masters.Finalization_Master;\n-      --  A collection of controlled objects\n+      Master : aliased System.Finalization_Masters.Finalization_Master (False);\n+      --  A heterogeneous collection of controlled objects\n \n       Node : SP_Node_Ptr := null;\n       --  A link to the doubly linked list node which contains the subpool.\n@@ -336,4 +335,10 @@ private\n    procedure Initialize_Pool (Pool : in out Root_Storage_Pool_With_Subpools);\n    --  Setup the doubly linked list of subpools\n \n+   procedure Print_Pool (Pool : Root_Storage_Pool_With_Subpools);\n+   --  Debug routine, output the contents of a pool_with_subpools\n+\n+   procedure Print_Subpool (Subpool : Subpool_Handle);\n+   --  Debug routine, output the contents of a subpool\n+\n end System.Storage_Pools.Subpools;"}, {"sha": "7b2d9e74f2d2c947fca13d877fa60d4403bac24a", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -1904,7 +1904,7 @@ package body Sem_Ch13 is\n                Get_First_Interp (Expr, I, It);\n                while Present (It.Nam) loop\n                   if not Check_Primitive_Function (It.Nam)\n-                    or else Valid_Default_Iterator (It.Nam)\n+                    or else not Valid_Default_Iterator (It.Nam)\n                   then\n                      Remove_Interp (I);\n \n@@ -5767,8 +5767,13 @@ package body Sem_Ch13 is\n             A_Id = Aspect_Default_Iterator  or else\n             A_Id = Aspect_Iterator_Element\n       then\n+         --  Make type unfrozen before analysis, to prevent spurious\n+         --  errors about late attributes.\n+\n+         Set_Is_Frozen (Ent, False);\n          Analyze (End_Decl_Expr);\n          Analyze (Aspect_Rep_Item (ASN));\n+         Set_Is_Frozen (Ent, True);\n \n          --  If the end of declarations comes before any other freeze\n          --  point, the Freeze_Expr is not analyzed: no check needed."}, {"sha": "c1cd42d2950a495c8182d855ca169719c3f03f13", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -15003,6 +15003,12 @@ package body Sem_Ch3 is\n             Set_Has_Private_Declaration (Prev);\n             Set_Has_Private_Declaration (Id);\n \n+            --  Preserve aspect and iterator flags, that may have been\n+            --  set on the partial view.\n+\n+            Set_Has_Delayed_Aspects (Prev, Has_Delayed_Aspects (Id));\n+            Set_Has_Implicit_Dereference (Prev, Has_Implicit_Dereference (Id));\n+\n             --  If no error, propagate freeze_node from private to full view.\n             --  It may have been generated for an early operational item.\n "}, {"sha": "4b2b9eab260d596debb0b8a8272cb8a118bdbdfd", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -30,6 +30,7 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Util; use Exp_Util;\n+with Expander; use Expander;\n with Fname;    use Fname;\n with Itypes;   use Itypes;\n with Lib;      use Lib;\n@@ -2235,6 +2236,10 @@ package body Sem_Ch4 is\n                      Check_Implicit_Dereference (N, CT);\n                   end;\n                end if;\n+\n+            elsif Try_Container_Indexing (N, P, First (Exprs)) then\n+               return;\n+\n             end if;\n \n             Get_Next_Interp (I, It);\n@@ -3340,6 +3345,7 @@ package body Sem_Ch4 is\n       Iterator : Node_Id;\n \n    begin\n+      Expander_Mode_Save_And_Set (False);\n       Check_SPARK_Restriction (\"quantified expression is not allowed\", N);\n \n       Set_Etype  (Ent,  Standard_Void_Type);\n@@ -3373,8 +3379,8 @@ package body Sem_Ch4 is\n \n       Analyze (Condition (N));\n       End_Scope;\n-\n       Set_Etype (N, Standard_Boolean);\n+      Expander_Mode_Restore;\n    end Analyze_Quantified_Expression;\n \n    -------------------\n@@ -6366,7 +6372,18 @@ package body Sem_Ch4 is\n       --  diagnosed in caller.\n \n       if No (Func_Name) then\n-         return False;\n+\n+         --  The prefix itself may be an indexing of a container\n+         --  rewrite as such and re-analyze.\n+\n+         if Has_Implicit_Dereference (Etype (Prefix)) then\n+            Build_Explicit_Dereference\n+              (Prefix, First_Discriminant (Etype (Prefix)));\n+            return Try_Container_Indexing (N, Prefix, Expr);\n+\n+         else\n+            return False;\n+         end if;\n       end if;\n \n       if Is_Var"}, {"sha": "ef74ed9df0310a360a9ece7034c214ac733b1085", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 119, "deletions": 32, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n@@ -2005,7 +2006,22 @@ package body Sem_Ch5 is\n                   Set_Parent (D_Copy, Parent (DS));\n                   Pre_Analyze_Range (D_Copy);\n \n+                  --  Ada2012 : if the domain of iteration is a function call,\n+                  --  it is the new iterator form.\n+\n+                  --  We have also implemented the shorter form : for X in S\n+                  --  for Alfa use. In this case the attributes Old and Result\n+                  --  must be treated as entity names  over which iterators are\n+                  --  legal.\n+\n                   if Nkind (D_Copy) = N_Function_Call\n+                    or else\n+                      (ALFA_Mode\n+                       and then (Nkind (D_Copy) = N_Attribute_Reference\n+                       and then\n+                         (Attribute_Name (D_Copy) = Name_Result\n+                            or else Attribute_Name (D_Copy) = Name_Old)))\n+\n                     or else\n                       (Is_Entity_Name (D_Copy)\n                         and then not Is_Type (Entity (D_Copy)))\n@@ -2027,6 +2043,14 @@ package body Sem_Ch5 is\n                         Set_Iterator_Specification (N, I_Spec);\n                         Set_Loop_Parameter_Specification (N, Empty);\n                         Analyze_Iterator_Specification (I_Spec);\n+\n+                        --  In a generic context, analyze the original\n+                        --  domain of iteration, for name capture.\n+\n+                        if not Expander_Active then\n+                           Analyze (DS);\n+                        end if;\n+\n                         return;\n                      end;\n \n@@ -2207,7 +2231,7 @@ package body Sem_Ch5 is\n       Loc       : constant Source_Ptr := Sloc (N);\n       Def_Id    : constant Node_Id    := Defining_Identifier (N);\n       Subt      : constant Node_Id    := Subtype_Indication (N);\n-      Container : constant Node_Id    := Name (N);\n+      Iter_Name : constant Node_Id    := Name (N);\n \n       Ent : Entity_Id;\n       Typ : Entity_Id;\n@@ -2220,45 +2244,83 @@ package body Sem_Ch5 is\n          Analyze (Subt);\n       end if;\n \n-      --  If it is an expression, the container is pre-analyzed in the caller.\n+      --  If it is an expression, the name is pre-analyzed in the caller.\n       --  If it it of a controlled type we need a block for the finalization\n       --  actions. As for loop bounds that need finalization, we create a\n       --  declaration and an assignment to trigger these actions.\n \n-      if Present (Etype (Container))\n-        and then Is_Controlled (Etype (Container))\n-        and then not Is_Entity_Name (Container)\n+      if Present (Etype (Iter_Name))\n+        and then Is_Controlled (Etype (Iter_Name))\n+        and then not Is_Entity_Name (Iter_Name)\n       then\n          declare\n-            Id : constant Entity_Id := Make_Temporary (Loc, 'R', Container);\n+            Id : constant Entity_Id := Make_Temporary (Loc, 'R', Iter_Name);\n \n             Decl   : Node_Id;\n-            Assign : Node_Id;\n \n          begin\n-            Typ := Etype (Container);\n+            Typ := Etype (Iter_Name);\n \n             Decl :=\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => Id,\n-                Object_Definition   => New_Occurrence_Of (Typ, Loc));\n-\n-            Assign :=\n-              Make_Assignment_Statement (Loc,\n-                Name        => New_Occurrence_Of (Id, Loc),\n-                Expression  => Relocate_Node (Container));\n-\n-            Insert_Actions (Parent (N), New_List (Decl, Assign));\n+                Object_Definition   => New_Occurrence_Of (Typ, Loc),\n+                Expression          => Relocate_Node (Iter_Name));\n+\n+            Insert_Actions\n+              (Parent (Parent (N)), New_List (Decl));\n+            Rewrite (Name (N), New_Occurrence_Of (Id, Loc));\n+            Set_Etype (Id, Typ);\n+            Set_Etype (Name (N), Typ);\n          end;\n \n       else\n \n-         --  Container is an entity or an array with uncontrolled components\n+         --  Container is an entity or an array with uncontrolled components,\n+         --  or else it is a container iterator given by a function call,\n+         --  typically called Iterate in the case of predefined containers,\n+         --  even though Iterate is not a reserved name. What matter is that\n+         --  the return type of the function is an iterator type.\n+\n+         Analyze (Iter_Name);\n+         if Nkind (Iter_Name) = N_Function_Call then\n+            declare\n+               C  : constant Node_Id := Name (Iter_Name);\n+               I  : Interp_Index;\n+               It : Interp;\n+\n+            begin\n+               if not Is_Overloaded (Iter_Name) then\n+                  Resolve (Iter_Name, Etype (C));\n+\n+               else\n+                  Get_First_Interp (C, I, It);\n+                  while It.Typ /= Empty loop\n+                     if Reverse_Present (N) then\n+                        if Is_Reversible_Iterator (It.Typ) then\n+                           Resolve (Iter_Name, It.Typ);\n+                           exit;\n+                        end if;\n+\n+                     elsif Is_Iterator (It.Typ) then\n+                        Resolve (Iter_Name, It.Typ);\n+                        exit;\n+                     end if;\n \n-         Analyze_And_Resolve (Container);\n+                     Get_Next_Interp (I, It);\n+                  end loop;\n+               end if;\n+            end;\n+\n+         else\n+\n+            --  domain of iteration is not overloaded.\n+\n+            Resolve (Iter_Name, Etype (Iter_Name));\n+         end if;\n       end if;\n \n-      Typ := Etype (Container);\n+      Typ := Etype (Iter_Name);\n \n       if Is_Array_Type (Typ) then\n          if Of_Present (N) then\n@@ -2269,33 +2331,58 @@ package body Sem_Ch5 is\n             Set_Etype (Def_Id, Etype (First_Index (Typ)));\n          end if;\n \n+         --  Check for type error in iterator.\n+\n+      elsif Typ = Any_Type then\n+         return;\n+\n       --  Iteration over a container\n \n       else\n          Set_Ekind (Def_Id, E_Loop_Parameter);\n \n          if Of_Present (N) then\n+            --  If the container has already been rewritten as a\n+            --  call to the default iterator, nothing to do. This\n+            --  is the case with the expansion of a quantified\n+            --  expression.\n \n-            --  Find the Element_Type in the package instance that defines the\n-            --  container type.\n+            if Nkind (Name (N)) = N_Function_Call\n+              and then not Comes_From_Source (Name (N))\n+            then\n+               null;\n \n-            Ent := First_Entity (Scope (Base_Type (Typ)));\n-            while Present (Ent) loop\n-               if Chars (Ent) = Name_Element_Type then\n-                  Set_Etype (Def_Id, Ent);\n-                  exit;\n-               end if;\n+            elsif Expander_Active then\n \n-               Next_Entity (Ent);\n-            end loop;\n+               --  Find the Iterator_Element and the default_iterator\n+               --   of the container type.\n+\n+               Set_Etype (Def_Id,\n+                 Entity (\n+                   Find_Aspect (Typ, Aspect_Iterator_Element)));\n+\n+               declare\n+                  Default_Iter : constant Entity_Id :=\n+                    Find_Aspect (Typ, Aspect_Default_Iterator);\n+               begin\n+                  Rewrite (Name (N),\n+                    Make_Function_Call (Loc,\n+                      Name => Default_Iter,\n+                      Parameter_Associations =>\n+                        New_List (Relocate_Node (Iter_Name))));\n+                  Analyze_And_Resolve (Name (N));\n+               end;\n+            end if;\n \n          else\n-            --  Find the Cursor type in similar fashion\n+            --  result type of Iterate function is the classwide\n+            --  type of the interface parent. We need the specific\n+            --  Cursor type defined in the package.\n \n-            Ent := First_Entity (Scope (Base_Type (Typ)));\n+            Ent := First_Entity (Scope (Typ));\n             while Present (Ent) loop\n                if Chars (Ent) = Name_Cursor then\n-                  Set_Etype (Def_Id, Ent);\n+                  Set_Etype (Def_Id, Etype (Ent));\n                   exit;\n                end if;\n "}, {"sha": "4c196669ccf84791835370da48156652edf86713", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -9749,12 +9749,13 @@ package body Sem_Ch6 is\n          if AS_Needed then\n             if Nkind (N) = N_Accept_Statement then\n \n-               --  If expansion is active, The formal is replaced by a local\n+               --  If expansion is active, the formal is replaced by a local\n                --  variable that renames the corresponding entry of the\n                --  parameter block, and it is this local variable that may\n-               --  require an actual subtype.\n+               --  require an actual subtype. In ALFA mode, expansion of accept\n+               --  statements is skipped.\n \n-               if Expander_Active then\n+               if Expander_Active and not ALFA_Mode then\n                   Decl := Build_Actual_Subtype (T, Renamed_Object (Formal));\n                else\n                   Decl := Build_Actual_Subtype (T, Formal);\n@@ -9794,6 +9795,7 @@ package body Sem_Ch6 is\n \n             if Nkind (N) = N_Accept_Statement\n               and then Expander_Active\n+              and then not ALFA_Mode\n             then\n                Set_Actual_Subtype (Renamed_Object (Formal),\n                  Defining_Identifier (Decl));"}, {"sha": "2b40b63baf3cfddb268cb1ae352211700f8b83e1", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -12472,21 +12472,56 @@ package body Sem_Util is\n \n    function Unique_Defining_Entity (N : Node_Id) return Entity_Id is\n    begin\n-      case Nkind (N) is\n-         when N_Package_Body =>\n-            return Corresponding_Spec (N);\n+      return Unique_Entity (Defining_Entity (N));\n+   end Unique_Defining_Entity;\n+\n+   -------------------\n+   -- Unique_Entity --\n+   -------------------\n+\n+   function Unique_Entity (E : Entity_Id) return Entity_Id is\n+      U : Entity_Id := E;\n+      P : Node_Id;\n+\n+   begin\n+      case Ekind (E) is\n+         when Type_Kind =>\n+            if Present (Full_View (E)) then\n+               U := Full_View (E);\n+            end if;\n+\n+         when E_Package_Body =>\n+            P := Parent (E);\n+\n+            if Nkind (P) = N_Defining_Program_Unit_Name then\n+               P := Parent (P);\n+            end if;\n+\n+            U := Corresponding_Spec (P);\n+\n+         when E_Subprogram_Body =>\n+            P := Parent (E);\n \n-         when N_Subprogram_Body =>\n-            if Acts_As_Spec (N) then\n-               return Defining_Entity (N);\n+            if Nkind (P) = N_Defining_Program_Unit_Name then\n+               P := Parent (P);\n+            end if;\n+\n+            P := Parent (P);\n+\n+            if Nkind (P) = N_Subprogram_Body_Stub then\n+               if Present (Library_Unit (P)) then\n+                  U := Get_Body_From_Stub (P);\n+               end if;\n             else\n-               return Corresponding_Spec (N);\n+               U := Corresponding_Spec (P);\n             end if;\n \n          when others =>\n-            return Defining_Entity (N);\n+            null;\n       end case;\n-   end Unique_Defining_Entity;\n+\n+      return U;\n+   end Unique_Entity;\n \n    -----------------\n    -- Unique_Name --"}, {"sha": "7acc4345757f5ee3fb6a8bf664f1f7709211a7c7", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -1421,8 +1421,16 @@ package Sem_Util is\n    --  specified we check only for the given stream operation.\n \n    function Unique_Defining_Entity (N : Node_Id) return Entity_Id;\n-   --  Return the entity which represents declaration N, so that matching\n-   --  declaration and body have the same entity.\n+   --  Return the entity which represents declaration N, so that different\n+   --  views of the same entity have the same unique defining entity:\n+   --  * package spec and body;\n+   --  * subprogram declaration, subprogram stub and subprogram body;\n+   --  * private view and full view of a type.\n+   --  In other cases, return the defining entity for N.\n+\n+   function Unique_Entity (E : Entity_Id) return Entity_Id;\n+   --  Return the unique entity for entity E, which would be returned by\n+   --  Unique_Defining_Entity if applied to the enclosing declaration of E.\n \n    function Unique_Name (E : Entity_Id) return String;\n    --  Return a unique name for entity E, which could be used to identify E"}, {"sha": "3c45d78939080b888e0869d4140fe4dd34a03af0", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -2709,7 +2709,12 @@ package body Sprint is\n                Write_Str (\" some \");\n             end if;\n \n-            Sprint_Node (Loop_Parameter_Specification (Node));\n+            if Present (Iterator_Specification (Node)) then\n+               Sprint_Node (Iterator_Specification (Node));\n+            else\n+               Sprint_Node (Loop_Parameter_Specification (Node));\n+            end if;\n+\n             Write_Str (\" => \");\n             Sprint_Node (Condition (Node));\n "}, {"sha": "c9411e13e38df58381624124e13bf63595fc0e3f", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -263,11 +263,40 @@ package body Treepr is\n    -- pn --\n    --------\n \n-   procedure pn (N : Node_Id) is\n+   procedure pn (N : Union_Id) is\n    begin\n-      Print_Tree_Node (N);\n+      case N is\n+         when List_Low_Bound .. List_High_Bound - 1 =>\n+            pl (Int (N));\n+         when Node_Range =>\n+            Print_Tree_Node (Node_Id (N));\n+         when Elist_Range =>\n+            Print_Tree_Elist (Elist_Id (N));\n+         when Elmt_Range =>\n+            raise Program_Error;\n+         when Names_Range =>\n+            Namet.wn (Name_Id (N));\n+         when Strings_Range =>\n+            Write_String_Table_Entry (String_Id (N));\n+         when Uint_Range =>\n+            Uintp.pid (From_Union (N));\n+         when Ureal_Range =>\n+            Urealp.pr (From_Union (N));\n+         when others =>\n+            Write_Str (\"Invalid Union_Id: \");\n+            Write_Int (Int (N));\n+      end case;\n    end pn;\n \n+   --------\n+   -- pp --\n+   --------\n+\n+   procedure pp (N : Union_Id) is\n+   begin\n+      pn (N);\n+   end pp;\n+\n    ----------------\n    -- Print_Char --\n    ----------------\n@@ -1471,6 +1500,15 @@ package body Treepr is\n       Print_Node_Subtree (N);\n    end pt;\n \n+   ---------\n+   -- ppp --\n+   ---------\n+\n+   procedure ppp (N : Node_Id) is\n+   begin\n+      pt (N);\n+   end ppp;\n+\n    -------------------\n    -- Serial_Number --\n    -------------------"}, {"sha": "683eb0db90bb514a363126a2a0cfd1dd4547dfea", "filename": "gcc/ada/treepr.ads", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Ftreepr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57a8057af4d9cafef111626b162b9ce2b096d63f/gcc%2Fada%2Ftreepr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.ads?ref=57a8057af4d9cafef111626b162b9ce2b096d63f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -57,25 +57,36 @@ package Treepr is\n    --  Prints the subtree consisting of the given element list and all its\n    --  referenced descendants.\n \n+   --  The following debugging procedures are intended to be called from gdb\n+\n+   procedure pp (N : Union_Id);\n+   pragma Export (Ada, pp);\n+   --  Prints a node, node list, uint, or anything else that falls under\n+   --  Union_Id.\n+\n+   procedure ppp (N : Node_Id);\n+   pragma Export (Ada, ppp);\n+   --  Same as Print_Node_Subtree\n+\n+   --  The following are no longer needed; you can use pp or ppp instead\n+\n    procedure pe (E : Elist_Id);\n    pragma Export (Ada, pe);\n-   --  Debugging procedure (to be called within gdb), same as Print_Tree_Elist\n+   --  Same as Print_Tree_Elist\n \n    procedure pl (L : Int);\n    pragma Export (Ada, pl);\n-   --  Debugging procedure (to be called within gdb), same as Print_Tree_List,\n-   --  except that you can use e.g. 66 instead of -99999966. In other words\n-   --  for the positive case we fill out to 8 digits on the left and add a\n-   --  minus sign. This just saves some typing in the debugger.\n+   --  Same as Print_Tree_List, except that you can use e.g. 66 instead of\n+   --  -99999966. In other words for the positive case we fill out to 8 digits\n+   --  on the left and add a minus sign. This just saves some typing in the\n+   --  debugger.\n \n-   procedure pn (N : Node_Id);\n+   procedure pn (N : Union_Id);\n    pragma Export (Ada, pn);\n-   --  Debugging procedure (to be called within gdb)\n-   --  same as Print_Tree_Node with Label = \"\"\n+   --  Same as pp\n \n    procedure pt (N : Node_Id);\n    pragma Export (Ada, pt);\n-   --  Debugging procedure (to be called within gdb)\n-   --  same as Print_Node_Subtree\n+   --  Same as ppp\n \n end Treepr;"}]}