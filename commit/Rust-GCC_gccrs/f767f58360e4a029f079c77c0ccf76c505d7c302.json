{"sha": "f767f58360e4a029f079c77c0ccf76c505d7c302", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc2N2Y1ODM2MGU0YTAyOWYwNzljNzdjMGNjZjc2YzUwNWQ3YzMwMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2015-06-29T14:35:19Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2015-06-29T14:35:19Z"}, "message": "i386: Implement asm flag outputs\n\n        * config/i386/constraints.md (Bf): New constraint.\n        * config/i386/i386-c.c (ix86_target_macros): Define\n        __GCC_ASM_FLAG_OUTPUTS__.\n        * config/i386/i386.c (ix86_md_asm_adjust): Handle =@cc* constraints\n        as flags outputs.\n        * doc/extend.texi (FlagOutputOperands): Document them.\ntestsuite/\n        * gcc.target/i386/asm-flag-1.c: New.\n        * gcc.target/i386/asm-flag-2.c: New.\n        * gcc.target/i386/asm-flag-3.c: New.\n        * gcc.target/i386/asm-flag-4.c: New.\n        * gcc.target/i386/asm-flag-5.c: New.\n\nFrom-SVN: r225122", "tree": {"sha": "2fcec776a565f4e7af84a254c59a81a44a678ac2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fcec776a565f4e7af84a254c59a81a44a678ac2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f767f58360e4a029f079c77c0ccf76c505d7c302", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f767f58360e4a029f079c77c0ccf76c505d7c302", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f767f58360e4a029f079c77c0ccf76c505d7c302", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f767f58360e4a029f079c77c0ccf76c505d7c302/comments", "author": null, "committer": null, "parents": [{"sha": "8fd17b982de905b1d564b9be985ecaacbc6c635f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fd17b982de905b1d564b9be985ecaacbc6c635f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fd17b982de905b1d564b9be985ecaacbc6c635f"}], "stats": {"total": 359, "additions": 352, "deletions": 7}, "files": [{"sha": "b07930194226250a0d1090161db2592a9c671d34", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f767f58360e4a029f079c77c0ccf76c505d7c302", "patch": "@@ -1,3 +1,12 @@\n+2015-06-29  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/constraints.md (Bf): New constraint.\n+\t* config/i386/i386-c.c (ix86_target_macros): Define\n+\t__GCC_ASM_FLAG_OUTPUTS__.\n+\t* config/i386/i386.c (ix86_md_asm_adjust): Handle =@cc* constraints\n+\tas flags outputs.\n+\t* doc/extend.texi (FlagOutputOperands): Document them.\n+\n 2015-06-29  Jiong Wang  <jiong.wang@arm.com>\n \n \t* config/arch64/aarch64.md (UNSPEC_TLSLE): New enumeration."}, {"sha": "2861d8dfdd2af189f94fbf36320709bf3007c9f0", "filename": "gcc/config/i386/constraints.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Fconfig%2Fi386%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Fconfig%2Fi386%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fconstraints.md?ref=f767f58360e4a029f079c77c0ccf76c505d7c302", "patch": "@@ -146,11 +146,16 @@\n  \"@internal Lower SSE register when avoiding REX prefix and all SSE registers otherwise.\")\n \n ;; We use the B prefix to denote any number of internal operands:\n+;;  f  FLAGS_REG\n ;;  g  GOT memory operand.\n ;;  s  Sibcall memory operand, not valid for TARGET_X32\n ;;  w  Call memory operand, not valid for TARGET_X32\n ;;  z  Constant call address operand.\n \n+(define_constraint \"Bf\"\n+  \"@internal Flags register operand.\"\n+  (match_operand 0 \"flags_reg_operand\"))\n+\n (define_constraint \"Bg\"\n   \"@internal GOT memory operand.\"\n   (match_operand 0 \"GOT_memory_operand\"))"}, {"sha": "d5063457b904de77288a2137709131c5fe566a15", "filename": "gcc/config/i386/i386-c.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Fconfig%2Fi386%2Fi386-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Fconfig%2Fi386%2Fi386-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.c?ref=f767f58360e4a029f079c77c0ccf76c505d7c302", "patch": "@@ -560,6 +560,8 @@ ix86_target_macros (void)\n   cpp_define_formatted (parse_in, \"__ATOMIC_HLE_ACQUIRE=%d\", IX86_HLE_ACQUIRE);\n   cpp_define_formatted (parse_in, \"__ATOMIC_HLE_RELEASE=%d\", IX86_HLE_RELEASE);\n \n+  cpp_define (parse_in, \"__GCC_ASM_FLAG_OUTPUTS__\");\n+\n   ix86_target_macros_internal (ix86_isa_flags,\n \t\t\t       ix86_arch,\n \t\t\t       ix86_tune,"}, {"sha": "144c1a6fd67f5476cd04597c4c592080dccd6247", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 130, "deletions": 7, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f767f58360e4a029f079c77c0ccf76c505d7c302", "patch": "@@ -45555,21 +45555,144 @@ ix86_c_mode_for_suffix (char suffix)\n \n /* Worker function for TARGET_MD_ASM_ADJUST.\n \n-   We do this in the new i386 backend to maintain source compatibility\n+   We implement asm flag outputs, and maintain source compatibility\n    with the old cc0-based compiler.  */\n \n static rtx_insn *\n-ix86_md_asm_adjust (vec<rtx> &/*outputs*/, vec<rtx> &/*inputs*/,\n-\t\t    vec<const char *> &/*constraints*/,\n+ix86_md_asm_adjust (vec<rtx> &outputs, vec<rtx> &/*inputs*/,\n+\t\t    vec<const char *> &constraints,\n \t\t    vec<rtx> &clobbers, HARD_REG_SET &clobbered_regs)\n {\n-  clobbers.safe_push (gen_rtx_REG (CCmode, FLAGS_REG));\n   clobbers.safe_push (gen_rtx_REG (CCFPmode, FPSR_REG));\n-\n-  SET_HARD_REG_BIT (clobbered_regs, FLAGS_REG);\n   SET_HARD_REG_BIT (clobbered_regs, FPSR_REG);\n \n-  return NULL;\n+  bool saw_asm_flag = false;\n+\n+  start_sequence ();\n+  for (unsigned i = 0, n = outputs.length (); i < n; ++i)\n+    {\n+      const char *con = constraints[i];\n+      if (strncmp (con, \"=@cc\", 4) != 0)\n+\tcontinue;\n+      con += 4;\n+      if (strchr (con, ',') != NULL)\n+\t{\n+\t  error (\"alternatives not allowed in asm flag output\");\n+\t  continue;\n+\t}\n+\n+      bool invert = false;\n+      if (con[0] == 'n')\n+\tinvert = true, con++;\n+\n+      machine_mode mode = CCmode;\n+      rtx_code code = UNKNOWN;\n+\n+      switch (con[0])\n+\t{\n+\tcase 'a':\n+\t  if (con[1] == 0)\n+\t    mode = CCAmode, code = EQ;\n+\t  else if (con[1] == 'e' && con[2] == 0)\n+\t    mode = CCCmode, code = EQ;\n+\t  break;\n+\tcase 'b':\n+\t  if (con[1] == 0)\n+\t    mode = CCCmode, code = EQ;\n+\t  else if (con[1] == 'e' && con[2] == 0)\n+\t    mode = CCAmode, code = NE;\n+\t  break;\n+\tcase 'c':\n+\t  if (con[1] == 0)\n+\t    mode = CCCmode, code = EQ;\n+\t  break;\n+\tcase 'e':\n+\t  if (con[1] == 0)\n+\t    mode = CCZmode, code = EQ;\n+\t  break;\n+\tcase 'g':\n+\t  if (con[1] == 0)\n+\t    mode = CCGCmode, code = GT;\n+\t  else if (con[1] == 'e' && con[2] == 0)\n+\t    mode = CCGCmode, code = GE;\n+\t  break;\n+\tcase 'l':\n+\t  if (con[1] == 0)\n+\t    mode = CCGCmode, code = LT;\n+\t  else if (con[1] == 'e' && con[2] == 0)\n+\t    mode = CCGCmode, code = LE;\n+\t  break;\n+\tcase 'o':\n+\t  if (con[1] == 0)\n+\t    mode = CCOmode, code = EQ;\n+\t  break;\n+\tcase 'p':\n+\t  if (con[1] == 0)\n+\t    mode = CCPmode, code = EQ;\n+\t  break;\n+\tcase 's':\n+\t  if (con[1] == 0)\n+\t    mode = CCSmode, code = EQ;\n+\t  break;\n+\tcase 'z':\n+\t  if (con[1] == 0)\n+\t    mode = CCZmode, code = EQ;\n+\t  break;\n+\t}\n+      if (code == UNKNOWN)\n+\t{\n+\t  error (\"unknown asm flag output %qs\", constraints[i]);\n+\t  continue;\n+\t}\n+      if (invert)\n+\tcode = reverse_condition (code);\n+\n+      rtx dest = outputs[i];\n+      if (!saw_asm_flag)\n+\t{\n+\t  /* This is the first asm flag output.  Here we put the flags\n+\t     register in as the real output and adjust the condition to\n+\t     allow it.  */\n+\t  constraints[i] = \"=Bf\";\n+\t  outputs[i] = gen_rtx_REG (CCmode, FLAGS_REG);\n+\t  saw_asm_flag = true;\n+\t}\n+      else\n+\t{\n+\t  /* We don't need the flags register as output twice.  */\n+\t  constraints[i] = \"=X\";\n+\t  outputs[i] = gen_rtx_SCRATCH (SImode);\n+\t}\n+\n+      rtx x = gen_rtx_REG (mode, FLAGS_REG);\n+      x = gen_rtx_fmt_ee (code, QImode, x, const0_rtx);\n+\n+      machine_mode dest_mode = GET_MODE (dest);\n+      if (!SCALAR_INT_MODE_P (dest_mode))\n+\t{\n+\t  error (\"invalid type for asm flag output\");\n+\t  continue;\n+\t}\n+      if (dest_mode != QImode)\n+\t{\n+\t  rtx destqi = gen_reg_rtx (QImode);\n+\t  emit_insn (gen_rtx_SET (destqi, x));\n+\t  x = gen_rtx_ZERO_EXTEND (dest_mode, destqi);\n+\t}\n+      emit_insn (gen_rtx_SET (dest, x));\n+    }\n+  rtx_insn *seq = get_insns ();\n+  end_sequence ();\n+\n+  if (saw_asm_flag)\n+    return seq;\n+  else\n+    {\n+      /* If we had no asm flag outputs, clobber the flags.  */\n+      clobbers.safe_push (gen_rtx_REG (CCmode, FLAGS_REG));\n+      SET_HARD_REG_BIT (clobbered_regs, FLAGS_REG);\n+      return NULL;\n+    }\n }\n \n /* Implements target vector targetm.asm.encode_section_info.  */"}, {"sha": "bb858a84f96052b8df55fe00b5903ab4744d26a2", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=f767f58360e4a029f079c77c0ccf76c505d7c302", "patch": "@@ -7683,6 +7683,84 @@ pointed to by @code{e}\n in a register, you can enable it to choose the best location\n for @code{d} by specifying both constraints.\n \n+@anchor{FlagOutputOperands}\n+@subsection Flag Output Operands\n+@cindex @code{asm} flag output operands\n+\n+Some targets have a special register that holds the ``flags'' for the\n+result of an operation or comparison.  Normally, the contents of that\n+register are either unmodifed by the asm, or the asm is considered to\n+clobber the contents.\n+\n+On some targets, a special form of output operand exists by which\n+conditions in the flags register may be outputs of the asm.  The set of\n+conditions supported are target specific, but the general rule is that\n+the output variable must be a scalar integer, and the value will be boolean.\n+When supported, the target will define the preprocessor symbol\n+@code{__GCC_ASM_FLAG_OUTPUTS__}.\n+\n+Because of the special nature of the flag output operands, the constraint\n+may not include alternatives.\n+\n+Most often, the target has only one flags register, and thus is an implied\n+operand of many instructions.  In this case, the operand should not be\n+referenced within the assembler template via @code{%0} etc, as there's\n+no corresponding text in the assembly language.\n+\n+@table @asis\n+@item x86 family\n+The flag output constraints for the x86 family are of the form\n+@samp{=@@cc@var{cond}} where @var{cond} is one of the standard\n+conditions defined in the ISA manual for @code{j@var{cc}} or\n+@code{set@var{cc}}.\n+\n+@table @code\n+@item a\n+``above'' or unsigned greater than\n+@item ae\n+``above or equal'' or unsigned greater than or equal\n+@item b\n+``below'' or unsigned less than\n+@item be\n+``below or equal'' or unsigned less than or equal\n+@item c\n+carry flag set\n+@item e\n+@itemx z\n+``equal'' or zero flag set\n+@item g\n+signed greater than\n+@item ge\n+signed greater than or equal\n+@item l\n+signed less than\n+@item le\n+signed less than or equal\n+@item o\n+overflow flag set\n+@item p\n+parity flag set\n+@item s\n+sign flag set\n+@item na\n+@itemx nae\n+@itemx nb\n+@itemx nbe\n+@itemx nc\n+@itemx ne\n+@itemx ng\n+@itemx nge\n+@itemx nl\n+@itemx nle\n+@itemx no\n+@itemx np\n+@itemx ns\n+@itemx nz\n+``not'' @var{flag}, or inverted versions of those above\n+@end table\n+\n+@end table\n+\n @anchor{InputOperands}\n @subsubsection Input Operands\n @cindex @code{asm} input operands"}, {"sha": "3163ba6305e83d24b8a5e41e02d59d09741ce243", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f767f58360e4a029f079c77c0ccf76c505d7c302", "patch": "@@ -1,3 +1,11 @@\n+2015-06-29  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc.target/i386/asm-flag-1.c: New.\n+\t* gcc.target/i386/asm-flag-2.c: New.\n+\t* gcc.target/i386/asm-flag-3.c: New.\n+\t* gcc.target/i386/asm-flag-4.c: New.\n+\t* gcc.target/i386/asm-flag-5.c: New.\n+\n 2015-06-29  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/66322"}, {"sha": "b0c05239b013ba3a10d6b2612ec106d731f4f2ec", "filename": "gcc/testsuite/gcc.target/i386/asm-flag-0.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-flag-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-flag-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-flag-0.c?ref=f767f58360e4a029f079c77c0ccf76c505d7c302", "patch": "@@ -0,0 +1,15 @@\n+/* Test error conditions of asm flag outputs.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+void a(void)\n+{\n+  char x;\n+  asm(\"\" : \"=@cca,@ccc\"(x));  /* { dg-error \"alternatives not allowed\" } */\n+}\n+\n+void b(void)\n+{\n+  char x;\n+  asm(\"\" : \"=@ccbad\"(x)); /* { dg-error \"unknown asm flag output\" } */\n+}"}, {"sha": "bcc4952239caf75310d650180bc957446fca31c9", "filename": "gcc/testsuite/gcc.target/i386/asm-flag-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-flag-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-flag-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-flag-1.c?ref=f767f58360e4a029f079c77c0ccf76c505d7c302", "patch": "@@ -0,0 +1,18 @@\n+/* Test some of the valid @cc<cc> asm flag outputs.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+\n+void f(char *out)\n+{\n+  asm(\"\" : \"=@cca\"(out[0]), \"=@ccc\"(out[1]), \"=@cce\"(out[2]),\n+           \"=@ccg\"(out[3]), \"=@cco\"(out[4]), \"=@ccp\"(out[5]),\n+           \"=@ccs\"(out[6]));\n+}\n+\n+/* { dg-final { scan-assembler \"seta\" } } */\n+/* { dg-final { scan-assembler \"setc\" } } */\n+/* { dg-final { scan-assembler \"sete\" } } */\n+/* { dg-final { scan-assembler \"setg\" } } */\n+/* { dg-final { scan-assembler \"seto\" } } */\n+/* { dg-final { scan-assembler \"setp\" } } */\n+/* { dg-final { scan-assembler \"sets\" } } */"}, {"sha": "5f8fa13da9888c6cad05bd210562ff540ddbf0d3", "filename": "gcc/testsuite/gcc.target/i386/asm-flag-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-flag-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-flag-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-flag-2.c?ref=f767f58360e4a029f079c77c0ccf76c505d7c302", "patch": "@@ -0,0 +1,16 @@\n+/* Test some of the valid @cc<cc> asm flag outputs.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+\n+void f(char *out)\n+{\n+  asm(\"\" : \"=@ccb\"(out[0]), \"=@ccl\"(out[1]), \"=@ccz\"(out[2]),\n+           \"=@ccbe\"(out[4]), \"=@ccge\"(out[5]), \"=@ccle\"(out[6]));\n+}\n+\n+/* { dg-final { scan-assembler \"setc\" } } */\n+/* { dg-final { scan-assembler \"setl\" } } */\n+/* { dg-final { scan-assembler \"sete\" } } */\n+/* { dg-final { scan-assembler \"setna\" } } */\n+/* { dg-final { scan-assembler \"setge\" } } */\n+/* { dg-final { scan-assembler \"setle\" } } */"}, {"sha": "220c07cb8679db5e2abbd12689a76c7351df6ef1", "filename": "gcc/testsuite/gcc.target/i386/asm-flag-3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-flag-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-flag-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-flag-3.c?ref=f767f58360e4a029f079c77c0ccf76c505d7c302", "patch": "@@ -0,0 +1,22 @@\n+/* Test some of the valid @cc<cc> asm flag outputs.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+\n+#define DO(C) \\\n+void f##C(int *y) { char x; asm(\"\" : \"=@cc\"#C(x)); if (!x) *y = 0; }\n+\n+DO(a)\n+DO(c)\n+DO(e)\n+DO(g)\n+DO(o)\n+DO(p)\n+DO(s)\n+\n+/* { dg-final { scan-assembler \"ja\" } } */\n+/* { dg-final { scan-assembler \"jc\" } } */\n+/* { dg-final { scan-assembler \"je\" } } */\n+/* { dg-final { scan-assembler \"jg\" } } */\n+/* { dg-final { scan-assembler \"jo\" } } */\n+/* { dg-final { scan-assembler \"jp\" } } */\n+/* { dg-final { scan-assembler \"js\" } } */"}, {"sha": "b84b7dfdb1c4b347c593c6fbebbaef769f4efd1a", "filename": "gcc/testsuite/gcc.target/i386/asm-flag-4.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-flag-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-flag-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-flag-4.c?ref=f767f58360e4a029f079c77c0ccf76c505d7c302", "patch": "@@ -0,0 +1,20 @@\n+/* Test some of the valid @cc<cc> asm flag outputs.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+\n+#define DO(C) \\\n+void f##C(int *y) { char x; asm(\"\" : \"=@cc\"#C(x)); if (!x) *y = 0; }\n+\n+DO(b)\n+DO(l)\n+DO(z)\n+DO(be)\n+DO(ge)\n+DO(le)\n+\n+/* { dg-final { scan-assembler \"jc\" } } */\n+/* { dg-final { scan-assembler \"jl\" } } */\n+/* { dg-final { scan-assembler \"je\" } } */\n+/* { dg-final { scan-assembler \"jna\" } } */\n+/* { dg-final { scan-assembler \"jge\" } } */\n+/* { dg-final { scan-assembler \"jle\" } } */"}, {"sha": "151157daf416543eaba5999ea40c0f56d8be4659", "filename": "gcc/testsuite/gcc.target/i386/asm-flag-5.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-flag-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f767f58360e4a029f079c77c0ccf76c505d7c302/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-flag-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-flag-5.c?ref=f767f58360e4a029f079c77c0ccf76c505d7c302", "patch": "@@ -0,0 +1,29 @@\n+/* Test error conditions of asm flag outputs.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+void f_B(void) { _Bool x; asm(\"\" : \"=@ccc\"(x)); }\n+void f_c(void) { char x; asm(\"\" : \"=@ccc\"(x)); }\n+void f_s(void) { short x; asm(\"\" : \"=@ccc\"(x)); }\n+void f_i(void) { int x; asm(\"\" : \"=@ccc\"(x)); }\n+void f_l(void) { long x; asm(\"\" : \"=@ccc\"(x)); }\n+\n+void f_f(void)\n+{\n+  float x;\n+  asm(\"\" : \"=@ccc\"(x)); /* { dg-error invalid type } */\n+}\n+\n+void f_d(void)\n+{\n+  double x;\n+  asm(\"\" : \"=@ccc\"(x)); /* { dg-error invalid type } */\n+}\n+\n+struct S { int x[3]; };\n+\n+void f_S(void)\n+{\n+  struct S x;\n+  asm(\"\" : \"=@ccc\"(x)); /* { dg-error invalid type } */\n+}"}]}