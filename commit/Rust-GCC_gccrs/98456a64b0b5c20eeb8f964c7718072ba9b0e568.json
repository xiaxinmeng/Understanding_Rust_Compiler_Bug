{"sha": "98456a64b0b5c20eeb8f964c7718072ba9b0e568", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg0NTZhNjRiMGI1YzIwZWViOGY5NjRjNzcxODA3MmJhOWIwZTU2OA==", "commit": {"author": {"name": "Jose E. Marchesi", "email": "jose.marchesi@oracle.com", "date": "2020-05-19T09:46:40Z"}, "committer": {"name": "Jose E. Marchesi", "email": "jose.marchesi@oracle.com", "date": "2020-05-19T09:46:40Z"}, "message": "bpf: do not save/restore callee-saved registers in function prolog/epilog\n\nBPF considers that every call to a function allocates a fresh set of\nregisters that are available to the callee, of which the first five\nmay have bee initialized with the function arguments.  This is\nimplemented by both interpreter and JIT in the Linux kernel.\n\nThis is enforced by the kernel BPF verifier, which will reject any\ncode in which non-initialized registers are accessed before being\nwritten.  Consequently, the spill instructions generated in function\nprologue were causing the verifier to reject our compiled programs.\n\nThis patch makes GCC to not save/restore callee-saved registers in\nfunction prologue/epilogue, unless xBPF mode is enabled.\n\n2020-05-19  Jose E. Marchesi  <jose.marchesi@oracle.com>\n\ngcc/\n\t* config/bpf/bpf.c (bpf_compute_frame_layout): Include space for\n\tcallee saved registers only in xBPF.\n\t(bpf_expand_prologue): Save callee saved registers only in xBPF.\n\t(bpf_expand_epilogue): Likewise for restoring.\n\t* doc/invoke.texi (eBPF Options): Document this is activated by\n\t-mxbpf.\n\ngcc/testsuite/\n\t* gcc.target/bpf/xbpf-callee-saved-regs-1.c: New test.\n\t* gcc.target/bpf/xbpf-callee-saved-regs-2.c: Likewise.", "tree": {"sha": "3d36b779e491302a4e2072b5fec294e59c9c1b37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d36b779e491302a4e2072b5fec294e59c9c1b37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98456a64b0b5c20eeb8f964c7718072ba9b0e568", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98456a64b0b5c20eeb8f964c7718072ba9b0e568", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98456a64b0b5c20eeb8f964c7718072ba9b0e568", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98456a64b0b5c20eeb8f964c7718072ba9b0e568/comments", "author": {"login": "jemarch", "id": 7061875, "node_id": "MDQ6VXNlcjcwNjE4NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jemarch", "html_url": "https://github.com/jemarch", "followers_url": "https://api.github.com/users/jemarch/followers", "following_url": "https://api.github.com/users/jemarch/following{/other_user}", "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions", "organizations_url": "https://api.github.com/users/jemarch/orgs", "repos_url": "https://api.github.com/users/jemarch/repos", "events_url": "https://api.github.com/users/jemarch/events{/privacy}", "received_events_url": "https://api.github.com/users/jemarch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jemarch", "id": 7061875, "node_id": "MDQ6VXNlcjcwNjE4NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jemarch", "html_url": "https://github.com/jemarch", "followers_url": "https://api.github.com/users/jemarch/followers", "following_url": "https://api.github.com/users/jemarch/following{/other_user}", "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions", "organizations_url": "https://api.github.com/users/jemarch/orgs", "repos_url": "https://api.github.com/users/jemarch/repos", "events_url": "https://api.github.com/users/jemarch/events{/privacy}", "received_events_url": "https://api.github.com/users/jemarch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51e10276d6792f67f1d88d90f299e7ac1b1f1f24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51e10276d6792f67f1d88d90f299e7ac1b1f1f24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51e10276d6792f67f1d88d90f299e7ac1b1f1f24"}], "stats": {"total": 187, "additions": 129, "deletions": 58}, "files": [{"sha": "8447bd56d98a21360b4f31e61b1b479b8c4705b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98456a64b0b5c20eeb8f964c7718072ba9b0e568/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98456a64b0b5c20eeb8f964c7718072ba9b0e568/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98456a64b0b5c20eeb8f964c7718072ba9b0e568", "patch": "@@ -1,3 +1,12 @@\n+2020-05-19  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* config/bpf/bpf.c (bpf_compute_frame_layout): Include space for\n+\tcallee saved registers only in xBPF.\n+\t(bpf_expand_prologue): Save callee saved registers only in xBPF.\n+\t(bpf_expand_epilogue): Likewise for restoring.\n+\t* doc/invoke.texi (eBPF Options): Document this is activated by\n+\t-mxbpf.\n+\n 2020-05-19  Jose E. Marchesi  <jose.marchesi@oracle.com>\n \n \t* config/bpf/bpf.opt (mxbpf): New option."}, {"sha": "36e08338630a459fdd4d8e4dc0a78b21ed3a5c21", "filename": "gcc/config/bpf/bpf.c", "status": "modified", "additions": 76, "deletions": 57, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98456a64b0b5c20eeb8f964c7718072ba9b0e568/gcc%2Fconfig%2Fbpf%2Fbpf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98456a64b0b5c20eeb8f964c7718072ba9b0e568/gcc%2Fconfig%2Fbpf%2Fbpf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fbpf.c?ref=98456a64b0b5c20eeb8f964c7718072ba9b0e568", "patch": "@@ -267,15 +267,18 @@ bpf_compute_frame_layout (void)\n \n   cfun->machine->local_vars_size += padding_locals;\n \n-  /* Set the space used in the stack by callee-saved used registers in\n-     the current function.  There is no need to round up, since the\n-     registers are all 8 bytes wide.  */\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if ((df_regs_ever_live_p (regno)\n-\t && !call_used_or_fixed_reg_p (regno))\n-\t|| (cfun->calls_alloca\n-\t    && regno == STACK_POINTER_REGNUM))\n-      cfun->machine->callee_saved_reg_size += 8;\n+  if (TARGET_XBPF)\n+    {\n+      /* Set the space used in the stack by callee-saved used\n+\t registers in the current function.  There is no need to round\n+\t up, since the registers are all 8 bytes wide.  */\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\tif ((df_regs_ever_live_p (regno)\n+\t     && !call_used_or_fixed_reg_p (regno))\n+\t    || (cfun->calls_alloca\n+\t\t&& regno == STACK_POINTER_REGNUM))\n+\t  cfun->machine->callee_saved_reg_size += 8;\n+    }\n \n   /* Check that the total size of the frame doesn't exceed the limit\n      imposed by eBPF.  */\n@@ -299,38 +302,50 @@ bpf_compute_frame_layout (void)\n void\n bpf_expand_prologue (void)\n {\n-  int regno, fp_offset;\n   rtx insn;\n   HOST_WIDE_INT size;\n \n   size = (cfun->machine->local_vars_size\n \t  + cfun->machine->callee_saved_reg_size);\n-  fp_offset = -cfun->machine->local_vars_size;\n \n-  /* Save callee-saved hard registes.  The register-save-area starts\n-     right after the local variables.  */\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+  /* The BPF \"hardware\" provides a fresh new set of registers for each\n+     called function, some of which are initialized to the values of\n+     the arguments passed in the first five registers.  In doing so,\n+     it saves the values of the registers of the caller, and restored\n+     them upon returning.  Therefore, there is no need to save the\n+     callee-saved registers here.  What is worse, the kernel\n+     implementation refuses to run programs in which registers are\n+     referred before being initialized.  */\n+  if (TARGET_XBPF)\n     {\n-      if ((df_regs_ever_live_p (regno)\n-\t   && !call_used_or_fixed_reg_p (regno))\n-\t  || (cfun->calls_alloca\n-\t      && regno == STACK_POINTER_REGNUM))\n-\t{\n-\t  rtx mem;\n+      int regno;\n+      int fp_offset = -cfun->machine->local_vars_size;\n \n-\t  if (!IN_RANGE (fp_offset, -1 - 0x7fff, 0x7fff))\n-\t    /* This has been already reported as an error in\n-\t       bpf_compute_frame_layout. */\n-\t    break;\n-\t  else\n+      /* Save callee-saved hard registes.  The register-save-area\n+\t starts right after the local variables.  */\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t{\n+\t  if ((df_regs_ever_live_p (regno)\n+\t       && !call_used_or_fixed_reg_p (regno))\n+\t      || (cfun->calls_alloca\n+\t\t  && regno == STACK_POINTER_REGNUM))\n \t    {\n-\t      mem = gen_frame_mem (DImode,\n-\t\t\t\t   plus_constant (DImode,\n-\t\t\t\t\t\t  hard_frame_pointer_rtx,\n-\t\t\t\t\t\t  fp_offset - 8));\n-\t      insn = emit_move_insn (mem, gen_rtx_REG (DImode, regno));\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t      fp_offset -= 8;\n+\t      rtx mem;\n+\n+\t      if (!IN_RANGE (fp_offset, -1 - 0x7fff, 0x7fff))\n+\t\t/* This has been already reported as an error in\n+\t\t   bpf_compute_frame_layout. */\n+\t\tbreak;\n+\t      else\n+\t\t{\n+\t\t  mem = gen_frame_mem (DImode,\n+\t\t\t\t       plus_constant (DImode,\n+\t\t\t\t\t\t      hard_frame_pointer_rtx,\n+\t\t\t\t\t\t      fp_offset - 8));\n+\t\t  insn = emit_move_insn (mem, gen_rtx_REG (DImode, regno));\n+\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t  fp_offset -= 8;\n+\t\t}\n \t    }\n \t}\n     }\n@@ -362,34 +377,38 @@ bpf_expand_prologue (void)\n void\n bpf_expand_epilogue (void)\n {\n-  int regno, fp_offset;\n-  rtx insn;\n-\n-  fp_offset = -cfun->machine->local_vars_size;\n-\n-  /* Restore callee-saved hard registes from the stack.  */\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+  /* See note in bpf_expand_prologue for an explanation on why we are\n+     not restoring callee-saved registers in BPF.  */\n+  if (TARGET_XBPF)\n     {\n-      if ((df_regs_ever_live_p (regno)\n-\t   && !call_used_or_fixed_reg_p (regno))\n-\t  || (cfun->calls_alloca\n-\t      && regno == STACK_POINTER_REGNUM))\n-\t{\n-\t  rtx mem;\n+      rtx insn;\n+      int regno;\n+      int fp_offset = -cfun->machine->local_vars_size;\n \n-\t  if (!IN_RANGE (fp_offset, -1 - 0x7fff, 0x7fff))\n-\t    /* This has been already reported as an error in\n-\t       bpf_compute_frame_layout. */\n-\t    break;\n-\t  else\n+      /* Restore callee-saved hard registes from the stack.  */\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t{\n+\t  if ((df_regs_ever_live_p (regno)\n+\t       && !call_used_or_fixed_reg_p (regno))\n+\t      || (cfun->calls_alloca\n+\t\t  && regno == STACK_POINTER_REGNUM))\n \t    {\n-\t      mem = gen_frame_mem (DImode,\n-\t\t\t\t   plus_constant (DImode,\n-\t\t\t\t\t\t  hard_frame_pointer_rtx,\n-\t\t\t\t\t\t  fp_offset - 8));\n-\t      insn = emit_move_insn (gen_rtx_REG (DImode, regno), mem);\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t      fp_offset -= 8;\n+\t      rtx mem;\n+\n+\t      if (!IN_RANGE (fp_offset, -1 - 0x7fff, 0x7fff))\n+\t\t/* This has been already reported as an error in\n+\t\t   bpf_compute_frame_layout. */\n+\t\tbreak;\n+\t      else\n+\t\t{\n+\t\t  mem = gen_frame_mem (DImode,\n+\t\t\t\t       plus_constant (DImode,\n+\t\t\t\t\t\t      hard_frame_pointer_rtx,\n+\t\t\t\t\t\t      fp_offset - 8));\n+\t\t  insn = emit_move_insn (gen_rtx_REG (DImode, regno), mem);\n+\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t  fp_offset -= 8;\n+\t\t}\n \t    }\n \t}\n     }"}, {"sha": "7217e27151d65135259bb49adf2ecc02d6ed67c3", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98456a64b0b5c20eeb8f964c7718072ba9b0e568/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98456a64b0b5c20eeb8f964c7718072ba9b0e568/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=98456a64b0b5c20eeb8f964c7718072ba9b0e568", "patch": "@@ -21016,7 +21016,11 @@ Generate code for a little-endian target.  This is the default.\n \n @item -mxbpf\n Generate code for an expanded version of BPF, which relaxes some of\n-the restrictions imposed by the BPF architecture.\n+the restrictions imposed by the BPF architecture:\n+@itemize @minus\n+@item Save and restore callee-saved registers at function entry and\n+exit, respectively.\n+@end itemize\n @end table\n \n @node FR30 Options"}, {"sha": "1fa18f2982aa5d72c03854e0eebb1511e7ec3948", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98456a64b0b5c20eeb8f964c7718072ba9b0e568/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98456a64b0b5c20eeb8f964c7718072ba9b0e568/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=98456a64b0b5c20eeb8f964c7718072ba9b0e568", "patch": "@@ -1,3 +1,8 @@\n+2020-05-19  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* gcc.target/bpf/xbpf-callee-saved-regs-1.c: New test.\n+\t* gcc.target/bpf/xbpf-callee-saved-regs-2.c: Likewise.\n+\n 2020-05-19  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \tPR target/92658"}, {"sha": "6d6fe6e8e1bb425f41467901915859f55850e9b8", "filename": "gcc/testsuite/gcc.target/bpf/xbpf-callee-saved-regs-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98456a64b0b5c20eeb8f964c7718072ba9b0e568/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fxbpf-callee-saved-regs-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98456a64b0b5c20eeb8f964c7718072ba9b0e568/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fxbpf-callee-saved-regs-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fxbpf-callee-saved-regs-1.c?ref=98456a64b0b5c20eeb8f964c7718072ba9b0e568", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mxbpf\" } */\n+\n+/* GCC should save and restore callee-saved registers when generating\n+   code for xBPF.  */\n+\n+int\n+foo ()\n+{\n+  register int f asm (\"r6\");\n+\n+  f = 20;\n+  return f + 1;\n+}\n+\n+/* { dg-final { scan-assembler \"stxdw\\t\\\\\\[%fp\\\\+-8\\\\\\],%r6\" } } */\n+/* { dg-final { scan-assembler \"ldxdw\\t%r6,\\\\\\[%fp\\\\+-8\\\\\\]\" } } */"}, {"sha": "dec71cfe65d7b3bb5053c8d6197df311ae56f2b1", "filename": "gcc/testsuite/gcc.target/bpf/xbpf-callee-saved-regs-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98456a64b0b5c20eeb8f964c7718072ba9b0e568/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fxbpf-callee-saved-regs-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98456a64b0b5c20eeb8f964c7718072ba9b0e568/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fxbpf-callee-saved-regs-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fxbpf-callee-saved-regs-2.c?ref=98456a64b0b5c20eeb8f964c7718072ba9b0e568", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mno-xbpf\" } */\n+\n+/* GCC should not save and restore callee-saved registers unless\n+   generating code for xBPF.  */\n+\n+int\n+foo ()\n+{\n+  register int f asm (\"r6\");\n+\n+  f = 20;\n+  return f + 1;\n+}\n+\n+/* { dg-final { scan-assembler-not \"stxdw\\t\\\\\\[%fp\\\\+-8\\\\\\],%r6\" } } */\n+/* { dg-final { scan-assembler-not \"ldxdw\\t%r6,\\\\\\[%fp\\\\+-8\\\\\\]\" } } */"}]}