{"sha": "6bad26173df0462c3d7391d58d55fa132bb44102", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJhZDI2MTczZGYwNDYyYzNkNzM5MWQ1OGQ1NWZhMTMyYmI0NDEwMg==", "commit": {"author": {"name": "Tomas Bily", "email": "tbily@suse.cz", "date": "2007-01-19T18:34:02Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-01-19T18:34:02Z"}, "message": "Patch by Tomas Bily <tbily@suse.cz>\n\nPatch by Tomas Bily  <tbily@suse.cz>\n        * cgraphunit.c (cgraph_finalize_function): Updating of pid\n        * tree-profile.c:\n        (tree_init_ic_make_global_vars): New function\n        (tree_init_edge_profiler): call of tree_init_ic_make_global_vars\n        (tree_gen_ic_profiler): New function\n        (tree_gen_ic_func_profiler): New function\n        (tree_profiling): Added calling of tree_gen_ic_func_profiler\n        (tree_profile_hooks): Added hook for indirec/virtual calls\n        * value-prof.c (tree_find_values_to_profile): New case for\n        indirect calls\n        (tree_values_to_profile): Call for determining indirect/virtual\n        counters\n        (tree_indirect_call_to_profile): New function\n        (tree_ic_transform): New function\n        (tree_ic): New function\n        (find_func_by_pid): New function\n        (init_pid_map): New function\n        (tree_value_profile_transformations): Added check for\n        indirect/virtual call transformation\n        * value-prof.h (enum hist_type): New counter type for\n        indirect/virtual calls\n        (profile_hooks): Added new hook for profiling indirect/virtual\n        calls\n        * profile.c (instrument_values): New case for indirect/virtual\n        call added\n        * gcov-io.h (GCOV_LAST_VALUE_COUNTER): Changed to 6\n        (GCOV_COUNTER_V_INDIR): New counter type\n        (GCOV_COUNTER_NAMES): New name of counter \"indirect\" added\n        (GCOV_MERGE_FUNCTIONS): New merge function for indirect/virtual\n        call added\n        * cgraph.c: Definition of cgraph_max_pid\n        (cgraph_create_node): Default init of pid attribute\n        * cgraph.h: Declaration of cgraph_max_pid\n        (struct cgraph_node): Added pid attribute\n        * libgcov.c (__gcov_indirect_call_profiler): New function\n\t(__gcov_one_value_profiler_body): New function\n\t(__gcov_one_value_profiler): Body was moved to\n\t__gcov_one_value_profiler_body and calls it\n\n\tgcc.dg/tree-prof/indir-call-prof.c: New.\n\tg++.dg/dg.exp: Add tree-prof subdirectory.\n\tg++.dg/tree-prof/indir-call-prof.C: New.\n\tg++.dg/tree-prof/tree-prof.exp: New.\n\nFrom-SVN: r120975", "tree": {"sha": "41def031b05732ddcfbc26eac41ed55f2a54dc07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41def031b05732ddcfbc26eac41ed55f2a54dc07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bad26173df0462c3d7391d58d55fa132bb44102", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bad26173df0462c3d7391d58d55fa132bb44102", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bad26173df0462c3d7391d58d55fa132bb44102", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bad26173df0462c3d7391d58d55fa132bb44102/comments", "author": null, "committer": null, "parents": [{"sha": "b7c75af4b5b275047cb622ae85f98839cf6299a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7c75af4b5b275047cb622ae85f98839cf6299a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7c75af4b5b275047cb622ae85f98839cf6299a1"}], "stats": {"total": 648, "additions": 635, "deletions": 13}, "files": [{"sha": "7f8ac0e9622c8a632d261454748f1f38a595244a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6bad26173df0462c3d7391d58d55fa132bb44102", "patch": "@@ -1,3 +1,44 @@\n+2007-01-19  Tomas Bily  <tbily@suse.cz>\n+\n+        * cgraphunit.c (cgraph_finalize_function): Updating of pid\n+        * tree-profile.c:\n+        (tree_init_ic_make_global_vars): New function\n+        (tree_init_edge_profiler): call of tree_init_ic_make_global_vars\n+        (tree_gen_ic_profiler): New function\n+        (tree_gen_ic_func_profiler): New function\n+        (tree_profiling): Added calling of tree_gen_ic_func_profiler\n+        (tree_profile_hooks): Added hook for indirec/virtual calls\n+        * value-prof.c (tree_find_values_to_profile): New case for\n+        indirect calls\n+        (tree_values_to_profile): Call for determining indirect/virtual\n+        counters\n+        (tree_indirect_call_to_profile): New function\n+        (tree_ic_transform): New function\n+        (tree_ic): New function\n+        (find_func_by_pid): New function\n+        (init_pid_map): New function\n+        (tree_value_profile_transformations): Added check for\n+        indirect/virtual call transformation\n+        * value-prof.h (enum hist_type): New counter type for\n+        indirect/virtual calls\n+        (profile_hooks): Added new hook for profiling indirect/virtual\n+        calls\n+        * profile.c (instrument_values): New case for indirect/virtual\n+        call added\n+        * gcov-io.h (GCOV_LAST_VALUE_COUNTER): Changed to 6\n+        (GCOV_COUNTER_V_INDIR): New counter type\n+        (GCOV_COUNTER_NAMES): New name of counter \"indirect\" added\n+        (GCOV_MERGE_FUNCTIONS): New merge function for indirect/virtual\n+        call added\n+        * cgraph.c: Definition of cgraph_max_pid\n+        (cgraph_create_node): Default init of pid attribute\n+        * cgraph.h: Declaration of cgraph_max_pid\n+        (struct cgraph_node): Added pid attribute\n+        * libgcov.c (__gcov_indirect_call_profiler): New function\n+\t(__gcov_one_value_profiler_body): New function\n+\t(__gcov_one_value_profiler): Body was moved to\n+\t__gcov_one_value_profiler_body and calls it\n+\n 2007-01-19  Basile Starynkevitch  <basile@starynkevitch.net>\n \n \t* doc/gty.texi (Options): Document the mark_hook option to"}, {"sha": "59ac3dd8b4f0ea86a5e8f2abc077bc9414067693", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6bad26173df0462c3d7391d58d55fa132bb44102", "patch": "@@ -1013,7 +1013,8 @@ LIB2FUNCS_ST = _eprintf __gcc_bcmp\n LIBGCOV = _gcov _gcov_merge_add _gcov_merge_single _gcov_merge_delta \\\n     _gcov_fork _gcov_execl _gcov_execlp _gcov_execle \\\n     _gcov_execv _gcov_execvp _gcov_execve \\\n-    _gcov_interval_profiler _gcov_pow2_profiler _gcov_one_value_profiler\n+    _gcov_interval_profiler _gcov_pow2_profiler _gcov_one_value_profiler \\\n+    _gcov_indirect_call_profiler\n \n FPBIT_FUNCS = _pack_sf _unpack_sf _addsub_sf _mul_sf _div_sf \\\n     _fpcmp_parts_sf _compare_sf _eq_sf _ne_sf _gt_sf _ge_sf \\\n@@ -2355,7 +2356,7 @@ profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n tree-profile.o : tree-profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) \\\n    $(FUNCTION_H) toplev.h $(COVERAGE_H) $(TREE_H) value-prof.h $(TREE_DUMP_H) \\\n-   tree-pass.h $(TREE_FLOW_H) $(TIMEVAR_H) $(GGC_H) gt-tree-profile.h\n+   tree-pass.h $(TREE_FLOW_H) $(TIMEVAR_H) $(GGC_H) gt-tree-profile.h $(CGRAPH_H)\n value-prof.o : value-prof.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h value-prof.h $(EXPR_H) output.h $(FLAGS_H) \\\n    $(RECOG_H) insn-config.h $(OPTABS_H) $(REGS_H) $(GGC_H) $(DIAGNOSTIC_H) \\"}, {"sha": "13b7fcd2938caf55782308fa1c1d29367505c53b", "filename": "gcc/cgraph.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=6bad26173df0462c3d7391d58d55fa132bb44102", "patch": "@@ -109,6 +109,9 @@ int cgraph_n_nodes;\n /* Maximal uid used in cgraph nodes.  */\n int cgraph_max_uid;\n \n+/* Maximal pid used for profiling */\n+int cgraph_max_pid;\n+\n /* Set when whole unit has been analyzed so we can access global info.  */\n bool cgraph_global_info_ready = false;\n \n@@ -161,6 +164,7 @@ cgraph_create_node (void)\n   node = GGC_CNEW (struct cgraph_node);\n   node->next = cgraph_nodes;\n   node->uid = cgraph_max_uid++;\n+  node->pid = -1;\n   node->order = cgraph_order++;\n   if (cgraph_nodes)\n     cgraph_nodes->previous = node;\n@@ -655,7 +659,7 @@ void\n dump_cgraph_node (FILE *f, struct cgraph_node *node)\n {\n   struct cgraph_edge *edge;\n-  fprintf (f, \"%s/%i:\", cgraph_node_name (node), node->uid);\n+  fprintf (f, \"%s/%i(%i):\", cgraph_node_name (node), node->uid, node->pid);\n   if (node->global.inlined_to)\n     fprintf (f, \" (inline copy in %s/%i)\",\n \t     cgraph_node_name (node->global.inlined_to),"}, {"sha": "179a5f1714e37f9f70b84d501bcc6b002c9a913a", "filename": "gcc/cgraph.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=6bad26173df0462c3d7391d58d55fa132bb44102", "patch": "@@ -180,6 +180,10 @@ struct cgraph_node GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n      into clone before compiling so the function in original form can be\n      inlined later.  This pointer points to the clone.  */\n   tree inline_decl;\n+\n+  /* unique id for profiling. pid is not suitable because of different\n+     number of cfg nodes with -fprofile-generate and -fprofile-use */\n+  int pid;\n };\n \n struct cgraph_edge GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\")))\n@@ -253,6 +257,7 @@ struct cgraph_asm_node GTY(())\n extern GTY(()) struct cgraph_node *cgraph_nodes;\n extern GTY(()) int cgraph_n_nodes;\n extern GTY(()) int cgraph_max_uid;\n+extern GTY(()) int cgraph_max_pid;\n extern bool cgraph_global_info_ready;\n enum cgraph_state\n {"}, {"sha": "055399e8330312b34d3db63cd7078b59175ddbb8", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=6bad26173df0462c3d7391d58d55fa132bb44102", "patch": "@@ -444,6 +444,7 @@ cgraph_finalize_function (tree decl, bool nested)\n   if (node->local.finalized)\n     cgraph_reset_node (node);\n \n+  node->pid = cgraph_max_pid ++;\n   notice_global_symbol (decl);\n   node->decl = decl;\n   node->local.finalized = true;"}, {"sha": "e819eb3fa2ac33fb35bbe1a165ac2cb08023bade", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=6bad26173df0462c3d7391d58d55fa132bb44102", "patch": "@@ -327,23 +327,26 @@ typedef HOST_WIDEST_INT gcov_type;\n #define GCOV_COUNTER_V_SINGLE\t3  /* The most common value of expression.  */\n #define GCOV_COUNTER_V_DELTA\t4  /* The most common difference between\n \t\t\t\t      consecutive values of expression.  */\n-#define GCOV_LAST_VALUE_COUNTER 4  /* The last of counters used for value\n+\n+#define GCOV_COUNTER_V_INDIR\t5  /* The most common indirect address */\n+#define GCOV_LAST_VALUE_COUNTER 5  /* The last of counters used for value\n \t\t\t\t      profiling.  */\n-#define GCOV_COUNTERS\t\t5\n+#define GCOV_COUNTERS\t\t6\n \n /* Number of counters used for value profiling.  */\n #define GCOV_N_VALUE_COUNTERS \\\n   (GCOV_LAST_VALUE_COUNTER - GCOV_FIRST_VALUE_COUNTER + 1)\n   \n   /* A list of human readable names of the counters */\n-#define GCOV_COUNTER_NAMES\t{\"arcs\", \"interval\", \"pow2\", \"single\", \"delta\"}\n+#define GCOV_COUNTER_NAMES\t{\"arcs\", \"interval\", \"pow2\", \"single\", \"delta\", \"indirect_call\"}\n   \n   /* Names of merge functions for counters.  */\n #define GCOV_MERGE_FUNCTIONS\t{\"__gcov_merge_add\",\t\\\n \t\t\t\t \"__gcov_merge_add\",\t\\\n \t\t\t\t \"__gcov_merge_add\",\t\\\n \t\t\t\t \"__gcov_merge_single\",\t\\\n-\t\t\t\t \"__gcov_merge_delta\"}\n+\t\t\t\t \"__gcov_merge_delta\",  \\\n+\t\t\t\t \"__gcov_merge_single\" }\n   \n /* Convert a counter index to a tag.  */\n #define GCOV_TAG_FOR_COUNTER(COUNT)\t\t\t\t\\"}, {"sha": "880686eba04c9d41d1ea98af4d1f917bb2cdfebb", "filename": "gcc/libgcov.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=6bad26173df0462c3d7391d58d55fa132bb44102", "patch": "@@ -726,7 +726,6 @@ __gcov_pow2_profiler (gcov_type *counters, gcov_type value)\n }\n #endif\n \n-#ifdef L_gcov_one_value_profiler\n /* Tries to determine the most common value among its inputs.  Checks if the\n    value stored in COUNTERS[0] matches VALUE.  If this is the case, COUNTERS[1]\n    is incremented.  If this is not the case and COUNTERS[1] is not zero,\n@@ -737,8 +736,8 @@ __gcov_pow2_profiler (gcov_type *counters, gcov_type value)\n \n    In any case, COUNTERS[2] is incremented.  */\n \n-void\n-__gcov_one_value_profiler (gcov_type *counters, gcov_type value)\n+static inline void\n+__gcov_one_value_profiler_body (gcov_type *counters, gcov_type value)\n {\n   if (value == counters[0])\n     counters[1]++;\n@@ -751,6 +750,24 @@ __gcov_one_value_profiler (gcov_type *counters, gcov_type value)\n     counters[1]--;\n   counters[2]++;\n }\n+\n+#ifdef L_gcov_one_value_profiler\n+void\n+__gcov_one_value_profiler (gcov_type *counters, gcov_type value)\n+{\n+  __gcov_one_value_profiler_body (counters, value);\n+}\n+#endif\n+\n+#ifdef L_gcov_indirect_call_profiler\n+/* Tries to determine the most common value among its inputs. */\n+void\n+__gcov_indirect_call_profiler (gcov_type* counter, gcov_type value, \n+\t\t\t       void* cur_func, void* callee_func)\n+{\n+  if (cur_func == callee_func)\n+    __gcov_one_value_profiler_body (counter, value);\n+}\n #endif\n \n #ifdef L_gcov_fork"}, {"sha": "b29d04a56cffdc2a7e56a2061a9508518eea2ecf", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=6bad26173df0462c3d7391d58d55fa132bb44102", "patch": "@@ -1638,6 +1638,7 @@ counts_to_freqs (void)\n   count_max = MAX (true_count_max, 1);\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     bb->frequency = (bb->count * BB_FREQ_MAX + count_max / 2) / count_max;\n+\n   return true_count_max;\n }\n "}, {"sha": "ef6b3266157028039f01913616d30682327138b2", "filename": "gcc/profile.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=6bad26173df0462c3d7391d58d55fa132bb44102", "patch": "@@ -192,6 +192,10 @@ instrument_values (histogram_values values)\n \t  t = GCOV_COUNTER_V_DELTA;\n \t  break;\n \n+ \tcase HIST_TYPE_INDIR_CALL:\n+ \t  t = GCOV_COUNTER_V_INDIR;\n+ \t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -216,6 +220,10 @@ instrument_values (histogram_values values)\n \t  (profile_hooks->gen_const_delta_profiler) (hist, t, 0);\n \t  break;\n \n+ \tcase HIST_TYPE_INDIR_CALL:\n+ \t  (profile_hooks->gen_ic_profiler) (hist, t, 0);\n+  \t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}"}, {"sha": "e0178ad1a1d6cc5ad292eed99577b774dcb089bb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6bad26173df0462c3d7391d58d55fa132bb44102", "patch": "@@ -1,3 +1,10 @@\n+2007-01-19  Tomas Bily  <tbily@suse.cz>\n+\n+\tgcc.dg/tree-prof/indir-call-prof.c: New.\n+\tg++.dg/dg.exp: Add tree-prof subdirectory.\n+\tg++.dg/tree-prof/indir-call-prof.C: New.\n+\tg++.dg/tree-prof/tree-prof.exp: New.\n+\n 2007-01-19  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR c++/17947"}, {"sha": "2581139eac327bd4a6dc5191822c9a3c6a655676", "filename": "gcc/testsuite/g++.dg/dg.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp?ref=6bad26173df0462c3d7391d58d55fa132bb44102", "patch": "@@ -41,6 +41,7 @@ set tests [prune $tests $srcdir/$subdir/special/*]\n set tests [prune $tests $srcdir/$subdir/tls/*]\n set tests [prune $tests $srcdir/$subdir/vect/*]\n set tests [prune $tests $srcdir/$subdir/gomp/*]\n+set tests [prune $tests $srcdir/$subdir/tree-prof/*]\n \n # Main loop.\n dg-runtest $tests \"\" $DEFAULT_CXXFLAGS"}, {"sha": "98ab302663fd3e0d4f23193850501f474be90363", "filename": "gcc/testsuite/g++.dg/tree-prof/indir-call-prof.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Findir-call-prof.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Findir-call-prof.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Findir-call-prof.C?ref=6bad26173df0462c3d7391d58d55fa132bb44102", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-tree_profile\" } */\n+\n+struct A {\n+  A () {}\n+\n+  virtual int AA (void)\n+  { return 0; }\n+\n+};\n+\n+struct B : public A {\n+  B () {}\n+\n+  virtual int AA (void)\n+  { return 1; }\n+};\n+\n+int\n+main (void)\n+{\n+  A a;\n+  B b;\n+  \n+  A* p;\n+\n+  p = &a;\n+  p->AA ();\n+\n+  p = &b;\n+  p->AA ();\n+  \n+  return 0;\n+}\n+\n+/* { dg-final-use { scan-tree-dump \"Indirect call -> direct call.* AA transformation on insn\" \"tree_profile\"} } */\n+/* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */                                                                                \n+/* { dg-final-use { cleanup-tree-dump \"optimized\" } } */                                                                                              \n+/* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */                                                                                           \n+"}, {"sha": "f9ebbd6959579a7a51384ba5f67f6312ff4e69e3", "filename": "gcc/testsuite/g++.dg/tree-prof/tree-prof.exp", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Ftree-prof.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Ftree-prof.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Ftree-prof.exp?ref=6bad26173df0462c3d7391d58d55fa132bb44102", "patch": "@@ -0,0 +1,53 @@\n+#   Copyright (C) 2001, 2002, 2004, 2005 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  \n+\n+# Test the functionality of programs compiled with profile-directed block\n+# ordering using -fprofile-generate followed by -fbranch-use.\n+\n+load_lib target-supports.exp\n+\n+# Some targets don't support tree profiling.\n+if { ![check_profiling_available \"\"] } {\n+    return\n+}\n+\n+# The procedures in profopt.exp need these parameters.\n+set tool g++\n+set prof_ext \"gcda gcno\"\n+\n+# Override the list defined in profopt.exp.\n+set PROFOPT_OPTIONS [list {}]\n+\n+if $tracelevel then {\n+    strace $tracelevel\n+}\n+\n+# Load support procs.\n+load_lib profopt.exp\n+\n+# These are globals used by profopt-execute.  The first is options\n+# needed to generate profile data, the second is options to use the\n+# profile data.\n+set profile_option \"-fprofile-generate\"\n+set feedback_option \"-fprofile-use\"\n+\n+foreach src [lsort [glob -nocomplain $srcdir/$subdir/*.C]] {\n+    # If we're only testing specific files and this isn't one of them, skip it.\n+    if ![runtest_file_p $runtests $src] then {\n+        continue\n+    }\n+    profopt-execute $src\n+}"}, {"sha": "101b9725f8633b0ebd595b56dfaaca76c44779c4", "filename": "gcc/testsuite/gcc.dg/tree-prof/indir-call-prof.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Findir-call-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Findir-call-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Findir-call-prof.c?ref=6bad26173df0462c3d7391d58d55fa132bb44102", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-tree_profile\" } */\n+\n+static int a1 (void)\n+{\n+    return 10;\n+}\n+\n+static int a2 (void)\n+{\n+    return 0;\n+}\n+\n+typedef int (*tp) (void);\n+\n+static tp aa [] = {a2, a1, a1, a1, a1};\n+\n+void setp (int (**pp) (void), int i)\n+{\n+  if (!i)\n+    *pp = aa [i];\n+  else\n+    *pp = aa [(i & 2) + 1];\n+}\n+\n+int\n+main (void)\n+{\n+  int (*p) (void);\n+  int  i;\n+\n+  for (i = 0; i < 10; i ++)\n+    {\n+\tsetp (&p, i);\n+\tp ();\n+    }\n+  \n+  return 0;\n+}\n+\n+/* { dg-final-use { scan-tree-dump \"Indirect call -> direct call.* a1 transformation on insn\" \"tree_profile\"} } */\n+/* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */                                                                                \n+/* { dg-final-use { cleanup-tree-dump \"optimized\" } } */                                                                                              \n+/* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */\n+                                                                                           \n+"}, {"sha": "2a4ec2ae9eb7e2bbdfce293834b0693229502dbb", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 143, "deletions": 1, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=6bad26173df0462c3d7391d58d55fa132bb44102", "patch": "@@ -45,22 +45,62 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"timevar.h\"\n #include \"value-prof.h\"\n #include \"ggc.h\"\n+#include \"cgraph.h\"\n \n static GTY(()) tree gcov_type_node;\n static GTY(()) tree tree_interval_profiler_fn;\n static GTY(()) tree tree_pow2_profiler_fn;\n static GTY(()) tree tree_one_value_profiler_fn;\n+static GTY(()) tree tree_indirect_call_profiler_fn;\n \f\n \n+static GTY(()) tree ic_void_ptr_var;\n+static GTY(()) tree ic_gcov_type_ptr_var;\n+static GTY(()) tree ptr_void;\n+\n /* Do initialization work for the edge profiler.  */\n \n+/* Add code:\n+   static gcov*\t__gcov_indirect_call_counters; // pointer to actual counter\n+   static void*\t__gcov_indirect_call_callee; // actual callie addres\n+*/\n+static void\n+tree_init_ic_make_global_vars (void)\n+{\n+  tree  gcov_type_ptr;\n+\n+  ptr_void = build_pointer_type (void_type_node);\n+  \n+  ic_void_ptr_var \n+    = build_decl (VAR_DECL, \n+\t\t  get_identifier (\"__gcov_indirect_call_callee\"), \n+\t\t  ptr_void);\n+  TREE_STATIC (ic_void_ptr_var) = 1;\n+  TREE_PUBLIC (ic_void_ptr_var) = 0;\n+  DECL_ARTIFICIAL (ic_void_ptr_var) = 1;\n+  DECL_INITIAL (ic_void_ptr_var) = NULL;\n+  assemble_variable (ic_void_ptr_var, 0, 0, 0);\n+\n+  gcov_type_ptr = build_pointer_type (get_gcov_type ());\n+  ic_gcov_type_ptr_var \n+    = build_decl (VAR_DECL, \n+\t\t  get_identifier (\"__gcov_indirect_call_counters\"), \n+\t\t  gcov_type_ptr);\n+  TREE_STATIC (ic_gcov_type_ptr_var) = 1;\n+  TREE_PUBLIC (ic_gcov_type_ptr_var) = 0;\n+  DECL_ARTIFICIAL (ic_gcov_type_ptr_var) = 1;\n+  DECL_INITIAL (ic_gcov_type_ptr_var) = NULL;\n+  assemble_variable (ic_gcov_type_ptr_var, 0, 0, 0);\n+}\n+\n static void\n tree_init_edge_profiler (void)\n {\n   tree interval_profiler_fn_type;\n   tree pow2_profiler_fn_type;\n   tree one_value_profiler_fn_type;\n   tree gcov_type_ptr;\n+  tree ic_profiler_fn_type;\n \n   if (!gcov_type_node)\n     {\n@@ -93,6 +133,18 @@ tree_init_edge_profiler (void)\n       tree_one_value_profiler_fn\n \t      = build_fn_decl (\"__gcov_one_value_profiler\",\n \t\t\t\t     one_value_profiler_fn_type);\n+\n+      tree_init_ic_make_global_vars ();\n+      \n+      /* void (*) (gcov_type *, gcov_type, void *, void *)  */\n+      ic_profiler_fn_type\n+\t       = build_function_type_list (void_type_node,\n+\t\t\t\t\t  gcov_type_ptr, gcov_type_node,\n+\t\t\t\t\t  ptr_void,\n+\t\t\t\t\t  ptr_void, NULL_TREE);\n+      tree_indirect_call_profiler_fn\n+\t      = build_fn_decl (\"__gcov_indirect_call_profiler\",\n+\t\t\t\t     ic_profiler_fn_type);\n     }\n }\n \n@@ -201,6 +253,90 @@ tree_gen_one_value_profiler (histogram_value value, unsigned tag, unsigned base)\n   bsi_insert_before (&bsi, call, BSI_SAME_STMT);\n }\n \n+\n+/* Output instructions as GIMPLE trees for code to find the most\n+   common called function in indirect call.  \n+   VALUE is the call expression whose indirect callie is profiled.\n+   TAG is the tag of the section for counters, BASE is offset of the\n+   counter position.  */\n+\n+static void\n+tree_gen_ic_profiler (histogram_value value, unsigned tag, unsigned base)\n+{\n+  tree tmp1, stmt1, stmt2, stmt3;\n+  tree stmt = value->hvalue.stmt;\n+  block_stmt_iterator bsi = bsi_for_stmt (stmt);\n+  tree ref = tree_coverage_counter_ref (tag, base), ref_ptr;\n+\n+  ref_ptr = force_gimple_operand_bsi (&bsi,\n+\t\t\t\t      build_addr (ref, current_function_decl),\n+\t\t\t\t      true, NULL_TREE);\n+\n+  /* Insert code:\n+    \n+    __gcov_indirect_call_counters = get_relevant_counter_ptr (); \n+    __gcov_indirect_call_callee = (void *) indirect call argument;\n+   */\n+\n+  tmp1 = create_tmp_var (ptr_void, \"PROF\");\n+  stmt1 = build2 (GIMPLE_MODIFY_STMT, \n+\t\t  build_pointer_type (get_gcov_type ()), \n+\t\t  ic_gcov_type_ptr_var, ref_ptr);\n+  stmt2 = build2 (GIMPLE_MODIFY_STMT, ptr_void, tmp1, \n+\t\t  unshare_expr (value->hvalue.value));\n+  stmt3 = build2 (GIMPLE_MODIFY_STMT, ptr_void, \n+\t\t  ic_void_ptr_var, tmp1);\n+\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n+}\n+\n+\n+/* Output instructions as GIMPLE trees for code to find the most\n+   common called function in indirect call. Insert instructions at the\n+   begining of every possible called function.\n+  */\n+\n+static void\n+tree_gen_ic_func_profiler (void)\n+{\n+  struct cgraph_node * c_node = cgraph_node (current_function_decl);\n+  block_stmt_iterator bsi;\n+  edge e;\n+  basic_block bb;\n+  edge_iterator ei;\n+  tree stmt1;\n+  tree args, tree_uid, cur_func;\n+\n+  if (flag_unit_at_a_time)\n+    {\n+      if (!c_node->needed)\n+\treturn;\n+    }\n+  \n+  tree_init_edge_profiler ();\n+  \n+  FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)\n+    {\n+      bb = split_edge (e);\n+      bsi = bsi_start (bb);\n+      cur_func = force_gimple_operand_bsi (&bsi,\n+\t\t\t\t\t   build_addr (current_function_decl, \n+\t\t\t\t\t\t       current_function_decl),\n+\t\t\t\t\t   true, NULL_TREE);\n+      tree_uid = build_int_cst (gcov_type_node, c_node->pid);\n+      args = tree_cons (NULL_TREE, ic_gcov_type_ptr_var,\n+\t\t\ttree_cons (NULL_TREE, tree_uid,\n+\t\t\t\t   tree_cons (NULL_TREE, cur_func,\n+\t\t\t\t\t      tree_cons (NULL_TREE, \n+\t\t\t\t\t\t\t ic_void_ptr_var,\n+\t\t\t\t\t\t\t NULL_TREE))));\n+      stmt1 = build_function_call_expr (tree_indirect_call_profiler_fn, args);\n+      bsi_insert_after (&bsi, stmt1, BSI_SAME_STMT);\n+    }\n+}\n+\n /* Output instructions as GIMPLE trees for code to find the most common value \n    of a difference between two evaluations of an expression.\n    VALUE is the expression whose value is profiled.  TAG is the tag of the\n@@ -242,6 +378,11 @@ tree_profiling (void)\n   if (cgraph_state == CGRAPH_STATE_FINISHED)\n     return 0;\n   branch_prob ();\n+\n+  if (! flag_branch_probabilities \n+      && flag_profile_values)\n+    tree_gen_ic_func_profiler ();\n+\n   if (flag_branch_probabilities\n       && flag_profile_values\n       && flag_value_profile_transformations)\n@@ -278,7 +419,8 @@ struct profile_hooks tree_profile_hooks =\n   tree_gen_interval_profiler,   /* gen_interval_profiler */\n   tree_gen_pow2_profiler,       /* gen_pow2_profiler */\n   tree_gen_one_value_profiler,  /* gen_one_value_profiler */\n-  tree_gen_const_delta_profiler /* gen_const_delta_profiler */\n+  tree_gen_const_delta_profiler,/* gen_const_delta_profiler */\n+  tree_gen_ic_profiler,\t\t/* gen_ic_profiler */\n };\n \n #include \"gt-tree-profile.h\""}, {"sha": "f23fd68dd6fe522233a0a0c114570142e04d7cec", "filename": "gcc/value-prof.c", "status": "modified", "additions": 250, "deletions": 1, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=6bad26173df0462c3d7391d58d55fa132bb44102", "patch": "@@ -40,6 +40,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"coverage.h\"\n #include \"tree.h\"\n #include \"gcov-io.h\"\n+#include \"cgraph.h\"\n #include \"timevar.h\"\n #include \"tree-pass.h\"\n #include \"toplev.h\"\n@@ -60,6 +61,11 @@ static struct value_prof_hooks *value_prof_hooks;\n       FIXME: This transformation was removed together with RTL based value\n       profiling.\n \n+   3) Indirect/virtual call specialization. If we can determine most\n+      common function callee in indirect/virtual call. We can use this\n+      information to improve code effectivity (espetialy info for\n+      inliner).\n+\n    Every such optimization should add its requirements for profiled values to\n    insn_values_to_profile function.  This function is called from branch_prob\n    in profile.c and the requested values are instrumented by it in the first\n@@ -81,6 +87,7 @@ static bool tree_divmod_fixed_value_transform (tree);\n static bool tree_mod_pow2_value_transform (tree);\n static bool tree_mod_subtract_transform (tree);\n static bool tree_stringops_transform (block_stmt_iterator *);\n+static bool tree_ic_transform (tree);\n \n /* Allocate histogram value.  */\n \n@@ -254,6 +261,19 @@ dump_histogram_value (FILE *dump_file, histogram_value hist)\n \t}\n       fprintf (dump_file, \".\\n\");\n       break;\n+    case HIST_TYPE_INDIR_CALL:\n+      fprintf (dump_file, \"Indirect call \");\n+      if (hist->hvalue.counters)\n+\t{\n+\t   fprintf (dump_file, \"value:\"HOST_WIDEST_INT_PRINT_DEC\n+\t\t    \" match:\"HOST_WIDEST_INT_PRINT_DEC\n+\t\t    \" all:\"HOST_WIDEST_INT_PRINT_DEC,\n+\t\t    (HOST_WIDEST_INT) hist->hvalue.counters[0],\n+\t\t    (HOST_WIDEST_INT) hist->hvalue.counters[1],\n+\t\t    (HOST_WIDEST_INT) hist->hvalue.counters[2]);\n+\t}\n+      fprintf (dump_file, \".\\n\");\n+      break;\n    }\n }\n \n@@ -432,7 +452,8 @@ tree_value_profile_transformations (void)\n \t      && (tree_mod_subtract_transform (stmt)\n \t\t  || tree_divmod_fixed_value_transform (stmt)\n \t\t  || tree_mod_pow2_value_transform (stmt)\n-\t\t  || tree_stringops_transform (&bsi)))\n+\t\t  || tree_stringops_transform (&bsi)\n+\t\t  || tree_ic_transform (stmt)))\n \t    {\n \t      stmt = bsi_stmt (bsi);\n \t      changed = true;\n@@ -967,6 +988,201 @@ tree_mod_subtract_transform (tree stmt)\n   return true;\n }\n \n+static struct cgraph_node** pid_map = NULL;\n+\n+/* Initialize map of pids (pid -> cgraph node) */\n+\n+static void \n+init_pid_map (void)\n+{\n+  struct cgraph_node *n;\n+\n+  if (pid_map != NULL)\n+    return;\n+\n+  pid_map \n+    = (struct cgraph_node**) xmalloc (sizeof (struct cgraph_node*) * cgraph_max_pid);\n+\n+  for (n = cgraph_nodes; n; n = n->next)\n+    {\n+      if (n->pid != -1)\n+\tpid_map [n->pid] = n;\n+    }\n+}\n+\n+/* Return cgraph node for function with pid */\n+\n+static inline struct cgraph_node*\n+find_func_by_pid (int\tpid)\n+{\n+  init_pid_map ();\n+\n+  return pid_map [pid];\n+}\n+\n+/* Do transformation\n+\n+  if (actual_callee_addres == addres_of_most_common_function/method)\n+    do direct call\n+  else\n+    old call\n+ */\n+\n+static tree\n+tree_ic (tree stmt, tree call, struct cgraph_node* direct_call, \n+\t int prob, gcov_type count, gcov_type all)\n+{\n+  tree stmt1, stmt2, stmt3;\n+  tree tmp1, tmpv;\n+  tree label_decl1 = create_artificial_label ();\n+  tree label_decl2 = create_artificial_label ();\n+  tree label1, label2;\n+  tree bb1end, bb2end, bb3end;\n+  tree new_call;\n+  basic_block bb, bb2, bb3, bb4;\n+  tree optype = build_pointer_type (void_type_node);\n+  edge e12, e13, e23, e24, e34;\n+  block_stmt_iterator bsi;\n+  int region;\n+\n+  bb = bb_for_stmt (stmt);\n+  bsi = bsi_for_stmt (stmt);\n+\n+  tmpv = create_tmp_var (optype, \"PROF\");\n+  tmp1 = create_tmp_var (optype, \"PROF\");\n+  stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, tmpv, \n+\t\t  unshare_expr (TREE_OPERAND (call, 0)));\n+  stmt2 = build2 (GIMPLE_MODIFY_STMT, optype, tmp1, \n+\t\t  fold_convert (optype, build_addr (direct_call->decl, \n+\t\t\t\t\t\t    current_function_decl)));\n+  stmt3 = build3 (COND_EXPR, void_type_node,\n+\t\t  build2 (NE_EXPR, boolean_type_node, tmp1, tmpv),\n+\t\t  build1 (GOTO_EXPR, void_type_node, label_decl2),\n+\t\t  build1 (GOTO_EXPR, void_type_node, label_decl1));\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n+  bb1end = stmt3;\n+\n+  label1 = build1 (LABEL_EXPR, void_type_node, label_decl1);\n+  stmt1 = unshare_expr (stmt);\n+  new_call = get_call_expr_in (stmt1);\n+  TREE_OPERAND (new_call, 0) = build_addr (direct_call->decl, \n+\t\t\t\t\t   current_function_decl);\n+  bsi_insert_before (&bsi, label1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bb2end = stmt1;\n+\n+  label2 = build1 (LABEL_EXPR, void_type_node, label_decl2);\n+  bsi_insert_before (&bsi, label2, BSI_SAME_STMT);\n+  bb3end = stmt;\n+\n+  /* Fix CFG. */\n+  /* Edge e23 connects bb2 to bb3, etc. */\n+  e12 = split_block (bb, bb1end);\n+  bb2 = e12->dest;\n+  bb2->count = count;\n+  e23 = split_block (bb2, bb2end);\n+  bb3 = e23->dest;\n+  bb3->count = all - count;\n+  e34 = split_block (bb3, bb3end);\n+  bb4 = e34->dest;\n+  bb4->count = all;\n+\n+  e12->flags &= ~EDGE_FALLTHRU;\n+  e12->flags |= EDGE_FALSE_VALUE;\n+  e12->probability = prob;\n+  e12->count = count;\n+\n+  e13 = make_edge (bb, bb3, EDGE_TRUE_VALUE);\n+  e13->probability = REG_BR_PROB_BASE - prob;\n+  e13->count = all - count;\n+\n+  remove_edge (e23);\n+  \n+  e24 = make_edge (bb2, bb4, EDGE_FALLTHRU);\n+  e24->probability = REG_BR_PROB_BASE;\n+  e24->count = count;\n+  e34->probability = REG_BR_PROB_BASE;\n+  e34->count = all - count;\n+\n+  /* Fix eh edges */\n+  region = lookup_stmt_eh_region (stmt);\n+  if (region >=0 && tree_could_throw_p (stmt1))\n+    {\n+      add_stmt_to_eh_region (stmt1, region);\n+      make_eh_edges (stmt1);\n+    }\n+\n+  if (region >=0 && tree_could_throw_p (stmt))\n+    {\n+      tree_purge_dead_eh_edges (bb4);\n+      make_eh_edges (stmt);\n+    }\n+\n+  return stmt1;\n+}\n+\n+/*\n+  For every checked indirect/virtual call determine if most common pid of\n+  function/class method has probability more than 50%. If yes modify code of\n+  this call to:\n+ */\n+\n+static bool\n+tree_ic_transform (tree stmt)\n+{\n+  histogram_value histogram;\n+  gcov_type val, count, all;\n+  int prob;\n+  tree call, callee, modify;\n+  struct cgraph_node *direct_call;\n+  \n+  call = get_call_expr_in (stmt);\n+\n+  if (!call || TREE_CODE (call) != CALL_EXPR)\n+    return false;\n+\n+  callee = TREE_OPERAND (call, 0);\n+\n+  if (TREE_CODE (callee) == ADDR_EXPR)\n+    return false;\n+\n+  histogram = gimple_histogram_value_of_type (cfun, stmt, HIST_TYPE_INDIR_CALL);\n+  if (!histogram)\n+    return false;\n+\n+  val = histogram->hvalue.counters [0];\n+  count = histogram->hvalue.counters [1];\n+  all = histogram->hvalue.counters [2];\n+  gimple_remove_histogram_value (cfun, stmt, histogram);\n+\n+  if (4 * count <= 3 * all)\n+    return false;\n+\n+  prob = (count * REG_BR_PROB_BASE + all / 2) / all;\n+  direct_call = find_func_by_pid ((int)val);\n+\n+  if (direct_call == NULL)\n+    return false;\n+\n+  modify = tree_ic (stmt, call, direct_call, prob, count, all);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Indirect call -> direct call \");\n+      print_generic_expr (dump_file, call, TDF_SLIM);\n+      fprintf (dump_file, \"=> \");\n+      print_generic_expr (dump_file, direct_call->decl, TDF_SLIM);\n+      fprintf (dump_file, \" transformation on insn \");\n+      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+      fprintf (dump_file, \" to \");\n+      print_generic_stmt (dump_file, modify, TDF_SLIM);\n+    }\n+\n+  return true;\n+}\n+\n /* Return true if the stringop FNDECL with ARGLIST shall be profiled.  */\n static bool\n interesting_stringop_to_profile_p (tree fndecl, tree arglist)\n@@ -1260,6 +1476,34 @@ tree_divmod_values_to_profile (tree stmt, histogram_values *values)\n     }\n }\n \n+/* Find calls inside STMT for that we want to measure histograms for \n+   indirect/virtual call optimization. */ \n+\n+static void\n+tree_indirect_call_to_profile (tree stmt, histogram_values *values)\n+{\n+  tree\t\t\tcall;\n+  tree\t\t\tcallee;\n+\n+  call = get_call_expr_in (stmt);\n+\n+  if (!call || TREE_CODE (call) != CALL_EXPR)\n+    return;\n+\n+  callee = TREE_OPERAND (call, 0);\n+  \n+  if (TREE_CODE (callee) == ADDR_EXPR)\n+    return;\n+\n+  VEC_reserve (histogram_value, heap, *values, 3);\n+\n+  VEC_quick_push (histogram_value, *values, \n+\t\t  gimple_alloc_histogram_value (cfun, HIST_TYPE_INDIR_CALL,\n+\t\t\t\t\t\tstmt, callee));\n+\n+  return;\n+}\n+\n /* Find values inside STMT for that we want to measure histograms for\n    string operations.  */\n static void\n@@ -1303,6 +1547,7 @@ tree_values_to_profile (tree stmt, histogram_values *values)\n     {\n       tree_divmod_values_to_profile (stmt, values);\n       tree_stringops_values_to_profile (stmt, values);\n+      tree_indirect_call_to_profile (stmt, values);\n     }\n }\n \n@@ -1339,6 +1584,10 @@ tree_find_values_to_profile (histogram_values *values)\n \t  hist->n_counters = 4;\n \t  break;\n \n+ \tcase HIST_TYPE_INDIR_CALL:\n+ \t  hist->n_counters = 3;\n+\t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}"}, {"sha": "78c9e887a27c2b6fa1614914adfa0c778400d728", "filename": "gcc/value-prof.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bad26173df0462c3d7391d58d55fa132bb44102/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=6bad26173df0462c3d7391d58d55fa132bb44102", "patch": "@@ -29,8 +29,10 @@ enum hist_type\n   HIST_TYPE_POW2,\t/* Histogram of power of 2 values.  */\n   HIST_TYPE_SINGLE_VALUE, /* Tries to identify the value that is (almost)\n \t\t\t   always constant.  */\n-  HIST_TYPE_CONST_DELTA\t/* Tries to identify the (almost) always constant\n+  HIST_TYPE_CONST_DELTA, /* Tries to identify the (almost) always constant\n \t\t\t   difference between two evaluations of a value.  */\n+  HIST_TYPE_INDIR_CALL   /* Tries to identify the function that is (almost) \n+\t\t\t    called in indirect call */\n };\n \n #define COUNTER_FOR_HIST_TYPE(TYPE) ((int) (TYPE) + GCOV_FIRST_VALUE_COUNTER)\n@@ -94,6 +96,9 @@ struct profile_hooks {\n   /* Insert code to find the most common value of a difference between two\n      evaluations of an expression.  */\n   void (*gen_const_delta_profiler) (histogram_value, unsigned, unsigned);\n+\n+  /* Insert code to find the most common indirect call */\n+  void (*gen_ic_profiler) (histogram_value, unsigned, unsigned);\n };\n \n histogram_value gimple_histogram_value (struct function *, tree);"}]}