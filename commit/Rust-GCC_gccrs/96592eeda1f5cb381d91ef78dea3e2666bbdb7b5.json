{"sha": "96592eeda1f5cb381d91ef78dea3e2666bbdb7b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY1OTJlZWRhMWY1Y2IzODFkOTFlZjc4ZGVhM2UyNjY2YmJkYjdiNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-10-25T16:26:12Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-10-25T16:26:12Z"}, "message": "re PR target/78102 (GCC refuses to generate PCMPEQQ instruction for SSE4.1)\n\n\tPR target/78102\n\t* optabs.def (vcondeq_optab, vec_cmpeq_optab): New optabs.\n\t* optabs.c (expand_vec_cond_expr): For comparison codes\n\tEQ_EXPR and NE_EXPR, attempt vcondeq_optab as fallback.\n\t(expand_vec_cmp_expr): For comparison codes\n\tEQ_EXPR and NE_EXPR, attempt vec_cmpeq_optab as fallback.\n\t* optabs-tree.h (expand_vec_cmp_expr_p, expand_vec_cond_expr_p):\n\tAdd enum tree_code argument.\n\t* optabs-query.h (get_vec_cmp_eq_icode, get_vcond_eq_icode): New\n\tinline functions.\n\t* optabs-tree.c (expand_vec_cmp_expr_p): Add CODE argument.  For\n\tCODE EQ_EXPR or NE_EXPR, attempt to use vec_cmpeq_optab as\n\tfallback.\n\t(expand_vec_cond_expr_p): Add CODE argument.  For CODE EQ_EXPR or\n\tNE_EXPR, attempt to use vcondeq_optab as fallback.\n\t* tree-vect-generic.c (expand_vector_comparison,\n\texpand_vector_divmod, expand_vector_condition): Adjust\n\texpand_vec_cmp_expr_p and expand_vec_cond_expr_p callers.\n\t* tree-vect-stmts.c (vectorizable_condition,\n\tvectorizable_comparison): Likewise.\n\t* tree-vect-patterns.c (vect_recog_mixed_size_cond_pattern,\n\tcheck_bool_pattern, search_type_for_mask_1): Likewise.\n\t* expr.c (do_store_flag): Likewise.\n\t* doc/md.texi (@code{vec_cmpeq@var{m}@var{n}},\n\t@code{vcondeq@var{m}@var{n}}): Document.\n\t* config/i386/sse.md (vec_cmpeqv2div2di, vcondeq<VI8F_128:mode>v2di):\n\tNew expanders.\ntestsuite/\n\t* gcc.target/i386/pr78102.c: New test.\n\nFrom-SVN: r241525", "tree": {"sha": "9f9b788664b48c4b29fde366326af8ab3961d90f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f9b788664b48c4b29fde366326af8ab3961d90f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8c78afcec88be17030623a4290f214928c143b29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c78afcec88be17030623a4290f214928c143b29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c78afcec88be17030623a4290f214928c143b29"}], "stats": {"total": 193, "additions": 168, "deletions": 25}, "files": [{"sha": "e7ab456ffc01d02fb04bf6d82782614fd5b93585", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96592eeda1f5cb381d91ef78dea3e2666bbdb7b5", "patch": "@@ -1,3 +1,33 @@\n+2016-10-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/78102\n+\t* optabs.def (vcondeq_optab, vec_cmpeq_optab): New optabs.\n+\t* optabs.c (expand_vec_cond_expr): For comparison codes\n+\tEQ_EXPR and NE_EXPR, attempt vcondeq_optab as fallback.\n+\t(expand_vec_cmp_expr): For comparison codes\n+\tEQ_EXPR and NE_EXPR, attempt vec_cmpeq_optab as fallback.\n+\t* optabs-tree.h (expand_vec_cmp_expr_p, expand_vec_cond_expr_p):\n+\tAdd enum tree_code argument.\n+\t* optabs-query.h (get_vec_cmp_eq_icode, get_vcond_eq_icode): New\n+\tinline functions.\n+\t* optabs-tree.c (expand_vec_cmp_expr_p): Add CODE argument.  For\n+\tCODE EQ_EXPR or NE_EXPR, attempt to use vec_cmpeq_optab as\n+\tfallback.\n+\t(expand_vec_cond_expr_p): Add CODE argument.  For CODE EQ_EXPR or\n+\tNE_EXPR, attempt to use vcondeq_optab as fallback.\n+\t* tree-vect-generic.c (expand_vector_comparison,\n+\texpand_vector_divmod, expand_vector_condition): Adjust\n+\texpand_vec_cmp_expr_p and expand_vec_cond_expr_p callers.\n+\t* tree-vect-stmts.c (vectorizable_condition,\n+\tvectorizable_comparison): Likewise.\n+\t* tree-vect-patterns.c (vect_recog_mixed_size_cond_pattern,\n+\tcheck_bool_pattern, search_type_for_mask_1): Likewise.\n+\t* expr.c (do_store_flag): Likewise.\n+\t* doc/md.texi (@code{vec_cmpeq@var{m}@var{n}},\n+\t@code{vcondeq@var{m}@var{n}}): Document.\n+\t* config/i386/sse.md (vec_cmpeqv2div2di, vcondeq<VI8F_128:mode>v2di):\n+\tNew expanders.\n+\n 2016-10-25  Jeff Law  <law@redhat.com>\n \n \t* config/v850/v850.c (v850_handle_data_area_attribute): Fix fallthru"}, {"sha": "14fcd67771cf04de1e1029067dbcc8acf2973c5b", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=96592eeda1f5cb381d91ef78dea3e2666bbdb7b5", "patch": "@@ -2652,6 +2652,18 @@\n   DONE;\n })\n \n+(define_expand \"vec_cmpeqv2div2di\"\n+  [(set (match_operand:V2DI 0 \"register_operand\")\n+\t(match_operator:V2DI 1 \"\"\n+\t  [(match_operand:V2DI 2 \"register_operand\")\n+\t   (match_operand:V2DI 3 \"vector_operand\")]))]\n+  \"TARGET_SSE4_1\"\n+{\n+  bool ok = ix86_expand_int_vec_cmp (operands);\n+  gcc_assert (ok);\n+  DONE;\n+})\n+\n (define_expand \"vcond<V_512:mode><VF_512:mode>\"\n   [(set (match_operand:V_512 0 \"register_operand\")\n \t(if_then_else:V_512\n@@ -11159,6 +11171,21 @@\n   DONE;\n })\n \n+(define_expand \"vcondeq<VI8F_128:mode>v2di\"\n+  [(set (match_operand:VI8F_128 0 \"register_operand\")\n+\t(if_then_else:VI8F_128\n+\t  (match_operator 3 \"\"\n+\t    [(match_operand:V2DI 4 \"vector_operand\")\n+\t     (match_operand:V2DI 5 \"general_operand\")])\n+\t  (match_operand:VI8F_128 1)\n+\t  (match_operand:VI8F_128 2)))]\n+  \"TARGET_SSE4_1\"\n+{\n+  bool ok = ix86_expand_int_vcond (operands);\n+  gcc_assert (ok);\n+  DONE;\n+})\n+\n (define_mode_iterator VEC_PERM_AVX2\n   [V16QI V8HI V4SI V2DI V4SF V2DF\n    (V32QI \"TARGET_AVX2\") (V16HI \"TARGET_AVX2\")"}, {"sha": "335dc61998035c20ed1ce31f21535e9cc38b62c2", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=96592eeda1f5cb381d91ef78dea3e2666bbdb7b5", "patch": "@@ -4730,6 +4730,14 @@ value of all-zeros.\n @item @samp{vec_cmpu@var{m}@var{n}}\n Similar to @code{vec_cmp@var{m}@var{n}} but perform unsigned vector comparison.\n \n+@cindex @code{vec_cmpeq@var{m}@var{n}} instruction pattern\n+@item @samp{vec_cmpeq@var{m}@var{n}}\n+Similar to @code{vec_cmp@var{m}@var{n}} but perform equality or non-equality\n+vector comparison only.  If @code{vec_cmp@var{m}@var{n}}\n+or @code{vec_cmpu@var{m}@var{n}} instruction pattern is supported,\n+it will be preferred over @code{vec_cmpeq@var{m}@var{n}}, so there is\n+no need to define this instruction pattern if the others are supported.\n+\n @cindex @code{vcond@var{m}@var{n}} instruction pattern\n @item @samp{vcond@var{m}@var{n}}\n Output a conditional vector move.  Operand 0 is the destination to\n@@ -4746,6 +4754,14 @@ comparison with a truth value of all-ones and a false value of all-zeros.\n Similar to @code{vcond@var{m}@var{n}} but performs unsigned vector\n comparison.\n \n+@cindex @code{vcondeq@var{m}@var{n}} instruction pattern\n+@item @samp{vcondeq@var{m}@var{n}}\n+Similar to @code{vcond@var{m}@var{n}} but performs equality or\n+non-equality vector comparison only.  If @code{vcond@var{m}@var{n}}\n+or @code{vcondu@var{m}@var{n}} instruction pattern is supported,\n+it will be preferred over @code{vcondeq@var{m}@var{n}}, so there is\n+no need to define this instruction pattern if the others are supported.\n+\n @cindex @code{vcond_mask_@var{m}@var{n}} instruction pattern\n @item @samp{vcond_mask_@var{m}@var{n}}\n Similar to @code{vcond@var{m}@var{n}} but operand 3 holds a pre-computed"}, {"sha": "38ef07c0a0f75901be151f3bd2c42bf1198faa05", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=96592eeda1f5cb381d91ef78dea3e2666bbdb7b5", "patch": "@@ -11286,7 +11286,7 @@ do_store_flag (sepops ops, rtx target, machine_mode mode)\n     {\n       tree ifexp = build2 (ops->code, ops->type, arg0, arg1);\n       if (VECTOR_BOOLEAN_TYPE_P (ops->type)\n-\t  && expand_vec_cmp_expr_p (TREE_TYPE (arg0), ops->type))\n+\t  && expand_vec_cmp_expr_p (TREE_TYPE (arg0), ops->type, ops->code))\n \treturn expand_vec_cmp_expr (ops->type, ifexp, target);\n       else\n \t{"}, {"sha": "840dc791bac02a909e959dd4e9e1a5515852f9c7", "filename": "gcc/optabs-query.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Foptabs-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Foptabs-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.h?ref=96592eeda1f5cb381d91ef78dea3e2666bbdb7b5", "patch": "@@ -90,6 +90,15 @@ get_vec_cmp_icode (machine_mode vmode, machine_mode mask_mode, bool uns)\n   return convert_optab_handler (tab, vmode, mask_mode);\n }\n \n+/* Return insn code for a comparison operator with VMODE\n+   resultin MASK_MODE (only for EQ/NE).  */\n+\n+static inline enum insn_code\n+get_vec_cmp_eq_icode (machine_mode vmode, machine_mode mask_mode)\n+{\n+  return convert_optab_handler (vec_cmpeq_optab, vmode, mask_mode);\n+}\n+\n /* Return insn code for a conditional operator with a comparison in\n    mode CMODE, unsigned if UNS is true, resulting in a value of mode VMODE.  */\n \n@@ -113,6 +122,15 @@ get_vcond_mask_icode (machine_mode vmode, machine_mode mmode)\n   return convert_optab_handler (vcond_mask_optab, vmode, mmode);\n }\n \n+/* Return insn code for a conditional operator with a comparison in\n+   mode CMODE (only EQ/NE), resulting in a value of mode VMODE.  */\n+\n+static inline enum insn_code\n+get_vcond_eq_icode (machine_mode vmode, machine_mode cmode)\n+{\n+  return convert_optab_handler (vcondeq_optab, vmode, cmode);\n+}\n+\n /* Enumerates the possible extraction_insn operations.  */\n enum extraction_pattern { EP_insv, EP_extv, EP_extzv };\n "}, {"sha": "28f53448d26eb2247a404a6c59be144a6c31a131", "filename": "gcc/optabs-tree.c", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Foptabs-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Foptabs-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.c?ref=96592eeda1f5cb381d91ef78dea3e2666bbdb7b5", "patch": "@@ -305,20 +305,24 @@ supportable_convert_operation (enum tree_code code,\n    and resulting mask with MASK_TYPE.  */\n \n bool\n-expand_vec_cmp_expr_p (tree value_type, tree mask_type)\n+expand_vec_cmp_expr_p (tree value_type, tree mask_type, enum tree_code code)\n {\n-  enum insn_code icode = get_vec_cmp_icode (TYPE_MODE (value_type),\n-\t\t\t\t\t    TYPE_MODE (mask_type),\n-\t\t\t\t\t    TYPE_UNSIGNED (value_type));\n-  return (icode != CODE_FOR_nothing);\n+  if (get_vec_cmp_icode (TYPE_MODE (value_type), TYPE_MODE (mask_type),\n+\t\t\t TYPE_UNSIGNED (value_type)) != CODE_FOR_nothing)\n+    return true;\n+  if ((code == EQ_EXPR || code == NE_EXPR)\n+      && (get_vec_cmp_eq_icode (TYPE_MODE (value_type), TYPE_MODE (mask_type))\n+\t  != CODE_FOR_nothing))\n+    return true;\n+  return false;\n }\n \n /* Return TRUE iff, appropriate vector insns are available\n    for vector cond expr with vector type VALUE_TYPE and a comparison\n    with operand vector types in CMP_OP_TYPE.  */\n \n bool\n-expand_vec_cond_expr_p (tree value_type, tree cmp_op_type)\n+expand_vec_cond_expr_p (tree value_type, tree cmp_op_type, enum tree_code code)\n {\n   machine_mode value_mode = TYPE_MODE (value_type);\n   machine_mode cmp_op_mode = TYPE_MODE (cmp_op_type);\n@@ -328,10 +332,16 @@ expand_vec_cond_expr_p (tree value_type, tree cmp_op_type)\n     return true;\n \n   if (GET_MODE_SIZE (value_mode) != GET_MODE_SIZE (cmp_op_mode)\n-      || GET_MODE_NUNITS (value_mode) != GET_MODE_NUNITS (cmp_op_mode)\n-      || get_vcond_icode (TYPE_MODE (value_type), TYPE_MODE (cmp_op_type),\n-\t\t\t  TYPE_UNSIGNED (cmp_op_type)) == CODE_FOR_nothing)\n+      || GET_MODE_NUNITS (value_mode) != GET_MODE_NUNITS (cmp_op_mode))\n     return false;\n+\n+  if (get_vcond_icode (TYPE_MODE (value_type), TYPE_MODE (cmp_op_type),\n+\t\t       TYPE_UNSIGNED (cmp_op_type)) == CODE_FOR_nothing\n+      && ((code != EQ_EXPR && code != NE_EXPR)\n+\t  || get_vcond_eq_icode (TYPE_MODE (value_type),\n+\t\t\t\t TYPE_MODE (cmp_op_type)) == CODE_FOR_nothing))\n+    return false;\n+\n   return true;\n }\n "}, {"sha": "db7294394d12a589861ffebfa047eee660f15074", "filename": "gcc/optabs-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Foptabs-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Foptabs-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.h?ref=96592eeda1f5cb381d91ef78dea3e2666bbdb7b5", "patch": "@@ -38,8 +38,8 @@ enum optab_subtype\n optab optab_for_tree_code (enum tree_code, const_tree, enum optab_subtype);\n bool supportable_convert_operation (enum tree_code, tree, tree, tree *,\n \t\t\t\t    enum tree_code *);\n-bool expand_vec_cmp_expr_p (tree, tree);\n-bool expand_vec_cond_expr_p (tree, tree);\n+bool expand_vec_cmp_expr_p (tree, tree, enum tree_code);\n+bool expand_vec_cond_expr_p (tree, tree, enum tree_code);\n void init_tree_optimization_optabs (tree);\n \n #endif"}, {"sha": "a4d7a5e8e46f4489de1dcc4c9894b2f1d9961864", "filename": "gcc/optabs.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=96592eeda1f5cb381d91ef78dea3e2666bbdb7b5", "patch": "@@ -5636,7 +5636,12 @@ expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n \n   icode = get_vcond_icode (mode, cmp_op_mode, unsignedp);\n   if (icode == CODE_FOR_nothing)\n-    return 0;\n+    {\n+      if (tcode == EQ_EXPR || tcode == NE_EXPR)\n+\ticode = get_vcond_eq_icode (mode, cmp_op_mode);\n+      if (icode == CODE_FOR_nothing)\n+\treturn 0;\n+    }\n \n   comparison = vector_compare_rtx (tcode, op0a, op0b, unsignedp, icode, 4);\n   rtx_op1 = expand_normal (op1);\n@@ -5675,7 +5680,12 @@ expand_vec_cmp_expr (tree type, tree exp, rtx target)\n \n   icode = get_vec_cmp_icode (vmode, mask_mode, unsignedp);\n   if (icode == CODE_FOR_nothing)\n-    return 0;\n+    {\n+      if (tcode == EQ_EXPR || tcode == NE_EXPR)\n+\ticode = get_vec_cmp_eq_icode (vmode, mask_mode);\n+      if (icode == CODE_FOR_nothing)\n+\treturn 0;\n+    }\n \n   comparison = vector_compare_rtx (tcode, op0a, op0b, unsignedp, icode, 2);\n   create_output_operand (&ops[0], target, mask_mode);"}, {"sha": "f97b5f054ff9448916a9a8efdb057d56fbe0090b", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=96592eeda1f5cb381d91ef78dea3e2666bbdb7b5", "patch": "@@ -82,9 +82,11 @@ OPTAB_CD(vec_load_lanes_optab, \"vec_load_lanes$a$b\")\n OPTAB_CD(vec_store_lanes_optab, \"vec_store_lanes$a$b\")\n OPTAB_CD(vcond_optab, \"vcond$a$b\")\n OPTAB_CD(vcondu_optab, \"vcondu$a$b\")\n+OPTAB_CD(vcondeq_optab, \"vcondeq$a$b\")\n OPTAB_CD(vcond_mask_optab, \"vcond_mask_$a$b\")\n OPTAB_CD(vec_cmp_optab, \"vec_cmp$a$b\")\n OPTAB_CD(vec_cmpu_optab, \"vec_cmpu$a$b\")\n+OPTAB_CD(vec_cmpeq_optab, \"vec_cmpeq$a$b\")\n OPTAB_CD(maskload_optab, \"maskload$a$b\")\n OPTAB_CD(maskstore_optab, \"maskstore$a$b\")\n "}, {"sha": "f985dba11764cb640b394c132becfffda46524df", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=96592eeda1f5cb381d91ef78dea3e2666bbdb7b5", "patch": "@@ -1,3 +1,8 @@\n+2016-10-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/78102\n+\t* gcc.target/i386/pr78102.c: New test.\n+\n 2016-10-25  Fritz Reese <fritzoreese@gmail.com>\n \n \t* gfortran.dg/dec_logical_xor_1.f90: New test."}, {"sha": "0fc3326e65a8f363a159a7647285735b3e97f4ca", "filename": "gcc/testsuite/gcc.target/i386/pr78102.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr78102.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr78102.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr78102.c?ref=96592eeda1f5cb381d91ef78dea3e2666bbdb7b5", "patch": "@@ -0,0 +1,24 @@\n+/* PR target/78102 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mno-sse4.2 -msse4.1\" } */\n+/* { dg-final { scan-assembler-times \"pcmpeqq\" 3 } } */\n+\n+#include <x86intrin.h>\n+\n+__m128i\n+foo (const __m128i x, const __m128i y)\n+{\n+  return _mm_cmpeq_epi64 (x, y);\n+}\n+\n+__v2di\n+bar (const __v2di x, const __v2di y)\n+{\n+  return x == y;\n+}\n+\n+__v2di\n+baz (const __v2di x, const __v2di y)\n+{\n+  return x != y;\n+}"}, {"sha": "b0b37c7b2a8147baf561b582b5b0cf8f9cd5cafe", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=96592eeda1f5cb381d91ef78dea3e2666bbdb7b5", "patch": "@@ -356,8 +356,8 @@ expand_vector_comparison (gimple_stmt_iterator *gsi, tree type, tree op0,\n                           tree op1, enum tree_code code)\n {\n   tree t;\n-  if (!expand_vec_cmp_expr_p (TREE_TYPE (op0), type)\n-      && !expand_vec_cond_expr_p (type, TREE_TYPE (op0)))\n+  if (!expand_vec_cmp_expr_p (TREE_TYPE (op0), type, code)\n+      && !expand_vec_cond_expr_p (type, TREE_TYPE (op0), code))\n     t = expand_vector_piecewise (gsi, do_compare, type,\n \t\t\t\t TREE_TYPE (TREE_TYPE (op0)), op0, op1, code);\n   else\n@@ -630,7 +630,7 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \t\t}\n \t    }\n \t  if (addend == NULL_TREE\n-\t      && expand_vec_cond_expr_p (type, type))\n+\t      && expand_vec_cond_expr_p (type, type, LT_EXPR))\n \t    {\n \t      tree zero, cst, cond, mask_type;\n \t      gimple *stmt;\n@@ -878,7 +878,7 @@ expand_vector_condition (gimple_stmt_iterator *gsi)\n       comp_inner_type = TREE_TYPE (TREE_TYPE (a1));\n     }\n \n-  if (expand_vec_cond_expr_p (type, TREE_TYPE (a1)))\n+  if (expand_vec_cond_expr_p (type, TREE_TYPE (a1), TREE_CODE (a)))\n     return;\n \n   /* TODO: try and find a smaller vector type.  */"}, {"sha": "835d9b52a657f092bed4bf9193f3f8e1514bf5ec", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=96592eeda1f5cb381d91ef78dea3e2666bbdb7b5", "patch": "@@ -3073,7 +3073,7 @@ vect_recog_mixed_size_cond_pattern (vec<gimple *> *stmts, tree *type_in,\n   if (vectype == NULL_TREE)\n     return NULL;\n \n-  if (expand_vec_cond_expr_p (vectype, comp_vectype))\n+  if (expand_vec_cond_expr_p (vectype, comp_vectype, TREE_CODE (cond_expr)))\n     return NULL;\n \n   if (itype == NULL_TREE)\n@@ -3088,7 +3088,7 @@ vect_recog_mixed_size_cond_pattern (vec<gimple *> *stmts, tree *type_in,\n   if (vecitype == NULL_TREE)\n     return NULL;\n \n-  if (!expand_vec_cond_expr_p (vecitype, comp_vectype))\n+  if (!expand_vec_cond_expr_p (vecitype, comp_vectype, TREE_CODE (cond_expr)))\n     return NULL;\n \n   if (GET_MODE_BITSIZE (TYPE_MODE (type)) > cmp_mode_size)\n@@ -3195,7 +3195,7 @@ check_bool_pattern (tree var, vec_info *vinfo, hash_set<gimple *> &stmts)\n \n \t  tree mask_type = get_mask_type_for_scalar_type (TREE_TYPE (rhs1));\n \t  if (mask_type\n-\t      && expand_vec_cmp_expr_p (comp_vectype, mask_type))\n+\t      && expand_vec_cmp_expr_p (comp_vectype, mask_type, rhs_code))\n \t    return false;\n \n \t  if (TREE_CODE (TREE_TYPE (rhs1)) != INTEGER_TYPE)\n@@ -3209,7 +3209,7 @@ check_bool_pattern (tree var, vec_info *vinfo, hash_set<gimple *> &stmts)\n \t    }\n \t  else\n \t    vecitype = comp_vectype;\n-\t  if (! expand_vec_cond_expr_p (vecitype, comp_vectype))\n+\t  if (! expand_vec_cond_expr_p (vecitype, comp_vectype, rhs_code))\n \t    return false;\n \t}\n       else\n@@ -3537,7 +3537,7 @@ search_type_for_mask_1 (tree var, vec_info *vinfo,\n \n \t  mask_type = get_mask_type_for_scalar_type (TREE_TYPE (rhs1));\n \t  if (!mask_type\n-\t      || !expand_vec_cmp_expr_p (comp_vectype, mask_type))\n+\t      || !expand_vec_cmp_expr_p (comp_vectype, mask_type, rhs_code))\n \t    {\n \t      res = NULL_TREE;\n \t      break;"}, {"sha": "1d17156b0b613ecc194767575fbfe6441f3dedd0", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96592eeda1f5cb381d91ef78dea3e2666bbdb7b5/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=96592eeda1f5cb381d91ef78dea3e2666bbdb7b5", "patch": "@@ -7710,7 +7710,8 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (!vec_stmt)\n     {\n       STMT_VINFO_TYPE (stmt_info) = condition_vec_info_type;\n-      return expand_vec_cond_expr_p (vectype, comp_vectype);\n+      return expand_vec_cond_expr_p (vectype, comp_vectype,\n+\t\t\t\t     TREE_CODE (cond_expr));\n     }\n \n   /* Transform.  */\n@@ -8013,7 +8014,7 @@ vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n       vect_model_simple_cost (stmt_info, ncopies * (1 + (bitop2 != NOP_EXPR)),\n \t\t\t      dts, NULL, NULL);\n       if (bitop1 == NOP_EXPR)\n-\treturn expand_vec_cmp_expr_p (vectype, mask_type);\n+\treturn expand_vec_cmp_expr_p (vectype, mask_type, code);\n       else\n \t{\n \t  machine_mode mode = TYPE_MODE (vectype);"}]}