{"sha": "37bb27091e33696b16044d58b41fe0ba405de588", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdiYjI3MDkxZTMzNjk2YjE2MDQ0ZDU4YjQxZmUwYmE0MDVkZTU4OA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-06-06T07:33:57Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-06-06T07:33:57Z"}, "message": "flow.c (mark_used_reg): Clean up looping over multiple hard registers.\n\n        * flow.c (mark_used_reg): Clean up looping over multiple hard\n        registers.  Do conditional life bits across multiple hard regs.\n\nFrom-SVN: r42942", "tree": {"sha": "f2a23bac2cab30bfa3e958e4488b32075c316ed4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2a23bac2cab30bfa3e958e4488b32075c316ed4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37bb27091e33696b16044d58b41fe0ba405de588", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37bb27091e33696b16044d58b41fe0ba405de588", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37bb27091e33696b16044d58b41fe0ba405de588", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37bb27091e33696b16044d58b41fe0ba405de588/comments", "author": null, "committer": null, "parents": [{"sha": "e7580d2ee7b7b49f6d1d9908df04dff533eea1b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7580d2ee7b7b49f6d1d9908df04dff533eea1b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7580d2ee7b7b49f6d1d9908df04dff533eea1b4"}], "stats": {"total": 210, "additions": 95, "deletions": 115}, "files": [{"sha": "7b7b76a3494df8d6bfafcc97dcf9f7cf12ca0755", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37bb27091e33696b16044d58b41fe0ba405de588/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37bb27091e33696b16044d58b41fe0ba405de588/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=37bb27091e33696b16044d58b41fe0ba405de588", "patch": "@@ -1,3 +1,8 @@\n+2001-06-06  Richard Henderson  <rth@redhat.com>\n+\n+\t* flow.c (mark_used_reg): Clean up looping over multiple hard\n+\tregisters.  Do conditional life bits across multiple hard regs.\n+\n 2001-06-05  Jeffrey D. Oldham  <oldham@codesourcery.com>\n \n \t* reload1.c (reload): Revert Schmidt's change so all USEs are not"}, {"sha": "2567926f257b4c0d3311be9af541fc82d13d05c5", "filename": "gcc/flow.c", "status": "modified", "additions": 90, "deletions": 115, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37bb27091e33696b16044d58b41fe0ba405de588/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37bb27091e33696b16044d58b41fe0ba405de588/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=37bb27091e33696b16044d58b41fe0ba405de588", "patch": "@@ -5592,35 +5592,37 @@ mark_used_reg (pbi, reg, cond, insn)\n      rtx cond ATTRIBUTE_UNUSED;\n      rtx insn;\n {\n-  int regno = REGNO (reg);\n-  int some_was_live = REGNO_REG_SET_P (pbi->reg_live, regno);\n-  int some_was_dead = ! some_was_live;\n-  int some_not_set;\n-  int n;\n+  unsigned int regno_first, regno_last, i;\n+  int some_was_live, some_was_dead, some_not_set;\n \n-  /* A hard reg in a wide mode may really be multiple registers.\n-     If so, mark all of them just like the first.  */\n-  if (regno < FIRST_PSEUDO_REGISTER)\n+  regno_last = regno_first = REGNO (reg);\n+  if (regno_first < FIRST_PSEUDO_REGISTER)\n+    regno_last += HARD_REGNO_NREGS (regno_first, GET_MODE (reg)) - 1;\n+\n+  /* Find out if any of this register is live after this instruction.  */\n+  some_was_live = some_was_dead = 0;\n+  for (i = regno_first; i <= regno_last; ++i)\n     {\n-      n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-      while (--n > 0)\n-\t{\n-\t  int needed_regno = REGNO_REG_SET_P (pbi->reg_live, regno + n);\n-\t  some_was_live |= needed_regno;\n-\t  some_was_dead |= ! needed_regno;\n-\t}\n+      int needed_regno = REGNO_REG_SET_P (pbi->reg_live, i);\n+      some_was_live |= needed_regno;\n+      some_was_dead |= ! needed_regno;\n     }\n \n+  /* Find out if any of the register was set this insn.  */\n+  some_not_set = 0;\n+  for (i = regno_first; i <= regno_last; ++i)\n+    some_not_set |= ! REGNO_REG_SET_P (pbi->new_set, i);\n+\n   if (pbi->flags & (PROP_LOG_LINKS | PROP_AUTOINC))\n     {\n       /* Record where each reg is used, so when the reg is set we know\n \t the next insn that uses it.  */\n-      pbi->reg_next_use[regno] = insn;\n+      pbi->reg_next_use[regno_first] = insn;\n     }\n \n   if (pbi->flags & PROP_REG_INFO)\n     {\n-      if (regno < FIRST_PSEUDO_REGISTER)\n+      if (regno_first < FIRST_PSEUDO_REGISTER)\n \t{\n \t  /* If this is a register we are going to try to eliminate,\n \t     don't mark it live here.  If we are successful in\n@@ -5634,41 +5636,28 @@ mark_used_reg (pbi, reg, cond, insn)\n \t     register to itself.  This should be fixed.  In the mean\n \t     time, hack around it.  */\n \n-\t  if (! (TEST_HARD_REG_BIT (elim_reg_set, regno)\n-\t         && (regno == FRAME_POINTER_REGNUM\n-\t\t     || regno == ARG_POINTER_REGNUM)))\n-\t    {\n-\t      int n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-\t      do\n-\t\tregs_ever_live[regno + --n] = 1;\n-\t      while (n > 0);\n-\t    }\n+\t  if (! (TEST_HARD_REG_BIT (elim_reg_set, regno_first)\n+\t         && (regno_first == FRAME_POINTER_REGNUM\n+\t\t     || regno_first == ARG_POINTER_REGNUM)))\n+\t    for (i = regno_first; i <= regno_last; ++i)\n+\t      regs_ever_live[i] = 1;\n \t}\n       else\n \t{\n \t  /* Keep track of which basic block each reg appears in.  */\n \n \t  register int blocknum = pbi->bb->index;\n-\t  if (REG_BASIC_BLOCK (regno) == REG_BLOCK_UNKNOWN)\n-\t    REG_BASIC_BLOCK (regno) = blocknum;\n-\t  else if (REG_BASIC_BLOCK (regno) != blocknum)\n-\t    REG_BASIC_BLOCK (regno) = REG_BLOCK_GLOBAL;\n+\t  if (REG_BASIC_BLOCK (regno_first) == REG_BLOCK_UNKNOWN)\n+\t    REG_BASIC_BLOCK (regno_first) = blocknum;\n+\t  else if (REG_BASIC_BLOCK (regno_first) != blocknum)\n+\t    REG_BASIC_BLOCK (regno_first) = REG_BLOCK_GLOBAL;\n \n \t  /* Count (weighted) number of uses of each reg.  */\n-\t  REG_N_REFS (regno) += (optimize_size ? 1\n-\t\t\t\t : pbi->bb->loop_depth + 1);\n+\t  REG_N_REFS (regno_first)\n+\t    += (optimize_size ? 1 : pbi->bb->loop_depth + 1);\n \t}\n     }\n \n-  /* Find out if any of the register was set this insn.  */\n-  some_not_set = ! REGNO_REG_SET_P (pbi->new_set, regno);\n-  if (regno < FIRST_PSEUDO_REGISTER)\n-    {\n-      n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-      while (--n > 0)\n-\tsome_not_set |= ! REGNO_REG_SET_P (pbi->new_set, regno + n);\n-    }\n-\n   /* Record and count the insns in which a reg dies.  If it is used in\n      this insn and was dead below the insn then it dies in this insn.\n      If it was set in this insn, we do not make a REG_DEAD note;\n@@ -5679,116 +5668,102 @@ mark_used_reg (pbi, reg, cond, insn)\n     {\n       /* Check for the case where the register dying partially\n \t overlaps the register set by this insn.  */\n-      if (regno < FIRST_PSEUDO_REGISTER\n-\t  && HARD_REGNO_NREGS (regno, GET_MODE (reg)) > 1)\n-\t{\n-\t  n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-\t  while (--n >= 0)\n-\t    some_was_live |= REGNO_REG_SET_P (pbi->new_set, regno + n);\n-\t}\n+      if (regno_first != regno_last)\n+\tfor (i = regno_first; i <= regno_last; ++i)\n+\t  some_was_live |= REGNO_REG_SET_P (pbi->new_set, i);\n \n       /* If none of the words in X is needed, make a REG_DEAD note.\n \t Otherwise, we must make partial REG_DEAD notes.  */\n       if (! some_was_live)\n \t{\n \t  if ((pbi->flags & PROP_DEATH_NOTES)\n-\t      && ! find_regno_note (insn, REG_DEAD, regno))\n+\t      && ! find_regno_note (insn, REG_DEAD, regno_first))\n \t    REG_NOTES (insn)\n \t      = alloc_EXPR_LIST (REG_DEAD, reg, REG_NOTES (insn));\n \n \t  if (pbi->flags & PROP_REG_INFO)\n-\t    REG_N_DEATHS (regno)++;\n+\t    REG_N_DEATHS (regno_first)++;\n \t}\n       else\n \t{\n \t  /* Don't make a REG_DEAD note for a part of a register\n \t     that is set in the insn.  */\n-\n-\t  n = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg)) - 1;\n-\t  for (; n >= regno; n--)\n-\t    if (! REGNO_REG_SET_P (pbi->reg_live, n)\n-\t\t&& ! dead_or_set_regno_p (insn, n))\n+\t  for (i = regno_first; i <= regno_last; ++i)\n+\t    if (! REGNO_REG_SET_P (pbi->reg_live, i)\n+\t\t&& ! dead_or_set_regno_p (insn, i))\n \t      REG_NOTES (insn)\n \t\t= alloc_EXPR_LIST (REG_DEAD,\n-\t\t\t\t   gen_rtx_REG (reg_raw_mode[n], n),\n+\t\t\t\t   gen_rtx_REG (reg_raw_mode[i], i),\n \t\t\t\t   REG_NOTES (insn));\n \t}\n     }\n \n-  SET_REGNO_REG_SET (pbi->reg_live, regno);\n-  if (regno < FIRST_PSEUDO_REGISTER)\n+  /* Mark the register as being live.  */\n+  for (i = regno_first; i <= regno_last; ++i)\n     {\n-      n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-      while (--n > 0)\n-\tSET_REGNO_REG_SET (pbi->reg_live, regno + n);\n-    }\n+      SET_REGNO_REG_SET (pbi->reg_live, i);\n \n #ifdef HAVE_conditional_execution\n-  /* If this is a conditional use, record that fact.  If it is later\n-     conditionally set, we'll know to kill the register.  */\n-  if (cond != NULL_RTX)\n-    {\n-      splay_tree_node node;\n-      struct reg_cond_life_info *rcli;\n-      rtx ncond;\n-\n-      if (some_was_live)\n+      /* If this is a conditional use, record that fact.  If it is later\n+\t conditionally set, we'll know to kill the register.  */\n+      if (cond != NULL_RTX)\n \t{\n-\t  node = splay_tree_lookup (pbi->reg_cond_dead, regno);\n-\t  if (node == NULL)\n-\t    {\n-\t      /* The register was unconditionally live previously.\n-\t\t No need to do anything.  */\n-\t    }\n-\t  else\n+\t  splay_tree_node node;\n+\t  struct reg_cond_life_info *rcli;\n+\t  rtx ncond;\n+\n+\t  if (some_was_live)\n \t    {\n-\t      /* The register was conditionally live previously.\n-\t\t Subtract the new life cond from the old death cond.  */\n-\t      rcli = (struct reg_cond_life_info *) node->value;\n-\t      ncond = rcli->condition;\n-\t      ncond = and_reg_cond (ncond, not_reg_cond (cond), 1);\n-\n-\t      /* If the register is now unconditionally live, remove the\n-\t\t entry in the splay_tree.  */\n-\t      if (ncond == const0_rtx)\n-\t\tsplay_tree_remove (pbi->reg_cond_dead, regno);\n+\t      node = splay_tree_lookup (pbi->reg_cond_dead, i);\n+\t      if (node == NULL)\n+\t\t{\n+\t\t  /* The register was unconditionally live previously.\n+\t\t     No need to do anything.  */\n+\t\t}\n \t      else\n \t\t{\n-\t\t  rcli->condition = ncond;\n-\t\t  SET_REGNO_REG_SET (pbi->reg_cond_reg, REGNO (XEXP (cond, 0)));\n+\t\t  /* The register was conditionally live previously.\n+\t\t     Subtract the new life cond from the old death cond.  */\n+\t\t  rcli = (struct reg_cond_life_info *) node->value;\n+\t\t  ncond = rcli->condition;\n+\t\t  ncond = and_reg_cond (ncond, not_reg_cond (cond), 1);\n+\n+\t\t  /* If the register is now unconditionally live,\n+\t\t     remove the entry in the splay_tree.  */\n+\t\t  if (ncond == const0_rtx)\n+\t\t    splay_tree_remove (pbi->reg_cond_dead, i);\n+\t\t  else\n+\t\t    {\n+\t\t      rcli->condition = ncond;\n+\t\t      SET_REGNO_REG_SET (pbi->reg_cond_reg,\n+\t\t\t\t\t REGNO (XEXP (cond, 0)));\n+\t\t    }\n \t\t}\n \t    }\n-\t}\n-      else\n-\t{\n-\t  /* The register was not previously live at all.  Record\n-\t     the condition under which it is still dead.  */\n-\t  rcli = (struct reg_cond_life_info *) xmalloc (sizeof (*rcli));\n-\t  rcli->condition = not_reg_cond (cond);\n-\t  rcli->stores = const0_rtx;\n-\t  rcli->orig_condition = const0_rtx;\n-\t  splay_tree_insert (pbi->reg_cond_dead, regno,\n-\t\t\t     (splay_tree_value) rcli);\n+\t  else\n+\t    {\n+\t      /* The register was not previously live at all.  Record\n+\t\t the condition under which it is still dead.  */\n+\t      rcli = (struct reg_cond_life_info *) xmalloc (sizeof (*rcli));\n+\t      rcli->condition = not_reg_cond (cond);\n+\t      rcli->stores = const0_rtx;\n+\t      rcli->orig_condition = const0_rtx;\n+\t      splay_tree_insert (pbi->reg_cond_dead, i,\n+\t\t\t\t (splay_tree_value) rcli);\n \n-\t  SET_REGNO_REG_SET (pbi->reg_cond_reg, REGNO (XEXP (cond, 0)));\n+\t      SET_REGNO_REG_SET (pbi->reg_cond_reg, REGNO (XEXP (cond, 0)));\n+\t    }\n \t}\n-    }\n-  else if (some_was_live)\n-    {\n-      splay_tree_node node;\n-\n-      node = splay_tree_lookup (pbi->reg_cond_dead, regno);\n-      if (node != NULL)\n+      else if (some_was_live)\n \t{\n-\t  /* The register was conditionally live previously, but is now\n-\t     unconditionally so.  Remove it from the conditionally dead\n-\t     list, so that a conditional set won't cause us to think\n+\t  /* The register may have been conditionally live previously, but\n+\t     is now unconditionally live.  Remove it from the conditionally\n+\t     dead list, so that a conditional set won't cause us to think\n \t     it dead.  */\n-\t  splay_tree_remove (pbi->reg_cond_dead, regno);\n+\t  splay_tree_remove (pbi->reg_cond_dead, i);\n \t}\n-    }\n-\n #endif\n+    }\n }\n \n /* Scan expression X and store a 1-bit in NEW_LIVE for each reg it uses."}]}