{"sha": "67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdmNTg5NDRhNzVlYWY5YzE5M2RjNzA0ZjgxMjhiZmFhZjZjM2MzYQ==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2015-04-18T18:13:18Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2015-04-18T18:13:18Z"}, "message": "remove need for store_values_directly\n\nThis switches all hash_table users to use the layout that stores\nelements of type value_type in the hash table instead of the one storing\nvalue_type *.  Since it becomes unused support for the value_type *\nlayout is removed.\n\ngcc/\n\n\t* hash-table.h: Remove version of hash_table that stored value_type *.\n\t* asan.c, attribs.c, bitmap.c, cfg.c, cgraph.h, config/arm/arm.c,\n\tconfig/i386/winnt.c, config/ia64/ia64.c, config/mips/mips.c,\n\tconfig/sol2.c, coverage.c, cselib.c, dse.c, dwarf2cfi.c,\n\tdwarf2out.c, except.c, gcse.c, genmatch.c, ggc-common.c,\n\tgimple-ssa-strength-reduction.c, gimplify.c, haifa-sched.c,\n\thard-reg-set.h, hash-map.h, hash-set.h, ipa-devirt.c, ipa-icf.h,\n\tipa-profile.c, ira-color.c, ira-costs.c, loop-invariant.c,\n\tloop-iv.c, loop-unroll.c, lto-streamer.h, plugin.c, postreload-gcse.c,\n\treginfo.c, statistics.c, store-motion.c, trans-mem.c, tree-cfg.c,\n\ttree-eh.c, tree-hasher.h, tree-into-ssa.c, tree-parloops.c,\n\ttree-sra.c, tree-ssa-coalesce.c, tree-ssa-dom.c, tree-ssa-live.c,\n\ttree-ssa-loop-im.c, tree-ssa-loop-ivopts.c, tree-ssa-phiopt.c,\n\ttree-ssa-pre.c, tree-ssa-reassoc.c, tree-ssa-sccvn.c,\n\ttree-ssa-structalias.c, tree-ssa-tail-merge.c,\n\ttree-ssa-threadupdate.c, tree-vectorizer.c, tree-vectorizer.h,\n\tvaltrack.h, var-tracking.c, vtable-verify.c, vtable-verify.h: Adjust.\n\nlibcc1/\n\n\t* plugin.cc: Adjust for hash_table changes.\n\ngcc/java/\n\n\t* jcf-io.c: Adjust for hash_table changes.\n\ngcc/lto/\n\n\t* lto.c: Adjust for hash_table changes.\n\ngcc/objc/\n\n\t* objc-act.c: Adjust for hash_table changes.\n\nFrom-SVN: r222213", "tree": {"sha": "371c9ad12b94f56f0112c4fda736391f1925a309", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/371c9ad12b94f56f0112c4fda736391f1925a309"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/comments", "author": null, "committer": null, "parents": [{"sha": "b9923c3538dbd24c38a86ff49c7e3895c6c22873", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9923c3538dbd24c38a86ff49c7e3895c6c22873", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9923c3538dbd24c38a86ff49c7e3895c6c22873"}], "stats": {"total": 1745, "additions": 633, "deletions": 1112}, "files": [{"sha": "f29a5c8519061d2f104a44fea473ac8afc21089f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -1,3 +1,23 @@\n+2015-04-18  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* hash-table.h: Remove version of hash_table that stored value_type *.\n+\t* asan.c, attribs.c, bitmap.c, cfg.c, cgraph.h, config/arm/arm.c,\n+\tconfig/i386/winnt.c, config/ia64/ia64.c, config/mips/mips.c,\n+\tconfig/sol2.c, coverage.c, cselib.c, dse.c, dwarf2cfi.c,\n+\tdwarf2out.c, except.c, gcse.c, genmatch.c, ggc-common.c,\n+\tgimple-ssa-strength-reduction.c, gimplify.c, haifa-sched.c,\n+\thard-reg-set.h, hash-map.h, hash-set.h, ipa-devirt.c, ipa-icf.h,\n+\tipa-profile.c, ira-color.c, ira-costs.c, loop-invariant.c,\n+\tloop-iv.c, loop-unroll.c, lto-streamer.h, plugin.c, postreload-gcse.c,\n+\treginfo.c, statistics.c, store-motion.c, trans-mem.c, tree-cfg.c,\n+\ttree-eh.c, tree-hasher.h, tree-into-ssa.c, tree-parloops.c,\n+\ttree-sra.c, tree-ssa-coalesce.c, tree-ssa-dom.c, tree-ssa-live.c,\n+\ttree-ssa-loop-im.c, tree-ssa-loop-ivopts.c, tree-ssa-phiopt.c,\n+\ttree-ssa-pre.c, tree-ssa-reassoc.c, tree-ssa-sccvn.c,\n+\ttree-ssa-structalias.c, tree-ssa-tail-merge.c,\n+\ttree-ssa-threadupdate.c, tree-vectorizer.c, tree-vectorizer.h,\n+\tvaltrack.h, var-tracking.c, vtable-verify.c, vtable-verify.h: Adjust.\n+\n 2015-04-17  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \tPR target/65787"}, {"sha": "cd6ccdc90706a80832961ea5c508b6b3e476e276", "filename": "gcc/asan.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -435,11 +435,11 @@ asan_mem_ref_get_end (const asan_mem_ref *ref, tree len)\n struct asan_mem_ref_hasher\n   : typed_noop_remove <asan_mem_ref>\n {\n-  typedef asan_mem_ref value_type;\n-  typedef asan_mem_ref compare_type;\n+  typedef asan_mem_ref *value_type;\n+  typedef asan_mem_ref *compare_type;\n \n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  static inline hashval_t hash (const asan_mem_ref *);\n+  static inline bool equal (const asan_mem_ref *, const asan_mem_ref *);\n };\n \n /* Hash a memory reference.  */"}, {"sha": "7b7e2a9af1bc675c4ca72960f12e1af52dbf1ddf", "filename": "gcc/attribs.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -67,21 +67,21 @@ substring_hash (const char *str, int l)\n \n struct attribute_hasher : typed_noop_remove <attribute_spec>\n {\n-  typedef attribute_spec value_type;\n-  typedef substring compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef attribute_spec *value_type;\n+  typedef substring *compare_type;\n+  static inline hashval_t hash (const attribute_spec *);\n+  static inline bool equal (const attribute_spec *, const substring *);\n };\n \n inline hashval_t\n-attribute_hasher::hash (const value_type *spec)\n+attribute_hasher::hash (const attribute_spec *spec)\n {\n   const int l = strlen (spec->name);\n   return substring_hash (spec->name, l);\n }\n \n inline bool\n-attribute_hasher::equal (const value_type *spec, const compare_type *str)\n+attribute_hasher::equal (const attribute_spec *spec, const substring *str)\n {\n   return (strncmp (spec->name, str->str, str->length) == 0\n \t  && !spec->name[str->length]);"}, {"sha": "71d5b112ca837ae8b89d2fa778266342c86acba5", "filename": "gcc/bitmap.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -61,20 +61,20 @@ struct loc\n \n struct bitmap_desc_hasher : typed_noop_remove <bitmap_descriptor_d>\n {\n-  typedef bitmap_descriptor_d value_type;\n-  typedef loc compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef bitmap_descriptor_d *value_type;\n+  typedef loc *compare_type;\n+  static inline hashval_t hash (const bitmap_descriptor_d *);\n+  static inline bool equal (const bitmap_descriptor_d *, const loc *);\n };\n \n inline hashval_t\n-bitmap_desc_hasher::hash (const value_type *d)\n+bitmap_desc_hasher::hash (const bitmap_descriptor_d *d)\n {\n   return htab_hash_pointer (d->file) + d->line;\n }\n \n inline bool\n-bitmap_desc_hasher::equal (const value_type *d, const compare_type *l)\n+bitmap_desc_hasher::equal (const bitmap_descriptor_d *d, const loc *l)\n {\n   return d->file == l->file && d->function == l->function && d->line == l->line;\n }"}, {"sha": "30745001b9eabf8fea4c27e1bb4539256bc1f064", "filename": "gcc/cfg.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -1039,21 +1039,22 @@ struct htab_bb_copy_original_entry\n \n struct bb_copy_hasher : typed_noop_remove <htab_bb_copy_original_entry>\n {\n-  typedef htab_bb_copy_original_entry value_type;\n-  typedef htab_bb_copy_original_entry compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *existing,\n-\t\t\t    const compare_type * candidate);\n+  typedef htab_bb_copy_original_entry *value_type;\n+  typedef htab_bb_copy_original_entry *compare_type;\n+  static inline hashval_t hash (const htab_bb_copy_original_entry *);\n+  static inline bool equal (const htab_bb_copy_original_entry *existing,\n+\t\t\t    const htab_bb_copy_original_entry * candidate);\n };\n \n inline hashval_t\n-bb_copy_hasher::hash (const value_type *data)\n+bb_copy_hasher::hash (const htab_bb_copy_original_entry *data)\n {\n   return data->index1;\n }\n \n inline bool\n-bb_copy_hasher::equal (const value_type *data, const compare_type *data2)\n+bb_copy_hasher::equal (const htab_bb_copy_original_entry *data,\n+\t\t       const htab_bb_copy_original_entry *data2)\n {\n   return data->index1 == data2->index1;\n }"}, {"sha": "29f65a895ff539dcf309b8257bdd5aeddbe4035f", "filename": "gcc/cgraph.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -1872,7 +1872,6 @@ struct asmname_hasher\n {\n   typedef symtab_node *value_type;\n   typedef const_tree compare_type;\n-  typedef int store_values_directly;\n \n   static hashval_t hash (symtab_node *n);\n   static bool equal (symtab_node *n, const_tree t);"}, {"sha": "6826c7886faea33401cc5a37fdd6eaf544417690", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -4897,21 +4897,21 @@ arm_function_value(const_tree type, const_tree func,\n \n struct libcall_hasher : typed_noop_remove <rtx_def>\n {\n-  typedef rtx_def value_type;\n-  typedef rtx_def compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n-  static inline void remove (value_type *);\n+  typedef const rtx_def *value_type;\n+  typedef const rtx_def *compare_type;\n+  static inline hashval_t hash (const rtx_def *);\n+  static inline bool equal (const rtx_def *, const rtx_def *);\n+  static inline void remove (rtx_def *);\n };\n \n inline bool\n-libcall_hasher::equal (const value_type *p1, const compare_type *p2)\n+libcall_hasher::equal (const rtx_def *p1, const rtx_def *p2)\n {\n   return rtx_equal_p (p1, p2);\n }\n \n inline hashval_t\n-libcall_hasher::hash (const value_type *p1)\n+libcall_hasher::hash (const rtx_def *p1)\n {\n   return hash_rtx (p1, VOIDmode, NULL, NULL, FALSE);\n }"}, {"sha": "f61412f7153364421fb28d48b028e2b399763343", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -738,23 +738,23 @@ i386_pe_record_stub (const char *name)\n \n struct wrapped_symbol_hasher : typed_noop_remove <char>\n {\n-  typedef char value_type;\n-  typedef char compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n-  static inline void remove (value_type *);\n+  typedef char *value_type;\n+  typedef char *compare_type;\n+  static inline hashval_t hash (const char *);\n+  static inline bool equal (const char *, const char *);\n+  static inline void remove (char *);\n };\n \n inline hashval_t\n-wrapped_symbol_hasher::hash (const value_type *v)\n+wrapped_symbol_hasher::hash (const char *v)\n {\n   return htab_hash_string (v);\n }\n \n /*  Hash table equality helper function.  */\n \n inline bool\n-wrapped_symbol_hasher::equal (const value_type *x, const compare_type *y)\n+wrapped_symbol_hasher::equal (const char *x, const char *y)\n {\n   return !strcmp (x, y);\n }"}, {"sha": "40e6ebe4c4ed93e4558b009e04bb196609cf7107", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -8609,16 +8609,16 @@ finish_bundle_states (void)\n \n struct bundle_state_hasher : typed_noop_remove <bundle_state>\n {\n-  typedef bundle_state value_type;\n-  typedef bundle_state compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef bundle_state *value_type;\n+  typedef bundle_state *compare_type;\n+  static inline hashval_t hash (const bundle_state *);\n+  static inline bool equal (const bundle_state *, const bundle_state *);\n };\n \n /* The function returns hash of BUNDLE_STATE.  */\n \n inline hashval_t\n-bundle_state_hasher::hash (const value_type *state)\n+bundle_state_hasher::hash (const bundle_state *state)\n {\n   unsigned result, i;\n \n@@ -8631,8 +8631,8 @@ bundle_state_hasher::hash (const value_type *state)\n /* The function returns nonzero if the bundle state keys are equal.  */\n \n inline bool\n-bundle_state_hasher::equal (const value_type *state1,\n-\t\t\t    const compare_type *state2)\n+bundle_state_hasher::equal (const bundle_state *state1,\n+\t\t\t    const bundle_state *state2)\n {\n   return (state1->insn_num == state2->insn_num\n \t  && memcmp (state1->dfa_state, state2->dfa_state,"}, {"sha": "bf69850edf28c459d2d3cbf055e299203d0c3175", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -16381,23 +16381,23 @@ mips_hash_base (rtx base)\n \n struct mips_lo_sum_offset_hasher : typed_free_remove <mips_lo_sum_offset>\n {\n-  typedef mips_lo_sum_offset value_type;\n-  typedef rtx_def compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef mips_lo_sum_offset *value_type;\n+  typedef rtx_def *compare_type;\n+  static inline hashval_t hash (const mips_lo_sum_offset *);\n+  static inline bool equal (const mips_lo_sum_offset *, const rtx_def *);\n };\n \n /* Hash-table callbacks for mips_lo_sum_offsets.  */\n \n inline hashval_t\n-mips_lo_sum_offset_hasher::hash (const value_type *entry)\n+mips_lo_sum_offset_hasher::hash (const mips_lo_sum_offset *entry)\n {\n   return mips_hash_base (entry->base);\n }\n \n inline bool\n-mips_lo_sum_offset_hasher::equal (const value_type *entry,\n-\t\t\t\t  const compare_type *value)\n+mips_lo_sum_offset_hasher::equal (const mips_lo_sum_offset *entry,\n+\t\t\t\t  const rtx_def *value)\n {\n   return rtx_equal_p (entry->base, value);\n }"}, {"sha": "d87c7b4a7df9efb164d6df24d04f6f3ca648d7fa", "filename": "gcc/config/sol2.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fconfig%2Fsol2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fconfig%2Fsol2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsol2.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -183,22 +183,22 @@ typedef struct comdat_entry\n \n struct comdat_entry_hasher : typed_noop_remove <comdat_entry>\n {\n-  typedef comdat_entry value_type;\n-  typedef comdat_entry compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n-  static inline void remove (value_type *);\n+  typedef comdat_entry *value_type;\n+  typedef comdat_entry *compare_type;\n+  static inline hashval_t hash (const comdat_entry *);\n+  static inline bool equal (const comdat_entry *, const comdat_entry *);\n+  static inline void remove (comdat_entry *);\n };\n \n inline hashval_t\n-comdat_entry_hasher::hash (const value_type *entry)\n+comdat_entry_hasher::hash (const comdat_entry *entry)\n {\n   return htab_hash_string (entry->sig);\n }\n \n inline bool\n-comdat_entry_hasher::equal (const value_type *entry1,\n-\t\t\t    const compare_type *entry2)\n+comdat_entry_hasher::equal (const comdat_entry *entry1,\n+\t\t\t    const comdat_entry *entry2)\n {\n   return strcmp (entry1->sig, entry2->sig) == 0;\n }"}, {"sha": "e1d81ff2949fd6129b7e2c9bde611cc2748f72c9", "filename": "gcc/coverage.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -114,11 +114,11 @@ typedef struct counts_entry\n   struct gcov_ctr_summary summary;\n \n   /* hash_table support.  */\n-  typedef counts_entry value_type;\n-  typedef counts_entry compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static int equal (const value_type *, const compare_type *);\n-  static void remove (value_type *);\n+  typedef counts_entry *value_type;\n+  typedef counts_entry *compare_type;\n+  static inline hashval_t hash (const counts_entry *);\n+  static int equal (const counts_entry *, const counts_entry *);\n+  static void remove (counts_entry *);\n } counts_entry_t;\n \n static GTY(()) struct coverage_data *functions_head = 0;\n@@ -197,20 +197,19 @@ get_gcov_unsigned_t (void)\n }\n \f\n inline hashval_t\n-counts_entry::hash (const value_type *entry)\n+counts_entry::hash (const counts_entry *entry)\n {\n   return entry->ident * GCOV_COUNTERS + entry->ctr;\n }\n \n inline int\n-counts_entry::equal (const value_type *entry1,\n-\t\t     const compare_type *entry2)\n+counts_entry::equal (const counts_entry *entry1, const counts_entry *entry2)\n {\n   return entry1->ident == entry2->ident && entry1->ctr == entry2->ctr;\n }\n \n inline void\n-counts_entry::remove (value_type *entry)\n+counts_entry::remove (counts_entry *entry)\n {\n   free (entry->counts);\n   free (entry);"}, {"sha": "30845edb4f6234abef56fa3eb0bc5a0b7cc6d1dc", "filename": "gcc/cselib.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -102,25 +102,26 @@ static rtx cselib_expand_value_rtx_1 (rtx, struct expand_value_data *, int);\n \n struct cselib_hasher : typed_noop_remove <cselib_val>\n {\n-  typedef cselib_val value_type;\n-  struct compare_type {\n+  typedef cselib_val *value_type;\n+  struct key {\n     /* The rtx value and its mode (needed separately for constant\n        integers).  */\n     machine_mode mode;\n     rtx x;\n     /* The mode of the contaning MEM, if any, otherwise VOIDmode.  */\n     machine_mode memmode;\n   };\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef key *compare_type;\n+  static inline hashval_t hash (const cselib_val *);\n+  static inline bool equal (const cselib_val *, const key *);\n };\n \n /* The hash function for our hash table.  The value is always computed with\n    cselib_hash_rtx when adding an element; this function just extracts the\n    hash value from a cselib_val structure.  */\n \n inline hashval_t\n-cselib_hasher::hash (const value_type *v)\n+cselib_hasher::hash (const cselib_val *v)\n {\n   return v->hash;\n }\n@@ -131,7 +132,7 @@ cselib_hasher::hash (const value_type *v)\n    CONST of an appropriate mode.  */\n \n inline bool\n-cselib_hasher::equal (const value_type *v, const compare_type *x_arg)\n+cselib_hasher::equal (const cselib_val *v, const key *x_arg)\n {\n   struct elt_loc_list *l;\n   rtx x = x_arg->x;\n@@ -507,7 +508,7 @@ preserve_constants_and_equivs (cselib_val **x, void *info ATTRIBUTE_UNUSED)\n \n   if (invariant_or_equiv_p (v))\n     {\n-      cselib_hasher::compare_type lookup = {\n+      cselib_hasher::key lookup = {\n \tGET_MODE (v->val_rtx), v->val_rtx, VOIDmode\n       };\n       cselib_val **slot\n@@ -592,7 +593,7 @@ cselib_find_slot (machine_mode mode, rtx x, hashval_t hash,\n \t\t  enum insert_option insert, machine_mode memmode)\n {\n   cselib_val **slot = NULL;\n-  cselib_hasher::compare_type lookup = { mode, x, memmode };\n+  cselib_hasher::key lookup = { mode, x, memmode };\n   if (cselib_preserve_constants)\n     slot = cselib_preserved_hash_table->find_slot_with_hash (&lookup, hash,\n \t\t\t\t\t\t\t     NO_INSERT);"}, {"sha": "603cdbdbf77541cb4dbaeb80e6888f3b0b983afb", "filename": "gcc/dse.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -667,21 +667,21 @@ clear_alias_set_lookup (alias_set_type alias_set)\n \n struct invariant_group_base_hasher : typed_noop_remove <group_info>\n {\n-  typedef group_info value_type;\n-  typedef group_info compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef group_info *value_type;\n+  typedef group_info *compare_type;\n+  static inline hashval_t hash (const group_info *);\n+  static inline bool equal (const group_info *, const group_info *);\n };\n \n inline bool\n-invariant_group_base_hasher::equal (const value_type *gi1,\n-\t\t\t\t    const compare_type *gi2)\n+invariant_group_base_hasher::equal (const group_info *gi1,\n+\t\t\t\t    const group_info *gi2)\n {\n   return rtx_equal_p (gi1->rtx_base, gi2->rtx_base);\n }\n \n inline hashval_t\n-invariant_group_base_hasher::hash (const value_type *gi)\n+invariant_group_base_hasher::hash (const group_info *gi)\n {\n   int do_not_record;\n   return hash_rtx (gi->rtx_base, Pmode, &do_not_record, NULL, false);"}, {"sha": "2469c2577bd7b62ce9a5a597181aaf7fb4e47469", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -182,20 +182,20 @@ typedef dw_trace_info *dw_trace_info_ref;\n \n struct trace_info_hasher : typed_noop_remove <dw_trace_info>\n {\n-  typedef dw_trace_info value_type;\n-  typedef dw_trace_info compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef dw_trace_info *value_type;\n+  typedef dw_trace_info *compare_type;\n+  static inline hashval_t hash (const dw_trace_info *);\n+  static inline bool equal (const dw_trace_info *, const dw_trace_info *);\n };\n \n inline hashval_t\n-trace_info_hasher::hash (const value_type *ti)\n+trace_info_hasher::hash (const dw_trace_info *ti)\n {\n   return INSN_UID (ti->head);\n }\n \n inline bool\n-trace_info_hasher::equal (const value_type *a, const compare_type *b)\n+trace_info_hasher::equal (const dw_trace_info *a, const dw_trace_info *b)\n {\n   return a->head == b->head;\n }"}, {"sha": "3f29db3352018bf2db66148e64ac44de065a618e", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -6865,28 +6865,28 @@ struct cu_hash_table_entry\n \n struct cu_hash_table_entry_hasher\n {\n-  typedef cu_hash_table_entry value_type;\n-  typedef die_struct compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n-  static inline void remove (value_type *);\n+  typedef cu_hash_table_entry *value_type;\n+  typedef die_struct *compare_type;\n+  static inline hashval_t hash (const cu_hash_table_entry *);\n+  static inline bool equal (const cu_hash_table_entry *, const die_struct *);\n+  static inline void remove (cu_hash_table_entry *);\n };\n \n inline hashval_t\n-cu_hash_table_entry_hasher::hash (const value_type *entry)\n+cu_hash_table_entry_hasher::hash (const cu_hash_table_entry *entry)\n {\n   return htab_hash_string (entry->cu->die_id.die_symbol);\n }\n \n inline bool\n-cu_hash_table_entry_hasher::equal (const value_type *entry1,\n-\t\t\t\t   const compare_type *entry2)\n+cu_hash_table_entry_hasher::equal (const cu_hash_table_entry *entry1,\n+\t\t\t\t   const die_struct *entry2)\n {\n   return !strcmp (entry1->cu->die_id.die_symbol, entry2->die_id.die_symbol);\n }\n \n inline void\n-cu_hash_table_entry_hasher::remove (value_type *entry)\n+cu_hash_table_entry_hasher::remove (cu_hash_table_entry *entry)\n {\n   struct cu_hash_table_entry *next;\n \n@@ -7202,21 +7202,21 @@ struct decl_table_entry\n \n struct decl_table_entry_hasher : typed_free_remove <decl_table_entry>\n {\n-  typedef decl_table_entry value_type;\n-  typedef die_struct compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef decl_table_entry *value_type;\n+  typedef die_struct *compare_type;\n+  static inline hashval_t hash (const decl_table_entry *);\n+  static inline bool equal (const decl_table_entry *, const die_struct *);\n };\n \n inline hashval_t\n-decl_table_entry_hasher::hash (const value_type *entry)\n+decl_table_entry_hasher::hash (const decl_table_entry *entry)\n {\n   return htab_hash_pointer (entry->orig);\n }\n \n inline bool\n-decl_table_entry_hasher::equal (const value_type *entry1,\n-\t\t\t\tconst compare_type *entry2)\n+decl_table_entry_hasher::equal (const decl_table_entry *entry1,\n+\t\t\t\tconst die_struct *entry2)\n {\n   return entry1->orig == entry2;\n }\n@@ -7744,14 +7744,14 @@ struct external_ref\n \n struct external_ref_hasher : typed_free_remove <external_ref>\n {\n-  typedef external_ref value_type;\n-  typedef external_ref compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef external_ref *value_type;\n+  typedef external_ref *compare_type;\n+  static inline hashval_t hash (const external_ref *);\n+  static inline bool equal (const external_ref *, const external_ref *);\n };\n \n inline hashval_t\n-external_ref_hasher::hash (const value_type *r)\n+external_ref_hasher::hash (const external_ref *r)\n {\n   dw_die_ref die = r->type;\n   hashval_t h = 0;\n@@ -7772,7 +7772,7 @@ external_ref_hasher::hash (const value_type *r)\n }\n \n inline bool\n-external_ref_hasher::equal (const value_type *r1, const compare_type *r2)\n+external_ref_hasher::equal (const external_ref *r1, const external_ref *r2)\n {\n   return r1->type == r2->type;\n }\n@@ -22230,21 +22230,21 @@ dwarf2out_undef (unsigned int lineno ATTRIBUTE_UNUSED,\n \n struct macinfo_entry_hasher : typed_noop_remove <macinfo_entry>\n {\n-  typedef macinfo_entry value_type;\n-  typedef macinfo_entry compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef macinfo_entry *value_type;\n+  typedef macinfo_entry *compare_type;\n+  static inline hashval_t hash (const macinfo_entry *);\n+  static inline bool equal (const macinfo_entry *, const macinfo_entry *);\n };\n \n inline hashval_t\n-macinfo_entry_hasher::hash (const value_type *entry)\n+macinfo_entry_hasher::hash (const macinfo_entry *entry)\n {\n   return htab_hash_string (entry->info);\n }\n \n inline bool\n-macinfo_entry_hasher::equal (const value_type *entry1,\n-\t\t\t     const compare_type *entry2)\n+macinfo_entry_hasher::equal (const macinfo_entry *entry1,\n+\t\t\t     const macinfo_entry *entry2)\n {\n   return !strcmp (entry1->info, entry2->info);\n }\n@@ -23308,23 +23308,23 @@ file_table_relative_p (dwarf_file_data **slot, bool *p)\n \n struct comdat_type_hasher : typed_noop_remove <comdat_type_node>\n {\n-  typedef comdat_type_node value_type;\n-  typedef comdat_type_node compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef comdat_type_node *value_type;\n+  typedef comdat_type_node *compare_type;\n+  static inline hashval_t hash (const comdat_type_node *);\n+  static inline bool equal (const comdat_type_node *, const comdat_type_node *);\n };\n \n inline hashval_t\n-comdat_type_hasher::hash (const value_type *type_node)\n+comdat_type_hasher::hash (const comdat_type_node *type_node)\n {\n   hashval_t h;\n   memcpy (&h, type_node->signature, sizeof (h));\n   return h;\n }\n \n inline bool\n-comdat_type_hasher::equal (const value_type *type_node_1,\n-\t\t\t   const compare_type *type_node_2)\n+comdat_type_hasher::equal (const comdat_type_node *type_node_1,\n+\t\t\t   const comdat_type_node *type_node_2)\n {\n   return (! memcmp (type_node_1->signature, type_node_2->signature,\n                     DWARF_TYPE_SIGNATURE_SIZE));\n@@ -24411,24 +24411,26 @@ compare_locs (dw_loc_descr_ref x, dw_loc_descr_ref y)\n \n struct loc_list_hasher : typed_noop_remove <dw_loc_list_struct>\n {\n-  typedef dw_loc_list_struct value_type;\n-  typedef dw_loc_list_struct compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef dw_loc_list_struct *value_type;\n+  typedef dw_loc_list_struct *compare_type;\n+  static inline hashval_t hash (const dw_loc_list_struct *);\n+  static inline bool equal (const dw_loc_list_struct *,\n+\t\t\t    const dw_loc_list_struct *);\n };\n \n /* Return precomputed hash of location list X.  */\n \n inline hashval_t\n-loc_list_hasher::hash (const value_type *x)\n+loc_list_hasher::hash (const dw_loc_list_struct *x)\n {\n   return x->hash;\n }\n \n /* Return true if location lists A and B are the same.  */\n \n inline bool\n-loc_list_hasher::equal (const value_type *a, const compare_type *b)\n+loc_list_hasher::equal (const dw_loc_list_struct *a,\n+\t\t\tconst dw_loc_list_struct *b)\n {\n   if (a == b)\n     return 1;"}, {"sha": "f85e55abab73b6e0eda786d32e0a1af28e4fc2ca", "filename": "gcc/except.c", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -227,20 +227,21 @@ struct action_record\n \n struct action_record_hasher : typed_free_remove <action_record>\n {\n-  typedef action_record value_type;\n-  typedef action_record compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef action_record *value_type;\n+  typedef action_record *compare_type;\n+  static inline hashval_t hash (const action_record *);\n+  static inline bool equal (const action_record *, const action_record *);\n };\n \n inline hashval_t\n-action_record_hasher::hash (const value_type *entry)\n+action_record_hasher::hash (const action_record *entry)\n {\n   return entry->next * 1009 + entry->filter;\n }\n \n inline bool\n-action_record_hasher::equal (const value_type *entry, const compare_type *data)\n+action_record_hasher::equal (const action_record *entry,\n+\t\t\t     const action_record *data)\n {\n   return entry->filter == data->filter && entry->next == data->next;\n }\n@@ -742,23 +743,23 @@ struct ttypes_filter {\n \n struct ttypes_filter_hasher : typed_free_remove <ttypes_filter>\n {\n-  typedef ttypes_filter value_type;\n-  typedef tree_node compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef ttypes_filter *value_type;\n+  typedef tree_node *compare_type;\n+  static inline hashval_t hash (const ttypes_filter *);\n+  static inline bool equal (const ttypes_filter *, const tree_node *);\n };\n \n /* Compare ENTRY (a ttypes_filter entry in the hash table) with DATA\n    (a tree) for a @TTypes type node we are thinking about adding.  */\n \n inline bool\n-ttypes_filter_hasher::equal (const value_type *entry, const compare_type *data)\n+ttypes_filter_hasher::equal (const ttypes_filter *entry, const tree_node *data)\n {\n   return entry->t == data;\n }\n \n inline hashval_t\n-ttypes_filter_hasher::hash (const value_type *entry)\n+ttypes_filter_hasher::hash (const ttypes_filter *entry)\n {\n   return TREE_HASH (entry->t);\n }\n@@ -770,10 +771,10 @@ typedef hash_table<ttypes_filter_hasher> ttypes_hash_type;\n \n struct ehspec_hasher : typed_free_remove <ttypes_filter>\n {\n-  typedef ttypes_filter value_type;\n-  typedef ttypes_filter compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef ttypes_filter *value_type;\n+  typedef ttypes_filter *compare_type;\n+  static inline hashval_t hash (const ttypes_filter *);\n+  static inline bool equal (const ttypes_filter *, const ttypes_filter *);\n };\n \n /* Compare ENTRY with DATA (both struct ttypes_filter) for a @TTypes\n@@ -782,15 +783,15 @@ struct ehspec_hasher : typed_free_remove <ttypes_filter>\n    should put these in some canonical order.  */\n \n inline bool\n-ehspec_hasher::equal (const value_type *entry, const compare_type *data)\n+ehspec_hasher::equal (const ttypes_filter *entry, const ttypes_filter *data)\n {\n   return type_list_equal (entry->t, data->t);\n }\n \n /* Hash function for exception specification lists.  */\n \n inline hashval_t\n-ehspec_hasher::hash (const value_type *entry)\n+ehspec_hasher::hash (const ttypes_filter *entry)\n {\n   hashval_t h = 0;\n   tree list;"}, {"sha": "4be3f36a773a0c9288d140e5d53e3dd6c49b7425", "filename": "gcc/gcse.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -388,15 +388,15 @@ static struct ls_expr * pre_ldst_mems = NULL;\n \n struct pre_ldst_expr_hasher : typed_noop_remove <ls_expr>\n {\n-  typedef ls_expr value_type;\n+  typedef ls_expr *value_type;\n   typedef value_type compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  static inline hashval_t hash (const ls_expr *);\n+  static inline bool equal (const ls_expr *, const ls_expr *);\n };\n \n /* Hashtable helpers.  */\n inline hashval_t\n-pre_ldst_expr_hasher::hash (const value_type *x)\n+pre_ldst_expr_hasher::hash (const ls_expr *x)\n {\n   int do_not_record_p = 0;\n   return\n@@ -406,8 +406,8 @@ pre_ldst_expr_hasher::hash (const value_type *x)\n static int expr_equiv_p (const_rtx, const_rtx);\n \n inline bool\n-pre_ldst_expr_hasher::equal (const value_type *ptr1,\n-\t\t\t     const compare_type *ptr2)\n+pre_ldst_expr_hasher::equal (const ls_expr *ptr1,\n+\t\t\t     const ls_expr *ptr2)\n {\n   return expr_equiv_p (ptr1->pattern, ptr2->pattern);\n }"}, {"sha": "fbd12a51a3a54441a1d1812124b1bdec1812d57a", "filename": "gcc/genmatch.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -190,21 +190,21 @@ struct id_base : typed_noop_remove<id_base>\n   const char *id;\n \n   /* hash_table support.  */\n-  typedef id_base value_type;\n-  typedef id_base compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline int equal (const value_type *, const compare_type *);\n+  typedef id_base *value_type;\n+  typedef id_base *compare_type;\n+  static inline hashval_t hash (const id_base *);\n+  static inline int equal (const id_base *, const id_base *);\n };\n \n inline hashval_t\n-id_base::hash (const value_type *op)\n+id_base::hash (const id_base *op)\n {\n   return op->hashval;\n }\n \n inline int\n-id_base::equal (const value_type *op1,\n-\t\t\tconst compare_type *op2)\n+id_base::equal (const id_base *op1,\n+\t\t\tconst id_base *op2)\n {\n   return (op1->hashval == op2->hashval\n \t  && strcmp (op1->id, op2->id) == 0);"}, {"sha": "eff326a36c5b28f5ddf522ecc012bc63b3c2fb38", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -242,20 +242,20 @@ struct ptr_data\n \n struct saving_hasher : typed_free_remove <ptr_data>\n {\n-  typedef ptr_data value_type;\n-  typedef void compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef ptr_data *value_type;\n+  typedef void *compare_type;\n+  static inline hashval_t hash (const ptr_data *);\n+  static inline bool equal (const ptr_data *, const void *);\n };\n \n inline hashval_t\n-saving_hasher::hash (const value_type *p)\n+saving_hasher::hash (const ptr_data *p)\n {\n   return POINTER_HASH (p->obj);\n }\n \n inline bool\n-saving_hasher::equal (const value_type *p1, const compare_type *p2)\n+saving_hasher::equal (const ptr_data *p1, const void *p2)\n {\n   return p1->obj == p2;\n }\n@@ -847,20 +847,22 @@ struct ggc_loc_descriptor\n \n struct ggc_loc_desc_hasher : typed_noop_remove <ggc_loc_descriptor>\n {\n-  typedef ggc_loc_descriptor value_type;\n-  typedef ggc_loc_descriptor compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef ggc_loc_descriptor *value_type;\n+  typedef ggc_loc_descriptor *compare_type;\n+  static inline hashval_t hash (const ggc_loc_descriptor *);\n+  static inline bool equal (const ggc_loc_descriptor *,\n+\t\t\t    const ggc_loc_descriptor *);\n };\n \n inline hashval_t\n-ggc_loc_desc_hasher::hash (const value_type *d)\n+ggc_loc_desc_hasher::hash (const ggc_loc_descriptor *d)\n {\n   return htab_hash_pointer (d->function) | d->line;\n }\n \n inline bool\n-ggc_loc_desc_hasher::equal (const value_type *d, const compare_type *d2)\n+ggc_loc_desc_hasher::equal (const ggc_loc_descriptor *d,\n+\t\t\t    const ggc_loc_descriptor *d2)\n {\n   return (d->file == d2->file && d->line == d2->line\n \t  && d->function == d2->function);\n@@ -880,20 +882,20 @@ struct ggc_ptr_hash_entry\n \n struct ptr_hash_hasher : typed_noop_remove <ggc_ptr_hash_entry>\n {\n-  typedef ggc_ptr_hash_entry value_type;\n-  typedef void compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef ggc_ptr_hash_entry *value_type;\n+  typedef void *compare_type;\n+  static inline hashval_t hash (const ggc_ptr_hash_entry *);\n+  static inline bool equal (const ggc_ptr_hash_entry *, const void *);\n };\n \n inline hashval_t\n-ptr_hash_hasher::hash (const value_type *d)\n+ptr_hash_hasher::hash (const ggc_ptr_hash_entry *d)\n {\n   return htab_hash_pointer (d->ptr);\n }\n \n inline bool\n-ptr_hash_hasher::equal (const value_type *p, const compare_type *p2)\n+ptr_hash_hasher::equal (const ggc_ptr_hash_entry *p, const void *p2)\n {\n   return (p->ptr == p2);\n }"}, {"sha": "afd3215de85444185d49b302e1ef71205f2f618c", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -438,21 +438,21 @@ lookup_cand (cand_idx idx)\n \n struct cand_chain_hasher : typed_noop_remove <cand_chain>\n {\n-  typedef cand_chain value_type;\n-  typedef cand_chain compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef cand_chain *value_type;\n+  typedef cand_chain *compare_type;\n+  static inline hashval_t hash (const cand_chain *);\n+  static inline bool equal (const cand_chain *, const cand_chain *);\n };\n \n inline hashval_t\n-cand_chain_hasher::hash (const value_type *p)\n+cand_chain_hasher::hash (const cand_chain *p)\n {\n   tree base_expr = p->base_expr;\n   return iterative_hash_expr (base_expr, 0);\n }\n \n inline bool\n-cand_chain_hasher::equal (const value_type *chain1, const compare_type *chain2)\n+cand_chain_hasher::equal (const cand_chain *chain1, const cand_chain *chain2)\n {\n   return operand_equal_p (chain1->base_expr, chain2->base_expr, 0);\n }"}, {"sha": "0a8ef84169f40e1f8cc882e4d9d3968f07bc13dd", "filename": "gcc/gimplify.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -136,10 +136,10 @@ enum omp_region_type\n \n struct gimplify_hasher : typed_free_remove <elt_t>\n {\n-  typedef elt_t value_type;\n-  typedef elt_t compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef elt_t *value_type;\n+  typedef elt_t *compare_type;\n+  static inline hashval_t hash (const elt_t *);\n+  static inline bool equal (const elt_t *, const elt_t *);\n };\n \n struct gimplify_ctx\n@@ -9448,14 +9448,14 @@ gimplify_assign (tree dst, tree src, gimple_seq *seq_p)\n }\n \n inline hashval_t\n-gimplify_hasher::hash (const value_type *p)\n+gimplify_hasher::hash (const elt_t *p)\n {\n   tree t = p->val;\n   return iterative_hash_expr (t, 0);\n }\n \n inline bool\n-gimplify_hasher::equal (const value_type *p1, const compare_type *p2)\n+gimplify_hasher::equal (const elt_t *p1, const elt_t *p2)\n {\n   tree t1 = p1->val;\n   tree t2 = p2->val;"}, {"sha": "96c038f7156f494303c10355b82eb8346d28dc24", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -621,48 +621,48 @@ struct delay_pair\n \n struct delay_i1_hasher : typed_noop_remove <delay_pair>\n {\n-  typedef delay_pair value_type;\n-  typedef void compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef delay_pair *value_type;\n+  typedef void *compare_type;\n+  static inline hashval_t hash (const delay_pair *);\n+  static inline bool equal (const delay_pair *, const void *);\n };\n \n /* Returns a hash value for X, based on hashing just I1.  */\n \n inline hashval_t\n-delay_i1_hasher::hash (const value_type *x)\n+delay_i1_hasher::hash (const delay_pair *x)\n {\n   return htab_hash_pointer (x->i1);\n }\n \n /* Return true if I1 of pair X is the same as that of pair Y.  */\n \n inline bool\n-delay_i1_hasher::equal (const value_type *x, const compare_type *y)\n+delay_i1_hasher::equal (const delay_pair *x, const void *y)\n {\n   return x->i1 == y;\n }\n \n struct delay_i2_hasher : typed_free_remove <delay_pair>\n {\n-  typedef delay_pair value_type;\n-  typedef void compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef delay_pair *value_type;\n+  typedef void *compare_type;\n+  static inline hashval_t hash (const delay_pair *);\n+  static inline bool equal (const delay_pair *, const void *);\n };\n \n /* Returns a hash value for X, based on hashing just I2.  */\n \n inline hashval_t\n-delay_i2_hasher::hash (const value_type *x)\n+delay_i2_hasher::hash (const delay_pair *x)\n {\n   return htab_hash_pointer (x->i2);\n }\n \n /* Return true if I2 of pair X is the same as that of pair Y.  */\n \n inline bool\n-delay_i2_hasher::equal (const value_type *x, const compare_type *y)\n+delay_i2_hasher::equal (const delay_pair *x, const void *y)\n {\n   return x->i2 == y;\n }"}, {"sha": "89971d7b36030582ff55dc3c06ff2a944b8a4836", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -615,7 +615,17 @@ hard_reg_set_iter_next (hard_reg_set_iterator *iter, unsigned *regno)\n \n extern char global_regs[FIRST_PSEUDO_REGISTER];\n \n-struct simplifiable_subregs_hasher;\n+struct simplifiable_subreg;\n+struct subreg_shape;\n+\n+struct simplifiable_subregs_hasher : typed_noop_remove <simplifiable_subreg>\n+{\n+  typedef simplifiable_subreg *value_type;\n+  typedef const subreg_shape *compare_type;\n+\n+  static inline hashval_t hash (const simplifiable_subreg *);\n+  static inline bool equal (const simplifiable_subreg *, const subreg_shape *);\n+};\n \n struct target_hard_regs {\n   void finalize ();"}, {"sha": "4cca702a0e2f768a938a69017bcf5821a993c4a6", "filename": "gcc/hash-map.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fhash-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fhash-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-map.h?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -114,7 +114,6 @@ class GTY((user)) hash_map\n \n     typedef hash_entry value_type;\n     typedef Key compare_type;\n-    typedef int store_values_directly;\n \n     static hashval_t hash (const hash_entry &e)\n       {"}, {"sha": "906545143a7ea3966d373d2910a6eb95a7171d9f", "filename": "gcc/hash-set.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fhash-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fhash-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-set.h?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -112,7 +112,6 @@ class hash_set\n \n     typedef hash_entry value_type;\n     typedef Key compare_type;\n-    typedef int store_values_directly;\n \n     static hashval_t hash (const hash_entry &e)\n       {"}, {"sha": "f6375d1ec71e554dcf45e51bc8a629a8074886dd", "filename": "gcc/hash-table.h", "status": "modified", "additions": 27, "deletions": 563, "changes": 590, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -278,7 +278,6 @@ struct pointer_hash : typed_noop_remove <Type>\n {\n   typedef Type *value_type;\n   typedef Type *compare_type;\n-  typedef int store_values_directly;\n \n   static inline hashval_t hash (const value_type &);\n \n@@ -310,7 +309,6 @@ struct ggc_hasher\n {\n   typedef T value_type;\n   typedef T compare_type;\n-  typedef int store_values_directly;\n \n   static void remove (T) {}\n \n@@ -342,7 +340,6 @@ struct ggc_cache_hasher\n {\n   typedef T value_type;\n   typedef T compare_type;\n-  typedef int store_values_directly;\n \n   static void remove (T &) {}\n \n@@ -438,26 +435,6 @@ hash_table_mod2 (hashval_t hash, unsigned int index)\n   return 1 + mul_mod (hash, p->prime - 2, p->inv_m2, p->shift);\n }\n \n-/* The below is some template meta programming to decide if we should use the\n-   hash table partial specialization that directly stores value_type instead of\n-   pointers to value_type.  If the Descriptor type defines the type\n-   Descriptor::store_values_directly then values are stored directly otherwise\n-   pointers to them are stored.  */\n-template<typename T> struct notype { typedef void type; };\n-\n-template<typename T, typename = void>\n-struct storage_tester\n-{\n-  static const bool value = false;\n-};\n-\n-template<typename T>\n-struct storage_tester<T, typename notype<typename\n-\t\t\t\t\t T::store_values_directly>::type>\n-{\n-  static const bool value = true;\n-};\n-\n  template<typename Traits>\n  struct has_is_deleted\n {\n@@ -576,9 +553,7 @@ struct mark_empty_helper<Type *, Traits, false>\n \n /* User-facing hash table type.\n \n-   The table stores elements of type Descriptor::value_type, or pointers to\n-   objects of type value_type if the descriptor does not define the type\n-   store_values_directly.\n+   The table stores elements of type Descriptor::value_type.\n \n    It hashes values with the hash member function.\n      The table currently works with relatively weak hash functions.\n@@ -601,517 +576,8 @@ struct mark_empty_helper<Type *, Traits, false>\n \n */\n template <typename Descriptor,\n-\t template<typename Type> class Allocator= xcallocator,\n-\t bool Storage = storage_tester<Descriptor>::value>\n+\t template<typename Type> class Allocator = xcallocator>\n class hash_table\n-{\n-};\n-\n-template <typename Descriptor,\n-\t template<typename Type> class Allocator>\n-class hash_table<Descriptor, Allocator, false>\n-{\n-  typedef typename Descriptor::value_type value_type;\n-  typedef typename Descriptor::compare_type compare_type;\n-\n-public:\n-  hash_table (size_t CXX_MEM_STAT_INFO);\n-  ~hash_table ();\n-\n-  /* Current size (in entries) of the hash table.  */\n-  size_t size () const { return m_size; }\n-\n-  /* Return the current number of elements in this hash table. */\n-  size_t elements () const { return m_n_elements - m_n_deleted; }\n-\n-  /* Return the current number of elements in this hash table. */\n-  size_t elements_with_deleted () const { return m_n_elements; }\n-\n-  /* This function clears all entries in the given hash table.  */\n-  void empty ();\n-\n-  /* This function clears a specified SLOT in a hash table.  It is\n-     useful when you've already done the lookup and don't want to do it\n-     again. */\n-\n-  void clear_slot (value_type **);\n-\n-  /* This function searches for a hash table entry equal to the given\n-     COMPARABLE element starting with the given HASH value.  It cannot\n-     be used to insert or delete an element. */\n-  value_type *find_with_hash (const compare_type *, hashval_t);\n-\n-/* Like find_slot_with_hash, but compute the hash value from the element.  */\n-  value_type *find (const value_type *value)\n-    {\n-      return find_with_hash (value, Descriptor::hash (value));\n-    }\n-\n-  value_type **find_slot (const value_type *value, insert_option insert)\n-    {\n-      return find_slot_with_hash (value, Descriptor::hash (value), insert);\n-    }\n-\n-  /* This function searches for a hash table slot containing an entry\n-     equal to the given COMPARABLE element and starting with the given\n-     HASH.  To delete an entry, call this with insert=NO_INSERT, then\n-     call clear_slot on the slot returned (possibly after doing some\n-     checks).  To insert an entry, call this with insert=INSERT, then\n-     write the value you want into the returned slot.  When inserting an\n-     entry, NULL may be returned if memory allocation fails. */\n-  value_type **find_slot_with_hash (const compare_type *comparable,\n-\t\t\t\t    hashval_t hash, enum insert_option insert);\n-\n-  /* This function deletes an element with the given COMPARABLE value\n-     from hash table starting with the given HASH.  If there is no\n-     matching element in the hash table, this function does nothing. */\n-  void remove_elt_with_hash (const compare_type *, hashval_t);\n-\n-/* Like remove_elt_with_hash, but compute the hash value from the element.  */\n-  void remove_elt (const value_type *value)\n-    {\n-      remove_elt_with_hash (value, Descriptor::hash (value));\n-    }\n-\n-  /* This function scans over the entire hash table calling CALLBACK for\n-     each live entry.  If CALLBACK returns false, the iteration stops.\n-     ARGUMENT is passed as CALLBACK's second argument. */\n-  template <typename Argument,\n-\t    int (*Callback) (value_type **slot, Argument argument)>\n-  void traverse_noresize (Argument argument);\n-\n-  /* Like traverse_noresize, but does resize the table when it is too empty\n-     to improve effectivity of subsequent calls.  */\n-  template <typename Argument,\n-\t    int (*Callback) (value_type **slot, Argument argument)>\n-  void traverse (Argument argument);\n-\n-  class iterator\n-  {\n-  public:\n-    iterator () : m_slot (NULL), m_limit (NULL) {}\n-\n-    iterator (value_type **slot, value_type **limit) :\n-      m_slot (slot), m_limit (limit) {}\n-\n-    inline value_type *operator * () { return *m_slot; }\n-    void slide ();\n-    inline iterator &operator ++ ();\n-    bool operator != (const iterator &other) const\n-      {\n-\treturn m_slot != other.m_slot || m_limit != other.m_limit;\n-      }\n-\n-  private:\n-    value_type **m_slot;\n-    value_type **m_limit;\n-  };\n-\n-  iterator begin () const\n-    {\n-      iterator iter (m_entries, m_entries + m_size);\n-      iter.slide ();\n-      return iter;\n-    }\n-\n-  iterator end () const { return iterator (); }\n-\n-  double collisions () const\n-    {\n-      return m_searches ? static_cast <double> (m_collisions) / m_searches : 0;\n-    }\n-\n-private:\n-\n-  value_type **find_empty_slot_for_expand (hashval_t);\n-  void expand ();\n-\n-  /* Table itself.  */\n-  typename Descriptor::value_type **m_entries;\n-\n-  size_t m_size;\n-\n-  /* Current number of elements including also deleted elements.  */\n-  size_t m_n_elements;\n-\n-  /* Current number of deleted elements in the table.  */\n-  size_t m_n_deleted;\n-\n-  /* The following member is used for debugging. Its value is number\n-     of all calls of `htab_find_slot' for the hash table. */\n-  unsigned int m_searches;\n-\n-  /* The following member is used for debugging.  Its value is number\n-     of collisions fixed for time of work with the hash table. */\n-  unsigned int m_collisions;\n-\n-  /* Current size (in entries) of the hash table, as an index into the\n-     table of primes.  */\n-  unsigned int m_size_prime_index;\n-};\n-\n-template<typename Descriptor, template<typename Type> class Allocator>\n-hash_table<Descriptor, Allocator, false>::hash_table (size_t size\n-\t\t\t\t\t\t      MEM_STAT_DECL) :\n-  m_n_elements (0), m_n_deleted (0), m_searches (0), m_collisions (0)\n-{\n-  unsigned int size_prime_index;\n-\n-  size_prime_index = hash_table_higher_prime_index (size);\n-  size = prime_tab[size_prime_index].prime;\n-\n-  m_entries = Allocator <value_type*> ::data_alloc (size);\n-  gcc_assert (m_entries != NULL);\n-  m_size = size;\n-  m_size_prime_index = size_prime_index;\n-}\n-\n-template<typename Descriptor, template<typename Type> class Allocator>\n-hash_table<Descriptor, Allocator, false>::~hash_table ()\n-{\n-  for (size_t i = m_size - 1; i < m_size; i--)\n-    if (m_entries[i] != HTAB_EMPTY_ENTRY && m_entries[i] != HTAB_DELETED_ENTRY)\n-      Descriptor::remove (m_entries[i]);\n-\n-  Allocator <value_type *> ::data_free (m_entries);\n-}\n-\n-/* Similar to find_slot, but without several unwanted side effects:\n-    - Does not call equal when it finds an existing entry.\n-    - Does not change the count of elements/searches/collisions in the\n-      hash table.\n-   This function also assumes there are no deleted entries in the table.\n-   HASH is the hash value for the element to be inserted.  */\n-\n-template<typename Descriptor, template<typename Type> class Allocator>\n-typename hash_table<Descriptor, Allocator, false>::value_type **\n-hash_table<Descriptor, Allocator, false>\n-::find_empty_slot_for_expand (hashval_t hash)\n-{\n-  hashval_t index = hash_table_mod1 (hash, m_size_prime_index);\n-  size_t size = m_size;\n-  value_type **slot = m_entries + index;\n-  hashval_t hash2;\n-\n-  if (*slot == HTAB_EMPTY_ENTRY)\n-    return slot;\n-  gcc_checking_assert (*slot != HTAB_DELETED_ENTRY);\n-\n-  hash2 = hash_table_mod2 (hash, m_size_prime_index);\n-  for (;;)\n-    {\n-      index += hash2;\n-      if (index >= size)\n-        index -= size;\n-\n-      slot = m_entries + index;\n-      if (*slot == HTAB_EMPTY_ENTRY)\n-        return slot;\n-      gcc_checking_assert (*slot != HTAB_DELETED_ENTRY);\n-    }\n-}\n-\n-/* The following function changes size of memory allocated for the\n-   entries and repeatedly inserts the table elements.  The occupancy\n-   of the table after the call will be about 50%.  Naturally the hash\n-   table must already exist.  Remember also that the place of the\n-   table entries is changed.  If memory allocation fails, this function\n-   will abort.  */\n-\n-template<typename Descriptor, template<typename Type> class Allocator>\n-void\n-hash_table<Descriptor, Allocator, false>::expand ()\n-{\n-  value_type **oentries = m_entries;\n-  unsigned int oindex = m_size_prime_index;\n-  size_t osize = size ();\n-  value_type **olimit = oentries + osize;\n-  size_t elts = elements ();\n-\n-  /* Resize only when table after removal of unused elements is either\n-     too full or too empty.  */\n-  unsigned int nindex;\n-  size_t nsize;\n-  if (elts * 2 > osize || (elts * 8 < osize && osize > 32))\n-    {\n-      nindex = hash_table_higher_prime_index (elts * 2);\n-      nsize = prime_tab[nindex].prime;\n-    }\n-  else\n-    {\n-      nindex = oindex;\n-      nsize = osize;\n-    }\n-\n-  value_type **nentries = Allocator <value_type *> ::data_alloc (nsize);\n-  gcc_assert (nentries != NULL);\n-  m_entries = nentries;\n-  m_size = nsize;\n-  m_size_prime_index = nindex;\n-  m_n_elements -= m_n_deleted;\n-  m_n_deleted = 0;\n-\n-  value_type **p = oentries;\n-  do\n-    {\n-      value_type *x = *p;\n-\n-      if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n-        {\n-          value_type **q = find_empty_slot_for_expand (Descriptor::hash (x));\n-\n-          *q = x;\n-        }\n-\n-      p++;\n-    }\n-  while (p < olimit);\n-\n-  Allocator <value_type *> ::data_free (oentries);\n-}\n-\n-template<typename Descriptor, template<typename Type> class Allocator>\n-void\n-hash_table<Descriptor, Allocator, false>::empty ()\n-{\n-  size_t size = m_size;\n-  value_type **entries = m_entries;\n-  int i;\n-\n-  for (i = size - 1; i >= 0; i--)\n-    if (entries[i] != HTAB_EMPTY_ENTRY && entries[i] != HTAB_DELETED_ENTRY)\n-      Descriptor::remove (entries[i]);\n-\n-  /* Instead of clearing megabyte, downsize the table.  */\n-  if (size > 1024*1024 / sizeof (PTR))\n-    {\n-      int nindex = hash_table_higher_prime_index (1024 / sizeof (PTR));\n-      int nsize = prime_tab[nindex].prime;\n-\n-      Allocator <value_type *> ::data_free (m_entries);\n-      m_entries = Allocator <value_type *> ::data_alloc (nsize);\n-      m_size = nsize;\n-      m_size_prime_index = nindex;\n-    }\n-  else\n-    memset (entries, 0, size * sizeof (value_type *));\n-  m_n_deleted = 0;\n-  m_n_elements = 0;\n-}\n-\n-/* This function clears a specified SLOT in a hash table.  It is\n-   useful when you've already done the lookup and don't want to do it\n-   again. */\n-\n-template<typename Descriptor, template<typename Type> class Allocator>\n-void\n-hash_table<Descriptor, Allocator, false>::clear_slot (value_type **slot)\n-{\n-  gcc_checking_assert (!(slot < m_entries || slot >= m_entries + size ()\n-\t\t         || *slot == HTAB_EMPTY_ENTRY\n-\t\t\t || *slot == HTAB_DELETED_ENTRY));\n-\n-  Descriptor::remove (*slot);\n-\n-  *slot = static_cast <value_type *> (HTAB_DELETED_ENTRY);\n-  m_n_deleted++;\n-}\n-\n-/* This function searches for a hash table entry equal to the given\n-   COMPARABLE element starting with the given HASH value.  It cannot\n-   be used to insert or delete an element. */\n-\n-template<typename Descriptor, template<typename Type> class Allocator>\n-typename hash_table<Descriptor, Allocator, false>::value_type *\n-hash_table<Descriptor, Allocator, false>\n-::find_with_hash (const compare_type *comparable, hashval_t hash)\n-{\n-  m_searches++;\n-  size_t size = m_size;\n-  hashval_t index = hash_table_mod1 (hash, m_size_prime_index);\n-\n-  value_type *entry = m_entries[index];\n-  if (entry == HTAB_EMPTY_ENTRY\n-      || (entry != HTAB_DELETED_ENTRY && Descriptor::equal (entry, comparable)))\n-    return entry;\n-\n-  hashval_t hash2 = hash_table_mod2 (hash, m_size_prime_index);\n-  for (;;)\n-    {\n-      m_collisions++;\n-      index += hash2;\n-      if (index >= size)\n-        index -= size;\n-\n-      entry = m_entries[index];\n-      if (entry == HTAB_EMPTY_ENTRY\n-          || (entry != HTAB_DELETED_ENTRY\n-\t      && Descriptor::equal (entry, comparable)))\n-        return entry;\n-    }\n-}\n-\n-/* This function searches for a hash table slot containing an entry\n-   equal to the given COMPARABLE element and starting with the given\n-   HASH.  To delete an entry, call this with insert=NO_INSERT, then\n-   call clear_slot on the slot returned (possibly after doing some\n-   checks).  To insert an entry, call this with insert=INSERT, then\n-   write the value you want into the returned slot.  When inserting an\n-   entry, NULL may be returned if memory allocation fails. */\n-\n-template<typename Descriptor, template<typename Type> class Allocator>\n-typename hash_table<Descriptor, Allocator, false>::value_type **\n-hash_table<Descriptor, Allocator, false>\n-::find_slot_with_hash (const compare_type *comparable, hashval_t hash,\n-\t\t       enum insert_option insert)\n-{\n-  if (insert == INSERT && m_size * 3 <= m_n_elements * 4)\n-    expand ();\n-\n-  m_searches++;\n-\n-  value_type **first_deleted_slot = NULL;\n-  hashval_t index = hash_table_mod1 (hash, m_size_prime_index);\n-  hashval_t hash2 = hash_table_mod2 (hash, m_size_prime_index);\n-  value_type *entry = m_entries[index];\n-  size_t size = m_size;\n-  if (entry == HTAB_EMPTY_ENTRY)\n-    goto empty_entry;\n-  else if (entry == HTAB_DELETED_ENTRY)\n-    first_deleted_slot = &m_entries[index];\n-  else if (Descriptor::equal (entry, comparable))\n-    return &m_entries[index];\n-\n-  for (;;)\n-    {\n-      m_collisions++;\n-      index += hash2;\n-      if (index >= size)\n-\tindex -= size;\n-\n-      entry = m_entries[index];\n-      if (entry == HTAB_EMPTY_ENTRY)\n-\tgoto empty_entry;\n-      else if (entry == HTAB_DELETED_ENTRY)\n-\t{\n-\t  if (!first_deleted_slot)\n-\t    first_deleted_slot = &m_entries[index];\n-\t}\n-      else if (Descriptor::equal (entry, comparable))\n-\treturn &m_entries[index];\n-    }\n-\n- empty_entry:\n-  if (insert == NO_INSERT)\n-    return NULL;\n-\n-  if (first_deleted_slot)\n-    {\n-      m_n_deleted--;\n-      *first_deleted_slot = static_cast <value_type *> (HTAB_EMPTY_ENTRY);\n-      return first_deleted_slot;\n-    }\n-\n-  m_n_elements++;\n-  return &m_entries[index];\n-}\n-\n-/* This function deletes an element with the given COMPARABLE value\n-   from hash table starting with the given HASH.  If there is no\n-   matching element in the hash table, this function does nothing. */\n-\n-template<typename Descriptor, template<typename Type> class Allocator>\n-void\n-hash_table<Descriptor, Allocator, false>\n-::remove_elt_with_hash (const compare_type *comparable, hashval_t hash)\n-{\n-  value_type **slot = find_slot_with_hash (comparable, hash, NO_INSERT);\n-  if (*slot == HTAB_EMPTY_ENTRY)\n-    return;\n-\n-  Descriptor::remove (*slot);\n-\n-  *slot = static_cast <value_type *> (HTAB_DELETED_ENTRY);\n-  m_n_deleted++;\n-}\n-\n-/* This function scans over the entire hash table calling CALLBACK for\n-   each live entry.  If CALLBACK returns false, the iteration stops.\n-   ARGUMENT is passed as CALLBACK's second argument. */\n-\n-template<typename Descriptor, template<typename Type> class Allocator>\n-template<typename Argument,\n-\t  int (*Callback) (typename hash_table<Descriptor, Allocator,\n-\t\t\t\t\t       false>::value_type **slot,\n-\t\t\t   Argument argument)>\n-void\n-hash_table<Descriptor, Allocator, false>::traverse_noresize (Argument argument)\n-{\n-  value_type **slot = m_entries;\n-  value_type **limit = slot + size ();\n-\n-  do\n-    {\n-      value_type *x = *slot;\n-\n-      if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n-        if (! Callback (slot, argument))\n-          break;\n-    }\n-  while (++slot < limit);\n-}\n-\n-/* Like traverse_noresize, but does resize the table when it is too empty\n-   to improve effectivity of subsequent calls.  */\n-\n-template <typename Descriptor,\n-\t  template <typename Type> class Allocator>\n-template <typename Argument,\n-\t  int (*Callback) (typename hash_table<Descriptor, Allocator,\n-\t\t\t\t\t       false>::value_type **slot,\n-\t\t\t   Argument argument)>\n-void\n-hash_table<Descriptor, Allocator, false>::traverse (Argument argument)\n-{\n-  size_t size = m_size;\n-  if (elements () * 8 < size && size > 32)\n-    expand ();\n-\n-  traverse_noresize <Argument, Callback> (argument);\n-}\n-\n-/* Slide down the iterator slots until an active entry is found.  */\n-\n-template<typename Descriptor, template<typename Type> class Allocator>\n-void\n-hash_table<Descriptor, Allocator, false>::iterator::slide ()\n-{\n-  for ( ; m_slot < m_limit; ++m_slot )\n-    {\n-      value_type *x = *m_slot;\n-      if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)\n-        return;\n-    }\n-  m_slot = NULL;\n-  m_limit = NULL;\n-}\n-\n-/* Bump the iterator.  */\n-\n-template<typename Descriptor, template<typename Type> class Allocator>\n-inline typename hash_table<Descriptor, Allocator, false>::iterator &\n-hash_table<Descriptor, Allocator, false>::iterator::operator ++ ()\n-{\n-  ++m_slot;\n-  slide ();\n-  return *this;\n-}\n-\n-/* A partial specialization used when values should be stored directly.  */\n-\n-template <typename Descriptor,\n-\t template<typename Type> class Allocator>\n-class hash_table<Descriptor, Allocator, true>\n {\n   typedef typename Descriptor::value_type value_type;\n   typedef typename Descriptor::compare_type compare_type;\n@@ -1296,7 +762,7 @@ class hash_table<Descriptor, Allocator, true>\n };\n \n template<typename Descriptor, template<typename Type> class Allocator>\n-hash_table<Descriptor, Allocator, true>::hash_table (size_t size, bool ggc\n+hash_table<Descriptor, Allocator>::hash_table (size_t size, bool ggc\n \t\t\t\t\t\t     MEM_STAT_DECL) :\n   m_n_elements (0), m_n_deleted (0), m_searches (0), m_collisions (0),\n   m_ggc (ggc)\n@@ -1312,7 +778,7 @@ hash_table<Descriptor, Allocator, true>::hash_table (size_t size, bool ggc\n }\n \n template<typename Descriptor, template<typename Type> class Allocator>\n-hash_table<Descriptor, Allocator, true>::~hash_table ()\n+hash_table<Descriptor, Allocator>::~hash_table ()\n {\n   for (size_t i = m_size - 1; i < m_size; i--)\n     if (!is_empty (m_entries[i]) && !is_deleted (m_entries[i]))\n@@ -1327,9 +793,8 @@ hash_table<Descriptor, Allocator, true>::~hash_table ()\n /* This function returns an array of empty hash table elements.  */\n \n template<typename Descriptor, template<typename Type> class Allocator>\n-inline typename hash_table<Descriptor, Allocator, true>::value_type *\n-hash_table<Descriptor, Allocator, true>::alloc_entries\n-\t (size_t n MEM_STAT_DECL) const\n+inline typename hash_table<Descriptor, Allocator>::value_type *\n+hash_table<Descriptor, Allocator>::alloc_entries (size_t n MEM_STAT_DECL) const\n {\n   value_type *nentries;\n \n@@ -1353,9 +818,8 @@ hash_table<Descriptor, Allocator, true>::alloc_entries\n    HASH is the hash value for the element to be inserted.  */\n \n template<typename Descriptor, template<typename Type> class Allocator>\n-typename hash_table<Descriptor, Allocator, true>::value_type *\n-hash_table<Descriptor, Allocator, true>\n-::find_empty_slot_for_expand (hashval_t hash)\n+typename hash_table<Descriptor, Allocator>::value_type *\n+hash_table<Descriptor, Allocator>::find_empty_slot_for_expand (hashval_t hash)\n {\n   hashval_t index = hash_table_mod1 (hash, m_size_prime_index);\n   size_t size = m_size;\n@@ -1393,7 +857,7 @@ ::find_empty_slot_for_expand (hashval_t hash)\n \n \t  template<typename Descriptor, template<typename Type> class Allocator>\n void\n-hash_table<Descriptor, Allocator, true>::expand ()\n+hash_table<Descriptor, Allocator>::expand ()\n {\n   value_type *oentries = m_entries;\n   unsigned int oindex = m_size_prime_index;\n@@ -1447,7 +911,7 @@ hash_table<Descriptor, Allocator, true>::expand ()\n \n template<typename Descriptor, template<typename Type> class Allocator>\n void\n-hash_table<Descriptor, Allocator, true>::empty ()\n+hash_table<Descriptor, Allocator>::empty ()\n {\n   size_t size = m_size;\n   value_type *entries = m_entries;\n@@ -1484,7 +948,7 @@ hash_table<Descriptor, Allocator, true>::empty ()\n \n template<typename Descriptor, template<typename Type> class Allocator>\n void\n-hash_table<Descriptor, Allocator, true>::clear_slot (value_type *slot)\n+hash_table<Descriptor, Allocator>::clear_slot (value_type *slot)\n {\n   gcc_checking_assert (!(slot < m_entries || slot >= m_entries + size ()\n \t\t         || is_empty (*slot) || is_deleted (*slot)));\n@@ -1500,8 +964,8 @@ hash_table<Descriptor, Allocator, true>::clear_slot (value_type *slot)\n    be used to insert or delete an element. */\n \n template<typename Descriptor, template<typename Type> class Allocator>\n-typename hash_table<Descriptor, Allocator, true>::value_type &\n-hash_table<Descriptor, Allocator, true>\n+typename hash_table<Descriptor, Allocator>::value_type &\n+hash_table<Descriptor, Allocator>\n ::find_with_hash (const compare_type &comparable, hashval_t hash)\n {\n   m_searches++;\n@@ -1537,8 +1001,8 @@ ::find_with_hash (const compare_type &comparable, hashval_t hash)\n    entry, NULL may be returned if memory allocation fails. */\n \n template<typename Descriptor, template<typename Type> class Allocator>\n-typename hash_table<Descriptor, Allocator, true>::value_type *\n-hash_table<Descriptor, Allocator, true>\n+typename hash_table<Descriptor, Allocator>::value_type *\n+hash_table<Descriptor, Allocator>\n ::find_slot_with_hash (const compare_type &comparable, hashval_t hash,\n \t\t       enum insert_option insert)\n {\n@@ -1599,7 +1063,7 @@ ::find_slot_with_hash (const compare_type &comparable, hashval_t hash,\n \n template<typename Descriptor, template<typename Type> class Allocator>\n void\n-hash_table<Descriptor, Allocator, true>\n+hash_table<Descriptor, Allocator>\n ::remove_elt_with_hash (const compare_type &comparable, hashval_t hash)\n {\n   value_type *slot = find_slot_with_hash (comparable, hash, NO_INSERT);\n@@ -1619,11 +1083,11 @@ ::remove_elt_with_hash (const compare_type &comparable, hashval_t hash)\n template<typename Descriptor,\n \t  template<typename Type> class Allocator>\n template<typename Argument,\n-\t  int (*Callback) (typename hash_table<Descriptor, Allocator,\n-\t\t\t\t\t       true>::value_type *slot,\n-\t\t\t   Argument argument)>\n+\t  int (*Callback)\n+     (typename hash_table<Descriptor, Allocator>::value_type *slot,\n+      Argument argument)>\n void\n-hash_table<Descriptor, Allocator, true>::traverse_noresize (Argument argument)\n+hash_table<Descriptor, Allocator>::traverse_noresize (Argument argument)\n {\n   value_type *slot = m_entries;\n   value_type *limit = slot + size ();\n@@ -1645,11 +1109,11 @@ hash_table<Descriptor, Allocator, true>::traverse_noresize (Argument argument)\n template <typename Descriptor,\n \t  template <typename Type> class Allocator>\n template <typename Argument,\n-\t  int (*Callback) (typename hash_table<Descriptor, Allocator,\n-\t\t\t\t\t       true>::value_type *slot,\n-\t\t\t   Argument argument)>\n+\t  int (*Callback)\n+     (typename hash_table<Descriptor, Allocator>::value_type *slot,\n+      Argument argument)>\n void\n-hash_table<Descriptor, Allocator, true>::traverse (Argument argument)\n+hash_table<Descriptor, Allocator>::traverse (Argument argument)\n {\n   size_t size = m_size;\n   if (elements () * 8 < size && size > 32)\n@@ -1662,7 +1126,7 @@ hash_table<Descriptor, Allocator, true>::traverse (Argument argument)\n \n template<typename Descriptor, template<typename Type> class Allocator>\n void\n-hash_table<Descriptor, Allocator, true>::iterator::slide ()\n+hash_table<Descriptor, Allocator>::iterator::slide ()\n {\n   for ( ; m_slot < m_limit; ++m_slot )\n     {\n@@ -1677,8 +1141,8 @@ hash_table<Descriptor, Allocator, true>::iterator::slide ()\n /* Bump the iterator.  */\n \n template<typename Descriptor, template<typename Type> class Allocator>\n-inline typename hash_table<Descriptor, Allocator, true>::iterator &\n-hash_table<Descriptor, Allocator, true>::iterator::operator ++ ()\n+inline typename hash_table<Descriptor, Allocator>::iterator &\n+hash_table<Descriptor, Allocator>::iterator::operator ++ ()\n {\n   ++m_slot;\n   slide ();"}, {"sha": "7214a74b8e8cdc66891e5ca53d36d09c76891592", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -308,11 +308,11 @@ type_possibly_instantiated_p (tree t)\n \n struct odr_name_hasher\n {\n-  typedef odr_type_d value_type;\n-  typedef union tree_node compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n-  static inline void remove (value_type *);\n+  typedef odr_type_d *value_type;\n+  typedef union tree_node *compare_type;\n+  static inline hashval_t hash (const odr_type_d *);\n+  static inline bool equal (const odr_type_d *, const tree_node *);\n+  static inline void remove (odr_type_d *);\n };\n \n /* Has used to unify ODR types based on their associated virtual table.\n@@ -321,8 +321,8 @@ struct odr_name_hasher\n \n struct odr_vtable_hasher:odr_name_hasher\n {\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  static inline hashval_t hash (const odr_type_d *);\n+  static inline bool equal (const odr_type_d *, const tree_node *);\n };\n \n /* Return type that was declared with T's name so that T is an\n@@ -369,7 +369,7 @@ hash_odr_name (const_tree t)\n /* Return the computed hashcode for ODR_TYPE.  */\n \n inline hashval_t\n-odr_name_hasher::hash (const value_type *odr_type)\n+odr_name_hasher::hash (const odr_type_d *odr_type)\n {\n   return hash_odr_name (odr_type->type);\n }\n@@ -414,7 +414,7 @@ hash_odr_vtable (const_tree t)\n /* Return the computed hashcode for ODR_TYPE.  */\n \n inline hashval_t\n-odr_vtable_hasher::hash (const value_type *odr_type)\n+odr_vtable_hasher::hash (const odr_type_d *odr_type)\n {\n   return hash_odr_vtable (odr_type->type);\n }\n@@ -553,7 +553,7 @@ types_must_be_same_for_odr (tree t1, tree t2)\n    equivalent.  */\n \n inline bool\n-odr_name_hasher::equal (const value_type *o1, const compare_type *t2)\n+odr_name_hasher::equal (const odr_type_d *o1, const tree_node *t2)\n {\n   tree t1 = o1->type;\n \n@@ -578,7 +578,7 @@ odr_name_hasher::equal (const value_type *o1, const compare_type *t2)\n    equivalent.  */\n \n inline bool\n-odr_vtable_hasher::equal (const value_type *o1, const compare_type *t2)\n+odr_vtable_hasher::equal (const odr_type_d *o1, const tree_node *t2)\n {\n   tree t1 = o1->type;\n \n@@ -602,7 +602,7 @@ odr_vtable_hasher::equal (const value_type *o1, const compare_type *t2)\n /* Free ODR type V.  */\n \n inline void\n-odr_name_hasher::remove (value_type *v)\n+odr_name_hasher::remove (odr_type_d *v)\n {\n   v->bases.release ();\n   v->derived_types.release ();\n@@ -2507,17 +2507,18 @@ struct polymorphic_call_target_d\n \n struct polymorphic_call_target_hasher \n {\n-  typedef polymorphic_call_target_d value_type;\n-  typedef polymorphic_call_target_d compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n-  static inline void remove (value_type *);\n+  typedef polymorphic_call_target_d *value_type;\n+  typedef polymorphic_call_target_d *compare_type;\n+  static inline hashval_t hash (const polymorphic_call_target_d *);\n+  static inline bool equal (const polymorphic_call_target_d *,\n+\t\t\t    const polymorphic_call_target_d *);\n+  static inline void remove (polymorphic_call_target_d *);\n };\n \n /* Return the computed hashcode for ODR_QUERY.  */\n \n inline hashval_t\n-polymorphic_call_target_hasher::hash (const value_type *odr_query)\n+polymorphic_call_target_hasher::hash (const polymorphic_call_target_d *odr_query)\n {\n   inchash::hash hstate (odr_query->otr_token);\n \n@@ -2541,8 +2542,8 @@ polymorphic_call_target_hasher::hash (const value_type *odr_query)\n /* Compare cache entries T1 and T2.  */\n \n inline bool\n-polymorphic_call_target_hasher::equal (const value_type *t1,\n-\t\t\t\t       const compare_type *t2)\n+polymorphic_call_target_hasher::equal (const polymorphic_call_target_d *t1,\n+\t\t\t\t       const polymorphic_call_target_d *t2)\n {\n   return (t1->type == t2->type && t1->otr_token == t2->otr_token\n \t  && t1->speculative == t2->speculative\n@@ -2560,7 +2561,7 @@ polymorphic_call_target_hasher::equal (const value_type *t1,\n /* Remove entry in polymorphic call target cache hash.  */\n \n inline void\n-polymorphic_call_target_hasher::remove (value_type *v)\n+polymorphic_call_target_hasher::remove (polymorphic_call_target_d *v)\n {\n   v->targets.release ();\n   free (v);"}, {"sha": "b9d70b4537e594217d5860d518c4fbec49f49ebb", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -429,15 +429,16 @@ struct congruence_class_group\n /* Congruence class set structure.  */\n struct congruence_class_group_hash: typed_noop_remove <congruence_class_group>\n {\n-  typedef congruence_class_group value_type;\n-  typedef congruence_class_group compare_type;\n+  typedef congruence_class_group *value_type;\n+  typedef congruence_class_group *compare_type;\n \n-  static inline hashval_t hash (const value_type *item)\n+  static inline hashval_t hash (const congruence_class_group *item)\n   {\n     return item->hash;\n   }\n \n-  static inline int equal (const value_type *item1, const compare_type *item2)\n+  static inline int equal (const congruence_class_group *item1,\n+\t\t\t   const congruence_class_group *item2)\n   {\n     return item1->hash == item2->hash && item1->type == item2->type;\n   }"}, {"sha": "96fb8102fc8ca5f7f24db2fcad8a0434ec01b0f9", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -113,10 +113,10 @@ static alloc_pool histogram_pool;\n \n struct histogram_hash : typed_noop_remove <histogram_entry>\n {\n-  typedef histogram_entry value_type;\n-  typedef histogram_entry compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline int equal (const value_type *, const compare_type *);\n+  typedef histogram_entry *value_type;\n+  typedef histogram_entry *compare_type;\n+  static inline hashval_t hash (const histogram_entry *);\n+  static inline int equal (const histogram_entry *, const histogram_entry *);\n };\n \n inline hashval_t"}, {"sha": "0ed9eddfd907186e4f27c02958af0500fc2cc103", "filename": "gcc/ira-color.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -227,22 +227,24 @@ static vec<allocno_hard_regs_t> allocno_hard_regs_vec;\n \n struct allocno_hard_regs_hasher : typed_noop_remove <allocno_hard_regs>\n {\n-  typedef allocno_hard_regs value_type;\n-  typedef allocno_hard_regs compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef allocno_hard_regs *value_type;\n+  typedef allocno_hard_regs *compare_type;\n+  static inline hashval_t hash (const allocno_hard_regs *);\n+  static inline bool equal (const allocno_hard_regs *,\n+\t\t\t    const allocno_hard_regs *);\n };\n \n /* Returns hash value for allocno hard registers V.  */\n inline hashval_t\n-allocno_hard_regs_hasher::hash (const value_type *hv)\n+allocno_hard_regs_hasher::hash (const allocno_hard_regs *hv)\n {\n   return iterative_hash (&hv->set, sizeof (HARD_REG_SET), 0);\n }\n \n /* Compares allocno hard registers V1 and V2.  */\n inline bool\n-allocno_hard_regs_hasher::equal (const value_type *hv1, const compare_type *hv2)\n+allocno_hard_regs_hasher::equal (const allocno_hard_regs *hv1,\n+\t\t\t\t const allocno_hard_regs *hv2)\n {\n   return hard_reg_set_equal_p (hv1->set, hv2->set);\n }"}, {"sha": "5358440e6f1582469849ca7b93eacff5f2ed2f45", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -161,23 +161,23 @@ static cost_classes_t *regno_cost_classes;\n \n struct cost_classes_hasher\n {\n-  typedef cost_classes value_type;\n-  typedef cost_classes compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n-  static inline void remove (value_type *);\n+  typedef cost_classes *value_type;\n+  typedef cost_classes *compare_type;\n+  static inline hashval_t hash (const cost_classes *);\n+  static inline bool equal (const cost_classes *, const cost_classes *);\n+  static inline void remove (cost_classes *);\n };\n \n /* Returns hash value for cost classes info HV.  */\n inline hashval_t\n-cost_classes_hasher::hash (const value_type *hv)\n+cost_classes_hasher::hash (const cost_classes *hv)\n {\n   return iterative_hash (&hv->classes, sizeof (enum reg_class) * hv->num, 0);\n }\n \n /* Compares cost classes info HV1 and HV2.  */\n inline bool\n-cost_classes_hasher::equal (const value_type *hv1, const compare_type *hv2)\n+cost_classes_hasher::equal (const cost_classes *hv1, const cost_classes *hv2)\n {\n   return (hv1->num == hv2->num\n \t  && memcmp (hv1->classes, hv2->classes,\n@@ -186,7 +186,7 @@ cost_classes_hasher::equal (const value_type *hv1, const compare_type *hv2)\n \n /* Delete cost classes info V from the hash table.  */\n inline void\n-cost_classes_hasher::remove (value_type *v)\n+cost_classes_hasher::remove (cost_classes *v)\n {\n   ira_free (v);\n }"}, {"sha": "9ebc248f1b06899e7491d67ae7ddee90ef3f9909", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -1,3 +1,7 @@\n+2015-04-18  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* jcf-io.c: Adjust for hash_table changes.\n+\n 2015-01-30  Joseph Myers  <joseph@codesourcery.com>\n \n \t* class.c, expr.c, jcf-parse.c, jvspec.c: All callers of"}, {"sha": "36ceb074cf305e402b6fc8119c300d236f6af8af", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -285,21 +285,20 @@ find_classfile (char *filename, JCF *jcf, const char *dep_name)\n \n struct charstar_hash : typed_noop_remove <char>\n {\n-  typedef const char value_type;\n-  typedef const char compare_type;\n-  static inline hashval_t hash (const value_type *candidate);\n-  static inline bool equal (const value_type *existing,\n-\t\t\t    const compare_type *candidate);\n+  typedef const char *value_type;\n+  typedef const char *compare_type;\n+  static inline hashval_t hash (const char *candidate);\n+  static inline bool equal (const char *existing, const char *candidate);\n };\n \n inline hashval_t\n-charstar_hash::hash (const value_type *candidate)\n+charstar_hash::hash (const char *candidate)\n {\n   return htab_hash_string (candidate);\n }\n \n inline bool\n-charstar_hash::equal (const value_type *existing, const compare_type *candidate)\n+charstar_hash::equal (const char *existing, const char *candidate)\n {\n   return strcmp (existing, candidate) == 0;\n }"}, {"sha": "52ecc0574e22ce2a846b769cf89c059d1c7f4a2e", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -455,25 +455,26 @@ invariant_expr_equal_p (rtx_insn *insn1, rtx e1, rtx_insn *insn2, rtx e2)\n \n struct invariant_expr_hasher : typed_free_remove <invariant_expr_entry>\n {\n-  typedef invariant_expr_entry value_type;\n-  typedef invariant_expr_entry compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef invariant_expr_entry *value_type;\n+  typedef invariant_expr_entry *compare_type;\n+  static inline hashval_t hash (const invariant_expr_entry *);\n+  static inline bool equal (const invariant_expr_entry *,\n+\t\t\t    const invariant_expr_entry *);\n };\n \n /* Returns hash value for invariant expression entry ENTRY.  */\n \n inline hashval_t\n-invariant_expr_hasher::hash (const value_type *entry)\n+invariant_expr_hasher::hash (const invariant_expr_entry *entry)\n {\n   return entry->hash;\n }\n \n /* Compares invariant expression entries ENTRY1 and ENTRY2.  */\n \n inline bool\n-invariant_expr_hasher::equal (const value_type *entry1,\n-\t\t\t      const compare_type *entry2)\n+invariant_expr_hasher::equal (const invariant_expr_entry *entry1,\n+\t\t\t      const invariant_expr_entry *entry2)\n {\n   if (entry1->mode != entry2->mode)\n     return 0;"}, {"sha": "36a9a9f616ee494f0f833da0c62103f5c48498ad", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -138,24 +138,24 @@ static struct loop *current_loop;\n \n struct biv_entry_hasher : typed_free_remove <biv_entry>\n {\n-  typedef biv_entry value_type;\n-  typedef rtx_def compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef biv_entry *value_type;\n+  typedef rtx_def *compare_type;\n+  static inline hashval_t hash (const biv_entry *);\n+  static inline bool equal (const biv_entry *, const rtx_def *);\n };\n \n /* Returns hash value for biv B.  */\n \n inline hashval_t\n-biv_entry_hasher::hash (const value_type *b)\n+biv_entry_hasher::hash (const biv_entry *b)\n {\n   return b->regno;\n }\n \n /* Compares biv B and register R.  */\n \n inline bool\n-biv_entry_hasher::equal (const value_type *b, const compare_type *r)\n+biv_entry_hasher::equal (const biv_entry *b, const rtx_def *r)\n {\n   return b->regno == REGNO (r);\n }"}, {"sha": "ccf473d4a54a897679849803ab26cef1e67c2efc", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -126,25 +126,25 @@ struct var_to_expand\n \n struct iv_split_hasher : typed_free_remove <iv_to_split>\n {\n-  typedef iv_to_split value_type;\n-  typedef iv_to_split compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef iv_to_split *value_type;\n+  typedef iv_to_split *compare_type;\n+  static inline hashval_t hash (const iv_to_split *);\n+  static inline bool equal (const iv_to_split *, const iv_to_split *);\n };\n \n \n /* A hash function for information about insns to split.  */\n \n inline hashval_t\n-iv_split_hasher::hash (const value_type *ivts)\n+iv_split_hasher::hash (const iv_to_split *ivts)\n {\n   return (hashval_t) INSN_UID (ivts->insn);\n }\n \n /* An equality functions for information about insns to split.  */\n \n inline bool\n-iv_split_hasher::equal (const value_type *i1, const compare_type *i2)\n+iv_split_hasher::equal (const iv_to_split *i1, const iv_to_split *i2)\n {\n   return i1->insn == i2->insn;\n }\n@@ -153,24 +153,24 @@ iv_split_hasher::equal (const value_type *i1, const compare_type *i2)\n \n struct var_expand_hasher : typed_free_remove <var_to_expand>\n {\n-  typedef var_to_expand value_type;\n-  typedef var_to_expand compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef var_to_expand *value_type;\n+  typedef var_to_expand *compare_type;\n+  static inline hashval_t hash (const var_to_expand *);\n+  static inline bool equal (const var_to_expand *, const var_to_expand *);\n };\n \n /* Return a hash for VES.  */\n \n inline hashval_t\n-var_expand_hasher::hash (const value_type *ves)\n+var_expand_hasher::hash (const var_to_expand *ves)\n {\n   return (hashval_t) INSN_UID (ves->insn);\n }\n \n /* Return true if I1 and I2 refer to the same instruction.  */\n \n inline bool\n-var_expand_hasher::equal (const value_type *i1, const compare_type *i2)\n+var_expand_hasher::equal (const var_to_expand *i1, const var_to_expand *i2)\n {\n   return i1->insn == i2->insn;\n }"}, {"sha": "e3465a834bcb403a2ee9ffd2ea1b0cc1c65b17ae", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -657,17 +657,17 @@ struct string_slot\n \n struct string_slot_hasher : typed_noop_remove <string_slot>\n {\n-  typedef string_slot value_type;\n-  typedef string_slot compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef string_slot *value_type;\n+  typedef string_slot *compare_type;\n+  static inline hashval_t hash (const string_slot *);\n+  static inline bool equal (const string_slot *, const string_slot *);\n };\n \n /* Returns a hash code for DS.  Adapted from libiberty's htab_hash_string\n    to support strings that may not end in '\\0'.  */\n \n inline hashval_t\n-string_slot_hasher::hash (const value_type *ds)\n+string_slot_hasher::hash (const string_slot *ds)\n {\n   hashval_t r = ds->len;\n   int i;\n@@ -680,7 +680,7 @@ string_slot_hasher::hash (const value_type *ds)\n /* Returns nonzero if DS1 and DS2 are equal.  */\n \n inline bool\n-string_slot_hasher::equal (const value_type *ds1, const compare_type *ds2)\n+string_slot_hasher::equal (const string_slot *ds1, const string_slot *ds2)\n {\n   if (ds1->len == ds2->len)\n     return memcmp (ds1->s, ds2->s, ds1->len) == 0;"}, {"sha": "0815e5841906a64c63959e253bca4a413b2baf9f", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -1,3 +1,7 @@\n+2015-04-18  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* \tlto.c: Adjust for hash_table changes.\n+\n 2015-03-27  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto.c (lto_read_decls): Move code registering odr types out"}, {"sha": "f3458c7a72c38b1c4aa1b8aeab4d531448795ccc", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -1143,20 +1143,20 @@ struct tree_scc\n \n struct tree_scc_hasher : typed_noop_remove <tree_scc>\n {\n-  typedef tree_scc value_type;\n-  typedef tree_scc compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef tree_scc *value_type;\n+  typedef tree_scc *compare_type;\n+  static inline hashval_t hash (const tree_scc *);\n+  static inline bool equal (const tree_scc *, const tree_scc *);\n };\n \n hashval_t\n-tree_scc_hasher::hash (const value_type *scc)\n+tree_scc_hasher::hash (const tree_scc *scc)\n {\n   return scc->hash;\n }\n \n bool\n-tree_scc_hasher::equal (const value_type *scc1, const compare_type *scc2)\n+tree_scc_hasher::equal (const tree_scc *scc1, const tree_scc *scc2)\n {\n   if (scc1->hash != scc2->hash\n       || scc1->len != scc2->len"}, {"sha": "84d27b27c118dc7003ea67d1d7315606a9c9244e", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -1,3 +1,7 @@\n+2015-04-18  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* objc-act.c: Adjust for hash_table changes.\n+\n 2015-01-09  Michael Collison  <michael.collison@linaro.org>\n \n \t* objc-act.c: Include hash-set.h, machmode.h, vec.h, double-int.h,"}, {"sha": "718fdf08bcdc49fff29ed28a8b6e084a0d08c15a", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -3871,20 +3871,20 @@ objc_get_class_ivars (tree class_name)\n \n struct decl_name_hash : typed_noop_remove <tree_node>\n {\n-  typedef tree_node value_type;\n-  typedef tree_node compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef tree_node *value_type;\n+  typedef tree_node *compare_type;\n+  static inline hashval_t hash (const tree_node *);\n+  static inline bool equal (const tree_node *, const tree_node *);\n };\n \n inline hashval_t\n-decl_name_hash::hash (const value_type *q)\n+decl_name_hash::hash (const tree_node *q)\n {\n   return (hashval_t) ((intptr_t)(DECL_NAME (q)) >> 3);\n }\n \n inline bool\n-decl_name_hash::equal (const value_type *a, const compare_type *b)\n+decl_name_hash::equal (const tree_node *a, const tree_node *b)\n {\n   return DECL_NAME (a) == DECL_NAME (b);\n }"}, {"sha": "6a7654f04643f38ff906ca2d936754948b617854", "filename": "gcc/plugin.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fplugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fplugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -66,16 +66,16 @@ const char **plugin_event_name = plugin_event_name_init;\n \n struct event_hasher : typed_noop_remove <const char *>\n {\n-  typedef const char *value_type;\n-  typedef const char *compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef const char **value_type;\n+  typedef const char **compare_type;\n+  static inline hashval_t hash (const char **);\n+  static inline bool equal (const char **, const char **);\n };\n \n /* Helper function for the event hash table that hashes the entry V.  */\n \n inline hashval_t\n-event_hasher::hash (const value_type *v)\n+event_hasher::hash (const char **v)\n {\n   return htab_hash_string (*v);\n }\n@@ -84,7 +84,7 @@ event_hasher::hash (const value_type *v)\n    existing entry (S1) with the given string (S2).  */\n \n inline bool\n-event_hasher::equal (const value_type *s1, const compare_type *s2)\n+event_hasher::equal (const char **s1, const char **s2)\n {\n   return !strcmp (*s1, *s2);\n }"}, {"sha": "9014d69df2065891c52762cf1a408bc0a9b86600", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -134,10 +134,10 @@ struct expr\n \n struct expr_hasher : typed_noop_remove <expr>\n {\n-  typedef expr value_type;\n-  typedef expr compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef expr *value_type;\n+  typedef expr *compare_type;\n+  static inline hashval_t hash (const expr *);\n+  static inline bool equal (const expr *, const expr *);\n };\n \n \n@@ -159,7 +159,7 @@ hash_expr (rtx x, int *do_not_record_p)\n    here, we just return the cached hash value.  */\n \n inline hashval_t\n-expr_hasher::hash (const value_type *exp)\n+expr_hasher::hash (const expr *exp)\n {\n   return exp->hash;\n }\n@@ -168,7 +168,7 @@ expr_hasher::hash (const value_type *exp)\n    Return nonzero if exp1 is equivalent to exp2.  */\n \n inline bool\n-expr_hasher::equal (const value_type *exp1, const compare_type *exp2)\n+expr_hasher::equal (const expr *exp1, const expr *exp2)\n {\n   int equiv_p = exp_equiv_p (exp1->expr, exp2->expr, 0, true);\n "}, {"sha": "6678688e105c2acc6559b041ebcf0099bfbb1488", "filename": "gcc/reginfo.c", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -85,15 +85,6 @@ struct simplifiable_subreg\n   subreg_shape shape;\n   HARD_REG_SET simplifiable_regs;\n };\n-\n-struct simplifiable_subregs_hasher : typed_noop_remove <simplifiable_subreg>\n-{\n-  typedef simplifiable_subreg value_type;\n-  typedef subreg_shape compare_type;\n-\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n-};\n \f\n struct target_hard_regs default_target_hard_regs;\n struct target_regs default_target_regs;\n@@ -1234,14 +1225,14 @@ reg_classes_intersect_p (reg_class_t c1, reg_class_t c2)\n \n \f\n inline hashval_t\n-simplifiable_subregs_hasher::hash (const value_type *value)\n+simplifiable_subregs_hasher::hash (const simplifiable_subreg *value)\n {\n   return value->shape.unique_id ();\n }\n \n inline bool\n-simplifiable_subregs_hasher::equal (const value_type *value,\n-\t\t\t\t    const compare_type *compare)\n+simplifiable_subregs_hasher::equal (const simplifiable_subreg *value,\n+\t\t\t\t    const subreg_shape *compare)\n {\n   return value->shape == *compare;\n }"}, {"sha": "8cbe88d4a906d554feea8bc6596aeafd8cf5408a", "filename": "gcc/statistics.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fstatistics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fstatistics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstatistics.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -55,33 +55,35 @@ typedef struct statistics_counter_s {\n \n struct stats_counter_hasher\n {\n-  typedef statistics_counter_t value_type;\n-  typedef statistics_counter_t compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n-  static inline void remove (value_type *);\n+  typedef statistics_counter_t *value_type;\n+  typedef statistics_counter_t *compare_type;\n+  static inline hashval_t hash (const statistics_counter_t *);\n+  static inline bool equal (const statistics_counter_t *,\n+\t\t\t    const statistics_counter_t *);\n+  static inline void remove (statistics_counter_t *);\n };\n \n /* Hash a statistic counter by its string ID.  */\n \n inline hashval_t\n-stats_counter_hasher::hash (const value_type *c)\n+stats_counter_hasher::hash (const statistics_counter_t *c)\n {\n   return htab_hash_string (c->id) + c->val;\n }\n \n /* Compare two statistic counters by their string IDs.  */\n \n inline bool\n-stats_counter_hasher::equal (const value_type *c1, const compare_type *c2)\n+stats_counter_hasher::equal (const statistics_counter_t *c1,\n+\t\t\t     const statistics_counter_t *c2)\n {\n   return c1->val == c2->val && strcmp (c1->id, c2->id) == 0;\n }\n \n /* Free a statistics entry.  */\n \n inline void\n-stats_counter_hasher::remove (value_type *v)\n+stats_counter_hasher::remove (statistics_counter_t *v)\n {\n   free (CONST_CAST (char *, v->id));\n   free (v);"}, {"sha": "d621ec11b147c60cf0143d3049034cd602ced81e", "filename": "gcc/store-motion.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -137,21 +137,21 @@ static struct edge_list *edge_list;\n \n struct st_expr_hasher : typed_noop_remove <st_expr>\n {\n-  typedef st_expr value_type;\n-  typedef st_expr compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef st_expr *value_type;\n+  typedef st_expr *compare_type;\n+  static inline hashval_t hash (const st_expr *);\n+  static inline bool equal (const st_expr *, const st_expr *);\n };\n \n inline hashval_t\n-st_expr_hasher::hash (const value_type *x)\n+st_expr_hasher::hash (const st_expr *x)\n {\n   int do_not_record_p = 0;\n   return hash_rtx (x->pattern, GET_MODE (x->pattern), &do_not_record_p, NULL, false);\n }\n \n inline bool\n-st_expr_hasher::equal (const value_type *ptr1, const compare_type *ptr2)\n+st_expr_hasher::equal (const st_expr *ptr1, const st_expr *ptr2)\n {\n   return exp_equiv_p (ptr1->pattern, ptr2->pattern, 0, true);\n }"}, {"sha": "d6cbd7611bb3acfa9e6f7255754f4e34804226af", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -974,23 +974,23 @@ typedef struct tm_log_entry\n \n struct log_entry_hasher\n {\n-  typedef tm_log_entry value_type;\n-  typedef tm_log_entry compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n-  static inline void remove (value_type *);\n+  typedef tm_log_entry *value_type;\n+  typedef tm_log_entry *compare_type;\n+  static inline hashval_t hash (const tm_log_entry *);\n+  static inline bool equal (const tm_log_entry *, const tm_log_entry *);\n+  static inline void remove (tm_log_entry *);\n };\n \n /* Htab support.  Return hash value for a `tm_log_entry'.  */\n inline hashval_t\n-log_entry_hasher::hash (const value_type *log)\n+log_entry_hasher::hash (const tm_log_entry *log)\n {\n   return iterative_hash_expr (log->addr, 0);\n }\n \n /* Htab support.  Return true if two log entries are the same.  */\n inline bool\n-log_entry_hasher::equal (const value_type *log1, const compare_type *log2)\n+log_entry_hasher::equal (const tm_log_entry *log1, const tm_log_entry *log2)\n {\n   /* FIXME:\n \n@@ -1016,7 +1016,7 @@ log_entry_hasher::equal (const value_type *log1, const compare_type *log2)\n \n /* Htab support.  Free one tm_log_entry.  */\n inline void\n-log_entry_hasher::remove (value_type *lp)\n+log_entry_hasher::remove (tm_log_entry *lp)\n {\n   lp->stmts.release ();\n   free (lp);\n@@ -1049,20 +1049,20 @@ typedef struct tm_new_mem_map\n \n struct tm_mem_map_hasher : typed_free_remove <tm_new_mem_map_t>\n {\n-  typedef tm_new_mem_map_t value_type;\n-  typedef tm_new_mem_map_t compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef tm_new_mem_map_t *value_type;\n+  typedef tm_new_mem_map_t *compare_type;\n+  static inline hashval_t hash (const tm_new_mem_map_t *);\n+  static inline bool equal (const tm_new_mem_map_t *, const tm_new_mem_map_t *);\n };\n \n inline hashval_t\n-tm_mem_map_hasher::hash (const value_type *v)\n+tm_mem_map_hasher::hash (const tm_new_mem_map_t *v)\n {\n   return (intptr_t)v->val >> 4;\n }\n \n inline bool\n-tm_mem_map_hasher::equal (const value_type *v, const compare_type *c)\n+tm_mem_map_hasher::equal (const tm_new_mem_map_t *v, const tm_new_mem_map_t *c)\n {\n   return v->val == c->val;\n }\n@@ -3350,15 +3350,15 @@ typedef struct tm_memop\n \n struct tm_memop_hasher : typed_free_remove <tm_memop>\n {\n-  typedef tm_memop value_type;\n-  typedef tm_memop compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef tm_memop *value_type;\n+  typedef tm_memop *compare_type;\n+  static inline hashval_t hash (const tm_memop *);\n+  static inline bool equal (const tm_memop *, const tm_memop *);\n };\n \n /* Htab support.  Return a hash value for a `tm_memop'.  */\n inline hashval_t\n-tm_memop_hasher::hash (const value_type *mem)\n+tm_memop_hasher::hash (const tm_memop *mem)\n {\n   tree addr = mem->addr;\n   /* We drill down to the SSA_NAME/DECL for the hash, but equality is\n@@ -3370,7 +3370,7 @@ tm_memop_hasher::hash (const value_type *mem)\n \n /* Htab support.  Return true if two tm_memop's are the same.  */\n inline bool\n-tm_memop_hasher::equal (const value_type *mem1, const compare_type *mem2)\n+tm_memop_hasher::equal (const tm_memop *mem1, const tm_memop *mem2)\n {\n   return operand_equal_p (mem1->addr, mem2->addr, 0);\n }"}, {"sha": "492962957f3ba8ddb2e45bac161c7a0081c8e6bf", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -148,17 +148,18 @@ struct locus_discrim_map\n \n struct locus_discrim_hasher : typed_free_remove <locus_discrim_map>\n {\n-  typedef locus_discrim_map value_type;\n-  typedef locus_discrim_map compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef locus_discrim_map *value_type;\n+  typedef locus_discrim_map *compare_type;\n+  static inline hashval_t hash (const locus_discrim_map *);\n+  static inline bool equal (const locus_discrim_map *,\n+\t\t\t    const locus_discrim_map *);\n };\n \n /* Trivial hash function for a location_t.  ITEM is a pointer to\n    a hash table entry that maps a location_t to a discriminator.  */\n \n inline hashval_t\n-locus_discrim_hasher::hash (const value_type *item)\n+locus_discrim_hasher::hash (const locus_discrim_map *item)\n {\n   return LOCATION_LINE (item->locus);\n }\n@@ -167,7 +168,8 @@ locus_discrim_hasher::hash (const value_type *item)\n    point to the two hash table entries to compare.  */\n \n inline bool\n-locus_discrim_hasher::equal (const value_type *a, const compare_type *b)\n+locus_discrim_hasher::equal (const locus_discrim_map *a,\n+\t\t\t     const locus_discrim_map *b)\n {\n   return LOCATION_LINE (a->locus) == LOCATION_LINE (b->locus);\n }"}, {"sha": "5d41cb423290ecf0db49c939f8c12f6191f1aa0b", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -214,20 +214,22 @@ struct finally_tree_node\n \n struct finally_tree_hasher : typed_free_remove <finally_tree_node>\n {\n-  typedef finally_tree_node value_type;\n-  typedef finally_tree_node compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef finally_tree_node *value_type;\n+  typedef finally_tree_node *compare_type;\n+  static inline hashval_t hash (const finally_tree_node *);\n+  static inline bool equal (const finally_tree_node *,\n+\t\t\t    const finally_tree_node *);\n };\n \n inline hashval_t\n-finally_tree_hasher::hash (const value_type *v)\n+finally_tree_hasher::hash (const finally_tree_node *v)\n {\n   return (intptr_t)v->child.t >> 4;\n }\n \n inline bool\n-finally_tree_hasher::equal (const value_type *v, const compare_type *c)\n+finally_tree_hasher::equal (const finally_tree_node *v,\n+\t\t\t    const finally_tree_node *c)\n {\n   return v->child.t == c->child.t;\n }"}, {"sha": "228e317e1aec6aca6474f83376e9c8def5838e75", "filename": "gcc/tree-hasher.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-hasher.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-hasher.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-hasher.h?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -34,7 +34,6 @@ struct int_tree_hasher\n {\n   typedef int_tree_map value_type;\n   typedef int_tree_map compare_type;\n-  typedef int store_values_directly;\n   static inline hashval_t hash (const value_type &);\n   static inline bool equal (const value_type &, const compare_type &);\n   static bool is_deleted (const value_type &v)"}, {"sha": "e8b55c134de7f7b73aed4ca8d981275fae3c6886", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -232,7 +232,6 @@ struct var_info_hasher : typed_free_remove <var_info_d>\n {\n   typedef var_info_d *value_type;\n   typedef var_info_d *compare_type;\n-  typedef int store_values_directly;\n   static inline hashval_t hash (const value_type &);\n   static inline bool equal (const value_type &, const compare_type &);\n };"}, {"sha": "080d35ea527968ef8d6154f48c774d1be88ed888", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -228,22 +228,22 @@ struct reduction_info\n \n struct reduction_hasher : typed_free_remove <reduction_info>\n {\n-  typedef reduction_info value_type;\n-  typedef reduction_info compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef reduction_info *value_type;\n+  typedef reduction_info *compare_type;\n+  static inline hashval_t hash (const reduction_info *);\n+  static inline bool equal (const reduction_info *, const reduction_info *);\n };\n \n /* Equality and hash functions for hashtab code.  */\n \n inline bool\n-reduction_hasher::equal (const value_type *a, const compare_type *b)\n+reduction_hasher::equal (const reduction_info *a, const reduction_info *b)\n {\n   return (a->reduc_phi == b->reduc_phi);\n }\n \n inline hashval_t\n-reduction_hasher::hash (const value_type *a)\n+reduction_hasher::hash (const reduction_info *a)\n {\n   return a->reduc_version;\n }\n@@ -280,22 +280,22 @@ struct name_to_copy_elt\n \n struct name_to_copy_hasher : typed_free_remove <name_to_copy_elt>\n {\n-  typedef name_to_copy_elt value_type;\n-  typedef name_to_copy_elt compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef name_to_copy_elt *value_type;\n+  typedef name_to_copy_elt *compare_type;\n+  static inline hashval_t hash (const name_to_copy_elt *);\n+  static inline bool equal (const name_to_copy_elt *, const name_to_copy_elt *);\n };\n \n /* Equality and hash functions for hashtab code.  */\n \n inline bool\n-name_to_copy_hasher::equal (const value_type *a, const compare_type *b)\n+name_to_copy_hasher::equal (const name_to_copy_elt *a, const name_to_copy_elt *b)\n {\n   return a->version == b->version;\n }\n \n inline hashval_t\n-name_to_copy_hasher::hash (const value_type *a)\n+name_to_copy_hasher::hash (const name_to_copy_elt *a)\n {\n   return (hashval_t) a->version;\n }"}, {"sha": "4b0d2a8b389492d2009e3f4fd643dba1d3330e35", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -327,24 +327,24 @@ static hash_map<tree, auto_vec<access_p> > *base_access_vec;\n \n struct uid_decl_hasher : typed_noop_remove <tree_node>\n {\n-  typedef tree_node value_type;\n-  typedef tree_node compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef tree_node *value_type;\n+  typedef tree_node *compare_type;\n+  static inline hashval_t hash (const tree_node *);\n+  static inline bool equal (const tree_node *, const tree_node *);\n };\n \n /* Hash a tree in a uid_decl_map.  */\n \n inline hashval_t\n-uid_decl_hasher::hash (const value_type *item)\n+uid_decl_hasher::hash (const tree_node *item)\n {\n   return item->decl_minimal.uid;\n }\n \n /* Return true if the DECL_UID in both trees are equal.  */\n \n inline bool\n-uid_decl_hasher::equal (const value_type *a, const compare_type *b)\n+uid_decl_hasher::equal (const tree_node *a, const tree_node *b)\n {\n   return (a->decl_minimal.uid == b->decl_minimal.uid);\n }"}, {"sha": "eeac5a46ab99a03d92bad40b794436234744d9e2", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -81,16 +81,16 @@ typedef const struct coalesce_pair *const_coalesce_pair_p;\n \n struct coalesce_pair_hasher : typed_noop_remove <coalesce_pair>\n {\n-  typedef coalesce_pair value_type;\n-  typedef coalesce_pair compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef coalesce_pair *value_type;\n+  typedef coalesce_pair *compare_type;\n+  static inline hashval_t hash (const coalesce_pair *);\n+  static inline bool equal (const coalesce_pair *, const coalesce_pair *);\n };\n \n /* Hash function for coalesce list.  Calculate hash for PAIR.   */\n \n inline hashval_t\n-coalesce_pair_hasher::hash (const value_type *pair)\n+coalesce_pair_hasher::hash (const coalesce_pair *pair)\n {\n   hashval_t a = (hashval_t)(pair->first_element);\n   hashval_t b = (hashval_t)(pair->second_element);\n@@ -102,7 +102,7 @@ coalesce_pair_hasher::hash (const value_type *pair)\n    returning TRUE if the two pairs are equivalent.  */\n \n inline bool\n-coalesce_pair_hasher::equal (const value_type *p1, const compare_type *p2)\n+coalesce_pair_hasher::equal (const coalesce_pair *p1, const coalesce_pair *p2)\n {\n   return (p1->first_element == p2->first_element\n \t  && p1->second_element == p2->second_element);\n@@ -1253,10 +1253,10 @@ coalesce_partitions (var_map map, ssa_conflicts_p graph, coalesce_list_p cl,\n \n struct ssa_name_var_hash : typed_noop_remove <tree_node>\n {\n-  typedef union tree_node value_type;\n-  typedef union tree_node compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline int equal (const value_type *, const compare_type *);\n+  typedef union tree_node *value_type;\n+  typedef union tree_node *compare_type;\n+  static inline hashval_t hash (const tree_node *);\n+  static inline int equal (const tree_node *, const tree_node *);\n };\n \n inline hashval_t\n@@ -1266,7 +1266,7 @@ ssa_name_var_hash::hash (const_tree n)\n }\n \n inline int\n-ssa_name_var_hash::equal (const value_type *n1, const compare_type *n2)\n+ssa_name_var_hash::equal (const tree_node *n1, const tree_node *n2)\n {\n   return SSA_NAME_VAR (n1) == SSA_NAME_VAR (n2);\n }"}, {"sha": "355c84c076f8b843d7f9724cae217ee90c6ba957", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -183,7 +183,6 @@ struct expr_elt_hasher\n {\n   typedef expr_hash_elt *value_type;\n   typedef expr_hash_elt *compare_type;\n-  typedef int store_values_directly;\n   static inline hashval_t hash (const value_type &);\n   static inline bool equal (const value_type &, const compare_type &);\n   static inline void remove (value_type &);"}, {"sha": "2c7c07298701056cce7dd8b10133f476ce0a36af", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -104,20 +104,20 @@ static void  verify_live_on_entry (tree_live_info_p);\n \n struct tree_int_map_hasher : typed_noop_remove <tree_int_map>\n {\n-  typedef tree_int_map value_type;\n-  typedef tree_int_map compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef tree_int_map *value_type;\n+  typedef tree_int_map *compare_type;\n+  static inline hashval_t hash (const tree_int_map *);\n+  static inline bool equal (const tree_int_map *, const tree_int_map *);\n };\n \n inline hashval_t\n-tree_int_map_hasher::hash (const value_type *v)\n+tree_int_map_hasher::hash (const tree_int_map *v)\n {\n   return tree_map_base_hash (v);\n }\n \n inline bool\n-tree_int_map_hasher::equal (const value_type *v, const compare_type *c)\n+tree_int_map_hasher::equal (const tree_int_map *v, const tree_int_map *c)\n {\n   return tree_int_map_eq (v, c);\n }"}, {"sha": "11fc699433d40e61a0957b0e8c0b4113ef420e26", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -172,16 +172,16 @@ typedef struct im_mem_ref\n \n struct mem_ref_hasher : typed_noop_remove <im_mem_ref>\n {\n-  typedef im_mem_ref value_type;\n-  typedef tree_node compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef im_mem_ref *value_type;\n+  typedef tree_node *compare_type;\n+  static inline hashval_t hash (const im_mem_ref *);\n+  static inline bool equal (const im_mem_ref *, const tree_node *);\n };\n \n /* A hash function for struct im_mem_ref object OBJ.  */\n \n inline hashval_t\n-mem_ref_hasher::hash (const value_type *mem)\n+mem_ref_hasher::hash (const im_mem_ref *mem)\n {\n   return mem->hash;\n }\n@@ -190,7 +190,7 @@ mem_ref_hasher::hash (const value_type *mem)\n    memory reference OBJ2.  */\n \n inline bool\n-mem_ref_hasher::equal (const value_type *mem1, const compare_type *obj2)\n+mem_ref_hasher::equal (const im_mem_ref *mem1, const tree_node *obj2)\n {\n   return operand_equal_p (mem1->mem.ref, (const_tree) obj2, 0);\n }"}, {"sha": "d71e3a4d337eefeeadab6bf187bc6a1e31a9cddd", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -292,24 +292,25 @@ typedef struct iv_cand *iv_cand_p;\n \n struct iv_inv_expr_hasher : typed_free_remove <iv_inv_expr_ent>\n {\n-  typedef iv_inv_expr_ent value_type;\n-  typedef iv_inv_expr_ent compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef iv_inv_expr_ent *value_type;\n+  typedef iv_inv_expr_ent *compare_type;\n+  static inline hashval_t hash (const iv_inv_expr_ent *);\n+  static inline bool equal (const iv_inv_expr_ent *, const iv_inv_expr_ent *);\n };\n \n /* Hash function for loop invariant expressions.  */\n \n inline hashval_t\n-iv_inv_expr_hasher::hash (const value_type *expr)\n+iv_inv_expr_hasher::hash (const iv_inv_expr_ent *expr)\n {\n   return expr->hash;\n }\n \n /* Hash table equality function for expressions.  */\n \n inline bool\n-iv_inv_expr_hasher::equal (const value_type *expr1, const compare_type *expr2)\n+iv_inv_expr_hasher::equal (const iv_inv_expr_ent *expr1,\n+\t\t\t   const iv_inv_expr_ent *expr2)\n {\n   return expr1->hash == expr2->hash\n \t && operand_equal_p (expr1->expr, expr2->expr, 0);"}, {"sha": "7c846c2b6e20bf5968a0f8430b4134adc1b6b78e", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -1332,10 +1332,10 @@ struct name_to_bb\n \n struct ssa_names_hasher : typed_free_remove <name_to_bb>\n {\n-  typedef name_to_bb value_type;\n-  typedef name_to_bb compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef name_to_bb *value_type;\n+  typedef name_to_bb *compare_type;\n+  static inline hashval_t hash (const name_to_bb *);\n+  static inline bool equal (const name_to_bb *, const name_to_bb *);\n };\n \n /* Used for quick clearing of the hash-table when we see calls.\n@@ -1345,7 +1345,7 @@ static unsigned int nt_call_phase;\n /* The hash function.  */\n \n inline hashval_t\n-ssa_names_hasher::hash (const value_type *n)\n+ssa_names_hasher::hash (const name_to_bb *n)\n {\n   return n->ssa_name_ver ^ (((hashval_t) n->store) << 31)\n          ^ (n->offset << 6) ^ (n->size << 3);\n@@ -1354,7 +1354,7 @@ ssa_names_hasher::hash (const value_type *n)\n /* The equality function of *P1 and *P2.  */\n \n inline bool\n-ssa_names_hasher::equal (const value_type *n1, const compare_type *n2)\n+ssa_names_hasher::equal (const name_to_bb *n1, const name_to_bb *n2)\n {\n   return n1->ssa_name_ver == n2->ssa_name_ver\n          && n1->store == n2->store"}, {"sha": "d857d8417c3915a57072be67385e14b2452c77e9", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -228,8 +228,8 @@ typedef struct pre_expr_d : typed_noop_remove <pre_expr_d>\n   pre_expr_union u;\n \n   /* hash_table support.  */\n-  typedef pre_expr_d value_type;\n-  typedef pre_expr_d compare_type;\n+  typedef pre_expr_d *value_type;\n+  typedef pre_expr_d *compare_type;\n   static inline hashval_t hash (const pre_expr_d *);\n   static inline int equal (const pre_expr_d *, const pre_expr_d *);\n } *pre_expr;\n@@ -242,7 +242,7 @@ typedef struct pre_expr_d : typed_noop_remove <pre_expr_d>\n /* Compare E1 and E1 for equality.  */\n \n inline int\n-pre_expr_d::equal (const value_type *e1, const compare_type *e2)\n+pre_expr_d::equal (const pre_expr_d *e1, const pre_expr_d *e2)\n {\n   if (e1->kind != e2->kind)\n     return false;\n@@ -267,7 +267,7 @@ pre_expr_d::equal (const value_type *e1, const compare_type *e2)\n /* Hash E.  */\n \n inline hashval_t\n-pre_expr_d::hash (const value_type *e)\n+pre_expr_d::hash (const pre_expr_d *e)\n {\n   switch (e->kind)\n     {\n@@ -547,10 +547,10 @@ typedef struct expr_pred_trans_d : typed_free_remove<expr_pred_trans_d>\n   hashval_t hashcode;\n \n   /* hash_table support.  */\n-  typedef expr_pred_trans_d value_type;\n-  typedef expr_pred_trans_d compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline int equal (const value_type *, const compare_type *);\n+  typedef expr_pred_trans_d *value_type;\n+  typedef expr_pred_trans_d *compare_type;\n+  static inline hashval_t hash (const expr_pred_trans_d *);\n+  static inline int equal (const expr_pred_trans_d *, const expr_pred_trans_d *);\n } *expr_pred_trans_t;\n typedef const struct expr_pred_trans_d *const_expr_pred_trans_t;\n \n@@ -561,8 +561,8 @@ expr_pred_trans_d::hash (const expr_pred_trans_d *e)\n }\n \n inline int\n-expr_pred_trans_d::equal (const value_type *ve1,\n-\t\t\t  const compare_type *ve2)\n+expr_pred_trans_d::equal (const expr_pred_trans_d *ve1,\n+\t\t\t  const expr_pred_trans_d *ve2)\n {\n   basic_block b1 = ve1->pred;\n   basic_block b2 = ve2->pred;"}, {"sha": "ae9d6318fb0e7ad6e2bb8206fdbf6d811f5f8199", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -1061,7 +1061,6 @@ struct oecount_hasher\n {\n   typedef int value_type;\n   typedef int compare_type;\n-  typedef int store_values_directly;\n   static inline hashval_t hash (const value_type &);\n   static inline bool equal (const value_type &, const compare_type &);\n   static bool is_deleted (int &v) { return v == 1; }"}, {"sha": "c6a16bc87902dc705fbf23150408850ae0e91a2a", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -148,16 +148,16 @@ along with GCC; see the file COPYING3.  If not see\n \n struct vn_nary_op_hasher : typed_noop_remove <vn_nary_op_s>\n {\n-  typedef vn_nary_op_s value_type;\n-  typedef vn_nary_op_s compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef vn_nary_op_s *value_type;\n+  typedef vn_nary_op_s *compare_type;\n+  static inline hashval_t hash (const vn_nary_op_s *);\n+  static inline bool equal (const vn_nary_op_s *, const vn_nary_op_s *);\n };\n \n /* Return the computed hashcode for nary operation P1.  */\n \n inline hashval_t\n-vn_nary_op_hasher::hash (const value_type *vno1)\n+vn_nary_op_hasher::hash (const vn_nary_op_s *vno1)\n {\n   return vno1->hashcode;\n }\n@@ -166,7 +166,7 @@ vn_nary_op_hasher::hash (const value_type *vno1)\n    equivalent.  */\n \n inline bool\n-vn_nary_op_hasher::equal (const value_type *vno1, const compare_type *vno2)\n+vn_nary_op_hasher::equal (const vn_nary_op_s *vno1, const vn_nary_op_s *vno2)\n {\n   return vn_nary_op_eq (vno1, vno2);\n }\n@@ -182,33 +182,33 @@ vn_phi_eq (const_vn_phi_t const vp1, const_vn_phi_t const vp2);\n \n struct vn_phi_hasher\n { \n-  typedef vn_phi_s value_type;\n-  typedef vn_phi_s compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n-  static inline void remove (value_type *);\n+  typedef vn_phi_s *value_type;\n+  typedef vn_phi_s *compare_type;\n+  static inline hashval_t hash (const vn_phi_s *);\n+  static inline bool equal (const vn_phi_s *, const vn_phi_s *);\n+  static inline void remove (vn_phi_s *);\n };\n \n /* Return the computed hashcode for phi operation P1.  */\n \n inline hashval_t\n-vn_phi_hasher::hash (const value_type *vp1)\n+vn_phi_hasher::hash (const vn_phi_s *vp1)\n {\n   return vp1->hashcode;\n }\n \n /* Compare two phi entries for equality, ignoring VN_TOP arguments.  */\n \n inline bool\n-vn_phi_hasher::equal (const value_type *vp1, const compare_type *vp2)\n+vn_phi_hasher::equal (const vn_phi_s *vp1, const vn_phi_s *vp2)\n {\n   return vn_phi_eq (vp1, vp2);\n }\n \n /* Free a phi operation structure VP.  */\n \n inline void\n-vn_phi_hasher::remove (value_type *phi)\n+vn_phi_hasher::remove (vn_phi_s *phi)\n {\n   phi->phiargs.release ();\n }\n@@ -250,29 +250,29 @@ free_reference (vn_reference_s *vr)\n \n struct vn_reference_hasher\n {\n-  typedef vn_reference_s value_type;\n-  typedef vn_reference_s compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n-  static inline void remove (value_type *);\n+  typedef vn_reference_s *value_type;\n+  typedef vn_reference_s *compare_type;\n+  static inline hashval_t hash (const vn_reference_s *);\n+  static inline bool equal (const vn_reference_s *, const vn_reference_s *);\n+  static inline void remove (vn_reference_s *);\n };\n \n /* Return the hashcode for a given reference operation P1.  */\n \n inline hashval_t\n-vn_reference_hasher::hash (const value_type *vr1)\n+vn_reference_hasher::hash (const vn_reference_s *vr1)\n {\n   return vr1->hashcode;\n }\n \n inline bool\n-vn_reference_hasher::equal (const value_type *v, const compare_type *c)\n+vn_reference_hasher::equal (const vn_reference_s *v, const vn_reference_s *c)\n {\n   return vn_reference_eq (v, c);\n }\n \n inline void\n-vn_reference_hasher::remove (value_type *v)\n+vn_reference_hasher::remove (vn_reference_s *v)\n {\n   free_reference (v);\n }\n@@ -298,24 +298,24 @@ typedef struct vn_tables_s\n \n struct vn_constant_hasher : typed_free_remove <vn_constant_s>\n { \n-  typedef vn_constant_s value_type;\n-  typedef vn_constant_s compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef vn_constant_s *value_type;\n+  typedef vn_constant_s *compare_type;\n+  static inline hashval_t hash (const vn_constant_s *);\n+  static inline bool equal (const vn_constant_s *, const vn_constant_s *);\n };\n \n /* Hash table hash function for vn_constant_t.  */\n \n inline hashval_t\n-vn_constant_hasher::hash (const value_type *vc1)\n+vn_constant_hasher::hash (const vn_constant_s *vc1)\n {\n   return vc1->hashcode;\n }\n \n /* Hash table equality function for vn_constant_t.  */\n \n inline bool\n-vn_constant_hasher::equal (const value_type *vc1, const compare_type *vc2)\n+vn_constant_hasher::equal (const vn_constant_s *vc1, const vn_constant_s *vc2)\n {\n   if (vc1->hashcode != vc2->hashcode)\n     return false;"}, {"sha": "d6a9f678259d569ef1d0780795dbb3181f29a2aa", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -1940,24 +1940,26 @@ typedef const struct equiv_class_label *const_equiv_class_label_t;\n \n struct equiv_class_hasher : typed_free_remove <equiv_class_label>\n {\n-  typedef equiv_class_label value_type;\n-  typedef equiv_class_label compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef equiv_class_label *value_type;\n+  typedef equiv_class_label *compare_type;\n+  static inline hashval_t hash (const equiv_class_label *);\n+  static inline bool equal (const equiv_class_label *,\n+\t\t\t    const equiv_class_label *);\n };\n \n /* Hash function for a equiv_class_label_t */\n \n inline hashval_t\n-equiv_class_hasher::hash (const value_type *ecl)\n+equiv_class_hasher::hash (const equiv_class_label *ecl)\n {\n   return ecl->hashcode;\n }\n \n /* Equality function for two equiv_class_label_t's.  */\n \n inline bool\n-equiv_class_hasher::equal (const value_type *eql1, const compare_type *eql2)\n+equiv_class_hasher::equal (const equiv_class_label *eql1,\n+\t\t\t   const equiv_class_label *eql2)\n {\n   return (eql1->hashcode == eql2->hashcode\n \t  && bitmap_equal_p (eql1->labels, eql2->labels));\n@@ -5963,24 +5965,26 @@ typedef const struct shared_bitmap_info *const_shared_bitmap_info_t;\n \n struct shared_bitmap_hasher : typed_free_remove <shared_bitmap_info>\n {\n-  typedef shared_bitmap_info value_type;\n-  typedef shared_bitmap_info compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef shared_bitmap_info *value_type;\n+  typedef shared_bitmap_info *compare_type;\n+  static inline hashval_t hash (const shared_bitmap_info *);\n+  static inline bool equal (const shared_bitmap_info *,\n+\t\t\t    const shared_bitmap_info *);\n };\n \n /* Hash function for a shared_bitmap_info_t */\n \n inline hashval_t\n-shared_bitmap_hasher::hash (const value_type *bi)\n+shared_bitmap_hasher::hash (const shared_bitmap_info *bi)\n {\n   return bi->hashcode;\n }\n \n /* Equality function for two shared_bitmap_info_t's. */\n \n inline bool\n-shared_bitmap_hasher::equal (const value_type *sbi1, const compare_type *sbi2)\n+shared_bitmap_hasher::equal (const shared_bitmap_info *sbi1,\n+\t\t\t     const shared_bitmap_info *sbi2)\n {\n   return bitmap_equal_p (sbi1->pt_vars, sbi2->pt_vars);\n }"}, {"sha": "4afe94e509dfd6c93e9d039856677e794464d5ce", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -260,19 +260,19 @@ struct same_succ_def\n   hashval_t hashval;\n \n   /* hash_table support.  */\n-  typedef same_succ_def value_type;\n-  typedef same_succ_def compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static int equal (const value_type *, const compare_type *);\n-  static void remove (value_type *);\n+  typedef same_succ_def *value_type;\n+  typedef same_succ_def *compare_type;\n+  static inline hashval_t hash (const same_succ_def *);\n+  static int equal (const same_succ_def *, const same_succ_def *);\n+  static void remove (same_succ_def *);\n };\n typedef struct same_succ_def *same_succ;\n typedef const struct same_succ_def *const_same_succ;\n \n /* hash routine for hash_table support, returns hashval of E.  */\n \n inline hashval_t\n-same_succ_def::hash (const value_type *e)\n+same_succ_def::hash (const same_succ_def *e)\n {\n   return e->hashval;\n }\n@@ -568,7 +568,7 @@ inverse_flags (const_same_succ e1, const_same_succ e2)\n /* Compares SAME_SUCCs E1 and E2.  */\n \n int\n-same_succ_def::equal (const value_type *e1, const compare_type *e2)\n+same_succ_def::equal (const same_succ_def *e1, const same_succ_def *e2)\n {\n   unsigned int i, first1, first2;\n   gimple_stmt_iterator gsi1, gsi2;"}, {"sha": "709b16e06ff30ea64949a1f27b401f6b23eccddd", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -160,10 +160,10 @@ struct redirection_data : typed_free_remove<redirection_data>\n   struct el *incoming_edges;\n \n   /* hash_table support.  */\n-  typedef redirection_data value_type;\n-  typedef redirection_data compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline int equal (const value_type *, const compare_type *);\n+  typedef redirection_data *value_type;\n+  typedef redirection_data *compare_type;\n+  static inline hashval_t hash (const redirection_data *);\n+  static inline int equal (const redirection_data *, const redirection_data *);\n };\n \n /* Dump a jump threading path, including annotations about each\n@@ -209,7 +209,7 @@ dump_jump_thread_path (FILE *dump_file, vec<jump_thread_edge *> path,\n    path.  So hash on the block index of the final edge in the path.  */\n \n inline hashval_t\n-redirection_data::hash (const value_type *p)\n+redirection_data::hash (const redirection_data *p)\n {\n   vec<jump_thread_edge *> *path = p->path;\n   return path->last ()->e->dest->index;\n@@ -218,7 +218,7 @@ redirection_data::hash (const value_type *p)\n /* Given two hash table entries, return true if they have the same\n    jump threading path.  */\n inline int\n-redirection_data::equal (const value_type *p1, const compare_type *p2)\n+redirection_data::equal (const redirection_data *p1, const redirection_data *p2)\n {\n   vec<jump_thread_edge *> *path1 = p1->path;\n   vec<jump_thread_edge *> *path2 = p2->path;"}, {"sha": "313e936b423e1cafd153f3e20caae22c6d686ed6", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -118,20 +118,20 @@ struct simduid_to_vf : typed_free_remove<simduid_to_vf>\n   int vf;\n \n   /* hash_table support.  */\n-  typedef simduid_to_vf value_type;\n-  typedef simduid_to_vf compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline int equal (const value_type *, const compare_type *);\n+  typedef simduid_to_vf *value_type;\n+  typedef simduid_to_vf *compare_type;\n+  static inline hashval_t hash (const simduid_to_vf *);\n+  static inline int equal (const simduid_to_vf *, const simduid_to_vf *);\n };\n \n inline hashval_t\n-simduid_to_vf::hash (const value_type *p)\n+simduid_to_vf::hash (const simduid_to_vf *p)\n {\n   return p->simduid;\n }\n \n inline int\n-simduid_to_vf::equal (const value_type *p1, const value_type *p2)\n+simduid_to_vf::equal (const simduid_to_vf *p1, const simduid_to_vf *p2)\n {\n   return p1->simduid == p2->simduid;\n }\n@@ -154,20 +154,22 @@ struct simd_array_to_simduid : typed_free_remove<simd_array_to_simduid>\n   unsigned int simduid;\n \n   /* hash_table support.  */\n-  typedef simd_array_to_simduid value_type;\n-  typedef simd_array_to_simduid compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline int equal (const value_type *, const compare_type *);\n+  typedef simd_array_to_simduid *value_type;\n+  typedef simd_array_to_simduid *compare_type;\n+  static inline hashval_t hash (const simd_array_to_simduid *);\n+  static inline int equal (const simd_array_to_simduid *,\n+\t\t\t   const simd_array_to_simduid *);\n };\n \n inline hashval_t\n-simd_array_to_simduid::hash (const value_type *p)\n+simd_array_to_simduid::hash (const simd_array_to_simduid *p)\n {\n   return DECL_UID (p->decl);\n }\n \n inline int\n-simd_array_to_simduid::equal (const value_type *p1, const value_type *p2)\n+simd_array_to_simduid::equal (const simd_array_to_simduid *p1,\n+\t\t\t      const simd_array_to_simduid *p2)\n {\n   return p1->decl == p2->decl;\n }"}, {"sha": "f22d6cff5cb81548bfc5a24878830d1107d0cbd8", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -220,20 +220,20 @@ typedef struct _vect_peel_extended_info\n \n struct peel_info_hasher : typed_free_remove <_vect_peel_info>\n {\n-  typedef _vect_peel_info value_type;\n-  typedef _vect_peel_info compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef _vect_peel_info *value_type;\n+  typedef _vect_peel_info *compare_type;\n+  static inline hashval_t hash (const _vect_peel_info *);\n+  static inline bool equal (const _vect_peel_info *, const _vect_peel_info *);\n };\n \n inline hashval_t\n-peel_info_hasher::hash (const value_type *peel_info)\n+peel_info_hasher::hash (const _vect_peel_info *peel_info)\n {\n   return (hashval_t) peel_info->npeel;\n }\n \n inline bool\n-peel_info_hasher::equal (const value_type *a, const compare_type *b)\n+peel_info_hasher::equal (const _vect_peel_info *a, const _vect_peel_info *b)\n {\n   return (a->npeel == b->npeel);\n }"}, {"sha": "b7b53f351c2a122c9a8f5ac61b95f2b350820a22", "filename": "gcc/valtrack.h", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fvaltrack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fvaltrack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvaltrack.h?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -45,33 +45,35 @@ struct dead_debug_global_entry\n struct dead_debug_hash_descr\n {\n   /* The hash table contains pointers to entries of this type.  */\n-  typedef struct dead_debug_global_entry value_type;\n-  typedef struct dead_debug_global_entry compare_type;\n+  typedef struct dead_debug_global_entry *value_type;\n+  typedef struct dead_debug_global_entry *compare_type;\n   /* Hash on the pseudo number.  */\n-  static inline hashval_t hash (const value_type *my);\n+  static inline hashval_t hash (const dead_debug_global_entry *my);\n   /* Entries are identical if they refer to the same pseudo.  */\n-  static inline bool equal (const value_type *my, const compare_type *other);\n+  static inline bool equal (const dead_debug_global_entry *my,\n+\t\t\t    const dead_debug_global_entry *other);\n   /* Release entries when they're removed.  */\n-  static inline void remove (value_type *p);\n+  static inline void remove (dead_debug_global_entry *p);\n };\n \n /* Hash on the pseudo number.  */\n inline hashval_t\n-dead_debug_hash_descr::hash (const value_type *my)\n+dead_debug_hash_descr::hash (const dead_debug_global_entry *my)\n {\n   return REGNO (my->reg);\n }\n \n /* Entries are identical if they refer to the same pseudo.  */\n inline bool\n-dead_debug_hash_descr::equal (const value_type *my, const compare_type *other)\n+dead_debug_hash_descr::equal (const dead_debug_global_entry *my,\n+\t\t\t      const dead_debug_global_entry *other)\n {\n   return my->reg == other->reg;\n }\n \n /* Release entries when they're removed.  */\n inline void\n-dead_debug_hash_descr::remove (value_type *p)\n+dead_debug_hash_descr::remove (dead_debug_global_entry *p)\n {\n   XDELETE (p);\n }"}, {"sha": "685fcc38c58da490e841c8133d735a3d44cc3be5", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -494,26 +494,26 @@ static void variable_htab_free (void *);\n \n struct variable_hasher\n {\n-  typedef variable_def value_type;\n-  typedef void compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n-  static inline void remove (value_type *);\n+  typedef variable_def *value_type;\n+  typedef void *compare_type;\n+  static inline hashval_t hash (const variable_def *);\n+  static inline bool equal (const variable_def *, const void *);\n+  static inline void remove (variable_def *);\n };\n \n /* The hash function for variable_htab, computes the hash value\n    from the declaration of variable X.  */\n \n inline hashval_t\n-variable_hasher::hash (const value_type *v)\n+variable_hasher::hash (const variable_def *v)\n {\n   return dv_htab_hash (v->dv);\n }\n \n /* Compare the declaration of variable X with declaration Y.  */\n \n inline bool\n-variable_hasher::equal (const value_type *v, const compare_type *y)\n+variable_hasher::equal (const variable_def *v, const void *y)\n {\n   decl_or_value dv = CONST_CAST2 (decl_or_value, const void *, y);\n \n@@ -523,7 +523,7 @@ variable_hasher::equal (const value_type *v, const compare_type *y)\n /* Free the element of VARIABLE_HTAB (its type is struct variable_def).  */\n \n inline void\n-variable_hasher::remove (value_type *var)\n+variable_hasher::remove (variable_def *var)\n {\n   variable_htab_free (var);\n }"}, {"sha": "8ced83518d9ae7f183cc2ce28f31291f74ad651b", "filename": "gcc/vtable-verify.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fvtable-verify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fvtable-verify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvtable-verify.c?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -268,14 +268,15 @@ vtbl_map_node_registration_insert (struct vtbl_map_node *node,\n /* Hashtable functions for vtable_registration hashtables.  */\n \n inline hashval_t\n-registration_hasher::hash (const value_type *p)\n+registration_hasher::hash (const vtable_registration *p)\n {\n   const struct vtable_registration *n = (const struct vtable_registration *) p;\n   return (hashval_t) (DECL_UID (n->vtable_decl));\n }\n \n inline bool\n-registration_hasher::equal (const value_type *p1, const compare_type *p2)\n+registration_hasher::equal (const vtable_registration *p1,\n+\t\t\t    const vtable_registration *p2)\n {\n   const struct vtable_registration *n1 =\n                                     (const struct vtable_registration *) p1;\n@@ -292,16 +293,16 @@ registration_hasher::equal (const value_type *p1, const compare_type *p2)\n \n struct vtbl_map_hasher : typed_noop_remove <struct vtbl_map_node>\n {\n-  typedef struct vtbl_map_node value_type;\n-  typedef struct vtbl_map_node compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef struct vtbl_map_node *value_type;\n+  typedef struct vtbl_map_node *compare_type;\n+  static inline hashval_t hash (const vtbl_map_node *);\n+  static inline bool equal (const vtbl_map_node *, const vtbl_map_node *);\n };\n \n /* Returns a hash code for P.  */\n \n inline hashval_t\n-vtbl_map_hasher::hash (const value_type *p)\n+vtbl_map_hasher::hash (const vtbl_map_node *p)\n {\n   const struct vtbl_map_node n = *((const struct vtbl_map_node *) p);\n   return (hashval_t) IDENTIFIER_HASH_VALUE (n.class_name);\n@@ -310,7 +311,7 @@ vtbl_map_hasher::hash (const value_type *p)\n /* Returns nonzero if P1 and P2 are equal.  */\n \n inline bool\n-vtbl_map_hasher::equal (const value_type *p1, const compare_type *p2)\n+vtbl_map_hasher::equal (const vtbl_map_node *p1, const vtbl_map_node *p2)\n {\n   const struct vtbl_map_node n1 = *((const struct vtbl_map_node *) p1);\n   const struct vtbl_map_node n2 = *((const struct vtbl_map_node *) p2);"}, {"sha": "6fb2b6049a512170cbfa589dd8c3290db1c4b9a3", "filename": "gcc/vtable-verify.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fvtable-verify.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/gcc%2Fvtable-verify.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvtable-verify.h?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -58,10 +58,11 @@ struct vtable_registration\n \n struct registration_hasher : typed_noop_remove <struct vtable_registration>\n {\n-  typedef struct vtable_registration value_type;\n-  typedef struct vtable_registration compare_type;\n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  typedef struct vtable_registration *value_type;\n+  typedef struct vtable_registration *compare_type;\n+  static inline hashval_t hash (const vtable_registration *);\n+  static inline bool equal (const vtable_registration *,\n+\t\t\t    const vtable_registration *);\n };\n \n typedef hash_table<registration_hasher> register_table_type;"}, {"sha": "ed43b6396c792a826b79e5f3a3c1de32c034521f", "filename": "libcc1/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/libcc1%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/libcc1%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2FChangeLog?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -1,3 +1,7 @@\n+2015-04-18  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* plugin.cc: Adjust for hash_table changes.\n+\n 2015-04-15  Andreas Schwab  <schwab@suse.de>\n \n \tPR bootstrap/65763"}, {"sha": "74a7ec3782ce3205ebc6569e5389dcddf13191dc", "filename": "libcc1/plugin.cc", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/libcc1%2Fplugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f58944a75eaf9c193dc704f8128bfaaf6c3c3a/libcc1%2Fplugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Fplugin.cc?ref=67f58944a75eaf9c193dc704f8128bfaaf6c3c3a", "patch": "@@ -113,38 +113,38 @@ struct decl_addr_value\n \n struct decl_addr_hasher : typed_free_remove<decl_addr_value>\n {\n-  typedef decl_addr_value value_type;\n-  typedef decl_addr_value compare_type;\n+  typedef decl_addr_value *value_type;\n+  typedef decl_addr_value *compare_type;\n \n-  static inline hashval_t hash (const value_type *);\n-  static inline bool equal (const value_type *, const compare_type *);\n+  static inline hashval_t hash (const decl_addr_value *);\n+  static inline bool equal (const decl_addr_value *, const decl_addr_value *);\n };\n \n inline hashval_t\n-decl_addr_hasher::hash (const value_type *e)\n+decl_addr_hasher::hash (const decl_addr_value *e)\n {\n   return IDENTIFIER_HASH_VALUE (DECL_NAME (e->decl));\n }\n \n inline bool\n-decl_addr_hasher::equal (const value_type *p1, const compare_type *p2)\n+decl_addr_hasher::equal (const decl_addr_value *p1, const decl_addr_value *p2)\n {\n   return p1->decl == p2->decl;\n }\n \n \f\n \n-struct string_hasher : typed_noop_remove<char>\n+struct string_hasher : typed_noop_remove<const char>\n {\n-  typedef char value_type;\n-  typedef char compare_type;\n+  typedef const char *value_type;\n+  typedef const char *compare_type;\n \n-  static inline hashval_t hash (const value_type *s)\n+  static inline hashval_t hash (const char *s)\n   {\n     return htab_hash_string (s);\n   }\n \n-  static inline bool equal (const value_type *p1, const value_type *p2)\n+  static inline bool equal (const char *p1, const char *p2)\n   {\n     return strcmp (p1, p2) == 0;\n   }\n@@ -210,7 +210,7 @@ struct plugin_context : public cc1_plugin::connection\n   // Add a file name to FILE_NAMES and return the canonical copy.\n   const char *intern_filename (const char *filename)\n   {\n-    char **slot = file_names.find_slot (filename, INSERT);\n+    const char **slot = file_names.find_slot (filename, INSERT);\n     if (*slot == NULL)\n       {\n \t/* The file name must live as long as the line map, which"}]}