{"sha": "68b48f3f4c49132cc6bfb16e65f8b6fd939689c7", "node_id": "C_kwDOANBUbNoAKDY4YjQ4ZjNmNGM0OTEzMmNjNmJmYjE2ZTY1ZjhiNmZkOTM5Njg5Yzc", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-11-01T13:48:58Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2021-11-01T13:48:58Z"}, "message": "middle-end: Teach CSE to be able to do vector extracts.\n\nThis patch gets CSE to re-use constants already inside a vector rather than\nre-materializing the constant again.\n\nBasically consider the following case:\n\n#include <stdint.h>\n#include <arm_neon.h>\n\nuint64_t\ntest (uint64_t a, uint64x2_t b, uint64x2_t* rt)\n{\n  uint64_t arr[2] = { 0x0942430810234076UL, 0x0942430810234076UL};\n  uint64_t res = a | arr[0];\n  uint64x2_t val = vld1q_u64 (arr);\n  *rt = vaddq_u64 (val, b);\n  return res;\n}\n\nThe actual behavior is inconsequential however notice that the same constants\nare used in the vector (arr and later val) and in the calculation of res.\n\nThe code we generate for this however is quite sub-optimal:\n\ntest:\n        adrp    x2, .LC0\n        sub     sp, sp, #16\n        ldr     q1, [x2, #:lo12:.LC0]\n        mov     x2, 16502\n        movk    x2, 0x1023, lsl 16\n        movk    x2, 0x4308, lsl 32\n        add     v1.2d, v1.2d, v0.2d\n        movk    x2, 0x942, lsl 48\n        orr     x0, x0, x2\n        str     q1, [x1]\n        add     sp, sp, 16\n        ret\n.LC0:\n        .xword  667169396713799798\n        .xword  667169396713799798\n\nEssentially we materialize the same constant twice.  The reason for this is\nbecause the front-end lowers the constant extracted from arr[0] quite early on.\nIf you look into the result of fre you'll find\n\n  <bb 2> :\n  arr[0] = 667169396713799798;\n  arr[1] = 667169396713799798;\n  res_7 = a_6(D) | 667169396713799798;\n  _16 = __builtin_aarch64_ld1v2di (&arr);\n  _17 = VIEW_CONVERT_EXPR<uint64x2_t>(_16);\n  _11 = b_10(D) + _17;\n  *rt_12(D) = _11;\n  arr ={v} {CLOBBER};\n  return res_7;\n\nWhich makes sense for further optimization.  However come expand time if the\nconstant isn't representable in the target arch it will be assigned to a\nregister again.\n\n(insn 8 5 9 2 (set (reg:V2DI 99)\n        (const_vector:V2DI [\n                (const_int 667169396713799798 [0x942430810234076]) repeated x2\n            ])) \"cse.c\":7:12 -1\n     (nil))\n...\n(insn 14 13 15 2 (set (reg:DI 103)\n        (const_int 667169396713799798 [0x942430810234076])) \"cse.c\":8:12 -1\n     (nil))\n(insn 15 14 16 2 (set (reg:DI 102 [ res ])\n        (ior:DI (reg/v:DI 96 [ a ])\n            (reg:DI 103))) \"cse.c\":8:12 -1\n     (nil))\n\nAnd since it's out of the immediate range of the scalar instruction used\ncombine won't be able to do anything here.\n\nThis will then trigger the re-materialization of the constant twice.\n\nTo fix this this patch extends CSE to be able to generate an extract for a\nconstant from another vector, or to make a vector for a constant by duplicating\nanother constant.\n\nWhether this transformation is done or not depends entirely on the costing for\nthe target for the different constants and operations.\n\nI Initially also investigated doing this in PRE, but PRE requires at least 2 BB\nto work and does not currently have any way to remove redundancies within a\nsingle BB and it did not look easy to support.\n\ngcc/ChangeLog:\n\n\t* cse.c (add_to_set): New.\n\t(find_sets_in_insn): Register constants in sets.\n\t(canonicalize_insn): Use auto_vec instead.\n\t(cse_insn): Try materializing using vec_dup.\n\t* rtl.h (simplify_context::simplify_gen_vec_select,\n\tsimplify_gen_vec_select): New.\n\t* simplify-rtx.c (simplify_context::simplify_gen_vec_select): New.", "tree": {"sha": "2aa3d70a8e03bc4ab5dc8082306b6d6e3572869d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2aa3d70a8e03bc4ab5dc8082306b6d6e3572869d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68b48f3f4c49132cc6bfb16e65f8b6fd939689c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68b48f3f4c49132cc6bfb16e65f8b6fd939689c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68b48f3f4c49132cc6bfb16e65f8b6fd939689c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68b48f3f4c49132cc6bfb16e65f8b6fd939689c7/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a260d652c421e212818efc3c0f487cf9cdbcc2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a260d652c421e212818efc3c0f487cf9cdbcc2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a260d652c421e212818efc3c0f487cf9cdbcc2c"}], "stats": {"total": 109, "additions": 91, "deletions": 18}, "files": [{"sha": "c1c7d0ca27b73c4b944b4719f95fece74e0358d5", "filename": "gcc/cse.c", "status": "modified", "additions": 62, "deletions": 18, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68b48f3f4c49132cc6bfb16e65f8b6fd939689c7/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68b48f3f4c49132cc6bfb16e65f8b6fd939689c7/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=68b48f3f4c49132cc6bfb16e65f8b6fd939689c7", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"regs.h\"\n #include \"function-abi.h\"\n #include \"rtlanal.h\"\n+#include \"expr.h\"\n \n /* The basic idea of common subexpression elimination is to go\n    through the code, keeping a record of expressions that would\n@@ -4239,14 +4240,21 @@ try_back_substitute_reg (rtx set, rtx_insn *insn)\n \t}\n     }\n }\n-\f\n+\n+/* Add an entry containing RTL X into SETS.  */\n+static inline void\n+add_to_set (vec<struct set> *sets, rtx x)\n+{\n+  struct set entry = {};\n+  entry.rtl = x;\n+  sets->safe_push (entry);\n+}\n+\n /* Record all the SETs in this instruction into SETS_PTR,\n    and return the number of recorded sets.  */\n static int\n-find_sets_in_insn (rtx_insn *insn, struct set **psets)\n+find_sets_in_insn (rtx_insn *insn, vec<struct set> *psets)\n {\n-  struct set *sets = *psets;\n-  int n_sets = 0;\n   rtx x = PATTERN (insn);\n \n   if (GET_CODE (x) == SET)\n@@ -4266,8 +4274,25 @@ find_sets_in_insn (rtx_insn *insn, struct set **psets)\n \t someplace else, so it isn't worth cse'ing.  */\n       else if (GET_CODE (SET_SRC (x)) == CALL)\n \t;\n+      else if (GET_CODE (SET_SRC (x)) == CONST_VECTOR\n+\t       && GET_MODE_CLASS (GET_MODE (SET_SRC (x))) != MODE_VECTOR_BOOL)\n+\t{\n+\t  /* First register the vector itself.  */\n+\t  add_to_set (psets, x);\n+\t  rtx src = SET_SRC (x);\n+\t  /* Go over the constants of the CONST_VECTOR in forward order, to\n+\t     put them in the same order in the SETS array.  */\n+\t  for (unsigned i = 0; i < const_vector_encoded_nelts (src) ; i++)\n+\t    {\n+\t      /* These are templates and don't actually get emitted but are\n+\t\t used to tell CSE how to get to a particular constant.  */\n+\t      rtx y = simplify_gen_vec_select (SET_DEST (x), i);\n+\t      gcc_assert (y);\n+\t      add_to_set (psets, gen_rtx_SET (y, CONST_VECTOR_ELT (src, i)));\n+\t    }\n+\t}\n       else\n-\tsets[n_sets++].rtl = x;\n+\tadd_to_set (psets, x);\n     }\n   else if (GET_CODE (x) == PARALLEL)\n     {\n@@ -4288,12 +4313,12 @@ find_sets_in_insn (rtx_insn *insn, struct set **psets)\n \t      else if (GET_CODE (SET_SRC (y)) == CALL)\n \t\t;\n \t      else\n-\t\tsets[n_sets++].rtl = y;\n+\t\tadd_to_set (psets, y);\n \t    }\n \t}\n     }\n \n-  return n_sets;\n+  return psets->length ();\n }\n \f\n /* Subroutine of canonicalize_insn.  X is an ASM_OPERANDS in INSN.  */\n@@ -4341,9 +4366,10 @@ canon_asm_operands (rtx x, rtx_insn *insn)\n    see canon_reg.  */\n \n static void\n-canonicalize_insn (rtx_insn *insn, struct set **psets, int n_sets)\n+canonicalize_insn (rtx_insn *insn, vec<struct set> *psets)\n {\n-  struct set *sets = *psets;\n+  vec<struct set> sets = *psets;\n+  int n_sets = sets.length ();\n   rtx tem;\n   rtx x = PATTERN (insn);\n   int i;\n@@ -4502,13 +4528,6 @@ cse_insn (rtx_insn *insn)\n   int src_eqv_in_memory = 0;\n   unsigned src_eqv_hash = 0;\n \n-  struct set *sets = (struct set *) 0;\n-\n-  if (GET_CODE (x) == SET)\n-    sets = XALLOCA (struct set);\n-  else if (GET_CODE (x) == PARALLEL)\n-    sets = XALLOCAVEC (struct set, XVECLEN (x, 0));\n-\n   this_insn = insn;\n \n   /* Find all regs explicitly clobbered in this insn,\n@@ -4517,10 +4536,11 @@ cse_insn (rtx_insn *insn)\n   invalidate_from_sets_and_clobbers (insn);\n \n   /* Record all the SETs in this instruction.  */\n-  n_sets = find_sets_in_insn (insn, &sets);\n+  auto_vec<struct set, 8> sets;\n+  n_sets = find_sets_in_insn (insn, (vec<struct set>*)&sets);\n \n   /* Substitute the canonical register where possible.  */\n-  canonicalize_insn (insn, &sets, n_sets);\n+  canonicalize_insn (insn, (vec<struct set>*)&sets);\n \n   /* If this insn has a REG_EQUAL note, store the equivalent value in SRC_EQV,\n      if different, or if the DEST is a STRICT_LOW_PART/ZERO_EXTRACT.  The\n@@ -4986,6 +5006,30 @@ cse_insn (rtx_insn *insn)\n \t  src_related_is_const_anchor = src_related != NULL_RTX;\n \t}\n \n+      /* Try to re-materialize a vec_dup with an existing constant.   */\n+      rtx src_elt;\n+      if ((!src_eqv_here || CONSTANT_P (src_eqv_here))\n+\t  && const_vec_duplicate_p (src, &src_elt))\n+\t{\n+\t   machine_mode const_mode = GET_MODE_INNER (GET_MODE (src));\n+\t   struct table_elt *related_elt\n+\t\t= lookup (src_elt, HASH (src_elt, const_mode), const_mode);\n+\t   if (related_elt)\n+\t    {\n+\t      for (related_elt = related_elt->first_same_value;\n+\t\t   related_elt; related_elt = related_elt->next_same_value)\n+\t\tif (REG_P (related_elt->exp))\n+\t\t  {\n+\t\t   /* We don't need to compare costs with an existing (constant)\n+\t\t      src_eqv_here, since any such src_eqv_here should already be\n+\t\t      available in src_const.  */\n+\t\t    src_eqv_here\n+\t\t\t= gen_rtx_VEC_DUPLICATE (GET_MODE (src),\n+\t\t\t\t\t\t related_elt->exp);\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\t}\n \n       if (src == src_folded)\n \tsrc_folded = 0;"}, {"sha": "6a6de1cf11d0bf5dd38f5ee37901310d653ce722", "filename": "gcc/rtl.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68b48f3f4c49132cc6bfb16e65f8b6fd939689c7/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68b48f3f4c49132cc6bfb16e65f8b6fd939689c7/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=68b48f3f4c49132cc6bfb16e65f8b6fd939689c7", "patch": "@@ -3425,6 +3425,7 @@ class simplify_context\n \t\t\t    rtx, rtx, rtx);\n   rtx simplify_gen_relational (rtx_code, machine_mode, machine_mode, rtx, rtx);\n   rtx simplify_gen_subreg (machine_mode, rtx, machine_mode, poly_uint64);\n+  rtx simplify_gen_vec_select (rtx, unsigned int);\n \n   /* Tracks the level of MEM nesting for the value being simplified:\n      0 means the value is not in a MEM, >0 means it is.  This is needed\n@@ -3526,6 +3527,12 @@ simplify_gen_subreg (machine_mode outermode, rtx op, machine_mode innermode,\n \t\t\t\t\t\t  innermode, byte);\n }\n \n+inline rtx\n+simplify_gen_vec_select (rtx op, unsigned int index)\n+{\n+  return simplify_context ().simplify_gen_vec_select (op, index);\n+}\n+\n inline rtx\n lowpart_subreg (machine_mode outermode, rtx op, machine_mode innermode)\n {"}, {"sha": "aac5693f54817107fe19e658076ae099e04ca281", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68b48f3f4c49132cc6bfb16e65f8b6fd939689c7/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68b48f3f4c49132cc6bfb16e65f8b6fd939689c7/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=68b48f3f4c49132cc6bfb16e65f8b6fd939689c7", "patch": "@@ -7620,6 +7620,28 @@ simplify_context::lowpart_subreg (machine_mode outer_mode, rtx expr,\n \t\t\t      subreg_lowpart_offset (outer_mode, inner_mode));\n }\n \n+/* Generate RTX to select element at INDEX out of vector OP.  */\n+\n+rtx simplify_context::simplify_gen_vec_select (rtx op, unsigned int index)\n+{\n+\n+  if (!VECTOR_MODE_P (GET_MODE (op)))\n+    return NULL_RTX;\n+\n+  machine_mode imode = GET_MODE_INNER (GET_MODE (op));\n+\n+  if (index == 0)\n+    {\n+      rtx res = lowpart_subreg (imode, op, GET_MODE (op));\n+      if (res)\n+\treturn res;\n+    }\n+\n+  rtx tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (1, GEN_INT (index)));\n+  return gen_rtx_VEC_SELECT (imode, op, tmp);\n+}\n+\n+\n /* Simplify X, an rtx expression.\n \n    Return the simplified expression or NULL if no simplifications"}]}