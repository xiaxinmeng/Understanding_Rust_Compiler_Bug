{"sha": "1b223a9f3489296c625bdb7cc764196d04fd9231", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWIyMjNhOWYzNDg5Mjk2YzYyNWJkYjdjYzc2NDE5NmQwNGZkOTIzMQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2015-11-03T03:57:07Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2015-11-03T03:57:07Z"}, "message": "defer mark_addressable calls during expand till the end of expand\n\nfor  gcc/ChangeLog\n\n\t* gimple-expr.c: Include hash-set.h and rtl.h.\n\t(mark_addressable_queue): New var.\n\t(mark_addressable): Factor actual marking into...\n\t(mark_addressable_1): ... this.  Queue it up during expand.\n\t(mark_addressable_2): New.\n\t(flush_mark_addressable_queue): New.\n\t* gimple-expr.h (flush_mark_addressable_queue): Declare.\n\t* cfgexpand.c: Include gimple-expr.h.\n\t(pass_expand::execute): Flush mark_addressable queue.\n\nFrom-SVN: r229696", "tree": {"sha": "1ca88d2602206178e1b174d26f9a22c25e3f13a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ca88d2602206178e1b174d26f9a22c25e3f13a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b223a9f3489296c625bdb7cc764196d04fd9231", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b223a9f3489296c625bdb7cc764196d04fd9231", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b223a9f3489296c625bdb7cc764196d04fd9231", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b223a9f3489296c625bdb7cc764196d04fd9231/comments", "author": null, "committer": null, "parents": [{"sha": "ec95cd47926915a7a50a5d94008b4fbfcd46eb46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec95cd47926915a7a50a5d94008b4fbfcd46eb46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec95cd47926915a7a50a5d94008b4fbfcd46eb46"}], "stats": {"total": 73, "additions": 71, "deletions": 2}, "files": [{"sha": "16712df8c8a470b8dcdf1cc3748187018340d30d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b223a9f3489296c625bdb7cc764196d04fd9231/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b223a9f3489296c625bdb7cc764196d04fd9231/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b223a9f3489296c625bdb7cc764196d04fd9231", "patch": "@@ -1,3 +1,15 @@\n+2015-11-03  Alexandre Oliva <aoliva@redhat.com>\n+\n+\t* gimple-expr.c: Include hash-set.h and rtl.h.\n+\t(mark_addressable_queue): New var.\n+\t(mark_addressable): Factor actual marking into...\n+\t(mark_addressable_1): ... this.  Queue it up during expand.\n+\t(mark_addressable_2): New.\n+\t(flush_mark_addressable_queue): New.\n+\t* gimple-expr.h (flush_mark_addressable_queue): Declare.\n+\t* cfgexpand.c: Include gimple-expr.h.\n+\t(pass_expand::execute): Flush mark_addressable queue.\n+\n 2015-11-02  Alexandre Oliva <aoliva@redhat.com>\n \n \t* tree-ssa-ifcombine.c (tree_ssa_ifcombine_bb_1): Factor out"}, {"sha": "bfbc958c020e54d15966d7796e38f83e2d81281b", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b223a9f3489296c625bdb7cc764196d04fd9231/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b223a9f3489296c625bdb7cc764196d04fd9231/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=1b223a9f3489296c625bdb7cc764196d04fd9231", "patch": "@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"internal-fn.h\"\n #include \"tree-eh.h\"\n #include \"gimple-iterator.h\"\n+#include \"gimple-expr.h\"\n #include \"gimple-walk.h\"\n #include \"tree-cfg.h\"\n #include \"tree-dfa.h\"\n@@ -6368,6 +6369,8 @@ pass_expand::execute (function *fun)\n   /* We're done expanding trees to RTL.  */\n   currently_expanding_to_rtl = 0;\n \n+  flush_mark_addressable_queue ();\n+\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (fun)->next_bb,\n \t\t  EXIT_BLOCK_PTR_FOR_FN (fun), next_bb)\n     {"}, {"sha": "f5f9e87d56f6b20f860d0e27443ee79553d92e6f", "filename": "gcc/gimple-expr.c", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b223a9f3489296c625bdb7cc764196d04fd9231/gcc%2Fgimple-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b223a9f3489296c625bdb7cc764196d04fd9231/gcc%2Fgimple-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.c?ref=1b223a9f3489296c625bdb7cc764196d04fd9231", "patch": "@@ -32,6 +32,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n #include \"stor-layout.h\"\n #include \"demangle.h\"\n+#include \"hash-set.h\"\n+#include \"rtl.h\"\n \n /* ----- Type related -----  */\n \n@@ -817,6 +819,57 @@ is_gimple_mem_ref_addr (tree t)\n \t\t  || decl_address_invariant_p (TREE_OPERAND (t, 0)))));\n }\n \n+/* Hold trees marked addressable during expand.  */\n+\n+static hash_set<tree> *mark_addressable_queue;\n+\n+/* Mark X as addressable or queue it up if called during expand.  We\n+   don't want to apply it immediately during expand because decls are\n+   made addressable at that point due to RTL-only concerns, such as\n+   uses of memcpy for block moves, and TREE_ADDRESSABLE changes\n+   is_gimple_reg, which might make it seem like a variable that used\n+   to be a gimple_reg shouldn't have been an SSA name.  So we queue up\n+   this flag setting and only apply it when we're done with GIMPLE and\n+   only RTL issues matter.  */\n+\n+static void\n+mark_addressable_1 (tree x)\n+{\n+  if (!currently_expanding_to_rtl)\n+    {\n+      TREE_ADDRESSABLE (x) = 1;\n+      return;\n+    }\n+\n+  if (!mark_addressable_queue)\n+    mark_addressable_queue = new hash_set<tree>();\n+  mark_addressable_queue->add (x);\n+}\n+\n+/* Adaptor for mark_addressable_1 for use in hash_set traversal.  */\n+\n+bool\n+mark_addressable_2 (tree const &x, void * ATTRIBUTE_UNUSED = NULL)\n+{\n+  mark_addressable_1 (x);\n+  return false;\n+}\n+\n+/* Mark all queued trees as addressable, and empty the queue.  To be\n+   called right after clearing CURRENTLY_EXPANDING_TO_RTL.  */\n+\n+void\n+flush_mark_addressable_queue ()\n+{\n+  gcc_assert (!currently_expanding_to_rtl);\n+  if (mark_addressable_queue)\n+    {\n+      mark_addressable_queue->traverse<void*, mark_addressable_2> (NULL);\n+      delete mark_addressable_queue;\n+      mark_addressable_queue = NULL;\n+    }\n+}\n+\n /* Mark X addressable.  Unlike the langhook we expect X to be in gimple\n    form and we don't do any syntax checking.  */\n \n@@ -832,7 +885,7 @@ mark_addressable (tree x)\n       && TREE_CODE (x) != PARM_DECL\n       && TREE_CODE (x) != RESULT_DECL)\n     return;\n-  TREE_ADDRESSABLE (x) = 1;\n+  mark_addressable_1 (x);\n \n   /* Also mark the artificial SSA_NAME that points to the partition of X.  */\n   if (TREE_CODE (x) == VAR_DECL\n@@ -843,7 +896,7 @@ mark_addressable (tree x)\n     {\n       tree *namep = cfun->gimple_df->decls_to_pointers->get (x);\n       if (namep)\n-\tTREE_ADDRESSABLE (*namep) = 1;\n+\tmark_addressable_1 (*namep);\n     }\n }\n "}, {"sha": "2917d2752cfdaefdabc84ec382ccd2c259523620", "filename": "gcc/gimple-expr.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b223a9f3489296c625bdb7cc764196d04fd9231/gcc%2Fgimple-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b223a9f3489296c625bdb7cc764196d04fd9231/gcc%2Fgimple-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.h?ref=1b223a9f3489296c625bdb7cc764196d04fd9231", "patch": "@@ -52,6 +52,7 @@ extern bool is_gimple_asm_val (tree);\n extern bool is_gimple_min_lval (tree);\n extern bool is_gimple_call_addr (tree);\n extern bool is_gimple_mem_ref_addr (tree);\n+extern void flush_mark_addressable_queue (void);\n extern void mark_addressable (tree);\n extern bool is_gimple_reg_rhs (tree);\n "}]}