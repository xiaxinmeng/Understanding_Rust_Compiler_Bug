{"sha": "fd6c76f46242891b11b7abbacb3c735f0012a240", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ2Yzc2ZjQ2MjQyODkxYjExYjdhYmJhY2IzYzczNWYwMDEyYTI0MA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-12-27T23:27:34Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2005-12-27T23:27:34Z"}, "message": "fold-const.c (int_const_binop): Return NULL_TREE when an expression can't be evaluated at compile-time (instead...\n\n\n\t* fold-const.c (int_const_binop): Return NULL_TREE when an expression\n\tcan't be evaluated at compile-time (instead of calling abort).\n\tReturn NULL_TREE for division (and modulus) by zero.\n\t(const_binop):  Return NULL_TREE for floating point operators that\n\taren't handled by real_arithmetic.\n\t(fold_binary):  Eliminate \"wins\" variable, and \"binary\" label, by\n\tfolding operators with constant operands early.  Assert that\n\toperands are non-NULL.\n\nFrom-SVN: r109088", "tree": {"sha": "3a566e041774c2831cfd87b087b4ca55259f0e53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a566e041774c2831cfd87b087b4ca55259f0e53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd6c76f46242891b11b7abbacb3c735f0012a240", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd6c76f46242891b11b7abbacb3c735f0012a240", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd6c76f46242891b11b7abbacb3c735f0012a240", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd6c76f46242891b11b7abbacb3c735f0012a240/comments", "author": null, "committer": null, "parents": [{"sha": "5156c0c3a78803759bd723877af0ef2baafea938", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5156c0c3a78803759bd723877af0ef2baafea938", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5156c0c3a78803759bd723877af0ef2baafea938"}], "stats": {"total": 179, "additions": 88, "deletions": 91}, "files": [{"sha": "2103a6637058724ce3dd7a2692c0e119c7043e11", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6c76f46242891b11b7abbacb3c735f0012a240/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6c76f46242891b11b7abbacb3c735f0012a240/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fd6c76f46242891b11b7abbacb3c735f0012a240", "patch": "@@ -1,3 +1,14 @@\n+2005-12-27  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (int_const_binop): Return NULL_TREE when an expression\n+\tcan't be evaluated at compile-time (instead of calling abort).\n+\tReturn NULL_TREE for division (and modulus) by zero.\n+\t(const_binop):  Return NULL_TREE for floating point operators that\n+\taren't handled by real_arithmetic.\n+\t(fold_binary):  Eliminate \"wins\" variable, and \"binary\" label, by\n+\tfolding operators with constant operands early.  Assert that\n+\toperands are non-NULL.\n+\n 2005-12-27  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* tree-vrp.c (extract_range_from_binary_expr): Use"}, {"sha": "4006d8996a9c3437ecbf15c1d1044f25b06449e3", "filename": "gcc/fold-const.c", "status": "modified", "additions": 77, "deletions": 91, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd6c76f46242891b11b7abbacb3c735f0012a240/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd6c76f46242891b11b7abbacb3c735f0012a240/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=fd6c76f46242891b11b7abbacb3c735f0012a240", "patch": "@@ -1345,7 +1345,8 @@ associate_trees (tree t1, tree t2, enum tree_code code, tree type)\n }\n \f\n /* Combine two integer constants ARG1 and ARG2 under operation CODE\n-   to produce a new constant.\n+   to produce a new constant.  Return NULL_TREE if we don't know how\n+   to evaluate CODE at compile-time.\n \n    If NOTRUNC is nonzero, do not truncate the result to fit the data type.  */\n \n@@ -1434,6 +1435,8 @@ int_const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n       /* ... fall through ...  */\n \n     case ROUND_DIV_EXPR:\n+      if (int2h == 0 && int2l == 0)\n+\treturn NULL_TREE;\n       if (int2h == 0 && int2l == 1)\n \t{\n \t  low = int1l, hi = int1h;\n@@ -1466,6 +1469,8 @@ int_const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n       /* ... fall through ...  */\n \n     case ROUND_MOD_EXPR:\n+      if (int2h == 0 && int2l == 0)\n+\treturn NULL_TREE;\n       overflow = div_and_round_double (code, uns,\n \t\t\t\t       int1l, int1h, int2l, int2h,\n \t\t\t\t       &garbagel, &garbageh, &low, &hi);\n@@ -1490,7 +1495,7 @@ int_const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n       break;\n \n     default:\n-      gcc_unreachable ();\n+      return NULL_TREE;\n     }\n \n   t = build_int_cst_wide (TREE_TYPE (arg1), low, hi);\n@@ -1546,6 +1551,21 @@ const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n       bool inexact;\n       tree t, type;\n \n+      /* The following codes are handled by real_arithmetic.  */\n+      switch (code)\n+\t{\n+\tcase PLUS_EXPR:\n+\tcase MINUS_EXPR:\n+\tcase MULT_EXPR:\n+\tcase RDIV_EXPR:\n+\tcase MIN_EXPR:\n+\tcase MAX_EXPR:\n+\t  break;\n+\n+\tdefault:\n+\t  return NULL_TREE;\n+\t}\n+\n       d1 = TREE_REAL_CST (arg1);\n       d2 = TREE_REAL_CST (arg2);\n \n@@ -1605,6 +1625,7 @@ const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n \t  | TREE_CONSTANT_OVERFLOW (arg2);\n       return t;\n     }\n+\n   if (TREE_CODE (arg1) == COMPLEX_CST)\n     {\n       tree type = TREE_TYPE (arg1);\n@@ -1680,11 +1701,11 @@ const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n \t  break;\n \n \tdefault:\n-\t  gcc_unreachable ();\n+\t  return NULL_TREE;\n \t}\n       return t;\n     }\n-  return 0;\n+  return NULL_TREE;\n }\n \n /* Create a size type INT_CST node with NUMBER sign extended.  KIND\n@@ -7171,80 +7192,57 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n   tree arg0 = NULL_TREE, arg1 = NULL_TREE;\n   enum tree_code_class kind = TREE_CODE_CLASS (code);\n \n-  /* WINS will be nonzero when the switch is done\n-     if all operands are constant.  */\n-  int wins = 1;\n-\n   gcc_assert (IS_EXPR_CODE_CLASS (kind)\n-\t      && TREE_CODE_LENGTH (code) == 2);\n+\t      && TREE_CODE_LENGTH (code) == 2\n+\t      && op0 != NULL_TREE\n+\t      && op1 != NULL_TREE);\n \n   arg0 = op0;\n   arg1 = op1;\n \n-  if (arg0)\n-    {\n-      tree subop;\n-\n-      /* Strip any conversions that don't change the mode.  This is\n-\t safe for every expression, except for a comparison expression\n-\t because its signedness is derived from its operands.  So, in\n-\t the latter case, only strip conversions that don't change the\n-\t signedness.\n-\n-\t Note that this is done as an internal manipulation within the\n-\t constant folder, in order to find the simplest representation\n-\t of the arguments so that their form can be studied.  In any\n-\t cases, the appropriate type conversions should be put back in\n-\t the tree that will get out of the constant folder.  */\n-      if (kind == tcc_comparison)\n-\tSTRIP_SIGN_NOPS (arg0);\n-      else\n-\tSTRIP_NOPS (arg0);\n+  /* Strip any conversions that don't change the mode.  This is\n+     safe for every expression, except for a comparison expression\n+     because its signedness is derived from its operands.  So, in\n+     the latter case, only strip conversions that don't change the\n+     signedness.\n \n-      if (TREE_CODE (arg0) == COMPLEX_CST)\n-\tsubop = TREE_REALPART (arg0);\n-      else\n-\tsubop = arg0;\n+     Note that this is done as an internal manipulation within the\n+     constant folder, in order to find the simplest representation\n+     of the arguments so that their form can be studied.  In any\n+     cases, the appropriate type conversions should be put back in\n+     the tree that will get out of the constant folder.  */\n \n-      if (TREE_CODE (subop) != INTEGER_CST\n-\t  && TREE_CODE (subop) != REAL_CST)\n-\t/* Note that TREE_CONSTANT isn't enough:\n-\t   static var addresses are constant but we can't\n-\t   do arithmetic on them.  */\n-\twins = 0;\n+  if (kind == tcc_comparison)\n+    {\n+      STRIP_SIGN_NOPS (arg0);\n+      STRIP_SIGN_NOPS (arg1);\n     }\n-\n-  if (arg1)\n+  else\n     {\n-      tree subop;\n-\n-      /* Strip any conversions that don't change the mode.  This is\n-\t safe for every expression, except for a comparison expression\n-\t because its signedness is derived from its operands.  So, in\n-\t the latter case, only strip conversions that don't change the\n-\t signedness.\n-\n-\t Note that this is done as an internal manipulation within the\n-\t constant folder, in order to find the simplest representation\n-\t of the arguments so that their form can be studied.  In any\n-\t cases, the appropriate type conversions should be put back in\n-\t the tree that will get out of the constant folder.  */\n-      if (kind == tcc_comparison)\n-\tSTRIP_SIGN_NOPS (arg1);\n-      else\n-\tSTRIP_NOPS (arg1);\n+      STRIP_NOPS (arg0);\n+      STRIP_NOPS (arg1);\n+    }\n \n-      if (TREE_CODE (arg1) == COMPLEX_CST)\n-\tsubop = TREE_REALPART (arg1);\n+  /* Note that TREE_CONSTANT isn't enough: static var addresses are\n+     constant but we can't do arithmetic on them.  */\n+  if ((TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n+      || (TREE_CODE (arg0) == REAL_CST && TREE_CODE (arg1) == REAL_CST)\n+      || (TREE_CODE (arg0) == COMPLEX_CST && TREE_CODE (arg1) == COMPLEX_CST)\n+      || (TREE_CODE (arg0) == VECTOR_CST && TREE_CODE (arg1) == VECTOR_CST))\n+    {\n+      if (kind == tcc_binary)\n+\ttem = const_binop (code, arg0, arg1, 0);\n+      else if (kind == tcc_comparison)\n+\ttem = fold_relational_const (code, type, arg0, arg1);\n       else\n-\tsubop = arg1;\n+\ttem = NULL_TREE;\n \n-      if (TREE_CODE (subop) != INTEGER_CST\n-\t  && TREE_CODE (subop) != REAL_CST)\n-\t/* Note that TREE_CONSTANT isn't enough:\n-\t   static var addresses are constant but we can't\n-\t   do arithmetic on them.  */\n-\twins = 0;\n+      if (tem != NULL_TREE)\n+\t{\n+\t  if (TREE_TYPE (tem) != type)\n+\t    tem = fold_convert (type, tem);\n+\t  return tem;\n+\t}\n     }\n \n   /* If this is a commutative operation, and ARG0 is a constant, move it\n@@ -7253,9 +7251,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n       && tree_swap_operands_p (arg0, arg1, true))\n     return fold_build2 (code, type, op1, op0);\n \n-  /* Now WINS is set as described above,\n-     ARG0 is the first operand of EXPR,\n-     and ARG1 is the second operand (if it has more than one operand).\n+  /* ARG0 is the first operand of EXPR, and ARG1 is the second operand.\n \n      First check for cases where an arithmetic operation is applied to a\n      compound, conditional, or comparison operation.  Push the arithmetic\n@@ -7577,8 +7573,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t don't associate floats at all, unless the user has specified\n \t -funsafe-math-optimizations.  */\n \n-      if (! wins\n-\t  && (! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations))\n+      if (! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations)\n \t{\n \t  tree var0, con0, lit0, minus_lit0;\n \t  tree var1, con1, lit1, minus_lit1;\n@@ -7652,18 +7647,6 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t    }\n \t}\n \n-    binary:\n-      if (wins)\n-\tt1 = const_binop (code, arg0, arg1, 0);\n-      if (t1 != NULL_TREE)\n-\t{\n-\t  /* The return value should always have\n-\t     the same type as the original expression.  */\n-\t  if (TREE_TYPE (t1) != type)\n-\t    t1 = fold_convert (type, t1);\n-\n-\t  return t1;\n-\t}\n       return NULL_TREE;\n \n     case MINUS_EXPR:\n@@ -7691,7 +7674,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n       if (! FLOAT_TYPE_P (type))\n \t{\n-\t  if (! wins && integer_zerop (arg0))\n+\t  if (integer_zerop (arg0))\n \t    return negate_expr (fold_convert (type, arg1));\n \t  if (integer_zerop (arg1))\n \t    return non_lvalue (fold_convert (type, arg0));\n@@ -7739,7 +7722,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n       /* (ARG0 - ARG1) is the same as (-ARG1 + ARG0).  So check whether\n \t ARG0 is zero and X + ARG0 reduces to X, since that would mean\n \t (-ARG1 + ARG0) reduces to -ARG1.  */\n-      else if (!wins && fold_real_zero_addition_p (TREE_TYPE (arg1), arg0, 0))\n+      else if (fold_real_zero_addition_p (TREE_TYPE (arg1), arg0, 0))\n \treturn negate_expr (fold_convert (type, arg1));\n \n       /* Fold &x - &x.  This can happen from &x.foo - &x.\n@@ -7753,7 +7736,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \treturn fold_convert (type, integer_zero_node);\n \n       /* A - B -> A + (-B) if B is easily negatable.  */\n-      if (!wins && negate_expr_p (arg1)\n+      if (negate_expr_p (arg1)\n \t  && ((FLOAT_TYPE_P (type)\n                /* Avoid this transformation if B is a positive REAL_CST.  */\n \t       && (TREE_CODE (arg1) != REAL_CST\n@@ -8488,7 +8471,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      return fold_build2 (MULT_EXPR, type, arg0, arg1);\n \t    }\n \t}\n-      goto binary;\n+      return NULL_TREE;\n \n     case TRUNC_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n@@ -8533,7 +8516,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && 0 != (tem = extract_muldiv (op0, arg1, code, NULL_TREE)))\n \treturn fold_convert (type, tem);\n \n-      goto binary;\n+      return NULL_TREE;\n \n     case CEIL_MOD_EXPR:\n     case FLOOR_MOD_EXPR:\n@@ -8613,7 +8596,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && 0 != (tem = extract_muldiv (op0, arg1, code, NULL_TREE)))\n \treturn fold_convert (type, tem);\n \n-      goto binary;\n+      return NULL_TREE;\n \n     case LROTATE_EXPR:\n     case RROTATE_EXPR:\n@@ -8727,7 +8710,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t      == (unsigned int) GET_MODE_BITSIZE (TYPE_MODE (type))))\n \treturn TREE_OPERAND (arg0, 0);\n \n-      goto binary;\n+      return NULL_TREE;\n \n     case MIN_EXPR:\n       if (operand_equal_p (arg0, arg1, 0))\n@@ -9998,7 +9981,10 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n       return pedantic_non_lvalue (tem);\n \n     case COMPLEX_EXPR:\n-      if (wins)\n+      if ((TREE_CODE (arg0) == REAL_CST\n+\t   && TREE_CODE (arg1) == REAL_CST)\n+\t  || (TREE_CODE (arg0) == INTEGER_CST\n+\t      && TREE_CODE (arg1) == INTEGER_CST))\n \treturn build_complex (type, arg0, arg1);\n       return NULL_TREE;\n "}]}