{"sha": "a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI5YmQ0ZjU5ZTllZWJmNTJhYzQxZjdkN2E2ZmE4M2NmMmFhZTA5ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-09-26T08:10:09Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-09-26T08:10:09Z"}, "message": "openmp: Improve #pragma omp simd vectorization\n\nAs mentioned earlier, the vectorizer punts on vectorization of loops with non-constant\nsteps.  As for OpenMP loops it is by the language restriction always possible to compute\nthe number of loop iterations before the loop, this change helps those cases\nby computing it and using an alternate IV that iterates from 0 to < niterations with\nstep of 1 next to the normal IV which will be just linear in that.\n\nList of functions where we compared to current trunk vectorize some loops where we\npreviously didn't (for c-c++-common only listing the C function names, both C and C++\nare affected though):\n\ngcc/testsuite/gcc.dg/vect/vect-simd-17.c doit\ngcc/testsuite/gcc.dg/vect/vect-simd-18.c foo\ngcc/testsuite/gcc.dg/vect/vect-simd-19.c foo\ngcc/testsuite/gcc.dg/vect/vect-simd-20.c foo\nlibgomp/testsuite/libgomp.c-c++-common/for-2.c f3_f_simd_auto\nlibgomp/testsuite/libgomp.c-c++-common/for-2.c f3_f_simd_guided32\nlibgomp/testsuite/libgomp.c-c++-common/for-2.c f3_f_simd_runtime\nlibgomp/testsuite/libgomp.c-c++-common/for-2.c f3_f_simd_static\nlibgomp/testsuite/libgomp.c-c++-common/for-2.c f3_f_simd_static32\nlibgomp/testsuite/libgomp.c-c++-common/for-2.c f3_pf_simd_auto._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-2.c f3_pf_simd_guided32._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-2.c f3_pf_simd_runtime._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-2.c f3_pf_simd_static32._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-2.c f3_pf_simd_static._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-2.c f3_simd_normal\nlibgomp/testsuite/libgomp.c-c++-common/for-2.c f5_simd_normal\nlibgomp/testsuite/libgomp.c-c++-common/for-2.c f6_simd_normal\nlibgomp/testsuite/libgomp.c-c++-common/for-3.c f3_dpfs_auto._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-3.c f3_dpfs_ds128_auto._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-3.c f3_dpfs_ds128_guided32._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-3.c f3_dpfs_ds128_runtime._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-3.c f3_dpfs_ds128_static32._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-3.c f3_dpfs_ds128_static._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-3.c f3_dpfs_guided32._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-3.c f3_dpfs_runtime._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-3.c f3_dpfs_static32._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-3.c f3_dpfs_static._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-3.c f3_ds_ds128_normal\nlibgomp/testsuite/libgomp.c-c++-common/for-3.c f3_ds_normal\nlibgomp/testsuite/libgomp.c-c++-common/for-4.c f3_taskloop_simd_normal._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f3_tpf_simd_auto._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f3_tpf_simd_guided32._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f3_tpf_simd_runtime._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f3_tpf_simd_static32._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f3_tpf_simd_static._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f3_t_simd_normal._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f3_ttdpfs_auto._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f3_ttdpfs_ds128_auto._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f3_ttdpfs_ds128_guided32._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f3_ttdpfs_ds128_runtime._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f3_ttdpfs_ds128_static32._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f3_ttdpfs_ds128_static._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f3_ttdpfs_guided32._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f3_ttdpfs_runtime._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f3_ttdpfs_static32._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f3_ttdpfs_static._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f3_ttds_ds128_normal._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f3_ttds_normal._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f5_t_simd_normal._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-5.c f6_t_simd_normal._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-6.c f3_tdpfs_auto._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-6.c f3_tdpfs_ds128_auto._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-6.c f3_tdpfs_ds128_guided32._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-6.c f3_tdpfs_ds128_runtime._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-6.c f3_tdpfs_ds128_static32._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-6.c f3_tdpfs_ds128_static._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-6.c f3_tdpfs_guided32._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-6.c f3_tdpfs_runtime._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-6.c f3_tdpfs_static32._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-6.c f3_tdpfs_static._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-6.c f3_tds_ds128_normal._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-6.c f3_tds_normal._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-14.c f3_dpfs_auto._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-14.c f3_dpfs_ds128_auto._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-14.c f3_dpfs_ds128_guided32._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-14.c f3_dpfs_ds128_runtime._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-14.c f3_dpfs_ds128_static32._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-14.c f3_dpfs_ds128_static._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-14.c f3_dpfs_guided32._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-14.c f3_dpfs_runtime._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-14.c f3_dpfs_static32._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-14.c f3_dpfs_static._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-14.c f3_ds_ds128_normal\nlibgomp/testsuite/libgomp.c-c++-common/for-14.c f3_ds_normal\nlibgomp/testsuite/libgomp.c-c++-common/for-15.c f3_tdpfs_auto._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-15.c f3_tdpfs_ds128_auto._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-15.c f3_tdpfs_ds128_guided32._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-15.c f3_tdpfs_ds128_runtime._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-15.c f3_tdpfs_ds128_static32._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-15.c f3_tdpfs_ds128_static._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-15.c f3_tdpfs_guided32._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-15.c f3_tdpfs_runtime._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-15.c f3_tdpfs_static32._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-15.c f3_tdpfs_static._omp_fn.1\nlibgomp/testsuite/libgomp.c-c++-common/for-15.c f3_tds_ds128_normal._omp_fn.0\nlibgomp/testsuite/libgomp.c-c++-common/for-15.c f3_tds_normal._omp_fn.0\n\n2020-09-26  Jakub Jelinek  <jakub@redhat.com>\n\n\t* omp-expand.c (expand_omp_simd): Help vectorizer for the collapse == 1\n\tand non-composite collapse > 1 case with non-constant innermost loop\n\tstep by precomputing number of iterations before loop and using an\n\talternate IV from 0 to number of iterations - 1 with step of 1.\n\n\t* gcc.dg/vect/vect-simd-17.c: Expect 11 or more vectorized loops.\n\t* gcc.dg/vect/vect-simd-18.c: New test.\n\t* gcc.dg/vect/vect-simd-19.c: New test.\n\t* gcc.dg/vect/vect-simd-20.c: New test.", "tree": {"sha": "596cff33e64350adf7347f302f330b5a6585f0ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/596cff33e64350adf7347f302f330b5a6585f0ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d00b1b023ecfc3ddc3fe952c0063dab7529d5f7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d00b1b023ecfc3ddc3fe952c0063dab7529d5f7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d00b1b023ecfc3ddc3fe952c0063dab7529d5f7a"}], "stats": {"total": 235, "additions": 230, "deletions": 5}, "files": [{"sha": "99cb4f9dda49c4e27ec815fcde3af572e82dfc5d", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 106, "deletions": 4, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d", "patch": "@@ -6452,6 +6452,56 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n     }\n   else\n     expand_omp_build_assign (&gsi, fd->loop.v, fold_convert (type, n1));\n+  tree altv = NULL_TREE, altn2 = NULL_TREE;\n+  if (fd->collapse == 1\n+      && !broken_loop\n+      && TREE_CODE (fd->loops[0].step) != INTEGER_CST)\n+    {\n+      /* The vectorizer currently punts on loops with non-constant steps\n+\t for the main IV (can't compute number of iterations and gives up\n+\t because of that).  As for OpenMP loops it is always possible to\n+\t compute the number of iterations upfront, use an alternate IV\n+\t as the loop iterator:\n+\t altn2 = n1 < n2 ? (n2 - n1 + step - 1) / step : 0;\n+\t for (i = n1, altv = 0; altv < altn2; altv++, i += step)  */\n+      altv = create_tmp_var (unsigned_type_for (TREE_TYPE (fd->loops[0].v)));\n+      expand_omp_build_assign (&gsi, altv, build_zero_cst (TREE_TYPE (altv)));\n+      tree itype = TREE_TYPE (fd->loop.v);\n+      if (POINTER_TYPE_P (itype))\n+\titype = signed_type_for (itype);\n+      t = build_int_cst (itype, (fd->loop.cond_code == LT_EXPR ? -1 : 1));\n+      t = fold_build2 (PLUS_EXPR, itype,\n+\t\t       fold_convert (itype, fd->loop.step), t);\n+      t = fold_build2 (PLUS_EXPR, itype, t, fold_convert (itype, n2));\n+      t = fold_build2 (MINUS_EXPR, itype, t,\n+\t\t       fold_convert (itype, fd->loop.v));\n+      if (TYPE_UNSIGNED (itype) && fd->loop.cond_code == GT_EXPR)\n+\tt = fold_build2 (TRUNC_DIV_EXPR, itype,\n+\t\t\t fold_build1 (NEGATE_EXPR, itype, t),\n+\t\t\t fold_build1 (NEGATE_EXPR, itype,\n+\t\t\t\t      fold_convert (itype, fd->loop.step)));\n+      else\n+\tt = fold_build2 (TRUNC_DIV_EXPR, itype, t,\n+\t\t\t fold_convert (itype, fd->loop.step));\n+      t = fold_convert (TREE_TYPE (altv), t);\n+      altn2 = create_tmp_var (TREE_TYPE (altv));\n+      expand_omp_build_assign (&gsi, altn2, t);\n+      tree t2 = fold_convert (TREE_TYPE (fd->loop.v), n2);\n+      t2 = force_gimple_operand_gsi (&gsi, t2, true, NULL_TREE,\n+\t\t\t\t     true, GSI_SAME_STMT);\n+      t2 = fold_build2 (fd->loop.cond_code, boolean_type_node, fd->loop.v, t2);\n+      gassign *g = gimple_build_assign (altn2, COND_EXPR, t2, altn2,\n+\t\t\t\t\tbuild_zero_cst (TREE_TYPE (altv)));\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+    }\n+  else if (fd->collapse > 1\n+\t   && !broken_loop\n+\t   && !gimple_omp_for_combined_into_p (fd->for_stmt)\n+\t   && TREE_CODE (fd->loops[fd->collapse - 1].step) != INTEGER_CST)\n+    {\n+      altv = create_tmp_var (unsigned_type_for (TREE_TYPE (fd->loops[0].v)));\n+      altn2 = create_tmp_var (TREE_TYPE (altv));\n+    }\n   if (cond_var)\n     {\n       if (POINTER_TYPE_P (type)\n@@ -6486,6 +6536,12 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n \t}\n       else if (TREE_CODE (n2) != INTEGER_CST)\n \texpand_omp_build_assign (&gsi, fd->loop.v, build_one_cst (type));\n+      if (altv)\n+\t{\n+\t  t = fold_build2 (PLUS_EXPR, TREE_TYPE (altv), altv,\n+\t\t\t   build_one_cst (TREE_TYPE (altv)));\n+\t  expand_omp_build_assign (&gsi, altv, t);\n+\t}\n \n       if (fd->collapse > 1)\n \t{\n@@ -6525,9 +6581,11 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n   /* Emit the condition in L1_BB.  */\n   gsi = gsi_start_bb (l1_bb);\n \n-  if (fd->collapse > 1\n-      && !gimple_omp_for_combined_into_p (fd->for_stmt)\n-      && !broken_loop)\n+  if (altv)\n+    t = build2 (LT_EXPR, boolean_type_node, altv, altn2);\n+  else if (fd->collapse > 1\n+\t   && !gimple_omp_for_combined_into_p (fd->for_stmt)\n+\t   && !broken_loop)\n     {\n       i = fd->collapse - 1;\n       tree itype = TREE_TYPE (fd->loops[i].v);\n@@ -6704,7 +6762,7 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n \t  expand_omp_build_assign (&gsi, fd->loops[i + 1].v, t);\n \t  if (fd->loops[i + 1].m2)\n \t    {\n-\t      if (i + 2 == fd->collapse && n2var)\n+\t      if (i + 2 == fd->collapse && (n2var || altv))\n \t\t{\n \t\t  gcc_assert (n2v == NULL_TREE);\n \t\t  n2v = create_tmp_var (TREE_TYPE (fd->loops[i + 1].v));\n@@ -6761,6 +6819,50 @@ expand_omp_simd (struct omp_region *region, struct omp_for_data *fd)\n \t      t = fold_build2 (PLUS_EXPR, type, fd->loop.v, t);\n \t      expand_omp_build_assign (&gsi, n2var, t);\n \t    }\n+\t  if (i + 2 == fd->collapse && altv)\n+\t    {\n+\t      /* The vectorizer currently punts on loops with non-constant\n+\t\t steps for the main IV (can't compute number of iterations\n+\t\t and gives up because of that).  As for OpenMP loops it is\n+\t\t always possible to compute the number of iterations upfront,\n+\t\t use an alternate IV as the loop iterator.  */\n+\t      expand_omp_build_assign (&gsi, altv,\n+\t\t\t\t       build_zero_cst (TREE_TYPE (altv)));\n+\t      tree itype = TREE_TYPE (fd->loops[i + 1].v);\n+\t      if (POINTER_TYPE_P (itype))\n+\t\titype = signed_type_for (itype);\n+\t      t = build_int_cst (itype, (fd->loops[i + 1].cond_code == LT_EXPR\n+\t\t\t\t\t ? -1 : 1));\n+\t      t = fold_build2 (PLUS_EXPR, itype,\n+\t\t\t       fold_convert (itype, fd->loops[i + 1].step), t);\n+\t      t = fold_build2 (PLUS_EXPR, itype, t,\n+\t\t\t       fold_convert (itype,\n+\t\t\t\t\t     fd->loops[i + 1].m2\n+\t\t\t\t\t     ? n2v : fd->loops[i + 1].n2));\n+\t      t = fold_build2 (MINUS_EXPR, itype, t,\n+\t\t\t       fold_convert (itype, fd->loops[i + 1].v));\n+\t      tree step = fold_convert (itype, fd->loops[i + 1].step);\n+\t      if (TYPE_UNSIGNED (itype)\n+\t\t  && fd->loops[i + 1].cond_code == GT_EXPR)\n+\t\tt = fold_build2 (TRUNC_DIV_EXPR, itype,\n+\t\t\t\t fold_build1 (NEGATE_EXPR, itype, t),\n+\t\t\t\t fold_build1 (NEGATE_EXPR, itype, step));\n+\t      else\n+\t\tt = fold_build2 (TRUNC_DIV_EXPR, itype, t, step);\n+\t      t = fold_convert (TREE_TYPE (altv), t);\n+\t      expand_omp_build_assign (&gsi, altn2, t);\n+\t      tree t2 = fold_convert (TREE_TYPE (fd->loops[i + 1].v),\n+\t\t\t\t      fd->loops[i + 1].m2\n+\t\t\t\t      ? n2v : fd->loops[i + 1].n2);\n+\t      t2 = force_gimple_operand_gsi (&gsi, t2, true, NULL_TREE,\n+\t\t\t\t\t     true, GSI_SAME_STMT);\n+\t      t2 = fold_build2 (fd->loops[i + 1].cond_code, boolean_type_node,\n+\t\t\t\tfd->loops[i + 1].v, t2);\n+\t      gassign *g\n+\t\t= gimple_build_assign (altn2, COND_EXPR, t2, altn2,\n+\t\t\t\t       build_zero_cst (TREE_TYPE (altv)));\n+\t      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t    }\n \t  n2v = nextn2v;\n \n \t  make_edge (init_bb, last_bb, EDGE_FALLTHRU);"}, {"sha": "951ba3afd9e332d7cd22addd273adf733e0fb71a", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-17.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-17.c?ref=a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d", "patch": "@@ -1,6 +1,6 @@\n /* { dg-additional-options \"-fopenmp-simd -fno-tree-vectorize\" } */\n /* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n-/* { dg-final { scan-tree-dump \"vectorized \\(\\[4-9]\\|1\\[0-2]\\) loops\" \"vect\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"vectorized 1\\[1-2] loops\" \"vect\" { target i?86-*-* x86_64-*-* } } } */\n \n #include \"tree-vect.h\"\n "}, {"sha": "b25f5a5cd3144d37cadda1323b98f417146a676c", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-18.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-18.c?ref=a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-additional-options \"-fopenmp-simd -fno-tree-vectorize\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" { target i?86-*-* x86_64-*-* } } } */\n+\n+#include \"tree-vect.h\"\n+\n+__attribute__((noipa)) int\n+foo (int s, int *p)\n+{\n+  int r = 0, l = 0, i;\n+  #pragma omp simd reduction (+:r) linear(l)\n+  for (i = 0; i < 10000; i += s)\n+    {\n+      p[l++] = i;\n+      r += i * 3;\n+    }\n+  return r;\n+}\n+\n+int p[10000 / 78];\n+\n+int\n+main ()\n+{\n+  int i, r;\n+  check_vect ();\n+  r = foo (78, p);\n+  for (i = 0; i < 10000 / 78; i++)\n+    if (p[i] != 78 * i)\n+      abort ();\n+  if (r != (10000 / 78) * (10000 / 78 + 1) / 2 * 78 * 3)\n+    abort ();\n+  r = foo (87, p);\n+  for (i = 0; i < 10000 / 87; i++)\n+    if (p[i] != 87 * i)\n+      abort ();\n+  if (r != (10000 / 87) * (10000 / 87 + 1) / 2 * 87 * 3)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "a71dfa676d8e92c6ed78f6bfef8c8965a4a4041f", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-19.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-19.c?ref=a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-additional-options \"-fopenmp-simd -fno-tree-vectorize\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" { target i?86-*-* x86_64-*-* } } } */\n+\n+#include \"tree-vect.h\"\n+\n+__attribute__((noipa)) int\n+foo (int s, int m, int n, int *p)\n+{\n+  int r = 0, l = 0, i;\n+  #pragma omp simd reduction (+:r) linear(l)\n+  for (i = m; i < n; i += s)\n+    {\n+      p[l++] = i;\n+      r += i * 3;\n+    }\n+  return r;\n+}\n+\n+int p[10000 / 78];\n+\n+int\n+main ()\n+{\n+  int i, r;\n+  check_vect ();\n+  r = foo (78, 0, 10000, p);\n+  for (i = 0; i < 10000 / 78; i++)\n+    if (p[i] != 78 * i)\n+      abort ();\n+  if (r != (10000 / 78) * (10000 / 78 + 1) / 2 * 78 * 3)\n+    abort ();\n+  r = foo (87, 0, 10000, p);\n+  for (i = 0; i < 10000 / 87; i++)\n+    if (p[i] != 87 * i)\n+      abort ();\n+  if (r != (10000 / 87) * (10000 / 87 + 1) / 2 * 87 * 3)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "c85f05f61c63a74c5e9bef615b6a2df5e7309021", "filename": "gcc/testsuite/gcc.dg/vect/vect-simd-20.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-simd-20.c?ref=a29bd4f59e9eebf52ac41f7d7a6fa83cf2aae09d", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-additional-options \"-fopenmp-simd -fno-tree-vectorize\" } */\n+/* { dg-additional-options \"-mavx\" { target avx_runtime } } */\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" { target i?86-*-* x86_64-*-* } } } */\n+\n+#include \"tree-vect.h\"\n+\n+__attribute__((noipa)) int\n+foo (int s, int m, int n, int *p)\n+{\n+  int r = 0, l = 0, i, j;\n+  #pragma omp simd reduction (+:r) linear(l) collapse(2)\n+  for (j = 0; j < 7; j++)\n+    for (i = m; i < n; i += s)\n+      {\n+\tp[l++] = i;\n+\tr += i * 3;\n+      }\n+  return r;\n+}\n+\n+int p[10000 / 78 * 7];\n+\n+int\n+main ()\n+{\n+  int i, j, r;\n+  check_vect ();\n+  r = foo (78, 0, 10000, p);\n+  for (j = 0; j < 7; j++)\n+    for (i = 0; i < 10000 / 78; i++)\n+      if (p[j * (10000 / 78 + 1) + i] != 78 * i)\n+\tabort ();\n+  if (r != (10000 / 78) * (10000 / 78 + 1) / 2 * 78 * 3 * 7)\n+    abort ();\n+  r = foo (87, 0, 10000, p);\n+  for (j = 0; j < 7; j++)\n+    for (i = 0; i < 10000 / 87; i++)\n+      if (p[j * (10000 / 87 + 1) + i] != 87 * i)\n+\tabort ();\n+  if (r != (10000 / 87) * (10000 / 87 + 1) / 2 * 87 * 3 * 7)\n+    abort ();\n+  return 0;\n+}"}]}