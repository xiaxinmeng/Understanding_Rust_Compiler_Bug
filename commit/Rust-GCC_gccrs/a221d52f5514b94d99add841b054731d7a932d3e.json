{"sha": "a221d52f5514b94d99add841b054731d7a932d3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIyMWQ1MmY1NTE0Yjk0ZDk5YWRkODQxYjA1NDczMWQ3YTkzMmQzZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-02-23T04:55:44Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-02-23T04:55:44Z"}, "message": "* pt.c (tsubst, FUNCTION_DECL): Tidy.\n\nFrom-SVN: r18200", "tree": {"sha": "568d44c26457e05eedda96f24d4f016d87cfd1b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/568d44c26457e05eedda96f24d4f016d87cfd1b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a221d52f5514b94d99add841b054731d7a932d3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a221d52f5514b94d99add841b054731d7a932d3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a221d52f5514b94d99add841b054731d7a932d3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a221d52f5514b94d99add841b054731d7a932d3e/comments", "author": null, "committer": null, "parents": [{"sha": "138928a69612cfe66459c6095eea555bf0f56646", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/138928a69612cfe66459c6095eea555bf0f56646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/138928a69612cfe66459c6095eea555bf0f56646"}], "stats": {"total": 105, "additions": 49, "deletions": 56}, "files": [{"sha": "3a128fe2a48ccff9c92502c5e2af6cb5957b2693", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a221d52f5514b94d99add841b054731d7a932d3e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a221d52f5514b94d99add841b054731d7a932d3e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a221d52f5514b94d99add841b054731d7a932d3e", "patch": "@@ -1,5 +1,7 @@\n Mon Feb 23 03:04:14 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n+\t* pt.c (tsubst, FUNCTION_DECL): Tidy.\n+\n \t* typeck.c (build_x_function_call): Handle static member function\n \ttemplates like non-templates.  Handle friend templates like normal\n \tfunction templates."}, {"sha": "c0894c80986f9fd972beb23cb9a480345e7c11bb", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 47, "deletions": 56, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a221d52f5514b94d99add841b054731d7a932d3e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a221d52f5514b94d99add841b054731d7a932d3e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a221d52f5514b94d99add841b054731d7a932d3e", "patch": "@@ -3266,6 +3266,22 @@ maybe_fold_nontype_arg (arg)\n   return arg;\n }\n \n+/* Return the TREE_VEC with the arguments for the innermost template header,\n+   where ARGS is either that or the VEC of VECs for all the arguments.\n+\n+   If is_spec, then we are dealing with a specialization of a member\n+   template, and want the second-innermost args, the innermost ones that\n+   are instantiated.  */\n+\n+tree\n+innermost_args (args, is_spec)\n+     tree args;\n+     int is_spec;\n+{\n+  if (TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n+    return TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1 - is_spec);\n+  return args;\n+}\n \n /* Take the tree structure T and replace template parameters used therein\n    with the argument vector ARGS.  NARGS is the number of args; should\n@@ -3627,7 +3643,7 @@ tsubst (t, args, nargs, in_decl)\n       {\n \ttree r = NULL_TREE;\n \ttree ctx;\n-\ttree fullargs = args;\n+\ttree argvec;\n \ttree tmpl = NULL_TREE;\n \tint member;\n \n@@ -3654,12 +3670,28 @@ tsubst (t, args, nargs, in_decl)\n \t    tree spec;\n \n \t    tmpl = DECL_TI_TEMPLATE (t);\n-\t    /* FIXME is this right for specializations?  */\n+\n+\t    /* Start by getting the innermost args.  */\n+\t    argvec = tsubst (DECL_TI_ARGS (t), args, nargs, in_decl);\n+\n+\t    /* If tmpl is an instantiation of a member template, tack on\n+\t       the args for the enclosing class.  NOTE: this will change\n+\t       for member class templates.  The generalized procedure\n+\t       is to grab the outer args, then tack on the current args,\n+\t       then any specialized args.  */\n \t    if (DECL_TEMPLATE_INFO (tmpl) && DECL_TI_ARGS (tmpl))\n-\t      fullargs = add_to_template_args (DECL_TI_ARGS (tmpl), args);\n+\t      {\n+\t\tif (!DECL_TEMPLATE_SPECIALIZATION (tmpl))\n+\t\t  argvec = add_to_template_args (DECL_TI_ARGS (tmpl), argvec);\n+\t\telse\n+\t\t  /* In this case, we are instantiating a\n+\t\t     specialization.  The innermost template args are\n+\t\t     already given by the specialization.  */\n+\t\t  argvec = add_to_template_args (argvec, DECL_TI_ARGS (tmpl));\n+\t      }\n \n \t    /* Do we already have this instantiation?  */\n-\t    spec = retrieve_specialization (tmpl, fullargs);\n+\t    spec = retrieve_specialization (tmpl, argvec);\n \t    if (spec)\n \t      return spec;\n \t  }\n@@ -3714,7 +3746,7 @@ tsubst (t, args, nargs, in_decl)\n \t      tmpl = in_decl;\n \n \t    /* tmpl will be NULL if this is a specialization of a\n-\t       member template of a template class.  */\n+\t       member function of a template class.  */\n \t    if (name_mangling_version < 1\n \t\t|| tmpl == NULL_TREE\n \t\t|| (member && !is_member_template (tmpl)\n@@ -3732,30 +3764,22 @@ tsubst (t, args, nargs, in_decl)\n \t      }\n \t    else\n \t      {\n-\t\t/* We pass the outermost template parameters to\n-\t\t   build_template_decl_overload since the innermost\n-\t\t   template parameters are still just template\n-\t\t   parameters; there are no corresponding subsitution\n-\t\t   arguments.  We get here with full args and only one\n-\t\t   level of parms.  This is necessary because when we\n-\t\t   partially instantiate a member template, even\n-\t\t   though there's really only one level of parms, left\n-\t\t   the parms from the original template, which have\n-\t\t   level 2, may appear in the definition of the a\n-\t\t   function body.  */\n \t\ttree tparms; \n \t\ttree targs;\n \n \t\tif (!DECL_TEMPLATE_SPECIALIZATION (tmpl)) \n \t\t  {\n+\t\t    /* We pass the outermost template parameters to\n+\t\t       build_template_decl_overload, since the innermost\n+\t\t       template parameters are still just template\n+\t\t       parameters; there are no corresponding subsitution\n+\t\t       arguments.  Levels of parms that have been bound\n+\t\t       before are not represented in DECL_TEMPLATE_PARMS.  */\n \t\t    tparms = DECL_TEMPLATE_PARMS (tmpl);\n \t\t    while (tparms && TREE_CHAIN (tparms) != NULL_TREE)\n \t\t      tparms = TREE_CHAIN (tparms);\n \t\t    \n-\t\t    targs = \n-\t\t      (TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC \n-\t\t       ? TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1)\n-\t\t       : args); \n+\t\t    targs = innermost_args (args, 0);\n \t\t  }\n \t\telse\n \t\t  {\n@@ -3848,25 +3872,6 @@ tsubst (t, args, nargs, in_decl)\n \n \tif (DECL_TEMPLATE_INFO (t) != NULL_TREE)\n \t  {\n-\t    tree argvec;\n-\n-\t    /* FIXME this is ugly.  */\n-\t    if (TREE_CODE (TREE_VEC_ELT (args, 0)) != TREE_VEC)\n-\t      argvec = args;\n-\t    else\n-\t      argvec = tsubst (DECL_TI_ARGS (t), args, nargs, in_decl);\n-\n-\t    if (DECL_TEMPLATE_INFO (tmpl) && DECL_TI_ARGS (tmpl))\n-\t      {\n-\t\tif (!DECL_TEMPLATE_SPECIALIZATION (tmpl))\n-\t\t  argvec = add_to_template_args (DECL_TI_ARGS (tmpl), argvec);\n-\t\telse\n-\t\t  /* In this case, we are instantiating a\n-\t\t     specialization.  The innermost template args are\n-\t\t     already given by the specialization.  */\n-\t\t  argvec = add_to_template_args (argvec, DECL_TI_ARGS (tmpl));\n-\t      }\n-\n \t    DECL_TEMPLATE_INFO (r) = perm_tree_cons (tmpl, argvec, NULL_TREE);\n \n \t    /* If we're not using ANSI overloading, then we might have\n@@ -5977,18 +5982,6 @@ do_type_instantiation (t, storage)\n   }\n }\n \n-/* Return the TREE_VEC with the arguments for the innermost template header,\n-   where ARGS is either that or the VEC of VECs for all the arguments.  */\n-\n-tree\n-innermost_args (args)\n-     tree args;\n-{\n-  if (TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n-    return TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1);\n-  return args;\n-}\n-\n /* Produce the definition of D, a _DECL generated from a template.  */\n \n tree\n@@ -5998,7 +5991,7 @@ instantiate_decl (d)\n   tree ti = DECL_TEMPLATE_INFO (d);\n   tree tmpl = TI_TEMPLATE (ti);\n   tree args = TI_ARGS (ti);\n-  tree td;\n+  tree td, temp;\n   tree decl_pattern, code_pattern;\n   tree save_ti;\n   int nested = in_function_p ();\n@@ -6111,10 +6104,8 @@ instantiate_decl (d)\n   /* Trick tsubst into giving us a new decl in case the template changed.  */\n   save_ti = DECL_TEMPLATE_INFO (decl_pattern);\n   DECL_TEMPLATE_INFO (decl_pattern) = NULL_TREE;\n-  /* FIXME this is ugly.  */\n-  td = tsubst (decl_pattern,\n-\t       DECL_TEMPLATE_SPECIALIZATION (decl_pattern)\n-\t       ? args : innermost_args (args), 0, tmpl);\n+  temp = innermost_args (args, DECL_TEMPLATE_SPECIALIZATION (decl_pattern));\n+  td = tsubst (decl_pattern, temp, 0, tmpl);\n   SET_DECL_IMPLICIT_INSTANTIATION (td);\n   DECL_TEMPLATE_INFO (decl_pattern) = save_ti;\n "}]}