{"sha": "c6aa9ce1220d7ee06053af57cd923d080701d20b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZhYTljZTEyMjBkN2VlMDYwNTNhZjU3Y2Q5MjNkMDgwNzAxZDIwYg==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-05-07T00:30:10Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-05-07T00:30:10Z"}, "message": "(leaf_reg_backmap): Delete.\n\n(sparc_flat_compute_frame_size): Renamed from\nsparc_frw_compute_frame_size.  All callers changed.\n(sparc_flat_save_restore): Likewise.\n(sparc_flat_output_function_prologue): Likewise.\nDelete decl of call_used_regs.\nDelete reference to frame_base_name, use frame pointer explicitly.\nPrint prologue end marker.\n(sparc_flat_output_function_epilogue): Likewise (renaming).\nDelete decls of asm_out_data_file, asm_out_file, call_used_regs.\nPrint epilogue start marker.\n(sparc_flat_epilogue_delay_slots): Likewise (renaming).\n(sparc_flat_eligible_for_epilogue_delay): Likewise.\n\nFrom-SVN: r7258", "tree": {"sha": "c2fbb7c01f8664416247a92036121c895b448a32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2fbb7c01f8664416247a92036121c895b448a32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6aa9ce1220d7ee06053af57cd923d080701d20b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6aa9ce1220d7ee06053af57cd923d080701d20b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6aa9ce1220d7ee06053af57cd923d080701d20b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6aa9ce1220d7ee06053af57cd923d080701d20b/comments", "author": null, "committer": null, "parents": [{"sha": "5e6aa5131b827017f9a08f22d68f18931892808c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e6aa5131b827017f9a08f22d68f18931892808c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e6aa5131b827017f9a08f22d68f18931892808c"}], "stats": {"total": 61, "additions": 25, "deletions": 36}, "files": [{"sha": "855e32e87a2c1c987cfc6ff98a07dd5d816ccdbe", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 25, "deletions": 36, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6aa9ce1220d7ee06053af57cd923d080701d20b/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6aa9ce1220d7ee06053af57cd923d080701d20b/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=c6aa9ce1220d7ee06053af57cd923d080701d20b", "patch": "@@ -62,18 +62,6 @@ char leaf_reg_remap[] =\n   48, 49, 50, 51, 52, 53, 54, 55,\n   56, 57, 58, 59, 60, 61, 62, 63};\n \n-#if 0 /* not used anymore */\n-char leaf_reg_backmap[] =\n-{ 0, 1, 2, 3, 4, 5, 6, 7,\n-  24, 25, 26, 27, 28, 29, 14, 31,\n-  -1, -1, -1, -1, -1, -1, -1, -1,\n-  -1, -1, -1, -1, -1, -1, -1, -1,\n-\n-  32, 33, 34, 35, 36, 37, 38, 39,\n-  40, 41, 42, 43, 44, 45, 46, 47,\n-  48, 49, 50, 51, 52, 53, 54, 55,\n-  56, 57, 58, 59, 60, 61, 62, 63};\n-#endif\n #endif\n \n /* Global variables set by FUNCTION_PROLOGUE.  */\n@@ -2107,7 +2095,9 @@ output_function_prologue (file, size, leaf_function)\n      space for our callee (and our own register save area).  */\n   actual_fsize = compute_frame_size (size, leaf_function);\n \n+  /* This is only for the human reader.  */\n   fprintf (file, \"\\t!#PROLOGUE# 0\\n\");\n+\n   if (actual_fsize == 0)\n     /* do nothing.  */ ;\n   else if (actual_fsize <= 4096)\n@@ -3055,7 +3045,7 @@ sparc_type_code (type)\n \t\t\t\t    SP->|\t\t\t|\n \t\t\t\t\t+-----------------------+  */\n \n-/* Structure to be filled in by sparc_frw_compute_frame_size with register\n+/* Structure to be filled in by sparc_flat_compute_frame_size with register\n    save masks, and offsets for the current function.  */\n \n struct sparc_frame_info\n@@ -3073,7 +3063,7 @@ struct sparc_frame_info\n   int\t\tinitialized;\t/* Nonzero if frame size already calculated.  */\n };\n \n-/* Current frame information calculated by sparc_frw_compute_frame_size.  */\n+/* Current frame information calculated by sparc_flat_compute_frame_size.  */\n struct sparc_frame_info current_frame_info;\n \n /* Zero structure to initialize current_frame_info.  */\n@@ -3090,7 +3080,7 @@ struct sparc_frame_info zero_frame_info;\n    stack pointer.  */\n \n unsigned long\n-sparc_frw_compute_frame_size (size)\n+sparc_flat_compute_frame_size (size)\n      int size;\t\t\t/* # of var. bytes allocated.  */\n {\n   int regno;\n@@ -3191,7 +3181,7 @@ sparc_frw_compute_frame_size (size)\n /* Common code to save/restore registers.  */\n \n void\n-sparc_frw_save_restore (file, word_op, doubleword_op)\n+sparc_flat_save_restore (file, word_op, doubleword_op)\n      FILE *file;\t\t/* Stream to write to.  */\n      char *word_op;\t\t/* Operation to do for one word.  */\n      char *doubleword_op;\t/* Operation to do for doubleword.  */\n@@ -3291,24 +3281,19 @@ sparc_frw_save_restore (file, word_op, doubleword_op)\n /* Set up the stack and frame (if desired) for the function.  */\n \n void\n-sparc_frw_output_function_prologue (file, size, ignored)\n+sparc_flat_output_function_prologue (file, size)\n      FILE *file;\n      int size;\n {\n-  extern char call_used_regs[];\n   int tsize;\n   char *sp_str = reg_names[STACK_POINTER_REGNUM];\n \n-  /* ??? This should be %sp+actual_fsize for a leaf function.  I think it\n-     works only because it is never used.  */\n-  frame_base_name\n-    = (!frame_pointer_needed) ? \"%sp+80\" : reg_names[FRAME_POINTER_REGNUM];\n-\n+  /* This is only for the human reader.  */\n   fprintf (file, \"\\t!#PROLOGUE# 0\\n\");\n \n   size = SPARC_STACK_ALIGN (size);\n   tsize = (! current_frame_info.initialized\n-\t   ? sparc_frw_compute_frame_size (size)\n+\t   ? sparc_flat_compute_frame_size (size)\n \t   : current_frame_info.total_size);\n \n   if (tsize > 0)\n@@ -3332,44 +3317,48 @@ sparc_frw_output_function_prologue (file, size, ignored)\n \t\t current_frame_info.extra_size);\n     }\n \n-  sparc_frw_save_restore (file, \"st\", \"std\");\n+  sparc_flat_save_restore (file, \"st\", \"std\");\n \n   if (frame_pointer_needed)\n     {\n+      char *fp_str = reg_names[FRAME_POINTER_REGNUM];\n+\n       if (tsize <= 4095)\n \tfprintf (file, \"\\tadd %s,%d,%s\\t!# set up frame pointer\\n\", sp_str,\n-\t\t tsize, frame_base_name);\n+\t\t tsize, fp_str);\n       else\n \tfprintf (file, \"\\tadd %s,%s,%s\\t!# set up frame pointer\\n\", sp_str,\n-\t\t \"%g1\", frame_base_name);\n+\t\t \"%g1\", fp_str);\n     }\n+\n+  fprintf (file, \"\\t!#PROLOGUE# 1\\n\");\n }\n \f\n /* Do any necessary cleanup after a function to restore stack, frame,\n    and regs. */\n \n void\n-sparc_frw_output_function_epilogue (file, size, ignored1, ignored2)\n+sparc_flat_output_function_epilogue (file, size)\n      FILE *file;\n      int size;\n {\n-  extern FILE *asm_out_data_file, *asm_out_file;\n-  extern char call_used_regs[];\n-  extern int frame_pointer_needed;\n   int tsize;\n   char *sp_str = reg_names[STACK_POINTER_REGNUM];\n   char *t1_str = \"%g1\";\n   rtx epilogue_delay = current_function_epilogue_delay_list;\n   int noepilogue = FALSE;\n \n+  /* This is only for the human reader.  */\n+  fprintf (file, \"\\t!#EPILOGUE#\\n\");\n+\n   /* The epilogue does not depend on any registers, but the stack\n      registers, so we assume that if we have 1 pending nop, it can be\n      ignored, and 2 it must be filled (2 nops occur for integer\n      multiply and divide).  */\n \n   size = SPARC_STACK_ALIGN (size);\n   tsize = (!current_frame_info.initialized\n-\t   ? sparc_frw_compute_frame_size (size)\n+\t   ? sparc_flat_compute_frame_size (size)\n \t   : current_frame_info.total_size);\n \n   if (tsize == 0 && epilogue_delay == 0)\n@@ -3404,7 +3393,7 @@ sparc_frw_output_function_epilogue (file, size, ignored1, ignored2)\n \t\t     fp_str, tsize, sp_str);\n \t}\n \n-      sparc_frw_save_restore (file, \"ld\", \"ldd\");\n+      sparc_flat_save_restore (file, \"ld\", \"ldd\");\n \n       if (current_function_returns_struct)\n \tfprintf (file, \"\\tjmp %%o7+12\\n\");\n@@ -3443,10 +3432,10 @@ sparc_frw_output_function_epilogue (file, size, ignored1, ignored2)\n    or the only register saved is the return register.  */\n \n int\n-sparc_frw_epilogue_delay_slots ()\n+sparc_flat_epilogue_delay_slots ()\n {\n   if (!current_frame_info.initialized)\n-    (void) sparc_frw_compute_frame_size (get_frame_size ());\n+    (void) sparc_flat_compute_frame_size (get_frame_size ());\n \n   if (current_frame_info.total_size == 0)\n     return 1;\n@@ -3459,7 +3448,7 @@ sparc_frw_epilogue_delay_slots ()\n    pointer is OK.  */\n \n int\n-sparc_frw_eligible_for_epilogue_delay (trial, slot)\n+sparc_flat_eligible_for_epilogue_delay (trial, slot)\n      rtx trial;\n      int slot;\n {"}]}