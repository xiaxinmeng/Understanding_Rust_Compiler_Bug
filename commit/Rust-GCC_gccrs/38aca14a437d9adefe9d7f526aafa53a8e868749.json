{"sha": "38aca14a437d9adefe9d7f526aafa53a8e868749", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhhY2ExNGE0MzdkOWFkZWZlOWQ3ZjUyNmFhZmE1M2E4ZTg2ODc0OQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-06-27T10:43:32Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-21T07:22:51Z"}, "message": "[Ada] Support of the Ada.Text_IO hierarchy for 128-bit types\n\ngcc/ada/\n\n\t* Makefile.rtl (GNATRTL_NONTASKING_OBJS): Add a-llltio, a-lllwti,\n\ta-lllzti and remove a-timoau, a-wtmoau and a-ztmoau.\n\t(GNATRTL_128BIT_PAIRS): Add a-tiinio.adb, a-timoio.adb, a-wtinio.adb,\n\ta-wtmoio.adb, a-ztinio.adb and a-ztmoio.adb.\n\t* impunit.adb (Non_Imp_File_Names_95): Add a-llltio, a-lllwti and\n\ta-lllzti.\n\t* krunch.ads: Document trick for Ada.Long_Long_Long_Integer_*_IO.\n\t* krunch.adb (Krunch): Add trick for Ada.Long_Long_Long_Integer_*_IO.\n\t* libgnat/a-llltio.ads: Instantiate Ada.Text_IO.Integer_IO.\n\t* libgnat/a-lllwti.ads: Instantiate Ada.Wide_Text_IO.Integer_IO.\n\t* libgnat/a-lllzti.ads: Instantiate Ada.Wide_Wide_Text_IO.Integer_IO.\n\t* libgnat/a-tigeau.ads (Load_Integer): New procedure.\n\t* libgnat/a-tigeau.adb (Load_Integer): Likewise.\n\t* libgnat/a-tiinau.ads, libgnat/a-tiinau.adb: Change to generic\n\tpackage.\n\t* libgnat/a-tiinio.adb: Instantiate it.\n\t* libgnat/a-tiinio__128.adb: Likewise.\n\t* libgnat/a-timoau.ads, libgnat/a-timoau.adb: Change to generic\n\tpackage.\n\t* libgnat/a-timoio.adb: Instantiate it.\n\t* libgnat/a-timoio__128.adb: Likewise.\n\t* libgnat/a-wtgeau.ads (Load_Integer): New procedure.\n\t* libgnat/a-wtgeau.adb (Load_Integer): Likewise.\n\t* libgnat/a-wtinau.ads, libgnat/a-wtinau.adb: Change to generic\n\tpackage.\n\t* libgnat/a-wtinio.adb: Instantiate it.\n\t* libgnat/a-wtinio__128.adb: Likewise.\n\t* libgnat/a-wtmoau.ads, libgnat/a-wtmoau.adb: Change to generic\n\tpackage.\n\t* libgnat/a-wtmoio.adb: Instantiate it.\n\t* libgnat/a-wtmoio__128.adb: Likewise.\n\t* libgnat/a-ztgeau.ads (Load_Integer): New procedure.\n\t* libgnat/a-ztgeau.adb (Load_Integer): Likewise.\n\t* libgnat/a-ztinau.ads, libgnat/a-ztinau.adb: Change to generic\n\tpackage.\n\t* libgnat/a-ztinio.adb: Instantiate it.\n\t* libgnat/a-ztinio__128.adb: Likewise.\n\t* libgnat/a-ztmoau.ads, libgnat/a-ztmoau.adb: Change to generic\n\tpackage.\n\t* libgnat/a-ztmoio.adb: Instantiate it.\n\t* libgnat/a-ztmoio__128.adb: Likewise.", "tree": {"sha": "c9c6289088cb9c4ef4ff485a3fcaa9c2af0733f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9c6289088cb9c4ef4ff485a3fcaa9c2af0733f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38aca14a437d9adefe9d7f526aafa53a8e868749", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38aca14a437d9adefe9d7f526aafa53a8e868749", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38aca14a437d9adefe9d7f526aafa53a8e868749", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38aca14a437d9adefe9d7f526aafa53a8e868749/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cd2e6f249e55c810c0414572807face97d88f07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cd2e6f249e55c810c0414572807face97d88f07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cd2e6f249e55c810c0414572807face97d88f07"}], "stats": {"total": 3858, "additions": 1865, "deletions": 1993}, "files": [{"sha": "898eb5d7d76bc12f5feb713c4cb6de36bbacc553", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -206,6 +206,9 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-llitio$(objext) \\\n   a-lliwti$(objext) \\\n   a-llizti$(objext) \\\n+  a-llltio$(objext) \\\n+  a-lllwti$(objext) \\\n+  a-lllzti$(objext) \\\n   a-locale$(objext) \\\n   a-nbnbin$(objext) \\\n   a-nbnbre$(objext) \\\n@@ -347,7 +350,6 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-tigeau$(objext) \\\n   a-tiinau$(objext) \\\n   a-tiinio$(objext) \\\n-  a-timoau$(objext) \\\n   a-timoio$(objext) \\\n   a-tiocst$(objext) \\\n   a-tirsfi$(objext) \\\n@@ -375,7 +377,6 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-wtgeau$(objext) \\\n   a-wtinau$(objext) \\\n   a-wtinio$(objext) \\\n-  a-wtmoau$(objext) \\\n   a-wtmoio$(objext) \\\n   a-wttest$(objext) \\\n   a-wwboio$(objext) \\\n@@ -399,7 +400,6 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-ztgeau$(objext) \\\n   a-ztinau$(objext) \\\n   a-ztinio$(objext) \\\n-  a-ztmoau$(objext) \\\n   a-ztmoio$(objext) \\\n   a-zttest$(objext) \\\n   a-zzboio$(objext) \\\n@@ -882,6 +882,12 @@ TRASYM_DWARF_UNIX_OBJS = $(TRASYM_DWARF_COMMON_OBJS) s-mmauni$(objext)\n TRASYM_DWARF_MINGW_OBJS = $(TRASYM_DWARF_COMMON_OBJS)\n \n GNATRTL_128BIT_PAIRS = \\\n+  a-tiinio.adb<libgnat/a-tiinio__128.adb \\\n+  a-timoio.adb<libgnat/a-timoio__128.adb \\\n+  a-wtinio.adb<libgnat/a-wtinio__128.adb \\\n+  a-wtmoio.adb<libgnat/a-wtmoio__128.adb \\\n+  a-ztinio.adb<libgnat/a-ztinio__128.adb \\\n+  a-ztmoio.adb<libgnat/a-ztmoio__128.adb \\\n   s-scaval.ads<libgnat/s-scaval__128.ads \\\n   s-scaval.adb<libgnat/s-scaval__128.adb\n "}, {"sha": "787d5b7fe3259a2e8d33f44455141e747d5abe93", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -146,6 +146,8 @@ package body Impunit is\n     (\"a-llfwti\", T),  -- Ada.Long_Long_Float_Wide_Text_IO\n     (\"a-llitio\", T),  -- Ada.Long_Long_Integer_Text_IO\n     (\"a-lliwti\", F),  -- Ada.Long_Long_Integer_Wide_Text_IO\n+    (\"a-llltio\", T),  -- Ada.Long_Long_Long_Integer_Text_IO\n+    (\"a-lllwti\", F),  -- Ada.Long_Long_Long_Integer_Wide_Text_IO\n     (\"a-nlcefu\", F),  -- Ada.Long_Complex_Elementary_Functions\n     (\"a-nlcoty\", T),  -- Ada.Numerics.Long_Complex_Types\n     (\"a-nlelfu\", T),  -- Ada.Numerics.Long_Elementary_Functions\n@@ -502,6 +504,7 @@ package body Impunit is\n     (\"a-llctio\", T),  -- Ada.Long_Long_Complex_Text_IO\n     (\"a-llfzti\", T),  -- Ada.Long_Long_Float_Wide_Wide_Text_IO\n     (\"a-llizti\", T),  -- Ada.Long_Long_Integer_Wide_Wide_Text_IO\n+    (\"a-lllzti\", T),  -- Ada.Long_Long_Long_Integer_Wide_Wide_Text_IO\n     (\"a-nlcoar\", T),  -- Ada.Numerics.Long_Complex_Arrays\n     (\"a-nllcar\", T),  -- Ada.Numerics.Long_Long_Complex_Arrays\n     (\"a-nllrar\", T),  -- Ada.Numerics.Long_Long_Real_Arrays"}, {"sha": "c1b4e98df8dd5d76f5d68656e36563edad158237", "filename": "gcc/ada/krunch.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Fkrunch.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Fkrunch.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fkrunch.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -73,6 +73,15 @@ begin\n       Curlen := Len - 17;\n       Krlen := 8;\n \n+   elsif Len >= 27\n+     and then Buffer (1 .. 27) = \"ada-long_long_long_integer_\"\n+   then\n+      Startloc := 3;\n+      Buffer (2 .. Len - 2) := Buffer (4 .. Len);\n+      Buffer (18 .. Len - 10) := Buffer (26 .. Len - 2);\n+      Curlen := Len - 10;\n+      Krlen := 8;\n+\n    elsif Len >= 4 and then Buffer (1 .. 4) = \"ada-\" then\n       Startloc := 3;\n       Buffer (2 .. Len - 2) := Buffer (4 .. Len);"}, {"sha": "3188d818b855064f8faa81a0a4edb3849b8d6482", "filename": "gcc/ada/krunch.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Fkrunch.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Fkrunch.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fkrunch.ads?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -114,6 +114,9 @@\n --  we replace the prefix ada.wide_wide_text_io- by a-zt- and then\n --  the normal crunching rules are applied.\n \n+--  An additional trick is used for Ada.Long_Long_Long_Integer_*_IO, where\n+--  the Integer word is dropped.\n+\n --  The units implementing the support of 128-bit types are crunched to 9 and\n --  System.Compare_Array_* is replaced with System.CA_* before crunching.\n "}, {"sha": "f107d4310c9166ba4a22e3d20c5269dfaadc8d5a", "filename": "gcc/ada/libgnat/a-llltio.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-llltio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-llltio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-llltio.ads?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -0,0 +1,19 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--   A D A . L O N G _ L O N G _ L O N G _ I N T E G E R _ T E X T _ I O    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Text_IO;\n+\n+package Ada.Long_Long_Long_Integer_Text_IO is\n+  new Ada.Text_IO.Integer_IO (Long_Long_Long_Integer);"}, {"sha": "942fac0d83c57313016907523f58cf3b60649b09", "filename": "gcc/ada/libgnat/a-lllwti.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-lllwti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-lllwti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-lllwti.ads?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -0,0 +1,19 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--   A D A . L O N G _ L O N G _ I N T E G E R _ W I D E _ T E X T _ I O    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Text_IO;\n+\n+package Ada.Long_Long_Long_Integer_Wide_Text_IO is\n+  new Ada.Wide_Text_IO.Integer_IO (Long_Long_Long_Integer);"}, {"sha": "40be96535144fbc4ffe49e42825076f74833b23b", "filename": "gcc/ada/libgnat/a-lllzti.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-lllzti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-lllzti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-lllzti.ads?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -0,0 +1,19 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--   A D A . L O N G _ L O N G _ I N T E G E R _ W I D E _ T E X T _ I O    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT.  In accordance with the copyright of that document, you can freely --\n+-- copy and modify this specification,  provided that if you redistribute a --\n+-- modified version,  any changes that you have made are clearly indicated. --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Wide_Text_IO;\n+\n+package Ada.Long_Long_Long_Integer_Wide_Wide_Text_IO is\n+  new Ada.Wide_Wide_Text_IO.Integer_IO (Long_Long_Long_Integer);"}, {"sha": "f1ba60a6839370af906f258d23f301f1d7e10e2f", "filename": "gcc/ada/libgnat/a-tigeau.adb", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-tigeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-tigeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tigeau.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -322,6 +322,60 @@ package body Ada.Text_IO.Generic_Aux is\n       Load_Extended_Digits (File, Buf, Ptr, Junk);\n    end Load_Extended_Digits;\n \n+   ------------------\n+   -- Load_Integer --\n+   ------------------\n+\n+   procedure Load_Integer\n+     (File : File_Type;\n+      Buf  : out String;\n+      Ptr  : in out Natural)\n+   is\n+      Hash_Loc : Natural;\n+      Loaded   : Boolean;\n+\n+   begin\n+      Load_Skip (File);\n+\n+      --  Note: it is a bit strange to allow a minus sign here, but it seems\n+      --  consistent with the general behavior expected by the ACVC tests\n+      --  which is to scan past junk and then signal data error, see ACVC\n+      --  test CE3704F, case (6), which is for signed integer exponents,\n+      --  which seems a similar case.\n+\n+      Load (File, Buf, Ptr, '+', '-');\n+      Load_Digits (File, Buf, Ptr, Loaded);\n+\n+      if Loaded then\n+\n+         --  Deal with based literal. We recognize either the standard '#' or\n+         --  the allowed alternative replacement ':' (see RM J.2(3)).\n+\n+         Load (File, Buf, Ptr, '#', ':', Loaded);\n+\n+         if Loaded then\n+            Hash_Loc := Ptr;\n+            Load_Extended_Digits (File, Buf, Ptr);\n+            Load (File, Buf, Ptr, Buf (Hash_Loc));\n+         end if;\n+\n+         --  Deal with exponent\n+\n+         Load (File, Buf, Ptr, 'E', 'e', Loaded);\n+\n+         if Loaded then\n+\n+            --  Note: it is strange to allow a minus sign, since the syntax\n+            --  does not, but that is what ACVC test CE3704F, case (6) wants\n+            --  for the signed case, and there seems no good reason to treat\n+            --  exponents differently for the signed and unsigned cases.\n+\n+            Load (File, Buf, Ptr, '+', '-');\n+            Load_Digits (File, Buf, Ptr);\n+         end if;\n+      end if;\n+   end Load_Integer;\n+\n    ---------------\n    -- Load_Skip --\n    ---------------"}, {"sha": "09334b371dda26f46e70bb8f8985e2c849da1bdb", "filename": "gcc/ada/libgnat/a-tigeau.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-tigeau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-tigeau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tigeau.ads?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -150,6 +150,12 @@ private package Ada.Text_IO.Generic_Aux is\n       Ptr    : in out Integer);\n    --  Same as above, but no indication if character is loaded\n \n+   procedure Load_Integer\n+     (File : File_Type;\n+      Buf  : out String;\n+      Ptr  : in out Natural);\n+   --  Loads a possibly signed integer literal value\n+\n    function Nextc (File : File_Type) return Integer;\n    --  Like Getc, but includes a call to Ungetc, so that the file\n    --  pointer is not moved by the call."}, {"sha": "a0bb5c6aa24e2337d44508a3fdaa3ea669ddccd2", "filename": "gcc/ada/libgnat/a-tiinau.adb", "status": "modified", "additions": 32, "deletions": 196, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-tiinau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-tiinau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tiinau.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -2,7 +2,7 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---              A D A . T E X T _ I O . I N T E G E R  _ A U X              --\n+--              A D A . T E X T _ I O . I N T E G E R _ A U X               --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n@@ -31,61 +31,15 @@\n \n with Ada.Text_IO.Generic_Aux; use Ada.Text_IO.Generic_Aux;\n \n-with System.Img_BIU;   use System.Img_BIU;\n-with System.Img_Int;   use System.Img_Int;\n-with System.Img_LLB;   use System.Img_LLB;\n-with System.Img_LLI;   use System.Img_LLI;\n-with System.Img_LLW;   use System.Img_LLW;\n-with System.Img_WIU;   use System.Img_WIU;\n-with System.Val_Int;   use System.Val_Int;\n-with System.Val_LLI;   use System.Val_LLI;\n-\n package body Ada.Text_IO.Integer_Aux is\n \n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Load_Integer\n-     (File : File_Type;\n-      Buf  : out String;\n-      Ptr  : in out Natural);\n-   --  This is an auxiliary routine that is used to load a possibly signed\n-   --  integer literal value from the input file into Buf, starting at Ptr + 1.\n-   --  On return, Ptr is set to the last character stored.\n-\n-   -------------\n-   -- Get_Int --\n-   -------------\n-\n-   procedure Get_Int\n-     (File  : File_Type;\n-      Item  : out Integer;\n-      Width : Field)\n-   is\n-      Buf  : String (1 .. Field'Last);\n-      Ptr  : aliased Integer := 1;\n-      Stop : Integer := 0;\n-\n-   begin\n-      if Width /= 0 then\n-         Load_Width (File, Width, Buf, Stop);\n-         String_Skip (Buf, Ptr);\n-      else\n-         Load_Integer (File, Buf, Stop);\n-      end if;\n-\n-      Item := Scan_Integer (Buf, Ptr'Access, Stop);\n-      Check_End_Of_Field (Buf, Stop, Ptr, Width);\n-   end Get_Int;\n+   ---------\n+   -- Get --\n+   ---------\n \n-   -------------\n-   -- Get_LLI --\n-   -------------\n-\n-   procedure Get_LLI\n+   procedure Get\n      (File  : File_Type;\n-      Item  : out Long_Long_Integer;\n+      Item  : out Num;\n       Width : Field)\n    is\n       Buf  : String (1 .. Field'Last);\n@@ -100,130 +54,38 @@ package body Ada.Text_IO.Integer_Aux is\n          Load_Integer (File, Buf, Stop);\n       end if;\n \n-      Item := Scan_Long_Long_Integer (Buf, Ptr'Access, Stop);\n+      Item := Scan (Buf, Ptr'Access, Stop);\n       Check_End_Of_Field (Buf, Stop, Ptr, Width);\n-   end Get_LLI;\n+   end Get;\n \n-   --------------\n-   -- Gets_Int --\n-   --------------\n+   ----------\n+   -- Gets --\n+   ----------\n \n-   procedure Gets_Int\n+   procedure Gets\n      (From : String;\n-      Item : out Integer;\n+      Item : out Num;\n       Last : out Positive)\n    is\n       Pos : aliased Integer;\n \n    begin\n       String_Skip (From, Pos);\n-      Item := Scan_Integer (From, Pos'Access, From'Last);\n+      Item := Scan (From, Pos'Access, From'Last);\n       Last := Pos - 1;\n \n    exception\n       when Constraint_Error =>\n          raise Data_Error;\n-   end Gets_Int;\n-\n-   --------------\n-   -- Gets_LLI --\n-   --------------\n-\n-   procedure Gets_LLI\n-     (From : String;\n-      Item : out Long_Long_Integer;\n-      Last : out Positive)\n-   is\n-      Pos : aliased Integer;\n-\n-   begin\n-      String_Skip (From, Pos);\n-      Item := Scan_Long_Long_Integer (From, Pos'Access, From'Last);\n-      Last := Pos - 1;\n-\n-   exception\n-      when Constraint_Error =>\n-         raise Data_Error;\n-   end Gets_LLI;\n-\n-   ------------------\n-   -- Load_Integer --\n-   ------------------\n-\n-   procedure Load_Integer\n-     (File : File_Type;\n-      Buf  : out String;\n-      Ptr  : in out Natural)\n-   is\n-      Hash_Loc : Natural;\n-      Loaded   : Boolean;\n-\n-   begin\n-      Load_Skip (File);\n-      Load (File, Buf, Ptr, '+', '-');\n-\n-      Load_Digits (File, Buf, Ptr, Loaded);\n-\n-      if Loaded then\n-\n-         --  Deal with based literal. We recognize either the standard '#' or\n-         --  the allowed alternative replacement ':' (see RM J.2(3)).\n+   end Gets;\n \n-         Load (File, Buf, Ptr, '#', ':', Loaded);\n+   ---------\n+   -- Put --\n+   ---------\n \n-         if Loaded then\n-            Hash_Loc := Ptr;\n-            Load_Extended_Digits (File, Buf, Ptr);\n-            Load (File, Buf, Ptr, Buf (Hash_Loc));\n-         end if;\n-\n-         --  Deal with exponent\n-\n-         Load (File, Buf, Ptr, 'E', 'e', Loaded);\n-\n-         if Loaded then\n-\n-            --  Note: it is strange to allow a minus sign, since the syntax\n-            --  does not, but that is what ACVC test CE3704F, case (6) wants.\n-\n-            Load (File, Buf, Ptr, '+', '-');\n-            Load_Digits (File, Buf, Ptr);\n-         end if;\n-      end if;\n-   end Load_Integer;\n-\n-   -------------\n-   -- Put_Int --\n-   -------------\n-\n-   procedure Put_Int\n-     (File  : File_Type;\n-      Item  : Integer;\n-      Width : Field;\n-      Base  : Number_Base)\n-   is\n-      Buf : String (1 .. Integer'Max (Field'Last, Width));\n-      Ptr : Natural := 0;\n-\n-   begin\n-      if Base = 10 and then Width = 0 then\n-         Set_Image_Integer (Item, Buf, Ptr);\n-      elsif Base = 10 then\n-         Set_Image_Width_Integer (Item, Width, Buf, Ptr);\n-      else\n-         Set_Image_Based_Integer (Item, Base, Width, Buf, Ptr);\n-      end if;\n-\n-      Put_Item (File, Buf (1 .. Ptr));\n-   end Put_Int;\n-\n-   -------------\n-   -- Put_LLI --\n-   -------------\n-\n-   procedure Put_LLI\n+   procedure Put\n      (File  : File_Type;\n-      Item  : Long_Long_Integer;\n+      Item  : Num;\n       Width : Field;\n       Base  : Number_Base)\n    is\n@@ -232,66 +94,40 @@ package body Ada.Text_IO.Integer_Aux is\n \n    begin\n       if Base = 10 and then Width = 0 then\n-         Set_Image_Long_Long_Integer (Item, Buf, Ptr);\n+         Set_Image (Item, Buf, Ptr);\n       elsif Base = 10 then\n-         Set_Image_Width_Long_Long_Integer (Item, Width, Buf, Ptr);\n+         Set_Image_Width (Item, Width, Buf, Ptr);\n       else\n-         Set_Image_Based_Long_Long_Integer (Item, Base, Width, Buf, Ptr);\n+         Set_Image_Based (Item, Base, Width, Buf, Ptr);\n       end if;\n \n       Put_Item (File, Buf (1 .. Ptr));\n-   end Put_LLI;\n-\n-   --------------\n-   -- Puts_Int --\n-   --------------\n-\n-   procedure Puts_Int\n-     (To   : out String;\n-      Item : Integer;\n-      Base : Number_Base)\n-   is\n-      Buf : String (1 .. Integer'Max (Field'Last, To'Length));\n-      Ptr : Natural := 0;\n-\n-   begin\n-      if Base = 10 then\n-         Set_Image_Width_Integer (Item, To'Length, Buf, Ptr);\n-      else\n-         Set_Image_Based_Integer (Item, Base, To'Length, Buf, Ptr);\n-      end if;\n-\n-      if Ptr > To'Length then\n-         raise Layout_Error;\n-      else\n-         To (To'First .. To'First + Ptr - 1) := Buf (1 .. Ptr);\n-      end if;\n-   end Puts_Int;\n+   end Put;\n \n-   --------------\n-   -- Puts_LLI --\n-   --------------\n+   ----------\n+   -- Puts --\n+   ----------\n \n-   procedure Puts_LLI\n+   procedure Puts\n      (To   : out String;\n-      Item : Long_Long_Integer;\n+      Item : Num;\n       Base : Number_Base)\n    is\n       Buf : String (1 .. Integer'Max (Field'Last, To'Length));\n       Ptr : Natural := 0;\n \n    begin\n       if Base = 10 then\n-         Set_Image_Width_Long_Long_Integer (Item, To'Length, Buf, Ptr);\n+         Set_Image_Width (Item, To'Length, Buf, Ptr);\n       else\n-         Set_Image_Based_Long_Long_Integer (Item, Base, To'Length, Buf, Ptr);\n+         Set_Image_Based (Item, Base, To'Length, Buf, Ptr);\n       end if;\n \n       if Ptr > To'Length then\n          raise Layout_Error;\n       else\n          To (To'First .. To'First + Ptr - 1) := Buf (1 .. Ptr);\n       end if;\n-   end Puts_LLI;\n+   end Puts;\n \n end Ada.Text_IO.Integer_Aux;"}, {"sha": "e1492211ea29c7c50d6a6d309ad4a4afcbc19600", "filename": "gcc/ada/libgnat/a-tiinau.ads", "status": "modified", "additions": 27, "deletions": 37, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-tiinau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-tiinau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tiinau.ads?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -29,55 +29,45 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the routines for Ada.Text_IO.Integer_IO that are\n---  shared among separate instantiations of this package. The routines in\n---  this package are identical semantically to those in Integer_IO itself,\n---  except that the generic parameter Num has been replaced by Integer or\n---  Long_Long_Integer, and the default parameters have been removed because\n---  they are supplied explicitly by the calls from within the generic template.\n+--  This package contains the implementation for Ada.Text_IO.Integer_IO and\n+--  Ada.Text_IO.Modular_IO. The routines in this package are identical\n+--  semantically to those in Integer_IO and Modular_IO themselves, except that\n+--  the default parameters have been removed because they are supplied\n+--  explicitly by the calls from within these units.\n \n-private package Ada.Text_IO.Integer_Aux is\n+private generic\n+   type Num is (<>);\n \n-   procedure Get_Int\n-     (File  : File_Type;\n-      Item  : out Integer;\n-      Width : Field);\n+   with function Scan\n+     (Str : String; Ptr : not null access Integer; Max : Integer) return Num;\n+   with procedure Set_Image\n+     (V : Num; S : in out String; P : in out Natural);\n+   with procedure Set_Image_Width\n+     (V : Num; W : Integer; S : out String; P : in out Natural);\n+   with procedure Set_Image_Based\n+     (V : Num; B : Natural; W : Integer; S : out String; P : in out Natural);\n+\n+package Ada.Text_IO.Integer_Aux is\n \n-   procedure Get_LLI\n+   procedure Get\n      (File  : File_Type;\n-      Item  : out Long_Long_Integer;\n+      Item  : out Num;\n       Width : Field);\n \n-   procedure Put_Int\n-     (File  : File_Type;\n-      Item  : Integer;\n-      Width : Field;\n-      Base  : Number_Base);\n+   procedure Gets\n+     (From : String;\n+      Item : out Num;\n+      Last : out Positive);\n \n-   procedure Put_LLI\n+   procedure Put\n      (File  : File_Type;\n-      Item  : Long_Long_Integer;\n+      Item  : Num;\n       Width : Field;\n       Base  : Number_Base);\n \n-   procedure Gets_Int\n-     (From : String;\n-      Item : out Integer;\n-      Last : out Positive);\n-\n-   procedure Gets_LLI\n-     (From : String;\n-      Item : out Long_Long_Integer;\n-      Last : out Positive);\n-\n-   procedure Puts_Int\n-     (To   : out String;\n-      Item : Integer;\n-      Base : Number_Base);\n-\n-   procedure Puts_LLI\n+   procedure Puts\n      (To   : out String;\n-      Item : Long_Long_Integer;\n+      Item : Num;\n       Base : Number_Base);\n \n end Ada.Text_IO.Integer_Aux;"}, {"sha": "4133bec67877dd6f30995b67324d8f734f1abe68", "filename": "gcc/ada/libgnat/a-tiinio.adb", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-tiinio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-tiinio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tiinio.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -30,10 +30,32 @@\n ------------------------------------------------------------------------------\n \n with Ada.Text_IO.Integer_Aux;\n+with System.Img_BIU; use System.Img_BIU;\n+with System.Img_Int; use System.Img_Int;\n+with System.Img_LLB; use System.Img_LLB;\n+with System.Img_LLI; use System.Img_LLI;\n+with System.Img_LLW; use System.Img_LLW;\n+with System.Img_WIU; use System.Img_WIU;\n+with System.Val_Int; use System.Val_Int;\n+with System.Val_LLI; use System.Val_LLI;\n \n package body Ada.Text_IO.Integer_IO is\n \n-   package Aux renames Ada.Text_IO.Integer_Aux;\n+   package Aux_Int is new\n+     Ada.Text_IO.Integer_Aux\n+       (Integer,\n+        Scan_Integer,\n+        Set_Image_Integer,\n+        Set_Image_Width_Integer,\n+        Set_Image_Based_Integer);\n+\n+   package Aux_LLI is new\n+     Ada.Text_IO.Integer_Aux\n+       (Long_Long_Integer,\n+        Scan_Long_Long_Integer,\n+        Set_Image_Long_Long_Integer,\n+        Set_Image_Width_Long_Long_Integer,\n+        Set_Image_Based_Long_Long_Integer);\n \n    Need_LLI : constant Boolean := Num'Base'Size > Integer'Size;\n    --  Throughout this generic body, we distinguish between the case where type\n@@ -57,9 +79,9 @@ package body Ada.Text_IO.Integer_IO is\n \n    begin\n       if Need_LLI then\n-         Aux.Get_LLI (File, Long_Long_Integer (Item), Width);\n+         Aux_LLI.Get (File, Long_Long_Integer (Item), Width);\n       else\n-         Aux.Get_Int (File, Integer (Item), Width);\n+         Aux_Int.Get (File, Integer (Item), Width);\n       end if;\n \n    exception\n@@ -70,20 +92,8 @@ package body Ada.Text_IO.Integer_IO is\n      (Item  : out Num;\n       Width : Field := 0)\n    is\n-      --  We depend on a range check to get Data_Error\n-\n-      pragma Unsuppress (Range_Check);\n-      pragma Unsuppress (Overflow_Check);\n-\n    begin\n-      if Need_LLI then\n-         Aux.Get_LLI (Current_In, Long_Long_Integer (Item), Width);\n-      else\n-         Aux.Get_Int (Current_In, Integer (Item), Width);\n-      end if;\n-\n-   exception\n-      when Constraint_Error => raise Data_Error;\n+      Get (Current_In, Item, Width);\n    end Get;\n \n    procedure Get\n@@ -98,9 +108,9 @@ package body Ada.Text_IO.Integer_IO is\n \n    begin\n       if Need_LLI then\n-         Aux.Gets_LLI (From, Long_Long_Integer (Item), Last);\n+         Aux_LLI.Gets (From, Long_Long_Integer (Item), Last);\n       else\n-         Aux.Gets_Int (From, Integer (Item), Last);\n+         Aux_Int.Gets (From, Integer (Item), Last);\n       end if;\n \n    exception\n@@ -119,9 +129,9 @@ package body Ada.Text_IO.Integer_IO is\n    is\n    begin\n       if Need_LLI then\n-         Aux.Put_LLI (File, Long_Long_Integer (Item), Width, Base);\n+         Aux_LLI.Put (File, Long_Long_Integer (Item), Width, Base);\n       else\n-         Aux.Put_Int (File, Integer (Item), Width, Base);\n+         Aux_Int.Put (File, Integer (Item), Width, Base);\n       end if;\n    end Put;\n \n@@ -131,11 +141,7 @@ package body Ada.Text_IO.Integer_IO is\n       Base  : Number_Base := Default_Base)\n    is\n    begin\n-      if Need_LLI then\n-         Aux.Put_LLI (Current_Out, Long_Long_Integer (Item), Width, Base);\n-      else\n-         Aux.Put_Int (Current_Out, Integer (Item), Width, Base);\n-      end if;\n+      Put (Current_Out, Item, Width, Base);\n    end Put;\n \n    procedure Put\n@@ -145,9 +151,9 @@ package body Ada.Text_IO.Integer_IO is\n    is\n    begin\n       if Need_LLI then\n-         Aux.Puts_LLI (To, Long_Long_Integer (Item), Base);\n+         Aux_LLI.Puts (To, Long_Long_Integer (Item), Base);\n       else\n-         Aux.Puts_Int (To, Integer (Item), Base);\n+         Aux_Int.Puts (To, Integer (Item), Base);\n       end if;\n    end Put;\n "}, {"sha": "e82b447804cd45aef92b4a48f1bb6f8b5e1f8401", "filename": "gcc/ada/libgnat/a-tiinio__128.adb", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-tiinio__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-tiinio__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tiinio__128.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -0,0 +1,182 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--               A D A . T E X T _ I O . I N T E G E R _ I O                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Text_IO.Integer_Aux;\n+with System.Img_BIU;  use System.Img_BIU;\n+with System.Img_Int;  use System.Img_Int;\n+with System.Img_LLB;  use System.Img_LLB;\n+with System.Img_LLI;  use System.Img_LLI;\n+with System.Img_LLW;  use System.Img_LLW;\n+with System.Img_LLLB; use System.Img_LLLB;\n+with System.Img_LLLI; use System.Img_LLLI;\n+with System.Img_LLLW; use System.Img_LLLW;\n+with System.Img_WIU;  use System.Img_WIU;\n+with System.Val_Int;  use System.Val_Int;\n+with System.Val_LLI;  use System.Val_LLI;\n+with System.Val_LLLI; use System.Val_LLLI;\n+\n+package body Ada.Text_IO.Integer_IO is\n+\n+   package Aux_Int is new\n+     Ada.Text_IO.Integer_Aux\n+       (Integer,\n+        Scan_Integer,\n+        Set_Image_Integer,\n+        Set_Image_Width_Integer,\n+        Set_Image_Based_Integer);\n+\n+   package Aux_LLI is new\n+     Ada.Text_IO.Integer_Aux\n+       (Long_Long_Integer,\n+        Scan_Long_Long_Integer,\n+        Set_Image_Long_Long_Integer,\n+        Set_Image_Width_Long_Long_Integer,\n+        Set_Image_Based_Long_Long_Integer);\n+\n+   package Aux_LLLI is new\n+     Ada.Text_IO.Integer_Aux\n+       (Long_Long_Long_Integer,\n+        Scan_Long_Long_Long_Integer,\n+        Set_Image_Long_Long_Long_Integer,\n+        Set_Image_Width_Long_Long_Long_Integer,\n+        Set_Image_Based_Long_Long_Long_Integer);\n+\n+   Need_LLI  : constant Boolean := Num'Base'Size > Integer'Size;\n+   Need_LLLI : constant Boolean := Num'Base'Size > Long_Long_Integer'Size;\n+   --  Throughout this generic body, we distinguish between cases where type\n+   --  Integer is acceptable, where type Long_Long_Integer is acceptable and\n+   --  where type Long_Long_Long_Integer is needed. These boolean constants\n+   --  are used to test for these cases and since they are constant, only code\n+   --  for the relevant case will be included in the instance.\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   procedure Get\n+     (File  : File_Type;\n+      Item  : out Num;\n+      Width : Field := 0)\n+   is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+      pragma Unsuppress (Overflow_Check);\n+\n+   begin\n+      if Need_LLLI then\n+         Aux_LLLI.Get (File, Long_Long_Long_Integer (Item), Width);\n+      elsif Need_LLI then\n+         Aux_LLI.Get (File, Long_Long_Integer (Item), Width);\n+      else\n+         Aux_Int.Get (File, Integer (Item), Width);\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   procedure Get\n+     (Item  : out Num;\n+      Width : Field := 0)\n+   is\n+   begin\n+      Get (Current_In, Item, Width);\n+   end Get;\n+\n+   procedure Get\n+     (From : String;\n+      Item : out Num;\n+      Last : out Positive)\n+   is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+      pragma Unsuppress (Overflow_Check);\n+\n+   begin\n+      if Need_LLLI then\n+         Aux_LLLI.Gets (From, Long_Long_Long_Integer (Item), Last);\n+      elsif Need_LLI then\n+         Aux_LLI.Gets (From, Long_Long_Integer (Item), Last);\n+      else\n+         Aux_Int.Gets (From, Integer (Item), Last);\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (File  : File_Type;\n+      Item  : Num;\n+      Width : Field := Default_Width;\n+      Base  : Number_Base := Default_Base)\n+   is\n+   begin\n+      if Need_LLLI then\n+         Aux_LLLI.Put (File, Long_Long_Long_Integer (Item), Width, Base);\n+      elsif Need_LLI then\n+         Aux_LLI.Put (File, Long_Long_Integer (Item), Width, Base);\n+      else\n+         Aux_Int.Put (File, Integer (Item), Width, Base);\n+      end if;\n+   end Put;\n+\n+   procedure Put\n+     (Item  : Num;\n+      Width : Field := Default_Width;\n+      Base  : Number_Base := Default_Base)\n+   is\n+   begin\n+      Put (Current_Out, Item, Width, Base);\n+   end Put;\n+\n+   procedure Put\n+     (To   : out String;\n+      Item : Num;\n+      Base : Number_Base := Default_Base)\n+   is\n+   begin\n+      if Need_LLLI then\n+         Aux_LLLI.Puts (To, Long_Long_Long_Integer (Item), Base);\n+      elsif Need_LLI then\n+         Aux_LLI.Puts (To, Long_Long_Integer (Item), Base);\n+      else\n+         Aux_Int.Puts (To, Integer (Item), Base);\n+      end if;\n+   end Put;\n+\n+end Ada.Text_IO.Integer_IO;"}, {"sha": "050b9c88fb6653911b63e650d599743550882b04", "filename": "gcc/ada/libgnat/a-timoau.adb", "status": "removed", "additions": 0, "deletions": 305, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd2e6f249e55c810c0414572807face97d88f07/gcc%2Fada%2Flibgnat%2Fa-timoau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd2e6f249e55c810c0414572807face97d88f07/gcc%2Fada%2Flibgnat%2Fa-timoau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-timoau.adb?ref=4cd2e6f249e55c810c0414572807face97d88f07", "patch": "@@ -1,305 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---              A D A . T E X T _ I O . M O D U L A R  _ A U X              --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Text_IO.Generic_Aux; use Ada.Text_IO.Generic_Aux;\n-\n-with System.Img_BIU; use System.Img_BIU;\n-with System.Img_Uns; use System.Img_Uns;\n-with System.Img_LLB; use System.Img_LLB;\n-with System.Img_LLU; use System.Img_LLU;\n-with System.Img_LLW; use System.Img_LLW;\n-with System.Img_WIU; use System.Img_WIU;\n-with System.Val_Uns; use System.Val_Uns;\n-with System.Val_LLU; use System.Val_LLU;\n-\n-package body Ada.Text_IO.Modular_Aux is\n-\n-   use System.Unsigned_Types;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Load_Modular\n-     (File : File_Type;\n-      Buf  : out String;\n-      Ptr  : in out Natural);\n-   --  This is an auxiliary routine that is used to load an possibly signed\n-   --  modular literal value from the input file into Buf, starting at Ptr + 1.\n-   --  Ptr is left set to the last character stored.\n-\n-   -------------\n-   -- Get_LLU --\n-   -------------\n-\n-   procedure Get_LLU\n-     (File  : File_Type;\n-      Item  : out Long_Long_Unsigned;\n-      Width : Field)\n-   is\n-      Buf  : String (1 .. Field'Last);\n-      Stop : Integer := 0;\n-      Ptr  : aliased Integer := 1;\n-\n-   begin\n-      if Width /= 0 then\n-         Load_Width (File, Width, Buf, Stop);\n-         String_Skip (Buf, Ptr);\n-      else\n-         Load_Modular (File, Buf, Stop);\n-      end if;\n-\n-      Item := Scan_Long_Long_Unsigned (Buf, Ptr'Access, Stop);\n-      Check_End_Of_Field (Buf, Stop, Ptr, Width);\n-   end Get_LLU;\n-\n-   -------------\n-   -- Get_Uns --\n-   -------------\n-\n-   procedure Get_Uns\n-     (File  : File_Type;\n-      Item  : out Unsigned;\n-      Width : Field)\n-   is\n-      Buf  : String (1 .. Field'Last);\n-      Stop : Integer := 0;\n-      Ptr  : aliased Integer := 1;\n-\n-   begin\n-      if Width /= 0 then\n-         Load_Width (File, Width, Buf, Stop);\n-         String_Skip (Buf, Ptr);\n-      else\n-         Load_Modular (File, Buf, Stop);\n-      end if;\n-\n-      Item := Scan_Unsigned (Buf, Ptr'Access, Stop);\n-      Check_End_Of_Field (Buf, Stop, Ptr, Width);\n-   end Get_Uns;\n-\n-   --------------\n-   -- Gets_LLU --\n-   --------------\n-\n-   procedure Gets_LLU\n-     (From : String;\n-      Item : out Long_Long_Unsigned;\n-      Last : out Positive)\n-   is\n-      Pos : aliased Integer;\n-\n-   begin\n-      String_Skip (From, Pos);\n-      Item := Scan_Long_Long_Unsigned (From, Pos'Access, From'Last);\n-      Last := Pos - 1;\n-\n-   exception\n-      when Constraint_Error =>\n-         raise Data_Error;\n-   end Gets_LLU;\n-\n-   --------------\n-   -- Gets_Uns --\n-   --------------\n-\n-   procedure Gets_Uns\n-     (From : String;\n-      Item : out Unsigned;\n-      Last : out Positive)\n-   is\n-      Pos : aliased Integer;\n-\n-   begin\n-      String_Skip (From, Pos);\n-      Item := Scan_Unsigned (From, Pos'Access, From'Last);\n-      Last := Pos - 1;\n-\n-   exception\n-      when Constraint_Error =>\n-         raise Data_Error;\n-   end Gets_Uns;\n-\n-   ------------------\n-   -- Load_Modular --\n-   ------------------\n-\n-   procedure Load_Modular\n-     (File : File_Type;\n-      Buf  : out String;\n-      Ptr  : in out Natural)\n-   is\n-      Hash_Loc : Natural;\n-      Loaded   : Boolean;\n-\n-   begin\n-      Load_Skip (File);\n-\n-      --  Note: it is a bit strange to allow a minus sign here, but it seems\n-      --  consistent with the general behavior expected by the ACVC tests\n-      --  which is to scan past junk and then signal data error, see ACVC\n-      --  test CE3704F, case (6), which is for signed integer exponents,\n-      --  which seems a similar case.\n-\n-      Load (File, Buf, Ptr, '+', '-');\n-      Load_Digits (File, Buf, Ptr, Loaded);\n-\n-      if Loaded then\n-\n-         --  Deal with based case. We recognize either the standard '#' or the\n-         --  allowed alternative replacement ':' (see RM J.2(3)).\n-\n-         Load (File, Buf, Ptr, '#', ':', Loaded);\n-\n-         if Loaded then\n-            Hash_Loc := Ptr;\n-            Load_Extended_Digits (File, Buf, Ptr);\n-            Load (File, Buf, Ptr, Buf (Hash_Loc));\n-         end if;\n-\n-         Load (File, Buf, Ptr, 'E', 'e', Loaded);\n-\n-         if Loaded then\n-\n-            --  Note: it is strange to allow a minus sign, since the syntax\n-            --  does not, but that is what ACVC test CE3704F, case (6) wants\n-            --  for the signed case, and there seems no good reason to treat\n-            --  exponents differently for the signed and unsigned cases.\n-\n-            Load (File, Buf, Ptr, '+', '-');\n-            Load_Digits (File, Buf, Ptr);\n-         end if;\n-      end if;\n-   end Load_Modular;\n-\n-   -------------\n-   -- Put_LLU --\n-   -------------\n-\n-   procedure Put_LLU\n-     (File  : File_Type;\n-      Item  : Long_Long_Unsigned;\n-      Width : Field;\n-      Base  : Number_Base)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      if Base = 10 and then Width = 0 then\n-         Set_Image_Long_Long_Unsigned (Item, Buf, Ptr);\n-      elsif Base = 10 then\n-         Set_Image_Width_Long_Long_Unsigned (Item, Width, Buf, Ptr);\n-      else\n-         Set_Image_Based_Long_Long_Unsigned (Item, Base, Width, Buf, Ptr);\n-      end if;\n-\n-      Put_Item (File, Buf (1 .. Ptr));\n-   end Put_LLU;\n-\n-   -------------\n-   -- Put_Uns --\n-   -------------\n-\n-   procedure Put_Uns\n-     (File  : File_Type;\n-      Item  : Unsigned;\n-      Width : Field;\n-      Base  : Number_Base)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      if Base = 10 and then Width = 0 then\n-         Set_Image_Unsigned (Item, Buf, Ptr);\n-      elsif Base = 10 then\n-         Set_Image_Width_Unsigned (Item, Width, Buf, Ptr);\n-      else\n-         Set_Image_Based_Unsigned (Item, Base, Width, Buf, Ptr);\n-      end if;\n-\n-      Put_Item (File, Buf (1 .. Ptr));\n-   end Put_Uns;\n-\n-   --------------\n-   -- Puts_LLU --\n-   --------------\n-\n-   procedure Puts_LLU\n-     (To   : out String;\n-      Item : Long_Long_Unsigned;\n-      Base : Number_Base)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      if Base = 10 then\n-         Set_Image_Width_Long_Long_Unsigned (Item, To'Length, Buf, Ptr);\n-      else\n-         Set_Image_Based_Long_Long_Unsigned (Item, Base, To'Length, Buf, Ptr);\n-      end if;\n-\n-      if Ptr > To'Length then\n-         raise Layout_Error;\n-      else\n-         To (To'First .. To'First + Ptr - 1) := Buf (1 .. Ptr);\n-      end if;\n-   end Puts_LLU;\n-\n-   --------------\n-   -- Puts_Uns --\n-   --------------\n-\n-   procedure Puts_Uns\n-     (To   : out String;\n-      Item : Unsigned;\n-      Base : Number_Base)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      if Base = 10 then\n-         Set_Image_Width_Unsigned (Item, To'Length, Buf, Ptr);\n-      else\n-         Set_Image_Based_Unsigned (Item, Base, To'Length, Buf, Ptr);\n-      end if;\n-\n-      if Ptr > To'Length then\n-         raise Layout_Error;\n-      else\n-         To (To'First .. To'First + Ptr - 1) := Buf (1 .. Ptr);\n-      end if;\n-   end Puts_Uns;\n-\n-end Ada.Text_IO.Modular_Aux;"}, {"sha": "247eb146b18f137c6dd60e7c81e2d8609c52e629", "filename": "gcc/ada/libgnat/a-timoau.ads", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd2e6f249e55c810c0414572807face97d88f07/gcc%2Fada%2Flibgnat%2Fa-timoau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd2e6f249e55c810c0414572807face97d88f07/gcc%2Fada%2Flibgnat%2Fa-timoau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-timoau.ads?ref=4cd2e6f249e55c810c0414572807face97d88f07", "patch": "@@ -1,87 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---              A D A . T E X T _ I O . M O D U L A R _ A U X               --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains the routines for Ada.Text_IO.Modular_IO that are\n---  shared among separate instantiations of this package. The routines in\n---  this package are identical semantically to those in Modular_IO itself,\n---  except that the generic parameter Num has been replaced by Unsigned or\n---  Long_Long_Unsigned, and the default parameters have been removed because\n---  they are supplied explicitly by the calls from within the generic template.\n-\n-with System.Unsigned_Types;\n-\n-private package Ada.Text_IO.Modular_Aux is\n-\n-   package U renames System.Unsigned_Types;\n-\n-   procedure Get_Uns\n-     (File  : File_Type;\n-      Item  : out U.Unsigned;\n-      Width : Field);\n-\n-   procedure Get_LLU\n-     (File  : File_Type;\n-      Item  : out U.Long_Long_Unsigned;\n-      Width : Field);\n-\n-   procedure Put_Uns\n-     (File  : File_Type;\n-      Item  : U.Unsigned;\n-      Width : Field;\n-      Base  : Number_Base);\n-\n-   procedure Put_LLU\n-     (File  : File_Type;\n-      Item  : U.Long_Long_Unsigned;\n-      Width : Field;\n-      Base  : Number_Base);\n-\n-   procedure Gets_Uns\n-     (From : String;\n-      Item : out U.Unsigned;\n-      Last : out Positive);\n-\n-   procedure Gets_LLU\n-     (From : String;\n-      Item : out U.Long_Long_Unsigned;\n-      Last : out Positive);\n-\n-   procedure Puts_Uns\n-     (To   : out String;\n-      Item : U.Unsigned;\n-      Base : Number_Base);\n-\n-   procedure Puts_LLU\n-     (To   : out String;\n-      Item : U.Long_Long_Unsigned;\n-      Base : Number_Base);\n-\n-end Ada.Text_IO.Modular_Aux;"}, {"sha": "83dbafa742a22d6d0429b0fb987590dcddba8ae6", "filename": "gcc/ada/libgnat/a-timoio.adb", "status": "modified", "additions": 48, "deletions": 31, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-timoio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-timoio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-timoio.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -29,13 +29,39 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Text_IO.Modular_Aux;\n-\n-with System.Unsigned_Types; use System.Unsigned_Types;\n+with Ada.Text_IO.Integer_Aux;\n+with System.Img_BIU; use System.Img_BIU;\n+with System.Img_Uns; use System.Img_Uns;\n+with System.Img_LLB; use System.Img_LLB;\n+with System.Img_LLU; use System.Img_LLU;\n+with System.Img_LLW; use System.Img_LLW;\n+with System.Img_WIU; use System.Img_WIU;\n+with System.Val_Uns; use System.Val_Uns;\n+with System.Val_LLU; use System.Val_LLU;\n \n package body Ada.Text_IO.Modular_IO is\n \n-   package Aux renames Ada.Text_IO.Modular_Aux;\n+   package Aux_Uns is new\n+     Ada.Text_IO.Integer_Aux\n+       (Unsigned,\n+        Scan_Unsigned,\n+        Set_Image_Unsigned,\n+        Set_Image_Width_Unsigned,\n+        Set_Image_Based_Unsigned);\n+\n+   package Aux_LLU is new\n+     Ada.Text_IO.Integer_Aux\n+       (Long_Long_Unsigned,\n+        Scan_Long_Long_Unsigned,\n+        Set_Image_Long_Long_Unsigned,\n+        Set_Image_Width_Long_Long_Unsigned,\n+        Set_Image_Based_Long_Long_Unsigned);\n+\n+   Need_LLU : constant Boolean := Num'Base'Size > Unsigned'Size;\n+   --  Throughout this generic body, we distinguish between the case where type\n+   --  Unsigned is acceptable, and where a Long_Long_Unsigned is needed. This\n+   --  Boolean is used to test for these cases and since it is a constant, only\n+   --  code for the relevant case will be included in the instance.\n \n    ---------\n    -- Get --\n@@ -46,13 +72,15 @@ package body Ada.Text_IO.Modular_IO is\n       Item  : out Num;\n       Width : Field := 0)\n    is\n+      --  We depend on a range check to get Data_Error\n+\n       pragma Unsuppress (Range_Check);\n \n    begin\n-      if Num'Size > Unsigned'Size then\n-         Aux.Get_LLU (File, Long_Long_Unsigned (Item), Width);\n+      if Need_LLU then\n+         Aux_LLU.Get (File, Long_Long_Unsigned (Item), Width);\n       else\n-         Aux.Get_Uns (File, Unsigned (Item), Width);\n+         Aux_Uns.Get (File, Unsigned (Item), Width);\n       end if;\n \n    exception\n@@ -63,31 +91,24 @@ package body Ada.Text_IO.Modular_IO is\n      (Item  : out Num;\n       Width : Field := 0)\n    is\n-      pragma Unsuppress (Range_Check);\n-\n    begin\n-      if Num'Size > Unsigned'Size then\n-         Aux.Get_LLU (Current_In, Long_Long_Unsigned (Item), Width);\n-      else\n-         Aux.Get_Uns (Current_In, Unsigned (Item), Width);\n-      end if;\n-\n-   exception\n-      when Constraint_Error => raise Data_Error;\n+      Get (Current_In, Item, Width);\n    end Get;\n \n    procedure Get\n      (From : String;\n       Item : out Num;\n       Last : out Positive)\n    is\n+      --  We depend on a range check to get Data_Error\n+\n       pragma Unsuppress (Range_Check);\n \n    begin\n-      if Num'Size > Unsigned'Size then\n-         Aux.Gets_LLU (From, Long_Long_Unsigned (Item), Last);\n+      if Need_LLU then\n+         Aux_LLU.Gets (From, Long_Long_Unsigned (Item), Last);\n       else\n-         Aux.Gets_Uns (From, Unsigned (Item), Last);\n+         Aux_Uns.Gets (From, Unsigned (Item), Last);\n       end if;\n \n    exception\n@@ -105,10 +126,10 @@ package body Ada.Text_IO.Modular_IO is\n       Base  : Number_Base := Default_Base)\n    is\n    begin\n-      if Num'Size > Unsigned'Size then\n-         Aux.Put_LLU (File, Long_Long_Unsigned (Item), Width, Base);\n+      if Need_LLU then\n+         Aux_LLU.Put (File, Long_Long_Unsigned (Item), Width, Base);\n       else\n-         Aux.Put_Uns (File, Unsigned (Item), Width, Base);\n+         Aux_Uns.Put (File, Unsigned (Item), Width, Base);\n       end if;\n    end Put;\n \n@@ -118,11 +139,7 @@ package body Ada.Text_IO.Modular_IO is\n       Base  : Number_Base := Default_Base)\n    is\n    begin\n-      if Num'Size > Unsigned'Size then\n-         Aux.Put_LLU (Current_Out, Long_Long_Unsigned (Item), Width, Base);\n-      else\n-         Aux.Put_Uns (Current_Out, Unsigned (Item), Width, Base);\n-      end if;\n+      Put (Current_Out, Item, Width, Base);\n    end Put;\n \n    procedure Put\n@@ -131,10 +148,10 @@ package body Ada.Text_IO.Modular_IO is\n       Base : Number_Base := Default_Base)\n    is\n    begin\n-      if Num'Size > Unsigned'Size then\n-         Aux.Puts_LLU (To, Long_Long_Unsigned (Item), Base);\n+      if Need_LLU then\n+         Aux_LLU.Puts (To, Long_Long_Unsigned (Item), Base);\n       else\n-         Aux.Puts_Uns (To, Unsigned (Item), Base);\n+         Aux_Uns.Puts (To, Unsigned (Item), Base);\n       end if;\n    end Put;\n "}, {"sha": "45856e23dd73db6052bbb006d2eec5ea956373c4", "filename": "gcc/ada/libgnat/a-timoio__128.adb", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-timoio__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-timoio__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-timoio__128.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -0,0 +1,180 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--               A D A . T E X T _ I O . M O D U L A R _ I O                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Text_IO.Integer_Aux;\n+with System.Img_BIU;  use System.Img_BIU;\n+with System.Img_Uns;  use System.Img_Uns;\n+with System.Img_LLB;  use System.Img_LLB;\n+with System.Img_LLU;  use System.Img_LLU;\n+with System.Img_LLW;  use System.Img_LLW;\n+with System.Img_LLLB; use System.Img_LLLB;\n+with System.Img_LLLU; use System.Img_LLLU;\n+with System.Img_LLLW; use System.Img_LLLW;\n+with System.Img_WIU;  use System.Img_WIU;\n+with System.Val_Uns;  use System.Val_Uns;\n+with System.Val_LLU;  use System.Val_LLU;\n+with System.Val_LLLU; use System.Val_LLLU;\n+\n+package body Ada.Text_IO.Modular_IO is\n+\n+   package Aux_Uns is new\n+     Ada.Text_IO.Integer_Aux\n+       (Unsigned,\n+        Scan_Unsigned,\n+        Set_Image_Unsigned,\n+        Set_Image_Width_Unsigned,\n+        Set_Image_Based_Unsigned);\n+\n+   package Aux_LLU is new\n+     Ada.Text_IO.Integer_Aux\n+       (Long_Long_Unsigned,\n+        Scan_Long_Long_Unsigned,\n+        Set_Image_Long_Long_Unsigned,\n+        Set_Image_Width_Long_Long_Unsigned,\n+        Set_Image_Based_Long_Long_Unsigned);\n+\n+   package Aux_LLLU is new\n+     Ada.Text_IO.Integer_Aux\n+       (Long_Long_Long_Unsigned,\n+        Scan_Long_Long_Long_Unsigned,\n+        Set_Image_Long_Long_Long_Unsigned,\n+        Set_Image_Width_Long_Long_Long_Unsigned,\n+        Set_Image_Based_Long_Long_Long_Unsigned);\n+\n+   Need_LLU  : constant Boolean := Num'Base'Size > Unsigned'Size;\n+   Need_LLLU : constant Boolean := Num'Base'Size > Long_Long_Unsigned'Size;\n+   --  Throughout this generic body, we distinguish between cases where type\n+   --  Unsigned is acceptable, where type Long_Long_Unsigned is acceptable and\n+   --  where type Long_Long_Long_Unsigned is needed. These boolean constants\n+   --  are used to test for these cases and since they are constant, only code\n+   --  for the relevant case will be included in the instance.\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   procedure Get\n+     (File  : File_Type;\n+      Item  : out Num;\n+      Width : Field := 0)\n+   is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+\n+   begin\n+      if Need_LLLU then\n+         Aux_LLLU.Get (File, Long_Long_Long_Unsigned (Item), Width);\n+      elsif Need_LLU then\n+         Aux_LLU.Get (File, Long_Long_Unsigned (Item), Width);\n+      else\n+         Aux_Uns.Get (File, Unsigned (Item), Width);\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   procedure Get\n+     (Item  : out Num;\n+      Width : Field := 0)\n+   is\n+   begin\n+      Get (Current_In, Item, Width);\n+   end Get;\n+\n+   procedure Get\n+     (From : String;\n+      Item : out Num;\n+      Last : out Positive)\n+   is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+\n+   begin\n+      if Need_LLLU then\n+         Aux_LLLU.Gets (From, Long_Long_Long_Unsigned (Item), Last);\n+      elsif Need_LLU then\n+         Aux_LLU.Gets (From, Long_Long_Unsigned (Item), Last);\n+      else\n+         Aux_Uns.Gets (From, Unsigned (Item), Last);\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (File  : File_Type;\n+      Item  : Num;\n+      Width : Field := Default_Width;\n+      Base  : Number_Base := Default_Base)\n+   is\n+   begin\n+      if Need_LLLU then\n+         Aux_LLLU.Put (File, Long_Long_Long_Unsigned (Item), Width, Base);\n+      elsif Need_LLU then\n+         Aux_LLU.Put (File, Long_Long_Unsigned (Item), Width, Base);\n+      else\n+         Aux_Uns.Put (File, Unsigned (Item), Width, Base);\n+      end if;\n+   end Put;\n+\n+   procedure Put\n+     (Item  : Num;\n+      Width : Field := Default_Width;\n+      Base  : Number_Base := Default_Base)\n+   is\n+   begin\n+      Put (Current_Out, Item, Width, Base);\n+   end Put;\n+\n+   procedure Put\n+     (To   : out String;\n+      Item : Num;\n+      Base : Number_Base := Default_Base)\n+   is\n+   begin\n+      if Need_LLLU then\n+         Aux_LLLU.Puts (To, Long_Long_Long_Unsigned (Item), Base);\n+      elsif Need_LLU then\n+         Aux_LLU.Puts (To, Long_Long_Unsigned (Item), Base);\n+      else\n+         Aux_Uns.Puts (To, Unsigned (Item), Base);\n+      end if;\n+   end Put;\n+\n+end Ada.Text_IO.Modular_IO;"}, {"sha": "9d24070e98df50edf163db0f8071350a8e71a90c", "filename": "gcc/ada/libgnat/a-wtgeau.adb", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-wtgeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-wtgeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtgeau.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -348,6 +348,60 @@ package body Ada.Wide_Text_IO.Generic_Aux is\n       Load_Extended_Digits (File, Buf, Ptr, Junk);\n    end Load_Extended_Digits;\n \n+   ------------------\n+   -- Load_Integer --\n+   ------------------\n+\n+   procedure Load_Integer\n+     (File : File_Type;\n+      Buf  : out String;\n+      Ptr  : in out Natural)\n+   is\n+      Hash_Loc : Natural;\n+      Loaded   : Boolean;\n+\n+   begin\n+      Load_Skip (File);\n+\n+      --  Note: it is a bit strange to allow a minus sign here, but it seems\n+      --  consistent with the general behavior expected by the ACVC tests\n+      --  which is to scan past junk and then signal data error, see ACVC\n+      --  test CE3704F, case (6), which is for signed integer exponents,\n+      --  which seems a similar case.\n+\n+      Load (File, Buf, Ptr, '+', '-');\n+      Load_Digits (File, Buf, Ptr, Loaded);\n+\n+      if Loaded then\n+\n+         --  Deal with based literal. We recognize either the standard '#' or\n+         --  the allowed alternative replacement ':' (see RM J.2(3)).\n+\n+         Load (File, Buf, Ptr, '#', ':', Loaded);\n+\n+         if Loaded then\n+            Hash_Loc := Ptr;\n+            Load_Extended_Digits (File, Buf, Ptr);\n+            Load (File, Buf, Ptr, Buf (Hash_Loc));\n+         end if;\n+\n+         --  Deal with exponent\n+\n+         Load (File, Buf, Ptr, 'E', 'e', Loaded);\n+\n+         if Loaded then\n+\n+            --  Note: it is strange to allow a minus sign, since the syntax\n+            --  does not, but that is what ACVC test CE3704F, case (6) wants\n+            --  for the signed case, and there seems no good reason to treat\n+            --  exponents differently for the signed and unsigned cases.\n+\n+            Load (File, Buf, Ptr, '+', '-');\n+            Load_Digits (File, Buf, Ptr);\n+         end if;\n+      end if;\n+   end Load_Integer;\n+\n    ---------------\n    -- Load_Skip --\n    ---------------"}, {"sha": "9577ac2bd33c1a7cc5e9476080e4ae0cbcffc389", "filename": "gcc/ada/libgnat/a-wtgeau.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-wtgeau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-wtgeau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtgeau.ads?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -149,6 +149,12 @@ package Ada.Wide_Text_IO.Generic_Aux is\n       Ptr    : in out Integer);\n    --  Same as above, but no indication if character is loaded\n \n+   procedure Load_Integer\n+     (File : File_Type;\n+      Buf  : out String;\n+      Ptr  : in out Natural);\n+   --  Loads a possibly signed integer literal value\n+\n    procedure Put_Item (File : File_Type; Str : String);\n    --  This routine is like Wide_Text_IO.Put, except that it checks for\n    --  overflow of bounded lines, as described in (RM A.10.6(8)). It is used\n@@ -169,7 +175,7 @@ package Ada.Wide_Text_IO.Generic_Aux is\n    procedure String_Skip (Str : String; Ptr : out Integer);\n    --  Used in the Get from string procedures to skip leading blanks in the\n    --  string. Ptr is set to the index of the first non-blank. If the string\n-   --  is all blanks, then the excption End_Error is raised, Note that blank\n+   --  is all blanks, then the exception End_Error is raised, Note that blank\n    --  is defined as a space or horizontal tab (RM A.10.6(5)).\n \n    procedure Ungetc (ch : Integer; File : File_Type);"}, {"sha": "b614b39577ca0e378200b610272abdf05961fd07", "filename": "gcc/ada/libgnat/a-wtinau.adb", "status": "modified", "additions": 34, "deletions": 196, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-wtinau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-wtinau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtinau.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -2,7 +2,7 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---         A D A . W I D E _ T E X T _ I O . I N T E G E R  _ A U X         --\n+--         A D A . W I D E _ T E X T _ I O . I N T E G E R _ A U X          --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n@@ -31,61 +31,15 @@\n \n with Ada.Wide_Text_IO.Generic_Aux; use Ada.Wide_Text_IO.Generic_Aux;\n \n-with System.Img_BIU; use System.Img_BIU;\n-with System.Img_Int; use System.Img_Int;\n-with System.Img_LLB; use System.Img_LLB;\n-with System.Img_LLI; use System.Img_LLI;\n-with System.Img_LLW; use System.Img_LLW;\n-with System.Img_WIU; use System.Img_WIU;\n-with System.Val_Int; use System.Val_Int;\n-with System.Val_LLI; use System.Val_LLI;\n-\n package body Ada.Wide_Text_IO.Integer_Aux is\n \n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Load_Integer\n-     (File : File_Type;\n-      Buf  : out String;\n-      Ptr  : in out Natural);\n-   --  This is an auxiliary routine that is used to load an possibly signed\n-   --  integer literal value from the input file into Buf, starting at Ptr + 1.\n-   --  On return, Ptr is set to the last character stored.\n-\n-   -------------\n-   -- Get_Int --\n-   -------------\n-\n-   procedure Get_Int\n-     (File  : File_Type;\n-      Item  : out Integer;\n-      Width : Field)\n-   is\n-      Buf  : String (1 .. Field'Last);\n-      Ptr  : aliased Integer := 1;\n-      Stop : Integer := 0;\n-\n-   begin\n-      if Width /= 0 then\n-         Load_Width (File, Width, Buf, Stop);\n-         String_Skip (Buf, Ptr);\n-      else\n-         Load_Integer (File, Buf, Stop);\n-      end if;\n-\n-      Item := Scan_Integer (Buf, Ptr'Access, Stop);\n-      Check_End_Of_Field (Buf, Stop, Ptr, Width);\n-   end Get_Int;\n-\n-   -------------\n-   -- Get_LLI --\n-   -------------\n+   ---------\n+   -- Get --\n+   ---------\n \n-   procedure Get_LLI\n+   procedure Get\n      (File  : File_Type;\n-      Item  : out Long_Long_Integer;\n+      Item  : out Num;\n       Width : Field)\n    is\n       Buf  : String (1 .. Field'Last);\n@@ -100,196 +54,80 @@ package body Ada.Wide_Text_IO.Integer_Aux is\n          Load_Integer (File, Buf, Stop);\n       end if;\n \n-      Item := Scan_Long_Long_Integer (Buf, Ptr'Access, Stop);\n+      Item := Scan (Buf, Ptr'Access, Stop);\n       Check_End_Of_Field (Buf, Stop, Ptr, Width);\n-   end Get_LLI;\n+   end Get;\n \n-   --------------\n-   -- Gets_Int --\n-   --------------\n+   ----------\n+   -- Gets --\n+   ----------\n \n-   procedure Gets_Int\n+   procedure Gets\n      (From : String;\n-      Item : out Integer;\n+      Item : out Num;\n       Last : out Positive)\n    is\n       Pos : aliased Integer;\n \n    begin\n       String_Skip (From, Pos);\n-      Item := Scan_Integer (From, Pos'Access, From'Last);\n+      Item := Scan (From, Pos'Access, From'Last);\n       Last := Pos - 1;\n \n    exception\n       when Constraint_Error =>\n          raise Data_Error;\n-   end Gets_Int;\n-\n-   --------------\n-   -- Gets_LLI --\n-   --------------\n-\n-   procedure Gets_LLI\n-     (From : String;\n-      Item : out Long_Long_Integer;\n-      Last : out Positive)\n-   is\n-      Pos : aliased Integer;\n-\n-   begin\n-      String_Skip (From, Pos);\n-      Item := Scan_Long_Long_Integer (From, Pos'Access, From'Last);\n-      Last := Pos - 1;\n-\n-   exception\n-      when Constraint_Error =>\n-         raise Data_Error;\n-   end Gets_LLI;\n-\n-   ------------------\n-   -- Load_Integer --\n-   ------------------\n-\n-   procedure Load_Integer\n-     (File : File_Type;\n-      Buf  : out String;\n-      Ptr  : in out Natural)\n-   is\n-      Hash_Loc : Natural;\n-      Loaded   : Boolean;\n-\n-   begin\n-      Load_Skip (File);\n-      Load (File, Buf, Ptr, '+', '-');\n-\n-      Load_Digits (File, Buf, Ptr, Loaded);\n+   end Gets;\n \n-      if Loaded then\n+   ---------\n+   -- Put --\n+   ---------\n \n-         --  Deal with based case. We recognize either the standard '#' or the\n-         --  allowed alternative replacement ':' (see RM J.2(3)).\n-\n-         Load (File, Buf, Ptr, '#', ':', Loaded);\n-\n-         if Loaded then\n-            Hash_Loc := Ptr;\n-            Load_Extended_Digits (File, Buf, Ptr);\n-            Load (File, Buf, Ptr, Buf (Hash_Loc));\n-         end if;\n-\n-         Load (File, Buf, Ptr, 'E', 'e', Loaded);\n-\n-         if Loaded then\n-\n-            --  Note: it is strange to allow a minus sign, since the syntax\n-            --  does not, but that is what ACVC test CE3704F, case (6) wants.\n-\n-            Load (File, Buf, Ptr, '+', '-');\n-            Load_Digits (File, Buf, Ptr);\n-         end if;\n-      end if;\n-   end Load_Integer;\n-\n-   -------------\n-   -- Put_Int --\n-   -------------\n-\n-   procedure Put_Int\n+   procedure Put\n      (File  : File_Type;\n-      Item  : Integer;\n+      Item  : Num;\n       Width : Field;\n       Base  : Number_Base)\n    is\n-      Buf : String (1 .. Field'Last);\n+      Buf : String (1 .. Integer'Max (Field'Last, Width));\n       Ptr : Natural := 0;\n \n    begin\n       if Base = 10 and then Width = 0 then\n-         Set_Image_Integer (Item, Buf, Ptr);\n+         Set_Image (Item, Buf, Ptr);\n       elsif Base = 10 then\n-         Set_Image_Width_Integer (Item, Width, Buf, Ptr);\n+         Set_Image_Width (Item, Width, Buf, Ptr);\n       else\n-         Set_Image_Based_Integer (Item, Base, Width, Buf, Ptr);\n+         Set_Image_Based (Item, Base, Width, Buf, Ptr);\n       end if;\n \n       Put_Item (File, Buf (1 .. Ptr));\n-   end Put_Int;\n-\n-   -------------\n-   -- Put_LLI --\n-   -------------\n-\n-   procedure Put_LLI\n-     (File  : File_Type;\n-      Item  : Long_Long_Integer;\n-      Width : Field;\n-      Base  : Number_Base)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      if Base = 10 and then Width = 0 then\n-         Set_Image_Long_Long_Integer (Item, Buf, Ptr);\n-      elsif Base = 10 then\n-         Set_Image_Width_Long_Long_Integer (Item, Width, Buf, Ptr);\n-      else\n-         Set_Image_Based_Long_Long_Integer (Item, Base, Width, Buf, Ptr);\n-      end if;\n-\n-      Put_Item (File, Buf (1 .. Ptr));\n-   end Put_LLI;\n-\n-   --------------\n-   -- Puts_Int --\n-   --------------\n-\n-   procedure Puts_Int\n-     (To   : out String;\n-      Item : Integer;\n-      Base : Number_Base)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      if Base = 10 then\n-         Set_Image_Width_Integer (Item, To'Length, Buf, Ptr);\n-      else\n-         Set_Image_Based_Integer (Item, Base, To'Length, Buf, Ptr);\n-      end if;\n-\n-      if Ptr > To'Length then\n-         raise Layout_Error;\n-      else\n-         To (To'First .. To'First + Ptr - 1) := Buf (1 .. Ptr);\n-      end if;\n-   end Puts_Int;\n+   end Put;\n \n-   --------------\n-   -- Puts_LLI --\n-   --------------\n+   ----------\n+   -- Puts --\n+   ----------\n \n-   procedure Puts_LLI\n+   procedure Puts\n      (To   : out String;\n-      Item : Long_Long_Integer;\n+      Item : Num;\n       Base : Number_Base)\n    is\n-      Buf : String (1 .. Field'Last);\n+      Buf : String (1 .. Integer'Max (Field'Last, To'Length));\n       Ptr : Natural := 0;\n \n    begin\n       if Base = 10 then\n-         Set_Image_Width_Long_Long_Integer (Item, To'Length, Buf, Ptr);\n+         Set_Image_Width (Item, To'Length, Buf, Ptr);\n       else\n-         Set_Image_Based_Long_Long_Integer (Item, Base, To'Length, Buf, Ptr);\n+         Set_Image_Based (Item, Base, To'Length, Buf, Ptr);\n       end if;\n \n       if Ptr > To'Length then\n          raise Layout_Error;\n       else\n          To (To'First .. To'First + Ptr - 1) := Buf (1 .. Ptr);\n       end if;\n-   end Puts_LLI;\n+   end Puts;\n \n end Ada.Wide_Text_IO.Integer_Aux;"}, {"sha": "f139f77d50372c461b50aa125fd9fc98a76f85b9", "filename": "gcc/ada/libgnat/a-wtinau.ads", "status": "modified", "additions": 25, "deletions": 35, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-wtinau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-wtinau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtinau.ads?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -29,55 +29,45 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the routines for Ada.Wide_Text_IO.Integer_IO that\n---  are shared among separate instantiations of this package. The routines\n---  in this package are identical semantically to those in Integer_IO itself,\n---  except that the generic parameter Num has been replaced by Integer or\n---  Long_Long_Integer, and the default parameters have been removed because\n---  they are supplied explicitly by the calls from within the generic template.\n+--  This package contains the implementation for Ada.Wide_Text_IO.Integer_IO\n+--  and Ada.Wide_Text_IO.Modular_IO. The routines in this package are identical\n+--  semantically to those in Integer_IO and Modular_IO themselves, except that\n+--  the default parameters have been removed because they are supplied\n+--  explicitly by the calls from within these units.\n \n-private package Ada.Wide_Text_IO.Integer_Aux is\n+private generic\n+   type Num is (<>);\n \n-   procedure Get_Int\n-     (File  : File_Type;\n-      Item  : out Integer;\n-      Width : Field);\n+   with function Scan\n+     (Str : String; Ptr : not null access Integer; Max : Integer) return Num;\n+   with procedure Set_Image\n+     (V : Num; S : in out String; P : in out Natural);\n+   with procedure Set_Image_Width\n+     (V : Num; W : Integer; S : out String; P : in out Natural);\n+   with procedure Set_Image_Based\n+     (V : Num; B : Natural; W : Integer; S : out String; P : in out Natural);\n \n-   procedure Get_LLI\n+package Ada.Wide_Text_IO.Integer_Aux is\n+\n+   procedure Get\n      (File  : File_Type;\n-      Item  : out Long_Long_Integer;\n+      Item  : out Num;\n       Width : Field);\n \n-   procedure Gets_Int\n+   procedure Gets\n      (From : String;\n-      Item : out Integer;\n+      Item : out Num;\n       Last : out Positive);\n \n-   procedure Gets_LLI\n-     (From : String;\n-      Item : out Long_Long_Integer;\n-      Last : out Positive);\n-\n-   procedure Put_Int\n+   procedure Put\n      (File  : File_Type;\n-      Item  : Integer;\n+      Item  : Num;\n       Width : Field;\n       Base  : Number_Base);\n \n-   procedure Put_LLI\n-     (File  : File_Type;\n-      Item  : Long_Long_Integer;\n-      Width : Field;\n-      Base  : Number_Base);\n-\n-   procedure Puts_Int\n-     (To   : out String;\n-      Item : Integer;\n-      Base : Number_Base);\n-\n-   procedure Puts_LLI\n+   procedure Puts\n      (To   : out String;\n-      Item : Long_Long_Integer;\n+      Item : Num;\n       Base : Number_Base);\n \n end Ada.Wide_Text_IO.Integer_Aux;"}, {"sha": "a3f666e1ccdf605c83c60d50147476ec485e79fd", "filename": "gcc/ada/libgnat/a-wtinio.adb", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-wtinio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-wtinio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtinio.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -30,11 +30,35 @@\n ------------------------------------------------------------------------------\n \n with Ada.Wide_Text_IO.Integer_Aux;\n+with System.Img_BIU; use System.Img_BIU;\n+with System.Img_Int; use System.Img_Int;\n+with System.Img_LLB; use System.Img_LLB;\n+with System.Img_LLI; use System.Img_LLI;\n+with System.Img_LLW; use System.Img_LLW;\n+with System.Img_WIU; use System.Img_WIU;\n+with System.Val_Int; use System.Val_Int;\n+with System.Val_LLI; use System.Val_LLI;\n with System.WCh_Con; use System.WCh_Con;\n with System.WCh_WtS; use System.WCh_WtS;\n \n package body Ada.Wide_Text_IO.Integer_IO is\n \n+   package Aux_Int is new\n+     Ada.Wide_Text_IO.Integer_Aux\n+       (Integer,\n+        Scan_Integer,\n+        Set_Image_Integer,\n+        Set_Image_Width_Integer,\n+        Set_Image_Based_Integer);\n+\n+   package Aux_LLI is new\n+     Ada.Wide_Text_IO.Integer_Aux\n+       (Long_Long_Integer,\n+        Scan_Long_Long_Integer,\n+        Set_Image_Long_Long_Integer,\n+        Set_Image_Width_Long_Long_Integer,\n+        Set_Image_Based_Long_Long_Integer);\n+\n    Need_LLI : constant Boolean := Num'Base'Size > Integer'Size;\n    --  Throughout this generic body, we distinguish between the case where type\n    --  Integer is acceptable, and where a Long_Long_Integer is needed. This\n@@ -44,8 +68,6 @@ package body Ada.Wide_Text_IO.Integer_IO is\n    subtype TFT is Ada.Wide_Text_IO.File_Type;\n    --  File type required for calls to routines in Aux\n \n-   package Aux renames Ada.Wide_Text_IO.Integer_Aux;\n-\n    ---------\n    -- Get --\n    ---------\n@@ -55,11 +77,16 @@ package body Ada.Wide_Text_IO.Integer_IO is\n       Item  : out Num;\n       Width : Field := 0)\n    is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+      pragma Unsuppress (Overflow_Check);\n+\n    begin\n       if Need_LLI then\n-         Aux.Get_LLI (TFT (File), Long_Long_Integer (Item), Width);\n+         Aux_LLI.Get (TFT (File), Long_Long_Integer (Item), Width);\n       else\n-         Aux.Get_Int (TFT (File), Integer (Item), Width);\n+         Aux_Int.Get (TFT (File), Integer (Item), Width);\n       end if;\n \n    exception\n@@ -79,6 +106,11 @@ package body Ada.Wide_Text_IO.Integer_IO is\n       Item : out Num;\n       Last : out Positive)\n    is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+      pragma Unsuppress (Overflow_Check);\n+\n       S : constant String := Wide_String_To_String (From, WCEM_Upper);\n       --  String on which we do the actual conversion. Note that the method\n       --  used for wide character encoding is irrelevant, since if there is\n@@ -87,9 +119,9 @@ package body Ada.Wide_Text_IO.Integer_IO is\n \n    begin\n       if Need_LLI then\n-         Aux.Gets_LLI (S, Long_Long_Integer (Item), Last);\n+         Aux_LLI.Gets (S, Long_Long_Integer (Item), Last);\n       else\n-         Aux.Gets_Int (S, Integer (Item), Last);\n+         Aux_Int.Gets (S, Integer (Item), Last);\n       end if;\n \n    exception\n@@ -108,9 +140,9 @@ package body Ada.Wide_Text_IO.Integer_IO is\n    is\n    begin\n       if Need_LLI then\n-         Aux.Put_LLI (TFT (File), Long_Long_Integer (Item), Width, Base);\n+         Aux_LLI.Put (TFT (File), Long_Long_Integer (Item), Width, Base);\n       else\n-         Aux.Put_Int (TFT (File), Integer (Item), Width, Base);\n+         Aux_Int.Put (TFT (File), Integer (Item), Width, Base);\n       end if;\n    end Put;\n \n@@ -132,9 +164,9 @@ package body Ada.Wide_Text_IO.Integer_IO is\n \n    begin\n       if Need_LLI then\n-         Aux.Puts_LLI (S, Long_Long_Integer (Item), Base);\n+         Aux_LLI.Puts (S, Long_Long_Integer (Item), Base);\n       else\n-         Aux.Puts_Int (S, Integer (Item), Base);\n+         Aux_Int.Puts (S, Integer (Item), Base);\n       end if;\n \n       for J in S'Range loop"}, {"sha": "edc78c3614ed8e8e9e9be2dfc294f58d920dbe42", "filename": "gcc/ada/libgnat/a-wtinio__128.adb", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-wtinio__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-wtinio__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtinio__128.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -0,0 +1,199 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--           A D A . W I D E _ T E X T _ I O . I N T E G E R _ I O          --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Text_IO.Integer_Aux;\n+with System.Img_BIU;  use System.Img_BIU;\n+with System.Img_Int;  use System.Img_Int;\n+with System.Img_LLB;  use System.Img_LLB;\n+with System.Img_LLI;  use System.Img_LLI;\n+with System.Img_LLW;  use System.Img_LLW;\n+with System.Img_LLLB; use System.Img_LLLB;\n+with System.Img_LLLI; use System.Img_LLLI;\n+with System.Img_LLLW; use System.Img_LLLW;\n+with System.Img_WIU;  use System.Img_WIU;\n+with System.Val_Int;  use System.Val_Int;\n+with System.Val_LLI;  use System.Val_LLI;\n+with System.Val_LLLI; use System.Val_LLLI;\n+with System.WCh_Con;  use System.WCh_Con;\n+with System.WCh_WtS;  use System.WCh_WtS;\n+\n+package body Ada.Wide_Text_IO.Integer_IO is\n+\n+   package Aux_Int is new\n+     Ada.Wide_Text_IO.Integer_Aux\n+       (Integer,\n+        Scan_Integer,\n+        Set_Image_Integer,\n+        Set_Image_Width_Integer,\n+        Set_Image_Based_Integer);\n+\n+   package Aux_LLI is new\n+     Ada.Wide_Text_IO.Integer_Aux\n+       (Long_Long_Integer,\n+        Scan_Long_Long_Integer,\n+        Set_Image_Long_Long_Integer,\n+        Set_Image_Width_Long_Long_Integer,\n+        Set_Image_Based_Long_Long_Integer);\n+\n+   package Aux_LLLI is new\n+     Ada.Wide_Text_IO.Integer_Aux\n+       (Long_Long_Long_Integer,\n+        Scan_Long_Long_Long_Integer,\n+        Set_Image_Long_Long_Long_Integer,\n+        Set_Image_Width_Long_Long_Long_Integer,\n+        Set_Image_Based_Long_Long_Long_Integer);\n+\n+   Need_LLI  : constant Boolean := Num'Base'Size > Integer'Size;\n+   Need_LLLI : constant Boolean := Num'Base'Size > Long_Long_Integer'Size;\n+   --  Throughout this generic body, we distinguish between cases where type\n+   --  Integer is acceptable, where type Long_Long_Integer is acceptable and\n+   --  where type Long_Long_Long_Integer is needed. These boolean constants\n+   --  are used to test for these cases and since they are constant, only code\n+   --  for the relevant case will be included in the instance.\n+\n+   subtype TFT is Ada.Wide_Text_IO.File_Type;\n+   --  File type required for calls to routines in Aux\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   procedure Get\n+     (File  : File_Type;\n+      Item  : out Num;\n+      Width : Field := 0)\n+   is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+      pragma Unsuppress (Overflow_Check);\n+\n+   begin\n+      if Need_LLLI then\n+         Aux_LLLI.Get (TFT (File), Long_Long_Long_Integer (Item), Width);\n+      elsif Need_LLI then\n+         Aux_LLI.Get (TFT (File), Long_Long_Integer (Item), Width);\n+      else\n+         Aux_Int.Get (TFT (File), Integer (Item), Width);\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   procedure Get\n+     (Item  : out Num;\n+      Width : Field := 0)\n+   is\n+   begin\n+      Get (Current_Input, Item, Width);\n+   end Get;\n+\n+   procedure Get\n+     (From : Wide_String;\n+      Item : out Num;\n+      Last : out Positive)\n+   is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+      pragma Unsuppress (Overflow_Check);\n+\n+      S : constant String := Wide_String_To_String (From, WCEM_Upper);\n+      --  String on which we do the actual conversion. Note that the method\n+      --  used for wide character encoding is irrelevant, since if there is\n+      --  a character outside the Standard.Character range then the call to\n+      --  Aux.Gets will raise Data_Error in any case.\n+\n+   begin\n+      if Need_LLLI then\n+         Aux_LLLI.Gets (S, Long_Long_Long_Integer (Item), Last);\n+      elsif Need_LLI then\n+         Aux_LLI.Gets (S, Long_Long_Integer (Item), Last);\n+      else\n+         Aux_Int.Gets (S, Integer (Item), Last);\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (File  : File_Type;\n+      Item  : Num;\n+      Width : Field := Default_Width;\n+      Base  : Number_Base := Default_Base)\n+   is\n+   begin\n+      if Need_LLLI then\n+         Aux_LLLI.Put (TFT (File), Long_Long_Long_Integer (Item), Width, Base);\n+      elsif Need_LLI then\n+         Aux_LLI.Put (TFT (File), Long_Long_Integer (Item), Width, Base);\n+      else\n+         Aux_Int.Put (TFT (File), Integer (Item), Width, Base);\n+      end if;\n+   end Put;\n+\n+   procedure Put\n+     (Item  : Num;\n+      Width : Field := Default_Width;\n+      Base  : Number_Base := Default_Base)\n+   is\n+   begin\n+      Put (Current_Output, Item, Width, Base);\n+   end Put;\n+\n+   procedure Put\n+     (To   : out Wide_String;\n+      Item : Num;\n+      Base : Number_Base := Default_Base)\n+   is\n+      S : String (To'First .. To'Last);\n+\n+   begin\n+      if Need_LLLI then\n+         Aux_LLLI.Puts (S, Long_Long_Long_Integer (Item), Base);\n+      elsif Need_LLI then\n+         Aux_LLI.Puts (S, Long_Long_Integer (Item), Base);\n+      else\n+         Aux_Int.Puts (S, Integer (Item), Base);\n+      end if;\n+\n+      for J in S'Range loop\n+         To (J) := Wide_Character'Val (Character'Pos (S (J)));\n+      end loop;\n+   end Put;\n+\n+end Ada.Wide_Text_IO.Integer_IO;"}, {"sha": "90397980bc56f018007df07230b5a88c9f1529ee", "filename": "gcc/ada/libgnat/a-wtmoau.adb", "status": "removed", "additions": 0, "deletions": 305, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd2e6f249e55c810c0414572807face97d88f07/gcc%2Fada%2Flibgnat%2Fa-wtmoau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd2e6f249e55c810c0414572807face97d88f07/gcc%2Fada%2Flibgnat%2Fa-wtmoau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtmoau.adb?ref=4cd2e6f249e55c810c0414572807face97d88f07", "patch": "@@ -1,305 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---         A D A . W I D E _ T E X T _ I O . M O D U L A R  _ A U X         --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Wide_Text_IO.Generic_Aux; use Ada.Wide_Text_IO.Generic_Aux;\n-\n-with System.Img_BIU; use System.Img_BIU;\n-with System.Img_Uns; use System.Img_Uns;\n-with System.Img_LLB; use System.Img_LLB;\n-with System.Img_LLU; use System.Img_LLU;\n-with System.Img_LLW; use System.Img_LLW;\n-with System.Img_WIU; use System.Img_WIU;\n-with System.Val_Uns; use System.Val_Uns;\n-with System.Val_LLU; use System.Val_LLU;\n-\n-package body Ada.Wide_Text_IO.Modular_Aux is\n-\n-   use System.Unsigned_Types;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Load_Modular\n-     (File : File_Type;\n-      Buf  : out String;\n-      Ptr  : in out Natural);\n-   --  This is an auxiliary routine that is used to load an possibly signed\n-   --  modular literal value from the input file into Buf, starting at Ptr + 1.\n-   --  Ptr is left set to the last character stored.\n-\n-   -------------\n-   -- Get_LLU --\n-   -------------\n-\n-   procedure Get_LLU\n-     (File  : File_Type;\n-      Item  : out Long_Long_Unsigned;\n-      Width : Field)\n-   is\n-      Buf  : String (1 .. Field'Last);\n-      Stop : Integer := 0;\n-      Ptr  : aliased Integer := 1;\n-\n-   begin\n-      if Width /= 0 then\n-         Load_Width (File, Width, Buf, Stop);\n-         String_Skip (Buf, Ptr);\n-      else\n-         Load_Modular (File, Buf, Stop);\n-      end if;\n-\n-      Item := Scan_Long_Long_Unsigned (Buf, Ptr'Access, Stop);\n-      Check_End_Of_Field (Buf, Stop, Ptr, Width);\n-   end Get_LLU;\n-\n-   -------------\n-   -- Get_Uns --\n-   -------------\n-\n-   procedure Get_Uns\n-     (File  : File_Type;\n-      Item  : out Unsigned;\n-      Width : Field)\n-   is\n-      Buf  : String (1 .. Field'Last);\n-      Stop : Integer := 0;\n-      Ptr  : aliased Integer := 1;\n-\n-   begin\n-      if Width /= 0 then\n-         Load_Width (File, Width, Buf, Stop);\n-         String_Skip (Buf, Ptr);\n-      else\n-         Load_Modular (File, Buf, Stop);\n-      end if;\n-\n-      Item := Scan_Unsigned (Buf, Ptr'Access, Stop);\n-      Check_End_Of_Field (Buf, Stop, Ptr, Width);\n-   end Get_Uns;\n-\n-   --------------\n-   -- Gets_LLU --\n-   --------------\n-\n-   procedure Gets_LLU\n-     (From : String;\n-      Item : out Long_Long_Unsigned;\n-      Last : out Positive)\n-   is\n-      Pos : aliased Integer;\n-\n-   begin\n-      String_Skip (From, Pos);\n-      Item := Scan_Long_Long_Unsigned (From, Pos'Access, From'Last);\n-      Last := Pos - 1;\n-\n-   exception\n-      when Constraint_Error =>\n-         raise Data_Error;\n-   end Gets_LLU;\n-\n-   --------------\n-   -- Gets_Uns --\n-   --------------\n-\n-   procedure Gets_Uns\n-     (From : String;\n-      Item : out Unsigned;\n-      Last : out Positive)\n-   is\n-      Pos : aliased Integer;\n-\n-   begin\n-      String_Skip (From, Pos);\n-      Item := Scan_Unsigned (From, Pos'Access, From'Last);\n-      Last := Pos - 1;\n-\n-   exception\n-      when Constraint_Error =>\n-         raise Data_Error;\n-   end Gets_Uns;\n-\n-   ------------------\n-   -- Load_Modular --\n-   ------------------\n-\n-   procedure Load_Modular\n-     (File : File_Type;\n-      Buf  : out String;\n-      Ptr  : in out Natural)\n-   is\n-      Hash_Loc : Natural;\n-      Loaded   : Boolean;\n-\n-   begin\n-      Load_Skip (File);\n-\n-      --  Note: it is a bit strange to allow a minus sign here, but it seems\n-      --  consistent with the general behavior expected by the ACVC tests\n-      --  which is to scan past junk and then signal data error, see ACVC\n-      --  test CE3704F, case (6), which is for signed integer exponents,\n-      --  which seems a similar case.\n-\n-      Load (File, Buf, Ptr, '+', '-');\n-      Load_Digits (File, Buf, Ptr, Loaded);\n-\n-      if Loaded then\n-\n-         --  Deal with based case. We recognize either the standard '#' or the\n-         --  allowed alternative replacement ':' (see RM J.2(3)).\n-\n-         Load (File, Buf, Ptr, '#', ':', Loaded);\n-\n-         if Loaded then\n-            Hash_Loc := Ptr;\n-            Load_Extended_Digits (File, Buf, Ptr);\n-            Load (File, Buf, Ptr, Buf (Hash_Loc));\n-         end if;\n-\n-         Load (File, Buf, Ptr, 'E', 'e', Loaded);\n-\n-         if Loaded then\n-\n-            --  Note: it is strange to allow a minus sign, since the syntax\n-            --  does not, but that is what ACVC test CE3704F, case (6) wants\n-            --  for the signed case, and there seems no good reason to treat\n-            --  exponents differently for the signed and unsigned cases.\n-\n-            Load (File, Buf, Ptr, '+', '-');\n-            Load_Digits (File, Buf, Ptr);\n-         end if;\n-      end if;\n-   end Load_Modular;\n-\n-   -------------\n-   -- Put_LLU --\n-   -------------\n-\n-   procedure Put_LLU\n-     (File  : File_Type;\n-      Item  : Long_Long_Unsigned;\n-      Width : Field;\n-      Base  : Number_Base)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      if Base = 10 and then Width = 0 then\n-         Set_Image_Long_Long_Unsigned (Item, Buf, Ptr);\n-      elsif Base = 10 then\n-         Set_Image_Width_Long_Long_Unsigned (Item, Width, Buf, Ptr);\n-      else\n-         Set_Image_Based_Long_Long_Unsigned (Item, Base, Width, Buf, Ptr);\n-      end if;\n-\n-      Put_Item (File, Buf (1 .. Ptr));\n-   end Put_LLU;\n-\n-   -------------\n-   -- Put_Uns --\n-   -------------\n-\n-   procedure Put_Uns\n-     (File  : File_Type;\n-      Item  : Unsigned;\n-      Width : Field;\n-      Base  : Number_Base)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      if Base = 10 and then Width = 0 then\n-         Set_Image_Unsigned (Item, Buf, Ptr);\n-      elsif Base = 10 then\n-         Set_Image_Width_Unsigned (Item, Width, Buf, Ptr);\n-      else\n-         Set_Image_Based_Unsigned (Item, Base, Width, Buf, Ptr);\n-      end if;\n-\n-      Put_Item (File, Buf (1 .. Ptr));\n-   end Put_Uns;\n-\n-   --------------\n-   -- Puts_LLU --\n-   --------------\n-\n-   procedure Puts_LLU\n-     (To   : out String;\n-      Item : Long_Long_Unsigned;\n-      Base : Number_Base)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      if Base = 10 then\n-         Set_Image_Width_Long_Long_Unsigned (Item, To'Length, Buf, Ptr);\n-      else\n-         Set_Image_Based_Long_Long_Unsigned (Item, Base, To'Length, Buf, Ptr);\n-      end if;\n-\n-      if Ptr > To'Length then\n-         raise Layout_Error;\n-      else\n-         To (To'First .. To'First + Ptr - 1) := Buf (1 .. Ptr);\n-      end if;\n-   end Puts_LLU;\n-\n-   --------------\n-   -- Puts_Uns --\n-   --------------\n-\n-   procedure Puts_Uns\n-     (To   : out String;\n-      Item : Unsigned;\n-      Base : Number_Base)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      if Base = 10 then\n-         Set_Image_Width_Unsigned (Item, To'Length, Buf, Ptr);\n-      else\n-         Set_Image_Based_Unsigned (Item, Base, To'Length, Buf, Ptr);\n-      end if;\n-\n-      if Ptr > To'Length then\n-         raise Layout_Error;\n-      else\n-         To (To'First .. To'First + Ptr - 1) := Buf (1 .. Ptr);\n-      end if;\n-   end Puts_Uns;\n-\n-end Ada.Wide_Text_IO.Modular_Aux;"}, {"sha": "9fe444e6b88705f1560ec4bbcca2086c21d4e8f5", "filename": "gcc/ada/libgnat/a-wtmoau.ads", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd2e6f249e55c810c0414572807face97d88f07/gcc%2Fada%2Flibgnat%2Fa-wtmoau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd2e6f249e55c810c0414572807face97d88f07/gcc%2Fada%2Flibgnat%2Fa-wtmoau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtmoau.ads?ref=4cd2e6f249e55c810c0414572807face97d88f07", "patch": "@@ -1,87 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---         A D A . W I D E _ T E X T _ I O . M O D U L A R _ A U X          --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains the routines for Ada.Wide_Text_IO.Modular_IO that\n---  are shared among separate instantiations of this package. The routines\n---  in this package are identical semantically to those in Modular_IO itself,\n---  except that the generic parameter Num has been replaced by Unsigned or\n---  Long_Long_Unsigned, and the default parameters have been removed because\n---  they are supplied explicitly by the calls from within the generic template.\n-\n-with System.Unsigned_Types;\n-\n-private package Ada.Wide_Text_IO.Modular_Aux is\n-\n-   package U renames System.Unsigned_Types;\n-\n-   procedure Get_Uns\n-     (File  : File_Type;\n-      Item  : out U.Unsigned;\n-      Width : Field);\n-\n-   procedure Get_LLU\n-     (File  : File_Type;\n-      Item  : out U.Long_Long_Unsigned;\n-      Width : Field);\n-\n-   procedure Gets_Uns\n-     (From : String;\n-      Item : out U.Unsigned;\n-      Last : out Positive);\n-\n-   procedure Gets_LLU\n-     (From : String;\n-      Item : out U.Long_Long_Unsigned;\n-      Last : out Positive);\n-\n-   procedure Put_Uns\n-     (File  : File_Type;\n-      Item  : U.Unsigned;\n-      Width : Field;\n-      Base  : Number_Base);\n-\n-   procedure Put_LLU\n-     (File  : File_Type;\n-      Item  : U.Long_Long_Unsigned;\n-      Width : Field;\n-      Base  : Number_Base);\n-\n-   procedure Puts_Uns\n-     (To   : out String;\n-      Item : U.Unsigned;\n-      Base : Number_Base);\n-\n-   procedure Puts_LLU\n-     (To   : out String;\n-      Item : U.Long_Long_Unsigned;\n-      Base : Number_Base);\n-\n-end Ada.Wide_Text_IO.Modular_Aux;"}, {"sha": "702dcbb68ca527e69fa5fc15d6604582430ee103", "filename": "gcc/ada/libgnat/a-wtmoio.adb", "status": "modified", "additions": 53, "deletions": 19, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-wtmoio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-wtmoio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtmoio.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -29,19 +29,45 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Wide_Text_IO.Modular_Aux;\n-\n-with System.Unsigned_Types; use System.Unsigned_Types;\n-with System.WCh_Con;        use System.WCh_Con;\n-with System.WCh_WtS;        use System.WCh_WtS;\n+with Ada.Wide_Text_IO.Integer_Aux;\n+with System.Img_BIU; use System.Img_BIU;\n+with System.Img_Uns; use System.Img_Uns;\n+with System.Img_LLB; use System.Img_LLB;\n+with System.Img_LLU; use System.Img_LLU;\n+with System.Img_LLW; use System.Img_LLW;\n+with System.Img_WIU; use System.Img_WIU;\n+with System.Val_Uns; use System.Val_Uns;\n+with System.Val_LLU; use System.Val_LLU;\n+with System.WCh_Con; use System.WCh_Con;\n+with System.WCh_WtS; use System.WCh_WtS;\n \n package body Ada.Wide_Text_IO.Modular_IO is\n \n+   package Aux_Uns is new\n+     Ada.Wide_Text_IO.Integer_Aux\n+       (Unsigned,\n+        Scan_Unsigned,\n+        Set_Image_Unsigned,\n+        Set_Image_Width_Unsigned,\n+        Set_Image_Based_Unsigned);\n+\n+   package Aux_LLU is new\n+     Ada.Wide_Text_IO.Integer_Aux\n+       (Long_Long_Unsigned,\n+        Scan_Long_Long_Unsigned,\n+        Set_Image_Long_Long_Unsigned,\n+        Set_Image_Width_Long_Long_Unsigned,\n+        Set_Image_Based_Long_Long_Unsigned);\n+\n+   Need_LLU : constant Boolean := Num'Base'Size > Unsigned'Size;\n+   --  Throughout this generic body, we distinguish between the case where type\n+   --  Unsigned is acceptable, and where a Long_Long_Unsigned is needed. This\n+   --  Boolean is used to test for these cases and since it is a constant, only\n+   --  code for the relevant case will be included in the instance.\n+\n    subtype TFT is Ada.Wide_Text_IO.File_Type;\n    --  File type required for calls to routines in Aux\n \n-   package Aux renames Ada.Wide_Text_IO.Modular_Aux;\n-\n    ---------\n    -- Get --\n    ---------\n@@ -51,11 +77,15 @@ package body Ada.Wide_Text_IO.Modular_IO is\n       Item  : out Num;\n       Width : Field := 0)\n    is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+\n    begin\n-      if Num'Size > Unsigned'Size then\n-         Aux.Get_LLU (TFT (File), Long_Long_Unsigned (Item), Width);\n+      if Need_LLU then\n+         Aux_LLU.Get (TFT (File), Long_Long_Unsigned (Item), Width);\n       else\n-         Aux.Get_Uns (TFT (File), Unsigned (Item), Width);\n+         Aux_Uns.Get (TFT (File), Unsigned (Item), Width);\n       end if;\n \n    exception\n@@ -75,17 +105,21 @@ package body Ada.Wide_Text_IO.Modular_IO is\n       Item : out Num;\n       Last : out Positive)\n    is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+\n       S : constant String := Wide_String_To_String (From, WCEM_Upper);\n       --  String on which we do the actual conversion. Note that the method\n       --  used for wide character encoding is irrelevant, since if there is\n       --  a character outside the Standard.Character range then the call to\n       --  Aux.Gets will raise Data_Error in any case.\n \n    begin\n-      if Num'Size > Unsigned'Size then\n-         Aux.Gets_LLU (S, Long_Long_Unsigned (Item), Last);\n+      if Need_LLU then\n+         Aux_LLU.Gets (S, Long_Long_Unsigned (Item), Last);\n       else\n-         Aux.Gets_Uns (S, Unsigned (Item), Last);\n+         Aux_Uns.Gets (S, Unsigned (Item), Last);\n       end if;\n \n    exception\n@@ -103,10 +137,10 @@ package body Ada.Wide_Text_IO.Modular_IO is\n       Base  : Number_Base := Default_Base)\n    is\n    begin\n-      if Num'Size > Unsigned'Size then\n-         Aux.Put_LLU (TFT (File), Long_Long_Unsigned (Item), Width, Base);\n+      if Need_LLU then\n+         Aux_LLU.Put (TFT (File), Long_Long_Unsigned (Item), Width, Base);\n       else\n-         Aux.Put_Uns (TFT (File), Unsigned (Item), Width, Base);\n+         Aux_Uns.Put (TFT (File), Unsigned (Item), Width, Base);\n       end if;\n    end Put;\n \n@@ -127,10 +161,10 @@ package body Ada.Wide_Text_IO.Modular_IO is\n       S : String (To'First .. To'Last);\n \n    begin\n-      if Num'Size > Unsigned'Size then\n-         Aux.Puts_LLU (S, Long_Long_Unsigned (Item), Base);\n+      if Need_LLU then\n+         Aux_LLU.Puts (S, Long_Long_Unsigned (Item), Base);\n       else\n-         Aux.Puts_Uns (S, Unsigned (Item), Base);\n+         Aux_Uns.Puts (S, Unsigned (Item), Base);\n       end if;\n \n       for J in S'Range loop"}, {"sha": "661faecf0167072544f60ec85f6a2d3e1958dadc", "filename": "gcc/ada/libgnat/a-wtmoio__128.adb", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-wtmoio__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-wtmoio__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtmoio__128.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -0,0 +1,197 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--           A D A . W I D E _ T E X T _ I O . M O D U L A R _ I O          --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--           Copyright (C) 1992-2020, Free Software Foundation, Inc.        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Text_IO.Integer_Aux;\n+with System.Img_BIU;  use System.Img_BIU;\n+with System.Img_Uns;  use System.Img_Uns;\n+with System.Img_LLB;  use System.Img_LLB;\n+with System.Img_LLU;  use System.Img_LLU;\n+with System.Img_LLW;  use System.Img_LLW;\n+with System.Img_LLLB; use System.Img_LLLB;\n+with System.Img_LLLU; use System.Img_LLLU;\n+with System.Img_LLLW; use System.Img_LLLW;\n+with System.Img_WIU;  use System.Img_WIU;\n+with System.Val_Uns;  use System.Val_Uns;\n+with System.Val_LLU;  use System.Val_LLU;\n+with System.Val_LLLU; use System.Val_LLLU;\n+with System.WCh_Con;  use System.WCh_Con;\n+with System.WCh_WtS;  use System.WCh_WtS;\n+\n+package body Ada.Wide_Text_IO.Modular_IO is\n+\n+   package Aux_Uns is new\n+     Ada.Wide_Text_IO.Integer_Aux\n+       (Unsigned,\n+        Scan_Unsigned,\n+        Set_Image_Unsigned,\n+        Set_Image_Width_Unsigned,\n+        Set_Image_Based_Unsigned);\n+\n+   package Aux_LLU is new\n+     Ada.Wide_Text_IO.Integer_Aux\n+       (Long_Long_Unsigned,\n+        Scan_Long_Long_Unsigned,\n+        Set_Image_Long_Long_Unsigned,\n+        Set_Image_Width_Long_Long_Unsigned,\n+        Set_Image_Based_Long_Long_Unsigned);\n+\n+   package Aux_LLLU is new\n+     Ada.Wide_Text_IO.Integer_Aux\n+       (Long_Long_Long_Unsigned,\n+        Scan_Long_Long_Long_Unsigned,\n+        Set_Image_Long_Long_Long_Unsigned,\n+        Set_Image_Width_Long_Long_Long_Unsigned,\n+        Set_Image_Based_Long_Long_Long_Unsigned);\n+\n+   Need_LLU  : constant Boolean := Num'Base'Size > Unsigned'Size;\n+   Need_LLLU : constant Boolean := Num'Base'Size > Long_Long_Unsigned'Size;\n+   --  Throughout this generic body, we distinguish between cases where type\n+   --  Unsigned is acceptable, where type Long_Long_Unsigned is acceptable and\n+   --  where type Long_Long_Long_Unsigned is needed. These boolean constants\n+   --  are used to test for these cases and since they are constant, only code\n+   --  for the relevant case will be included in the instance.\n+\n+   subtype TFT is Ada.Wide_Text_IO.File_Type;\n+   --  File type required for calls to routines in Aux\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   procedure Get\n+     (File  : File_Type;\n+      Item  : out Num;\n+      Width : Field := 0)\n+   is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+\n+   begin\n+      if Need_LLLU then\n+         Aux_LLLU.Get (File, Long_Long_Long_Unsigned (Item), Width);\n+      elsif Need_LLU then\n+         Aux_LLU.Get (TFT (File), Long_Long_Unsigned (Item), Width);\n+      else\n+         Aux_Uns.Get (TFT (File), Unsigned (Item), Width);\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   procedure Get\n+     (Item  : out Num;\n+      Width : Field := 0)\n+   is\n+   begin\n+      Get (Current_Input, Item, Width);\n+   end Get;\n+\n+   procedure Get\n+     (From : Wide_String;\n+      Item : out Num;\n+      Last : out Positive)\n+   is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+\n+      S : constant String := Wide_String_To_String (From, WCEM_Upper);\n+      --  String on which we do the actual conversion. Note that the method\n+      --  used for wide character encoding is irrelevant, since if there is\n+      --  a character outside the Standard.Character range then the call to\n+      --  Aux.Gets will raise Data_Error in any case.\n+\n+   begin\n+      if Need_LLLU then\n+         Aux_LLLU.Gets (S, Long_Long_Long_Unsigned (Item), Last);\n+      elsif Need_LLU then\n+         Aux_LLU.Gets (S, Long_Long_Unsigned (Item), Last);\n+      else\n+         Aux_Uns.Gets (S, Unsigned (Item), Last);\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (File  : File_Type;\n+      Item  : Num;\n+      Width : Field := Default_Width;\n+      Base  : Number_Base := Default_Base)\n+   is\n+   begin\n+      if Need_LLLU then\n+         Aux_LLLU.Put (File, Long_Long_Long_Unsigned (Item), Width, Base);\n+      elsif Need_LLU then\n+         Aux_LLU.Put (TFT (File), Long_Long_Unsigned (Item), Width, Base);\n+      else\n+         Aux_Uns.Put (TFT (File), Unsigned (Item), Width, Base);\n+      end if;\n+   end Put;\n+\n+   procedure Put\n+     (Item  : Num;\n+      Width : Field := Default_Width;\n+      Base  : Number_Base := Default_Base)\n+   is\n+   begin\n+      Put (Current_Output, Item, Width, Base);\n+   end Put;\n+\n+   procedure Put\n+     (To   : out Wide_String;\n+      Item : Num;\n+      Base : Number_Base := Default_Base)\n+   is\n+      S : String (To'First .. To'Last);\n+\n+   begin\n+      if Need_LLLU then\n+         Aux_LLLU.Puts (S, Long_Long_Long_Unsigned (Item), Base);\n+      elsif Need_LLU then\n+         Aux_LLU.Puts (S, Long_Long_Unsigned (Item), Base);\n+      else\n+         Aux_Uns.Puts (S, Unsigned (Item), Base);\n+      end if;\n+\n+      for J in S'Range loop\n+         To (J) := Wide_Character'Val (Character'Pos (S (J)));\n+      end loop;\n+   end Put;\n+\n+end Ada.Wide_Text_IO.Modular_IO;"}, {"sha": "be7aecc9ecf4d1448c3efd7f4180740bc001c709", "filename": "gcc/ada/libgnat/a-ztgeau.adb", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-ztgeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-ztgeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztgeau.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -348,6 +348,60 @@ package body Ada.Wide_Wide_Text_IO.Generic_Aux is\n       Load_Extended_Digits (File, Buf, Ptr, Junk);\n    end Load_Extended_Digits;\n \n+   ------------------\n+   -- Load_Integer --\n+   ------------------\n+\n+   procedure Load_Integer\n+     (File : File_Type;\n+      Buf  : out String;\n+      Ptr  : in out Natural)\n+   is\n+      Hash_Loc : Natural;\n+      Loaded   : Boolean;\n+\n+   begin\n+      Load_Skip (File);\n+\n+      --  Note: it is a bit strange to allow a minus sign here, but it seems\n+      --  consistent with the general behavior expected by the ACVC tests\n+      --  which is to scan past junk and then signal data error, see ACVC\n+      --  test CE3704F, case (6), which is for signed integer exponents,\n+      --  which seems a similar case.\n+\n+      Load (File, Buf, Ptr, '+', '-');\n+      Load_Digits (File, Buf, Ptr, Loaded);\n+\n+      if Loaded then\n+\n+         --  Deal with based literal. We recognize either the standard '#' or\n+         --  the allowed alternative replacement ':' (see RM J.2(3)).\n+\n+         Load (File, Buf, Ptr, '#', ':', Loaded);\n+\n+         if Loaded then\n+            Hash_Loc := Ptr;\n+            Load_Extended_Digits (File, Buf, Ptr);\n+            Load (File, Buf, Ptr, Buf (Hash_Loc));\n+         end if;\n+\n+         --  Deal with exponent\n+\n+         Load (File, Buf, Ptr, 'E', 'e', Loaded);\n+\n+         if Loaded then\n+\n+            --  Note: it is strange to allow a minus sign, since the syntax\n+            --  does not, but that is what ACVC test CE3704F, case (6) wants\n+            --  for the signed case, and there seems no good reason to treat\n+            --  exponents differently for the signed and unsigned cases.\n+\n+            Load (File, Buf, Ptr, '+', '-');\n+            Load_Digits (File, Buf, Ptr);\n+         end if;\n+      end if;\n+   end Load_Integer;\n+\n    ---------------\n    -- Load_Skip --\n    ---------------"}, {"sha": "68d4a33cb379812b481a44602a56e2c88fa902a3", "filename": "gcc/ada/libgnat/a-ztgeau.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-ztgeau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-ztgeau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztgeau.ads?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -149,6 +149,12 @@ package Ada.Wide_Wide_Text_IO.Generic_Aux is\n       Ptr    : in out Integer);\n    --  Same as above, but no indication if character is loaded\n \n+   procedure Load_Integer\n+     (File : File_Type;\n+      Buf  : out String;\n+      Ptr  : in out Natural);\n+   --  Loads a possibly signed integer literal value\n+\n    procedure Put_Item (File : File_Type; Str : String);\n    --  This routine is like Wide_Wide_Text_IO.Put, except that it checks for\n    --  overflow of bounded lines, as described in (RM A.10.6(8)). It is used\n@@ -169,7 +175,7 @@ package Ada.Wide_Wide_Text_IO.Generic_Aux is\n    procedure String_Skip (Str : String; Ptr : out Integer);\n    --  Used in the Get from string procedures to skip leading blanks in the\n    --  string. Ptr is set to the index of the first non-blank. If the string\n-   --  is all blanks, then the excption End_Error is raised, Note that blank\n+   --  is all blanks, then the exception End_Error is raised, Note that blank\n    --  is defined as a space or horizontal tab (RM A.10.6(5)).\n \n    procedure Ungetc (ch : Integer; File : File_Type);"}, {"sha": "f7b49a11029f507baf4bfbe823c107ff72fa709f", "filename": "gcc/ada/libgnat/a-ztinau.adb", "status": "modified", "additions": 33, "deletions": 195, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-ztinau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-ztinau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztinau.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -31,61 +31,15 @@\n \n with Ada.Wide_Wide_Text_IO.Generic_Aux; use Ada.Wide_Wide_Text_IO.Generic_Aux;\n \n-with System.Img_BIU;   use System.Img_BIU;\n-with System.Img_Int;   use System.Img_Int;\n-with System.Img_LLB;   use System.Img_LLB;\n-with System.Img_LLI;   use System.Img_LLI;\n-with System.Img_LLW;   use System.Img_LLW;\n-with System.Img_WIU;   use System.Img_WIU;\n-with System.Val_Int;   use System.Val_Int;\n-with System.Val_LLI;   use System.Val_LLI;\n-\n package body Ada.Wide_Wide_Text_IO.Integer_Aux is\n \n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Load_Integer\n-     (File : File_Type;\n-      Buf  : out String;\n-      Ptr  : in out Natural);\n-   --  This is an auxiliary routine that is used to load an possibly signed\n-   --  integer literal value from the input file into Buf, starting at Ptr + 1.\n-   --  On return, Ptr is set to the last character stored.\n-\n-   -------------\n-   -- Get_Int --\n-   -------------\n-\n-   procedure Get_Int\n-     (File  : File_Type;\n-      Item  : out Integer;\n-      Width : Field)\n-   is\n-      Buf  : String (1 .. Field'Last);\n-      Ptr  : aliased Integer := 1;\n-      Stop : Integer := 0;\n-\n-   begin\n-      if Width /= 0 then\n-         Load_Width (File, Width, Buf, Stop);\n-         String_Skip (Buf, Ptr);\n-      else\n-         Load_Integer (File, Buf, Stop);\n-      end if;\n-\n-      Item := Scan_Integer (Buf, Ptr'Access, Stop);\n-      Check_End_Of_Field (Buf, Stop, Ptr, Width);\n-   end Get_Int;\n-\n-   -------------\n-   -- Get_LLI --\n-   -------------\n+   ---------\n+   -- Get --\n+   ---------\n \n-   procedure Get_LLI\n+   procedure Get\n      (File  : File_Type;\n-      Item  : out Long_Long_Integer;\n+      Item  : out Num;\n       Width : Field)\n    is\n       Buf  : String (1 .. Field'Last);\n@@ -100,196 +54,80 @@ package body Ada.Wide_Wide_Text_IO.Integer_Aux is\n          Load_Integer (File, Buf, Stop);\n       end if;\n \n-      Item := Scan_Long_Long_Integer (Buf, Ptr'Access, Stop);\n+      Item := Scan (Buf, Ptr'Access, Stop);\n       Check_End_Of_Field (Buf, Stop, Ptr, Width);\n-   end Get_LLI;\n+   end Get;\n \n-   --------------\n-   -- Gets_Int --\n-   --------------\n+   ----------\n+   -- Gets --\n+   ----------\n \n-   procedure Gets_Int\n+   procedure Gets\n      (From : String;\n-      Item : out Integer;\n+      Item : out Num;\n       Last : out Positive)\n    is\n       Pos : aliased Integer;\n \n    begin\n       String_Skip (From, Pos);\n-      Item := Scan_Integer (From, Pos'Access, From'Last);\n+      Item := Scan (From, Pos'Access, From'Last);\n       Last := Pos - 1;\n \n    exception\n       when Constraint_Error =>\n          raise Data_Error;\n-   end Gets_Int;\n-\n-   --------------\n-   -- Gets_LLI --\n-   --------------\n-\n-   procedure Gets_LLI\n-     (From : String;\n-      Item : out Long_Long_Integer;\n-      Last : out Positive)\n-   is\n-      Pos : aliased Integer;\n-\n-   begin\n-      String_Skip (From, Pos);\n-      Item := Scan_Long_Long_Integer (From, Pos'Access, From'Last);\n-      Last := Pos - 1;\n-\n-   exception\n-      when Constraint_Error =>\n-         raise Data_Error;\n-   end Gets_LLI;\n-\n-   ------------------\n-   -- Load_Integer --\n-   ------------------\n-\n-   procedure Load_Integer\n-     (File : File_Type;\n-      Buf  : out String;\n-      Ptr  : in out Natural)\n-   is\n-      Hash_Loc : Natural;\n-      Loaded   : Boolean;\n-\n-   begin\n-      Load_Skip (File);\n-      Load (File, Buf, Ptr, '+', '-');\n-\n-      Load_Digits (File, Buf, Ptr, Loaded);\n+   end Gets;\n \n-      if Loaded then\n+   ---------\n+   -- Put --\n+   ---------\n \n-         --  Deal with based case. We recognize either the standard '#' or the\n-         --  allowed alternative replacement ':' (see RM J.2(3)).\n-\n-         Load (File, Buf, Ptr, '#', ':', Loaded);\n-\n-         if Loaded then\n-            Hash_Loc := Ptr;\n-            Load_Extended_Digits (File, Buf, Ptr);\n-            Load (File, Buf, Ptr, Buf (Hash_Loc));\n-         end if;\n-\n-         Load (File, Buf, Ptr, 'E', 'e', Loaded);\n-\n-         if Loaded then\n-\n-            --  Note: it is strange to allow a minus sign, since the syntax\n-            --  does not, but that is what ACVC test CE3704F, case (6) wants.\n-\n-            Load (File, Buf, Ptr, '+', '-');\n-            Load_Digits (File, Buf, Ptr);\n-         end if;\n-      end if;\n-   end Load_Integer;\n-\n-   -------------\n-   -- Put_Int --\n-   -------------\n-\n-   procedure Put_Int\n+   procedure Put\n      (File  : File_Type;\n-      Item  : Integer;\n+      Item  : Num;\n       Width : Field;\n       Base  : Number_Base)\n    is\n-      Buf : String (1 .. Field'Last);\n+      Buf : String (1 .. Integer'Max (Field'Last, Width));\n       Ptr : Natural := 0;\n \n    begin\n       if Base = 10 and then Width = 0 then\n-         Set_Image_Integer (Item, Buf, Ptr);\n+         Set_Image (Item, Buf, Ptr);\n       elsif Base = 10 then\n-         Set_Image_Width_Integer (Item, Width, Buf, Ptr);\n+         Set_Image_Width (Item, Width, Buf, Ptr);\n       else\n-         Set_Image_Based_Integer (Item, Base, Width, Buf, Ptr);\n+         Set_Image_Based (Item, Base, Width, Buf, Ptr);\n       end if;\n \n       Put_Item (File, Buf (1 .. Ptr));\n-   end Put_Int;\n-\n-   -------------\n-   -- Put_LLI --\n-   -------------\n-\n-   procedure Put_LLI\n-     (File  : File_Type;\n-      Item  : Long_Long_Integer;\n-      Width : Field;\n-      Base  : Number_Base)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      if Base = 10 and then Width = 0 then\n-         Set_Image_Long_Long_Integer (Item, Buf, Ptr);\n-      elsif Base = 10 then\n-         Set_Image_Width_Long_Long_Integer (Item, Width, Buf, Ptr);\n-      else\n-         Set_Image_Based_Long_Long_Integer (Item, Base, Width, Buf, Ptr);\n-      end if;\n-\n-      Put_Item (File, Buf (1 .. Ptr));\n-   end Put_LLI;\n-\n-   --------------\n-   -- Puts_Int --\n-   --------------\n-\n-   procedure Puts_Int\n-     (To   : out String;\n-      Item : Integer;\n-      Base : Number_Base)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      if Base = 10 then\n-         Set_Image_Width_Integer (Item, To'Length, Buf, Ptr);\n-      else\n-         Set_Image_Based_Integer (Item, Base, To'Length, Buf, Ptr);\n-      end if;\n-\n-      if Ptr > To'Length then\n-         raise Layout_Error;\n-      else\n-         To (To'First .. To'First + Ptr - 1) := Buf (1 .. Ptr);\n-      end if;\n-   end Puts_Int;\n+   end Put;\n \n-   --------------\n-   -- Puts_LLI --\n-   --------------\n+   ----------\n+   -- Puts --\n+   ----------\n \n-   procedure Puts_LLI\n+   procedure Puts\n      (To   : out String;\n-      Item : Long_Long_Integer;\n+      Item : Num;\n       Base : Number_Base)\n    is\n-      Buf : String (1 .. Field'Last);\n+      Buf : String (1 .. Integer'Max (Field'Last, To'Length));\n       Ptr : Natural := 0;\n \n    begin\n       if Base = 10 then\n-         Set_Image_Width_Long_Long_Integer (Item, To'Length, Buf, Ptr);\n+         Set_Image_Width (Item, To'Length, Buf, Ptr);\n       else\n-         Set_Image_Based_Long_Long_Integer (Item, Base, To'Length, Buf, Ptr);\n+         Set_Image_Based (Item, Base, To'Length, Buf, Ptr);\n       end if;\n \n       if Ptr > To'Length then\n          raise Layout_Error;\n       else\n          To (To'First .. To'First + Ptr - 1) := Buf (1 .. Ptr);\n       end if;\n-   end Puts_LLI;\n+   end Puts;\n \n end Ada.Wide_Wide_Text_IO.Integer_Aux;"}, {"sha": "914f12013a3ce73448645b1101fdae3f025cb957", "filename": "gcc/ada/libgnat/a-ztinau.ads", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-ztinau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-ztinau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztinau.ads?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -2,7 +2,7 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---    A D A . W I D E _ W I D E _ T E X T _ I O . I N T E G E R _ A U X     --\n+--    A D A . W I D E _ W I D E _ T E X T _ I O . I N T E G E R  _ A U X    --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n@@ -29,55 +29,45 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the routines for Ada.Wide_Wide_Text_IO.Integer_IO\n---  that are shared among separate instantiations of this package. The routines\n---  in this package are identical semantically to those in Integer_IO itself,\n---  except that the generic parameter Num has been replaced by Integer or\n---  Long_Long_Integer, and the default parameters have been removed because\n---  they are supplied explicitly by the calls from within the generic template.\n+--  This package contains implementation for Ada.Wide_Wide.Text_IO.Integer_IO\n+--  and Ada.Wide_Wide_Text_IO.Modular_IO. The routines in this package are\n+--  identical semantically to those in Integer_IO and Modular_IO themselves,\n+--  except that the default parameters have been removed because they are\n+--  supplied explicitly by the calls from within these units.\n \n-private package Ada.Wide_Wide_Text_IO.Integer_Aux is\n+private generic\n+   type Num is (<>);\n \n-   procedure Get_Int\n-     (File  : File_Type;\n-      Item  : out Integer;\n-      Width : Field);\n+   with function Scan\n+     (Str : String; Ptr : not null access Integer; Max : Integer) return Num;\n+   with procedure Set_Image\n+     (V : Num; S : in out String; P : in out Natural);\n+   with procedure Set_Image_Width\n+     (V : Num; W : Integer; S : out String; P : in out Natural);\n+   with procedure Set_Image_Based\n+     (V : Num; B : Natural; W : Integer; S : out String; P : in out Natural);\n \n-   procedure Get_LLI\n+package Ada.Wide_Wide_Text_IO.Integer_Aux is\n+\n+   procedure Get\n      (File  : File_Type;\n-      Item  : out Long_Long_Integer;\n+      Item  : out Num;\n       Width : Field);\n \n-   procedure Gets_Int\n+   procedure Gets\n      (From : String;\n-      Item : out Integer;\n+      Item : out Num;\n       Last : out Positive);\n \n-   procedure Gets_LLI\n-     (From : String;\n-      Item : out Long_Long_Integer;\n-      Last : out Positive);\n-\n-   procedure Put_Int\n+   procedure Put\n      (File  : File_Type;\n-      Item  : Integer;\n+      Item  : Num;\n       Width : Field;\n       Base  : Number_Base);\n \n-   procedure Put_LLI\n-     (File  : File_Type;\n-      Item  : Long_Long_Integer;\n-      Width : Field;\n-      Base  : Number_Base);\n-\n-   procedure Puts_Int\n-     (To   : out String;\n-      Item : Integer;\n-      Base : Number_Base);\n-\n-   procedure Puts_LLI\n+   procedure Puts\n      (To   : out String;\n-      Item : Long_Long_Integer;\n+      Item : Num;\n       Base : Number_Base);\n \n end Ada.Wide_Wide_Text_IO.Integer_Aux;"}, {"sha": "ab8741ee027e0ff168a18ff1aa7db073c780e322", "filename": "gcc/ada/libgnat/a-ztinio.adb", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-ztinio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-ztinio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztinio.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -30,11 +30,35 @@\n ------------------------------------------------------------------------------\n \n with Ada.Wide_Wide_Text_IO.Integer_Aux;\n+with System.Img_BIU; use System.Img_BIU;\n+with System.Img_Int; use System.Img_Int;\n+with System.Img_LLB; use System.Img_LLB;\n+with System.Img_LLI; use System.Img_LLI;\n+with System.Img_LLW; use System.Img_LLW;\n+with System.Img_WIU; use System.Img_WIU;\n+with System.Val_Int; use System.Val_Int;\n+with System.Val_LLI; use System.Val_LLI;\n with System.WCh_Con; use System.WCh_Con;\n with System.WCh_WtS; use System.WCh_WtS;\n \n package body Ada.Wide_Wide_Text_IO.Integer_IO is\n \n+   package Aux_Int is new\n+     Ada.Wide_Wide_Text_IO.Integer_Aux\n+       (Integer,\n+        Scan_Integer,\n+        Set_Image_Integer,\n+        Set_Image_Width_Integer,\n+        Set_Image_Based_Integer);\n+\n+   package Aux_LLI is new\n+     Ada.Wide_Wide_Text_IO.Integer_Aux\n+       (Long_Long_Integer,\n+        Scan_Long_Long_Integer,\n+        Set_Image_Long_Long_Integer,\n+        Set_Image_Width_Long_Long_Integer,\n+        Set_Image_Based_Long_Long_Integer);\n+\n    Need_LLI : constant Boolean := Num'Base'Size > Integer'Size;\n    --  Throughout this generic body, we distinguish between the case where type\n    --  Integer is acceptable, and where a Long_Long_Integer is needed. This\n@@ -44,8 +68,6 @@ package body Ada.Wide_Wide_Text_IO.Integer_IO is\n    subtype TFT is Ada.Wide_Wide_Text_IO.File_Type;\n    --  File type required for calls to routines in Aux\n \n-   package Aux renames Ada.Wide_Wide_Text_IO.Integer_Aux;\n-\n    ---------\n    -- Get --\n    ---------\n@@ -55,11 +77,16 @@ package body Ada.Wide_Wide_Text_IO.Integer_IO is\n       Item  : out Num;\n       Width : Field := 0)\n    is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+      pragma Unsuppress (Overflow_Check);\n+\n    begin\n       if Need_LLI then\n-         Aux.Get_LLI (TFT (File), Long_Long_Integer (Item), Width);\n+         Aux_LLI.Get (TFT (File), Long_Long_Integer (Item), Width);\n       else\n-         Aux.Get_Int (TFT (File), Integer (Item), Width);\n+         Aux_Int.Get (TFT (File), Integer (Item), Width);\n       end if;\n \n    exception\n@@ -79,6 +106,11 @@ package body Ada.Wide_Wide_Text_IO.Integer_IO is\n       Item : out Num;\n       Last : out Positive)\n    is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+      pragma Unsuppress (Overflow_Check);\n+\n       S : constant String := Wide_Wide_String_To_String (From, WCEM_Upper);\n       --  String on which we do the actual conversion. Note that the method\n       --  used for wide character encoding is irrelevant, since if there is\n@@ -87,9 +119,9 @@ package body Ada.Wide_Wide_Text_IO.Integer_IO is\n \n    begin\n       if Need_LLI then\n-         Aux.Gets_LLI (S, Long_Long_Integer (Item), Last);\n+         Aux_LLI.Gets (S, Long_Long_Integer (Item), Last);\n       else\n-         Aux.Gets_Int (S, Integer (Item), Last);\n+         Aux_Int.Gets (S, Integer (Item), Last);\n       end if;\n \n    exception\n@@ -108,9 +140,9 @@ package body Ada.Wide_Wide_Text_IO.Integer_IO is\n    is\n    begin\n       if Need_LLI then\n-         Aux.Put_LLI (TFT (File), Long_Long_Integer (Item), Width, Base);\n+         Aux_LLI.Put (TFT (File), Long_Long_Integer (Item), Width, Base);\n       else\n-         Aux.Put_Int (TFT (File), Integer (Item), Width, Base);\n+         Aux_Int.Put (TFT (File), Integer (Item), Width, Base);\n       end if;\n    end Put;\n \n@@ -132,9 +164,9 @@ package body Ada.Wide_Wide_Text_IO.Integer_IO is\n \n    begin\n       if Need_LLI then\n-         Aux.Puts_LLI (S, Long_Long_Integer (Item), Base);\n+         Aux_LLI.Puts (S, Long_Long_Integer (Item), Base);\n       else\n-         Aux.Puts_Int (S, Integer (Item), Base);\n+         Aux_Int.Puts (S, Integer (Item), Base);\n       end if;\n \n       for J in S'Range loop"}, {"sha": "c809eebd8a4e3dc3bc2d456838df30077e996f30", "filename": "gcc/ada/libgnat/a-ztinio__128.adb", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-ztinio__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-ztinio__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztinio__128.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -0,0 +1,199 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--      A D A . W I D E _ W I D E _ T E X T _ I O . I N T E G E R _ I O     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Wide_Text_IO.Integer_Aux;\n+with System.Img_BIU;  use System.Img_BIU;\n+with System.Img_Int;  use System.Img_Int;\n+with System.Img_LLB;  use System.Img_LLB;\n+with System.Img_LLI;  use System.Img_LLI;\n+with System.Img_LLW;  use System.Img_LLW;\n+with System.Img_LLLB; use System.Img_LLLB;\n+with System.Img_LLLI; use System.Img_LLLI;\n+with System.Img_LLLW; use System.Img_LLLW;\n+with System.Img_WIU;  use System.Img_WIU;\n+with System.Val_Int;  use System.Val_Int;\n+with System.Val_LLI;  use System.Val_LLI;\n+with System.Val_LLLI; use System.Val_LLLI;\n+with System.WCh_Con;  use System.WCh_Con;\n+with System.WCh_WtS;  use System.WCh_WtS;\n+\n+package body Ada.Wide_Wide_Text_IO.Integer_IO is\n+\n+   package Aux_Int is new\n+     Ada.Wide_Wide_Text_IO.Integer_Aux\n+       (Integer,\n+        Scan_Integer,\n+        Set_Image_Integer,\n+        Set_Image_Width_Integer,\n+        Set_Image_Based_Integer);\n+\n+   package Aux_LLI is new\n+     Ada.Wide_Wide_Text_IO.Integer_Aux\n+       (Long_Long_Integer,\n+        Scan_Long_Long_Integer,\n+        Set_Image_Long_Long_Integer,\n+        Set_Image_Width_Long_Long_Integer,\n+        Set_Image_Based_Long_Long_Integer);\n+\n+   package Aux_LLLI is new\n+     Ada.Wide_Wide_Text_IO.Integer_Aux\n+       (Long_Long_Long_Integer,\n+        Scan_Long_Long_Long_Integer,\n+        Set_Image_Long_Long_Long_Integer,\n+        Set_Image_Width_Long_Long_Long_Integer,\n+        Set_Image_Based_Long_Long_Long_Integer);\n+\n+   Need_LLI  : constant Boolean := Num'Base'Size > Integer'Size;\n+   Need_LLLI : constant Boolean := Num'Base'Size > Long_Long_Integer'Size;\n+   --  Throughout this generic body, we distinguish between cases where type\n+   --  Integer is acceptable, where type Long_Long_Integer is acceptable and\n+   --  where type Long_Long_Long_Integer is needed. These boolean constants\n+   --  are used to test for these cases and since they are constant, only code\n+   --  for the relevant case will be included in the instance.\n+\n+   subtype TFT is Ada.Wide_Wide_Text_IO.File_Type;\n+   --  File type required for calls to routines in Aux\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   procedure Get\n+     (File  : File_Type;\n+      Item  : out Num;\n+      Width : Field := 0)\n+   is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+      pragma Unsuppress (Overflow_Check);\n+\n+   begin\n+      if Need_LLLI then\n+         Aux_LLLI.Get (TFT (File), Long_Long_Long_Integer (Item), Width);\n+      elsif Need_LLI then\n+         Aux_LLI.Get (TFT (File), Long_Long_Integer (Item), Width);\n+      else\n+         Aux_Int.Get (TFT (File), Integer (Item), Width);\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   procedure Get\n+     (Item  : out Num;\n+      Width : Field := 0)\n+   is\n+   begin\n+      Get (Current_Input, Item, Width);\n+   end Get;\n+\n+   procedure Get\n+     (From : Wide_Wide_String;\n+      Item : out Num;\n+      Last : out Positive)\n+   is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+      pragma Unsuppress (Overflow_Check);\n+\n+      S : constant String := Wide_Wide_String_To_String (From, WCEM_Upper);\n+      --  String on which we do the actual conversion. Note that the method\n+      --  used for wide character encoding is irrelevant, since if there is\n+      --  a character outside the Standard.Character range then the call to\n+      --  Aux.Gets will raise Data_Error in any case.\n+\n+   begin\n+      if Need_LLLI then\n+         Aux_LLLI.Gets (S, Long_Long_Long_Integer (Item), Last);\n+      elsif Need_LLI then\n+         Aux_LLI.Gets (S, Long_Long_Integer (Item), Last);\n+      else\n+         Aux_Int.Gets (S, Integer (Item), Last);\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (File  : File_Type;\n+      Item  : Num;\n+      Width : Field := Default_Width;\n+      Base  : Number_Base := Default_Base)\n+   is\n+   begin\n+      if Need_LLLI then\n+         Aux_LLLI.Put (TFT (File), Long_Long_Long_Integer (Item), Width, Base);\n+      elsif Need_LLI then\n+         Aux_LLI.Put (TFT (File), Long_Long_Integer (Item), Width, Base);\n+      else\n+         Aux_Int.Put (TFT (File), Integer (Item), Width, Base);\n+      end if;\n+   end Put;\n+\n+   procedure Put\n+     (Item  : Num;\n+      Width : Field := Default_Width;\n+      Base  : Number_Base := Default_Base)\n+   is\n+   begin\n+      Put (Current_Output, Item, Width, Base);\n+   end Put;\n+\n+   procedure Put\n+     (To   : out Wide_Wide_String;\n+      Item : Num;\n+      Base : Number_Base := Default_Base)\n+   is\n+      S : String (To'First .. To'Last);\n+\n+   begin\n+      if Need_LLLI then\n+         Aux_LLLI.Puts (S, Long_Long_Long_Integer (Item), Base);\n+      elsif Need_LLI then\n+         Aux_LLI.Puts (S, Long_Long_Integer (Item), Base);\n+      else\n+         Aux_Int.Puts (S, Integer (Item), Base);\n+      end if;\n+\n+      for J in S'Range loop\n+         To (J) := Wide_Wide_Character'Val (Character'Pos (S (J)));\n+      end loop;\n+   end Put;\n+\n+end Ada.Wide_Wide_Text_IO.Integer_IO;"}, {"sha": "2f179e2785e1915828cb9c00a3e55fb201846e0e", "filename": "gcc/ada/libgnat/a-ztmoau.adb", "status": "removed", "additions": 0, "deletions": 305, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd2e6f249e55c810c0414572807face97d88f07/gcc%2Fada%2Flibgnat%2Fa-ztmoau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd2e6f249e55c810c0414572807face97d88f07/gcc%2Fada%2Flibgnat%2Fa-ztmoau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztmoau.adb?ref=4cd2e6f249e55c810c0414572807face97d88f07", "patch": "@@ -1,305 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---    A D A . W I D E _ W I D E _ T E X T _ I O . M O D U L A R  _ A U X    --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Wide_Wide_Text_IO.Generic_Aux; use Ada.Wide_Wide_Text_IO.Generic_Aux;\n-\n-with System.Img_BIU;   use System.Img_BIU;\n-with System.Img_Uns;   use System.Img_Uns;\n-with System.Img_LLB;   use System.Img_LLB;\n-with System.Img_LLU;   use System.Img_LLU;\n-with System.Img_LLW;   use System.Img_LLW;\n-with System.Img_WIU;   use System.Img_WIU;\n-with System.Val_Uns;   use System.Val_Uns;\n-with System.Val_LLU;   use System.Val_LLU;\n-\n-package body Ada.Wide_Wide_Text_IO.Modular_Aux is\n-\n-   use System.Unsigned_Types;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Load_Modular\n-     (File : File_Type;\n-      Buf  : out String;\n-      Ptr  : in out Natural);\n-   --  This is an auxiliary routine that is used to load an possibly signed\n-   --  modular literal value from the input file into Buf, starting at Ptr + 1.\n-   --  Ptr is left set to the last character stored.\n-\n-   -------------\n-   -- Get_LLU --\n-   -------------\n-\n-   procedure Get_LLU\n-     (File  : File_Type;\n-      Item  : out Long_Long_Unsigned;\n-      Width : Field)\n-   is\n-      Buf  : String (1 .. Field'Last);\n-      Stop : Integer := 0;\n-      Ptr  : aliased Integer := 1;\n-\n-   begin\n-      if Width /= 0 then\n-         Load_Width (File, Width, Buf, Stop);\n-         String_Skip (Buf, Ptr);\n-      else\n-         Load_Modular (File, Buf, Stop);\n-      end if;\n-\n-      Item := Scan_Long_Long_Unsigned (Buf, Ptr'Access, Stop);\n-      Check_End_Of_Field (Buf, Stop, Ptr, Width);\n-   end Get_LLU;\n-\n-   -------------\n-   -- Get_Uns --\n-   -------------\n-\n-   procedure Get_Uns\n-     (File  : File_Type;\n-      Item  : out Unsigned;\n-      Width : Field)\n-   is\n-      Buf  : String (1 .. Field'Last);\n-      Stop : Integer := 0;\n-      Ptr  : aliased Integer := 1;\n-\n-   begin\n-      if Width /= 0 then\n-         Load_Width (File, Width, Buf, Stop);\n-         String_Skip (Buf, Ptr);\n-      else\n-         Load_Modular (File, Buf, Stop);\n-      end if;\n-\n-      Item := Scan_Unsigned (Buf, Ptr'Access, Stop);\n-      Check_End_Of_Field (Buf, Stop, Ptr, Width);\n-   end Get_Uns;\n-\n-   --------------\n-   -- Gets_LLU --\n-   --------------\n-\n-   procedure Gets_LLU\n-     (From : String;\n-      Item : out Long_Long_Unsigned;\n-      Last : out Positive)\n-   is\n-      Pos : aliased Integer;\n-\n-   begin\n-      String_Skip (From, Pos);\n-      Item := Scan_Long_Long_Unsigned (From, Pos'Access, From'Last);\n-      Last := Pos - 1;\n-\n-   exception\n-      when Constraint_Error =>\n-         raise Data_Error;\n-   end Gets_LLU;\n-\n-   --------------\n-   -- Gets_Uns --\n-   --------------\n-\n-   procedure Gets_Uns\n-     (From : String;\n-      Item : out Unsigned;\n-      Last : out Positive)\n-   is\n-      Pos : aliased Integer;\n-\n-   begin\n-      String_Skip (From, Pos);\n-      Item := Scan_Unsigned (From, Pos'Access, From'Last);\n-      Last := Pos - 1;\n-\n-   exception\n-      when Constraint_Error =>\n-         raise Data_Error;\n-   end Gets_Uns;\n-\n-   ------------------\n-   -- Load_Modular --\n-   ------------------\n-\n-   procedure Load_Modular\n-     (File : File_Type;\n-      Buf  : out String;\n-      Ptr  : in out Natural)\n-   is\n-      Hash_Loc : Natural;\n-      Loaded   : Boolean;\n-\n-   begin\n-      Load_Skip (File);\n-\n-      --  Note: it is a bit strange to allow a minus sign here, but it seems\n-      --  consistent with the general behavior expected by the ACVC tests\n-      --  which is to scan past junk and then signal data error, see ACVC\n-      --  test CE3704F, case (6), which is for signed integer exponents,\n-      --  which seems a similar case.\n-\n-      Load (File, Buf, Ptr, '+', '-');\n-      Load_Digits (File, Buf, Ptr, Loaded);\n-\n-      if Loaded then\n-\n-         --  Deal with based case. We recognize either the standard '#' or the\n-         --  allowed alternative replacement ':' (see RM J.2(3)).\n-\n-         Load (File, Buf, Ptr, '#', ':', Loaded);\n-\n-         if Loaded then\n-            Hash_Loc := Ptr;\n-            Load_Extended_Digits (File, Buf, Ptr);\n-            Load (File, Buf, Ptr, Buf (Hash_Loc));\n-         end if;\n-\n-         Load (File, Buf, Ptr, 'E', 'e', Loaded);\n-\n-         if Loaded then\n-\n-            --  Note: it is strange to allow a minus sign, since the syntax\n-            --  does not, but that is what ACVC test CE3704F, case (6) wants\n-            --  for the signed case, and there seems no good reason to treat\n-            --  exponents differently for the signed and unsigned cases.\n-\n-            Load (File, Buf, Ptr, '+', '-');\n-            Load_Digits (File, Buf, Ptr);\n-         end if;\n-      end if;\n-   end Load_Modular;\n-\n-   -------------\n-   -- Put_LLU --\n-   -------------\n-\n-   procedure Put_LLU\n-     (File  : File_Type;\n-      Item  : Long_Long_Unsigned;\n-      Width : Field;\n-      Base  : Number_Base)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      if Base = 10 and then Width = 0 then\n-         Set_Image_Long_Long_Unsigned (Item, Buf, Ptr);\n-      elsif Base = 10 then\n-         Set_Image_Width_Long_Long_Unsigned (Item, Width, Buf, Ptr);\n-      else\n-         Set_Image_Based_Long_Long_Unsigned (Item, Base, Width, Buf, Ptr);\n-      end if;\n-\n-      Put_Item (File, Buf (1 .. Ptr));\n-   end Put_LLU;\n-\n-   -------------\n-   -- Put_Uns --\n-   -------------\n-\n-   procedure Put_Uns\n-     (File  : File_Type;\n-      Item  : Unsigned;\n-      Width : Field;\n-      Base  : Number_Base)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      if Base = 10 and then Width = 0 then\n-         Set_Image_Unsigned (Item, Buf, Ptr);\n-      elsif Base = 10 then\n-         Set_Image_Width_Unsigned (Item, Width, Buf, Ptr);\n-      else\n-         Set_Image_Based_Unsigned (Item, Base, Width, Buf, Ptr);\n-      end if;\n-\n-      Put_Item (File, Buf (1 .. Ptr));\n-   end Put_Uns;\n-\n-   --------------\n-   -- Puts_LLU --\n-   --------------\n-\n-   procedure Puts_LLU\n-     (To   : out String;\n-      Item : Long_Long_Unsigned;\n-      Base : Number_Base)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      if Base = 10 then\n-         Set_Image_Width_Long_Long_Unsigned (Item, To'Length, Buf, Ptr);\n-      else\n-         Set_Image_Based_Long_Long_Unsigned (Item, Base, To'Length, Buf, Ptr);\n-      end if;\n-\n-      if Ptr > To'Length then\n-         raise Layout_Error;\n-      else\n-         To (To'First .. To'First + Ptr - 1) := Buf (1 .. Ptr);\n-      end if;\n-   end Puts_LLU;\n-\n-   --------------\n-   -- Puts_Uns --\n-   --------------\n-\n-   procedure Puts_Uns\n-     (To   : out String;\n-      Item : Unsigned;\n-      Base : Number_Base)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      if Base = 10 then\n-         Set_Image_Width_Unsigned (Item, To'Length, Buf, Ptr);\n-      else\n-         Set_Image_Based_Unsigned (Item, Base, To'Length, Buf, Ptr);\n-      end if;\n-\n-      if Ptr > To'Length then\n-         raise Layout_Error;\n-      else\n-         To (To'First .. To'First + Ptr - 1) := Buf (1 .. Ptr);\n-      end if;\n-   end Puts_Uns;\n-\n-end Ada.Wide_Wide_Text_IO.Modular_Aux;"}, {"sha": "9d531541705d6b6ac9cb60636d3005d21c08698f", "filename": "gcc/ada/libgnat/a-ztmoau.ads", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cd2e6f249e55c810c0414572807face97d88f07/gcc%2Fada%2Flibgnat%2Fa-ztmoau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cd2e6f249e55c810c0414572807face97d88f07/gcc%2Fada%2Flibgnat%2Fa-ztmoau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztmoau.ads?ref=4cd2e6f249e55c810c0414572807face97d88f07", "patch": "@@ -1,88 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---    A D A . W I D E _ W I D E _ T E X T _ I O . M O D U L A R _ A U X     --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains the routines for Ada.Wide_Wide_Text_IO.Modular_IO\n---  that are shared among separate instantiations of this package. The\n---  routines in this package are identical semantically to those in Modular_IO\n---  itself, except that the generic parameter Num has been replaced by\n---  Unsigned or Long_Long_Unsigned, and the default parameters have been\n---  removed because they are supplied explicitly by the calls from within the\n---  generic template.\n-\n-with System.Unsigned_Types;\n-\n-private package Ada.Wide_Wide_Text_IO.Modular_Aux is\n-\n-   package U renames System.Unsigned_Types;\n-\n-   procedure Get_Uns\n-     (File  : File_Type;\n-      Item  : out U.Unsigned;\n-      Width : Field);\n-\n-   procedure Get_LLU\n-     (File  : File_Type;\n-      Item  : out U.Long_Long_Unsigned;\n-      Width : Field);\n-\n-   procedure Gets_Uns\n-     (From : String;\n-      Item : out U.Unsigned;\n-      Last : out Positive);\n-\n-   procedure Gets_LLU\n-     (From : String;\n-      Item : out U.Long_Long_Unsigned;\n-      Last : out Positive);\n-\n-   procedure Put_Uns\n-     (File  : File_Type;\n-      Item  : U.Unsigned;\n-      Width : Field;\n-      Base  : Number_Base);\n-\n-   procedure Put_LLU\n-     (File  : File_Type;\n-      Item  : U.Long_Long_Unsigned;\n-      Width : Field;\n-      Base  : Number_Base);\n-\n-   procedure Puts_Uns\n-     (To   : out String;\n-      Item : U.Unsigned;\n-      Base : Number_Base);\n-\n-   procedure Puts_LLU\n-     (To   : out String;\n-      Item : U.Long_Long_Unsigned;\n-      Base : Number_Base);\n-\n-end Ada.Wide_Wide_Text_IO.Modular_Aux;"}, {"sha": "d2f81e2380c298afa25857377aebff0ff0153306", "filename": "gcc/ada/libgnat/a-ztmoio.adb", "status": "modified", "additions": 53, "deletions": 19, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-ztmoio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-ztmoio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztmoio.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -29,19 +29,45 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Wide_Wide_Text_IO.Modular_Aux;\n-\n-with System.Unsigned_Types; use System.Unsigned_Types;\n-with System.WCh_Con;        use System.WCh_Con;\n-with System.WCh_WtS;        use System.WCh_WtS;\n+with Ada.Wide_Wide_Text_IO.Integer_Aux;\n+with System.Img_BIU; use System.Img_BIU;\n+with System.Img_Uns; use System.Img_Uns;\n+with System.Img_LLB; use System.Img_LLB;\n+with System.Img_LLU; use System.Img_LLU;\n+with System.Img_LLW; use System.Img_LLW;\n+with System.Img_WIU; use System.Img_WIU;\n+with System.Val_Uns; use System.Val_Uns;\n+with System.Val_LLU; use System.Val_LLU;\n+with System.WCh_Con; use System.WCh_Con;\n+with System.WCh_WtS; use System.WCh_WtS;\n \n package body Ada.Wide_Wide_Text_IO.Modular_IO is\n \n+   package Aux_Uns is new\n+     Ada.Wide_Wide_Text_IO.Integer_Aux\n+       (Unsigned,\n+        Scan_Unsigned,\n+        Set_Image_Unsigned,\n+        Set_Image_Width_Unsigned,\n+        Set_Image_Based_Unsigned);\n+\n+   package Aux_LLU is new\n+     Ada.Wide_Wide_Text_IO.Integer_Aux\n+       (Long_Long_Unsigned,\n+        Scan_Long_Long_Unsigned,\n+        Set_Image_Long_Long_Unsigned,\n+        Set_Image_Width_Long_Long_Unsigned,\n+        Set_Image_Based_Long_Long_Unsigned);\n+\n+   Need_LLU : constant Boolean := Num'Base'Size > Unsigned'Size;\n+   --  Throughout this generic body, we distinguish between the case where type\n+   --  Unsigned is acceptable, and where a Long_Long_Unsigned is needed. This\n+   --  Boolean is used to test for these cases and since it is a constant, only\n+   --  code for the relevant case will be included in the instance.\n+\n    subtype TFT is Ada.Wide_Wide_Text_IO.File_Type;\n    --  File type required for calls to routines in Aux\n \n-   package Aux renames Ada.Wide_Wide_Text_IO.Modular_Aux;\n-\n    ---------\n    -- Get --\n    ---------\n@@ -51,11 +77,15 @@ package body Ada.Wide_Wide_Text_IO.Modular_IO is\n       Item  : out Num;\n       Width : Field := 0)\n    is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+\n    begin\n-      if Num'Size > Unsigned'Size then\n-         Aux.Get_LLU (TFT (File), Long_Long_Unsigned (Item), Width);\n+      if Need_LLU then\n+         Aux_LLU.Get (TFT (File), Long_Long_Unsigned (Item), Width);\n       else\n-         Aux.Get_Uns (TFT (File), Unsigned (Item), Width);\n+         Aux_Uns.Get (TFT (File), Unsigned (Item), Width);\n       end if;\n \n    exception\n@@ -75,17 +105,21 @@ package body Ada.Wide_Wide_Text_IO.Modular_IO is\n       Item : out Num;\n       Last : out Positive)\n    is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+\n       S : constant String := Wide_Wide_String_To_String (From, WCEM_Upper);\n       --  String on which we do the actual conversion. Note that the method\n       --  used for wide character encoding is irrelevant, since if there is\n       --  a character outside the Standard.Character range then the call to\n       --  Aux.Gets will raise Data_Error in any case.\n \n    begin\n-      if Num'Size > Unsigned'Size then\n-         Aux.Gets_LLU (S, Long_Long_Unsigned (Item), Last);\n+      if Need_LLU then\n+         Aux_LLU.Gets (S, Long_Long_Unsigned (Item), Last);\n       else\n-         Aux.Gets_Uns (S, Unsigned (Item), Last);\n+         Aux_Uns.Gets (S, Unsigned (Item), Last);\n       end if;\n \n    exception\n@@ -103,10 +137,10 @@ package body Ada.Wide_Wide_Text_IO.Modular_IO is\n       Base  : Number_Base := Default_Base)\n    is\n    begin\n-      if Num'Size > Unsigned'Size then\n-         Aux.Put_LLU (TFT (File), Long_Long_Unsigned (Item), Width, Base);\n+      if Need_LLU then\n+         Aux_LLU.Put (TFT (File), Long_Long_Unsigned (Item), Width, Base);\n       else\n-         Aux.Put_Uns (TFT (File), Unsigned (Item), Width, Base);\n+         Aux_Uns.Put (TFT (File), Unsigned (Item), Width, Base);\n       end if;\n    end Put;\n \n@@ -127,10 +161,10 @@ package body Ada.Wide_Wide_Text_IO.Modular_IO is\n       S : String (To'First .. To'Last);\n \n    begin\n-      if Num'Size > Unsigned'Size then\n-         Aux.Puts_LLU (S, Long_Long_Unsigned (Item), Base);\n+      if Need_LLU then\n+         Aux_LLU.Puts (S, Long_Long_Unsigned (Item), Base);\n       else\n-         Aux.Puts_Uns (S, Unsigned (Item), Base);\n+         Aux_Uns.Puts (S, Unsigned (Item), Base);\n       end if;\n \n       for J in S'Range loop"}, {"sha": "e6e11defa7abf27612939e606fe82ae5fc82f561", "filename": "gcc/ada/libgnat/a-ztmoio__128.adb", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-ztmoio__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38aca14a437d9adefe9d7f526aafa53a8e868749/gcc%2Fada%2Flibgnat%2Fa-ztmoio__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztmoio__128.adb?ref=38aca14a437d9adefe9d7f526aafa53a8e868749", "patch": "@@ -0,0 +1,197 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--      A D A . W I D E _ W I D E _ T E X T _ I O . M O D U L A R _ I O     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Wide_Text_IO.Integer_Aux;\n+with System.Img_BIU;  use System.Img_BIU;\n+with System.Img_Uns;  use System.Img_Uns;\n+with System.Img_LLB;  use System.Img_LLB;\n+with System.Img_LLU;  use System.Img_LLU;\n+with System.Img_LLW;  use System.Img_LLW;\n+with System.Img_LLLB; use System.Img_LLLB;\n+with System.Img_LLLU; use System.Img_LLLU;\n+with System.Img_LLLW; use System.Img_LLLW;\n+with System.Img_WIU;  use System.Img_WIU;\n+with System.Val_Uns;  use System.Val_Uns;\n+with System.Val_LLU;  use System.Val_LLU;\n+with System.Val_LLLU; use System.Val_LLLU;\n+with System.WCh_Con;  use System.WCh_Con;\n+with System.WCh_WtS;  use System.WCh_WtS;\n+\n+package body Ada.Wide_Wide_Text_IO.Modular_IO is\n+\n+   package Aux_Uns is new\n+     Ada.Wide_Wide_Text_IO.Integer_Aux\n+       (Unsigned,\n+        Scan_Unsigned,\n+        Set_Image_Unsigned,\n+        Set_Image_Width_Unsigned,\n+        Set_Image_Based_Unsigned);\n+\n+   package Aux_LLU is new\n+     Ada.Wide_Wide_Text_IO.Integer_Aux\n+       (Long_Long_Unsigned,\n+        Scan_Long_Long_Unsigned,\n+        Set_Image_Long_Long_Unsigned,\n+        Set_Image_Width_Long_Long_Unsigned,\n+        Set_Image_Based_Long_Long_Unsigned);\n+\n+   package Aux_LLLU is new\n+     Ada.Wide_Wide_Text_IO.Integer_Aux\n+       (Long_Long_Long_Unsigned,\n+        Scan_Long_Long_Long_Unsigned,\n+        Set_Image_Long_Long_Long_Unsigned,\n+        Set_Image_Width_Long_Long_Long_Unsigned,\n+        Set_Image_Based_Long_Long_Long_Unsigned);\n+\n+   Need_LLU  : constant Boolean := Num'Base'Size > Unsigned'Size;\n+   Need_LLLU : constant Boolean := Num'Base'Size > Long_Long_Unsigned'Size;\n+   --  Throughout this generic body, we distinguish between cases where type\n+   --  Unsigned is acceptable, where type Long_Long_Unsigned is acceptable and\n+   --  where type Long_Long_Long_Unsigned is needed. These boolean constants\n+   --  are used to test for these cases and since they are constant, only code\n+   --  for the relevant case will be included in the instance.\n+\n+   subtype TFT is Ada.Wide_Wide_Text_IO.File_Type;\n+   --  File type required for calls to routines in Aux\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   procedure Get\n+     (File  : File_Type;\n+      Item  : out Num;\n+      Width : Field := 0)\n+   is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+\n+   begin\n+      if Need_LLLU then\n+         Aux_LLLU.Get (File, Long_Long_Long_Unsigned (Item), Width);\n+      elsif Need_LLU then\n+         Aux_LLU.Get (TFT (File), Long_Long_Unsigned (Item), Width);\n+      else\n+         Aux_Uns.Get (TFT (File), Unsigned (Item), Width);\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   procedure Get\n+     (Item  : out Num;\n+      Width : Field := 0)\n+   is\n+   begin\n+      Get (Current_Input, Item, Width);\n+   end Get;\n+\n+   procedure Get\n+     (From : Wide_Wide_String;\n+      Item : out Num;\n+      Last : out Positive)\n+   is\n+      --  We depend on a range check to get Data_Error\n+\n+      pragma Unsuppress (Range_Check);\n+\n+      S : constant String := Wide_Wide_String_To_String (From, WCEM_Upper);\n+      --  String on which we do the actual conversion. Note that the method\n+      --  used for wide character encoding is irrelevant, since if there is\n+      --  a character outside the Standard.Character range then the call to\n+      --  Aux.Gets will raise Data_Error in any case.\n+\n+   begin\n+      if Need_LLLU then\n+         Aux_LLLU.Gets (S, Long_Long_Long_Unsigned (Item), Last);\n+      elsif Need_LLU then\n+         Aux_LLU.Gets (S, Long_Long_Unsigned (Item), Last);\n+      else\n+         Aux_Uns.Gets (S, Unsigned (Item), Last);\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (File  : File_Type;\n+      Item  : Num;\n+      Width : Field := Default_Width;\n+      Base  : Number_Base := Default_Base)\n+   is\n+   begin\n+      if Need_LLLU then\n+         Aux_LLLU.Put (File, Long_Long_Long_Unsigned (Item), Width, Base);\n+      elsif Need_LLU then\n+         Aux_LLU.Put (TFT (File), Long_Long_Unsigned (Item), Width, Base);\n+      else\n+         Aux_Uns.Put (TFT (File), Unsigned (Item), Width, Base);\n+      end if;\n+   end Put;\n+\n+   procedure Put\n+     (Item  : Num;\n+      Width : Field := Default_Width;\n+      Base  : Number_Base := Default_Base)\n+   is\n+   begin\n+      Put (Current_Output, Item, Width, Base);\n+   end Put;\n+\n+   procedure Put\n+     (To   : out Wide_Wide_String;\n+      Item : Num;\n+      Base : Number_Base := Default_Base)\n+   is\n+      S : String (To'First .. To'Last);\n+\n+   begin\n+      if Need_LLLU then\n+         Aux_LLLU.Puts (S, Long_Long_Long_Unsigned (Item), Base);\n+      elsif Need_LLU then\n+         Aux_LLU.Puts (S, Long_Long_Unsigned (Item), Base);\n+      else\n+         Aux_Uns.Puts (S, Unsigned (Item), Base);\n+      end if;\n+\n+      for J in S'Range loop\n+         To (J) := Wide_Wide_Character'Val (Character'Pos (S (J)));\n+      end loop;\n+   end Put;\n+\n+end Ada.Wide_Wide_Text_IO.Modular_IO;"}]}