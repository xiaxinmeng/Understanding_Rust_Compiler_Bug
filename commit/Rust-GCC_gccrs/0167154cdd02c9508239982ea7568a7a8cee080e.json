{"sha": "0167154cdd02c9508239982ea7568a7a8cee080e", "node_id": "C_kwDOANBUbNoAKDAxNjcxNTRjZGQwMmM5NTA4MjM5OTgyZWE3NTY4YTdhOGNlZTA4MGU", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-10-05T00:19:06Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-10-05T00:19:06Z"}, "message": "analyzer: move region_model_manager decl to its own header\n\ngcc/analyzer/ChangeLog:\n\t* region-model.h: Include \"analyzer/region-model-manager.h\"\n\t(class region_model_manager): Move decl to...\n\t* region-model-manager.h: ...this new file.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "95c4a82a956608ecc420826e7f481913a5b77183", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95c4a82a956608ecc420826e7f481913a5b77183"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0167154cdd02c9508239982ea7568a7a8cee080e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0167154cdd02c9508239982ea7568a7a8cee080e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0167154cdd02c9508239982ea7568a7a8cee080e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0167154cdd02c9508239982ea7568a7a8cee080e/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f42f7adfa69fea029fbb76286048f712bb017ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f42f7adfa69fea029fbb76286048f712bb017ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f42f7adfa69fea029fbb76286048f712bb017ff"}], "stats": {"total": 601, "additions": 313, "deletions": 288}, "files": [{"sha": "0057326b78ff5e4dcad0d6e22c263ff89768da4c", "filename": "gcc/analyzer/region-model-manager.h", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0167154cdd02c9508239982ea7568a7a8cee080e/gcc%2Fanalyzer%2Fregion-model-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0167154cdd02c9508239982ea7568a7a8cee080e/gcc%2Fanalyzer%2Fregion-model-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.h?ref=0167154cdd02c9508239982ea7568a7a8cee080e", "patch": "@@ -0,0 +1,312 @@\n+/* Consolidation of svalues and regions.\n+   Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_ANALYZER_REGION_MODEL_MANAGER_H\n+#define GCC_ANALYZER_REGION_MODEL_MANAGER_H\n+\n+namespace ana {\n+\n+/* A class responsible for owning and consolidating region and svalue\n+   instances.\n+   region and svalue instances are immutable as far as clients are\n+   concerned, so they are provided as \"const\" ptrs.  */\n+\n+class region_model_manager\n+{\n+public:\n+  region_model_manager (logger *logger = NULL);\n+  ~region_model_manager ();\n+\n+  /* call_string consolidation.  */\n+  const call_string &get_empty_call_string () const\n+  {\n+    return m_empty_call_string;\n+  }\n+\n+  /* svalue consolidation.  */\n+  const svalue *get_or_create_constant_svalue (tree cst_expr);\n+  const svalue *get_or_create_int_cst (tree type, poly_int64);\n+  const svalue *get_or_create_unknown_svalue (tree type);\n+  const svalue *get_or_create_setjmp_svalue (const setjmp_record &r,\n+\t\t\t\t\t     tree type);\n+  const svalue *get_or_create_poisoned_svalue (enum poison_kind kind,\n+\t\t\t\t\t       tree type);\n+  const svalue *get_or_create_initial_value (const region *reg);\n+  const svalue *get_ptr_svalue (tree ptr_type, const region *pointee);\n+  const svalue *get_or_create_unaryop (tree type, enum tree_code op,\n+\t\t\t\t       const svalue *arg);\n+  const svalue *get_or_create_cast (tree type, const svalue *arg);\n+  const svalue *get_or_create_binop (tree type,\n+\t\t\t\t     enum tree_code op,\n+\t\t\t\t     const svalue *arg0, const svalue *arg1);\n+  const svalue *get_or_create_sub_svalue (tree type,\n+\t\t\t\t\t  const svalue *parent_svalue,\n+\t\t\t\t\t  const region *subregion);\n+  const svalue *get_or_create_repeated_svalue (tree type,\n+\t\t\t\t\t       const svalue *outer_size,\n+\t\t\t\t\t       const svalue *inner_svalue);\n+  const svalue *get_or_create_bits_within (tree type,\n+\t\t\t\t\t   const bit_range &bits,\n+\t\t\t\t\t   const svalue *inner_svalue);\n+  const svalue *get_or_create_unmergeable (const svalue *arg);\n+  const svalue *get_or_create_widening_svalue (tree type,\n+\t\t\t\t\t       const function_point &point,\n+\t\t\t\t\t       const svalue *base_svalue,\n+\t\t\t\t\t       const svalue *iter_svalue);\n+  const svalue *get_or_create_compound_svalue (tree type,\n+\t\t\t\t\t       const binding_map &map);\n+  const svalue *get_or_create_conjured_svalue (tree type, const gimple *stmt,\n+\t\t\t\t\t       const region *id_reg,\n+\t\t\t\t\t       const conjured_purge &p);\n+  const svalue *\n+  get_or_create_asm_output_svalue (tree type,\n+\t\t\t\t   const gasm *asm_stmt,\n+\t\t\t\t   unsigned output_idx,\n+\t\t\t\t   const vec<const svalue *> &inputs);\n+  const svalue *\n+  get_or_create_const_fn_result_svalue (tree type,\n+\t\t\t\t\ttree fndecl,\n+\t\t\t\t\tconst vec<const svalue *> &inputs);\n+\n+  const svalue *maybe_get_char_from_string_cst (tree string_cst,\n+\t\t\t\t\t\ttree byte_offset_cst);\n+\n+  /* Dynamically-allocated svalue instances.\n+     The number of these within the analysis can grow arbitrarily.\n+     They are still owned by the manager.  */\n+  const svalue *create_unique_svalue (tree type);\n+\n+  /* region consolidation.  */\n+  const stack_region * get_stack_region () const { return &m_stack_region; }\n+  const heap_region *get_heap_region () const { return &m_heap_region; }\n+  const code_region *get_code_region () const { return &m_code_region; }\n+  const globals_region *get_globals_region () const\n+  {\n+    return &m_globals_region;\n+  }\n+  const function_region *get_region_for_fndecl (tree fndecl);\n+  const label_region *get_region_for_label (tree label);\n+  const decl_region *get_region_for_global (tree expr);\n+  const region *get_field_region (const region *parent, tree field);\n+  const region *get_element_region (const region *parent,\n+\t\t\t\t    tree element_type,\n+\t\t\t\t    const svalue *index);\n+  const region *get_offset_region (const region *parent,\n+\t\t\t\t   tree type,\n+\t\t\t\t   const svalue *byte_offset);\n+  const region *get_sized_region (const region *parent,\n+\t\t\t\t  tree type,\n+\t\t\t\t  const svalue *byte_size_sval);\n+  const region *get_cast_region (const region *original_region,\n+\t\t\t\t tree type);\n+  const frame_region *get_frame_region (const frame_region *calling_frame,\n+\t\t\t\t\tfunction *fun);\n+  const region *get_symbolic_region (const svalue *sval);\n+  const string_region *get_region_for_string (tree string_cst);\n+  const region *get_bit_range (const region *parent, tree type,\n+\t\t\t       const bit_range &bits);\n+  const var_arg_region *get_var_arg_region (const frame_region *parent,\n+\t\t\t\t\t    unsigned idx);\n+\n+  const region *get_unknown_symbolic_region (tree region_type);\n+\n+  const region *\n+  get_region_for_unexpected_tree_code (region_model_context *ctxt,\n+\t\t\t\t       tree t,\n+\t\t\t\t       const dump_location_t &loc);\n+\n+  unsigned alloc_region_id () { return m_next_region_id++; }\n+\n+  store_manager *get_store_manager () { return &m_store_mgr; }\n+  bounded_ranges_manager *get_range_manager () const { return m_range_mgr; }\n+\n+  known_function_manager *get_known_function_manager ()\n+  {\n+    return &m_known_fn_mgr;\n+  }\n+\n+  /* Dynamically-allocated region instances.\n+     The number of these within the analysis can grow arbitrarily.\n+     They are still owned by the manager.  */\n+  const region *create_region_for_heap_alloc ();\n+  const region *create_region_for_alloca (const frame_region *frame);\n+\n+  void log_stats (logger *logger, bool show_objs) const;\n+\n+  void begin_checking_feasibility (void) { m_checking_feasibility = true; }\n+  void end_checking_feasibility (void) { m_checking_feasibility = false; }\n+\n+  logger *get_logger () const { return m_logger; }\n+\n+  void dump_untracked_regions () const;\n+\n+private:\n+  bool too_complex_p (const complexity &c) const;\n+  bool reject_if_too_complex (svalue *sval);\n+\n+  const svalue *maybe_fold_unaryop (tree type, enum tree_code op,\n+\t\t\t\t    const svalue *arg);\n+  const svalue *maybe_fold_binop (tree type, enum tree_code op,\n+\t\t\t\t  const svalue *arg0, const svalue *arg1);\n+  const svalue *maybe_fold_sub_svalue (tree type,\n+\t\t\t\t       const svalue *parent_svalue,\n+\t\t\t\t       const region *subregion);\n+  const svalue *maybe_fold_repeated_svalue (tree type,\n+\t\t\t\t\t    const svalue *outer_size,\n+\t\t\t\t\t    const svalue *inner_svalue);\n+  const svalue *maybe_fold_bits_within_svalue (tree type,\n+\t\t\t\t\t       const bit_range &bits,\n+\t\t\t\t\t       const svalue *inner_svalue);\n+  const svalue *maybe_undo_optimize_bit_field_compare (tree type,\n+\t\t\t\t\t\t       const compound_svalue *compound_sval,\n+\t\t\t\t\t\t       tree cst, const svalue *arg1);\n+  const svalue *maybe_fold_asm_output_svalue (tree type,\n+\t\t\t\t\t      const vec<const svalue *> &inputs);\n+\n+  logger *m_logger;\n+\n+  const call_string m_empty_call_string;\n+\n+  unsigned m_next_region_id;\n+  root_region m_root_region;\n+  stack_region m_stack_region;\n+  heap_region m_heap_region;\n+\n+  /* svalue consolidation.  */\n+  typedef hash_map<tree, constant_svalue *> constants_map_t;\n+  constants_map_t m_constants_map;\n+\n+  typedef hash_map<tree, unknown_svalue *> unknowns_map_t;\n+  unknowns_map_t m_unknowns_map;\n+  const unknown_svalue *m_unknown_NULL;\n+\n+  typedef hash_map<poisoned_svalue::key_t,\n+\t\t   poisoned_svalue *> poisoned_values_map_t;\n+  poisoned_values_map_t m_poisoned_values_map;\n+\n+  typedef hash_map<setjmp_svalue::key_t,\n+\t\t   setjmp_svalue *> setjmp_values_map_t;\n+  setjmp_values_map_t m_setjmp_values_map;\n+\n+  typedef hash_map<const region *, initial_svalue *> initial_values_map_t;\n+  initial_values_map_t m_initial_values_map;\n+\n+  typedef hash_map<region_svalue::key_t, region_svalue *> pointer_values_map_t;\n+  pointer_values_map_t m_pointer_values_map;\n+\n+  typedef hash_map<unaryop_svalue::key_t,\n+\t\t   unaryop_svalue *> unaryop_values_map_t;\n+  unaryop_values_map_t m_unaryop_values_map;\n+\n+  typedef hash_map<binop_svalue::key_t, binop_svalue *> binop_values_map_t;\n+  binop_values_map_t m_binop_values_map;\n+\n+  typedef hash_map<sub_svalue::key_t, sub_svalue *> sub_values_map_t;\n+  sub_values_map_t m_sub_values_map;\n+\n+  typedef hash_map<repeated_svalue::key_t,\n+\t\t   repeated_svalue *> repeated_values_map_t;\n+  repeated_values_map_t m_repeated_values_map;\n+\n+  typedef hash_map<bits_within_svalue::key_t,\n+\t\t   bits_within_svalue *> bits_within_values_map_t;\n+  bits_within_values_map_t m_bits_within_values_map;\n+\n+  typedef hash_map<const svalue *,\n+\t\t   unmergeable_svalue *> unmergeable_values_map_t;\n+  unmergeable_values_map_t m_unmergeable_values_map;\n+\n+  typedef hash_map<widening_svalue::key_t,\n+\t\t   widening_svalue */*,\n+\t\t   widening_svalue::key_t::hash_map_traits*/>\n+    widening_values_map_t;\n+  widening_values_map_t m_widening_values_map;\n+\n+  typedef hash_map<compound_svalue::key_t,\n+\t\t   compound_svalue *> compound_values_map_t;\n+  compound_values_map_t m_compound_values_map;\n+\n+  typedef hash_map<conjured_svalue::key_t,\n+\t\t   conjured_svalue *> conjured_values_map_t;\n+  conjured_values_map_t m_conjured_values_map;\n+\n+  typedef hash_map<asm_output_svalue::key_t,\n+\t\t   asm_output_svalue *> asm_output_values_map_t;\n+  asm_output_values_map_t m_asm_output_values_map;\n+\n+  typedef hash_map<const_fn_result_svalue::key_t,\n+\t\t   const_fn_result_svalue *> const_fn_result_values_map_t;\n+  const_fn_result_values_map_t m_const_fn_result_values_map;\n+\n+  bool m_checking_feasibility;\n+\n+  /* \"Dynamically-allocated\" svalue instances.\n+     The number of these within the analysis can grow arbitrarily.\n+     They are still owned by the manager.  */\n+  auto_delete_vec<svalue> m_managed_dynamic_svalues;\n+\n+  /* Maximum complexity of svalues that weren't rejected.  */\n+  complexity m_max_complexity;\n+\n+  /* region consolidation.  */\n+\n+  code_region m_code_region;\n+  typedef hash_map<tree, function_region *> fndecls_map_t;\n+  typedef fndecls_map_t::iterator fndecls_iterator_t;\n+  fndecls_map_t m_fndecls_map;\n+\n+  typedef hash_map<tree, label_region *> labels_map_t;\n+  typedef labels_map_t::iterator labels_iterator_t;\n+  labels_map_t m_labels_map;\n+\n+  globals_region m_globals_region;\n+  typedef hash_map<tree, decl_region *> globals_map_t;\n+  typedef globals_map_t::iterator globals_iterator_t;\n+  globals_map_t m_globals_map;\n+\n+  consolidation_map<field_region> m_field_regions;\n+  consolidation_map<element_region> m_element_regions;\n+  consolidation_map<offset_region> m_offset_regions;\n+  consolidation_map<sized_region> m_sized_regions;\n+  consolidation_map<cast_region> m_cast_regions;\n+  consolidation_map<frame_region> m_frame_regions;\n+  consolidation_map<symbolic_region> m_symbolic_regions;\n+\n+  typedef hash_map<tree, string_region *> string_map_t;\n+  string_map_t m_string_map;\n+\n+  consolidation_map<bit_range_region> m_bit_range_regions;\n+  consolidation_map<var_arg_region> m_var_arg_regions;\n+\n+  store_manager m_store_mgr;\n+\n+  bounded_ranges_manager *m_range_mgr;\n+\n+  known_function_manager m_known_fn_mgr;\n+\n+  /* \"Dynamically-allocated\" region instances.\n+     The number of these within the analysis can grow arbitrarily.\n+     They are still owned by the manager.  */\n+  auto_delete_vec<region> m_managed_dynamic_regions;\n+};\n+\n+} // namespace ana\n+\n+#endif /* GCC_ANALYZER_REGION_MODEL_MANAGER_H */"}, {"sha": "be0a97aebcc50c1680a9f74028b3fdaa5bd074bb", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 1, "deletions": 288, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0167154cdd02c9508239982ea7568a7a8cee080e/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0167154cdd02c9508239982ea7568a7a8cee080e/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=0167154cdd02c9508239982ea7568a7a8cee080e", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/svalue.h\"\n #include \"analyzer/region.h\"\n #include \"analyzer/known-function-manager.h\"\n+#include \"analyzer/region-model-manager.h\"\n \n using namespace ana;\n \n@@ -230,294 +231,6 @@ class visitor\n   virtual void visit_region (const region *) {}\n };\n \n-} // namespace ana\n-\n-namespace ana {\n-\n-/* A class responsible for owning and consolidating region and svalue\n-   instances.\n-   region and svalue instances are immutable as far as clients are\n-   concerned, so they are provided as \"const\" ptrs.  */\n-\n-class region_model_manager\n-{\n-public:\n-  region_model_manager (logger *logger = NULL);\n-  ~region_model_manager ();\n-\n-  /* call_string consolidation.  */\n-  const call_string &get_empty_call_string () const\n-  {\n-    return m_empty_call_string;\n-  }\n-\n-  /* svalue consolidation.  */\n-  const svalue *get_or_create_constant_svalue (tree cst_expr);\n-  const svalue *get_or_create_int_cst (tree type, poly_int64);\n-  const svalue *get_or_create_unknown_svalue (tree type);\n-  const svalue *get_or_create_setjmp_svalue (const setjmp_record &r,\n-\t\t\t\t\t     tree type);\n-  const svalue *get_or_create_poisoned_svalue (enum poison_kind kind,\n-\t\t\t\t\t       tree type);\n-  const svalue *get_or_create_initial_value (const region *reg);\n-  const svalue *get_ptr_svalue (tree ptr_type, const region *pointee);\n-  const svalue *get_or_create_unaryop (tree type, enum tree_code op,\n-\t\t\t\t       const svalue *arg);\n-  const svalue *get_or_create_cast (tree type, const svalue *arg);\n-  const svalue *get_or_create_binop (tree type,\n-\t\t\t\t     enum tree_code op,\n-\t\t\t\t     const svalue *arg0, const svalue *arg1);\n-  const svalue *get_or_create_sub_svalue (tree type,\n-\t\t\t\t\t  const svalue *parent_svalue,\n-\t\t\t\t\t  const region *subregion);\n-  const svalue *get_or_create_repeated_svalue (tree type,\n-\t\t\t\t\t       const svalue *outer_size,\n-\t\t\t\t\t       const svalue *inner_svalue);\n-  const svalue *get_or_create_bits_within (tree type,\n-\t\t\t\t\t   const bit_range &bits,\n-\t\t\t\t\t   const svalue *inner_svalue);\n-  const svalue *get_or_create_unmergeable (const svalue *arg);\n-  const svalue *get_or_create_widening_svalue (tree type,\n-\t\t\t\t\t       const function_point &point,\n-\t\t\t\t\t       const svalue *base_svalue,\n-\t\t\t\t\t       const svalue *iter_svalue);\n-  const svalue *get_or_create_compound_svalue (tree type,\n-\t\t\t\t\t       const binding_map &map);\n-  const svalue *get_or_create_conjured_svalue (tree type, const gimple *stmt,\n-\t\t\t\t\t       const region *id_reg,\n-\t\t\t\t\t       const conjured_purge &p);\n-  const svalue *\n-  get_or_create_asm_output_svalue (tree type,\n-\t\t\t\t   const gasm *asm_stmt,\n-\t\t\t\t   unsigned output_idx,\n-\t\t\t\t   const vec<const svalue *> &inputs);\n-  const svalue *\n-  get_or_create_const_fn_result_svalue (tree type,\n-\t\t\t\t\ttree fndecl,\n-\t\t\t\t\tconst vec<const svalue *> &inputs);\n-\n-  const svalue *maybe_get_char_from_string_cst (tree string_cst,\n-\t\t\t\t\t\ttree byte_offset_cst);\n-\n-  /* Dynamically-allocated svalue instances.\n-     The number of these within the analysis can grow arbitrarily.\n-     They are still owned by the manager.  */\n-  const svalue *create_unique_svalue (tree type);\n-\n-  /* region consolidation.  */\n-  const stack_region * get_stack_region () const { return &m_stack_region; }\n-  const heap_region *get_heap_region () const { return &m_heap_region; }\n-  const code_region *get_code_region () const { return &m_code_region; }\n-  const globals_region *get_globals_region () const\n-  {\n-    return &m_globals_region;\n-  }\n-  const function_region *get_region_for_fndecl (tree fndecl);\n-  const label_region *get_region_for_label (tree label);\n-  const decl_region *get_region_for_global (tree expr);\n-  const region *get_field_region (const region *parent, tree field);\n-  const region *get_element_region (const region *parent,\n-\t\t\t\t    tree element_type,\n-\t\t\t\t    const svalue *index);\n-  const region *get_offset_region (const region *parent,\n-\t\t\t\t   tree type,\n-\t\t\t\t   const svalue *byte_offset);\n-  const region *get_sized_region (const region *parent,\n-\t\t\t\t  tree type,\n-\t\t\t\t  const svalue *byte_size_sval);\n-  const region *get_cast_region (const region *original_region,\n-\t\t\t\t tree type);\n-  const frame_region *get_frame_region (const frame_region *calling_frame,\n-\t\t\t\t\tfunction *fun);\n-  const region *get_symbolic_region (const svalue *sval);\n-  const string_region *get_region_for_string (tree string_cst);\n-  const region *get_bit_range (const region *parent, tree type,\n-\t\t\t       const bit_range &bits);\n-  const var_arg_region *get_var_arg_region (const frame_region *parent,\n-\t\t\t\t\t    unsigned idx);\n-\n-  const region *get_unknown_symbolic_region (tree region_type);\n-\n-  const region *\n-  get_region_for_unexpected_tree_code (region_model_context *ctxt,\n-\t\t\t\t       tree t,\n-\t\t\t\t       const dump_location_t &loc);\n-\n-  unsigned alloc_region_id () { return m_next_region_id++; }\n-\n-  store_manager *get_store_manager () { return &m_store_mgr; }\n-  bounded_ranges_manager *get_range_manager () const { return m_range_mgr; }\n-\n-  known_function_manager *get_known_function_manager ()\n-  {\n-    return &m_known_fn_mgr;\n-  }\n-\n-  /* Dynamically-allocated region instances.\n-     The number of these within the analysis can grow arbitrarily.\n-     They are still owned by the manager.  */\n-  const region *create_region_for_heap_alloc ();\n-  const region *create_region_for_alloca (const frame_region *frame);\n-\n-  void log_stats (logger *logger, bool show_objs) const;\n-\n-  void begin_checking_feasibility (void) { m_checking_feasibility = true; }\n-  void end_checking_feasibility (void) { m_checking_feasibility = false; }\n-\n-  logger *get_logger () const { return m_logger; }\n-\n-  void dump_untracked_regions () const;\n-\n-private:\n-  bool too_complex_p (const complexity &c) const;\n-  bool reject_if_too_complex (svalue *sval);\n-\n-  const svalue *maybe_fold_unaryop (tree type, enum tree_code op,\n-\t\t\t\t    const svalue *arg);\n-  const svalue *maybe_fold_binop (tree type, enum tree_code op,\n-\t\t\t\t  const svalue *arg0, const svalue *arg1);\n-  const svalue *maybe_fold_sub_svalue (tree type,\n-\t\t\t\t       const svalue *parent_svalue,\n-\t\t\t\t       const region *subregion);\n-  const svalue *maybe_fold_repeated_svalue (tree type,\n-\t\t\t\t\t    const svalue *outer_size,\n-\t\t\t\t\t    const svalue *inner_svalue);\n-  const svalue *maybe_fold_bits_within_svalue (tree type,\n-\t\t\t\t\t       const bit_range &bits,\n-\t\t\t\t\t       const svalue *inner_svalue);\n-  const svalue *maybe_undo_optimize_bit_field_compare (tree type,\n-\t\t\t\t\t\t       const compound_svalue *compound_sval,\n-\t\t\t\t\t\t       tree cst, const svalue *arg1);\n-  const svalue *maybe_fold_asm_output_svalue (tree type,\n-\t\t\t\t\t      const vec<const svalue *> &inputs);\n-\n-  logger *m_logger;\n-\n-  const call_string m_empty_call_string;\n-\n-  unsigned m_next_region_id;\n-  root_region m_root_region;\n-  stack_region m_stack_region;\n-  heap_region m_heap_region;\n-\n-  /* svalue consolidation.  */\n-  typedef hash_map<tree, constant_svalue *> constants_map_t;\n-  constants_map_t m_constants_map;\n-\n-  typedef hash_map<tree, unknown_svalue *> unknowns_map_t;\n-  unknowns_map_t m_unknowns_map;\n-  const unknown_svalue *m_unknown_NULL;\n-\n-  typedef hash_map<poisoned_svalue::key_t,\n-\t\t   poisoned_svalue *> poisoned_values_map_t;\n-  poisoned_values_map_t m_poisoned_values_map;\n-\n-  typedef hash_map<setjmp_svalue::key_t,\n-\t\t   setjmp_svalue *> setjmp_values_map_t;\n-  setjmp_values_map_t m_setjmp_values_map;\n-\n-  typedef hash_map<const region *, initial_svalue *> initial_values_map_t;\n-  initial_values_map_t m_initial_values_map;\n-\n-  typedef hash_map<region_svalue::key_t, region_svalue *> pointer_values_map_t;\n-  pointer_values_map_t m_pointer_values_map;\n-\n-  typedef hash_map<unaryop_svalue::key_t,\n-\t\t   unaryop_svalue *> unaryop_values_map_t;\n-  unaryop_values_map_t m_unaryop_values_map;\n-\n-  typedef hash_map<binop_svalue::key_t, binop_svalue *> binop_values_map_t;\n-  binop_values_map_t m_binop_values_map;\n-\n-  typedef hash_map<sub_svalue::key_t, sub_svalue *> sub_values_map_t;\n-  sub_values_map_t m_sub_values_map;\n-\n-  typedef hash_map<repeated_svalue::key_t,\n-\t\t   repeated_svalue *> repeated_values_map_t;\n-  repeated_values_map_t m_repeated_values_map;\n-\n-  typedef hash_map<bits_within_svalue::key_t,\n-\t\t   bits_within_svalue *> bits_within_values_map_t;\n-  bits_within_values_map_t m_bits_within_values_map;\n-\n-  typedef hash_map<const svalue *,\n-\t\t   unmergeable_svalue *> unmergeable_values_map_t;\n-  unmergeable_values_map_t m_unmergeable_values_map;\n-\n-  typedef hash_map<widening_svalue::key_t,\n-\t\t   widening_svalue */*,\n-\t\t   widening_svalue::key_t::hash_map_traits*/>\n-    widening_values_map_t;\n-  widening_values_map_t m_widening_values_map;\n-\n-  typedef hash_map<compound_svalue::key_t,\n-\t\t   compound_svalue *> compound_values_map_t;\n-  compound_values_map_t m_compound_values_map;\n-\n-  typedef hash_map<conjured_svalue::key_t,\n-\t\t   conjured_svalue *> conjured_values_map_t;\n-  conjured_values_map_t m_conjured_values_map;\n-\n-  typedef hash_map<asm_output_svalue::key_t,\n-\t\t   asm_output_svalue *> asm_output_values_map_t;\n-  asm_output_values_map_t m_asm_output_values_map;\n-\n-  typedef hash_map<const_fn_result_svalue::key_t,\n-\t\t   const_fn_result_svalue *> const_fn_result_values_map_t;\n-  const_fn_result_values_map_t m_const_fn_result_values_map;\n-\n-  bool m_checking_feasibility;\n-\n-  /* \"Dynamically-allocated\" svalue instances.\n-     The number of these within the analysis can grow arbitrarily.\n-     They are still owned by the manager.  */\n-  auto_delete_vec<svalue> m_managed_dynamic_svalues;\n-\n-  /* Maximum complexity of svalues that weren't rejected.  */\n-  complexity m_max_complexity;\n-\n-  /* region consolidation.  */\n-\n-  code_region m_code_region;\n-  typedef hash_map<tree, function_region *> fndecls_map_t;\n-  typedef fndecls_map_t::iterator fndecls_iterator_t;\n-  fndecls_map_t m_fndecls_map;\n-\n-  typedef hash_map<tree, label_region *> labels_map_t;\n-  typedef labels_map_t::iterator labels_iterator_t;\n-  labels_map_t m_labels_map;\n-\n-  globals_region m_globals_region;\n-  typedef hash_map<tree, decl_region *> globals_map_t;\n-  typedef globals_map_t::iterator globals_iterator_t;\n-  globals_map_t m_globals_map;\n-\n-  consolidation_map<field_region> m_field_regions;\n-  consolidation_map<element_region> m_element_regions;\n-  consolidation_map<offset_region> m_offset_regions;\n-  consolidation_map<sized_region> m_sized_regions;\n-  consolidation_map<cast_region> m_cast_regions;\n-  consolidation_map<frame_region> m_frame_regions;\n-  consolidation_map<symbolic_region> m_symbolic_regions;\n-\n-  typedef hash_map<tree, string_region *> string_map_t;\n-  string_map_t m_string_map;\n-\n-  consolidation_map<bit_range_region> m_bit_range_regions;\n-  consolidation_map<var_arg_region> m_var_arg_regions;\n-\n-  store_manager m_store_mgr;\n-\n-  bounded_ranges_manager *m_range_mgr;\n-\n-  known_function_manager m_known_fn_mgr;\n-\n-  /* \"Dynamically-allocated\" region instances.\n-     The number of these within the analysis can grow arbitrarily.\n-     They are still owned by the manager.  */\n-  auto_delete_vec<region> m_managed_dynamic_regions;\n-};\n-\n struct append_regions_cb_data;\n \n /* Helper class for handling calls to functions with known behavior."}]}