{"sha": "cc60cad6155362fe0eca87937bccd75d9fca3ec6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M2MGNhZDYxNTUzNjJmZTBlY2E4NzkzN2JjY2Q3NWQ5ZmNhM2VjNg==", "commit": {"author": {"name": "Sebastian Perta", "email": "sebastian.perta@renesas.com", "date": "2018-02-09T16:17:13Z"}, "committer": {"name": "Sebastian Perta", "email": "sebastianperta@gcc.gnu.org", "date": "2018-02-09T16:17:13Z"}, "message": "constraints.md: added new constraint CALL_OP_SYMBOL_REF to allow or block \"symbol_ref\"...\n\n2018-02-09  Sebastian Perta  <sebastian.perta@renesas.com>\n\n\t* config/rx/constraints.md: added new constraint CALL_OP_SYMBOL_REF \n\tto allow or block \"symbol_ref\" depending on value of TARGET_JSR\n\t* config/rx/rx.md: use CALL_OP_SYMBOL_REF in call_internal and \n\tcall_value_internal insns\n\nFrom-SVN: r257529", "tree": {"sha": "0f8a165e4193a8c0a69a62d57b51d6da651793c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f8a165e4193a8c0a69a62d57b51d6da651793c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc60cad6155362fe0eca87937bccd75d9fca3ec6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc60cad6155362fe0eca87937bccd75d9fca3ec6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc60cad6155362fe0eca87937bccd75d9fca3ec6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc60cad6155362fe0eca87937bccd75d9fca3ec6/comments", "author": null, "committer": null, "parents": [{"sha": "a51ca83b315586ee1f93f3377a0d67fcf2ec9da1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a51ca83b315586ee1f93f3377a0d67fcf2ec9da1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a51ca83b315586ee1f93f3377a0d67fcf2ec9da1"}], "stats": {"total": 151, "additions": 149, "deletions": 2}, "files": [{"sha": "02a7ea064a8daad458552114011e33270e61107e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc60cad6155362fe0eca87937bccd75d9fca3ec6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc60cad6155362fe0eca87937bccd75d9fca3ec6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc60cad6155362fe0eca87937bccd75d9fca3ec6", "patch": "@@ -1,3 +1,10 @@\n+2018-02-09  Sebastian Perta  <sebastian.perta@renesas.com>\n+\n+\t* config/rx/constraints.md: added new constraint CALL_OP_SYMBOL_REF \n+\tto allow or block \"symbol_ref\" depending on value of TARGET_JSR\n+\t* config/rx/rx.md: use CALL_OP_SYMBOL_REF in call_internal and \n+\tcall_value_internal insns\n+\n 2018-02-09  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \tPR lto/84213"}, {"sha": "d981f66acf9583dca2ba445d32984b1a94b867b4", "filename": "gcc/config/rx/constraints.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc60cad6155362fe0eca87937bccd75d9fca3ec6/gcc%2Fconfig%2Frx%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc60cad6155362fe0eca87937bccd75d9fca3ec6/gcc%2Fconfig%2Frx%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Fconstraints.md?ref=cc60cad6155362fe0eca87937bccd75d9fca3ec6", "patch": "@@ -106,3 +106,9 @@\n        )\n   )\n )\n+\n+(define_constraint \"CALL_OP_SYMBOL_REF\"\n+\"constraint for call instructions using symbol ref\"\n+(and (match_test \"!TARGET_JSR\")\n+     (match_code \"symbol_ref\"))\n+)"}, {"sha": "35263b1adc7d513a56e96c35c6bc1ac32770d765", "filename": "gcc/config/rx/rx.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc60cad6155362fe0eca87937bccd75d9fca3ec6/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc60cad6155362fe0eca87937bccd75d9fca3ec6/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=cc60cad6155362fe0eca87937bccd75d9fca3ec6", "patch": "@@ -438,7 +438,7 @@\n )\n \n (define_insn \"call_internal\"\n-  [(call (mem:QI (match_operand:SI 0 \"rx_call_operand\" \"r,Symbol\"))\n+  [(call (mem:QI (match_operand:SI 0 \"rx_call_operand\" \"r,CALL_OP_SYMBOL_REF\"))\n \t (const_int 0))\n    (clobber (reg:CC CC_REG))]\n   \"\"\n@@ -466,7 +466,7 @@\n \n (define_insn \"call_value_internal\"\n   [(set (match_operand                  0 \"register_operand\" \"=r,r\")\n-\t(call (mem:QI (match_operand:SI 1 \"rx_call_operand\"   \"r,Symbol\"))\n+\t(call (mem:QI (match_operand:SI 1 \"rx_call_operand\"   \"r,CALL_OP_SYMBOL_REF\"))\n \t      (const_int 0)))\n    (clobber (reg:CC CC_REG))]\n   \"\""}, {"sha": "c73a01bb5200aba79d8324c756d6d84732525d6e", "filename": "gcc/testsuite/gcc.target/rx/mjsr.c", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc60cad6155362fe0eca87937bccd75d9fca3ec6/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fmjsr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc60cad6155362fe0eca87937bccd75d9fca3ec6/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fmjsr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fmjsr.c?ref=cc60cad6155362fe0eca87937bccd75d9fca3ec6", "patch": "@@ -0,0 +1,134 @@\n+/* { dg-do compile } */\r\n+/* { dg-options \"-O2 -mjsr\" } */\r\n+\r\n+void *malloc (__SIZE_TYPE__);\r\n+void *realloc (void *, __SIZE_TYPE__);\r\n+\r\n+struct A { double x, y; };\r\n+struct B { double x0, y0, x1, y1; };\r\n+struct C { int n_points; int dir; struct B bbox; struct A *points; };\r\n+struct D { int n_segs; struct C segs[1]; };\r\n+\r\n+void foo (int, int, int *, int, int *, struct A **, int *, int *,\r\n+\t  struct D *, int *, struct D **, int *, int **);\r\n+int baz (struct A, struct A, struct A, struct A);\r\n+\r\n+static void\r\n+bar (struct D *svp, int *n_points_max,\r\n+     struct A p, int *seg_map, int *active_segs, int i)\r\n+{\r\n+  int asi, n_points;\r\n+  struct C *seg;\r\n+\r\n+  asi = seg_map[active_segs[i]];\r\n+  seg = &svp->segs[asi];\r\n+  n_points = seg->n_points;\r\n+  seg->points = ((struct A *)\r\n+\t\trealloc (seg->points, (n_points_max[asi] <<= 1) * sizeof (struct A)));\r\n+  seg->points[n_points] = p;\r\n+  seg->bbox.y1 = p.y;\r\n+  seg->n_points++;\r\n+}\r\n+\r\n+struct D *\r\n+test (struct D *vp)\r\n+{\r\n+  int *active_segs, n_active_segs, *cursor, seg_idx;\r\n+  double y, share_x;\r\n+  int tmp1, tmp2, asi, i, j, *n_ips, *n_ips_max, n_segs_max;\r\n+  struct A **ips, p_curs, *pts;\r\n+  struct D *new_vp;\r\n+  int *n_points_max, *seg_map, first_share;\r\n+\r\n+  n_segs_max = 16;\r\n+  new_vp = (struct D *) malloc (sizeof (struct D) +\r\n+\t\t\t\t(n_segs_max - 1) * sizeof (struct C));\r\n+  new_vp->n_segs = 0;\r\n+\r\n+  if (vp->n_segs == 0)\r\n+    return new_vp;\r\n+\r\n+  active_segs = ((int *) malloc ((vp->n_segs) * sizeof (int)));\r\n+  cursor = ((int *) malloc ((vp->n_segs) * sizeof (int)));\r\n+\r\n+  seg_map = ((int *) malloc ((vp->n_segs) * sizeof (int)));\r\n+  n_ips = ((int *) malloc ((vp->n_segs) * sizeof (int)));\r\n+  n_ips_max = ((int *) malloc ((vp->n_segs) * sizeof (int)));\r\n+  ips = ((struct A * *) malloc ((vp->n_segs) * sizeof (struct A *)));\r\n+\r\n+  n_points_max = ((int *) malloc ((n_segs_max) * sizeof (int)));\r\n+\r\n+  n_active_segs = 0;\r\n+  seg_idx = 0;\r\n+  y = vp->segs[0].points[0].y;\r\n+  while (seg_idx < vp->n_segs || n_active_segs > 0)\r\n+    {\r\n+      for (i = 0; i < n_active_segs; i++)\r\n+\t{\r\n+\t  asi = active_segs[i];\r\n+\t  if (vp->segs[asi].n_points - 1 == cursor[asi] &&\r\n+\t      vp->segs[asi].points[cursor[asi]].y == y)\r\n+\t    i--;\r\n+\t}\r\n+\r\n+      while (seg_idx < vp->n_segs && y == vp->segs[seg_idx].points[0].y)\r\n+\t{\r\n+\t  cursor[seg_idx] = 0;\r\n+\t  n_ips[seg_idx] = 1;\r\n+\t  n_ips_max[seg_idx] = 2;\r\n+\t  ips[seg_idx] =\r\n+\t    ((struct A *) malloc ((n_ips_max[seg_idx]) * sizeof (struct A)));\r\n+\t  ips[seg_idx][0] = vp->segs[seg_idx].points[0];\r\n+\t  pts = ((struct A *) malloc ((16) * sizeof (struct A)));\r\n+\t  pts[0] = vp->segs[seg_idx].points[0];\r\n+\t  tmp1 = seg_idx;\r\n+\t  for (j = i; j < n_active_segs; j++)\r\n+\t    {\r\n+\t      tmp2 = active_segs[j];\r\n+\t      active_segs[j] = tmp1;\r\n+\t      tmp1 = tmp2;\r\n+\t    }\r\n+\t  active_segs[n_active_segs] = tmp1;\r\n+\t  n_active_segs++;\r\n+\t  seg_idx++;\r\n+\t}\r\n+      first_share = -1;\r\n+      share_x = 0;\r\n+\r\n+      for (i = 0; i < n_active_segs; i++)\r\n+\t{\r\n+\t  asi = active_segs[i];\r\n+\t  p_curs = ips[asi][1];\r\n+\t  if (p_curs.y == y)\r\n+\t    {\r\n+\t      bar (new_vp, n_points_max,\r\n+\t\t   p_curs, seg_map, active_segs, i);\r\n+\r\n+\t      n_ips[asi]--;\r\n+\t      for (j = 0; j < n_ips[asi]; j++)\r\n+\t\tips[asi][j] = ips[asi][j + 1];\r\n+\r\n+\t      if (first_share < 0 || p_curs.x != share_x)\r\n+\t\t{\r\n+\t\t  foo (first_share, i,\r\n+\t\t       active_segs, n_active_segs,\r\n+\t\t       cursor, ips, n_ips, n_ips_max, vp, seg_map,\r\n+\t\t       &new_vp, &n_segs_max, &n_points_max);\r\n+\t\t  first_share = i;\r\n+\t\t  share_x = p_curs.x;\r\n+\t\t}\r\n+\t    }\r\n+\t  else\r\n+\t    {\r\n+\t      foo (first_share, i,\r\n+\t\t   active_segs, n_active_segs,\r\n+\t\t   cursor, ips, n_ips, n_ips_max, vp, seg_map,\r\n+\t\t   &new_vp, &n_segs_max, &n_points_max);\r\n+\t      first_share = -1;\r\n+\t    }\r\n+\t}\r\n+    }\r\n+  return new_vp;\r\n+}\r\n+\r\n+/* { dg-final { scan-assembler-not \"bsr\" } } */\r"}]}