{"sha": "5b74dd0a2278365eb562d9d1999c3c11cddb733c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI3NGRkMGEyMjc4MzY1ZWI1NjJkOWQxOTk5YzNjMTFjZGRiNzMzYw==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-03-13T20:03:02Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-03-13T20:03:02Z"}, "message": "d/dmd: Merge upstream dmd e9420cfbf\n\n1. Implement DIP 1010 - (Static foreach)\n\nSupport for 'static foreach' has been added.  'static foreach' is a conditional\ncompilation construct that is to 'foreach' what 'static if' is to 'if'.  It is\na convenient way to generate declarations and statements by iteration.\n\n    import std.conv: to;\n\n    static foreach(i; 0 .. 10)\n    {\n\n        // a 'static foreach' body does not introduce a nested scope\n        // (similar to 'static if').\n\n        // The following mixin declaration is at module scope:\n        // declares 10 variables x0, x1, ..., x9\n        mixin('enum x' ~ to!string(i) ~ ' = i;');\n    }\n\n    import std.range: iota;\n    // all aggregate types that can be iterated with a standard 'foreach'\n    // loop are also supported by static foreach:\n    static foreach(i; iota(10))\n    {\n        // we access the declarations generated in the first 'static foreach'\n        pragma(msg, \"x\", i, \": \", mixin(`x` ~ to!string(i)));\n        static assert(mixin(`x` ~ to!string(i)) == i);\n    }\n\n    void main()\n    {\n        import std.conv: text;\n        import std.typecons: tuple;\n        import std.algorithm: map;\n        import std.stdio: writeln;\n\n        // 'static foreach' has both declaration and statement forms\n        // (similar to 'static if').\n\n        static foreach(x; iota(3).map!(i => tuple(text(\"x\", i), i)))\n        {\n            // generates three local variables x0, x1 and x2.\n            mixin(text(`int `,x[0],` = x[1];`));\n\n            scope(exit) // this is within the scope of 'main'\n            {\n                writeln(mixin(x[0]));\n            }\n        }\n\n        writeln(x0,\" \",x1,\" \",x2); // first runtime output\n    }\n\n2. Aliases can be created directly from a '__trait'.\n\nAliases can be created directly from the traits that return symbol(s) or\ntuples.  This includes 'getMember', 'allMembers', 'derivedMembers', 'parent',\n'getOverloads', 'getVirtualFunctions', 'getVirtualMethods', 'getUnitTests',\n'getAttributes' and finally 'getAliasThis'.  Previously an 'AliasSeq' was\nnecessary in order to alias their return.  Now the grammar allows to write\nshorter declarations:\n\n    struct Foo\n    {\n        static int a;\n    }\n\n    alias oldWay = AliasSeq!(__traits(getMember, Foo, \"a\"))[0];\n    alias newWay = __traits(getMember, Foo, \"a\");\n\nTo permit this it was more interesting to include '__trait' in the basic types\nrather than just changing the alias syntax. So additionally, wherever a type\nappears a '__trait' can be used, for example in a variable declaration:\n\n    struct Foo { static struct Bar {} }\n    const(__traits(getMember, Foo, \"Bar\")) fooBar;\n    static assert(is(typeof(fooBar) == const(Foo.Bar)));\n\n3. fix Issue 10100 - Identifiers with double underscores and allMembers\n\nThe identifer whitelist has been converted into a blacklist of all possible\ninternal D language declarations.\n\nReviewed-on: https://github.com/dlang/dmd/pull/10791", "tree": {"sha": "d50cf33dd430febb733c654fc1ea60dc7a34609f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d50cf33dd430febb733c654fc1ea60dc7a34609f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b74dd0a2278365eb562d9d1999c3c11cddb733c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b74dd0a2278365eb562d9d1999c3c11cddb733c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b74dd0a2278365eb562d9d1999c3c11cddb733c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b74dd0a2278365eb562d9d1999c3c11cddb733c/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db3fa3476e9e922ca3e283df03ebd14be7220b6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db3fa3476e9e922ca3e283df03ebd14be7220b6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db3fa3476e9e922ca3e283df03ebd14be7220b6e"}], "stats": {"total": 3473, "additions": 3046, "deletions": 427}, "files": [{"sha": "b017c037d74c4c715f05f6c8877ed292518890bd", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -1,4 +1,4 @@\n-b37a537d36c2ac69afa505a3110e2328c9fc0114\n+e9420cfbf5cd0cf9e6e398603e009ccc8e14d324\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "86485d27616bde22573788688c47ff78e6138473", "filename": "gcc/d/dmd/attrib.c", "status": "modified", "additions": 187, "deletions": 2, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fattrib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fattrib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -31,6 +31,7 @@\n bool definitelyValueParameter(Expression *e);\n Expression *semantic(Expression *e, Scope *sc);\n StringExp *semanticString(Scope *sc, Expression *exp, const char *s);\n+Dsymbols *makeTupleForeachStaticDecl(Scope *sc, ForeachStatement *fs, Dsymbols *dbody, bool needExpansion);\n \n /********************************* AttribDeclaration ****************************/\n \n@@ -42,6 +43,9 @@ AttribDeclaration::AttribDeclaration(Dsymbols *decl)\n \n Dsymbols *AttribDeclaration::include(Scope *, ScopeDsymbol *)\n {\n+    if (errors)\n+        return NULL;\n+\n     return decl;\n }\n \n@@ -752,6 +756,7 @@ void AnonDeclaration::semantic(Scope *sc)\n     {\n         ::error(loc, \"%s can only be a part of an aggregate, not %s %s\",\n             kind(), p->kind(), p->toChars());\n+        errors = true;\n         return;\n     }\n \n@@ -1219,6 +1224,10 @@ bool ConditionalDeclaration::oneMember(Dsymbol **ps, Identifier *ident)\n Dsymbols *ConditionalDeclaration::include(Scope *sc, ScopeDsymbol *sds)\n {\n     //printf(\"ConditionalDeclaration::include(sc = %p) _scope = %p\\n\", sc, _scope);\n+\n+    if (errors)\n+        return NULL;\n+\n     assert(condition);\n     return condition->include(_scope ? _scope : sc, sds) ? decl : elsedecl;\n }\n@@ -1275,6 +1284,7 @@ StaticIfDeclaration::StaticIfDeclaration(Condition *condition,\n     //printf(\"StaticIfDeclaration::StaticIfDeclaration()\\n\");\n     scopesym = NULL;\n     addisdone = false;\n+    onStack = false;\n }\n \n Dsymbol *StaticIfDeclaration::syntaxCopy(Dsymbol *s)\n@@ -1293,12 +1303,17 @@ Dsymbols *StaticIfDeclaration::include(Scope *sc, ScopeDsymbol *)\n {\n     //printf(\"StaticIfDeclaration::include(sc = %p) _scope = %p\\n\", sc, _scope);\n \n+    if (errors || onStack)\n+        return NULL;\n+    onStack = true;\n+    Dsymbols *d;\n+\n     if (condition->inc == 0)\n     {\n         assert(scopesym);   // addMember is already done\n         assert(_scope);      // setScope is already done\n \n-        Dsymbols *d = ConditionalDeclaration::include(_scope, scopesym);\n+        d = ConditionalDeclaration::include(_scope, scopesym);\n \n         if (d && !addisdone)\n         {\n@@ -1318,11 +1333,14 @@ Dsymbols *StaticIfDeclaration::include(Scope *sc, ScopeDsymbol *)\n \n             addisdone = true;\n         }\n+        onStack = false;\n         return d;\n     }\n     else\n     {\n-        return ConditionalDeclaration::include(sc, scopesym);\n+        d = ConditionalDeclaration::include(sc, scopesym);\n+        onStack = false;\n+        return d;\n     }\n }\n \n@@ -1366,6 +1384,173 @@ const char *StaticIfDeclaration::kind() const\n     return \"static if\";\n }\n \n+/***************************** StaticForeachDeclaration ***********************/\n+\n+/* Static foreach at declaration scope, like:\n+ *     static foreach (i; [0, 1, 2]){ }\n+ */\n+\n+StaticForeachDeclaration::StaticForeachDeclaration(StaticForeach *sfe, Dsymbols *decl)\n+        : AttribDeclaration(decl)\n+{\n+    this->sfe = sfe;\n+    this->scopesym = NULL;\n+    this->onStack = false;\n+    this->cached = false;\n+    this->cache = NULL;\n+}\n+\n+Dsymbol *StaticForeachDeclaration::syntaxCopy(Dsymbol *s)\n+{\n+    assert(!s);\n+    return new StaticForeachDeclaration(\n+        sfe->syntaxCopy(),\n+        Dsymbol::arraySyntaxCopy(decl));\n+}\n+\n+bool StaticForeachDeclaration::oneMember(Dsymbol **ps, Identifier *ident)\n+{\n+    // Required to support IFTI on a template that contains a\n+    // `static foreach` declaration.  `super.oneMember` calls\n+    // include with a `null` scope.  As `static foreach` requires\n+    // the scope for expansion, `oneMember` can only return a\n+    // precise result once `static foreach` has been expanded.\n+    if (cached)\n+    {\n+        return AttribDeclaration::oneMember(ps, ident);\n+    }\n+    *ps = NULL; // a `static foreach` declaration may in general expand to multiple symbols\n+    return false;\n+}\n+\n+Dsymbols *StaticForeachDeclaration::include(Scope *, ScopeDsymbol *)\n+{\n+    if (errors || onStack)\n+        return NULL;\n+    if (cached)\n+    {\n+        assert(!onStack);\n+        return cache;\n+    }\n+    onStack = true;\n+\n+    if (_scope)\n+    {\n+        staticForeachPrepare(sfe, _scope); // lower static foreach aggregate\n+    }\n+    if (!staticForeachReady(sfe))\n+    {\n+        onStack = false;\n+        return NULL; // TODO: ok?\n+    }\n+\n+    // expand static foreach\n+    Dsymbols *d = makeTupleForeachStaticDecl(_scope, sfe->aggrfe, decl, sfe->needExpansion);\n+    if (d) // process generated declarations\n+    {\n+        // Add members lazily.\n+        for (size_t i = 0; i < d->dim; i++)\n+        {\n+            Dsymbol *s = (*d)[i];\n+            s->addMember(_scope, scopesym);\n+        }\n+        // Set the member scopes lazily.\n+        for (size_t i = 0; i < d->dim; i++)\n+        {\n+            Dsymbol *s = (*d)[i];\n+            s->setScope(_scope);\n+        }\n+    }\n+    onStack = false;\n+    cached = true;\n+    cache = d;\n+    return d;\n+}\n+\n+void StaticForeachDeclaration::addMember(Scope *, ScopeDsymbol *sds)\n+{\n+    // used only for caching the enclosing symbol\n+    this->scopesym = sds;\n+}\n+\n+void StaticForeachDeclaration::addComment(const utf8_t *)\n+{\n+    // do nothing\n+    // change this to give semantics to documentation comments on static foreach declarations\n+}\n+\n+void StaticForeachDeclaration::setScope(Scope *sc)\n+{\n+    // do not evaluate condition before semantic pass\n+    // But do set the scope, in case we need it for forward referencing\n+    Dsymbol::setScope(sc);\n+}\n+\n+void StaticForeachDeclaration::importAll(Scope *)\n+{\n+    // do not evaluate aggregate before semantic pass\n+}\n+\n+void StaticForeachDeclaration::semantic(Scope *sc)\n+{\n+    AttribDeclaration::semantic(sc);\n+}\n+\n+const char *StaticForeachDeclaration::kind() const\n+{\n+    return \"static foreach\";\n+}\n+\n+/***********************************************************\n+ * Collection of declarations that stores foreach index variables in a\n+ * local symbol table.  Other symbols declared within are forwarded to\n+ * another scope, like:\n+ *\n+ *      static foreach (i; 0 .. 10) // loop variables for different indices do not conflict.\n+ *      { // this body is expanded into 10 ForwardingAttribDeclarations, where `i` has storage class STClocal\n+ *          mixin(\"enum x\" ~ to!string(i) ~ \" = i\"); // ok, can access current loop variable\n+ *      }\n+ *\n+ *      static foreach (i; 0.. 10)\n+ *      {\n+ *          pragma(msg, mixin(\"x\" ~ to!string(i))); // ok, all 10 symbols are visible as they were forwarded to the global scope\n+ *      }\n+ *\n+ *      static assert (!is(typeof(i))); // loop index variable is not visible outside of the static foreach loop\n+ *\n+ * A StaticForeachDeclaration generates one\n+ * ForwardingAttribDeclaration for each expansion of its body.  The\n+ * AST of the ForwardingAttribDeclaration contains both the `static\n+ * foreach` variables and the respective copy of the `static foreach`\n+ * body.  The functionality is achieved by using a\n+ * ForwardingScopeDsymbol as the parent symbol for the generated\n+ * declarations.\n+ */\n+\n+ForwardingAttribDeclaration::ForwardingAttribDeclaration(Dsymbols *decl)\n+        : AttribDeclaration(decl)\n+{\n+    sym = new ForwardingScopeDsymbol(NULL);\n+    sym->symtab = new DsymbolTable();\n+}\n+\n+/**************************************\n+ * Use the ForwardingScopeDsymbol as the parent symbol for members.\n+ */\n+Scope *ForwardingAttribDeclaration::newScope(Scope *sc)\n+{\n+    return sc->push(sym);\n+}\n+\n+/***************************************\n+ * Lazily initializes the scope to forward to.\n+ */\n+void ForwardingAttribDeclaration::addMember(Scope *sc, ScopeDsymbol *sds)\n+{\n+    parent = sym->parent = sym->forward = sds;\n+    return AttribDeclaration::addMember(sc, sym);\n+}\n+\n /***************************** CompileDeclaration *****************************/\n \n // These are mixin declarations, like mixin(\"int x\");"}, {"sha": "ccfcddadaca9224535fc430a2fce17b8070701de", "filename": "gcc/d/dmd/attrib.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fattrib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fattrib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.h?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -191,6 +191,7 @@ class StaticIfDeclaration : public ConditionalDeclaration\n public:\n     ScopeDsymbol *scopesym;\n     bool addisdone;\n+    bool onStack;\n \n     StaticIfDeclaration(Condition *condition, Dsymbols *decl, Dsymbols *elsedecl);\n     Dsymbol *syntaxCopy(Dsymbol *s);\n@@ -203,14 +204,16 @@ class StaticIfDeclaration : public ConditionalDeclaration\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n-class StaticForeachDeclaration : public ConditionalDeclaration\n+class StaticForeachDeclaration : public AttribDeclaration\n {\n public:\n     StaticForeach *sfe;\n     ScopeDsymbol *scopesym;\n+    bool onStack;\n     bool cached;\n     Dsymbols *cache;\n \n+    StaticForeachDeclaration(StaticForeach *sfe, Dsymbols *decl);\n     Dsymbol *syntaxCopy(Dsymbol *s);\n     bool oneMember(Dsymbol **ps, Identifier *ident);\n     Dsymbols *include(Scope *sc, ScopeDsymbol *sds);\n@@ -223,14 +226,16 @@ class StaticForeachDeclaration : public ConditionalDeclaration\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n-class ForwardingAttribDeclaration : AttribDeclaration\n+class ForwardingAttribDeclaration : public AttribDeclaration\n {\n public:\n     ForwardingScopeDsymbol *sym;\n \n+    ForwardingAttribDeclaration(Dsymbols *decl);\n     Scope *newScope(Scope *sc);\n     void addMember(Scope *sc, ScopeDsymbol *sds);\n     ForwardingAttribDeclaration *isForwardingAttribDeclaration() { return this; }\n+    void accept(Visitor *v) { v->visit(this); }\n };\n \n // Mixin declarations"}, {"sha": "c75399d38253ad2bc3bd9069fb2cd6e0e3860bb8", "filename": "gcc/d/dmd/cond.c", "status": "modified", "additions": 323, "deletions": 10, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fcond.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fcond.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcond.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -13,6 +13,7 @@\n #include \"mars.h\"\n #include \"id.h\"\n #include \"init.h\"\n+#include \"aggregate.h\"\n #include \"declaration.h\"\n #include \"identifier.h\"\n #include \"expression.h\"\n@@ -21,6 +22,7 @@\n #include \"template.h\"\n #include \"mtype.h\"\n #include \"scope.h\"\n+#include \"statement.h\"\n #include \"arraytypes.h\"\n #include \"tokens.h\"\n \n@@ -53,6 +55,327 @@ Condition::Condition(Loc loc)\n \n /* ============================================================ */\n \n+StaticForeach::StaticForeach(Loc loc, ForeachStatement *aggrfe, ForeachRangeStatement *rangefe)\n+{\n+    assert(!!aggrfe ^ !!rangefe);\n+    this->loc = loc;\n+    this->aggrfe = aggrfe;\n+    this->rangefe = rangefe;\n+    this->needExpansion = false;\n+}\n+\n+StaticForeach *StaticForeach::syntaxCopy()\n+{\n+    return new StaticForeach(\n+        loc,\n+        aggrfe ? (ForeachStatement *)aggrfe->syntaxCopy() : NULL,\n+        rangefe ? (ForeachRangeStatement *)rangefe->syntaxCopy() : NULL\n+    );\n+}\n+\n+/*****************************************\n+ * Turn an aggregate which is an array into an expression tuple\n+ * of its elements. I.e., lower\n+ *     static foreach (x; [1, 2, 3, 4]) { ... }\n+ * to\n+ *     static foreach (x; AliasSeq!(1, 2, 3, 4)) { ... }\n+ */\n+\n+static void lowerArrayAggregate(StaticForeach *sfe, Scope *sc)\n+{\n+    Expression *aggr = sfe->aggrfe->aggr;\n+    Expression *el = new ArrayLengthExp(aggr->loc, aggr);\n+    sc = sc->startCTFE();\n+    el = semantic(el, sc);\n+    sc = sc->endCTFE();\n+    el = el->optimize(WANTvalue);\n+    el = el->ctfeInterpret();\n+    if (el->op == TOKint64)\n+    {\n+        dinteger_t length = el->toInteger();\n+        Expressions *es = new Expressions();\n+        for (size_t i = 0; i < length; i++)\n+        {\n+            IntegerExp *index = new IntegerExp(sfe->loc, i, Type::tsize_t);\n+            Expression *value = new IndexExp(aggr->loc, aggr, index);\n+            es->push(value);\n+        }\n+        sfe->aggrfe->aggr = new TupleExp(aggr->loc, es);\n+        sfe->aggrfe->aggr = semantic(sfe->aggrfe->aggr, sc);\n+        sfe->aggrfe->aggr = sfe->aggrfe->aggr->optimize(WANTvalue);\n+    }\n+    else\n+    {\n+        sfe->aggrfe->aggr = new ErrorExp();\n+    }\n+}\n+\n+/*****************************************\n+ * Wrap a statement into a function literal and call it.\n+ *\n+ * Params:\n+ *     loc = The source location.\n+ *     s  = The statement.\n+ * Returns:\n+ *     AST of the expression `(){ s; }()` with location loc.\n+ */\n+\n+static Expression *wrapAndCall(Loc loc, Statement *s)\n+{\n+    TypeFunction *tf = new TypeFunction(new Parameters(), NULL, 0, LINKdefault, 0);\n+    FuncLiteralDeclaration *fd = new FuncLiteralDeclaration(loc, loc, tf, TOKreserved, NULL);\n+    fd->fbody = s;\n+    FuncExp *fe = new FuncExp(loc, fd);\n+    Expression *ce = new CallExp(loc, fe, new Expressions());\n+    return ce;\n+}\n+\n+/*****************************************\n+ * Create a `foreach` statement from `aggrefe/rangefe` with given\n+ * `foreach` variables and body `s`.\n+ *\n+ * Params:\n+ *     loc = The source location.\n+ *     parameters = The foreach variables.\n+ *     s = The `foreach` body.\n+ * Returns:\n+ *     `foreach (parameters; aggregate) s;` or\n+ *     `foreach (parameters; lower .. upper) s;`\n+ *     Where aggregate/lower, upper are as for the current StaticForeach.\n+ */\n+\n+static Statement *createForeach(StaticForeach *sfe, Loc loc, Parameters *parameters, Statement *s)\n+{\n+    if (sfe->aggrfe)\n+    {\n+        return new ForeachStatement(loc, sfe->aggrfe->op, parameters, sfe->aggrfe->aggr->syntaxCopy(), s, loc);\n+    }\n+    else\n+    {\n+        assert(sfe->rangefe && parameters->dim == 1);\n+        return new ForeachRangeStatement(loc, sfe->rangefe->op, (*parameters)[0],\n+                                         sfe->rangefe->lwr->syntaxCopy(),\n+                                         sfe->rangefe->upr->syntaxCopy(), s, loc);\n+    }\n+}\n+\n+/*****************************************\n+ * For a `static foreach` with multiple loop variables, the\n+ * aggregate is lowered to an array of tuples. As D does not have\n+ * built-in tuples, we need a suitable tuple type. This generates\n+ * a `struct` that serves as the tuple type. This type is only\n+ * used during CTFE and hence its typeinfo will not go to the\n+ * object file.\n+ *\n+ * Params:\n+ *     loc = The source location.\n+ *     e = The expressions we wish to store in the tuple.\n+ *     sc  = The current scope.\n+ * Returns:\n+ *     A struct type of the form\n+ *         struct Tuple\n+ *         {\n+ *             typeof(AliasSeq!(e)) tuple;\n+ *         }\n+ */\n+\n+static TypeStruct *createTupleType(Loc loc, Expressions *e)\n+{   // TODO: move to druntime?\n+    Identifier *sid = Identifier::generateId(\"Tuple\");\n+    StructDeclaration *sdecl = new StructDeclaration(loc, sid, false);\n+    sdecl->storage_class |= STCstatic;\n+    sdecl->members = new Dsymbols();\n+    Identifier *fid = Identifier::idPool(\"tuple\");\n+    Type *ty = new TypeTypeof(loc, new TupleExp(loc, e));\n+    sdecl->members->push(new VarDeclaration(loc, ty, fid, NULL));\n+    TypeStruct *r = (TypeStruct *)sdecl->type;\n+    r->vtinfo = TypeInfoStructDeclaration::create(r); // prevent typeinfo from going to object file\n+    return r;\n+}\n+\n+/*****************************************\n+ * Create the AST for an instantiation of a suitable tuple type.\n+ *\n+ * Params:\n+ *     loc = The source location.\n+ *     type = A Tuple type, created with createTupleType.\n+ *     e = The expressions we wish to store in the tuple.\n+ * Returns:\n+ *     An AST for the expression `Tuple(e)`.\n+ */\n+\n+static Expression *createTuple(Loc loc, TypeStruct *type, Expressions *e)\n+{   // TODO: move to druntime?\n+    return new CallExp(loc, new TypeExp(loc, type), e);\n+}\n+\n+/*****************************************\n+ * Lower any aggregate that is not an array to an array using a\n+ * regular foreach loop within CTFE.  If there are multiple\n+ * `static foreach` loop variables, an array of tuples is\n+ * generated. In thise case, the field `needExpansion` is set to\n+ * true to indicate that the static foreach loop expansion will\n+ * need to expand the tuples into multiple variables.\n+ *\n+ * For example, `static foreach (x; range) { ... }` is lowered to:\n+ *\n+ *     static foreach (x; {\n+ *         typeof({\n+ *             foreach (x; range) return x;\n+ *         }())[] __res;\n+ *         foreach (x; range) __res ~= x;\n+ *         return __res;\n+ *     }()) { ... }\n+ *\n+ * Finally, call `lowerArrayAggregate` to turn the produced\n+ * array into an expression tuple.\n+ *\n+ * Params:\n+ *     sc = The current scope.\n+ */\n+\n+static void lowerNonArrayAggregate(StaticForeach *sfe, Scope *sc)\n+{\n+    size_t nvars = sfe->aggrfe ? sfe->aggrfe->parameters->dim : 1;\n+    Loc aloc = sfe->aggrfe ? sfe->aggrfe->aggr->loc : sfe->rangefe->lwr->loc;\n+    // We need three sets of foreach loop variables because the\n+    // lowering contains three foreach loops.\n+    Parameters *pparams[3] = {new Parameters(), new Parameters(), new Parameters()};\n+    for (size_t i = 0; i < nvars; i++)\n+    {\n+        for (size_t j = 0; j < 3; j++)\n+        {\n+            Parameters *params = pparams[j];\n+            Parameter *p = sfe->aggrfe ? (*sfe->aggrfe->parameters)[i] : sfe->rangefe->prm;\n+            params->push(new Parameter(p->storageClass, p->type, p->ident, NULL));\n+        }\n+    }\n+    Expression *res[2];\n+    TypeStruct *tplty = NULL;\n+    if (nvars == 1) // only one `static foreach` variable, generate identifiers.\n+    {\n+        for (size_t i = 0; i < 2; i++)\n+        {\n+            res[i] = new IdentifierExp(aloc, (*pparams[i])[0]->ident);\n+        }\n+    }\n+    else // multiple `static foreach` variables, generate tuples.\n+    {\n+        for (size_t i = 0; i < 2; i++)\n+        {\n+            Expressions *e = new Expressions();\n+            for (size_t j = 0; j < pparams[0]->dim; j++)\n+            {\n+                Parameter *p = (*pparams[i])[j];\n+                e->push(new IdentifierExp(aloc, p->ident));\n+            }\n+            if (!tplty)\n+            {\n+                tplty = createTupleType(aloc, e);\n+            }\n+            res[i] = createTuple(aloc, tplty, e);\n+        }\n+        sfe->needExpansion = true; // need to expand the tuples later\n+    }\n+    // generate remaining code for the new aggregate which is an\n+    // array (see documentation comment).\n+    if (sfe->rangefe)\n+    {\n+        sc = sc->startCTFE();\n+        sfe->rangefe->lwr = semantic(sfe->rangefe->lwr, sc);\n+        sfe->rangefe->lwr = resolveProperties(sc, sfe->rangefe->lwr);\n+        sfe->rangefe->upr = semantic(sfe->rangefe->upr, sc);\n+        sfe->rangefe->upr = resolveProperties(sc, sfe->rangefe->upr);\n+        sc = sc->endCTFE();\n+        sfe->rangefe->lwr = sfe->rangefe->lwr->optimize(WANTvalue);\n+        sfe->rangefe->lwr = sfe->rangefe->lwr->ctfeInterpret();\n+        sfe->rangefe->upr = sfe->rangefe->upr->optimize(WANTvalue);\n+        sfe->rangefe->upr = sfe->rangefe->upr->ctfeInterpret();\n+    }\n+    Statements *s1 = new Statements();\n+    Statements *sfebody = new Statements();\n+    if (tplty) sfebody->push(new ExpStatement(sfe->loc, tplty->sym));\n+    sfebody->push(new ReturnStatement(aloc, res[0]));\n+    s1->push(createForeach(sfe, aloc, pparams[0], new CompoundStatement(aloc, sfebody)));\n+    s1->push(new ExpStatement(aloc, new AssertExp(aloc, new IntegerExp(aloc, 0, Type::tint32))));\n+    Type *ety = new TypeTypeof(aloc, wrapAndCall(aloc, new CompoundStatement(aloc, s1)));\n+    Type *aty = ety->arrayOf();\n+    Identifier *idres = Identifier::generateId(\"__res\");\n+    VarDeclaration *vard = new VarDeclaration(aloc, aty, idres, NULL);\n+    Statements *s2 = new Statements();\n+    s2->push(new ExpStatement(aloc, vard));\n+    Expression *catass = new CatAssignExp(aloc, new IdentifierExp(aloc, idres), res[1]);\n+    s2->push(createForeach(sfe, aloc, pparams[1], new ExpStatement(aloc, catass)));\n+    s2->push(new ReturnStatement(aloc, new IdentifierExp(aloc, idres)));\n+    Expression *aggr = wrapAndCall(aloc, new CompoundStatement(aloc, s2));\n+    sc = sc->startCTFE();\n+    aggr = semantic(aggr, sc);\n+    aggr = resolveProperties(sc, aggr);\n+    sc = sc->endCTFE();\n+    aggr = aggr->optimize(WANTvalue);\n+    aggr = aggr->ctfeInterpret();\n+\n+    assert(!!sfe->aggrfe ^ !!sfe->rangefe);\n+    sfe->aggrfe = new ForeachStatement(sfe->loc, TOKforeach, pparams[2], aggr,\n+                                  sfe->aggrfe ? sfe->aggrfe->_body : sfe->rangefe->_body,\n+                                  sfe->aggrfe ? sfe->aggrfe->endloc : sfe->rangefe->endloc);\n+    sfe->rangefe = NULL;\n+    lowerArrayAggregate(sfe, sc); // finally, turn generated array into expression tuple\n+}\n+\n+/*****************************************\n+ * Perform `static foreach` lowerings that are necessary in order\n+ * to finally expand the `static foreach` using\n+ * `ddmd.statementsem.makeTupleForeach`.\n+ */\n+\n+void staticForeachPrepare(StaticForeach *sfe, Scope *sc)\n+{\n+    assert(sc);\n+    if (sfe->aggrfe)\n+    {\n+        sc = sc->startCTFE();\n+        sfe->aggrfe->aggr = semantic(sfe->aggrfe->aggr, sc);\n+        sc = sc->endCTFE();\n+        sfe->aggrfe->aggr = sfe->aggrfe->aggr->optimize(WANTvalue);\n+        Type *tab = sfe->aggrfe->aggr->type->toBasetype();\n+        if (tab->ty != Ttuple)\n+        {\n+            sfe->aggrfe->aggr = sfe->aggrfe->aggr->ctfeInterpret();\n+        }\n+    }\n+\n+    if (sfe->aggrfe && sfe->aggrfe->aggr->type->toBasetype()->ty == Terror)\n+    {\n+        return;\n+    }\n+\n+    if (!staticForeachReady(sfe))\n+    {\n+        if (sfe->aggrfe && sfe->aggrfe->aggr->type->toBasetype()->ty == Tarray)\n+        {\n+            lowerArrayAggregate(sfe, sc);\n+        }\n+        else\n+        {\n+            lowerNonArrayAggregate(sfe, sc);\n+        }\n+    }\n+}\n+\n+/*****************************************\n+ * Returns:\n+ *     `true` iff ready to call `ddmd.statementsem.makeTupleForeach`.\n+ */\n+\n+bool staticForeachReady(StaticForeach *sfe)\n+{\n+    return sfe->aggrfe && sfe->aggrfe->aggr && sfe->aggrfe->aggr->type &&\n+        sfe->aggrfe->aggr->type->toBasetype()->ty == Ttuple;\n+}\n+\n+/* ============================================================ */\n+\n DVCondition::DVCondition(Module *mod, unsigned level, Identifier *ident)\n         : Condition(Loc())\n {\n@@ -324,7 +647,6 @@ StaticIfCondition::StaticIfCondition(Loc loc, Expression *exp)\n     : Condition(loc)\n {\n     this->exp = exp;\n-    this->nest = 0;\n }\n \n Condition *StaticIfCondition::syntaxCopy()\n@@ -336,28 +658,19 @@ int StaticIfCondition::include(Scope *sc, ScopeDsymbol *sds)\n {\n     if (inc == 0)\n     {\n-        if (exp->op == TOKerror || nest > 100)\n-        {\n-            error(loc, (nest > 1000) ? \"unresolvable circular static if expression\"\n-                                     : \"error evaluating static if expression\");\n-            goto Lerror;\n-        }\n-\n         if (!sc)\n         {\n             error(loc, \"static if conditional cannot be at global scope\");\n             inc = 2;\n             return 0;\n         }\n \n-        ++nest;\n         sc = sc->push(sc->scopesym);\n         sc->sds = sds;                  // sds gets any addMember()\n \n         bool errors = false;\n         bool result = evalStaticCondition(sc, exp, exp, errors);\n         sc->pop();\n-        --nest;\n \n         // Prevent repeated condition evaluation.\n         // See: fail_compilation/fail7815.d"}, {"sha": "576de8c26c2b3a2002d43f2eff04e2ec085dbf20", "filename": "gcc/d/dmd/cond.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fcond.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fcond.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcond.h?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -53,9 +53,13 @@ class StaticForeach\n \n     bool needExpansion;\n \n+    StaticForeach(Loc loc, ForeachStatement *aggrfe, ForeachRangeStatement *rangefe);\n     StaticForeach *syntaxCopy();\n };\n \n+void staticForeachPrepare(StaticForeach *sfe, Scope *sc);\n+bool staticForeachReady(StaticForeach *sfe);\n+\n class DVCondition : public Condition\n {\n public:\n@@ -100,7 +104,6 @@ class StaticIfCondition : public Condition\n {\n public:\n     Expression *exp;\n-    int nest;         // limit circular dependencies\n \n     StaticIfCondition(Loc loc, Expression *exp);\n     Condition *syntaxCopy();"}, {"sha": "6179bfd789eff3533288c083a69017c567c3d52d", "filename": "gcc/d/dmd/cppmangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fcppmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fcppmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcppmangle.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -261,7 +261,7 @@ class CppMangleVisitor : public Visitor\n                     fatal();\n                 }\n             }\n-            else if(tp->isTemplateThisParameter())\n+            else if (tp->isTemplateThisParameter())\n             {\n                 ti->error(\"Internal Compiler Error: C++ `%s` template this parameter is not supported\", o->toChars());\n                 fatal();"}, {"sha": "806e29d690738ce56e5327aaaacfc18067134523", "filename": "gcc/d/dmd/declaration.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fdeclaration.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fdeclaration.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -340,14 +340,20 @@ void AliasDeclaration::semantic(Scope *sc)\n void AliasDeclaration::aliasSemantic(Scope *sc)\n {\n     //printf(\"AliasDeclaration::semantic() %s\\n\", toChars());\n+    // TypeTraits needs to know if it's located in an AliasDeclaration\n+    sc->flags |= SCOPEalias;\n+\n     if (aliassym)\n     {\n         FuncDeclaration *fd = aliassym->isFuncLiteralDeclaration();\n         TemplateDeclaration *td = aliassym->isTemplateDeclaration();\n         if (fd || (td && td->literal))\n         {\n             if (fd && fd->semanticRun >= PASSsemanticdone)\n+            {\n+                sc->flags &= ~SCOPEalias;\n                 return;\n+            }\n \n             Expression *e = new FuncExp(loc, aliassym);\n             e = ::semantic(e, sc);\n@@ -361,11 +367,13 @@ void AliasDeclaration::aliasSemantic(Scope *sc)\n                 aliassym = NULL;\n                 type = Type::terror;\n             }\n+            sc->flags &= ~SCOPEalias;\n             return;\n         }\n \n         if (aliassym->isTemplateInstance())\n             aliassym->semantic(sc);\n+        sc->flags &= ~SCOPEalias;\n         return;\n     }\n     inuse = 1;\n@@ -470,6 +478,7 @@ void AliasDeclaration::aliasSemantic(Scope *sc)\n         if (!overloadInsert(sx))\n             ScopeDsymbol::multiplyDefined(Loc(), sx, this);\n     }\n+    sc->flags &= ~SCOPEalias;\n }\n \n bool AliasDeclaration::overloadInsert(Dsymbol *s)"}, {"sha": "61f5cdb0730ab0bf6b60d41afea82a75558f41de", "filename": "gcc/d/dmd/dinterpret.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fdinterpret.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fdinterpret.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -4649,6 +4649,10 @@ class Interpreter : public Visitor\n                     result = getVarExp(e->loc, istate, ((SymbolExp *)ea)->var, ctfeNeedRvalue);\n                 else if (ea->op == TOKaddress)\n                     result = interpret(((AddrExp *)ea)->e1, istate);\n+                // https://issues.dlang.org/show_bug.cgi?id=18871\n+                // https://issues.dlang.org/show_bug.cgi?id=18819\n+                else if (ea->op == TOKarrayliteral)\n+                    result = interpret((ArrayLiteralExp *)ea, istate);\n                 else\n                     assert(0);\n                 if (CTFEExp::isCantExp(result))"}, {"sha": "f41f6284dc515619c799104da34e3c11f8a9f0c1", "filename": "gcc/d/dmd/dmangle.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fdmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fdmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -80,6 +80,7 @@ void initTypeMangle()\n     mangleChar[Tslice] = \"@\";\n     mangleChar[Treturn] = \"@\";\n     mangleChar[Tvector] = \"@\";\n+    mangleChar[Ttraits] = \"@\";\n \n     mangleChar[Tnull] = \"n\";    // same as TypeNone\n "}, {"sha": "05ab04c8989026c2b3ce2341ca71d305d2fd0e63", "filename": "gcc/d/dmd/dsymbol.c", "status": "modified", "additions": 90, "deletions": 10, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fdsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fdsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -321,20 +321,21 @@ Dsymbol *Dsymbol::toAlias2()\n  */\n Dsymbol *Dsymbol::pastMixin()\n {\n-    Dsymbol *s = this;\n-\n     //printf(\"Dsymbol::pastMixin() %s\\n\", toChars());\n-    while (s && s->isTemplateMixin())\n-        s = s->parent;\n-    return s;\n+    if (!isTemplateMixin() && !isForwardingAttribDeclaration() && !isForwardingScopeDsymbol())\n+        return this;\n+    if (!parent)\n+        return NULL;\n+    return parent->pastMixin();\n }\n \n /// ditto\n Dsymbol *Dsymbol::pastMixinAndNspace()\n {\n     //printf(\"Dsymbol::pastMixinAndNspace() %s\\n\", toChars());\n     Nspace *ns = isNspace();\n-    if (!(ns && ns->mangleOnly) && !isTemplateMixin() && !isForwardingAttribDeclaration())\n+    if (!(ns && ns->mangleOnly) &&\n+        !isTemplateMixin() && !isForwardingAttribDeclaration() && !isForwardingScopeDsymbol())\n         return this;\n     if (!parent)\n         return NULL;\n@@ -382,10 +383,12 @@ Dsymbol *Dsymbol::toParent()\n /// ditto\n Dsymbol *Dsymbol::toParent2()\n {\n-    Dsymbol *s = parent;\n-    while (s && s->isTemplateInstance())\n-        s = s->parent;\n-    return s;\n+    if (!parent ||\n+        (!parent->isTemplateInstance() &&\n+         !parent->isForwardingAttribDeclaration() &&\n+         !parent->isForwardingScopeDsymbol()))\n+        return parent;\n+    return parent->toParent2();\n }\n \n /// ditto\n@@ -951,6 +954,83 @@ const char *OverloadSet::kind() const\n }\n \n \n+/********************************* ForwardingScopeDsymbol ******************/\n+\n+ForwardingScopeDsymbol::ForwardingScopeDsymbol(ScopeDsymbol *forward)\n+    : ScopeDsymbol()\n+{\n+    this->forward = forward;\n+}\n+\n+Dsymbol *ForwardingScopeDsymbol::symtabInsert(Dsymbol *s)\n+{\n+    assert(forward);\n+    if (Declaration *d = s->isDeclaration())\n+    {\n+        if (d->storage_class & STClocal)\n+        {\n+            // Symbols with storage class STClocal are not\n+            // forwarded, but stored in the local symbol\n+            // table. (Those are the `static foreach` variables.)\n+            if (!symtab)\n+            {\n+                symtab = new DsymbolTable();\n+            }\n+            return ScopeDsymbol::symtabInsert(s); // insert locally\n+        }\n+    }\n+    if (!forward->symtab)\n+    {\n+        forward->symtab = new DsymbolTable();\n+    }\n+    // Non-STClocal symbols are forwarded to `forward`.\n+    return forward->symtabInsert(s);\n+}\n+\n+/************************\n+ * This override handles the following two cases:\n+ *     static foreach (i, i; [0]) { ... }\n+ * and\n+ *     static foreach (i; [0]) { enum i = 2; }\n+ */\n+Dsymbol *ForwardingScopeDsymbol::symtabLookup(Dsymbol *s, Identifier *id)\n+{\n+    assert(forward);\n+    // correctly diagnose clashing foreach loop variables.\n+    if (Declaration *d = s->isDeclaration())\n+    {\n+        if (d->storage_class & STClocal)\n+        {\n+            if (!symtab)\n+            {\n+                symtab = new DsymbolTable();\n+            }\n+            return ScopeDsymbol::symtabLookup(s,id);\n+        }\n+    }\n+    // Declarations within `static foreach` do not clash with\n+    // `static foreach` loop variables.\n+    if (!forward->symtab)\n+    {\n+        forward->symtab = new DsymbolTable();\n+    }\n+    return forward->symtabLookup(s,id);\n+}\n+\n+void ForwardingScopeDsymbol::importScope(Dsymbol *s, Prot protection)\n+{\n+    forward->importScope(s, protection);\n+}\n+\n+void ForwardingScopeDsymbol::semantic(Scope *)\n+{\n+}\n+\n+const char *ForwardingScopeDsymbol::kind() const\n+{\n+    return \"local scope\";\n+}\n+\n /********************************* ScopeDsymbol ****************************/\n \n ScopeDsymbol::ScopeDsymbol()"}, {"sha": "788b67e7b74ffa7c6e2b76ee5ce195de7bc52470", "filename": "gcc/d/dmd/dsymbol.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fdsymbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fdsymbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.h?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -376,8 +376,10 @@ class OverloadSet : public Dsymbol\n \n class ForwardingScopeDsymbol : public ScopeDsymbol\n {\n+public:\n     ScopeDsymbol *forward;\n \n+    ForwardingScopeDsymbol(ScopeDsymbol *forward);\n     Dsymbol *symtabInsert(Dsymbol *s);\n     Dsymbol *symtabLookup(Dsymbol *s, Identifier *id);\n     void importScope(Dsymbol *s, Prot protection);"}, {"sha": "ccfb4b69a2964a352f473ef13d4eead3be7f5405", "filename": "gcc/d/dmd/expression.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fexpression.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fexpression.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -2185,6 +2185,11 @@ StringExp *Expression::toStringExp()\n     return NULL;\n }\n \n+TupleExp *Expression::toTupleExp()\n+{\n+    return NULL;\n+}\n+\n /***************************************\n  * Return !=0 if expression is an lvalue.\n  */\n@@ -4542,6 +4547,11 @@ Expression *TupleExp::syntaxCopy()\n     return new TupleExp(loc, e0 ? e0->syntaxCopy() : NULL, arraySyntaxCopy(exps));\n }\n \n+TupleExp *TupleExp::toTupleExp()\n+{\n+    return this;\n+}\n+\n /******************************** FuncExp *********************************/\n \n FuncExp::FuncExp(Loc loc, Dsymbol *s)"}, {"sha": "60448600e24fb41e2b098db2b0aff9ed5c4efd83", "filename": "gcc/d/dmd/expression.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fexpression.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fexpression.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.h?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -157,6 +157,7 @@ class Expression : public RootObject\n     virtual real_t toImaginary();\n     virtual complex_t toComplex();\n     virtual StringExp *toStringExp();\n+    virtual TupleExp *toTupleExp();\n     virtual bool isLvalue();\n     virtual Expression *toLvalue(Scope *sc, Expression *e);\n     virtual Expression *modifiableLvalue(Scope *sc, Expression *e);\n@@ -397,6 +398,7 @@ class TupleExp : public Expression\n     TupleExp(Loc loc, Expression *e0, Expressions *exps);\n     TupleExp(Loc loc, Expressions *exps);\n     TupleExp(Loc loc, TupleDeclaration *tup);\n+    TupleExp *toTupleExp();\n     Expression *syntaxCopy();\n     bool equals(RootObject *o);\n "}, {"sha": "781bd3ea5fdbaed983f5f01bf80b23054e8fe211", "filename": "gcc/d/dmd/expressionsem.c", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -1758,15 +1758,30 @@ class ExpressionSemanticVisitor : public Visitor\n                 else\n                 {\n                     // Disallow shadowing\n-                    for (Scope *scx = sc->enclosing; scx && scx->func == sc->func; scx = scx->enclosing)\n+                    for (Scope *scx = sc->enclosing; scx && (scx->func == sc->func || (scx->func && sc->func->fes)); scx = scx->enclosing)\n                     {\n                         Dsymbol *s2;\n                         if (scx->scopesym && scx->scopesym->symtab &&\n                             (s2 = scx->scopesym->symtab->lookup(s->ident)) != NULL &&\n                             s != s2)\n                         {\n-                            e->error(\"%s %s is shadowing %s %s\", s->kind(), s->ident->toChars(), s2->kind(), s2->toPrettyChars());\n-                            return setError();\n+                            // allow STClocal symbols to be shadowed\n+                            // TODO: not reallly an optimal design\n+                            Declaration *decl = s2->isDeclaration();\n+                            if (!decl || !(decl->storage_class & STClocal))\n+                            {\n+                                if (sc->func->fes)\n+                                {\n+                                    e->deprecation(\"%s `%s` is shadowing %s `%s`. Rename the `foreach` variable.\",\n+                                        s->kind(), s->ident->toChars(), s2->kind(), s2->toPrettyChars());\n+                                }\n+                                else\n+                                {\n+                                    e->error(\"%s %s is shadowing %s %s\",\n+                                        s->kind(), s->ident->toChars(), s2->kind(), s2->toPrettyChars());\n+                                    return setError();\n+                                }\n+                            }\n                         }\n                     }\n                 }\n@@ -7930,6 +7945,12 @@ class ExpressionSemanticVisitor : public Visitor\n         if (f1 || f2)\n             return setError();\n \n+        if (exp->e1->op == TOKtype || exp->e2->op == TOKtype)\n+        {\n+            result = exp->incompatibleTypes();\n+            return;\n+        }\n+\n         exp->type = Type::tbool;\n \n         if (exp->e1->type != exp->e2->type && exp->e1->type->isfloating() && exp->e2->type->isfloating())"}, {"sha": "ab74dc5328b3ad7d43bbe6887fc67e925c626c64", "filename": "gcc/d/dmd/func.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Ffunc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Ffunc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -1491,8 +1491,7 @@ void FuncDeclaration::semantic3(Scope *sc)\n          * e.g.\n          *      class C { int x; static assert(is(typeof({ this.x = 1; }))); }\n          *\n-         * To properly accept it, mark these lambdas as member functions -\n-         * isThis() returns true and isNested() returns false.\n+         * To properly accept it, mark these lambdas as member functions.\n          */\n         if (FuncLiteralDeclaration *fld = isFuncLiteralDeclaration())\n         {\n@@ -1510,7 +1509,6 @@ void FuncDeclaration::semantic3(Scope *sc)\n                     if (fld->tok != TOKfunction)\n                         fld->tok = TOKdelegate;\n                 }\n-                assert(!isNested());\n             }\n         }\n "}, {"sha": "2436f6eba8fe5503f7880df1f2fab271a2096fca", "filename": "gcc/d/dmd/hdrgen.c", "status": "modified", "additions": 65, "deletions": 3, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fhdrgen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fhdrgen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -249,7 +249,7 @@ class PrettyPrintVisitor : public Visitor\n         buf->writenl();\n     }\n \n-    void visit(ForeachStatement *s)\n+    void foreachWithoutBody(ForeachStatement *s)\n     {\n         buf->writestring(Token::toChars(s->op));\n         buf->writestring(\" (\");\n@@ -269,6 +269,11 @@ class PrettyPrintVisitor : public Visitor\n         s->aggr->accept(this);\n         buf->writeByte(')');\n         buf->writenl();\n+    }\n+\n+    void visit(ForeachStatement *s)\n+    {\n+        foreachWithoutBody(s);\n         buf->writeByte('{');\n         buf->writenl();\n         buf->level++;\n@@ -279,7 +284,7 @@ class PrettyPrintVisitor : public Visitor\n         buf->writenl();\n     }\n \n-    void visit(ForeachRangeStatement *s)\n+    void foreachRangeWithoutBody(ForeachRangeStatement *s)\n     {\n         buf->writestring(Token::toChars(s->op));\n         buf->writestring(\" (\");\n@@ -297,6 +302,11 @@ class PrettyPrintVisitor : public Visitor\n         buf->writenl();\n         buf->writeByte('{');\n         buf->writenl();\n+    }\n+\n+    void visit(ForeachRangeStatement *s)\n+    {\n+        foreachRangeWithoutBody(s);\n         buf->level++;\n         if (s->_body)\n             s->_body->accept(this);\n@@ -305,6 +315,20 @@ class PrettyPrintVisitor : public Visitor\n         buf->writenl();\n     }\n \n+    void visit(StaticForeachStatement *s)\n+    {\n+        buf->writestring(\"static \");\n+        if (s->sfe->aggrfe)\n+        {\n+            visit(s->sfe->aggrfe);\n+        }\n+        else\n+        {\n+            assert(s->sfe->rangefe);\n+            visit(s->sfe->rangefe);\n+        }\n+    }\n+\n     void visit(IfStatement *s)\n     {\n         buf->writestring(\"if (\");\n@@ -767,6 +791,12 @@ class PrettyPrintVisitor : public Visitor\n         buf->writestring(t->dstring);\n     }\n \n+    void visit(TypeTraits *t)\n+    {\n+        //printf(\"TypeBasic::toCBuffer2(t.mod = %d)\\n\", t.mod);\n+        t->exp->accept(this);\n+    }\n+\n     void visit(TypeVector *t)\n     {\n         //printf(\"TypeVector::toCBuffer2(t->mod = %d)\\n\", t->mod);\n@@ -1360,6 +1390,32 @@ class PrettyPrintVisitor : public Visitor\n         buf->writenl();\n     }\n \n+    void visit(ForwardingStatement *s)\n+    {\n+        s->statement->accept(this);\n+    }\n+\n+    void visit(StaticForeachDeclaration *s)\n+    {\n+        buf->writestring(\"static \");\n+        if (s->sfe->aggrfe)\n+        {\n+            foreachWithoutBody(s->sfe->aggrfe);\n+        }\n+        else\n+        {\n+            assert(s->sfe->rangefe);\n+            foreachRangeWithoutBody(s->sfe->rangefe);\n+        }\n+        buf->writeByte('{');\n+        buf->writenl();\n+        buf->level++;\n+        visit((AttribDeclaration *)s);\n+        buf->level--;\n+        buf->writeByte('}');\n+        buf->writenl();\n+    }\n+\n     void visit(CompileDeclaration *d)\n     {\n         buf->writestring(\"mixin(\");\n@@ -1787,6 +1843,8 @@ class PrettyPrintVisitor : public Visitor\n \n     void visit(AliasDeclaration *d)\n     {\n+        if (d->storage_class & STClocal)\n+            return;\n         buf->writestring(\"alias \");\n         if (d->aliassym)\n         {\n@@ -1818,6 +1876,8 @@ class PrettyPrintVisitor : public Visitor\n \n     void visit(VarDeclaration *d)\n     {\n+        if (d->storage_class & STClocal)\n+            return;\n         visitVarDecl(d, false);\n         buf->writeByte(';');\n         buf->writenl();\n@@ -2653,7 +2713,8 @@ class PrettyPrintVisitor : public Visitor\n     void visit(TraitsExp *e)\n     {\n         buf->writestring(\"__traits(\");\n-        buf->writestring(e->ident->toChars());\n+        if (e->ident)\n+            buf->writestring(e->ident->toChars());\n         if (e->args)\n         {\n             for (size_t i = 0; i < e->args->dim; i++)\n@@ -3241,6 +3302,7 @@ const char *stcToChars(StorageClass& stc)\n         { STCsystem,       TOKat,       \"@system\" },\n         { STCdisable,      TOKat,       \"@disable\" },\n         { STCfuture,       TOKat,       \"@__future\" },\n+        { STClocal,        TOKat,       \"__local\" },\n         { 0,               TOKreserved, NULL }\n     };\n "}, {"sha": "7bd44ab1fc2fe61d03e230c0c9d99260eee5c109", "filename": "gcc/d/dmd/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finit.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -238,7 +238,7 @@ bool hasNonConstPointers(Expression *e)\n             return arrayHasNonConstPointers(ae->keys);\n         return false;\n     }\n-    if(e->op == TOKaddress)\n+    if (e->op == TOKaddress)\n     {\n         AddrExp *ae = (AddrExp *)e;\n         if (ae->e1->op == TOKstructliteral)"}, {"sha": "c56d7ba8a9379a4299feb67c7c7ddc387d56403c", "filename": "gcc/d/dmd/intrange.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fintrange.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fintrange.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fintrange.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -610,7 +610,7 @@ IntRange IntRange::operator/(const IntRange& rhs) const\n     {\n         r.imax.value--;\n     }\n-    else if(r.imin.value == 0)\n+    else if (r.imin.value == 0)\n     {\n         r.imin.value++;\n     }"}, {"sha": "fa49e9240e2a45718cd5342ea189016c584e9ef0", "filename": "gcc/d/dmd/json.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fjson.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fjson.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fjson.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -454,6 +454,8 @@ class ToJsonVisitor : public Visitor\n \n     void jsonProperties(Declaration *d)\n     {\n+        if (d->storage_class & STClocal)\n+            return;\n         jsonProperties((Dsymbol *)d);\n \n         propertyStorageClass(\"storageClass\", d->storage_class);\n@@ -843,6 +845,8 @@ class ToJsonVisitor : public Visitor\n \n     void visit(VarDeclaration *d)\n     {\n+        if (d->storage_class & STClocal)\n+            return;\n         objectStart();\n \n         jsonProperties(d);"}, {"sha": "aa1880624cebc52efba6ab7b54135b120ca88c62", "filename": "gcc/d/dmd/mtype.c", "status": "modified", "additions": 151, "deletions": 1, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fmtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fmtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -202,6 +202,7 @@ void Type::_init()\n     sizeTy[Terror] = sizeof(TypeError);\n     sizeTy[Tnull] = sizeof(TypeNull);\n     sizeTy[Tvector] = sizeof(TypeVector);\n+    sizeTy[Ttraits] = sizeof(TypeTraits);\n \n     initTypeMangle();\n \n@@ -6459,7 +6460,7 @@ Type *TypeDelegate::addStorageClass(StorageClass stc)\n      *  alias dg_t = void* delegate();\n      *  scope dg_t dg = ...;\n      */\n-    if(stc & STCscope)\n+    if (stc & STCscope)\n     {\n         Type *n = t->next->addStorageClass(STCscope | STCscopeinferred);\n         if (n != t->next)\n@@ -6554,7 +6555,156 @@ bool TypeDelegate::hasPointers()\n     return true;\n }\n \n+/***************************** TypeTraits ********************************/\n+\n+TypeTraits::TypeTraits(const Loc &loc, TraitsExp *exp)\n+     : Type(Ttraits)\n+{\n+    this->loc = loc;\n+    this->exp = exp;\n+    this->sym = NULL;\n+}\n+\n+Type *TypeTraits::syntaxCopy()\n+{\n+    TraitsExp *te = (TraitsExp *) exp->syntaxCopy();\n+    TypeTraits *tt = new TypeTraits(loc, te);\n+    tt->mod = mod;\n+    return tt;\n+}\n \n+Type *TypeTraits::semantic(Loc, Scope *sc)\n+{\n+    if (ty == Terror)\n+        return this;\n+\n+    const int inAlias = (sc->flags & SCOPEalias) != 0;\n+    if (exp->ident != Id::allMembers &&\n+        exp->ident != Id::derivedMembers &&\n+        exp->ident != Id::getMember &&\n+        exp->ident != Id::parent &&\n+        exp->ident != Id::getOverloads &&\n+        exp->ident != Id::getVirtualFunctions &&\n+        exp->ident != Id::getVirtualMethods &&\n+        exp->ident != Id::getAttributes &&\n+        exp->ident != Id::getUnitTests &&\n+        exp->ident != Id::getAliasThis)\n+    {\n+        static const char *ctxt[2] = {\"as type\", \"in alias\"};\n+        ::error(loc, \"trait `%s` is either invalid or not supported %s\",\n+                exp->ident->toChars(), ctxt[inAlias]);\n+        ty = Terror;\n+        return this;\n+    }\n+\n+    Type *result = NULL;\n+\n+    if (Expression *e = semanticTraits(exp, sc))\n+    {\n+        switch (e->op)\n+        {\n+        case TOKdotvar:\n+            sym = ((DotVarExp *)e)->var;\n+            break;\n+        case TOKvar:\n+            sym = ((VarExp *)e)->var;\n+            break;\n+        case TOKfunction:\n+        {\n+            FuncExp *fe = (FuncExp *)e;\n+            if (fe->td)\n+                sym = fe->td;\n+            else\n+                sym = fe->fd;\n+            break;\n+        }\n+        case TOKdottd:\n+            sym = ((DotTemplateExp*)e)->td;\n+            break;\n+        case TOKdsymbol:\n+            sym = ((DsymbolExp *)e)->s;\n+            break;\n+        case TOKtemplate:\n+            sym = ((TemplateExp *)e)->td;\n+            break;\n+        case TOKscope:\n+            sym = ((ScopeExp *)e)->sds;\n+            break;\n+        case TOKtuple:\n+        {\n+            TupleExp *te = e->toTupleExp();\n+            Objects *elems = new Objects;\n+            elems->setDim(te->exps->dim);\n+            for (size_t i = 0; i < elems->dim; i++)\n+            {\n+                Expression *src = (*te->exps)[i];\n+                switch (src->op)\n+                {\n+                case TOKtype:\n+                    (*elems)[i] = ((TypeExp *)src)->type;\n+                    break;\n+                case TOKdottype:\n+                    (*elems)[i] = ((DotTypeExp *)src)->type;\n+                    break;\n+                case TOKoverloadset:\n+                    (*elems)[i] = ((OverExp *)src)->type;\n+                    break;\n+                default:\n+                    if (Dsymbol *sym = isDsymbol(src))\n+                        (*elems)[i] = sym;\n+                    else\n+                        (*elems)[i] = src;\n+                }\n+            }\n+            TupleDeclaration *td = new TupleDeclaration(e->loc,\n+                Identifier::generateId(\"__aliastup\"), elems);\n+            sym = td;\n+            break;\n+        }\n+        case TOKdottype:\n+            result = isType(((DotTypeExp *)e)->sym);\n+            break;\n+        case TOKtype:\n+            result = ((TypeExp *)e)->type;\n+            break;\n+        case TOKoverloadset:\n+            result = ((OverExp *)e)->type;\n+            break;\n+        default:\n+            break;\n+        }\n+    }\n+\n+    if (result)\n+        result = result->addMod(mod);\n+    if (!inAlias && !result)\n+    {\n+        if (!global.errors)\n+            ::error(loc, \"`%s` does not give a valid type\", toChars());\n+        return Type::terror;\n+    }\n+\n+    return result;\n+}\n+\n+void TypeTraits::resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool)\n+{\n+    *pt = NULL;\n+    *pe = NULL;\n+    *ps = NULL;\n+\n+    if (Type *t = semantic(loc, sc))\n+        *pt = t;\n+    else if (sym)\n+        *ps = sym;\n+    else\n+        *pt = Type::terror;\n+}\n+\n+d_uns64 TypeTraits::size(Loc)\n+{\n+    return SIZE_INVALID;\n+}\n \n /***************************** TypeQualified *****************************/\n "}, {"sha": "22fabf585ea75fe5e925a6c1df295ff4f37d06d9", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -94,6 +94,7 @@ enum ENUMTY\n     Tvector,\n     Tint128,\n     Tuns128,\n+    Ttraits,\n     TMAX\n };\n typedef unsigned char TY;       // ENUMTY\n@@ -659,6 +660,23 @@ class TypeDelegate : public TypeNext\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n+class TypeTraits : public Type\n+{\n+public:\n+    Loc loc;\n+    /// The expression to resolve as type or symbol.\n+    TraitsExp *exp;\n+    /// The symbol when exp doesn't represent a type.\n+    Dsymbol *sym;\n+\n+    TypeTraits(const Loc &loc, TraitsExp *exp);\n+    Type *syntaxCopy();\n+    Type *semantic(Loc loc, Scope *sc);\n+    void resolve(Loc loc, Scope *sc, Expression **pe, Type **pt, Dsymbol **ps, bool intypeid = false);\n+    d_uns64 size(Loc loc);\n+    void accept(Visitor *v) { v->visit(this); }\n+};\n+\n class TypeQualified : public Type\n {\n public:"}, {"sha": "b66bddb8ef87aa996832bcd75edd91bdb5db975a", "filename": "gcc/d/dmd/parse.c", "status": "modified", "additions": 203, "deletions": 101, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -351,6 +351,7 @@ Dsymbols *Parser::parseDeclDefs(int once, Dsymbol **pLastDecl, PrefixAttributes\n             case TOKunion:\n             case TOKclass:\n             case TOKinterface:\n+            case TOKtraits:\n             Ldeclaration:\n                 a = parseDeclarations(false, pAttrs, pAttrs->comment);\n                 if (a && a->dim)\n@@ -485,6 +486,10 @@ Dsymbols *Parser::parseDeclDefs(int once, Dsymbol **pLastDecl, PrefixAttributes\n                     a = parseImport();\n                     // keep pLastDecl\n                 }\n+                else if (next == TOKforeach || next == TOKforeach_reverse)\n+                {\n+                    s = parseForeachStaticDecl(token.loc, pLastDecl);\n+                }\n                 else\n                 {\n                     stc = STCstatic;\n@@ -3144,6 +3149,18 @@ Type *Parser::parseBasicType(bool dontLookDotIdents)\n             t = parseVector();\n             break;\n \n+        case TOKtraits:\n+            if (TraitsExp *te = (TraitsExp *) parsePrimaryExp())\n+            {\n+                if (te->ident && te->args)\n+                {\n+                    t = new TypeTraits(token.loc, te);\n+                    break;\n+                }\n+            }\n+            t = new TypeError();\n+            break;\n+\n         case TOKconst:\n             // const(type)\n             nextToken();\n@@ -4699,6 +4716,161 @@ void Parser::checkCstyleTypeSyntax(Loc loc, Type *t, int alt, Identifier *ident)\n \n }\n \n+/*****************************************\n+ * Parses `foreach` statements, `static foreach` statements and\n+ * `static foreach` declarations.  The template parameter\n+ * `isStatic` is true, iff a `static foreach` should be parsed.\n+ * If `isStatic` is true, `isDecl` can be true to indicate that a\n+ * `static foreach` declaration should be parsed.\n+ */\n+Statement *Parser::parseForeach(Loc loc, bool *isRange, bool isDecl)\n+{\n+    TOK op = token.value;\n+\n+    nextToken();\n+    check(TOKlparen);\n+\n+    Parameters *parameters = new Parameters();\n+\n+    while (1)\n+    {\n+        Identifier *ai = NULL;\n+        Type *at;\n+\n+        StorageClass storageClass = 0;\n+        StorageClass stc = 0;\n+    Lagain:\n+        if (stc)\n+        {\n+            storageClass = appendStorageClass(storageClass, stc);\n+            nextToken();\n+        }\n+        switch (token.value)\n+        {\n+            case TOKref:\n+                stc = STCref;\n+                goto Lagain;\n+\n+            case TOKenum:\n+                stc = STCmanifest;\n+                goto Lagain;\n+\n+            case TOKalias:\n+                storageClass = appendStorageClass(storageClass, STCalias);\n+                nextToken();\n+                break;\n+\n+            case TOKconst:\n+                if (peekNext() != TOKlparen)\n+                {\n+                    stc = STCconst;\n+                    goto Lagain;\n+                }\n+                break;\n+\n+            case TOKimmutable:\n+                if (peekNext() != TOKlparen)\n+                {\n+                    stc = STCimmutable;\n+                    goto Lagain;\n+                }\n+                break;\n+\n+            case TOKshared:\n+                if (peekNext() != TOKlparen)\n+                {\n+                    stc = STCshared;\n+                    goto Lagain;\n+                }\n+                break;\n+\n+            case TOKwild:\n+                if (peekNext() != TOKlparen)\n+                {\n+                    stc = STCwild;\n+                    goto Lagain;\n+                }\n+                break;\n+\n+            default:\n+                break;\n+        }\n+        if (token.value == TOKidentifier)\n+        {\n+            Token *t = peek(&token);\n+            if (t->value == TOKcomma || t->value == TOKsemicolon)\n+            {   ai = token.ident;\n+                at = NULL;              // infer argument type\n+                nextToken();\n+                goto Larg;\n+            }\n+        }\n+        at = parseType(&ai);\n+        if (!ai)\n+            error(\"no identifier for declarator %s\", at->toChars());\n+      Larg:\n+        Parameter *p = new Parameter(storageClass, at, ai, NULL);\n+        parameters->push(p);\n+        if (token.value == TOKcomma)\n+        {   nextToken();\n+            continue;\n+        }\n+        break;\n+    }\n+    check(TOKsemicolon);\n+\n+    Expression *aggr = parseExpression();\n+    if (token.value == TOKslice && parameters->dim == 1)\n+    {\n+        Parameter *p = (*parameters)[0];\n+        delete parameters;\n+        nextToken();\n+        Expression *upr = parseExpression();\n+        check(TOKrparen);\n+        Loc endloc;\n+        Statement *body = (!isDecl) ? parseStatement(0, NULL, &endloc) : NULL;\n+        if (isRange)\n+            *isRange = true;\n+        return new ForeachRangeStatement(loc, op, p, aggr, upr, body, endloc);\n+    }\n+    else\n+    {\n+        check(TOKrparen);\n+        Loc endloc;\n+        Statement *body = (!isDecl) ? parseStatement(0, NULL, &endloc) : NULL;\n+        if (isRange) \n+            *isRange = false;\n+        return new ForeachStatement(loc, op, parameters, aggr, body, endloc);\n+    }\n+}\n+\n+Dsymbol *Parser::parseForeachStaticDecl(Loc loc, Dsymbol **pLastDecl)\n+{\n+    nextToken();\n+\n+    bool isRange = false;\n+    Statement *s = parseForeach(loc, &isRange, true);\n+\n+    return new StaticForeachDeclaration(\n+        new StaticForeach(loc, isRange ? NULL : (ForeachStatement *)s,\n+                          isRange ? (ForeachRangeStatement *)s : NULL),\n+        parseBlock(pLastDecl)\n+    );\n+}\n+\n+Statement *Parser::parseForeachStatic(Loc loc)\n+{\n+    nextToken();\n+\n+    bool isRange = false;\n+    Statement *s = parseForeach(loc, &isRange, false);\n+\n+    return new StaticForeachStatement(loc,\n+        new StaticForeach(loc, isRange ? NULL : (ForeachStatement *)s,\n+                          isRange ? (ForeachRangeStatement *)s : NULL)\n+    );\n+}\n+\n /*****************************************\n  * Input:\n  *      flags   PSxxxx\n@@ -4757,6 +4929,7 @@ Statement *Parser::parseStatement(int flags, const utf8_t** endPtr, Loc *pEndloc\n         case TOKdot:\n         case TOKtypeof:\n         case TOKvector:\n+        case TOKtraits:\n             /* Bugzilla 15163: If tokens can be handled as\n              * old C-style declaration or D expression, prefer the latter.\n              */\n@@ -4805,7 +4978,6 @@ Statement *Parser::parseStatement(int flags, const utf8_t** endPtr, Loc *pEndloc\n         case TOKtypeid:\n         case TOKis:\n         case TOKlbracket:\n-        case TOKtraits:\n         case TOKfile:\n         case TOKfilefullpath:\n         case TOKline:\n@@ -4834,6 +5006,13 @@ Statement *Parser::parseStatement(int flags, const utf8_t** endPtr, Loc *pEndloc\n                 cond = parseStaticIfCondition();\n                 goto Lcondition;\n             }\n+            else if (t->value == TOKforeach || t->value == TOKforeach_reverse)\n+            {\n+                s = parseForeachStatic(loc);\n+                if (flags & PSscope)\n+                    s = new ScopeStatement(loc, s, token.loc);\n+                break;\n+            }\n             if (t->value == TOKimport)\n             {\n                 Dsymbols *imports = parseImport();\n@@ -5086,106 +5265,7 @@ Statement *Parser::parseStatement(int flags, const utf8_t** endPtr, Loc *pEndloc\n         case TOKforeach:\n         case TOKforeach_reverse:\n         {\n-            TOK op = token.value;\n-\n-            nextToken();\n-            check(TOKlparen);\n-\n-            Parameters *parameters = new Parameters();\n-\n-            while (1)\n-            {\n-                Identifier *ai = NULL;\n-                Type *at;\n-\n-                StorageClass storageClass = 0;\n-                StorageClass stc = 0;\n-            Lagain:\n-                if (stc)\n-                {\n-                    storageClass = appendStorageClass(storageClass, stc);\n-                    nextToken();\n-                }\n-                switch (token.value)\n-                {\n-                    case TOKref:\n-                        stc = STCref;\n-                        goto Lagain;\n-\n-                    case TOKconst:\n-                        if (peekNext() != TOKlparen)\n-                        {\n-                            stc = STCconst;\n-                            goto Lagain;\n-                        }\n-                        break;\n-                    case TOKimmutable:\n-                        if (peekNext() != TOKlparen)\n-                        {\n-                            stc = STCimmutable;\n-                            goto Lagain;\n-                        }\n-                        break;\n-                    case TOKshared:\n-                        if (peekNext() != TOKlparen)\n-                        {\n-                            stc = STCshared;\n-                            goto Lagain;\n-                        }\n-                        break;\n-                    case TOKwild:\n-                        if (peekNext() != TOKlparen)\n-                        {\n-                            stc = STCwild;\n-                            goto Lagain;\n-                        }\n-                        break;\n-                    default:\n-                        break;\n-                }\n-                if (token.value == TOKidentifier)\n-                {\n-                    Token *t = peek(&token);\n-                    if (t->value == TOKcomma || t->value == TOKsemicolon)\n-                    {   ai = token.ident;\n-                        at = NULL;              // infer argument type\n-                        nextToken();\n-                        goto Larg;\n-                    }\n-                }\n-                at = parseType(&ai);\n-                if (!ai)\n-                    error(\"no identifier for declarator %s\", at->toChars());\n-              Larg:\n-                Parameter *p = new Parameter(storageClass, at, ai, NULL);\n-                parameters->push(p);\n-                if (token.value == TOKcomma)\n-                {   nextToken();\n-                    continue;\n-                }\n-                break;\n-            }\n-            check(TOKsemicolon);\n-\n-            Expression *aggr = parseExpression();\n-            if (token.value == TOKslice && parameters->dim == 1)\n-            {\n-                Parameter *p = (*parameters)[0];\n-                delete parameters;\n-                nextToken();\n-                Expression *upr = parseExpression();\n-                check(TOKrparen);\n-                Loc endloc;\n-                Statement *body = parseStatement(0, NULL, &endloc);\n-                s = new ForeachRangeStatement(loc, op, p, aggr, upr, body, endloc);\n-            }\n-            else\n-            {\n-                check(TOKrparen);\n-                Loc endloc;\n-                Statement *body = parseStatement(0, NULL, &endloc);\n-                s = new ForeachStatement(loc, op, parameters, aggr, body, endloc);\n-            }\n+            s = parseForeach(loc, NULL, false);\n             break;\n         }\n \n@@ -6001,6 +6081,27 @@ bool Parser::isBasicType(Token **pt)\n                 goto Lfalse;\n             goto L3;\n \n+        case TOKtraits:\n+        {\n+            // __traits(getMember\n+            t = peek(t);\n+            if (t->value != TOKlparen)\n+                goto Lfalse;\n+            Token *lp = t;\n+            t = peek(t);\n+            if (t->value != TOKidentifier || t->ident != Id::getMember)\n+                goto Lfalse;\n+            if (!skipParens(lp, &lp))\n+                goto Lfalse;\n+            // we are in a lookup for decl VS statement\n+            // so we expect a declarator following __trait if it's a type.\n+            // other usages wont be ambiguous (alias, template instance, type qual, etc.)\n+            if (lp->value != TOKidentifier)\n+                goto Lfalse;\n+\n+            break;\n+        }\n+\n         case TOKconst:\n         case TOKimmutable:\n         case TOKshared:\n@@ -7390,6 +7491,7 @@ Expression *Parser::parseUnaryExp()\n                     case TOKfunction:\n                     case TOKdelegate:\n                     case TOKtypeof:\n+                    case TOKtraits:\n                     case TOKvector:\n                     case TOKfile:\n                     case TOKfilefullpath:"}, {"sha": "c5ef0b2cdb659ba51b059e9154d8178e547e5ae7", "filename": "gcc/d/dmd/parse.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.h?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -120,6 +120,9 @@ class Parser : public Lexer\n     FuncDeclaration *parseContracts(FuncDeclaration *f);\n     void checkDanglingElse(Loc elseloc);\n     void checkCstyleTypeSyntax(Loc loc, Type *t, int alt, Identifier *ident);\n+    Statement *parseForeach(Loc loc, bool *isRange, bool isDecl);\n+    Dsymbol *parseForeachStaticDecl(Loc loc, Dsymbol **pLastDecl);\n+    Statement *parseForeachStatic(Loc loc);\n     /** endPtr used for documented unittests */\n     Statement *parseStatement(int flags, const utf8_t** endPtr = NULL, Loc *pEndloc = NULL);\n     Initializer *parseInitializer();"}, {"sha": "d34a0e704f702251e1e57808e135e960f6209eba", "filename": "gcc/d/dmd/scope.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fscope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fscope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fscope.h?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -61,9 +61,10 @@ enum PINLINE;\n #define SCOPEctfe           0x0080  // inside a ctfe-only expression\n #define SCOPEcompile        0x0100  // inside __traits(compile)\n #define SCOPEignoresymbolvisibility 0x0200  // ignore symbol visibility (Bugzilla 15907)\n-#define SCOPEfullinst       0x1000  // fully instantiate templates\n \n #define SCOPEfree           0x8000  // is on free list\n+#define SCOPEfullinst       0x10000 // fully instantiate templates\n+#define SCOPEalias          0x20000 // inside alias declaration\n \n struct Scope\n {"}, {"sha": "6c3443cb9fadf83bd3879b75bb7cde22f4a3dd12", "filename": "gcc/d/dmd/statement.c", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fstatement.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fstatement.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -32,6 +32,7 @@ bool checkEscapeRef(Scope *sc, Expression *e, bool gag);\n VarDeclaration *copyToTemp(StorageClass stc, const char *name, Expression *e);\n Expression *semantic(Expression *e, Scope *sc);\n StringExp *semanticString(Scope *sc, Expression *exp, const char *s);\n+Statement *makeTupleForeachStatic(Scope *sc, ForeachStatement *fs, bool needExpansion);\n \n Identifier *fixupLabelName(Scope *sc, Identifier *ident)\n {\n@@ -410,6 +411,7 @@ Statement *toStatement(Dsymbol *s)\n         void visit(ProtDeclaration *d)          { result = visitMembers(d->loc, d->decl); }\n         void visit(AlignDeclaration *d)         { result = visitMembers(d->loc, d->decl); }\n         void visit(UserAttributeDeclaration *d) { result = visitMembers(d->loc, d->decl); }\n+        void visit(ForwardingAttribDeclaration *d) { result = visitMembers(d->loc, d->decl); }\n \n         void visit(StaticAssert *) {}\n         void visit(Import *) {}\n@@ -420,6 +422,12 @@ Statement *toStatement(Dsymbol *s)\n             result = visitMembers(d->loc, d->include(NULL, NULL));\n         }\n \n+        void visit(StaticForeachDeclaration *d)\n+        {\n+            assert(d->sfe && !!d->sfe->aggrfe ^ !!d->sfe->rangefe);\n+            result = visitMembers(d->loc, d->include(NULL, NULL));\n+        }\n+\n         void visit(CompileDeclaration *d)\n         {\n             result = visitMembers(d->loc, d->include(NULL, NULL));\n@@ -682,6 +690,72 @@ bool ScopeStatement::hasContinue()\n     return statement ? statement->hasContinue() : false;\n }\n \n+/******************************** ForwardingStatement **********************/\n+\n+/* Statement whose symbol table contains foreach index variables in a\n+ * local scope and forwards other members to the parent scope.  This\n+ * wraps a statement.\n+ *\n+ * Also see: `ddmd.attrib.ForwardingAttribDeclaration`\n+ */\n+\n+ForwardingStatement::ForwardingStatement(Loc loc, ForwardingScopeDsymbol *sym, Statement *s)\n+    : Statement(loc)\n+{\n+    this->sym = sym;\n+    assert(s);\n+    this->statement = s;\n+}\n+\n+ForwardingStatement::ForwardingStatement(Loc loc, Statement *s)\n+    : Statement(loc)\n+{\n+    this->sym = new ForwardingScopeDsymbol(NULL);\n+    this->sym->symtab = new DsymbolTable();\n+    assert(s);\n+    this->statement = s;\n+}\n+\n+Statement *ForwardingStatement::syntaxCopy()\n+{\n+    return new ForwardingStatement(loc, statement->syntaxCopy());\n+}\n+\n+/***********************\n+ * ForwardingStatements are distributed over the flattened\n+ * sequence of statements. This prevents flattening to be\n+ * \"blocked\" by a ForwardingStatement and is necessary, for\n+ * example, to support generating scope guards with `static\n+ * foreach`:\n+ *\n+ *     static foreach(i; 0 .. 10) scope(exit) writeln(i);\n+ *     writeln(\"this is printed first\");\n+ *     // then, it prints 10, 9, 8, 7, ...\n+ */\n+\n+Statements *ForwardingStatement::flatten(Scope *sc)\n+{\n+    if (!statement)\n+    {\n+        return NULL;\n+    }\n+    sc = sc->push(sym);\n+    Statements *a = statement->flatten(sc);\n+    sc = sc->pop();\n+    if (!a)\n+    {\n+        return a;\n+    }\n+    Statements *b = new Statements();\n+    b->setDim(a->dim);\n+    for (size_t i = 0; i < a->dim; i++)\n+    {\n+        Statement *s = (*a)[i];\n+        (*b)[i] = s ? new ForwardingStatement(s->loc, sym, s) : NULL;\n+    }\n+    return b;\n+}\n+\n /******************************** WhileStatement ***************************/\n \n WhileStatement::WhileStatement(Loc loc, Expression *c, Statement *b, Loc endloc)\n@@ -935,6 +1009,52 @@ Statements *ConditionalStatement::flatten(Scope *sc)\n     return a;\n }\n \n+/******************************** StaticForeachStatement ********************/\n+\n+/* Static foreach statements, like:\n+ *      void main()\n+ *      {\n+ *           static foreach(i; 0 .. 10)\n+ *           {\n+ *               pragma(msg, i);\n+ *           }\n+ *      }\n+ */\n+\n+StaticForeachStatement::StaticForeachStatement(Loc loc, StaticForeach *sfe)\n+    : Statement(loc)\n+{\n+    this->sfe = sfe;\n+}\n+\n+Statement *StaticForeachStatement::syntaxCopy()\n+{\n+    return new StaticForeachStatement(loc, sfe->syntaxCopy());\n+}\n+\n+Statements *StaticForeachStatement::flatten(Scope *sc)\n+{\n+    staticForeachPrepare(sfe, sc);\n+    if (staticForeachReady(sfe))\n+    {\n+        Statement *s = makeTupleForeachStatic(sc, sfe->aggrfe, sfe->needExpansion);\n+        Statements *result = s->flatten(sc);\n+        if (result)\n+        {\n+            return result;\n+        }\n+        result = new Statements();\n+        result->push(s);\n+        return result;\n+    }\n+    else\n+    {\n+        Statements *result = new Statements();\n+        result->push(new ErrorStatement());\n+        return result;\n+    }\n+}\n+\n /******************************** PragmaStatement ***************************/\n \n PragmaStatement::PragmaStatement(Loc loc, Identifier *ident, Expressions *args, Statement *body)"}, {"sha": "8f69383bb3a657a318c9033131b9b46b7fb2442c", "filename": "gcc/d/dmd/statement.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fstatement.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fstatement.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.h?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -232,15 +232,13 @@ class ScopeStatement : public Statement\n \n class ForwardingStatement : public Statement\n {\n+public:\n     ForwardingScopeDsymbol *sym;\n     Statement *statement;\n \n+    ForwardingStatement(Loc loc, ForwardingScopeDsymbol *sym, Statement *s);\n+    ForwardingStatement(Loc loc, Statement *s);\n     Statement *syntaxCopy();\n-    Statement *getRelatedLabeled();\n-    bool hasBreak();\n-    bool hasContinue();\n-    Statement *scopeCode(Scope *sc, Statement **sentry, Statement **sexception, Statement **sfinally);\n-    Statement *last();\n     Statements *flatten(Scope *sc);\n     ForwardingStatement *isForwardingStatement() { return this; }\n     void accept(Visitor *v) { v->visit(this); }\n@@ -384,6 +382,7 @@ class StaticForeachStatement : public Statement\n public:\n     StaticForeach *sfe;\n \n+    StaticForeachStatement(Loc loc, StaticForeach *sfe);\n     Statement *syntaxCopy();\n     Statements *flatten(Scope *sc);\n "}, {"sha": "26e5950518a187bd351650660a7be682c2f206a2", "filename": "gcc/d/dmd/statementsem.c", "status": "modified", "additions": 413, "deletions": 168, "changes": 581, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fstatementsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fstatementsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -13,6 +13,7 @@\n \n #include \"errors.h\"\n #include \"statement.h\"\n+#include \"attrib.h\"\n #include \"expression.h\"\n #include \"cond.h\"\n #include \"init.h\"\n@@ -303,11 +304,10 @@ class StatementSemanticVisitor : public Visitor\n \n     void visit(ScopeStatement *ss)\n     {\n-        ScopeDsymbol *sym;\n         //printf(\"ScopeStatement::semantic(sc = %p)\\n\", sc);\n         if (ss->statement)\n         {\n-            sym = new ScopeDsymbol();\n+            ScopeDsymbol *sym = new ScopeDsymbol();\n             sym->parent = sc->scopesym;\n             sym->endlinnum = ss->endloc.linnum;\n             sc = sc->push(sym);\n@@ -348,6 +348,22 @@ class StatementSemanticVisitor : public Visitor\n         result = ss;\n     }\n \n+    void visit(ForwardingStatement *ss)\n+    {\n+        assert(ss->sym);\n+        for (Scope *csc = sc; !ss->sym->forward; csc = csc->enclosing)\n+        {\n+            assert(csc);\n+            ss->sym->forward = csc->scopesym;\n+        }\n+        sc = sc->push(ss->sym);\n+        sc->sbreak = ss;\n+        sc->scontinue = ss;\n+        ss->statement = semantic(ss->statement, sc);\n+        sc = sc->pop();\n+        result = ss->statement;\n+    }\n+\n     void visit(WhileStatement *ws)\n     {\n         /* Rewrite as a for(;condition;) loop\n@@ -478,6 +494,347 @@ class StatementSemanticVisitor : public Visitor\n         result = fs;\n     }\n \n+    /***********************\n+     * Declares a unrolled `foreach` loop variable or a `static foreach` variable.\n+     *\n+     * Params:\n+     *     storageClass = The storage class of the variable.\n+     *     type = The declared type of the variable.\n+     *     ident = The name of the variable.\n+     *     e = The initializer of the variable (i.e. the current element of the looped over aggregate).\n+     *     t = The type of the initializer.\n+     * Returns:\n+     *     `true` iff the declaration was successful.\n+     */\n+    bool declareVariable(ForeachStatement *fs, Type *paramtype, TupleExp *te,\n+        bool needExpansion, bool isStatic, Statements *statements, Dsymbols *declarations,\n+        StorageClass storageClass, Type *type, Identifier *ident, Expression *e, Type *t)\n+    {\n+        Loc loc = fs->loc;\n+        if (storageClass & (STCout | STClazy) ||\n+            (storageClass & STCref && !te))\n+        {\n+            fs->error(\"no storage class for value %s\", ident->toChars());\n+            return false;\n+        }\n+        Declaration *var;\n+        if (e)\n+        {\n+            Type *tb = e->type->toBasetype();\n+            Dsymbol *ds = NULL;\n+            if (!(storageClass & STCmanifest))\n+            {\n+                if ((isStatic || tb->ty == Tfunction || tb->ty == Tsarray || storageClass & STCalias) && e->op == TOKvar)\n+                    ds = ((VarExp *)e)->var;\n+                else if (e->op == TOKtemplate)\n+                    ds = ((TemplateExp *)e)->td;\n+                else if (e->op == TOKscope)\n+                    ds = ((ScopeExp *)e)->sds;\n+                else if (e->op == TOKfunction)\n+                {\n+                    FuncExp *fe = (FuncExp *)e;\n+                    ds = fe->td ? (Dsymbol *)fe->td : fe->fd;\n+                }\n+            }\n+            else if (storageClass & STCalias)\n+            {\n+                fs->error(\"foreach loop variable cannot be both enum and alias\");\n+                return false;\n+            }\n+\n+            if (ds)\n+            {\n+                var = new AliasDeclaration(loc, ident, ds);\n+                if (storageClass & STCref)\n+                {\n+                    fs->error(\"symbol %s cannot be ref\", ds->toChars());\n+                    return false;\n+                }\n+                if (paramtype)\n+                {\n+                    fs->error(\"cannot specify element type for symbol %s\", ds->toChars());\n+                    return false;\n+                }\n+            }\n+            else if (e->op == TOKtype)\n+            {\n+                var = new AliasDeclaration(loc, ident, e->type);\n+                if (paramtype)\n+                {\n+                    fs->error(\"cannot specify element type for type %s\", e->type->toChars());\n+                    return false;\n+                }\n+            }\n+            else\n+            {\n+                e = resolveProperties(sc, e);\n+                type = e->type;\n+                if (paramtype)\n+                    type = paramtype;\n+                Initializer *ie = new ExpInitializer(Loc(), e);\n+                VarDeclaration *v = new VarDeclaration(loc, type, ident, ie);\n+                if (storageClass & STCref)\n+                    v->storage_class |= STCref | STCforeach;\n+                if (isStatic || storageClass & STCmanifest || e->isConst() ||\n+                    e->op == TOKstring ||\n+                    e->op == TOKstructliteral ||\n+                    e->op == TOKarrayliteral)\n+                {\n+                    if (v->storage_class & STCref)\n+                    {\n+                        if (!isStatic || !needExpansion)\n+                        {\n+                            fs->error(\"constant value %s cannot be ref\", ie->toChars());\n+                        }\n+                        else \n+                        {\n+                            fs->error(\"constant value %s cannot be ref\", ident->toChars());\n+                        }\n+                        return false;\n+                    }\n+                    else\n+                        v->storage_class |= STCmanifest;\n+                }\n+                var = v;\n+            }\n+        }\n+        else\n+        {\n+            var = new AliasDeclaration(loc, ident, t);\n+            if (paramtype)\n+            {\n+                fs->error(\"cannot specify element type for symbol %s\", fs->toChars());\n+                return false;\n+            }\n+        }\n+        if (isStatic)\n+            var->storage_class |= STClocal;\n+        if (statements)\n+            statements->push(new ExpStatement(loc, var));\n+        else if (declarations)\n+            declarations->push(var);\n+        else\n+            assert(0);\n+        return true;\n+    }\n+\n+    bool makeTupleForeachBody(ForeachStatement *fs, size_t k,\n+        Type *paramtype, TupleExp *te, TypeTuple *tuple,\n+        bool needExpansion, bool isStatic, bool isDecl,\n+        Statements *statements, Dsymbols *declarations, Dsymbols *dbody)\n+    {\n+        Loc loc = fs->loc;\n+        Expression *e = NULL;\n+        Type *t = NULL;\n+        if (te)\n+            e = (*te->exps)[k];\n+        else\n+            t = Parameter::getNth(tuple->arguments, k)->type;\n+        Parameter *p = (*fs->parameters)[0];\n+        Statements *stmts = (isDecl) ? NULL : new Statements();\n+        Dsymbols *decls = (isDecl) ? new Dsymbols() : NULL;\n+\n+        size_t dim = fs->parameters->dim;\n+        if (!needExpansion && dim == 2)\n+        {\n+            // Declare key\n+            if (p->storageClass & (STCout | STCref | STClazy))\n+            {\n+                fs->error(\"no storage class for key %s\", p->ident->toChars());\n+                return false;\n+            }\n+            if (isStatic)\n+            {\n+                if (!p->type)\n+                {\n+                    p->type = Type::tsize_t;\n+                }\n+            }\n+            p->type = p->type->semantic(loc, sc);\n+            TY keyty = p->type->ty;\n+            if (keyty != Tint32 && keyty != Tuns32)\n+            {\n+                if (global.params.isLP64)\n+                {\n+                    if (keyty != Tint64 && keyty != Tuns64)\n+                    {\n+                        fs->error(\"foreach: key type must be int or uint, long or ulong, not %s\", p->type->toChars());\n+                        return false;\n+                    }\n+                }\n+                else\n+                {\n+                    fs->error(\"foreach: key type must be int or uint, not %s\", p->type->toChars());\n+                    return false;\n+                }\n+            }\n+            Initializer *ie = new ExpInitializer(Loc(), new IntegerExp(k));\n+            VarDeclaration *var = new VarDeclaration(loc, p->type, p->ident, ie);\n+            var->storage_class |= STCmanifest;\n+            if (isStatic)\n+                var->storage_class |= STClocal;\n+            if (!isDecl)\n+                stmts->push(new ExpStatement(loc, var));\n+            else\n+                decls->push(var);\n+            p = (*fs->parameters)[1];  // value\n+        }\n+\n+        if (!isStatic || !needExpansion)\n+        {\n+            // Declare value\n+            if (!declareVariable(fs, paramtype, te, needExpansion, isStatic, stmts, decls,\n+                                 p->storageClass, p->type, p->ident, e, t))\n+            {\n+                return false;\n+            }\n+        }\n+        else\n+        {\n+            // expand tuples into multiple `static foreach` variables.\n+            assert(e && !t);\n+            Identifier *ident = Identifier::generateId(\"__value\");\n+            declareVariable(fs, paramtype, te, needExpansion, isStatic, stmts, decls,\n+                            0, e->type, ident, e, NULL);\n+            Identifier *field = Identifier::idPool(\"tuple\");\n+            Expression *access = new DotIdExp(loc, e, field);\n+            access = semantic(access, sc);\n+            if (!tuple)\n+                return false;\n+            //printf(\"%s\\n\", tuple->toChars());\n+            for (size_t l = 0; l < dim; l++)\n+            {\n+                Parameter *cp = (*fs->parameters)[l];\n+                Expression *init_ = new IndexExp(loc, access, new IntegerExp(loc, l, Type::tsize_t));\n+                init_ = semantic(init_, sc);\n+                assert(init_->type);\n+                declareVariable(fs, paramtype, te, needExpansion, isStatic, stmts, decls,\n+                                p->storageClass, init_->type, cp->ident, init_, NULL);\n+            }\n+        }\n+        Statement *fwdstmt = NULL;\n+        Dsymbol *fwddecl = NULL;\n+        if (!isDecl)\n+        {\n+            if (fs->_body)\n+                stmts->push(fs->_body->syntaxCopy());\n+            fwdstmt = new CompoundStatement(loc, stmts);\n+        }\n+        else\n+        {\n+            decls->append(Dsymbol::arraySyntaxCopy(dbody));\n+        }\n+        if (!isStatic)\n+        {\n+            fwdstmt = new ScopeStatement(loc, fwdstmt, fs->endloc);\n+        }\n+        else if (!isDecl)\n+        {\n+            fwdstmt = new ForwardingStatement(loc, fwdstmt);\n+        }\n+        else\n+        {\n+            fwddecl = new ForwardingAttribDeclaration(decls);\n+        }\n+\n+        if (statements)\n+            statements->push(fwdstmt);\n+        else if (declarations)\n+            declarations->push(fwddecl);\n+        else\n+            assert(0);\n+        return true;\n+    }\n+\n+    /*******************\n+     * Type check and unroll `foreach` over an expression tuple as well\n+     * as `static foreach` statements and `static foreach`\n+     * declarations. For `static foreach` statements and `static\n+     * foreach` declarations, the visitor interface is used (and the\n+     * result is written into the `result` field.) For `static\n+     * foreach` declarations, the resulting Dsymbols* are returned\n+     * directly.\n+     *\n+     * The unrolled body is wrapped into a\n+     *  - UnrolledLoopStatement, for `foreach` over an expression tuple.\n+     *  - ForwardingStatement, for `static foreach` statements.\n+     *  - ForwardingAttribDeclaration, for `static foreach` declarations.\n+     *\n+     * `static foreach` variables are declared as `STClocal`, such\n+     * that they are inserted into the local symbol tables of the\n+     * forwarding constructs instead of forwarded. For `static\n+     * foreach` with multiple foreach loop variables whose aggregate\n+     * has been lowered into a sequence of tuples, this function\n+     * expands the tuples into multiple `STClocal` `static foreach`\n+     * variables.\n+     */\n+    bool makeTupleForeach(ForeachStatement *fs, bool needExpansion, bool isStatic, bool isDecl,\n+                          Statements *statements, Dsymbols *declarations, Dsymbols *dbody)\n+    {\n+        Loc loc = fs->loc;\n+        size_t dim = fs->parameters->dim;\n+        if (!needExpansion && (dim < 1 || dim > 2))\n+        {\n+            fs->error(\"only one (value) or two (key,value) arguments for tuple foreach\");\n+            return false;\n+        }\n+\n+        Type *paramtype = (*fs->parameters)[dim-1]->type;\n+        if (paramtype)\n+        {\n+            paramtype = paramtype->semantic(loc, sc);\n+            if (paramtype->ty == Terror)\n+                return false;\n+        }\n+\n+        Type *tab = fs->aggr->type->toBasetype();\n+        TypeTuple *tuple = (TypeTuple *)tab;\n+        //printf(\"aggr: op = %d, %s\\n\", fs->aggr->op, fs->aggr->toChars());\n+        size_t n;\n+        TupleExp *te = NULL;\n+        if (fs->aggr->op == TOKtuple)       // expression tuple\n+        {\n+            te = (TupleExp *)fs->aggr;\n+            n = te->exps->dim;\n+        }\n+        else if (fs->aggr->op == TOKtype)   // type tuple\n+        {\n+            n = Parameter::dim(tuple->arguments);\n+        }\n+        else\n+            assert(0);\n+        for (size_t j = 0; j < n; j++)\n+        {\n+            size_t k = (fs->op == TOKforeach) ? j : n - 1 - j;\n+            if (!makeTupleForeachBody(fs, k, paramtype, te, tuple,\n+                                      needExpansion, isStatic, isDecl,\n+                                      statements, declarations, dbody))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    Dsymbols *makeTupleForeachStaticDecl(ForeachStatement *fs, Dsymbols *dbody, bool needExpansion)\n+    {\n+        assert(sc);\n+        Dsymbols *declarations = new Dsymbols();\n+        if (!makeTupleForeach(fs, needExpansion, true, true, NULL, declarations, dbody))\n+            return NULL;\n+\n+        return declarations;\n+    }\n+\n+    void makeTupleForeachStatic(ForeachStatement *fs, bool needExpansion)\n+    {\n+        Loc loc = fs->loc;\n+        assert(sc);\n+        Statements *statements = new Statements();\n+        if (!makeTupleForeach(fs, needExpansion, true, false, statements, NULL, NULL))\n+            return setError();\n+\n+        result = new CompoundStatement(loc, statements);\n+    }\n+\n     void visit(ForeachStatement *fs)\n     {\n         //printf(\"ForeachStatement::semantic() %p\\n\", fs);\n@@ -575,177 +932,22 @@ class StatementSemanticVisitor : public Visitor\n \n         if (tab->ty == Ttuple)      // don't generate new scope for tuple loops\n         {\n-            if (dim < 1 || dim > 2)\n-            {\n-                fs->error(\"only one (value) or two (key,value) arguments for tuple foreach\");\n+            Statements *statements = new Statements();\n+            if (!makeTupleForeach(fs, false, false, false, statements, NULL, NULL))\n                 return setError();\n-            }\n \n-            Type *paramtype = (*fs->parameters)[dim-1]->type;\n-            if (paramtype)\n-            {\n-                paramtype = paramtype->semantic(loc, sc);\n-                if (paramtype->ty == Terror)\n-                    return setError();\n-            }\n-\n-            TypeTuple *tuple = (TypeTuple *)tab;\n-            Statements *statements = new Statements();\n-            //printf(\"aggr: op = %d, %s\\n\", fs->aggr->op, fs->aggr->toChars());\n-            size_t n;\n-            TupleExp *te = NULL;\n-            if (fs->aggr->op == TOKtuple)       // expression tuple\n-            {\n-                te = (TupleExp *)fs->aggr;\n-                n = te->exps->dim;\n-            }\n-            else if (fs->aggr->op == TOKtype)   // type tuple\n+            result = new UnrolledLoopStatement(loc, statements);\n+            if (LabelStatement *ls = checkLabeledLoop(sc, fs))\n+                ls->gotoTarget = result;\n+            if (fs->aggr->op == TOKtuple)\n             {\n-                n = Parameter::dim(tuple->arguments);\n+                TupleExp *te = (TupleExp *)fs->aggr;\n+                if (te->e0)\n+                    result = new CompoundStatement(loc, new ExpStatement(te->e0->loc, te->e0), result);\n             }\n-            else\n-                assert(0);\n-            for (size_t j = 0; j < n; j++)\n-            {\n-                size_t k = (fs->op == TOKforeach) ? j : n - 1 - j;\n-                Expression *e = NULL;\n-                Type *t = NULL;\n-                if (te)\n-                    e = (*te->exps)[k];\n-                else\n-                    t = Parameter::getNth(tuple->arguments, k)->type;\n-                Parameter *p = (*fs->parameters)[0];\n-                Statements *st = new Statements();\n-\n-                if (dim == 2)\n-                {\n-                    // Declare key\n-                    if (p->storageClass & (STCout | STCref | STClazy))\n-                    {\n-                        fs->error(\"no storage class for key %s\", p->ident->toChars());\n-                        return setError();\n-                    }\n-                    p->type = p->type->semantic(loc, sc);\n-                    TY keyty = p->type->ty;\n-                    if (keyty != Tint32 && keyty != Tuns32)\n-                    {\n-                        if (global.params.isLP64)\n-                        {\n-                            if (keyty != Tint64 && keyty != Tuns64)\n-                            {\n-                                fs->error(\"foreach: key type must be int or uint, long or ulong, not %s\", p->type->toChars());\n-                                return setError();\n-                            }\n-                        }\n-                        else\n-                        {\n-                            fs->error(\"foreach: key type must be int or uint, not %s\", p->type->toChars());\n-                            return setError();\n-                        }\n-                    }\n-                    Initializer *ie = new ExpInitializer(Loc(), new IntegerExp(k));\n-                    VarDeclaration *var = new VarDeclaration(loc, p->type, p->ident, ie);\n-                    var->storage_class |= STCmanifest;\n-                    st->push(new ExpStatement(loc, var));\n-                    p = (*fs->parameters)[1];  // value\n-                }\n-                // Declare value\n-                if (p->storageClass & (STCout | STClazy) ||\n-                    (p->storageClass & STCref && !te))\n-                {\n-                    fs->error(\"no storage class for value %s\", p->ident->toChars());\n-                    return setError();\n-                }\n-                Dsymbol *var;\n-                if (te)\n-                {\n-                    Type *tb = e->type->toBasetype();\n-                    Dsymbol *ds = NULL;\n-                    if ((tb->ty == Tfunction || tb->ty == Tsarray) && e->op == TOKvar)\n-                        ds = ((VarExp *)e)->var;\n-                    else if (e->op == TOKtemplate)\n-                        ds = ((TemplateExp *)e)->td;\n-                    else if (e->op == TOKscope)\n-                        ds = ((ScopeExp *)e)->sds;\n-                    else if (e->op == TOKfunction)\n-                    {\n-                        FuncExp *fe = (FuncExp *)e;\n-                        ds = fe->td ? (Dsymbol *)fe->td : fe->fd;\n-                    }\n-\n-                    if (ds)\n-                    {\n-                        var = new AliasDeclaration(loc, p->ident, ds);\n-                        if (p->storageClass & STCref)\n-                        {\n-                            fs->error(\"symbol %s cannot be ref\", s->toChars());\n-                            return setError();\n-                        }\n-                        if (paramtype)\n-                        {\n-                            fs->error(\"cannot specify element type for symbol %s\", ds->toChars());\n-                            return setError();\n-                        }\n-                    }\n-                    else if (e->op == TOKtype)\n-                    {\n-                        var = new AliasDeclaration(loc, p->ident, e->type);\n-                        if (paramtype)\n-                        {\n-                            fs->error(\"cannot specify element type for type %s\", e->type->toChars());\n-                            return setError();\n-                        }\n-                    }\n-                    else\n-                    {\n-                        p->type = e->type;\n-                        if (paramtype)\n-                            p->type = paramtype;\n-                        Initializer *ie = new ExpInitializer(Loc(), e);\n-                        VarDeclaration *v = new VarDeclaration(loc, p->type, p->ident, ie);\n-                        if (p->storageClass & STCref)\n-                            v->storage_class |= STCref | STCforeach;\n-                        if (e->isConst() || e->op == TOKstring ||\n-                            e->op == TOKstructliteral || e->op == TOKarrayliteral)\n-                        {\n-                            if (v->storage_class & STCref)\n-                            {\n-                                fs->error(\"constant value %s cannot be ref\", ie->toChars());\n-                                return setError();\n-                            }\n-                            else\n-                                v->storage_class |= STCmanifest;\n-                        }\n-                        var = v;\n-                    }\n-                }\n-                else\n-                {\n-                    var = new AliasDeclaration(loc, p->ident, t);\n-                    if (paramtype)\n-                    {\n-                        fs->error(\"cannot specify element type for symbol %s\", s->toChars());\n-                        return setError();\n-                    }\n-                }\n-                st->push(new ExpStatement(loc, var));\n-\n-                if (fs->_body)\n-                    st->push(fs->_body->syntaxCopy());\n-                s = new CompoundStatement(loc, st);\n-                s = new ScopeStatement(loc, s, fs->endloc);\n-                statements->push(s);\n-            }\n-\n-            s = new UnrolledLoopStatement(loc, statements);\n-            if (LabelStatement *ls = checkLabeledLoop(sc, fs))\n-                ls->gotoTarget = s;\n-            if (te && te->e0)\n-                s = new CompoundStatement(loc, new ExpStatement(te->e0->loc, te->e0), s);\n             if (vinit)\n-                s = new CompoundStatement(loc, new ExpStatement(loc, vinit), s);\n-            s = semantic(s, sc);\n-            result = s;\n+                result = new CompoundStatement(loc, new ExpStatement(loc, vinit), result);\n+            result = semantic(result, sc);\n             return;\n         }\n \n@@ -756,6 +958,19 @@ class StatementSemanticVisitor : public Visitor\n \n         sc2->noctor++;\n \n+        for (size_t i = 0; i < dim; i++)\n+        {\n+            Parameter *p = (*fs->parameters)[i];\n+            if (p->storageClass & STCmanifest)\n+            {\n+                fs->error(\"cannot declare enum loop variables for non-unrolled foreach\");\n+            }\n+            if (p->storageClass & STCalias)\n+            {\n+                fs->error(\"cannot declare alias loop variables for non-unrolled foreach\");\n+            }\n+        }\n+\n         switch (tab->ty)\n         {\n             case Tarray:\n@@ -1949,6 +2164,11 @@ class StatementSemanticVisitor : public Visitor\n \n         if (ps->_body)\n         {\n+            if (ps->ident == Id::msg || ps->ident == Id::startaddress)\n+            {\n+                ps->error(\"`pragma(%s)` is missing a terminating `;`\", ps->ident->toChars());\n+                return setError();\n+            }\n             ps->_body = semantic(ps->_body, sc);\n         }\n         result = ps->_body;\n@@ -2862,6 +3082,10 @@ class StatementSemanticVisitor : public Visitor\n                 bs->error(\"break is not inside a loop or switch\");\n             return setError();\n         }\n+        else if (sc->sbreak->isForwardingStatement())\n+        {\n+            bs->error(\"must use labeled `break` within `static foreach`\");\n+        }\n         result = bs;\n     }\n \n@@ -2944,6 +3168,10 @@ class StatementSemanticVisitor : public Visitor\n                 cs->error(\"continue is not inside a loop\");\n             return setError();\n         }\n+        else if (sc->scontinue->isForwardingStatement())\n+        {\n+            cs->error(\"must use labeled `continue` within `static foreach`\");\n+        }\n         result = cs;\n     }\n \n@@ -3663,3 +3891,20 @@ Statement *semanticScope(Statement *s, Scope *sc, Statement *sbreak, Statement *\n     scd->pop();\n     return s;\n }\n+\n+/*******************\n+ * See StatementSemanticVisitor.makeTupleForeach.  This is a simple\n+ * wrapper that returns the generated statements/declarations.\n+ */\n+Statement *makeTupleForeachStatic(Scope *sc, ForeachStatement *fs, bool needExpansion)\n+{\n+    StatementSemanticVisitor v = StatementSemanticVisitor(sc);\n+    v.makeTupleForeachStatic(fs, needExpansion);\n+    return v.result;\n+}\n+\n+Dsymbols *makeTupleForeachStaticDecl(Scope *sc, ForeachStatement *fs, Dsymbols *dbody, bool needExpansion)\n+{\n+    StatementSemanticVisitor v = StatementSemanticVisitor(sc);\n+    return v.makeTupleForeachStaticDecl(fs, dbody, needExpansion);\n+}"}, {"sha": "04726c36473e8d2722ccff30614b464ed78f6674", "filename": "gcc/d/dmd/traits.c", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Ftraits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Ftraits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.c?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -1182,16 +1182,27 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n             {\n                 if (!sm)\n                     return 1;\n+\n+                // skip local symbols, such as static foreach loop variables\n+                if (Declaration *decl = sm->isDeclaration())\n+                {\n+                    if (decl->storage_class & STClocal)\n+                    {\n+                        return 0;\n+                    }\n+                }\n+\n                 //printf(\"\\t[%i] %s %s\\n\", i, sm->kind(), sm->toChars());\n                 if (sm->ident)\n                 {\n-                    const char *idx = sm->ident->toChars();\n-                    if (idx[0] == '_' && idx[1] == '_' &&\n-                        sm->ident != Id::ctor &&\n-                        sm->ident != Id::dtor &&\n-                        sm->ident != Id::__xdtor &&\n-                        sm->ident != Id::postblit &&\n-                        sm->ident != Id::__xpostblit)\n+                    // https://issues.dlang.org/show_bug.cgi?id=10096\n+                    // https://issues.dlang.org/show_bug.cgi?id=10100\n+                    // Skip over internal members in __traits(allMembers)\n+                    if ((sm->isCtorDeclaration() && sm->ident != Id::ctor) ||\n+                        (sm->isDtorDeclaration() && sm->ident != Id::dtor) ||\n+                        (sm->isPostBlitDeclaration() && sm->ident != Id::postblit) ||\n+                        sm->isInvariantDeclaration() ||\n+                        sm->isUnitTestDeclaration())\n                     {\n                         return 0;\n                     }\n@@ -1352,6 +1363,13 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n \n         RootObject *o1 = (*e->args)[0];\n         RootObject *o2 = (*e->args)[1];\n+\n+        // issue 12001, allow isSame, <BasicType>, <BasicType>\n+        Type *t1 = isType(o1);\n+        Type *t2 = isType(o2);\n+        if (t1 && t2 && t1->equals(t2))\n+            return True(e);\n+\n         Dsymbol *s1 = getDsymbol(o1);\n         Dsymbol *s2 = getDsymbol(o2);\n         //printf(\"isSame: %s, %s\\n\", o1->toChars(), o2->toChars());\n@@ -1411,7 +1429,7 @@ Expression *semanticTraits(TraitsExp *e, Scope *sc)\n         TupleExp *te= new TupleExp(e->loc, exps);\n         return semantic(te, sc);\n     }\n-    else if(e->ident == Id::getVirtualIndex)\n+    else if (e->ident == Id::getVirtualIndex)\n     {\n         if (dim != 1)\n             return dimError(e, 1, dim);"}, {"sha": "df549da2df73d079f43f248982ac03ced15bc4fd", "filename": "gcc/d/dmd/visitor.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fvisitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Fd%2Fdmd%2Fvisitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fvisitor.h?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -81,6 +81,7 @@ class TypeClass;\n class TypeTuple;\n class TypeSlice;\n class TypeNull;\n+class TypeTraits;\n \n class Dsymbol;\n \n@@ -107,6 +108,7 @@ class StaticIfDeclaration;\n class CompileDeclaration;\n class StaticForeachDeclaration;\n class UserAttributeDeclaration;\n+class ForwardingAttribDeclaration;\n \n class ScopeDsymbol;\n class TemplateDeclaration;\n@@ -373,6 +375,7 @@ class Visitor\n     virtual void visit(TypeTuple *t) { visit((Type *)t); }\n     virtual void visit(TypeSlice *t) { visit((TypeNext *)t); }\n     virtual void visit(TypeNull *t) { visit((Type *)t); }\n+    virtual void visit(TypeTraits *t) { visit((Type *)t); }\n \n     virtual void visit(Dsymbol *) { assert(0); }\n \n@@ -399,6 +402,7 @@ class Visitor\n     virtual void visit(StaticForeachDeclaration *s) { visit((AttribDeclaration *)s); }\n     virtual void visit(CompileDeclaration *s) { visit((AttribDeclaration *)s); }\n     virtual void visit(UserAttributeDeclaration *s) { visit((AttribDeclaration *)s); }\n+    virtual void visit(ForwardingAttribDeclaration *s) { visit((AttribDeclaration *)s); }\n \n     virtual void visit(ScopeDsymbol *s) { visit((Dsymbol *)s); }\n     virtual void visit(TemplateDeclaration *s) { visit((ScopeDsymbol *)s); }"}, {"sha": "f67c8957514a63a4a5a1bdc59c72dd7bc2d4cd66", "filename": "gcc/testsuite/gdc.test/compilable/b12001.d", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb12001.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb12001.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb12001.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -0,0 +1,9 @@\n+void main()\n+{\n+    static assert(__traits(isSame, int, int));\n+    static assert(__traits(isSame, int[][], int[][]));\n+    static assert(__traits(isSame, bool*, bool*));\n+\n+    static assert(!__traits(isSame, bool*, bool[]));\n+    static assert(!__traits(isSame, float, double));\n+}"}, {"sha": "e2b08605893c6681267bb981933023716612a6ba", "filename": "gcc/testsuite/gdc.test/compilable/json.d", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fjson.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fjson.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fjson.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -111,3 +111,24 @@ enum Numbers\n }\n \n template IncludeConstraint(T) if (T == string) {}\n+\n+static foreach(enum i; 0..3)\n+{\n+    mixin(\"int a\" ~ i.stringof ~ \" = 1;\");\n+}\n+\n+alias Seq(T...) = T;\n+\n+static foreach(int i, alias a; Seq!(a0, a1, a2))\n+{\n+       mixin(\"alias b\" ~ i.stringof ~ \" = a;\");\n+}\n+\n+mixin template test18211(int n)\n+{\n+    static foreach (i; 0 .. n>10 ? 10 : n)\n+    {\n+        mixin(\"enum x\" ~ cast(char)('0' + i));\n+    }\n+    static if (true) {}\n+}"}, {"sha": "48d06b418d31d7f4457bc1e813e3b38f2d07dbe0", "filename": "gcc/testsuite/gdc.test/compilable/staticforeach.d", "status": "added", "additions": 842, "deletions": 0, "changes": 842, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fstaticforeach.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fstaticforeach.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fstaticforeach.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -0,0 +1,842 @@\n+// REQUIRED_ARGS: -o-\n+// PERMUTE_ARGS:\n+// EXTRA_FILES: imports/imp12242a1.d imports/imp12242a2.d\n+/*\n+TEST_OUTPUT:\n+---\n+9\n+8\n+7\n+6\n+5\n+4\n+3\n+2\n+1\n+0\n+S(1, 2, 3, [0, 1, 2])\n+x0: 1\n+x1: 2\n+x2: 3\n+a: [0, 1, 2]\n+(int[], char[], bool[], Object[])\n+[0, 0]\n+x0: int\n+x1: double\n+x2: char\n+test(0)\u2192 0\n+test(1)\u2192 1\n+test(2)\u2192 2\n+test(3)\u2192 3\n+test(4)\u2192 4\n+test(5)\u2192 5\n+test(6)\u2192 6\n+test(7)\u2192 7\n+test(8)\u2192 8\n+test(9)\u2192 9\n+test(10)\u2192 -1\n+test(11)\u2192 -1\n+test(12)\u2192 -1\n+test(13)\u2192 -1\n+test(14)\u2192 -1\n+1\n+[1, 2, 3]\n+2\n+[1, 2, 3]\n+3\n+[1, 2, 3]\n+0 1\n+1 2\n+2 3\n+1\n+3\n+4\n+object\n+Tuple\n+tuple\n+main\n+front\n+popFront\n+empty\n+back\n+popBack\n+Iota\n+iota\n+map\n+to\n+text\n+all\n+any\n+join\n+S\n+s\n+Seq\n+Overloads\n+Parameters\n+forward\n+foo\n+A\n+B\n+C\n+D\n+E\n+Types\n+Visitor\n+testVisitor\n+staticMap\n+arrayOf\n+StaticForeachLoopVariable\n+StaticForeachScopeExit\n+StaticForeachReverseHiding\n+UnrolledForeachReverse\n+StaticForeachReverse\n+StaticForeachByAliasDefault\n+NestedStaticForeach\n+TestAliasOutsideFunctionScope\n+OpApplyMultipleStaticForeach\n+OpApplyMultipleStaticForeachLowered\n+RangeStaticForeach\n+OpApplySingleStaticForeach\n+TypeStaticForeach\n+AliasForeach\n+EnumForeach\n+TestUninterpretable\n+SeqForeachConstant\n+SeqForeachBreakContinue\n+TestStaticForeach\n+testtest\n+fun\n+testEmpty\n+bug17660\n+breakContinueBan\n+MixinTemplate\n+testToStatement\n+bug17688\n+T\n+foo2\n+T2\n+1 2 '3'\n+2 3 '4'\n+0 1\n+1 2\n+2 3\n+---\n+*/\n+\n+module staticforeach;\n+\n+struct Tuple(T...){\n+    T expand;\n+    alias expand this;\n+}\n+auto tuple(T...)(T t){ return Tuple!T(t); }\n+\n+/+struct TupleStaticForeach{ // should work, but is not the fault of the static foreach implementation.\n+    //pragma(msg, [tuple(1,\"2\",'3'),tuple(2,\"3\",'4')].map!((x)=>x));\n+    static foreach(a,b,c;[tuple(1,\"2\",'3'),tuple(2,\"3\",'4')].map!((x)=>x)){\n+        pragma(msg,a,\" \",b,\" \",c);\n+    }\n+}+/\n+\n+void main(){\n+    static foreach(a,b,c;[tuple(1,\"2\",'3'),tuple(2,\"3\",'4')].map!((x)=>x)){\n+        pragma(msg, a,\" \",b,\" \",c);\n+    }\n+    static struct S{\n+        // (aggregate scope, forward referencing possible)\n+        static assert(stripA(\"123\")==1);\n+        static assert(stripA([1],2)==2);\n+        static foreach(i;0..2){\n+            mixin(`import imports.imp12242a`~text(i+1)~`;`);\n+            static assert(stripA(\"123\")==1);\n+            static assert(stripA([1],2)==2);\n+        }\n+        static assert(stripA(\"123\")==1);\n+        static assert(stripA([1],2)==2);\n+    }\n+    static foreach(i;0..2){\n+        // (function scope, no forward referencing)\n+        mixin(`import imports.imp12242a`~text(i+1)~`;`);\n+        static assert(stripA(\"123\")==1);\n+        static if(i) static assert(stripA([1],2)==2);\n+    }\n+    static assert(stripA(\"123\")==1);\n+    static assert(stripA([1],2)==2);\n+}\n+\n+auto front(T)(T[] a){ return a[0]; }\n+auto popFront(T)(ref T[] a){ a=a[1..$]; }\n+auto empty(T)(T[] a){ return !a.length; }\n+auto back(T)(T[] a){ return a[$-1]; }\n+auto popBack(T)(ref T[] a){ a=a[0..$-1]; }\n+\n+struct Iota(T){\n+    T s,e;\n+    @property bool empty(){ return s>=e; }\n+    @property T front(){ return s; }\n+    @property T back(){ return cast(T)(e-1); }\n+    void popFront(){ s++; }\n+    void popBack(){ e--; }\n+}\n+auto iota(T)(T s, T e){ return Iota!T(s,e); }\n+\n+template map(alias a){\n+    struct Map(R){\n+        R r;\n+        @property front(){ return a(r.front); }\n+        @property back(){ return a(r.back); }\n+        @property bool empty(){ return r.empty; }\n+        void popFront(){ r.popFront(); }\n+        void popBack(){ r.popBack(); }\n+    }\n+    auto map(R)(R r){ return Map!R(r); }\n+}\n+\n+template to(T:string){\n+    string to(S)(S x)if(is(S:int)||is(S:size_t)||is(S:char)){\n+        static if(is(S==char)) return cast(string)[x];\n+        if(x<0) return \"-\"~to(-1 * x);\n+        if(x==0) return \"0\";\n+        return (x>=10?to(x/10):\"\")~cast(char)(x%10+'0');\n+    }\n+}\n+auto text(T)(T arg){ return to!string(arg); };\n+\n+template all(alias a){\n+    bool all(R)(R r){\n+        foreach(x;r) if(!a(x)) return false;\n+        return true;\n+    }\n+}\n+template any(alias a){\n+    bool any(R)(R r){\n+        foreach(x;r) if(a(x)) return true;\n+        return false;\n+    }\n+}\n+auto join(R)(R r,string sep=\"\"){\n+    string a;\n+    int first=0;\n+    foreach(x;r){\n+        if(first++) a~=sep;\n+        a~=x;\n+    }\n+    return a;\n+}\n+\n+static foreach_reverse(x;iota(0,10).map!(to!string)){\n+    pragma(msg, x);\n+}\n+\n+// create struct members iteratively\n+struct S{\n+    static foreach(i;a){\n+        mixin(\"int x\"~to!string(i)~\";\");\n+    }\n+    immutable int[] a = [0,1,2];\n+}\n+enum s=S(1,2,3);\n+pragma(msg, s);\n+\n+// loop over struct members\n+static foreach(member;__traits(allMembers,S)){\n+    pragma(msg, member,\": \",mixin(\"s.\"~member));\n+}\n+\n+// print prime numbers using overload sets as state variables.\n+/+\n+static assert(is(typeof(bad57)));\n+static assert(!is(typeof(bad53)));\n+\n+static foreach(x;iota(2,100)){\n+    static foreach(y;iota(2,x)){\n+        static if(!(x%y)){\n+            mixin(\"void bad\"~to!string(x)~\"();\");\n+        }\n+    }\n+    static if(!is(typeof(mixin(\"bad\"~to!string(x))))){\n+        static assert(iota(2,x).all!(y=>!!(x%y)));\n+        pragma(msg, x);\n+    }else{\n+        static assert(iota(2,x).any!(y=>!(x%y)));\n+    }\n+}\n++/\n+\n+\n+alias Seq(T...)=T;\n+\n+alias Overloads(alias a) = Seq!(__traits(getOverloads, __traits(parent, a), __traits(identifier, a)));\n+\n+template Parameters(alias f){\n+    static if(is(typeof(f) P == function)) alias Parameters=P;\n+}\n+\n+template forward(alias a){\n+    enum x=2;\n+    static foreach(f;Overloads!a){\n+        auto ref forward(Parameters!f args){\n+            return f(args);\n+        }\n+    }\n+    enum y=3;\n+}\n+\n+int foo(int x){ return x; }\n+string foo(string x){ return x; }\n+\n+static assert(forward!foo(2)==2 && forward!foo(\"hi\") == \"hi\");\n+\n+\n+// simple boilerplate-free visitor pattern\n+static foreach(char T;'A'..'F'){\n+    mixin(\"class \"~T~q{{\n+        void accept(Visitor v){\n+            return v.visit(this);\n+        }\n+    }});\n+}\n+alias Types = Seq!(mixin(\"Seq!(\"~iota('A','F').map!(to!string).join(\", \")~\")\"));\n+abstract class Visitor{\n+    static foreach(T;Types){\n+        abstract void visit(T);\n+    }\n+}\n+\n+string testVisitor(){\n+    string r;\n+    void writeln(T...)(T args){\n+        static foreach(x;args) r~=x;\n+        r~='\\n';\n+    }\n+    class Visitor: .Visitor{\n+        static foreach(T;Types){\n+            override void visit(T){\n+                writeln(\"visited: \",T.stringof);\n+            }\n+        }\n+    }\n+    void main(){\n+        auto v=new Visitor;\n+        static foreach(T;Types){\n+            v.visit(new T);\n+        }\n+    }\n+    main();\n+    return r;\n+}\n+static assert(testVisitor()==\"visited: A\n+visited: B\n+visited: C\n+visited: D\n+visited: E\n+\");\n+\n+// iterative computation over AliasSeq:\n+template staticMap(alias F,T...){\n+    alias state0=Seq!();\n+    static foreach(i,A;T){\n+        mixin(\"alias state\"~to!string(i+1)~\" = Seq!(state\"~to!string(i)~\",F!A);\");\n+    }\n+    alias staticMap = Seq!(mixin(\"state\"~to!string(T.length)));\n+}\n+\n+alias arrayOf(T)=T[];\n+static assert(is(staticMap!(arrayOf,int,char,bool,Object)==Seq!(int[], char[], bool[], Object[])));\n+pragma(msg, staticMap!(arrayOf,int,char,bool,Object));\n+\n+\n+struct StaticForeachLoopVariable{\n+    int x;\n+    static foreach(i;0..1){\n+        mixin(\"enum x\"~text(i)~\" = i;\");\n+    }\n+    int y;\n+    static assert(__traits(allMembers, StaticForeachLoopVariable).length==3);\n+    static assert(!is(typeof(StaticForeachLoopVariable.i)));\n+    static assert(!is(typeof(__traits(getMember, StaticForeachLoopVariable, \"i\"))));\n+}\n+\n+struct StaticForeachScopeExit{\n+static:\n+    int[] test(){\n+        int[] r;\n+        scope(exit) r ~= 1234;\n+        {\n+            static foreach(i;0..5){\n+                scope(exit) r ~= i;\n+            }\n+            r ~= 5;\n+        }\n+        return r;\n+    }\n+    static assert(test()==[5,4,3,2,1,0]);\n+}\n+\n+struct StaticForeachReverseHiding{\n+    static foreach(i;[0]){\n+        enum i = 1; // TODO: disallow?\n+        static assert(i==0);\n+    }\n+}\n+\n+struct UnrolledForeachReverse{\n+static:\n+    alias Seq(T...)=T;\n+    int[] test(){\n+        int[] r;\n+        foreach_reverse(i;Seq!(0,1,2,3)){\n+            r~=i;\n+        }\n+        return r;\n+    }\n+    static assert(test()==[3,2,1,0]);\n+}\n+\n+struct StaticForeachReverse{\n+static:\n+    alias Seq(T...)=T;\n+    int[] test(){\n+        int[] r;\n+        static foreach_reverse(i;0..4){\n+            r~=i;\n+        }\n+        return r;\n+    }\n+    static assert(test()==[3,2,1,0]);\n+\n+    int[] test2(){\n+        int[] r;\n+        static foreach_reverse(i;[0,1,2,3]){\n+            r~=i;\n+        }\n+        return r;\n+    }\n+    static assert(test2()==[3,2,1,0]);\n+\n+    int[] test3(){\n+        static struct S{\n+            int opApplyReverse(scope int delegate(int) dg){\n+                foreach_reverse(i;0..4) if(auto r=dg(i)) return r;\n+                return 0;\n+            }\n+        }\n+        int[] r;\n+        static foreach_reverse(i;S()){\n+            r~=i;\n+        }\n+        return r;\n+    }\n+    static assert(test3()==[3,2,1,0]);\n+\n+    int[] test4(){\n+        int[] r;\n+        static foreach_reverse(i;Seq!(0,1,2,3)){\n+            r~=i;\n+        }\n+        return r;\n+    }\n+    static assert(test()==[3,2,1,0]);\n+}\n+\n+struct StaticForeachByAliasDefault{\n+static:\n+    alias Seq(T...)=T;\n+\n+    int[] test(){\n+        int a,b,c;\n+        static foreach(i,x;Seq!(a,b,c)) x=i;\n+        return [a,b,c];\n+    }\n+    static assert(test()==[0,1,2]);\n+\n+    int[] test2(){\n+        int x=0;\n+        int foo(){ return ++x; }\n+        static foreach(y;Seq!foo)\n+            return [y,y,y];\n+    }\n+    static assert(test2()==[1,2,3]);\n+\n+    void test3(){\n+        int x=0;\n+        int foo(){ return ++x; }\n+        static assert(!is(typeof({\n+            static foreach(enum y;Seq!foo)\n+                return [y,y,y];\n+        })));\n+    }\n+}\n+\n+struct NestedStaticForeach{\n+    static:\n+    static foreach(i,name;[\"a\"]){\n+        static foreach(j,name2;[\"d\"]){\n+            mixin(\"enum int[] \"~name~name2~\"=[i, j];\");\n+        }\n+    }\n+    pragma(msg, ad);\n+}\n+\n+struct TestAliasOutsideFunctionScope{\n+static:\n+    alias Seq(T...)=T;\n+    int a;\n+    static foreach(alias x;Seq!(a)){\n+    }\n+}\n+\n+struct OpApplyMultipleStaticForeach{\n+static:\n+    struct OpApply{\n+        int opApply(scope int delegate(int,int) dg){\n+            foreach(i;0..10) if(auto r=dg(i,i*i)) return r;\n+            return 0;\n+        }\n+    }\n+    static foreach(a,b;OpApply()){\n+        mixin(`enum x`~cast(char)('0'+a)~\"=b;\");\n+    }\n+    static foreach(i;0..10){\n+        static assert(mixin(`x`~cast(char)('0'+i))==i*i);\n+    }\n+}\n+\n+\n+struct OpApplyMultipleStaticForeachLowered{\n+static:\n+    struct OpApply{\n+        int opApply(scope int delegate(int,int) dg){\n+            foreach(i;0..10) if(auto r=dg(i,i*i)) return r;\n+            return 0;\n+        }\n+    }\n+    static foreach(x;{\n+            static struct S(T...){ this(T k){ this.x=k; } T x; }\n+            static s(T...)(T a){ return S!T(a); }\n+            typeof({ foreach(a,b;OpApply()){ return s(a,b); } assert(0);}())[] r;\n+            foreach(a,b;OpApply()) r~=s(a,b);\n+            return r;\n+        }()){\n+        mixin(`enum x`~cast(char)('0'+x.x[0])~\"=x.x[1];\");\n+    }\n+    static foreach(i;0..10){\n+        static assert(mixin(`x`~cast(char)('0'+i))==i*i);\n+    }\n+}\n+\n+struct RangeStaticForeach{\n+    static:\n+    struct Range{\n+        int x=0;\n+        this(int x){ this.x=x; }\n+        @property int front(){ return x; }\n+        void popFront(){ x += 2; }\n+        @property bool empty(){ return x>=10; }\n+    }\n+    static foreach(i;Range()){\n+        mixin(`enum x`~cast(char)('0'+i)~\"=i;\");\n+    }\n+    static foreach(i;0..5){\n+        static assert(mixin(`x`~cast(char)('0'+2*i))==2*i);\n+    }\n+    static assert(!is(typeof({\n+        struct S{\n+            static foreach(i,k;Range()){}\n+        }\n+    })));\n+    static foreach(k;Range()){} // ok\n+}\n+\n+struct OpApplySingleStaticForeach{\n+    static:\n+    struct OpApply{\n+        int opApply(scope int delegate(int) dg){\n+            foreach(i;0..10) if(auto r=dg(i)) return r;\n+            return 0;\n+        }\n+    }\n+    static foreach(b;OpApply()){\n+        mixin(`enum x`~cast(char)('0'+b)~\"=b;\");\n+    }\n+    static foreach(i;0..10){\n+        static assert(mixin(`x`~cast(char)('0'+i))==i);\n+    }\n+}\n+\n+struct TypeStaticForeach{\n+static:\n+    alias Seq(T...)=T;\n+    static foreach(i,alias T;Seq!(int,double,char)){\n+        mixin(`T x`~cast(char)('0'+i)~\";\");\n+    }\n+    pragma(msg, \"x0: \",typeof(x0));\n+    pragma(msg, \"x1: \",typeof(x1));\n+    pragma(msg, \"x2: \",typeof(x2));\n+    static assert(is(typeof(x0)==int));\n+    static assert(is(typeof(x1)==double));\n+    static assert(is(typeof(x2)==char));\n+}\n+\n+struct AliasForeach{\n+static:\n+    alias Seq(T...)=T;\n+    int[] test(){\n+        int a,b,c;\n+        static foreach(x;Seq!(a,b,c,2)){\n+            static if(is(typeof({x=2;}))) x=2;\n+        }\n+        int x,y,z;\n+        static foreach(alias k;Seq!(x,y,z,2)){\n+            static if(is(typeof({k=2;}))) k=2;\n+        }\n+        int j,k,l;\n+        static assert(!is(typeof({\n+            static foreach(ref x;Seq!(j,k,l,2)){\n+                static if(is(typeof({x=2;}))) x=2;\n+            }\n+        })));\n+        return [x,y,z];\n+    }\n+    static assert(test()==[2,2,2]);\n+}\n+\n+struct EnumForeach{\n+static:\n+    alias Seq(T...)=T;\n+    int a=1;\n+    int fun(){ return 1; }\n+    int gun(){ return 2; }\n+    int hun(){ return 3;}\n+    auto test(){\n+        static foreach(i,enum x;Seq!(fun,gun,hun)){\n+            static assert(i+1==x);\n+        }\n+        foreach(i,enum x;Seq!(fun,gun,hun)){\n+            static assert(i+1==x);\n+        }\n+    }\n+}\n+\n+struct TestUninterpretable{\n+static:\n+    alias Seq(T...)=T;\n+    auto test(){\n+        int k;\n+        static assert(!is(typeof({\n+            static foreach(x;[k]){}\n+        })));\n+        static assert(!is(typeof({\n+            foreach(enum x;[1,2,3]){}\n+        })));\n+        static assert(!is(typeof({\n+            foreach(alias x;[1,2,3]){}\n+        })));\n+        foreach(enum x;Seq!(1,2,3)){} // ok\n+        foreach(alias x;Seq!(1,2,3)){} // ok\n+        static foreach(enum x;[1,2,3]){} // ok\n+        static foreach(alias x;[1,2,3]){} // ok\n+        static assert(!is(typeof({\n+            static foreach(enum alias x;[1,2,3]){}\n+        })));\n+        int x;\n+        static foreach(i;Seq!x){ } // ok\n+        static foreach(i,j;Seq!(1,2,x)){ } // ok\n+        static assert(!is(typeof({\n+            static foreach(ref x;[1,2,3]){}\n+        })));\n+    }\n+}\n+\n+struct SeqForeachConstant{\n+static:\n+    alias Seq(T...)=T;\n+    static assert(!is(typeof({\n+        foreach(x;Seq!1) x=2;\n+    })));\n+    int test2(){\n+        int r=0;\n+        foreach(x;Seq!(1,2,3)){\n+            enum k=x;\n+            r+=k;\n+        }\n+        return r;\n+    }\n+    static assert(test2()==6);\n+}\n+\n+struct SeqForeachBreakContinue{\n+static:\n+    alias Seq(T...)=T;\n+    int[] test(){\n+        int[] r;\n+        foreach(i;Seq!(0,1,2,3,4,5)){\n+            if(i==2) continue;\n+            if(i==4) break;\n+            r~=i;\n+        }\n+        return r;\n+    }\n+    static assert(test()==[0,1,3]);\n+}\n+\n+struct TestStaticForeach{\n+static:\n+    int test(int x){\n+        int r=0;\n+    label: switch(x){\n+            static foreach(i;0..10){\n+                case i: r=i; break label; // TODO: remove label when restriction is lifted\n+            }\n+            default: r=-1; break label;\n+        }\n+        return r;\n+    }\n+    static foreach(i;0..15){\n+        pragma(msg, \"test(\",i,\")\u2192 \",test(i));\n+        static assert(test(i)==(i<10?i:-1));\n+    }\n+\n+    enum x=[1,2,3];\n+\n+    static foreach(i;x){\n+        mixin(\"enum x\"~cast(char)('0'+i)~\"=\"~cast(char)('0'+i)~\";\");\n+    }\n+\n+    static foreach(i;x){\n+        pragma(msg, mixin(\"x\"~cast(char)('0'+i)));\n+        pragma(msg,x);\n+    }\n+\n+    int[] noBreakNoContinue(){\n+        int[] r;\n+        static foreach(i;0..1){\n+            // if(i==3) continue; // TODO: error?\n+            // if(i==7) break; // TODO: error?\n+            r~=i;\n+        }\n+        return r;\n+    }\n+\n+    mixin(\"enum k=3;\");\n+}\n+\n+static foreach(i,j;[1,2,3]){\n+    pragma(msg, int(i),\" \",j);\n+}\n+\n+void testtest(){\n+    static foreach(i,v;[1,2,3]){\n+        pragma(msg, int(i),\" \",v);\n+        static assert(i+1 == v);\n+    }\n+}\n+\n+\n+static foreach(i;Seq!(1,2,3,4,int)){\n+    static if(!is(i) && i!=2){\n+        pragma(msg, i);\n+    }\n+}\n+\n+int fun(int x){\n+    int r=0;\n+    label: switch(x){\n+        static foreach(i;Seq!(0,1,2,3,4,5,6)){\n+            static if (i < 5)\n+                case i: r=i; break label; // TODO: remove label when restriction is lifted\n+        }\n+        default: r=-1; break label;\n+    }\n+    return r;\n+}\n+\n+static foreach(i;0..10) static assert(fun(i)==(i<5?i:-1));\n+\n+static foreach(i;0..0) { }\n+void testEmpty(){\n+    static foreach(i;0..0) { }\n+}\n+\n+auto bug17660(){\n+    int x;\n+    static foreach (i; 0 .. 1) { return 3; }\n+    return x;\n+}\n+static assert(bug17660()==3);\n+\n+int breakContinueBan(){\n+    static assert(!is(typeof({\n+        for(;;){\n+            static foreach(i;0..1){\n+                break;\n+            }\n+        }\n+    })));\n+    static assert(!is(typeof({\n+        for(;;){\n+            static foreach(i;0..1){\n+                continue;\n+            }\n+        }\n+    })));\n+    Louter1: for(;;){\n+        static foreach(i;0..1){\n+            break Louter1;\n+        }\n+    }\n+    Louter2: foreach(i;0..10){\n+        static foreach(j;0..1){\n+            continue Louter2;\n+        }\n+        return 0;\n+    }\n+    static foreach(i;0..1){\n+        for(;;){ break; } // ok\n+    }\n+    return 1;\n+}\n+static assert(breakContinueBan()==1);\n+\n+mixin template MixinTemplate(){\n+    static foreach(i;0..2){\n+        mixin(`enum x`~cast(char)('0'+i)~\"=i;\");\n+    }\n+    static foreach(i;[0,1]){\n+        mixin(`enum y`~cast(char)('0'+i)~\"=i;\");\n+    }\n+}\n+void testToStatement(){\n+    mixin MixinTemplate;\n+    static assert(x0==0 && x1==1);\n+    static assert(y0==0 && y1==1);\n+}\n+\n+void bug17688(){\n+    final switch(1) static foreach(x;0..1){ int y=3; case 1: return; }\n+    static assert(!is(typeof(y)));\n+}\n+\n+struct T{ enum n = 1; }\n+T foo(T v)@nogc{\n+    static foreach(x;0..v.n){ }\n+    return T.init;\n+}\n+T foo2(T v)@nogc{\n+    static foreach(_;0..typeof(return).n){ }\n+    return T.init;\n+}\n+\n+//https://issues.dlang.org/show_bug.cgi?id=18698\n+\n+static foreach(m; __traits(allMembers, staticforeach))\n+{\n+    pragma(msg, m);\n+}\n+\n+//https://issues.dlang.org/show_bug.cgi?id=20072\n+struct T2{\n+    static foreach(i;0..1)\n+        struct S{}\n+}\n+static assert(is(__traits(parent,T2.S)==T2));"}, {"sha": "79863e11f47d613086aad5d4d9307559598f555e", "filename": "gcc/testsuite/gdc.test/compilable/test11169.d", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest11169.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest11169.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest11169.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -43,3 +43,18 @@ void main()\n     static assert(!__traits(compiles, { auto b = new B2(); }));\n     static assert(!__traits(compiles, { auto b = new B3(); }));\n }\n+\n+class B : A\n+{\n+    // __traits(isAbstractClass) is not usable in static if condition.\n+       static assert (!__traits(isAbstractClass, typeof(this)));\n+\n+    override void foo()\n+    {\n+    }\n+}\n+\n+void main2()\n+{\n+    B b = new B();\n+}"}, {"sha": "f1266a0aee158b824833de31f7a0d5c0ab77f0d1", "filename": "gcc/testsuite/gdc.test/compilable/test17819.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17819.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17819.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest17819.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -0,0 +1,17 @@\n+static if (__traits(allMembers, __traits(parent,{}))[0]==\"object\") {\n+\tenum test = 0;\n+}\n+\n+static foreach (m; __traits(allMembers, __traits(parent,{}))) {\n+\tmixin(\"enum new\"~m~\"=`\"~m~\"`;\");\n+}\n+\n+static assert([__traits(allMembers, __traits(parent,{}))] == [\"object\", \"test\", \"newobject\", \"newWorld\", \"newBuildStuff\", \"World\", \"BuildStuff\"]);\n+\n+struct World {\n+\tmixin BuildStuff;\n+}\n+\n+template BuildStuff() {\n+\tstatic foreach(elem; __traits(allMembers, typeof(this))) {}\n+}"}, {"sha": "44486f20cee8f11646d08d224eec27377f2ba7fb", "filename": "gcc/testsuite/gdc.test/compilable/test18871.d", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18871.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18871.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18871.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -0,0 +1,15 @@\n+// https://issues.dlang.org/show_bug.cgi?id=18871\n+// and https://issues.dlang.org/show_bug.cgi?id=18819\n+\n+struct Problem\n+{\n+    ~this() {}\n+}\n+struct S\n+{\n+    Problem[1] payload;\n+}\n+enum theTemplateB = {\n+    static foreach (e; S.init.tupleof) {}\n+    return true;\n+}();"}, {"sha": "405d9fc9d90426cd21f16e6c36b2190405e7a364", "filename": "gcc/testsuite/gdc.test/compilable/test7815.d", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest7815.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest7815.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest7815.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -2,8 +2,6 @@\n /*\n TEST_OUTPUT:\n ---\n-X: tuple(\"x\")\n-fail_compilation/fail7815.d(47): Error: no property 'flags' for type 'Move'\n ---\n */\n \n@@ -47,7 +45,7 @@ struct Move\n enum a7815 = Move.init.flags;\n \n /+\n-This is an invalid case.\n+This originally was an invalid case:\n When the Move struct member is analyzed:\n 1. mixin Helpers!() is instantiated.\n 2. In Helpers!(), static if and its condition is(Flags!Move)) evaluated.\n@@ -62,4 +60,6 @@ When the Move struct member is analyzed:\n    Flags!Move is instantiated to a new struct Flags.\n 7. Finally Move struct does not have flags member, then the `enum a7815`\n    definition will fail in its initializer.\n+\n+Now, static if will behave like a string mixin: it is invisible during its own expansion.\n +/", "previous_filename": "gcc/testsuite/gdc.test/fail_compilation/fail7815.d"}, {"sha": "fd3ade496857b6de52d7f227c019c54bb08ba916", "filename": "gcc/testsuite/gdc.test/compilable/test7886.d", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest7886.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest7886.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest7886.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -0,0 +1,5 @@\n+// https://issues.dlang.org/show_bug.cgi?id=7886\n+\n+struct A {\n+\tstatic assert (__traits(derivedMembers, A).length == 0);\n+}"}, {"sha": "38c25fbf7ae6b4afef9a36a6ab90a1fd30e5f69f", "filename": "gcc/testsuite/gdc.test/fail_compilation/e7804_1.d", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe7804_1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe7804_1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe7804_1.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -0,0 +1,11 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/e7804_1.d(10): Error: trait `farfelu` is either invalid or not supported as type\n+fail_compilation/e7804_1.d(11): Error: trait `farfelu` is either invalid or not supported in alias\n+---\n+*/\n+module e7804_1;\n+\n+__traits(farfelu, Aggr, \"member\") a;\n+alias foo = __traits(farfelu, Aggr, \"member\");"}, {"sha": "ef9b784b24a722a43f0ac96213fd5890c905cb16", "filename": "gcc/testsuite/gdc.test/fail_compilation/e7804_2.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe7804_2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe7804_2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fe7804_2.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -0,0 +1,19 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/e7804_2.d(17): Error: `__traits(getMember, Foo, \"func\")` does not give a valid type\n+---\n+*/\n+\n+module e7804_2;\n+\n+class Foo\n+{\n+     void func(){}\n+}\n+\n+void test()\n+{\n+    __traits(getMember, Foo, \"func\") var;\n+    auto a = cast(__traits(getMember, Foo, \"func\")) 0;\n+}"}, {"sha": "e6ab4a64886b7f2028fbb82cc3023cb243b056e7", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail11169.d", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3fa3476e9e922ca3e283df03ebd14be7220b6e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11169.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3fa3476e9e922ca3e283df03ebd14be7220b6e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11169.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11169.d?ref=db3fa3476e9e922ca3e283df03ebd14be7220b6e", "patch": "@@ -1,28 +0,0 @@\n-/*\n-TEST_OUTPUT:\n----\n-fail_compilation/fail11169.d(16): Error: error evaluating static if expression\n----\n-*/\n-\n-class A\n-{\n-    abstract void foo();\n-}\n-\n-class B : A\n-{\n-    // __traits(isAbstractClass) is not usable in static if condition.\n-    static if (__traits(isAbstractClass, typeof(this)))\n-    {\n-    }\n-\n-    override void foo()\n-    {\n-    }\n-}\n-\n-void main()\n-{\n-    B b = new B();\n-}"}, {"sha": "388c4603f04b22822ff6f2b417156ee96573a90a", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19182.d", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19182.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19182.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19182.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -0,0 +1,18 @@\n+// REQUIRED_ARGS: -c\n+/*\n+TEST_OUTPUT:\n+---\n+gigi\n+fail_compilation/fail19182.d(12): Error: `pragma(msg)` is missing a terminating `;`\n+---\n+*/\n+\n+void foo()\n+{\n+    pragma(msg, \"gigi\") // Here\n+    static foreach (e; [])\n+    {\n+        pragma(msg, \"lili\");\n+    }\n+\n+}"}, {"sha": "fc15be5784f44155292f647341e44f56cc8bce29", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19336.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19336.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19336.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19336.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -0,0 +1,17 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail19336.d(14): Error: template instance `Template!()` template `Template` is not defined\n+fail_compilation/fail19336.d(14): Error: circular reference to `fail19336.Foo.a`\n+fail_compilation/fail19336.d(17): Error: circular reference to `fail19336.b`\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=19336\n+\n+struct Foo\n+{\n+        Template!() a(a.x);\n+}\n+\n+int b(b.x);"}, {"sha": "305e05554897db3a00808b817440dfbb8e438de3", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19520.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19520.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19520.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19520.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -0,0 +1,21 @@\n+/* https://issues.dlang.org/show_bug.cgi?id=19520\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail19520.d(17): Error: incompatible types for `(Empty) is (Empty)`: cannot use `is` with types\n+fail_compilation/fail19520.d(17):        while evaluating: `static assert((Empty) is (Empty))`\n+fail_compilation/fail19520.d(18): Error: incompatible types for `(WithSym) is (WithSym)`: cannot use `is` with types\n+fail_compilation/fail19520.d(18):        while evaluating: `static assert((WithSym) is (WithSym))`\n+fail_compilation/fail19520.d(19): Error: incompatible types for `(Empty) is (Empty)`: cannot use `is` with types\n+fail_compilation/fail19520.d(20): Error: incompatible types for `(WithSym) is (WithSym)`: cannot use `is` with types\n+---\n+*/\n+struct Empty { }\n+struct WithSym { int i; }\n+\n+void test()\n+{\n+    static assert(Empty is Empty);\n+    static assert(WithSym is WithSym);\n+    assert(Empty is Empty);\n+    assert(WithSym is WithSym);\n+}"}, {"sha": "b6d5304210970c5f7e07d02c97997b81062d2c97", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail2195.d", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail2195.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail2195.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail2195.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -0,0 +1,18 @@\n+// https://issues.dlang.org/show_bug.cgi?id=2195\n+// REQUIRED_ARGS: -de\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail2195.d(16): Deprecation: variable `variable` is shadowing variable `fail2195.main.variable`. Rename the `foreach` variable.\n+---\n+*/\n+\n+void main()\n+{\n+    int[int] arr;\n+    int variable;\n+    foreach (i, j; arr)\n+    {\n+        int variable;  // shadowing is disallowed but not detected\n+    }\n+}"}, {"sha": "b939aad1495ea4ffe0650da7004274ec05a92f34", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail7886.d", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3fa3476e9e922ca3e283df03ebd14be7220b6e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail7886.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3fa3476e9e922ca3e283df03ebd14be7220b6e/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail7886.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail7886.d?ref=db3fa3476e9e922ca3e283df03ebd14be7220b6e", "patch": "@@ -1,5 +0,0 @@\n-// 7886\n-\n-struct A {\n-  static if (__traits(derivedMembers, A).length) {}\n-}"}, {"sha": "b58f520c0bf3354d0bb7ea656ad48d7b96dcdb08", "filename": "gcc/testsuite/gdc.test/fail_compilation/staticforeach1.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fstaticforeach1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fstaticforeach1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fstaticforeach1.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -0,0 +1,13 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/staticforeach1.d(10): Error: must use labeled `break` within `static foreach`\n+---\n+*/\n+void main(){\n+\tfor(;;){\n+\t\tstatic foreach(i;0..1){\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+}"}, {"sha": "25e283efb5cd7a78ac16da55e08f01d531a66e3e", "filename": "gcc/testsuite/gdc.test/fail_compilation/staticforeach2.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fstaticforeach2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fstaticforeach2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fstaticforeach2.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -0,0 +1,13 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/staticforeach2.d(10): Error: must use labeled `continue` within `static foreach`\n+---\n+*/\n+void main(){\n+\tfor(;;){\n+\t\tstatic foreach(i;0..1){\n+\t\t\tcontinue;\n+\t\t}\n+\t}\n+}"}, {"sha": "a93d20be86fe9905f348a4a83dc56ca25c246f80", "filename": "gcc/testsuite/gdc.test/fail_compilation/staticforeach3.d", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fstaticforeach3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fstaticforeach3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fstaticforeach3.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -0,0 +1,7 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/staticforeach3.d(7): Error: variable `staticforeach3.__anonymous.i` conflicts with variable `staticforeach3.__anonymous.i` at fail_compilation/staticforeach3.d(7)\n+---\n+*/\n+static foreach(i,i;[0]){}"}, {"sha": "470cfed7eba456f571f8810f0e8c457d47f46b29", "filename": "gcc/testsuite/gdc.test/fail_compilation/test17307.d", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17307.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17307.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17307.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -0,0 +1,12 @@\n+/* \n+TEST_OUTPUT:\n+---\n+fail_compilation/test17307.d(9): Error: anonymous struct can only be a part of an aggregate, not module `test17307`\n+---\n+ * https://issues.dlang.org/show_bug.cgi?id=17307\n+ */\n+\n+struct { enum bitsPerWord = size_t; }\n+\n+void main()\n+{ }"}, {"sha": "8f6f145e6bf48dd8e4507c23f318a7d0b10b0c5f", "filename": "gcc/testsuite/gdc.test/fail_compilation/traits_alone.d", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftraits_alone.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftraits_alone.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftraits_alone.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -0,0 +1,10 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/traits_alone.d(11): Error: found `End of File` when expecting `(`\n+fail_compilation/traits_alone.d(11): Error: `__traits(identifier, args...)` expected\n+fail_compilation/traits_alone.d(11): Error: no identifier for declarator `_error_`\n+---\n+*/\n+//used to segfault\n+__traits"}, {"sha": "e3749bee72a213a716910f88a19f560344f71f34", "filename": "gcc/testsuite/gdc.test/runnable/arrayop.d", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Farrayop.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Farrayop.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Farrayop.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -919,8 +919,7 @@ int main()\n     }\n     else\n     {\n-        pragma(msg, \"arrayop.d:test1 Test skipped because arrayop evaluation\"\n-                    \" order is ill-defined. See GDC issue #8\");\n+        //pragma(msg, \"Test skipped because arrayop evaluation order is ill-defined.\");\n     }\n     test3();\n     test4();"}, {"sha": "0708056bc6661ebe3b1977c81263c6e4789520b6", "filename": "gcc/testsuite/gdc.test/runnable/constfold.d", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fconstfold.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fconstfold.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fconstfold.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -252,15 +252,15 @@ void test2()\n     // This test only tests undefined, architecture-dependant behavior.\n     // E.g. the result of converting a float whose value doesn't fit into the integer\n     // leads to an undefined result.\n-    version(GNU)\n-       return;\n-\n-    float f = float.infinity;\n-    int i = cast(int) f;\n-    writeln(i);\n-    writeln(cast(int)float.max);\n-    assert(i == cast(int)float.max);\n-    assert(i == 0x80000000);\n+    version (DigitalMars)\n+    {\n+        float f = float.infinity;\n+        int i = cast(int) f;\n+        writeln(i);\n+        writeln(cast(int)float.max);\n+        assert(i == cast(int)float.max);\n+        assert(i == 0x80000000);\n+    }\n }\n \n /************************************/"}, {"sha": "d32531055f540e5f75ceaa666451922675fe0292", "filename": "gcc/testsuite/gdc.test/runnable/e7804.d", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fe7804.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fe7804.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fe7804.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -0,0 +1,179 @@\n+/* REQUIRED_ARGS: -unittest\n+*/\n+module e7804;\n+\n+struct Bar {static struct B{}}\n+alias BarB = __traits(getMember, Bar, \"B\");\n+static assert(is(BarB == Bar.B));\n+static assert(is(const(__traits(getMember, Bar, \"B\")) == const(Bar.B)));\n+\n+alias BarBParent = __traits(parent, BarB);\n+static assert(is(BarBParent == Bar));\n+\n+struct Foo {alias MyInt = int;}\n+alias FooInt = __traits(getMember, Foo, \"MyInt\");\n+static immutable FooInt fi = 42;\n+static assert(fi == 42);\n+void declVsStatementSupport()\n+{\n+    __traits(getMember, Foo, \"MyInt\") i1 = 1;\n+    const(__traits(getMember, Foo, \"MyInt\")) i2 = 1;\n+    assert(i1 == i2);\n+    __traits(getMember, Foo, \"MyInt\") i3 = __traits(getMember, Foo, \"MyInt\").max;\n+    assert(i3 == int.max);\n+}\n+\n+\n+enum __traits(getMember, Foo, \"MyInt\") a0 = 12;\n+static assert(is(typeof(a0) == int));\n+static assert(a0 == 12);\n+\n+\n+const __traits(getMember, Foo, \"MyInt\") a1 = 46;\n+\n+\n+__traits(getMember, Foo, \"MyInt\") a2 = 78;\n+\n+\n+const(__traits(getMember, Foo, \"MyInt\")) a3 = 63;\n+\n+\n+struct WithSym {static int foo; static int bar(){return 42;}}\n+alias m1 = __traits(getMember, WithSym, \"foo\");\n+alias m2 = WithSym.foo;\n+static assert(__traits(isSame, m1, m2));\n+alias f1 = __traits(getMember, WithSym, \"bar\");\n+alias f2 = WithSym.bar;\n+static assert(__traits(isSame, f1, f2));\n+\n+\n+auto ovld(const(char)[] s){return s;}\n+auto ovld(int i){return i;}\n+alias ovlds = __traits(getOverloads, e7804, \"ovld\");\n+\n+\n+struct TmpPrm(T)\n+if (is(T == int)){T t;}\n+TmpPrm!(__traits(getMember, Foo, \"MyInt\")) tpt = TmpPrm!(__traits(getMember, Foo, \"MyInt\"))(42);\n+\n+\n+@Foo @(1) class Class\n+{\n+    final void virtual(){}\n+    int virtual(int p){return p;}\n+    void test(this T)()\n+    {\n+        alias vf = __traits(getVirtualFunctions, Class, \"virtual\");\n+        assert(vf.length == 2);\n+        alias vm = __traits(getVirtualMethods, Class, \"virtual\");\n+        assert(vm.length == 1);\n+        assert(vm[0](42) == 42);\n+        alias attribs = __traits(getAttributes, Class);\n+        assert(attribs.length == 2);\n+        assert(is(typeof(attribs[0]()) == Foo));\n+        assert(attribs[1] == 1);\n+\n+        alias objectAll = __traits(allMembers, Object);\n+        alias classDerived = __traits(derivedMembers, Class);\n+        alias classAll = __traits(allMembers, Class);\n+        enum Seq(T...) = T;\n+        static assert (classAll == Seq!(classDerived, objectAll));\n+    }\n+}\n+\n+\n+struct UnitTests\n+{\n+    static int count;\n+    unittest { count++; }\n+    unittest {++++count;}\n+    static void test()\n+    {\n+        alias tests = __traits(getUnitTests, UnitTests);\n+        static assert(tests.length == 2);\n+        foreach(t; tests) t();\n+        assert(count == 6); // not 3 because executed automatically (DRT) then manually\n+    }\n+}\n+\n+\n+class One\n+{\n+    void foo(){}\n+    void foo(int){}\n+}\n+\n+class Two : One\n+{\n+    void test()\n+    {\n+        alias Seq(T...) = T;\n+        alias p1 = Seq!(__traits(getMember, super, \"foo\"))[0];\n+        alias p2 = __traits(getMember, super, \"foo\");\n+        static assert(__traits(isSame, p1, p2));\n+    }\n+}\n+\n+\n+class SingleSymTuple\n+{\n+    int foo(){return 42;}\n+    void test()\n+    {\n+        alias f = __traits(getMember, this, \"foo\");\n+        assert(f() == 42);\n+    }\n+}\n+\n+\n+struct WithAliasThis\n+{\n+    auto getter(){return 42;}\n+    alias getter this;\n+    void test()\n+    {\n+        alias getterCall = __traits(getAliasThis, typeof(this));\n+        assert(mixin(getterCall[0]) == 42);\n+    }\n+}\n+\n+void main()\n+{\n+    declVsStatementSupport();\n+    assert(a1 == 46);\n+    assert(a2 == 78);\n+    assert(a3 == 63);\n+    assert(f1() == f2());\n+    Foo.MyInt fmi = cast(__traits(getMember, Foo, \"MyInt\")) 0;\n+    auto c = __traits(getMember, Foo, \"MyInt\").max;\n+    assert(c == int.max);\n+    assert(ovlds[0](\"farfelu\") == \"farfelu\");\n+    assert(ovlds[1](42) == 42);\n+    (new Class).test();\n+    UnitTests.test();\n+    (new WithAliasThis).test();\n+    (new Two).test();\n+    (new SingleSymTuple).test();\n+}\n+\n+/* https://issues.dlang.org/show_bug.cgi?id=19708 */\n+struct Foo19708 {}\n+struct Bar19708 {}\n+template Baz19708(T) { struct Baz19708{T t;} }\n+int symbol19708;\n+\n+@Foo19708 @Bar19708 @Baz19708 @symbol19708 int bar19708;\n+\n+alias TR19708 = __traits(getAttributes, bar19708);\n+alias TRT = __traits(getAttributes, bar19708)[2];\n+\n+TR19708[0] a119708;\n+TR19708[1] a219708;\n+alias A3 = TRT!int;\n+\n+alias C19708 = TR19708[0];\n+alias D19708 = TR19708[1];\n+C19708 c1;\n+D19708 d1;\n+\n+static assert(__traits(isSame, TR19708[3], symbol19708));"}, {"sha": "0c390bc9cfe2d36f217895976c9afb20ae72d3a3", "filename": "gcc/testsuite/gdc.test/runnable/imports/template13478a.d", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fimports%2Ftemplate13478a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fimports%2Ftemplate13478a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fimports%2Ftemplate13478a.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -1,9 +1,8 @@\n module imports.template13478a;\n \n-import gcc.attribute;\n-\n-@attribute(\"noinline\") bool foo(T)() {\n+bool foo(T)() {\n     // Make sure this is not inlined so template13478.o actually\n     // needs to reference it.\n+    pragma(inline, false);\n     return false;\n }"}, {"sha": "bf6dc983935b1a58fccbd8b56317ff153bd29a42", "filename": "gcc/testsuite/gdc.test/runnable/staticforeach.d", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fstaticforeach.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fstaticforeach.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fstaticforeach.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -0,0 +1,45 @@\n+// REQUIRED_ARGS:\n+\n+/**********************************/\n+// https://issues.dlang.org/show_bug.cgi?id=19479\n+\n+mixin template genInts19479a()\n+{\n+    static foreach (t; 0..1)\n+        int i = 5;\n+}\n+\n+mixin template genInts19479b()\n+{\n+    static foreach (t; 0..2)\n+        mixin(\"int i\" ~ cast(char)('0' + t) ~ \" = 5;\");\n+}\n+\n+void test19479()\n+{\n+    {\n+        static foreach (t; 0..1)\n+            int i = 5;\n+        assert(i == 5);\n+    }\n+    {\n+        mixin genInts19479a!();\n+        assert(i == 5);\n+    }\n+    {\n+        static foreach (t; 0..2)\n+            mixin(\"int i\" ~ cast(char)('0' + t) ~ \" = 5;\");\n+        assert(i0 == 5);\n+        assert(i1 == 5);\n+    }\n+    {\n+        mixin genInts19479b!();\n+        assert(i0 == 5);\n+        assert(i1 == 5);\n+    }\n+}\n+\n+void main()\n+{\n+    test19479();\n+}"}, {"sha": "6e0c42b6ff55edb017021a5383369290782496c7", "filename": "gcc/testsuite/gdc.test/runnable/test42.d", "status": "modified", "additions": 6, "deletions": 54, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest42.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest42.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest42.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -1682,54 +1682,13 @@ void test101()\n \n /***************************************************/\n \n-version(GNU)\n-{\n-int x103;\n-\n-void external(int a, ...)\n-{\n-    va_list ap;\n-    va_start(ap, a);\n-    auto ext = va_arg!int(ap);\n-    printf(\"external: %d\\n\", ext);\n-    x103 = ext;\n-    va_end(ap);\n-}\n-\n-class C103\n-{\n-    void method ()\n-    {\n-        void internal (int a, ...)\n-        {\n-            va_list ap;\n-            va_start(ap, a);\n-        auto internal = va_arg!int(ap);\n-            printf(\"internal: %d\\n\", internal);\n-            x103 = internal;\n-            va_end(ap);\n-        }\n-\n-        internal (0, 43);\n-        assert(x103 == 43);\n-    }\n-}\n-\n-void test103()\n-{\n-    external(0, 42);\n-    assert(x103 == 42);\n-    (new C103).method ();\n-}\n-}\n-else version(X86)\n-{\n int x103;\n \n void external(...)\n {\n-    printf(\"external: %d\\n\", *cast (int *) _argptr);\n-    x103 = *cast (int *) _argptr;\n+    int arg = va_arg!int(_argptr);\n+    printf(\"external: %d\\n\", arg);\n+    x103 = arg;\n }\n \n class C103\n@@ -1738,8 +1697,9 @@ class C103\n     {\n         void internal (...)\n         {\n-            printf(\"internal: %d\\n\", *cast (int *)_argptr);\n-            x103 = *cast (int *) _argptr;\n+            int arg = va_arg!int(_argptr);\n+            printf(\"internal: %d\\n\", arg);\n+            x103 = arg;\n         }\n \n         internal (43);\n@@ -1753,14 +1713,6 @@ void test103()\n     assert(x103 == 42);\n     (new C103).method ();\n }\n-}\n-else version(X86_64)\n-{\n-    pragma(msg, \"Not ported to x86-64 compatible varargs, yet.\");\n-    void test103() {}\n-}\n-else\n-    static assert(false, \"Unknown platform\");\n \n /***************************************************/\n "}, {"sha": "6c3bf7859e35f2fe2c93fd1aa796ea6b3ce81425", "filename": "gcc/testsuite/gdc.test/runnable/traits.d", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b74dd0a2278365eb562d9d1999c3c11cddb733c/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits.d?ref=5b74dd0a2278365eb562d9d1999c3c11cddb733c", "patch": "@@ -1247,14 +1247,35 @@ struct S10096X\n     invariant() {}\n     invariant() {}\n     unittest {}\n+    unittest {}\n \n     this(int) {}\n     this(this) {}\n     ~this() {}\n+\n+    string getStr() in(str) out(r; r == str) { return str; }\n }\n static assert(\n     [__traits(allMembers, S10096X)] ==\n-    [\"str\", \"__ctor\", \"__postblit\", \"__dtor\", \"__xdtor\", \"__xpostblit\", \"opAssign\"]);\n+    [\"str\", \"__ctor\", \"__postblit\", \"__dtor\", \"getStr\", \"__xdtor\", \"__xpostblit\", \"opAssign\"]);\n+\n+class C10096X\n+{\n+    string str;\n+\n+    invariant() {}\n+    invariant() {}\n+    unittest {}\n+    unittest {}\n+\n+    this(int) {}\n+    ~this() {}\n+\n+    string getStr() in(str) out(r; r == str) { return str;\n+}\n+static assert(\n+    [__traits(allMembers, C10096X)] ==\n+    [\"str\", \"__ctor\", \"__dtor\", \"getStr\", \"__xdtor\", \"toString\", \"toHash\", \"opCmp\", \"opEquals\", \"Monitor\", \"factory\"]);\n \n // --------\n \n@@ -1525,6 +1546,21 @@ void async(ARGS...)(ARGS)\n \n alias test17495 = async!(int, int);\n \n+/********************************************************/\n+// https://issues.dlang.org/show_bug.cgi?id=10100\n+\n+enum E10100\n+{\n+    value,\n+    _value,\n+    __value,\n+    ___value,\n+    ____value,\n+}\n+static assert(\n+    [__traits(allMembers, E10100)] ==\n+    [\"value\", \"_value\", \"__value\", \"___value\", \"____value\"]);\n+\n /********************************************************/\n \n int main()"}]}