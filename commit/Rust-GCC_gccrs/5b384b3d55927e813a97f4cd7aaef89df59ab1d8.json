{"sha": "5b384b3d55927e813a97f4cd7aaef89df59ab1d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIzODRiM2Q1NTkyN2U4MTNhOTdmNGNkN2FhZWY4OWRmNTlhYjFkOA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-01-18T22:01:29Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-01-18T22:01:29Z"}, "message": "[multiple changes]\n\n2015-01-18  Andre Vehreschild  <vehre@gmx.de>\n\t    Janus Weil <janus@gcc.gnu.org>\n\n\tPR fortran/60255\n\t* class.c (gfc_get_len_component): New.\n\t(gfc_build_class_symbol): Add _len component to unlimited\n\tpolymorphic entities.\n\t(find_intrinsic_vtab): Removed emitting of error message.\n\t* gfortran.h: Added prototype for gfc_get_len_component.\n\t* simplify.c (gfc_simplify_len): Use _len component where\n\tavailable.\n\t* trans-expr.c (gfc_class_len_get): New.\n\t(gfc_conv_intrinsic_to_class): Add handling for deferred\n\tcharacter arrays.\n\t(gfc_conv_structure): Treat _len component correctly.\n\t(gfc_conv_expr): Prevent bind_c handling when not required.\n\t(gfc_trans_pointer_assignment): Propagate _len component.\n\t* trans-stmt.c (class_has_len_component): New.\n\t(trans_associate_var): _len component treatment for associate\n\tcontext.\n\t(gfc_trans_allocate): Same as for trans_associate_var()\n\t* trans.h: Added prototype for gfc_class_len_get.\n\n2015-01-18  Andre Vehreschild  <vehre@gmx.de>\n\n\tPR fortran/60255\n\t* gfortran.dg/unlimited_polymorphic_2.f03: Removed error.\n\t* gfortran.dg/unlimited_polymorphic_20.f03: New test.\n\n2015-01-18  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/64578\n\t* gfortran.dg/unlimited_polymorphic_21.f90: New test\n\nFrom-SVN: r219827", "tree": {"sha": "8897cf52c9332ef304732836b3ee4b66ef2cbb2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8897cf52c9332ef304732836b3ee4b66ef2cbb2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b384b3d55927e813a97f4cd7aaef89df59ab1d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b384b3d55927e813a97f4cd7aaef89df59ab1d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b384b3d55927e813a97f4cd7aaef89df59ab1d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/comments", "author": null, "committer": null, "parents": [{"sha": "69fe4502488fea1573f2d5166235540e3d9a466e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69fe4502488fea1573f2d5166235540e3d9a466e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69fe4502488fea1573f2d5166235540e3d9a466e"}], "stats": {"total": 447, "additions": 417, "deletions": 30}, "files": [{"sha": "638f962270ec08847c66a4de96d1c2ba026127a0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5b384b3d55927e813a97f4cd7aaef89df59ab1d8", "patch": "@@ -1,3 +1,26 @@\n+2015-01-18  Andre Vehreschild  <vehre@gmx.de>\n+\t    Janus Weil <janus@gcc.gnu.org>\n+\n+\tPR fortran/60255\n+\t* class.c (gfc_get_len_component): New.\n+\t(gfc_build_class_symbol): Add _len component to unlimited\n+\tpolymorphic entities.\n+\t(find_intrinsic_vtab): Removed emitting of error message.\n+\t* gfortran.h: Added prototype for gfc_get_len_component.\n+\t* simplify.c (gfc_simplify_len): Use _len component where\n+\tavailable.\n+\t* trans-expr.c (gfc_class_len_get): New.\n+\t(gfc_conv_intrinsic_to_class): Add handling for deferred\n+\tcharacter arrays.\n+\t(gfc_conv_structure): Treat _len component correctly.\n+\t(gfc_conv_expr): Prevent bind_c handling when not required.\n+\t(gfc_trans_pointer_assignment): Propagate _len component.\n+\t* trans-stmt.c (class_has_len_component): New.\n+\t(trans_associate_var): _len component treatment for associate\n+\tcontext.\n+\t(gfc_trans_allocate): Same as for trans_associate_var()\n+\t* trans.h: Added prototype for gfc_class_len_get.\n+\n 2015-01-18  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/57959"}, {"sha": "a9b65e65b2b1abbc50a940333b83a9389467debd", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 60, "deletions": 16, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=5b384b3d55927e813a97f4cd7aaef89df59ab1d8", "patch": "@@ -34,6 +34,12 @@ along with GCC; see the file COPYING3.  If not see\n              (pointer/allocatable/dimension/...).\n     * _vptr: A pointer to the vtable entry (see below) of the dynamic type.\n \n+    Only for unlimited polymorphic classes:\n+    * _len:  An integer(4) to store the string length when the unlimited\n+             polymorphic pointer is used to point to a char array.  The '_len'\n+             component will be zero when no character array is stored in\n+             '_data'.\n+\n    For each derived type we set up a \"vtable\" entry, i.e. a structure with the\n    following fields:\n     * _hash:     A hash value serving as a unique identifier for this type.\n@@ -544,10 +550,48 @@ gfc_intrinsic_hash_value (gfc_typespec *ts)\n }\n \n \n+/* Get the _len component from a class/derived object storing a string.\n+   For unlimited polymorphic entities a ref to the _data component is available\n+   while a ref to the _len component is needed.  This routine traverese the\n+   ref-chain and strips the last ref to a _data from it replacing it with a\n+   ref to the _len component.  */\n+\n+gfc_expr *\n+gfc_get_len_component (gfc_expr *e)\n+{\n+  gfc_expr *ptr;\n+  gfc_ref *ref, **last;\n+\n+  ptr = gfc_copy_expr (e);\n+\n+  /* We need to remove the last _data component ref from ptr.  */\n+  last = &(ptr->ref);\n+  ref = ptr->ref;\n+  while (ref)\n+    {\n+      if (!ref->next\n+\t  && ref->type == REF_COMPONENT\n+\t  && strcmp (\"_data\", ref->u.c.component->name)== 0)\n+\t{\n+\t  gfc_free_ref_list (ref);\n+\t  *last = NULL;\n+\t  break;\n+\t}\n+      last = &(ref->next);\n+      ref = ref->next;\n+    }\n+  /* And replace if with a ref to the _len component.  */\n+  gfc_add_component_ref (ptr, \"_len\");\n+  return ptr;\n+}\n+\n+\n /* Build a polymorphic CLASS entity, using the symbol that comes from\n    build_sym. A CLASS entity is represented by an encapsulating type,\n    which contains the declared type as '_data' component, plus a pointer\n-   component '_vptr' which determines the dynamic type.  */\n+   component '_vptr' which determines the dynamic type.  When this CLASS\n+   entity is unlimited polymorphic, then also add a component '_len' to\n+   store the length of string when that is stored in it.  */\n \n bool\n gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n@@ -645,19 +689,28 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n       if (!gfc_add_component (fclass, \"_vptr\", &c))\n \treturn false;\n       c->ts.type = BT_DERIVED;\n+      c->attr.access = ACCESS_PRIVATE;\n+      c->attr.pointer = 1;\n \n       if (ts->u.derived->attr.unlimited_polymorphic)\n \t{\n \t  vtab = gfc_find_derived_vtab (ts->u.derived);\n \t  gcc_assert (vtab);\n \t  c->ts.u.derived = vtab->ts.u.derived;\n+\n+\t  /* Add component '_len'.  Only unlimited polymorphic pointers may\n+             have a string assigned to them, i.e., only those need the _len\n+             component.  */\n+\t  if (!gfc_add_component (fclass, \"_len\", &c))\n+\t    return false;\n+\t  c->ts.type = BT_INTEGER;\n+\t  c->ts.kind = 4;\n+\t  c->attr.access = ACCESS_PRIVATE;\n+\t  c->attr.artificial = 1;\n \t}\n       else\n \t/* Build vtab later.  */\n \tc->ts.u.derived = NULL;\n-\n-      c->attr.access = ACCESS_PRIVATE;\n-      c->attr.pointer = 1;\n     }\n \n   if (!ts->u.derived->attr.unlimited_polymorphic)\n@@ -2415,18 +2468,9 @@ find_intrinsic_vtab (gfc_typespec *ts)\n   gfc_symbol *copy = NULL, *src = NULL, *dst = NULL;\n   int charlen = 0;\n \n-  if (ts->type == BT_CHARACTER)\n-    {\n-      if (ts->deferred)\n-\t{\n-\t  gfc_error (\"TODO: Deferred character length variable at %C cannot \"\n-\t\t     \"yet be associated with unlimited polymorphic entities\");\n-\t  return NULL;\n-\t}\n-      else if (ts->u.cl && ts->u.cl->length\n-\t       && ts->u.cl->length->expr_type == EXPR_CONSTANT)\n-\tcharlen = mpz_get_si (ts->u.cl->length->value.integer);\n-    }\n+  if (ts->type == BT_CHARACTER && !ts->deferred && ts->u.cl && ts->u.cl->length\n+      && ts->u.cl->length->expr_type == EXPR_CONSTANT)\n+    charlen = mpz_get_si (ts->u.cl->length->value.integer);\n \n   /* Find the top-level namespace.  */\n   for (ns = gfc_current_ns; ns; ns = ns->parent)"}, {"sha": "287669b1f8bb264a2ab61834d8e40bb89c0f8d59", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=5b384b3d55927e813a97f4cd7aaef89df59ab1d8", "patch": "@@ -3174,6 +3174,7 @@ bool gfc_is_class_scalar_expr (gfc_expr *);\n bool gfc_is_class_container_ref (gfc_expr *e);\n gfc_expr *gfc_class_initializer (gfc_typespec *, gfc_expr *);\n unsigned int gfc_hash_value (gfc_symbol *);\n+gfc_expr *gfc_get_len_component (gfc_expr *e);\n bool gfc_build_class_symbol (gfc_typespec *, symbol_attribute *,\n \t\t\t     gfc_array_spec **);\n gfc_symbol *gfc_find_derived_vtab (gfc_symbol *);"}, {"sha": "92b3076b634f1c66950ce948a579ed6f74afa4ca", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=5b384b3d55927e813a97f4cd7aaef89df59ab1d8", "patch": "@@ -3713,6 +3713,14 @@ gfc_simplify_len (gfc_expr *e, gfc_expr *kind)\n       mpz_set (result->value.integer, e->ts.u.cl->length->value.integer);\n       return range_check (result, \"LEN\");\n     }\n+  else if (e->expr_type == EXPR_VARIABLE && e->ts.type == BT_CHARACTER\n+\t   && e->symtree->n.sym\n+\t   && e->symtree->n.sym->assoc && e->symtree->n.sym->assoc->target\n+\t   && e->symtree->n.sym->assoc->target->ts.type == BT_DERIVED)\n+    /* The expression in assoc->target points to a ref to the _data component\n+       of the unlimited polymorphic entity.  To get the _len component the last\n+       _data ref needs to be stripped and a ref to the _len component added.  */\n+    return gfc_get_len_component (e->symtree->n.sym->assoc->target);\n   else\n     return NULL;\n }"}, {"sha": "91cac41f9990818465c0d30a8c67746404dec403", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 85, "deletions": 1, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=5b384b3d55927e813a97f4cd7aaef89df59ab1d8", "patch": "@@ -104,6 +104,7 @@ gfc_conv_scalar_to_descriptor (gfc_se *se, tree scalar, symbol_attribute attr)\n    in future implementations.  Use the corresponding APIs.  */\n #define CLASS_DATA_FIELD 0\n #define CLASS_VPTR_FIELD 1\n+#define CLASS_LEN_FIELD 2\n #define VTABLE_HASH_FIELD 0\n #define VTABLE_SIZE_FIELD 1\n #define VTABLE_EXTENDS_FIELD 2\n@@ -158,6 +159,20 @@ gfc_class_vptr_get (tree decl)\n }\n \n \n+tree\n+gfc_class_len_get (tree decl)\n+{\n+  tree len;\n+  if (POINTER_TYPE_P (TREE_TYPE (decl)))\n+    decl = build_fold_indirect_ref_loc (input_location, decl);\n+  len = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (decl)),\n+\t\t\t    CLASS_LEN_FIELD);\n+  return fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t  TREE_TYPE (len), decl, len,\n+\t\t\t  NULL_TREE);\n+}\n+\n+\n static tree\n gfc_vtable_field_get (tree decl, int field)\n {\n@@ -627,6 +642,45 @@ gfc_conv_intrinsic_to_class (gfc_se *parmse, gfc_expr *e,\n \t}\n     }\n \n+  /* When the actual arg is a char array, then set the _len component of the\n+     unlimited polymorphic entity, too.  */\n+  if (e->ts.type == BT_CHARACTER)\n+    {\n+      ctree = gfc_class_len_get (var);\n+      /* Start with parmse->string_length because this seems to be set to a\n+\t correct value more often.  */\n+      if (parmse->string_length)\n+\t  gfc_add_modify (&parmse->pre, ctree, parmse->string_length);\n+      /* When the string_length is not yet set, then try the backend_decl of\n+\t the cl.  */\n+      else if (e->ts.u.cl->backend_decl)\n+          gfc_add_modify (&parmse->pre, ctree, e->ts.u.cl->backend_decl);\n+      /* If both of the above approaches fail, then try to generate an\n+\t expression from the input, which is only feasible currently, when the\n+\t expression can be evaluated to a constant one.  */\n+      else\n+        {\n+          /* Try to simplify the expression.  */\n+          gfc_simplify_expr (e, 0);\n+          if (e->expr_type == EXPR_CONSTANT && !e->ts.u.cl->resolved)\n+            {\n+              /* Amazingly all data is present to compute the length of a\n+                 constant string, but the expression is not yet there.  */\n+              e->ts.u.cl->length = gfc_get_constant_expr (BT_INTEGER, 1,\n+                                                          &e->where);\n+              mpz_set_ui (e->ts.u.cl->length->value.integer,\n+                          e->value.character.length);\n+              gfc_conv_const_charlen (e->ts.u.cl);\n+              e->ts.u.cl->resolved = 1;\n+              gfc_add_modify (&parmse->pre, ctree, e->ts.u.cl->backend_decl);\n+            }\n+          else\n+            {\n+              gfc_error (\"Can't compute the length of the char array at %L.\",\n+                         &e->where);\n+            }\n+        }\n+    }\n   /* Pass the address of the class object.  */\n   parmse->expr = gfc_build_addr_expr (NULL_TREE, var);\n }\n@@ -6656,6 +6710,14 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n \t\t\t\t  fold_convert (TREE_TYPE (cm->backend_decl),\n \t\t\t\t\t\tval));\n \t}\n+      else if (cm->ts.type == BT_INTEGER && strcmp (cm->name, \"_len\") == 0)\n+        {\n+          gfc_expr *e = gfc_get_int_expr (gfc_default_integer_kind, NULL, 0);\n+          val = gfc_conv_constant_to_tree (e);\n+          CONSTRUCTOR_APPEND_ELT (v, cm->backend_decl,\n+                                  fold_convert (TREE_TYPE (cm->backend_decl),\n+                                                val));\n+        }\n       else\n \t{\n \t  val = gfc_conv_initializer (c->expr, &cm->ts,\n@@ -6732,7 +6794,8 @@ gfc_conv_expr (gfc_se * se, gfc_expr * expr)\n      null_pointer_node.  C_PTR and C_FUNPTR are converted to match the\n      typespec for the C_PTR and C_FUNPTR symbols, which has already been\n      updated to be an integer with a kind equal to the size of a (void *).  */\n-  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->ts.f90_type == BT_VOID)\n+  if (expr->ts.type == BT_DERIVED && expr->ts.u.derived->ts.f90_type == BT_VOID\n+      && expr->ts.u.derived->attr.is_bind_c)\n     {\n       if (expr->expr_type == EXPR_VARIABLE\n \t  && (expr->symtree->n.sym->intmod_sym_id == ISOCBINDING_NULL_PTR\n@@ -7000,6 +7063,27 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n       gfc_add_block_to_block (&block, &lse.pre);\n       gfc_add_block_to_block (&block, &rse.pre);\n \n+      /* For string assignments to unlimited polymorphic pointers add an\n+\t assignment of the string_length to the _len component of the\n+\t pointer.  */\n+      if ((expr1->ts.type == BT_CLASS || expr1->ts.type == BT_DERIVED)\n+\t  && expr1->ts.u.derived->attr.unlimited_polymorphic\n+\t  && (expr2->ts.type == BT_CHARACTER ||\n+\t      ((expr2->ts.type == BT_DERIVED || expr2->ts.type == BT_CLASS)\n+\t       && expr2->ts.u.derived->attr.unlimited_polymorphic)))\n+\t{\n+\t  gfc_expr *len_comp;\n+\t  gfc_se se;\n+\t  len_comp = gfc_get_len_component (expr1);\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr (&se, len_comp);\n+\n+\t  /* ptr % _len = len (str)  */\n+\t  gfc_add_modify (&block, se.expr, rse.string_length);\n+\t  lse.string_length = se.expr;\n+\t  gfc_free_expr (len_comp);\n+\t}\n+\n       /* Check character lengths if character expression.  The test is only\n \t really added if -fbounds-check is enabled.  Exclude deferred\n \t character length lefthand sides.  */"}, {"sha": "a9cbe43b2a9691cdf3599212478d33e4f7d7ae51", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 88, "deletions": 12, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=5b384b3d55927e813a97f4cd7aaef89df59ab1d8", "patch": "@@ -1154,6 +1154,22 @@ gfc_trans_critical (gfc_code *code)\n }\n \n \n+/* Return true, when the class has a _len component.  */\n+\n+static bool\n+class_has_len_component (gfc_symbol *sym)\n+{\n+  gfc_component *comp = sym->ts.u.derived->components;\n+  while (comp)\n+    {\n+      if (strcmp (comp->name, \"_len\") == 0)\n+\treturn true;\n+      comp = comp->next;\n+    }\n+  return false;\n+}\n+\n+\n /* Do proper initialization for ASSOCIATE names.  */\n \n static void\n@@ -1167,6 +1183,8 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n   tree offset;\n   tree dim;\n   int n;\n+  tree charlen;\n+  bool need_len_assign;\n \n   gcc_assert (sym->assoc);\n   e = sym->assoc->target;\n@@ -1177,6 +1195,20 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \n   unlimited = UNLIMITED_POLY (e);\n \n+  /* Assignments to the string length need to be generated, when\n+     ( sym is a char array or\n+       sym has a _len component)\n+     and the associated expression is unlimited polymorphic, which is\n+     not (yet) correctly in 'unlimited', because for an already associated\n+     BT_DERIVED the u-poly flag is not set, i.e.,\n+      __tmp_CHARACTER_0_1 => w => arg\n+       ^ generated temp      ^ from code, the w does not have the u-poly\n+     flag set, where UNLIMITED_POLY(e) expects it.  */\n+  need_len_assign = ((unlimited || (e->ts.type == BT_DERIVED\n+                     && e->ts.u.derived->attr.unlimited_polymorphic))\n+      && (sym->ts.type == BT_CHARACTER\n+          || ((sym->ts.type == BT_CLASS || sym->ts.type == BT_DERIVED)\n+              && class_has_len_component (sym))));\n   /* Do a `pointer assignment' with updated descriptor (or assign descriptor\n      to array temporary) for arrays with either unknown shape or if associating\n      to a variable.  */\n@@ -1276,8 +1308,11 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t unconditionally associate pointers and the symbol is scalar.  */\n       if (sym->ts.type == BT_CLASS && CLASS_DATA (sym)->attr.dimension)\n \t{\n+\t  tree target_expr;\n \t  /* For a class array we need a descriptor for the selector.  */\n \t  gfc_conv_expr_descriptor (&se, e);\n+\t  /* Needed to get/set the _len component below.  */\n+\t  target_expr = se.expr;\n \n \t  /* Obtain a temporary class container for the result.  */\n \t  gfc_conv_class_to_class (&se, e, sym->ts, false, true, false, false);\n@@ -1297,6 +1332,23 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t\t\t\t        gfc_array_index_type,\n \t\t\t\t        offset, tmp);\n \t    }\n+\t  if (need_len_assign)\n+\t    {\n+\t      /* Get the _len comp from the target expr by stripping _data\n+\t\t from it and adding component-ref to _len.  */\n+\t      tmp = gfc_class_len_get (TREE_OPERAND (target_expr, 0));\n+\t      /* Get the component-ref for the temp structure's _len comp.  */\n+\t      charlen = gfc_class_len_get (se.expr);\n+\t      /* Add the assign to the beginning of the the block...  */\n+\t      gfc_add_modify (&se.pre, charlen,\n+\t\t\t      fold_convert (TREE_TYPE (charlen), tmp));\n+\t      /* and the oposite way at the end of the block, to hand changes\n+\t\t on the string length back.  */\n+\t      gfc_add_modify (&se.post, tmp,\n+\t\t\t      fold_convert (TREE_TYPE (tmp), charlen));\n+\t      /* Length assignment done, prevent adding it again below.  */\n+\t      need_len_assign = false;\n+\t    }\n \t  gfc_conv_descriptor_offset_set (&se.pre, desc, offset);\n \t}\n       else if (sym->ts.type == BT_CLASS && e->ts.type == BT_CLASS\n@@ -1311,7 +1363,13 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t  se.expr = build_fold_indirect_ref_loc (input_location, se.expr);\n \t}\n       else\n-\tgfc_conv_expr (&se, e);\n+\t{\n+\t  /* For BT_CLASS and BT_DERIVED, this boils down to a pointer assign,\n+\t     which has the string length included.  For CHARACTERS it is still\n+\t     needed and will be done at the end of this routine.  */\n+\t  gfc_conv_expr (&se, e);\n+\t  need_len_assign = need_len_assign && sym->ts.type == BT_CHARACTER;\n+\t}\n \n       tmp = TREE_TYPE (sym->backend_decl);\n       tmp = gfc_build_addr_expr (tmp, se.expr);\n@@ -1332,21 +1390,30 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n       gfc_add_init_cleanup (block, tmp, NULL_TREE);\n     }\n \n-  /* Set the stringlength from the vtable size.  */\n-  if (sym->ts.type == BT_CHARACTER && sym->attr.select_type_temporary)\n+  /* Set the stringlength, when needed.  */\n+  if (need_len_assign)\n     {\n-      tree charlen;\n       gfc_se se;\n       gfc_init_se (&se, NULL);\n-      gcc_assert (UNLIMITED_POLY (e->symtree->n.sym));\n-      tmp = gfc_get_symbol_decl (e->symtree->n.sym);\n-      tmp = gfc_vtable_size_get (tmp);\n+      if (e->symtree->n.sym->ts.type == BT_CHARACTER)\n+\t{\n+\t  /* What about deferred strings?  */\n+\t  gcc_assert (!e->symtree->n.sym->ts.deferred);\n+\t  tmp = e->symtree->n.sym->ts.u.cl->backend_decl;\n+\t}\n+      else\n+\ttmp = gfc_class_len_get (gfc_get_symbol_decl (e->symtree->n.sym));\n       gfc_get_symbol_decl (sym);\n-      charlen = sym->ts.u.cl->backend_decl;\n-      gfc_add_modify (&se.pre, charlen,\n-\t\t      fold_convert (TREE_TYPE (charlen), tmp));\n-      gfc_add_init_cleanup (block, gfc_finish_block( &se.pre),\n-\t\t\t    gfc_finish_block (&se.post));\n+      charlen = sym->ts.type == BT_CHARACTER ? sym->ts.u.cl->backend_decl\n+\t\t\t\t\t: gfc_class_len_get (sym->backend_decl);\n+      /* Prevent adding a noop len= len.  */\n+      if (tmp != charlen)\n+\t{\n+\t  gfc_add_modify (&se.pre, charlen,\n+\t\t\t  fold_convert (TREE_TYPE (charlen), tmp));\n+\t  gfc_add_init_cleanup (block, gfc_finish_block (&se.pre),\n+\t\t\t\tgfc_finish_block (&se.post));\n+\t}\n     }\n }\n \n@@ -5069,6 +5136,15 @@ gfc_trans_allocate (gfc_code * code)\n \t\tgfc_add_modify (&se.pre, se.string_length,\n \t\t\t\tfold_convert (TREE_TYPE (se.string_length),\n \t\t\t\tmemsz));\n+\t      else if ((al->expr->ts.type == BT_DERIVED\n+\t\t\t|| al->expr->ts.type == BT_CLASS)\n+\t\t       && expr->ts.u.derived->attr.unlimited_polymorphic)\n+\t\t{\n+\t\t  tmp = gfc_class_len_get (al->expr->symtree->n.sym->backend_decl);\n+\t\t  gfc_add_modify (&se.pre, tmp,\n+\t\t\t\t  fold_convert (TREE_TYPE (tmp),\n+\t\t\t\t\t\tmemsz));\n+\t\t}\n \n \t      /* Convert to size in bytes, using the character KIND.  */\n \t      if (unlimited_char)"}, {"sha": "bd1520aeada83e9b40a71366c791c2801b9669ab", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=5b384b3d55927e813a97f4cd7aaef89df59ab1d8", "patch": "@@ -348,6 +348,7 @@ gfc_wrapped_block;\n /* Class API functions.  */\n tree gfc_class_data_get (tree);\n tree gfc_class_vptr_get (tree);\n+tree gfc_class_len_get (tree);\n void gfc_reset_vptr (stmtblock_t *, gfc_expr *);\n tree gfc_class_set_static_fields (tree, tree, tree);\n tree gfc_vtable_hash_get (tree);"}, {"sha": "88be2da4f39d5d86a343f2bf34af058b6e83e324", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5b384b3d55927e813a97f4cd7aaef89df59ab1d8", "patch": "@@ -1,3 +1,14 @@\n+2015-01-18  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/60255\n+\t* gfortran.dg/unlimited_polymorphic_2.f03: Removed error.\n+\t* gfortran.dg/unlimited_polymorphic_20.f03: New test.\n+\n+2015-01-18  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/64578\n+\t* gfortran.dg/unlimited_polymorphic_21.f90: New test\n+\n 2015-01-18  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/64652"}, {"sha": "5eea79dec774c8af70f9a60d1f54a2f56fb581c5", "filename": "gcc/testsuite/gfortran.dg/unlimited_polymorphic_2.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_2.f03?ref=5b384b3d55927e813a97f4cd7aaef89df59ab1d8", "patch": "@@ -5,7 +5,7 @@\n ! Contributed by Paul Thomas  <pault@gcc.gnu.org>\r\n !            and Tobias Burnus <burnus@gcc.gnu.org>\r\n !\r\n-  CHARACTER(:), allocatable, target :: chr ! { dg-error \"TODO: Deferred character length variable\" }\r\n+  CHARACTER(:), allocatable, target :: chr\r\n ! F2008: C5100\r\n   integer :: i(2)\r\n   logical :: flag\r"}, {"sha": "c6c6d29a8071b93672408321430acbd7cd956225", "filename": "gcc/testsuite/gfortran.dg/unlimited_polymorphic_20.f90", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_20.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_20.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_20.f90?ref=5b384b3d55927e813a97f4cd7aaef89df59ab1d8", "patch": "@@ -0,0 +1,104 @@\n+! { dg-do run }\n+!\n+! Testing fix for PR fortran/60255\n+!\n+! Author: Andre Vehreschild <vehre@gmx.de>\n+!\n+MODULE m\n+\n+contains\n+  subroutine bar (arg, res)\n+    class(*) :: arg\n+    character(100) :: res\n+    select type (w => arg)\n+      type is (character(*))\n+        write (res, '(I2)') len(w)\n+    end select\n+  end subroutine\n+\n+END MODULE\n+\n+program test\n+    use m;\n+    implicit none\n+    character(LEN=:), allocatable, target :: S\n+    character(LEN=100) :: res\n+    class(*), pointer :: ucp\n+    call sub1 (\"long test string\", 16)\n+    call sub2 ()\n+    S = \"test\"\n+    ucp => S\n+    call sub3 (ucp)\n+    call sub4 (S, 4)\n+    call sub4 (\"This is a longer string.\", 24)\n+    call bar (S, res)\n+    if (trim (res) .NE. \" 4\") call abort ()\n+    call bar(ucp, res)\n+    if (trim (res) .NE. \" 4\") call abort ()\n+\n+contains\n+\n+    subroutine sub1(dcl, ilen)\n+        character(len=*), target :: dcl\n+        integer(4) :: ilen\n+        character(len=:), allocatable :: hlp\n+        class(*), pointer :: ucp\n+\n+        ucp => dcl\n+\n+        select type (ucp)\n+        type is (character(len=*))\n+            if (len(dcl) .NE. ilen) call abort ()\n+            if (len(ucp) .NE. ilen) call abort ()\n+            hlp = ucp\n+            if (len(hlp) .NE. ilen) call abort ()\n+        class default\n+            call abort()\n+        end select\n+    end subroutine\n+\n+    subroutine sub2\n+        character(len=:), allocatable, target :: dcl\n+        class(*), pointer :: ucp\n+\n+        dcl = \"ttt\"\n+        ucp => dcl\n+\n+        select type (ucp)\n+        type is (character(len=*))\n+            if (len(ucp) .ne. 3) call abort ()\n+        class default\n+            call abort()\n+        end select\n+    end subroutine\n+\n+    subroutine sub3(ucp)\n+        character(len=:), allocatable :: hlp\n+        class(*), pointer :: ucp\n+\n+        select type (ucp)\n+        type is (character(len=*))\n+            if (len(ucp) .ne. 4) call abort ()\n+            hlp = ucp\n+            if (len(hlp) .ne. 4) call abort ()\n+        class default\n+            call abort()\n+        end select\n+    end subroutine\n+\n+    subroutine sub4(ucp, ilen)\n+        character(len=:), allocatable :: hlp\n+        integer(4) :: ilen\n+        class(*) :: ucp\n+\n+        select type (ucp)\n+        type is (character(len=*))\n+            if (len(ucp) .ne. ilen) call abort ()\n+            hlp = ucp\n+            if (len(hlp) .ne. ilen) call abort ()\n+        class default\n+            call abort()\n+        end select\n+    end subroutine\n+end program\n+"}, {"sha": "fecb5934007fa391c4f63b5a21a42a560b4a9e20", "filename": "gcc/testsuite/gfortran.dg/unlimited_polymorphic_21.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_21.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b384b3d55927e813a97f4cd7aaef89df59ab1d8/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_21.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Funlimited_polymorphic_21.f90?ref=5b384b3d55927e813a97f4cd7aaef89df59ab1d8", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do run }\n+! Tests the fix for PR64578.\n+!\n+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>\n+!\n+  type foo\n+     real, allocatable :: component(:)\n+  end type\n+  type (foo), target :: f\n+  class(*), pointer :: ptr(:)\n+  allocate(f%component(1),source=[0.99])\n+  call associate_pointer(f,ptr)\n+  select type (ptr)\n+    type is (real)\n+      if (abs (ptr(1) - 0.99) > 1e-5) call abort\n+  end select\n+  ptr => return_pointer(f)  ! runtime segmentation fault\n+  if (associated(return_pointer(f)) .neqv. .true.) call abort\n+  select type (ptr)\n+    type is (real)\n+      if (abs (ptr(1) - 0.99) > 1e-5) call abort\n+  end select\n+contains\n+  subroutine associate_pointer(this, item)\n+    class(foo), target :: this\n+    class(*), pointer :: item(:)\n+    item => this%component\n+  end subroutine\n+  function return_pointer(this)\n+    class(foo), target :: this\n+    class(*), pointer :: return_pointer(:)\n+    return_pointer => this%component\n+  end function\n+end\n+"}]}