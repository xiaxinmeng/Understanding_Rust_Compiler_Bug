{"sha": "a40ed31be5fb790bd5281404c0703039ee34de06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQwZWQzMWJlNWZiNzkwYmQ1MjgxNDA0YzA3MDMwMzllZTM0ZGUwNg==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1994-06-01T00:39:40Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1994-06-01T00:39:40Z"}, "message": "(SECONDARY_MEMORY_NEEDED): Simplify.\n\n(ADDITIONAL_REGISTER_NAMES): Define.\n(CONDITIONAL_REGISTER_USAGE): Make PIC_OFFSET_TABLE_REGNUM fixed\nagain.\n(FIRST_PSEUDO_REGISTER): Now 89.\n(FIXED_REGISTERS): Delete 1.0 fp registers,\n(CALL_USED_REGISTERS): Likewise.\n(CONDITIONAL_REGISTER_USAGE): Almost deleted.\n(REG_ALLOC_ORDER): Update register numbers.\n(HARD_REGNO_NREGS): Delete special case for 1.0 fp registers.\n(HARD_REGNO_MODE_OK): Rewrite.  Don't allow use of odd fp registers\n(enum reg_class): Delete HI_SNAKE_FP_REGS and FP_OR_SNAKE_FP_REGS.\n(REG_CLASS_NAMES): Corresponding change.\n(REG_CLASS_CONTENTS): Delete HI_SNAKE_FP_REGS and\nFP_OR_SNAKE_FP_REGS.  Make SNAKE_FP_REGS class contain all fp\nregisters.  Update all values for changed register numbering.\n(REGNO_REG_CLASS): Corresponding changes.\n(REG_CLASS_FROM_LETTER): Delete 'y'.\n(FP_REG_CLASS_P): No longer test HI_SNAKE_FP_REGS.\n(CLASS_MAX_NREGS): Delete special case for 1.1 fp registers.\n(FUNCTION_VALUE): Remove TARGET_SNAKE conditionals.\n(LIBCALL_VALUE): Likewise.\n(FUNCTION_ARG_REGNO_P): Likewise.\n(FUNCTION_VALUE_REGNO_P): Likewise.  Add registers 29 and 33.\n(FUNCTION_ARG): Remove TARGET_SNAKE conditionals.  Update register\nnumbers.\n(REGNO_OK_FOR_FP_P): Update register number.\n(REGISTER_NAMES): Delete special entries for 1.0 fp registers.\n(DBX_REGISTER_NUMBER): Likewise.\n\nFrom-SVN: r7412", "tree": {"sha": "53df8bb26fe5d9e938e9fc475c87fd92ce91d8d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53df8bb26fe5d9e938e9fc475c87fd92ce91d8d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a40ed31be5fb790bd5281404c0703039ee34de06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a40ed31be5fb790bd5281404c0703039ee34de06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a40ed31be5fb790bd5281404c0703039ee34de06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a40ed31be5fb790bd5281404c0703039ee34de06/comments", "author": null, "committer": null, "parents": [{"sha": "80225b66a6f57598b94ad854d8214592914c6062", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80225b66a6f57598b94ad854d8214592914c6062", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80225b66a6f57598b94ad854d8214592914c6062"}], "stats": {"total": 248, "additions": 97, "deletions": 151}, "files": [{"sha": "66814105a5bc27830f71cae17a0af2fb0a8e42d1", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 97, "deletions": 151, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a40ed31be5fb790bd5281404c0703039ee34de06/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a40ed31be5fb790bd5281404c0703039ee34de06/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=a40ed31be5fb790bd5281404c0703039ee34de06", "patch": "@@ -110,7 +110,7 @@ extern int target_flags;\n    compatable.  */\n #define DBX_BLOCKS_FUNCTION_RELATIVE 1\n \n-/* Likewise for linenos. \n+/* Likewise for linenos.\n \n    We make the first line stab special to avoid adding several\n    gross hacks to GAS.  */\n@@ -280,8 +280,8 @@ extern int target_flags;\n    has different fp units: define separate register sets for the 1.0\n    and 1.1 fp units. */\n \n-#define FIRST_PSEUDO_REGISTER 101  /* 32 + 12 1.0 regs + 56 1.1 regs + */\n-\t\t\t\t   /* 1 shift reg */\n+#define FIRST_PSEUDO_REGISTER 89  /* 32 general regs + 56 fp regs +\n+\t\t\t\t     + 1 shift reg */\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n@@ -325,10 +325,7 @@ extern int target_flags;\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 0, 1, 0, 0, 1, 0, \\\n-  /* 1.0 fp registers */ \\\n-  0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, \\\n-  /* 1.1 fp registers */ \\\n+  /* fp registers */\t  \\\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n@@ -349,10 +346,7 @@ extern int target_flags;\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n   0, 0, 0, 1, 1, 1, 1, 1, \\\n   1, 1, 1, 1, 1, 1, 1, 1, \\\n-  /* 1.0 fp registers */ \\\n-  1, 1, 1, 1, \\\n-  1, 1, 1, 1, 0, 0, 0, 0, \\\n-  /* 1.1 fp registers */ \\\n+  /* fp registers */\t  \\\n   1, 1, 1, 1, 1, 1, 1, 1, \\\n   1, 1, 1, 1, 1, 1, 1, 1, \\\n   0, 0, 0, 0, 0, 0, 0, 0, \\\n@@ -362,76 +356,39 @@ extern int target_flags;\n   1, 1, 1, 1, 1, 1, 1, 1, \\\n   1}\n \n-/* Make sure everything's fine if we *don't* have a given processor.\n-   This assumes that putting a register in fixed_regs will keep the\n-   compiler's mitts completely off it.  We don't bother to zero it out\n-   of register classes.   */\n-\n #define CONDITIONAL_REGISTER_USAGE \\\n {\t\t\t\t\t\t\\\n-  int i;\t\t\t\t\t\\\n-  HARD_REG_SET x;\t\t\t\t\\\n-  if (!TARGET_SNAKE)\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      COPY_HARD_REG_SET (x, reg_class_contents[(int)SNAKE_FP_REGS]);\\\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ ) \\\n-       if (TEST_HARD_REG_BIT (x, i)) \t\t\\\n-\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n-    }\t\t\t\t\t\t\\\n-  else if (TARGET_DISABLE_FPREGS)\t\t\\\n-    {\t\t\t\t\t\t\\\n-      COPY_HARD_REG_SET (x, reg_class_contents[(int)FP_REGS]);\\\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ ) \\\n-       if (TEST_HARD_REG_BIT (x, i)) \t\t\\\n-\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n-      COPY_HARD_REG_SET (x, reg_class_contents[(int)SNAKE_FP_REGS]);\\\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ ) \\\n-       if (TEST_HARD_REG_BIT (x, i)) \t\t\\\n-\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n-    }\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\\\n-    { \t\t\t\t\t\t\\\n-      COPY_HARD_REG_SET (x, reg_class_contents[(int)FP_REGS]); \\\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ ) \\\n-       if (TEST_HARD_REG_BIT (x, i)) \t\t\\\n-\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n-    } \t\t\t\t\t\t\\\n-  /* This makes cse think PIC_OFFSET_TABLE_REGNUM is not clobbered\n-     in calls.\t\t\t\t\t\\\n   if (flag_pic)\t\t\t\t\t\\\n-    fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1; */\t\\\n+    fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n }\n \n-/* Allocated the call used registers first.  This should minimize\n+/* Allocate the call used registers first.  This should minimize\n    the number of registers that need to be saved (as call used\n    registers will generally not be allocated across a call).\n \n    Experimentation has shown slightly better results by allocating\n    FP registers first.  */\n \n #define REG_ALLOC_ORDER \\\n-  /* 1.0 caller-saved fp regs.  */\t\\\n- {36, 37, 38, 39, 32, 33, 34, 35,\t\\\n-  /* 1.1 caller-saved fp regs.  */\t\\\n-  52, 53, 54, 55, 56, 57, 58, 59, \t\\\n-  80, 81, 82, 83, 84, 85, 86, 87,\t\\\n-  88, 89, 90, 91, 92, 93, 94, 95,\t\\\n-  96, 97, 98, 99,\t\t\t\\\n-  44, 45, 46, 47, 48, 49, 50, 51, \t\\\n+ {\t\t\t\t\t\\\n+  /* caller-saved fp regs.  */\t\t\\\n+  40, 41, 42, 43, 44, 45, 46, 47,\t\\\n+  68, 69, 70, 71, 72, 73, 74, 75,\t\\\n+  76, 77, 78, 79, 80, 81, 82, 83,\t\\\n+  84, 85, 86, 87,\t\t\t\\\n+  32, 33, 34, 35, 36, 37, 38, 39,\t\\\n   /* caller-saved general regs.  */\t\\\n   19, 20, 21, 22, 23, 24, 25, 26,\t\\\n   27, 28, 29, 31,  2,\t\t\t\\\n-  /* 1.0 callee-saved fp regs.  */\t\\\n-  40, 41, 42, 43,\t\t\t\\\n-  /* 1.1 callee-saved fp regs.  */\t\\\n-  60, 61, 62, 63, 64, 65, 66, 67, \t\\\n-  68, 69, 70, 71, 72, 73, 74, 75, \t\\\n-  76, 77, 78, 79, \t\t\t\\\n+  /* callee-saved fp regs.  */\t\t\\\n+  48, 49, 50, 51, 52, 53, 54, 55,\t\\\n+  56, 57, 58, 59, 60, 61, 62, 63,\t\\\n+  64, 65, 66, 67,\t\t\t\\\n   /* callee-saved general regs.  */\t\\\n    3,  4,  5,  6,  7,  8,  9, 10, \t\\\n   11, 12, 13, 14, 15, 16, 17, 18,\t\\\n   /* special registers.  */\t\t\\\n-   1, 30,  0, 100}\n+   1, 30,  0, 88}\n \n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n@@ -443,20 +400,21 @@ extern int target_flags;\n    The floating point registers are 64 bits wide. Snake fp regs are 32\n    bits wide */\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  (((REGNO) < 32 || (REGNO) >= 44)\t\\\n-   ? ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD) : 1)\n+   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    On the HP-PA, the cpu registers can hold any mode.  We\n    force this to be an even register is it cannot hold the full mode.  */\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   ((REGNO) == 0 ? (MODE) == CCmode || (MODE) == CCFPmode\t\t\\\n-   : (REGNO) < 32 ? ((GET_MODE_SIZE (MODE) <= 4) ? 1 : ((REGNO) & 1) == 0)\\\n-   : (REGNO) < 44 ? (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\\\n-\t\t     || (GET_MODE_SIZE (MODE) > 4\t\t\t\\\n-\t\t\t && GET_MODE_CLASS (MODE) == MODE_FLOAT)) \t\\\n-   : (GET_MODE_SIZE (MODE) > 4 ? ((REGNO) & 1) == 0\t\t\t\\\n-      : 1))\n+   : !TARGET_SNAKE && (REGNO) >= 32\t\t\t\t\t\\\n+     /* On 1.0 machines, all fp registers are 64 bits. */\t\t\\\n+     ? (((REGNO) & 1) == 0\t\t\t\t\t\t\\\n+     /* On 1.0 machines, don't allow large non-fp values in fp regs. */\t\\\n+\t&& (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t\\\n+\t    || GET_MODE_CLASS (MODE) == MODE_FLOAT))\t\t\t\\\n+   /* Make large values be in aligned registers. */\t\t\t\\\n+   : GET_MODE_SIZE (MODE) <= 4 || ((REGNO) & 1) == 0)\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n@@ -534,76 +492,70 @@ extern int target_flags;\n \n   /* The HP-PA has four kinds of registers: general regs, 1.0 fp regs,\n      1.1 fp regs, and the high 1.1 fp regs, to which the operands of\n-     fmpyadd and fmpysub are restricted.\n-\n-     FP_OR_SNAKE_FP_REGS is for reload_{in,out}di only and isn't used\n-     anywhere else.  */\n+     fmpyadd and fmpysub are restricted.  */\n \n enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n-  HI_SNAKE_FP_REGS, SNAKE_FP_REGS, GENERAL_OR_SNAKE_FP_REGS,\n-  FP_OR_SNAKE_FP_REGS, NON_SHIFT_REGS, SHIFT_REGS, ALL_REGS, LIM_REG_CLASSES};\n+  SNAKE_FP_REGS, GENERAL_OR_SNAKE_FP_REGS,\n+  NON_SHIFT_REGS, SHIFT_REGS, ALL_REGS, LIM_REG_CLASSES};\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n /* Give names of register classes as strings for dump file.   */\n \n #define REG_CLASS_NAMES \\\n-  { \"NO_REGS\", \"R1_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"GENERAL_OR_FP_REGS\",\\\n-    \"HI_SNAKE_FP_REGS\", \"SNAKE_FP_REGS\", \"GENERAL_OR_SNAKE_FP_REGS\",\\\n-    \"FP_OR_SNAKE_FP_REGS\", \"NON_SHIFT_REGS\", \"SHIFT_REGS\", \"ALL_REGS\"}\n+  {\"NO_REGS\", \"R1_REGS\", \"GENERAL_REGS\", \"FP_REGS\",\t\t\t\\\n+   \"GENERAL_OR_FP_REGS\", \"SNAKE_FP_REGS\", \"GENERAL_OR_SNAKE_FP_REGS\",\t\\\n+   \"NON_SHIFT_REGS\", \"SHIFT_REGS\", \"ALL_REGS\"}\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES. Register 0, the \"condition code\" register,\n    is in no class. */\n \n #define REG_CLASS_CONTENTS\t\\\n-{ {0, 0, 0, 0},\t\t\t/* NO_REGS */\t\t\\\n-  {0x2, 0, 0, 0},\t\t/* R1_REGS */\t\t\\\n-  {-2, 0, 0, 0},\t\t/* GENERAL_REGS */\t\\\n-  {0, 0xfff, 0, 0},\t\t/* FP_REGS */\t\t\\\n-  {-2, 0xfff, 0, 0},\t\t/* GENERAL_OR_FP_REGS */\\\n-  {0, 0, 0xfffffff0, 0xf},\t/* HI_SNAKE_FP_REGS */\t\\\n-  {0, 0xfffff000, ~0, 0xf},\t/* SNAKE_FP_REGS */\t\\\n-  {-2, 0xfffff000, ~0, 0xf},\t/* GENERAL_OR_SNAKE_FP_REGS */\\\n-  {0, ~0, ~0, 0xf},\t\t/* FP_OR_SNAKE_FP_REGS */\\\n-  {-2, ~0, ~0, ~0x10},\t\t/* NON_SHIFT_REGS */\t\\\n-  {0, 0, 0, 0x10},\t\t/* SHIFT_REGS */\t\\\n-  {-2, ~0, ~0, 0x1f}}\t\t/* ALL_REGS */\n+ {{0x00000000, 0x00000000, 0x00000000},\t/* NO_REGS */\t\t\t\\\n+  {0x00000002, 0x00000000, 0x00000000},\t/* R1_REGS */\t\t\t\\\n+  {0xfffffffe, 0x00000000, 0x00000000},\t/* GENERAL_REGS */\t\t\\\n+  {0x00000000, 0x00ffffff, 0x00000000},\t/* FP_REGS */\t\t\t\\\n+  {0xfffffffe, 0x00ffffff, 0x00000000},\t/* GENERAL_OR_FP_REGS */\t\\\n+  {0x00000000, 0xffffffff, 0x00ffffff},\t/* SNAKE_FP_REGS */\t\t\\\n+  {0xfffffffe, 0xffffffff, 0x00ffffff},\t/* GENERAL_OR_SNAKE_FP_REGS */\t\\\n+  {0xfffffffe, 0xffffffff, 0x00ffffff},\t/* NON_SHIFT_REGS */\t\t\\\n+  {0x00000000, 0x00000000, 0x01000000},\t/* SHIFT_REGS */\t\t\\\n+  {0xfffffffe, 0xffffffff, 0x01ffffff}}\t/* ALL_REGS */\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n \n-#define REGNO_REG_CLASS(REGNO)\t\t\\\n-  ((REGNO) == 0 ? NO_REGS \t\t\\\n-   : (REGNO) == 1 ? R1_REGS\t\t\\\n-   : (REGNO) < 32 ? GENERAL_REGS\t\\\n-   : (REGNO) < 44 ? FP_REGS\t\t\\\n-   : (REGNO) < 68 ? SNAKE_FP_REGS\t\\\n-   : (REGNO) < 100 ? HI_SNAKE_FP_REGS\t\\\n+#define REGNO_REG_CLASS(REGNO)\t\t\t\t\t\t\\\n+  ((REGNO) == 0 ? NO_REGS \t\t\t\t\t\t\\\n+   : (REGNO) == 1 ? R1_REGS\t\t\t\t\t\t\\\n+   : (REGNO) < 32 ? GENERAL_REGS\t\t\t\t\t\\\n+   : (REGNO) < 44 && !TARGET_SNAKE ? FP_REGS\t\t\t\t\\\n+   : (REGNO) < 88 && TARGET_SNAKE ? SNAKE_FP_REGS\t\t\t\\\n    : SHIFT_REGS)\n \n /* The class value for index registers, and the one for base regs.  */\n #define INDEX_REG_CLASS GENERAL_REGS\n #define BASE_REG_CLASS GENERAL_REGS\n \n #define FP_REG_CLASS_P(CLASS) \\\n-  (CLASS == FP_REGS || CLASS == SNAKE_FP_REGS || CLASS == HI_SNAKE_FP_REGS)\n+  (CLASS == FP_REGS || CLASS == SNAKE_FP_REGS)\n \n /* Get reg_class from a letter such as appears in the machine description.\n    Note 'Z' is not the same as 'r' since SHIFT_REGS is not part of\n    GENERAL_REGS.  */\n \n+/* OOPS Merge f and x? */\n #define REG_CLASS_FROM_LETTER(C) \\\n   ((C) == 'f' ? (!TARGET_SNAKE ? FP_REGS : NO_REGS) :\t\t\\\n-   ((C) == 'x' ? (TARGET_SNAKE ? SNAKE_FP_REGS : NO_REGS) :\t\\\n-    ((C) == 'y' ? (TARGET_SNAKE ? HI_SNAKE_FP_REGS : NO_REGS) :\t\\\n-     ((C) == 'q' ? SHIFT_REGS :\t\t\t\t\t\\\n-      ((C) == 'a' ? R1_REGS :\t\t\t\t\t\\\n-       ((C) == 'z' ? FP_OR_SNAKE_FP_REGS :\t\t\t\\\n-        ((C) == 'Z' ? ALL_REGS : NO_REGS)))))))\n+   (C) == 'x' ? (TARGET_SNAKE ? SNAKE_FP_REGS : NO_REGS) :\t\\\n+   (C) == 'q' ? SHIFT_REGS :\t\t\t\t\t\\\n+   (C) == 'a' ? R1_REGS :\t\t\t\t\t\\\n+   (C) == 'z' ? SNAKE_FP_REGS :\t\t\t\t\t\\\n+   (C) == 'Z' ? ALL_REGS : NO_REGS)\n \n /* The letters I, J, K, L and M in a register constraint string\n    can be used to stand for particular ranges of immediate operands.\n@@ -657,8 +609,7 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n /* On the PA it is not possible to directly move data between\n    GENERAL_REGS and FP_REGS.  */\n #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)  \\\n-  ((FP_REG_CLASS_P (CLASS1) && ! FP_REG_CLASS_P (CLASS2))\t\\\n-   || (! FP_REG_CLASS_P (CLASS1) && FP_REG_CLASS_P (CLASS2)))\n+  (FP_REG_CLASS_P (CLASS1) != FP_REG_CLASS_P (CLASS2))\n \n /* Return the stack location to use for secondary memory needed reloads.  */\n #define SECONDARY_MEMORY_NEEDED_RTX(MODE) \\\n@@ -667,7 +618,7 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n-  ((CLASS) == FP_REGS ? 1 : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -754,26 +705,24 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n   gen_rtx (REG, TYPE_MODE (VALTYPE), ((TYPE_MODE (VALTYPE) == SFmode ||\t\\\n \t\t\t\t       TYPE_MODE (VALTYPE) == DFmode) ? \\\n-\t\t\t\t      (TARGET_SNAKE ? 44 : 32) : 28))\n+\t\t\t\t      32 : 28))\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n #define LIBCALL_VALUE(MODE) \\\n-  gen_rtx (REG, MODE, (MODE == SFmode || MODE == DFmode ?\\\n-\t\t       (TARGET_SNAKE ? 44 : 32) : 28))\n+  gen_rtx (REG, MODE, ((MODE) == SFmode || (MODE) == DFmode ? 32 : 28))\n \n /* 1 if N is a possible register number for a function value\n    as seen by the caller.  */\n \n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == 28 || (N) == (TARGET_SNAKE ? 44 : 32))\n+#define FUNCTION_VALUE_REGNO_P(N) \\\n+  ((N) == 28 || (N) == 29 || (N) == 32 || (N) == 33)\n \n /* 1 if N is a possible register number for function argument passing.  */\n \n-#define FUNCTION_ARG_REGNO_P(N)\t\t\t\t\\\n-  (((N) >= 23 && (N) <= 26) \t\t\t\t\\\n-   || ((N) >= 32 && (N) <= 35 && ! TARGET_SNAKE)\t\\\n-   || ((N) >= 44 && (N) <= 51 && TARGET_SNAKE))\n+#define FUNCTION_ARG_REGNO_P(N) \\\n+  (((N) >= 23 && (N) <= 26) || ((N) >= 32 && (N) <= 39))\n \f\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n@@ -873,7 +822,7 @@ struct hppa_args {int words, nargs_prototype; };\n   FYI: The portable parameter passing conventions are almost exactly like\n   the standard parameter passing conventions on the RS6000.  That's why\n   you'll see lots of similar code in rs6000.h.  */\n-  \n+\n #define FUNCTION_ARG_PADDING(MODE, TYPE) function_arg_padding ((MODE), (TYPE))\n \n /* Do not expect to understand this without reading it several times.  I'm\n@@ -887,28 +836,20 @@ struct hppa_args {int words, nargs_prototype; };\n \t\t (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1\t\t\\\n \t\t  ? (((!current_call_is_indirect || TARGET_PORTABLE_RUNTIME) \\\n \t\t      && (MODE) == DFmode)\t\t\t\t\\\n-\t\t     ? ((CUM).words\t\t\t\t\t\\\n-\t\t\t? (TARGET_SNAKE ? 50 : 35) \t\t\t\\\n-\t\t\t: (TARGET_SNAKE ? 46 : 33))\t\t\t\\\n+\t\t     ? ((CUM).words ? 38 : 34)\t\t\t\t\\\n \t\t     : ((CUM).words ? 23 : 25))\t\t\t\t\\\n \t\t  : (((!current_call_is_indirect || TARGET_PORTABLE_RUNTIME) \\\n \t\t      && (MODE) == SFmode)\t\t\t\t\\\n-\t\t     ? (TARGET_SNAKE\t\t\t\t\t\\\n-\t\t\t? 44 + 2 * (CUM).words\t\t\t\t\\\n-\t\t\t: 32  + (CUM).words)\t\t\t\t\\\n+\t\t     ? (32 + 2 * (CUM).words)\t\t\t\t\\\n \t\t     : (27 - (CUM).words - FUNCTION_ARG_SIZE ((MODE),\t\\\n \t\t\t\t\t\t\t      (TYPE))))))\\\n    /* We are calling a non-prototyped function with floating point\t\\\n       arguments using the portable conventions.  */\t\t\t\\\n    : gen_rtx (EXPR_LIST, VOIDmode,\t\t\t\t\t\\\n \t      gen_rtx (REG, (MODE),\t\t\t\t\t\\\n \t\t       (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1\t\t\\\n-\t\t\t? ((CUM).words\t\t\t\t\t\\\n-\t\t\t   ? (TARGET_SNAKE ? 50 : 35)\t\t\t\\\n-\t\t\t   : (TARGET_SNAKE ? 46 : 33))\t\t\t\\\n-\t\t\t: (TARGET_SNAKE\t\t\t\t\t\\\n-\t\t\t   ? 44 + 2 * (CUM).words\t\t\t\\\n-\t\t\t   : 32 + (CUM).words))),\t\t\t\\\n+\t\t\t? ((CUM).words ? 38 : 34)\t\t\t\\\n+\t\t\t: (32 + 2 * (CUM).words))),\t\t\t\\\n \t      gen_rtx (REG, (MODE),\t\t\t\t\t\\\n \t\t       (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1\t\t\\\n \t\t\t? ((CUM).words ? 23 : 25)\t\t\t\\\n@@ -1181,8 +1122,8 @@ extern union tree_node *current_function_decl;\n #define REGNO_OK_FOR_BASE_P(REGNO)  \\\n   ((REGNO) && ((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32))\n #define REGNO_OK_FOR_FP_P(REGNO) \\\n-  (((REGNO) >= 32 && (REGNO) <= 99)\\\n-   || (reg_renumber[REGNO] >= 32 && reg_renumber[REGNO] <= 99))\n+  (((REGNO) >= 32 && (REGNO) <= 87)\\\n+   || (reg_renumber[REGNO] >= 32 && reg_renumber[REGNO] <= 87))\n \n /* Now macros that check whether X is a register and also,\n    strictly, whether it is in a specified class.\n@@ -1732,35 +1673,40 @@ readonly_data ()\t\t\t\t\t\t\t\\\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n \n #define REGISTER_NAMES \\\n-{\"0\", \"%r1\", \"%r2\", \"%r3\", \"%r4\", \"%r5\", \"%r6\", \"%r7\",\t\t\t\\\n- \"%r8\", \"%r9\", \"%r10\", \"%r11\", \"%r12\", \"%r13\", \"%r14\", \"%r15\",\t\t\\\n- \"%r16\", \"%r17\", \"%r18\", \"%r19\", \"%r20\", \"%r21\", \"%r22\", \"%r23\",\t\\\n- \"%r24\", \"%r25\", \"%r26\", \"%r27\", \"%r28\", \"%r29\", \"%r30\", \"%r31\",\t\\\n- \"%fr4\", \"%fr5\", \"%fr6\", \"%fr7\",\t\\\n- \"%fr8\", \"%fr9\", \"%fr10\", \"%fr11\", \"%fr12\", \"%fr13\", \"%fr14\", \"%fr15\",\t\\\n- \"%fr4\", \"%fr4R\", \"%fr5\", \"%fr5R\", \"%fr6\", \"%fr6R\", \"%fr7\", \"%fr7R\",\t\\\n- \"%fr8\", \"%fr8R\", \"%fr9\", \"%fr9R\", \"%fr10\", \"%fr10R\", \"%fr11\", \"%fr11R\",\\\n- \"%fr12\", \"%fr12R\", \"%fr13\", \"%fr13R\", \"%fr14\", \"%fr14R\", \"%fr15\", \"%fr15R\",\\\n- \"%fr16\", \"%fr16R\", \"%fr17\", \"%fr17R\", \"%fr18\", \"%fr18R\", \"%fr19\", \"%fr19R\",\\\n- \"%fr20\", \"%fr20R\", \"%fr21\", \"%fr21R\", \"%fr22\", \"%fr22R\", \"%fr23\", \"%fr23R\",\\\n- \"%fr24\", \"%fr24R\", \"%fr25\", \"%fr25R\", \"%fr26\", \"%fr26R\", \"%fr27\", \"%fr27R\",\\\n- \"%fr28\", \"%fr28R\", \"%fr29\", \"%fr29R\", \"%fr30\", \"%fr30R\", \"%fr31\", \"%fr31R\",\\\n+{\"%r0\",   \"%r1\",    \"%r2\",   \"%r3\",    \"%r4\",   \"%r5\",    \"%r6\",   \"%r7\",    \\\n+ \"%r8\",   \"%r9\",    \"%r10\",  \"%r11\",   \"%r12\",  \"%r13\",   \"%r14\",  \"%r15\",   \\\n+ \"%r16\",  \"%r17\",   \"%r18\",  \"%r19\",   \"%r20\",  \"%r21\",   \"%r22\",  \"%r23\",   \\\n+ \"%r24\",  \"%r25\",   \"%r26\",  \"%r27\",   \"%r28\",  \"%r29\",   \"%r30\",  \"%r31\",   \\\n+ \"%fr4\",  \"%fr4R\",  \"%fr5\",  \"%fr5R\",  \"%fr6\",  \"%fr6R\",  \"%fr7\",  \"%fr7R\",  \\\n+ \"%fr8\",  \"%fr8R\",  \"%fr9\",  \"%fr9R\",  \"%fr10\", \"%fr10R\", \"%fr11\", \"%fr11R\", \\\n+ \"%fr12\", \"%fr12R\", \"%fr13\", \"%fr13R\", \"%fr14\", \"%fr14R\", \"%fr15\", \"%fr15R\", \\\n+ \"%fr16\", \"%fr16R\", \"%fr17\", \"%fr17R\", \"%fr18\", \"%fr18R\", \"%fr19\", \"%fr19R\", \\\n+ \"%fr20\", \"%fr20R\", \"%fr21\", \"%fr21R\", \"%fr22\", \"%fr22R\", \"%fr23\", \"%fr23R\", \\\n+ \"%fr24\", \"%fr24R\", \"%fr25\", \"%fr25R\", \"%fr26\", \"%fr26R\", \"%fr27\", \"%fr27R\", \\\n+ \"%fr28\", \"%fr28R\", \"%fr29\", \"%fr29R\", \"%fr30\", \"%fr30R\", \"%fr31\", \"%fr31R\", \\\n  \"SAR\"}\n \n+#define ADDITIONAL_REGISTER_NAMES \\\n+{{\"%fr4L\",32}, {\"%fr5L\",34}, {\"%fr6L\",36}, {\"%fr7L\",38},\t\t\\\n+ {\"%fr8L\",40}, {\"%fr9L\",42}, {\"%fr10L\",44}, {\"%fr11L\",46},\t\t\\\n+ {\"%fr12L\",48}, {\"%fr13L\",50}, {\"%fr14L\",52}, {\"%fr15L\",54},\t\t\\\n+ {\"%fr16L\",56}, {\"%fr17L\",58}, {\"%fr18L\",60}, {\"%fr19L\",62},\t\t\\\n+ {\"%fr20L\",64}, {\"%fr21L\",66}, {\"%fr22L\",68}, {\"%fr23L\",70},\t\t\\\n+ {\"%fr24L\",72}, {\"%fr25L\",74}, {\"%fr26L\",76}, {\"%fr27L\",78},\t\t\\\n+ {\"%fr28L\",80}, {\"%fr29L\",82}, {\"%fr30L\",84}, {\"%fr31R\",86},\t\t\\\n+ {\"%cr11\",88}}\n+\n /* How to renumber registers for dbx and gdb.\n \n    Registers 0  - 31 remain unchanged.\n \n-   Registers 32 - 43 are mapped to 72 - 94 (even numbers only)\n-\n-   Registers 44 - 100 are mapped to 72 - 128 \n+   Registers 32 - 87 are mapped to 72 - 127\n \n-   Register 101 is mapped to 32.  */\n+   Register 88 is mapped to 32.  */\n \n #define DBX_REGISTER_NUMBER(REGNO) \\\n-  ((REGNO) <= 31 ? (REGNO) : \t\t\t\t\t\\\n-   ((REGNO) > 31 && (REGNO) <= 43 ? ((REGNO) - 32) * 2 + 72 : \t\\\n-    ((REGNO) > 43 && (REGNO) <= 100 ? (REGNO) + 28 : 32)))\n+  ((REGNO) <= 31 ? (REGNO) :\t\t\t\t\t\t\\\n+   ((REGNO) > 31 && (REGNO) <= 87 ? (REGNO) + 40 : 32))\n \n /* This is how to output the definition of a user-level label named NAME,\n    such as the label on a static function or variable NAME.  */"}]}