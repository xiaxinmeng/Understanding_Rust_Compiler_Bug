{"sha": "e59512633b9f456412454edb22b5333c70c3314f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU5NTEyNjMzYjlmNDU2NDEyNDU0ZWRiMjJiNTMzM2M3MGMzMzE0Zg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "2000-04-11T03:08:01Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-04-11T03:08:01Z"}, "message": "Fix compile time warnings for arm-pe target.\n\nFrom-SVN: r33069", "tree": {"sha": "f34f9bff35475104e3764c4869c6de919daa5aa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f34f9bff35475104e3764c4869c6de919daa5aa7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e59512633b9f456412454edb22b5333c70c3314f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e59512633b9f456412454edb22b5333c70c3314f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e59512633b9f456412454edb22b5333c70c3314f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e59512633b9f456412454edb22b5333c70c3314f/comments", "author": null, "committer": null, "parents": [{"sha": "dc4a31ee33b499654a503af215415fc94ace02cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc4a31ee33b499654a503af215415fc94ace02cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc4a31ee33b499654a503af215415fc94ace02cf"}], "stats": {"total": 140, "additions": 86, "deletions": 54}, "files": [{"sha": "cea1068cffb5b1bff40635e0ccb069e30bb4d32e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59512633b9f456412454edb22b5333c70c3314f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59512633b9f456412454edb22b5333c70c3314f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e59512633b9f456412454edb22b5333c70c3314f", "patch": "@@ -1,3 +1,26 @@\n+2000-04-10  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/arm.h (HOST_INT): New macro: Declare a HOST_WIDE_INT\n+\tinteger.\n+\t(HOST_UINT): New macro: Declare an unsigned HOST_WIDE_INT\n+\tinteger.\n+\t(ARM_SIGN_EXTEND): Use HOST_UINT.\n+\t(STRIP_NAME_ENCODING): Prevent warnings about redefinitions.\n+\t(ASM_OUTPUT_LABELREF): Prevent warnings about redefinitions.\n+\t(INCOMING_RETURN_ADDR_RTX): Only define if Dwarf2 is supported.\n+\t(DWARF_FRAME_RETURN_COLUMN): Only define if Dwarf2 is supported.\n+\n+\t* config/arm/arm.c: (const_ok_for_arm): Use HOST_UINT.\n+\t(arm_gen_constant): Use HOST_UINT.\n+\t(arm_canonicalize_constant): Use HOST_UINT.\n+\t(arm_reload_in_hi): Use HOST_UINT.\n+\t(arm_reload_out_hi): Use HOST_UINT.\n+\t(output_multi_immediate): Use HOST_UINT.\n+\t(int_log2): Use HOST_UINT.\n+\t(arm_poke_function_name): Use HOST_UINT.\n+\t(arm_output_epilogue): Use arm_volatile_func().\n+\t(output_thumb_prologue): Use arm_strip_name_encoding().\n+\t\n Mon Apr 10 15:40:59 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* sbitmap.c (sbitmap_a_subset_b_p): Rework loop to avoid potential"}, {"sha": "9311ba488361eb91ea5a33b73cbcb9f9319ed13b", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59512633b9f456412454edb22b5333c70c3314f/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59512633b9f456412454edb22b5333c70c3314f/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e59512633b9f456412454edb22b5333c70c3314f", "patch": "@@ -722,14 +722,14 @@ int\n const_ok_for_arm (i)\n      HOST_WIDE_INT i;\n {\n-  unsigned HOST_WIDE_INT mask = ~(unsigned HOST_WIDE_INT)0xFF;\n+  unsigned HOST_WIDE_INT mask = ~ HOST_UINT (0xFF);\n \n   /* For machines with >32 bit HOST_WIDE_INT, the bits above bit 31 must \n      be all zero, or all one.  */\n-  if ((i & ~(unsigned HOST_WIDE_INT) 0xffffffff) != 0\n-      && ((i & ~(unsigned HOST_WIDE_INT) 0xffffffff) \n-\t  != ((~(unsigned HOST_WIDE_INT) 0)\n-\t      & ~(unsigned HOST_WIDE_INT) 0xffffffff)))\n+  if ((i & ~ HOST_UINT (0xffffffff)) != 0\n+      && ((i & ~ HOST_UINT (0xffffffff)) \n+\t  != ((~ HOST_UINT (0))\n+\t      & ~ HOST_UINT (0xffffffff))))\n     return FALSE;\n   \n   /* Fast return for 0 and powers of 2 */\n@@ -738,12 +738,12 @@ const_ok_for_arm (i)\n \n   do\n     {\n-      if ((i & mask & (unsigned HOST_WIDE_INT) 0xffffffff) == 0)\n+      if ((i & mask & HOST_UINT (0xffffffff)) == 0)\n         return TRUE;\n       mask =\n-\t  (mask << 2) | ((mask & (unsigned HOST_WIDE_INT) 0xffffffff)\n-\t\t\t >> (32 - 2)) | ~((unsigned HOST_WIDE_INT) 0xffffffff);\n-    } while (mask != ~(unsigned HOST_WIDE_INT) 0xFF);\n+\t  (mask << 2) | ((mask & HOST_UINT (0xffffffff))\n+\t\t\t >> (32 - 2)) | ~(HOST_UINT (0xffffffff));\n+    } while (mask != ~ HOST_UINT (0xFF));\n \n   return FALSE;\n }\n@@ -863,7 +863,7 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n   int set_zero_bit_copies = 0;\n   int insns = 0;\n   unsigned HOST_WIDE_INT temp1, temp2;\n-  unsigned HOST_WIDE_INT remainder = val & (unsigned HOST_WIDE_INT)0xffffffff;\n+  unsigned HOST_WIDE_INT remainder = val & HOST_UINT (0xffffffff);\n \n   /* Find out which operations are safe for a given CODE.  Also do a quick\n      check for degenerate cases; these can occur when DImode operations\n@@ -882,7 +882,7 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n       break;\n \n     case IOR:\n-      if (remainder == (unsigned HOST_WIDE_INT)0xffffffff)\n+      if (remainder == HOST_UINT (0xffffffff))\n \t{\n \t  if (generate)\n \t    emit_insn (gen_rtx_SET (VOIDmode, target,\n@@ -906,7 +906,7 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n \t    emit_insn (gen_rtx_SET (VOIDmode, target, const0_rtx));\n \t  return 1;\n \t}\n-      if (remainder == (unsigned HOST_WIDE_INT)0xffffffff)\n+      if (remainder == HOST_UINT (0xffffffff))\n \t{\n \t  if (reload_completed && rtx_equal_p (target, source))\n \t    return 0;\n@@ -926,7 +926,7 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n \t    emit_insn (gen_rtx_SET (VOIDmode, target, source));\n \t  return 1;\n \t}\n-      if (remainder == (unsigned HOST_WIDE_INT)0xffffffff)\n+      if (remainder == HOST_UINT (0xffffffff))\n \t{\n \t  if (generate)\n \t    emit_insn (gen_rtx_SET (VOIDmode, target,\n@@ -1054,16 +1054,16 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n \t word.  We only look for the simplest cases, to do more would cost\n \t too much.  Be careful, however, not to generate this when the\n \t alternative would take fewer insns.  */\n-      if (val & (unsigned HOST_WIDE_INT)0xffff0000)\n+      if (val & HOST_UINT (0xffff0000))\n \t{\n-\t  temp1 = remainder & (unsigned HOST_WIDE_INT)0xffff0000;\n+\t  temp1 = remainder & HOST_UINT (0xffff0000);\n \t  temp2 = remainder & 0x0000ffff;\n \n \t  /* Overlaps outside this range are best done using other methods.  */\n \t  for (i = 9; i < 24; i++)\n \t    {\n \t      if ((((temp2 | (temp2 << i))\n-\t\t    & (unsigned HOST_WIDE_INT)0xffffffff) == remainder)\n+\t\t    & HOST_UINT (0xffffffff)) == remainder)\n \t\t  && ! const_ok_for_arm (temp2))\n \t\t{\n \t\t  rtx new_src = (subtargets\n@@ -1201,11 +1201,11 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n       /* See if two shifts will do 2 or more insn's worth of work.  */\n       if (clear_sign_bit_copies >= 16 && clear_sign_bit_copies < 24)\n \t{\n-\t  HOST_WIDE_INT shift_mask = ((((unsigned HOST_WIDE_INT)0xffffffff)\n+\t  HOST_WIDE_INT shift_mask = (((HOST_UINT (0xffffffff))\n \t\t\t\t       << (32 - clear_sign_bit_copies))\n-\t\t\t\t      & (unsigned HOST_WIDE_INT)0xffffffff);\n+\t\t\t\t      & HOST_UINT (0xffffffff));\n \n-\t  if ((remainder | shift_mask) != (unsigned HOST_WIDE_INT)0xffffffff)\n+\t  if ((remainder | shift_mask) != HOST_UINT (0xffffffff))\n \t    {\n \t      if (generate)\n \t\t{\n@@ -1238,7 +1238,7 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n \t{\n \t  HOST_WIDE_INT shift_mask = (1 << clear_zero_bit_copies) - 1;\n \t  \n-\t  if ((remainder | shift_mask) != (unsigned HOST_WIDE_INT)0xffffffff)\n+\t  if ((remainder | shift_mask) != HOST_UINT (0xffffffff))\n \t    {\n \t      if (generate)\n \t\t{\n@@ -1280,9 +1280,9 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n       num_bits_set++;\n \n   if (code == AND || (can_invert && num_bits_set > 16))\n-    remainder = (~remainder) & (unsigned HOST_WIDE_INT)0xffffffff;\n+    remainder = (~remainder) & HOST_UINT (0xffffffff);\n   else if (code == PLUS && num_bits_set > 16)\n-    remainder = (-remainder) & (unsigned HOST_WIDE_INT)0xffffffff;\n+    remainder = (-remainder) & HOST_UINT (0xffffffff);\n   else\n     {\n       can_invert = 0;\n@@ -1406,7 +1406,7 @@ arm_canonicalize_comparison (code, op1)\n \n     case GT:\n     case LE:\n-      if (i != ((((unsigned HOST_WIDE_INT) 1) << (HOST_BITS_PER_WIDE_INT - 1))\n+      if (i != (((HOST_UINT (1)) << (HOST_BITS_PER_WIDE_INT - 1))\n \t\t- 1)\n \t  && (const_ok_for_arm (i+1) || const_ok_for_arm (- (i+1))))\n \t{\n@@ -1417,7 +1417,7 @@ arm_canonicalize_comparison (code, op1)\n \n     case GE:\n     case LT:\n-      if (i != (((unsigned HOST_WIDE_INT) 1) << (HOST_BITS_PER_WIDE_INT - 1))\n+      if (i != ((HOST_UINT (1)) << (HOST_BITS_PER_WIDE_INT - 1))\n \t  && (const_ok_for_arm (i-1) || const_ok_for_arm (- (i-1))))\n \t{\n \t  *op1 = GEN_INT (i-1);\n@@ -1427,7 +1427,7 @@ arm_canonicalize_comparison (code, op1)\n \n     case GTU:\n     case LEU:\n-      if (i != ~((unsigned HOST_WIDE_INT) 0)\n+      if (i != ~ (HOST_UINT (0))\n \t  && (const_ok_for_arm (i+1) || const_ok_for_arm (- (i+1))))\n \t{\n \t  *op1 = GEN_INT (i + 1);\n@@ -2306,7 +2306,7 @@ arm_rtx_costs (x, code, outer)\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n \t{\n \t  unsigned HOST_WIDE_INT i = (INTVAL (XEXP (x, 1))\n-\t\t\t\t      & (unsigned HOST_WIDE_INT) 0xffffffff);\n+\t\t\t\t      & HOST_UINT (0xffffffff));\n \t  int add_cost = const_ok_for_arm (i) ? 4 : 8;\n \t  int j;\n \t  \n@@ -4360,9 +4360,9 @@ arm_reload_in_hi (operands)\n       if (lo == 4095)\n \tlo &= 0x7ff;\n \n-      hi = ((((offset - lo) & (HOST_WIDE_INT) 0xffffffff)\n-\t     ^ (HOST_WIDE_INT) 0x80000000)\n-\t    - (HOST_WIDE_INT) 0x80000000);\n+      hi = ((((offset - lo) & HOST_INT (0xffffffff))\n+\t     ^ HOST_INT (0x80000000))\n+\t    -  HOST_INT (0x80000000));\n \n       if (hi + lo != offset)\n \tabort ();\n@@ -4506,9 +4506,9 @@ arm_reload_out_hi (operands)\n       if (lo == 4095)\n \tlo &= 0x7ff;\n \n-      hi = ((((offset - lo) & (HOST_WIDE_INT) 0xffffffff)\n-\t     ^ (HOST_WIDE_INT) 0x80000000)\n-\t    - (HOST_WIDE_INT) 0x80000000);\n+      hi = ((((offset - lo) & HOST_INT (0xffffffff))\n+\t     ^ HOST_INT (0x80000000))\n+\t    -  HOST_INT (0x80000000));\n \n       if (hi + lo != offset)\n \tabort ();\n@@ -6179,8 +6179,7 @@ output_mov_immediate (operands)\n       n_ones++;\n \n   if (n_ones > 16)  /* Shorter to use MVN with BIC in this case.  */\n-    output_multi_immediate (operands, \"mvn%?\\t%0, %1\", \"bic%?\\t%0, %0, %1\", 1,\n-\t\t\t    ~n);\n+    output_multi_immediate (operands, \"mvn%?\\t%0, %1\", \"bic%?\\t%0, %0, %1\", 1, ~n);\n   else\n     output_multi_immediate (operands, \"mov%?\\t%0, %1\", \"orr%?\\t%0, %0, %1\", 1, n);\n \n@@ -6227,7 +6226,7 @@ output_multi_immediate (operands, instr1, instr2, immed_op, n)\n      HOST_WIDE_INT n;\n {\n #if HOST_BITS_PER_WIDE_INT > 32\n-  n &= (unsigned HOST_WIDE_INT)0xffffffff;\n+  n &= HOST_UINT (0xffffffff);\n #endif\n \n   if (n == 0)\n@@ -6375,7 +6374,7 @@ int_log2 (power)\n {\n   HOST_WIDE_INT shift = 0;\n \n-  while (((((HOST_WIDE_INT) 1) << shift) & power) == 0)\n+  while ((((HOST_INT (1)) << shift) & power) == 0)\n     {\n       if (shift > 31)\n \tabort ();\n@@ -6823,7 +6822,7 @@ arm_poke_function_name (stream, name)\n   \n   ASM_OUTPUT_ASCII (stream, name, length);\n   ASM_OUTPUT_ALIGN (stream, 2);\n-  x = GEN_INT (((unsigned HOST_WIDE_INT)0xff000000) + alignlength);\n+  x = GEN_INT (HOST_UINT(0xff000000) + alignlength);\n   ASM_OUTPUT_INT (stream, x);\n }\n \n@@ -6925,8 +6924,7 @@ arm_output_epilogue ()\n   int frame_size = get_frame_size ();\n   rtx eh_ofs = cfun->machine->eh_epilogue_sp_ofs;\n   FILE * f = asm_out_file;\n-  int volatile_func = (optimize > 0\n-\t\t       && TREE_THIS_VOLATILE (current_function_decl));\n+  int volatile_func = arm_volatile_func ();\n   int return_regnum;\n \n   if (use_return_insn (FALSE) && return_used_this_function)\n@@ -7493,7 +7491,6 @@ arm_expand_prologue ()\n   if (profile_flag || profile_block_flag || TARGET_NO_SCHED_PRO)\n     emit_insn (gen_blockage ());\n }\n-  \n \f\n /* If CODE is 'd', then the X is a condition operand and the instruction\n    should only be executed if the condition is true.\n@@ -9210,7 +9207,7 @@ output_thumb_prologue (f)\n       asm_fprintf (f, \"\\t.code\\t16\\n\");\n #ifdef ARM_PE\n       if (arm_dllexport_name_p (name))\n-        name = ARM_STRIP_NAME_ENCODING (name);\n+        name = arm_strip_name_encoding (name);\n #endif        \n       asm_fprintf (f, \"\\t.globl %s%U%s\\n\", STUB_NAME, name);\n       asm_fprintf (f, \"\\t.thumb_func\\n\");"}, {"sha": "6810cdde8243cf2adf88989b988818bd71e905c7", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e59512633b9f456412454edb22b5333c70c3314f/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e59512633b9f456412454edb22b5333c70c3314f/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=e59512633b9f456412454edb22b5333c70c3314f", "patch": "@@ -457,11 +457,11 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n   {\"callee-super-interworking\",\t    THUMB_FLAG_CALLEE_SUPER_INTERWORKING, \\\n      \"Thumb: Assume non-static functions may be called from ARM code\" },  \\\n   {\"no-callee-super-interworking\", -THUMB_FLAG_CALLEE_SUPER_INTERWORKING, \\\n-   \"\"},\t\t\t\t\t\t\t\t\t  \\\n+     \"\" },\t\t\t\t\t\t\t\t  \\\n   {\"caller-super-interworking\",\t    THUMB_FLAG_CALLER_SUPER_INTERWORKING, \\\n      \"Thumb: Assume function pointers may go to non-Thumb aware code\" },  \\\n   {\"no-caller-super-interworking\", -THUMB_FLAG_CALLER_SUPER_INTERWORKING, \\\n-   \"\" },\t\t\t\t\t\t\t\t  \\\n+     \"\" },\t\t\t\t\t\t\t\t  \\\n   SUBTARGET_SWITCHES\t\t\t\t\t\t\t  \\\n   {\"\",\t\t\t\tTARGET_DEFAULT, \"\" }\t\t\t  \\\n }\n@@ -1217,9 +1217,9 @@ enum reg_class\n \t  else\t\t\t\t\t\t\t\t   \\\n \t    break;\t\t\t\t\t\t\t   \\\n \t\t\t\t\t\t\t\t\t   \\\n-\t  high = ((((val - low) & (unsigned long)0xffffffff)\t\t   \\\n-\t\t   ^ (unsigned long)0x80000000)\t\t\t\t   \\\n-\t\t  - (unsigned long)0x80000000);\t\t\t\t   \\\n+\t  high = ((((val - low) & HOST_UINT (0xffffffff))\t\t   \\\n+\t\t   ^ HOST_UINT (0x80000000))\t\t\t\t   \\\n+\t\t  - HOST_UINT (0x80000000));\t\t\t\t   \\\n \t  /* Check for overflow or zero */\t\t\t\t   \\\n \t  if (low == 0 || high == 0 || (high + low != val))\t\t   \\\n \t    break;\t\t\t\t\t\t\t   \\\n@@ -1840,11 +1840,13 @@ typedef struct\n \n /* This has to be handled by a function because more than part of the\n    ARM backend uses funciton name prefixes to encode attributes.  */\n+#undef  STRIP_NAME_ENCODING\n #define STRIP_NAME_ENCODING(VAR, SYMBOL_NAME)\t\\\n   (VAR) = arm_strip_name_encoding (SYMBOL_NAME)\n \n /* This is how to output a reference to a user-level label named NAME.\n    `assemble_name' uses this.  */\n+#undef  ASM_OUTPUT_LABELREF\n #define ASM_OUTPUT_LABELREF(FILE, NAME)\t\t\\\n   fprintf (FILE, \"%s%s\", USER_LABEL_PREFIX, arm_strip_name_encoding (NAME))\n \n@@ -2628,17 +2630,26 @@ extern int making_const_table;\n    || (TARGET_ARM   && (CODE == '?'))\t\t\\\n    || (TARGET_THUMB && (CODE == '_')))\n \n-     \n /* Output an operand of an instruction.  */\n #define PRINT_OPERAND(STREAM, X, CODE)  \\\n   arm_print_operand (STREAM, X, CODE)\n \n-#define ARM_SIGN_EXTEND(x)  ((HOST_WIDE_INT)\t\t\\\n-  (HOST_BITS_PER_WIDE_INT <= 32 ? (x)\t\t\t\\\n-   : (((x) & (unsigned HOST_WIDE_INT) 0xffffffff) |\t\\\n-      (((x) & (unsigned HOST_WIDE_INT) 0x80000000)\t\\\n-       ? ((~ (HOST_WIDE_INT) 0)\t\t\t\t\\\n-\t  & ~ (unsigned HOST_WIDE_INT) 0xffffffff)\t\\\n+/* Create an [unsigned] host sized integer declaration that\n+   avoids compiler warnings.  */\n+#ifdef __STDC__\n+#define HOST_INT(x)  ((signed HOST_WIDE_INT) x##UL)\n+#define HOST_UINT(x) ((unsigned HOST_WIDE_INT) x##UL)\n+#else\n+#define HOST_INT(x)  ((HOST_WIDE_INT) x)\n+#define HOST_UINT(x) ((unsigned HOST_WIDE_INT) x)\n+#endif\n+\n+#define ARM_SIGN_EXTEND(x)  ((HOST_WIDE_INT)\t\\\n+  (HOST_BITS_PER_WIDE_INT <= 32 ? (x)\t\t\\\n+   : (((x) & HOST_UINT (0xffffffff)) |\t\t\\\n+      (((x) & HOST_UINT (0x80000000))\t\t\\\n+       ? ((~ HOST_INT (0))\t\t\t\\\n+\t  & ~ HOST_UINT(0xffffffff))\t\t\\\n        : 0))))\n \n /* Output the address of an operand.  */\n@@ -2814,12 +2825,13 @@ extern int making_const_table;\n    when running in 26-bit mode.  */\n #define RETURN_ADDR_MASK26 (0x03fffffc)\n \n+#ifdef DWARF2_DEBUGGING_INFO\n /* Pick up the return address upon entry to a procedure. Used for\n    dwarf2 unwind information.  This also enables the table driven\n    mechanism.  */\n-\n #define INCOMING_RETURN_ADDR_RTX\tgen_rtx_REG (Pmode, LR_REGNUM)\n #define DWARF_FRAME_RETURN_COLUMN\tDWARF_FRAME_REGNUM (LR_REGNUM)\n+#endif\n \n /* Used to mask out junk bits from the return address, such as\n    processor state, interrupt status, condition codes and the like.  */"}]}