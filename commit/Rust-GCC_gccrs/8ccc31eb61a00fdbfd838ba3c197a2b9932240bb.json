{"sha": "8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNjYzMxZWI2MWEwMGZkYmZkODM4YmEzYzE5N2EyYjk5MzIyNDBiYg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-02-16T15:24:37Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-02-16T15:24:37Z"}, "message": "56th Cygnus<->FSF merge\n\nFrom-SVN: r8957", "tree": {"sha": "8b5e685b4056f68990c586e81d97766c717ee227", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b5e685b4056f68990c586e81d97766c717ee227"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/comments", "author": null, "committer": null, "parents": [{"sha": "3a5ece659ce244cbdfa9344a829dd39243410766", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a5ece659ce244cbdfa9344a829dd39243410766", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a5ece659ce244cbdfa9344a829dd39243410766"}], "stats": {"total": 1931, "additions": 1233, "deletions": 698}, "files": [{"sha": "a092c8db65b61353e2d5c26e13eb93e4563cf9a8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "patch": "@@ -10,6 +10,306 @@ Wed Jan 25 15:02:09 1995  David S. Miller  (davem@nadzieja.rutgers.edu)\n \t* class.c (instantiate_type): Change error message text.\n \t* typeck2.c (store_init_value): Likewise.\n \n+Thu Feb 16 03:28:49 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* class.c (finish_struct): Use TYPE_{MIN,MAX}_VALUE to determine\n+\twhether an enumerated type fits in a bitfield.\n+\n+Wed Feb 15 15:38:12 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* class.c (grow_method): Update method_vec after growing the class\n+        obstack.\n+\n+Wed Feb 15 13:42:59 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* parse.y (handler_seq): Push a level for the catch parameters.\n+\n+Wed Feb 15 12:42:57 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* init.c (emit_base_init): Update BINFO_INHERITANCE_CHAIN on my\n+\tbases, in case they've been clobbered.\n+\n+Wed Feb 15 12:07:29 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* class.c (finish_base_struct): Set up BINFO_INHERITANCE_CHAIN here,\n+\tso that one day it will always be valid.\n+\t* tree.c (propagate_binfo_offsets, layout_vbasetypes): Ditto.\n+\n+\t* cp-tree.h (copy_binfo): Removed, unused.\n+\t* tree.c (copy_binfo): Ditto.\n+\n+Wed Feb 15 00:05:30 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* init.c (build_new): Save the allocation before calling\n+\texpand_vec_init on it.\n+\n+\t* decl.c (finish_enum): The TYPE_PRECISION of the enum type mush\n+\tmatch the TYPE_PRECISION of the underlying type for constant folding\n+\tto work.\n+\n+Tue Feb 14 15:31:25 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (push_eh_entry, expand_start_all_catch,\n+\texpand_leftover_cleanups, expand_end_catch_block): Keep track of\n+\tthe context in which the exception region occurs.\n+\t(build_exception_table): If the region was not output, don't output\n+\tthe entry in the eh table for it.\n+\n+Tue Feb 14 02:15:43 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* init.c (expand_default_init): Only use a previous constructor call\n+\tif it's a call to our constructor.  Does the word \"Duh\" mean\n+\tanything to you?\n+\n+\t* decl.c (grokparms): Fine, just don't call\n+\tconvert_for_initialization at all.  OK?  Happy now?\n+\n+Mon Feb 13 02:23:44 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* cp-tree.h (CLASSTYPE_FIRST_CONVERSION): Make sure that the class\n+\tmethod vector has a second element before returning it.\n+\n+\t* decl.c (grokparms): Don't strip REFERENCE_TYPE before calling\n+\tconvert_for_initialization.\n+\n+Sun Feb 12 03:57:06 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (build_modify_expr): Compare function name to\n+\tconstructor_name (current_class_type) instead of current_class_name.\n+\n+\t* decl.c (grokparms): Don't do anything with the return value of\n+\tconvert_for_initialization.\n+\n+\t* error.c (dump_decl): Also dump_readonly_or_volatile on the decl.\n+\n+\t* decl.c (duplicate_decls): Tweak error message.\n+\n+\t* typeck.c (build_const_cast): Implement checking.\n+\t(build_reinterpret_cast): Implement some checking.\n+\n+\t* cp-tree.h (CONV_FORCE_TEMP): Require a new temporary when\n+\tconverting to the same aggregate type.\n+\t(CONV_STATIC_CAST): Include it.\n+\t(CONV_C_CAST): Ditto.\n+\t* cvt.c (convert_force): Use CONV_C_CAST instead of CONV_OLD_CONVERT.\n+\t(cp_convert): Only force a new temporary if CONV_FORCE_TEMP.\n+\n+Fri Feb 10 16:18:52 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (build_c_cast): Use non_lvalue to tack something on\n+        where necessary.\n+\n+\t* decl.c (auto_function): Now a function.\n+\t* except.c (init_exception_processing): terminate, unexpected,\n+\tset_terminate, and set_unexpected have C++ linkage.\n+\n+\t* typeck.c (build_unary_op, TRUTH_NOT_EXPR): Use convert instead of\n+\ttruthvalue_conversion for converting to bool, as it handles\n+\tuser-defined conversions properly.\n+\t(condition_conversion): Ditto.\n+\n+\t* except.c (expand_throw): Don't call convert_to_reference.\n+\tPass the correct parameters to build_new.\n+\n+\t* method.c (do_build_assign_ref): Don't use access control when\n+\tconverting to a base reference here.\n+\t(do_build_copy_constructor): Or here.\n+\n+\t* init.c (build_new): Unset TREE_READONLY on the dereferenced\n+\tpointer before assigning to it.\n+\n+\t* decl.c (maybe_build_cleanup): Don't bother stripping const here.\n+\n+\t* decl2.c (delete_sanity): You can now delete pointer to const.\n+\n+Fri Feb 10 13:28:38 1995  Jason Merrill  <jason@python.cygnus.com>\n+\n+\t* decl.c (finish_function): Don't rely on actual parameters being\n+\tevaluated left-to-right.\n+\t* except.c (expand_end_catch_block): Ditto.\n+\n+Fri Feb 10 00:52:04 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* tree.c (real_lvalue_p): Like lvalue_p, but class temps aren't\n+\tconsidered lvalues.\n+\t* cvt.c (convert_to_reference): Use real_lvalue_p instead of\n+        lvalue_p.\n+\n+\t* cvt.c (build_type_conversion_1): Don't call convert on aggregate\n+\ttypes.\n+\t(convert_to_reference): Fix erroneous text substitution.\n+\n+\t* typeck2.c (initializer_constant_valid_p): Update from C frontend.\n+\tAdd new argument to all callers.\n+\n+\t* typeck.c (convert_arguments): Check for error_mark_node before\n+\ttrying to do anything with the actual parameter.\n+\n+\t* typeck.c (condition_conversion): Build up a CLEANUP_POINT_EXPR and\n+\tfold it.\n+\t(bool_truthvalue_conversion): Remove.  Fix all callers to call\n+\ttruthvalue_conversion instead.\n+\t(various): Fold CLEANUP_POINT_EXPRs.\n+\n+\t* parse.y (conditions): Call condition_conversion rather than\n+\tbuilding up a CLEANUP_POINT_EXPR.\n+\n+\t* pt.c (end_template_decl): Don't warn_if_unknown_interface here\n+\tunder -falt-external-templates.\n+\n+Thu Feb  9 05:24:10 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* init.c (build_new): Complain about new of const type without\n+\tinitializer.  Other cleanup.\n+\n+\t* call.c (compute_conversion_costs): Don't call\n+\tbuild_type_conversion with a reference type; convert to the target\n+\ttype and check its lvaluetude.\n+\t* cvt.c (convert_to_reference): Ditto.\n+\n+\t* cvt.c (build_type_conversion_1): There will never be any need to\n+\tdereference references here now.\n+\n+Thu Feb  9 00:37:47 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_builtin_throw): Make sure we only `use' the\n+\tvalue of return_val_rtx.\n+\n+Wed Feb  8 15:45:55 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* parse.y (structsp): Don't complain about declaring a type being\n+\tdefined to be a friend.\n+\n+\t* decl2.c (warn_if_unknown_interface): Note the template in question\n+\tand the point of instantiation, for -falt-external-templates.\n+\t* lex.c (reinit_parse_for_method): Pass the decl to\n+\twarn_if_unknown_interface.\n+\t* pt.c (instantiate_template): Ditto.\n+\t(end_template_decl): Ditto.\n+\n+\t* decl.c (set_nested_typename): Set IDENTIFIER_TYPE_VALUE on the\n+\tnested name again, to make local classes work a bit better.\n+\n+\t* typeck.c (build_function_call_real): Dereference reference after\n+\tchecking for incomplete type.\n+\n+\t* init.c (build_new): Accept new of const and volatile types.\n+\n+Wed Feb  8 14:04:16 1995  Jason Merrill  <jason@deneb.cygnus.com>\n+\n+\t* decl.c (grokdeclarator): Fix error message.\n+\n+Wed Feb  8 03:16:15 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (convert_for_initialization): Do bash arrays when\n+\tconverting to a reference to non-array.\n+\n+Tue Feb  7 15:50:33 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* cvt.c (cp_convert): Don't call convert_to_reference, or\n+\tautomatically dereference references.  Do pass reference conversions\n+\tto cp_convert_to_pointer.\n+\t(cp_convert_to_pointer): Support references.\n+\n+\t* call.c (build_method_call): Don't build up a reference to the\n+\tparameter here; let build_overload_call handle that.\n+\n+\t* typeck.c (build_c_cast): Call convert_to_reference directly if\n+\tconverting to a reference type.\n+\t* method.c (do_build_copy_constructor): Ditto.\n+\t* method.c (do_build_copy_constructor): Ditto.\n+\t(do_build_assign_ref): Ditto.\n+\n+\t* call.c (build_method_call): Dereference a returned reference.\n+\t* typeck.c (build_function_call_real): Ditto.\n+\n+\t* decl.c (xref_basetypes): Check for unions with basetypes here.\n+\t(xref_tag): Instead of here.\n+\n+\t* pt.c (process_template_parm): Template type parm decls are\n+\tartificial.\n+\n+Mon Feb  6 04:32:09 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* parse.y (typed_declspecs): Add missing semicolon.\n+\t(do_xref_defn): Resurrect.\n+\t(named_class_head_sans_basetype): Move template specialization\n+\tdefinition cases to named_class_head_sans_basetype_defn.\n+\n+\t* decl2.c (grokfield): Call pushdecl_class_level after setting the\n+\tTYPE_NAME, not before.\n+\n+Sun Feb  5 02:50:45 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* call.c (convert_harshness): Don't call sorry here.  Don't allow\n+\tconversions between function pointer types if pedantic.\n+\n+\t* pt.c (overload_template_name): Pass globalize=1 to xref_tag.\n+\n+\t* lex.c (cons_up_default_function): Use the full name for the return\n+\ttype of op=.\n+\n+\t* decl.c (set_nested_typename): Don't worry about anonymous types,\n+\tas they already have a unique name.\n+\t(pushdecl): Remove redundant set_nested_typename\n+\t(xref_tag): Split out base handling into xref_basetypes.\n+\n+\t* cp-tree.h (TYPE_INCOMPLETE): New macro; TEMPLATE_TYPE_PARMs are\n+\tnot considered incomplete even though their definition is unknown.\n+\n+\t* decl.c (xref_defn_tag): Lose.\n+\t(xref_tag): xref_next_defn = ! globalize.\n+\t(pushdecl): Don't set DECL_NESTED_TYPENAME on artificial decls.  The\n+\tones that should have it set will have it set by pushtag.\n+\t(pushdecl_class_level): Ditto.\n+\t(pushtag): Tidy up a bit.\n+\t(set_nested_typename): Push a decl for the nested typename from\n+\there, rather than from xref_defn_tag.\n+\n+\t* parse.y (do_xref): Lose.\n+\t(named_class_head): If we see 'class foo:' we know it's a\n+\tdefinition, so don't worry about base lists for non-definitions.\n+\n+\t* pt.c (push_template_decls): Template parm decls are artificial.\n+\n+\t* decl.c (duplicate_decls): Restore check for qualifier\n+\tdisagreement for non-functions.\n+\t(decls_match): Remove check for qualifier disagreement.\n+\n+Fri Feb  3 14:58:58 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (grok_reference_init): Convert initializer from\n+        reference.\n+\t* typeck.c (convert_for_initialization): Ditto.\n+\n+\t* decl.c (duplicate_decls): Propagate DECL_NESTED_TYPENAME.\n+\n+\t* cvt.c (cp_convert): Don't convert to the same class type by just\n+\ttacking on a NOP_EXPR.\n+\t(convert_to_reference): Use comp_target_types instead of comptypes\n+\tso that we don't allow conversions two levels down.\n+\n+Thu Feb  2 15:07:58 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* class.c (build_vbase_path): Bash types to make the backend happy.\n+\t* cvt.c (build_up_reference): Bash the types bashed by\n+\tbuild_vbase_path to be reference types instead of pointer types.\n+\t(convert_to_reference): Ditto.\n+\n+\t* typeck.c (build_c_cast): Don't strip NOPs if we're converting to a\n+\treference type.\n+\n+\t* parse.y (structsp): Put back error for 'struct B: public A;'.\n+\n+Wed Feb  1 23:02:06 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c: Add support for mips systems that don't define __mips\n+\tbut do define mips, like Ultrix.\n+\n+Wed Feb  1 22:39:07 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c: Add support for exception handling on the Alpha.\n+\n Wed Feb  1 10:12:14 1995  Mike Stump  <mrs@cygnus.com>\n \n \t* decl2.c (finish_file): Fix bug in Jan 31st change."}, {"sha": "be7cf3c64fada6820bc12727f904c6729804a2e8", "filename": "gcc/cp/call.c", "status": "modified", "additions": 17, "deletions": 35, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "patch": "@@ -176,6 +176,9 @@ convert_harshness (type, parmtype, parm)\n       if (type == parmtype)\n \treturn ZERO_RETURN (h);\n \n+      if (pedantic)\n+\treturn EVIL_RETURN (h);\n+\n       /* Compare return types.  */\n       p1 = TREE_TYPE (type);\n       p2 = TREE_TYPE (parmtype);\n@@ -207,14 +210,16 @@ convert_harshness (type, parmtype, parm)\n \n \t  if (! BINFO_OFFSET_ZEROP (binfo))\n \t    {\n+#if 0\n \t      static int explained = 0;\n \t      if (h2.distance < 0)\n-\t\tmessage_2_types (sorry, \"cannot cast `%d' to `%d' at function call site\", p2, p1);\n+\t\tmessage_2_types (sorry, \"cannot cast `%s' to `%s' at function call site\", p2, p1);\n \t      else\n-\t\tmessage_2_types (sorry, \"cannot cast `%d' to `%d' at function call site\", p1, p2);\n+\t\tmessage_2_types (sorry, \"cannot cast `%s' to `%s' at function call site\", p1, p2);\n \n \t      if (! explained++)\n \t\tsorry (\"(because pointer values change during conversion)\");\n+#endif\n \t      return EVIL_RETURN (h);\n \t    }\n \t}\n@@ -877,12 +882,15 @@ compute_conversion_costs (function, tta_in, cp, arglen)\n \n \t\t      inhibit_warnings = 1;\n \t\t      conv = build_type_conversion\n-\t\t\t(CALL_EXPR, TREE_VALUE (ttf), TREE_VALUE (tta), 0);\n+\t\t\t(CALL_EXPR, formal_type, TREE_VALUE (tta), 0);\n \t\t      inhibit_warnings = old_inhibit_warnings;\n \n \t\t      if (conv)\n \t\t\t{\n-\t\t\t  if (conv == error_mark_node)\n+\t\t\t  if (conv == error_mark_node\n+\t\t\t      || (TREE_CODE (TREE_VALUE (ttf)) == REFERENCE_TYPE\n+\t\t\t\t  && ! TYPE_READONLY (TREE_VALUE (TREE_VALUE (ttf)))\n+\t\t\t\t  && ! lvalue_p (conv)))\n \t\t\t    win += 2;\n \t\t\t  else\n \t\t\t    {\n@@ -891,22 +899,6 @@ compute_conversion_costs (function, tta_in, cp, arglen)\n \t\t\t\textra_conversions = 1;\n \t\t\t    }\n \t\t\t}\n-\t\t      else if (TREE_CODE (TREE_VALUE (ttf)) == REFERENCE_TYPE)\n-\t\t\t{\n-\t\t\t  conv = build_type_conversion (CALL_EXPR, formal_type,\n-\t\t\t\t\t\t\tTREE_VALUE (tta), 0);\n-\t\t\t  if (conv)\n-\t\t\t    {\n-\t\t\t      if (conv == error_mark_node)\n-\t\t\t\twin += 2;\n-\t\t\t      else\n-\t\t\t\t{\n-\t\t\t\t  win++;\n-\t\t\t\t  if (TREE_CODE (conv) != CALL_EXPR)\n-\t\t\t\t    extra_conversions = 1;\n-\t\t\t\t}\n-\t\t\t    }\n-\t\t\t}\n \t\t    }\n \t\t}\n \t      dont_convert_types = 0;\n@@ -2035,25 +2027,14 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t      tree parm = instance_ptr;\n \n \t      if (TREE_CODE (TREE_TYPE (parm)) == REFERENCE_TYPE)\n-\t\t{\n-\t\t  /* TREE_VALUE (parms) may have been modified by now;\n-                     restore it to its original value. */\n-\t\t  TREE_VALUE (parms) = parm;\n-\t\t  friend_parms = parms;\n-\t\t}\n+\t\tparm = convert_from_reference (parm);\n \t      else if (TREE_CODE (TREE_TYPE (parm)) == POINTER_TYPE)\n-\t\t{\n-\t\t  tree new_type;\n-\t\t  parm = build_indirect_ref (parm, \"friendifying parms (compiler error)\");\n-\t\t  new_type = cp_build_type_variant (TREE_TYPE (parm), constp,\n-\t\t\t\t\t\t   volatilep);\n-\t\t  new_type = build_reference_type (new_type);\n-\t\t  parm = convert (new_type, parm);\n-\t\t  friend_parms = tree_cons (NULL_TREE, parm, TREE_CHAIN (parms));\n-\t\t}\n+\t\tparm = build_indirect_ref (parm, \"friendifying parms (compiler error)\");\n \t      else\n \t\tmy_friendly_abort (167);\n \n+\t      friend_parms = tree_cons (NULL_TREE, parm, TREE_CHAIN (parms));\n+\n \t      cp->h_len = len;\n \t      cp->harshness = (struct harshness_code *)\n \t\talloca ((len + 1) * sizeof (struct harshness_code));\n@@ -2602,6 +2583,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n     TREE_TYPE (result) = value_type;\n     TREE_SIDE_EFFECTS (result) = 1;\n     TREE_HAS_CONSTRUCTOR (result) = is_constructor;\n+    result = convert_from_reference (result);\n     return result;\n   }\n }"}, {"sha": "b5edebd54591de9abcfe6246a04f0aead1739231", "filename": "gcc/cp/class.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "patch": "@@ -1453,6 +1453,7 @@ finish_base_struct (t, b, t_binfo)\n \t      chain = TREE_VEC_ELT (base_binfos, j);\n \t      TREE_VIA_PUBLIC (chain) = TREE_VIA_PUBLIC (base_base_binfo);\n \t      TREE_VIA_PROTECTED (chain) = TREE_VIA_PROTECTED (base_base_binfo);\n+\t      BINFO_INHERITANCE_CHAIN (chain) = base_binfo;\n \t    }\n \n \t  /* Completely unshare potentially shared data, and\n@@ -1711,8 +1712,9 @@ finish_struct_bits (t, max_has_virtual)\n /* Add FN to the method_vec growing on the class_obstack.  Used by\n    finish_struct_methods.  */\n static void\n-grow_method (fn)\n+grow_method (fn, method_vec_ptr)\n      tree fn;\n+     tree *method_vec_ptr;\n {\n   tree method_vec = (tree)obstack_base (&class_obstack);\n   tree *testp = &TREE_VEC_ELT (method_vec, 0);\n@@ -1756,7 +1758,10 @@ grow_method (fn)\n \t}\n     }\n   else\n-    obstack_ptr_grow (&class_obstack, fn);\n+    {\n+      obstack_ptr_grow (&class_obstack, fn);\n+      *method_vec_ptr = (tree)obstack_base (&class_obstack);\n+    }\n }\n \n /* Warn about duplicate methods in fn_fields.  Also compact method\n@@ -1855,7 +1860,7 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \t  else if (typecode_p (return_type, REAL_TYPE))\n \t    TYPE_HAS_REAL_CONVERSION (t) = 1;\n \n-\t  grow_method (fn_fields);\n+\t  grow_method (fn_fields, &method_vec);\n \t}\n       else\n \t{\n@@ -1891,12 +1896,10 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \t    }\n \t}\n \n-      grow_method (fn_fields);\n+      grow_method (fn_fields, &method_vec);\n       fn_fields = nextp;\n     }\n \n-  /* Update in case method_vec has moved.  */\n-  method_vec = (tree)obstack_base (&class_obstack);\n   TREE_VEC_LENGTH (method_vec) = (tree *)obstack_next_free (&class_obstack)\n     - (&TREE_VEC_ELT (method_vec, 0));\n   obstack_finish (&class_obstack);\n@@ -2289,13 +2292,9 @@ modify_one_vtable (binfo, t, fndecl, pfn)\n \t  this_offset = size_binop (MINUS_EXPR, offset, base_offset);\n \n \t  /* Make sure we can modify the derived association with immunity.  */\n-\t  if (TREE_USED (binfo)) {\n+\t  if (TREE_USED (binfo))\n \t    my_friendly_assert (0, 999);\n-#if 0\n-\t    my_friendly_assert (*binfo2_ptr == binfo, 999);\n-\t    *binfo2_ptr = copy_binfo (binfo);\n-#endif\n-\t  }\n+\n \t  if (binfo == TYPE_BINFO (t))\n \t    {\n \t      /* In this case, it is *type*'s vtable we are modifying.\n@@ -3160,8 +3159,11 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t\t    {\n \t\t      cp_warning_at (\"width of `%D' exceeds its type\", x);\n \t\t    }\n-\t\t  else if (width < TYPE_PRECISION (TREE_TYPE (x))\n-\t\t\t   && TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE)\n+\t\t  else if (TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE\n+\t       && ((min_precision (TYPE_MIN_VALUE (TREE_TYPE (x)),\n+\t\t\t\t   TREE_UNSIGNED (TREE_TYPE (x))) > width)\n+\t\t   || (min_precision (TYPE_MAX_VALUE (TREE_TYPE (x)),\n+\t\t\t\t      TREE_UNSIGNED (TREE_TYPE (x))) > width)))\n \t\t    {\n \t\t      cp_warning_at (\"`%D' is too small to hold all values of `%#T'\",\n \t\t\t\t     x, TREE_TYPE (x));"}, {"sha": "4cb8af9e90ef8d0098004782549c513772bd3787", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "patch": "@@ -666,7 +666,9 @@ struct lang_type\n    searched with TREE_CHAIN), or the first non-constructor function if\n    there are no type conversion operators.  */\n #define CLASSTYPE_FIRST_CONVERSION(NODE) \\\n-  TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (NODE), 1)\n+  TREE_VEC_LENGTH (CLASSTYPE_METHOD_VEC (NODE)) > 1 \\\n+    ? TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (NODE), 1) \\\n+    : NULL_TREE;\n \n /* Pointer from any member function to the head of the list of\n    member functions of the type that member function belongs to.  */\n@@ -842,6 +844,9 @@ struct lang_type\n \n /* Nonzero if a _DECL node requires us to output debug info for this class.  */\n #define CLASSTYPE_DEBUG_REQUESTED(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.debug_requested)\n+\n+#define TYPE_INCOMPLETE(NODE) \\\n+  (TYPE_SIZE (NODE) == NULL_TREE && TREE_CODE (NODE) != TEMPLATE_TYPE_PARM)\n \f\n /* Additional macros for inheritance information.  */\n \n@@ -1816,19 +1821,22 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n    CONV_CONST      :  Perform the explicit conversions for const_cast.\n    CONV_REINTERPRET:  Perform the explicit conversions for reinterpret_cast.\n    CONV_PRIVATE    :  Perform upcasts to private bases.\n-   CONV_NONCONVERTING : Allow non-converting constructors to be used.  */\n+   CONV_NONCONVERTING : Allow non-converting constructors to be used.\n+   CONV_FORCE_TEMP :  Require a new temporary when converting to the same\n+   \t\t      aggregate type.  */\n \n #define CONV_IMPLICIT    1\n #define CONV_STATIC      2\n #define CONV_CONST       4\n #define CONV_REINTERPRET 8\n #define CONV_PRIVATE\t 16\n #define CONV_NONCONVERTING 32\n-#define CONV_STATIC_CAST (CONV_IMPLICIT | CONV_STATIC)\n+#define CONV_FORCE_TEMP  64\n+#define CONV_STATIC_CAST (CONV_IMPLICIT | CONV_STATIC | CONV_FORCE_TEMP)\n #define CONV_OLD_CONVERT (CONV_IMPLICIT | CONV_STATIC | CONV_CONST \\\n \t\t\t  | CONV_REINTERPRET)\n #define CONV_C_CAST      (CONV_IMPLICIT | CONV_STATIC | CONV_CONST \\\n-\t\t\t  | CONV_REINTERPRET | CONV_PRIVATE)\n+\t\t\t  | CONV_REINTERPRET | CONV_PRIVATE | CONV_FORCE_TEMP)\n \n /* Anatomy of a DECL_FRIENDLIST (which is a TREE_LIST):\n    purpose = friend name (IDENTIFIER_NODE);\n@@ -1946,6 +1954,7 @@ extern tree pushdecl_top_level\t\t\tPROTO((tree));\n extern void push_class_level_binding\t\tPROTO((tree, tree));\n extern void push_overloaded_decl_top_level\tPROTO((tree, int));\n extern tree pushdecl_class_level\t\tPROTO((tree));\n+extern tree pushdecl_nonclass_level\t\tPROTO((tree));\n extern int overloaded_globals_p\t\t\tPROTO((tree));\n extern tree push_overloaded_decl\t\tPROTO((tree, int));\n extern tree implicitly_declare\t\t\tPROTO((tree));\n@@ -1971,8 +1980,8 @@ extern int complete_array_type\t\t\tPROTO((tree, tree, int));\n extern tree build_ptrmemfunc_type\t\tPROTO((tree));\n extern tree grokdeclarator\t\t\t(); /* PROTO((tree, tree, enum decl_context, int, tree)); */\n extern int parmlist_is_exprlist\t\t\tPROTO((tree));\n-extern tree xref_defn_tag\t\t\tPROTO((tree, tree, tree));\n extern tree xref_tag\t\t\t\tPROTO((tree, tree, tree, int));\n+extern void xref_basetypes\t\t\tPROTO((tree, tree, tree, tree));\n extern tree start_enum\t\t\t\tPROTO((tree));\n extern tree finish_enum\t\t\t\tPROTO((tree, tree));\n extern tree build_enumerator\t\t\tPROTO((tree, tree));\n@@ -2019,7 +2028,7 @@ extern tree coerce_delete_type\t\t\tPROTO((tree));\n extern void walk_vtables\t\t\tPROTO((void (*)(), void (*)()));\n extern void walk_sigtables\t\t\tPROTO((void (*)(), void (*)()));\n extern void finish_file\t\t\t\tPROTO((void));\n-extern void warn_if_unknown_interface\t\tPROTO((void));\n+extern void warn_if_unknown_interface\t\tPROTO((tree));\n extern tree grok_x_components\t\t\tPROTO((tree, tree));\n extern tree reparse_absdcl_as_expr\t\tPROTO((tree, tree));\n extern tree reparse_absdcl_as_casts\t\tPROTO((tree, tree));\n@@ -2286,7 +2295,6 @@ extern tree hash_chainon\t\t\tPROTO((tree, tree));\n extern tree get_decl_list\t\t\tPROTO((tree));\n extern tree list_hash_lookup_or_cons\t\tPROTO((tree));\n extern tree make_binfo\t\t\t\tPROTO((tree, tree, tree, tree, tree));\n-extern tree copy_binfo\t\t\t\tPROTO((tree));\n extern tree binfo_value\t\t\t\tPROTO((tree, tree));\n extern tree reverse_path\t\t\tPROTO((tree));\n extern tree virtual_member\t\t\tPROTO((tree, tree));\n@@ -2311,7 +2319,7 @@ extern tree array_type_nelts_total\t\tPROTO((tree));\n extern tree array_type_nelts_top\t\tPROTO((tree));\n \n /* in typeck.c */\n-extern tree bool_truthvalue_conversion\t\tPROTO((tree));\n+extern tree condition_conversion\t\tPROTO((tree));\n extern tree target_type\t\t\t\tPROTO((tree));\n extern tree require_complete_type\t\tPROTO((tree));\n extern int type_unknown_p\t\t\tPROTO((tree));"}, {"sha": "ce01c662ccfa6071ded5c8105b7c2ef6e94df788", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 55, "deletions": 56, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "patch": "@@ -113,7 +113,7 @@ cp_convert_to_pointer (type, expr)\n   register tree intype = TREE_TYPE (expr);\n   register enum tree_code form = TREE_CODE (intype);\n   \n-  if (form == POINTER_TYPE)\n+  if (form == POINTER_TYPE || form == REFERENCE_TYPE)\n     {\n       intype = TYPE_MAIN_VARIANT (intype);\n \n@@ -632,31 +632,49 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n {\n   register tree type = TYPE_MAIN_VARIANT (TREE_TYPE (reftype));\n   register tree intype = TREE_TYPE (expr);\n-  register enum tree_code form = TREE_CODE (intype);\n   tree rval = NULL_TREE;\n+  tree rval_as_conversion = NULL_TREE;\n+  int i;\n+\n+  if (TREE_CODE (intype) == REFERENCE_TYPE)\n+    my_friendly_abort (364);\n \n-  if (form == REFERENCE_TYPE)\n-    intype = TREE_TYPE (intype);\n   intype = TYPE_MAIN_VARIANT (intype);\n \n-  if (((convtype & CONV_STATIC) && comptypes (type, intype, -1))\n-      || ((convtype & CONV_IMPLICIT) && comptypes (type, intype, 0)))\n+  i = comp_target_types (type, intype, 0);\n+\n+  if (i <= 0 && (convtype & CONV_IMPLICIT) && IS_AGGR_TYPE (intype)\n+      && ! (flags & LOOKUP_NO_CONVERSION))\n+    {\n+      /* Look for a user-defined conversion to lvalue that we can use.  */\n+\n+      rval_as_conversion = build_type_conversion (CONVERT_EXPR, type, expr, 1);\n+\n+      if (rval_as_conversion && rval_as_conversion != error_mark_node\n+\t  && real_lvalue_p (rval_as_conversion))\n+\t{\n+\t  expr = rval_as_conversion;\n+\t  rval_as_conversion = NULL_TREE;\n+\t  intype = type;\n+\t  i = 1;\n+\t}\n+    }\n+\n+  if (((convtype & CONV_STATIC) && i == -1)\n+      || ((convtype & CONV_IMPLICIT) && i == 1))\n     {\n       if (flags & LOOKUP_COMPLAIN)\n \t{\n \t  tree ttl = TREE_TYPE (reftype);\n \t  tree ttr;\n \t  \n-\t  if (form == REFERENCE_TYPE)\n-\t    ttr = TREE_TYPE (TREE_TYPE (expr));\n-\t  else\n-\t    {\n-\t      int r = TREE_READONLY (expr);\n-\t      int v = TREE_THIS_VOLATILE (expr);\n-\t      ttr = cp_build_type_variant (TREE_TYPE (expr), r, v);\n-\t    }\n+\t  {\n+\t    int r = TREE_READONLY (expr);\n+\t    int v = TREE_THIS_VOLATILE (expr);\n+\t    ttr = cp_build_type_variant (TREE_TYPE (expr), r, v);\n+\t  }\n \n-\t  if (! lvalue_p (expr) &&\n+\t  if (! real_lvalue_p (expr) &&\n \t      (decl == NULL_TREE || ! TYPE_READONLY (ttl)))\n \t    {\n \t      if (decl)\n@@ -678,34 +696,9 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t    }\n \t}\n \n-      if (form == REFERENCE_TYPE)\n-\t{\n-\t  tree type = TREE_TYPE (expr);\n-\t  TREE_TYPE (expr) = build_pointer_type (TREE_TYPE (type));\n-\t  rval = cp_convert (build_pointer_type (TREE_TYPE (reftype)), expr,\n-\t\t\t     convtype, flags);\n-\t  TREE_TYPE (expr) = type;\n-\t  TREE_TYPE (rval) = reftype;\n-\t  if (TREE_CODE (rval) == PLUS_EXPR || TREE_CODE (rval) == MINUS_EXPR)\n-\t    TREE_TYPE (TREE_OPERAND (rval, 0))\n-\t      = TREE_TYPE (TREE_OPERAND (rval, 1)) = reftype;\n-\t  return rval;\n-\t}\n-\n       return build_up_reference (reftype, expr, flags,\n \t\t\t\t ! (convtype & CONV_CONST));\n     }\n-\n-  if ((convtype & CONV_IMPLICIT)\n-      && IS_AGGR_TYPE (intype)\n-      && ! (flags & LOOKUP_NO_CONVERSION)\n-      && (rval = build_type_conversion (CONVERT_EXPR, reftype, expr, 1)))\n-    {\n-      if (rval == error_mark_node)\n-\tcp_error (\"conversion from `%T' to `%T' is ambiguous\",\n-\t\t  intype, reftype);\n-      return rval;\n-    }\n   else if ((convtype & CONV_REINTERPRET) && lvalue_p (expr))\n     {\n       /* When casting an lvalue to a reference type, just convert into\n@@ -715,7 +708,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \n       /* B* bp; A& ar = (A&)bp; is valid, but it's probably not what they\n          meant.  */\n-      if (form == POINTER_TYPE\n+      if (TREE_CODE (intype) == POINTER_TYPE\n \t  && (comptypes (TREE_TYPE (intype), type, -1)))\n \tcp_warning (\"casting `%T' to `%T' does not dereference pointer\",\n \t\t    intype, reftype);\n@@ -728,16 +721,18 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n     }\n   else if (decl)\n     {\n-      tree rval_as_conversion = NULL_TREE;\n       tree rval_as_ctor = NULL_TREE;\n       \n-      if (IS_AGGR_TYPE (intype)\n-\t  && (rval = build_type_conversion (CONVERT_EXPR, type, expr, 1)))\n+      if (rval_as_conversion)\n \t{\n-\t  if (rval == error_mark_node)\n-\t    return rval;\n-\n-\t  rval_as_conversion = build_up_reference (reftype, rval, flags, 1);\n+\t  if (rval_as_conversion == error_mark_node)\n+\t    {\n+\t      cp_error (\"conversion from `%T' to `%T' is ambiguous\",\n+\t\t\tintype, reftype);\n+\t      return error_mark_node;\n+\t    }\n+\t  rval_as_conversion = build_up_reference (reftype, rval_as_conversion,\n+\t\t\t\t\t\t   flags, 1);\n \t}\n       \n       /* Definitely need to go through a constructor here.  */\n@@ -815,7 +810,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n       return rval;\n     }\n \n-  my_friendly_assert (form != OFFSET_TYPE, 189);\n+  my_friendly_assert (TREE_CODE (intype) != OFFSET_TYPE, 189);\n \n   if (flags & LOOKUP_SPECULATIVELY)\n     return NULL_TREE;\n@@ -1206,8 +1201,10 @@ cp_convert (type, expr, convtype, flags)\n       || TREE_CODE (TREE_TYPE (e)) == ERROR_MARK)\n     return error_mark_node;\n \n-  /* Trivial conversion: cv-qualifiers do not matter on rvalues.  */\n-  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (e)))\n+  if (IS_AGGR_TYPE (type) && (convtype & CONV_FORCE_TEMP))\n+    /* We need a new temporary; don't take this shortcut.  */;\n+  else if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (e)))\n+    /* Trivial conversion: cv-qualifiers do not matter on rvalues.  */\n     return fold (build1 (NOP_EXPR, type, e));\n   \n   if (code == VOID_TYPE && (convtype & CONV_STATIC))\n@@ -1227,10 +1224,12 @@ cp_convert (type, expr, convtype, flags)\n       code = TREE_CODE (type);\n     }\n \n+#if 0\n   if (code == REFERENCE_TYPE)\n     return fold (convert_to_reference (type, e, convtype, flags, NULL_TREE));\n   else if (TREE_CODE (TREE_TYPE (e)) == REFERENCE_TYPE)\n     e = convert_from_reference (e);\n+#endif\n \n   if (TREE_CODE (e) == OFFSET_REF)\n     e = resolve_offset_ref (e);\n@@ -1266,7 +1265,7 @@ cp_convert (type, expr, convtype, flags)\n \treturn truthvalue_conversion (e);\n       return fold (convert_to_integer (type, e));\n     }\n-  if (code == POINTER_TYPE)\n+  if (code == POINTER_TYPE || code == REFERENCE_TYPE)\n     return fold (cp_convert_to_pointer (type, e));\n   if (code == REAL_TYPE)\n     {\n@@ -1458,7 +1457,7 @@ convert_force (type, expr, convtype)\n       return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), e, 1);\n     }\n \n-  return cp_convert (type, e, CONV_OLD_CONVERT|convtype, 0);\n+  return cp_convert (type, e, CONV_C_CAST|convtype, 0);\n }\n \n /* Subroutine of build_type_conversion.  */\n@@ -1484,9 +1483,9 @@ build_type_conversion_1 (xtype, basetype, expr, typename, for_sure)\n \treturn NULL_TREE;\n       return error_mark_node;\n     }\n-  if (TREE_CODE (TREE_TYPE (rval)) == REFERENCE_TYPE\n-      && TREE_CODE (xtype) != REFERENCE_TYPE)\n-    rval = default_conversion (rval);\n+\n+  if (IS_AGGR_TYPE (TREE_TYPE (rval)))\n+    return rval;\n \n   if (warn_cast_qual\n       && TREE_TYPE (xtype)"}, {"sha": "01547b0a766bdd85690e2a6136dd3975ef4d2f59", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 256, "deletions": 287, "changes": 543, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "patch": "@@ -121,17 +121,6 @@ static struct stack_level *decl_stack;\n #define WCHAR_TYPE \"int\"\n #endif\n \n-#define builtin_function(NAME, TYPE, CODE, LIBNAME) \\\n-  define_function (NAME, TYPE, CODE, (void (*)())pushdecl, LIBNAME)\n-#define auto_function(NAME, TYPE, CODE) \\\n-  do {\t\t\t\t\t\\\n-    tree __name = NAME;\t\t\\\n-    tree __type = TYPE;\t\t\t\\\n-    define_function (IDENTIFIER_POINTER (__name), __type, CODE,\t\\\n-\t\t     (void (*)())push_overloaded_decl_1,\t\\\n-\t\t     IDENTIFIER_POINTER (build_decl_overload (__name, TYPE_ARG_TYPES (__type), 0)));\\\n-  } while (0)\n-\n static tree grokparms\t\t\t\tPROTO((tree, int));\n static tree lookup_nested_type\t\t\tPROTO((tree, tree));\n static char *redeclaration_error_message\tPROTO((tree, tree));\n@@ -1647,6 +1636,14 @@ set_nested_typename (decl, classname, name, type)\n {\n   char *buf;\n   my_friendly_assert (TREE_CODE (decl) == TYPE_DECL, 136);\n+\n+  /* No need to do this for anonymous names, since they're unique.  */\n+  if (ANON_AGGRNAME_P (name))\n+    {\n+      DECL_NESTED_TYPENAME (decl) = name;\n+      return;\n+    }\n+\n   if (classname == NULL_TREE)\n     classname = get_identifier (\"\");\n \n@@ -1659,11 +1656,27 @@ set_nested_typename (decl, classname, name, type)\n   DECL_NESTED_TYPENAME (decl) = get_identifier (buf);\n   TREE_MANGLED (DECL_NESTED_TYPENAME (decl)) = 1;\n \n-  /* This is a special usage of IDENTIFIER_TYPE_VALUE which have no\n-     correspondence in any binding_level.  This is ok since the\n-     DECL_NESTED_TYPENAME is just a convenience identifier whose\n-     IDENTIFIER_TYPE_VALUE will remain constant from now on.  */\n-  SET_IDENTIFIER_TYPE_VALUE (DECL_NESTED_TYPENAME (decl), type);\n+  /* Create an extra decl so that the nested name will have a type value\n+     where appropriate.  */\n+  {\n+    tree nested, type_decl;\n+    nested = DECL_NESTED_TYPENAME (decl);\n+    type_decl = build_decl (TYPE_DECL, nested, type);\n+    DECL_NESTED_TYPENAME (type_decl) = nested;\n+    SET_DECL_ARTIFICIAL (type_decl);\n+#ifdef DWARF_DEBUGGING_INFO\n+    /* Mark the TYPE_DECL node created just above as a\n+       gratuitous one so that dwarfout.c will know not to\n+       generate a TAG_typedef DIE for it.  */\n+    if (write_symbols == DWARF_DEBUG)\n+      DECL_IGNORED_P (type_decl) = 1;\n+#endif /* DWARF_DEBUGGING_INFO */\n+\n+    /* Remove this when local classes are fixed.  */\n+    SET_IDENTIFIER_TYPE_VALUE (nested, type);\n+\n+    pushdecl_nonclass_level (type_decl);\n+  }\n }\n \n /* Pop off extraneous binding levels left over due to syntax errors.  */\n@@ -1820,7 +1833,7 @@ pushtag (name, type, globalize)\n \t\t}\n #endif /* DWARF_DEBUGGING_INFO */\n \n-\t      TYPE_NAME (type) = d;\n+\t      TYPE_MAIN_DECL (type) = d;\n \n \t      /* Make sure we're in this type's scope when we push the\n \t\t decl for a template, otherwise class_binding_level will\n@@ -1832,37 +1845,31 @@ pushtag (name, type, globalize)\n \t      if (TREE_CODE (type) == UNINSTANTIATED_P_TYPE)\n \t\tpopclass (0);\n \t    }\n-\t  if (write_symbols != DWARF_DEBUG)\n+\t  if (newdecl)\n \t    {\n-\t      if (ANON_AGGRNAME_P (name))\n-\t\tDECL_IGNORED_P (d) = 1;\n-\t    }\n+\t      if (write_symbols != DWARF_DEBUG)\n+\t\t{\n+\t\t  if (ANON_AGGRNAME_P (name))\n+\t\t    DECL_IGNORED_P (d) = 1;\n+\t\t}\n+\n+\t      if (context == NULL_TREE)\n+\t\t/* Non-nested class.  */\n+\t\tset_nested_typename (d, NULL_TREE, name, type);\n+\t      else if (context && TREE_CODE (context) == FUNCTION_DECL)\n+\t\t/* Function-nested class.  */\n+\t\tset_nested_typename (d, DECL_ASSEMBLER_NAME (c_decl),\n+\t\t\t\t     name, type);\n+\t      else /* if (context && IS_AGGR_TYPE (context)) */\n+\t\t/* Class-nested class.  */\n+\t\tset_nested_typename (d, DECL_NESTED_TYPENAME (c_decl),\n+\t\t\t\t     name, type);\n \n-\t  if (context == NULL_TREE)\n-\t    /* Non-nested class.  */\n-\t    set_nested_typename (d, NULL_TREE, name, type);\n-\t  else if (context && TREE_CODE (context) == FUNCTION_DECL)\n-\t    {\n-\t      /* Function-nested class.  */\n-\t      set_nested_typename (d, DECL_ASSEMBLER_NAME (c_decl),\n-\t\t\t\t   name, type);\n-\t      /* This builds the links for classes nested in fn scope.  */\n-\t      DECL_CONTEXT (d) = context;\n-\t    }\n-/*        else if (TYPE_SIZE (current_class_type) == NULL_TREE)\n-*/\n-\t  else if (context && IS_AGGR_TYPE (context))\n-\t    {\n-\t      /* Class-nested class.  */\n-\t      set_nested_typename (d, DECL_NESTED_TYPENAME (c_decl),\n-\t\t\t\t   name, type);\n-\t      /* This builds the links for classes nested in type scope.  */\n \t      DECL_CONTEXT (d) = context;\n+\t      TYPE_CONTEXT (type) = DECL_CONTEXT (d);\n+\t      DECL_ASSEMBLER_NAME (d)\n+\t\t= get_identifier (build_overload_name (type, 1, 1));\n \t    }\n-\t  TYPE_CONTEXT (type) = DECL_CONTEXT (d);\n-\t  if (newdecl)\n-\t    DECL_ASSEMBLER_NAME (d)\n-\t      = get_identifier (build_overload_name (type, 1, 1));\n         }\n       if (b->parm_flag == 2)\n \t{\n@@ -2042,9 +2049,7 @@ decls_match (newdecl, olddecl)\n       else if (TREE_TYPE (newdecl) == NULL_TREE)\n \ttypes_match = 0;\n       else\n-\ttypes_match = (comptypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl), 1)\n-\t\t       && TREE_READONLY (newdecl) == TREE_READONLY (olddecl)\n-\t\t       && TREE_THIS_VOLATILE (newdecl) == TREE_THIS_VOLATILE (olddecl));\n+\ttypes_match = comptypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl), 1);\n     }\n \n   return types_match;\n@@ -2312,6 +2317,13 @@ duplicate_decls (newdecl, olddecl)\n \t\t  }\n \t      }\n \t}\n+      /* These bits are logically part of the type for non-functions.  */\n+      else if (TREE_READONLY (newdecl) != TREE_READONLY (olddecl)\n+\t       || TREE_THIS_VOLATILE (newdecl) != TREE_THIS_VOLATILE (olddecl))\n+\t{\n+\t  cp_pedwarn (\"type qualifiers for `%#D'\", newdecl);\n+\t  cp_pedwarn_at (\"conflict with previous decl `%#D'\", olddecl);\n+\t}\n     }\n \n   /* If new decl is `static' and an `extern' was seen previously,\n@@ -2347,6 +2359,8 @@ duplicate_decls (newdecl, olddecl)\n       register tree newtype = TREE_TYPE (newdecl);\n       register tree oldtype = TREE_TYPE (olddecl);\n \n+      DECL_NESTED_TYPENAME (newdecl) = DECL_NESTED_TYPENAME (olddecl);\n+\n       if (newtype != error_mark_node && oldtype != error_mark_node\n \t  && TYPE_LANG_SPECIFIC (newtype) && TYPE_LANG_SPECIFIC (oldtype))\n \t{\n@@ -2826,6 +2840,7 @@ pushdecl (x)\n \t    {\n \t      tree tname = DECL_NAME (name);\n \n+\t      /* This is a disgusting kludge for dealing with UPTs.  */\n \t      if (global_bindings_p () && ANON_AGGRNAME_P (tname))\n \t\t{\n   \t\t  /* do gratuitous C++ typedefing, and make sure that\n@@ -2837,7 +2852,10 @@ pushdecl (x)\n \t    }\n \t  my_friendly_assert (TREE_CODE (name) == TYPE_DECL, 140);\n \n-\t  if (! DECL_NESTED_TYPENAME (x))\n+\t  /* Don't set nested_typename on template type parms, for instance.\n+\t     Any artificial decls that need DECL_NESTED_TYPENAME will have it\n+\t     set in pushtag.  */\n+\t  if (! DECL_NESTED_TYPENAME (x) && ! DECL_ARTIFICIAL (x))\n \t    set_nested_typename (x, current_class_name, DECL_NAME (x), type);\n \n \t  if (type != error_mark_node\n@@ -3056,16 +3074,6 @@ pushdecl (x)\n \t}\n     }\n \n-  if (TREE_CODE (x) == TYPE_DECL && name != NULL_TREE)\n-    {\n-      if (current_class_name)\n-\t{\n-\t  if (! TREE_MANGLED (name))\n-\t    set_nested_typename (x, current_class_name, DECL_NAME (x),\n-\t\t\t\t TREE_TYPE (x));\n-\t}\n-    }\n-\n   /* Put decls on list in reverse order.\n      We will reverse them later if necessary.  */\n   TREE_CHAIN (x) = b->names;\n@@ -3190,7 +3198,11 @@ pushdecl_class_level (x)\n       if (TREE_CODE (x) == TYPE_DECL)\n \t{\n \t  set_identifier_type_value (name, TREE_TYPE (x));\n-\t  if (!DECL_NESTED_TYPENAME (x))\n+\n+\t  /* Don't set nested_typename on template type parms, for instance.\n+\t     Any artificial decls that need DECL_NESTED_TYPENAME will have it\n+\t     set in pushtag.  */\n+\t  if (! DECL_NESTED_TYPENAME (x) && ! DECL_ARTIFICIAL (x))\n \t    set_nested_typename (x, current_class_name, name, TREE_TYPE (x));\n \t}\n     }\n@@ -4259,6 +4271,22 @@ push_overloaded_decl_1 (x)\n   push_overloaded_decl (x, 0);\n }\n \n+#define builtin_function(NAME, TYPE, CODE, LIBNAME) \\\n+  define_function (NAME, TYPE, CODE, (void (*)())pushdecl, LIBNAME)\n+\n+#ifdef __GNUC__\n+__inline\n+#endif\n+tree auto_function (name, type, code)\n+     tree name, type;\n+     enum built_in_function code;\n+{\n+  return define_function\n+    (IDENTIFIER_POINTER (name), type, code, (void (*)())push_overloaded_decl_1,\n+     IDENTIFIER_POINTER (build_decl_overload (name, TYPE_ARG_TYPES (type),\n+\t\t\t\t\t      0)));\n+}\n+\n /* Create the predefined scalar types of C,\n    and some nodes representing standard constants (0, 1, (void *)0).\n    Initialize the global binding level.\n@@ -5733,6 +5761,9 @@ grok_reference_init (decl, type, init, cleanupp)\n   if (TREE_CODE (init) == TREE_LIST)\n     init = build_compound_expr (init);\n \n+  if (TREE_CODE (TREE_TYPE (init)) == REFERENCE_TYPE)\n+    init = convert_from_reference (init);\n+\n   if (TREE_CODE (TREE_TYPE (type)) != ARRAY_TYPE\n       && TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE)\n     {\n@@ -7442,7 +7473,12 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t      || id == ridpointers[(int) RID_WCHAR])\n \t    {\n \t      if (type)\n-\t\terror (\"extraneous `%T' ignored\", id);\n+\t\t{\n+\t\t  if (id == ridpointers[(int) RID_BOOL])\n+\t\t    error (\"`bool' is now a keyword\");\n+\t\t  else\n+\t\t    cp_error (\"extraneous `%T' ignored\", id);\n+\t\t}\n \t      else\n \t\t{\n \t\t  if (id == ridpointers[(int) RID_INT])\n@@ -9558,17 +9594,7 @@ grokparms (first_parm, funcdef_flag)\n \t\t\t}\n \t\t      else\n \t\t\tinit = require_instantiated_type (type, init, integer_zero_node);\n-\n-\t\t      /* Don't actually try to build up a reference here.  */\n-\t\t      {\n-\t\t\ttree t = type;\n-\t\t\tif (TREE_CODE (t) == REFERENCE_TYPE)\n-\t\t\t  t = TREE_TYPE (t);\n-\t\t\tinit = convert_for_initialization\n-\t\t\t  (NULL_TREE, t, init, LOOKUP_NORMAL,\n-\t\t\t   \"argument passing\", 0, 0);\n-\t\t      }\n-\t\t    }\n+\t    }\n #if 0 /* This is too early to check; trailing parms might be merged in by\n \t duplicate_decls.  */\n \t\t  else if (any_init)\n@@ -9961,73 +9987,6 @@ grok_op_properties (decl, virtualp, friendp)\n    the current frame for the name (since C++ allows new names in any\n    scope.)  */\n \n-/* avoid rewriting all callers of xref_tag */\n-static int xref_next_defn = 0;\n-\n-tree\n-xref_defn_tag (code_type_node, name, binfo)\n-     tree code_type_node;\n-     tree name, binfo;\n-{\n-  tree rv, ncp;\n-  xref_next_defn = 1;\n-\n-  if (class_binding_level)\n-    {\n-      tree n1;\n-      char *buf;\n-      /* we need to build a new IDENTIFIER_NODE for name which nukes\n-       * the pieces... */\n-/*\n-      n1 = IDENTIFIER_LOCAL_VALUE (current_class_name);\n-      if (n1)\n-\tn1 = DECL_NAME (n1);\n-      else\n-\tn1 = current_class_name;\n-*/\n-      n1 = TYPE_NAME (current_class_type);\n-      if (n1)\n-\tn1 = DECL_NESTED_TYPENAME(n1);\n-      else\n-\tn1 = current_class_name;\n-      \n-      buf = (char *) alloca (4 + IDENTIFIER_LENGTH (n1)\n-\t\t\t     + IDENTIFIER_LENGTH (name));\n-      \n-      sprintf (buf, \"%s::%s\", IDENTIFIER_POINTER (n1),\n-\t       IDENTIFIER_POINTER (name));\n-      ncp = get_identifier (buf);\n-#ifdef SPEW_DEBUG\n-      if (spew_debug)\n-\tprintf(\"*** %s ***\\n\", IDENTIFIER_POINTER (ncp));\n-#endif\n-#if 0\n-      IDENTIFIER_LOCAL_VALUE (name) =\n-\tbuild_decl (TYPE_DECL, ncp, NULL_TREE);\n-#endif\n-      rv = xref_tag (code_type_node, name, binfo, 0);\n-      if (! ANON_AGGRNAME_P (name))\n-      {\n-\tregister tree type_decl = build_decl (TYPE_DECL, ncp, rv);\n-\tSET_DECL_ARTIFICIAL (type_decl);\n-#ifdef DWARF_DEBUGGING_INFO\n-\t/* Mark the TYPE_DECL node created just above as a gratuitous one\n-\t   so that dwarfout.c will know not to generate a TAG_typedef DIE\n-\t   for it.  */\n-\tif (write_symbols == DWARF_DEBUG)\n-\t  DECL_IGNORED_P (type_decl) = 1;\n-#endif /* DWARF_DEBUGGING_INFO */\n-\tpushdecl_nonclass_level (type_decl);\n-      }\n-    }\n-  else\n-    {\n-      rv = xref_tag (code_type_node, name, binfo, 0);\n-    }\n-  xref_next_defn = 0;\n-  return rv;\n-}\n-\n tree\n xref_tag (code_type_node, name, binfo, globalize)\n      tree code_type_node;\n@@ -10037,7 +9996,7 @@ xref_tag (code_type_node, name, binfo, globalize)\n   enum tag_types tag_code;\n   enum tree_code code;\n   int temp = 0;\n-  int i, len;\n+  int i;\n   register tree ref, t;\n   struct binding_level *b = inner_binding_level;\n \n@@ -10048,16 +10007,9 @@ xref_tag (code_type_node, name, binfo, globalize)\n     case class_type:\n     case signature_type:\n       code = RECORD_TYPE;\n-      len = list_length (binfo);\n       break;\n     case union_type:\n       code = UNION_TYPE;\n-      if (binfo)\n-\t{\n-\t  cp_error (\"derived union `%T' invalid\", name);\n-\t  binfo = NULL_TREE;\n-\t}\n-      len = 0;\n       break;\n     case enum_type:\n       code = ENUMERAL_TYPE;\n@@ -10072,18 +10024,12 @@ xref_tag (code_type_node, name, binfo, globalize)\n   if (t && TREE_CODE (t) != code)\n     t = NULL_TREE;\n \n-  if (xref_next_defn)\n+  if (! globalize)\n     {\n       /* If we know we are defining this tag, only look it up in this scope\n        * and don't try to find it as a type. */\n-      xref_next_defn = 0;\n-      if (t && TYPE_CONTEXT(t))\n-\t{\n-\t  if (TREE_MANGLED (name))\n-\t    ref = t;\n-\t  else\n-      \t    ref = lookup_tag (code, name, b, 1);\n-\t}\n+      if (t && TYPE_CONTEXT(t) && TREE_MANGLED (name))\n+\tref = t;\n       else\n       \tref = lookup_tag (code, name, b, 1);\n     }\n@@ -10180,6 +10126,7 @@ xref_tag (code_type_node, name, binfo, globalize)\n \t  && IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE)\n \tIDENTIFIER_GLOBAL_VALUE (name) = TYPE_NAME (ref);\n \n+#if 0\n       if (binfo)\n \t{\n \t  tree tt1 = binfo;\n@@ -10202,128 +10149,11 @@ xref_tag (code_type_node, name, binfo, globalize)\n \t     build them on the permanent obstack.  */\n \t  end_temporary_allocation ();\n \t}\n+#endif\n     }\n \n   if (binfo)\n-    {\n-      /* In the declaration `A : X, Y, ... Z' we mark all the types\n-\t (A, X, Y, ..., Z) so we can check for duplicates.  */\n-      tree binfos;\n-\n-      SET_CLASSTYPE_MARKED (ref);\n-      BINFO_BASETYPES (TYPE_BINFO (ref)) = binfos = make_tree_vec (len);\n-\n-      for (i = 0; binfo; binfo = TREE_CHAIN (binfo))\n-\t{\n-\t  /* The base of a derived struct is public by default.  */\n-\t  int via_public\n-\t    = (TREE_PURPOSE (binfo) == (tree)access_public\n-\t       || TREE_PURPOSE (binfo) == (tree)access_public_virtual\n-\t       || (tag_code != class_type\n-\t\t   && (TREE_PURPOSE (binfo) == (tree)access_default\n-\t\t       || TREE_PURPOSE (binfo) == (tree)access_default_virtual)));\n-\t  int via_protected = TREE_PURPOSE (binfo) == (tree)access_protected;\n-\t  int via_virtual\n-\t    = (TREE_PURPOSE (binfo) == (tree)access_private_virtual\n-\t       || TREE_PURPOSE (binfo) == (tree)access_public_virtual\n-\t       || TREE_PURPOSE (binfo) == (tree)access_default_virtual);\n-\t  tree basetype = TREE_TYPE (TREE_VALUE (binfo));\n-\t  tree base_binfo;\n-\n-\t  GNU_xref_hier (IDENTIFIER_POINTER (name),\n-\t\t\t IDENTIFIER_POINTER (TREE_VALUE (binfo)),\n-\t\t\t via_public, via_virtual, 0);\n-\n-\t  if (basetype && TREE_CODE (basetype) == TYPE_DECL)\n-\t    basetype = TREE_TYPE (basetype);\n-\t  if (!basetype || TREE_CODE (basetype) != RECORD_TYPE)\n-\t    {\n-\t      error (\"base type `%s' fails to be a struct or class type\",\n-\t\t     IDENTIFIER_POINTER (TREE_VALUE (binfo)));\n-\t      continue;\n-\t    }\n-#if 1\n-\t  /* This code replaces similar code in layout_basetypes.  */\n-\t  else if (TYPE_SIZE (basetype) == NULL_TREE)\n-\t    {\n-\t      cp_error (\"base class `%T' has incomplete type\", basetype);\n-\t      continue;\n-\t    }\n-#endif\n-\t  else\n-\t    {\n-\t      if (CLASSTYPE_MARKED (basetype))\n-\t\t{\n-\t\t  if (basetype == ref)\n-\t\t    cp_error (\"recursive type `%T' undefined\", basetype);\n-\t\t  else\n-\t\t    cp_error (\"duplicate base type `%T' invalid\", basetype);\n-\t\t  continue;\n-\t\t}\n-\n- \t      /* Note that the BINFO records which describe individual\n- \t\t inheritances are *not* shared in the lattice!  They\n- \t\t cannot be shared because a given baseclass may be\n- \t\t inherited with different `accessibility' by different\n- \t\t derived classes.  (Each BINFO record describing an\n- \t\t individual inheritance contains flags which say what\n- \t\t the `accessibility' of that particular inheritance is.)  */\n-  \n-\t      base_binfo = make_binfo (integer_zero_node, basetype,\n-\t\t\t\t  TYPE_BINFO_VTABLE (basetype),\n- \t\t\t\t  TYPE_BINFO_VIRTUALS (basetype), NULL_TREE);\n- \n-\t      TREE_VEC_ELT (binfos, i) = base_binfo;\n-\t      TREE_VIA_PUBLIC (base_binfo) = via_public;\n- \t      TREE_VIA_PROTECTED (base_binfo) = via_protected;\n-\t      TREE_VIA_VIRTUAL (base_binfo) = via_virtual;\n-\t      BINFO_INHERITANCE_CHAIN (base_binfo) = TYPE_BINFO (ref);\n-\n-\t      SET_CLASSTYPE_MARKED (basetype);\n-#if 0\n-/* XYZZY TEST VIRTUAL BASECLASSES */\n-if (CLASSTYPE_N_BASECLASSES (basetype) == NULL_TREE\n-    && TYPE_HAS_DEFAULT_CONSTRUCTOR (basetype)\n-    && via_virtual == 0)\n-  {\n-    warning (\"making type `%s' a virtual baseclass\",\n-\t     TYPE_NAME_STRING (basetype));\n-    via_virtual = 1;\n-  }\n-#endif\n-\t      /* We are free to modify these bits because they are meaningless\n-\t\t at top level, and BASETYPE is a top-level type.  */\n-\t      if (via_virtual || TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n-\t\t{\n-\t\t  TYPE_USES_VIRTUAL_BASECLASSES (ref) = 1;\n-\t\t  TYPE_USES_COMPLEX_INHERITANCE (ref) = 1;\n-\t\t}\n-\n-\t      TYPE_OVERLOADS_METHOD_CALL_EXPR (ref) |= TYPE_OVERLOADS_METHOD_CALL_EXPR (basetype);\n-\t      TYPE_GETS_NEW (ref) |= TYPE_GETS_NEW (basetype);\n-\t      TYPE_GETS_DELETE (ref) |= TYPE_GETS_DELETE (basetype);\n-\t      CLASSTYPE_LOCAL_TYPEDECLS (ref) |= CLASSTYPE_LOCAL_TYPEDECLS (basetype);\n-\t      i += 1;\n-\t    }\n-\t}\n-      if (i)\n-\tTREE_VEC_LENGTH (binfos) = i;\n-      else\n-\tBINFO_BASETYPES (TYPE_BINFO (ref)) = NULL_TREE;\n-\n-      if (i > 1)\n-\tTYPE_USES_MULTIPLE_INHERITANCE (ref) = 1;\n-      else if (i == 1)\n-\tTYPE_USES_MULTIPLE_INHERITANCE (ref)\n-\t  = TYPE_USES_MULTIPLE_INHERITANCE (BINFO_TYPE (TREE_VEC_ELT (binfos, 0)));\n-      if (TYPE_USES_MULTIPLE_INHERITANCE (ref))\n-\tTYPE_USES_COMPLEX_INHERITANCE (ref) = 1;\n-\n-      /* Unmark all the types.  */\n-      while (--i >= 0)\n-\tCLEAR_CLASSTYPE_MARKED (BINFO_TYPE (TREE_VEC_ELT (binfos, i)));\n-      CLEAR_CLASSTYPE_MARKED (ref);\n-    }\n+    xref_basetypes (code_type_node, name, ref, binfo);\n \n  just_return:\n \n@@ -10344,6 +10174,145 @@ if (CLASSTYPE_N_BASECLASSES (basetype) == NULL_TREE\n \n   return ref;\n }\n+\n+void\n+xref_basetypes (code_type_node, name, ref, binfo)\n+     tree code_type_node;\n+     tree name, ref;\n+     tree binfo;\n+{\n+  /* In the declaration `A : X, Y, ... Z' we mark all the types\n+     (A, X, Y, ..., Z) so we can check for duplicates.  */\n+  tree binfos;\n+  int i, len;\n+  enum tag_types tag_code = (enum tag_types) TREE_INT_CST_LOW (code_type_node);\n+\n+  if (tag_code == union_type)\n+    {\n+      cp_error (\"derived union `%T' invalid\", ref);\n+      return;\n+    }\n+\n+  len = list_length (binfo);\n+  push_obstacks (TYPE_OBSTACK (ref), TYPE_OBSTACK (ref));\n+\n+  SET_CLASSTYPE_MARKED (ref);\n+  BINFO_BASETYPES (TYPE_BINFO (ref)) = binfos = make_tree_vec (len);\n+\n+  for (i = 0; binfo; binfo = TREE_CHAIN (binfo))\n+    {\n+      /* The base of a derived struct is public by default.  */\n+      int via_public\n+\t= (TREE_PURPOSE (binfo) == (tree)access_public\n+\t   || TREE_PURPOSE (binfo) == (tree)access_public_virtual\n+\t   || (tag_code != class_type\n+\t       && (TREE_PURPOSE (binfo) == (tree)access_default\n+\t\t   || TREE_PURPOSE (binfo) == (tree)access_default_virtual)));\n+      int via_protected = TREE_PURPOSE (binfo) == (tree)access_protected;\n+      int via_virtual\n+\t= (TREE_PURPOSE (binfo) == (tree)access_private_virtual\n+\t   || TREE_PURPOSE (binfo) == (tree)access_public_virtual\n+\t   || TREE_PURPOSE (binfo) == (tree)access_default_virtual);\n+      tree basetype = TREE_TYPE (TREE_VALUE (binfo));\n+      tree base_binfo;\n+\n+      GNU_xref_hier (IDENTIFIER_POINTER (name),\n+\t\t     IDENTIFIER_POINTER (TREE_VALUE (binfo)),\n+\t\t     via_public, via_virtual, 0);\n+\n+      if (basetype && TREE_CODE (basetype) == TYPE_DECL)\n+\tbasetype = TREE_TYPE (basetype);\n+      if (!basetype || TREE_CODE (basetype) != RECORD_TYPE)\n+\t{\n+\t  cp_error (\"base type `%T' fails to be a struct or class type\",\n+\t\t    TREE_VALUE (binfo));\n+\t  continue;\n+\t}\n+#if 1\n+      /* This code replaces similar code in layout_basetypes.  */\n+      else if (TYPE_INCOMPLETE (basetype))\n+\t{\n+\t  cp_error (\"base class `%T' has incomplete type\", basetype);\n+\t  continue;\n+\t}\n+#endif\n+      else\n+\t{\n+\t  if (CLASSTYPE_MARKED (basetype))\n+\t    {\n+\t      if (basetype == ref)\n+\t\tcp_error (\"recursive type `%T' undefined\", basetype);\n+\t      else\n+\t\tcp_error (\"duplicate base type `%T' invalid\", basetype);\n+\t      continue;\n+\t    }\n+\n+\t  /* Note that the BINFO records which describe individual\n+\t     inheritances are *not* shared in the lattice!  They\n+\t     cannot be shared because a given baseclass may be\n+\t     inherited with different `accessibility' by different\n+\t     derived classes.  (Each BINFO record describing an\n+\t     individual inheritance contains flags which say what\n+\t     the `accessibility' of that particular inheritance is.)  */\n+  \n+\t  base_binfo = make_binfo (integer_zero_node, basetype,\n+\t\t\t\t   TYPE_BINFO_VTABLE (basetype),\n+\t\t\t\t   TYPE_BINFO_VIRTUALS (basetype), NULL_TREE);\n+ \n+\t  TREE_VEC_ELT (binfos, i) = base_binfo;\n+\t  TREE_VIA_PUBLIC (base_binfo) = via_public;\n+\t  TREE_VIA_PROTECTED (base_binfo) = via_protected;\n+\t  TREE_VIA_VIRTUAL (base_binfo) = via_virtual;\n+\t  BINFO_INHERITANCE_CHAIN (base_binfo) = TYPE_BINFO (ref);\n+\n+\t  SET_CLASSTYPE_MARKED (basetype);\n+#if 0\n+\t  /* XYZZY TEST VIRTUAL BASECLASSES */\n+\t  if (CLASSTYPE_N_BASECLASSES (basetype) == NULL_TREE\n+\t      && TYPE_HAS_DEFAULT_CONSTRUCTOR (basetype)\n+\t      && via_virtual == 0)\n+\t    {\n+\t      warning (\"making type `%s' a virtual baseclass\",\n+\t\t       TYPE_NAME_STRING (basetype));\n+\t      via_virtual = 1;\n+\t    }\n+#endif\n+\t  /* We are free to modify these bits because they are meaningless\n+\t     at top level, and BASETYPE is a top-level type.  */\n+\t  if (via_virtual || TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n+\t    {\n+\t      TYPE_USES_VIRTUAL_BASECLASSES (ref) = 1;\n+\t      TYPE_USES_COMPLEX_INHERITANCE (ref) = 1;\n+\t    }\n+\n+\t  TYPE_OVERLOADS_METHOD_CALL_EXPR (ref) |= TYPE_OVERLOADS_METHOD_CALL_EXPR (basetype);\n+\t  TYPE_GETS_NEW (ref) |= TYPE_GETS_NEW (basetype);\n+\t  TYPE_GETS_DELETE (ref) |= TYPE_GETS_DELETE (basetype);\n+\t  CLASSTYPE_LOCAL_TYPEDECLS (ref) |= CLASSTYPE_LOCAL_TYPEDECLS (basetype);\n+\t  i += 1;\n+\t}\n+    }\n+  if (i)\n+    TREE_VEC_LENGTH (binfos) = i;\n+  else\n+    BINFO_BASETYPES (TYPE_BINFO (ref)) = NULL_TREE;\n+\n+  if (i > 1)\n+    TYPE_USES_MULTIPLE_INHERITANCE (ref) = 1;\n+  else if (i == 1)\n+    TYPE_USES_MULTIPLE_INHERITANCE (ref)\n+      = TYPE_USES_MULTIPLE_INHERITANCE (BINFO_TYPE (TREE_VEC_ELT (binfos, 0)));\n+  if (TYPE_USES_MULTIPLE_INHERITANCE (ref))\n+    TYPE_USES_COMPLEX_INHERITANCE (ref) = 1;\n+\n+  /* Unmark all the types.  */\n+  while (--i >= 0)\n+    CLEAR_CLASSTYPE_MARKED (BINFO_TYPE (TREE_VEC_ELT (binfos, i)));\n+  CLEAR_CLASSTYPE_MARKED (ref);\n+\n+  pop_obstacks ();\n+}\n+  \n \f\n static tree current_local_enum = NULL_TREE;\n \n@@ -10452,19 +10421,23 @@ finish_enum (enumtype, values)\n \n     TYPE_SIZE (enumtype) = NULL_TREE;\n \n-    /* Lay out the type as though it were an integer.  */\n-    if (! flag_short_enums && precision < TYPE_PRECISION (integer_type_node))\n-      {\n-\tTYPE_MIN_VALUE (enumtype) = minnode;\n-\tTYPE_PRECISION (enumtype) = TYPE_PRECISION (integer_type_node);\n-\tlayout_type (enumtype);\n-      }\n+    /* Set TYPE_MIN_VALUE and TYPE_MAX_VALUE according to `precision'.  */\n \n     TYPE_PRECISION (enumtype) = precision;\n     if (unsignedp)\n       fixup_unsigned_type (enumtype);\n     else\n       fixup_signed_type (enumtype);\n+\n+    if (flag_short_enums || precision > TYPE_PRECISION (integer_type_node))\n+      /* Use the width of the narrowest normal C type which is wide enough.  */\n+      TYPE_PRECISION (enumtype) = TYPE_PRECISION (type_for_size\n+\t\t\t\t\t\t  (precision, 1));\n+    else\n+      TYPE_PRECISION (enumtype) = TYPE_PRECISION (integer_type_node);\n+\n+    TYPE_SIZE (enumtype) = 0;\n+    layout_type (enumtype);\n   }\n \n   if (flag_cadillac)\n@@ -11530,7 +11503,8 @@ finish_function (lineno, call_poplevel, nested)\n \n       if (call_poplevel)\n \t{\n-\t  expand_end_bindings (decls = getdecls (), decls != NULL_TREE, 0);\n+\t  decls = getdecls ();\n+\t  expand_end_bindings (decls, decls != NULL_TREE, 0);\n \t  poplevel (decls != NULL_TREE, 1, 0);\n \t}\n \n@@ -12002,11 +11976,6 @@ maybe_build_cleanup (decl)\n \t  || flag_expensive_optimizations)\n \tflags |= LOOKUP_NONVIRTUAL;\n \n-      /* Use TYPE_MAIN_VARIANT so we don't get a warning about\n-\t calling delete on a `const' variable.  */\n-      if (TYPE_READONLY (TREE_TYPE (TREE_TYPE (rval))))\n-\trval = build1 (NOP_EXPR, TYPE_POINTER_TO (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (rval)))), rval);\n-\n       rval = build_delete (TREE_TYPE (rval), rval, integer_two_node, flags, 0);\n \n       if (TYPE_USES_VIRTUAL_BASECLASSES (type)"}, {"sha": "32090e974a6a6ec9cfbcb134c1dd4192ee0ff958", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "patch": "@@ -683,11 +683,29 @@ substitute_nice_name (decl)\n    interface/implementation is not used all the times it should be,\n    inform the user.  */\n void\n-warn_if_unknown_interface ()\n+warn_if_unknown_interface (decl)\n+     tree decl;\n {\n   static int already_warned = 0;\n-  if (++already_warned == 1)\n-    warning (\"templates that are built with -fexternal-templates should be in files that have #pragma interface/implementation\");\n+  if (already_warned++)\n+    return;\n+\n+  if (flag_alt_external_templates)\n+    {\n+      struct tinst_level *til = tinst_for_decl ();\n+      int sl = lineno;\n+      char *sf = input_filename;\n+\n+      lineno = til->line;\n+      input_filename = til->file;\n+      cp_warning (\"template `%#D' instantiated in file without #pragma interface\",\n+\t\t  decl);\n+      lineno = sl;\n+      input_filename = sf;\n+    }\n+  else\n+    cp_warning_at (\"template `%#D' defined in file without #pragma interface\",\n+\t\t   decl);\n }\n \n /* A subroutine of the parser, to handle a component list.  */\n@@ -734,7 +752,7 @@ grok_x_components (specs, components)\n \t  else if (IS_SIGNATURE(t))\n \t    tcode = signature_type_node;\n \t  \n-\t  t = xref_defn_tag(tcode, TYPE_IDENTIFIER(t), NULL_TREE);\n+\t  t = xref_tag (tcode, TYPE_IDENTIFIER (t), NULL_TREE, 0);\n \t  if (TYPE_CONTEXT(t))\n \t    CLASSTYPE_NO_GLOBALIZE(t) = 1;\n \t  return NULL_TREE;\n@@ -747,7 +765,7 @@ grok_x_components (specs, components)\n \t  else\n \t    tcode = enum_type_node;\n \n-\t  t = xref_defn_tag(tcode, TYPE_IDENTIFIER(t), NULL_TREE);\n+\t  t = xref_tag (tcode, TYPE_IDENTIFIER (t), NULL_TREE, 0);\n \t  if (TREE_CODE(t) == UNION_TYPE && TYPE_CONTEXT(t))\n \t    CLASSTYPE_NO_GLOBALIZE(t) = 1;\n \t  if (TREE_CODE (t) == UNION_TYPE\n@@ -1103,12 +1121,15 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n \n   if (code == POINTER_TYPE)\n     {\n+#if 0\n+      /* As of Valley Forge, you can delete a pointer to constant.  */\n       /* You can't delete a pointer to constant.  */\n       if (TREE_READONLY (TREE_TYPE (type)))\n \t{\n \t  error (\"`const *' cannot be deleted\");\n \t  return error_mark_node;\n \t}\n+#endif\n       /* You also can't delete functions.  */\n       if (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n \t{\n@@ -1288,7 +1309,6 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree)\n       DECL_CONTEXT (value) = current_class_type;\n       DECL_CLASS_CONTEXT (value) = current_class_type;\n       CLASSTYPE_LOCAL_TYPEDECLS (current_class_type) = 1;\n-      pushdecl_class_level (value);\n \n       /* If we declare a typedef name for something that has no name,\n \t the typedef name is used for linkage.  See 7.1.3 p4 94/0158. */\n@@ -1299,6 +1319,8 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree)\n \t  TYPE_NAME (TREE_TYPE (value)) = value;\n \t  TYPE_STUB_DECL (TREE_TYPE (value)) = value;\n \t}\n+\n+      pushdecl_class_level (value);\n       return value;\n     }\n "}, {"sha": "2be11e0d90daf62c7778b3ae8140d478944954f6", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "patch": "@@ -599,6 +599,7 @@ dump_decl (t, v)\n \t{\n \t  dump_type_prefix (TREE_TYPE (t), v);\n \t  OB_PUTC (' ');\n+\t  dump_readonly_or_volatile (t, after);\n \t}\n       /* DECL_CLASS_CONTEXT isn't being set in some cases.  Hmm...  */\n       if (DECL_CONTEXT (t)"}, {"sha": "6fc23ec85cdf30dd68d70b34fd46d5e1ecabde35", "filename": "gcc/cp/except.c", "status": "modified", "additions": 70, "deletions": 59, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "patch": "@@ -48,7 +48,12 @@ tree builtin_return_address_fndecl;\n #define __rs6000\n #endif\n #endif\n-#if defined(__i386) || defined(__rs6000) || defined(__hppa) || defined(__mc68000) || defined (__mips) || defined (__arm)\n+#ifdef mips\n+#ifndef __mips\n+#define __mips\n+#endif\n+#endif\n+#if defined(__i386) || defined(__rs6000) || defined(__hppa) || defined(__mc68000) || defined (__mips) || defined (__arm) || defined (__alpha)\n #define TRY_NEW_EH\n #endif\n #endif\n@@ -390,44 +395,45 @@ static tree TerminateFunctionCall;\n /* =================================================================== */\n \n struct labelNode {\n-    rtx label;\n-\tstruct labelNode *chain;\n- };\n+  rtx label;\n+  struct labelNode *chain;\n+};\n \n \n /* this is the most important structure here.  Basically this is how I store\n    an exception table entry internally. */\n struct ehEntry {\n-    rtx start_label;\n-\trtx end_label;\n-\trtx exception_handler_label;\n+  rtx start_label;\n+  rtx end_label;\n+  rtx exception_handler_label;\n \n-\ttree finalization;\n- };\n+  tree finalization;\n+  tree context;\n+};\n \n struct ehNode {\n-    struct ehEntry *entry;\n-\tstruct ehNode *chain;\n- };\n+  struct ehEntry *entry;\n+  struct ehNode *chain;\n+};\n \n struct ehStack {\n-    struct ehNode *top;\n- };\n+  struct ehNode *top;\n+};\n \n struct ehQueue {\n-    struct ehNode *head;\n-\tstruct ehNode *tail;\n- };\n+  struct ehNode *head;\n+  struct ehNode *tail;\n+};\n \n struct exceptNode {\n-    rtx catchstart;\n-\trtx catchend;\n+  rtx catchstart;\n+  rtx catchend;\n \n-\tstruct exceptNode *chain;\n- };\n+  struct exceptNode *chain;\n+};\n \n struct exceptStack {\n-\tstruct exceptNode *top;\n+  struct exceptNode *top;\n  };\n /* ========================================================================= */\n \n@@ -603,6 +609,7 @@ push_eh_entry (stack)\n   LABEL_PRESERVE_P (entry->exception_handler_label) = 1;\n \n   entry->finalization = NULL_TREE;\n+  entry->context = current_function_decl;\n \n   node->entry = entry;\n   node->chain = stack->top;\n@@ -715,6 +722,8 @@ lang_interim_eh (finalization)\n     start_protect ();\n }\n \n+extern tree auto_function PROTO((tree, tree, enum built_in_function));\n+\n /* sets up all the global eh stuff that needs to be initialized at the\n    start of compilation.\n \n@@ -735,44 +744,34 @@ init_exception_processing ()\n   tree catch_match_fndecl;\n   tree find_first_exception_match_fndecl;\n   tree unwind_fndecl;\n-  tree temp, PFV;\n-\n-  interim_eh_hook = lang_interim_eh;\n \n   /* void (*)() */\n-  PFV = build_pointer_type (build_function_type (void_type_node, void_list_node));\n+  tree PFV = build_pointer_type (build_function_type\n+\t\t\t\t (void_type_node, void_list_node));\n \n   /* arg list for the build_function_type call for set_terminate () and\n      set_unexpected () */\n-  temp = tree_cons (NULL_TREE, PFV, void_list_node);\n+  tree pfvlist = tree_cons (NULL_TREE, PFV, void_list_node);\n \n-  push_lang_context (lang_name_c);\n+  /* void (*pfvtype (void (*) ()))() */\n+  tree pfvtype = build_function_type (PFV, pfvlist);\n \n-  set_terminate_fndecl =\n-    define_function (\"set_terminate\",\n-\t\t     build_function_type (PFV, temp),\n-\t\t     NOT_BUILT_IN,\n-\t\t     pushdecl,\n-\t\t     0);\n-  set_unexpected_fndecl =\n-    define_function (\"set_unexpected\",\n-\t\t     build_function_type (PFV, temp),\n-\t\t     NOT_BUILT_IN,\n-\t\t     pushdecl,\n-\t\t     0);\n+  /* void vtype () */\n+  tree vtype = build_function_type (void_type_node, void_list_node);\n+  \n+  set_terminate_fndecl = auto_function (get_identifier (\"set_terminate\"),\n+\t\t\t\t\tpfvtype, NOT_BUILT_IN);\n+  set_unexpected_fndecl = auto_function (get_identifier (\"set_unexpected\"),\n+\t\t\t\t\t pfvtype, NOT_BUILT_IN);\n+  unexpected_fndecl = auto_function (get_identifier (\"unexpected\"),\n+\t\t\t\t     vtype, NOT_BUILT_IN);\n+  terminate_fndecl = auto_function (get_identifier (\"terminate\"),\n+\t\t\t\t    vtype, NOT_BUILT_IN);\n+\n+  interim_eh_hook = lang_interim_eh;\n+\n+  push_lang_context (lang_name_c);\n \n-  unexpected_fndecl =\n-    define_function (\"unexpected\",\n-\t\t     build_function_type (void_type_node, void_list_node),\n-\t\t     NOT_BUILT_IN,\n-\t\t     pushdecl,\n-\t\t     0);\n-  terminate_fndecl =\n-    define_function (\"terminate\",\n-\t\t     build_function_type (void_type_node, void_list_node),\n-\t\t     NOT_BUILT_IN,\n-\t\t     pushdecl,\n-\t\t     0);\n   catch_match_fndecl =\n     define_function (\"__throw_type_match\",\n \t\t     build_function_type (integer_type_node,\n@@ -843,6 +842,11 @@ init_exception_processing ()\n   saved_pc = gen_rtx (REG, Pmode, 7);\n   saved_throw_type = gen_rtx (REG, Pmode, 8);\n   saved_throw_value = gen_rtx (REG, Pmode, 9);\n+#endif\n+#ifdef __alpha\n+  saved_pc = gen_rtx (REG, Pmode, 9);\n+  saved_throw_type = gen_rtx (REG, Pmode, 10);\n+  saved_throw_value = gen_rtx (REG, Pmode, 11);\n #endif\n   new_eh_queue (&ehqueue);\n   new_eh_queue (&eh_table_output_queue);\n@@ -989,6 +993,7 @@ expand_start_all_catch ()\n   entry->end_label = gen_label_rtx ();\n   entry->exception_handler_label = gen_label_rtx ();\n   entry->finalization = TerminateFunctionCall;\n+  entry->context = current_function_decl;\n   assemble_external (TREE_OPERAND (Terminate, 0));\n   pop_rtl_from_perm ();\n \n@@ -1091,6 +1096,7 @@ expand_leftover_cleanups ()\n       entry.end_label = label;\n       entry.exception_handler_label = gen_label_rtx ();\n       entry.finalization = TerminateFunctionCall;\n+      entry.context = current_function_decl;\n       assemble_external (TREE_OPERAND (Terminate, 0));\n       pop_rtl_from_perm ();\n \n@@ -1243,13 +1249,15 @@ void expand_end_catch_block ()\n       emit_jump (throw_label);\n       /* No associated finalization.  */\n       entry.finalization = NULL_TREE;\n+      entry.context = current_function_decl;\n \n       /* Because we are reordered out of line, we have to protect this. */\n       /* label for the start of the protection region.  */\n       start_protect_label_rtx = pop_label_entry (&false_label_stack);\n \n       /* Cleanup the EH paramater.  */\n-      expand_end_bindings (decls = getdecls (), decls != NULL_TREE, 0);\n+      decls = getdecls ();\n+      expand_end_bindings (decls, decls != NULL_TREE, 0);\n       \n       /* label we emit to jump to if this catch block didn't match. */\n       emit_label (end_protect_label_rtx = pop_label_entry (&false_label_stack));\n@@ -1309,7 +1317,7 @@ do_unwind (throw_label)\n   easy_expand_asm (\"restore\");\n   emit_barrier ();\n #endif\n-#if defined(__i386) || defined(__rs6000) || defined(__hppa) || defined(__mc68000) || defined (__mips)\n+#if defined(__i386) || defined(__rs6000) || defined(__hppa) || defined(__mc68000) || defined (__mips) || defined(__alpha)\n   extern FILE *asm_out_file;\n   tree fcall;\n   tree params;\n@@ -1449,7 +1457,7 @@ expand_builtin_throw ()\n #ifndef sparc\n   /* On the SPARC, __builtin_return_address is already -8, no need to\n      subtract any more from it. */\n-  emit_insn (gen_add2_insn (return_val_rtx, GEN_INT (-1)));\n+  return_val_rtx = plus_constant (return_val_rtx, -1);\n #endif\n #endif\n \n@@ -1542,10 +1550,8 @@ expand_throw (exp)\n \trtx throw_type_rtx = expand_expr (throw_type, NULL_RTX, VOIDmode, 0);\n \trtx throw_value_rtx;\n \n-\texp = convert_to_reference (build_reference_type (build_type_variant (TREE_TYPE (exp), 1, 0)), exp, CONV_STATIC, LOOKUP_COMPLAIN, error_mark_node);\n-\n \t/* Make a copy of the thrown object.  WP 15.1.5  */\n-\texp = build_new (NULL_TREE, TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (exp))), exp, 0);\n+\texp = build_new (NULL_TREE, type, build_tree_list (NULL_TREE, exp), 0);\n \n \tif (exp == error_mark_node)\n \t  error (\"  in thrown expression\");\n@@ -1557,7 +1563,7 @@ expand_throw (exp)\n   else\n     {\n       /* rethrow current exception */\n-      /* This part is easy, as we dont' have to do anything else.  */\n+      /* This part is easy, as we don't have to do anything else.  */\n     }\n \n   emit_move_insn (saved_pc, gen_rtx (LABEL_REF, Pmode, label));\n@@ -1585,6 +1591,11 @@ build_exception_table ()\n \n  while (entry = dequeue_eh_entry (&eh_table_output_queue))\n    {\n+     tree context = entry->context;\n+\n+     if (context && ! TREE_ASM_WRITTEN (context))\n+       continue;\n+\n      if (count == 0)\n        {\n \t exception_section ();"}, {"sha": "9be741779ffa9b47a676fcdb39a64dac8ad0df5d", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "patch": "@@ -1193,17 +1193,17 @@ The below points out some flaws in g++'s exception handling, as it now\n stands.\n \n Only exact type matching or reference matching of throw types works.\n-Only works on a SPARC machines (like Suns), and i386 machines.  Partial\n-support is also in for rs6000, hppa, m68k and mips machines, but a stack\n-unwinder called __unwind_function has to be written, and added to\n-libgcc2 for them.  All completely constructed temps and local variables\n-are cleaned up in all unwinded scopes.  Completed parts of partially\n-constructed objects are not cleaned up.  Don't expect exception handling\n-to work right if you optimize, in fact the compiler will probably core\n-dump.  If two EH regions are the exact same size, the backend cannot\n-tell which one is first.  It punts by picking the last one, if they tie.\n-This is usually right.  We really should stick in a nop, if they are the\n-same size.\n+Only works on a SPARC machines (like Suns), i386 machines, arm machines\n+and rs6000 machines.  Partial support is also in for alpha, hppa, m68k\n+and mips machines, but a stack unwinder called __unwind_function has to\n+be written, and added to libgcc2 for them.  All completely constructed\n+temps and local variables are cleaned up in all unwinded scopes.\n+Completed parts of partially constructed objects are not cleaned up.\n+Don't expect exception handling to work right if you optimize, in fact\n+the compiler will probably core dump.  If two EH regions are the exact\n+same size, the backend cannot tell which one is first.  It punts by\n+picking the last one, if they tie.  This is usually right.  We really\n+should stick in a nop, if they are the same size.\n \n When we invoke the copy constructor for an exception object because it\n is passed by value, and if we take a hit (exception) inside the copy\n@@ -1223,14 +1223,14 @@ implements set compares, not exact list equality.  Type smashing should\n smash exception specifications using set union.\n \n Thrown objects are allocated on the heap, in the usual way, but they are\n-never deleted.  They should be deleted by the catch clauses.\n-\n-In stmt.c, expand_end_bindings attempts to eliminate the generation of\n-destructors for a binding contour if the code would be unreachable (last\n-insn == BARRIER). In this case, interim_eh_hook is never called for the\n-end of the lifetimes of auto variables, so the compiler generates\n-invalid assembler (the end label for the scope is never declared, and\n-destructor code isn't generated on the exception path).\n+never deleted.  They should be deleted by the catch clauses.  If one\n+runs out of heap space, throwing an object will probably never work.\n+This could be relaxed some by passing an __in_chrg parameter to track\n+who has control over the exception object.\n+\n+When the backend returns a value, it can create new exception regions\n+that need protecting.  The new region should rethrow the object in\n+context of the last associated cleanup that ran to completion.\n \n @node Free Store, Concept Index, Exception Handling, Top\n @section Free Store"}, {"sha": "cf8b0e7772a19825cf20c0754d3fe8a62174b45d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 63, "deletions": 67, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "patch": "@@ -574,6 +574,12 @@ emit_base_init (t, immediately)\n       tree base = current_class_decl;\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n \n+#if 0 /* Once unsharing happens soon enough.  */\n+      my_friendly_assert (BINFO_INHERITANCE_CHAIN (base_binfo) == t_binfo);\n+#else\n+      BINFO_INHERITANCE_CHAIN (base_binfo) = t_binfo;\n+#endif\n+\n       if (TYPE_NEEDS_CONSTRUCTING (BINFO_TYPE (base_binfo)))\n \t{\n \t  if (! TREE_VIA_VIRTUAL (base_binfo)\n@@ -1210,7 +1216,8 @@ expand_default_init (binfo, true_exp, exp, type, init, alias_this, flags)\n       if (parms)\n \tinit = TREE_VALUE (parms);\n     }\n-  else if (TREE_CODE (init) == INDIRECT_REF && TREE_HAS_CONSTRUCTOR (init))\n+  else if (TREE_CODE (init) == INDIRECT_REF && TREE_HAS_CONSTRUCTOR (init)\n+\t   && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (init)))\n     {\n       rval = convert_for_initialization (exp, type, init, 0, 0, 0, 0);\n       TREE_USED (rval) = 1;\n@@ -2932,11 +2939,8 @@ build_new (placement, decl, init, use_global_new)\n     }\n \n   if (TYPE_READONLY (type) || TYPE_VOLATILE (type))\n-    {\n-      pedwarn (\"const and volatile types cannot be created with operator new\");\n-      type = true_type = TYPE_MAIN_VARIANT (type);\n-    }\n-  \n+    type = TYPE_MAIN_VARIANT (type);\n+\n   /* If our base type is an array, then make sure we know how many elements\n      it has.  */\n   while (TREE_CODE (true_type) == ARRAY_TYPE)\n@@ -3000,7 +3004,7 @@ build_new (placement, decl, init, use_global_new)\n       rval = convert (TYPE_POINTER_TO (true_type), rval);\n     }\n   else if (! has_array && flag_this_is_variable > 0\n-\t   && TYPE_HAS_CONSTRUCTOR (true_type) && init != void_type_node)\n+\t   && TYPE_NEEDS_CONSTRUCTING (true_type) && init != void_type_node)\n     {\n       if (init == NULL_TREE || TREE_CODE (init) == TREE_LIST)\n \trval = NULL_TREE;\n@@ -3061,57 +3065,8 @@ build_new (placement, decl, init, use_global_new)\n \t\t\t\t\t     build_tree_list (NULL_TREE, rval)));\n     }\n \n-  /* We've figured out where the allocation is to go.\n-     If we're not eliding constructors, then if a constructor\n-     is defined, we must go through it.  */\n-  if (!has_array && (rval == NULL_TREE || !flag_elide_constructors)\n-      && TYPE_HAS_CONSTRUCTOR (true_type) && init != void_type_node)\n-    {\n-      tree newrval;\n-      /* Constructors are never virtual. If it has an initialization, we\n-\t need to complain if we aren't allowed to use the ctor that took\n-\t that argument.  */\n-      int flags = LOOKUP_NORMAL|LOOKUP_NONVIRTUAL|LOOKUP_COMPLAIN;\n-\n-      /* If a copy constructor might work, set things up so that we can\n-\t try that after this.  We deliberately don't clear LOOKUP_COMPLAIN\n-\t any more, since that would make it impossible to rationally use\n-\t the access of a constructor that matches perfectly.  */\n-#if 0\n-      if (rval != NULL_TREE)\n-\tflags |= LOOKUP_SPECULATIVELY;\n-#endif\n-\n-      if (rval && TYPE_USES_VIRTUAL_BASECLASSES (true_type))\n-\t{\n-\t  init = tree_cons (NULL_TREE, integer_one_node, init);\n-\t  flags |= LOOKUP_HAS_IN_CHARGE;\n-\t}\n-\n-      {\n-\ttree tmp = rval;\n-\t\n-\tif (tmp && TREE_CODE (TREE_TYPE (tmp)) == POINTER_TYPE)\n-\t  tmp = build_indirect_ref (tmp, NULL_PTR);\n-      \n-\tnewrval = build_method_call (tmp, constructor_name_full (true_type),\n-\t\t\t\t     init, NULL_TREE, flags);\n-      }\n-      \n-      if (newrval)\n-\t{\n-\t  rval = newrval;\n-\t  TREE_HAS_CONSTRUCTOR (rval) = 1;\n-\t}\n-      else\n-\trval = error_mark_node;\n-      goto done;\n-    }\n-\n   if (rval == error_mark_node)\n     return error_mark_node;\n-  rval = save_expr (rval);\n-  TREE_HAS_CONSTRUCTOR (rval) = 1;\n \n   /* Don't call any constructors or do any initialization.  */\n   if (init == void_type_node)\n@@ -3123,20 +3078,60 @@ build_new (placement, decl, init, use_global_new)\n \t{\n \t  /* New 2.0 interpretation: `new int (10)' means\n \t     allocate an int, and initialize it with 10.  */\n+\t  tree deref;\n+\n+\t  rval = save_expr (rval);\n+\t  deref = build_indirect_ref (rval, NULL_PTR);\n+\t  TREE_READONLY (deref) = 0;\n \n-\t  init = build_c_cast (type, init, 1);\n+\t  if (TREE_CHAIN (init) != NULL_TREE)\n+\t    pedwarn (\"initializer list being treated as compound expression\");\n+\t  init = build_compound_expr (init);\n+\n+\t  init = convert_for_initialization (deref, type, init, LOOKUP_NORMAL,\n+\t\t\t\t\t     \"new\", NULL_TREE, 0);\n \t  rval = build (COMPOUND_EXPR, TREE_TYPE (rval),\n-\t\t\tbuild_modify_expr (build_indirect_ref (rval, NULL_PTR),\n-\t\t\t\t\t   NOP_EXPR, init),\n+\t\t\tbuild_modify_expr (deref, NOP_EXPR, init),\n \t\t\trval);\n \t  TREE_SIDE_EFFECTS (rval) = 1;\n \t  TREE_CALLS_NEW (rval) = 1;\n \t}\n+      else if (! has_array)\n+\t{\n+\t  tree newrval;\n+\t  /* Constructors are never virtual. If it has an initialization, we\n+\t     need to complain if we aren't allowed to use the ctor that took\n+\t     that argument.  */\n+\t  int flags = LOOKUP_NORMAL|LOOKUP_NONVIRTUAL|LOOKUP_COMPLAIN;\n+\n+\t  if (rval && TYPE_USES_VIRTUAL_BASECLASSES (true_type))\n+\t    {\n+\t      init = tree_cons (NULL_TREE, integer_one_node, init);\n+\t      flags |= LOOKUP_HAS_IN_CHARGE;\n+\t    }\n+\n+\t  newrval = rval;\n+\n+\t  if (newrval && TREE_CODE (TREE_TYPE (newrval)) == POINTER_TYPE)\n+\t    newrval = build_indirect_ref (newrval, NULL_PTR);\n+\n+\t  newrval = build_method_call (newrval, constructor_name_full (true_type),\n+\t\t\t\t       init, NULL_TREE, flags);\n+\n+\t  if (newrval)\n+\t    {\n+\t      rval = newrval;\n+\t      TREE_HAS_CONSTRUCTOR (rval) = 1;\n+\t    }\n+\t  else\n+\t    rval = error_mark_node;\n+\t}\n       else if (current_function_decl == NULL_TREE)\n \t{\n \t  extern tree static_aggregates;\n \n \t  /* In case of static initialization, SAVE_EXPR is good enough.  */\n+\t  rval = save_expr (rval);\n \t  init = copy_to_permanent (init);\n \t  rval = copy_to_permanent (rval);\n \t  static_aggregates = perm_tree_cons (init, rval, static_aggregates);\n@@ -3156,12 +3151,11 @@ build_new (placement, decl, init, use_global_new)\n \t  /* As a matter of principle, `start_sequence' should do this.  */\n \t  emit_note (0, -1);\n \n-\t  if (has_array)\n-\t    rval = expand_vec_init (decl, rval,\n-\t\t\t\t    build_binary_op (MINUS_EXPR, nelts, integer_one_node, 1),\n-\t\t\t\t    init, 0);\n-\t  else\n-\t    expand_aggr_init (build_indirect_ref (rval, NULL_PTR), init, 0, 0);\n+\t  rval = save_expr (rval);\n+\t  rval = expand_vec_init (decl, rval,\n+\t\t\t\t  build_binary_op (MINUS_EXPR, nelts,\n+\t\t\t\t\t\t   integer_one_node, 1),\n+\t\t\t\t  init, 0);\n \n \t  do_pending_stack_adjust ();\n \n@@ -3185,13 +3179,15 @@ build_new (placement, decl, init, use_global_new)\n \t  rval = xval;\n \t}\n     }\n+  else if (TYPE_READONLY (true_type))\n+    cp_error (\"uninitialized const in `new' of `%#T'\", true_type);\n+\n  done:\n \n   if (flag_check_new && alloc_expr && rval != alloc_expr)\n     {\n       tree ifexp = build_binary_op (NE_EXPR, alloc_expr, integer_zero_node, 1);\n-      rval = build_conditional_expr (ifexp, rval, convert (TREE_TYPE (rval),\n-\t\t\t\t\t\t\t   integer_zero_node));\n+      rval = build_conditional_expr (ifexp, rval, alloc_expr);\n     }\n \n   if (rval && TREE_TYPE (rval) != build_pointer_type (type))"}, {"sha": "89a90ded3fac839d6641163b1384c681c8537171", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "patch": "@@ -1539,7 +1539,7 @@ reinit_parse_for_method (yychar, decl)\n       t->can_free = 1;\n       t->deja_vu = 0;\n       if (interface_unknown && processing_template_defn && flag_external_templates && ! DECL_IN_SYSTEM_HEADER (decl))\n-\twarn_if_unknown_interface ();\n+\twarn_if_unknown_interface (decl);\n       t->interface = (interface_unknown ? 1 : (interface_only ? 0 : 2));\n       store_pending_inline (decl, t);\n     }\n@@ -1700,8 +1700,8 @@ reinit_parse_for_block (yychar, obstackp, is_template)\n    When KIND == 6, build default operator = (X&).  */\n \n tree\n-cons_up_default_function (type, name, kind)\n-     tree type, name;\n+cons_up_default_function (type, full_name, kind)\n+     tree type, full_name;\n      int kind;\n {\n   extern tree void_list_node;\n@@ -1712,8 +1712,8 @@ cons_up_default_function (type, name, kind)\n   tree argtype;\n   int retref = 0;\n   int complex = 0;\n+  tree name = constructor_name (full_name);\n \n-  name = constructor_name (name);\n   switch (kind)\n     {\n       /* Destructors.  */\n@@ -1750,7 +1750,7 @@ cons_up_default_function (type, name, kind)\n       /* Fall through...  */\n     case 6:\n       retref = 1;\n-      declspecs = build_decl_list (NULL_TREE, name);\n+      declspecs = build_decl_list (NULL_TREE, full_name);\n \n       name = ansi_opname [(int) MODIFY_EXPR];\n "}, {"sha": "f185ebe17695c40a816da8aeeb6fedfd8fbed7bf", "filename": "gcc/cp/method.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "patch": "@@ -2069,7 +2069,9 @@ do_build_copy_constructor (fndecl)\n \t   t = TREE_CHAIN (t))\n \t{\n \t  tree basetype = BINFO_TYPE (t);\n-\t  tree p = convert (build_reference_type (basetype), parm);\n+\t  tree p = convert_to_reference\n+\t    (build_reference_type (basetype), parm,\n+\t     CONV_IMPLICIT|CONV_CONST, LOOKUP_COMPLAIN, NULL_TREE);\n \t  p = convert_from_reference (p);\n \t  current_base_init_list = tree_cons (TYPE_NESTED_NAME (basetype),\n \t\t\t\t\t      p, current_base_init_list);\n@@ -2079,10 +2081,12 @@ do_build_copy_constructor (fndecl)\n \t{\n \t  tree p, basetype = TREE_VEC_ELT (binfos, i);\n \t  if (TREE_VIA_VIRTUAL (basetype))\n-\t    continue;\t  \n+\t    continue; \n \n \t  basetype = BINFO_TYPE (basetype);\n-\t  p = convert (build_reference_type (basetype), parm);\n+\t  p = convert_to_reference\n+\t    (build_reference_type (basetype), parm,\n+\t     CONV_IMPLICIT|CONV_CONST, LOOKUP_COMPLAIN, NULL_TREE);\n \t  p = convert_from_reference (p);\n \t  current_base_init_list = tree_cons (TYPE_NESTED_NAME (basetype),\n \t\t\t\t\t      p, current_base_init_list);\n@@ -2153,7 +2157,9 @@ do_build_assign_ref (fndecl)\n \t  tree basetype = BINFO_TYPE (TREE_VEC_ELT (binfos, i));\n \t  if (TYPE_HAS_ASSIGN_REF (basetype))\n \t    {\n-\t      tree p = convert (build_reference_type (basetype), parm);\n+\t      tree p = convert_to_reference\n+\t\t(build_reference_type (basetype), parm,\n+\t\t CONV_IMPLICIT|CONV_CONST, LOOKUP_COMPLAIN, NULL_TREE);\n \t      p = convert_from_reference (p);\n \t      p = build_member_call (TYPE_NESTED_NAME (basetype),\n \t\t\t\t     ansi_opname [MODIFY_EXPR],"}, {"sha": "102ca63e131b81ab070c04d7aca361aa021577b1", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 33, "deletions": 46, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "patch": "@@ -280,7 +280,7 @@ empty_parms ()\n /* Used in lex.c for parsing pragmas.  */\n %token END_OF_LINE\n \n-/* spew.c depends on this being the last token.  Define\n+/* lex.c and pt.c depends on this being the last token.  Define\n    any new tokens before this one!  */\n %token END_OF_SAVED_INPUT\n \f\n@@ -940,8 +940,7 @@ paren_expr_or_null:\n \t\t\t cond_stmt_keyword);\n \t\t  $$ = integer_zero_node; }\n \t| '(' expr ')'\n-\t\t{ $$ = build1 (CLEANUP_POINT_EXPR, boolean_type_node, \n-\t\t\t       bool_truthvalue_conversion ($2)); }\n+\t\t{ $$ = condition_conversion ($2); }\n \t;\n \n paren_cond_or_null:\n@@ -950,16 +949,14 @@ paren_cond_or_null:\n \t\t\t cond_stmt_keyword);\n \t\t  $$ = integer_zero_node; }\n \t| '(' condition ')'\n-\t\t{ $$ = build1 (CLEANUP_POINT_EXPR, boolean_type_node, \n-\t\t\t       bool_truthvalue_conversion ($2)); }\n+\t\t{ $$ = condition_conversion ($2); }\n \t;\n \n xcond:\n \t/* empty */\n \t\t{ $$ = NULL_TREE; }\n \t| condition\n-\t\t{ $$ = build1 (CLEANUP_POINT_EXPR, boolean_type_node, \n-\t\t\t       bool_truthvalue_conversion ($$)); }\n+\t\t{ $$ = condition_conversion ($$); }\n \t| error\n \t\t{ $$ = NULL_TREE; }\n \t;\n@@ -1800,6 +1797,7 @@ type_id:\n typed_declspecs:\n \t  typed_typespecs %prec EMPTY\n \t| typed_declspecs1\n+\t;\n \n typed_declspecs1:\n \t  declmods typespec\n@@ -2151,9 +2149,9 @@ structsp:\n \t\t{ $$ = finish_enum (start_enum (make_anon_name()), NULL_TREE);\n \t\t  check_for_missing_semicolon ($$); }\n \t| ENUM identifier\n-\t\t{ $$ = xref_tag (enum_type_node, $2, NULL_TREE, 0); }\n+\t\t{ $$ = xref_tag (enum_type_node, $2, NULL_TREE, 1); }\n \t| ENUM complex_type_name\n-\t\t{ $$ = xref_tag (enum_type_node, $2, NULL_TREE, 0); }\n+\t\t{ $$ = xref_tag (enum_type_node, $2, NULL_TREE, 1); }\n \n \t/* C++ extensions, merged with C to avoid shift/reduce conflicts */\n \t| class_head left_curly opt.component_decl_list '}'\n@@ -2206,16 +2204,11 @@ structsp:\n \t\t    check_for_missing_semicolon ($$); }\n \t| class_head  %prec EMPTY\n \t\t{\n-#if 0\n-  /* It's no longer clear what the following error is supposed to\n-     accomplish.  If it turns out to be needed, add a comment why.  */\n-\t\t  if (TYPE_BINFO_BASETYPES ($$) && !TYPE_SIZE ($$))\n-\t\t    {\n-\t\t      error (\"incomplete definition of type `%s'\",\n-\t\t\t     TYPE_NAME_STRING ($$));\n-\t\t      $$ = error_mark_node;\n-\t\t    }\n-#endif\n+\t\t  /* struct B: public A; is not accepted by the WP grammar.  */\n+\t\t  if (TYPE_BINFO_BASETYPES ($$) && !TYPE_SIZE ($$)\n+\t\t      && ! TYPE_BEING_DEFINED ($$))\n+\t\t    cp_error (\"base clause without member specification for `%#T'\",\n+\t\t\t      $$);\n \t\t}\n \t;\n \n@@ -2257,6 +2250,12 @@ named_class_head_sans_basetype:\n \t\t{ current_aggr = $$; $$ = $2; }\n \t| aggr template_type %prec EMPTY\n \t\t{ current_aggr = $$; $$ = $2; }\n+\t| specialization\n+\t;\n+\n+named_class_head_sans_basetype_defn:\n+\t  aggr identifier_defn %prec EMPTY\n+\t\t{ current_aggr = $$; $$ = $2; }\n \t| aggr template_type_name '{'\n \t\t{ yyungetc ('{', 1);\n \t\taggr2:\n@@ -2265,37 +2264,21 @@ named_class_head_sans_basetype:\n \t\t  overload_template_name ($$, 0); }\n \t| aggr template_type_name ':'\n \t\t{ yyungetc (':', 1); goto aggr2; }\n-\t| specialization\n \t;\n \n-named_class_head_sans_basetype_defn:\n-\t  aggr identifier_defn %prec EMPTY\n-\t\t{ current_aggr = $$; $$ = $2; }\n-\t;\n-\n-do_xref: /* empty */ %prec EMPTY\n-\t{ $<ttype>$ = xref_tag (current_aggr, $<ttype>0, NULL_TREE, 1); }\n-\n do_xref_defn: /* empty */ %prec EMPTY\n-\t{ $<ttype>$ = xref_defn_tag (current_aggr, $<ttype>0, NULL_TREE); }\n+        { $<ttype>$ = xref_tag (current_aggr, $<ttype>0, NULL_TREE, 0); }\n+\t;\n \n named_class_head:\n-\t  named_class_head_sans_basetype do_xref\n-\t  maybe_base_class_list %prec EMPTY\n-\t\t{\n-\t\t  if ($3)\n-\t\t    $$ = xref_tag (current_aggr, $1, $3, 1);\n-\t\t  else\n-\t\t    $$ = $<ttype>2;\n-\t\t}\n-\t|\n-\t  named_class_head_sans_basetype_defn do_xref_defn\n-\t  maybe_base_class_list %prec EMPTY\n-\t\t{\n+\t  named_class_head_sans_basetype %prec EMPTY\n+\t\t{ $$ = xref_tag (current_aggr, $1, NULL_TREE, 1); }\n+\t| named_class_head_sans_basetype_defn do_xref_defn\n+          maybe_base_class_list %prec EMPTY\n+\t\t{ \n+\t\t  $$ = $<ttype>2;\n \t\t  if ($3)\n-\t\t    $$ = xref_defn_tag (current_aggr, $1, $3);\n-\t\t  else\n-\t\t    $$ = $<ttype>2;\n+                    xref_basetypes (current_aggr, $1, $<ttype>2, $3); \n \t\t}\n \t;\n \n@@ -3472,8 +3455,12 @@ handler_seq:\n \t  /* empty */\n \t| handler_seq CATCH\n \t\t{ emit_line_note (input_filename, lineno); }\n-\t  handler_args compstmt\n-\t\t{ expand_end_catch_block (); }\n+          .pushlevel handler_args compstmt\n+\t\t{ expand_end_catch_block ();\n+\t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n+\t\t  poplevel (kept_level_p (), 1, 0);\n+\t\t  pop_momentary ();\n+\t\t}\n \t;\n \n type_specifier_seq:"}, {"sha": "5804bb6b87c724daa6331f49ba8c49752a012dcf", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "patch": "@@ -128,6 +128,7 @@ process_template_parm (list, next)\n \t    defval = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (defval));\n \t}\n     }\n+  SET_DECL_ARTIFICIAL (decl);\n   pushdecl (decl);\n   parm = build_tree_list (defval, parm);\n   return chainon (list, parm);\n@@ -238,8 +239,10 @@ end_template_decl (d1, d2, is_class, defn)\n \t  DECL_CLASS_CONTEXT (decl) = DECL_CLASS_CONTEXT (d2);\n \t  DECL_NAME (decl) = DECL_NAME (d2);\n \t  TREE_TYPE (decl) = TREE_TYPE (d2);\n-\t  if (interface_unknown && flag_external_templates && ! DECL_IN_SYSTEM_HEADER (decl))\n-\t    warn_if_unknown_interface ();\n+\t  if (interface_unknown && flag_external_templates\n+\t      && ! flag_alt_external_templates\n+\t      && ! DECL_IN_SYSTEM_HEADER (decl))\n+\t    warn_if_unknown_interface (decl);\n \t  TREE_PUBLIC (decl) = TREE_PUBLIC (d2) = flag_external_templates && !interface_unknown;\n \t  DECL_EXTERNAL (decl) = (DECL_EXTERNAL (d2)\n \t\t\t\t  && !(DECL_CLASS_CONTEXT (d2)\n@@ -690,6 +693,7 @@ push_template_decls (parmlist, arglist, class_level)\n \t}\n       if (decl != 0)\n \t{\n+\t  SET_DECL_ARTIFICIAL (decl);\n \t  layout_decl (decl, 0);\n \t  if (class_level)\n \t    pushdecl_class_level (decl);\n@@ -1755,7 +1759,7 @@ instantiate_template (tmpl, targ_ptr)\n \t\t  = CLASSTYPE_INTERFACE_ONLY (DECL_CLASS_CONTEXT (fndecl));\n \t      }\n \t    else if (! DECL_IN_SYSTEM_HEADER (tmpl))\n-\t      warn_if_unknown_interface ();\n+\t      warn_if_unknown_interface (tmpl);\n \t  }\n \n \tif (interface_unknown || ! flag_external_templates)\n@@ -1850,7 +1854,7 @@ overload_template_name (id, classlevel)\n     }\n #endif\n \n-  t = xref_tag (tinfo->aggr, id, NULL_TREE, 0);\n+  t = xref_tag (tinfo->aggr, id, NULL_TREE, 1);\n   my_friendly_assert (TREE_CODE (t) == RECORD_TYPE\n \t\t      || TREE_CODE (t) == UNION_TYPE\n \t\t      || TREE_CODE (t) == UNINSTANTIATED_P_TYPE, 286);"}, {"sha": "4424423b07be775de44326048343b1bad36d2eb8", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 77, "deletions": 16, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "patch": "@@ -31,6 +31,79 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    Lvalues can be assigned, unless they have TREE_READONLY.\n    Lvalues can have their address taken, unless they have DECL_REGISTER.  */\n \n+int\n+real_lvalue_p (ref)\n+     tree ref;\n+{\n+  if (! language_lvalue_valid (ref))\n+    return 0;\n+  \n+  if (TREE_CODE (TREE_TYPE (ref)) == REFERENCE_TYPE)\n+    return 1;\n+\n+  if (ref == current_class_decl && flag_this_is_variable <= 0)\n+    return 0;\n+\n+  switch (TREE_CODE (ref))\n+    {\n+      /* preincrements and predecrements are valid lvals, provided\n+\t what they refer to are valid lvals. */\n+    case PREINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case COMPONENT_REF:\n+    case SAVE_EXPR:\n+      return real_lvalue_p (TREE_OPERAND (ref, 0));\n+\n+    case STRING_CST:\n+      return 1;\n+\n+    case VAR_DECL:\n+      if (TREE_READONLY (ref) && ! TREE_STATIC (ref)\n+\t  && DECL_LANG_SPECIFIC (ref)\n+\t  && DECL_IN_AGGR_P (ref))\n+\treturn 0;\n+    case INDIRECT_REF:\n+    case ARRAY_REF:\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+    case ERROR_MARK:\n+      if (TREE_CODE (TREE_TYPE (ref)) != FUNCTION_TYPE\n+\t  && TREE_CODE (TREE_TYPE (ref)) != METHOD_TYPE)\n+\treturn 1;\n+      break;\n+\n+    case WITH_CLEANUP_EXPR:\n+      return real_lvalue_p (TREE_OPERAND (ref, 0));\n+\n+      /* A currently unresolved scope ref.  */\n+    case SCOPE_REF:\n+      my_friendly_abort (103);\n+    case OFFSET_REF:\n+      if (TREE_CODE (TREE_OPERAND (ref, 1)) == FUNCTION_DECL)\n+\treturn 1;\n+      return real_lvalue_p (TREE_OPERAND (ref, 0))\n+\t&& real_lvalue_p (TREE_OPERAND (ref, 1));\n+      break;\n+\n+    case COND_EXPR:\n+      return (real_lvalue_p (TREE_OPERAND (ref, 1))\n+\t      && real_lvalue_p (TREE_OPERAND (ref, 2)));\n+\n+    case MODIFY_EXPR:\n+      return 1;\n+\n+    case COMPOUND_EXPR:\n+      return real_lvalue_p (TREE_OPERAND (ref, 1));\n+\n+    case MAX_EXPR:\n+    case MIN_EXPR:\n+      return (real_lvalue_p (TREE_OPERAND (ref, 0))\n+\t      && real_lvalue_p (TREE_OPERAND (ref, 1)));\n+    }\n+\n+  return 0;\n+}\n+\n int\n lvalue_p (ref)\n      tree ref;\n@@ -496,6 +569,7 @@ propagate_binfo_offsets (binfo, offset)\n \t\t  chain = TREE_VEC_ELT (base_binfos, k);\n \t\t  TREE_VIA_PUBLIC (chain) = TREE_VIA_PUBLIC (base_base_binfo);\n \t\t  TREE_VIA_PROTECTED (chain) = TREE_VIA_PROTECTED (base_base_binfo);\n+\t\t  BINFO_INHERITANCE_CHAIN (chain) = base_binfo;\n \t\t}\n \t      /* Now propagate the offset to the base types.  */\n \t      propagate_binfo_offsets (base_binfo, offset);\n@@ -616,6 +690,8 @@ layout_vbasetypes (rec, max)\n     {\n       tree base_binfos = BINFO_BASETYPES (vbase_types);\n \n+      BINFO_INHERITANCE_CHAIN (vbase_types) = TYPE_BINFO (rec);\n+\n       if (base_binfos)\n \t{\n \t  tree chain = NULL_TREE;\n@@ -636,6 +712,7 @@ layout_vbasetypes (rec, max)\n \t      chain = TREE_VEC_ELT (base_binfos, j);\n \t      TREE_VIA_PUBLIC (chain) = TREE_VIA_PUBLIC (base_base_binfo);\n \t      TREE_VIA_PROTECTED (chain) = TREE_VIA_PROTECTED (base_base_binfo);\n+\t      BINFO_INHERITANCE_CHAIN (chain) = vbase_types;\n \t    }\n \n \t  propagate_binfo_offsets (vbase_types, BINFO_OFFSET (vbase_types));\n@@ -1169,22 +1246,6 @@ make_binfo (offset, binfo, vtable, virtuals, chain)\n   return new_binfo;\n }\n \n-tree\n-copy_binfo (list)\n-     tree list;\n-{\n-  tree binfo = copy_list (list);\n-  tree rval = binfo;\n-  while (binfo)\n-    {\n-      TREE_USED (binfo) = 0;\n-      if (BINFO_BASETYPES (binfo))\n-\tBINFO_BASETYPES (binfo) = copy_node (BINFO_BASETYPES (binfo));\n-      binfo = TREE_CHAIN (binfo);\n-    }\n-  return rval;\n-}\n-\n /* Return the binfo value for ELEM in TYPE.  */\n \n tree"}, {"sha": "d36fa8d1ac856d7d8f928044a9d344a7d99f5aca", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 157, "deletions": 38, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "patch": "@@ -2382,11 +2382,13 @@ build_function_call_real (function, params, require_complete, flags)\n \t     function, coerced_params, NULL_TREE);\n \n     TREE_SIDE_EFFECTS (result) = 1;\n+\n     if (! require_complete)\n-      return result;\n+      return convert_from_reference (result);\n     if (value_type == void_type_node)\n       return result;\n-    return require_complete_type (result);\n+    result = require_complete_type (result);\n+    return convert_from_reference (result);\n   }\n }\n \n@@ -2463,6 +2465,9 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n       register tree type = typetail ? TREE_VALUE (typetail) : 0;\n       register tree val = TREE_VALUE (valtail);\n \n+      if (val == error_mark_node)\n+\tcontinue;\n+\n       if (type == void_type_node)\n \t{\n \t  if (fndecl)\n@@ -2987,9 +2992,6 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n     case TRUTH_AND_EXPR:\n     case TRUTH_OR_EXPR:\n       result_type = boolean_type_node;\n-      op0 = bool_truthvalue_conversion (op0);\n-      op1 = bool_truthvalue_conversion (op1);\n-      converted = 1;\n       break;\n \n       /* Shift operations: result has same type as first operand;\n@@ -3779,17 +3781,17 @@ build_x_unary_op (code, xarg)\n   return build_unary_op (code, xarg, 0);\n }\n \n-/* Just like truthvalue_conversion, but we want a BOOLEAN_TYPE */\n+/* Just like truthvalue_conversion, but we want a CLEANUP_POINT_EXPR.  */\n+   \n tree\n-bool_truthvalue_conversion (expr)\n+condition_conversion (expr)\n      tree expr;\n {\n-  /* We really want to preform the optimizations in truthvalue_conversion\n-     but, not this way. */\n-  /* expr = truthvalue_conversion (expr); */\n-  return convert (boolean_type_node, expr);\n+  tree t = convert (boolean_type_node, expr);\n+  t = fold (build1 (CLEANUP_POINT_EXPR, boolean_type_node, t));\n+  return t;\n }\n-\n+\t\t\t       \n /* C++: Must handle pointers to members.\n \n    Perhaps type instantiation should be extended to handle conversion\n@@ -3927,7 +3929,7 @@ build_unary_op (code, xarg, noconvert)\n       break;\n \n     case TRUTH_NOT_EXPR:\n-      arg = bool_truthvalue_conversion (arg);\n+      arg = convert (boolean_type_node, arg);\n       val = invert_truthvalue (arg);\n       if (arg != error_mark_node)\n \treturn val;\n@@ -4538,7 +4540,7 @@ build_conditional_expr (ifexp, op1, op2)\n       ifexp = op1 = save_expr (ifexp);\n     }\n \n-  ifexp = bool_truthvalue_conversion (ifexp);\n+  ifexp = truthvalue_conversion (ifexp);\n \n   if (TREE_CODE (ifexp) == ERROR_MARK)\n     return error_mark_node;\n@@ -4895,6 +4897,16 @@ build_compound_expr (list)\n \t\tbreak_out_cleanups (TREE_VALUE (list)), rest);\n }\n \n+#ifdef __GNUC__\n+__inline\n+#endif\n+int\n+null_ptr_cst_p (t)\n+     tree t;\n+{\n+  return (TREE_CODE (t) == INTEGER_CST && integer_zerop (t));\n+}\n+\n tree build_static_cast (type, expr)\n    tree type, expr;\n {\n@@ -4904,12 +4916,104 @@ tree build_static_cast (type, expr)\n tree build_reinterpret_cast (type, expr)\n    tree type, expr;\n {\n+  tree intype = TREE_TYPE (expr);\n+\n+  if (TYPE_PTRMEMFUNC_P (type))\n+    type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n+  if (TYPE_PTRMEMFUNC_P (intype))\n+    intype = TYPE_PTRMEMFUNC_FN_TYPE (intype);\n+\n+  if (! POINTER_TYPE_P (type) && ! TREE_CODE (type) == INTEGER_TYPE)\n+    {\n+      cp_error (\"reinterpret_cast cannot convert to type `%T'\", type);\n+      return error_mark_node;\n+    }\n+  if (! POINTER_TYPE_P (intype) && ! TREE_CODE (intype) == INTEGER_TYPE)\n+    {\n+      cp_error (\"reinterpret_cast cannot convert from type `%T'\", type);\n+      return error_mark_node;\n+    }\n+  if (TREE_CODE (type) == INTEGER_TYPE && TREE_CODE (intype) != POINTER_TYPE)\n+    {\n+      cp_error (\"reinterpret_cast cannot convert non-pointer type `%T' to `%T'\",\n+\t\tintype, type);\n+      return error_mark_node;\n+    }\n+  if (TREE_CODE (intype) == INTEGER_TYPE && TREE_CODE (type) != POINTER_TYPE)\n+    {\n+      cp_error (\"reinterpret_cast cannot convert `%T' to non-pointer type `%T'\",\n+\t\tintype, type);\n+      return error_mark_node;\n+    }\n+\n+  if (TREE_CODE (type) == POINTER_TYPE && TREE_CODE (intype) == POINTER_TYPE)\n+    expr = convert (ptr_type_node, expr);\n+\n   return build_c_cast (type, expr, 0);\n }\n \n tree build_const_cast (type, expr)\n    tree type, expr;\n {\n+  tree intype = TREE_TYPE (expr);\n+  tree t1, t2;\n+\n+  if (TYPE_PTRMEMFUNC_P (type))\n+    type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n+  if (TYPE_PTRMEMFUNC_P (intype))\n+    intype = TYPE_PTRMEMFUNC_FN_TYPE (intype);\n+\n+  if (! POINTER_TYPE_P (type))\n+    {\n+      cp_error (\"const_cast cannot convert to non-pointer type `%T'\", type);\n+      return error_mark_node;\n+    }\n+  if (TREE_CODE (type) == REFERENCE_TYPE && ! real_lvalue_p (expr))\n+    {\n+      cp_error (\"const_cast cannot convert rvalue to type `%T'\", type);\n+      return error_mark_node;\n+    }\n+  if (TREE_CODE (type) == POINTER_TYPE && TREE_CODE (intype) != POINTER_TYPE)\n+    {\n+      cp_error (\"const_cast cannot convert non-pointer type `%T' to type `%T'\",\n+\t\tintype, type);\n+      return error_mark_node;\n+    }\n+\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    {\n+      t1 = TREE_TYPE (type);\n+      t2 = intype;\n+    }\n+  else\n+    {\n+      t1 = TREE_TYPE (type);\n+      t2 = TREE_TYPE (intype);\n+\n+      for (; TREE_CODE (t1) == POINTER_TYPE && TREE_CODE (t2) == POINTER_TYPE;\n+\t   t1 = TREE_TYPE (t1), t2 = TREE_TYPE (t2))\n+\t;\n+    }\n+\n+  if (TREE_CODE (t1) == OFFSET_TYPE && TREE_CODE (t2) == OFFSET_TYPE)\n+    {\n+      if (TYPE_OFFSET_BASETYPE (t1) != TYPE_OFFSET_BASETYPE (t2))\n+\t{\n+\t  cp_error (\"const_cast cannot convert between pointers to members of different types `%T' and `%T'\",\n+\t\t    TYPE_OFFSET_BASETYPE (t2), TYPE_OFFSET_BASETYPE (t1));\n+\t  return error_mark_node;\n+\t}\n+      t1 = TREE_TYPE (t1);\n+      t2 = TREE_TYPE (t2);\n+    }\n+\n+  if (TYPE_MAIN_VARIANT (t1) != TYPE_MAIN_VARIANT (t2))\n+    {\n+      cp_error (\"const_cast cannot convert unrelated type `%T' to `%T'\",\n+\t\tt2, t1);\n+      return error_mark_node;\n+    }\n+\n   return build_c_cast (type, expr, 0);\n }\n \n@@ -4930,8 +5034,9 @@ build_c_cast (type, expr, allow_nonconverting)\n     return error_mark_node;\n \n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n-     Strip such NOP_EXPRs, since VALUE is being used in non-lvalue context.  */\n-  if (TREE_CODE (value) == NOP_EXPR\n+     Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */\n+  if (TREE_CODE (type) != REFERENCE_TYPE\n+      && TREE_CODE (value) == NOP_EXPR\n       && TREE_TYPE (value) == TREE_TYPE (TREE_OPERAND (value, 0)))\n     value = TREE_OPERAND (value, 0);\n \n@@ -4989,7 +5094,8 @@ build_c_cast (type, expr, allow_nonconverting)\n     }\n   else\n     {\n-      tree otype, ovalue;\n+      tree otype;\n+      int flag;\n \n       /* Convert functions and arrays to pointers and\n \t convert references to their expanded types,\n@@ -5041,17 +5147,28 @@ build_c_cast (type, expr, allow_nonconverting)\n \twarning (\"cast to pointer from integer of different size\");\n #endif\n \n-      if (TREE_READONLY_DECL_P (value))\n-\tvalue = decl_constant_value (value);\n+      flag = allow_nonconverting ? CONV_NONCONVERTING : 0;\n \n-      ovalue = value;\n-      value = convert_force (type, value, allow_nonconverting?CONV_NONCONVERTING:0);\n-\n-      /* Ignore any integer overflow caused by the cast.  */\n-      if (TREE_CODE (value) == INTEGER_CST)\n+      if (TREE_CODE (type) == REFERENCE_TYPE)\n+\tvalue = (convert_from_reference\n+\t\t (convert_to_reference (type, value, CONV_OLD_CONVERT|flag,\n+\t\t\t\t\tLOOKUP_COMPLAIN, NULL_TREE)));\n+      else\n \t{\n-\t  TREE_OVERFLOW (value) = TREE_OVERFLOW (ovalue);\n-\t  TREE_CONSTANT_OVERFLOW (value) = TREE_CONSTANT_OVERFLOW (ovalue);\n+\t  tree ovalue;\n+\n+\t  if (TREE_READONLY_DECL_P (value))\n+\t    value = decl_constant_value (value);\n+\n+\t  ovalue = value;\n+\t  value = convert_force (type, value, flag);\n+\n+\t  /* Ignore any integer overflow caused by the cast.  */\n+\t  if (TREE_CODE (value) == INTEGER_CST)\n+\t    {\n+\t      TREE_OVERFLOW (value) = TREE_OVERFLOW (ovalue);\n+\t      TREE_CONSTANT_OVERFLOW (value) = TREE_CONSTANT_OVERFLOW (ovalue);\n+\t    }\n \t}\n     }\n \n@@ -5064,11 +5181,7 @@ build_c_cast (type, expr, allow_nonconverting)\n \t  && TREE_CODE (value) == INTEGER_CST\n \t  && TREE_CODE (expr) == INTEGER_CST\n \t  && TREE_CODE (TREE_TYPE (expr)) != INTEGER_TYPE))\n-    {\n-      tree nvalue = build1 (NOP_EXPR, type, value);\n-      TREE_CONSTANT (nvalue) = TREE_CONSTANT (value);\n-      return nvalue;\n-    }\n+    value = non_lvalue (value);\n \n   return value;\n }\n@@ -5667,7 +5780,8 @@ build_modify_expr (lhs, modifycode, rhs)\n     {\n       if (flag_this_is_variable > 0\n \t  && DECL_NAME (current_function_decl) != NULL_TREE\n-\t  && current_class_name != DECL_NAME (current_function_decl))\n+\t  && (DECL_NAME (current_function_decl)\n+\t      != constructor_name (current_class_type)))\n \twarning (\"assignment to `this' not in constructor or destructor\");\n       current_function_just_assigned_this = 1;\n     }\n@@ -6724,12 +6838,15 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n       rhs = resolve_offset_ref (rhs);\n       if (rhs == error_mark_node)\n \treturn error_mark_node;\n-      rhstype = TREE_TYPE (rhs);\n-      coder = TREE_CODE (rhstype);\n     }\n \n+  if (TREE_CODE (TREE_TYPE (rhs)) == REFERENCE_TYPE)\n+    rhs = convert_from_reference (rhs);\n+\n   if ((TREE_CODE (TREE_TYPE (rhs)) == ARRAY_TYPE\n-       && TREE_CODE (type) != ARRAY_TYPE && TREE_CODE (type) != REFERENCE_TYPE)\n+       && TREE_CODE (type) != ARRAY_TYPE\n+       && (TREE_CODE (type) != REFERENCE_TYPE\n+\t   || TREE_CODE (TREE_TYPE (type)) != ARRAY_TYPE))\n       || TREE_CODE (TREE_TYPE (rhs)) == FUNCTION_TYPE\n       || TREE_CODE (TREE_TYPE (rhs)) == METHOD_TYPE)\n     rhs = default_conversion (rhs);\n@@ -7166,7 +7283,8 @@ c_expand_return (retval)\n \t  /* Here is where we finally get RETVAL into RESULT.\n \t     `expand_return' does the magic of protecting\n \t     RESULT from cleanups.  */\n-\t  retval = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (result), retval);\n+\t  retval = fold (build1 (CLEANUP_POINT_EXPR, TREE_TYPE (result),\n+\t\t\t\t retval));\n \t  /* This part _must_ come second, because expand_return looks for\n \t     the INIT_EXPR as the toplevel node only.  :-( */\n \t  retval = build (INIT_EXPR, TREE_TYPE (result), result, retval);\n@@ -7278,8 +7396,9 @@ c_expand_start_case (exp)\n \texp = index;\n     }\n \n-  expand_start_case (1, build1 (CLEANUP_POINT_EXPR, TREE_TYPE (exp), exp),\n-\t\t     type, \"switch statement\");\n+  expand_start_case\n+    (1, fold (build1 (CLEANUP_POINT_EXPR, TREE_TYPE (exp), exp)),\n+     type, \"switch statement\");\n \n   return exp;\n }"}, {"sha": "8a446c18f37017afe32b79c1e17c4ba678ede4e6", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 102, "deletions": 34, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccc31eb61a00fdbfd838ba3c197a2b9932240bb/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=8ccc31eb61a00fdbfd838ba3c197a2b9932240bb", "patch": "@@ -329,7 +329,7 @@ ack (s, v, v2)\n    silly.  So instead, we just do the equivalent of a call to fatal in the\n    same situation (call exit).  */\n \n-/* First used: 0 (reserved), Last used: 363.  Free: */\n+/* First used: 0 (reserved), Last used: 364.  Free: */\n \n static int abortcount = 0;\n \n@@ -379,65 +379,131 @@ my_friendly_assert (cond, where)\n    for use in initializing a static variable; one that can be an\n    element of a \"constant\" initializer.\n \n-   Return 1 if the value is absolute; return 2 if it is relocatable.\n+   Return null_pointer_node if the value is absolute;\n+   if it is relocatable, return the variable that determines the relocation.\n    We assume that VALUE has been folded as much as possible;\n    therefore, we do not need to check for such things as\n    arithmetic-combinations of integers.  */\n \n-static int\n-initializer_constant_valid_p (value)\n+tree\n+initializer_constant_valid_p (value, endtype)\n      tree value;\n+     tree endtype;\n {\n   switch (TREE_CODE (value))\n     {\n     case CONSTRUCTOR:\n-      return TREE_STATIC (value);\n+      if (TREE_CODE (TREE_TYPE (value)) == UNION_TYPE\n+\t  && TREE_CONSTANT (value))\n+\treturn\n+\t  initializer_constant_valid_p (TREE_VALUE (CONSTRUCTOR_ELTS (value)),\n+\t\t\t\t\tendtype);\n+\t\n+      return TREE_STATIC (value) ? null_pointer_node : 0;\n \n     case INTEGER_CST:\n     case REAL_CST:\n     case STRING_CST:\n-      return 1;\n+    case COMPLEX_CST:\n+      return null_pointer_node;\n \n     case ADDR_EXPR:\n-      return 2;\n+      return TREE_OPERAND (value, 0);\n+\n+    case NON_LVALUE_EXPR:\n+      return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n \n     case CONVERT_EXPR:\n     case NOP_EXPR:\n-      /* Allow conversions between types of the same kind.  */\n-      if (TREE_CODE (TREE_TYPE (value))\n-\t  == TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))))\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0));\n+      /* Allow conversions between pointer types.  */\n+      if (TREE_CODE (TREE_TYPE (value)) == POINTER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == POINTER_TYPE)\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n+\n+      /* Allow conversions between real types.  */\n+      if (TREE_CODE (TREE_TYPE (value)) == REAL_TYPE\n+\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == REAL_TYPE)\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n+\n+      /* Allow length-preserving conversions between integer types.  */\n+      if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == INTEGER_TYPE\n+\t  && (TYPE_PRECISION (TREE_TYPE (value))\n+\t      == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n+\n+      /* Allow conversions between other integer types only if\n+\t explicit value.  */\n+      if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == INTEGER_TYPE)\n+\t{\n+\t  tree inner = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t\t     endtype);\n+\t  if (inner == null_pointer_node)\n+\t    return null_pointer_node;\n+\t  return 0;\n+\t}\n+\n       /* Allow (int) &foo provided int is as wide as a pointer.  */\n       if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == POINTER_TYPE\n-\t  && ! tree_int_cst_lt (TYPE_SIZE (TREE_TYPE (value)),\n-\t\t\t\tTYPE_SIZE (TREE_TYPE (TREE_OPERAND (value, 0)))))\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0));\n+\t  && (TYPE_PRECISION (TREE_TYPE (value))\n+\t      >= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t     endtype);\n+\n+      /* Likewise conversions from int to pointers.  */\n+      if (TREE_CODE (TREE_TYPE (value)) == POINTER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == INTEGER_TYPE\n+\t  && (TYPE_PRECISION (TREE_TYPE (value))\n+\t      <= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (value, 0)))))\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t     endtype);\n+\n+      /* Allow conversions to union types if the value inside is okay.  */\n+      if (TREE_CODE (TREE_TYPE (value)) == UNION_TYPE)\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t     endtype);\n       return 0;\n \n     case PLUS_EXPR:\n+      if (TREE_CODE (endtype) == INTEGER_TYPE\n+\t  && TYPE_PRECISION (endtype) < POINTER_SIZE)\n+\treturn 0;\n       {\n-\tint valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0));\n-\tint valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1));\n-\tif (valid0 == 1 && valid1 == 2)\n-\t  return 2;\n-\tif (valid0 == 2 && valid1 == 1)\n-\t  return 2;\n+\ttree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t\t    endtype);\n+\ttree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n+\t\t\t\t\t\t    endtype);\n+\t/* If either term is absolute, use the other terms relocation.  */\n+\tif (valid0 == null_pointer_node)\n+\t  return valid1;\n+\tif (valid1 == null_pointer_node)\n+\t  return valid0;\n \treturn 0;\n       }\n \n     case MINUS_EXPR:\n+      if (TREE_CODE (endtype) == INTEGER_TYPE\n+\t  && TYPE_PRECISION (endtype) < POINTER_SIZE)\n+\treturn 0;\n       {\n-\tint valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0));\n-\tint valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1));\n-\tif (valid0 == 2 && valid1 == 1)\n-\t  return 2;\n+\ttree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t\t    endtype);\n+\ttree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n+\t\t\t\t\t\t    endtype);\n+\t/* Win if second argument is absolute.  */\n+\tif (valid1 == null_pointer_node)\n+\t  return valid0;\n+\t/* Win if both arguments have the same relocation.\n+\t   Then the value is absolute.  */\n+\tif (valid0 == valid1)\n+\t  return null_pointer_node;\n \treturn 0;\n       }\n-\n-    default:\n-      return 0;\n     }\n+\n+  return 0;\n }\n \f\n /* Perform appropriate conversions on the initial value of a variable,\n@@ -583,7 +649,7 @@ store_init_value (decl, init)\n     ;\n   else if (TREE_STATIC (decl)\n \t   && (! TREE_CONSTANT (value)\n-\t       || ! initializer_constant_valid_p (value)\n+\t       || ! initializer_constant_valid_p (value, TREE_TYPE (value))\n #if 0\n \t       /* A STATIC PUBLIC int variable doesn't have to be\n \t\t  run time inited when doing pic.  (mrs) */\n@@ -920,7 +986,7 @@ process_init_constructor (type, init, elts)\n \t    erroneous = 1;\n \t  else if (!TREE_CONSTANT (next1))\n \t    allconstant = 0;\n-\t  else if (! initializer_constant_valid_p (next1))\n+\t  else if (! initializer_constant_valid_p (next1, TREE_TYPE (next1)))\n \t    allsimple = 0;\n \t  members = tree_cons (NULL_TREE, next1, members);\n \t}\n@@ -984,7 +1050,7 @@ process_init_constructor (type, init, elts)\n \t    erroneous = 1;\n \t  else if (!TREE_CONSTANT (next1))\n \t    allconstant = 0;\n-\t  else if (! initializer_constant_valid_p (next1))\n+\t  else if (! initializer_constant_valid_p (next1, TREE_TYPE (next1)))\n \t    allsimple = 0;\n \t  members = tree_cons (field, next1, members);\n \t}\n@@ -1001,7 +1067,7 @@ process_init_constructor (type, init, elts)\n \t\terroneous = 1;\n \t      else if (!TREE_CONSTANT (next1))\n \t\tallconstant = 0;\n-\t      else if (! initializer_constant_valid_p (next1))\n+\t      else if (! initializer_constant_valid_p (next1, TREE_TYPE (next1)))\n \t\tallsimple = 0;\n \t      members = tree_cons (field, next1, members);\n \t    }\n@@ -1082,7 +1148,7 @@ process_init_constructor (type, init, elts)\n \terroneous = 1;\n       else if (!TREE_CONSTANT (next1))\n \tallconstant = 0;\n-      else if (initializer_constant_valid_p (next1) == 0)\n+      else if (initializer_constant_valid_p (next1, TREE_TYPE (next1)) == 0)\n \tallsimple = 0;\n       members = tree_cons (field, next1, members);\n     }\n@@ -1425,11 +1491,13 @@ build_functional_cast (exp, parms)\n       /* this must build a C cast */\n       if (parms == NULL_TREE)\n \tparms = integer_zero_node;\n-      else if (TREE_CHAIN (parms) != NULL_TREE)\n+      else\n \t{\n-\t  pedwarn (\"initializer list being treated as compound expression\");\n+\t  if (TREE_CHAIN (parms) != NULL_TREE)\n+\t    pedwarn (\"initializer list being treated as compound expression\");\n \t  parms = build_compound_expr (parms);\n \t}\n+\n       return build_c_cast (type, parms, 1);\n     }\n "}]}