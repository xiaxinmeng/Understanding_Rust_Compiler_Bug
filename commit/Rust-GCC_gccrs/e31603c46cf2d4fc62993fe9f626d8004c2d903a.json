{"sha": "e31603c46cf2d4fc62993fe9f626d8004c2d903a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTMxNjAzYzQ2Y2YyZDRmYzYyOTkzZmU5ZjYyNmQ4MDA0YzJkOTAzYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2003-04-28T12:10:35Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2003-04-28T12:10:35Z"}, "message": "builtins.def (BUILT_IN_BCOPY, [...]): New.\n\n\t* builtins.def (BUILT_IN_BCOPY, BUILT_IN_MEMMOVE): New.\n\t* builtin-types.def (BT_FN_VOID_CONST_PTR_PTR_SIZE): New.\n\t* builtins.c (expand_builtin_memmove, expand_builtin_bcopy): New\n\tfunctions.\n\t(expand_builtin): Handle BUILT_IN_BCOPY and BUILT_IN_MEMMOVE.\n\n\t* gcc.c-torture/execute/string-opt-19.c: New test.\n\nFrom-SVN: r66169", "tree": {"sha": "724aa570916638d254b686a7dfa1cfb24f55c7f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/724aa570916638d254b686a7dfa1cfb24f55c7f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e31603c46cf2d4fc62993fe9f626d8004c2d903a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e31603c46cf2d4fc62993fe9f626d8004c2d903a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e31603c46cf2d4fc62993fe9f626d8004c2d903a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e31603c46cf2d4fc62993fe9f626d8004c2d903a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dbe983a84b4aa2e9037f093e7185d1985830cb5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbe983a84b4aa2e9037f093e7185d1985830cb5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbe983a84b4aa2e9037f093e7185d1985830cb5b"}], "stats": {"total": 215, "additions": 212, "deletions": 3}, "files": [{"sha": "f7a7d93579ce5c59c16332c247e21cdbcc9d82fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e31603c46cf2d4fc62993fe9f626d8004c2d903a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e31603c46cf2d4fc62993fe9f626d8004c2d903a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e31603c46cf2d4fc62993fe9f626d8004c2d903a", "patch": "@@ -1,3 +1,11 @@\n+2003-04-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* builtins.def (BUILT_IN_BCOPY, BUILT_IN_MEMMOVE): New.\n+\t* builtin-types.def (BT_FN_VOID_CONST_PTR_PTR_SIZE): New.\n+\t* builtins.c (expand_builtin_memmove, expand_builtin_bcopy): New\n+\tfunctions.\n+\t(expand_builtin): Handle BUILT_IN_BCOPY and BUILT_IN_MEMMOVE.\n+\n 2003-04-28  Nick Clifton  <nickc@redhat.com>\n \n \t* config/arm/elf.h (ASM_OUTPUT_ALIGNED_COMMON): Remove definition."}, {"sha": "d9b98f111746846fd69117dd50b272b63228d8ef", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e31603c46cf2d4fc62993fe9f626d8004c2d903a/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e31603c46cf2d4fc62993fe9f626d8004c2d903a/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=e31603c46cf2d4fc62993fe9f626d8004c2d903a", "patch": "@@ -174,6 +174,8 @@ DEF_FUNCTION_TYPE_3 (BT_FN_PTR_PTR_INT_SIZE,\n \t             BT_PTR, BT_PTR, BT_INT, BT_SIZE)\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_PTR_INT_INT,\n \t\t     BT_VOID, BT_PTR, BT_INT, BT_INT)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_CONST_PTR_PTR_SIZE,\n+\t\t     BT_VOID, BT_CONST_PTR, BT_PTR, BT_SIZE)\n DEF_FUNCTION_TYPE_3 (BT_FN_INT_STRING_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_STRING, BT_CONST_STRING, BT_VALIST_ARG)\n DEF_FUNCTION_TYPE_3 (BT_FN_INT_CONST_STRING_CONST_STRING_VALIST_ARG,"}, {"sha": "94db6a3ba3f430a20ec24310ef2d8d48d78e912b", "filename": "gcc/builtins.c", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e31603c46cf2d4fc62993fe9f626d8004c2d903a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e31603c46cf2d4fc62993fe9f626d8004c2d903a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e31603c46cf2d4fc62993fe9f626d8004c2d903a", "patch": "@@ -126,6 +126,9 @@ static rtx expand_builtin_strcspn\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_memcpy\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode, int));\n+static rtx expand_builtin_memmove\tPARAMS ((tree, rtx,\n+\t\t\t\t\t\t enum machine_mode));\n+static rtx expand_builtin_bcopy\t\tPARAMS ((tree));\n static rtx expand_builtin_strcpy\tPARAMS ((tree, rtx,\n \t\t\t\t\t\t enum machine_mode));\n static rtx expand_builtin_stpcpy\tPARAMS ((tree, rtx,\n@@ -2364,6 +2367,84 @@ expand_builtin_memcpy (arglist, target, mode, endp)\n     }\n }\n \n+/* Expand expression EXP, which is a call to the memmove builtin.  Return 0\n+   if we failed the caller should emit a normal call.  */\n+\n+static rtx\n+expand_builtin_memmove (arglist, target, mode)\n+     tree arglist;\n+     rtx target;\n+     enum machine_mode mode;\n+{\n+  if (!validate_arglist (arglist,\n+\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+  else\n+    {\n+      tree dest = TREE_VALUE (arglist);\n+      tree src = TREE_VALUE (TREE_CHAIN (arglist));\n+      tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+      unsigned int src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n+      unsigned int dest_align\n+\t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+\n+      /* If DEST is not a pointer type, call the normal function.  */\n+      if (dest_align == 0)\n+\treturn 0;\n+\n+      /* If the LEN parameter is zero, return DEST.  */\n+      if (host_integerp (len, 1) && tree_low_cst (len, 1) == 0)\n+\t{\n+\t  /* Evaluate and ignore SRC in case it has side-effects.  */\n+\t  expand_expr (src, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\t  return expand_expr (dest, target, mode, EXPAND_NORMAL);\n+\t}\n+\n+      /* If either SRC is not a pointer type, don't do this\n+         operation in-line.  */\n+      if (src_align == 0)\n+\treturn 0;\n+\n+      /* If src is a string constant and strings are not writable,\n+\t we can use normal memcpy.  */\n+      if (!flag_writable_strings && c_getstr (src))\n+\treturn expand_builtin_memcpy (arglist, target, mode, 0);\n+\n+      /* Otherwise, call the normal function.  */\n+      return 0;\n+   }\n+}\n+\n+/* Expand expression EXP, which is a call to the bcopy builtin.  Return 0\n+   if we failed the caller should emit a normal call.  */\n+\n+static rtx\n+expand_builtin_bcopy (arglist)\n+     tree arglist;\n+{\n+  tree src, dest, size, newarglist;\n+\n+  if (!validate_arglist (arglist,\n+\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return NULL_RTX;\n+\n+  src = TREE_VALUE (arglist);\n+  dest = TREE_VALUE (TREE_CHAIN (arglist));\n+  size = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+  /* New argument list transforming bcopy(ptr x, ptr y, int z) to\n+     memmove(ptr y, ptr x, size_t z).   This is done this way\n+     so that if it isn't expanded inline, we fallback to\n+     calling bcopy instead of memmove.  */\n+\n+  newarglist = build_tree_list (NULL_TREE, convert (sizetype, size));\n+  newarglist = tree_cons (NULL_TREE, src, newarglist);\n+  newarglist = tree_cons (NULL_TREE, dest, newarglist);\n+\n+  return expand_builtin_memmove (newarglist, const0_rtx, VOIDmode);\n+}\n+\n /* Expand expression EXP, which is a call to the strcpy builtin.  Return 0\n    if we failed the caller should emit a normal call, otherwise try to get\n    the result in TARGET, if convenient (and in mode MODE if that's\n@@ -4177,8 +4258,10 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       case BUILT_IN_MEMCPY:\n       case BUILT_IN_MEMCMP:\n       case BUILT_IN_MEMPCPY:\n+      case BUILT_IN_MEMMOVE:\n       case BUILT_IN_BCMP:\n       case BUILT_IN_BZERO:\n+      case BUILT_IN_BCOPY:\n       case BUILT_IN_INDEX:\n       case BUILT_IN_RINDEX:\n       case BUILT_IN_STPCPY:\n@@ -4543,6 +4626,18 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \treturn target;\n       break;\n \n+    case BUILT_IN_MEMMOVE:\n+      target = expand_builtin_memmove (arglist, target, mode);\n+      if (target)\n+\treturn target;\n+      break;\n+\n+    case BUILT_IN_BCOPY:\n+      target = expand_builtin_bcopy (arglist);\n+      if (target)\n+\treturn target;\n+      break;\n+\n     case BUILT_IN_MEMSET:\n       target = expand_builtin_memset (exp, target, mode);\n       if (target)"}, {"sha": "1806434b1aba7f0db0ff4deea185bcee4c8a2225", "filename": "gcc/builtins.def", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e31603c46cf2d4fc62993fe9f626d8004c2d903a/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e31603c46cf2d4fc62993fe9f626d8004c2d903a/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=e31603c46cf2d4fc62993fe9f626d8004c2d903a", "patch": "@@ -286,16 +286,23 @@ DEF_C99_BUILTIN(BUILT_IN_CIMAGL,\n \t\tBT_FN_LONG_DOUBLE_COMPLEX_LONG_DOUBLE,\n \t\tATTR_CONST_NOTHROW_LIST)\n \n-/* The system prototypes for `bzero' and `bcmp' functions have many\n-   variations, so don't specify parameters to avoid conflicts.  The\n-   expand_* functions check the argument types anyway.  */\n+/* The system prototypes for `bzero', 'bcopy' and `bcmp' functions\n+   have many variations, so don't specify parameters to avoid conflicts.\n+   The expand_* functions check the argument types anyway.  */\n DEF_BUILTIN (BUILT_IN_BZERO,\n \t     \"__builtin_bzero\",\n \t     BUILT_IN_NORMAL,\n \t     BT_FN_VOID_PTR_SIZE, \n \t     BT_FN_VOID_VAR,\n \t     true, true, true,\n \t     ATTR_NOTHROW_LIST, false)\n+DEF_BUILTIN (BUILT_IN_BCOPY,\n+\t     \"__builtin_bcopy\",\n+\t     BUILT_IN_NORMAL,\n+\t     BT_FN_VOID_CONST_PTR_PTR_SIZE, \n+\t     BT_FN_VOID_VAR,\n+\t     true, true, true,\n+\t     ATTR_NOTHROW_LIST, false)\n DEF_BUILTIN (BUILT_IN_BCMP,\n \t     \"__builtin_bcmp\",\n \t     BUILT_IN_NORMAL,\n@@ -380,6 +387,10 @@ DEF_LIB_BUILTIN(BUILT_IN_MEMCPY,\n \t\t\"__builtin_memcpy\",\n \t\tBT_FN_PTR_PTR_CONST_PTR_SIZE,\n \t\tATTR_NOTHROW_LIST)\n+DEF_LIB_BUILTIN(BUILT_IN_MEMMOVE,\n+\t\t\"__builtin_memmove\",\n+\t\tBT_FN_PTR_PTR_CONST_PTR_SIZE,\n+\t\tATTR_NOTHROW_LIST)\n DEF_LIB_BUILTIN(BUILT_IN_MEMCMP,\n \t\t\"__builtin_memcmp\",\n \t\tBT_FN_INT_CONST_PTR_CONST_PTR_SIZE,"}, {"sha": "ee090a74e6f55ad52eb0dffc989af790dc133325", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e31603c46cf2d4fc62993fe9f626d8004c2d903a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e31603c46cf2d4fc62993fe9f626d8004c2d903a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e31603c46cf2d4fc62993fe9f626d8004c2d903a", "patch": "@@ -1,3 +1,7 @@\n+2003-04-28  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.c-torture/execute/string-opt-19.c: New test.\n+\n 2003-04-27  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/10506"}, {"sha": "92b84c6d8432fdaffedcd2eac7106caf1d721faf", "filename": "gcc/testsuite/gcc.c-torture/execute/string-opt-19.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e31603c46cf2d4fc62993fe9f626d8004c2d903a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e31603c46cf2d4fc62993fe9f626d8004c2d903a/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fstring-opt-19.c?ref=e31603c46cf2d4fc62993fe9f626d8004c2d903a", "patch": "@@ -0,0 +1,89 @@\n+/* Copyright (C) 2003  Free Software Foundation.\n+\n+   Ensure builtin memmove and bcopy perform correctly.\n+\n+   Written by Jakub Jelinek, 4/26/2003.  */\n+\n+extern void abort (void);\n+typedef __SIZE_TYPE__ size_t;\n+extern void *memmove (void *, const void *, size_t);\n+extern void bcopy (const void *, void *, size_t);\n+extern int memcmp (const void *, const void *, size_t);\n+\n+const char s1[] = \"123\";\n+char p[32] = \"\";\n+\n+int main()\n+{\n+  int i;\n+  const char *s;\n+\n+  if (memmove (p, \"abcde\", 6) != p || memcmp (p, \"abcde\", 6))\n+    abort ();\n+  s = s1;\n+  if (memmove (p + 2, ++s, 0) != p + 2 || memcmp (p, \"abcde\", 6) || s != s1 + 1)\n+    abort ();\n+  if (__builtin_memmove (p + 3, \"\", 1) != p + 3 || memcmp (p, \"abc\\0e\", 6))\n+    abort ();\n+  bcopy (\"fghijk\", p + 2, 4);\n+  if (memcmp (p, \"abfghi\", 7))\n+    abort ();\n+  s = s1 + 1;\n+  bcopy (s++, p + 1, 0);\n+  if (memcmp (p, \"abfghi\", 7) || s != s1 + 2)\n+    abort ();\n+  __builtin_bcopy (\"ABCDE\", p + 4, 1);\n+  if (memcmp (p, \"abfgAi\", 7))\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* When optimizing, all the above cases should be transformed into\n+   something else.  So any remaining calls to the original function\n+   should abort.  When not optimizing, provide memmove/bcopy implementation\n+   just in case target lacks these in its libc.  */\n+__attribute__ ((noinline))\n+static void *\n+memmove (void *d, const void *s, size_t n)\n+{\n+#ifdef __OPTIMIZE__\n+  abort ();\n+#else\n+  char *dst = (char *) d;\n+  const char *src = (const char *) s;\n+  if (src < dst)\n+    {\n+      dst += n;\n+      src += n;\n+      while (n--)\n+        *--dst = *--src;\n+    }\n+  else\n+    while (n--)\n+      *dst++ = *src++;\n+  return (char *) d;\n+#endif\n+}\n+\n+__attribute__ ((noinline))\n+static void\n+bcopy (const void *s, void *d, size_t n)\n+{\n+#ifdef __OPTIMIZE__\n+  abort ();\n+#else\n+  char *dst = (char *) d;\n+  const char *src = (const char *) s;\n+  if (src < dst)\n+    {\n+      dst += n;\n+      src += n;\n+      while (n--)\n+        *--dst = *--src;\n+    }\n+  else\n+    while (n--)\n+      *dst++ = *src++;\n+#endif\n+}"}]}