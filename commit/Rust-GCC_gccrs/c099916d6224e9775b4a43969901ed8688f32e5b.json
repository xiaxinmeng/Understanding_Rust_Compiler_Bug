{"sha": "c099916d6224e9775b4a43969901ed8688f32e5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA5OTkxNmQ2MjI0ZTk3NzViNGE0Mzk2OTkwMWVkODY4OGYzMmU1Yg==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-05-22T09:27:15Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-05-22T09:27:15Z"}, "message": "re PR fortran/31627 ([4.1/4.2 only] -bounds-check doesn't check lower bound of assumed-sized array)\n\n\tPR fortran/31627\n\n\t* trans-array.c (gfc_trans_array_bound_check): Take extra argument to\n\tindicate whether we should check the upper bound in that dimension.\n\t(gfc_conv_array_index_offset): Check only the lower bound of the\n\tlast dimension for assumed-size arrays.\n\t(gfc_conv_array_ref): Likewise.\n\t(gfc_conv_ss_startstride): Likewise.\n\n\t* gfortran.dg/bounds_check_7.f90: New test.\n\nFrom-SVN: r124940", "tree": {"sha": "902c9ac4700d6fbdc15aa8bef964cdf2350134dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/902c9ac4700d6fbdc15aa8bef964cdf2350134dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c099916d6224e9775b4a43969901ed8688f32e5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c099916d6224e9775b4a43969901ed8688f32e5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c099916d6224e9775b4a43969901ed8688f32e5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c099916d6224e9775b4a43969901ed8688f32e5b/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f869709401ddaf2fac3bb2fcd58f998a69fc8f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f869709401ddaf2fac3bb2fcd58f998a69fc8f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f869709401ddaf2fac3bb2fcd58f998a69fc8f4"}], "stats": {"total": 166, "additions": 109, "deletions": 57}, "files": [{"sha": "45f40034988e1bd48a871b3d47370dfc0f2dda7c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c099916d6224e9775b4a43969901ed8688f32e5b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c099916d6224e9775b4a43969901ed8688f32e5b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c099916d6224e9775b4a43969901ed8688f32e5b", "patch": "@@ -1,3 +1,13 @@\n+2007-05-22 Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/31627\n+\t* trans-array.c (gfc_trans_array_bound_check): Take extra argument to\n+\tindicate whether we should check the upper bound in that dimension.\n+\t(gfc_conv_array_index_offset): Check only the lower bound of the\n+\tlast dimension for assumed-size arrays.\n+\t(gfc_conv_array_ref): Likewise.\n+\t(gfc_conv_ss_startstride): Likewise.\n+\n 2005-05-21  Jerry DeLisle  <jvdelisle@verizon.net>\n \t    Daniel Franke  <franke.daniel@gmail.com>\n "}, {"sha": "7a1c0214c2be61a477647033b896467f01a0e60d", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 79, "deletions": 57, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c099916d6224e9775b4a43969901ed8688f32e5b/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c099916d6224e9775b4a43969901ed8688f32e5b/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=c099916d6224e9775b4a43969901ed8688f32e5b", "patch": "@@ -1987,7 +1987,7 @@ gfc_conv_array_ubound (tree descriptor, int dim)\n \n static tree\n gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n,\n-\t\t\t     locus * where)\n+\t\t\t     locus * where, bool check_upper)\n {\n   tree fault;\n   tree tmp;\n@@ -2040,16 +2040,19 @@ gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n,\n   gfc_free (msg);\n \n   /* Check upper bound.  */\n-  tmp = gfc_conv_array_ubound (descriptor, n);\n-  fault = fold_build2 (GT_EXPR, boolean_type_node, index, tmp);\n-  if (name)\n-    asprintf (&msg, \"%s for array '%s', upper bound of dimension %d exceeded\",\n-\t      gfc_msg_fault, name, n+1);\n-  else\n-    asprintf (&msg, \"%s, upper bound of dimension %d exceeded\",\n-\t      gfc_msg_fault, n+1);\n-  gfc_trans_runtime_check (fault, msg, &se->pre, where);\n-  gfc_free (msg);\n+  if (check_upper)\n+    {\n+      tmp = gfc_conv_array_ubound (descriptor, n);\n+      fault = fold_build2 (GT_EXPR, boolean_type_node, index, tmp);\n+      if (name)\n+\tasprintf (&msg, \"%s for array '%s', upper bound of dimension %d \"\n+\t\t\t\" exceeded\", gfc_msg_fault, name, n+1);\n+      else\n+\tasprintf (&msg, \"%s, upper bound of dimension %d exceeded\",\n+\t\t  gfc_msg_fault, n+1);\n+      gfc_trans_runtime_check (fault, msg, &se->pre, where);\n+      gfc_free (msg);\n+    }\n \n   return index;\n }\n@@ -2080,10 +2083,10 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n \t  /* We've already translated this value outside the loop.  */\n \t  index = info->subscript[dim]->data.scalar.expr;\n \n-\t  if ((ar->as->type != AS_ASSUMED_SIZE && !ar->as->cp_was_assumed)\n-\t      || dim < ar->dimen - 1)\n-\t    index = gfc_trans_array_bound_check (se, info->descriptor,\n-\t\t\t\t\t\t index, dim, &ar->where);\n+\t  index = gfc_trans_array_bound_check (se, info->descriptor,\n+\t\t\tindex, dim, &ar->where,\n+\t\t\t(ar->as->type != AS_ASSUMED_SIZE\n+\t\t\t && !ar->as->cp_was_assumed) || dim < ar->dimen - 1);\n \t  break;\n \n \tcase DIMEN_VECTOR:\n@@ -2106,10 +2109,10 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n \t  index = gfc_evaluate_now (index, &se->pre);\n \n \t  /* Do any bounds checking on the final info->descriptor index.  */\n-\t  if ((ar->as->type != AS_ASSUMED_SIZE && !ar->as->cp_was_assumed)\n-\t      || dim < ar->dimen - 1)\n-\t    index = gfc_trans_array_bound_check (se, info->descriptor,\n-\t\t\t\t\t\t index, dim, &ar->where);\n+\t  index = gfc_trans_array_bound_check (se, info->descriptor,\n+\t\t\tindex, dim, &ar->where,\n+\t\t\t(ar->as->type != AS_ASSUMED_SIZE\n+\t\t\t && !ar->as->cp_was_assumed) || dim < ar->dimen - 1);\n \t  break;\n \n \tcase DIMEN_RANGE:\n@@ -2220,14 +2223,13 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n       gfc_conv_expr_type (&indexse, ar->start[n], gfc_array_index_type);\n       gfc_add_block_to_block (&se->pre, &indexse.pre);\n \n-      if (flag_bounds_check &&\n-\t  ((ar->as->type != AS_ASSUMED_SIZE && !ar->as->cp_was_assumed)\n-\t   || n < ar->dimen - 1))\n+      if (flag_bounds_check)\n \t{\n \t  /* Check array bounds.  */\n \t  tree cond;\n \t  char *msg;\n \n+\t  /* Lower bound.  */\n \t  tmp = gfc_conv_array_lbound (se->expr, n);\n \t  cond = fold_build2 (LT_EXPR, boolean_type_node, \n \t\t\t      indexse.expr, tmp);\n@@ -2237,14 +2239,20 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n \t  gfc_trans_runtime_check (cond, msg, &se->pre, where);\n \t  gfc_free (msg);\n \n-\t  tmp = gfc_conv_array_ubound (se->expr, n);\n-\t  cond = fold_build2 (GT_EXPR, boolean_type_node, \n-\t\t\t      indexse.expr, tmp);\n-\t  asprintf (&msg, \"%s for array '%s', \"\n-\t            \"upper bound of dimension %d exceeded\", gfc_msg_fault,\n-\t\t    sym->name, n+1);\n-\t  gfc_trans_runtime_check (cond, msg, &se->pre, where);\n-\t  gfc_free (msg);\n+\t  /* Upper bound, but not for the last dimension of assumed-size\n+\t     arrays.  */\n+\t  if (n < ar->dimen - 1\n+\t      || (ar->as->type != AS_ASSUMED_SIZE && !ar->as->cp_was_assumed))\n+\t    {\n+\t      tmp = gfc_conv_array_ubound (se->expr, n);\n+\t      cond = fold_build2 (GT_EXPR, boolean_type_node, \n+\t\t\t\t  indexse.expr, tmp);\n+\t      asprintf (&msg, \"%s for array '%s', \"\n+\t\t\t\"upper bound of dimension %d exceeded\", gfc_msg_fault,\n+\t\t\tsym->name, n+1);\n+\t      gfc_trans_runtime_check (cond, msg, &se->pre, where);\n+\t      gfc_free (msg);\n+\t    }\n \t}\n \n       /* Multiply the index by the stride.  */\n@@ -2779,22 +2787,18 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t     dimensions are checked later.  */\n \t  for (n = 0; n < loop->dimen; n++)\n \t    {\n+\t      bool check_upper;\n+\n \t      dim = info->dim[n];\n \t      if (info->ref->u.ar.dimen_type[dim] != DIMEN_RANGE)\n \t\tcontinue;\n+\n \t      if (n == info->ref->u.ar.dimen - 1\n \t\t  && (info->ref->u.ar.as->type == AS_ASSUMED_SIZE\n \t\t      || info->ref->u.ar.as->cp_was_assumed))\n-\t\tcontinue;\n-\n-\t      desc = ss->data.info.descriptor;\n-\n-\t      /* This is the run-time equivalent of resolve.c's\n-\t         check_dimension().  The logical is more readable there\n-\t         than it is here, with all the trees.  */\n-\t      lbound = gfc_conv_array_lbound (desc, dim);\n-\t      ubound = gfc_conv_array_ubound (desc, dim);\n-\t      end = info->end[n];\n+\t\tcheck_upper = false;\n+\t      else\n+\t\tcheck_upper = true;\n \n \t      /* Zero stride is not allowed.  */\n \t      tmp = fold_build2 (EQ_EXPR, boolean_type_node, info->stride[n],\n@@ -2805,6 +2809,18 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n \t      gfc_free (msg);\n \n+\t      desc = ss->data.info.descriptor;\n+\n+\t      /* This is the run-time equivalent of resolve.c's\n+\t         check_dimension().  The logical is more readable there\n+\t         than it is here, with all the trees.  */\n+\t      lbound = gfc_conv_array_lbound (desc, dim);\n+\t      end = info->end[n];\n+\t      if (check_upper)\n+\t\tubound = gfc_conv_array_ubound (desc, dim);\n+\t      else\n+\t\tubound = NULL;\n+\n \t      /* non_zerosized is true when the selected range is not\n \t         empty.  */\n \t      stride_pos = fold_build2 (GT_EXPR, boolean_type_node,\n@@ -2835,15 +2851,18 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n \t      gfc_free (msg);\n \n-\t      tmp = fold_build2 (GT_EXPR, boolean_type_node, info->start[n],\n-\t\t\t\t ubound);\n-\t      tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t non_zerosized, tmp);\n-\t      asprintf (&msg, \"%s, upper bound of dimension %d of array '%s'\"\n-\t\t\t\" exceeded\", gfc_msg_fault, info->dim[n]+1,\n-\t\t\tss->expr->symtree->name);\n-\t      gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n-\t      gfc_free (msg);\n+\t      if (check_upper)\n+\t\t{\n+\t\t  tmp = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t\t     info->start[n], ubound);\n+\t\t  tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t     non_zerosized, tmp);\n+\t          asprintf (&msg, \"%s, upper bound of dimension %d of array \"\n+\t\t\t    \"'%s' exceeded\", gfc_msg_fault, info->dim[n]+1,\n+\t\t\t    ss->expr->symtree->name);\n+\t\t  gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n+\t\t  gfc_free (msg);\n+\t\t}\n \n \t      /* Compute the last element of the range, which is not\n \t\t necessarily \"end\" (think 0:5:3, which doesn't contain 5)\n@@ -2864,14 +2883,17 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n \t      gfc_free (msg);\n \n-\t      tmp = fold_build2 (GT_EXPR, boolean_type_node, tmp2, ubound);\n-\t      tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t non_zerosized, tmp);\n-\t      asprintf (&msg, \"%s, upper bound of dimension %d of array '%s'\"\n-\t\t\t\" exceeded\", gfc_msg_fault, info->dim[n]+1,\n-\t\t\tss->expr->symtree->name);\n-\t      gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n-\t      gfc_free (msg);\n+\t      if (check_upper)\n+\t\t{\n+\t\t  tmp = fold_build2 (GT_EXPR, boolean_type_node, tmp2, ubound);\n+\t\t  tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t     non_zerosized, tmp);\n+\t\t  asprintf (&msg, \"%s, upper bound of dimension %d of array \"\n+\t\t\t    \"'%s' exceeded\", gfc_msg_fault, info->dim[n]+1,\n+\t\t\t    ss->expr->symtree->name);\n+\t\t  gfc_trans_runtime_check (tmp, msg, &block, &ss->expr->where);\n+\t\t  gfc_free (msg);\n+\t\t}\n \n \t      /* Check the section sizes match.  */\n \t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, end,"}, {"sha": "c27bbe1a1c989f50d5d2d34aff2d64f7bac9f728", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c099916d6224e9775b4a43969901ed8688f32e5b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c099916d6224e9775b4a43969901ed8688f32e5b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c099916d6224e9775b4a43969901ed8688f32e5b", "patch": "@@ -1,3 +1,8 @@\n+2007-05-22 Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/31627\n+\t* gfortran.dg/bounds_check_7.f90: New test.\n+\n 2007-05-22  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/i386.exp (check_effective_target_ssse3): New."}, {"sha": "362cc662a1a117b7a56a28a198427441147aac14", "filename": "gcc/testsuite/gfortran.dg/bounds_check_7.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c099916d6224e9775b4a43969901ed8688f32e5b/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c099916d6224e9775b4a43969901ed8688f32e5b/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_7.f90?ref=c099916d6224e9775b4a43969901ed8688f32e5b", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"Array reference out of bounds\" }\n+! PR fortran/31627\n+subroutine foo(a)\n+  integer a(*), i\n+  i = 0\n+  a(i) = 42 ! {\n+end subroutine foo\n+\n+program test\n+  integer x(42)\n+  call foo(x)\n+end program test\n+! { dg-output \"Array reference out of bounds .* lower bound of dimension 1 exceeded\" }"}]}