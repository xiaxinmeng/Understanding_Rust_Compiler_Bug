{"sha": "e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM3MzMzYmFkN2I3ZGY3ZmQ5ZDJlNTE2NWY2MWMyYTY4YjU3YTMwZA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-06-07T06:41:58Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-06-07T06:41:58Z"}, "message": "Remove indirect call top N counter type.\n\n2019-06-07  Martin Liska  <mliska@suse.cz>\n\n\t* doc/invoke.texi: Remove param.\n\t* gcov-counter.def (GCOV_COUNTER_ICALL_TOPNV):\n\tRemove.\n\t* gcov-io.h (GCOV_ICALL_TOPN_VAL): Likewise.\n\t(GCOV_ICALL_TOPN_NCOUNTS): Likewise.\n\t* params.def (PARAM_INDIR_CALL_TOPN_PROFILE): Likewise.\n\t* profile.c (instrument_values): Remove\n\tHIST_TYPE_INDIR_CALL_TOPN.\n\t* tree-profile.c (init_ic_make_global_vars):\n\tAlways build __gcov_indirect_call only.\n\t(gimple_init_gcov_profiler): Remove usage\n\tof PARAM_INDIR_CALL_TOPN_PROFILE.\n\t(gimple_gen_ic_profiler): Likewise.\n\t* value-prof.c (dump_histogram_value): Likewise.\n\t(stream_in_histogram_value): Likewise.\n\t(gimple_indirect_call_to_profile): Likewise.\n\t(gimple_find_values_to_profile): Likewise.\n\t* value-prof.h (enum hist_type): Likewise.\n2019-06-07  Martin Liska  <mliska@suse.cz>\n\n\t* Makefile.in: Remove usage of\n\t_gcov_merge_icall_topn.\n\t* libgcov-driver.c (gcov_sort_n_vals): Remove.\n\t(gcov_sort_icall_topn_counter): Likewise.\n\t(gcov_sort_topn_counter_arrays): Likewise.\n\t(dump_one_gcov): Remove call to gcov_sort_topn_counter_arrays.\n\t* libgcov-merge.c (__gcov_merge_icall_topn): Remove.\n\t* libgcov-profiler.c (__gcov_topn_value_profiler_body):\n\tLikewise.\n\t(GCOV_ICALL_COUNTER_CLEAR_THRESHOLD): Remove.\n\t(struct indirect_call_tuple): Remove.\n\t(__gcov_indirect_call_topn_profiler): Remove.\n\t* libgcov-util.c (__gcov_icall_topn_counter_op): Remove.\n\t* libgcov.h (gcov_sort_n_vals): Remove.\n\t(L_gcov_merge_icall_topn): Likewise.\n\t(__gcov_merge_icall_topn): Likewise.\n\t(__gcov_indirect_call_topn_profiler): Likewise.\n\nFrom-SVN: r272030", "tree": {"sha": "11122c7c389797b0e1f14c47c37b5607faff8a47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11122c7c389797b0e1f14c47c37b5607faff8a47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cc261f66c268107b120add99942d729b3a489452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc261f66c268107b120add99942d729b3a489452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc261f66c268107b120add99942d729b3a489452"}], "stats": {"total": 416, "additions": 46, "deletions": 370}, "files": [{"sha": "cbbdbc20a6c60d465351f2db7e4a01fcfd53504a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "patch": "@@ -1,3 +1,24 @@\n+2019-06-07  Martin Liska  <mliska@suse.cz>\n+\n+\t* doc/invoke.texi: Remove param.\n+\t* gcov-counter.def (GCOV_COUNTER_ICALL_TOPNV):\n+\tRemove.\n+\t* gcov-io.h (GCOV_ICALL_TOPN_VAL): Likewise.\n+\t(GCOV_ICALL_TOPN_NCOUNTS): Likewise.\n+\t* params.def (PARAM_INDIR_CALL_TOPN_PROFILE): Likewise.\n+\t* profile.c (instrument_values): Remove\n+\tHIST_TYPE_INDIR_CALL_TOPN.\n+\t* tree-profile.c (init_ic_make_global_vars):\n+\tAlways build __gcov_indirect_call only.\n+\t(gimple_init_gcov_profiler): Remove usage\n+\tof PARAM_INDIR_CALL_TOPN_PROFILE.\n+\t(gimple_gen_ic_profiler): Likewise.\n+\t* value-prof.c (dump_histogram_value): Likewise.\n+\t(stream_in_histogram_value): Likewise.\n+\t(gimple_indirect_call_to_profile): Likewise.\n+\t(gimple_find_values_to_profile): Likewise.\n+\t* value-prof.h (enum hist_type): Likewise.\n+\n 2019-06-07  Martin Liska  <mliska@suse.cz>\n \n \t* tree-ssa-loop.c (get_lsm_tmp_name): Return at the end of the"}, {"sha": "50e50e394139bf114d181da49f278b3d47ddbe8c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "patch": "@@ -12140,9 +12140,6 @@ will not try to thread through its block.\n Maximum number of nested calls to search for control dependencies\n during uninitialized variable analysis.\n \n-@item indir-call-topn-profile\n-Track top N target addresses in indirect-call profile.\n-\n @item max-once-peeled-insns\n The maximum number of insns of a peeled loop that rolls only once.\n "}, {"sha": "b0596c8dc6bc177b2e5c1d879d7cf331df43bd55", "filename": "gcc/gcov-counter.def", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/gcc%2Fgcov-counter.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/gcc%2Fgcov-counter.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-counter.def?ref=e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "patch": "@@ -49,6 +49,3 @@ DEF_GCOV_COUNTER(GCOV_COUNTER_IOR, \"ior\", _ior)\n \n /* Time profile collecting first run of a function */\n DEF_GCOV_COUNTER(GCOV_TIME_PROFILER, \"time_profiler\", _time_profile)\n-\n-/* Top N value tracking for indirect calls.  */\n-DEF_GCOV_COUNTER(GCOV_COUNTER_ICALL_TOPNV, \"indirect_call_topn\", _icall_topn)"}, {"sha": "69c9a73dba8747d504f52989e9c5705b1a97fe5a", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "patch": "@@ -266,12 +266,6 @@ GCOV_COUNTERS\n #define GCOV_N_VALUE_COUNTERS \\\n   (GCOV_LAST_VALUE_COUNTER - GCOV_FIRST_VALUE_COUNTER + 1)\n \n-/* The number of hottest callees to be tracked.  */\n-#define GCOV_ICALL_TOPN_VAL  2\n-\n-/* The number of counter entries per icall callsite.  */\n-#define GCOV_ICALL_TOPN_NCOUNTS (1 + GCOV_ICALL_TOPN_VAL * 4)\n-\n /* Convert a counter index to a tag.  */\n #define GCOV_TAG_FOR_COUNTER(COUNT)\t\t\t\t\\\n \t(GCOV_TAG_COUNTER_BASE + ((gcov_unsigned_t)(COUNT) << 17))"}, {"sha": "b4a4e4a4190b4876b5a6952ed059a8d05f9db195", "filename": "gcc/params.def", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "patch": "@@ -992,14 +992,6 @@ DEFPARAM (PARAM_PROFILE_FUNC_INTERNAL_ID,\n \t  \"Use internal function id in profile lookup.\",\n \t  0, 0, 1)\n \n-/* When the parameter is 1, track the most frequent N target\n-   addresses in indirect-call profile. This disables\n-   indirect_call_profiler_v3 which tracks single target.  */\n-DEFPARAM (PARAM_INDIR_CALL_TOPN_PROFILE,\n-\t  \"indir-call-topn-profile\",\n-\t  \"Track top N target addresses in indirect-call profile.\",\n-\t  0, 0, 1)\n-\n /* Avoid SLP vectorization of large basic blocks.  */\n DEFPARAM (PARAM_SLP_MAX_INSNS_IN_BB,\n \t  \"slp-max-insns-in-bb\","}, {"sha": "9aff9ef2b211dcda90aa1744e95d7881b8d1aac3", "filename": "gcc/profile.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "patch": "@@ -172,7 +172,6 @@ instrument_values (histogram_values values)\n \t  break;\n \n  \tcase HIST_TYPE_INDIR_CALL:\n- \tcase HIST_TYPE_INDIR_CALL_TOPN:\n  \t  gimple_gen_ic_profiler (hist, t, 0);\n   \t  break;\n "}, {"sha": "f2cf40475793308fc5c754d6829c42a7a87a0ec5", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "patch": "@@ -101,11 +101,7 @@ init_ic_make_global_vars (void)\n \n   ic_tuple_var\n     = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n-\t\t  get_identifier (\n-\t\t\t  (PARAM_VALUE (PARAM_INDIR_CALL_TOPN_PROFILE) ?\n-\t\t\t   \"__gcov_indirect_call_topn\" :\n-\t\t\t   \"__gcov_indirect_call\")),\n-\t\t  tuple_type);\n+\t\t  get_identifier (\"__gcov_indirect_call\"), tuple_type);\n   TREE_PUBLIC (ic_tuple_var) = 1;\n   DECL_ARTIFICIAL (ic_tuple_var) = 1;\n   DECL_INITIAL (ic_tuple_var) = NULL;\n@@ -187,8 +183,6 @@ gimple_init_gcov_profiler (void)\n \t\t\t\t\t  ptr_type_node,\n \t\t\t\t\t  NULL_TREE);\n       profiler_fn_name = \"__gcov_indirect_call_profiler_v3\";\n-      if (PARAM_VALUE (PARAM_INDIR_CALL_TOPN_PROFILE))\n-\tprofiler_fn_name = \"__gcov_indirect_call_topn_profiler\";\n \n       tree_indirect_call_profiler_fn\n \t      = build_fn_decl (profiler_fn_name, ic_profiler_fn_type);\n@@ -376,12 +370,6 @@ gimple_gen_ic_profiler (histogram_value value, unsigned tag, unsigned base)\n   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n   tree ref_ptr = tree_coverage_counter_addr (tag, base);\n \n-  if ( (PARAM_VALUE (PARAM_INDIR_CALL_TOPN_PROFILE) &&\n-        tag == GCOV_COUNTER_V_INDIR) ||\n-       (!PARAM_VALUE (PARAM_INDIR_CALL_TOPN_PROFILE) &&\n-        tag == GCOV_COUNTER_ICALL_TOPNV))\n-    return;\n-\n   ref_ptr = force_gimple_operand_gsi (&gsi, ref_ptr,\n \t\t\t\t      true, NULL_TREE, true, GSI_SAME_STMT);\n "}, {"sha": "1e14e5320700317c2005a48d5c2ad85808936529", "filename": "gcc/value-prof.c", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "patch": "@@ -316,22 +316,6 @@ dump_histogram_value (FILE *dump_file, histogram_value hist)\n       }\n       fprintf (dump_file, \".\\n\");\n       break;\n-    case HIST_TYPE_INDIR_CALL_TOPN:\n-      fprintf (dump_file, \"Indirect call topn \");\n-      if (hist->hvalue.counters)\n-\t{\n-           int i;\n-\n-           fprintf (dump_file, \"accu:%\" PRId64, hist->hvalue.counters[0]);\n-           for (i = 1; i < (GCOV_ICALL_TOPN_VAL << 2); i += 2)\n-             {\n-               fprintf (dump_file, \" target:%\" PRId64 \" value:%\" PRId64,\n-                       (int64_t) hist->hvalue.counters[i],\n-                       (int64_t) hist->hvalue.counters[i+1]);\n-             }\n-        }\n-      fprintf (dump_file, \".\\n\");\n-      break;\n     case HIST_TYPE_MAX:\n       gcc_unreachable ();\n    }\n@@ -416,10 +400,6 @@ stream_in_histogram_value (struct lto_input_block *ib, gimple *stmt)\n \t  ncounters = 1;\n \t  break;\n \n-        case HIST_TYPE_INDIR_CALL_TOPN:\n-          ncounters = (GCOV_ICALL_TOPN_VAL << 2) + 1;\n-          break;\n-\n \tcase HIST_TYPE_MAX:\n \t  gcc_unreachable ();\n \t}\n@@ -1865,12 +1845,8 @@ gimple_indirect_call_to_profile (gimple *stmt, histogram_values *values)\n \n   values->reserve (3);\n \n-  values->quick_push (gimple_alloc_histogram_value (\n-                        cfun,\n-                        PARAM_VALUE (PARAM_INDIR_CALL_TOPN_PROFILE) ?\n-                          HIST_TYPE_INDIR_CALL_TOPN :\n-                          HIST_TYPE_INDIR_CALL,\n-\t\t\tstmt, callee));\n+  values->quick_push (gimple_alloc_histogram_value (cfun, HIST_TYPE_INDIR_CALL,\n+\t\t\t\t\t\t    stmt, callee));\n \n   return;\n }\n@@ -1971,10 +1947,6 @@ gimple_find_values_to_profile (histogram_values *values)\n \t  hist->n_counters = 1;\n \t  break;\n \n-        case HIST_TYPE_INDIR_CALL_TOPN:\n-          hist->n_counters = GCOV_ICALL_TOPN_NCOUNTS;\n-          break;\n-\n \tdefault:\n \t  gcc_unreachable ();\n \t}"}, {"sha": "a54024b48dee357eb002951ee817bdfc3a9726fe", "filename": "gcc/value-prof.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "patch": "@@ -33,8 +33,6 @@ enum hist_type\n   HIST_TYPE_AVERAGE,\t/* Compute average value (sum of all values).  */\n   HIST_TYPE_IOR,\t/* Used to compute expected alignment.  */\n   HIST_TYPE_TIME_PROFILE, /* Used for time profile */\n-  HIST_TYPE_INDIR_CALL_TOPN, /* Tries to identify the top N most frequently\n-                                called functions in indirect call.  */\n   HIST_TYPE_MAX\n };\n "}, {"sha": "7ef347a18344f9605218fbe08491c2b796c1478e", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "patch": "@@ -1,3 +1,23 @@\n+2019-06-07  Martin Liska  <mliska@suse.cz>\n+\n+\t* Makefile.in: Remove usage of\n+\t_gcov_merge_icall_topn.\n+\t* libgcov-driver.c (gcov_sort_n_vals): Remove.\n+\t(gcov_sort_icall_topn_counter): Likewise.\n+\t(gcov_sort_topn_counter_arrays): Likewise.\n+\t(dump_one_gcov): Remove call to gcov_sort_topn_counter_arrays.\n+\t* libgcov-merge.c (__gcov_merge_icall_topn): Remove.\n+\t* libgcov-profiler.c (__gcov_topn_value_profiler_body):\n+\tLikewise.\n+\t(GCOV_ICALL_COUNTER_CLEAR_THRESHOLD): Remove.\n+\t(struct indirect_call_tuple): Remove.\n+\t(__gcov_indirect_call_topn_profiler): Remove.\n+\t* libgcov-util.c (__gcov_icall_topn_counter_op): Remove.\n+\t* libgcov.h (gcov_sort_n_vals): Remove.\n+\t(L_gcov_merge_icall_topn): Likewise.\n+\t(__gcov_merge_icall_topn): Likewise.\n+\t(__gcov_indirect_call_topn_profiler): Likewise.\n+\n 2019-06-06  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* config/rs6000/t-darwin: Ensure that the unwinder is built with"}, {"sha": "fb77881145ec8e903ef472147197bc49a7b3612e", "filename": "libgcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/libgcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/libgcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FMakefile.in?ref=e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "patch": "@@ -888,7 +888,7 @@ include $(iterator)\n # Build libgcov components.\n \n LIBGCOV_MERGE = _gcov_merge_add _gcov_merge_single\t\t\t\\\n-\t_gcov_merge_ior _gcov_merge_time_profile _gcov_merge_icall_topn\n+\t_gcov_merge_ior _gcov_merge_time_profile\n LIBGCOV_PROFILER = _gcov_interval_profiler\t\t\t\t\\\n \t_gcov_interval_profiler_atomic\t\t\t\t\t\\\n \t_gcov_pow2_profiler\t\t\t\t\t\t\\\n@@ -900,8 +900,7 @@ LIBGCOV_PROFILER = _gcov_interval_profiler\t\t\t\t\\\n \t_gcov_ior_profiler\t\t\t\t\t\t\\\n \t_gcov_ior_profiler_atomic\t\t\t\t\t\\\n \t_gcov_indirect_call_profiler_v3\t\t\t\t\t\\\n-\t_gcov_time_profiler\t\t\t\t\t\t\\\n-\t_gcov_indirect_call_topn_profiler\n+\t_gcov_time_profiler\n LIBGCOV_INTERFACE = _gcov_dump _gcov_flush _gcov_fork\t\t\t\\\n \t_gcov_execl _gcov_execlp\t\t\t\t\t\\\n \t_gcov_execle _gcov_execv _gcov_execvp _gcov_execve _gcov_reset"}, {"sha": "f03868e34bb992913185518a1304a2852abf2860", "filename": "libgcc/libgcov-driver.c", "status": "modified", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/libgcc%2Flibgcov-driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/libgcc%2Flibgcov-driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-driver.c?ref=e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "patch": "@@ -415,84 +415,6 @@ merge_summary (int run_counted, struct gcov_summary *summary,\n     }\n }\n \n-/* Sort N entries in VALUE_ARRAY in descending order.\n-   Each entry in VALUE_ARRAY has two values. The sorting\n-   is based on the second value.  */\n-\n-GCOV_LINKAGE  void\n-gcov_sort_n_vals (gcov_type *value_array, int n)\n-{\n-  int j, k;\n-\n-  for (j = 2; j < n; j += 2)\n-    {\n-      gcov_type cur_ent[2];\n-\n-      cur_ent[0] = value_array[j];\n-      cur_ent[1] = value_array[j + 1];\n-      k = j - 2;\n-      while (k >= 0 && value_array[k + 1] < cur_ent[1])\n-        {\n-          value_array[k + 2] = value_array[k];\n-          value_array[k + 3] = value_array[k+1];\n-          k -= 2;\n-        }\n-      value_array[k + 2] = cur_ent[0];\n-      value_array[k + 3] = cur_ent[1];\n-    }\n-}\n-\n-/* Sort the profile counters for all indirect call sites. Counters\n-   for each call site are allocated in array COUNTERS.  */\n-\n-static void\n-gcov_sort_icall_topn_counter (const struct gcov_ctr_info *counters)\n-{\n-  int i;\n-  gcov_type *values;\n-  int n = counters->num;\n-\n-  gcc_assert (!(n % GCOV_ICALL_TOPN_NCOUNTS));\n-  values = counters->values;\n-\n-  for (i = 0; i < n; i += GCOV_ICALL_TOPN_NCOUNTS)\n-    {\n-      gcov_type *value_array = &values[i + 1];\n-      gcov_sort_n_vals (value_array, GCOV_ICALL_TOPN_NCOUNTS - 1);\n-    }\n-}\n-\n-/* Sort topn indirect_call profile counters in GI_PTR.  */\n-\n-static void\n-gcov_sort_topn_counter_arrays (const struct gcov_info *gi_ptr)\n-{\n-  unsigned int i;\n-  int f_ix;\n-  const struct gcov_fn_info *gfi_ptr;\n-  const struct gcov_ctr_info *ci_ptr;\n-\n-  if (!gi_ptr->merge[GCOV_COUNTER_ICALL_TOPNV]) \n-    return;\n-\n-  for (f_ix = 0; (unsigned)f_ix != gi_ptr->n_functions; f_ix++)\n-    {\n-      gfi_ptr = gi_ptr->functions[f_ix];\n-      ci_ptr = gfi_ptr->ctrs;\n-      for (i = 0; i < GCOV_COUNTERS; i++)\n-        {\n-          if (!gi_ptr->merge[i])\n-            continue;\n-          if (i == GCOV_COUNTER_ICALL_TOPNV)\n-            {\n-              gcov_sort_icall_topn_counter (ci_ptr);\n-              break;\n-            }\n-          ci_ptr++;\n-        }\n-    }\n-}\n-\n /* Dump the coverage counts for one gcov_info object. We merge with existing\n    counts when possible, to avoid growing the .da files ad infinitum. We use\n    this program's checksum to make sure we only accumulate whole program\n@@ -510,8 +432,6 @@ dump_one_gcov (struct gcov_info *gi_ptr, struct gcov_filename *gf,\n \n   fn_buffer = 0;\n \n-  gcov_sort_topn_counter_arrays (gi_ptr);\n-\n   error = gcov_exit_open_gcda_file (gi_ptr, gf);\n   if (error == -1)\n     return;"}, {"sha": "702a69f834959a1279c98c0c36f5f301432a6f7f", "filename": "libgcc/libgcov-merge.c", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/libgcc%2Flibgcov-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/libgcc%2Flibgcov-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-merge.c?ref=e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "patch": "@@ -122,66 +122,4 @@ __gcov_merge_single (gcov_type *counters, unsigned n_counters)\n }\n #endif /* L_gcov_merge_single */\n \n-#ifdef L_gcov_merge_icall_topn\n-/* The profile merging function used for merging indirect call counts\n-   This function is given array COUNTERS of N_COUNTERS old counters and it\n-   reads the same number of counters from the gcov file.  */\n-\n-void\n-__gcov_merge_icall_topn (gcov_type *counters, unsigned n_counters)\n-{\n-  unsigned i, j, k, m;\n-\n-  gcc_assert (!(n_counters % GCOV_ICALL_TOPN_NCOUNTS));\n-  for (i = 0; i < n_counters; i += GCOV_ICALL_TOPN_NCOUNTS)\n-    {\n-      gcov_type *value_array = &counters[i + 1];\n-      unsigned tmp_size = 2 * (GCOV_ICALL_TOPN_NCOUNTS - 1);\n-      gcov_type *tmp_array \n-          = (gcov_type *) alloca (tmp_size * sizeof (gcov_type));\n-\n-      for (j = 0; j < tmp_size; j++)\n-        tmp_array[j] = 0;\n-\n-      for (j = 0; j < GCOV_ICALL_TOPN_NCOUNTS - 1; j += 2)\n-        {\n-          tmp_array[j] = value_array[j];\n-          tmp_array[j + 1] = value_array [j + 1];\n-        }\n-\n-      /* Skip the number_of_eviction entry.  */\n-      gcov_get_counter ();\n-      for (k = 0; k < GCOV_ICALL_TOPN_NCOUNTS - 1; k += 2)\n-        {\n-          int found = 0;\n-          gcov_type global_id = gcov_get_counter_target ();\n-          gcov_type call_count = gcov_get_counter ();\n-          for (m = 0; m < j; m += 2)\n-            {\n-              if (tmp_array[m] == global_id)\n-                {\n-                  found = 1;\n-                  tmp_array[m + 1] += call_count;\n-                  break;\n-                }\n-            }\n-          if (!found)\n-            {\n-              tmp_array[j] = global_id;\n-              tmp_array[j + 1] = call_count;\n-              j += 2;\n-            }\n-        }\n-      /* Now sort the temp array */\n-      gcov_sort_n_vals (tmp_array, j);\n-\n-      /* Now copy back the top half of the temp array */\n-      for (k = 0; k < GCOV_ICALL_TOPN_NCOUNTS - 1; k += 2)\n-        {\n-          value_array[k] = tmp_array[k];\n-          value_array[k + 1] = tmp_array[k + 1];\n-        }\n-    }\n-}\n-#endif /* L_gcov_merge_icall_topn */\n #endif /* inhibit_libc */"}, {"sha": "40f0858a17473b4b9a1b72c6f63b86a0669bc3ef", "filename": "libgcc/libgcov-profiler.c", "status": "modified", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/libgcc%2Flibgcov-profiler.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/libgcc%2Flibgcov-profiler.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-profiler.c?ref=e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "patch": "@@ -163,139 +163,6 @@ __gcov_one_value_profiler_atomic (gcov_type *counters, gcov_type value)\n }\n #endif\n \n-#ifdef L_gcov_indirect_call_topn_profiler\n-/* Tries to keep track the most frequent N values in the counters where\n-   N is specified by parameter TOPN_VAL. To track top N values, 2*N counter\n-   entries are used.\n-   counter[0] --- the accumative count of the number of times one entry in\n-                  in the counters gets evicted/replaced due to limited capacity.\n-                  When this value reaches a threshold, the bottom N values are\n-                  cleared.\n-   counter[1] through counter[2*N] records the top 2*N values collected so far.\n-   Each value is represented by two entries: count[2*i+1] is the ith value, and\n-   count[2*i+2] is the number of times the value is seen.  */\n-\n-static void\n-__gcov_topn_value_profiler_body (gcov_type *counters, gcov_type value)\n-{\n-   unsigned i, found = 0, have_zero_count = 0;\n-   gcov_type *entry;\n-   gcov_type *lfu_entry = &counters[1];\n-   gcov_type *value_array = &counters[1];\n-   gcov_type *num_eviction = &counters[0];\n-   gcov_unsigned_t topn_val = GCOV_ICALL_TOPN_VAL;\n-\n-   /* There are 2*topn_val values tracked, each value takes two slots in the\n-      counter array.  */\n-   for (i = 0; i < (topn_val << 2); i += 2)\n-     {\n-       entry = &value_array[i];\n-       if (entry[0] == value)\n-         {\n-           entry[1]++ ;\n-           found = 1;\n-           break;\n-         }\n-       else if (entry[1] == 0)\n-         {\n-           lfu_entry = entry;\n-           have_zero_count = 1;\n-         }\n-      else if (entry[1] < lfu_entry[1])\n-        lfu_entry = entry;\n-     }\n-\n-   if (found)\n-     return;\n-\n-   /* lfu_entry is either an empty entry or an entry\n-      with lowest count, which will be evicted.  */\n-   lfu_entry[0] = value;\n-   lfu_entry[1] = 1;\n-\n-#define GCOV_ICALL_COUNTER_CLEAR_THRESHOLD 3000\n-\n-   /* Too many evictions -- time to clear bottom entries to\n-      avoid hot values bumping each other out.  */\n-   if (!have_zero_count\n-       && ++*num_eviction >= GCOV_ICALL_COUNTER_CLEAR_THRESHOLD)\n-     {\n-       unsigned i, j;\n-       gcov_type *p, minv;\n-       gcov_type* tmp_cnts\n-           = (gcov_type *)alloca (topn_val * sizeof (gcov_type));\n-\n-       *num_eviction = 0;\n-\n-       for (i = 0; i < topn_val; i++)\n-         tmp_cnts[i] = 0;\n-\n-       /* Find the largest topn_val values from the group of\n-          2*topn_val values and put them into tmp_cnts.  */\n-\n-       for (i = 0; i < 2 * topn_val; i += 2)\n-         {\n-           p = 0;\n-           for (j = 0; j < topn_val; j++)\n-             {\n-               if (!p || tmp_cnts[j] < *p)\n-                  p = &tmp_cnts[j];\n-             }\n-            if (value_array[i + 1] > *p)\n-              *p = value_array[i + 1];\n-         }\n-\n-       minv = tmp_cnts[0];\n-       for (j = 1; j < topn_val; j++)\n-         {\n-           if (tmp_cnts[j] < minv)\n-             minv = tmp_cnts[j];\n-         }\n-       /* Zero out low value entries.  */\n-       for (i = 0; i < 2 * topn_val; i += 2)\n-         {\n-           if (value_array[i + 1] < minv)\n-             {\n-               value_array[i] = 0;\n-               value_array[i + 1] = 0;\n-             }\n-         }\n-     }\n-}\n-\n-/* These two variables are used to actually track caller and callee.  Keep\n-   them in TLS memory so races are not common (they are written to often).\n-   The variables are set directly by GCC instrumented code, so declaration\n-   here must match one in tree-profile.c.  */\n-\n-#if defined(HAVE_CC_TLS) && !defined (USE_EMUTLS)\n-__thread\n-#endif\n-struct indirect_call_tuple __gcov_indirect_call_topn;\n-\n-#ifdef TARGET_VTABLE_USES_DESCRIPTORS\n-#define VTABLE_USES_DESCRIPTORS 1\n-#else\n-#define VTABLE_USES_DESCRIPTORS 0\n-#endif\n-\n-/* This fucntion is instrumented at function entry to track topn indirect\n-   calls to CUR_FUNC.  */\n- \n-void\n-__gcov_indirect_call_topn_profiler (gcov_type value, void* cur_func)\n-{\n-  void *callee_func = __gcov_indirect_call_topn.callee;\n-  /* If the C++ virtual tables contain function descriptors then one\n-     function may have multiple descriptors and we need to dereference\n-     the descriptors to see if they point to the same function.  */\n-  if (cur_func == callee_func\n-      || (VTABLE_USES_DESCRIPTORS && callee_func\n-\t  && *(void **) cur_func == *(void **) callee_func))\n-    __gcov_topn_value_profiler_body (__gcov_indirect_call_topn.counters, value);\n-}\n-#endif\n-\n #ifdef L_gcov_indirect_call_profiler_v3\n \n /* These two variables are used to actually track caller and callee.  Keep"}, {"sha": "c794132c17237b7269ac2aab91af3ec6d07dda25", "filename": "libgcc/libgcov-util.c", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/libgcc%2Flibgcov-util.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/libgcc%2Flibgcov-util.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-util.c?ref=e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "patch": "@@ -740,25 +740,6 @@ __gcov_single_counter_op (gcov_type *counters, unsigned n_counters,\n     }\n }\n \n-/* Performing FN upon indirect-call profile counters.  */\n-\n-static void\n-__gcov_icall_topn_counter_op (gcov_type *counters, unsigned n_counters,\n-                              counter_op_fn fn, void *data1, void *data2)\n-{\n-  unsigned i;\n-\n-  gcc_assert (!(n_counters % GCOV_ICALL_TOPN_NCOUNTS));\n-  for (i = 0; i < n_counters; i += GCOV_ICALL_TOPN_NCOUNTS)\n-    {\n-      unsigned j;\n-      gcov_type *value_array = &counters[i + 1];\n-\n-      for (j = 0; j < GCOV_ICALL_TOPN_NCOUNTS - 1; j += 2)\n-        value_array[j + 1] = fn (value_array[j + 1], data1, data2);\n-    }\n-}\n-\n /* Scaling the counter value V by multiplying *(float*) DATA1.  */\n \n static gcov_type"}, {"sha": "b4f1ec576fc70785f10c19737eefb1d3a4117760", "filename": "libgcc/libgcov.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/libgcc%2Flibgcov.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e37333bad7b7df7fd9d2e5165f61c2a68b57a30d/libgcc%2Flibgcov.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov.h?ref=e37333bad7b7df7fd9d2e5165f61c2a68b57a30d", "patch": "@@ -102,7 +102,6 @@ typedef unsigned gcov_type_unsigned __attribute__ ((mode (QI)));\n #define gcov_read_unsigned __gcov_read_unsigned\n #define gcov_read_counter __gcov_read_counter\n #define gcov_read_summary __gcov_read_summary\n-#define gcov_sort_n_vals __gcov_sort_n_vals\n \n #else /* IN_GCOV_TOOL */\n /* About the host.  */\n@@ -130,7 +129,6 @@ typedef unsigned gcov_position_t;\n #define L_gcov_merge_single 1\n #define L_gcov_merge_ior 1\n #define L_gcov_merge_time_profile 1\n-#define L_gcov_merge_icall_topn 1\n \n extern gcov_type gcov_read_counter_mem ();\n extern unsigned gcov_get_merge_weight ();\n@@ -267,9 +265,6 @@ extern void __gcov_merge_single (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;\n /* The merge function that just ors the counters together.  */\n extern void __gcov_merge_ior (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;\n \n-/* The merge function is used for topn indirect call counters.  */\n-extern void __gcov_merge_icall_topn (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;\n-\n /* The profiler functions.  */\n extern void __gcov_interval_profiler (gcov_type *, gcov_type, int, unsigned);\n extern void __gcov_interval_profiler_atomic (gcov_type *, gcov_type, int,\n@@ -285,8 +280,6 @@ extern void __gcov_average_profiler (gcov_type *, gcov_type);\n extern void __gcov_average_profiler_atomic (gcov_type *, gcov_type);\n extern void __gcov_ior_profiler (gcov_type *, gcov_type);\n extern void __gcov_ior_profiler_atomic (gcov_type *, gcov_type);\n-extern void __gcov_indirect_call_topn_profiler (gcov_type, void *);\n-extern void gcov_sort_n_vals (gcov_type *, int);\n \n #ifndef inhibit_libc\n /* The wrappers around some library functions..  */"}]}