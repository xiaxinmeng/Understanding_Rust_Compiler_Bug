{"sha": "dc297297ea56b13efad4bcddab5359fae7d819c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMyOTcyOTdlYTU2YjEzZWZhZDRiY2RkYWI1MzU5ZmFlN2Q4MTljMQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2001-08-12T23:40:53Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2001-08-12T23:40:53Z"}, "message": "gcc.c: Fix comment formatting.\n\n\t* gcc.c: Fix comment formatting.\n\t* gccspec.c: Likewise.\n\t* gcov.c: Likewise.\n\t* gcse.c: Likewise.\n\t* genemit.c: Likewise.\n\t* gengenrtl.c: Likewise.\n\t* genrecog.c: Likewise.\n\t* gensupport.c: Likewise.\n\t* ggc-page.c: Likewise.\n\t* global.c: Likewise.\n\t* graph.c: Likewise.\n\t* ifcvt.c: Likewise.\n\t* integrate.c: Likewise.\n\t* lcm.c: Likewise.\n\t* libgcc2.c: Likewise.\n\t* loop.c: Likewise.\n\t* mbchar.c: Likewise.\n\t* optabs.c: Likewise.\n\t* predict.c: Likewise.\n\t* prefix.c: Likewise.\n\t* profile.c: Likewise.\n\t* protoize.c: Likewise.\n\t* real.c: Likewise.\n\t* recog.c: Likewise.\n\t* regclass.c: Likewise.\n\t* regmove.c: Likewise.\n\t* reg-stack.c: Likewise.\n\t* reload1.c: Likewise.\n\t* resource.c: Likewise.\n\t* rtlanal.c: Likewise.\n\t* rtl.c: Likewise.\n\nFrom-SVN: r44837", "tree": {"sha": "f8425171fd5a2b92510be46813648f3e6a1d9f61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8425171fd5a2b92510be46813648f3e6a1d9f61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc297297ea56b13efad4bcddab5359fae7d819c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc297297ea56b13efad4bcddab5359fae7d819c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc297297ea56b13efad4bcddab5359fae7d819c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc297297ea56b13efad4bcddab5359fae7d819c1/comments", "author": null, "committer": null, "parents": [{"sha": "f0d1c3bd39e6379bf2c1b53071c62baeabeb2174", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0d1c3bd39e6379bf2c1b53071c62baeabeb2174", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0d1c3bd39e6379bf2c1b53071c62baeabeb2174"}], "stats": {"total": 226, "additions": 130, "deletions": 96}, "files": [{"sha": "6876e4ce6e5e166615e01cb5ad1973b3abfc3b3b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -1,3 +1,37 @@\n+2001-08-12  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* gcc.c: Fix comment formatting.\n+\t* gccspec.c: Likewise.\n+\t* gcov.c: Likewise.\n+\t* gcse.c: Likewise.\n+\t* genemit.c: Likewise.\n+\t* gengenrtl.c: Likewise.\n+\t* genrecog.c: Likewise.\n+\t* gensupport.c: Likewise.\n+\t* ggc-page.c: Likewise.\n+\t* global.c: Likewise.\n+\t* graph.c: Likewise.\n+\t* ifcvt.c: Likewise.\n+\t* integrate.c: Likewise.\n+\t* lcm.c: Likewise.\n+\t* libgcc2.c: Likewise.\n+\t* loop.c: Likewise.\n+\t* mbchar.c: Likewise.\n+\t* optabs.c: Likewise.\n+\t* predict.c: Likewise.\n+\t* prefix.c: Likewise.\n+\t* profile.c: Likewise.\n+\t* protoize.c: Likewise.\n+\t* real.c: Likewise.\n+\t* recog.c: Likewise.\n+\t* regclass.c: Likewise.\n+\t* regmove.c: Likewise.\n+\t* reg-stack.c: Likewise.\n+\t* reload1.c: Likewise.\n+\t* resource.c: Likewise.\n+\t* rtlanal.c: Likewise.\n+\t* rtl.c: Likewise.\n+\n 2001-08-12  Kazu Hirata  <kazu@hxi.com>\n \n \t* doc/tm.texi (ENCODE_SECTION_INFO): Add documentation on how"}, {"sha": "5d1806323adf4f4a47a0df6b6efe99fc1bced08c", "filename": "gcc/gcc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -185,7 +185,7 @@ static int print_help_list;\n \n static int verbose_flag;\n \n-/* Flag indicating to print target specific command line options. */\n+/* Flag indicating to print target specific command line options.  */\n \n static int target_help_flag;\n \n@@ -3280,7 +3280,7 @@ process_command (argc, argv)\n \t}\n       else if (strcmp (argv[i], \"-ftarget-help\") == 0)\n         {\n-          /* translate_options() has turned --target-help into -ftarget-help. */\n+          /* translate_options() has turned --target-help into -ftarget-help.  */\n           target_help_flag = 1;\n \n           /* We will be passing a dummy file on to the sub-processes.  */\n@@ -4004,7 +4004,7 @@ static int this_is_library_file;\n static int input_from_pipe;\n \n /* Nonnull means substitute this for any suffix when outputting a switches\n-   arguments. */\n+   arguments.  */\n static const char *suffix_subst;\n \n /* Process the spec SPEC and run the commands specified therein.\n@@ -5879,7 +5879,7 @@ main (argc, argv)\n       /* We do not exit here. Instead we have created a fake input file\n          called 'target-dummy' which needs to be compiled, and we pass this\n          on to the various sub-processes, along with the --target-help\n-         switch. */\n+         switch.  */\n     }\n \n   if (print_help_list)"}, {"sha": "88072eada5459e649b34178b38323f2417121d36", "filename": "gcc/gccspec.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fgccspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fgccspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgccspec.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -22,7 +22,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"gcc.h\"\n \n-/* Filter argc and argv before processing by the gcc driver proper. */\n+/* Filter argc and argv before processing by the gcc driver proper.  */\n void\n lang_specific_driver (in_argc, in_argv, in_added_libraries)\n      int *in_argc ATTRIBUTE_UNUSED;\n@@ -92,12 +92,12 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n #endif\n }\n \n-/* Called before linking.  Returns 0 on success and -1 on failure. */\n+/* Called before linking.  Returns 0 on success and -1 on failure.  */\n int\n lang_specific_pre_link ()\n {\n-  return 0;  /* Not used for C. */\n+  return 0;  /* Not used for C.  */\n }\n \n-/* Number of extra output files that lang_specific_pre_link may generate. */\n-int lang_specific_extra_outfiles = 0;  /* Not used for C. */\n+/* Number of extra output files that lang_specific_pre_link may generate.  */\n+int lang_specific_extra_outfiles = 0;  /* Not used for C.  */"}, {"sha": "4fe37b20c30182a622fa7aa2887632c9667a2663", "filename": "gcc/gcov.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -851,7 +851,7 @@ scan_for_source_files ()\n \t}\n       else if (line_num < 0)\n \t{\n-\t  /* Don't know what this is, but it's garbage. */\n+\t  /* Don't know what this is, but it's garbage.  */\n \t  abort();\n \t}\n     }"}, {"sha": "0c1bc3c835a741c3884bd26a6dfb523f52a59e3b", "filename": "gcc/gcse.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -2391,15 +2391,15 @@ record_last_mem_set_info (insn)\n      rtx insn;\n {\n   /* load_killed_in_block_p will handle the case of calls clobbering\n-     everything. */\n+     everything.  */\n   modify_mem_list[BLOCK_NUM (insn)] = \n     alloc_INSN_LIST (insn, modify_mem_list[BLOCK_NUM (insn)]);\n \n   if (GET_CODE (insn) == CALL_INSN)\n     {\n       /* Note that traversals of this loop (other than for free-ing)\n \t will break after encountering a CALL_INSN.  So, there's no\n-\t need to insert a pair of items, as canon_list_insert does. */\n+\t need to insert a pair of items, as canon_list_insert does.  */\n       canon_modify_mem_list[BLOCK_NUM (insn)] = \n         alloc_INSN_LIST (insn, canon_modify_mem_list[BLOCK_NUM (insn)]);\n     }\n@@ -3208,7 +3208,7 @@ expr_reaches_here_p_work (occr, expr, bb, check_self_loop, visited)\n }\n \n /* This wrapper for expr_reaches_here_p_work() is to ensure that any\n-   memory allocated for that function is returned. */\n+   memory allocated for that function is returned.  */\n \n static int\n expr_reaches_here_p (occr, expr, bb, check_self_loop)\n@@ -4116,7 +4116,7 @@ cprop_insn (bb, insn, alter_jumps)\n   \n   note = find_reg_equal_equiv_note (insn);\n \n-  /* We may win even when propagating constants into notes. */\n+  /* We may win even when propagating constants into notes.  */\n   if (note)\n     find_used_regs (&XEXP (note, 0), NULL);\n \n@@ -4128,7 +4128,7 @@ cprop_insn (bb, insn, alter_jumps)\n       struct expr *set;\n \n       /* Ignore registers created by GCSE.\n-\t We do this because ... */\n+\t We do this because ...  */\n       if (regno >= max_gcse_regno)\n \tcontinue;\n \n@@ -4514,7 +4514,7 @@ pre_expr_reaches_here_p_work (occr_bb, expr, bb, visited)\n }\n \n /* The wrapper for pre_expr_reaches_here_work that ensures that any\n-   memory allocated for that function is returned. */\n+   memory allocated for that function is returned.  */\n \n static int\n pre_expr_reaches_here_p (occr_bb, expr, bb)\n@@ -6673,7 +6673,7 @@ build_store_vectors ()\n       {\n \tif (store_killed_after (ptr->pattern, BLOCK_HEAD (b), BASIC_BLOCK (b)))\n \t  {\n-\t    /* The anticipatable expression is not killed if it's gen'd. */\n+\t    /* The anticipatable expression is not killed if it's gen'd.  */\n \t    /*\n \t      We leave this check out for now. If we have a code sequence \n \t      in a block which looks like:"}, {"sha": "b7985ba08837675e63fe520babca09d2d6b53e58", "filename": "gcc/genemit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -735,7 +735,7 @@ output_added_clobbers_hard_reg_p ()\n }\n \f\n /* Generate code to invoke find_free_register () as needed for the\n-   scratch registers used by the peephole2 pattern in SPLIT. */\n+   scratch registers used by the peephole2 pattern in SPLIT.  */\n \n static void\n output_peephole2_scratches (split)"}, {"sha": "73615a860ce7a462332d8edf8d159fadb82fecf7", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -212,7 +212,7 @@ special_rtx (idx)\n \t  || strcmp (defs[idx].enumname, \"MEM\") == 0);\n }\n \n-/* Place a list of all format specifiers we use into the array FORMAT. */\n+/* Place a list of all format specifiers we use into the array FORMAT.  */\n \n static void\n find_formats ()"}, {"sha": "0a02977e8ae1ac361cce25102929219dd99772b1", "filename": "gcc/genrecog.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -800,7 +800,7 @@ add_to_sequence (pattern, last, position, insn_type, top)\n   switch (code)\n     {\n     case PARALLEL:\n-      /* Toplevel peephole pattern. */\n+      /* Toplevel peephole pattern.  */\n       if (insn_type == PEEPHOLE2 && top)\n \t{\n \t  /* We don't need the node we just created -- unlink it.  */\n@@ -809,7 +809,7 @@ add_to_sequence (pattern, last, position, insn_type, top)\n \t  for (i = 0; i < (size_t) XVECLEN (pattern, 0); i++)\n \t    {\n \t      /* Which insn we're looking at is represented by A-Z. We don't\n-\t         ever use 'A', however; it is always implied. */\n+\t         ever use 'A', however; it is always implied.  */\n \n \t      subpos[depth] = (i > 0 ? 'A' + i : 0);\n \t      sub = add_to_sequence (XVECEXP (pattern, 0, i),\n@@ -1705,7 +1705,7 @@ find_afterward (head, real_afterward)\n    new state, branch to node AFTERWARD if non-zero, otherwise return.\n \n    Failure to move to the new state can only occur if we are trying to\n-   match multiple insns and we try to step past the end of the stream. */\n+   match multiple insns and we try to step past the end of the stream.  */\n \n static void\n change_state (oldpos, newpos, afterward, indent)\n@@ -1734,7 +1734,7 @@ change_state (oldpos, newpos, afterward, indent)\n   /* Go down to desired level.  */\n   while (depth < ndepth)\n     {\n-      /* It's a different insn from the first one. */\n+      /* It's a different insn from the first one.  */\n       if (newpos[depth] >= 'A' && newpos[depth] <= 'Z')\n \t{\n \t  /* We can only fail if we're moving down the tree.  */"}, {"sha": "73521d9f8c2ec8cc78d280ffad60f20c4fc09e98", "filename": "gcc/gensupport.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -177,7 +177,7 @@ process_rtx (desc, lineno)\n \trtvec attr;\n \tint i;\n \n-\t/* Create a split with values from the insn_and_split. */\n+\t/* Create a split with values from the insn_and_split.  */\n \tsplit = rtx_alloc (DEFINE_SPLIT);\n \n \ti = XVECLEN (desc, 1);"}, {"sha": "09a4ff99ec7548a92cb1318c0db91a5c2d100c2a", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -592,7 +592,7 @@ alloc_page (order)\n \n   if (p != NULL)\n     {\n-      /* Recycle the allocated memory from this page ... */\n+      /* Recycle the allocated memory from this page ...  */\n       *pp = p->next;\n       page = p->page;\n \n@@ -987,7 +987,7 @@ ggc_set_mark (p)\n   word = bit / HOST_BITS_PER_LONG;\n   mask = (unsigned long) 1 << (bit % HOST_BITS_PER_LONG);\n   \n-  /* If the bit was previously set, skip it. */\n+  /* If the bit was previously set, skip it.  */\n   if (entry->in_use_p[word] & mask)\n     return 1;\n \n@@ -1053,7 +1053,7 @@ init_ggc ()\n \t  abort ();\n       }\n \n-    /* We have a good page, might as well hold onto it... */\n+    /* We have a good page, might as well hold onto it...  */\n     e = (struct page_entry *) xcalloc (1, sizeof (struct page_entry));\n     e->bytes = G.pagesize;\n     e->page = p;"}, {"sha": "a5900bb6c8314ffe14980d3ef4f6a70878e45e1c", "filename": "gcc/global.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -75,7 +75,7 @@ Boston, MA 02111-1307, USA.  */\n    5. Allocate the variables in that order; each if possible into\n    a preferred register, else into another register.  */\n \f\n-/* Number of pseudo-registers which are candidates for allocation. */\n+/* Number of pseudo-registers which are candidates for allocation.  */\n \n static int max_allocno;\n "}, {"sha": "c6af98ad45e272739c6595d2d01b9cef593b39b3", "filename": "gcc/graph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -80,7 +80,7 @@ label: \\\"basic block %d\",\n     }\n \n #if 0\n-  /* FIXME Should this be printed?  It makes the graph significantly larger. */\n+  /* FIXME Should this be printed?  It makes the graph significantly larger.  */\n \n   /* Print the live-at-start register list.  */\n   fputc ('\\n', fp);"}, {"sha": "ce13599d29eed5366bcda0b8910fee3227d8cdd5", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -326,7 +326,7 @@ cond_exec_process_if_block (test_bb, then_bb, else_bb, join_bb)\n   rtx then_end;\t\t\t/* last insn + 1 in THEN block */\n   rtx else_start = NULL_RTX;\t/* first insn in ELSE block or NULL */\n   rtx else_end = NULL_RTX;\t/* last insn + 1 in ELSE block */\n-  int max;\t\t\t/* max # of insns to convert. */\n+  int max;\t\t\t/* max # of insns to convert.  */\n   int then_mod_ok;\t\t/* whether conditional mods are ok in THEN */\n   rtx true_expr;\t\t/* test for else block insns */\n   rtx false_expr;\t\t/* test for then block insns */"}, {"sha": "c865f6f1aee5fc4ee638db98fdb974c943a6ff83", "filename": "gcc/integrate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -71,7 +71,7 @@ extern struct obstack *function_maybepermanent_obstack;\n #endif\n \f\n \n-/* Private type used by {get/has}_func_hard_reg_initial_val. */\n+/* Private type used by {get/has}_func_hard_reg_initial_val.  */\n typedef struct initial_value_pair {\n   rtx hard_reg;\n   rtx pseudo;\n@@ -2006,7 +2006,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n       if (NOTE_LINE_NUMBER (orig) != NOTE_INSN_DELETED_LABEL)\n \tbreak;\n \n-      /* ... FALLTHRU ... */\n+      /* ... FALLTHRU ...  */\n     case CODE_LABEL:\n       LABEL_PRESERVE_P (get_label_from_map (map, CODE_LABEL_NUMBER (orig)))\n \t= LABEL_PRESERVE_P (orig);"}, {"sha": "0f48d6c4483ee76c7599bc6f7091cb469f5dc0fe", "filename": "gcc/lcm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -307,7 +307,7 @@ compute_laterin (edge_list, earliest, antloc, later, laterin)\n   qin = worklist;\n   /* Note that we do not use the last allocated element for our queue,\n      as EXIT_BLOCK is never inserted into it. In fact the above allocation\n-     of n_basic_blocks + 1 elements is not encessary. */\n+     of n_basic_blocks + 1 elements is not encessary.  */\n   qend = &worklist[n_basic_blocks];\n   qlen = n_basic_blocks;\n "}, {"sha": "1c6685f8e3a2e617c78db618c01cba7bfd5536c1", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -2654,11 +2654,11 @@ __clear_insn_cache (void)\n   int save_errno;\n \n   /* Preserve errno, because users would be surprised to have\n-  errno changing without explicitly calling any system-call. */\n+  errno changing without explicitly calling any system-call.  */\n   save_errno = errno;\n \n   /* Keep it simple : memctl (MCT_TEXT) always fully clears the insn cache.\n-     No need to use an address derived from _start or %sp, as 0 works also. */\n+     No need to use an address derived from _start or %sp, as 0 works also.  */\n   memctl(0, 4096, MCT_TEXT);\n   errno = save_errno;\n #endif"}, {"sha": "f9a17af4cd424a6c8bdf628c6d53476ee2f412ee", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -1604,7 +1604,7 @@ rtx_equal_for_loop_p (x, y, movables, regs)\n \f\n /* If X contains any LABEL_REF's, add REG_LABEL notes for them to all\n    insns in INSNS which use the reference.  LABEL_NUSES for CODE_LABEL\n-   references is incremented once for each added note. */\n+   references is incremented once for each added note.  */\n \n static void\n add_label_notes (x, insns)"}, {"sha": "58422988ecc4fc793e632ff90a372cac18ca4366", "filename": "gcc/mbchar.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fmbchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fmbchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmbchar.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -184,7 +184,7 @@ local_mbtowc (pwc, s, n)\n       if (s == NULL)\n \t{\n \t  save_state = ASCII;\n-\t  /* State-dependent. */\n+\t  /* State-dependent.  */\n \t  return 1;\n \t}\n \n@@ -283,7 +283,7 @@ local_mbtowc (pwc, s, n)\n   return 1;\n #else\n \n-  /* This must be the \"C\" locale or unknown locale. */\n+  /* This must be the \"C\" locale or unknown locale.  */\n   return mbtowc (pwc, s, n);\n #endif\n }"}, {"sha": "fd75ba118a3e2d20de5af370a72a1de5276d389e", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -25,7 +25,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n \n /* Include insn-config.h before expr.h so that HAVE_conditional_move\n-   is properly defined. */\n+   is properly defined.  */\n #include \"insn-config.h\"\n #include \"rtl.h\"\n #include \"tree.h\""}, {"sha": "128556c4819a6c82415241953300cc37e1d5e0a4", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -87,7 +87,7 @@ struct predictor_info\n struct predictor_info predictor_info[] = {\n #include \"predict.def\"\n \n-  /* Upper bound on predictors. */\n+  /* Upper bound on predictors.  */\n   {NULL, 0, 0}\n };\n #undef DEF_PREDICTOR"}, {"sha": "5fa47e75a634c6e083c5b8e64939671062aa3fd4", "filename": "gcc/prefix.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fprefix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fprefix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprefix.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -300,7 +300,7 @@ UPDATE_PATH_HOST_CANONICALIZE (path, key);\n #endif\n \n #ifdef DIR_SEPARATOR_2\n-  /* Convert DIR_SEPARATOR_2 to DIR_SEPARATOR. */\n+  /* Convert DIR_SEPARATOR_2 to DIR_SEPARATOR.  */\n   if (DIR_SEPARATOR != DIR_SEPARATOR_2)\n     {\n       char *new_path = xstrdup (path);"}, {"sha": "90327ca4ba9982c3d283dddb39be2c0eb5a42a9c", "filename": "gcc/profile.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -84,10 +84,10 @@ static FILE *bbg_file;\n \n static FILE *da_file;\n \n-/* Pointer of the output file for the basic block/line number map. */\n+/* Pointer of the output file for the basic block/line number map.  */\n static FILE *bb_file;\n \n-/* Last source file name written to bb_file. */\n+/* Last source file name written to bb_file.  */\n \n static char *last_bb_file_name;\n \n@@ -121,7 +121,7 @@ static basic_block find_group PARAMS ((basic_block));\n static void union_groups PARAMS ((basic_block, basic_block));\n \n /* If non-zero, we need to output a constructor to set up the\n-   per-object-file data. */\n+   per-object-file data.  */\n static int need_func_profiler = 0;\n \f\n /* Add edge instrumentation code to the entire insn chain.\n@@ -702,12 +702,12 @@ branch_prob ()\n \n   /* Create spanning tree from basic block graph, mark each edge that is\n      on the spanning tree.  We insert as many abnormal and critical edges\n-     as possible to minimize number of edge splits necesary. */\n+     as possible to minimize number of edge splits necesary.  */\n \n   find_spanning_tree (el);\n \n   /* Fake edges that are not on the tree will not be instrumented, so\n-     mark them ignored. */\n+     mark them ignored.  */\n   for (i = 0; i < num_edges; i++)\n     {\n       edge e = INDEX_EDGE (el, i);\n@@ -807,7 +807,7 @@ branch_prob ()\n }\n \f\n /* Union find algorithm implementation for the basic blocks using\n-   aux fields. */\n+   aux fields.  */\n \n static basic_block\n find_group (bb)\n@@ -995,7 +995,7 @@ end_branch_prob ()\n \t  long temp;\n \t  /* This seems slightly dangerous, as it presumes the EOF\n \t     flag will not be set until an attempt is made to read\n-\t     past the end of the file. */\n+\t     past the end of the file.  */\n \t  if (feof (da_file))\n \t    error (\".da file contents exhausted too early\");\n \t  /* Should be at end of file now.  */\n@@ -1083,7 +1083,7 @@ gen_edge_profiler (edgeno)\n }\n \n /* Output code for a constructor that will invoke __bb_init_func, if\n-   this has not already been done. */\n+   this has not already been done.  */\n \n void\n output_func_start_profiler ()\n@@ -1100,18 +1100,18 @@ output_func_start_profiler ()\n   int save_flag_branch_probabilities = flag_branch_probabilities;\n \n   /* It's either already been output, or we don't need it because we're\n-     not doing profile-edges. */\n+     not doing profile-edges.  */\n   if (! need_func_profiler)\n     return;\n \n   need_func_profiler = 0;\n \n   /* Synthesize a constructor function to invoke __bb_init_func with a\n-     pointer to this object file's profile block. */\n+     pointer to this object file's profile block.  */\n \n   /* Try and make a unique name given the \"file function name\".\n \n-     And no, I don't like this either. */\n+     And no, I don't like this either.  */\n \n   fnname = get_file_function_name ('I');\n   cfnname = IDENTIFIER_POINTER (fnname);\n@@ -1141,7 +1141,7 @@ output_func_start_profiler ()\n   pushlevel (0);\n   expand_function_start (fndecl, 0);\n \n-  /* Actually generate the code to call __bb_init_func. */\n+  /* Actually generate the code to call __bb_init_func.  */\n   ASM_GENERATE_INTERNAL_LABEL (buf, \"LPBX\", 0);\n   table_address = force_reg (Pmode,\n \t\t\t     gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf)));"}, {"sha": "818b6db1cdd58f5f5655c0430141337ee6b66e3e", "filename": "gcc/protoize.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -34,7 +34,7 @@ Boston, MA 02111-1307, USA.  */\n #undef abort\n #include \"version.h\"\n \n-/* Include getopt.h for the sake of getopt_long. */\n+/* Include getopt.h for the sake of getopt_long.  */\n #include \"getopt.h\"\n \n /* Macro to see if the path elements match.  */\n@@ -1173,7 +1173,7 @@ continue_outer: ;\n   return (got_unexpanded ? savestring (line_buf, copy_p - line_buf) : 0);\n }\n \f\n-/* Return 1 if pathname is absolute. */\n+/* Return 1 if pathname is absolute.  */\n \n static int\n is_abspath (path)\n@@ -2237,7 +2237,7 @@ start_over: ;\n   \n     fd_flags = O_RDONLY;\n #ifdef O_BINARY\n-    /* Use binary mode to avoid having to deal with different EOL characters. */\n+    /* Use binary mode to avoid having to deal with different EOL characters.  */\n     fd_flags |= O_BINARY;\n #endif\n     if ((aux_info_file = open (aux_info_filename, fd_flags, 0444 )) == -1)\n@@ -4191,7 +4191,7 @@ edit_file (hp)\n \n     fd_flags = O_RDONLY;\n #ifdef O_BINARY\n-    /* Use binary mode to avoid having to deal with different EOL characters. */\n+    /* Use binary mode to avoid having to deal with different EOL characters.  */\n     fd_flags |= O_BINARY;\n #endif\n     if ((input_file = open (convert_filename, fd_flags, 0444)) == -1)"}, {"sha": "424f0efd2ddc2a516967deb365ecba06fc880206", "filename": "gcc/real.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -5311,7 +5311,7 @@ asctoeg (ss, y, oprec)\n \n   /* Exponent interpretation */\n  expnt:\n-  /* 0.0eXXX is zero, regardless of XXX.  Check for the 0.0. */\n+  /* 0.0eXXX is zero, regardless of XXX.  Check for the 0.0.  */\n   for (k = 0; k < NI; k++)\n     {\n       if (yy[k] != 0)\n@@ -6016,7 +6016,7 @@ c4xtoe (d, e, mode)\n   int i;\n   int carry;\n \n-  /* Short-circuit the zero case. */\n+  /* Short-circuit the zero case.  */\n   if ((d[0] == 0x8000)\n       && (d[1] == 0x0000)\n       && ((mode == QFmode) || ((d[2] == 0x0000) && (d[3] == 0x0000))))\n@@ -6043,7 +6043,7 @@ c4xtoe (d, e, mode)\n   }\n \n   r >>= 8;\t\t\t/* Shift exponent word down 8 bits.  */\n-  if (r & 0x80)\t\t\t/* Make the exponent negative if it is. */\n+  if (r & 0x80)\t\t\t/* Make the exponent negative if it is.  */\n   {\n      r = r | (~0 & ~0xff);\n   }\n@@ -6070,7 +6070,7 @@ c4xtoe (d, e, mode)\n \n      /* Now do the two's complement on the data.  */\n \n-     carry = 1;\t/* Initially add 1 for the two's complement. */\n+     carry = 1;\t/* Initially add 1 for the two's complement.  */\n      for (i=size + M; i > M; i--)\n      {\n \tif (carry && (y[i] == 0x0000))\n@@ -6130,10 +6130,10 @@ etoc4x (x, d, mode)\n \n   emovi (x, xi);\n \n-  /* Adjust exponent for offsets. */\n+  /* Adjust exponent for offsets.  */\n   exp = (EMULONG) xi[E] - (EXONE - 0x7f);\n \n-  /* Round off to nearest or even. */\n+  /* Round off to nearest or even.  */\n   rndsav = rndprc;\n   rndprc = mode == QFmode ? 24 : 32;\n   emdnorm (xi, 0, 0, exp, 64);\n@@ -6158,7 +6158,7 @@ toc4x (x, y, mode)\n       /* Only check for double if necessary */\n       && ((mode == QFmode) || ((x[M+2] == 0) && (x[M+3] == 0))))\n     {\n-      /* We have a zero.  Put it into the output and return. */\n+      /* We have a zero.  Put it into the output and return.  */\n       *y++ = 0x8000;\n       *y++ = 0x0000;\n       if (mode != QFmode)\n@@ -6172,14 +6172,14 @@ toc4x (x, y, mode)\n   *y = 0;\n \n   /* Negative number require a two's complement conversion of the\n-     mantissa. */\n+     mantissa.  */\n   if (x[0])\n     {\n       *y = 0x0080;\n \n       i = ((int) x[1]) - 0x7f;\n \n-      /* Now add 1 to the inverted data to do the two's complement. */\n+      /* Now add 1 to the inverted data to do the two's complement.  */\n       if (mode != QFmode)\n \tv = 4 + M;\n       else\n@@ -6202,11 +6202,11 @@ toc4x (x, y, mode)\n       /* The following is a special case.  The C4X negative float requires\n \t a zero in the high bit (because the format is (2 - x) x 2^m), so\n \t if a one is in that bit, we have to shift left one to get rid\n-\t of it.  This only occurs if the number is -1 x 2^m. */\n+\t of it.  This only occurs if the number is -1 x 2^m.  */\n       if (x[M+1] & 0x8000)\n \t{\n \t  /* This is the case of -1 x 2^m, we have to rid ourselves of the\n-\t     high sign bit and shift the exponent. */\n+\t     high sign bit and shift the exponent.  */\n \t  eshift(x, 1);\n \t  i--;\n \t}\n@@ -6376,9 +6376,9 @@ ereal_unto_float (f)\n       s[0] = (unsigned EMUSHORT) f;\n       s[1] = (unsigned EMUSHORT) (f >> 16);\n     }\n-  /* Convert and promote the target float to E-type. */\n+  /* Convert and promote the target float to E-type.  */\n   e24toe (s, e);\n-  /* Output E-type to REAL_VALUE_TYPE. */\n+  /* Output E-type to REAL_VALUE_TYPE.  */\n   PUT_REAL (e, &r);\n   return r;\n }\n@@ -6411,9 +6411,9 @@ ereal_unto_double (d)\n       s[2] = (unsigned EMUSHORT) d[1];\n       s[3] = (unsigned EMUSHORT) (d[1] >> 16);\n     }\n-  /* Convert target double to E-type. */\n+  /* Convert target double to E-type.  */\n   e53toe (s, e);\n-  /* Output E-type to REAL_VALUE_TYPE. */\n+  /* Output E-type to REAL_VALUE_TYPE.  */\n   PUT_REAL (e, &r);\n   return r;\n }"}, {"sha": "283713bba5f6828ee321736a564ee941cb3c05e9", "filename": "gcc/recog.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -1065,7 +1065,7 @@ register_operand (op, mode)\n     }\n \n   /* If we have an ADDRESSOF, consider it valid since it will be\n-     converted into something that will not be a MEM. */\n+     converted into something that will not be a MEM.  */\n   if (GET_CODE (op) == ADDRESSOF)\n     return 1;\n \n@@ -1984,11 +1984,11 @@ offsettable_address_p (strictp, mode, y)\n \n int\n mode_dependent_address_p (addr)\n-  rtx addr ATTRIBUTE_UNUSED; /* Maybe used in GO_IF_MODE_DEPENDENT_ADDRESS. */\n+  rtx addr ATTRIBUTE_UNUSED; /* Maybe used in GO_IF_MODE_DEPENDENT_ADDRESS.  */\n {\n   GO_IF_MODE_DEPENDENT_ADDRESS (addr, win);\n   return 0;\n-  /* Label `win' might (not) be used via GO_IF_MODE_DEPENDENT_ADDRESS. */\n+  /* Label `win' might (not) be used via GO_IF_MODE_DEPENDENT_ADDRESS.  */\n  win: ATTRIBUTE_UNUSED_LABEL\n   return 1;\n }\n@@ -2012,7 +2012,7 @@ mode_independent_operand (op, mode)\n   addr = XEXP (op, 0);\n   GO_IF_MODE_DEPENDENT_ADDRESS (addr, lose);\n   return 1;\n-  /* Label `lose' might (not) be used via GO_IF_MODE_DEPENDENT_ADDRESS. */\n+  /* Label `lose' might (not) be used via GO_IF_MODE_DEPENDENT_ADDRESS.  */\n  lose: ATTRIBUTE_UNUSED_LABEL\n   return 0;\n }\n@@ -2988,7 +2988,7 @@ peep2_find_free_register (from, to, class_str, mode, reg_set)\n   return NULL_RTX;\n }\n \n-/* Perform the peephole2 optimization pass. */\n+/* Perform the peephole2 optimization pass.  */\n \n void\n peephole2_optimize (dump_file)"}, {"sha": "b859cd711954c6e1ceb53056deee1d78daa1fec4", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -1217,7 +1217,7 @@ move_for_stack_reg (insn, regstack, pat)\n \f\n /* Swap the condition on a branch, if there is one.  Return true if we\n    found a condition to swap.  False if the condition was not used as\n-   such. */\n+   such.  */\n \n static int\n swap_rtx_condition_1 (pat)\n@@ -1773,13 +1773,13 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t    break;\n \n \t  case IF_THEN_ELSE:\n-\t    /* This insn requires the top of stack to be the destination. */\n+\t    /* This insn requires the top of stack to be the destination.  */\n \n \t    /* If the comparison operator is an FP comparison operator,\n \t       it is handled correctly by compare_for_stack_reg () who\n \t       will move the destination to the top of stack. But if the\n \t       comparison operator is not an FP comparison operator, we\n-\t       have to handle it here. */\n+\t       have to handle it here.  */\n \t    if (get_hard_regnum (regstack, *dest) >= FIRST_STACK_REG\n \t\t&& REGNO (*dest) != regstack->reg[regstack->top])\n \t      emit_swap_insn (insn, regstack, *dest);\t\n@@ -1826,7 +1826,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t    }\n \n \t    /* Make dest the top of stack.  Add dest to regstack if\n-\t       not present. */\n+\t       not present.  */\n \t    if (get_hard_regnum (regstack, *dest) < FIRST_STACK_REG)\n \t      regstack->reg[++regstack->top] = REGNO (*dest);\t\n \t    SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));"}, {"sha": "021756a68e90bbbe64acd3065f73bacfd037a3d0", "filename": "gcc/regclass.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -265,7 +265,7 @@ struct reg_info_data {\n static struct reg_info_data *reg_info_head;\n \n /* No more global register variables may be declared; true once\n-   regclass has been initialized. */\n+   regclass has been initialized.  */\n \n static int no_global_reg_vars = 0;\n \n@@ -633,7 +633,7 @@ memory_move_secondary_cost (mode, class, in)\n   enum reg_class altclass;\n   int partial_cost = 0;\n   /* We need a memory reference to feed to SECONDARY... macros.  */\n-  /* mem may be unused even if the SECONDARY_ macros are defined. */\n+  /* mem may be unused even if the SECONDARY_ macros are defined.  */\n   rtx mem ATTRIBUTE_UNUSED = top_of_stack[(int) mode];\n \n \n@@ -848,7 +848,7 @@ static struct costs init_cost;\n \n static struct reg_pref *reg_pref;\n \n-/* Allocated buffers for reg_pref. */\n+/* Allocated buffers for reg_pref.  */\n \n static struct reg_pref *reg_pref_buffer;\n \n@@ -908,7 +908,7 @@ regclass_init ()\n      before regclass is run.  */\n   reg_pref = NULL;\n \n-  /* No more global register variables may be declared. */\n+  /* No more global register variables may be declared.  */\n   no_global_reg_vars = 1;\n }\n \f"}, {"sha": "484c39119a0757c575547bb6460f3398c97f71af", "filename": "gcc/regmove.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -437,7 +437,7 @@ optimize_reg_copy_1 (insn, dest, src)\n   int sregno = REGNO (src);\n   int dregno = REGNO (dest);\n \n-  /* We don't want to mess with hard regs if register classes are small. */\n+  /* We don't want to mess with hard regs if register classes are small.  */\n   if (sregno == dregno\n       || (SMALL_REGISTER_CLASSES\n \t  && (sregno < FIRST_PSEUDO_REGISTER\n@@ -1225,7 +1225,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t      if (recog_data.operand[match_no] != SET_DEST (set))\n \t\tcontinue;\n \n-\t      /* If the operands already match, then there is nothing to do. */\n+\t      /* If the operands already match, then there is nothing to do.  */\n \t      if (operands_match_p (src, dst))\n \t\tcontinue;\n \n@@ -1304,7 +1304,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\t  || RTX_UNCHANGING_P (dst))\n \t\tcontinue;\n \n-\t      /* If the operands already match, then there is nothing to do. */\n+\t      /* If the operands already match, then there is nothing to do.  */\n \t      if (operands_match_p (src, dst))\n \t\tcontinue;\n \n@@ -2007,7 +2007,7 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n \t{\n \t  /* ??? We can't scan past the end of a basic block without updating\n \t     the register lifetime info\n-\t     (REG_DEAD/basic_block_live_at_start). */\n+\t     (REG_DEAD/basic_block_live_at_start).  */\n \t  if (perhaps_ends_bb_p (q))\n \t    break;\n \t  else if (! INSN_P (q))"}, {"sha": "ded6943c04724eee0fbab22c107bdb857e4270fa", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -9067,7 +9067,7 @@ static int reg_set_luid[FIRST_PSEUDO_REGISTER];\n    reg_offset[n] in mode reg_mode[n] .\n    If reg_base_reg[n] is non-negative, register n has been set to the\n    sum of reg_offset[n] and the value of register reg_base_reg[n]\n-   before reg_set_luid[n], calculated in mode reg_mode[n] . */\n+   before reg_set_luid[n], calculated in mode reg_mode[n] .  */\n static HOST_WIDE_INT reg_offset[FIRST_PSEUDO_REGISTER];\n static int reg_base_reg[FIRST_PSEUDO_REGISTER];\n static enum machine_mode reg_mode[FIRST_PSEUDO_REGISTER];"}, {"sha": "af701b95d7adc2ac928544251905e01534f8a53d", "filename": "gcc/resource.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -1128,7 +1128,7 @@ mark_target_live_regs (insns, target, res)\n   /* If we hit an unconditional branch, we have another way of finding out\n      what is live: we can see what is live at the branch target and include\n      anything used but not set before the branch.  We add the live\n-     resources found using the test below to those found until now. */\n+     resources found using the test below to those found until now.  */\n \n   if (jump_insn)\n     {\n@@ -1304,7 +1304,7 @@ incr_ticks_for_insn (insn)\n }\n \f\n /* Add TRIAL to the set of resources used at the end of the current\n-   function. */\n+   function.  */\n void\n mark_end_of_function_resources (trial, include_delayed_effects)\n      rtx trial;"}, {"sha": "49ae05b877b3e5740c1435f2ef8b36c1438b5840", "filename": "gcc/rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -239,7 +239,7 @@ const char * const rtx_format[] = {\n      \"u\" a pointer to another insn\n          prints the uid of the insn.\n      \"b\" is a pointer to a bitmap header.\n-     \"t\" is a tree pointer. */\n+     \"t\" is a tree pointer.  */\n \n #define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   FORMAT ,\n #include \"rtl.def\"\t\t/* rtl expressions are defined here */\n@@ -518,7 +518,7 @@ copy_most_rtx (orig, may_share)\n \t  break;\n \n \tcase '0':\n-\t  /* Copy this through the wide int field; that's safest. */\n+\t  /* Copy this through the wide int field; that's safest.  */\n \t  X0WINT (copy, i) = X0WINT (orig, i);\n \t  break;\n "}, {"sha": "8fe3a4b5f798321b9c2077223ef2fdb27cb8e501", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc297297ea56b13efad4bcddab5359fae7d819c1/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=dc297297ea56b13efad4bcddab5359fae7d819c1", "patch": "@@ -2224,7 +2224,7 @@ replace_rtx (x, from, to)\n   register const char *fmt;\n \n   /* The following prevents loops occurrence when we change MEM in\n-     CONST_DOUBLE onto the same CONST_DOUBLE. */\n+     CONST_DOUBLE onto the same CONST_DOUBLE.  */\n   if (x != 0 && GET_CODE (x) == CONST_DOUBLE)\n     return x;\n \n@@ -2773,7 +2773,7 @@ subreg_regno_offset (xregno, xmode, offset, ymode)\n   return ret;\n }\n \n-/* Return the final regno that a subreg expression refers to. */\n+/* Return the final regno that a subreg expression refers to.  */\n unsigned int \n subreg_regno (x)\n      rtx x;"}]}