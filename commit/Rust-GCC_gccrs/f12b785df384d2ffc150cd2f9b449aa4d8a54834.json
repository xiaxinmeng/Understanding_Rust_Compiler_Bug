{"sha": "f12b785df384d2ffc150cd2f9b449aa4d8a54834", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjEyYjc4NWRmMzg0ZDJmZmMxNTBjZDJmOWI0NDlhYTRkOGE1NDgzNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-04-20T04:54:11Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-04-20T04:54:11Z"}, "message": "builtins.c (expand_builtin_sync_operation): Revert last change.\n\n        * builtins.c (expand_builtin_sync_operation): Revert last change.\n        * optabs.c (expand_bool_compare_and_swap): Compare vs old value,\n        not vs new value.\n        (expand_compare_and_swap_loop): Likewise.\n        (expand_sync_operation): Remove fallback from NAND to AND; invert\n        memory operand when expanding from cmpxchg.\n        (expand_sync_fetch_operation): Likewise.\n        * doc/extend.texi (Atomic Builtins): Fix docs for nand and\n        compare-and-swap.\n\n        * config/alpha/alpha.c (alpha_split_atomic_op): Invert memory operand\n        when implementing NAND.  Fix double-add for AFTER.\n        * config/alpha/sync.md (sync_nand<I48MODE>): Invert memory operand.\n        (sync_old_nand<I48MODE>, sync_new_nand<I48MODE>): Likewise.\n        (sync_compare_and_swap<I48MODE>): Fix compare vs zero.  Return old\n        memory value.\n        (sync_lock_test_and_set<I48MODE>): Remove extra label and last\n        memory barrier.\n\n        * config/i386/sync.md (sync_compare_and_swap<IMODE>): Fix pattern\n        to return old memory value.\n        (sync_compare_and_swap_cc<IMODE>): Likewise.\n\n        * config/ia64/ia64.c (ia64_dependencies_evaluation_hook): Early\n        return pre-reload.  Don't consider output or anti dependencies.\n        * config/ia64/sync.md (IMODE): New.\n        (modesuffix): Add QI and HI.\n        (memory_barrier): Simplify expansion.\n        (sync_compare_and_swap<IMODE>): Use IMODE, not I48MODE.\n        (cmpxchg_acq_<IMODE>): Likewise.\n        (sync_lock_test_and_set<IMODE>): Likewise.\n        (sync_lock_release<IMODE>): Likewise.\n\nFrom-SVN: r98436", "tree": {"sha": "4acdd6c4898d643fa0b840941a2d12315366ec66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4acdd6c4898d643fa0b840941a2d12315366ec66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f12b785df384d2ffc150cd2f9b449aa4d8a54834", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f12b785df384d2ffc150cd2f9b449aa4d8a54834", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f12b785df384d2ffc150cd2f9b449aa4d8a54834", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f12b785df384d2ffc150cd2f9b449aa4d8a54834/comments", "author": null, "committer": null, "parents": [{"sha": "f242e7690e6e838ec12e2d09fe1b5fc7929e20da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f242e7690e6e838ec12e2d09fe1b5fc7929e20da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f242e7690e6e838ec12e2d09fe1b5fc7929e20da"}], "stats": {"total": 302, "additions": 172, "deletions": 130}, "files": [{"sha": "bb9d66abd92fbc56cd868fb01bce43463d2bd4cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f12b785df384d2ffc150cd2f9b449aa4d8a54834", "patch": "@@ -1,3 +1,38 @@\n+2005-04-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* builtins.c (expand_builtin_sync_operation): Revert last change.\n+\t* optabs.c (expand_bool_compare_and_swap): Compare vs old value,\n+\tnot vs new value.\n+\t(expand_compare_and_swap_loop): Likewise.\n+\t(expand_sync_operation): Remove fallback from NAND to AND; invert\n+\tmemory operand when expanding from cmpxchg.\n+\t(expand_sync_fetch_operation): Likewise.\n+\t* doc/extend.texi (Atomic Builtins): Fix docs for nand and\n+\tcompare-and-swap.\n+\n+\t* config/alpha/alpha.c (alpha_split_atomic_op): Invert memory operand\n+\twhen implementing NAND.  Fix double-add for AFTER.\n+\t* config/alpha/sync.md (sync_nand<I48MODE>): Invert memory operand.\n+\t(sync_old_nand<I48MODE>, sync_new_nand<I48MODE>): Likewise.\n+\t(sync_compare_and_swap<I48MODE>): Fix compare vs zero.  Return old\n+\tmemory value.\n+\t(sync_lock_test_and_set<I48MODE>): Remove extra label and last\n+\tmemory barrier.\n+\n+\t* config/i386/sync.md (sync_compare_and_swap<IMODE>): Fix pattern\n+\tto return old memory value.\n+\t(sync_compare_and_swap_cc<IMODE>): Likewise.\n+\n+\t* config/ia64/ia64.c (ia64_dependencies_evaluation_hook): Early\n+\treturn pre-reload.  Don't consider output or anti dependencies.\n+\t* config/ia64/sync.md (IMODE): New.\n+\t(modesuffix): Add QI and HI.\n+\t(memory_barrier): Simplify expansion.\n+\t(sync_compare_and_swap<IMODE>): Use IMODE, not I48MODE.\n+\t(cmpxchg_acq_<IMODE>): Likewise.\n+\t(sync_lock_test_and_set<IMODE>): Likewise.\n+\t(sync_lock_release<IMODE>): Likewise.\n+\n 2005-04-19  James A. Morrison  <phython@gcc.gnu.org>\n \n \t* fold-const.c (fold_binary): Fold ~(X ^ Y) to ~X ^ Y or X ^ ~Y if"}, {"sha": "33102e08e55f9518161b065d7479397993c4ef41", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=f12b785df384d2ffc150cd2f9b449aa4d8a54834", "patch": "@@ -5255,20 +5255,13 @@ expand_builtin_sync_operation (tree arglist, enum rtx_code code, bool after,\n {\n   enum machine_mode mode;\n   rtx addr, val, mem;\n-  tree valt;\n \n   /* Expand the operands.  */\n   addr = expand_expr (TREE_VALUE (arglist), NULL, Pmode, EXPAND_SUM);\n   mode = TYPE_MODE (TREE_TYPE (TREE_TYPE (TREE_VALUE (arglist))));\n \n   arglist = TREE_CHAIN (arglist);\n-  valt = TREE_VALUE (arglist);\n-  if (code == NOT && TREE_CONSTANT (valt))\n-    {\n-      valt = fold_build1 (BIT_NOT_EXPR, TREE_TYPE (valt), valt);\n-      code = AND;\n-    }\n-  val = expand_expr (valt, NULL, mode, EXPAND_NORMAL);\n+  val = expand_expr (TREE_VALUE (arglist), NULL, mode, EXPAND_NORMAL);\n \n   /* Note that we explicitly do not want any alias information for this\n      memory, so that we kill all other live memories.  Otherwise we don't"}, {"sha": "69d67f9f99b94e04e542b960b0752e0540b38720", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=f12b785df384d2ffc150cd2f9b449aa4d8a54834", "patch": "@@ -4502,15 +4502,15 @@ alpha_split_atomic_op (enum rtx_code code, rtx mem, rtx val,\n \n   if (code == NOT)\n     {\n-      x = gen_rtx_NOT (mode, val);\n-      x = gen_rtx_AND (mode, x, before);\n+      x = gen_rtx_NOT (mode, before);\n+      x = gen_rtx_AND (mode, x, val);\n     }\n   else\n     x = gen_rtx_fmt_ee (code, mode, before, val);\n \n-  emit_insn (gen_rtx_SET (VOIDmode, scratch, x));\n   if (after)\n     emit_insn (gen_rtx_SET (VOIDmode, after, copy_rtx (x)));\n+  emit_insn (gen_rtx_SET (VOIDmode, scratch, x));\n \n   cond = gen_rtx_REG (DImode, REGNO (scratch));\n   if (mode == SImode)"}, {"sha": "937a17a8e4fc68c02480ed4e0ff4586eb3eab15b", "filename": "gcc/config/alpha/sync.md", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Fconfig%2Falpha%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Fconfig%2Falpha%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fsync.md?ref=f12b785df384d2ffc150cd2f9b449aa4d8a54834", "patch": "@@ -94,10 +94,8 @@\n (define_insn_and_split \"sync_nand<mode>\"\n   [(set (match_operand:I48MODE 0 \"memory_operand\" \"+m\")\n \t(unspec_volatile:I48MODE\n-\t  [(and:I48MODE\n-\t     (not:I48MODE\n-\t       (match_operand:I48MODE 1 \"reg_or_8bit_operand\" \"rI\"))\n-\t     (match_dup 0))]\n+\t  [(and:I48MODE (not:I48MODE (match_dup 0))\n+\t     (match_operand:I48MODE 1 \"register_operand\" \"r\"))]\n \t  UNSPECV_ATOMIC))\n    (clobber (match_scratch:I48MODE 2 \"=&r\"))]\n   \"\"\n@@ -136,10 +134,8 @@\n \t(match_operand:I48MODE 1 \"memory_operand\" \"+m\"))\n    (set (match_dup 1)\n \t(unspec_volatile:I48MODE\n-\t  [(and:I48MODE\n-\t     (not:I48MODE\n-\t       (match_operand:I48MODE 2 \"reg_or_8bit_operand\" \"rI\"))\n-\t     (match_dup 1))]\n+\t  [(and:I48MODE (not:I48MODE (match_dup 1))\n+\t     (match_operand:I48MODE 2 \"register_operand\" \"r\"))]\n \t  UNSPECV_ATOMIC))\n    (clobber (match_scratch:I48MODE 3 \"=&r\"))]\n   \"\"\n@@ -177,12 +173,11 @@\n (define_insn_and_split \"sync_new_nand<mode>\"\n   [(set (match_operand:I48MODE 0 \"register_operand\" \"=&r\")\n \t(and:I48MODE \n-\t  (not:I48MODE\n-\t    (match_operand:I48MODE 2 \"reg_or_8bit_operand\" \"rI\"))\n-\t  (match_operand:I48MODE 1 \"memory_operand\" \"+m\")))\n+\t  (not:I48MODE (match_operand:I48MODE 1 \"memory_operand\" \"+m\"))\n+\t  (match_operand:I48MODE 2 \"reg_or_8bit_operand\" \"rI\")))\n    (set (match_dup 1)\n \t(unspec_volatile:I48MODE\n-\t  [(and:I48MODE (not:I48MODE (match_dup 2)) (match_dup 1))]\n+\t  [(and:I48MODE (not:I48MODE (match_dup 1)) (match_dup 2))]\n \t  UNSPECV_ATOMIC))\n    (clobber (match_scratch:I48MODE 3 \"=&r\"))]\n   \"\"\n@@ -246,9 +241,11 @@\n   emit_insn (gen_load_locked_<mode> (retval, mem));\n \n   x = gen_lowpart (DImode, retval);\n-  x = gen_rtx_EQ (DImode, x, oldval);\n-  if (oldval != const0_rtx)\n+  if (oldval == const0_rtx)\n+    x = gen_rtx_NE (DImode, x, const0_rtx);\n+  else\n     {\n+      x = gen_rtx_EQ (DImode, x, oldval);\n       emit_insn (gen_rtx_SET (VOIDmode, cond, x));\n       x = gen_rtx_EQ (DImode, cond, const0_rtx);\n     }\n@@ -257,17 +254,16 @@\n   REG_NOTES (x) = gen_rtx_EXPR_LIST (REG_BR_PROB, very_unlikely, NULL_RTX);\n     \n   emit_move_insn (scratch, newval);\n-  emit_move_insn (retval, newval);\n-  \n+\n   emit_insn (gen_store_conditional_<mode> (cond, mem, scratch));\n \n   x = gen_rtx_EQ (DImode, cond, const0_rtx);\n   x = gen_rtx_IF_THEN_ELSE (VOIDmode, x, label1, pc_rtx);\n   x = emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, x));\n   REG_NOTES (x) = gen_rtx_EXPR_LIST (REG_BR_PROB, very_unlikely, NULL_RTX);\n \n-  emit_label (XEXP (label2, 0));\n   emit_insn (gen_memory_barrier ());\n+  emit_label (XEXP (label2, 0));\n   DONE;\n }\n   [(set_attr \"type\" \"multi\")])\n@@ -286,7 +282,7 @@\n   [(const_int 0)]\n {\n   rtx retval, mem, val, scratch;\n-  rtx cond, label1, label2, x;\n+  rtx cond, label1, x;\n   rtx very_unlikely = GEN_INT (REG_BR_PROB_BASE / 100 - 1);\n \n   retval = operands[0];\n@@ -298,7 +294,6 @@\n   emit_insn (gen_memory_barrier ());\n \n   label1 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n-  label2 = gen_rtx_LABEL_REF (DImode, gen_label_rtx ());\n   emit_label (XEXP (label1, 0));\n \n   emit_insn (gen_load_locked_<mode> (retval, mem));\n@@ -312,8 +307,6 @@\n   x = emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, x));\n   REG_NOTES (x) = gen_rtx_EXPR_LIST (REG_BR_PROB, very_unlikely, NULL_RTX);\n \n-  emit_label (XEXP (label2, 0));\n-  emit_insn (gen_memory_barrier ());\n   DONE;\n }\n   [(set_attr \"type\" \"multi\")])"}, {"sha": "99d100fd726fe05f5b460d488653f6b7f6f6c69a", "filename": "gcc/config/i386/sync.md", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Fconfig%2Fi386%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Fconfig%2Fi386%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsync.md?ref=f12b785df384d2ffc150cd2f9b449aa4d8a54834", "patch": "@@ -32,34 +32,32 @@\n \n (define_insn \"sync_compare_and_swap<mode>\"\n   [(set (match_operand:IMODE 0 \"register_operand\" \"=a\")\n+\t(match_operand:IMODE 1 \"memory_operand\" \"+m\"))\n+   (set (match_dup 1)\n \t(unspec_volatile:IMODE\n-\t  [(match_operand:IMODE 1 \"memory_operand\" \"+m\")\n+\t  [(match_dup 1)\n \t   (match_operand:IMODE 2 \"register_operand\" \"a\")\n \t   (match_operand:IMODE 3 \"register_operand\" \"<modeconstraint>\")]\n \t  UNSPECV_CMPXCHG_1))\n-   (set (match_dup 1)\n-\t(unspec_volatile:IMODE\n-\t  [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPECV_CMPXCHG_2))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_CMPXCHG\"\n   \"lock\\;cmpxchg{<modesuffix>}\\t{%3, %1|%1, %3}\")\n \n (define_expand \"sync_compare_and_swap_cc<mode>\"\n   [(parallel\n     [(set (match_operand:IMODE 0 \"register_operand\" \"\")\n+\t  (match_operand:IMODE 1 \"memory_operand\" \"\"))\n+     (set (match_dup 1)\n \t  (unspec_volatile:IMODE\n-\t    [(match_operand:IMODE 1 \"memory_operand\" \"\")\n+\t    [(match_dup 1)\n \t     (match_operand:IMODE 2 \"register_operand\" \"\")\n \t     (match_operand:IMODE 3 \"register_operand\" \"\")]\n \t    UNSPECV_CMPXCHG_1))\n-     (set (match_dup 1)\n-\t  (unspec_volatile:IMODE\n-\t    [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPECV_CMPXCHG_2))\n      (set (match_dup 4)\n \t  (compare:CCZ\n \t    (unspec_volatile:IMODE\n-\t      [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPECV_CMPXCHG_1)\n-\t    (match_dup 3)))])]\n+\t      [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPECV_CMPXCHG_2)\n+\t    (match_dup 2)))])]\n   \"TARGET_CMPXCHG\"\n {\n   operands[4] = gen_rtx_REG (CCZmode, FLAGS_REG);\n@@ -70,19 +68,18 @@\n \n (define_insn \"*sync_compare_and_swap_cc<mode>\"\n   [(set (match_operand:IMODE 0 \"register_operand\" \"=a\")\n+\t(match_operand:IMODE 1 \"memory_operand\" \"+m\"))\n+   (set (match_dup 1)\n \t(unspec_volatile:IMODE\n-\t  [(match_operand:IMODE 1 \"memory_operand\" \"+m\")\n+\t  [(match_dup 1)\n \t   (match_operand:IMODE 2 \"register_operand\" \"a\")\n \t   (match_operand:IMODE 3 \"register_operand\" \"<modeconstraint>\")]\n \t  UNSPECV_CMPXCHG_1))\n-   (set (match_dup 1)\n-\t(unspec_volatile:IMODE\n-\t  [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPECV_CMPXCHG_2))\n    (set (reg:CCZ FLAGS_REG)\n \t(compare:CCZ\n \t  (unspec_volatile:IMODE\n-\t    [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPECV_CMPXCHG_1)\n-\t  (match_dup 3)))]\n+\t    [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPECV_CMPXCHG_2)\n+\t  (match_dup 2)))]\n   \"TARGET_CMPXCHG\"\n   \"lock\\;cmpxchg{<modesuffix>}\\t{%3, %1|%1, %3}\")\n "}, {"sha": "24359222ea3cbdc08ae024089d843eab848f1e5e", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=f12b785df384d2ffc150cd2f9b449aa4d8a54834", "patch": "@@ -5814,6 +5814,12 @@ ia64_dependencies_evaluation_hook (rtx head, rtx tail)\n {\n   rtx insn, link, next, next_tail;\n \n+  /* Before reload, which_alternative is not set, which means that\n+     ia64_safe_itanium_class will produce wrong results for (at least)\n+     move instructions.  */\n+  if (!reload_completed)\n+    return;\n+\n   next_tail = NEXT_INSN (tail);\n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n@@ -5824,6 +5830,8 @@ ia64_dependencies_evaluation_hook (rtx head, rtx tail)\n       {\n \tfor (link = INSN_DEPEND (insn); link != 0; link = XEXP (link, 1))\n \t  {\n+\t    if (REG_NOTE_KIND (link) != REG_DEP_TRUE)\n+\t      continue;\n \t    next = XEXP (link, 0);\n \t    if ((ia64_safe_itanium_class (next) == ITANIUM_CLASS_ST\n \t\t || ia64_safe_itanium_class (next) == ITANIUM_CLASS_STF)"}, {"sha": "0ea8e96ebaaa721411831727fc80790694f6e2b4", "filename": "gcc/config/ia64/sync.md", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Fconfig%2Fia64%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Fconfig%2Fia64%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fsync.md?ref=f12b785df384d2ffc150cd2f9b449aa4d8a54834", "patch": "@@ -19,22 +19,14 @@\n ;; the Free Software Foundation, 59 Temple Place - Suite 330,\n ;; Boston, MA 02111-1307, USA.\n \n+(define_mode_macro IMODE [QI HI SI DI])\n (define_mode_macro I48MODE [SI DI])\n-(define_mode_attr modesuffix [(SI \"4\") (DI \"8\")])\n+(define_mode_attr modesuffix [(QI \"1\") (HI \"2\") (SI \"4\") (DI \"8\")])\n \n \n-(define_expand \"memory_barrier\"\n-  [(set (mem:BLK (match_dup 0))\n-\t(unspec:BLK [(mem:BLK (match_dup 0))] UNSPEC_MF))]\n-  \"\"\n-{\n-  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (DImode));\n-  MEM_VOLATILE_P (operands[0]) = 1;\n-})\n-\n-(define_insn \"*mf_internal\"\n-  [(set (match_operand:BLK 0 \"\" \"\")\n-\t(unspec:BLK [(match_operand:BLK 1 \"\" \"\")] UNSPEC_MF))]\n+(define_insn \"memory_barrier\"\n+  [(set (mem:BLK (match_scratch:DI 0 \"X\"))\n+\t(unspec:BLK [(mem:BLK (match_scratch:DI 1 \"X\"))] UNSPEC_MF))]\n   \"\"\n   \"mf\"\n   [(set_attr \"itanium_class\" \"syst_m\")])\n@@ -77,10 +69,10 @@\n   [(set_attr \"itanium_class\" \"sem\")])\n \n (define_expand \"sync_compare_and_swap<mode>\"\n-  [(match_operand:I48MODE 0 \"gr_register_operand\" \"\")\n-   (match_operand:I48MODE 1 \"memory_operand\" \"\")\n-   (match_operand:I48MODE 2 \"gr_register_operand\" \"\")\n-   (match_operand:I48MODE 3 \"gr_register_operand\" \"\")]\n+  [(match_operand:IMODE 0 \"gr_register_operand\" \"\")\n+   (match_operand:IMODE 1 \"memory_operand\" \"\")\n+   (match_operand:IMODE 2 \"gr_register_operand\" \"\")\n+   (match_operand:IMODE 3 \"gr_register_operand\" \"\")]\n   \"\"\n {\n   rtx ccv = gen_rtx_REG (DImode, AR_CCV_REGNUM);\n@@ -92,29 +84,29 @@\n })\n \n (define_insn \"cmpxchg_acq_<mode>\"\n-  [(set (match_operand:I48MODE 0 \"gr_register_operand\" \"=r\")\n-\t(match_operand:I48MODE 1 \"not_postinc_memory_operand\" \"+S\"))\n+  [(set (match_operand:IMODE 0 \"gr_register_operand\" \"=r\")\n+\t(match_operand:IMODE 1 \"not_postinc_memory_operand\" \"+S\"))\n    (set (match_dup 1)\n-        (unspec:I48MODE [(match_dup 1)\n-\t\t\t (match_operand:DI 2 \"ar_ccv_reg_operand\" \"\")\n-\t\t\t (match_operand:I48MODE 3 \"gr_register_operand\" \"r\")]\n-\t\t\tUNSPEC_CMPXCHG_ACQ))]\n+        (unspec:IMODE [(match_dup 1)\n+\t\t       (match_operand:DI 2 \"ar_ccv_reg_operand\" \"\")\n+\t\t       (match_operand:IMODE 3 \"gr_register_operand\" \"r\")]\n+\t\t      UNSPEC_CMPXCHG_ACQ))]\n   \"\"\n   \"cmpxchg<modesuffix>.acq %0 = %1, %3, %2\"\n   [(set_attr \"itanium_class\" \"sem\")])\n \n (define_insn \"sync_lock_test_and_set<mode>\"\n-  [(set (match_operand:I48MODE 0 \"gr_register_operand\" \"=r\")\n-        (match_operand:I48MODE 1 \"not_postinc_memory_operand\" \"+S\"))\n+  [(set (match_operand:IMODE 0 \"gr_register_operand\" \"=r\")\n+        (match_operand:IMODE 1 \"not_postinc_memory_operand\" \"+S\"))\n    (set (match_dup 1)\n-        (match_operand:I48MODE 2 \"gr_register_operand\" \"r\"))]\n+        (match_operand:IMODE 2 \"gr_register_operand\" \"r\"))]\n   \"\"\n   \"xchg<modesuffix> %0 = %1, %2\"\n   [(set_attr \"itanium_class\" \"sem\")])\n \n (define_expand \"sync_lock_release<mode>\"\n-  [(set (match_operand:I48MODE 0 \"memory_operand\" \"\")\n-\t(match_operand:I48MODE 1 \"gr_reg_or_0_operand\" \"\"))]\n+  [(set (match_operand:IMODE 0 \"memory_operand\" \"\")\n+\t(match_operand:IMODE 1 \"gr_reg_or_0_operand\" \"\"))]\n   \"\"\n {\n   gcc_assert (MEM_VOLATILE_P (operands[0]));"}, {"sha": "acd75e4f71b44da85316bf7edb46548110398bea", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=f12b785df384d2ffc150cd2f9b449aa4d8a54834", "patch": "@@ -4639,11 +4639,9 @@ returns the value that had previously been in memory.  That is,\n \n @smallexample\n @{ tmp = *ptr; *ptr @var{op}= value; return tmp; @}\n+@{ tmp = *ptr; *ptr = ~tmp & value; return tmp; @}   // nand\n @end smallexample\n \n-The builtin @code{__sync_fetch_and_nand} could be implemented by\n-@code{__sync_fetch_and_and(ptr, ~value)}.\n-\n @item @var{type} __sync_add_and_fetch (@var{type} *ptr, @var{type} value, ...)\n @itemx @var{type} __sync_sub_and_fetch (@var{type} *ptr, @var{type} value, ...)\n @itemx @var{type} __sync_or_and_fetch (@var{type} *ptr, @var{type} value, ...)\n@@ -4661,6 +4659,7 @@ return the new value.  That is,\n \n @smallexample\n @{ *ptr @var{op}= value; return *ptr; @}\n+@{ *ptr = ~*ptr & value; return *ptr; @}   // nand\n @end smallexample\n \n @item bool __sync_bool_compare_and_swap (@var{type} *ptr, @var{type} oldval @var{type} newval, ...)\n@@ -4673,7 +4672,7 @@ value of @code{*@var{ptr}} is @var{oldval}, then write @var{newval} into\n \n The ``bool'' version returns true if the comparison is successful and \n @var{newval} was written.  The ``val'' version returns the contents\n-of @code{*@var{ptr}} after the operation.\n+of @code{*@var{ptr}} before the operation.\n \n @item __sync_synchronize (...)\n @findex __sync_synchronize"}, {"sha": "e1b9e3d3b769735b8758f7002be2aed647a8a961", "filename": "gcc/optabs.c", "status": "modified", "additions": 25, "deletions": 36, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=f12b785df384d2ffc150cd2f9b449aa4d8a54834", "patch": "@@ -5588,12 +5588,17 @@ expand_bool_compare_and_swap (rtx mem, rtx old_val, rtx new_val, rtx target)\n       if (icode == CODE_FOR_nothing)\n \treturn NULL_RTX;\n \n+      /* Ensure that if old_val == mem, that we're not comparing\n+\t against an old value.  */\n+      if (GET_CODE (old_val) == MEM)\n+\told_val = force_reg (mode, old_val);\n+\n       subtarget = expand_val_compare_and_swap_1 (mem, old_val, new_val,\n \t\t\t\t\t\t NULL_RTX, icode);\n       if (subtarget == NULL_RTX)\n \treturn NULL_RTX;\n \n-      emit_cmp_insn (subtarget, new_val, EQ, const0_rtx, mode, true);\n+      emit_cmp_insn (subtarget, old_val, EQ, const0_rtx, mode, true);\n     }\n \n   /* If the target has a sane STORE_FLAG_VALUE, then go ahead and use a\n@@ -5700,7 +5705,7 @@ expand_compare_and_swap_loop (rtx mem, rtx old_reg, rtx new_reg, rtx seq)\n       if (subtarget == NULL_RTX)\n \treturn false;\n \n-      emit_cmp_insn (subtarget, new_reg, EQ, const0_rtx, mode, true);\n+      emit_cmp_insn (subtarget, old_reg, EQ, const0_rtx, mode, true);\n     }\n \n   /* ??? Mark this jump predicted not taken?  */\n@@ -5735,6 +5740,9 @@ expand_sync_operation (rtx mem, rtx val, enum rtx_code code)\n     case AND:\n       icode = sync_and_optab[mode];\n       break;\n+    case NOT:\n+      icode = sync_nand_optab[mode];\n+      break;\n \n     case MINUS:\n       icode = sync_sub_optab[mode];\n@@ -5749,19 +5757,6 @@ expand_sync_operation (rtx mem, rtx val, enum rtx_code code)\n \t}\n       break;\n \n-    case NOT:\n-      icode = sync_nand_optab[mode];\n-      if (icode == CODE_FOR_nothing)\n-\t{\n-\t  icode = sync_and_optab[mode];\n-\t  if (icode != CODE_FOR_nothing)\n-\t    {\n-\t      val = expand_simple_unop (mode, NOT, val, NULL_RTX, 1);\n-\t      code = AND;\n-\t    }\n-\t}\n-      break;\n-\n     default:\n       gcc_unreachable ();\n     }\n@@ -5790,12 +5785,13 @@ expand_sync_operation (rtx mem, rtx val, enum rtx_code code)\n \n       start_sequence ();\n \n+      t1 = t0;\n       if (code == NOT)\n \t{\n-\t  val = expand_simple_unop (mode, NOT, val, NULL_RTX, true);\n+\t  t1 = expand_simple_unop (mode, NOT, t1, NULL_RTX, true);\n \t  code = AND;\n \t}\n-      t1 = expand_simple_binop (mode, code, t0, val, NULL_RTX,\n+      t1 = expand_simple_binop (mode, code, t1, val, NULL_RTX,\n \t\t\t\ttrue, OPTAB_LIB_WIDEN);\n \n       insn = get_insns ();\n@@ -5842,6 +5838,10 @@ expand_sync_fetch_operation (rtx mem, rtx val, enum rtx_code code,\n       old_code = sync_old_and_optab[mode];\n       new_code = sync_new_and_optab[mode];\n       break;\n+    case NOT:\n+      old_code = sync_old_nand_optab[mode];\n+      new_code = sync_new_nand_optab[mode];\n+      break;\n \n     case MINUS:\n       old_code = sync_old_sub_optab[mode];\n@@ -5858,21 +5858,6 @@ expand_sync_fetch_operation (rtx mem, rtx val, enum rtx_code code,\n \t}\n       break;\n \n-    case NOT:\n-      old_code = sync_old_nand_optab[mode];\n-      new_code = sync_new_nand_optab[mode];\n-      if (old_code == CODE_FOR_nothing && new_code == CODE_FOR_nothing)\n-\t{\n-\t  old_code = sync_old_sub_optab[mode];\n-\t  new_code = sync_new_sub_optab[mode];\n-\t  if (old_code != CODE_FOR_nothing || new_code != CODE_FOR_nothing)\n-\t    {\n-\t      val = expand_simple_unop (mode, NOT, val, NULL_RTX, 1);\n-\t      code = AND;\n-\t    }\n-\t}\n-      break;\n-\n     default:\n       gcc_unreachable ();\n     }\n@@ -5933,6 +5918,9 @@ expand_sync_fetch_operation (rtx mem, rtx val, enum rtx_code code,\n \t\t  else if (code == MINUS)\n \t\t    code = PLUS;\n \t\t}\n+\n+\t      if (code == NOT)\n+\t\ttarget = expand_simple_unop (mode, NOT, target, NULL_RTX, true);\n \t      target = expand_simple_binop (mode, code, target, val, NULL_RTX,\n \t\t\t\t\t    true, OPTAB_LIB_WIDEN);\n \t    }\n@@ -5952,14 +5940,15 @@ expand_sync_fetch_operation (rtx mem, rtx val, enum rtx_code code,\n \n       start_sequence ();\n \n+      if (!after)\n+\temit_move_insn (target, t0);\n+      t1 = t0;\n       if (code == NOT)\n \t{\n-\t  val = expand_simple_unop (mode, NOT, val, NULL_RTX, true);\n+\t  t1 = expand_simple_unop (mode, NOT, t1, NULL_RTX, true);\n \t  code = AND;\n \t}\n-      if (!after)\n-\temit_move_insn (target, t0);\n-      t1 = expand_simple_binop (mode, code, t0, val, NULL_RTX,\n+      t1 = expand_simple_binop (mode, code, t1, val, NULL_RTX,\n \t\t\t\ttrue, OPTAB_LIB_WIDEN);\n       if (after)\n \temit_move_insn (target, t1);"}, {"sha": "f256d75a9034ea226e91957298e039d61dad1540", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f12b785df384d2ffc150cd2f9b449aa4d8a54834", "patch": "@@ -1,3 +1,13 @@\n+2005-04-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_vect_int_mult): \n+\tFix typo in exists check.\n+\t(check_effective_target_sync_int_long): New.\n+\t* gcc.dg/ia64-sync-1.c: Enable for all effective-target sync_int_long.\n+\t* gcc.dg/ia64-sync-2.c: Likewise.\n+\t* gcc.dg/ia64-sync-3.c: Likewise.\n+\t* gcc.dg/ia64-sync-4.c: Likewise.\n+\n 2005-04-19  James A. Morrison  <phython@gcc.gnu.org>\n \n \t* gcc.dg/fold-xor-1.c: New test."}, {"sha": "f58f8cb80c3d92d21c54e715b2b6dbd04462d7d7", "filename": "gcc/testsuite/gcc.dg/ia64-sync-1.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-1.c?ref=f12b785df384d2ffc150cd2f9b449aa4d8a54834", "patch": "@@ -1,11 +1,12 @@\n-/* { dg-do run { target ia64-*-* } } */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_long } */\n /* { dg-options } */\n+/* { dg-options \"-march=i486\" { target i?86-*-* } } */\n+/* { dg-options \"-march=i486\" { target { x86_64-*-* && ilp32 } } } */\n \n /* Test basic functionality of the intrinsics.  The operations should\n    not be optimized away if no one checks the return values.  */\n \n-#include <ia64intrin.h>\n-\n extern void abort (void);\n extern void *memcpy (void *, const void *, __SIZE_TYPE__);\n "}, {"sha": "000a2678fea5dada6caf42d738fe314ac7f8a1b6", "filename": "gcc/testsuite/gcc.dg/ia64-sync-2.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-2.c?ref=f12b785df384d2ffc150cd2f9b449aa4d8a54834", "patch": "@@ -1,10 +1,11 @@\n-/* { dg-do run { target ia64-*-* } } */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_long } */\n /* { dg-options } */\n+/* { dg-options \"-march=i486\" { target i?86-*-* } } */\n+/* { dg-options \"-march=i486\" { target { x86_64-*-* && ilp32 } } } */\n \n /* Test basic functionality of the intrinsics.  */\n \n-#include <ia64intrin.h>\n-\n extern void abort (void);\n extern void *memcpy (void *, const void *, __SIZE_TYPE__);\n "}, {"sha": "46f6294aac23fd90c2ccfcebce770669bb4be86a", "filename": "gcc/testsuite/gcc.dg/ia64-sync-3.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-3.c?ref=f12b785df384d2ffc150cd2f9b449aa4d8a54834", "patch": "@@ -1,10 +1,11 @@\n-/* { dg-do run { target ia64-*-* } } */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_long } */\n /* { dg-options } */\n+/* { dg-options \"-march=i486\" { target i?86-*-* } } */\n+/* { dg-options \"-march=i486\" { target { x86_64-*-* && ilp32 } } } */\n \n /* Test basic functionality of the intrinsics.  */\n \n-#include <ia64intrin.h>\n-\n extern void abort (void);\n extern void *memcpy (void *, const void *, __SIZE_TYPE__);\n "}, {"sha": "baeb8527c8739479038b998917f85946007666f2", "filename": "gcc/testsuite/gcc.dg/ia64-sync-4.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fia64-sync-4.c?ref=f12b785df384d2ffc150cd2f9b449aa4d8a54834", "patch": "@@ -1,15 +1,17 @@\n-/* { dg-do compile { target ia64-*-* } } */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target sync_int_long } */\n /* { dg-options \"-O2 -finline-functions\" } */\n+/* { dg-options \"-march=i486\" { target i?86-*-* } } */\n+/* { dg-options \"-march=i486\" { target { x86_64-*-* && ilp32 } } } */\n \n-/* Test inlining __sync_bool_compare_and_swap_di.  */\n+/* Test inlining __sync_bool_compare_and_swap.  */\n \n #include <stdbool.h>\n-#include <ia64intrin.h>\n \n static bool\n compare_and_swap(long *addr, long old, long new_val)\n {\n-  return __sync_bool_compare_and_swap_di(addr, old, new_val);\n+  return __sync_bool_compare_and_swap(addr, old, new_val);\n }\n \n void"}, {"sha": "ab9953f8bed34e610464d553137464a19af955d5", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12b785df384d2ffc150cd2f9b449aa4d8a54834/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=f12b785df384d2ffc150cd2f9b449aa4d8a54834", "patch": "@@ -861,7 +861,7 @@ proc check_effective_target_vect_condition { } {\n proc check_effective_target_vect_int_mult { } {\n     global et_vect_int_mult_saved\n \n-    if [info exists et_vect_int_mult] {\n+    if [info exists et_vect_int_mult_saved] {\n \tverbose \"check_effective_target_vect_int_mult: using cached result\" 2\n     } else {\n \tset et_vect_int_mult_saved 0\n@@ -874,6 +874,27 @@ proc check_effective_target_vect_int_mult { } {\n     return $et_vect_int_mult_saved\n }\n \n+# Return 1 if the target supports atomic operations on \"int\" and \"long\".\n+\n+proc check_effective_target_sync_int_long { } {\n+    global et_sync_int_long_saved\n+\n+    if [info exists et_sync_int_long_saved] {\n+        verbose \"check_effective_target_sync_int_long: using cached result\" 2\n+    } else {\n+        set et_sync_int_long_saved 0\n+        if { [istarget ia64-*-*]\n+\t     || [istarget i?86-*-*]\n+\t     || [istarget x86_64-*-*]\n+\t     || [istarget alpha*-*-*] } {\n+           set et_sync_int_long_saved 1\n+        }\n+    }\n+\n+    verbose \"check_effective_target_sync_int_long: returning $et_sync_int_long_saved\" 2\n+    return $et_sync_int_long_saved\n+}\n+\n # Return 1 if the target matches the effective target 'arg', 0 otherwise.\n # This can be used with any check_* proc that takes no argument and\n # returns only 1 or 0.  It could be used with check_* procs that take"}]}