{"sha": "41947a54d2d19e8432255617cb7b9f28de65c413", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE5NDdhNTRkMmQxOWU4NDMyMjU1NjE3Y2I3YjlmMjhkZTY1YzQxMw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-03-13T23:55:10Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-03-13T23:55:10Z"}, "message": "cppfiles.c (NO_INCLUDE_PATH): New macro.\n\n\t* cppfiles.c (NO_INCLUDE_PATH): New macro.\n\t(find_include_file): Decide here which part of the include\n\tchain to start the search.  Complain about an empty include\n\tchain in all cases apart from an abolsute file name.\n\t(_cpp_execute_include): Don't choose the search chain here.\n\tDon't call handle_missing_include in the case of an empty\n\tinclude chain.\n\t(_cpp_compare_file_date): Don't choose the search chain here.\n\t* cpplib.c (do_include_next): Move the in-main-file diagnostic\n\there from _cpp_execute_include.  Behave like #include if\n\twe're in the main file.\n\nFrom-SVN: r40445", "tree": {"sha": "3fc1eb6452163596e3e8d8e1f8d49711b555bc6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fc1eb6452163596e3e8d8e1f8d49711b555bc6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41947a54d2d19e8432255617cb7b9f28de65c413", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41947a54d2d19e8432255617cb7b9f28de65c413", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41947a54d2d19e8432255617cb7b9f28de65c413", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41947a54d2d19e8432255617cb7b9f28de65c413/comments", "author": null, "committer": null, "parents": [{"sha": "fafcb5c9370abb44c61fbbd68c8b4b09685e86fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fafcb5c9370abb44c61fbbd68c8b4b09685e86fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fafcb5c9370abb44c61fbbd68c8b4b09685e86fa"}], "stats": {"total": 140, "additions": 69, "deletions": 71}, "files": [{"sha": "7a2e6bf22294f77cd3c592b7ce7da282a453553b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41947a54d2d19e8432255617cb7b9f28de65c413/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41947a54d2d19e8432255617cb7b9f28de65c413/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41947a54d2d19e8432255617cb7b9f28de65c413", "patch": "@@ -1,3 +1,17 @@\n+2001-03-13  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cppfiles.c (NO_INCLUDE_PATH): New macro.\n+\t(find_include_file): Decide here which part of the include\n+\tchain to start the search.  Complain about an empty include\n+\tchain in all cases apart from an abolsute file name.\n+\t(_cpp_execute_include): Don't choose the search chain here.\n+\tDon't call handle_missing_include in the case of an empty\n+\tinclude chain.\n+\t(_cpp_compare_file_date): Don't choose the search chain here.\n+\t* cpplib.c (do_include_next): Move the in-main-file diagnostic\n+\there from _cpp_execute_include.  Behave like #include if\n+\twe're in the main file.\n+\n 2001-03-13  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* system.h (malloc, realloc, calloc, strdup): Only poison these"}, {"sha": "d510b8a6550ec8debbee6277e0a0a3fe99f95376", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 47, "deletions": 70, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41947a54d2d19e8432255617cb7b9f28de65c413/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41947a54d2d19e8432255617cb7b9f28de65c413/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=41947a54d2d19e8432255617cb7b9f28de65c413", "patch": "@@ -82,6 +82,7 @@ struct include_file\n #define DO_NOT_REREAD(inc) \\\n ((inc)->cmacro && ((inc)->cmacro == NEVER_REREAD \\\n \t\t   || ((inc)->cmacro->type == NT_MACRO) == (inc)->defined))\n+#define NO_INCLUDE_PATH ((struct include_file *) -1)\n \n static struct file_name_map *read_name_map\n \t\t\t\tPARAMS ((cpp_reader *, const char *));\n@@ -90,9 +91,8 @@ static char *remap_filename \tPARAMS ((cpp_reader *, char *,\n \t\t\t\t\t struct search_path *));\n static struct search_path *search_from PARAMS ((cpp_reader *,\n \t\t\t\t\t\tstruct include_file *));\n-static struct include_file *find_include_file\n-\t\t\t\tPARAMS ((cpp_reader *, const char *,\n-\t\t\t\t\t struct search_path *));\n+static struct include_file *\n+\tfind_include_file PARAMS ((cpp_reader *, const cpp_token *, int));\n static struct include_file *open_file PARAMS ((cpp_reader *, const char *));\n static void read_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n static void stack_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n@@ -487,26 +487,46 @@ cpp_included (pfile, fname)\n   return 0;\n }\n \n-/* Search for include file FNAME in the include chain starting at\n-   SEARCH_START.  Return 0 if there is no such file (or it's un-openable),\n-   otherwise an include_file structure.  */\n+/* Search for HEADER.  Return 0 if there is no such file (or it's\n+   un-openable), in which case an error code will be in errno.  If\n+   there is no include path to use it returns NO_INCLUDE_PATH,\n+   otherwise an include_file structure.  If this request originates\n+   from a #include_next directive, set INCLUDE_NEXT to true.  */\n \n static struct include_file *\n-find_include_file (pfile, fname, search_start)\n+find_include_file (pfile, header, include_next)\n      cpp_reader *pfile;\n-     const char *fname;\n-     struct search_path *search_start;\n+     const cpp_token *header;\n+     int include_next;\n {\n+  const char *fname = (const char *) header->val.str.text;\n   struct search_path *path;\n-  char *name;\n   struct include_file *file;\n+  char *name;\n \n   if (IS_ABSOLUTE_PATHNAME (fname))\n     return open_file (pfile, fname);\n-      \n+\n+  /* For #include_next, skip in the search path past the dir in which\n+     the current file was found.  If this is the last directory in the\n+     search path, don't include anything.  If the current file was\n+     specified with an absolute path, use the normal search logic.  */\n+  if (include_next && pfile->buffer->inc->foundhere)\n+    path = pfile->buffer->inc->foundhere->next;\n+  else if (header->type == CPP_HEADER_NAME)\n+    path = CPP_OPTION (pfile, bracket_include);\n+  else\n+    path = pfile->buffer->search_from;\n+\n+  if (path == NULL)\n+    {\n+      cpp_error (pfile, \"No include path in which to find %s\", fname);\n+      return NO_INCLUDE_PATH;\n+    }\n+\n   /* Search directory path for the file.  */\n   name = (char *) alloca (strlen (fname) + pfile->max_include_len + 2);\n-  for (path = search_start; path; path = path->next)\n+  for (; path; path = path->next)\n     {\n       memcpy (name, path->name, path->len);\n       name[path->len] = '/';\n@@ -631,9 +651,6 @@ _cpp_execute_include (pfile, header, no_reinclude, include_next)\n      int no_reinclude;\n      int include_next;\n {\n-  struct search_path *search_start = 0;\n-  unsigned int angle_brackets = header->type == CPP_HEADER_NAME;\n-  const char *fname = (const char *) header->val.str.text;\n   struct include_file *inc;\n \n   /* Help protect #include or similar from recursion.  */\n@@ -650,45 +667,14 @@ _cpp_execute_include (pfile, header, no_reinclude, include_next)\n       return;\n     }\n \n-  /* For #include_next, skip in the search path past the dir in which\n-     the current file was found.  If this is the last directory in the\n-     search path, don't include anything.  If the current file was\n-     specified with an absolute path, use the normal search logic.  If\n-     this is the primary source file, use the normal search logic and\n-     generate a warning.  */\n-  if (include_next)\n-    {\n-      if (! pfile->buffer->prev)\n-\tcpp_warning (pfile, \"#include_next in primary source file\");\n-      else\n-\t{\n-\t  if (pfile->buffer->inc->foundhere)\n-\t    {\n-\t      search_start = pfile->buffer->inc->foundhere->next;\n-\t      if (! search_start)\n-\t\treturn;\n-\t    }\n-\t}\n-    }\n+  inc = find_include_file (pfile, header, include_next);\n \n-  if (!search_start)\n+  if (inc == 0)\n+    handle_missing_header (pfile, (const char *) header->val.str.text,\n+\t\t\t   header->type == CPP_HEADER_NAME);\n+  else if (inc != NO_INCLUDE_PATH)\n     {\n-      if (angle_brackets)\n-\tsearch_start = CPP_OPTION (pfile, bracket_include);\n-      else\n-\tsearch_start = pfile->buffer->search_from;\n-\n-      if (!search_start)\n-\t{\n-\t  cpp_error (pfile, \"No include path in which to find %s\", fname);\n-\t  return;\n-\t}\n-    }\n-\n-  inc = find_include_file (pfile, fname, search_start);\n-  if (inc)\n-    {\n-      if (angle_brackets)\n+      if (header->type == CPP_HEADER_NAME)\n \tpfile->system_include_depth++;\n \n       stack_include_file (pfile, inc);\n@@ -708,37 +694,28 @@ _cpp_execute_include (pfile, header, no_reinclude, include_next)\n \t    }\n \t}\n     }\n-  else\n-    handle_missing_header (pfile, fname, angle_brackets);\n }\n \n-/* Locate file F, and determine whether it is newer than PFILE. Return -1,\n-   if F cannot be located or dated, 1, if it is newer and 0 if older.  */\n+/* Locate HEADER, and determine whether it is newer than the current\n+   file.  If it cannot be located or dated, return -1, if it is newer\n+   newer, return 1, otherwise 0.  */\n int\n-_cpp_compare_file_date (pfile, f)\n+_cpp_compare_file_date (pfile, header)\n      cpp_reader *pfile;\n-     const cpp_token *f;\n+     const cpp_token *header;\n {\n-  const char *fname = (const char *) f->val.str.text;\n-  struct search_path *search_start;\n-  struct include_file *inc;\n-\n-  if (f->type == CPP_HEADER_NAME)\n-    search_start = CPP_OPTION (pfile, bracket_include);\n-  else\n-    search_start = pfile->buffer->search_from;\n-\n-  inc = find_include_file (pfile, fname, search_start);\n+  struct include_file *inc = find_include_file (pfile, header, 0);\n   \n-  if (!inc)\n+  if (inc == NULL || inc == NO_INCLUDE_PATH)\n     return -1;\n+\n   if (inc->fd > 0)\n     {\n       close (inc->fd);\n       inc->fd = -1;\n     }\n     \n-  return inc->st.st_mtime > CPP_BUFFER (pfile)->inc->st.st_mtime;\n+  return inc->st.st_mtime > pfile->buffer->inc->st.st_mtime;\n }\n \n "}, {"sha": "963ab9b2a9974caba08ef84f0369b4d2b8c0067a", "filename": "gcc/cpplib.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41947a54d2d19e8432255617cb7b9f28de65c413/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41947a54d2d19e8432255617cb7b9f28de65c413/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=41947a54d2d19e8432255617cb7b9f28de65c413", "patch": "@@ -619,7 +619,14 @@ do_include_next (pfile)\n   cpp_token header;\n \n   if (!parse_include (pfile, &header))\n-    _cpp_execute_include (pfile, &header, 0, 1);\n+    {\n+      /* If this is the primary source file, warn and use the normal\n+\t search logic.  */\n+      if (! pfile->buffer->prev)\n+\tcpp_warning (pfile, \"#include_next in primary source file\");\n+\n+      _cpp_execute_include (pfile, &header, 0, pfile->buffer->prev != 0);\n+    }\n }\n \n /* Subroutine of do_line.  Read possible flags after file name.  LAST"}]}