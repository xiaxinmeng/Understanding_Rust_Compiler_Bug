{"sha": "93fc47746815ea9dac413322fcade2931f757e7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNmYzQ3NzQ2ODE1ZWE5ZGFjNDEzMzIyZmNhZGUyOTMxZjc1N2U3Zg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-12T21:25:14Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-12T23:47:04Z"}, "message": "libstdc++: Optimise std::future::wait_for and fix futex polling\n\nTo poll a std::future to see if it's ready you have to call one of the\ntimed waiting functions. The most obvious way is wait_for(0s) but this\nwas previously very inefficient because it would turn the relative\ntimeout to an absolute one by calling system_clock::now(). When the\nrelative timeout is zero (or less) we're obviously going to get a time\nthat has already passed, but the overhead of obtaining the current time\ncan be dozens of microseconds. The alternative is to call wait_until\nwith an absolute timeout that is in the past. If you know the clock's\nepoch is in the past you can use a default constructed time_point.\nAlternatively, using some_clock::time_point::min() gives the earliest\ntime point supported by the clock, which should be safe to assume is in\nthe past. However, using a futex wait with an absolute timeout before\nthe UNIX epoch fails and sets errno=EINVAL. The new code using futex\nwaits with absolute timeouts was not checking for this case, which could\nresult in hangs (or killing the process if the libray is built with\nassertions enabled).\n\nThis patch checks for times before the epoch before attempting to wait\non a futex with an absolute timeout, which fixes the hangs or crashes.\nIt also makes it very fast to poll using an absolute timeout before the\nepoch (because we skip the futex syscall).\n\nIt also makes future::wait_for avoid waiting at all when the relative\ntimeout is zero or less, to avoid the unnecessary overhead of getting\nthe current time. This makes polling with wait_for(0s) take only a few\ncycles instead of dozens of milliseconds.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/future (future::wait_for): Do not wait for\n\tdurations less than or equal to zero.\n\t* src/c++11/futex.cc (_M_futex_wait_until)\n\t(_M_futex_wait_until_steady): Do not wait for timeouts before\n\tthe epoch.\n\t* testsuite/30_threads/future/members/poll.cc: New test.", "tree": {"sha": "3d205d29fd50ca30fc087007cc18c36eab357f7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d205d29fd50ca30fc087007cc18c36eab357f7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93fc47746815ea9dac413322fcade2931f757e7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93fc47746815ea9dac413322fcade2931f757e7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93fc47746815ea9dac413322fcade2931f757e7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93fc47746815ea9dac413322fcade2931f757e7f/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/421d0d0f54294a7bf2872b3b2ac521ce0fa9869e"}], "stats": {"total": 126, "additions": 123, "deletions": 3}, "files": [{"sha": "f7617cac8e932a2929bd24d3e2c4dffd8c88e5b1", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93fc47746815ea9dac413322fcade2931f757e7f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93fc47746815ea9dac413322fcade2931f757e7f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=93fc47746815ea9dac413322fcade2931f757e7f", "patch": "@@ -345,10 +345,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  // to synchronize with the thread that made it ready.\n \t  if (_M_status._M_load(memory_order_acquire) == _Status::__ready)\n \t    return future_status::ready;\n+\n \t  if (_M_is_deferred_future())\n \t    return future_status::deferred;\n-\t  if (_M_status._M_load_when_equal_for(_Status::__ready,\n-\t      memory_order_acquire, __rel))\n+\n+\t  // Don't wait unless the relative time is greater than zero.\n+\t  if (__rel > __rel.zero()\n+\t      && _M_status._M_load_when_equal_for(_Status::__ready,\n+\t\t\t\t\t\t  memory_order_acquire,\n+\t\t\t\t\t\t  __rel))\n \t    {\n \t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t      // 2100.  timed waiting functions must also join\n@@ -377,10 +382,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  // to synchronize with the thread that made it ready.\n \t  if (_M_status._M_load(memory_order_acquire) == _Status::__ready)\n \t    return future_status::ready;\n+\n \t  if (_M_is_deferred_future())\n \t    return future_status::deferred;\n+\n \t  if (_M_status._M_load_when_equal_until(_Status::__ready,\n-\t      memory_order_acquire, __abs))\n+\t\t\t\t\t\t memory_order_acquire,\n+\t\t\t\t\t\t __abs))\n \t    {\n \t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t      // 2100.  timed waiting functions must also join"}, {"sha": "57f7dfe87e9e27b3128db6ddb045c5fcd47ef07c", "filename": "libstdc++-v3/src/c++11/futex.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93fc47746815ea9dac413322fcade2931f757e7f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93fc47746815ea9dac413322fcade2931f757e7f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffutex.cc?ref=93fc47746815ea9dac413322fcade2931f757e7f", "patch": "@@ -78,6 +78,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    struct timespec rt;\n \t    rt.tv_sec = __s.count();\n \t    rt.tv_nsec = __ns.count();\n+\n+\t    // futex sets errno=EINVAL for absolute timeouts before the epoch.\n+\t    if (__builtin_expect(rt.tv_sec < 0, false))\n+\t      return false;\n+\n \t    if (syscall (SYS_futex, __addr,\n \t\t\t futex_wait_bitset_op | futex_clock_realtime_flag,\n \t\t\t __val, &rt, nullptr, futex_bitset_match_any) == -1)\n@@ -151,6 +156,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    rt.tv_sec = __s.count();\n \t    rt.tv_nsec = __ns.count();\n \n+\t    // futex sets errno=EINVAL for absolute timeouts before the epoch.\n+\t    if (__builtin_expect(rt.tv_sec < 0, false))\n+\t      return false;\n+\n \t    if (syscall (SYS_futex, __addr,\n \t\t\t futex_wait_bitset_op | futex_clock_monotonic_flag,\n \t\t\t __val, &rt, nullptr, futex_bitset_match_any) == -1)"}, {"sha": "54580579d3a1dc8f15703c61c5d651f44b087d03", "filename": "libstdc++-v3/testsuite/30_threads/future/members/poll.cc", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93fc47746815ea9dac413322fcade2931f757e7f/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ffuture%2Fmembers%2Fpoll.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93fc47746815ea9dac413322fcade2931f757e7f/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ffuture%2Fmembers%2Fpoll.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ffuture%2Fmembers%2Fpoll.cc?ref=93fc47746815ea9dac413322fcade2931f757e7f", "patch": "@@ -0,0 +1,103 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-O3\" }\n+// { dg-do run { target c++11 } }\n+\n+#include <future>\n+#include <chrono>\n+#include <iostream>\n+#include <testsuite_hooks.h>\n+\n+const int iterations = 200;\n+\n+using namespace std;\n+\n+template<typename Duration>\n+double\n+print(const char* desc, Duration dur)\n+{\n+  auto ns = chrono::duration_cast<chrono::nanoseconds>(dur).count();\n+  double d = double(ns) / iterations;\n+  cout << desc << \": \" << ns << \"ns for \" << iterations\n+    << \" calls, avg \" << d << \"ns per call\\n\";\n+  return d;\n+}\n+\n+int main()\n+{\n+  promise<int> p;\n+  future<int> f = p.get_future();\n+\n+  auto start = chrono::high_resolution_clock::now();\n+  for(int i = 0; i < iterations; i++)\n+    f.wait_for(chrono::seconds(0));\n+  auto stop = chrono::high_resolution_clock::now();\n+  double wait_for_0 = print(\"wait_for(0s)\", stop - start);\n+\n+  start = chrono::high_resolution_clock::now();\n+  for(int i = 0; i < iterations; i++)\n+    f.wait_until(chrono::system_clock::time_point());\n+  stop = chrono::high_resolution_clock::now();\n+  double wait_until_sys_epoch __attribute__((unused))\n+    = print(\"wait_until(system_clock epoch)\", stop - start);\n+\n+  start = chrono::high_resolution_clock::now();\n+  for(int i = 0; i < iterations; i++)\n+    f.wait_until(chrono::steady_clock::time_point());\n+  stop = chrono::high_resolution_clock::now();\n+  double wait_until_steady_epoch __attribute__((unused))\n+    = print(\"wait_until(steady_clock epoch\", stop - start);\n+\n+  start = chrono::high_resolution_clock::now();\n+  for(int i = 0; i < iterations; i++)\n+    f.wait_until(chrono::system_clock::time_point::min());\n+  stop = chrono::high_resolution_clock::now();\n+  double wait_until_sys_min __attribute__((unused))\n+    = print(\"wait_until(system_clock minimum)\", stop - start);\n+\n+  start = chrono::high_resolution_clock::now();\n+  for(int i = 0; i < iterations; i++)\n+    f.wait_until(chrono::steady_clock::time_point::min());\n+  stop = chrono::high_resolution_clock::now();\n+  double wait_until_steady_min __attribute__((unused))\n+    = print(\"wait_until(steady_clock minimum)\", stop - start);\n+\n+  p.set_value(1);\n+\n+  start = chrono::high_resolution_clock::now();\n+  for(int i = 0; i < iterations; i++)\n+    f.wait_for(chrono::seconds(0));\n+  stop = chrono::high_resolution_clock::now();\n+  double ready = print(\"wait_for when ready\", stop - start);\n+\n+  // polling before ready with wait_for(0s) should be almost as fast as\n+  // after the result is ready.\n+  VERIFY( wait_for_0 < (ready * 10) );\n+\n+  // The following two tests fail with GCC 11, see\n+  // https://gcc.gnu.org/pipermail/libstdc++/2020-November/051422.html\n+#if 0\n+  // polling before ready using wait_until(epoch) should not be terribly slow.\n+  VERIFY( wait_until_sys_epoch < (ready * 100) );\n+  VERIFY( wait_until_steady_epoch < (ready * 100) );\n+#endif\n+\n+  // polling before ready using wait_until(min) should not be terribly slow.\n+  VERIFY( wait_until_sys_min < (ready * 100) );\n+  VERIFY( wait_until_steady_min < (ready * 100) );\n+}"}]}