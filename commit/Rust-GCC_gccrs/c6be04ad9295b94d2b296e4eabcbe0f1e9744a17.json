{"sha": "c6be04ad9295b94d2b296e4eabcbe0f1e9744a17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZiZTA0YWQ5Mjk1Yjk0ZDJiMjk2ZTRlYWJjYmUwZjFlOTc0NGExNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-03-23T22:29:53Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-03-23T22:29:53Z"}, "message": "Make lambda conversion op and op() non-static.\n\n\t* semantics.c (maybe_add_lambda_conv_op): Make non-static.\n\tAlso add the thunk function returned by the conversion op.\n\tMark the conversion deleted if the op() is variadic.\n\t* decl2.c (mark_used): Give helpful message about deleted conversion.\n\t* parser.c (cp_parser_lambda_declarator_opt): Don't make op() static.\n\t* semantics.c (finish_this_expr): Adjust.\n\t* mangle.c (write_closure_type_name): Adjust.\n\t* decl.c (grok_op_properties): Don't allow it.\n\t* call.c (build_user_type_conversion_1): No static conversion ops.\n\t(build_op_call): Or op().\n\n\t* decl2.c (change_return_type): Fix 'this' quals.\n\nFrom-SVN: r157681", "tree": {"sha": "fdde8455ca7ffe4a47159148d311a462aca7e170", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdde8455ca7ffe4a47159148d311a462aca7e170"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5b5cfcb3b8177ebe2bf56ef1501b64a054080515", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b5cfcb3b8177ebe2bf56ef1501b64a054080515", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b5cfcb3b8177ebe2bf56ef1501b64a054080515"}], "stats": {"total": 250, "additions": 182, "deletions": 68}, "files": [{"sha": "81df9870121101f2e3e1a641e55431758254d971", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c6be04ad9295b94d2b296e4eabcbe0f1e9744a17", "patch": "@@ -1,3 +1,19 @@\n+2010-03-23  Jason Merrill  <jason@redhat.com>\n+\n+\tMake lambda conversion op and op() non-static.\n+\t* semantics.c (maybe_add_lambda_conv_op): Make non-static.\n+\tAlso add the thunk function returned by the conversion op.\n+\tMark the conversion deleted if the op() is variadic.\n+\t* decl2.c (mark_used): Give helpful message about deleted conversion.\n+\t* parser.c (cp_parser_lambda_declarator_opt): Don't make op() static.\n+\t* semantics.c (finish_this_expr): Adjust.\n+\t* mangle.c (write_closure_type_name): Adjust.\n+\t* decl.c (grok_op_properties): Don't allow it.\n+\t* call.c (build_user_type_conversion_1): No static conversion ops.\n+\t(build_op_call): Or op().\n+\n+\t* decl2.c (change_return_type): Fix 'this' quals.\n+\n 2010-03-22  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/43333"}, {"sha": "edec6eaf57cceef3ab8c620150984db3bf90385d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=c6be04ad9295b94d2b296e4eabcbe0f1e9744a17", "patch": "@@ -2944,16 +2944,11 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n       for (fns = TREE_VALUE (conv_fns); fns; fns = OVL_NEXT (fns))\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n-\t  tree first = first_arg;\n \n \t  if (DECL_NONCONVERTING_P (fn)\n \t      && (flags & LOOKUP_ONLYCONVERTING))\n \t    continue;\n \n-\t  /* Lambdas have a static conversion op.  */\n-\t  if (DECL_STATIC_FUNCTION_P (fn))\n-\t    first = NULL_TREE;\n-\n \t  /* [over.match.funcs] For conversion functions, the function\n \t     is considered to be a member of the class of the implicit\n \t     object argument for the purpose of defining the type of\n@@ -2964,14 +2959,14 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t    cand = add_template_candidate (&candidates, fn, fromtype,\n \t\t\t\t\t   NULL_TREE,\n-\t\t\t\t\t   first, NULL, totype,\n+\t\t\t\t\t   first_arg, NULL, totype,\n \t\t\t\t\t   TYPE_BINFO (fromtype),\n \t\t\t\t\t   conversion_path,\n \t\t\t\t\t   flags,\n \t\t\t\t\t   DEDUCE_CONV);\n \t  else\n \t    cand = add_function_candidate (&candidates, fn, fromtype,\n-\t\t\t\t\t   first, NULL,\n+\t\t\t\t\t   first_arg, NULL,\n \t\t\t\t\t   TYPE_BINFO (fromtype),\n \t\t\t\t\t   conversion_path,\n \t\t\t\t\t   flags);\n@@ -3379,29 +3374,20 @@ build_op_call (tree obj, VEC(tree,gc) **args, tsubst_flags_t complain)\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n \n-\t  tree lfirst = first_mem_arg;\n-\t  if (DECL_STATIC_FUNCTION_P (fn))\n-\t    lfirst = NULL_TREE;\n-\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t    add_template_candidate (&candidates, fn, base, NULL_TREE,\n-\t\t\t\t    lfirst, *args, NULL_TREE,\n+\t\t\t\t    first_mem_arg, *args, NULL_TREE,\n \t\t\t\t    TYPE_BINFO (type),\n \t\t\t\t    TYPE_BINFO (type),\n \t\t\t\t    LOOKUP_NORMAL, DEDUCE_CALL);\n \t  else\n \t    add_function_candidate\n-\t      (&candidates, fn, base, lfirst, *args, TYPE_BINFO (type),\n+\t      (&candidates, fn, base, first_mem_arg, *args, TYPE_BINFO (type),\n \t       TYPE_BINFO (type), LOOKUP_NORMAL);\n \t}\n     }\n \n-  /* Rather than mess with handling static conversion ops here, just don't\n-     look at conversions in lambdas.  */\n-  if (LAMBDA_TYPE_P (type))\n-    convs = NULL_TREE;\n-  else\n-    convs = lookup_conversions (type, /*lookup_template_convs_p=*/true);\n+  convs = lookup_conversions (type, /*lookup_template_convs_p=*/true);\n \n   for (; convs; convs = TREE_CHAIN (convs))\n     {"}, {"sha": "e38abda27352d4d4eb96c98f29323fe1f7f802f8", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c6be04ad9295b94d2b296e4eabcbe0f1e9744a17", "patch": "@@ -10318,13 +10318,8 @@ grok_op_properties (tree decl, bool complain)\n \t      || operator_code == ARRAY_REF\n \t      || operator_code == NOP_EXPR)\n \t    {\n-\t      if (class_type && LAMBDA_TYPE_P (class_type))\n-\t\t/* Lambdas can have static op() and conv ops.  */;\n-\t      else\n-\t\t{\n-\t\t  error (\"%qD must be a nonstatic member function\", decl);\n-\t\t  return false;\n-\t\t}\n+\t      error (\"%qD must be a nonstatic member function\", decl);\n+\t      return false;\n \t    }\n \t  else\n \t    {"}, {"sha": "90adc68c4932cb71871503140ba2bd239a8a140e", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=c6be04ad9295b94d2b296e4eabcbe0f1e9744a17", "patch": "@@ -156,8 +156,9 @@ change_return_type (tree new_ret, tree fntype)\n   if (TREE_CODE (fntype) == FUNCTION_TYPE)\n     newtype = build_function_type (new_ret, args);\n   else\n-    newtype = build_method_type_directly (TYPE_METHOD_BASETYPE (fntype),\n-\t\t\t\t\t  new_ret, TREE_CHAIN (args));\n+    newtype = build_method_type_directly\n+      (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fntype))),\n+       new_ret, TREE_CHAIN (args));\n   if (raises)\n     newtype = build_exception_variant (newtype, raises);\n   if (attrs)\n@@ -4006,6 +4007,18 @@ mark_used (tree decl)\n   if (TREE_CODE (decl) == FUNCTION_DECL\n       && DECL_DELETED_FN (decl))\n     {\n+      if (DECL_ARTIFICIAL (decl))\n+\t{\n+\t  if (DECL_OVERLOADED_OPERATOR_P (decl) == TYPE_EXPR\n+\t      && LAMBDA_TYPE_P (DECL_CONTEXT (decl)))\n+\t    {\n+\t      /* We mark a lambda conversion op as deleted if we can't\n+\t\t generate it properly; see maybe_add_lambda_conv_op.  */\n+\t      sorry (\"converting lambda which uses %<...%> to \"\n+\t\t     \"function pointer\");\n+\t      return;\n+\t    }\n+\t}\n       error (\"deleted function %q+D\", decl);\n       error (\"used here\");\n       return;"}, {"sha": "3b81ea94b95c25702cf739403b64499428f3aa0d", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=c6be04ad9295b94d2b296e4eabcbe0f1e9744a17", "patch": "@@ -1331,7 +1331,7 @@ write_closure_type_name (const tree type)\n   MANGLE_TRACE_TREE (\"closure-type-name\", type);\n \n   write_string (\"Ul\");\n-  write_method_parms (parms, DECL_NONSTATIC_MEMBER_FUNCTION_P (fn), fn);\n+  write_method_parms (parms, /*method_p=*/1, fn);\n   write_char ('E');\n   write_compact_number (LAMBDA_EXPR_DISCRIMINATOR (lambda));\n }"}, {"sha": "cbbfd94938d1caa28beeacd87047e93405a4a3c0", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=c6be04ad9295b94d2b296e4eabcbe0f1e9744a17", "patch": "@@ -7390,18 +7390,8 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n     declarator = make_id_declarator (NULL_TREE, ansi_opname (CALL_EXPR),\n \t\t\t\t     sfk_none);\n \n-    quals = TYPE_UNQUALIFIED;\n-    if (LAMBDA_EXPR_CAPTURE_LIST (lambda_expr) == NULL_TREE\n-\t&& LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr) == CPLD_NONE)\n-      {\n-\t/* A lambda with no captures has a static op() and a conversion op\n-\t   to function type.  */\n-\tif (LAMBDA_EXPR_MUTABLE_P (lambda_expr))\n-\t  error (\"lambda expression with no captures declared mutable\");\n-\treturn_type_specs.storage_class = sc_static;\n-      }\n-    else if (!LAMBDA_EXPR_MUTABLE_P (lambda_expr))\n-      quals = TYPE_QUAL_CONST;\n+    quals = (LAMBDA_EXPR_MUTABLE_P (lambda_expr)\n+\t     ? TYPE_UNQUALIFIED : TYPE_QUAL_CONST);\n     declarator = make_call_declarator (declarator, param_list, quals,\n \t\t\t\t       exception_spec,\n                                        /*late_return_type=*/NULL_TREE);"}, {"sha": "1678e5078e83a9815f492a841099cff526a89e94", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 95, "deletions": 13, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=c6be04ad9295b94d2b296e4eabcbe0f1e9744a17", "patch": "@@ -2104,13 +2104,17 @@ finish_this_expr (void)\n {\n   tree result;\n \n-  /* In a lambda expression, 'this' refers to the captured 'this'.  */\n-  if (current_function_decl\n-      && LAMBDA_FUNCTION_P (current_function_decl))\n-    result = (lambda_expr_this_capture\n-\t      (CLASSTYPE_LAMBDA_EXPR (current_class_type)));\n-  else if (current_class_ptr)\n-    result = current_class_ptr;\n+  if (current_class_ptr)\n+    {\n+      tree type = TREE_TYPE (current_class_ref);\n+\n+      /* In a lambda expression, 'this' refers to the captured 'this'.  */\n+      if (LAMBDA_TYPE_P (type))\n+        result = lambda_expr_this_capture (CLASSTYPE_LAMBDA_EXPR (type));\n+      else\n+        result = current_class_ptr;\n+\n+    }\n   else if (current_function_decl\n \t   && DECL_STATIC_FUNCTION_P (current_function_decl))\n     {\n@@ -5861,14 +5865,22 @@ maybe_add_lambda_conv_op (tree type)\n   bool nested = (current_function_decl != NULL_TREE);\n   tree callop = lambda_function (type);\n   tree rettype, name, fntype, fn, body, compound_stmt;\n+  tree thistype, stattype, statfn, convfn, call, arg;\n+  VEC (tree, gc) *argvec;\n \n-  if (!DECL_STATIC_FUNCTION_P (callop))\n+  if (LAMBDA_EXPR_CAPTURE_LIST (CLASSTYPE_LAMBDA_EXPR (type)) != NULL_TREE)\n     return;\n \n-  rettype = build_pointer_type (TREE_TYPE (callop));\n+  stattype = build_function_type (TREE_TYPE (TREE_TYPE (callop)),\n+\t\t\t\t  FUNCTION_ARG_CHAIN (callop));\n+\n+  /* First build up the conversion op.  */\n+\n+  rettype = build_pointer_type (stattype);\n   name = mangle_conv_op_name_for_type (rettype);\n-  fntype = build_function_type (rettype, void_list_node);\n-  fn = build_lang_decl (FUNCTION_DECL, name, fntype);\n+  thistype = cp_build_qualified_type (type, TYPE_QUAL_CONST);\n+  fntype = build_method_type_directly (thistype, rettype, void_list_node);\n+  fn = convfn = build_lang_decl (FUNCTION_DECL, name, fntype);\n   DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (callop);\n \n   if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_pfn\n@@ -5883,25 +5895,95 @@ maybe_add_lambda_conv_op (tree type)\n   DECL_ARTIFICIAL (fn) = 1;\n   DECL_NOT_REALLY_EXTERN (fn) = 1;\n   DECL_DECLARED_INLINE_P (fn) = 1;\n+  DECL_ARGUMENTS (fn) = build_this_parm (fntype, TYPE_QUAL_CONST);\n+  if (nested)\n+    DECL_INTERFACE_KNOWN (fn) = 1;\n+\n+  add_method (type, fn, NULL_TREE);\n+\n+  /* Generic thunk code fails for varargs; we'll complain in mark_used if\n+     the conversion op is used.  */\n+  if (varargs_function_p (callop))\n+    {\n+      DECL_DELETED_FN (fn) = 1;\n+      return;\n+    }\n+\n+  /* Now build up the thunk to be returned.  */\n+\n+  name = get_identifier (\"_FUN\");\n+  fn = statfn = build_lang_decl (FUNCTION_DECL, name, stattype);\n+  DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (callop);\n+  if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_pfn\n+      && DECL_ALIGN (fn) < 2 * BITS_PER_UNIT)\n+    DECL_ALIGN (fn) = 2 * BITS_PER_UNIT;\n+  grokclassfn (type, fn, NO_SPECIAL);\n+  set_linkage_according_to_type (type, fn);\n+  rest_of_decl_compilation (fn, toplevel_bindings_p (), at_eof);\n+  DECL_IN_AGGR_P (fn) = 1;\n+  DECL_ARTIFICIAL (fn) = 1;\n+  DECL_NOT_REALLY_EXTERN (fn) = 1;\n+  DECL_DECLARED_INLINE_P (fn) = 1;\n   DECL_STATIC_FUNCTION_P (fn) = 1;\n+  DECL_ARGUMENTS (fn) = copy_list (TREE_CHAIN (DECL_ARGUMENTS (callop)));\n+  for (arg = DECL_ARGUMENTS (fn); arg; arg = TREE_CHAIN (arg))\n+    DECL_CONTEXT (arg) = fn;\n   if (nested)\n     DECL_INTERFACE_KNOWN (fn) = 1;\n \n   add_method (type, fn, NULL_TREE);\n \n   if (nested)\n     push_function_context ();\n-  start_preparsed_function (fn, NULL_TREE,\n+\n+  /* Generate the body of the thunk.  */\n+\n+  start_preparsed_function (statfn, NULL_TREE,\n+\t\t\t    SF_PRE_PARSED | SF_INCLASS_INLINE);\n+  if (DECL_ONE_ONLY (statfn))\n+    {\n+      /* Put the thunk in the same comdat group as the call op.  */\n+      struct cgraph_node *callop_node, *thunk_node;\n+      DECL_COMDAT_GROUP (statfn) = DECL_COMDAT_GROUP (callop);\n+      callop_node = cgraph_node (callop);\n+      thunk_node = cgraph_node (statfn);\n+      gcc_assert (callop_node->same_comdat_group == NULL);\n+      gcc_assert (thunk_node->same_comdat_group == NULL);\n+      callop_node->same_comdat_group = thunk_node;\n+      thunk_node->same_comdat_group = callop_node;\n+    }\n+  body = begin_function_body ();\n+  compound_stmt = begin_compound_stmt (0);\n+\n+  arg = build1 (NOP_EXPR, TREE_TYPE (DECL_ARGUMENTS (callop)), void_zero_node);\n+  argvec = make_tree_vector ();\n+  VEC_quick_push (tree, argvec, arg);\n+  for (arg = DECL_ARGUMENTS (statfn); arg; arg = TREE_CHAIN (arg))\n+    VEC_safe_push (tree, gc, argvec, arg);\n+  call = build_cxx_call (callop, VEC_length (tree, argvec),\n+\t\t\t VEC_address (tree, argvec));\n+  CALL_FROM_THUNK_P (call) = 1;\n+  finish_return_stmt (call);\n+\n+  finish_compound_stmt (compound_stmt);\n+  finish_function_body (body);\n+\n+  expand_or_defer_fn (finish_function (2));\n+\n+  /* Generate the body of the conversion op.  */\n+\n+  start_preparsed_function (convfn, NULL_TREE,\n \t\t\t    SF_PRE_PARSED | SF_INCLASS_INLINE);\n   body = begin_function_body ();\n   compound_stmt = begin_compound_stmt (0);\n \n-  finish_return_stmt (decay_conversion (callop));\n+  finish_return_stmt (decay_conversion (statfn));\n \n   finish_compound_stmt (compound_stmt);\n   finish_function_body (body);\n \n   expand_or_defer_fn (finish_function (2));\n+\n   if (nested)\n     pop_function_context ();\n }"}, {"sha": "f97f9c0164244ba2d54963c686ea4dec463f5874", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c6be04ad9295b94d2b296e4eabcbe0f1e9744a17", "patch": "@@ -1,3 +1,12 @@\n+2010-03-23  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/lambda/lambda-const-neg.C: Adjust for non-static op().\n+\t* g++.dg/cpp0x/lambda/lambda-conv.C: Likewise.\n+\t* g++.dg/cpp0x/lambda/lambda-mangle.C: Likewise.\n+\t* g++.dg/cpp0x/lambda/lambda-non-const.C: Likewise.\n+\t* g++.dg/cpp0x/lambda/lambda-conv2.C: New.\n+\t* g++.dg/cpp0x/lambda/lambda-conv3.C: New.\n+\n 2010-03-23  Mike Stump  <mikestump@comcast.net>\n \n \tPR target/33120"}, {"sha": "7e7541ca2eeb1ec749fa916b24cda52adcc80e21", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-const-neg.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-const-neg.C?ref=c6be04ad9295b94d2b296e4eabcbe0f1e9744a17", "patch": "@@ -7,7 +7,7 @@ void call(const F& f) { f(); }\n \n int main() {\n   call([] () -> void {});\n-  call([] () mutable -> void {}); // { dg-message \"\" \"declared mutable\" }\n+  call([] () mutable -> void {});\n \n   int i = -1;\n   call([&i] () -> void { i = 0; });"}, {"sha": "acd7da0b6d8c265748063da6badf88b364cf12e1", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-conv.C", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-conv.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-conv.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-conv.C?ref=c6be04ad9295b94d2b296e4eabcbe0f1e9744a17", "patch": "@@ -1,9 +1,7 @@\n-// Test for conversion from stateless lambda to function pointer, which is\n-// not yet part of the draft but hopefully will be after the March 2010\n-// meeting.\n+// Test for conversion from stateless lambda to function pointer.\n \n // { dg-options -std=c++0x }\n-// { dg-final { scan-assembler \"weak\\[^\\n\\r\\]*_?_ZZ1fvENUlvE_cvPFvvEEv\" { target { ! { *-*-darwin* *-*-mingw* *-*-cygwin } } } } }\n+// { dg-final { scan-assembler \"weak\\[^\\n\\r\\]*_?_ZZ1fvENKUlvE_cvPFvvEEv\" { target { ! { *-*-darwin* *-*-mingw* *-*-cygwin } } } } }\n \n inline void f()\n {"}, {"sha": "fc19c9969d7ce33015efd4fd705813926d5020ae", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-conv2.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-conv2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-conv2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-conv2.C?ref=c6be04ad9295b94d2b296e4eabcbe0f1e9744a17", "patch": "@@ -0,0 +1,12 @@\n+// Test for conversion from stateless lambda to function pointer.\n+\n+// { dg-options -std=c++0x }\n+// { dg-do run }\n+\n+typedef int (*pfn)(int);\n+\n+int main()\n+{\n+  pfn p = [](int i) { return i-42; };\n+  return p (42);\n+}"}, {"sha": "e4e7daffdd5e88d21209fafb116ccfd1432cbd01", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-conv3.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-conv3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-conv3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-conv3.C?ref=c6be04ad9295b94d2b296e4eabcbe0f1e9744a17", "patch": "@@ -0,0 +1,12 @@\n+// Conversion to a function pointer uses a generic thunk, which doesn't\n+// work properly for variadics.  Make sure that we can still use the lambda\n+// normally.\n+\n+// { dg-options -std=c++0x }\n+\n+void f()\n+{\n+  auto l = [](...){};\n+  void (*p1)(...) = l;\t\t// { dg-bogus \"sorry\" \"\" { xfail *-*-* } }\n+  l();\t\t\t\t// OK\n+}"}, {"sha": "5c9b483d3a6cd09f50978c9a201c2900dc563961", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-mangle.C", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-mangle.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-mangle.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-mangle.C?ref=c6be04ad9295b94d2b296e4eabcbe0f1e9744a17", "patch": "@@ -10,8 +10,8 @@ inline void g(int n) {\n   // The closure type is encoded as Z1giEUlvE_.\n   // The call operator of that type is _ZZ1giENKUlvE_clEv.\n \n-// { dg-final { scan-assembler \"_ZZ1giENUlvE_clEv\" } }\n-// { dg-final { scan-assembler \"weak\\[^\\n\\r\\]*_?_ZZ1giENUlvE_clEv\" { target { ! { *-*-darwin* *-*-mingw* *-*-cygwin } } } } }\n+// { dg-final { scan-assembler \"_ZZ1giENKUlvE_clEv\" } }\n+// { dg-final { scan-assembler \"weak\\[^\\n\\r\\]*_?_ZZ1giENKUlvE_clEv\" { target { ! { *-*-darwin* *-*-mingw* *-*-cygwin } } } } }\n \n   algo([=]{return n+bef();});\n   // The captured entities do not participate in <lambda-sig>\n@@ -32,17 +32,17 @@ struct S {\n   void f(int =\n \t // Type: ZN1S1fEiiEd0_UlvE_\n \t // Operator: _ZZN1S1fEiiEd0_NKUlvE_clEv\n-// { dg-final { scan-assembler \"_ZZN1S1fEiiEd0_NUlvE_clEv\" } }\n-// { dg-final { scan-assembler \"weak\\[^\\n\\r\\]*_?_ZZN1S1fEiiEd0_NUlvE_clEv\" { target { ! { *-*-darwin* *-*-mingw* *-*-cygwin } } } } }\n+// { dg-final { scan-assembler \"_ZZN1S1fEiiEd0_NKUlvE_clEv\" } }\n+// { dg-final { scan-assembler \"weak\\[^\\n\\r\\]*_?_ZZN1S1fEiiEd0_NKUlvE_clEv\" { target { ! { *-*-darwin* *-*-mingw* *-*-cygwin } } } } }\n \t []{return 1;}()\n \t // Type: ZN1S1fEiiEd0_UlvE0_\n \t // Operator: _ZZN1S1fEiiEd0_NKUlvE0_clEv\n-// { dg-final { scan-assembler \"_ZZN1S1fEiiEd0_NUlvE0_clEv\" } }\n+// { dg-final { scan-assembler \"_ZZN1S1fEiiEd0_NKUlvE0_clEv\" } }\n \t + []{return 2;}(),\n \t int =\n \t // Type: ZN1S1fEiiEd_UlvE_\n \t // Operator: _ZZN1S1fEiiEd_NKUlvE_clEv\n-// { dg-final { scan-assembler \"_ZZN1S1fEiiEd_NUlvE_clEv\" } }\n+// { dg-final { scan-assembler \"_ZZN1S1fEiiEd_NKUlvE_clEv\" } }\n \t []{return 3;}());\n };\n \n@@ -53,8 +53,8 @@ template<typename T> int R<T>::x = []{return 1;}();\n template int R<int>::x;\n // Type of lambda in intializer of R<int>::x: N1RIiE1xMUlvE_E\n // Corresponding operator(): _ZNK1RIiE1xMUlvE_clEv\n-// { dg-final { scan-assembler \"_ZN1RIiE1xMUlvE_clEv\" } }\n-// { dg-final { scan-assembler \"weak\\[^\\n\\r\\]*_?_ZN1RIiE1xMUlvE_clEv\" { target { ! { *-*-mingw* *-*-cygwin } } } } }\n+// { dg-final { scan-assembler \"_ZNK1RIiE1xMUlvE_clEv\" } }\n+// { dg-final { scan-assembler \"weak\\[^\\n\\r\\]*_?_ZNK1RIiE1xMUlvE_clEv\" { target { ! { *-*-mingw* *-*-cygwin } } } } }\n \n void bar()\n {\n@@ -64,7 +64,7 @@ void bar()\n }\n \n // lambdas used in non-template, non-class body initializers are internal.\n-// { dg-final { scan-assembler-not \"weak\\[^\\n\\r\\]*_ZNUlv\" } }\n+// { dg-final { scan-assembler-not \"weak\\[^\\n\\r\\]*_ZNKUlv\" } }\n // { dg-final { scan-assembler-not \"weak\\[^\\n\\r\\]*variable\" } }\n int variable = []{return 1;}();\n "}, {"sha": "9c2b1195af30d21118f66f66192286ebd045c1ca", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-non-const.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-non-const.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6be04ad9295b94d2b296e4eabcbe0f1e9744a17/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-non-const.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-non-const.C?ref=c6be04ad9295b94d2b296e4eabcbe0f1e9744a17", "patch": "@@ -8,6 +8,7 @@ void call(F f) { f(); }\n \n int main() {\n   call([] () -> void {});\n+  call([] () mutable -> void {});\n \n   int i = -1;\n   call([i] () mutable -> void { i = 0; });"}]}