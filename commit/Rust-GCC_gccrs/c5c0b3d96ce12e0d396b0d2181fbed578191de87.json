{"sha": "c5c0b3d96ce12e0d396b0d2181fbed578191de87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVjMGIzZDk2Y2UxMmUwZDM5NmIwZDIxODFmYmVkNTc4MTkxZGU4Nw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-11-28T14:58:08Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-11-28T14:58:08Z"}, "message": "system.h (IS_DIR_SEPARATOR): Use uppercase macro name.\n\n\t* system.h (IS_DIR_SEPARATOR): Use uppercase macro name.\n\t(IS_ABSOLUTE_PATHNAME): New macro.\n\t* gcc.c (find_a_file, process_command, do_spec_1, main): Use it.\n\nFrom-SVN: r37818", "tree": {"sha": "5f103e128799a70a1832432704583e13f433de18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f103e128799a70a1832432704583e13f433de18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5c0b3d96ce12e0d396b0d2181fbed578191de87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5c0b3d96ce12e0d396b0d2181fbed578191de87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5c0b3d96ce12e0d396b0d2181fbed578191de87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5c0b3d96ce12e0d396b0d2181fbed578191de87/comments", "author": null, "committer": null, "parents": [{"sha": "bb92901dc0ff3fbdb21532566a4f46d197fd55e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb92901dc0ff3fbdb21532566a4f46d197fd55e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb92901dc0ff3fbdb21532566a4f46d197fd55e6"}], "stats": {"total": 51, "additions": 30, "deletions": 21}, "files": [{"sha": "506fae68fafef021231ab3574c1d0b104771f4b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c0b3d96ce12e0d396b0d2181fbed578191de87/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c0b3d96ce12e0d396b0d2181fbed578191de87/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5c0b3d96ce12e0d396b0d2181fbed578191de87", "patch": "@@ -1,3 +1,9 @@\n+Tue Nov 28 09:53:50 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* system.h (IS_DIR_SEPARATOR): Use uppercase macro name.\n+\t(IS_ABSOLUTE_PATHNAME): New macro.\n+\t* gcc.c (find_a_file, process_command, do_spec_1, main): Use it.\n+\n 2000-11-28  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.md (truncxfsf2_2): Fix predicate."}, {"sha": "aaf46b962bb9c1aba8e84b8eb00bcf8f9782d0ec", "filename": "gcc/gcc.c", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c0b3d96ce12e0d396b0d2181fbed578191de87/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c0b3d96ce12e0d396b0d2181fbed578191de87/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=c5c0b3d96ce12e0d396b0d2181fbed578191de87", "patch": "@@ -2242,7 +2242,7 @@ find_a_file (pprefix, name, mode)\n   int len = pprefix->max_len + strlen (name) + strlen (file_suffix) + 1;\n \n #ifdef DEFAULT_ASSEMBLER\n-  if (! strcmp(name, \"as\") && access (DEFAULT_ASSEMBLER, mode) == 0)\n+  if (! strcmp (name, \"as\") && access (DEFAULT_ASSEMBLER, mode) == 0)\n     return xstrdup (DEFAULT_ASSEMBLER);\n #endif\n \n@@ -2258,12 +2258,7 @@ find_a_file (pprefix, name, mode)\n \n   /* Determine the filename to execute (special case for absolute paths).  */\n \n-  if (IS_DIR_SEPARATOR (*name)\n-#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n-      /* Check for disk name on MS-DOS-based systems.  */\n-      || (name[0] && name[1] == ':' && IS_DIR_SEPARATOR (name[2]))\n-#endif\n-      )\n+  if (IS_ABSOLUTE_PATHNAME (name))\n     {\n       if (access (name, mode) == 0)\n \t{\n@@ -2918,6 +2913,7 @@ process_command (argc, argv)\n   if (gcc_exec_prefix)\n     {\n       int len = strlen (gcc_exec_prefix);\n+\n       if (len > (int) sizeof (\"/lib/gcc-lib/\") - 1\n \t  && (IS_DIR_SEPARATOR (gcc_exec_prefix[len-1])))\n \t{\n@@ -3460,7 +3456,7 @@ process_command (argc, argv)\n      directories, so that we can search both the user specified directory\n      and the standard place.  */\n \n-  if (!IS_DIR_SEPARATOR (*tooldir_prefix))\n+  if (!IS_ABSOLUTE_PATHNAME (tooldir_prefix))\n     {\n       if (gcc_exec_prefix)\n \t{\n@@ -3957,7 +3953,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\t  /* Relative directories always come from -B,\n \t\t     and it is better not to use them for searching\n \t\t     at run time.  In particular, stage1 loses.  */\n-\t\t  if (!IS_DIR_SEPARATOR (pl->prefix[0]))\n+\t\t  if (!IS_ABSOLUTE_PATHNAME (pl->prefix))\n \t\t    continue;\n #endif\n \t\t  /* Try subdirectory if there is one.  */\n@@ -5405,14 +5401,7 @@ main (argc, argv)\n \t standard_exec_prefix.  This lets us move the installed tree\n \t as a unit.  If GCC_EXEC_PREFIX is defined, base\n \t standard_startfile_prefix on that as well.  */\n-      if (IS_DIR_SEPARATOR (*standard_startfile_prefix)\n-\t    || *standard_startfile_prefix == '$'\n-#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n-  \t    /* Check for disk name on MS-DOS-based systems.  */\n-          || (standard_startfile_prefix[1] == ':'\n-\t      && (IS_DIR_SEPARATOR (standard_startfile_prefix[2])))\n-#endif\n-\t  )\n+      if (IS_ABSOLUTE_PATHNAME (standard_startfile_prefix))\n \tadd_prefix (&startfile_prefixes, standard_startfile_prefix, \"BINUTILS\",\n \t\t    PREFIX_PRIORITY_LAST, 0, NULL_PTR);\n       else\n@@ -5440,7 +5429,8 @@ main (argc, argv)\n     }\n   else\n     {\n-      if (!IS_DIR_SEPARATOR (*standard_startfile_prefix) && gcc_exec_prefix)\n+      if (!IS_ABSOLUTE_PATHNAME (standard_startfile_prefix)\n+\t  && gcc_exec_prefix)\n \tadd_prefix (&startfile_prefixes,\n \t\t    concat (gcc_exec_prefix, machine_suffix,\n \t\t\t    standard_startfile_prefix, NULL_PTR),"}, {"sha": "59caf48f0e5ace5205f15af15317c14b5d048fc8", "filename": "gcc/system.h", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5c0b3d96ce12e0d396b0d2181fbed578191de87/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5c0b3d96ce12e0d396b0d2181fbed578191de87/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=c5c0b3d96ce12e0d396b0d2181fbed578191de87", "patch": "@@ -538,12 +538,25 @@ extern void abort PARAMS ((void));\n \n /* Define IS_DIR_SEPARATOR.  */\n #ifndef DIR_SEPARATOR_2\n-# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)\n+# define IS_DIR_SEPARATOR(CH) ((CH) == DIR_SEPARATOR)\n #else /* DIR_SEPARATOR_2 */\n-# define IS_DIR_SEPARATOR(ch) \\\n-\t(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))\n+# define IS_DIR_SEPARATOR(CH) \\\n+\t(((CH) == DIR_SEPARATOR) || ((CH) == DIR_SEPARATOR_2))\n #endif /* DIR_SEPARATOR_2 */\n \n+/* Say how to test for an absolute pathname.  On Unix systems, this is if\n+   it starts with a leading slash or a '$', the latter meaning the value of\n+   an environment variable is to be used.  On machien with DOS-based\n+   file systems, it is also absolute if it starts with a drive identifier.  */\n+#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n+#define IS_ABSOLUTE_PATHNAME(STR) \\\n+  (IS_DIR_SEPARATOR ((STR)[0]) || (STR)[0] == '$' \\\n+   || ((STR)[0] != '\\0' && (STR)[1] == ':' && IS_DIR_SEPARATOR ((STR)[2])))\n+#else\n+#define IS_ABSOLUTE_PATHNAME(STR) \\\n+  (IS_DIR_SEPARATOR ((STR)[0]) || (STR)[0] == '$')\n+#endif\n+\n /* Get libiberty declarations. */\n #include \"libiberty.h\"\n "}]}