{"sha": "aca532984541ebca71db7cff750d36f9e25465b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNhNTMyOTg0NTQxZWJjYTcxZGI3Y2ZmNzUwZDM2ZjllMjU0NjViOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-24T13:59:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-24T13:59:23Z"}, "message": "[multiple changes]\n\n2009-04-24  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj.adb, prj.ads, prj-nmsc.adb (Check_File, Record_Ada_Source,\n\tAdd_Source): merge some code between those. In particular change where\n\tfile normalization is done to avoid a few extra calls to\n\tCanonicalize_File_Name. This also removes the need for passing\n\tCurrent_Dir in a number of subprograms.\n\n2009-04-24  Bob Duff  <duff@adacore.com>\n\n\t* lib-load.adb (Make_Instance_Unit): In the case where In_Main is\n\tFalse, assign the correct unit to the Cunit field of the new table\n\tentry. We want the spec unit, not the body unit.\n\n\t* rtsfind.adb (Make_Unit_Name, Maybe_Add_With): Simplify calling\n\tinterface for these.\n\t(Maybe_Add_With): Check whether we're trying to a with on the current\n\tunit, and avoid creating such directly self-referential with clauses.\n\t(Text_IO_Kludge): Add implicit with's for the generic pseudo-children of\n\t[[Wide_]Wide_]Text_IO. These are needed for Walk_Library_Items,\n\tand matches existing comments in the spec.\n\n\t* sem.adb (Walk_Library_Items): Add various special cases to make the\n\tassertions pass.\n\n\t* sem_ch12.adb (Build_Instance_Compilation_Unit_Nodes): Use Body_Cunit\n\tinstead of Parent (N), for uniformity.\n\nFrom-SVN: r146724", "tree": {"sha": "96fd56588b8a31258591454a7a355551de0d5526", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96fd56588b8a31258591454a7a355551de0d5526"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aca532984541ebca71db7cff750d36f9e25465b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aca532984541ebca71db7cff750d36f9e25465b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aca532984541ebca71db7cff750d36f9e25465b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aca532984541ebca71db7cff750d36f9e25465b9/comments", "author": null, "committer": null, "parents": [{"sha": "e211f8596da3e934f0894d9cc3b8637c1667acd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e211f8596da3e934f0894d9cc3b8637c1667acd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e211f8596da3e934f0894d9cc3b8637c1667acd4"}], "stats": {"total": 824, "additions": 426, "deletions": 398}, "files": [{"sha": "634f4cb9418de2544f09812b5dc744eb904d0cfc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca532984541ebca71db7cff750d36f9e25465b9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca532984541ebca71db7cff750d36f9e25465b9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=aca532984541ebca71db7cff750d36f9e25465b9", "patch": "@@ -1,3 +1,31 @@\n+2009-04-24  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj.adb, prj.ads, prj-nmsc.adb (Check_File, Record_Ada_Source,\n+\tAdd_Source): merge some code between those. In particular change where\n+\tfile normalization is done to avoid a few extra calls to\n+\tCanonicalize_File_Name. This also removes the need for passing\n+\tCurrent_Dir in a number of subprograms.\n+\n+2009-04-24  Bob Duff  <duff@adacore.com>\n+\n+\t* lib-load.adb (Make_Instance_Unit): In the case where In_Main is\n+\tFalse, assign the correct unit to the Cunit field of the new table\n+\tentry. We want the spec unit, not the body unit.\n+\n+\t* rtsfind.adb (Make_Unit_Name, Maybe_Add_With): Simplify calling\n+\tinterface for these.\n+\t(Maybe_Add_With): Check whether we're trying to a with on the current\n+\tunit, and avoid creating such directly self-referential with clauses.\n+\t(Text_IO_Kludge): Add implicit with's for the generic pseudo-children of\n+\t[[Wide_]Wide_]Text_IO. These are needed for Walk_Library_Items,\n+\tand matches existing comments in the spec.\n+\n+\t* sem.adb (Walk_Library_Items): Add various special cases to make the\n+\tassertions pass.\n+\n+\t* sem_ch12.adb (Build_Instance_Compilation_Unit_Nodes): Use Body_Cunit\n+\tinstead of Parent (N), for uniformity.\n+\n 2009-04-24  Robert Dewar  <dewar@adacore.com>\n \n \t* errout.ads: Minor reformatting"}, {"sha": "43a39dc8a1eae2f9abd280146a52f0ab729be93c", "filename": "gcc/ada/lib-load.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca532984541ebca71db7cff750d36f9e25465b9/gcc%2Fada%2Flib-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca532984541ebca71db7cff750d36f9e25465b9/gcc%2Fada%2Flib-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-load.adb?ref=aca532984541ebca71db7cff750d36f9e25465b9", "patch": "@@ -812,7 +812,16 @@ package body Lib.Load is\n          --  units table when first loaded as a declaration.\n \n          Units.Table (Units.Last) := Units.Table (Get_Cunit_Unit_Number (N));\n-         Units.Table (Units.Last).Cunit := N;\n+\n+         --  The correct Cunit is the spec -- Library_Unit (N). But that causes\n+         --  gnatmake to fail in certain cases, so this is under control of\n+         --  Inspector_Mode for now. ???\n+\n+         if Inspector_Mode then\n+            Units.Table (Units.Last).Cunit := Library_Unit (N);\n+         else\n+            Units.Table (Units.Last).Cunit := N;\n+         end if;\n       end if;\n    end Make_Instance_Unit;\n "}, {"sha": "dcb835cb3e1f2838c7175b5abb1a935621aec4ef", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 283, "deletions": 309, "changes": 592, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca532984541ebca71db7cff750d36f9e25465b9/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca532984541ebca71db7cff750d36f9e25465b9/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=aca532984541ebca71db7cff750d36f9e25465b9", "patch": "@@ -205,6 +205,9 @@ package body Prj.Nmsc is\n    end record;\n    No_Name_And_Index : constant Name_And_Index :=\n                          (Name => No_Name, Index => 0);\n+   --  Name of a unit, and its index inside the source file. The first unit has\n+   --  index 1 (see doc for pragma Source_File_Name), but the index might be\n+   --  set to 0 when the source file contains a single unit.\n \n    package Reverse_Ada_Naming_Exceptions is new GNAT.HTable.Simple_HTable\n      (Header_Num => Header_Num,\n@@ -233,8 +236,7 @@ package body Prj.Nmsc is\n       Display_File        : File_Name_Type;\n       Lang_Kind           : Language_Kind;\n       Naming_Exception    : Boolean := False;\n-      Path                : Path_Name_Type := No_Path;\n-      Display_Path        : Path_Name_Type := No_Path;\n+      Path                : Path_Information := No_Path_Information;\n       Alternate_Languages : Alternate_Language_Id := No_Alternate_Language;\n       Other_Part          : Source_Id := No_Source;\n       Unit                : Name_Id   := No_Name;\n@@ -355,7 +357,6 @@ package body Prj.Nmsc is\n      (Project               : Project_Id;\n       In_Tree               : Project_Tree_Ref;\n       Data                  : in out Project_Data;\n-      Current_Dir           : String;\n       Explicit_Sources_Only : Boolean);\n    --  Find all Ada sources by traversing all source directories.\n    --  If Explicit_Sources_Only is True, then the sources found must belong to\n@@ -390,10 +391,9 @@ package body Prj.Nmsc is\n      (Project           : Project_Id;\n       In_Tree           : Project_Tree_Ref;\n       Data              : in out Project_Data;\n-      Name              : String;\n+      Path              : Path_Name_Type;\n       File_Name         : File_Name_Type;\n       Display_File_Name : File_Name_Type;\n-      Source_Directory  : String;\n       For_All_Sources   : Boolean);\n    --  Check if file File_Name is a valid source of the project. This is used\n    --  in multi-language mode only.\n@@ -464,8 +464,7 @@ package body Prj.Nmsc is\n    --  Source_Names.\n \n    procedure Find_Sources\n-     (Current_Dir : String;\n-      Project     : Project_Id;\n+     (Project     : Project_Id;\n       In_Tree     : Project_Tree_Ref;\n       Data        : in out Project_Data);\n    --  Process the Source_Files and Source_List_File attributes, and store\n@@ -499,7 +498,7 @@ package body Prj.Nmsc is\n    --  specific SFN pragma is needed. If the file name corresponds to no unit,\n    --  then Unit_Name will be No_Name. If the file is a multi-unit source or an\n    --  exception to the naming scheme, then Exception_Id is set to the unit or\n-   --  units that the source contains.\n+   --  units that the source contains, and the other information are not set.\n \n    function Is_Illegal_Suffix\n      (Suffix          : File_Name_Type;\n@@ -532,15 +531,11 @@ package body Prj.Nmsc is\n    procedure Look_For_Sources\n      (Project     : Project_Id;\n       In_Tree     : Project_Tree_Ref;\n-      Data        : in out Project_Data;\n-      Current_Dir : String);\n+      Data        : in out Project_Data);\n    --  Find all the sources of project Project in project tree In_Tree and\n    --  update its Data accordingly. This assumes that Data.First_Source has\n    --  been initialized with the list of excluded sources and special naming\n    --  exceptions.\n-   --\n-   --  Current_Dir should represent the current directory, and is passed for\n-   --  efficiency to avoid system calls to recompute it.\n \n    function Path_Name_Of\n      (File_Name : File_Name_Type;\n@@ -561,15 +556,12 @@ package body Prj.Nmsc is\n       Project         : Project_Id;\n       In_Tree         : Project_Tree_Ref;\n       Data            : in out Project_Data;\n+      Ada_Language    : Language_Ptr;\n       Location        : Source_Ptr;\n-      Current_Source  : in out String_List_Id;\n-      Source_Recorded : in out Boolean;\n-      Current_Dir     : String);\n+      Source_Recorded : in out Boolean);\n    --  Put a unit in the list of units of a project, if the file name\n    --  corresponds to a valid unit name.\n-   --\n-   --  Current_Dir should represent the current directory, and is passed for\n-   --  efficiency to avoid system calls to recompute it.\n+   --  Ada_Language is a pointer to the Language_Data for \"Ada\" in Project.\n \n    procedure Remove_Source\n      (Id          : Source_Id;\n@@ -684,8 +676,7 @@ package body Prj.Nmsc is\n       Display_File        : File_Name_Type;\n       Lang_Kind           : Language_Kind;\n       Naming_Exception    : Boolean := False;\n-      Path                : Path_Name_Type := No_Path;\n-      Display_Path        : Path_Name_Type := No_Path;\n+      Path                : Path_Information := No_Path_Information;\n       Alternate_Languages : Alternate_Language_Id := No_Alternate_Language;\n       Other_Part          : Source_Id := No_Source;\n       Unit                : Name_Id   := No_Name;\n@@ -744,9 +735,9 @@ package body Prj.Nmsc is\n          Id.Switches := Switches_Name (File_Name);\n       end if;\n \n-      if Path /= No_Path then\n-         Id.Path := (Path, Display_Path);\n-         Source_Paths_Htable.Set (In_Tree.Source_Paths_HT, Path, Id);\n+      if Path /= No_Path_Information then\n+         Id.Path := Path;\n+         Source_Paths_Htable.Set (In_Tree.Source_Paths_HT, Path.Name, Id);\n       end if;\n \n       --  Add the source id to the Unit_Sources_HT hash table, if the unit name\n@@ -870,7 +861,7 @@ package body Prj.Nmsc is\n       --  Find the sources\n \n       if Data.Source_Dirs /= Nil_String then\n-         Look_For_Sources (Project, In_Tree, Data, Current_Dir);\n+         Look_For_Sources (Project, In_Tree, Data);\n \n          if Get_Mode = Ada_Only then\n \n@@ -6895,8 +6886,7 @@ package body Prj.Nmsc is\n    ------------------\n \n    procedure Find_Sources\n-     (Current_Dir : String;\n-      Project     : Project_Id;\n+     (Project     : Project_Id;\n       In_Tree     : Project_Tree_Ref;\n       Data        : in out Project_Data)\n    is\n@@ -7056,7 +7046,7 @@ package body Prj.Nmsc is\n \n       if Get_Mode = Ada_Only then\n          Find_Ada_Sources\n-           (Project, In_Tree, Data, Current_Dir,\n+           (Project, In_Tree, Data,\n             Explicit_Sources_Only => Has_Explicit_Sources);\n \n       else\n@@ -7152,21 +7142,27 @@ package body Prj.Nmsc is\n      (Project               : Project_Id;\n       In_Tree               : Project_Tree_Ref;\n       Data                  : in out Project_Data;\n-      Current_Dir           : String;\n       Explicit_Sources_Only : Boolean)\n    is\n       Source_Dir      : String_List_Id;\n       Element         : String_Element;\n       Dir             : Dir_Type;\n-      Current_Source  : String_List_Id := Nil_String;\n       Dir_Has_Source  : Boolean := False;\n       NL              : Name_Location;\n+      Ada_Language    : Language_Ptr;\n \n    begin\n       if Current_Verbosity = High then\n          Write_Line (\"Looking for Ada sources:\");\n       end if;\n \n+      Ada_Language := Data.Languages;\n+      while Ada_Language /= No_Language_Index\n+        and then Ada_Language.Name /= Name_Ada\n+      loop\n+         Ada_Language := Ada_Language.Next;\n+      end loop;\n+\n       --  We look in all source directories for the file names in the hash\n       --  table Source_Names.\n \n@@ -7213,7 +7209,7 @@ package body Prj.Nmsc is\n                       (Name           => Name_Buffer (1 .. Name_Len),\n                        Directory      => Dir_Path (Dir_Path'First .. Dir_Last),\n                        Resolve_Links  => Opt.Follow_Links_For_Files,\n-                       Case_Sensitive => True);\n+                       Case_Sensitive => True);  -- no case folding\n \n                   Path_Name : Path_Name_Type;\n                   To_Record : Boolean := False;\n@@ -7257,10 +7253,9 @@ package body Prj.Nmsc is\n                         Project         => Project,\n                         In_Tree         => In_Tree,\n                         Data            => Data,\n+                        Ada_Language    => Ada_Language,\n                         Location        => Location,\n-                        Current_Source  => Current_Source,\n-                        Source_Recorded => Dir_Has_Source,\n-                        Current_Dir     => Current_Dir);\n+                        Source_Recorded => Dir_Has_Source);\n                   end if;\n                end;\n             end loop;\n@@ -7435,22 +7430,14 @@ package body Prj.Nmsc is\n      (Project           : Project_Id;\n       In_Tree           : Project_Tree_Ref;\n       Data              : in out Project_Data;\n-      Name              : String;\n+      Path              : Path_Name_Type;\n       File_Name         : File_Name_Type;\n       Display_File_Name : File_Name_Type;\n-      Source_Directory  : String;\n       For_All_Sources   : Boolean)\n    is\n-      Display_Path    : constant String :=\n-        Normalize_Pathname\n-          (Name           => Name,\n-           Directory      => Source_Directory,\n-           Resolve_Links  => Opt.Follow_Links_For_Files,\n-           Case_Sensitive => True);\n-\n+      Canonical_Path : constant Path_Name_Type :=\n+        Path_Name_Type (Canonical_Case_File_Name (Name_Id (Path)));\n       Name_Loc          : Name_Location := Source_Names.Get (File_Name);\n-      Path_Id           : Path_Name_Type;\n-      Display_Path_Id   : Path_Name_Type;\n       Check_Name        : Boolean := False;\n       Alternate_Languages : Alternate_Language_Id := No_Alternate_Language;\n       Language          : Language_Ptr;\n@@ -7468,17 +7455,6 @@ package body Prj.Nmsc is\n       Iter                  : Source_Iterator;\n \n    begin\n-      Name_Len := Display_Path'Length;\n-      Name_Buffer (1 .. Name_Len) := Display_Path;\n-      Display_Path_Id := Name_Find;\n-\n-      if Osint.File_Names_Case_Sensitive then\n-         Path_Id := Display_Path_Id;\n-      else\n-         Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-         Path_Id := Name_Find;\n-      end if;\n-\n       if Name_Loc = No_Name_Location then\n          Check_Name := For_All_Sources;\n \n@@ -7505,11 +7481,11 @@ package body Prj.Nmsc is\n                Check_Name := True;\n \n             else\n-               Name_Loc.Source.Path := (Path_Id, Display_Path_Id);\n+               Name_Loc.Source.Path := (Canonical_Path, Path);\n \n                Source_Paths_Htable.Set\n                  (In_Tree.Source_Paths_HT,\n-                  Path_Id,\n+                  Canonical_Path,\n                   Name_Loc.Source);\n \n                --  Check if this is a subunit\n@@ -7518,7 +7494,7 @@ package body Prj.Nmsc is\n                  and then Name_Loc.Source.Kind = Impl\n                then\n                   Src_Ind := Sinput.P.Load_Project_File\n-                    (Get_Name_String (Path_Id));\n+                    (Get_Name_String (Canonical_Path));\n \n                   if Sinput.P.Source_File_Is_Subunit (Src_Ind) then\n                      Name_Loc.Source.Kind := Sep;\n@@ -7631,7 +7607,7 @@ package body Prj.Nmsc is\n \n                      Error_Msg_Name_1 :=\n                        In_Tree.Projects.Table (Project).Name;\n-                     Error_Msg_Name_2 := Name_Id (Display_Path_Id);\n+                     Error_Msg_Name_2 := Name_Id (Path);\n                      Error_Msg\n                        (Project, In_Tree, \"\\  project %%, %%\", No_Location);\n \n@@ -7661,8 +7637,7 @@ package body Prj.Nmsc is\n                   Display_File        => Display_File_Name,\n                   Other_Part          => Other_Part,\n                   Unit                => Unit,\n-                  Path                => Path_Id,\n-                  Display_Path        => Display_Path_Id,\n+                  Path                => (Canonical_Path, Path),\n                   Source_To_Replace   => Source_To_Replace);\n             end if;\n          end if;\n@@ -7749,10 +7724,23 @@ package body Prj.Nmsc is\n                         end if;\n \n                         declare\n+                           Path_Name : constant String :=\n+                               Normalize_Pathname\n+                                 (Name (1 .. Last),\n+                                  Directory      => Source_Directory\n+                                    (Source_Directory'First .. Dir_Last),\n+                                  Resolve_Links  => Opt.Follow_Links_For_Files,\n+                                  Case_Sensitive => True); --  no folding\n+                           Path : Path_Name_Type;\n+\n                            FF : File_Found :=\n                                   Excluded_Sources_Htable.Get (File_Name);\n \n                         begin\n+                           Name_Len := Path_Name'Length;\n+                           Name_Buffer (1 .. Name_Len) := Path_Name;\n+                           Path := Name_Find;\n+\n                            if FF /= No_File_Found then\n                               if not FF.Found then\n                                  FF.Found := True;\n@@ -7771,11 +7759,9 @@ package body Prj.Nmsc is\n                                 (Project           => Project,\n                                  In_Tree           => In_Tree,\n                                  Data              => Data,\n-                                 Name              => Name (1 .. Last),\n+                                 Path              => Path,\n                                  File_Name         => File_Name,\n                                  Display_File_Name => Display_File_Name,\n-                                 Source_Directory  => Source_Directory\n-                                   (Source_Directory'First .. Dir_Last),\n                                  For_All_Sources   => For_All_Sources);\n                            end if;\n                         end;\n@@ -7874,8 +7860,7 @@ package body Prj.Nmsc is\n    procedure Look_For_Sources\n      (Project     : Project_Id;\n       In_Tree     : Project_Tree_Ref;\n-      Data        : in out Project_Data;\n-      Current_Dir : String)\n+      Data        : in out Project_Data)\n    is\n       Iter : Source_Iterator;\n \n@@ -8113,7 +8098,7 @@ package body Prj.Nmsc is\n             Load_Naming_Exceptions (Project, In_Tree);\n          end if;\n \n-         Find_Sources (Current_Dir, Project, In_Tree, Data);\n+         Find_Sources (Project, In_Tree, Data);\n          Mark_Excluded_Sources;\n \n          if Get_Mode = Multi_Language then\n@@ -8204,287 +8189,276 @@ package body Prj.Nmsc is\n       Project         : Project_Id;\n       In_Tree         : Project_Tree_Ref;\n       Data            : in out Project_Data;\n+      Ada_Language    : Language_Ptr;\n       Location        : Source_Ptr;\n-      Current_Source  : in out String_List_Id;\n-      Source_Recorded : in out Boolean;\n-      Current_Dir     : String)\n+      Source_Recorded : in out Boolean)\n    is\n-      Canonical_File_Name : File_Name_Type;\n-      Canonical_Path_Name : Path_Name_Type;\n-\n-      Exception_Id : Ada_Naming_Exception_Id;\n-      Unit_Name    : Name_Id;\n-      Unit_Kind    : Spec_Or_Body;\n-      Unit_Ind     : Int := 0;\n-      Info         : Unit_Info;\n-      Name_Index   : Name_And_Index;\n-      Needs_Pragma : Boolean;\n+      Canonical_File : File_Name_Type;\n+      Canonical_Path : Path_Name_Type;\n \n-      The_Location    : Source_Ptr              := Location;\n-      Previous_Source : constant String_List_Id := Current_Source;\n-      Except_Name     : Name_And_Index          := No_Name_And_Index;\n+      File_Recorded  : Boolean := False;\n+      --  True when at least one file has been recorded\n \n-      Unit_Prj : Unit_Project;\n+      procedure Record_Unit\n+        (Unit_Name    : Name_Id;\n+         Unit_Ind     : Int := 0;\n+         Unit_Kind    : Spec_Or_Body;\n+         Needs_Pragma : Boolean);\n+      --  Register of the units contained in the source file (there is in\n+      --  general a single such unit except when exceptions to the naming\n+      --  scheme indicate there are several such units)\n \n-      File_Name_Recorded : Boolean := False;\n+      -----------------\n+      -- Record_Unit --\n+      -----------------\n \n-   begin\n-      Canonical_File_Name := Canonical_Case_File_Name (Name_Id (File_Name));\n+      procedure Record_Unit\n+        (Unit_Name    : Name_Id;\n+         Unit_Ind     : Int := 0;\n+         Unit_Kind    : Spec_Or_Body;\n+         Needs_Pragma : Boolean)\n+      is\n+         The_Unit      : Unit_Index :=\n+           Units_Htable.Get (In_Tree.Units_HT, Unit_Name);\n+         UData         : Unit_Data;\n+         Kind          : Source_Kind;\n+         Source        : Source_Id;\n+         Unit_Prj      : Unit_Project;\n+         To_Record     : Boolean := False;\n+         The_Location  : Source_Ptr := Location;\n \n-      if Osint.File_Names_Case_Sensitive then\n-         Canonical_Path_Name := Path_Name;\n-      else\n-         declare\n-            Canonical_Path : constant String :=\n-                               Normalize_Pathname\n-                                 (Get_Name_String (Path_Name),\n-                                  Directory      => Current_Dir,\n-                                  Resolve_Links  => Opt.Follow_Links_For_Files,\n-                                  Case_Sensitive => False);\n-         begin\n-            Name_Len := 0;\n-            Add_Str_To_Name_Buffer (Canonical_Path);\n-            Canonical_Path_Name := Name_Find;\n-         end;\n-      end if;\n+      begin\n+         if Current_Verbosity = High then\n+            Write_Str  (\"   Putting \");\n+            Write_Str  (Get_Name_String (Unit_Name));\n+            Write_Line (\" in the unit list.\");\n+         end if;\n \n-      --  Find out the unit name, the unit kind and if it needs\n-      --  a specific SFN pragma.\n+         --  The unit is already in the list, but may be it is only the other\n+         --  unit kind (spec or body), or what is in the unit list is a unit of\n+         --  a project we are extending.\n \n-      Get_Unit\n-        (In_Tree             => In_Tree,\n-         Canonical_File_Name => Canonical_File_Name,\n-         Naming              => Data.Naming,\n-         Exception_Id        => Exception_Id,\n-         Unit_Name           => Unit_Name,\n-         Unit_Kind           => Unit_Kind,\n-         Needs_Pragma        => Needs_Pragma);\n+         if The_Unit /= No_Unit_Index then\n+            UData := In_Tree.Units.Table (The_Unit);\n \n-      if Exception_Id = No_Ada_Naming_Exception\n-        and then Unit_Name = No_Name\n-      then\n-         if Current_Verbosity = High then\n-            Write_Str  (\"   \"\"\");\n-            Write_Str  (Get_Name_String (Canonical_File_Name));\n-            Write_Line (\"\"\" is not a valid source file name (ignored).\");\n-         end if;\n+            if (UData.File_Names (Unit_Kind).Name = Canonical_File\n+                and then UData.File_Names (Unit_Kind).Path.Name = Slash)\n+              or else UData.File_Names (Unit_Kind).Name = No_File\n+              or else Is_Extending\n+                (Data.Extends,\n+                 UData.File_Names (Unit_Kind).Project,\n+                 In_Tree)\n+            then\n+               if UData.File_Names (Unit_Kind).Path.Name = Slash then\n+                  Remove_Forbidden_File_Name\n+                    (UData.File_Names (Unit_Kind).Name);\n+               end if;\n \n-      else\n-         --  Check to see if the source has been hidden by an exception,\n-         --  but only if it is not an exception.\n+               --  Record the file name in the hash table Files_Htable\n+\n+               Unit_Prj := (Unit => The_Unit, Project => Project);\n+               Files_Htable.Set\n+                 (In_Tree.Files_HT,\n+                  Canonical_File,\n+                  Unit_Prj);\n+\n+               UData.File_Names (Unit_Kind) :=\n+                 (Name         => Canonical_File,\n+                  Index        => Unit_Ind,\n+                  Display_Name => File_Name,\n+                  Path         => (Canonical_Path, Path_Name),\n+                  Project      => Project,\n+                  Needs_Pragma => Needs_Pragma);\n+               In_Tree.Units.Table (The_Unit) := UData;\n+               To_Record       := True;\n+               Source_Recorded := True;\n+\n+            --  If the same file is already in the list, do not add it again\n+\n+            elsif UData.File_Names (Unit_Kind).Project = Project\n+              and then\n+                (Data.Known_Order_Of_Source_Dirs\n+                 or else\n+                   UData.File_Names (Unit_Kind).Path.Name = Canonical_Path)\n+            then\n+               To_Record := False;\n \n-         if not Needs_Pragma then\n-            Except_Name :=\n-              Reverse_Ada_Naming_Exceptions.Get\n-                ((Unit_Kind, Unit_Name, No_Ada_Naming_Exception));\n+            --  Else, same unit but not same file => It is an error to have two\n+            --  units with the same name and the same kind (spec or body).\n \n-            if Except_Name /= No_Name_And_Index then\n-               if Current_Verbosity = High then\n-                  Write_Str  (\"   \"\"\");\n-                  Write_Str  (Get_Name_String (Canonical_File_Name));\n-                  Write_Str  (\"\"\" contains a unit that is found in \"\"\");\n-                  Write_Str  (Get_Name_String (Except_Name.Name));\n-                  Write_Line (\"\"\" (ignored).\");\n+            else\n+               if The_Location = No_Location then\n+                  The_Location := In_Tree.Projects.Table (Project).Location;\n                end if;\n \n-               --  The file is not included in the source of the project since\n-               --  it is hidden by the exception. So, nothing else to do.\n+               Err_Vars.Error_Msg_Name_1 := Unit_Name;\n+               Error_Msg\n+                 (Project, In_Tree, \"duplicate unit %%\", The_Location);\n \n-               return;\n-            end if;\n-         end if;\n+               Err_Vars.Error_Msg_Name_1 :=\n+                 In_Tree.Projects.Table\n+                   (UData.File_Names (Unit_Kind).Project).Name;\n+               Err_Vars.Error_Msg_File_1 :=\n+                 File_Name_Type (UData.File_Names (Unit_Kind).Path.Name);\n+               Error_Msg\n+                 (Project, In_Tree,\n+                  \"\\   project file %%, {\", The_Location);\n \n-         loop\n-            if Exception_Id /= No_Ada_Naming_Exception then\n-               Info := Ada_Naming_Exception_Table.Table (Exception_Id);\n-               Exception_Id := Info.Next;\n-               Info.Next := No_Ada_Naming_Exception;\n-               Name_Index := Reverse_Ada_Naming_Exceptions.Get (Info);\n-\n-               Unit_Name := Info.Unit;\n-               Unit_Ind  := Name_Index.Index;\n-               Unit_Kind := Info.Kind;\n-            end if;\n+               Err_Vars.Error_Msg_Name_1 :=\n+                 In_Tree.Projects.Table (Project).Name;\n+               Err_Vars.Error_Msg_File_1 := File_Name_Type (Canonical_Path);\n+               Error_Msg\n+                 (Project, In_Tree, \"\\   project file %%, {\", The_Location);\n \n-            --  Put the file name in the list of sources of the project\n-\n-            String_Element_Table.Increment_Last (In_Tree.String_Elements);\n-            In_Tree.String_Elements.Table\n-              (String_Element_Table.Last (In_Tree.String_Elements)) :=\n-                (Value         => Name_Id (Canonical_File_Name),\n-                 Display_Value => Name_Id (File_Name),\n-                 Location      => No_Location,\n-                 Flag          => False,\n-                 Next          => Nil_String,\n-                 Index         => Unit_Ind);\n-\n-            if Current_Source = Nil_String then\n-               Data.Ada_Sources :=\n-                 String_Element_Table.Last (In_Tree.String_Elements);\n-            else\n-               In_Tree.String_Elements.Table (Current_Source).Next :=\n-                 String_Element_Table.Last (In_Tree.String_Elements);\n+               To_Record := False;\n             end if;\n \n-            Current_Source :=\n-              String_Element_Table.Last (In_Tree.String_Elements);\n+         --  It is a new unit, create a new record\n \n-            --  Put the unit in unit list\n+         else\n+            --  First, check if there is no other unit with this file name in\n+            --  another project. If it is, report error but note we do that\n+            --  only for the first unit in the source file.\n \n-            declare\n-               The_Unit : Unit_Index :=\n-                            Units_Htable.Get (In_Tree.Units_HT, Unit_Name);\n+            Unit_Prj := Files_Htable.Get (In_Tree.Files_HT, Canonical_File);\n \n-               The_Unit_Data : Unit_Data;\n+            if not File_Recorded\n+              and then Unit_Prj /= No_Unit_Project\n+            then\n+               Error_Msg_File_1 := File_Name;\n+               Error_Msg_Name_1 :=\n+                 In_Tree.Projects.Table (Unit_Prj.Project).Name;\n+               Error_Msg\n+                 (Project, In_Tree,\n+                  \"{ is already a source of project %%\",\n+                  Location);\n \n-            begin\n-               if Current_Verbosity = High then\n-                  Write_Str  (\"   Putting \");\n-                  Write_Str  (Get_Name_String (Unit_Name));\n-                  Write_Line (\" in the unit list.\");\n-               end if;\n+            else\n+               Unit_Table.Increment_Last (In_Tree.Units);\n+               The_Unit := Unit_Table.Last (In_Tree.Units);\n+               Units_Htable.Set (In_Tree.Units_HT, Unit_Name, The_Unit);\n+\n+               Unit_Prj := (Unit => The_Unit, Project => Project);\n+               Files_Htable.Set (In_Tree.Files_HT, Canonical_File, Unit_Prj);\n+\n+               UData.Name := Unit_Name;\n+               UData.File_Names (Unit_Kind) :=\n+                 (Name         => Canonical_File,\n+                  Index        => Unit_Ind,\n+                  Display_Name => File_Name,\n+                  Path         => (Canonical_Path, Path_Name),\n+                  Project      => Project,\n+                  Needs_Pragma => Needs_Pragma);\n+               In_Tree.Units.Table (The_Unit) := UData;\n+\n+               Source_Recorded := True;\n+               To_Record := True;\n+            end if;\n+         end if;\n \n-               --  The unit is already in the list, but may be it is\n-               --  only the other unit kind (spec or body), or what is\n-               --  in the unit list is a unit of a project we are extending.\n+         if To_Record then\n+            case Unit_Kind is\n+               when Body_Part      => Kind := Impl;\n+               when Specification  => Kind := Spec;\n+            end case;\n \n-               if The_Unit /= No_Unit_Index then\n-                  The_Unit_Data := In_Tree.Units.Table (The_Unit);\n+            Add_Source\n+              (Id                  => Source,\n+               In_Tree             => In_Tree,\n+               Project             => Project,\n+               Lang_Id             => Ada_Language,\n+               Lang_Kind           => Unit_Based,\n+               File_Name           => Canonical_File,\n+               Display_File        => File_Name,\n+               Unit                => Unit_Name,\n+               Path                => (Canonical_Path, Path_Name),\n+               Kind                => Kind,\n+               Other_Part          => No_Source);  --  ??? Can we find file ?\n+         end if;\n+      end Record_Unit;\n \n-                  if (The_Unit_Data.File_Names (Unit_Kind).Name =\n-                                                          Canonical_File_Name\n-                        and then\n-                        The_Unit_Data.File_Names\n-                          (Unit_Kind).Path.Name = Slash)\n-                    or else The_Unit_Data.File_Names (Unit_Kind).Name = No_File\n-                    or else Is_Extending\n-                      (Data.Extends,\n-                       The_Unit_Data.File_Names (Unit_Kind).Project,\n-                       In_Tree)\n-                  then\n-                     if\n-                       The_Unit_Data.File_Names (Unit_Kind).Path.Name = Slash\n-                     then\n-                        Remove_Forbidden_File_Name\n-                          (The_Unit_Data.File_Names (Unit_Kind).Name);\n-                     end if;\n+      Exception_Id : Ada_Naming_Exception_Id;\n+      Unit_Name    : Name_Id;\n+      Unit_Kind    : Spec_Or_Body;\n+      Unit_Ind     : Int := 0;\n+      Info         : Unit_Info;\n+      Name_Index   : Name_And_Index;\n+      Except_Name  : Name_And_Index := No_Name_And_Index;\n+      Needs_Pragma : Boolean;\n \n-                     --  Record the file name in the hash table Files_Htable\n-\n-                     Unit_Prj := (Unit => The_Unit, Project => Project);\n-                     Files_Htable.Set\n-                       (In_Tree.Files_HT,\n-                        Canonical_File_Name,\n-                        Unit_Prj);\n-\n-                     The_Unit_Data.File_Names (Unit_Kind) :=\n-                       (Name         => Canonical_File_Name,\n-                        Index        => Unit_Ind,\n-                        Display_Name => File_Name,\n-                        Path         => (Canonical_Path_Name, Path_Name),\n-                        Project      => Project,\n-                        Needs_Pragma => Needs_Pragma);\n-                     In_Tree.Units.Table (The_Unit) := The_Unit_Data;\n-                     Source_Recorded := True;\n-\n-                  elsif The_Unit_Data.File_Names (Unit_Kind).Project = Project\n-                    and then (Data.Known_Order_Of_Source_Dirs\n-                                or else\n-                                The_Unit_Data.File_Names\n-                                  (Unit_Kind).Path.Name = Canonical_Path_Name)\n-                  then\n-                     if Previous_Source = Nil_String then\n-                        Data.Ada_Sources := Nil_String;\n-                     else\n-                        In_Tree.String_Elements.Table (Previous_Source).Next :=\n-                          Nil_String;\n-                        String_Element_Table.Decrement_Last\n-                          (In_Tree.String_Elements);\n-                     end if;\n+   begin\n+      Canonical_File := Canonical_Case_File_Name (Name_Id (File_Name));\n+      Canonical_Path :=\n+        Path_Name_Type (Canonical_Case_File_Name (Name_Id (Path_Name)));\n \n-                     Current_Source := Previous_Source;\n+      --  Check the naming scheme to get extra file properties\n \n-                  else\n-                     --  It is an error to have two units with the same name\n-                     --  and the same kind (spec or body).\n+      Get_Unit\n+        (In_Tree             => In_Tree,\n+         Canonical_File_Name => Canonical_File,\n+         Naming              => Data.Naming,\n+         Exception_Id        => Exception_Id,\n+         Unit_Name           => Unit_Name,\n+         Unit_Kind           => Unit_Kind,\n+         Needs_Pragma        => Needs_Pragma);\n \n-                     if The_Location = No_Location then\n-                        The_Location :=\n-                          In_Tree.Projects.Table (Project).Location;\n-                     end if;\n+      if Exception_Id = No_Ada_Naming_Exception\n+        and then Unit_Name = No_Name\n+      then\n+         if Current_Verbosity = High then\n+            Write_Str  (\"   \"\"\");\n+            Write_Str  (Get_Name_String (Canonical_File));\n+            Write_Line (\"\"\" is not a valid source file name (ignored).\");\n+         end if;\n+         return;\n+      end if;\n \n-                     Err_Vars.Error_Msg_Name_1 := Unit_Name;\n-                     Error_Msg\n-                       (Project, In_Tree, \"duplicate unit %%\", The_Location);\n+      --  Check to see if the source has been hidden by an exception,\n+      --  but only if it is not an exception.\n \n-                     Err_Vars.Error_Msg_Name_1 :=\n-                       In_Tree.Projects.Table\n-                         (The_Unit_Data.File_Names (Unit_Kind).Project).Name;\n-                     Err_Vars.Error_Msg_File_1 :=\n-                       File_Name_Type\n-                         (The_Unit_Data.File_Names (Unit_Kind).Path.Name);\n-                     Error_Msg\n-                       (Project, In_Tree,\n-                        \"\\   project file %%, {\", The_Location);\n+      if not Needs_Pragma then\n+         Except_Name :=\n+           Reverse_Ada_Naming_Exceptions.Get\n+             ((Unit_Kind, Unit_Name, No_Ada_Naming_Exception));\n \n-                     Err_Vars.Error_Msg_Name_1 :=\n-                       In_Tree.Projects.Table (Project).Name;\n-                     Err_Vars.Error_Msg_File_1 :=\n-                       File_Name_Type (Canonical_Path_Name);\n-                     Error_Msg\n-                       (Project, In_Tree,\n-                        \"\\   project file %%, {\", The_Location);\n-                  end if;\n+         if Except_Name /= No_Name_And_Index then\n+            if Current_Verbosity = High then\n+               Write_Str  (\"   \"\"\");\n+               Write_Str  (Get_Name_String (Canonical_File));\n+               Write_Str  (\"\"\" contains a unit that is found in \"\"\");\n+               Write_Str  (Get_Name_String (Except_Name.Name));\n+               Write_Line (\"\"\" (ignored).\");\n+            end if;\n \n-               --  It is a new unit, create a new record\n+            --  The file is not included in the source of the project since\n+            --  it is hidden by the exception. So, nothing else to do.\n \n-               else\n-                  --  First, check if there is no other unit with this file\n-                  --  name in another project. If it is, report error but note\n-                  --  we do that only for the first unit in the source file.\n+            return;\n+         end if;\n+      end if;\n \n-                  Unit_Prj :=\n-                    Files_Htable.Get (In_Tree.Files_HT, Canonical_File_Name);\n+      --  The following loop registers the unit in the appropriate table. It\n+      --  will be executed multiple times when the file is a multi-unit file,\n+      --  in which case Exception_Id initially points to the first file and\n+      --  then to each other unit in the file.\n \n-                  if not File_Name_Recorded and then\n-                    Unit_Prj /= No_Unit_Project\n-                  then\n-                     Error_Msg_File_1 := File_Name;\n-                     Error_Msg_Name_1 :=\n-                       In_Tree.Projects.Table (Unit_Prj.Project).Name;\n-                     Error_Msg\n-                       (Project, In_Tree,\n-                        \"{ is already a source of project %%\",\n-                        Location);\n+      loop\n+         if Exception_Id /= No_Ada_Naming_Exception then\n+            Info := Ada_Naming_Exception_Table.Table (Exception_Id);\n+            Exception_Id := Info.Next;\n+            Info.Next := No_Ada_Naming_Exception;\n+            Name_Index := Reverse_Ada_Naming_Exceptions.Get (Info);\n+\n+            Unit_Name := Info.Unit;\n+            Unit_Ind  := Name_Index.Index;\n+            Unit_Kind := Info.Kind;\n+         end if;\n \n-                  else\n-                     Unit_Table.Increment_Last (In_Tree.Units);\n-                     The_Unit := Unit_Table.Last (In_Tree.Units);\n-                     Units_Htable.Set\n-                       (In_Tree.Units_HT, Unit_Name, The_Unit);\n-                     Unit_Prj := (Unit => The_Unit, Project => Project);\n-                     Files_Htable.Set\n-                       (In_Tree.Files_HT,\n-                        Canonical_File_Name,\n-                        Unit_Prj);\n-                     The_Unit_Data.Name := Unit_Name;\n-                     The_Unit_Data.File_Names (Unit_Kind) :=\n-                       (Name         => Canonical_File_Name,\n-                        Index        => Unit_Ind,\n-                        Display_Name => File_Name,\n-                        Path         => (Canonical_Path_Name, Path_Name),\n-                        Project      => Project,\n-                        Needs_Pragma => Needs_Pragma);\n-                     In_Tree.Units.Table (The_Unit) := The_Unit_Data;\n-                     Source_Recorded := True;\n-                  end if;\n-               end if;\n-            end;\n+         Record_Unit (Unit_Name, Unit_Ind, Unit_Kind, Needs_Pragma);\n+         File_Recorded := True;\n \n-            exit when Exception_Id = No_Ada_Naming_Exception;\n-            File_Name_Recorded := True;\n-         end loop;\n-      end if;\n+         exit when Exception_Id = No_Ada_Naming_Exception;\n+      end loop;\n    end Record_Ada_Source;\n \n    -------------------"}, {"sha": "2cebd1aa8ffce3cf83af55e188c221f1868ba18d", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca532984541ebca71db7cff750d36f9e25465b9/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca532984541ebca71db7cff750d36f9e25465b9/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=aca532984541ebca71db7cff750d36f9e25465b9", "patch": "@@ -105,7 +105,6 @@ package body Prj is\n                       Lib_Auto_Init                  => False,\n                       Libgnarl_Needed                => Unknown,\n                       Symbol_Data                    => No_Symbols,\n-                      Ada_Sources                    => Nil_String,\n                       Interfaces_Defined             => False,\n                       Include_Path                   => null,\n                       Include_Data_Set               => False,\n@@ -1205,10 +1204,6 @@ package body Prj is\n       Lang : Language_Ptr;\n \n    begin\n-      if Data.Ada_Sources /= Nil_String then\n-         return True;\n-      end if;\n-\n       Lang := Data.Languages;\n       while Lang /= No_Language_Index loop\n          if Lang.Name = Name_Ada then"}, {"sha": "35c964546f11fadaa1460e51eeca6fa789bec141", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca532984541ebca71db7cff750d36f9e25465b9/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca532984541ebca71db7cff750d36f9e25465b9/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=aca532984541ebca71db7cff750d36f9e25465b9", "patch": "@@ -1256,11 +1256,8 @@ package Prj is\n       -------------\n       -- Sources --\n       -------------\n-      --  In multi-language mode, the sources for all languages including Ada\n-      --  are accessible through the Source_Iterator type\n-\n-      Ada_Sources : String_List_Id := Nil_String;\n-      --  The list of all the Ada source file names (gnatmake only).\n+      --  The sources for all languages including Ada are accessible through\n+      --  the Source_Iterator type\n \n       Interfaces_Defined      : Boolean := False;\n       --  True if attribute Interfaces is declared for the project or any"}, {"sha": "986ca3a7e9b4acc1a6a8e9e5a18691f1123a275e", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 53, "deletions": 39, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca532984541ebca71db7cff750d36f9e25465b9/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca532984541ebca71db7cff750d36f9e25465b9/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=aca532984541ebca71db7cff750d36f9e25465b9", "patch": "@@ -164,25 +164,26 @@ package body Rtsfind is\n       Id          : RE_Id   := RE_Null;\n       Use_Setting : Boolean := False);\n    --  Load the unit whose Id is given if not already loaded. The unit is\n-   --  loaded, analyzed, and added to the WITH list, and the entry in\n-   --  RT_Unit_Table is updated to reflect the load. Use_Setting is used to\n-   --  indicate the initial setting for the Is_Potentially_Use_Visible flag of\n-   --  the entity for the loaded unit (if it is indeed loaded). A value of\n-   --  False means nothing special need be done. A value of True indicates that\n-   --  this flag must be set to True. It is needed only in the Text_IO_Kludge\n-   --  procedure, which may materialize an entity of Text_IO (or\n-   --  [Wide_]Wide_Text_IO) that was previously unknown. Id is the RE_Id value\n-   --  of the entity which was originally requested. Id is used only for error\n-   --  message detail, and if it is RE_Null, then the attempt to output the\n-   --  entity name is ignored.\n-\n-   function Make_Unit_Name (E : RE_Id; N : Node_Id) return Node_Id;\n+   --  loaded and analyzed, and the entry in RT_Unit_Table is updated to\n+   --  reflect the load. Use_Setting is used to indicate the initial setting\n+   --  for the Is_Potentially_Use_Visible flag of the entity for the loaded\n+   --  unit (if it is indeed loaded). A value of False means nothing special\n+   --  need be done. A value of True indicates that this flag must be set to\n+   --  True. It is needed only in the Text_IO_Kludge procedure, which may\n+   --  materialize an entity of Text_IO (or [Wide_]Wide_Text_IO) that was\n+   --  previously unknown. Id is the RE_Id value of the entity which was\n+   --  originally requested. Id is used only for error message detail, and if\n+   --  it is RE_Null, then the attempt to output the entity name is ignored.\n+\n+   function Make_Unit_Name\n+     (U : RT_Unit_Table_Record;\n+      N : Node_Id) return Node_Id;\n    --  If the unit is a child unit, build fully qualified name for use in\n    --  With_Clause.\n \n-   procedure Maybe_Add_With (E : RE_Id; U : in out RT_Unit_Table_Record);\n+   procedure Maybe_Add_With (U : in out RT_Unit_Table_Record);\n    --  If necessary, add an implicit with_clause from the current unit to the\n-   --  one represented by E and U.\n+   --  one represented by U.\n \n    procedure Output_Entity_Name (Id : RE_Id; Msg : String);\n    --  Output continuation error message giving qualified name of entity\n@@ -765,9 +766,10 @@ package body Rtsfind is\n    -- Make_Unit_Name --\n    --------------------\n \n-   function Make_Unit_Name (E : RE_Id; N : Node_Id) return Node_Id is\n-      U_Id : constant RTU_Id := RE_Unit_Table (E);\n-      U    : RT_Unit_Table_Record renames RT_Unit_Table (U_Id);\n+   function Make_Unit_Name\n+     (U : RT_Unit_Table_Record;\n+      N : Node_Id) return Node_Id is\n+\n       Nam  : Node_Id;\n       Scop : Entity_Id;\n \n@@ -795,15 +797,24 @@ package body Rtsfind is\n    -- Maybe_Add_With --\n    --------------------\n \n-   procedure Maybe_Add_With (E : RE_Id; U : in out RT_Unit_Table_Record) is\n+   procedure Maybe_Add_With (U : in out RT_Unit_Table_Record) is\n       Is_Main : constant Boolean :=\n                   In_Extended_Main_Code_Unit (Cunit_Entity (Current_Sem_Unit));\n \n    begin\n       --  We do not need to generate a with_clause for a call issued from\n-      --  RTE_Component_Available.\n+      --  RTE_Component_Available. However, for Inspector, we need these\n+      --  additional with's, because for a sequence like \"if RTE_Available (X)\n+      --  then ... RTE (X)\" the RTE call fails to create some necessary\n+      --  with's.\n \n-      if RTE_Available_Call then\n+      if RTE_Available_Call and then not Inspector_Mode then\n+         return;\n+      end if;\n+\n+      --  Avoid creating directly self-referential with clauses\n+\n+      if Current_Sem_Unit = U.Unum then\n          return;\n       end if;\n \n@@ -836,7 +847,7 @@ package body Rtsfind is\n                      Make_With_Clause (Standard_Location,\n                        Name =>\n                          Make_Unit_Name\n-                           (E, Defining_Unit_Name (Specification (LibUnit))));\n+                           (U, Defining_Unit_Name (Specification (LibUnit))));\n \n       begin\n          Set_Library_Unit       (Withn, Cunit (U.Unum));\n@@ -1127,7 +1138,7 @@ package body Rtsfind is\n       end if;\n \n    <<Found>>\n-      Maybe_Add_With (E, U);\n+      Maybe_Add_With (U);\n \n       Front_End_Inlining := Save_Front_End_Inlining;\n       return Check_CRT (E, RE_Table (E));\n@@ -1229,7 +1240,7 @@ package body Rtsfind is\n       --  If we didn't find the entity we want, something is wrong. The\n       --  appropriate action will be taken by Check_CRT when we exit.\n \n-      Maybe_Add_With (E, U);\n+      Maybe_Add_With (U);\n \n       Front_End_Inlining := Save_Front_End_Inlining;\n       return Check_CRT (E, Found_E);\n@@ -1380,6 +1391,9 @@ package body Rtsfind is\n         Name_Integer_IO     => Ada_Wide_Wide_Text_IO_Integer_IO,\n         Name_Modular_IO     => Ada_Wide_Wide_Text_IO_Modular_IO);\n \n+      To_Load : RTU_Id;\n+      --  Unit to be loaded, from one of the above maps\n+\n    begin\n       --  Nothing to do if name is not an identifier or a selected component\n       --  whose selector_name is not an identifier.\n@@ -1419,27 +1433,27 @@ package body Rtsfind is\n                --  they are visible.\n \n                if Name_Buffer (1 .. 12) = \"a-textio.ads\" then\n-                  Load_RTU\n-                    (Name_Map (Chrs),\n-                     Use_Setting => In_Use (Cunit_Entity (U)));\n-                  Set_Is_Visible_Child_Unit\n-                    (RT_Unit_Table (Name_Map (Chrs)).Entity);\n+                  To_Load := Name_Map (Chrs);\n \n                elsif Name_Buffer (1 .. 12) = \"a-witeio.ads\" then\n-                  Load_RTU\n-                    (Wide_Name_Map (Chrs),\n-                     Use_Setting => In_Use (Cunit_Entity (U)));\n-                  Set_Is_Visible_Child_Unit\n-                    (RT_Unit_Table (Wide_Name_Map (Chrs)).Entity);\n+                  To_Load := Wide_Name_Map (Chrs);\n \n                elsif Name_Buffer (1 .. 12) = \"a-ztexio.ads\" then\n-                  Load_RTU\n-                    (Wide_Wide_Name_Map (Chrs),\n-                     Use_Setting => In_Use (Cunit_Entity (U)));\n-                  Set_Is_Visible_Child_Unit\n-                    (RT_Unit_Table (Wide_Wide_Name_Map (Chrs)).Entity);\n+                  To_Load := Wide_Wide_Name_Map (Chrs);\n+\n+               else\n+                  goto Continue;\n                end if;\n+\n+               Load_RTU\n+                 (To_Load,\n+                  Use_Setting => In_Use (Cunit_Entity (U)));\n+               Set_Is_Visible_Child_Unit\n+                 (RT_Unit_Table (To_Load).Entity);\n+               Maybe_Add_With (RT_Unit_Table (To_Load));\n             end if;\n+\n+            <<Continue>> null;\n          end loop;\n       end if;\n "}, {"sha": "d3a7c35a23dc42617f9b265ed557a4a1c91c62cc", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca532984541ebca71db7cff750d36f9e25465b9/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca532984541ebca71db7cff750d36f9e25465b9/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=aca532984541ebca71db7cff750d36f9e25465b9", "patch": "@@ -1544,7 +1544,8 @@ package body Sem is\n             when N_Package_Body | N_Subprogram_Body =>\n                --  A body must be the main unit\n \n-               pragma Assert (CU = Cunit (Main_Unit));\n+               pragma Assert (Acts_As_Spec (CU)\n+                              or else CU = Cunit (Main_Unit));\n                null;\n \n             --  All other cases cannot happen\n@@ -1573,29 +1574,32 @@ package body Sem is\n                                 Get_Cunit_Unit_Number (CU);\n \n                procedure Assert_Done (Withed_Unit : Node_Id);\n-               --  Assert Withed_Unit is already Done\n+               --  Assert Withed_Unit is already Done, unless it's a body. It\n+               --  might seem strange for a with_clause to refer to a body, but\n+               --  this happens in the case of a generic instantiation, which\n+               --  gets transformed into the instance body (and the instance\n+               --  spec is also created). With clauses pointing to the\n+               --  instantiation end up pointing to the instance body.\n \n                procedure Assert_Done (Withed_Unit : Node_Id) is\n                begin\n-                  if not Done\n-                       (Get_Cunit_Unit_Number\n-                        (Withed_Unit))\n-                  then\n-                     Write_Unit_Name\n-                       (Unit_Name\n-                        (Get_Cunit_Unit_Number\n-                         (Withed_Unit)));\n-                     Write_Str (\" not yet walked!\");\n-                     Write_Eol;\n-                  end if;\n-\n-                  if False then\n-                     --  This assertion is disabled because it fails in the\n-                     --  presence of subunits.\n-                     pragma Assert  --  ???\n-                       (Done\n-                          (Get_Cunit_Unit_Number (Withed_Unit)));\n-                     null;\n+                  if not Done (Get_Cunit_Unit_Number (Withed_Unit)) then\n+                     if not Nkind_In\n+                       (Unit (Withed_Unit), N_Package_Body, N_Subprogram_Body)\n+                     then\n+\n+                        Write_Unit_Name\n+                          (Unit_Name\n+                           (Get_Cunit_Unit_Number\n+                            (Withed_Unit)));\n+                        Write_Str (\" not yet walked!\");\n+                        if Get_Cunit_Unit_Number (Withed_Unit) = Unit_Num then\n+                           Write_Str (\" (self-ref)\");\n+                        end if;\n+                        Write_Eol;\n+\n+                        pragma Assert (False);\n+                     end if;\n                   end if;\n                end Assert_Done;\n \n@@ -1608,23 +1612,16 @@ package body Sem is\n \n                --  Main unit should come last\n \n-               if Done (Main_Unit) then\n-                  Write_Line (\"Main unit is done!\");\n-               end if;\n-               if False then  --  ???\n-                  --  This assertion is disabled because it fails in the\n-                  --  presence of subunits.\n-                  pragma Assert (not Done (Main_Unit));\n-                  null;\n-               end if;\n+               pragma Assert (not Done (Main_Unit));\n \n                --  We shouldn't do the same thing twice\n \n                pragma Assert (not Done (Unit_Num));\n \n                --  Everything we depend upon should already be done\n \n-               Assert_Withed_Units_Done (CU, Include_Limited => False);\n+               pragma Debug\n+                 (Assert_Withed_Units_Done (CU, Include_Limited => False));\n             end;\n \n          else\n@@ -1645,8 +1642,8 @@ package body Sem is\n       ----------------------------\n \n       procedure Do_Unit_And_Dependents (CU : Node_Id; Item : Node_Id) is\n-         Unit_Num     : constant Unit_Number_Type :=\n-                          Get_Cunit_Unit_Number (CU);\n+         Unit_Num : constant Unit_Number_Type :=\n+                      Get_Cunit_Unit_Number (CU);\n \n          procedure Do_Withed_Unit (Withed_Unit : Node_Id);\n          --  Pass the buck to Do_Unit_And_Dependents\n@@ -1670,7 +1667,13 @@ package body Sem is\n             declare\n                Spec_Unit : constant Node_Id := Library_Unit (CU);\n             begin\n-               Do_Unit_And_Dependents (Spec_Unit, Unit (Spec_Unit));\n+               if Spec_Unit = CU then  --  ???Why needed?\n+                  pragma Assert (Acts_As_Spec (CU));\n+                  null;\n+\n+               else\n+                  Do_Unit_And_Dependents (Spec_Unit, Unit (Spec_Unit));\n+               end if;\n             end;\n          end if;\n \n@@ -1681,6 +1684,7 @@ package body Sem is\n          --  Process the unit itself\n \n          if not Nkind_In (Item, N_Package_Body, N_Subprogram_Body)\n+           or else Acts_As_Spec (CU)\n            or else CU = Cunit (Main_Unit)\n          then\n \n@@ -1689,13 +1693,20 @@ package body Sem is\n             Done (Unit_Num) := True;\n          end if;\n \n-         --  Process the corresponding body last\n+         --  Process corresponding body of spec last. However, if this body is\n+         --  the main unit (because some dependent of the main unit depends on\n+         --  the main unit's spec), we don't process it now. We also skip\n+         --  processing of the body of a unit named by pragma Extend_System,\n+         --  because it has cyclic dependences in some cases.\n \n          if not Nkind_In (Item, N_Package_Body, N_Subprogram_Body) then\n             declare\n                Body_Unit : constant Node_Id := Library_Unit (CU);\n             begin\n-               if Present (Body_Unit) then\n+               if Present (Body_Unit)\n+                 and then Body_Unit /= Cunit (Main_Unit)\n+                 and then Unit_Num /= Get_Source_Unit (System_Aux_Id)\n+               then\n                   Do_Unit_And_Dependents (Body_Unit, Unit (Body_Unit));\n                end if;\n             end;\n@@ -1738,7 +1749,7 @@ package body Sem is\n                      Entity : Node_Id := N;\n \n                   begin\n-                     if Nkind (N) = N_Subprogram_Body then\n+                     if Nkind (Entity) = N_Subprogram_Body then\n                         Entity := Specification (Entity);\n                      end if;\n \n@@ -1910,7 +1921,7 @@ package body Sem is\n \n       --  Skip the rest if we're not supposed to print the withs\n \n-      if False and then not Withs then -- ???\n+      if not Withs then\n          return;\n       end if;\n "}, {"sha": "6045918217e4d61a97187f761a1f9337ce027b71", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca532984541ebca71db7cff750d36f9e25465b9/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca532984541ebca71db7cff750d36f9e25465b9/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=aca532984541ebca71db7cff750d36f9e25465b9", "patch": "@@ -4392,7 +4392,7 @@ package body Sem_Ch12 is\n       --  If the instance is not the main unit, its context, categorization,\n       --  and elaboration entity are not relevant to the compilation.\n \n-      if Parent (N) /= Cunit (Main_Unit) then\n+      if Body_Cunit /= Cunit (Main_Unit) then\n          Make_Instance_Unit (Body_Cunit, In_Main => False);\n          return;\n       end if;"}]}