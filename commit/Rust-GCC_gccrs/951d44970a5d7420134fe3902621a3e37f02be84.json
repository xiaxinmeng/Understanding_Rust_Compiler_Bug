{"sha": "951d44970a5d7420134fe3902621a3e37f02be84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTUxZDQ0OTcwYTVkNzQyMDEzNGZlMzkwMjYyMWEzZTM3ZjAyYmU4NA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2009-12-17T19:31:52Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-12-17T19:31:52Z"}, "message": "re PR debug/41679 (internal compiler error: in loc_cmp, at var-tracking.c:2433)\n\n\tPR debug/41679\n\t* var-tracking.c (use_type): Remove indirection from loc.\n\t(count_uses): Dereference incoming loc early.\n\t(add_uses): Dereference incoming loc early.\n\nFrom-SVN: r155323", "tree": {"sha": "b42c17c401d7d1a333ff03e1c8b93a1f83506f50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b42c17c401d7d1a333ff03e1c8b93a1f83506f50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/951d44970a5d7420134fe3902621a3e37f02be84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/951d44970a5d7420134fe3902621a3e37f02be84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/951d44970a5d7420134fe3902621a3e37f02be84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/951d44970a5d7420134fe3902621a3e37f02be84/comments", "author": null, "committer": null, "parents": [{"sha": "00ee9f445b842dfc09b8120e7d45235cd818412e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00ee9f445b842dfc09b8120e7d45235cd818412e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00ee9f445b842dfc09b8120e7d45235cd818412e"}], "stats": {"total": 83, "additions": 45, "deletions": 38}, "files": [{"sha": "a7760c469711c76d278e2720bf1a17d29a23c224", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/951d44970a5d7420134fe3902621a3e37f02be84/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/951d44970a5d7420134fe3902621a3e37f02be84/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=951d44970a5d7420134fe3902621a3e37f02be84", "patch": "@@ -1,5 +1,10 @@\n 2009-12-17  Alexandre Oliva  <aoliva@redhat.com>\n \n+\tPR debug/41679\n+\t* var-tracking.c (use_type): Remove indirection from loc.\n+\t(count_uses): Dereference incoming loc early.\n+\t(add_uses): Dereference incoming loc early.\n+\n \tPR debug/41679\n \t* var-tracking.c (add_stores): Avoid value mode mismatch for\n \tpromoted declarations."}, {"sha": "988e348a3ae3395129937c142a45c41c4d4bf1ed", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/951d44970a5d7420134fe3902621a3e37f02be84/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/951d44970a5d7420134fe3902621a3e37f02be84/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=951d44970a5d7420134fe3902621a3e37f02be84", "patch": "@@ -4375,19 +4375,19 @@ replace_expr_with_values (rtx loc)\n    MO_CLOBBER if no micro operation is to be generated.  */\n \n static enum micro_operation_type\n-use_type (rtx *loc, struct count_use_info *cui, enum machine_mode *modep)\n+use_type (rtx loc, struct count_use_info *cui, enum machine_mode *modep)\n {\n   tree expr;\n   cselib_val *val;\n \n   if (cui && cui->sets)\n     {\n-      if (GET_CODE (*loc) == VAR_LOCATION)\n+      if (GET_CODE (loc) == VAR_LOCATION)\n \t{\n-\t  if (track_expr_p (PAT_VAR_LOCATION_DECL (*loc), false))\n+\t  if (track_expr_p (PAT_VAR_LOCATION_DECL (loc), false))\n \t    {\n-\t      rtx ploc = PAT_VAR_LOCATION_LOC (*loc);\n-\t      cselib_val *val = cselib_lookup (ploc, GET_MODE (*loc), 1);\n+\t      rtx ploc = PAT_VAR_LOCATION_LOC (loc);\n+\t      cselib_val *val = cselib_lookup (ploc, GET_MODE (loc), 1);\n \n \t      /* ??? flag_float_store and volatile mems are never\n \t\t given values, but we could in theory use them for\n@@ -4399,47 +4399,47 @@ use_type (rtx *loc, struct count_use_info *cui, enum machine_mode *modep)\n \t    return MO_CLOBBER;\n \t}\n \n-      if ((REG_P (*loc) || MEM_P (*loc))\n-\t  && (val = find_use_val (*loc, GET_MODE (*loc), cui)))\n+      if ((REG_P (loc) || MEM_P (loc))\n+\t  && (val = find_use_val (loc, GET_MODE (loc), cui)))\n \t{\n \t  if (modep)\n-\t    *modep = GET_MODE (*loc);\n+\t    *modep = GET_MODE (loc);\n \t  if (cui->store_p)\n \t    {\n-\t      if (REG_P (*loc)\n-\t\t  || cselib_lookup (XEXP (*loc, 0), GET_MODE (*loc), 0))\n+\t      if (REG_P (loc)\n+\t\t  || cselib_lookup (XEXP (loc, 0), GET_MODE (loc), 0))\n \t\treturn MO_VAL_SET;\n \t    }\n \t  else if (!cselib_preserved_value_p (val))\n \t    return MO_VAL_USE;\n \t}\n     }\n \n-  if (REG_P (*loc))\n+  if (REG_P (loc))\n     {\n-      gcc_assert (REGNO (*loc) < FIRST_PSEUDO_REGISTER);\n+      gcc_assert (REGNO (loc) < FIRST_PSEUDO_REGISTER);\n \n-      expr = REG_EXPR (*loc);\n+      expr = REG_EXPR (loc);\n \n       if (!expr)\n \treturn MO_USE_NO_VAR;\n       else if (target_for_debug_bind (var_debug_decl (expr)))\n \treturn MO_CLOBBER;\n-      else if (track_loc_p (*loc, expr, REG_OFFSET (*loc),\n+      else if (track_loc_p (loc, expr, REG_OFFSET (loc),\n \t\t\t    false, modep, NULL))\n \treturn MO_USE;\n       else\n \treturn MO_USE_NO_VAR;\n     }\n-  else if (MEM_P (*loc))\n+  else if (MEM_P (loc))\n     {\n-      expr = MEM_EXPR (*loc);\n+      expr = MEM_EXPR (loc);\n \n       if (!expr)\n \treturn MO_CLOBBER;\n       else if (target_for_debug_bind (var_debug_decl (expr)))\n \treturn MO_CLOBBER;\n-      else if (track_loc_p (*loc, expr, INT_MEM_OFFSET (*loc),\n+      else if (track_loc_p (loc, expr, INT_MEM_OFFSET (loc),\n \t\t\t    false, modep, NULL))\n \treturn MO_USE;\n       else\n@@ -4467,37 +4467,38 @@ log_op_type (rtx x, basic_block bb, rtx insn,\n    INSN is instruction which the LOC is part of.  */\n \n static int\n-count_uses (rtx *loc, void *cuip)\n+count_uses (rtx *ploc, void *cuip)\n {\n+  rtx loc = *ploc;\n   struct count_use_info *cui = (struct count_use_info *) cuip;\n   enum micro_operation_type mopt = use_type (loc, cui, NULL);\n \n   if (mopt != MO_CLOBBER)\n     {\n       cselib_val *val;\n-      enum machine_mode mode = GET_MODE (*loc);\n+      enum machine_mode mode = GET_MODE (loc);\n \n       VTI (cui->bb)->n_mos++;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tlog_op_type (*loc, cui->bb, cui->insn, mopt, dump_file);\n+\tlog_op_type (loc, cui->bb, cui->insn, mopt, dump_file);\n \n       switch (mopt)\n \t{\n \tcase MO_VAL_LOC:\n-\t  loc = &PAT_VAR_LOCATION_LOC (*loc);\n-\t  if (VAR_LOC_UNKNOWN_P (*loc))\n+\t  loc = PAT_VAR_LOCATION_LOC (loc);\n+\t  if (VAR_LOC_UNKNOWN_P (loc))\n \t    break;\n \t  /* Fall through.  */\n \n \tcase MO_VAL_USE:\n \tcase MO_VAL_SET:\n-\t  if (MEM_P (*loc)\n-\t      && !REG_P (XEXP (*loc, 0)) && !MEM_P (XEXP (*loc, 0)))\n+\t  if (MEM_P (loc)\n+\t      && !REG_P (XEXP (loc, 0)) && !MEM_P (XEXP (loc, 0)))\n \t    {\n \t      enum machine_mode address_mode\n-\t\t= targetm.addr_space.address_mode (MEM_ADDR_SPACE (*loc));\n-\t      val = cselib_lookup (XEXP (*loc, 0), address_mode, false);\n+\t\t= targetm.addr_space.address_mode (MEM_ADDR_SPACE (loc));\n+\t      val = cselib_lookup (XEXP (loc, 0), address_mode, false);\n \n \t      if (val && !cselib_preserved_value_p (val))\n \t\t{\n@@ -4506,7 +4507,7 @@ count_uses (rtx *loc, void *cuip)\n \t\t}\n \t    }\n \n-\t  val = find_use_val (*loc, mode, cui);\n+\t  val = find_use_val (loc, mode, cui);\n \t  if (val)\n \t    cselib_preserve_value (val);\n \t  else\n@@ -4590,8 +4591,9 @@ count_with_sets (rtx insn, struct cselib_set *sets, int n_sets)\n    to VTI (bb)->mos.  INSN is instruction which the LOC is part of.  */\n \n static int\n-add_uses (rtx *loc, void *data)\n+add_uses (rtx *ploc, void *data)\n {\n+  rtx loc = *ploc;\n   enum machine_mode mode = VOIDmode;\n   struct count_use_info *cui = (struct count_use_info *)data;\n   enum micro_operation_type type = use_type (loc, cui, &mode);\n@@ -4602,12 +4604,12 @@ add_uses (rtx *loc, void *data)\n       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n \n       mo->type = type;\n-      mo->u.loc = type == MO_USE ? var_lowpart (mode, *loc) : *loc;\n+      mo->u.loc = type == MO_USE ? var_lowpart (mode, loc) : loc;\n       mo->insn = cui->insn;\n \n       if (type == MO_VAL_LOC)\n \t{\n-\t  rtx oloc = *loc;\n+\t  rtx oloc = loc;\n \t  rtx vloc = PAT_VAR_LOCATION_LOC (oloc);\n \t  cselib_val *val;\n \n@@ -4655,7 +4657,7 @@ add_uses (rtx *loc, void *data)\n \n \t      oloc = gen_rtx_CONCAT (mode, val->val_rtx, oloc);\n \n-\t      type2 = use_type (&vloc, 0, &mode2);\n+\t      type2 = use_type (vloc, 0, &mode2);\n \n \t      gcc_assert (type2 == MO_USE || type2 == MO_USE_NO_VAR\n \t\t\t  || type2 == MO_CLOBBER);\n@@ -4679,8 +4681,8 @@ add_uses (rtx *loc, void *data)\n \t{\n \t  enum machine_mode mode2 = VOIDmode;\n \t  enum micro_operation_type type2;\n-\t  cselib_val *val = find_use_val (*loc, GET_MODE (*loc), cui);\n-\t  rtx vloc, oloc = *loc, nloc;\n+\t  cselib_val *val = find_use_val (loc, GET_MODE (loc), cui);\n+\t  rtx vloc, oloc = loc, nloc;\n \n \t  gcc_assert (cui->sets);\n \n@@ -4718,7 +4720,7 @@ add_uses (rtx *loc, void *data)\n \t\t      || type2 == MO_CLOBBER);\n \n \t  if (type2 == MO_USE)\n-\t    vloc = var_lowpart (mode2, *loc);\n+\t    vloc = var_lowpart (mode2, loc);\n \t  else\n \t    vloc = oloc;\n \n@@ -4732,7 +4734,7 @@ add_uses (rtx *loc, void *data)\n \n \t  */\n \n-\t  nloc = replace_expr_with_values (*loc);\n+\t  nloc = replace_expr_with_values (loc);\n \t  if (!nloc)\n \t    nloc = oloc;\n \n@@ -4781,7 +4783,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n   basic_block bb = cui->bb;\n   micro_operation *mo;\n   rtx oloc = loc, nloc, src = NULL;\n-  enum micro_operation_type type = use_type (&loc, cui, &mode);\n+  enum micro_operation_type type = use_type (loc, cui, &mode);\n   bool track_p = false;\n   cselib_val *v;\n   bool resolve, preserve;\n@@ -4796,7 +4798,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n       mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n \n       if ((GET_CODE (expr) == CLOBBER && type != MO_VAL_SET)\n-\t  || !(track_p = use_type (&loc, NULL, &mode2) == MO_USE)\n+\t  || !(track_p = use_type (loc, NULL, &mode2) == MO_USE)\n \t  || GET_CODE (expr) == CLOBBER)\n \t{\n \t  mo->type = MO_CLOBBER;\n@@ -4829,7 +4831,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n       mo->insn = cui->insn;\n     }\n   else if (MEM_P (loc)\n-\t   && ((track_p = use_type (&loc, NULL, &mode2) == MO_USE)\n+\t   && ((track_p = use_type (loc, NULL, &mode2) == MO_USE)\n \t       || cui->sets))\n     {\n       mo = VTI (bb)->mos + VTI (bb)->n_mos++;"}]}