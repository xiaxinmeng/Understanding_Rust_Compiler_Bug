{"sha": "e803a64bc8b81e67597cab2553ce2b30b4facd51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgwM2E2NGJjOGI4MWU2NzU5N2NhYjI1NTNjZTJiMzBiNGZhY2Q1MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-01-31T06:21:31Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-01-31T06:21:31Z"}, "message": "rtl.h (NOTE_INSN_LOOP_END_TOP_COND): New.\n\n        * rtl.h (NOTE_INSN_LOOP_END_TOP_COND): New.\n        * rtl.c (note_insn_name): Update.\n        * emit-rtl.c (remove_unnecessary_notes): Kill it.\n        * stmt.c (expand_end_loop): Kill jump opt code.  Use LOOP_END_TOP_COND\n        to perform loop rotation.\n        (expand_exit_loop_top_cond): New.\n        * tree.h (expand_exit_loop_top_cond): Declare it.\n        * c-semantics.c (genrtl_while_stmt): Use it.\n        (genrtl_for_stmt): Likewise.\n\n        * ada/trans.c (tree_transform) [N_Loop_Statement]: Use\n        expand_exit_loop_top_cond.\n\n        * f/ste.c (ffeste_begin_iterdo_): Use expand_exit_loop_top_cond.\n        (ffeste_R819B): Likewise.\n\nFrom-SVN: r49364", "tree": {"sha": "74d7d828de9e380db26da65d9c431dfb739c6948", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74d7d828de9e380db26da65d9c431dfb739c6948"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e803a64bc8b81e67597cab2553ce2b30b4facd51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e803a64bc8b81e67597cab2553ce2b30b4facd51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e803a64bc8b81e67597cab2553ce2b30b4facd51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e803a64bc8b81e67597cab2553ce2b30b4facd51/comments", "author": null, "committer": null, "parents": [{"sha": "5867245e314ba5fc3af34d6c158acdfe62817a06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5867245e314ba5fc3af34d6c158acdfe62817a06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5867245e314ba5fc3af34d6c158acdfe62817a06"}], "stats": {"total": 431, "additions": 158, "deletions": 273}, "files": [{"sha": "4ab67a059047f0553b744997c91d4fa355565025", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e803a64bc8b81e67597cab2553ce2b30b4facd51", "patch": "@@ -1,3 +1,15 @@\n+2002-01-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* rtl.h (NOTE_INSN_LOOP_END_TOP_COND): New.\n+\t* rtl.c (note_insn_name): Update.\n+\t* emit-rtl.c (remove_unnecessary_notes): Kill it.\n+\t* stmt.c (expand_end_loop): Kill jump opt code.  Use LOOP_END_TOP_COND\n+\tto perform loop rotation.\n+\t(expand_exit_loop_top_cond): New.\n+\t* tree.h (expand_exit_loop_top_cond): Declare it.\n+\t* c-semantics.c (genrtl_while_stmt): Use it.\n+\t(genrtl_for_stmt): Likewise.\n+\n 2002-01-30  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config/mips/mips.h (PARM_BOUNDARY): Guarantee alignment of"}, {"sha": "755f3b268468e82bf0066c9c111efcef14887fe4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e803a64bc8b81e67597cab2553ce2b30b4facd51", "patch": "@@ -1,3 +1,8 @@\n+2001-01-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* trans.c (tree_transform) [N_Loop_Statement]: Use\n+\texpand_exit_loop_top_cond.\n+\n 2001-12-23  Richard Henderson  <rth@redhat.com>\n \n \t* utils.c (end_subprog_body): Push GC context around"}, {"sha": "7c376e5b2d8b9a3a50cd328f22b9da10a1a7855a", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=e803a64bc8b81e67597cab2553ce2b30b4facd51", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *                            $Revision$\n+ *                            $Revision: 1.10 $\n  *                                                                          *\n  *          Copyright (C) 1992-2001, Free Software Foundation, Inc.         *\n  *                                                                          *\n@@ -2350,7 +2350,7 @@ tree_transform (gnat_node)\n \tif (Present (gnat_top_condition))\n \t  gnu_top_condition = gnat_to_gnu (gnat_top_condition);\n \n-\texpand_exit_loop_if_false (0, gnu_top_condition);\n+\texpand_exit_loop_top_cond (0, gnu_top_condition);\n \n         /* Make the loop body into its own block, so any allocated\n            storage will be released every iteration.  This is needed"}, {"sha": "c0bbc515da8faef3ff44f9259f9b61d7869800ab", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=e803a64bc8b81e67597cab2553ce2b30b4facd51", "patch": "@@ -427,7 +427,7 @@ genrtl_while_stmt (t)\n \n   cond = expand_cond (WHILE_COND (t));\n   emit_line_note (input_filename, lineno);\n-  expand_exit_loop_if_false (0, cond);\n+  expand_exit_loop_top_cond (0, cond);\n   genrtl_do_pushlevel ();\n   \n   expand_stmt (WHILE_BODY (t));\n@@ -529,7 +529,7 @@ genrtl_for_stmt (t)\n   /* Expand the condition.  */\n   emit_line_note (input_filename, lineno);\n   if (cond)\n-    expand_exit_loop_if_false (0, cond);\n+    expand_exit_loop_top_cond (0, cond);\n \n   /* Expand the body.  */\n   genrtl_do_pushlevel ();"}, {"sha": "4ea852b60503080aebac3e94a49470479c9947d3", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=e803a64bc8b81e67597cab2553ce2b30b4facd51", "patch": "@@ -3562,6 +3562,7 @@ remove_unnecessary_notes ()\n       switch (NOTE_LINE_NUMBER (insn))\n \t{\n \tcase NOTE_INSN_DELETED:\n+\tcase NOTE_INSN_LOOP_END_TOP_COND:\n \t  remove_insn (insn);\n \t  break;\n "}, {"sha": "ee4afd782bdee74cfae0a8f1054ebe5de99f6670", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=e803a64bc8b81e67597cab2553ce2b30b4facd51", "patch": "@@ -1,3 +1,8 @@\n+2002-01-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* ste.c (ffeste_begin_iterdo_): Use expand_exit_loop_top_cond.\n+\t(ffeste_R819B): Likewise.\n+\n 2002-01-30  Toon Moene  <toon@moene.indiv.nluug.nl>\n \n \t* intrin.c (upcasecmp_): New function."}, {"sha": "8bb9c2d012bddc25cf969dd487170d3b907f0e8f", "filename": "gcc/f/ste.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Ff%2Fste.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Ff%2Fste.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fste.c?ref=e803a64bc8b81e67597cab2553ce2b30b4facd51", "patch": "@@ -706,7 +706,7 @@ ffeste_begin_iterdo_ (ffestw block, tree *xtvar, tree *xtincr,\n \t\t   convert (TREE_TYPE (niters),\n \t\t\t    ffecom_integer_zero_node)));\n \n-      expand_exit_loop_if_false (0, expr);\n+      expand_exit_loop_top_cond (0, expr);\n     }\n \n   if (block)\n@@ -2816,7 +2816,7 @@ ffeste_R819B (ffestw block, ffelab label UNUSED, ffebld expr)\n       ffeste_end_stmt_ ();\n \n       ffestw_set_do_hook (block, loop);\n-      expand_exit_loop_if_false (0, result);\n+      expand_exit_loop_top_cond (0, result);\n     }\n   else\n     ffestw_set_do_hook (block, expand_start_loop (1));"}, {"sha": "7f4a4d5dd7cc0c4848977df1e8b7a8ccdacdce20", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=e803a64bc8b81e67597cab2553ce2b30b4facd51", "patch": "@@ -263,7 +263,7 @@ const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS] =\n   \"NOTE_INSN_BLOCK_BEG\", \"NOTE_INSN_BLOCK_END\",\n   \"NOTE_INSN_LOOP_BEG\", \"NOTE_INSN_LOOP_END\",\n   \"NOTE_INSN_LOOP_CONT\", \"NOTE_INSN_LOOP_VTOP\",\n-  \"NOTE_INSN_FUNCTION_END\",\n+  \"NOTE_INSN_LOOP_END_TOP_COND\", \"NOTE_INSN_FUNCTION_END\",\n   \"NOTE_INSN_PROLOGUE_END\", \"NOTE_INSN_EPILOGUE_BEG\",\n   \"NOTE_INSN_DELETED_LABEL\", \"NOTE_INSN_FUNCTION_BEG\",\n   \"NOTE_INSN_EH_REGION_BEG\", \"NOTE_INSN_EH_REGION_END\","}, {"sha": "ef4c5f8f14609926eadd721f812a8794aed4f142", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e803a64bc8b81e67597cab2553ce2b30b4facd51", "patch": "@@ -682,6 +682,12 @@ enum insn_note\n   /* Generated at the start of a duplicated exit test.  */\n   NOTE_INSN_LOOP_VTOP,\n \n+  /* Generated at the end of a conditional at the top of the loop.\n+     This is used to perform a lame form of loop rotation in lieu\n+     of actually understanding the loop structure.  The note is\n+     discarded after rotation is complete.  */\n+  NOTE_INSN_LOOP_END_TOP_COND,\n+\n   /* This kind of note is generated at the end of the function body,\n      just before the return insn or return label.  In an optimizing\n      compilation it is deleted by the first jump optimization, after"}, {"sha": "5d0e4c44388eeb29450530040d2f47718eab0807", "filename": "gcc/stmt.c", "status": "modified", "additions": 119, "deletions": 265, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=e803a64bc8b81e67597cab2553ce2b30b4facd51", "patch": "@@ -2642,305 +2642,143 @@ void\n expand_end_loop ()\n {\n   rtx start_label = loop_stack->data.loop.start_label;\n-  rtx insn = get_last_insn ();\n-  int needs_end_jump = 1;\n+  rtx etc_note;\n+  int eh_regions, debug_blocks;\n \n   /* Mark the continue-point at the top of the loop if none elsewhere.  */\n   if (start_label == loop_stack->data.loop.continue_label)\n     emit_note_before (NOTE_INSN_LOOP_CONT, start_label);\n \n   do_pending_stack_adjust ();\n \n-  /* If optimizing, perhaps reorder the loop.\n-     First, try to use a condjump near the end.\n-     expand_exit_loop_if_false ends loops with unconditional jumps,\n-     like this:\n-\n-     if (test) goto label;\n-     optional: cleanup\n-     goto loop_stack->data.loop.end_label\n-     barrier\n-     label:\n-\n-     If we find such a pattern, we can end the loop earlier.  */\n-\n-  if (optimize\n-      && GET_CODE (insn) == CODE_LABEL\n-      && LABEL_NAME (insn) == NULL\n-      && GET_CODE (PREV_INSN (insn)) == BARRIER)\n-    {\n-      rtx label = insn;\n-      rtx jump = PREV_INSN (PREV_INSN (label));\n-\n-      if (GET_CODE (jump) == JUMP_INSN\n-\t  && GET_CODE (PATTERN (jump)) == SET\n-\t  && SET_DEST (PATTERN (jump)) == pc_rtx\n-\t  && GET_CODE (SET_SRC (PATTERN (jump))) == LABEL_REF\n-\t  && (XEXP (SET_SRC (PATTERN (jump)), 0)\n-\t      == loop_stack->data.loop.end_label))\n-\t{\n-\t  rtx prev;\n-\n-\t  /* The test might be complex and reference LABEL multiple times,\n-\t     like the loop in loop_iterations to set vtop.  To handle this,\n-\t     we move LABEL.  */\n-\t  insn = PREV_INSN (label);\n-\t  reorder_insns (label, label, start_label);\n-\n-\t  for (prev = PREV_INSN (jump);; prev = PREV_INSN (prev))\n-\t    {\n-\t      /* We ignore line number notes, but if we see any other note,\n-\t\t in particular NOTE_INSN_BLOCK_*, NOTE_INSN_EH_REGION_*,\n-\t\t NOTE_INSN_LOOP_*, we disable this optimization.  */\n-\t      if (GET_CODE (prev) == NOTE)\n-\t\t{\n-\t\t  if (NOTE_LINE_NUMBER (prev) < 0)\n-\t\t    break;\n-\t\t  continue;\n-\t\t}\n-\t      if (GET_CODE (prev) == CODE_LABEL)\n-\t\tbreak;\n-\t      if (GET_CODE (prev) == JUMP_INSN)\n-\t\t{\n-\t\t  if (GET_CODE (PATTERN (prev)) == SET\n-\t\t      && SET_DEST (PATTERN (prev)) == pc_rtx\n-\t\t      && GET_CODE (SET_SRC (PATTERN (prev))) == IF_THEN_ELSE\n-\t\t      && (GET_CODE (XEXP (SET_SRC (PATTERN (prev)), 1))\n-\t\t\t  == LABEL_REF)\n-\t\t      && XEXP (XEXP (SET_SRC (PATTERN (prev)), 1), 0) == label)\n-\t\t    {\n-\t\t      XEXP (XEXP (SET_SRC (PATTERN (prev)), 1), 0)\n-\t\t\t= start_label;\n-\t\t      emit_note_after (NOTE_INSN_LOOP_END, prev);\n-\t\t      needs_end_jump = 0;\n-\t\t    }\n-\t\t  break;\n-\t\t}\n-\t   }\n-\t}\n-    }\n-\n-     /* If the loop starts with a loop exit, roll that to the end where\n+  /* If the loop starts with a loop exit, roll that to the end where\n      it will optimize together with the jump back.\n \n-     We look for the conditional branch to the exit, except that once\n-     we find such a branch, we don't look past 30 instructions.\n-\n-     In more detail, if the loop presently looks like this (in pseudo-C):\n+     If the loop presently looks like this (in pseudo-C):\n \n-         start_label:\n-         if (test) goto end_label;\n-\t body;\n-\t goto start_label;\n-\t end_label:\n+\tLOOP_BEG\n+\tstart_label:\n+\t  if (test) goto end_label;\n+\tLOOP_END_TOP_COND\n+\t  body;\n+\t  goto start_label;\n+\tend_label:\n \n      transform it to look like:\n \n-         goto start_label;\n-         newstart_label:\n-\t body;\n-\t start_label:\n-\t if (test) goto end_label;\n-\t goto newstart_label;\n-\t end_label:\n-\n-     Here, the `test' may actually consist of some reasonably complex\n-     code, terminating in a test.  */\n-\n-  if (optimize\n-      && needs_end_jump\n-      &&\n-      ! (GET_CODE (insn) == JUMP_INSN\n-\t && GET_CODE (PATTERN (insn)) == SET\n-\t && SET_DEST (PATTERN (insn)) == pc_rtx\n-\t && GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE))\n-    {\n-      int eh_regions = 0;\n-      int num_insns = 0;\n-      rtx last_test_insn = NULL_RTX;\n-\n-      /* Scan insns from the top of the loop looking for a qualified\n-\t conditional exit.  */\n-      for (insn = NEXT_INSN (loop_stack->data.loop.start_label); insn;\n-\t   insn = NEXT_INSN (insn))\n-\t{\n-\t  if (GET_CODE (insn) == NOTE)\n-\t    {\n-\t      if (optimize < 2\n-\t\t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG\n-\t\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END))\n-\t\t/* The code that actually moves the exit test will\n-\t\t   carefully leave BLOCK notes in their original\n-\t\t   location.  That means, however, that we can't debug\n-\t\t   the exit test itself.  So, we refuse to move code\n-\t\t   containing BLOCK notes at low optimization levels.  */\n-\t\tbreak;\n-\n-\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n-\t\t++eh_regions;\n-\t      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)\n-\t\t{\n-\t\t  --eh_regions;\n-\t\t  if (eh_regions < 0)\n-\t\t    /* We've come to the end of an EH region, but\n-\t\t       never saw the beginning of that region.  That\n-\t\t       means that an EH region begins before the top\n-\t\t       of the loop, and ends in the middle of it.  The\n-\t\t       existence of such a situation violates a basic\n-\t\t       assumption in this code, since that would imply\n-\t\t       that even when EH_REGIONS is zero, we might\n-\t\t       move code out of an exception region.  */\n-\t\t    abort ();\n-\t\t}\n-\n-\t      /* We must not walk into a nested loop.  */\n-\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t\tbreak;\n-\n-\t      /* We already know this INSN is a NOTE, so there's no\n-\t\t point in looking at it to see if it's a JUMP.  */\n-\t      continue;\n-\t    }\n-\n-\t  if (GET_CODE (insn) == JUMP_INSN || GET_CODE (insn) == INSN)\n-\t    num_insns++;\n+\tLOOP_BEG\n+\t  goto start_label;\n+\ttop_label:\n+\t  body;\n+\tstart_label:\n+\t  if (test) goto end_label;\n+\t  goto top_label;\n+\tend_label:\n+\n+     We rely on the presence of NOTE_INSN_LOOP_END_TOP_COND to mark\n+     the end of the entry condtional.  Without this, our lexical scan\n+     can't tell the difference between an entry conditional and a\n+     body conditional that exits the loop.  Mistaking the two means\n+     that we can misplace the NOTE_INSN_LOOP_CONT note, which can \n+     screw up loop unrolling.\n+\n+     Things will be oh so much better when loop optimization is done\n+     off of a proper control flow graph...  */\n+\n+  /* Scan insns from the top of the loop looking for the END_TOP_COND note.  */\n+\n+  eh_regions = debug_blocks = 0;\n+  for (etc_note = start_label; etc_note ; etc_note = NEXT_INSN (etc_note))\n+    if (GET_CODE (etc_note) == NOTE)\n+      {\n+\tif (NOTE_LINE_NUMBER (etc_note) == NOTE_INSN_LOOP_END_TOP_COND)\n+\t  break;\n \n-\t  if (last_test_insn && num_insns > 30)\n+\t/* We must not walk into a nested loop.  */\n+\telse if (NOTE_LINE_NUMBER (etc_note) == NOTE_INSN_LOOP_BEG)\n+\t  {\n+\t    etc_note = NULL_RTX;\n \t    break;\n+\t  }\n \n-\t  if (eh_regions > 0)\n-\t    /* We don't want to move a partial EH region.  Consider:\n-\n-\t\t  while ( ( { try {\n-\t\t\t\tif (cond ()) 0;\n-\t\t\t\telse {\n-\t\t\t\t  bar();\n-\t\t\t\t  1;\n-\t\t\t\t}\n-\t\t\t      } catch (...) {\n-\t\t\t\t1;\n-\t\t\t      } )) {\n-\t\t     body;\n-\t\t  }\n-\n-\t        This isn't legal C++, but here's what it's supposed to\n-\t        mean: if cond() is true, stop looping.  Otherwise,\n-\t        call bar, and keep looping.  In addition, if cond\n-\t        throws an exception, catch it and keep looping. Such\n-\t        constructs are certainy legal in LISP.\n-\n-\t\tWe should not move the `if (cond()) 0' test since then\n-\t\tthe EH-region for the try-block would be broken up.\n-\t\t(In this case we would the EH_BEG note for the `try'\n-\t\tand `if cond()' but not the call to bar() or the\n-\t\tEH_END note.)\n-\n-\t        So we don't look for tests within an EH region.  */\n-\t    continue;\n-\n-\t  if (GET_CODE (insn) == JUMP_INSN\n-\t      && GET_CODE (PATTERN (insn)) == SET\n-\t      && SET_DEST (PATTERN (insn)) == pc_rtx)\n-\t    {\n-\t      /* This is indeed a jump.  */\n-\t      rtx dest1 = NULL_RTX;\n-\t      rtx dest2 = NULL_RTX;\n-\t      rtx potential_last_test;\n-\t      if (GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE)\n-\t\t{\n-\t\t  /* A conditional jump.  */\n-\t\t  dest1 = XEXP (SET_SRC (PATTERN (insn)), 1);\n-\t\t  dest2 = XEXP (SET_SRC (PATTERN (insn)), 2);\n-\t\t  potential_last_test = insn;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* An unconditional jump.  */\n-\t\t  dest1 = SET_SRC (PATTERN (insn));\n-\t\t  /* Include the BARRIER after the JUMP.  */\n-\t\t  potential_last_test = NEXT_INSN (insn);\n-\t\t}\n-\n-\t      do {\n-\t\tif (dest1 && GET_CODE (dest1) == LABEL_REF\n-\t\t    && ((XEXP (dest1, 0)\n-\t\t\t == loop_stack->data.loop.alt_end_label)\n-\t\t\t|| (XEXP (dest1, 0)\n-\t\t\t    == loop_stack->data.loop.end_label)))\n-\t\t  {\n-\t\t    last_test_insn = potential_last_test;\n-\t\t    break;\n-\t\t  }\n+\t/* At the same time, scan for EH region notes, as we don't want\n+\t   to scrog region nesting.  This shouldn't happen, but...  */\n+\telse if (NOTE_LINE_NUMBER (etc_note) == NOTE_INSN_EH_REGION_BEG)\n+\t  eh_regions++;\n+\telse if (NOTE_LINE_NUMBER (etc_note) == NOTE_INSN_EH_REGION_END)\n+\t  {\n+\t    if (--eh_regions < 0)\n+\t      /* We've come to the end of an EH region, but never saw the\n+\t\t beginning of that region.  That means that an EH region\n+\t\t begins before the top of the loop, and ends in the middle\n+\t\t of it.  The existence of such a situation violates a basic\n+\t\t assumption in this code, since that would imply that even\n+\t\t when EH_REGIONS is zero, we might move code out of an\n+\t\t exception region.  */\n+\t      abort ();\n+\t  }\n \n-\t\t/* If this was a conditional jump, there may be\n-\t\t   another label at which we should look.  */\n-\t\tdest1 = dest2;\n-\t\tdest2 = NULL_RTX;\n-\t      } while (dest1);\n-\t    }\n-\t}\n+\t/* Likewise for debug scopes.  In this case we'll either (1) move\n+\t   all of the notes if they are properly nested or (2) leave the\n+\t   notes alone and only rotate the loop at high optimization \n+\t   levels when we expect to scrog debug info.  */\n+\telse if (NOTE_LINE_NUMBER (etc_note) == NOTE_INSN_BLOCK_BEG)\n+\t  debug_blocks++;\n+\telse if (NOTE_LINE_NUMBER (etc_note) == NOTE_INSN_BLOCK_END)\n+\t  debug_blocks--;\n+      }\n \n-      if (last_test_insn != 0 && last_test_insn != get_last_insn ())\n+  if (etc_note\n+      && optimize\n+      && eh_regions == 0\n+      && (debug_blocks == 0 || optimize >= 2)\n+      && NEXT_INSN (etc_note) != NULL_RTX\n+      && ! any_condjump_p (get_last_insn ()))\n+    {\n+      /* We found one.  Move everything from START to ETC to the end\n+\t of the loop, and add a jump from the top of the loop.  */\n+      rtx top_label = gen_label_rtx ();\n+      rtx start_move = start_label;\n+\n+      /* If the start label is preceded by a NOTE_INSN_LOOP_CONT note,\n+\t then we want to move this note also.  */\n+      if (GET_CODE (PREV_INSN (start_move)) == NOTE\n+\t  && NOTE_LINE_NUMBER (PREV_INSN (start_move)) == NOTE_INSN_LOOP_CONT)\n+\tstart_move = PREV_INSN (start_move);\n+\n+      emit_label_before (top_label, start_move);\n+\n+      /* Actually move the insns.  If the debug scopes are nested, we\n+\t can move everything at once.  Otherwise we have to move them\n+\t one by one and squeeze out the block notes.  */\n+      if (debug_blocks == 0)\n+\treorder_insns (start_move, etc_note, get_last_insn ());\n+      else\n \t{\n-\t  /* We found one.  Move everything from there up\n-\t     to the end of the loop, and add a jump into the loop\n-\t     to jump to there.  */\n-\t  rtx newstart_label = gen_label_rtx ();\n-\t  rtx start_move = start_label;\n-\t  rtx next_insn;\n-\n-\t  /* If the start label is preceded by a NOTE_INSN_LOOP_CONT note,\n-\t     then we want to move this note also.  */\n-\t  if (GET_CODE (PREV_INSN (start_move)) == NOTE\n-\t      && (NOTE_LINE_NUMBER (PREV_INSN (start_move))\n-\t\t  == NOTE_INSN_LOOP_CONT))\n-\t    start_move = PREV_INSN (start_move);\n-\n-\t  emit_label_after (newstart_label, PREV_INSN (start_move));\n-\n-\t  /* Actually move the insns.  Start at the beginning, and\n-\t     keep copying insns until we've copied the\n-\t     last_test_insn.  */\n+\t  rtx insn, next_insn;\n \t  for (insn = start_move; insn; insn = next_insn)\n \t    {\n \t      /* Figure out which insn comes after this one.  We have\n \t\t to do this before we move INSN.  */\n-\t      if (insn == last_test_insn)\n-\t\t/* We've moved all the insns.  */\n-\t\tnext_insn = NULL_RTX;\n-\t      else\n-\t\tnext_insn = NEXT_INSN (insn);\n+\t      next_insn = (insn == etc_note ? NULL : NEXT_INSN (insn));\n \n \t      if (GET_CODE (insn) == NOTE\n \t\t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG\n \t\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END))\n-\t\t/* We don't want to move NOTE_INSN_BLOCK_BEGs or\n-\t\t   NOTE_INSN_BLOCK_ENDs because the correct generation\n-\t\t   of debugging information depends on these appearing\n-\t\t   in the same order in the RTL and in the tree\n-\t\t   structure, where they are represented as BLOCKs.\n-\t\t   So, we don't move block notes.  Of course, moving\n-\t\t   the code inside the block is likely to make it\n-\t\t   impossible to debug the instructions in the exit\n-\t\t   test, but such is the price of optimization.  */\n \t\tcontinue;\n \n-\t      /* Move the INSN.  */\n \t      reorder_insns (insn, insn, get_last_insn ());\n \t    }\n-\n-\t  emit_jump_insn_after (gen_jump (start_label),\n-\t\t\t\tPREV_INSN (newstart_label));\n-\t  emit_barrier_after (PREV_INSN (newstart_label));\n-\t  start_label = newstart_label;\n \t}\n-    }\n \n-  if (needs_end_jump)\n-    {\n-      emit_jump (start_label);\n-      emit_note (NULL, NOTE_INSN_LOOP_END);\n+      /* Add the jump from the top of the loop.  */\n+      emit_jump_insn_before (gen_jump (start_label), top_label);\n+      emit_barrier_before (top_label);\n+      start_label = top_label;\n     }\n+\n+  emit_jump (start_label);\n+  emit_note (NULL, NOTE_INSN_LOOP_END);\n   emit_label (loop_stack->data.loop.end_label);\n \n   POPSTACK (loop_stack);\n@@ -3028,6 +2866,22 @@ expand_exit_loop_if_false (whichloop, cond)\n   return 1;\n }\n \n+/* Like expand_exit_loop_if_false except also emit a note marking\n+   the end of the conditional.  Should only be used immediately \n+   after expand_loop_start.  */\n+\n+int\n+expand_exit_loop_top_cond (whichloop, cond)\n+     struct nesting *whichloop;\n+     tree cond;\n+{\n+  if (! expand_exit_loop_if_false (whichloop, cond))\n+    return 0;\n+\n+  emit_note (NULL, NOTE_INSN_LOOP_END_TOP_COND);\n+  return 1;\n+}\n+\n /* Return nonzero if the loop nest is empty.  Else return zero.  */\n \n int"}, {"sha": "51898d7e63fd9947ac0302bf1717c3bd1f503b8e", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e803a64bc8b81e67597cab2553ce2b30b4facd51/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e803a64bc8b81e67597cab2553ce2b30b4facd51", "patch": "@@ -2751,7 +2751,9 @@ extern void expand_end_null_loop\t\tPARAMS ((void));\n extern int expand_continue_loop\t\t\tPARAMS ((struct nesting *));\n extern int expand_exit_loop\t\t\tPARAMS ((struct nesting *));\n extern int expand_exit_loop_if_false\t\tPARAMS ((struct nesting *,\n-\t\t\t\t\t\t       tree));\n+\t\t\t\t\t\t         tree));\n+extern int expand_exit_loop_top_cond\t\tPARAMS ((struct nesting *,\n+\t\t\t\t\t\t\t tree));\n extern int expand_exit_something\t\tPARAMS ((void));\n \n extern void expand_return\t\t\tPARAMS ((tree));"}]}