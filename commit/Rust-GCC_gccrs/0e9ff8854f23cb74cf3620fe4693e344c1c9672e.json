{"sha": "0e9ff8854f23cb74cf3620fe4693e344c1c9672e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU5ZmY4ODU0ZjIzY2I3NGNmMzYyMGZlNDY5M2UzNDRjMWM5NjcyZQ==", "commit": {"author": {"name": "David S. Miller", "email": "davem@tanya.rutgers.edu", "date": "1998-01-17T23:08:03Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-01-17T23:08:03Z"}, "message": "combine.c (force_to_mode, [...]): Correctly optimize constant offset computations from objects with known...\n\n        * combine.c (force_to_mode, nonzero_bits): Correctly optimize\n        constant offset computations from objects with known alignment in\n        the presence of STACK_BIAS.\n\nFrom-SVN: r17405", "tree": {"sha": "2336b25b2cab487594138677cde074a1a6c0ce6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2336b25b2cab487594138677cde074a1a6c0ce6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e9ff8854f23cb74cf3620fe4693e344c1c9672e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e9ff8854f23cb74cf3620fe4693e344c1c9672e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e9ff8854f23cb74cf3620fe4693e344c1c9672e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e9ff8854f23cb74cf3620fe4693e344c1c9672e/comments", "author": null, "committer": null, "parents": [{"sha": "aef28d1d1eb2d3af2b6015c764345724744ee5fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef28d1d1eb2d3af2b6015c764345724744ee5fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aef28d1d1eb2d3af2b6015c764345724744ee5fe"}], "stats": {"total": 65, "additions": 55, "deletions": 10}, "files": [{"sha": "0fdabb2567e083b393b68b5b4f78523998316cb2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e9ff8854f23cb74cf3620fe4693e344c1c9672e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e9ff8854f23cb74cf3620fe4693e344c1c9672e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e9ff8854f23cb74cf3620fe4693e344c1c9672e", "patch": "@@ -1,5 +1,9 @@\n Sat Jan 17 23:41:36 1998  David S. Miller  <davem@tanya.rutgers.edu>\n \n+\t* combine.c (force_to_mode, nonzero_bits): Correctly optimize\n+\tconstant offset computations from objects with known alignment in\n+\tthe presence of STACK_BIAS.\n+\n \t* varasm.c (immed_double_const): Add casts to HOST_WIDE_INT where\n \tnecessary.\n \t(const_hash): Hash val is unsigned long."}, {"sha": "4bfa9e56ebb9508171cad0b565917e9f0060886d", "filename": "gcc/combine.c", "status": "modified", "additions": 51, "deletions": 10, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e9ff8854f23cb74cf3620fe4693e344c1c9672e/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e9ff8854f23cb74cf3620fe4693e344c1c9672e/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=0e9ff8854f23cb74cf3620fe4693e344c1c9672e", "patch": "@@ -6253,12 +6253,32 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t  smask |= (HOST_WIDE_INT) -1 << width;\n \n \tif (GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t    && exact_log2 (- smask) >= 0\n-\t    && (nonzero_bits (XEXP (x, 0), mode) & ~ mask) == 0\n-\t    && (INTVAL (XEXP (x, 1)) & ~ mask) != 0)\n-\t  return force_to_mode (plus_constant (XEXP (x, 0),\n-\t\t\t\t\t       INTVAL (XEXP (x, 1)) & mask),\n-\t\t\t\tmode, mask, reg, next_select);\n+\t    && exact_log2 (- smask) >= 0)\n+\t  {\n+#ifdef STACK_BIAS\n+\t    if (STACK_BIAS\n+\t        && (XEXP (x, 0) == stack_pointer_rtx\n+\t            || XEXP (x, 0) == frame_pointer_rtx))\n+\t      {\n+                int sp_alignment = STACK_BOUNDARY / BITS_PER_UNIT;\n+                unsigned HOST_WIDE_INT sp_mask = GET_MODE_MASK (mode);\n+          \n+\t\tsp_mask &= ~ (sp_alignment - 1);\n+\t\tif ((sp_mask & ~ mask) == 0\n+\t\t    && ((INTVAL (XEXP (x, 1)) - STACK_BIAS) & ~ mask) != 0)\n+\t\t  return force_to_mode (plus_constant (XEXP (x, 0),\n+\t\t  \t\t\t\t       ((INTVAL (XEXP (x, 1)) -\n+\t\t\t\t\t\t\t STACK_BIAS) & mask)\n+\t\t\t\t\t\t       + STACK_BIAS),\n+\t\t \t\t\tmode, mask, reg, next_select);\n+              }\n+#endif\n+\t    if ((nonzero_bits (XEXP (x, 0), mode) & ~ mask) == 0\n+\t        && (INTVAL (XEXP (x, 1)) & ~ mask) != 0)\n+\t      return force_to_mode (plus_constant (XEXP (x, 0),\n+\t\t\t\t\t           INTVAL (XEXP (x, 1)) & mask),\n+\t\t\t\t    mode, mask, reg, next_select);\n+\t  }\n       }\n \n       /* ... fall through ...  */\n@@ -7331,10 +7351,15 @@ nonzero_bits (x, mode)\n \t In particular, in the Irix6 n64 ABI, the stack has 128 bit\n \t alignment but the argument pointer has only 64 bit alignment.  */\n \n-      if (x == stack_pointer_rtx || x == frame_pointer_rtx\n-\t  || x == hard_frame_pointer_rtx\n-\t  || (REGNO (x) >= FIRST_VIRTUAL_REGISTER\n-\t      && REGNO (x) <= LAST_VIRTUAL_REGISTER))\n+      if ((x == frame_pointer_rtx\n+\t   || x == stack_pointer_rtx\n+\t   || x == hard_frame_pointer_rtx\n+\t   || (REGNO (x) >= FIRST_VIRTUAL_REGISTER\n+\t       && REGNO (x) <= LAST_VIRTUAL_REGISTER))\n+#ifdef STACK_BIAS\n+\t  && !STACK_BIAS\n+#endif\t      \n+\t      )\n \t{\n \t  int sp_alignment = STACK_BOUNDARY / BITS_PER_UNIT;\n \n@@ -7515,6 +7540,22 @@ nonzero_bits (x, mode)\n \tswitch (code)\n \t  {\n \t  case PLUS:\n+#ifdef STACK_BIAS\n+\t    if (STACK_BIAS\n+\t        && (XEXP (x, 0) == stack_pointer_rtx\n+\t            || XEXP (x, 0) == frame_pointer_rtx)\n+\t        && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t      {\n+\t\tint sp_alignment = STACK_BOUNDARY / BITS_PER_UNIT;\n+\n+\t        nz0 = (GET_MODE_MASK (mode) & ~ (sp_alignment - 1));\n+\t        nz1 = INTVAL (XEXP (x, 1)) - STACK_BIAS;\n+\t        width0 = floor_log2 (nz0) + 1;\n+\t        width1 = floor_log2 (nz1) + 1;\n+\t        low0 = floor_log2 (nz0 & -nz0);\n+\t        low1 = floor_log2 (nz1 & -nz1);\n+\t      }\n+#endif\t  \n \t    result_width = MAX (width0, width1) + 1;\n \t    result_low = MIN (low0, low1);\n \t    break;"}]}