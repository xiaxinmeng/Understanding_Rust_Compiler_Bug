{"sha": "602fca427df6c5f7452677cfcdd16a5b9a3ca86a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAyZmNhNDI3ZGY2YzVmNzQ1MjY3N2NmY2RkMTZhNWI5YTNjYTg2YQ==", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-08-17T19:15:46Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-08-18T11:25:29Z"}, "message": "Turn 'bool force_collect' parameter to 'ggc_collect' into an 'enum ggc_collect mode'\n\n... to make the meaning more explicit to the reader of the code.\n\nFollow-up to recent commit 0edf2e81bb02cba43b649b3f6e7258b68a779ac0\n\"Turn global 'ggc_force_collect' variable into 'force_collect' parameter to\n'ggc_collect'\".\n\n\tgcc/\n\t* ggc.h (enum ggc_collect): New.\n\t(ggc_collect): Use it.\n\t* ggc-page.c: Adjust.\n\t* ggc-common.c: Likewise.\n\t* ggc-tests.c: Likewise.\n\t* read-rtl-function.c: Likewise.\n\t* selftest-run-tests.c: Likewise.\n\t* doc/gty.texi (Invoking the garbage collector): Likewise.\n\nSuggested-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "a6de70912168e67f7281933cbd1ad8c050039fc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6de70912168e67f7281933cbd1ad8c050039fc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/602fca427df6c5f7452677cfcdd16a5b9a3ca86a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/602fca427df6c5f7452677cfcdd16a5b9a3ca86a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/602fca427df6c5f7452677cfcdd16a5b9a3ca86a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/602fca427df6c5f7452677cfcdd16a5b9a3ca86a/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76bb3c50dd43a5f87d4f949cf0d0979144562e6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76bb3c50dd43a5f87d4f949cf0d0979144562e6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76bb3c50dd43a5f87d4f949cf0d0979144562e6c"}], "stats": {"total": 45, "additions": 24, "deletions": 21}, "files": [{"sha": "2ad7793191bf474e59477409a72c9167a0ecb217", "filename": "gcc/doc/gty.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602fca427df6c5f7452677cfcdd16a5b9a3ca86a/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602fca427df6c5f7452677cfcdd16a5b9a3ca86a/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=602fca427df6c5f7452677cfcdd16a5b9a3ca86a", "patch": "@@ -655,9 +655,9 @@ with many other garbage collectors, it is not implicitly invoked by\n allocation routines when a lot of memory has been consumed. So the\n only way to have GGC reclaim storage is to call the @code{ggc_collect}\n function explicitly.\n-When the @var{force_collect} parameter is set or otherwise an internal\n-heuristic decides whether to actually collect, this call is\n-potentially an expensive operation, as it may\n+With @var{mode} @code{GGC_COLLECT_FORCE} or otherwise (default\n+@code{GGC_COLLECT_HEURISTIC}) when the internal heuristic decides to\n+collect, this call is potentially an expensive operation, as it may\n have to scan the entire heap.  Beware that local variables (on the GCC\n call stack) are not followed by such an invocation (as many other\n garbage collectors do): you should reference all your data from static"}, {"sha": "32ba5be42b2e10511860927645c66d053710d172", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602fca427df6c5f7452677cfcdd16a5b9a3ca86a/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602fca427df6c5f7452677cfcdd16a5b9a3ca86a/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=602fca427df6c5f7452677cfcdd16a5b9a3ca86a", "patch": "@@ -962,7 +962,7 @@ dump_ggc_loc_statistics ()\n   if (! GATHER_STATISTICS)\n     return;\n \n-  ggc_collect (true);\n+  ggc_collect (GGC_COLLECT_FORCE);\n \n   ggc_mem_desc.dump (GGC_ORIGIN);\n }"}, {"sha": "1c49643e7e7cc24dcceb0d91a074510e0d0a7628", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602fca427df6c5f7452677cfcdd16a5b9a3ca86a/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602fca427df6c5f7452677cfcdd16a5b9a3ca86a/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=602fca427df6c5f7452677cfcdd16a5b9a3ca86a", "patch": "@@ -2184,7 +2184,7 @@ validate_free_objects (void)\n /* Top level mark-and-sweep routine.  */\n \n void\n-ggc_collect (bool force_collect)\n+ggc_collect (enum ggc_collect mode)\n {\n   /* Avoid frequent unnecessary work by skipping collection if the\n      total allocations haven't expanded much since the last\n@@ -2196,7 +2196,8 @@ ggc_collect (bool force_collect)\n   memory_block_pool::trim ();\n \n   float min_expand = allocated_last_gc * param_ggc_min_expand / 100;\n-  if (G.allocated < allocated_last_gc + min_expand && !force_collect)\n+  if (mode == GGC_COLLECT_HEURISTIC\n+      && G.allocated < allocated_last_gc + min_expand)\n     return;\n \n   timevar_push (TV_GC);"}, {"sha": "e83f701986368e7b8e9ccb512203e56366edb233", "filename": "gcc/ggc-tests.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602fca427df6c5f7452677cfcdd16a5b9a3ca86a/gcc%2Fggc-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602fca427df6c5f7452677cfcdd16a5b9a3ca86a/gcc%2Fggc-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-tests.c?ref=602fca427df6c5f7452677cfcdd16a5b9a3ca86a", "patch": "@@ -47,7 +47,7 @@ test_basic_struct ()\n   root_test_struct = ggc_cleared_alloc <test_struct> ();\n   root_test_struct->other = ggc_cleared_alloc <test_struct> ();\n \n-  ggc_collect (true);\n+  ggc_collect (GGC_COLLECT_FORCE);\n \n   ASSERT_TRUE (ggc_marked_p (root_test_struct));\n   ASSERT_TRUE (ggc_marked_p (root_test_struct->other));\n@@ -77,7 +77,7 @@ test_length ()\n   for (int i = 0; i < count; i++)\n     root_test_of_length->elem[i] = ggc_cleared_alloc <test_of_length> ();\n \n-  ggc_collect (true);\n+  ggc_collect (GGC_COLLECT_FORCE);\n \n   ASSERT_TRUE (ggc_marked_p (root_test_of_length));\n   for (int i = 0; i < count; i++)\n@@ -151,7 +151,7 @@ test_union ()\n   test_struct *referenced_by_other = ggc_cleared_alloc <test_struct> ();\n   other->m_ptr = referenced_by_other;\n \n-  ggc_collect (true);\n+  ggc_collect (GGC_COLLECT_FORCE);\n \n   ASSERT_TRUE (ggc_marked_p (root_test_of_union_1));\n   ASSERT_TRUE (ggc_marked_p (ts));\n@@ -192,7 +192,7 @@ test_finalization ()\n \n   test_struct_with_dtor::dtor_call_count = 0;\n \n-  ggc_collect (true);\n+  ggc_collect (GGC_COLLECT_FORCE);\n \n   /* Verify that the destructor was run for each instance.  */\n   ASSERT_EQ (count, test_struct_with_dtor::dtor_call_count);\n@@ -210,7 +210,7 @@ test_deletable_global ()\n   test_of_deletable = ggc_cleared_alloc <test_struct> ();\n   ASSERT_TRUE (test_of_deletable != NULL);\n \n-  ggc_collect (true);\n+  ggc_collect (GGC_COLLECT_FORCE);\n \n   ASSERT_EQ (NULL, test_of_deletable);\n }\n@@ -283,7 +283,7 @@ test_inheritance ()\n   test_some_subclass_as_base_ptr = new some_subclass ();\n   test_some_other_subclass_as_base_ptr = new some_other_subclass ();\n \n-  ggc_collect (true);\n+  ggc_collect (GGC_COLLECT_FORCE);\n \n   /* Verify that the roots and everything referenced by them got marked\n      (both for fields in the base class and those in subclasses).  */\n@@ -362,7 +362,7 @@ test_chain_next ()\n       tail_node = new_node;\n     }\n \n-  ggc_collect (true);\n+  ggc_collect (GGC_COLLECT_FORCE);\n \n   /* If we got here, we survived.  */\n \n@@ -429,7 +429,7 @@ test_user_struct ()\n \n   num_calls_to_user_gt_ggc_mx = 0;\n \n-  ggc_collect (true);\n+  ggc_collect (GGC_COLLECT_FORCE);\n \n   ASSERT_TRUE (ggc_marked_p (root_user_struct_ptr));\n   ASSERT_TRUE (ggc_marked_p (referenced));\n@@ -447,7 +447,7 @@ test_tree_marking ()\n {\n   dummy_unittesting_tree = build_int_cst (integer_type_node, 1066);\n \n-  ggc_collect (true);\n+  ggc_collect (GGC_COLLECT_FORCE);\n \n   ASSERT_TRUE (ggc_marked_p (dummy_unittesting_tree));\n }"}, {"sha": "5e921d957fd1fa6f988bd702538c088266dcdd01", "filename": "gcc/ggc.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602fca427df6c5f7452677cfcdd16a5b9a3ca86a/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602fca427df6c5f7452677cfcdd16a5b9a3ca86a/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=602fca427df6c5f7452677cfcdd16a5b9a3ca86a", "patch": "@@ -262,10 +262,12 @@ extern const char *ggc_alloc_string (const char *contents, int length\n #define ggc_strdup(S) ggc_alloc_string ((S), -1 MEM_STAT_INFO)\n \n /* Invoke the collector.  Garbage collection occurs only when this\n-   function is called, not during allocations.\n-   Unless FORCE_COLLECT, an internal heuristic decides whether to actually\n-   collect.  */\n-extern void ggc_collect (bool force_collect = false);\n+   function is called, not during allocations.  */\n+enum ggc_collect {\n+  GGC_COLLECT_HEURISTIC,\n+  GGC_COLLECT_FORCE\n+};\n+extern void ggc_collect (enum ggc_collect mode = GGC_COLLECT_HEURISTIC);\n \n /* Return unused memory pages to the system.  */\n extern void ggc_trim (void);"}, {"sha": "941d1e158a303b1f554116269499a1e73db426e4", "filename": "gcc/read-rtl-function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602fca427df6c5f7452677cfcdd16a5b9a3ca86a/gcc%2Fread-rtl-function.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602fca427df6c5f7452677cfcdd16a5b9a3ca86a/gcc%2Fread-rtl-function.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl-function.c?ref=602fca427df6c5f7452677cfcdd16a5b9a3ca86a", "patch": "@@ -1861,7 +1861,7 @@ test_loading_labels ()\n \n   /* Ensure that label names read from a dump are GC-managed\n      and are found through the insn.  */\n-  ggc_collect (true);\n+  ggc_collect (GGC_COLLECT_FORCE);\n   ASSERT_TRUE (ggc_marked_p (insn_200));\n   ASSERT_TRUE (ggc_marked_p (LABEL_NAME (insn_200)));\n }"}, {"sha": "6a8f291f5dd9ca1f17ab301fc76734b81e6c5522", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/602fca427df6c5f7452677cfcdd16a5b9a3ca86a/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/602fca427df6c5f7452677cfcdd16a5b9a3ca86a/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=602fca427df6c5f7452677cfcdd16a5b9a3ca86a", "patch": "@@ -128,7 +128,7 @@ selftest::run_tests ()\n      issues.  For example, if any GC-managed items have buggy (or missing)\n      finalizers, this last collection will ensure that things that were\n      failed to be finalized can be detected by valgrind.  */\n-  ggc_collect (true);\n+  ggc_collect (GGC_COLLECT_FORCE);\n \n   /* Finished running tests; the test_runner dtor will print a summary.  */\n }"}]}