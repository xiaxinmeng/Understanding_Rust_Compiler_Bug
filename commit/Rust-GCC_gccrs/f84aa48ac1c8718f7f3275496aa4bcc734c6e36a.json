{"sha": "f84aa48ac1c8718f7f3275496aa4bcc734c6e36a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg0YWE0OGFjMWM4NzE4ZjdmMzI3NTQ5NmFhNGJjYzczNGM2ZTM2YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-02-13T10:40:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-02-13T10:40:40Z"}, "message": "i386.h (SSE_CLASS_P, [...]): New macros.\n\n\n\t* i386.h (SSE_CLASS_P, MMX_CLASS_P, MAYBE_FLOAT_CLASS_P,\n\tMAYBE_SSE_CLASS_P, MAYBE_MMX_CLASS_P): New macros.\n\t(PREFERRED_RELOAD_CLASS, SECONDARY_MEMORY_NEEDED): Move offline.\n\t(REGISTER_MOVE_COST): Likewise.\n\t* i386-protos.h (ix86_secondary_memory_needed,\n\tix86_preferred_reload_class, ix86_register_move_cost): Declare.\n\t* i386.c (ix86_secondary_memory_needed,\n\tix86_preferred_reload_class, ix86_register_move_cost): New function.\n\nFrom-SVN: r39622", "tree": {"sha": "537f9fa2dd14fc9ffe672728b7337b853e9af29e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/537f9fa2dd14fc9ffe672728b7337b853e9af29e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f84aa48ac1c8718f7f3275496aa4bcc734c6e36a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f84aa48ac1c8718f7f3275496aa4bcc734c6e36a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f84aa48ac1c8718f7f3275496aa4bcc734c6e36a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f84aa48ac1c8718f7f3275496aa4bcc734c6e36a/comments", "author": null, "committer": null, "parents": [{"sha": "a946dd00743b24b4ac24ed1f5d39df34bc263964", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a946dd00743b24b4ac24ed1f5d39df34bc263964", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a946dd00743b24b4ac24ed1f5d39df34bc263964"}], "stats": {"total": 157, "additions": 125, "deletions": 32}, "files": [{"sha": "df04b0380df224be0cf5ee7bbfd8b91a97e46e8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84aa48ac1c8718f7f3275496aa4bcc734c6e36a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84aa48ac1c8718f7f3275496aa4bcc734c6e36a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f84aa48ac1c8718f7f3275496aa4bcc734c6e36a", "patch": "@@ -1,3 +1,14 @@\n+Tue Feb 13 11:37:06 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.h (SSE_CLASS_P, MMX_CLASS_P, MAYBE_FLOAT_CLASS_P,\n+\tMAYBE_SSE_CLASS_P, MAYBE_MMX_CLASS_P): New macros.\n+\t(PREFERRED_RELOAD_CLASS, SECONDARY_MEMORY_NEEDED): Move offline.\n+\t(REGISTER_MOVE_COST): Likewise.\n+\t* i386-protos.h (ix86_secondary_memory_needed,\n+\tix86_preferred_reload_class, ix86_register_move_cost): Declare.\n+\t* i386.c (ix86_secondary_memory_needed,\n+\tix86_preferred_reload_class, ix86_register_move_cost): New function.\n+\n Die Feb 13 11:04:25 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.h (VALID_FP_MODE_P, VALID_INT_MODE_P): New."}, {"sha": "4e5dffdbcf60f1bac93db93822165d97ded7930a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84aa48ac1c8718f7f3275496aa4bcc734c6e36a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84aa48ac1c8718f7f3275496aa4bcc734c6e36a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f84aa48ac1c8718f7f3275496aa4bcc734c6e36a", "patch": "@@ -8725,6 +8725,108 @@ ix86_free_from_memory (mode)\n \t\t\t\t\t\t : 4))));\n }\n \n+/* Put float CONST_DOUBLE in the constant pool instead of fp regs.\n+   QImode must go into class Q_REGS.\n+   Narrow ALL_REGS to GENERAL_REGS.  This supports allowing movsf and\n+   movdf to do mem-to-mem moves through integer regs. */\n+enum reg_class\n+ix86_preferred_reload_class (x, class)\n+     rtx x;\n+     enum reg_class class;\n+{\n+  if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) != VOIDmode)\n+    {\n+      /* SSE can't load any constant directly yet.  */\n+      if (SSE_CLASS_P (class))\n+\treturn NO_REGS;\n+      /* Floats can load 0 and 1.  */\n+      if (MAYBE_FLOAT_CLASS_P (class) && standard_80387_constant_p (x))\n+\t{\n+\t  /* Limit class to non-SSE.  Use GENERAL_REGS if possible.  */\n+\t  if (MAYBE_SSE_CLASS_P (class))\n+\t    return (reg_class_subset_p (class, GENERAL_REGS)\n+\t\t    ? GENERAL_REGS : FLOAT_REGS);\n+\t  else\n+\t    return class;\n+\t}\n+      /* General regs can load everything.  */\n+      if (reg_class_subset_p (class, GENERAL_REGS))\n+\treturn GENERAL_REGS;\n+      /* In case we haven't resolved FLOAT or SSE yet, give up.  */\n+      if (MAYBE_FLOAT_CLASS_P (class) || MAYBE_SSE_CLASS_P (class))\n+\treturn NO_REGS;\n+    }\n+  if (MAYBE_MMX_CLASS_P (class) && CONSTANT_P (x))\n+    return NO_REGS;\n+  if (GET_MODE (x) == QImode && ! reg_class_subset_p (class, Q_REGS))\n+    return Q_REGS;\n+  return class;\n+}\n+\n+/* If we are copying between general and FP registers, we need a memory\n+   location. The same is true for SSE and MMX registers.\n+\n+   The macro can't work reliably when one of the CLASSES is class containing\n+   registers from multiple units (SSE, MMX, integer).  We avoid this by never\n+   combining those units in single alternative in the machine description.\n+   Ensure that this constraint holds to avoid unexpected surprises.\n+\n+   When STRICT is false, we are being called from REGISTER_MOVE_COST, so do not\n+   enforce these sanity checks.  */\n+int\n+ix86_secondary_memory_needed (class1, class2, mode, strict)\n+     enum reg_class class1, class2;\n+     enum machine_mode mode;\n+     int strict;\n+{\n+  if (MAYBE_FLOAT_CLASS_P (class1) != FLOAT_CLASS_P (class1)\n+      || MAYBE_FLOAT_CLASS_P (class2) != FLOAT_CLASS_P (class2)\n+      || MAYBE_SSE_CLASS_P (class1) != SSE_CLASS_P (class1)\n+      || MAYBE_SSE_CLASS_P (class2) != SSE_CLASS_P (class2)\n+      || MAYBE_MMX_CLASS_P (class1) != MMX_CLASS_P (class1)\n+      || MAYBE_MMX_CLASS_P (class2) != MMX_CLASS_P (class2))\n+    {\n+      if (strict)\n+\tabort ();\n+      else\n+\treturn 1;\n+    }\n+  return (FLOAT_CLASS_P (class1) != FLOAT_CLASS_P (class2)\n+\t  || (SSE_CLASS_P (class1) != SSE_CLASS_P (class2)\n+\t      && (mode) != SImode)\n+\t  || (MMX_CLASS_P (class1) != MMX_CLASS_P (class2)\n+\t      && (mode) != SImode));\n+}\n+/* Return the cost of moving data from a register in class CLASS1 to\n+   one in class CLASS2. \n+\n+   It is not required that the cost always equal 2 when FROM is the same as TO;\n+   on some machines it is expensive to move between registers if they are not\n+   general registers.  */\n+int\n+ix86_register_move_cost (mode, class1, class2)\n+     enum machine_mode mode;\n+     enum reg_class class1, class2;\n+{\n+  /* In case we require secondary memory, compute cost of the store followed\n+     by load.  In case of copying from general_purpose_register we may emit\n+     multiple stores followed by single load causing memory size mismatch\n+     stall.  Count this as arbitarily high cost of 20.  */\n+  if (ix86_secondary_memory_needed (class1, class2, mode, 0))\n+    {\n+      if (CLASS_MAX_NREGS (CLASS1, MODE) > CLASS_MAX_NREGS (CLASS2, MODE))\n+\treturn 10;\n+      return (MEMORY_MOVE_COST (MODE, CLASS1, 0)\n+\t      + MEMORY_MOVE_COST (MODE, CLASS2, 1));\n+    }\n+  /* Moves between SSE/MMX and integer unit are expensive.\n+     ??? We should make this cost CPU specific.  */\n+  if (MMX_CLASS_P (CLASS1) != MMX_CLASS_P (CLASS2)\n+      || SSE_CLASS_P (CLASS1) != SSE_CLASS_P (CLASS2))\n+    return 3;\n+  return 2;\n+}\n+\n /* Return 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n int\n ix86_hard_regno_mode_ok (regno, mode)"}, {"sha": "13ef600eb62fbef076cce31d88fae0b27c4b2322", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 12, "deletions": 32, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f84aa48ac1c8718f7f3275496aa4bcc734c6e36a/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f84aa48ac1c8718f7f3275496aa4bcc734c6e36a/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=f84aa48ac1c8718f7f3275496aa4bcc734c6e36a", "patch": "@@ -946,6 +946,11 @@ enum reg_class\n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n #define FLOAT_CLASS_P(CLASS) (reg_class_subset_p (CLASS, FLOAT_REGS))\n+#define SSE_CLASS_P(CLASS) (reg_class_subset_p (CLASS, SSE_REGS))\n+#define MMX_CLASS_P(CLASS) (reg_class_subset_p (CLASS, MMX_REGS))\n+#define MAYBE_FLOAT_CLASS_P(CLASS) (reg_classes_intersect_p (CLASS, FLOAT_REGS))\n+#define MAYBE_SSE_CLASS_P(CLASS) (reg_classes_intersect_p (SSE_REGS, CLASS))\n+#define MAYBE_MMX_CLASS_P(CLASS) (reg_classes_intersect_p (MMX_REGS, CLASS))\n \n #define Q_CLASS_P(CLASS) (reg_class_subset_p (CLASS, Q_REGS))\n \n@@ -1112,22 +1117,12 @@ enum reg_class\n    movdf to do mem-to-mem moves through integer regs. */\n \n #define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\t\t\\\n-  (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != VOIDmode\t\t\\\n-   ? (standard_80387_constant_p (X)\t\t\t\t\t\\\n-      ? CLASS\t\t\t\t\t\t\t\t\\\n-      : (reg_class_subset_p (CLASS, FLOAT_REGS) \t\t\t\\\n-\t ? NO_REGS\t\t\t\t\t\t\t\\\n-\t : reg_class_subset_p (CLASS, GENERAL_REGS) ? CLASS : GENERAL_REGS)) \\\n-   : GET_MODE (X) == QImode && ! reg_class_subset_p (CLASS, Q_REGS) ? Q_REGS \\\n-   : (CLASS))\n+   ix86_preferred_reload_class (X, CLASS)\n \n /* If we are copying between general and FP registers, we need a memory\n-   location.  */\n-/* The same is true for SSE and MMX registers.  */\n+   location. The same is true for SSE and MMX registers.  */\n #define SECONDARY_MEMORY_NEEDED(CLASS1,CLASS2,MODE) \\\n-  (FLOAT_CLASS_P (CLASS1) != FLOAT_CLASS_P (CLASS2) \\\n-   || ((CLASS1 == SSE_REGS) != (CLASS2 == SSE_REGS)) \\\n-   || ((CLASS1 == MMX_REGS) != (CLASS2 == MMX_REGS) && (MODE) != SImode))\n+  ix86_secondary_memory_needed (CLASS1, CLASS2, MODE, 1)\n \n /* QImode spills from non-QI registers need a scratch.  This does not\n    happen often -- the only example so far requires an uninitialized \n@@ -1141,7 +1136,7 @@ enum reg_class\n /* On the 80386, this is the size of MODE in words,\n    except in the FP regs, where a single reg is always enough.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n- (FLOAT_CLASS_P (CLASS) || (CLASS) == SSE_REGS || (CLASS) == MMX_REGS\t\\\n+ (FLOAT_CLASS_P (CLASS) || SSE_CLASS_P (CLASS) || MMX_CLASS_P (CLASS)\t\\\n   ? 1\t\t\t\t\t\t\t\t\t\\\n   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n@@ -2352,25 +2347,10 @@ while (0)\n \n    It is not required that the cost always equal 2 when FROM is the same as TO;\n    on some machines it is expensive to move between registers if they are not\n-   general registers.\n+   general registers.  */\n \n-   On the i386, copying between floating-point and fixed-point\n-   registers is done trough memory.  \n- \n-   Integer -> fp moves are noticeably slower than the opposite direction\n-   because of the partial memory stall they cause.  Give it an\n-   arbitary high cost.\n- */\n-\n-#define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2)\t\t\\\n-  ((FLOAT_CLASS_P (CLASS1) && ! FLOAT_CLASS_P (CLASS2))\t\t\\\n-   ? (MEMORY_MOVE_COST (DFmode, CLASS1, 0)\t\t\t\\\n-     + MEMORY_MOVE_COST (DFmode, CLASS2, 1))\t\t\t\\\n-   : (! FLOAT_CLASS_P (CLASS1) && FLOAT_CLASS_P (CLASS2)) ? 10\t\\\n-   : ((CLASS1) == MMX_REGS && (CLASS2) == SSE_REGS) ? 10\t\\\n-   : ((CLASS1) == SSE_REGS && (CLASS2) == MMX_REGS) ? 10\t\\\n-   : ((CLASS1) == MMX_REGS) != ((CLASS2) == MMX_REGS) ? 3\t\\\n-   : 2)\n+#define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2) \\\n+   ix86_register_move_cost (mode, class1, class2);\n \n /* A C expression for the cost of moving data of mode M between a\n    register and memory.  A value of 2 is the default; this cost is"}]}