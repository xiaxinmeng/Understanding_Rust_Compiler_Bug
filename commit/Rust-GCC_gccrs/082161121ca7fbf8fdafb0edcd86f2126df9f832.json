{"sha": "082161121ca7fbf8fdafb0edcd86f2126df9f832", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgyMTYxMTIxY2E3ZmJmOGZkYWZiMGVkY2Q4NmYyMTI2ZGY5ZjgzMg==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-05T10:01:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-05T10:01:14Z"}, "message": "Merge #406\n\n406: Add locations to implicit inference variables r=philberty a=philberty\n\nWhen we have expression paths to generic functions we need to resolve all\r\ntype parameters to something otherwise we are left with orphaned inference\r\nvariables.\r\n\r\nThis adds the same checks from rustc back in, previously the\r\nPathInExpression resolver abused inference variables as it was implemented\r\nincorrectly since this is fixed in previous PRs we can bring this back in\r\nto make typing more strict again.\r\n\r\nFixes #375\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "920e61b1df2c0b39934d08c5338a9f27e283ca57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/920e61b1df2c0b39934d08c5338a9f27e283ca57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/082161121ca7fbf8fdafb0edcd86f2126df9f832", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgkmzqCRBK7hj4Ov3rIwAALdsIAGeSPA6ul49sVvIGEauWTx4L\ngk5LuO/0t9ZfLXKTB7B8CfDERfQnlOM9QL5dpEjNfKC/Ihmqg7iqWvbwtYMJ2cvm\n99FmDrNeXU5cAV8oMgvhoDj7MmBjvXDos0Ljiyyygmvx1ZWDdTr3GkpraL7GkeBq\nPRWbxWydsHDkxCXNC+2m6R1ZlPSOojGx/tgknDjp+6ISAM+f3FMohWVD/mjrVI3a\n/k1uNfZy3pjiqqTB3fBPCFJxPb2jMfrNYcFM6TfNY/b70ukj1HbEk3DTPggb3YGS\n4AEG0r4/gtzri6J5+QKElkhI40jfX0cONJjpiqK0gs0EQPM9wTvze6Fsv7Uv9K4=\n=sH99\n-----END PGP SIGNATURE-----\n", "payload": "tree 920e61b1df2c0b39934d08c5338a9f27e283ca57\nparent b1dcbc3d8e2fedd7b0c2f42554f4c2297469dabe\nparent fad543c8b8bc9c9c2ca98f28b13182dc28e65a28\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1620208874 +0000\ncommitter GitHub <noreply@github.com> 1620208874 +0000\n\nMerge #406\n\n406: Add locations to implicit inference variables r=philberty a=philberty\n\nWhen we have expression paths to generic functions we need to resolve all\r\ntype parameters to something otherwise we are left with orphaned inference\r\nvariables.\r\n\r\nThis adds the same checks from rustc back in, previously the\r\nPathInExpression resolver abused inference variables as it was implemented\r\nincorrectly since this is fixed in previous PRs we can bring this back in\r\nto make typing more strict again.\r\n\r\nFixes #375\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/082161121ca7fbf8fdafb0edcd86f2126df9f832", "html_url": "https://github.com/Rust-GCC/gccrs/commit/082161121ca7fbf8fdafb0edcd86f2126df9f832", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/082161121ca7fbf8fdafb0edcd86f2126df9f832/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1dcbc3d8e2fedd7b0c2f42554f4c2297469dabe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1dcbc3d8e2fedd7b0c2f42554f4c2297469dabe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1dcbc3d8e2fedd7b0c2f42554f4c2297469dabe"}, {"sha": "fad543c8b8bc9c9c2ca98f28b13182dc28e65a28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fad543c8b8bc9c9c2ca98f28b13182dc28e65a28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fad543c8b8bc9c9c2ca98f28b13182dc28e65a28"}], "stats": {"total": 76, "additions": 31, "deletions": 45}, "files": [{"sha": "d82e82b2ee56feb3e1c6898c4dcb55f76ca48bc2", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082161121ca7fbf8fdafb0edcd86f2126df9f832/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082161121ca7fbf8fdafb0edcd86f2126df9f832/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=082161121ca7fbf8fdafb0edcd86f2126df9f832", "patch": "@@ -696,6 +696,7 @@ class TypeCheckExpr : public TypeCheckBase\n   void visit (HIR::ArrayExpr &expr) override\n   {\n     HIR::ArrayElems *elements = expr.get_internal_elements ();\n+    root_array_expr_locus = expr.get_locus ();\n \n     elements->accept_vis (*this);\n     if (infered_array_elems == nullptr)\n@@ -717,7 +718,8 @@ class TypeCheckExpr : public TypeCheckBase\n       return true;\n     });\n \n-    infered_array_elems = TyTy::TyVar::get_implicit_infer_var ().get_tyty ();\n+    infered_array_elems\n+      = TyTy::TyVar::get_implicit_infer_var (root_array_expr_locus).get_tyty ();\n \n     for (auto &type : types)\n       {\n@@ -1152,6 +1154,7 @@ class TypeCheckExpr : public TypeCheckBase\n      Stores the type of array elements, if `expr` is ArrayExpr. */\n   TyTy::BaseType *infered_array_elems;\n   Bexpression *folded_array_capacity;\n+  Location root_array_expr_locus;\n \n   bool inside_loop;\n }; // namespace Resolver"}, {"sha": "c9500409afc8cfb9740d629c2d8a4002c86c573e", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 9, "deletions": 40, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082161121ca7fbf8fdafb0edcd86f2126df9f832/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082161121ca7fbf8fdafb0edcd86f2126df9f832/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=082161121ca7fbf8fdafb0edcd86f2126df9f832", "patch": "@@ -50,7 +50,6 @@ TypeResolution::Resolve (HIR::Crate &crate)\n   if (saw_errors ())\n     return;\n \n-  auto resolver = Resolver::Resolver::get ();\n   auto mappings = Analysis::Mappings::get ();\n   auto context = TypeCheckContext::get ();\n \n@@ -70,7 +69,13 @@ TypeResolution::Resolve (HIR::Crate &crate)\n     TyTy::InferType *infer_var = (TyTy::InferType *) ty;\n     TyTy::BaseType *default_type;\n     bool ok = infer_var->default_type (&default_type);\n-    if (ok)\n+    if (!ok)\n+      {\n+\trust_error_at (mappings->lookup_location (id),\n+\t\t       \"type annotations needed\");\n+\treturn true;\n+      }\n+    else\n       {\n \tauto result = ty->unify (default_type);\n \tresult->set_ref (id);\n@@ -82,42 +87,6 @@ TypeResolution::Resolve (HIR::Crate &crate)\n \n     return true;\n   });\n-\n-  // scan the ribs to ensure the decls are all setup correctly\n-  resolver->iterate_name_ribs ([&] (Rib *r) -> bool {\n-    r->iterate_decls ([&] (NodeId decl_node_id, Location locus) -> bool {\n-      Definition def;\n-      if (!resolver->lookup_definition (decl_node_id, &def))\n-\t{\n-\t  rust_error_at (locus, \"failed to lookup decl def\");\n-\t  return true;\n-\t}\n-\n-      HirId hir_node = UNKNOWN_HIRID;\n-      if (!mappings->lookup_node_to_hir (mappings->get_current_crate (),\n-\t\t\t\t\t def.parent, &hir_node))\n-\t{\n-\t  rust_error_at (locus, \"failed to lookup type hir node id\");\n-\t  return true;\n-\t}\n-\n-      // lookup the ty\n-      TyTy::BaseType *ty = nullptr;\n-      bool ok = context->lookup_type (hir_node, &ty);\n-      if (!ok)\n-\t{\n-\t  rust_error_at (locus, \"failed to lookup type for decl node_id: %u\",\n-\t\t\t decl_node_id);\n-\t  return true;\n-\t}\n-\n-      if (!ty->is_concrete ())\n-\trust_error_at (locus, \"unable to determine type\");\n-\n-      return true;\n-    });\n-    return true;\n-  });\n }\n \n // RUST_HIR_TYPE_CHECK_EXPR\n@@ -269,8 +238,8 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n \n   // everything is ok, now we need to ensure all field values are ordered\n   // correctly. The GIMPLE backend uses a simple algorithm that assumes each\n-  // assigned field in the constructor is in the same order as the field in the\n-  // type\n+  // assigned field in the constructor is in the same order as the field in\n+  // the type\n \n   std::vector<std::unique_ptr<HIR::StructExprField> > expr_fields\n     = struct_expr.get_fields_as_owner ();"}, {"sha": "dcf9203bc1632eb07c1dbd803b8479db67ce51a5", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082161121ca7fbf8fdafb0edcd86f2126df9f832/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082161121ca7fbf8fdafb0edcd86f2126df9f832/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=082161121ca7fbf8fdafb0edcd86f2126df9f832", "patch": "@@ -52,7 +52,7 @@ TyVar::get_tyty () const\n }\n \n TyVar\n-TyVar::get_implicit_infer_var ()\n+TyVar::get_implicit_infer_var (Location locus)\n {\n   auto mappings = Analysis::Mappings::get ();\n   auto context = Resolver::TypeCheckContext::get ();\n@@ -64,6 +64,8 @@ TyVar::get_implicit_infer_var ()\n \t\t\t\t\t       infer->get_ref (),\n \t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n \t\t\tinfer);\n+  mappings->insert_location (mappings->get_current_crate (), infer->get_ref (),\n+\t\t\t     locus);\n   return TyVar (infer->get_ref ());\n }\n "}, {"sha": "442b23b7beb364a8ec56915cee28f50b5e15e02b", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082161121ca7fbf8fdafb0edcd86f2126df9f832/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082161121ca7fbf8fdafb0edcd86f2126df9f832/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=082161121ca7fbf8fdafb0edcd86f2126df9f832", "patch": "@@ -171,7 +171,7 @@ class TyVar\n \n   BaseType *get_tyty () const;\n \n-  static TyVar get_implicit_infer_var ();\n+  static TyVar get_implicit_infer_var (Location locus);\n \n private:\n   HirId ref;\n@@ -695,7 +695,7 @@ class SubstitutionRef\n     std::vector<SubstitutionArg> args;\n     for (auto &sub : get_substs ())\n       {\n-\tTyVar infer_var = TyVar::get_implicit_infer_var ();\n+\tTyVar infer_var = TyVar::get_implicit_infer_var (locus);\n \targs.push_back (SubstitutionArg (&sub, infer_var.get_tyty ()));\n       }\n "}, {"sha": "191f533ff8d0365f786265e4e66be9a8f8c0d44c", "filename": "gcc/testsuite/rust.test/xfail_compile/array_empty_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082161121ca7fbf8fdafb0edcd86f2126df9f832/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Farray_empty_list.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082161121ca7fbf8fdafb0edcd86f2126df9f832/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Farray_empty_list.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Farray_empty_list.rs?ref=082161121ca7fbf8fdafb0edcd86f2126df9f832", "patch": "@@ -1,4 +1,4 @@\n-// { dg-error \"unable to determine type\" \"\" { target { *-*-* } } 0 }\n fn main() {\n     let arr = [];\n+    // { dg-error \"type annotations needed\" \"\" { target { *-*-* } } .-1 }\n }"}, {"sha": "fc46b2e5434db0041bffe1be766815354a696e34", "filename": "gcc/testsuite/rust.test/xfail_compile/generics11.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/082161121ca7fbf8fdafb0edcd86f2126df9f832/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics11.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/082161121ca7fbf8fdafb0edcd86f2126df9f832/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics11.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics11.rs?ref=082161121ca7fbf8fdafb0edcd86f2126df9f832", "patch": "@@ -0,0 +1,12 @@\n+struct Foo<T>(T, bool);\n+\n+impl<T> Foo<T> {\n+    fn test() -> i32 {\n+        123\n+    }\n+}\n+\n+fn main() {\n+    let a = Foo::test();\n+    // { dg-error \"type annotations needed\" \"\" { target { *-*-* } } .-1 }\n+}"}]}