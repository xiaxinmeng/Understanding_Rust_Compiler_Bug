{"sha": "896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk2YzhiOTZjNWNmMzYwOTBiNjJlNWYxYmE4Y2U3ZTQ5YTRhNTNlNQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-03-14T17:05:48Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-03-14T17:05:48Z"}, "message": "re PR tree-optimization/34172 (Missed store ccp optimization)\n\n2008-03-14  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/34172\n\t* tree-flow.h (refs_may_alias_p): Declare.\n\t(get_single_def_stmt): Likewise.\n\t(get_single_def_stmt_from_phi): Likewise.\n\t(get_single_def_stmt_with_phi): Likewise.\n\t* tree-dfa.c (refs_may_alias_p): New function.\n\t(get_single_def_stmt): Likewise.\n\t(get_single_def_stmt_from_phi): Likewise.\n\t(get_single_def_stmt_with_phi): Likewise.\n\t* tree-ssa-sccvn.c (get_def_ref_stmt_vuses): New function.\n\t(vn_reference_lookup_1): New helper function.\n\t(vn_reference_lookup): Walk the virtual use-def chain to\n\tcontinue searching for a match if the def does not alias the\n\treference we are looking for.\n\n\t* gcc.dg/tree-ssa/ssa-fre-11.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-fre-12.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-fre-13.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-fre-14.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-fre-15.c: Likewise.\n\t* gcc.dg/tree-ssa/20031106-4.c: Remove XFAIL.\n\nFrom-SVN: r133222", "tree": {"sha": "e62afbba9e20ac34bc1bb3da1a97cb976122058a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e62afbba9e20ac34bc1bb3da1a97cb976122058a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "155350439afb47e68f93beb052eb93c0128c017c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/155350439afb47e68f93beb052eb93c0128c017c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/155350439afb47e68f93beb052eb93c0128c017c"}], "stats": {"total": 442, "additions": 430, "deletions": 12}, "files": [{"sha": "0da79075f657cb318c726e7f01d697433b17e221", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5", "patch": "@@ -1,3 +1,20 @@\n+2008-03-14  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/34172\n+\t* tree-flow.h (refs_may_alias_p): Declare.\n+\t(get_single_def_stmt): Likewise.\n+\t(get_single_def_stmt_from_phi): Likewise.\n+\t(get_single_def_stmt_with_phi): Likewise.\n+\t* tree-dfa.c (refs_may_alias_p): New function.\n+\t(get_single_def_stmt): Likewise.\n+\t(get_single_def_stmt_from_phi): Likewise.\n+\t(get_single_def_stmt_with_phi): Likewise.\n+\t* tree-ssa-sccvn.c (get_def_ref_stmt_vuses): New function.\n+\t(vn_reference_lookup_1): New helper function.\n+\t(vn_reference_lookup): Walk the virtual use-def chain to\n+\tcontinue searching for a match if the def does not alias the\n+\treference we are looking for.\n+\n 2008-03-14  David Edelsohn  <edelsohn@gnu.org>\n \n \t* doc/install.texi (Binaries): Remove UCLA archive.  Add HVCC"}, {"sha": "f93230a95ae6006d688255ca90db282fe50173d3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5", "patch": "@@ -1,3 +1,13 @@\n+2008-03-14  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/34172\n+\t* gcc.dg/tree-ssa/ssa-fre-11.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-fre-12.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-fre-13.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-fre-14.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-fre-15.c: Likewise.\n+\t* gcc.dg/tree-ssa/20031106-4.c: Remove XFAIL.\n+\n 2008-03-14  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR libcpp/35322:"}, {"sha": "d727886917053ad59d78fce44ab59778b6cf3f15", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20031106-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20031106-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20031106-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20031106-4.c?ref=896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5", "patch": "@@ -26,5 +26,5 @@ void foo (struct s*  r)\n }\n \n /* There should be no link_error calls.  */\n-/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"optimized\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"link_error\" 0 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "50bb5d9606645ae98c7699cd7ad35cd72412ae81", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-11.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-11.c?ref=896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-fre-details\" } */\n+\n+struct\n+{\n+  int x;\n+  int y;\n+} S[100];\n+\n+int z[100];\n+\n+int\n+foo (int y)\n+{\n+  int x;\n+\n+  S[5].x = 4;\n+  S[5].y = 0;\n+\n+  x = S[5].x;\n+\n+  return (x);\n+}\n+\n+/* { dg-final { scan-tree-dump \"Replaced S\\\\\\[5\\\\\\].x with 4\" \"fre\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "50bb5d9606645ae98c7699cd7ad35cd72412ae81", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-12.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-12.c?ref=896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-fre-details\" } */\n+\n+struct\n+{\n+  int x;\n+  int y;\n+} S[100];\n+\n+int z[100];\n+\n+int\n+foo (int y)\n+{\n+  int x;\n+\n+  S[5].x = 4;\n+  S[5].y = 0;\n+\n+  x = S[5].x;\n+\n+  return (x);\n+}\n+\n+/* { dg-final { scan-tree-dump \"Replaced S\\\\\\[5\\\\\\].x with 4\" \"fre\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "3253afe2927a4dcdbf2935fe53114fe946c8888c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-13.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-13.c?ref=896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fstrict-aliasing -fno-tree-sra --param max-aliased-vops=0 --param max-fields-for-field-sensitive=0 -fdump-tree-fre-details\" } */\n+\n+/* Should be optimized, propagating &a into (*p)[i] with parameters\n+     --param max-aliased-vops=0 --param max-fields-for-field-sensitive=0\n+   which means max 1 VOP per stmt and no SFTs.  */\n+\n+/* For this testcase we need TBAA to work.  */\n+\n+struct Foo\n+{\n+  void *data;\n+  int size;\n+};\n+void foo(double (*q)[4], struct Foo *tmp1)\n+{\n+  double a[4];\n+  int i;\n+  tmp1->data = &a;\n+  tmp1->size = 4;\n+  for (i=0; i<4; ++i)\n+    {\n+      double (*p)[4] = tmp1->data;\n+      (*p)[i] = (*q)[i];\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"Inserted .* &a\" \"fre\" } } */\n+/* { dg-final { scan-tree-dump \"Replaced tmp1_.\\\\\\(D\\\\\\)->data\" \"fre\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "d2d5e01bcc40862461097ca6ebb77a08354f1235", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-14.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-14.c?ref=896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fno-tree-sra --param max-aliased-vops=0 --param max-fields-for-field-sensitive=0 -fdump-tree-fre-details\" } */\n+\n+/* Should be optimized, propagating &a into (*p)[i] with parameters\n+     --param max-aliased-vops=0 --param max-fields-for-field-sensitive=0\n+   which means max 1 VOP per stmt and no SFTs.  */\n+\n+struct Foo\n+{\n+  void *data;\n+  double size;\n+};\n+void foo(double (*q)[4])\n+{\n+  struct Foo tmp1;\n+  double a[4];\n+  int i;\n+  tmp1.data = &a;\n+  tmp1.size = 4;\n+  for (i=0; i<4; ++i)\n+    {\n+      double (*p)[4] = tmp1.data;\n+      (*p)[i] = (*q)[i];\n+      /* We want a PHI for the VOP for accessing tmp1.data, so place\n+ \t this store to tmp1 here.  */\n+      tmp1.size -= 1.0;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"Inserted .* &a\" \"fre\" } } */\n+/* { dg-final { scan-tree-dump \"Replaced tmp1.data\" \"fre\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "1a286f1e1cb6cd9a7814e7de8d3ea098460711d2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-15.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-15.c?ref=896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fno-tree-sra --param max-aliased-vops=0 --param max-fields-for-field-sensitive=0 -fdump-tree-fre-details\" } */\n+\n+/* Should be optimized, propagating &a into (*p)[i] with parameters\n+     --param max-aliased-vops=0 --param max-fields-for-field-sensitive=0\n+   which means max 1 VOP per stmt and no SFTs.  */\n+\n+struct Foo\n+{\n+  void *data;\n+  double size;\n+};\n+void foo(double (*q)[4])\n+{\n+  struct Foo tmp1;\n+  double a[4];\n+  int i;\n+  tmp1.data = &a;\n+  for (i=0; i<4; ++i)\n+    {\n+      double (*p)[4] = tmp1.data;\n+      (*p)[i] = (*q)[i];\n+      /* We want a PHI for the VOP for accessing tmp1.data, so place\n+ \t this store to tmp1 here.  */\n+      tmp1.size -= 1.0;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"Replaced\" \"fre\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "349581671a57507ad581a4bf4148706ef699171d", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5", "patch": "@@ -1046,3 +1046,165 @@ stmt_references_abnormal_ssa_name (tree stmt)\n   return false;\n }\n \n+/* Return true, if the two memory references REF1 and REF2 may alias.  */\n+\n+bool\n+refs_may_alias_p (tree ref1, tree ref2)\n+{\n+  tree base1, base2;\n+  HOST_WIDE_INT offset1 = 0, offset2 = 0;\n+  HOST_WIDE_INT size1 = -1, size2 = -1;\n+  HOST_WIDE_INT max_size1 = -1, max_size2 = -1;\n+\n+  gcc_assert ((SSA_VAR_P (ref1)\n+\t       || handled_component_p (ref1)\n+\t       || TREE_CODE (ref1) == INDIRECT_REF)\n+\t      && (SSA_VAR_P (ref2)\n+\t\t  || handled_component_p (ref2)\n+\t\t  || TREE_CODE (ref2) == INDIRECT_REF));\n+\n+  /* Defer to TBAA if possible.  */\n+  if (flag_strict_aliasing\n+      && !alias_sets_conflict_p (get_alias_set (ref1), get_alias_set (ref2)))\n+    return false;\n+\n+  /* Decompose the references into their base objects and the access.  */\n+  base1 = ref1;\n+  if (handled_component_p (ref1))\n+    base1 = get_ref_base_and_extent (ref1, &offset1, &size1, &max_size1);\n+  base2 = ref2;\n+  if (handled_component_p (ref2))\n+    base2 = get_ref_base_and_extent (ref2, &offset2, &size2, &max_size2);\n+\n+  /* If both references are based on different variables, they cannot alias.\n+     If both references are based on the same variable, they cannot alias if\n+     if the accesses do not overlap.  */\n+  if (SSA_VAR_P (base1)\n+      && SSA_VAR_P (base2)\n+      && (!operand_equal_p (base1, base2, 0)\n+\t  || !ranges_overlap_p (offset1, max_size1, offset2, max_size2)))\n+    return false;\n+\n+  /* If both references are through pointers and both pointers are equal\n+     then they do not alias if the accesses do not overlap.  */\n+  if (TREE_CODE (base1) == INDIRECT_REF\n+      && TREE_CODE (base2) == INDIRECT_REF\n+      && operand_equal_p (TREE_OPERAND (base1, 0),\n+\t\t\t  TREE_OPERAND (base2, 0), 0)\n+      && !ranges_overlap_p (offset1, max_size1, offset2, max_size2))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Given a stmt STMT that references memory, return the single stmt\n+   that is reached by following the VUSE -> VDEF link.  Returns\n+   NULL_TREE, if there is no single stmt that defines all VUSEs of\n+   STMT.\n+   Note that for a stmt with a single virtual operand this may return\n+   a PHI node as well.  Note that if all VUSEs are default definitions\n+   this function will return an empty statement.  */\n+\n+tree\n+get_single_def_stmt (tree stmt)\n+{\n+  tree def_stmt = NULL_TREE;\n+  tree use;\n+  ssa_op_iter iter;\n+\n+  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_VIRTUAL_USES)\n+    {\n+      tree tmp = SSA_NAME_DEF_STMT (use);\n+\n+      /* ???  This is too simplistic for multiple virtual operands\n+\t reaching different PHI nodes of the same basic blocks or for\n+\t reaching all default definitions.  */\n+      if (def_stmt\n+\t  && def_stmt != tmp\n+\t  && !(IS_EMPTY_STMT (def_stmt)\n+\t       && IS_EMPTY_STMT (tmp)))\n+\treturn NULL_TREE;\n+\n+      def_stmt = tmp;\n+    }\n+\n+  return def_stmt;\n+}\n+\n+/* Given a PHI node of virtual operands, tries to eliminate cyclic\n+   reached definitions if they do not alias REF and returns the\n+   defining statement of the single virtual operand that flows in\n+   from a non-backedge.  Returns NULL_TREE if such statement within\n+   the above conditions cannot be found.  */\n+\n+tree\n+get_single_def_stmt_from_phi (tree ref, tree phi)\n+{\n+  tree def_arg = NULL_TREE;\n+  int i;\n+\n+  /* Find the single PHI argument that is not flowing in from a\n+     back edge and verify that the loop-carried definitions do\n+     not alias the reference we look for.  */\n+  for (i = 0; i < PHI_NUM_ARGS (phi); ++i)\n+    {\n+      tree arg = PHI_ARG_DEF (phi, i);\n+      tree def_stmt;\n+\n+      if (!(PHI_ARG_EDGE (phi, i)->flags & EDGE_DFS_BACK))\n+\t{\n+\t  /* Multiple non-back edges?  Do not try to handle this.  */\n+\t  if (def_arg)\n+\t    return NULL_TREE;\n+\t  def_arg = arg;\n+\t  continue;\n+\t}\n+\n+      /* Follow the definitions back to the original PHI node.  Bail\n+\t out once a definition is found that may alias REF.  */\n+      def_stmt = SSA_NAME_DEF_STMT (arg);\n+      do\n+\t{\n+\t  if (TREE_CODE (def_stmt) != GIMPLE_MODIFY_STMT\n+\t      || refs_may_alias_p (ref, GIMPLE_STMT_OPERAND (def_stmt, 0)))\n+\t    return NULL_TREE;\n+\t  /* ???  This will only work, reaching the PHI node again if\n+\t     there is a single virtual operand on def_stmt.  */\n+\t  def_stmt = get_single_def_stmt (def_stmt);\n+\t  if (!def_stmt)\n+\t    return NULL_TREE;\n+\t}\n+      while (def_stmt != phi);\n+    }\n+\n+  return SSA_NAME_DEF_STMT (def_arg);\n+}\n+\n+/* Return the single reference statement defining all virtual uses\n+   on STMT or NULL_TREE, if there are multiple defining statements.\n+   Take into account only definitions that alias REF if following\n+   back-edges when looking through a loop PHI node.  */\n+\n+tree\n+get_single_def_stmt_with_phi (tree ref, tree stmt)\n+{\n+  switch (NUM_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_USES))\n+    {\n+    case 0:\n+      gcc_unreachable ();\n+\n+    case 1:\n+      {\n+\ttree def_stmt = SSA_NAME_DEF_STMT (SINGLE_SSA_TREE_OPERAND\n+\t\t\t\t\t     (stmt, SSA_OP_VIRTUAL_USES));\n+\t/* We can handle lookups over PHI nodes only for a single\n+\t   virtual operand.  */\n+\tif (TREE_CODE (def_stmt) == PHI_NODE)\n+\t  return get_single_def_stmt_from_phi (ref, def_stmt);\n+\treturn def_stmt;\n+      }\n+\n+    default:\n+      return get_single_def_stmt (stmt);\n+    }\n+}"}, {"sha": "274e740496ed8dfa604b734a8965ec213b896812", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5", "patch": "@@ -824,6 +824,10 @@ extern tree make_rename_temp (tree, const char *);\n extern void set_default_def (tree, tree);\n extern tree gimple_default_def (struct function *, tree);\n extern bool stmt_references_abnormal_ssa_name (tree);\n+extern bool refs_may_alias_p (tree, tree);\n+extern tree get_single_def_stmt (tree);\n+extern tree get_single_def_stmt_from_phi (tree, tree);\n+extern tree get_single_def_stmt_with_phi (tree, tree);\n \n /* In tree-phinodes.c  */\n extern void reserve_phi_args_for_new_edge (basic_block);"}, {"sha": "3b42c241fb9bcfeed8e8e42c122f5f0d1d35d4a2", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 92, "deletions": 11, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=896c8b96c5cf36090b62e5f1ba8ce7e49a4a53e5", "patch": "@@ -662,28 +662,110 @@ valueize_vuses (VEC (tree, gc) *orig)\n   return orig;\n }\n \n+/* Return the single reference statement defining all virtual uses\n+   in VUSES or NULL_TREE, if there are multiple defining statements.\n+   Take into account only definitions that alias REF if following\n+   back-edges.  */\n+\n+static tree\n+get_def_ref_stmt_vuses (tree ref, VEC (tree, gc) *vuses)\n+{\n+  tree def_stmt, vuse;\n+  unsigned int i;\n+\n+  gcc_assert (VEC_length (tree, vuses) >= 1);\n+\n+  def_stmt = SSA_NAME_DEF_STMT (VEC_index (tree, vuses, 0));\n+  if (TREE_CODE (def_stmt) == PHI_NODE)\n+    {\n+      /* We can only handle lookups over PHI nodes for a single\n+\t virtual operand.  */\n+      if (VEC_length (tree, vuses) == 1)\n+\t{\n+\t  def_stmt = get_single_def_stmt_from_phi (ref, def_stmt);\n+\t  goto cont;\n+\t}\n+      else\n+\treturn NULL_TREE;\n+    }\n+\n+  /* Verify each VUSE reaches the same defining stmt.  */\n+  for (i = 1; VEC_iterate (tree, vuses, i, vuse); ++i)\n+    {\n+      tree tmp = SSA_NAME_DEF_STMT (vuse);\n+      if (tmp != def_stmt)\n+\treturn NULL_TREE;\n+    }\n+\n+  /* Now see if the definition aliases ref, and loop until it does.  */\n+cont:\n+  while (def_stmt\n+\t && TREE_CODE (def_stmt) == GIMPLE_MODIFY_STMT\n+\t && !get_call_expr_in (def_stmt)\n+\t && !refs_may_alias_p (ref, GIMPLE_STMT_OPERAND (def_stmt, 0)))\n+    def_stmt = get_single_def_stmt_with_phi (ref, def_stmt);\n+\n+  return def_stmt;\n+}\n+\n+/* Lookup a SCCVN reference operation VR in the current hash table.\n+   Returns the resulting value number if it exists in the hash table,\n+   NULL_TREE otherwise.  */\n+\n+static tree\n+vn_reference_lookup_1 (vn_reference_t vr)\n+{\n+  void **slot;\n+  hashval_t hash;\n+\n+  hash = vr->hashcode;\n+  slot = htab_find_slot_with_hash (current_info->references, vr,\n+\t\t\t\t   hash, NO_INSERT);\n+  if (!slot && current_info == optimistic_info)\n+    slot = htab_find_slot_with_hash (valid_info->references, vr,\n+\t\t\t\t     hash, NO_INSERT);\n+  if (slot)\n+    return ((vn_reference_t)*slot)->result;\n+\n+  return NULL_TREE;\n+}\n+\n /* Lookup OP in the current hash table, and return the resulting\n    value number if it exists in the hash table.  Return NULL_TREE if\n    it does not exist in the hash table. */\n \n tree\n vn_reference_lookup (tree op, VEC (tree, gc) *vuses)\n {\n-  void **slot;\n   struct vn_reference_s vr1;\n+  tree result, def_stmt;\n \n   vr1.vuses = valueize_vuses (vuses);\n   vr1.operands = valueize_refs (shared_reference_ops_from_ref (op));\n   vr1.hashcode = vn_reference_compute_hash (&vr1);\n-  slot = htab_find_slot_with_hash (current_info->references, &vr1, vr1.hashcode,\n-\t\t\t\t   NO_INSERT);\n-  if (!slot && current_info == optimistic_info)\n-    slot = htab_find_slot_with_hash (valid_info->references, &vr1, vr1.hashcode,\n-\t\t\t\t     NO_INSERT);\n-  if (!slot)\n-    return NULL_TREE;\n+  result = vn_reference_lookup_1 (&vr1);\n+\n+  /* If there is a single defining statement for all virtual uses, we can\n+     use that, following virtual use-def chains.  */\n+  if (!result\n+      && vr1.vuses\n+      && VEC_length (tree, vr1.vuses) >= 1\n+      && !get_call_expr_in (op)\n+      && (def_stmt = get_def_ref_stmt_vuses (op, vr1.vuses))\n+      && TREE_CODE (def_stmt) == GIMPLE_MODIFY_STMT\n+      /* If there is a call involved, op must be assumed to\n+\t be clobbered.  */\n+      && !get_call_expr_in (def_stmt))\n+    {\n+      /* We are now at an aliasing definition for the vuses we want to\n+\t look up.  Re-do the lookup with the vdefs for this stmt.  */\n+      vdefs_to_vec (def_stmt, &vuses);\n+      vr1.vuses = valueize_vuses (vuses);\n+      vr1.hashcode = vn_reference_compute_hash (&vr1);\n+      result = vn_reference_lookup_1 (&vr1);\n+    }\n \n-  return ((vn_reference_t)*slot)->result;\n+  return result;\n }\n \n /* Insert OP into the current hash table with a value number of\n@@ -1632,10 +1714,9 @@ visit_use (tree use)\n \t\t  print_generic_expr (dump_file, simplified, 0);\n \t\t  if (TREE_CODE (lhs) == SSA_NAME)\n \t\t    fprintf (dump_file, \" has constants %d\\n\",\n-\t\t\t     VN_INFO (lhs)->has_constants);\n+\t\t\t     expr_has_constants (simplified));\n \t\t  else\n \t\t    fprintf (dump_file, \"\\n\");\n-\n \t\t}\n \t    }\n \t  /* Setting value numbers to constants will occasionally"}]}