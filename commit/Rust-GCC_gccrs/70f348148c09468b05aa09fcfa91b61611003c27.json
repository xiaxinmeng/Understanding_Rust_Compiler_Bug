{"sha": "70f348148c09468b05aa09fcfa91b61611003c27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBmMzQ4MTQ4YzA5NDY4YjA1YWEwOWZjZmE5MWI2MTYxMTAwM2MyNw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-07-01T08:49:19Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-07-01T08:49:19Z"}, "message": "re PR middle-end/42834 (memcpy folding overeager)\n\n2010-07-01  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/42834\n\tPR middle-end/44468\n\t* doc/gimple.texi (is_gimple_mem_ref_addr): Document.\n\t* doc/generic.texi (References to storage): Document MEM_REF.\n\t* tree-pretty-print.c (dump_generic_node): Handle MEM_REF.\n\t(print_call_name): Likewise.\n\t* tree.c (recompute_tree_invariant_for_addr_expr): Handle MEM_REF.\n\t(build_simple_mem_ref_loc): New function.\n\t(mem_ref_offset): Likewise.\n\t* tree.h (build_simple_mem_ref_loc): Declare.\n\t(build_simple_mem_ref): Define.\n\t(mem_ref_offset): Declare.\n\t* fold-const.c: Include tree-flow.h.\n\t(operand_equal_p): Handle MEM_REF.\n\t(build_fold_addr_expr_with_type_loc): Likewise.\n\t(fold_comparison): Likewise.\n\t(fold_unary_loc): Fold\n\tVIEW_CONVERT_EXPR <T1, MEM_REF <T2, ...>> to MEM_REF <T1, ...>.\n\t(fold_binary_loc): Fold MEM[&MEM[p, CST1], CST2] to MEM[p, CST1 + CST2],\n\tfold MEM[&a.b, CST2] to MEM[&a, offsetof (a, b) + CST2].\n\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Handle MEM_REF.\n\t(ptr_deref_may_alias_ref_p_1): Likewise.\n\t(ao_ref_base_alias_set): Properly differentiate base object for\n\toffset and TBAA.\n\t(ao_ref_init_from_ptr_and_size): Use MEM_REF.\n\t(indirect_ref_may_alias_decl_p): Handle MEM_REFs properly.\n\t(indirect_refs_may_alias_p): Likewise.\n\t(refs_may_alias_p_1): Likewise.  Remove pointer SSA name def\n\tchasing code.\n\t(ref_maybe_used_by_call_p_1): Handle MEM_REF.\n\t(call_may_clobber_ref_p_1): Likewise.\n\t* dwarf2out.c (loc_list_from_tree): Handle MEM_REF.\n\t* expr.c (expand_assignment): Handle MEM_REF.\n\t(store_expr): Handle MEM_REFs from STRING_CSTs.\n\t(store_field): If expanding a MEM_REF of a non-addressable\n\tdecl use bitfield operations.\n\t(get_inner_reference): Handle MEM_REF.\n\t(expand_expr_addr_expr_1): Likewise.\n\t(expand_expr_real_1): Likewise.\n\t* tree-eh.c (tree_could_trap_p): Handle MEM_REF.\n\t* alias.c (ao_ref_from_mem): Handle MEM_REF.\n\t(get_alias_set): Likewise.  Properly handle VIEW_CONVERT_EXPRs.\n\t* tree-data-ref.c (dr_analyze_innermost): Handle MEM_REF.\n\t(dr_analyze_indices): Likewise.\n\t(dr_analyze_alias): Likewise.\n\t(object_address_invariant_in_loop_p): Likewise.\n\t* gimplify.c (mark_addressable): Handle MEM_REF.\n\t(gimplify_cond_expr): Build MEM_REFs.\n\t(gimplify_modify_expr_to_memcpy): Likewise.\n\t(gimplify_init_ctor_preeval_1): Handle MEM_REF.\n\t(gimple_fold_indirect_ref): Adjust.\n\t(gimplify_expr): Handle MEM_REF.  Gimplify INDIRECT_REF to MEM_REF.\n\t* tree.def (MEM_REF): New tree code.\n\t* tree-dfa.c: Include toplev.h.\n\t(get_ref_base_and_extent): Handle MEM_REF.\n\t(get_addr_base_and_unit_offset): New function.\n\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Handle MEM_REF.\n\t* gimple-fold.c (may_propagate_address_into_dereference): Handle\n\tMEM_REF.\n\t(maybe_fold_offset_to_array_ref): Allow possibly out-of bounds\n\taccesses if the array has just one dimension.  Remove always true\n\tparameter.  Do not require type compatibility here.\n\t(maybe_fold_offset_to_component_ref): Remove.\n\t(maybe_fold_stmt_indirect): Remove.\n\t(maybe_fold_reference): Remove INDIRECT_REF handling.\n\tFold back to non-MEM_REF.\n\t(maybe_fold_offset_to_address): Simplify.  Deal with type\n\tmismatches here.\n\t(maybe_fold_reference): Likewise.\n\t(maybe_fold_stmt_addition): Likewise.  Also handle\n\t&ARRAY + I in addition to &ARRAY[0] + I.\n\t(fold_gimple_assign): Handle ADDR_EXPR of MEM_REFs.\n\t(gimple_get_relevant_ref_binfo): Handle MEM_REF.\n\t* cfgexpand.c (expand_debug_expr): Handle MEM_REF.\n\t* tree-ssa.c (useless_type_conversion_p): Make most pointer\n\tconversions useless.\n\t(warn_uninitialized_var): Handle MEM_REF.\n\t(maybe_rewrite_mem_ref_base): New function.\n\t(execute_update_addresses_taken): Implement re-writing of MEM_REFs\n\tto SSA form.\n\t* tree-inline.c (remap_gimple_op_r): Handle MEM_REF, remove\n\tINDIRECT_REF handling.\n\t(copy_tree_body_r): Handle MEM_REF.\n\t* gimple.c (is_gimple_addressable): Adjust.\n\t(is_gimple_address): Likewise.\n\t(is_gimple_invariant_address): ADDR_EXPRs of MEM_REFs with\n\tinvariant base are invariant.\n\t(is_gimple_min_lval): Adjust.\n\t(is_gimple_mem_ref_addr): New function.\n\t(get_base_address): Handle MEM_REF.\n\t(count_ptr_derefs): Likewise.\n\t(get_base_loadstore): Likewise.\n\t* gimple.h (is_gimple_mem_ref_addr): Declare.\n\t(gimple_call_fndecl): Handle invariant MEM_REF addresses.\n\t* tree-cfg.c (verify_address): New function, split out from ...\n\t(verify_expr): ... here.  Use for verifying ADDR_EXPRs and\n\tthe address operand of MEM_REFs.  Verify MEM_REFs.  Reject\n\tINDIRECT_REFs.\n\t(verify_types_in_gimple_min_lval): Handle MEM_REF.  Disallow\n\tINDIRECT_REF.  Allow conversions.\n\t(verify_types_in_gimple_reference): Verify VIEW_CONVERT_EXPR of\n\ta register does not change its size.\n\t(verify_types_in_gimple_reference): Verify MEM_REF.\n\t(verify_gimple_assign_single): Disallow INDIRECT_REF.\n\tHandle MEM_REF.\n\t* tree-ssa-operands.c (opf_non_addressable, opf_not_non_addressable):\n\tNew.\n\t(mark_address_taken): Handle MEM_REF.\n\t(get_indirect_ref_operands): Pass through opf_not_non_addressable.\n\t(get_asm_expr_operands): Pass opf_not_non_addressable.\n\t(get_expr_operands): Handle opf_[not_]non_addressable.\n\tHandle MEM_REF.  Remove INDIRECT_REF handling.\n\t* tree-vrp.c: (check_array_ref): Handle MEM_REF.\n\t(search_for_addr_array): Likewise.\n\t(check_array_bounds): Likewise.\n\t(vrp_stmt_computes_nonzero): Adjust for MEM_REF.\n\t* tree-ssa-loop-im.c (for_each_index): Handle MEM_REF.\n\t(ref_always_accessed_p): Likewise.\n\t(gen_lsm_tmp_name): Likewise.  Handle ADDR_EXPR.\n\t* tree-complex.c (extract_component): Do not handle INDIRECT_REF.\n\tHandle MEM_REF.\n\t* cgraphbuild.c (mark_load): Properly check for NULL result\n\tfrom get_base_address.\n\t(mark_store): Likewise.\n\t* tree-ssa-loop-niter.c (array_at_struct_end_p): Handle MEM_REF.\n\t* tree-loop-distribution.c (generate_builtin): Exchange INDIRECT_REF\n\thandling for MEM_REF.\n\t* tree-scalar-evolution.c (follow_ssa_edge_expr): Handle\n\t&MEM[ptr + CST] similar to POINTER_PLUS_EXPR.\n\t* builtins.c (stabilize_va_list_loc): Use the function ABI\n\tvalist type if we couldn't canonicalize the argument type.\n\tAlways dereference with the canonical va-list type.\n\t(maybe_emit_free_warning): Handle MEM_REF.\n\t(fold_builtin_memory_op): Simplify and handle MEM_REFs in folding\n\tmemmove to memcpy.\n\t* builtins.c (fold_builtin_memory_op): Use ref-all types\n\tfor all memcpy foldings.\n\t* omp-low.c (build_receiver_ref): Adjust for MEM_REF.\n\t(build_outer_var_ref): Likewise.\n\t(scan_omp_1_op): Likewise.\n\t(lower_rec_input_clauses): Likewise.\n\t(lower_lastprivate_clauses): Likewise.\n\t(lower_reduction_clauses): Likewise.\n\t(lower_copyprivate_clauses): Likewise.\n\t(expand_omp_atomic_pipeline): Likewise.\n\t(expand_omp_atomic_mutex): Likewise.\n\t(create_task_copyfn): Likewise.\n\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Handle MEM_REF.\n\tRemove old union trick.  Initialize constant offsets.\n\t(ao_ref_init_from_vn_reference): Likewise.  Do not handle\n\tINDIRECT_REF.  Init base_alias_set properly.\n\t(vn_reference_lookup_3): Replace INDIRECT_REF handling with\n\tMEM_REF.\n\t(vn_reference_fold_indirect): Adjust for MEM_REFs.\n\t(valueize_refs): Fold MEM_REFs.  Re-evaluate constant offset\n\tfor ARRAY_REFs.\n\t(may_insert): Remove.\n\t(visit_reference_op_load): Do not test may_insert.\n\t(run_scc_vn): Remove parameter, do not fiddle with may_insert.\n\t* tree-ssa-sccvn.h (struct vn_reference_op_struct): Add\n\ta field to store the constant offset this op applies.\n\t(run_scc_vn): Adjust prototype.\n\t* cgraphunit.c (thunk_adjust): Adjust for MEM_REF.\n\t* tree-ssa-ccp.c (ccp_fold): Replace INDIRECT_REF folding with\n\tMEM_REF.  Propagate &foo + CST as &MEM[&foo, CST].  Do not\n\tbother about volatile qualifiers on pointers.\n\t(fold_const_aggregate_ref): Handle MEM_REF, do not handle INDIRECT_REF.\n\t* tree-ssa-loop-ivopts.c\n\t* tree-ssa-loop-ivopts.c (determine_base_object): Adjust\n\tfor MEM_REF.\n\t(strip_offset_1): Likewise.\n\t(find_interesting_uses_address): Replace INDIRECT_REF handling with\n\tMEM_REF handling.\n\t(get_computation_cost_at): Likewise.\n\t* ipa-pure-const.c (check_op): Handle MEM_REF.\n\t* tree-stdarg.c (check_all_va_list_escapes): Adjust for MEM_REF.\n\t* tree-ssa-sink.c (is_hidden_global_store): Handle MEM_REF\n\tand constants.\n\t* ipa-inline.c (likely_eliminated_by_inlining_p): Handle MEM_REF.\n\t* tree-parloops.c (take_address_of): Adjust for MEM_REF.\n\t(eliminate_local_variables_1): Likewise.\n\t(create_call_for_reduction_1): Likewise.\n\t(create_loads_for_reductions): Likewise.\n\t(create_loads_and_stores_for_name): Likewise.\n\t* matrix-reorg.c (may_flatten_matrices_1): Sanitize.\n\t(ssa_accessed_in_tree): Handle MEM_REF.\n\t(ssa_accessed_in_assign_rhs): Likewise.\n\t(update_type_size): Likewise.\n\t(analyze_accesses_for_call_stmt): Likewise.\n\t(analyze_accesses_for_assign_stmt): Likewise.\n\t(transform_access_sites): Likewise.\n\t(transform_allocation_sites): Likewise.\n\t* tree-affine.c (tree_to_aff_combination): Handle MEM_REF.\n\t* tree-vect-data-refs.c (vect_create_addr_base_for_vector_ref): Do\n\tnot handle INDIRECT_REF.\n\t* tree-ssa-phiopt.c (add_or_mark_expr): Handle MEM_REF.\n\t(cond_store_replacement): Likewise.\n\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Handle\n\tMEM_REF, no not handle INDIRECT_REFs.\n\t(insert_into_preds_of_block): Properly initialize avail.\n\t(phi_translate_1): Fold MEM_REFs.  Re-evaluate constant offset\n\tfor ARRAY_REFs.  Properly handle reference lookups that\n\trequire a bit re-interpretation.\n\t(can_PRE_operation): Do not handle INDIRECT_REF.  Handle MEM_REF.\n\t* tree-sra.c\n\t* tree-sra.c (build_access_from_expr_1): Handle MEM_REF.\n\t(build_ref_for_offset_1): Remove.\n\t(build_ref_for_offset): Build MEM_REFs.\n\t(gate_intra_sra): Disable for now.\n\t(sra_ipa_modify_expr): Handle MEM_REF.\n\t(ipa_early_sra_gate): Disable for now.\n\t* tree-sra.c (create_access): Swap INDIRECT_REF handling for\n\tMEM_REF handling.\n\t(disqualify_base_of_expr): Likewise.\n\t(ptr_parm_has_direct_uses): Swap INDIRECT_REF handling for\n\tMEM_REF handling.\n\t(sra_ipa_modify_expr): Remove INDIRECT_REF handling.\n\tUse mem_ref_offset.  Remove bogus folding.\n\t(build_access_from_expr_1): Properly handle MEM_REF for\n\tnon IPA-SRA.\n\t(make_fancy_name_1): Add support for MEM_REF.\n\t* tree-predcom.c (ref_at_iteration): Handle MEM_REFs.\n\t* tree-mudflap.c (mf_xform_derefs_1): Adjust for MEM_REF.\n\t* ipa-prop.c (compute_complex_assign_jump_func): Handle MEM_REF.\n\t(compute_complex_ancestor_jump_func): Likewise.\n\t(ipa_analyze_virtual_call_uses): Likewise.\n\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Replace\n\tINDIRECT_REF folding with more generalized MEM_REF folding.\n\t(tree_ssa_forward_propagate_single_use_vars): Adjust accordingly.\n\t(forward_propagate_addr_into_variable_array_index): Also handle\n\t&ARRAY + I in addition to &ARRAY[0] + I.\n\t* tree-ssa-dce.c (ref_may_be_aliased): Handle MEM_REF.\n\t* tree-ssa-ter.c (find_replaceable_in_bb): Avoid TER if that\n\tcreates assignments with overlap.\n\t* tree-nested.c (get_static_chain): Adjust for MEM_REF.\n\t(get_frame_field): Likewise.\n\t(get_nonlocal_debug_decl): Likewise.\n\t(convert_nonlocal_reference_op): Likewise.\n\t(struct nesting_info): Add mem_refs pointer-set.\n\t(create_nesting_tree): Allocate it.\n\t(convert_local_reference_op): Insert to be folded mem-refs.\n\t(fold_mem_refs): New function.\n\t(finalize_nesting_tree_1): Perform defered folding of mem-refs \n\t(free_nesting_tree): Free the pointer-set.\n\t* tree-vect-stmts.c (vectorizable_store): Adjust for MEM_REF.\n\t(vectorizable_load): Likewise.\n\t* tree-ssa-phiprop.c (phiprop_insert_phi): Adjust for MEM_REF.\n\t(propagate_with_phi): Likewise.\n\t* tree-object-size.c (addr_object_size): Handle MEM_REFs\n\tinstead of INDIRECT_REFs.\n\t(compute_object_offset): Handle MEM_REF.\n\t(plus_stmt_object_size): Handle MEM_REF.\n\t(collect_object_sizes_for): Dispatch to plus_stmt_object_size\n\tfor &MEM_REF.\n\t* tree-flow.h (get_addr_base_and_unit_offset): Declare.\n\t(symbol_marked_for_renaming): Likewise.\n\t* Makefile.in (tree-dfa.o): Add $(TOPLEV_H).\n\t(fold-const.o): Add $(TREE_FLOW_H).\n\t* tree-ssa-structalias.c (get_constraint_for_1): Handle MEM_REF.\n\t(find_func_clobbers): Likewise.\n\t* ipa-struct-reorg.c (decompose_indirect_ref_acc): Handle MEM_REF.\n\t(decompose_access): Likewise.\n\t(replace_field_acc): Likewise.\n\t(replace_field_access_stmt): Likewise.\n\t(insert_new_var_in_stmt): Likewise.\n\t(get_stmt_accesses): Likewise.\n\t(reorg_structs_drive): Disable.\n\t* config/i386/i386.c (ix86_va_start): Adjust for MEM_REF.\n\t(ix86_canonical_va_list_type): Likewise.\n\n\tcp/\n\t* cp-gimplify.c (cp_gimplify_expr): Open-code the rhs\n\tpredicate we are looking for, allow non-gimplified\n\tINDIRECT_REFs.\n\n\ttestsuite/\n\t* gcc.c-torture/execute/20100316-1.c: New testcase.\n\t* gcc.c-torture/execute/pr44468.c: Likewise.\n\t* gcc.c-torture/compile/20100609-1.c: Likewise.\n\t* gcc.dg/volatile2.c: Adjust.\n\t* gcc.dg/plugin/selfassign.c: Likewise.\n\t* gcc.dg/pr36902.c: Likewise.\n\t* gcc.dg/tree-ssa/foldaddr-2.c: Remove.\n\t* gcc.dg/tree-ssa/foldaddr-3.c: Likewise.\n\t* gcc.dg/tree-ssa/forwprop-8.c: Adjust.\n\t* gcc.dg/tree-ssa/pr17141-1.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-fre-13.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-fre-14.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ccp-21.c: Likewise.\n\t* gcc.dg/tree-ssa/pta-ptrarith-1.c: Likewise.\n\t* gcc.dg/tree-ssa/20030807-7.c: Likewise.\n\t* gcc.dg/tree-ssa/forwprop-10.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-fre-1.c: Likewise.\n\t* gcc.dg/tree-ssa/pta-ptrarith-2.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ccp-23.c: Likewise.\n\t* gcc.dg/tree-ssa/forwprop-1.c: Likewise.\n\t* gcc.dg/tree-ssa/forwprop-2.c: Likewise.\n\t* gcc.dg/tree-ssa/struct-aliasing-1.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ccp-25.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-pre-26.c: Likewise.\n\t* gcc.dg/tree-ssa/struct-aliasing-2.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ccp-26.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-sccvn-4.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-pre-7.c: Likewise.\n\t* gcc.dg/tree-ssa/forwprop-5.c: Likewise.\n\t* gcc.dg/struct/w_prof_two_strs.c: XFAIL.\n\t* gcc.dg/struct/wo_prof_escape_arg_to_local.c: Likewise.\n\t* gcc.dg/struct/wo_prof_global_var.c: Likewise.\n\t* gcc.dg/struct/wo_prof_malloc_size_var.c: Likewise.\n\t* gcc.dg/struct/w_prof_local_array.c: Likewise.\n\t* gcc.dg/struct/w_prof_single_str_global.c: Likewise.\n\t* gcc.dg/struct/wo_prof_escape_str_init.c: Likewise.\n\t* gcc.dg/struct/wo_prof_array_through_pointer.c: Likewise.\n\t* gcc.dg/struct/w_prof_global_array.c: Likewise.\n\t* gcc.dg/struct/wo_prof_array_field.c: Likewise.\n\t* gcc.dg/struct/wo_prof_single_str_local.c: Likewise.\n\t* gcc.dg/struct/w_prof_local_var.c: Likewise.\n\t* gcc.dg/struct/wo_prof_two_strs.c: Likewise.\n\t* gcc.dg/struct/wo_prof_empty_str.c: Likewise.\n\t* gcc.dg/struct/wo_prof_local_array.c: Likewise.\n\t* gcc.dg/struct/w_prof_global_var.c: Likewise.\n\t* gcc.dg/struct/wo_prof_single_str_global.c: Likewise.\n\t* gcc.dg/struct/wo_prof_escape_substr_value.c: Likewise.\n\t* gcc.dg/struct/wo_prof_global_array.c: Likewise.\n\t* gcc.dg/struct/wo_prof_escape_return.c: Likewise.\n\t* gcc.dg/struct/wo_prof_escape_substr_array.c: Likewise.\n\t* gcc.dg/struct/wo_prof_double_malloc.c: Likewise.\n\t* gcc.dg/struct/w_ratio_cold_str.c: Likewise.\n\t* gcc.dg/struct/wo_prof_escape_substr_pointer.c: Likewise.\n\t* gcc.dg/struct/wo_prof_local_var.c: Likewise.\n\t* gcc.dg/tree-prof/stringop-1.c: Adjust.\n\t* g++.dg/tree-ssa/pr31146.C: Likewise.\n\t* g++.dg/tree-ssa/copyprop-1.C: Likewise.\n\t* g++.dg/tree-ssa/pr33604.C: Likewise.\n\t* g++.dg/plugin/selfassign.c: Likewise.\n\t* gfortran.dg/array_memcpy_3.f90: Likewise.\n\t* gfortran.dg/array_memcpy_4.f90: Likewise.\n\t* c-c++-common/torture/pr42834.c: New testcase.\n\nFrom-SVN: r161655", "tree": {"sha": "4cc8d9c35ed3127dbf885a1f08a83776819bed41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cc8d9c35ed3127dbf885a1f08a83776819bed41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70f348148c09468b05aa09fcfa91b61611003c27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70f348148c09468b05aa09fcfa91b61611003c27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70f348148c09468b05aa09fcfa91b61611003c27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70f348148c09468b05aa09fcfa91b61611003c27/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "952b984e86f884d08d2e1ae5675ce518381692c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/952b984e86f884d08d2e1ae5675ce518381692c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/952b984e86f884d08d2e1ae5675ce518381692c5"}], "stats": {"total": 4581, "additions": 3112, "deletions": 1469}, "files": [{"sha": "d36c585e27789cfd8d7bf09d928343f78aa71a42", "filename": "gcc/ChangeLog", "status": "modified", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1,3 +1,275 @@\n+2010-07-01  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/42834\n+\tPR middle-end/44468\n+\t* doc/gimple.texi (is_gimple_mem_ref_addr): Document.\n+\t* doc/generic.texi (References to storage): Document MEM_REF.\n+\t* tree-pretty-print.c (dump_generic_node): Handle MEM_REF.\n+\t(print_call_name): Likewise.\n+\t* tree.c (recompute_tree_invariant_for_addr_expr): Handle MEM_REF.\n+\t(build_simple_mem_ref_loc): New function.\n+\t(mem_ref_offset): Likewise.\n+\t* tree.h (build_simple_mem_ref_loc): Declare.\n+\t(build_simple_mem_ref): Define.\n+\t(mem_ref_offset): Declare.\n+\t* fold-const.c: Include tree-flow.h.\n+\t(operand_equal_p): Handle MEM_REF.\n+\t(build_fold_addr_expr_with_type_loc): Likewise.\n+\t(fold_comparison): Likewise.\n+\t(fold_unary_loc): Fold\n+\tVIEW_CONVERT_EXPR <T1, MEM_REF <T2, ...>> to MEM_REF <T1, ...>.\n+\t(fold_binary_loc): Fold MEM[&MEM[p, CST1], CST2] to MEM[p, CST1 + CST2],\n+\tfold MEM[&a.b, CST2] to MEM[&a, offsetof (a, b) + CST2].\n+\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Handle MEM_REF.\n+\t(ptr_deref_may_alias_ref_p_1): Likewise.\n+\t(ao_ref_base_alias_set): Properly differentiate base object for\n+\toffset and TBAA.\n+\t(ao_ref_init_from_ptr_and_size): Use MEM_REF.\n+\t(indirect_ref_may_alias_decl_p): Handle MEM_REFs properly.\n+\t(indirect_refs_may_alias_p): Likewise.\n+\t(refs_may_alias_p_1): Likewise.  Remove pointer SSA name def\n+\tchasing code.\n+\t(ref_maybe_used_by_call_p_1): Handle MEM_REF.\n+\t(call_may_clobber_ref_p_1): Likewise.\n+\t* dwarf2out.c (loc_list_from_tree): Handle MEM_REF.\n+\t* expr.c (expand_assignment): Handle MEM_REF.\n+\t(store_expr): Handle MEM_REFs from STRING_CSTs.\n+\t(store_field): If expanding a MEM_REF of a non-addressable\n+\tdecl use bitfield operations.\n+\t(get_inner_reference): Handle MEM_REF.\n+\t(expand_expr_addr_expr_1): Likewise.\n+\t(expand_expr_real_1): Likewise.\n+\t* tree-eh.c (tree_could_trap_p): Handle MEM_REF.\n+\t* alias.c (ao_ref_from_mem): Handle MEM_REF.\n+\t(get_alias_set): Likewise.  Properly handle VIEW_CONVERT_EXPRs.\n+\t* tree-data-ref.c (dr_analyze_innermost): Handle MEM_REF.\n+\t(dr_analyze_indices): Likewise.\n+\t(dr_analyze_alias): Likewise.\n+\t(object_address_invariant_in_loop_p): Likewise.\n+\t* gimplify.c (mark_addressable): Handle MEM_REF.\n+\t(gimplify_cond_expr): Build MEM_REFs.\n+\t(gimplify_modify_expr_to_memcpy): Likewise.\n+\t(gimplify_init_ctor_preeval_1): Handle MEM_REF.\n+\t(gimple_fold_indirect_ref): Adjust.\n+\t(gimplify_expr): Handle MEM_REF.  Gimplify INDIRECT_REF to MEM_REF.\n+\t* tree.def (MEM_REF): New tree code.\n+\t* tree-dfa.c: Include toplev.h.\n+\t(get_ref_base_and_extent): Handle MEM_REF.\n+\t(get_addr_base_and_unit_offset): New function.\n+\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Handle MEM_REF.\n+\t* gimple-fold.c (may_propagate_address_into_dereference): Handle\n+\tMEM_REF.\n+\t(maybe_fold_offset_to_array_ref): Allow possibly out-of bounds\n+\taccesses if the array has just one dimension.  Remove always true\n+\tparameter.  Do not require type compatibility here.\n+\t(maybe_fold_offset_to_component_ref): Remove.\n+\t(maybe_fold_stmt_indirect): Remove.\n+\t(maybe_fold_reference): Remove INDIRECT_REF handling.\n+\tFold back to non-MEM_REF.\n+\t(maybe_fold_offset_to_address): Simplify.  Deal with type\n+\tmismatches here.\n+\t(maybe_fold_reference): Likewise.\n+\t(maybe_fold_stmt_addition): Likewise.  Also handle\n+\t&ARRAY + I in addition to &ARRAY[0] + I.\n+\t(fold_gimple_assign): Handle ADDR_EXPR of MEM_REFs.\n+\t(gimple_get_relevant_ref_binfo): Handle MEM_REF.\n+\t* cfgexpand.c (expand_debug_expr): Handle MEM_REF.\n+\t* tree-ssa.c (useless_type_conversion_p): Make most pointer\n+\tconversions useless.\n+\t(warn_uninitialized_var): Handle MEM_REF.\n+\t(maybe_rewrite_mem_ref_base): New function.\n+\t(execute_update_addresses_taken): Implement re-writing of MEM_REFs\n+\tto SSA form.\n+\t* tree-inline.c (remap_gimple_op_r): Handle MEM_REF, remove\n+\tINDIRECT_REF handling.\n+\t(copy_tree_body_r): Handle MEM_REF.\n+\t* gimple.c (is_gimple_addressable): Adjust.\n+\t(is_gimple_address): Likewise.\n+\t(is_gimple_invariant_address): ADDR_EXPRs of MEM_REFs with\n+\tinvariant base are invariant.\n+\t(is_gimple_min_lval): Adjust.\n+\t(is_gimple_mem_ref_addr): New function.\n+\t(get_base_address): Handle MEM_REF.\n+\t(count_ptr_derefs): Likewise.\n+\t(get_base_loadstore): Likewise.\n+\t* gimple.h (is_gimple_mem_ref_addr): Declare.\n+\t(gimple_call_fndecl): Handle invariant MEM_REF addresses.\n+\t* tree-cfg.c (verify_address): New function, split out from ...\n+\t(verify_expr): ... here.  Use for verifying ADDR_EXPRs and\n+\tthe address operand of MEM_REFs.  Verify MEM_REFs.  Reject\n+\tINDIRECT_REFs.\n+\t(verify_types_in_gimple_min_lval): Handle MEM_REF.  Disallow\n+\tINDIRECT_REF.  Allow conversions.\n+\t(verify_types_in_gimple_reference): Verify VIEW_CONVERT_EXPR of\n+\ta register does not change its size.\n+\t(verify_types_in_gimple_reference): Verify MEM_REF.\n+\t(verify_gimple_assign_single): Disallow INDIRECT_REF.\n+\tHandle MEM_REF.\n+\t* tree-ssa-operands.c (opf_non_addressable, opf_not_non_addressable):\n+\tNew.\n+\t(mark_address_taken): Handle MEM_REF.\n+\t(get_indirect_ref_operands): Pass through opf_not_non_addressable.\n+\t(get_asm_expr_operands): Pass opf_not_non_addressable.\n+\t(get_expr_operands): Handle opf_[not_]non_addressable.\n+\tHandle MEM_REF.  Remove INDIRECT_REF handling.\n+\t* tree-vrp.c: (check_array_ref): Handle MEM_REF.\n+\t(search_for_addr_array): Likewise.\n+\t(check_array_bounds): Likewise.\n+\t(vrp_stmt_computes_nonzero): Adjust for MEM_REF.\n+\t* tree-ssa-loop-im.c (for_each_index): Handle MEM_REF.\n+\t(ref_always_accessed_p): Likewise.\n+\t(gen_lsm_tmp_name): Likewise.  Handle ADDR_EXPR.\n+\t* tree-complex.c (extract_component): Do not handle INDIRECT_REF.\n+\tHandle MEM_REF.\n+\t* cgraphbuild.c (mark_load): Properly check for NULL result\n+\tfrom get_base_address.\n+\t(mark_store): Likewise.\n+\t* tree-ssa-loop-niter.c (array_at_struct_end_p): Handle MEM_REF.\n+\t* tree-loop-distribution.c (generate_builtin): Exchange INDIRECT_REF\n+\thandling for MEM_REF.\n+\t* tree-scalar-evolution.c (follow_ssa_edge_expr): Handle\n+\t&MEM[ptr + CST] similar to POINTER_PLUS_EXPR.\n+\t* builtins.c (stabilize_va_list_loc): Use the function ABI\n+\tvalist type if we couldn't canonicalize the argument type.\n+\tAlways dereference with the canonical va-list type.\n+\t(maybe_emit_free_warning): Handle MEM_REF.\n+\t(fold_builtin_memory_op): Simplify and handle MEM_REFs in folding\n+\tmemmove to memcpy.\n+\t* builtins.c (fold_builtin_memory_op): Use ref-all types\n+\tfor all memcpy foldings.\n+\t* omp-low.c (build_receiver_ref): Adjust for MEM_REF.\n+\t(build_outer_var_ref): Likewise.\n+\t(scan_omp_1_op): Likewise.\n+\t(lower_rec_input_clauses): Likewise.\n+\t(lower_lastprivate_clauses): Likewise.\n+\t(lower_reduction_clauses): Likewise.\n+\t(lower_copyprivate_clauses): Likewise.\n+\t(expand_omp_atomic_pipeline): Likewise.\n+\t(expand_omp_atomic_mutex): Likewise.\n+\t(create_task_copyfn): Likewise.\n+\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Handle MEM_REF.\n+\tRemove old union trick.  Initialize constant offsets.\n+\t(ao_ref_init_from_vn_reference): Likewise.  Do not handle\n+\tINDIRECT_REF.  Init base_alias_set properly.\n+\t(vn_reference_lookup_3): Replace INDIRECT_REF handling with\n+\tMEM_REF.\n+\t(vn_reference_fold_indirect): Adjust for MEM_REFs.\n+\t(valueize_refs): Fold MEM_REFs.  Re-evaluate constant offset\n+\tfor ARRAY_REFs.\n+\t(may_insert): Remove.\n+\t(visit_reference_op_load): Do not test may_insert.\n+\t(run_scc_vn): Remove parameter, do not fiddle with may_insert.\n+\t* tree-ssa-sccvn.h (struct vn_reference_op_struct): Add\n+\ta field to store the constant offset this op applies.\n+\t(run_scc_vn): Adjust prototype.\n+\t* cgraphunit.c (thunk_adjust): Adjust for MEM_REF.\n+\t* tree-ssa-ccp.c (ccp_fold): Replace INDIRECT_REF folding with\n+\tMEM_REF.  Propagate &foo + CST as &MEM[&foo, CST].  Do not\n+\tbother about volatile qualifiers on pointers.\n+\t(fold_const_aggregate_ref): Handle MEM_REF, do not handle INDIRECT_REF.\n+\t* tree-ssa-loop-ivopts.c\n+\t* tree-ssa-loop-ivopts.c (determine_base_object): Adjust\n+\tfor MEM_REF.\n+\t(strip_offset_1): Likewise.\n+\t(find_interesting_uses_address): Replace INDIRECT_REF handling with\n+\tMEM_REF handling.\n+\t(get_computation_cost_at): Likewise.\n+\t* ipa-pure-const.c (check_op): Handle MEM_REF.\n+\t* tree-stdarg.c (check_all_va_list_escapes): Adjust for MEM_REF.\n+\t* tree-ssa-sink.c (is_hidden_global_store): Handle MEM_REF\n+\tand constants.\n+\t* ipa-inline.c (likely_eliminated_by_inlining_p): Handle MEM_REF.\n+\t* tree-parloops.c (take_address_of): Adjust for MEM_REF.\n+\t(eliminate_local_variables_1): Likewise.\n+\t(create_call_for_reduction_1): Likewise.\n+\t(create_loads_for_reductions): Likewise.\n+\t(create_loads_and_stores_for_name): Likewise.\n+\t* matrix-reorg.c (may_flatten_matrices_1): Sanitize.\n+\t(ssa_accessed_in_tree): Handle MEM_REF.\n+\t(ssa_accessed_in_assign_rhs): Likewise.\n+\t(update_type_size): Likewise.\n+\t(analyze_accesses_for_call_stmt): Likewise.\n+\t(analyze_accesses_for_assign_stmt): Likewise.\n+\t(transform_access_sites): Likewise.\n+\t(transform_allocation_sites): Likewise.\n+\t* tree-affine.c (tree_to_aff_combination): Handle MEM_REF.\n+\t* tree-vect-data-refs.c (vect_create_addr_base_for_vector_ref): Do\n+\tnot handle INDIRECT_REF.\n+\t* tree-ssa-phiopt.c (add_or_mark_expr): Handle MEM_REF.\n+\t(cond_store_replacement): Likewise.\n+\t* tree-ssa-pre.c (create_component_ref_by_pieces_1): Handle\n+\tMEM_REF, no not handle INDIRECT_REFs.\n+\t(insert_into_preds_of_block): Properly initialize avail.\n+\t(phi_translate_1): Fold MEM_REFs.  Re-evaluate constant offset\n+\tfor ARRAY_REFs.  Properly handle reference lookups that\n+\trequire a bit re-interpretation.\n+\t(can_PRE_operation): Do not handle INDIRECT_REF.  Handle MEM_REF.\n+\t* tree-sra.c\n+\t* tree-sra.c (build_access_from_expr_1): Handle MEM_REF.\n+\t(build_ref_for_offset_1): Remove.\n+\t(build_ref_for_offset): Build MEM_REFs.\n+\t(gate_intra_sra): Disable for now.\n+\t(sra_ipa_modify_expr): Handle MEM_REF.\n+\t(ipa_early_sra_gate): Disable for now.\n+\t* tree-sra.c (create_access): Swap INDIRECT_REF handling for\n+\tMEM_REF handling.\n+\t(disqualify_base_of_expr): Likewise.\n+\t(ptr_parm_has_direct_uses): Swap INDIRECT_REF handling for\n+\tMEM_REF handling.\n+\t(sra_ipa_modify_expr): Remove INDIRECT_REF handling.\n+\tUse mem_ref_offset.  Remove bogus folding.\n+\t(build_access_from_expr_1): Properly handle MEM_REF for\n+\tnon IPA-SRA.\n+\t(make_fancy_name_1): Add support for MEM_REF.\n+\t* tree-predcom.c (ref_at_iteration): Handle MEM_REFs.\n+\t* tree-mudflap.c (mf_xform_derefs_1): Adjust for MEM_REF.\n+\t* ipa-prop.c (compute_complex_assign_jump_func): Handle MEM_REF.\n+\t(compute_complex_ancestor_jump_func): Likewise.\n+\t(ipa_analyze_virtual_call_uses): Likewise.\n+\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Replace\n+\tINDIRECT_REF folding with more generalized MEM_REF folding.\n+\t(tree_ssa_forward_propagate_single_use_vars): Adjust accordingly.\n+\t(forward_propagate_addr_into_variable_array_index): Also handle\n+\t&ARRAY + I in addition to &ARRAY[0] + I.\n+\t* tree-ssa-dce.c (ref_may_be_aliased): Handle MEM_REF.\n+\t* tree-ssa-ter.c (find_replaceable_in_bb): Avoid TER if that\n+\tcreates assignments with overlap.\n+\t* tree-nested.c (get_static_chain): Adjust for MEM_REF.\n+\t(get_frame_field): Likewise.\n+\t(get_nonlocal_debug_decl): Likewise.\n+\t(convert_nonlocal_reference_op): Likewise.\n+\t(struct nesting_info): Add mem_refs pointer-set.\n+\t(create_nesting_tree): Allocate it.\n+\t(convert_local_reference_op): Insert to be folded mem-refs.\n+\t(fold_mem_refs): New function.\n+\t(finalize_nesting_tree_1): Perform defered folding of mem-refs \n+\t(free_nesting_tree): Free the pointer-set.\n+\t* tree-vect-stmts.c (vectorizable_store): Adjust for MEM_REF.\n+\t(vectorizable_load): Likewise.\n+\t* tree-ssa-phiprop.c (phiprop_insert_phi): Adjust for MEM_REF.\n+\t(propagate_with_phi): Likewise.\n+\t* tree-object-size.c (addr_object_size): Handle MEM_REFs\n+\tinstead of INDIRECT_REFs.\n+\t(compute_object_offset): Handle MEM_REF.\n+\t(plus_stmt_object_size): Handle MEM_REF.\n+\t(collect_object_sizes_for): Dispatch to plus_stmt_object_size\n+\tfor &MEM_REF.\n+\t* tree-flow.h (get_addr_base_and_unit_offset): Declare.\n+\t(symbol_marked_for_renaming): Likewise.\n+\t* Makefile.in (tree-dfa.o): Add $(TOPLEV_H).\n+\t(fold-const.o): Add $(TREE_FLOW_H).\n+\t* tree-ssa-structalias.c (get_constraint_for_1): Handle MEM_REF.\n+\t(find_func_clobbers): Likewise.\n+\t* ipa-struct-reorg.c (decompose_indirect_ref_acc): Handle MEM_REF.\n+\t(decompose_access): Likewise.\n+\t(replace_field_acc): Likewise.\n+\t(replace_field_access_stmt): Likewise.\n+\t(insert_new_var_in_stmt): Likewise.\n+\t(get_stmt_accesses): Likewise.\n+\t(reorg_structs_drive): Disable.\n+\t* config/i386/i386.c (ix86_va_start): Adjust for MEM_REF.\n+\t(ix86_canonical_va_list_type): Likewise.\n+\n 2010-06-30  Joern Rennecke  <joern.rennecke@embecosm.com>\n \n \tPR other/44566"}, {"sha": "d717332b3287ef7e6eacd3d4334a6e54d81252fc", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -2510,7 +2510,7 @@ tree-dfa.o : tree-dfa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_INLINE_H) $(HASHTAB_H) pointer-set.h $(FLAGS_H) $(FUNCTION_H) \\\n    $(TIMEVAR_H) convert.h $(TM_H) coretypes.h langhooks.h $(TREE_DUMP_H) \\\n    $(TREE_PASS_H) $(PARAMS_H) $(CGRAPH_H) $(BASIC_BLOCK_H) $(GIMPLE_H) \\\n-   tree-pretty-print.h\n+   tree-pretty-print.h $(TOPLEV_H)\n tree-ssa-operands.o : tree-ssa-operands.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) $(TREE_INLINE_H) \\\n    $(FLAGS_H) $(FUNCTION_H) $(TM_H) $(TIMEVAR_H) $(TREE_PASS_H) $(TOPLEV_H) \\\n@@ -2789,7 +2789,7 @@ tree-diagnostic.o : tree-diagnostic.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(FLAGS_H) $(TOPLEV_H) $(HASHTAB_H) $(EXPR_H) $(RTL_H) \\\n    $(GGC_H) $(TM_P_H) langhooks.h $(MD5_H) intl.h $(TARGET_H) \\\n-   $(GIMPLE_H) realmpfr.h\n+   $(GIMPLE_H) realmpfr.h $(TREE_FLOW_H)\n diagnostic.o : diagnostic.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    version.h $(INPUT_H) intl.h $(DIAGNOSTIC_H) diagnostic.def\n opts.o : opts.c opts.h options.h $(TOPLEV_H) $(CONFIG_H) $(SYSTEM_H) \\"}, {"sha": "30717127be235356f43e76914880ed6cbee895dc", "filename": "gcc/alias.c", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -279,7 +279,8 @@ ao_ref_from_mem (ao_ref *ref, const_rtx mem)\n \n   /* If this is a pointer dereference of a non-SSA_NAME punt.\n      ???  We could replace it with a pointer to anything.  */\n-  if (INDIRECT_REF_P (base)\n+  if ((INDIRECT_REF_P (base)\n+       || TREE_CODE (base) == MEM_REF)\n       && TREE_CODE (TREE_OPERAND (base, 0)) != SSA_NAME)\n     return false;\n \n@@ -293,10 +294,7 @@ ao_ref_from_mem (ao_ref *ref, const_rtx mem)\n       void *namep;\n       namep = pointer_map_contains (cfun->gimple_df->decls_to_pointers, base);\n       if (namep)\n-\t{\n-\t  ref->base_alias_set = get_alias_set (base);\n-\t  ref->base = build1 (INDIRECT_REF, TREE_TYPE (base), *(tree *)namep);\n-\t}\n+\tref->base = build_simple_mem_ref (*(tree *)namep);\n     }\n \n   ref->ref_alias_set = MEM_ALIAS_SET (mem);\n@@ -648,8 +646,8 @@ get_alias_set (tree t)\n     {\n       tree inner;\n \n-      /* Remove any nops, then give the language a chance to do\n-\t something with this tree before we look at it.  */\n+      /* Give the language a chance to do something with this tree\n+\t before we look at it.  */\n       STRIP_NOPS (t);\n       set = lang_hooks.get_alias_set (t);\n       if (set != -1)\n@@ -659,21 +657,41 @@ get_alias_set (tree t)\n       if (TREE_CODE (t) == TARGET_MEM_REF)\n \tt = TMR_ORIGINAL (t);\n \n-      /* First see if the actual object referenced is an INDIRECT_REF from a\n-\t restrict-qualified pointer or a \"void *\".  */\n+      /* Get the base object of the reference.  */\n       inner = t;\n       while (handled_component_p (inner))\n \t{\n+\t  /* If there is a VIEW_CONVERT_EXPR in the chain we cannot use\n+\t     the type of any component references that wrap it to\n+\t     determine the alias-set.  */\n+\t  if (TREE_CODE (inner) == VIEW_CONVERT_EXPR)\n+\t    t = TREE_OPERAND (inner, 0);\n \t  inner = TREE_OPERAND (inner, 0);\n-\t  STRIP_NOPS (inner);\n \t}\n \n+      /* Handle pointer dereferences here, they can override the\n+\t alias-set.  */\n       if (INDIRECT_REF_P (inner))\n \t{\n \t  set = get_deref_alias_set_1 (TREE_OPERAND (inner, 0));\n \t  if (set != -1)\n \t    return set;\n \t}\n+      else if (TREE_CODE (inner) == MEM_REF)\n+\t{\n+\t  set = get_deref_alias_set_1 (TREE_OPERAND (inner, 1));\n+\t  if (set != -1)\n+\t    return set;\n+\t}\n+\n+      /* If the innermost reference is a MEM_REF that has a\n+\t conversion embedded treat it like a VIEW_CONVERT_EXPR above,\n+\t using the memory access type for determining the alias-set.  */\n+     if (TREE_CODE (inner) == MEM_REF\n+\t && (TYPE_MAIN_VARIANT (TREE_TYPE (inner))\n+\t     != TYPE_MAIN_VARIANT\n+\t          (TREE_TYPE (TREE_TYPE (TREE_OPERAND (inner, 1))))))\n+       return get_deref_alias_set (TREE_OPERAND (inner, 1));\n \n       /* Otherwise, pick up the outermost object that we could have a pointer\n \t to, processing conversions as above.  */"}, {"sha": "ddbbd79dbe2be02e39edf51c88943269e6840666", "filename": "gcc/builtins.c", "status": "modified", "additions": 68, "deletions": 116, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -4455,7 +4455,10 @@ stabilize_va_list_loc (location_t loc, tree valist, int needs_lvalue)\n {\n   tree vatype = targetm.canonical_va_list_type (TREE_TYPE (valist));\n \n-  gcc_assert (vatype != NULL_TREE);\n+  /* The current way of determining the type of valist is completely\n+     bogus.  We should have the information on the va builtin instead.  */\n+  if (!vatype)\n+    vatype = targetm.fn_abi_va_list (cfun->decl);\n \n   if (TREE_CODE (vatype) == ARRAY_TYPE)\n     {\n@@ -4474,21 +4477,21 @@ stabilize_va_list_loc (location_t loc, tree valist, int needs_lvalue)\n     }\n   else\n     {\n-      tree pt;\n+      tree pt = build_pointer_type (vatype);\n \n       if (! needs_lvalue)\n \t{\n \t  if (! TREE_SIDE_EFFECTS (valist))\n \t    return valist;\n \n-\t  pt = build_pointer_type (vatype);\n \t  valist = fold_build1_loc (loc, ADDR_EXPR, pt, valist);\n \t  TREE_SIDE_EFFECTS (valist) = 1;\n \t}\n \n       if (TREE_SIDE_EFFECTS (valist))\n \tvalist = save_expr (valist);\n-      valist = build_fold_indirect_ref_loc (loc, valist);\n+      valist = fold_build2_loc (loc, MEM_REF,\n+\t\t\t\tvatype, valist, build_int_cst (pt, 0));\n     }\n \n   return valist;\n@@ -8346,6 +8349,7 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n     {\n       tree srctype, desttype;\n       int src_align, dest_align;\n+      tree off0;\n \n       if (endp == 3)\n \t{\n@@ -8371,37 +8375,26 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n \t    }\n \n \t  /* If *src and *dest can't overlap, optimize into memcpy as well.  */\n-\t  srcvar = build_fold_indirect_ref_loc (loc, src);\n-\t  destvar = build_fold_indirect_ref_loc (loc, dest);\n-\t  if (srcvar\n-\t      && !TREE_THIS_VOLATILE (srcvar)\n-\t      && destvar\n-\t      && !TREE_THIS_VOLATILE (destvar))\n+\t  if (TREE_CODE (src) == ADDR_EXPR\n+\t      && TREE_CODE (dest) == ADDR_EXPR)\n \t    {\n \t      tree src_base, dest_base, fn;\n \t      HOST_WIDE_INT src_offset = 0, dest_offset = 0;\n \t      HOST_WIDE_INT size = -1;\n \t      HOST_WIDE_INT maxsize = -1;\n \n-\t      src_base = srcvar;\n-\t      if (handled_component_p (src_base))\n-\t\tsrc_base = get_ref_base_and_extent (src_base, &src_offset,\n-\t\t\t\t\t\t    &size, &maxsize);\n-\t      dest_base = destvar;\n-\t      if (handled_component_p (dest_base))\n-\t\tdest_base = get_ref_base_and_extent (dest_base, &dest_offset,\n-\t\t\t\t\t\t     &size, &maxsize);\n+\t      srcvar = TREE_OPERAND (src, 0);\n+\t      src_base = get_ref_base_and_extent (srcvar, &src_offset,\n+\t\t\t\t\t\t  &size, &maxsize);\n+\t      destvar = TREE_OPERAND (dest, 0);\n+\t      dest_base = get_ref_base_and_extent (destvar, &dest_offset,\n+\t\t\t\t\t\t   &size, &maxsize);\n \t      if (host_integerp (len, 1))\n-\t\t{\n-\t\t  maxsize = tree_low_cst (len, 1);\n-\t\t  if (maxsize\n-\t\t      > INTTYPE_MAXIMUM (HOST_WIDE_INT) / BITS_PER_UNIT)\n-\t\t    maxsize = -1;\n-\t\t  else\n-\t\t    maxsize *= BITS_PER_UNIT;\n-\t\t}\n+\t\tmaxsize = tree_low_cst (len, 1);\n \t      else\n \t\tmaxsize = -1;\n+\t      src_offset /= BITS_PER_UNIT;\n+\t      dest_offset /= BITS_PER_UNIT;\n \t      if (SSA_VAR_P (src_base)\n \t\t  && SSA_VAR_P (dest_base))\n \t\t{\n@@ -8410,13 +8403,25 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n \t\t\t\t\t   dest_offset, maxsize))\n \t\t    return NULL_TREE;\n \t\t}\n-\t      else if (TREE_CODE (src_base) == INDIRECT_REF\n-\t\t       && TREE_CODE (dest_base) == INDIRECT_REF)\n+\t      else if (TREE_CODE (src_base) == MEM_REF\n+\t\t       && TREE_CODE (dest_base) == MEM_REF)\n \t\t{\n+\t\t  double_int off;\n \t\t  if (! operand_equal_p (TREE_OPERAND (src_base, 0),\n-\t\t\t\t\t TREE_OPERAND (dest_base, 0), 0)\n-\t\t      || ranges_overlap_p (src_offset, maxsize,\n-\t\t\t\t\t   dest_offset, maxsize))\n+\t\t\t\t\t TREE_OPERAND (dest_base, 0), 0))\n+\t\t    return NULL_TREE;\n+\t\t  off = double_int_add (mem_ref_offset (src_base),\n+\t\t\t\t\tshwi_to_double_int (src_offset));\n+\t\t  if (!double_int_fits_in_shwi_p (off))\n+\t\t    return NULL_TREE;\n+\t\t  src_offset = off.low;\n+\t\t  off = double_int_add (mem_ref_offset (dest_base),\n+\t\t\t\t\tshwi_to_double_int (dest_offset));\n+\t\t  if (!double_int_fits_in_shwi_p (off))\n+\t\t    return NULL_TREE;\n+\t\t  dest_offset = off.low;\n+\t\t  if (ranges_overlap_p (src_offset, maxsize,\n+\t\t\t\t\tdest_offset, maxsize))\n \t\t    return NULL_TREE;\n \t\t}\n \t      else\n@@ -8472,12 +8477,12 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n \t  dest = build1 (NOP_EXPR, build_pointer_type (desttype), dest);\n \t}\n       if (!srctype || !desttype\n+\t  || TREE_ADDRESSABLE (srctype)\n+\t  || TREE_ADDRESSABLE (desttype)\n \t  || !TYPE_SIZE_UNIT (srctype)\n \t  || !TYPE_SIZE_UNIT (desttype)\n \t  || TREE_CODE (TYPE_SIZE_UNIT (srctype)) != INTEGER_CST\n-\t  || TREE_CODE (TYPE_SIZE_UNIT (desttype)) != INTEGER_CST\n-\t  || TYPE_VOLATILE (srctype)\n-\t  || TYPE_VOLATILE (desttype))\n+\t  || TREE_CODE (TYPE_SIZE_UNIT (desttype)) != INTEGER_CST)\n \treturn NULL_TREE;\n \n       src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n@@ -8489,97 +8494,44 @@ fold_builtin_memory_op (location_t loc, tree dest, tree src,\n       if (!ignore)\n         dest = builtin_save_expr (dest);\n \n-      srcvar = NULL_TREE;\n-      if (tree_int_cst_equal (TYPE_SIZE_UNIT (srctype), len))\n-\t{\n-\t  srcvar = build_fold_indirect_ref_loc (loc, src);\n-\t  if (TREE_THIS_VOLATILE (srcvar))\n-\t    return NULL_TREE;\n-\t  else if (!tree_int_cst_equal (tree_expr_size (srcvar), len))\n-\t    srcvar = NULL_TREE;\n-\t  /* With memcpy, it is possible to bypass aliasing rules, so without\n-\t     this check i.e. execute/20060930-2.c would be misoptimized,\n-\t     because it use conflicting alias set to hold argument for the\n-\t     memcpy call.  This check is probably unnecessary with\n-\t     -fno-strict-aliasing.  Similarly for destvar.  See also\n-\t     PR29286.  */\n-\t  else if (!var_decl_component_p (srcvar))\n-\t    srcvar = NULL_TREE;\n-\t}\n-\n-      destvar = NULL_TREE;\n-      if (tree_int_cst_equal (TYPE_SIZE_UNIT (desttype), len))\n-\t{\n-\t  destvar = build_fold_indirect_ref_loc (loc, dest);\n-\t  if (TREE_THIS_VOLATILE (destvar))\n-\t    return NULL_TREE;\n-\t  else if (!tree_int_cst_equal (tree_expr_size (destvar), len))\n-\t    destvar = NULL_TREE;\n-\t  else if (!var_decl_component_p (destvar))\n-\t    destvar = NULL_TREE;\n-\t}\n+      /* Build accesses at offset zero with a ref-all character type.  */\n+      off0 = build_int_cst (build_pointer_type_for_mode (char_type_node,\n+\t\t\t\t\t\t\t ptr_mode, true), 0);\n+\n+      destvar = dest;\n+      STRIP_NOPS (destvar);\n+      if (TREE_CODE (destvar) == ADDR_EXPR\n+\t  && var_decl_component_p (TREE_OPERAND (destvar, 0))\n+\t  && tree_int_cst_equal (TYPE_SIZE_UNIT (desttype), len))\n+\tdestvar = fold_build2 (MEM_REF, desttype, destvar, off0);\n+      else\n+\tdestvar = NULL_TREE;\n+\n+      srcvar = src;\n+      STRIP_NOPS (srcvar);\n+      if (TREE_CODE (srcvar) == ADDR_EXPR\n+\t  && var_decl_component_p (TREE_OPERAND (srcvar, 0))\n+\t  && tree_int_cst_equal (TYPE_SIZE_UNIT (srctype), len))\n+\tsrcvar = fold_build2 (MEM_REF, destvar ? desttype : srctype,\n+\t\t\t      srcvar, off0);\n+      else\n+\tsrcvar = NULL_TREE;\n \n       if (srcvar == NULL_TREE && destvar == NULL_TREE)\n \treturn NULL_TREE;\n \n       if (srcvar == NULL_TREE)\n \t{\n-\t  tree srcptype;\n-\t  if (TREE_ADDRESSABLE (TREE_TYPE (destvar)))\n-\t    return NULL_TREE;\n-\n-\t  srctype = build_qualified_type (desttype, 0);\n-\t  if (src_align < (int) TYPE_ALIGN (srctype))\n-\t    {\n-\t      if (AGGREGATE_TYPE_P (srctype)\n-\t\t  || SLOW_UNALIGNED_ACCESS (TYPE_MODE (srctype), src_align))\n-\t\treturn NULL_TREE;\n-\n-\t      srctype = build_variant_type_copy (srctype);\n-\t      TYPE_ALIGN (srctype) = src_align;\n-\t      TYPE_USER_ALIGN (srctype) = 1;\n-\t      TYPE_PACKED (srctype) = 1;\n-\t    }\n-\t  srcptype = build_pointer_type_for_mode (srctype, ptr_mode, true);\n-\t  src = fold_convert_loc (loc, srcptype, src);\n-\t  srcvar = build_fold_indirect_ref_loc (loc, src);\n+\t  STRIP_NOPS (src);\n+\t  srcvar = fold_build2 (MEM_REF, desttype, src, off0);\n \t}\n       else if (destvar == NULL_TREE)\n \t{\n-\t  tree destptype;\n-\t  if (TREE_ADDRESSABLE (TREE_TYPE (srcvar)))\n-\t    return NULL_TREE;\n-\n-\t  desttype = build_qualified_type (srctype, 0);\n-\t  if (dest_align < (int) TYPE_ALIGN (desttype))\n-\t    {\n-\t      if (AGGREGATE_TYPE_P (desttype)\n-\t\t  || SLOW_UNALIGNED_ACCESS (TYPE_MODE (desttype), dest_align))\n-\t\treturn NULL_TREE;\n+\t  STRIP_NOPS (dest);\n+\t  destvar = fold_build2 (MEM_REF, srctype, dest, off0);\n+\t}\n \n-\t      desttype = build_variant_type_copy (desttype);\n-\t      TYPE_ALIGN (desttype) = dest_align;\n-\t      TYPE_USER_ALIGN (desttype) = 1;\n-\t      TYPE_PACKED (desttype) = 1;\n-\t    }\n-\t  destptype = build_pointer_type_for_mode (desttype, ptr_mode, true);\n-\t  dest = fold_convert_loc (loc, destptype, dest);\n-\t  destvar = build_fold_indirect_ref_loc (loc, dest);\n-\t}\n-\n-      if (srctype == desttype\n-\t  || (gimple_in_ssa_p (cfun)\n-\t      && useless_type_conversion_p (desttype, srctype)))\n-\texpr = srcvar;\n-      else if ((INTEGRAL_TYPE_P (TREE_TYPE (srcvar))\n-\t   || POINTER_TYPE_P (TREE_TYPE (srcvar)))\n-\t  && (INTEGRAL_TYPE_P (TREE_TYPE (destvar))\n-\t      || POINTER_TYPE_P (TREE_TYPE (destvar))))\n-\texpr = fold_convert_loc (loc, TREE_TYPE (destvar), srcvar);\n-      else\n-\texpr = fold_build1_loc (loc, VIEW_CONVERT_EXPR,\n-\t\t\t    TREE_TYPE (destvar), srcvar);\n-      expr = build2 (MODIFY_EXPR, TREE_TYPE (destvar), destvar, expr);\n+      expr = build2 (MODIFY_EXPR, TREE_TYPE (destvar), destvar, srcvar);\n     }\n \n   if (ignore)\n@@ -12068,7 +12020,7 @@ maybe_emit_free_warning (tree exp)\n     return;\n \n   arg = get_base_address (TREE_OPERAND (arg, 0));\n-  if (arg == NULL || INDIRECT_REF_P (arg))\n+  if (arg == NULL || INDIRECT_REF_P (arg) || TREE_CODE (arg) == MEM_REF)\n     return;\n \n   if (SSA_VAR_P (arg))"}, {"sha": "a76aeb23b3b24d4657613e2ee4deb7943bb14632", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -2438,6 +2438,11 @@ expand_debug_expr (tree exp)\n \treturn op0;\n       }\n \n+    case MEM_REF:\n+      /* ??? FIXME.  */\n+      if (!integer_zerop (TREE_OPERAND (exp, 1)))\n+\treturn NULL;\n+      /* Fallthru.  */\n     case INDIRECT_REF:\n     case ALIGN_INDIRECT_REF:\n     case MISALIGNED_INDIRECT_REF:"}, {"sha": "9dcb862316729760e36c15e16c5ea2edc40b5ed8", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -275,7 +275,7 @@ mark_load (gimple stmt ATTRIBUTE_UNUSED, tree t,\n \t   void *data ATTRIBUTE_UNUSED)\n {\n   t = get_base_address (t);\n-  if (TREE_CODE (t) == VAR_DECL\n+  if (t && TREE_CODE (t) == VAR_DECL\n       && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n       struct varpool_node *vnode = varpool_node (t);\n@@ -300,7 +300,7 @@ mark_store (gimple stmt ATTRIBUTE_UNUSED, tree t,\n \t    void *data ATTRIBUTE_UNUSED)\n {\n   t = get_base_address (t);\n-  if (TREE_CODE (t) == VAR_DECL\n+  if (t && TREE_CODE (t) == VAR_DECL\n       && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n       struct varpool_node *vnode = varpool_node (t);"}, {"sha": "5a69afa5286f7f2a891aaf87725cd517fa93addf", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1364,8 +1364,7 @@ thunk_adjust (gimple_stmt_iterator * bsi,\n       vtabletmp2 = create_tmp_var (TREE_TYPE (TREE_TYPE (vtabletmp)),\n \t\t\t\t   \"vtableaddr\");\n       stmt = gimple_build_assign (vtabletmp2,\n-\t\t\t\t  build1 (INDIRECT_REF,\n-\t\t\t\t\t  TREE_TYPE (vtabletmp2), vtabletmp));\n+\t\t\t\t  build_simple_mem_ref (vtabletmp));\n       gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n       mark_symbols_for_renaming (stmt);\n       find_referenced_vars_in (stmt);\n@@ -1384,9 +1383,7 @@ thunk_adjust (gimple_stmt_iterator * bsi,\n       vtabletmp3 = create_tmp_var (TREE_TYPE (TREE_TYPE (vtabletmp2)),\n \t\t\t\t   \"vcalloffset\");\n       stmt = gimple_build_assign (vtabletmp3,\n-\t\t\t\t  build1 (INDIRECT_REF,\n-\t\t\t\t\t  TREE_TYPE (vtabletmp3),\n-\t\t\t\t\t  vtabletmp2));\n+\t\t\t\t  build_simple_mem_ref (vtabletmp2));\n       gsi_insert_after (bsi, stmt, GSI_NEW_STMT);\n       mark_symbols_for_renaming (stmt);\n       find_referenced_vars_in (stmt);"}, {"sha": "a67097a3c2cc04b95edf2bfdc2f05c9df0f2de5c", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -6025,7 +6025,7 @@ alpha_stdarg_optimize_hook (struct stdarg_info *si, const_gimple stmt)\n   rhs = gimple_assign_rhs1 (stmt);\n   while (handled_component_p (rhs))\n     rhs = TREE_OPERAND (rhs, 0);\n-  if (TREE_CODE (rhs) != INDIRECT_REF\n+  if (TREE_CODE (rhs) != MEM_REF\n       || TREE_CODE (TREE_OPERAND (rhs, 0)) != SSA_NAME)\n     return false;\n "}, {"sha": "ec2cdd38d83896624bcf280154330c8eb8febc17", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -7093,11 +7093,17 @@ ix86_va_start (tree valist, rtx nextarg)\n   f_ovf = TREE_CHAIN (f_fpr);\n   f_sav = TREE_CHAIN (f_ovf);\n \n-  valist = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (valist)), valist);\n-  gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr, NULL_TREE);\n-  fpr = build3 (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr, NULL_TREE);\n-  ovf = build3 (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf, NULL_TREE);\n-  sav = build3 (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav, NULL_TREE);\n+  valist = build_simple_mem_ref (valist);\n+  TREE_TYPE (valist) = TREE_TYPE (sysv_va_list_type_node);\n+  /* The following should be folded into the MEM_REF offset.  */\n+  gpr = build3 (COMPONENT_REF, TREE_TYPE (f_gpr), unshare_expr (valist),\n+\t\tf_gpr, NULL_TREE);\n+  fpr = build3 (COMPONENT_REF, TREE_TYPE (f_fpr), unshare_expr (valist),\n+\t\tf_fpr, NULL_TREE);\n+  ovf = build3 (COMPONENT_REF, TREE_TYPE (f_ovf), unshare_expr (valist),\n+\t\tf_ovf, NULL_TREE);\n+  sav = build3 (COMPONENT_REF, TREE_TYPE (f_sav), unshare_expr (valist),\n+\t\tf_sav, NULL_TREE);\n \n   /* Count number of gp and fp argument registers used.  */\n   words = crtl->args.info.words;\n@@ -30619,10 +30625,12 @@ ix86_canonical_va_list_type (tree type)\n   tree wtype, htype;\n \n   /* Resolve references and pointers to va_list type.  */\n-  if (INDIRECT_REF_P (type))\n+  if (TREE_CODE (type) == MEM_REF)\n     type = TREE_TYPE (type);\n   else if (POINTER_TYPE_P (type) && POINTER_TYPE_P (TREE_TYPE(type)))\n     type = TREE_TYPE (type);\n+  else if (POINTER_TYPE_P (type) && TREE_CODE (TREE_TYPE (type)) == ARRAY_TYPE)\n+    type = TREE_TYPE (type);\n \n   if (TARGET_64BIT)\n     {"}, {"sha": "36187c95cd5085139529c6508d08e864c6b72166", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -13682,7 +13682,7 @@ rs6000_check_sdmode (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n     case RESULT_DECL:\n     case SSA_NAME:\n     case REAL_CST:\n-    case INDIRECT_REF:\n+    case MEM_REF:\n     case ALIGN_INDIRECT_REF:\n     case MISALIGNED_INDIRECT_REF:\n     case VIEW_CONVERT_EXPR:"}, {"sha": "b8d2be17c36bc059c45b673d207e6a6a3db6da8c", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -7886,7 +7886,7 @@ sh_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n       lab_false = create_artificial_label (UNKNOWN_LOCATION);\n       lab_over = create_artificial_label (UNKNOWN_LOCATION);\n \n-      valist = build1 (INDIRECT_REF, ptr_type_node, addr);\n+      valist = build_simple_mem_ref (addr);\n \n       if (pass_as_float)\n \t{"}, {"sha": "4b7f9162395bf4f069327995d57c1c7f2b558973", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -4171,7 +4171,7 @@ spu_gimplify_va_arg_expr (tree valist, tree type, gimple_seq * pre_p,\n   f_args = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n   f_skip = TREE_CHAIN (f_args);\n \n-  valist = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (valist)), valist);\n+  valist = build_simple_mem_ref (valist);\n   args =\n     build3 (COMPONENT_REF, TREE_TYPE (f_args), valist, f_args, NULL_TREE);\n   skip ="}, {"sha": "27e7f7a5ff3d44a78e5b6f96da812aa963914176", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1,3 +1,9 @@\n+2010-07-01  Richard Guenther  <rguenther@suse.de>\n+\n+\t* cp-gimplify.c (cp_gimplify_expr): Open-code the rhs\n+\tpredicate we are looking for, allow non-gimplified\n+\tINDIRECT_REFs.\n+\n 2010-06-30  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/44628"}, {"sha": "fa897bfa2b89f7c89c66ad84f967797dbd3cf60d", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -575,7 +575,7 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t  TREE_OPERAND (*expr_p, 1) = build1 (VIEW_CONVERT_EXPR,\n \t\t\t\t\t      TREE_TYPE (op0), op1);\n \n-\telse if ((rhs_predicate_for (op0)) (op1)\n+\telse if ((is_gimple_lvalue (op1) || INDIRECT_REF_P (op1))\n \t\t && !(TREE_CODE (op1) == CALL_EXPR\n \t\t      && CALL_EXPR_RETURN_SLOT_OPT (op1))\n \t\t && is_really_empty_class (TREE_TYPE (op0)))"}, {"sha": "7b3be30dc6a8328d31a2088954f4836cc9ebf21f", "filename": "gcc/doc/generic.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fdoc%2Fgeneric.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fdoc%2Fgeneric.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgeneric.texi?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1116,6 +1116,7 @@ target system bytes are not the same width as host system bytes.\n @subsection References to storage\n @tindex ADDR_EXPR\n @tindex INDIRECT_REF\n+@tindex MEM_REF\n @tindex ARRAY_REF\n @tindex ARRAY_RANGE_REF\n @tindex TARGET_MEM_REF\n@@ -1176,6 +1177,13 @@ These nodes are used to represent the object pointed to by a pointer.\n The operand is the pointer being dereferenced; it will always have\n pointer or reference type.\n \n+@item MEM_REF\n+These nodes are used to represent the object pointed to by a pointer\n+offset by a constant.\n+The first operand is the pointer being dereferenced; it will always have\n+pointer or reference type.  The second operand is a pointer constant.\n+Its type is specifying the type to be used for type-based alias analysis.\n+\n @item COMPONENT_REF\n These nodes represent non-static data member accesses.  The first\n operand is the object (rather than a pointer to it); the second operand"}, {"sha": "b778db387d91316bae3bf9407aa7d3e911eb6201", "filename": "gcc/doc/gimple.texi", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fdoc%2Fgimple.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fdoc%2Fgimple.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgimple.texi?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -452,8 +452,8 @@ becomes\n \n The same rule holds for arguments to a @code{GIMPLE_CALL}.\n \n-The target of an assignment is usually a variable, but can also be an\n-@code{INDIRECT_REF} or a compound lvalue as described below.\n+The target of an assignment is usually a variable, but can also be a\n+@code{MEM_REF} or a compound lvalue as described below.\n \n @menu\n * Compound Expressions::\n@@ -664,6 +664,11 @@ Return true if t is a valid expression to use as the function\n called by a @code{GIMPLE_CALL}.\n @end deftypefn\n \n+@deftypefn {GIMPLE function} is_gimple_mem_ref_addr (tree t)\n+Return true if t is a valid expression to use as first operand\n+of a @code{MEM_REF} expression.\n+@end deftypefn\n+\n @deftypefn {GIMPLE function} is_gimple_constant (tree t)\n Return true if t is a valid gimple constant.\n @end deftypefn"}, {"sha": "3faa175485999a907b2a45695b73b7f2ca84361c", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -15160,6 +15160,11 @@ loc_list_from_tree (tree loc, int want_address)\n       }\n       break;\n \n+    case MEM_REF:\n+      /* ??? FIXME.  */\n+      if (!integer_zerop (TREE_OPERAND (loc, 1)))\n+\treturn 0;\n+      /* Fallthru.  */\n     case INDIRECT_REF:\n     case ALIGN_INDIRECT_REF:\n     case MISALIGNED_INDIRECT_REF:"}, {"sha": "4e38d89d34875f973f2b96aa90a8fb9be4abeb14", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1614,6 +1614,35 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n       || TREE_CODE (t) == ALIGN_INDIRECT_REF\n       || TYPE_ALIGN_OK (type))\n     align = MAX (align, TYPE_ALIGN (type));\n+  else if (TREE_CODE (t) == MEM_REF)\n+    {\n+      HOST_WIDE_INT aoff = BITS_PER_UNIT;\n+      if (host_integerp (TREE_OPERAND (t, 1), 1))\n+\t{\n+\t  HOST_WIDE_INT ioff = TREE_INT_CST_LOW (TREE_OPERAND (t, 1));\n+\t  aoff = (ioff & -ioff) * BITS_PER_UNIT;\n+\t}\n+      if (TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR\n+\t  && DECL_P (TREE_OPERAND (TREE_OPERAND (t, 0), 0)))\n+\talign = MAX (align,\n+\t\t     DECL_ALIGN (TREE_OPERAND (TREE_OPERAND (t, 0), 0)));\n+      else if (TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR\n+\t       && CONSTANT_CLASS_P (TREE_OPERAND (TREE_OPERAND (t, 0), 0)))\n+\t{\n+\t  align = TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 0), 0)));\n+#ifdef CONSTANT_ALIGNMENT\n+\t  align = CONSTANT_ALIGNMENT (TREE_OPERAND (TREE_OPERAND (t, 0), 0), align);\n+#endif\n+\t}\n+      else\n+\t/* This technically isn't correct.  We can't really derive\n+\t   alignment information from types.  */\n+\talign = MAX (align,\n+\t\t     TYPE_ALIGN (TREE_TYPE (TREE_TYPE (TREE_OPERAND (t, 1)))));\n+      if (!integer_zerop (TREE_OPERAND (t, 1))\n+\t  && aoff < align)\n+\talign = aoff;\n+    }\n   else\n     if (TREE_CODE (t) == MISALIGNED_INDIRECT_REF)\n       {\n@@ -1654,6 +1683,9 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t     || TREE_CODE (base) == BIT_FIELD_REF)\n \tbase = TREE_OPERAND (base, 0);\n \n+      if (TREE_CODE (base) == MEM_REF\n+\t  && TREE_CODE (TREE_OPERAND (base, 0)) == ADDR_EXPR)\n+\tbase = TREE_OPERAND (TREE_OPERAND (base, 0), 0);\n       if (DECL_P (base))\n \t{\n \t  if (CODE_CONTAINS_STRUCT (TREE_CODE (base), TS_DECL_WITH_VIS))\n@@ -1774,7 +1806,7 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t    }\n \n \t  /* If this is an indirect reference, record it.  */\n-\t  else if (TREE_CODE (t) == INDIRECT_REF\n+\t  else if (TREE_CODE (t) == MEM_REF \n \t\t   || TREE_CODE (t) == MISALIGNED_INDIRECT_REF)\n \t    {\n \t      expr = t;\n@@ -1784,7 +1816,7 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t}\n \n       /* If this is an indirect reference, record it.  */\n-      else if (TREE_CODE (t) == INDIRECT_REF\n+      else if (TREE_CODE (t) == MEM_REF \n \t       || TREE_CODE (t) == MISALIGNED_INDIRECT_REF)\n \t{\n \t  expr = t;"}, {"sha": "a2a8054eb4ef69ea644197c47d991c1c140cbfaa", "filename": "gcc/expr.c", "status": "modified", "additions": 151, "deletions": 1, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -4213,6 +4213,10 @@ expand_assignment (tree to, tree from, bool nontemporal)\n      an array element in an unaligned packed structure field, has the same\n      problem.  */\n   if (handled_component_p (to)\n+      /* ???  We only need to handle MEM_REF here if the access is not\n+         a full access of the base object.  */\n+      || (TREE_CODE (to) == MEM_REF\n+\t  && TREE_CODE (TREE_OPERAND (to, 0)) == ADDR_EXPR)\n       || TREE_CODE (TREE_TYPE (to)) == ARRAY_TYPE)\n     {\n       enum machine_mode mode1;\n@@ -4686,6 +4690,51 @@ store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n \t\t       BLOCK_OP_NORMAL);\n       return NULL_RTX;\n     }\n+  else if (TREE_CODE (exp) == MEM_REF\n+\t   && TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n+\t   && TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)) == STRING_CST\n+\t   && integer_zerop (TREE_OPERAND (exp, 1))\n+\t   && !nontemporal && !call_param_p\n+\t   && TYPE_MODE (TREE_TYPE (exp)) == BLKmode)\n+    {\n+      /* Optimize initialization of an array with a STRING_CST.  */\n+      HOST_WIDE_INT exp_len, str_copy_len;\n+      rtx dest_mem;\n+      tree str = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+\n+      exp_len = int_expr_size (exp);\n+      if (exp_len <= 0)\n+\tgoto normal_expr;\n+\n+      str_copy_len = strlen (TREE_STRING_POINTER (str));\n+      if (str_copy_len < TREE_STRING_LENGTH (str) - 1)\n+\tgoto normal_expr;\n+\n+      str_copy_len = TREE_STRING_LENGTH (str);\n+      if ((STORE_MAX_PIECES & (STORE_MAX_PIECES - 1)) == 0)\n+\t{\n+\t  str_copy_len += STORE_MAX_PIECES - 1;\n+\t  str_copy_len &= ~(STORE_MAX_PIECES - 1);\n+\t}\n+      str_copy_len = MIN (str_copy_len, exp_len);\n+      if (!can_store_by_pieces (str_copy_len, builtin_strncpy_read_str,\n+\t\t\t\tCONST_CAST(char *, TREE_STRING_POINTER (str)),\n+\t\t\t\tMEM_ALIGN (target), false))\n+\tgoto normal_expr;\n+\n+      dest_mem = target;\n+\n+      dest_mem = store_by_pieces (dest_mem,\n+\t\t\t\t  str_copy_len, builtin_strncpy_read_str,\n+\t\t\t\t  CONST_CAST(char *, TREE_STRING_POINTER (str)),\n+\t\t\t\t  MEM_ALIGN (target), false,\n+\t\t\t\t  exp_len > str_copy_len ? 1 : 0);\n+      if (exp_len > str_copy_len)\n+\tclear_storage (adjust_address (dest_mem, BLKmode, 0),\n+\t\t       GEN_INT (exp_len - str_copy_len),\n+\t\t       BLOCK_OP_NORMAL);\n+      return NULL_RTX;\n+    }\n   else\n     {\n       rtx tmp_target;\n@@ -5852,7 +5901,15 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t operations.  */\n       || (bitsize >= 0\n \t  && TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) == INTEGER_CST\n-\t  && compare_tree_int (TYPE_SIZE (TREE_TYPE (exp)), bitsize) != 0))\n+\t  && compare_tree_int (TYPE_SIZE (TREE_TYPE (exp)), bitsize) != 0)\n+      /* If we are expanding a MEM_REF of a non-BLKmode non-addressable\n+         decl we must use bitfield operations.  */\n+      || (bitsize >= 0\n+\t  && TREE_CODE (exp) == MEM_REF\n+\t  && TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n+\t  && DECL_P (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n+\t  && !TREE_ADDRESSABLE (TREE_OPERAND (TREE_OPERAND (exp, 0),0 ))\n+\t  && DECL_MODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)) != BLKmode))\n     {\n       rtx temp;\n       gimple nop_def;\n@@ -6113,6 +6170,24 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n \t    goto done;\n \t  break;\n \n+\tcase MEM_REF:\n+\t  /* Hand back the decl for MEM[&decl, off].  */\n+\t  if (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR)\n+\t    {\n+\t      tree off = TREE_OPERAND (exp, 1);\n+\t      if (!integer_zerop (off))\n+\t\t{\n+\t\t  double_int boff, coff = mem_ref_offset (exp);\n+\t\t  boff = double_int_lshift (coff,\n+\t\t\t\t\t    BITS_PER_UNIT == 8\n+\t\t\t\t\t    ? 3 : exact_log2 (BITS_PER_UNIT),\n+\t\t\t\t\t    HOST_BITS_PER_DOUBLE_INT, true);\n+\t\t  bit_offset = double_int_add (bit_offset, boff);\n+\t\t}\n+\t      exp = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+\t    }\n+\t  goto done;\n+\n \tdefault:\n \t  goto done;\n \t}\n@@ -6873,6 +6948,16 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n       /* This case will happen via recursion for &a->b.  */\n       return expand_expr (TREE_OPERAND (exp, 0), target, tmode, modifier);\n \n+    case MEM_REF:\n+      {\n+\ttree tem = TREE_OPERAND (exp, 0);\n+\tif (!integer_zerop (TREE_OPERAND (exp, 1)))\n+\t  tem = build2 (POINTER_PLUS_EXPR, TREE_TYPE (TREE_OPERAND (exp, 1)),\n+\t\t\ttem,\n+\t\t\tdouble_int_to_tree (sizetype, mem_ref_offset (exp)));\n+\treturn expand_expr (tem, target, tmode, modifier);\n+      }\n+\n     case CONST_DECL:\n       /* Expand the initializer like constants above.  */\n       return XEXP (expand_expr_constant (DECL_INITIAL (exp), 0, modifier), 0);\n@@ -8684,6 +8769,71 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       }\n       return temp;\n \n+    case MEM_REF:\n+      {\n+\taddr_space_t as\n+\t  = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 1))));\n+\tenum machine_mode address_mode;\n+\ttree base = TREE_OPERAND (exp, 0);\n+\t/* Handle expansion of non-aliased memory with non-BLKmode.  That\n+\t   might end up in a register.  */\n+\tif (TREE_CODE (base) == ADDR_EXPR)\n+\t  {\n+\t    HOST_WIDE_INT offset = mem_ref_offset (exp).low;\n+\t    tree bit_offset;\n+\t    base = TREE_OPERAND (base, 0);\n+\t    if (!DECL_P (base))\n+\t      {\n+\t\tHOST_WIDE_INT off;\n+\t\tbase = get_addr_base_and_unit_offset (base, &off);\n+\t\tgcc_assert (base);\n+\t\toffset += off;\n+\t      }\n+\t    /* If we are expanding a MEM_REF of a non-BLKmode non-addressable\n+\t       decl we must use bitfield operations.  */\n+\t    if (DECL_P (base)\n+\t\t&& !TREE_ADDRESSABLE (base)\n+\t\t&& DECL_MODE (base) != BLKmode\n+\t\t&& DECL_RTL_SET_P (base)\n+\t\t&& !MEM_P (DECL_RTL (base)))\n+\t      {\n+\t\ttree bftype;\n+\t\tif (offset == 0\n+\t\t    && host_integerp (TYPE_SIZE (TREE_TYPE (exp)), 1)\n+\t\t    && (GET_MODE_BITSIZE (DECL_MODE (base))\n+\t\t\t== TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (exp)))))\n+\t\t  return expand_expr (build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t      TREE_TYPE (exp), base),\n+\t\t\t\t      target, tmode, modifier);\n+\t\tbit_offset = bitsize_int (offset * BITS_PER_UNIT);\n+\t\tbftype = TREE_TYPE (base);\n+\t\tif (TYPE_MODE (TREE_TYPE (exp)) != BLKmode)\n+\t\t  bftype = TREE_TYPE (exp);\n+\t\treturn expand_expr (build3 (BIT_FIELD_REF, bftype,\n+\t\t\t\t\t    base,\n+\t\t\t\t\t    TYPE_SIZE (TREE_TYPE (exp)),\n+\t\t\t\t\t    bit_offset),\n+\t\t\t\t    target, tmode, modifier);\n+\t      }\n+\t  }\n+\taddress_mode = targetm.addr_space.address_mode (as);\n+\top0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, address_mode,\n+\t\t\t   EXPAND_NORMAL);\n+\tif (!integer_zerop (TREE_OPERAND (exp, 1)))\n+\t  {\n+\t    rtx off;\n+\t    off = immed_double_int_const (mem_ref_offset (exp), address_mode);\n+\t    op0 = simplify_gen_binary (PLUS, address_mode, op0, off);\n+\t  }\n+\top0 = memory_address_addr_space (mode, op0, as);\n+\ttemp = gen_rtx_MEM (mode, op0);\n+\tset_mem_attributes (temp, exp, 0);\n+\tset_mem_addr_space (temp, as);\n+\tif (TREE_THIS_VOLATILE (exp))\n+\t  MEM_VOLATILE_P (temp) = 1;\n+\treturn temp;\n+      }\n+\n     case ARRAY_REF:\n \n       {"}, {"sha": "1e3bae65405119467244975df5bcb7ae67ece765", "filename": "gcc/fold-const.c", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -60,6 +60,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"md5.h\"\n #include \"gimple.h\"\n+#include \"tree-flow.h\"\n \n /* Nonzero if we are folding constants inside an initializer; zero\n    otherwise.  */\n@@ -2591,6 +2592,17 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \tcase IMAGPART_EXPR:\n \t  return OP_SAME (0);\n \n+\tcase MEM_REF:\n+\t  /* Require equal access sizes.  We can have incomplete types\n+\t     for array references of variable-sized arrays from the\n+\t     Fortran frontent though.  */\n+\t  return ((TYPE_SIZE (TREE_TYPE (arg0)) == TYPE_SIZE (TREE_TYPE (arg1))\n+\t\t   || (TYPE_SIZE (TREE_TYPE (arg0))\n+\t\t       && TYPE_SIZE (TREE_TYPE (arg1))\n+\t\t       && operand_equal_p (TYPE_SIZE (TREE_TYPE (arg0)),\n+\t\t\t\t\t   TYPE_SIZE (TREE_TYPE (arg1)), flags)))\n+\t\t  && OP_SAME (0) && OP_SAME (1));\n+\n \tcase ARRAY_REF:\n \tcase ARRAY_RANGE_REF:\n \t  /* Operands 2 and 3 may be null.\n@@ -7596,6 +7608,9 @@ build_fold_addr_expr_with_type_loc (location_t loc, tree t, tree ptrtype)\n \t  SET_EXPR_LOCATION (t, loc);\n \t}\n     }\n+  else if (TREE_CODE (t) == MEM_REF\n+      && integer_zerop (TREE_OPERAND (t, 1)))\n+    return TREE_OPERAND (t, 0);\n   else if (TREE_CODE (t) == VIEW_CONVERT_EXPR)\n     {\n       t = build_fold_addr_expr_loc (loc, TREE_OPERAND (t, 0));\n@@ -8014,6 +8029,9 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n       if (TREE_CODE (op0) == VIEW_CONVERT_EXPR)\n \treturn fold_build1_loc (loc, VIEW_CONVERT_EXPR,\n \t\t\t    type, TREE_OPERAND (op0, 0));\n+      if (TREE_CODE (op0) == MEM_REF)\n+\treturn fold_build2_loc (loc, MEM_REF, type,\n+\t\t\t\tTREE_OPERAND (op0, 0), TREE_OPERAND (op0, 1));\n \n       /* For integral conversions with the same precision or pointer\n \t conversions use a NOP_EXPR instead.  */\n@@ -8665,6 +8683,11 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n       else if (TREE_CODE (arg0) == POINTER_PLUS_EXPR)\n \t{\n \t  base0 = TREE_OPERAND (arg0, 0);\n+\t  if (TREE_CODE (base0) == ADDR_EXPR)\n+\t    {\n+\t      base0 = TREE_OPERAND (base0, 0);\n+\t      indirect_base0 = true;\n+\t    }\n \t  offset0 = TREE_OPERAND (arg0, 1);\n \t}\n \n@@ -8682,6 +8705,11 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n       else if (TREE_CODE (arg1) == POINTER_PLUS_EXPR)\n \t{\n \t  base1 = TREE_OPERAND (arg1, 0);\n+\t  if (TREE_CODE (base1) == ADDR_EXPR)\n+\t    {\n+\t      base1 = TREE_OPERAND (base1, 0);\n+\t      indirect_base1 = true;\n+\t    }\n \t  offset1 = TREE_OPERAND (arg1, 1);\n \t}\n \n@@ -9524,6 +9552,36 @@ fold_binary_loc (location_t loc,\n \n   switch (code)\n     {\n+    case MEM_REF:\n+      /* MEM[&MEM[p, CST1], CST2] -> MEM[p, CST1 + CST2].  */\n+      if (TREE_CODE (arg0) == ADDR_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 0)) == MEM_REF)\n+\t{\n+\t  tree iref = TREE_OPERAND (arg0, 0);\n+\t  return fold_build2 (MEM_REF, type,\n+\t\t\t      TREE_OPERAND (iref, 0),\n+\t\t\t      int_const_binop (PLUS_EXPR, arg1,\n+\t\t\t\t\t       TREE_OPERAND (iref, 1), 0));\n+\t}\n+\n+      /* MEM[&a.b, CST2] -> MEM[&a, offsetof (a, b) + CST2].  */\n+      if (TREE_CODE (arg0) == ADDR_EXPR\n+\t  && handled_component_p (TREE_OPERAND (arg0, 0)))\n+\t{\n+\t  tree base;\n+\t  HOST_WIDE_INT coffset;\n+\t  base = get_addr_base_and_unit_offset (TREE_OPERAND (arg0, 0),\n+\t\t\t\t\t\t&coffset);\n+\t  if (!base)\n+\t    return NULL_TREE;\n+\t  return fold_build2 (MEM_REF, type,\n+\t\t\t      build_fold_addr_expr (base),\n+\t\t\t      int_const_binop (PLUS_EXPR, arg1,\n+\t\t\t\t\t       size_int (coffset), 0));\n+\t}\n+\n+      return NULL_TREE;\n+\n     case POINTER_PLUS_EXPR:\n       /* 0 +p index -> (type)index */\n       if (integer_zerop (arg0))"}, {"sha": "6af651140006574818fca407c5e87bf5dff2a9e9", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 124, "deletions": 369, "changes": 493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -82,7 +82,7 @@ get_symbol_constant_value (tree sym)\n bool\n may_propagate_address_into_dereference (tree addr, tree deref)\n {\n-  gcc_assert (INDIRECT_REF_P (deref)\n+  gcc_assert (TREE_CODE (deref) == MEM_REF\n \t      && TREE_CODE (addr) == ADDR_EXPR);\n \n   /* Don't propagate if ADDR's operand has incomplete type.  */\n@@ -108,15 +108,12 @@ may_propagate_address_into_dereference (tree addr, tree deref)\n \n \n /* A subroutine of fold_stmt.  Attempts to fold *(A+O) to A[X].\n-   BASE is an array type.  OFFSET is a byte displacement.  ORIG_TYPE\n-   is the desired result type.\n+   BASE is an array type.  OFFSET is a byte displacement.\n \n    LOC is the location of the original expression.  */\n \n static tree\n-maybe_fold_offset_to_array_ref (location_t loc, tree base, tree offset,\n-\t\t\t\ttree orig_type,\n-\t\t\t\tbool allow_negative_idx)\n+maybe_fold_offset_to_array_ref (location_t loc, tree base, tree offset)\n {\n   tree min_idx, idx, idx_type, elt_offset = integer_zero_node;\n   tree array_type, elt_type, elt_size;\n@@ -145,8 +142,6 @@ maybe_fold_offset_to_array_ref (location_t loc, tree base, tree offset,\n   if (TREE_CODE (array_type) != ARRAY_TYPE)\n     return NULL_TREE;\n   elt_type = TREE_TYPE (array_type);\n-  if (!useless_type_conversion_p (orig_type, elt_type))\n-    return NULL_TREE;\n \n   /* Use signed size type for intermediate computation on the index.  */\n   idx_type = ssizetype;\n@@ -219,34 +214,22 @@ maybe_fold_offset_to_array_ref (location_t loc, tree base, tree offset,\n        char *(c[4]);\n        c[3][2];\n      should not be simplified into (*c)[14] or tree-vrp will\n-     give false warnings.  The same is true for\n-       struct A { long x; char d[0]; } *a;\n-       (char *)a - 4;\n-     which should be not folded to &a->d[-8].  */\n-  if (domain_type\n-      && TYPE_MAX_VALUE (domain_type)\n-      && TREE_CODE (TYPE_MAX_VALUE (domain_type)) == INTEGER_CST)\n+     give false warnings.\n+     This is only an issue for multi-dimensional arrays.  */\n+  if (TREE_CODE (elt_type) == ARRAY_TYPE\n+      && domain_type)\n     {\n-      tree up_bound = TYPE_MAX_VALUE (domain_type);\n-\n-      if (tree_int_cst_lt (up_bound, idx)\n-\t  /* Accesses after the end of arrays of size 0 (gcc\n-\t     extension) and 1 are likely intentional (\"struct\n-\t     hack\").  */\n-\t  && compare_tree_int (up_bound, 1) > 0)\n+      if (TYPE_MAX_VALUE (domain_type)\n+\t  && TREE_CODE (TYPE_MAX_VALUE (domain_type)) == INTEGER_CST\n+\t  && tree_int_cst_lt (TYPE_MAX_VALUE (domain_type), idx))\n \treturn NULL_TREE;\n-    }\n-  if (domain_type\n-      && TYPE_MIN_VALUE (domain_type))\n-    {\n-      if (!allow_negative_idx\n-\t  && TREE_CODE (TYPE_MIN_VALUE (domain_type)) == INTEGER_CST\n-\t  && tree_int_cst_lt (idx, TYPE_MIN_VALUE (domain_type)))\n+      else if (TYPE_MIN_VALUE (domain_type)\n+\t       && TREE_CODE (TYPE_MIN_VALUE (domain_type)) == INTEGER_CST\n+\t       && tree_int_cst_lt (idx, TYPE_MIN_VALUE (domain_type)))\n+\treturn NULL_TREE;\n+      else if (compare_tree_int (idx, 0) < 0)\n \treturn NULL_TREE;\n     }\n-  else if (!allow_negative_idx\n-\t   && compare_tree_int (idx, 0) < 0)\n-    return NULL_TREE;\n \n   {\n     tree t = build4 (ARRAY_REF, elt_type, base, idx, NULL_TREE, NULL_TREE);\n@@ -256,340 +239,55 @@ maybe_fold_offset_to_array_ref (location_t loc, tree base, tree offset,\n }\n \n \n-/* Attempt to fold *(S+O) to S.X.\n-   BASE is a record type.  OFFSET is a byte displacement.  ORIG_TYPE\n-   is the desired result type.\n-\n-   LOC is the location of the original expression.  */\n-\n-static tree\n-maybe_fold_offset_to_component_ref (location_t loc, tree record_type,\n-\t\t\t\t    tree base, tree offset, tree orig_type)\n-{\n-  tree f, t, field_type, tail_array_field, field_offset;\n-  tree ret;\n-  tree new_base;\n-\n-  if (TREE_CODE (record_type) != RECORD_TYPE\n-      && TREE_CODE (record_type) != UNION_TYPE\n-      && TREE_CODE (record_type) != QUAL_UNION_TYPE)\n-    return NULL_TREE;\n-\n-  /* Short-circuit silly cases.  */\n-  if (useless_type_conversion_p (record_type, orig_type))\n-    return NULL_TREE;\n-\n-  tail_array_field = NULL_TREE;\n-  for (f = TYPE_FIELDS (record_type); f ; f = TREE_CHAIN (f))\n-    {\n-      int cmp;\n-\n-      if (TREE_CODE (f) != FIELD_DECL)\n-\tcontinue;\n-      if (DECL_BIT_FIELD (f))\n-\tcontinue;\n-\n-      if (!DECL_FIELD_OFFSET (f))\n-\tcontinue;\n-      field_offset = byte_position (f);\n-      if (TREE_CODE (field_offset) != INTEGER_CST)\n-\tcontinue;\n-\n-      /* ??? Java creates \"interesting\" fields for representing base classes.\n-\t They have no name, and have no context.  With no context, we get into\n-\t trouble with nonoverlapping_component_refs_p.  Skip them.  */\n-      if (!DECL_FIELD_CONTEXT (f))\n-\tcontinue;\n-\n-      /* The previous array field isn't at the end.  */\n-      tail_array_field = NULL_TREE;\n-\n-      /* Check to see if this offset overlaps with the field.  */\n-      cmp = tree_int_cst_compare (field_offset, offset);\n-      if (cmp > 0)\n-\tcontinue;\n-\n-      field_type = TREE_TYPE (f);\n-\n-      /* Here we exactly match the offset being checked.  If the types match,\n-\t then we can return that field.  */\n-      if (cmp == 0\n-\t  && useless_type_conversion_p (orig_type, field_type))\n-\t{\n-\t  t = fold_build3 (COMPONENT_REF, field_type, base, f, NULL_TREE);\n-\t  return t;\n-\t}\n-\n-      /* Don't care about offsets into the middle of scalars.  */\n-      if (!AGGREGATE_TYPE_P (field_type))\n-\tcontinue;\n-\n-      /* Check for array at the end of the struct.  This is often\n-\t used as for flexible array members.  We should be able to\n-\t turn this into an array access anyway.  */\n-      if (TREE_CODE (field_type) == ARRAY_TYPE)\n-\ttail_array_field = f;\n-\n-      /* Check the end of the field against the offset.  */\n-      if (!DECL_SIZE_UNIT (f)\n-\t  || TREE_CODE (DECL_SIZE_UNIT (f)) != INTEGER_CST)\n-\tcontinue;\n-      t = int_const_binop (MINUS_EXPR, offset, field_offset, 1);\n-      if (!tree_int_cst_lt (t, DECL_SIZE_UNIT (f)))\n-\tcontinue;\n-\n-      /* If we matched, then set offset to the displacement into\n-\t this field.  */\n-      new_base = fold_build3 (COMPONENT_REF, field_type, base, f, NULL_TREE);\n-      SET_EXPR_LOCATION (new_base, loc);\n-\n-      /* Recurse to possibly find the match.  */\n-      ret = maybe_fold_offset_to_array_ref (loc, new_base, t, orig_type,\n-\t\t\t\t\t    f == TYPE_FIELDS (record_type));\n-      if (ret)\n-\treturn ret;\n-      ret = maybe_fold_offset_to_component_ref (loc, field_type, new_base, t,\n-\t\t\t\t\t\torig_type);\n-      if (ret)\n-\treturn ret;\n-    }\n-\n-  if (!tail_array_field)\n-    return NULL_TREE;\n-\n-  f = tail_array_field;\n-  field_type = TREE_TYPE (f);\n-  offset = int_const_binop (MINUS_EXPR, offset, byte_position (f), 1);\n-\n-  /* If we get here, we've got an aggregate field, and a possibly\n-     nonzero offset into them.  Recurse and hope for a valid match.  */\n-  base = fold_build3 (COMPONENT_REF, field_type, base, f, NULL_TREE);\n-  SET_EXPR_LOCATION (base, loc);\n-\n-  t = maybe_fold_offset_to_array_ref (loc, base, offset, orig_type,\n-\t\t\t\t      f == TYPE_FIELDS (record_type));\n-  if (t)\n-    return t;\n-  return maybe_fold_offset_to_component_ref (loc, field_type, base, offset,\n-\t\t\t\t\t     orig_type);\n-}\n-\n-/* Attempt to express (ORIG_TYPE)BASE+OFFSET as BASE->field_of_orig_type\n-   or BASE[index] or by combination of those.\n-\n+/* Attempt to express (ORIG_TYPE)BASE+OFFSET as BASE[index].\n    LOC is the location of original expression.\n \n-   Before attempting the conversion strip off existing ADDR_EXPRs and\n-   handled component refs.  */\n+   Before attempting the conversion strip off existing ADDR_EXPRs.  */\n \n tree\n maybe_fold_offset_to_reference (location_t loc, tree base, tree offset,\n \t\t\t\ttree orig_type)\n {\n   tree ret;\n-  tree type;\n \n   STRIP_NOPS (base);\n   if (TREE_CODE (base) != ADDR_EXPR)\n     return NULL_TREE;\n \n   base = TREE_OPERAND (base, 0);\n-\n-  /* Handle case where existing COMPONENT_REF pick e.g. wrong field of union,\n-     so it needs to be removed and new COMPONENT_REF constructed.\n-     The wrong COMPONENT_REF are often constructed by folding the\n-     (type *)&object within the expression (type *)&object+offset  */\n-  if (handled_component_p (base))\n-    {\n-      HOST_WIDE_INT sub_offset, size, maxsize;\n-      tree newbase;\n-      newbase = get_ref_base_and_extent (base, &sub_offset,\n-\t\t\t\t\t &size, &maxsize);\n-      gcc_assert (newbase);\n-      if (size == maxsize\n-\t  && size != -1\n-\t  && !(sub_offset & (BITS_PER_UNIT - 1)))\n-\t{\n-\t  base = newbase;\n-\t  if (sub_offset)\n-\t    offset = int_const_binop (PLUS_EXPR, offset,\n-\t\t\t\t      build_int_cst (TREE_TYPE (offset),\n-\t\t\t\t\t\t     sub_offset / BITS_PER_UNIT), 1);\n-\t}\n-    }\n-  if (useless_type_conversion_p (orig_type, TREE_TYPE (base))\n+  if (types_compatible_p (orig_type, TREE_TYPE (base))\n       && integer_zerop (offset))\n     return base;\n-  type = TREE_TYPE (base);\n \n-  ret = maybe_fold_offset_to_component_ref (loc, type, base, offset, orig_type);\n-  if (!ret)\n-    ret = maybe_fold_offset_to_array_ref (loc, base, offset, orig_type, true);\n-\n-  return ret;\n+  ret = maybe_fold_offset_to_array_ref (loc, base, offset);\n+  if (ret && types_compatible_p (orig_type, TREE_TYPE (ret)))\n+    return ret;\n+  return NULL_TREE;\n }\n \n-/* Attempt to express (ORIG_TYPE)&BASE+OFFSET as &BASE->field_of_orig_type\n-   or &BASE[index] or by combination of those.\n-\n-   LOC is the location of the original expression.\n-\n-   Before attempting the conversion strip off existing component refs.  */\n+/* Attempt to express (ORIG_TYPE)ADDR+OFFSET as (*ADDR)[index].\n+   LOC is the location of the original expression.  */\n \n tree\n maybe_fold_offset_to_address (location_t loc, tree addr, tree offset,\n \t\t\t      tree orig_type)\n {\n-  tree t;\n+  tree base, ret;\n \n-  gcc_assert (POINTER_TYPE_P (TREE_TYPE (addr))\n-\t      && POINTER_TYPE_P (orig_type));\n-\n-  t = maybe_fold_offset_to_reference (loc, addr, offset,\n-\t\t\t\t      TREE_TYPE (orig_type));\n-  if (t != NULL_TREE)\n-    {\n-      tree orig = addr;\n-      tree ptr_type;\n-\n-      /* For __builtin_object_size to function correctly we need to\n-         make sure not to fold address arithmetic so that we change\n-\t reference from one array to another.  This would happen for\n-\t example for\n-\n-\t   struct X { char s1[10]; char s2[10] } s;\n-\t   char *foo (void) { return &s.s2[-4]; }\n-\n-\t where we need to avoid generating &s.s1[6].  As the C and\n-\t C++ frontends create different initial trees\n-\t (char *) &s.s1 + -4  vs.  &s.s1[-4]  we have to do some\n-\t sophisticated comparisons here.  Note that checking for the\n-\t condition after the fact is easier than trying to avoid doing\n-\t the folding.  */\n-      STRIP_NOPS (orig);\n-      if (TREE_CODE (orig) == ADDR_EXPR)\n-\torig = TREE_OPERAND (orig, 0);\n-      if ((TREE_CODE (orig) == ARRAY_REF\n-\t   || (TREE_CODE (orig) == COMPONENT_REF\n-\t       && TREE_CODE (TREE_TYPE (TREE_OPERAND (orig, 1))) == ARRAY_TYPE))\n-\t  && (TREE_CODE (t) == ARRAY_REF\n-\t      || TREE_CODE (t) == COMPONENT_REF)\n-\t  && !operand_equal_p (TREE_CODE (orig) == ARRAY_REF\n-\t\t\t       ? TREE_OPERAND (orig, 0) : orig,\n-\t\t\t       TREE_CODE (t) == ARRAY_REF\n-\t\t\t       ? TREE_OPERAND (t, 0) : t, 0))\n-\treturn NULL_TREE;\n-\n-      ptr_type = build_pointer_type (TREE_TYPE (t));\n-      if (!useless_type_conversion_p (orig_type, ptr_type))\n-\treturn NULL_TREE;\n-      return build_fold_addr_expr_with_type_loc (loc, t, ptr_type);\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* A subroutine of fold_stmt.  Attempt to simplify *(BASE+OFFSET).\n-   Return the simplified expression, or NULL if nothing could be done.  */\n-\n-static tree\n-maybe_fold_stmt_indirect (tree expr, tree base, tree offset)\n-{\n-  tree t;\n-  bool volatile_p = TREE_THIS_VOLATILE (expr);\n-  location_t loc = EXPR_LOCATION (expr);\n-\n-  /* We may well have constructed a double-nested PLUS_EXPR via multiple\n-     substitutions.  Fold that down to one.  Remove NON_LVALUE_EXPRs that\n-     are sometimes added.  */\n-  base = fold (base);\n-  STRIP_TYPE_NOPS (base);\n-  TREE_OPERAND (expr, 0) = base;\n-\n-  /* One possibility is that the address reduces to a string constant.  */\n-  t = fold_read_from_constant_string (expr);\n-  if (t)\n-    return t;\n-\n-  /* Add in any offset from a POINTER_PLUS_EXPR.  */\n-  if (TREE_CODE (base) == POINTER_PLUS_EXPR)\n+  STRIP_NOPS (addr);\n+  if (TREE_CODE (addr) != ADDR_EXPR)\n+    return NULL_TREE;\n+  base = TREE_OPERAND (addr, 0);\n+  ret = maybe_fold_offset_to_array_ref (loc, base, offset);\n+  if (ret)\n     {\n-      tree offset2;\n-\n-      offset2 = TREE_OPERAND (base, 1);\n-      if (TREE_CODE (offset2) != INTEGER_CST)\n+      ret = build_fold_addr_expr (ret);\n+      if (!useless_type_conversion_p (orig_type, TREE_TYPE (ret)))\n \treturn NULL_TREE;\n-      base = TREE_OPERAND (base, 0);\n-\n-      offset = fold_convert (sizetype,\n-\t\t\t     int_const_binop (PLUS_EXPR, offset, offset2, 1));\n+      SET_EXPR_LOCATION (ret, loc);\n     }\n \n-  if (TREE_CODE (base) == ADDR_EXPR)\n-    {\n-      tree base_addr = base;\n-\n-      /* Strip the ADDR_EXPR.  */\n-      base = TREE_OPERAND (base, 0);\n-\n-      /* Fold away CONST_DECL to its value, if the type is scalar.  */\n-      if (TREE_CODE (base) == CONST_DECL\n-\t  && is_gimple_min_invariant (DECL_INITIAL (base)))\n-\treturn DECL_INITIAL (base);\n-\n-      /* If there is no offset involved simply return the folded base.  */\n-      if (integer_zerop (offset))\n-\treturn base;\n-\n-      /* Try folding *(&B+O) to B.X.  */\n-      t = maybe_fold_offset_to_reference (loc, base_addr, offset,\n-\t\t\t\t\t  TREE_TYPE (expr));\n-      if (t)\n-\t{\n-\t  /* Preserve volatileness of the original expression.\n-\t     We can end up with a plain decl here which is shared\n-\t     and we shouldn't mess with its flags.  */\n-\t  if (!SSA_VAR_P (t))\n-\t    TREE_THIS_VOLATILE (t) = volatile_p;\n-\t  return t;\n-\t}\n-    }\n-  else\n-    {\n-      /* We can get here for out-of-range string constant accesses,\n-\t such as \"_\"[3].  Bail out of the entire substitution search\n-\t and arrange for the entire statement to be replaced by a\n-\t call to __builtin_trap.  In all likelihood this will all be\n-\t constant-folded away, but in the meantime we can't leave with\n-\t something that get_expr_operands can't understand.  */\n-\n-      t = base;\n-      STRIP_NOPS (t);\n-      if (TREE_CODE (t) == ADDR_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (t, 0)) == STRING_CST)\n-\t{\n-\t  /* FIXME: Except that this causes problems elsewhere with dead\n-\t     code not being deleted, and we die in the rtl expanders\n-\t     because we failed to remove some ssa_name.  In the meantime,\n-\t     just return zero.  */\n-\t  /* FIXME2: This condition should be signaled by\n-\t     fold_read_from_constant_string directly, rather than\n-\t     re-checking for it here.  */\n-\t  return integer_zero_node;\n-\t}\n-\n-      /* Try folding *(B+O) to B->X.  Still an improvement.  */\n-      if (POINTER_TYPE_P (TREE_TYPE (base)))\n-\t{\n-          t = maybe_fold_offset_to_reference (loc, base, offset,\n-\t\t\t\t              TREE_TYPE (expr));\n-\t  if (t)\n-\t    return t;\n-\t}\n-    }\n-\n-  /* Otherwise we had an offset that we could not simplify.  */\n-  return NULL_TREE;\n+  return ret;\n }\n \n \n@@ -622,18 +320,17 @@ maybe_fold_stmt_addition (location_t loc, tree res_type, tree op0, tree op1)\n       /* Or op0 should now be A[0] and the non-constant offset defined\n \t via a multiplication by the array element size.  */\n       if (TREE_CODE (op0) == ARRAY_REF\n-\t  && integer_zerop (TREE_OPERAND (op0, 1))\n-\t  && TREE_CODE (op1) == SSA_NAME\n-\t  && host_integerp (TYPE_SIZE_UNIT (TREE_TYPE (op0)), 1))\n-\t{\n-\t  gimple offset_def = SSA_NAME_DEF_STMT (op1);\n-\t  if (!is_gimple_assign (offset_def))\n-\t    return NULL_TREE;\n-\n \t  /* As we will end up creating a variable index array access\n \t     in the outermost array dimension make sure there isn't\n \t     a more inner array that the index could overflow to.  */\n-\t  if (TREE_CODE (TREE_OPERAND (op0, 0)) == ARRAY_REF)\n+\t  && TREE_CODE (TREE_OPERAND (op0, 0)) != ARRAY_REF\n+\t  && integer_zerop (TREE_OPERAND (op0, 1))\n+\t  && TREE_CODE (op1) == SSA_NAME)\n+\t{\n+\t  gimple offset_def = SSA_NAME_DEF_STMT (op1);\n+\t  tree elsz = TYPE_SIZE_UNIT (TREE_TYPE (op0));\n+\t  if (!host_integerp (elsz, 1)\n+\t      || !is_gimple_assign (offset_def))\n \t    return NULL_TREE;\n \n \t  /* Do not build array references of something that we can't\n@@ -644,15 +341,14 @@ maybe_fold_stmt_addition (location_t loc, tree res_type, tree op0, tree op1)\n \n \t  if (gimple_assign_rhs_code (offset_def) == MULT_EXPR\n \t      && TREE_CODE (gimple_assign_rhs2 (offset_def)) == INTEGER_CST\n-\t      && tree_int_cst_equal (gimple_assign_rhs2 (offset_def),\n-\t\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (op0))))\n+\t      && tree_int_cst_equal (gimple_assign_rhs2 (offset_def), elsz))\n \t    return build_fold_addr_expr\n \t\t\t  (build4 (ARRAY_REF, TREE_TYPE (op0),\n \t\t\t\t   TREE_OPERAND (op0, 0),\n \t\t\t\t   gimple_assign_rhs1 (offset_def),\n \t\t\t\t   TREE_OPERAND (op0, 2),\n \t\t\t\t   TREE_OPERAND (op0, 3)));\n-\t  else if (integer_onep (TYPE_SIZE_UNIT (TREE_TYPE (op0)))\n+\t  else if (integer_onep (elsz)\n \t\t   && gimple_assign_rhs_code (offset_def) != MULT_EXPR)\n \t    return build_fold_addr_expr\n \t\t\t  (build4 (ARRAY_REF, TREE_TYPE (op0),\n@@ -661,6 +357,38 @@ maybe_fold_stmt_addition (location_t loc, tree res_type, tree op0, tree op1)\n \t\t\t\t   TREE_OPERAND (op0, 2),\n \t\t\t\t   TREE_OPERAND (op0, 3)));\n \t}\n+      else if (TREE_CODE (TREE_TYPE (op0)) == ARRAY_TYPE\n+\t       /* Dto.  */\n+\t       && TREE_CODE (TREE_TYPE (TREE_TYPE (op0))) != ARRAY_TYPE\n+\t       && TREE_CODE (op1) == SSA_NAME)\n+\t{\n+\t  gimple offset_def = SSA_NAME_DEF_STMT (op1);\n+\t  tree elsz = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (op0)));\n+\t  if (!host_integerp (elsz, 1)\n+\t      || !is_gimple_assign (offset_def))\n+\t    return NULL_TREE;\n+\n+\t  /* Do not build array references of something that we can't\n+\t     see the true number of array dimensions for.  */\n+\t  if (!DECL_P (op0)\n+\t      && !handled_component_p (op0))\n+\t    return NULL_TREE;\n+\n+\t  if (gimple_assign_rhs_code (offset_def) == MULT_EXPR\n+\t      && TREE_CODE (gimple_assign_rhs2 (offset_def)) == INTEGER_CST\n+\t      && tree_int_cst_equal (gimple_assign_rhs2 (offset_def), elsz))\n+\t    return build_fold_addr_expr\n+\t\t\t  (build4 (ARRAY_REF, TREE_TYPE (TREE_TYPE (op0)),\n+\t\t\t\t   op0, gimple_assign_rhs1 (offset_def),\n+\t\t\t\t   integer_zero_node, NULL_TREE));\n+\t  else if (integer_onep (elsz)\n+\t\t   && gimple_assign_rhs_code (offset_def) != MULT_EXPR)\n+\t    return build_fold_addr_expr\n+\t\t\t  (build4 (ARRAY_REF, TREE_TYPE (TREE_TYPE (op0)),\n+\t\t\t\t   op0, op1,\n+\t\t\t\t   integer_zero_node, NULL_TREE));\n+\t}\n+\n       return NULL_TREE;\n     }\n \n@@ -715,13 +443,12 @@ maybe_fold_stmt_addition (location_t loc, tree res_type, tree op0, tree op1)\n     ptd_type = TREE_TYPE (TREE_TYPE (op0));\n \n   /* At which point we can try some of the same things as for indirects.  */\n-  t = maybe_fold_offset_to_array_ref (loc, op0, op1, ptd_type, true);\n-  if (!t)\n-    t = maybe_fold_offset_to_component_ref (loc, TREE_TYPE (op0), op0, op1,\n-\t\t\t\t\t    ptd_type);\n+  t = maybe_fold_offset_to_array_ref (loc, op0, op1);\n   if (t)\n     {\n-      t = build1 (ADDR_EXPR, res_type, t);\n+      t = build_fold_addr_expr (t);\n+      if (!useless_type_conversion_p (res_type, TREE_TYPE (t)))\n+\treturn NULL_TREE;\n       SET_EXPR_LOCATION (t, loc);\n     }\n \n@@ -759,19 +486,39 @@ maybe_fold_reference (tree expr, bool is_lhs)\n   while (handled_component_p (*t))\n     t = &TREE_OPERAND (*t, 0);\n \n-  if (TREE_CODE (*t) == INDIRECT_REF)\n+  /* Fold back MEM_REFs to reference trees.  */\n+  if (TREE_CODE (*t) == MEM_REF\n+      && TREE_CODE (TREE_OPERAND (*t, 0)) == ADDR_EXPR\n+      && integer_zerop (TREE_OPERAND (*t, 1))\n+      && (TREE_THIS_VOLATILE (*t)\n+\t  == TREE_THIS_VOLATILE (TREE_OPERAND (TREE_OPERAND (*t, 0), 0)))\n+      && !TYPE_REF_CAN_ALIAS_ALL (TREE_TYPE (TREE_OPERAND (*t, 1)))\n+      && (TYPE_MAIN_VARIANT (TREE_TYPE (*t))\n+\t  == TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (TREE_OPERAND (*t, 1)))))\n+      /* We have to look out here to not drop a required conversion\n+\t from the rhs to the lhs if is_lhs, but we don't have the\n+\t rhs here to verify that.  Thus require strict type\n+\t compatibility.  */\n+      && types_compatible_p (TREE_TYPE (*t),\n+\t\t\t     TREE_TYPE (TREE_OPERAND\n+\t\t\t\t\t  (TREE_OPERAND (*t, 0), 0))))\n     {\n-      tree tem = maybe_fold_stmt_indirect (*t, TREE_OPERAND (*t, 0),\n-\t\t\t\t\t   integer_zero_node);\n-      /* Avoid folding *\"abc\" = 5 into 'a' = 5.  */\n-      if (is_lhs && tem && CONSTANT_CLASS_P (tem))\n-\ttem = NULL_TREE;\n-      if (!tem\n-\t  && TREE_CODE (TREE_OPERAND (*t, 0)) == ADDR_EXPR)\n-\t/* If we had a good reason for propagating the address here,\n-\t   make sure we end up with valid gimple.  See PR34989.  */\n-\ttem = TREE_OPERAND (TREE_OPERAND (*t, 0), 0);\n-\n+      tree tem;\n+      *t = TREE_OPERAND (TREE_OPERAND (*t, 0), 0);\n+      tem = maybe_fold_reference (expr, is_lhs);\n+      if (tem)\n+\treturn tem;\n+      return expr;\n+    }\n+  /* Canonicalize MEM_REFs invariant address operand.  */\n+  else if (TREE_CODE (*t) == MEM_REF\n+\t   && TREE_CODE (TREE_OPERAND (*t, 0)) == ADDR_EXPR\n+\t   && !DECL_P (TREE_OPERAND (TREE_OPERAND (*t, 0), 0))\n+\t   && !CONSTANT_CLASS_P (TREE_OPERAND (TREE_OPERAND (*t, 0), 0)))\n+    {\n+      tree tem = fold_binary (MEM_REF, TREE_TYPE (*t),\n+\t\t\t      TREE_OPERAND (*t, 0),\n+\t\t\t      TREE_OPERAND (*t, 1));\n       if (tem)\n \t{\n \t  *t = tem;\n@@ -863,10 +610,18 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n \n \telse if (TREE_CODE (rhs) == ADDR_EXPR)\n \t  {\n-\t    tree tem = maybe_fold_reference (TREE_OPERAND (rhs, 0), true);\n-\t    if (tem)\n+\t    tree ref = TREE_OPERAND (rhs, 0);\n+\t    tree tem = maybe_fold_reference (ref, true);\n+\t    if (tem\n+\t\t&& TREE_CODE (tem) == MEM_REF\n+\t\t&& integer_zerop (TREE_OPERAND (tem, 1)))\n+\t      result = fold_convert (TREE_TYPE (rhs), TREE_OPERAND (tem, 0));\n+\t    else if (tem)\n \t      result = fold_convert (TREE_TYPE (rhs),\n \t\t\t\t     build_fold_addr_expr_loc (loc, tem));\n+\t    else if (TREE_CODE (ref) == MEM_REF\n+\t\t     && integer_zerop (TREE_OPERAND (ref, 1)))\n+\t      result = fold_convert (TREE_TYPE (rhs), TREE_OPERAND (ref, 0));\n \t  }\n \n \telse if (TREE_CODE (rhs) == CONSTRUCTOR\n@@ -1580,7 +1335,7 @@ gimple_get_relevant_ref_binfo (tree ref, tree known_binfo)\n \treturn TYPE_BINFO (TREE_TYPE (ref));\n       else if (known_binfo\n \t       && (TREE_CODE (ref) == SSA_NAME\n-\t\t   || TREE_CODE (ref) == INDIRECT_REF))\n+\t\t   || TREE_CODE (ref) == MEM_REF))\n \treturn known_binfo;\n       else\n \treturn NULL_TREE;"}, {"sha": "2359e0e954a4a1f2ae73080df77d9529382722e7", "filename": "gcc/gimple.c", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -2595,7 +2595,8 @@ is_gimple_condexpr (tree t)\n bool\n is_gimple_addressable (tree t)\n {\n-  return (is_gimple_id (t) || handled_component_p (t) || INDIRECT_REF_P (t));\n+  return (is_gimple_id (t) || handled_component_p (t)\n+\t  || TREE_CODE (t) == MEM_REF);\n }\n \n /* Return true if T is a valid gimple constant.  */\n@@ -2646,7 +2647,7 @@ is_gimple_address (const_tree t)\n       op = TREE_OPERAND (op, 0);\n     }\n \n-  if (CONSTANT_CLASS_P (op) || INDIRECT_REF_P (op))\n+  if (CONSTANT_CLASS_P (op) || TREE_CODE (op) == MEM_REF)\n     return true;\n \n   switch (TREE_CODE (op))\n@@ -2706,8 +2707,18 @@ is_gimple_invariant_address (const_tree t)\n     return false;\n \n   op = strip_invariant_refs (TREE_OPERAND (t, 0));\n+  if (!op)\n+    return false;\n \n-  return op && (CONSTANT_CLASS_P (op) || decl_address_invariant_p (op));\n+  if (TREE_CODE (op) == MEM_REF)\n+    {\n+      const_tree op0 = TREE_OPERAND (op, 0);\n+      return (TREE_CODE (op0) == ADDR_EXPR\n+\t      && (CONSTANT_CLASS_P (TREE_OPERAND (op0, 0))\n+\t\t  || decl_address_invariant_p (TREE_OPERAND (op0, 0))));\n+    }\n+\n+  return CONSTANT_CLASS_P (op) || decl_address_invariant_p (op);\n }\n \n /* Return true if T is a gimple invariant address at IPA level\n@@ -2924,7 +2935,7 @@ is_gimple_min_lval (tree t)\n {\n   if (!(t = CONST_CAST_TREE (strip_invariant_refs (t))))\n     return false;\n-  return (is_gimple_id (t) || TREE_CODE (t) == INDIRECT_REF);\n+  return (is_gimple_id (t) || TREE_CODE (t) == MEM_REF);\n }\n \n /* Return true if T is a typecast operation.  */\n@@ -2944,6 +2955,18 @@ is_gimple_call_addr (tree t)\n   return (TREE_CODE (t) == OBJ_TYPE_REF || is_gimple_val (t));\n }\n \n+/* Return true if T is a valid address operand of a MEM_REF.  */\n+\n+bool\n+is_gimple_mem_ref_addr (tree t)\n+{\n+  return (is_gimple_reg (t)\n+\t  || TREE_CODE (t) == INTEGER_CST\n+\t  || (TREE_CODE (t) == ADDR_EXPR\n+\t      && (CONSTANT_CLASS_P (TREE_OPERAND (t, 0))\n+\t\t  || decl_address_invariant_p (TREE_OPERAND (t, 0)))));\n+}\n+\n /* If T makes a function call, return the corresponding CALL_EXPR operand.\n    Otherwise, return NULL_TREE.  */\n \n@@ -2975,10 +2998,15 @@ get_base_address (tree t)\n   while (handled_component_p (t))\n     t = TREE_OPERAND (t, 0);\n \n+  if (TREE_CODE (t) == MEM_REF\n+      && TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR)\n+    t = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n+\n   if (SSA_VAR_P (t)\n       || TREE_CODE (t) == STRING_CST\n       || TREE_CODE (t) == CONSTRUCTOR\n-      || INDIRECT_REF_P (t))\n+      || INDIRECT_REF_P (t)\n+      || TREE_CODE (t) == MEM_REF)\n     return t;\n   else\n     return NULL_TREE;\n@@ -4418,7 +4446,7 @@ count_ptr_derefs (tree *tp, int *walk_subtrees, void *data)\n       return NULL_TREE;\n     }\n \n-  if (INDIRECT_REF_P (*tp) && TREE_OPERAND (*tp, 0) == count_p->ptr)\n+  if (TREE_CODE (*tp) == MEM_REF && TREE_OPERAND (*tp, 0) == count_p->ptr)\n     {\n       if (wi_p->is_lhs)\n \tcount_p->num_stores++;\n@@ -4491,6 +4519,7 @@ get_base_loadstore (tree op)\n     op = TREE_OPERAND (op, 0);\n   if (DECL_P (op)\n       || INDIRECT_REF_P (op)\n+      || TREE_CODE (op) == MEM_REF\n       || TREE_CODE (op) == TARGET_MEM_REF)\n     return op;\n   return NULL_TREE;"}, {"sha": "7d2289b5dddf0a8ae44307ee7413acf1730f4ef2", "filename": "gcc/gimple.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -933,6 +933,8 @@ extern bool is_gimple_ip_invariant (const_tree);\n extern bool is_gimple_val (tree);\n /* Returns true iff T is a GIMPLE asm statement input.  */\n extern bool is_gimple_asm_val (tree);\n+/* Returns true iff T is a valid address operand of a MEM_REF.  */\n+bool is_gimple_mem_ref_addr (tree);\n /* Returns true iff T is a valid rhs for a MODIFY_EXPR where the LHS is a\n    GIMPLE temporary, a renamed user variable, or something else,\n    respectively.  */\n@@ -2037,7 +2039,18 @@ gimple_call_fndecl (const_gimple gs)\n {\n   tree addr = gimple_call_fn (gs);\n   if (TREE_CODE (addr) == ADDR_EXPR)\n-    return TREE_OPERAND (addr, 0);\n+    {\n+      tree fndecl = TREE_OPERAND (addr, 0);\n+      if (TREE_CODE (fndecl) == MEM_REF)\n+\t{\n+\t  if (TREE_CODE (TREE_OPERAND (fndecl, 0)) == ADDR_EXPR\n+\t      && integer_zerop (TREE_OPERAND (fndecl, 1)))\n+\t    return TREE_OPERAND (TREE_OPERAND (fndecl, 0), 0);\n+\t  else\n+\t    return NULL_TREE;\n+\t}\n+      return TREE_OPERAND (addr, 0);\n+    }\n   return NULL_TREE;\n }\n \n@@ -4857,8 +4870,8 @@ void gimplify_and_update_call_from_tree (gimple_stmt_iterator *, tree);\n tree gimple_fold_builtin (gimple);\n bool fold_stmt (gimple_stmt_iterator *);\n bool fold_stmt_inplace (gimple);\n-tree maybe_fold_offset_to_reference (location_t, tree, tree, tree);\n tree maybe_fold_offset_to_address (location_t, tree, tree, tree);\n+tree maybe_fold_offset_to_reference (location_t, tree, tree, tree);\n tree maybe_fold_stmt_addition (location_t, tree, tree, tree);\n tree get_symbol_constant_value (tree);\n bool may_propagate_address_into_dereference (tree, tree);"}, {"sha": "a9c93ac972d0e17e997f69f462fb88904540950f", "filename": "gcc/gimplify.c", "status": "modified", "additions": 96, "deletions": 50, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -110,10 +110,13 @@ mark_addressable (tree x)\n {\n   while (handled_component_p (x))\n     x = TREE_OPERAND (x, 0);\n+  if (TREE_CODE (x) == MEM_REF\n+      && TREE_CODE (TREE_OPERAND (x, 0)) == ADDR_EXPR)\n+    x = TREE_OPERAND (TREE_OPERAND (x, 0), 0);\n   if (TREE_CODE (x) != VAR_DECL\n       && TREE_CODE (x) != PARM_DECL\n       && TREE_CODE (x) != RESULT_DECL)\n-    return ;\n+    return;\n   TREE_ADDRESSABLE (x) = 1;\n }\n \n@@ -2961,7 +2964,7 @@ gimplify_cond_expr (tree *expr_p, gimple_seq *pre_p, fallback_t fallback)\n \t    = build3 (COND_EXPR, type, TREE_OPERAND (expr, 0), then_, else_);\n \n \t  tmp = create_tmp_var (type, \"iftmp\");\n-\t  result = build_fold_indirect_ref_loc (loc, tmp);\n+\t  result = build_simple_mem_ref_loc (loc, tmp);\n \t}\n \n       /* Build the new then clause, `tmp = then_;'.  But don't build the\n@@ -3185,7 +3188,7 @@ gimplify_modify_expr_to_memcpy (tree *expr_p, tree size, bool want_value,\n       gimple_call_set_lhs (gs, t);\n       gimplify_seq_add_stmt (seq_p, gs);\n \n-      *expr_p = build1 (INDIRECT_REF, TREE_TYPE (to), t);\n+      *expr_p = build_simple_mem_ref (t);\n       return GS_ALL_DONE;\n     }\n \n@@ -3269,13 +3272,16 @@ gimplify_init_ctor_preeval_1 (tree *tp, int *walk_subtrees, void *xdata)\n   /* If the constructor component is indirect, determine if we have a\n      potential overlap with the lhs.  The only bits of information we\n      have to go on at this point are addressability and alias sets.  */\n-  if (TREE_CODE (t) == INDIRECT_REF\n+  if ((INDIRECT_REF_P (t)\n+       || TREE_CODE (t) == MEM_REF)\n       && (!data->lhs_base_decl || TREE_ADDRESSABLE (data->lhs_base_decl))\n       && alias_sets_conflict_p (data->lhs_alias_set, get_alias_set (t)))\n     return t;\n \n   /* If the constructor component is a call, determine if it can hide a\n-     potential overlap with the lhs through an INDIRECT_REF like above.  */\n+     potential overlap with the lhs through an INDIRECT_REF like above.\n+     ??? Ugh - this is completely broken.  In fact this whole analysis\n+     doesn't look conservative.  */\n   if (TREE_CODE (t) == CALL_EXPR)\n     {\n       tree type, fntype = TREE_TYPE (TREE_TYPE (CALL_EXPR_FN (t)));\n@@ -4004,7 +4010,7 @@ gimplify_init_constructor (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n tree\n gimple_fold_indirect_ref (tree t)\n {\n-  tree type = TREE_TYPE (TREE_TYPE (t));\n+  tree ptype = TREE_TYPE (t), type = TREE_TYPE (ptype);\n   tree sub = t;\n   tree subtype;\n \n@@ -4047,51 +4053,52 @@ gimple_fold_indirect_ref (tree t)\n         }\n     }\n \n-  /* ((foo*)&vectorfoo)[1] => BIT_FIELD_REF<vectorfoo,...> */\n+  /* *(p + CST) -> ...  */\n   if (TREE_CODE (sub) == POINTER_PLUS_EXPR\n       && TREE_CODE (TREE_OPERAND (sub, 1)) == INTEGER_CST)\n     {\n-      tree op00 = TREE_OPERAND (sub, 0);\n-      tree op01 = TREE_OPERAND (sub, 1);\n-      tree op00type;\n+      tree addr = TREE_OPERAND (sub, 0);\n+      tree off = TREE_OPERAND (sub, 1);\n+      tree addrtype;\n+\n+      STRIP_NOPS (addr);\n+      addrtype = TREE_TYPE (addr);\n \n-      STRIP_NOPS (op00);\n-      op00type = TREE_TYPE (op00);\n-      if (TREE_CODE (op00) == ADDR_EXPR\n-\t  && TREE_CODE (TREE_TYPE (op00type)) == VECTOR_TYPE\n-\t  && useless_type_conversion_p (type, TREE_TYPE (TREE_TYPE (op00type))))\n+      /* ((foo*)&vectorfoo)[1] -> BIT_FIELD_REF<vectorfoo,...> */\n+      if (TREE_CODE (addr) == ADDR_EXPR\n+\t  && TREE_CODE (TREE_TYPE (addrtype)) == VECTOR_TYPE\n+\t  && useless_type_conversion_p (type, TREE_TYPE (TREE_TYPE (addrtype))))\n \t{\n-\t  HOST_WIDE_INT offset = tree_low_cst (op01, 0);\n-\t  tree part_width = TYPE_SIZE (type);\n-\t  unsigned HOST_WIDE_INT part_widthi\n-\t    = tree_low_cst (part_width, 0) / BITS_PER_UNIT;\n-\t  unsigned HOST_WIDE_INT indexi = offset * BITS_PER_UNIT;\n-\t  tree index = bitsize_int (indexi);\n-\t  if (offset / part_widthi\n-\t      <= TYPE_VECTOR_SUBPARTS (TREE_TYPE (op00type)))\n-\t    return fold_build3 (BIT_FIELD_REF, type, TREE_OPERAND (op00, 0),\n-\t\t\t\tpart_width, index);\n+          HOST_WIDE_INT offset = tree_low_cst (off, 0);\n+          tree part_width = TYPE_SIZE (type);\n+          unsigned HOST_WIDE_INT part_widthi\n+            = tree_low_cst (part_width, 0) / BITS_PER_UNIT;\n+          unsigned HOST_WIDE_INT indexi = offset * BITS_PER_UNIT;\n+          tree index = bitsize_int (indexi);\n+          if (offset / part_widthi\n+              <= TYPE_VECTOR_SUBPARTS (TREE_TYPE (addrtype)))\n+            return fold_build3 (BIT_FIELD_REF, type, TREE_OPERAND (addr, 0),\n+                                part_width, index);\n \t}\n-    }\n \n-  /* ((foo*)&complexfoo)[1] => __imag__ complexfoo */\n-  if (TREE_CODE (sub) == POINTER_PLUS_EXPR\n-      && TREE_CODE (TREE_OPERAND (sub, 1)) == INTEGER_CST)\n-    {\n-      tree op00 = TREE_OPERAND (sub, 0);\n-      tree op01 = TREE_OPERAND (sub, 1);\n-      tree op00type;\n+      /* ((foo*)&complexfoo)[1] -> __imag__ complexfoo */\n+      if (TREE_CODE (addr) == ADDR_EXPR\n+\t  && TREE_CODE (TREE_TYPE (addrtype)) == COMPLEX_TYPE\n+\t  && useless_type_conversion_p (type, TREE_TYPE (TREE_TYPE (addrtype))))\n+        {\n+          tree size = TYPE_SIZE_UNIT (type);\n+          if (tree_int_cst_equal (size, off))\n+            return fold_build1 (IMAGPART_EXPR, type, TREE_OPERAND (addr, 0));\n+        }\n \n-      STRIP_NOPS (op00);\n-      op00type = TREE_TYPE (op00);\n-      if (TREE_CODE (op00) == ADDR_EXPR\n-\t  && TREE_CODE (TREE_TYPE (op00type)) == COMPLEX_TYPE\n-\t  && useless_type_conversion_p (type, TREE_TYPE (TREE_TYPE (op00type))))\n-\t{\n-\t  tree size = TYPE_SIZE_UNIT (type);\n-\t  if (tree_int_cst_equal (size, op01))\n-\t    return fold_build1 (IMAGPART_EXPR, type, TREE_OPERAND (op00, 0));\n-\t}\n+      /* *(p + CST) -> MEM_REF <p, CST>.  */\n+      if (TREE_CODE (addr) != ADDR_EXPR\n+\t  || DECL_P (TREE_OPERAND (addr, 0)))\n+\treturn fold_build2 (MEM_REF, type,\n+\t\t\t    addr,\n+\t\t\t    build_int_cst_wide (ptype,\n+\t\t\t\t\t\tTREE_INT_CST_LOW (off),\n+\t\t\t\t\t\tTREE_INT_CST_HIGH (off)));\n     }\n \n   /* *(foo *)fooarrptr => (*fooarrptr)[0] */\n@@ -6558,7 +6565,8 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n            || gimple_test_f == is_gimple_mem_rhs_or_call\n            || gimple_test_f == is_gimple_reg_rhs\n            || gimple_test_f == is_gimple_reg_rhs_or_call\n-           || gimple_test_f == is_gimple_asm_val)\n+           || gimple_test_f == is_gimple_asm_val\n+\t   || gimple_test_f == is_gimple_mem_ref_addr)\n     gcc_assert (fallback & fb_rvalue);\n   else if (gimple_test_f == is_gimple_min_lval\n \t   || gimple_test_f == is_gimple_lvalue)\n@@ -6764,19 +6772,57 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  recalculate_side_effects (*expr_p);\n \t  break;\n \n+\tcase ALIGN_INDIRECT_REF:\n+\tcase MISALIGNED_INDIRECT_REF:\n+\t  /* We can only reach this through re-gimplification from\n+\t     tree optimizers.  */\n+\t  ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n+\t\t\t       is_gimple_reg, fb_rvalue);\n+\t  recalculate_side_effects (*expr_p);\n+\t  break;\n+\n \tcase INDIRECT_REF:\n-\t  *expr_p = fold_indirect_ref_loc (input_location, *expr_p);\n-\t  if (*expr_p != save_expr)\n+\t  {\n+\t    bool volatilep = TREE_THIS_VOLATILE (*expr_p);\n+\t    tree saved_ptr_type = TREE_TYPE (TREE_OPERAND (*expr_p, 0));\n+\n+\t    *expr_p = fold_indirect_ref_loc (input_location, *expr_p);\n+\t    if (*expr_p != save_expr)\n+\t      {\n+\t\tret = GS_OK;\n+\t\tbreak;\n+\t      }\n+\n+\t    ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n+\t\t\t\t is_gimple_reg, fb_rvalue);\n+\t    recalculate_side_effects (*expr_p);\n+\n+\t    *expr_p = fold_build2_loc (input_location, MEM_REF,\n+\t\t\t\t       TREE_TYPE (*expr_p),\n+\t\t\t\t       TREE_OPERAND (*expr_p, 0),\n+\t\t\t\t       build_int_cst (saved_ptr_type, 0));\n+\t    TREE_THIS_VOLATILE (*expr_p) = volatilep;\n+\t    ret = GS_OK;\n+\t    break;\n+\t  }\n+\n+\t/* We arrive here through the various re-gimplifcation paths.  */\n+\tcase MEM_REF:\n+\t  /* First try re-folding the whole thing.  */\n+\t  tmp = fold_binary (MEM_REF, TREE_TYPE (*expr_p),\n+\t\t\t     TREE_OPERAND (*expr_p, 0),\n+\t\t\t     TREE_OPERAND (*expr_p, 1));\n+\t  if (tmp)\n \t    {\n+\t      *expr_p = tmp;\n+\t      recalculate_side_effects (*expr_p);\n \t      ret = GS_OK;\n \t      break;\n \t    }\n-\t  /* else fall through.  */\n-\tcase ALIGN_INDIRECT_REF:\n-\tcase MISALIGNED_INDIRECT_REF:\n \t  ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n-\t\t\t       is_gimple_reg, fb_rvalue);\n+\t\t\t       is_gimple_mem_ref_addr, fb_rvalue);\n \t  recalculate_side_effects (*expr_p);\n+\t  ret = GS_ALL_DONE;\n \t  break;\n \n \t  /* Constants need not be gimplified.  */"}, {"sha": "691bf6ca771ca130cb7ce1e60882e8d28a87ca0f", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1832,10 +1832,12 @@ likely_eliminated_by_inlining_p (gimple stmt)\n \t    bool rhs_free = false;\n \t    bool lhs_free = false;\n \n- \t    while (handled_component_p (inner_lhs) || TREE_CODE (inner_lhs) == INDIRECT_REF)\n+ \t    while (handled_component_p (inner_lhs)\n+\t\t   || TREE_CODE (inner_lhs) == MEM_REF)\n \t      inner_lhs = TREE_OPERAND (inner_lhs, 0);\n  \t    while (handled_component_p (inner_rhs)\n-\t           || TREE_CODE (inner_rhs) == ADDR_EXPR || TREE_CODE (inner_rhs) == INDIRECT_REF)\n+\t           || TREE_CODE (inner_rhs) == ADDR_EXPR\n+\t\t   || TREE_CODE (inner_rhs) == MEM_REF)\n \t      inner_rhs = TREE_OPERAND (inner_rhs, 0);\n \n \n@@ -1855,7 +1857,8 @@ likely_eliminated_by_inlining_p (gimple stmt)\n \t        || (TREE_CODE (inner_lhs) == SSA_NAME\n \t\t    && TREE_CODE (SSA_NAME_VAR (inner_lhs)) == RESULT_DECL))\n \t      lhs_free = true;\n-\t    if (lhs_free && (is_gimple_reg (rhs) || is_gimple_min_invariant (rhs)))\n+\t    if (lhs_free\n+\t\t&& (is_gimple_reg (rhs) || is_gimple_min_invariant (rhs)))\n \t      rhs_free = true;\n \t    if (lhs_free && rhs_free)\n \t      return true;"}, {"sha": "9bd07f039b98870499fe57ba4e50363cf1c72217", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -405,11 +405,12 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n   if (TREE_CODE (type) != RECORD_TYPE)\n     return;\n   op1 = get_ref_base_and_extent (op1, &offset, &size, &max_size);\n-  if (TREE_CODE (op1) != INDIRECT_REF\n+  if (TREE_CODE (op1) != MEM_REF\n       /* If this is a varying address, punt.  */\n       || max_size == -1\n       || max_size != size)\n     return;\n+  offset += mem_ref_offset (op1).low * BITS_PER_UNIT;\n   op1 = TREE_OPERAND (op1, 0);\n   if (TREE_CODE (op1) != SSA_NAME\n       || !SSA_NAME_IS_DEFAULT_DEF (op1))\n@@ -481,11 +482,12 @@ compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n   expr = TREE_OPERAND (expr, 0);\n   expr = get_ref_base_and_extent (expr, &offset, &size, &max_size);\n \n-  if (TREE_CODE (expr) != INDIRECT_REF\n+  if (TREE_CODE (expr) != MEM_REF\n       /* If this is a varying address, punt.  */\n       || max_size == -1\n       || max_size != size)\n     return;\n+  offset += mem_ref_offset (expr).low * BITS_PER_UNIT;\n   parm = TREE_OPERAND (expr, 0);\n   if (TREE_CODE (parm) != SSA_NAME\n       || !SSA_NAME_IS_DEFAULT_DEF (parm))\n@@ -1179,7 +1181,7 @@ ipa_analyze_virtual_call_uses (struct cgraph_node *node,\n \t  obj = TREE_OPERAND (obj, 0);\n \t}\n       while (TREE_CODE (obj) == COMPONENT_REF);\n-      if (TREE_CODE (obj) != INDIRECT_REF)\n+      if (TREE_CODE (obj) != MEM_REF)\n \treturn;\n       obj = TREE_OPERAND (obj, 0);\n     }"}, {"sha": "741742961cb60a57cb61a1f0defe8a3b7ad6aeb8", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -324,7 +324,7 @@ check_op (funct_state local, tree t, bool checking_write)\n       return;\n     }\n   else if (t\n-  \t   && INDIRECT_REF_P (t)\n+  \t   && (INDIRECT_REF_P (t) || TREE_CODE (t) == MEM_REF)\n \t   && TREE_CODE (TREE_OPERAND (t, 0)) == SSA_NAME\n \t   && !ptr_deref_may_alias_global_p (TREE_OPERAND (t, 0)))\n     {"}, {"sha": "98ad91f8508d34c6033b4bcc6199636552139928", "filename": "gcc/ipa-struct-reorg.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fipa-struct-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fipa-struct-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -421,6 +421,10 @@ decompose_indirect_ref_acc (tree str_decl, struct field_access_site *acc)\n   if (!is_result_of_mult (before_cast, &acc->num, struct_size))\n     return false;\n \n+  /* ???  Add TREE_OPERAND (acc->ref, 1) to acc->offset.  */\n+  if (!integer_zerop (TREE_OPERAND (acc->ref, 1)))\n+    return false;\n+\n   return true;\n }\n \n@@ -434,7 +438,7 @@ decompose_access (tree str_decl, struct field_access_site *acc)\n {\n   gcc_assert (acc->ref);\n \n-  if (TREE_CODE (acc->ref) == INDIRECT_REF)\n+  if (TREE_CODE (acc->ref) == MEM_REF)\n     return decompose_indirect_ref_acc (str_decl, acc);\n   else if (TREE_CODE (acc->ref) == ARRAY_REF)\n     return true;\n@@ -969,12 +973,12 @@ replace_field_acc (struct field_access_site *acc, tree new_type)\n   type_wrapper_t *wr_p = NULL;\n   struct ref_pos r_pos;\n \n-  while (TREE_CODE (ref_var) == INDIRECT_REF\n+  while (TREE_CODE (ref_var) == MEM_REF\n \t || TREE_CODE (ref_var) == ARRAY_REF)\n     {\n       type_wrapper_t wr;\n \n-      if ( TREE_CODE (ref_var) == INDIRECT_REF)\n+      if (TREE_CODE (ref_var) == MEM_REF)\n \t{\n \t  wr.wrap = 0;\n \t  wr.domain = 0;\n@@ -1001,7 +1005,7 @@ replace_field_acc (struct field_access_site *acc, tree new_type)\n \tnew_ref = build4 (ARRAY_REF, type, new_ref,\n \t\t\t  wr_p->domain, NULL_TREE, NULL_TREE);\n       else /* Pointer.  */\n-\tnew_ref = build1 (INDIRECT_REF, type, new_ref);\n+\tnew_ref = build_simple_mem_ref (new_ref);\n       VEC_pop (type_wrapper_t, wrapper);\n     }\n \n@@ -1041,7 +1045,7 @@ static void\n replace_field_access_stmt (struct field_access_site *acc, tree new_type)\n {\n \n-  if (TREE_CODE (acc->ref) == INDIRECT_REF\n+  if (TREE_CODE (acc->ref) == MEM_REF\n       ||TREE_CODE (acc->ref) == ARRAY_REF\n       ||TREE_CODE (acc->ref) == VAR_DECL)\n     replace_field_acc (acc, new_type);\n@@ -1277,13 +1281,11 @@ insert_new_var_in_stmt (gimple stmt, tree var, tree new_var)\n   pos = find_pos_in_stmt (stmt, var, &r_pos);\n   gcc_assert (pos);\n \n-  while (r_pos.container && (TREE_CODE(r_pos.container) == INDIRECT_REF\n+  while (r_pos.container && (TREE_CODE(r_pos.container) == MEM_REF\n \t\t\t     || TREE_CODE(r_pos.container) == ADDR_EXPR))\n     {\n-      tree type = TREE_TYPE (TREE_TYPE (new_var));\n-\n-      if (TREE_CODE(r_pos.container) == INDIRECT_REF)\n-\tnew_var = build1 (INDIRECT_REF, type, new_var);\n+      if (TREE_CODE(r_pos.container) == MEM_REF)\n+\tnew_var = build_simple_mem_ref (new_var);\n       else\n \tnew_var = build_fold_addr_expr (new_var);\n       pos = find_pos_in_stmt (stmt, r_pos.container, &r_pos);\n@@ -2530,7 +2532,7 @@ get_stmt_accesses (tree *tp, int *walk_subtrees, void *data)\n \ttree field_decl = TREE_OPERAND (t, 1);\n \n \n-\tif ((TREE_CODE (ref) == INDIRECT_REF\n+\tif ((TREE_CODE (ref) == MEM_REF\n \t     || TREE_CODE (ref) == ARRAY_REF\n \t     || TREE_CODE (ref) == VAR_DECL)\n \t    && TREE_CODE (field_decl) == FIELD_DECL)\n@@ -4031,7 +4033,10 @@ reorg_structs (void)\n static unsigned int\n reorg_structs_drive (void)\n {\n-  reorg_structs ();\n+  /* IPA struct-reorg is completely broken - its analysis phase is\n+     non-conservative (which is not the only reason it is broken).  */\n+  if (0)\n+    reorg_structs ();\n   return 0;\n }\n "}, {"sha": "84c6e6ea3c2e2e69471efd56f0c4ee7f962ba9d0", "filename": "gcc/matrix-reorg.c", "status": "modified", "additions": 28, "deletions": 52, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -218,7 +218,7 @@ collect_data_for_malloc_call (gimple stmt, struct malloc_call_data *m_data)\n    initial address and index of each dimension.  */\n struct access_site_info\n {\n-  /* The statement (INDIRECT_REF or POINTER_PLUS_EXPR).  */\n+  /* The statement (MEM_REF or POINTER_PLUS_EXPR).  */\n   gimple stmt;\n \n   /* In case of POINTER_PLUS_EXPR, what is the offset.  */\n@@ -334,7 +334,7 @@ struct ssa_acc_in_tree\n   /* The variable whose accesses in the tree we are looking for.  */\n   tree ssa_var;\n   /* The tree and code inside it the ssa_var is accessed, currently\n-     it could be an INDIRECT_REF or CALL_EXPR.  */\n+     it could be an MEM_REF or CALL_EXPR.  */\n   enum tree_code t_code;\n   tree t_tree;\n   /* The place in the containing tree.  */\n@@ -413,33 +413,18 @@ mtt_info_eq (const void *mtt1, const void *mtt2)\n static bool\n may_flatten_matrices_1 (gimple stmt)\n {\n-  tree t;\n-\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_ASSIGN:\n-      if (!gimple_assign_cast_p (stmt))\n+    case GIMPLE_CALL:\n+      if (!gimple_has_lhs (stmt))\n \treturn true;\n-\n-      t = gimple_assign_rhs1 (stmt);\n-      while (CONVERT_EXPR_P (t))\n+      if (TREE_CODE (TREE_TYPE (gimple_get_lhs (stmt))) == VECTOR_TYPE)\n \t{\n-\t  if (TREE_TYPE (t) && POINTER_TYPE_P (TREE_TYPE (t)))\n-\t    {\n-\t      tree pointee;\n-\n-\t      pointee = TREE_TYPE (t);\n-\t      while (POINTER_TYPE_P (pointee))\n-\t\tpointee = TREE_TYPE (pointee);\n-\t      if (TREE_CODE (pointee) == VECTOR_TYPE)\n-\t\t{\n-\t\t  if (dump_file)\n-\t\t    fprintf (dump_file,\n-\t\t\t     \"Found vector type, don't flatten matrix\\n\");\n-\t\t  return false;\n-\t\t}\n-\t    }\n-\t  t = TREE_OPERAND (t, 0);\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"Found vector type, don't flatten matrix\\n\");\n+\t  return false;\n \t}\n       break;\n     case GIMPLE_ASM:\n@@ -602,7 +587,7 @@ mark_min_matrix_escape_level (struct matrix_info *mi, int l, gimple s)\n /* Find if the SSA variable is accessed inside the\n    tree and record the tree containing it.\n    The only relevant uses are the case of SSA_NAME, or SSA inside\n-   INDIRECT_REF, PLUS_EXPR, POINTER_PLUS_EXPR, MULT_EXPR.  */\n+   MEM_REF, PLUS_EXPR, POINTER_PLUS_EXPR, MULT_EXPR.  */\n static void\n ssa_accessed_in_tree (tree t, struct ssa_acc_in_tree *a)\n {\n@@ -613,7 +598,7 @@ ssa_accessed_in_tree (tree t, struct ssa_acc_in_tree *a)\n       if (t == a->ssa_var)\n \ta->var_found = true;\n       break;\n-    case INDIRECT_REF:\n+    case MEM_REF:\n       if (SSA_VAR_P (TREE_OPERAND (t, 0))\n \t  && TREE_OPERAND (t, 0) == a->ssa_var)\n \ta->var_found = true;\n@@ -660,7 +645,7 @@ ssa_accessed_in_assign_rhs (gimple stmt, struct ssa_acc_in_tree *a)\n       tree op1, op2;\n \n     case SSA_NAME:\n-    case INDIRECT_REF:\n+    case MEM_REF:\n     CASE_CONVERT:\n     case VIEW_CONVERT_EXPR:\n       ssa_accessed_in_tree (gimple_assign_rhs1 (stmt), a);\n@@ -984,17 +969,17 @@ get_index_from_offset (tree offset, gimple def_stmt)\n \n /* update MI->dimension_type_size[CURRENT_INDIRECT_LEVEL] with the size\n    of the type related to the SSA_VAR, or the type related to the\n-   lhs of STMT, in the case that it is an INDIRECT_REF.  */\n+   lhs of STMT, in the case that it is an MEM_REF.  */\n static void\n update_type_size (struct matrix_info *mi, gimple stmt, tree ssa_var,\n \t\t  int current_indirect_level)\n {\n   tree lhs;\n   HOST_WIDE_INT type_size;\n \n-  /* Update type according to the type of the INDIRECT_REF expr.   */\n+  /* Update type according to the type of the MEM_REF expr.   */\n   if (is_gimple_assign (stmt)\n-      && TREE_CODE (gimple_assign_lhs (stmt)) == INDIRECT_REF)\n+      && TREE_CODE (gimple_assign_lhs (stmt)) == MEM_REF)\n     {\n       lhs = gimple_assign_lhs (stmt);\n       gcc_assert (POINTER_TYPE_P\n@@ -1073,7 +1058,7 @@ analyze_accesses_for_call_stmt (struct matrix_info *mi, tree ssa_var,\n \t at this level because in this case we cannot calculate the\n \t address correctly.  */\n       if ((lhs_acc.var_found && rhs_acc.var_found\n-\t   && lhs_acc.t_code == INDIRECT_REF)\n+\t   && lhs_acc.t_code == MEM_REF)\n \t  || (!rhs_acc.var_found && !lhs_acc.var_found))\n \t{\n \t  mark_min_matrix_escape_level (mi, current_indirect_level, use_stmt);\n@@ -1087,7 +1072,7 @@ analyze_accesses_for_call_stmt (struct matrix_info *mi, tree ssa_var,\n \t{\n \t  int l = current_indirect_level + 1;\n \n-\t  gcc_assert (lhs_acc.t_code == INDIRECT_REF);\n+\t  gcc_assert (lhs_acc.t_code == MEM_REF);\n \t  mark_min_matrix_escape_level (mi, l, use_stmt);\n \t  return current_indirect_level;\n \t}\n@@ -1213,7 +1198,7 @@ analyze_accesses_for_assign_stmt (struct matrix_info *mi, tree ssa_var,\n      at this level because in this case we cannot calculate the\n      address correctly.  */\n   if ((lhs_acc.var_found && rhs_acc.var_found\n-       && lhs_acc.t_code == INDIRECT_REF)\n+       && lhs_acc.t_code == MEM_REF)\n       || (!rhs_acc.var_found && !lhs_acc.var_found))\n     {\n       mark_min_matrix_escape_level (mi, current_indirect_level, use_stmt);\n@@ -1227,7 +1212,7 @@ analyze_accesses_for_assign_stmt (struct matrix_info *mi, tree ssa_var,\n     {\n       int l = current_indirect_level + 1;\n \n-      gcc_assert (lhs_acc.t_code == INDIRECT_REF);\n+      gcc_assert (lhs_acc.t_code == MEM_REF);\n \n       if (!(gimple_assign_copy_p (use_stmt)\n \t    || gimple_assign_cast_p (use_stmt))\n@@ -1248,15 +1233,15 @@ analyze_accesses_for_assign_stmt (struct matrix_info *mi, tree ssa_var,\n      is used.  */\n   if (rhs_acc.var_found)\n     {\n-      if (rhs_acc.t_code != INDIRECT_REF\n+      if (rhs_acc.t_code != MEM_REF\n \t  && rhs_acc.t_code != POINTER_PLUS_EXPR && rhs_acc.t_code != SSA_NAME)\n \t{\n \t  mark_min_matrix_escape_level (mi, current_indirect_level, use_stmt);\n \t  return current_indirect_level;\n \t}\n       /* If the access in the RHS has an indirection increase the\n          indirection level.  */\n-      if (rhs_acc.t_code == INDIRECT_REF)\n+      if (rhs_acc.t_code == MEM_REF)\n \t{\n \t  if (record_accesses)\n \t    record_access_alloc_site_info (mi, use_stmt, NULL_TREE,\n@@ -1309,7 +1294,7 @@ analyze_accesses_for_assign_stmt (struct matrix_info *mi, tree ssa_var,\n \t}\n       /* If we are storing this level of indirection mark it as\n          escaping.  */\n-      if (lhs_acc.t_code == INDIRECT_REF || TREE_CODE (lhs) != SSA_NAME)\n+      if (lhs_acc.t_code == MEM_REF || TREE_CODE (lhs) != SSA_NAME)\n \t{\n \t  int l = current_indirect_level;\n \n@@ -1369,8 +1354,8 @@ analyze_matrix_accesses (struct matrix_info *mi, tree ssa_var,\n     return;\n \n /* Now go over the uses of the SSA_NAME and check how it is used in\n-   each one of them.  We are mainly looking for the pattern INDIRECT_REF,\n-   then a POINTER_PLUS_EXPR, then INDIRECT_REF etc.  while in between there could\n+   each one of them.  We are mainly looking for the pattern MEM_REF,\n+   then a POINTER_PLUS_EXPR, then MEM_REF etc.  while in between there could\n    be any number of copies and casts.  */\n   gcc_assert (TREE_CODE (ssa_var) == SSA_NAME);\n \n@@ -1856,7 +1841,7 @@ transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \t\t    gimple new_stmt;\n \n \t\t    gcc_assert (gimple_assign_rhs_code (acc_info->stmt)\n-\t\t\t\t== INDIRECT_REF);\n+\t\t\t\t== MEM_REF);\n \t\t    /* Emit convert statement to convert to type of use.  */\n \t\t    tmp = create_tmp_var (TREE_TYPE (lhs), \"new\");\n \t\t    add_referenced_var (tmp);\n@@ -1878,10 +1863,10 @@ transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \t  continue;\n \t}\n       code = gimple_assign_rhs_code (acc_info->stmt);\n-      if (code == INDIRECT_REF\n+      if (code == MEM_REF\n \t  && acc_info->level < min_escape_l - 1)\n \t{\n-\t  /* Replace the INDIRECT_REF with NOP (cast) usually we are casting\n+\t  /* Replace the MEM_REF with NOP (cast) usually we are casting\n \t     from \"pointer to type\" to \"type\".  */\n \t  tree t =\n \t    build1 (NOP_EXPR, TREE_TYPE (gimple_assign_rhs1 (acc_info->stmt)),\n@@ -2206,7 +2191,6 @@ transform_allocation_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n   for (i = 1; i < mi->min_indirect_level_escape; i++)\n     {\n       gimple_stmt_iterator gsi;\n-      gimple use_stmt1 = NULL;\n \n       gimple call_stmt = mi->malloc_for_level[i];\n       gcc_assert (is_gimple_call (call_stmt));\n@@ -2216,17 +2200,9 @@ transform_allocation_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n       gsi = gsi_for_stmt (call_stmt);\n       /* Remove the call stmt.  */\n       gsi_remove (&gsi, true);\n-      /* remove the type cast stmt.  */\n-      FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter,\n-\t\t\t     gimple_call_lhs (call_stmt))\n-      {\n-\tuse_stmt1 = use_stmt;\n-\tgsi = gsi_for_stmt (use_stmt);\n-\tgsi_remove (&gsi, true);\n-      }\n       /* Remove the assignment of the allocated area.  */\n       FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter,\n-\t\t\t     gimple_get_lhs (use_stmt1))\n+\t\t\t     gimple_call_lhs (call_stmt))\n       {\n \tgsi = gsi_for_stmt (use_stmt);\n \tgsi_remove (&gsi, true);"}, {"sha": "68bc84a881cddd3f0bcc34beb4e28376506387d6", "filename": "gcc/omp-low.c", "status": "modified", "additions": 43, "deletions": 28, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -864,10 +864,10 @@ build_receiver_ref (tree var, bool by_ref, omp_context *ctx)\n   if (x != NULL)\n     field = x;\n \n-  x = build_fold_indirect_ref (ctx->receiver_decl);\n+  x = build_simple_mem_ref (ctx->receiver_decl);\n   x = build3 (COMPONENT_REF, TREE_TYPE (field), x, field, NULL);\n   if (by_ref)\n-    x = build_fold_indirect_ref (x);\n+    x = build_simple_mem_ref (x);\n \n   return x;\n }\n@@ -887,7 +887,7 @@ build_outer_var_ref (tree var, omp_context *ctx)\n     {\n       x = TREE_OPERAND (DECL_VALUE_EXPR (var), 0);\n       x = build_outer_var_ref (x, ctx);\n-      x = build_fold_indirect_ref (x);\n+      x = build_simple_mem_ref (x);\n     }\n   else if (is_taskreg_ctx (ctx))\n     {\n@@ -904,7 +904,7 @@ build_outer_var_ref (tree var, omp_context *ctx)\n     gcc_unreachable ();\n \n   if (is_reference (var))\n-    x = build_fold_indirect_ref (x);\n+    x = build_simple_mem_ref (x);\n \n   return x;\n }\n@@ -1916,7 +1916,18 @@ scan_omp_1_op (tree *tp, int *walk_subtrees, void *data)\n \t{\n \t  *walk_subtrees = 1;\n \t  if (ctx)\n-\t    TREE_TYPE (t) = remap_type (TREE_TYPE (t), &ctx->cb);\n+\t    {\n+\t      tree tem = remap_type (TREE_TYPE (t), &ctx->cb);\n+\t      if (tem != TREE_TYPE (t))\n+\t\t{\n+\t\t  if (TREE_CODE (t) == INTEGER_CST)\n+\t\t    *tp = build_int_cst_wide (tem,\n+\t\t\t\t\t      TREE_INT_CST_LOW (t),\n+\t\t\t\t\t      TREE_INT_CST_HIGH (t));\n+\t\t  else\n+\t\t    TREE_TYPE (t) = tem;\n+\t\t}\n+\t    }\n \t}\n       break;\n     }\n@@ -2337,7 +2348,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t      x = fold_convert_loc (clause_loc, TREE_TYPE (new_var), x);\n \t      gimplify_assign (new_var, x, ilist);\n \n-\t      new_var = build_fold_indirect_ref_loc (clause_loc, new_var);\n+\t      new_var = build_simple_mem_ref_loc (clause_loc, new_var);\n \t    }\n \t  else if (c_kind == OMP_CLAUSE_REDUCTION\n \t\t   && OMP_CLAUSE_REDUCTION_PLACEHOLDER (c))\n@@ -2555,7 +2566,7 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n \n \t  x = build_outer_var_ref (var, ctx);\n \t  if (is_reference (var))\n-\t    new_var = build_fold_indirect_ref_loc (clause_loc, new_var);\n+\t    new_var = build_simple_mem_ref_loc (clause_loc, new_var);\n \t  x = lang_hooks.decls.omp_clause_assign_op (c, x, new_var);\n \t  gimplify_and_add (x, stmt_list);\n \t}\n@@ -2622,7 +2633,7 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp, omp_context *ctx)\n       var = OMP_CLAUSE_DECL (c);\n       new_var = lookup_decl (var, ctx);\n       if (is_reference (var))\n-\tnew_var = build_fold_indirect_ref_loc (clause_loc, new_var);\n+\tnew_var = build_simple_mem_ref_loc (clause_loc, new_var);\n       ref = build_outer_var_ref (var, ctx);\n       code = OMP_CLAUSE_REDUCTION_CODE (c);\n \n@@ -2714,8 +2725,8 @@ lower_copyprivate_clauses (tree clauses, gimple_seq *slist, gimple_seq *rlist,\n       if (is_reference (var))\n \t{\n \t  ref = fold_convert_loc (clause_loc, TREE_TYPE (new_var), ref);\n-\t  ref = build_fold_indirect_ref_loc (clause_loc, ref);\n-\t  new_var = build_fold_indirect_ref_loc (clause_loc, new_var);\n+\t  ref = build_simple_mem_ref_loc (clause_loc, ref);\n+\t  new_var = build_simple_mem_ref_loc (clause_loc, new_var);\n \t}\n       x = lang_hooks.decls.omp_clause_assign_op (c, new_var, ref);\n       gimplify_and_add (x, rlist);\n@@ -5067,8 +5078,12 @@ expand_omp_atomic_pipeline (basic_block load_bb, basic_block store_bb,\n       loadedi = loaded_val;\n     }\n \n-  initial = force_gimple_operand_gsi (&si, build_fold_indirect_ref (iaddr),\n-\t\t\t\t      true, NULL_TREE, true, GSI_SAME_STMT);\n+  initial\n+    = force_gimple_operand_gsi (&si,\n+\t\t\t\tbuild2 (MEM_REF, TREE_TYPE (TREE_TYPE (iaddr)),\n+\t\t\t\t\tiaddr,\n+\t\t\t\t\tbuild_int_cst (TREE_TYPE (iaddr), 0)),\n+\t\t\t\ttrue, NULL_TREE, true, GSI_SAME_STMT);\n \n   /* Move the value to the LOADEDI temporary.  */\n   if (gimple_in_ssa_p (cfun))\n@@ -5212,15 +5227,15 @@ expand_omp_atomic_mutex (basic_block load_bb, basic_block store_bb,\n   t = build_function_call_expr (UNKNOWN_LOCATION, t, 0);\n   force_gimple_operand_gsi (&si, t, true, NULL_TREE, true, GSI_SAME_STMT);\n \n-  stmt = gimple_build_assign (loaded_val, build_fold_indirect_ref (addr));\n+  stmt = gimple_build_assign (loaded_val, build_simple_mem_ref (addr));\n   gsi_insert_before (&si, stmt, GSI_SAME_STMT);\n   gsi_remove (&si, true);\n \n   si = gsi_last_bb (store_bb);\n   gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_ATOMIC_STORE);\n \n-  stmt = gimple_build_assign (build_fold_indirect_ref (unshare_expr (addr)),\n-\t\t\t\tstored_val);\n+  stmt = gimple_build_assign (build_simple_mem_ref (unshare_expr (addr)),\n+\t\t\t      stored_val);\n   gsi_insert_before (&si, stmt, GSI_SAME_STMT);\n \n   t = built_in_decls[BUILT_IN_GOMP_ATOMIC_END];\n@@ -6269,7 +6284,7 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n \t  n = splay_tree_lookup (ctx->sfield_map, (splay_tree_key) decl);\n \t  sf = (tree) n->value;\n \t  sf = *(tree *) pointer_map_contains (tcctx.cb.decl_map, sf);\n-\t  src = build_fold_indirect_ref_loc (loc, sarg);\n+\t  src = build_simple_mem_ref_loc (loc, sarg);\n \t  src = build3 (COMPONENT_REF, TREE_TYPE (sf), src, sf, NULL);\n \t  t = build2 (MODIFY_EXPR, TREE_TYPE (*p), *p, src);\n \t  append_to_statement_list (t, &list);\n@@ -6292,9 +6307,9 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n \tsf = (tree) n->value;\n \tif (tcctx.cb.decl_map)\n \t  sf = *(tree *) pointer_map_contains (tcctx.cb.decl_map, sf);\n-\tsrc = build_fold_indirect_ref_loc (loc, sarg);\n+\tsrc = build_simple_mem_ref_loc (loc, sarg);\n \tsrc = build3 (COMPONENT_REF, TREE_TYPE (sf), src, sf, NULL);\n-\tdst = build_fold_indirect_ref_loc (loc, arg);\n+\tdst = build_simple_mem_ref_loc (loc, arg);\n \tdst = build3 (COMPONENT_REF, TREE_TYPE (f), dst, f, NULL);\n \tt = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);\n \tappend_to_statement_list (t, &list);\n@@ -6315,14 +6330,14 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n \t    sf = (tree) n->value;\n \t    if (tcctx.cb.decl_map)\n \t      sf = *(tree *) pointer_map_contains (tcctx.cb.decl_map, sf);\n-\t    src = build_fold_indirect_ref_loc (loc, sarg);\n+\t    src = build_simple_mem_ref_loc (loc, sarg);\n \t    src = build3 (COMPONENT_REF, TREE_TYPE (sf), src, sf, NULL);\n \t    if (use_pointer_for_field (decl, NULL) || is_reference (decl))\n-\t      src = build_fold_indirect_ref_loc (loc, src);\n+\t      src = build_simple_mem_ref_loc (loc, src);\n \t  }\n \telse\n \t  src = decl;\n-\tdst = build_fold_indirect_ref_loc (loc, arg);\n+\tdst = build_simple_mem_ref_loc (loc, arg);\n \tdst = build3 (COMPONENT_REF, TREE_TYPE (f), dst, f, NULL);\n \tt = lang_hooks.decls.omp_clause_copy_ctor (c, dst, src);\n \tappend_to_statement_list (t, &list);\n@@ -6341,14 +6356,14 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n \t    sf = (tree) n->value;\n \t    if (tcctx.cb.decl_map)\n \t      sf = *(tree *) pointer_map_contains (tcctx.cb.decl_map, sf);\n-\t    src = build_fold_indirect_ref_loc (loc, sarg);\n+\t    src = build_simple_mem_ref_loc (loc, sarg);\n \t    src = build3 (COMPONENT_REF, TREE_TYPE (sf), src, sf, NULL);\n \t    if (use_pointer_for_field (decl, NULL))\n-\t      src = build_fold_indirect_ref_loc (loc, src);\n+\t      src = build_simple_mem_ref_loc (loc, src);\n \t  }\n \telse\n \t  src = decl;\n-\tdst = build_fold_indirect_ref_loc (loc, arg);\n+\tdst = build_simple_mem_ref_loc (loc, arg);\n \tdst = build3 (COMPONENT_REF, TREE_TYPE (f), dst, f, NULL);\n \tt = build2 (MODIFY_EXPR, TREE_TYPE (dst), dst, src);\n \tappend_to_statement_list (t, &list);\n@@ -6380,18 +6395,18 @@ create_task_copyfn (gimple task_stmt, omp_context *ctx)\n \t\t\t\t (splay_tree_key) TREE_OPERAND (ind, 0));\n \t  sf = (tree) n->value;\n \t  sf = *(tree *) pointer_map_contains (tcctx.cb.decl_map, sf);\n-\t  src = build_fold_indirect_ref_loc (loc, sarg);\n+\t  src = build_simple_mem_ref_loc (loc, sarg);\n \t  src = build3 (COMPONENT_REF, TREE_TYPE (sf), src, sf, NULL);\n-\t  src = build_fold_indirect_ref_loc (loc, src);\n-\t  dst = build_fold_indirect_ref_loc (loc, arg);\n+\t  src = build_simple_mem_ref_loc (loc, src);\n+\t  dst = build_simple_mem_ref_loc (loc, arg);\n \t  dst = build3 (COMPONENT_REF, TREE_TYPE (f), dst, f, NULL);\n \t  t = lang_hooks.decls.omp_clause_copy_ctor (c, dst, src);\n \t  append_to_statement_list (t, &list);\n \t  n = splay_tree_lookup (ctx->field_map,\n \t\t\t\t (splay_tree_key) TREE_OPERAND (ind, 0));\n \t  df = (tree) n->value;\n \t  df = *(tree *) pointer_map_contains (tcctx.cb.decl_map, df);\n-\t  ptr = build_fold_indirect_ref_loc (loc, arg);\n+\t  ptr = build_simple_mem_ref_loc (loc, arg);\n \t  ptr = build3 (COMPONENT_REF, TREE_TYPE (df), ptr, df, NULL);\n \t  t = build2 (MODIFY_EXPR, TREE_TYPE (ptr), ptr,\n \t\t      build_fold_addr_expr_loc (loc, dst));"}, {"sha": "0fd31d9bc604156b713f30482ad7bdd4584888ff", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1,3 +1,70 @@\n+2010-07-01  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/42834\n+\tPR middle-end/44468\n+\t* gcc.c-torture/execute/20100316-1.c: New testcase.\n+\t* gcc.c-torture/execute/pr44468.c: Likewise.\n+\t* gcc.c-torture/compile/20100609-1.c: Likewise.\n+\t* gcc.dg/volatile2.c: Adjust.\n+\t* gcc.dg/plugin/selfassign.c: Likewise.\n+\t* gcc.dg/pr36902.c: Likewise.\n+\t* gcc.dg/tree-ssa/foldaddr-2.c: Remove.\n+\t* gcc.dg/tree-ssa/foldaddr-3.c: Likewise.\n+\t* gcc.dg/tree-ssa/forwprop-8.c: Adjust.\n+\t* gcc.dg/tree-ssa/pr17141-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-fre-13.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-fre-14.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ccp-21.c: Likewise.\n+\t* gcc.dg/tree-ssa/pta-ptrarith-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/20030807-7.c: Likewise.\n+\t* gcc.dg/tree-ssa/forwprop-10.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-fre-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/pta-ptrarith-2.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ccp-23.c: Likewise.\n+\t* gcc.dg/tree-ssa/forwprop-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/forwprop-2.c: Likewise.\n+\t* gcc.dg/tree-ssa/struct-aliasing-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ccp-25.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-pre-26.c: Likewise.\n+\t* gcc.dg/tree-ssa/struct-aliasing-2.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ccp-26.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-sccvn-4.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-pre-7.c: Likewise.\n+\t* gcc.dg/tree-ssa/forwprop-5.c: Likewise.\n+\t* gcc.dg/struct/w_prof_two_strs.c: XFAIL.\n+\t* gcc.dg/struct/wo_prof_escape_arg_to_local.c: Likewise.\n+\t* gcc.dg/struct/wo_prof_global_var.c: Likewise.\n+\t* gcc.dg/struct/wo_prof_malloc_size_var.c: Likewise.\n+\t* gcc.dg/struct/w_prof_local_array.c: Likewise.\n+\t* gcc.dg/struct/w_prof_single_str_global.c: Likewise.\n+\t* gcc.dg/struct/wo_prof_escape_str_init.c: Likewise.\n+\t* gcc.dg/struct/wo_prof_array_through_pointer.c: Likewise.\n+\t* gcc.dg/struct/w_prof_global_array.c: Likewise.\n+\t* gcc.dg/struct/wo_prof_array_field.c: Likewise.\n+\t* gcc.dg/struct/wo_prof_single_str_local.c: Likewise.\n+\t* gcc.dg/struct/w_prof_local_var.c: Likewise.\n+\t* gcc.dg/struct/wo_prof_two_strs.c: Likewise.\n+\t* gcc.dg/struct/wo_prof_empty_str.c: Likewise.\n+\t* gcc.dg/struct/wo_prof_local_array.c: Likewise.\n+\t* gcc.dg/struct/w_prof_global_var.c: Likewise.\n+\t* gcc.dg/struct/wo_prof_single_str_global.c: Likewise.\n+\t* gcc.dg/struct/wo_prof_escape_substr_value.c: Likewise.\n+\t* gcc.dg/struct/wo_prof_global_array.c: Likewise.\n+\t* gcc.dg/struct/wo_prof_escape_return.c: Likewise.\n+\t* gcc.dg/struct/wo_prof_escape_substr_array.c: Likewise.\n+\t* gcc.dg/struct/wo_prof_double_malloc.c: Likewise.\n+\t* gcc.dg/struct/w_ratio_cold_str.c: Likewise.\n+\t* gcc.dg/struct/wo_prof_escape_substr_pointer.c: Likewise.\n+\t* gcc.dg/struct/wo_prof_local_var.c: Likewise.\n+\t* gcc.dg/tree-prof/stringop-1.c: Adjust.\n+\t* g++.dg/tree-ssa/pr31146.C: Likewise.\n+\t* g++.dg/tree-ssa/copyprop-1.C: Likewise.\n+\t* g++.dg/tree-ssa/pr33604.C: Likewise.\n+\t* g++.dg/plugin/selfassign.c: Likewise.\n+\t* gfortran.dg/array_memcpy_3.f90: Likewise.\n+\t* gfortran.dg/array_memcpy_4.f90: Likewise.\n+\t* c-c++-common/torture/pr42834.c: New testcase.\n+\n 2010-06-30  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/44628"}, {"sha": "a1ba49e46d47cc24d8ce66e29fce3e3765dadeca", "filename": "gcc/testsuite/c-c++-common/torture/pr42834.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fpr42834.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fpr42834.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fpr42834.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do run } */\n+\n+void __attribute__((noinline,noclone))\n+foo(int *p, float *q) { __asm__ volatile (\"\" : : : \"memory\"); }\n+\n+int main()\n+{\n+  if (sizeof (int) == sizeof (float))\n+    {\n+      int i;\n+      float f;\n+      int *p;\n+      /* Prevent i and f from being rewritten into SSA form.  */\n+      foo (&i, &f);\n+      i = 0;\n+      f = 1.0;\n+      p = (int *)&f;\n+      __builtin_memcpy (&i, p, 4);\n+      if (*(float *)&i != 1.0)\n+\t__builtin_abort ();\n+    }\n+  return 0;\n+}"}, {"sha": "eb8f24a45a8e301c432e94fb07a04ec8e675a38a", "filename": "gcc/testsuite/g++.dg/plugin/selfassign.c", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fselfassign.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -52,9 +52,7 @@ get_real_ref_rhs (tree expr)\n               /* We are only interested in an assignment with a single\n                  rhs operand because if it is not, the original assignment\n                  will not possibly be a self-assignment.  */\n-              if (is_gimple_assign (def_stmt)\n-                  && (get_gimple_rhs_class (gimple_assign_rhs_code (def_stmt))\n-                      == GIMPLE_SINGLE_RHS))\n+              if (gimple_assign_single_p (def_stmt))\n                 return get_real_ref_rhs (gimple_assign_rhs1 (def_stmt));\n               else\n                 return NULL_TREE;\n@@ -66,7 +64,7 @@ get_real_ref_rhs (tree expr)\n       case PARM_DECL:\n       case FIELD_DECL:\n       case COMPONENT_REF:\n-      case INDIRECT_REF:\n+      case MEM_REF:\n       case ARRAY_REF:\n         return expr;\n       default:\n@@ -116,17 +114,18 @@ get_non_ssa_expr (tree expr)\n           else\n             return expr;\n         }\n-      case INDIRECT_REF:\n+      case MEM_REF:\n         {\n           tree orig_base = TREE_OPERAND (expr, 0);\n-          tree base = get_non_ssa_expr (orig_base);\n-          if (!base)\n-            return NULL_TREE;\n-          /* If BASE is converted, build a new indirect reference tree.  */\n-          if (base != orig_base)\n-            return build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (base)), base);\n-          else\n-            return expr;\n+\t  if (TREE_CODE (orig_base) == SSA_NAME)\n+\t    {\n+\t      tree base = get_non_ssa_expr (orig_base);\n+\t      if (!base)\n+\t\treturn NULL_TREE;\n+\t      return fold_build2 (MEM_REF, TREE_TYPE (expr),\n+\t\t\t\t  base, TREE_OPERAND (expr, 1));\n+\t    }\n+\t  return expr;\n         }\n       case ARRAY_REF:\n         {\n@@ -153,9 +152,7 @@ get_non_ssa_expr (tree expr)\n               && !gimple_nop_p (SSA_NAME_DEF_STMT (expr)))\n             {\n               gimple def_stmt = SSA_NAME_DEF_STMT (expr);\n-              if (is_gimple_assign (def_stmt)\n-                  && (get_gimple_rhs_class (gimple_assign_rhs_code (def_stmt))\n-                      == GIMPLE_SINGLE_RHS))\n+              if (gimple_assign_single_p (def_stmt))\n                 vdecl = gimple_assign_rhs1 (def_stmt);\n             }\n           return get_non_ssa_expr (vdecl);\n@@ -201,9 +198,7 @@ warn_self_assign (gimple stmt)\n   tree rhs, lhs;\n \n   /* Check assigment statement.  */\n-  if (is_gimple_assign (stmt)\n-      && (get_gimple_rhs_class (gimple_assign_rhs_code (stmt))\n-          == GIMPLE_SINGLE_RHS))\n+  if (gimple_assign_single_p (stmt))\n     {\n       rhs = get_real_ref_rhs (gimple_assign_rhs1 (stmt));\n       if (!rhs)"}, {"sha": "03f6b1207c7243dc8faa725cb933fba4164f438b", "filename": "gcc/testsuite/g++.dg/tree-ssa/copyprop-1.C", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fcopyprop-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fcopyprop-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fcopyprop-1.C?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -25,5 +25,7 @@ int foo(Object&o)\n   return o[0];\n }\n \n-/* { dg-final { scan-tree-dump-not \".* = \\[^>;\\]*;\" \"dce2\" } } */\n+/* Remaining should be two loads.  */\n+\n+/* { dg-final { scan-tree-dump-times \" = \\[^\\n\\]*;\" 2 \"dce2\" } } */\n /* { dg-final { cleanup-tree-dump \"dce2\" } } */"}, {"sha": "478a488e3c2053e186274c556e8c642b7d19973a", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr31146.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr31146.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr31146.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr31146.C?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -12,5 +12,5 @@ void foo (int j)\n   *q = 1;\n }\n \n-/* { dg-final { scan-tree-dump \"i\\\\\\[j.*\\\\\\] =.* 1;\" \"forwprop1\" } } */\n+/* { dg-final { scan-tree-dump \"MEM\\\\\\[.*&i\\\\\\]\\\\\\[j.*\\\\\\] =.* 1;\" \"forwprop1\" } } */\n /* { dg-final { cleanup-tree-dump \"forwprop?\" } } */"}, {"sha": "7e820d3ef16fba00ab646117db124bc6b25296c3", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr33604.C", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr33604.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr33604.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr33604.C?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-O -fdump-tree-forwprop1\" } */\n+/* { dg-options \"-O -fdump-tree-optimized-vops\" } */\n \n struct Value\n {\n@@ -35,12 +35,14 @@ int main(int argc, char *argv[])\n   return 0;\n }\n \n-/* Check that we forward propagated\n+/* Check that we propagate\n      D.2182_13 = (struct Ref *) &D.2137.lhs;\n    to\n      D.2182_13->lhs.m ={v} &I;\n    yielding\n-     D.2137.lhs.m ={v} &I;  */\n+     D.2137.lhs.m ={v} &I;\n+   so that SRA can promote all locals to registers and we end up\n+   referencing a single virtual operand at abort () after optimization.  */\n \n-/* { dg-final { scan-tree-dump-times \"D\\\\\\.....\\\\\\..hs\\\\\\.m =\" 2 \"forwprop1\" } } */\n-/* { dg-final { cleanup-tree-dump \"forwprop1\" } } */\n+/* { dg-final { scan-tree-dump-times \".MEM_\\[0-9\\]*\\\\\\(D\\\\\\)\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "8e1175faa32ea7d90290ac8c249dcc67367ad339", "filename": "gcc/testsuite/gcc.c-torture/compile/20100609-1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20100609-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20100609-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20100609-1.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -0,0 +1,8 @@\n+extern unsigned long int strtoul (__const char *__restrict __nptr,       char **__restrict __endptr, int __base);\n+int find_reloads (int i, char *p)\n+{\n+  int c;\n+  while ((c = *p++))\n+    return strtoul (p - 1, &p, 10); \n+  return 0;\n+}"}, {"sha": "8367d7273d2fe6b65683937671ac2d4f2c20e2da", "filename": "gcc/testsuite/gcc.c-torture/execute/20100316-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20100316-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20100316-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20100316-1.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -0,0 +1,24 @@\n+struct Foo {\n+  int i;\n+  unsigned precision : 10;\n+  unsigned blah : 3;\n+} f;\n+\n+int __attribute__((noinline,noclone))\n+foo (struct Foo *p)\n+{\n+  struct Foo *q = p;\n+  return (*q).precision;\n+}\n+\n+extern void abort (void);\n+\n+int main()\n+{\n+  f.i = -1;\n+  f.precision = 0;\n+  f.blah = -1;\n+  if (foo (&f) != 0)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "c4bd492656d474ee404126e7f32856d64dd87caf", "filename": "gcc/testsuite/gcc.c-torture/execute/pr44468.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr44468.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr44468.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr44468.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -0,0 +1,60 @@\n+#include <stddef.h>\n+\n+struct S {\n+  int i;\n+  int j;\n+};\n+struct R {\n+  int k;\n+  struct S a;\n+};\n+struct Q {\n+  float k;\n+  struct S a;\n+};\n+struct Q s;\n+int __attribute__((noinline,noclone))\n+test1 (void *q)\n+{\n+  struct S *b = (struct S *)((char *)q + sizeof (int));\n+  s.a.i = 0;\n+  b->i = 3;\n+  return s.a.i;\n+}\n+int __attribute__((noinline,noclone))\n+test2 (void *q)\n+{\n+  struct S *b = &((struct R *)q)->a;\n+  s.a.i = 0;\n+  b->i = 3;\n+  return s.a.i;\n+}\n+int __attribute__((noinline,noclone))\n+test3 (void *q)\n+{\n+  s.a.i = 0;\n+  ((struct S *)((char *)q + sizeof (int)))->i = 3;\n+  return s.a.i;\n+}\n+extern void abort (void);\n+int\n+main()\n+{\n+  if (sizeof (float) != sizeof (int)\n+      || offsetof (struct R, a) != sizeof (int)\n+      || offsetof (struct Q, a) != sizeof (int))\n+    return 0;\n+  s.a.i = 1;\n+  s.a.j = 2;\n+  if (test1 ((void *)&s) != 3)\n+    abort ();\n+  s.a.i = 1;\n+  s.a.j = 2;\n+  if (test2 ((void *)&s) != 3)\n+    abort ();\n+  s.a.i = 1;\n+  s.a.j = 2;\n+  if (test3 ((void *)&s) != 3)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "eb8f24a45a8e301c432e94fb07a04ec8e675a38a", "filename": "gcc/testsuite/gcc.dg/plugin/selfassign.c", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fselfassign.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -52,9 +52,7 @@ get_real_ref_rhs (tree expr)\n               /* We are only interested in an assignment with a single\n                  rhs operand because if it is not, the original assignment\n                  will not possibly be a self-assignment.  */\n-              if (is_gimple_assign (def_stmt)\n-                  && (get_gimple_rhs_class (gimple_assign_rhs_code (def_stmt))\n-                      == GIMPLE_SINGLE_RHS))\n+              if (gimple_assign_single_p (def_stmt))\n                 return get_real_ref_rhs (gimple_assign_rhs1 (def_stmt));\n               else\n                 return NULL_TREE;\n@@ -66,7 +64,7 @@ get_real_ref_rhs (tree expr)\n       case PARM_DECL:\n       case FIELD_DECL:\n       case COMPONENT_REF:\n-      case INDIRECT_REF:\n+      case MEM_REF:\n       case ARRAY_REF:\n         return expr;\n       default:\n@@ -116,17 +114,18 @@ get_non_ssa_expr (tree expr)\n           else\n             return expr;\n         }\n-      case INDIRECT_REF:\n+      case MEM_REF:\n         {\n           tree orig_base = TREE_OPERAND (expr, 0);\n-          tree base = get_non_ssa_expr (orig_base);\n-          if (!base)\n-            return NULL_TREE;\n-          /* If BASE is converted, build a new indirect reference tree.  */\n-          if (base != orig_base)\n-            return build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (base)), base);\n-          else\n-            return expr;\n+\t  if (TREE_CODE (orig_base) == SSA_NAME)\n+\t    {\n+\t      tree base = get_non_ssa_expr (orig_base);\n+\t      if (!base)\n+\t\treturn NULL_TREE;\n+\t      return fold_build2 (MEM_REF, TREE_TYPE (expr),\n+\t\t\t\t  base, TREE_OPERAND (expr, 1));\n+\t    }\n+\t  return expr;\n         }\n       case ARRAY_REF:\n         {\n@@ -153,9 +152,7 @@ get_non_ssa_expr (tree expr)\n               && !gimple_nop_p (SSA_NAME_DEF_STMT (expr)))\n             {\n               gimple def_stmt = SSA_NAME_DEF_STMT (expr);\n-              if (is_gimple_assign (def_stmt)\n-                  && (get_gimple_rhs_class (gimple_assign_rhs_code (def_stmt))\n-                      == GIMPLE_SINGLE_RHS))\n+              if (gimple_assign_single_p (def_stmt))\n                 vdecl = gimple_assign_rhs1 (def_stmt);\n             }\n           return get_non_ssa_expr (vdecl);\n@@ -201,9 +198,7 @@ warn_self_assign (gimple stmt)\n   tree rhs, lhs;\n \n   /* Check assigment statement.  */\n-  if (is_gimple_assign (stmt)\n-      && (get_gimple_rhs_class (gimple_assign_rhs_code (stmt))\n-          == GIMPLE_SINGLE_RHS))\n+  if (gimple_assign_single_p (stmt))\n     {\n       rhs = get_real_ref_rhs (gimple_assign_rhs1 (stmt));\n       if (!rhs)"}, {"sha": "43a2d14f981f18ad252a806a4cda3bf69e28f786", "filename": "gcc/testsuite/gcc.dg/pr36902.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36902.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36902.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36902.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -44,7 +44,7 @@ foo2(unsigned char * to, const unsigned char * from, int n)\n       *to = *from;\n       break;\n     case 5:\n-      to[4] = from [4]; /* { dg-warning \"20:array subscript is above array bounds\" } */\n+      to[4] = from [4]; /* { dg-warning \"array subscript is above array bounds\" } */\n       break;\n     }\n   return to;"}, {"sha": "ca3643e43de7558531f08e3dfb1a232658112ab6", "filename": "gcc/testsuite/gcc.dg/struct/w_prof_global_array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_global_array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_global_array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_global_array.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -26,5 +26,5 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" } } */\n+/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final-use { cleanup-ipa-dump \"*\" } } */"}, {"sha": "baff45d917db1f7ccd7f1105abdcf3ae6da38788", "filename": "gcc/testsuite/gcc.dg/struct/w_prof_global_var.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_global_var.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_global_var.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_global_var.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -39,5 +39,5 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail { \"avr-*-*\" } } } } */\n+/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final-use { cleanup-ipa-dump \"*\" } } */"}, {"sha": "8953264fea19d22047a5b814eccb88de4230baa8", "filename": "gcc/testsuite/gcc.dg/struct/w_prof_local_array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_local_array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_local_array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_local_array.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -34,5 +34,5 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail { \"avr-*-*\" } } } } */\n+/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final-use { cleanup-ipa-dump \"*\" } } */"}, {"sha": "9a23f8d53a8bd6c1a2f2c6258e1b1595b5b65f0b", "filename": "gcc/testsuite/gcc.dg/struct/w_prof_local_var.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_local_var.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_local_var.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_local_var.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -37,5 +37,5 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" } } */\n+/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final-use { cleanup-ipa-dump \"*\" } } */"}, {"sha": "b020239910434fbe826908ff3f83b24a09640072", "filename": "gcc/testsuite/gcc.dg/struct/w_prof_single_str_global.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_single_str_global.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_single_str_global.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_single_str_global.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -28,6 +28,6 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail { \"avr-*-*\" } } } } */\n+/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final-use { cleanup-ipa-dump \"*\" } } */\n "}, {"sha": "e9de98c3b8a9b7736712be7453a41609a7d7c69a", "filename": "gcc/testsuite/gcc.dg/struct/w_prof_two_strs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_two_strs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_two_strs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_prof_two_strs.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -61,6 +61,6 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 2\" \"ipa_struct_reorg\" } } */\n+/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 2\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final-use { cleanup-ipa-dump \"*\" } } */\n "}, {"sha": "3c26e3be7b67c5f110e966aab6f4a41a495383df", "filename": "gcc/testsuite/gcc.dg/struct/w_ratio_cold_str.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_ratio_cold_str.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_ratio_cold_str.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fw_ratio_cold_str.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -39,5 +39,5 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" } } */\n+/* { dg-final-use { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final-use { cleanup-ipa-dump \"*\" } } */"}, {"sha": "5d5e37b4f0e6b831bc06f4bed6e3c552adfeecac", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_array_field.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_array_field.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_array_field.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_array_field.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -23,5 +23,5 @@ int main()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail { \"avr-*-*\" } } } } */\n+/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "efb68be8bdd7da7883e1c01f594c24686c5dd689", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_array_through_pointer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_array_through_pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_array_through_pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_array_through_pointer.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -35,5 +35,5 @@ main ()\n   return 0;\n }\n \n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" } } */\n+/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "77226b449c5d7fcd22e7b6569b5e500cd47972fd", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_double_malloc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_double_malloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_double_malloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_double_malloc.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -26,5 +26,5 @@ int main()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail { \"avr-*-*\" } } } } */\n+/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "58411202767a8c718641828716e62adac55072b2", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_empty_str.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_empty_str.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_empty_str.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_empty_str.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -43,5 +43,5 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"No structures to transform\" \"ipa_struct_reorg\" { xfail { \"avr-*-*\" } } } } */\n+/* { dg-final { scan-ipa-dump \"No structures to transform\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "781a847f9f735908a271ba9f63fe1e3c9fda77ed", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_escape_arg_to_local.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_arg_to_local.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_arg_to_local.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_arg_to_local.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -42,5 +42,5 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"is passed to local function...Excluded.\" \"ipa_struct_reorg\" } } */\n+/* { dg-final { scan-ipa-dump \"is passed to local function...Excluded.\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "8892fa99098ef52b2b0b841bf49b3e61ea16f2c1", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_escape_return.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_return.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_return.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_return.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -29,5 +29,5 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"is return type of function...Excluded\" \"ipa_struct_reorg\" } } */\n+/* { dg-final { scan-ipa-dump \"is return type of function...Excluded\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "6da3420f6e88ac1e29a13d6ca13ecdce004badb7", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_escape_str_init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_str_init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_str_init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_str_init.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -28,6 +28,6 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"is initialized...Excluded\" \"ipa_struct_reorg\" } } */\n+/* { dg-final { scan-ipa-dump \"is initialized...Excluded\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"*\" } } */\n "}, {"sha": "bd03ec42f0534a905ce6ec570d1b5f796043eded", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_escape_substr_array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_substr_array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_substr_array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_substr_array.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -30,5 +30,5 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"is a field in the structure\" \"ipa_struct_reorg\" } } */\n+/* { dg-final { scan-ipa-dump \"is a field in the structure\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "59e0e48321a5052bb95504a794d1837944bfce43", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_escape_substr_pointer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_substr_pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_substr_pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_substr_pointer.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -45,5 +45,5 @@ main (void)\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"is a field in the structure\" \"ipa_struct_reorg\" } } */\n+/* { dg-final { scan-ipa-dump \"is a field in the structure\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "a6b32ddd688c3dd28c2e05569f7edaea60d273ce", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_escape_substr_value.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_substr_value.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_substr_value.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_escape_substr_value.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -42,5 +42,5 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"is a field in the structure\" \"ipa_struct_reorg\" } } */\n+/* { dg-final { scan-ipa-dump \"is a field in the structure\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "b61e26b12484dbff4654afa2f7953e10afacbc21", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_global_array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_global_array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_global_array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_global_array.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -29,5 +29,5 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail { \"avr-*-*\" } } } } */\n+/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "39351e072e2901af8898aaf0da55dc3f1a1255b4", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_global_var.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_global_var.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_global_var.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_global_var.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -42,5 +42,5 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail { \"avr-*-*\" } } } } */\n+/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "18d5a734740e713be2503085bb04cbaff0d934d5", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_local_array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_local_array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_local_array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_local_array.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -37,5 +37,5 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail { \"avr-*-*\" } } } } */\n+/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "26a9dbd731430d826e4a2291a4dde887c43dfe40", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_local_var.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_local_var.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_local_var.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_local_var.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -40,5 +40,5 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail { \"avr-*-*\" } } } } */\n+/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "6caadcf12305ace627fcda1e117bd853cdc2a943", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_malloc_size_var.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_malloc_size_var.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_malloc_size_var.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_malloc_size_var.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -44,5 +44,5 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail { \"avr-*-*\" } } } } */\n+/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "812763d53ff846f55814a4fb388a8daa1427a426", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_single_str_global.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_single_str_global.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_single_str_global.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_single_str_global.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -31,5 +31,5 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail { \"avr-*-*\" } } } } */\n+/* { dg-final { scan-ipa-dump \"Number of structures to transform is 1\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "313af1080c1d293c5c9049b769ffae064ce0a810", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_single_str_local.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_single_str_local.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_single_str_local.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_single_str_local.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -31,5 +31,5 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"No structures to transform\" \"ipa_struct_reorg\" { xfail { \"avr-*-*\" } } } } */\n+/* { dg-final { scan-ipa-dump \"No structures to transform\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "92da94d29239df51ebc80178c6b6fc27c270b471", "filename": "gcc/testsuite/gcc.dg/struct/wo_prof_two_strs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_two_strs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_two_strs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstruct%2Fwo_prof_two_strs.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -64,5 +64,5 @@ main ()\n }\n \n /*--------------------------------------------------------------------------*/\n-/* { dg-final { scan-ipa-dump \"Number of structures to transform is 2\" \"ipa_struct_reorg\" { xfail { \"avr-*-*\" } } } } */\n+/* { dg-final { scan-ipa-dump \"Number of structures to transform is 2\" \"ipa_struct_reorg\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-ipa-dump \"*\" } } */"}, {"sha": "0f477b2376c06f672d583a2b87e4c7b0eedfb19d", "filename": "gcc/testsuite/gcc.dg/tree-prof/stringop-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-1.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -16,7 +16,7 @@ main()\n /* { dg-final-use { scan-tree-dump \"Single value 4 stringop\" \"tree_profile\"} } */\n /* Really this ought to simplify into assignment, but we are not there yet.  */\n /* a[0] = b[0] is what we fold the resulting memcpy into.  */\n-/* { dg-final-use { scan-tree-dump \"a.0. = \" \"optimized\"} } */\n-/* { dg-final-use { scan-tree-dump \"= b.0.\" \"optimized\"} } */\n+/* { dg-final-use { scan-tree-dump \" = MEM.*&b\" \"optimized\"} } */\n+/* { dg-final-use { scan-tree-dump \"MEM.*&a\\\\\\] = \" \"optimized\"} } */\n /* { dg-final-use { cleanup-tree-dump \"optimized\" } } */\n /* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */"}, {"sha": "ed6f7c0d5d5d8e688e5de8dbe8dfff6bd20fe6ad", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030807-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030807-7.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -33,5 +33,5 @@ simplify_condition (cond_p)\n }\n \n /* There should be exactly one IF conditional.  */\n-/* { dg-final { scan-tree-dump-times \"if \" 1 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"if \" 1 \"vrp1\" { xfail *-*-* } } } */\n /* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "dc764c3d79eea3498e93c8cfbaea87a04fe5ea77", "filename": "gcc/testsuite/gcc.dg/tree-ssa/foldaddr-2.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/952b984e86f884d08d2e1ae5675ce518381692c5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ffoldaddr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/952b984e86f884d08d2e1ae5675ce518381692c5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ffoldaddr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ffoldaddr-2.c?ref=952b984e86f884d08d2e1ae5675ce518381692c5", "patch": "@@ -1,13 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-optimized\" } */\n-struct a{\n-\tint a;\n-\tint b;\n-} a;\n-int *\n-t()\n-{\n-\treturn (int *)&a;\n-}\n-/* { dg-final { scan-tree-dump \"a.a\" \"optimized\"} } */\n-/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "b764187a029f335860e0cb826b9dcf3ee208e96d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/foldaddr-3.c", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/952b984e86f884d08d2e1ae5675ce518381692c5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ffoldaddr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/952b984e86f884d08d2e1ae5675ce518381692c5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ffoldaddr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ffoldaddr-3.c?ref=952b984e86f884d08d2e1ae5675ce518381692c5", "patch": "@@ -1,28 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-optimized\" } */\n-union a\n-{\n-  struct s1\n-  {\n-    long long a;\n-    long long b;\n-  } s1;\n-  struct s2\n-  {\n-    int c;\n-    int d;\n-  } s2;\n-  struct s3\n-  {\n-    unsigned long long e;\n-    unsigned long long f;\n-  } s3;\n-} a;\n-int *\n-t ()\n-{\n-  return (int *) &a;\n-}\n-\n-/* { dg-final { scan-tree-dump \"a.s2.c\" \"optimized\"} } */\n-/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "7b07d7f488f4fa6f69abbf4636536d56b9a6da39", "filename": "gcc/testsuite/gcc.dg/tree-ssa/forwprop-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-1.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -15,5 +15,5 @@ void f(struct a * b, __SIZE_TYPE__ i)\n   c[i] = 1;\n }\n \n-/* { dg-final { scan-tree-dump-times \"t\\\\\\[i.*\\\\\\] =.* 1;\" 1 \"forwprop1\" } } */\n+/* { dg-final { scan-tree-dump-times \"t\\\\\\[i.*\\\\\\].* = 1;\" 1 \"forwprop1\" } } */\n /* { dg-final { cleanup-tree-dump \"forwprop1\" } } */"}, {"sha": "b46b8ece81606836484ee8a793db3a55e910090c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/forwprop-10.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-10.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O -fdump-tree-forwprop1\" } */\n+/* { dg-options \"-O -fdump-tree-fre-details\" } */\n \n int b;\n unsigned a;\n@@ -15,9 +15,8 @@ void test2(void)\n }\n \n /* The indirect load should be replaced by a load from a and a\n-   conversion to int.  */\n+   conversion to int.  FRE should then be able to replace\n+   the rhs of the store to b by 1.  */\n \n-/* { dg-final { scan-tree-dump \"= a;\" \"forwprop1\" } } */\n-/* { dg-final { scan-tree-dump \"= \\\\\\(int\\\\\\) \" \"forwprop1\" } } */\n-/* { dg-final { scan-tree-dump-not \"= \\\\\\*\" \"forwprop1\" } } */\n-/* { dg-final { cleanup-tree-dump \"forwprop1\" } } */\n+/* { dg-final { scan-tree-dump \"Replaced\\[^\\\\n\\]*with 1\" \"fre\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "2aefb9ace63a2fb7ee4d6948c0fb561fb343ec2b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/forwprop-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-2.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -17,5 +17,5 @@ void f(__SIZE_TYPE__ i)\n   c[i] = 1;\n }\n \n-/* { dg-final { scan-tree-dump-times \"t\\\\\\[i.*\\\\\\] =.* 1;\" 1 \"forwprop1\" } } */\n+/* { dg-final { scan-tree-dump-times \"t\\\\\\[i.*\\\\\\].* = 1;\" 1 \"forwprop1\" } } */\n /* { dg-final { cleanup-tree-dump \"forwprop?\" } } */"}, {"sha": "1b68d5a35f02f48d18e717c61f3a6068f8463cec", "filename": "gcc/testsuite/gcc.dg/tree-ssa/forwprop-5.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-5.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-forwprop1 -w\" } */\n+/* { dg-options \"-O1 -fdump-tree-esra -w\" } */\n \n #define vector __attribute__((vector_size(16) ))\n struct VecClass\n@@ -15,7 +15,8 @@ vector float foo( vector float v )\n     return y.v;\n }\n \n-/* We should be able to convert the cast to a VCE in forwprop1. */\n-/* { dg-final { scan-tree-dump-times \"VIEW_CONVERT_EXPR\" 1 \"forwprop1\"} } */\n-/* { dg-final { cleanup-tree-dump \"forwprop1\" } } */\n-\n+/* We should be able to remove the intermediate struct and directly\n+   return x.  As we do not fold VIEW_CONVERT_EXPR<struct VecClass>(x).v\n+   that doesn't happen right now.  */\n+/* { dg-final { scan-tree-dump-times \"VIEW_CONVERT_EXPR\" 1 \"esra\"} } */\n+/* { dg-final { cleanup-tree-dump \"esra\" } } */"}, {"sha": "fc74297242cce1b65f829545cf5779bb5be1aaae", "filename": "gcc/testsuite/gcc.dg/tree-ssa/forwprop-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-8.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -12,5 +12,5 @@ int foo(struct X *q)\n \n /* We should have propragated &q->a into (*pointer).  */\n /* { dg-final { scan-tree-dump-times \"pointer\" 0 \"forwprop1\"} } */\n-/* { dg-final { scan-tree-dump \"->a\\\\\\[0\\\\\\]\" \"forwprop1\" } } */\n+/* { dg-final { scan-tree-dump \"\\\\\\[0\\\\\\]\" \"forwprop1\" } } */\n /* { dg-final { cleanup-tree-dump \"forwprop1\" } } */"}, {"sha": "4b8239e4531603aec8489353e8445c3e90bc25d4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre6.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre6.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+/* { dg-options \"-O2 -fdump-tree-pre-stats -fdump-tree-fre\" } */\n #include <stddef.h>\n \n union tree_node;\n@@ -72,7 +72,9 @@ main (void)\n   remove_useless_vars (&unexpanded_var_list, 0);\n   return 0;\n }\n-/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\" } } */\n+\n+/* See PR44656.  The last elimination is only done by PRE.  */\n+/* { dg-final { scan-tree-dump-not \"= unexpanded_var_list;\" \"fre\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 2 \"pre\" } } */\n /* { dg-final { scan-tree-dump-times \"Insertions: 2\" 1 \"pre\" } } */\n /* { dg-final { cleanup-tree-dump \"pre\" } } */\n-"}, {"sha": "853fe70c6233b0d36d2e2b59088051478a11b39c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr17141-1.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr17141-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr17141-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr17141-1.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-forwprop1\" } */\n+/* { dg-options \"-O -fdump-tree-forwprop1\" } */\n \n struct A { int i; };\n int\n@@ -11,5 +11,7 @@ foo(struct A *locp, int str)\n   return locp->i;\n }\n \n-/* { dg-final { scan-tree-dump \"locp.*->i =\" \"forwprop1\" } } */\n+/* We should have propagated &locp->i into its dereference.  */\n+\n+/* { dg-final { scan-tree-dump \"locp_\\[^\\\\n\\]* =\" \"forwprop1\" } } */\n /* { dg-final { cleanup-tree-dump \"forwprop1\" } } */"}, {"sha": "6db9ba0d8719a74caf187aad32cf2d61a36bb09a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pta-ptrarith-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-ptrarith-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-ptrarith-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-ptrarith-1.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-tree-ccp -fdump-tree-alias\" } */\n+/* { dg-options \"-O2 -fno-tree-ccp -fdump-tree-ealias\" } */\n \n extern void abort (void);\n struct X {\n@@ -22,5 +22,5 @@ foo(int i, int j, int k, int off)\n   return *q;\n }\n \n-/* { dg-final { scan-tree-dump \"q_., points-to vars: { k }\" \"alias\" } } */\n-/* { dg-final { cleanup-tree-dump \"alias\" } } */\n+/* { dg-final { scan-tree-dump \"q_., points-to vars: { k }\" \"ealias\" } } */\n+/* { dg-final { cleanup-tree-dump \"ealias\" } } */"}, {"sha": "85b96b190e211cdc23cae095f5f1c577b5ab9869", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pta-ptrarith-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-ptrarith-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-ptrarith-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-ptrarith-2.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-tree-ccp -fdump-tree-alias\" } */\n+/* { dg-options \"-O2 -fno-tree-ccp -fdump-tree-ealias\" } */\n \n extern void abort (void);\n struct X {\n@@ -22,5 +22,5 @@ foo(int i, int j, int k, int off)\n   return *q;\n }\n \n-/* { dg-final { scan-tree-dump \"q_., points-to vars: { i }\" \"alias\" } } */\n-/* { dg-final { cleanup-tree-dump \"alias\" } } */\n+/* { dg-final { scan-tree-dump \"q_., points-to vars: { i }\" \"ealias\" } } */\n+/* { dg-final { cleanup-tree-dump \"ealias\" } } */"}, {"sha": "3f4adf434833f477e299d96194b7e788a221f8ed", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-21.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-21.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -21,5 +21,9 @@ int bar (void)\n   return q->i;\n }\n \n-/* { dg-final { scan-tree-dump-times \"a.b.i\" 2 \"ccp1\" } } */\n+/* The first access is through struct A, so a.b.i is fine,\n+   the second access needs to preserve the original access type struct B.  */\n+\n+/* { dg-final { scan-tree-dump-times \"a.b.i\" 1 \"ccp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"MEM\\\\\\[\\\\\\(struct B \\\\\\*\\\\\\)&a\\\\\\].i\" 1 \"ccp1\" } } */\n /* { dg-final { cleanup-tree-dump \"ccp1\" } } */"}, {"sha": "fb4af2d484dbe6ab243dcf0e1ec3514e30723075", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-23.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-23.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -15,5 +15,5 @@ int foo (void)\n   return *x;\n }\n \n-/* { dg-final { scan-tree-dump \"a.i\\\\\\[1\\\\\\]\" \"ccp1\" } } */\n+/* { dg-final { scan-tree-dump \"MEM\\\\\\[\\\\\\(int \\\\\\*\\\\\\)&a \\\\\\+ 4B\\\\\\]\" \"ccp1\" } } */\n /* { dg-final { cleanup-tree-dump \"ccp1\" } } */"}, {"sha": "7912a57f09ed0f6f1fd649d026f36db74f067355", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-25.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-25.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -9,6 +9,6 @@ int foo(int i)\n }\n \n /* { dg-final { scan-tree-dump \"&a\\\\\\[\\[iD\\]\\\\\\.\" \"ccp1\" } } */\n-/* { dg-final { scan-tree-dump \"= a\\\\\\[\\[iD\\]\\\\\\.\" \"forwprop1\" } } */\n+/* { dg-final { scan-tree-dump \"= .*&a\\\\\\]\\\\\\[\\[iD\\]\\\\\\.\" \"forwprop1\" } } */\n /* { dg-final { cleanup-tree-dump \"ccp1\" } } */\n /* { dg-final { cleanup-tree-dump \"forwprop1\" } } */"}, {"sha": "c0a548155cb4b011b8787683cd491d2ef47ef23a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-26.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-26.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -7,5 +7,5 @@ int foo(int i)\n   return (a + 1)[i];\n }\n \n-/* { dg-final { scan-tree-dump \"= a\\\\\\[D\\\\\\.\" \"forwprop1\" } } */\n+/* { dg-final { scan-tree-dump \"=.*&a\\\\\\]\\\\\\[D\\\\\\.\" \"forwprop1\" } } */\n /* { dg-final { cleanup-tree-dump \"forwprop1\" } } */"}, {"sha": "b9ec6bc720f7ce752c260bcc7dc3352681fd407d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-1.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-1.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -11,6 +11,5 @@ int f(int *a)\n   return *c + t;\n }\n \n-/* { dg-final { scan-tree-dump \"Replaced \\\\\\(int \\\\\\*\\\\\\) b_.*with a_\" \"fre\" } } */\n-/* { dg-final { scan-tree-dump \"Replaced \\\\\\*c_.*with t_\" \"fre\" } } */\n+/* { dg-final { scan-tree-dump \"Replaced \\\\\\*a_\\[^\\n\\].*with t_\" \"fre\" } } */\n /* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "972e6c69ef9f97391e1141187742a668647252f2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-13.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-13.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -23,6 +23,5 @@ void foo(double (*q)[4], struct Foo *tmp1)\n     }\n }\n \n-/* { dg-final { scan-tree-dump \"Inserted .* &a\" \"fre\" } } */\n-/* { dg-final { scan-tree-dump \"Replaced tmp1_.\\\\\\(D\\\\\\)->data\" \"fre\" } } */\n+/* { dg-final { scan-tree-dump \"Replaced tmp1_.\\\\\\(D\\\\\\)->data with &a\" \"fre\" } } */\n /* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "9d1b3f2ba92de5a413c2d36afcd6f3ada014af1a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-14.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-14.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -27,6 +27,5 @@ void foo(double (*q)[4])\n   bar(a);\n }\n \n-/* { dg-final { scan-tree-dump \"Inserted .* &a\" \"fre\" } } */\n-/* { dg-final { scan-tree-dump \"Replaced tmp1.data\" \"fre\" } } */\n+/* { dg-final { scan-tree-dump \"Replaced tmp1.data with &a\" \"fre\" } } */\n /* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "b986bdd92a9f1955292a8ff6fef6806b227775f8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-26.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-26.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-Os -fdump-tree-pre-details\" } */\n+/* { dg-options \"-O -fdump-tree-fre-details\" } */\n \n typedef union\n {\n@@ -23,5 +23,5 @@ void foo(SA* pResult, SB* method, SC* self)\n     pResult->data = pResult->data;\n }\n \n-/* { dg-final { scan-tree-dump \"Deleted redundant store\" \"pre\" } } */\n-/* { dg-final { cleanup-tree-dump \"pre\" } } */\n+/* { dg-final { scan-tree-dump \"Deleted redundant store\" \"fre\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "f87476a3a9f323cc12c81f802dda0b803720fd2a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-7.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-7.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -7,6 +7,6 @@ foo (int *array)\n           return array[1];\n       return 0;\n }\n-/* We should eliminate one address calculation, and one load.  */\n-/* { dg-final { scan-tree-dump-times \"Eliminated: 2\" 1 \"fre\"} } */\n+/* We should eliminate one load.  */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"fre\"} } */\n /* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "7caf4eec6f8f948ee6dbe990f7cd8ecfdf100ee0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-sccvn-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sccvn-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sccvn-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-sccvn-4.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -23,5 +23,5 @@ int vnum_test8(int *data)\n } \n /* We should eliminate m - n, n + k, set data[5] = 0, eliminate the\n    address arithmetic for data[5], and set p = 0.\n-/* { dg-final { scan-tree-dump-times \"Eliminated: 7\" 1 \"fre\"} } */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 5\" 1 \"fre\"} } */\n /* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "7dc7833647b9b1001fd13d091f90fa78ff072bde", "filename": "gcc/testsuite/gcc.dg/tree-ssa/struct-aliasing-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstruct-aliasing-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstruct-aliasing-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstruct-aliasing-1.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do \"compile\" } */\n-/* { dg-options \"-O2 -fdump-tree-fre\" } */\n+/* { dg-options \"-O2 -fdump-tree-fre-details\" } */\n \n struct S { float f; };\n int __attribute__((noinline))\n@@ -11,5 +11,5 @@ foo (float *r, struct S *p)\n   return i + *q;\n }\n \n-/* { dg-final { scan-tree-dump-times \"\\\\\\*q\" 1 \"fre\" } } */\n+/* { dg-final { scan-tree-dump \"Replaced\\[^\\n\\]*with i_.\" \"fre\" } } */\n /* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "812dac928da8136b6337789438216d7cbe70205a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/struct-aliasing-2.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstruct-aliasing-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstruct-aliasing-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstruct-aliasing-2.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -12,7 +12,8 @@ foo ( struct S *p)\n }\n \n \n-/*  There should only be one load of p->f because fwprop can change *(int *)&p->f into just (int)p->f.  */\n-/* { dg-final { scan-tree-dump-times \"p_.\\\\\\(D\\\\\\)->f\" 1 \"fre\" } } */\n+/* There should only be one load of p->f because fwprop can change\n+   *(int *)&p->f into just (int)p->f.  */\n+/* { dg-final { scan-tree-dump-times \"= \\[^\\n\\]*p_.\\\\\\(D\\\\\\)\" 1 \"fre\" } } */\n /* { dg-final { cleanup-tree-dump \"fre\" } } */\n "}, {"sha": "d663123c83db97e5437baa809ea72a9af56d2555", "filename": "gcc/testsuite/gcc.dg/volatile2.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fvolatile2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgcc.dg%2Fvolatile2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvolatile2.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-gimple -fdump-tree-optimized\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n \n struct GTeth_desc\n {\n@@ -12,14 +12,11 @@ struct GTeth_softc\n \n void foo(struct GTeth_softc *sc)\n {\n-  /* Verify that we retain the cast to (volatile struct GTeth_desc *)\n-     after gimplification and that we keep the volatileness on the\n+  /* Verify that we retain the volatileness on the\n      store until after optimization.  */\n   volatile struct GTeth_desc *p = &sc->txq_desc[0];\n   p->ed_cmdsts = 0;\n }\n \n-/* { dg-final { scan-tree-dump \"\\\\(volatile struct GTeth_desc \\\\*\\\\) D\" \"gimple\" } } */\n /* { dg-final { scan-tree-dump \"{v}\" \"optimized\" } } */\n-/* { dg-final { cleanup-tree-dump \"gimple\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "78097308030300d4622286940219c58bc1f2ecfa", "filename": "gcc/testsuite/gfortran.dg/array_memcpy_3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memcpy_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memcpy_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memcpy_3.f90?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -11,5 +11,5 @@ subroutine bar(x)\n   x = (/ 3, 1, 4, 1 /)\n end subroutine\n \n-! { dg-final { scan-tree-dump-times \"memcpy|ref-all\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"memcpy|(ref-all.*ref-all)\" 2 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "9f2279d881c7ead90b92c631aa70eb1cc8a6c61e", "filename": "gcc/testsuite/gfortran.dg/array_memcpy_4.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memcpy_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memcpy_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_memcpy_4.f90?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -9,5 +9,5 @@\n \n   d = s\n end\n-! { dg-final { scan-tree-dump-times \"d = \" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"MEM.*d\\\\\\] = MEM\" 1 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "a02d56cdc8d1fa742954e59648e3df89be23b275", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -309,6 +309,15 @@ tree_to_aff_combination (tree expr, tree type, aff_tree *comb)\n       return;\n \n     case ADDR_EXPR:\n+      /* Handle &MEM[ptr + CST] which is equivalent to POINTER_PLUS_EXPR.  */\n+      if (TREE_CODE (TREE_OPERAND (expr, 0)) == MEM_REF)\n+\t{\n+\t  expr = TREE_OPERAND (expr, 0);\n+\t  tree_to_aff_combination (TREE_OPERAND (expr, 0), type, comb);\n+\t  tree_to_aff_combination (TREE_OPERAND (expr, 1), sizetype, &tmp);\n+\t  aff_combination_add (comb, &tmp);\n+\t  return;\n+\t}\n       core = get_inner_reference (TREE_OPERAND (expr, 0), &bitsize, &bitpos,\n \t\t\t\t  &toffset, &mode, &unsignedp, &volatilep,\n \t\t\t\t  false);\n@@ -331,6 +340,25 @@ tree_to_aff_combination (tree expr, tree type, aff_tree *comb)\n \t}\n       return;\n \n+    case MEM_REF:\n+      if (TREE_CODE (TREE_OPERAND (expr, 0)) == ADDR_EXPR)\n+\ttree_to_aff_combination (TREE_OPERAND (TREE_OPERAND (expr, 0), 0),\n+\t\t\t\t type, comb);\n+      else if (integer_zerop (TREE_OPERAND (expr, 1)))\n+\t{\n+\t  aff_combination_elt (comb, type, expr);\n+\t  return;\n+\t}\n+      else\n+\taff_combination_elt (comb, type,\n+\t\t\t     build2 (MEM_REF, TREE_TYPE (expr),\n+\t\t\t\t     TREE_OPERAND (expr, 0),\n+\t\t\t\t     build_int_cst\n+\t\t\t\t      (TREE_TYPE (TREE_OPERAND (expr, 1)), 0)));\n+      tree_to_aff_combination (TREE_OPERAND (expr, 1), sizetype, &tmp);\n+      aff_combination_add (comb, &tmp);\n+      return;\n+\n     default:\n       break;\n     }"}, {"sha": "3b8ab9d9e7d5d45339417419e779e5dc78e69706", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 98, "deletions": 40, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -2533,6 +2533,49 @@ gimple_split_edge (edge edge_in)\n   return new_bb;\n }\n \n+\n+/* Verify properties of the address expression T with base object BASE.  */\n+\n+static tree\n+verify_address (tree t, tree base)\n+{\n+  bool old_constant;\n+  bool old_side_effects;\n+  bool new_constant;\n+  bool new_side_effects;\n+\n+  old_constant = TREE_CONSTANT (t);\n+  old_side_effects = TREE_SIDE_EFFECTS (t);\n+\n+  recompute_tree_invariant_for_addr_expr (t);\n+  new_side_effects = TREE_SIDE_EFFECTS (t);\n+  new_constant = TREE_CONSTANT (t);\n+\n+  if (old_constant != new_constant)\n+    {\n+      error (\"constant not recomputed when ADDR_EXPR changed\");\n+      return t;\n+    }\n+  if (old_side_effects != new_side_effects)\n+    {\n+      error (\"side effects not recomputed when ADDR_EXPR changed\");\n+      return t;\n+    }\n+\n+  if (!(TREE_CODE (base) == VAR_DECL\n+\t|| TREE_CODE (base) == PARM_DECL\n+\t|| TREE_CODE (base) == RESULT_DECL))\n+    return NULL_TREE;\n+\n+  if (DECL_GIMPLE_REG_P (base))\n+    {\n+      error (\"DECL_GIMPLE_REG_P set on a variable with address taken\");\n+      return base;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Callback for walk_tree, check that all elements with address taken are\n    properly noticed as such.  The DATA is an int* that is 1 if TP was seen\n    inside a PHI node.  */\n@@ -2561,12 +2604,26 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n       break;\n \n     case INDIRECT_REF:\n+      error (\"INDIRECT_REF in gimple IL\");\n+      return t;\n+\n+    case MEM_REF:\n       x = TREE_OPERAND (t, 0);\n-      if (!is_gimple_reg (x) && !is_gimple_min_invariant (x))\n+      if (!is_gimple_mem_ref_addr (x))\n \t{\n-\t  error (\"Indirect reference's operand is not a register or a constant.\");\n+\t  error (\"Invalid first operand of MEM_REF.\");\n \t  return x;\n \t}\n+      if (TREE_CODE (TREE_OPERAND (t, 1)) != INTEGER_CST\n+\t  || !POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (t, 1))))\n+\t{\n+\t  error (\"Invalid offset operand of MEM_REF.\");\n+\t  return TREE_OPERAND (t, 1);\n+\t}\n+      if (TREE_CODE (x) == ADDR_EXPR\n+\t  && (x = verify_address (x, TREE_OPERAND (x, 0))))\n+\treturn x;\n+      *walk_subtrees = 0;\n       break;\n \n     case ASSERT_EXPR:\n@@ -2584,31 +2641,10 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \n     case ADDR_EXPR:\n       {\n-\tbool old_constant;\n-\tbool old_side_effects;\n-\tbool new_constant;\n-\tbool new_side_effects;\n+\ttree tem;\n \n \tgcc_assert (is_gimple_address (t));\n \n-\told_constant = TREE_CONSTANT (t);\n-\told_side_effects = TREE_SIDE_EFFECTS (t);\n-\n-\trecompute_tree_invariant_for_addr_expr (t);\n-\tnew_side_effects = TREE_SIDE_EFFECTS (t);\n-\tnew_constant = TREE_CONSTANT (t);\n-\n-        if (old_constant != new_constant)\n-\t  {\n-\t    error (\"constant not recomputed when ADDR_EXPR changed\");\n-\t    return t;\n-\t  }\n-\tif (old_side_effects != new_side_effects)\n-\t  {\n-\t    error (\"side effects not recomputed when ADDR_EXPR changed\");\n-\t    return t;\n-\t  }\n-\n \t/* Skip any references (they will be checked when we recurse down the\n \t   tree) and ensure that any variable used as a prefix is marked\n \t   addressable.  */\n@@ -2617,20 +2653,19 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t     x = TREE_OPERAND (x, 0))\n \t  ;\n \n+\tif ((tem = verify_address (t, x)))\n+\t  return tem;\n+\n \tif (!(TREE_CODE (x) == VAR_DECL\n \t      || TREE_CODE (x) == PARM_DECL\n \t      || TREE_CODE (x) == RESULT_DECL))\n \t  return NULL;\n+\n \tif (!TREE_ADDRESSABLE (x))\n \t  {\n \t    error (\"address taken, but ADDRESSABLE bit not set\");\n \t    return x;\n \t  }\n-\tif (DECL_GIMPLE_REG_P (x))\n-\t  {\n-\t    error (\"DECL_GIMPLE_REG_P set on a variable with address taken\");\n-\t    return x;\n-\t  }\n \n \tbreak;\n       }\n@@ -2815,8 +2850,10 @@ verify_types_in_gimple_min_lval (tree expr)\n   if (is_gimple_id (expr))\n     return false;\n \n-  if (!INDIRECT_REF_P (expr)\n-      && TREE_CODE (expr) != TARGET_MEM_REF)\n+  if (TREE_CODE (expr) != ALIGN_INDIRECT_REF\n+      && TREE_CODE (expr) != MISALIGNED_INDIRECT_REF\n+      && TREE_CODE (expr) != TARGET_MEM_REF\n+      && TREE_CODE (expr) != MEM_REF)\n     {\n       error (\"invalid expression for min lvalue\");\n       return true;\n@@ -2833,14 +2870,7 @@ verify_types_in_gimple_min_lval (tree expr)\n       debug_generic_stmt (op);\n       return true;\n     }\n-  if (!useless_type_conversion_p (TREE_TYPE (expr),\n-\t\t\t\t  TREE_TYPE (TREE_TYPE (op))))\n-    {\n-      error (\"type mismatch in indirect reference\");\n-      debug_generic_stmt (TREE_TYPE (expr));\n-      debug_generic_stmt (TREE_TYPE (TREE_TYPE (op)));\n-      return true;\n-    }\n+  /* Memory references now generally can involve a value conversion.  */\n \n   return false;\n }\n@@ -2927,13 +2957,37 @@ verify_types_in_gimple_reference (tree expr, bool require_lvalue)\n \t      debug_generic_stmt (expr);\n \t      return true;\n \t    }\n+\t  else if (TREE_CODE (op) == SSA_NAME\n+\t\t   && TYPE_SIZE (TREE_TYPE (expr)) != TYPE_SIZE (TREE_TYPE (op)))\n+\t    {\n+\t      error (\"Conversion of register to a different size.\");\n+\t      debug_generic_stmt (expr);\n+\t      return true;\n+\t    }\n \t  else if (!handled_component_p (op))\n \t    return false;\n \t}\n \n       expr = op;\n     }\n \n+  if (TREE_CODE (expr) == MEM_REF)\n+    {\n+      if (!is_gimple_mem_ref_addr (TREE_OPERAND (expr, 0)))\n+\t{\n+\t  error (\"Invalid address operand in MEM_REF.\");\n+\t  debug_generic_stmt (expr);\n+\t  return true;\n+\t}\n+      if (TREE_CODE (TREE_OPERAND (expr, 1)) != INTEGER_CST\n+\t  || !POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 1))))\n+\t{\n+\t  error (\"Invalid offset operand in MEM_REF.\");\n+\t  debug_generic_stmt (expr);\n+\t  return true;\n+\t}\n+    }\n+\n   return ((require_lvalue || !is_gimple_min_invariant (expr))\n \t  && verify_types_in_gimple_min_lval (expr));\n }\n@@ -3642,9 +3696,12 @@ verify_gimple_assign_single (gimple stmt)\n       }\n \n     /* tcc_reference  */\n+    case INDIRECT_REF:\n+      error (\"INDIRECT_REF in gimple IL\");\n+      return true;\n+\n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n-    case INDIRECT_REF:\n     case ALIGN_INDIRECT_REF:\n     case MISALIGNED_INDIRECT_REF:\n     case ARRAY_REF:\n@@ -3653,6 +3710,7 @@ verify_gimple_assign_single (gimple stmt)\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n     case TARGET_MEM_REF:\n+    case MEM_REF:\n       if (!is_gimple_reg (lhs)\n \t  && is_gimple_reg_type (TREE_TYPE (lhs)))\n \t{"}, {"sha": "77b5c6a85fd4d43665dc324e56a986a6fb40937e", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -596,10 +596,10 @@ extract_component (gimple_stmt_iterator *gsi, tree t, bool imagpart_p,\n     case VAR_DECL:\n     case RESULT_DECL:\n     case PARM_DECL:\n-    case INDIRECT_REF:\n     case COMPONENT_REF:\n     case ARRAY_REF:\n     case VIEW_CONVERT_EXPR:\n+    case MEM_REF:\n       {\n \ttree inner_type = TREE_TYPE (TREE_TYPE (t));\n "}, {"sha": "7ab7779c5691b3c80ac0c92ef67d5bca728e2739", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -746,7 +746,22 @@ dr_analyze_innermost (struct data_reference *dr)\n       return false;\n     }\n \n-  base = build_fold_addr_expr (base);\n+  if (TREE_CODE (base) == MEM_REF)\n+    {\n+      if (!integer_zerop (TREE_OPERAND (base, 1)))\n+\t{\n+\t  if (!poffset)\n+\t    {\n+\t      double_int moff = mem_ref_offset (base);\n+\t      poffset = double_int_to_tree (sizetype, moff);\n+\t    }\n+\t  else\n+\t    poffset = size_binop (PLUS_EXPR, poffset, TREE_OPERAND (base, 1));\n+\t}\n+      base = TREE_OPERAND (base, 0);\n+    }\n+  else\n+    base = build_fold_addr_expr (base);\n   if (in_loop)\n     {\n       if (!simple_iv (loop, loop_containing_stmt (stmt), base, &base_iv,\n@@ -844,20 +859,41 @@ dr_analyze_indices (struct data_reference *dr, struct loop *nest)\n       aref = TREE_OPERAND (aref, 0);\n     }\n \n-  if (nest && INDIRECT_REF_P (aref))\n+  if (nest\n+      && (INDIRECT_REF_P (aref)\n+\t  || TREE_CODE (aref) == MEM_REF))\n     {\n       op = TREE_OPERAND (aref, 0);\n       access_fn = analyze_scalar_evolution (loop, op);\n       access_fn = instantiate_scev (before_loop, loop, access_fn);\n       base = initial_condition (access_fn);\n       split_constant_offset (base, &base, &off);\n+      if (TREE_CODE (aref) == MEM_REF)\n+\toff = size_binop (PLUS_EXPR, off,\n+\t\t\t  fold_convert (ssizetype, TREE_OPERAND (aref, 1)));\n       access_fn = chrec_replace_initial_condition (access_fn,\n \t\t\tfold_convert (TREE_TYPE (base), off));\n \n       TREE_OPERAND (aref, 0) = base;\n       VEC_safe_push (tree, heap, access_fns, access_fn);\n     }\n \n+  if (TREE_CODE (aref) == MEM_REF)\n+    TREE_OPERAND (aref, 1)\n+      = build_int_cst (TREE_TYPE (TREE_OPERAND (aref, 1)), 0);\n+\n+  if (TREE_CODE (ref) == MEM_REF\n+      && TREE_CODE (TREE_OPERAND (ref, 0)) == ADDR_EXPR\n+      && integer_zerop (TREE_OPERAND (ref, 1)))\n+    ref = TREE_OPERAND (TREE_OPERAND (ref, 0), 0);\n+\n+  /* For canonicalization purposes we'd like to strip all outermost\n+     zero-offset component-refs.\n+     ???  For now simply handle zero-index array-refs.  */\n+  while (TREE_CODE (ref) == ARRAY_REF\n+\t && integer_zerop (TREE_OPERAND (ref, 1)))\n+    ref = TREE_OPERAND (ref, 0);\n+\n   DR_BASE_OBJECT (dr) = ref;\n   DR_ACCESS_FNS (dr) = access_fns;\n }\n@@ -870,7 +906,8 @@ dr_analyze_alias (struct data_reference *dr)\n   tree ref = DR_REF (dr);\n   tree base = get_base_address (ref), addr;\n \n-  if (INDIRECT_REF_P (base))\n+  if (INDIRECT_REF_P (base)\n+      || TREE_CODE (base) == MEM_REF)\n     {\n       addr = TREE_OPERAND (base, 0);\n       if (TREE_CODE (addr) == SSA_NAME)\n@@ -1188,7 +1225,8 @@ object_address_invariant_in_loop_p (const struct loop *loop, const_tree obj)\n       obj = TREE_OPERAND (obj, 0);\n     }\n \n-  if (!INDIRECT_REF_P (obj))\n+  if (!INDIRECT_REF_P (obj)\n+      && TREE_CODE (obj) != MEM_REF)\n     return true;\n \n   return !chrec_contains_symbols_defined_in_loop (TREE_OPERAND (obj, 0),"}, {"sha": "467a6781d7c6d99ccd7bcc4eaae651701c76b56b", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n+#include \"toplev.h\"\n #include \"hashtab.h\"\n #include \"pointer-set.h\"\n #include \"tree.h\"\n@@ -855,6 +856,29 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n \tcase VIEW_CONVERT_EXPR:\n \t  break;\n \n+\tcase MEM_REF:\n+\t  /* Hand back the decl for MEM[&decl, off].  */\n+\t  if (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR)\n+\t    {\n+\t      if (integer_zerop (TREE_OPERAND (exp, 1)))\n+\t\texp = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+\t      else\n+\t\t{\n+\t\t  double_int off = mem_ref_offset (exp);\n+\t\t  off = double_int_lshift (off,\n+\t\t\t\t\t   BITS_PER_UNIT == 8\n+\t\t\t\t\t   ? 3 : exact_log2 (BITS_PER_UNIT),\n+\t\t\t\t\t   HOST_BITS_PER_DOUBLE_INT, true);\n+\t\t  off = double_int_add (off, shwi_to_double_int (bit_offset));\n+\t\t  if (double_int_fits_in_shwi_p (off))\n+\t\t    {\n+\t\t      bit_offset = double_int_to_shwi (off);\n+\t\t      exp = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  goto done;\n+\n \tdefault:\n \t  goto done;\n \t}\n@@ -901,6 +925,104 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n   return exp;\n }\n \n+/* Returns the base object and a constant BITS_PER_UNIT offset in *POFFSET that\n+   denotes the starting address of the memory access EXP.\n+   Returns NULL_TREE if the offset is not constant or any component\n+   is not BITS_PER_UNIT-aligned.  */\n+\n+tree\n+get_addr_base_and_unit_offset (tree exp, HOST_WIDE_INT *poffset)\n+{\n+  HOST_WIDE_INT byte_offset = 0;\n+\n+  /* Compute cumulative byte-offset for nested component-refs and array-refs,\n+     and find the ultimate containing object.  */\n+  while (1)\n+    {\n+      switch (TREE_CODE (exp))\n+\t{\n+\tcase BIT_FIELD_REF:\n+\t  return NULL_TREE;\n+\n+\tcase COMPONENT_REF:\n+\t  {\n+\t    tree field = TREE_OPERAND (exp, 1);\n+\t    tree this_offset = component_ref_field_offset (exp);\n+\t    HOST_WIDE_INT hthis_offset;\n+\n+\t    if (!this_offset\n+\t\t|| TREE_CODE (this_offset) != INTEGER_CST\n+\t\t|| (TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (field))\n+\t\t    % BITS_PER_UNIT))\n+\t      return NULL_TREE;\n+\n+\t    hthis_offset = TREE_INT_CST_LOW (this_offset);\n+\t    hthis_offset += (TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (field))\n+\t\t\t     / BITS_PER_UNIT);\n+\t    byte_offset += hthis_offset;\n+\t  }\n+\t  break;\n+\n+\tcase ARRAY_REF:\n+\tcase ARRAY_RANGE_REF:\n+\t  {\n+\t    tree index = TREE_OPERAND (exp, 1);\n+\t    tree low_bound, unit_size;\n+\n+\t    /* If the resulting bit-offset is constant, track it.  */\n+\t    if (TREE_CODE (index) == INTEGER_CST\n+\t\t&& (low_bound = array_ref_low_bound (exp),\n+\t\t    TREE_CODE (low_bound) == INTEGER_CST)\n+\t\t&& (unit_size = array_ref_element_size (exp),\n+\t\t    TREE_CODE (unit_size) == INTEGER_CST))\n+\t      {\n+\t\tHOST_WIDE_INT hindex = TREE_INT_CST_LOW (index);\n+\n+\t\thindex -= TREE_INT_CST_LOW (low_bound);\n+\t\thindex *= TREE_INT_CST_LOW (unit_size);\n+\t\tbyte_offset += hindex;\n+\t      }\n+\t    else\n+\t      return NULL_TREE;\n+\t  }\n+\t  break;\n+\n+\tcase REALPART_EXPR:\n+\t  break;\n+\n+\tcase IMAGPART_EXPR:\n+\t  byte_offset += TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (exp)));\n+\t  break;\n+\n+\tcase VIEW_CONVERT_EXPR:\n+\t  break;\n+\n+\tcase MEM_REF:\n+\t  /* Hand back the decl for MEM[&decl, off].  */\n+\t  if (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR)\n+\t    {\n+\t      if (!integer_zerop (TREE_OPERAND (exp, 1)))\n+\t\t{\n+\t\t  double_int off = mem_ref_offset (exp);\n+\t\t  gcc_assert (off.high == -1 || off.high == 0);\n+\t\t  byte_offset += double_int_to_shwi (off);\n+\t\t}\n+\t      exp = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+\t    }\n+\t  goto done;\n+\n+\tdefault:\n+\t  goto done;\n+\t}\n+\n+      exp = TREE_OPERAND (exp, 0);\n+    }\n+done:\n+\n+  *poffset = byte_offset;\n+  return exp;\n+}\n+\n /* Returns true if STMT references an SSA_NAME that has\n    SSA_NAME_OCCURS_IN_ABNORMAL_PHI set, otherwise false.  */\n "}, {"sha": "c117013810dd42ebd4f5d66075a82f9cd8337bc7", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -2437,6 +2437,10 @@ tree_could_trap_p (tree expr)\n \treturn false;\n       return !in_array_bounds_p (expr);\n \n+    case MEM_REF:\n+      if (TREE_CODE (TREE_OPERAND (expr, 0)) == ADDR_EXPR)\n+\treturn false;\n+      /* Fallthru.  */\n     case INDIRECT_REF:\n     case ALIGN_INDIRECT_REF:\n     case MISALIGNED_INDIRECT_REF:"}, {"sha": "fb1373a1ad0a0af6c5073e11ef661db6be34e6ce", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -491,6 +491,7 @@ extern tree gimple_default_def (struct function *, tree);\n extern bool stmt_references_abnormal_ssa_name (gimple);\n extern tree get_ref_base_and_extent (tree, HOST_WIDE_INT *,\n \t\t\t\t     HOST_WIDE_INT *, HOST_WIDE_INT *);\n+extern tree get_addr_base_and_unit_offset (tree, HOST_WIDE_INT *);\n extern void find_referenced_vars_in (gimple);\n \n /* In tree-phinodes.c  */\n@@ -572,6 +573,7 @@ void release_ssa_name_after_update_ssa (tree);\n void compute_global_livein (bitmap, bitmap);\n void mark_sym_for_renaming (tree);\n void mark_set_for_renaming (bitmap);\n+bool symbol_marked_for_renaming (tree);\n tree get_current_def (tree);\n void set_current_def (tree, tree);\n "}, {"sha": "3b1c459128fb192974065b964c551971cf9dabc2", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 56, "deletions": 42, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -811,48 +811,49 @@ remap_gimple_op_r (tree *tp, int *walk_subtrees, void *data)\n     {\n       /* Otherwise, just copy the node.  Note that copy_tree_r already\n \t knows not to copy VAR_DECLs, etc., so this is safe.  */\n-      if (TREE_CODE (*tp) == INDIRECT_REF)\n+      if (TREE_CODE (*tp) == MEM_REF)\n \t{\n-\t  /* Get rid of *& from inline substitutions that can happen when a\n-\t     pointer argument is an ADDR_EXPR.  */\n+\t  /* We need to re-canonicalize MEM_REFs from inline substitutions\n+\t     that can happen when a pointer argument is an ADDR_EXPR.  */\n \t  tree decl = TREE_OPERAND (*tp, 0);\n \t  tree *n;\n \n \t  n = (tree *) pointer_map_contains (id->decl_map, decl);\n \t  if (n)\n \t    {\n-\t      tree type, new_tree, old;\n-\n-\t      /* If we happen to get an ADDR_EXPR in n->value, strip\n-\t\t it manually here as we'll eventually get ADDR_EXPRs\n-\t\t which lie about their types pointed to.  In this case\n-\t\t build_fold_indirect_ref wouldn't strip the\n-\t\t INDIRECT_REF, but we absolutely rely on that.  As\n-\t\t fold_indirect_ref does other useful transformations,\n-\t\t try that first, though.  */\n-\t      type = TREE_TYPE (TREE_TYPE (*n));\n-\t      new_tree = unshare_expr (*n);\n-\t      old = *tp;\n-\t      *tp = gimple_fold_indirect_ref (new_tree);\n-\t      if (!*tp)\n-\t        {\n-\t\t  if (TREE_CODE (new_tree) == ADDR_EXPR)\n-\t\t    {\n-\t\t      *tp = fold_indirect_ref_1 (EXPR_LOCATION (new_tree),\n-\t\t\t\t\t\t type, new_tree);\n-\t\t      /* ???  We should either assert here or build\n-\t\t\t a VIEW_CONVERT_EXPR instead of blindly leaking\n-\t\t\t incompatible types to our IL.  */\n-\t\t      if (! *tp)\n-\t\t\t*tp = TREE_OPERAND (new_tree, 0);\n-\t\t    }\n-\t          else\n-\t\t    {\n-\t              *tp = build1 (INDIRECT_REF, type, new_tree);\n-\t\t      TREE_THIS_VOLATILE (*tp) = TREE_THIS_VOLATILE (old);\n-\t\t      TREE_NO_WARNING (*tp) = TREE_NO_WARNING (old);\n-\t\t    }\n+\t      tree old = *tp;\n+\t      tree ptr = unshare_expr (*n);\n+\t      tree tem;\n+\t      if ((tem = maybe_fold_offset_to_reference (EXPR_LOCATION (*tp),\n+\t\t\t\t\t\t\t ptr,\n+\t\t\t\t\t\t\t TREE_OPERAND (*tp, 1),\n+\t\t\t\t\t\t\t TREE_TYPE (*tp)))\n+\t\t  && TREE_THIS_VOLATILE (tem) == TREE_THIS_VOLATILE (old))\n+\t\t{\n+\t\t  tree *tem_basep = &tem;\n+\t\t  while (handled_component_p (*tem_basep))\n+\t\t    tem_basep = &TREE_OPERAND (*tem_basep, 0);\n+\t\t  if (TREE_CODE (*tem_basep) == MEM_REF)\n+\t\t    *tem_basep\n+\t\t      = build2 (MEM_REF, TREE_TYPE (*tem_basep),\n+\t\t\t\tTREE_OPERAND (*tem_basep, 0),\n+\t\t\t\tfold_convert (TREE_TYPE (TREE_OPERAND (*tp, 1)),\n+\t\t\t\t\t      TREE_OPERAND (*tem_basep, 1)));\n+\t\t  else\n+\t\t    *tem_basep\n+\t\t      = build2 (MEM_REF, TREE_TYPE (*tem_basep),\n+\t\t\t\tbuild_fold_addr_expr (*tem_basep),\n+\t\t\t\tbuild_int_cst\n+\t\t\t\t  (TREE_TYPE (TREE_OPERAND (*tp, 1)), 0));\n+\t\t  *tp = tem;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  *tp = fold_build2 (MEM_REF, TREE_TYPE (*tp),\n+\t\t\t\t     ptr, TREE_OPERAND (*tp, 1));\n+\t\t  TREE_THIS_VOLATILE (*tp) = TREE_THIS_VOLATILE (old);\n \t\t}\n+\t      TREE_NO_WARNING (*tp) = TREE_NO_WARNING (old);\n \t      *walk_subtrees = 0;\n \t      return NULL;\n \t    }\n@@ -887,21 +888,15 @@ remap_gimple_op_r (tree *tp, int *walk_subtrees, void *data)\n       else if (TREE_CODE (*tp) == ADDR_EXPR)\n \t{\n \t  /* Variable substitution need not be simple.  In particular,\n-\t     the INDIRECT_REF substitution above.  Make sure that\n+\t     the MEM_REF substitution above.  Make sure that\n \t     TREE_CONSTANT and friends are up-to-date.  But make sure\n \t     to not improperly set TREE_BLOCK on some sub-expressions.  */\n \t  int invariant = is_gimple_min_invariant (*tp);\n \t  tree block = id->block;\n \t  id->block = NULL_TREE;\n \t  walk_tree (&TREE_OPERAND (*tp, 0), remap_gimple_op_r, data, NULL);\n \t  id->block = block;\n-\n-\t  /* Handle the case where we substituted an INDIRECT_REF\n-\t     into the operand of the ADDR_EXPR.  */\n-\t  if (TREE_CODE (TREE_OPERAND (*tp, 0)) == INDIRECT_REF)\n-\t    *tp = TREE_OPERAND (TREE_OPERAND (*tp, 0), 0);\n-\t  else\n-\t    recompute_tree_invariant_for_addr_expr (*tp);\n+\t  recompute_tree_invariant_for_addr_expr (*tp);\n \n \t  /* If this used to be invariant, but is not any longer,\n \t     then regimplification is probably needed.  */\n@@ -1092,6 +1087,25 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n \t      return NULL;\n \t    }\n \t}\n+      else if (TREE_CODE (*tp) == MEM_REF)\n+\t{\n+\t  /* We need to re-canonicalize MEM_REFs from inline substitutions\n+\t     that can happen when a pointer argument is an ADDR_EXPR.  */\n+\t  tree decl = TREE_OPERAND (*tp, 0);\n+\t  tree *n;\n+\n+\t  n = (tree *) pointer_map_contains (id->decl_map, decl);\n+\t  if (n)\n+\t    {\n+\t      tree old = *tp;\n+\t      *tp = fold_build2 (MEM_REF, TREE_TYPE (*tp),\n+\t\t\t\t unshare_expr (*n), TREE_OPERAND (*tp, 1));\n+\t      TREE_THIS_VOLATILE (*tp) = TREE_THIS_VOLATILE (old);\n+\t      TREE_NO_WARNING (*tp) = TREE_NO_WARNING (old);\n+\t      *walk_subtrees = 0;\n+\t      return NULL;\n+\t    }\n+\t}\n \n       /* Here is the \"usual case\".  Copy this tree node, and then\n \t tweak some special cases.  */"}, {"sha": "e49fb035bc124064f13c1d9f3919785dc2397107", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -556,7 +556,7 @@ set_livein_block (tree var, basic_block bb)\n \n /* Return true if symbol SYM is marked for renaming.  */\n \n-static inline bool\n+bool\n symbol_marked_for_renaming (tree sym)\n {\n   return bitmap_bit_p (SYMS_TO_RENAME (cfun), DECL_UID (sym));"}, {"sha": "099a7fe479f727a44e41ab986751acbe034d30b5", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -397,7 +397,7 @@ generate_builtin (struct loop *loop, bitmap partition, bool copy_p)\n   op1 = gimple_assign_rhs1 (write);\n \n   if (!(TREE_CODE (op0) == ARRAY_REF\n-\t|| TREE_CODE (op0) == INDIRECT_REF))\n+\t|| TREE_CODE (op0) == MEM_REF))\n     goto end;\n \n   /* The new statements will be placed before LOOP.  */"}, {"sha": "e70524543c5db1af466a5dcecf75848fd5761001", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -790,7 +790,8 @@ mf_xform_derefs_1 (gimple_stmt_iterator *iter, tree *tp,\n               }\n             else if (TREE_CODE (var) == COMPONENT_REF)\n               var = TREE_OPERAND (var, 0);\n-            else if (INDIRECT_REF_P (var))\n+            else if (INDIRECT_REF_P (var)\n+\t\t     || TREE_CODE (var) == MEM_REF)\n               {\n \t\tbase = TREE_OPERAND (var, 0);\n                 break;\n@@ -868,6 +869,18 @@ mf_xform_derefs_1 (gimple_stmt_iterator *iter, tree *tp,\n \t\t\t   size_int (-1));\n       break;\n \n+    case MEM_REF:\n+      addr = build2 (POINTER_PLUS_EXPR, TREE_TYPE (TREE_OPERAND (t, 1)),\n+\t\t     TREE_OPERAND (t, 0),\n+\t\t     fold_convert (sizetype, TREE_OPERAND (t, 1)));\n+      base = addr;\n+      limit = fold_build2_loc (location, POINTER_PLUS_EXPR, ptr_type_node,\n+\t\t\t   fold_build2_loc (location,\n+\t\t\t\t\tPOINTER_PLUS_EXPR, ptr_type_node, base,\n+\t\t\t\t\tsize),\n+\t\t\t   size_int (-1));\n+      break;\n+\n     case TARGET_MEM_REF:\n       addr = tree_mem_ref_addr (ptr_type_node, t);\n       base = addr;"}, {"sha": "db704b7905578f6b922e48c1a9c7b0abbdf33aa2", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -84,6 +84,7 @@ struct nesting_info\n \n   struct pointer_map_t *field_map;\n   struct pointer_map_t *var_map;\n+  struct pointer_set_t *mem_refs;\n   bitmap suppress_expansion;\n \n   tree context;\n@@ -717,6 +718,7 @@ create_nesting_tree (struct cgraph_node *cgn)\n   struct nesting_info *info = XCNEW (struct nesting_info);\n   info->field_map = pointer_map_create ();\n   info->var_map = pointer_map_create ();\n+  info->mem_refs = pointer_set_create ();\n   info->suppress_expansion = BITMAP_ALLOC (&nesting_info_bitmap_obstack);\n   info->context = cgn->decl;\n \n@@ -758,7 +760,7 @@ get_static_chain (struct nesting_info *info, tree target_context,\n \t{\n \t  tree field = get_chain_field (i);\n \n-\t  x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n+\t  x = build_simple_mem_ref (x);\n \t  x = build3 (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);\n \t  x = init_tmp_var (info, x, gsi);\n \t}\n@@ -793,12 +795,12 @@ get_frame_field (struct nesting_info *info, tree target_context,\n \t{\n \t  tree field = get_chain_field (i);\n \n-\t  x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n+\t  x = build_simple_mem_ref (x);\n \t  x = build3 (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);\n \t  x = init_tmp_var (info, x, gsi);\n \t}\n \n-      x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n+      x = build_simple_mem_ref (x);\n     }\n \n   x = build3 (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);\n@@ -841,16 +843,16 @@ get_nonlocal_debug_decl (struct nesting_info *info, tree decl)\n       for (i = info->outer; i->context != target_context; i = i->outer)\n \t{\n \t  field = get_chain_field (i);\n-\t  x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n+\t  x = build_simple_mem_ref (x);\n \t  x = build3 (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);\n \t}\n-      x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n+      x = build_simple_mem_ref (x);\n     }\n \n   field = lookup_field_for_decl (i, decl, INSERT);\n   x = build3 (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);\n   if (use_pointer_in_frame (decl))\n-    x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n+    x = build_simple_mem_ref (x);\n \n   /* ??? We should be remapping types as well, surely.  */\n   new_decl = build_decl (DECL_SOURCE_LOCATION (decl),\n@@ -927,7 +929,7 @@ convert_nonlocal_reference_op (tree *tp, int *walk_subtrees, void *data)\n \t      if (use_pointer_in_frame (t))\n \t\t{\n \t\t  x = init_tmp_var (info, x, &wi->gsi);\n-\t\t  x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n+\t\t  x = build_simple_mem_ref (x);\n \t\t}\n \t    }\n \n@@ -1498,6 +1500,21 @@ convert_local_reference_op (tree *tp, int *walk_subtrees, void *data)\n       wi->val_only = save_val_only;\n       break;\n \n+    case MEM_REF:\n+      save_val_only = wi->val_only;\n+      wi->val_only = true;\n+      wi->is_lhs = false;\n+      walk_tree (&TREE_OPERAND (t, 0), convert_local_reference_op,\n+\t\t wi, NULL);\n+      /* We need to re-fold the MEM_REF as component references as\n+\t part of a ADDR_EXPR address are not allowed.  But we cannot\n+\t fold here, as the chain record type is not yet finalized.  */\n+      if (TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR\n+\t  && !DECL_P (TREE_OPERAND (TREE_OPERAND (t, 0), 0)))\n+\tpointer_set_insert (info->mem_refs, tp);\n+      wi->val_only = save_val_only;\n+      break;\n+\n     case VIEW_CONVERT_EXPR:\n       /* Just request to look at the subtrees, leaving val_only and lhs\n \t untouched.  This might actually be for !val_only + lhs, in which\n@@ -2247,6 +2264,15 @@ remap_vla_decls (tree block, struct nesting_info *root)\n   pointer_map_destroy (id.cb.decl_map);\n }\n \n+/* Fold the MEM_REF *E.  */\n+static bool\n+fold_mem_refs (const void *e, void *data ATTRIBUTE_UNUSED)\n+{\n+  tree *ref_p = CONST_CAST2(tree *, const tree *, (const tree *)e);\n+  *ref_p = fold (*ref_p);\n+  return true;\n+}\n+\n /* Do \"everything else\" to clean up or complete state collected by the\n    various walking passes -- lay out the types and decls, generate code\n    to initialize the frame decl, store critical expressions in the\n@@ -2461,6 +2487,9 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n \t\t     root->debug_var_chain);\n     }\n \n+  /* Fold the rewritten MEM_REF trees.  */\n+  pointer_set_traverse (root->mem_refs, fold_mem_refs, NULL);\n+\n   /* Dump the translated tree function.  */\n   if (dump_file)\n     {\n@@ -2514,6 +2543,7 @@ free_nesting_tree (struct nesting_info *root)\n       next = iter_nestinfo_next (node);\n       pointer_map_destroy (node->var_map);\n       pointer_map_destroy (node->field_map);\n+      pointer_set_destroy (node->mem_refs);\n       free (node);\n       node = next;\n     }"}, {"sha": "58e8ee47a7d7a6f6a59affeccc6d9ff8edc23396", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -141,6 +141,10 @@ compute_object_offset (const_tree expr, const_tree var)\n       off = size_binop (MULT_EXPR, TYPE_SIZE_UNIT (TREE_TYPE (expr)), t);\n       break;\n \n+    case MEM_REF:\n+      gcc_assert (TREE_CODE (TREE_OPERAND (expr, 0)) == ADDR_EXPR);\n+      return TREE_OPERAND (expr, 1);\n+\n     default:\n       return error_mark_node;\n     }\n@@ -166,15 +170,21 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n     pt_var = get_base_address (pt_var);\n \n   if (pt_var\n-      && TREE_CODE (pt_var) == INDIRECT_REF\n+      && TREE_CODE (pt_var) == MEM_REF\n       && TREE_CODE (TREE_OPERAND (pt_var, 0)) == SSA_NAME\n       && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (pt_var, 0))))\n     {\n       unsigned HOST_WIDE_INT sz;\n \n       if (!osi || (object_size_type & 1) != 0)\n-\tsz = compute_builtin_object_size (TREE_OPERAND (pt_var, 0),\n-\t\t\t\t\t  object_size_type & ~1);\n+\t{\n+\t  sz = compute_builtin_object_size (TREE_OPERAND (pt_var, 0),\n+\t\t\t\t\t    object_size_type & ~1);\n+\t  if (host_integerp (TREE_OPERAND (pt_var, 1), 0))\n+\t    sz -= TREE_INT_CST_LOW (TREE_OPERAND (pt_var, 1));\n+\t  else\n+\t    sz = offset_limit;\n+\t}\n       else\n \t{\n \t  tree var = TREE_OPERAND (pt_var, 0);\n@@ -185,6 +195,10 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \t    sz = object_sizes[object_size_type][SSA_NAME_VERSION (var)];\n \t  else\n \t    sz = unknown[object_size_type];\n+\t  if (host_integerp (TREE_OPERAND (pt_var, 1), 0))\n+\t    sz -= TREE_INT_CST_LOW (TREE_OPERAND (pt_var, 1));\n+\t  else\n+\t    sz = offset_limit;\n \t}\n \n       if (sz != unknown[object_size_type] && sz < offset_limit)\n@@ -225,7 +239,7 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \t\t  && tree_int_cst_lt (pt_var_size,\n \t\t\t\t      TYPE_SIZE_UNIT (TREE_TYPE (var)))))\n \t    var = pt_var;\n-\t  else if (var != pt_var && TREE_CODE (pt_var) == INDIRECT_REF)\n+\t  else if (var != pt_var && TREE_CODE (pt_var) == MEM_REF)\n \t    {\n \t      tree v = var;\n \t      /* For &X->fld, compute object size only if fld isn't the last\n@@ -328,12 +342,14 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \t}\n       if (var != pt_var\n \t  && pt_var_size\n-\t  && TREE_CODE (pt_var) == INDIRECT_REF\n+\t  && TREE_CODE (pt_var) == MEM_REF\n \t  && bytes != error_mark_node)\n \t{\n \t  tree bytes2 = compute_object_offset (TREE_OPERAND (ptr, 0), pt_var);\n \t  if (bytes2 != error_mark_node)\n \t    {\n+\t      bytes2 = size_binop (PLUS_EXPR, bytes2,\n+\t\t\t\t   TREE_OPERAND (pt_var, 1));\n \t      if (TREE_CODE (bytes2) == INTEGER_CST\n \t\t  && tree_int_cst_lt (pt_var_size, bytes2))\n \t\tbytes2 = size_zero_node;\n@@ -746,10 +762,20 @@ plus_stmt_object_size (struct object_size_info *osi, tree var, gimple stmt)\n   unsigned HOST_WIDE_INT bytes;\n   tree op0, op1;\n \n-  gcc_assert (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR);\n-\n-  op0 = gimple_assign_rhs1 (stmt);\n-  op1 = gimple_assign_rhs2 (stmt);\n+  if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n+    {\n+      op0 = gimple_assign_rhs1 (stmt);\n+      op1 = gimple_assign_rhs2 (stmt);\n+    }\n+  else if (gimple_assign_rhs_code (stmt) == ADDR_EXPR)\n+    {\n+      tree rhs = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);\n+      gcc_assert (TREE_CODE (rhs) == MEM_REF);\n+      op0 = TREE_OPERAND (rhs, 0);\n+      op1 = TREE_OPERAND (rhs, 1);\n+    }\n+  else\n+    gcc_unreachable ();\n \n   if (object_sizes[object_size_type][varno] == unknown[object_size_type])\n     return false;\n@@ -897,13 +923,14 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n     {\n     case GIMPLE_ASSIGN:\n       {\n-        if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n+\ttree rhs = gimple_assign_rhs1 (stmt);\n+        if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR\n+\t    || (gimple_assign_rhs_code (stmt) == ADDR_EXPR\n+\t\t&& TREE_CODE (TREE_OPERAND (rhs, 0)) == MEM_REF))\n           reexamine = plus_stmt_object_size (osi, var, stmt);\n         else if (gimple_assign_single_p (stmt)\n                  || gimple_assign_unary_nop_p (stmt))\n           {\n-            tree rhs = gimple_assign_rhs1 (stmt);\n-\n             if (TREE_CODE (rhs) == SSA_NAME\n                 && POINTER_TYPE_P (TREE_TYPE (rhs)))\n               reexamine = merge_object_sizes (osi, var, rhs, 0);"}, {"sha": "af2708667d2a4c93d4087a8a0688799b17090826", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -357,7 +357,7 @@ take_address_of (tree obj, tree type, edge entry, htab_t decl_address)\n \n   if (var_p != &obj)\n     {\n-      *var_p = build1 (INDIRECT_REF, TREE_TYPE (*var_p), name);\n+      *var_p = build_simple_mem_ref (name);\n       name = force_gimple_operand (build_addr (obj, current_function_decl),\n \t\t\t\t   &stmts, true, NULL_TREE);\n       if (!gimple_seq_empty_p (stmts))\n@@ -456,7 +456,7 @@ eliminate_local_variables_1 (tree *tp, int *walk_subtrees, void *data)\n       type = TREE_TYPE (t);\n       addr_type = build_pointer_type (type);\n       addr = take_address_of (t, addr_type, dta->entry, dta->decl_address);\n-      *tp = build1 (INDIRECT_REF, TREE_TYPE (*tp), addr);\n+      *tp = build_simple_mem_ref (addr);\n \n       dta->changed = true;\n       return NULL_TREE;\n@@ -857,7 +857,6 @@ create_call_for_reduction_1 (void **slot, void *data)\n   struct clsn_data *const clsn_data = (struct clsn_data *) data;\n   gimple_stmt_iterator gsi;\n   tree type = TREE_TYPE (PHI_RESULT (reduc->reduc_phi));\n-  tree struct_type = TREE_TYPE (TREE_TYPE (clsn_data->load));\n   tree load_struct;\n   basic_block bb;\n   basic_block new_bb;\n@@ -866,7 +865,7 @@ create_call_for_reduction_1 (void **slot, void *data)\n   tree tmp_load, name;\n   gimple load;\n \n-  load_struct = fold_build1 (INDIRECT_REF, struct_type, clsn_data->load);\n+  load_struct = build_simple_mem_ref (clsn_data->load);\n   t = build3 (COMPONENT_REF, type, load_struct, reduc->field, NULL_TREE);\n \n   addr = build_addr (t, current_function_decl);\n@@ -925,13 +924,12 @@ create_loads_for_reductions (void **slot, void *data)\n   gimple stmt;\n   gimple_stmt_iterator gsi;\n   tree type = TREE_TYPE (gimple_assign_lhs (red->reduc_stmt));\n-  tree struct_type = TREE_TYPE (TREE_TYPE (clsn_data->load));\n   tree load_struct;\n   tree name;\n   tree x;\n \n   gsi = gsi_after_labels (clsn_data->load_bb);\n-  load_struct = fold_build1 (INDIRECT_REF, struct_type, clsn_data->load);\n+  load_struct = build_simple_mem_ref (clsn_data->load);\n   load_struct = build3 (COMPONENT_REF, type, load_struct, red->field,\n \t\t\tNULL_TREE);\n \n@@ -1012,7 +1010,6 @@ create_loads_and_stores_for_name (void **slot, void *data)\n   gimple stmt;\n   gimple_stmt_iterator gsi;\n   tree type = TREE_TYPE (elt->new_name);\n-  tree struct_type = TREE_TYPE (TREE_TYPE (clsn_data->load));\n   tree load_struct;\n \n   gsi = gsi_last_bb (clsn_data->store_bb);\n@@ -1022,7 +1019,7 @@ create_loads_and_stores_for_name (void **slot, void *data)\n   gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n \n   gsi = gsi_last_bb (clsn_data->load_bb);\n-  load_struct = fold_build1 (INDIRECT_REF, struct_type, clsn_data->load);\n+  load_struct = build_simple_mem_ref (clsn_data->load);\n   t = build3 (COMPONENT_REF, type, load_struct, elt->field, NULL_TREE);\n   stmt = gimple_build_assign (elt->new_name, t);\n   SSA_NAME_DEF_STMT (elt->new_name) = stmt;"}, {"sha": "4af074ff5e511cc858621213d26fc43aa6dac3e9", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1345,14 +1345,16 @@ ref_at_iteration (struct loop *loop, tree ref, int iter)\n       if (!op0)\n \treturn NULL_TREE;\n     }\n-  else if (!INDIRECT_REF_P (ref))\n+  else if (!INDIRECT_REF_P (ref)\n+\t   && TREE_CODE (ref) != MEM_REF)\n     return unshare_expr (ref);\n \n-  if (INDIRECT_REF_P (ref))\n+  if (INDIRECT_REF_P (ref)\n+      || TREE_CODE (ref) == MEM_REF)\n     {\n-      /* Take care for INDIRECT_REF and MISALIGNED_INDIRECT_REF at\n+      /* Take care for MEM_REF and MISALIGNED_INDIRECT_REF at\n          the same time.  */\n-      ret = copy_node (ref);\n+      ret = unshare_expr (ref);\n       idx = TREE_OPERAND (ref, 0);\n       idx_p = &TREE_OPERAND (ret, 0);\n     }"}, {"sha": "03cc102458124d6fc50e3a70fd34500f46a9736f", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -794,6 +794,55 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       NIY;\n       break;\n \n+    case MEM_REF:\n+      {\n+\tif (integer_zerop (TREE_OPERAND (node, 1))\n+\t    /* Same pointer types, but ignoring POINTER_TYPE vs.\n+\t       REFERENCE_TYPE.  */\n+\t    && (TREE_TYPE (TREE_TYPE (TREE_OPERAND (node, 0)))\n+\t\t== TREE_TYPE (TREE_TYPE (TREE_OPERAND (node, 1))))\n+\t    && (TYPE_MODE (TREE_TYPE (TREE_OPERAND (node, 0)))\n+\t\t== TYPE_MODE (TREE_TYPE (TREE_OPERAND (node, 1))))\n+\t    && (TYPE_REF_CAN_ALIAS_ALL (TREE_TYPE (TREE_OPERAND (node, 0)))\n+\t\t== TYPE_REF_CAN_ALIAS_ALL (TREE_TYPE (TREE_OPERAND (node, 1))))\n+\t    && (TYPE_QUALS (TREE_TYPE (TREE_OPERAND (node, 0)))\n+\t\t== TYPE_QUALS (TREE_TYPE (TREE_OPERAND (node, 1))))\n+\t    /* Same value types ignoring qualifiers.  */\n+\t    && (TYPE_MAIN_VARIANT (TREE_TYPE (node))\n+\t\t== TYPE_MAIN_VARIANT\n+\t\t    (TREE_TYPE (TREE_TYPE (TREE_OPERAND (node, 1))))))\n+\t  {\n+\t    if (TREE_CODE (TREE_OPERAND (node, 0)) != ADDR_EXPR)\n+\t      {\n+\t\tpp_string (buffer, \"*\");\n+\t\tdump_generic_node (buffer, TREE_OPERAND (node, 0),\n+\t\t\t\t   spc, flags, false);\n+\t      }\n+\t    else\n+\t      dump_generic_node (buffer,\n+\t\t\t\t TREE_OPERAND (TREE_OPERAND (node, 0), 0),\n+\t\t\t\t spc, flags, false);\n+\t  }\n+\telse\n+\t  {\n+\t    pp_string (buffer, \"MEM[\");\n+\t    pp_string (buffer, \"(\");\n+\t    dump_generic_node (buffer, TREE_TYPE (TREE_OPERAND (node, 1)),\n+\t\t\t       spc, flags, false);\n+\t    pp_string (buffer, \")\");\n+\t    dump_generic_node (buffer, TREE_OPERAND (node, 0),\n+\t\t\t       spc, flags, false);\n+\t    if (!integer_zerop (TREE_OPERAND (node, 1)))\n+\t      {\n+\t\tpp_string (buffer, \" + \");\n+\t\tdump_generic_node (buffer, TREE_OPERAND (node, 1),\n+\t\t\t\t   spc, flags, false);\n+\t      }\n+\t    pp_string (buffer, \"]\");\n+\t  }\n+\tbreak;\n+      }\n+\n     case TARGET_MEM_REF:\n       {\n \tconst char *sep = \"\";\n@@ -1100,7 +1149,25 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n     case COMPONENT_REF:\n       op0 = TREE_OPERAND (node, 0);\n       str = \".\";\n-      if (op0 && TREE_CODE (op0) == INDIRECT_REF)\n+      if (op0\n+\t  && (TREE_CODE (op0) == INDIRECT_REF\n+\t      || (TREE_CODE (op0) == MEM_REF\n+\t\t  && TREE_CODE (TREE_OPERAND (op0, 0)) != ADDR_EXPR\n+\t\t  && integer_zerop (TREE_OPERAND (op0, 1))\n+\t\t  /* Same pointer types, but ignoring POINTER_TYPE vs.\n+\t\t     REFERENCE_TYPE.  */\n+\t\t  && (TREE_TYPE (TREE_TYPE (TREE_OPERAND (op0, 0)))\n+\t\t      == TREE_TYPE (TREE_TYPE (TREE_OPERAND (op0, 1))))\n+\t\t  && (TYPE_MODE (TREE_TYPE (TREE_OPERAND (op0, 0)))\n+\t\t      == TYPE_MODE (TREE_TYPE (TREE_OPERAND (op0, 1))))\n+\t\t  && (TYPE_REF_CAN_ALIAS_ALL (TREE_TYPE (TREE_OPERAND (op0, 0)))\n+\t\t      == TYPE_REF_CAN_ALIAS_ALL (TREE_TYPE (TREE_OPERAND (op0, 1))))\n+\t\t  && (TYPE_QUALS (TREE_TYPE (TREE_OPERAND (op0, 0)))\n+\t\t      == TYPE_QUALS (TREE_TYPE (TREE_OPERAND (op0, 1))))\n+\t\t  /* Same value types ignoring qualifiers.  */\n+\t\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (op0))\n+\t\t      == TYPE_MAIN_VARIANT\n+\t\t          (TREE_TYPE (TREE_TYPE (TREE_OPERAND (op0, 1))))))))\n \t{\n \t  op0 = TREE_OPERAND (op0, 0);\n \t  str = \"->\";\n@@ -2760,6 +2827,13 @@ print_call_name (pretty_printer *buffer, tree node, int flags)\n \tdump_generic_node (buffer, op0, 0, flags, false);\n       break;\n \n+    case MEM_REF:\n+      if (integer_zerop (TREE_OPERAND (op0, 1)))\n+\t{\n+\t  op0 = TREE_OPERAND (op0, 0);\n+\t  goto again;\n+\t}\n+      /* Fallthru.  */\n     case COMPONENT_REF:\n     case SSA_NAME:\n     case OBJ_TYPE_REF:"}, {"sha": "0e372567c8954e677e03026b93ac80b13d7dadd8", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1170,6 +1170,24 @@ follow_ssa_edge_expr (struct loop *loop, gimple at_stmt, tree expr,\n \t\t\t\t    halting_phi, evolution_of_loop, limit);\n       break;\n \n+    case ADDR_EXPR:\n+      /* Handle &MEM[ptr + CST] which is equivalent to POINTER_PLUS_EXPR.  */\n+      if (TREE_CODE (TREE_OPERAND (expr, 0)) == MEM_REF)\n+\t{\n+\t  expr = TREE_OPERAND (expr, 0);\n+\t  rhs0 = TREE_OPERAND (expr, 0);\n+\t  rhs1 = TREE_OPERAND (expr, 1);\n+\t  type = TREE_TYPE (rhs0);\n+\t  STRIP_USELESS_TYPE_CONVERSION (rhs0);\n+\t  STRIP_USELESS_TYPE_CONVERSION (rhs1);\n+\t  res = follow_ssa_edge_binary (loop, at_stmt, type,\n+\t\t\t\t\trhs0, POINTER_PLUS_EXPR, rhs1,\n+\t\t\t\t\thalting_phi, evolution_of_loop, limit);\n+\t}\n+      else\n+\tres = t_false;\n+      break;\n+\n     case ASSERT_EXPR:\n       /* This assignment is of the form: \"a_1 = ASSERT_EXPR <a_2, ...>\"\n \t It must be handled as a copy assignment of the form a_1 = a_2.  */"}, {"sha": "05e3cf800aadad6cdf625f37325394e430c3bcee", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 51, "deletions": 36, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -751,7 +751,8 @@ create_access (tree expr, gimple stmt, bool write)\n \n   base = get_ref_base_and_extent (expr, &offset, &size, &max_size);\n \n-  if (sra_mode == SRA_MODE_EARLY_IPA && INDIRECT_REF_P (base))\n+  if (sra_mode == SRA_MODE_EARLY_IPA\n+      && TREE_CODE (base) == MEM_REF)\n     {\n       base = get_ssa_base_param (TREE_OPERAND (base, 0));\n       if (!base)\n@@ -885,15 +886,10 @@ completely_scalarize_record (tree base, tree decl, HOST_WIDE_INT offset)\n static void\n disqualify_base_of_expr (tree t, const char *reason)\n {\n-  while (handled_component_p (t))\n-    t = TREE_OPERAND (t, 0);\n-\n-  if (sra_mode == SRA_MODE_EARLY_IPA)\n-    {\n-      if (INDIRECT_REF_P (t))\n-\tt = TREE_OPERAND (t, 0);\n-      t = get_ssa_base_param (t);\n-    }\n+  t = get_base_address (t);\n+  if (sra_mode == SRA_MODE_EARLY_IPA\n+      && TREE_CODE (t) == MEM_REF)\n+    t = get_ssa_base_param (TREE_OPERAND (t, 0));\n \n   if (t && DECL_P (t))\n     disqualify_candidate (t, reason);\n@@ -935,8 +931,9 @@ build_access_from_expr_1 (tree expr, gimple stmt, bool write)\n \n   switch (TREE_CODE (expr))\n     {\n-    case INDIRECT_REF:\n-      if (sra_mode != SRA_MODE_EARLY_IPA)\n+    case MEM_REF:\n+      if (TREE_CODE (TREE_OPERAND (expr, 0)) != ADDR_EXPR\n+\t  && sra_mode != SRA_MODE_EARLY_IPA)\n \treturn NULL;\n       /* fall through */\n     case VAR_DECL:\n@@ -1285,7 +1282,21 @@ make_fancy_name_1 (tree expr)\n \tbreak;\n       sprintf (buffer, HOST_WIDE_INT_PRINT_DEC, TREE_INT_CST_LOW (index));\n       obstack_grow (&name_obstack, buffer, strlen (buffer));\n+      break;\n \n+    case ADDR_EXPR:\n+      make_fancy_name_1 (TREE_OPERAND (expr, 0));\n+      break;\n+\n+    case MEM_REF:\n+      make_fancy_name_1 (TREE_OPERAND (expr, 0));\n+      if (!integer_zerop (TREE_OPERAND (expr, 1)))\n+\t{\n+\t  obstack_1grow (&name_obstack, '$');\n+\t  sprintf (buffer, HOST_WIDE_INT_PRINT_DEC,\n+\t\t   TREE_INT_CST_LOW (TREE_OPERAND (expr, 1)));\n+\t  obstack_grow (&name_obstack, buffer, strlen (buffer));\n+\t}\n       break;\n \n     case BIT_FIELD_REF:\n@@ -1308,7 +1319,11 @@ make_fancy_name (tree expr)\n   return XOBFINISH (&name_obstack, char *);\n }\n \n-/* Helper function for build_ref_for_offset.  */\n+/* Helper function for build_ref_for_offset.\n+\n+   FIXME: Eventually this should be rewritten to either re-use the\n+   original access expression unshared (which is good for alias\n+   analysis) or to build a MEM_REF expression.  */\n \n static bool\n build_ref_for_offset_1 (tree *res, tree type, HOST_WIDE_INT offset,\n@@ -1406,12 +1421,7 @@ build_ref_for_offset_1 (tree *res, tree type, HOST_WIDE_INT offset,\n    type TYPE at the given OFFSET of the type EXP_TYPE.  If EXPR is NULL, the\n    function only determines whether it can build such a reference without\n    actually doing it, otherwise, the tree it points to is unshared first and\n-   then used as a base for furhter sub-references.\n-\n-   FIXME: Eventually this should be replaced with\n-   maybe_fold_offset_to_reference() from tree-ssa-ccp.c but that requires a\n-   minor rewrite of fold_stmt.\n- */\n+   then used as a base for furhter sub-references.  */\n \n bool\n build_ref_for_offset (tree *expr, tree type, HOST_WIDE_INT offset,\n@@ -1426,7 +1436,7 @@ build_ref_for_offset (tree *expr, tree type, HOST_WIDE_INT offset,\n     {\n       type = TREE_TYPE (type);\n       if (expr)\n-\t*expr = fold_build1_loc (loc, INDIRECT_REF, type, *expr);\n+\t*expr = build_simple_mem_ref_loc (loc, *expr);\n     }\n \n   return build_ref_for_offset_1 (expr, type, offset, exp_type);\n@@ -3026,17 +3036,23 @@ ptr_parm_has_direct_uses (tree parm)\n \t  tree lhs = gimple_get_lhs (stmt);\n \t  while (handled_component_p (lhs))\n \t    lhs = TREE_OPERAND (lhs, 0);\n-\t  if (INDIRECT_REF_P (lhs)\n-\t      && TREE_OPERAND (lhs, 0) == name)\n+\t  if (TREE_CODE (lhs) == MEM_REF\n+\t      && TREE_OPERAND (lhs, 0) == name\n+\t      && integer_zerop (TREE_OPERAND (lhs, 1))\n+\t      && types_compatible_p (TREE_TYPE (lhs),\n+\t\t\t\t     TREE_TYPE (TREE_TYPE (name))))\n \t    uses_ok++;\n \t}\n       if (gimple_assign_single_p (stmt))\n \t{\n \t  tree rhs = gimple_assign_rhs1 (stmt);\n \t  while (handled_component_p (rhs))\n \t    rhs = TREE_OPERAND (rhs, 0);\n-\t  if (INDIRECT_REF_P (rhs)\n-\t      && TREE_OPERAND (rhs, 0) == name)\n+\t  if (TREE_CODE (rhs) == MEM_REF\n+\t      && TREE_OPERAND (rhs, 0) == name\n+\t      && integer_zerop (TREE_OPERAND (rhs, 1))\n+\t      && types_compatible_p (TREE_TYPE (rhs),\n+\t\t\t\t     TREE_TYPE (TREE_TYPE (name))))\n \t    uses_ok++;\n \t}\n       else if (is_gimple_call (stmt))\n@@ -3047,8 +3063,11 @@ ptr_parm_has_direct_uses (tree parm)\n \t      tree arg = gimple_call_arg (stmt, i);\n \t      while (handled_component_p (arg))\n \t\targ = TREE_OPERAND (arg, 0);\n-\t      if (INDIRECT_REF_P (arg)\n-\t\t  && TREE_OPERAND (arg, 0) == name)\n+\t      if (TREE_CODE (arg) == MEM_REF\n+\t\t  && TREE_OPERAND (arg, 0) == name\n+\t\t  && integer_zerop (TREE_OPERAND (arg, 1))\n+\t\t  && types_compatible_p (TREE_TYPE (arg),\n+\t\t\t\t\t TREE_TYPE (TREE_TYPE (name))))\n \t\tuses_ok++;\n \t    }\n \t}\n@@ -3917,8 +3936,11 @@ sra_ipa_modify_expr (tree *expr, bool convert,\n   if (!base || size == -1 || max_size == -1)\n     return false;\n \n-  if (INDIRECT_REF_P (base))\n-    base = TREE_OPERAND (base, 0);\n+  if (TREE_CODE (base) == MEM_REF)\n+    {\n+      offset += mem_ref_offset (base).low * BITS_PER_UNIT;\n+      base = TREE_OPERAND (base, 0);\n+    }\n \n   base = get_ssa_base_param (base);\n   if (!base || TREE_CODE (base) != PARM_DECL)\n@@ -3939,14 +3961,7 @@ sra_ipa_modify_expr (tree *expr, bool convert,\n     return false;\n \n   if (cand->by_ref)\n-    {\n-      tree folded;\n-      src = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (cand->reduction)),\n-\t\t    cand->reduction);\n-      folded = gimple_fold_indirect_ref (src);\n-      if (folded)\n-        src = folded;\n-    }\n+    src = build_simple_mem_ref (cand->reduction);\n   else\n     src = cand->reduction;\n "}, {"sha": "78eb362ca5c7f238ccd93529bc16b46a2a7dc793", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 136, "deletions": 102, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -182,7 +182,8 @@ ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n     {\n       tree base = get_base_address (TREE_OPERAND (ptr, 0));\n       if (base\n-\t  && INDIRECT_REF_P (base))\n+\t  && (INDIRECT_REF_P (base)\n+\t      || TREE_CODE (base) == MEM_REF))\n \tptr = TREE_OPERAND (base, 0);\n       else if (base\n \t       && SSA_VAR_P (base))\n@@ -238,7 +239,8 @@ ptr_derefs_may_alias_p (tree ptr1, tree ptr2)\n     {\n       tree base = get_base_address (TREE_OPERAND (ptr1, 0));\n       if (base\n-\t  && INDIRECT_REF_P (base))\n+\t  && (INDIRECT_REF_P (base)\n+\t      || TREE_CODE (base) == MEM_REF))\n \tptr1 = TREE_OPERAND (base, 0);\n       else if (base\n \t       && SSA_VAR_P (base))\n@@ -250,7 +252,8 @@ ptr_derefs_may_alias_p (tree ptr1, tree ptr2)\n     {\n       tree base = get_base_address (TREE_OPERAND (ptr2, 0));\n       if (base\n-\t  && INDIRECT_REF_P (base))\n+\t  && (INDIRECT_REF_P (base)\n+\t      || TREE_CODE (base) == MEM_REF))\n \tptr2 = TREE_OPERAND (base, 0);\n       else if (base\n \t       && SSA_VAR_P (base))\n@@ -299,7 +302,8 @@ ptr_deref_may_alias_ref_p_1 (tree ptr, ao_ref *ref)\n {\n   tree base = ao_ref_base (ref);\n \n-  if (INDIRECT_REF_P (base))\n+  if (INDIRECT_REF_P (base)\n+      || TREE_CODE (base) == MEM_REF)\n     return ptr_derefs_may_alias_p (ptr, TREE_OPERAND (base, 0));\n   else if (SSA_VAR_P (base))\n     return ptr_deref_may_alias_decl_p (ptr, base);\n@@ -470,12 +474,18 @@ ao_ref_base (ao_ref *ref)\n \n /* Returns the base object alias set of the memory reference *REF.  */\n \n-static alias_set_type ATTRIBUTE_UNUSED\n+static alias_set_type\n ao_ref_base_alias_set (ao_ref *ref)\n {\n+  tree base_ref;\n   if (ref->base_alias_set != -1)\n     return ref->base_alias_set;\n-  ref->base_alias_set = get_alias_set (ao_ref_base (ref));\n+  if (!ref->ref)\n+    return 0;\n+  base_ref = ref->ref;\n+  while (handled_component_p (base_ref))\n+    base_ref = TREE_OPERAND (base_ref, 0);\n+  ref->base_alias_set = get_alias_set (base_ref);\n   return ref->base_alias_set;\n }\n \n@@ -505,7 +515,8 @@ ao_ref_init_from_ptr_and_size (ao_ref *ref, tree ptr, tree size)\n \t\t\t\t\t &ref->offset, &t1, &t2);\n   else\n     {\n-      ref->base = build1 (INDIRECT_REF, char_type_node, ptr);\n+      ref->base = build2 (MEM_REF, char_type_node,\n+\t\t\t  ptr, build_int_cst (ptr_type_node, 0));\n       ref->offset = 0;\n     }\n   if (size\n@@ -665,56 +676,98 @@ decl_refs_may_alias_p (tree base1,\n    if non-NULL are the complete memory reference trees.  */\n \n static bool\n-indirect_ref_may_alias_decl_p (tree ref1, tree ptr1,\n-\t\t\t       HOST_WIDE_INT offset1, HOST_WIDE_INT max_size1,\n+indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n+\t\t\t       HOST_WIDE_INT offset1,\n+\t\t\t       HOST_WIDE_INT max_size1 ATTRIBUTE_UNUSED,\n \t\t\t       alias_set_type ref1_alias_set,\n \t\t\t       alias_set_type base1_alias_set,\n-\t\t\t       tree ref2, tree base2,\n+\t\t\t       tree ref2 ATTRIBUTE_UNUSED, tree base2,\n \t\t\t       HOST_WIDE_INT offset2, HOST_WIDE_INT max_size2,\n \t\t\t       alias_set_type ref2_alias_set,\n-\t\t\t       alias_set_type base2_alias_set)\n+\t\t\t       alias_set_type base2_alias_set, bool tbaa_p)\n {\n+  tree ptr1 = TREE_OPERAND (base1, 0);\n+  tree ptrtype1;\n+  HOST_WIDE_INT offset1p = offset1;\n+\n+  if (TREE_CODE (base1) == MEM_REF)\n+    offset1p = offset1 + mem_ref_offset (base1).low * BITS_PER_UNIT;\n+\n   /* If only one reference is based on a variable, they cannot alias if\n      the pointer access is beyond the extent of the variable access.\n      (the pointer base cannot validly point to an offset less than zero\n      of the variable).\n      They also cannot alias if the pointer may not point to the decl.  */\n-  if (max_size2 != -1\n-      && !ranges_overlap_p (offset1, max_size1, 0, offset2 + max_size2))\n+  if (!ranges_overlap_p (MAX (0, offset1p), -1, offset2, max_size2))\n     return false;\n   if (!ptr_deref_may_alias_decl_p (ptr1, base2))\n     return false;\n \n   /* Disambiguations that rely on strict aliasing rules follow.  */\n-  if (!flag_strict_aliasing)\n+  if (!flag_strict_aliasing || !tbaa_p)\n     return true;\n \n+  if (TREE_CODE (base1) == MEM_REF)\n+    ptrtype1 = TREE_TYPE (TREE_OPERAND (base1, 1));\n+  else\n+    ptrtype1 = TREE_TYPE (ptr1);\n+\n   /* If the alias set for a pointer access is zero all bets are off.  */\n   if (base1_alias_set == -1)\n-    base1_alias_set = get_deref_alias_set (ptr1);\n+    base1_alias_set = get_deref_alias_set (ptrtype1);\n   if (base1_alias_set == 0)\n     return true;\n   if (base2_alias_set == -1)\n     base2_alias_set = get_alias_set (base2);\n \n   /* If both references are through the same type, they do not alias\n      if the accesses do not overlap.  This does extra disambiguation\n-     for mixed/pointer accesses but requires strict aliasing.  */\n-  if (same_type_for_tbaa (TREE_TYPE (TREE_TYPE (ptr1)),\n-\t\t\t  TREE_TYPE (base2)) == 1)\n+     for mixed/pointer accesses but requires strict aliasing.\n+     For MEM_REFs we require that the component-ref offset we computed\n+     is relative to the start of the type which we ensure by\n+     comparing rvalue and access type and disregarding the constant\n+     pointer offset.  */\n+  if ((TREE_CODE (base1) != MEM_REF\n+       || same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (ptrtype1)) == 1)\n+      && same_type_for_tbaa (TREE_TYPE (ptrtype1), TREE_TYPE (base2)) == 1)\n     return ranges_overlap_p (offset1, max_size1, offset2, max_size2);\n \n-  /* The only way to access a variable is through a pointer dereference\n-     of the same alias set or a subset of it.  */\n+  /* When we are trying to disambiguate an access with a pointer dereference\n+     as base versus one with a decl as base we can use both the size\n+     of the decl and its dynamic type for extra disambiguation.\n+     ???  We do not know anything about the dynamic type of the decl\n+     other than that its alias-set contains base2_alias_set as a subset\n+     which does not help us here.  */\n+  /* As we know nothing useful about the dynamic type of the decl just\n+     use the usual conflict check rather than a subset test.\n+     ???  We could introduce -fvery-strict-aliasing when the language\n+     does not allow decls to have a dynamic type that differs from their\n+     static type.  Then we can check \n+     !alias_set_subset_of (base1_alias_set, base2_alias_set) instead.  */\n   if (base1_alias_set != base2_alias_set\n-      && !alias_set_subset_of (base1_alias_set, base2_alias_set))\n+      && !alias_sets_conflict_p (base1_alias_set, base2_alias_set))\n+    return false;\n+  /* If the size of the access relevant for TBAA through the pointer\n+     is bigger than the size of the decl we can't possibly access the\n+     decl via that pointer.  */\n+  if (DECL_SIZE (base2) && COMPLETE_TYPE_P (TREE_TYPE (ptrtype1))\n+      && TREE_CODE (DECL_SIZE (base2)) == INTEGER_CST\n+      && TREE_CODE (TYPE_SIZE (TREE_TYPE (ptrtype1))) == INTEGER_CST\n+      /* ???  This in turn may run afoul when a decl of type T which is\n+\t a member of union type U is accessed through a pointer to\n+\t type U and sizeof T is smaller than sizeof U.  */\n+      && TREE_CODE (TREE_TYPE (ptrtype1)) != UNION_TYPE\n+      && TREE_CODE (TREE_TYPE (ptrtype1)) != QUAL_UNION_TYPE\n+      && tree_int_cst_lt (DECL_SIZE (base2), TYPE_SIZE (TREE_TYPE (ptrtype1))))\n     return false;\n \n   /* Do access-path based disambiguation.  */\n   if (ref1 && ref2\n       && handled_component_p (ref1)\n-      && handled_component_p (ref2))\n-    return aliasing_component_refs_p (ref1, TREE_TYPE (TREE_TYPE (ptr1)),\n+      && handled_component_p (ref2)\n+      && (TREE_CODE (base1) != MEM_REF\n+\t  || same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (ptrtype1)) == 1))\n+    return aliasing_component_refs_p (ref1, TREE_TYPE (ptrtype1),\n \t\t\t\t      ref1_alias_set, base1_alias_set,\n \t\t\t\t      offset1, max_size1,\n \t\t\t\t      ref2, TREE_TYPE (base2),\n@@ -732,42 +785,65 @@ indirect_ref_may_alias_decl_p (tree ref1, tree ptr1,\n    if non-NULL are the complete memory reference trees. */\n \n static bool\n-indirect_refs_may_alias_p (tree ref1, tree ptr1,\n+indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n \t\t\t   HOST_WIDE_INT offset1, HOST_WIDE_INT max_size1,\n \t\t\t   alias_set_type ref1_alias_set,\n \t\t\t   alias_set_type base1_alias_set,\n-\t\t\t   tree ref2, tree ptr2,\n+\t\t\t   tree ref2 ATTRIBUTE_UNUSED, tree base2,\n \t\t\t   HOST_WIDE_INT offset2, HOST_WIDE_INT max_size2,\n \t\t\t   alias_set_type ref2_alias_set,\n-\t\t\t   alias_set_type base2_alias_set)\n+\t\t\t   alias_set_type base2_alias_set, bool tbaa_p)\n {\n+  tree ptr1 = TREE_OPERAND (base1, 0);\n+  tree ptr2 = TREE_OPERAND (base2, 0);\n+  tree ptrtype1, ptrtype2;\n+\n   /* If both bases are based on pointers they cannot alias if they may not\n      point to the same memory object or if they point to the same object\n      and the accesses do not overlap.  */\n   if (operand_equal_p (ptr1, ptr2, 0))\n-    return ranges_overlap_p (offset1, max_size1, offset2, max_size2);\n+    {\n+      if (TREE_CODE (base1) == MEM_REF)\n+\toffset1 += mem_ref_offset (base1).low * BITS_PER_UNIT;\n+      if (TREE_CODE (base2) == MEM_REF)\n+\toffset2 += mem_ref_offset (base2).low * BITS_PER_UNIT;\n+      return ranges_overlap_p (offset1, max_size1, offset2, max_size2);\n+    }\n   if (!ptr_derefs_may_alias_p (ptr1, ptr2))\n     return false;\n \n   /* Disambiguations that rely on strict aliasing rules follow.  */\n-  if (!flag_strict_aliasing)\n+  if (!flag_strict_aliasing || !tbaa_p)\n     return true;\n \n+  if (TREE_CODE (base1) == MEM_REF)\n+    ptrtype1 = TREE_TYPE (TREE_OPERAND (base1, 1));\n+  else\n+    ptrtype1 = TREE_TYPE (ptr1);\n+  if (TREE_CODE (base2) == MEM_REF)\n+    ptrtype2 = TREE_TYPE (TREE_OPERAND (base2, 1));\n+  else\n+    ptrtype2 = TREE_TYPE (ptr2);\n+\n   /* If the alias set for a pointer access is zero all bets are off.  */\n   if (base1_alias_set == -1)\n-    base1_alias_set = get_deref_alias_set (ptr1);\n+    base1_alias_set = get_deref_alias_set (ptrtype1);\n   if (base1_alias_set == 0)\n     return true;\n   if (base2_alias_set == -1)\n-    base2_alias_set = get_deref_alias_set (ptr2);\n+    base2_alias_set = get_deref_alias_set (ptrtype2);\n   if (base2_alias_set == 0)\n     return true;\n \n   /* If both references are through the same type, they do not alias\n      if the accesses do not overlap.  This does extra disambiguation\n      for mixed/pointer accesses but requires strict aliasing.  */\n-  if (same_type_for_tbaa (TREE_TYPE (TREE_TYPE (ptr1)),\n-\t\t\t  TREE_TYPE (TREE_TYPE (ptr2))) == 1)\n+  if ((TREE_CODE (base1) != MEM_REF\n+       || same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (ptrtype1)) == 1)\n+      && (TREE_CODE (base2) != MEM_REF\n+\t  || same_type_for_tbaa (TREE_TYPE (base2), TREE_TYPE (ptrtype2)) == 1)\n+      && same_type_for_tbaa (TREE_TYPE (ptrtype1),\n+\t\t\t     TREE_TYPE (ptrtype2)) == 1)\n     return ranges_overlap_p (offset1, max_size1, offset2, max_size2);\n \n   /* Do type-based disambiguation.  */\n@@ -778,11 +854,15 @@ indirect_refs_may_alias_p (tree ref1, tree ptr1,\n   /* Do access-path based disambiguation.  */\n   if (ref1 && ref2\n       && handled_component_p (ref1)\n-      && handled_component_p (ref2))\n-    return aliasing_component_refs_p (ref1, TREE_TYPE (TREE_TYPE (ptr1)),\n+      && handled_component_p (ref2)\n+      && (TREE_CODE (base1) != MEM_REF\n+\t  || same_type_for_tbaa (TREE_TYPE (base1), TREE_TYPE (ptrtype1)) == 1)\n+      && (TREE_CODE (base2) != MEM_REF\n+\t  || same_type_for_tbaa (TREE_TYPE (base2), TREE_TYPE (ptrtype2)) == 1))\n+    return aliasing_component_refs_p (ref1, TREE_TYPE (ptrtype1),\n \t\t\t\t      ref1_alias_set, base1_alias_set,\n \t\t\t\t      offset1, max_size1,\n-\t\t\t\t      ref2, TREE_TYPE (TREE_TYPE (ptr2)),\n+\t\t\t\t      ref2, TREE_TYPE (ptrtype2),\n \t\t\t\t      ref2_alias_set, base2_alias_set,\n \t\t\t\t      offset2, max_size2, false);\n \n@@ -798,19 +878,20 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n   HOST_WIDE_INT offset1 = 0, offset2 = 0;\n   HOST_WIDE_INT max_size1 = -1, max_size2 = -1;\n   bool var1_p, var2_p, ind1_p, ind2_p;\n-  alias_set_type set;\n \n   gcc_checking_assert ((!ref1->ref\n \t\t\t|| TREE_CODE (ref1->ref) == SSA_NAME\n \t\t\t|| DECL_P (ref1->ref)\n \t\t\t|| handled_component_p (ref1->ref)\n \t\t\t|| INDIRECT_REF_P (ref1->ref)\n+\t\t\t|| TREE_CODE (ref1->ref) == MEM_REF\n \t\t\t|| TREE_CODE (ref1->ref) == TARGET_MEM_REF)\n \t\t       && (!ref2->ref\n \t\t\t   || TREE_CODE (ref2->ref) == SSA_NAME\n \t\t\t   || DECL_P (ref2->ref)\n \t\t\t   || handled_component_p (ref2->ref)\n \t\t\t   || INDIRECT_REF_P (ref2->ref)\n+\t\t\t   || TREE_CODE (ref2->ref) == MEM_REF\n \t\t\t   || TREE_CODE (ref2->ref) == TARGET_MEM_REF));\n \n   /* Decompose the references into their base objects and the access.  */\n@@ -851,8 +932,9 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n     return decl_refs_may_alias_p (base1, offset1, max_size1,\n \t\t\t\t  base2, offset2, max_size2);\n \n-  ind1_p = INDIRECT_REF_P (base1);\n-  ind2_p = INDIRECT_REF_P (base2);\n+  ind1_p = INDIRECT_REF_P (base1) || (TREE_CODE (base1) == MEM_REF);\n+  ind2_p = INDIRECT_REF_P (base2) || (TREE_CODE (base2) == MEM_REF);\n+\n   /* Canonicalize the pointer-vs-decl case.  */\n   if (ind1_p && var2_p)\n     {\n@@ -869,59 +951,6 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n       ind2_p = true;\n     }\n \n-  /* If we are about to disambiguate pointer-vs-decl try harder to\n-     see must-aliases and give leeway to some invalid cases.\n-     This covers a pretty minimal set of cases only and does not\n-     when called from the RTL oracle.  It handles cases like\n-\n-       int i = 1;\n-       return *(float *)&i;\n-\n-     and also fixes gfortran.dg/lto/pr40725.  */\n-  if (var1_p && ind2_p\n-      && cfun\n-      && gimple_in_ssa_p (cfun)\n-      && TREE_CODE (TREE_OPERAND (base2, 0)) == SSA_NAME)\n-    {\n-      gimple def_stmt = SSA_NAME_DEF_STMT (TREE_OPERAND (base2, 0));\n-      while (is_gimple_assign (def_stmt)\n-\t     && (gimple_assign_rhs_code (def_stmt) == SSA_NAME\n-\t\t || CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt))))\n-\t{\n-\t  tree rhs = gimple_assign_rhs1 (def_stmt);\n-\t  HOST_WIDE_INT offset, size, max_size;\n-\n-\t  /* Look through SSA name copies and pointer conversions.  */\n-\t  if (TREE_CODE (rhs) == SSA_NAME\n-\t      && POINTER_TYPE_P (TREE_TYPE (rhs)))\n-\t    {\n-\t      def_stmt = SSA_NAME_DEF_STMT (rhs);\n-\t      continue;\n-\t    }\n-\t  if (TREE_CODE (rhs) != ADDR_EXPR)\n-\t    break;\n-\n-\t  /* If the pointer is defined as an address based on a decl\n-\t     use plain offset disambiguation and ignore TBAA.  */\n-\t  rhs = TREE_OPERAND (rhs, 0);\n-\t  rhs = get_ref_base_and_extent (rhs, &offset, &size, &max_size);\n-\t  if (SSA_VAR_P (rhs))\n-\t    {\n-\t      base2 = rhs;\n-\t      offset2 += offset;\n-\t      if (size != max_size\n-\t\t  || max_size == -1)\n-\t\tmax_size2 = -1;\n-\t      return decl_refs_may_alias_p (base1, offset1, max_size1,\n-\t\t\t\t\t    base2, offset2, max_size2);\n-\t    }\n-\n-\t  /* Do not continue looking through &p->x to limit time\n-\t     complexity.  */\n-\t  break;\n-\t}\n-    }\n-\n   /* First defer to TBAA if possible.  */\n   if (tbaa_p\n       && flag_strict_aliasing\n@@ -937,21 +966,23 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n     return true;\n \n   /* Dispatch to the pointer-vs-decl or pointer-vs-pointer disambiguators.  */\n-  set = tbaa_p ? -1 : 0;\n   if (var1_p && ind2_p)\n-    return indirect_ref_may_alias_decl_p (ref2->ref, TREE_OPERAND (base2, 0),\n+    return indirect_ref_may_alias_decl_p (ref2->ref, base2,\n \t\t\t\t\t  offset2, max_size2,\n-\t\t\t\t\t  ao_ref_alias_set (ref2), set,\n+\t\t\t\t\t  ao_ref_alias_set (ref2), -1,\n \t\t\t\t\t  ref1->ref, base1,\n \t\t\t\t\t  offset1, max_size1,\n-\t\t\t\t\t  ao_ref_alias_set (ref1), set);\n+\t\t\t\t\t  ao_ref_alias_set (ref1),\n+\t\t\t\t\t  ao_ref_base_alias_set (ref1),\n+\t\t\t\t\t  tbaa_p);\n   else if (ind1_p && ind2_p)\n-    return indirect_refs_may_alias_p (ref1->ref, TREE_OPERAND (base1, 0),\n+    return indirect_refs_may_alias_p (ref1->ref, base1,\n \t\t\t\t      offset1, max_size1,\n-\t\t\t\t      ao_ref_alias_set (ref1), set,\n-\t\t\t\t      ref2->ref, TREE_OPERAND (base2, 0),\n+\t\t\t\t      ao_ref_alias_set (ref1), -1,\n+\t\t\t\t      ref2->ref, base2,\n \t\t\t\t      offset2, max_size2,\n-\t\t\t\t      ao_ref_alias_set (ref2), set);\n+\t\t\t\t      ao_ref_alias_set (ref2), -1,\n+\t\t\t\t      tbaa_p);\n \n   gcc_unreachable ();\n }\n@@ -1110,7 +1141,8 @@ ref_maybe_used_by_call_p_1 (gimple call, ao_ref *ref)\n       if (pt_solution_includes (gimple_call_use_set (call), base))\n \treturn true;\n     }\n-  else if (INDIRECT_REF_P (base)\n+  else if ((INDIRECT_REF_P (base)\n+\t    || TREE_CODE (base) == MEM_REF)\n \t   && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n     {\n       struct ptr_info_def *pi = SSA_NAME_PTR_INFO (TREE_OPERAND (base, 0));\n@@ -1281,7 +1313,8 @@ call_may_clobber_ref_p_1 (gimple call, ao_ref *ref)\n \t      if (DECL_P (base)\n \t\t  && !TREE_STATIC (base))\n \t\treturn true;\n-\t      else if (INDIRECT_REF_P (base)\n+\t      else if ((INDIRECT_REF_P (base)\n+\t\t\t|| TREE_CODE (base) == MEM_REF)\n \t\t       && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME\n \t\t       && (pi = SSA_NAME_PTR_INFO (TREE_OPERAND (base, 0))))\n \t\treturn pi->pt.anything || pi->pt.nonlocal;\n@@ -1360,7 +1393,8 @@ call_may_clobber_ref_p_1 (gimple call, ao_ref *ref)\n   /* Check if the base variable is call-clobbered.  */\n   if (DECL_P (base))\n     return pt_solution_includes (gimple_call_clobber_set (call), base);\n-  else if (INDIRECT_REF_P (base)\n+  else if ((INDIRECT_REF_P (base)\n+\t    || TREE_CODE (base) == MEM_REF)\n \t   && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n     {\n       struct ptr_info_def *pi = SSA_NAME_PTR_INFO (TREE_OPERAND (base, 0));"}, {"sha": "912c5059363aa9d287dda98bc4b0ecbf20a5179d", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 119, "deletions": 38, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -896,20 +896,22 @@ ccp_fold (gimple stmt)\n \t\t  base = &TREE_OPERAND (rhs, 0);\n \t\t  while (handled_component_p (*base))\n \t\t    base = &TREE_OPERAND (*base, 0);\n-\t\t  if (TREE_CODE (*base) == INDIRECT_REF\n+\t\t  if (TREE_CODE (*base) == MEM_REF\n \t\t      && TREE_CODE (TREE_OPERAND (*base, 0)) == SSA_NAME)\n \t\t    {\n \t\t      prop_value_t *val = get_value (TREE_OPERAND (*base, 0));\n \t\t      if (val->lattice_val == CONSTANT\n-\t\t\t  && TREE_CODE (val->value) == ADDR_EXPR\n-\t\t\t  && may_propagate_address_into_dereference\n-\t\t\t       (val->value, *base))\n+\t\t\t  && TREE_CODE (val->value) == ADDR_EXPR)\n \t\t\t{\n+\t\t\t  tree ret, save = *base;\n+\t\t\t  tree new_base;\n+\t\t\t  new_base = fold_build2 (MEM_REF, TREE_TYPE (*base),\n+\t\t\t\t\t\t  unshare_expr (val->value),\n+\t\t\t\t\t\t  TREE_OPERAND (*base, 1));\n \t\t\t  /* We need to return a new tree, not modify the IL\n \t\t\t     or share parts of it.  So play some tricks to\n \t\t\t     avoid manually building it.  */\n-\t\t\t  tree ret, save = *base;\n-\t\t\t  *base = TREE_OPERAND (val->value, 0);\n+\t\t\t  *base = new_base;\n \t\t\t  ret = unshare_expr (rhs);\n \t\t\t  recompute_tree_invariant_for_addr_expr (ret);\n \t\t\t  *base = save;\n@@ -955,15 +957,19 @@ ccp_fold (gimple stmt)\n \t\t\t\t\t   TREE_CODE (rhs),\n \t\t\t\t\t   TREE_TYPE (rhs), val->value);\n \t\t    }\n-\t\t  else if (TREE_CODE (rhs) == INDIRECT_REF\n+\t\t  else if (TREE_CODE (rhs) == MEM_REF\n \t\t\t   && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME)\n \t\t    {\n \t\t      prop_value_t *val = get_value (TREE_OPERAND (rhs, 0));\n \t\t      if (val->lattice_val == CONSTANT\n-\t\t\t  && TREE_CODE (val->value) == ADDR_EXPR\n-\t\t\t  && useless_type_conversion_p (TREE_TYPE (rhs),\n-\t\t\t\t\t\t\tTREE_TYPE (TREE_TYPE (val->value))))\n-\t\t\trhs = TREE_OPERAND (val->value, 0);\n+\t\t\t  && TREE_CODE (val->value) == ADDR_EXPR)\n+\t\t\t{\n+\t\t\t  tree tem = fold_build2 (MEM_REF, TREE_TYPE (rhs),\n+\t\t\t\t\t\t  unshare_expr (val->value),\n+\t\t\t\t\t\t  TREE_OPERAND (rhs, 1));\n+\t\t\t  if (tem)\n+\t\t\t    rhs = tem;\n+\t\t\t}\n \t\t    }\n \t\t  return fold_const_aggregate_ref (rhs);\n \t\t}\n@@ -987,16 +993,10 @@ ccp_fold (gimple stmt)\n \t\t allowed places.  */\n \t      if (CONVERT_EXPR_CODE_P (subcode)\n \t\t  && POINTER_TYPE_P (TREE_TYPE (lhs))\n-\t\t  && POINTER_TYPE_P (TREE_TYPE (op0))\n-\t\t  /* Do not allow differences in volatile qualification\n-\t\t     as this might get us confused as to whether a\n-\t\t     propagation destination statement is volatile\n-\t\t     or not.  See PR36988.  */\n-\t\t  && (TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (lhs)))\n-\t\t      == TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (op0)))))\n+\t\t  && POINTER_TYPE_P (TREE_TYPE (op0)))\n \t\t{\n \t\t  tree tem;\n-\t\t  /* Still try to generate a constant of correct type.  */\n+\t\t  /* Try to re-construct array references on-the-fly.  */\n \t\t  if (!useless_type_conversion_p (TREE_TYPE (lhs),\n \t\t\t\t\t\t  TREE_TYPE (op0))\n \t\t      && ((tem = maybe_fold_offset_to_address\n@@ -1018,19 +1018,21 @@ ccp_fold (gimple stmt)\n               tree op0 = get_rhs_assign_op_for_ccp (stmt, 1);\n               tree op1 = get_rhs_assign_op_for_ccp (stmt, 2);\n \n-\t      /* Fold &foo + CST into an invariant reference if possible.  */\n+\t      /* Translate &x + CST into an invariant form suitable for\n+\t         further propagation.  */\n \t      if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR\n \t\t  && TREE_CODE (op0) == ADDR_EXPR\n \t\t  && TREE_CODE (op1) == INTEGER_CST)\n \t\t{\n-\t\t  tree tem = maybe_fold_offset_to_address\n-\t\t    (loc, op0, op1, TREE_TYPE (op0));\n-\t\t  if (tem != NULL_TREE)\n-\t\t    return tem;\n+\t\t  tree off = fold_convert (ptr_type_node, op1);\n+\t\t  return build_fold_addr_expr\n+\t\t\t   (fold_build2 (MEM_REF,\n+\t\t\t\t\t TREE_TYPE (TREE_TYPE (op0)),\n+\t\t\t\t\t unshare_expr (op0), off));\n \t\t}\n \n               return fold_binary_loc (loc, subcode,\n-\t\t\t\t  gimple_expr_type (stmt), op0, op1);\n+\t\t\t\t      gimple_expr_type (stmt), op0, op1);\n             }\n \n           case GIMPLE_TERNARY_RHS:\n@@ -1299,18 +1301,97 @@ fold_const_aggregate_ref (tree t)\n \tbreak;\n       }\n \n-    case INDIRECT_REF:\n-      {\n-\ttree base = TREE_OPERAND (t, 0);\n-\tif (TREE_CODE (base) == SSA_NAME\n-\t    && (value = get_value (base))\n-\t    && value->lattice_val == CONSTANT\n-\t    && TREE_CODE (value->value) == ADDR_EXPR\n-\t    && useless_type_conversion_p (TREE_TYPE (t),\n-\t\t\t\t\t  TREE_TYPE (TREE_TYPE (value->value))))\n-\t  return fold_const_aggregate_ref (TREE_OPERAND (value->value, 0));\n-\tbreak;\n-      }\n+    case MEM_REF:\n+      /* Get the base object we are accessing.  */\n+      base = TREE_OPERAND (t, 0);\n+      if (TREE_CODE (base) == SSA_NAME\n+\t  && (value = get_value (base))\n+\t  && value->lattice_val == CONSTANT)\n+\tbase = value->value;\n+      if (TREE_CODE (base) != ADDR_EXPR)\n+\treturn NULL_TREE;\n+      base = TREE_OPERAND (base, 0);\n+      switch (TREE_CODE (base))\n+\t{\n+\tcase VAR_DECL:\n+\t  if (DECL_P (base)\n+\t      && !AGGREGATE_TYPE_P (TREE_TYPE (base))\n+\t      && integer_zerop (TREE_OPERAND (t, 1)))\n+\t    return get_symbol_constant_value (base);\n+\n+\t  if (!TREE_READONLY (base)\n+\t      || TREE_CODE (TREE_TYPE (base)) != ARRAY_TYPE\n+\t      || !targetm.binds_local_p (base))\n+\t    return NULL_TREE;\n+\n+\t  ctor = DECL_INITIAL (base);\n+\t  break;\n+\n+\tcase STRING_CST:\n+\tcase CONSTRUCTOR:\n+\t  ctor = base;\n+\t  break;\n+\n+\tdefault:\n+\t  return NULL_TREE;\n+\t}\n+\n+      if (ctor == NULL_TREE\n+\t  || (TREE_CODE (ctor) != CONSTRUCTOR\n+\t      && TREE_CODE (ctor) != STRING_CST)\n+\t  || !TREE_STATIC (ctor))\n+\treturn NULL_TREE;\n+\n+      /* Get the byte offset.  */\n+      idx = TREE_OPERAND (t, 1);\n+\n+      /* Fold read from constant string.  */\n+      if (TREE_CODE (ctor) == STRING_CST)\n+\t{\n+\t  if ((TYPE_MODE (TREE_TYPE (t))\n+\t       == TYPE_MODE (TREE_TYPE (TREE_TYPE (ctor))))\n+\t      && (GET_MODE_CLASS (TYPE_MODE (TREE_TYPE (TREE_TYPE (ctor))))\n+\t          == MODE_INT)\n+\t      && GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (TREE_TYPE (ctor)))) == 1\n+\t      && compare_tree_int (idx, TREE_STRING_LENGTH (ctor)) < 0)\n+\t    return build_int_cst_type (TREE_TYPE (t),\n+\t\t\t\t       (TREE_STRING_POINTER (ctor)\n+\t\t\t\t\t[TREE_INT_CST_LOW (idx)]));\n+\t  return NULL_TREE;\n+\t}\n+\n+      /* ???  Implement byte-offset indexing into a non-array CONSTRUCTOR.  */\n+      if (TREE_CODE (TREE_TYPE (ctor)) == ARRAY_TYPE\n+\t  && (TYPE_MODE (TREE_TYPE (t))\n+\t      == TYPE_MODE (TREE_TYPE (TREE_TYPE (ctor))))\n+\t  && GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (t))) != 0\n+\t  && integer_zerop\n+\t       (int_const_binop\n+\t\t  (TRUNC_MOD_EXPR, idx,\n+\t\t   size_int (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (t)))), 0)))\n+\t{\n+\t  idx = int_const_binop (TRUNC_DIV_EXPR, idx,\n+\t\t\t\t size_int (GET_MODE_SIZE\n+\t\t\t\t\t     (TYPE_MODE (TREE_TYPE (t)))), 0);\n+\t  FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (ctor), cnt, cfield, cval)\n+\t    if (tree_int_cst_equal (cfield, idx))\n+\t      {\n+\t\tSTRIP_NOPS (cval);\n+\t\tif (TREE_CODE (cval) == ADDR_EXPR)\n+\t\t  {\n+\t\t    tree base = get_base_address (TREE_OPERAND (cval, 0));\n+\t\t    if (base && TREE_CODE (base) == VAR_DECL)\n+\t\t      add_referenced_var (base);\n+\t\t  }\n+\t\tif (useless_type_conversion_p (TREE_TYPE (t), TREE_TYPE (cval)))\n+\t\t  return cval;\n+\t\telse if (CONSTANT_CLASS_P (cval))\n+\t\t  return fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (t), cval);\n+\t\telse\n+\t\t  return NULL_TREE;\n+\t      }\n+\t}\n+      break;\n \n     default:\n       break;\n@@ -1498,7 +1579,7 @@ ccp_fold_stmt (gimple_stmt_iterator *gsi)\n \t  {\n \t    tree rhs = unshare_expr (val->value);\n \t    if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n-\t      rhs = fold_convert (TREE_TYPE (lhs), rhs);\n+\t      rhs = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (lhs), rhs);\n \t    gimple_assign_set_rhs_from_tree (gsi, rhs);\n \t    return true;\n \t  }"}, {"sha": "edec49d374ffbcd85f7ae0cd78dd8a2f4a32455e", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -499,6 +499,9 @@ ref_may_be_aliased (tree ref)\n {\n   while (handled_component_p (ref))\n     ref = TREE_OPERAND (ref, 0);\n+  if (TREE_CODE (ref) == MEM_REF\n+      && TREE_CODE (TREE_OPERAND (ref, 0)) == ADDR_EXPR)\n+    ref = TREE_OPERAND (TREE_OPERAND (ref, 0), 0);\n   return !(DECL_P (ref)\n \t   && !may_be_aliased (ref));\n }"}, {"sha": "5044afffcd9d1655bf999f0df4cb7a455a089dd4", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 229, "deletions": 98, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -628,9 +628,14 @@ forward_propagate_addr_into_variable_array_index (tree offset,\n {\n   tree index, tunit;\n   gimple offset_def, use_stmt = gsi_stmt (*use_stmt_gsi);\n-  tree tmp;\n+  tree new_rhs, tmp;\n \n-  tunit = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (def_rhs)));\n+  if (TREE_CODE (TREE_OPERAND (def_rhs, 0)) == ARRAY_REF)\n+    tunit = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (def_rhs)));\n+  else if (TREE_CODE (TREE_TYPE (TREE_OPERAND (def_rhs, 0))) == ARRAY_TYPE)\n+    tunit = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (TREE_TYPE (def_rhs))));\n+  else\n+    return false;\n   if (!host_integerp (tunit, 1))\n     return false;\n \n@@ -697,10 +702,28 @@ forward_propagate_addr_into_variable_array_index (tree offset,\n   /* Replace the pointer addition with array indexing.  */\n   index = force_gimple_operand_gsi (use_stmt_gsi, index, true, NULL_TREE,\n \t\t\t\t    true, GSI_SAME_STMT);\n-  gimple_assign_set_rhs_from_tree (use_stmt_gsi, unshare_expr (def_rhs));\n+  if (TREE_CODE (TREE_OPERAND (def_rhs, 0)) == ARRAY_REF)\n+    {\n+      new_rhs = unshare_expr (def_rhs);\n+      TREE_OPERAND (TREE_OPERAND (new_rhs, 0), 1) = index;\n+    }\n+  else\n+    {\n+      new_rhs = build4 (ARRAY_REF, TREE_TYPE (TREE_TYPE (TREE_TYPE (def_rhs))),\n+\t\t\tunshare_expr (TREE_OPERAND (def_rhs, 0)),\n+\t\t\tindex, integer_zero_node, NULL_TREE);\n+      new_rhs = build_fold_addr_expr (new_rhs);\n+      if (!useless_type_conversion_p (TREE_TYPE (gimple_assign_lhs (use_stmt)),\n+\t\t\t\t      TREE_TYPE (new_rhs)))\n+\t{\n+\t  new_rhs = force_gimple_operand_gsi (use_stmt_gsi, new_rhs, true,\n+\t\t\t\t\t      NULL_TREE, true, GSI_SAME_STMT);\n+\t  new_rhs = fold_convert (TREE_TYPE (gimple_assign_lhs (use_stmt)),\n+\t\t\t\t  new_rhs);\n+\t}\n+    }\n+  gimple_assign_set_rhs_from_tree (use_stmt_gsi, new_rhs);\n   use_stmt = gsi_stmt (*use_stmt_gsi);\n-  TREE_OPERAND (TREE_OPERAND (gimple_assign_rhs1 (use_stmt), 0), 1)\n-    = index;\n \n   /* That should have created gimple, so there is no need to\n      record information to undo the propagation.  */\n@@ -725,11 +748,9 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs,\n \t\t\t       bool single_use_p)\n {\n   tree lhs, rhs, rhs2, array_ref;\n-  tree *rhsp, *lhsp;\n   gimple use_stmt = gsi_stmt (*use_stmt_gsi);\n   enum tree_code rhs_code;\n   bool res = true;\n-  bool addr_p = false;\n \n   gcc_assert (TREE_CODE (def_rhs) == ADDR_EXPR);\n \n@@ -767,31 +788,120 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs,\n       return true;\n     }\n \n+  /* Propagate through constant pointer adjustments.  */\n+  if (TREE_CODE (lhs) == SSA_NAME\n+      && rhs_code == POINTER_PLUS_EXPR\n+      && rhs == name\n+      && TREE_CODE (gimple_assign_rhs2 (use_stmt)) == INTEGER_CST)\n+    {\n+      tree new_def_rhs;\n+      /* As we come here with non-invariant addresses in def_rhs we need\n+         to make sure we can build a valid constant offsetted address\n+\t for further propagation.  Simply rely on fold building that\n+\t and check after the fact.  */\n+      new_def_rhs = fold_build2 (MEM_REF, TREE_TYPE (TREE_TYPE (rhs)),\n+\t\t\t\t def_rhs,\n+\t\t\t\t fold_convert (ptr_type_node,\n+\t\t\t\t\t       gimple_assign_rhs2 (use_stmt)));\n+      if (TREE_CODE (new_def_rhs) == MEM_REF\n+\t  && TREE_CODE (TREE_OPERAND (new_def_rhs, 0)) == ADDR_EXPR\n+\t  && !DECL_P (TREE_OPERAND (TREE_OPERAND (new_def_rhs, 0), 0))\n+\t  && !CONSTANT_CLASS_P (TREE_OPERAND (TREE_OPERAND (new_def_rhs, 0), 0)))\n+\treturn false;\n+      new_def_rhs = build_fold_addr_expr_with_type (new_def_rhs,\n+\t\t\t\t\t\t    TREE_TYPE (rhs));\n+\n+      /* Recurse.  If we could propagate into all uses of lhs do not\n+\t bother to replace into the current use but just pretend we did.  */\n+      if (TREE_CODE (new_def_rhs) == ADDR_EXPR\n+\t  && forward_propagate_addr_expr (lhs, new_def_rhs))\n+\treturn true;\n+\n+      if (useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (new_def_rhs)))\n+\tgimple_assign_set_rhs_with_ops (use_stmt_gsi, TREE_CODE (new_def_rhs),\n+\t\t\t\t\tnew_def_rhs, NULL_TREE);\n+      else if (is_gimple_min_invariant (new_def_rhs))\n+\tgimple_assign_set_rhs_with_ops (use_stmt_gsi, NOP_EXPR,\n+\t\t\t\t\tnew_def_rhs, NULL_TREE);\n+      else\n+\treturn false;\n+      gcc_assert (gsi_stmt (*use_stmt_gsi) == use_stmt);\n+      update_stmt (use_stmt);\n+      return true;\n+    }\n+\n   /* Now strip away any outer COMPONENT_REF/ARRAY_REF nodes from the LHS.\n      ADDR_EXPR will not appear on the LHS.  */\n-  lhsp = gimple_assign_lhs_ptr (use_stmt);\n-  while (handled_component_p (*lhsp))\n-    lhsp = &TREE_OPERAND (*lhsp, 0);\n-  lhs = *lhsp;\n+  lhs = gimple_assign_lhs (use_stmt);\n+  while (handled_component_p (lhs))\n+    lhs = TREE_OPERAND (lhs, 0);\n \n-  /* Now see if the LHS node is an INDIRECT_REF using NAME.  If so,\n+  /* Now see if the LHS node is a MEM_REF using NAME.  If so,\n      propagate the ADDR_EXPR into the use of NAME and fold the result.  */\n-  if (TREE_CODE (lhs) == INDIRECT_REF\n+  if (TREE_CODE (lhs) == MEM_REF\n       && TREE_OPERAND (lhs, 0) == name)\n     {\n-      if (may_propagate_address_into_dereference (def_rhs, lhs)\n-\t  && (lhsp != gimple_assign_lhs_ptr (use_stmt)\n-\t      || useless_type_conversion_p\n-\t           (TREE_TYPE (TREE_OPERAND (def_rhs, 0)), TREE_TYPE (rhs))))\n+      tree def_rhs_base;\n+      HOST_WIDE_INT def_rhs_offset;\n+      /* If the address is invariant we can always fold it.  */\n+      if ((def_rhs_base = get_addr_base_and_unit_offset (TREE_OPERAND (def_rhs, 0),\n+\t\t\t\t\t\t\t &def_rhs_offset)))\n \t{\n-\t  *lhsp = unshare_expr (TREE_OPERAND (def_rhs, 0));\n-\t  fold_stmt_inplace (use_stmt);\n+\t  double_int off = mem_ref_offset (lhs);\n+\t  tree new_ptr;\n+\t  off = double_int_add (off,\n+\t\t\t\tshwi_to_double_int (def_rhs_offset));\n+\t  if (TREE_CODE (def_rhs_base) == MEM_REF)\n+\t    {\n+\t      off = double_int_add (off, mem_ref_offset (def_rhs_base));\n+\t      new_ptr = TREE_OPERAND (def_rhs_base, 0);\n+\t    }\n+\t  else\n+\t    new_ptr = build_fold_addr_expr (def_rhs_base);\n+\t  TREE_OPERAND (lhs, 0) = new_ptr;\n+\t  TREE_OPERAND (lhs, 1)\n+\t    = double_int_to_tree (TREE_TYPE (TREE_OPERAND (lhs, 1)), off);\n \t  tidy_after_forward_propagate_addr (use_stmt);\n-\n \t  /* Continue propagating into the RHS if this was not the only use.  */\n \t  if (single_use_p)\n \t    return true;\n \t}\n+      /* If the LHS is a plain dereference and the value type is the same as\n+         that of the pointed-to type of the address we can put the\n+\t dereferenced address on the LHS preserving the original alias-type.  */\n+      else if (gimple_assign_lhs (use_stmt) == lhs\n+\t       && useless_type_conversion_p\n+\t            (TREE_TYPE (TREE_OPERAND (def_rhs, 0)),\n+\t\t     TREE_TYPE (gimple_assign_rhs1 (use_stmt))))\n+\t{\n+\t  tree *def_rhs_basep = &TREE_OPERAND (def_rhs, 0);\n+\t  tree new_offset, new_base, saved;\n+\t  while (handled_component_p (*def_rhs_basep))\n+\t    def_rhs_basep = &TREE_OPERAND (*def_rhs_basep, 0);\n+\t  saved = *def_rhs_basep;\n+\t  if (TREE_CODE (*def_rhs_basep) == MEM_REF)\n+\t    {\n+\t      new_base = TREE_OPERAND (*def_rhs_basep, 0);\n+\t      new_offset\n+\t\t= int_const_binop (PLUS_EXPR, TREE_OPERAND (lhs, 1),\n+\t\t\t\t   TREE_OPERAND (*def_rhs_basep, 1), 0);\n+\t    }\n+\t  else\n+\t    {\n+\t      new_base = build_fold_addr_expr (*def_rhs_basep);\n+\t      new_offset = TREE_OPERAND (lhs, 1);\n+\t    }\n+\t  *def_rhs_basep = build2 (MEM_REF, TREE_TYPE (*def_rhs_basep),\n+\t\t\t\t   new_base, new_offset);\n+\t  gimple_assign_set_lhs (use_stmt,\n+\t\t\t\t unshare_expr (TREE_OPERAND (def_rhs, 0)));\n+\t  *def_rhs_basep = saved;\n+\t  tidy_after_forward_propagate_addr (use_stmt);\n+\t  /* Continue propagating into the RHS if this was not the\n+\t     only use.  */\n+\t  if (single_use_p)\n+\t    return true;\n+\t}\n       else\n \t/* We can have a struct assignment dereferencing our name twice.\n \t   Note that we didn't propagate into the lhs to not falsely\n@@ -801,79 +911,76 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs,\n \n   /* Strip away any outer COMPONENT_REF, ARRAY_REF or ADDR_EXPR\n      nodes from the RHS.  */\n-  rhsp = gimple_assign_rhs1_ptr (use_stmt);\n-  if (TREE_CODE (*rhsp) == ADDR_EXPR)\n-    {\n-      rhsp = &TREE_OPERAND (*rhsp, 0);\n-      addr_p = true;\n-    }\n-  while (handled_component_p (*rhsp))\n-    rhsp = &TREE_OPERAND (*rhsp, 0);\n-  rhs = *rhsp;\n+  rhs = gimple_assign_rhs1 (use_stmt);\n+  if (TREE_CODE (rhs) == ADDR_EXPR)\n+    rhs = TREE_OPERAND (rhs, 0);\n+  while (handled_component_p (rhs))\n+    rhs = TREE_OPERAND (rhs, 0);\n \n-  /* Now see if the RHS node is an INDIRECT_REF using NAME.  If so,\n+  /* Now see if the RHS node is a MEM_REF using NAME.  If so,\n      propagate the ADDR_EXPR into the use of NAME and fold the result.  */\n-  if (TREE_CODE (rhs) == INDIRECT_REF\n-      && TREE_OPERAND (rhs, 0) == name\n-      && may_propagate_address_into_dereference (def_rhs, rhs))\n+  if (TREE_CODE (rhs) == MEM_REF\n+      && TREE_OPERAND (rhs, 0) == name)\n     {\n-      *rhsp = unshare_expr (TREE_OPERAND (def_rhs, 0));\n-      fold_stmt_inplace (use_stmt);\n-      tidy_after_forward_propagate_addr (use_stmt);\n-      return res;\n+      tree def_rhs_base;\n+      HOST_WIDE_INT def_rhs_offset;\n+      if ((def_rhs_base = get_addr_base_and_unit_offset (TREE_OPERAND (def_rhs, 0),\n+\t\t\t\t\t\t\t &def_rhs_offset)))\n+\t{\n+\t  double_int off = mem_ref_offset (rhs);\n+\t  tree new_ptr;\n+\t  off = double_int_add (off,\n+\t\t\t\tshwi_to_double_int (def_rhs_offset));\n+\t  if (TREE_CODE (def_rhs_base) == MEM_REF)\n+\t    {\n+\t      off = double_int_add (off, mem_ref_offset (def_rhs_base));\n+\t      new_ptr = TREE_OPERAND (def_rhs_base, 0);\n+\t    }\n+\t  else\n+\t    new_ptr = build_fold_addr_expr (def_rhs_base);\n+\t  TREE_OPERAND (rhs, 0) = new_ptr;\n+\t  TREE_OPERAND (rhs, 1)\n+\t    = double_int_to_tree (TREE_TYPE (TREE_OPERAND (rhs, 1)), off);\n+\t  fold_stmt_inplace (use_stmt);\n+\t  tidy_after_forward_propagate_addr (use_stmt);\n+\t  return res;\n+\t}\n+      /* If the LHS is a plain dereference and the value type is the same as\n+         that of the pointed-to type of the address we can put the\n+\t dereferenced address on the LHS preserving the original alias-type.  */\n+      else if (gimple_assign_rhs1 (use_stmt) == rhs\n+\t       && useless_type_conversion_p\n+\t\t    (TREE_TYPE (gimple_assign_lhs (use_stmt)),\n+\t\t     TREE_TYPE (TREE_OPERAND (def_rhs, 0))))\n+\t{\n+\t  tree *def_rhs_basep = &TREE_OPERAND (def_rhs, 0);\n+\t  tree new_offset, new_base, saved;\n+\t  while (handled_component_p (*def_rhs_basep))\n+\t    def_rhs_basep = &TREE_OPERAND (*def_rhs_basep, 0);\n+\t  saved = *def_rhs_basep;\n+\t  if (TREE_CODE (*def_rhs_basep) == MEM_REF)\n+\t    {\n+\t      new_base = TREE_OPERAND (*def_rhs_basep, 0);\n+\t      new_offset\n+\t\t= int_const_binop (PLUS_EXPR, TREE_OPERAND (rhs, 1),\n+\t\t\t\t   TREE_OPERAND (*def_rhs_basep, 1), 0);\n+\t    }\n+\t  else\n+\t    {\n+\t      new_base = build_fold_addr_expr (*def_rhs_basep);\n+\t      new_offset = TREE_OPERAND (rhs, 1);\n+\t    }\n+\t  *def_rhs_basep = build2 (MEM_REF, TREE_TYPE (*def_rhs_basep),\n+\t\t\t\t   new_base, new_offset);\n+\t  gimple_assign_set_rhs1 (use_stmt,\n+\t\t\t\t  unshare_expr (TREE_OPERAND (def_rhs, 0)));\n+\t  *def_rhs_basep = saved;\n+\t  fold_stmt_inplace (use_stmt);\n+\t  tidy_after_forward_propagate_addr (use_stmt);\n+\t  return res;\n+\t}\n     }\n \n-  /* Now see if the RHS node is an INDIRECT_REF using NAME.  If so,\n-     propagate the ADDR_EXPR into the use of NAME and try to\n-     create a VCE and fold the result.  */\n-  if (TREE_CODE (rhs) == INDIRECT_REF\n-      && TREE_OPERAND (rhs, 0) == name\n-      && TYPE_SIZE (TREE_TYPE (rhs))\n-      && TYPE_SIZE (TREE_TYPE (TREE_OPERAND (def_rhs, 0)))\n-      /* Function decls should not be used for VCE either as it could be a\n-         function descriptor that we want and not the actual function code.  */\n-      && TREE_CODE (TREE_OPERAND (def_rhs, 0)) != FUNCTION_DECL\n-      /* We should not convert volatile loads to non volatile loads. */\n-      && !TYPE_VOLATILE (TREE_TYPE (rhs))\n-      && !TYPE_VOLATILE (TREE_TYPE (TREE_OPERAND (def_rhs, 0)))\n-      && operand_equal_p (TYPE_SIZE (TREE_TYPE (rhs)),\n-\t\t\t  TYPE_SIZE (TREE_TYPE (TREE_OPERAND (def_rhs, 0))), 0)\n-      /* Make sure we only do TBAA compatible replacements.  */\n-      && get_alias_set (TREE_OPERAND (def_rhs, 0)) == get_alias_set (rhs))\n-   {\n-     tree def_rhs_base, new_rhs = unshare_expr (TREE_OPERAND (def_rhs, 0));\n-     new_rhs = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (rhs), new_rhs);\n-     if (TREE_CODE (new_rhs) != VIEW_CONVERT_EXPR)\n-       {\n-\t /* If we have folded the VIEW_CONVERT_EXPR then the result is only\n-\t    valid if we can replace the whole rhs of the use statement.  */\n-\t if (rhs != gimple_assign_rhs1 (use_stmt))\n-\t   return false;\n-\t new_rhs = force_gimple_operand_gsi (use_stmt_gsi, new_rhs, true, NULL,\n-\t\t\t\t\t     true, GSI_NEW_STMT);\n-\t gimple_assign_set_rhs1 (use_stmt, new_rhs);\n-\t tidy_after_forward_propagate_addr (use_stmt);\n-\t return res;\n-       }\n-     /* If the defining rhs comes from an indirect reference, then do not\n-        convert into a VIEW_CONVERT_EXPR.  Likewise if we'll end up taking\n-\tthe address of a V_C_E of a constant.  */\n-     def_rhs_base = TREE_OPERAND (def_rhs, 0);\n-     while (handled_component_p (def_rhs_base))\n-       def_rhs_base = TREE_OPERAND (def_rhs_base, 0);\n-     if (!INDIRECT_REF_P (def_rhs_base)\n-\t && (!addr_p\n-\t     || !is_gimple_min_invariant (def_rhs)))\n-       {\n-\t /* We may have arbitrary VIEW_CONVERT_EXPRs in a nested component\n-\t    reference.  Place it there and fold the thing.  */\n-\t *rhsp = new_rhs;\n-\t fold_stmt_inplace (use_stmt);\n-\t tidy_after_forward_propagate_addr (use_stmt);\n-\t return res;\n-       }\n-   }\n-\n   /* If the use of the ADDR_EXPR is not a POINTER_PLUS_EXPR, there\n      is nothing to do. */\n   if (gimple_assign_rhs_code (use_stmt) != POINTER_PLUS_EXPR\n@@ -885,9 +992,10 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs,\n      element zero in an array.  If that is not the case then there\n      is nothing to do.  */\n   array_ref = TREE_OPERAND (def_rhs, 0);\n-  if (TREE_CODE (array_ref) != ARRAY_REF\n-      || TREE_CODE (TREE_TYPE (TREE_OPERAND (array_ref, 0))) != ARRAY_TYPE\n-      || TREE_CODE (TREE_OPERAND (array_ref, 1)) != INTEGER_CST)\n+  if ((TREE_CODE (array_ref) != ARRAY_REF\n+       || TREE_CODE (TREE_TYPE (TREE_OPERAND (array_ref, 0))) != ARRAY_TYPE\n+       || TREE_CODE (TREE_OPERAND (array_ref, 1)) != INTEGER_CST)\n+      && TREE_CODE (TREE_TYPE (array_ref)) != ARRAY_TYPE)\n     return false;\n \n   rhs2 = gimple_assign_rhs2 (use_stmt);\n@@ -923,7 +1031,8 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs,\n      array elements, then the result is converted into the proper\n      type for the arithmetic.  */\n   if (TREE_CODE (rhs2) == SSA_NAME\n-      && integer_zerop (TREE_OPERAND (array_ref, 1))\n+      && (TREE_CODE (array_ref) != ARRAY_REF\n+\t  || integer_zerop (TREE_OPERAND (array_ref, 1)))\n       && useless_type_conversion_p (TREE_TYPE (name), TREE_TYPE (def_rhs))\n       /* Avoid problems with IVopts creating PLUS_EXPRs with a\n \t different type than their operands.  */\n@@ -1300,13 +1409,35 @@ tree_ssa_forward_propagate_single_use_vars (void)\n \t\t  else\n \t\t    gsi_next (&gsi);\n \t\t}\n-\t      else if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR\n-\t\t       && is_gimple_min_invariant (rhs))\n+\t      else if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n \t\t{\n-\t\t  /* Make sure to fold &a[0] + off_1 here.  */\n-\t\t  fold_stmt_inplace (stmt);\n-\t\t  update_stmt (stmt);\n-\t\t  if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n+\t\t  if (TREE_CODE (gimple_assign_rhs2 (stmt)) == INTEGER_CST\n+\t\t      /* ???  Better adjust the interface to that function\n+\t\t\t instead of building new trees here.  */\n+\t\t      && forward_propagate_addr_expr\n+\t\t           (lhs,\n+\t\t\t    build1 (ADDR_EXPR,\n+\t\t\t\t    TREE_TYPE (rhs),\n+\t\t\t\t    fold_build2 (MEM_REF,\n+\t\t\t\t\t\t TREE_TYPE (TREE_TYPE (rhs)),\n+\t\t\t\t\t\t rhs,\n+\t\t\t\t\t\t fold_convert\n+\t\t\t\t\t\t   (ptr_type_node,\n+\t\t\t\t\t\t    gimple_assign_rhs2 (stmt))))))\n+\t\t    {\n+\t\t      release_defs (stmt);\n+\t\t      todoflags |= TODO_remove_unused_locals;\n+\t\t      gsi_remove (&gsi, true);\n+\t\t    }\n+\t\t  else if (is_gimple_min_invariant (rhs))\n+\t\t    {\n+\t\t      /* Make sure to fold &a[0] + off_1 here.  */\n+\t\t      fold_stmt_inplace (stmt);\n+\t\t      update_stmt (stmt);\n+\t\t      if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n+\t\t\tgsi_next (&gsi);\n+\t\t    }\n+\t\t  else\n \t\t    gsi_next (&gsi);\n \t\t}\n \t      else if ((gimple_assign_rhs_code (stmt) == BIT_NOT_EXPR"}, {"sha": "6aaeaa09b5977a493d6c91f01c11177e4d071710", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -274,7 +274,7 @@ for_each_index (tree *addr_p, bool (*cbck) (tree, tree *, void *), void *data)\n \n \tcase MISALIGNED_INDIRECT_REF:\n \tcase ALIGN_INDIRECT_REF:\n-\tcase INDIRECT_REF:\n+\tcase MEM_REF:\n \t  nxt = &TREE_OPERAND (*addr_p, 0);\n \t  return cbck (*addr_p, nxt, data);\n \n@@ -1985,11 +1985,15 @@ gen_lsm_tmp_name (tree ref)\n     {\n     case MISALIGNED_INDIRECT_REF:\n     case ALIGN_INDIRECT_REF:\n-    case INDIRECT_REF:\n+    case MEM_REF:\n       gen_lsm_tmp_name (TREE_OPERAND (ref, 0));\n       lsm_tmp_name_add (\"_\");\n       break;\n \n+    case ADDR_EXPR:\n+      gen_lsm_tmp_name (TREE_OPERAND (ref, 0));\n+      break;\n+\n     case BIT_FIELD_REF:\n     case VIEW_CONVERT_EXPR:\n     case ARRAY_RANGE_REF:\n@@ -2150,7 +2154,8 @@ ref_always_accessed_p (struct loop *loop, mem_ref_p ref, bool stored_p)\n   tree base;\n \n   base = get_base_address (ref->mem);\n-  if (INDIRECT_REF_P (base))\n+  if (INDIRECT_REF_P (base)\n+      || TREE_CODE (base) == MEM_REF)\n     base = TREE_OPERAND (base, 0);\n \n   get_all_locs_in_loop (loop, ref, &locs);\n@@ -2169,7 +2174,8 @@ ref_always_accessed_p (struct loop *loop, mem_ref_p ref, bool stored_p)\n \t  lhs = get_base_address (gimple_get_lhs (loc->stmt));\n \t  if (!lhs)\n \t    continue;\n-\t  if (INDIRECT_REF_P (lhs))\n+\t  if (INDIRECT_REF_P (lhs)\n+\t      || TREE_CODE (lhs) == MEM_REF)\n \t    lhs = TREE_OPERAND (lhs, 0);\n \t  if (lhs != base)\n \t    continue;"}, {"sha": "46356588c94b046db0d92de3608afdedcf1c5ba0", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -813,7 +813,7 @@ determine_base_object (tree expr)\n       if (!base)\n \treturn expr;\n \n-      if (TREE_CODE (base) == INDIRECT_REF)\n+      if (TREE_CODE (base) == MEM_REF)\n \treturn determine_base_object (TREE_OPERAND (base, 0));\n \n       return fold_convert (ptr_type_node,\n@@ -1694,9 +1694,11 @@ find_interesting_uses_address (struct ivopts_data *data, gimple stmt, tree *op_p\n \t  tree *ref = &TREE_OPERAND (base, 0);\n \t  while (handled_component_p (*ref))\n \t    ref = &TREE_OPERAND (*ref, 0);\n-\t  if (TREE_CODE (*ref) == INDIRECT_REF)\n+\t  if (TREE_CODE (*ref) == MEM_REF)\n \t    {\n-\t      tree tem = gimple_fold_indirect_ref (TREE_OPERAND (*ref, 0));\n+\t      tree tem = fold_binary (MEM_REF, TREE_TYPE (*ref),\n+\t\t\t\t      TREE_OPERAND (*ref, 0),\n+\t\t\t\t      TREE_OPERAND (*ref, 1));\n \t      if (tem)\n \t\t*ref = tem;\n \t    }\n@@ -2018,7 +2020,8 @@ strip_offset_1 (tree expr, bool inside_addr, bool top_compref,\n       expr = build_fold_addr_expr (op0);\n       return fold_convert (orig_type, expr);\n \n-    case INDIRECT_REF:\n+    case MEM_REF:\n+      /* ???  Offset operand?  */\n       inside_addr = false;\n       break;\n \n@@ -3889,7 +3892,7 @@ get_computation_cost_at (struct ivopts_data *data,\n       return infinite_cost;\n \n     if (address_p)\n-      comp = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (comp)), comp);\n+      comp = build_simple_mem_ref (comp);\n \n     return new_cost (computation_cost (comp, speed), 0);\n   }"}, {"sha": "9956cc551b4153b2454e2303943353d682f2be9c", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -2625,7 +2625,7 @@ array_at_struct_end_p (tree ref)\n \n   /* Unless the reference is through a pointer, the size of the array matches\n      its declaration.  */\n-  if (!base || !INDIRECT_REF_P (base))\n+  if (!base || (!INDIRECT_REF_P (base) && TREE_CODE (base) != MEM_REF))\n     return false;\n \n   for (;handled_component_p (ref); ref = parent)\n@@ -2651,7 +2651,6 @@ array_at_struct_end_p (tree ref)\n \t Therefore, continue checking.  */\n     }\n \n-  gcc_assert (INDIRECT_REF_P (ref));\n   return true;\n }\n "}, {"sha": "fdc906a8b1ba3a390cdd8e658344d774c78e23ab", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -127,6 +127,12 @@ static struct\n    clobbering sites like function calls or ASM_EXPRs.  */\n #define opf_implicit\t(1 << 2)\n \n+/* Operand is in a place where address-taken does not imply addressable.  */\n+#define opf_non_addressable (1 << 3)\n+\n+/* Operand is in a place where opf_non_addressable does not apply.  */\n+#define opf_not_non_addressable (1 << 4)\n+\n /* Array for building all the def operands.  */\n static VEC(tree,heap) *build_defs;\n \n@@ -693,15 +699,22 @@ mark_address_taken (tree ref)\n      be referenced using pointer arithmetic.  See PR 21407 and the\n      ensuing mailing list discussion.  */\n   var = get_base_address (ref);\n-  if (var && DECL_P (var))\n-    TREE_ADDRESSABLE (var) = 1;\n+  if (var)\n+    {\n+      if (DECL_P (var))\n+\tTREE_ADDRESSABLE (var) = 1;\n+      else if (TREE_CODE (var) == MEM_REF\n+\t       && TREE_CODE (TREE_OPERAND (var, 0)) == ADDR_EXPR\n+\t       && DECL_P (TREE_OPERAND (TREE_OPERAND (var, 0), 0)))\n+\tTREE_ADDRESSABLE (TREE_OPERAND (TREE_OPERAND (var, 0), 0)) = 1;\n+    }\n }\n \n \n-/* A subroutine of get_expr_operands to handle INDIRECT_REF,\n+/* A subroutine of get_expr_operands to handle MEM_REF,\n    ALIGN_INDIRECT_REF and MISALIGNED_INDIRECT_REF.\n \n-   STMT is the statement being processed, EXPR is the INDIRECT_REF\n+   STMT is the statement being processed, EXPR is the MEM_REF\n       that got us here.\n \n    FLAGS is as in get_expr_operands.\n@@ -725,7 +738,8 @@ get_indirect_ref_operands (gimple stmt, tree expr, int flags,\n   /* If requested, add a USE operand for the base pointer.  */\n   if (recurse_on_base)\n     get_expr_operands (stmt, pptr,\n-\t\t       opf_use | (flags & opf_no_vops));\n+\t\t       opf_non_addressable | opf_use\n+\t\t       | (flags & (opf_no_vops|opf_not_non_addressable)));\n }\n \n \n@@ -802,7 +816,7 @@ get_asm_expr_operands (gimple stmt)\n       if (!allows_reg && allows_mem)\n \tmark_address_taken (TREE_VALUE (link));\n \n-      get_expr_operands (stmt, &TREE_VALUE (link), opf_def);\n+      get_expr_operands (stmt, &TREE_VALUE (link), opf_def | opf_not_non_addressable);\n     }\n \n   /* Gather all input operands.  */\n@@ -818,7 +832,7 @@ get_asm_expr_operands (gimple stmt)\n       if (!allows_reg && allows_mem)\n \tmark_address_taken (TREE_VALUE (link));\n \n-      get_expr_operands (stmt, &TREE_VALUE (link), 0);\n+      get_expr_operands (stmt, &TREE_VALUE (link), opf_not_non_addressable);\n     }\n \n   /* Clobber all memory and addressable symbols for asm (\"\" : : : \"memory\");  */\n@@ -862,7 +876,9 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n \t reference to it, but the fact that the statement takes its\n \t address will be of interest to some passes (e.g. alias\n \t resolution).  */\n-      if (!is_gimple_debug (stmt))\n+      if ((!(flags & opf_non_addressable)\n+\t   || (flags & opf_not_non_addressable))\n+\t  && !is_gimple_debug (stmt))\n \tmark_address_taken (TREE_OPERAND (expr, 0));\n \n       /* If the address is invariant, there may be no interesting\n@@ -876,7 +892,8 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n \t here are ARRAY_REF indices which will always be real operands\n \t (GIMPLE does not allow non-registers as array indices).  */\n       flags |= opf_no_vops;\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 0),\n+\t\t\t flags | opf_not_non_addressable);\n       return;\n \n     case SSA_NAME:\n@@ -898,7 +915,7 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n       /* fall through */\n \n     case ALIGN_INDIRECT_REF:\n-    case INDIRECT_REF:\n+    case MEM_REF:\n       get_indirect_ref_operands (stmt, expr, flags, true);\n       return;\n "}, {"sha": "482f267a6483d9441a04f2f867a7c8098c6b1c5d", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -994,10 +994,10 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n \n /* Auxiliary functions to determine the set of memory accesses which\n    can't trap because they are preceded by accesses to the same memory\n-   portion.  We do that for INDIRECT_REFs, so we only need to track\n+   portion.  We do that for MEM_REFs, so we only need to track\n    the SSA_NAME of the pointer indirectly referenced.  The algorithm\n    simply is a walk over all instructions in dominator order.  When\n-   we see an INDIRECT_REF we determine if we've already seen a same\n+   we see an MEM_REF we determine if we've already seen a same\n    ref anywhere up to the root of the dominator tree.  If we do the\n    current access can't trap.  If we don't see any dominating access\n    the current access might trap, but might also make later accesses\n@@ -1011,7 +1011,7 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n    trap even if a store doesn't (write-only memory).  This probably is\n    overly conservative.  */\n \n-/* A hash-table of SSA_NAMEs, and in which basic block an INDIRECT_REF\n+/* A hash-table of SSA_NAMEs, and in which basic block an MEM_REF\n    through it was seen, which would constitute a no-trap region for\n    same accesses.  */\n struct name_to_bb\n@@ -1024,7 +1024,7 @@ struct name_to_bb\n /* The hash table for remembering what we've seen.  */\n static htab_t seen_ssa_names;\n \n-/* The set of INDIRECT_REFs which can't trap.  */\n+/* The set of MEM_REFs which can't trap.  */\n static struct pointer_set_t *nontrap_set;\n \n /* The hash function, based on the pointer to the pointer SSA_NAME.  */\n@@ -1047,15 +1047,15 @@ name_to_bb_eq (const void *p1, const void *p2)\n }\n \n /* We see the expression EXP in basic block BB.  If it's an interesting\n-   expression (an INDIRECT_REF through an SSA_NAME) possibly insert the\n+   expression (an MEM_REF through an SSA_NAME) possibly insert the\n    expression into the set NONTRAP or the hash table of seen expressions.\n    STORE is true if this expression is on the LHS, otherwise it's on\n    the RHS.  */\n static void\n add_or_mark_expr (basic_block bb, tree exp,\n \t\t  struct pointer_set_t *nontrap, bool store)\n {\n-  if (INDIRECT_REF_P (exp)\n+  if (TREE_CODE (exp) == MEM_REF\n       && TREE_CODE (TREE_OPERAND (exp, 0)) == SSA_NAME)\n     {\n       tree name = TREE_OPERAND (exp, 0);\n@@ -1064,7 +1064,7 @@ add_or_mark_expr (basic_block bb, tree exp,\n       struct name_to_bb *n2bb;\n       basic_block found_bb = 0;\n \n-      /* Try to find the last seen INDIRECT_REF through the same\n+      /* Try to find the last seen MEM_REF through the same\n          SSA_NAME, which can trap.  */\n       map.ssa_name = name;\n       map.bb = 0;\n@@ -1074,7 +1074,7 @@ add_or_mark_expr (basic_block bb, tree exp,\n       if (n2bb)\n         found_bb = n2bb->bb;\n \n-      /* If we've found a trapping INDIRECT_REF, _and_ it dominates EXP\n+      /* If we've found a trapping MEM_REF, _and_ it dominates EXP\n          (it's in a basic block on the path from us to the dominator root)\n \t then we can't trap.  */\n       if (found_bb && found_bb->aux == (void *)1)\n@@ -1135,7 +1135,7 @@ nt_fini_block (struct dom_walk_data *data ATTRIBUTE_UNUSED, basic_block bb)\n /* This is the entry point of gathering non trapping memory accesses.\n    It will do a dominator walk over the whole function, and it will\n    make use of the bb->aux pointers.  It returns a set of trees\n-   (the INDIRECT_REFs itself) which can't trap.  */\n+   (the MEM_REFs itself) which can't trap.  */\n static struct pointer_set_t *\n get_non_trapping (void)\n {\n@@ -1200,7 +1200,8 @@ cond_store_replacement (basic_block middle_bb, basic_block join_bb,\n   locus = gimple_location (assign);\n   lhs = gimple_assign_lhs (assign);\n   rhs = gimple_assign_rhs1 (assign);\n-  if (!INDIRECT_REF_P (lhs))\n+  if (TREE_CODE (lhs) != MEM_REF\n+      || TREE_CODE (TREE_OPERAND (lhs, 0)) != SSA_NAME)\n     return false;\n \n   /* RHS is either a single SSA_NAME or a constant. */"}, {"sha": "6595515e1ada03196b37c21ff50a1707f86a9dd2", "filename": "gcc/tree-ssa-phiprop.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-phiprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-phiprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiprop.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -139,7 +139,7 @@ phiprop_insert_phi (basic_block bb, gimple phi, gimple use_stmt,\n   edge e;\n \n   gcc_assert (is_gimple_assign (use_stmt)\n-\t      && gimple_assign_rhs_code (use_stmt) == INDIRECT_REF);\n+\t      && gimple_assign_rhs_code (use_stmt) == MEM_REF);\n \n   /* Build a new PHI node to replace the definition of\n      the indirect reference lhs.  */\n@@ -295,8 +295,11 @@ propagate_with_phi (basic_block bb, gimple phi, struct phiprop_d *phivn,\n       /* Check whether this is a load of *ptr.  */\n       if (!(is_gimple_assign (use_stmt)\n \t    && TREE_CODE (gimple_assign_lhs (use_stmt)) == SSA_NAME\n-\t    && gimple_assign_rhs_code (use_stmt) == INDIRECT_REF\n+\t    && gimple_assign_rhs_code (use_stmt) == MEM_REF\n \t    && TREE_OPERAND (gimple_assign_rhs1 (use_stmt), 0) == ptr\n+\t    && integer_zerop (TREE_OPERAND (gimple_assign_rhs1 (use_stmt), 1))\n+\t    && types_compatible_p (TREE_TYPE (gimple_assign_rhs1 (use_stmt)),\n+\t\t\t\t   TREE_TYPE (TREE_TYPE (ptr)))\n \t    /* We cannot replace a load that may throw or is volatile.  */\n \t    && !stmt_can_throw_internal (use_stmt)))\n \tcontinue;"}, {"sha": "97eb7d2c1887eab162607810e6b1e976ede47416", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 102, "deletions": 7, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1629,12 +1629,28 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \t    newop.op0 = op0;\n \t    newop.op1 = op1;\n \t    newop.op2 = op2;\n+\t    /* If it transforms a non-constant ARRAY_REF into a constant\n+\t       one, adjust the constant offset.  */\n+\t    if (newop.opcode == ARRAY_REF\n+\t\t&& newop.off == -1\n+\t\t&& TREE_CODE (op0) == INTEGER_CST\n+\t\t&& TREE_CODE (op1) == INTEGER_CST\n+\t\t&& TREE_CODE (op2) == INTEGER_CST)\n+\t      {\n+\t\tdouble_int off = tree_to_double_int (op0);\n+\t\toff = double_int_add (off,\n+\t\t\t\t      double_int_neg\n+\t\t\t\t        (tree_to_double_int (op1)));\n+\t\toff = double_int_mul (off, tree_to_double_int (op2));\n+\t\tif (double_int_fits_in_shwi_p (off))\n+\t\t  newop.off = off.low;\n+\t      }\n \t    VEC_replace (vn_reference_op_s, newoperands, j, &newop);\n \t    /* If it transforms from an SSA_NAME to an address, fold with\n \t       a preceding indirect reference.  */\n \t    if (j > 0 && op0 && TREE_CODE (op0) == ADDR_EXPR\n \t\t&& VEC_index (vn_reference_op_s,\n-\t\t\t      newoperands, j - 1)->opcode == INDIRECT_REF)\n+\t\t\t      newoperands, j - 1)->opcode == MEM_REF)\n \t      vn_reference_fold_indirect (&newoperands, &j);\n \t  }\n \tif (i != VEC_length (vn_reference_op_s, operands))\n@@ -1661,6 +1677,7 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \t  {\n \t    unsigned int new_val_id;\n \t    pre_expr constant;\n+\t    bool converted = false;\n \n \t    tree result = vn_reference_lookup_pieces (newvuse, ref->set,\n \t\t\t\t\t\t      ref->type,\n@@ -1669,6 +1686,13 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \t    if (result)\n \t      VEC_free (vn_reference_op_s, heap, newoperands);\n \n+\t    if (result\n+\t\t&& !useless_type_conversion_p (ref->type, TREE_TYPE (result)))\n+\t      {\n+\t\tresult = fold_build1 (VIEW_CONVERT_EXPR, ref->type, result);\n+\t\tconverted = true;\n+\t      }\n+\n \t    if (result && is_gimple_min_invariant (result))\n \t      {\n \t        gcc_assert (!newoperands);\n@@ -1679,7 +1703,54 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \t    expr->kind = REFERENCE;\n \t    expr->id = 0;\n \n-\t    if (newref)\n+\t    if (converted)\n+\t      {\n+\t\tvn_nary_op_t nary;\n+\t\ttree nresult;\n+\n+\t\tgcc_assert (CONVERT_EXPR_P (result)\n+\t\t\t    || TREE_CODE (result) == VIEW_CONVERT_EXPR);\n+\n+\t\tnresult = vn_nary_op_lookup_pieces (1, TREE_CODE (result),\n+\t\t\t\t\t\t    TREE_TYPE (result),\n+\t\t\t\t\t\t    TREE_OPERAND (result, 0),\n+\t\t\t\t\t\t    NULL_TREE, NULL_TREE,\n+\t\t\t\t\t\t    NULL_TREE,\n+\t\t\t\t\t\t    &nary);\n+\t\tif (nresult && is_gimple_min_invariant (nresult))\n+\t\t  return get_or_alloc_expr_for_constant (nresult);\n+\n+\t\texpr->kind = NARY;\n+\t\tif (nary)\n+\t\t  {\n+\t\t    PRE_EXPR_NARY (expr) = nary;\n+\t\t    constant = fully_constant_expression (expr);\n+\t\t    if (constant != expr)\n+\t\t      return constant;\n+\n+\t\t    new_val_id = nary->value_id;\n+\t\t    get_or_alloc_expression_id (expr);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    new_val_id = get_next_value_id ();\n+\t\t    VEC_safe_grow_cleared (bitmap_set_t, heap,\n+\t\t\t\t\t   value_expressions,\n+\t\t\t\t\t   get_max_value_id() + 1);\n+\t\t    nary = vn_nary_op_insert_pieces (1, TREE_CODE (result),\n+\t\t\t\t\t\t     TREE_TYPE (result),\n+\t\t\t\t\t\t     TREE_OPERAND (result, 0),\n+\t\t\t\t\t\t     NULL_TREE, NULL_TREE,\n+\t\t\t\t\t\t     NULL_TREE, NULL_TREE,\n+\t\t\t\t\t\t     new_val_id);\n+\t\t    PRE_EXPR_NARY (expr) = nary;\n+\t\t    constant = fully_constant_expression (expr);\n+\t\t    if (constant != expr)\n+\t\t      return constant;\n+\t\t    get_or_alloc_expression_id (expr);\n+\t\t  }\n+\t      }\n+\t    else if (newref)\n \t      {\n \t\tPRE_EXPR_REFERENCE (expr) = newref;\n \t\tconstant = fully_constant_expression (expr);\n@@ -2598,7 +2669,7 @@ can_PRE_operation (tree op)\n   return UNARY_CLASS_P (op)\n     || BINARY_CLASS_P (op)\n     || COMPARISON_CLASS_P (op)\n-    || TREE_CODE (op) == INDIRECT_REF\n+    || TREE_CODE (op) == MEM_REF \n     || TREE_CODE (op) == COMPONENT_REF\n     || TREE_CODE (op) == VIEW_CONVERT_EXPR\n     || TREE_CODE (op) == CALL_EXPR\n@@ -2674,6 +2745,29 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n \treturn folded;\n       }\n       break;\n+    case MEM_REF:\n+      {\n+\ttree baseop = create_component_ref_by_pieces_1 (block, ref, operand,\n+\t\t\t\t\t\t\tstmts, domstmt);\n+\ttree offset = currop->op0;\n+\tif (!baseop)\n+\t  return NULL_TREE;\n+\tif (TREE_CODE (baseop) == ADDR_EXPR\n+\t    && handled_component_p (TREE_OPERAND (baseop, 0)))\n+\t  {\n+\t    HOST_WIDE_INT off;\n+\t    tree base;\n+\t    base = get_addr_base_and_unit_offset (TREE_OPERAND (baseop, 0),\n+\t\t\t\t\t\t  &off);\n+\t    gcc_assert (base);\n+\t    offset = int_const_binop (PLUS_EXPR, offset,\n+\t\t\t\t      build_int_cst (TREE_TYPE (offset),\n+\t\t\t\t\t\t     off), 0);\n+\t    baseop = build_fold_addr_expr (base);\n+\t  }\n+\treturn fold_build2 (MEM_REF, currop->type, baseop, offset);\n+      }\n+      break;\n     case TARGET_MEM_REF:\n       {\n \tvn_reference_op_t nextop = VEC_index (vn_reference_op_s, ref->operands,\n@@ -2728,7 +2822,6 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n       break;\n     case ALIGN_INDIRECT_REF:\n     case MISALIGNED_INDIRECT_REF:\n-    case INDIRECT_REF:\n       {\n \ttree folded;\n \ttree genop1 = create_component_ref_by_pieces_1 (block, ref,\n@@ -2880,7 +2973,7 @@ create_component_ref_by_pieces_1 (basic_block block, vn_reference_t ref,\n }\n \n /* For COMPONENT_REF's and ARRAY_REF's, we can't have any intermediates for the\n-   COMPONENT_REF or INDIRECT_REF or ARRAY_REF portion, because we'd end up with\n+   COMPONENT_REF or MEM_REF or ARRAY_REF portion, because we'd end up with\n    trying to rename aggregates into ssa form directly, which is a no no.\n \n    Thus, this routine doesn't create temporaries, it just builds a\n@@ -3131,7 +3224,7 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n   VN_INFO (name)->value_id = value_id;\n   nameexpr = get_or_alloc_expr_for_name (name);\n   add_to_value (value_id, nameexpr);\n-  if (!in_fre)\n+  if (NEW_SETS (block))\n     bitmap_value_replace_in_set (NEW_SETS (block), nameexpr);\n   bitmap_value_replace_in_set (AVAIL_OUT (block), nameexpr);\n \n@@ -3310,6 +3403,8 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \t\t      avail[bprime->index] = get_or_alloc_expr_for_name (forcedexpr);\n \t\t    }\n \t\t}\n+\t      else\n+\t\tavail[bprime->index] = get_or_alloc_expr_for_constant (builtexpr);\n \t    }\n \t}\n       else if (eprime->kind == NAME)\n@@ -4723,7 +4818,7 @@ execute_pre (bool do_fre)\n   if (!do_fre)\n     loop_optimizer_init (LOOPS_NORMAL);\n \n-  if (!run_scc_vn (do_fre))\n+  if (!run_scc_vn ())\n     {\n       if (!do_fre)\n \tloop_optimizer_finalize ();"}, {"sha": "cc667207ee0e44eb450f3dbe70a2dca13de508b2", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 216, "deletions": 112, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -156,8 +156,6 @@ static unsigned int next_value_id;\n static unsigned int next_dfs_num;\n static VEC (tree, heap) *sccstack;\n \n-static bool may_insert;\n-\n \n DEF_VEC_P(vn_ssa_aux_t);\n DEF_VEC_ALLOC_P(vn_ssa_aux_t, heap);\n@@ -431,9 +429,41 @@ vn_reference_compute_hash (const vn_reference_t vr1)\n   hashval_t result = 0;\n   int i;\n   vn_reference_op_t vro;\n+  HOST_WIDE_INT off = -1;\n+  bool deref = false;\n \n   for (i = 0; VEC_iterate (vn_reference_op_s, vr1->operands, i, vro); i++)\n-    result = vn_reference_op_compute_hash (vro, result);\n+    {\n+      if (vro->opcode == MEM_REF)\n+\tderef = true;\n+      else if (vro->opcode != ADDR_EXPR)\n+\tderef = false;\n+      if (vro->off != -1)\n+\t{\n+\t  if (off == -1)\n+\t    off = 0;\n+\t  off += vro->off;\n+\t}\n+      else\n+\t{\n+\t  if (off != -1\n+\t      && off != 0)\n+\t    result = iterative_hash_hashval_t (off, result);\n+\t  off = -1;\n+\t  if (deref\n+\t      && vro->opcode == ADDR_EXPR)\n+\t    {\n+\t      if (vro->op0)\n+\t\t{\n+\t\t  tree op = TREE_OPERAND (vro->op0, 0);\n+\t\t  result = iterative_hash_hashval_t (TREE_CODE (op), result);\n+\t\t  result = iterative_hash_expr (op, result);\n+\t\t}\n+\t    }\n+\t  else\n+\t    result = vn_reference_op_compute_hash (vro, result);\n+\t}\n+    }\n   if (vr1->vuse)\n     result += SSA_NAME_VERSION (vr1->vuse);\n \n@@ -446,8 +476,7 @@ vn_reference_compute_hash (const vn_reference_t vr1)\n int\n vn_reference_eq (const void *p1, const void *p2)\n {\n-  int i;\n-  vn_reference_op_t vro;\n+  unsigned i, j;\n \n   const_vn_reference_t const vr1 = (const_vn_reference_t) p1;\n   const_vn_reference_t const vr2 = (const_vn_reference_t) p2;\n@@ -466,17 +495,58 @@ vn_reference_eq (const void *p1, const void *p2)\n   if (vr1->operands == vr2->operands)\n     return true;\n \n-  /* We require that address operands be canonicalized in a way that\n-     two memory references will have the same operands if they are\n-     equivalent.  */\n-  if (VEC_length (vn_reference_op_s, vr1->operands)\n-      != VEC_length (vn_reference_op_s, vr2->operands))\n+  if (!expressions_equal_p (TYPE_SIZE (vr1->type), TYPE_SIZE (vr2->type)))\n     return false;\n \n-  for (i = 0; VEC_iterate (vn_reference_op_s, vr1->operands, i, vro); i++)\n-    if (!vn_reference_op_eq (VEC_index (vn_reference_op_s, vr2->operands, i),\n-\t\t\t     vro))\n-      return false;\n+  i = 0;\n+  j = 0;\n+  do\n+    {\n+      HOST_WIDE_INT off1 = 0, off2 = 0;\n+      vn_reference_op_t vro1, vro2;\n+      vn_reference_op_s tem1, tem2;\n+      bool deref1 = false, deref2 = false;\n+      for (; VEC_iterate (vn_reference_op_s, vr1->operands, i, vro1); i++)\n+\t{\n+\t  if (vro1->opcode == MEM_REF)\n+\t    deref1 = true;\n+\t  if (vro1->off == -1)\n+\t    break;\n+\t  off1 += vro1->off;\n+\t}\n+      for (; VEC_iterate (vn_reference_op_s, vr2->operands, j, vro2); j++)\n+\t{\n+\t  if (vro2->opcode == MEM_REF)\n+\t    deref2 = true;\n+\t  if (vro2->off == -1)\n+\t    break;\n+\t  off2 += vro2->off;\n+\t}\n+      if (off1 != off2)\n+\treturn false;\n+      if (deref1 && vro1->opcode == ADDR_EXPR)\n+\t{\n+\t  memset (&tem1, 0, sizeof (tem1));\n+\t  tem1.op0 = TREE_OPERAND (vro1->op0, 0);\n+\t  tem1.type = TREE_TYPE (tem1.op0);\n+\t  tem1.opcode = TREE_CODE (tem1.op0);\n+\t  vro1 = &tem1;\n+\t}\n+      if (deref2 && vro2->opcode == ADDR_EXPR)\n+\t{\n+\t  memset (&tem2, 0, sizeof (tem2));\n+\t  tem2.op0 = TREE_OPERAND (vro2->op0, 0);\n+\t  tem2.type = TREE_TYPE (tem2.op0);\n+\t  tem2.opcode = TREE_CODE (tem2.op0);\n+\t  vro2 = &tem2;\n+\t}\n+      if (!vn_reference_op_eq (vro1, vro2))\n+\treturn false;\n+      ++j;\n+      ++i;\n+    }\n+  while (VEC_length (vn_reference_op_s, vr1->operands) != i\n+\t || VEC_length (vn_reference_op_s, vr2->operands) != j);\n \n   return true;\n }\n@@ -503,13 +573,15 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n       temp.op0 = TMR_INDEX (ref);\n       temp.op1 = TMR_STEP (ref);\n       temp.op2 = TMR_OFFSET (ref);\n+      temp.off = -1;\n       VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n \n       memset (&temp, 0, sizeof (temp));\n       temp.type = NULL_TREE;\n       temp.opcode = TREE_CODE (base);\n       temp.op0 = base;\n       temp.op1 = TMR_ORIGINAL (ref);\n+      temp.off = -1;\n       VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n       return;\n     }\n@@ -524,17 +596,23 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n       /* We do not care for spurious type qualifications.  */\n       temp.type = TYPE_MAIN_VARIANT (TREE_TYPE (ref));\n       temp.opcode = TREE_CODE (ref);\n+      temp.off = -1;\n \n       switch (temp.opcode)\n \t{\n \tcase ALIGN_INDIRECT_REF:\n-\tcase INDIRECT_REF:\n \t  /* The only operand is the address, which gets its own\n \t     vn_reference_op_s structure.  */\n \t  break;\n \tcase MISALIGNED_INDIRECT_REF:\n \t  temp.op0 = TREE_OPERAND (ref, 1);\n \t  break;\n+\tcase MEM_REF:\n+\t  /* The base address gets its own vn_reference_op_s structure.  */\n+\t  temp.op0 = TREE_OPERAND (ref, 1);\n+\t  if (host_integerp (TREE_OPERAND (ref, 1), 0))\n+\t    temp.off = TREE_INT_CST_LOW (TREE_OPERAND (ref, 1));\n+\t  break;\n \tcase BIT_FIELD_REF:\n \t  /* Record bits and position.  */\n \t  temp.op0 = TREE_OPERAND (ref, 1);\n@@ -547,17 +625,25 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n \t  temp.type = NULL_TREE;\n \t  temp.op0 = TREE_OPERAND (ref, 1);\n \t  temp.op1 = TREE_OPERAND (ref, 2);\n-\t  /* If this is a reference to a union member, record the union\n-\t     member size as operand.  Do so only if we are doing\n-\t     expression insertion (during FRE), as PRE currently gets\n-\t     confused with this.  */\n-\t  if (may_insert\n-\t      && temp.op1 == NULL_TREE\n-\t      && TREE_CODE (DECL_CONTEXT (temp.op0)) == UNION_TYPE\n-\t      && integer_zerop (DECL_FIELD_OFFSET (temp.op0))\n-\t      && integer_zerop (DECL_FIELD_BIT_OFFSET (temp.op0))\n-\t      && host_integerp (DECL_SIZE (temp.op0), 0))\n-\t    temp.op0 = DECL_SIZE (temp.op0);\n+\t  {\n+\t    tree this_offset = component_ref_field_offset (ref);\n+\t    if (this_offset\n+\t\t&& TREE_CODE (this_offset) == INTEGER_CST)\n+\t      {\n+\t\ttree bit_offset = DECL_FIELD_BIT_OFFSET (TREE_OPERAND (ref, 1));\n+\t\tif (TREE_INT_CST_LOW (bit_offset) % BITS_PER_UNIT == 0)\n+\t\t  {\n+\t\t    double_int off\n+\t\t      = double_int_add (tree_to_double_int (this_offset),\n+\t\t\t\t\tdouble_int_sdiv\n+\t\t\t\t\t  (tree_to_double_int (bit_offset),\n+\t\t\t\t\t   uhwi_to_double_int (BITS_PER_UNIT),\n+\t\t\t\t\t   TRUNC_DIV_EXPR));\n+\t\t    if (double_int_fits_in_shwi_p (off))\n+\t\t      temp.off = off.low;\n+\t\t  }\n+\t      }\n+\t  }\n \t  break;\n \tcase ARRAY_RANGE_REF:\n \tcase ARRAY_REF:\n@@ -566,6 +652,18 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n \t  /* Always record lower bounds and element size.  */\n \t  temp.op1 = array_ref_low_bound (ref);\n \t  temp.op2 = array_ref_element_size (ref);\n+\t  if (TREE_CODE (temp.op0) == INTEGER_CST\n+\t      && TREE_CODE (temp.op1) == INTEGER_CST\n+\t      && TREE_CODE (temp.op2) == INTEGER_CST)\n+\t    {\n+\t      double_int off = tree_to_double_int (temp.op0);\n+\t      off = double_int_add (off,\n+\t\t\t\t    double_int_neg\n+\t\t\t\t      (tree_to_double_int (temp.op1)));\n+\t      off = double_int_mul (off, tree_to_double_int (temp.op2));\n+\t      if (double_int_fits_in_shwi_p (off))\n+\t\ttemp.off = off.low;\n+\t    }\n \t  break;\n \tcase STRING_CST:\n \tcase INTEGER_CST:\n@@ -592,9 +690,13 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n \t     ref in the chain of references (IE they require an\n \t     operand), so we don't have to put anything\n \t     for op* as it will be handled by the iteration  */\n-\tcase IMAGPART_EXPR:\n \tcase REALPART_EXPR:\n \tcase VIEW_CONVERT_EXPR:\n+\t  temp.off = 0;\n+\t  break;\n+\tcase IMAGPART_EXPR:\n+\t  /* This is only interesting for its constant offset.  */\n+\t  temp.off = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (ref)));\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n@@ -627,16 +729,12 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n   HOST_WIDE_INT max_size;\n   HOST_WIDE_INT size = -1;\n   tree size_tree = NULL_TREE;\n+  alias_set_type base_alias_set = -1;\n \n   /* First get the final access size from just the outermost expression.  */\n   op = VEC_index (vn_reference_op_s, ops, 0);\n   if (op->opcode == COMPONENT_REF)\n-    {\n-      if (TREE_CODE (op->op0) == INTEGER_CST)\n-\tsize_tree = op->op0;\n-      else\n-\tsize_tree = DECL_SIZE (op->op0);\n-    }\n+    size_tree = DECL_SIZE (op->op0);\n   else if (op->opcode == BIT_FIELD_REF)\n     size_tree = op->op0;\n   else\n@@ -667,13 +765,31 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n \t{\n \t/* These may be in the reference ops, but we cannot do anything\n \t   sensible with them here.  */\n-\tcase CALL_EXPR:\n \tcase ADDR_EXPR:\n+\t  /* Apart from ADDR_EXPR arguments to MEM_REF.  */\n+\t  if (base != NULL_TREE\n+\t      && TREE_CODE (base) == MEM_REF\n+\t      && op->op0\n+\t      && DECL_P (TREE_OPERAND (op->op0, 0)))\n+\t    {\n+\t      vn_reference_op_t pop = VEC_index (vn_reference_op_s, ops, i-1);\n+\t      base = TREE_OPERAND (op->op0, 0);\n+\t      if (pop->off == -1)\n+\t\t{\n+\t\t  max_size = -1;\n+\t\t  offset = 0;\n+\t\t}\n+\t      else\n+\t\toffset += pop->off * BITS_PER_UNIT;\n+\t      op0_p = NULL;\n+\t      break;\n+\t    }\n+\t  /* Fallthru.  */\n+\tcase CALL_EXPR:\n \t  return false;\n \n \t/* Record the base objects.  */\n \tcase ALIGN_INDIRECT_REF:\n-\tcase INDIRECT_REF:\n \t  *op0_p = build1 (op->opcode, op->type, NULL_TREE);\n \t  op0_p = &TREE_OPERAND (*op0_p, 0);\n \t  break;\n@@ -684,11 +800,19 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n \t  op0_p = &TREE_OPERAND (*op0_p, 0);\n \t  break;\n \n+\tcase MEM_REF:\n+\t  base_alias_set = get_deref_alias_set (op->op0);\n+\t  *op0_p = build2 (MEM_REF, op->type,\n+\t\t\t   NULL_TREE, op->op0);\n+\t  op0_p = &TREE_OPERAND (*op0_p, 0);\n+\t  break;\n+\n \tcase VAR_DECL:\n \tcase PARM_DECL:\n \tcase RESULT_DECL:\n \tcase SSA_NAME:\n \t  *op0_p = op->op0;\n+\t  op0_p = NULL;\n \t  break;\n \n \t/* And now the usual component-reference style ops.  */\n@@ -703,11 +827,8 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n \t       cannot use component_ref_field_offset.  Do the interesting\n \t       parts manually.  */\n \n-\t    /* Our union trick, done for offset zero only.  */\n-\t    if (TREE_CODE (field) == INTEGER_CST)\n-\t      ;\n-\t    else if (op->op1\n-\t\t     || !host_integerp (DECL_FIELD_OFFSET (field), 1))\n+\t    if (op->op1\n+\t\t|| !host_integerp (DECL_FIELD_OFFSET (field), 1))\n \t      max_size = -1;\n \t    else\n \t      {\n@@ -768,7 +889,10 @@ ao_ref_init_from_vn_reference (ao_ref *ref,\n   ref->size = size;\n   ref->max_size = max_size;\n   ref->ref_alias_set = set;\n-  ref->base_alias_set = -1;\n+  if (base_alias_set != -1)\n+    ref->base_alias_set = base_alias_set;\n+  else\n+    ref->base_alias_set = get_alias_set (base);\n \n   return true;\n }\n@@ -789,6 +913,7 @@ copy_reference_ops_from_call (gimple call,\n   temp.opcode = CALL_EXPR;\n   temp.op0 = gimple_call_fn (call);\n   temp.op1 = gimple_call_chain (call);\n+  temp.off = -1;\n   VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n \n   /* Copy the call arguments.  As they can be references as well,\n@@ -830,62 +955,30 @@ void\n vn_reference_fold_indirect (VEC (vn_reference_op_s, heap) **ops,\n \t\t\t    unsigned int *i_p)\n {\n-  VEC(vn_reference_op_s, heap) *mem = NULL;\n-  vn_reference_op_t op;\n   unsigned int i = *i_p;\n-  unsigned int j;\n-\n-  /* Get ops for the addressed object.  */\n-  op = VEC_index (vn_reference_op_s, *ops, i);\n-  /* ???  If this is our usual typeof &ARRAY vs. &ARRAY[0] problem, work\n-     around it to avoid later ICEs.  */\n-  if (TREE_CODE (TREE_TYPE (TREE_OPERAND (op->op0, 0))) == ARRAY_TYPE\n-      && TREE_CODE (TREE_TYPE (TREE_TYPE (op->op0))) != ARRAY_TYPE)\n-    {\n-      vn_reference_op_s aref;\n-      tree dom;\n-      aref.type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (op->op0)));\n-      aref.opcode = ARRAY_REF;\n-      aref.op0 = integer_zero_node;\n-      if ((dom = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (op->op0, 0))))\n-\t  && TYPE_MIN_VALUE (dom))\n-\taref.op0 = TYPE_MIN_VALUE (dom);\n-      aref.op1 = aref.op0;\n-      aref.op2 = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (op->op0)));\n-      VEC_safe_push (vn_reference_op_s, heap, mem, &aref);\n-    }\n-  copy_reference_ops_from_ref (TREE_OPERAND (op->op0, 0), &mem);\n-\n-  /* Do the replacement - we should have at least one op in mem now.  */\n-  if (VEC_length (vn_reference_op_s, mem) == 1)\n-    {\n-      VEC_replace (vn_reference_op_s, *ops, i - 1,\n-\t\t   VEC_index (vn_reference_op_s, mem, 0));\n-      VEC_ordered_remove (vn_reference_op_s, *ops, i);\n-      i--;\n-    }\n-  else if (VEC_length (vn_reference_op_s, mem) == 2)\n-    {\n-      VEC_replace (vn_reference_op_s, *ops, i - 1,\n-\t\t   VEC_index (vn_reference_op_s, mem, 0));\n-      VEC_replace (vn_reference_op_s, *ops, i,\n-\t\t   VEC_index (vn_reference_op_s, mem, 1));\n-    }\n-  else if (VEC_length (vn_reference_op_s, mem) > 2)\n-    {\n-      VEC_replace (vn_reference_op_s, *ops, i - 1,\n-\t\t   VEC_index (vn_reference_op_s, mem, 0));\n-      VEC_replace (vn_reference_op_s, *ops, i,\n-\t\t   VEC_index (vn_reference_op_s, mem, 1));\n-      /* ???  There is no VEC_splice.  */\n-      for (j = 2; VEC_iterate (vn_reference_op_s, mem, j, op); j++)\n-\tVEC_safe_insert (vn_reference_op_s, heap, *ops, ++i, op);\n+  vn_reference_op_t op = VEC_index (vn_reference_op_s, *ops, i);\n+  vn_reference_op_t mem_op = VEC_index (vn_reference_op_s, *ops, i - 1);\n+  tree addr_base;\n+  HOST_WIDE_INT addr_offset;\n+\n+  /* The only thing we have to do is from &OBJ.foo.bar add the offset\n+     from .foo.bar to the preceeding MEM_REF offset and replace the\n+     address with &OBJ.  */\n+  addr_base = get_addr_base_and_unit_offset (TREE_OPERAND (op->op0, 0),\n+\t\t\t\t\t     &addr_offset);\n+  gcc_checking_assert (addr_base && TREE_CODE (addr_base) != MEM_REF);\n+  if (addr_base != op->op0)\n+    {\n+      double_int off = tree_to_double_int (mem_op->op0);\n+      off = double_int_sext (off, TYPE_PRECISION (TREE_TYPE (mem_op->op0)));\n+      off = double_int_add (off, shwi_to_double_int (addr_offset));\n+      mem_op->op0 = double_int_to_tree (TREE_TYPE (mem_op->op0), off);\n+      op->op0 = build_fold_addr_expr (addr_base);\n+      if (host_integerp (mem_op->op0, 0))\n+\tmem_op->off = TREE_INT_CST_LOW (mem_op->op0);\n+      else\n+\tmem_op->off = -1;\n     }\n-  else\n-    gcc_unreachable ();\n-\n-  VEC_free (vn_reference_op_s, heap, mem);\n-  *i_p = i;\n }\n \n /* Optimize the reference REF to a constant if possible or return\n@@ -978,20 +1071,35 @@ valueize_refs (VEC (vn_reference_op_s, heap) *orig)\n \t     the opcode.  */\n \t  if (TREE_CODE (vro->op0) != SSA_NAME && vro->opcode == SSA_NAME)\n \t    vro->opcode = TREE_CODE (vro->op0);\n-\t  /* If it transforms from an SSA_NAME to an address, fold with\n-\t     a preceding indirect reference.  */\n-\t  if (i > 0 && TREE_CODE (vro->op0) == ADDR_EXPR\n-\t      && VEC_index (vn_reference_op_s,\n-\t\t\t    orig, i - 1)->opcode == INDIRECT_REF)\n-\t    {\n-\t      vn_reference_fold_indirect (&orig, &i);\n-\t      continue;\n-\t    }\n \t}\n       if (vro->op1 && TREE_CODE (vro->op1) == SSA_NAME)\n \tvro->op1 = SSA_VAL (vro->op1);\n       if (vro->op2 && TREE_CODE (vro->op2) == SSA_NAME)\n \tvro->op2 = SSA_VAL (vro->op2);\n+      /* If it transforms from an SSA_NAME to an address, fold with\n+\t a preceding indirect reference.  */\n+      if (i > 0\n+\t  && vro->op0\n+\t  && TREE_CODE (vro->op0) == ADDR_EXPR\n+\t  && VEC_index (vn_reference_op_s,\n+\t\t\torig, i - 1)->opcode == MEM_REF)\n+\tvn_reference_fold_indirect (&orig, &i);\n+      /* If it transforms a non-constant ARRAY_REF into a constant\n+\t one, adjust the constant offset.  */\n+      else if (vro->opcode == ARRAY_REF\n+\t       && vro->off == -1\n+\t       && TREE_CODE (vro->op0) == INTEGER_CST\n+\t       && TREE_CODE (vro->op1) == INTEGER_CST\n+\t       && TREE_CODE (vro->op2) == INTEGER_CST)\n+\t{\n+\t  double_int off = tree_to_double_int (vro->op0);\n+\t  off = double_int_add (off,\n+\t\t\t\tdouble_int_neg\n+\t\t\t\t  (tree_to_double_int (vro->op1)));\n+\t  off = double_int_mul (off, tree_to_double_int (vro->op2));\n+\t  if (double_int_fits_in_shwi_p (off))\n+\t    vro->off = off.low;\n+\t}\n     }\n \n   return orig;\n@@ -1172,7 +1280,7 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_)\n      the copy kills ref.  */\n   else if (gimple_assign_single_p (def_stmt)\n \t   && (DECL_P (gimple_assign_rhs1 (def_stmt))\n-\t       || INDIRECT_REF_P (gimple_assign_rhs1 (def_stmt))\n+\t       || TREE_CODE (gimple_assign_rhs1 (def_stmt)) == MEM_REF\n \t       || handled_component_p (gimple_assign_rhs1 (def_stmt))))\n     {\n       tree base2;\n@@ -2092,9 +2200,9 @@ visit_reference_op_load (tree lhs, tree op, gimple stmt)\n \tresult = vn_nary_op_lookup (val, NULL);\n       /* If the expression is not yet available, value-number lhs to\n \t a new SSA_NAME we create.  */\n-      if (!result && may_insert)\n+      if (!result)\n         {\n-\t  result = make_ssa_name (SSA_NAME_VAR (lhs), NULL);\n+\t  result = make_ssa_name (SSA_NAME_VAR (lhs), gimple_build_nop ());\n \t  /* Initialize value-number information properly.  */\n \t  VN_INFO_GET (result)->valnum = result;\n \t  VN_INFO (result)->value_id = get_next_value_id ();\n@@ -3266,14 +3374,12 @@ set_hashtable_value_ids (void)\n    due to resource constraints.  */\n \n bool\n-run_scc_vn (bool may_insert_arg)\n+run_scc_vn (void)\n {\n   size_t i;\n   tree param;\n   bool changed = true;\n \n-  may_insert = may_insert_arg;\n-\n   init_scc_vn ();\n   current_info = valid_info;\n \n@@ -3297,7 +3403,6 @@ run_scc_vn (bool may_insert_arg)\n \tif (!DFS (name))\n \t  {\n \t    free_scc_vn ();\n-\t    may_insert = false;\n \t    return false;\n \t  }\n     }\n@@ -3359,7 +3464,6 @@ run_scc_vn (bool may_insert_arg)\n \t}\n     }\n \n-  may_insert = false;\n   return true;\n }\n "}, {"sha": "ba7fc5c3e49bffc310c81efda416b363f64779a1", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -72,6 +72,8 @@ typedef const struct vn_phi_s *const_vn_phi_t;\n typedef struct vn_reference_op_struct\n {\n   enum tree_code opcode;\n+  /* Constant offset this op adds or -1 if it is variable.  */\n+  HOST_WIDE_INT off;\n   tree type;\n   tree op0;\n   tree op1;\n@@ -167,7 +169,7 @@ typedef struct vn_ssa_aux\n extern vn_ssa_aux_t VN_INFO (tree);\n extern vn_ssa_aux_t VN_INFO_GET (tree);\n tree vn_get_expr_for (tree);\n-bool run_scc_vn (bool);\n+bool run_scc_vn (void);\n void free_scc_vn (void);\n tree vn_nary_op_lookup (tree, vn_nary_op_t *);\n tree vn_nary_op_lookup_stmt (gimple, vn_nary_op_t *);"}, {"sha": "9deec26b11d5bbcc461247a5385a64ed6fcddcf6", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -190,8 +190,11 @@ is_hidden_global_store (gimple stmt)\n \t    return true;\n \n \t}\n-      else if (INDIRECT_REF_P (lhs))\n+      else if (INDIRECT_REF_P (lhs)\n+\t       || TREE_CODE (lhs) == MEM_REF)\n \treturn ptr_deref_may_alias_global_p (TREE_OPERAND (lhs, 0));\n+      else if (CONSTANT_CLASS_P (lhs))\n+\treturn true;\n       else\n \tgcc_unreachable ();\n     }"}, {"sha": "77ff17a6962554a6594f3ab87b90e532b47a845b", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -3107,7 +3107,8 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results,\n      &0->a.b */\n   forzero = t;\n   while (handled_component_p (forzero)\n-\t || INDIRECT_REF_P (forzero))\n+\t || INDIRECT_REF_P (forzero)\n+\t || TREE_CODE (forzero) == MEM_REF)\n     forzero = TREE_OPERAND (forzero, 0);\n \n   if (CONSTANT_CLASS_P (forzero) && integer_zerop (forzero))\n@@ -3334,9 +3335,10 @@ get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p)\n       {\n \tswitch (TREE_CODE (t))\n \t  {\n-\t  case INDIRECT_REF:\n+\t  case MEM_REF:\n \t    {\n-\t      get_constraint_for_1 (TREE_OPERAND (t, 0), results, address_p);\n+\t      get_constraint_for_ptr_offset (TREE_OPERAND (t, 0),\n+\t\t\t\t\t     TREE_OPERAND (t, 1), results);\n \t      do_deref (results);\n \t      return;\n \t    }\n@@ -4572,7 +4574,11 @@ find_func_clobbers (gimple origt)\n \ttem = TREE_OPERAND (tem, 0);\n       if ((DECL_P (tem)\n \t   && !auto_var_in_fn_p (tem, cfun->decl))\n-\t  || INDIRECT_REF_P (tem))\n+\t  || INDIRECT_REF_P (tem)\n+\t  || (TREE_CODE (tem) == MEM_REF\n+\t      && !(TREE_CODE (TREE_OPERAND (tem, 0)) == ADDR_EXPR\n+\t\t   && auto_var_in_fn_p\n+\t\t        (TREE_OPERAND (TREE_OPERAND (tem, 0), 0), cfun->decl))))\n \t{\n \t  struct constraint_expr lhsc, *rhsp;\n \t  unsigned i;\n@@ -4596,7 +4602,11 @@ find_func_clobbers (gimple origt)\n \ttem = TREE_OPERAND (tem, 0);\n       if ((DECL_P (tem)\n \t   && !auto_var_in_fn_p (tem, cfun->decl))\n-\t  || INDIRECT_REF_P (tem))\n+\t  || INDIRECT_REF_P (tem)\n+\t  || (TREE_CODE (tem) == MEM_REF\n+\t      && !(TREE_CODE (TREE_OPERAND (tem, 0)) == ADDR_EXPR\n+\t\t   && auto_var_in_fn_p\n+\t\t        (TREE_OPERAND (TREE_OPERAND (tem, 0), 0), cfun->decl))))\n \t{\n \t  struct constraint_expr lhs, *rhsp;\n \t  unsigned i;"}, {"sha": "a997f7884b0fd59d9770448b6e63f65b7d20fdbd", "filename": "gcc/tree-ssa-ter.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-ter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa-ter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -616,6 +616,24 @@ find_replaceable_in_bb (temp_expr_table_p tab, basic_block bb)\n \t\t      }\n \t\t  }\n \n+\t      /* If the stmt does a memory store and the replacement\n+\t         is a load aliasing it avoid creating overlapping\n+\t\t assignments which we cannot expand correctly.  */\n+\t      if (gimple_vdef (stmt)\n+\t\t  && gimple_assign_single_p (stmt))\n+\t\t{\n+\t\t  gimple def_stmt = SSA_NAME_DEF_STMT (use);\n+\t\t  while (is_gimple_assign (def_stmt)\n+\t\t\t && gimple_assign_rhs_code (def_stmt) == SSA_NAME)\n+\t\t    def_stmt\n+\t\t      = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (def_stmt));\n+\t\t  if (gimple_vuse (def_stmt)\n+\t\t      && gimple_assign_single_p (def_stmt)\n+\t\t      && refs_may_alias_p (gimple_assign_lhs (stmt),\n+\t\t\t\t\t   gimple_assign_rhs1 (def_stmt)))\n+\t\t    same_root_var = true;\n+\t\t}\n+\n \t      /* Mark expression as replaceable unless stmt is volatile or the\n \t\t def variable has the same root variable as something in the\n \t\t substitution list.  */"}, {"sha": "2ea2e685b9d91d873d111a2def2bafe23f5f9063", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 152, "deletions": 54, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -1204,6 +1204,12 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n \t  != TYPE_ADDR_SPACE (TREE_TYPE (inner_type)))\n \treturn false;\n \n+      /* Do not lose casts to restrict qualified pointers.  */\n+      if ((TYPE_RESTRICT (outer_type)\n+\t   != TYPE_RESTRICT (inner_type))\n+\t  && TYPE_RESTRICT (outer_type))\n+\treturn false;\n+\n       /* If the outer type is (void *) or a pointer to an incomplete\n \t record type or a pointer to an unprototyped function,\n \t then the conversion is not necessary.  */\n@@ -1216,12 +1222,6 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n \t      && useless_type_conversion_p (TREE_TYPE (TREE_TYPE (outer_type)),\n \t\t\t\t\t    TREE_TYPE (TREE_TYPE (inner_type)))))\n \treturn true;\n-\n-      /* Do not lose casts to restrict qualified pointers.  */\n-      if ((TYPE_RESTRICT (outer_type)\n-\t   != TYPE_RESTRICT (inner_type))\n-\t  && TYPE_RESTRICT (outer_type))\n-\treturn false;\n     }\n \n   /* From now on qualifiers on value types do not matter.  */\n@@ -1273,41 +1273,18 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n   else if (POINTER_TYPE_P (inner_type)\n \t   && POINTER_TYPE_P (outer_type))\n     {\n-      /* Don't lose casts between pointers to volatile and non-volatile\n-\t qualified types.  Doing so would result in changing the semantics\n-\t of later accesses.  For function types the volatile qualifier\n-\t is used to indicate noreturn functions.  */\n-      if (TREE_CODE (TREE_TYPE (outer_type)) != FUNCTION_TYPE\n-\t  && TREE_CODE (TREE_TYPE (outer_type)) != METHOD_TYPE\n-\t  && TREE_CODE (TREE_TYPE (inner_type)) != FUNCTION_TYPE\n-\t  && TREE_CODE (TREE_TYPE (inner_type)) != METHOD_TYPE\n-\t  && (TYPE_VOLATILE (TREE_TYPE (outer_type))\n-\t      != TYPE_VOLATILE (TREE_TYPE (inner_type)))\n-\t  && TYPE_VOLATILE (TREE_TYPE (outer_type)))\n-\treturn false;\n-\n-      /* We require explicit conversions from incomplete target types.  */\n-      if (!COMPLETE_TYPE_P (TREE_TYPE (inner_type))\n-\t  && COMPLETE_TYPE_P (TREE_TYPE (outer_type)))\n-\treturn false;\n-\n-      /* Do not lose casts between pointers that when dereferenced access\n-\t memory with different alias sets.  */\n-      if (get_deref_alias_set (inner_type) != get_deref_alias_set (outer_type))\n+      /* Do not lose casts to function pointer types.  */\n+      if ((TREE_CODE (TREE_TYPE (outer_type)) == FUNCTION_TYPE\n+\t   || TREE_CODE (TREE_TYPE (outer_type)) == METHOD_TYPE)\n+\t  && !useless_type_conversion_p (TREE_TYPE (outer_type),\n+\t\t\t\t\t TREE_TYPE (inner_type)))\n \treturn false;\n \n       /* We do not care for const qualification of the pointed-to types\n \t as const qualification has no semantic value to the middle-end.  */\n \n-      /* Otherwise pointers/references are equivalent if their pointed\n-\t to types are effectively the same.  We can strip qualifiers\n-\t on pointed-to types for further comparison, which is done in\n-\t the callee.  Note we have to use true compatibility here\n-\t because addresses are subject to propagation into dereferences\n-\t and thus might get the original type exposed which is equivalent\n-\t to a reverse conversion.  */\n-      return types_compatible_p (TREE_TYPE (outer_type),\n-\t\t\t\t TREE_TYPE (inner_type));\n+      /* Otherwise pointers/references are equivalent.  */\n+      return true;\n     }\n \n   /* Recurse for complex types.  */\n@@ -1673,8 +1650,9 @@ warn_uninitialized_var (tree *tp, int *walk_subtrees, void *data_)\n   /* We do not care about LHS.  */\n   if (wi->is_lhs)\n     {\n-      /* Except for operands of INDIRECT_REF.  */\n-      if (!INDIRECT_REF_P (t))\n+      /* Except for operands of dereferences.  */\n+      if (!INDIRECT_REF_P (t)\n+\t  && TREE_CODE (t) != MEM_REF)\n \treturn NULL_TREE;\n       t = TREE_OPERAND (t, 0);\n     }\n@@ -1822,6 +1800,34 @@ struct gimple_opt_pass pass_early_warn_uninitialized =\n  }\n };\n \n+\n+/* If necessary, rewrite the base of the reference tree *TP from\n+   a MEM_REF to a plain or converted symbol.  */\n+\n+static void\n+maybe_rewrite_mem_ref_base (tree *tp)\n+{\n+  tree sym;\n+\n+  while (handled_component_p (*tp))\n+    tp = &TREE_OPERAND (*tp, 0);\n+  if (TREE_CODE (*tp) == MEM_REF\n+      && TREE_CODE (TREE_OPERAND (*tp, 0)) == ADDR_EXPR\n+      && integer_zerop (TREE_OPERAND (*tp, 1))\n+      && (sym = TREE_OPERAND (TREE_OPERAND (*tp, 0), 0))\n+      && DECL_P (sym)\n+      && !TREE_ADDRESSABLE (sym)\n+      && symbol_marked_for_renaming (sym))\n+    {\n+      if (!useless_type_conversion_p (TREE_TYPE (*tp),\n+\t\t\t\t      TREE_TYPE (sym)))\n+\t*tp = build1 (VIEW_CONVERT_EXPR,\n+\t\t\tTREE_TYPE (*tp), sym);\n+      else\n+\t*tp = sym;\n+    }\n+}\n+\n /* Compute TREE_ADDRESSABLE and DECL_GIMPLE_REG_P for local variables.  */\n \n void\n@@ -1853,17 +1859,50 @@ execute_update_addresses_taken (bool do_optimize)\n \t    {\n               tree lhs = gimple_get_lhs (stmt);\n \n-              /* We may not rewrite TMR_SYMBOL to SSA.  */\n-              if (lhs && TREE_CODE (lhs) == TARGET_MEM_REF\n-                  && TMR_SYMBOL (lhs))\n-                bitmap_set_bit (not_reg_needs, DECL_UID (TMR_SYMBOL (lhs)));\n+              /* A plain decl does not need it set.  */\n+              if (lhs && !DECL_P (lhs))\n+\t\t{\n+\t\t  if (handled_component_p (lhs))\n+\t\t    lhs = get_base_address (lhs);\n+\n+                  if (DECL_P (lhs))\n+                    bitmap_set_bit (not_reg_needs, DECL_UID (lhs));\n+\t\t  else if (TREE_CODE (lhs) == MEM_REF\n+\t\t\t   && TREE_CODE (TREE_OPERAND (lhs, 0)) == ADDR_EXPR)\n+\t\t    {\n+\t\t      tree decl = TREE_OPERAND (TREE_OPERAND (lhs, 0), 0);\n+\t\t      if (DECL_P (decl)\n+\t\t\t  && (!integer_zerop (TREE_OPERAND (lhs, 1))\n+\t\t\t      || (DECL_SIZE (decl)\n+\t\t\t\t  != TYPE_SIZE (TREE_TYPE (lhs)))))\n+\t\t\tbitmap_set_bit (not_reg_needs, DECL_UID (decl));\n+\t\t    }\n+                }\n+\t    }\n+\n+\t  if (gimple_assign_single_p (stmt))\n+\t    {\n+\t      tree rhs = gimple_assign_rhs1 (stmt);\n \n               /* A plain decl does not need it set.  */\n-              else if (lhs && handled_component_p (lhs))\n-                {\n-                  var = get_base_address (lhs);\n-                  if (DECL_P (var))\n-                    bitmap_set_bit (not_reg_needs, DECL_UID (var));\n+              if (!DECL_P (rhs))\n+\t\t{\n+\t\t  tree base = rhs;\n+\t\t  while (handled_component_p (base))\n+\t\t    base = TREE_OPERAND (base, 0);\n+\n+\t\t  /* But watch out for MEM_REFs we cannot lower to a\n+\t\t     VIEW_CONVERT_EXPR.  */\n+\t\t  if (TREE_CODE (base) == MEM_REF\n+\t\t      && TREE_CODE (TREE_OPERAND (base, 0)) == ADDR_EXPR)\n+\t\t    {\n+\t\t      tree decl = TREE_OPERAND (TREE_OPERAND (base, 0), 0);\n+\t\t      if (DECL_P (decl)\n+\t\t\t  && (!integer_zerop (TREE_OPERAND (base, 1))\n+\t\t\t      || (DECL_SIZE (decl)\n+\t\t\t\t  != TYPE_SIZE (TREE_TYPE (base)))))\n+\t\t\tbitmap_set_bit (not_reg_needs, DECL_UID (decl));\n+\t\t    }\n                 }\n \t    }\n \t}\n@@ -1937,14 +1976,73 @@ execute_update_addresses_taken (bool do_optimize)\n   if (update_vops)\n     {\n       FOR_EACH_BB (bb)\n-\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t    {\n-\t      gimple stmt = gsi_stmt (gsi);\n+\tfor (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  {\n+\t    gimple stmt = gsi_stmt (gsi);\n \n-\t      if (gimple_references_memory_p (stmt)\n-\t\t  || is_gimple_debug (stmt))\n-\t\tupdate_stmt (stmt);\n-\t    }\n+\t    /* Re-write TARGET_MEM_REFs of symbols we want to\n+\t       rewrite into SSA form.  */\n+\t    if (gimple_assign_single_p (stmt))\n+\t      {\n+\t\ttree lhs = gimple_assign_lhs (stmt);\n+\t\ttree rhs, *rhsp = gimple_assign_rhs1_ptr (stmt);\n+\t\ttree sym;\n+\n+\t\t/* We shouldn't have any fancy wrapping of\n+\t\t   component-refs on the LHS, but look through\n+\t\t   VIEW_CONVERT_EXPRs as that is easy.  */\n+\t\twhile (TREE_CODE (lhs) == VIEW_CONVERT_EXPR)\n+\t\t  lhs = TREE_OPERAND (lhs, 0);\n+\t\tif (TREE_CODE (lhs) == MEM_REF\n+\t\t    && TREE_CODE (TREE_OPERAND (lhs, 0)) == ADDR_EXPR\n+\t\t    && integer_zerop (TREE_OPERAND (lhs, 1))\n+\t\t    && (sym = TREE_OPERAND (TREE_OPERAND (lhs, 0), 0))\n+\t\t    && DECL_P (sym)\n+\t\t    && !TREE_ADDRESSABLE (sym)\n+\t\t    && symbol_marked_for_renaming (sym))\n+\t\t  lhs = sym;\n+\t\telse\n+\t\t  lhs = gimple_assign_lhs (stmt);\n+\n+\t\t/* Rewrite the RHS and make sure the resulting assignment\n+\t\t   is validly typed.  */\n+\t\tmaybe_rewrite_mem_ref_base (rhsp);\n+\t\trhs = gimple_assign_rhs1 (stmt);\n+\t\tif (gimple_assign_lhs (stmt) != lhs\n+\t\t    && !useless_type_conversion_p (TREE_TYPE (lhs),\n+\t\t\t\t\t\t   TREE_TYPE (rhs)))\n+\t\t  rhs = fold_build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t     TREE_TYPE (lhs), rhs);\n+\n+\t\tif (gimple_assign_lhs (stmt) != lhs)\n+\t\t  gimple_assign_set_lhs (stmt, lhs);\n+\n+\t\tif (gimple_assign_rhs1 (stmt) != rhs)\n+\t\t  {\n+\t\t    gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+\t\t    gimple_assign_set_rhs_from_tree (&gsi, rhs);\n+\t\t  }\n+\t      }\n+\n+\t    if (gimple_code (stmt) == GIMPLE_ASM)\n+\t      {\n+\t\tunsigned i;\n+\t\tfor (i = 0; i < gimple_asm_noutputs (stmt); ++i)\n+\t\t  {\n+\t\t    tree link = gimple_asm_output_op (stmt, i);\n+\t\t    maybe_rewrite_mem_ref_base (&TREE_VALUE (link));\n+\t\t  }\n+\t\tfor (i = 0; i < gimple_asm_ninputs (stmt); ++i)\n+\t\t  {\n+\t\t    tree link = gimple_asm_input_op (stmt, i);\n+\t\t    maybe_rewrite_mem_ref_base (&TREE_VALUE (link));\n+\t\t  }\n+\t      }\n+\n+\t    if (gimple_references_memory_p (stmt)\n+\t\t|| is_gimple_debug (stmt))\n+\t      update_stmt (stmt);\n+\t  }\n \n       /* Update SSA form here, we are called as non-pass as well.  */\n       update_ssa (TODO_update_ssa);"}, {"sha": "dae14f54a6000be9e9d8813506be8671c3cc1c9d", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -512,7 +512,7 @@ check_all_va_list_escapes (struct stdarg_info *si)\n \t\t  enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n \n \t\t  /* x = *ap_temp;  */\n-\t\t  if (gimple_assign_rhs_code (stmt) == INDIRECT_REF\n+\t\t  if (gimple_assign_rhs_code (stmt) == MEM_REF\n \t\t      && TREE_OPERAND (rhs, 0) == use\n \t\t      && TYPE_SIZE_UNIT (TREE_TYPE (rhs))\n \t\t      && host_integerp (TYPE_SIZE_UNIT (TREE_TYPE (rhs)), 1)\n@@ -522,6 +522,7 @@ check_all_va_list_escapes (struct stdarg_info *si)\n \t\t      tree access_size = TYPE_SIZE_UNIT (TREE_TYPE (rhs));\n \n \t\t      gpr_size = si->offsets[SSA_NAME_VERSION (use)]\n+\t\t\t  \t + tree_low_cst (TREE_OPERAND (rhs, 1), 0)\n \t\t\t\t + tree_low_cst (access_size, 1);\n \t\t      if (gpr_size >= VA_LIST_MAX_GPR_SIZE)\n \t\t\tcfun->va_list_gpr_size = VA_LIST_MAX_GPR_SIZE;"}, {"sha": "cbefc1f01c4bb775b4b8dc5966fddff1082e8945", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -2398,12 +2398,9 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n                              data_ref_base, base_offset);\n   else\n     {\n-      if (TREE_CODE (DR_REF (dr)) == INDIRECT_REF)\n-        addr_base = unshare_expr (TREE_OPERAND (DR_REF (dr), 0));\n-      else\n-        addr_base = build1 (ADDR_EXPR,\n-                            build_pointer_type (TREE_TYPE (DR_REF (dr))),\n-                            unshare_expr (DR_REF (dr)));\n+      addr_base = build1 (ADDR_EXPR,\n+\t\t\t  build_pointer_type (TREE_TYPE (DR_REF (dr))),\n+\t\t\t  unshare_expr (DR_REF (dr)));\n     }\n \n   vect_ptr_type = build_pointer_type (STMT_VINFO_VECTYPE (stmt_info));"}, {"sha": "c95fe7d273e4ecd807a56101fbe4e505ed28603e", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -3026,7 +3026,8 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       && TREE_CODE (scalar_dest) != INDIRECT_REF\n       && TREE_CODE (scalar_dest) != COMPONENT_REF\n       && TREE_CODE (scalar_dest) != IMAGPART_EXPR\n-      && TREE_CODE (scalar_dest) != REALPART_EXPR)\n+      && TREE_CODE (scalar_dest) != REALPART_EXPR\n+      && TREE_CODE (scalar_dest) != MEM_REF)\n     return false;\n \n   gcc_assert (gimple_assign_single_p (stmt));\n@@ -3282,7 +3283,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t    vec_oprnd = VEC_index (tree, result_chain, i);\n \n           if (aligned_access_p (first_dr))\n-            data_ref = build_fold_indirect_ref (dataref_ptr);\n+\t    data_ref = build_simple_mem_ref (dataref_ptr);\n           else\n           {\n             int mis = DR_MISALIGNMENT (first_dr);\n@@ -3421,7 +3422,8 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       && code != INDIRECT_REF\n       && code != COMPONENT_REF\n       && code != IMAGPART_EXPR\n-      && code != REALPART_EXPR)\n+      && code != REALPART_EXPR\n+      && code != MEM_REF)\n     return false;\n \n   if (!STMT_VINFO_DATA_REF (stmt_info))\n@@ -3659,7 +3661,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t    {\n \t    case dr_aligned:\n \t      gcc_assert (aligned_access_p (first_dr));\n-\t      data_ref = build_fold_indirect_ref (dataref_ptr);\n+\t      data_ref = build_simple_mem_ref (dataref_ptr);\n \t      break;\n \t    case dr_unaligned_supported:\n \t      {"}, {"sha": "4f5db8069f52489b2c62ad0e0c25f640d0a77683", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -987,7 +987,7 @@ vrp_stmt_computes_nonzero (gimple stmt, bool *strict_overflow_p)\n       tree base = get_base_address (TREE_OPERAND (expr, 0));\n \n       if (base != NULL_TREE\n-\t  && TREE_CODE (base) == INDIRECT_REF\n+\t  && TREE_CODE (base) == MEM_REF\n \t  && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n \t{\n \t  value_range_t *vr = get_value_range (TREE_OPERAND (base, 0));\n@@ -5075,8 +5075,7 @@ check_array_ref (location_t location, tree ref, bool ignore_off_by_one)\n   /* Accesses to trailing arrays via pointers may access storage\n      beyond the types array bounds.  */\n   base = get_base_address (ref);\n-  if (base\n-      && INDIRECT_REF_P (base))\n+  if (base && TREE_CODE (base) == MEM_REF)\n     {\n       tree cref, next = NULL_TREE;\n \n@@ -5175,6 +5174,51 @@ search_for_addr_array (tree t, location_t location)\n       t = TREE_OPERAND (t, 0);\n     }\n   while (handled_component_p (t));\n+\n+  if (TREE_CODE (t) == MEM_REF\n+      && TREE_CODE (TREE_OPERAND (t, 0)) == ADDR_EXPR\n+      && !TREE_NO_WARNING (t))\n+    {\n+      tree tem = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n+      tree low_bound, up_bound, el_sz;\n+      double_int idx;\n+      if (TREE_CODE (TREE_TYPE (tem)) != ARRAY_TYPE\n+\t  || TREE_CODE (TREE_TYPE (TREE_TYPE (tem))) == ARRAY_TYPE\n+\t  || !TYPE_DOMAIN (TREE_TYPE (tem)))\n+\treturn;\n+\n+      low_bound = TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (tem)));\n+      up_bound = TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (tem)));\n+      el_sz = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (tem)));\n+      if (!low_bound\n+\t  || TREE_CODE (low_bound) != INTEGER_CST\n+\t  || !up_bound\n+\t  || TREE_CODE (up_bound) != INTEGER_CST\n+\t  || !el_sz\n+\t  || TREE_CODE (el_sz) != INTEGER_CST)\n+\treturn;\n+\n+      idx = mem_ref_offset (t);\n+      idx = double_int_sdiv (idx, tree_to_double_int (el_sz), TRUNC_DIV_EXPR);\n+      if (double_int_scmp (idx, double_int_zero) < 0)\n+\t{\n+\t  warning_at (location, OPT_Warray_bounds,\n+\t\t      \"array subscript is below array bounds\");\n+\t  TREE_NO_WARNING (t) = 1;\n+\t}\n+      else if (double_int_scmp (idx,\n+\t\t\t\tdouble_int_add\n+\t\t\t\t  (double_int_add\n+\t\t\t\t    (tree_to_double_int (up_bound),\n+\t\t\t\t     double_int_neg\n+\t\t\t\t       (tree_to_double_int (low_bound))),\n+\t\t\t\t    double_int_one)) > 0)\n+\t{\n+\t  warning_at (location, OPT_Warray_bounds,\n+\t\t      \"array subscript is above array bounds\");\n+\t  TREE_NO_WARNING (t) = 1;\n+\t}\n+    }\n }\n \n /* walk_tree() callback that checks if *TP is\n@@ -5203,7 +5247,7 @@ check_array_bounds (tree *tp, int *walk_subtree, void *data)\n   if (TREE_CODE (t) == ARRAY_REF)\n     check_array_ref (location, t, false /*ignore_off_by_one*/);\n \n-  if (TREE_CODE (t) == INDIRECT_REF\n+  if (TREE_CODE (t) == MEM_REF\n       || (TREE_CODE (t) == RETURN_EXPR && TREE_OPERAND (t, 0)))\n     search_for_addr_array (TREE_OPERAND (t, 0), location);\n "}, {"sha": "17accb2f912e91bcc6514ab28b39757019738e39", "filename": "gcc/tree.c", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -3564,7 +3564,8 @@ do { tree _node = (NODE); \\\n      address is constant too.  If it's a decl, its address is constant if the\n      decl is static.  Everything else is not constant and, furthermore,\n      taking the address of a volatile variable is not volatile.  */\n-  if (TREE_CODE (node) == INDIRECT_REF)\n+  if (TREE_CODE (node) == INDIRECT_REF\n+      || TREE_CODE (node) == MEM_REF)\n     UPDATE_FLAGS (TREE_OPERAND (node, 0));\n   else if (CONSTANT_CLASS_P (node))\n     ;\n@@ -3878,6 +3879,42 @@ build6_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n   return t;\n }\n \n+/* Build a simple MEM_REF tree with the sematics of a plain INDIRECT_REF\n+   on the pointer PTR.  */\n+\n+tree\n+build_simple_mem_ref_loc (location_t loc, tree ptr)\n+{\n+  HOST_WIDE_INT offset = 0;\n+  tree ptype = TREE_TYPE (ptr);\n+  tree tem;\n+  /* For convenience allow addresses that collapse to a simple base\n+     and offset.  */\n+  if (TREE_CODE (ptr) == ADDR_EXPR\n+      && (handled_component_p (TREE_OPERAND (ptr, 0))\n+\t  || TREE_CODE (TREE_OPERAND (ptr, 0)) == MEM_REF))\n+    {\n+      ptr = get_addr_base_and_unit_offset (TREE_OPERAND (ptr, 0), &offset);\n+      gcc_assert (ptr);\n+      ptr = build_fold_addr_expr (ptr);\n+      gcc_assert (is_gimple_reg (ptr) || is_gimple_min_invariant (ptr));\n+    }\n+  tem = build2 (MEM_REF, TREE_TYPE (ptype),\n+\t\tptr, build_int_cst (ptype, offset));\n+  SET_EXPR_LOCATION (tem, loc);\n+  return tem;\n+}\n+\n+/* Return the constant offset of a MEM_REF tree T.  */\n+\n+double_int\n+mem_ref_offset (const_tree t)\n+{\n+  tree toff = TREE_OPERAND (t, 1);\n+  return double_int_sext (tree_to_double_int (toff),\n+\t\t\t  TYPE_PRECISION (TREE_TYPE (toff)));\n+}\n+\n /* Similar except don't specify the TREE_TYPE\n    and leave the TREE_SIDE_EFFECTS as 0.\n    It is permissible for arguments to be null,"}, {"sha": "9a7b1ec8199134c94cc6f2a5b2db581c1e5dda3e", "filename": "gcc/tree.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -970,6 +970,16 @@ DEFTREECODE (REALIGN_LOAD_EXPR, \"realign_load\", tcc_expression, 3)\n \n DEFTREECODE (TARGET_MEM_REF, \"target_mem_ref\", tcc_reference, 6)\n \n+/* Memory addressing.  Operands are a pointer and a tree constant integer\n+   byte offset of the pointer type that when dereferenced yields the\n+   type of the base object the pointer points into and which is used for\n+   TBAA purposes.\n+   The type of the MEM_REF is the type the bytes at the memory location\n+   are interpreted as.\n+   MEM_REF <p, c> is equivalent to ((typeof(c))p)->x... where x... is a\n+   chain of component references offsetting p by c.  */\n+DEFTREECODE (MEM_REF, \"mem_ref\", tcc_reference, 2)\n+\n /* The ordering of the codes between OMP_PARALLEL and OMP_CRITICAL is\n    exposed to TREE_RANGE_CHECK.  */\n /* OpenMP - #pragma omp parallel [clause1 ... clauseN]"}, {"sha": "75b3dcfccf145c348b57b4786a4ada787b9c7888", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f348148c09468b05aa09fcfa91b61611003c27/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=70f348148c09468b05aa09fcfa91b61611003c27", "patch": "@@ -4963,6 +4963,10 @@ extern tree build_fold_indirect_ref_loc (location_t, tree);\n #define fold_indirect_ref(T)\\\n         fold_indirect_ref_loc (UNKNOWN_LOCATION, T)\n extern tree fold_indirect_ref_loc (location_t, tree);\n+extern tree build_simple_mem_ref_loc (location_t, tree);\n+#define build_simple_mem_ref(T)\\\n+\tbuild_simple_mem_ref_loc (UNKNOWN_LOCATION, T)\n+extern double_int mem_ref_offset (const_tree);\n extern tree constant_boolean_node (int, tree);\n extern tree div_if_zero_remainder (enum tree_code, const_tree, const_tree);\n "}]}