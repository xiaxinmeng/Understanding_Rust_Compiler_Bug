{"sha": "2563a16d3c7a56cd1e0cfe9b4ccb702edfb12312", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU2M2ExNmQzYzdhNTZjZDFlMGNmZTliNGNjYjcwMmVkZmIxMjMxMg==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2017-11-18T22:05:13Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2017-11-18T22:05:13Z"}, "message": "PR 44292 Handle large record lengths\n\nNow that the ABI supports large record lengths, there's a few places\nin libgfortran where we need to use larger types. For internal units\nwhich by definition are in-memory, it's enought to use ptrdiff_t, for\nexternal units gfc_offset.\n\nRegtested on x86_64-pc-linux-gnu?\n\nlibgfortran/ChangeLog:\n\n2017-11-19  Janne Blomqvist  <jb@gcc.gnu.org>\n\n        PR fortran/44292\n\t* io/transfer.c (skip_record): Use gfc_offset to handle large\n\trecords.\n\t(next_record_r): Likewise.\n\t(sset): Likewise.\n\t(next_record_w): Use gfc_offset/ptrdiff_t appropriately.\n\nFrom-SVN: r254918", "tree": {"sha": "8e0e2ff952f1a8b84f943e814b65b68dfd0bbb94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e0e2ff952f1a8b84f943e814b65b68dfd0bbb94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2563a16d3c7a56cd1e0cfe9b4ccb702edfb12312", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2563a16d3c7a56cd1e0cfe9b4ccb702edfb12312", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2563a16d3c7a56cd1e0cfe9b4ccb702edfb12312", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2563a16d3c7a56cd1e0cfe9b4ccb702edfb12312/comments", "author": null, "committer": null, "parents": [{"sha": "a7a389d6eee846a877b79c733d853cd2e6b162da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7a389d6eee846a877b79c733d853cd2e6b162da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7a389d6eee846a877b79c733d853cd2e6b162da"}], "stats": {"total": 46, "additions": 29, "deletions": 17}, "files": [{"sha": "24084517a62fa8747d69c4bdb1a405b23c56d718", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2563a16d3c7a56cd1e0cfe9b4ccb702edfb12312/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2563a16d3c7a56cd1e0cfe9b4ccb702edfb12312/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=2563a16d3c7a56cd1e0cfe9b4ccb702edfb12312", "patch": "@@ -1,3 +1,12 @@\n+2017-11-19  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR fortran/44292\n+\t* io/transfer.c (skip_record): Use gfc_offset to handle large\n+\trecords.\n+\t(next_record_r): Likewise.\n+\t(sset): Likewise.\n+\t(next_record_w): Use gfc_offset/ptrdiff_t appropriately.\n+\n 2017-11-18  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/83036"}, {"sha": "c17344742b177a39e07518111804c7c17364bf7e", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2563a16d3c7a56cd1e0cfe9b4ccb702edfb12312/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2563a16d3c7a56cd1e0cfe9b4ccb702edfb12312/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=2563a16d3c7a56cd1e0cfe9b4ccb702edfb12312", "patch": "@@ -3290,7 +3290,7 @@ next_array_record (st_parameter_dt *dtp, array_loop_spec *ls, int *finished)\n    position.  */\n \n static void\n-skip_record (st_parameter_dt *dtp, ssize_t bytes)\n+skip_record (st_parameter_dt *dtp, gfc_offset bytes)\n {\n   ssize_t rlength, readb;\n #define MAX_READ 4096\n@@ -3367,7 +3367,6 @@ static void\n next_record_r (st_parameter_dt *dtp, int done)\n {\n   gfc_offset record;\n-  int bytes_left;\n   char p;\n   int cc;\n \n@@ -3419,7 +3418,7 @@ next_record_r (st_parameter_dt *dtp, int done)\n \t    }\n \t  else\n \t    {\n-\t      bytes_left = (int) dtp->u.p.current_unit->bytes_left;\n+\t      gfc_offset bytes_left = dtp->u.p.current_unit->bytes_left;\n \t      bytes_left = min_off (bytes_left,\n \t\t      ssize (dtp->u.p.current_unit->s)\n \t\t      - stell (dtp->u.p.current_unit->s));\n@@ -3590,12 +3589,13 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n /* Utility function like memset() but operating on streams. Return\n    value is same as for POSIX write().  */\n \n-static ssize_t\n-sset (stream *s, int c, ssize_t nbyte)\n+static gfc_offset\n+sset (stream *s, int c, gfc_offset nbyte)\n {\n #define WRITE_CHUNK 256\n   char p[WRITE_CHUNK];\n-  ssize_t bytes_left, trans;\n+  gfc_offset bytes_left;\n+  ssize_t trans;\n \n   if (nbyte < WRITE_CHUNK)\n     memset (p, c, nbyte);\n@@ -3645,11 +3645,10 @@ next_record_cc (st_parameter_dt *dtp)\n static void\n next_record_w (st_parameter_dt *dtp, int done)\n {\n-  gfc_offset m, record, max_pos;\n-  int length;\n+  gfc_offset max_pos_off;\n \n   /* Zero counters for X- and T-editing.  */\n-  max_pos = dtp->u.p.max_pos;\n+  max_pos_off = dtp->u.p.max_pos;\n   dtp->u.p.max_pos = dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n \n   switch (current_mode (dtp))\n@@ -3674,7 +3673,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n     case UNFORMATTED_DIRECT:\n       if (dtp->u.p.current_unit->bytes_left > 0)\n \t{\n-\t  length = (int) dtp->u.p.current_unit->bytes_left;\n+\t  gfc_offset length = dtp->u.p.current_unit->bytes_left;\n \t  if (sset (dtp->u.p.current_unit->s, 0, length) != length)\n \t    goto io_error;\n \t}\n@@ -3691,11 +3690,14 @@ next_record_w (st_parameter_dt *dtp, int done)\n       if (is_internal_unit (dtp))\n \t{\n \t  char *p;\n+\t  /* Internal unit, so must fit in memory.  */\n+\t  ptrdiff_t length, m, record;\n+\t  ptrdiff_t max_pos = max_pos_off;\n \t  if (is_array_io (dtp))\n \t    {\n \t      int finished;\n \n-\t      length = (int) dtp->u.p.current_unit->bytes_left;\n+\t      length = dtp->u.p.current_unit->bytes_left;\n \n \t      /* If the farthest position reached is greater than current\n \t      position, adjust the position and set length to pad out\n@@ -3705,14 +3707,14 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t\t- dtp->u.p.current_unit->bytes_left;\n \t      if (max_pos > m)\n \t\t{\n-\t\t  length = (int) (max_pos - m);\n+\t\t  length = (max_pos - m);\n \t\t  if (sseek (dtp->u.p.current_unit->s,\n \t\t\t     length, SEEK_CUR) < 0)\n \t\t    {\n \t\t      generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t      return;\n \t\t    }\n-\t\t  length = (int) (dtp->u.p.current_unit->recl - max_pos);\n+\t\t  length = ((ptrdiff_t) dtp->u.p.current_unit->recl - max_pos);\n \t\t}\n \n \t      p = write_block (dtp, length);\n@@ -3735,7 +3737,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\tdtp->u.p.current_unit->endfile = AT_ENDFILE;\n \n \t      /* Now seek to this record */\n-\t      record = record * dtp->u.p.current_unit->recl;\n+\t      record = record * ((ptrdiff_t) dtp->u.p.current_unit->recl);\n \n \t      if (sseek (dtp->u.p.current_unit->s, record, SEEK_SET) < 0)\n \t\t{\n@@ -3758,17 +3760,18 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t\t- dtp->u.p.current_unit->bytes_left;\n \t\t  if (max_pos > m)\n \t\t    {\n-\t\t      length = (int) (max_pos - m);\n+\t\t      length = max_pos - m;\n \t\t      if (sseek (dtp->u.p.current_unit->s,\n \t\t\t\t length, SEEK_CUR) < 0)\n \t\t        {\n \t\t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t\t  return;\n \t\t\t}\n-\t\t      length = (int) (dtp->u.p.current_unit->recl - max_pos);\n+\t\t      length = (ptrdiff_t) dtp->u.p.current_unit->recl\n+\t\t\t- max_pos;\n \t\t    }\n \t\t  else\n-\t\t    length = (int) dtp->u.p.current_unit->bytes_left;\n+\t\t    length = dtp->u.p.current_unit->bytes_left;\n \t\t}\n \t      if (length > 0)\n \t\t{"}]}