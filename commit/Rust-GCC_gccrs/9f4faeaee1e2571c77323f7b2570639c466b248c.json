{"sha": "9f4faeaee1e2571c77323f7b2570639c466b248c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY0ZmFlYWVlMWUyNTcxYzc3MzIzZjdiMjU3MDYzOWM0NjZiMjQ4Yw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-02-09T02:53:41Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-02-09T02:53:41Z"}, "message": "re PR c++/19733 (ICE on invalid destructor call)\n\n\tPR c++/19733\n\t* class.c (add_method): Don't set TYPE_HAS_DESTRUCTOR.\n\t(check_bases): Give warnings about a base class with a\n\tnon-virtual destructor, even if it is implicit.\n\t(finish_struct_bits): Don't copy TYPE_HAS_DESTRUCTOR.\n\t(maybe_warn_about_overly_private_class): Don't use\n\tTYPE_HAS_DESTRUCTOR.\n\t(finish_struct_methods): Don't set TYPE_HAS_DESTRUCTOR.\n\t(check_for_override): Give it external linkage.\n\t(add_implicitly_declared_members): Generate destructors lazily.\n\t(check_field_decls): Use TYPE_HAS_NONTRIVIAL_DESTRUCTOR, not\n\tTYPE_HAS_DESTRUCTOR.\n\t(check_bases_and_members): Call check_methods before\n\tcheck_field_decls.\n\t(check_bases_and_members): Use TYPE_HAS_NONTRIVIAL_DESTRUCTOR, not\n\tTYPE_HAS_DESTRUCTOR.\n\t(finish_struct_1): Do not use TYPE_HAS_DESTRUCTOR.\n\t* cp-tree.def (PSEUDO_DTOR_EXPR): Document.\n\t* cp-tree.h (TYPE_HAS_DESTRUCTOR): Remove.\n\t(lang_type_class): Add lazy_destructor.\n\t(CLASSTYPE_LAZY_DESTRUCTOR): New macro.\n\t(CLASSTYPE_DESTRUCTORS): Robustify.\n\t(TYPE_HAS_DESTRUCTOR): Remove.\n\t(check_for_override): Declare.\n\t(build_vbase_delete): Remove.\n\t* cvt.c (convert_to_void): Issue errors about pseudo-destructor\n\texpressions.\n\t* decl.c (cxx_maybe_build_cleanup): Remove dead code.\n\t* except.c (dtor_nothrow): Lazily create destructors if necessary.\n\t(build_throw): Use TYPE_HAS_NONTRIVIAL_DESTRUCTOR.\n\t* init.c (build_delete): Lazily create destructors, if necessary.\n\t(build_vbase_delete): Remove.\n\t* method.c (locate_dtor): Simplify.\n\t(implicitly_declare_fn): Add support for destructors.\n\t* parser.c (cp_parser_lookup_name): Lazily create destructors, if\n\tnecessary.\n\t* pt.c (check_explicit_specialization): Don't use\n\tTYPE_HAS_DESTRUCTOR.\n\t(instantiate_class_template): Likewise.\n\t* ptree.c (cxx_print_type): Don't print TYPE_HAS_DESTRUCTOR.\n\t* rtti.c (emit_support_tinfos): Robustify.\n\t* search.c (lookup_fnfields_1): Lazily create destructors.\n\t* typeck.c (build_class_member_access_expr): Remove\n\tPSEUDO_DTOR_EXPR handling.\n\t(lookup_destructor): Likewise.\n\n\tPR c++/19733\n\t* g++.dg/parse/crash23.C: New test.\n\t* g++.dg/warn/Weff1.C: New test.\n\nFrom-SVN: r94759", "tree": {"sha": "4a26d3c40b76aa9d12fd1b7d9aea782111229fc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a26d3c40b76aa9d12fd1b7d9aea782111229fc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f4faeaee1e2571c77323f7b2570639c466b248c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f4faeaee1e2571c77323f7b2570639c466b248c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f4faeaee1e2571c77323f7b2570639c466b248c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f4faeaee1e2571c77323f7b2570639c466b248c/comments", "author": null, "committer": null, "parents": [{"sha": "ec2cd8b20cb5c3fad017df6eb91a3210c3ec69f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec2cd8b20cb5c3fad017df6eb91a3210c3ec69f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec2cd8b20cb5c3fad017df6eb91a3210c3ec69f5"}], "stats": {"total": 376, "additions": 236, "deletions": 140}, "files": [{"sha": "dc5609f1a731e0bdef2a4ad50f7c235f7350d1c0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9f4faeaee1e2571c77323f7b2570639c466b248c", "patch": "@@ -1,3 +1,51 @@\n+2005-02-08  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/19733\n+\t* class.c (add_method): Don't set TYPE_HAS_DESTRUCTOR.\n+\t(check_bases): Give warnings about a base class with a\n+\tnon-virtual destructor, even if it is implicit.\n+\t(finish_struct_bits): Don't copy TYPE_HAS_DESTRUCTOR.\n+\t(maybe_warn_about_overly_private_class): Don't use\n+\tTYPE_HAS_DESTRUCTOR.\n+\t(finish_struct_methods): Don't set TYPE_HAS_DESTRUCTOR.\n+\t(check_for_override): Give it external linkage.\n+\t(add_implicitly_declared_members): Generate destructors lazily.\n+\t(check_field_decls): Use TYPE_HAS_NONTRIVIAL_DESTRUCTOR, not\n+\tTYPE_HAS_DESTRUCTOR.\n+\t(check_bases_and_members): Call check_methods before\n+\tcheck_field_decls.\n+\t(check_bases_and_members): Use TYPE_HAS_NONTRIVIAL_DESTRUCTOR, not\n+\tTYPE_HAS_DESTRUCTOR.\n+\t(finish_struct_1): Do not use TYPE_HAS_DESTRUCTOR.\n+\t* cp-tree.def (PSEUDO_DTOR_EXPR): Document.\n+\t* cp-tree.h (TYPE_HAS_DESTRUCTOR): Remove.\n+\t(lang_type_class): Add lazy_destructor.\n+\t(CLASSTYPE_LAZY_DESTRUCTOR): New macro.\n+\t(CLASSTYPE_DESTRUCTORS): Robustify.\n+\t(TYPE_HAS_DESTRUCTOR): Remove.\n+\t(check_for_override): Declare.\n+\t(build_vbase_delete): Remove.\n+\t* cvt.c (convert_to_void): Issue errors about pseudo-destructor\n+\texpressions.\n+\t* decl.c (cxx_maybe_build_cleanup): Remove dead code.\n+\t* except.c (dtor_nothrow): Lazily create destructors if necessary.\n+\t(build_throw): Use TYPE_HAS_NONTRIVIAL_DESTRUCTOR.\n+\t* init.c (build_delete): Lazily create destructors, if necessary.\n+\t(build_vbase_delete): Remove.\n+\t* method.c (locate_dtor): Simplify.\n+\t(implicitly_declare_fn): Add support for destructors.\n+\t* parser.c (cp_parser_lookup_name): Lazily create destructors, if\n+\tnecessary.\n+\t* pt.c (check_explicit_specialization): Don't use\n+\tTYPE_HAS_DESTRUCTOR.\n+\t(instantiate_class_template): Likewise.\n+\t* ptree.c (cxx_print_type): Don't print TYPE_HAS_DESTRUCTOR.\n+\t* rtti.c (emit_support_tinfos): Robustify.\n+\t* search.c (lookup_fnfields_1): Lazily create destructors.\n+\t* typeck.c (build_class_member_access_expr): Remove\n+\tPSEUDO_DTOR_EXPR handling.\n+\t(lookup_destructor): Likewise.\n+\n 2005-02-08  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* cxx-pretty-print.c, cxx-pretty-print.h, decl.h: Update"}, {"sha": "bfb9ee12237c9d2ecad9eb4f0124c66ad51b6814", "filename": "gcc/cp/class.c", "status": "modified", "additions": 85, "deletions": 75, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9f4faeaee1e2571c77323f7b2570639c466b248c", "patch": "@@ -116,7 +116,6 @@ static void modify_vtable_entry (tree, tree, tree, tree, tree *);\n static void finish_struct_bits (tree);\n static int alter_access (tree, tree, tree);\n static void handle_using_decl (tree, tree);\n-static void check_for_override (tree, tree);\n static tree dfs_modify_vtables (tree, void *);\n static tree modify_all_vtables (tree, tree);\n static void determine_primary_bases (tree);\n@@ -893,13 +892,16 @@ add_method (tree type, tree method)\n   else if (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (method))\n     {\n       slot = CLASSTYPE_DESTRUCTOR_SLOT;\n-      TYPE_HAS_DESTRUCTOR (type) = 1;\n       \n       if (TYPE_FOR_JAVA (type))\n-\terror (DECL_ARTIFICIAL (method)\n-\t       ? \"Java class %qT cannot have an implicit non-trivial destructor\"\n-\t       : \"Java class %qT cannot have a destructor\",\n-\t       DECL_CONTEXT (method));\n+\t{\n+\t  if (!DECL_ARTIFICIAL (method))\n+\t    error (\"Java class %qT cannot have a destructor\", type);\n+\t  else if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n+\t    error (\"Java class %qT cannot have an implicit non-trivial \"\n+\t\t   \"destructor\",\n+\t\t   type);\n+\t}\n     }\n   else\n     {\n@@ -1203,8 +1205,7 @@ check_bases (tree t,\n       /* Effective C++ rule 14.  We only need to check TYPE_POLYMORPHIC_P\n \t here because the case of virtual functions but non-virtual\n \t dtor is handled in finish_struct_1.  */\n-      if (warn_ecpp && ! TYPE_POLYMORPHIC_P (basetype)\n-\t  && TYPE_HAS_DESTRUCTOR (basetype))\n+      if (warn_ecpp && ! TYPE_POLYMORPHIC_P (basetype))\n \twarning (\"base class %q#T has a non-virtual destructor\", basetype);\n \n       /* If the base class doesn't have copy constructors or\n@@ -1406,7 +1407,6 @@ finish_struct_bits (tree t)\n       /* These fields are in the _TYPE part of the node, not in\n \t the TYPE_LANG_SPECIFIC component, so they are not shared.  */\n       TYPE_HAS_CONSTRUCTOR (variants) = TYPE_HAS_CONSTRUCTOR (t);\n-      TYPE_HAS_DESTRUCTOR (variants) = TYPE_HAS_DESTRUCTOR (t);\n       TYPE_NEEDS_CONSTRUCTING (variants) = TYPE_NEEDS_CONSTRUCTING (t);\n       TYPE_HAS_NONTRIVIAL_DESTRUCTOR (variants) \n \t= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t);\n@@ -1540,8 +1540,8 @@ maybe_warn_about_overly_private_class (tree t)\n   /* Even if some of the member functions are non-private, the class\n      won't be useful for much if all the constructors or destructors\n      are private: such an object can never be created or destroyed.  */\n-  if (TYPE_HAS_DESTRUCTOR (t)\n-      && TREE_PRIVATE (CLASSTYPE_DESTRUCTORS (t)))\n+  fn = CLASSTYPE_DESTRUCTORS (t);\n+  if (fn && TREE_PRIVATE (fn))\n     {\n       warning (\"%q#T only defines a private destructor and has no friends\",\n \t       t);\n@@ -1693,11 +1693,6 @@ finish_struct_methods (tree t)\n        fn_fields = TREE_CHAIN (fn_fields))\n     DECL_IN_AGGR_P (fn_fields) = 0;\n \n-  if (TYPE_HAS_DESTRUCTOR (t) && !CLASSTYPE_DESTRUCTORS (t))\n-    /* We thought there was a destructor, but there wasn't.  Some\n-       parse errors cause this anomalous situation.  */\n-    TYPE_HAS_DESTRUCTOR (t) = 0;\n-    \n   /* Issue warnings about private constructors and such.  If there are\n      no methods, then some public defaults are generated.  */\n   maybe_warn_about_overly_private_class (t);\n@@ -2284,7 +2279,7 @@ get_basefndecls (tree name, tree t)\n    a method declared virtual in the base class, then\n    mark this field as being virtual as well.  */\n \n-static void\n+void\n check_for_override (tree decl, tree ctype)\n {\n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n@@ -2465,35 +2460,61 @@ maybe_add_class_template_decl_list (tree type, tree t, int friend_p)\n    CANT_HAVE_CONST_ASSIGNMENT are nonzero if, for whatever reason, the\n    class cannot have a default constructor, copy constructor taking a\n    const reference argument, or an assignment operator taking a const\n-   reference, respectively.  If a virtual destructor is created, its\n-   DECL is returned; otherwise the return value is NULL_TREE.  */\n+   reference, respectively.  */\n \n static void\n add_implicitly_declared_members (tree t, \n                                  int cant_have_default_ctor,\n \t\t\t\t int cant_have_const_cctor,\n \t\t\t\t int cant_have_const_assignment)\n {\n-  tree default_fn;\n-  tree implicit_fns = NULL_TREE;\n-  tree virtual_dtor = NULL_TREE;\n-  tree *f;\n-\n   /* Destructor.  */\n-  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) && !TYPE_HAS_DESTRUCTOR (t))\n+  if (!CLASSTYPE_DESTRUCTORS (t))\n     {\n-      default_fn = implicitly_declare_fn (sfk_destructor, t, /*const_p=*/0);\n-      check_for_override (default_fn, t);\n+      /* In general, we create destructors lazily.  */\n+      CLASSTYPE_LAZY_DESTRUCTOR (t) = 1;\n+      /* However, if the implicit destructor is non-trivial\n+\t destructor, we sometimes have to create it at this point.  */\n+      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t))\n+\t{\n+\t  bool lazy_p = true;\n \n-      TREE_CHAIN (default_fn) = implicit_fns;\n-      implicit_fns = default_fn;\n-      \n-      if (DECL_VINDEX (default_fn))\n-\tvirtual_dtor = default_fn;\n+\t  if (TYPE_FOR_JAVA (t))\n+\t    /* If this a Java class, any non-trivial destructor is\n+\t       invalid, even if compiler-generated.  Therefore, if the\n+\t       destructor is non-trivial we create it now.  */\n+\t    lazy_p = false;\n+\t  else\n+\t    {\n+\t      tree binfo;\n+\t      tree base_binfo;\n+\t      int ix;\n+\n+\t      /* If the implicit destructor will be virtual, then we must\n+\t\t generate it now because (unfortunately) we do not\n+\t\t generate virtual tables lazily.  */\n+\t      binfo = TYPE_BINFO (t);\n+\t      for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ix++)\n+\t\t{\n+\t\t  tree base_type;\n+\t\t  tree dtor;\n+\n+\t\t  base_type = BINFO_TYPE (base_binfo);\n+\t\t  dtor = CLASSTYPE_DESTRUCTORS (base_type);\n+\t\t  if (dtor && DECL_VIRTUAL_P (dtor))\n+\t\t    {\n+\t\t      lazy_p = false;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  /* If we can't get away with being lazy, generate the destructor\n+\t     now.  */ \n+\t  if (!lazy_p)\n+\t    lazily_declare_fn (sfk_destructor, t);\n+\t}\n     }\n-  else\n-    /* Any non-implicit destructor is non-trivial.  */\n-    TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) |= TYPE_HAS_DESTRUCTOR (t);\n \n   /* Default constructor.  */\n   if (! TYPE_HAS_CONSTRUCTOR (t) && ! cant_have_default_ctor)\n@@ -2521,29 +2542,6 @@ add_implicitly_declared_members (tree t,\n       TYPE_HAS_CONST_ASSIGN_REF (t) = !cant_have_const_assignment;\n       CLASSTYPE_LAZY_ASSIGNMENT_OP (t) = 1;\n     }\n-  \n-  /* Now, hook all of the new functions on to TYPE_METHODS,\n-     and add them to the CLASSTYPE_METHOD_VEC.  */\n-  for (f = &implicit_fns; *f; f = &TREE_CHAIN (*f))\n-    {\n-      add_method (t, *f);\n-      maybe_add_class_template_decl_list (current_class_type, *f, /*friend_p=*/0);\n-    }\n-  if (abi_version_at_least (2))\n-    /* G++ 3.2 put the implicit destructor at the *beginning* of the\n-       list, which cause the destructor to be emitted in an incorrect\n-       location in the vtable.  */\n-    TYPE_METHODS (t) = chainon (TYPE_METHODS (t), implicit_fns);\n-  else\n-    {\n-      if (warn_abi && virtual_dtor)\n-\twarning (\"vtable layout for class %qT may not be ABI-compliant \"\n-\t\t \"and may change in a future version of GCC due to implicit \"\n-\t\t \"virtual destructor\",\n-\t\t t);\n-      *f = TYPE_METHODS (t);\n-      TYPE_METHODS (t) = implicit_fns;\n-    }\n }\n \n /* Subroutine of finish_struct_1.  Recursively count the number of fields\n@@ -3012,7 +3010,7 @@ check_field_decls (tree t, tree *access_decls,\n     if (warn_ecpp\n \t&& has_pointers\n \t&& TYPE_HAS_CONSTRUCTOR (t)\n-\t&& TYPE_HAS_DESTRUCTOR (t)\n+\t&& TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n \t&& !(TYPE_HAS_INIT_REF (t) && TYPE_HAS_ASSIGN_REF (t)))\n     {\n       warning (\"%q#T has pointer data members\", t);\n@@ -3660,6 +3658,9 @@ check_methods (tree t)\n \t  if (DECL_PURE_VIRTUAL_P (x))\n \t    VEC_safe_push (tree, CLASSTYPE_PURE_VIRTUALS (t), x);\n \t}\n+      /* All user-declared destructors are non-trivial.  */\n+      if (DECL_DESTRUCTOR_P (x))\n+\tTYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) = 1;\n     }\n }\n \n@@ -4034,15 +4035,18 @@ check_bases_and_members (tree t)\n   check_bases (t, &cant_have_default_ctor, &cant_have_const_ctor,\n \t       &no_const_asn_ref);\n \n-  /* Check all the data member declarations.  */\n+  /* Check all the method declarations.  */\n+  check_methods (t);\n+\n+  /* Check all the data member declarations.  We cannot call\n+     check_field_decls until we have called check_bases check_methods,\n+     as check_field_decls depends on TYPE_HAS_NONTRIVIAL_DESTRUCTOR\n+     being set appropriately.  */\n   check_field_decls (t, &access_decls,\n \t\t     &cant_have_default_ctor,\n \t\t     &cant_have_const_ctor,\n \t\t     &no_const_asn_ref);\n \n-  /* Check all the method declarations.  */\n-  check_methods (t);\n-\n   /* A nearly-empty class has to be vptr-containing; a nearly empty\n      class contains just a vptr.  */\n   if (!TYPE_CONTAINS_VPTR_P (t))\n@@ -4057,7 +4061,8 @@ check_bases_and_members (tree t)\n   CLASSTYPE_NON_AGGREGATE (t)\n     |= (TYPE_HAS_CONSTRUCTOR (t) || TYPE_POLYMORPHIC_P (t));\n   CLASSTYPE_NON_POD_P (t)\n-    |= (CLASSTYPE_NON_AGGREGATE (t) || TYPE_HAS_DESTRUCTOR (t) \n+    |= (CLASSTYPE_NON_AGGREGATE (t) \n+\t|| TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n \t|| TYPE_HAS_ASSIGN_REF (t));\n   TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n     |= TYPE_HAS_ASSIGN_REF (t) || TYPE_CONTAINS_VPTR_P (t);\n@@ -5007,17 +5012,22 @@ finish_struct_1 (tree t)\n   /* Build the VTT for T.  */\n   build_vtt (t);\n \n-  if (warn_nonvdtor && TYPE_POLYMORPHIC_P (t) && TYPE_HAS_DESTRUCTOR (t)\n-      && !DECL_VINDEX (CLASSTYPE_DESTRUCTORS (t)))\n-\n-    {\n-      tree dtor = CLASSTYPE_DESTRUCTORS (t);\n-\n-      /* Warn only if the dtor is non-private or the class has friends */\n-      if (!TREE_PRIVATE (dtor) ||\n-\t  (CLASSTYPE_FRIEND_CLASSES (t) ||\n-\t   DECL_FRIENDLIST (TYPE_MAIN_DECL (t))))\n-\twarning (\"%q#T has virtual functions but non-virtual destructor\", t);\n+  if (warn_nonvdtor && TYPE_POLYMORPHIC_P (t))\n+    {\n+      tree dtor;\n+\n+      dtor = CLASSTYPE_DESTRUCTORS (t);\n+      /* Warn only if the dtor is non-private or the class has\n+\t friends.  */\n+      if (/* An implicitly declared destructor is always public.  And,\n+\t     if it were virtual, we would have created it by now.  */\n+\t  !dtor\n+\t  || (!DECL_VINDEX (dtor)\n+\t      && (!TREE_PRIVATE (dtor) \n+\t\t  || CLASSTYPE_FRIEND_CLASSES (t) \n+\t\t  || DECL_FRIENDLIST (TYPE_MAIN_DECL (t)))))\n+\twarning (\"%q#T has virtual functions but non-virtual destructor\", \n+\t\t t);\n     }\n \n   complete_vars (t);"}, {"sha": "bc606dba4ffcfd0e41c67cab851e4797800a7b69", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=9f4faeaee1e2571c77323f7b2570639c466b248c", "patch": "@@ -222,6 +222,18 @@ DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", tcc_expression, 2)\n    the original name, and the parameter is the FUNCTION_DECL.  */\n DEFTREECODE (OVERLOAD, \"overload\", tcc_exceptional, 0)\n \n+/* A pseudo-destructor, of the form \"OBJECT.~DESTRUCTOR\" or\n+   \"OBJECT.SCOPE::~DESTRUCTOR.  The first operand is the OBJECT.  The\n+   second operand (if non-NULL) is the SCOPE.  The third operand is\n+   the TYPE node corresponding to the DESTRUCTOR.  The type of the\n+   first operand will always be a scalar type. \n+\n+   The type of a PSEUDO_DTOR_EXPR is always \"void\", even though it can\n+   be used as if it were a zero-argument function.  We handle the\n+   function-call case specially, and giving it \"void\" type prevents it\n+   being used in expressions in ways that are not permitted.  */  \n+DEFTREECODE (PSEUDO_DTOR_EXPR, \"pseudo_dtor_expr\", tcc_expression, 3)\n+\n /* A whole bunch of tree codes for the initial, superficial parsing of\n    templates.  */\n DEFTREECODE (MODOP_EXPR, \"modop_expr\", tcc_expression, 3)\n@@ -232,7 +244,6 @@ DEFTREECODE (STATIC_CAST_EXPR, \"static_cast_expr\", tcc_unary, 1)\n DEFTREECODE (DYNAMIC_CAST_EXPR, \"dynamic_cast_expr\", tcc_unary, 1)\n DEFTREECODE (DOTSTAR_EXPR, \"dotstar_expr\", tcc_expression, 2)\n DEFTREECODE (TYPEID_EXPR, \"typeid_expr\", tcc_expression, 1)\n-DEFTREECODE (PSEUDO_DTOR_EXPR, \"pseudo_dtor_expr\", tcc_expression, 3)\n \n /* A placeholder for an expression that is not type-dependent, but\n    does occur in a template.  When an expression that is not"}, {"sha": "0b4959ba37302b5b40b813f6753c4538411a156e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9f4faeaee1e2571c77323f7b2570639c466b248c", "patch": "@@ -80,7 +80,7 @@ struct diagnostic_context;\n    Usage of TYPE_LANG_FLAG_?:\n    0: TYPE_DEPENDENT_P\n    1: TYPE_HAS_CONSTRUCTOR.\n-   2: TYPE_HAS_DESTRUCTOR.\n+   2: Unused\n    3: TYPE_FOR_JAVA.\n    4: TYPE_HAS_NONTRIVIAL_DESTRUCTOR\n    5: IS_AGGR_TYPE.\n@@ -1035,8 +1035,9 @@ struct lang_type_class GTY(())\n   unsigned lazy_default_ctor : 1;\n   unsigned lazy_copy_ctor : 1;\n   unsigned lazy_assignment_op : 1;\n+  unsigned lazy_destructor : 1;\n+\n   unsigned has_const_init_ref : 1;\n-  \n   unsigned has_complex_init_ref : 1;\n   unsigned has_complex_assign_ref : 1;\n   unsigned non_aggregate : 1;\n@@ -1049,7 +1050,7 @@ struct lang_type_class GTY(())\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 12;\n+  unsigned dummy : 11;\n \n   tree primary_base;\n   VEC (tree_pair_s) *vcall_indices;\n@@ -1153,6 +1154,11 @@ struct lang_type GTY(())\n #define CLASSTYPE_LAZY_ASSIGNMENT_OP(NODE) \\\n   (LANG_TYPE_CLASS_CHECK (NODE)->lazy_assignment_op)\n \n+/* Nonzero means that NODE (a class type) has a destructor -- but that\n+   it has not yet been declared.  */\n+#define CLASSTYPE_LAZY_DESTRUCTOR(NODE) \\\n+  (LANG_TYPE_CLASS_CHECK (NODE)->lazy_destructor)\n+ \n /* Nonzero means that this _CLASSTYPE node overloads operator=(X&).  */\n #define TYPE_HAS_ASSIGN_REF(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->has_assign_ref)\n \n@@ -1236,9 +1242,13 @@ struct lang_type GTY(())\n   (VEC_index (tree, CLASSTYPE_METHOD_VEC (NODE), CLASSTYPE_CONSTRUCTOR_SLOT))\n \n /* A FUNCTION_DECL for the destructor for NODE.  These are the\n-   destructors that take an in-charge parameter.  */\n+   destructors that take an in-charge parameter.  If\n+   CLASSTYPE_LAZY_DESTRUCTOR is true, then this entry will be NULL\n+   until the destructor is created with lazily_declare_fn.  */\n #define CLASSTYPE_DESTRUCTORS(NODE) \\\n-  (VEC_index (tree, CLASSTYPE_METHOD_VEC (NODE), CLASSTYPE_DESTRUCTOR_SLOT))\n+  (CLASSTYPE_METHOD_VEC (NODE)\t\t\t\t\t\t      \\\n+   ? VEC_index (tree, CLASSTYPE_METHOD_VEC (NODE), CLASSTYPE_DESTRUCTOR_SLOT) \\\n+   : NULL_TREE)\n \n /* A dictionary of the nested user-defined-types (class-types, or enums)\n    found within this class.  This table includes nested member class\n@@ -2412,9 +2422,6 @@ struct lang_decl GTY(())\n \t\t\t\t   && CONSTRUCTOR_ELTS (NODE) == NULL_TREE \\\n \t\t\t\t   && ! TREE_HAS_CONSTRUCTOR (NODE))\n \n-/* Nonzero for _TYPE means that the _TYPE defines a destructor.  */\n-#define TYPE_HAS_DESTRUCTOR(NODE) (TYPE_LANG_FLAG_2 (NODE))\n-\n /* Nonzero means that an object of this type can not be initialized using\n    an initializer list.  */\n #define CLASSTYPE_NON_AGGREGATE(NODE) \\\n@@ -3721,6 +3728,7 @@ extern void debug_thunks \t\t\t(tree);\n extern tree cp_fold_obj_type_ref\t\t(tree, tree);\n extern void set_linkage_according_to_type       (tree, tree);\n extern void determine_key_method                (tree);\n+extern void check_for_override                  (tree, tree);\n \n /* in cvt.c */\n extern tree convert_to_reference (tree, tree, int, int, tree);\n@@ -3924,7 +3932,6 @@ extern tree build_vec_init\t\t\t(tree, tree, tree, int);\n extern tree build_x_delete\t\t\t(tree, int, tree);\n extern tree build_delete\t\t\t(tree, tree, special_function_kind, int, int);\n extern void push_base_cleanups\t\t\t(void);\n-extern tree build_vbase_delete\t\t\t(tree, tree);\n extern tree build_vec_delete\t\t\t(tree, tree, special_function_kind, int);\n extern tree create_temporary_var                (tree);\n extern void initialize_vtbl_ptrs                (tree);"}, {"sha": "32dc96d10c66f83ee7376b2b5ca797afe8ffb098", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=9f4faeaee1e2571c77323f7b2570639c466b248c", "patch": "@@ -793,6 +793,11 @@ convert_to_void (tree expr, const char *implicit)\n     return expr;\n   if (invalid_nonstatic_memfn_p (expr))\n     return error_mark_node;\n+  if (TREE_CODE (expr) == PSEUDO_DTOR_EXPR)\n+    {\n+      error (\"pseudo-destructor is not called\");\n+      return error_mark_node;\n+    }\n   if (VOID_TYPE_P (TREE_TYPE (expr)))\n     return expr;\n   switch (TREE_CODE (expr))"}, {"sha": "4d8059fc46adda4dadb9c99791f2f349ecdadfa9", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9f4faeaee1e2571c77323f7b2570639c466b248c", "patch": "@@ -10929,9 +10929,6 @@ cxx_maybe_build_cleanup (tree decl)\n       rval = build_delete (TREE_TYPE (rval), rval,\n \t\t\t   sfk_complete_destructor, flags, 0);\n \n-      if (has_vbases && !TYPE_HAS_DESTRUCTOR (type))\n-\trval = build_compound_expr (rval, build_vbase_delete (type, decl));\n-\n       return rval;\n     }\n   return NULL_TREE;"}, {"sha": "44521e3ab8d07c29f08e2cb23e0781d250a0eca7", "filename": "gcc/cp/except.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=9f4faeaee1e2571c77323f7b2570639c466b248c", "patch": "@@ -182,9 +182,12 @@ dtor_nothrow (tree type)\n   if (type == NULL_TREE)\n     return 0;\n \n-  if (! TYPE_HAS_DESTRUCTOR (type))\n+  if (!CLASS_TYPE_P (type))\n     return 1;\n \n+  if (CLASSTYPE_LAZY_DESTRUCTOR (type))\n+    lazily_declare_fn (sfk_destructor, type);\n+\n   return TREE_NOTHROW (CLASSTYPE_DESTRUCTORS (type));\n }\n \n@@ -709,7 +712,7 @@ build_throw (tree exp)\n \n       throw_type = build_eh_type_type (prepare_eh_type (TREE_TYPE (object)));\n \n-      if (TYPE_HAS_DESTRUCTOR (TREE_TYPE (object)))\n+      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (object)))\n \t{\n \t  cleanup = lookup_fnfields (TYPE_BINFO (TREE_TYPE (object)),\n \t\t\t\t     complete_dtor_identifier, 0);"}, {"sha": "4ad5e62c4acdda75b6707747ea3882897ae23746", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 29, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=9f4faeaee1e2571c77323f7b2570639c466b248c", "patch": "@@ -2796,7 +2796,8 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n       tree do_delete = NULL_TREE;\n       tree ifexp;\n \n-      gcc_assert (TYPE_HAS_DESTRUCTOR (type));\n+      if (CLASSTYPE_LAZY_DESTRUCTOR (type))\n+\tlazily_declare_fn (sfk_destructor, type);\n \n       /* For `::delete x', we must not use the deleting destructor\n \t since then we would not be sure to get the global `operator\n@@ -2935,34 +2936,6 @@ push_base_cleanups (void)\n     }\n }\n \n-/* For type TYPE, delete the virtual baseclass objects of DECL.  */\n-\n-tree\n-build_vbase_delete (tree type, tree decl)\n-{\n-  unsigned ix;\n-  tree binfo;\n-  tree result;\n-  VEC (tree) *vbases;\n-  tree addr = build_unary_op (ADDR_EXPR, decl, 0);\n-\n-  gcc_assert (addr != error_mark_node);\n-\n-  result = convert_to_void (integer_zero_node, NULL);\n-  for (vbases = CLASSTYPE_VBASECLASSES (type), ix = 0;\n-       VEC_iterate (tree, vbases, ix, binfo); ix++)\n-    {\n-      tree base_addr = convert_force\n-\t(build_pointer_type (BINFO_TYPE (binfo)), addr, 0);\n-      tree base_delete = build_delete\n-\t(TREE_TYPE (base_addr), base_addr, sfk_base_destructor,\n-\t LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 0);\n-      \n-      result = build_compound_expr (result, base_delete);\n-    }\n-  return result;\n-}\n-\n /* Build a C++ vector delete expression.\n    MAXINDEX is the number of elements to be deleted.\n    ELT_SIZE is the nominal size of each element in the vector."}, {"sha": "fadbf3911d3fad3892e6c6034032cc84cf29b988", "filename": "gcc/cp/method.c", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=9f4faeaee1e2571c77323f7b2570639c466b248c", "patch": "@@ -823,9 +823,7 @@ synthesize_exception_spec (tree type, tree (*extractor) (tree, void*),\n static tree\n locate_dtor (tree type, void *client ATTRIBUTE_UNUSED)\n {\n-  return (CLASSTYPE_METHOD_VEC (type) \n-\t  ? CLASSTYPE_DESTRUCTORS (type) \n-\t  : NULL_TREE);\n+  return CLASSTYPE_DESTRUCTORS (type);\n }\n \n /* Locate the default ctor of TYPE.  */\n@@ -1035,7 +1033,7 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n   DECL_DECLARED_INLINE_P (fn) = 1;\n   DECL_INLINE (fn) = 1;\n   gcc_assert (!TREE_USED (fn));\n-  \n+\n   return fn;\n }\n \n@@ -1060,24 +1058,46 @@ lazily_declare_fn (special_function_kind sfk, tree type)\n     const_p = false;\n   /* Declare the function.  */\n   fn = implicitly_declare_fn (sfk, type, const_p);\n+  /* A destructor may be virtual.  */\n+  if (sfk == sfk_destructor)\n+    check_for_override (fn, type);\n   /* Add it to CLASSTYPE_METHOD_VEC.  */\n   add_method (type, fn);\n   /* Add it to TYPE_METHODS.  */\n-  TREE_CHAIN (fn) = TYPE_METHODS (type);\n-  TYPE_METHODS (type) = fn;\n+  if (sfk == sfk_destructor \n+      && DECL_VIRTUAL_P (fn)\n+      && abi_version_at_least (2))\n+    /* The ABI requires that a virtual destructor go at the end of the\n+       vtable.  */\n+    TYPE_METHODS (type) = chainon (TYPE_METHODS (type), fn);\n+  else\n+    {\n+      /* G++ 3.2 put the implicit destructor at the *beginning* of the\n+\t TYPE_METHODS list, which cause the destructor to be emitted\n+\t in an incorrect location in the vtable.  */ \n+      if (warn_abi && DECL_VIRTUAL_P (fn))\n+\twarning (\"vtable layout for class %qT may not be ABI-compliant\"\n+\t\t \"and may change in a future version of GCC due to \"\n+\t\t \"implicit virtual destructor\",\n+\t\t type);\n+      TREE_CHAIN (fn) = TYPE_METHODS (type);\n+      TYPE_METHODS (type) = fn;\n+    }\n   maybe_add_class_template_decl_list (type, fn, /*friend_p=*/0);\n-  if (sfk == sfk_constructor || sfk == sfk_copy_constructor)\n+  if (sfk == sfk_assignment_operator)\n+    CLASSTYPE_LAZY_ASSIGNMENT_OP (type) = 0;\n+  else\n     {\n       /* Remember that the function has been created.  */\n       if (sfk == sfk_constructor)\n \tCLASSTYPE_LAZY_DEFAULT_CTOR (type) = 0;\n-      else\n+      else if (sfk == sfk_copy_constructor)\n \tCLASSTYPE_LAZY_COPY_CTOR (type) = 0;\n+      else if (sfk == sfk_destructor)\n+\tCLASSTYPE_LAZY_DESTRUCTOR (type) = 0;\n       /* Create appropriate clones.  */\n       clone_function_decl (fn, /*update_method_vec=*/true);\n     }\n-  else if (sfk == sfk_assignment_operator)\n-    CLASSTYPE_LAZY_ASSIGNMENT_OP (type) = 0;\n \n   return fn;\n }"}, {"sha": "6e797532153bc79e5e5e7638a8c1ba012549a144", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9f4faeaee1e2571c77323f7b2570639c466b248c", "patch": "@@ -14252,6 +14252,8 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n       /* If that's not a class type, there is no destructor.  */\n       if (!type || !CLASS_TYPE_P (type))\n \treturn error_mark_node;\n+      if (CLASSTYPE_LAZY_DESTRUCTOR (type))\n+\tlazily_declare_fn (sfk_destructor, type);\n       if (!CLASSTYPE_DESTRUCTORS (type))\n \t  return error_mark_node;\n       /* If it was a class type, return the destructor.  */"}, {"sha": "dbe560b860642dcc1b99d57b29825d2081f4c355", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9f4faeaee1e2571c77323f7b2570639c466b248c", "patch": "@@ -1932,7 +1932,7 @@ check_explicit_specialization (tree declarator,\n \t      int is_constructor = DECL_CONSTRUCTOR_P (decl);\n \t      \n \t      if (is_constructor ? !TYPE_HAS_CONSTRUCTOR (ctype)\n-\t\t  : !TYPE_HAS_DESTRUCTOR (ctype))\n+\t\t  : !CLASSTYPE_DESTRUCTORS (ctype))\n \t\t{\n \t\t  /* From [temp.expl.spec]:\n \t\t       \n@@ -5541,7 +5541,6 @@ instantiate_class_template (tree type)\n   input_location = DECL_SOURCE_LOCATION (TYPE_NAME (pattern));\n \n   TYPE_HAS_CONSTRUCTOR (type) = TYPE_HAS_CONSTRUCTOR (pattern);\n-  TYPE_HAS_DESTRUCTOR (type) = TYPE_HAS_DESTRUCTOR (pattern);\n   TYPE_HAS_NEW_OPERATOR (type) = TYPE_HAS_NEW_OPERATOR (pattern);\n   TYPE_HAS_ARRAY_NEW_OPERATOR (type) = TYPE_HAS_ARRAY_NEW_OPERATOR (pattern);\n   TYPE_GETS_DELETE (type) = TYPE_GETS_DELETE (pattern);"}, {"sha": "d33ad9f7e25a940393c7cbc2a5ae703977cdf1cd", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=9f4faeaee1e2571c77323f7b2570639c466b248c", "patch": "@@ -100,8 +100,6 @@ cxx_print_type (FILE *file, tree node, int indent)\n     fputs ( \"needs-constructor\", file);\n   if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (node))\n     fputs (\" needs-destructor\", file);\n-  if (TYPE_HAS_DESTRUCTOR (node))\n-    fputs (\" ~X()\", file);\n   if (TYPE_HAS_DEFAULT_CONSTRUCTOR (node))\n     fputs (\" X()\", file);\n   if (TYPE_HAS_CONVERSION (node))"}, {"sha": "a08a3ee5cb755e0691ff26cec29f8fc2f1cd6531", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=9f4faeaee1e2571c77323f7b2570639c466b248c", "patch": "@@ -1342,7 +1342,7 @@ emit_support_tinfos (void)\n   if (!COMPLETE_TYPE_P (bltn_type))\n     return;\n   dtor = CLASSTYPE_DESTRUCTORS (bltn_type);\n-  if (DECL_EXTERNAL (dtor))\n+  if (!dtor || DECL_EXTERNAL (dtor))\n     return;\n   doing_runtime = 1;\n   for (ix = 0; fundamentals[ix]; ix++)"}, {"sha": "a0cb0ff0bc143dad02005062ca259cc8687fd8f7", "filename": "gcc/cp/search.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=9f4faeaee1e2571c77323f7b2570639c466b248c", "patch": "@@ -1367,6 +1367,12 @@ lookup_fnfields_1 (tree type, tree name)\n       else if (name == ansi_assopname(NOP_EXPR)\n \t       && CLASSTYPE_LAZY_ASSIGNMENT_OP (type))\n \tlazily_declare_fn (sfk_assignment_operator, type);\n+      else if ((name == dtor_identifier\n+\t\t|| name == base_dtor_identifier\n+\t\t|| name == complete_dtor_identifier\n+\t\t|| name == deleting_dtor_identifier)\n+\t       && CLASSTYPE_LAZY_DESTRUCTOR (type))\n+\tlazily_declare_fn (sfk_destructor, type);\n     }\n \n   method_vec = CLASSTYPE_METHOD_VEC (type);"}, {"sha": "2badcc274940ec4861f6672bc9375f7685f74067", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9f4faeaee1e2571c77323f7b2570639c466b248c", "patch": "@@ -1577,9 +1577,6 @@ build_class_member_access_expr (tree object, tree member,\n   if (object == error_mark_node || member == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (member) == PSEUDO_DTOR_EXPR)\n-    return member;\n-\n   gcc_assert (DECL_P (member) || BASELINK_P (member));\n \n   /* [expr.ref]\n@@ -1822,9 +1819,6 @@ lookup_destructor (tree object, tree scope, tree dtor_name)\n \t     TYPE_MAIN_VARIANT (object_type), dtor_type);\n       return error_mark_node;\n     }\n-  if (!TYPE_HAS_DESTRUCTOR (dtor_type))\n-    return build3 (PSEUDO_DTOR_EXPR, void_type_node, object, scope,\n-\t\t   dtor_type);\n   expr = lookup_member (dtor_type, complete_dtor_identifier,\n \t\t\t/*protect=*/1, /*want_type=*/false);\n   expr = (adjust_result_of_qualified_name_lookup"}, {"sha": "0067f19a1233fe29cdb8b8cbd61fcbd5f1f96f85", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9f4faeaee1e2571c77323f7b2570639c466b248c", "patch": "@@ -1,3 +1,9 @@\n+2005-02-08  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/19733\n+\t* g++.dg/parse/crash23.C: New test.\n+\t* g++.dg/warn/Weff1.C: New test.\n+\n 2005-02-09  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/20050209-1.c: New test."}, {"sha": "19ad70a64547f9de9e54d499de1d1619bc813f50", "filename": "gcc/testsuite/g++.dg/parse/crash23.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash23.C?ref=9f4faeaee1e2571c77323f7b2570639c466b248c", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/19733\n+\n+struct A {};\n+typedef int I;\n+void foo() {\n+  A().~A; // { dg-error \"\" }\n+  A().A::~A; // { dg-error \"\" }\n+  (int().I::~I, 3); // { dg-error \"\" }\n+  int().I::~I; // { dg-error \"\" }\n+}\n+\n+  "}, {"sha": "a00dc29bf5f572e7a4b0feb183e6e3e99453ed41", "filename": "gcc/testsuite/g++.dg/warn/Weff1.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWeff1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f4faeaee1e2571c77323f7b2570639c466b248c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWeff1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWeff1.C?ref=9f4faeaee1e2571c77323f7b2570639c466b248c", "patch": "@@ -0,0 +1,5 @@\n+// { dg-options \"-Weffc++\" }\n+\n+struct S {};\n+/* Base classes should have virtual destructors.  */\n+struct T : public S {}; // { dg-warning \"\" }"}]}