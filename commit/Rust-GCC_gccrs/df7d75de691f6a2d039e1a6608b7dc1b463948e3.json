{"sha": "df7d75de691f6a2d039e1a6608b7dc1b463948e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY3ZDc1ZGU2OTFmNmEyZDAzOWUxYTY2MDhiN2RjMWI0NjM5NDhlMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-07-28T11:11:09Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-07-28T11:11:09Z"}, "message": "(try_combine): Don't make a MULT if none of the insns in our input had one.\n\nFrom-SVN: r7803", "tree": {"sha": "33e43ed9a7ab4e263278761de3edc761942c15c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33e43ed9a7ab4e263278761de3edc761942c15c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df7d75de691f6a2d039e1a6608b7dc1b463948e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df7d75de691f6a2d039e1a6608b7dc1b463948e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df7d75de691f6a2d039e1a6608b7dc1b463948e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df7d75de691f6a2d039e1a6608b7dc1b463948e3/comments", "author": null, "committer": null, "parents": [{"sha": "98310eaac7db6d1f1e07a30f3f9970ec1c6e2305", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98310eaac7db6d1f1e07a30f3f9970ec1c6e2305", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98310eaac7db6d1f1e07a30f3f9970ec1c6e2305"}], "stats": {"total": 38, "additions": 28, "deletions": 10}, "files": [{"sha": "5358cd0852aeedb4cb181205a9026b8ac68bee34", "filename": "gcc/combine.c", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7d75de691f6a2d039e1a6608b7dc1b463948e3/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7d75de691f6a2d039e1a6608b7dc1b463948e3/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=df7d75de691f6a2d039e1a6608b7dc1b463948e3", "patch": "@@ -1203,6 +1203,8 @@ try_combine (i3, i2, i1)\n   rtx new_i3_notes, new_i2_notes;\n   /* Notes that we substituted I3 into I2 instead of the normal case.  */\n   int i3_subst_into_i2 = 0;\n+  /* Notes that I1, I2 or I3 is a MULT operation.  */\n+  int have_mult = 0;\n \n   int maxreg;\n   rtx temp;\n@@ -1392,6 +1394,15 @@ try_combine (i3, i2, i1)\n       return 0;\n     }\n \n+  /* See if any of the insns is a MULT operation.  Unless one is, we will\n+     reject a combination that is, since it must be slower.  Be conservative\n+     here.  */\n+  if (GET_CODE (i2src) == MULT\n+      || (i1 != 0 && GET_CODE (i1src) == MULT)\n+      || (GET_CODE (PATTERN (i3)) == SET\n+\t  && GET_CODE (SET_SRC (PATTERN (i3))) == MULT))\n+    have_mult = 1;\n+\n   /* If I3 has an inc, then give up if I1 or I2 uses the reg that is inc'd.\n      We used to do this EXCEPT in one case: I3 has a post-inc in an\n      output operand.  However, that exception can give rise to insns like\n@@ -1601,7 +1612,11 @@ try_combine (i3, i2, i1)\n \t really no reason to).  */\n       || max_reg_num () != maxreg\n       /* Fail if we couldn't do something and have a CLOBBER.  */\n-      || GET_CODE (newpat) == CLOBBER)\n+      || GET_CODE (newpat) == CLOBBER\n+      /* Fail if this new pattern is a MULT and we didn't have one before\n+\t at the outer level.  */\n+      || (GET_CODE (newpat) == SET && GET_CODE (SET_SRC (newpat)) == MULT\n+\t  && ! have_mult))\n     {\n       undo_all ();\n       return 0;\n@@ -1804,13 +1819,14 @@ try_combine (i3, i2, i1)\n \t  && ! reg_referenced_p (i2dest, newpat))\n \t{\n \t  rtx newdest = i2dest;\n+\t  enum rtx_code split_code = GET_CODE (*split);\n+\t  enum machine_mode split_mode = GET_MODE (*split);\n \n \t  /* Get NEWDEST as a register in the proper mode.  We have already\n \t     validated that we can do this.  */\n-\t  if (GET_MODE (i2dest) != GET_MODE (*split)\n-\t      && GET_MODE (*split) != VOIDmode)\n+\t  if (GET_MODE (i2dest) != split_mode && split_mode != VOIDmode)\n \t    {\n-\t      newdest = gen_rtx (REG, GET_MODE (*split), REGNO (i2dest));\n+\t      newdest = gen_rtx (REG, split_mode, REGNO (i2dest));\n \n \t      if (REGNO (i2dest) >= FIRST_PSEUDO_REGISTER)\n \t\tSUBST (regno_reg_rtx[REGNO (i2dest)], newdest);\n@@ -1819,25 +1835,27 @@ try_combine (i3, i2, i1)\n \t  /* If *SPLIT is a (mult FOO (const_int pow2)), convert it to\n \t     an ASHIFT.  This can occur if it was inside a PLUS and hence\n \t     appeared to be a memory address.  This is a kludge.  */\n-\t  if (GET_CODE (*split) == MULT\n+\t  if (split_code == MULT\n \t      && GET_CODE (XEXP (*split, 1)) == CONST_INT\n \t      && (i = exact_log2 (INTVAL (XEXP (*split, 1)))) >= 0)\n-\t    SUBST (*split, gen_rtx_combine (ASHIFT, GET_MODE (*split),\n+\t    SUBST (*split, gen_rtx_combine (ASHIFT, split_mode,\n \t\t\t\t\t    XEXP (*split, 0), GEN_INT (i)));\n \n #ifdef INSN_SCHEDULING\n \t  /* If *SPLIT is a paradoxical SUBREG, when we split it, it should\n \t     be written as a ZERO_EXTEND.  */\n-\t  if (GET_CODE (*split) == SUBREG\n-\t      && GET_CODE (SUBREG_REG (*split)) == MEM)\n-\t    SUBST (*split, gen_rtx_combine (ZERO_EXTEND, GET_MODE (*split),\n+\t  if (split_code == SUBREG && GET_CODE (SUBREG_REG (*split)) == MEM)\n+\t    SUBST (*split, gen_rtx_combine (ZERO_EXTEND, split_mode,\n \t\t\t\t\t    XEXP (*split, 0)));\n #endif\n \n \t  newi2pat = gen_rtx_combine (SET, VOIDmode, newdest, *split);\n \t  SUBST (*split, newdest);\n \t  i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes);\n-\t  if (i2_code_number >= 0)\n+\n+\t  /* If the split point was a MULT and we didn't have one before,\n+\t     don't use one now.  */\n+\t  if (i2_code_number >= 0 && ! (split_code == MULT && ! have_mult))\n \t    insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n \t}\n     }"}]}