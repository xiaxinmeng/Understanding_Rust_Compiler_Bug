{"sha": "a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVlMGNkMWQ5YmQ2ZmJjZmYzN2E2NTQ1ZDhlNjBiMzZmZjZlYTdhNw==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2013-05-10T11:15:14Z"}, "committer": {"name": "Marc Glisse", "email": "glisse@gcc.gnu.org", "date": "2013-05-10T11:15:14Z"}, "message": "stor-layout.c (element_precision): New function.\n\n2013-05-10  Marc Glisse  <marc.glisse@inria.fr>\n\ngcc/\n\t* stor-layout.c (element_precision): New function.\n\t* machmode.h (element_precision): Declare it.\n\t* tree.c (build_minus_one_cst): New function.\n\t(element_precision): Likewise.\n\t* tree.h (build_minus_one_cst): Declare new function.\n\t(element_precision): Likewise.\n\t* fold-const.c (operand_equal_p): Use element_precision.\n\t(fold_binary_loc): Handle vector types.\n\t* convert.c (convert_to_integer): Use element_precision.\n\t* gimple.c (iterative_hash_canonical_type): Handle complex and vectors\n\tseparately.\n\ngcc/c-family/\n\t* c-common.c (vector_types_convertible_p): No TYPE_PRECISION for\n\tvectors.\n\ngcc/testsuite/\n\t* gcc.dg/vector-shift.c: New testcase.\n\nFrom-SVN: r198772", "tree": {"sha": "28b2392d93f8ced83cd8e4d51d5232f6883088da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28b2392d93f8ced83cd8e4d51d5232f6883088da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cb2558bc95658155c76e1468ed4db64359452dc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb2558bc95658155c76e1468ed4db64359452dc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb2558bc95658155c76e1468ed4db64359452dc2"}], "stats": {"total": 178, "additions": 146, "deletions": 32}, "files": [{"sha": "bdc8bc50e10ce080f92bea8cdd37cfc4b69b3ddf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7", "patch": "@@ -1,3 +1,17 @@\n+2013-05-10  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\t* stor-layout.c (element_precision): New function.\n+\t* machmode.h (element_precision): Declare it.\n+\t* tree.c (build_minus_one_cst): New function.\n+\t(element_precision): Likewise.\n+\t* tree.h (build_minus_one_cst): Declare new function.\n+\t(element_precision): Likewise.\n+\t* fold-const.c (operand_equal_p): Use element_precision.\n+\t(fold_binary_loc): Handle vector types.\n+\t* convert.c (convert_to_integer): Use element_precision.\n+\t* gimple.c (iterative_hash_canonical_type): Handle complex and vectors\n+\tseparately.\n+\n 2013-05-10  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* config/mips/mips-protos.h (m16_uimm3_b, m16_simm4_1, m16_nsimm4_1)"}, {"sha": "62e14d07adb8e02d16ef316124dd7687109800f1", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7", "patch": "@@ -1,3 +1,8 @@\n+2013-05-10  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\t* c-common.c (vector_types_convertible_p): No TYPE_PRECISION for\n+\tvectors.\n+\n 2013-05-07  Han Shen  <shenhan@google.com>\n \n \t* c-cppbuiltin.c (c_cpp_builtins): Added \"__SSP_STRONG__=3\"."}, {"sha": "8cc1248861378daa8240b59da53a2f60b9fd61f0", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7", "patch": "@@ -2227,7 +2227,7 @@ vector_types_convertible_p (const_tree t1, const_tree t2, bool emit_lax_note)\n   convertible_lax =\n     (tree_int_cst_equal (TYPE_SIZE (t1), TYPE_SIZE (t2))\n      && (TREE_CODE (TREE_TYPE (t1)) != REAL_TYPE ||\n-\t TYPE_PRECISION (t1) == TYPE_PRECISION (t2))\n+\t TYPE_VECTOR_SUBPARTS (t1) == TYPE_VECTOR_SUBPARTS (t2))\n      && (INTEGRAL_TYPE_P (TREE_TYPE (t1))\n \t == INTEGRAL_TYPE_P (TREE_TYPE (t2))));\n "}, {"sha": "62ff224b5663707166901341cedb942d69761e52", "filename": "gcc/convert.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7", "patch": "@@ -355,8 +355,8 @@ convert_to_integer (tree type, tree expr)\n {\n   enum tree_code ex_form = TREE_CODE (expr);\n   tree intype = TREE_TYPE (expr);\n-  unsigned int inprec = TYPE_PRECISION (intype);\n-  unsigned int outprec = TYPE_PRECISION (type);\n+  unsigned int inprec = element_precision (intype);\n+  unsigned int outprec = element_precision (type);\n \n   /* An INTEGER_TYPE cannot be incomplete, but an ENUMERAL_TYPE can\n      be.  Consider `enum E = { a, b = (enum E) 3 };'.  */"}, {"sha": "bfe9e07d9b2a962380a7f08f66ac7c5192f826f4", "filename": "gcc/fold-const.c", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7", "patch": "@@ -2445,7 +2445,8 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \n   /* If both types don't have the same precision, then it is not safe\n      to strip NOPs.  */\n-  if (TYPE_PRECISION (TREE_TYPE (arg0)) != TYPE_PRECISION (TREE_TYPE (arg1)))\n+  if (element_precision (TREE_TYPE (arg0))\n+      != element_precision (TREE_TYPE (arg1)))\n     return 0;\n \n   STRIP_NOPS (arg0);\n@@ -9877,6 +9878,7 @@ fold_binary_loc (location_t loc,\n   tree arg0, arg1, tem;\n   tree t1 = NULL_TREE;\n   bool strict_overflow_p;\n+  unsigned int prec;\n \n   gcc_assert (IS_EXPR_CODE_CLASS (kind)\n \t      && TREE_CODE_LENGTH (code) == 2\n@@ -10147,7 +10149,7 @@ fold_binary_loc (location_t loc,\n \t      STRIP_NOPS (tem);\n \t      if (operand_equal_p (tem, arg1, 0))\n \t\t{\n-\t\t  t1 = build_int_cst_type (type, -1);\n+\t\t  t1 = build_minus_one_cst (type);\n \t\t  return omit_one_operand_loc (loc, type, t1, arg1);\n \t\t}\n \t    }\n@@ -10161,7 +10163,7 @@ fold_binary_loc (location_t loc,\n \t      STRIP_NOPS (tem);\n \t      if (operand_equal_p (arg0, tem, 0))\n \t\t{\n-\t\t  t1 = build_int_cst_type (type, -1);\n+\t\t  t1 = build_minus_one_cst (type);\n \t\t  return omit_one_operand_loc (loc, type, t1, arg0);\n \t\t}\n \t    }\n@@ -10387,7 +10389,8 @@ fold_binary_loc (location_t loc,\n \t        TYPE_UNSIGNED (rtype))\n \t    /* Only create rotates in complete modes.  Other cases are not\n \t       expanded properly.  */\n-\t    && TYPE_PRECISION (rtype) == GET_MODE_PRECISION (TYPE_MODE (rtype)))\n+\t    && (element_precision (rtype)\n+\t\t== element_precision (TYPE_MODE (rtype))))\n \t  {\n \t    tree tree01, tree11;\n \t    enum tree_code code01, code11;\n@@ -10403,7 +10406,7 @@ fold_binary_loc (location_t loc,\n \t\t&& TREE_INT_CST_HIGH (tree01) == 0\n \t\t&& TREE_INT_CST_HIGH (tree11) == 0\n \t\t&& ((TREE_INT_CST_LOW (tree01) + TREE_INT_CST_LOW (tree11))\n-\t\t    == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0)))))\n+\t\t    == element_precision (TREE_TYPE (TREE_OPERAND (arg0, 0)))))\n \t      {\n \t\ttem = build2_loc (loc, LROTATE_EXPR,\n \t\t\t\t  TREE_TYPE (TREE_OPERAND (arg0, 0)),\n@@ -10420,7 +10423,7 @@ fold_binary_loc (location_t loc,\n \t\tSTRIP_NOPS (tree111);\n \t\tif (TREE_CODE (tree110) == INTEGER_CST\n \t\t    && 0 == compare_tree_int (tree110,\n-\t\t\t\t\t      TYPE_PRECISION\n+\t\t\t\t\t      element_precision\n \t\t\t\t\t      (TREE_TYPE (TREE_OPERAND\n \t\t\t\t\t\t\t  (arg0, 0))))\n \t\t    && operand_equal_p (tree01, tree111, 0))\n@@ -10441,7 +10444,7 @@ fold_binary_loc (location_t loc,\n \t\tSTRIP_NOPS (tree011);\n \t\tif (TREE_CODE (tree010) == INTEGER_CST\n \t\t    && 0 == compare_tree_int (tree010,\n-\t\t\t\t\t      TYPE_PRECISION\n+\t\t\t\t\t      element_precision\n \t\t\t\t\t      (TREE_TYPE (TREE_OPERAND\n \t\t\t\t\t\t\t  (arg0, 0))))\n \t\t    && operand_equal_p (tree11, tree011, 0))\n@@ -11757,8 +11760,7 @@ fold_binary_loc (location_t loc,\n       if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg0) == NOP_EXPR\n \t  && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n \t{\n-\t  unsigned int prec\n-\t    = TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0)));\n+\t  prec = TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0)));\n \n \t  if (prec < BITS_PER_WORD && prec < HOST_BITS_PER_WIDE_INT\n \t      && (~TREE_INT_CST_LOW (arg1)\n@@ -11826,7 +11828,7 @@ fold_binary_loc (location_t loc,\n \t\t   && TYPE_PRECISION (TREE_TYPE (arg0))\n \t\t      == GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (arg0))))\n \t    {\n-\t      unsigned int prec = TYPE_PRECISION (TREE_TYPE (arg0));\n+\t      prec = TYPE_PRECISION (TREE_TYPE (arg0));\n \t      tree arg00 = TREE_OPERAND (arg0, 0);\n \t      /* See if more bits can be proven as zero because of\n \t\t zero extension.  */\n@@ -11869,8 +11871,6 @@ fold_binary_loc (location_t loc,\n \t  newmask = mask | zerobits;\n \t  if (newmask != mask && (newmask & (newmask + 1)) == 0)\n \t    {\n-\t      unsigned int prec;\n-\n \t      /* Only do the transformation if NEWMASK is some integer\n \t\t mode's mask.  */\n \t      for (prec = BITS_PER_UNIT;\n@@ -12414,30 +12414,32 @@ fold_binary_loc (location_t loc,\n       if (TREE_CODE (arg1) == INTEGER_CST && tree_int_cst_sgn (arg1) < 0)\n \treturn NULL_TREE;\n \n+      prec = element_precision (type);\n+\n       /* Turn (a OP c1) OP c2 into a OP (c1+c2).  */\n       if (TREE_CODE (op0) == code && host_integerp (arg1, false)\n-\t  && TREE_INT_CST_LOW (arg1) < TYPE_PRECISION (type)\n+\t  && TREE_INT_CST_LOW (arg1) < prec\n \t  && host_integerp (TREE_OPERAND (arg0, 1), false)\n-\t  && TREE_INT_CST_LOW (TREE_OPERAND (arg0, 1)) < TYPE_PRECISION (type))\n+\t  && TREE_INT_CST_LOW (TREE_OPERAND (arg0, 1)) < prec)\n \t{\n \t  HOST_WIDE_INT low = (TREE_INT_CST_LOW (TREE_OPERAND (arg0, 1))\n \t\t\t       + TREE_INT_CST_LOW (arg1));\n \n \t  /* Deal with a OP (c1 + c2) being undefined but (a OP c1) OP c2\n \t     being well defined.  */\n-\t  if (low >= TYPE_PRECISION (type))\n+\t  if (low >= prec)\n \t    {\n \t      if (code == LROTATE_EXPR || code == RROTATE_EXPR)\n-\t        low = low % TYPE_PRECISION (type);\n+\t        low = low % prec;\n \t      else if (TYPE_UNSIGNED (type) || code == LSHIFT_EXPR)\n-\t\treturn omit_one_operand_loc (loc, type, build_int_cst (type, 0),\n+\t\treturn omit_one_operand_loc (loc, type, build_zero_cst (type),\n \t\t\t\t\t TREE_OPERAND (arg0, 0));\n \t      else\n-\t\tlow = TYPE_PRECISION (type) - 1;\n+\t\tlow = prec - 1;\n \t    }\n \n \t  return fold_build2_loc (loc, code, type, TREE_OPERAND (arg0, 0),\n-\t\t\t      build_int_cst (type, low));\n+\t\t\t\t  build_int_cst (TREE_TYPE (arg1), low));\n \t}\n \n       /* Transform (x >> c) << c into x & (-1<<c), or transform (x << c) >> c\n@@ -12446,9 +12448,9 @@ fold_binary_loc (location_t loc,\n            || (TYPE_UNSIGNED (type)\n \t       && code == RSHIFT_EXPR && TREE_CODE (arg0) == LSHIFT_EXPR))\n \t  && host_integerp (arg1, false)\n-\t  && TREE_INT_CST_LOW (arg1) < TYPE_PRECISION (type)\n+\t  && TREE_INT_CST_LOW (arg1) < prec\n \t  && host_integerp (TREE_OPERAND (arg0, 1), false)\n-\t  && TREE_INT_CST_LOW (TREE_OPERAND (arg0, 1)) < TYPE_PRECISION (type))\n+\t  && TREE_INT_CST_LOW (TREE_OPERAND (arg0, 1)) < prec)\n \t{\n \t  HOST_WIDE_INT low0 = TREE_INT_CST_LOW (TREE_OPERAND (arg0, 1));\n \t  HOST_WIDE_INT low1 = TREE_INT_CST_LOW (arg1);\n@@ -12459,8 +12461,8 @@ fold_binary_loc (location_t loc,\n \t    {\n \t      arg00 = fold_convert_loc (loc, type, TREE_OPERAND (arg0, 0));\n \n-\t      lshift = build_int_cst (type, -1);\n-\t      lshift = int_const_binop (code, lshift, arg1);\n+\t      lshift = build_minus_one_cst (type);\n+\t      lshift = const_binop (code, lshift, arg1);\n \n \t      return fold_build2_loc (loc, BIT_AND_EXPR, type, arg00, lshift);\n \t    }\n@@ -12470,8 +12472,7 @@ fold_binary_loc (location_t loc,\n \t RROTATE_EXPR by a new constant.  */\n       if (code == LROTATE_EXPR && TREE_CODE (arg1) == INTEGER_CST)\n \t{\n-\t  tree tem = build_int_cst (TREE_TYPE (arg1),\n-\t\t\t\t    TYPE_PRECISION (type));\n+\t  tree tem = build_int_cst (TREE_TYPE (arg1), prec);\n \t  tem = const_binop (MINUS_EXPR, tem, arg1);\n \t  return fold_build2_loc (loc, RROTATE_EXPR, type, op0, tem);\n \t}\n@@ -12499,7 +12500,7 @@ fold_binary_loc (location_t loc,\n \t  && TREE_INT_CST_HIGH (TREE_OPERAND (arg0, 1)) == 0\n \t  && ((TREE_INT_CST_LOW (arg1)\n \t       + TREE_INT_CST_LOW (TREE_OPERAND (arg0, 1)))\n-\t      == (unsigned int) TYPE_PRECISION (type)))\n+\t      == prec))\n \treturn TREE_OPERAND (arg0, 0);\n \n       /* Fold (X & C2) << C1 into (X << C1) & (C2 << C1)\n@@ -12912,8 +12913,8 @@ fold_binary_loc (location_t loc,\n \t  && integer_zerop (arg1))\n \t{\n \t  tree itype = TREE_TYPE (arg0);\n-\t  unsigned HOST_WIDE_INT prec = TYPE_PRECISION (itype);\n \t  tree arg001 = TREE_OPERAND (TREE_OPERAND (arg0, 0), 1);\n+\t  prec = TYPE_PRECISION (itype);\n \n \t  /* Check for a valid shift count.  */\n \t  if (TREE_INT_CST_HIGH (arg001) == 0"}, {"sha": "f5074199381bf4baefb16c164257b2272c62cb89", "filename": "gcc/gimple.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7", "patch": "@@ -3083,15 +3083,22 @@ iterative_hash_canonical_type (tree type, hashval_t val)\n   if (INTEGRAL_TYPE_P (type)\n       || SCALAR_FLOAT_TYPE_P (type)\n       || FIXED_POINT_TYPE_P (type)\n-      || TREE_CODE (type) == VECTOR_TYPE\n-      || TREE_CODE (type) == COMPLEX_TYPE\n       || TREE_CODE (type) == OFFSET_TYPE\n       || POINTER_TYPE_P (type))\n     {\n       v = iterative_hash_hashval_t (TYPE_PRECISION (type), v);\n       v = iterative_hash_hashval_t (TYPE_UNSIGNED (type), v);\n     }\n \n+  if (VECTOR_TYPE_P (type))\n+    {\n+      v = iterative_hash_hashval_t (TYPE_VECTOR_SUBPARTS (type), v);\n+      v = iterative_hash_hashval_t (TYPE_UNSIGNED (type), v);\n+    }\n+\n+  if (TREE_CODE (type) == COMPLEX_TYPE)\n+    v = iterative_hash_hashval_t (TYPE_UNSIGNED (type), v);\n+\n   /* For pointer and reference types, fold in information about the type\n      pointed to but do not recurse to the pointed-to type.  */\n   if (POINTER_TYPE_P (type))"}, {"sha": "981ee92a87a2feaff2d4fa1ddb29a26356c5d98d", "filename": "gcc/machmode.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7", "patch": "@@ -297,6 +297,10 @@ extern unsigned get_mode_alignment (enum machine_mode);\n \n #define GET_MODE_ALIGNMENT(MODE) get_mode_alignment (MODE)\n \n+/* Get the precision of the mode or its inner mode if it has one.  */\n+\n+extern unsigned int element_precision (enum machine_mode);\n+\n /* For each class, get the narrowest mode in that class.  */\n \n extern const unsigned char class_narrowest_mode[MAX_MODE_CLASS];"}, {"sha": "6f6b3107841ca963aaace67aa87a6d61df9a0b22", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7", "patch": "@@ -453,6 +453,18 @@ get_mode_alignment (enum machine_mode mode)\n   return MIN (BIGGEST_ALIGNMENT, MAX (1, mode_base_align[mode]*BITS_PER_UNIT));\n }\n \n+/* Return the precision of the mode, or for a complex or vector mode the\n+   precision of the mode of its elements.  */\n+\n+unsigned int\n+element_precision (enum machine_mode mode)\n+{\n+  if (COMPLEX_MODE_P (mode) || VECTOR_MODE_P (mode))\n+    mode = GET_MODE_INNER (mode);\n+\n+  return GET_MODE_PRECISION (mode);\n+}\n+\n /* Return the natural mode of an array, given that it is SIZE bytes in\n    total and has elements of type ELEM_TYPE.  */\n "}, {"sha": "d8e13548d966dcb38707f34d4d3650de48ecbc07", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7", "patch": "@@ -1,3 +1,7 @@\n+2013-05-10  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\t* gcc.dg/vector-shift.c: New testcase.\n+\n 2013-05-10  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.target/i386/rotate-1.c: Accept rolb or rorb instruction."}, {"sha": "2a4d415c5ff852673c3e447a0a8794437eac1abc", "filename": "gcc/testsuite/gcc.dg/vector-shift.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Ftestsuite%2Fgcc.dg%2Fvector-shift.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Ftestsuite%2Fgcc.dg%2Fvector-shift.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvector-shift.c?ref=a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-original\" } */\n+\n+typedef unsigned vec __attribute__ ((vector_size (4 * sizeof (int))));\n+\n+void\n+f (vec *x)\n+{\n+  *x = (*x << 4) << 3;\n+}\n+\n+/* { dg-final { scan-tree-dump \"<< 7\" \"original\" } } */\n+/* { dg-final { cleanup-tree-dump \"original\" } } */"}, {"sha": "d93c6aeb75ad879eaeb4479734801d67b30cac94", "filename": "gcc/tree.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7", "patch": "@@ -1643,6 +1643,45 @@ build_one_cst (tree type)\n     }\n }\n \n+/* Return a constant of arithmetic type TYPE which is the\n+   opposite of the multiplicative identity of the set TYPE.  */\n+\n+tree\n+build_minus_one_cst (tree type)\n+{\n+  switch (TREE_CODE (type))\n+    {\n+    case INTEGER_TYPE: case ENUMERAL_TYPE: case BOOLEAN_TYPE:\n+    case POINTER_TYPE: case REFERENCE_TYPE:\n+    case OFFSET_TYPE:\n+      return build_int_cst (type, -1);\n+\n+    case REAL_TYPE:\n+      return build_real (type, dconstm1);\n+\n+    case FIXED_POINT_TYPE:\n+      /* We can only generate 1 for accum types.  */\n+      gcc_assert (ALL_SCALAR_ACCUM_MODE_P (TYPE_MODE (type)));\n+      return build_fixed (type, fixed_from_double_int (double_int_minus_one,\n+\t\t\t\t\t\t       TYPE_MODE (type)));\n+\n+    case VECTOR_TYPE:\n+      {\n+\ttree scalar = build_minus_one_cst (TREE_TYPE (type));\n+\n+\treturn build_vector_from_val (type, scalar);\n+      }\n+\n+    case COMPLEX_TYPE:\n+      return build_complex (type,\n+\t\t\t    build_minus_one_cst (TREE_TYPE (type)),\n+\t\t\t    build_zero_cst (TREE_TYPE (type)));\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Build 0 constant of type TYPE.  This is used by constructor folding\n    and thus the constant should be represented in memory by\n    zero(es).  */\n@@ -6949,6 +6988,19 @@ valid_constant_size_p (const_tree size)\n   return true;\n }\n \n+/* Return the precision of the type, or for a complex or vector type the\n+   precision of the type of its elements.  */\n+\n+unsigned int\n+element_precision (const_tree type)\n+{\n+  enum tree_code code = TREE_CODE (type);\n+  if (code == COMPLEX_TYPE || code == VECTOR_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  return TYPE_PRECISION (type);\n+}\n+\n /* Return true if CODE represents an associative tree code.  Otherwise\n    return false.  */\n bool"}, {"sha": "a46d276b94a701d501edfcf7c87332b62edba473", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a5e0cd1d9bd6fbcff37a6545d8e60b36ff6ea7a7", "patch": "@@ -4767,6 +4767,7 @@ extern tree build_constructor_va (tree, int, ...);\n extern tree build_real_from_int_cst (tree, const_tree);\n extern tree build_complex (tree, tree, tree);\n extern tree build_one_cst (tree);\n+extern tree build_minus_one_cst (tree);\n extern tree build_zero_cst (tree);\n extern tree build_string (int, const char *);\n extern tree build_tree_list_stat (tree, tree MEM_STAT_DECL);\n@@ -4867,6 +4868,7 @@ extern bool may_negate_without_overflow_p (const_tree);\n extern tree strip_array_types (tree);\n extern tree excess_precision_type (tree);\n extern bool valid_constant_size_p (const_tree);\n+extern unsigned int element_precision (const_tree);\n \n /* Construct various nodes representing fract or accum data types.  */\n "}]}