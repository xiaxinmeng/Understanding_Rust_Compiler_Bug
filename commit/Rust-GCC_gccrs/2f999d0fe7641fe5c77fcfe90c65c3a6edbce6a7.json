{"sha": "2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY5OTlkMGZlNzY0MWZlNWM3N2ZjZmU5MGM2NWMzYTZlZGJjZTZhNw==", "commit": {"author": {"name": "Eric Blake", "email": "ebb9@email.byu.edu", "date": "2002-02-15T03:21:47Z"}, "committer": {"name": "Eric Blake", "email": "ericb@gcc.gnu.org", "date": "2002-02-15T03:21:47Z"}, "message": "javaprims.h (java::lang): Add java::lang::StrictMath.\n\n2002-02-14  Eric Blake  <ebb9@email.byu.edu>\n\n\t* gcj/javaprims.h (java::lang): Add java::lang::StrictMath.\n\t* Makefile.am (core_java_source_files): Add\n\tjava/lang/StrictMath.java.\n\t* java/lang/Math.java: Merge with Classpath.\n\t* java/lang/StrictMath.java: New file - merge with Classpath.\n\nFrom-SVN: r49781", "tree": {"sha": "e9a01c945ee2d91f6afc645e57eb9bd74182eddb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9a01c945ee2d91f6afc645e57eb9bd74182eddb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7/comments", "author": null, "committer": null, "parents": [{"sha": "37cea03434d4ae0f5cee382f5ce3112d53b199ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37cea03434d4ae0f5cee382f5ce3112d53b199ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37cea03434d4ae0f5cee382f5ce3112d53b199ab"}], "stats": {"total": 2534, "additions": 2451, "deletions": 83}, "files": [{"sha": "9fed23141314068e9755556b4c29c6f180283126", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7", "patch": "@@ -1,3 +1,11 @@\n+2002-02-14  Eric Blake  <ebb9@email.byu.edu>\n+\n+\t* gcj/javaprims.h (java::lang): Add java::lang::StrictMath.\n+\t* Makefile.am (core_java_source_files): Add\n+\tjava/lang/StrictMath.java.\n+\t* java/lang/Math.java: Merge with Classpath.\n+\t* java/lang/StrictMath.java: New file - merge with Classpath.\n+\n 2002-02-14  Mark Wielaard  <mark@klomp.org>\n \n \t* java/math/BigInteger.java: import gnu.java.math.MPN not the whole"}, {"sha": "7bbd663b4b6568c5fe24d576a4b7f604f22f4336", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7", "patch": "@@ -1102,6 +1102,7 @@ java/lang/SecurityException.java \\\n java/lang/SecurityManager.java \\\n java/lang/Short.java \\\n java/lang/StackOverflowError.java \\\n+java/lang/StrictMath.java \\\n java/lang/String.java \\\n java/lang/StringBuffer.java \\\n java/lang/StringIndexOutOfBoundsException.java \\"}, {"sha": "c4d86fb126e5591ddd501d4e0544ede9e386002d", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7", "patch": "@@ -1,6 +1,6 @@\n // javaprims.h - Main external header file for libgcj.  -*- c++ -*-\n \n-/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -193,6 +193,7 @@ extern \"Java\"\n       class SecurityManager;\n       class Short;\n       class StackOverflowError;\n+      class StrictMath;\n       class String;\n       class String$CaseInsensitiveComparator;\n       class StringBuffer;"}, {"sha": "0d0930e8bf64a7abc6127679974ab212d1ac2932", "filename": "libjava/java/lang/Math.java", "status": "modified", "additions": 597, "deletions": 82, "changes": 679, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7/libjava%2Fjava%2Flang%2FMath.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7/libjava%2Fjava%2Flang%2FMath.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FMath.java?ref=2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7", "patch": "@@ -1,128 +1,643 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* java.lang.Math -- common mathematical functions, native allowed\n+   Copyright (C) 1998, 2001, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n \n-   This file is part of libgcj.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n- \n-/**\n- * @author Andrew Haley <aph@cygnus.com>\n- * @date September 18, 1998.  \n- */\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n- */\n- \n package java.lang;\n \n import java.util.Random;\n+import gnu.classpath.Configuration;\n \n-public final class Math \n+/**\n+ * Helper class containing useful mathematical functions and constants.\n+ * <P>\n+ *\n+ * Note that angles are specified in radians.  Conversion functions are\n+ * provided for your convenience.\n+ *\n+ * @author Paul Fisher\n+ * @author John Keiser\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.0\n+ */\n+public final class Math\n {\n-  private static Random random_;\n-\n-  public static final double E  = 2.7182818284590452354;\n-  public static final double PI = 3.14159265358979323846;\n-\n-  public static native double sin (double x);\n-\n-  public static native double cos (double x);\n-\n-  public static native double tan (double x);\n-\n-  public static native double asin (double x);\n-\n-  public static native double acos (double x);\n-\n-  public static native double atan (double x);\n-\n-  public static native double atan2(double y, double x);\n-\n-  public static native double exp (double x);\n-\n-  public static native double log (double x);\n-\n-  public static native double sqrt (double x);\n-\n-  public static native double pow (double x, double y);\n-\n-  public static native double IEEEremainder (double x, double y);\n-\n-  public static native double ceil (double x);\n-\n-  public static native double floor (double x);\n+  /**\n+   * Math is non-instantiable\n+   */\n+  private Math()\n+  {\n+  }\n \n-  public static native double rint (double x);\n+  static\n+  {\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      {\n+\tSystem.loadLibrary(\"javalang\");\n+      }\n+  }\n \n-  public static native int round (float x);\n+  /**\n+   * A random number generator, initialized on first use.\n+   */\n+  private static Random rand;\n+\n+  /**\n+   * The most accurate approximation to the mathematical constant <em>e</em>:\n+   * <code>2.718281828459045</code>. Used in natural log and exp.\n+   *\n+   * @see #log(double)\n+   * @see #exp(double)\n+   */\n+  public static final double E = 2.718281828459045;\n+\n+  /**\n+   * The most accurate approximation to the mathematical constant <em>pi</em>:\n+   * <code>3.141592653589793</code>. This is the ratio of a circle's diameter\n+   * to its circumference.\n+   */\n+  public static final double PI = 3.141592653589793;\n+\n+  /**\n+   * Take the absolute value of the argument.\n+   * (Absolute value means make it positive.)\n+   * <P>\n+   *\n+   * Note that the the largest negative value (Integer.MIN_VALUE) cannot\n+   * be made positive.  In this case, because of the rules of negation in\n+   * a computer, MIN_VALUE is what will be returned.\n+   * This is a <em>negative</em> value.  You have been warned.\n+   *\n+   * @param i the number to take the absolute value of\n+   * @return the absolute value\n+   * @see Integer#MIN_VALUE\n+   */\n+  public static int abs(int i)\n+  {\n+    return (i < 0) ? -i : i;\n+  }\n \n-  public static native long round (double x);\n-  \n-  public static synchronized double random ()\n+  /**\n+   * Take the absolute value of the argument.\n+   * (Absolute value means make it positive.)\n+   * <P>\n+   *\n+   * Note that the the largest negative value (Long.MIN_VALUE) cannot\n+   * be made positive.  In this case, because of the rules of negation in\n+   * a computer, MIN_VALUE is what will be returned.\n+   * This is a <em>negative</em> value.  You have been warned.\n+   *\n+   * @param l the number to take the absolute value of\n+   * @return the absolute value\n+   * @see Long#MIN_VALUE\n+   */\n+  public static long abs(long l)\n   {\n-    if (random_ == null)\n-      random_ = new Random ();\n-    return random_.nextDouble ();\n+    return (l < 0) ? -l : l;\n   }\n \n-  public static int abs (int n)\n+  /**\n+   * Take the absolute value of the argument.\n+   * (Absolute value means make it positive.)\n+   * <P>\n+   *\n+   * This is equivalent, but faster than, calling\n+   * <code>Float.intBitsToFloat(0x7fffffff & Float.floatToIntBits(a))</code>.\n+   *\n+   * @param f the number to take the absolute value of\n+   * @return the absolute value\n+   */\n+  public static float abs(float f)\n   {\n-    return (n < 0 ? -n : n);\n+    return (f <= 0) ? 0 - f : f;\n   }\n \n-  public static long abs (long n)\n+  /**\n+   * Take the absolute value of the argument.\n+   * (Absolute value means make it positive.)\n+   *\n+   * This is equivalent, but faster than, calling\n+   * <code>Double.longBitsToDouble(Double.doubleToLongBits(a)\n+   *       &lt;&lt; 1) &gt;&gt;&gt; 1);</code>.\n+   *\n+   * @param d the number to take the absolute value of\n+   * @return the absolute value\n+   */\n+  public static double abs(double d)\n   {\n-    return (n < 0 ? -n : n);\n+    return (d <= 0) ? 0 - d : d;\n   }\n \n-  public static native float abs (float x);\n+  /**\n+   * Return whichever argument is smaller.\n+   *\n+   * @param a the first number\n+   * @param b a second number\n+   * @return the smaller of the two numbers\n+   */\n+  public static int min(int a, int b)\n+  {\n+    return (a < b) ? a : b;\n+  }\n \n-  public static native double abs (double x);\n+  /**\n+   * Return whichever argument is smaller.\n+   *\n+   * @param a the first number\n+   * @param b a second number\n+   * @return the smaller of the two numbers\n+   */\n+  public static long min(long a, long b)\n+  {\n+    return (a < b) ? a : b;\n+  }\n \n-  public static int min (int a, int b)\n+  /**\n+   * Return whichever argument is smaller. If either argument is NaN, the\n+   * result is NaN, and when comparing 0 and -0, -0 is always smaller.\n+   *\n+   * @param a the first number\n+   * @param b a second number\n+   * @return the smaller of the two numbers\n+   */\n+  public static float min(float a, float b)\n   {\n-    return (a < b ? a : b);\n+    // this check for NaN, from JLS 15.21.1, saves a method call\n+    if (a != a)\n+      return a;\n+    // no need to check if b is NaN; < will work correctly\n+    // recall that -0.0 == 0.0, but [+-]0.0 - [+-]0.0 behaves special\n+    if (a == 0 && b == 0)\n+      return -(-a - b);\n+    return (a < b) ? a : b;\n   }\n \n-  public static long min (long a, long b)\n+  /**\n+   * Return whichever argument is smaller. If either argument is NaN, the\n+   * result is NaN, and when comparing 0 and -0, -0 is always smaller.\n+   *\n+   * @param a the first number\n+   * @param b a second number\n+   * @return the smaller of the two numbers\n+   */\n+  public static double min(double a, double b)\n   {\n-    return (a < b ? a : b);\n+    // this check for NaN, from JLS 15.21.1, saves a method call\n+    if (a != a)\n+      return a;\n+    // no need to check if b is NaN; < will work correctly\n+    // recall that -0.0 == 0.0, but [+-]0.0 - [+-]0.0 behaves special\n+    if (a == 0 && b == 0)\n+      return -(-a - b);\n+    return (a < b) ? a : b;\n   }\n \n-  public static native float min (float a, float b);\n+  /**\n+   * Return whichever argument is larger.\n+   *\n+   * @param a the first number\n+   * @param b a second number\n+   * @return the larger of the two numbers\n+   */\n+  public static int max(int a, int b)\n+  {\n+    return (a > b) ? a : b;\n+  }\n \n-  public static native double min (double a, double b);\n+  /**\n+   * Return whichever argument is larger.\n+   *\n+   * @param a the first number\n+   * @param b a second number\n+   * @return the larger of the two numbers\n+   */\n+  public static long max(long a, long b)\n+  {\n+    return (a > b) ? a : b;\n+  }\n \n-  public static int max (int a, int b)\n+  /**\n+   * Return whichever argument is larger. If either argument is NaN, the\n+   * result is NaN, and when comparing 0 and -0, 0 is always larger.\n+   *\n+   * @param a the first number\n+   * @param b a second number\n+   * @return the larger of the two numbers\n+   */\n+  public static float max(float a, float b)\n   {\n-    return (a < b ? b : a);\n+    // this check for NaN, from JLS 15.21.1, saves a method call\n+    if (a != a)\n+      return a;\n+    // no need to check if b is NaN; > will work correctly\n+    // recall that -0.0 == 0.0, but [+-]0.0 - [+-]0.0 behaves special\n+    if (a == 0 && b == 0)\n+      return a - -b;\n+    return (a > b) ? a : b;\n   }\n \n-  public static long max (long a, long b)\n+  /**\n+   * Return whichever argument is larger. If either argument is NaN, the\n+   * result is NaN, and when comparing 0 and -0, 0 is always larger.\n+   *\n+   * @param a the first number\n+   * @param b a second number\n+   * @return the larger of the two numbers\n+   */\n+  public static double max(double a, double b)\n   {\n-    return (a < b ? b : a);\n+    // this check for NaN, from JLS 15.21.1, saves a method call\n+    if (a != a)\n+      return a;\n+    // no need to check if b is NaN; > will work correctly\n+    // recall that -0.0 == 0.0, but [+-]0.0 - [+-]0.0 behaves special\n+    if (a == 0 && b == 0)\n+      return a - -b;\n+    return (a > b) ? a : b;\n   }\n \n-  public static native float max (float a, float b);\n+  /**\n+   * The trigonometric function <em>sin</em>. The sine of NaN or infinity is\n+   * NaN, and the sine of 0 retains its sign. This is accurate within 1 ulp,\n+   * and is semi-monotonic.\n+   *\n+   * @param a the angle (in radians)\n+   * @return sin(a)\n+   */\n+  public native static double sin(double a);\n+\n+  /**\n+   * The trigonometric function <em>cos</em>. The cosine of NaN or infinity is\n+   * NaN. This is accurate within 1 ulp, and is semi-monotonic.\n+   *\n+   * @param a the angle (in radians)\n+   * @return cos(a)\n+   */\n+  public native static double cos(double a);\n+\n+  /**\n+   * The trigonometric function <em>tan</em>. The tangent of NaN or infinity\n+   * is NaN, and the tangent of 0 retains its sign. This is accurate within 1\n+   * ulp, and is semi-monotonic.\n+   *\n+   * @param a the angle (in radians)\n+   * @return tan(a)\n+   */\n+  public native static double tan(double a);\n+\n+  /**\n+   * The trigonometric function <em>arcsin</em>. The range of angles returned\n+   * is -pi/2 to pi/2 radians (-90 to 90 degrees). If the argument is NaN or\n+   * its absolute value is beyond 1, the result is NaN; and the arcsine of\n+   * 0 retains its sign. This is accurate within 1 ulp, and is semi-monotonic.\n+   *\n+   * @param a the sin to turn back into an angle\n+   * @return arcsin(a)\n+   */\n+  public native static double asin(double a);\n+\n+  /**\n+   * The trigonometric function <em>arccos</em>. The range of angles returned\n+   * is 0 to pi radians (0 to 180 degrees). If the argument is NaN or\n+   * its absolute value is beyond 1, the result is NaN. This is accurate\n+   * within 1 ulp, and is semi-monotonic.\n+   *\n+   * @param a the cos to turn back into an angle\n+   * @return arccos(a)\n+   */\n+  public native static double acos(double a);\n+\n+  /**\n+   * The trigonometric function <em>arcsin</em>. The range of angles returned\n+   * is -pi/2 to pi/2 radians (-90 to 90 degrees). If the argument is NaN, the\n+   * result is NaN; and the arctangent of 0 retains its sign. This is accurate\n+   * within 1 ulp, and is semi-monotonic.\n+   *\n+   * @param a the tan to turn back into an angle\n+   * @return arcsin(a)\n+   * @see #atan2(double, double)\n+   */\n+  public native static double atan(double a);\n+\n+  /**\n+   * A special version of the trigonometric function <em>arctan</em>, for\n+   * converting rectangular coordinates <em>(x, y)</em> to polar\n+   * <em>(r, theta)</em>. This computes the arctangent of x/y in the range\n+   * of -pi to pi radians (-180 to 180 degrees). Special cases:<ul>\n+   * <li>If either argument is NaN, the result is NaN.</li>\n+   * <li>If the first argument is positive zero and the second argument is\n+   * positive, or the first argument is positive and finite and the second\n+   * argument is positive infinity, then the result is positive zero.</li>\n+   * <li>If the first argument is negative zero and the second argument is\n+   * positive, or the first argument is negative and finite and the second\n+   * argument is positive infinity, then the result is negative zero.</li>\n+   * <li>If the first argument is positive zero and the second argument is\n+   * negative, or the first argument is positive and finite and the second\n+   * argument is negative infinity, then the result is the double value\n+   * closest to pi.</li>\n+   * <li>If the first argument is negative zero and the second argument is\n+   * negative, or the first argument is negative and finite and the second\n+   * argument is negative infinity, then the result is the double value\n+   * closest to -pi.</li>\n+   * <li>If the first argument is positive and the second argument is\n+   * positive zero or negative zero, or the first argument is positive\n+   * infinity and the second argument is finite, then the result is the\n+   * double value closest to pi/2.</li>\n+   * <li>If the first argument is negative and the second argument is\n+   * positive zero or negative zero, or the first argument is negative\n+   * infinity and the second argument is finite, then the result is the\n+   * double value closest to -pi/2.</li>\n+   * <li>If both arguments are positive infinity, then the result is the\n+   * double value closest to pi/4.</li>\n+   * <li>If the first argument is positive infinity and the second argument\n+   * is negative infinity, then the result is the double value closest to\n+   * 3*pi/4.</li>\n+   * <li>If the first argument is negative infinity and the second argument\n+   * is positive infinity, then the result is the double value closest to\n+   * -pi/4.</li>\n+   * <li>If both arguments are negative infinity, then the result is the\n+   * double value closest to -3*pi/4.</li>\n+   *\n+   * </ul><p>This is accurate within 2 ulps, and is semi-monotonic. To get r,\n+   * use sqrt(x*x+y*y).\n+   *\n+   * @param y the y position\n+   * @param x the x position\n+   * @return <em>theta</em> in the conversion of (x, y) to (r, theta)\n+   * @see #atan(double)\n+   */\n+  public native static double atan2(double y, double x);\n+\n+  /**\n+   * Take <em>e</em><sup>a</sup>.  The opposite of <code>log()</code>. If the\n+   * argument is NaN, the result is NaN; if the argument is positive infinity,\n+   * the result is positive infinity; and if the argument is negative\n+   * infinity, the result is positive zero. This is accurate within 1 ulp,\n+   * and is semi-monotonic.\n+   *\n+   * @param a the number to raise to the power\n+   * @return the number raised to the power of <em>e</em>\n+   * @see #log(double)\n+   * @see #pow(double, double)\n+   */\n+  public native static double exp(double a);\n+\n+  /**\n+   * Take ln(a) (the natural log).  The opposite of <code>exp()</code>. If the\n+   * argument is NaN or negative, the result is NaN; if the argument is\n+   * positive infinity, the result is positive infinity; and if the argument\n+   * is either zero, the result is negative infinity. This is accurate within\n+   * 1 ulp, and is semi-monotonic.\n+   *\n+   * <p>Note that the way to get log<sub>b</sub>(a) is to do this:\n+   * <code>ln(a) / ln(b)</code>.\n+   *\n+   * @param a the number to take the natural log of\n+   * @return the natural log of <code>a</code>\n+   * @see #exp(double)\n+   */\n+  public native static double log(double a);\n+\n+  /**\n+   * Take a square root. If the argument is NaN or negative, the result is\n+   * NaN; if the argument is positive infinity, the result is positive\n+   * infinity; and if the result is either zero, the result is the same.\n+   * This is accurate within the limits of doubles.\n+   *\n+   * <p>For other roots, use pow(a, 1 / rootNumber).\n+   *\n+   * @param a the numeric argument\n+   * @return the square root of the argument\n+   * @see #pow(double, double)\n+   */\n+  public native static double sqrt(double a);\n+\n+  /**\n+   * Raise a number to a power. Special cases:<ul>\n+   * <li>If the second argument is positive or negative zero, then the result\n+   * is 1.0.</li>\n+   * <li>If the second argument is 1.0, then the result is the same as the\n+   * first argument.</li>\n+   * <li>If the second argument is NaN, then the result is NaN.</li>\n+   * <li>If the first argument is NaN and the second argument is nonzero,\n+   * then the result is NaN.</li>\n+   * <li>If the absolute value of the first argument is greater than 1 and\n+   * the second argument is positive infinity, or the absolute value of the\n+   * first argument is less than 1 and the second argument is negative\n+   * infinity, then the result is positive infinity.</li>\n+   * <li>If the absolute value of the first argument is greater than 1 and\n+   * the second argument is negative infinity, or the absolute value of the\n+   * first argument is less than 1 and the second argument is positive\n+   * infinity, then the result is positive zero.</li>\n+   * <li>If the absolute value of the first argument equals 1 and the second\n+   * argument is infinite, then the result is NaN.</li>\n+   * <li>If the first argument is positive zero and the second argument is\n+   * greater than zero, or the first argument is positive infinity and the\n+   * second argument is less than zero, then the result is positive zero.</li>\n+   * <li>If the first argument is positive zero and the second argument is\n+   * less than zero, or the first argument is positive infinity and the\n+   * second argument is greater than zero, then the result is positive\n+   * infinity.</li>\n+   * <li>If the first argument is negative zero and the second argument is\n+   * greater than zero but not a finite odd integer, or the first argument is\n+   * negative infinity and the second argument is less than zero but not a\n+   * finite odd integer, then the result is positive zero.</li>\n+   * <li>If the first argument is negative zero and the second argument is a\n+   * positive finite odd integer, or the first argument is negative infinity\n+   * and the second argument is a negative finite odd integer, then the result\n+   * is negative zero.</li>\n+   * <li>If the first argument is negative zero and the second argument is\n+   * less than zero but not a finite odd integer, or the first argument is\n+   * negative infinity and the second argument is greater than zero but not a\n+   * finite odd integer, then the result is positive infinity.</li>\n+   * <li>If the first argument is negative zero and the second argument is a\n+   * negative finite odd integer, or the first argument is negative infinity\n+   * and the second argument is a positive finite odd integer, then the result\n+   * is negative infinity.</li>\n+   * <li>If the first argument is less than zero and the second argument is a\n+   * finite even integer, then the result is equal to the result of raising\n+   * the absolute value of the first argument to the power of the second\n+   * argument.</li>\n+   * <li>If the first argument is less than zero and the second argument is a\n+   * finite odd integer, then the result is equal to the negative of the\n+   * result of raising the absolute value of the first argument to the power\n+   * of the second argument.</li>\n+   * <li>If the first argument is finite and less than zero and the second\n+   * argument is finite and not an integer, then the result is NaN.</li>\n+   * <li>If both arguments are integers, then the result is exactly equal to\n+   * the mathematical result of raising the first argument to the power of\n+   * the second argument if that result can in fact be represented exactly as\n+   * a double value.</li>\n+   *\n+   * </ul><p>(In the foregoing descriptions, a floating-point value is\n+   * considered to be an integer if and only if it is a fixed point of the\n+   * method {@link #ceil(double)} or, equivalently, a fixed point of the\n+   * method {@link #floor(double)}. A value is a fixed point of a one-argument\n+   * method if and only if the result of applying the method to the value is\n+   * equal to the value.) This is accurate within 1 ulp, and is semi-monotonic.\n+   *\n+   * @param a the number to raise\n+   * @param b the power to raise it to\n+   * @return a<sup>b</sup>\n+   */\n+  public native static double pow(double a, double b);\n+\n+  /**\n+   * Get the IEEE 754 floating point remainder on two numbers. This is the\n+   * value of <code>x - y * <em>n</em></code>, where <em>n</em> is the closest\n+   * double to <code>x / y</code> (ties go to the even n); for a zero\n+   * remainder, the sign is that of <code>x</code>. If either argument is NaN,\n+   * the first argument is infinite, or the second argument is zero, the result\n+   * is NaN; if x is finite but y is infinte, the result is x. This is\n+   * accurate within the limits of doubles.\n+   *\n+   * @param x the dividend (the top half)\n+   * @param y the divisor (the bottom half)\n+   * @return the IEEE 754-defined floating point remainder of x/y\n+   * @see #rint(double)\n+   */\n+  public native static double IEEEremainder(double x, double y);\n+\n+  /**\n+   * Take the nearest integer that is that is greater than or equal to the\n+   * argument. If the argument is NaN, infinite, or zero, the result is the\n+   * same; if the argument is between -1 and 0, the result is negative zero.\n+   * Note that <code>Math.ceil(x) == -Math.floor(-x)</code>.\n+   *\n+   * @param a the value to act upon\n+   * @return the nearest integer &gt;= <code>a</code>\n+   */\n+  public native static double ceil(double a);\n+\n+  /**\n+   * Take the nearest integer that is that is less than or equal to the\n+   * argument. If the argument is NaN, infinite, or zero, the result is the\n+   * same. Note that <code>Math.ceil(x) == -Math.floor(-x)</code>.\n+   *\n+   * @param a the value to act upon\n+   * @return the nearest integer &lt;= <code>a</code>\n+   */\n+  public native static double floor(double a);\n+\n+  /**\n+   * Take the nearest integer to the argument.  If it is exactly between\n+   * two integers, the even integer is taken. If the argument is NaN,\n+   * infinite, or zero, the result is the same.\n+   *\n+   * @param a the value to act upon\n+   * @return the nearest integer to <code>a</code>\n+   */\n+  public native static double rint(double a);\n+\n+  /**\n+   * Take the nearest integer to the argument.  This is equivalent to\n+   * <code>(int) Math.floor(a + 0.5f). If the argument is NaN, the result\n+   * is 0; otherwise if the argument is outside the range of int, the result\n+   * will be Integer.MIN_VALUE or Integer.MAX_VALUE, as appropriate.\n+   *\n+   * @param a the argument to round\n+   * @return the nearest integer to the argument\n+   * @see Integer#MIN_VALUE\n+   * @see Integer#MAX_VALUE\n+   */\n+  public static int round(float a)\n+  {\n+    return (int) floor(a + 0.5f);\n+  }\n \n-  public static native double max (double a, double b);\n+  /**\n+   * Take the nearest long to the argument.  This is equivalent to\n+   * <code>(long) Math.floor(a + 0.5)</code>. If the argument is NaN, the\n+   * result is 0; otherwise if the argument is outside the range of long, the\n+   * result will be Long.MIN_VALUE or Long.MAX_VALUE, as appropriate.\n+   *\n+   * @param a the argument to round\n+   * @return the nearest long to the argument\n+   * @see Long#MIN_VALUE\n+   * @see Long#MAX_VALUE\n+   */\n+  public static long round(double a)\n+  {\n+    return (long) floor(a + 0.5d);\n+  }\n \n-  public static double toDegrees (double radians)\n+  /**\n+   * Get a random number.  This behaves like Random.nextDouble(), seeded by\n+   * System.currentTimeMillis() when first called. In other words, the number\n+   * is from a pseudorandom sequence, and lies in the range [+0.0, 1.0).\n+   * This random sequence is only used by this method, and is threadsafe,\n+   * although you may want your own random number generator if it is shared\n+   * among threads.\n+   *\n+   * @return a random number\n+   * @see Random#nextDouble()\n+   * @see System#currentTimeMillis()\n+   */\n+  public static synchronized double random()\n   {\n-    return radians * 180 / PI;\n+    if (rand == null)\n+      rand = new Random();\n+    return rand.nextDouble();\n   }\n \n-  public static double toRadians (double degrees)\n+  /**\n+   * Convert from degrees to radians. The formula for this is\n+   * radians = degrees * (pi/180); however it is not always exact given the\n+   * limitations of floating point numbers.\n+   *\n+   * @param degrees an angle in degrees\n+   * @return the angle in radians\n+   * @since 1.2\n+   */\n+  public static double toRadians(double degrees)\n   {\n-    return degrees * PI / 180;\n+    return degrees * (PI / 180);\n   }\n \n-  // Don't allow objects to be made.\n-  private Math ()\n+  /**\n+   * Convert from radians to degrees. The formula for this is\n+   * degrees = radians * (180/pi); however it is not always exact given the\n+   * limitations of floating point numbers.\n+   *\n+   * @param rads an angle in radians\n+   * @return the angle in degrees\n+   * @since 1.2\n+   */\n+  public static double toDegrees(double rads)\n   {\n+    return rads * (180 / PI);\n   }\n }\n-"}, {"sha": "b47d89ca0409224b6b269937fca28ed483658e5c", "filename": "libjava/java/lang/StrictMath.java", "status": "added", "additions": 1843, "deletions": 0, "changes": 1843, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7/libjava%2Fjava%2Flang%2FStrictMath.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7/libjava%2Fjava%2Flang%2FStrictMath.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FStrictMath.java?ref=2f999d0fe7641fe5c77fcfe90c65c3a6edbce6a7", "patch": "@@ -0,0 +1,1843 @@\n+/* java.lang.StrictMath -- common mathematical functions, strict Java\n+   Copyright (C) 1998, 2001, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+/*\n+ * Some of the algorithms in this class are in the public domain, as part\n+ * of fdlibm (freely-distributable math library), available at\n+ * http://www.netlib.org/fdlibm/, and carry the following copyright:\n+ * ====================================================\n+ * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n+ *\n+ * Developed at SunSoft, a Sun Microsystems, Inc. business.\n+ * Permission to use, copy, modify, and distribute this\n+ * software is freely granted, provided that this notice\n+ * is preserved.\n+ * ====================================================\n+ */\n+\n+package java.lang;\n+\n+import java.util.Random;\n+import gnu.classpath.Configuration;\n+\n+/**\n+ * Helper class containing useful mathematical functions and constants.\n+ * This class mirrors {@link Math}, but is 100% portable, because it uses\n+ * no native methods whatsoever.  Also, these algorithms are all accurate\n+ * to less than 1 ulp, and execute in <code>strictfp</code> mode, while\n+ * Math is allowed to vary in its results for some functions. Unfortunately,\n+ * this usually means StrictMath has less efficiency and speed, as Math can\n+ * use native methods.\n+ *\n+ * <p>The source of the various algorithms used is the fdlibm library, at:<br>\n+ * <a href=\"http://www.netlib.org/fdlibm/\">http://www.netlib.org/fdlibm/</a>\n+ *\n+ * Note that angles are specified in radians.  Conversion functions are\n+ * provided for your convenience.\n+ *\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.3\n+ */\n+public final strictfp class StrictMath\n+{\n+  /**\n+   * StrictMath is non-instantiable.\n+   */\n+  private StrictMath()\n+  {\n+  }\n+\n+  /**\n+   * A random number generator, initialized on first use.\n+   *\n+   * @see #random()\n+   */\n+  private static Random rand;\n+\n+  /**\n+   * The most accurate approximation to the mathematical constant <em>e</em>:\n+   * <code>2.718281828459045</code>. Used in natural log and exp.\n+   *\n+   * @see #log(double)\n+   * @see #exp(double)\n+   */\n+  public static final double E\n+    = 2.718281828459045; // Long bits 0x4005bf0z8b145769L.\n+\n+  /**\n+   * The most accurate approximation to the mathematical constant <em>pi</em>:\n+   * <code>3.141592653589793</code>. This is the ratio of a circle's diameter\n+   * to its circumference.\n+   */\n+  public static final double PI\n+    = 3.141592653589793; // Long bits 0x400921fb54442d18L.\n+\n+  /**\n+   * Take the absolute value of the argument. (Absolute value means make\n+   * it positive.)\n+   *\n+   * <p>Note that the the largest negative value (Integer.MIN_VALUE) cannot\n+   * be made positive.  In this case, because of the rules of negation in\n+   * a computer, MIN_VALUE is what will be returned.\n+   * This is a <em>negative</em> value.  You have been warned.\n+   *\n+   * @param i the number to take the absolute value of\n+   * @return the absolute value\n+   * @see Integer#MIN_VALUE\n+   */\n+  public static int abs(int i)\n+  {\n+    return (i < 0) ? -i : i;\n+  }\n+\n+  /**\n+   * Take the absolute value of the argument. (Absolute value means make\n+   * it positive.)\n+   *\n+   * <p>Note that the the largest negative value (Long.MIN_VALUE) cannot\n+   * be made positive.  In this case, because of the rules of negation in\n+   * a computer, MIN_VALUE is what will be returned.\n+   * This is a <em>negative</em> value.  You have been warned.\n+   *\n+   * @param l the number to take the absolute value of\n+   * @return the absolute value\n+   * @see Long#MIN_VALUE\n+   */\n+  public static long abs(long l)\n+  {\n+    return (l < 0) ? -l : l;\n+  }\n+\n+  /**\n+   * Take the absolute value of the argument. (Absolute value means make\n+   * it positive.)\n+   *\n+   * @param f the number to take the absolute value of\n+   * @return the absolute value\n+   */\n+  public static float abs(float f)\n+  {\n+    return (f <= 0) ? 0 - f : f;\n+  }\n+\n+  /**\n+   * Take the absolute value of the argument. (Absolute value means make\n+   * it positive.)\n+   *\n+   * @param d the number to take the absolute value of\n+   * @return the absolute value\n+   */\n+  public static double abs(double d)\n+  {\n+    return (d <= 0) ? 0 - d : d;\n+  }\n+\n+  /**\n+   * Return whichever argument is smaller.\n+   *\n+   * @param a the first number\n+   * @param b a second number\n+   * @return the smaller of the two numbers\n+   */\n+  public static int min(int a, int b)\n+  {\n+    return (a < b) ? a : b;\n+  }\n+\n+  /**\n+   * Return whichever argument is smaller.\n+   *\n+   * @param a the first number\n+   * @param b a second number\n+   * @return the smaller of the two numbers\n+   */\n+  public static long min(long a, long b)\n+  {\n+    return (a < b) ? a : b;\n+  }\n+\n+  /**\n+   * Return whichever argument is smaller. If either argument is NaN, the\n+   * result is NaN, and when comparing 0 and -0, -0 is always smaller.\n+   *\n+   * @param a the first number\n+   * @param b a second number\n+   * @return the smaller of the two numbers\n+   */\n+  public static float min(float a, float b)\n+  {\n+    // this check for NaN, from JLS 15.21.1, saves a method call\n+    if (a != a)\n+      return a;\n+    // no need to check if b is NaN; < will work correctly\n+    // recall that -0.0 == 0.0, but [+-]0.0 - [+-]0.0 behaves special\n+    if (a == 0 && b == 0)\n+      return -(-a - b);\n+    return (a < b) ? a : b;\n+  }\n+\n+  /**\n+   * Return whichever argument is smaller. If either argument is NaN, the\n+   * result is NaN, and when comparing 0 and -0, -0 is always smaller.\n+   *\n+   * @param a the first number\n+   * @param b a second number\n+   * @return the smaller of the two numbers\n+   */\n+  public static double min(double a, double b)\n+  {\n+    // this check for NaN, from JLS 15.21.1, saves a method call\n+    if (a != a)\n+      return a;\n+    // no need to check if b is NaN; < will work correctly\n+    // recall that -0.0 == 0.0, but [+-]0.0 - [+-]0.0 behaves special\n+    if (a == 0 && b == 0)\n+      return -(-a - b);\n+    return (a < b) ? a : b;\n+  }\n+\n+  /**\n+   * Return whichever argument is larger.\n+   *\n+   * @param a the first number\n+   * @param b a second number\n+   * @return the larger of the two numbers\n+   */\n+  public static int max(int a, int b)\n+  {\n+    return (a > b) ? a : b;\n+  }\n+\n+  /**\n+   * Return whichever argument is larger.\n+   *\n+   * @param a the first number\n+   * @param b a second number\n+   * @return the larger of the two numbers\n+   */\n+  public static long max(long a, long b)\n+  {\n+    return (a > b) ? a : b;\n+  }\n+\n+  /**\n+   * Return whichever argument is larger. If either argument is NaN, the\n+   * result is NaN, and when comparing 0 and -0, 0 is always larger.\n+   *\n+   * @param a the first number\n+   * @param b a second number\n+   * @return the larger of the two numbers\n+   */\n+  public static float max(float a, float b)\n+  {\n+    // this check for NaN, from JLS 15.21.1, saves a method call\n+    if (a != a)\n+      return a;\n+    // no need to check if b is NaN; > will work correctly\n+    // recall that -0.0 == 0.0, but [+-]0.0 - [+-]0.0 behaves special\n+    if (a == 0 && b == 0)\n+      return a - -b;\n+    return (a > b) ? a : b;\n+  }\n+\n+  /**\n+   * Return whichever argument is larger. If either argument is NaN, the\n+   * result is NaN, and when comparing 0 and -0, 0 is always larger.\n+   *\n+   * @param a the first number\n+   * @param b a second number\n+   * @return the larger of the two numbers\n+   */\n+  public static double max(double a, double b)\n+  {\n+    // this check for NaN, from JLS 15.21.1, saves a method call\n+    if (a != a)\n+      return a;\n+    // no need to check if b is NaN; > will work correctly\n+    // recall that -0.0 == 0.0, but [+-]0.0 - [+-]0.0 behaves special\n+    if (a == 0 && b == 0)\n+      return a - -b;\n+    return (a > b) ? a : b;\n+  }\n+\n+  /**\n+   * The trigonometric function <em>sin</em>. The sine of NaN or infinity is\n+   * NaN, and the sine of 0 retains its sign.\n+   *\n+   * @param a the angle (in radians)\n+   * @return sin(a)\n+   */\n+  public static double sin(double a)\n+  {\n+    if (a == Double.NEGATIVE_INFINITY || ! (a < Double.POSITIVE_INFINITY))\n+      return Double.NaN;\n+\n+    if (abs(a) <= PI / 4)\n+      return sin(a, 0);\n+\n+    // Argument reduction needed.\n+    double[] y = new double[2];\n+    int n = remPiOver2(a, y);\n+    switch (n & 3)\n+      {\n+      case 0:\n+        return sin(y[0], y[1]);\n+      case 1:\n+        return cos(y[0], y[1]);\n+      case 2:\n+        return -sin(y[0], y[1]);\n+      default:\n+        return -cos(y[0], y[1]);\n+      }\n+  }\n+\n+  /**\n+   * The trigonometric function <em>cos</em>. The cosine of NaN or infinity is\n+   * NaN.\n+   *\n+   * @param a the angle (in radians).\n+   * @return cos(a).\n+   */\n+  public static double cos(double a)\n+  {\n+    if (a == Double.NEGATIVE_INFINITY || ! (a < Double.POSITIVE_INFINITY))\n+      return Double.NaN;\n+\n+    if (abs(a) <= PI / 4)\n+      return cos(a, 0);\n+\n+    // Argument reduction needed.\n+    double[] y = new double[2];\n+    int n = remPiOver2(a, y);\n+    switch (n & 3)\n+      {\n+      case 0:\n+        return cos(y[0], y[1]);\n+      case 1:\n+        return -sin(y[0], y[1]);\n+      case 2:\n+        return -cos(y[0], y[1]);\n+      default:\n+        return sin(y[0], y[1]);\n+      }\n+  }\n+\n+  /**\n+   * The trigonometric function <em>tan</em>. The tangent of NaN or infinity\n+   * is NaN, and the tangent of 0 retains its sign.\n+   *\n+   * @param a the angle (in radians)\n+   * @return tan(a)\n+   */\n+  public static double tan(double a)\n+  {\n+    if (a == Double.NEGATIVE_INFINITY || ! (a < Double.POSITIVE_INFINITY))\n+      return Double.NaN;\n+\n+    if (abs(a) <= PI / 4)\n+      return tan(a, 0, false);\n+\n+    // Argument reduction needed.\n+    double[] y = new double[2];\n+    int n = remPiOver2(a, y);\n+    return tan(y[0], y[1], (n & 1) == 1);\n+  }\n+\n+  /**\n+   * The trigonometric function <em>arcsin</em>. The range of angles returned\n+   * is -pi/2 to pi/2 radians (-90 to 90 degrees). If the argument is NaN or\n+   * its absolute value is beyond 1, the result is NaN; and the arcsine of\n+   * 0 retains its sign.\n+   *\n+   * @param x the sin to turn back into an angle\n+   * @return arcsin(x)\n+   */\n+  public static double asin(double x)\n+  {\n+    boolean negative = x < 0;\n+    if (negative)\n+      x = -x;\n+    if (! (x <= 1))\n+      return Double.NaN;\n+    if (x == 1)\n+      return negative ? -PI / 2 : PI / 2;\n+    if (x < 0.5)\n+      {\n+        if (x < 1 / TWO_27)\n+          return negative ? -x : x;\n+        double t = x * x;\n+        double p = t * (PS0 + t * (PS1 + t * (PS2 + t * (PS3 + t\n+                                                         * (PS4 + t * PS5)))));\n+        double q = 1 + t * (QS1 + t * (QS2 + t * (QS3 + t * QS4)));\n+        return negative ? -x - x * (p / q) : x + x * (p / q);\n+      }\n+    double w = 1 - x; // 1>|x|>=0.5.\n+    double t = w * 0.5;\n+    double p = t * (PS0 + t * (PS1 + t * (PS2 + t * (PS3 + t\n+                                                     * (PS4 + t * PS5)))));\n+    double q = 1 + t * (QS1 + t * (QS2 + t * (QS3 + t * QS4)));\n+    double s = sqrt(t);\n+    if (x >= 0.975)\n+      {\n+        w = p / q;\n+        t = PI / 2 - (2 * (s + s * w) - PI_L / 2);\n+      }\n+    else\n+      {\n+        w = (float) s;\n+        double c = (t - w * w) / (s + w);\n+        p = 2 * s * (p / q) - (PI_L / 2 - 2 * c);\n+        q = PI / 4 - 2 * w;\n+        t = PI / 4 - (p - q);\n+      }\n+    return negative ? -t : t;\n+  }\n+\n+  /**\n+   * The trigonometric function <em>arccos</em>. The range of angles returned\n+   * is 0 to pi radians (0 to 180 degrees). If the argument is NaN or\n+   * its absolute value is beyond 1, the result is NaN.\n+   *\n+   * @param x the cos to turn back into an angle\n+   * @return arccos(x)\n+   */\n+  public static double acos(double x)\n+  {\n+    boolean negative = x < 0;\n+    if (negative)\n+      x = -x;\n+    if (! (x <= 1))\n+      return Double.NaN;\n+    if (x == 1)\n+      return negative ? PI : 0;\n+    if (x < 0.5)\n+      {\n+        if (x < 1 / TWO_57)\n+          return PI / 2;\n+        double z = x * x;\n+        double p = z * (PS0 + z * (PS1 + z * (PS2 + z * (PS3 + z\n+                                                         * (PS4 + z * PS5)))));\n+        double q = 1 + z * (QS1 + z * (QS2 + z * (QS3 + z * QS4)));\n+        double r = x - (PI_L / 2 - x * (p / q));\n+        return negative ? PI / 2 + r : PI / 2 - r;\n+      }\n+    if (negative) // x<=-0.5.\n+      {\n+        double z = (1 + x) * 0.5;\n+        double p = z * (PS0 + z * (PS1 + z * (PS2 + z * (PS3 + z\n+                                                         * (PS4 + z * PS5)))));\n+        double q = 1 + z * (QS1 + z * (QS2 + z * (QS3 + z * QS4)));\n+        double s = sqrt(z);\n+        double w = p / q * s - PI_L / 2;\n+        return PI - 2 * (s + w);\n+      }\n+    double z = (1 - x) * 0.5; // x>0.5.\n+    double s = sqrt(z);\n+    double df = (float) s;\n+    double c = (z - df * df) / (s + df);\n+    double p = z * (PS0 + z * (PS1 + z * (PS2 + z * (PS3 + z\n+                                                     * (PS4 + z * PS5)))));\n+    double q = 1 + z * (QS1 + z * (QS2 + z * (QS3 + z * QS4)));\n+    double w = p / q * s + c;\n+    return 2 * (df + w);\n+  }\n+\n+  /**\n+   * The trigonometric function <em>arcsin</em>. The range of angles returned\n+   * is -pi/2 to pi/2 radians (-90 to 90 degrees). If the argument is NaN, the\n+   * result is NaN; and the arctangent of 0 retains its sign.\n+   *\n+   * @param x the tan to turn back into an angle\n+   * @return arcsin(x)\n+   * @see #atan2(double, double)\n+   */\n+  public static double atan(double x)\n+  {\n+    double lo;\n+    double hi;\n+    boolean negative = x < 0;\n+    if (negative)\n+      x = -x;\n+    if (x >= TWO_66)\n+      return negative ? -PI / 2 : PI / 2;\n+    if (! (x >= 0.4375)) // |x|<7/16, or NaN.\n+      {\n+        if (! (x >= 1 / TWO_29)) // Small, or NaN.\n+          return negative ? -x : x;\n+        lo = hi = 0;\n+      }\n+    else if (x < 1.1875)\n+      {\n+        if (x < 0.6875) // 7/16<=|x|<11/16.\n+          {\n+            x = (2 * x - 1) / (2 + x);\n+            hi = ATAN_0_5H;\n+            lo = ATAN_0_5L;\n+          }\n+        else // 11/16<=|x|<19/16.\n+          {\n+            x = (x - 1) / (x + 1);\n+            hi = PI / 4;\n+            lo = PI_L / 4;\n+          }\n+      }\n+    else if (x < 2.4375) // 19/16<=|x|<39/16.\n+      {\n+        x = (x - 1.5) / (1 + 1.5 * x);\n+        hi = ATAN_1_5H;\n+        lo = ATAN_1_5L;\n+      }\n+    else // 39/16<=|x|<2**66.\n+      {\n+        x = -1 / x;\n+        hi = PI / 2;\n+        lo = PI_L / 2;\n+      }\n+\n+    // Break sum from i=0 to 10 ATi*z**(i+1) into odd and even poly.\n+    double z = x * x;\n+    double w = z * z;\n+    double s1 = z * (AT0 + w * (AT2 + w * (AT4 + w * (AT6 + w\n+                                                      * (AT8 + w * AT10)))));\n+    double s2 = w * (AT1 + w * (AT3 + w * (AT5 + w * (AT7 + w * AT9))));\n+    if (hi == 0)\n+      return negative ? x * (s1 + s2) - x : x - x * (s1 + s2);\n+    z = hi - ((x * (s1 + s2) - lo) - x);\n+    return negative ? -z : z;\n+  }\n+\n+  /**\n+   * A special version of the trigonometric function <em>arctan</em>, for\n+   * converting rectangular coordinates <em>(x, y)</em> to polar\n+   * <em>(r, theta)</em>. This computes the arctangent of x/y in the range\n+   * of -pi to pi radians (-180 to 180 degrees). Special cases:<ul>\n+   * <li>If either argument is NaN, the result is NaN.</li>\n+   * <li>If the first argument is positive zero and the second argument is\n+   * positive, or the first argument is positive and finite and the second\n+   * argument is positive infinity, then the result is positive zero.</li>\n+   * <li>If the first argument is negative zero and the second argument is\n+   * positive, or the first argument is negative and finite and the second\n+   * argument is positive infinity, then the result is negative zero.</li>\n+   * <li>If the first argument is positive zero and the second argument is\n+   * negative, or the first argument is positive and finite and the second\n+   * argument is negative infinity, then the result is the double value\n+   * closest to pi.</li>\n+   * <li>If the first argument is negative zero and the second argument is\n+   * negative, or the first argument is negative and finite and the second\n+   * argument is negative infinity, then the result is the double value\n+   * closest to -pi.</li>\n+   * <li>If the first argument is positive and the second argument is\n+   * positive zero or negative zero, or the first argument is positive\n+   * infinity and the second argument is finite, then the result is the\n+   * double value closest to pi/2.</li>\n+   * <li>If the first argument is negative and the second argument is\n+   * positive zero or negative zero, or the first argument is negative\n+   * infinity and the second argument is finite, then the result is the\n+   * double value closest to -pi/2.</li>\n+   * <li>If both arguments are positive infinity, then the result is the\n+   * double value closest to pi/4.</li>\n+   * <li>If the first argument is positive infinity and the second argument\n+   * is negative infinity, then the result is the double value closest to\n+   * 3*pi/4.</li>\n+   * <li>If the first argument is negative infinity and the second argument\n+   * is positive infinity, then the result is the double value closest to\n+   * -pi/4.</li>\n+   * <li>If both arguments are negative infinity, then the result is the\n+   * double value closest to -3*pi/4.</li>\n+   *\n+   * </ul><p>This returns theta, the angle of the point. To get r, albeit\n+   * slightly inaccurately, use sqrt(x*x+y*y).\n+   *\n+   * @param y the y position\n+   * @param x the x position\n+   * @return <em>theta</em> in the conversion of (x, y) to (r, theta)\n+   * @see #atan(double)\n+   */\n+  public static double atan2(double y, double x)\n+  {\n+    if (x != x || y != y)\n+      return Double.NaN;\n+    if (x == 1)\n+      return atan(y);\n+    if (x == Double.POSITIVE_INFINITY)\n+      {\n+        if (y == Double.POSITIVE_INFINITY)\n+          return PI / 4;\n+        if (y == Double.NEGATIVE_INFINITY)\n+          return -PI / 4;\n+        return 0 * y;\n+      }\n+    if (x == Double.NEGATIVE_INFINITY)\n+      {\n+        if (y == Double.POSITIVE_INFINITY)\n+          return 3 * PI / 4;\n+        if (y == Double.NEGATIVE_INFINITY)\n+          return -3 * PI / 4;\n+        return (1 / (0 * y) == Double.POSITIVE_INFINITY) ? PI : -PI;\n+      }\n+    if (y == 0)\n+      {\n+        if (1 / (0 * x) == Double.POSITIVE_INFINITY)\n+          return y;\n+        return (1 / y == Double.POSITIVE_INFINITY) ? PI : -PI;\n+      }\n+    if (y == Double.POSITIVE_INFINITY || y == Double.NEGATIVE_INFINITY\n+        || x == 0)\n+      return y < 0 ? -PI / 2 : PI / 2;\n+\n+    double z = abs(y / x); // Safe to do y/x.\n+    if (z > TWO_60)\n+      z = PI / 2 + 0.5 * PI_L;\n+    else if (x < 0 && z < 1 / TWO_60)\n+      z = 0;\n+    else\n+      z = atan(z);\n+    if (x > 0)\n+      return y > 0 ? z : -z;\n+    return y > 0 ? PI - (z - PI_L) : z - PI_L - PI;\n+  }\n+\n+  /**\n+   * Take <em>e</em><sup>a</sup>.  The opposite of <code>log()</code>. If the\n+   * argument is NaN, the result is NaN; if the argument is positive infinity,\n+   * the result is positive infinity; and if the argument is negative\n+   * infinity, the result is positive zero.\n+   *\n+   * @param x the number to raise to the power\n+   * @return the number raised to the power of <em>e</em>\n+   * @see #log(double)\n+   * @see #pow(double, double)\n+   */\n+  public static double exp(double x)\n+  {\n+    if (x != x)\n+      return x;\n+    if (x > EXP_LIMIT_H)\n+      return Double.POSITIVE_INFINITY;\n+    if (x < EXP_LIMIT_L)\n+      return 0;\n+\n+    // Argument reduction.\n+    double hi;\n+    double lo;\n+    int k;\n+    double t = abs(x);\n+    if (t > 0.5 * LN2)\n+      {\n+        if (t < 1.5 * LN2)\n+          {\n+            hi = t - LN2_H;\n+            lo = LN2_L;\n+            k = 1;\n+          }\n+        else\n+          {\n+            k = (int) (INV_LN2 * t + 0.5);\n+            hi = t - k * LN2_H;\n+            lo = k * LN2_L;\n+          }\n+        if (x < 0)\n+          {\n+            hi = -hi;\n+            lo = -lo;\n+            k = -k;\n+          }\n+        x = hi - lo;\n+      }\n+    else if (t < 1 / TWO_28)\n+      return 1;\n+    else\n+      lo = hi = k = 0;\n+\n+    // Now x is in primary range.\n+    t = x * x;\n+    double c = x - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n+    if (k == 0)\n+      return 1 - (x * c / (c - 2) - x);\n+    double y = 1 - (lo - x * c / (2 - c) - hi);\n+    return scale(y, k);\n+  }\n+\n+  /**\n+   * Take ln(a) (the natural log).  The opposite of <code>exp()</code>. If the\n+   * argument is NaN or negative, the result is NaN; if the argument is\n+   * positive infinity, the result is positive infinity; and if the argument\n+   * is either zero, the result is negative infinity.\n+   *\n+   * <p>Note that the way to get log<sub>b</sub>(a) is to do this:\n+   * <code>ln(a) / ln(b)</code>.\n+   *\n+   * @param x the number to take the natural log of\n+   * @return the natural log of <code>a</code>\n+   * @see #exp(double)\n+   */\n+  public static double log(double x)\n+  {\n+    if (x == 0)\n+      return Double.NEGATIVE_INFINITY;\n+    if (x < 0)\n+      return Double.NaN;\n+    if (! (x < Double.POSITIVE_INFINITY))\n+      return x;\n+\n+    // Normalize x.\n+    long bits = Double.doubleToLongBits(x);\n+    int exp = (int) (bits >> 52);\n+    if (exp == 0) // Subnormal x.\n+      {\n+        x *= TWO_54;\n+        bits = Double.doubleToLongBits(x);\n+        exp = (int) (bits >> 52) - 54;\n+      }\n+    exp -= 1023; // Unbias exponent.\n+    bits = (bits & 0x000fffffffffffffL) | 0x3ff0000000000000L;\n+    x = Double.longBitsToDouble(bits);\n+    if (x >= SQRT_2)\n+      {\n+        x *= 0.5;\n+        exp++;\n+      }\n+    x--;\n+    if (abs(x) < 1 / TWO_20)\n+      {\n+        if (x == 0)\n+          return exp * LN2_H + exp * LN2_L;\n+        double r = x * x * (0.5 - 1 / 3.0 * x);\n+        if (exp == 0)\n+          return x - r;\n+        return exp * LN2_H - ((r - exp * LN2_L) - x);\n+      }\n+    double s = x / (2 + x);\n+    double z = s * s;\n+    double w = z * z;\n+    double t1 = w * (LG2 + w * (LG4 + w * LG6));\n+    double t2 = z * (LG1 + w * (LG3 + w * (LG5 + w * LG7)));\n+    double r = t2 + t1;\n+    if (bits >= 0x3ff6174a00000000L && bits < 0x3ff6b85200000000L)\n+      {\n+        double h = 0.5 * x * x; // Need more accuracy for x near sqrt(2).\n+        if (exp == 0)\n+          return x - (h - s * (h + r));\n+        return exp * LN2_H - ((h - (s * (h + r) + exp * LN2_L)) - x);\n+      }\n+    if (exp == 0)\n+      return x - s * (x - r);\n+    return exp * LN2_H - ((s * (x - r) - exp * LN2_L) - x);\n+  }\n+\n+  /**\n+   * Take a square root. If the argument is NaN or negative, the result is\n+   * NaN; if the argument is positive infinity, the result is positive\n+   * infinity; and if the result is either zero, the result is the same.\n+   *\n+   * <p>For other roots, use pow(x, 1/rootNumber).\n+   *\n+   * @param x the numeric argument\n+   * @return the square root of the argument\n+   * @see #pow(double, double)\n+   */\n+  public static double sqrt(double x)\n+  {\n+    if (x < 0)\n+      return Double.NaN;\n+    if (x == 0 || ! (x < Double.POSITIVE_INFINITY))\n+      return x;\n+\n+    // Normalize x.\n+    long bits = Double.doubleToLongBits(x);\n+    int exp = (int) (bits >> 52);\n+    if (exp == 0) // Subnormal x.\n+      {\n+        x *= TWO_54;\n+        bits = Double.doubleToLongBits(x);\n+        exp = (int) (bits >> 52) - 54;\n+      }\n+    exp -= 1023; // Unbias exponent.\n+    bits = (bits & 0x000fffffffffffffL) | 0x0010000000000000L;\n+    if ((exp & 1) == 1) // Odd exp, double x to make it even.\n+      bits <<= 1;\n+    exp >>= 1;\n+\n+    // Generate sqrt(x) bit by bit.\n+    bits <<= 1;\n+    long q = 0;\n+    long s = 0;\n+    long r = 0x0020000000000000L; // Move r right to left.\n+    while (r != 0)\n+      {\n+        long t = s + r;\n+        if (t <= bits)\n+          {\n+            s = t + r;\n+            bits -= t;\n+            q += r;\n+          }\n+        bits <<= 1;\n+        r >>= 1;\n+      }\n+\n+    // Use floating add to round correctly.\n+    if (bits != 0)\n+      q += q & 1;\n+    return Double.longBitsToDouble((q >> 1) + ((exp + 1022L) << 52));\n+  }\n+\n+  /**\n+   * Raise a number to a power. Special cases:<ul>\n+   * <li>If the second argument is positive or negative zero, then the result\n+   * is 1.0.</li>\n+   * <li>If the second argument is 1.0, then the result is the same as the\n+   * first argument.</li>\n+   * <li>If the second argument is NaN, then the result is NaN.</li>\n+   * <li>If the first argument is NaN and the second argument is nonzero,\n+   * then the result is NaN.</li>\n+   * <li>If the absolute value of the first argument is greater than 1 and\n+   * the second argument is positive infinity, or the absolute value of the\n+   * first argument is less than 1 and the second argument is negative\n+   * infinity, then the result is positive infinity.</li>\n+   * <li>If the absolute value of the first argument is greater than 1 and\n+   * the second argument is negative infinity, or the absolute value of the\n+   * first argument is less than 1 and the second argument is positive\n+   * infinity, then the result is positive zero.</li>\n+   * <li>If the absolute value of the first argument equals 1 and the second\n+   * argument is infinite, then the result is NaN.</li>\n+   * <li>If the first argument is positive zero and the second argument is\n+   * greater than zero, or the first argument is positive infinity and the\n+   * second argument is less than zero, then the result is positive zero.</li>\n+   * <li>If the first argument is positive zero and the second argument is\n+   * less than zero, or the first argument is positive infinity and the\n+   * second argument is greater than zero, then the result is positive\n+   * infinity.</li>\n+   * <li>If the first argument is negative zero and the second argument is\n+   * greater than zero but not a finite odd integer, or the first argument is\n+   * negative infinity and the second argument is less than zero but not a\n+   * finite odd integer, then the result is positive zero.</li>\n+   * <li>If the first argument is negative zero and the second argument is a\n+   * positive finite odd integer, or the first argument is negative infinity\n+   * and the second argument is a negative finite odd integer, then the result\n+   * is negative zero.</li>\n+   * <li>If the first argument is negative zero and the second argument is\n+   * less than zero but not a finite odd integer, or the first argument is\n+   * negative infinity and the second argument is greater than zero but not a\n+   * finite odd integer, then the result is positive infinity.</li>\n+   * <li>If the first argument is negative zero and the second argument is a\n+   * negative finite odd integer, or the first argument is negative infinity\n+   * and the second argument is a positive finite odd integer, then the result\n+   * is negative infinity.</li>\n+   * <li>If the first argument is less than zero and the second argument is a\n+   * finite even integer, then the result is equal to the result of raising\n+   * the absolute value of the first argument to the power of the second\n+   * argument.</li>\n+   * <li>If the first argument is less than zero and the second argument is a\n+   * finite odd integer, then the result is equal to the negative of the\n+   * result of raising the absolute value of the first argument to the power\n+   * of the second argument.</li>\n+   * <li>If the first argument is finite and less than zero and the second\n+   * argument is finite and not an integer, then the result is NaN.</li>\n+   * <li>If both arguments are integers, then the result is exactly equal to\n+   * the mathematical result of raising the first argument to the power of\n+   * the second argument if that result can in fact be represented exactly as\n+   * a double value.</li>\n+   *\n+   * </ul><p>(In the foregoing descriptions, a floating-point value is\n+   * considered to be an integer if and only if it is a fixed point of the\n+   * method {@link #ceil(double)} or, equivalently, a fixed point of the\n+   * method {@link #floor(double)}. A value is a fixed point of a one-argument\n+   * method if and only if the result of applying the method to the value is\n+   * equal to the value.)\n+   *\n+   * @param x the number to raise\n+   * @param y the power to raise it to\n+   * @return x<sup>y</sup>\n+   */\n+  public static double pow(double x, double y)\n+  {\n+    // Special cases first.\n+    if (y == 0)\n+      return 1;\n+    if (y == 1)\n+      return x;\n+    if (y == -1)\n+      return 1 / x;\n+    if (x != x || y != y)\n+      return Double.NaN;\n+\n+    // When x < 0, yisint tells if y is not an integer (0), even(1),\n+    // or odd (2).\n+    int yisint = 0;\n+    if (x < 0 && floor(y) == y)\n+      yisint = (y % 2 == 0) ? 2 : 1;\n+    double ax = abs(x);\n+    double ay = abs(y);\n+\n+    // More special cases, of y.\n+    if (ay == Double.POSITIVE_INFINITY)\n+      {\n+        if (ax == 1)\n+          return Double.NaN;\n+        if (ax > 1)\n+          return y > 0 ? y : 0;\n+        return y < 0 ? -y : 0;\n+      }\n+    if (y == 2)\n+      return x * x;\n+    if (y == 0.5)\n+      return sqrt(x);\n+\n+    // More special cases, of x.\n+    if (x == 0 || ax == Double.POSITIVE_INFINITY || ax == 1)\n+      {\n+        if (y < 0)\n+          ax = 1 / ax;\n+        if (x < 0)\n+          {\n+            if (x == -1 && yisint == 0)\n+              ax = Double.NaN;\n+            else if (yisint == 1)\n+              ax = -ax;\n+          }\n+        return ax;\n+      }\n+    if (x < 0 && yisint == 0)\n+      return Double.NaN;\n+\n+    // Now we can start!\n+    double t;\n+    double t1;\n+    double t2;\n+    double u;\n+    double v;\n+    double w;\n+    if (ay > TWO_31)\n+      {\n+        if (ay > TWO_64) // Automatic over/underflow.\n+          return ((ax < 1) ? y < 0 : y > 0) ? Double.POSITIVE_INFINITY : 0;\n+        // Over/underflow if x is not close to one.\n+        if (ax < 0.9999995231628418)\n+          return y < 0 ? Double.POSITIVE_INFINITY : 0;\n+        if (ax >= 1.0000009536743164)\n+          return y > 0 ? Double.POSITIVE_INFINITY : 0;\n+        // Now |1-x| is <= 2**-20, sufficient to compute\n+        // log(x) by x-x^2/2+x^3/3-x^4/4.\n+        t = x - 1;\n+        w = t * t * (0.5 - t * (1 / 3.0 - t * 0.25));\n+        u = INV_LN2_H * t;\n+        v = t * INV_LN2_L - w * INV_LN2;\n+        t1 = (float) (u + v);\n+        t2 = v - (t1 - u);\n+      }\n+    else\n+    {\n+      long bits = Double.doubleToLongBits(ax);\n+      int exp = (int) (bits >> 52);\n+      if (exp == 0) // Subnormal x.\n+        {\n+          ax *= TWO_54;\n+          bits = Double.doubleToLongBits(ax);\n+          exp = (int) (bits >> 52) - 54;\n+        }\n+      exp -= 1023; // Unbias exponent.\n+      ax = Double.longBitsToDouble((bits & 0x000fffffffffffffL)\n+                                   | 0x3ff0000000000000L);\n+      boolean k;\n+      if (ax < SQRT_1_5)  // |x|<sqrt(3/2).\n+        k = false;\n+      else if (ax < SQRT_3) // |x|<sqrt(3).\n+        k = true;\n+      else\n+        {\n+          k = false;\n+          ax *= 0.5;\n+          exp++;\n+        }\n+\n+      // Compute s = s_h+s_l = (x-1)/(x+1) or (x-1.5)/(x+1.5).\n+      u = ax - (k ? 1.5 : 1);\n+      v = 1 / (ax + (k ? 1.5 : 1));\n+      double s = u * v;\n+      double s_h = (float) s;\n+      double t_h = (float) (ax + (k ? 1.5 : 1));\n+      double t_l = ax - (t_h - (k ? 1.5 : 1));\n+      double s_l = v * ((u - s_h * t_h) - s_h * t_l);\n+      // Compute log(ax).\n+      double s2 = s * s;\n+      double r = s_l * (s_h + s) + s2 * s2\n+        * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n+      s2 = s_h * s_h;\n+      t_h = (float) (3.0 + s2 + r);\n+      t_l = r - (t_h - 3.0 - s2);\n+      // u+v = s*(1+...).\n+      u = s_h * t_h;\n+      v = s_l * t_h + t_l * s;\n+      // 2/(3log2)*(s+...).\n+      double p_h = (float) (u + v);\n+      double p_l = v - (p_h - u);\n+      double z_h = CP_H * p_h;\n+      double z_l = CP_L * p_h + p_l * CP + (k ? DP_L : 0);\n+      // log2(ax) = (s+..)*2/(3*log2) = exp + dp_h + z_h + z_l.\n+      t = exp;\n+      t1 = (float) (z_h + z_l + (k ? DP_H : 0) + t);\n+      t2 = z_l - (t1 - t - (k ? DP_H : 0) - z_h);\n+    }\n+\n+    // Split up y into y1+y2 and compute (y1+y2)*(t1+t2).\n+    boolean negative = x < 0 && yisint == 1;\n+    double y1 = (float) y;\n+    double p_l = (y - y1) * t1 + y * t2;\n+    double p_h = y1 * t1;\n+    double z = p_l + p_h;\n+    if (z >= 1024) // Detect overflow.\n+      {\n+        if (z > 1024 || p_l + OVT > z - p_h)\n+          return negative ? Double.NEGATIVE_INFINITY\n+            : Double.POSITIVE_INFINITY;\n+      }\n+    else if (z <= -1075) // Detect underflow.\n+      {\n+        if (z < -1075 || p_l <= z - p_h)\n+          return negative ? -0.0 : 0;\n+      }\n+\n+    // Compute 2**(p_h+p_l).\n+    int n = round((float) z);\n+    p_h -= n;\n+    t = (float) (p_l + p_h);\n+    u = t * LN2_H;\n+    v = (p_l - (t - p_h)) * LN2 + t * LN2_L;\n+    z = u + v;\n+    w = v - (z - u);\n+    t = z * z;\n+    t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n+    double r = (z * t1) / (t1 - 2) - (w + z * w);\n+    z = scale(1 - (r - z), n);\n+    return negative ? -z : z;\n+  }\n+\n+  /**\n+   * Get the IEEE 754 floating point remainder on two numbers. This is the\n+   * value of <code>x - y * <em>n</em></code>, where <em>n</em> is the closest\n+   * double to <code>x / y</code> (ties go to the even n); for a zero\n+   * remainder, the sign is that of <code>x</code>. If either argument is NaN,\n+   * the first argument is infinite, or the second argument is zero, the result\n+   * is NaN; if x is finite but y is infinte, the result is x.\n+   *\n+   * @param x the dividend (the top half)\n+   * @param y the divisor (the bottom half)\n+   * @return the IEEE 754-defined floating point remainder of x/y\n+   * @see #rint(double)\n+   */\n+  public static double IEEEremainder(double x, double y)\n+  {\n+    // Purge off exception values.\n+    if (x == Double.NEGATIVE_INFINITY || ! (x < Double.POSITIVE_INFINITY)\n+        || y == 0 || y != y)\n+      return Double.NaN;\n+\n+    boolean negative = x < 0;\n+    x = abs(x);\n+    y = abs(y);\n+    if (x == y || x == 0)\n+      return 0 * x; // Get correct sign.\n+\n+    // Achieve x < 2y, then take first shot at remainder.\n+    if (y < TWO_1023)\n+      x %= y + y;\n+\n+    // Now adjust x to get correct precision.\n+    if (y < 4 / TWO_1023)\n+      {\n+        if (x + x > y)\n+          {\n+            x -= y;\n+            if (x + x >= y)\n+              x -= y;\n+          }\n+      }\n+    else\n+      {\n+        y *= 0.5;\n+        if (x > y)\n+          {\n+            x -= y;\n+            if (x >= y)\n+              x -= y;\n+          }\n+      }\n+    return negative ? -x : x;\n+  }\n+\n+  /**\n+   * Take the nearest integer that is that is greater than or equal to the\n+   * argument. If the argument is NaN, infinite, or zero, the result is the\n+   * same; if the argument is between -1 and 0, the result is negative zero.\n+   * Note that <code>Math.ceil(x) == -Math.floor(-x)</code>.\n+   *\n+   * @param a the value to act upon\n+   * @return the nearest integer &gt;= <code>a</code>\n+   */\n+  public static double ceil(double a)\n+  {\n+    return -floor(-a);\n+  }\n+\n+  /**\n+   * Take the nearest integer that is that is less than or equal to the\n+   * argument. If the argument is NaN, infinite, or zero, the result is the\n+   * same. Note that <code>Math.ceil(x) == -Math.floor(-x)</code>.\n+   *\n+   * @param a the value to act upon\n+   * @return the nearest integer &lt;= <code>a</code>\n+   */\n+  public static double floor(double a)\n+  {\n+    double x = abs(a);\n+    if (! (x < TWO_52) || (long) a == a)\n+      return a; // No fraction bits; includes NaN and infinity.\n+    if (x < 1)\n+      return a >= 0 ? 0 * a : -1; // Worry about signed zero.\n+    return a < 0 ? (long) a - 1.0 : (long) a; // Cast to long truncates.\n+  }\n+\n+  /**\n+   * Take the nearest integer to the argument.  If it is exactly between\n+   * two integers, the even integer is taken. If the argument is NaN,\n+   * infinite, or zero, the result is the same.\n+   *\n+   * @param a the value to act upon\n+   * @return the nearest integer to <code>a</code>\n+   */\n+  public static double rint(double a)\n+  {\n+    double x = abs(a);\n+    if (! (x < TWO_52))\n+      return a; // No fraction bits; includes NaN and infinity.\n+    if (x <= 0.5)\n+      return 0 * a; // Worry about signed zero.\n+    if (x % 2 <= 0.5)\n+      return (long) a; // Catch round down to even.\n+    return (long) (a + (a < 0 ? -0.5 : 0.5)); // Cast to long truncates.\n+  }\n+\n+  /**\n+   * Take the nearest integer to the argument.  This is equivalent to\n+   * <code>(int) Math.floor(f + 0.5f)</code>. If the argument is NaN, the\n+   * result is 0; otherwise if the argument is outside the range of int, the\n+   * result will be Integer.MIN_VALUE or Integer.MAX_VALUE, as appropriate.\n+   *\n+   * @param f the argument to round\n+   * @return the nearest integer to the argument\n+   * @see Integer#MIN_VALUE\n+   * @see Integer#MAX_VALUE\n+   */\n+  public static int round(float f)\n+  {\n+    return (int) floor(f + 0.5f);\n+  }\n+\n+  /**\n+   * Take the nearest long to the argument.  This is equivalent to\n+   * <code>(long) Math.floor(d + 0.5)</code>. If the argument is NaN, the\n+   * result is 0; otherwise if the argument is outside the range of long, the\n+   * result will be Long.MIN_VALUE or Long.MAX_VALUE, as appropriate.\n+   *\n+   * @param d the argument to round\n+   * @return the nearest long to the argument\n+   * @see Long#MIN_VALUE\n+   * @see Long#MAX_VALUE\n+   */\n+  public static long round(double d)\n+  {\n+    return (long) floor(d + 0.5);\n+  }\n+\n+  /**\n+   * Get a random number.  This behaves like Random.nextDouble(), seeded by\n+   * System.currentTimeMillis() when first called. In other words, the number\n+   * is from a pseudorandom sequence, and lies in the range [+0.0, 1.0).\n+   * This random sequence is only used by this method, and is threadsafe,\n+   * although you may want your own random number generator if it is shared\n+   * among threads.\n+   *\n+   * @return a random number\n+   * @see Random#nextDouble()\n+   * @see System#currentTimeMillis()\n+   */\n+  public static synchronized double random()\n+  {\n+    if (rand == null)\n+      rand = new Random();\n+    return rand.nextDouble();\n+  }\n+\n+  /**\n+   * Convert from degrees to radians. The formula for this is\n+   * radians = degrees * (pi/180); however it is not always exact given the\n+   * limitations of floating point numbers.\n+   *\n+   * @param degrees an angle in degrees\n+   * @return the angle in radians\n+   */\n+  public static double toRadians(double degrees)\n+  {\n+    return degrees * (PI / 180);\n+  }\n+\n+  /**\n+   * Convert from radians to degrees. The formula for this is\n+   * degrees = radians * (180/pi); however it is not always exact given the\n+   * limitations of floating point numbers.\n+   *\n+   * @param rads an angle in radians\n+   * @return the angle in degrees\n+   */\n+  public static double toDegrees(double rads)\n+  {\n+    return rads * (180 / PI);\n+  }\n+\n+  /**\n+   * Constants for scaling and comparing doubles by powers of 2. The compiler\n+   * must automatically inline constructs like (1/TWO_54), so we don't list\n+   * negative powers of two here.\n+   */\n+  private static final double\n+    TWO_16 = 0x10000, // Long bits 0x40f0000000000000L.\n+    TWO_20 = 0x100000, // Long bits 0x4130000000000000L.\n+    TWO_24 = 0x1000000, // Long bits 0x4170000000000000L.\n+    TWO_27 = 0x8000000, // Long bits 0x41a0000000000000L.\n+    TWO_28 = 0x10000000, // Long bits 0x41b0000000000000L.\n+    TWO_29 = 0x20000000, // Long bits 0x41c0000000000000L.\n+    TWO_31 = 0x80000000L, // Long bits 0x41e0000000000000L.\n+    TWO_49 = 0x2000000000000L, // Long bits 0x4300000000000000L.\n+    TWO_52 = 0x10000000000000L, // Long bits 0x4330000000000000L.\n+    TWO_54 = 0x40000000000000L, // Long bits 0x4350000000000000L.\n+    TWO_57 = 0x200000000000000L, // Long bits 0x4380000000000000L.\n+    TWO_60 = 0x1000000000000000L, // Long bits 0x43b0000000000000L.\n+    TWO_64 = 1.8446744073709552e19, // Long bits 0x43f0000000000000L.\n+    TWO_66 = 7.378697629483821e19, // Long bits 0x4410000000000000L.\n+    TWO_1023 = 8.98846567431158e307; // Long bits 0x7fe0000000000000L.\n+\n+  /**\n+   * Super precision for 2/pi in 24-bit chunks, for use in\n+   * {@link #remPiOver2()}.\n+   */\n+  private static final int TWO_OVER_PI[] = {\n+    0xa2f983, 0x6e4e44, 0x1529fc, 0x2757d1, 0xf534dd, 0xc0db62,\n+    0x95993c, 0x439041, 0xfe5163, 0xabdebb, 0xc561b7, 0x246e3a,\n+    0x424dd2, 0xe00649, 0x2eea09, 0xd1921c, 0xfe1deb, 0x1cb129,\n+    0xa73ee8, 0x8235f5, 0x2ebb44, 0x84e99c, 0x7026b4, 0x5f7e41,\n+    0x3991d6, 0x398353, 0x39f49c, 0x845f8b, 0xbdf928, 0x3b1ff8,\n+    0x97ffde, 0x05980f, 0xef2f11, 0x8b5a0a, 0x6d1f6d, 0x367ecf,\n+    0x27cb09, 0xb74f46, 0x3f669e, 0x5fea2d, 0x7527ba, 0xc7ebe5,\n+    0xf17b3d, 0x0739f7, 0x8a5292, 0xea6bfb, 0x5fb11f, 0x8d5d08,\n+    0x560330, 0x46fc7b, 0x6babf0, 0xcfbc20, 0x9af436, 0x1da9e3,\n+    0x91615e, 0xe61b08, 0x659985, 0x5f14a0, 0x68408d, 0xffd880,\n+    0x4d7327, 0x310606, 0x1556ca, 0x73a8c9, 0x60e27b, 0xc08c6b,\n+  };\n+\n+  /**\n+   * Super precision for pi/2 in 24-bit chunks, for use in\n+   * {@link #remPiOver2()}.\n+   */\n+  private static final double PI_OVER_TWO[] = {\n+    1.570796251296997, // Long bits 0x3ff921fb40000000L.\n+    7.549789415861596e-8, // Long bits 0x3e74442d00000000L.\n+    5.390302529957765e-15, // Long bits 0x3cf8469880000000L.\n+    3.282003415807913e-22, // Long bits 0x3b78cc5160000000L.\n+    1.270655753080676e-29, // Long bits 0x39f01b8380000000L.\n+    1.2293330898111133e-36, // Long bits 0x387a252040000000L.\n+    2.7337005381646456e-44, // Long bits 0x36e3822280000000L.\n+    2.1674168387780482e-51, // Long bits 0x3569f31d00000000L.\n+  };\n+\n+  /**\n+   * More constants related to pi, used in {@link #remPiOver2()} and\n+   * elsewhere.\n+   */\n+  private static final double\n+    PI_L = 1.2246467991473532e-16, // Long bits 0x3ca1a62633145c07L.\n+    PIO2_1 = 1.5707963267341256, // Long bits 0x3ff921fb54400000L.\n+    PIO2_1L = 6.077100506506192e-11, // Long bits 0x3dd0b4611a626331L.\n+    PIO2_2 = 6.077100506303966e-11, // Long bits 0x3dd0b4611a600000L.\n+    PIO2_2L = 2.0222662487959506e-21, // Long bits 0x3ba3198a2e037073L.\n+    PIO2_3 = 2.0222662487111665e-21, // Long bits 0x3ba3198a2e000000L.\n+    PIO2_3L = 8.4784276603689e-32; // Long bits 0x397b839a252049c1L.\n+\n+  /**\n+   * Natural log and square root constants, for calculation of\n+   * {@link #exp(double)}, {@link #log(double)} and\n+   * {@link #power(double, double)}. CP is 2/(3*ln(2)).\n+   */\n+  private static final double\n+    SQRT_1_5 = 1.224744871391589, // Long bits 0x3ff3988e1409212eL.\n+    SQRT_2 = 1.4142135623730951, // Long bits 0x3ff6a09e667f3bcdL.\n+    SQRT_3 = 1.7320508075688772, // Long bits 0x3ffbb67ae8584caaL.\n+    EXP_LIMIT_H = 709.782712893384, // Long bits 0x40862e42fefa39efL.\n+    EXP_LIMIT_L = -745.1332191019411, // Long bits 0xc0874910d52d3051L.\n+    CP = 0.9617966939259756, // Long bits 0x3feec709dc3a03fdL.\n+    CP_H = 0.9617967009544373, // Long bits 0x3feec709e0000000L.\n+    CP_L = -7.028461650952758e-9, // Long bits 0xbe3e2fe0145b01f5L.\n+    LN2 = 0.6931471805599453, // Long bits 0x3fe62e42fefa39efL.\n+    LN2_H = 0.6931471803691238, // Long bits 0x3fe62e42fee00000L.\n+    LN2_L = 1.9082149292705877e-10, // Long bits 0x3dea39ef35793c76L.\n+    INV_LN2 = 1.4426950408889634, // Long bits 0x3ff71547652b82feL.\n+    INV_LN2_H = 1.4426950216293335, // Long bits 0x3ff7154760000000L.\n+    INV_LN2_L = 1.9259629911266175e-8; // Long bits 0x3e54ae0bf85ddf44L.\n+\n+  /**\n+   * Constants for computing {@link #log(double)}.\n+   */\n+  private static final double\n+    LG1 = 0.6666666666666735, // Long bits 0x3fe5555555555593L.\n+    LG2 = 0.3999999999940942, // Long bits 0x3fd999999997fa04L.\n+    LG3 = 0.2857142874366239, // Long bits 0x3fd2492494229359L.\n+    LG4 = 0.22222198432149784, // Long bits 0x3fcc71c51d8e78afL.\n+    LG5 = 0.1818357216161805, // Long bits 0x3fc7466496cb03deL.\n+    LG6 = 0.15313837699209373, // Long bits 0x3fc39a09d078c69fL.\n+    LG7 = 0.14798198605116586; // Long bits 0x3fc2f112df3e5244L.\n+\n+  /**\n+   * Constants for computing {@link #pow(double, double)}. L and P are\n+   * coefficients for series; OVT is -(1024-log2(ovfl+.5ulp)); and DP is ???.\n+   * The P coefficients also calculate {@link #exp(double)}.\n+   */\n+  private static final double\n+    L1 = 0.5999999999999946, // Long bits 0x3fe3333333333303L.\n+    L2 = 0.4285714285785502, // Long bits 0x3fdb6db6db6fabffL.\n+    L3 = 0.33333332981837743, // Long bits 0x3fd55555518f264dL.\n+    L4 = 0.272728123808534, // Long bits 0x3fd17460a91d4101L.\n+    L5 = 0.23066074577556175, // Long bits 0x3fcd864a93c9db65L.\n+    L6 = 0.20697501780033842, // Long bits 0x3fca7e284a454eefL.\n+    P1 = 0.16666666666666602, // Long bits 0x3fc555555555553eL.\n+    P2 = -2.7777777777015593e-3, // Long bits 0xbf66c16c16bebd93L.\n+    P3 = 6.613756321437934e-5, // Long bits 0x3f11566aaf25de2cL.\n+    P4 = -1.6533902205465252e-6, // Long bits 0xbebbbd41c5d26bf1L.\n+    P5 = 4.1381367970572385e-8, // Long bits 0x3e66376972bea4d0L.\n+    DP_H = 0.5849624872207642, // Long bits 0x3fe2b80340000000L.\n+    DP_L = 1.350039202129749e-8, // Long bits 0x3e4cfdeb43cfd006L.\n+    OVT = 8.008566259537294e-17; // Long bits 0x3c971547652b82feL.\n+\n+  /**\n+   * Coefficients for computing {@link #sin(double)}.\n+   */\n+  private static final double\n+    S1 = -0.16666666666666632, // Long bits 0xbfc5555555555549L.\n+    S2 = 8.33333333332249e-3, // Long bits 0x3f8111111110f8a6L.\n+    S3 = -1.984126982985795e-4, // Long bits 0xbf2a01a019c161d5L.\n+    S4 = 2.7557313707070068e-6, // Long bits 0x3ec71de357b1fe7dL.\n+    S5 = -2.5050760253406863e-8, // Long bits 0xbe5ae5e68a2b9cebL.\n+    S6 = 1.58969099521155e-10; // Long bits 0x3de5d93a5acfd57cL.\n+\n+  /**\n+   * Coefficients for computing {@link #cos(double)}.\n+   */\n+  private static final double\n+    C1 = 0.0416666666666666, // Long bits 0x3fa555555555554cL.\n+    C2 = -1.388888888887411e-3, // Long bits 0xbf56c16c16c15177L.\n+    C3 = 2.480158728947673e-5, // Long bits 0x3efa01a019cb1590L.\n+    C4 = -2.7557314351390663e-7, // Long bits 0xbe927e4f809c52adL.\n+    C5 = 2.087572321298175e-9, // Long bits 0x3e21ee9ebdb4b1c4L.\n+    C6 = -1.1359647557788195e-11; // Long bits 0xbda8fae9be8838d4L.\n+\n+  /**\n+   * Coefficients for computing {@link #tan(double)}.\n+   */\n+  private static final double\n+    T0 = 0.3333333333333341, // Long bits 0x3fd5555555555563L.\n+    T1 = 0.13333333333320124, // Long bits 0x3fc111111110fe7aL.\n+    T2 = 0.05396825397622605, // Long bits 0x3faba1ba1bb341feL.\n+    T3 = 0.021869488294859542, // Long bits 0x3f9664f48406d637L.\n+    T4 = 8.8632398235993e-3, // Long bits 0x3f8226e3e96e8493L.\n+    T5 = 3.5920791075913124e-3, // Long bits 0x3f6d6d22c9560328L.\n+    T6 = 1.4562094543252903e-3, // Long bits 0x3f57dbc8fee08315L.\n+    T7 = 5.880412408202641e-4, // Long bits 0x3f4344d8f2f26501L.\n+    T8 = 2.464631348184699e-4, // Long bits 0x3f3026f71a8d1068L.\n+    T9 = 7.817944429395571e-5, // Long bits 0x3f147e88a03792a6L.\n+    T10 = 7.140724913826082e-5, // Long bits 0x3f12b80f32f0a7e9L.\n+    T11 = -1.8558637485527546e-5, // Long bits 0xbef375cbdb605373L.\n+    T12 = 2.590730518636337e-5; // Long bits 0x3efb2a7074bf7ad4L.\n+\n+  /**\n+   * Coefficients for computing {@link #asin(double)} and\n+   * {@link #acos(double)}.\n+   */\n+  private static final double\n+    PS0 = 0.16666666666666666, // Long bits 0x3fc5555555555555L.\n+    PS1 = -0.3255658186224009, // Long bits 0xbfd4d61203eb6f7dL.\n+    PS2 = 0.20121253213486293, // Long bits 0x3fc9c1550e884455L.\n+    PS3 = -0.04005553450067941, // Long bits 0xbfa48228b5688f3bL.\n+    PS4 = 7.915349942898145e-4, // Long bits 0x3f49efe07501b288L.\n+    PS5 = 3.479331075960212e-5, // Long bits 0x3f023de10dfdf709L.\n+    QS1 = -2.403394911734414, // Long bits 0xc0033a271c8a2d4bL.\n+    QS2 = 2.0209457602335057, // Long bits 0x40002ae59c598ac8L.\n+    QS3 = -0.6882839716054533, // Long bits 0xbfe6066c1b8d0159L.\n+    QS4 = 0.07703815055590194; // Long bits 0x3fb3b8c5b12e9282L.\n+\n+  /**\n+   * Coefficients for computing {@link #atan(double)}.\n+   */\n+  private static final double\n+    ATAN_0_5H = 0.4636476090008061, // Long bits 0x3fddac670561bb4fL.\n+    ATAN_0_5L = 2.2698777452961687e-17, // Long bits 0x3c7a2b7f222f65e2L.\n+    ATAN_1_5H = 0.982793723247329, // Long bits 0x3fef730bd281f69bL.\n+    ATAN_1_5L = 1.3903311031230998e-17, // Long bits 0x3c7007887af0cbbdL.\n+    AT0 = 0.3333333333333293, // Long bits 0x3fd555555555550dL.\n+    AT1 = -0.19999999999876483, // Long bits 0xbfc999999998ebc4L.\n+    AT2 = 0.14285714272503466, // Long bits 0x3fc24924920083ffL.\n+    AT3 = -0.11111110405462356, // Long bits 0xbfbc71c6fe231671L.\n+    AT4 = 0.09090887133436507, // Long bits 0x3fb745cdc54c206eL.\n+    AT5 = -0.0769187620504483, // Long bits 0xbfb3b0f2af749a6dL.\n+    AT6 = 0.06661073137387531, // Long bits 0x3fb10d66a0d03d51L.\n+    AT7 = -0.058335701337905735, // Long bits 0xbfadde2d52defd9aL.\n+    AT8 = 0.049768779946159324, // Long bits 0x3fa97b4b24760debL.\n+    AT9 = -0.036531572744216916, // Long bits 0xbfa2b4442c6a6c2fL.\n+    AT10 = 0.016285820115365782; // Long bits 0x3f90ad3ae322da11L.\n+\n+  /**\n+   * Helper function for reducing an angle to a multiple of pi/2 within\n+   * [-pi/4, pi/4].\n+   *\n+   * @param x the angle; not infinity or NaN, and outside pi/4\n+   * @param y an array of 2 doubles modified to hold the remander x % pi/2\n+   * @return the quadrant of the result, mod 4: 0: [-pi/4, pi/4],\n+   *         1: [pi/4, 3*pi/4], 2: [3*pi/4, 5*pi/4], 3: [-3*pi/4, -pi/4]\n+   */\n+  private static int remPiOver2(double x, double[] y)\n+  {\n+    boolean negative = x < 0;\n+    x = abs(x);\n+    double z;\n+    int n;\n+    if (Configuration.DEBUG && (x <= PI / 4 || x != x\n+                                || x == Double.POSITIVE_INFINITY))\n+      throw new InternalError(\"Assertion failure\");\n+    if (x < 3 * PI / 4) // If |x| is small.\n+      {\n+        z = x - PIO2_1;\n+        if ((float) x != (float) (PI / 2)) // 33+53 bit pi is good enough.\n+          {\n+            y[0] = z - PIO2_1L;\n+            y[1] = z - y[0] - PIO2_1L;\n+          }\n+        else // Near pi/2, use 33+33+53 bit pi.\n+          {\n+            z -= PIO2_2;\n+            y[0] = z - PIO2_2L;\n+            y[1] = z - y[0] - PIO2_2L;\n+          }\n+        n = 1;\n+      }\n+    else if (x <= TWO_20 * PI / 2) // Medium size.\n+      {\n+        n = (int) (2 / PI * x + 0.5);\n+        z = x - n * PIO2_1;\n+        double w = n * PIO2_1L; // First round good to 85 bits.\n+        y[0] = z - w;\n+        if (n >= 32 || (float) x == (float) (w))\n+          {\n+            if (x / y[0] >= TWO_16) // Second iteration, good to 118 bits.\n+              {\n+                double t = z;\n+                w = n * PIO2_2;\n+                z = t - w;\n+                w = n * PIO2_2L - (t - z - w);\n+                y[0] = z - w;\n+                if (x / y[0] >= TWO_49) // Third iteration, 151 bits accuracy.\n+                  {\n+                    t = z;\n+                    w = n * PIO2_3;\n+                    z = t - w;\n+                    w = n * PIO2_3L - (t - z - w);\n+                    y[0] = z - w;\n+                  }\n+              }\n+          }\n+        y[1] = z - y[0] - w;\n+      }\n+    else\n+      {\n+        // All other (large) arguments.\n+        int e0 = (int) (Double.doubleToLongBits(x) >> 52) - 1046;\n+        z = scale(x, -e0); // e0 = ilogb(z) - 23.\n+        double[] tx = new double[3];\n+        for (int i = 0; i < 2; i++)\n+          {\n+            tx[i] = (int) z;\n+            z = (z - tx[i]) * TWO_24;\n+          }\n+        tx[2] = z;\n+        int nx = 2;\n+        while (tx[nx] == 0)\n+          nx--;\n+        n = remPiOver2(tx, y, e0, nx);\n+      }\n+    if (negative)\n+      {\n+        y[0] = -y[0];\n+        y[1] = -y[1];\n+        return -n;\n+      }\n+    return n;\n+  }\n+\n+  /**\n+   * Helper function for reducing an angle to a multiple of pi/2 within\n+   * [-pi/4, pi/4].\n+   *\n+   * @param x the positive angle, broken into 24-bit chunks\n+   * @param y an array of 2 doubles modified to hold the remander x % pi/2\n+   * @param e0 the exponent of x[0]\n+   * @param nx the last index used in x\n+   * @return the quadrant of the result, mod 4: 0: [-pi/4, pi/4],\n+   *         1: [pi/4, 3*pi/4], 2: [3*pi/4, 5*pi/4], 3: [-3*pi/4, -pi/4]\n+   */\n+  private static int remPiOver2(double[] x, double[] y, int e0, int nx)\n+  {\n+    int i;\n+    int ih;\n+    int n;\n+    double fw;\n+    double z;\n+    int[] iq = new int[20];\n+    double[] f = new double[20];\n+    double[] q = new double[20];\n+    boolean recompute = false;\n+\n+    // Initialize jk, jz, jv, q0; note that 3>q0.\n+    int jk = 4;\n+    int jz = jk;\n+    int jv = max((e0 - 3) / 24, 0);\n+    int q0 = e0 - 24 * (jv + 1);\n+\n+    // Set up f[0] to f[nx+jk] where f[nx+jk] = TWO_OVER_PI[jv+jk].\n+    int j = jv - nx;\n+    int m = nx + jk;\n+    for (i = 0; i <= m; i++, j++)\n+      f[i] = (j < 0) ? 0 : TWO_OVER_PI[j];\n+\n+    // Compute q[0],q[1],...q[jk].\n+    for (i = 0; i <= jk; i++)\n+      {\n+        for (j = 0, fw = 0; j <= nx; j++)\n+          fw += x[j] * f[nx + i - j];\n+        q[i] = fw;\n+      }\n+\n+    do\n+      {\n+        // Distill q[] into iq[] reversingly.\n+        for (i = 0, j = jz, z = q[jz]; j > 0; i++, j--)\n+          {\n+            fw = (int) (1 / TWO_24 * z);\n+            iq[i] = (int) (z - TWO_24 * fw);\n+            z = q[j - 1] + fw;\n+          }\n+\n+        // Compute n.\n+        z = scale(z, q0);\n+        z -= 8 * floor(z * 0.125); // Trim off integer >= 8.\n+        n = (int) z;\n+        z -= n;\n+        ih = 0;\n+        if (q0 > 0) // Need iq[jz-1] to determine n.\n+          {\n+            i = iq[jz - 1] >> (24 - q0);\n+            n += i;\n+            iq[jz - 1] -= i << (24 - q0);\n+            ih = iq[jz - 1] >> (23 - q0);\n+          }\n+        else if (q0 == 0)\n+          ih = iq[jz - 1] >> 23;\n+        else if (z >= 0.5)\n+          ih = 2;\n+\n+        if (ih > 0) // If q > 0.5.\n+          {\n+            n += 1;\n+            int carry = 0;\n+            for (i = 0; i < jz; i++) // Compute 1-q.\n+              {\n+                j = iq[i];\n+                if (carry == 0)\n+                  {\n+                    if (j != 0)\n+                      {\n+                        carry = 1;\n+                        iq[i] = 0x1000000 - j;\n+                      }\n+                  }\n+                else\n+                  iq[i] = 0xffffff - j;\n+              }\n+            switch (q0)\n+              {\n+              case 1: // Rare case: chance is 1 in 12 for non-default.\n+                iq[jz - 1] &= 0x7fffff;\n+                break;\n+              case 2:\n+                iq[jz - 1] &= 0x3fffff;\n+              }\n+            if (ih == 2)\n+              {\n+                z = 1 - z;\n+                if (carry != 0)\n+                  z -= scale(1, q0);\n+              }\n+          }\n+\n+        // Check if recomputation is needed.\n+        if (z == 0)\n+          {\n+            j = 0;\n+            for (i = jz - 1; i >= jk; i--)\n+              j |= iq[i];\n+            if (j == 0) // Need recomputation.\n+              {\n+                int k;\n+                for (k = 1; iq[jk - k] == 0; k++); // k = no. of terms needed.\n+\n+                for (i = jz + 1; i <= jz + k; i++) // Add q[jz+1] to q[jz+k].\n+                  {\n+                    f[nx + i] = TWO_OVER_PI[jv + i];\n+                    for (j = 0, fw = 0; j <= nx; j++)\n+                      fw += x[j] * f[nx + i - j];\n+                    q[i] = fw;\n+                  }\n+                jz += k;\n+                recompute = true;\n+              }\n+          }\n+      }\n+    while (recompute);\n+\n+    // Chop off zero terms.\n+    if (z == 0)\n+      {\n+        jz--;\n+        q0 -= 24;\n+        while (iq[jz] == 0)\n+          {\n+            jz--;\n+            q0 -= 24;\n+          }\n+      }\n+    else // Break z into 24-bit if necessary.\n+      {\n+        z = scale(z, -q0);\n+        if (z >= TWO_24)\n+          {\n+            fw = (int) (1 / TWO_24 * z);\n+            iq[jz] = (int) (z - TWO_24 * fw);\n+            jz++;\n+            q0 += 24;\n+            iq[jz] = (int) fw;\n+          }\n+        else\n+          iq[jz] = (int) z;\n+      }\n+\n+    // Convert integer \"bit\" chunk to floating-point value.\n+    fw = scale(1, q0);\n+    for (i = jz; i >= 0; i--)\n+      {\n+        q[i] = fw * iq[i];\n+        fw *= 1 / TWO_24;\n+      }\n+\n+    // Compute PI_OVER_TWO[0,...,jk]*q[jz,...,0].\n+    double[] fq = new double[20];\n+    for (i = jz; i >= 0; i--)\n+      {\n+        fw = 0;\n+        for (int k = 0; k <= jk && k <= jz - i; k++)\n+          fw += PI_OVER_TWO[k] * q[i + k];\n+        fq[jz - i] = fw;\n+      }\n+\n+    // Compress fq[] into y[].\n+    fw = 0;\n+    for (i = jz; i >= 0; i--)\n+      fw += fq[i];\n+    y[0] = (ih == 0) ? fw : -fw;\n+    fw = fq[0] - fw;\n+    for (i = 1; i <= jz; i++)\n+      fw += fq[i];\n+    y[1] = (ih == 0) ? fw : -fw;\n+    return n;\n+  }\n+\n+  /**\n+   * Helper method for scaling a double by a power of 2.\n+   *\n+   * @param x the double\n+   * @param n the scale; |n| < 2048\n+   * @return x * 2**n\n+   */\n+  private static double scale(double x, int n)\n+  {\n+    if (Configuration.DEBUG && abs(n) >= 2048)\n+      throw new InternalError(\"Assertion failure\");\n+    if (x == 0 || x == Double.NEGATIVE_INFINITY\n+        || ! (x < Double.POSITIVE_INFINITY) || n == 0)\n+      return x;\n+    long bits = Double.doubleToLongBits(x);\n+    int exp = (int) (bits >> 52) & 0x7ff;\n+    if (exp == 0) // Subnormal x.\n+      {\n+        x *= TWO_54;\n+        exp = ((int) (Double.doubleToLongBits(x) >> 52) & 0x7ff) - 54;\n+      }\n+    exp += n;\n+    if (exp > 0x7fe) // Overflow.\n+      return Double.POSITIVE_INFINITY * x;\n+    if (exp > 0) // Normal.\n+      return Double.longBitsToDouble((bits & 0x800fffffffffffffL)\n+                                     | ((long) exp << 52));\n+    if (exp <= -54)\n+      return 0 * x; // Underflow.\n+    exp += 54; // Subnormal result.\n+    x = Double.longBitsToDouble((bits & 0x800fffffffffffffL)\n+                                | ((long) exp << 52));\n+    return x * (1 / TWO_54);\n+  }\n+\n+  /**\n+   * Helper trig function; computes sin in range [-pi/4, pi/4].\n+   *\n+   * @param x angle within about pi/4\n+   * @param y tail of x, created by remPiOver2\n+   * @return sin(x+y)\n+   */\n+  private static double sin(double x, double y)\n+  {\n+    if (Configuration.DEBUG && abs(x + y) > 0.7854)\n+      throw new InternalError(\"Assertion failure\");\n+    if (abs(x) < 1 / TWO_27)\n+      return x;  // If |x| ~< 2**-27, already know answer.\n+\n+    double z = x * x;\n+    double v = z * x;\n+    double r = S2 + z * (S3 + z * (S4 + z * (S5 + z * S6)));\n+    if (y == 0)\n+      return x + v * (S1 + z * r);\n+    return x - ((z * (0.5 * y - v * r) - y) - v * S1);\n+  }\n+\n+  /**\n+   * Helper trig function; computes cos in range [-pi/4, pi/4].\n+   *\n+   * @param x angle within about pi/4\n+   * @param y tail of x, created by remPiOver2\n+   * @return cos(x+y)\n+   */\n+  private static double cos(double x, double y)\n+  {\n+    if (Configuration.DEBUG && abs(x + y) > 0.7854)\n+      throw new InternalError(\"Assertion failure\");\n+    x = abs(x);\n+    if (x < 1 / TWO_27)\n+      return 1;  // If |x| ~< 2**-27, already know answer.\n+\n+    double z = x * x;\n+    double r = z * (C1 + z * (C2 + z * (C3 + z * (C4 + z * (C5 + z * C6)))));\n+\n+    if (x < 0.3)\n+      return 1 - (0.5 * z - (z * r - x * y));\n+\n+    double qx = (x > 0.78125) ? 0.28125 : (x * 0.25);\n+    return 1 - qx - ((0.5 * z - qx) - (z * r - x * y));\n+  }\n+\n+  /**\n+   * Helper trig function; computes tan in range [-pi/4, pi/4].\n+   *\n+   * @param x angle within about pi/4\n+   * @param y tail of x, created by remPiOver2\n+   * @param invert true iff -1/tan should be returned instead\n+   * @return tan(x+y)\n+   */\n+  private static double tan(double x, double y, boolean invert)\n+  {\n+    // PI/2 is irrational, so no double is a perfect multiple of it.\n+    if (Configuration.DEBUG && (abs(x + y) > 0.7854 || (x == 0 && invert)))\n+      throw new InternalError(\"Assertion failure\");\n+    boolean negative = x < 0;\n+    if (negative)\n+      {\n+        x = -x;\n+        y = -y;\n+      }\n+    if (x < 1 / TWO_28) // If |x| ~< 2**-28, already know answer.\n+      return (negative ? -1 : 1) * (invert ? -1 / x : x);\n+\n+    double z;\n+    double w;\n+    boolean large = x >= 0.6744;\n+    if (large)\n+      {\n+        z = PI / 4 - x;\n+        w = PI_L / 4 - y;\n+        x = z + w;\n+        y = 0;\n+      }\n+    z = x * x;\n+    w = z * z;\n+    // Break x**5*(T1+x**2*T2+...) into\n+    //   x**5(T1+x**4*T3+...+x**20*T11)\n+    // + x**5(x**2*(T2+x**4*T4+...+x**22*T12)).\n+    double r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));\n+    double v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));\n+    double s = z * x;\n+    r = y + z * (s * (r + v) + y);\n+    r += T0 * s;\n+    w = x + r;\n+    if (large)\n+      {\n+        v = invert ? -1 : 1;\n+        return (negative ? -1 : 1) * (v - 2 * (x - (w * w / (w + v) - r)));\n+      }\n+    if (! invert)\n+      return w;\n+\n+    // Compute -1.0/(x+r) accurately.\n+    z = (float) w;\n+    v = r - (z - x);\n+    double a = -1 / w;\n+    double t = (float) a;\n+    return t + a * (1 + t * z + t * v);\n+  }\n+}"}]}