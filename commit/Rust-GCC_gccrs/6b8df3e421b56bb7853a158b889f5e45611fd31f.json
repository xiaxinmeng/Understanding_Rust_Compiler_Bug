{"sha": "6b8df3e421b56bb7853a158b889f5e45611fd31f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI4ZGYzZTQyMWI1NmJiNzg1M2ExNThiODg5ZjVlNDU2MTFmZDMxZg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-01-14T07:43:32Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-01-14T08:47:02Z"}, "message": "PR middle-end/93246 - missing alias subsets\n\nStarting with the introduction of TYPE_TYPELESS_STORAGE the situation\nof having a alias-set zero aggregate field became more common which\nprevents recording alias-sets of fields of said aggregate as subset\nof the outer aggregate.  component_uses_parent_alias_set_from in the\npast fended off some of the issues with that but the alias oracles\nuse of the alias set of the base of an access path never appropriately\nhandled it.\n\nThe following makes it so that alias-sets of fields of alias-set zero\naggregate fields are still recorded as subset of the container.\n\n2020-01-14  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/93246\n\t* alias.c (record_component_aliases): Take superset to record\n\tinto, recurse for alias-set zero fields.\n\t(record_component_aliases): New oveerload wrapping around the above.\n\n\t* g++.dg/torture/pr93246.C: New testcase.", "tree": {"sha": "33bf50001d0dfc546744ed2fdd0962089a017631", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33bf50001d0dfc546744ed2fdd0962089a017631"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b8df3e421b56bb7853a158b889f5e45611fd31f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b8df3e421b56bb7853a158b889f5e45611fd31f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b8df3e421b56bb7853a158b889f5e45611fd31f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b8df3e421b56bb7853a158b889f5e45611fd31f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b38e86ddb7a9b6d7e87d7cc0b23983d027fcbd96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b38e86ddb7a9b6d7e87d7cc0b23983d027fcbd96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b38e86ddb7a9b6d7e87d7cc0b23983d027fcbd96"}], "stats": {"total": 65, "additions": 61, "deletions": 4}, "files": [{"sha": "9629b5a9f48460cc67a228e3a7f9e7bcf702a5a4", "filename": "gcc/alias.c", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8df3e421b56bb7853a158b889f5e45611fd31f/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8df3e421b56bb7853a158b889f5e45611fd31f/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=6b8df3e421b56bb7853a158b889f5e45611fd31f", "patch": "@@ -1191,15 +1191,14 @@ record_alias_subset (alias_set_type superset, alias_set_type subset)\n     }\n }\n \n-/* Record that component types of TYPE, if any, are part of that type for\n+/* Record that component types of TYPE, if any, are part of SUPERSET for\n    aliasing purposes.  For record types, we only record component types\n    for fields that are not marked non-addressable.  For array types, we\n    only record the component type if it is not marked non-aliased.  */\n \n void\n-record_component_aliases (tree type)\n+record_component_aliases (tree type, alias_set_type superset)\n {\n-  alias_set_type superset = get_alias_set (type);\n   tree field;\n \n   if (superset == 0)\n@@ -1253,7 +1252,21 @@ record_component_aliases (tree type)\n \t\t\t\t\t == get_alias_set (TREE_TYPE (field)));\n \t\t}\n \n-\t      record_alias_subset (superset, get_alias_set (t));\n+\t      alias_set_type set = get_alias_set (t);\n+\t      record_alias_subset (superset, set);\n+\t      /* If the field has alias-set zero make sure to still record\n+\t\t any componets of it.  This makes sure that for\n+\t\t   struct A {\n+\t\t     struct B {\n+\t\t       int i;\n+\t\t       char c[4];\n+\t\t     } b;\n+\t\t   };\n+\t\t in C++ even though 'B' has alias-set zero because\n+\t\t TYPE_TYPELESS_STORAGE is set, 'A' has the alias-set of\n+\t\t 'int' as subset.  */\n+\t      if (set == 0)\n+\t\trecord_component_aliases (t, superset);\n \t    }\n       }\n       break;\n@@ -1270,6 +1283,19 @@ record_component_aliases (tree type)\n     }\n }\n \n+/* Record that component types of TYPE, if any, are part of that type for\n+   aliasing purposes.  For record types, we only record component types\n+   for fields that are not marked non-addressable.  For array types, we\n+   only record the component type if it is not marked non-aliased.  */\n+\n+void\n+record_component_aliases (tree type)\n+{\n+  alias_set_type superset = get_alias_set (type);\n+  record_component_aliases (type, superset);\n+}\n+\n+\n /* Allocate an alias set for use in storing and reading from the varargs\n    spill area.  */\n "}, {"sha": "4c5234431755490225609504b516dc190519d0c3", "filename": "gcc/testsuite/g++.dg/torture/pr93246.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8df3e421b56bb7853a158b889f5e45611fd31f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr93246.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8df3e421b56bb7853a158b889f5e45611fd31f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr93246.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr93246.C?ref=6b8df3e421b56bb7853a158b889f5e45611fd31f", "patch": "@@ -0,0 +1,31 @@\n+// { dg-do run }\n+// { dg-additional-options \"-fstrict-aliasing\" }\n+\n+template <typename = void> struct Optional {\n+  auto is_present() const { const bool &p = inner.present; return p; }\n+  auto set_present() { if (not is_present()) inner.present = true; }\n+  struct InnerType {\n+    bool present = false;\n+    char padding[1] = {0};\n+  };\n+  using inner_t = InnerType;\n+  inner_t inner = {};\n+};\n+\n+template <typename WrappedType> struct Wrapper {\n+  auto operator-> () { return value; }\n+  WrappedType *value;\n+};\n+\n+void __attribute__((noipa)) foo(Optional<>& x) {}\n+\n+int main()\n+{\n+  Optional<> buf{};\n+  foo(buf);\n+  Wrapper<Optional<>> wo = {&buf};\n+  wo->set_present();\n+  auto x = wo->is_present();\n+  if (!x)\n+    __builtin_abort ();\n+}"}]}