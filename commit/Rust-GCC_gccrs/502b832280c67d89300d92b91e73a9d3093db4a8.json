{"sha": "502b832280c67d89300d92b91e73a9d3093db4a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTAyYjgzMjI4MGM2N2Q4OTMwMGQ5MmI5MWU3M2E5ZDMwOTNkYjRhOA==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-06-29T16:21:58Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-06-29T16:21:58Z"}, "message": "except.c: Convert prototypes to ISO C90.\n\n\t* except.c: Convert prototypes to ISO C90.\n\t* except.h: Likewise.\n\t* emit-rtl.c: Likewise.\n\t* et-forest.c: Likewise.\n\t* et-forest.h: Likewise.\n\t* except.c: Likewise.\n\t* explow.c: Likewise.\n\t* expmed.c: Likewise.\n\t* expr.c: Likewise.\n\t* expr.h: Likewise.\n\nFrom-SVN: r68674", "tree": {"sha": "d12a59c660881801d6279dba52e7bd166ec393fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d12a59c660881801d6279dba52e7bd166ec393fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/502b832280c67d89300d92b91e73a9d3093db4a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/502b832280c67d89300d92b91e73a9d3093db4a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/502b832280c67d89300d92b91e73a9d3093db4a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/502b832280c67d89300d92b91e73a9d3093db4a8/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7080f7359418d87feb8ec8dfacf327d32b5a070c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7080f7359418d87feb8ec8dfacf327d32b5a070c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7080f7359418d87feb8ec8dfacf327d32b5a070c"}], "stats": {"total": 2485, "additions": 916, "deletions": 1569}, "files": [{"sha": "e3b5d665e9e1ff0e65ca1f58eafd92ba2f1777c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=502b832280c67d89300d92b91e73a9d3093db4a8", "patch": "@@ -14,6 +14,16 @@\n \t* dwarf2out.c: Likewise.\n \t* dwarf2out.h: Likewise.\n \t* dwarfout.c: Likewise.\n+\t* except.c: Likewise.\n+\t* except.h: Likewise.\n+\t* emit-rtl.c: Likewise.\n+\t* et-forest.c: Likewise.\n+\t* et-forest.h: Likewise.\n+\t* except.c: Likewise.\n+\t* explow.c: Likewise.\n+\t* expmed.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* expr.h: Likewise.\n \n 2003-06-29  Kazu Hirata  <kazu@cs.umass.edu>\n "}, {"sha": "17f68cf98064eb2a6b10fe5b87e9985da8c65d46", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 202, "deletions": 439, "changes": 641, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=502b832280c67d89300d92b91e73a9d3093db4a8", "patch": "@@ -173,36 +173,29 @@ static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n #define last_location (cfun->emit->x_last_location)\n #define first_label_num (cfun->emit->x_first_label_num)\n \n-static rtx make_jump_insn_raw\t\tPARAMS ((rtx));\n-static rtx make_call_insn_raw\t\tPARAMS ((rtx));\n-static rtx find_line_note\t\tPARAMS ((rtx));\n-static rtx change_address_1\t\tPARAMS ((rtx, enum machine_mode, rtx,\n-\t\t\t\t\t\t int));\n-static void unshare_all_rtl_1\t\tPARAMS ((rtx));\n-static void unshare_all_decls\t\tPARAMS ((tree));\n-static void reset_used_decls\t\tPARAMS ((tree));\n-static void mark_label_nuses\t\tPARAMS ((rtx));\n-static hashval_t const_int_htab_hash    PARAMS ((const void *));\n-static int const_int_htab_eq            PARAMS ((const void *,\n-\t\t\t\t\t\t const void *));\n-static hashval_t const_double_htab_hash PARAMS ((const void *));\n-static int const_double_htab_eq\t\tPARAMS ((const void *,\n-\t\t\t\t\t\t const void *));\n-static rtx lookup_const_double\t\tPARAMS ((rtx));\n-static hashval_t mem_attrs_htab_hash    PARAMS ((const void *));\n-static int mem_attrs_htab_eq            PARAMS ((const void *,\n-\t\t\t\t\t\t const void *));\n-static mem_attrs *get_mem_attrs\t\tPARAMS ((HOST_WIDE_INT, tree, rtx,\n-\t\t\t\t\t\t rtx, unsigned int,\n-\t\t\t\t\t\t enum machine_mode));\n-static hashval_t reg_attrs_htab_hash    PARAMS ((const void *));\n-static int reg_attrs_htab_eq            PARAMS ((const void *,\n-\t\t\t\t\t\t const void *));\n-static reg_attrs *get_reg_attrs\t\tPARAMS ((tree, int));\n-static tree component_ref_for_mem_expr\tPARAMS ((tree));\n-static rtx gen_const_vector_0\t\tPARAMS ((enum machine_mode));\n-static rtx gen_complex_constant_part\tPARAMS ((enum machine_mode,\n-\t\t\t\t\t\t rtx, int));\n+static rtx make_jump_insn_raw (rtx);\n+static rtx make_call_insn_raw (rtx);\n+static rtx find_line_note (rtx);\n+static rtx change_address_1 (rtx, enum machine_mode, rtx, int);\n+static void unshare_all_rtl_1 (rtx);\n+static void unshare_all_decls (tree);\n+static void reset_used_decls (tree);\n+static void mark_label_nuses (rtx);\n+static hashval_t const_int_htab_hash (const void *);\n+static int const_int_htab_eq (const void *, const void *);\n+static hashval_t const_double_htab_hash (const void *);\n+static int const_double_htab_eq (const void *, const void *);\n+static rtx lookup_const_double (rtx);\n+static hashval_t mem_attrs_htab_hash (const void *);\n+static int mem_attrs_htab_eq (const void *, const void *);\n+static mem_attrs *get_mem_attrs (HOST_WIDE_INT, tree, rtx, rtx, unsigned int,\n+\t\t\t\t enum machine_mode);\n+static hashval_t reg_attrs_htab_hash (const void *);\n+static int reg_attrs_htab_eq (const void *, const void *);\n+static reg_attrs *get_reg_attrs (tree, int);\n+static tree component_ref_for_mem_expr (tree);\n+static rtx gen_const_vector_0 (enum machine_mode);\n+static rtx gen_complex_constant_part (enum machine_mode, rtx, int);\n \n /* Probability of the conditional branch currently proceeded by try_split.\n    Set to -1 otherwise.  */\n@@ -211,8 +204,7 @@ int split_branch_probability = -1;\n /* Returns a hash code for X (which is a really a CONST_INT).  */\n \n static hashval_t\n-const_int_htab_hash (x)\n-     const void *x;\n+const_int_htab_hash (const void *x)\n {\n   return (hashval_t) INTVAL ((struct rtx_def *) x);\n }\n@@ -222,17 +214,14 @@ const_int_htab_hash (x)\n    HOST_WIDE_INT *).  */\n \n static int\n-const_int_htab_eq (x, y)\n-     const void *x;\n-     const void *y;\n+const_int_htab_eq (const void *x, const void *y)\n {\n   return (INTVAL ((rtx) x) == *((const HOST_WIDE_INT *) y));\n }\n \n /* Returns a hash code for X (which is really a CONST_DOUBLE).  */\n static hashval_t\n-const_double_htab_hash (x)\n-     const void *x;\n+const_double_htab_hash (const void *x)\n {\n   rtx value = (rtx) x;\n   hashval_t h;\n@@ -251,9 +240,7 @@ const_double_htab_hash (x)\n /* Returns nonzero if the value represented by X (really a ...)\n    is the same as that represented by Y (really a ...) */\n static int\n-const_double_htab_eq (x, y)\n-     const void *x;\n-     const void *y;\n+const_double_htab_eq (const void *x, const void *y)\n {\n   rtx a = (rtx)x, b = (rtx)y;\n \n@@ -270,8 +257,7 @@ const_double_htab_eq (x, y)\n /* Returns a hash code for X (which is a really a mem_attrs *).  */\n \n static hashval_t\n-mem_attrs_htab_hash (x)\n-     const void *x;\n+mem_attrs_htab_hash (const void *x)\n {\n   mem_attrs *p = (mem_attrs *) x;\n \n@@ -286,9 +272,7 @@ mem_attrs_htab_hash (x)\n    mem_attrs *).  */\n \n static int\n-mem_attrs_htab_eq (x, y)\n-     const void *x;\n-     const void *y;\n+mem_attrs_htab_eq (const void *x, const void *y)\n {\n   mem_attrs *p = (mem_attrs *) x;\n   mem_attrs *q = (mem_attrs *) y;\n@@ -302,13 +286,8 @@ mem_attrs_htab_eq (x, y)\n    MEM of mode MODE.  */\n \n static mem_attrs *\n-get_mem_attrs (alias, expr, offset, size, align, mode)\n-     HOST_WIDE_INT alias;\n-     tree expr;\n-     rtx offset;\n-     rtx size;\n-     unsigned int align;\n-     enum machine_mode mode;\n+get_mem_attrs (HOST_WIDE_INT alias, tree expr, rtx offset, rtx size,\n+\t       unsigned int align, enum machine_mode mode)\n {\n   mem_attrs attrs;\n   void **slot;\n@@ -342,8 +321,7 @@ get_mem_attrs (alias, expr, offset, size, align, mode)\n /* Returns a hash code for X (which is a really a reg_attrs *).  */\n \n static hashval_t\n-reg_attrs_htab_hash (x)\n-     const void *x;\n+reg_attrs_htab_hash (const void *x)\n {\n   reg_attrs *p = (reg_attrs *) x;\n \n@@ -355,9 +333,7 @@ reg_attrs_htab_hash (x)\n    reg_attrs *).  */\n \n static int\n-reg_attrs_htab_eq (x, y)\n-     const void *x;\n-     const void *y;\n+reg_attrs_htab_eq (const void *x, const void *y)\n {\n   reg_attrs *p = (reg_attrs *) x;\n   reg_attrs *q = (reg_attrs *) y;\n@@ -369,9 +345,7 @@ reg_attrs_htab_eq (x, y)\n    MEM of mode MODE.  */\n \n static reg_attrs *\n-get_reg_attrs (decl, offset)\n-     tree decl;\n-     int offset;\n+get_reg_attrs (tree decl, int offset)\n {\n   reg_attrs attrs;\n   void **slot;\n@@ -398,9 +372,7 @@ get_reg_attrs (decl, offset)\n    frame_pointer_rtx).  */\n \n rtx\n-gen_raw_REG (mode, regno)\n-     enum machine_mode mode;\n-     int regno;\n+gen_raw_REG (enum machine_mode mode, int regno)\n {\n   rtx x = gen_rtx_raw_REG (mode, regno);\n   ORIGINAL_REGNO (x) = regno;\n@@ -412,9 +384,7 @@ gen_raw_REG (mode, regno)\n    special_rtx in gengenrtl.c as well.  */\n \n rtx\n-gen_rtx_CONST_INT (mode, arg)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT arg;\n+gen_rtx_CONST_INT (enum machine_mode mode ATTRIBUTE_UNUSED, HOST_WIDE_INT arg)\n {\n   void **slot;\n \n@@ -436,9 +406,7 @@ gen_rtx_CONST_INT (mode, arg)\n }\n \n rtx\n-gen_int_mode (c, mode)\n-     HOST_WIDE_INT c;\n-     enum machine_mode mode;\n+gen_int_mode (HOST_WIDE_INT c, enum machine_mode mode)\n {\n   return GEN_INT (trunc_int_for_mode (c, mode));\n }\n@@ -451,8 +419,7 @@ gen_int_mode (c, mode)\n    hash table.  If so, return its counterpart; otherwise add it\n    to the hash table and return it.  */\n static rtx\n-lookup_const_double (real)\n-     rtx real;\n+lookup_const_double (rtx real)\n {\n   void **slot = htab_find_slot (const_double_htab, real, INSERT);\n   if (*slot == 0)\n@@ -464,9 +431,7 @@ lookup_const_double (real)\n /* Return a CONST_DOUBLE rtx for a floating-point value specified by\n    VALUE in mode MODE.  */\n rtx\n-const_double_from_real_value (value, mode)\n-     REAL_VALUE_TYPE value;\n-     enum machine_mode mode;\n+const_double_from_real_value (REAL_VALUE_TYPE value, enum machine_mode mode)\n {\n   rtx real = rtx_alloc (CONST_DOUBLE);\n   PUT_MODE (real, mode);\n@@ -482,9 +447,7 @@ const_double_from_real_value (value, mode)\n    REAL_VALUE_TYPE and use CONST_DOUBLE_FROM_REAL_VALUE.  */\n \n rtx\n-immed_double_const (i0, i1, mode)\n-     HOST_WIDE_INT i0, i1;\n-     enum machine_mode mode;\n+immed_double_const (HOST_WIDE_INT i0, HOST_WIDE_INT i1, enum machine_mode mode)\n {\n   rtx value;\n   unsigned int i;\n@@ -567,9 +530,7 @@ immed_double_const (i0, i1, mode)\n }\n \n rtx\n-gen_rtx_REG (mode, regno)\n-     enum machine_mode mode;\n-     unsigned int regno;\n+gen_rtx_REG (enum machine_mode mode, unsigned int regno)\n {\n   /* In case the MD file explicitly references the frame pointer, have\n      all such references point to the same frame pointer.  This is\n@@ -634,9 +595,7 @@ gen_rtx_REG (mode, regno)\n }\n \n rtx\n-gen_rtx_MEM (mode, addr)\n-     enum machine_mode mode;\n-     rtx addr;\n+gen_rtx_MEM (enum machine_mode mode, rtx addr)\n {\n   rtx rt = gen_rtx_raw_MEM (mode, addr);\n \n@@ -648,10 +607,7 @@ gen_rtx_MEM (mode, addr)\n }\n \n rtx\n-gen_rtx_SUBREG (mode, reg, offset)\n-     enum machine_mode mode;\n-     rtx reg;\n-     int offset;\n+gen_rtx_SUBREG (enum machine_mode mode, rtx reg, int offset)\n {\n   /* This is the most common failure type.\n      Catch it early so we can see who does it.  */\n@@ -673,9 +629,7 @@ gen_rtx_SUBREG (mode, reg, offset)\n    is smaller than mode of REG, otherwise paradoxical SUBREG.  */\n \n rtx\n-gen_lowpart_SUBREG (mode, reg)\n-     enum machine_mode mode;\n-     rtx reg;\n+gen_lowpart_SUBREG (enum machine_mode mode, rtx reg)\n {\n   enum machine_mode inmode;\n \n@@ -831,9 +785,7 @@ gen_rtvec (int n, ...)\n }\n \n rtvec\n-gen_rtvec_v (n, argp)\n-     int n;\n-     rtx *argp;\n+gen_rtvec_v (int n, rtx *argp)\n {\n   int i;\n   rtvec rt_val;\n@@ -853,8 +805,7 @@ gen_rtvec_v (n, argp)\n    This pseudo is assigned the next sequential register number.  */\n \n rtx\n-gen_reg_rtx (mode)\n-     enum machine_mode mode;\n+gen_reg_rtx (enum machine_mode mode)\n {\n   struct function *f = cfun;\n   rtx val;\n@@ -911,24 +862,18 @@ gen_reg_rtx (mode)\n    but offsetted by OFFSET.  */\n \n rtx\n-gen_rtx_REG_offset (reg, mode, regno, offset)\n-     enum machine_mode mode;\n-     unsigned int regno;\n-     int offset;\n-     rtx reg;\n+gen_rtx_REG_offset (rtx reg, enum machine_mode mode, unsigned int regno, int offset)\n {\n   rtx new = gen_rtx_REG (mode, regno);\n   REG_ATTRS (new) = get_reg_attrs (REG_EXPR (reg),\n-\t\t \t\t   REG_OFFSET (reg) + offset);\n+\t\t\t\t   REG_OFFSET (reg) + offset);\n   return new;\n }\n \n /* Set the decl for MEM to DECL.  */\n \n void\n-set_reg_attrs_from_mem (reg, mem)\n-     rtx reg;\n-     rtx mem;\n+set_reg_attrs_from_mem (rtx reg, rtx mem)\n {\n   if (MEM_OFFSET (mem) && GET_CODE (MEM_OFFSET (mem)) == CONST_INT)\n     REG_ATTRS (reg)\n@@ -939,9 +884,7 @@ set_reg_attrs_from_mem (reg, mem)\n    Use needed values from memory attributes of MEM.  */\n \n void\n-set_reg_attrs_for_parm (parm_rtx, mem)\n-     rtx parm_rtx;\n-     rtx mem;\n+set_reg_attrs_for_parm (rtx parm_rtx, rtx mem)\n {\n   if (GET_CODE (parm_rtx) == REG)\n     set_reg_attrs_from_mem (parm_rtx, mem);\n@@ -963,9 +906,7 @@ set_reg_attrs_for_parm (parm_rtx, mem)\n \n /* Assign the RTX X to declaration T.  */\n void\n-set_decl_rtl (t, x)\n-     tree t;\n-     rtx x;\n+set_decl_rtl (tree t, rtx x)\n {\n   DECL_CHECK (t)->decl.rtl = x;\n \n@@ -1000,8 +941,7 @@ set_decl_rtl (t, x)\n /* Identify REG (which may be a CONCAT) as a user register.  */\n \n void\n-mark_user_reg (reg)\n-     rtx reg;\n+mark_user_reg (rtx reg)\n {\n   if (GET_CODE (reg) == CONCAT)\n     {\n@@ -1018,9 +958,7 @@ mark_user_reg (reg)\n    as ALIGN, if nonzero.  */\n \n void\n-mark_reg_pointer (reg, align)\n-     rtx reg;\n-     int align;\n+mark_reg_pointer (rtx reg, int align)\n {\n   if (! REG_POINTER (reg))\n     {\n@@ -1037,15 +975,15 @@ mark_reg_pointer (reg, align)\n /* Return 1 plus largest pseudo reg number used in the current function.  */\n \n int\n-max_reg_num ()\n+max_reg_num (void)\n {\n   return reg_rtx_no;\n }\n \n /* Return 1 + the largest label number used so far in the current function.  */\n \n int\n-max_label_num ()\n+max_label_num (void)\n {\n   if (last_label_num && label_num == base_label_num)\n     return last_label_num;\n@@ -1055,17 +993,15 @@ max_label_num ()\n /* Return first label number used in this function (if any were used).  */\n \n int\n-get_first_label_num ()\n+get_first_label_num (void)\n {\n   return first_label_num;\n }\n \f\n /* Return the final regno of X, which is a SUBREG of a hard\n    register.  */\n int\n-subreg_hard_regno (x, check_mode)\n-     rtx x;\n-     int check_mode;\n+subreg_hard_regno (rtx x, int check_mode)\n {\n   enum machine_mode mode = GET_MODE (x);\n   unsigned int byte_offset, base_regno, final_regno;\n@@ -1083,7 +1019,7 @@ subreg_hard_regno (x, check_mode)\n     abort ();\n #ifdef ENABLE_CHECKING\n   if (!subreg_offset_representable_p (REGNO (reg), GET_MODE (reg),\n-\t\t\t  \t      SUBREG_BYTE (x), mode))\n+\t\t\t\t      SUBREG_BYTE (x), mode))\n     abort ();\n #endif\n   /* Catch non-congruent offsets too.  */\n@@ -1108,9 +1044,7 @@ subreg_hard_regno (x, check_mode)\n    If this is not a case we can handle, return 0.  */\n \n rtx\n-gen_lowpart_common (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+gen_lowpart_common (enum machine_mode mode, rtx x)\n {\n   int msize = GET_MODE_SIZE (mode);\n   int xsize = GET_MODE_SIZE (GET_MODE (x));\n@@ -1305,10 +1239,7 @@ gen_lowpart_common (mode, x)\n    returns NULL_RTX if the component isn't a constant.  */\n \n static rtx\n-gen_complex_constant_part (mode, x, imagpart_p)\n-     enum machine_mode mode;\n-     rtx x;\n-     int imagpart_p;\n+gen_complex_constant_part (enum machine_mode mode, rtx x, int imagpart_p)\n {\n   tree decl, part;\n \n@@ -1331,9 +1262,7 @@ gen_complex_constant_part (mode, x, imagpart_p)\n    This always comes at the low address in memory.  */\n \n rtx\n-gen_realpart (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+gen_realpart (enum machine_mode mode, rtx x)\n {\n   rtx part;\n \n@@ -1358,9 +1287,7 @@ gen_realpart (mode, x)\n    This always comes at the high address in memory.  */\n \n rtx\n-gen_imagpart (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+gen_imagpart (enum machine_mode mode, rtx x)\n {\n   rtx part;\n \n@@ -1387,8 +1314,7 @@ gen_imagpart (mode, x)\n    regardless of WORDS_BIG_ENDIAN.  */\n \n int\n-subreg_realpart_p (x)\n-     rtx x;\n+subreg_realpart_p (rtx x)\n {\n   if (GET_CODE (x) != SUBREG)\n     abort ();\n@@ -1405,9 +1331,7 @@ subreg_realpart_p (x)\n    If X is a MEM whose address is a QUEUED, the value may be so also.  */\n \n rtx\n-gen_lowpart (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+gen_lowpart (enum machine_mode mode, rtx x)\n {\n   rtx result = gen_lowpart_common (mode, x);\n \n@@ -1454,9 +1378,7 @@ gen_lowpart (mode, x)\n    This is used to access the imaginary part of a complex number.  */\n \n rtx\n-gen_highpart (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+gen_highpart (enum machine_mode mode, rtx x)\n {\n   unsigned int msize = GET_MODE_SIZE (mode);\n   rtx result;\n@@ -1484,9 +1406,7 @@ gen_highpart (mode, x)\n /* Like gen_highpart, but accept mode of EXP operand in case EXP can\n    be VOIDmode constant.  */\n rtx\n-gen_highpart_mode (outermode, innermode, exp)\n-     enum machine_mode outermode, innermode;\n-     rtx exp;\n+gen_highpart_mode (enum machine_mode outermode, enum machine_mode innermode, rtx exp)\n {\n   if (GET_MODE (exp) != VOIDmode)\n     {\n@@ -1502,8 +1422,7 @@ gen_highpart_mode (outermode, innermode, exp)\n    of the value in mode INNERMODE stored in memory in target format.  */\n \n unsigned int\n-subreg_lowpart_offset (outermode, innermode)\n-     enum machine_mode outermode, innermode;\n+subreg_lowpart_offset (enum machine_mode outermode, enum machine_mode innermode)\n {\n   unsigned int offset = 0;\n   int difference = (GET_MODE_SIZE (innermode) - GET_MODE_SIZE (outermode));\n@@ -1522,8 +1441,7 @@ subreg_lowpart_offset (outermode, innermode)\n /* Return offset in bytes to get OUTERMODE high part\n    of the value in mode INNERMODE stored in memory in target format.  */\n unsigned int\n-subreg_highpart_offset (outermode, innermode)\n-     enum machine_mode outermode, innermode;\n+subreg_highpart_offset (enum machine_mode outermode, enum machine_mode innermode)\n {\n   unsigned int offset = 0;\n   int difference = (GET_MODE_SIZE (innermode) - GET_MODE_SIZE (outermode));\n@@ -1547,8 +1465,7 @@ subreg_highpart_offset (outermode, innermode)\n    If X is not a SUBREG, always return 1 (it is its own low part!).  */\n \n int\n-subreg_lowpart_p (x)\n-     rtx x;\n+subreg_lowpart_p (rtx x)\n {\n   if (GET_CODE (x) != SUBREG)\n     return 1;\n@@ -1564,10 +1481,7 @@ subreg_lowpart_p (x)\n    Some places invoke this directly.  */\n \n rtx\n-constant_subword (op, offset, mode)\n-     rtx op;\n-     int offset;\n-     enum machine_mode mode;\n+constant_subword (rtx op, int offset, enum machine_mode mode)\n {\n   int size_ratio = HOST_BITS_PER_WIDE_INT / BITS_PER_WORD;\n   HOST_WIDE_INT val;\n@@ -1744,11 +1658,7 @@ constant_subword (op, offset, mode)\n  */\n \n rtx\n-operand_subword (op, offset, validate_address, mode)\n-     rtx op;\n-     unsigned int offset;\n-     int validate_address;\n-     enum machine_mode mode;\n+operand_subword (rtx op, unsigned int offset, int validate_address, enum machine_mode mode)\n {\n   if (mode == VOIDmode)\n     mode = GET_MODE (op);\n@@ -1794,10 +1704,7 @@ operand_subword (op, offset, validate_address, mode)\n    MODE is the mode of OP, in case it is CONST_INT.  */\n \n rtx\n-operand_subword_force (op, offset, mode)\n-     rtx op;\n-     unsigned int offset;\n-     enum machine_mode mode;\n+operand_subword_force (rtx op, unsigned int offset, enum machine_mode mode)\n {\n   rtx result = operand_subword (op, offset, 1, mode);\n \n@@ -1825,8 +1732,7 @@ operand_subword_force (op, offset, mode)\n    A test instruction is changed into a compare of 0 against the operand.  */\n \n void\n-reverse_comparison (insn)\n-     rtx insn;\n+reverse_comparison (rtx insn)\n {\n   rtx body = PATTERN (insn);\n   rtx comp;\n@@ -1859,8 +1765,7 @@ reverse_comparison (insn)\n    a NULL expression.  */\n \n static tree\n-component_ref_for_mem_expr (ref)\n-     tree ref;\n+component_ref_for_mem_expr (tree ref)\n {\n   tree inner = TREE_OPERAND (ref, 0);\n \n@@ -1899,11 +1804,8 @@ component_ref_for_mem_expr (ref)\n    there is an offset outstanding on T that will be applied later.  */\n \n void\n-set_mem_attributes_minus_bitpos (ref, t, objectp, bitpos)\n-     rtx ref;\n-     tree t;\n-     int objectp;\n-     HOST_WIDE_INT bitpos;\n+set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n+\t\t\t\t HOST_WIDE_INT bitpos)\n {\n   HOST_WIDE_INT alias = MEM_ALIAS_SET (ref);\n   tree expr = MEM_EXPR (ref);\n@@ -2122,20 +2024,15 @@ set_mem_attributes_minus_bitpos (ref, t, objectp, bitpos)\n }\n \n void\n-set_mem_attributes (ref, t, objectp)\n-     rtx ref;\n-     tree t;\n-     int objectp;\n+set_mem_attributes (rtx ref, tree t, int objectp)\n {\n   set_mem_attributes_minus_bitpos (ref, t, objectp, 0);\n }\n \n /* Set the decl for MEM to DECL.  */\n \n void\n-set_mem_attrs_from_reg (mem, reg)\n-     rtx mem;\n-     rtx reg;\n+set_mem_attrs_from_reg (rtx mem, rtx reg)\n {\n   MEM_ATTRS (mem)\n     = get_mem_attrs (MEM_ALIAS_SET (mem), REG_EXPR (reg),\n@@ -2146,9 +2043,7 @@ set_mem_attrs_from_reg (mem, reg)\n /* Set the alias set of MEM to SET.  */\n \n void\n-set_mem_alias_set (mem, set)\n-     rtx mem;\n-     HOST_WIDE_INT set;\n+set_mem_alias_set (rtx mem, HOST_WIDE_INT set)\n {\n #ifdef ENABLE_CHECKING\n   /* If the new and old alias sets don't conflict, something is wrong.  */\n@@ -2164,9 +2059,7 @@ set_mem_alias_set (mem, set)\n /* Set the alignment of MEM to ALIGN bits.  */\n \n void\n-set_mem_align (mem, align)\n-     rtx mem;\n-     unsigned int align;\n+set_mem_align (rtx mem, unsigned int align)\n {\n   MEM_ATTRS (mem) = get_mem_attrs (MEM_ALIAS_SET (mem), MEM_EXPR (mem),\n \t\t\t\t   MEM_OFFSET (mem), MEM_SIZE (mem), align,\n@@ -2176,9 +2069,7 @@ set_mem_align (mem, align)\n /* Set the expr for MEM to EXPR.  */\n \n void\n-set_mem_expr (mem, expr)\n-     rtx mem;\n-     tree expr;\n+set_mem_expr (rtx mem, tree expr)\n {\n   MEM_ATTRS (mem)\n     = get_mem_attrs (MEM_ALIAS_SET (mem), expr, MEM_OFFSET (mem),\n@@ -2188,8 +2079,7 @@ set_mem_expr (mem, expr)\n /* Set the offset of MEM to OFFSET.  */\n \n void\n-set_mem_offset (mem, offset)\n-     rtx mem, offset;\n+set_mem_offset (rtx mem, rtx offset)\n {\n   MEM_ATTRS (mem) = get_mem_attrs (MEM_ALIAS_SET (mem), MEM_EXPR (mem),\n \t\t\t\t   offset, MEM_SIZE (mem), MEM_ALIGN (mem),\n@@ -2199,8 +2089,7 @@ set_mem_offset (mem, offset)\n /* Set the size of MEM to SIZE.  */\n \n void\n-set_mem_size (mem, size)\n-     rtx mem, size;\n+set_mem_size (rtx mem, rtx size)\n {\n   MEM_ATTRS (mem) = get_mem_attrs (MEM_ALIAS_SET (mem), MEM_EXPR (mem),\n \t\t\t\t   MEM_OFFSET (mem), size, MEM_ALIGN (mem),\n@@ -2214,11 +2103,7 @@ set_mem_size (mem, size)\n    attributes are not changed.  */\n \n static rtx\n-change_address_1 (memref, mode, addr, validate)\n-     rtx memref;\n-     enum machine_mode mode;\n-     rtx addr;\n-     int validate;\n+change_address_1 (rtx memref, enum machine_mode mode, rtx addr, int validate)\n {\n   rtx new;\n \n@@ -2252,10 +2137,7 @@ change_address_1 (memref, mode, addr, validate)\n    way we are changing MEMREF, so we only preserve the alias set.  */\n \n rtx\n-change_address (memref, mode, addr)\n-     rtx memref;\n-     enum machine_mode mode;\n-     rtx addr;\n+change_address (rtx memref, enum machine_mode mode, rtx addr)\n {\n   rtx new = change_address_1 (memref, mode, addr, 1);\n   enum machine_mode mmode = GET_MODE (new);\n@@ -2277,11 +2159,8 @@ change_address (memref, mode, addr)\n    and caller is responsible for adjusting MEMREF base register.  */\n \n rtx\n-adjust_address_1 (memref, mode, offset, validate, adjust)\n-     rtx memref;\n-     enum machine_mode mode;\n-     HOST_WIDE_INT offset;\n-     int validate, adjust;\n+adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n+\t\t  int validate, int adjust)\n {\n   rtx addr = XEXP (memref, 0);\n   rtx new;\n@@ -2343,12 +2222,8 @@ adjust_address_1 (memref, mode, offset, validate, adjust)\n    nonzero, the memory address is forced to be valid.  */\n \n rtx\n-adjust_automodify_address_1 (memref, mode, addr, offset, validate)\n-     rtx memref;\n-     enum machine_mode mode;\n-     rtx addr;\n-     HOST_WIDE_INT offset;\n-     int validate;\n+adjust_automodify_address_1 (rtx memref, enum machine_mode mode, rtx addr,\n+\t\t\t     HOST_WIDE_INT offset, int validate)\n {\n   memref = change_address_1 (memref, VOIDmode, addr, validate);\n   return adjust_address_1 (memref, mode, offset, validate, 0);\n@@ -2359,10 +2234,7 @@ adjust_automodify_address_1 (memref, mode, addr, offset, validate)\n    known to be in OFFSET (possibly 1).  */\n \n rtx\n-offset_address (memref, offset, pow2)\n-     rtx memref;\n-     rtx offset;\n-     unsigned HOST_WIDE_INT pow2;\n+offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n {\n   rtx new, addr = XEXP (memref, 0);\n \n@@ -2401,9 +2273,7 @@ offset_address (memref, offset, pow2)\n    by putting something into a register.  */\n \n rtx\n-replace_equiv_address (memref, addr)\n-     rtx memref;\n-     rtx addr;\n+replace_equiv_address (rtx memref, rtx addr)\n {\n   /* change_address_1 copies the memory attribute structure without change\n      and that's exactly what we want here.  */\n@@ -2414,9 +2284,7 @@ replace_equiv_address (memref, addr)\n /* Likewise, but the reference is not required to be valid.  */\n \n rtx\n-replace_equiv_address_nv (memref, addr)\n-     rtx memref;\n-     rtx addr;\n+replace_equiv_address_nv (rtx memref, rtx addr)\n {\n   return change_address_1 (memref, VOIDmode, addr, 0);\n }\n@@ -2427,10 +2295,7 @@ replace_equiv_address_nv (memref, addr)\n    operations plus masking logic.  */\n \n rtx\n-widen_memory_access (memref, mode, offset)\n-     rtx memref;\n-     enum machine_mode mode;\n-     HOST_WIDE_INT offset;\n+widen_memory_access (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset)\n {\n   rtx new = adjust_address_1 (memref, mode, offset, 1, 1);\n   tree expr = MEM_EXPR (new);\n@@ -2504,10 +2369,10 @@ widen_memory_access (memref, mode, offset)\n /* Return a newly created CODE_LABEL rtx with a unique label number.  */\n \n rtx\n-gen_label_rtx ()\n+gen_label_rtx (void)\n {\n   return gen_rtx_CODE_LABEL (VOIDmode, 0, NULL_RTX, NULL_RTX,\n-\t\t  \t     NULL, label_num++, NULL);\n+\t\t\t     NULL, label_num++, NULL);\n }\n \f\n /* For procedure integration.  */\n@@ -2517,8 +2382,7 @@ gen_label_rtx ()\n    Used for an inline-procedure after copying the insn chain.  */\n \n void\n-set_new_first_and_last_insn (first, last)\n-     rtx first, last;\n+set_new_first_and_last_insn (rtx first, rtx last)\n {\n   rtx insn;\n \n@@ -2536,8 +2400,7 @@ set_new_first_and_last_insn (first, last)\n    This is used when belatedly compiling an inline function.  */\n \n void\n-set_new_first_and_last_label_num (first, last)\n-     int first, last;\n+set_new_first_and_last_label_num (int first, int last)\n {\n   base_label_num = label_num;\n   first_label_num = first;\n@@ -2548,8 +2411,7 @@ set_new_first_and_last_label_num (first, last)\n    This is used when belatedly compiling an inline function.  */\n \n void\n-set_new_last_label_num (last)\n-     int last;\n+set_new_last_label_num (int last)\n {\n   base_label_num = label_num;\n   last_label_num = last;\n@@ -2559,8 +2421,7 @@ set_new_last_label_num (last)\n    This is used after a nested function.  */\n \n void\n-restore_emit_status (p)\n-     struct function *p ATTRIBUTE_UNUSED;\n+restore_emit_status (struct function *p ATTRIBUTE_UNUSED)\n {\n   last_label_num = 0;\n }\n@@ -2569,9 +2430,7 @@ restore_emit_status (p)\n    structure.  This routine should only be called once.  */\n \n void\n-unshare_all_rtl (fndecl, insn)\n-     tree fndecl;\n-     rtx insn;\n+unshare_all_rtl (tree fndecl, rtx insn)\n {\n   tree decl;\n \n@@ -2600,8 +2459,7 @@ unshare_all_rtl (fndecl, insn)\n    should be done sparingly.  */\n \n void\n-unshare_all_rtl_again (insn)\n-     rtx insn;\n+unshare_all_rtl_again (rtx insn)\n {\n   rtx p;\n   tree decl;\n@@ -2630,8 +2488,7 @@ unshare_all_rtl_again (insn)\n    Assumes the mark bits are cleared at entry.  */\n \n static void\n-unshare_all_rtl_1 (insn)\n-     rtx insn;\n+unshare_all_rtl_1 (rtx insn)\n {\n   for (; insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n@@ -2645,8 +2502,7 @@ unshare_all_rtl_1 (insn)\n /* Go through all virtual stack slots of a function and copy any\n    shared structure.  */\n static void\n-unshare_all_decls (blk)\n-     tree blk;\n+unshare_all_decls (tree blk)\n {\n   tree t;\n \n@@ -2663,8 +2519,7 @@ unshare_all_decls (blk)\n /* Go through all virtual stack slots of a function and mark them as\n    not shared.  */\n static void\n-reset_used_decls (blk)\n-     tree blk;\n+reset_used_decls (tree blk)\n {\n   tree t;\n \n@@ -2683,9 +2538,7 @@ reset_used_decls (blk)\n    either a MEM of an EXPR_LIST of MEMs.  */\n \n rtx\n-copy_most_rtx (orig, may_share)\n-     rtx orig;\n-     rtx may_share;\n+copy_most_rtx (rtx orig, rtx may_share)\n {\n   rtx copy;\n   int i, j;\n@@ -2785,8 +2638,7 @@ copy_most_rtx (orig, may_share)\n    Recursively does the same for subexpressions.  */\n \n rtx\n-copy_rtx_if_shared (orig)\n-     rtx orig;\n+copy_rtx_if_shared (rtx orig)\n {\n   rtx x = orig;\n   int i;\n@@ -2903,8 +2755,7 @@ copy_rtx_if_shared (orig)\n    to look for shared sub-parts.  */\n \n void\n-reset_used_flags (x)\n-     rtx x;\n+reset_used_flags (rtx x)\n {\n   int i, j;\n   enum rtx_code code;\n@@ -2968,8 +2819,7 @@ reset_used_flags (x)\n    OTHER must be valid as a SET_DEST.  */\n \n rtx\n-make_safe_from (x, other)\n-     rtx x, other;\n+make_safe_from (rtx x, rtx other)\n {\n   while (1)\n     switch (GET_CODE (other))\n@@ -3006,16 +2856,15 @@ make_safe_from (x, other)\n /* Return the first insn of the current sequence or current function.  */\n \n rtx\n-get_insns ()\n+get_insns (void)\n {\n   return first_insn;\n }\n \n /* Specify a new insn as the first in the chain.  */\n \n void\n-set_first_insn (insn)\n-     rtx insn;\n+set_first_insn (rtx insn)\n {\n   if (PREV_INSN (insn) != 0)\n     abort ();\n@@ -3025,16 +2874,15 @@ set_first_insn (insn)\n /* Return the last insn emitted in current sequence or current function.  */\n \n rtx\n-get_last_insn ()\n+get_last_insn (void)\n {\n   return last_insn;\n }\n \n /* Specify a new insn as the last in the chain.  */\n \n void\n-set_last_insn (insn)\n-     rtx insn;\n+set_last_insn (rtx insn)\n {\n   if (NEXT_INSN (insn) != 0)\n     abort ();\n@@ -3044,7 +2892,7 @@ set_last_insn (insn)\n /* Return the last insn emitted, even if it is in a sequence now pushed.  */\n \n rtx\n-get_last_insn_anywhere ()\n+get_last_insn_anywhere (void)\n {\n   struct sequence_stack *stack;\n   if (last_insn)\n@@ -3059,7 +2907,7 @@ get_last_insn_anywhere ()\n    function.  This routine looks inside SEQUENCEs.  */\n \n rtx\n-get_first_nonnote_insn ()\n+get_first_nonnote_insn (void)\n {\n   rtx insn = first_insn;\n \n@@ -3077,7 +2925,7 @@ get_first_nonnote_insn ()\n    function.  This routine looks inside SEQUENCEs.  */\n \n rtx\n-get_last_nonnote_insn ()\n+get_last_nonnote_insn (void)\n {\n   rtx insn = last_insn;\n \n@@ -3094,16 +2942,15 @@ get_last_nonnote_insn ()\n /* Return a number larger than any instruction's uid in this function.  */\n \n int\n-get_max_uid ()\n+get_max_uid (void)\n {\n   return cur_insn_uid;\n }\n \n /* Renumber instructions so that no instruction UIDs are wasted.  */\n \n void\n-renumber_insns (stream)\n-     FILE *stream;\n+renumber_insns (FILE *stream)\n {\n   rtx insn;\n \n@@ -3131,8 +2978,7 @@ renumber_insns (stream)\n    of the sequence.  */\n \n rtx\n-next_insn (insn)\n-     rtx insn;\n+next_insn (rtx insn)\n {\n   if (insn)\n     {\n@@ -3149,8 +2995,7 @@ next_insn (insn)\n    of the sequence.  */\n \n rtx\n-previous_insn (insn)\n-     rtx insn;\n+previous_insn (rtx insn)\n {\n   if (insn)\n     {\n@@ -3167,8 +3012,7 @@ previous_insn (insn)\n    look inside SEQUENCEs.  */\n \n rtx\n-next_nonnote_insn (insn)\n-     rtx insn;\n+next_nonnote_insn (rtx insn)\n {\n   while (insn)\n     {\n@@ -3184,8 +3028,7 @@ next_nonnote_insn (insn)\n    not look inside SEQUENCEs.  */\n \n rtx\n-prev_nonnote_insn (insn)\n-     rtx insn;\n+prev_nonnote_insn (rtx insn)\n {\n   while (insn)\n     {\n@@ -3202,8 +3045,7 @@ prev_nonnote_insn (insn)\n    SEQUENCEs.  */\n \n rtx\n-next_real_insn (insn)\n-     rtx insn;\n+next_real_insn (rtx insn)\n {\n   while (insn)\n     {\n@@ -3221,8 +3063,7 @@ next_real_insn (insn)\n    SEQUENCEs.  */\n \n rtx\n-prev_real_insn (insn)\n-     rtx insn;\n+prev_real_insn (rtx insn)\n {\n   while (insn)\n     {\n@@ -3239,7 +3080,7 @@ prev_real_insn (insn)\n    This routine does not look inside SEQUENCEs.  */\n \n rtx\n-last_call_insn ()\n+last_call_insn (void)\n {\n   rtx insn;\n \n@@ -3256,8 +3097,7 @@ last_call_insn ()\n    same as next_real_insn.  */\n \n int\n-active_insn_p (insn)\n-     rtx insn;\n+active_insn_p (rtx insn)\n {\n   return (GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == JUMP_INSN\n \t  || (GET_CODE (insn) == INSN\n@@ -3267,8 +3107,7 @@ active_insn_p (insn)\n }\n \n rtx\n-next_active_insn (insn)\n-     rtx insn;\n+next_active_insn (rtx insn)\n {\n   while (insn)\n     {\n@@ -3285,8 +3124,7 @@ next_active_insn (insn)\n    same as prev_real_insn.  */\n \n rtx\n-prev_active_insn (insn)\n-     rtx insn;\n+prev_active_insn (rtx insn)\n {\n   while (insn)\n     {\n@@ -3301,8 +3139,7 @@ prev_active_insn (insn)\n /* Return the next CODE_LABEL after the insn INSN, or 0 if there is none.  */\n \n rtx\n-next_label (insn)\n-     rtx insn;\n+next_label (rtx insn)\n {\n   while (insn)\n     {\n@@ -3317,8 +3154,7 @@ next_label (insn)\n /* Return the last CODE_LABEL before the insn INSN, or 0 if there is none.  */\n \n rtx\n-prev_label (insn)\n-     rtx insn;\n+prev_label (rtx insn)\n {\n   while (insn)\n     {\n@@ -3335,8 +3171,7 @@ prev_label (insn)\n    and REG_CC_USER notes so we can find it.  */\n \n void\n-link_cc0_insns (insn)\n-     rtx insn;\n+link_cc0_insns (rtx insn)\n {\n   rtx user = next_nonnote_insn (insn);\n \n@@ -3358,8 +3193,7 @@ link_cc0_insns (insn)\n    Return 0 if we can't find the insn.  */\n \n rtx\n-next_cc0_user (insn)\n-     rtx insn;\n+next_cc0_user (rtx insn)\n {\n   rtx note = find_reg_note (insn, REG_CC_USER, NULL_RTX);\n \n@@ -3380,8 +3214,7 @@ next_cc0_user (insn)\n    note, it is the previous insn.  */\n \n rtx\n-prev_cc0_setter (insn)\n-     rtx insn;\n+prev_cc0_setter (rtx insn)\n {\n   rtx note = find_reg_note (insn, REG_CC_SETTER, NULL_RTX);\n \n@@ -3399,8 +3232,7 @@ prev_cc0_setter (insn)\n /* Increment the label uses for all labels present in rtx.  */\n \n static void\n-mark_label_nuses (x)\n-     rtx x;\n+mark_label_nuses (rtx x)\n {\n   enum rtx_code code;\n   int i, j;\n@@ -3432,9 +3264,7 @@ mark_label_nuses (x)\n    returns TRIAL.  If the insn to be returned can be split, it will be.  */\n \n rtx\n-try_split (pat, trial, last)\n-     rtx pat, trial;\n-     int last;\n+try_split (rtx pat, rtx trial, int last)\n {\n   rtx before = PREV_INSN (trial);\n   rtx after = NEXT_INSN (trial);\n@@ -3611,8 +3441,7 @@ try_split (pat, trial, last)\n    Store PATTERN in the pattern slots.  */\n \n rtx\n-make_insn_raw (pattern)\n-     rtx pattern;\n+make_insn_raw (rtx pattern)\n {\n   rtx insn;\n \n@@ -3644,8 +3473,7 @@ make_insn_raw (pattern)\n /* Like `make_insn_raw' but make a JUMP_INSN instead of an insn.  */\n \n static rtx\n-make_jump_insn_raw (pattern)\n-     rtx pattern;\n+make_jump_insn_raw (rtx pattern)\n {\n   rtx insn;\n \n@@ -3666,8 +3494,7 @@ make_jump_insn_raw (pattern)\n /* Like `make_insn_raw' but make a CALL_INSN instead of an insn.  */\n \n static rtx\n-make_call_insn_raw (pattern)\n-     rtx pattern;\n+make_call_insn_raw (rtx pattern)\n {\n   rtx insn;\n \n@@ -3689,8 +3516,7 @@ make_call_insn_raw (pattern)\n    INSN may be an INSN, JUMP_INSN, CALL_INSN, CODE_LABEL, BARRIER or NOTE.  */\n \n void\n-add_insn (insn)\n-     rtx insn;\n+add_insn (rtx insn)\n {\n   PREV_INSN (insn) = last_insn;\n   NEXT_INSN (insn) = 0;\n@@ -3710,8 +3536,7 @@ add_insn (insn)\n    SEQUENCE.  */\n \n void\n-add_insn_after (insn, after)\n-     rtx insn, after;\n+add_insn_after (rtx insn, rtx after)\n {\n   rtx next = NEXT_INSN (after);\n   basic_block bb;\n@@ -3776,8 +3601,7 @@ add_insn_after (insn, after)\n    SEQUENCE.  */\n \n void\n-add_insn_before (insn, before)\n-     rtx insn, before;\n+add_insn_before (rtx insn, rtx before)\n {\n   rtx prev = PREV_INSN (before);\n   basic_block bb;\n@@ -3839,8 +3663,7 @@ add_insn_before (insn, before)\n /* Remove an insn from its doubly-linked list.  This function knows how\n    to handle sequences.  */\n void\n-remove_insn (insn)\n-     rtx insn;\n+remove_insn (rtx insn)\n {\n   rtx next = NEXT_INSN (insn);\n   rtx prev = PREV_INSN (insn);\n@@ -3915,8 +3738,7 @@ remove_insn (insn)\n /* Append CALL_FUSAGE to the CALL_INSN_FUNCTION_USAGE for CALL_INSN.  */\n \n void\n-add_function_usage_to (call_insn, call_fusage)\n-     rtx call_insn, call_fusage;\n+add_function_usage_to (rtx call_insn, rtx call_fusage)\n {\n   if (! call_insn || GET_CODE (call_insn) != CALL_INSN)\n     abort ();\n@@ -3941,8 +3763,7 @@ add_function_usage_to (call_insn, call_fusage)\n    FROM becomes the new last instruction.  */\n \n void\n-delete_insns_since (from)\n-     rtx from;\n+delete_insns_since (rtx from)\n {\n   if (from == 0)\n     first_insn = 0;\n@@ -3962,8 +3783,7 @@ delete_insns_since (from)\n    called after delay-slot filling has been done.  */\n \n void\n-reorder_insns_nobb (from, to, after)\n-     rtx from, to, after;\n+reorder_insns_nobb (rtx from, rtx to, rtx after)\n {\n   /* Splice this bunch out of where it is now.  */\n   if (PREV_INSN (from))\n@@ -3988,8 +3808,7 @@ reorder_insns_nobb (from, to, after)\n \n /* Same as function above, but take care to update BB boundaries.  */\n void\n-reorder_insns (from, to, after)\n-     rtx from, to, after;\n+reorder_insns (rtx from, rtx to, rtx after)\n {\n   rtx prev = PREV_INSN (from);\n   basic_block bb, bb2;\n@@ -4021,8 +3840,7 @@ reorder_insns (from, to, after)\n /* Return the line note insn preceding INSN.  */\n \n static rtx\n-find_line_note (insn)\n-     rtx insn;\n+find_line_note (rtx insn)\n {\n   if (no_line_numbers)\n     return 0;\n@@ -4040,8 +3858,7 @@ find_line_note (insn)\n    and FROM, and another one after TO.  */\n \n void\n-reorder_insns_with_line_notes (from, to, after)\n-     rtx from, to, after;\n+reorder_insns_with_line_notes (rtx from, rtx to, rtx after)\n {\n   rtx from_line = find_line_note (from);\n   rtx after_line = find_line_note (after);\n@@ -4064,7 +3881,7 @@ reorder_insns_with_line_notes (from, to, after)\n /* Remove unnecessary notes from the instruction stream.  */\n \n void\n-remove_unnecessary_notes ()\n+remove_unnecessary_notes (void)\n {\n   rtx block_stack = NULL_RTX;\n   rtx eh_stack = NULL_RTX;\n@@ -4202,8 +4019,7 @@ remove_unnecessary_notes ()\n /* Make X be output before the instruction BEFORE.  */\n \n rtx\n-emit_insn_before (x, before)\n-     rtx x, before;\n+emit_insn_before (rtx x, rtx before)\n {\n   rtx last = before;\n   rtx insn;\n@@ -4253,8 +4069,7 @@ emit_insn_before (x, before)\n    and output it before the instruction BEFORE.  */\n \n rtx\n-emit_jump_insn_before (x, before)\n-     rtx x, before;\n+emit_jump_insn_before (rtx x, rtx before)\n {\n   rtx insn, last = NULL_RTX;\n \n@@ -4300,8 +4115,7 @@ emit_jump_insn_before (x, before)\n    and output it before the instruction BEFORE.  */\n \n rtx\n-emit_call_insn_before (x, before)\n-     rtx x, before;\n+emit_call_insn_before (rtx x, rtx before)\n {\n   rtx last = NULL_RTX, insn;\n \n@@ -4347,8 +4161,7 @@ emit_call_insn_before (x, before)\n    and output it before the insn BEFORE.  */\n \n rtx\n-emit_barrier_before (before)\n-     rtx before;\n+emit_barrier_before (rtx before)\n {\n   rtx insn = rtx_alloc (BARRIER);\n \n@@ -4361,8 +4174,7 @@ emit_barrier_before (before)\n /* Emit the label LABEL before the insn BEFORE.  */\n \n rtx\n-emit_label_before (label, before)\n-     rtx label, before;\n+emit_label_before (rtx label, rtx before)\n {\n   /* This can be called twice for the same label as a result of the\n      confusion that follows a syntax error!  So make it harmless.  */\n@@ -4378,9 +4190,7 @@ emit_label_before (label, before)\n /* Emit a note of subtype SUBTYPE before the insn BEFORE.  */\n \n rtx\n-emit_note_before (subtype, before)\n-     int subtype;\n-     rtx before;\n+emit_note_before (int subtype, rtx before)\n {\n   rtx note = rtx_alloc (NOTE);\n   INSN_UID (note) = cur_insn_uid++;\n@@ -4395,11 +4205,10 @@ emit_note_before (subtype, before)\n /* Helper for emit_insn_after, handles lists of instructions\n    efficiently.  */\n \n-static rtx emit_insn_after_1 PARAMS ((rtx, rtx));\n+static rtx emit_insn_after_1 (rtx, rtx);\n \n static rtx\n-emit_insn_after_1 (first, after)\n-     rtx first, after;\n+emit_insn_after_1 (rtx first, rtx after)\n {\n   rtx last;\n   rtx after_after;\n@@ -4437,8 +4246,7 @@ emit_insn_after_1 (first, after)\n /* Make X be output after the insn AFTER.  */\n \n rtx\n-emit_insn_after (x, after)\n-     rtx x, after;\n+emit_insn_after (rtx x, rtx after)\n {\n   rtx last = after;\n \n@@ -4480,8 +4288,7 @@ emit_insn_after (x, after)\n    as to act as if this insn were at FROM.  */\n \n void\n-emit_insn_after_with_line_notes (x, after, from)\n-     rtx x, after, from;\n+emit_insn_after_with_line_notes (rtx x, rtx after, rtx from)\n {\n   rtx from_line = find_line_note (from);\n   rtx after_line = find_line_note (after);\n@@ -4502,8 +4309,7 @@ emit_insn_after_with_line_notes (x, after, from)\n    and output it after the insn AFTER.  */\n \n rtx\n-emit_jump_insn_after (x, after)\n-     rtx x, after;\n+emit_jump_insn_after (rtx x, rtx after)\n {\n   rtx last;\n \n@@ -4542,8 +4348,7 @@ emit_jump_insn_after (x, after)\n    and output it after the instruction AFTER.  */\n \n rtx\n-emit_call_insn_after (x, after)\n-     rtx x, after;\n+emit_call_insn_after (rtx x, rtx after)\n {\n   rtx last;\n \n@@ -4582,8 +4387,7 @@ emit_call_insn_after (x, after)\n    and output it after the insn AFTER.  */\n \n rtx\n-emit_barrier_after (after)\n-     rtx after;\n+emit_barrier_after (rtx after)\n {\n   rtx insn = rtx_alloc (BARRIER);\n \n@@ -4596,8 +4400,7 @@ emit_barrier_after (after)\n /* Emit the label LABEL after the insn AFTER.  */\n \n rtx\n-emit_label_after (label, after)\n-     rtx label, after;\n+emit_label_after (rtx label, rtx after)\n {\n   /* This can be called twice for the same label\n      as a result of the confusion that follows a syntax error!\n@@ -4614,9 +4417,7 @@ emit_label_after (label, after)\n /* Emit a note of subtype SUBTYPE after the insn AFTER.  */\n \n rtx\n-emit_note_after (subtype, after)\n-     int subtype;\n-     rtx after;\n+emit_note_after (int subtype, rtx after)\n {\n   rtx note = rtx_alloc (NOTE);\n   INSN_UID (note) = cur_insn_uid++;\n@@ -4630,10 +4431,7 @@ emit_note_after (subtype, after)\n /* Emit a line note for FILE and LINE after the insn AFTER.  */\n \n rtx\n-emit_line_note_after (file, line, after)\n-     const char *file;\n-     int line;\n-     rtx after;\n+emit_line_note_after (const char *file, int line, rtx after)\n {\n   rtx note;\n \n@@ -4656,9 +4454,7 @@ emit_line_note_after (file, line, after)\n \f\n /* Like emit_insn_after, but set INSN_LOCATOR according to SCOPE.  */\n rtx\n-emit_insn_after_setloc (pattern, after, loc)\n-     rtx pattern, after;\n-     int loc;\n+emit_insn_after_setloc (rtx pattern, rtx after, int loc)\n {\n   rtx last = emit_insn_after (pattern, after);\n \n@@ -4676,9 +4472,7 @@ emit_insn_after_setloc (pattern, after, loc)\n \n /* Like emit_jump_insn_after, but set INSN_LOCATOR according to SCOPE.  */\n rtx\n-emit_jump_insn_after_setloc (pattern, after, loc)\n-     rtx pattern, after;\n-     int loc;\n+emit_jump_insn_after_setloc (rtx pattern, rtx after, int loc)\n {\n   rtx last = emit_jump_insn_after (pattern, after);\n \n@@ -4696,9 +4490,7 @@ emit_jump_insn_after_setloc (pattern, after, loc)\n \n /* Like emit_call_insn_after, but set INSN_LOCATOR according to SCOPE.  */\n rtx\n-emit_call_insn_after_setloc (pattern, after, loc)\n-     rtx pattern, after;\n-     int loc;\n+emit_call_insn_after_setloc (rtx pattern, rtx after, int loc)\n {\n   rtx last = emit_call_insn_after (pattern, after);\n \n@@ -4716,9 +4508,7 @@ emit_call_insn_after_setloc (pattern, after, loc)\n \n /* Like emit_insn_before, but set INSN_LOCATOR according to SCOPE.  */\n rtx\n-emit_insn_before_setloc (pattern, before, loc)\n-     rtx pattern, before;\n-     int loc;\n+emit_insn_before_setloc (rtx pattern, rtx before, int loc)\n {\n   rtx first = PREV_INSN (before);\n   rtx last = emit_insn_before (pattern, before);\n@@ -4741,8 +4531,7 @@ emit_insn_before_setloc (pattern, before, loc)\n    Returns the last insn emitted.  */\n \n rtx\n-emit_insn (x)\n-     rtx x;\n+emit_insn (rtx x)\n {\n   rtx last = last_insn;\n   rtx insn;\n@@ -4787,8 +4576,7 @@ emit_insn (x)\n    and add it to the end of the doubly-linked list.  */\n \n rtx\n-emit_jump_insn (x)\n-     rtx x;\n+emit_jump_insn (rtx x)\n {\n   rtx last = NULL_RTX, insn;\n \n@@ -4829,8 +4617,7 @@ emit_jump_insn (x)\n    and add it to the end of the doubly-linked list.  */\n \n rtx\n-emit_call_insn (x)\n-     rtx x;\n+emit_call_insn (rtx x)\n {\n   rtx insn;\n \n@@ -4863,8 +4650,7 @@ emit_call_insn (x)\n /* Add the label LABEL to the end of the doubly-linked list.  */\n \n rtx\n-emit_label (label)\n-     rtx label;\n+emit_label (rtx label)\n {\n   /* This can be called twice for the same label\n      as a result of the confusion that follows a syntax error!\n@@ -4881,7 +4667,7 @@ emit_label (label)\n    and add it to the end of the doubly-linked list.  */\n \n rtx\n-emit_barrier ()\n+emit_barrier (void)\n {\n   rtx barrier = rtx_alloc (BARRIER);\n   INSN_UID (barrier) = cur_insn_uid++;\n@@ -4895,15 +4681,13 @@ emit_barrier ()\n    but only if line-numbers are desired for debugging info.  */\n \n rtx\n-emit_line_note (file, line)\n-     const char *file;\n-     int line;\n+emit_line_note (const char *file, int line)\n {\n   rtx note;\n-  \n+\n   if (line < 0)\n     abort ();\n-  \n+\n   set_file_and_line_for_stmt (file, line);\n \n   if (file && last_location.file && !strcmp (file, last_location.file)\n@@ -4920,16 +4704,15 @@ emit_line_note (file, line)\n \n   note = emit_note (line);\n   NOTE_SOURCE_FILE (note) = file;\n-  \n+\n   return note;\n }\n \n /* Make an insn of code NOTE or type NOTE_NO\n    and add it to the end of the doubly-linked list.  */\n \n rtx\n-emit_note (note_no)\n-     int note_no;\n+emit_note (int note_no)\n {\n   rtx note;\n \n@@ -4945,9 +4728,7 @@ emit_note (note_no)\n /* Emit a NOTE, and don't omit it even if LINE is the previous note.  */\n \n rtx\n-emit_line_note_force (file, line)\n-     const char *file;\n-     int line;\n+emit_line_note_force (const char *file, int line)\n {\n   last_location.line = -1;\n   return emit_line_note (file, line);\n@@ -4957,7 +4738,7 @@ emit_line_note_force (file, line)\n    has not changed.  This is used at the beginning of a function.  */\n \n void\n-force_next_line_note ()\n+force_next_line_note (void)\n {\n   last_location.line = -1;\n }\n@@ -4966,10 +4747,7 @@ force_next_line_note ()\n    note of this type already exists, remove it first.  */\n \n rtx\n-set_unique_reg_note (insn, kind, datum)\n-     rtx insn;\n-     enum reg_note kind;\n-     rtx datum;\n+set_unique_reg_note (rtx insn, enum reg_note kind, rtx datum)\n {\n   rtx note = find_reg_note (insn, kind, NULL_RTX);\n \n@@ -5012,8 +4790,7 @@ set_unique_reg_note (insn, kind, datum)\n    The value is CODE_LABEL, INSN, CALL_INSN or JUMP_INSN.  */\n \n enum rtx_code\n-classify_insn (x)\n-     rtx x;\n+classify_insn (rtx x)\n {\n   if (GET_CODE (x) == CODE_LABEL)\n     return CODE_LABEL;\n@@ -5050,8 +4827,7 @@ classify_insn (x)\n    If X is a label, it is simply added into the insn chain.  */\n \n rtx\n-emit (x)\n-     rtx x;\n+emit (rtx x)\n {\n   enum rtx_code code = classify_insn (x);\n \n@@ -5084,7 +4860,7 @@ static GTY ((deletable (\"\"))) struct sequence_stack *free_sequence_stack;\n    emitted in the middle of this sequence.  */\n \n void\n-start_sequence ()\n+start_sequence (void)\n {\n   struct sequence_stack *tem;\n \n@@ -5112,8 +4888,7 @@ start_sequence ()\n    information about how to use this function.  */\n \n void\n-start_sequence_for_rtl_expr (t)\n-     tree t;\n+start_sequence_for_rtl_expr (tree t)\n {\n   start_sequence ();\n \n@@ -5125,8 +4900,7 @@ start_sequence_for_rtl_expr (t)\n    start_sequence for more information about how to use this function.  */\n \n void\n-push_to_sequence (first)\n-     rtx first;\n+push_to_sequence (rtx first)\n {\n   rtx last;\n \n@@ -5141,8 +4915,7 @@ push_to_sequence (first)\n /* Set up the insn chain from a chain stort in FIRST to LAST.  */\n \n void\n-push_to_full_sequence (first, last)\n-     rtx first, last;\n+push_to_full_sequence (rtx first, rtx last)\n {\n   start_sequence ();\n   first_insn = first;\n@@ -5156,7 +4929,7 @@ push_to_full_sequence (first, last)\n    as the current sequence, saving the previously current one.  */\n \n void\n-push_topmost_sequence ()\n+push_topmost_sequence (void)\n {\n   struct sequence_stack *stack, *top = NULL;\n \n@@ -5174,7 +4947,7 @@ push_topmost_sequence ()\n    insn chain, and restore the previous saved state.  */\n \n void\n-pop_topmost_sequence ()\n+pop_topmost_sequence (void)\n {\n   struct sequence_stack *stack, *top = NULL;\n \n@@ -5202,7 +4975,7 @@ pop_topmost_sequence ()\n    information about deferred popping of arguments.  */\n \n void\n-end_sequence ()\n+end_sequence (void)\n {\n   struct sequence_stack *tem = seq_stack;\n \n@@ -5220,8 +4993,7 @@ end_sequence ()\n    and LAST.  */\n \n void\n-end_full_sequence (first, last)\n-     rtx *first, *last;\n+end_full_sequence (rtx *first, rtx *last)\n {\n   *first = first_insn;\n   *last = last_insn;\n@@ -5231,16 +5003,15 @@ end_full_sequence (first, last)\n /* Return 1 if currently emitting into a sequence.  */\n \n int\n-in_sequence_p ()\n+in_sequence_p (void)\n {\n   return seq_stack != 0;\n }\n \f\n /* Put the various virtual registers into REGNO_REG_RTX.  */\n \n void\n-init_virtual_regs (es)\n-     struct emit_status *es;\n+init_virtual_regs (struct emit_status *es)\n {\n   rtx *ptr = es->x_regno_reg_rtx;\n   ptr[VIRTUAL_INCOMING_ARGS_REGNUM] = virtual_incoming_args_rtx;\n@@ -5279,8 +5050,7 @@ static rtvec copy_asm_constraints_vector;\n    SCRATCHes.  */\n \n rtx\n-copy_insn_1 (orig)\n-     rtx orig;\n+copy_insn_1 (rtx orig)\n {\n   rtx copy;\n   int i, j;\n@@ -5413,8 +5183,7 @@ copy_insn_1 (orig)\n    INSN doesn't really have to be a full INSN; it could be just the\n    pattern.  */\n rtx\n-copy_insn (insn)\n-     rtx insn;\n+copy_insn (rtx insn)\n {\n   copy_insn_n_scratches = 0;\n   orig_asm_operands_vector = 0;\n@@ -5428,7 +5197,7 @@ copy_insn (insn)\n    before generating rtl for each function.  */\n \n void\n-init_emit ()\n+init_emit (void)\n {\n   struct function *f = cfun;\n \n@@ -5497,8 +5266,7 @@ init_emit ()\n /* Generate the constant 0.  */\n \n static rtx\n-gen_const_vector_0 (mode)\n-     enum machine_mode mode;\n+gen_const_vector_0 (enum machine_mode mode)\n {\n   rtx tem;\n   rtvec v;\n@@ -5524,9 +5292,7 @@ gen_const_vector_0 (mode)\n /* Generate a vector like gen_rtx_raw_CONST_VEC, but use the zero vector when\n    all elements are zero.  */\n rtx\n-gen_rtx_CONST_VECTOR (mode, v)\n-     enum machine_mode mode;\n-     rtvec v;\n+gen_rtx_CONST_VECTOR (enum machine_mode mode, rtvec v)\n {\n   rtx inner_zero = CONST0_RTX (GET_MODE_INNER (mode));\n   int i;\n@@ -5541,8 +5307,7 @@ gen_rtx_CONST_VECTOR (mode, v)\n    LINE_NUMBERS is nonzero if line numbers are to be generated.  */\n \n void\n-init_emit_once (line_numbers)\n-     int line_numbers;\n+init_emit_once (int line_numbers)\n {\n   int i;\n   enum machine_mode mode;\n@@ -5743,7 +5508,7 @@ init_emit_once (line_numbers)\n    warnings about unreachable code.  */\n \n int\n-force_line_numbers ()\n+force_line_numbers (void)\n {\n   int old = no_line_numbers;\n \n@@ -5754,8 +5519,7 @@ force_line_numbers ()\n }\n \n void\n-restore_line_number_status (old_value)\n-     int old_value;\n+restore_line_number_status (int old_value)\n {\n   no_line_numbers = old_value;\n }\n@@ -5764,8 +5528,7 @@ restore_line_number_status (old_value)\n    Care updating of libcall regions if present.  */\n \n rtx\n-emit_copy_of_insn_after (insn, after)\n-     rtx insn, after;\n+emit_copy_of_insn_after (rtx insn, rtx after)\n {\n   rtx new;\n   rtx note1, note2, link;"}, {"sha": "1d5cd26d25ad990f778f887d721517f4a8f46c28", "filename": "gcc/et-forest.c", "status": "modified", "additions": 42, "deletions": 63, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2Fet-forest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2Fet-forest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.c?ref=502b832280c67d89300d92b91e73a9d3093db4a8", "patch": "@@ -1,6 +1,6 @@\n /* ET-trees datastructure implementation.\n    Contributed by Pavel Nejedly\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of the libiberty library.\n Libiberty is free software; you can redistribute it and/or\n@@ -16,7 +16,7 @@ Library General Public License for more details.\n You should have received a copy of the GNU Library General Public\n License along with libiberty; see the file COPYING.LIB.  If\n not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  \n+Boston, MA 02111-1307, USA.\n \n   The ET-forest structure is described in:\n     D. D. Sleator and R. E. Tarjan. A data structure for dynamic trees.\n@@ -42,7 +42,7 @@ struct et_forest\n   alloc_pool occur_pool;\n };\n \n-/* Single occurrence of node in ET-forest.  \n+/* Single occurrence of node in ET-forest.\n    A single node may have multiple occurrences.\n  */\n struct et_forest_occurrence\n@@ -75,18 +75,17 @@ struct et_forest_node\n };\n \n \n-static et_forest_occurrence_t splay PARAMS ((et_forest_occurrence_t));\n-static void remove_all_occurrences PARAMS ((et_forest_t, et_forest_node_t));\n-static inline et_forest_occurrence_t find_leftmost_node \n-                               PARAMS ((et_forest_occurrence_t));\n-static inline et_forest_occurrence_t find_rightmost_node \n-                               PARAMS ((et_forest_occurrence_t));\n-static int calculate_value PARAMS ((et_forest_occurrence_t));\n+static et_forest_occurrence_t splay (et_forest_occurrence_t);\n+static void remove_all_occurrences (et_forest_t, et_forest_node_t);\n+static inline et_forest_occurrence_t find_leftmost_node\n+  (et_forest_occurrence_t);\n+static inline et_forest_occurrence_t find_rightmost_node\n+  (et_forest_occurrence_t);\n+static int calculate_value (et_forest_occurrence_t);\n \n /* Return leftmost node present in the tree roted by OCC.  */\n static inline et_forest_occurrence_t\n-find_leftmost_node (occ)\n-     et_forest_occurrence_t occ;\n+find_leftmost_node (et_forest_occurrence_t occ)\n {\n   while (occ->left)\n     occ = occ->left;\n@@ -96,8 +95,7 @@ find_leftmost_node (occ)\n \n /* Return rightmost node present in the tree roted by OCC.  */\n static inline et_forest_occurrence_t\n-find_rightmost_node (occ)\n-     et_forest_occurrence_t occ;\n+find_rightmost_node (et_forest_occurrence_t occ)\n {\n   while (occ->right)\n     occ = occ->right;\n@@ -107,8 +105,7 @@ find_rightmost_node (occ)\n \n /* Operation splay for splay tree structure representing occurrences.  */\n static et_forest_occurrence_t\n-splay (node)\n-     et_forest_occurrence_t node;\n+splay (et_forest_occurrence_t node)\n {\n   et_forest_occurrence_t parent;\n   et_forest_occurrence_t grandparent;\n@@ -276,7 +273,7 @@ splay (node)\n \t\t}\n \t    }\n \t}\n-\t  \n+\n     }\n \n   /* parent == root.  */\n@@ -286,7 +283,7 @@ splay (node)\n     {\n       et_forest_occurrence_t node1;\n       int count1;\n-      \n+\n       node1 = node->right;\n       count1 = node->count_right;\n \n@@ -306,13 +303,13 @@ splay (node)\n \t  else\n \t    node->parent->right = node;\n \t}\n-    } \n-  else \n+    }\n+  else\n     {\n       /* node == parent->right.  */\n       et_forest_occurrence_t node1;\n       int count1;\n-      \n+\n       node1 = node->left;\n       count1 = node->count_left;\n \n@@ -339,9 +336,7 @@ splay (node)\n \n /* Remove all occurrences of the given node before destroying the node.  */\n static void\n-remove_all_occurrences (forest, forest_node)\n-     et_forest_t forest;\n-     et_forest_node_t forest_node;\n+remove_all_occurrences (et_forest_t forest, et_forest_node_t forest_node)\n {\n   et_forest_occurrence_t first = forest_node->first;\n   et_forest_occurrence_t last = forest_node->last;\n@@ -352,7 +347,7 @@ remove_all_occurrences (forest, forest_node)\n   if (first->left)\n     first->left->parent = 0;\n   if (first->right)\n-    first->right->parent = 0;   \n+    first->right->parent = 0;\n \n   if (last != first)\n     {\n@@ -416,8 +411,7 @@ remove_all_occurrences (forest, forest_node)\n \n /* Calculate ET value of the given node.  */\n static inline int\n-calculate_value (node)\n-     et_forest_occurrence_t node;\n+calculate_value (et_forest_occurrence_t node)\n {\n   int value = node->count_left;\n \n@@ -437,7 +431,7 @@ calculate_value (node)\n \n /* Create ET-forest structure.  */\n et_forest_t\n-et_forest_create ()\n+et_forest_create (void)\n {\n   et_forest_t forest = xmalloc (sizeof (struct et_forest));\n \n@@ -450,9 +444,8 @@ et_forest_create ()\n \n \n /* Deallocate the structure.  */\n-void \n-et_forest_delete (forest)\n-     et_forest_t forest;\n+void\n+et_forest_delete (et_forest_t forest)\n {\n   if (forest->nnodes)\n     abort ();\n@@ -464,9 +457,7 @@ et_forest_delete (forest)\n /* Create new node with VALUE and return the edge.\n    Return NULL when memory allocation failed.  */\n et_forest_node_t\n-et_forest_add_node (forest, value)\n-     et_forest_t forest;\n-     void *value;\n+et_forest_add_node (et_forest_t forest, void *value)\n {\n   /* Create node with one occurrence.  */\n   et_forest_node_t node;\n@@ -489,10 +480,8 @@ et_forest_add_node (forest, value)\n /* Add new edge to the tree, return 1 if successful.\n    0 indicates that creation of the edge will close the cycle in graph.  */\n int\n-et_forest_add_edge (forest, parent_node, child_node)\n-     et_forest_t forest ATTRIBUTE_UNUSED;\n-     et_forest_node_t parent_node;\n-     et_forest_node_t child_node;\n+et_forest_add_edge (et_forest_t forest ATTRIBUTE_UNUSED,\n+\t\t    et_forest_node_t parent_node, et_forest_node_t child_node)\n {\n   et_forest_occurrence_t new_occ, parent_occ, child_occ;\n \n@@ -510,7 +499,7 @@ et_forest_add_edge (forest, parent_node, child_node)\n \n   if (child_occ->left)\n     abort ();  /* child must be root of its containing tree.  */\n-  \n+\n   new_occ = pool_alloc (forest->occur_pool);\n \n   new_occ->node = parent_node;\n@@ -534,9 +523,7 @@ et_forest_add_edge (forest, parent_node, child_node)\n \n /* Remove NODE from the tree and all connected edges.  */\n void\n-et_forest_remove_node (forest, node)\n-     et_forest_t forest;\n-     et_forest_node_t node;\n+et_forest_remove_node (et_forest_t forest, et_forest_node_t node)\n {\n   remove_all_occurrences (forest, node);\n   forest->nnodes--;\n@@ -547,10 +534,9 @@ et_forest_remove_node (forest, node)\n /* Remove edge from the tree, return 1 if successful,\n    0 indicates nonexisting edge.  */\n int\n-et_forest_remove_edge (forest, parent_node, child_node)\n-     et_forest_t forest ATTRIBUTE_UNUSED;\n-     et_forest_node_t parent_node;\n-     et_forest_node_t child_node;\n+et_forest_remove_edge (et_forest_t forest ATTRIBUTE_UNUSED,\n+\t\t       et_forest_node_t parent_node,\n+\t\t       et_forest_node_t child_node)\n {\n   et_forest_occurrence_t parent_pre_occ, parent_post_occ;\n \n@@ -565,7 +551,7 @@ et_forest_remove_edge (forest, parent_node, child_node)\n \n   splay (parent_pre_occ);\n   parent_pre_occ->right->parent = 0;\n-  \n+\n   parent_post_occ = parent_pre_occ->next;\n   splay (parent_post_occ);\n \n@@ -587,9 +573,7 @@ et_forest_remove_edge (forest, parent_node, child_node)\n \n /* Return the parent of the NODE if any, NULL otherwise.  */\n et_forest_node_t\n-et_forest_parent (forest, node)\n-     et_forest_t forest ATTRIBUTE_UNUSED;\n-     et_forest_node_t node;\n+et_forest_parent (et_forest_t forest ATTRIBUTE_UNUSED, et_forest_node_t node)\n {\n   splay (node->first);\n \n@@ -603,17 +587,15 @@ et_forest_parent (forest, node)\n /* Return nearest common ancestor of NODE1 and NODE2.\n    Return NULL of they are in different trees.  */\n et_forest_node_t\n-et_forest_common_ancestor (forest, node1, node2)\n-     et_forest_t forest ATTRIBUTE_UNUSED;\n-     et_forest_node_t node1;\n-     et_forest_node_t node2;\n+et_forest_common_ancestor (et_forest_t forest ATTRIBUTE_UNUSED,\n+\t\t\t   et_forest_node_t node1, et_forest_node_t node2)\n {\n   int value1, value2, max_value;\n   et_forest_node_t ancestor;\n \n   if (node1 == node2)\n     return node1;\n-  \n+\n   if (! node1 || ! node2)\n     abort ();\n \n@@ -636,7 +618,7 @@ et_forest_common_ancestor (forest, node1, node2)\n       ancestor = node2;\n       max_value = value1;\n     }\n-  \n+\n   while (calculate_value (ancestor->last) < max_value)\n     {\n       /* Find parent node.  */\n@@ -649,9 +631,8 @@ et_forest_common_ancestor (forest, node1, node2)\n \n /* Return the value pointer of node set during it's creation.  */\n void *\n-et_forest_node_value (forest, node)\n-     et_forest_t forest ATTRIBUTE_UNUSED;\n-     et_forest_node_t node;\n+et_forest_node_value (et_forest_t forest ATTRIBUTE_UNUSED,\n+\t\t      et_forest_node_t node)\n {\n   /* Alloc threading NULL as a special node of the forest.  */\n   if (!node)\n@@ -662,10 +643,8 @@ et_forest_node_value (forest, node)\n /* Find all sons of NODE and store them into ARRAY allocated by the caller.\n    Return number of nodes found.  */\n int\n-et_forest_enumerate_sons (forest, node, array)\n-     et_forest_t forest ATTRIBUTE_UNUSED;\n-     et_forest_node_t node;\n-     et_forest_node_t *array;\n+et_forest_enumerate_sons (et_forest_t forest ATTRIBUTE_UNUSED,\n+\t\t\t  et_forest_node_t node, et_forest_node_t *array)\n {\n   int n = 0;\n   et_forest_occurrence_t occ = node->first, stop = node->last, occ1;"}, {"sha": "b4ac5500ca88ce96e5ca643e22c9f7ac41936e96", "filename": "gcc/et-forest.h", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2Fet-forest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2Fet-forest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.h?ref=502b832280c67d89300d92b91e73a9d3093db4a8", "patch": "@@ -1,5 +1,5 @@\n-/* Et-forest data structure implementation.  \n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+/* Et-forest data structure implementation.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n@@ -15,32 +15,32 @@ You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n-/* This package implements ET forest data structure. Each tree in \n+/* This package implements ET forest data structure. Each tree in\n    the structure maintains a tree structure and offers logarithmic time\n    for tree operations (insertion and removal of nodes and edges) and\n    poly-logarithmic time for nearest common ancestor.\n- \n-   ET tree strores its structue as a sequence of symbols obtained \n+\n+   ET tree strores its structue as a sequence of symbols obtained\n    by dfs(root)\n \n-   dfs (node) \n+   dfs (node)\n    {\n      s = node;\n      for each child c of node do\n        s = concat (s, c, node);\n      return s;\n    }\n-   \n+\n    For example for tree\n- \n+\n             1\n           / | \\\n          2  3  4\n        / |\n       4  5\n- \n+\n    the sequence is 1 2 4 2 5 3 1 3 1 4 1.\n- \n+\n    The sequence is stored in a sligtly modified splay tree.\n    In order to support various types of node values, a hashtable\n    is used to convert node values to the internal representation.  */\n@@ -58,23 +58,23 @@ extern \"C\" {\n typedef struct et_forest *et_forest_t;\n typedef struct et_forest_node *et_forest_node_t;\n \n-extern et_forest_t et_forest_create PARAMS ((void));\n-\n-extern void et_forest_delete PARAMS ((et_forest_t));\n-\n-extern et_forest_node_t et_forest_add_node PARAMS ((et_forest_t, void *));\n-extern int et_forest_add_edge PARAMS ((et_forest_t, et_forest_node_t, \n-\t\t\t\t\tet_forest_node_t));\n-extern void et_forest_remove_node PARAMS ((et_forest_t, et_forest_node_t));\n-extern int et_forest_remove_edge PARAMS ((et_forest_t, et_forest_node_t,\n-\t\t\t\t\t   et_forest_node_t));\n-extern et_forest_node_t et_forest_parent PARAMS ((et_forest_t, et_forest_node_t));\n-extern et_forest_node_t et_forest_common_ancestor PARAMS ((et_forest_t,\n-\t\t\t\t\t\t\t  et_forest_node_t,\n-\t\t\t\t\t\t\t  et_forest_node_t));\n-extern void * et_forest_node_value PARAMS ((et_forest_t, et_forest_node_t));\n-extern int et_forest_enumerate_sons PARAMS ((et_forest_t, et_forest_node_t,\n-\t\t\t\t\t     et_forest_node_t *));\n+extern et_forest_t et_forest_create (void);\n+\n+extern void et_forest_delete (et_forest_t);\n+\n+extern et_forest_node_t et_forest_add_node (et_forest_t, void *);\n+extern int et_forest_add_edge (et_forest_t, et_forest_node_t,\n+\t\t\t       et_forest_node_t);\n+extern void et_forest_remove_node (et_forest_t, et_forest_node_t);\n+extern int et_forest_remove_edge (et_forest_t, et_forest_node_t,\n+\t\t\t\t  et_forest_node_t);\n+extern et_forest_node_t et_forest_parent (et_forest_t, et_forest_node_t);\n+extern et_forest_node_t et_forest_common_ancestor (et_forest_t,\n+\t\t\t\t\t\t   et_forest_node_t,\n+\t\t\t\t\t\t   et_forest_node_t);\n+extern void * et_forest_node_value (et_forest_t, et_forest_node_t);\n+extern int et_forest_enumerate_sons (et_forest_t, et_forest_node_t,\n+\t\t\t\t     et_forest_node_t *);\n \n #ifdef __cplusplus\n }"}, {"sha": "63a35702b9130a8c94b7648ce6f54113428d50b3", "filename": "gcc/except.c", "status": "modified", "additions": 158, "deletions": 253, "changes": 411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=502b832280c67d89300d92b91e73a9d3093db4a8", "patch": "@@ -1,6 +1,6 @@\n /* Implements exception handling.\n    Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Mike Stump <mrs@cygnus.com>.\n \n This file is part of GCC.\n@@ -86,13 +86,13 @@ int flag_non_call_exceptions;\n \n /* Protect cleanup actions with must-not-throw regions, with a call\n    to the given failure handler.  */\n-tree (*lang_protect_cleanup_actions) PARAMS ((void));\n+tree (*lang_protect_cleanup_actions) (void);\n \n /* Return true if type A catches type B.  */\n-int (*lang_eh_type_covers) PARAMS ((tree a, tree b));\n+int (*lang_eh_type_covers) (tree a, tree b);\n \n /* Map a type to a runtime object to match type.  */\n-tree (*lang_eh_runtime_type) PARAMS ((tree));\n+tree (*lang_eh_runtime_type) (tree);\n \n /* A hash table of label to region number.  */\n \n@@ -241,7 +241,7 @@ struct eh_status GTY(())\n \n   htab_t GTY ((param_is (struct ehl_map_entry))) exception_handler_label_map;\n \n-  struct call_site_record * GTY ((length (\"%h.call_site_data_used\"))) \n+  struct call_site_record * GTY ((length (\"%h.call_site_data_used\")))\n     call_site_data;\n   int call_site_data_used;\n   int call_site_data_size;\n@@ -255,61 +255,50 @@ struct eh_status GTY(())\n };\n \n \f\n-static int t2r_eq\t\t\t\tPARAMS ((const void *,\n-\t\t\t\t\t\t\t const void *));\n-static hashval_t t2r_hash\t\t\tPARAMS ((const void *));\n-static void add_type_for_runtime\t\tPARAMS ((tree));\n-static tree lookup_type_for_runtime\t\tPARAMS ((tree));\n-\n-static struct eh_region *expand_eh_region_end\tPARAMS ((void));\n-\n-static rtx get_exception_filter\t\t\tPARAMS ((struct function *));\n-\n-static void collect_eh_region_array\t\tPARAMS ((void));\n-static void resolve_fixup_regions\t\tPARAMS ((void));\n-static void remove_fixup_regions\t\tPARAMS ((void));\n-static void remove_unreachable_regions\t\tPARAMS ((rtx));\n-static void convert_from_eh_region_ranges_1\tPARAMS ((rtx *, int *, int));\n-\n-static struct eh_region *duplicate_eh_region_1\tPARAMS ((struct eh_region *,\n-\t\t\t\t\t\t     struct inline_remap *));\n-static void duplicate_eh_region_2\t\tPARAMS ((struct eh_region *,\n-\t\t\t\t\t\t\t struct eh_region **));\n-static int ttypes_filter_eq\t\t\tPARAMS ((const void *,\n-\t\t\t\t\t\t\t const void *));\n-static hashval_t ttypes_filter_hash\t\tPARAMS ((const void *));\n-static int ehspec_filter_eq\t\t\tPARAMS ((const void *,\n-\t\t\t\t\t\t\t const void *));\n-static hashval_t ehspec_filter_hash\t\tPARAMS ((const void *));\n-static int add_ttypes_entry\t\t\tPARAMS ((htab_t, tree));\n-static int add_ehspec_entry\t\t\tPARAMS ((htab_t, htab_t,\n-\t\t\t\t\t\t\t tree));\n-static void assign_filter_values\t\tPARAMS ((void));\n-static void build_post_landing_pads\t\tPARAMS ((void));\n-static void connect_post_landing_pads\t\tPARAMS ((void));\n-static void dw2_build_landing_pads\t\tPARAMS ((void));\n+static int t2r_eq (const void *, const void *);\n+static hashval_t t2r_hash (const void *);\n+static void add_type_for_runtime (tree);\n+static tree lookup_type_for_runtime (tree);\n+\n+static struct eh_region *expand_eh_region_end (void);\n+\n+static rtx get_exception_filter (struct function *);\n+\n+static void collect_eh_region_array (void);\n+static void resolve_fixup_regions (void);\n+static void remove_fixup_regions (void);\n+static void remove_unreachable_regions (rtx);\n+static void convert_from_eh_region_ranges_1 (rtx *, int *, int);\n+\n+static struct eh_region *duplicate_eh_region_1 (struct eh_region *,\n+\t\t\t\t\t\tstruct inline_remap *);\n+static void duplicate_eh_region_2 (struct eh_region *, struct eh_region **);\n+static int ttypes_filter_eq (const void *, const void *);\n+static hashval_t ttypes_filter_hash (const void *);\n+static int ehspec_filter_eq (const void *, const void *);\n+static hashval_t ehspec_filter_hash (const void *);\n+static int add_ttypes_entry (htab_t, tree);\n+static int add_ehspec_entry (htab_t, htab_t, tree);\n+static void assign_filter_values (void);\n+static void build_post_landing_pads (void);\n+static void connect_post_landing_pads (void);\n+static void dw2_build_landing_pads (void);\n \n struct sjlj_lp_info;\n-static bool sjlj_find_directly_reachable_regions\n-     PARAMS ((struct sjlj_lp_info *));\n-static void sjlj_assign_call_site_values\n-     PARAMS ((rtx, struct sjlj_lp_info *));\n-static void sjlj_mark_call_sites\n-     PARAMS ((struct sjlj_lp_info *));\n-static void sjlj_emit_function_enter\t\tPARAMS ((rtx));\n-static void sjlj_emit_function_exit\t\tPARAMS ((void));\n-static void sjlj_emit_dispatch_table\n-     PARAMS ((rtx, struct sjlj_lp_info *));\n-static void sjlj_build_landing_pads\t\tPARAMS ((void));\n-\n-static hashval_t ehl_hash\t\t\tPARAMS ((const void *));\n-static int ehl_eq\t\t\t\tPARAMS ((const void *,\n-\t\t\t\t\t\t\t const void *));\n-static void add_ehl_entry\t\t\tPARAMS ((rtx,\n-\t\t\t\t\t\t\t struct eh_region *));\n-static void remove_exception_handler_label\tPARAMS ((rtx));\n-static void remove_eh_handler\t\t\tPARAMS ((struct eh_region *));\n-static int for_each_eh_label_1\t\t\tPARAMS ((void **, void *));\n+static bool sjlj_find_directly_reachable_regions (struct sjlj_lp_info *);\n+static void sjlj_assign_call_site_values (rtx, struct sjlj_lp_info *);\n+static void sjlj_mark_call_sites (struct sjlj_lp_info *);\n+static void sjlj_emit_function_enter (rtx);\n+static void sjlj_emit_function_exit (void);\n+static void sjlj_emit_dispatch_table (rtx, struct sjlj_lp_info *);\n+static void sjlj_build_landing_pads (void);\n+\n+static hashval_t ehl_hash (const void *);\n+static int ehl_eq (const void *, const void *);\n+static void add_ehl_entry (rtx, struct eh_region *);\n+static void remove_exception_handler_label (rtx);\n+static void remove_eh_handler (struct eh_region *);\n+static int for_each_eh_label_1 (void **, void *);\n \n struct reachable_info;\n \n@@ -326,30 +315,26 @@ enum reachable_code\n   RNL_BLOCKED\n };\n \n-static int check_handled\t\t\tPARAMS ((tree, tree));\n-static void add_reachable_handler\n-     PARAMS ((struct reachable_info *, struct eh_region *,\n-\t      struct eh_region *));\n-static enum reachable_code reachable_next_level\n-     PARAMS ((struct eh_region *, tree, struct reachable_info *));\n-\n-static int action_record_eq\t\t\tPARAMS ((const void *,\n-\t\t\t\t\t\t\t const void *));\n-static hashval_t action_record_hash\t\tPARAMS ((const void *));\n-static int add_action_record\t\t\tPARAMS ((htab_t, int, int));\n-static int collect_one_action_chain\t\tPARAMS ((htab_t,\n-\t\t\t\t\t\t\t struct eh_region *));\n-static int add_call_site\t\t\tPARAMS ((rtx, int));\n-\n-static void push_uleb128\t\t\tPARAMS ((varray_type *,\n-\t\t\t\t\t\t\t unsigned int));\n-static void push_sleb128\t\t\tPARAMS ((varray_type *, int));\n+static int check_handled (tree, tree);\n+static void add_reachable_handler (struct reachable_info *,\n+\t\t\t\t   struct eh_region *, struct eh_region *);\n+static enum reachable_code reachable_next_level (struct eh_region *, tree,\n+\t\t\t\t\t\t struct reachable_info *);\n+\n+static int action_record_eq (const void *, const void *);\n+static hashval_t action_record_hash (const void *);\n+static int add_action_record (htab_t, int, int);\n+static int collect_one_action_chain (htab_t, struct eh_region *);\n+static int add_call_site (rtx, int);\n+\n+static void push_uleb128 (varray_type *, unsigned int);\n+static void push_sleb128 (varray_type *, int);\n #ifndef HAVE_AS_LEB128\n-static int dw2_size_of_call_site_table\t\tPARAMS ((void));\n-static int sjlj_size_of_call_site_table\t\tPARAMS ((void));\n+static int dw2_size_of_call_site_table (void);\n+static int sjlj_size_of_call_site_table (void);\n #endif\n-static void dw2_output_call_site_table\t\tPARAMS ((void));\n-static void sjlj_output_call_site_table\t\tPARAMS ((void));\n+static void dw2_output_call_site_table (void);\n+static void sjlj_output_call_site_table (void);\n \n \f\n /* Routine to see if exception handling is turned on.\n@@ -360,8 +345,7 @@ static void sjlj_output_call_site_table\t\tPARAMS ((void));\n    compiler tries to use any exception-specific functions.  */\n \n int\n-doing_eh (do_warn)\n-     int do_warn;\n+doing_eh (int do_warn)\n {\n   if (! flag_exceptions)\n     {\n@@ -378,7 +362,7 @@ doing_eh (do_warn)\n \n \f\n void\n-init_eh ()\n+init_eh (void)\n {\n   if (! flag_exceptions)\n     return;\n@@ -472,9 +456,9 @@ init_eh ()\n }\n \n void\n-init_eh_for_function ()\n+init_eh_for_function (void)\n {\n-  cfun->eh = (struct eh_status *) \n+  cfun->eh = (struct eh_status *)\n     ggc_alloc_cleared (sizeof (struct eh_status));\n }\n \f\n@@ -483,7 +467,7 @@ init_eh_for_function ()\n    expand_eh_region_end is invoked.  */\n \n void\n-expand_eh_region_start ()\n+expand_eh_region_start (void)\n {\n   struct eh_region *new_region;\n   struct eh_region *cur_region;\n@@ -517,7 +501,7 @@ expand_eh_region_start ()\n /* Common code to end a region.  Returns the region just ended.  */\n \n static struct eh_region *\n-expand_eh_region_end ()\n+expand_eh_region_end (void)\n {\n   struct eh_region *cur_region = cfun->eh->cur_region;\n   rtx note;\n@@ -536,8 +520,7 @@ expand_eh_region_end ()\n    expression to expand for the cleanup.  */\n \n void\n-expand_eh_region_end_cleanup (handler)\n-     tree handler;\n+expand_eh_region_end_cleanup (tree handler)\n {\n   struct eh_region *region;\n   tree protect_cleanup_actions;\n@@ -603,7 +586,7 @@ expand_eh_region_end_cleanup (handler)\n    for subsequent calls to expand_start_catch.  */\n \n void\n-expand_start_all_catch ()\n+expand_start_all_catch (void)\n {\n   struct eh_region *region;\n \n@@ -626,8 +609,7 @@ expand_start_all_catch ()\n    is useful e.g. for Ada.  */\n \n void\n-expand_start_catch (type_or_list)\n-     tree type_or_list;\n+expand_start_catch (tree type_or_list)\n {\n   struct eh_region *t, *c, *l;\n   tree type_list;\n@@ -674,7 +656,7 @@ expand_start_catch (type_or_list)\n /* End a catch clause.  Control will resume after the try/catch block.  */\n \n void\n-expand_end_catch ()\n+expand_end_catch (void)\n {\n   struct eh_region *try_region;\n \n@@ -690,7 +672,7 @@ expand_end_catch ()\n /* End a sequence of catch handlers for a try block.  */\n \n void\n-expand_end_all_catch ()\n+expand_end_all_catch (void)\n {\n   struct eh_region *try_region;\n \n@@ -712,8 +694,7 @@ expand_end_all_catch ()\n    rethrowing satisfies the \"filter\" of the catch type.  */\n \n void\n-expand_eh_region_end_allowed (allowed, failure)\n-     tree allowed, failure;\n+expand_eh_region_end_allowed (tree allowed, tree failure)\n {\n   struct eh_region *region;\n   rtx around_label;\n@@ -755,8 +736,7 @@ expand_eh_region_end_allowed (allowed, failure)\n    the C++ LSDA.  */\n \n void\n-expand_eh_region_end_must_not_throw (failure)\n-     tree failure;\n+expand_eh_region_end_must_not_throw (tree failure)\n {\n   struct eh_region *region;\n   rtx around_label;\n@@ -786,8 +766,7 @@ expand_eh_region_end_must_not_throw (failure)\n    is being thrown.  */\n \n void\n-expand_eh_region_end_throw (type)\n-     tree type;\n+expand_eh_region_end_throw (tree type)\n {\n   struct eh_region *region;\n \n@@ -810,8 +789,7 @@ expand_eh_region_end_throw (type)\n    the proper notion of \"enclosing\" in convert_from_eh_region_ranges.  */\n \n void\n-expand_eh_region_end_fixup (handler)\n-     tree handler;\n+expand_eh_region_end_fixup (tree handler)\n {\n   struct eh_region *fixup;\n \n@@ -827,7 +805,7 @@ expand_eh_region_end_fixup (handler)\n    call to a function which itself may contain a throw.  */\n \n void\n-note_eh_region_may_contain_throw ()\n+note_eh_region_may_contain_throw (void)\n {\n   struct eh_region *region;\n \n@@ -843,8 +821,7 @@ note_eh_region_may_contain_throw ()\n    within a handler.  */\n \n rtx\n-get_exception_pointer (fun)\n-     struct function *fun;\n+get_exception_pointer (struct function *fun)\n {\n   rtx exc_ptr = fun->eh->exc_ptr;\n   if (fun == cfun && ! exc_ptr)\n@@ -859,8 +836,7 @@ get_exception_pointer (fun)\n    within a handler.  */\n \n static rtx\n-get_exception_filter (fun)\n-     struct function *fun;\n+get_exception_filter (struct function *fun)\n {\n   rtx filter = fun->eh->filter;\n   if (fun == cfun && ! filter)\n@@ -878,7 +854,7 @@ get_exception_filter (fun)\n    without having to realloc memory.  */\n \n static void\n-collect_eh_region_array ()\n+collect_eh_region_array (void)\n {\n   struct eh_region **array, *i;\n \n@@ -914,7 +890,7 @@ collect_eh_region_array ()\n }\n \n static void\n-resolve_fixup_regions ()\n+resolve_fixup_regions (void)\n {\n   int i, j, n = cfun->eh->last_region_number;\n \n@@ -944,7 +920,7 @@ resolve_fixup_regions ()\n    we can shuffle pointers and remove them from the tree.  */\n \n static void\n-remove_fixup_regions ()\n+remove_fixup_regions (void)\n {\n   int i;\n   rtx insn, note;\n@@ -1014,8 +990,7 @@ remove_fixup_regions ()\n /* Remove all regions whose labels are not reachable from insns.  */\n \n static void\n-remove_unreachable_regions (insns)\n-     rtx insns;\n+remove_unreachable_regions (rtx insns)\n {\n   int i, *uid_region_num;\n   bool *reachable;\n@@ -1078,10 +1053,7 @@ remove_unreachable_regions (insns)\n    can_throw instruction in the region.  */\n \n static void\n-convert_from_eh_region_ranges_1 (pinsns, orig_sp, cur)\n-     rtx *pinsns;\n-     int *orig_sp;\n-     int cur;\n+convert_from_eh_region_ranges_1 (rtx *pinsns, int *orig_sp, int cur)\n {\n   int *sp = orig_sp;\n   rtx insn, next;\n@@ -1162,7 +1134,7 @@ convert_from_eh_region_ranges_1 (pinsns, orig_sp, cur)\n }\n \n void\n-convert_from_eh_region_ranges ()\n+convert_from_eh_region_ranges (void)\n {\n   int *stack;\n   rtx insns;\n@@ -1180,9 +1152,7 @@ convert_from_eh_region_ranges ()\n }\n \n static void\n-add_ehl_entry (label, region)\n-     rtx label;\n-     struct eh_region *region;\n+add_ehl_entry (rtx label, struct eh_region *region)\n {\n   struct ehl_map_entry **slot, *entry;\n \n@@ -1206,7 +1176,7 @@ add_ehl_entry (label, region)\n }\n \n void\n-find_exception_handler_labels ()\n+find_exception_handler_labels (void)\n {\n   int i;\n \n@@ -1247,7 +1217,7 @@ find_exception_handler_labels ()\n }\n \n bool\n-current_function_has_exception_handlers ()\n+current_function_has_exception_handlers (void)\n {\n   int i;\n \n@@ -1265,9 +1235,7 @@ current_function_has_exception_handlers ()\n }\n \f\n static struct eh_region *\n-duplicate_eh_region_1 (o, map)\n-     struct eh_region *o;\n-     struct inline_remap *map;\n+duplicate_eh_region_1 (struct eh_region *o, struct inline_remap *map)\n {\n   struct eh_region *n\n     = (struct eh_region *) ggc_alloc_cleared (sizeof (struct eh_region));\n@@ -1316,9 +1284,7 @@ duplicate_eh_region_1 (o, map)\n }\n \n static void\n-duplicate_eh_region_2 (o, n_array)\n-     struct eh_region *o;\n-     struct eh_region **n_array;\n+duplicate_eh_region_2 (struct eh_region *o, struct eh_region **n_array)\n {\n   struct eh_region *n = n_array[o->region_number];\n \n@@ -1349,9 +1315,7 @@ duplicate_eh_region_2 (o, n_array)\n }\n \n int\n-duplicate_eh_regions (ifun, map)\n-     struct function *ifun;\n-     struct inline_remap *map;\n+duplicate_eh_regions (struct function *ifun, struct inline_remap *map)\n {\n   int ifun_last_region_number = ifun->eh->last_region_number;\n   struct eh_region **n_array, *root, *cur;\n@@ -1417,9 +1381,7 @@ duplicate_eh_regions (ifun, map)\n \n \f\n static int\n-t2r_eq (pentry, pdata)\n-     const void *pentry;\n-     const void *pdata;\n+t2r_eq (const void *pentry, const void *pdata)\n {\n   tree entry = (tree) pentry;\n   tree data = (tree) pdata;\n@@ -1428,16 +1390,14 @@ t2r_eq (pentry, pdata)\n }\n \n static hashval_t\n-t2r_hash (pentry)\n-     const void *pentry;\n+t2r_hash (const void *pentry)\n {\n   tree entry = (tree) pentry;\n   return TYPE_HASH (TREE_PURPOSE (entry));\n }\n \n static void\n-add_type_for_runtime (type)\n-     tree type;\n+add_type_for_runtime (tree type)\n {\n   tree *slot;\n \n@@ -1451,8 +1411,7 @@ add_type_for_runtime (type)\n }\n \n static tree\n-lookup_type_for_runtime (type)\n-     tree type;\n+lookup_type_for_runtime (tree type)\n {\n   tree *slot;\n \n@@ -1476,9 +1435,7 @@ struct ttypes_filter GTY(())\n    (a tree) for a @TTypes type node we are thinking about adding.  */\n \n static int\n-ttypes_filter_eq (pentry, pdata)\n-     const void *pentry;\n-     const void *pdata;\n+ttypes_filter_eq (const void *pentry, const void *pdata)\n {\n   const struct ttypes_filter *entry = (const struct ttypes_filter *) pentry;\n   tree data = (tree) pdata;\n@@ -1487,8 +1444,7 @@ ttypes_filter_eq (pentry, pdata)\n }\n \n static hashval_t\n-ttypes_filter_hash (pentry)\n-     const void *pentry;\n+ttypes_filter_hash (const void *pentry)\n {\n   const struct ttypes_filter *entry = (const struct ttypes_filter *) pentry;\n   return TYPE_HASH (entry->t);\n@@ -1500,9 +1456,7 @@ ttypes_filter_hash (pentry)\n    should put these in some canonical order.  */\n \n static int\n-ehspec_filter_eq (pentry, pdata)\n-     const void *pentry;\n-     const void *pdata;\n+ehspec_filter_eq (const void *pentry, const void *pdata)\n {\n   const struct ttypes_filter *entry = (const struct ttypes_filter *) pentry;\n   const struct ttypes_filter *data = (const struct ttypes_filter *) pdata;\n@@ -1513,8 +1467,7 @@ ehspec_filter_eq (pentry, pdata)\n /* Hash function for exception specification lists.  */\n \n static hashval_t\n-ehspec_filter_hash (pentry)\n-     const void *pentry;\n+ehspec_filter_hash (const void *pentry)\n {\n   const struct ttypes_filter *entry = (const struct ttypes_filter *) pentry;\n   hashval_t h = 0;\n@@ -1529,9 +1482,7 @@ ehspec_filter_hash (pentry)\n    up the search.  Return the filter value to be used.  */\n \n static int\n-add_ttypes_entry (ttypes_hash, type)\n-     htab_t ttypes_hash;\n-     tree type;\n+add_ttypes_entry (htab_t ttypes_hash, tree type)\n {\n   struct ttypes_filter **slot, *n;\n \n@@ -1557,10 +1508,7 @@ add_ttypes_entry (ttypes_hash, type)\n    to speed up the search.  Return the filter value to be used.  */\n \n static int\n-add_ehspec_entry (ehspec_hash, ttypes_hash, list)\n-     htab_t ehspec_hash;\n-     htab_t ttypes_hash;\n-     tree list;\n+add_ehspec_entry (htab_t ehspec_hash, htab_t ttypes_hash, tree list)\n {\n   struct ttypes_filter **slot, *n;\n   struct ttypes_filter dummy;\n@@ -1595,7 +1543,7 @@ add_ehspec_entry (ehspec_hash, ttypes_hash, list)\n    the same filter value, which saves table space.  */\n \n static void\n-assign_filter_values ()\n+assign_filter_values (void)\n {\n   int i;\n   htab_t ttypes, ehspec;\n@@ -1667,7 +1615,7 @@ assign_filter_values ()\n    landing pads.  */\n \n static void\n-build_post_landing_pads ()\n+build_post_landing_pads (void)\n {\n   int i;\n \n@@ -1783,7 +1731,7 @@ build_post_landing_pads ()\n    _Unwind_Resume otherwise.  */\n \n static void\n-connect_post_landing_pads ()\n+connect_post_landing_pads (void)\n {\n   int i;\n \n@@ -1824,7 +1772,7 @@ connect_post_landing_pads ()\n \n \f\n static void\n-dw2_build_landing_pads ()\n+dw2_build_landing_pads (void)\n {\n   int i;\n   unsigned int j;\n@@ -1907,8 +1855,7 @@ struct sjlj_lp_info\n };\n \n static bool\n-sjlj_find_directly_reachable_regions (lp_info)\n-     struct sjlj_lp_info *lp_info;\n+sjlj_find_directly_reachable_regions (struct sjlj_lp_info *lp_info)\n {\n   rtx insn;\n   bool found_one = false;\n@@ -1956,9 +1903,7 @@ sjlj_find_directly_reachable_regions (lp_info)\n }\n \n static void\n-sjlj_assign_call_site_values (dispatch_label, lp_info)\n-     rtx dispatch_label;\n-     struct sjlj_lp_info *lp_info;\n+sjlj_assign_call_site_values (rtx dispatch_label, struct sjlj_lp_info *lp_info)\n {\n   htab_t ar_hash;\n   int i, index;\n@@ -2020,8 +1965,7 @@ sjlj_assign_call_site_values (dispatch_label, lp_info)\n }\n \n static void\n-sjlj_mark_call_sites (lp_info)\n-     struct sjlj_lp_info *lp_info;\n+sjlj_mark_call_sites (struct sjlj_lp_info *lp_info)\n {\n   int last_call_site = -2;\n   rtx insn, mem;\n@@ -2085,8 +2029,7 @@ sjlj_mark_call_sites (lp_info)\n /* Construct the SjLj_Function_Context.  */\n \n static void\n-sjlj_emit_function_enter (dispatch_label)\n-     rtx dispatch_label;\n+sjlj_emit_function_enter (rtx dispatch_label)\n {\n   rtx fn_begin, fc, mem, seq;\n \n@@ -2151,14 +2094,13 @@ sjlj_emit_function_enter (dispatch_label)\n    the call to unwind_sjlj_unregister_libfunc if needed.  */\n \n void\n-sjlj_emit_function_exit_after (after)\n-     rtx after;\n+sjlj_emit_function_exit_after (rtx after)\n {\n   cfun->eh->sjlj_exit_after = after;\n }\n \n static void\n-sjlj_emit_function_exit ()\n+sjlj_emit_function_exit (void)\n {\n   rtx seq;\n \n@@ -2178,9 +2120,7 @@ sjlj_emit_function_exit ()\n }\n \n static void\n-sjlj_emit_dispatch_table (dispatch_label, lp_info)\n-     rtx dispatch_label;\n-     struct sjlj_lp_info *lp_info;\n+sjlj_emit_dispatch_table (rtx dispatch_label, struct sjlj_lp_info *lp_info)\n {\n   int i, first_reachable;\n   rtx mem, dispatch, seq, fc;\n@@ -2243,7 +2183,7 @@ sjlj_emit_dispatch_table (dispatch_label, lp_info)\n }\n \n static void\n-sjlj_build_landing_pads ()\n+sjlj_build_landing_pads (void)\n {\n   struct sjlj_lp_info *lp_info;\n \n@@ -2271,7 +2211,7 @@ sjlj_build_landing_pads ()\n }\n \n void\n-finish_eh_generation ()\n+finish_eh_generation (void)\n {\n   /* Nothing to do if no regions created.  */\n   if (cfun->eh->region_tree == NULL)\n@@ -2313,8 +2253,7 @@ finish_eh_generation ()\n }\n \f\n static hashval_t\n-ehl_hash (pentry)\n-     const void *pentry;\n+ehl_hash (const void *pentry)\n {\n   struct ehl_map_entry *entry = (struct ehl_map_entry *) pentry;\n \n@@ -2324,9 +2263,7 @@ ehl_hash (pentry)\n }\n \n static int\n-ehl_eq (pentry, pdata)\n-     const void *pentry;\n-     const void *pdata;\n+ehl_eq (const void *pentry, const void *pdata)\n {\n   struct ehl_map_entry *entry = (struct ehl_map_entry *) pentry;\n   struct ehl_map_entry *data = (struct ehl_map_entry *) pdata;\n@@ -2339,8 +2276,7 @@ ehl_eq (pentry, pdata)\n /* Remove LABEL from exception_handler_label_map.  */\n \n static void\n-remove_exception_handler_label (label)\n-     rtx label;\n+remove_exception_handler_label (rtx label)\n {\n   struct ehl_map_entry **slot, tmp;\n \n@@ -2361,8 +2297,7 @@ remove_exception_handler_label (label)\n /* Splice REGION from the region tree etc.  */\n \n static void\n-remove_eh_handler (region)\n-     struct eh_region *region;\n+remove_eh_handler (struct eh_region *region)\n {\n   struct eh_region **pp, **pp_start, *p, *outer, *inner;\n   rtx lab;\n@@ -2451,8 +2386,7 @@ remove_eh_handler (region)\n    delete the region.  */\n \n void\n-maybe_remove_eh_handler (label)\n-     rtx label;\n+maybe_remove_eh_handler (rtx label)\n {\n   struct ehl_map_entry **slot, tmp;\n   struct eh_region *region;\n@@ -2490,20 +2424,17 @@ maybe_remove_eh_handler (label)\n    loop hackery; should not be used by new code.  */\n \n void\n-for_each_eh_label (callback)\n-     void (*callback) PARAMS ((rtx));\n+for_each_eh_label (void (*callback) (rtx))\n {\n   htab_traverse (cfun->eh->exception_handler_label_map, for_each_eh_label_1,\n \t\t (void *)callback);\n }\n \n static int\n-for_each_eh_label_1 (pentry, data)\n-     void **pentry;\n-     void *data;\n+for_each_eh_label_1 (void **pentry, void *data)\n {\n   struct ehl_map_entry *entry = *(struct ehl_map_entry **)pentry;\n-  void (*callback) PARAMS ((rtx)) = (void (*) PARAMS ((rtx))) data;\n+  void (*callback) (rtx) = (void (*) (rtx)) data;\n \n   (*callback) (entry->label);\n   return 1;\n@@ -2523,8 +2454,7 @@ struct reachable_info GTY(())\n    base class of TYPE, is in HANDLED.  */\n \n static int\n-check_handled (handled, type)\n-     tree handled, type;\n+check_handled (tree handled, tree type)\n {\n   tree t;\n \n@@ -2554,10 +2484,7 @@ check_handled (handled, type)\n    LP_REGION contains the landing pad; REGION is the handler.  */\n \n static void\n-add_reachable_handler (info, lp_region, region)\n-     struct reachable_info *info;\n-     struct eh_region *lp_region;\n-     struct eh_region *region;\n+add_reachable_handler (struct reachable_info *info, struct eh_region *lp_region, struct eh_region *region)\n {\n   if (! info)\n     return;\n@@ -2577,10 +2504,8 @@ add_reachable_handler (info, lp_region, region)\n    and caught/allowed type information between invocations.  */\n \n static enum reachable_code\n-reachable_next_level (region, type_thrown, info)\n-     struct eh_region *region;\n-     tree type_thrown;\n-     struct reachable_info *info;\n+reachable_next_level (struct eh_region *region, tree type_thrown,\n+\t\t      struct reachable_info *info)\n {\n   switch (region->type)\n     {\n@@ -2741,8 +2666,7 @@ reachable_next_level (region, type_thrown, info)\n    reached by a given insn.  */\n \n rtx\n-reachable_handlers (insn)\n-     rtx insn;\n+reachable_handlers (rtx insn)\n {\n   struct reachable_info info;\n   struct eh_region *region;\n@@ -2793,16 +2717,15 @@ reachable_handlers (insn)\n       else\n \tregion = region->outer;\n     }\n-    \n+\n   return info.handlers;\n }\n \n /* Determine if the given INSN can throw an exception that is caught\n    within the function.  */\n \n bool\n-can_throw_internal (insn)\n-     rtx insn;\n+can_throw_internal (rtx insn)\n {\n   struct eh_region *region;\n   tree type_thrown;\n@@ -2862,8 +2785,7 @@ can_throw_internal (insn)\n    visible outside the function.  */\n \n bool\n-can_throw_external (insn)\n-     rtx insn;\n+can_throw_external (rtx insn)\n {\n   struct eh_region *region;\n   tree type_thrown;\n@@ -2926,10 +2848,10 @@ can_throw_external (insn)\n /* Set current_function_nothrow and cfun->all_throwers_are_sibcalls.  */\n \n void\n-set_nothrow_function_flags ()\n+set_nothrow_function_flags (void)\n {\n   rtx insn;\n-  \n+\n   current_function_nothrow = 1;\n \n   /* Assume cfun->all_throwers_are_sibcalls until we encounter\n@@ -2942,7 +2864,7 @@ set_nothrow_function_flags ()\n \n   if (! flag_exceptions)\n     return;\n-  \n+\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     if (can_throw_external (insn))\n       {\n@@ -2976,7 +2898,7 @@ set_nothrow_function_flags ()\n    On the SPARC, this means flushing the register windows.  */\n \n void\n-expand_builtin_unwind_init ()\n+expand_builtin_unwind_init (void)\n {\n   /* Set this so all the registers get saved in our frame; we need to be\n      able to copy the saved values for any registers from frames we unwind.  */\n@@ -2988,8 +2910,7 @@ expand_builtin_unwind_init ()\n }\n \n rtx\n-expand_builtin_eh_return_data_regno (arglist)\n-     tree arglist;\n+expand_builtin_eh_return_data_regno (tree arglist)\n {\n   tree which = TREE_VALUE (arglist);\n   unsigned HOST_WIDE_INT iwhich;\n@@ -3018,8 +2939,7 @@ expand_builtin_eh_return_data_regno (arglist)\n    return the actual address encoded in that value.  */\n \n rtx\n-expand_builtin_extract_return_addr (addr_tree)\n-     tree addr_tree;\n+expand_builtin_extract_return_addr (tree addr_tree)\n {\n   rtx addr = expand_expr (addr_tree, NULL_RTX, Pmode, 0);\n \n@@ -3051,8 +2971,7 @@ expand_builtin_extract_return_addr (addr_tree)\n    stack slot so the epilogue will return to that address.  */\n \n rtx\n-expand_builtin_frob_return_addr (addr_tree)\n-     tree addr_tree;\n+expand_builtin_frob_return_addr (tree addr_tree)\n {\n   rtx addr = expand_expr (addr_tree, NULL_RTX, ptr_mode, 0);\n \n@@ -3073,9 +2992,8 @@ expand_builtin_frob_return_addr (addr_tree)\n    exception handler.  */\n \n void\n-expand_builtin_eh_return (stackadj_tree, handler_tree)\n-    tree stackadj_tree ATTRIBUTE_UNUSED;\n-    tree handler_tree;\n+expand_builtin_eh_return (tree stackadj_tree ATTRIBUTE_UNUSED,\n+\t\t\t  tree handler_tree)\n {\n   rtx tmp;\n \n@@ -3107,7 +3025,7 @@ expand_builtin_eh_return (stackadj_tree, handler_tree)\n }\n \n void\n-expand_eh_return ()\n+expand_eh_return (void)\n {\n   rtx around_label;\n \n@@ -3165,27 +3083,22 @@ struct action_record\n };\n \n static int\n-action_record_eq (pentry, pdata)\n-     const void *pentry;\n-     const void *pdata;\n+action_record_eq (const void *pentry, const void *pdata)\n {\n   const struct action_record *entry = (const struct action_record *) pentry;\n   const struct action_record *data = (const struct action_record *) pdata;\n   return entry->filter == data->filter && entry->next == data->next;\n }\n \n static hashval_t\n-action_record_hash (pentry)\n-     const void *pentry;\n+action_record_hash (const void *pentry)\n {\n   const struct action_record *entry = (const struct action_record *) pentry;\n   return entry->next * 1009 + entry->filter;\n }\n \n static int\n-add_action_record (ar_hash, filter, next)\n-     htab_t ar_hash;\n-     int filter, next;\n+add_action_record (htab_t ar_hash, int filter, int next)\n {\n   struct action_record **slot, *new, tmp;\n \n@@ -3216,9 +3129,7 @@ add_action_record (ar_hash, filter, next)\n }\n \n static int\n-collect_one_action_chain (ar_hash, region)\n-     htab_t ar_hash;\n-     struct eh_region *region;\n+collect_one_action_chain (htab_t ar_hash, struct eh_region *region)\n {\n   struct eh_region *c;\n   int next;\n@@ -3319,9 +3230,7 @@ collect_one_action_chain (ar_hash, region)\n }\n \n static int\n-add_call_site (landing_pad, action)\n-     rtx landing_pad;\n-     int action;\n+add_call_site (rtx landing_pad, int action)\n {\n   struct call_site_record *data = cfun->eh->call_site_data;\n   int used = cfun->eh->call_site_data_used;\n@@ -3349,7 +3258,7 @@ add_call_site (landing_pad, action)\n    instead to call site entries.  */\n \n void\n-convert_to_eh_region_ranges ()\n+convert_to_eh_region_ranges (void)\n {\n   rtx insn, iter, note;\n   htab_t ar_hash;\n@@ -3473,9 +3382,7 @@ convert_to_eh_region_ranges ()\n \n \f\n static void\n-push_uleb128 (data_area, value)\n-     varray_type *data_area;\n-     unsigned int value;\n+push_uleb128 (varray_type *data_area, unsigned int value)\n {\n   do\n     {\n@@ -3489,9 +3396,7 @@ push_uleb128 (data_area, value)\n }\n \n static void\n-push_sleb128 (data_area, value)\n-     varray_type *data_area;\n-     int value;\n+push_sleb128 (varray_type *data_area, int value)\n {\n   unsigned char byte;\n   int more;\n@@ -3512,7 +3417,7 @@ push_sleb128 (data_area, value)\n \f\n #ifndef HAVE_AS_LEB128\n static int\n-dw2_size_of_call_site_table ()\n+dw2_size_of_call_site_table (void)\n {\n   int n = cfun->eh->call_site_data_used;\n   int size = n * (4 + 4 + 4);\n@@ -3528,7 +3433,7 @@ dw2_size_of_call_site_table ()\n }\n \n static int\n-sjlj_size_of_call_site_table ()\n+sjlj_size_of_call_site_table (void)\n {\n   int n = cfun->eh->call_site_data_used;\n   int size = 0;\n@@ -3546,7 +3451,7 @@ sjlj_size_of_call_site_table ()\n #endif\n \n static void\n-dw2_output_call_site_table ()\n+dw2_output_call_site_table (void)\n {\n   const char *const function_start_lab\n     = IDENTIFIER_POINTER (current_function_func_begin_label);\n@@ -3598,7 +3503,7 @@ dw2_output_call_site_table ()\n }\n \n static void\n-sjlj_output_call_site_table ()\n+sjlj_output_call_site_table (void)\n {\n   int n = cfun->eh->call_site_data_used;\n   int i;\n@@ -3619,7 +3524,7 @@ sjlj_output_call_site_table ()\n    table.  */\n \n void\n-default_exception_section ()\n+default_exception_section (void)\n {\n   if (targetm.have_named_sections)\n     {\n@@ -3643,7 +3548,7 @@ default_exception_section ()\n }\n \n void\n-output_function_exception_table ()\n+output_function_exception_table (void)\n {\n   int tt_format, cs_format, lp_format, i, n;\n #ifdef HAVE_AS_LEB128"}, {"sha": "8f075400fe7bda8e766d3b2082518b4ffdce8958", "filename": "gcc/except.h", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=502b832280c67d89300d92b91e73a9d3093db4a8", "patch": "@@ -1,5 +1,5 @@\n /* Exception Handling interface routines.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n    Free Software Foundation, Inc.\n    Contributed by Mike Stump <mrs@cygnus.com>.\n \n@@ -33,95 +33,94 @@ struct eh_status;\n struct eh_region;\n \n /* Test: is exception handling turned on?  */\n-extern int doing_eh\t\t\t        PARAMS ((int));\n+extern int doing_eh (int);\n \n /* Start an exception handling region.  All instructions emitted after\n    this point are considered to be part of the region until an\n    expand_eh_region_end variant is invoked.  */\n-extern void expand_eh_region_start\t\tPARAMS ((void));\n+extern void expand_eh_region_start (void);\n \n /* End an exception handling region for a cleanup.  HANDLER is an\n    expression to expand for the cleanup.  */\n-extern void expand_eh_region_end_cleanup\tPARAMS ((tree));\n+extern void expand_eh_region_end_cleanup (tree);\n \n /* End an exception handling region for a try block, and prepares\n    for subsequent calls to expand_start_catch.  */\n-extern void expand_start_all_catch\t\tPARAMS ((void));\n+extern void expand_start_all_catch (void);\n \n /* Begin a catch clause.  TYPE is an object to be matched by the\n    runtime, or a list of such objects, or null if this is a catch-all\n    clause.  */\n-extern void expand_start_catch\t\t\tPARAMS ((tree));\n+extern void expand_start_catch (tree);\n \n /* End a catch clause.  Control will resume after the try/catch block.  */\n-extern void expand_end_catch\t\t\tPARAMS ((void));\n+extern void expand_end_catch (void);\n \n /* End a sequence of catch handlers for a try block.  */\n-extern void expand_end_all_catch\t\tPARAMS ((void));\n+extern void expand_end_all_catch (void);\n \n /* End an exception region for an exception type filter.  ALLOWED is a\n    TREE_LIST of TREE_VALUE objects to be matched by the runtime.\n    FAILURE is a function to invoke if a mismatch occurs.  */\n-extern void expand_eh_region_end_allowed\tPARAMS ((tree, tree));\n+extern void expand_eh_region_end_allowed (tree, tree);\n \n /* End an exception region for a must-not-throw filter.  FAILURE is a\n    function to invoke if an uncaught exception propagates this far.  */\n-extern void expand_eh_region_end_must_not_throw\tPARAMS ((tree));\n+extern void expand_eh_region_end_must_not_throw (tree);\n \n /* End an exception region for a throw.  No handling goes on here,\n    but it's the easiest way for the front-end to indicate what type\n    is being thrown.  */\n-extern void expand_eh_region_end_throw\t\tPARAMS ((tree));\n+extern void expand_eh_region_end_throw (tree);\n \n /* End a fixup region.  Within this region the cleanups for the immediately\n    enclosing region are _not_ run.  This is used for goto cleanup to avoid\n    destroying an object twice.  */\n-extern void expand_eh_region_end_fixup\t\tPARAMS ((tree));\n+extern void expand_eh_region_end_fixup (tree);\n \n /* Note that the current EH region (if any) may contain a throw, or a\n    call to a function which itself may contain a throw.  */\n-extern void note_eh_region_may_contain_throw    PARAMS ((void));\n+extern void note_eh_region_may_contain_throw (void);\n \n /* Invokes CALLBACK for every exception handler label.  Only used by old\n    loop hackery; should not be used by new code.  */\n-extern void for_each_eh_label\t\t\tPARAMS ((void (*) (rtx)));\n+extern void for_each_eh_label (void (*) (rtx));\n \n /* Determine if the given INSN can throw an exception.  */\n-extern bool can_throw_internal\t\t\tPARAMS ((rtx));\n-extern bool can_throw_external\t\t\tPARAMS ((rtx));\n+extern bool can_throw_internal (rtx);\n+extern bool can_throw_external (rtx);\n \n /* Set current_function_nothrow and cfun->all_throwers_are_sibcalls.  */\n-extern void set_nothrow_function_flags\t\tPARAMS ((void));\n+extern void set_nothrow_function_flags (void);\n \n /* After initial rtl generation, call back to finish generating\n    exception support code.  */\n-extern void finish_eh_generation\t\tPARAMS ((void));\n+extern void finish_eh_generation (void);\n \n-extern void init_eh\t\t\t\tPARAMS ((void));\n-extern void init_eh_for_function\t\tPARAMS ((void));\n+extern void init_eh (void);\n+extern void init_eh_for_function (void);\n \n-extern rtx reachable_handlers\t\t\tPARAMS ((rtx));\n-extern void maybe_remove_eh_handler\t\tPARAMS ((rtx));\n+extern rtx reachable_handlers (rtx);\n+extern void maybe_remove_eh_handler (rtx);\n \n-extern void convert_from_eh_region_ranges\tPARAMS ((void));\n-extern void convert_to_eh_region_ranges\t\tPARAMS ((void));\n-extern void find_exception_handler_labels\tPARAMS ((void));\n-extern bool current_function_has_exception_handlers PARAMS ((void));\n-extern void output_function_exception_table\tPARAMS ((void));\n+extern void convert_from_eh_region_ranges (void);\n+extern void convert_to_eh_region_ranges (void);\n+extern void find_exception_handler_labels (void);\n+extern bool current_function_has_exception_handlers (void);\n+extern void output_function_exception_table (void);\n \n-extern void expand_builtin_unwind_init\t\tPARAMS ((void));\n-extern rtx expand_builtin_eh_return_data_regno\tPARAMS ((tree));\n-extern rtx expand_builtin_extract_return_addr\tPARAMS ((tree));\n-extern void expand_builtin_init_dwarf_reg_sizes PARAMS ((tree));\n-extern rtx expand_builtin_frob_return_addr\tPARAMS ((tree));\n-extern rtx expand_builtin_dwarf_sp_column\tPARAMS ((void));\n-extern void expand_builtin_eh_return\t\tPARAMS ((tree, tree));\n-extern void expand_eh_return\t\t\tPARAMS ((void));\n-extern rtx get_exception_pointer\t\tPARAMS ((struct function *));\n-extern int duplicate_eh_regions\t\t\tPARAMS ((struct function *,\n-\t\t\t\t\t\t struct inline_remap *));\n+extern void expand_builtin_unwind_init (void);\n+extern rtx expand_builtin_eh_return_data_regno (tree);\n+extern rtx expand_builtin_extract_return_addr (tree);\n+extern void expand_builtin_init_dwarf_reg_sizes (tree);\n+extern rtx expand_builtin_frob_return_addr (tree);\n+extern rtx expand_builtin_dwarf_sp_column (void);\n+extern void expand_builtin_eh_return (tree, tree);\n+extern void expand_eh_return (void);\n+extern rtx get_exception_pointer (struct function *);\n+extern int duplicate_eh_regions (struct function *, struct inline_remap *);\n \n-extern void sjlj_emit_function_exit_after\tPARAMS ((rtx));\n+extern void sjlj_emit_function_exit_after (rtx);\n \n \n /* If non-NULL, this is a function that returns an expression to be\n@@ -130,13 +129,13 @@ extern void sjlj_emit_function_exit_after\tPARAMS ((rtx));\n    during stack unwinding is required to result in a call to\n    `std::terminate', so the C++ version of this function returns a\n    CALL_EXPR for `std::terminate'.  */\n-extern tree (*lang_protect_cleanup_actions) PARAMS ((void));\n+extern tree (*lang_protect_cleanup_actions) (void);\n \n /* Return true if type A catches type B.  */\n-extern int (*lang_eh_type_covers) PARAMS ((tree a, tree b));\n+extern int (*lang_eh_type_covers) (tree a, tree b);\n \n /* Map a type to a runtime object to match type.  */\n-extern tree (*lang_eh_runtime_type) PARAMS ((tree));\n+extern tree (*lang_eh_runtime_type) (tree);\n \n \n /* Just because the user configured --with-sjlj-exceptions=no doesn't"}, {"sha": "e9ca57b7803b2877cc5e50aadb6c47ad3a55231a", "filename": "gcc/explow.c", "status": "modified", "additions": 41, "deletions": 94, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=502b832280c67d89300d92b91e73a9d3093db4a8", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for manipulating rtx's in semantically interesting ways.\n    Copyright (C) 1987, 1991, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -38,16 +38,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"recog.h\"\n #include \"langhooks.h\"\n \n-static rtx break_out_memory_refs\tPARAMS ((rtx));\n-static void emit_stack_probe\t\tPARAMS ((rtx));\n+static rtx break_out_memory_refs (rtx);\n+static void emit_stack_probe (rtx);\n \n \n /* Truncate and perhaps sign-extend C as appropriate for MODE.  */\n \n HOST_WIDE_INT\n-trunc_int_for_mode (c, mode)\n-     HOST_WIDE_INT c;\n-     enum machine_mode mode;\n+trunc_int_for_mode (HOST_WIDE_INT c, enum machine_mode mode)\n {\n   int width = GET_MODE_BITSIZE (mode);\n \n@@ -78,9 +76,7 @@ trunc_int_for_mode (c, mode)\n    This function should be used via the `plus_constant' macro.  */\n \n rtx\n-plus_constant_wide (x, c)\n-     rtx x;\n-     HOST_WIDE_INT c;\n+plus_constant_wide (rtx x, HOST_WIDE_INT c)\n {\n   RTX_CODE code;\n   rtx y;\n@@ -206,9 +202,7 @@ plus_constant_wide (x, c)\n    it is not isomorphic to X.  */\n \n rtx\n-eliminate_constant_term (x, constptr)\n-     rtx x;\n-     rtx *constptr;\n+eliminate_constant_term (rtx x, rtx *constptr)\n {\n   rtx x0, x1;\n   rtx tem;\n@@ -244,8 +238,7 @@ eliminate_constant_term (x, constptr)\n /* Return an rtx for the size in bytes of the value of EXP.  */\n \n rtx\n-expr_size (exp)\n-     tree exp;\n+expr_size (tree exp)\n {\n   tree size = (*lang_hooks.expr_size) (exp);\n \n@@ -259,8 +252,7 @@ expr_size (exp)\n    if the size can vary or is larger than an integer.  */\n \n HOST_WIDE_INT\n-int_expr_size (exp)\n-     tree exp;\n+int_expr_size (tree exp)\n {\n   tree t = (*lang_hooks.expr_size) (exp);\n \n@@ -292,8 +284,7 @@ int_expr_size (exp)\n    Values returned by expand_expr with 1 for sum_ok fit this constraint.  */\n \n static rtx\n-break_out_memory_refs (x)\n-     rtx x;\n+break_out_memory_refs (rtx x)\n {\n   if (GET_CODE (x) == MEM\n       || (CONSTANT_P (x) && CONSTANT_ADDRESS_P (x)\n@@ -321,9 +312,7 @@ break_out_memory_refs (x)\n    used.  */\n \n rtx\n-convert_memory_address (to_mode, x)\n-     enum machine_mode to_mode;\n-     rtx x;\n+convert_memory_address (enum machine_mode to_mode, rtx x)\n {\n   enum machine_mode from_mode = to_mode == ptr_mode ? Pmode : ptr_mode;\n   rtx temp;\n@@ -409,8 +398,7 @@ convert_memory_address (to_mode, x)\n    but then you wouldn't get indexed addressing in the reference.  */\n \n rtx\n-copy_all_regs (x)\n-     rtx x;\n+copy_all_regs (rtx x)\n {\n   if (GET_CODE (x) == REG)\n     {\n@@ -439,9 +427,7 @@ copy_all_regs (x)\n    works by copying X or subexpressions of it into registers.  */\n \n rtx\n-memory_address (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+memory_address (enum machine_mode mode, rtx x)\n {\n   rtx oldx = x;\n \n@@ -569,9 +555,7 @@ memory_address (mode, x)\n /* Like `memory_address' but pretend `flag_force_addr' is 0.  */\n \n rtx\n-memory_address_noforce (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+memory_address_noforce (enum machine_mode mode, rtx x)\n {\n   int ambient_force_addr = flag_force_addr;\n   rtx val;\n@@ -586,8 +570,7 @@ memory_address_noforce (mode, x)\n    Pass through anything else unchanged.  */\n \n rtx\n-validize_mem (ref)\n-     rtx ref;\n+validize_mem (rtx ref)\n {\n   if (GET_CODE (ref) != MEM)\n     return ref;\n@@ -604,9 +587,7 @@ validize_mem (ref)\n    appropriate.  */\n \n void\n-maybe_set_unchanging (ref, t)\n-     rtx ref;\n-     tree t;\n+maybe_set_unchanging (rtx ref, tree t)\n {\n   /* We can set RTX_UNCHANGING_P from TREE_READONLY for decls whose\n      initialization is only executed once, or whose initializer always\n@@ -635,8 +616,7 @@ maybe_set_unchanging (ref, t)\n    Perhaps even if it is a MEM, if there is no need to change it.  */\n \n rtx\n-stabilize (x)\n-     rtx x;\n+stabilize (rtx x)\n {\n   if (GET_CODE (x) != MEM\n       || ! rtx_unstable_p (XEXP (x, 0)))\n@@ -649,8 +629,7 @@ stabilize (x)\n /* Copy the value or contents of X to a new temp reg and return that reg.  */\n \n rtx\n-copy_to_reg (x)\n-     rtx x;\n+copy_to_reg (rtx x)\n {\n   rtx temp = gen_reg_rtx (GET_MODE (x));\n \n@@ -669,8 +648,7 @@ copy_to_reg (x)\n    in case X is a constant.  */\n \n rtx\n-copy_addr_to_reg (x)\n-     rtx x;\n+copy_addr_to_reg (rtx x)\n {\n   return copy_to_mode_reg (Pmode, x);\n }\n@@ -679,9 +657,7 @@ copy_addr_to_reg (x)\n    in case X is a constant.  */\n \n rtx\n-copy_to_mode_reg (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+copy_to_mode_reg (enum machine_mode mode, rtx x)\n {\n   rtx temp = gen_reg_rtx (mode);\n \n@@ -706,9 +682,7 @@ copy_to_mode_reg (mode, x)\n    since we mark it as a \"constant\" register.  */\n \n rtx\n-force_reg (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+force_reg (enum machine_mode mode, rtx x)\n {\n   rtx temp, insn, set;\n \n@@ -749,8 +723,7 @@ force_reg (mode, x)\n    that reg.  Otherwise, return X.  */\n \n rtx\n-force_not_mem (x)\n-     rtx x;\n+force_not_mem (rtx x)\n {\n   rtx temp;\n \n@@ -767,9 +740,7 @@ force_not_mem (x)\n    MODE is the mode to use for X in case it is a constant.  */\n \n rtx\n-copy_to_suggested_reg (x, target, mode)\n-     rtx x, target;\n-     enum machine_mode mode;\n+copy_to_suggested_reg (rtx x, rtx target, enum machine_mode mode)\n {\n   rtx temp;\n \n@@ -789,11 +760,8 @@ copy_to_suggested_reg (x, target, mode)\n    FOR_CALL is nonzero if this call is promoting args for a call.  */\n \n enum machine_mode\n-promote_mode (type, mode, punsignedp, for_call)\n-     tree type;\n-     enum machine_mode mode;\n-     int *punsignedp;\n-     int for_call ATTRIBUTE_UNUSED;\n+promote_mode (tree type, enum machine_mode mode, int *punsignedp,\n+\t      int for_call ATTRIBUTE_UNUSED)\n {\n   enum tree_code code = TREE_CODE (type);\n   int unsignedp = *punsignedp;\n@@ -832,8 +800,7 @@ promote_mode (type, mode, punsignedp, for_call)\n    This pops when ADJUST is positive.  ADJUST need not be constant.  */\n \n void\n-adjust_stack (adjust)\n-     rtx adjust;\n+adjust_stack (rtx adjust)\n {\n   rtx temp;\n   adjust = protect_from_queue (adjust, 0);\n@@ -863,8 +830,7 @@ adjust_stack (adjust)\n    This pushes when ADJUST is positive.  ADJUST need not be constant.  */\n \n void\n-anti_adjust_stack (adjust)\n-     rtx adjust;\n+anti_adjust_stack (rtx adjust)\n {\n   rtx temp;\n   adjust = protect_from_queue (adjust, 0);\n@@ -894,8 +860,7 @@ anti_adjust_stack (adjust)\n    by this machine.  SIZE is the desired size, which need not be constant.  */\n \n rtx\n-round_push (size)\n-     rtx size;\n+round_push (rtx size)\n {\n   int align = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n \n@@ -933,14 +898,11 @@ round_push (size)\n    are emitted at the current position.  */\n \n void\n-emit_stack_save (save_level, psave, after)\n-     enum save_level save_level;\n-     rtx *psave;\n-     rtx after;\n+emit_stack_save (enum save_level save_level, rtx *psave, rtx after)\n {\n   rtx sa = *psave;\n   /* The default is that we use a move insn and save in a Pmode object.  */\n-  rtx (*fcn) PARAMS ((rtx, rtx)) = gen_move_insn;\n+  rtx (*fcn) (rtx, rtx) = gen_move_insn;\n   enum machine_mode mode = STACK_SAVEAREA_MODE (save_level);\n \n   /* See if this machine has anything special to do for this kind of save.  */\n@@ -1016,13 +978,10 @@ emit_stack_save (save_level, psave, after)\n    current position.  */\n \n void\n-emit_stack_restore (save_level, sa, after)\n-     enum save_level save_level;\n-     rtx after;\n-     rtx sa;\n+emit_stack_restore (enum save_level save_level, rtx sa, rtx after)\n {\n   /* The default is that we use a move insn.  */\n-  rtx (*fcn) PARAMS ((rtx, rtx)) = gen_move_insn;\n+  rtx (*fcn) (rtx, rtx) = gen_move_insn;\n \n   /* See if this machine has anything special to do for this kind of save.  */\n   switch (save_level)\n@@ -1056,7 +1015,7 @@ emit_stack_restore (save_level, sa, after)\n \t references to variable arrays below the code\n \t that deletes (pops) the arrays.  */\n       emit_insn (gen_rtx_CLOBBER (VOIDmode,\n-\t\t    gen_rtx_MEM (BLKmode, \n+\t\t    gen_rtx_MEM (BLKmode,\n \t\t\tgen_rtx_SCRATCH (VOIDmode))));\n       emit_insn (gen_rtx_CLOBBER (VOIDmode,\n \t\t    gen_rtx_MEM (BLKmode, stack_pointer_rtx)));\n@@ -1083,8 +1042,7 @@ emit_stack_restore (save_level, sa, after)\n    frame, thus causing a crash if a longjmp unwinds to it.  */\n \n void\n-optimize_save_area_alloca (insns)\n-     rtx insns;\n+optimize_save_area_alloca (rtx insns)\n {\n   rtx insn;\n \n@@ -1168,10 +1126,7 @@ optimize_save_area_alloca (insns)\n    KNOWN_ALIGN is the alignment (in bits) that we know SIZE has.  */\n \n rtx\n-allocate_dynamic_stack_space (size, target, known_align)\n-     rtx size;\n-     rtx target;\n-     int known_align;\n+allocate_dynamic_stack_space (rtx size, rtx target, int known_align)\n {\n #ifdef SETJMP_VIA_SAVE_AREA\n   rtx setjmpless_size = NULL_RTX;\n@@ -1416,17 +1371,15 @@ allocate_dynamic_stack_space (size, target, known_align)\n static GTY(()) rtx stack_check_libfunc;\n \n void\n-set_stack_check_libfunc (libfunc)\n-     rtx libfunc;\n+set_stack_check_libfunc (rtx libfunc)\n {\n   stack_check_libfunc = libfunc;\n }\n \f\n /* Emit one stack probe at ADDRESS, an address within the stack.  */\n \n static void\n-emit_stack_probe (address)\n-     rtx address;\n+emit_stack_probe (rtx address)\n {\n   rtx memref = gen_rtx_MEM (word_mode, address);\n \n@@ -1451,9 +1404,7 @@ emit_stack_probe (address)\n #endif\n \n void\n-probe_stack_range (first, size)\n-     HOST_WIDE_INT first;\n-     rtx size;\n+probe_stack_range (HOST_WIDE_INT first, rtx size)\n {\n   /* First ensure SIZE is Pmode.  */\n   if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)\n@@ -1585,10 +1536,8 @@ probe_stack_range (first, size)\n    and 0 otherwise.  */\n \n rtx\n-hard_function_value (valtype, func, outgoing)\n-     tree valtype;\n-     tree func ATTRIBUTE_UNUSED;\n-     int outgoing ATTRIBUTE_UNUSED;\n+hard_function_value (tree valtype, tree func ATTRIBUTE_UNUSED,\n+\t\t     int outgoing ATTRIBUTE_UNUSED)\n {\n   rtx val;\n \n@@ -1631,8 +1580,7 @@ hard_function_value (valtype, func, outgoing)\n    in which a scalar value of mode MODE was returned by a library call.  */\n \n rtx\n-hard_libcall_value (mode)\n-     enum machine_mode mode;\n+hard_libcall_value (enum machine_mode mode)\n {\n   return LIBCALL_VALUE (mode);\n }\n@@ -1643,8 +1591,7 @@ hard_libcall_value (mode)\n    what `enum tree_code' means.  */\n \n int\n-rtx_to_tree_code (code)\n-     enum rtx_code code;\n+rtx_to_tree_code (enum rtx_code code)\n {\n   enum tree_code tcode;\n "}, {"sha": "883eff5b52b44dc55edd4ceb5938b98d656a5fc5", "filename": "gcc/expmed.c", "status": "modified", "additions": 79, "deletions": 160, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=502b832280c67d89300d92b91e73a9d3093db4a8", "patch": "@@ -37,24 +37,20 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"recog.h\"\n #include \"langhooks.h\"\n \n-static void store_fixed_bit_field\tPARAMS ((rtx, unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT, rtx));\n-static void store_split_bit_field\tPARAMS ((rtx, unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT, rtx));\n-static rtx extract_fixed_bit_field\tPARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t rtx, int));\n-static rtx mask_rtx\t\t\tPARAMS ((enum machine_mode, int,\n-\t\t\t\t\t\t int, int));\n-static rtx lshift_value\t\t\tPARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t\t int, int));\n-static rtx extract_split_bit_field\tPARAMS ((rtx, unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT, int));\n-static void do_cmp_and_jump\t\tPARAMS ((rtx, rtx, enum rtx_code,\n-\t\t\t\t\t\t enum machine_mode, rtx));\n+static void store_fixed_bit_field (rtx, unsigned HOST_WIDE_INT,\n+\t\t\t\t   unsigned HOST_WIDE_INT,\n+\t\t\t\t   unsigned HOST_WIDE_INT, rtx);\n+static void store_split_bit_field (rtx, unsigned HOST_WIDE_INT,\n+\t\t\t\t   unsigned HOST_WIDE_INT, rtx);\n+static rtx extract_fixed_bit_field (enum machine_mode, rtx,\n+\t\t\t\t    unsigned HOST_WIDE_INT,\n+\t\t\t\t    unsigned HOST_WIDE_INT,\n+\t\t\t\t    unsigned HOST_WIDE_INT, rtx, int);\n+static rtx mask_rtx (enum machine_mode, int, int, int);\n+static rtx lshift_value (enum machine_mode, rtx, int, int);\n+static rtx extract_split_bit_field (rtx, unsigned HOST_WIDE_INT,\n+\t\t\t\t    unsigned HOST_WIDE_INT, int);\n+static void do_cmp_and_jump (rtx, rtx, enum rtx_code, enum machine_mode, rtx);\n \n /* Nonzero means divides or modulus operations are relatively cheap for\n    powers of two, so don't use branches; emit the operation instead.\n@@ -104,7 +100,7 @@ static int mul_widen_cost[NUM_MACHINE_MODES];\n static int mul_highpart_cost[NUM_MACHINE_MODES];\n \n void\n-init_expmed ()\n+init_expmed (void)\n {\n   rtx reg, shift_insn, shiftadd_insn, shiftsub_insn;\n   int dummy;\n@@ -207,9 +203,7 @@ init_expmed ()\n    useful if X is a CONST_INT.  */\n \n rtx\n-negate_rtx (mode, x)\n-     enum machine_mode mode;\n-     rtx x;\n+negate_rtx (enum machine_mode mode, rtx x)\n {\n   rtx result = simplify_unary_operation (NEG, mode, x, mode);\n \n@@ -224,9 +218,7 @@ negate_rtx (mode, x)\n    is false; else the mode of the specified operand.  If OPNO is -1,\n    all the caller cares about is whether the insn is available.  */\n enum machine_mode\n-mode_for_extraction (pattern, opno)\n-     enum extraction_pattern pattern;\n-     int opno;\n+mode_for_extraction (enum extraction_pattern pattern, int opno)\n {\n   const struct insn_data *data;\n \n@@ -287,13 +279,9 @@ mode_for_extraction (pattern, opno)\n    else, we use the mode of operand 3.  */\n \n rtx\n-store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, total_size)\n-     rtx str_rtx;\n-     unsigned HOST_WIDE_INT bitsize;\n-     unsigned HOST_WIDE_INT bitnum;\n-     enum machine_mode fieldmode;\n-     rtx value;\n-     HOST_WIDE_INT total_size;\n+store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n+\t\t unsigned HOST_WIDE_INT bitnum, enum machine_mode fieldmode,\n+\t\t rtx value, HOST_WIDE_INT total_size)\n {\n   unsigned int unit\n     = (GET_CODE (str_rtx) == MEM) ? BITS_PER_UNIT : BITS_PER_WORD;\n@@ -702,10 +690,9 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, total_size)\n    Note that protect_from_queue has already been done on OP0 and VALUE.  */\n \n static void\n-store_fixed_bit_field (op0, offset, bitsize, bitpos, value)\n-     rtx op0;\n-     unsigned HOST_WIDE_INT offset, bitsize, bitpos;\n-     rtx value;\n+store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n+\t\t       unsigned HOST_WIDE_INT bitsize,\n+\t\t       unsigned HOST_WIDE_INT bitpos, rtx value)\n {\n   enum machine_mode mode;\n   unsigned int total_bits = BITS_PER_WORD;\n@@ -868,10 +855,8 @@ store_fixed_bit_field (op0, offset, bitsize, bitpos, value)\n    This does not yet handle fields wider than BITS_PER_WORD.  */\n \n static void\n-store_split_bit_field (op0, bitsize, bitpos, value)\n-     rtx op0;\n-     unsigned HOST_WIDE_INT bitsize, bitpos;\n-     rtx value;\n+store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n+\t\t       unsigned HOST_WIDE_INT bitpos, rtx value)\n {\n   unsigned int unit;\n   unsigned int bitsdone = 0;\n@@ -1004,15 +989,10 @@ store_split_bit_field (op0, bitsize, bitpos, value)\n    if they are equally easy.  */\n \n rtx\n-extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n-\t\t   target, mode, tmode, total_size)\n-     rtx str_rtx;\n-     unsigned HOST_WIDE_INT bitsize;\n-     unsigned HOST_WIDE_INT bitnum;\n-     int unsignedp;\n-     rtx target;\n-     enum machine_mode mode, tmode;\n-     HOST_WIDE_INT total_size;\n+extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n+\t\t   unsigned HOST_WIDE_INT bitnum, int unsignedp, rtx target,\n+\t\t   enum machine_mode mode, enum machine_mode tmode,\n+\t\t   HOST_WIDE_INT total_size)\n {\n   unsigned int unit\n     = (GET_CODE (str_rtx) == MEM) ? BITS_PER_UNIT : BITS_PER_WORD;\n@@ -1560,12 +1540,11 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n    If TARGET is not used, create a pseudo-reg of mode TMODE for the value.  */\n \n static rtx\n-extract_fixed_bit_field (tmode, op0, offset, bitsize, bitpos,\n-\t\t\t target, unsignedp)\n-     enum machine_mode tmode;\n-     rtx op0, target;\n-     unsigned HOST_WIDE_INT offset, bitsize, bitpos;\n-     int unsignedp;\n+extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n+\t\t\t unsigned HOST_WIDE_INT offset,\n+\t\t\t unsigned HOST_WIDE_INT bitsize,\n+\t\t\t unsigned HOST_WIDE_INT bitpos, rtx target,\n+\t\t\t int unsignedp)\n {\n   unsigned int total_bits = BITS_PER_WORD;\n   enum machine_mode mode;\n@@ -1692,9 +1671,7 @@ extract_fixed_bit_field (tmode, op0, offset, bitsize, bitpos,\n    BITSIZE+BITPOS is too small for MODE.  */\n \n static rtx\n-mask_rtx (mode, bitpos, bitsize, complement)\n-     enum machine_mode mode;\n-     int bitpos, bitsize, complement;\n+mask_rtx (enum machine_mode mode, int bitpos, int bitsize, int complement)\n {\n   HOST_WIDE_INT masklow, maskhigh;\n \n@@ -1735,10 +1712,7 @@ mask_rtx (mode, bitpos, bitsize, complement)\n    VALUE truncated to BITSIZE bits and then shifted left BITPOS bits.  */\n \n static rtx\n-lshift_value (mode, value, bitpos, bitsize)\n-     enum machine_mode mode;\n-     rtx value;\n-     int bitpos, bitsize;\n+lshift_value (enum machine_mode mode, rtx value, int bitpos, int bitsize)\n {\n   unsigned HOST_WIDE_INT v = INTVAL (value);\n   HOST_WIDE_INT low, high;\n@@ -1768,10 +1742,8 @@ lshift_value (mode, value, bitpos, bitsize)\n    UNSIGNEDP is 1 if should zero-extend the contents; else sign-extend.  */\n \n static rtx\n-extract_split_bit_field (op0, bitsize, bitpos, unsignedp)\n-     rtx op0;\n-     unsigned HOST_WIDE_INT bitsize, bitpos;\n-     int unsignedp;\n+extract_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n+\t\t\t unsigned HOST_WIDE_INT bitpos, int unsignedp)\n {\n   unsigned int unit;\n   unsigned int bitsdone = 0;\n@@ -1870,8 +1842,7 @@ extract_split_bit_field (op0, bitsize, bitpos, unsignedp)\n /* Add INC into TARGET.  */\n \n void\n-expand_inc (target, inc)\n-     rtx target, inc;\n+expand_inc (rtx target, rtx inc)\n {\n   rtx value = expand_binop (GET_MODE (target), add_optab,\n \t\t\t    target, inc,\n@@ -1883,8 +1854,7 @@ expand_inc (target, inc)\n /* Subtract DEC from TARGET.  */\n \n void\n-expand_dec (target, dec)\n-     rtx target, dec;\n+expand_dec (rtx target, rtx dec)\n {\n   rtx value = expand_binop (GET_MODE (target), sub_optab,\n \t\t\t    target, dec,\n@@ -1901,13 +1871,8 @@ expand_dec (target, dec)\n    Return the rtx for where the value is.  */\n \n rtx\n-expand_shift (code, mode, shifted, amount, target, unsignedp)\n-     enum tree_code code;\n-     enum machine_mode mode;\n-     rtx shifted;\n-     tree amount;\n-     rtx target;\n-     int unsignedp;\n+expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n+\t      tree amount, rtx target, int unsignedp)\n {\n   rtx op1, temp = 0;\n   int left = (code == LSHIFT_EXPR || code == LROTATE_EXPR);\n@@ -2079,25 +2044,19 @@ struct algorithm\n   char log[MAX_BITS_PER_WORD];\n };\n \n-static void synth_mult\t\t\tPARAMS ((struct algorithm *,\n-\t\t\t\t\t\t unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t int));\n-static unsigned HOST_WIDE_INT choose_multiplier PARAMS ((unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t\t int, int,\n-\t\t\t\t\t\t\t unsigned HOST_WIDE_INT *,\n-\t\t\t\t\t\t\t int *, int *));\n-static unsigned HOST_WIDE_INT invert_mod2n\tPARAMS ((unsigned HOST_WIDE_INT,\n-\t\t\t\t\t\t\t int));\n+static void synth_mult (struct algorithm *, unsigned HOST_WIDE_INT, int);\n+static unsigned HOST_WIDE_INT choose_multiplier (unsigned HOST_WIDE_INT, int,\n+\t\t\t\t\t\t int, unsigned HOST_WIDE_INT *,\n+\t\t\t\t\t\t int *, int *);\n+static unsigned HOST_WIDE_INT invert_mod2n (unsigned HOST_WIDE_INT, int);\n /* Compute and return the best algorithm for multiplying by T.\n    The algorithm must cost less than cost_limit\n    If retval.cost >= COST_LIMIT, no algorithm was found and all\n    other field of the returned struct are undefined.  */\n \n static void\n-synth_mult (alg_out, t, cost_limit)\n-     struct algorithm *alg_out;\n-     unsigned HOST_WIDE_INT t;\n-     int cost_limit;\n+synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n+\t    int cost_limit)\n {\n   int m;\n   struct algorithm *alg_in, *best_alg;\n@@ -2341,10 +2300,7 @@ synth_mult (alg_out, t, cost_limit)\n    you should swap the two operands if OP0 would be constant.  */\n \n rtx\n-expand_mult (mode, op0, op1, target, unsignedp)\n-     enum machine_mode mode;\n-     rtx op0, op1, target;\n-     int unsignedp;\n+expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target, int unsignedp)\n {\n   rtx const_op1 = op1;\n \n@@ -2535,9 +2491,9 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \n \t      insn = get_last_insn ();\n \t      set_unique_reg_note (insn,\n-\t      \t\t\t   REG_EQUAL,\n+\t\t\t\t   REG_EQUAL,\n \t\t\t\t   gen_rtx_MULT (nmode, tem,\n-\t\t\t\t   \t         GEN_INT (val_so_far)));\n+\t\t\t\t\t         GEN_INT (val_so_far)));\n \t    }\n \n \t  if (variant == negate_variant)\n@@ -2573,8 +2529,7 @@ expand_mult (mode, op0, op1, target, unsignedp)\n /* Return the smallest n such that 2**n >= X.  */\n \n int\n-ceil_log2 (x)\n-     unsigned HOST_WIDE_INT x;\n+ceil_log2 (unsigned HOST_WIDE_INT x)\n {\n   return floor_log2 (x - 1) + 1;\n }\n@@ -2597,13 +2552,9 @@ ceil_log2 (x)\n \n static\n unsigned HOST_WIDE_INT\n-choose_multiplier (d, n, precision, multiplier_ptr, post_shift_ptr, lgup_ptr)\n-     unsigned HOST_WIDE_INT d;\n-     int n;\n-     int precision;\n-     unsigned HOST_WIDE_INT *multiplier_ptr;\n-     int *post_shift_ptr;\n-     int *lgup_ptr;\n+choose_multiplier (unsigned HOST_WIDE_INT d, int n, int precision,\n+\t\t   unsigned HOST_WIDE_INT *multiplier_ptr,\n+\t\t   int *post_shift_ptr, int *lgup_ptr)\n {\n   HOST_WIDE_INT mhigh_hi, mlow_hi;\n   unsigned HOST_WIDE_INT mhigh_lo, mlow_lo;\n@@ -2694,9 +2645,7 @@ choose_multiplier (d, n, precision, multiplier_ptr, post_shift_ptr, lgup_ptr)\n    congruent to 1 (mod 2**N).  */\n \n static unsigned HOST_WIDE_INT\n-invert_mod2n (x, n)\n-     unsigned HOST_WIDE_INT x;\n-     int n;\n+invert_mod2n (unsigned HOST_WIDE_INT x, int n)\n {\n   /* Solve x*y == 1 (mod 2^n), where x is odd.  Return y.  */\n \n@@ -2731,10 +2680,8 @@ invert_mod2n (x, n)\n    MODE is the mode of operation.  */\n \n rtx\n-expand_mult_highpart_adjust (mode, adj_operand, op0, op1, target, unsignedp)\n-     enum machine_mode mode;\n-     rtx adj_operand, op0, op1, target;\n-     int unsignedp;\n+expand_mult_highpart_adjust (enum machine_mode mode, rtx adj_operand, rtx op0,\n+\t\t\t     rtx op1, rtx target, int unsignedp)\n {\n   rtx tem;\n   enum rtx_code adj_code = unsignedp ? PLUS : MINUS;\n@@ -2768,12 +2715,9 @@ expand_mult_highpart_adjust (mode, adj_operand, op0, op1, target, unsignedp)\n    MAX_COST is the total allowed cost for the expanded RTL.  */\n \n rtx\n-expand_mult_highpart (mode, op0, cnst1, target, unsignedp, max_cost)\n-     enum machine_mode mode;\n-     rtx op0, target;\n-     unsigned HOST_WIDE_INT cnst1;\n-     int unsignedp;\n-     int max_cost;\n+expand_mult_highpart (enum machine_mode mode, rtx op0,\n+\t\t      unsigned HOST_WIDE_INT cnst1, rtx target,\n+\t\t      int unsignedp, int max_cost)\n {\n   enum machine_mode wider_mode = GET_MODE_WIDER_MODE (mode);\n   optab mul_highpart_optab;\n@@ -2945,12 +2889,8 @@ expand_mult_highpart (mode, op0, cnst1, target, unsignedp, max_cost)\n #define EXACT_POWER_OF_2_OR_ZERO_P(x) (((x) & ((x) - 1)) == 0)\n \n rtx\n-expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n-     int rem_flag;\n-     enum tree_code code;\n-     enum machine_mode mode;\n-     rtx op0, op1, target;\n-     int unsignedp;\n+expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n+\t       rtx op0, rtx op1, rtx target, int unsignedp)\n {\n   enum machine_mode compute_mode;\n   rtx tquotient;\n@@ -3266,7 +3206,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t    && (set = single_set (insn)) != 0\n \t\t    && SET_DEST (set) == quotient)\n \t\t  set_unique_reg_note (insn,\n-\t\t  \t\t       REG_EQUAL,\n+\t\t\t\t       REG_EQUAL,\n \t\t\t\t       gen_rtx_UDIV (compute_mode, op0, op1));\n \t      }\n \t    else\t\t/* TRUNC_DIV, signed */\n@@ -3354,7 +3294,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t\t    && abs_d < ((unsigned HOST_WIDE_INT) 1\n \t\t\t\t\t<< (HOST_BITS_PER_WIDE_INT - 1)))\n \t\t\t  set_unique_reg_note (insn,\n-\t\t\t  \t\t       REG_EQUAL,\n+\t\t\t\t\t       REG_EQUAL,\n \t\t\t\t\t       gen_rtx_DIV (compute_mode,\n \t\t\t\t\t\t\t    op0,\n \t\t\t\t\t\t\t    GEN_INT\n@@ -3445,7 +3385,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t    && (set = single_set (insn)) != 0\n \t\t    && SET_DEST (set) == quotient)\n \t\t  set_unique_reg_note (insn,\n-\t\t  \t\t       REG_EQUAL,\n+\t\t\t\t       REG_EQUAL,\n \t\t\t\t       gen_rtx_DIV (compute_mode, op0, op1));\n \t      }\n \t    break;\n@@ -3865,7 +3805,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \n \t    insn = get_last_insn ();\n \t    set_unique_reg_note (insn,\n-\t    \t\t\t REG_EQUAL,\n+\t\t\t\t REG_EQUAL,\n \t\t\t\t gen_rtx_fmt_ee (unsignedp ? UDIV : DIV,\n \t\t\t\t\t\t compute_mode,\n \t\t\t\t\t\t op0, op1));\n@@ -4044,9 +3984,7 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n    generated by loop.c.  */\n \n tree\n-make_tree (type, x)\n-     tree type;\n-     rtx x;\n+make_tree (tree type, rtx x)\n {\n   tree t;\n \n@@ -4177,10 +4115,7 @@ make_tree (type, x)\n    UNSIGNEDP is nonzero to do unsigned multiplication.  */\n \n bool\n-const_mult_add_overflow_p (x, mult, add, mode, unsignedp)\n-     rtx x, mult, add;\n-     enum machine_mode mode;\n-     int unsignedp;\n+const_mult_add_overflow_p (rtx x, rtx mult, rtx add, enum machine_mode mode, int unsignedp)\n {\n   tree type, mult_type, add_type, result;\n \n@@ -4216,10 +4151,8 @@ const_mult_add_overflow_p (x, mult, add, mode, unsignedp)\n    This may emit insns.  */\n \n rtx\n-expand_mult_add (x, target, mult, add, mode, unsignedp)\n-     rtx x, target, mult, add;\n-     enum machine_mode mode;\n-     int unsignedp;\n+expand_mult_add (rtx x, rtx target, rtx mult, rtx add, enum machine_mode mode,\n+\t\t int unsignedp)\n {\n   tree type = (*lang_hooks.types.type_for_mode) (mode, unsignedp);\n   tree add_type = (GET_MODE (add) == VOIDmode\n@@ -4240,9 +4173,7 @@ expand_mult_add (x, target, mult, add, mode, unsignedp)\n    If TARGET is 0, a pseudo-register or constant is returned.  */\n \n rtx\n-expand_and (mode, op0, op1, target)\n-     enum machine_mode mode;\n-     rtx op0, op1, target;\n+expand_and (enum machine_mode mode, rtx op0, rtx op1, rtx target)\n {\n   rtx tem = 0;\n \n@@ -4274,13 +4205,8 @@ expand_and (mode, op0, op1, target)\n    \"raw\" out of the scc insn.  */\n \n rtx\n-emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n-     rtx target;\n-     enum rtx_code code;\n-     rtx op0, op1;\n-     enum machine_mode mode;\n-     int unsignedp;\n-     int normalizep;\n+emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n+\t\t enum machine_mode mode, int unsignedp, int normalizep)\n {\n   rtx subtarget;\n   enum insn_code icode;\n@@ -4714,13 +4640,8 @@ emit_store_flag (target, code, op0, op1, mode, unsignedp, normalizep)\n /* Like emit_store_flag, but always succeeds.  */\n \n rtx\n-emit_store_flag_force (target, code, op0, op1, mode, unsignedp, normalizep)\n-     rtx target;\n-     enum rtx_code code;\n-     rtx op0, op1;\n-     enum machine_mode mode;\n-     int unsignedp;\n-     int normalizep;\n+emit_store_flag_force (rtx target, enum rtx_code code, rtx op0, rtx op1,\n+\t\t       enum machine_mode mode, int unsignedp, int normalizep)\n {\n   rtx tem, label;\n \n@@ -4759,10 +4680,8 @@ emit_store_flag_force (target, code, op0, op1, mode, unsignedp, normalizep)\n    be handled if needed).  */\n \n static void\n-do_cmp_and_jump (arg1, arg2, op, mode, label)\n-     rtx arg1, arg2, label;\n-     enum rtx_code op;\n-     enum machine_mode mode;\n+do_cmp_and_jump (rtx arg1, rtx arg2, enum rtx_code op, enum machine_mode mode,\n+\t\t rtx label)\n {\n   /* If this mode is an integer too wide to compare properly,\n      compare word by word.  Rely on cse to optimize constant cases.  */"}, {"sha": "de1137f523fd0fb01ee416cd75c23b75acb8530f", "filename": "gcc/expr.c", "status": "modified", "additions": 149, "deletions": 311, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=502b832280c67d89300d92b91e73a9d3093db4a8", "patch": "@@ -125,60 +125,52 @@ struct store_by_pieces\n   int explicit_inc_to;\n   unsigned HOST_WIDE_INT len;\n   HOST_WIDE_INT offset;\n-  rtx (*constfun) PARAMS ((void *, HOST_WIDE_INT, enum machine_mode));\n+  rtx (*constfun) (void *, HOST_WIDE_INT, enum machine_mode);\n   void *constfundata;\n   int reverse;\n };\n \n-static rtx enqueue_insn\t\tPARAMS ((rtx, rtx));\n-static unsigned HOST_WIDE_INT move_by_pieces_ninsns\n-\t\t\t\tPARAMS ((unsigned HOST_WIDE_INT,\n-\t\t\t\t\t unsigned int));\n-static void move_by_pieces_1\tPARAMS ((rtx (*) (rtx, ...), enum machine_mode,\n-\t\t\t\t\t struct move_by_pieces *));\n-static bool block_move_libcall_safe_for_call_parm PARAMS ((void));\n-static bool emit_block_move_via_movstr PARAMS ((rtx, rtx, rtx, unsigned));\n-static rtx emit_block_move_via_libcall PARAMS ((rtx, rtx, rtx));\n-static tree emit_block_move_libcall_fn PARAMS ((int));\n-static void emit_block_move_via_loop PARAMS ((rtx, rtx, rtx, unsigned));\n-static rtx clear_by_pieces_1\tPARAMS ((void *, HOST_WIDE_INT,\n-\t\t\t\t\t enum machine_mode));\n-static void clear_by_pieces\tPARAMS ((rtx, unsigned HOST_WIDE_INT,\n-\t\t\t\t\t unsigned int));\n-static void store_by_pieces_1\tPARAMS ((struct store_by_pieces *,\n-\t\t\t\t\t unsigned int));\n-static void store_by_pieces_2\tPARAMS ((rtx (*) (rtx, ...),\n-\t\t\t\t\t enum machine_mode,\n-\t\t\t\t\t struct store_by_pieces *));\n-static bool clear_storage_via_clrstr PARAMS ((rtx, rtx, unsigned));\n-static rtx clear_storage_via_libcall PARAMS ((rtx, rtx));\n-static tree clear_storage_libcall_fn PARAMS ((int));\n-static rtx compress_float_constant PARAMS ((rtx, rtx));\n-static rtx get_subtarget\tPARAMS ((rtx));\n-static int is_zeros_p         PARAMS ((tree));\n-static int mostly_zeros_p\tPARAMS ((tree));\n-static void store_constructor_field PARAMS ((rtx, unsigned HOST_WIDE_INT,\n-\t\t\t\t\t     HOST_WIDE_INT, enum machine_mode,\n-\t\t\t\t\t     tree, tree, int, int));\n-static void store_constructor\tPARAMS ((tree, rtx, int, HOST_WIDE_INT));\n-static rtx store_field\t\tPARAMS ((rtx, HOST_WIDE_INT,\n-\t\t\t\t\t HOST_WIDE_INT, enum machine_mode,\n-\t\t\t\t\t tree, enum machine_mode, int, tree,\n-\t\t\t\t\t int));\n-static rtx var_rtx\t\tPARAMS ((tree));\n-\n-static unsigned HOST_WIDE_INT highest_pow2_factor PARAMS ((tree));\n-static unsigned HOST_WIDE_INT highest_pow2_factor_for_type PARAMS ((tree,\n-\t\t\t\t\t\t\t\t    tree));\n-\n-static int is_aligning_offset\tPARAMS ((tree, tree));\n-static rtx expand_increment\tPARAMS ((tree, int, int));\n-static rtx do_store_flag\tPARAMS ((tree, rtx, enum machine_mode, int));\n+static rtx enqueue_insn (rtx, rtx);\n+static unsigned HOST_WIDE_INT move_by_pieces_ninsns (unsigned HOST_WIDE_INT,\n+\t\t\t\t\t\t     unsigned int);\n+static void move_by_pieces_1 (rtx (*) (rtx, ...), enum machine_mode,\n+\t\t\t      struct move_by_pieces *);\n+static bool block_move_libcall_safe_for_call_parm (void);\n+static bool emit_block_move_via_movstr (rtx, rtx, rtx, unsigned);\n+static rtx emit_block_move_via_libcall (rtx, rtx, rtx);\n+static tree emit_block_move_libcall_fn (int);\n+static void emit_block_move_via_loop (rtx, rtx, rtx, unsigned);\n+static rtx clear_by_pieces_1 (void *, HOST_WIDE_INT, enum machine_mode);\n+static void clear_by_pieces (rtx, unsigned HOST_WIDE_INT, unsigned int);\n+static void store_by_pieces_1 (struct store_by_pieces *, unsigned int);\n+static void store_by_pieces_2 (rtx (*) (rtx, ...), enum machine_mode,\n+\t\t\t       struct store_by_pieces *);\n+static bool clear_storage_via_clrstr (rtx, rtx, unsigned);\n+static rtx clear_storage_via_libcall (rtx, rtx);\n+static tree clear_storage_libcall_fn (int);\n+static rtx compress_float_constant (rtx, rtx);\n+static rtx get_subtarget (rtx);\n+static int is_zeros_p (tree);\n+static int mostly_zeros_p (tree);\n+static void store_constructor_field (rtx, unsigned HOST_WIDE_INT,\n+\t\t\t\t     HOST_WIDE_INT, enum machine_mode,\n+\t\t\t\t     tree, tree, int, int);\n+static void store_constructor (tree, rtx, int, HOST_WIDE_INT);\n+static rtx store_field (rtx, HOST_WIDE_INT, HOST_WIDE_INT, enum machine_mode,\n+\t\t\ttree, enum machine_mode, int, tree, int);\n+static rtx var_rtx (tree);\n+\n+static unsigned HOST_WIDE_INT highest_pow2_factor (tree);\n+static unsigned HOST_WIDE_INT highest_pow2_factor_for_type (tree, tree);\n+\n+static int is_aligning_offset (tree, tree);\n+static rtx expand_increment (tree, int, int);\n+static rtx do_store_flag (tree, rtx, enum machine_mode, int);\n #ifdef PUSH_ROUNDING\n-static void emit_single_push_insn PARAMS ((enum machine_mode, rtx, tree));\n+static void emit_single_push_insn (enum machine_mode, rtx, tree);\n #endif\n-static void do_tablejump PARAMS ((rtx, enum machine_mode, rtx, rtx, rtx));\n-static rtx const_vector_from_tree PARAMS ((tree));\n+static void do_tablejump (rtx, enum machine_mode, rtx, rtx, rtx);\n+static rtx const_vector_from_tree (tree);\n \n /* Record for each mode whether we can move a register directly to or\n    from an object of that mode in memory.  If we can't, we won't try\n@@ -252,7 +244,7 @@ enum insn_code clrstr_optab[NUM_MACHINE_MODES];\n    directly in memory and to initialize the block move optab.  */\n \n void\n-init_expr_once ()\n+init_expr_once (void)\n {\n   rtx insn, pat;\n   enum machine_mode mode;\n@@ -345,7 +337,7 @@ init_expr_once ()\n /* This is run at the start of compiling a function.  */\n \n void\n-init_expr ()\n+init_expr (void)\n {\n   cfun->expr = (struct expr_status *) ggc_alloc (sizeof (struct expr_status));\n \n@@ -361,7 +353,7 @@ init_expr ()\n /* Small sanity check that the queue is empty at the end of a function.  */\n \n void\n-finish_expr_for_function ()\n+finish_expr_for_function (void)\n {\n   if (pending_chain)\n     abort ();\n@@ -378,8 +370,7 @@ finish_expr_for_function ()\n    where you want to guarantee the pre-incrementation value of VAR.  */\n \n static rtx\n-enqueue_insn (var, body)\n-     rtx var, body;\n+enqueue_insn (rtx var, rtx body)\n {\n   pending_chain = gen_rtx_QUEUED (GET_MODE (var), var, NULL_RTX, NULL_RTX,\n \t\t\t\t  body, pending_chain);\n@@ -402,9 +393,7 @@ enqueue_insn (var, body)\n    If the queue is flushed in between, incorrect code will result.  */\n \n rtx\n-protect_from_queue (x, modify)\n-     rtx x;\n-     int modify;\n+protect_from_queue (rtx x, int modify)\n {\n   RTX_CODE code = GET_CODE (x);\n \n@@ -488,8 +477,7 @@ protect_from_queue (x, modify)\n    since memory addresses generally contain only those.  */\n \n int\n-queued_subexp_p (x)\n-     rtx x;\n+queued_subexp_p (rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   switch (code)\n@@ -511,7 +499,7 @@ queued_subexp_p (x)\n /* Perform all the pending incrementations.  */\n \n void\n-emit_queue ()\n+emit_queue (void)\n {\n   rtx p;\n   while ((p = pending_chain))\n@@ -551,9 +539,7 @@ emit_queue ()\n    This causes zero-extension instead of sign-extension.  */\n \n void\n-convert_move (to, from, unsignedp)\n-     rtx to, from;\n-     int unsignedp;\n+convert_move (rtx to, rtx from, int unsignedp)\n {\n   enum machine_mode to_mode = GET_MODE (to);\n   enum machine_mode from_mode = GET_MODE (from);\n@@ -1332,10 +1318,7 @@ convert_move (to, from, unsignedp)\n    except when putting X into an insn (in which case convert_move does it).  */\n \n rtx\n-convert_to_mode (mode, x, unsignedp)\n-     enum machine_mode mode;\n-     rtx x;\n-     int unsignedp;\n+convert_to_mode (enum machine_mode mode, rtx x, int unsignedp)\n {\n   return convert_modes (mode, VOIDmode, x, unsignedp);\n }\n@@ -1354,10 +1337,7 @@ convert_to_mode (mode, x, unsignedp)\n    except when putting X into an insn (in which case convert_move does it).  */\n \n rtx\n-convert_modes (mode, oldmode, x, unsignedp)\n-     enum machine_mode mode, oldmode;\n-     rtx x;\n-     int unsignedp;\n+convert_modes (enum machine_mode mode, enum machine_mode oldmode, rtx x, int unsignedp)\n {\n   rtx temp;\n \n@@ -1468,9 +1448,8 @@ convert_modes (mode, oldmode, x, unsignedp)\n    succeed.  */\n \n int\n-can_move_by_pieces (len, align)\n-     unsigned HOST_WIDE_INT len;\n-     unsigned int align ATTRIBUTE_UNUSED;\n+can_move_by_pieces (unsigned HOST_WIDE_INT len,\n+\t\t    unsigned int align ATTRIBUTE_UNUSED)\n {\n   return MOVE_BY_PIECES_P (len, align);\n }\n@@ -1489,11 +1468,8 @@ can_move_by_pieces (len, align)\n    stpcpy.  */\n \n rtx\n-move_by_pieces (to, from, len, align, endp)\n-     rtx to, from;\n-     unsigned HOST_WIDE_INT len;\n-     unsigned int align;\n-     int endp;\n+move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,\n+\t\tunsigned int align, int endp)\n {\n   struct move_by_pieces data;\n   rtx to_addr, from_addr = XEXP (from, 0);\n@@ -1643,9 +1619,7 @@ move_by_pieces (to, from, len, align, endp)\n    ALIGN (in bits) is maximum alignment we can assume.  */\n \n static unsigned HOST_WIDE_INT\n-move_by_pieces_ninsns (l, align)\n-     unsigned HOST_WIDE_INT l;\n-     unsigned int align;\n+move_by_pieces_ninsns (unsigned HOST_WIDE_INT l, unsigned int align)\n {\n   unsigned HOST_WIDE_INT n_insns = 0;\n   unsigned HOST_WIDE_INT max_size = MOVE_MAX + 1;\n@@ -1684,10 +1658,8 @@ move_by_pieces_ninsns (l, align)\n    to make a move insn for that mode.  DATA has all the other info.  */\n \n static void\n-move_by_pieces_1 (genfun, mode, data)\n-     rtx (*genfun) PARAMS ((rtx, ...));\n-     enum machine_mode mode;\n-     struct move_by_pieces *data;\n+move_by_pieces_1 (rtx (*genfun) (rtx, ...), enum machine_mode mode,\n+\t\t  struct move_by_pieces *data)\n {\n   unsigned int size = GET_MODE_SIZE (mode);\n   rtx to1 = NULL_RTX, from1;\n@@ -1755,9 +1727,7 @@ move_by_pieces_1 (genfun, mode, data)\n    0 otherwise.  */\n \n rtx\n-emit_block_move (x, y, size, method)\n-     rtx x, y, size;\n-     enum block_op_methods method;\n+emit_block_move (rtx x, rtx y, rtx size, enum block_op_methods method)\n {\n   bool may_use_call;\n   rtx retval = 0;\n@@ -1828,12 +1798,12 @@ emit_block_move (x, y, size, method)\n   return retval;\n }\n \n-/* A subroutine of emit_block_move.  Returns true if calling the \n+/* A subroutine of emit_block_move.  Returns true if calling the\n    block move libcall will not clobber any parameters which may have\n    already been placed on the stack.  */\n \n static bool\n-block_move_libcall_safe_for_call_parm ()\n+block_move_libcall_safe_for_call_parm (void)\n {\n   if (PUSH_ARGS)\n     return true;\n@@ -1887,13 +1857,11 @@ block_move_libcall_safe_for_call_parm ()\n     }\n }\n \n-/* A subroutine of emit_block_move.  Expand a movstr pattern; \n+/* A subroutine of emit_block_move.  Expand a movstr pattern;\n    return true if successful.  */\n \n static bool\n-emit_block_move_via_movstr (x, y, size, align)\n-     rtx x, y, size;\n-     unsigned int align;\n+emit_block_move_via_movstr (rtx x, rtx y, rtx size, unsigned int align)\n {\n   rtx opalign = GEN_INT (align / BITS_PER_UNIT);\n   enum machine_mode mode;\n@@ -1961,8 +1929,7 @@ emit_block_move_via_movstr (x, y, size, align)\n    Return the return value from memcpy, 0 otherwise.  */\n \n static rtx\n-emit_block_move_via_libcall (dst, src, size)\n-     rtx dst, src, size;\n+emit_block_move_via_libcall (rtx dst, rtx src, rtx size)\n {\n   rtx dst_addr, src_addr;\n   tree call_expr, arg_list, fn, src_tree, dst_tree, size_tree;\n@@ -2063,8 +2030,7 @@ emit_block_move_via_libcall (dst, src, size)\n static GTY(()) tree block_move_fn;\n \n void\n-init_block_move_fn (asmspec)\n-     const char *asmspec;\n+init_block_move_fn (const char *asmspec)\n {\n   if (!block_move_fn)\n     {\n@@ -2102,8 +2068,7 @@ init_block_move_fn (asmspec)\n }\n \n static tree\n-emit_block_move_libcall_fn (for_call)\n-     int for_call;\n+emit_block_move_libcall_fn (int for_call)\n {\n   static bool emitted_extern;\n \n@@ -2125,9 +2090,8 @@ emit_block_move_libcall_fn (for_call)\n /* ??? It'd be nice to copy in hunks larger than QImode.  */\n \n static void\n-emit_block_move_via_loop (x, y, size, align)\n-     rtx x, y, size;\n-     unsigned int align ATTRIBUTE_UNUSED;\n+emit_block_move_via_loop (rtx x, rtx y, rtx size,\n+\t\t\t  unsigned int align ATTRIBUTE_UNUSED)\n {\n   rtx cmp_label, top_label, iter, x_addr, y_addr, tmp;\n   enum machine_mode iter_mode;\n@@ -2177,11 +2141,7 @@ emit_block_move_via_loop (x, y, size, align)\n    The number of registers to be filled is NREGS.  */\n \n void\n-move_block_to_reg (regno, x, nregs, mode)\n-     int regno;\n-     rtx x;\n-     int nregs;\n-     enum machine_mode mode;\n+move_block_to_reg (int regno, rtx x, int nregs, enum machine_mode mode)\n {\n   int i;\n #ifdef HAVE_load_multiple\n@@ -2221,10 +2181,7 @@ move_block_to_reg (regno, x, nregs, mode)\n    The number of registers to be filled is NREGS.  */\n \n void\n-move_block_from_reg (regno, x, nregs)\n-     int regno;\n-     rtx x;\n-     int nregs;\n+move_block_from_reg (int regno, rtx x, int nregs)\n {\n   int i;\n \n@@ -2266,8 +2223,7 @@ move_block_from_reg (regno, x, nregs)\n    The new set has the same modes as the original set.  */\n \n rtx\n-gen_group_rtx (orig)\n-     rtx orig;\n+gen_group_rtx (rtx orig)\n {\n   int i, length;\n   rtx *tmps;\n@@ -2306,9 +2262,7 @@ gen_group_rtx (orig)\n    would be needed.  */\n \n void\n-emit_group_load (dst, orig_src, ssize)\n-     rtx dst, orig_src;\n-     int ssize;\n+emit_group_load (rtx dst, rtx orig_src, int ssize)\n {\n   rtx *tmps, src;\n   int start, i;\n@@ -2433,8 +2387,7 @@ emit_group_load (dst, orig_src, ssize)\n    non-consecutive groups of registers, each represented by a PARALLEL.  */\n \n void\n-emit_group_move (dst, src)\n-     rtx dst, src;\n+emit_group_move (rtx dst, rtx src)\n {\n   int i;\n \n@@ -2454,9 +2407,7 @@ emit_group_move (dst, src)\n    block DST, or -1 if not known.  */\n \n void\n-emit_group_store (orig_dst, src, ssize)\n-     rtx orig_dst, src;\n-     int ssize;\n+emit_group_store (rtx orig_dst, rtx src, int ssize)\n {\n   rtx *tmps, dst;\n   int start, i;\n@@ -2581,10 +2532,7 @@ emit_group_store (orig_dst, src, ssize)\n    in registers regardless of the structure's alignment.  */\n \n rtx\n-copy_blkmode_from_reg (tgtblk, srcreg, type)\n-     rtx tgtblk;\n-     rtx srcreg;\n-     tree type;\n+copy_blkmode_from_reg (rtx tgtblk, rtx srcreg, tree type)\n {\n   unsigned HOST_WIDE_INT bytes = int_size_in_bytes (type);\n   rtx src = NULL, dst = NULL;\n@@ -2655,8 +2603,7 @@ copy_blkmode_from_reg (tgtblk, srcreg, type)\n    to by CALL_FUSAGE.  REG must denote a hard register.  */\n \n void\n-use_reg (call_fusage, reg)\n-     rtx *call_fusage, reg;\n+use_reg (rtx *call_fusage, rtx reg)\n {\n   if (GET_CODE (reg) != REG\n       || REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n@@ -2671,10 +2618,7 @@ use_reg (call_fusage, reg)\n    starting at REGNO.  All of these registers must be hard registers.  */\n \n void\n-use_regs (call_fusage, regno, nregs)\n-     rtx *call_fusage;\n-     int regno;\n-     int nregs;\n+use_regs (rtx *call_fusage, int regno, int nregs)\n {\n   int i;\n \n@@ -2690,9 +2634,7 @@ use_regs (call_fusage, regno, nregs)\n    non-contiguous locations.  The Irix 6 ABI has examples of this.  */\n \n void\n-use_group_regs (call_fusage, regs)\n-     rtx *call_fusage;\n-     rtx regs;\n+use_group_regs (rtx *call_fusage, rtx regs)\n {\n   int i;\n \n@@ -2716,11 +2658,9 @@ use_group_regs (call_fusage, regs)\n    call to store_by_pieces should succeed.  */\n \n int\n-can_store_by_pieces (len, constfun, constfundata, align)\n-     unsigned HOST_WIDE_INT len;\n-     rtx (*constfun) PARAMS ((void *, HOST_WIDE_INT, enum machine_mode));\n-     void *constfundata;\n-     unsigned int align;\n+can_store_by_pieces (unsigned HOST_WIDE_INT len,\n+\t\t     rtx (*constfun) (void *, HOST_WIDE_INT, enum machine_mode),\n+\t\t     void *constfundata, unsigned int align)\n {\n   unsigned HOST_WIDE_INT max_size, l;\n   HOST_WIDE_INT offset = 0;\n@@ -2798,13 +2738,9 @@ can_store_by_pieces (len, constfun, constfundata, align)\n    stpcpy.  */\n \n rtx\n-store_by_pieces (to, len, constfun, constfundata, align, endp)\n-     rtx to;\n-     unsigned HOST_WIDE_INT len;\n-     rtx (*constfun) PARAMS ((void *, HOST_WIDE_INT, enum machine_mode));\n-     void *constfundata;\n-     unsigned int align;\n-     int endp;\n+store_by_pieces (rtx to, unsigned HOST_WIDE_INT len,\n+\t\t rtx (*constfun) (void *, HOST_WIDE_INT, enum machine_mode),\n+\t\t void *constfundata, unsigned int align, int endp)\n {\n   struct store_by_pieces data;\n \n@@ -2852,10 +2788,7 @@ store_by_pieces (to, len, constfun, constfundata, align, endp)\n    before calling. ALIGN is maximum alignment we can assume.  */\n \n static void\n-clear_by_pieces (to, len, align)\n-     rtx to;\n-     unsigned HOST_WIDE_INT len;\n-     unsigned int align;\n+clear_by_pieces (rtx to, long unsigned int len, unsigned int align)\n {\n   struct store_by_pieces data;\n \n@@ -2870,10 +2803,9 @@ clear_by_pieces (to, len, align)\n    Return const0_rtx unconditionally.  */\n \n static rtx\n-clear_by_pieces_1 (data, offset, mode)\n-     void *data ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT offset ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+clear_by_pieces_1 (void *data ATTRIBUTE_UNUSED,\n+\t\t   HOST_WIDE_INT offset ATTRIBUTE_UNUSED,\n+\t\t   enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return const0_rtx;\n }\n@@ -2884,9 +2816,8 @@ clear_by_pieces_1 (data, offset, mode)\n    before calling.  ALIGN is maximum alignment we can assume.  */\n \n static void\n-store_by_pieces_1 (data, align)\n-     struct store_by_pieces *data;\n-     unsigned int align;\n+store_by_pieces_1 (struct store_by_pieces *data ATTRIBUTE_UNUSED,\n+\t\t   unsigned int align ATTRIBUTE_UNUSED)\n {\n   rtx to_addr = XEXP (data->to, 0);\n   unsigned HOST_WIDE_INT max_size = STORE_MAX_PIECES + 1;\n@@ -2970,10 +2901,8 @@ store_by_pieces_1 (data, align)\n    to make a move insn for that mode.  DATA has all the other info.  */\n \n static void\n-store_by_pieces_2 (genfun, mode, data)\n-     rtx (*genfun) PARAMS ((rtx, ...));\n-     enum machine_mode mode;\n-     struct store_by_pieces *data;\n+store_by_pieces_2 (rtx (*genfun) (rtx, ...), enum machine_mode mode,\n+\t\t   struct store_by_pieces *data)\n {\n   unsigned int size = GET_MODE_SIZE (mode);\n   rtx to1, cst;\n@@ -3010,9 +2939,7 @@ store_by_pieces_2 (genfun, mode, data)\n    its length in bytes.  */\n \n rtx\n-clear_storage (object, size)\n-     rtx object;\n-     rtx size;\n+clear_storage (rtx object, rtx size)\n {\n   rtx retval = 0;\n   unsigned int align = (GET_CODE (object) == MEM ? MEM_ALIGN (object)\n@@ -3045,9 +2972,7 @@ clear_storage (object, size)\n    return true if successful.  */\n \n static bool\n-clear_storage_via_clrstr (object, size, align)\n-     rtx object, size;\n-     unsigned int align;\n+clear_storage_via_clrstr (rtx object, rtx size, unsigned int align)\n {\n   /* Try the most limited insn first, because there's no point\n      including more than one in the machine description unless\n@@ -3103,8 +3028,7 @@ clear_storage_via_clrstr (object, size, align)\n    Return the return value of memset, 0 otherwise.  */\n \n static rtx\n-clear_storage_via_libcall (object, size)\n-     rtx object, size;\n+clear_storage_via_libcall (rtx object, rtx size)\n {\n   tree call_expr, arg_list, fn, object_tree, size_tree;\n   enum machine_mode size_mode;\n@@ -3184,8 +3108,7 @@ clear_storage_via_libcall (object, size)\n static GTY(()) tree block_clear_fn;\n \n void\n-init_block_clear_fn (asmspec)\n-     const char *asmspec;\n+init_block_clear_fn (const char *asmspec)\n {\n   if (!block_clear_fn)\n     {\n@@ -3222,8 +3145,7 @@ init_block_clear_fn (asmspec)\n }\n \n static tree\n-clear_storage_libcall_fn (for_call)\n-     int for_call;\n+clear_storage_libcall_fn (int for_call)\n {\n   static bool emitted_extern;\n \n@@ -3248,8 +3170,7 @@ clear_storage_libcall_fn (for_call)\n    Return the last instruction emitted.  */\n \n rtx\n-emit_move_insn (x, y)\n-     rtx x, y;\n+emit_move_insn (rtx x, rtx y)\n {\n   enum machine_mode mode = GET_MODE (x);\n   rtx y_cst = NULL_RTX;\n@@ -3319,8 +3240,7 @@ emit_move_insn (x, y)\n    are basically valid.  */\n \n rtx\n-emit_move_insn_1 (x, y)\n-     rtx x, y;\n+emit_move_insn_1 (rtx x, rtx y)\n {\n   enum machine_mode mode = GET_MODE (x);\n   enum machine_mode submode;\n@@ -3541,7 +3461,7 @@ emit_move_insn_1 (x, y)\n \t  x = gen_lowpart (tmode, x);\n \t  y = gen_lowpart (tmode, y);\n \t}\n-\t  \n+\n       insn_code = mov_optab->handlers[(int) tmode].insn_code;\n       return emit_insn (GEN_FCN (insn_code) (x, y));\n     }\n@@ -3662,8 +3582,7 @@ emit_move_insn_1 (x, y)\n    move as an extension.  */\n \n static rtx\n-compress_float_constant (x, y)\n-     rtx x, y;\n+compress_float_constant (rtx x, rtx y)\n {\n   enum machine_mode dstmode = GET_MODE (x);\n   enum machine_mode orig_srcmode = GET_MODE (y);\n@@ -3726,9 +3645,7 @@ compress_float_constant (x, y)\n    otherwise, the padding comes at high addresses.  */\n \n rtx\n-push_block (size, extra, below)\n-     rtx size;\n-     int extra, below;\n+push_block (rtx size, int extra, int below)\n {\n   rtx temp;\n \n@@ -3777,10 +3694,7 @@ push_block (size, extra, below)\n /* Emit single push insn.  */\n \n static void\n-emit_single_push_insn (mode, x, type)\n-     rtx x;\n-     enum machine_mode mode;\n-     tree type;\n+emit_single_push_insn (enum machine_mode mode, rtx x, tree type)\n {\n   rtx dest_addr;\n   unsigned rounded_size = PUSH_ROUNDING (GET_MODE_SIZE (mode));\n@@ -3900,21 +3814,10 @@ emit_single_push_insn (mode, x, type)\n    of bytes required.  */\n \n void\n-emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n-\t\targs_addr, args_so_far, reg_parm_stack_space,\n-\t\talignment_pad)\n-     rtx x;\n-     enum machine_mode mode;\n-     tree type;\n-     rtx size;\n-     unsigned int align;\n-     int partial;\n-     rtx reg;\n-     int extra;\n-     rtx args_addr;\n-     rtx args_so_far;\n-     int reg_parm_stack_space;\n-     rtx alignment_pad;\n+emit_push_insn (rtx x, enum machine_mode mode, tree type, rtx size,\n+\t\tunsigned int align, int partial, rtx reg, int extra,\n+\t\trtx args_addr, rtx args_so_far, int reg_parm_stack_space,\n+\t\trtx alignment_pad)\n {\n   rtx xinner;\n   enum direction stack_direction\n@@ -4185,8 +4088,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n    operations.  */\n \n static rtx\n-get_subtarget (x)\n-     rtx x;\n+get_subtarget (rtx x)\n {\n   return ((x == 0\n \t   /* Only registers can be subtargets.  */\n@@ -4213,10 +4115,8 @@ get_subtarget (x)\n    We now use WANT_VALUE to decide whether to do this.  */\n \n rtx\n-expand_assignment (to, from, want_value, suggest_reg)\n-     tree to, from;\n-     int want_value;\n-     int suggest_reg ATTRIBUTE_UNUSED;\n+expand_assignment (tree to, tree from, int want_value,\n+\t\t   int suggest_reg ATTRIBUTE_UNUSED)\n {\n   rtx to_rtx = 0;\n   rtx result;\n@@ -4488,10 +4388,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n    stack, and block moves may need to be treated specially.  */\n \n rtx\n-store_expr (exp, target, want_value)\n-     tree exp;\n-     rtx target;\n-     int want_value;\n+store_expr (tree exp, rtx target, int want_value)\n {\n   rtx temp;\n   int dont_return_target = 0;\n@@ -4631,8 +4528,8 @@ store_expr (exp, target, want_value)\n \t\t\t  want_value & 2 ? EXPAND_STACK_PARM : EXPAND_NORMAL);\n \n       /* If TEMP is a MEM and we want a result value, make the access\n-\t now so it gets done only once.  Strictly speaking, this is \n-\t only necessary if the MEM is volatile, or if the address \n+\t now so it gets done only once.  Strictly speaking, this is\n+\t only necessary if the MEM is volatile, or if the address\n \t overlaps TARGET.  But not performing the load twice also\n \t reduces the amount of rtl we generate and then have to CSE.  */\n       if (GET_CODE (temp) == MEM && (want_value & 1) != 0)\n@@ -4851,8 +4748,7 @@ store_expr (exp, target, want_value)\n /* Return 1 if EXP just contains zeros.  */\n \n static int\n-is_zeros_p (exp)\n-     tree exp;\n+is_zeros_p (tree exp)\n {\n   tree elt;\n \n@@ -4899,8 +4795,7 @@ is_zeros_p (exp)\n /* Return 1 if EXP contains mostly (3/4)  zeros.  */\n \n static int\n-mostly_zeros_p (exp)\n-     tree exp;\n+mostly_zeros_p (tree exp)\n {\n   if (TREE_CODE (exp) == CONSTRUCTOR)\n     {\n@@ -4941,15 +4836,9 @@ mostly_zeros_p (exp)\n    clear a substructure if the outer structure has already been cleared.  */\n \n static void\n-store_constructor_field (target, bitsize, bitpos, mode, exp, type, cleared,\n-\t\t\t alias_set)\n-     rtx target;\n-     unsigned HOST_WIDE_INT bitsize;\n-     HOST_WIDE_INT bitpos;\n-     enum machine_mode mode;\n-     tree exp, type;\n-     int cleared;\n-     int alias_set;\n+store_constructor_field (rtx target, unsigned HOST_WIDE_INT bitsize,\n+\t\t\t HOST_WIDE_INT bitpos, enum machine_mode mode,\n+\t\t\t tree exp, tree type, int cleared, int alias_set)\n {\n   if (TREE_CODE (exp) == CONSTRUCTOR\n       && bitpos % BITS_PER_UNIT == 0\n@@ -4991,11 +4880,7 @@ store_constructor_field (target, bitsize, bitpos, mode, exp, type, cleared,\n    which has been packed to exclude padding bits.  */\n \n static void\n-store_constructor (exp, target, cleared, size)\n-     tree exp;\n-     rtx target;\n-     int cleared;\n-     HOST_WIDE_INT size;\n+store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n {\n   tree type = TREE_TYPE (exp);\n #ifdef WORD_REGISTER_OPERATIONS\n@@ -5638,17 +5523,9 @@ store_constructor (exp, target, cleared, size)\n    reference to the containing structure.  */\n \n static rtx\n-store_field (target, bitsize, bitpos, mode, exp, value_mode, unsignedp, type,\n-\t     alias_set)\n-     rtx target;\n-     HOST_WIDE_INT bitsize;\n-     HOST_WIDE_INT bitpos;\n-     enum machine_mode mode;\n-     tree exp;\n-     enum machine_mode value_mode;\n-     int unsignedp;\n-     tree type;\n-     int alias_set;\n+store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n+\t     enum machine_mode mode, tree exp, enum machine_mode value_mode,\n+\t     int unsignedp, tree type, int alias_set)\n {\n   HOST_WIDE_INT width_mask = 0;\n \n@@ -5717,7 +5594,7 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode, unsignedp, type,\n \t  && ((((MEM_ALIGN (target) < GET_MODE_ALIGNMENT (mode))\n \t\t|| bitpos % GET_MODE_ALIGNMENT (mode))\n \t       && SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (target)))\n-\t      || (bitpos % BITS_PER_UNIT != 0)))\t      \n+\t      || (bitpos % BITS_PER_UNIT != 0)))\n       /* If the RHS and field are a constant size and the size of the\n \t RHS isn't the same size as the bitfield, we must use bitfield\n \t operations.  */\n@@ -5852,15 +5729,10 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode, unsignedp, type,\n    this case, but the address of the object can be found.  */\n \n tree\n-get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n-\t\t     punsignedp, pvolatilep)\n-     tree exp;\n-     HOST_WIDE_INT *pbitsize;\n-     HOST_WIDE_INT *pbitpos;\n-     tree *poffset;\n-     enum machine_mode *pmode;\n-     int *punsignedp;\n-     int *pvolatilep;\n+get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n+\t\t     HOST_WIDE_INT *pbitpos, tree *poffset,\n+\t\t     enum machine_mode *pmode, int *punsignedp,\n+\t\t     int *pvolatilep)\n {\n   tree size_tree = 0;\n   enum machine_mode mode = VOIDmode;\n@@ -6019,8 +5891,7 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n /* Return 1 if T is an expression that get_inner_reference handles.  */\n \n int\n-handled_component_p (t)\n-     tree t;\n+handled_component_p (tree t)\n {\n   switch (TREE_CODE (t))\n     {\n@@ -6050,8 +5921,7 @@ handled_component_p (t)\n    The returned value may be a REG, SUBREG, MEM or constant.  */\n \n rtx\n-force_operand (value, target)\n-     rtx value, target;\n+force_operand (rtx value, rtx target)\n {\n   rtx op1, op2;\n   /* Use subtarget as the target for operand 0 of a binary operation.  */\n@@ -6182,10 +6052,7 @@ force_operand (value, target)\n    searches for optimization opportunities.  */\n \n int\n-safe_from_p (x, exp, top_p)\n-     rtx x;\n-     tree exp;\n-     int top_p;\n+safe_from_p (rtx x, tree exp, int top_p)\n {\n   rtx exp_rtl = 0;\n   int i, nops;\n@@ -6426,8 +6293,7 @@ safe_from_p (x, exp, top_p)\n    variable or parameter; else return 0.  */\n \n static rtx\n-var_rtx (exp)\n-     tree exp;\n+var_rtx (tree exp)\n {\n   STRIP_NOPS (exp);\n   switch (TREE_CODE (exp))\n@@ -6443,8 +6309,7 @@ var_rtx (exp)\n #ifdef MAX_INTEGER_COMPUTATION_MODE\n \n void\n-check_max_integer_computation_mode (exp)\n-     tree exp;\n+check_max_integer_computation_mode (tree exp)\n {\n   enum tree_code code;\n   enum machine_mode mode;\n@@ -6499,8 +6364,7 @@ check_max_integer_computation_mode (exp)\n    This is used in updating alignment of MEMs in array references.  */\n \n static unsigned HOST_WIDE_INT\n-highest_pow2_factor (exp)\n-     tree exp;\n+highest_pow2_factor (tree exp)\n {\n   unsigned HOST_WIDE_INT c0, c1;\n \n@@ -6569,9 +6433,7 @@ highest_pow2_factor (exp)\n    of the alignment of TYPE.  */\n \n static unsigned HOST_WIDE_INT\n-highest_pow2_factor_for_type (type, exp)\n-     tree type;\n-     tree exp;\n+highest_pow2_factor_for_type (tree type, tree exp)\n {\n   unsigned HOST_WIDE_INT type_align, factor;\n \n@@ -6589,9 +6451,7 @@ highest_pow2_factor_for_type (type, exp)\n    the placeholder list at which the object is found is placed.  */\n \n tree\n-find_placeholder (exp, plist)\n-     tree exp;\n-     tree *plist;\n+find_placeholder (tree exp, tree *plist)\n {\n   tree type = TREE_TYPE (exp);\n   tree placeholder_expr;\n@@ -6689,11 +6549,7 @@ find_placeholder (exp, plist)\n    emit_block_move will be flagged with BLOCK_OP_CALL_PARM.  */\n \n rtx\n-expand_expr (exp, target, tmode, modifier)\n-     tree exp;\n-     rtx target;\n-     enum machine_mode tmode;\n-     enum expand_modifier modifier;\n+expand_expr (tree exp, rtx target, enum machine_mode tmode, enum expand_modifier modifier)\n {\n   rtx op0, op1, temp;\n   tree type = TREE_TYPE (exp);\n@@ -7593,7 +7449,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t   forcing the SAVE_EXPR into memory.  */\n \t\tif (TREE_CODE (TREE_OPERAND (exp, 0)) == SAVE_EXPR)\n \t\t  {\n-\t\t    put_var_into_stack (TREE_OPERAND (exp, 0), \n+\t\t    put_var_into_stack (TREE_OPERAND (exp, 0),\n \t\t\t\t\t/*rescan=*/true);\n \t\t    op0 = SAVE_EXPR_RTL (TREE_OPERAND (exp, 0));\n \t\t  }\n@@ -9693,9 +9549,7 @@ expand_expr (exp, target, tmode, modifier)\n    aligned more than BIGGEST_ALIGNMENT.  */\n \n static int\n-is_aligning_offset (offset, exp)\n-     tree offset;\n-     tree exp;\n+is_aligning_offset (tree offset, tree exp)\n {\n   /* Strip off any conversions and WITH_RECORD_EXPR nodes.  */\n   while (TREE_CODE (offset) == NON_LVALUE_EXPR\n@@ -9744,9 +9598,7 @@ is_aligning_offset (offset, exp)\n    offset will be `sizetype'.  */\n \n tree\n-string_constant (arg, ptr_offset)\n-     tree arg;\n-     tree *ptr_offset;\n+string_constant (tree arg, tree *ptr_offset)\n {\n   STRIP_NOPS (arg);\n \n@@ -9786,9 +9638,7 @@ string_constant (arg, ptr_offset)\n    POST is 1 for postinc/decrements and 0 for preinc/decrements.  */\n \n static rtx\n-expand_increment (exp, post, ignore)\n-     tree exp;\n-     int post, ignore;\n+expand_increment (tree exp, int post, int ignore)\n {\n   rtx op0, op1;\n   rtx temp, value;\n@@ -10007,11 +9857,7 @@ expand_increment (exp, post, ignore)\n    set/jump/set sequence.  */\n \n static rtx\n-do_store_flag (exp, target, mode, only_cheap)\n-     tree exp;\n-     rtx target;\n-     enum machine_mode mode;\n-     int only_cheap;\n+do_store_flag (tree exp, rtx target, enum machine_mode mode, int only_cheap)\n {\n   enum rtx_code code;\n   tree arg0, arg1, type;\n@@ -10302,19 +10148,16 @@ do_store_flag (exp, target, mode, only_cheap)\n #endif /* CASE_VALUES_THRESHOLD */\n \n unsigned int\n-case_values_threshold ()\n+case_values_threshold (void)\n {\n   return CASE_VALUES_THRESHOLD;\n }\n \n /* Attempt to generate a casesi instruction.  Returns 1 if successful,\n    0 otherwise (i.e. if there is no casesi instruction).  */\n int\n-try_casesi (index_type, index_expr, minval, range,\n-\t    table_label, default_label)\n-     tree index_type, index_expr, minval, range;\n-     rtx table_label ATTRIBUTE_UNUSED;\n-     rtx default_label;\n+try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n+\t    rtx table_label ATTRIBUTE_UNUSED, rtx default_label)\n {\n   enum machine_mode index_mode = SImode;\n   int index_bits = GET_MODE_BITSIZE (index_mode);\n@@ -10401,9 +10244,8 @@ try_casesi (index_type, index_expr, minval, range,\n    index value is out of range.  */\n \n static void\n-do_tablejump (index, mode, range, table_label, default_label)\n-     rtx index, range, table_label, default_label;\n-     enum machine_mode mode;\n+do_tablejump (rtx index, enum machine_mode mode, rtx range, rtx table_label,\n+\t      rtx default_label)\n {\n   rtx temp, vector;\n \n@@ -10467,10 +10309,8 @@ do_tablejump (index, mode, range, table_label, default_label)\n }\n \n int\n-try_tablejump (index_type, index_expr, minval, range,\n-\t       table_label, default_label)\n-     tree index_type, index_expr, minval, range;\n-     rtx table_label, default_label;\n+try_tablejump (tree index_type, tree index_expr, tree minval, tree range,\n+\t       rtx table_label, rtx default_label)\n {\n   rtx index;\n \n@@ -10500,8 +10340,7 @@ try_tablejump (index_type, index_expr, minval, range,\n    vector mode, but we can emulate with narrower modes.  */\n \n int\n-vector_mode_valid_p (mode)\n-     enum machine_mode mode;\n+vector_mode_valid_p (enum machine_mode mode)\n {\n   enum mode_class class = GET_MODE_CLASS (mode);\n   enum machine_mode innermode;\n@@ -10527,8 +10366,7 @@ vector_mode_valid_p (mode)\n \n /* Return a CONST_VECTOR rtx for a VECTOR_CST tree.  */\n static rtx\n-const_vector_from_tree (exp)\n-     tree exp;\n+const_vector_from_tree (tree exp)\n {\n   rtvec v;\n   int units, i;"}, {"sha": "ddf8505fa87e3f591d9fbf67f5546e98a9d478a0", "filename": "gcc/expr.h", "status": "modified", "additions": 167, "deletions": 180, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502b832280c67d89300d92b91e73a9d3093db4a8/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=502b832280c67d89300d92b91e73a9d3093db4a8", "patch": "@@ -186,7 +186,7 @@ tree split_complex_values (tree);\n #endif\n \n /* Nonzero if we do not know how to pass TYPE solely in registers.  */\n-extern bool default_must_pass_in_stack PARAMS((enum machine_mode, tree));\n+extern bool default_must_pass_in_stack (enum machine_mode, tree);\n #ifndef MUST_PASS_IN_STACK\n #define MUST_PASS_IN_STACK(MODE,TYPE) default_must_pass_in_stack(MODE, TYPE)\n #endif\n@@ -274,82 +274,80 @@ enum optab_methods\n /* Generate code for a simple binary or unary operation.  \"Simple\" in\n    this case means \"can be unambiguously described by a (mode, code)\n    pair and mapped to a single optab.\"  */\n-extern rtx expand_simple_binop PARAMS ((enum machine_mode, enum rtx_code, rtx,\n-\t\t\t\t\trtx, rtx, int, enum optab_methods));\n-extern rtx expand_simple_unop PARAMS ((enum machine_mode, enum rtx_code,\n-\t\t\t\t       rtx, rtx, int));\n+extern rtx expand_simple_binop (enum machine_mode, enum rtx_code, rtx,\n+\t\t\t\trtx, rtx, int, enum optab_methods);\n+extern rtx expand_simple_unop (enum machine_mode, enum rtx_code, rtx, rtx,\n+\t\t\t       int);\n \n /* Report whether the machine description contains an insn which can\n    perform the operation described by CODE and MODE.  */\n-extern int have_insn_for PARAMS ((enum rtx_code, enum machine_mode));\n+extern int have_insn_for (enum rtx_code, enum machine_mode);\n \n /* Emit code to make a call to a constant function or a library call.  */\n-extern void emit_libcall_block PARAMS ((rtx, rtx, rtx, rtx));\n+extern void emit_libcall_block (rtx, rtx, rtx, rtx);\n \n /* Create but don't emit one rtl instruction to perform certain operations.\n    Modes must match; operands must meet the operation's predicates.\n    Likewise for subtraction and for just copying.\n    These do not call protect_from_queue; caller must do so.  */\n-extern rtx gen_add2_insn PARAMS ((rtx, rtx));\n-extern rtx gen_add3_insn PARAMS ((rtx, rtx, rtx));\n-extern rtx gen_sub2_insn PARAMS ((rtx, rtx));\n-extern rtx gen_sub3_insn PARAMS ((rtx, rtx, rtx));\n-extern rtx gen_move_insn PARAMS ((rtx, rtx));\n-extern int have_add2_insn PARAMS ((rtx, rtx));\n-extern int have_sub2_insn PARAMS ((rtx, rtx));\n+extern rtx gen_add2_insn (rtx, rtx);\n+extern rtx gen_add3_insn (rtx, rtx, rtx);\n+extern rtx gen_sub2_insn (rtx, rtx);\n+extern rtx gen_sub3_insn (rtx, rtx, rtx);\n+extern rtx gen_move_insn (rtx, rtx);\n+extern int have_add2_insn (rtx, rtx);\n+extern int have_sub2_insn (rtx, rtx);\n \n /* Emit a pair of rtl insns to compare two rtx's and to jump\n    to a label if the comparison is true.  */\n-extern void emit_cmp_and_jump_insns PARAMS ((rtx, rtx, enum rtx_code, rtx,\n-\t\t\t\t\t     enum machine_mode, int, rtx));\n+extern void emit_cmp_and_jump_insns (rtx, rtx, enum rtx_code, rtx,\n+\t\t\t\t     enum machine_mode, int, rtx);\n \n /* Generate code to indirectly jump to a location given in the rtx LOC.  */\n-extern void emit_indirect_jump PARAMS ((rtx));\n+extern void emit_indirect_jump (rtx);\n \n #ifdef HAVE_conditional_move\n /* Emit a conditional move operation.  */\n-rtx emit_conditional_move PARAMS ((rtx, enum rtx_code, rtx, rtx,\n-\t\t\t\t   enum machine_mode, rtx, rtx,\n-\t\t\t\t   enum machine_mode, int));\n+rtx emit_conditional_move (rtx, enum rtx_code, rtx, rtx, enum machine_mode,\n+\t\t\t   rtx, rtx, enum machine_mode, int);\n \n /* Return nonzero if the conditional move is supported.  */\n-int can_conditionally_move_p PARAMS ((enum machine_mode mode));\n+int can_conditionally_move_p (enum machine_mode mode);\n \n #endif\n-rtx emit_conditional_add PARAMS ((rtx, enum rtx_code, rtx, rtx,\n-\t\t\t\t  enum machine_mode, rtx, rtx,\n-\t\t\t\t  enum machine_mode, int));\n+rtx emit_conditional_add (rtx, enum rtx_code, rtx, rtx, enum machine_mode,\n+\t\t\t  rtx, rtx, enum machine_mode, int);\n \n \f\n /* Functions from expmed.c:  */\n \n /* Arguments MODE, RTX: return an rtx for the negation of that value.\n    May emit insns.  */\n-extern rtx negate_rtx PARAMS ((enum machine_mode, rtx));\n+extern rtx negate_rtx (enum machine_mode, rtx);\n \n /* Expand a logical AND operation.  */\n-extern rtx expand_and PARAMS ((enum machine_mode, rtx, rtx, rtx));\n+extern rtx expand_and (enum machine_mode, rtx, rtx, rtx);\n \n /* Emit a store-flag operation.  */\n-extern rtx emit_store_flag PARAMS ((rtx, enum rtx_code, rtx, rtx,\n-\t\t\t\t    enum machine_mode, int, int));\n+extern rtx emit_store_flag (rtx, enum rtx_code, rtx, rtx, enum machine_mode,\n+\t\t\t    int, int);\n \n /* Like emit_store_flag, but always succeeds.  */\n-extern rtx emit_store_flag_force PARAMS ((rtx, enum rtx_code, rtx, rtx,\n-\t\t\t\t\t  enum machine_mode, int, int));\n+extern rtx emit_store_flag_force (rtx, enum rtx_code, rtx, rtx,\n+\t\t\t\t  enum machine_mode, int, int);\n \n /* Functions from loop.c:  */\n \n /* Given an insn and condition, return a canonical description of\n    the test being made.  */\n-extern rtx canonicalize_condition PARAMS ((rtx, rtx, int, rtx *, rtx));\n+extern rtx canonicalize_condition (rtx, rtx, int, rtx *, rtx);\n \n /* Given a JUMP_INSN, return a canonical description of the test\n    being made.  */\n-extern rtx get_condition PARAMS ((rtx, rtx *));\n+extern rtx get_condition (rtx, rtx *);\n \n /* Generate a conditional trap instruction.  */\n-extern rtx gen_cond_trap PARAMS ((enum rtx_code, rtx, rtx, rtx));\n+extern rtx gen_cond_trap (enum rtx_code, rtx, rtx, rtx);\n \f\n /* Functions from builtins.c:  */\n extern rtx expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n@@ -374,34 +372,33 @@ extern int can_address_p (tree);\n \n /* This is run once per compilation to set up which modes can be used\n    directly in memory and to initialize the block move optab.  */\n-extern void init_expr_once PARAMS ((void));\n+extern void init_expr_once (void);\n \n /* This is run at the start of compiling a function.  */\n-extern void init_expr PARAMS ((void));\n+extern void init_expr (void);\n \n /* This is run at the end of compiling a function.  */\n-extern void finish_expr_for_function PARAMS ((void));\n+extern void finish_expr_for_function (void);\n \n /* Use protect_from_queue to convert a QUEUED expression\n    into something that you can put immediately into an instruction.  */\n-extern rtx protect_from_queue PARAMS ((rtx, int));\n+extern rtx protect_from_queue (rtx, int);\n \n /* Perform all the pending incrementations.  */\n-extern void emit_queue PARAMS ((void));\n+extern void emit_queue (void);\n \n /* Tell if something has a queued subexpression.  */\n-extern int queued_subexp_p PARAMS ((rtx));\n+extern int queued_subexp_p (rtx);\n \n /* Emit some rtl insns to move data between rtx's, converting machine modes.\n    Both modes must be floating or both fixed.  */\n-extern void convert_move PARAMS ((rtx, rtx, int));\n+extern void convert_move (rtx, rtx, int);\n \n /* Convert an rtx to specified machine mode and return the result.  */\n-extern rtx convert_to_mode PARAMS ((enum machine_mode, rtx, int));\n+extern rtx convert_to_mode (enum machine_mode, rtx, int);\n \n /* Convert an rtx to MODE from OLDMODE and return the result.  */\n-extern rtx convert_modes PARAMS ((enum machine_mode, enum machine_mode,\n-\t\t\t\t  rtx, int));\n+extern rtx convert_modes (enum machine_mode, enum machine_mode, rtx, int);\n \n /* Emit code to move a block Y to a block X.  */\n \n@@ -412,108 +409,106 @@ enum block_op_methods\n   BLOCK_OP_CALL_PARM\n };\n \n-extern void init_block_move_fn PARAMS ((const char *));\n-extern void init_block_clear_fn PARAMS ((const char *));\n+extern void init_block_move_fn (const char *);\n+extern void init_block_clear_fn (const char *);\n \n-extern rtx emit_block_move PARAMS ((rtx, rtx, rtx, enum block_op_methods));\n+extern rtx emit_block_move (rtx, rtx, rtx, enum block_op_methods);\n \n /* Copy all or part of a value X into registers starting at REGNO.\n    The number of registers to be filled is NREGS.  */\n-extern void move_block_to_reg PARAMS ((int, rtx, int, enum machine_mode));\n+extern void move_block_to_reg (int, rtx, int, enum machine_mode);\n \n /* Copy all or part of a BLKmode value X out of registers starting at REGNO.\n    The number of registers to be filled is NREGS.  */\n-extern void move_block_from_reg PARAMS ((int, rtx, int));\n+extern void move_block_from_reg (int, rtx, int);\n \n /* Generate a non-consecutive group of registers represented by a PARALLEL.  */\n-extern rtx gen_group_rtx PARAMS ((rtx));\n+extern rtx gen_group_rtx (rtx);\n \n /* Load a BLKmode value into non-consecutive registers represented by a\n    PARALLEL.  */\n-extern void emit_group_load PARAMS ((rtx, rtx, int));\n+extern void emit_group_load (rtx, rtx, int);\n \n /* Move a non-consecutive group of registers represented by a PARALLEL into\n    a non-consecutive group of registers represented by a PARALLEL.  */\n-extern void emit_group_move PARAMS ((rtx, rtx));\n+extern void emit_group_move (rtx, rtx);\n \n /* Store a BLKmode value from non-consecutive registers represented by a\n    PARALLEL.  */\n-extern void emit_group_store PARAMS ((rtx, rtx, int));\n+extern void emit_group_store (rtx, rtx, int);\n \n #ifdef TREE_CODE\n /* Copy BLKmode object from a set of registers.  */\n-extern rtx copy_blkmode_from_reg PARAMS ((rtx, rtx, tree));\n+extern rtx copy_blkmode_from_reg (rtx, rtx, tree);\n #endif\n \n /* Mark REG as holding a parameter for the next CALL_INSN.  */\n-extern void use_reg PARAMS ((rtx *, rtx));\n+extern void use_reg (rtx *, rtx);\n \n /* Mark NREGS consecutive regs, starting at REGNO, as holding parameters\n    for the next CALL_INSN.  */\n-extern void use_regs PARAMS ((rtx *, int, int));\n+extern void use_regs (rtx *, int, int);\n \n /* Mark a PARALLEL as holding a parameter for the next CALL_INSN.  */\n-extern void use_group_regs PARAMS ((rtx *, rtx));\n+extern void use_group_regs (rtx *, rtx);\n \n /* Write zeros through the storage of OBJECT.\n    If OBJECT has BLKmode, SIZE is its length in bytes.  */\n-extern rtx clear_storage PARAMS ((rtx, rtx));\n+extern rtx clear_storage (rtx, rtx);\n \n /* Determine whether the LEN bytes can be moved by using several move\n    instructions.  Return nonzero if a call to move_by_pieces should\n    succeed.  */\n-extern int can_move_by_pieces PARAMS ((unsigned HOST_WIDE_INT, unsigned int));\n+extern int can_move_by_pieces (unsigned HOST_WIDE_INT, unsigned int);\n \n /* Return nonzero if it is desirable to store LEN bytes generated by\n    CONSTFUN with several move instructions by store_by_pieces\n    function.  CONSTFUNDATA is a pointer which will be passed as argument\n    in every CONSTFUN call.\n    ALIGN is maximum alignment we can assume.  */\n-extern int can_store_by_pieces PARAMS ((unsigned HOST_WIDE_INT,\n-\t\t\t\t\trtx (*) (void *, HOST_WIDE_INT,\n-\t\t\t\t\t\t enum machine_mode),\n-\t\t\t\t\tvoid *, unsigned int));\n+extern int can_store_by_pieces (unsigned HOST_WIDE_INT,\n+\t\t\t\trtx (*) (void *, HOST_WIDE_INT,\n+\t\t\t\t\t enum machine_mode),\n+\t\t\t\tvoid *, unsigned int);\n \n /* Generate several move instructions to store LEN bytes generated by\n    CONSTFUN to block TO.  (A MEM rtx with BLKmode).  CONSTFUNDATA is a\n    pointer which will be passed as argument in every CONSTFUN call.\n    ALIGN is maximum alignment we can assume.\n    Returns TO + LEN.  */\n-extern rtx store_by_pieces PARAMS ((rtx, unsigned HOST_WIDE_INT,\n-\t\t\t\t    rtx (*) (void *, HOST_WIDE_INT,\n-\t\t\t\t\t     enum machine_mode),\n-\t\t\t\t    void *, unsigned int, int));\n+extern rtx store_by_pieces (rtx, unsigned HOST_WIDE_INT,\n+\t\t\t    rtx (*) (void *, HOST_WIDE_INT, enum machine_mode),\n+\t\t\t    void *, unsigned int, int);\n \n /* Emit insns to set X from Y.  */\n-extern rtx emit_move_insn PARAMS ((rtx, rtx));\n+extern rtx emit_move_insn (rtx, rtx);\n \n /* Emit insns to set X from Y, with no frills.  */\n-extern rtx emit_move_insn_1 PARAMS ((rtx, rtx));\n+extern rtx emit_move_insn_1 (rtx, rtx);\n \n /* Push a block of length SIZE (perhaps variable)\n    and return an rtx to address the beginning of the block.  */\n-extern rtx push_block PARAMS ((rtx, int, int));\n+extern rtx push_block (rtx, int, int);\n \n #ifdef TREE_CODE\n /* Generate code to push something onto the stack, given its mode and type.  */\n-extern void emit_push_insn PARAMS ((rtx, enum machine_mode, tree, rtx,\n-\t\t\t\t    unsigned int, int, rtx, int, rtx, rtx,\n-\t\t\t\t    int, rtx));\n+extern void emit_push_insn (rtx, enum machine_mode, tree, rtx, unsigned int,\n+\t\t\t    int, rtx, int, rtx, rtx, int, rtx);\n \n /* Expand an assignment that stores the value of FROM into TO.  */\n-extern rtx expand_assignment PARAMS ((tree, tree, int, int));\n+extern rtx expand_assignment (tree, tree, int, int);\n \n /* Generate code for computing expression EXP,\n    and storing the value into TARGET.\n    If SUGGEST_REG is nonzero, copy the value through a register\n    and return that register, if that is possible.  */\n-extern rtx store_expr PARAMS ((tree, rtx, int));\n+extern rtx store_expr (tree, rtx, int);\n #endif\n \n /* Given an rtx that may include add and multiply operations,\n    generate them as insns and return a pseudo-reg containing the value.\n    Useful after calling expand_expr with 1 as sum_ok.  */\n-extern rtx force_operand PARAMS ((rtx, rtx));\n+extern rtx force_operand (rtx, rtx);\n \n /* Return an object on the placeholder list that matches EXP, a\n    PLACEHOLDER_EXPR.  An object \"matches\" if it is of the type of the\n@@ -522,137 +517,134 @@ extern rtx force_operand PARAMS ((rtx, rtx));\n    a location which initially points to a starting location in the\n    placeholder list (zero means start of the list) and where a pointer into\n    the placeholder list at which the object is found is placed.  */\n-extern tree find_placeholder PARAMS ((tree, tree *));\n+extern tree find_placeholder (tree, tree *);\n \n /* Generate code for computing expression EXP.\n    An rtx for the computed value is returned.  The value is never null.\n    In the case of a void EXP, const0_rtx is returned.  */\n-extern rtx expand_expr PARAMS ((tree, rtx, enum machine_mode,\n-\t\t\t\tenum expand_modifier));\n+extern rtx expand_expr (tree, rtx, enum machine_mode, enum expand_modifier);\n \n /* At the start of a function, record that we have no previously-pushed\n    arguments waiting to be popped.  */\n-extern void init_pending_stack_adjust PARAMS ((void));\n+extern void init_pending_stack_adjust (void);\n \n /* When exiting from function, if safe, clear out any pending stack adjust\n    so the adjustment won't get done.  */\n-extern void clear_pending_stack_adjust PARAMS ((void));\n+extern void clear_pending_stack_adjust (void);\n \n /* Pop any previously-pushed arguments that have not been popped yet.  */\n-extern void do_pending_stack_adjust PARAMS ((void));\n+extern void do_pending_stack_adjust (void);\n \n #ifdef TREE_CODE\n /* Return the tree node and offset if a given argument corresponds to\n    a string constant.  */\n-extern tree string_constant PARAMS ((tree, tree *));\n+extern tree string_constant (tree, tree *);\n \n /* Generate code to evaluate EXP and jump to LABEL if the value is zero.  */\n-extern void jumpifnot PARAMS ((tree, rtx));\n+extern void jumpifnot (tree, rtx);\n \n /* Generate code to evaluate EXP and jump to LABEL if the value is nonzero.  */\n-extern void jumpif PARAMS ((tree, rtx));\n+extern void jumpif (tree, rtx);\n \n /* Generate code to evaluate EXP and jump to IF_FALSE_LABEL if\n    the result is zero, or IF_TRUE_LABEL if the result is one.  */\n-extern void do_jump PARAMS ((tree, rtx, rtx));\n+extern void do_jump (tree, rtx, rtx);\n #endif\n \n /* Generate rtl to compare two rtx's, will call emit_cmp_insn.  */\n-extern rtx compare_from_rtx PARAMS ((rtx, rtx, enum rtx_code, int,\n-\t\t\t\t     enum machine_mode, rtx));\n-extern void do_compare_rtx_and_jump PARAMS ((rtx, rtx, enum rtx_code, int,\n-\t\t\t\t\t     enum machine_mode, rtx,\n-\t\t\t\t\t     rtx, rtx));\n+extern rtx compare_from_rtx (rtx, rtx, enum rtx_code, int, enum machine_mode,\n+\t\t\t     rtx);\n+extern void do_compare_rtx_and_jump (rtx, rtx, enum rtx_code, int,\n+\t\t\t\t     enum machine_mode, rtx, rtx, rtx);\n \n /* Two different ways of generating switch statements.  */\n-extern int try_casesi    PARAMS ((tree, tree, tree, tree, rtx, rtx));\n-extern int try_tablejump PARAMS ((tree, tree, tree, tree, rtx, rtx));\n+extern int try_casesi (tree, tree, tree, tree, rtx, rtx);\n+extern int try_tablejump (tree, tree, tree, tree, rtx, rtx);\n \n /* Smallest number of adjacent cases before we use a jump table.\n    XXX Should be a target hook.  */\n-extern unsigned int case_values_threshold PARAMS ((void));\n+extern unsigned int case_values_threshold (void);\n \n \f\n #ifdef TREE_CODE\n /* rtl.h and tree.h were included.  */\n /* Return an rtx for the size in bytes of the value of an expr.  */\n-extern rtx expr_size PARAMS ((tree));\n+extern rtx expr_size (tree);\n \n /* Return a wide integer for the size in bytes of the value of EXP, or -1\n    if the size can vary or is larger than an integer.  */\n-extern HOST_WIDE_INT int_expr_size PARAMS ((tree));\n+extern HOST_WIDE_INT int_expr_size (tree);\n \n-extern rtx lookup_static_chain PARAMS ((tree));\n+extern rtx lookup_static_chain (tree);\n \n /* Convert a stack slot address ADDR valid in function FNDECL\n    into an address valid in this function (using a static chain).  */\n-extern rtx fix_lexical_addr PARAMS ((rtx, tree));\n+extern rtx fix_lexical_addr (rtx, tree);\n \n /* Return the address of the trampoline for entering nested fn FUNCTION.  */\n-extern rtx trampoline_address PARAMS ((tree));\n+extern rtx trampoline_address (tree);\n \n /* Return an rtx that refers to the value returned by a function\n    in its original home.  This becomes invalid if any more code is emitted.  */\n-extern rtx hard_function_value PARAMS ((tree, tree, int));\n+extern rtx hard_function_value (tree, tree, int);\n \n-extern rtx prepare_call_address\tPARAMS ((rtx, tree, rtx *, int, int));\n+extern rtx prepare_call_address (rtx, tree, rtx *, int, int);\n \n-extern rtx expand_call PARAMS ((tree, rtx, int));\n+extern rtx expand_call (tree, rtx, int);\n \n-extern rtx expand_shift PARAMS ((enum tree_code, enum machine_mode, rtx, tree,\n-\t\t\t\t rtx, int));\n-extern rtx expand_divmod PARAMS ((int, enum tree_code, enum machine_mode, rtx,\n-\t\t\t\t  rtx, rtx, int));\n-extern void locate_and_pad_parm PARAMS ((enum machine_mode, tree, int, int,\n-\t\t\t\t\t tree, struct args_size *,\n-\t\t\t\t\t struct locate_and_pad_arg_data *));\n-extern rtx expand_inline_function PARAMS ((tree, tree, rtx, int, tree, rtx));\n+extern rtx expand_shift (enum tree_code, enum machine_mode, rtx, tree, rtx,\n+\t\t\t int);\n+extern rtx expand_divmod (int, enum tree_code, enum machine_mode, rtx, rtx,\n+\t\t\t  rtx, int);\n+extern void locate_and_pad_parm (enum machine_mode, tree, int, int, tree,\n+\t\t\t\t struct args_size *,\n+\t\t\t\t struct locate_and_pad_arg_data *);\n+extern rtx expand_inline_function (tree, tree, rtx, int, tree, rtx);\n \n /* Return the CODE_LABEL rtx for a LABEL_DECL, creating it if necessary.  */\n-extern rtx label_rtx PARAMS ((tree));\n+extern rtx label_rtx (tree);\n \n /* As label_rtx, but additionally the label is placed on the forced label\n    list of its containing function (i.e. it is treated as reachable even\n    if how is not obvious).  */\n-extern rtx force_label_rtx PARAMS ((tree));\n+extern rtx force_label_rtx (tree);\n #endif\n \n /* Indicate how an input argument register was promoted.  */\n-extern rtx promoted_input_arg PARAMS ((unsigned int, enum machine_mode *,\n-\t\t\t\t       int *));\n+extern rtx promoted_input_arg (unsigned int, enum machine_mode *, int *);\n \n /* Return an rtx like arg but sans any constant terms.\n    Returns the original rtx if it has no constant terms.\n    The constant terms are added and stored via a second arg.  */\n-extern rtx eliminate_constant_term PARAMS ((rtx, rtx *));\n+extern rtx eliminate_constant_term (rtx, rtx *);\n \n /* Convert arg to a valid memory address for specified machine mode,\n    by emitting insns to perform arithmetic if nec.  */\n-extern rtx memory_address PARAMS ((enum machine_mode, rtx));\n+extern rtx memory_address (enum machine_mode, rtx);\n \n /* Like `memory_address' but pretent `flag_force_addr' is 0.  */\n-extern rtx memory_address_noforce PARAMS ((enum machine_mode, rtx));\n+extern rtx memory_address_noforce (enum machine_mode, rtx);\n \n /* Set the alias set of MEM to SET.  */\n-extern void set_mem_alias_set PARAMS ((rtx, HOST_WIDE_INT));\n+extern void set_mem_alias_set (rtx, HOST_WIDE_INT);\n \n /* Set the alignment of MEM to ALIGN bits.  */\n-extern void set_mem_align PARAMS ((rtx, unsigned int));\n+extern void set_mem_align (rtx, unsigned int);\n \n /* Set the expr for MEM to EXPR.  */\n-extern void set_mem_expr PARAMS ((rtx, tree));\n+extern void set_mem_expr (rtx, tree);\n \n /* Set the offset for MEM to OFFSET.  */\n-extern void set_mem_offset PARAMS ((rtx, rtx));\n+extern void set_mem_offset (rtx, rtx);\n \n /* Set the size for MEM to SIZE.  */\n-extern void set_mem_size PARAMS ((rtx, rtx));\n+extern void set_mem_size (rtx, rtx);\n \n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address changed to ADDR.\n    (VOIDmode means don't change the mode.\n    NULL for ADDR means don't change the address.)  */\n-extern rtx change_address PARAMS ((rtx, enum machine_mode, rtx));\n+extern rtx change_address (rtx, enum machine_mode, rtx);\n \n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address offset by OFFSET bytes.  */\n@@ -673,162 +665,157 @@ extern rtx change_address PARAMS ((rtx, enum machine_mode, rtx));\n #define adjust_automodify_address_nv(MEMREF, MODE, ADDR, OFFSET) \\\n   adjust_automodify_address_1 (MEMREF, MODE, ADDR, OFFSET, 0)\n \n-extern rtx adjust_address_1 PARAMS ((rtx, enum machine_mode, HOST_WIDE_INT,\n-\t\t\t\t     int, int));\n-extern rtx adjust_automodify_address_1 PARAMS ((rtx, enum machine_mode,\n-\t\t\t\t\t\trtx, HOST_WIDE_INT, int));\n+extern rtx adjust_address_1 (rtx, enum machine_mode, HOST_WIDE_INT, int, int);\n+extern rtx adjust_automodify_address_1 (rtx, enum machine_mode, rtx,\n+\t\t\t\t\tHOST_WIDE_INT, int);\n \n /* Return a memory reference like MEMREF, but whose address is changed by\n    adding OFFSET, an RTX, to it.  POW2 is the highest power of two factor\n    known to be in OFFSET (possibly 1).  */\n-extern rtx offset_address PARAMS ((rtx, rtx, unsigned HOST_WIDE_INT));\n+extern rtx offset_address (rtx, rtx, unsigned HOST_WIDE_INT);\n \n /* Return a memory reference like MEMREF, but with its address changed to\n    ADDR.  The caller is asserting that the actual piece of memory pointed\n    to is the same, just the form of the address is being changed, such as\n    by putting something into a register.  */\n-extern rtx replace_equiv_address PARAMS ((rtx, rtx));\n+extern rtx replace_equiv_address (rtx, rtx);\n \n /* Likewise, but the reference is not required to be valid.  */\n-extern rtx replace_equiv_address_nv PARAMS ((rtx, rtx));\n+extern rtx replace_equiv_address_nv (rtx, rtx);\n \n /* Return a memory reference like MEMREF, but with its mode widened to\n    MODE and adjusted by OFFSET.  */\n-extern rtx widen_memory_access PARAMS ((rtx, enum machine_mode, HOST_WIDE_INT));\n+extern rtx widen_memory_access (rtx, enum machine_mode, HOST_WIDE_INT);\n \n /* Return a memory reference like MEMREF, but which is known to have a\n    valid address.  */\n-extern rtx validize_mem PARAMS ((rtx));\n+extern rtx validize_mem (rtx);\n \n #ifdef TREE_CODE\n /* Given REF, either a MEM or a REG, and T, either the type of X or\n    the expression corresponding to REF, set RTX_UNCHANGING_P if\n    appropriate.  */\n-extern void maybe_set_unchanging PARAMS ((rtx, tree));\n+extern void maybe_set_unchanging (rtx, tree);\n \n /* Given REF, a MEM, and T, either the type of X or the expression\n    corresponding to REF, set the memory attributes.  OBJECTP is nonzero\n    if we are making a new object of this type.  */\n-extern void set_mem_attributes PARAMS ((rtx, tree, int));\n+extern void set_mem_attributes (rtx, tree, int);\n \n /* Similar, except that BITPOS has not yet been applied to REF, so if\n    we alter MEM_OFFSET according to T then we should subtract BITPOS\n    expecting that it'll be added back in later.  */\n-extern void set_mem_attributes_minus_bitpos PARAMS ((rtx, tree, int,\n-\t\t\t\t\t\t     HOST_WIDE_INT));\n+extern void set_mem_attributes_minus_bitpos (rtx, tree, int, HOST_WIDE_INT);\n #endif\n \n /* Assemble the static constant template for function entry trampolines.  */\n-extern rtx assemble_trampoline_template PARAMS ((void));\n+extern rtx assemble_trampoline_template (void);\n \n /* Given rtx, return new rtx whose address won't be affected by\n    any side effects.  It has been copied to a new temporary reg.  */\n-extern rtx stabilize PARAMS ((rtx));\n+extern rtx stabilize (rtx);\n \n /* Given an rtx, copy all regs it refers to into new temps\n    and return a modified copy that refers to the new temps.  */\n-extern rtx copy_all_regs PARAMS ((rtx));\n+extern rtx copy_all_regs (rtx);\n \n /* Copy given rtx to a new temp reg and return that.  */\n-extern rtx copy_to_reg PARAMS ((rtx));\n+extern rtx copy_to_reg (rtx);\n \n /* Like copy_to_reg but always make the reg Pmode.  */\n-extern rtx copy_addr_to_reg PARAMS ((rtx));\n+extern rtx copy_addr_to_reg (rtx);\n \n /* Like copy_to_reg but always make the reg the specified mode MODE.  */\n-extern rtx copy_to_mode_reg PARAMS ((enum machine_mode, rtx));\n+extern rtx copy_to_mode_reg (enum machine_mode, rtx);\n \n /* Copy given rtx to given temp reg and return that.  */\n-extern rtx copy_to_suggested_reg PARAMS ((rtx, rtx, enum machine_mode));\n+extern rtx copy_to_suggested_reg (rtx, rtx, enum machine_mode);\n \n /* Copy a value to a register if it isn't already a register.\n    Args are mode (in case value is a constant) and the value.  */\n-extern rtx force_reg PARAMS ((enum machine_mode, rtx));\n+extern rtx force_reg (enum machine_mode, rtx);\n \n /* Return given rtx, copied into a new temp reg if it was in memory.  */\n-extern rtx force_not_mem PARAMS ((rtx));\n+extern rtx force_not_mem (rtx);\n \n #ifdef TREE_CODE\n /* Return mode and signedness to use when object is promoted.  */\n-extern enum machine_mode promote_mode PARAMS ((tree, enum machine_mode,\n-\t\t\t\t\t       int *, int));\n+extern enum machine_mode promote_mode (tree, enum machine_mode, int *, int);\n #endif\n \n /* Remove some bytes from the stack.  An rtx says how many.  */\n-extern void adjust_stack PARAMS ((rtx));\n+extern void adjust_stack (rtx);\n \n /* Add some bytes to the stack.  An rtx says how many.  */\n-extern void anti_adjust_stack PARAMS ((rtx));\n+extern void anti_adjust_stack (rtx);\n \n /* This enum is used for the following two functions.  */\n enum save_level {SAVE_BLOCK, SAVE_FUNCTION, SAVE_NONLOCAL};\n \n /* Save the stack pointer at the specified level.  */\n-extern void emit_stack_save PARAMS ((enum save_level, rtx *, rtx));\n+extern void emit_stack_save (enum save_level, rtx *, rtx);\n \n /* Restore the stack pointer from a save area of the specified level.  */\n-extern void emit_stack_restore PARAMS ((enum save_level, rtx, rtx));\n+extern void emit_stack_restore (enum save_level, rtx, rtx);\n \n /* Allocate some space on the stack dynamically and return its address.  An rtx\n    says how many bytes.  */\n-extern rtx allocate_dynamic_stack_space PARAMS ((rtx, rtx, int));\n+extern rtx allocate_dynamic_stack_space (rtx, rtx, int);\n \n /* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.\n    FIRST is a constant and size is a Pmode RTX.  These are offsets from the\n    current stack pointer.  STACK_GROWS_DOWNWARD says whether to add or\n    subtract from the stack.  If SIZE is constant, this is done\n    with a fixed number of probes.  Otherwise, we must make a loop.  */\n-extern void probe_stack_range PARAMS ((HOST_WIDE_INT, rtx));\n+extern void probe_stack_range (HOST_WIDE_INT, rtx);\n \n /* Return an rtx that refers to the value returned by a library call\n    in its original home.  This becomes invalid if any more code is emitted.  */\n-extern rtx hard_libcall_value PARAMS ((enum machine_mode));\n+extern rtx hard_libcall_value (enum machine_mode);\n \n /* Given an rtx, return an rtx for a value rounded up to a multiple\n    of STACK_BOUNDARY / BITS_PER_UNIT.  */\n-extern rtx round_push PARAMS ((rtx));\n+extern rtx round_push (rtx);\n \n /* Return the mode desired by operand N of a particular bitfield\n    insert/extract insn, or MAX_MACHINE_MODE if no such insn is\n    available.  */\n \n enum extraction_pattern { EP_insv, EP_extv, EP_extzv };\n extern enum machine_mode\n-mode_for_extraction PARAMS ((enum extraction_pattern, int));\n-\n-extern rtx store_bit_field PARAMS ((rtx, unsigned HOST_WIDE_INT,\n-\t\t\t\t    unsigned HOST_WIDE_INT,\n-\t\t\t\t    enum machine_mode, rtx, HOST_WIDE_INT));\n-extern rtx extract_bit_field PARAMS ((rtx, unsigned HOST_WIDE_INT,\n-\t\t\t\t      unsigned HOST_WIDE_INT, int, rtx,\n-\t\t\t\t      enum machine_mode, enum machine_mode,\n-\t\t\t\t      HOST_WIDE_INT));\n-extern rtx expand_mult PARAMS ((enum machine_mode, rtx, rtx, rtx, int));\n-extern bool const_mult_add_overflow_p PARAMS ((rtx, rtx, rtx, enum machine_mode, int));\n-extern rtx expand_mult_add PARAMS ((rtx, rtx, rtx, rtx,enum machine_mode, int));\n-extern rtx expand_mult_highpart_adjust PARAMS ((enum machine_mode, rtx, rtx, rtx, rtx, int));\n-\n-extern rtx assemble_static_space PARAMS ((unsigned HOST_WIDE_INT));\n-extern int safe_from_p PARAMS ((rtx, tree, int));\n+mode_for_extraction (enum extraction_pattern, int);\n+\n+extern rtx store_bit_field (rtx, unsigned HOST_WIDE_INT,\n+\t\t\t    unsigned HOST_WIDE_INT, enum machine_mode, rtx,\n+\t\t\t    HOST_WIDE_INT);\n+extern rtx extract_bit_field (rtx, unsigned HOST_WIDE_INT,\n+\t\t\t      unsigned HOST_WIDE_INT, int, rtx,\n+\t\t\t      enum machine_mode, enum machine_mode,\n+\t\t\t      HOST_WIDE_INT);\n+extern rtx expand_mult (enum machine_mode, rtx, rtx, rtx, int);\n+extern bool const_mult_add_overflow_p (rtx, rtx, rtx, enum machine_mode, int);\n+extern rtx expand_mult_add (rtx, rtx, rtx, rtx,enum machine_mode, int);\n+extern rtx expand_mult_highpart_adjust (enum machine_mode, rtx, rtx, rtx, rtx, int);\n+\n+extern rtx assemble_static_space (unsigned HOST_WIDE_INT);\n+extern int safe_from_p (rtx, tree, int);\n \n /* Call this once to initialize the contents of the optabs\n    appropriately for the current target machine.  */\n-extern void init_optabs\t\t\t\tPARAMS ((void));\n-extern void init_all_optabs\t\t\tPARAMS ((void));\n+extern void init_optabs (void);\n+extern void init_all_optabs (void);\n \n /* Call this to initialize an optab function entry.  */\n-extern rtx init_one_libfunc\t\t\tPARAMS ((const char *));\n+extern rtx init_one_libfunc (const char *);\n \n-extern void do_jump_by_parts_equality_rtx\tPARAMS ((rtx, rtx, rtx));\n-extern void do_jump_by_parts_greater_rtx\tPARAMS ((enum machine_mode,\n-\t\t\t\t\t\t\t int, rtx, rtx, rtx,\n-\t\t\t\t\t\t\t rtx));\n+extern void do_jump_by_parts_equality_rtx (rtx, rtx, rtx);\n+extern void do_jump_by_parts_greater_rtx (enum machine_mode, int, rtx, rtx,\n+\t\t\t\t\t  rtx, rtx);\n \n #ifdef TREE_CODE   /* Don't lose if tree.h not included.  */\n-extern void mark_seen_cases\t\t\tPARAMS ((tree, unsigned char *,\n-\t\t\t\t\t\t\t HOST_WIDE_INT, int));\n+extern void mark_seen_cases (tree, unsigned char *, HOST_WIDE_INT, int);\n #endif\n \n-extern int vector_mode_valid_p\t\tPARAMS ((enum machine_mode));\n+extern int vector_mode_valid_p (enum machine_mode);\n \n extern tree placeholder_list;"}]}