{"sha": "2d1644bf5b2a2186aa00d50fa7c44832a020f5a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQxNjQ0YmY1YjJhMjE4NmFhMDBkNTBmYTdjNDQ4MzJhMDIwZjVhOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-04-17T02:43:53Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-04-17T02:43:53Z"}, "message": "ipa-devirt.c (odr_type_d): Add field all_derivations_known.\n\n\n\t* ipa-devirt.c (odr_type_d): Add field all_derivations_known.\n\t(type_all_derivations_known_p): New predicate.\n\t(type_all_ctors_visible_p): New predicate.\n\t(type_possibly_instantiated_p): New predicate.\n\t(get_odr_type): Compute all_derivations_known.\n\t(dump_odr_type): Dump the flag.\n\t(maybe_record_type): Cleanup.\n\t(record_target_from_binfo): Add bases_to_consider array;\n\trecord bases for types w/o instances and skip CXX destructor.\n\t(possible_polymorphic_call_targets_1): Add bases_to_consider\n\tand consider_construction parameters; check if type may\n\thave instance.\n\t(get_polymorphic_call_info): Set maybe_in_construction to true\n\twhen we know nothing.\n\t(record_targets_from_bases): Skip CXX destructors; they are\n\tnever called for types in construction.\n\t(possible_polymorphic_call_targets): Do not record target when\n\ttype may not have instance.\n\n\t* g++.dg/ipa/devirt-31.C: New testcase.\n\nFrom-SVN: r209461", "tree": {"sha": "d8e52d8022602d98ec6b0fde5b40d561be3e613b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8e52d8022602d98ec6b0fde5b40d561be3e613b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d1644bf5b2a2186aa00d50fa7c44832a020f5a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d1644bf5b2a2186aa00d50fa7c44832a020f5a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d1644bf5b2a2186aa00d50fa7c44832a020f5a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d1644bf5b2a2186aa00d50fa7c44832a020f5a8/comments", "author": null, "committer": null, "parents": [{"sha": "7c1b1692e15e8800f984dfd6404c04401a1142d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c1b1692e15e8800f984dfd6404c04401a1142d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c1b1692e15e8800f984dfd6404c04401a1142d6"}], "stats": {"total": 214, "additions": 187, "deletions": 27}, "files": [{"sha": "783a1b8d757fcda829d356da9812cb88b0693ebb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d1644bf5b2a2186aa00d50fa7c44832a020f5a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d1644bf5b2a2186aa00d50fa7c44832a020f5a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d1644bf5b2a2186aa00d50fa7c44832a020f5a8", "patch": "@@ -1,3 +1,24 @@\n+2014-04-16  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-devirt.c (odr_type_d): Add field all_derivations_known.\n+\t(type_all_derivations_known_p): New predicate.\n+\t(type_all_ctors_visible_p): New predicate.\n+\t(type_possibly_instantiated_p): New predicate.\n+\t(get_odr_type): Compute all_derivations_known.\n+\t(dump_odr_type): Dump the flag.\n+\t(maybe_record_type): Cleanup.\n+\t(record_target_from_binfo): Add bases_to_consider array;\n+\trecord bases for types w/o instances and skip CXX destructor.\n+\t(possible_polymorphic_call_targets_1): Add bases_to_consider\n+\tand consider_construction parameters; check if type may\n+\thave instance.\n+\t(get_polymorphic_call_info): Set maybe_in_construction to true\n+\twhen we know nothing.\n+\t(record_targets_from_bases): Skip CXX destructors; they are\n+\tnever called for types in construction.\n+\t(possible_polymorphic_call_targets): Do not record target when\n+\ttype may not have instance.\n+\n 2014-04-16  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/60854"}, {"sha": "eab7ecdb8c76b5d0868b181b47ab617abe753baf", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 146, "deletions": 27, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d1644bf5b2a2186aa00d50fa7c44832a020f5a8/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d1644bf5b2a2186aa00d50fa7c44832a020f5a8/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=2d1644bf5b2a2186aa00d50fa7c44832a020f5a8", "patch": "@@ -162,6 +162,8 @@ struct GTY(()) odr_type_d\n   int id;\n   /* Is it in anonymous namespace? */\n   bool anonymous_namespace;\n+  /* Do we know about all derivations of given type?  */\n+  bool all_derivations_known;\n };\n \n \n@@ -180,6 +182,61 @@ polymorphic_type_binfo_p (tree binfo)\n   return BINFO_VTABLE (TYPE_BINFO (BINFO_TYPE (binfo)));\n }\n \n+/* Return TRUE if all derived types of T are known and thus\n+   we may consider the walk of derived type complete.\n+\n+   This is typically true only for final anonymous namespace types and types\n+   defined within functions (that may be COMDAT and thus shared across units,\n+   but with the same set of derived types).  */\n+\n+static bool\n+type_all_derivations_known_p (tree t)\n+{\n+  if (TYPE_FINAL_P (t))\n+    return true;\n+  if (flag_ltrans)\n+    return false;\n+  if (type_in_anonymous_namespace_p (t))\n+    return true;\n+  return (decl_function_context (TYPE_NAME (t)) != NULL);\n+}\n+\n+/* Return TURE if type's constructors are all visible.  */\n+\n+static bool\n+type_all_ctors_visible_p (tree t)\n+{\n+  return !flag_ltrans\n+\t && cgraph_state >= CGRAPH_STATE_CONSTRUCTION\n+\t /* We can not always use type_all_derivations_known_p.\n+\t    For function local types we must assume case where\n+\t    the function is COMDAT and shared in between units. \n+\n+\t    TODO: These cases are quite easy to get, but we need\n+\t    to keep track of C++ privatizing via -Wno-weak\n+\t    as well as the  IPA privatizing.  */\n+\t && type_in_anonymous_namespace_p (t);\n+}\n+\n+/* Return TRUE if type may have instance.  */\n+\n+static bool\n+type_possibly_instantiated_p (tree t)\n+{\n+  tree vtable;\n+  varpool_node *vnode;\n+\n+  /* TODO: Add abstract types here.  */\n+  if (!type_all_ctors_visible_p (t))\n+    return true;\n+\n+  vtable = BINFO_VTABLE (TYPE_BINFO (t));\n+  if (TREE_CODE (vtable) == POINTER_PLUS_EXPR)\n+    vtable = TREE_OPERAND (TREE_OPERAND (vtable, 0), 0);\n+  vnode = varpool_get_node (vtable);\n+  return vnode && vnode->definition;\n+}\n+\n /* One Definition Rule hashtable helpers.  */\n \n struct odr_hasher \n@@ -439,6 +496,7 @@ get_odr_type (tree type, bool insert)\n       val->bases = vNULL;\n       val->derived_types = vNULL;\n       val->anonymous_namespace = type_in_anonymous_namespace_p (type);\n+      val->all_derivations_known = type_all_derivations_known_p (type);\n       *slot = val;\n       for (i = 0; i < BINFO_N_BASE_BINFOS (binfo); i++)\n \t/* For now record only polymorphic types. other are\n@@ -469,7 +527,8 @@ dump_odr_type (FILE *f, odr_type t, int indent=0)\n   unsigned int i;\n   fprintf (f, \"%*s type %i: \", indent * 2, \"\", t->id);\n   print_generic_expr (f, t->type, TDF_SLIM);\n-  fprintf (f, \"%s\\n\", t->anonymous_namespace ? \" (anonymous namespace)\":\"\");\n+  fprintf (f, \"%s\", t->anonymous_namespace ? \" (anonymous namespace)\":\"\");\n+  fprintf (f, \"%s\\n\", t->all_derivations_known ? \" (derivations known)\":\"\");\n   if (TYPE_NAME (t->type))\n     {\n       fprintf (f, \"%*s defined at: %s:%i\\n\", indent * 2, \"\",\n@@ -710,14 +769,16 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n \t}\n     }\n   else if (completep\n-\t   && !type_in_anonymous_namespace_p\n-\t\t (method_class_type (TREE_TYPE (target))))\n+\t   && (!type_in_anonymous_namespace_p\n+\t\t (DECL_CONTEXT (target))\n+\t       || flag_ltrans))\n     *completep = false;\n }\n \n /* See if BINFO's type match OUTER_TYPE.  If so, lookup \n    BINFO of subtype of OTR_TYPE at OFFSET and in that BINFO find\n-   method in vtable and insert method to NODES array.\n+   method in vtable and insert method to NODES array\n+   or BASES_TO_CONSIDER if this array is non-NULL.\n    Otherwise recurse to base BINFOs.\n    This match what get_binfo_at_offset does, but with offset\n    being unknown.\n@@ -736,6 +797,7 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n \n static void\n record_target_from_binfo (vec <cgraph_node *> &nodes,\n+\t\t\t  vec <tree> *bases_to_consider,\n \t\t\t  tree binfo,\n \t\t\t  tree otr_type,\n \t\t\t  vec <tree> &type_binfos,\n@@ -795,13 +857,19 @@ record_target_from_binfo (vec <cgraph_node *> &nodes,\n \t    return;\n \t}\n       gcc_assert (inner_binfo);\n-      if (!pointer_set_insert (matched_vtables, BINFO_VTABLE (inner_binfo)))\n+      if (bases_to_consider\n+\t  ? !pointer_set_contains (matched_vtables, BINFO_VTABLE (inner_binfo))\n+\t  : !pointer_set_insert (matched_vtables, BINFO_VTABLE (inner_binfo)))\n \t{\n \t  bool can_refer;\n \t  tree target = gimple_get_virt_method_for_binfo (otr_token,\n \t\t\t\t\t\t\t  inner_binfo,\n \t\t\t\t\t\t\t  &can_refer);\n-\t  maybe_record_node (nodes, target, inserted, can_refer, completep);\n+\t  if (!bases_to_consider)\n+\t    maybe_record_node (nodes, target, inserted, can_refer, completep);\n+\t  /* Destructors are never called via construction vtables.  */\n+\t  else if (!target || !DECL_CXX_DESTRUCTOR_P (target))\n+\t    bases_to_consider->safe_push (target);\n \t}\n       return;\n     }\n@@ -810,7 +878,7 @@ record_target_from_binfo (vec <cgraph_node *> &nodes,\n   for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     /* Walking bases that have no virtual method is pointless excercise.  */\n     if (polymorphic_type_binfo_p (base_binfo))\n-      record_target_from_binfo (nodes, base_binfo, otr_type,\n+      record_target_from_binfo (nodes, bases_to_consider, base_binfo, otr_type,\n \t\t\t\ttype_binfos, \n \t\t\t\totr_token, outer_type, offset, inserted,\n \t\t\t\tmatched_vtables, anonymous, completep);\n@@ -822,7 +890,11 @@ record_target_from_binfo (vec <cgraph_node *> &nodes,\n    of TYPE, insert them to NODES, recurse into derived nodes. \n    INSERTED is used to avoid duplicate insertions of methods into NODES.\n    MATCHED_VTABLES are used to avoid duplicate walking vtables.\n-   Clear COMPLETEP if unreferable target is found.  */\n+   Clear COMPLETEP if unreferable target is found.\n+ \n+   If CONSIDER_CONSTURCTION is true, record to BASES_TO_CONSDIER\n+   all cases where BASE_SKIPPED is true (because the base is abstract\n+   class).  */\n \n static void\n possible_polymorphic_call_targets_1 (vec <cgraph_node *> &nodes,\n@@ -833,23 +905,39 @@ possible_polymorphic_call_targets_1 (vec <cgraph_node *> &nodes,\n \t\t\t\t     HOST_WIDE_INT otr_token,\n \t\t\t\t     tree outer_type,\n \t\t\t\t     HOST_WIDE_INT offset,\n-\t\t\t\t     bool *completep)\n+\t\t\t\t     bool *completep,\n+\t\t\t\t     vec <tree> &bases_to_consider,\n+\t\t\t\t     bool consider_construction)\n {\n   tree binfo = TYPE_BINFO (type->type);\n   unsigned int i;\n   vec <tree> type_binfos = vNULL;\n-\n-  record_target_from_binfo (nodes, binfo, otr_type, type_binfos, otr_token,\n-\t\t\t    outer_type, offset,\n-\t\t\t    inserted, matched_vtables,\n-\t\t\t    type->anonymous_namespace, completep);\n+  bool possibly_instantiated = type_possibly_instantiated_p (type->type);\n+\n+  /* We may need to consider types w/o instances because of possible derived\n+     types using their methods either directly or via construction vtables.\n+     We are safe to skip them when all derivations are known, since we will\n+     handle them later.\n+     This is done by recording them to BASES_TO_CONSIDER array.  */\n+  if (possibly_instantiated || consider_construction)\n+    {\n+      record_target_from_binfo (nodes,\n+\t\t\t\t(!possibly_instantiated\n+\t\t\t\t && type_all_derivations_known_p (type->type))\n+\t\t\t\t? &bases_to_consider : NULL,\n+\t\t\t\tbinfo, otr_type, type_binfos, otr_token,\n+\t\t\t\touter_type, offset,\n+\t\t\t\tinserted, matched_vtables,\n+\t\t\t\ttype->anonymous_namespace, completep);\n+    }\n   type_binfos.release ();\n   for (i = 0; i < type->derived_types.length (); i++)\n     possible_polymorphic_call_targets_1 (nodes, inserted, \n \t\t\t\t\t matched_vtables,\n \t\t\t\t\t otr_type,\n \t\t\t\t\t type->derived_types[i],\n-\t\t\t\t\t otr_token, outer_type, offset, completep);\n+\t\t\t\t\t otr_token, outer_type, offset, completep,\n+\t\t\t\t\t bases_to_consider, consider_construction);\n }\n \n /* Cache of queries for polymorphic call targets.\n@@ -1232,7 +1320,7 @@ get_polymorphic_call_info (tree fndecl,\n   context->offset = 0;\n   base_pointer = OBJ_TYPE_REF_OBJECT (ref);\n   context->maybe_derived_type = true;\n-  context->maybe_in_construction = false;\n+  context->maybe_in_construction = true;\n \n   /* Walk SSA for outer object.  */\n   do \n@@ -1433,7 +1521,8 @@ record_targets_from_bases (tree otr_type,\n \t  tree target = gimple_get_virt_method_for_binfo (otr_token,\n \t\t\t\t\t\t\t  base_binfo,\n \t\t\t\t\t\t\t  &can_refer);\n-\t  maybe_record_node (nodes, target, inserted, can_refer, completep);\n+\t  if (!target || ! DECL_CXX_DESTRUCTOR_P (target))\n+\t    maybe_record_node (nodes, target, inserted, can_refer, completep);\n \t  pointer_set_insert (matched_vtables, BINFO_VTABLE (base_binfo));\n \t}\n     }\n@@ -1487,13 +1576,15 @@ possible_polymorphic_call_targets (tree otr_type,\n   pointer_set_t *inserted;\n   pointer_set_t *matched_vtables;\n   vec <cgraph_node *> nodes = vNULL;\n+  vec <tree> bases_to_consider = vNULL;\n   odr_type type, outer_type;\n   polymorphic_call_target_d key;\n   polymorphic_call_target_d **slot;\n   unsigned int i;\n   tree binfo, target;\n   bool complete;\n   bool can_refer;\n+  bool skipped = false;\n \n   /* If ODR is not initialized, return empty incomplete list.  */\n   if (!odr_hash.is_created ())\n@@ -1539,9 +1630,6 @@ possible_polymorphic_call_targets (tree otr_type,\n     }\n   /* We need to update our hiearchy if the type does not exist.  */\n   outer_type = get_odr_type (context.outer_type, true);\n-  /* If outer and inner type match, there are no bases to see.  */\n-  if (type == outer_type)\n-    context.maybe_in_construction = false;\n   /* If the type is complete, there are no derivations.  */\n   if (TYPE_FINAL_P (outer_type->type))\n     context.maybe_derived_type = false;\n@@ -1602,7 +1690,10 @@ possible_polymorphic_call_targets (tree otr_type,\n       target = NULL;\n     }\n \n-  maybe_record_node (nodes, target, inserted, can_refer, &complete);\n+  /* Destructors are never called through construction virtual tables,\n+     because the type is always known.  */\n+  if (target && DECL_CXX_DESTRUCTOR_P (target))\n+    context.maybe_in_construction = false;\n \n   if (target)\n     {\n@@ -1611,8 +1702,15 @@ possible_polymorphic_call_targets (tree otr_type,\n       if (DECL_FINAL_P (target))\n \tcontext.maybe_derived_type = false;\n     }\n+\n+  /* If OUTER_TYPE is abstract, we know we are not seeing its instance.  */\n+  if (type_possibly_instantiated_p (outer_type->type))\n+    maybe_record_node (nodes, target, inserted, can_refer, &complete);\n   else\n-    gcc_assert (!complete);\n+    {\n+      skipped = true;\n+      gcc_assert (in_lto_p || context.maybe_derived_type);\n+    }\n \n   pointer_set_insert (matched_vtables, BINFO_VTABLE (binfo));\n \n@@ -1621,23 +1719,44 @@ possible_polymorphic_call_targets (tree otr_type,\n     {\n       /* For anonymous namespace types we can attempt to build full type.\n \t All derivations must be in this unit (unless we see partial unit).  */\n-      if (!type->anonymous_namespace || flag_ltrans)\n+      if (!type->all_derivations_known)\n \tcomplete = false;\n       for (i = 0; i < outer_type->derived_types.length(); i++)\n \tpossible_polymorphic_call_targets_1 (nodes, inserted,\n \t\t\t\t\t     matched_vtables,\n \t\t\t\t\t     otr_type,\n \t\t\t\t\t     outer_type->derived_types[i],\n \t\t\t\t\t     otr_token, outer_type->type,\n-\t\t\t\t\t     context.offset, &complete);\n+\t\t\t\t\t     context.offset, &complete,\n+\t\t\t\t\t     bases_to_consider,\n+\t\t\t\t\t     context.maybe_in_construction);\n     }\n \n   /* Finally walk bases, if asked to.  */\n   (*slot)->nonconstruction_targets = nodes.length();\n+\n+  /* Destructors are never called through construction virtual tables,\n+     because the type is always known.  One of entries may be cxa_pure_virtual\n+     so look to at least two of them.  */\n+  if (context.maybe_in_construction)\n+    for (i =0 ; i < MIN (nodes.length (), 2); i++)\n+      if (DECL_CXX_DESTRUCTOR_P (nodes[i]->decl))\n+\tcontext.maybe_in_construction = false;\n   if (context.maybe_in_construction)\n-    record_targets_from_bases (otr_type, otr_token, outer_type->type,\n-\t\t\t       context.offset, nodes, inserted,\n-\t\t\t       matched_vtables, &complete);\n+    {\n+      if (type != outer_type\n+\t  && (!skipped\n+\t      || (context.maybe_derived_type\n+\t          && !type_all_derivations_known_p (outer_type->type))))\n+\trecord_targets_from_bases (otr_type, otr_token, outer_type->type,\n+\t\t\t\t   context.offset, nodes, inserted,\n+\t\t\t\t   matched_vtables, &complete);\n+      if (skipped)\n+        maybe_record_node (nodes, target, inserted, can_refer, &complete);\n+      for (i = 0; i < bases_to_consider.length(); i++)\n+        maybe_record_node (nodes, bases_to_consider[i], inserted, can_refer, &complete);\n+    }\n+  bases_to_consider.release();\n \n   (*slot)->targets = nodes;\n   (*slot)->complete = complete;"}, {"sha": "b8d40b7a0eef5b9ee1ba40e163a18d2c2c0a34b9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d1644bf5b2a2186aa00d50fa7c44832a020f5a8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d1644bf5b2a2186aa00d50fa7c44832a020f5a8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2d1644bf5b2a2186aa00d50fa7c44832a020f5a8", "patch": "@@ -1,3 +1,7 @@\n+2014-04-16  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* g++.dg/ipa/devirt-31.C: New testcase.\n+\n 2014-04-16  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR lto/60820"}, {"sha": "49ad33e3e6bd0bd2970de7cc6b3203bf10d7301b", "filename": "gcc/testsuite/g++.dg/ipa/devirt-31.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d1644bf5b2a2186aa00d50fa7c44832a020f5a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-31.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d1644bf5b2a2186aa00d50fa7c44832a020f5a8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-31.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-31.C?ref=2d1644bf5b2a2186aa00d50fa7c44832a020f5a8", "patch": "@@ -0,0 +1,16 @@\n+// { dg-options \"-O3 -fdump-tree-ssa\" }\n+inline void t()\n+{\n+  struct A {virtual void q() {}};\n+  static struct A *a;\n+  if (!a)\n+    a = new(A);\n+  a->q();\n+};\n+void\n+m()\n+{\n+  t();\n+}\n+// { dg-final { scan-tree-dump-not \"OBJ_TYPE_REF\" \"ssa\" } }\n+// { dg-final { cleanup-tree-dump \"ssa\" } }"}]}