{"sha": "aca90db9e258f2c5644ead687d604337839f0db0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNhOTBkYjllMjU4ZjJjNTY0NGVhZDY4N2Q2MDQzMzc4MzlmMGRiMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T13:52:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T13:52:19Z"}, "message": "[multiple changes]\n\n2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.ads: E_Abstract_State is now part of the entities that\n\tcan be overloaded. Update type Overloadable_Kind to reflect the\n\tinclusion of abstract states.\n\t* sem_ch6.adb (New_Overloaded_Entity): A function can now\n\toverload an abstract state.\n\t* sem_prag.adb (Analyze_Constituent): Handle the overloading\n\tof states by functions. Use Entity_Of to obtain the entity of\n\ta constituent.\t(Analyze_Global_Item): Handle the overloading of\n\tstates by functions.\n\t(Analyze_Initialization_Item): Handle the\n\toverloading of states by functions.  Use Entity_Of to obtain the\n\tentity of an item.\n\t(Analyze_Input_Item): Handle the overloading\n\tof states by functions. Use Entity_Of to obtain the entity of an item.\n\t(Analyze_Input_Output): Handle the overloading of states by functions.\n\t(Analyze_Refinement_Clause): Handle the overloading\n\tof states by functions.  Use Entity_Of to obtain the entity of an item.\n\t(Appears_In): Use Entity_Of to obtain the entity of an element.\n\t(Check_Usage): Use Entity_Of to obtain the entity of\n\tan item. Add a guard to prevent a crash due to a previous error.\n\t(Resolve_State): New routine.\n\n2014-01-20  Yannick Moy  <moy@adacore.com>\n\n\t* spark_xrefs.ads, debug.adb, gnat1drv.adb, errout.adb, errout.ads,\n\topt.ads: Minor comments updates.\n\nFrom-SVN: r206809", "tree": {"sha": "cf6bf18d53a5d2fe4198bf0c7c668af20741f2b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf6bf18d53a5d2fe4198bf0c7c668af20741f2b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aca90db9e258f2c5644ead687d604337839f0db0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aca90db9e258f2c5644ead687d604337839f0db0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aca90db9e258f2c5644ead687d604337839f0db0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aca90db9e258f2c5644ead687d604337839f0db0/comments", "author": null, "committer": null, "parents": [{"sha": "dc72675740ac7e955a2ae13855da45f7818686ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc72675740ac7e955a2ae13855da45f7818686ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc72675740ac7e955a2ae13855da45f7818686ae"}], "stats": {"total": 172, "additions": 132, "deletions": 40}, "files": [{"sha": "d507793d01763aaa2883632b576e7127b5afee45", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=aca90db9e258f2c5644ead687d604337839f0db0", "patch": "@@ -1,3 +1,32 @@\n+2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.ads: E_Abstract_State is now part of the entities that\n+\tcan be overloaded. Update type Overloadable_Kind to reflect the\n+\tinclusion of abstract states.\n+\t* sem_ch6.adb (New_Overloaded_Entity): A function can now\n+\toverload an abstract state.\n+\t* sem_prag.adb (Analyze_Constituent): Handle the overloading\n+\tof states by functions. Use Entity_Of to obtain the entity of\n+\ta constituent.\t(Analyze_Global_Item): Handle the overloading of\n+\tstates by functions.\n+\t(Analyze_Initialization_Item): Handle the\n+\toverloading of states by functions.  Use Entity_Of to obtain the\n+\tentity of an item.\n+\t(Analyze_Input_Item): Handle the overloading\n+\tof states by functions. Use Entity_Of to obtain the entity of an item.\n+\t(Analyze_Input_Output): Handle the overloading of states by functions.\n+\t(Analyze_Refinement_Clause): Handle the overloading\n+\tof states by functions.  Use Entity_Of to obtain the entity of an item.\n+\t(Appears_In): Use Entity_Of to obtain the entity of an element.\n+\t(Check_Usage): Use Entity_Of to obtain the entity of\n+\tan item. Add a guard to prevent a crash due to a previous error.\n+\t(Resolve_State): New routine.\n+\n+2014-01-20  Yannick Moy  <moy@adacore.com>\n+\n+\t* spark_xrefs.ads, debug.adb, gnat1drv.adb, errout.adb, errout.ads,\n+\topt.ads: Minor comments updates.\n+\n 2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* einfo.adb (Non_Limited_View): Applies to abstract states."}, {"sha": "bb98c5c45431f080d788d0cf1412cfc3162037b9", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=aca90db9e258f2c5644ead687d604337839f0db0", "patch": "@@ -606,9 +606,9 @@ package body Debug is\n    --       ALI files to compute effects of subprograms. Note that ALI files\n    --       are only written when option d.G is also given.\n \n-   --  d.G  Frame condition mode for gnat2why. In this mode, gnat2why will not\n-   --       generate Why code. Instead, it generates ALI files with an extra\n-   --       section which contains the effects of subprograms.\n+   --  d.G  Frame condition mode for gnat2why. In this mode, gnat2why will\n+   --       generate ALI files with an extra section which contains the effects\n+   --       of subprograms.\n \n    --  d.I  Do not ignore enum representation clauses in CodePeer mode.\n    --       The default of ignoring representation clauses for enumeration"}, {"sha": "59ab153555fde2da06d80874a473f008a63ce1f8", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=aca90db9e258f2c5644ead687d604337839f0db0", "patch": "@@ -4462,6 +4462,11 @@ package Einfo is\n       --  An entry, created by an entry declaration in a task or protected\n       --  object.\n \n+      E_Abstract_State,\n+      --  A state abstraction. Used to designate entities introduced by aspect\n+      --  or pragma Abstract_State. The entity carries the various properties\n+      --  of the state.\n+\n       --------------------\n       -- Other Entities --\n       --------------------\n@@ -4533,16 +4538,11 @@ package Einfo is\n       --  A task body. This entity serves almost no function, since all\n       --  semantic analysis uses the protected entity (E_Task_Type).\n \n-      E_Subprogram_Body,\n+      E_Subprogram_Body\n       --  A subprogram body. Used when a subprogram has a separate declaration\n       --  to represent the entity for the body. This entity serves almost no\n       --  function, since all semantic analysis uses the subprogram entity\n       --  for the declaration (E_Function or E_Procedure).\n-\n-      E_Abstract_State\n-      --  A state abstraction. Used to designate entities introduced by aspect\n-      --  or pragma Abstract_State. The entity carries the various properties\n-      --  of the state.\n    );\n \n    for Entity_Kind'Size use 8;\n@@ -4792,7 +4792,8 @@ package Einfo is\n    --  E_Function\n    --  E_Operator\n    --  E_Procedure\n-       E_Entry;\n+   --  E_Entry\n+       E_Abstract_State;\n \n    subtype Private_Kind                is Entity_Kind range\n        E_Record_Type_With_Private .."}, {"sha": "0e69062920a05983035314a9db7d6adf7995bdbf", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=aca90db9e258f2c5644ead687d604337839f0db0", "patch": "@@ -234,7 +234,7 @@ package body Errout is\n       if not Finalize_Called then\n          raise Program_Error;\n \n-      --  In formal verification mode, errors issued when generating Why code\n+      --  In formal verification mode, errors issued when analyzing code\n       --  are not compilation errors, and should not result in exiting with\n       --  an error status. These errors are handled in the driver of the\n       --  verification process instead."}, {"sha": "056132924487546583eb3a06d0114e6db9e1bf54", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=aca90db9e258f2c5644ead687d604337839f0db0", "patch": "@@ -818,7 +818,7 @@ package Errout is\n    --  Returns True if errors have been detected, or warnings in -gnatwe (treat\n    --  warnings as errors) mode. Note that it is mandatory to call Finalize\n    --  before calling this routine. Always returns False in formal verification\n-   --  mode, because errors issued when generating Why code are not compilation\n+   --  mode, because errors issued when analyzing code are not compilation\n    --  errors, and should not result in exiting with an error status.\n \n    procedure Error_Msg_CRT (Feature : String; N : Node_Id);"}, {"sha": "8693fd193a3e38610ad9555f28fa04c52d801547", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=aca90db9e258f2c5644ead687d604337839f0db0", "patch": "@@ -317,10 +317,10 @@ procedure Gnat1drv is\n          end if;\n \n          --  Distinguish between the two modes of gnat2why: frame condition\n-         --  generation (generation of ALI files) and translation of Why (no\n-         --  ALI files generated). This is done with the switch -gnatd.G,\n-         --  which activates frame condition mode. The other changes in\n-         --  behavior depending on this switch are done in gnat2why directly.\n+         --  generation (generation of ALI files) and analysis (no ALI files\n+         --  generated). This is done with the switch -gnatd.G, which activates\n+         --  frame condition mode. The other changes in behavior depending on\n+         --  this switch are done in gnat2why directly.\n \n          if Debug_Flag_Dot_GG then\n             Frame_Condition_Mode := True;\n@@ -1057,7 +1057,7 @@ begin\n       --  It is not an error to analyze in GNATprove mode a spec which requires\n       --  a body, when the body is not available. During frame condition\n       --  generation, the corresponding ALI file is generated. During\n-      --  translation to Why, Why code is generated for the spec.\n+      --  analysis, the spec is analyzed.\n \n       elsif GNATprove_Mode then\n          Back_End_Mode := Declarations_Only;"}, {"sha": "e06cf1e64310032ecfce4f8636293236471563ed", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=aca90db9e258f2c5644ead687d604337839f0db0", "patch": "@@ -1995,8 +1995,8 @@ package Opt is\n    Frame_Condition_Mode : Boolean := False;\n    --  Specific mode to be used in combination with GNATprove_Mode. If set to\n    --  true, ALI files containing the frame conditions (global effects) are\n-   --  generated, and Why files are *not* generated. If not true, Why files\n-   --  are generated. Set by debug flag -gnatd.G.\n+   --  generated, and analysis is *not* performed. If not true, analysis is\n+   --  performed. Set by debug flag -gnatd.G.\n \n    Formal_Extensions : Boolean := False;\n    --  When this flag is set, new aspects/pragmas/attributes are accepted,\n@@ -2008,12 +2008,11 @@ package Opt is\n    --  in a configuration file such as gnat.adc.\n \n    GNATprove_Mode : Boolean := False;\n-   --  Specific compiling mode targeting formal verification through the\n-   --  generation of Why code for those parts of the input code that belong to\n-   --  the SPARK 2014 subset of Ada. Set True by the gnat2why executable or by\n-   --  use of the -gnatd.F debug switch. Note that this is completely separate\n-   --  from the SPARK restriction defined in GNAT to detect violations of a\n-   --  subset of SPARK 2005 rules.\n+   --  Specific compiling mode targeting formal verification for those parts\n+   --  of the input code that belong to the SPARK 2014 subset of Ada. Set True\n+   --  by the gnat2why executable or by use of the -gnatd.F debug switch. Note\n+   --  that this is completely separate from the SPARK restriction defined in\n+   --  GNAT to detect violations of a subset of SPARK 2005 rules.\n \n    SPARK_Strict_Mode : Boolean := False;\n    --  Interpret compiler permissions as strictly as possible. E.g. base ranges"}, {"sha": "4ad72dffe2d11192b83260543c800a079a30de45", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=aca90db9e258f2c5644ead687d604337839f0db0", "patch": "@@ -10513,6 +10513,16 @@ package body Sem_Ch6 is\n             if Scope (E) /= Current_Scope then\n                null;\n \n+            --  A function can overload the name of an abstract state. The\n+            --  state can be viewed as a function with a profile that cannot\n+            --  be matched by anything.\n+\n+            elsif Ekind (S) = E_Function\n+              and then Ekind (E) = E_Abstract_State\n+            then\n+               Enter_Overloaded_Entity (S);\n+               return;\n+\n             --  Ada 2012 (AI05-0165): For internally generated bodies of null\n             --  procedures locate the internally generated spec. We enforce\n             --  mode conformance since a tagged type may inherit from"}, {"sha": "29240bc38105a2c8bfc962aabbd9428455ec0738", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 67, "deletions": 13, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=aca90db9e258f2c5644ead687d604337839f0db0", "patch": "@@ -284,6 +284,11 @@ package body Sem_Prag is\n    --  determines if we have a body reference to an abstract state, which may\n    --  be illegal if the state is refined within the body.\n \n+   procedure Resolve_State (N : Node_Id);\n+   --  Handle the overloading of state names by functions. When N denotes a\n+   --  function, this routine finds the corresponding state and sets the entity\n+   --  of N to that of the state.\n+\n    procedure Rewrite_Assertion_Kind (N : Node_Id);\n    --  If N is Pre'Class, Post'Class, Invariant'Class, or Type_Invariant'Class,\n    --  then it is rewritten as an identifier with the corresponding special\n@@ -771,7 +776,8 @@ package body Sem_Prag is\n                   Error_Msg_N (\"cannot mix null and non-null items\", Item);\n                end if;\n \n-               Analyze (Item);\n+               Analyze       (Item);\n+               Resolve_State (Item);\n \n                --  Find the entity of the item. If this is a renaming, climb\n                --  the renaming chain to reach the root object. Renamings of\n@@ -1075,12 +1081,14 @@ package body Sem_Prag is\n             if Nkind (Item) = N_Defining_Identifier then\n                Item_Id := Item;\n             else\n-               Item_Id := Entity (Item);\n+               Item_Id := Entity_Of (Item);\n             end if;\n \n             --  The item does not appear in a dependency\n \n-            if not Contains (Used_Items, Item_Id) then\n+            if Present (Item_Id)\n+              and then not Contains (Used_Items, Item_Id)\n+            then\n                if Is_Formal (Item_Id) then\n                   Usage_Error (Item, Item_Id);\n \n@@ -1645,7 +1653,8 @@ package body Sem_Prag is\n                return;\n             end if;\n \n-            Analyze (Item);\n+            Analyze       (Item);\n+            Resolve_State (Item);\n \n             --  Find the entity of the item. If this is a renaming, climb the\n             --  renaming chain to reach the root object. Renamings of non-\n@@ -2262,10 +2271,11 @@ package body Sem_Prag is\n                  (\"cannot mix null and non-null initialization items\", Item);\n             end if;\n \n-            Analyze (Item);\n+            Analyze       (Item);\n+            Resolve_State (Item);\n \n             if Is_Entity_Name (Item) then\n-               Item_Id := Entity (Item);\n+               Item_Id := Entity_Of (Item);\n \n                if Ekind_In (Item_Id, E_Abstract_State, E_Variable) then\n \n@@ -2356,10 +2366,11 @@ package body Sem_Prag is\n                     (\"cannot mix null and non-null initialization item\", Item);\n                end if;\n \n-               Analyze (Input);\n+               Analyze       (Input);\n+               Resolve_State (Input);\n \n                if Is_Entity_Name (Input) then\n-                  Input_Id := Entity (Input);\n+                  Input_Id := Entity_Of (Input);\n \n                   if Ekind_In (Input_Id, E_Abstract_State, E_Variable) then\n \n@@ -21574,13 +21585,14 @@ package body Sem_Prag is\n                     (\"cannot mix null and non-null constituents\", Constit);\n                end if;\n \n-               Analyze (Constit);\n+               Analyze       (Constit);\n+               Resolve_State (Constit);\n \n                --  Ensure that the constituent denotes a valid state or a\n                --  whole variable.\n \n                if Is_Entity_Name (Constit) then\n-                  Constit_Id := Entity (Constit);\n+                  Constit_Id := Entity_Of (Constit);\n \n                   if Ekind_In (Constit_Id, E_Abstract_State, E_Variable) then\n                      Check_Matching_Constituent (Constit_Id);\n@@ -21665,13 +21677,14 @@ package body Sem_Prag is\n                  (\"refinement clause cannot cover multiple states\", State);\n \n             else\n-               Analyze (State);\n+               Analyze       (State);\n+               Resolve_State (State);\n \n                --  Ensure that the state name denotes a valid abstract state\n                --  that is defined in the spec of the related package.\n \n                if Is_Entity_Name (State) then\n-                  State_Id := Entity (State);\n+                  State_Id := Entity_Of (State);\n \n                   --  Catch any attempts to re-refine a state or refine a\n                   --  state that is not defined in the package declaration.\n@@ -21974,7 +21987,7 @@ package body Sem_Prag is\n             if Nkind (Node (Elmt)) = N_Defining_Identifier then\n                Id := Node (Elmt);\n             else\n-               Id := Entity (Node (Elmt));\n+               Id := Entity_Of (Node (Elmt));\n             end if;\n \n             if Id = Item_Id then\n@@ -23491,6 +23504,47 @@ package body Sem_Prag is\n       end loop;\n    end Relocate_Pragmas_To_Body;\n \n+   -------------------\n+   -- Resolve_State --\n+   -------------------\n+\n+   procedure Resolve_State (N : Node_Id) is\n+      Func  : Entity_Id;\n+      State : Entity_Id;\n+\n+   begin\n+      if Is_Entity_Name (N) and then Present (Entity (N)) then\n+         Func := Entity (N);\n+\n+         --  Handle overloading of state names by functions. Traverse the\n+         --  homonym chain looking for an abstract state.\n+\n+         if Ekind (Func) = E_Function and then Has_Homonym (Func) then\n+            State := Homonym (Func);\n+            while Present (State) loop\n+\n+               --  Resolve the overloading by setting the proper entity of the\n+               --  reference to that of the state.\n+\n+               if Ekind (State) = E_Abstract_State then\n+                  Set_Etype           (N, Standard_Void_Type);\n+                  Set_Entity          (N, State);\n+                  Set_Associated_Node (N, State);\n+                  return;\n+               end if;\n+\n+               State := Homonym (State);\n+            end loop;\n+\n+            --  A function can never act as a state. If the homonym chain does\n+            --  not contain a corresponding state, then something went wrong in\n+            --  the overloading mechanism.\n+\n+            raise Program_Error;\n+         end if;\n+      end if;\n+   end Resolve_State;\n+\n    ----------------------------\n    -- Rewrite_Assertion_Kind --\n    ----------------------------"}, {"sha": "e7df0331ba1374cbd536911399f2d402c2659c24", "filename": "gcc/ada/spark_xrefs.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2Fspark_xrefs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca90db9e258f2c5644ead687d604337839f0db0/gcc%2Fada%2Fspark_xrefs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fspark_xrefs.ads?ref=aca90db9e258f2c5644ead687d604337839f0db0", "patch": "@@ -56,8 +56,7 @@ package SPARK_Xrefs is\n \n    --  SPARK cross-reference information is generated on a unit-by-unit basis\n    --  in the ALI file, using lines that start with the identifying character F\n-   --  (\"Formal\").  These lines are generated if -gnatd.E or -gnatd.F (Why\n-   --  generation mode) switches are set.\n+   --  (\"Formal\"). These lines are generated if Frame_Condition_Mode is True.\n \n    --  The SPARK cross-reference information comes after the shared\n    --  cross-reference information, so it needs not be read by tools like"}]}