{"sha": "3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NiOGVlNWNkNmI3MmNlYjg3Yjg5Y2FjYjliY2IxNjlhN2IzNGRkNg==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@vnet.ibm.com", "date": "2017-07-27T20:04:53Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2017-07-27T20:04:53Z"}, "message": "predicates.md (volatile_mem_operand): Remove code related to reload_in_progress.\n\n\t* config/rs6000/predicates.md (volatile_mem_operand): Remove code\n\trelated to reload_in_progress.\n\t(splat_input_operand): Likewise.\n\t* config/rs6000/rs6000-protos.h (rs6000_secondary_memory_needed_rtx):\n\tDelete prototype.\n\t* config/rs6000/rs6000.c (machine_function): Remove sdmode_stack_slot\n\tfield.\n\t(TARGET_EXPAND_TO_RTL_HOOK): Delete.\n\t(TARGET_INSTANTIATE_DECLS): Likewise.\n\t(legitimate_indexed_address_p): Delete reload_in_progress code.\n\t(rs6000_debug_legitimate_address_p): Likewise.\n\t(rs6000_eliminate_indexed_memrefs): Likewise.\n\t(rs6000_emit_le_vsx_store): Likewise.\n\t(rs6000_emit_move_si_sf_subreg): Likewise.\n\t(rs6000_emit_move): Likewise.\n\t(register_to_reg_type): Likewise.\n\t(rs6000_pre_atomic_barrier): Likewise.\n\t(rs6000_machopic_legitimize_pic_address): Likewise.\n\t(rs6000_allocate_stack_temp): Likewise.\n\t(rs6000_address_for_fpconvert): Likewise.\n\t(rs6000_address_for_altivec): Likewise.\n\t(rs6000_secondary_memory_needed_rtx): Delete function.\n\t(rs6000_check_sdmode): Likewise.\n\t(rs6000_alloc_sdmode_stack_slot): Likewise.\n\t(rs6000_instantiate_decls): Likewise.\n\t* config/rs6000/rs6000.h (SECONDARY_MEMORY_NEEDED_RTX): Delete.\n\t* config/rs6000/rs6000.md (splitter for *movsi_got_internal):\n\tDelete reload_in_progress.\n\t(*vec_reload_and_plus_<mptrsize>): Likewise.\n\t* config/rs6000/vsx.md (vsx_mul_v2di): Likewise.\n\t(vsx_div_v2di): Likewise.\n\t(vsx_udiv_v2di): Likewise.\n\nFrom-SVN: r250638", "tree": {"sha": "a52e372df1cdf1f2496562743ac2b73bfa1d0c18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a52e372df1cdf1f2496562743ac2b73bfa1d0c18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7a5cbf29beb2485a4385613a02cbc0be1c03d2bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a5cbf29beb2485a4385613a02cbc0be1c03d2bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a5cbf29beb2485a4385613a02cbc0be1c03d2bb"}], "stats": {"total": 314, "additions": 62, "deletions": 252}, "files": [{"sha": "be98abe05157f12349af7f4c4d69c4ae01129160", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6", "patch": "@@ -1,3 +1,38 @@\n+2017-07-27  Peter Bergner  <bergner@vnet.ibm.com>\n+\n+\t* config/rs6000/predicates.md (volatile_mem_operand): Remove code\n+\trelated to reload_in_progress.\n+\t(splat_input_operand): Likewise.\n+\t* config/rs6000/rs6000-protos.h (rs6000_secondary_memory_needed_rtx):\n+\tDelete prototype.\n+\t* config/rs6000/rs6000.c (machine_function): Remove sdmode_stack_slot\n+\tfield.\n+\t(TARGET_EXPAND_TO_RTL_HOOK): Delete.\n+\t(TARGET_INSTANTIATE_DECLS): Likewise.\n+\t(legitimate_indexed_address_p): Delete reload_in_progress code.\n+\t(rs6000_debug_legitimate_address_p): Likewise.\n+\t(rs6000_eliminate_indexed_memrefs): Likewise.\n+\t(rs6000_emit_le_vsx_store): Likewise.\n+\t(rs6000_emit_move_si_sf_subreg): Likewise.\n+\t(rs6000_emit_move): Likewise.\n+\t(register_to_reg_type): Likewise.\n+\t(rs6000_pre_atomic_barrier): Likewise.\n+\t(rs6000_machopic_legitimize_pic_address): Likewise.\n+\t(rs6000_allocate_stack_temp): Likewise.\n+\t(rs6000_address_for_fpconvert): Likewise.\n+\t(rs6000_address_for_altivec): Likewise.\n+\t(rs6000_secondary_memory_needed_rtx): Delete function.\n+\t(rs6000_check_sdmode): Likewise.\n+\t(rs6000_alloc_sdmode_stack_slot): Likewise.\n+\t(rs6000_instantiate_decls): Likewise.\n+\t* config/rs6000/rs6000.h (SECONDARY_MEMORY_NEEDED_RTX): Delete.\n+\t* config/rs6000/rs6000.md (splitter for *movsi_got_internal):\n+\tDelete reload_in_progress.\n+\t(*vec_reload_and_plus_<mptrsize>): Likewise.\n+\t* config/rs6000/vsx.md (vsx_mul_v2di): Likewise.\n+\t(vsx_div_v2di): Likewise.\n+\t(vsx_udiv_v2di): Likewise.\n+\n 2017-07-27  Peter Bergner  <bergner@vnet.ibm.com>\n \n \t* config/rs6000/rs6000.opt (mlra): Replace with stub."}, {"sha": "466f9131aa04739a726b49f4904a569191df12cd", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6", "patch": "@@ -783,10 +783,8 @@\n   (and (and (match_code \"mem\")\n \t    (match_test \"MEM_VOLATILE_P (op)\"))\n        (if_then_else (match_test \"reload_completed\")\n-         (match_operand 0 \"memory_operand\")\n-         (if_then_else (match_test \"reload_in_progress\")\n-\t   (match_test \"strict_memory_address_p (mode, XEXP (op, 0))\")\n-\t   (match_test \"memory_address_p (mode, XEXP (op, 0))\")))))\n+\t (match_operand 0 \"memory_operand\")\n+\t (match_test \"memory_address_p (mode, XEXP (op, 0))\"))))\n \n ;; Return 1 if the operand is an offsettable memory operand.\n (define_predicate \"offsettable_mem_operand\"\n@@ -1142,7 +1140,7 @@\n       if (! volatile_ok && MEM_VOLATILE_P (op))\n \treturn 0;\n \n-      if (reload_in_progress || lra_in_progress || reload_completed)\n+      if (lra_in_progress || reload_completed)\n \treturn indexed_or_indirect_address (addr, vmode);\n       else\n \treturn memory_address_addr_space_p (vmode, addr, MEM_ADDR_SPACE (op));"}, {"sha": "144bdb26fa4ee0e6b34313cc1def7db00cb58510", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6", "patch": "@@ -155,7 +155,6 @@ extern void rs6000_emit_le_vsx_permute (rtx, rtx, machine_mode);\n extern void rs6000_emit_le_vsx_move (rtx, rtx, machine_mode);\n extern bool valid_sf_si_move (rtx, rtx, machine_mode);\n extern void rs6000_emit_move (rtx, rtx, machine_mode);\n-extern rtx rs6000_secondary_memory_needed_rtx (machine_mode);\n extern machine_mode rs6000_secondary_memory_needed_mode (machine_mode);\n extern rtx (*rs6000_legitimize_reload_address_ptr) (rtx, machine_mode,\n \t\t\t\t\t\t    int, int, int, int *);"}, {"sha": "2fcec13b3f33886049faae61b5d9823765dba295", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 19, "deletions": 234, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6", "patch": "@@ -143,10 +143,6 @@ typedef struct GTY(()) machine_function\n   /* Offset from virtual_stack_vars_rtx to the start of the ABI_V4\n      varargs save area.  */\n   HOST_WIDE_INT varargs_save_offset;\n-  /* Temporary stack slot to use for SDmode copies.  This slot is\n-     64-bits wide and is allocated early enough so that the offset\n-     does not overflow the 16-bit load/store offset field.  */\n-  rtx sdmode_stack_slot;\n   /* Alternative internal arg pointer for -fsplit-stack.  */\n   rtx split_stack_arg_pointer;\n   bool split_stack_argp_used;\n@@ -1872,12 +1868,6 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_BUILTIN_RECIPROCAL\n #define TARGET_BUILTIN_RECIPROCAL rs6000_builtin_reciprocal\n \n-#undef TARGET_EXPAND_TO_RTL_HOOK\n-#define TARGET_EXPAND_TO_RTL_HOOK rs6000_alloc_sdmode_stack_slot\n-\n-#undef TARGET_INSTANTIATE_DECLS\n-#define TARGET_INSTANTIATE_DECLS rs6000_instantiate_decls\n-\n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD rs6000_secondary_reload\n \n@@ -8628,14 +8618,6 @@ legitimate_indexed_address_p (rtx x, int strict)\n   op0 = XEXP (x, 0);\n   op1 = XEXP (x, 1);\n \n-  /* Recognize the rtl generated by reload which we know will later be\n-     replaced with proper base and index regs.  */\n-  if (!strict\n-      && reload_in_progress\n-      && (REG_P (op0) || GET_CODE (op0) == PLUS)\n-      && REG_P (op1))\n-    return true;\n-\n   return (REG_P (op0) && REG_P (op1)\n \t  && ((INT_REG_OK_FOR_BASE_P (op0, strict)\n \t       && INT_REG_OK_FOR_INDEX_P (op1, strict))\n@@ -9879,9 +9861,7 @@ rs6000_debug_legitimate_address_p (machine_mode mode, rtx x,\n \t   ret ? \"true\" : \"false\",\n \t   GET_MODE_NAME (mode),\n \t   reg_ok_strict,\n-\t   (reload_completed\n-\t    ? \"after\"\n-\t    : (reload_in_progress ? \"progress\" : \"before\")),\n+\t   (reload_completed ? \"after\" : \"before\"),\n \t   GET_RTX_NAME (GET_CODE (x)));\n   debug_rtx (x);\n \n@@ -10283,9 +10263,6 @@ rs6000_emit_set_long_const (rtx dest, HOST_WIDE_INT c)\n static void\n rs6000_eliminate_indexed_memrefs (rtx operands[2])\n {\n-  if (reload_in_progress)\n-    return;\n-\n   if (GET_CODE (operands[0]) == MEM\n       && GET_CODE (XEXP (operands[0], 0)) != REG\n       && ! legitimate_constant_pool_address_p (XEXP (operands[0], 0),\n@@ -10397,10 +10374,10 @@ rs6000_emit_le_vsx_load (rtx dest, rtx source, machine_mode mode)\n void\n rs6000_emit_le_vsx_store (rtx dest, rtx source, machine_mode mode)\n {\n-  /* This should never be called during or after reload, because it does\n+  /* This should never be called during or after LRA, because it does\n      not re-permute the source register.  It is intended only for use\n      during expand.  */\n-  gcc_assert (!reload_in_progress && !lra_in_progress && !reload_completed);\n+  gcc_assert (!lra_in_progress && !reload_completed);\n \n   /* Use V2DImode to do swaps of types with 128-bit scalar parts (TImode,\n      V1TImode).  */\n@@ -10492,8 +10469,7 @@ valid_sf_si_move (rtx dest, rtx src, machine_mode mode)\n static bool\n rs6000_emit_move_si_sf_subreg (rtx dest, rtx source, machine_mode mode)\n {\n-  if (TARGET_DIRECT_MOVE_64BIT && !reload_in_progress && !reload_completed\n-      && !lra_in_progress\n+  if (TARGET_DIRECT_MOVE_64BIT && !lra_in_progress && !reload_completed\n       && (!SUBREG_P (dest) || !sf_subreg_operand (dest, mode))\n       && SUBREG_P (source) && sf_subreg_operand (source, mode))\n     {\n@@ -10527,10 +10503,10 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n   if (TARGET_DEBUG_ADDR)\n     {\n       fprintf (stderr,\n-\t       \"\\nrs6000_emit_move: mode = %s, reload_in_progress = %d, \"\n+\t       \"\\nrs6000_emit_move: mode = %s, lra_in_progress = %d, \"\n \t       \"reload_completed = %d, can_create_pseudos = %d.\\ndest:\\n\",\n \t       GET_MODE_NAME (mode),\n-\t       reload_in_progress,\n+\t       lra_in_progress,\n \t       reload_completed,\n \t       can_create_pseudo_p ());\n       debug_rtx (dest);\n@@ -10604,12 +10580,6 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n       operands[1] = tmp;\n     }\n \n-  /* Handle the case where reload calls us with an invalid address.  */\n-  if (reload_in_progress && mode == Pmode\n-      && (! general_operand (operands[1], mode)\n-\t  || ! nonimmediate_operand (operands[0], mode)))\n-    goto emit_set;\n-\n   /* 128-bit constant floating-point values on Darwin should really be loaded\n      as two parts.  However, this premature splitting is a problem when DFmode\n      values can go into Altivec registers.  */\n@@ -10627,11 +10597,6 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n       return;\n     }\n \n-  if (reload_in_progress && cfun->machine->sdmode_stack_slot != NULL_RTX)\n-    cfun->machine->sdmode_stack_slot =\n-      eliminate_regs (cfun->machine->sdmode_stack_slot, VOIDmode, NULL_RTX);\n-\n-\n   /* Transform (p0:DD, (SUBREG:DD p1:SD)) to ((SUBREG:SD p0:DD),\n      p1:SD) if p1 is not of floating point class and p0 is spilled as\n      we can have no analogous movsd_store for this.  */\n@@ -10741,57 +10706,6 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n       return;\n     }\n \n-  if (reload_in_progress\n-      && mode == SDmode\n-      && cfun->machine->sdmode_stack_slot != NULL_RTX\n-      && MEM_P (operands[0])\n-      && rtx_equal_p (operands[0], cfun->machine->sdmode_stack_slot)\n-      && REG_P (operands[1]))\n-    {\n-      if (FP_REGNO_P (REGNO (operands[1])))\n-\t{\n-\t  rtx mem = adjust_address_nv (operands[0], DDmode, 0);\n-\t  mem = eliminate_regs (mem, VOIDmode, NULL_RTX);\n-\t  emit_insn (gen_movsd_store (mem, operands[1]));\n-\t}\n-      else if (INT_REGNO_P (REGNO (operands[1])))\n-\t{\n-\t  rtx mem = operands[0];\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    mem = adjust_address_nv (mem, mode, 4);\n-\t  mem = eliminate_regs (mem, VOIDmode, NULL_RTX);\n-\t  emit_insn (gen_movsd_hardfloat (mem, operands[1]));\n-\t}\n-      else\n-\tgcc_unreachable();\n-      return;\n-    }\n-  if (reload_in_progress\n-      && mode == SDmode\n-      && REG_P (operands[0])\n-      && MEM_P (operands[1])\n-      && cfun->machine->sdmode_stack_slot != NULL_RTX\n-      && rtx_equal_p (operands[1], cfun->machine->sdmode_stack_slot))\n-    {\n-      if (FP_REGNO_P (REGNO (operands[0])))\n-\t{\n-\t  rtx mem = adjust_address_nv (operands[1], DDmode, 0);\n-\t  mem = eliminate_regs (mem, VOIDmode, NULL_RTX);\n-\t  emit_insn (gen_movsd_load (operands[0], mem));\n-\t}\n-      else if (INT_REGNO_P (REGNO (operands[0])))\n-\t{\n-\t  rtx mem = operands[1];\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    mem = adjust_address_nv (mem, mode, 4);\n-\t  mem = eliminate_regs (mem, VOIDmode, NULL_RTX);\n-\t  emit_insn (gen_movsd_hardfloat (operands[0], mem));\n-\t}\n-      else\n-\tgcc_unreachable();\n-      return;\n-    }\n-\n   /* FIXME:  In the long term, this switch statement should go away\n      and be replaced by a sequence of tests based on things like\n      mode == Pmode.  */\n@@ -10950,10 +10864,9 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n \n \t  /* If we are to limit the number of things we put in the TOC and\n \t     this is a symbol plus a constant we can add in one insn,\n-\t     just put the symbol in the TOC and add the constant.  Don't do\n-\t     this if reload is in progress.  */\n+\t     just put the symbol in the TOC and add the constant.  */\n \t  if (GET_CODE (operands[1]) == CONST\n-\t      && TARGET_NO_SUM_IN_TOC && ! reload_in_progress\n+\t      && TARGET_NO_SUM_IN_TOC\n \t      && GET_CODE (XEXP (operands[1], 0)) == PLUS\n \t      && add_operand (XEXP (XEXP (operands[1], 0), 1), mode)\n \t      && (GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF\n@@ -10999,10 +10912,9 @@ rs6000_emit_move (rtx dest, rtx source, machine_mode mode)\n   /* Above, we may have called force_const_mem which may have returned\n      an invalid address.  If we can, fix this up; otherwise, reload will\n      have to deal with it.  */\n-  if (GET_CODE (operands[1]) == MEM && ! reload_in_progress)\n+  if (GET_CODE (operands[1]) == MEM)\n     operands[1] = validize_mem (operands[1]);\n \n- emit_set:\n   emit_insn (gen_rtx_SET (operands[0], operands[1]));\n }\n \f\n@@ -19195,42 +19107,6 @@ mems_ok_for_quad_peep (rtx mem1, rtx mem2)\n   return 1;\n }\n \f\n-\n-rtx\n-rs6000_secondary_memory_needed_rtx (machine_mode mode)\n-{\n-  static bool eliminated = false;\n-  rtx ret;\n-\n-  if (mode != SDmode || TARGET_NO_SDMODE_STACK)\n-    ret = assign_stack_local (mode, GET_MODE_SIZE (mode), 0);\n-  else\n-    {\n-      rtx mem = cfun->machine->sdmode_stack_slot;\n-      gcc_assert (mem != NULL_RTX);\n-\n-      if (!eliminated)\n-\t{\n-\t  mem = eliminate_regs (mem, VOIDmode, NULL_RTX);\n-\t  cfun->machine->sdmode_stack_slot = mem;\n-\t  eliminated = true;\n-\t}\n-      ret = mem;\n-    }\n-\n-  if (TARGET_DEBUG_ADDR)\n-    {\n-      fprintf (stderr, \"\\nrs6000_secondary_memory_needed_rtx, mode %s, rtx:\\n\",\n-\t       GET_MODE_NAME (mode));\n-      if (!ret)\n-\tfprintf (stderr, \"\\tNULL_RTX\\n\");\n-      else\n-\tdebug_rtx (ret);\n-    }\n-\n-  return ret;\n-}\n-\n /* Return the mode to be used for memory when a secondary memory\n    location is needed.  For SDmode values we need to use DDmode, in\n    all other cases we can use the same mode.  */\n@@ -19242,36 +19118,6 @@ rs6000_secondary_memory_needed_mode (machine_mode mode)\n   return mode;\n }\n \n-static tree\n-rs6000_check_sdmode (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n-{\n-  /* Don't walk into types.  */\n-  if (*tp == NULL_TREE || *tp == error_mark_node || TYPE_P (*tp))\n-    {\n-      *walk_subtrees = 0;\n-      return NULL_TREE;\n-    }\n-\n-  switch (TREE_CODE (*tp))\n-    {\n-    case VAR_DECL:\n-    case PARM_DECL:\n-    case FIELD_DECL:\n-    case RESULT_DECL:\n-    case SSA_NAME:\n-    case REAL_CST:\n-    case MEM_REF:\n-    case VIEW_CONVERT_EXPR:\n-      if (TYPE_MODE (TREE_TYPE (*tp)) == SDmode)\n-\treturn *tp;\n-      break;\n-    default:\n-      break;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n /* Classify a register type.  Because the FMRGOW/FMRGEW instructions only work\n    on traditional floating point registers, and the VMRGOW/VMRGEW instructions\n    only work on the traditional altivec registers, note if an altivec register\n@@ -19292,7 +19138,7 @@ register_to_reg_type (rtx reg, bool *is_altivec)\n   regno = REGNO (reg);\n   if (regno >= FIRST_PSEUDO_REGISTER)\n     {\n-      if (!lra_in_progress && !reload_in_progress && !reload_completed)\n+      if (!lra_in_progress && !reload_completed)\n \treturn PSEUDO_REG_TYPE;\n \n       regno = true_regnum (reg);\n@@ -20369,64 +20215,6 @@ rs6000_secondary_reload_gpr (rtx reg, rtx mem, rtx scratch, bool store_p)\n   return;\n }\n \n-/* Allocate a 64-bit stack slot to be used for copying SDmode values through if\n-   this function has any SDmode references.  If we are on a power7 or later, we\n-   don't need the 64-bit stack slot since the LFIWZX and STIFWX instructions\n-   can load/store the value.  */\n-\n-static void\n-rs6000_alloc_sdmode_stack_slot (void)\n-{\n-  tree t;\n-  basic_block bb;\n-  gimple_stmt_iterator gsi;\n-\n-  gcc_assert (cfun->machine->sdmode_stack_slot == NULL_RTX);\n-  /* We use a different approach for dealing with the secondary\n-     memory in LRA.  */\n-  if (ira_use_lra_p)\n-    return;\n-\n-  if (TARGET_NO_SDMODE_STACK)\n-    return;\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-      {\n-\ttree ret = walk_gimple_op (gsi_stmt (gsi), rs6000_check_sdmode, NULL);\n-\tif (ret)\n-\t  {\n-\t    rtx stack = assign_stack_local (DDmode, GET_MODE_SIZE (DDmode), 0);\n-\t    cfun->machine->sdmode_stack_slot = adjust_address_nv (stack,\n-\t\t\t\t\t\t\t\t  SDmode, 0);\n-\t    return;\n-\t  }\n-      }\n-\n-  /* Check for any SDmode parameters of the function.  */\n-  for (t = DECL_ARGUMENTS (cfun->decl); t; t = DECL_CHAIN (t))\n-    {\n-      if (TREE_TYPE (t) == error_mark_node)\n-\tcontinue;\n-\n-      if (TYPE_MODE (TREE_TYPE (t)) == SDmode\n-\t  || TYPE_MODE (DECL_ARG_TYPE (t)) == SDmode)\n-\t{\n-\t  rtx stack = assign_stack_local (DDmode, GET_MODE_SIZE (DDmode), 0);\n-\t  cfun->machine->sdmode_stack_slot = adjust_address_nv (stack,\n-\t\t\t\t\t\t\t\tSDmode, 0);\n-\t  return;\n-\t}\n-    }\n-}\n-\n-static void\n-rs6000_instantiate_decls (void)\n-{\n-  if (cfun->machine->sdmode_stack_slot != NULL_RTX)\n-    instantiate_decl_rtl (cfun->machine->sdmode_stack_slot);\n-}\n-\n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n    In general this is just CLASS; but on some machines\n@@ -23454,10 +23242,9 @@ static rtx\n rs6000_pre_atomic_barrier (rtx mem, enum memmodel model)\n {\n   rtx addr = XEXP (mem, 0);\n-  int strict_p = (reload_in_progress || reload_completed);\n \n-  if (!legitimate_indirect_address_p (addr, strict_p)\n-      && !legitimate_indexed_address_p (addr, strict_p))\n+  if (!legitimate_indirect_address_p (addr, reload_completed)\n+      && !legitimate_indexed_address_p (addr, reload_completed))\n     {\n       addr = force_reg (Pmode, addr);\n       mem = replace_equiv_address_nv (mem, addr);\n@@ -33184,7 +32971,7 @@ rs6000_machopic_legitimize_pic_address (rtx orig, machine_mode mode,\n {\n   rtx base, offset;\n \n-  if (reg == NULL && ! reload_in_progress && ! reload_completed)\n+  if (reg == NULL && !reload_completed)\n     reg = gen_reg_rtx (Pmode);\n \n   if (GET_CODE (orig) == CONST)\n@@ -33210,7 +32997,7 @@ rs6000_machopic_legitimize_pic_address (rtx orig, machine_mode mode,\n \t{\n \t  if (SMALL_INT (offset))\n \t    return plus_constant (Pmode, base, INTVAL (offset));\n-\t  else if (! reload_in_progress && ! reload_completed)\n+\t  else if (!reload_completed)\n \t    offset = force_reg (Pmode, offset);\n \t  else\n \t    {\n@@ -37459,7 +37246,7 @@ rs6000_allocate_stack_temp (machine_mode mode,\n {\n   rtx stack = assign_stack_temp (mode, GET_MODE_SIZE (mode));\n   rtx addr = XEXP (stack, 0);\n-  int strict_p = (reload_in_progress || reload_completed);\n+  int strict_p = reload_completed;\n \n   if (!legitimate_indirect_address_p (addr, strict_p))\n     {\n@@ -37481,13 +37268,12 @@ rs6000_allocate_stack_temp (machine_mode mode,\n rtx\n rs6000_address_for_fpconvert (rtx x)\n {\n-  int strict_p = (reload_in_progress || reload_completed);\n   rtx addr;\n \n   gcc_assert (MEM_P (x));\n   addr = XEXP (x, 0);\n-  if (! legitimate_indirect_address_p (addr, strict_p)\n-      && ! legitimate_indexed_address_p (addr, strict_p))\n+  if (! legitimate_indirect_address_p (addr, reload_completed)\n+      && ! legitimate_indexed_address_p (addr, reload_completed))\n     {\n       if (GET_CODE (addr) == PRE_INC || GET_CODE (addr) == PRE_DEC)\n \t{\n@@ -37525,10 +37311,9 @@ rs6000_address_for_altivec (rtx x)\n   if (!altivec_indexed_or_indirect_operand (x, GET_MODE (x)))\n     {\n       rtx addr = XEXP (x, 0);\n-      int strict_p = (reload_in_progress || reload_completed);\n \n-      if (!legitimate_indexed_address_p (addr, strict_p)\n-\t  && !legitimate_indirect_address_p (addr, strict_p))\n+      if (!legitimate_indexed_address_p (addr, reload_completed)\n+\t  && !legitimate_indirect_address_p (addr, reload_completed))\n \taddr = copy_to_mode_reg (Pmode, addr);\n \n       addr = gen_rtx_AND (Pmode, addr, GEN_INT (-16));"}, {"sha": "82a0bda48c68a4777e2282cf84a8aadd050bac60", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6", "patch": "@@ -1583,13 +1583,6 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n #define SECONDARY_MEMORY_NEEDED(CLASS1,CLASS2,MODE)\t\t\t\\\n   rs6000_secondary_memory_needed_ptr (CLASS1, CLASS2, MODE)\n \n-/* For cpus that cannot load/store SDmode values from the 64-bit\n-   FP registers without using a full 64-bit load/store, we need\n-   to allocate a full 64-bit stack slot for them.  */\n-\n-#define SECONDARY_MEMORY_NEEDED_RTX(MODE) \\\n-  rs6000_secondary_memory_needed_rtx (MODE)\n-\n /* Specify the mode to be used for memory when a secondary memory\n    location is needed.  For cpus that cannot load/store SDmode values\n    from the 64-bit FP registers without using a full 64-bit"}, {"sha": "6985b9f82da0dcae87387a9c70210c0a128718a3", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6", "patch": "@@ -6672,7 +6672,7 @@\n \t\t   UNSPEC_MOVSI_GOT))]\n   \"DEFAULT_ABI == ABI_V4\n     && flag_pic == 1\n-    && (reload_in_progress || reload_completed)\"\n+    && reload_completed\"\n   [(set (match_dup 0) (match_dup 2))\n    (set (match_dup 0) (unspec:SI [(match_dup 1)(match_dup 0)]\n \t\t\t\t UNSPEC_MOVSI_GOT))]\n@@ -8225,7 +8225,7 @@\n \t(and:P (plus:P (match_operand:P 1 \"gpc_reg_operand\" \"r\")\n \t\t       (match_operand:P 2 \"reg_or_cint_operand\" \"rI\"))\n \t       (const_int -16)))]\n-  \"TARGET_ALTIVEC && (reload_in_progress || reload_completed)\"\n+  \"TARGET_ALTIVEC && reload_completed\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0)"}, {"sha": "2937499c4a633bd5c86c001f576dfd2d2ea8a6d3", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=3cb8ee5cd6b72ceb87b89cacb9bcb169a7b34dd6", "patch": "@@ -1201,7 +1201,7 @@\n                      UNSPEC_VSX_MULSD))]\n   \"VECTOR_MEM_VSX_P (V2DImode)\"\n   \"#\"\n-  \"VECTOR_MEM_VSX_P (V2DImode) && !reload_completed && !reload_in_progress\"\n+  \"VECTOR_MEM_VSX_P (V2DImode) && !reload_completed\"\n   [(const_int 0)]\n   \"\n {\n@@ -1239,7 +1239,7 @@\n                      UNSPEC_VSX_DIVSD))]\n   \"VECTOR_MEM_VSX_P (V2DImode)\"\n   \"#\"\n-  \"VECTOR_MEM_VSX_P (V2DImode) && !reload_completed && !reload_in_progress\"\n+  \"VECTOR_MEM_VSX_P (V2DImode) && !reload_completed\"\n   [(const_int 0)]\n   \"\n {\n@@ -1267,7 +1267,7 @@\n                      UNSPEC_VSX_DIVUD))]\n   \"VECTOR_MEM_VSX_P (V2DImode)\"\n   \"#\"\n-  \"VECTOR_MEM_VSX_P (V2DImode) && !reload_completed && !reload_in_progress\"\n+  \"VECTOR_MEM_VSX_P (V2DImode) && !reload_completed\"\n   [(const_int 0)]\n   \"\n {"}]}