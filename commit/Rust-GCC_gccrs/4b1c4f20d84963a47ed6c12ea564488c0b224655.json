{"sha": "4b1c4f20d84963a47ed6c12ea564488c0b224655", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIxYzRmMjBkODQ5NjNhNDdlZDZjMTJlYTU2NDQ4OGMwYjIyNDY1NQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2012-10-02T08:37:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-02T08:37:54Z"}, "message": "checks.adb (Apply_Arithmetic_Overflow_Checked_Suppressed): New name for Apply_Arithmetic_Overflow_Normal\n\n2012-10-02  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb (Apply_Arithmetic_Overflow_Checked_Suppressed):\n\tNew name for Apply_Arithmetic_Overflow_Normal\n\t(Apply_Arithmetic_Overflow_Minimized_Eliminated):\n\tAdd handling for conditional expressions\n\t(Is_Signed_Integer_Arithmetic_Op): Now includes conditional\n\texpressions (Minimize_Eliminate_Overflow_Checks): Handle\n\tconditional expressions.\n\t* checks.ads: Minor comment fixes.\n\t* exp_ch4.adb (Expand_N_Case_Expression): Call\n\tApply_Arithmetic_Overflow_Check (Expand_N_Conditional_Expression):\n\tCall Apply_Arithmetic_Overflow_Check\n\t* s-bignum.adb (Normalize): Remove incorrect precondition.\n\t* sem_res.adb (Resolve_Case_Expression): Set Do_Overflow_Check\n\tflag (Resolve_Conditional_Expression): Set Do_Overflow_Check flag.\n\t* sinfo.adb: Add Do_Overflow_Check for conditional expressions.\n\t* sinfo.ads: Minor documentation updates.\n\nFrom-SVN: r191964", "tree": {"sha": "9ee7a8d8942978c3fbfd7342cd658d7e849ae9d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ee7a8d8942978c3fbfd7342cd658d7e849ae9d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b1c4f20d84963a47ed6c12ea564488c0b224655", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b1c4f20d84963a47ed6c12ea564488c0b224655", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b1c4f20d84963a47ed6c12ea564488c0b224655", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b1c4f20d84963a47ed6c12ea564488c0b224655/comments", "author": null, "committer": null, "parents": [{"sha": "2492305bcc43dbc13678f1d6113e76b735dba432", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2492305bcc43dbc13678f1d6113e76b735dba432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2492305bcc43dbc13678f1d6113e76b735dba432"}], "stats": {"total": 536, "additions": 400, "deletions": 136}, "files": [{"sha": "8dd037ffba443b74545c5b62e377c4811c1c6c27", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b1c4f20d84963a47ed6c12ea564488c0b224655/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b1c4f20d84963a47ed6c12ea564488c0b224655/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4b1c4f20d84963a47ed6c12ea564488c0b224655", "patch": "@@ -1,3 +1,22 @@\n+2012-10-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb (Apply_Arithmetic_Overflow_Checked_Suppressed):\n+\tNew name for Apply_Arithmetic_Overflow_Normal\n+\t(Apply_Arithmetic_Overflow_Minimized_Eliminated):\n+\tAdd handling for conditional expressions\n+\t(Is_Signed_Integer_Arithmetic_Op): Now includes conditional\n+\texpressions (Minimize_Eliminate_Overflow_Checks): Handle\n+\tconditional expressions.\n+\t* checks.ads: Minor comment fixes.\n+\t* exp_ch4.adb (Expand_N_Case_Expression): Call\n+\tApply_Arithmetic_Overflow_Check (Expand_N_Conditional_Expression):\n+\tCall Apply_Arithmetic_Overflow_Check\n+\t* s-bignum.adb (Normalize): Remove incorrect precondition.\n+\t* sem_res.adb (Resolve_Case_Expression): Set Do_Overflow_Check\n+\tflag (Resolve_Conditional_Expression): Set Do_Overflow_Check flag.\n+\t* sinfo.adb: Add Do_Overflow_Check for conditional expressions.\n+\t* sinfo.ads: Minor documentation updates.\n+\n 2012-10-02  Ed Schonberg  <schonberg@adacore.com>\n \n \t* exp_ch4.adb (Expand_N_Case_Expression): Do not introduce"}, {"sha": "da2029288d9d7328cb1d488d337d028cb2576893", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 232, "deletions": 32, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b1c4f20d84963a47ed6c12ea564488c0b224655/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b1c4f20d84963a47ed6c12ea564488c0b224655/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=4b1c4f20d84963a47ed6c12ea564488c0b224655", "patch": "@@ -193,15 +193,17 @@ package body Checks is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Apply_Arithmetic_Overflow_Normal (N : Node_Id);\n+   procedure Apply_Arithmetic_Overflow_Checked_Suppressed (N : Node_Id);\n    --  Used to apply arithmetic overflow checks for all cases except operators\n    --  on signed arithmetic types in Minimized/Eliminate case (for which we\n-   --  call Apply_Arithmetic_Overflow_Minimized_Eliminated below).\n+   --  call Apply_Arithmetic_Overflow_Minimized_Eliminated below). N is always\n+   --  a signed integer arithmetic operator (conditional expression excluded).\n \n    procedure Apply_Arithmetic_Overflow_Minimized_Eliminated (Op : Node_Id);\n    --  Used to apply arithmetic overflow checks for the case where the overflow\n    --  checking mode is Minimized or Eliminated (and the Do_Overflow_Check flag\n-   --  is known to be set) and we have an signed integer arithmetic op.\n+   --  is known to be set) and we have an signed integer arithmetic op (which\n+   --  includes the case of conditional expressions).\n \n    procedure Apply_Division_Check\n      (N   : Node_Id;\n@@ -311,8 +313,10 @@ package body Checks is\n \n    function Is_Signed_Integer_Arithmetic_Op (N : Node_Id) return Boolean;\n    --  Returns True if node N is for an arithmetic operation with signed\n-   --  integer operands. This is the kind of node for which special handling\n-   --  applies in MINIMIZED or EXTENDED overflow checking mode.\n+   --  integer operands. This includes unary and binary operators, and also\n+   --  if and case expression nodes where the dependent expressions are of\n+   --  a signed integer type. These are the kinds of nodes for which special\n+   --  handling applies in MINIMIZED or EXTENDED overflow checking mode.\n \n    function Range_Or_Validity_Checks_Suppressed\n      (Expr : Node_Id) return Boolean;\n@@ -767,7 +771,7 @@ package body Checks is\n         or else not Do_Overflow_Check (N)\n         or else not Is_Signed_Integer_Arithmetic_Op (N)\n       then\n-         Apply_Arithmetic_Overflow_Normal (N);\n+         Apply_Arithmetic_Overflow_Checked_Suppressed (N);\n \n       --  Otherwise use the new routine for Minimized/Eliminated modes for\n       --  the case of a signed integer arithmetic op, with Do_Overflow_Check\n@@ -778,9 +782,9 @@ package body Checks is\n       end if;\n    end Apply_Arithmetic_Overflow_Check;\n \n-   --------------------------------------\n-   -- Apply_Arithmetic_Overflow_Normal --\n-   --------------------------------------\n+   --------------------------------------------------\n+   -- Apply_Arithmetic_Overflow_Checked_Suppressed --\n+   --------------------------------------------------\n \n    --  This routine is called only if the type is an integer type, and a\n    --  software arithmetic overflow check may be needed for op (add, subtract,\n@@ -798,7 +802,7 @@ package body Checks is\n    --  Note: we also call this routine if we decide in the MINIMIZED case\n    --  to give up and just generate an overflow check without any fuss.\n \n-   procedure Apply_Arithmetic_Overflow_Normal (N : Node_Id) is\n+   procedure Apply_Arithmetic_Overflow_Checked_Suppressed (N : Node_Id) is\n       Loc   : constant Source_Ptr := Sloc (N);\n       Typ   : constant Entity_Id  := Etype (N);\n       Rtyp  : constant Entity_Id  := Root_Type (Typ);\n@@ -1061,7 +1065,7 @@ package body Checks is\n          when RE_Not_Available =>\n             return;\n       end;\n-   end Apply_Arithmetic_Overflow_Normal;\n+   end Apply_Arithmetic_Overflow_Checked_Suppressed;\n \n    ----------------------------------------------------\n    -- Apply_Arithmetic_Overflow_Minimized_Eliminated --\n@@ -1081,7 +1085,7 @@ package body Checks is\n       --  Original result type\n \n       Check_Mode : constant Overflow_Check_Type :=\n-        Overflow_Check_Mode (Etype (Op));\n+                     Overflow_Check_Mode (Etype (Op));\n       pragma Assert (Check_Mode in Minimized_Or_Eliminated);\n \n       Lo, Hi : Uint;\n@@ -1090,7 +1094,7 @@ package body Checks is\n    begin\n       --  Nothing to do if our parent is one of the following:\n \n-      --    Another signed integer arithmetic operation\n+      --    Another signed integer arithmetic op\n       --    A membership operation\n       --    A comparison operation\n \n@@ -1111,7 +1115,7 @@ package body Checks is\n          return;\n       end if;\n \n-      --  Otherwise, we have a top level arithmetic operator node, and this\n+      --  Otherwise, we have a top level arithmetic operation node, and this\n       --  is where we commence the special processing for minimize/eliminate.\n       --  This is the case where we tell the machinery not to move into Bignum\n       --  mode at this top level (of course the top level operation will still\n@@ -3799,7 +3803,7 @@ package body Checks is\n       Loc : constant Source_Ptr := Sloc (N);\n \n    begin\n-      --  Nothing to do if Bignum already\n+      --  Nothing to do if Bignum already except call Relocate_Node\n \n       if Is_RTE (Etype (N), RE_Bignum) then\n          return Relocate_Node (N);\n@@ -6254,6 +6258,13 @@ package body Checks is\n               N_Op_Rem   | N_Op_Subtract =>\n             return Is_Signed_Integer_Type (Etype (N));\n \n+         when N_Conditional_Expression |\n+              N_Case_Expression        =>\n+            return Is_Signed_Integer_Type (Etype (N));\n+\n+         when N_Case_Expression_Alternative =>\n+            return Is_Signed_Integer_Type (Etype (Parent (N)));\n+\n          when others =>\n             return False;\n       end case;\n@@ -6677,23 +6688,26 @@ package body Checks is\n       Hi        : out Uint;\n       Top_Level : Boolean)\n    is\n-      pragma Assert (Is_Signed_Integer_Type (Etype (N)));\n+      Rtyp : constant Entity_Id := Etype (N);\n+      pragma Assert (Is_Signed_Integer_Type (Rtyp));\n+      --  Result type, must be a signed integer type\n \n       Check_Mode : constant Overflow_Check_Type := Overflow_Check_Mode (Empty);\n       pragma Assert (Check_Mode in Minimized_Or_Eliminated);\n \n       Loc : constant Source_Ptr := Sloc (N);\n \n       Rlo, Rhi : Uint;\n-      --  Ranges of values for right operand\n+      --  Ranges of values for right operand (operator case)\n \n       Llo, Lhi : Uint;\n-      --  Ranges of values for left operand\n+      --  Ranges of values for left operand (operator case)\n \n       LLIB : constant Entity_Id := Base_Type (Standard_Long_Long_Integer);\n       --  Operands and results are of this type when we convert\n \n-      LLLo, LLHi : Uint;\n+      LLLo : constant Uint := Intval (Type_Low_Bound  (LLIB));\n+      LLHi : constant Uint := Intval (Type_High_Bound (LLIB));\n       --  Bounds of Long_Long_Integer\n \n       Binary : constant Boolean := Nkind (N) in N_Binary_Op;\n@@ -6705,14 +6719,41 @@ package body Checks is\n       Bignum_Operands : Boolean;\n       --  Set True if one or more operands is already of type Bignum, meaning\n       --  that for sure (regardless of Top_Level setting) we are committed to\n-      --  doing the operation in Bignum mode.\n+      --  doing the operation in Bignum mode (or in the case of a case or if\n+      --  expression, converting all the dependent expressions to bignum).\n+\n+      Long_Long_Integer_Operands : Boolean;\n+      --  Set True if one r more operands is already of type Long_Loong_Integer\n+      --  which means that if the result is known to be in the result type\n+      --  range, then we must convert such operands back to the result type.\n+      --  This switch is properly set only when Bignum_Operands is False.\n+\n+      function In_Result_Range return Boolean;\n+      --  Returns True iff Lo .. Hi are within range of the result type\n \n       procedure Max (A : in out Uint; B : Uint);\n       --  If A is No_Uint, sets A to B, else to UI_Max (A, B);\n \n       procedure Min (A : in out Uint; B : Uint);\n       --  If A is No_Uint, sets A to B, else to UI_Min (A, B);\n \n+      ---------------------\n+      -- In_Result_Range --\n+      ---------------------\n+\n+      function In_Result_Range return Boolean is\n+      begin\n+         if Is_Static_Subtype (Etype (N)) then\n+            return Lo >= Expr_Value (Type_Low_Bound  (Rtyp))\n+                     and then\n+                   Hi <= Expr_Value (Type_High_Bound (Rtyp));\n+         else\n+            return Lo >= Expr_Value (Type_Low_Bound  (Base_Type (Rtyp)))\n+                     and then\n+                   Hi <= Expr_Value (Type_High_Bound (Base_Type (Rtyp)));\n+         end if;\n+      end In_Result_Range;\n+\n       ---------\n       -- Max --\n       ---------\n@@ -6738,7 +6779,7 @@ package body Checks is\n    --  Start of processing for Minimize_Eliminate_Overflow_Checks\n \n    begin\n-      --  Case where we do not have an arithmetic operator\n+      --  Case where we do not have a signed integer arithmetic operation\n \n       if not Is_Signed_Integer_Arithmetic_Op (N) then\n \n@@ -6762,18 +6803,168 @@ package body Checks is\n \n          return;\n \n-      --  If we have an arithmetic oeprator we make recursive calls on the\n+      --  Processing for if expression\n+\n+      elsif Nkind (N) = N_Conditional_Expression then\n+         declare\n+            Then_DE : constant Node_Id := Next (First (Expressions (N)));\n+            Else_DE : constant Node_Id := Next (Then_DE);\n+\n+         begin\n+            Bignum_Operands := False;\n+\n+            Minimize_Eliminate_Overflow_Checks\n+              (Then_DE, Lo, Hi, Top_Level => False);\n+\n+            if Lo = No_Uint then\n+               Bignum_Operands := True;\n+            end if;\n+\n+            Minimize_Eliminate_Overflow_Checks\n+              (Else_DE, Rlo, Rhi, Top_Level => False);\n+\n+            if Rlo = No_Uint then\n+               Bignum_Operands := True;\n+            else\n+               Long_Long_Integer_Operands :=\n+                 Etype (Then_DE) = LLIB or else Etype (Else_DE) = LLIB;\n+\n+               Min (Lo, Rlo);\n+               Max (Hi, Rhi);\n+            end if;\n+\n+            --  If at least one of our operands is now bignum, we must rebuild\n+            --  the if expression to use bignum operands. We will analyze the\n+            --  rebuilt if expression with overflow checks off, since once we\n+            --  are in bignum mode, we are all done with overflow checks!\n+\n+            if Bignum_Operands then\n+               Rewrite (N,\n+                 Make_Conditional_Expression (Loc,\n+                   Expressions => New_List (\n+                     Remove_Head (Expressions (N)),\n+                     Convert_To_Bignum (Then_DE),\n+                     Convert_To_Bignum (Else_DE)),\n+                   Is_Elsif    => Is_Elsif (N)));\n+\n+               Analyze_And_Resolve\n+                 (N, RTE (RE_Bignum), Suppress => Overflow_Check);\n+\n+            --  If we have no Long_Long_Integer operands, then we are in result\n+            --  range, since it means that none of our operands felt the need\n+            --  to worry about overflow (otherwise it would have already been\n+            --  converted to long long integer or bignum).\n+\n+            elsif not Long_Long_Integer_Operands then\n+               Set_Do_Overflow_Check (N, False);\n+\n+            --  Otherwise convert us to long long integer mode. Note that we\n+            --  don't need any further overflow checking at this level.\n+\n+            else\n+               Convert_To_And_Rewrite (LLIB, Then_DE);\n+               Convert_To_And_Rewrite (LLIB, Else_DE);\n+               Set_Etype (N, LLIB);\n+               Set_Do_Overflow_Check (N, False);\n+            end if;\n+         end;\n+\n+         return;\n+\n+      --  Here for case expression\n+\n+      elsif Nkind (N) = N_Case_Expression then\n+         Bignum_Operands := False;\n+         Long_Long_Integer_Operands := False;\n+         Lo := No_Uint;\n+         Hi := No_Uint;\n+\n+         declare\n+            Alt      : Node_Id;\n+            New_Alts : List_Id;\n+            New_Exp  : Node_Id;\n+            Rtype    : Entity_Id;\n+\n+         begin\n+            --  Loop through expressions applying recursive call\n+\n+            Alt := First (Alternatives (N));\n+            while Present (Alt) loop\n+               declare\n+                  Aexp : constant Node_Id := Expression (Alt);\n+\n+               begin\n+                  Minimize_Eliminate_Overflow_Checks\n+                    (Aexp, Lo, Hi, Top_Level => False);\n+\n+                  if Lo = No_Uint then\n+                     Bignum_Operands := True;\n+                  elsif Etype (Aexp) = LLIB then\n+                     Long_Long_Integer_Operands := True;\n+                  end if;\n+               end;\n+\n+               Next (Alt);\n+            end loop;\n+\n+            --  If we have no bignum or long long integer operands, it means\n+            --  that none of our dependent expressions could raise overflow.\n+            --  In this case, we simply return with no changes except for\n+            --  resetting the overflow flag, since we are done with overflow\n+            --  checks for this node. We will reset the Analyzed flag so that\n+            --  we will properly reexpand and get the needed expansion for\n+            --  the case expression.\n+\n+            if not (Bignum_Operands or else Long_Long_Integer_Operands) then\n+               Set_Do_Overflow_Check (N, False);\n+               Set_Analyzed (N, False);\n+\n+            --  Otherwise we are going to rebuild the case expression using\n+            --  either bignum or long long integer operands throughout.\n+\n+            else\n+               New_Alts := New_List;\n+               Alt := First (Alternatives (N));\n+               while Present (Alt) loop\n+                  if Bignum_Operands then\n+                     New_Exp := Convert_To_Bignum (Expression (Alt));\n+                     Rtype   := RTE (RE_Bignum);\n+                  else\n+                     New_Exp := Convert_To (LLIB, Expression (Alt));\n+                     Rtype   := LLIB;\n+                  end if;\n+\n+                  Append_To (New_Alts,\n+                    Make_Case_Expression_Alternative (Sloc (Alt),\n+                      Actions          => No_List,\n+                      Discrete_Choices => Discrete_Choices (Alt),\n+                      Expression       => New_Exp));\n+\n+                  Next (Alt);\n+               end loop;\n+\n+               Rewrite (N,\n+                 Make_Case_Expression (Loc,\n+                   Expression   => Expression (N),\n+                   Alternatives => New_Alts));\n+\n+               Analyze_And_Resolve (N, Rtype, Suppress => Overflow_Check);\n+            end if;\n+         end;\n+\n+         return;\n+      end if;\n+\n+      --  If we have an arithmetic operator we make recursive calls on the\n       --  operands to get the ranges (and to properly process the subtree\n       --  that lies below us!)\n \n-      else\n-         Minimize_Eliminate_Overflow_Checks\n-           (Right_Opnd (N), Rlo, Rhi, Top_Level => False);\n+      Minimize_Eliminate_Overflow_Checks\n+        (Right_Opnd (N), Rlo, Rhi, Top_Level => False);\n \n-         if Binary then\n-            Minimize_Eliminate_Overflow_Checks\n-              (Left_Opnd (N), Llo, Lhi, Top_Level => False);\n-         end if;\n+      if Binary then\n+         Minimize_Eliminate_Overflow_Checks\n+           (Left_Opnd (N), Llo, Lhi, Top_Level => False);\n       end if;\n \n       --  If either operand is a bignum, then result will be a bignum\n@@ -6788,6 +6979,10 @@ package body Checks is\n       else\n          Bignum_Operands := False;\n \n+         Long_Long_Integer_Operands :=\n+           Etype (Right_Opnd (N)) = LLIB\n+             or else (Binary and then Etype (Left_Opnd (N)) = LLIB);\n+\n          case Nkind (N) is\n \n             --  Absolute value\n@@ -7136,9 +7331,6 @@ package body Checks is\n       --  0 .. 1, but the cases are rare and it is not worth the effort.\n       --  Failing to do this switching back is only an efficiency issue.\n \n-      LLLo := Intval (Type_Low_Bound  (LLIB));\n-      LLHi := Intval (Type_High_Bound (LLIB));\n-\n       if Lo = No_Uint or else Lo < LLLo or else Hi > LLHi then\n \n          --  OK, we are definitely outside the range of Long_Long_Integer. The\n@@ -7248,6 +7440,14 @@ package body Checks is\n          Set_Do_Overflow_Check (N, False);\n       end if;\n \n+      --  If Result is in range of the result type, and we don't have any\n+      --  Long_Long_Integer operands, then overflow checking is not needed\n+      --  and we have nothing to do (we have already reset Do_Overflow_Check).\n+\n+      if In_Result_Range and not Long_Long_Integer_Operands then\n+         return;\n+      end if;\n+\n       --  Here we will do the operation in Long_Long_Integer. We do this even\n       --  if we know an overflow check is required, better to do this in long\n       --  long integer mode, since we are less likely to overflow!"}, {"sha": "29a65f6e32136285c3f29548d445a222a53e8038", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b1c4f20d84963a47ed6c12ea564488c0b224655/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b1c4f20d84963a47ed6c12ea564488c0b224655/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=4b1c4f20d84963a47ed6c12ea564488c0b224655", "patch": "@@ -135,13 +135,14 @@ package Checks is\n    --  larger than the overlaid object.\n \n    procedure Apply_Arithmetic_Overflow_Check (N : Node_Id);\n-   --  Given a binary arithmetic operator (+ - *) expand a software integer\n-   --  overflow check using range checks on a larger checking type or a call\n-   --  to an appropriate runtime routine. This is used for all three operators\n-   --  for the signed integer case, and for +/- in the fixed-point case. The\n-   --  check is expanded only if Software_Overflow_Checking is enabled and\n-   --  Do_Overflow_Check is set on node N. Note that divide is handled\n-   --  separately using Apply_Arithmetic_Divide_Overflow_Check.\n+   --  Handle overflow checking for an arithmetic operator. Also handles the\n+   --  cases of ELIMINATED and MINIMIZED overflow checking mode. If the mode\n+   --  is one of the latter two, then this routine can also be called with\n+   --  a conditional expression node to make sure that we properly handle\n+   --  overflow checking for dependent expressions. This routine handles\n+   --  front end vs back end overflow checks (in the front end case it expands\n+   --  the necessary check). Note that divide is handled separately using\n+   --  Apply_Arithmetic_Divide_Overflow_Check.\n \n    procedure Apply_Constraint_Check\n      (N          : Node_Id;"}, {"sha": "560d1759ef8bddf6367e536afa53a1db7b271ea6", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b1c4f20d84963a47ed6c12ea564488c0b224655/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b1c4f20d84963a47ed6c12ea564488c0b224655/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=4b1c4f20d84963a47ed6c12ea564488c0b224655", "patch": "@@ -4776,6 +4776,18 @@ package body Exp_Ch4 is\n       Fexp    : Node_Id;\n \n    begin\n+      --  If Do_Overflow_Check is set, it means we are in MINIMIZED/ELIMINATED\n+      --  mode, and all we do is to call Apply_Arithmetic_Overflow_Check to\n+      --  ensure proper overflow handling for the dependent expressions. The\n+      --  checks circuitry will rewrite the case expression in this case with\n+      --  Do_Overflow_Checks off. so that when that rewritten node arrives back\n+      --  here, then we will do the full expansion.\n+\n+      if Do_Overflow_Check (N) then\n+         Apply_Arithmetic_Overflow_Check (N);\n+         return;\n+      end if;\n+\n       --  We expand\n \n       --    case X is when A => AX, when B => BX ...\n@@ -5204,6 +5216,15 @@ package body Exp_Ch4 is\n          --  the same approach as a C conditional expression.\n \n       else\n+         --  If Do_Overflow_Check is set it means we have a signed intger type\n+         --  in MINIMIZED or ELIMINATED mode, so we apply an overflow check to\n+         --  the if expression (to make sure that overflow checking is properly\n+         --  handled for dependent expressions).\n+\n+         if Do_Overflow_Check (N) then\n+            Apply_Arithmetic_Overflow_Check (N);\n+         end if;\n+\n          return;\n       end if;\n "}, {"sha": "39cae8a8659a14f2be932d74d1d518816225897f", "filename": "gcc/ada/s-bignum.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b1c4f20d84963a47ed6c12ea564488c0b224655/gcc%2Fada%2Fs-bignum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b1c4f20d84963a47ed6c12ea564488c0b224655/gcc%2Fada%2Fs-bignum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bignum.adb?ref=4b1c4f20d84963a47ed6c12ea564488c0b224655", "patch": "@@ -104,8 +104,7 @@ package body System.Bignums is\n \n    function Normalize\n      (X   : Digit_Vector;\n-      Neg : Boolean := False) return Bignum\n-   with Pre  => X'First = 1;\n+      Neg : Boolean := False) return Bignum;\n    --  Given a digit vector and sign, allocate and construct a Bignum value.\n    --  Note that X may have leading zeroes which must be removed, and if the\n    --  result is zero, the sign is forced positive."}, {"sha": "86d74529a8a2c55c05fc536f6e2dd2607f626863", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b1c4f20d84963a47ed6c12ea564488c0b224655/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b1c4f20d84963a47ed6c12ea564488c0b224655/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=4b1c4f20d84963a47ed6c12ea564488c0b224655", "patch": "@@ -5941,6 +5941,16 @@ package body Sem_Res is\n \n       Set_Etype (N, Typ);\n       Eval_Case_Expression (N);\n+\n+      --  If we still have a case expression, and overflow checks are enabled\n+      --  in MINIMIZED or ELIMINATED modes, then set Do_Overflow_Check to\n+      --  ensure that we handle overflow for dependent expressions.\n+\n+      if Nkind (N) = N_Case_Expression\n+        and then Overflow_Check_Mode (Typ) in Minimized_Or_Eliminated\n+      then\n+         Set_Do_Overflow_Check (N);\n+      end if;\n    end Resolve_Case_Expression;\n \n    -------------------------------\n@@ -6134,8 +6144,9 @@ package body Sem_Res is\n       Resolve (Then_Expr, Typ);\n       Then_Typ := Etype (Then_Expr);\n \n-      --  When the \"then\" and \"else\" expressions are of a scalar type, insert\n-      --  a conversion to ensure the generation of a constraint check.\n+      --  When the \"then\" expression is of a scalar type different from the\n+      --  result type, then insert a conversion to ensure the generation of\n+      --  a constraint check.\n \n       if Is_Scalar_Type (Then_Typ)\n         and then Then_Typ /= Typ\n@@ -6174,6 +6185,16 @@ package body Sem_Res is\n \n       Set_Etype (N, Typ);\n       Eval_Conditional_Expression (N);\n+\n+      --  If we still have a conditional expression, and overflow checks are\n+      --  enabled in MINIMIZED or ELIMINATED modes, then set Do_Overflow_Check\n+      --  to ensure that we handle overflow for dependent expressions.\n+\n+      if Nkind (N) = N_Conditional_Expression\n+        and then Overflow_Check_Mode (Typ) in Minimized_Or_Eliminated\n+      then\n+         Set_Do_Overflow_Check (N);\n+      end if;\n    end Resolve_Conditional_Expression;\n \n    -----------------------------------------"}, {"sha": "a7ecd179cc241de8ff56250fda15558e248e0eb7", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b1c4f20d84963a47ed6c12ea564488c0b224655/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b1c4f20d84963a47ed6c12ea564488c0b224655/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=4b1c4f20d84963a47ed6c12ea564488c0b224655", "patch": "@@ -927,6 +927,8 @@ package body Sinfo is\n       pragma Assert (False\n         or else NT (N).Nkind in N_Op\n         or else NT (N).Nkind = N_Attribute_Reference\n+        or else NT (N).Nkind = N_Case_Expression\n+        or else NT (N).Nkind = N_Conditional_Expression\n         or else NT (N).Nkind = N_Type_Conversion);\n       return Flag17 (N);\n    end Do_Overflow_Check;\n@@ -3998,6 +4000,8 @@ package body Sinfo is\n       pragma Assert (False\n         or else NT (N).Nkind in N_Op\n         or else NT (N).Nkind = N_Attribute_Reference\n+        or else NT (N).Nkind = N_Case_Expression\n+        or else NT (N).Nkind = N_Conditional_Expression\n         or else NT (N).Nkind = N_Type_Conversion);\n       Set_Flag17 (N, Val);\n    end Set_Do_Overflow_Check;"}, {"sha": "79f8c436466a85b5e56f5c40df7469f769437aae", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 92, "deletions": 93, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b1c4f20d84963a47ed6c12ea564488c0b224655/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b1c4f20d84963a47ed6c12ea564488c0b224655/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=4b1c4f20d84963a47ed6c12ea564488c0b224655", "patch": "@@ -823,7 +823,10 @@ package Sinfo is\n    --    See also the description of Do_Range_Check for this case. The only\n    --    attribute references which use this flag are Pred and Succ, where it\n    --    means that the result should be checked for going outside the base\n-   --    range. Note that this flag is not set for modular types.\n+   --    range. Note that this flag is not set for modular types. This flag is\n+   --    also set on conditional expression nodes if we are operating in either\n+   --    MINIMIZED or ELIMINATED overflow checking mode (to make sure that we\n+   --    properly process overflow checking for dependent expressions).\n \n    --  Do_Range_Check (Flag9-Sem)\n    --    This flag is set on an expression which appears in a context where a\n@@ -3859,18 +3862,91 @@ package Sinfo is\n       --  Note on overflow handling: When the overflow checking mode is set to\n       --  MINIMIZED or ELIMINATED, nodes for signed arithmetic operations may\n       --  be modified to use a larger type for the operands and result. In\n-      --  these cases, the back end does not need the Entity field anyway, so\n-      --  there is no point in setting it. In fact we reuse the Entity field to\n-      --  record the possible range of the result. Entity points to an N_Range\n-      --  node whose Low_Bound and High_Bound fields point to integer literal\n-      --  nodes containing the computed bounds. These range nodes are only set\n-      --  for intermediate nodes whose parents are themselves either arithmetic\n-      --  operators, or comparison or membership tests. The computed ranges are\n-      --  then used in processing the parent operation. In the case where the\n-      --  computed range exceeds that of Long_Long_Integer, and we are running\n-      --  in ELIMINATED mode, the operator node will be changed to be a call to\n-      --  the appropriate routine in System.Bignums, and in this case we forget\n-      --  about keeping track of the range.\n+      --  the case where the computed range exceeds that of Long_Long_Integer,\n+      --  and we are running in ELIMINATED mode, the operator node will be\n+      --  changed to be a call to the appropriate routine in System.Bignums.\n+\n+      ------------------------------------\n+      -- 4.5.7  Conditional Expressions --\n+      ------------------------------------\n+\n+      --  CONDITIONAL_EXPRESSION ::= IF_EXPRESSION | CASE_EXPRESSION\n+\n+      --------------------------\n+      -- 4.5.7  If Expression --\n+      ----------------------------\n+\n+      --  IF_EXPRESSION ::=\n+      --    if CONDITION then DEPENDENT_EXPRESSION\n+      --                {elsif CONDITION then DEPENDENT_EXPRESSION}\n+      --                [else DEPENDENT_EXPRESSION]\n+\n+      --  DEPENDENT_EXPRESSION ::= EXPRESSION\n+\n+      --  Note: if we have (IF x1 THEN x2 ELSIF x3 THEN x4 ELSE x5) then it\n+      --  is represented as (IF x1 THEN x2 ELSE (IF x3 THEN x4 ELSE x5)) and\n+      --  the Is_Elsif flag is set on the inner conditional expression.\n+\n+      --  Note: to be consistent with the grammar, the following node should\n+      --  really be named N_If_Expression, but historically it was always\n+      --  N_Conditional_Expression, so it would be a bit of an earthquake\n+      --  to change, and actually conditional expression seems a bit clearer\n+      --  than if expression in typical contexts, so we decide to leave it!\n+\n+      --  N_Conditional_Expression\n+      --  Sloc points to IF or ELSIF keyword\n+      --  Expressions (List1)\n+      --  Then_Actions (List2-Sem)\n+      --  Else_Actions (List3-Sem)\n+      --  Is_Elsif (Flag13) (set if comes from ELSIF)\n+      --  Do_Overflow_Check (Flag17-Sem)\n+      --  plus fields for expression\n+\n+      --  Expressions here is a three-element list, whose first element is the\n+      --  condition, the second element is the dependent expression after THEN\n+      --  and the third element is the dependent expression after the ELSE\n+      --  (explicitly set to True if missing).\n+\n+      --  Note: the Then_Actions and Else_Actions fields are always set to\n+      --  No_List in the tree passed to Gigi. These fields are used only\n+      --  for temporary processing purposes in the expander.\n+\n+      ----------------------------\n+      -- 4.5.7  Case Expression --\n+      ----------------------------\n+\n+      --  CASE_EXPRESSION ::=\n+      --    case SELECTING_EXPRESSION is\n+      --      CASE_EXPRESSION_ALTERNATIVE\n+      --      {CASE_EXPRESSION_ALTERNATIVE}\n+\n+      --  Note that the Alternatives cannot include pragmas (this contrasts\n+      --  with the situation of case statements where pragmas are allowed).\n+\n+      --  N_Case_Expression\n+      --  Sloc points to CASE\n+      --  Expression (Node3) (the selecting expression)\n+      --  Alternatives (List4) (the case expression alternatives)\n+      --  Do_Overflow_Check (Flag17-Sem)\n+\n+      ----------------------------------------\n+      -- 4.5.7  Case Expression Alternative --\n+      ----------------------------------------\n+\n+      --  CASE_EXPRESSION_ALTERNATIVE ::=\n+      --    when DISCRETE_CHOICE_LIST =>\n+      --      DEPENDENT_EXPRESSION\n+\n+      --  N_Case_Expression_Alternative\n+      --  Sloc points to WHEN\n+      --  Actions (List1)\n+      --  Discrete_Choices (List4)\n+      --  Expression (Node3)\n+\n+      --  Note: The Actions field temporarily holds any actions associated with\n+      --  evaluation of the Expression. During expansion of the case expression\n+      --  these actions are wrapped into an N_Expressions_With_Actions node\n+      --  replacing the original expression.\n \n       ---------------------------------\n       -- 4.5.9 Quantified Expression --\n@@ -6877,86 +6953,9 @@ package Sinfo is\n    --  show this syntax.\n \n    --  Note: Case_Expression and Conditional_Expression is in this section for\n-   --  now, since they are extensions. We will move them to their appropriate\n-   --  places when they are officially approved as extensions (and then we will\n-   --  know what the exact grammar and place in the Reference Manual is!)\n-\n-      ---------------------\n-      -- Case Expression --\n-      ---------------------\n-\n-      --  CASE_EXPRESSION ::=\n-      --    case EXPRESSION is\n-      --      CASE_EXPRESSION_ALTERNATIVE\n-      --      {CASE_EXPRESSION_ALTERNATIVE}\n-\n-      --  Note that the Alternatives cannot include pragmas (this contrasts\n-      --  with the situation of case statements where pragmas are allowed).\n-\n-      --  N_Case_Expression\n-      --  Sloc points to CASE\n-      --  Expression (Node3)\n-      --  Alternatives (List4)\n-\n-      ---------------------------------\n-      -- Case Expression Alternative --\n-      ---------------------------------\n-\n-      --  CASE_STATEMENT_ALTERNATIVE ::=\n-      --    when DISCRETE_CHOICE_LIST =>\n-      --      EXPRESSION\n-\n-      --  N_Case_Expression_Alternative\n-      --  Sloc points to WHEN\n-      --  Actions (List1)\n-      --  Discrete_Choices (List4)\n-      --  Expression (Node3)\n-\n-      --  Note: The Actions field temporarily holds any actions associated with\n-      --  evaluation of the Expression. During expansion of the case expression\n-      --  these actions are wrapped into an N_Expressions_With_Actions node\n-      --  replacing the original expression.\n-\n-      ----------------------------\n-      -- Conditional Expression --\n-      ----------------------------\n-\n-      --  This node is used to represent an expression corresponding to the\n-      --  C construct (condition ? then-expression : else_expression), where\n-      --  Expressions is a three element list, whose first expression is the\n-      --  condition, and whose second and third expressions are the then and\n-      --  else expressions respectively.\n-\n-      --  Note: the Then_Actions and Else_Actions fields are always set to\n-      --  No_List in the tree passed to Gigi. These fields are used only\n-      --  for temporary processing purposes in the expander.\n-\n-      --  The Ada language does not permit conditional expressions, however\n-      --  this is under discussion as a possible extension by the ARG, and we\n-      --  have implemented a form of this capability in GNAT under control of\n-      --  the -gnatX switch. The syntax is:\n-\n-      --  CONDITIONAL_EXPRESSION ::=\n-      --    if EXPRESSION then EXPRESSION\n-      --                  {elsif EXPRESSION then EXPRESSION}\n-      --                  [else EXPRESSION]\n-\n-      --  And we add the additional constructs\n-\n-      --  PRIMARY ::= ( CONDITIONAL_EXPRESSION )\n-      --  PRAGMA_ARGUMENT_ASSOCIATION ::= CONDITIONAL_EXPRESSION\n-\n-      --  Note: if we have (IF x1 THEN x2 ELSIF x3 THEN x4 ELSE x5) then it\n-      --  is represented as (IF x1 THEN x2 ELSE (IF x3 THEN x4 ELSE x5)) and\n-      --  the Is_Elsif flag is set on the inner conditional expression.\n-\n-      --  N_Conditional_Expression\n-      --  Sloc points to IF or ELSIF keyword\n-      --  Expressions (List1)\n-      --  Then_Actions (List2-Sem)\n-      --  Else_Actions (List3-Sem)\n-      --  Is_Elsif (Flag13) (set if comes from ELSIF)\n-      --  plus fields for expression\n+   --  historical reasons, since they were initially extensions. Now that they\n+   --  are an official part of Ada 2012, we should move them to the appropriate\n+   --  section of this package. ???\n \n       --------------\n       -- Contract --"}]}