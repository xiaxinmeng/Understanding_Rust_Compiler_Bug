{"sha": "a02c5a694eab9da43296e18b0c669e731c31427a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAyYzVhNjk0ZWFiOWRhNDMyOTZlMThiMGM2NjllNzMxYzMxNDI3YQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2015-05-22T10:25:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-22T10:25:20Z"}, "message": "atree.adb, atree.ads (Needs_Actuals_Check): New flag.\n\n2015-05-22  Robert Dewar  <dewar@adacore.com>\n\n\t* atree.adb, atree.ads (Needs_Actuals_Check): New flag.\n\nFrom-SVN: r223536", "tree": {"sha": "1e54597e4f87629dea72d3cef787c9173b1bcbfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e54597e4f87629dea72d3cef787c9173b1bcbfe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a02c5a694eab9da43296e18b0c669e731c31427a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a02c5a694eab9da43296e18b0c669e731c31427a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a02c5a694eab9da43296e18b0c669e731c31427a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a02c5a694eab9da43296e18b0c669e731c31427a/comments", "author": null, "committer": null, "parents": [{"sha": "7a391e42e75bb13e036d521be84714a5ced2a4c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a391e42e75bb13e036d521be84714a5ced2a4c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a391e42e75bb13e036d521be84714a5ced2a4c4"}], "stats": {"total": 82, "additions": 61, "deletions": 21}, "files": [{"sha": "7708e137afd15eab4e82619cb968eab88562afb5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a02c5a694eab9da43296e18b0c669e731c31427a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a02c5a694eab9da43296e18b0c669e731c31427a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a02c5a694eab9da43296e18b0c669e731c31427a", "patch": "@@ -1,3 +1,7 @@\n+2015-05-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* atree.adb, atree.ads (Needs_Actuals_Check): New flag.\n+\n 2015-05-22  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_prag.adb (Analyze_Pragma): Remove the detection"}, {"sha": "457fa622d7758d7920ec8c14bc3f0150819d4e64", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a02c5a694eab9da43296e18b0c669e731c31427a/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a02c5a694eab9da43296e18b0c669e731c31427a/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=a02c5a694eab9da43296e18b0c669e731c31427a", "patch": "@@ -594,6 +594,10 @@ package body Atree is\n          Set_Is_Ignored_Ghost_Node (New_Id);\n       end if;\n \n+      --  Clear Needs_Actual_Check to False\n+\n+      Set_Needs_Actuals_Check (New_Id, False);\n+\n       --  Specifically copy Paren_Count to deal with creating new table entry\n       --  if the parentheses count is at the maximum possible value already.\n \n@@ -1489,6 +1493,15 @@ package body Atree is\n       Nodes.Table (New_Node).Rewrite_Ins := True;\n    end Mark_Rewrite_Insertion;\n \n+   -------------------------\n+   -- Needs_Actuals_Check --\n+   -------------------------\n+\n+   function Needs_Actuals_Check (N : Node_Id) return Boolean is\n+   begin\n+      return Flags.Table (N).Needs_Actuals_Check;\n+   end Needs_Actuals_Check;\n+\n    --------------\n    -- New_Copy --\n    --------------\n@@ -2097,6 +2110,15 @@ package body Atree is\n       Flags.Table (N).Is_Ignored_Ghost_Node := Val;\n    end Set_Is_Ignored_Ghost_Node;\n \n+   -----------------------------\n+   -- Set_Needs_Actuals_Check --\n+   -----------------------------\n+\n+   procedure Set_Needs_Actuals_Check (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      Flags.Table (N).Needs_Actuals_Check := Val;\n+   end Set_Needs_Actuals_Check;\n+\n    -----------------------\n    -- Set_Original_Node --\n    -----------------------"}, {"sha": "c3f9c5c7b64803e0f7559e1148f277fd13797d17", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a02c5a694eab9da43296e18b0c669e731c31427a/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a02c5a694eab9da43296e18b0c669e731c31427a/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=a02c5a694eab9da43296e18b0c669e731c31427a", "patch": "@@ -605,44 +605,46 @@ package Atree is\n    --  The following functions return the contents of the indicated field of\n    --  the node referenced by the argument, which is a Node_Id.\n \n-   function Analyzed          (N : Node_Id) return Boolean;\n+   function Analyzed                     (N : Node_Id) return Boolean;\n    pragma Inline (Analyzed);\n \n-   function Comes_From_Source (N : Node_Id) return Boolean;\n+   function Comes_From_Source            (N : Node_Id) return Boolean;\n    pragma Inline (Comes_From_Source);\n \n-   function Error_Posted      (N : Node_Id) return Boolean;\n+   function Error_Posted                 (N : Node_Id) return Boolean;\n    pragma Inline (Error_Posted);\n \n-   function Has_Aspects       (N : Node_Id) return Boolean;\n+   function Has_Aspects                  (N : Node_Id) return Boolean;\n    pragma Inline (Has_Aspects);\n \n-   function Is_Ignored_Ghost_Node\n-                              (N : Node_Id) return Boolean;\n+   function Is_Ignored_Ghost_Node        (N : Node_Id) return Boolean;\n    pragma Inline (Is_Ignored_Ghost_Node);\n \n-   function Nkind             (N : Node_Id) return Node_Kind;\n+   function Needs_Actuals_Check          (N : Node_Id) return Boolean;\n+   pragma Inline (Needs_Actuals_Check);\n+\n+   function Nkind                        (N : Node_Id) return Node_Kind;\n    pragma Inline (Nkind);\n \n-   function No                (N : Node_Id) return Boolean;\n+   function No                           (N : Node_Id) return Boolean;\n    pragma Inline (No);\n    --  Tests given Id for equality with the Empty node. This allows notations\n    --  like \"if No (Variant_Part)\" as opposed to \"if Variant_Part = Empty\".\n \n-   function Parent            (N : Node_Id) return Node_Id;\n+   function Parent                       (N : Node_Id) return Node_Id;\n    pragma Inline (Parent);\n    --  Returns the parent of a node if the node is not a list member, or else\n    --  the parent of the list containing the node if the node is a list member.\n \n-   function Paren_Count       (N : Node_Id) return Nat;\n+   function Paren_Count                  (N : Node_Id) return Nat;\n    pragma Inline (Paren_Count);\n \n-   function Present           (N : Node_Id) return Boolean;\n+   function Present                      (N : Node_Id) return Boolean;\n    pragma Inline (Present);\n    --  Tests given Id for inequality with the Empty node. This allows notations\n    --  like \"if Present (Statement)\" as opposed to \"if Statement /= Empty\".\n \n-   function Sloc              (N : Node_Id) return Source_Ptr;\n+   function Sloc                         (N : Node_Id) return Source_Ptr;\n    pragma Inline (Sloc);\n \n    ---------------------\n@@ -893,40 +895,43 @@ package Atree is\n    --  to be set in the specified field. Note that Set_Nkind is in the next\n    --  section, since its use is restricted.\n \n-   procedure Set_Analyzed (N : Node_Id; Val : Boolean := True);\n+   procedure Set_Analyzed              (N : Node_Id; Val : Boolean := True);\n    pragma Inline (Set_Analyzed);\n \n-   procedure Set_Comes_From_Source (N : Node_Id; Val : Boolean);\n+   procedure Set_Comes_From_Source     (N : Node_Id; Val : Boolean);\n    pragma Inline (Set_Comes_From_Source);\n    --  Note that this routine is very rarely used, since usually the default\n    --  mechanism provided sets the right value, but in some unusual cases, the\n    --  value needs to be reset (e.g. when a source node is copied, and the copy\n    --  must not have Comes_From_Source set).\n \n-   procedure Set_Error_Posted (N : Node_Id; Val : Boolean := True);\n+   procedure Set_Error_Posted          (N : Node_Id; Val : Boolean := True);\n    pragma Inline (Set_Error_Posted);\n \n-   procedure Set_Has_Aspects (N : Node_Id; Val : Boolean := True);\n+   procedure Set_Has_Aspects           (N : Node_Id; Val : Boolean := True);\n    pragma Inline (Set_Has_Aspects);\n \n    procedure Set_Is_Ignored_Ghost_Node (N : Node_Id; Val : Boolean := True);\n    pragma Inline (Set_Is_Ignored_Ghost_Node);\n \n-   procedure Set_Original_Node (N : Node_Id; Val : Node_Id);\n+   procedure Set_Needs_Actuals_Check   (N : Node_Id; Val : Boolean := True);\n+   pragma Inline (Set_Needs_Actuals_Check);\n+\n+   procedure Set_Original_Node         (N : Node_Id; Val : Node_Id);\n    pragma Inline (Set_Original_Node);\n    --  Note that this routine is used only in very peculiar cases. In normal\n    --  cases, the Original_Node link is set by calls to Rewrite. We currently\n    --  use it in ASIS mode to manually set the link from pragma expressions to\n    --  their aspect original source expressions, so that the original source\n    --  expressions accessed by ASIS are also semantically analyzed.\n \n-   procedure Set_Parent (N : Node_Id; Val : Node_Id);\n+   procedure Set_Parent                (N : Node_Id; Val : Node_Id);\n    pragma Inline (Set_Parent);\n \n-   procedure Set_Paren_Count (N : Node_Id; Val : Nat);\n+   procedure Set_Paren_Count           (N : Node_Id; Val : Nat);\n    pragma Inline (Set_Paren_Count);\n \n-   procedure Set_Sloc (N : Node_Id; Val : Source_Ptr);\n+   procedure Set_Sloc                  (N : Node_Id; Val : Source_Ptr);\n    pragma Inline (Set_Sloc);\n \n    ------------------------------\n@@ -4123,16 +4128,25 @@ package Atree is\n \n       type Flags_Byte is record\n          Flag0  : Boolean;\n+         --  Note: we don't use Flag0 at the moment. To put Flag0 into use\n+         --  requires some awkward work in Treeprs (treeprs.adt), so for the\n+         --  moment we don't use it.\n+\n          Flag1  : Boolean;\n          Flag2  : Boolean;\n          Flag3  : Boolean;\n+         --  These flags are used in the usual manner in Sinfo and Einfo\n \n          Is_Ignored_Ghost_Node : Boolean;\n          --  Flag denothing whether the node is subject to pragma Ghost with\n          --  policy Ignore. The name of the flag should be Flag4, however this\n          --  requires changing the names of all remaining 300+ flags.\n \n-         Spare1 : Boolean;\n+         Needs_Actuals_Check : Boolean;\n+         --  Flag set to indicate that the marked node is subject to the check\n+         --  for writable actuals. See xxx for more details. Again it would be\n+         --  more uniform to use some Flagx here, but that would be disruptive.\n+\n          Spare2 : Boolean;\n          Spare3 : Boolean;\n       end record;"}]}