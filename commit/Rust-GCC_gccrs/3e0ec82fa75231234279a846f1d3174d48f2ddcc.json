{"sha": "3e0ec82fa75231234279a846f1d3174d48f2ddcc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2UwZWM4MmZhNzUyMzEyMzQyNzlhODQ2ZjFkMzE3NGQ0OGYyZGRjYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-04-30T17:00:59Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-04-30T17:00:59Z"}, "message": "re PR c++/6492 (New boost regression (friends))\n\n\tPR c++/6492\n\t* pt.c (tsubst_friend_class): If the friend has an explicit scope,\n\tenter that scope before name lookup.\n\nFrom-SVN: r52951", "tree": {"sha": "8ac961b42915337dce0c192c0975fede1238658f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ac961b42915337dce0c192c0975fede1238658f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e0ec82fa75231234279a846f1d3174d48f2ddcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e0ec82fa75231234279a846f1d3174d48f2ddcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e0ec82fa75231234279a846f1d3174d48f2ddcc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e0ec82fa75231234279a846f1d3174d48f2ddcc/comments", "author": null, "committer": null, "parents": [{"sha": "30482eb0deaebc6d4241460e0626945816337f50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30482eb0deaebc6d4241460e0626945816337f50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30482eb0deaebc6d4241460e0626945816337f50"}], "stats": {"total": 67, "additions": 42, "deletions": 25}, "files": [{"sha": "7551df7b14ee0a353e68659e5602f27e040eef88", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e0ec82fa75231234279a846f1d3174d48f2ddcc/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e0ec82fa75231234279a846f1d3174d48f2ddcc/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3e0ec82fa75231234279a846f1d3174d48f2ddcc", "patch": "@@ -4831,30 +4831,36 @@ tsubst_friend_class (friend_tmpl, args)\n {\n   tree friend_type;\n   tree tmpl;\n+  tree context;\n \n-  /* First, we look for a class template.  */\n-  if (DECL_CONTEXT (friend_tmpl))\n-    tmpl = friend_tmpl;\n-  else\n+  context = DECL_CONTEXT (friend_tmpl);\n+\n+  if (context)\n     {\n-      tmpl = lookup_name (DECL_NAME (friend_tmpl), /*prefer_type=*/0); \n+      if (TREE_CODE (context) == NAMESPACE_DECL)\n+\tpush_nested_namespace (context);\n+      else\n+\tpush_nested_class (context, 2);\n+    }\n \n-      /* But, if we don't find one, it might be because we're in a\n-\t situation like this:\n+  /* First, we look for a class template.  */\n+  tmpl = lookup_name (DECL_NAME (friend_tmpl), /*prefer_type=*/0); \n \n-\t   template <class T>\n-\t   struct S {\n-\t     template <class U>\n-\t     friend struct S;\n-\t   };\n+  /* But, if we don't find one, it might be because we're in a\n+     situation like this:\n \n-\t Here, in the scope of (say) S<int>, `S' is bound to a TYPE_DECL\n-\t for `S<int>', not the TEMPLATE_DECL.  */\n-      if (!tmpl || !DECL_CLASS_TEMPLATE_P (tmpl))\n-\t{\n-\t  tmpl = lookup_name (DECL_NAME (friend_tmpl), /*prefer_type=*/1);\n-\t  tmpl = maybe_get_template_decl_from_type_decl (tmpl);\n-\t}\n+       template <class T>\n+       struct S {\n+\t template <class U>\n+\t friend struct S;\n+       };\n+\n+     Here, in the scope of (say) S<int>, `S' is bound to a TYPE_DECL\n+     for `S<int>', not the TEMPLATE_DECL.  */\n+  if (!tmpl || !DECL_CLASS_TEMPLATE_P (tmpl))\n+    {\n+      tmpl = lookup_name (DECL_NAME (friend_tmpl), /*prefer_type=*/1);\n+      tmpl = maybe_get_template_decl_from_type_decl (tmpl);\n     }\n \n   if (tmpl && DECL_CLASS_TEMPLATE_P (tmpl))\n@@ -4865,12 +4871,15 @@ tsubst_friend_class (friend_tmpl, args)\n \t of course.  We only need the innermost template parameters\n \t because that is all that redeclare_class_template will look\n \t at.  */\n-      tree parms \n-\t= tsubst_template_parms (DECL_TEMPLATE_PARMS (friend_tmpl),\n-\t\t\t\t args, tf_error | tf_warning);\n-      if (!parms)\n-        return error_mark_node;\n-      redeclare_class_template (TREE_TYPE (tmpl), parms);\n+      if (TMPL_PARMS_DEPTH (DECL_TEMPLATE_PARMS (friend_tmpl))\n+\t  > TMPL_ARGS_DEPTH (args))\n+\t{\n+\t  tree parms;\n+\t  parms = tsubst_template_parms (DECL_TEMPLATE_PARMS (friend_tmpl),\n+\t\t\t\t\t args, tf_error | tf_warning);\n+\t  redeclare_class_template (TREE_TYPE (tmpl), parms);\n+\t}\n+\n       friend_type = TREE_TYPE (tmpl);\n     }\n   else\n@@ -4892,6 +4901,14 @@ tsubst_friend_class (friend_tmpl, args)\n       friend_type = TREE_TYPE (pushdecl_top_level (tmpl));\n     }\n \n+  if (context) \n+    {\n+      if (TREE_CODE (context) == NAMESPACE_DECL)\n+\tpop_nested_namespace (context);\n+      else\n+\tpop_nested_class ();\n+    }\n+\n   return friend_type;\n }\n "}]}