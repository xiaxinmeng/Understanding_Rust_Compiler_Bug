{"sha": "f25a6767ec28780a3e3b6d38f5e54e1122a26fd6", "node_id": "C_kwDOANBUbNoAKGYyNWE2NzY3ZWMyODc4MGEzZTNiNmQzOGY1ZTU0ZTExMjJhMjZmZDY", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-09-08T11:08:22Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-09-08T11:32:51Z"}, "message": "openmp: Implement doacross(sink: omp_cur_iteration - 1)\n\nThis patch implements doacross(sink: omp_cur_iteration - 1) that the\nprevious patchset emitted a sorry on during omp expansion.\nIt can be implemented with existing library functions.\n\nTo recap, depend(source)/doacross(source:)/doacross(source:omp_cur_iteration)\nis implemented calling GOMP_doacross_post or GOMP_doacross_ull_post,\ncalled with an array of long or unsigned long long elements, one for\nall collapsed loops together and one for each further ordered loop if any.\nWe initialize that array in each thread when grabbing further set of iterations\nand update it at the end of loops, so that it represents the current iteration\n(as 0 based counters).  When the worksharing loop is created, we tell the\nlibrary through another similar array the counts (the loop needs to be\nrectangular) in each dimension, first element is count of all logical iterations\nin the collapsed loops.\n\ndepend(sink:v1 op N1, v2 op N2, ...) is then implemented by conditionally calling\nGOMP_doacross_wait/GOMP_doacross_ull_wait.  For N? of 0 there is no check,\notherwise if it wants to wait in a particular dimension for a previous iteration,\nwe check that the corresponding iterator isn't the first one (or first few),\nwhere the previous iterator in that dimension would be out of range, and similarly\nfor checking of next iteration in a dimension that it isn't the last one (or last few)\nwhere it would be similarly out of bounds.  Then the collapsed loop counters are\nfolded into a single 0 based counter (first argument) and then other 0 based\niterations counters on what iteration it should wait for.\n\nNow, doacross(sink: omp_cur_iteration - 1) is supposed to wait for the previous\nlogical iteration in the combined iteration space of all ordered loops.\nFor the very first iteration in that combined iteration space it does nothing,\nthere is no previous iteration.  And similarly it does nothing if there\nare more ordered loops than collapsed loop and it isn't the first logical\niteration of the combined loops inside of the collapsed loops, because as implemented\nwe know the previous iteration in that case is always executed by the same thread\nas the current one.\nIn the implementation, we use the same value as is stored in the first element\nof the array for GOMP_doacross_post/GOMP_doacross_ull_post, if that value is 0,\nwe do nothing.  The rest is different based on if ordered argument is equal to\ncollapse or not.  If it is, then we otherwise call\nGOMP_doacross_wait/GOMP_doacross_ull_wait with a single argument, one less than\nthat counter we compare against 0.\nIf ordered argument is bigger than collapse, we add a per-thread boolean variable\n.first.N, which we set to true at the start of the outermost ordered loop inside\nof the collapsed set of loops and set to false at the end of the innermost\nordered loop.  If .first.N is false, we don't do anything (we know the previous\niteration was handled by the current thread and by my reading of the spec we don't\nneed to emit even a memory barrier in that case, because it is just synchronization\nwith the same thread), otherwise we call GOMP_doacross_wait/GOMP_doacross_ull_wait\nwith the first argument one less than the counter we compare against 0, and then\none less than 2nd and following counts if iterations we pass to the workshare\ninitialization.  If say .counts.N passed to the workshare initialization is\n{ 256, 13, 5, 2 } for collapse(3) ordered(6) loop, then\nGOMP_doacross_post/GOMP_doacross_ull_post is called with arguments equal to\n.ordereda.N[0] - 1, 12, 4, 1.\n\n2022-09-08  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* omp-expand.cc (expand_omp_ordered_sink): Add CONT_BB argument.\n\tAdd doacross(sink:omp_cur_iteration-1) support.\n\t(expand_omp_ordered_source_sink): Clear counts[fd->ordered + 1].\n\tAdjust expand_omp_ordered_sink caller.\n\t(expand_omp_for_ordered_loops): If counts[fd->ordered + 1] is\n\tnon-NULL, set that variable to true at the start of outermost\n\tnon-collapsed loop and set it to false at the end of innermost\n\tordered loop.\n\t(expand_omp_for_generic): If fd->ordered, allocate\n\t1 + (fd->ordered - fd->collapse) further elements in counts array.\n\tCopy to counts + 2 + fd->ordered the counts of fd->collapse ..\n\tfd->ordered - 1 loop if any.\ngcc/testsuite/\n\t* c-c++-common/gomp/doacross-7.c: New test.\nlibgomp/\n\t* libgomp.texi (OpenMP 5.2): Mention that omp_cur_iteration is now\n\tfully supported.\n\t* testsuite/libgomp.c/doacross-4.c: New test.\n\t* testsuite/libgomp.c/doacross-5.c: New test.\n\t* testsuite/libgomp.c/doacross-6.c: New test.\n\t* testsuite/libgomp.c/doacross-7.c: New test.", "tree": {"sha": "19d3a9ab263d2d94d344c72e8b6c15a2edd4086a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19d3a9ab263d2d94d344c72e8b6c15a2edd4086a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f25a6767ec28780a3e3b6d38f5e54e1122a26fd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f25a6767ec28780a3e3b6d38f5e54e1122a26fd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f25a6767ec28780a3e3b6d38f5e54e1122a26fd6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f25a6767ec28780a3e3b6d38f5e54e1122a26fd6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8d3b44dfa2851659f966627835497667c5fed6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8d3b44dfa2851659f966627835497667c5fed6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8d3b44dfa2851659f966627835497667c5fed6c"}], "stats": {"total": 1086, "additions": 1078, "deletions": 8}, "files": [{"sha": "5cac8dfe63427abcc9cb55a7c0ccc833a0bca9cb", "filename": "gcc/omp-expand.cc", "status": "modified", "additions": 111, "deletions": 6, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25a6767ec28780a3e3b6d38f5e54e1122a26fd6/gcc%2Fomp-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25a6767ec28780a3e3b6d38f5e54e1122a26fd6/gcc%2Fomp-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.cc?ref=f25a6767ec28780a3e3b6d38f5e54e1122a26fd6", "patch": "@@ -3287,7 +3287,8 @@ expand_omp_ordered_source (gimple_stmt_iterator *gsi, struct omp_for_data *fd,\n \n static void\n expand_omp_ordered_sink (gimple_stmt_iterator *gsi, struct omp_for_data *fd,\n-\t\t\t tree *counts, tree c, location_t loc)\n+\t\t\t tree *counts, tree c, location_t loc,\n+\t\t\t basic_block cont_bb)\n {\n   auto_vec<tree, 10> args;\n   enum built_in_function sink_ix\n@@ -3300,7 +3301,93 @@ expand_omp_ordered_sink (gimple_stmt_iterator *gsi, struct omp_for_data *fd,\n \n   if (deps == NULL)\n     {\n-      sorry_at (loc, \"%<doacross(sink:omp_cur_iteration-1)%> not supported yet\");\n+      /* Handle doacross(sink: omp_cur_iteration - 1).  */\n+      gsi_prev (&gsi2);\n+      edge e1 = split_block (gsi_bb (gsi2), gsi_stmt (gsi2));\n+      edge e2 = split_block_after_labels (e1->dest);\n+      gsi2 = gsi_after_labels (e1->dest);\n+      *gsi = gsi_last_bb (e1->src);\n+      gimple_stmt_iterator gsi3 = *gsi;\n+\n+      if (counts[fd->collapse - 1])\n+\t{\n+\t  gcc_assert (fd->collapse == 1);\n+\t  t = counts[fd->collapse - 1];\n+\t}\n+      else if (fd->collapse > 1)\n+\tt = fd->loop.v;\n+      else\n+\t{\n+\t  t = fold_build2 (MINUS_EXPR, TREE_TYPE (fd->loops[0].v),\n+\t\t\t   fd->loops[0].v, fd->loops[0].n1);\n+\t  t = fold_convert (fd->iter_type, t);\n+\t}\n+\n+      t = force_gimple_operand_gsi (gsi, t, true, NULL_TREE,\n+\t\t\t\t    false, GSI_CONTINUE_LINKING);\n+      gsi_insert_after (gsi, gimple_build_cond (NE_EXPR, t,\n+\t\t\t\t\t\tbuild_zero_cst (TREE_TYPE (t)),\n+\t\t\t\t\t\tNULL_TREE, NULL_TREE),\n+\t\t\tGSI_NEW_STMT);\n+\n+      t = fold_build2 (PLUS_EXPR, TREE_TYPE (t), t,\n+\t\t       build_minus_one_cst (TREE_TYPE (t)));\n+      t = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n+\t\t\t\t    true, GSI_SAME_STMT);\n+      args.safe_push (t);\n+      for (i = fd->collapse; i < fd->ordered; i++)\n+\t{\n+\t  t = counts[fd->ordered + 2 + (i - fd->collapse)];\n+\t  t = fold_build2 (PLUS_EXPR, TREE_TYPE (t), t,\n+\t\t\t   build_minus_one_cst (TREE_TYPE (t)));\n+\t  t = fold_convert (fd->iter_type, t);\n+\t  t = force_gimple_operand_gsi (&gsi2, t, true, NULL_TREE,\n+\t\t\t\t\ttrue, GSI_SAME_STMT);\n+\t  args.safe_push (t);\n+\t}\n+\n+      gimple *g = gimple_build_call_vec (builtin_decl_explicit (sink_ix),\n+\t\t\t\t\t args);\n+      gimple_set_location (g, loc);\n+      gsi_insert_before (&gsi2, g, GSI_SAME_STMT);\n+\n+      edge e3 = make_edge (e1->src, e2->dest, EDGE_FALSE_VALUE);\n+      e3->probability = profile_probability::guessed_always () / 8;\n+      e1->probability = e3->probability.invert ();\n+      e1->flags = EDGE_TRUE_VALUE;\n+      set_immediate_dominator (CDI_DOMINATORS, e2->dest, e1->src);\n+\n+      if (fd->ordered > fd->collapse && cont_bb)\n+\t{\n+\t  if (counts[fd->ordered + 1] == NULL_TREE)\n+\t    counts[fd->ordered + 1]\n+\t      = create_tmp_var (boolean_type_node, \".first\");\n+\n+\t  edge e4;\n+\t  if (gsi_end_p (gsi3))\n+\t    e4 = split_block_after_labels (e1->src);\n+\t  else\n+\t    {\n+\t      gsi_prev (&gsi3);\n+\t      e4 = split_block (gsi_bb (gsi3), gsi_stmt (gsi3));\n+\t    }\n+\t  gsi3 = gsi_last_bb (e4->src);\n+\n+\t  gsi_insert_after (&gsi3,\n+\t\t\t    gimple_build_cond (NE_EXPR,\n+\t\t\t\t\t       counts[fd->ordered + 1],\n+\t\t\t\t\t       boolean_false_node,\n+\t\t\t\t\t       NULL_TREE, NULL_TREE),\n+\t\t\t    GSI_NEW_STMT);\n+\n+\t  edge e5 = make_edge (e4->src, e2->dest, EDGE_FALSE_VALUE);\n+\t  e4->probability = profile_probability::guessed_always () / 8;\n+\t  e5->probability = e4->probability.invert ();\n+\t  e4->flags = EDGE_TRUE_VALUE;\n+\t  set_immediate_dominator (CDI_DOMINATORS, e2->dest, e4->src);\n+\t}\n+\n+      *gsi = gsi_after_labels (e2->dest);\n       return;\n     }\n   for (i = 0; i < fd->ordered; i++)\n@@ -3558,6 +3645,7 @@ expand_omp_ordered_source_sink (struct omp_region *region,\n     = build_array_type_nelts (fd->iter_type, fd->ordered - fd->collapse + 1);\n   counts[fd->ordered] = create_tmp_var (atype, \".orditera\");\n   TREE_ADDRESSABLE (counts[fd->ordered]) = 1;\n+  counts[fd->ordered + 1] = NULL_TREE;\n \n   for (inner = region->inner; inner; inner = inner->next)\n     if (inner->type == GIMPLE_OMP_ORDERED)\n@@ -3575,7 +3663,7 @@ expand_omp_ordered_source_sink (struct omp_region *region,\n \tfor (c = gimple_omp_ordered_clauses (ord_stmt);\n \t     c; c = OMP_CLAUSE_CHAIN (c))\n \t  if (OMP_CLAUSE_DOACROSS_KIND (c) == OMP_CLAUSE_DOACROSS_SINK)\n-\t    expand_omp_ordered_sink (&gsi, fd, counts, c, loc);\n+\t    expand_omp_ordered_sink (&gsi, fd, counts, c, loc, cont_bb);\n \tgsi_remove (&gsi, true);\n       }\n }\n@@ -3611,6 +3699,9 @@ expand_omp_for_ordered_loops (struct omp_for_data *fd, tree *counts,\n     {\n       tree t, type = TREE_TYPE (fd->loops[i].v);\n       gimple_stmt_iterator gsi = gsi_after_labels (body_bb);\n+      if (counts[fd->ordered + 1] && i == fd->collapse)\n+\texpand_omp_build_assign (&gsi, counts[fd->ordered + 1],\n+\t\t\t\t boolean_true_node);\n       expand_omp_build_assign (&gsi, fd->loops[i].v,\n \t\t\t       fold_convert (type, fd->loops[i].n1));\n       if (counts[i])\n@@ -3658,6 +3749,9 @@ expand_omp_for_ordered_loops (struct omp_for_data *fd, tree *counts,\n \t\t\t size_int (i - fd->collapse + 1),\n \t\t\t NULL_TREE, NULL_TREE);\n \t  expand_omp_build_assign (&gsi, aref, t);\n+\t  if (counts[fd->ordered + 1] && i == fd->ordered - 1)\n+\t    expand_omp_build_assign (&gsi, counts[fd->ordered + 1],\n+\t\t\t\t     boolean_false_node);\n \t  gsi_prev (&gsi);\n \t  e2 = split_block (cont_bb, gsi_stmt (gsi));\n \t  new_header = e2->dest;\n@@ -3915,7 +4009,10 @@ expand_omp_for_generic (struct omp_region *region,\n       int first_zero_iter1 = -1, first_zero_iter2 = -1;\n       basic_block zero_iter1_bb = NULL, zero_iter2_bb = NULL, l2_dom_bb = NULL;\n \n-      counts = XALLOCAVEC (tree, fd->ordered ? fd->ordered + 1 : fd->collapse);\n+      counts = XALLOCAVEC (tree, fd->ordered\n+\t\t\t\t ? fd->ordered + 2\n+\t\t\t\t   + (fd->ordered - fd->collapse)\n+\t\t\t\t : fd->collapse);\n       expand_omp_for_init_counts (fd, &gsi, entry_bb, counts,\n \t\t\t\t  zero_iter1_bb, first_zero_iter1,\n \t\t\t\t  zero_iter2_bb, first_zero_iter2, l2_dom_bb);\n@@ -4352,13 +4449,21 @@ expand_omp_for_generic (struct omp_region *region,\n   if (fd->ordered)\n     {\n       /* Until now, counts array contained number of iterations or\n-\t variable containing it for ith loop.  From now on, we need\n+\t variable containing it for ith loop.  From now on, we usually need\n \t those counts only for collapsed loops, and only for the 2nd\n \t till the last collapsed one.  Move those one element earlier,\n \t we'll use counts[fd->collapse - 1] for the first source/sink\n \t iteration counter and so on and counts[fd->ordered]\n \t as the array holding the current counter values for\n-\t depend(source).  */\n+\t depend(source).  For doacross(sink:omp_cur_iteration - 1) we need\n+\t the counts from fd->collapse to fd->ordered - 1; make a copy of\n+\t those to counts[fd->ordered + 2] and onwards.\n+\t counts[fd->ordered + 1] can be a flag whether it is the first\n+\t iteration with a new collapsed counter (used only if\n+\t fd->ordered > fd->collapse).  */\n+      if (fd->ordered > fd->collapse)\n+\tmemcpy (counts + fd->ordered + 2, counts + fd->collapse,\n+\t\t(fd->ordered - fd->collapse) * sizeof (counts[0]));\n       if (fd->collapse > 1)\n \tmemmove (counts, counts + 1, (fd->collapse - 1) * sizeof (counts[0]));\n       if (broken_loop)"}, {"sha": "8ead16795226c68d7e2d13b5315c0512ada44aa4", "filename": "gcc/testsuite/c-c++-common/gomp/doacross-7.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25a6767ec28780a3e3b6d38f5e54e1122a26fd6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdoacross-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25a6767ec28780a3e3b6d38f5e54e1122a26fd6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdoacross-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fdoacross-7.c?ref=f25a6767ec28780a3e3b6d38f5e54e1122a26fd6", "patch": "@@ -0,0 +1,78 @@\n+void\n+foo (int l)\n+{\n+  int i, j, k;\n+  #pragma omp parallel\n+  {\n+    #pragma omp for schedule(static) ordered (3)\n+    for (i = 2; i < 256 / 16 - 1; i++)\n+      for (j = 0; j < 8; j += 2)\n+\tfor (k = 1; k <= 3; k++)\n+\t  {\n+\t    #pragma omp ordered doacross(sink: omp_cur_iteration - 1)\n+\t    #pragma omp ordered doacross(source:)\n+\t  }\n+    #pragma omp for schedule(static) ordered (3) collapse(2)\n+    for (i = 2; i < 256 / 16 - 1; i++)\n+      for (j = 0; j < 8; j += 2)\n+\tfor (k = 1; k <= 3; k++)\n+\t  {\n+\t    #pragma omp ordered doacross(sink: omp_cur_iteration - 1)\n+\t    #pragma omp ordered doacross(source:)\n+\t  }\n+    #pragma omp for schedule(static) ordered (3) collapse(3)\n+    for (i = 2; i < 256 / 16 - 1; i++)\n+      for (j = 0; j < 8; j += 2)\n+\tfor (k = 1; k <= 3; k++)\n+\t  {\n+\t    #pragma omp ordered doacross(sink: omp_cur_iteration - 1)\n+\t    #pragma omp ordered doacross(source: omp_cur_iteration)\n+\t  }\n+    #pragma omp for schedule(static) ordered (1) nowait\n+    for (i = 2; i < 256 / 16 - 1; i += l)\n+      {\n+\t#pragma omp ordered doacross(sink: omp_cur_iteration - 1)\n+\t#pragma omp ordered doacross(source:)\n+      }\n+  }\n+}\n+\n+void\n+bar (int l, int m, int n, int o)\n+{\n+  int i, j, k;\n+  #pragma omp for schedule(static) ordered (3)\n+  for (i = 2; i < 256 / 16 - 1; i++)\n+    for (j = 0; j < m; j += n)\n+      for (k = o; k <= 3; k++)\n+\t{\n+\t  foo (l);\n+\t  #pragma omp ordered doacross(sink: omp_cur_iteration - 1)\n+\t  #pragma omp ordered doacross(source:omp_cur_iteration)\n+\t}\n+  #pragma omp for schedule(static) ordered (3) collapse(2)\n+  for (i = 2; i < 256 / 16 - m; i += n)\n+    for (j = 0; j < 8; j += o)\n+      for (k = 1; k <= 3; k++)\n+\t{\n+\t  foo (l);\n+\t  #pragma omp ordered doacross(sink: omp_cur_iteration - 1)\n+\t  #pragma omp ordered doacross(source : omp_cur_iteration)\n+\t}\n+  #pragma omp for schedule(static) ordered (3) collapse(3)\n+  for (i = m; i < 256 / 16 - 1; i++)\n+    for (j = 0; j < n; j += 2)\n+      for (k = 1; k <= o; k++)\n+\t{\n+\t  foo (l);\n+\t  #pragma omp ordered doacross(sink: omp_cur_iteration - 1)\n+\t  #pragma omp ordered doacross(source :)\n+\t}\n+  #pragma omp for schedule(static) ordered\n+  for (i = m; i < n / 16 - 1; i += l)\n+    {\n+      foo (l);\n+      #pragma omp ordered doacross(sink: omp_cur_iteration - 1)\n+      #pragma omp ordered doacross(source: omp_cur_iteration)\n+    }\n+}"}, {"sha": "0672580d569b5ef157c7b18e11a65b3512d52bdb", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25a6767ec28780a3e3b6d38f5e54e1122a26fd6/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25a6767ec28780a3e3b6d38f5e54e1122a26fd6/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=f25a6767ec28780a3e3b6d38f5e54e1122a26fd6", "patch": "@@ -397,8 +397,7 @@ to address of matching mapped list item per 5.1, Sect. 2.21.7.2 @tab N @tab\n       @code{source}/@code{sink} modifier @tab Y @tab\n @item Deprecation of @code{depend} with @code{source}/@code{sink} modifier\n       @tab N @tab\n-@item @code{omp_cur_iteration} keyword @tab P\n-      @tab @code{sink: omp_cur_iteration - 1} unsupported\n+@item @code{omp_cur_iteration} keyword @tab Y @tab\n @end multitable\n \n @unnumberedsubsec Other new OpenMP 5.2 features"}, {"sha": "4bc451d5b690ef8585fbf1c811e903cf9b6127ad", "filename": "libgomp/testsuite/libgomp.c/doacross-4.c", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25a6767ec28780a3e3b6d38f5e54e1122a26fd6/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25a6767ec28780a3e3b6d38f5e54e1122a26fd6/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-4.c?ref=f25a6767ec28780a3e3b6d38f5e54e1122a26fd6", "patch": "@@ -0,0 +1,228 @@\n+extern void abort (void);\n+\n+#define N 256\n+int a[N], b[N / 16][8][4], c[N / 32][8][8], g[N / 16][8][6];\n+volatile int d, e;\n+volatile unsigned long long f;\n+\n+int\n+main ()\n+{\n+  unsigned long long i;\n+  int j, k, l, m;\n+  #pragma omp parallel private (l)\n+  {\n+    #pragma omp for schedule(static, 1) ordered nowait\n+    for (i = 1; i < N + f; i++)\n+      {\n+\t#pragma omp atomic write\n+\ta[i] = 1;\n+\t#pragma omp ordered doacross(sink: i - 1)\n+\tif (i > 1)\n+\t  {\n+\t    #pragma omp atomic read\n+\t    l = a[i - 1];\n+\t    if (l < 2)\n+\t      abort ();\n+\t  }\n+\t#pragma omp atomic write\n+\ta[i] = 2;\n+\tif (i < N - 1)\n+\t  {\n+\t    #pragma omp atomic read\n+\t    l = a[i + 1];\n+\t    if (l == 3)\n+\t      abort ();\n+\t  }\n+\t#pragma omp ordered doacross(source : omp_cur_iteration)\n+\t#pragma omp atomic write\n+\ta[i] = 3;\n+      }\n+    #pragma omp for schedule(static) ordered (3) nowait\n+    for (i = 3; i < N / 16 - 1 + f; i++)\n+      for (j = 0; j < 8; j += 2)\n+\tfor (k = 1; k <= 3; k++)\n+\t  {\n+\t    #pragma omp atomic write\n+\t    b[i][j][k] = 1;\n+\t    #pragma omp ordered doacross(sink: i, j - 2, k - 1) \\\n+\t\t\t\tdoacross(sink: i - 2, j - 2, k + 1)\n+\t    #pragma omp ordered doacross(sink: i - 3, j + 2, k - 2)\n+\t    if (j >= 2 && k > 1)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = b[i][j - 2][k - 1];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    #pragma omp atomic write\n+\t    b[i][j][k] = 2;\n+\t    if (i >= 5 && j >= 2 && k < 3)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = b[i - 2][j - 2][k + 1];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    if (i >= 6 && j < N / 16 - 3 && k == 3)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = b[i - 3][j + 2][k - 2];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    #pragma omp ordered doacross(source : )\n+\t    #pragma omp atomic write\n+\t    b[i][j][k] = 3;\n+\t  }\n+#define A(n) int n;\n+#define B(n) A(n##0) A(n##1) A(n##2) A(n##3)\n+#define C(n) B(n##0) B(n##1) B(n##2) B(n##3)\n+#define D(n) C(n##0) C(n##1) C(n##2) C(n##3)\n+    D(m)\n+#undef A\n+    #pragma omp for collapse (2) ordered(61) schedule(dynamic, 15)\n+    for (i = 2; i < N / 32 + f; i++)\n+      for (j = 7; j > 1; j--)\n+\tfor (k = 6; k >= 0; k -= 2)\n+#define A(n) for (n = 4; n < 5; n++)\n+\t  D(m)\n+#undef A\n+\t    {\n+\t      #pragma omp atomic write\n+\t      c[i][j][k] = 1;\n+#define A(n) ,n\n+#define E(n) C(n##0) C(n##1) C(n##2) B(n##30) B(n##31) A(n##320) A(n##321)\n+\t      #pragma omp ordered doacross (sink: i, j, k + 2 E(m)) \\\n+\t\t\t\t  doacross (sink:i - 2, j + 1, k - 4 E(m)) \\\n+\t\t\t\t  doacross(sink: i - 1, j - 2, k - 2 E(m))\n+\t      if (k <= 4)\n+\t\t{\n+\t\t  #pragma omp atomic read\n+\t\t  l = c[i][j][k + 2];\n+\t\t  if (l < 2)\n+\t\t    abort ();\n+\t\t}\n+\t      #pragma omp atomic write\n+\t      c[i][j][k] = 2;\n+\t      if (i >= 4 && j < 7 && k >= 4)\n+\t\t{\n+\t\t  #pragma omp atomic read\n+\t\t  l = c[i - 2][j + 1][k - 4];\n+\t\t  if (l < 2)\n+\t\t    abort ();\n+\t\t}\n+\t      if (i >= 3 && j >= 4 && k >= 2)\n+\t\t{\n+\t\t  #pragma omp atomic read\n+\t\t  l = c[i - 1][j - 2][k - 2];\n+\t\t  if (l < 2)\n+\t\t    abort ();\n+\t\t}\n+\t      #pragma omp ordered doacross (source : omp_cur_iteration)\n+\t      #pragma omp atomic write\n+\t      c[i][j][k] = 3;\n+\t    }\n+    #pragma omp for schedule(static) ordered (3) nowait\n+    for (j = 0; j < N / 16 - 1; j++)\n+      for (k = 0; k < 8; k += 2)\n+\tfor (i = 3; i <= 5 + f; i++)\n+\t  {\n+\t    #pragma omp atomic write\n+\t    g[j][k][i] = 1;\n+\t    #pragma omp ordered doacross(sink: j, k - 2, i - 1) \\\n+\t\t\t\tdoacross(sink: j - 2, k - 2, i + 1)\n+\t    #pragma omp ordered doacross(sink: j - 3, k + 2, i - 2)\n+\t    if (k >= 2 && i > 3)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = g[j][k - 2][i - 1];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    #pragma omp atomic write\n+\t    g[j][k][i] = 2;\n+\t    if (j >= 2 && k >= 2 && i < 5)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = g[j - 2][k - 2][i + 1];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    if (j >= 3 && k < N / 16 - 3 && i == 5)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = g[j - 3][k + 2][i - 2];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    #pragma omp ordered doacross(source :)\n+\t    #pragma omp atomic write\n+\t    g[j][k][i] = 3;\n+\t  }\n+    #pragma omp for collapse(2) ordered(4) lastprivate (i, j, k)\n+    for (i = 2; i < f + 3; i++)\n+      for (j = d + 1; j >= 0; j--)\n+\tfor (k = 0; k < d; k++)\n+\t  for (l = 0; l < d + 2; l++)\n+\t    {\n+\t      #pragma omp ordered doacross (source : omp_cur_iteration)\n+\t      #pragma omp ordered doacross (sink:i - 2, j + 2, k - 2, l)\n+\t      if (!e)\n+\t\tabort ();\n+\t    }\n+    #pragma omp single\n+    {\n+      if (i != 3 || j != -1 || k != 0)\n+\tabort ();\n+      i = 8; j = 9; k = 10;\n+    }\n+    #pragma omp for collapse(2) ordered(4) lastprivate (i, j, k, m)\n+    for (i = 2; i < f + 3; i++)\n+      for (j = d + 1; j >= 0; j--)\n+\tfor (k = 0; k < d + 2; k++)\n+\t  for (m = 0; m < d; m++)\n+\t    {\n+\t      #pragma omp ordered doacross (source:)\n+\t      #pragma omp ordered doacross (sink:i - 2, j + 2, k - 2, m)\n+\t      abort ();\n+\t    }\n+    #pragma omp single\n+    if (i != 3 || j != -1 || k != 2 || m != 0)\n+      abort ();\n+    #pragma omp for collapse(2) ordered(4) nowait\n+    for (i = 2; i < f + 3; i++)\n+      for (j = d; j > 0; j--)\n+\tfor (k = 0; k < d + 2; k++)\n+\t  for (l = 0; l < d + 4; l++)\n+\t    {\n+\t      #pragma omp ordered doacross (source : omp_cur_iteration)\n+\t      #pragma omp ordered doacross (sink:i - 2, j + 2, k - 2, l)\n+\t      if (!e)\n+\t\tabort ();\n+\t    }\n+    #pragma omp for nowait\n+    for (i = 0; i < N; i++)\n+      if (a[i] != 3 * (i >= 1))\n+\tabort ();\n+    #pragma omp for collapse(2) private(k) nowait\n+    for (i = 0; i < N / 16; i++)\n+      for (j = 0; j < 8; j++)\n+\tfor (k = 0; k < 4; k++)\n+\t  if (b[i][j][k] != 3 * (i >= 3 && i < N / 16 - 1 && (j & 1) == 0 && k >= 1))\n+\t    abort ();\n+    #pragma omp for collapse(3) nowait\n+    for (i = 0; i < N / 32; i++)\n+      for (j = 0; j < 8; j++)\n+\tfor (k = 0; k < 8; k++)\n+\t  if (c[i][j][k] != 3 * (i >= 2 && j >= 2 && (k & 1) == 0))\n+\t    abort ();\n+    #pragma omp for collapse(2) private(k) nowait\n+    for (i = 0; i < N / 16; i++)\n+      for (j = 0; j < 8; j++)\n+\tfor (k = 0; k < 6; k++)\n+\t  if (g[i][j][k] != 3 * (i < N / 16 - 1 && (j & 1) == 0 && k >= 3))\n+\t    abort ();\n+  }\n+  return 0;\n+}"}, {"sha": "7bb1993647c42f95a2f73655fd02285bd5eb2487", "filename": "libgomp/testsuite/libgomp.c/doacross-5.c", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25a6767ec28780a3e3b6d38f5e54e1122a26fd6/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25a6767ec28780a3e3b6d38f5e54e1122a26fd6/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-5.c?ref=f25a6767ec28780a3e3b6d38f5e54e1122a26fd6", "patch": "@@ -0,0 +1,198 @@\n+extern void abort (void);\n+\n+#define N 256\n+int a[N], b[N / 16][8][4], c[N / 32][8][8];\n+volatile int d, e;\n+\n+int\n+main ()\n+{\n+  int i, j, k, l, m;\n+  #pragma omp parallel private (l)\n+  {\n+    #pragma omp for schedule(static, 1) ordered (1) nowait\n+    for (i = 0; i < N; i++)\n+      {\n+\t#pragma omp atomic write\n+\ta[i] = 1;\n+\t#pragma omp ordered doacross(sink: omp_cur_iteration - 1)\n+\tif (i)\n+\t  {\n+\t    #pragma omp atomic read\n+\t    l = a[i - 1];\n+\t    if (l < 2)\n+\t      abort ();\n+\t  }\n+\t#pragma omp atomic write\n+\ta[i] = 2;\n+\tif (i < N - 1)\n+\t  {\n+\t    #pragma omp atomic read\n+\t    l = a[i + 1];\n+\t    if (l == 3)\n+\t      abort ();\n+\t  }\n+\t#pragma omp ordered doacross(source :)\n+\t#pragma omp atomic write\n+\ta[i] = 3;\n+      }\n+    #pragma omp for schedule(static) ordered (3) nowait\n+    for (i = 2; i < N / 16 - 1; i++)\n+      for (j = 0; j < 8; j += 2)\n+\tfor (k = 1; k <= 3; k++)\n+\t  {\n+\t    #pragma omp atomic write\n+\t    b[i][j][k] = 1;\n+\t    #pragma omp ordered doacross(sink: omp_cur_iteration - 1) \\\n+\t\t\t\tdoacross(sink: i - 2, j - 2, k + 1)\n+\t    #pragma omp ordered doacross(sink: i - 3, j + 2, k - 2)\n+\t    if (i != 2 || j || k != 1)\n+\t      {\n+\t\tif (k != 1)\n+\t\t  #pragma omp atomic read\n+\t\t  l = b[i][j][k - 1];\n+\t\telse if (j)\n+\t\t  #pragma omp atomic read\n+\t\t  l = b[i][j - 2][3];\n+\t\telse\n+\t\t  #pragma omp atomic read\n+\t\t  l = b[i - 1][6][3];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    #pragma omp atomic write\n+\t    b[i][j][k] = 2;\n+\t    if (i >= 4 && j >= 2 && k < 3)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = b[i - 2][j - 2][k + 1];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    if (i >= 5 && j < N / 16 - 3 && k == 3)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = b[i - 3][j + 2][k - 2];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    #pragma omp ordered doacross(source : omp_cur_iteration)\n+\t    #pragma omp atomic write\n+\t    b[i][j][k] = 3;\n+\t  }\n+#define A(n) int n;\n+#define B(n) A(n##0) A(n##1) A(n##2) A(n##3)\n+#define C(n) B(n##0) B(n##1) B(n##2) B(n##3)\n+#define D(n) C(n##0) C(n##1) C(n##2) C(n##3)\n+    D(m)\n+#undef A\n+    #pragma omp for collapse (2) ordered(61) schedule(dynamic, 15)\n+    for (i = 0; i < N / 32; i++)\n+      for (j = 7; j > 1; j--)\n+\tfor (k = 6; k >= 0; k -= 2)\n+#define A(n) for (n = 4; n < 5; n++)\n+\t  D(m)\n+#undef A\n+\t    {\n+\t      #pragma omp atomic write\n+\t      c[i][j][k] = 1;\n+#define A(n) ,n\n+#define E(n) C(n##0) C(n##1) C(n##2) B(n##30) B(n##31) A(n##320) A(n##321)\n+\t      #pragma omp ordered doacross (sink: i, j, k + 2 E(m)) \\\n+\t\t\t\t  doacross (sink:omp_cur_iteration - 1) \\\n+\t\t\t\t  doacross(sink: i - 1, j - 2, k - 2 E(m))\n+\t      if (k <= 4)\n+\t\t{\n+\t\t  #pragma omp atomic read\n+\t\t  l = c[i][j][k + 2];\n+\t\t  if (l < 2)\n+\t\t    abort ();\n+\t\t}\n+\t      #pragma omp atomic write\n+\t      c[i][j][k] = 2;\n+\t      if (i || j != 7 && k != 6)\n+\t\t{\n+\t\t  if (k != 6)\n+\t\t    #pragma omp atomic read\n+\t\t    l = c[i][j][k + 2];\n+\t\t  else if (j != 7)\n+\t\t    #pragma omp atomic read\n+\t\t    l = c[i][j + 1][0];\n+\t\t  else\n+\t\t    #pragma omp atomic read\n+\t\t    l = c[i - 1][2][0];\n+\t\t  if (l < 2)\n+\t\t    abort ();\n+\t\t}\n+\t      if (i >= 1 && j >= 4 && k >= 2)\n+\t\t{\n+\t\t  #pragma omp atomic read\n+\t\t  l = c[i - 1][j - 2][k - 2];\n+\t\t  if (l < 2)\n+\t\t    abort ();\n+\t\t}\n+\t      #pragma omp ordered doacross (source: )\n+\t      #pragma omp atomic write\n+\t      c[i][j][k] = 3;\n+\t    }\n+\n+    #pragma omp for collapse(2) ordered(4) lastprivate (i, j, k)\n+    for (i = 0; i < d + 1; i++)\n+      for (j = d + 1; j >= 0; j--)\n+\tfor (k = 0; k < d; k++)\n+\t  for (l = 0; l < d + 2; l++)\n+\t    {\n+\t      #pragma omp ordered doacross (source : omp_cur_iteration)\n+\t      #pragma omp ordered doacross (sink: omp_cur_iteration - 1)\n+\t      if (!e)\n+\t\tabort ();\n+\t    }\n+    #pragma omp single\n+    {\n+      if (i != 1 || j != -1 || k != 0)\n+\tabort ();\n+      i = 8; j = 9; k = 10;\n+    }\n+    #pragma omp for collapse(2) ordered(4) lastprivate (i, j, k, m)\n+    for (i = 0; i < d + 1; i++)\n+      for (j = d + 1; j >= 0; j--)\n+\tfor (k = 0; k < d + 2; k++)\n+\t  for (m = 0; m < d; m++)\n+\t    {\n+\t      #pragma omp ordered doacross (source : )\n+\t      #pragma omp ordered doacross (sink:omp_cur_iteration - 1)\n+\t      abort ();\n+\t    }\n+    #pragma omp single\n+    if (i != 1 || j != -1 || k != 2 || m != 0)\n+      abort ();\n+    #pragma omp for collapse(2) ordered(4) nowait\n+    for (i = 0; i < d + 1; i++)\n+      for (j = d; j > 0; j--)\n+\tfor (k = 0; k < d + 2; k++)\n+\t  for (l = 0; l < d + 4; l++)\n+\t    {\n+\t      #pragma omp ordered doacross (source : omp_cur_iteration)\n+\t      #pragma omp ordered doacross (sink:omp_cur_iteration - 1)\n+\t      if (!e)\n+\t\tabort ();\n+\t    }\n+    #pragma omp for nowait\n+    for (i = 0; i < N; i++)\n+      if (a[i] != 3)\n+\tabort ();\n+    #pragma omp for collapse(2) private(k) nowait\n+    for (i = 0; i < N / 16; i++)\n+      for (j = 0; j < 8; j++)\n+\tfor (k = 0; k < 4; k++)\n+\t  if (b[i][j][k] != 3 * (i >= 2 && i < N / 16 - 1 && (j & 1) == 0 && k >= 1))\n+\t    abort ();\n+    #pragma omp for collapse(3) nowait\n+    for (i = 0; i < N / 32; i++)\n+      for (j = 0; j < 8; j++)\n+\tfor (k = 0; k < 8; k++)\n+\t  if (c[i][j][k] != 3 * (j >= 2 && (k & 1) == 0))\n+\t    abort ();\n+  }\n+  return 0;\n+}"}, {"sha": "de5dee6f60727c6d2fc410222321b1b7374b4830", "filename": "libgomp/testsuite/libgomp.c/doacross-6.c", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25a6767ec28780a3e3b6d38f5e54e1122a26fd6/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25a6767ec28780a3e3b6d38f5e54e1122a26fd6/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-6.c?ref=f25a6767ec28780a3e3b6d38f5e54e1122a26fd6", "patch": "@@ -0,0 +1,231 @@\n+extern void abort (void);\n+\n+#define N 256\n+int a[N], b[N / 16][8][4], c[N / 32][8][8], g[N / 16][8][6];\n+volatile int d, e;\n+volatile unsigned long long f;\n+\n+int\n+main ()\n+{\n+  unsigned long long i;\n+  int j, k, l, m;\n+  #pragma omp parallel private (l)\n+  {\n+    #pragma omp for schedule(static, 1) ordered (1) nowait\n+    for (i = 1; i < N + f; i++)\n+      {\n+\t#pragma omp atomic write\n+\ta[i] = 1;\n+\t#pragma omp ordered doacross(sink: omp_cur_iteration - 1)\n+\tif (i > 1)\n+\t  {\n+\t    #pragma omp atomic read\n+\t    l = a[i - 1];\n+\t    if (l < 2)\n+\t      abort ();\n+\t  }\n+\t#pragma omp atomic write\n+\ta[i] = 2;\n+\tif (i < N - 1)\n+\t  {\n+\t    #pragma omp atomic read\n+\t    l = a[i + 1];\n+\t    if (l == 3)\n+\t      abort ();\n+\t  }\n+\t#pragma omp ordered doacross(source : omp_cur_iteration)\n+\t#pragma omp atomic write\n+\ta[i] = 3;\n+      }\n+    #pragma omp for schedule(static) ordered (3) nowait\n+    for (i = 3; i < N / 16 - 1 + f; i++)\n+      for (j = 0; j < 8; j += 2)\n+\tfor (k = 1; k <= 3; k++)\n+\t  {\n+\t    #pragma omp atomic write\n+\t    b[i][j][k] = 1;\n+\t    #pragma omp ordered doacross(sink: i, j - 2, k - 1) \\\n+\t\t\t\tdoacross(sink: i - 2, j - 2, k + 1)\n+\t    #pragma omp ordered doacross(sink: omp_cur_iteration - 1)\n+\t    if (j >= 2 && k > 1)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = b[i][j - 2][k - 1];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    #pragma omp atomic write\n+\t    b[i][j][k] = 2;\n+\t    if (i >= 5 && j >= 2 && k < 3)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = b[i - 2][j - 2][k + 1];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    if (i != 3 || j || k != 1)\n+\t      {\n+\t\tif (k != 1)\n+\t\t  #pragma omp atomic read\n+\t\t  l = b[i][j][k - 1];\n+\t\telse if (j)\n+\t\t  #pragma omp atomic read\n+\t\t  l = b[i][j - 2][3];\n+\t\telse\n+\t\t  #pragma omp atomic read\n+\t\t  l = b[i - 1][6][3];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    #pragma omp ordered doacross(source:)\n+\t    #pragma omp atomic write\n+\t    b[i][j][k] = 3;\n+\t  }\n+#define A(n) int n;\n+#define B(n) A(n##0) A(n##1) A(n##2) A(n##3)\n+#define C(n) B(n##0) B(n##1) B(n##2) B(n##3)\n+#define D(n) C(n##0) C(n##1) C(n##2) C(n##3)\n+    D(m)\n+#undef A\n+    #pragma omp for collapse (2) ordered(61) schedule(dynamic, 15)\n+    for (i = 2; i < N / 32 + f; i++)\n+      for (j = 7; j > 1; j--)\n+\tfor (k = 6; k >= 0; k -= 2)\n+#define A(n) for (n = 4; n < 5; n++)\n+\t  D(m)\n+#undef A\n+\t    {\n+\t      #pragma omp atomic write\n+\t      c[i][j][k] = 1;\n+\t      #pragma omp ordered doacross (sink: omp_cur_iteration - 1)\n+\t      if (i != 2 || j != 7 || k != 6)\n+\t\t{\n+\t\t  if (k != 6)\n+\t\t    #pragma omp atomic read\n+\t\t    l = c[i][j][k + 2];\n+\t\t  else if (j != 7)\n+\t\t    #pragma omp atomic read\n+\t\t    l = c[i][j + 1][0];\n+\t\t  else\n+\t\t    #pragma omp atomic read\n+\t\t    l = c[i - 1][2][0];\n+\t\t  if (l < 2)\n+\t\t    abort ();\n+\t\t}\n+\t      #pragma omp atomic write\n+\t      c[i][j][k] = 2;\n+\t      #pragma omp ordered doacross (source:)\n+\t      #pragma omp atomic write\n+\t      c[i][j][k] = 3;\n+\t    }\n+    #pragma omp for schedule(static) ordered (3) nowait\n+    for (j = 0; j < N / 16 - 1; j++)\n+      for (k = 0; k < 8; k += 2)\n+\tfor (i = 3; i <= 5 + f; i++)\n+\t  {\n+\t    #pragma omp atomic write\n+\t    g[j][k][i] = 1;\n+\t    #pragma omp ordered doacross(sink: j, k - 2, i - 1) \\\n+\t\t\t\tdoacross(sink: omp_cur_iteration - 1)\n+\t    #pragma omp ordered doacross(sink: j - 3, k + 2, i - 2)\n+\t    if (k >= 2 && i > 3)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = g[j][k - 2][i - 1];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    #pragma omp atomic write\n+\t    g[j][k][i] = 2;\n+\t    if (j || k || i != 3)\n+\t      {\n+\t\tif (i != 3)\n+\t\t  #pragma omp atomic read\n+\t\t  l = g[j][k][i - 1];\n+\t\telse if (k)\n+\t\t  #pragma omp atomic read\n+\t\t  l = g[j][k - 2][5 + f];\n+\t\telse\n+\t\t  #pragma omp atomic read\n+\t\t  l = g[j - 1][6][5 + f];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    if (j >= 3 && k < N / 16 - 3 && i == 5)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = g[j - 3][k + 2][i - 2];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    #pragma omp ordered doacross(source : omp_cur_iteration)\n+\t    #pragma omp atomic write\n+\t    g[j][k][i] = 3;\n+\t  }\n+    #pragma omp for collapse(2) ordered(4) lastprivate (i, j, k)\n+    for (i = 2; i < f + 3; i++)\n+      for (j = d + 1; j >= 0; j--)\n+\tfor (k = 0; k < d; k++)\n+\t  for (l = 0; l < d + 2; l++)\n+\t    {\n+\t      #pragma omp ordered doacross (source : omp_cur_iteration)\n+\t      #pragma omp ordered doacross (sink:omp_cur_iteration - 1)\n+\t      if (!e)\n+\t\tabort ();\n+\t    }\n+    #pragma omp single\n+    {\n+      if (i != 3 || j != -1 || k != 0)\n+\tabort ();\n+      i = 8; j = 9; k = 10;\n+    }\n+    #pragma omp for collapse(2) ordered(4) lastprivate (i, j, k, m)\n+    for (i = 2; i < f + 3; i++)\n+      for (j = d + 1; j >= 0; j--)\n+\tfor (k = 0; k < d + 2; k++)\n+\t  for (m = 0; m < d; m++)\n+\t    {\n+\t      #pragma omp ordered doacross (source : omp_cur_iteration)\n+\t      #pragma omp ordered doacross (sink:omp_cur_iteration - 1)\n+\t      abort ();\n+\t    }\n+    #pragma omp single\n+    if (i != 3 || j != -1 || k != 2 || m != 0)\n+      abort ();\n+    #pragma omp for collapse(2) ordered(4) nowait\n+    for (i = 2; i < f + 3; i++)\n+      for (j = d; j > 0; j--)\n+\tfor (k = 0; k < d + 2; k++)\n+\t  for (l = 0; l < d + 4; l++)\n+\t    {\n+\t      #pragma omp ordered doacross (source:)\n+\t      #pragma omp ordered doacross (sink:omp_cur_iteration-1)\n+\t      if (!e)\n+\t\tabort ();\n+\t    }\n+    #pragma omp for nowait\n+    for (i = 0; i < N; i++)\n+      if (a[i] != 3 * (i >= 1))\n+\tabort ();\n+    #pragma omp for collapse(2) private(k) nowait\n+    for (i = 0; i < N / 16; i++)\n+      for (j = 0; j < 8; j++)\n+\tfor (k = 0; k < 4; k++)\n+\t  if (b[i][j][k] != 3 * (i >= 3 && i < N / 16 - 1 && (j & 1) == 0 && k >= 1))\n+\t    abort ();\n+    #pragma omp for collapse(3) nowait\n+    for (i = 0; i < N / 32; i++)\n+      for (j = 0; j < 8; j++)\n+\tfor (k = 0; k < 8; k++)\n+\t  if (c[i][j][k] != 3 * (i >= 2 && j >= 2 && (k & 1) == 0))\n+\t    abort ();\n+    #pragma omp for collapse(2) private(k) nowait\n+    for (i = 0; i < N / 16; i++)\n+      for (j = 0; j < 8; j++)\n+\tfor (k = 0; k < 6; k++)\n+\t  if (g[i][j][k] != 3 * (i < N / 16 - 1 && (j & 1) == 0 && k >= 3))\n+\t    abort ();\n+  }\n+  return 0;\n+}"}, {"sha": "f0ad38849dd320c176013aacba22fc25634897c9", "filename": "libgomp/testsuite/libgomp.c/doacross-7.c", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25a6767ec28780a3e3b6d38f5e54e1122a26fd6/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25a6767ec28780a3e3b6d38f5e54e1122a26fd6/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fdoacross-7.c?ref=f25a6767ec28780a3e3b6d38f5e54e1122a26fd6", "patch": "@@ -0,0 +1,231 @@\n+extern void abort (void);\n+\n+#define N 256\n+int a[N], b[N / 16][8][4], c[N / 32][8][8], g[N / 16][8][6];\n+volatile int d, e;\n+volatile unsigned long long f;\n+\n+int\n+main ()\n+{\n+  unsigned long long i;\n+  int j, k, l, m;\n+  #pragma omp parallel private (l)\n+  {\n+    #pragma omp for schedule(guided, 3) ordered (1) nowait\n+    for (i = 1; i < N + f; i++)\n+      {\n+\t#pragma omp atomic write\n+\ta[i] = 1;\n+\t#pragma omp ordered doacross(sink: omp_cur_iteration - 1)\n+\tif (i > 1)\n+\t  {\n+\t    #pragma omp atomic read\n+\t    l = a[i - 1];\n+\t    if (l < 2)\n+\t      abort ();\n+\t  }\n+\t#pragma omp atomic write\n+\ta[i] = 2;\n+\tif (i < N - 1)\n+\t  {\n+\t    #pragma omp atomic read\n+\t    l = a[i + 1];\n+\t    if (l == 3)\n+\t      abort ();\n+\t  }\n+\t#pragma omp ordered doacross(source : omp_cur_iteration)\n+\t#pragma omp atomic write\n+\ta[i] = 3;\n+      }\n+    #pragma omp for schedule(guided) ordered (3) nowait\n+    for (i = 3; i < N / 16 - 1 + f; i++)\n+      for (j = 0; j < 8; j += 2)\n+\tfor (k = 1; k <= 3; k++)\n+\t  {\n+\t    #pragma omp atomic write\n+\t    b[i][j][k] = 1;\n+\t    #pragma omp ordered doacross(sink: i, j - 2, k - 1) \\\n+\t\t\t\tdoacross(sink: i - 2, j - 2, k + 1)\n+\t    #pragma omp ordered doacross(sink: omp_cur_iteration - 1)\n+\t    if (j >= 2 && k > 1)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = b[i][j - 2][k - 1];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    #pragma omp atomic write\n+\t    b[i][j][k] = 2;\n+\t    if (i >= 5 && j >= 2 && k < 3)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = b[i - 2][j - 2][k + 1];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    if (i != 3 || j || k != 1)\n+\t      {\n+\t\tif (k != 1)\n+\t\t  #pragma omp atomic read\n+\t\t  l = b[i][j][k - 1];\n+\t\telse if (j)\n+\t\t  #pragma omp atomic read\n+\t\t  l = b[i][j - 2][3];\n+\t\telse\n+\t\t  #pragma omp atomic read\n+\t\t  l = b[i - 1][6][3];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    #pragma omp ordered doacross(source:)\n+\t    #pragma omp atomic write\n+\t    b[i][j][k] = 3;\n+\t  }\n+#define A(n) int n;\n+#define B(n) A(n##0) A(n##1) A(n##2) A(n##3)\n+#define C(n) B(n##0) B(n##1) B(n##2) B(n##3)\n+#define D(n) C(n##0) C(n##1) C(n##2) C(n##3)\n+    D(m)\n+#undef A\n+    #pragma omp for collapse (2) ordered(61) schedule(guided, 15)\n+    for (i = 2; i < N / 32 + f; i++)\n+      for (j = 7; j > 1; j--)\n+\tfor (k = 6; k >= 0; k -= 2)\n+#define A(n) for (n = 4; n < 5; n++)\n+\t  D(m)\n+#undef A\n+\t    {\n+\t      #pragma omp atomic write\n+\t      c[i][j][k] = 1;\n+\t      #pragma omp ordered doacross (sink: omp_cur_iteration - 1)\n+\t      if (i != 2 || j != 7 || k != 6)\n+\t\t{\n+\t\t  if (k != 6)\n+\t\t    #pragma omp atomic read\n+\t\t    l = c[i][j][k + 2];\n+\t\t  else if (j != 7)\n+\t\t    #pragma omp atomic read\n+\t\t    l = c[i][j + 1][0];\n+\t\t  else\n+\t\t    #pragma omp atomic read\n+\t\t    l = c[i - 1][2][0];\n+\t\t  if (l < 2)\n+\t\t    abort ();\n+\t\t}\n+\t      #pragma omp atomic write\n+\t      c[i][j][k] = 2;\n+\t      #pragma omp ordered doacross (source:)\n+\t      #pragma omp atomic write\n+\t      c[i][j][k] = 3;\n+\t    }\n+    #pragma omp for schedule(guided, 5) ordered (3) nowait\n+    for (j = 0; j < N / 16 - 1; j++)\n+      for (k = 0; k < 8; k += 2)\n+\tfor (i = 3; i <= 5 + f; i++)\n+\t  {\n+\t    #pragma omp atomic write\n+\t    g[j][k][i] = 1;\n+\t    #pragma omp ordered doacross(sink: j, k - 2, i - 1) \\\n+\t\t\t\tdoacross(sink: omp_cur_iteration - 1)\n+\t    #pragma omp ordered doacross(sink: j - 3, k + 2, i - 2)\n+\t    if (k >= 2 && i > 3)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = g[j][k - 2][i - 1];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    #pragma omp atomic write\n+\t    g[j][k][i] = 2;\n+\t    if (j || k || i != 3)\n+\t      {\n+\t\tif (i != 3)\n+\t\t  #pragma omp atomic read\n+\t\t  l = g[j][k][i - 1];\n+\t\telse if (k)\n+\t\t  #pragma omp atomic read\n+\t\t  l = g[j][k - 2][5 + f];\n+\t\telse\n+\t\t  #pragma omp atomic read\n+\t\t  l = g[j - 1][6][5 + f];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    if (j >= 3 && k < N / 16 - 3 && i == 5)\n+\t      {\n+\t\t#pragma omp atomic read\n+\t\tl = g[j - 3][k + 2][i - 2];\n+\t\tif (l < 2)\n+\t\t  abort ();\n+\t      }\n+\t    #pragma omp ordered doacross(source : omp_cur_iteration)\n+\t    #pragma omp atomic write\n+\t    g[j][k][i] = 3;\n+\t  }\n+    #pragma omp for collapse(2) ordered(4) lastprivate (i, j, k)\n+    for (i = 2; i < f + 3; i++)\n+      for (j = d + 1; j >= 0; j--)\n+\tfor (k = 0; k < d; k++)\n+\t  for (l = 0; l < d + 2; l++)\n+\t    {\n+\t      #pragma omp ordered doacross (source : omp_cur_iteration)\n+\t      #pragma omp ordered doacross (sink:omp_cur_iteration - 1)\n+\t      if (!e)\n+\t\tabort ();\n+\t    }\n+    #pragma omp single\n+    {\n+      if (i != 3 || j != -1 || k != 0)\n+\tabort ();\n+      i = 8; j = 9; k = 10;\n+    }\n+    #pragma omp for collapse(2) ordered(4) lastprivate (i, j, k, m)\n+    for (i = 2; i < f + 3; i++)\n+      for (j = d + 1; j >= 0; j--)\n+\tfor (k = 0; k < d + 2; k++)\n+\t  for (m = 0; m < d; m++)\n+\t    {\n+\t      #pragma omp ordered doacross (source : omp_cur_iteration)\n+\t      #pragma omp ordered doacross (sink:omp_cur_iteration - 1)\n+\t      abort ();\n+\t    }\n+    #pragma omp single\n+    if (i != 3 || j != -1 || k != 2 || m != 0)\n+      abort ();\n+    #pragma omp for collapse(2) ordered(4) nowait\n+    for (i = 2; i < f + 3; i++)\n+      for (j = d; j > 0; j--)\n+\tfor (k = 0; k < d + 2; k++)\n+\t  for (l = 0; l < d + 4; l++)\n+\t    {\n+\t      #pragma omp ordered doacross (source:)\n+\t      #pragma omp ordered doacross (sink:omp_cur_iteration-1)\n+\t      if (!e)\n+\t\tabort ();\n+\t    }\n+    #pragma omp for nowait\n+    for (i = 0; i < N; i++)\n+      if (a[i] != 3 * (i >= 1))\n+\tabort ();\n+    #pragma omp for collapse(2) private(k) nowait\n+    for (i = 0; i < N / 16; i++)\n+      for (j = 0; j < 8; j++)\n+\tfor (k = 0; k < 4; k++)\n+\t  if (b[i][j][k] != 3 * (i >= 3 && i < N / 16 - 1 && (j & 1) == 0 && k >= 1))\n+\t    abort ();\n+    #pragma omp for collapse(3) nowait\n+    for (i = 0; i < N / 32; i++)\n+      for (j = 0; j < 8; j++)\n+\tfor (k = 0; k < 8; k++)\n+\t  if (c[i][j][k] != 3 * (i >= 2 && j >= 2 && (k & 1) == 0))\n+\t    abort ();\n+    #pragma omp for collapse(2) private(k) nowait\n+    for (i = 0; i < N / 16; i++)\n+      for (j = 0; j < 8; j++)\n+\tfor (k = 0; k < 6; k++)\n+\t  if (g[i][j][k] != 3 * (i < N / 16 - 1 && (j & 1) == 0 && k >= 3))\n+\t    abort ();\n+  }\n+  return 0;\n+}"}]}