{"sha": "f439901c10edf6de3b471f68eb535241ed35eb8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQzOTkwMWMxMGVkZjZkZTNiNDcxZjY4ZWI1MzUyNDFlZDM1ZWI4ZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-07-04T10:10:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-07-04T10:10:39Z"}, "message": "New file.\n\nFrom-SVN: r101569", "tree": {"sha": "9f10939139735d56445565a42e3e0b20dae58b7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f10939139735d56445565a42e3e0b20dae58b7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f439901c10edf6de3b471f68eb535241ed35eb8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f439901c10edf6de3b471f68eb535241ed35eb8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f439901c10edf6de3b471f68eb535241ed35eb8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f439901c10edf6de3b471f68eb535241ed35eb8e/comments", "author": null, "committer": null, "parents": [{"sha": "c4c756daf850ee938a2dbfa8e04b6cb609127179", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4c756daf850ee938a2dbfa8e04b6cb609127179", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4c756daf850ee938a2dbfa8e04b6cb609127179"}], "stats": {"total": 385, "additions": 385, "deletions": 0}, "files": [{"sha": "3823ebe9aaa24fcc328e2e71f0370d27165267e6", "filename": "gcc/ada/s-stausa.adb", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f439901c10edf6de3b471f68eb535241ed35eb8e/gcc%2Fada%2Fs-stausa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f439901c10edf6de3b471f68eb535241ed35eb8e/gcc%2Fada%2Fs-stausa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stausa.adb?ref=f439901c10edf6de3b471f68eb535241ed35eb8e", "patch": "@@ -0,0 +1,96 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M - S T A C K _ U S A G E                    --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--         Copyright (C) 2004-2005, Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+--  Dummy implementation.\n+\n+package body System.Stack_Usage is\n+\n+   --------------------\n+   -- Compute_Result --\n+   --------------------\n+\n+   procedure Compute_Result (Analyzer : in out Stack_Analyzer) is\n+      pragma Unreferenced (Analyzer);\n+   begin\n+      null;\n+   end Compute_Result;\n+\n+   ----------------\n+   -- Fill_Stack --\n+   ----------------\n+\n+   procedure Fill_Stack (Analyzer : in out Stack_Analyzer) is\n+      pragma Unreferenced (Analyzer);\n+   begin\n+      null;\n+   end Fill_Stack;\n+\n+   -------------------------\n+   -- Initialize_Analyzer --\n+   -------------------------\n+\n+   procedure Initialize_Analyzer\n+     (Analyzer  : in out Stack_Analyzer;\n+      Task_Name : String;\n+      Size      : Natural;\n+      Bottom    : Stack_Address;\n+      Pattern   : Word_32 := 16#DEAD_BEEF#)\n+   is\n+      pragma Unreferenced (Analyzer);\n+      pragma Unreferenced (Task_Name);\n+      pragma Unreferenced (Size);\n+      pragma Unreferenced (Pattern);\n+      pragma Unreferenced (Bottom);\n+   begin\n+      null;\n+   end Initialize_Analyzer;\n+\n+   ---------------------\n+   --  Output_Results --\n+   ---------------------\n+\n+   procedure Output_Results is\n+   begin\n+      null;\n+   end Output_Results;\n+\n+   -------------------\n+   -- Report_Result --\n+   -------------------\n+\n+   procedure Report_Result (Analyzer : Stack_Analyzer) is\n+      pragma Unreferenced (Analyzer);\n+   begin\n+      null;\n+   end Report_Result;\n+\n+end System.Stack_Usage;"}, {"sha": "0c0d8eb17b2fc8edfdcdd35b8f4b575bdd482ff9", "filename": "gcc/ada/s-stausa.ads", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f439901c10edf6de3b471f68eb535241ed35eb8e/gcc%2Fada%2Fs-stausa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f439901c10edf6de3b471f68eb535241ed35eb8e/gcc%2Fada%2Fs-stausa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stausa.ads?ref=f439901c10edf6de3b471f68eb535241ed35eb8e", "patch": "@@ -0,0 +1,289 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M - S T A C K _ U S A G E                    --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--         Copyright (C) 2004-2005, Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System;\n+with System.Storage_Elements;\n+with System.Address_To_Access_Conversions;\n+\n+package System.Stack_Usage is\n+\n+   package SSE renames System.Storage_Elements;\n+\n+   Byte_Size : constant := 8;\n+   Word_32_Size : constant := 4 * Byte_Size;\n+\n+   type Word_32 is mod 2 ** Word_32_Size;\n+   for Word_32'Alignment use 4;\n+\n+   subtype Stack_Address is SSE.Integer_Address;\n+   --  Address on the stack.\n+   --\n+   --  NOTE:\n+   --  *****\n+   --\n+   --  in this package, when comparing two addresses on the\n+   --  stack, the comments use the terms \"outer\", \"inner\", \"outermost\"\n+   --  and \"innermost\" instead of the ambigous \"higher\", \"lower\",\n+   --  \"highest\" and \"lowest\". \"inner\" means \"closer to the bottom of\n+   --  stack\" and is the contrary of \"outer\". \"innermost\" means \"closest\n+   --  address to the bottom of stack\". The stack is growing from the\n+   --  innermost addresses to the outermost addresses.\n+\n+   function To_Stack_Address (Value : Address) return Stack_Address\n+     renames System.Storage_Elements.To_Integer;\n+\n+   type Stack_Analyzer is private;\n+   --  Type of the stack analyzer tool. It is used to fill a portion of\n+   --  the stack with Pattern, and to compute the stack used after some\n+   --  execution.\n+   --\n+   --  USAGE:\n+   --  ******\n+   --\n+   --  --  A typical use of the package is something like:\n+   --\n+   --  A : Stack_Analyzer;\n+   --\n+   --  task T is\n+   --     pragma Storage_Size (A_Storage_Size);\n+   --  end T;\n+   --\n+   --  [...]\n+   --\n+   --     Bottom_Of_Stack : aliased Integer;\n+   --     --  Bottom_Of_Stack'Address will be used as an approximation of\n+   --     --  the bottom of stack. A good practise is to avoid allocating\n+   --     --  other local variables on this stack, as it would degrade\n+   --     --  the quality of this approximation.\n+   --\n+   --  begin\n+   --     Initialize_Analyzer (A,\n+   --                          \"Task t\",\n+   --                          A_Storage_Size - A_Guard,\n+   --                          To_Stack_Address (Bottom_Of_Stack'Address));\n+   --     Fill_Stack (A);\n+   --     Some_User_Code;\n+   --     Compute_Result (A);\n+   --     Report_Result (A);\n+   --  end T;\n+   --\n+   --\n+   --  Errors:\n+   --  *******\n+   --\n+   --  We are instrumenting the code to measure the stack used by the user\n+   --  code. This method has a number of systematic errors, but several\n+   --  methods can be used to evaluate or reduce those errors. Here are\n+   --  those errors and the strategy that we use to deal with them:\n+   --\n+   --  * Bottom offset:\n+   --   - Description: The procedure used to fill the stack with a given\n+   --   pattern will itself have a stack frame. The value of the stack pointer\n+   --   in this procedure is, therefore, different from the value before the\n+   --   call to the instrumentation procedure.\n+   --   - Strategy: The user of this package shall measure the bottom of stack\n+   --   before the call to Fill_Stack and pass it in parameter.\n+   --\n+   --  * Instrumentation threshold at writing:\n+   --   - Description: The procedure used to fill the stack with a given\n+   --   pattern will itself have a stack frame.  Therefore, it will\n+   --   fill the stack after this stack frame. This part of the stack will\n+   --   appear as used in the final measure.\n+   --   - Strategy: As the user pass the value of the bottom of stack to\n+   --   the instrumentation to deal with the bottom offset error, and as\n+   --   as the instrumentation procedure knows where the pattern filling\n+   --   start on the stack, the difference between the two values is the\n+   --   minimum stack usage that the method can measure. If, when the results\n+   --   are computed, the pattern zone has been left untouched, we conclude\n+   --   that the stack usage is inferior to this minimum stack usage.\n+   --\n+   --  * Instrumentation threshold at reading:\n+   --   - Description: The procedure used to read the stack at the end of the\n+   --   execution clobbers the stack by allocating its stack frame. If this\n+   --   stack frame is bigger than the total stack used by the user code at\n+   --   this point, it will increase the measured stack size.\n+   --   - Strategy: We could augment this stack frame and see if it changes the\n+   --   measure. However, this error should be negligeable.\n+   --\n+   --   * Pattern zone overflow:\n+   --    - Description: The stack grows outer than the outermost bound of the\n+   --    pattern zone. In that case, the outermost region modified in the\n+   --    pattern is not the maximum value of the stack pointer during the\n+   --    execution.\n+   --    - Strategy: At the end of the execution, the difference between the\n+   --    outermost memory region modified in the pattern zone and the\n+   --    outermost bound of the pattern zone can be understood as the\n+   --    biggest allocation that the method could have detect, provided\n+   --    that there is no \"Untouched allocated zone\" error and no \"Pattern\n+   --    usage in user code\" error. If no object in the user code is likely\n+   --    to have this size, this is not likely to happen.\n+   --\n+   --   * Pattern usage in user code:\n+   --    - Description: The pattern can be found in the object of the user\n+   --    code. Therefore, the address space where this object has been\n+   --    allocated will appear as untouched.\n+   --    - Strategy: Choose a pattern that is uncommon. 16#0000_0000# is the\n+   --    worst choice; 16#DEAD_BEEF# can be a good one. A good choice is an\n+   --    address which is not a multiple of 2, and which is not in the\n+   --    target address space. You can also change the pattern to see if\n+   --    it changes the measure. Note that this error *very* rarely influence\n+   --    the measure of the total stack usage: to have some influence, the\n+   --    pattern has to be used in the object that has been allocated on the\n+   --    outermost address of the used stack.\n+   --\n+   --   * Stack overflow:\n+   --    - Description: The pattern zone does not fit on the stack.\n+   --    This may lead to an erroneous execution.\n+   --    - Strategy: Specify a storage size that is bigger than the\n+   --    size of the pattern. 2 times bigger should be enough.\n+   --\n+   --   * Augmentation of the user stack frames:\n+   --    - Description: The use of instrumentation object or procedure may\n+   --    augment the stack frame of the caller.\n+   --    - Strategy: Do *not* inline the instrumentation procedures. Do *not*\n+   --    allocate the Stack_Analyzer object on the stack.\n+   --\n+   --   * Untouched allocated zone:\n+   --    - Description: The user code may allocate objects that it will never\n+   --    touch. In that case, the pattern will not be changed.\n+   --    - Strategy: There are no way to detect this error. Fortunately, this\n+   --    error is really rare, and it is most probably a bug in the user code,\n+   --    e.g. some uninitialized variable. It is (most of the time) harmless:\n+   --    it influences the measure only if the untouched allocated zone\n+   --    happens to be located at the outermost value of the stack pointer\n+   --    for the whole execution.\n+\n+   procedure Fill_Stack (Analyzer : in out Stack_Analyzer);\n+   --  Fill an area of the stack with the pattern Analyzer.Pattern. The size\n+   --  of this area is Analyzer.Size. After the call to this procedure,\n+   --  the memory will look like that:\n+   --\n+   --                                                             Stack growing\n+   --  ----------------------------------------------------------------------->\n+   --  |<---------------------->|<----------------------------------->|\n+   --  |  Stack frame           | Memory filled with Analyzer.Pattern |\n+   --  |  of Fill_Stack         |                                     |\n+   --  |  (deallocated at       |                                     |\n+   --  |  the end of the call)  |                                     |\n+   --  ^                        |                                     |\n+   --  Analyzer.Bottom_Of_Stack ^                                     |\n+   --                    Analyzer.Inner_Pattern_Mark                  ^\n+   --                                            Analyzer.Outer_Pattern_Mark\n+\n+   procedure Compute_Result (Analyzer : in out Stack_Analyzer);\n+   --  Read the patern zone and deduce the stack usage. It should\n+   --  be called from the same frame as Fill_Stack. If Analyzer.Probe is not\n+   --  null, an array of Word_32 with Analyzer.Probe elements is allocated on\n+   --  Compute_Result's stack frame. Probe can be used to detect an\n+   --  \"instrumentation threshold at reading\" error; See above.\n+   --  After the call to this procedure, the memory will look like:\n+   --\n+   --                                                             Stack growing\n+   --  ----------------------------------------------------------------------->\n+   --  |<---------------------->|<-------------->|<--------->|<--------->|\n+   --  |  Stack frame           | Array of       | used      |  Memory   |\n+   --  |  of Compute_Result     | Analyzer.Probe | during    |   filled  |\n+   --  |  (deallocated at       | elements       |  the      |    with   |\n+   --  |  the end of the call)  |                | execution |  pattern  |\n+   --  |                        ^                |           |           |\n+   --  |                   Inner_Pattern_Mark    |           |           |\n+   --  |                                                     |           |\n+   --  |<---------------------------------------------------->           |\n+   --                  Stack used                                        ^\n+   --                                                     Outer_Pattern_Mark\n+\n+   procedure Report_Result (Analyzer : Stack_Analyzer);\n+   --  Store the results of the computation in memory, at the address\n+   --  corresponding to the symbol __gnat_stack_usage_results.\n+\n+   type Parameterless_Procedure is access procedure;\n+\n+   procedure Initialize_Analyzer\n+     (Analyzer  : in out Stack_Analyzer;\n+      Task_Name : String;\n+      Size      : Natural;\n+      Bottom    : Stack_Address;\n+      Pattern   : Word_32 := 16#DEAD_BEEF#);\n+   --  Should be called before any use of a Stack_Analyzer, to initialize it.\n+   --  Size is the size of the pattern zone.\n+   --  Bottom should be a close approximation of the caller base\n+   --  frame address.\n+\n+   procedure Output_Results;\n+   --  Print the results computed so far on the standard output. Should be\n+   --  called when all tasks are dead.\n+\n+private\n+\n+   package Word_32_Addr is\n+      new System.Address_To_Access_Conversions (Word_32);\n+\n+   type Result_Array_Id is range 0 .. 1_023;\n+\n+   type Stack_Analyzer\n+   is record\n+      Size                   : Natural;\n+      --  Size of the pattern zone.\n+\n+      Pattern                : Word_32 := 16#DEAD_BEEF#;\n+      --  Pattern used to recognize untouched memory.\n+\n+      Inner_Pattern_Mark     : Stack_Address;\n+      --  Innermost bound of the pattern area on the stack.\n+\n+      Outer_Pattern_Mark     : Stack_Address;\n+      --  Outermost bound of the pattern area on the stack.\n+\n+      Outermost_Touched_Mark : Stack_Address;\n+      --  Outermost address of the pattern area whose value it is pointing\n+      --  at has been modified during execution. If the systematic error are\n+      --  compensated, it is the outermost value of the stack pointer during\n+      --  the execution.\n+\n+      Bottom_Of_Stack        : Stack_Address;\n+      --  Address of the bottom of the stack, as given by the caller of\n+      --  Initialize_Analyzer.\n+\n+      Array_Address          : Address;\n+      --  Address of the array of Word_32 that represents the pattern zone.\n+\n+      First_Is_Outermost     : Boolean;\n+      --  Set to true if the first element of the array of Word_32 that\n+      --  represents the pattern zone is at the outermost address of the\n+      --  pattern zone; false if it is the innermost address.\n+\n+      Result_Id              : Result_Array_Id;\n+      --  Location in the result array of the result for the current task.\n+   end record;\n+\n+end System.Stack_Usage;"}]}