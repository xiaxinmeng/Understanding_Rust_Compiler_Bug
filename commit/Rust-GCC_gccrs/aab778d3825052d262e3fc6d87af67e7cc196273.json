{"sha": "aab778d3825052d262e3fc6d87af67e7cc196273", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFiNzc4ZDM4MjUwNTJkMjYyZTNmYzZkODdhZjY3ZTdjYzE5NjI3Mw==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2018-05-22T19:10:34Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2018-05-22T19:10:34Z"}, "message": "Don't mark IFUNC resolver as only called directly\n\nSince IFUNC resolver is called indirectly, don't mark IFUNC resolver as\nonly called directly.  This patch adds ifunc_resolver to cgraph_node,\nsets ifunc_resolver for ifunc attribute and checks ifunc_resolver\ninstead of looking up ifunc attribute.\n\ngcc/\n\n\tPR target/85345\n\t* cgraph.h (cgraph_node::create): Set ifunc_resolver for ifunc\n\tattribute.\n\t(cgraph_node::create_alias): Likewise.\n\t(cgraph_node::get_availability): Check ifunc_resolver instead\n\tof looking up ifunc attribute.\n\t* cgraphunit.c (maybe_diag_incompatible_alias): Likewise.\n\t* varasm.c (do_assemble_alias): Likewise.\n\t(assemble_alias): Likewise.\n\t(default_binds_local_p_3): Likewise.\n\t* cgraph.h (cgraph_node): Add ifunc_resolver.\n\t(cgraph_node::only_called_directly_or_aliased_p): Return false\n\tfor IFUNC resolver.\n\t* lto-cgraph.c (input_node): Set ifunc_resolver for ifunc\n\tattribute.\n\t* symtab.c (symtab_node::verify_base): Verify that ifunc_resolver\n\tis equivalent to lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (decl)).\n\t(symtab_node::binds_to_current_def_p): Check ifunc_resolver\n\tinstead of looking up ifunc attribute.\n\ngcc/testsuite/\n\n\tPR target/85345\n\t* gcc.target/i386/pr85345.c: New test.\n\nFrom-SVN: r260547", "tree": {"sha": "f88364764fd0a5dbf2703b09f278a52dcaaddaef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f88364764fd0a5dbf2703b09f278a52dcaaddaef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aab778d3825052d262e3fc6d87af67e7cc196273", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aab778d3825052d262e3fc6d87af67e7cc196273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aab778d3825052d262e3fc6d87af67e7cc196273", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aab778d3825052d262e3fc6d87af67e7cc196273/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "58c2ad42a89438281327c74afb3f7483ffe22514", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58c2ad42a89438281327c74afb3f7483ffe22514", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58c2ad42a89438281327c74afb3f7483ffe22514"}], "stats": {"total": 105, "additions": 98, "deletions": 7}, "files": [{"sha": "e665b03e1e1c3920fec4609b24aee4f08aff4188", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab778d3825052d262e3fc6d87af67e7cc196273/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab778d3825052d262e3fc6d87af67e7cc196273/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aab778d3825052d262e3fc6d87af67e7cc196273", "patch": "@@ -1,3 +1,25 @@\n+2018-05-22  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/85345\n+\t* cgraph.h (cgraph_node::create): Set ifunc_resolver for ifunc\n+\tattribute.\n+\t(cgraph_node::create_alias): Likewise.\n+\t(cgraph_node::get_availability): Check ifunc_resolver instead\n+\tof looking up ifunc attribute.\n+\t* cgraphunit.c (maybe_diag_incompatible_alias): Likewise.\n+\t* varasm.c (do_assemble_alias): Likewise.\n+\t(assemble_alias): Likewise.\n+\t(default_binds_local_p_3): Likewise.\n+\t* cgraph.h (cgraph_node): Add ifunc_resolver.\n+\t(cgraph_node::only_called_directly_or_aliased_p): Return false\n+\tfor IFUNC resolver.\n+\t* lto-cgraph.c (input_node): Set ifunc_resolver for ifunc\n+\tattribute.\n+\t* symtab.c (symtab_node::verify_base): Verify that ifunc_resolver\n+\tis equivalent to lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (decl)).\n+\t(symtab_node::binds_to_current_def_p): Check ifunc_resolver\n+\tinstead of looking up ifunc attribute.\n+\n 2018-05-22  Luis Machado  <luis.machado@linaro.org>\n \n \t* config/aarch64/aarch64.md (*ashift<mode>_extv_bfiz): New pattern."}, {"sha": "9f3a2929f6bd6e90cd7dac8a88b05779e4495c11", "filename": "gcc/cgraph.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab778d3825052d262e3fc6d87af67e7cc196273/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab778d3825052d262e3fc6d87af67e7cc196273/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=aab778d3825052d262e3fc6d87af67e7cc196273", "patch": "@@ -517,6 +517,9 @@ cgraph_node::create (tree decl)\n \tg->have_offload = true;\n     }\n \n+  if (lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (decl)))\n+    node->ifunc_resolver = true;\n+\n   node->register_symbol ();\n \n   if (DECL_CONTEXT (decl) && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)\n@@ -575,6 +578,8 @@ cgraph_node::create_alias (tree alias, tree target)\n   alias_node->alias = true;\n   if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (alias)) != NULL)\n     alias_node->transparent_alias = alias_node->weakref = true;\n+  if (lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (alias)))\n+    alias_node->ifunc_resolver = true;\n   return alias_node;\n }\n \n@@ -2299,7 +2304,7 @@ cgraph_node::get_availability (symtab_node *ref)\n     avail = AVAIL_AVAILABLE;\n   else if (transparent_alias)\n     ultimate_alias_target (&avail, ref);\n-  else if (lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (decl))\n+  else if (ifunc_resolver\n \t   || lookup_attribute (\"noipa\", DECL_ATTRIBUTES (decl)))\n     avail = AVAIL_INTERPOSABLE;\n   else if (!externally_visible)"}, {"sha": "afb2745a841d598a507ef199c7bc4fba52637473", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab778d3825052d262e3fc6d87af67e7cc196273/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab778d3825052d262e3fc6d87af67e7cc196273/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=aab778d3825052d262e3fc6d87af67e7cc196273", "patch": "@@ -530,6 +530,9 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Set when symbol can be streamed into bytecode for offloading.  */\n   unsigned offloadable : 1;\n \n+  /* Set when symbol is an IFUNC resolver.  */\n+  unsigned ifunc_resolver : 1;\n+\n \n   /* Ordering of all symtab entries.  */\n   int order;\n@@ -2886,6 +2889,7 @@ cgraph_node::only_called_directly_or_aliased_p (void)\n {\n   gcc_assert (!global.inlined_to);\n   return (!force_output && !address_taken\n+\t  && !ifunc_resolver\n \t  && !used_from_other_partition\n \t  && !DECL_VIRTUAL_P (decl)\n \t  && !DECL_STATIC_CONSTRUCTOR (decl)"}, {"sha": "212ee7b83403d69b308d3e1ec6e98d16f2f8fb80", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab778d3825052d262e3fc6d87af67e7cc196273/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab778d3825052d262e3fc6d87af67e7cc196273/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=aab778d3825052d262e3fc6d87af67e7cc196273", "patch": "@@ -1307,7 +1307,7 @@ maybe_diag_incompatible_alias (tree alias, tree target)\n   tree altype = TREE_TYPE (alias);\n   tree targtype = TREE_TYPE (target);\n \n-  bool ifunc = lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (alias));\n+  bool ifunc = cgraph_node::get (alias)->ifunc_resolver;\n   tree funcptr = altype;\n \n   if (ifunc)"}, {"sha": "40baf858ca5c274755769cf8b2433b551a392b2a", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab778d3825052d262e3fc6d87af67e7cc196273/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab778d3825052d262e3fc6d87af67e7cc196273/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=aab778d3825052d262e3fc6d87af67e7cc196273", "patch": "@@ -1257,6 +1257,8 @@ input_node (struct lto_file_decl_data *file_data,\n \t of ipa passes is done.  Alays forcingly create a fresh node.  */\n       node = symtab->create_empty ();\n       node->decl = fn_decl;\n+      if (lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (fn_decl)))\n+\tnode->ifunc_resolver = 1;\n       node->register_symbol ();\n     }\n "}, {"sha": "954920b6dff4f51facf02bbab75fd26649f488b1", "filename": "gcc/symtab.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab778d3825052d262e3fc6d87af67e7cc196273/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab778d3825052d262e3fc6d87af67e7cc196273/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=aab778d3825052d262e3fc6d87af67e7cc196273", "patch": "@@ -998,6 +998,13 @@ symtab_node::verify_base (void)\n           error (\"function symbol is not function\");\n           error_found = true;\n \t}\n+      else if ((lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (decl))\n+\t\t!= NULL)\n+\t       != dyn_cast <cgraph_node *> (this)->ifunc_resolver)\n+\t{\n+          error (\"inconsistent `ifunc' attribute\");\n+          error_found = true;\n+\t}\n     }\n   else if (is_a <varpool_node *> (this))\n     {\n@@ -2253,13 +2260,13 @@ symtab_node::binds_to_current_def_p (symtab_node *ref)\n   if (transparent_alias)\n     return definition\n \t   && get_alias_target()->binds_to_current_def_p (ref);\n-  if (lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (decl)))\n+  cgraph_node *cnode = dyn_cast <cgraph_node *> (this);\n+  if (cnode && cnode->ifunc_resolver)\n     return false;\n   if (decl_binds_to_current_def_p (decl))\n     return true;\n \n   /* Inline clones always binds locally.  */\n-  cgraph_node *cnode = dyn_cast <cgraph_node *> (this);\n   if (cnode && cnode->global.inlined_to)\n     return true;\n "}, {"sha": "2e5bb3f0fb13bce6eb762d955bc0c1a2252375a8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab778d3825052d262e3fc6d87af67e7cc196273/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab778d3825052d262e3fc6d87af67e7cc196273/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aab778d3825052d262e3fc6d87af67e7cc196273", "patch": "@@ -1,3 +1,8 @@\n+2018-05-22  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/85345\n+\t* gcc.target/i386/pr85345.c: New test.\n+\n 2018-05-22  Luis Machado  <luis.machado@linaro.org>\n \n \t* gcc.target/aarch64/lsl_asr_sbfiz.c: New test."}, {"sha": "ceb94e4b9406537a69cbdb6b01df5261d833b145", "filename": "gcc/testsuite/gcc.target/i386/pr85345.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab778d3825052d262e3fc6d87af67e7cc196273/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr85345.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab778d3825052d262e3fc6d87af67e7cc196273/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr85345.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr85345.c?ref=aab778d3825052d262e3fc6d87af67e7cc196273", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fcf-protection\" } */\n+/* { dg-final { scan-assembler-times {\\mendbr} 4 } } */\n+\n+int resolver_fn = 0;\n+int resolved_fn = 0;\n+\n+static inline void\n+do_it_right_at_runtime_A (void)\n+{\n+  resolved_fn++;\n+}\n+\n+static inline void\n+do_it_right_at_runtime_B (void)\n+{\n+  resolved_fn++;\n+}\n+\n+static inline void do_it_right_at_runtime (void);\n+\n+void do_it_right_at_runtime (void)\n+  __attribute__ ((ifunc (\"resolve_do_it_right_at_runtime\")));\n+\n+extern int r;\n+static void (*resolve_do_it_right_at_runtime (void)) (void)\n+{\n+  resolver_fn++;\n+\n+  typeof(do_it_right_at_runtime) *func;\n+  if (r & 1)\n+    func = do_it_right_at_runtime_A;\n+  else\n+    func = do_it_right_at_runtime_B;\n+\n+  return (void *) func;\n+}\n+\n+int\n+main ()\n+{\n+  do_it_right_at_runtime ();\n+  return 0;\n+}"}, {"sha": "3bd9cbb69f0e760023b57e837c160b86b052cc26", "filename": "gcc/varasm.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab778d3825052d262e3fc6d87af67e7cc196273/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab778d3825052d262e3fc6d87af67e7cc196273/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=aab778d3825052d262e3fc6d87af67e7cc196273", "patch": "@@ -5833,7 +5833,8 @@ do_assemble_alias (tree decl, tree target)\n       globalize_decl (decl);\n       maybe_assemble_visibility (decl);\n     }\n-  if (lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (decl)))\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && cgraph_node::get (decl)->ifunc_resolver)\n     {\n #if defined (ASM_OUTPUT_TYPE_DIRECTIVE)\n       if (targetm.has_ifunc_p ())\n@@ -5916,7 +5917,7 @@ assemble_alias (tree decl, tree target)\n # else\n       if (!DECL_WEAK (decl))\n \t{\n-\t  if (lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (decl)))\n+\t  if (cgraph_node::get (decl)->ifunc_resolver)\n \t    error_at (DECL_SOURCE_LOCATION (decl),\n \t\t      \"ifunc is not supported in this configuration\");\n \t  else\n@@ -7048,7 +7049,8 @@ default_binds_local_p_3 (const_tree exp, bool shlib, bool weak_dominate,\n      weakref alias.  */\n   if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (exp))\n       || (TREE_CODE (exp) == FUNCTION_DECL\n-\t  && lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (exp))))\n+\t  && cgraph_node::get (exp)\n+\t  && cgraph_node::get (exp)->ifunc_resolver))\n     return false;\n \n   /* Static variables are always local.  */"}]}