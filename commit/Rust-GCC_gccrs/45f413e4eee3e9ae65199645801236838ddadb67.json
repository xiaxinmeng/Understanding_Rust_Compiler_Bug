{"sha": "45f413e4eee3e9ae65199645801236838ddadb67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVmNDEzZTRlZWUzZTlhZTY1MTk5NjQ1ODAxMjM2ODM4ZGRhZGI2Nw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-08-26T09:08:03Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-08-26T09:08:03Z"}, "message": "re PR debug/10695 (ICE in dwarf2out_frame_debug_expr,)\n\n        PR debug/10695\n        * config/alpha/alpha.c (emit_frame_store_1, emit_frame_store): New.\n        (alpha_expand_prologue): Handle >32-bit frames.  Generate proper\n        unwind info for >16-bit frames.\n\nFrom-SVN: r86610", "tree": {"sha": "38bc34c2368c96bbef4234db04cad1945b2849c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38bc34c2368c96bbef4234db04cad1945b2849c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45f413e4eee3e9ae65199645801236838ddadb67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45f413e4eee3e9ae65199645801236838ddadb67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45f413e4eee3e9ae65199645801236838ddadb67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45f413e4eee3e9ae65199645801236838ddadb67/comments", "author": null, "committer": null, "parents": [{"sha": "e7a2d5fb772b33ef161b201d579b6d58c5fb1ed1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7a2d5fb772b33ef161b201d579b6d58c5fb1ed1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7a2d5fb772b33ef161b201d579b6d58c5fb1ed1"}], "stats": {"total": 112, "additions": 72, "deletions": 40}, "files": [{"sha": "b50cccb55aacb79d97760bdd35f0feddb8fd2e73", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f413e4eee3e9ae65199645801236838ddadb67/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f413e4eee3e9ae65199645801236838ddadb67/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=45f413e4eee3e9ae65199645801236838ddadb67", "patch": "@@ -1,3 +1,10 @@\n+2004-08-25  Richard Henderson  <rth@redhat.com>\n+ \n+        PR debug/10695\n+        * config/alpha/alpha.c (emit_frame_store_1, emit_frame_store): New.\n+        (alpha_expand_prologue): Handle >32-bit frames.  Generate proper\n+        unwind info for >16-bit frames.\n+\n 2004-08-25  Richard B. Kreckel  <richard.kreckel@framatome-anp.com>\n \n \tPR target/17171"}, {"sha": "532fe667c106a72ec6e119af1d4e862ac9cea133", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 65, "deletions": 40, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f413e4eee3e9ae65199645801236838ddadb67/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f413e4eee3e9ae65199645801236838ddadb67/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=45f413e4eee3e9ae65199645801236838ddadb67", "patch": "@@ -6178,6 +6178,48 @@ set_frame_related_p (void)\n \n #define FRP(exp)  (start_sequence (), exp, set_frame_related_p ())\n \n+/* Generates a store with the proper unwind info attached.  VALUE is\n+   stored at BASE_REG+BASE_OFS.  If FRAME_BIAS is non-zero, then BASE_REG\n+   contains SP+FRAME_BIAS, and that is the unwind info that should be\n+   generated.  If FRAME_REG != VALUE, then VALUE is being stored on\n+   behalf of FRAME_REG, and FRAME_REG should be present in the unwind.  */\n+\n+static void\n+emit_frame_store_1 (rtx value, rtx base_reg, HOST_WIDE_INT frame_bias,\n+\t\t    HOST_WIDE_INT base_ofs, rtx frame_reg)\n+{\n+  rtx addr, mem, insn;\n+\n+  addr = plus_constant (base_reg, base_ofs);\n+  mem = gen_rtx_MEM (DImode, addr);\n+  set_mem_alias_set (mem, alpha_sr_alias_set);\n+\n+  insn = emit_move_insn (mem, value);\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+\n+  if (frame_bias || value != frame_reg)\n+    {\n+      if (frame_bias)\n+\t{\n+\t  addr = plus_constant (stack_pointer_rtx, frame_bias + base_ofs);\n+\t  mem = gen_rtx_MEM (DImode, addr);\n+\t}\n+\n+      REG_NOTES (insn)\n+\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t\t     gen_rtx_SET (VOIDmode, mem, frame_reg),\n+\t\t\t     REG_NOTES (insn));\n+    }\n+}\n+\n+static void\n+emit_frame_store (unsigned int regno, rtx base_reg,\n+\t\t  HOST_WIDE_INT frame_bias, HOST_WIDE_INT base_ofs)\n+{\n+  rtx reg = gen_rtx_REG (DImode, regno);\n+  emit_frame_store_1 (reg, base_reg, frame_bias, base_ofs, reg);\n+}\n+\n /* Write function prologue.  */\n \n /* On vms we have two kinds of functions:\n@@ -6207,7 +6249,7 @@ alpha_expand_prologue (void)\n   HOST_WIDE_INT frame_size;\n   /* Offset from base reg to register save area.  */\n   HOST_WIDE_INT reg_offset;\n-  rtx sa_reg, mem;\n+  rtx sa_reg;\n   int i;\n \n   sa_size = alpha_sa_size ();\n@@ -6357,37 +6399,40 @@ alpha_expand_prologue (void)\n \n   if (!TARGET_ABI_UNICOSMK)\n     {\n+      HOST_WIDE_INT sa_bias = 0;\n+\n       /* Cope with very large offsets to the register save area.  */\n       sa_reg = stack_pointer_rtx;\n       if (reg_offset + sa_size > 0x8000)\n \t{\n \t  int low = ((reg_offset & 0xffff) ^ 0x8000) - 0x8000;\n-\t  HOST_WIDE_INT bias;\n+\t  rtx sa_bias_rtx;\n \n \t  if (low + sa_size <= 0x8000)\n-\t    bias = reg_offset - low, reg_offset = low;\n+\t    sa_bias = reg_offset - low, reg_offset = low;\n \t  else\n-\t    bias = reg_offset, reg_offset = 0;\n+\t    sa_bias = reg_offset, reg_offset = 0;\n \n \t  sa_reg = gen_rtx_REG (DImode, 24);\n-\t  FRP (emit_insn (gen_adddi3 (sa_reg, stack_pointer_rtx,\n-\t\t\t\t      GEN_INT (bias))));\n+\t  sa_bias_rtx = GEN_INT (sa_bias);\n+\n+\t  if (add_operand (sa_bias_rtx, DImode))\n+\t    emit_insn (gen_adddi3 (sa_reg, stack_pointer_rtx, sa_bias_rtx));\n+\t  else\n+\t    {\n+\t      emit_move_insn (sa_reg, sa_bias_rtx);\n+\t      emit_insn (gen_adddi3 (sa_reg, stack_pointer_rtx, sa_reg));\n+\t    }\n \t}\n \n       /* Save regs in stack order.  Beginning with VMS PV.  */\n       if (TARGET_ABI_OPEN_VMS && alpha_procedure_type == PT_STACK)\n-\t{\n-\t  mem = gen_rtx_MEM (DImode, stack_pointer_rtx);\n-\t  set_mem_alias_set (mem, alpha_sr_alias_set);\n-\t  FRP (emit_move_insn (mem, gen_rtx_REG (DImode, REG_PV)));\n-\t}\n+\temit_frame_store (REG_PV, stack_pointer_rtx, 0, 0);\n \n       /* Save register RA next.  */\n       if (imask & (1UL << REG_RA))\n \t{\n-\t  mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));\n-\t  set_mem_alias_set (mem, alpha_sr_alias_set);\n-\t  FRP (emit_move_insn (mem, gen_rtx_REG (DImode, REG_RA)));\n+\t  emit_frame_store (REG_RA, sa_reg, sa_bias, reg_offset);\n \t  imask &= ~(1UL << REG_RA);\n \t  reg_offset += 8;\n \t}\n@@ -6396,36 +6441,22 @@ alpha_expand_prologue (void)\n       for (i = 0; i < 31; i++)\n \tif (imask & (1UL << i))\n \t  {\n-\t    mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));\n-\t    set_mem_alias_set (mem, alpha_sr_alias_set);\n-\t    FRP (emit_move_insn (mem, gen_rtx_REG (DImode, i)));\n+\t    emit_frame_store (i, sa_reg, sa_bias, reg_offset);\n \t    reg_offset += 8;\n \t  }\n \n       /* Store a zero if requested for unwinding.  */\n       if (imask & (1UL << 31))\n \t{\n-\t  rtx insn, t;\n-\n-\t  mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));\n-\t  set_mem_alias_set (mem, alpha_sr_alias_set);\n-\t  insn = emit_move_insn (mem, const0_rtx);\n-\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t  t = gen_rtx_REG (Pmode, 31);\n-\t  t = gen_rtx_SET (VOIDmode, mem, t);\n-\t  t = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, t, REG_NOTES (insn));\n-\t  REG_NOTES (insn) = t;\n-\n+\t  emit_frame_store_1 (const0_rtx, sa_reg, sa_bias, reg_offset,\n+\t\t\t      gen_rtx_REG (Pmode, 31));\n \t  reg_offset += 8;\n \t}\n \n       for (i = 0; i < 31; i++)\n \tif (fmask & (1UL << i))\n \t  {\n-\t    mem = gen_rtx_MEM (DFmode, plus_constant (sa_reg, reg_offset));\n-\t    set_mem_alias_set (mem, alpha_sr_alias_set);\n-\t    FRP (emit_move_insn (mem, gen_rtx_REG (DFmode, i+32)));\n+\t    emit_frame_store (i+32, sa_reg, sa_bias, reg_offset);\n \t    reg_offset += 8;\n \t  }\n     }\n@@ -6439,19 +6470,13 @@ alpha_expand_prologue (void)\n       for (i = 9; i < 15; i++)\n \tif (imask & (1UL << i))\n \t  {\n-\t    mem = gen_rtx_MEM (DImode, plus_constant(hard_frame_pointer_rtx,\n-\t\t\t\t\t\t     reg_offset));\n-\t    set_mem_alias_set (mem, alpha_sr_alias_set);\n-\t    FRP (emit_move_insn (mem, gen_rtx_REG (DImode, i)));\n+\t    emit_frame_store (i, hard_frame_pointer_rtx, 0, reg_offset);\n \t    reg_offset -= 8;\n \t  }\n       for (i = 2; i < 10; i++)\n \tif (fmask & (1UL << i))\n \t  {\n-\t    mem = gen_rtx_MEM (DFmode, plus_constant (hard_frame_pointer_rtx,\n-\t\t\t\t\t\t      reg_offset));\n-\t    set_mem_alias_set (mem, alpha_sr_alias_set);\n-\t    FRP (emit_move_insn (mem, gen_rtx_REG (DFmode, i+32)));\n+\t    emit_frame_store (i+32, hard_frame_pointer_rtx, 0, reg_offset);\n \t    reg_offset -= 8;\n \t  }\n     }"}]}