{"sha": "862e28863e70173f97b4eb3d6af9d3c218878e8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYyZTI4ODYzZTcwMTczZjk3YjRlYjNkNmFmOWQzYzIxODg3OGU4Yg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-06-05T10:58:34Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-06-05T10:58:34Z"}, "message": "i386.c (x86_use_loop): Remove.\n\n\t* config/i386/i386.c (x86_use_loop): Remove.\n\t* config/i386/i386.h (x86_use_loop): Remove extern decl.\n\t(TARGET_USE_LOOP): Remove.\n\t* config/i386/i386.md (doloop_end, doloop_end_internal): Remove.\n\tAlso remove related define_splits.\n\nFrom-SVN: r100618", "tree": {"sha": "22a8bf7f1bbc66bf93f5637f65da4995df3bfb23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22a8bf7f1bbc66bf93f5637f65da4995df3bfb23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/862e28863e70173f97b4eb3d6af9d3c218878e8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/862e28863e70173f97b4eb3d6af9d3c218878e8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/862e28863e70173f97b4eb3d6af9d3c218878e8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/862e28863e70173f97b4eb3d6af9d3c218878e8b/comments", "author": null, "committer": null, "parents": [{"sha": "88088c03967bc1ccf78ee8ddd9c0612f565df20a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88088c03967bc1ccf78ee8ddd9c0612f565df20a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88088c03967bc1ccf78ee8ddd9c0612f565df20a"}], "stats": {"total": 239, "additions": 69, "deletions": 170}, "files": [{"sha": "d0a38c6444c0ca8feacfc99cc3fe585bf0b469b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 68, "deletions": 60, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e28863e70173f97b4eb3d6af9d3c218878e8b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e28863e70173f97b4eb3d6af9d3c218878e8b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=862e28863e70173f97b4eb3d6af9d3c218878e8b", "patch": "@@ -1,65 +1,73 @@\n+2005-06-05  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* config/i386/i386.c (x86_use_loop): Remove.\n+\t* config/i386/i386.h (x86_use_loop): Remove extern decl.\n+\t(TARGET_USE_LOOP): Remove.\n+\t* config/i386/i386.md (doloop_end, doloop_end_internal): Remove.\n+\tAlso remove related define_splits.\n+\n 2005-06-05  Dorit Nuzman  <dorit@il.ibm.com>\n \n-        * tree-flow.h (stmt_ann_d): Move aux to ...\n-        (tree_ann_common_d): ... here.\n-        * tree-ssa-loop-im.c (LIM_DATA, determine_invariantness_stmt,\n-        move_computations_stmt, schedule_sm): Update references to\n-        aux.\n-        * tree-vectorizer.h (set_stmt_info, vinfo_for_stmt): Likewise.\n-        * tree-vect-transform.c (vect_create_index_for_vector_ref): Update\n-        call to set_stmt_info.\n-        (vect_transform_loop): Likewise.\n-        * tree-vectorizer.c (new_loop_vec_info, destroy_loop_vec_info):\n-        Likewise.\n-\n-        * tree-vect-analyze.c (vect_analyze_scalar_cycles): Made void instead of\n-        bool.\n-        (vect_mark_relevant): Takes two additional arguments - live_p and\n-        relevant_p. Set RELEVANT_P and LIVE_P according to these arguments.\n-        (vect_stmt_relevant_p): Differentiate between a live stmt and a\n-        relevant stmt. Return two values = live_p and relevant_p.\n-        (vect_mark_stmts_to_be_vectorized): Call vect_mark_relevant and\n-        vect_stmt_relevant_p with additional arguments. Phis are no longer\n-        put into the worklist (analyzed seperately in analyze_scalar_cycles).\n-        (vect_determine_vectorization_factor): Also check for LIVE_P, because a\n-        stmt that is marked as irrelevant and live, cause it's only used out\n-        side the loop, may need to be vectorized (e.g. reduction).\n-        (vect_analyze_operations): Examine phis. Call\n-        vectorizable_live_operation for for LIVE_P stmts. Check if\n-        need_to_vectorize.\n-        (vect_analyze_scalar_cycles): Update documentation. Don't fail\n-        vectorization - just classify the scalar cycles created by the loop\n-        phis. Call vect_is_simple_reduction.\n-        (vect_analyze_loop): Call to analyze_scalar_cycles moved earlier.\n-        * tree-vect-transform.c (vect_create_index_for_vector_ref): Update\n-        call to set_stmt_info.\n-        (vect_get_vec_def_for_operand): Code reorganized - the code that\n-        classifies the type of use was factored out to vect_is_simple_use.\n-        (vectorizable_store, vect_is_simple_cond): Call vect_is_simple_use with\n-        additional arguments.\n-        (vectorizable_assignment): Likewise. Also make sure the stmt is relevant\n-        and computes a loop_vec_def.\n-        (vectorizable_operation, vectorizable_load, vectorizable_condition):\n-        Likewise.\n-        (vectorizable_live_operation): New.\n-        (vect_transform_stmt): Handle LIVE_P stmts.\n-        * tree-vectorizer.c (new_stmt_vec_info): Initialize the new fields\n-        STMT_VINFO_LIVE_P and STMT_VINFO_DEF_TYPE.\n-        (new_loop_vec_info, destroy_loop_vec_info): Also handle phis.\n-        (vect_is_simple_use): Determine the type of the def and return it\n-        in a new function argument. Consider vect_reduction_def and\n-        vect_induction_def, but for now these are not supported.\n-        (vect_is_simple_reduction): New. Empty for now.\n-        * tree-vectorizer.h (vect_def_type): New enum type.\n-        (_stmt_vec_info): Added new fields - live and _stmt_vec_info.\n-        (STMT_VINFO_LIVE_P, STMT_VINFO_DEF_TYPE): New accessor macros.\n-        (vect_is_simple_use): New arguments added to function declaration.\n-        (vect_is_simple_reduction): New function declaration.\n-        (vectorizable_live_operation): New function declaration.\n-\n-        * tree-vect-analyze.c (vect_can_advance_ivs_p): Add debug printout.\n-        (vect_can_advance_ivs_p): Likewise.\n-        * tree-vect-transform.c (vect_update_ivs_after_vectorizer): Likewise.\n+\t* tree-flow.h (stmt_ann_d): Move aux to ...\n+\t(tree_ann_common_d): ... here.\n+\t* tree-ssa-loop-im.c (LIM_DATA, determine_invariantness_stmt,\n+\tmove_computations_stmt, schedule_sm): Update references to\n+\taux.\n+\t* tree-vectorizer.h (set_stmt_info, vinfo_for_stmt): Likewise.\n+\t* tree-vect-transform.c (vect_create_index_for_vector_ref): Update\n+\tcall to set_stmt_info.\n+\t(vect_transform_loop): Likewise.\n+\t* tree-vectorizer.c (new_loop_vec_info, destroy_loop_vec_info):\n+\tLikewise.\n+\n+\t* tree-vect-analyze.c (vect_analyze_scalar_cycles): Made void instead of\n+\tbool.\n+\t(vect_mark_relevant): Takes two additional arguments - live_p and\n+\trelevant_p. Set RELEVANT_P and LIVE_P according to these arguments.\n+\t(vect_stmt_relevant_p): Differentiate between a live stmt and a\n+\trelevant stmt. Return two values = live_p and relevant_p.\n+\t(vect_mark_stmts_to_be_vectorized): Call vect_mark_relevant and\n+\tvect_stmt_relevant_p with additional arguments. Phis are no longer\n+\tput into the worklist (analyzed seperately in analyze_scalar_cycles).\n+\t(vect_determine_vectorization_factor): Also check for LIVE_P, because a\n+\tstmt that is marked as irrelevant and live, cause it's only used out\n+\tside the loop, may need to be vectorized (e.g. reduction).\n+\t(vect_analyze_operations): Examine phis. Call\n+\tvectorizable_live_operation for for LIVE_P stmts. Check if\n+\tneed_to_vectorize.\n+\t(vect_analyze_scalar_cycles): Update documentation. Don't fail\n+\tvectorization - just classify the scalar cycles created by the loop\n+\tphis. Call vect_is_simple_reduction.\n+\t(vect_analyze_loop): Call to analyze_scalar_cycles moved earlier.\n+\t* tree-vect-transform.c (vect_create_index_for_vector_ref): Update\n+\tcall to set_stmt_info.\n+\t(vect_get_vec_def_for_operand): Code reorganized - the code that\n+\tclassifies the type of use was factored out to vect_is_simple_use.\n+\t(vectorizable_store, vect_is_simple_cond): Call vect_is_simple_use with\n+\tadditional arguments.\n+\t(vectorizable_assignment): Likewise. Also make sure the stmt is relevant\n+\tand computes a loop_vec_def.\n+\t(vectorizable_operation, vectorizable_load, vectorizable_condition):\n+\tLikewise.\n+\t(vectorizable_live_operation): New.\n+\t(vect_transform_stmt): Handle LIVE_P stmts.\n+\t* tree-vectorizer.c (new_stmt_vec_info): Initialize the new fields\n+\tSTMT_VINFO_LIVE_P and STMT_VINFO_DEF_TYPE.\n+\t(new_loop_vec_info, destroy_loop_vec_info): Also handle phis.\n+\t(vect_is_simple_use): Determine the type of the def and return it\n+\tin a new function argument. Consider vect_reduction_def and\n+\tvect_induction_def, but for now these are not supported.\n+\t(vect_is_simple_reduction): New. Empty for now.\n+\t* tree-vectorizer.h (vect_def_type): New enum type.\n+\t(_stmt_vec_info): Added new fields - live and _stmt_vec_info.\n+\t(STMT_VINFO_LIVE_P, STMT_VINFO_DEF_TYPE): New accessor macros.\n+\t(vect_is_simple_use): New arguments added to function declaration.\n+\t(vect_is_simple_reduction): New function declaration.\n+\t(vectorizable_live_operation): New function declaration.\n+\n+\t* tree-vect-analyze.c (vect_can_advance_ivs_p): Add debug printout.\n+\t(vect_can_advance_ivs_p): Likewise.\n+\t* tree-vect-transform.c (vect_update_ivs_after_vectorizer): Likewise.\n \n 2005-06-05  Eric Christopher  <echristo@redhat.com>\n "}, {"sha": "70a35316dcaf7ec699359842c52dcdc35d3c20c7", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e28863e70173f97b4eb3d6af9d3c218878e8b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e28863e70173f97b4eb3d6af9d3c218878e8b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=862e28863e70173f97b4eb3d6af9d3c218878e8b", "patch": "@@ -535,7 +535,6 @@ const int x86_deep_branch = m_PPRO | m_K6 | m_ATHLON_K8 | m_PENT4 | m_NOCONA;\n const int x86_branch_hints = 0;\n const int x86_use_sahf = m_PPRO | m_K6 | m_PENT4 | m_NOCONA;\n const int x86_partial_reg_stall = m_PPRO;\n-const int x86_use_loop = m_K6;\n const int x86_use_himode_fiop = m_386 | m_486 | m_K6;\n const int x86_use_simode_fiop = ~(m_PPRO | m_ATHLON_K8 | m_PENT);\n const int x86_use_mov0 = m_K6;"}, {"sha": "49fc6079d2abcbebf1e598e8879f8c93c029412e", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e28863e70173f97b4eb3d6af9d3c218878e8b/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e28863e70173f97b4eb3d6af9d3c218878e8b/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=862e28863e70173f97b4eb3d6af9d3c218878e8b", "patch": "@@ -146,7 +146,7 @@ extern const int x86_use_leave, x86_push_memory, x86_zero_extend_with_and;\n extern const int x86_use_bit_test, x86_cmove, x86_fisttp, x86_deep_branch;\n extern const int x86_branch_hints, x86_unroll_strlen;\n extern const int x86_double_with_add, x86_partial_reg_stall, x86_movx;\n-extern const int x86_use_loop, x86_use_himode_fiop, x86_use_simode_fiop;\n+extern const int x86_use_himode_fiop, x86_use_simode_fiop;\n extern const int x86_use_mov0, x86_use_cltd, x86_read_modify_write;\n extern const int x86_read_modify, x86_split_long_moves;\n extern const int x86_promote_QImode, x86_single_stringop, x86_fast_prefix;\n@@ -180,7 +180,6 @@ extern int x86_prefetch_sse;\n #define TARGET_USE_SAHF ((x86_use_sahf & TUNEMASK) && !TARGET_64BIT)\n #define TARGET_MOVX (x86_movx & TUNEMASK)\n #define TARGET_PARTIAL_REG_STALL (x86_partial_reg_stall & TUNEMASK)\n-#define TARGET_USE_LOOP (x86_use_loop & TUNEMASK)\n #define TARGET_USE_HIMODE_FIOP (x86_use_himode_fiop & TUNEMASK)\n #define TARGET_USE_SIMODE_FIOP (x86_use_simode_fiop & TUNEMASK)\n #define TARGET_USE_MOV0 (x86_use_mov0 & TUNEMASK)"}, {"sha": "cae0bc37a5dd56a32681b7f5de5cb456ab6b776f", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862e28863e70173f97b4eb3d6af9d3c218878e8b/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862e28863e70173f97b4eb3d6af9d3c218878e8b/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=862e28863e70173f97b4eb3d6af9d3c218878e8b", "patch": "@@ -13066,113 +13066,6 @@\n   [(set_attr \"type\" \"ibr\")\n    (set_attr \"length_immediate\" \"0\")])\n \f\n-;; Loop instruction\n-;;\n-;; This is all complicated by the fact that since this is a jump insn\n-;; we must handle our own reloads.\n-\n-(define_expand \"doloop_end\"\n-  [(use (match_operand 0 \"\" \"\"))        ; loop pseudo\n-   (use (match_operand 1 \"\" \"\"))        ; iterations; zero if unknown\n-   (use (match_operand 2 \"\" \"\"))        ; max iterations\n-   (use (match_operand 3 \"\" \"\"))        ; loop level \n-   (use (match_operand 4 \"\" \"\"))]       ; label\n-  \"!TARGET_64BIT && TARGET_USE_LOOP\"\n-  \"                                 \n-{\n-  /* Only use cloop on innermost loops.  */\n-  if (INTVAL (operands[3]) > 1)\n-    FAIL;\n-  if (GET_MODE (operands[0]) != SImode)\n-    FAIL;\n-  emit_jump_insn (gen_doloop_end_internal (operands[4], operands[0],\n-\t\t\t\t\t   operands[0]));\n-  DONE;\n-}\")\n-\n-(define_insn \"doloop_end_internal\"\n-  [(set (pc)\n-\t(if_then_else (ne (match_operand:SI 1 \"register_operand\" \"c,?*r,?*r\")\n-\t\t\t  (const_int 1))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))\n-   (set (match_operand:SI 2 \"nonimmediate_operand\" \"=1,1,*m*r\")\n-\t(plus:SI (match_dup 1)\n-\t\t (const_int -1)))\n-   (clobber (match_scratch:SI 3 \"=X,X,r\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_USE_LOOP\n-   && (reload_in_progress || reload_completed\n-       || register_operand (operands[2], VOIDmode))\"\n-{\n-  if (which_alternative != 0)\n-    return \"#\";\n-  if (get_attr_length (insn) == 2)\n-    return \"%+loop\\t%l0\";\n-  else\n-    return \"dec{l}\\t%1\\;%+jne\\t%l0\";\n-}\n-  [(set (attr \"length\")\n-\t(if_then_else (and (eq_attr \"alternative\" \"0\")\n-\t\t\t   (and (ge (minus (match_dup 0) (pc))\n-\t\t\t            (const_int -126))\n-\t\t\t        (lt (minus (match_dup 0) (pc))\n-\t\t\t            (const_int 128))))\n-\t\t      (const_int 2)\n-\t\t      (const_int 16)))\n-   ;; We don't know the type before shorten branches.  Optimistically expect\n-   ;; the loop instruction to match.\n-   (set (attr \"type\") (const_string \"ibr\"))])\n-\n-(define_split\n-  [(set (pc)\n-\t(if_then_else (ne (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t\t  (const_int 1))\n-\t\t      (match_operand 0 \"\" \"\")\n-\t\t      (pc)))\n-   (set (match_dup 1)\n-\t(plus:SI (match_dup 1)\n-\t\t (const_int -1)))\n-   (clobber (match_scratch:SI 2 \"\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_USE_LOOP\n-   && reload_completed\n-   && REGNO (operands[1]) != 2\"\n-  [(parallel [(set (reg:CCZ FLAGS_REG)\n-\t\t   (compare:CCZ (plus:SI (match_dup 1) (const_int -1))\n-\t\t\t\t (const_int 0)))\n-\t      (set (match_dup 1) (plus:SI (match_dup 1) (const_int -1)))])\n-   (set (pc) (if_then_else (ne (reg:CCZ FLAGS_REG) (const_int 0))\n-\t\t\t   (match_dup 0)\n-\t\t\t   (pc)))]\n-  \"\")\n-  \n-(define_split\n-  [(set (pc)\n-\t(if_then_else (ne (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t\t  (const_int 1))\n-\t\t      (match_operand 0 \"\" \"\")\n-\t\t      (pc)))\n-   (set (match_operand:SI 2 \"nonimmediate_operand\" \"\")\n-\t(plus:SI (match_dup 1)\n-\t\t (const_int -1)))\n-   (clobber (match_scratch:SI 3 \"\"))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_USE_LOOP\n-   && reload_completed\n-   && (! REG_P (operands[2])\n-       || ! rtx_equal_p (operands[1], operands[2]))\"\n-  [(set (match_dup 3) (match_dup 1))\n-   (parallel [(set (reg:CCZ FLAGS_REG)\n-\t\t   (compare:CCZ (plus:SI (match_dup 3) (const_int -1))\n-\t\t\t\t(const_int 0)))\n-\t      (set (match_dup 3) (plus:SI (match_dup 3) (const_int -1)))])\n-   (set (match_dup 2) (match_dup 3))\n-   (set (pc) (if_then_else (ne (reg:CCZ FLAGS_REG) (const_int 0))\n-\t\t\t   (match_dup 0)\n-\t\t\t   (pc)))]\n-  \"\")\n-\n ;; Convert setcc + movzbl to xor + setcc if operands don't overlap.\n \n (define_peephole2"}]}