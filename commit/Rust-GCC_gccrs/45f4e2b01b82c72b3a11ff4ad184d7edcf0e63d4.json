{"sha": "45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVmNGUyYjAxYjgyYzcyYjNhMTFmZjRhZDE4NGQ3ZWRjZjBlNjNkNA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-05-19T16:44:08Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-05-26T19:31:27Z"}, "message": "Convert remaining passes to get_range_query.\n\nThis patch converts the remaining users of get_range_info and\nget_ptr_nonnull to the get_range_query API.\n\nNo effort was made to move passes away from VR_ANTI_RANGE, or any other\nuse of deprecated methods.  This was a straight up conversion to the new\nAPI, nothing else.\n\ngcc/ChangeLog:\n\n\t* builtins.c (check_nul_terminated_array): Convert to get_range_query.\n\t(expand_builtin_strnlen): Same.\n\t(determine_block_size): Same.\n\t* fold-const.c (expr_not_equal_to): Same.\n\t* gimple-fold.c (size_must_be_zero_p): Same.\n\t* gimple-match-head.c: Include gimple-range.h.\n\t* gimple-pretty-print.c (dump_ssaname_info): Convert to get_range_query.\n\t* gimple-ssa-warn-restrict.c\n\t(builtin_memref::extend_offset_range): Same.\n\t* graphite-sese-to-poly.c (add_param_constraints): Same.\n\t* internal-fn.c (get_min_precision): Same.\n\t* ipa-fnsummary.c (set_switch_stmt_execution_predicate): Same.\n\t* ipa-prop.c (ipa_compute_jump_functions_for_edge): Same.\n\t* match.pd: Same.\n\t* tree-data-ref.c (split_constant_offset): Same.\n\t(dr_step_indicator): Same.\n\t* tree-dfa.c (get_ref_base_and_extent): Same.\n\t* tree-scalar-evolution.c (iv_can_overflow_p): Same.\n\t* tree-ssa-loop-niter.c (refine_value_range_using_guard): Same.\n\t(determine_value_range): Same.\n\t(record_nonwrapping_iv): Same.\n\t(infer_loop_bounds_from_signedness): Same.\n\t(scev_var_range_cant_overflow): Same.\n\t* tree-ssa-phiopt.c (two_value_replacement): Same.\n\t* tree-ssa-pre.c (insert_into_preds_of_block): Same.\n\t* tree-ssa-reassoc.c (optimize_range_tests_to_bit_test): Same.\n\t* tree-ssa-strlen.c (handle_builtin_stxncpy_strncat): Same.\n\t(get_range): Same.\n\t(dump_strlen_info): Same.\n\t(set_strlen_range): Same.\n\t(maybe_diag_stxncpy_trunc): Same.\n\t(get_len_or_size): Same.\n\t(handle_integral_assign): Same.\n\t* tree-ssa-structalias.c (find_what_p_points_to): Same.\n\t* tree-ssa-uninit.c (find_var_cmp_const): Same.\n\t* tree-switch-conversion.c (bit_test_cluster::emit): Same.\n\t* tree-vect-patterns.c (vect_get_range_info): Same.\n\t(vect_recog_divmod_pattern): Same.\n\t* tree-vrp.c (intersect_range_with_nonzero_bits): Same.\n\t(register_edge_assert_for_2): Same.\n\t(determine_value_range_1): Same.\n\t* tree.c (get_range_pos_neg): Same.\n\t* vr-values.c (vr_values::get_lattice_entry): Same.\n\t(vr_values::update_value_range): Same.\n\t(simplify_conversion_using_ranges): Same.", "tree": {"sha": "4ded2cb7fa2fbf922e5258cee4d0202c511ca68a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ded2cb7fa2fbf922e5258cee4d0202c511ca68a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe9a499cb8775cfbcea356ab0cae5c365971cf86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe9a499cb8775cfbcea356ab0cae5c365971cf86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe9a499cb8775cfbcea356ab0cae5c365971cf86"}], "stats": {"total": 491, "additions": 332, "deletions": 159}, "files": [{"sha": "af1fe49bb4827ece3f0a87c8ec6da387292fc68b", "filename": "gcc/builtins.c", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -79,6 +79,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-outof-ssa.h\"\n #include \"attr-fnspec.h\"\n #include \"demangle.h\"\n+#include \"gimple-range.h\"\n \n struct target_builtins default_target_builtins;\n #if SWITCHABLE_TARGET\n@@ -1218,14 +1219,15 @@ check_nul_terminated_array (tree expr, tree src,\n   wide_int bndrng[2];\n   if (bound)\n     {\n-      if (TREE_CODE (bound) == INTEGER_CST)\n-\tbndrng[0] = bndrng[1] = wi::to_wide (bound);\n-      else\n-\t{\n-\t  value_range_kind rng = get_range_info (bound, bndrng, bndrng + 1);\n-\t  if (rng != VR_RANGE)\n-\t    return true;\n-\t}\n+      value_range r;\n+\n+      get_global_range_query ()->range_of_expr (r, bound);\n+\n+      if (r.kind () != VR_RANGE)\n+\treturn true;\n+\n+      bndrng[0] = r.lower_bound ();\n+      bndrng[1] = r.upper_bound ();\n \n       if (exact)\n \t{\n@@ -3831,9 +3833,12 @@ expand_builtin_strnlen (tree exp, rtx target, machine_mode target_mode)\n     return NULL_RTX;\n \n   wide_int min, max;\n-  enum value_range_kind rng = get_range_info (bound, &min, &max);\n-  if (rng != VR_RANGE)\n+  value_range r;\n+  get_global_range_query ()->range_of_expr (r, bound);\n+  if (r.kind () != VR_RANGE)\n     return NULL_RTX;\n+  min = r.lower_bound ();\n+  max = r.upper_bound ();\n \n   if (!len || TREE_CODE (len) != INTEGER_CST)\n     {\n@@ -3901,7 +3906,16 @@ determine_block_size (tree len, rtx len_rtx,\n \t*probable_max_size = *max_size = GET_MODE_MASK (GET_MODE (len_rtx));\n \n       if (TREE_CODE (len) == SSA_NAME)\n-\trange_type = get_range_info (len, &min, &max);\n+\t{\n+\t  value_range r;\n+\t  get_global_range_query ()->range_of_expr (r, len);\n+\t  range_type = r.kind ();\n+\t  if (range_type != VR_UNDEFINED)\n+\t    {\n+\t      min = wi::to_wide (r.min ());\n+\t      max = wi::to_wide (r.max ());\n+\t    }\n+\t}\n       if (range_type == VR_RANGE)\n \t{\n \t  if (wi::fits_uhwi_p (min) && *min_size < min.to_uhwi ())\n@@ -4920,8 +4934,8 @@ check_read_access (tree exp, tree src, tree bound /* = NULL_TREE */,\n /* If STMT is a call to an allocation function, returns the constant\n    maximum size of the object allocated by the call represented as\n    sizetype.  If nonnull, sets RNG1[] to the range of the size.\n-   When nonnull, uses RVALS for range information, otherwise calls\n-   get_range_info to get it.\n+   When nonnull, uses RVALS for range information, otherwise gets global\n+   range info.\n    Returns null when STMT is not a call to a valid allocation function.  */\n \n tree"}, {"sha": "33d64bfbbe88082adbb765ebb5cf7f514f29dd77", "filename": "gcc/fold-const.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -83,6 +83,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-vector-builder.h\"\n #include \"vec-perm-indices.h\"\n #include \"asan.h\"\n+#include \"gimple-range.h\"\n \n /* Nonzero if we are folding constants inside an initializer; zero\n    otherwise.  */\n@@ -10686,7 +10687,12 @@ expr_not_equal_to (tree t, const wide_int &w)\n     case SSA_NAME:\n       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \treturn false;\n-      get_range_info (t, vr);\n+\n+      if (cfun)\n+\tget_range_query (cfun)->range_of_expr (vr, t);\n+      else\n+\tget_global_range_query ()->range_of_expr (vr, t);\n+\n       if (!vr.undefined_p ()\n \t  && !vr.contains_p (wide_int_to_tree (TREE_TYPE (t), w)))\n \treturn true;"}, {"sha": "eaf0fb76b6610db1a5bf45c70cdfbe2066d1a421", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -873,7 +873,12 @@ size_must_be_zero_p (tree size)\n   value_range valid_range (build_int_cst (type, 0),\n \t\t\t   wide_int_to_tree (type, ssize_max));\n   value_range vr;\n-  get_range_info (size, vr);\n+  if (cfun)\n+    get_range_query (cfun)->range_of_expr (vr, size);\n+  else\n+    get_global_range_query ()->range_of_expr (vr, size);\n+  if (vr.undefined_p ())\n+    vr.set_varying (TREE_TYPE (size));\n   vr.intersect (&valid_range);\n   return vr.zero_p ();\n }"}, {"sha": "7112c1168357ba3bf9d99e87d3b78f3367304145", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-eh.h\"\n #include \"dbgcnt.h\"\n #include \"tm.h\"\n+#include \"gimple-range.h\"\n \n /* Forward declarations of the private auto-generated matchers.\n    They expect valueized operands in canonical order and do not"}, {"sha": "c9c0a66ee308a034cc82b4976c15a0e20e43a4b7", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"asan.h\"\n #include \"cfgloop.h\"\n+#include \"gimple-range.h\"\n \n /* Disable warnings about quoting issues in the pp_xxx calls below\n    that (intentionally) don't follow GCC diagnostic conventions.  */\n@@ -2263,8 +2264,17 @@ dump_ssaname_info (pretty_printer *buffer, tree node, int spc)\n       && SSA_NAME_RANGE_INFO (node))\n     {\n       wide_int min, max, nonzero_bits;\n-      value_range_kind range_type = get_range_info (node, &min, &max);\n+      value_range r;\n \n+      get_global_range_query ()->range_of_expr (r, node);\n+      value_range_kind range_type = r.kind ();\n+      if (!r.undefined_p ())\n+\t{\n+\t  min = wi::to_wide (r.min ());\n+\t  max = wi::to_wide (r.max ());\n+\t}\n+\n+      // FIXME: Use irange::dump() instead.\n       if (range_type == VR_VARYING)\n \tpp_printf (buffer, \"# RANGE VR_VARYING\");\n       else if (range_type == VR_RANGE || range_type == VR_ANTI_RANGE)"}, {"sha": "c8c9f9581a805a7b05418341e37593ebaa8082c0", "filename": "gcc/gimple-ssa-warn-restrict.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fgimple-ssa-warn-restrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fgimple-ssa-warn-restrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -349,7 +349,13 @@ builtin_memref::extend_offset_range (tree offset)\n \t  /* There is a global version here because\n \t     check_bounds_or_overlap may be called from gimple\n \t     fold during gimple lowering.  */\n-\t  rng = get_range_info (offset, &min, &max);\n+\t  get_range_query (cfun)->range_of_expr (vr, offset, stmt);\n+\t  rng = vr.kind ();\n+\t  if (!vr.undefined_p ())\n+\t    {\n+\t      min = wi::to_wide (vr.min ());\n+\t      max = wi::to_wide (vr.max ());\n+\t    }\n \t}\n       if (rng == VR_ANTI_RANGE && wi::lts_p (max, min))\n \t{"}, {"sha": "99ea0327b1a782f8459cd1d0f448460e3008608f", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -418,13 +418,18 @@ static void\n add_param_constraints (scop_p scop, graphite_dim_t p, tree parameter)\n {\n   tree type = TREE_TYPE (parameter);\n+  value_range r;\n   wide_int min, max;\n \n   gcc_assert (INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type));\n \n   if (INTEGRAL_TYPE_P (type)\n-      && get_range_info (parameter, &min, &max) == VR_RANGE)\n-    ;\n+      && get_range_query (cfun)->range_of_expr (r, parameter)\n+      && !r.undefined_p ())\n+    {\n+      min = r.lower_bound ();\n+      max = r.upper_bound ();\n+    }\n   else\n     {\n       min = wi::min_value (TYPE_PRECISION (type), TYPE_SIGN (type));"}, {"sha": "f06c2711cb788f665f44b7c7eddb5066e11a0a3e", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ssa-iterators.h\"\n #include \"explow.h\"\n #include \"rtl-iter.h\"\n+#include \"gimple-range.h\"\n \n /* The names of each internal function, indexed by function number.  */\n const char *const internal_fn_name_array[] = {\n@@ -680,8 +681,9 @@ get_min_precision (tree arg, signop sign)\n     }\n   if (TREE_CODE (arg) != SSA_NAME)\n     return prec + (orig_sign != sign);\n-  wide_int arg_min, arg_max;\n-  while (get_range_info (arg, &arg_min, &arg_max) != VR_RANGE)\n+  value_range r;\n+  while (!get_global_range_query ()->range_of_expr (r, arg)\n+\t || r.kind () != VR_RANGE)\n     {\n       gimple *g = SSA_NAME_DEF_STMT (arg);\n       if (is_gimple_assign (g)\n@@ -709,14 +711,14 @@ get_min_precision (tree arg, signop sign)\n     }\n   if (sign == TYPE_SIGN (TREE_TYPE (arg)))\n     {\n-      int p1 = wi::min_precision (arg_min, sign);\n-      int p2 = wi::min_precision (arg_max, sign);\n+      int p1 = wi::min_precision (r.lower_bound (), sign);\n+      int p2 = wi::min_precision (r.upper_bound (), sign);\n       p1 = MAX (p1, p2);\n       prec = MIN (prec, p1);\n     }\n-  else if (sign == UNSIGNED && !wi::neg_p (arg_min, SIGNED))\n+  else if (sign == UNSIGNED && !wi::neg_p (r.lower_bound (), SIGNED))\n     {\n-      int p = wi::min_precision (arg_max, UNSIGNED);\n+      int p = wi::min_precision (r.upper_bound (), UNSIGNED);\n       prec = MIN (prec, p);\n     }\n   return prec + (orig_sign != sign);"}, {"sha": "95d28757f9507150028b663cad915eaf54526f63", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -85,6 +85,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"tree-into-ssa.h\"\n #include \"symtab-clones.h\"\n+#include \"gimple-range.h\"\n \n /* Summaries.  */\n fast_function_summary <ipa_fn_summary *, va_gc> *ipa_fn_summaries;\n@@ -1687,8 +1688,14 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n   int bound_limit = opt_for_fn (fbi->node->decl,\n \t\t\t\tparam_ipa_max_switch_predicate_bounds);\n   int bound_count = 0;\n-  wide_int vr_wmin, vr_wmax;\n-  value_range_kind vr_type = get_range_info (op, &vr_wmin, &vr_wmax);\n+  value_range vr;\n+\n+  get_range_query (cfun)->range_of_expr (vr, op);\n+  if (vr.undefined_p ())\n+    vr.set_varying (TREE_TYPE (op));\n+  value_range_kind vr_type = vr.kind ();\n+  wide_int vr_wmin = wi::to_wide (vr.min ());\n+  wide_int vr_wmax = wi::to_wide (vr.max ());\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {"}, {"sha": "f74d2e17b69d69f6d27b39e654dc201eac2abe81", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -55,6 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"options.h\"\n #include \"symtab-clones.h\"\n #include \"attr-fnspec.h\"\n+#include \"gimple-range.h\"\n \n /* Function summary where the parameter infos are actually stored. */\n ipa_node_params_t *ipa_node_params_sum = NULL;\n@@ -2237,6 +2238,7 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n   gcall *call = cs->call_stmt;\n   int n, arg_num = gimple_call_num_args (call);\n   bool useful_context = false;\n+  value_range vr;\n \n   if (arg_num == 0 || args->jump_functions)\n     return;\n@@ -2274,7 +2276,8 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \n \t  if (TREE_CODE (arg) == SSA_NAME\n \t      && param_type\n-\t      && get_ptr_nonnull (arg))\n+\t      && get_range_query (cfun)->range_of_expr (vr, arg)\n+\t      && vr.nonzero_p ())\n \t    addr_nonzero = true;\n \t  else if (tree_single_nonzero_warnv_p (arg, &strict_overflow))\n \t    addr_nonzero = true;\n@@ -2289,19 +2292,14 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n \t}\n       else\n \t{\n-\t  wide_int min, max;\n-\t  value_range_kind kind;\n \t  if (TREE_CODE (arg) == SSA_NAME\n \t      && param_type\n-\t      && (kind = get_range_info (arg, &min, &max))\n-\t      && (kind == VR_RANGE || kind == VR_ANTI_RANGE))\n+\t      && get_range_query (cfun)->range_of_expr (vr, arg)\n+\t      && !vr.undefined_p ())\n \t    {\n \t      value_range resvr;\n-\t      value_range tmpvr (wide_int_to_tree (TREE_TYPE (arg), min),\n-\t\t\t\t wide_int_to_tree (TREE_TYPE (arg), max),\n-\t\t\t\t kind);\n \t      range_fold_unary_expr (&resvr, NOP_EXPR, param_type,\n-\t\t\t\t     &tmpvr, TREE_TYPE (arg));\n+\t\t\t\t     &vr, TREE_TYPE (arg));\n \t      if (!resvr.undefined_p () && !resvr.varying_p ())\n \t\tipa_set_jfunc_vr (jfunc, &resvr);\n \t      else"}, {"sha": "b60e2703f60a9dbb32225204cf572db461a24100", "filename": "gcc/match.pd", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -663,11 +663,17 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n     (with\n      {\n        bool overflowed = true;\n-       wide_int wmin0, wmax0, wmin1, wmax1;\n+       value_range vr0, vr1;\n        if (INTEGRAL_TYPE_P (type)\n-\t   && get_range_info (@0, &wmin0, &wmax0) == VR_RANGE\n-\t   && get_range_info (@1, &wmin1, &wmax1) == VR_RANGE)\n+\t   && get_global_range_query ()->range_of_expr (vr0, @0)\n+\t   && get_global_range_query ()->range_of_expr (vr1, @1)\n+\t   && vr0.kind () == VR_RANGE\n+\t   && vr1.kind () == VR_RANGE)\n \t {\n+\t   wide_int wmin0 = vr0.lower_bound ();\n+\t   wide_int wmax0 = vr0.upper_bound ();\n+\t   wide_int wmin1 = vr1.lower_bound ();\n+\t   wide_int wmax1 = vr1.upper_bound ();\n \t   /* If the multiplication can't overflow/wrap around, then\n \t      it can be optimized too.  */\n \t   wi::overflow_type min_ovf, max_ovf;\n@@ -2509,9 +2515,12 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \t  = wide_int::from (wi::to_wide (@1), TYPE_PRECISION (inner_type),\n \t\t\t    TYPE_SIGN (inner_type));\n \n-        wide_int wmin0, wmax0;\n-        if (get_range_info (@0, &wmin0, &wmax0) == VR_RANGE)\n+\tvalue_range vr;\n+\tif (get_global_range_query ()->range_of_expr (vr, @0)\n+\t    && vr.kind () == VR_RANGE)\n           {\n+\t    wide_int wmin0 = vr.lower_bound ();\n+\t    wide_int wmax0 = vr.upper_bound ();\n             wi::add (wmin0, w1, TYPE_SIGN (inner_type), &min_ovf);\n             wi::add (wmax0, w1, TYPE_SIGN (inner_type), &max_ovf);\n           }"}, {"sha": "09d466715655892992d28961f6f3775c384902de", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -1035,14 +1035,23 @@ split_constant_offset (tree exp, tree *var, tree *off, value_range *exp_range,\n       *exp_range = type;\n       if (code == SSA_NAME)\n \t{\n-\t  wide_int var_min, var_max;\n-\t  value_range_kind vr_kind = get_range_info (exp, &var_min, &var_max);\n+\t  value_range vr;\n+\t  get_range_query (cfun)->range_of_expr (vr, exp);\n+\t  if (vr.undefined_p ())\n+\t    vr.set_varying (TREE_TYPE (exp));\n+\t  wide_int var_min = wi::to_wide (vr.min ());\n+\t  wide_int var_max = wi::to_wide (vr.max ());\n+\t  value_range_kind vr_kind = vr.kind ();\n \t  wide_int var_nonzero = get_nonzero_bits (exp);\n \t  vr_kind = intersect_range_with_nonzero_bits (vr_kind,\n \t\t\t\t\t\t       &var_min, &var_max,\n \t\t\t\t\t\t       var_nonzero,\n \t\t\t\t\t\t       TYPE_SIGN (type));\n-\t  if (vr_kind == VR_RANGE)\n+\t  /* This check for VR_VARYING is here because the old code\n+\t     using get_range_info would return VR_RANGE for the entire\n+\t     domain, instead of VR_VARYING.  The new code normalizes\n+\t     full-domain ranges to VR_VARYING.  */\n+\t  if (vr_kind == VR_RANGE || vr_kind == VR_VARYING)\n \t    *exp_range = value_range (type, var_min, var_max);\n \t}\n     }\n@@ -6298,12 +6307,19 @@ dr_step_indicator (struct data_reference *dr, int useful_min)\n \n       /* Get the range of values that the unconverted step actually has.  */\n       wide_int step_min, step_max;\n+      value_range vr;\n       if (TREE_CODE (step) != SSA_NAME\n-\t  || get_range_info (step, &step_min, &step_max) != VR_RANGE)\n+\t  || !get_range_query (cfun)->range_of_expr (vr, step)\n+\t  || vr.kind () != VR_RANGE)\n \t{\n \t  step_min = wi::to_wide (TYPE_MIN_VALUE (type));\n \t  step_max = wi::to_wide (TYPE_MAX_VALUE (type));\n \t}\n+      else\n+\t{\n+\t  step_min = vr.lower_bound ();\n+\t  step_max = vr.upper_bound ();\n+\t}\n \n       /* Check whether the unconverted step has an acceptable range.  */\n       signop sgn = TYPE_SIGN (type);"}, {"sha": "1d20de0c40034bc219af899f436abd5514c20898", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-iterator.h\"\n #include \"gimple-walk.h\"\n #include \"tree-dfa.h\"\n+#include \"gimple-range.h\"\n \n /* Build and maintain data flow information for trees.  */\n \n@@ -535,14 +536,23 @@ get_ref_base_and_extent (tree exp, poly_int64_pod *poffset,\n \t\t   index.  */\n \t\tseen_variable_array_ref = true;\n \n-\t\twide_int min, max;\n+\t\tvalue_range vr;\n+\t\trange_query *query;\n+\t\tif (cfun)\n+\t\t  query = get_range_query (cfun);\n+\t\telse\n+\t\t  query = get_global_range_query ();\n+\n \t\tif (TREE_CODE (index) == SSA_NAME\n \t\t    && (low_bound = array_ref_low_bound (exp),\n \t\t\tpoly_int_tree_p (low_bound))\n \t\t    && (unit_size = array_ref_element_size (exp),\n \t\t\tTREE_CODE (unit_size) == INTEGER_CST)\n-\t\t    && get_range_info (index, &min, &max) == VR_RANGE)\n+\t\t    && query->range_of_expr (vr, index)\n+\t\t    && vr.kind () == VR_RANGE)\n \t\t  {\n+\t\t    wide_int min = vr.lower_bound ();\n+\t\t    wide_int max = vr.upper_bound ();\n \t\t    poly_offset_int lbound = wi::to_poly_offset (low_bound);\n \t\t    /* Try to constrain maxsize with range information.  */\n \t\t    offset_int omax"}, {"sha": "b22d49a0ab629d14d25819bea6e6cc2c4591b2a6", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -3039,18 +3039,27 @@ iv_can_overflow_p (class loop *loop, tree type, tree base, tree step)\n   widest_int nit;\n   wide_int base_min, base_max, step_min, step_max, type_min, type_max;\n   signop sgn = TYPE_SIGN (type);\n+  value_range r;\n \n   if (integer_zerop (step))\n     return false;\n \n   if (!INTEGRAL_TYPE_P (TREE_TYPE (base))\n-      || get_range_info (base, &base_min, &base_max) != VR_RANGE)\n+      || !get_range_query (cfun)->range_of_expr (r, base)\n+      || r.kind () != VR_RANGE)\n     return true;\n \n+  base_min = r.lower_bound ();\n+  base_max = r.upper_bound ();\n+\n   if (!INTEGRAL_TYPE_P (TREE_TYPE (step))\n-      || get_range_info (step, &step_min, &step_max) != VR_RANGE)\n+      || !get_range_query (cfun)->range_of_expr (r, step)\n+      || r.kind () != VR_RANGE)\n     return true;\n \n+  step_min = r.lower_bound ();\n+  step_max = r.upper_bound ();\n+\n   if (!get_max_loop_iterations (loop, &nit))\n     return true;\n "}, {"sha": "b5add827018067e1d508782ccc3e1be2e0b3c24c", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 54, "deletions": 27, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-chrec.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-dfa.h\"\n+#include \"gimple-range.h\"\n \n \n /* The maximum number of dominator BBs we search for conditions\n@@ -121,7 +122,6 @@ refine_value_range_using_guard (tree type, tree var,\n   tree varc0, varc1, ctype;\n   mpz_t offc0, offc1;\n   mpz_t mint, maxt, minc1, maxc1;\n-  wide_int minv, maxv;\n   bool no_wrap = nowrap_type_p (type);\n   bool c0_ok, c1_ok;\n   signop sgn = TYPE_SIGN (type);\n@@ -221,6 +221,7 @@ refine_value_range_using_guard (tree type, tree var,\n   get_type_static_bounds (type, mint, maxt);\n   mpz_init (minc1);\n   mpz_init (maxc1);\n+  value_range r;\n   /* Setup range information for varc1.  */\n   if (integer_zerop (varc1))\n     {\n@@ -229,11 +230,12 @@ refine_value_range_using_guard (tree type, tree var,\n     }\n   else if (TREE_CODE (varc1) == SSA_NAME\n \t   && INTEGRAL_TYPE_P (type)\n-\t   && get_range_info (varc1, &minv, &maxv) == VR_RANGE)\n+\t   && get_range_query (cfun)->range_of_expr (r, varc1)\n+\t   && r.kind () == VR_RANGE)\n     {\n-      gcc_assert (wi::le_p (minv, maxv, sgn));\n-      wi::to_mpz (minv, minc1, sgn);\n-      wi::to_mpz (maxv, maxc1, sgn);\n+      gcc_assert (wi::le_p (r.lower_bound (), r.upper_bound (), sgn));\n+      wi::to_mpz (r.lower_bound (), minc1, sgn);\n+      wi::to_mpz (r.upper_bound (), maxc1, sgn);\n     }\n   else\n     {\n@@ -372,34 +374,50 @@ determine_value_range (class loop *loop, tree type, tree var, mpz_t off,\n       gphi_iterator gsi;\n \n       /* Either for VAR itself...  */\n-      rtype = get_range_info (var, &minv, &maxv);\n+      value_range var_range;\n+      get_range_query (cfun)->range_of_expr (var_range, var);\n+      rtype = var_range.kind ();\n+      if (!var_range.undefined_p ())\n+\t{\n+\t  minv = var_range.lower_bound ();\n+\t  maxv = var_range.upper_bound ();\n+\t}\n+\n       /* Or for PHI results in loop->header where VAR is used as\n \t PHI argument from the loop preheader edge.  */\n       for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gphi *phi = gsi.phi ();\n-\t  wide_int minc, maxc;\n+\t  value_range phi_range;\n \t  if (PHI_ARG_DEF_FROM_EDGE (phi, e) == var\n-\t      && (get_range_info (gimple_phi_result (phi), &minc, &maxc)\n-\t\t  == VR_RANGE))\n+\t      && get_range_query (cfun)->range_of_expr (phi_range,\n+\t\t\t\t\t\t    gimple_phi_result (phi))\n+\t      && phi_range.kind () == VR_RANGE)\n \t    {\n \t      if (rtype != VR_RANGE)\n \t\t{\n \t\t  rtype = VR_RANGE;\n-\t\t  minv = minc;\n-\t\t  maxv = maxc;\n+\t\t  minv = phi_range.lower_bound ();\n+\t\t  maxv = phi_range.upper_bound ();\n \t\t}\n \t      else\n \t\t{\n-\t\t  minv = wi::max (minv, minc, sgn);\n-\t\t  maxv = wi::min (maxv, maxc, sgn);\n+\t\t  minv = wi::max (minv, phi_range.lower_bound (), sgn);\n+\t\t  maxv = wi::min (maxv, phi_range.upper_bound (), sgn);\n \t\t  /* If the PHI result range are inconsistent with\n \t\t     the VAR range, give up on looking at the PHI\n \t\t     results.  This can happen if VR_UNDEFINED is\n \t\t     involved.  */\n \t\t  if (wi::gt_p (minv, maxv, sgn))\n \t\t    {\n-\t\t      rtype = get_range_info (var, &minv, &maxv);\n+\t\t      value_range vr;\n+\t\t      get_range_query (cfun)->range_of_expr (vr, var);\n+\t\t      rtype = vr.kind ();\n+\t\t      if (!vr.undefined_p ())\n+\t\t\t{\n+\t\t\t  minv = vr.lower_bound ();\n+\t\t\t  maxv = vr.upper_bound ();\n+\t\t\t}\n \t\t      break;\n \t\t    }\n \t\t}\n@@ -3545,12 +3563,16 @@ record_nonwrapping_iv (class loop *loop, tree base, tree step, gimple *stmt,\n \n   if (tree_int_cst_sign_bit (step))\n     {\n-      wide_int min, max;\n+      wide_int max;\n+      value_range base_range;\n+      if (get_range_query (cfun)->range_of_expr (base_range, orig_base)\n+\t  && !base_range.undefined_p ())\n+\tmax = base_range.upper_bound ();\n       extreme = fold_convert (unsigned_type, low);\n       if (TREE_CODE (orig_base) == SSA_NAME\n \t  && TREE_CODE (high) == INTEGER_CST\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (orig_base))\n-\t  && (get_range_info (orig_base, &min, &max) == VR_RANGE\n+\t  && (base_range.kind () == VR_RANGE\n \t      || get_cst_init_from_scev (orig_base, &max, false))\n \t  && wi::gts_p (wi::to_wide (high), max))\n \tbase = wide_int_to_tree (unsigned_type, max);\n@@ -3563,12 +3585,16 @@ record_nonwrapping_iv (class loop *loop, tree base, tree step, gimple *stmt,\n     }\n   else\n     {\n-      wide_int min, max;\n+      wide_int min;\n+      value_range base_range;\n+      if (get_range_query (cfun)->range_of_expr (base_range, orig_base)\n+\t  && !base_range.undefined_p ())\n+\tmin = base_range.lower_bound ();\n       extreme = fold_convert (unsigned_type, high);\n       if (TREE_CODE (orig_base) == SSA_NAME\n \t  && TREE_CODE (low) == INTEGER_CST\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (orig_base))\n-\t  && (get_range_info (orig_base, &min, &max) == VR_RANGE\n+\t  && (base_range.kind () == VR_RANGE\n \t      || get_cst_init_from_scev (orig_base, &min, true))\n \t  && wi::gts_p (min, wi::to_wide (low)))\n \tbase = wide_int_to_tree (unsigned_type, min);\n@@ -3835,11 +3861,12 @@ infer_loop_bounds_from_signedness (class loop *loop, gimple *stmt)\n \n   low = lower_bound_in_type (type, type);\n   high = upper_bound_in_type (type, type);\n-  wide_int minv, maxv;\n-  if (get_range_info (def, &minv, &maxv) == VR_RANGE)\n+  value_range r;\n+  get_range_query (cfun)->range_of_expr (r, def);\n+  if (r.kind () == VR_RANGE)\n     {\n-      low = wide_int_to_tree (type, minv);\n-      high = wide_int_to_tree (type, maxv);\n+      low = wide_int_to_tree (type, r.lower_bound ());\n+      high = wide_int_to_tree (type, r.upper_bound ());\n     }\n \n   record_nonwrapping_iv (loop, base, step, stmt, low, high, false, true);\n@@ -4873,7 +4900,6 @@ scev_var_range_cant_overflow (tree var, tree step, class loop *loop)\n {\n   tree type;\n   wide_int minv, maxv, diff, step_wi;\n-  enum value_range_kind rtype;\n \n   if (TREE_CODE (step) != INTEGER_CST || !INTEGRAL_TYPE_P (TREE_TYPE (var)))\n     return false;\n@@ -4884,8 +4910,9 @@ scev_var_range_cant_overflow (tree var, tree step, class loop *loop)\n   if (!def_bb || !dominated_by_p (CDI_DOMINATORS, loop->latch, def_bb))\n     return false;\n \n-  rtype = get_range_info (var, &minv, &maxv);\n-  if (rtype != VR_RANGE)\n+  value_range r;\n+  get_range_query (cfun)->range_of_expr (r, var);\n+  if (r.kind () != VR_RANGE)\n     return false;\n \n   /* VAR is a scev whose evolution part is STEP and value range info\n@@ -4899,11 +4926,11 @@ scev_var_range_cant_overflow (tree var, tree step, class loop *loop)\n   type = TREE_TYPE (var);\n   if (tree_int_cst_sign_bit (step))\n     {\n-      diff = minv - wi::to_wide (lower_bound_in_type (type, type));\n+      diff = r.lower_bound () - wi::to_wide (lower_bound_in_type (type, type));\n       step_wi = - step_wi;\n     }\n   else\n-    diff = wi::to_wide (upper_bound_in_type (type, type)) - maxv;\n+    diff = wi::to_wide (upper_bound_in_type (type, type)) - r.upper_bound ();\n \n   return (wi::geu_p (diff, step_wi));\n }"}, {"sha": "e3bd18023a0547add6a99641dc9830d96b856325", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-eh.h\"\n #include \"gimple-fold.h\"\n #include \"internal-fn.h\"\n+#include \"gimple-range.h\"\n \n static unsigned int tree_ssa_phiopt_worker (bool, bool, bool);\n static bool two_value_replacement (basic_block, basic_block, edge, gphi *,\n@@ -684,7 +685,15 @@ two_value_replacement (basic_block cond_bb, basic_block middle_bb,\n     return false;\n \n   wide_int min, max;\n-  if (get_range_info (lhs, &min, &max) != VR_RANGE)\n+  value_range r;\n+  get_range_query (cfun)->range_of_expr (r, lhs);\n+\n+  if (r.kind () == VR_RANGE)\n+    {\n+      min = r.lower_bound ();\n+      max = r.upper_bound ();\n+    }\n+  else\n     {\n       int prec = TYPE_PRECISION (TREE_TYPE (lhs));\n       signop sgn = TYPE_SIGN (TREE_TYPE (lhs));"}, {"sha": "d86fe26bd07f885fc847d2ac2926c4a2f6ccac2c", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -51,6 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-dce.h\"\n #include \"tree-cfgcleanup.h\"\n #include \"alias.h\"\n+#include \"gimple-range.h\"\n \n /* Even though this file is called tree-ssa-pre.c, we actually\n    implement a bit more than just PRE here.  All of them piggy-back\n@@ -3234,16 +3235,18 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \t  >= TYPE_PRECISION (TREE_TYPE (expr->u.nary->op[0])))\n       && SSA_NAME_RANGE_INFO (expr->u.nary->op[0]))\n     {\n-      wide_int min, max;\n-      if (get_range_info (expr->u.nary->op[0], &min, &max) == VR_RANGE\n-\t  && !wi::neg_p (min, SIGNED)\n-\t  && !wi::neg_p (max, SIGNED))\n+      value_range r;\n+      if (get_range_query (cfun)->range_of_expr (r, expr->u.nary->op[0])\n+\t  && r.kind () == VR_RANGE\n+\t  && !wi::neg_p (r.lower_bound (), SIGNED)\n+\t  && !wi::neg_p (r.upper_bound (), SIGNED))\n \t/* Just handle extension and sign-changes of all-positive ranges.  */\n-\tset_range_info (temp,\n-\t\t\tSSA_NAME_RANGE_TYPE (expr->u.nary->op[0]),\n-\t\t\twide_int_storage::from (min, TYPE_PRECISION (type),\n+\tset_range_info (temp, VR_RANGE,\n+\t\t\twide_int_storage::from (r.lower_bound (),\n+\t\t\t\t\t\tTYPE_PRECISION (type),\n \t\t\t\t\t\tTYPE_SIGN (type)),\n-\t\t\twide_int_storage::from (max, TYPE_PRECISION (type),\n+\t\t\twide_int_storage::from (r.upper_bound (),\n+\t\t\t\t\t\tTYPE_PRECISION (type),\n \t\t\t\t\t\tTYPE_SIGN (type)));\n     }\n "}, {"sha": "6dfc70356d0fdaad6c54231486ba9211f709b2a5", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"case-cfn-macros.h\"\n #include \"tree-ssa-reassoc.h\"\n #include \"tree-ssa-math-opts.h\"\n+#include \"gimple-range.h\"\n \n /*  This is a simple global reassociation pass.  It is, in part, based\n     on the LLVM pass of the same name (They do some things more/less\n@@ -3221,12 +3222,14 @@ optimize_range_tests_to_bit_test (enum tree_code opcode, int first, int length,\n \t amount, then we can merge the entry test in the bit test.  In this\n \t case, if we would need otherwise 2 or more comparisons, then use\n \t the bit test; in the other cases, the threshold is 3 comparisons.  */\n-      wide_int min, max;\n       bool entry_test_needed;\n+      value_range r;\n       if (TREE_CODE (exp) == SSA_NAME\n-\t  && get_range_info (exp, &min, &max) == VR_RANGE\n-\t  && wi::leu_p (max - min, prec - 1))\n+\t  && get_range_query (cfun)->range_of_expr (r, exp)\n+\t  && r.kind () == VR_RANGE\n+\t  && wi::leu_p (r.upper_bound () - r.lower_bound (), prec - 1))\n \t{\n+\t  wide_int min = r.lower_bound ();\n \t  wide_int ilowi = wi::to_wide (lowi);\n \t  if (wi::lt_p (min, ilowi, TYPE_SIGN (TREE_TYPE (lowi))))\n \t    {"}, {"sha": "423075b2bd1e3ed9b94f9553ae45bb079de007ae", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 49, "deletions": 36, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -196,7 +196,7 @@ static void handle_builtin_stxncpy_strncat (bool, gimple_stmt_iterator *);\n /* Sets MINMAX to either the constant value or the range VAL is in\n    and returns either the constant value or VAL on success or null\n    when the range couldn't be determined.  Uses RVALS when nonnull\n-   to determine the range, otherwise get_range_info.  */\n+   to determine the range, otherwise uses global range info.  */\n \n tree\n get_range (tree val, gimple *stmt, wide_int minmax[2],\n@@ -211,9 +211,9 @@ get_range (tree val, gimple *stmt, wide_int minmax[2],\n   if (TREE_CODE (val) != SSA_NAME)\n     return NULL_TREE;\n \n+  value_range vr;\n   if (rvals && stmt)\n     {\n-      value_range vr;\n       if (!rvals->range_of_expr (vr, val, stmt))\n \treturn NULL_TREE;\n       value_range_kind rng = vr.kind ();\n@@ -225,7 +225,15 @@ get_range (tree val, gimple *stmt, wide_int minmax[2],\n       return val;\n     }\n \n-  value_range_kind rng = get_range_info (val, minmax, minmax + 1);\n+  // ?? This entire function should use get_range_query or get_global_range_query (),\n+  // instead of doing something different for RVALS and global ranges.\n+\n+  if (!get_global_range_query ()->range_of_expr (vr, val) || vr.undefined_p ())\n+    return NULL_TREE;\n+\n+  minmax[0] = wi::to_wide (vr.min ());\n+  minmax[1] = wi::to_wide (vr.max ());\n+  value_range_kind rng = vr.kind ();\n   if (rng == VR_RANGE)\n     /* This may be an inverted range whose MINMAX[1] < MINMAX[0].  */\n     return val;\n@@ -929,7 +937,17 @@ dump_strlen_info (FILE *fp, gimple *stmt, range_query *rvals)\n \t\t\t    rng = VR_UNDEFINED;\n \t\t\t}\n \t\t      else\n-\t\t\trng = get_range_info (si->nonzero_chars, &min, &max);\n+\t\t\t{\n+\t\t\t  value_range vr;\n+\t\t\t  get_global_range_query ()->range_of_expr (vr,\n+\t\t\t\t\t\t\t     si->nonzero_chars);\n+\t\t\t  rng = vr.kind ();\n+\t\t\t  if (!vr.undefined_p ())\n+\t\t\t    {\n+\t\t\t      min = wi::to_wide (vr.min ());\n+\t\t\t      max = wi::to_wide (vr.max ());\n+\t\t\t    }\n+\t\t\t}\n \n \t\t      if (rng == VR_RANGE || rng == VR_ANTI_RANGE)\n \t\t\t{\n@@ -1809,18 +1827,17 @@ set_strlen_range (tree lhs, wide_int min, wide_int max,\n \t}\n       else if (TREE_CODE (bound) == SSA_NAME)\n \t{\n-\t  wide_int minbound, maxbound;\n-\t  // FIXME: Use range_query instead of global ranges.\n-\t  value_range_kind rng = get_range_info (bound, &minbound, &maxbound);\n-\t  if (rng == VR_RANGE)\n+\t  value_range r;\n+\t  get_range_query (cfun)->range_of_expr (r, bound);\n+\t  if (!r.undefined_p ())\n \t    {\n \t      /* For a bound in a known range, adjust the range determined\n \t\t above as necessary.  For a bound in some anti-range or\n \t\t in an unknown range, use the range determined by callers.  */\n-\t      if (wi::ltu_p (minbound, min))\n-\t\tmin = minbound;\n-\t      if (wi::ltu_p (maxbound, max))\n-\t\tmax = maxbound;\n+\t      if (wi::ltu_p (r.lower_bound (), min))\n+\t\tmin = r.lower_bound ();\n+\t      if (wi::ltu_p (r.upper_bound (), max))\n+\t\tmax = r.upper_bound ();\n \t    }\n \t}\n     }\n@@ -2780,12 +2797,15 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt,\n     return false;\n \n   wide_int cntrange[2];\n+  value_range r;\n+  if (!get_range_query (cfun)->range_of_expr (r, cnt)\n+      || r.varying_p ()\n+      || r.undefined_p ())\n+    return false;\n \n-  // FIXME: Use range_query instead of global ranges.\n-  enum value_range_kind rng = get_range_info (cnt, cntrange, cntrange + 1);\n-  if (rng == VR_RANGE)\n-    ;\n-  else if (rng == VR_ANTI_RANGE)\n+  cntrange[0] = wi::to_wide (r.min ());\n+  cntrange[1] = wi::to_wide (r.max ());\n+  if (r.kind () == VR_ANTI_RANGE)\n     {\n       wide_int maxobjsize = wi::to_wide (TYPE_MAX_VALUE (ptrdiff_type_node));\n \n@@ -2800,8 +2820,6 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt,\n \t  cntrange[0] = wi::zero (TYPE_PRECISION (TREE_TYPE (cnt)));\n \t}\n     }\n-  else\n-    return false;\n \n   /* Negative value is the constant string length.  If it's less than\n      the lower bound there is no truncation.  Avoid calling get_stridx()\n@@ -3923,13 +3941,12 @@ get_len_or_size (gimple *stmt, tree arg, int idx,\n \t}\n       else if (TREE_CODE (si->nonzero_chars) == SSA_NAME)\n \t{\n-\t  wide_int min, max;\n-\t  // FIXME: Use range_query instead of global ranges.\n-\t  value_range_kind rng = get_range_info (si->nonzero_chars, &min, &max);\n-\t  if (rng == VR_RANGE)\n+\t  value_range r;\n+\t  get_range_query (cfun)->range_of_expr (r, si->nonzero_chars);\n+\t  if (r.kind () == VR_RANGE)\n \t    {\n-\t      lenrng[0] = min.to_uhwi ();\n-\t      lenrng[1] = max.to_uhwi ();\n+\t      lenrng[0] = r.lower_bound ().to_uhwi ();\n+\t      lenrng[1] = r.upper_bound ().to_uhwi ();\n \t      *nulterm = si->full_string_p;\n \t    }\n \t}\n@@ -5301,17 +5318,13 @@ handle_integral_assign (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n \t\t  /* Reading a character before the final '\\0'\n \t\t     character.  Just set the value range to ~[0, 0]\n \t\t     if we don't have anything better.  */\n-\t\t  wide_int min, max;\n-\t\t  signop sign = TYPE_SIGN (lhs_type);\n-\t\t  int prec = TYPE_PRECISION (lhs_type);\n-\t\t  // FIXME: Use range_query instead of global ranges.\n-\t\t  value_range_kind vr = get_range_info (lhs, &min, &max);\n-\t\t  if (vr == VR_VARYING\n-\t\t      || (vr == VR_RANGE\n-\t\t\t  && min == wi::min_value (prec, sign)\n-\t\t\t  && max == wi::max_value (prec, sign)))\n-\t\t    set_range_info (lhs, VR_ANTI_RANGE,\n-\t\t\t\t    wi::zero (prec), wi::zero (prec));\n+\t\t  value_range r;\n+\t\t  if (!get_range_query (cfun)->range_of_expr (r, lhs)\n+\t\t      || r.varying_p ())\n+\t\t    {\n+\t\t      r.set_nonzero (lhs_type);\n+\t\t      set_range_info (lhs, r);\n+\t\t    }\n \t\t}\n \t    }\n \t}"}, {"sha": "7163438e23d34a735cdc2e2ac0d98ea336dad35e", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -43,6 +43,7 @@\n #include \"attribs.h\"\n #include \"tree-ssa.h\"\n #include \"tree-cfg.h\"\n+#include \"gimple-range.h\"\n \n /* The idea behind this analyzer is to generate set constraints from the\n    program, then solve the resulting constraints in order to generate the\n@@ -6740,7 +6741,9 @@ find_what_p_points_to (tree fndecl, tree p)\n   struct ptr_info_def *pi;\n   tree lookup_p = p;\n   varinfo_t vi;\n-  bool nonnull = get_ptr_nonnull (p);\n+  value_range vr;\n+  get_range_query (DECL_STRUCT_FUNCTION (fndecl))->range_of_expr (vr, p);\n+  bool nonnull = vr.nonzero_p ();\n \n   /* For parameters, get at the points-to set for the actual parm\n      decl.  */\n@@ -6758,8 +6761,7 @@ find_what_p_points_to (tree fndecl, tree p)\n   pi->pt = find_what_var_points_to (fndecl, vi);\n   /* Conservatively set to NULL from PTA (to true). */\n   pi->pt.null = 1;\n-  /* Preserve pointer nonnull computed by VRP.  See get_ptr_nonnull\n-     in gcc/tree-ssaname.c for more information.  */\n+  /* Preserve pointer nonnull globally computed.  */\n   if (nonnull)\n     set_ptr_nonnull (p);\n }"}, {"sha": "dcfdec96881889f0e2e48bc6505826c702f7007d", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"builtins.h\"\n #include \"calls.h\"\n+#include \"gimple-range.h\"\n \n /* This implements the pass that does predicate aware warning on uses of\n    possibly uninitialized variables.  The pass first collects the set of\n@@ -1606,11 +1607,14 @@ find_var_cmp_const (pred_chain_union preds, gphi *phi, gimple **flag_def,\n \t       flag_var <= [min, max] ->  flag_var < [min, max+1]\n \t       flag_var >= [min, max] ->  flag_var > [min-1, max]\n \t     if no overflow/wrap.  */\n-\t  wide_int min, max;\n \t  tree type = TREE_TYPE (cond_lhs);\n+\t  value_range r;\n \t  if (!INTEGRAL_TYPE_P (type)\n-\t      || get_range_info (cond_rhs, &min, &max) != VR_RANGE)\n+\t      || !get_range_query (cfun)->range_of_expr (r, cond_rhs)\n+\t      || r.kind () != VR_RANGE)\n \t    continue;\n+\t  wide_int min = r.lower_bound ();\n+\t  wide_int max = r.upper_bound ();\n \t  if (code == LE_EXPR\n \t      && max != wi::max_value (TYPE_PRECISION (type), TYPE_SIGN (type)))\n \t    {"}, {"sha": "294b545700863d445c198ae0b14d0ae7f177f078", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -50,6 +50,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"target.h\"\n #include \"tree-into-ssa.h\"\n #include \"omp-general.h\"\n+#include \"gimple-range.h\"\n \n /* ??? For lang_hooks.types.type_for_mode, but is there a word_mode\n    type in the GIMPLE type system that is language-independent?  */\n@@ -1553,12 +1554,15 @@ bit_test_cluster::emit (tree index_expr, tree index_type,\n \n   /* If every possible relative value of the index expression is a valid shift\n      amount, then we can merge the entry test in the bit test.  */\n-  wide_int min, max;\n   bool entry_test_needed;\n+  value_range r;\n   if (TREE_CODE (index_expr) == SSA_NAME\n-      && get_range_info (index_expr, &min, &max) == VR_RANGE\n-      && wi::leu_p (max - min, prec - 1))\n+      && get_range_query (cfun)->range_of_expr (r, index_expr)\n+      && r.kind () == VR_RANGE\n+      && wi::leu_p (r.upper_bound () - r.lower_bound (), prec - 1))\n     {\n+      wide_int min = r.lower_bound ();\n+      wide_int max = r.upper_bound ();\n       tree index_type = TREE_TYPE (index_expr);\n       minval = fold_convert (index_type, minval);\n       wide_int iminval = wi::to_wide (minval);"}, {"sha": "177d44ebb5e209372f1b52f40c725bbaf00a12fd", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -48,14 +48,21 @@ along with GCC; see the file COPYING3.  If not see\n #include \"predict.h\"\n #include \"tree-vector-builder.h\"\n #include \"vec-perm-indices.h\"\n+#include \"gimple-range.h\"\n \n /* Return true if we have a useful VR_RANGE range for VAR, storing it\n    in *MIN_VALUE and *MAX_VALUE if so.  Note the range in the dump files.  */\n \n static bool\n vect_get_range_info (tree var, wide_int *min_value, wide_int *max_value)\n {\n-  value_range_kind vr_type = get_range_info (var, min_value, max_value);\n+  value_range vr;\n+  get_range_query (cfun)->range_of_expr (vr, var);\n+  if (vr.undefined_p ())\n+    vr.set_varying (TREE_TYPE (var));\n+  *min_value = wi::to_wide (vr.min ());\n+  *max_value = wi::to_wide (vr.max ());\n+  value_range_kind vr_type = vr.kind ();\n   wide_int nonzero = get_nonzero_bits (var);\n   signop sgn = TYPE_SIGN (TREE_TYPE (var));\n   if (intersect_range_with_nonzero_bits (vr_type, min_value, max_value,\n@@ -3437,13 +3444,14 @@ vect_recog_divmod_pattern (vec_info *vinfo,\n       else\n \tt3 = t2;\n \n-      wide_int oprnd0_min, oprnd0_max;\n       int msb = 1;\n-      if (get_range_info (oprnd0, &oprnd0_min, &oprnd0_max) == VR_RANGE)\n+      value_range r;\n+      get_range_query (cfun)->range_of_expr (r, oprnd0);\n+      if (r.kind () == VR_RANGE)\n \t{\n-\t  if (!wi::neg_p (oprnd0_min, TYPE_SIGN (itype)))\n+\t  if (!wi::neg_p (r.lower_bound (), TYPE_SIGN (itype)))\n \t    msb = 0;\n-\t  else if (wi::neg_p (oprnd0_max, TYPE_SIGN (itype)))\n+\t  else if (wi::neg_p (r.upper_bound (), TYPE_SIGN (itype)))\n \t    msb = -1;\n \t}\n "}, {"sha": "450926d5f9bc89d21077f44e35a1d25f04b820b0", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -228,7 +228,7 @@ intersect_range_with_nonzero_bits (enum value_range_kind vr_type,\n \t  vr_type = VR_RANGE;\n \t}\n     }\n-  if (vr_type == VR_RANGE)\n+  if (vr_type == VR_RANGE || vr_type == VR_VARYING)\n     {\n       *max = wi::round_down_for_mask (*max, nonzero_bits);\n \n@@ -1717,7 +1717,7 @@ register_edge_assert_for_2 (tree name, edge e,\n          simply register the same assert for it.  */\n       if (CONVERT_EXPR_CODE_P (rhs_code))\n \t{\n-\t  wide_int rmin, rmax;\n+\t  value_range vr;\n \t  tree rhs1 = gimple_assign_rhs1 (def_stmt);\n \t  if (INTEGRAL_TYPE_P (TREE_TYPE (rhs1))\n \t      && TREE_CODE (rhs1) == SSA_NAME\n@@ -1739,13 +1739,14 @@ register_edge_assert_for_2 (tree name, edge e,\n \t      && int_fits_type_p (val, TREE_TYPE (rhs1))\n \t      && ((TYPE_PRECISION (TREE_TYPE (name))\n \t\t   > TYPE_PRECISION (TREE_TYPE (rhs1)))\n-\t\t  || (get_range_info (rhs1, &rmin, &rmax) == VR_RANGE\n+\t\t  || ((get_range_query (cfun)->range_of_expr (vr, rhs1)\n+\t\t       && vr.kind () == VR_RANGE)\n \t\t      && wi::fits_to_tree_p\n-\t\t\t   (widest_int::from (rmin,\n+\t\t\t   (widest_int::from (vr.lower_bound (),\n \t\t\t\t\t      TYPE_SIGN (TREE_TYPE (rhs1))),\n \t\t\t    TREE_TYPE (name))\n \t\t      && wi::fits_to_tree_p\n-\t\t\t   (widest_int::from (rmax,\n+\t\t\t   (widest_int::from (vr.upper_bound (),\n \t\t\t\t\t      TYPE_SIGN (TREE_TYPE (rhs1))),\n \t\t\t    TREE_TYPE (name)))))\n \t    add_assert_info (asserts, rhs1, rhs1,\n@@ -4631,16 +4632,14 @@ determine_value_range_1 (value_range *vr, tree expr)\n     vr->set (expr);\n   else\n     {\n-      value_range_kind kind;\n-      wide_int min, max;\n+      value_range r;\n       /* For SSA names try to extract range info computed by VRP.  Otherwise\n \t fall back to varying.  */\n       if (TREE_CODE (expr) == SSA_NAME\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (expr))\n-\t  && (kind = get_range_info (expr, &min, &max)) != VR_VARYING)\n-\tvr->set (wide_int_to_tree (TREE_TYPE (expr), min),\n-\t\t wide_int_to_tree (TREE_TYPE (expr), max),\n-\t\t kind);\n+\t  && get_range_query (cfun)->range_of_expr (r, expr)\n+\t  && !r.undefined_p ())\n+\t*vr = r;\n       else\n \tvr->set_varying (TREE_TYPE (expr));\n     }"}, {"sha": "9cafe4384aed2375c5d565530ef8f0f476543367", "filename": "gcc/tree.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -68,6 +68,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-vector-builder.h\"\n #include \"gimple-fold.h\"\n #include \"escaped_string.h\"\n+#include \"gimple-range.h\"\n \n /* Tree code classes.  */\n \n@@ -13831,8 +13832,8 @@ get_range_pos_neg (tree arg)\n \n   if (TREE_CODE (arg) != SSA_NAME)\n     return 3;\n-  wide_int arg_min, arg_max;\n-  while (get_range_info (arg, &arg_min, &arg_max) != VR_RANGE)\n+  value_range r;\n+  while (!get_global_range_query ()->range_of_expr (r, arg) || r.kind () != VR_RANGE)\n     {\n       gimple *g = SSA_NAME_DEF_STMT (arg);\n       if (is_gimple_assign (g)\n@@ -13858,16 +13859,16 @@ get_range_pos_neg (tree arg)\n     {\n       /* For unsigned values, the \"positive\" range comes\n \t below the \"negative\" range.  */\n-      if (!wi::neg_p (wi::sext (arg_max, prec), SIGNED))\n+      if (!wi::neg_p (wi::sext (r.upper_bound (), prec), SIGNED))\n \treturn 1;\n-      if (wi::neg_p (wi::sext (arg_min, prec), SIGNED))\n+      if (wi::neg_p (wi::sext (r.lower_bound (), prec), SIGNED))\n \treturn 2;\n     }\n   else\n     {\n-      if (!wi::neg_p (wi::sext (arg_min, prec), SIGNED))\n+      if (!wi::neg_p (wi::sext (r.lower_bound (), prec), SIGNED))\n \treturn 1;\n-      if (wi::neg_p (wi::sext (arg_max, prec), SIGNED))\n+      if (wi::neg_p (wi::sext (r.upper_bound (), prec), SIGNED))\n \treturn 2;\n     }\n   return 3;"}, {"sha": "d283108b7c227ac974b506363788dc469b761fc5", "filename": "gcc/vr-values.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=45f4e2b01b82c72b3a11ff4ad184d7edcf0e63d4", "patch": "@@ -117,14 +117,16 @@ vr_values::get_lattice_entry (const_tree var)\n \t     default definitions of PARM_DECLs.  */\n \t  if (POINTER_TYPE_P (TREE_TYPE (sym))\n \t      && (nonnull_arg_p (sym)\n-\t\t  || get_ptr_nonnull (var)))\n+\t\t  || (get_global_range_query ()->range_of_expr (*vr,\n+\t\t\t\t\t\tconst_cast <tree> (var))\n+\t\t      && vr->nonzero_p ())))\n \t    {\n \t      vr->set_nonzero (TREE_TYPE (sym));\n \t      vr->equiv_clear ();\n \t    }\n \t  else if (INTEGRAL_TYPE_P (TREE_TYPE (sym)))\n \t    {\n-\t      get_range_info (var, *vr);\n+\t      get_global_range_query ()->range_of_expr (*vr, const_cast <tree> (var));\n \t      if (vr->undefined_p ())\n \t\tvr->set_varying (TREE_TYPE (sym));\n \t    }\n@@ -262,7 +264,7 @@ vr_values::update_value_range (const_tree var, value_range_equiv *new_vr)\n   if (INTEGRAL_TYPE_P (TREE_TYPE (var)))\n     {\n       value_range_equiv nr;\n-      get_range_info (var, nr);\n+      get_global_range_query ()->range_of_expr (nr, const_cast <tree> (var));\n       if (!nr.undefined_p ())\n \tnew_vr->intersect (&nr);\n     }\n@@ -3829,13 +3831,13 @@ simplify_conversion_using_ranges (gimple_stmt_iterator *gsi, gimple *stmt)\n       || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (innerop))\n     return false;\n \n-  /* Get the value-range of the inner operand.  Use get_range_info in\n+  /* Get the value-range of the inner operand.  Use global ranges in\n      case innerop was created during substitute-and-fold.  */\n   wide_int imin, imax;\n   value_range vr;\n   if (!INTEGRAL_TYPE_P (TREE_TYPE (innerop)))\n     return false;\n-  get_range_info (innerop, vr);\n+  get_global_range_query ()->range_of_expr (vr, innerop, stmt);\n   if (vr.undefined_p () || vr.varying_p ())\n     return false;\n   innermin = widest_int::from (vr.lower_bound (), TYPE_SIGN (TREE_TYPE (innerop)));"}]}