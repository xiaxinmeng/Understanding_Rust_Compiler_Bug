{"sha": "852dff61566d2e005e604fb0a8ab188988ca0324", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUyZGZmNjE1NjZkMmUwMDVlNjA0ZmIwYThhYjE4ODk4OGNhMDMyNA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2002-12-12T05:13:04Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2002-12-12T05:13:04Z"}, "message": "mips.c (mips_output_conditional_branch): Support PIC-safe out-of-range branch and branch-likely.\n\n* config/mips/mips.c (mips_output_conditional_branch): Support\nPIC-safe out-of-range branch and branch-likely.\n* config/mips/mips.md (attr length): PIC-safe out-of-range\nbranches are longer.\n(\"jump\"): Support PIC-safe out-of-range-for-branch jumps.  Remove\nunused code to support indirect jumps.\n\nFrom-SVN: r60058", "tree": {"sha": "8535bfc0d0721f4de4c8fecd3380a56bd5cb907a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8535bfc0d0721f4de4c8fecd3380a56bd5cb907a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/852dff61566d2e005e604fb0a8ab188988ca0324", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852dff61566d2e005e604fb0a8ab188988ca0324", "html_url": "https://github.com/Rust-GCC/gccrs/commit/852dff61566d2e005e604fb0a8ab188988ca0324", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852dff61566d2e005e604fb0a8ab188988ca0324/comments", "author": null, "committer": null, "parents": [{"sha": "d6567b3adff339466b4e2f76d889624d2ee2a949", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6567b3adff339466b4e2f76d889624d2ee2a949", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6567b3adff339466b4e2f76d889624d2ee2a949"}], "stats": {"total": 109, "additions": 89, "deletions": 20}, "files": [{"sha": "a399390cd199c5cfe41bf31bf37675314cf7d391", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852dff61566d2e005e604fb0a8ab188988ca0324/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852dff61566d2e005e604fb0a8ab188988ca0324/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=852dff61566d2e005e604fb0a8ab188988ca0324", "patch": "@@ -1,3 +1,12 @@\n+2002-12-12  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* config/mips/mips.c (mips_output_conditional_branch): Support\n+\tPIC-safe out-of-range branch and branch-likely.\n+\t* config/mips/mips.md (attr length): PIC-safe out-of-range\n+\tbranches are longer.\n+\t(\"jump\"): Support PIC-safe out-of-range-for-branch jumps.  Remove\n+\tunused code to support indirect jumps.\n+\n 2002-12-11  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* pa.h (BIGGEST_ALIGNMENT): Change 32-bit value to 64 bits."}, {"sha": "2dcf69d3f43a5d6577de56acfa57ba9e5d17589c", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852dff61566d2e005e604fb0a8ab188988ca0324/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852dff61566d2e005e604fb0a8ab188988ca0324/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=852dff61566d2e005e604fb0a8ab188988ca0324", "patch": "@@ -10177,25 +10177,50 @@ mips_output_conditional_branch (insn,\n \n     case 12:\n     case 16:\n+    case 24:\n+    case 28:\n       {\n \t/* Generate a reversed conditional branch around ` j'\n \t   instruction:\n \n \t\t.set noreorder\n \t\t.set nomacro\n \t\tbc    l\n-\t\tnop\n+\t\tdelay_slot or #nop\n \t\tj     target\n+\t\t#nop\n+\t     l:\n \t\t.set macro\n \t\t.set reorder\n+\n+\t   If the original branch was a likely branch, the delay slot\n+\t   must be executed only if the branch is taken, so generate:\n+\n+\t\t.set noreorder\n+\t\t.set nomacro\n+\t\tbc    l\n+\t\t#nop\n+\t\tj     target\n+\t\tdelay slot or #nop\n \t     l:\n+\t\t.set macro\n+\t\t.set reorder\n+\t   \n+\t   When generating non-embedded PIC, instead of:\n+\n+\t        j     target\n+\n+\t   we emit:\n \n+\t        .set noat\n+\t        la    $at, target\n+\t\tjr    $at\n+\t\t.set at\n \t*/\n \n         rtx orig_target;\n \trtx target = gen_label_rtx ();\n \n-        output_asm_insn (\"%(%<\", 0);\n         orig_target = operands[1];\n         operands[1] = target;\n \t/* Generate the reversed comparison.  This takes four\n@@ -10210,23 +10235,42 @@ mips_output_conditional_branch (insn,\n \t\t   op1,\n \t\t   op2);\n         output_asm_insn (buffer, operands);\n-        operands[1] = orig_target;\n \n-\toutput_asm_insn (\"nop\\n\\tj\\t%1\", operands);\n+        if (length != 16 && length != 28 && ! mips_branch_likely)\n+          {\n+            /* Output delay slot instruction.  */\n+            rtx insn = final_sequence;\n+            final_scan_insn (XVECEXP (insn, 0, 1), asm_out_file,\n+                             optimize, 0, 1);\n+            INSN_DELETED_P (XVECEXP (insn, 0, 1)) = 1;\n+          }\n+\telse\n+\t  output_asm_insn (\"%#\", 0);\n \n-        if (length == 16)\n-\t  output_asm_insn (\"nop\", 0);\n-        else\n+\tif (length <= 16)\n+\t  output_asm_insn (\"j\\t%0\", &orig_target);\n+\telse\n+\t  {\n+\t    if (Pmode == DImode)\n+\t      output_asm_insn (\"%[dla\\t%@,%0\\n\\tjr\\t%@%]\", &orig_target);\n+\t    else\n+\t      output_asm_insn (\"%[la\\t%@,%0\\n\\tjr\\t%@%]\", &orig_target);\n+\t  }\n+\n+        if (length != 16 && length != 28 && mips_branch_likely)\n           {\n             /* Output delay slot instruction.  */\n             rtx insn = final_sequence;\n             final_scan_insn (XVECEXP (insn, 0, 1), asm_out_file,\n                              optimize, 0, 1);\n             INSN_DELETED_P (XVECEXP (insn, 0, 1)) = 1;\n           }\n-\toutput_asm_insn (\"%>%)\", 0);\n+\telse\n+\t  output_asm_insn (\"%#\", 0);\n+\n         ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n                                    CODE_LABEL_NUMBER (target));\n+\n         return \"\";\n       }\n "}, {"sha": "cc6cda53dba0df563a65e77939a664150ef0a674", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852dff61566d2e005e604fb0a8ab188988ca0324/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852dff61566d2e005e604fb0a8ab188988ca0324/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=852dff61566d2e005e604fb0a8ab188988ca0324", "patch": "@@ -105,9 +105,12 @@\n    (cond [(eq_attr \"type\" \"branch\")\n           (cond [(lt (abs (minus (match_dup 1) (plus (pc) (const_int 4))))\n                      (const_int 131072))\n-                 (const_int 4)]\n-\t         (const_int 12))]\n-          (const_int 4)))\n+                 (const_int 4)\n+\t\t (ne (symbol_ref \"flag_pic && ! TARGET_EMBEDDED_PIC\")\n+\t\t     (const_int 0))\n+\t\t (const_int 24)\n+\t\t ] (const_int 12))\n+\t  ] (const_int 4)))\n \n ;; Attribute describing the processor.  This attribute must match exactly\n ;; with the processor_type enumeration in mips.h.\n@@ -9592,26 +9595,39 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"!TARGET_MIPS16\"\n   \"*\n {\n-  if (GET_CODE (operands[0]) == REG)\n-    return \\\"%*j\\\\t%0\\\";\n-  /* ??? I don't know why this is necessary.  This works around an\n-     assembler problem that appears when a label is defined, then referenced\n-     in a switch table, then used in a `j' instruction.  */\n-  else if (mips_abi != ABI_32 && mips_abi != ABI_O64)\n-    return \\\"%*b\\\\t%l0\\\";\n+  if (flag_pic && ! TARGET_EMBEDDED_PIC)\n+    {\n+      if (get_attr_length (insn) <= 8)\n+\treturn \\\"%*b\\\\t%l0\\\";\n+      else if (Pmode == DImode)\n+\treturn \\\"%[dla\\\\t%@,%l0\\;%*jr\\\\t%@%]\\\";\n+      else\n+\treturn \\\"%[la\\\\t%@,%l0\\;%*jr\\\\t%@%]\\\";\n+    }\n   else\n     return \\\"%*j\\\\t%l0\\\";\n }\"\n   [(set_attr \"type\"\t\"jump\")\n-   (set_attr \"mode\"\t\"none\")])\n+   (set_attr \"mode\"\t\"none\")\n+   (set (attr \"length\")\n+\t;; we can't use `j' when emitting non-embedded PIC, so we emit\n+\t;; branch, if it's in range, or load the address of the branch\n+\t;; target into $at in a PIC-compatible way and then jump to it.\n+\t(if_then_else \n+\t (ior (eq (symbol_ref \"flag_pic && ! TARGET_EMBEDDED_PIC\")\n+\t\t  (const_int 0))\n+\t      (lt (abs (minus (match_dup 0)\n+\t\t\t      (plus (pc) (const_int 4))))\n+\t\t  (const_int 131072)))\n+\t (const_int 4) (const_int 16)))])\n \n ;; We need a different insn for the mips16, because a mips16 branch\n ;; does not have a delay slot.\n \n (define_insn \"\"\n   [(set (pc)\n \t(label_ref (match_operand 0 \"\" \"\")))]\n-  \"TARGET_MIPS16 && GET_CODE (operands[0]) != REG\"\n+  \"TARGET_MIPS16\"\n   \"b\\\\t%l0\"\n   [(set_attr \"type\"\t\"branch\")\n    (set_attr \"mode\"\t\"none\")"}]}