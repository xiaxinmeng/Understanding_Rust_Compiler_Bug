{"sha": "6cce215622c7a24991d7c90d743cc82cc1b0d76c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNjZTIxNTYyMmM3YTI0OTkxZDdjOTBkNzQzY2M4MmNjMWIwZDc2Yw==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2011-08-30T13:16:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-30T13:16:22Z"}, "message": "sem_ch6.adb (Check_Return_Subtype_Indication): Issue error if the return object has an anonymous access type and the...\n\n2011-08-30  Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_ch6.adb (Check_Return_Subtype_Indication): Issue error if the\n\treturn object has an anonymous access type and the function's type is\n\ta named access type.\n\t* sem_ch8.adb (Analyze_Object_Renaming): Suppress error about renaming\n\tconversions on implicit conversions, since such conversions can occur\n\tfor anonymous access cases due to expansion. Issue error for attempt\n\tto rename an anonymous expression as an object of a named access type.\n\t* sem_res.ads (Valid_Conversion): Add defaulted parameter Report_Errs,\n\tto indicate whether this function should report errors on invalid\n\tconversions.\n\t* sem_res.adb (Resolve): For Ada 2012, in the case where the type of\n\tthe expression is of an anonymous access type and the expected type is\n\ta named general access type, rewrite the expression as a type\n\tconversion, unless this is an expression of a membership test.\n\t(Valid_Conversion.Error_Msg_N): New procedure that conditions the\n\tcalling of Error_Msg_N on new formal Report_Errs.\n\t(Valid_Conversion.Error_Msg_NE): New procedure that conditions the\n\tcalling of Error_Msg_NE on new formal Report_Errs.\n\t(Valid_Conversion): Move declaration of this function to the package\n\tspec, to allow calls from membership test processing. For Ada 2012,\n\tenforce legality restrictions on implicit conversions of anonymous\n\taccess values to general access types, disallowing such conversions in\n\tcases where the expression has a dynamic accessibility level (access\n\tparameters, stand-alone anonymous access objects, or a component of a\n\tdereference of one of the first two cases).\n\t* sem_type.adb (Covers): For Ada 2012, allow an anonymous access type\n\tin the context of a named general access expected type.\n\t* exp_ch4.adb Add with and use of Exp_Ch2.\n\t(Expand_N_In): Add processing for membership tests applied to\n\texpressions of an anonymous access type. First, Valid_Conversion is\n\tcalled to check whether the test is statically False, and then the\n\tconversion is expanded to test that the expression's accessibility\n\tlevel is no deeper than that of the tested type. In the case of\n\tanonymous access-to-tagged types, a tagged membership test is applied\n\tas well.\n\t(Tagged_Membership): Extend to handle access type cases, applying the\n\ttest to the designated types.\n\t* exp_ch6.adb (Expand_Call): When creating an extra actual for an\n\taccessibility level, and the actual is a 'Access applied to a current\n\tinstance, pass the accessibility level of the type of the current\n\tinstance rather than applying Object_Access_Level to the prefix. Add a\n\t??? comment, since this level isn't quite right either (will eventually\n\tneed to pass an implicit level parameter to init procs).\n\nFrom-SVN: r178296", "tree": {"sha": "e0000a0cf72df374303078147d1c94eff72b0539", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0000a0cf72df374303078147d1c94eff72b0539"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cce215622c7a24991d7c90d743cc82cc1b0d76c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cce215622c7a24991d7c90d743cc82cc1b0d76c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cce215622c7a24991d7c90d743cc82cc1b0d76c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cce215622c7a24991d7c90d743cc82cc1b0d76c/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e12da14140bd1ec670a97f2e9b147d16e81c8ae4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e12da14140bd1ec670a97f2e9b147d16e81c8ae4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e12da14140bd1ec670a97f2e9b147d16e81c8ae4"}], "stats": {"total": 407, "additions": 385, "deletions": 22}, "files": [{"sha": "a5892f23f73f78b6ec78b5be479f70dbc9d475da", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cce215622c7a24991d7c90d743cc82cc1b0d76c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cce215622c7a24991d7c90d743cc82cc1b0d76c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6cce215622c7a24991d7c90d743cc82cc1b0d76c", "patch": "@@ -1,3 +1,49 @@\n+2011-08-30  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_ch6.adb (Check_Return_Subtype_Indication): Issue error if the\n+\treturn object has an anonymous access type and the function's type is\n+\ta named access type.\n+\t* sem_ch8.adb (Analyze_Object_Renaming): Suppress error about renaming\n+\tconversions on implicit conversions, since such conversions can occur\n+\tfor anonymous access cases due to expansion. Issue error for attempt\n+\tto rename an anonymous expression as an object of a named access type.\n+\t* sem_res.ads (Valid_Conversion): Add defaulted parameter Report_Errs,\n+\tto indicate whether this function should report errors on invalid\n+\tconversions.\n+\t* sem_res.adb (Resolve): For Ada 2012, in the case where the type of\n+\tthe expression is of an anonymous access type and the expected type is\n+\ta named general access type, rewrite the expression as a type\n+\tconversion, unless this is an expression of a membership test.\n+\t(Valid_Conversion.Error_Msg_N): New procedure that conditions the\n+\tcalling of Error_Msg_N on new formal Report_Errs.\n+\t(Valid_Conversion.Error_Msg_NE): New procedure that conditions the\n+\tcalling of Error_Msg_NE on new formal Report_Errs.\n+\t(Valid_Conversion): Move declaration of this function to the package\n+\tspec, to allow calls from membership test processing. For Ada 2012,\n+\tenforce legality restrictions on implicit conversions of anonymous\n+\taccess values to general access types, disallowing such conversions in\n+\tcases where the expression has a dynamic accessibility level (access\n+\tparameters, stand-alone anonymous access objects, or a component of a\n+\tdereference of one of the first two cases).\n+\t* sem_type.adb (Covers): For Ada 2012, allow an anonymous access type\n+\tin the context of a named general access expected type.\n+\t* exp_ch4.adb Add with and use of Exp_Ch2.\n+\t(Expand_N_In): Add processing for membership tests applied to\n+\texpressions of an anonymous access type. First, Valid_Conversion is\n+\tcalled to check whether the test is statically False, and then the\n+\tconversion is expanded to test that the expression's accessibility\n+\tlevel is no deeper than that of the tested type. In the case of\n+\tanonymous access-to-tagged types, a tagged membership test is applied\n+\tas well.\n+\t(Tagged_Membership): Extend to handle access type cases, applying the\n+\ttest to the designated types.\n+\t* exp_ch6.adb (Expand_Call): When creating an extra actual for an\n+\taccessibility level, and the actual is a 'Access applied to a current\n+\tinstance, pass the accessibility level of the type of the current\n+\tinstance rather than applying Object_Access_Level to the prefix. Add a\n+\t??? comment, since this level isn't quite right either (will eventually\n+\tneed to pass an implicit level parameter to init procs).\n+\n 2011-08-30  Bob Duff  <duff@adacore.com>\n \n \t* s-taskin.ads: Minor comment fix."}, {"sha": "e21d9d1d79118e5bca0ee2f8d6cd20a06c94b0aa", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cce215622c7a24991d7c90d743cc82cc1b0d76c/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cce215622c7a24991d7c90d743cc82cc1b0d76c/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=6cce215622c7a24991d7c90d743cc82cc1b0d76c", "patch": "@@ -31,6 +31,7 @@ with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n with Exp_Atag; use Exp_Atag;\n+with Exp_Ch2;  use Exp_Ch2;\n with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n@@ -4955,6 +4956,121 @@ package body Exp_Ch4 is\n                Rewrite (N, Cond);\n                Analyze_And_Resolve (N, Restyp);\n             end if;\n+\n+            --  Ada 2012 (AI05-0149): Handle membership tests applied to an\n+            --  expression of an anonymous access type. This can involve an\n+            --  accessibility test and a tagged type membership test in the\n+            --  case of tagged designated types.\n+\n+            if Ada_Version >= Ada_2012\n+              and then Is_Acc\n+              and then Ekind (Ltyp) = E_Anonymous_Access_Type\n+            then\n+               declare\n+                  Expr_Entity : Entity_Id := Empty;\n+                  New_N       : Node_Id;\n+                  Param_Level : Node_Id;\n+                  Type_Level  : Node_Id;\n+               begin\n+                  if Is_Entity_Name (Lop) then\n+                     Expr_Entity := Param_Entity (Lop);\n+                     if not Present (Expr_Entity) then\n+                        Expr_Entity := Entity (Lop);\n+                     end if;\n+                  end if;\n+\n+                  --  If a conversion of the anonymous access value to the\n+                  --  tested type would be illegal, then the result is False.\n+\n+                  if not Valid_Conversion\n+                           (Lop, Rtyp, Lop, Report_Errs => False)\n+                  then\n+                     Rewrite (N, New_Occurrence_Of (Standard_False, Loc));\n+                     Analyze_And_Resolve (N, Restyp);\n+\n+                  --  Apply an accessibility check if the access object has an\n+                  --  associated access level and when the level of the type is\n+                  --  less deep than the level of the access parameter. This\n+                  --  only occur for access parameters and stand-alone objects\n+                  --  of an anonymous access type.\n+\n+                  else\n+                     if Present (Expr_Entity)\n+                       and then Present (Extra_Accessibility (Expr_Entity))\n+                       and then UI_Gt\n+                                  (Object_Access_Level (Lop),\n+                                   Type_Access_Level (Rtyp))\n+                     then\n+                        Param_Level :=\n+                          New_Occurrence_Of\n+                            (Extra_Accessibility (Expr_Entity), Loc);\n+\n+                        Type_Level :=\n+                          Make_Integer_Literal (Loc, Type_Access_Level (Rtyp));\n+\n+                        --  Return True only if the accessibility level of the\n+                        --  expression entity is not deeper than the level of\n+                        --  the tested access type.\n+\n+                        Rewrite (N,\n+                          Make_And_Then (Loc,\n+                            Left_Opnd  => Relocate_Node (N),\n+                            Right_Opnd => Make_Op_Le (Loc,\n+                                            Left_Opnd  => Param_Level,\n+                                            Right_Opnd => Type_Level)));\n+\n+                        Analyze_And_Resolve (N);\n+                     end if;\n+\n+                     --  If the designated type is tagged, do tagged membership\n+                     --  operation.\n+\n+                     --  *** NOTE: we have to check not null before doing the\n+                     --  tagged membership test (but maybe that can be done\n+                     --  inside Tagged_Membership?).\n+\n+                     if Is_Tagged_Type (Typ) then\n+                        Rewrite (N,\n+                          Make_And_Then (Loc,\n+                            Left_Opnd  => Relocate_Node (N),\n+                            Right_Opnd =>\n+                              Make_Op_Ne (Loc,\n+                                Left_Opnd  => Obj,\n+                                Right_Opnd => Make_Null (Loc))));\n+\n+                        --  No expansion will be performed when VM_Target, as\n+                        --  the VM back-ends will handle the membership tests\n+                        --  directly (tags are not explicitly represented in\n+                        --  Java objects, so the normal tagged membership\n+                        --  expansion is not what we want).\n+\n+                        if Tagged_Type_Expansion then\n+\n+                           --  Note that we have to pass Original_Node, because\n+                           --  the membership test might already have been\n+                           --  rewritten by earlier parts of membership test.\n+\n+                           Tagged_Membership\n+                             (Original_Node (N), SCIL_Node, New_N);\n+\n+                           --  Update decoration of relocated node referenced\n+                           --  by the SCIL node.\n+\n+                           if Generate_SCIL and then Present (SCIL_Node) then\n+                              Set_SCIL_Node (New_N, SCIL_Node);\n+                           end if;\n+\n+                           Rewrite (N,\n+                             Make_And_Then (Loc,\n+                               Left_Opnd  => Relocate_Node (N),\n+                               Right_Opnd => New_N));\n+\n+                           Analyze_And_Resolve (N, Restyp);\n+                        end if;\n+                     end if;\n+                  end if;\n+               end;\n+            end if;\n          end;\n       end if;\n \n@@ -10909,6 +11025,15 @@ package body Exp_Ch4 is\n       Left_Type  := Available_View (Etype (Left));\n       Right_Type := Available_View (Etype (Right));\n \n+      --  In the case where the type is an access type, the test is applied\n+      --  using the designated types (needed in Ada 2012 for implicit anonymous\n+      --  access conversions, for AI05-0149).\n+\n+      if Is_Access_Type (Right_Type) then\n+         Left_Type  := Designated_Type (Left_Type);\n+         Right_Type := Designated_Type (Right_Type);\n+      end if;\n+\n       if Is_Class_Wide_Type (Left_Type) then\n          Left_Type := Root_Type (Left_Type);\n       end if;"}, {"sha": "93d8174ea6ed8e078fb088e7a71476d105eee198", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cce215622c7a24991d7c90d743cc82cc1b0d76c/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cce215622c7a24991d7c90d743cc82cc1b0d76c/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=6cce215622c7a24991d7c90d743cc82cc1b0d76c", "patch": "@@ -2436,12 +2436,39 @@ package body Exp_Ch6 is\n                         --  For X'Access, pass on the level of the prefix X\n \n                         when Attribute_Access =>\n-                           Add_Extra_Actual\n-                             (Make_Integer_Literal (Loc,\n-                               Intval =>\n-                                 Object_Access_Level\n-                                   (Prefix (Prev_Orig))),\n-                                    Extra_Accessibility (Formal));\n+                           --  If this is an Access attribute applied to the\n+                           --  the current instance object passed to a type\n+                           --  initialization procedure, then use the level\n+                           --  of the type itself. This is not really correct,\n+                           --  as there should be an extra level parameter\n+                           --  passed in with _init formals (only in the case\n+                           --  where the type is immutably limited), but we\n+                           --  don't have an easy way currently to create such\n+                           --  an extra formal (init procs aren't ever frozen).\n+                           --  For now we just use the level of the type,\n+                           --  which may be too shallow, but that works better\n+                           --  than passing Object_Access_Level of the type,\n+                           --  which can be one level too deep in some cases.\n+                           --  ???\n+\n+                           if Is_Entity_Name (Prefix (Prev_Orig))\n+                             and then Is_Type (Entity (Prefix (Prev_Orig)))\n+                           then\n+                              Add_Extra_Actual\n+                                (Make_Integer_Literal (Loc,\n+                                   Intval =>\n+                                     Type_Access_Level\n+                                       (Entity (Prefix (Prev_Orig)))),\n+                                 Extra_Accessibility (Formal));\n+\n+                           else\n+                              Add_Extra_Actual\n+                                (Make_Integer_Literal (Loc,\n+                                   Intval =>\n+                                     Object_Access_Level\n+                                       (Prefix (Prev_Orig))),\n+                                 Extra_Accessibility (Formal));\n+                           end if;\n \n                         --  Treat the unchecked attributes as library-level\n "}, {"sha": "f7e0fa5b994e985cb375ab4f05083df1d693860e", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cce215622c7a24991d7c90d743cc82cc1b0d76c/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cce215622c7a24991d7c90d743cc82cc1b0d76c/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=6cce215622c7a24991d7c90d743cc82cc1b0d76c", "patch": "@@ -564,6 +564,15 @@ package body Sem_Ch6 is\n                Error_Msg_N (\"must use anonymous access type\", Subtype_Ind);\n             end if;\n \n+         --  If the return object is of an anonymous access type, then report\n+         --  an error if the function's result type is not also anonymous.\n+\n+         elsif R_Stm_Type_Is_Anon_Access\n+           and then not R_Type_Is_Anon_Access\n+         then\n+            Error_Msg_N (\"anonymous access not allowed for function with \" &\n+                         \"named access result\", Subtype_Ind);\n+\n          --  Subtype indication case: check that the return object's type is\n          --  covered by the result type, and that the subtypes statically match\n          --  when the result subtype is constrained. Also handle record types"}, {"sha": "662a0e9bb5dc4f98ef9de51a0c11fabb109b6d8f", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cce215622c7a24991d7c90d743cc82cc1b0d76c/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cce215622c7a24991d7c90d743cc82cc1b0d76c/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=6cce215622c7a24991d7c90d743cc82cc1b0d76c", "patch": "@@ -802,8 +802,13 @@ package body Sem_Ch8 is\n          T := Entity (Subtype_Mark (N));\n          Analyze (Nam);\n \n+         --  Reject renamings of conversions unless the type is tagged, or\n+         --  the conversion is implicit (which can occur for cases of anonymous\n+         --  access types in Ada 2012).\n+\n          if Nkind (Nam) = N_Type_Conversion\n-            and then not Is_Tagged_Type (T)\n+           and then Comes_From_Source (Nam)\n+           and then not Is_Tagged_Type (T)\n          then\n             Error_Msg_N\n               (\"renaming of conversion only allowed for tagged types\", Nam);\n@@ -834,6 +839,22 @@ package body Sem_Ch8 is\n             return;\n          end if;\n \n+         --  Ada 2012 (AI05-149): Reject renaming of an anonymous access object\n+         --  when renaming declaration has a named access type. The Ada 2012\n+         --  coverage rules allow an anonymous access type in the context of\n+         --  an expected named general access type, but the renaming rules\n+         --  require the types to be the same. (An exception is when the type\n+         --  of the renaming is also an anonymous access type, which can only\n+         --  happen due to a renaming created by the expander.)\n+\n+         if Nkind (Nam) = N_Type_Conversion\n+           and then not Comes_From_Source (Nam)\n+           and then Ekind (Etype (Expression (Nam))) = E_Anonymous_Access_Type\n+           and then Ekind (T) /= E_Anonymous_Access_Type\n+         then\n+            Wrong_Type (Expression (Nam), T); -- Should we give better error???\n+         end if;\n+\n          --  Check that a class-wide object is not being renamed as an object\n          --  of a specific type. The test for access types is needed to exclude\n          --  cases where the renamed object is a dynamically tagged access"}, {"sha": "0d03b298c6f4defe294be6c281366da10f229160", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 124, "deletions": 14, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cce215622c7a24991d7c90d743cc82cc1b0d76c/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cce215622c7a24991d7c90d743cc82cc1b0d76c/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=6cce215622c7a24991d7c90d743cc82cc1b0d76c", "patch": "@@ -273,15 +273,6 @@ package body Sem_Res is\n    --  is only one requires a search over all visible entities, and happens\n    --  only in very pathological cases (see 6115-006).\n \n-   function Valid_Conversion\n-     (N       : Node_Id;\n-      Target  : Entity_Id;\n-      Operand : Node_Id) return Boolean;\n-   --  Verify legality rules given in 4.6 (8-23). Target is the target type\n-   --  of the conversion, which may be an implicit conversion of an actual\n-   --  parameter to an anonymous access type (in which case N denotes the\n-   --  actual parameter and N = Operand).\n-\n    -------------------------\n    -- Ambiguous_Character --\n    -------------------------\n@@ -2759,6 +2750,22 @@ package body Sem_Res is\n                Resolve_Unchecked_Type_Conversion                 (N, Ctx_Type);\n          end case;\n \n+         --  Ada 2012 (AI05-0149): Apply an (implicit) conversion to an\n+         --  expression of an anonymous access type that occurs in the context\n+         --  of a named general access type, except when the expression is that\n+         --  of a membership test. This ensures proper legality checking in\n+         --  terms of allowed conversions (expressions that would be illegal to\n+         --  convert implicitly are allowed in membership tests).\n+\n+         if Ada_Version >= Ada_2012\n+           and then Ekind (Ctx_Type) = E_General_Access_Type\n+           and then Ekind (Etype (N)) = E_Anonymous_Access_Type\n+           and then Nkind (Parent (N)) not in N_Membership_Test\n+         then\n+            Rewrite (N, Convert_To (Ctx_Type, Relocate_Node (N)));\n+            Analyze_And_Resolve (N, Ctx_Type);\n+         end if;\n+\n          --  If the subexpression was replaced by a non-subexpression, then\n          --  all we do is to expand it. The only legitimate case we know of\n          --  is converting procedure call statement to entry call statements,\n@@ -10097,9 +10104,10 @@ package body Sem_Res is\n    ----------------------\n \n    function Valid_Conversion\n-     (N       : Node_Id;\n-      Target  : Entity_Id;\n-      Operand : Node_Id) return Boolean\n+     (N           : Node_Id;\n+      Target      : Entity_Id;\n+      Operand     : Node_Id;\n+      Report_Errs : Boolean := True) return Boolean\n    is\n       Target_Type : constant Entity_Id := Base_Type (Target);\n       Opnd_Type   : Entity_Id := Etype (Operand);\n@@ -10109,6 +10117,15 @@ package body Sem_Res is\n          Msg   : String) return Boolean;\n       --  Little routine to post Msg if Valid is False, returns Valid value\n \n+      procedure Error_Msg_N (Msg : String; N : Node_Or_Entity_Id);\n+      --  If Report_Errs, then calls Errout.Error_Msg_N with its arguments\n+\n+      procedure Error_Msg_NE\n+        (Msg : String;\n+         N   : Node_Or_Entity_Id;\n+         E   : Node_Or_Entity_Id);\n+      --  If Report_Errs, then calls Errout.Error_Msg_NE with its arguments\n+\n       function Valid_Tagged_Conversion\n         (Target_Type : Entity_Id;\n          Opnd_Type   : Entity_Id) return Boolean;\n@@ -10134,6 +10151,32 @@ package body Sem_Res is\n          return Valid;\n       end Conversion_Check;\n \n+      -----------------\n+      -- Error_Msg_N --\n+      -----------------\n+\n+      procedure Error_Msg_N (Msg : String; N : Node_Or_Entity_Id) is\n+      begin\n+         if Report_Errs then\n+            Errout.Error_Msg_N (Msg, N);\n+         end if;\n+      end Error_Msg_N;\n+\n+      ------------------\n+      -- Error_Msg_NE --\n+      ------------------\n+\n+      procedure Error_Msg_NE\n+        (Msg : String;\n+         N   : Node_Or_Entity_Id;\n+         E   : Node_Or_Entity_Id)\n+      is\n+      begin\n+         if Report_Errs then\n+            Errout.Error_Msg_NE (Msg, N, E);\n+         end if;\n+      end Error_Msg_NE;\n+\n       ----------------------------\n       -- Valid_Array_Conversion --\n       ----------------------------\n@@ -10588,9 +10631,76 @@ package body Sem_Res is\n          if Ekind (Target_Type) /= E_Anonymous_Access_Type\n            or else Is_Local_Anonymous_Access (Target_Type)\n          then\n-            if Type_Access_Level (Opnd_Type)\n-              > Type_Access_Level (Target_Type)\n+            --  Ada 2012 (AI05-0149): Perform legality checking on implicit\n+            --  conversions from an anonymous access type to a named general\n+            --  access type. Such conversions are not allowed in the case of\n+            --  access parameters and stand-alone objects of an anonymous\n+            --  access type.\n+\n+            if Ada_Version >= Ada_2012\n+              and then not Comes_From_Source (N)\n+              and then Ekind (Target_Type) = E_General_Access_Type\n+              and then Ekind (Opnd_Type) = E_Anonymous_Access_Type\n             then\n+               if Is_Itype (Opnd_Type) then\n+\n+                  --  Implicit conversions aren't allowed for objects of an\n+                  --  anonymous access type, since such objects have nonstatic\n+                  --  levels in Ada 2012.\n+\n+                  if Nkind (Associated_Node_For_Itype (Opnd_Type)) =\n+                       N_Object_Declaration\n+                  then\n+                     Error_Msg_N\n+                       (\"implicit conversion of stand-alone anonymous \" &\n+                        \"access object not allowed\", Operand);\n+                     return False;\n+\n+                  --  Implicit conversions aren't allowed for anonymous access\n+                  --  parameters. The \"not Is_Local_Anonymous_Access_Type\" test\n+                  --  is done to exclude anonymous access results.\n+\n+                  elsif not Is_Local_Anonymous_Access (Opnd_Type)\n+                    and then Nkind_In (Associated_Node_For_Itype (Opnd_Type),\n+                                       N_Function_Specification,\n+                                       N_Procedure_Specification)\n+                  then\n+                     Error_Msg_N\n+                       (\"implicit conversion of anonymous access formal \" &\n+                        \"not allowed\", Operand);\n+                     return False;\n+\n+                  --  This is a case where there's an enclosing object whose\n+                  --  to which the \"statically deeper than\" relationship does\n+                  --  not apply (such as an access discriminant selected from\n+                  --  a dereference of an access parameter).\n+\n+                  elsif Object_Access_Level (Operand)\n+                          = Scope_Depth (Standard_Standard)\n+                  then\n+                     Error_Msg_N\n+                       (\"implicit conversion of anonymous access value \" &\n+                        \"not allowed\", Operand);\n+                     return False;\n+\n+                  --  In other cases, the level of the operand's type must be\n+                  --  statically less deep than that of the target type, else\n+                  --  implicit conversion is disallowed (by RM12-8.6(27.1/3)).\n+\n+                  elsif Type_Access_Level (Opnd_Type)\n+                          > Type_Access_Level (Target_Type)\n+                  then\n+                     Error_Msg_N\n+                       (\"implicit conversion of anonymous access value \" &\n+                        \"violates accessibility\", Operand);\n+                     return False;\n+                  end if;\n+               end if;\n+\n+            elsif Type_Access_Level (Opnd_Type)\n+                    > Type_Access_Level (Target_Type)\n+            then\n+\n                --  In an instance, this is a run-time check, but one we know\n                --  will fail, so generate an appropriate warning. The raise\n                --  will be generated by Expand_N_Type_Conversion."}, {"sha": "361b8651569c0818afa568ba835c41efcd599520", "filename": "gcc/ada/sem_res.ads", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cce215622c7a24991d7c90d743cc82cc1b0d76c/gcc%2Fada%2Fsem_res.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cce215622c7a24991d7c90d743cc82cc1b0d76c/gcc%2Fada%2Fsem_res.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.ads?ref=6cce215622c7a24991d7c90d743cc82cc1b0d76c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -122,6 +122,18 @@ package Sem_Res is\n    procedure Preanalyze_And_Resolve (N : Node_Id);\n    --  Same, but use type of node because context does not impose a single type\n \n+   function Valid_Conversion\n+     (N           : Node_Id;\n+      Target      : Entity_Id;\n+      Operand     : Node_Id;\n+      Report_Errs : Boolean := True) return Boolean;\n+   --  Verify legality rules given in 4.6 (8-23). Target is the target type\n+   --  of the conversion, which may be an implicit conversion of an actual\n+   --  parameter to an anonymous access type (in which case N denotes the\n+   --  actual parameter and N = Operand). Returns a Boolean result indicating\n+   --  whether the conversion is legal. Reports errors in the case of illegal\n+   --  conversions, unless Report_Errs is False.\n+\n private\n    procedure Resolve_Implicit_Type (N : Node_Id) renames Resolve;\n    pragma Inline (Resolve_Implicit_Type);"}, {"sha": "8c2eeeef65b492d8e6f09f3b59407c16ebe582f1", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cce215622c7a24991d7c90d743cc82cc1b0d76c/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cce215622c7a24991d7c90d743cc82cc1b0d76c/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=6cce215622c7a24991d7c90d743cc82cc1b0d76c", "patch": "@@ -967,6 +967,19 @@ package body Sem_Type is\n       then\n          return True;\n \n+      --  Ada 2012 (AI05-0149): Allow an anonymous access type in the context\n+      --  of a named general access type. An implicit conversion will be\n+      --  applied. For the resolution, one designated type must cover the\n+      --  other.\n+\n+      elsif Ada_Version >= Ada_2012\n+        and then Ekind (BT1) = E_General_Access_Type\n+        and then Ekind (BT2) = E_Anonymous_Access_Type\n+        and then (Covers (Designated_Type (T1), Designated_Type (T2))\n+                   or else Covers (Designated_Type (T2), Designated_Type (T1)))\n+      then\n+         return True;\n+\n       --  An Access_To_Subprogram is compatible with itself, or with an\n       --  anonymous type created for an attribute reference Access.\n "}]}