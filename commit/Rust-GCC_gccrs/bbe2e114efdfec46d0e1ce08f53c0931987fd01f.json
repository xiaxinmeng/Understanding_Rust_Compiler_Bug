{"sha": "bbe2e114efdfec46d0e1ce08f53c0931987fd01f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJlMmUxMTRlZmRmZWM0NmQwZTFjZTA4ZjUzYzA5MzE5ODdmZDAxZg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2018-02-20T18:56:01Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-02-20T18:56:01Z"}, "message": "re PR middle-end/82123 (spurious -Wformat-overflow warning for converted vars)\n\n\tPR middle-end/82123\n\tPR tree-optimization/81592\n\tPR middle-end/79257\n\t* gimple-ssa-sprintf.c (get_int_range): Accept vr_values parameter\n\tpass it to children as needed.\n\t(struct directive::fmtresult): Similarly.\n\t(struct directive::set_width): Similarly.\n\t(struct directive::set_precision): Similarly.\n\t(format_integer, format_directive, parse_directive): Similarly.\n\t(format_none): Accept unnamed vr_values parameter.\n\t(format_percent, format_floating, format_character): Similarly.\n\t(format_string, format_plain): Similarly.\n\nFrom-SVN: r257854", "tree": {"sha": "16fb7891bbb3aaf33e04e4dde296e4544b65fcbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16fb7891bbb3aaf33e04e4dde296e4544b65fcbd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbe2e114efdfec46d0e1ce08f53c0931987fd01f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbe2e114efdfec46d0e1ce08f53c0931987fd01f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbe2e114efdfec46d0e1ce08f53c0931987fd01f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbe2e114efdfec46d0e1ce08f53c0931987fd01f/comments", "author": null, "committer": null, "parents": [{"sha": "c3684506742ca3669add18eafdefb8a30871afb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3684506742ca3669add18eafdefb8a30871afb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3684506742ca3669add18eafdefb8a30871afb6"}], "stats": {"total": 81, "additions": 50, "deletions": 31}, "files": [{"sha": "134d5d9efda4b83cc94691b0aaad4aba7b92f28c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbe2e114efdfec46d0e1ce08f53c0931987fd01f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbe2e114efdfec46d0e1ce08f53c0931987fd01f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bbe2e114efdfec46d0e1ce08f53c0931987fd01f", "patch": "@@ -3,6 +3,15 @@\n \tPR middle-end/82123\n \tPR tree-optimization/81592\n \tPR middle-end/79257\n+\t* gimple-ssa-sprintf.c (get_int_range): Accept vr_values parameter\n+\tpass it to children as needed.\n+\t(struct directive::fmtresult): Similarly.\n+\t(struct directive::set_width): Similarly.\n+\t(struct directive::set_precision): Similarly.\n+\t(format_integer, format_directive, parse_directive): Similarly.\n+\t(format_none): Accept unnamed vr_values parameter.\n+\t(format_percent, format_floating, format_character): Similarly.\n+\t(format_string, format_plain): Similarly.\n \t* gimple-ssa-sprintf.c (sprintf_dom_walker::handle_gimple_call): Query\n \tthe EVRP range analyzer for range data rather than using global data.\n \t* gimple-ssa-sprintf.c: Include alloc-pool.h, vr-values.h and "}, {"sha": "54c91320e56a230e0cb33742b452fbb3089ff6af", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 41, "deletions": 31, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbe2e114efdfec46d0e1ce08f53c0931987fd01f/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbe2e114efdfec46d0e1ce08f53c0931987fd01f/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=bbe2e114efdfec46d0e1ce08f53c0931987fd01f", "patch": "@@ -771,7 +771,8 @@ fmtresult::type_max_digits (tree type, int base)\n }\n \n static bool\n-get_int_range (tree, HOST_WIDE_INT *, HOST_WIDE_INT *, bool, HOST_WIDE_INT);\n+get_int_range (tree, HOST_WIDE_INT *, HOST_WIDE_INT *, bool, HOST_WIDE_INT,\n+\t       class vr_values *vr_values);\n \n /* Description of a format directive.  A directive is either a plain\n    string or a conversion specification that starts with '%'.  */\n@@ -806,7 +807,7 @@ struct directive\n \n   /* Format conversion function that given a directive and an argument\n      returns the formatting result.  */\n-  fmtresult (*fmtfunc) (const directive &, tree);\n+  fmtresult (*fmtfunc) (const directive &, tree, vr_values *);\n \n   /* Return True when a the format flag CHR has been used.  */\n   bool get_flag (char chr) const\n@@ -843,9 +844,9 @@ struct directive\n      or 0, whichever is greater.  For a non-constant ARG in some range\n      set width to its range adjusting each bound to -1 if it's less.\n      For an indeterminate ARG set width to [0, INT_MAX].  */\n-  void set_width (tree arg)\n+  void set_width (tree arg, vr_values *vr_values)\n   {\n-    get_int_range (arg, width, width + 1, true, 0);\n+    get_int_range (arg, width, width + 1, true, 0, vr_values);\n   }\n \n   /* Set both bounds of the precision range to VAL.  */\n@@ -859,9 +860,9 @@ struct directive\n      or -1 whichever is greater.  For a non-constant ARG in some range\n      set precision to its range adjusting each bound to -1 if it's less.\n      For an indeterminate ARG set precision to [-1, INT_MAX].  */\n-  void set_precision (tree arg)\n+  void set_precision (tree arg, vr_values *vr_values)\n   {\n-    get_int_range (arg, prec, prec + 1, false, -1);\n+    get_int_range (arg, prec, prec + 1, false, -1, vr_values);\n   }\n \n   /* Return true if both width and precision are known to be\n@@ -1042,7 +1043,7 @@ struct sprintf_dom_walker::call_info\n /* Return the result of formatting a no-op directive (such as '%n').  */\n \n static fmtresult\n-format_none (const directive &, tree)\n+format_none (const directive &, tree, vr_values *)\n {\n   fmtresult res (0);\n   return res;\n@@ -1051,7 +1052,7 @@ format_none (const directive &, tree)\n /* Return the result of formatting the '%%' directive.  */\n \n static fmtresult\n-format_percent (const directive &, tree)\n+format_percent (const directive &, tree, vr_values *)\n {\n   fmtresult res (1);\n   return res;\n@@ -1108,7 +1109,8 @@ build_intmax_type_nodes (tree *pintmax, tree *puintmax)\n \n static bool\n get_int_range (tree arg, HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n-\t       bool absolute, HOST_WIDE_INT negbound)\n+\t       bool absolute, HOST_WIDE_INT negbound,\n+\t       class vr_values *vr_values)\n {\n   /* The type of the result.  */\n   const_tree type = integer_type_node;\n@@ -1179,7 +1181,8 @@ get_int_range (tree arg, HOST_WIDE_INT *pmin, HOST_WIDE_INT *pmax,\n       /* Handle an argument with an unknown range as if none had been\n \t provided.  */\n       if (unknown)\n-\treturn get_int_range (NULL_TREE, pmin, pmax, absolute, negbound);\n+\treturn get_int_range (NULL_TREE, pmin, pmax, absolute,\n+\t\t\t      negbound, vr_values);\n     }\n \n   /* Adjust each bound as specified by ABSOLUTE and NEGBOUND.  */\n@@ -1264,7 +1267,7 @@ adjust_range_for_overflow (tree dirtype, tree *argmin, tree *argmax)\n    used when the directive argument or its value isn't known.  */\n \n static fmtresult\n-format_integer (const directive &dir, tree arg)\n+format_integer (const directive &dir, tree arg, vr_values *vr_values)\n {\n   tree intmax_type_node;\n   tree uintmax_type_node;\n@@ -1482,7 +1485,7 @@ format_integer (const directive &dir, tree arg)\n \t      if (code == INTEGER_CST)\n \t\t{\n \t\t  arg = gimple_assign_rhs1 (def);\n-\t\t  return format_integer (dir, arg);\n+\t\t  return format_integer (dir, arg, vr_values);\n \t\t}\n \n \t      if (code == NOP_EXPR)\n@@ -1527,26 +1530,29 @@ format_integer (const directive &dir, tree arg)\n       /* For unsigned conversions/directives or signed when\n \t the minimum is positive, use the minimum and maximum to compute\n \t the shortest and longest output, respectively.  */\n-      res.range.min = format_integer (dir, argmin).range.min;\n-      res.range.max = format_integer (dir, argmax).range.max;\n+      res.range.min = format_integer (dir, argmin, vr_values).range.min;\n+      res.range.max = format_integer (dir, argmax, vr_values).range.max;\n     }\n   else if (tree_int_cst_sgn (argmax) < 0)\n     {\n       /* For signed conversions/directives if maximum is negative,\n \t use the minimum as the longest output and maximum as the\n \t shortest output.  */\n-      res.range.min = format_integer (dir, argmax).range.min;\n-      res.range.max = format_integer (dir, argmin).range.max;\n+      res.range.min = format_integer (dir, argmax, vr_values).range.min;\n+      res.range.max = format_integer (dir, argmin, vr_values).range.max;\n     }\n   else\n     {\n       /* Otherwise, 0 is inside of the range and minimum negative.  Use 0\n \t as the shortest output and for the longest output compute the\n \t length of the output of both minimum and maximum and pick the\n \t longer.  */\n-      unsigned HOST_WIDE_INT max1 = format_integer (dir, argmin).range.max;\n-      unsigned HOST_WIDE_INT max2 = format_integer (dir, argmax).range.max;\n-      res.range.min = format_integer (dir, integer_zero_node).range.min;\n+      unsigned HOST_WIDE_INT max1\n+\t= format_integer (dir, argmin, vr_values).range.max;\n+      unsigned HOST_WIDE_INT max2\n+\t= format_integer (dir, argmax, vr_values).range.max;\n+      res.range.min\n+\t= format_integer (dir, integer_zero_node, vr_values).range.min;\n       res.range.max = MAX (max1, max2);\n     }\n \n@@ -1887,7 +1893,7 @@ format_floating (const directive &dir, const HOST_WIDE_INT prec[2])\n    ARG.  */\n \n static fmtresult\n-format_floating (const directive &dir, tree arg)\n+format_floating (const directive &dir, tree arg, vr_values *)\n {\n   HOST_WIDE_INT prec[] = { dir.prec[0], dir.prec[1] };\n   tree type = (dir.modifier == FMT_LEN_L || dir.modifier == FMT_LEN_ll\n@@ -2127,7 +2133,7 @@ get_string_length (tree str)\n    vsprinf).  */\n \n static fmtresult\n-format_character (const directive &dir, tree arg)\n+format_character (const directive &dir, tree arg, vr_values *vr_values)\n {\n   fmtresult res;\n \n@@ -2139,7 +2145,7 @@ format_character (const directive &dir, tree arg)\n       res.range.min = 0;\n \n       HOST_WIDE_INT min, max;\n-      if (get_int_range (arg, &min, &max, false, 0))\n+      if (get_int_range (arg, &min, &max, false, 0, vr_values))\n \t{\n \t  if (min == 0 && max == 0)\n \t    {\n@@ -2192,7 +2198,7 @@ format_character (const directive &dir, tree arg)\n    vsprinf).  */\n \n static fmtresult\n-format_string (const directive &dir, tree arg)\n+format_string (const directive &dir, tree arg, vr_values *)\n {\n   fmtresult res;\n \n@@ -2353,7 +2359,7 @@ format_string (const directive &dir, tree arg)\n /* Format plain string (part of the format string itself).  */\n \n static fmtresult\n-format_plain (const directive &dir, tree)\n+format_plain (const directive &dir, tree, vr_values *)\n {\n   fmtresult res (dir.len);\n   return res;\n@@ -2734,7 +2740,8 @@ maybe_warn (substring_loc &dirloc, location_t argloc,\n \n static bool\n format_directive (const sprintf_dom_walker::call_info &info,\n-\t\t  format_result *res, const directive &dir)\n+\t\t  format_result *res, const directive &dir,\n+\t\t  class vr_values *vr_values)\n {\n   /* Offset of the beginning of the directive from the beginning\n      of the format string.  */\n@@ -2759,7 +2766,7 @@ format_directive (const sprintf_dom_walker::call_info &info,\n     return false;\n \n   /* Compute the range of lengths of the formatted output.  */\n-  fmtresult fmtres = dir.fmtfunc (dir, dir.arg);\n+  fmtresult fmtres = dir.fmtfunc (dir, dir.arg, vr_values);\n \n   /* Record whether the output of all directives is known to be\n      bounded by some maximum, implying that their arguments are\n@@ -3025,7 +3032,8 @@ format_directive (const sprintf_dom_walker::call_info &info,\n static size_t\n parse_directive (sprintf_dom_walker::call_info &info,\n \t\t directive &dir, format_result *res,\n-\t\t const char *str, unsigned *argno)\n+\t\t const char *str, unsigned *argno,\n+\t\t vr_values *vr_values)\n {\n   const char *pcnt = strchr (str, target_percent);\n   dir.beg = str;\n@@ -3343,7 +3351,7 @@ parse_directive (sprintf_dom_walker::call_info &info,\n   if (star_width)\n     {\n       if (INTEGRAL_TYPE_P (TREE_TYPE (star_width)))\n-\tdir.set_width (star_width);\n+\tdir.set_width (star_width, vr_values);\n       else\n \t{\n \t  /* Width specified by a va_list takes on the range [0, -INT_MIN]\n@@ -3376,7 +3384,7 @@ parse_directive (sprintf_dom_walker::call_info &info,\n   if (star_precision)\n     {\n       if (INTEGRAL_TYPE_P (TREE_TYPE (star_precision)))\n-\tdir.set_precision (star_precision);\n+\tdir.set_precision (star_precision, vr_values);\n       else\n \t{\n \t  /* Precision specified by a va_list takes on the range [-1, INT_MAX]\n@@ -3498,10 +3506,12 @@ sprintf_dom_walker::compute_format_length (call_info &info,\n       directive dir = directive ();\n       dir.dirno = dirno;\n \n-      size_t n = parse_directive (info, dir, res, pf, &argno);\n+      size_t n = parse_directive (info, dir, res, pf, &argno,\n+\t\t\t\t  evrp_range_analyzer.get_vr_values ());\n \n       /* Return failure if the format function fails.  */\n-      if (!format_directive (info, res, dir))\n+      if (!format_directive (info, res, dir,\n+\t\t\t     evrp_range_analyzer.get_vr_values ()))\n \treturn false;\n \n       /* Return success the directive is zero bytes long and it's"}]}