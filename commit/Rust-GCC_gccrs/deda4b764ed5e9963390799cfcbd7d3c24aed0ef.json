{"sha": "deda4b764ed5e9963390799cfcbd7d3c24aed0ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVkYTRiNzY0ZWQ1ZTk5NjMzOTA3OTljZmNiZDdkM2MyNGFlZDBlZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2001-05-21T15:48:49Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2001-05-21T15:48:49Z"}, "message": "dbxout.c (MINIMAL_DEBUG, [...]): Lose.\n\n        * dbxout.c (MINIMAL_DEBUG, flag_minimal_debug): Lose.\n        (dbxout_type_fields): Lose minimal_debug support.\n        (dbxout_type_methods, dbxout_type): Likewise.\n\nFrom-SVN: r42391", "tree": {"sha": "e1e91e15fefa77cce77d0fca8118ff5b868d811b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1e91e15fefa77cce77d0fca8118ff5b868d811b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/deda4b764ed5e9963390799cfcbd7d3c24aed0ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deda4b764ed5e9963390799cfcbd7d3c24aed0ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/deda4b764ed5e9963390799cfcbd7d3c24aed0ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deda4b764ed5e9963390799cfcbd7d3c24aed0ef/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7a81cf7f5c6e069df06941374279d1d21473e587", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a81cf7f5c6e069df06941374279d1d21473e587", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a81cf7f5c6e069df06941374279d1d21473e587"}], "stats": {"total": 233, "additions": 57, "deletions": 176}, "files": [{"sha": "861b4bae27c1916df46f88e6995e69f52c6f1ce7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deda4b764ed5e9963390799cfcbd7d3c24aed0ef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deda4b764ed5e9963390799cfcbd7d3c24aed0ef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=deda4b764ed5e9963390799cfcbd7d3c24aed0ef", "patch": "@@ -1,3 +1,9 @@\n+2001-05-21  Jason Merrill  <jason_merrill@redhat.com>\n+\n+\t* dbxout.c (MINIMAL_DEBUG, flag_minimal_debug): Lose.\n+\t(dbxout_type_fields): Lose minimal_debug support.\n+\t(dbxout_type_methods, dbxout_type): Likewise.\n+\n 2001-05-17  Andrew Haley  <aph@redhat.com>\n \n \t* config/rs6000/linux.h (MD_FALLBACK_FRAME_STATE_FOR): New."}, {"sha": "0d0fd64412a09513fa012f0593249355dfdaae73", "filename": "gcc/dbxout.c", "status": "modified", "additions": 51, "deletions": 176, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/deda4b764ed5e9963390799cfcbd7d3c24aed0ef/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/deda4b764ed5e9963390799cfcbd7d3c24aed0ef/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=deda4b764ed5e9963390799cfcbd7d3c24aed0ef", "patch": "@@ -131,24 +131,11 @@ Boston, MA 02111-1307, USA.  */\n #define STABS_GCC_MARKER \"gcc2_compiled.\"\n #endif\n \n-/* Nonzero means if the type has methods, only output debugging\n-   information if methods are actually written to the asm file.  This\n-   optimization only works if the debugger can detect the special C++\n-   marker.  */\n-\n-#define MINIMAL_DEBUG 1\n-\n-#ifdef NO_DOLLAR_IN_LABEL\n-#ifdef NO_DOT_IN_LABEL\n-#undef MINIMAL_DEBUG\n-#define MINIMAL_DEBUG 0\n-#endif\n-#endif\n+/* Typical USG systems don't have stab.h, and they also have\n+   no use for DBX-format debugging info.  */\n \n #if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n \n-static int flag_minimal_debug = MINIMAL_DEBUG;\n-\n /* Nonzero if we have actually used any of the GDB extensions\n    to the debugging format.  The idea is that we use them for the\n    first time only if there's a strong reason, but once we have done that,\n@@ -308,7 +295,7 @@ static void dbxout_type_fields\t\tPARAMS ((tree));\n static void dbxout_type_method_1\tPARAMS ((tree, const char *));\n static void dbxout_type_methods\t\tPARAMS ((tree));\n static void dbxout_range_type\t\tPARAMS ((tree));\n-static void dbxout_type\t\t\tPARAMS ((tree, int, int));\n+static void dbxout_type\t\t\tPARAMS ((tree, int));\n static void print_int_cst_octal\t\tPARAMS ((tree));\n static void print_octal\t\t\tPARAMS ((unsigned HOST_WIDE_INT, int));\n static void dbxout_type_name\t\tPARAMS ((tree));\n@@ -628,25 +615,6 @@ dbxout_type_fields (type)\n \t  if (tem != TYPE_FIELDS (type))\n \t    CONTIN;\n \n-\t  if (use_gnu_debug_info_extensions\n-\t      && flag_minimal_debug\n-\t      && TREE_CODE (tem) == FIELD_DECL\n-\t      && DECL_VIRTUAL_P (tem)\n-\t      && DECL_ASSEMBLER_NAME (tem))\n-\t    {\n-\t      have_used_extensions = 1;\n-\t      CHARS (3 + IDENTIFIER_LENGTH (DECL_ASSEMBLER_NAME (tem)));\n-\t      fputs (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (tem)), asmfile);\n-\t      dbxout_type (DECL_FCONTEXT (tem), 0, 0);\n-\t      fprintf (asmfile, \":\");\n-\t      dbxout_type (TREE_TYPE (tem), 0, 0);\n-\t      fputc (',', asmfile);\n-\t      fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n-\t\t       int_bit_position (tem));\n-\t      fputc (';', asmfile);\n-\t      continue;\n-\t    }\n-\n \t  if (DECL_NAME (tem))\n \t    {\n \t      fprintf (asmfile, \"%s:\", IDENTIFIER_POINTER (DECL_NAME (tem)));\n@@ -672,7 +640,7 @@ dbxout_type_fields (type)\n \n \t  dbxout_type ((TREE_CODE (tem) == FIELD_DECL\n \t\t\t&& DECL_BIT_FIELD_TYPE (tem))\n-\t\t       ? DECL_BIT_FIELD_TYPE (tem) : TREE_TYPE (tem), 0, 0);\n+\t\t       ? DECL_BIT_FIELD_TYPE (tem) : TREE_TYPE (tem), 0);\n \n \t  if (TREE_CODE (tem) == VAR_DECL)\n \t    {\n@@ -746,7 +714,7 @@ dbxout_type_method_1 (decl, debug_name)\n       fprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n \t       tree_low_cst (DECL_VINDEX (decl), 0));\n       fputc (';', asmfile);\n-      dbxout_type (DECL_CONTEXT (decl), 0, 0);\n+      dbxout_type (DECL_CONTEXT (decl), 0);\n       fprintf (asmfile, \";\");\n       CHARS (8);\n     }\n@@ -792,7 +760,7 @@ dbxout_type_methods (type)\n \n   type_identifier_length = IDENTIFIER_LENGTH (type_encoding);\n \n-  sprintf(formatted_type_identifier_length, \"%d\", type_identifier_length);\n+  sprintf (formatted_type_identifier_length, \"%d\", type_identifier_length);\n \n   if (TREE_CODE (methods) != TREE_VEC)\n     fndecl = methods;\n@@ -803,9 +771,6 @@ dbxout_type_methods (type)\n \n   while (fndecl)\n     {\n-      tree name = DECL_NAME (fndecl);\n-      int need_prefix = 1;\n-\n       /* Group together all the methods for the same operation.\n \t These differ in the types of the arguments.  */\n       for (last = NULL_TREE;\n@@ -818,7 +783,6 @@ dbxout_type_methods (type)\n \t  /* This is the \"mangled\" name of the method.\n \t     It encodes the argument types.  */\n \t  const char *debug_name;\n-\t  int show_arg_types = 0;\n \n \t  /* Skip methods that aren't FUNCTION_DECLs.  (In C++, these\n \t     include TEMPLATE_DECLs.)  The debugger doesn't know what\n@@ -838,82 +802,10 @@ dbxout_type_methods (type)\n \t  if (DECL_IGNORED_P (fndecl) || DECL_ABSTRACT (fndecl))\n \t    continue;\n \n-\t  if (flag_minimal_debug)\n-\t    {\n-\t      char marker;\n-\n-\t      /* We can't optimize a method which uses an anonymous\n-                 class, because the debugger will not be able to\n-                 associate the arbitrary class name with the actual\n-                 class.  */\n-#ifndef NO_DOLLAR_IN_LABEL\n-\t      marker = '$';\n-#else\n-\t      marker = '.';\n-#endif\n-\t      if (strchr (debug_name, marker))\n-\t\tshow_arg_types = 1;\n-\t      /* Detect ordinary methods because their mangled names\n-\t\t start with the operation name.  */\n-\t      else if (!strncmp (IDENTIFIER_POINTER (name), debug_name,\n-\t\t\t\t IDENTIFIER_LENGTH (name)))\n-\t\t{\n-\t\t  debug_name += IDENTIFIER_LENGTH (name);\n-\t\t  if (debug_name[0] == '_' && debug_name[1] == '_')\n-\t\t    {\n-\t\t      const char *method_name = debug_name + 2;\n-\t\t      const char *length_ptr =\n-\t\t\tformatted_type_identifier_length;\n-\t\t      /* Get past const and volatile qualifiers.  */\n-\t\t      while (*method_name == 'C' || *method_name == 'V')\n-\t\t\tmethod_name++;\n-\t\t      /* Skip digits for length of type_encoding.  */\n-\t\t      while (*method_name == *length_ptr && *length_ptr)\n-\t\t\t  length_ptr++, method_name++;\n-\t\t      if (! strncmp (method_name,\n-\t\t\t\t     IDENTIFIER_POINTER (type_encoding),\n-\t\t\t\t     type_identifier_length))\n-\t\t\tmethod_name += type_identifier_length;\n-\t\t      debug_name = method_name;\n-\t\t    }\n-\t\t}\n-\t      /* Detect constructors by their style of name mangling.  */\n-\t      else if (debug_name[0] == '_' && debug_name[1] == '_')\n-\t\t{\n-\t\t  const char *ctor_name = debug_name + 2;\n-\t\t  const char *length_ptr = formatted_type_identifier_length;\n-\t\t  while (*ctor_name == 'C' || *ctor_name == 'V')\n-\t\t    ctor_name++;\n-\t\t  /* Skip digits for length of type_encoding.  */\n-\t\t  while (*ctor_name == *length_ptr && *length_ptr)\n-\t\t      length_ptr++, ctor_name++;\n-\t\t  if (!strncmp (IDENTIFIER_POINTER (type_encoding), ctor_name,\n-\t\t\t\ttype_identifier_length))\n-\t\t    debug_name = ctor_name + type_identifier_length;\n-\t\t}\n-\t      /* The other alternative is a destructor.  */\n-\t      else\n-\t\tshow_arg_types = 1;\n-\n-\t      /* Output the operation name just once, for the first method\n-\t\t that we output.  */\n-\t      if (need_prefix)\n-\t\t{\n-\t\t  fprintf (asmfile, \"%s::\", IDENTIFIER_POINTER (name));\n-\t\t  CHARS (IDENTIFIER_LENGTH (name) + 2);\n-\t\t  need_prefix = 0;\n-\t\t}\n-\t    }\n-\n-\t  dbxout_type (TREE_TYPE (fndecl), 0, show_arg_types);\n+\t  dbxout_type (TREE_TYPE (fndecl), 0);\n \n \t  dbxout_type_method_1 (fndecl, debug_name);\n \t}\n-      if (!need_prefix)\n-\t{\n-          putc (';', asmfile);\n-\t  CHARS (1);\n-\t}\n     }\n }\n \n@@ -927,9 +819,9 @@ dbxout_range_type (type)\n {\n   fprintf (asmfile, \"r\");\n   if (TREE_TYPE (type))\n-    dbxout_type (TREE_TYPE (type), 0, 0);\n+    dbxout_type (TREE_TYPE (type), 0);\n   else if (TREE_CODE (type) != INTEGER_TYPE)\n-    dbxout_type (type, 0, 0); /* E.g. Pascal's ARRAY [BOOLEAN] of INTEGER */\n+    dbxout_type (type, 0); /* E.g. Pascal's ARRAY [BOOLEAN] of INTEGER */\n   else\n     {\n       /* Traditionally, we made sure 'int' was type 1, and builtin types\n@@ -980,16 +872,12 @@ dbxout_range_type (type)\n    If FULL is nonzero, and the type has been described only with\n    a forward-reference, output the definition now.\n    If FULL is zero in this case, just refer to the forward-reference\n-   using the number previously allocated.\n-\n-   If SHOW_ARG_TYPES is nonzero, we output a description of the argument\n-   types for a METHOD_TYPE.  */\n+   using the number previously allocated.  */\n \n static void\n-dbxout_type (type, full, show_arg_types)\n+dbxout_type (type, full)\n      tree type;\n      int full;\n-     int show_arg_types;\n {\n   register tree tem;\n   static int anonymous_type_number = 0;\n@@ -1114,7 +1002,7 @@ dbxout_type (type, full, show_arg_types)\n   if (TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n       && DECL_ORIGINAL_TYPE (TYPE_NAME (type)))\n     { \n-      dbxout_type (DECL_ORIGINAL_TYPE (TYPE_NAME (type)), 0, 0);\n+      dbxout_type (DECL_ORIGINAL_TYPE (TYPE_NAME (type)), 0);\n       return;\n     }\n \n@@ -1246,7 +1134,7 @@ dbxout_type (type, full, show_arg_types)\n     case FILE_TYPE:\n       putc ('d', asmfile);\n       CHARS (1);\n-      dbxout_type (TREE_TYPE (type), 0, 0);\n+      dbxout_type (TREE_TYPE (type), 0);\n       break;\n \n     case COMPLEX_TYPE:\n@@ -1271,13 +1159,13 @@ dbxout_type (type, full, show_arg_types)\n \n \t  fprintf (asmfile, \"real:\");\n \t  CHARS (10);\n-\t  dbxout_type (TREE_TYPE (type), 0, 0);\n+\t  dbxout_type (TREE_TYPE (type), 0);\n \t  fprintf (asmfile, \",%d,%d;\",\n \t\t   0, TYPE_PRECISION (TREE_TYPE (type)));\n \t  CHARS (8);\n \t  fprintf (asmfile, \"imag:\");\n \t  CHARS (5);\n-\t  dbxout_type (TREE_TYPE (type), 0, 0);\n+\t  dbxout_type (TREE_TYPE (type), 0);\n \t  fprintf (asmfile, \",%d,%d;;\",\n \t\t   TYPE_PRECISION (TREE_TYPE (type)),\n \t\t   TYPE_PRECISION (TREE_TYPE (type)));\n@@ -1300,7 +1188,7 @@ dbxout_type (type, full, show_arg_types)\n \t}\n       putc ('S', asmfile);\n       CHARS (1);\n-      dbxout_type (TYPE_DOMAIN (type), 0, 0);\n+      dbxout_type (TYPE_DOMAIN (type), 0);\n       break;\n \n     case ARRAY_TYPE:\n@@ -1315,7 +1203,7 @@ dbxout_type (type, full, show_arg_types)\n \t  fprintf (asmfile, \"@S;\");\n \t  putc ('S', asmfile);\n \t  CHARS (1);\n-\t  dbxout_type (TYPE_DOMAIN (type), 0, 0);\n+\t  dbxout_type (TYPE_DOMAIN (type), 0);\n \t  break;\n \t}\n       /* Output \"a\" followed by a range type definition\n@@ -1342,7 +1230,7 @@ dbxout_type (type, full, show_arg_types)\n \t  dbxout_range_type (tem);\n \t}\n       CHARS (14);\n-      dbxout_type (TREE_TYPE (type), 0, 0);\n+      dbxout_type (TREE_TYPE (type), 0);\n       break;\n \n     case RECORD_TYPE:\n@@ -1419,7 +1307,7 @@ dbxout_type (type, full, show_arg_types)\n \t\t\t  * BITS_PER_UNIT));\n \t\tfputc (',', asmfile);\n \t\tCHARS (15);\n-\t\tdbxout_type (BINFO_TYPE (child), 0, 0);\n+\t\tdbxout_type (BINFO_TYPE (child), 0);\n \t\tputc (';', asmfile);\n \t      }\n \t    else\n@@ -1428,7 +1316,7 @@ dbxout_type (type, full, show_arg_types)\n \t\t   which have the same names at the types they hold.  */\n \t\tdbxout_type_name (BINFO_TYPE (child));\n \t\tputc (':', asmfile);\n-\t\tdbxout_type (BINFO_TYPE (child), full, 0);\n+\t\tdbxout_type (BINFO_TYPE (child), full);\n \t\tfputc (',', asmfile);\n \t\tfprintf (asmfile, HOST_WIDE_INT_PRINT_DEC,\n \t\t\t tree_low_cst (BINFO_OFFSET (child), 0)\n@@ -1472,7 +1360,7 @@ dbxout_type (type, full, show_arg_types)\n \t  if (TYPE_VFIELD (type))\n \t    {\n \t      putc ('%', asmfile);\n-\t      dbxout_type (DECL_FCONTEXT (TYPE_VFIELD (type)), 0, 0);\n+\t      dbxout_type (DECL_FCONTEXT (TYPE_VFIELD (type)), 0);\n \t    }\n \t  putc (';', asmfile);\n \t  CHARS (3);\n@@ -1531,7 +1419,7 @@ dbxout_type (type, full, show_arg_types)\n     case POINTER_TYPE:\n       putc ('*', asmfile);\n       CHARS (1);\n-      dbxout_type (TREE_TYPE (type), 0, 0);\n+      dbxout_type (TREE_TYPE (type), 0);\n       break;\n \n     case METHOD_TYPE:\n@@ -1540,33 +1428,20 @@ dbxout_type (type, full, show_arg_types)\n \t  have_used_extensions = 1;\n \t  putc ('#', asmfile);\n \t  CHARS (1);\n-\t  if (flag_minimal_debug && !show_arg_types)\n-\t    {\n-\t      /* Normally, just output the return type.\n-\t\t The argument types are encoded in the method name.  */\n-\t      putc ('#', asmfile);\n-\t      CHARS (1);\n-\t      dbxout_type (TREE_TYPE (type), 0, 0);\n-\t      putc (';', asmfile);\n-\t      CHARS (1);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* When outputting destructors, we need to write\n-\t\t the argument types out longhand.  */\n-\t      dbxout_type (TYPE_METHOD_BASETYPE (type), 0, 0);\n-\t      putc (',', asmfile);\n-\t      CHARS (1);\n-\t      dbxout_type (TREE_TYPE (type), 0, 0);\n-\t      dbxout_args (TYPE_ARG_TYPES (type));\n-\t      putc (';', asmfile);\n-\t      CHARS (1);\n-\t    }\n+\n+\t  /* Write the argument types out longhand.  */\n+\t  dbxout_type (TYPE_METHOD_BASETYPE (type), 0);\n+\t  putc (',', asmfile);\n+\t  CHARS (1);\n+\t  dbxout_type (TREE_TYPE (type), 0);\n+\t  dbxout_args (TYPE_ARG_TYPES (type));\n+\t  putc (';', asmfile);\n+\t  CHARS (1);\n \t}\n       else\n \t{\n \t  /* Treat it as a function type.  */\n-\t  dbxout_type (TREE_TYPE (type), 0, 0);\n+\t  dbxout_type (TREE_TYPE (type), 0);\n \t}\n       break;\n \n@@ -1576,16 +1451,16 @@ dbxout_type (type, full, show_arg_types)\n \t  have_used_extensions = 1;\n \t  putc ('@', asmfile);\n \t  CHARS (1);\n-\t  dbxout_type (TYPE_OFFSET_BASETYPE (type), 0, 0);\n+\t  dbxout_type (TYPE_OFFSET_BASETYPE (type), 0);\n \t  putc (',', asmfile);\n \t  CHARS (1);\n-\t  dbxout_type (TREE_TYPE (type), 0, 0);\n+\t  dbxout_type (TREE_TYPE (type), 0);\n \t}\n       else\n \t{\n \t  /* Should print as an int, because it is really\n \t     just an offset.  */\n-\t  dbxout_type (integer_type_node, 0, 0);\n+\t  dbxout_type (integer_type_node, 0);\n \t}\n       break;\n \n@@ -1594,13 +1469,13 @@ dbxout_type (type, full, show_arg_types)\n \thave_used_extensions = 1;\n       putc (use_gnu_debug_info_extensions ? '&' : '*', asmfile);\n       CHARS (1);\n-      dbxout_type (TREE_TYPE (type), 0, 0);\n+      dbxout_type (TREE_TYPE (type), 0);\n       break;\n \n     case FUNCTION_TYPE:\n       putc ('f', asmfile);\n       CHARS (1);\n-      dbxout_type (TREE_TYPE (type), 0, 0);\n+      dbxout_type (TREE_TYPE (type), 0);\n       break;\n \n     default:\n@@ -1755,9 +1630,9 @@ dbxout_symbol (decl, local)\n       current_sym_addr = XEXP (DECL_RTL (decl), 0);\n \n       if (TREE_TYPE (type))\n-\tdbxout_type (TREE_TYPE (type), 0, 0);\n+\tdbxout_type (TREE_TYPE (type), 0);\n       else\n-\tdbxout_type (void_type_node, 0, 0);\n+\tdbxout_type (void_type_node, 0);\n \n       /* For a nested function, when that function is compiled,\n \t mention the containing function name\n@@ -1828,7 +1703,7 @@ dbxout_symbol (decl, local)\n \n \t\tfprintf (asmfile, \"%s\\\"%s:T\", ASM_STABS_OP,\n \t\t\t IDENTIFIER_POINTER (name));\n-\t\tdbxout_type (type, 1, 0);\n+\t\tdbxout_type (type, 1);\n \t\tdbxout_finish_symbol (NULL_TREE);\n \t      }\n \n@@ -1859,7 +1734,7 @@ dbxout_symbol (decl, local)\n \t    putc ('t', asmfile);\n \t    current_sym_code = DBX_TYPE_DECL_STABS_CODE;\n \n-\t    dbxout_type (type, 1, 0);\n+\t    dbxout_type (type, 1);\n \t    dbxout_finish_symbol (decl);\n \t    did_output = 1;\n \t  }\n@@ -1889,7 +1764,7 @@ dbxout_symbol (decl, local)\n \n \t    fprintf (asmfile, \"%s\\\"%s:T\", ASM_STABS_OP,\n \t\t     IDENTIFIER_POINTER (name));\n-\t    dbxout_type (type, 1, 0);\n+\t    dbxout_type (type, 1);\n \t    dbxout_finish_symbol (NULL_TREE);\n \t    did_output = 1;\n \t  }\n@@ -1907,7 +1782,7 @@ dbxout_symbol (decl, local)\n \t    /* Some debuggers fail when given NULL names, so give this a\n \t       harmless name of ` '.  */\n \t    fprintf (asmfile, \"%s\\\" :T\", ASM_STABS_OP);\n-\t    dbxout_type (type, 1, 0);\n+\t    dbxout_type (type, 1);\n \t    dbxout_finish_symbol (NULL_TREE);\n \t  }\n \n@@ -2196,7 +2071,7 @@ dbxout_symbol_location (decl, type, suffix, home)\n #endif\n \n   dbxout_symbol_name (decl, suffix, letter);\n-  dbxout_type (type, 0, 0);\n+  dbxout_type (type, 0);\n   dbxout_finish_symbol (decl);\n \n #ifdef DBX_STATIC_BLOCK_END\n@@ -2351,7 +2226,7 @@ dbxout_parms (parms)\n \n \t    /* It is quite tempting to use:\n \t       \n-\t           dbxout_type (TREE_TYPE (parms), 0, 0);\n+\t           dbxout_type (TREE_TYPE (parms), 0);\n \n \t       as the next statement, rather than using DECL_ARG_TYPE(), so\n \t       that gcc reports the actual type of the parameter, rather\n@@ -2363,7 +2238,7 @@ dbxout_parms (parms)\n \t       double on the stack, but if we emit a stab saying the type is a\n \t       float, then gdb will only read in a single value, and this will\n \t       produce an erropneous value.  */\n- \t    dbxout_type (DECL_ARG_TYPE (parms), 0, 0);\n+ \t    dbxout_type (DECL_ARG_TYPE (parms), 0);\n \t    current_sym_value = DEBUGGER_ARG_OFFSET (current_sym_value, addr);\n \t    dbxout_finish_symbol (parms);\n \t  }\n@@ -2414,7 +2289,7 @@ dbxout_parms (parms)\n \t\t\t regparm_letter);\n \t      }\n \n-\t    dbxout_type (parm_type, 0, 0);\n+\t    dbxout_type (parm_type, 0);\n \t    dbxout_finish_symbol (parms);\n \t  }\n \telse if (GET_CODE (DECL_RTL (parms)) == MEM\n@@ -2467,7 +2342,7 @@ dbxout_parms (parms)\n \t\t\t regparm_letter);\n \t      }\n \n-\t    dbxout_type (TREE_TYPE (parms), 0, 0);\n+\t    dbxout_type (TREE_TYPE (parms), 0);\n \t    dbxout_finish_symbol (parms);\n \t  }\n \telse if (GET_CODE (DECL_RTL (parms)) == MEM\n@@ -2489,7 +2364,7 @@ dbxout_parms (parms)\n \t      \n \t    FORCE_TEXT;\n \t    fprintf (asmfile, \"%s\\\"%s:v\", ASM_STABS_OP, decl_name);\n-\t    dbxout_type (TREE_TYPE (parms), 0, 0);\n+\t    dbxout_type (TREE_TYPE (parms), 0);\n \t    dbxout_finish_symbol (parms);\n \t  }\n \telse if (GET_CODE (DECL_RTL (parms)) == MEM\n@@ -2545,7 +2420,7 @@ dbxout_parms (parms)\n \t    current_sym_value\n \t      = DEBUGGER_ARG_OFFSET (current_sym_value,\n \t\t\t\t     XEXP (DECL_RTL (parms), 0));\n-\t    dbxout_type (TREE_TYPE (parms), 0, 0);\n+\t    dbxout_type (TREE_TYPE (parms), 0);\n \t    dbxout_finish_symbol (parms);\n \t  }\n       }\n@@ -2598,7 +2473,7 @@ dbxout_args (args)\n   while (args)\n     {\n       putc (',', asmfile);\n-      dbxout_type (TREE_VALUE (args), 0, 0);\n+      dbxout_type (TREE_VALUE (args), 0);\n       CHARS (1);\n       args = TREE_CHAIN (args);\n     }"}]}