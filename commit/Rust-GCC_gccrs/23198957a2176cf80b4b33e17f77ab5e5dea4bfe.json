{"sha": "23198957a2176cf80b4b33e17f77ab5e5dea4bfe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjMxOTg5NTdhMjE3NmNmODBiNGIzM2UxN2Y3N2FiNWU1ZGVhNGJmZQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2009-12-14T16:55:12Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-12-14T16:55:12Z"}, "message": "re PR target/41473 (dsymutil \"Assertion failed ...\")\n\n\tPR debug/41473\n\t* dwarf2out.c (add_var_loc_to_decl): Don't drop initial empty\n\tlocations.\n\t(new_loc_list): Drop gensym arg.  Move generation of ll_symbol...\n\t(gen_llsym): ... here.  New function.\n\t(add_loc_descr_to_loc_list): Removed.\n\t(loc_descriptor): Infer mode from CONST_DOUBLEs and CONST_VECTORs.\n\t(single_element_loc_list): Removed.\n\t(dw_loc_list): Don't create entries without a location.  Don't\n\tspecial-case the first node of the list, only single nodes.\n\t(single_element_loc_list_p): Simplify.\n\t(loc_list_from_tree): Don't use DECL_RTL if loc_list is nonempty.\n\t(add_location_or_const_value_attribute): Test var loc for NULL.\n\t(convert_cfa_to_fb_loc_list): Adjust calls to new new_loc_list,\n\tcall gen_llsym if needed.\n\nFrom-SVN: r155221", "tree": {"sha": "dcda67d4f613a7e3844e5df9b0bbe883b6d92351", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcda67d4f613a7e3844e5df9b0bbe883b6d92351"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23198957a2176cf80b4b33e17f77ab5e5dea4bfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23198957a2176cf80b4b33e17f77ab5e5dea4bfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23198957a2176cf80b4b33e17f77ab5e5dea4bfe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23198957a2176cf80b4b33e17f77ab5e5dea4bfe/comments", "author": null, "committer": null, "parents": [{"sha": "20cdc2be22a6e32fd6a0fbedae32473e3698961a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20cdc2be22a6e32fd6a0fbedae32473e3698961a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20cdc2be22a6e32fd6a0fbedae32473e3698961a"}], "stats": {"total": 178, "additions": 93, "deletions": 85}, "files": [{"sha": "b1094a85df10b149d9aa8e6d4b433727e1bbd39d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23198957a2176cf80b4b33e17f77ab5e5dea4bfe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23198957a2176cf80b4b33e17f77ab5e5dea4bfe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=23198957a2176cf80b4b33e17f77ab5e5dea4bfe", "patch": "@@ -1,3 +1,21 @@\n+2009-12-14  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/41473\n+\t* dwarf2out.c (add_var_loc_to_decl): Don't drop initial empty\n+\tlocations.\n+\t(new_loc_list): Drop gensym arg.  Move generation of ll_symbol...\n+\t(gen_llsym): ... here.  New function.\n+\t(add_loc_descr_to_loc_list): Removed.\n+\t(loc_descriptor): Infer mode from CONST_DOUBLEs and CONST_VECTORs.\n+\t(single_element_loc_list): Removed.\n+\t(dw_loc_list): Don't create entries without a location.  Don't\n+\tspecial-case the first node of the list, only single nodes.\n+\t(single_element_loc_list_p): Simplify.\n+\t(loc_list_from_tree): Don't use DECL_RTL if loc_list is nonempty.\n+\t(add_location_or_const_value_attribute): Test var loc for NULL.\n+\t(convert_cfa_to_fb_loc_list): Adjust calls to new new_loc_list,\n+\tcall gen_llsym if needed.\n+\n 2009-12-14  Jakub Jelinek  <jakub@redhat.com>\n \n \t* cgraph.h (cgraph_set_nothrow_flag, cgraph_set_readonly_flag,"}, {"sha": "971b191b3013b6c980c28f799b469cb1227a10a2", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 75, "deletions": 85, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23198957a2176cf80b4b33e17f77ab5e5dea4bfe/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23198957a2176cf80b4b33e17f77ab5e5dea4bfe/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=23198957a2176cf80b4b33e17f77ab5e5dea4bfe", "patch": "@@ -6177,10 +6177,7 @@ static void gen_generic_params_dies (tree);\n static void splice_child_die (dw_die_ref, dw_die_ref);\n static int file_info_cmp (const void *, const void *);\n static dw_loc_list_ref new_loc_list (dw_loc_descr_ref, const char *,\n-\t\t\t\t     const char *, const char *, unsigned);\n-static void add_loc_descr_to_loc_list (dw_loc_list_ref *, dw_loc_descr_ref,\n-\t\t\t\t       const char *, const char *,\n-\t\t\t\t       const char *);\n+\t\t\t\t     const char *, const char *);\n static void output_loc_list (dw_loc_list_ref);\n static char *gen_internal_sym (const char *);\n \n@@ -7793,8 +7790,7 @@ add_var_loc_to_decl (tree decl, struct var_loc_node *loc)\n \t  temp->last = loc;\n \t}\n     }\n-  /* Do not add empty location to the beginning of the list.  */\n-  else if (NOTE_VAR_LOCATION_LOC (loc->var_loc_note) != NULL_RTX)\n+  else\n     {\n       temp->first = loc;\n       temp->last = loc;\n@@ -10302,40 +10298,30 @@ output_die_symbol (dw_die_ref die)\n }\n \n /* Return a new location list, given the begin and end range, and the\n-   expression. gensym tells us whether to generate a new internal symbol for\n-   this location list node, which is done for the head of the list only.  */\n+   expression.  */\n \n static inline dw_loc_list_ref\n new_loc_list (dw_loc_descr_ref expr, const char *begin, const char *end,\n-\t      const char *section, unsigned int gensym)\n+\t      const char *section)\n {\n   dw_loc_list_ref retlist = GGC_CNEW (dw_loc_list_node);\n \n   retlist->begin = begin;\n   retlist->end = end;\n   retlist->expr = expr;\n   retlist->section = section;\n-  if (gensym)\n-    retlist->ll_symbol = gen_internal_sym (\"LLST\");\n \n   return retlist;\n }\n \n-/* Add a location description expression to a location list.  */\n+/* Generate a new internal symbol for this location list node, if it\n+   hasn't got one yet.  */\n \n static inline void\n-add_loc_descr_to_loc_list (dw_loc_list_ref *list_head, dw_loc_descr_ref descr,\n-\t\t\t   const char *begin, const char *end,\n-\t\t\t   const char *section)\n+gen_llsym (dw_loc_list_ref list)\n {\n-  dw_loc_list_ref *d;\n-\n-  /* Find the end of the chain.  */\n-  for (d = list_head; (*d) != NULL; d = &(*d)->dw_loc_next)\n-    ;\n-\n-  /* Add a new location list node to the list.  */\n-  *d = new_loc_list (descr, begin, end, section, 0);\n+  gcc_assert (!list->ll_symbol);\n+  list->ll_symbol = gen_internal_sym (\"LLST\");\n }\n \n /* Output the location list given to us.  */\n@@ -13653,15 +13639,17 @@ loc_descriptor (rtx rtl, enum machine_mode mode,\n       break;\n \n     case CONST_DOUBLE:\n+      if (mode == VOIDmode)\n+\tmode = GET_MODE (rtl);\n+\n       if (mode != VOIDmode && (dwarf_version >= 4 || !dwarf_strict))\n \t{\n+\t  gcc_assert (mode == GET_MODE (rtl) || VOIDmode == GET_MODE (rtl));\n+\n \t  /* Note that a CONST_DOUBLE rtx could represent either an integer\n \t     or a floating-point constant.  A CONST_DOUBLE is used whenever\n \t     the constant requires more than one word in order to be\n \t     adequately represented.  We output CONST_DOUBLEs as blocks.  */\n-\t  if (GET_MODE (rtl) != VOIDmode)\n-\t    mode = GET_MODE (rtl);\n-\n \t  loc_result = new_loc_descr (DW_OP_implicit_value,\n \t\t\t\t      GET_MODE_SIZE (mode), 0);\n \t  if (SCALAR_FLOAT_MODE_P (mode))\n@@ -13687,6 +13675,9 @@ loc_descriptor (rtx rtl, enum machine_mode mode,\n       break;\n \n     case CONST_VECTOR:\n+      if (mode == VOIDmode)\n+\tmode = GET_MODE (rtl);\n+\n       if (mode != VOIDmode && (dwarf_version >= 4 || !dwarf_strict))\n \t{\n \t  unsigned int elt_size = GET_MODE_UNIT_SIZE (GET_MODE (rtl));\n@@ -13695,7 +13686,7 @@ loc_descriptor (rtx rtl, enum machine_mode mode,\n \t  unsigned int i;\n \t  unsigned char *p;\n \n-\t  mode = GET_MODE (rtl);\n+\t  gcc_assert (mode == GET_MODE (rtl) || VOIDmode == GET_MODE (rtl));\n \t  switch (GET_MODE_CLASS (mode))\n \t    {\n \t    case MODE_VECTOR_INT:\n@@ -13842,14 +13833,6 @@ decl_by_reference_p (tree decl)\n \t  && DECL_BY_REFERENCE (decl));\n }\n \n-/* Return single element location list containing loc descr REF.  */\n-\n-static dw_loc_list_ref\n-single_element_loc_list (dw_loc_descr_ref ref)\n-{\n-  return new_loc_list (ref, NULL, NULL, NULL, 0);\n-}\n-\n /* Helper function for dw_loc_list.  Compute proper Dwarf location descriptor\n    for VARLOC.  */\n \n@@ -13931,20 +13914,21 @@ dw_loc_list_1 (tree loc, rtx varloc, int want_address,\n   return descr;\n }\n \n-/* Return dwarf representation of location list representing for\n-   LOC_LIST of DECL.  WANT_ADDRESS has the same meaning as in\n-   loc_list_from_tree function.  */\n+/* Return the dwarf representation of the location list LOC_LIST of\n+   DECL.  WANT_ADDRESS has the same meaning as in loc_list_from_tree\n+   function.  */\n \n static dw_loc_list_ref\n-dw_loc_list (var_loc_list * loc_list, tree decl, int want_address)\n+dw_loc_list (var_loc_list *loc_list, tree decl, int want_address)\n {\n   const char *endname, *secname;\n-  dw_loc_list_ref list;\n   rtx varloc;\n   enum var_init_status initialized;\n   struct var_loc_node *node;\n   dw_loc_descr_ref descr;\n   char label_id[MAX_ARTIFICIAL_LABEL_BYTES];\n+  dw_loc_list_ref list = NULL;\n+  dw_loc_list_ref *listp = &list;\n \n   /* Now that we know what section we are using for a base,\n      actually construct the list of locations.\n@@ -13957,55 +13941,56 @@ dw_loc_list (var_loc_list * loc_list, tree decl, int want_address)\n      This means we have to special case the last node, and generate\n      a range of [last location start, end of function label].  */\n \n-  node = loc_list->first;\n   secname = secname_for_decl (decl);\n \n-  if (NOTE_VAR_LOCATION_LOC (node->var_loc_note))\n-    initialized = NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n-  else\n-    initialized = VAR_INIT_STATUS_INITIALIZED;\n-  varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n-  descr = dw_loc_list_1 (decl, varloc, want_address, initialized);\n-\n-  if (loc_list && loc_list->first != loc_list->last)\n-    list = new_loc_list (descr, node->label, node->next->label, secname, 1);\n-  else\n-    return single_element_loc_list (descr);\n-  node = node->next;\n-\n-  if (!node)\n-    return NULL;\n-\n-  for (; node->next; node = node->next)\n+  for (node = loc_list->first; node->next; node = node->next)\n     if (NOTE_VAR_LOCATION_LOC (node->var_loc_note) != NULL_RTX)\n       {\n \t/* The variable has a location between NODE->LABEL and\n \t   NODE->NEXT->LABEL.  */\n \tinitialized = NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n \tvarloc = NOTE_VAR_LOCATION (node->var_loc_note);\n \tdescr = dw_loc_list_1 (decl, varloc, want_address, initialized);\n-\tadd_loc_descr_to_loc_list (&list, descr,\n-\t\t\t\t   node->label, node->next->label, secname);\n+\tif (descr)\n+\t  {\n+\t    *listp = new_loc_list (descr, node->label, node->next->label,\n+\t\t\t\t   secname);\n+\t    listp = &(*listp)->dw_loc_next;\n+\t  }\n       }\n \n   /* If the variable has a location at the last label\n      it keeps its location until the end of function.  */\n   if (NOTE_VAR_LOCATION_LOC (node->var_loc_note) != NULL_RTX)\n     {\n-      if (!current_function_decl)\n-\tendname = text_end_label;\n-      else\n-\t{\n-\t  ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,\n-\t\t\t\t       current_function_funcdef_no);\n-\t  endname = ggc_strdup (label_id);\n-\t}\n-\n       initialized = NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n       varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n       descr = dw_loc_list_1 (decl, varloc, want_address, initialized);\n-      add_loc_descr_to_loc_list (&list, descr, node->label, endname, secname);\n+      if (descr)\n+\t{\n+\t  if (!current_function_decl)\n+\t    endname = text_end_label;\n+\t  else\n+\t    {\n+\t      ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,\n+\t\t\t\t\t   current_function_funcdef_no);\n+\t      endname = ggc_strdup (label_id);\n+\t    }\n+\n+\t  *listp = new_loc_list (descr, node->label, endname, secname);\n+\t  listp = &(*listp)->dw_loc_next;\n+\t}\n     }\n+\n+  /* Try to avoid the overhead of a location list emitting a location\n+     expression instead, but only if we didn't have more than one\n+     location entry in the first place.  If some entries were not\n+     representable, we don't want to pretend a single entry that was\n+     applies to the entire scope in which the variable is\n+     available.  */\n+  if (list && loc_list->first->next)\n+    gen_llsym (list);\n+\n   return list;\n }\n \n@@ -14015,7 +14000,8 @@ dw_loc_list (var_loc_list * loc_list, tree decl, int want_address)\n static bool\n single_element_loc_list_p (dw_loc_list_ref list)\n {\n-  return (!list->dw_loc_next && !list->begin && !list->end);\n+  gcc_assert (!list->dw_loc_next || list->ll_symbol);\n+  return !list->ll_symbol;\n }\n \n /* To each location in list LIST add loc descr REF.  */\n@@ -14315,9 +14301,9 @@ loc_list_from_tree (tree loc, int want_address)\n \trtx rtl;\n \tvar_loc_list *loc_list = lookup_decl_loc (loc);\n \n-\tif (loc_list && loc_list->first\n-\t    && (list_ret = dw_loc_list (loc_list, loc, want_address)))\n+\tif (loc_list && loc_list->first)\n \t  {\n+\t    list_ret = dw_loc_list (loc_list, loc, want_address);\n \t    have_address = want_address != 0;\n \t    break;\n \t  }\n@@ -14728,7 +14714,7 @@ loc_list_from_tree (tree loc, int want_address)\n \tadd_loc_descr_to_each (list_ret, new_loc_descr (op, size, 0));\n     }\n   if (ret)\n-    list_ret = single_element_loc_list (ret);\n+    list_ret = new_loc_list (ret, NULL, NULL, NULL);\n \n   return list_ret;\n }\n@@ -15722,15 +15708,18 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n      a constant value.  That way we are better to use add_const_value_attribute\n      rather than expanding constant value equivalent.  */\n   loc_list = lookup_decl_loc (decl);\n-  if (loc_list && loc_list->first && loc_list->first == loc_list->last)\n+  if (loc_list\n+      && loc_list->first\n+      && loc_list->first == loc_list->last\n+      && NOTE_VAR_LOCATION (loc_list->first->var_loc_note)\n+      && NOTE_VAR_LOCATION_LOC (loc_list->first->var_loc_note))\n     {\n       struct var_loc_node *node;\n \n       node = loc_list->first;\n-      rtl = NOTE_VAR_LOCATION (node->var_loc_note);\n-      if (GET_CODE (rtl) == VAR_LOCATION\n-\t  && GET_CODE (XEXP (rtl, 1)) != PARALLEL)\n-\trtl = XEXP (XEXP (rtl, 1), 0);\n+      rtl = NOTE_VAR_LOCATION_LOC (node->var_loc_note);\n+      if (GET_CODE (rtl) != PARALLEL)\n+\trtl = XEXP (rtl, 0);\n       if ((CONSTANT_P (rtl) || GET_CODE (rtl) == CONST_STRING)\n \t  && add_const_value_attribute (die, rtl))\n \t return true;\n@@ -16017,8 +16006,7 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n \tif (!cfa_equal_p (&last_cfa, &next_cfa))\n \t  {\n \t    *list_tail = new_loc_list (build_cfa_loc (&last_cfa, offset),\n-\t\t\t\t       start_label, last_label, section,\n-\t\t\t\t       list == NULL);\n+\t\t\t\t       start_label, last_label, section);\n \n \t    list_tail = &(*list_tail)->dw_loc_next;\n \t    last_cfa = next_cfa;\n@@ -16039,14 +16027,16 @@ convert_cfa_to_fb_loc_list (HOST_WIDE_INT offset)\n   if (!cfa_equal_p (&last_cfa, &next_cfa))\n     {\n       *list_tail = new_loc_list (build_cfa_loc (&last_cfa, offset),\n-\t\t\t\t start_label, last_label, section,\n-\t\t\t\t list == NULL);\n+\t\t\t\t start_label, last_label, section);\n       list_tail = &(*list_tail)->dw_loc_next;\n       start_label = last_label;\n     }\n+\n   *list_tail = new_loc_list (build_cfa_loc (&next_cfa, offset),\n-\t\t\t     start_label, fde->dw_fde_end, section,\n-\t\t\t     list == NULL);\n+\t\t\t     start_label, fde->dw_fde_end, section);\n+\n+  if (list && list->dw_loc_next)\n+    gen_llsym (list);\n \n   return list;\n }"}]}