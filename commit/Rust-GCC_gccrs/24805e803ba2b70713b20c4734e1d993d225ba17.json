{"sha": "24805e803ba2b70713b20c4734e1d993d225ba17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ4MDVlODAzYmEyYjcwNzEzYjIwYzQ3MzRlMWQ5OTNkMjI1YmExNw==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2000-08-21T10:14:18Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2000-08-21T10:14:18Z"}, "message": "diagnostic.c (context_as_prefix): Export.\n\n\t* diagnostic.c (context_as_prefix): Export.\n\t(need_error_newline): Remove.\n\t(lang_diagnostic_starter, lang_diagnostic_finalizer): New objects.\n\t(error_module_changed, record_last_error_module,\n\terror_function_changed, record_last_error_function): New functions.\n\t(initialize_diagnostics): Default intialize\n\tlang_diagnostic_starter, lang_diagnostic_finalizer.\n\t(init_output_buffer): Tweak.\n\t(file_name_as_prefix): New function.\n\t(announce_function, default_print_error_function,\n\treport_error_function, set_diagnostic_context): Tweak.\n\ncp/\n\t* lex.c (lang_init_options): Default diagnostic message maximum\n\tlength to 80, when line-wrapping.\n\nFrom-SVN: r35836", "tree": {"sha": "ca79cce10e0abbfa450780324e3cf4c8874844eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca79cce10e0abbfa450780324e3cf4c8874844eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24805e803ba2b70713b20c4734e1d993d225ba17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24805e803ba2b70713b20c4734e1d993d225ba17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24805e803ba2b70713b20c4734e1d993d225ba17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24805e803ba2b70713b20c4734e1d993d225ba17/comments", "author": null, "committer": null, "parents": [{"sha": "056b68414ebe6f82a052ae1aaf1ea5c4c6d2bcaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/056b68414ebe6f82a052ae1aaf1ea5c4c6d2bcaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/056b68414ebe6f82a052ae1aaf1ea5c4c6d2bcaf"}], "stats": {"total": 118, "additions": 98, "deletions": 20}, "files": [{"sha": "231a2bdc027c03203abc4585ed799b91e4f4cd7a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24805e803ba2b70713b20c4734e1d993d225ba17/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24805e803ba2b70713b20c4734e1d993d225ba17/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=24805e803ba2b70713b20c4734e1d993d225ba17", "patch": "@@ -1,3 +1,17 @@\n+2000-08-21  Gabriel Dos Reis  <gdr@merlin.codesourcery.com>\n+\n+\t* diagnostic.c (context_as_prefix): Export.\n+\t(need_error_newline): Remove.\n+\t(lang_diagnostic_starter, lang_diagnostic_finalizer): New objects.\n+\t(error_module_changed, record_last_error_module,\n+\terror_function_changed, record_last_error_function): New functions.\n+\t(initialize_diagnostics): Default intialize\n+\tlang_diagnostic_starter, lang_diagnostic_finalizer.\n+\t(init_output_buffer): Tweak.\n+\t(file_name_as_prefix): New function.\n+\t(announce_function, default_print_error_function,\n+\treport_error_function, set_diagnostic_context): Tweak.\n+\n 2000-08-21  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* flow.c (init_propagate_block_info): Handle SUBREG in a jump"}, {"sha": "55f3111f4f0427914966b1974d9801d25018f669", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24805e803ba2b70713b20c4734e1d993d225ba17/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24805e803ba2b70713b20c4734e1d993d225ba17/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=24805e803ba2b70713b20c4734e1d993d225ba17", "patch": "@@ -1,3 +1,8 @@\n+2000-08-21  Gabriel Dos Reis  <gdr@codesourcery.com>\n+\n+\t* lex.c (lang_init_options): Default diagnostic message maximum\n+\tlength to 80, when line-wrapping.\n+\n 2000-08-20  Mark Mitchell  <mark@codesourcery.com>\n \n \t* class.c (build_vtbl_initializer): Clear the entire"}, {"sha": "964bd569cf18fe83eb125b0c32730b94462b94b2", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24805e803ba2b70713b20c4734e1d993d225ba17/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24805e803ba2b70713b20c4734e1d993d225ba17/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=24805e803ba2b70713b20c4734e1d993d225ba17", "patch": "@@ -385,8 +385,9 @@ lang_init_options ()\n   flag_exceptions = 1;\n   /* Mark as \"unspecified\".  */\n   flag_bounds_check = -1;\n-  /* By default wrap lines at 72 characters.  */\n-  diagnostic_message_length_per_line = 72;\n+  /* By default wrap lines at 80 characters.  Is getenv (\"COLUMNS\")\n+     preferable?  */\n+  diagnostic_message_length_per_line = 80;\n   /* By default, emit location information once for every\n      diagnostic message.  */\n   set_message_prefixing_rule (DIAGNOSTICS_SHOW_PREFIX_ONCE);"}, {"sha": "7124ecd58e3fcc20d4398535ded3bd409135e82f", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 58, "deletions": 18, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24805e803ba2b70713b20c4734e1d993d225ba17/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24805e803ba2b70713b20c4734e1d993d225ba17/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=24805e803ba2b70713b20c4734e1d993d225ba17", "patch": "@@ -71,7 +71,6 @@ static void output_format PARAMS ((output_buffer *));\n static char *vbuild_message_string PARAMS ((const char *, va_list));\n static char *build_message_string PARAMS ((const char *, ...))\n      ATTRIBUTE_PRINTF_1;\n-static char *context_as_prefix PARAMS ((const char *, int, int));\n static void output_do_printf PARAMS ((output_buffer *, const char *));\n static void format_with_decl PARAMS ((output_buffer *, tree));\n static void file_and_line_for_asm PARAMS ((rtx, const char **, int *));\n@@ -121,8 +120,6 @@ static char digit_buffer[128];\n static output_buffer global_output_buffer;\n output_buffer *diagnostic_buffer = &global_output_buffer;\n \n-static int need_error_newline;\n-\n /* Function of last error message;\n    more generally, function such that if next error message is in it\n    then we don't have to mention the function name.  */\n@@ -137,6 +134,10 @@ static int last_error_tick;\n void (*print_error_function) PARAMS ((const char *)) =\n   default_print_error_function;\n \n+/* Hooks for language specific diagnostic messages pager and finalizer.  */\n+diagnostic_starter_fn lang_diagnostic_starter;\n+diagnostic_finalizer_fn lang_diagnostic_finalizer;\n+\n /* Maximum characters per line in automatic line wrapping mode.\n    Zero means don't wrap lines. */\n \n@@ -150,6 +151,36 @@ static int current_prefixing_rule;\n static int diagnostic_lock;\n \n \f\n+/* Return truthvalue if current input file is different from the most recent\n+   file involved in a diagnostic message.  */\n+int\n+error_module_changed ()\n+{\n+  return last_error_tick != input_file_stack_tick;\n+}\n+\n+/* Remember current file as being the most recent file involved in a\n+   diagnostic message.  */\n+void\n+record_last_error_module ()\n+{\n+  last_error_tick = input_file_stack_tick;\n+}\n+\n+/* Same as error_module_changed, but for function.  */\n+int\n+error_function_changed ()\n+{\n+  return last_error_function != current_function_decl;\n+}\n+\n+/* Same as record_last_error_module, but for function.  */\n+void\n+record_last_error_function ()\n+{\n+  last_error_function = current_function_decl;\n+}\n+\n /* Initialize the diagnostic message outputting machinery.  */\n \n void\n@@ -161,6 +192,9 @@ initialize_diagnostics ()\n \n   /* Proceed to actual initialization.  */\n   default_initialize_buffer (diagnostic_buffer);\n+\n+  lang_diagnostic_starter = default_diagnostic_starter;\n+  lang_diagnostic_finalizer = default_diagnostic_finalizer;\n }\n \n void\n@@ -278,6 +312,7 @@ init_output_buffer (buffer, prefix, maximum_length)\n      const char *prefix;\n      int maximum_length;\n {\n+  bzero (buffer, sizeof (output_buffer));\n   obstack_init (&buffer->obstack);\n   ideal_line_wrap_cutoff (buffer) = maximum_length;\n   prefixing_policy (buffer) = current_prefixing_rule;\n@@ -744,11 +779,9 @@ build_message_string VPARAMS ((const char *msgid, ...))\n   return str;\n }\n \n-\n /* Return a malloc'd string describing a location.  The caller is\n    responsible for freeing the memory.  */\n-\n-static char *\n+char *\n context_as_prefix (file, line, warn)\n      const char *file;\n      int line;\n@@ -770,6 +803,14 @@ context_as_prefix (file, line, warn)\n     }\n }\n \n+/* Same as context_as_prefix, but only the source FILE is given.  */\n+char *\n+file_name_as_prefix (f)\n+     const char *f;\n+{\n+  return build_message_string (\"%s: \", f);\n+}\n+\n /* Format a MESSAGE into BUFFER.  Automatically wrap lines.  */\n \n static void\n@@ -1150,8 +1191,8 @@ announce_function (decl)\n       else\n         verbatim (\" %s\", (*decl_printable_name) (decl, 2));\n       fflush (stderr);\n-      need_error_newline = 1;\n-      last_error_function = current_function_decl;\n+      output_needs_newline (diagnostic_buffer) = 1;\n+      record_last_error_function ();\n     }\n }\n \n@@ -1162,7 +1203,7 @@ void\n default_print_error_function (file)\n   const char *file;\n {\n-  if (last_error_function != current_function_decl)\n+  if (error_function_changed ())\n     {\n       char *prefix = file ? build_message_string (\"%s: \", file) : NULL;\n       output_state os;\n@@ -1187,7 +1228,7 @@ default_print_error_function (file)\n                (*decl_printable_name) (current_function_decl, 2));\n \t}\n \n-      last_error_function = current_function_decl;\n+      record_last_error_function ();\n       output_to_stream (diagnostic_buffer, stderr);\n       diagnostic_buffer->state = os;\n       free ((char*) prefix);\n@@ -1204,22 +1245,22 @@ report_error_function (file)\n {\n   struct file_stack *p;\n \n-  if (need_error_newline)\n+  if (output_needs_newline (diagnostic_buffer))\n     {\n       verbatim (\"\\n\");\n-      need_error_newline = 0;\n+      output_needs_newline (diagnostic_buffer) = 0;\n     }\n \n   if (input_file_stack && input_file_stack->next != 0\n-      && input_file_stack_tick != last_error_tick)\n+      && error_function_changed ())\n     {\n       for (p = input_file_stack->next; p; p = p->next)\n \tif (p == input_file_stack->next)\n \t  verbatim (\"In file included from %s:%d\", p->name, p->line);\n \telse\n \t  verbatim (\",\\n                 from %s:%d\", p->name, p->line);\n       verbatim (\":\\n\");\n-      last_error_tick = input_file_stack_tick;\n+      record_last_error_function ();\n     }\n \n   (*print_error_function) (input_filename);\n@@ -1616,8 +1657,7 @@ See %s for instructions.\",\n \n /* Setup DC for reporting a diagnostic MESSAGE (an error of a WARNING),\n    using arguments pointed to by ARGS_PTR, issued at a location specified\n-   by FILE and LINE.  Front-ends may override the defaut diagnostic pager\n-   and finalizer *after* this subroutine completes.  */\n+   by FILE and LINE.  */\n void\n set_diagnostic_context (dc, message, args_ptr, file, line, warn)\n      diagnostic_context *dc;\n@@ -1633,8 +1673,8 @@ set_diagnostic_context (dc, message, args_ptr, file, line, warn)\n   diagnostic_file_location (dc) = file;\n   diagnostic_line_location (dc) = line;\n   diagnostic_is_warning (dc) = warn;\n-  diagnostic_starter (dc) = default_diagnostic_starter;\n-  diagnostic_finalizer (dc) = default_diagnostic_finalizer;\n+  diagnostic_starter (dc) = lang_diagnostic_starter;\n+  diagnostic_finalizer (dc) = lang_diagnostic_finalizer;\n }\n \n static void"}, {"sha": "e3450ce46edbbb8ddbc1a4a3007894e27e39548d", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24805e803ba2b70713b20c4734e1d993d225ba17/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24805e803ba2b70713b20c4734e1d993d225ba17/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=24805e803ba2b70713b20c4734e1d993d225ba17", "patch": "@@ -27,6 +27,9 @@ Boston, MA 02111-1307, USA.  */\n /*  Forward declarations.  */\n typedef struct output_buffer output_buffer;\n typedef struct diagnostic_context diagnostic_context;\n+typedef void (*diagnostic_starter_fn) PARAMS ((output_buffer *,\n+                                               diagnostic_context *));\n+typedef diagnostic_starter_fn diagnostic_finalizer_fn;\n \n #define DIAGNOSTICS_SHOW_PREFIX_ONCE       0x0\n #define DIAGNOSTICS_SHOW_PREFIX_NEVER      0x1\n@@ -50,6 +53,10 @@ typedef struct\n   int ideal_maximum_length;\n   /* Nonzero if current PREFIX was emitted at least once.  */\n   int emitted_prefix_p;\n+\n+  /* Nonzero means one should emit a newline before outputing anything.  */\n+  int need_newline_p;\n+\n   /* Tells how often current PREFIX should be emitted:\n      o DIAGNOSTICS_SHOW_PREFIX_NEVER: never - not yet supported;\n      o DIAGNOSTICS_SHOW_PREFIX_ONCE: emit current PREFIX only once;\n@@ -79,6 +86,7 @@ struct output_buffer\n \n #define output_buffer_text_cursor(BUFFER) (BUFFER)->state.cursor\n #define output_buffer_format_args(BUFFER) *((BUFFER)->state.format_args)\n+#define output_needs_newline(BUFFER) (BUFFER)->state.need_newline_p\n \n /* This data structure bundles altogether any information relevent to\n    the context of a diagnostic message.  */\n@@ -137,6 +145,9 @@ struct diagnostic_context\n \n extern printer_fn lang_printer;\n \n+extern diagnostic_starter_fn lang_diagnostic_starter;\n+extern diagnostic_finalizer_fn lang_diagnostic_finalizer;\n+\n extern int diagnostic_message_length_per_line;\n \n /* This output buffer is used by front-ends that directly output\n@@ -178,5 +189,12 @@ void set_message_prefixing_rule PARAMS ((int));\n void output_verbatim            PARAMS ((output_buffer *, const char *, ...))\n      ATTRIBUTE_PRINTF_2;\n void verbatim PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+char *context_as_prefix         PARAMS ((const char *, int, int));\n+char *file_name_as_prefix       PARAMS ((const char *));\n+int error_module_changed        PARAMS ((void));\n+void record_last_error_module   PARAMS ((void));\n+int error_function_changed      PARAMS ((void));\n+void record_last_error_function PARAMS ((void));\n+     \n \n #endif /* __GCC_DIAGNOSTIC_H__ */"}]}