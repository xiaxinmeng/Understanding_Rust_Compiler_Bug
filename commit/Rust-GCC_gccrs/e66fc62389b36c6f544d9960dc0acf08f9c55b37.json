{"sha": "e66fc62389b36c6f544d9960dc0acf08f9c55b37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY2ZmM2MjM4OWIzNmM2ZjU0NGQ5OTYwZGMwYWNmMDhmOWM1NWIzNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-05-13T03:35:09Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-05-13T03:35:09Z"}, "message": "re PR target/66047 (vlc compilation failure with target attribute)\n\n\n\tPR target/66047\n\t* i386.c (ix86_function_sseregparm): Only return -1 if local function\n\twith implied regparm is called from -mno-sse function.\n\t(init_cumulative_args): Output error if ix86_function_sseregparm\n\treturn -1 and SSE register would be needed.\n\t(function_arg_advance_32): Likewise.\n\t(function_arg_32): Likewise.\n\t* i386.h (ix86_args): Add decl field.\n\t* gcc.target/i386/pr66047.c: New testcase.\n\nFrom-SVN: r223111", "tree": {"sha": "305dd37a74f45200746b4c315e45feb7143fff32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/305dd37a74f45200746b4c315e45feb7143fff32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e66fc62389b36c6f544d9960dc0acf08f9c55b37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e66fc62389b36c6f544d9960dc0acf08f9c55b37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e66fc62389b36c6f544d9960dc0acf08f9c55b37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e66fc62389b36c6f544d9960dc0acf08f9c55b37/comments", "author": null, "committer": null, "parents": [{"sha": "e4b5b3a5cb422662b1c4ef1102bf559082017ac3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4b5b3a5cb422662b1c4ef1102bf559082017ac3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4b5b3a5cb422662b1c4ef1102bf559082017ac3"}], "stats": {"total": 90, "additions": 79, "deletions": 11}, "files": [{"sha": "ea1909fd24ef71f52b2bda03c9b752b89eadec6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66fc62389b36c6f544d9960dc0acf08f9c55b37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66fc62389b36c6f544d9960dc0acf08f9c55b37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e66fc62389b36c6f544d9960dc0acf08f9c55b37", "patch": "@@ -1,3 +1,14 @@\n+2015-05-12  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR target/pr66047.c\n+\t* i386.c (ix86_function_sseregparm): Only return -1 if local function\n+\twith implied regparm is called from -mno-sse function.\n+\t(init_cumulative_args): Output error if ix86_function_sseregparm\n+\treturn -1 and SSE register would be needed.\n+\t(function_arg_advance_32): Likewise.\n+\t(function_arg_32): Likewise.\n+\t* i386.h (ix86_args): Add decl field.\n+\n 2015-05-12  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/65873"}, {"sha": "fd52d891257bdaee6bdfcf05210d2255f2c5f660", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 47, "deletions": 11, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66fc62389b36c6f544d9960dc0acf08f9c55b37/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66fc62389b36c6f544d9960dc0acf08f9c55b37/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e66fc62389b36c6f544d9960dc0acf08f9c55b37", "patch": "@@ -5895,7 +5895,10 @@ ix86_function_regparm (const_tree type, const_tree decl)\n /* Return 1 or 2, if we can pass up to SSE_REGPARM_MAX SFmode (1) and\n    DFmode (2) arguments in SSE registers for a function with the\n    indicated TYPE and DECL.  DECL may be NULL when calling function\n-   indirectly or considering a libcall.  Otherwise return 0.  */\n+   indirectly or considering a libcall.  Return -1 if any FP parameter\n+   should be rejected by error.  This is used in siutation we imply SSE\n+   calling convetion but the function is called from another function with\n+   SSE disabled. Otherwise return 0.  */\n \n static int\n ix86_function_sseregparm (const_tree type, const_tree decl, bool warn)\n@@ -5944,14 +5947,13 @@ ix86_function_sseregparm (const_tree type, const_tree decl, bool warn)\n \t{\n \t  /* Refuse to produce wrong code when local function with SSE enabled\n \t     is called from SSE disabled function.\n-\t     We may work hard to work out these scenarios but hopefully\n-\t     it doesnot matter in practice.  */\n+\t     FIXME: We need a way to detect these cases cross-ltrans partition\n+\t     and avoid using SSE calling conventions on local functions called\n+\t     from function with SSE disabled.  For now at least delay the\n+\t     warning until we know we are going to produce wrong code.\n+\t     See PR66047  */\n \t  if (!TARGET_SSE && warn)\n-\t    {\n-\t      error (\"calling %qD with SSE caling convention without \"\n-\t\t     \"SSE/SSE2 enabled\", decl);\n-\t      return 0;\n-\t    }\n+\t    return -1;\n \t  return TARGET_SSE2_P (target_opts_for_fn (target->decl)\n \t\t\t\t->x_ix86_isa_flags) ? 2 : 1;\n \t}\n@@ -6507,6 +6509,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n   cum->bnd_regno = FIRST_BND_REG;\n   cum->bnds_in_bt = 0;\n   cum->force_bnd_pass = 0;\n+  cum->decl = fndecl;\n \n   if (!TARGET_64BIT)\n     {\n@@ -7452,6 +7455,7 @@ function_arg_advance_32 (CUMULATIVE_ARGS *cum, machine_mode mode,\n \t\t\t HOST_WIDE_INT words)\n {\n   int res = 0;\n+  bool error_p = NULL;\n \n   switch (mode)\n     {\n@@ -7484,9 +7488,13 @@ function_arg_advance_32 (CUMULATIVE_ARGS *cum, machine_mode mode,\n       gcc_unreachable ();\n \n     case DFmode:\n+      if (cum->float_in_sse == -1)\n+\terror_p = 1;\n       if (cum->float_in_sse < 2)\n \tbreak;\n     case SFmode:\n+      if (cum->float_in_sse == -1)\n+\terror_p = 1;\n       if (cum->float_in_sse < 1)\n \tbreak;\n       /* FALLTHRU */\n@@ -7542,6 +7550,14 @@ function_arg_advance_32 (CUMULATIVE_ARGS *cum, machine_mode mode,\n \t}\n       break;\n     }\n+  if (error_p)\n+    {\n+      cum->float_in_sse = 0;\n+      error (\"calling %qD with SSE calling convention without \"\n+\t     \"SSE/SSE2 enabled\", cum->decl);\n+      sorry (\"this is a GCC bug that can be worked around by adding \"\n+\t     \"attribute used to function called\");\n+    }\n \n   return res;\n }\n@@ -7674,10 +7690,11 @@ ix86_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n static rtx\n-function_arg_32 (const CUMULATIVE_ARGS *cum, machine_mode mode,\n+function_arg_32 (CUMULATIVE_ARGS *cum, machine_mode mode,\n \t\t machine_mode orig_mode, const_tree type,\n \t\t HOST_WIDE_INT bytes, HOST_WIDE_INT words)\n {\n+  bool error_p = false;\n   /* Avoid the AL settings for the Unix64 ABI.  */\n   if (mode == VOIDmode)\n     return constm1_rtx;\n@@ -7718,9 +7735,13 @@ function_arg_32 (const CUMULATIVE_ARGS *cum, machine_mode mode,\n       break;\n \n     case DFmode:\n+      if (cum->float_in_sse == -1)\n+\terror_p = 1;\n       if (cum->float_in_sse < 2)\n \tbreak;\n     case SFmode:\n+      if (cum->float_in_sse == -1)\n+\terror_p = 1;\n       if (cum->float_in_sse < 1)\n \tbreak;\n       /* FALLTHRU */\n@@ -7779,6 +7800,14 @@ function_arg_32 (const CUMULATIVE_ARGS *cum, machine_mode mode,\n \t}\n       break;\n     }\n+  if (error_p)\n+    {\n+      cum->float_in_sse = 0;\n+      error (\"calling %qD with SSE calling convention without \"\n+\t     \"SSE/SSE2 enabled\", cum->decl);\n+      sorry (\"this is a GCC bug that can be worked around by adding \"\n+\t     \"attribute used to function called\");\n+    }\n \n   return NULL_RTX;\n }\n@@ -8258,8 +8287,15 @@ function_value_32 (machine_mode orig_mode, machine_mode mode,\n   if ((fn || fntype) && (mode == SFmode || mode == DFmode))\n     {\n       int sse_level = ix86_function_sseregparm (fntype, fn, false);\n-      if ((sse_level >= 1 && mode == SFmode)\n-\t  || (sse_level == 2 && mode == DFmode))\n+      if (sse_level == -1)\n+\t{\n+\t  error (\"calling %qD with SSE caling convention without \"\n+\t\t \"SSE/SSE2 enabled\", fn);\n+\t  sorry (\"this is a GCC bug that can be worked around by adding \"\n+\t\t \"attribute used to function called\");\n+\t}\n+      else if ((sse_level >= 1 && mode == SFmode)\n+\t       || (sse_level == 2 && mode == DFmode))\n \tregno = FIRST_SSE_REG;\n     }\n "}, {"sha": "5279b2d36c3c93358cf744003021533e3323a491", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66fc62389b36c6f544d9960dc0acf08f9c55b37/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66fc62389b36c6f544d9960dc0acf08f9c55b37/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=e66fc62389b36c6f544d9960dc0acf08f9c55b37", "patch": "@@ -1688,6 +1688,7 @@ typedef struct ix86_args {\n   int stdarg;                   /* Set to 1 if function is stdarg.  */\n   enum calling_abi call_abi;\t/* Set to SYSV_ABI for sysv abi. Otherwise\n  \t\t\t\t   MS_ABI for ms abi.  */\n+  tree decl;\t\t\t/* Callee decl.  */\n } CUMULATIVE_ARGS;\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS"}, {"sha": "d16a8707fc59300ba09c441b210cde03e8e3a735", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66fc62389b36c6f544d9960dc0acf08f9c55b37/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66fc62389b36c6f544d9960dc0acf08f9c55b37/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e66fc62389b36c6f544d9960dc0acf08f9c55b37", "patch": "@@ -1,3 +1,8 @@\n+2015-05-12  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR target/pr66047.c\n+\t* gcc.target/i386/pr66047.c: New testcase.\n+\n 2015-05-12  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/65873"}, {"sha": "60eefe4d06b65e3fb1f3c85ddc092a4e670e69b0", "filename": "gcc/testsuite/gcc.target/i386/pr66047.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e66fc62389b36c6f544d9960dc0acf08f9c55b37/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr66047.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e66fc62389b36c6f544d9960dc0acf08f9c55b37/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr66047.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr66047.c?ref=e66fc62389b36c6f544d9960dc0acf08f9c55b37", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mno-sse\" } */\n+/* { dg-require-effective-target ia32 } */\n+__attribute__((target (\"sse2\"), noinline)) static void\n+foo (void)\n+{\n+  asm volatile (\"\" : : : \"memory\");\n+}\n+\n+void\n+bar (void)\n+{\n+  foo ();\n+}\n+"}]}