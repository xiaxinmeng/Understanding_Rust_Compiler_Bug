{"sha": "55a9b91ba89e744f86bb6445797e8840585f3258", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVhOWI5MWJhODllNzQ0Zjg2YmI2NDQ1Nzk3ZTg4NDA1ODVmMzI1OA==", "commit": {"author": {"name": "Matthew Wahab", "email": "matthew.wahab@arm.com", "date": "2016-09-23T09:54:44Z"}, "committer": {"name": "Matthew Wahab", "email": "mwahab@gcc.gnu.org", "date": "2016-09-23T09:54:44Z"}, "message": "[PATCH 9/17][ARM] Add NEON FP16 arithmetic instructions.\n\ngcc/\n2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n\n\t* config/arm/iterators.md (VCVTHI): New.\n\t(NEON_VCMP): Add UNSPEC_VCLT and UNSPEC_VCLE.  Fix a long line.\n\t(NEON_VAGLTE): New.\n\t(VFM_LANE_AS): New.\n\t(VH_CVTTO): New.\n\t(V_reg): Add HF, V4HF and V8HF.  Fix white-space.\n\t(V_HALF): Add V4HF.  Fix white-space.\n\t(V_if_elem): Add HF, V4HF and V8HF.  Fix white-space.\n\t(V_s_elem): Likewise.\n\t(V_sz_elem): Fix white-space.\n\t(V_elem_ch): Likewise.\n\t(VH_elem_ch): New.\n\t(scalar_mul_constraint): Add V8HF and V4HF.\n\t(Is_float_mode): Fix white-space.\n\t(Is_d_reg): Add V4HF and V8HF.  Fix white-space.\n\t(q): Add HF.  Fix white-space.\n\t(float_sup): New.\n\t(float_SUP): New.\n\t(cmp_op_unsp): Add UNSPEC_VCALE and UNSPEC_VCALT.\n\t(neon_vfm_lane_as): New.\n\t* config/arm/neon.md (add<mode>3_fp16): New.\n\t(sub<mode>3_fp16): New.\n\t(mul<mode>3add<mode>_neon): New.\n\t(fma<VH:mode>4_intrinsic): New.\n\t(fmsub<VCVTF:mode>4_intrinsic): Fix white-space.\n\t(fmsub<VH:mode>4_intrinsic): New.\n\t(<absneg_str><mode>2): New.\n\t(neon_v<absneg_str><mode>): New.\n\t(neon_v<fp16_rnd_str><mode>): New.\n\t(neon_vrsqrte<mode>): New.\n\t(neon_vpaddv4hf): New.\n\t(neon_vadd<mode>): New.\n\t(neon_vsub<mode>): New.\n\t(neon_vmulf<mode>): New.\n\t(neon_vfma<VH:mode>): New.\n\t(neon_vfms<VH:mode>): New.\n\t(neon_vc<cmp_op><mode>): New.\n\t(neon_vc<cmp_op><mode>_fp16insn): New\n\t(neon_vc<cmp_op_unsp><mode>_fp16insn_unspec): New.\n\t(neon_vca<cmp_op><mode>): New.\n\t(neon_vca<cmp_op><mode>_fp16insn): New.\n\t(neon_vca<cmp_op_unsp><mode>_fp16insn_unspec): New.\n\t(neon_vc<cmp_op>z<mode>): New.\n\t(neon_vabd<mode>): New.\n\t(neon_v<maxmin>f<mode>): New.\n\t(neon_vp<maxmin>fv4hf: New.\n\t(neon_<fmaxmin_op><mode>): New.\n\t(neon_vrecps<mode>): New.\n\t(neon_vrsqrts<mode>): New.\n\t(neon_vrecpe<mode>): New (VH variant).\n\t(neon_vdup_lane<mode>_internal): New.\n\t(neon_vdup_lane<mode>): New.\n\t(neon_vcvt<sup><mode>): New (VCVTHI variant).\n\t(neon_vcvt<sup><mode>): New (VH variant).\n\t(neon_vcvt<sup>_n<mode>): New (VH variant).\n\t(neon_vcvt<sup>_n<mode>): New (VCVTHI variant).\n\t(neon_vcvt<vcvth_op><sup><mode>): New.\n\t(neon_vmul_lane<mode>): New.\n\t(neon_vmul_n<mode>): New.\n\t* config/arm/unspecs.md (UNSPEC_VCALE): New\n\t(UNSPEC_VCALT): New.\n\t(UNSPEC_VFMA_LANE): New.\n\t(UNSPECS_VFMS_LANE): New.\n\ntestsuite/\n2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n\n\t* gcc.target/arm/armv8_2-fp16-arith-1.c: Use arm_v8_2a_fp16_neon\n\toptions.  Add tests for float16x4_t and float16x8_t.\n\nFrom-SVN: r240415", "tree": {"sha": "72b39c3cf898aa6d3ed28f489f72c3990f2dd43c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72b39c3cf898aa6d3ed28f489f72c3990f2dd43c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55a9b91ba89e744f86bb6445797e8840585f3258", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55a9b91ba89e744f86bb6445797e8840585f3258", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55a9b91ba89e744f86bb6445797e8840585f3258", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55a9b91ba89e744f86bb6445797e8840585f3258/comments", "author": null, "committer": null, "parents": [{"sha": "64c744b962798d44aa64c491d4b32b84a27d4e93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64c744b962798d44aa64c491d4b32b84a27d4e93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64c744b962798d44aa64c491d4b32b84a27d4e93"}], "stats": {"total": 709, "additions": 650, "deletions": 59}, "files": [{"sha": "679ffca8ecec94ca34ec32f4c7793ee31969092f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a9b91ba89e744f86bb6445797e8840585f3258/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a9b91ba89e744f86bb6445797e8840585f3258/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55a9b91ba89e744f86bb6445797e8840585f3258", "patch": "@@ -1,3 +1,69 @@\n+2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n+\n+\t* config/arm/iterators.md (VCVTHI): New.\n+\t(NEON_VCMP): Add UNSPEC_VCLT and UNSPEC_VCLE.  Fix a long line.\n+\t(NEON_VAGLTE): New.\n+\t(VFM_LANE_AS): New.\n+\t(VH_CVTTO): New.\n+\t(V_reg): Add HF, V4HF and V8HF.  Fix white-space.\n+\t(V_HALF): Add V4HF.  Fix white-space.\n+\t(V_if_elem): Add HF, V4HF and V8HF.  Fix white-space.\n+\t(V_s_elem): Likewise.\n+\t(V_sz_elem): Fix white-space.\n+\t(V_elem_ch): Likewise.\n+\t(VH_elem_ch): New.\n+\t(scalar_mul_constraint): Add V8HF and V4HF.\n+\t(Is_float_mode): Fix white-space.\n+\t(Is_d_reg): Add V4HF and V8HF.  Fix white-space.\n+\t(q): Add HF.  Fix white-space.\n+\t(float_sup): New.\n+\t(float_SUP): New.\n+\t(cmp_op_unsp): Add UNSPEC_VCALE and UNSPEC_VCALT.\n+\t(neon_vfm_lane_as): New.\n+\t* config/arm/neon.md (add<mode>3_fp16): New.\n+\t(sub<mode>3_fp16): New.\n+\t(mul<mode>3add<mode>_neon): New.\n+\t(fma<VH:mode>4_intrinsic): New.\n+\t(fmsub<VCVTF:mode>4_intrinsic): Fix white-space.\n+\t(fmsub<VH:mode>4_intrinsic): New.\n+\t(<absneg_str><mode>2): New.\n+\t(neon_v<absneg_str><mode>): New.\n+\t(neon_v<fp16_rnd_str><mode>): New.\n+\t(neon_vrsqrte<mode>): New.\n+\t(neon_vpaddv4hf): New.\n+\t(neon_vadd<mode>): New.\n+\t(neon_vsub<mode>): New.\n+\t(neon_vmulf<mode>): New.\n+\t(neon_vfma<VH:mode>): New.\n+\t(neon_vfms<VH:mode>): New.\n+\t(neon_vc<cmp_op><mode>): New.\n+\t(neon_vc<cmp_op><mode>_fp16insn): New\n+\t(neon_vc<cmp_op_unsp><mode>_fp16insn_unspec): New.\n+\t(neon_vca<cmp_op><mode>): New.\n+\t(neon_vca<cmp_op><mode>_fp16insn): New.\n+\t(neon_vca<cmp_op_unsp><mode>_fp16insn_unspec): New.\n+\t(neon_vc<cmp_op>z<mode>): New.\n+\t(neon_vabd<mode>): New.\n+\t(neon_v<maxmin>f<mode>): New.\n+\t(neon_vp<maxmin>fv4hf: New.\n+\t(neon_<fmaxmin_op><mode>): New.\n+\t(neon_vrecps<mode>): New.\n+\t(neon_vrsqrts<mode>): New.\n+\t(neon_vrecpe<mode>): New (VH variant).\n+\t(neon_vdup_lane<mode>_internal): New.\n+\t(neon_vdup_lane<mode>): New.\n+\t(neon_vcvt<sup><mode>): New (VCVTHI variant).\n+\t(neon_vcvt<sup><mode>): New (VH variant).\n+\t(neon_vcvt<sup>_n<mode>): New (VH variant).\n+\t(neon_vcvt<sup>_n<mode>): New (VCVTHI variant).\n+\t(neon_vcvt<vcvth_op><sup><mode>): New.\n+\t(neon_vmul_lane<mode>): New.\n+\t(neon_vmul_n<mode>): New.\n+\t* config/arm/unspecs.md (UNSPEC_VCALE): New\n+\t(UNSPEC_VCALT): New.\n+\t(UNSPEC_VFMA_LANE): New.\n+\t(UNSPECS_VFMS_LANE): New.\n+\n 2016-09-23  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n \n \t* config/s390/s390.md (\"*extzv<mode>_zEC12\", \"*extzv<mode>_z10\")"}, {"sha": "be39e4aa73787d6e513ba3264294fb67ea6bb8ad", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 78, "deletions": 43, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a9b91ba89e744f86bb6445797e8840585f3258/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a9b91ba89e744f86bb6445797e8840585f3258/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=55a9b91ba89e744f86bb6445797e8840585f3258", "patch": "@@ -145,6 +145,9 @@\n ;; Vector modes form int->float conversions.\n (define_mode_iterator VCVTI [V2SI V4SI])\n \n+;; Vector modes for int->half conversions.\n+(define_mode_iterator VCVTHI [V4HI V8HI])\n+\n ;; Vector modes for doubleword multiply-accumulate, etc. insns.\n (define_mode_iterator VMD [V4HI V2SI V2SF])\n \n@@ -267,10 +270,14 @@\n (define_int_iterator VRINT [UNSPEC_VRINTZ UNSPEC_VRINTP UNSPEC_VRINTM\n                             UNSPEC_VRINTR UNSPEC_VRINTX UNSPEC_VRINTA])\n \n-(define_int_iterator NEON_VCMP [UNSPEC_VCEQ UNSPEC_VCGT UNSPEC_VCGE UNSPEC_VCLT UNSPEC_VCLE])\n+(define_int_iterator NEON_VCMP [UNSPEC_VCEQ UNSPEC_VCGT UNSPEC_VCGE\n+\t\t\t\tUNSPEC_VCLT UNSPEC_VCLE])\n \n (define_int_iterator NEON_VACMP [UNSPEC_VCAGE UNSPEC_VCAGT])\n \n+(define_int_iterator NEON_VAGLTE [UNSPEC_VCAGE UNSPEC_VCAGT\n+\t\t\t\t  UNSPEC_VCALE UNSPEC_VCALT])\n+\n (define_int_iterator VCVT [UNSPEC_VRINTP UNSPEC_VRINTM UNSPEC_VRINTA])\n \n (define_int_iterator NEON_VRINT [UNSPEC_NVRINTP UNSPEC_NVRINTZ UNSPEC_NVRINTM\n@@ -398,6 +405,8 @@\n \n (define_int_iterator VQRDMLH_AS [UNSPEC_VQRDMLAH UNSPEC_VQRDMLSH])\n \n+(define_int_iterator VFM_LANE_AS [UNSPEC_VFMA_LANE UNSPEC_VFMS_LANE])\n+\n ;;----------------------------------------------------------------------------\n ;; Mode attributes\n ;;----------------------------------------------------------------------------\n@@ -416,6 +425,10 @@\n (define_mode_attr V_cvtto [(V2SI \"v2sf\") (V2SF \"v2si\")\n                            (V4SI \"v4sf\") (V4SF \"v4si\")])\n \n+;; (Opposite) mode to convert to/from for vector-half mode conversions.\n+(define_mode_attr VH_CVTTO [(V4HI \"V4HF\") (V4HF \"V4HI\")\n+\t\t\t    (V8HI \"V8HF\") (V8HF \"V8HI\")])\n+\n ;; Define element mode for each vector mode.\n (define_mode_attr V_elem [(V8QI \"QI\") (V16QI \"QI\")\n \t\t\t  (V4HI \"HI\") (V8HI \"HI\")\n@@ -459,12 +472,13 @@\n \n ;; Register width from element mode\n (define_mode_attr V_reg [(V8QI \"P\") (V16QI \"q\")\n-                         (V4HI \"P\") (V8HI  \"q\")\n-                         (V4HF \"P\") (V8HF  \"q\")\n-                         (V2SI \"P\") (V4SI  \"q\")\n-                         (V2SF \"P\") (V4SF  \"q\")\n-                         (DI   \"P\") (V2DI  \"q\")\n-                         (SF   \"\")  (DF    \"P\")])\n+\t\t\t (V4HI \"P\") (V8HI  \"q\")\n+\t\t\t (V4HF \"P\") (V8HF  \"q\")\n+\t\t\t (V2SI \"P\") (V4SI  \"q\")\n+\t\t\t (V2SF \"P\") (V4SF  \"q\")\n+\t\t\t (DI   \"P\") (V2DI  \"q\")\n+\t\t\t (SF   \"\")  (DF    \"P\")\n+\t\t\t (HF   \"\")])\n \n ;; Wider modes with the same number of elements.\n (define_mode_attr V_widen [(V8QI \"V8HI\") (V4HI \"V4SI\") (V2SI \"V2DI\")])\n@@ -480,7 +494,7 @@\n (define_mode_attr V_HALF [(V16QI \"V8QI\") (V8HI \"V4HI\")\n \t\t\t  (V8HF \"V4HF\") (V4SI  \"V2SI\")\n \t\t\t  (V4SF \"V2SF\") (V2DF \"DF\")\n-                          (V2DI \"DI\")])\n+\t\t\t  (V2DI \"DI\") (V4HF \"HF\")])\n \n ;; Same, but lower-case.\n (define_mode_attr V_half [(V16QI \"v8qi\") (V8HI \"v4hi\")\n@@ -529,18 +543,22 @@\n ;; Get element type from double-width mode, for operations where we \n ;; don't care about signedness.\n (define_mode_attr V_if_elem [(V8QI \"i8\")  (V16QI \"i8\")\n-                 (V4HI \"i16\") (V8HI  \"i16\")\n-                             (V2SI \"i32\") (V4SI  \"i32\")\n-                             (DI   \"i64\") (V2DI  \"i64\")\n-                 (V2SF \"f32\") (V4SF  \"f32\")\n-                 (SF \"f32\") (DF \"f64\")])\n+\t\t\t     (V4HI \"i16\") (V8HI  \"i16\")\n+\t\t\t     (V2SI \"i32\") (V4SI  \"i32\")\n+\t\t\t     (DI   \"i64\") (V2DI  \"i64\")\n+\t\t\t     (V2SF \"f32\") (V4SF  \"f32\")\n+\t\t\t     (SF   \"f32\") (DF    \"f64\")\n+\t\t\t     (HF   \"f16\") (V4HF  \"f16\")\n+\t\t\t     (V8HF \"f16\")])\n \n ;; Same, but for operations which work on signed values.\n (define_mode_attr V_s_elem [(V8QI \"s8\")  (V16QI \"s8\")\n-                (V4HI \"s16\") (V8HI  \"s16\")\n-                            (V2SI \"s32\") (V4SI  \"s32\")\n-                            (DI   \"s64\") (V2DI  \"s64\")\n-                (V2SF \"f32\") (V4SF  \"f32\")])\n+\t\t\t    (V4HI \"s16\") (V8HI  \"s16\")\n+\t\t\t    (V2SI \"s32\") (V4SI  \"s32\")\n+\t\t\t    (DI   \"s64\") (V2DI  \"s64\")\n+\t\t\t    (V2SF \"f32\") (V4SF  \"f32\")\n+\t\t\t    (HF   \"f16\") (V4HF  \"f16\")\n+\t\t\t    (V8HF \"f16\")])\n \n ;; Same, but for operations which work on unsigned values.\n (define_mode_attr V_u_elem [(V8QI \"u8\")  (V16QI \"u8\")\n@@ -557,17 +575,22 @@\n                              (V2SF \"32\") (V4SF \"32\")])\n \n (define_mode_attr V_sz_elem [(V8QI \"8\")  (V16QI \"8\")\n-                 (V4HI \"16\") (V8HI  \"16\")\n-                             (V2SI \"32\") (V4SI  \"32\")\n-                             (DI   \"64\") (V2DI  \"64\")\n+\t\t\t     (V4HI \"16\") (V8HI  \"16\")\n+\t\t\t     (V2SI \"32\") (V4SI  \"32\")\n+\t\t\t     (DI   \"64\") (V2DI  \"64\")\n \t\t\t     (V4HF \"16\") (V8HF \"16\")\n-                 (V2SF \"32\") (V4SF  \"32\")])\n+\t\t\t     (V2SF \"32\") (V4SF  \"32\")])\n \n (define_mode_attr V_elem_ch [(V8QI \"b\")  (V16QI \"b\")\n-                             (V4HI \"h\") (V8HI  \"h\")\n-                             (V2SI \"s\") (V4SI  \"s\")\n-                             (DI   \"d\") (V2DI  \"d\")\n-                             (V2SF \"s\") (V4SF  \"s\")])\n+\t\t\t     (V4HI \"h\") (V8HI  \"h\")\n+\t\t\t     (V2SI \"s\") (V4SI  \"s\")\n+\t\t\t     (DI   \"d\") (V2DI  \"d\")\n+\t\t\t     (V2SF \"s\") (V4SF  \"s\")\n+\t\t\t     (V2SF \"s\") (V4SF  \"s\")])\n+\n+(define_mode_attr VH_elem_ch [(V4HI \"s\") (V8HI  \"s\")\n+\t\t\t      (V4HF \"s\") (V8HF  \"s\")\n+\t\t\t      (HF \"s\")])\n \n ;; Element sizes for duplicating ARM registers to all elements of a vector.\n (define_mode_attr VD_dup [(V8QI \"8\") (V4HI \"16\") (V2SI \"32\") (V2SF \"32\")])\n@@ -603,16 +626,17 @@\n ;; This mode attribute is used to obtain the correct register constraints.\n \n (define_mode_attr scalar_mul_constraint [(V4HI \"x\") (V2SI \"t\") (V2SF \"t\")\n-                                         (V8HI \"x\") (V4SI \"t\") (V4SF \"t\")])\n+\t\t\t\t\t (V8HI \"x\") (V4SI \"t\") (V4SF \"t\")\n+\t\t\t\t\t (V8HF \"x\") (V4HF \"x\")])\n \n ;; Predicates used for setting type for neon instructions\n \n (define_mode_attr Is_float_mode [(V8QI \"false\") (V16QI \"false\")\n-                 (V4HI \"false\") (V8HI \"false\")\n-                 (V2SI \"false\") (V4SI \"false\")\n-                 (V4HF \"true\") (V8HF \"true\")\n-                 (V2SF \"true\") (V4SF \"true\")\n-                 (DI \"false\") (V2DI \"false\")])\n+\t\t\t\t (V4HI \"false\") (V8HI \"false\")\n+\t\t\t\t (V2SI \"false\") (V4SI \"false\")\n+\t\t\t\t (V4HF \"true\") (V8HF \"true\")\n+\t\t\t\t (V2SF \"true\") (V4SF \"true\")\n+\t\t\t\t (DI \"false\") (V2DI \"false\")])\n \n (define_mode_attr Scalar_mul_8_16 [(V8QI \"true\") (V16QI \"true\")\n \t\t\t\t   (V4HI \"true\") (V8HI \"true\")\n@@ -621,10 +645,10 @@\n \t\t\t\t   (DI \"false\") (V2DI \"false\")])\n \n (define_mode_attr Is_d_reg [(V8QI \"true\") (V16QI \"false\")\n-                            (V4HI \"true\") (V8HI  \"false\")\n-                            (V2SI \"true\") (V4SI  \"false\")\n-                            (V2SF \"true\") (V4SF  \"false\")\n-                            (DI   \"true\") (V2DI  \"false\")\n+\t\t\t    (V4HI \"true\") (V8HI  \"false\")\n+\t\t\t    (V2SI \"true\") (V4SI  \"false\")\n+\t\t\t    (V2SF \"true\") (V4SF  \"false\")\n+\t\t\t    (DI   \"true\") (V2DI  \"false\")\n \t\t\t    (V4HF \"true\") (V8HF  \"false\")])\n \n (define_mode_attr V_mode_nunits [(V8QI \"8\") (V16QI \"16\")\n@@ -670,12 +694,14 @@\n \n ;; Mode attribute used to build the \"type\" attribute.\n (define_mode_attr q [(V8QI \"\") (V16QI \"_q\")\n-                     (V4HI \"\") (V8HI \"_q\")\n-                     (V2SI \"\") (V4SI \"_q\")\n+\t\t     (V4HI \"\") (V8HI \"_q\")\n+\t\t     (V2SI \"\") (V4SI \"_q\")\n \t\t     (V4HF \"\") (V8HF \"_q\")\n-                     (V2SF \"\") (V4SF \"_q\")\n-                     (DI \"\")   (V2DI \"_q\")\n-                     (DF \"\")   (V2DF \"_q\")])\n+\t\t     (V2SF \"\") (V4SF \"_q\")\n+\t\t     (V4HF \"\") (V8HF \"_q\")\n+\t\t     (DI \"\")   (V2DI \"_q\")\n+\t\t     (DF \"\")   (V2DF \"_q\")\n+\t\t     (HF \"\")])\n \n (define_mode_attr pf [(V8QI \"p\") (V16QI \"p\") (V2SF \"f\") (V4SF \"f\")])\n \n@@ -718,6 +744,10 @@\n ;; Conversions.\n (define_code_attr FCVTI32typename [(unsigned_float \"u32\") (float \"s32\")])\n \n+(define_code_attr float_sup [(unsigned_float \"u\") (float \"s\")])\n+\n+(define_code_attr float_SUP [(unsigned_float \"U\") (float \"S\")])\n+\n ;;----------------------------------------------------------------------------\n ;; Int attributes\n ;;----------------------------------------------------------------------------\n@@ -790,9 +820,10 @@\n    (UNSPEC_VRNDP \"vrintp\") (UNSPEC_VRNDX \"vrintx\")])\n \n (define_int_attr cmp_op_unsp [(UNSPEC_VCEQ \"eq\") (UNSPEC_VCGT \"gt\")\n-                              (UNSPEC_VCGE \"ge\") (UNSPEC_VCLE \"le\")\n-                              (UNSPEC_VCLT \"lt\") (UNSPEC_VCAGE \"ge\")\n-                              (UNSPEC_VCAGT \"gt\")])\n+\t\t\t      (UNSPEC_VCGE \"ge\") (UNSPEC_VCLE \"le\")\n+\t\t\t      (UNSPEC_VCLT \"lt\") (UNSPEC_VCAGE \"ge\")\n+\t\t\t      (UNSPEC_VCAGT \"gt\") (UNSPEC_VCALE \"le\")\n+\t\t\t      (UNSPEC_VCALT \"lt\")])\n \n (define_int_attr r [\n   (UNSPEC_VRHADD_S \"r\") (UNSPEC_VRHADD_U \"r\")\n@@ -908,3 +939,7 @@\n \n ;; Attributes for VQRDMLAH/VQRDMLSH\n (define_int_attr neon_rdma_as [(UNSPEC_VQRDMLAH \"a\") (UNSPEC_VQRDMLSH \"s\")])\n+\n+;; Attributes for VFMA_LANE/ VFMS_LANE\n+(define_int_attr neon_vfm_lane_as\n+ [(UNSPEC_VFMA_LANE \"a\") (UNSPEC_VFMS_LANE \"s\")])"}, {"sha": "05323334ffd81aeff33ee407b96c788d123b3fe3", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 452, "deletions": 7, "changes": 459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a9b91ba89e744f86bb6445797e8840585f3258/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a9b91ba89e744f86bb6445797e8840585f3258/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=55a9b91ba89e744f86bb6445797e8840585f3258", "patch": "@@ -505,6 +505,20 @@\n                     (const_string \"neon_add<q>\")))]\n )\n \n+(define_insn \"add<mode>3_fp16\"\n+  [(set\n+    (match_operand:VH 0 \"s_register_operand\" \"=w\")\n+    (plus:VH\n+     (match_operand:VH 1 \"s_register_operand\" \"w\")\n+     (match_operand:VH 2 \"s_register_operand\" \"w\")))]\n+ \"TARGET_NEON_FP16INST\"\n+ \"vadd.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+ [(set (attr \"type\")\n+   (if_then_else (match_test \"<Is_float_mode>\")\n+    (const_string \"neon_fp_addsub_s<q>\")\n+    (const_string \"neon_add<q>\")))]\n+)\n+\n (define_insn \"adddi3_neon\"\n   [(set (match_operand:DI 0 \"s_register_operand\" \"=w,?&r,?&r,?w,?&r,?&r,?&r\")\n         (plus:DI (match_operand:DI 1 \"s_register_operand\" \"%w,0,0,w,r,0,r\")\n@@ -543,6 +557,17 @@\n                     (const_string \"neon_sub<q>\")))]\n )\n \n+(define_insn \"sub<mode>3_fp16\"\n+ [(set\n+   (match_operand:VH 0 \"s_register_operand\" \"=w\")\n+   (minus:VH\n+    (match_operand:VH 1 \"s_register_operand\" \"w\")\n+    (match_operand:VH 2 \"s_register_operand\" \"w\")))]\n+ \"TARGET_NEON_FP16INST\"\n+ \"vsub.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+ [(set_attr \"type\" \"neon_sub<q>\")]\n+)\n+\n (define_insn \"subdi3_neon\"\n   [(set (match_operand:DI 0 \"s_register_operand\" \"=w,?&r,?&r,?&r,?w\")\n         (minus:DI (match_operand:DI 1 \"s_register_operand\" \"w,0,r,0,w\")\n@@ -591,6 +616,16 @@\n \t\t    (const_string \"neon_mla_<V_elem_ch><q>\")))]\n )\n \n+(define_insn \"mul<mode>3add<mode>_neon\"\n+  [(set (match_operand:VH 0 \"s_register_operand\" \"=w\")\n+\t(plus:VH (mult:VH (match_operand:VH 2 \"s_register_operand\" \"w\")\n+\t\t\t  (match_operand:VH 3 \"s_register_operand\" \"w\"))\n+\t\t  (match_operand:VH 1 \"s_register_operand\" \"0\")))]\n+  \"TARGET_NEON_FP16INST && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n+  \"vmla.f16\\t%<V_reg>0, %<V_reg>2, %<V_reg>3\"\n+  [(set_attr \"type\" \"neon_fp_mla_s<q>\")]\n+)\n+\n (define_insn \"mul<mode>3neg<mode>add<mode>_neon\"\n   [(set (match_operand:VDQW 0 \"s_register_operand\" \"=w\")\n         (minus:VDQW (match_operand:VDQW 1 \"s_register_operand\" \"0\")\n@@ -629,6 +664,19 @@\n   [(set_attr \"type\" \"neon_fp_mla_s<q>\")]\n )\n \n+;; There is limited support for unsafe-math optimizations using the NEON FP16\n+;; arithmetic instructions, so only the intrinsic is currently supported.\n+(define_insn \"fma<VH:mode>4_intrinsic\"\n+ [(set (match_operand:VH 0 \"register_operand\" \"=w\")\n+   (fma:VH\n+    (match_operand:VH 1 \"register_operand\" \"w\")\n+    (match_operand:VH 2 \"register_operand\" \"w\")\n+    (match_operand:VH 3 \"register_operand\" \"0\")))]\n+ \"TARGET_NEON_FP16INST\"\n+ \"vfma.<V_if_elem>\\\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+ [(set_attr \"type\" \"neon_fp_mla_s<q>\")]\n+)\n+\n (define_insn \"*fmsub<VCVTF:mode>4\"\n   [(set (match_operand:VCVTF 0 \"register_operand\" \"=w\")\n         (fma:VCVTF (neg:VCVTF (match_operand:VCVTF 1 \"register_operand\" \"w\"))\n@@ -640,13 +688,25 @@\n )\n \n (define_insn \"fmsub<VCVTF:mode>4_intrinsic\"\n-  [(set (match_operand:VCVTF 0 \"register_operand\" \"=w\")\n-        (fma:VCVTF (neg:VCVTF (match_operand:VCVTF 1 \"register_operand\" \"w\"))\n-\t\t   (match_operand:VCVTF 2 \"register_operand\" \"w\")\n-\t\t   (match_operand:VCVTF 3 \"register_operand\" \"0\")))]\n-  \"TARGET_NEON && TARGET_FMA\"\n-  \"vfms%?.<V_if_elem>\\\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n-  [(set_attr \"type\" \"neon_fp_mla_s<q>\")]\n+ [(set (match_operand:VCVTF 0 \"register_operand\" \"=w\")\n+   (fma:VCVTF\n+    (neg:VCVTF (match_operand:VCVTF 1 \"register_operand\" \"w\"))\n+    (match_operand:VCVTF 2 \"register_operand\" \"w\")\n+    (match_operand:VCVTF 3 \"register_operand\" \"0\")))]\n+ \"TARGET_NEON && TARGET_FMA\"\n+ \"vfms%?.<V_if_elem>\\\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+ [(set_attr \"type\" \"neon_fp_mla_s<q>\")]\n+)\n+\n+(define_insn \"fmsub<VH:mode>4_intrinsic\"\n+ [(set (match_operand:VH 0 \"register_operand\" \"=w\")\n+   (fma:VH\n+    (neg:VH (match_operand:VH 1 \"register_operand\" \"w\"))\n+    (match_operand:VH 2 \"register_operand\" \"w\")\n+    (match_operand:VH 3 \"register_operand\" \"0\")))]\n+ \"TARGET_NEON_FP16INST\"\n+ \"vfms.<V_if_elem>\\\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+ [(set_attr \"type\" \"neon_fp_mla_s<q>\")]\n )\n \n (define_insn \"neon_vrint<NEON_VRINT:nvrint_variant><VCVTF:mode>\"\n@@ -860,6 +920,44 @@\n   \"\"\n )\n \n+(define_insn \"<absneg_str><mode>2\"\n+  [(set (match_operand:VH 0 \"s_register_operand\" \"=w\")\n+    (ABSNEG:VH (match_operand:VH 1 \"s_register_operand\" \"w\")))]\n+ \"TARGET_NEON_FP16INST\"\n+ \"v<absneg_str>.<V_s_elem>\\t%<V_reg>0, %<V_reg>1\"\n+ [(set_attr \"type\" \"neon_abs<q>\")]\n+)\n+\n+(define_expand \"neon_v<absneg_str><mode>\"\n+ [(set\n+   (match_operand:VH 0 \"s_register_operand\")\n+   (ABSNEG:VH (match_operand:VH 1 \"s_register_operand\")))]\n+ \"TARGET_NEON_FP16INST\"\n+{\n+  emit_insn (gen_<absneg_str><mode>2 (operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_insn \"neon_v<fp16_rnd_str><mode>\"\n+  [(set (match_operand:VH 0 \"s_register_operand\" \"=w\")\n+    (unspec:VH\n+     [(match_operand:VH 1 \"s_register_operand\" \"w\")]\n+     FP16_RND))]\n+ \"TARGET_NEON_FP16INST\"\n+ \"<fp16_rnd_insn>.<V_s_elem>\\t%<V_reg>0, %<V_reg>1\"\n+ [(set_attr \"type\" \"neon_fp_round_s<q>\")]\n+)\n+\n+(define_insn \"neon_vrsqrte<mode>\"\n+  [(set (match_operand:VH 0 \"s_register_operand\" \"=w\")\n+    (unspec:VH\n+     [(match_operand:VH 1 \"s_register_operand\" \"w\")]\n+     UNSPEC_VRSQRTE))]\n+  \"TARGET_NEON_FP16INST\"\n+  \"vrsqrte.f16\\t%<V_reg>0, %<V_reg>1\"\n+ [(set_attr \"type\" \"neon_fp_rsqrte_s<q>\")]\n+)\n+\n (define_insn \"*umin<mode>3_neon\"\n   [(set (match_operand:VDQIW 0 \"s_register_operand\" \"=w\")\n \t(umin:VDQIW (match_operand:VDQIW 1 \"s_register_operand\" \"w\")\n@@ -1601,6 +1699,17 @@\n                     (const_string \"neon_reduc_add<q>\")))]\n )\n \n+(define_insn \"neon_vpaddv4hf\"\n+ [(set\n+   (match_operand:V4HF 0 \"s_register_operand\" \"=w\")\n+   (unspec:V4HF [(match_operand:V4HF 1 \"s_register_operand\" \"w\")\n+\t\t (match_operand:V4HF 2 \"s_register_operand\" \"w\")]\n+    UNSPEC_VPADD))]\n+ \"TARGET_NEON_FP16INST\"\n+ \"vpadd.f16\\t%P0, %P1, %P2\"\n+ [(set_attr \"type\" \"neon_reduc_add\")]\n+)\n+\n (define_insn \"neon_vpsmin<mode>\"\n   [(set (match_operand:VD 0 \"s_register_operand\" \"=w\")\n \t(unspec:VD [(match_operand:VD 1 \"s_register_operand\" \"w\")\n@@ -1949,6 +2058,26 @@\n   DONE;\n })\n \n+(define_expand \"neon_vadd<mode>\"\n+  [(match_operand:VH 0 \"s_register_operand\")\n+   (match_operand:VH 1 \"s_register_operand\")\n+   (match_operand:VH 2 \"s_register_operand\")]\n+  \"TARGET_NEON_FP16INST\"\n+{\n+  emit_insn (gen_add<mode>3_fp16 (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"neon_vsub<mode>\"\n+  [(match_operand:VH 0 \"s_register_operand\")\n+   (match_operand:VH 1 \"s_register_operand\")\n+   (match_operand:VH 2 \"s_register_operand\")]\n+  \"TARGET_NEON_FP16INST\"\n+{\n+  emit_insn (gen_sub<mode>3_fp16 (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n ; Note that NEON operations don't support the full IEEE 754 standard: in\n ; particular, denormal values are flushed to zero.  This means that GCC cannot\n ; use those instructions for autovectorization, etc. unless\n@@ -2040,6 +2169,17 @@\n                     (const_string \"neon_mul_<V_elem_ch><q>\")))]\n )\n \n+(define_insn \"neon_vmulf<mode>\"\n+ [(set\n+   (match_operand:VH 0 \"s_register_operand\" \"=w\")\n+   (mult:VH\n+    (match_operand:VH 1 \"s_register_operand\" \"w\")\n+    (match_operand:VH 2 \"s_register_operand\" \"w\")))]\n+  \"TARGET_NEON_FP16INST\"\n+  \"vmul.f16\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+ [(set_attr \"type\" \"neon_mul_<VH_elem_ch><q>\")]\n+)\n+\n (define_expand \"neon_vmla<mode>\"\n   [(match_operand:VDQW 0 \"s_register_operand\" \"=w\")\n    (match_operand:VDQW 1 \"s_register_operand\" \"0\")\n@@ -2068,6 +2208,18 @@\n   DONE;\n })\n \n+(define_expand \"neon_vfma<VH:mode>\"\n+  [(match_operand:VH 0 \"s_register_operand\")\n+   (match_operand:VH 1 \"s_register_operand\")\n+   (match_operand:VH 2 \"s_register_operand\")\n+   (match_operand:VH 3 \"s_register_operand\")]\n+  \"TARGET_NEON_FP16INST\"\n+{\n+  emit_insn (gen_fma<mode>4_intrinsic (operands[0], operands[2], operands[3],\n+\t\t\t\t       operands[1]));\n+  DONE;\n+})\n+\n (define_expand \"neon_vfms<VCVTF:mode>\"\n   [(match_operand:VCVTF 0 \"s_register_operand\")\n    (match_operand:VCVTF 1 \"s_register_operand\")\n@@ -2080,6 +2232,18 @@\n   DONE;\n })\n \n+(define_expand \"neon_vfms<VH:mode>\"\n+  [(match_operand:VH 0 \"s_register_operand\")\n+   (match_operand:VH 1 \"s_register_operand\")\n+   (match_operand:VH 2 \"s_register_operand\")\n+   (match_operand:VH 3 \"s_register_operand\")]\n+  \"TARGET_NEON_FP16INST\"\n+{\n+  emit_insn (gen_fmsub<mode>4_intrinsic (operands[0], operands[2], operands[3],\n+\t\t\t\t\t operands[1]));\n+  DONE;\n+})\n+\n ; Used for intrinsics when flag_unsafe_math_optimizations is false.\n \n (define_insn \"neon_vmla<mode>_unspec\"\n@@ -2380,6 +2544,72 @@\n   [(set_attr \"type\" \"neon_fp_compare_s<q>\")]\n )\n \n+(define_expand \"neon_vc<cmp_op><mode>\"\n+ [(match_operand:<V_cmp_result> 0 \"s_register_operand\")\n+  (neg:<V_cmp_result>\n+   (COMPARISONS:VH\n+    (match_operand:VH 1 \"s_register_operand\")\n+    (match_operand:VH 2 \"reg_or_zero_operand\")))]\n+ \"TARGET_NEON_FP16INST\"\n+{\n+  /* For FP comparisons use UNSPECS unless -funsafe-math-optimizations\n+     are enabled.  */\n+  if (GET_MODE_CLASS (<MODE>mode) == MODE_VECTOR_FLOAT\n+      && !flag_unsafe_math_optimizations)\n+    emit_insn\n+      (gen_neon_vc<cmp_op><mode>_fp16insn_unspec\n+       (operands[0], operands[1], operands[2]));\n+  else\n+    emit_insn\n+      (gen_neon_vc<cmp_op><mode>_fp16insn\n+       (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_insn \"neon_vc<cmp_op><mode>_fp16insn\"\n+ [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w,w\")\n+   (neg:<V_cmp_result>\n+    (COMPARISONS:<V_cmp_result>\n+     (match_operand:VH 1 \"s_register_operand\" \"w,w\")\n+     (match_operand:VH 2 \"reg_or_zero_operand\" \"w,Dz\"))))]\n+ \"TARGET_NEON_FP16INST\n+  && !(GET_MODE_CLASS (<MODE>mode) == MODE_VECTOR_FLOAT\n+  && !flag_unsafe_math_optimizations)\"\n+{\n+  char pattern[100];\n+  sprintf (pattern, \"vc<cmp_op>.%s%%#<V_sz_elem>\\t%%<V_reg>0,\"\n+\t   \" %%<V_reg>1, %s\",\n+\t   GET_MODE_CLASS (<MODE>mode) == MODE_VECTOR_FLOAT\n+\t   ? \"f\" : \"<cmp_type>\",\n+\t   which_alternative == 0\n+\t   ? \"%<V_reg>2\" : \"#0\");\n+  output_asm_insn (pattern, operands);\n+  return \"\";\n+}\n+ [(set (attr \"type\")\n+   (if_then_else (match_operand 2 \"zero_operand\")\n+    (const_string \"neon_compare_zero<q>\")\n+    (const_string \"neon_compare<q>\")))])\n+\n+(define_insn \"neon_vc<cmp_op_unsp><mode>_fp16insn_unspec\"\n+ [(set\n+   (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w,w\")\n+   (unspec:<V_cmp_result>\n+    [(match_operand:VH 1 \"s_register_operand\" \"w,w\")\n+     (match_operand:VH 2 \"reg_or_zero_operand\" \"w,Dz\")]\n+    NEON_VCMP))]\n+ \"TARGET_NEON_FP16INST\"\n+{\n+  char pattern[100];\n+  sprintf (pattern, \"vc<cmp_op_unsp>.f%%#<V_sz_elem>\\t%%<V_reg>0,\"\n+\t   \" %%<V_reg>1, %s\",\n+\t   which_alternative == 0\n+\t   ? \"%<V_reg>2\" : \"#0\");\n+  output_asm_insn (pattern, operands);\n+  return \"\";\n+}\n+ [(set_attr \"type\" \"neon_fp_compare_s<q>\")])\n+\n (define_insn \"neon_vc<cmp_op>u<mode>\"\n   [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w\")\n         (neg:<V_cmp_result>\n@@ -2431,6 +2661,60 @@\n   [(set_attr \"type\" \"neon_fp_compare_s<q>\")]\n )\n \n+(define_expand \"neon_vca<cmp_op><mode>\"\n+  [(set\n+    (match_operand:<V_cmp_result> 0 \"s_register_operand\")\n+    (neg:<V_cmp_result>\n+     (GLTE:<V_cmp_result>\n+      (abs:VH (match_operand:VH 1 \"s_register_operand\"))\n+      (abs:VH (match_operand:VH 2 \"s_register_operand\")))))]\n+ \"TARGET_NEON_FP16INST\"\n+{\n+  if (flag_unsafe_math_optimizations)\n+    emit_insn (gen_neon_vca<cmp_op><mode>_fp16insn\n+\t       (operands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_neon_vca<cmp_op><mode>_fp16insn_unspec\n+\t       (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_insn \"neon_vca<cmp_op><mode>_fp16insn\"\n+  [(set\n+    (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w\")\n+    (neg:<V_cmp_result>\n+     (GLTE:<V_cmp_result>\n+      (abs:VH (match_operand:VH 1 \"s_register_operand\" \"w\"))\n+      (abs:VH (match_operand:VH 2 \"s_register_operand\" \"w\")))))]\n+ \"TARGET_NEON_FP16INST && flag_unsafe_math_optimizations\"\n+ \"vac<cmp_op>.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+ [(set_attr \"type\" \"neon_fp_compare_s<q>\")]\n+)\n+\n+(define_insn \"neon_vca<cmp_op_unsp><mode>_fp16insn_unspec\"\n+ [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w\")\n+   (unspec:<V_cmp_result>\n+    [(match_operand:VH 1 \"s_register_operand\" \"w\")\n+     (match_operand:VH 2 \"s_register_operand\" \"w\")]\n+    NEON_VAGLTE))]\n+ \"TARGET_NEON\"\n+ \"vac<cmp_op_unsp>.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+ [(set_attr \"type\" \"neon_fp_compare_s<q>\")]\n+)\n+\n+(define_expand \"neon_vc<cmp_op>z<mode>\"\n+ [(set\n+   (match_operand:<V_cmp_result> 0 \"s_register_operand\")\n+   (COMPARISONS:<V_cmp_result>\n+    (match_operand:VH 1 \"s_register_operand\")\n+    (const_int 0)))]\n+ \"TARGET_NEON_FP16INST\"\n+ {\n+  emit_insn (gen_neon_vc<cmp_op><mode> (operands[0], operands[1],\n+\t\t\t\t\tCONST0_RTX (<MODE>mode)));\n+  DONE;\n+})\n+\n (define_insn \"neon_vtst<mode>\"\n   [(set (match_operand:VDQIW 0 \"s_register_operand\" \"=w\")\n         (unspec:VDQIW [(match_operand:VDQIW 1 \"s_register_operand\" \"w\")\n@@ -2451,6 +2735,16 @@\n   [(set_attr \"type\" \"neon_abd<q>\")]\n )\n \n+(define_insn \"neon_vabd<mode>\"\n+  [(set (match_operand:VH 0 \"s_register_operand\" \"=w\")\n+    (unspec:VH [(match_operand:VH 1 \"s_register_operand\" \"w\")\n+\t\t(match_operand:VH 2 \"s_register_operand\" \"w\")]\n+     UNSPEC_VABD_F))]\n+ \"TARGET_NEON_FP16INST\"\n+ \"vabd.<V_s_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+  [(set_attr \"type\" \"neon_abd<q>\")]\n+)\n+\n (define_insn \"neon_vabdf<mode>\"\n   [(set (match_operand:VCVTF 0 \"s_register_operand\" \"=w\")\n         (unspec:VCVTF [(match_operand:VCVTF 1 \"s_register_operand\" \"w\")\n@@ -2513,6 +2807,40 @@\n   [(set_attr \"type\" \"neon_fp_minmax_s<q>\")]\n )\n \n+(define_insn \"neon_v<maxmin>f<mode>\"\n+ [(set (match_operand:VH 0 \"s_register_operand\" \"=w\")\n+   (unspec:VH\n+    [(match_operand:VH 1 \"s_register_operand\" \"w\")\n+     (match_operand:VH 2 \"s_register_operand\" \"w\")]\n+    VMAXMINF))]\n+ \"TARGET_NEON_FP16INST\"\n+ \"v<maxmin>.<V_s_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+ [(set_attr \"type\" \"neon_fp_minmax_s<q>\")]\n+)\n+\n+(define_insn \"neon_vp<maxmin>fv4hf\"\n+ [(set (match_operand:V4HF 0 \"s_register_operand\" \"=w\")\n+   (unspec:V4HF\n+    [(match_operand:V4HF 1 \"s_register_operand\" \"w\")\n+     (match_operand:V4HF 2 \"s_register_operand\" \"w\")]\n+    VPMAXMINF))]\n+ \"TARGET_NEON_FP16INST\"\n+ \"vp<maxmin>.f16\\t%P0, %P1, %P2\"\n+  [(set_attr \"type\" \"neon_reduc_minmax\")]\n+)\n+\n+(define_insn \"neon_<fmaxmin_op><mode>\"\n+ [(set\n+   (match_operand:VH 0 \"s_register_operand\" \"=w\")\n+   (unspec:VH\n+    [(match_operand:VH 1 \"s_register_operand\" \"w\")\n+     (match_operand:VH 2 \"s_register_operand\" \"w\")]\n+    VMAXMINFNM))]\n+ \"TARGET_NEON_FP16INST\"\n+ \"<fmaxmin_op>.<V_s_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+ [(set_attr \"type\" \"neon_fp_minmax_s<q>\")]\n+)\n+\n ;; Vector forms for the IEEE-754 fmax()/fmin() functions\n (define_insn \"<fmaxmin><mode>3\"\n   [(set (match_operand:VCVTF 0 \"s_register_operand\" \"=w\")\n@@ -2584,6 +2912,17 @@\n   [(set_attr \"type\" \"neon_fp_recps_s<q>\")]\n )\n \n+(define_insn \"neon_vrecps<mode>\"\n+  [(set\n+    (match_operand:VH 0 \"s_register_operand\" \"=w\")\n+    (unspec:VH [(match_operand:VH 1 \"s_register_operand\" \"w\")\n+\t\t(match_operand:VH 2 \"s_register_operand\" \"w\")]\n+     UNSPEC_VRECPS))]\n+  \"TARGET_NEON_FP16INST\"\n+  \"vrecps.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+  [(set_attr \"type\" \"neon_fp_recps_s<q>\")]\n+)\n+\n (define_insn \"neon_vrsqrts<mode>\"\n   [(set (match_operand:VCVTF 0 \"s_register_operand\" \"=w\")\n         (unspec:VCVTF [(match_operand:VCVTF 1 \"s_register_operand\" \"w\")\n@@ -2594,6 +2933,17 @@\n   [(set_attr \"type\" \"neon_fp_rsqrts_s<q>\")]\n )\n \n+(define_insn \"neon_vrsqrts<mode>\"\n+  [(set\n+    (match_operand:VH 0 \"s_register_operand\" \"=w\")\n+    (unspec:VH [(match_operand:VH 1 \"s_register_operand\" \"w\")\n+\t\t (match_operand:VH 2 \"s_register_operand\" \"w\")]\n+     UNSPEC_VRSQRTS))]\n+ \"TARGET_NEON_FP16INST\"\n+ \"vrsqrts.<V_if_elem>\\t%<V_reg>0, %<V_reg>1, %<V_reg>2\"\n+ [(set_attr \"type\" \"neon_fp_rsqrts_s<q>\")]\n+)\n+\n (define_expand \"neon_vabs<mode>\"\n   [(match_operand:VDQW 0 \"s_register_operand\" \"\")\n    (match_operand:VDQW 1 \"s_register_operand\" \"\")]\n@@ -2708,6 +3058,15 @@\n   DONE;\n })\n \n+(define_insn \"neon_vrecpe<mode>\"\n+  [(set (match_operand:VH 0 \"s_register_operand\" \"=w\")\n+\t(unspec:VH [(match_operand:VH 1 \"s_register_operand\" \"w\")]\n+\t\t   UNSPEC_VRECPE))]\n+  \"TARGET_NEON_FP16INST\"\n+  \"vrecpe.f16\\t%<V_reg>0, %<V_reg>1\"\n+  [(set_attr \"type\" \"neon_fp_recpe_s<q>\")]\n+)\n+\n (define_insn \"neon_vrecpe<mode>\"\n   [(set (match_operand:V32 0 \"s_register_operand\" \"=w\")\n \t(unspec:V32 [(match_operand:V32 1 \"s_register_operand\" \"w\")]\n@@ -3251,6 +3610,28 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_fp_cvt_narrow_s_q\")]\n )\n \n+(define_insn \"neon_vcvt<sup><mode>\"\n+ [(set\n+   (match_operand:<VH_CVTTO> 0 \"s_register_operand\" \"=w\")\n+   (unspec:<VH_CVTTO>\n+    [(match_operand:VCVTHI 1 \"s_register_operand\" \"w\")]\n+    VCVT_US))]\n+ \"TARGET_NEON_FP16INST\"\n+ \"vcvt.f16.<sup>%#16\\t%<V_reg>0, %<V_reg>1\"\n+  [(set_attr \"type\" \"neon_int_to_fp_<VH_elem_ch><q>\")]\n+)\n+\n+(define_insn \"neon_vcvt<sup><mode>\"\n+ [(set\n+   (match_operand:<VH_CVTTO> 0 \"s_register_operand\" \"=w\")\n+   (unspec:<VH_CVTTO>\n+    [(match_operand:VH 1 \"s_register_operand\" \"w\")]\n+    VCVT_US))]\n+ \"TARGET_NEON_FP16INST\"\n+ \"vcvt.<sup>%#16.f16\\t%<V_reg>0, %<V_reg>1\"\n+  [(set_attr \"type\" \"neon_fp_to_int_<VH_elem_ch><q>\")]\n+)\n+\n (define_insn \"neon_vcvt<sup>_n<mode>\"\n   [(set (match_operand:<V_CVTTO> 0 \"s_register_operand\" \"=w\")\n \t(unspec:<V_CVTTO> [(match_operand:VCVTF 1 \"s_register_operand\" \"w\")\n@@ -3264,6 +3645,20 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_fp_to_int_<V_elem_ch><q>\")]\n )\n \n+(define_insn \"neon_vcvt<sup>_n<mode>\"\n+ [(set (match_operand:<VH_CVTTO> 0 \"s_register_operand\" \"=w\")\n+   (unspec:<VH_CVTTO>\n+    [(match_operand:VH 1 \"s_register_operand\" \"w\")\n+     (match_operand:SI 2 \"immediate_operand\" \"i\")]\n+    VCVT_US_N))]\n+  \"TARGET_NEON_FP16INST\"\n+{\n+  neon_const_bounds (operands[2], 0, 17);\n+  return \"vcvt.<sup>%#16.f16\\t%<V_reg>0, %<V_reg>1, %2\";\n+}\n+ [(set_attr \"type\" \"neon_fp_to_int_<VH_elem_ch><q>\")]\n+)\n+\n (define_insn \"neon_vcvt<sup>_n<mode>\"\n   [(set (match_operand:<V_CVTTO> 0 \"s_register_operand\" \"=w\")\n \t(unspec:<V_CVTTO> [(match_operand:VCVTI 1 \"s_register_operand\" \"w\")\n@@ -3277,6 +3672,31 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_int_to_fp_<V_elem_ch><q>\")]\n )\n \n+(define_insn \"neon_vcvt<sup>_n<mode>\"\n+ [(set (match_operand:<VH_CVTTO> 0 \"s_register_operand\" \"=w\")\n+   (unspec:<VH_CVTTO>\n+    [(match_operand:VCVTHI 1 \"s_register_operand\" \"w\")\n+     (match_operand:SI 2 \"immediate_operand\" \"i\")]\n+    VCVT_US_N))]\n+ \"TARGET_NEON_FP16INST\"\n+{\n+  neon_const_bounds (operands[2], 0, 17);\n+  return \"vcvt.f16.<sup>%#16\\t%<V_reg>0, %<V_reg>1, %2\";\n+}\n+ [(set_attr \"type\" \"neon_int_to_fp_<VH_elem_ch><q>\")]\n+)\n+\n+(define_insn \"neon_vcvt<vcvth_op><sup><mode>\"\n+ [(set\n+   (match_operand:<VH_CVTTO> 0 \"s_register_operand\" \"=w\")\n+   (unspec:<VH_CVTTO>\n+    [(match_operand:VH 1 \"s_register_operand\" \"w\")]\n+    VCVT_HF_US))]\n+ \"TARGET_NEON_FP16INST\"\n+ \"vcvt<vcvth_op>.<sup>%#16.f16\\t%<V_reg>0, %<V_reg>1\"\n+  [(set_attr \"type\" \"neon_fp_to_int_<VH_elem_ch><q>\")]\n+)\n+\n (define_insn \"neon_vmovn<mode>\"\n   [(set (match_operand:<V_narrow> 0 \"s_register_operand\" \"=w\")\n \t(unspec:<V_narrow> [(match_operand:VN 1 \"s_register_operand\" \"w\")]\n@@ -3347,6 +3767,18 @@ if (BYTES_BIG_ENDIAN)\n                    (const_string \"neon_mul_<V_elem_ch>_scalar<q>\")))]\n )\n \n+(define_insn \"neon_vmul_lane<mode>\"\n+  [(set (match_operand:VH 0 \"s_register_operand\" \"=w\")\n+\t(unspec:VH [(match_operand:VH 1 \"s_register_operand\" \"w\")\n+\t\t    (match_operand:V4HF 2 \"s_register_operand\"\n+\t\t     \"<scalar_mul_constraint>\")\n+\t\t     (match_operand:SI 3 \"immediate_operand\" \"i\")]\n+\t\t     UNSPEC_VMUL_LANE))]\n+  \"TARGET_NEON_FP16INST\"\n+  \"vmul.f16\\t%<V_reg>0, %<V_reg>1, %P2[%c3]\"\n+  [(set_attr \"type\" \"neon_fp_mul_s_scalar<q>\")]\n+)\n+\n (define_insn \"neon_vmull<sup>_lane<mode>\"\n   [(set (match_operand:<V_widen> 0 \"s_register_operand\" \"=w\")\n \t(unspec:<V_widen> [(match_operand:VMDI 1 \"s_register_operand\" \"w\")\n@@ -3601,6 +4033,19 @@ if (BYTES_BIG_ENDIAN)\n   DONE;\n })\n \n+(define_expand \"neon_vmul_n<mode>\"\n+  [(match_operand:VH 0 \"s_register_operand\")\n+   (match_operand:VH 1 \"s_register_operand\")\n+   (match_operand:<V_elem> 2 \"s_register_operand\")]\n+  \"TARGET_NEON_FP16INST\"\n+{\n+  rtx tmp = gen_reg_rtx (V4HFmode);\n+  emit_insn (gen_neon_vset_lanev4hf (tmp, operands[2], tmp, const0_rtx));\n+  emit_insn (gen_neon_vmul_lane<mode> (operands[0], operands[1], tmp,\n+\t\t\t\t       const0_rtx));\n+  DONE;\n+})\n+\n (define_expand \"neon_vmulls_n<mode>\"\n   [(match_operand:<V_widen> 0 \"s_register_operand\" \"\")\n    (match_operand:VMDI 1 \"s_register_operand\" \"\")"}, {"sha": "bee8795f007accc623c82b73c41a8619ebc29209", "filename": "gcc/config/arm/unspecs.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a9b91ba89e744f86bb6445797e8840585f3258/gcc%2Fconfig%2Farm%2Funspecs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a9b91ba89e744f86bb6445797e8840585f3258/gcc%2Fconfig%2Farm%2Funspecs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funspecs.md?ref=55a9b91ba89e744f86bb6445797e8840585f3258", "patch": "@@ -191,6 +191,8 @@\n   UNSPEC_VBSL\n   UNSPEC_VCAGE\n   UNSPEC_VCAGT\n+  UNSPEC_VCALE\n+  UNSPEC_VCALT\n   UNSPEC_VCEQ\n   UNSPEC_VCGE\n   UNSPEC_VCGEU\n@@ -258,6 +260,8 @@\n   UNSPEC_VMLSL_S_LANE\n   UNSPEC_VMLSL_U_LANE\n   UNSPEC_VMLSL_LANE\n+  UNSPEC_VFMA_LANE\n+  UNSPEC_VFMS_LANE\n   UNSPEC_VMOVL_S\n   UNSPEC_VMOVL_U\n   UNSPEC_VMOVN\n@@ -387,4 +391,3 @@\n   UNSPEC_VRNDP\n   UNSPEC_VRNDX\n ])\n-"}, {"sha": "51b055321566c5b503678b6f2a61a28457c6375d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a9b91ba89e744f86bb6445797e8840585f3258/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a9b91ba89e744f86bb6445797e8840585f3258/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=55a9b91ba89e744f86bb6445797e8840585f3258", "patch": "@@ -1,3 +1,8 @@\n+2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n+\n+\t* gcc.target/arm/armv8_2-fp16-arith-1.c: Use arm_v8_2a_fp16_neon\n+\toptions.  Add tests for float16x4_t and float16x8_t.\n+\n 2016-09-23  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n \n \t* gcc.target/s390/risbg-ll-1.c: Ported risbg tests from llvm."}, {"sha": "b88f43f79fa039ae1011dae65e66732c00e5ec6e", "filename": "gcc/testsuite/gcc.target/arm/armv8_2-fp16-arith-1.c", "status": "modified", "additions": 45, "deletions": 8, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55a9b91ba89e744f86bb6445797e8840585f3258/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_2-fp16-arith-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55a9b91ba89e744f86bb6445797e8840585f3258/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_2-fp16-arith-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_2-fp16-arith-1.c?ref=55a9b91ba89e744f86bb6445797e8840585f3258", "patch": "@@ -1,14 +1,17 @@\n /* { dg-do compile }  */\n-/* { dg-require-effective-target arm_v8_2a_fp16_scalar_ok }  */\n+/* { dg-require-effective-target arm_v8_2a_fp16_neon_ok }  */\n /* { dg-options \"-O2 -ffast-math\" }  */\n-/* { dg-add-options arm_v8_2a_fp16_scalar }  */\n+/* { dg-add-options arm_v8_2a_fp16_neon }  */\n \n /* Test instructions generated for half-precision arithmetic.  */\n \n typedef __fp16 float16_t;\n typedef __simd64_float16_t float16x4_t;\n typedef __simd128_float16_t float16x8_t;\n \n+typedef short int16x4_t __attribute__ ((vector_size (8)));\n+typedef short int int16x8_t  __attribute__ ((vector_size (16)));\n+\n float16_t\n fp16_abs (float16_t a)\n {\n@@ -50,15 +53,49 @@ TEST_CMP (greaterthan, >, int, float16_t)\n TEST_CMP (lessthanequal, <=, int, float16_t)\n TEST_CMP (greaterthanqual, >=, int, float16_t)\n \n+/* Vectors of size 4.  */\n+\n+TEST_UNOP (neg, -, float16x4_t)\n+\n+TEST_BINOP (add, +, float16x4_t)\n+TEST_BINOP (sub, -, float16x4_t)\n+TEST_BINOP (mult, *, float16x4_t)\n+TEST_BINOP (div, /, float16x4_t)\n+\n+TEST_CMP (equal, ==, int16x4_t, float16x4_t)\n+TEST_CMP (unequal, !=, int16x4_t, float16x4_t)\n+TEST_CMP (lessthan, <, int16x4_t, float16x4_t)\n+TEST_CMP (greaterthan, >, int16x4_t, float16x4_t)\n+TEST_CMP (lessthanequal, <=, int16x4_t, float16x4_t)\n+TEST_CMP (greaterthanqual, >=, int16x4_t, float16x4_t)\n+\n+/* Vectors of size 8.  */\n+\n+TEST_UNOP (neg, -, float16x8_t)\n+\n+TEST_BINOP (add, +, float16x8_t)\n+TEST_BINOP (sub, -, float16x8_t)\n+TEST_BINOP (mult, *, float16x8_t)\n+TEST_BINOP (div, /, float16x8_t)\n+\n+TEST_CMP (equal, ==, int16x8_t, float16x8_t)\n+TEST_CMP (unequal, !=, int16x8_t, float16x8_t)\n+TEST_CMP (lessthan, <, int16x8_t, float16x8_t)\n+TEST_CMP (greaterthan, >, int16x8_t, float16x8_t)\n+TEST_CMP (lessthanequal, <=, int16x8_t, float16x8_t)\n+TEST_CMP (greaterthanqual, >=, int16x8_t, float16x8_t)\n+\n /* { dg-final { scan-assembler-times {vneg\\.f16\\ts[0-9]+, s[0-9]+} 1 } }  */\n+/* { dg-final { scan-assembler-times {vneg\\.f16\\td[0-9]+, d[0-9]+} 1 } }  */\n+/* { dg-final { scan-assembler-times {vneg\\.f16\\tq[0-9]+, q[0-9]+} 1 } }  */\n /* { dg-final { scan-assembler-times {vabs\\.f16\\ts[0-9]+, s[0-9]+} 2 } }  */\n \n-/* { dg-final { scan-assembler-times {vadd\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 1 } }  */\n-/* { dg-final { scan-assembler-times {vsub\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 1 } }  */\n-/* { dg-final { scan-assembler-times {vmul\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 1 } }  */\n-/* { dg-final { scan-assembler-times {vdiv\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 1 } }  */\n-/* { dg-final { scan-assembler-times {vcmp\\.f32\\ts[0-9]+, s[0-9]+} 2 } }  */\n-/* { dg-final { scan-assembler-times {vcmpe\\.f32\\ts[0-9]+, s[0-9]+} 4 } }  */\n+/* { dg-final { scan-assembler-times {vadd\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 13 } }  */\n+/* { dg-final { scan-assembler-times {vsub\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 13 } }  */\n+/* { dg-final { scan-assembler-times {vmul\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 13 } }  */\n+/* { dg-final { scan-assembler-times {vdiv\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 13 } }  */\n+/* { dg-final { scan-assembler-times {vcmp\\.f32\\ts[0-9]+, s[0-9]+} 26 } }  */\n+/* { dg-final { scan-assembler-times {vcmpe\\.f32\\ts[0-9]+, s[0-9]+} 52 } }  */\n \n /* { dg-final { scan-assembler-not {vadd\\.f32} } }  */\n /* { dg-final { scan-assembler-not {vsub\\.f32} } }  */"}]}