{"sha": "38ae7651154a39bdeb2638762fa70c042e3d24b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhhZTc2NTExNTRhMzliZGViMjYzODc2MmZhNzBjMDQyZTNkMjRiNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-12-19T09:54:24Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-12-19T09:54:24Z"}, "message": "rtl.def (SUBREG): Update comments.\n\ngcc/\n\t* rtl.def (SUBREG): Update comments.\n\t* rtl.h (reg_attrs): Be explicit about the type of offset used.\n\t(set_reg_attrs_from_mem): Rename to...\n\t(set_reg_attrs_from_value): ...this.\n\t(adjust_reg_mode, byte_lowpart_offset): Declare.\n\t* emit-rtl.c (byte_lowpart_offset): New function.\n\t(update_reg_offset): Remove special offset handling for big-endian\n\ttargets.\n\t(gen_rtx_REG_offset, gen_reg_rtx_offset): Explicitly say that the\n\toffset parameter is added to REG_OFFSET.\n\t(adjust_reg_mode): New function.\n\t(set_reg_attrs_for_mem): Rename to...\n\t(set_reg_attrs_for_value): ...this and generalize to all values.\n\tIf the register is a lowpart of the value, adjust the offset\n\taccordingly.\n\t(set_reg_attrs_for_parm): Update after the above renaming.\n\t(set_reg_attrs_for_decl_rtl): New function, split out from\n\tset_decl_incoming_rtl.  Set the offset of plain REGs to the\n\toffset of the REG's mode from the decl's.  Assert that all\n\tsubregs are lowparts and handle their inner registers in the\n\tsame way as plain REGs.\n\t(set_decl_rtl, set_incoming_decl_rtl): Use reg_attrs_for_decl_rtl.\n\t(subreg_lowpart_offset): Explicitly say that the returned offset\n\tis a SUBREG_BYTE.\n\t* combine.c (do_SUBST_MODE, try_combine, undo_all): Use adjust_reg_mode\n\tinstead of PUT_MODE.\n\t* final.c (alter_subreg): Fix/update argument to gen_rtx_REG_offset.\n\t* config/ia64/ia64.c (ia64_expand_load_address): Likewise.\n\t* regclass.c (reg_scan_mark_refs): Use set_reg_attrs_from_value.\n\t* reload.c (find_reloads_subreg_address): Call set_mem_offset\n\twhen offseting a MEM.\n\t* var-tracking.c (offset_valid_for_tracked_p): Delete.\n\t(mode_for_reg_attrs): Replace with...\n\t(track_loc_p): ...this new function.  Return the mode and offset\n\tto the caller, checking that the latter is valid.  If the rtx is\n\ta paradoxical lowpart of the decl, use the decl's mode instead.\n\tDo the same when storing to a register that contains the entire decl.\n\t(var_lowpart): Use byte_lowpart_offset rather than\n\tsubreg_lowpart_offset when adjusting the offset attribute.\n\t(count_uses, add_uses, add_stores): Use track_reg_p instead of\n\tREG_EXPR, MEM_EXPR, REG_OFFSET, INT_MEM_OFFSET, track_expr_p,\n\toffset_valid_for_tracked_p and mode_for_reg_attrs.  Generate\n\tlowparts for MEMs as well as REGs.\n\t(vt_add_function_parameters): When obtaining the information from\n\tthe decl_rtl, adjust the offset to match incoming.  Use track_loc_p\n\tand var_lowpart.\n\nFrom-SVN: r131055", "tree": {"sha": "04d822382e376ca18a5a67555814561e947a2f3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04d822382e376ca18a5a67555814561e947a2f3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38ae7651154a39bdeb2638762fa70c042e3d24b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38ae7651154a39bdeb2638762fa70c042e3d24b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38ae7651154a39bdeb2638762fa70c042e3d24b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38ae7651154a39bdeb2638762fa70c042e3d24b6/comments", "author": null, "committer": null, "parents": [{"sha": "43779dea9bb2f3cfbb680330d8324a486c450565", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43779dea9bb2f3cfbb680330d8324a486c450565", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43779dea9bb2f3cfbb680330d8324a486c450565"}], "stats": {"total": 450, "additions": 240, "deletions": 210}, "files": [{"sha": "b8ae7dea22e315a2c0ebcc4b1cfb7a09df495d51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38ae7651154a39bdeb2638762fa70c042e3d24b6", "patch": "@@ -1,3 +1,52 @@\n+2007-12-19  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* rtl.def (SUBREG): Update comments.\n+\t* rtl.h (reg_attrs): Be explicit about the type of offset used.\n+\t(set_reg_attrs_from_mem): Rename to...\n+\t(set_reg_attrs_from_value): ...this.\n+\t(adjust_reg_mode, byte_lowpart_offset): Declare.\n+\t* emit-rtl.c (byte_lowpart_offset): New function.\n+\t(update_reg_offset): Remove special offset handling for big-endian\n+\ttargets.\n+\t(gen_rtx_REG_offset, gen_reg_rtx_offset): Explicitly say that the\n+\toffset parameter is added to REG_OFFSET.\n+\t(adjust_reg_mode): New function.\n+\t(set_reg_attrs_for_mem): Rename to...\n+\t(set_reg_attrs_for_value): ...this and generalize to all values.\n+\tIf the register is a lowpart of the value, adjust the offset\n+\taccordingly.\n+\t(set_reg_attrs_for_parm): Update after the above renaming.\n+\t(set_reg_attrs_for_decl_rtl): New function, split out from\n+\tset_decl_incoming_rtl.  Set the offset of plain REGs to the\n+\toffset of the REG's mode from the decl's.  Assert that all\n+\tsubregs are lowparts and handle their inner registers in the\n+\tsame way as plain REGs.\n+\t(set_decl_rtl, set_incoming_decl_rtl): Use reg_attrs_for_decl_rtl.\n+\t(subreg_lowpart_offset): Explicitly say that the returned offset\n+\tis a SUBREG_BYTE.\n+\t* combine.c (do_SUBST_MODE, try_combine, undo_all): Use adjust_reg_mode\n+\tinstead of PUT_MODE.\n+\t* final.c (alter_subreg): Fix/update argument to gen_rtx_REG_offset.\n+\t* config/ia64/ia64.c (ia64_expand_load_address): Likewise.\n+\t* regclass.c (reg_scan_mark_refs): Use set_reg_attrs_from_value.\n+\t* reload.c (find_reloads_subreg_address): Call set_mem_offset\n+\twhen offseting a MEM.\n+\t* var-tracking.c (offset_valid_for_tracked_p): Delete.\n+\t(mode_for_reg_attrs): Replace with...\n+\t(track_loc_p): ...this new function.  Return the mode and offset\n+\tto the caller, checking that the latter is valid.  If the rtx is\n+\ta paradoxical lowpart of the decl, use the decl's mode instead.\n+\tDo the same when storing to a register that contains the entire decl.\n+\t(var_lowpart): Use byte_lowpart_offset rather than\n+\tsubreg_lowpart_offset when adjusting the offset attribute.\n+\t(count_uses, add_uses, add_stores): Use track_reg_p instead of\n+\tREG_EXPR, MEM_EXPR, REG_OFFSET, INT_MEM_OFFSET, track_expr_p,\n+\toffset_valid_for_tracked_p and mode_for_reg_attrs.  Generate\n+\tlowparts for MEMs as well as REGs.\n+\t(vt_add_function_parameters): When obtaining the information from\n+\tthe decl_rtl, adjust the offset to match incoming.  Use track_loc_p\n+\tand var_lowpart.\n+\n 2007-12-18  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR tree-optimization/34123"}, {"sha": "b3d064d3f11b45ffd5c4e34f116be0dcdfd6b5d7", "filename": "gcc/combine.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=38ae7651154a39bdeb2638762fa70c042e3d24b6", "patch": "@@ -751,7 +751,7 @@ do_SUBST_MODE (rtx *into, enum machine_mode newval)\n   buf->kind = UNDO_MODE;\n   buf->where.r = into;\n   buf->old_contents.m = oldval;\n-  PUT_MODE (*into, newval);\n+  adjust_reg_mode (*into, newval);\n \n   buf->next = undobuf.undos, undobuf.undos = buf;\n }\n@@ -2984,7 +2984,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t\t{\n \t\t  struct undo *buf;\n \n-\t\t  PUT_MODE (regno_reg_rtx[REGNO (i2dest)], old_mode);\n+\t\t  adjust_reg_mode (regno_reg_rtx[REGNO (i2dest)], old_mode);\n \t\t  buf = undobuf.undos;\n \t\t  undobuf.undos = buf->next;\n \t\t  buf->next = undobuf.frees;\n@@ -3826,7 +3826,7 @@ undo_all (void)\n \t  *undo->where.i = undo->old_contents.i;\n \t  break;\n \tcase UNDO_MODE:\n-\t  PUT_MODE (*undo->where.r, undo->old_contents.m);\n+\t  adjust_reg_mode (*undo->where.r, undo->old_contents.m);\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();"}, {"sha": "f2d00cf3cc8bd0fbc90188091453bfd1bfe513f7", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=38ae7651154a39bdeb2638762fa70c042e3d24b6", "patch": "@@ -796,7 +796,8 @@ ia64_expand_load_address (rtx dest, rtx src)\n      computation below are also more natural to compute as 64-bit quantities.\n      If we've been given an SImode destination register, change it.  */\n   if (GET_MODE (dest) != Pmode)\n-    dest = gen_rtx_REG_offset (dest, Pmode, REGNO (dest), 0);\n+    dest = gen_rtx_REG_offset (dest, Pmode, REGNO (dest),\n+\t\t\t       byte_lowpart_offset (Pmode, GET_MODE (dest)));\n \n   if (TARGET_NO_PIC)\n     return false;"}, {"sha": "ae8970ce25c74014364fe0440b4c98e1102bb805", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 74, "deletions": 139, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=38ae7651154a39bdeb2638762fa70c042e3d24b6", "patch": "@@ -837,6 +837,22 @@ gen_rtvec_v (int n, rtx *argp)\n   return rt_val;\n }\n \f\n+/* Return the number of bytes between the start of an OUTER_MODE\n+   in-memory value and the start of an INNER_MODE in-memory value,\n+   given that the former is a lowpart of the latter.  It may be a\n+   paradoxical lowpart, in which case the offset will be negative\n+   on big-endian targets.  */\n+\n+int\n+byte_lowpart_offset (enum machine_mode outer_mode,\n+\t\t     enum machine_mode inner_mode)\n+{\n+  if (GET_MODE_SIZE (outer_mode) < GET_MODE_SIZE (inner_mode))\n+    return subreg_lowpart_offset (outer_mode, inner_mode);\n+  else\n+    return -subreg_lowpart_offset (inner_mode, outer_mode);\n+}\n+\f\n /* Generate a REG rtx for a new pseudo register of mode MODE.\n    This pseudo is assigned the next sequential register number.  */\n \n@@ -891,101 +907,18 @@ gen_reg_rtx (enum machine_mode mode)\n   return val;\n }\n \n-/* Update NEW with the same attributes as REG, but offsetted by OFFSET.\n-   Do the big endian correction if needed.  */\n+/* Update NEW with the same attributes as REG, but with OFFSET added\n+   to the REG_OFFSET.  */\n \n static void\n update_reg_offset (rtx new, rtx reg, int offset)\n {\n-  tree decl;\n-  HOST_WIDE_INT var_size;\n-\n-  /* PR middle-end/14084\n-     The problem appears when a variable is stored in a larger register\n-     and later it is used in the original mode or some mode in between\n-     or some part of variable is accessed.\n-\n-     On little endian machines there is no problem because\n-     the REG_OFFSET of the start of the variable is the same when\n-     accessed in any mode (it is 0).\n-\n-     However, this is not true on big endian machines.\n-     The offset of the start of the variable is different when accessed\n-     in different modes.\n-     When we are taking a part of the REG we have to change the OFFSET\n-     from offset WRT size of mode of REG to offset WRT size of variable.\n-\n-     If we would not do the big endian correction the resulting REG_OFFSET\n-     would be larger than the size of the DECL.\n-\n-     Examples of correction, for BYTES_BIG_ENDIAN WORDS_BIG_ENDIAN machine:\n-\n-     REG.mode  MODE  DECL size  old offset  new offset  description\n-     DI        SI    4          4           0           int32 in SImode\n-     DI        SI    1          4           0           char in SImode\n-     DI        QI    1          7           0           char in QImode\n-     DI        QI    4          5           1           1st element in QImode\n-                                                        of char[4]\n-     DI        HI    4          6           2           1st element in HImode\n-                                                        of int16[2]\n-\n-     If the size of DECL is equal or greater than the size of REG\n-     we can't do this correction because the register holds the\n-     whole variable or a part of the variable and thus the REG_OFFSET\n-     is already correct.  */\n-\n-  decl = REG_EXPR (reg);\n-  if ((BYTES_BIG_ENDIAN || WORDS_BIG_ENDIAN)\n-      && decl != NULL\n-      && offset > 0\n-      && GET_MODE_SIZE (GET_MODE (reg)) > GET_MODE_SIZE (GET_MODE (new))\n-      && ((var_size = int_size_in_bytes (TREE_TYPE (decl))) > 0\n-\t  && var_size < GET_MODE_SIZE (GET_MODE (reg))))\n-    {\n-      int offset_le;\n-\n-      /* Convert machine endian to little endian WRT size of mode of REG.  */\n-      if (WORDS_BIG_ENDIAN)\n-\toffset_le = ((GET_MODE_SIZE (GET_MODE (reg)) - 1 - offset)\n-\t\t     / UNITS_PER_WORD) * UNITS_PER_WORD;\n-      else\n-\toffset_le = (offset / UNITS_PER_WORD) * UNITS_PER_WORD;\n-\n-      if (BYTES_BIG_ENDIAN)\n-\toffset_le += ((GET_MODE_SIZE (GET_MODE (reg)) - 1 - offset)\n-\t\t      % UNITS_PER_WORD);\n-      else\n-\toffset_le += offset % UNITS_PER_WORD;\n-\n-      if (offset_le >= var_size)\n-\t{\n-\t  /* MODE is wider than the variable so the new reg will cover\n-\t     the whole variable so the resulting OFFSET should be 0.  */\n-\t  offset = 0;\n-\t}\n-      else\n-\t{\n-\t  /* Convert little endian to machine endian WRT size of variable.  */\n-\t  if (WORDS_BIG_ENDIAN)\n-\t    offset = ((var_size - 1 - offset_le)\n-\t\t      / UNITS_PER_WORD) * UNITS_PER_WORD;\n-\t  else\n-\t    offset = (offset_le / UNITS_PER_WORD) * UNITS_PER_WORD;\n-\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    offset += ((var_size - 1 - offset_le)\n-\t\t       % UNITS_PER_WORD);\n-\t  else\n-\t    offset += offset_le % UNITS_PER_WORD;\n-\t}\n-    }\n-\n   REG_ATTRS (new) = get_reg_attrs (REG_EXPR (reg),\n \t\t\t\t   REG_OFFSET (reg) + offset);\n }\n \n-/* Generate a register with same attributes as REG, but offsetted by\n-   OFFSET.  */\n+/* Generate a register with same attributes as REG, but with OFFSET\n+   added to the REG_OFFSET.  */\n \n rtx\n gen_rtx_REG_offset (rtx reg, enum machine_mode mode, unsigned int regno,\n@@ -998,7 +931,7 @@ gen_rtx_REG_offset (rtx reg, enum machine_mode mode, unsigned int regno,\n }\n \n /* Generate a new pseudo-register with the same attributes as REG, but\n-   offsetted by OFFSET.  */\n+   with OFFSET added to the REG_OFFSET.  */\n \n rtx\n gen_reg_rtx_offset (rtx reg, enum machine_mode mode, int offset)\n@@ -1009,14 +942,30 @@ gen_reg_rtx_offset (rtx reg, enum machine_mode mode, int offset)\n   return new;\n }\n \n-/* Set REG to the decl that MEM refers to.  */\n+/* Adjust REG in-place so that it has mode MODE.  It is assumed that the\n+   new register is a (possibly paradoxical) lowpart of the old one.  */\n+\n+void\n+adjust_reg_mode (rtx reg, enum machine_mode mode)\n+{\n+  update_reg_offset (reg, reg, byte_lowpart_offset (mode, GET_MODE (reg)));\n+  PUT_MODE (reg, mode);\n+}\n+\n+/* Copy REG's attributes from X, if X has any attributes.  If REG and X\n+   have different modes, REG is a (possibly paradoxical) lowpart of X.  */\n \n void\n-set_reg_attrs_from_mem (rtx reg, rtx mem)\n+set_reg_attrs_from_value (rtx reg, rtx x)\n {\n-  if (MEM_OFFSET (mem) && GET_CODE (MEM_OFFSET (mem)) == CONST_INT)\n+  int offset;\n+\n+  offset = byte_lowpart_offset (GET_MODE (reg), GET_MODE (x));\n+  if (MEM_P (x) && MEM_OFFSET (x) && GET_CODE (MEM_OFFSET (x)) == CONST_INT)\n     REG_ATTRS (reg)\n-      = get_reg_attrs (MEM_EXPR (mem), INTVAL (MEM_OFFSET (mem)));\n+      = get_reg_attrs (MEM_EXPR (x), INTVAL (MEM_OFFSET (x)) + offset);\n+  if (REG_P (x) && REG_ATTRS (x))\n+    update_reg_offset (reg, x, offset);\n }\n \n /* Set the register attributes for registers contained in PARM_RTX.\n@@ -1026,7 +975,7 @@ void\n set_reg_attrs_for_parm (rtx parm_rtx, rtx mem)\n {\n   if (REG_P (parm_rtx))\n-    set_reg_attrs_from_mem (parm_rtx, mem);\n+    set_reg_attrs_from_value (parm_rtx, mem);\n   else if (GET_CODE (parm_rtx) == PARALLEL)\n     {\n       /* Check for a NULL entry in the first slot, used to indicate that the\n@@ -1043,54 +992,21 @@ set_reg_attrs_for_parm (rtx parm_rtx, rtx mem)\n     }\n }\n \n-/* Assign the RTX X to declaration T.  */\n-void\n-set_decl_rtl (tree t, rtx x)\n-{\n-  DECL_WRTL_CHECK (t)->decl_with_rtl.rtl = x;\n+/* Set the REG_ATTRS for registers in value X, given that X represents\n+   decl T.  */\n \n-  if (!x)\n-    return;\n-  /* For register, we maintain the reverse information too.  */\n-  if (REG_P (x))\n-    REG_ATTRS (x) = get_reg_attrs (t, 0);\n-  else if (GET_CODE (x) == SUBREG)\n-    REG_ATTRS (SUBREG_REG (x))\n-      = get_reg_attrs (t, -SUBREG_BYTE (x));\n-  if (GET_CODE (x) == CONCAT)\n-    {\n-      if (REG_P (XEXP (x, 0)))\n-        REG_ATTRS (XEXP (x, 0)) = get_reg_attrs (t, 0);\n-      if (REG_P (XEXP (x, 1)))\n-\tREG_ATTRS (XEXP (x, 1))\n-\t  = get_reg_attrs (t, GET_MODE_UNIT_SIZE (GET_MODE (XEXP (x, 0))));\n-    }\n-  if (GET_CODE (x) == PARALLEL)\n+static void\n+set_reg_attrs_for_decl_rtl (tree t, rtx x)\n+{\n+  if (GET_CODE (x) == SUBREG)\n     {\n-      int i;\n-      for (i = 0; i < XVECLEN (x, 0); i++)\n-\t{\n-\t  rtx y = XVECEXP (x, 0, i);\n-\t  if (REG_P (XEXP (y, 0)))\n-\t    REG_ATTRS (XEXP (y, 0)) = get_reg_attrs (t, INTVAL (XEXP (y, 1)));\n-\t}\n+      gcc_assert (subreg_lowpart_p (x));\n+      x = SUBREG_REG (x);\n     }\n-}\n-\n-/* Assign the RTX X to parameter declaration T.  */\n-void\n-set_decl_incoming_rtl (tree t, rtx x)\n-{\n-  DECL_INCOMING_RTL (t) = x;\n-\n-  if (!x)\n-    return;\n-  /* For register, we maintain the reverse information too.  */\n   if (REG_P (x))\n-    REG_ATTRS (x) = get_reg_attrs (t, 0);\n-  else if (GET_CODE (x) == SUBREG)\n-    REG_ATTRS (SUBREG_REG (x))\n-      = get_reg_attrs (t, -SUBREG_BYTE (x));\n+    REG_ATTRS (x)\n+      = get_reg_attrs (t, byte_lowpart_offset (GET_MODE (x),\n+\t\t\t\t\t       TYPE_MODE (TREE_TYPE (t))));\n   if (GET_CODE (x) == CONCAT)\n     {\n       if (REG_P (XEXP (x, 0)))\n@@ -1119,6 +1035,26 @@ set_decl_incoming_rtl (tree t, rtx x)\n     }\n }\n \n+/* Assign the RTX X to declaration T.  */\n+\n+void\n+set_decl_rtl (tree t, rtx x)\n+{\n+  DECL_WRTL_CHECK (t)->decl_with_rtl.rtl = x;\n+  if (x)\n+    set_reg_attrs_for_decl_rtl (t, x);\n+}\n+\n+/* Assign the RTX X to parameter declaration T.  */\n+\n+void\n+set_decl_incoming_rtl (tree t, rtx x)\n+{\n+  DECL_INCOMING_RTL (t) = x;\n+  if (x)\n+    set_reg_attrs_for_decl_rtl (t, x);\n+}\n+\n /* Identify REG (which may be a CONCAT) as a user register.  */\n \n void\n@@ -1304,8 +1240,7 @@ gen_highpart_mode (enum machine_mode outermode, enum machine_mode innermode, rtx\n \t\t\t      subreg_highpart_offset (outermode, innermode));\n }\n \n-/* Return offset in bytes to get OUTERMODE low part\n-   of the value in mode INNERMODE stored in memory in target format.  */\n+/* Return the SUBREG_BYTE for an OUTERMODE lowpart of an INNERMODE value.  */\n \n unsigned int\n subreg_lowpart_offset (enum machine_mode outermode, enum machine_mode innermode)"}, {"sha": "72edbc05acc4ad1dae574382ba321c74b86700b8", "filename": "gcc/final.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=38ae7651154a39bdeb2638762fa70c042e3d24b6", "patch": "@@ -2763,8 +2763,15 @@ alter_subreg (rtx *xp)\n       else if (REG_P (y))\n \t{\n \t  /* Simplify_subreg can't handle some REG cases, but we have to.  */\n-\t  unsigned int regno = subreg_regno (x);\n-\t  *xp = gen_rtx_REG_offset (y, GET_MODE (x), regno, SUBREG_BYTE (x));\n+\t  unsigned int regno;\n+\t  HOST_WIDE_INT offset;\n+\n+\t  regno = subreg_regno (x);\n+\t  if (subreg_lowpart_p (x))\n+\t    offset = byte_lowpart_offset (GET_MODE (x), GET_MODE (y));\n+\t  else\n+\t    offset = SUBREG_BYTE (x);\n+\t  *xp = gen_rtx_REG_offset (y, GET_MODE (x), regno, offset);\n \t}\n     }\n "}, {"sha": "a4734f2c9bd4c325477b5b1ffebe2383300a4e14", "filename": "gcc/regclass.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=38ae7651154a39bdeb2638762fa70c042e3d24b6", "patch": "@@ -2435,10 +2435,7 @@ reg_scan_mark_refs (rtx x, rtx insn)\n \t\t || (GET_CODE (src) == SUBREG && subreg_lowpart_p (src)))\n \t    src = XEXP (src, 0);\n \n-\t  if (REG_P (src))\n-\t    REG_ATTRS (dest) = REG_ATTRS (src);\n-\t  if (MEM_P (src))\n-\t    set_reg_attrs_from_mem (dest, src);\n+\t  set_reg_attrs_from_value (dest, src);\n \t}\n \n       /* ... fall through ...  */"}, {"sha": "8f84546fbb24f647364dc02658e1b791be98b774", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=38ae7651154a39bdeb2638762fa70c042e3d24b6", "patch": "@@ -6025,6 +6025,8 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n \n \t      XEXP (tem, 0) = plus_constant (XEXP (tem, 0), offset);\n \t      PUT_MODE (tem, GET_MODE (x));\n+\t      if (MEM_OFFSET (tem))\n+\t\tset_mem_offset (tem, plus_constant (MEM_OFFSET (tem), offset));\n \n \t      /* If this was a paradoxical subreg that we replaced, the\n \t\t resulting memory must be sufficiently aligned to allow"}, {"sha": "fa2238c58b77f8ab82d3770f0145fb1c71290775", "filename": "gcc/rtl.def", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=38ae7651154a39bdeb2638762fa70c042e3d24b6", "patch": "@@ -371,14 +371,8 @@ DEF_RTL_EXPR(REG, \"reg\", \"i00\", RTX_OBJ)\n    marked as having one operand so it can be turned into a REG.  */\n DEF_RTL_EXPR(SCRATCH, \"scratch\", \"0\", RTX_OBJ)\n \n-/* One word of a multi-word value.\n-   The first operand is the complete value; the second says which word.\n-   The WORDS_BIG_ENDIAN flag controls whether word number 0\n-   (as numbered in a SUBREG) is the most or least significant word.\n-\n-   This is also used to refer to a value in a different machine mode.\n-   For example, it can be used to refer to a SImode value as if it were\n-   Qimode, or vice versa.  Then the word number is always 0.  */\n+/* A reference to a part of another value.  The first operand is the\n+   complete value and the second is the byte offset of the selected part.   */\n DEF_RTL_EXPR(SUBREG, \"subreg\", \"ei\", RTX_EXTRA)\n \n /* This one-argument rtx is used for move instructions"}, {"sha": "f4aa35a387b4152615ee131cda2826178b77e49e", "filename": "gcc/rtl.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=38ae7651154a39bdeb2638762fa70c042e3d24b6", "patch": "@@ -149,7 +149,11 @@ typedef struct mem_attrs GTY(())\n } mem_attrs;\n \n /* Structure used to describe the attributes of a REG in similar way as\n-   mem_attrs does for MEM above.  */\n+   mem_attrs does for MEM above.  Note that the OFFSET field is calculated\n+   in the same way as for mem_attrs, rather than in the same way as a\n+   SUBREG_BYTE.  For example, if a big-endian target stores a byte\n+   object in the low part of a 4-byte register, the OFFSET field\n+   will be -3 rather than 0.  */\n \n typedef struct reg_attrs GTY(())\n {\n@@ -1476,9 +1480,10 @@ extern rtx copy_insn_1 (rtx);\n extern rtx copy_insn (rtx);\n extern rtx gen_int_mode (HOST_WIDE_INT, enum machine_mode);\n extern rtx emit_copy_of_insn_after (rtx, rtx);\n-extern void set_reg_attrs_from_mem (rtx, rtx);\n+extern void set_reg_attrs_from_value (rtx, rtx);\n extern void set_mem_attrs_from_reg (rtx, rtx);\n extern void set_reg_attrs_for_parm (rtx, rtx);\n+extern void adjust_reg_mode (rtx, enum machine_mode);\n extern int mem_expr_equal_p (const_tree, const_tree);\n \n /* In rtl.c */\n@@ -1522,6 +1527,7 @@ extern unsigned int subreg_lowpart_offset (enum machine_mode,\n \t\t\t\t\t   enum machine_mode);\n extern unsigned int subreg_highpart_offset (enum machine_mode,\n \t\t\t\t\t    enum machine_mode);\n+extern int byte_lowpart_offset (enum machine_mode, enum machine_mode);\n extern rtx make_safe_from (rtx, rtx);\n extern rtx convert_memory_address (enum machine_mode, rtx);\n extern rtx get_insns (void);"}, {"sha": "eb7e3b9626e06e56e7f79de9e9394c2df4f918fc", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 90, "deletions": 51, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ae7651154a39bdeb2638762fa70c042e3d24b6/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=38ae7651154a39bdeb2638762fa70c042e3d24b6", "patch": "@@ -1645,18 +1645,6 @@ track_expr_p (tree expr)\n   return 1;\n }\n \n-/* Return true if OFFSET is a valid offset for a register or memory\n-   access we want to track.  This is used to reject out-of-bounds\n-   accesses that can cause assertions to fail later.  Note that we\n-   don't reject negative offsets because they can be generated for\n-   paradoxical subregs on big-endian architectures.  */\n-\n-static inline bool\n-offset_valid_for_tracked_p (HOST_WIDE_INT offset)\n-{\n-  return (-MAX_VAR_PARTS < offset) && (offset < MAX_VAR_PARTS);\n-}\n-\n /* Determine whether a given LOC refers to the same variable part as\n    EXPR+OFFSET.  */\n \n@@ -1691,28 +1679,65 @@ same_variable_part_p (rtx loc, tree expr, HOST_WIDE_INT offset)\n   return (expr == expr2 && offset == offset2);\n }\n \n-/* REG is a register we want to track.  If not all of REG contains useful\n-   information, return the mode of the lowpart that does contain useful\n-   information, otherwise return the mode of REG.\n+/* LOC is a REG or MEM that we would like to track if possible.\n+   If EXPR is null, we don't know what expression LOC refers to,\n+   otherwise it refers to EXPR + OFFSET.  STORE_REG_P is true if\n+   LOC is an lvalue register.\n \n-   If REG was a paradoxical subreg, its REG_ATTRS will describe the\n-   whole subreg, but only the old inner part is really relevant.  */\n+   Return true if EXPR is nonnull and if LOC, or some lowpart of it,\n+   is something we can track.  When returning true, store the mode of\n+   the lowpart we can track in *MODE_OUT (if nonnull) and its offset\n+   from EXPR in *OFFSET_OUT (if nonnull).  */\n \n-static enum machine_mode\n-mode_for_reg_attrs (rtx reg)\n+static bool\n+track_loc_p (rtx loc, tree expr, HOST_WIDE_INT offset, bool store_reg_p,\n+\t     enum machine_mode *mode_out, HOST_WIDE_INT *offset_out)\n {\n   enum machine_mode mode;\n \n-  mode = GET_MODE (reg);\n-  if (!HARD_REGISTER_NUM_P (ORIGINAL_REGNO (reg)))\n+  if (expr == NULL || !track_expr_p (expr))\n+    return false;\n+\n+  /* If REG was a paradoxical subreg, its REG_ATTRS will describe the\n+     whole subreg, but only the old inner part is really relevant.  */\n+  mode = GET_MODE (loc);\n+  if (REG_P (loc) && !HARD_REGISTER_NUM_P (ORIGINAL_REGNO (loc)))\n     {\n       enum machine_mode pseudo_mode;\n \n-      pseudo_mode = PSEUDO_REGNO_MODE (ORIGINAL_REGNO (reg));\n+      pseudo_mode = PSEUDO_REGNO_MODE (ORIGINAL_REGNO (loc));\n       if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (pseudo_mode))\n-\tmode = pseudo_mode;\n+\t{\n+\t  offset += byte_lowpart_offset (pseudo_mode, mode);\n+\t  mode = pseudo_mode;\n+\t}\n+    }\n+\n+  /* If LOC is a paradoxical lowpart of EXPR, refer to EXPR itself.\n+     Do the same if we are storing to a register and EXPR occupies\n+     the whole of register LOC; in that case, the whole of EXPR is\n+     being changed.  We exclude complex modes from the second case\n+     because the real and imaginary parts are represented as separate\n+     pseudo registers, even if the whole complex value fits into one\n+     hard register.  */\n+  if ((GET_MODE_SIZE (mode) > GET_MODE_SIZE (DECL_MODE (expr))\n+       || (store_reg_p\n+\t   && !COMPLEX_MODE_P (DECL_MODE (expr))\n+\t   && hard_regno_nregs[REGNO (loc)][DECL_MODE (expr)] == 1))\n+      && offset + byte_lowpart_offset (DECL_MODE (expr), mode) == 0)\n+    {\n+      mode = DECL_MODE (expr);\n+      offset = 0;\n     }\n-  return mode;\n+\n+  if (offset < 0 || offset >= MAX_VAR_PARTS)\n+    return false;\n+\n+  if (mode_out)\n+    *mode_out = mode;\n+  if (offset_out)\n+    *offset_out = offset;\n+  return true;\n }\n \n /* Return the MODE lowpart of LOC, or null if LOC is not something we\n@@ -1722,21 +1747,22 @@ mode_for_reg_attrs (rtx reg)\n static rtx\n var_lowpart (enum machine_mode mode, rtx loc)\n {\n-  unsigned int offset, regno;\n+  unsigned int offset, reg_offset, regno;\n \n   if (!REG_P (loc) && !MEM_P (loc))\n     return NULL;\n \n   if (GET_MODE (loc) == mode)\n     return loc;\n \n-  offset = subreg_lowpart_offset (mode, GET_MODE (loc));\n+  offset = byte_lowpart_offset (mode, GET_MODE (loc));\n \n   if (MEM_P (loc))\n     return adjust_address_nv (loc, mode, offset);\n \n+  reg_offset = subreg_lowpart_offset (mode, GET_MODE (loc));\n   regno = REGNO (loc) + subreg_regno_offset (REGNO (loc), GET_MODE (loc),\n-\t\t\t\t\t     offset, mode);\n+\t\t\t\t\t     reg_offset, mode);\n   return gen_rtx_REG_offset (loc, mode, regno, offset);\n }\n \n@@ -1754,9 +1780,8 @@ count_uses (rtx *loc, void *insn)\n       VTI (bb)->n_mos++;\n     }\n   else if (MEM_P (*loc)\n-\t   && MEM_EXPR (*loc)\n-\t   && track_expr_p (MEM_EXPR (*loc))\n-\t   && offset_valid_for_tracked_p (INT_MEM_OFFSET (*loc)))\n+\t   && track_loc_p (*loc, MEM_EXPR (*loc), INT_MEM_OFFSET (*loc),\n+\t\t\t   false, NULL, NULL))\n     {\n       VTI (bb)->n_mos++;\n     }\n@@ -1787,17 +1812,18 @@ count_stores (rtx loc, const_rtx expr ATTRIBUTE_UNUSED, void *insn)\n static int\n add_uses (rtx *loc, void *insn)\n {\n+  enum machine_mode mode;\n+\n   if (REG_P (*loc))\n     {\n       basic_block bb = BLOCK_FOR_INSN ((rtx) insn);\n       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n \n-      if (REG_EXPR (*loc)\n-\t  && track_expr_p (REG_EXPR (*loc))\n-\t  && offset_valid_for_tracked_p (REG_OFFSET (*loc)))\n+      if (track_loc_p (*loc, REG_EXPR (*loc), REG_OFFSET (*loc),\n+\t\t       false, &mode, NULL))\n \t{\n \t  mo->type = MO_USE;\n-\t  mo->u.loc = var_lowpart (mode_for_reg_attrs (*loc), *loc);\n+\t  mo->u.loc = var_lowpart (mode, *loc);\n \t}\n       else\n \t{\n@@ -1807,15 +1833,14 @@ add_uses (rtx *loc, void *insn)\n       mo->insn = (rtx) insn;\n     }\n   else if (MEM_P (*loc)\n-\t   && MEM_EXPR (*loc)\n-\t   && track_expr_p (MEM_EXPR (*loc))\n-\t   && offset_valid_for_tracked_p (INT_MEM_OFFSET (*loc)))\n+\t   && track_loc_p (*loc, MEM_EXPR (*loc), INT_MEM_OFFSET (*loc),\n+\t\t\t   false, &mode, NULL))\n     {\n       basic_block bb = BLOCK_FOR_INSN ((rtx) insn);\n       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n \n       mo->type = MO_USE;\n-      mo->u.loc = *loc;\n+      mo->u.loc = var_lowpart (mode, *loc);\n       mo->insn = (rtx) insn;\n     }\n \n@@ -1837,22 +1862,22 @@ add_uses_1 (rtx *x, void *insn)\n static void\n add_stores (rtx loc, const_rtx expr, void *insn)\n {\n+  enum machine_mode mode;\n+\n   if (REG_P (loc))\n     {\n       basic_block bb = BLOCK_FOR_INSN ((rtx) insn);\n       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n \n       if (GET_CODE (expr) == CLOBBER\n-\t  || !(REG_EXPR (loc)\n-\t       && track_expr_p (REG_EXPR (loc))\n-\t       && offset_valid_for_tracked_p (REG_OFFSET (loc))))\n+\t  || !track_loc_p (loc, REG_EXPR (loc), REG_OFFSET (loc),\n+\t\t\t   true, &mode, NULL))\n \t{\n \t  mo->type = MO_CLOBBER;\n \t  mo->u.loc = loc;\n \t}\n       else\n \t{\n-\t  enum machine_mode mode = mode_for_reg_attrs (loc);\n \t  rtx src = NULL;\n \n \t  if (GET_CODE (expr) == SET && SET_DEST (expr) == loc)\n@@ -1878,24 +1903,24 @@ add_stores (rtx loc, const_rtx expr, void *insn)\n       mo->insn = (rtx) insn;\n     }\n   else if (MEM_P (loc)\n-\t   && MEM_EXPR (loc)\n-\t   && track_expr_p (MEM_EXPR (loc))\n-\t   && offset_valid_for_tracked_p (INT_MEM_OFFSET (loc)))\n+\t   && track_loc_p (loc, MEM_EXPR (loc), INT_MEM_OFFSET (loc),\n+\t\t\t   false, &mode, NULL))\n     {\n       basic_block bb = BLOCK_FOR_INSN ((rtx) insn);\n       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n \n       if (GET_CODE (expr) == CLOBBER)\n \t{\n \t  mo->type = MO_CLOBBER;\n-\t  mo->u.loc = loc;\n+\t  mo->u.loc = var_lowpart (mode, loc);\n \t}\n       else\n \t{\n \t  rtx src = NULL;\n \n \t  if (GET_CODE (expr) == SET && SET_DEST (expr) == loc)\n-\t    src = var_lowpart (GET_MODE (loc), SET_SRC (expr));\n+\t    src = var_lowpart (mode, SET_SRC (expr));\n+\t  loc = var_lowpart (mode, loc);\n \n \t  if (src == NULL)\n \t    {\n@@ -1904,6 +1929,8 @@ add_stores (rtx loc, const_rtx expr, void *insn)\n \t    }\n \t  else\n \t    {\n+\t      if (SET_SRC (expr) != src)\n+\t\texpr = gen_rtx_SET (VOIDmode, loc, src);\n \t      if (same_variable_part_p (SET_SRC (expr),\n \t\t\t\t\tMEM_EXPR (loc),\n \t\t\t\t\tINT_MEM_OFFSET (loc)))\n@@ -3115,6 +3142,7 @@ vt_add_function_parameters (void)\n       rtx decl_rtl = DECL_RTL_IF_SET (parm);\n       rtx incoming = DECL_INCOMING_RTL (parm);\n       tree decl;\n+      enum machine_mode mode;\n       HOST_WIDE_INT offset;\n       dataflow_set *out;\n \n@@ -3131,27 +3159,38 @@ vt_add_function_parameters (void)\n \tcontinue;\n \n       if (!vt_get_decl_and_offset (incoming, &decl, &offset))\n-\tif (!vt_get_decl_and_offset (decl_rtl, &decl, &offset))\n-\t  continue;\n+\t{\n+\t  if (!vt_get_decl_and_offset (decl_rtl, &decl, &offset))\n+\t    continue;\n+\t  offset += byte_lowpart_offset (GET_MODE (incoming),\n+\t\t\t\t\t GET_MODE (decl_rtl));\n+\t}\n \n       if (!decl)\n \tcontinue;\n \n       gcc_assert (parm == decl);\n \n+      if (!track_loc_p (incoming, parm, offset, false, &mode, &offset))\n+\tcontinue;\n+\n       out = &VTI (ENTRY_BLOCK_PTR)->out;\n \n       if (REG_P (incoming))\n \t{\n+\t  incoming = var_lowpart (mode, incoming);\n \t  gcc_assert (REGNO (incoming) < FIRST_PSEUDO_REGISTER);\n \t  attrs_list_insert (&out->regs[REGNO (incoming)],\n \t\t\t     parm, offset, incoming);\n \t  set_variable_part (out, incoming, parm, offset, VAR_INIT_STATUS_INITIALIZED, \n \t\t\t     NULL);\n \t}\n       else if (MEM_P (incoming))\n-\tset_variable_part (out, incoming, parm, offset, VAR_INIT_STATUS_INITIALIZED, \n-\t\t\t   NULL);\n+\t{\n+\t  incoming = var_lowpart (mode, incoming);\n+\t  set_variable_part (out, incoming, parm, offset,\n+\t\t\t     VAR_INIT_STATUS_INITIALIZED, NULL);\n+\t}\n     }\n }\n "}]}