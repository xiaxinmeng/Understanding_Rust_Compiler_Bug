{"sha": "fe25fea3f817e507caec0b3b9f41b318aae2a1ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmUyNWZlYTNmODE3ZTUwN2NhZWMwYjNiOWY0MWIzMThhYWUyYTFlZQ==", "commit": {"author": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-07-24T20:41:43Z"}, "committer": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-07-24T20:41:43Z"}, "message": "(put_condition_code, print_operand, output_fp_cc0_set):\n\nSupport fcmov suffixes.\n\nFrom-SVN: r12560", "tree": {"sha": "0180913b92b7dea78f08249cefeee0cf2c18dcb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0180913b92b7dea78f08249cefeee0cf2c18dcb9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe25fea3f817e507caec0b3b9f41b318aae2a1ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe25fea3f817e507caec0b3b9f41b318aae2a1ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe25fea3f817e507caec0b3b9f41b318aae2a1ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe25fea3f817e507caec0b3b9f41b318aae2a1ee/comments", "author": null, "committer": null, "parents": [{"sha": "56710e421f38c3cbe737f824fa3f8abe33567e2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56710e421f38c3cbe737f824fa3f8abe33567e2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56710e421f38c3cbe737f824fa3f8abe33567e2d"}], "stats": {"total": 69, "additions": 58, "deletions": 11}, "files": [{"sha": "c86e6d684d583d6354479d094ed6d7c7653f9ccf", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 58, "deletions": 11, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe25fea3f817e507caec0b3b9f41b318aae2a1ee/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe25fea3f817e507caec0b3b9f41b318aae2a1ee/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=fe25fea3f817e507caec0b3b9f41b318aae2a1ee", "patch": "@@ -2685,14 +2685,15 @@ output_pic_addr_const (file, x, code)\n     }\n }\n \f\n-\n /* Append the correct conditional move suffix which corresponds to CODE */\n \n static void\n-put_condition_code (code, file)\n-    enum rtx_code code;\n-    FILE * file;\n+put_condition_code (code, mode, file)\n+     enum rtx_code code;\n+     enum mode_class mode;\n+     FILE * file;\n {\n+  if (mode == MODE_INT)\n   switch (code)\n     {\n       case NE: \n@@ -2725,13 +2726,39 @@ put_condition_code (code, file)\n \t  fputs (\"b\", file); return;\n       default: output_operand_lossage (\"Invalid %%C operand\");\n     }\n+  else if (mode == MODE_FLOAT)\n+  switch (code)\n+    {\n+      case NE: \n+          fputs (\"ne\", file); return;\n+      case EQ: \n+\t  fputs (\"e\", file); return;\n+      case GE: \n+\t  fputs (\"nb\", file); return;\n+      case GT: \n+\t  fputs (\"nbe\", file); return;\n+      case LE: \n+\t  fputs (\"be\", file); return;\n+      case LT: \n+\t  fputs (\"b\", file); return;\n+      case GEU: \n+\t  fputs (\"nb\", file); return;\n+      case GTU: \n+\t  fputs (\"nbe\", file); return;\n+      case LEU: \n+\t  fputs (\"be\", file); return;\n+      case LTU: \n+\t  fputs (\"b\", file); return;\n+      default: output_operand_lossage (\"Invalid %%C operand\");\n+    }\n }\n \n /* Meaning of CODE:\n-   f -- float insn (print a CONST_DOUBLE as a float rather than in hex).\n-   D,L,W,B,Q,S -- print the opcode suffix for specified size of operand.\n+   L,W,B,Q,S,T -- print the opcode suffix for specified size of operand.\n    C -- print opcode suffix for set/cmov insn.\n-   N -- like C, but print reversed condition\n+   c -- like C, but print reversed condition\n+   F -- print opcode suffix for fcmov insn.\n+   f -- like C, but print reversed condition\n    R -- print the prefix for register names.\n    z -- print the opcode suffix for the size of the current operand.\n    * -- print a star (in certain assembler syntax)\n@@ -2740,6 +2767,13 @@ put_condition_code (code, file)\n    J -- print the appropriate jump operand.\n    s -- print a shift double count, followed by the assemblers argument\n \tdelimiter.\n+   b -- print the QImode name of the register for the indicated operand.\n+\t%b0 would print %al if operands[0] is reg 0.\n+   w --  likewise, print the HImode name of the register.\n+   k --  likewise, print the SImode name of the register.\n+   h --  print the QImode name for a \"high\" register, either ah, bh, ch or dh.\n+   y --  print \"st(0)\" instead of \"st\" as a register.\n+   P --  print as a PIC constant\n */\n \n void\n@@ -2866,11 +2900,22 @@ print_operand (file, x, code)\n \n \t  /* This is used by the conditional move instructions.  */\n \tcase 'C':\n-\t  put_condition_code (GET_CODE (x), file);\n+\t  put_condition_code (GET_CODE (x), MODE_INT, file);\n \t  return;\n+\n+\t  /* like above, but reverse condition */\n+\tcase 'c':\n+\t  put_condition_code (reverse_condition (GET_CODE (x)), MODE_INT, file);\n+\t  return;\n+\n+\tcase 'F':\n+\t  put_condition_code (GET_CODE (x), MODE_FLOAT, file);\n+\t  return;\n+\n \t  /* like above, but reverse condition */\n-\tcase 'N':\n-\t  put_condition_code (reverse_condition (GET_CODE (x)), file);\n+\tcase 'f':\n+\t  put_condition_code (reverse_condition (GET_CODE (x)),\n+\t\t\t      MODE_FLOAT, file);\n \t  return;\n \n \tdefault:\n@@ -3623,7 +3668,9 @@ output_fp_cc0_set (insn)\n     }\n   else if (GET_CODE (PATTERN (next)) == SET)\n     {\n-      code = GET_CODE (SET_SRC (PATTERN (next)));\n+      if (GET_CODE (SET_SRC (PATTERN (next))) == IF_THEN_ELSE)\n+\tcode = GET_CODE (XEXP (SET_SRC (PATTERN (next)), 0));\n+      else code = GET_CODE (SET_SRC (PATTERN (next)));\n     }\n   else\n     abort ();"}]}