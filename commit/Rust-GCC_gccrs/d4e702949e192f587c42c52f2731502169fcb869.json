{"sha": "d4e702949e192f587c42c52f2731502169fcb869", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRlNzAyOTQ5ZTE5MmY1ODdjNDJjNTJmMjczMTUwMjE2OWZjYjg2OQ==", "commit": {"author": {"name": "Olga Golovanevsky", "email": "olga@il.ibm.com", "date": "2007-03-12T08:44:48Z"}, "committer": {"name": "Olga Golovanevsky", "email": "olga@gcc.gnu.org", "date": "2007-03-12T08:44:48Z"}, "message": "ipa-type-escape improvements\n\nFrom-SVN: r122835", "tree": {"sha": "c8d7d0f2766c8bb656828d0b6744c332e1b705a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8d7d0f2766c8bb656828d0b6744c332e1b705a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4e702949e192f587c42c52f2731502169fcb869", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4e702949e192f587c42c52f2731502169fcb869", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4e702949e192f587c42c52f2731502169fcb869", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4e702949e192f587c42c52f2731502169fcb869/comments", "author": null, "committer": null, "parents": [{"sha": "e8bb459742b8df82d418cce1389040429e02ab47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8bb459742b8df82d418cce1389040429e02ab47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8bb459742b8df82d418cce1389040429e02ab47"}], "stats": {"total": 482, "additions": 419, "deletions": 63}, "files": [{"sha": "8192093b5ecf234a91404b2aedf36768ab812a59", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e702949e192f587c42c52f2731502169fcb869/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e702949e192f587c42c52f2731502169fcb869/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4e702949e192f587c42c52f2731502169fcb869", "patch": "@@ -1,3 +1,20 @@\n+2007-03-12  Olga Golovanevsky  <olga@il.ibm.com>\n+  \n+  \t* tree.h : Add multiple_of_p declaration.\n+  \t* fold-const.c (multiple_of_p): Make multiple_of_p public. \n+  \t* ipa-type-escape.c (results_of_malloc): Redundant.\n+  \t(visited_stmts): New. Visited stmt for walk_use_def_chains.\n+  \t(cast_type): Extended with new members.\n+  \t(check_cast): Returns cast_type.\n+  \t(cast): New structure for data of walk_use_def_chains.\n+  \t(is_malloc_result, is_cast_from_non_pointer_1,\n+  \tis_cast_from_non_pointer, \n+  \tis_array_access_through_pointer_and_index): New functions.\n+  \t(look_for_casts): Returns cast types.\n+ \t(check_call): Returns void.\n+  \t(okay_pointer_operation): Use support of pointer plus index,\n+  \tpointer plus constant and allow all multiplications.\n+\t\n 2007-03-11  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/31115"}, {"sha": "daad1ba3d41f5ba6840bc5f23c9598c8ff709d35", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e702949e192f587c42c52f2731502169fcb869/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e702949e192f587c42c52f2731502169fcb869/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d4e702949e192f587c42c52f2731502169fcb869", "patch": "@@ -131,7 +131,6 @@ static tree fold_truthop (enum tree_code, tree, tree, tree);\n static tree optimize_minmax_comparison (enum tree_code, tree, tree, tree);\n static tree extract_muldiv (tree, tree, enum tree_code, tree, bool *);\n static tree extract_muldiv_1 (tree, tree, enum tree_code, tree, bool *);\n-static int multiple_of_p (tree, tree, tree);\n static tree fold_binary_op_with_conditional_arg (enum tree_code, tree,\n \t\t\t\t\t\t tree, tree,\n \t\t\t\t\t\t tree, tree, int);\n@@ -13115,7 +13114,7 @@ fold_build_call_array_initializer (tree type, tree fn,\n    (where the same SAVE_EXPR (J) is used in the original and the\n    transformed version).  */\n \n-static int\n+int\n multiple_of_p (tree type, tree top, tree bottom)\n {\n   if (operand_equal_p (top, bottom, 0))"}, {"sha": "d4c86ca06b2cdf3ef2721a990383ed20d3030f48", "filename": "gcc/ipa-type-escape.c", "status": "modified", "additions": 400, "deletions": 60, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e702949e192f587c42c52f2731502169fcb869/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e702949e192f587c42c52f2731502169fcb869/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=d4e702949e192f587c42c52f2731502169fcb869", "patch": "@@ -60,13 +60,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    this phase has been run.  */\n static bool initialized = false;\n \n-/* This bitmap contains the set of local vars that are the lhs of\n-   calls to mallocs.  These variables, when seen on the rhs as part of\n-   a cast, the cast are not marked as doing bad things to the type\n-   even though they are generally of the form \n-   \"foo = (type_of_foo)void_temp\". */\n-static bitmap results_of_malloc;\n-\n /* Scratch bitmap for avoiding work. */\n static bitmap been_there_done_that;\n static bitmap bitmap_tmp;\n@@ -135,8 +128,17 @@ static splay_tree uid_to_subtype_map;\n    scan_for_refs.  */\n static struct pointer_set_t *visited_nodes;\n \n+/* Visited stmts by walk_use_def_chains function because it's called\n+   recursively.  */\n+static struct pointer_set_t *visited_stmts;\n+\n static bitmap_obstack ipa_obstack;\n \n+/* Static functions from this file that are used \n+   before being defined.  */\n+static unsigned int look_for_casts (tree lhs ATTRIBUTE_UNUSED, tree);\n+static bool is_cast_from_non_pointer (tree, tree, void *);\n+\n /* Get the name of TYPE or return the string \"<UNNAMED>\".  */\n static char*\n get_name_of_type (tree type)\n@@ -622,10 +624,15 @@ count_stars (tree* type_ptr)\n }\n \n enum cast_type {\n-  CT_UP,\n-  CT_DOWN,\n-  CT_SIDEWAYS,\n-  CT_USELESS\n+  CT_UP = 0x1,\n+  CT_DOWN = 0x2,\n+  CT_SIDEWAYS = 0x4,\n+  CT_USELESS = 0x8,\n+  CT_FROM_P_BAD = 0x10,\n+  CT_FROM_NON_P = 0x20,\n+  CT_TO_NON_INTER = 0x40,\n+  CT_FROM_MALLOC = 0x80,\n+  CT_NO_CAST = 0x100\n };\n \n /* Check the cast FROM_TYPE to TO_TYPE.  This function requires that\n@@ -648,17 +655,54 @@ check_cast_type (tree to_type, tree from_type)\n   return CT_SIDEWAYS;\n }     \n \n+/* This function returns non-zero if VAR is result of call \n+   to malloc function.  */\n+\n+static bool\n+is_malloc_result (tree var)\n+{\n+  tree def_stmt;\n+  tree rhs;\n+  int flags;\n+\n+  if (!var)\n+    return false;\n+  \n+  if (SSA_NAME_IS_DEFAULT_DEF (var))\n+    return false;\n+\n+  def_stmt = SSA_NAME_DEF_STMT (var);\n+  \n+  if (TREE_CODE (def_stmt) != GIMPLE_MODIFY_STMT)\n+    return false;\n+\n+  if (var != GIMPLE_STMT_OPERAND (def_stmt, 0))\n+    return false;\n+\n+  rhs = get_call_expr_in (def_stmt);\n+\n+  if (!rhs)\n+    return false;\n+\n+  flags = call_expr_flags (rhs);\n+    \n+  return ((flags & ECF_MALLOC) != 0);\n+\n+}\n+\n /* Check a cast FROM this variable, TO_TYPE.  Mark the escaping types\n-   if appropriate.  */ \n-static void\n+   if appropriate. Returns cast_type as detected.  */\n+ \n+static enum cast_type\n check_cast (tree to_type, tree from) \n {\n   tree from_type = get_canon_type (TREE_TYPE (from), false, false);\n   bool to_interesting_type, from_interesting_type;\n+  enum cast_type cast = CT_NO_CAST;\n \n   to_type = get_canon_type (to_type, false, false);\n   if (!from_type || !to_type || from_type == to_type)\n-    return;\n+    return cast;\n \n   to_interesting_type = \n     ipa_type_escape_star_count_of_interesting_type (to_type) >= 0;\n@@ -674,7 +718,8 @@ check_cast (tree to_type, tree from)\n \t   both sides get marked as escaping.  Downcasts are not\n \t   interesting here because if type is marked as escaping, all\n \t   of its subtypes escape.  */\n-\tswitch (check_cast_type (to_type, from_type)) \n+\tcast = check_cast_type (to_type, from_type);\n+\tswitch (cast) \n \t  {\n \t  case CT_UP:\n \t  case CT_USELESS:\n@@ -685,17 +730,288 @@ check_cast (tree to_type, tree from)\n \t    mark_type (to_type, FULL_ESCAPE);\n \t    mark_type (from_type, FULL_ESCAPE);\n \t    break;\n+\n+\t  default:\n+\t    break;\n \t  }\n       }\n     else\n       {\n-\t/* If this is a cast from the local that is a result from a\n-\t   call to malloc, do not mark the cast as bad.  */\n-\tif (DECL_P (from) && !bitmap_bit_p (results_of_malloc, DECL_UID (from)))\n-\t  mark_type (to_type, FULL_ESCAPE);\n+\t/* This code excludes two cases from marking as escaped:\n+\t   \n+\t1. if this is a cast of index of array of structures/unions\n+\tthat happens before accessing array element, we should not \n+\tmark it as escaped.\n+\t2. if this is a cast from the local that is a result from a\n+\tcall to malloc, do not mark the cast as bad.  \n+\n+\t*/\n+\t\n+\tif (POINTER_TYPE_P (to_type) && !POINTER_TYPE_P (from_type))\n+\t  cast = CT_FROM_NON_P;\n+\telse if (TREE_CODE (from) == SSA_NAME \n+\t\t && is_malloc_result (from))\n+\t  cast = CT_FROM_MALLOC;\n+\telse\n+\t  {\n+\t    cast = CT_FROM_P_BAD;\n+\t    mark_type (to_type, FULL_ESCAPE);\n+\t  }\n       }\n   else if (from_interesting_type)\n-    mark_type (from_type, FULL_ESCAPE);\n+    {\n+      mark_type (from_type, FULL_ESCAPE);\n+      cast = CT_TO_NON_INTER;\n+    }\n+\n+  return cast;\n+}\n+\n+typedef struct cast \n+{\n+  int type;\n+  tree stmt;\n+}cast_t;\n+\n+/* This function is a callback for walk_tree called from \n+   is_cast_from_non_pointer. The data->type is set to be:\n+\n+   0      - if there is no cast\n+   number - the number of casts from non-pointer type\n+   -1     - if there is a cast that makes the type to escape\n+\n+   If data->type = number, then data->stmt will contain the \n+   last casting stmt met in traversing.  */\n+\n+static tree\n+is_cast_from_non_pointer_1 (tree *tp, int *walk_subtrees, void *data)\n+{\n+  tree def_stmt = *tp;\n+\n+\n+  if (pointer_set_insert (visited_stmts, def_stmt))\n+    {\n+      *walk_subtrees = 0;\n+      return NULL;\n+    }\n+  \n+  switch (TREE_CODE (def_stmt))\n+    {\n+    case GIMPLE_MODIFY_STMT:\n+      {\n+\tuse_operand_p use_p; \n+\tssa_op_iter iter;\n+\ttree lhs = GIMPLE_STMT_OPERAND (def_stmt, 0);\n+\ttree rhs = GIMPLE_STMT_OPERAND (def_stmt, 1);\n+\n+        unsigned int cast = look_for_casts (lhs, rhs);\n+\t/* Check that only one cast happened, and it's of \n+\t   non-pointer type.  */\n+\tif ((cast & CT_FROM_NON_P) == (CT_FROM_NON_P) \n+\t    && (cast & ~(CT_FROM_NON_P)) == 0)\n+\t  {\n+\t    ((cast_t *)data)->stmt = def_stmt;\n+\t    ((cast_t *)data)->type++;\n+\n+\t    FOR_EACH_SSA_USE_OPERAND (use_p, def_stmt, iter, SSA_OP_ALL_USES)\n+\t      {\n+\t\twalk_use_def_chains (USE_FROM_PTR (use_p), is_cast_from_non_pointer, \n+\t\t\t\t     data, false);\n+\t\tif (((cast_t*)data)->type == -1)\n+\t\t  return def_stmt;\n+\t      }\n+\t  }\n+\n+\t/* Check that there is no cast, or cast is not harmful. */\n+\telse if ((cast & CT_NO_CAST) == (CT_NO_CAST)\n+\t\t || (cast & CT_DOWN) == (CT_DOWN)\n+\t\t || (cast & CT_UP) == (CT_UP)\n+\t\t || (cast & CT_USELESS) == (CT_USELESS)\n+\t\t || (cast & CT_FROM_MALLOC) == (CT_FROM_MALLOC))\n+\t  {\n+\t    FOR_EACH_SSA_USE_OPERAND (use_p, def_stmt, iter, SSA_OP_ALL_USES)\n+\t      {\n+\t\twalk_use_def_chains (USE_FROM_PTR (use_p), is_cast_from_non_pointer, \n+\t\t\t\t     data, false);\n+\t\tif (((cast_t*)data)->type == -1)\n+\t\t  return def_stmt;\n+\t      }\t    \n+\t  }\n+\n+\t/* The cast is harmful.  */\n+\telse\n+\t  {\n+\t    ((cast_t *)data)->type = -1;\n+\t    return def_stmt;\n+\t  }\n+\n+\t*walk_subtrees = 0;\n+      }     \n+      break;\n+\n+    default:\n+      {\n+\t*walk_subtrees = 0;\n+\tbreak;\n+      }\n+    }\n+\n+  return NULL;\n+}\n+\n+/* This function is a callback for walk_use_def_chains function called \n+   from is_array_access_through_pointer_and_index.  */\n+\n+static bool\n+is_cast_from_non_pointer (tree var, tree def_stmt, void *data)\n+{\n+\n+  if (!def_stmt || !var)\n+    return false;\n+  \n+  if (TREE_CODE (def_stmt) == PHI_NODE)\n+    return false;\n+\n+  if (SSA_NAME_IS_DEFAULT_DEF (var))\n+      return false;\n+\n+  walk_tree (&def_stmt, is_cast_from_non_pointer_1, data, NULL);\n+  if (((cast_t*)data)->type == -1)\n+    return true;\n+  \n+  return false;\n+}\n+\n+/* When array element a_p[i] is accessed through the pointer a_p \n+   and index i, it's translated into the following sequence\n+   in gimple:\n+\n+  i.1_5 = (unsigned int) i_1;\n+  D.1605_6 = i.1_5 * 16;\n+  D.1606_7 = (struct str_t *) D.1605_6;\n+  a_p.2_8 = a_p;\n+  D.1608_9 = D.1606_7 + a_p.2_8;\n+\n+  OP0 and OP1 are of the same pointer types and stand for \n+  D.1606_7 and a_p.2_8 or vise versa.\n+\n+  This function checks that:\n+\n+  1. one of OP0 and OP1 (D.1606_7) has passed only one cast from \n+  non-pointer type (D.1606_7 = (struct str_t *) D.1605_6;).\n+\n+  2. one of OP0 and OP1 which has passed the cast from \n+  non-pointer type (D.1606_7), is actually generated by multiplication of \n+  index by size of type to which both OP0 and OP1 point to\n+  (in this case D.1605_6 = i.1_5 * 16; ).\n+\n+  3. an address of def of the var to which was made cast (D.1605_6) \n+  was not taken.(How can it happen?)\n+\n+  The following items are checked implicitly by the end of algorithm:\n+\n+  4. one of OP0 and OP1 (a_p.2_8) have never been cast \n+  (because if it was cast to pointer type, its type, that is also \n+  the type of OP0 and OP1, will be marked as escaped during \n+  analysis of casting stmt (when check_cast() is called \n+  from scan_for_refs for this stmt)).   \n+\n+  5. defs of OP0 and OP1 are not passed into externally visible function\n+  (because if they are passed then their type, that is also the type of OP0\n+  and OP1, will be marked and escaped during check_call function called from \n+  scan_for_refs with call stmt).\n+\n+  In total, 1-5 guaranty that it's an access to array by pointer and index. \n+\n+*/\n+\n+static bool\n+is_array_access_through_pointer_and_index (tree op0, tree op1)\n+{\n+  tree base, offset, offset_cast_stmt;\n+  tree before_cast, before_cast_def_stmt;\n+  cast_t op0_cast, op1_cast;\n+\n+  /* Check 1.  */\n+\n+  /* Init data for walk_use_def_chains function.  */\n+  op0_cast.type = op1_cast.type = 0;\n+  op0_cast.stmt = op1_cast.stmt = NULL;\n+\n+  visited_stmts = pointer_set_create ();\n+  walk_use_def_chains (op0, is_cast_from_non_pointer,(void *)(&op0_cast), false);\n+  pointer_set_destroy (visited_stmts);\n+\n+  visited_stmts = pointer_set_create ();  \n+  walk_use_def_chains (op1, is_cast_from_non_pointer,(void *)(&op1_cast), false);\n+  pointer_set_destroy (visited_stmts);\n+\n+  if (op0_cast.type == 1 && op1_cast.type == 0)\n+    {\n+      base = op1;\n+      offset = op0;\n+      offset_cast_stmt = op0_cast.stmt;\n+    }\n+  else if (op0_cast.type == 0 && op1_cast.type == 1)\n+    {\n+      base = op0;\n+      offset = op1;      \n+      offset_cast_stmt = op1_cast.stmt;\n+    }\n+  else\n+    return false;\n+\n+  /* Check 2.  \n+     offset_cast_stmt is of the form: \n+     D.1606_7 = (struct str_t *) D.1605_6;  */\n+\n+  before_cast = SINGLE_SSA_TREE_OPERAND (offset_cast_stmt, SSA_OP_USE);\n+  if (!before_cast)\n+    return false;\n+  \n+  if (SSA_NAME_IS_DEFAULT_DEF(before_cast))\n+    return false;\n+  \n+  before_cast_def_stmt = SSA_NAME_DEF_STMT (before_cast);\n+  if (!before_cast_def_stmt)\n+    return false;\n+\n+  /* before_cast_def_stmt should be of the form:\n+     D.1605_6 = i.1_5 * 16; */\n+  \n+  if (TREE_CODE (before_cast_def_stmt) == GIMPLE_MODIFY_STMT)\n+    {\n+      tree lhs = GIMPLE_STMT_OPERAND (before_cast_def_stmt,0);\n+      tree rhs = GIMPLE_STMT_OPERAND (before_cast_def_stmt,1);\n+\n+      /* We expect temporary here.  */\n+      if (!is_gimple_reg (lhs))\t\n+\treturn false;\n+\n+      if (TREE_CODE (rhs) == MULT_EXPR)\n+\t{\n+\t  tree arg0 = TREE_OPERAND (rhs, 0);\n+\t  tree arg1 = TREE_OPERAND (rhs, 1);\n+\t  tree unit_size = \n+\t    TYPE_SIZE_UNIT (TREE_TYPE (TYPE_MAIN_VARIANT (TREE_TYPE (op0))));\n+\n+\t  if (!(CONSTANT_CLASS_P (arg0) \n+\t      && simple_cst_equal (arg0,unit_size))\n+\t      && !(CONSTANT_CLASS_P (arg1) \n+\t      && simple_cst_equal (arg1,unit_size)))\n+\t    return false;\t      \t\t   \n+\t}\n+      else\n+\treturn false;\n+    }\n+  else\n+    return false;\n+\n+  /* Check 3.\n+     check that address of D.1605_6 was not taken.\n+     FIXME: if D.1605_6 is gimple reg than it cannot be addressable.  */\n+\n+  return true;\n }\n \n /* Register the parameter and return types of function FN.  The type\n@@ -808,9 +1124,9 @@ check_tree (tree t)\n   if ((TREE_CODE (t) == EXC_PTR_EXPR) || (TREE_CODE (t) == FILTER_EXPR))\n     return;\n \n-  while (TREE_CODE (t) == REALPART_EXPR \n-\t || TREE_CODE (t) == IMAGPART_EXPR\n-\t || handled_component_p (t))\n+  /* We want to catch here also REALPART_EXPR and IMAGEPART_EXPR,\n+     but they already included in handled_component_p.  */\n+  while (handled_component_p (t))\n     {\n       if (TREE_CODE (t) == ARRAY_REF)\n \tcheck_operand (TREE_OPERAND (t, 1));\n@@ -873,7 +1189,7 @@ mark_interesting_addressof (tree to_type, tree from_type)\n \t\t\t to_uid, \n \t\t\t (splay_tree_value)type_map);\n     }\n-  bitmap_set_bit (type_map, TYPE_UID (to_type));\n+  bitmap_set_bit (type_map, TYPE_UID (from_type)); \n }\n \n /* Scan tree T to see if there are any addresses taken in within T.  */\n@@ -912,29 +1228,41 @@ look_for_address_of (tree t)\n /* Scan tree T to see if there are any casts within it.\n    LHS Is the LHS of the expression involving the cast.  */\n \n-static void \n-look_for_casts (tree lhs __attribute__((unused)), tree t)\n+static unsigned int \n+look_for_casts (tree lhs ATTRIBUTE_UNUSED, tree t)\n {\n+  unsigned int cast = 0;\n+\n+\n   if (is_gimple_cast (t) || TREE_CODE (t) == VIEW_CONVERT_EXPR)\n     {\n       tree castfromvar = TREE_OPERAND (t, 0);\n-      check_cast (TREE_TYPE (t), castfromvar);\n+      cast = cast | check_cast (TREE_TYPE (t), castfromvar);\n     }\n-  else\n-    while (handled_component_p (t))\n-      {\n-\tt = TREE_OPERAND (t, 0);\n-\tif (TREE_CODE (t) == VIEW_CONVERT_EXPR)\n-\t  {\n-\t    /* This may be some part of a component ref.\n-\t       IE it may be a.b.VIEW_CONVERT_EXPR<weird_type>(c).d, AFAIK.\n-\t       castfromref will give you a.b.c, not a. */\n-\t    tree castfromref = TREE_OPERAND (t, 0);\n-\t    check_cast (TREE_TYPE (t), castfromref);\n-\t  }\n-\telse if (TREE_CODE (t) == COMPONENT_REF)\n-\t  get_canon_type (TREE_TYPE (TREE_OPERAND (t, 1)), false, false);\n-      }\n+  else if (TREE_CODE (t) == COMPONENT_REF\n+\t   || TREE_CODE (t) == INDIRECT_REF\n+\t   || TREE_CODE (t) == BIT_FIELD_REF)\n+    {\n+      tree base = get_base_address (t);\n+      while (t != base)\n+\t{\n+\t  t = TREE_OPERAND (t, 0);\n+\t  if (TREE_CODE (t) == VIEW_CONVERT_EXPR)\n+\t    {\n+\t      /* This may be some part of a component ref.\n+\t\t IE it may be a.b.VIEW_CONVERT_EXPR<weird_type>(c).d, AFAIK.\n+\t\t castfromref will give you a.b.c, not a. */\n+\t      tree castfromref = TREE_OPERAND (t, 0);\n+\t      cast = cast | check_cast (TREE_TYPE (t), castfromref);\n+\t    }\n+\t  else if (TREE_CODE (t) == COMPONENT_REF)\n+\t    get_canon_type (TREE_TYPE (TREE_OPERAND (t, 1)), false, false);\n+\t}\n+    } \n+\n+  if (!cast)\n+    cast = CT_NO_CAST;\n+  return cast;\n } \n \n /* Check to see if T is a read or address of operation on a static var\n@@ -1007,10 +1335,9 @@ get_asm_expr_operands (tree stmt)\n    this is either an indirect call, a call outside the compilation\n    unit.  */\n \n-static bool\n+static void\n check_call (tree call_expr) \n {\n-  int flags = call_expr_flags(call_expr);\n   tree operand;\n   tree callee_t = get_callee_fndecl (call_expr);\n   struct cgraph_node* callee;\n@@ -1118,7 +1445,6 @@ check_call (tree call_expr)\n \t  mark_interesting_type (type, EXPOSED_PARAMETER);\n \t}\n     }\n-  return (flags & ECF_MALLOC);\n }\n \n /* CODE is the operation on OP0 and OP1.  OP0 is the operand that we\n@@ -1128,18 +1454,39 @@ okay_pointer_operation (enum tree_code code, tree op0, tree op1)\n {\n   tree op0type = TYPE_MAIN_VARIANT (TREE_TYPE (op0));\n   tree op1type = TYPE_MAIN_VARIANT (TREE_TYPE (op1));\n-  if (POINTER_TYPE_P (op1type))\n-    return false;\n+\n   switch (code)\n     {\n     case MULT_EXPR:\n-    case PLUS_EXPR:\n+      /* Multiplication does not change alignment.  */\n+      return true;\n+      break;\n     case MINUS_EXPR:\n-      /* TODO: Handle multiples of op0 size as well */\n-      if (operand_equal_p (size_in_bytes (op0type), op1, 0))\n-\treturn true;\n-      /* fallthrough */\n+    case PLUS_EXPR:\n+      {\n+\tif (POINTER_TYPE_P (op1type)\n+\t    && TREE_CODE (op0) == SSA_NAME \n+\t    && TREE_CODE (op1) == SSA_NAME \n+\t    && is_array_access_through_pointer_and_index (op0, op1))\n+\t  return true;\n+\telse\n+\t  {\n+\t    tree size_of_op0_points_to = TYPE_SIZE_UNIT (TREE_TYPE (op0type));\n+\t    \n+\t    if (CONSTANT_CLASS_P (op1)\n+\t\t&& size_of_op0_points_to\n+\t\t&& multiple_of_p (TREE_TYPE (size_of_op0_points_to), \n+\t\t\t\t  op1, size_of_op0_points_to))\n+\t      return true;\n \n+\t    if (CONSTANT_CLASS_P (op0) \n+\t\t&& size_of_op0_points_to\n+\t\t&& multiple_of_p (TREE_TYPE (size_of_op0_points_to), \n+\t\t\t\t  op0, size_of_op0_points_to))\n+\t      return true;\t    \n+\t  }\n+      }\n+      break;\n     default:\n       return false;\n     }\n@@ -1256,12 +1603,7 @@ scan_for_refs (tree *tp, int *walk_subtrees, void *data)\n \t\t/* If this is a call to malloc, squirrel away the\n \t\t   result so we do mark the resulting cast as being\n \t\t   bad.  */\n-\t\tif (check_call (rhs))\n-\t\t  {\n-\t\t    if (TREE_CODE (lhs) == SSA_NAME)\n-\t\t      lhs = SSA_NAME_VAR (lhs);\n-\t\t    bitmap_set_bit (results_of_malloc, DECL_UID (lhs));\n-\t\t  }\n+\t\tcheck_call (rhs);\n \t\tbreak;\n \t      default:\n \t\tbreak;\n@@ -1307,7 +1649,6 @@ ipa_init (void)\n   global_types_exposed_parameter = BITMAP_ALLOC (&ipa_obstack);\n   global_types_full_escape = BITMAP_ALLOC (&ipa_obstack);\n   global_types_seen = BITMAP_ALLOC (&ipa_obstack);\n-  results_of_malloc = BITMAP_ALLOC (&ipa_obstack);\n \n   uid_to_canon_type = splay_tree_new (splay_tree_compare_ints, 0, 0);\n   all_canon_types = splay_tree_new (compare_type_brand, 0, 0);\n@@ -1810,7 +2151,6 @@ type_escape_execute (void)\n   BITMAP_FREE (global_types_exposed_parameter);\n   BITMAP_FREE (been_there_done_that);\n   BITMAP_FREE (bitmap_tmp);\n-  BITMAP_FREE (results_of_malloc);\n   return 0;\n }\n "}, {"sha": "b090770b61fcaa3e0296eb1977286a70e28e21c4", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e702949e192f587c42c52f2731502169fcb869/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e702949e192f587c42c52f2731502169fcb869/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d4e702949e192f587c42c52f2731502169fcb869", "patch": "@@ -4454,7 +4454,7 @@ enum operand_equal_flag\n };\n \n extern int operand_equal_p (tree, tree, unsigned int);\n-\n+extern int multiple_of_p (tree, tree, tree);\n extern tree omit_one_operand (tree, tree, tree);\n extern tree omit_two_operands (tree, tree, tree, tree);\n extern tree invert_truthvalue (tree);"}]}