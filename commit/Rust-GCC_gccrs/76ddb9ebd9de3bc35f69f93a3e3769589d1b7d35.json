{"sha": "76ddb9ebd9de3bc35f69f93a3e3769589d1b7d35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZkZGI5ZWJkOWRlM2JjMzVmNjlmOTNhM2UzNzY5NTg5ZDFiN2QzNQ==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2019-05-07T22:25:05Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2019-05-07T22:25:05Z"}, "message": "rs6000: Remove reload leftovers\n\nThere are a few things left in the rs6000 port that are unused now\nthat we do not support old reload anymore.  This removes those.\n\n\n\t* config/rs6000/rs6000-protos.h (rs6000_legitimize_reload_address_ptr):\n\tDelete declaration.\n\t* config/rs6000/rs6000.c (rs6000_legitimize_reload_address): Delete.\n\t(rs6000_debug_legitimize_reload_address): Delete.\n\t(rs6000_legitimize_reload_address_ptr): Delete.\n\t(rs6000_option_override_internal): Adjust.\n\t(mem_operand_gpr): Adjust comment.\n\t(legitimate_lo_sum_address_p): Ditto.\n\t(rs6000_legitimize_reload_address): Delete.\n\t(rs6000_debug_legitimize_reload_address): Delete.\n\t* config/rs6000/rs6000.h (LEGITIMIZE_RELOAD_ADDRESS): Delete.\n\nFrom-SVN: r270983", "tree": {"sha": "52fc76fff77a3eb6b4d1315ea3daf816fd8741a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52fc76fff77a3eb6b4d1315ea3daf816fd8741a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76ddb9ebd9de3bc35f69f93a3e3769589d1b7d35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76ddb9ebd9de3bc35f69f93a3e3769589d1b7d35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76ddb9ebd9de3bc35f69f93a3e3769589d1b7d35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76ddb9ebd9de3bc35f69f93a3e3769589d1b7d35/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5d30228e2b9837e66827acfe95c9a74c90c1d42b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d30228e2b9837e66827acfe95c9a74c90c1d42b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d30228e2b9837e66827acfe95c9a74c90c1d42b"}], "stats": {"total": 337, "additions": 17, "deletions": 320}, "files": [{"sha": "4a98ec84c7b9e318b3fd73d1501caa900a8e759e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76ddb9ebd9de3bc35f69f93a3e3769589d1b7d35/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76ddb9ebd9de3bc35f69f93a3e3769589d1b7d35/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76ddb9ebd9de3bc35f69f93a3e3769589d1b7d35", "patch": "@@ -1,3 +1,17 @@\n+2019-05-07  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_legitimize_reload_address_ptr):\n+\tDelete declaration.\n+\t* config/rs6000/rs6000.c (rs6000_legitimize_reload_address): Delete.\n+\t(rs6000_debug_legitimize_reload_address): Delete.\n+\t(rs6000_legitimize_reload_address_ptr): Delete.\n+\t(rs6000_option_override_internal): Adjust.\n+\t(mem_operand_gpr): Adjust comment.\n+\t(legitimate_lo_sum_address_p): Ditto.\n+\t(rs6000_legitimize_reload_address): Delete.\n+\t(rs6000_debug_legitimize_reload_address): Delete.\n+\t* config/rs6000/rs6000.h (LEGITIMIZE_RELOAD_ADDRESS): Delete.\n+\n 2019-05-07  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n \n \tPR target/89765"}, {"sha": "8466368ce4bf992bf188657cada501c4db01bb1e", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76ddb9ebd9de3bc35f69f93a3e3769589d1b7d35/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76ddb9ebd9de3bc35f69f93a3e3769589d1b7d35/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=76ddb9ebd9de3bc35f69f93a3e3769589d1b7d35", "patch": "@@ -137,8 +137,6 @@ extern void rs6000_emit_le_vsx_permute (rtx, rtx, machine_mode);\n extern void rs6000_emit_le_vsx_move (rtx, rtx, machine_mode);\n extern bool valid_sf_si_move (rtx, rtx, machine_mode);\n extern void rs6000_emit_move (rtx, rtx, machine_mode);\n-extern rtx (*rs6000_legitimize_reload_address_ptr) (rtx, machine_mode,\n-\t\t\t\t\t\t    int, int, int, int *);\n extern bool rs6000_legitimate_offset_address_p (machine_mode, rtx,\n \t\t\t\t\t\tbool, bool);\n extern void rs6000_output_tlsargs (rtx *);"}, {"sha": "5d5765d89b21873b3f921f5e682ab6d57e33dcb1", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 3, "deletions": 302, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76ddb9ebd9de3bc35f69f93a3e3769589d1b7d35/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76ddb9ebd9de3bc35f69f93a3e3769589d1b7d35/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=76ddb9ebd9de3bc35f69f93a3e3769589d1b7d35", "patch": "@@ -1368,10 +1368,6 @@ static rtx rs6000_darwin64_record_arg (CUMULATIVE_ARGS *, const_tree,\n static void macho_branch_islands (void);\n static tree get_prev_label (tree);\n #endif\n-static rtx rs6000_legitimize_reload_address (rtx, machine_mode, int, int,\n-\t\t\t\t\t     int, int *);\n-static rtx rs6000_debug_legitimize_reload_address (rtx, machine_mode, int,\n-\t\t\t\t\t\t   int, int, int *);\n static bool rs6000_mode_dependent_address (const_rtx);\n static bool rs6000_debug_mode_dependent_address (const_rtx);\n static bool rs6000_offsettable_memref_p (rtx, machine_mode, bool);\n@@ -1392,10 +1388,6 @@ static bool rs6000_debug_can_change_mode_class (machine_mode,\n static bool rs6000_save_toc_in_prologue_p (void);\n static rtx rs6000_internal_arg_pointer (void);\n \n-rtx (*rs6000_legitimize_reload_address_ptr) (rtx, machine_mode, int, int,\n-\t\t\t\t\t     int, int *)\n-  = rs6000_legitimize_reload_address;\n-\n static bool (*rs6000_mode_dependent_address_ptr) (const_rtx)\n   = rs6000_mode_dependent_address;\n \n@@ -4422,8 +4414,6 @@ rs6000_option_override_internal (bool global_init_p)\n \t    = rs6000_debug_can_change_mode_class;\n \t  rs6000_preferred_reload_class_ptr\n \t    = rs6000_debug_preferred_reload_class;\n-\t  rs6000_legitimize_reload_address_ptr\n-\t    = rs6000_debug_legitimize_reload_address;\n \t  rs6000_mode_dependent_address_ptr\n \t    = rs6000_debug_mode_dependent_address;\n \t}\n@@ -7663,14 +7653,10 @@ address_offset (rtx op)\n \n    Accept direct, indexed, offset, lo_sum and tocref.  Since this is\n    a constraint function we know the operand has satisfied a suitable\n-   memory predicate.  Also accept some odd rtl generated by reload\n-   (see rs6000_legitimize_reload_address for various forms).  It is\n-   important that reload rtl be accepted by appropriate constraints\n-   but not by the operand predicate.\n+   memory predicate.\n \n    Offsetting a lo_sum should not be allowed, except where we know by\n-   alignment that a 32k boundary is not crossed, but see the ???\n-   comment in rs6000_legitimize_reload_address.  Note that by\n+   alignment that a 32k boundary is not crossed.  Note that by\n    \"offsetting\" here we mean a further offset to access parts of the\n    MEM.  It's fine to have a lo_sum where the inner address is offset\n    from a sym, since the same sym+offset will appear in the high part\n@@ -8133,8 +8119,7 @@ legitimate_lo_sum_address_p (machine_mode mode, rtx x, int strict)\n \t function says opposite.  In most cases, LRA through different\n \t transformations can generate correct code for address reloads.\n \t It cannot manage only some LO_SUM cases.  So we need to add\n-\t code analogous to one in rs6000_legitimize_reload_address for\n-\t LOW_SUM here saying that some addresses are still valid.  */\n+\t code here saying that some addresses are still valid.  */\n       large_toc_ok = (lra_in_progress && TARGET_CMODEL != CMODEL_SMALL\n \t\t      && small_toc_ref (x, VOIDmode));\n       if (TARGET_TOC && ! large_toc_ok)\n@@ -8912,290 +8897,6 @@ use_toc_relative_ref (rtx sym, machine_mode mode)\n \t      && GET_MODE_SIZE (mode) <= POWERPC64_TOC_POINTER_ALIGNMENT));\n }\n \n-/* Our implementation of LEGITIMIZE_RELOAD_ADDRESS.  Returns a value to\n-   replace the input X, or the original X if no replacement is called for.\n-   The output parameter *WIN is 1 if the calling macro should goto WIN,\n-   0 if it should not.\n-\n-   For RS/6000, we wish to handle large displacements off a base\n-   register by splitting the addend across an addiu/addis and the mem insn.\n-   This cuts number of extra insns needed from 3 to 1.\n-\n-   On Darwin, we use this to generate code for floating point constants.\n-   A movsf_low is generated so we wind up with 2 instructions rather than 3.\n-   The Darwin code is inside #if TARGET_MACHO because only then are the\n-   machopic_* functions defined.  */\n-static rtx\n-rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n-\t\t\t\t  int opnum, int type,\n-\t\t\t\t  int ind_levels ATTRIBUTE_UNUSED, int *win)\n-{\n-  bool reg_offset_p = reg_offset_addressing_ok_p (mode);\n-  bool quad_offset_p = mode_supports_dq_form (mode);\n-\n-  /* Nasty hack for vsx_splat_v2df/v2di load from mem, which takes a\n-     DFmode/DImode MEM.  Ditto for ISA 3.0 vsx_splat_v4sf/v4si.  */\n-  if (reg_offset_p\n-      && opnum == 1\n-      && ((mode == DFmode && recog_data.operand_mode[0] == V2DFmode)\n-\t  || (mode == DImode && recog_data.operand_mode[0] == V2DImode)\n-\t  || (mode == SFmode && recog_data.operand_mode[0] == V4SFmode\n-\t      && TARGET_P9_VECTOR)\n-\t  || (mode == SImode && recog_data.operand_mode[0] == V4SImode\n-\t      && TARGET_P9_VECTOR)))\n-    reg_offset_p = false;\n-\n-  /* We must recognize output that we have already generated ourselves.  */\n-  if (GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 0)) == PLUS\n-      && REG_P (XEXP (XEXP (x, 0), 0))\n-      && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n-      && CONST_INT_P (XEXP (x, 1)))\n-    {\n-      if (TARGET_DEBUG_ADDR)\n-\t{\n-\t  fprintf (stderr, \"\\nlegitimize_reload_address push_reload #1:\\n\");\n-\t  debug_rtx (x);\n-\t}\n-      push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n-\t\t   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n-\t\t   opnum, (enum reload_type) type);\n-      *win = 1;\n-      return x;\n-    }\n-\n-  /* Likewise for (lo_sum (high ...) ...) output we have generated.  */\n-  if (GET_CODE (x) == LO_SUM\n-      && GET_CODE (XEXP (x, 0)) == HIGH)\n-    {\n-      if (TARGET_DEBUG_ADDR)\n-\t{\n-\t  fprintf (stderr, \"\\nlegitimize_reload_address push_reload #2:\\n\");\n-\t  debug_rtx (x);\n-\t}\n-      push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n-\t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n-\t\t   opnum, (enum reload_type) type);\n-      *win = 1;\n-      return x;\n-    }\n-\n-#if TARGET_MACHO\n-  if (DEFAULT_ABI == ABI_DARWIN && flag_pic\n-      && GET_CODE (x) == LO_SUM\n-      && GET_CODE (XEXP (x, 0)) == PLUS\n-      && XEXP (XEXP (x, 0), 0) == pic_offset_table_rtx\n-      && GET_CODE (XEXP (XEXP (x, 0), 1)) == HIGH\n-      && XEXP (XEXP (XEXP (x, 0), 1), 0) == XEXP (x, 1)\n-      && machopic_operand_p (XEXP (x, 1)))\n-    {\n-      /* Result of previous invocation of this function on Darwin\n-\t floating point constant.  */\n-      push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n-\t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n-\t\t   opnum, (enum reload_type) type);\n-      *win = 1;\n-      return x;\n-    }\n-#endif\n-\n-  if (TARGET_CMODEL != CMODEL_SMALL\n-      && reg_offset_p\n-      && !quad_offset_p\n-      && small_toc_ref (x, VOIDmode))\n-    {\n-      rtx hi = gen_rtx_HIGH (Pmode, copy_rtx (x));\n-      x = gen_rtx_LO_SUM (Pmode, hi, x);\n-      if (TARGET_DEBUG_ADDR)\n-\t{\n-\t  fprintf (stderr, \"\\nlegitimize_reload_address push_reload #3:\\n\");\n-\t  debug_rtx (x);\n-\t}\n-      push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n-\t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n-\t\t   opnum, (enum reload_type) type);\n-      *win = 1;\n-      return x;\n-    }\n-\n-  if (GET_CODE (x) == PLUS\n-      && REG_P (XEXP (x, 0))\n-      && HARD_REGISTER_P (XEXP (x, 0))\n-      && INT_REG_OK_FOR_BASE_P (XEXP (x, 0), 1)\n-      && CONST_INT_P (XEXP (x, 1))\n-      && reg_offset_p\n-      && (quad_offset_p || !VECTOR_MODE_P (mode) || VECTOR_MEM_NONE_P (mode)))\n-    {\n-      HOST_WIDE_INT val = INTVAL (XEXP (x, 1));\n-      HOST_WIDE_INT low = ((val & 0xffff) ^ 0x8000) - 0x8000;\n-      HOST_WIDE_INT high\n-\t= (((val - low) & 0xffffffff) ^ 0x80000000) - 0x80000000;\n-\n-      /* Check for 32-bit overflow or quad addresses with one of the\n-\t four least significant bits set.  */\n-      if (high + low != val\n-\t  || (quad_offset_p && (low & 0xf)))\n-\t{\n-\t  *win = 0;\n-\t  return x;\n-\t}\n-\n-      /* Reload the high part into a base reg; leave the low part\n-\t in the mem directly.  */\n-\n-      x = gen_rtx_PLUS (GET_MODE (x),\n-\t\t\tgen_rtx_PLUS (GET_MODE (x), XEXP (x, 0),\n-\t\t\t\t      GEN_INT (high)),\n-\t\t\tGEN_INT (low));\n-\n-      if (TARGET_DEBUG_ADDR)\n-\t{\n-\t  fprintf (stderr, \"\\nlegitimize_reload_address push_reload #4:\\n\");\n-\t  debug_rtx (x);\n-\t}\n-      push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n-\t\t   BASE_REG_CLASS, GET_MODE (x), VOIDmode, 0, 0,\n-\t\t   opnum, (enum reload_type) type);\n-      *win = 1;\n-      return x;\n-    }\n-\n-  if (SYMBOL_REF_P (x)\n-      && reg_offset_p\n-      && !quad_offset_p\n-      && (!VECTOR_MODE_P (mode) || VECTOR_MEM_NONE_P (mode))\n-#if TARGET_MACHO\n-      && DEFAULT_ABI == ABI_DARWIN\n-      && (flag_pic || MACHO_DYNAMIC_NO_PIC_P)\n-      && machopic_symbol_defined_p (x)\n-#else\n-      && DEFAULT_ABI == ABI_V4\n-      && !flag_pic\n-#endif\n-      /* Don't do this for TFmode or TDmode, since the result isn't offsettable.\n-\t The same goes for DImode without 64-bit gprs and DFmode and DDmode\n-\t without fprs.\n-\t ??? Assume floating point reg based on mode?  This assumption is\n-\t violated by eg. powerpc-linux -m32 compile of gcc.dg/pr28796-2.c\n-\t where reload ends up doing a DFmode load of a constant from\n-\t mem using two gprs.  Unfortunately, at this point reload\n-\t hasn't yet selected regs so poking around in reload data\n-\t won't help and even if we could figure out the regs reliably,\n-\t we'd still want to allow this transformation when the mem is\n-\t naturally aligned.  Since we say the address is good here, we\n-\t can't disable offsets from LO_SUMs in mem_operand_gpr.\n-\t FIXME: Allow offset from lo_sum for other modes too, when\n-\t mem is sufficiently aligned.\n-\n-\t Also disallow this if the type can go in VMX/Altivec registers, since\n-\t those registers do not have d-form (reg+offset) address modes.  */\n-      && !reg_addr[mode].scalar_in_vmx_p\n-      && mode != TFmode\n-      && mode != TDmode\n-      && mode != IFmode\n-      && mode != KFmode\n-      && (mode != TImode || !TARGET_VSX)\n-      && mode != PTImode\n-      && (mode != DImode || TARGET_POWERPC64)\n-      && ((mode != DFmode && mode != DDmode) || TARGET_POWERPC64\n-\t  || TARGET_HARD_FLOAT))\n-    {\n-#if TARGET_MACHO\n-      if (flag_pic)\n-\t{\n-\t  rtx offset = machopic_gen_offset (x);\n-\t  x = gen_rtx_LO_SUM (GET_MODE (x),\n-\t\tgen_rtx_PLUS (Pmode, pic_offset_table_rtx,\n-\t\t  gen_rtx_HIGH (Pmode, offset)), offset);\n-\t}\n-      else\n-#endif\n-\tx = gen_rtx_LO_SUM (GET_MODE (x),\n-\t      gen_rtx_HIGH (Pmode, x), x);\n-\n-      if (TARGET_DEBUG_ADDR)\n-\t{\n-\t  fprintf (stderr, \"\\nlegitimize_reload_address push_reload #5:\\n\");\n-\t  debug_rtx (x);\n-\t}\n-      push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n-\t\t   BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n-\t\t   opnum, (enum reload_type) type);\n-      *win = 1;\n-      return x;\n-    }\n-\n-  /* Reload an offset address wrapped by an AND that represents the\n-     masking of the lower bits.  Strip the outer AND and let reload\n-     convert the offset address into an indirect address.  For VSX,\n-     force reload to create the address with an AND in a separate\n-     register, because we can't guarantee an altivec register will\n-     be used.  */\n-  if (VECTOR_MEM_ALTIVEC_P (mode)\n-      && GET_CODE (x) == AND\n-      && GET_CODE (XEXP (x, 0)) == PLUS\n-      && REG_P (XEXP (XEXP (x, 0), 0))\n-      && CONST_INT_P (XEXP (XEXP (x, 0), 1))\n-      && CONST_INT_P (XEXP (x, 1))\n-      && INTVAL (XEXP (x, 1)) == -16)\n-    {\n-      x = XEXP (x, 0);\n-      *win = 1;\n-      return x;\n-    }\n-\n-  if (TARGET_TOC\n-      && reg_offset_p\n-      && !quad_offset_p\n-      && SYMBOL_REF_P (x)\n-      && use_toc_relative_ref (x, mode))\n-    {\n-      x = create_TOC_reference (x, NULL_RTX);\n-      if (TARGET_CMODEL != CMODEL_SMALL)\n-\t{\n-\t  if (TARGET_DEBUG_ADDR)\n-\t    {\n-\t      fprintf (stderr, \"\\nlegitimize_reload_address push_reload #6:\\n\");\n-\t      debug_rtx (x);\n-\t    }\n-\t  push_reload (XEXP (x, 0), NULL_RTX, &XEXP (x, 0), NULL,\n-\t\t       BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\n-\t\t       opnum, (enum reload_type) type);\n-\t}\n-      *win = 1;\n-      return x;\n-    }\n-  *win = 0;\n-  return x;\n-}\n-\n-/* Debug version of rs6000_legitimize_reload_address.  */\n-static rtx\n-rs6000_debug_legitimize_reload_address (rtx x, machine_mode mode,\n-\t\t\t\t\tint opnum, int type,\n-\t\t\t\t\tint ind_levels, int *win)\n-{\n-  rtx ret = rs6000_legitimize_reload_address (x, mode, opnum, type,\n-\t\t\t\t\t      ind_levels, win);\n-  fprintf (stderr,\n-\t   \"\\nrs6000_legitimize_reload_address: mode = %s, opnum = %d, \"\n-\t   \"type = %d, ind_levels = %d, win = %d, original addr:\\n\",\n-\t   GET_MODE_NAME (mode), opnum, type, ind_levels, *win);\n-  debug_rtx (x);\n-\n-  if (x == ret)\n-    fprintf (stderr, \"Same address returned\\n\");\n-  else if (!ret)\n-    fprintf (stderr, \"NULL returned\\n\");\n-  else\n-    {\n-      fprintf (stderr, \"New address:\\n\");\n-      debug_rtx (ret);\n-    }\n-\n-  return ret;\n-}\n-\n /* TARGET_LEGITIMATE_ADDRESS_P recognizes an RTL expression\n    that is a valid memory address for an instruction.\n    The MODE argument is the machine mode for the MEM expression"}, {"sha": "14a9e199bc892ec55fd2b792f85c77aba657c9cb", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76ddb9ebd9de3bc35f69f93a3e3769589d1b7d35/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76ddb9ebd9de3bc35f69f93a3e3769589d1b7d35/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=76ddb9ebd9de3bc35f69f93a3e3769589d1b7d35", "patch": "@@ -1741,22 +1741,6 @@ typedef struct rs6000_args\n    ((((unsigned HOST_WIDE_INT)GET_MODE_MASK (mode)) + 1) >> 1))\n \n \f\n-/* Try a machine-dependent way of reloading an illegitimate address\n-   operand.  If we find one, push the reload and jump to WIN.  This\n-   macro is used in only one place: `find_reloads_address' in reload.c.\n-\n-   Implemented on rs6000 by rs6000_legitimize_reload_address.\n-   Note that (X) is evaluated twice; this is safe in current usage.  */\n-\n-#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)\t     \\\n-do {\t\t\t\t\t\t\t\t\t     \\\n-  int win;\t\t\t\t\t\t\t\t     \\\n-  (X) = rs6000_legitimize_reload_address_ptr ((X), (MODE), (OPNUM),\t     \\\n-\t\t\t(int)(TYPE), (IND_LEVELS), &win);\t\t     \\\n-  if ( win )\t\t\t\t\t\t\t\t     \\\n-    goto WIN;\t\t\t\t\t\t\t\t     \\\n-} while (0)\n-\n #define FIND_BASE_TERM rs6000_find_base_term\n \f\n /* The register number of the register used to address a table of"}]}