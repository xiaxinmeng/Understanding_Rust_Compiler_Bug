{"sha": "d677a8b6818b1682bfccae40cceb7264b53c1018", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY3N2E4YjY4MThiMTY4MmJmY2NhZTQwY2NlYjcyNjRiNTNjMTAxOA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-05-22T17:45:35Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-05-22T17:45:35Z"}, "message": "PR c/85623 - strncmp() warns about attribute 'nonstring' incorrectly in -Wstringop-overflow\n\ngcc/ChangeLog:\n\n\tPR c/85623\n\t* calls.c (maybe_warn_nonstring_arg): Use string length to set\n\tor ajust the presumed bound on an operation to avoid unnecessary\n\twarnings.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c/85623\n\t* c-c++-common/attr-nonstring-3.c: Adjust.\n\t* c-c++-common/attr-nonstring-4.c: Adjust.\n\t* c-c++-common/attr-nonstring-6.c: New test.\n\nFrom-SVN: r260541", "tree": {"sha": "8bcb9d057f75ddb91c415569f50789f538e99968", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bcb9d057f75ddb91c415569f50789f538e99968"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d677a8b6818b1682bfccae40cceb7264b53c1018", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d677a8b6818b1682bfccae40cceb7264b53c1018", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d677a8b6818b1682bfccae40cceb7264b53c1018", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d677a8b6818b1682bfccae40cceb7264b53c1018/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9b56ec1111632f4e9a47ba5388d7a65c19593f71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b56ec1111632f4e9a47ba5388d7a65c19593f71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b56ec1111632f4e9a47ba5388d7a65c19593f71"}], "stats": {"total": 287, "additions": 274, "deletions": 13}, "files": [{"sha": "3dc05662b7bd39881508e5d4112f366fcaabf850", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d677a8b6818b1682bfccae40cceb7264b53c1018/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d677a8b6818b1682bfccae40cceb7264b53c1018/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d677a8b6818b1682bfccae40cceb7264b53c1018", "patch": "@@ -40,6 +40,13 @@\n \t* config/aarch64/predicates.md (aarch64_reg_zero_or_fp_zero):\n \tNew predicate.\n \n+2018-05-22  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/85623\n+\t* calls.c (maybe_warn_nonstring_arg): Use string length to set\n+\tor ajust the presumed bound on an operation to avoid unnecessary\n+\twarnings.\n+\n 2018-05-22  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/85826"}, {"sha": "d2eecf139e0ac01c1e4248b7d8caffc2c31fb7b0", "filename": "gcc/calls.c", "status": "modified", "additions": 66, "deletions": 7, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d677a8b6818b1682bfccae40cceb7264b53c1018/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d677a8b6818b1682bfccae40cceb7264b53c1018/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=d677a8b6818b1682bfccae40cceb7264b53c1018", "patch": "@@ -55,6 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"builtins.h\"\n+#include \"gimple-fold.h\"\n \n /* Like PREFERRED_STACK_BOUNDARY but in units of bytes, not bits.  */\n #define STACK_BYTES (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)\n@@ -1616,15 +1617,36 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n   /* The bound argument to a bounded string function like strncpy.  */\n   tree bound = NULL_TREE;\n \n+  /* The range of lengths of a string argument to one of the comparison\n+     functions.  If the length is less than the bound it is used instead.  */\n+  tree lenrng[2] = { NULL_TREE, NULL_TREE };\n+\n   /* It's safe to call \"bounded\" string functions with a non-string\n      argument since the functions provide an explicit bound for this\n      purpose.  */\n   switch (DECL_FUNCTION_CODE (fndecl))\n     {\n-    case BUILT_IN_STPNCPY:\n-    case BUILT_IN_STPNCPY_CHK:\n+    case BUILT_IN_STRCMP:\n     case BUILT_IN_STRNCMP:\n     case BUILT_IN_STRNCASECMP:\n+      {\n+\t/* For these, if one argument refers to one or more of a set\n+\t   of string constants or arrays of known size, determine\n+\t   the range of their known or possible lengths and use it\n+\t   conservatively as the bound for the unbounded function,\n+\t   and to adjust the range of the bound of the bounded ones.  */\n+\tunsigned stride = with_bounds ? 2 : 1;\n+\tfor (unsigned argno = 0; argno < nargs && !*lenrng; argno += stride)\n+\t  {\n+\t    tree arg = CALL_EXPR_ARG (exp, argno);\n+\t    if (!get_attr_nonstring_decl (arg))\n+\t      get_range_strlen (arg, lenrng);\n+\t  }\n+      }\n+      /* Fall through.  */\n+\n+    case BUILT_IN_STPNCPY:\n+    case BUILT_IN_STPNCPY_CHK:\n     case BUILT_IN_STRNCPY:\n     case BUILT_IN_STRNCPY_CHK:\n       {\n@@ -1651,6 +1673,33 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n   if (bound)\n     get_size_range (bound, bndrng);\n \n+  if (*lenrng)\n+    {\n+      /* Add one for the nul.  */\n+      lenrng[0] = const_binop (PLUS_EXPR, TREE_TYPE (lenrng[0]),\n+\t\t\t       lenrng[0], size_one_node);\n+      lenrng[1] = const_binop (PLUS_EXPR, TREE_TYPE (lenrng[1]),\n+\t\t\t       lenrng[1], size_one_node);\n+\n+      if (!bndrng[0])\n+\t{\n+\t  /* Conservatively use the upper bound of the lengths for\n+\t     both the lower and the upper bound of the operation.  */\n+\t  bndrng[0] = lenrng[1];\n+\t  bndrng[1] = lenrng[1];\n+\t  bound = void_type_node;\n+\t}\n+      else\n+\t{\n+\t  /* Replace the bound on the oparation with the upper bound\n+\t     of the length of the string if the latter is smaller.  */\n+\t  if (tree_int_cst_lt (lenrng[1], bndrng[0]))\n+\t    bndrng[0] = lenrng[1];\n+\t  else if (tree_int_cst_lt (lenrng[1], bndrng[1]))\n+\t    bndrng[1] = lenrng[1];\n+\t}\n+    }\n+\n   /* Iterate over the built-in function's formal arguments and check\n      each const char* against the actual argument.  If the actual\n      argument is declared attribute non-string issue a warning unless\n@@ -1693,18 +1742,28 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n \n       tree type = TREE_TYPE (decl);\n \n+      /* The maximum number of array elements accessed.  */\n       offset_int wibnd = 0;\n       if (bndrng[0])\n \twibnd = wi::to_offset (bndrng[0]);\n \n+      /* Size of the array.  */\n       offset_int asize = wibnd;\n \n+      /* Determine the array size.  For arrays of unknown bound and\n+\t pointers reset BOUND to trigger the appropriate warning.  */\n       if (TREE_CODE (type) == ARRAY_TYPE)\n-\tif (tree arrbnd = TYPE_DOMAIN (type))\n-\t  {\n-\t    if ((arrbnd = TYPE_MAX_VALUE (arrbnd)))\n-\t      asize = wi::to_offset (arrbnd) + 1;\n-\t  }\n+\t{\n+\t  if (tree arrbnd = TYPE_DOMAIN (type))\n+\t    {\n+\t      if ((arrbnd = TYPE_MAX_VALUE (arrbnd)))\n+\t\tasize = wi::to_offset (arrbnd) + 1;\n+\t    }\n+\t  else if (bound == void_type_node)\n+\t    bound = NULL_TREE;\n+\t}\n+      else if (bound == void_type_node)\n+\tbound = NULL_TREE;\n \n       location_t loc = EXPR_LOCATION (exp);\n "}, {"sha": "f21a1fb5bcd1940acae23d940ae4ac82e03b71a8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d677a8b6818b1682bfccae40cceb7264b53c1018/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d677a8b6818b1682bfccae40cceb7264b53c1018/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d677a8b6818b1682bfccae40cceb7264b53c1018", "patch": "@@ -4,6 +4,13 @@\n \t* gcc.target/aarch64/ldp_stp_7.c: New.\n \t* gcc.target/aarch64/ldp_stp_8.c: New.\n \n+2018-05-22  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/85623\n+\t* c-c++-common/attr-nonstring-3.c: Adjust.\n+\t* c-c++-common/attr-nonstring-4.c: Adjust.\n+\t* c-c++-common/attr-nonstring-6.c: New test.\n+\n 2018-05-22  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/85826"}, {"sha": "a54e73a3285b5f4c3d235d60e10743c6a8808b23", "filename": "gcc/testsuite/c-c++-common/attr-nonstring-3.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d677a8b6818b1682bfccae40cceb7264b53c1018/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d677a8b6818b1682bfccae40cceb7264b53c1018/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-3.c?ref=d677a8b6818b1682bfccae40cceb7264b53c1018", "patch": "@@ -47,15 +47,18 @@ char* strndup (const char*, size_t);\n \n #define NONSTRING __attribute__ ((nonstring))\n \n-char str[4];\n+/* STR needs to be bigger than ARR to trigger warnings, otherwise\n+   since STR must be a string, using both in a string function\n+   can be assumed to be safe even if ARR isn't nul-terminated.  */\n+char str[5];\n char arr[4] NONSTRING;\n \n char *ptr;\n char *parr NONSTRING;\n \n struct MemArrays\n {\n-  char str[4];\n+  char str[5];\n   char arr[4] NONSTRING;\n   char *parr NONSTRING;\n };"}, {"sha": "597bbb32c25d334d28f822943e5e11acc621e518", "filename": "gcc/testsuite/c-c++-common/attr-nonstring-4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d677a8b6818b1682bfccae40cceb7264b53c1018/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d677a8b6818b1682bfccae40cceb7264b53c1018/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-4.c?ref=d677a8b6818b1682bfccae40cceb7264b53c1018", "patch": "@@ -37,23 +37,23 @@ int warn_strcmp_cst_2 (void)\n \n int warn_strncmp_cst_1 (void)\n {\n-  return strncmp (\"bar\", ar5, X);   /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n+  return strncmp (\"12345\", ar5, X);   /* { dg-warning \"argument 2 declared attribute .nonstring.\" } */\n }\n \n int warn_strncmp_cst_2 (void)\n {\n-  return strncmp (ar5, \"foo\", X);   /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n+  return strncmp (ar5, \"12345\", X);   /* { dg-warning \"argument 1 declared attribute .nonstring.\" } */\n }\n \n \n int nowarn_strncmp_cst_1 (void)\n {\n-  return strncmp (\"bar\", ar5, N);\n+  return strncmp (\"12345\", ar5, N);\n }\n \n int nowarn_strncmp_cst_2 (void)\n {\n-  return strncmp (ar5, \"foo\", N);\n+  return strncmp (ar5, \"12345\", N);\n }\n \n "}, {"sha": "19ceaacf39c24cd89e7487673f573b9c997b066d", "filename": "gcc/testsuite/c-c++-common/attr-nonstring-6.c", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d677a8b6818b1682bfccae40cceb7264b53c1018/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d677a8b6818b1682bfccae40cceb7264b53c1018/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-nonstring-6.c?ref=d677a8b6818b1682bfccae40cceb7264b53c1018", "patch": "@@ -0,0 +1,185 @@\n+/* PR 85623 - strncmp() warns about attribute 'nonstring' incorrectly\n+   in -Wstringop-overflow\n+  { dg-do compile }\n+  { dg-options \"-O2 -Wstringop-overflow -ftrack-macro-expansion=0\" } */\n+\n+#include \"../gcc.dg/range.h\"\n+\n+#if __cplusplus\n+extern \"C\" {\n+#endif\n+\n+extern int strcmp (const char*, const char*);\n+extern int strncmp (const char*, const char*, size_t);\n+extern int strncasecmp (const char*, const char*, size_t);\n+\n+extern size_t strspn (const char*, const char*);\n+extern size_t strcspn (const char*, const char*);\n+\n+#if __cplusplus\n+}\n+#endif\n+\n+#define S26 \"0123456789abcdefghijklmnopqrstuvwxyz\"\n+#define S(n) (S26 + sizeof S26 - 1 - (n))\n+\n+char __attribute__ ((nonstring)) a3[3];\n+char __attribute__ ((nonstring)) a5[5];\n+\n+void sink (int);\n+\n+#define T(call)   sink (call)\n+\n+void test_strcmp_cst (void)\n+{\n+  /* Verify that no warning is issued for strcmp() calls with a non-string\n+     array argument when the other argument is a string whose length is\n+     less than the size of the array.  Because the function stops reading\n+     at the first nul character there is no chance that it will read past\n+     the end of the array.  */\n+  T (strcmp (S (0), a3));\n+  T (strcmp (S (1), a3));\n+  T (strcmp (S (2), a3));\n+  /* The following reads a3[3].  */\n+  T (strcmp (S (3), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  /* The following also reads past the end of a3.  */\n+  T (strcmp (S (9), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+\n+  T (strcmp (a3, S (0)));\n+  T (strcmp (a3, S (1)));\n+  T (strcmp (a3, S (2)));\n+  T (strcmp (a3, S (3)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strcmp (a3, S (9)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+}\n+\n+\n+void test_strcmp_range (const char *s)\n+{\n+  s = signed_value () < 0 ? S (0) : S (1);\n+  T (strcmp (a3, s));\n+\n+  s = signed_value () < 0 ? S (0) : S (2);\n+  T (strcmp (a3, s));\n+\n+  s = signed_value () < 0 ? S (0) : S (3);\n+  T (strcmp (a3, s));       /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+\n+  s = signed_value () < 0 ? S (1) : S (2);\n+  T (strcmp (a3, s));\n+\n+  s = signed_value () < 0 ? S (1) : S (3);\n+  T (strcmp (a3, s));       /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+\n+  s = signed_value () < 0 ? S (3) : S (4);\n+  T (strcmp (a3, s));       /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+}\n+\n+\n+void test_strncmp_cst (void)\n+{\n+  T (strncmp (S (0), a3, 1));\n+  T (strncmp (S (1), a3, 2));\n+  T (strncmp (S (2), a3, 3));\n+  T (strncmp (S (3), a3, 3));\n+  T (strncmp (S (3), a3, 4));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+\n+  T (strncmp (S (9), a3, 3));\n+  T (strncmp (S (9), a3, 4));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strncmp (S (9), a3, 5));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+\n+  T (strncmp (a3, S (0), 1));\n+  T (strncmp (a3, S (1), 2));\n+  T (strncmp (a3, S (2), 3));\n+  T (strncmp (a3, S (3), 3));\n+  T (strncmp (a3, S (3), 4));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+\n+  T (strncmp (a3, S (9), 3));\n+  T (strncmp (a3, S (9), 4));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strncmp (a3, S (9), 5));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+}\n+\n+void test_strncmp_range (const char *s)\n+{\n+  T (strncmp (a3, S (2), UR (0, 3)));\n+  T (strncmp (a3, S (2), UR (1, 4)));\n+  T (strncmp (a3, S (2), UR (2, 5)));\n+  T (strncmp (a3, S (2), UR (3, 6)));\n+  T (strncmp (a3, S (2), UR (4, 7)));\n+\n+  T (strncmp (a3, S (5), UR (0, 3)));\n+  T (strncmp (a3, S (5), UR (1, 4)));\n+  T (strncmp (a3, S (5), UR (2, 5)));\n+  T (strncmp (a3, S (5), UR (3, 6)));\n+  T (strncmp (a3, S (5), UR (4, 7)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strncmp (a3, S (5), UR (7, 9)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+\n+  s = signed_value () < 0 ? S (0) : S (1);\n+  T (strncmp (a3, s, UR (1, 3)));\n+  T (strncmp (a3, s, UR (2, 5)));\n+\n+  s = signed_value () < 0 ? S (2) : S (5);\n+  T (strncmp (a3, s, UR (1, 3)));\n+\n+  s = signed_value () < 0 ? S (2) : S (5);\n+  T (strncmp (a3, s, UR (1, 4)));\n+  T (strncmp (a3, s, UR (2, 5)));\n+  T (strncmp (a3, s, UR (3, 6)));\n+  T (strncmp (a3, s, UR (4, 7)));       /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+}\n+\n+void test_strncasecmp (void)\n+{\n+  T (strncasecmp (S (0), a3, 1));\n+  T (strncasecmp (S (1), a3, 2));\n+  T (strncasecmp (S (2), a3, 3));\n+  T (strncasecmp (S (3), a3, 3));\n+  T (strncasecmp (S (3), a3, 4));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+\n+  T (strncasecmp (S (9), a3, 3));\n+  T (strncasecmp (S (9), a3, 4));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strncasecmp (S (9), a3, 5));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+\n+  T (strncasecmp (a3, S (0), 1));\n+  T (strncasecmp (a3, S (1), 2));\n+  T (strncasecmp (a3, S (2), 3));\n+  T (strncasecmp (a3, S (3), 3));\n+  T (strncasecmp (a3, S (3), 4));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+\n+  T (strncasecmp (a3, S (9), 3));\n+  T (strncasecmp (a3, S (9), 4));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strncasecmp (a3, S (9), 5));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+}\n+\n+void test_strspn (void)\n+{\n+  /* strspn must traverse all characters in the second argument except\n+     when the first string is empty. */\n+  T (strspn (S (0), a3));\n+  T (strspn (S (1), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strspn (S (2), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strspn (S (3), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strspn (S (9), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+\n+  /* Similarly, strspn must traverse all characters in the first argument\n+     except when the second string is empty. */\n+  T (strspn (a3, S (0)));\n+  T (strspn (a3, S (1)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strspn (a3, S (2)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strspn (a3, S (3)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strspn (a3, S (9)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+}\n+\n+void test_strcspn (void)\n+{\n+  T (strcspn (S (0), a3));\n+  T (strcspn (S (1), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strcspn (S (2), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strcspn (S (3), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strcspn (S (9), a3));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+\n+  T (strcspn (a3, S (0)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strcspn (a3, S (1)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strcspn (a3, S (2)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strcspn (a3, S (3)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+  T (strcspn (a3, S (9)));   /* { dg-warning \"\\\\\\[-Wstringop-overflow\" } */\n+}"}]}