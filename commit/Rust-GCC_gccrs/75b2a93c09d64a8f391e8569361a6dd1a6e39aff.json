{"sha": "75b2a93c09d64a8f391e8569361a6dd1a6e39aff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzViMmE5M2MwOWQ2NGE4ZjM5MWU4NTY5MzYxYTZkZDFhNmUzOWFmZg==", "commit": {"author": {"name": "Osku Salerma", "email": "osku@iki.fi", "date": "2003-06-09T22:31:33Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2003-06-09T22:31:33Z"}, "message": "Patch from Osku Salerma\n* c-format.c (check_format_string, get_constant): New.\n(handle_format_attribute, handle_format_arg_attribute,\ndecode_format_attr): Change to use above functions.\n\nFrom-SVN: r67680", "tree": {"sha": "a990e8de90595d90f1f5ec5c1b9e19168f8e0a42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a990e8de90595d90f1f5ec5c1b9e19168f8e0a42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75b2a93c09d64a8f391e8569361a6dd1a6e39aff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75b2a93c09d64a8f391e8569361a6dd1a6e39aff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75b2a93c09d64a8f391e8569361a6dd1a6e39aff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75b2a93c09d64a8f391e8569361a6dd1a6e39aff/comments", "author": null, "committer": null, "parents": [{"sha": "71ed1fdbff1ed83a74186db1d9e4b55008762d20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71ed1fdbff1ed83a74186db1d9e4b55008762d20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71ed1fdbff1ed83a74186db1d9e4b55008762d20"}], "stats": {"total": 146, "additions": 78, "deletions": 68}, "files": [{"sha": "231dccddbf68f87fffffea25c42bc573cc22b199", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b2a93c09d64a8f391e8569361a6dd1a6e39aff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b2a93c09d64a8f391e8569361a6dd1a6e39aff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75b2a93c09d64a8f391e8569361a6dd1a6e39aff", "patch": "@@ -1,3 +1,9 @@\n+2003-06-19  Osku Salerma  <osku@iki.fi>\n+\n+\t* c-format.c (check_format_string, get_constant): New.\n+\t(handle_format_attribute, handle_format_arg_attribute,\n+\tdecode_format_attr): Change to use above functions.\n+\n 2003-06-09  Richard Henderson  <rth@redhat.com>\n \n         * stmt.c (expand_asm_operands): Re-word warning."}, {"sha": "1199667c5f005aa1a4f999a835b0a3b218faa593", "filename": "gcc/c-format.c", "status": "modified", "additions": 72, "deletions": 68, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75b2a93c09d64a8f391e8569361a6dd1a6e39aff/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75b2a93c09d64a8f391e8569361a6dd1a6e39aff/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=75b2a93c09d64a8f391e8569361a6dd1a6e39aff", "patch": "@@ -71,6 +71,11 @@ static bool decode_format_attr\t\tPARAMS ((tree,\n \t\t\t\t\t\t function_format_info *, int));\n static enum format_type decode_format_type\tPARAMS ((const char *));\n \n+static bool check_format_string (tree argument,\n+\t\t\t\t unsigned HOST_WIDE_INT format_num,\n+\t\t\t\t int flags, bool *no_add_attrs);\n+static bool get_constant (tree expr, unsigned HOST_WIDE_INT *value,\n+\t\t\t  int validated_p);\n \n \n /* Handle a \"format_arg\" attribute; arguments as in\n@@ -86,46 +91,20 @@ handle_format_arg_attribute (node, name, args, flags, no_add_attrs)\n   tree type = *node;\n   tree format_num_expr = TREE_VALUE (args);\n   unsigned HOST_WIDE_INT format_num;\n-  unsigned HOST_WIDE_INT arg_num;\n   tree argument;\n \n-  /* Strip any conversions from the first arg number and verify it\n-     is a constant.  */\n-  while (TREE_CODE (format_num_expr) == NOP_EXPR\n-\t || TREE_CODE (format_num_expr) == CONVERT_EXPR\n-\t || TREE_CODE (format_num_expr) == NON_LVALUE_EXPR)\n-    format_num_expr = TREE_OPERAND (format_num_expr, 0);\n-\n-  if (TREE_CODE (format_num_expr) != INTEGER_CST\n-      || TREE_INT_CST_HIGH (format_num_expr) != 0)\n+  if (!get_constant (format_num_expr, &format_num, 0))\n     {\n       error (\"format string has invalid operand number\");\n       *no_add_attrs = true;\n       return NULL_TREE;\n     }\n \n-  format_num = TREE_INT_CST_LOW (format_num_expr);\n-\n-  /* If a parameter list is specified, verify that the format_num\n-     argument is actually a string, in case the format attribute\n-     is in error.  */\n   argument = TYPE_ARG_TYPES (type);\n   if (argument)\n     {\n-      for (arg_num = 1; argument != 0 && arg_num != format_num;\n-\t   ++arg_num, argument = TREE_CHAIN (argument))\n-\t;\n-\n-      if (! argument\n-\t  || TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE\n-\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (argument)))\n-\t      != char_type_node))\n-\t{\n-\t  if (!(flags & (int) ATTR_FLAG_BUILT_IN))\n-\t    error (\"format string arg not a string type\");\n-\t  *no_add_attrs = true;\n-\t  return NULL_TREE;\n-\t}\n+      if (!check_format_string (argument, format_num, flags, no_add_attrs))\n+\treturn NULL_TREE;\n     }\n \n   if (TREE_CODE (TREE_TYPE (type)) != POINTER_TYPE\n@@ -141,6 +120,57 @@ handle_format_arg_attribute (node, name, args, flags, no_add_attrs)\n   return NULL_TREE;\n }\n \n+/* Verify that the format_num argument is actually a string, in case\n+   the format attribute is in error.  */\n+bool\n+check_format_string (tree argument, unsigned HOST_WIDE_INT format_num,\n+\t\t     int flags, bool *no_add_attrs)\n+{\n+  unsigned HOST_WIDE_INT i;\n+\n+  for (i = 1; i != format_num; i++)\n+    {\n+      if (argument == 0)\n+\tbreak;\n+      argument = TREE_CHAIN (argument);\n+    }\n+\n+  if (!argument\n+      || TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE\n+      || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (argument)))\n+\t  != char_type_node))\n+    {\n+      if (!(flags & (int) ATTR_FLAG_BUILT_IN))\n+\terror (\"format string arg not a string type\");\n+      *no_add_attrs = true;\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Strip any conversions from the expression, verify it is a constant,\n+   and store its value. If validated_p is true, abort on errors.\n+   Returns true on success, false otherwise. */\n+bool\n+get_constant(tree expr, unsigned HOST_WIDE_INT *value, int validated_p)\n+{\n+  while (TREE_CODE (expr) == NOP_EXPR\n+\t || TREE_CODE (expr) == CONVERT_EXPR\n+\t || TREE_CODE (expr) == NON_LVALUE_EXPR)\n+    expr = TREE_OPERAND (expr, 0);\n+\n+  if (TREE_CODE (expr) != INTEGER_CST || TREE_INT_CST_HIGH (expr) != 0)\n+    {\n+      if (validated_p)\n+\tabort ();\n+      return false;\n+    }\n+\n+  *value = TREE_INT_CST_LOW (expr);\n+\n+  return true;\n+}\n \n /* Decode the arguments to a \"format\" attribute into a function_format_info\n    structure.  It is already known that the list is of the right length.\n@@ -182,31 +212,18 @@ decode_format_attr (args, info, validated_p)\n \t}\n     }\n \n-  /* Strip any conversions from the string index and first arg number\n-     and verify they are constants.  */\n-  while (TREE_CODE (format_num_expr) == NOP_EXPR\n-\t || TREE_CODE (format_num_expr) == CONVERT_EXPR\n-\t || TREE_CODE (format_num_expr) == NON_LVALUE_EXPR)\n-    format_num_expr = TREE_OPERAND (format_num_expr, 0);\n-\n-  while (TREE_CODE (first_arg_num_expr) == NOP_EXPR\n-\t || TREE_CODE (first_arg_num_expr) == CONVERT_EXPR\n-\t || TREE_CODE (first_arg_num_expr) == NON_LVALUE_EXPR)\n-    first_arg_num_expr = TREE_OPERAND (first_arg_num_expr, 0);\n-\n-  if (TREE_CODE (format_num_expr) != INTEGER_CST\n-      || TREE_INT_CST_HIGH (format_num_expr) != 0\n-      || TREE_CODE (first_arg_num_expr) != INTEGER_CST\n-      || TREE_INT_CST_HIGH (first_arg_num_expr) != 0)\n+  if (!get_constant (format_num_expr, &info->format_num, validated_p))\n     {\n-      if (validated_p)\n-\tabort ();\n       error (\"format string has invalid operand number\");\n       return false;\n     }\n \n-  info->format_num = TREE_INT_CST_LOW (format_num_expr);\n-  info->first_arg_num = TREE_INT_CST_LOW (first_arg_num_expr);\n+  if (!get_constant (first_arg_num_expr, &info->first_arg_num, validated_p))\n+    {\n+      error (\"'...' has invalid operand number\");\n+      return false;\n+    }\n+\n   if (info->first_arg_num != 0 && info->first_arg_num <= info->format_num)\n     {\n       if (validated_p)\n@@ -2363,37 +2380,24 @@ handle_format_attribute (node, name, args, flags, no_add_attrs)\n   tree type = *node;\n   function_format_info info;\n   tree argument;\n-  unsigned HOST_WIDE_INT arg_num;\n \n   if (!decode_format_attr (args, &info, 0))\n     {\n       *no_add_attrs = true;\n       return NULL_TREE;\n     }\n \n-  /* If a parameter list is specified, verify that the format_num\n-     argument is actually a string, in case the format attribute\n-     is in error.  */\n   argument = TYPE_ARG_TYPES (type);\n   if (argument)\n     {\n-      for (arg_num = 1; argument != 0 && arg_num != info.format_num;\n-\t   ++arg_num, argument = TREE_CHAIN (argument))\n-\t;\n-\n-      if (! argument\n-\t  || TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE\n-\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (argument)))\n-\t      != char_type_node))\n-\t{\n-\t  if (!(flags & (int) ATTR_FLAG_BUILT_IN))\n-\t    error (\"format string arg not a string type\");\n-\t  *no_add_attrs = true;\n-\t  return NULL_TREE;\n-\t}\n+      if (!check_format_string (argument, info.format_num, flags,\n+\t\t\t\tno_add_attrs))\n+\treturn NULL_TREE;\n \n-      else if (info.first_arg_num != 0)\n+      if (info.first_arg_num != 0)\n \t{\n+\t  unsigned HOST_WIDE_INT arg_num = 1;\n+\n \t  /* Verify that first_arg_num points to the last arg,\n \t     the ...  */\n \t  while (argument)"}]}