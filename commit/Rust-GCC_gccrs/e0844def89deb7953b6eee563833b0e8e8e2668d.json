{"sha": "e0844def89deb7953b6eee563833b0e8e8e2668d", "node_id": "C_kwDOANBUbNoAKGUwODQ0ZGVmODlkZWI3OTUzYjZlZWU1NjM4MzNiMGU4ZThlMjY2OGQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-07-06T09:15:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-06T09:15:56Z"}, "message": "Merge #1346\n\n1346: Support self paths r=philberty a=philberty\n\nThis adds support for the self path which is used in two different\r\ncontexts. One where it refers to the self parameter within methods\r\nthe other is where it can refer to the crate module scope.\r\n\r\nHandling self has some limitations where it must be the first\r\nthe segment in the path or be a single segment path for example see:\r\n\r\n```\r\n  struct foo;\r\n\r\n  fn test() {\r\n    crate::self::foo;\r\n  }\r\n```\r\n\r\nErrors with (rustc 1.61):\r\n\r\n```\r\n  Error[E0433]: failed to resolve: `self` in paths can only be used in start position\r\n```\r\n\r\ncrate and super keywords can be chained as expected but self seems to be a special case.\r\n\r\nThe patch here reorders the algorithm to look at the name/type scope first if its the first segment\r\nand handle the lower case self as a special case. If this fails to result in a resolved node we\r\nthen try to look at the module_scope_id hierarchy to handle the case that the previous segments\r\nwere crate or super and finally error out at the end if we failed to resolve the segment. We can\r\nonly error for the first segment as associated paths such as Foo::Bar with Bar being an associated\r\nimpl block item requiring type-resolution.\r\n\r\nFixes #1231 #1227\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "7b5e1dc63abdd67e9e9a1ccf8e76ddeb5e10ab64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b5e1dc63abdd67e9e9a1ccf8e76ddeb5e10ab64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0844def89deb7953b6eee563833b0e8e8e2668d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJixVLMCRBK7hj4Ov3rIwAAlSoIAAPsHBaZNUq2Bdj2UE3VY9d9\n1l19lHb428OTC5Oyv31SQ09XAoY5MIrbNWiVm7/um1/+wwB04bKDq5/ASVDf/Xzs\nySpXaS89sg+oUFgiJpsjNrbbI/DJHE1fvh19wvn3IbktpF674CgH7z6CQlYbHhLo\ngxHC42yzoYh+ORffvqGo3yAlaZgLHJCEo7WqR9ZQzbVIk8wP0xg747Av0hZqj5hK\nDaswIFTc4aDysUVGNIB1gR2fmmy+xNnqw+eU/+j8+qGmW/5CBX+LjOVaq7wNMiyy\naEr/ez9LUf19S6KumlI41Y3WkxcG2swMhZlQ/7zLUvsXDBEpxNVwykXhHJZQ/WY=\n=M4Sl\n-----END PGP SIGNATURE-----\n", "payload": "tree 7b5e1dc63abdd67e9e9a1ccf8e76ddeb5e10ab64\nparent 408b7f87b99c1b9d074787ac279c86319ab00667\nparent f4a5629fb7f6274433005c255bc9baf113856a5d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1657098956 +0000\ncommitter GitHub <noreply@github.com> 1657098956 +0000\n\nMerge #1346\n\n1346: Support self paths r=philberty a=philberty\n\nThis adds support for the self path which is used in two different\r\ncontexts. One where it refers to the self parameter within methods\r\nthe other is where it can refer to the crate module scope.\r\n\r\nHandling self has some limitations where it must be the first\r\nthe segment in the path or be a single segment path for example see:\r\n\r\n```\r\n  struct foo;\r\n\r\n  fn test() {\r\n    crate::self::foo;\r\n  }\r\n```\r\n\r\nErrors with (rustc 1.61):\r\n\r\n```\r\n  Error[E0433]: failed to resolve: `self` in paths can only be used in start position\r\n```\r\n\r\ncrate and super keywords can be chained as expected but self seems to be a special case.\r\n\r\nThe patch here reorders the algorithm to look at the name/type scope first if its the first segment\r\nand handle the lower case self as a special case. If this fails to result in a resolved node we\r\nthen try to look at the module_scope_id hierarchy to handle the case that the previous segments\r\nwere crate or super and finally error out at the end if we failed to resolve the segment. We can\r\nonly error for the first segment as associated paths such as Foo::Bar with Bar being an associated\r\nimpl block item requiring type-resolution.\r\n\r\nFixes #1231 #1227\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0844def89deb7953b6eee563833b0e8e8e2668d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0844def89deb7953b6eee563833b0e8e8e2668d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0844def89deb7953b6eee563833b0e8e8e2668d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "408b7f87b99c1b9d074787ac279c86319ab00667", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/408b7f87b99c1b9d074787ac279c86319ab00667", "html_url": "https://github.com/Rust-GCC/gccrs/commit/408b7f87b99c1b9d074787ac279c86319ab00667"}, {"sha": "f4a5629fb7f6274433005c255bc9baf113856a5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4a5629fb7f6274433005c255bc9baf113856a5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4a5629fb7f6274433005c255bc9baf113856a5d"}], "stats": {"total": 254, "additions": 188, "deletions": 66}, "files": [{"sha": "c6485c07bbaa72c01a56bd699ac1ba853f250b9e", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0844def89deb7953b6eee563833b0e8e8e2668d/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0844def89deb7953b6eee563833b0e8e8e2668d/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=e0844def89deb7953b6eee563833b0e8e8e2668d", "patch": "@@ -50,6 +50,8 @@ class PathIdentSegment\n \n   std::string as_string () const { return segment_name; }\n \n+  Location get_locus () const { return locus; }\n+\n   bool is_super_segment () const { return as_string ().compare (\"super\") == 0; }\n   bool is_crate_segment () const { return as_string ().compare (\"crate\") == 0; }\n   bool is_lower_self () const { return as_string ().compare (\"self\") == 0; }\n@@ -691,6 +693,10 @@ class TypePathSegment\n     return get_ident_segment ().is_super_segment ();\n   }\n   bool is_big_self_seg () const { return get_ident_segment ().is_big_self (); }\n+  bool is_lower_self_seg () const\n+  {\n+    return get_ident_segment ().is_lower_self ();\n+  }\n };\n \n // Segment used in type path with generic args"}, {"sha": "9bd836a5872cc540259aac8f0a78a3bf7832078d", "filename": "gcc/rust/resolve/rust-ast-resolve-path.cc", "status": "modified", "additions": 58, "deletions": 31, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0844def89deb7953b6eee563833b0e8e8e2668d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0844def89deb7953b6eee563833b0e8e8e2668d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc?ref=e0844def89deb7953b6eee563833b0e8e8e2668d", "patch": "@@ -59,6 +59,18 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n       bool is_first_segment = i == 0;\n       resolved_node_id = UNKNOWN_NODEID;\n \n+      bool in_middle_of_path = i > 0;\n+      if (in_middle_of_path && segment.is_lower_self_seg ())\n+\t{\n+\t  // error[E0433]: failed to resolve: `self` in paths can only be used\n+\t  // in start position\n+\t  rust_error_at (segment.get_locus (),\n+\t\t\t \"failed to resolve: %<%s%> in paths can only be used \"\n+\t\t\t \"in start position\",\n+\t\t\t segment.as_string ().c_str ());\n+\t  return;\n+\t}\n+\n       NodeId crate_scope_id = resolver->peek_crate_module_scope ();\n       if (segment.is_crate_path_seg ())\n \t{\n@@ -118,7 +130,43 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n       //\n       // can only use old resolution when previous segment is unkown\n \n-      if (previous_resolved_node_id == module_scope_id)\n+      if (is_first_segment)\n+\t{\n+\t  // name scope first\n+\t  NodeId resolved_node = UNKNOWN_NODEID;\n+\t  const CanonicalPath path\n+\t    = CanonicalPath::new_seg (segment.get_node_id (),\n+\t\t\t\t      ident_seg.as_string ());\n+\t  if (resolver->get_name_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t      resolved_node_id = resolved_node;\n+\t    }\n+\t  // check the type scope\n+\t  else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolver->insert_resolved_type (segment.get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t      resolved_node_id = resolved_node;\n+\t    }\n+\t  else if (segment.is_lower_self_seg ())\n+\t    {\n+\t      module_scope_id = crate_scope_id;\n+\t      previous_resolved_node_id = module_scope_id;\n+\t      resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t      module_scope_id);\n+\t      continue;\n+\t    }\n+\t  else\n+\t    {\n+\t      // no error handling here since we might be able to resolve via\n+\t      // the module hierarchy and handle errors at the end\n+\t    }\n+\t}\n+\n+      if (resolved_node_id == UNKNOWN_NODEID\n+\t  && previous_resolved_node_id == module_scope_id)\n \t{\n \t  Optional<CanonicalPath &> resolved_child\n \t    = mappings->lookup_module_child (module_scope_id,\n@@ -150,43 +198,22 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n \t    }\n \t}\n \n-      if (resolved_node_id == UNKNOWN_NODEID && is_first_segment)\n-\t{\n-\t  // name scope first\n-\t  NodeId resolved_node = UNKNOWN_NODEID;\n-\t  const CanonicalPath path\n-\t    = CanonicalPath::new_seg (segment.get_node_id (),\n-\t\t\t\t      ident_seg.as_string ());\n-\t  if (resolver->get_name_scope ().lookup (path, &resolved_node))\n-\t    {\n-\t      resolver->insert_resolved_name (segment.get_node_id (),\n-\t\t\t\t\t      resolved_node);\n-\t    }\n-\t  // check the type scope\n-\t  else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n-\t    {\n-\t      resolver->insert_resolved_type (segment.get_node_id (),\n-\t\t\t\t\t      resolved_node);\n-\t    }\n-\t  else\n-\t    {\n-\t      rust_error_at (segment.get_locus (),\n-\t\t\t     \"Cannot find path %<%s%> in this scope\",\n-\t\t\t     segment.as_string ().c_str ());\n-\t      return;\n-\t    }\n-\n-\t  resolved_node_id = resolved_node;\n-\t}\n-\n-      if (resolved_node_id != UNKNOWN_NODEID)\n+      bool did_resolve_segment = resolved_node_id != UNKNOWN_NODEID;\n+      if (did_resolve_segment)\n \t{\n \t  if (mappings->node_is_module (resolved_node_id))\n \t    {\n \t      module_scope_id = resolved_node_id;\n \t    }\n \t  previous_resolved_node_id = resolved_node_id;\n \t}\n+      else if (is_first_segment)\n+\t{\n+\t  rust_error_at (segment.get_locus (),\n+\t\t\t \"Cannot find path %<%s%> in this scope\",\n+\t\t\t segment.as_string ().c_str ());\n+\t  return;\n+\t}\n     }\n \n   resolved_node = resolved_node_id;"}, {"sha": "d444e3758cd8d97ab8c87235426edfcfd99e53ca", "filename": "gcc/rust/resolve/rust-ast-resolve-type.cc", "status": "modified", "additions": 55, "deletions": 35, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0844def89deb7953b6eee563833b0e8e8e2668d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0844def89deb7953b6eee563833b0e8e8e2668d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc?ref=e0844def89deb7953b6eee563833b0e8e8e2668d", "patch": "@@ -95,6 +95,18 @@ ResolveRelativeTypePath::go (AST::TypePath &path, NodeId &resolved_node_id)\n       bool is_first_segment = i == 0;\n       resolved_node_id = UNKNOWN_NODEID;\n \n+      bool in_middle_of_path = i > 0;\n+      if (in_middle_of_path && segment->is_lower_self_seg ())\n+\t{\n+\t  // error[E0433]: failed to resolve: `self` in paths can only be used\n+\t  // in start position\n+\t  rust_error_at (segment->get_locus (),\n+\t\t\t \"failed to resolve: %<%s%> in paths can only be used \"\n+\t\t\t \"in start position\",\n+\t\t\t segment->as_string ().c_str ());\n+\t  return false;\n+\t}\n+\n       NodeId crate_scope_id = resolver->peek_crate_module_scope ();\n       if (segment->is_crate_path_seg ())\n \t{\n@@ -129,10 +141,7 @@ ResolveRelativeTypePath::go (AST::TypePath &path, NodeId &resolved_node_id)\n \t      = static_cast<AST::TypePathSegmentGeneric *> (segment.get ());\n \t    if (s->has_generic_args ())\n \t      {\n-\t\tfor (auto &gt : s->get_generic_args ().get_type_args ())\n-\t\t  {\n-\t\t    ResolveType::go (gt.get ());\n-\t\t  }\n+\t\tResolveType::type_resolve_generic_args (s->get_generic_args ());\n \t      }\n \t  }\n \t  break;\n@@ -146,8 +155,39 @@ ResolveRelativeTypePath::go (AST::TypePath &path, NodeId &resolved_node_id)\n \t  break;\n \t}\n \n-      if (previous_resolved_node_id == module_scope_id\n-\t  && path.get_segments ().size () > 1)\n+      if (is_first_segment)\n+\t{\n+\t  // name scope first\n+\t  NodeId resolved_node = UNKNOWN_NODEID;\n+\t  const CanonicalPath path\n+\t    = CanonicalPath::new_seg (segment->get_node_id (),\n+\t\t\t\t      ident_seg.as_string ());\n+\t  if (resolver->get_type_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolver->insert_resolved_type (segment->get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t      resolved_node_id = resolved_node;\n+\t    }\n+\t  else if (resolver->get_name_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolver->insert_resolved_name (segment->get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t      resolved_node_id = resolved_node;\n+\t    }\n+\t  else if (segment->is_lower_self_seg ())\n+\t    {\n+\t      // what is the current crate scope node id?\n+\t      module_scope_id = crate_scope_id;\n+\t      previous_resolved_node_id = module_scope_id;\n+\t      resolver->insert_resolved_name (segment->get_node_id (),\n+\t\t\t\t\t      module_scope_id);\n+\n+\t      continue;\n+\t    }\n+\t}\n+\n+      if (resolved_node_id == UNKNOWN_NODEID\n+\t  && previous_resolved_node_id == module_scope_id)\n \t{\n \t  Optional<CanonicalPath &> resolved_child\n \t    = mappings->lookup_module_child (module_scope_id,\n@@ -179,42 +219,22 @@ ResolveRelativeTypePath::go (AST::TypePath &path, NodeId &resolved_node_id)\n \t    }\n \t}\n \n-      if (resolved_node_id == UNKNOWN_NODEID && is_first_segment)\n-\t{\n-\t  // name scope first\n-\t  NodeId resolved_node = UNKNOWN_NODEID;\n-\t  const CanonicalPath path\n-\t    = CanonicalPath::new_seg (segment->get_node_id (),\n-\t\t\t\t      ident_seg.as_string ());\n-\t  if (resolver->get_type_scope ().lookup (path, &resolved_node))\n-\t    {\n-\t      resolver->insert_resolved_type (segment->get_node_id (),\n-\t\t\t\t\t      resolved_node);\n-\t    }\n-\t  else if (resolver->get_name_scope ().lookup (path, &resolved_node))\n-\t    {\n-\t      resolver->insert_resolved_name (segment->get_node_id (),\n-\t\t\t\t\t      resolved_node);\n-\t    }\n-\t  else\n-\t    {\n-\t      rust_error_at (segment->get_locus (),\n-\t\t\t     \"failed to resolve TypePath: %s in this scope\",\n-\t\t\t     segment->as_string ().c_str ());\n-\t      return false;\n-\t    }\n-\n-\t  resolved_node_id = resolved_node;\n-\t}\n-\n-      if (resolved_node_id != UNKNOWN_NODEID)\n+      bool did_resolve_segment = resolved_node_id != UNKNOWN_NODEID;\n+      if (did_resolve_segment)\n \t{\n \t  if (mappings->node_is_module (resolved_node_id))\n \t    {\n \t      module_scope_id = resolved_node_id;\n \t    }\n \t  previous_resolved_node_id = resolved_node_id;\n \t}\n+      else if (is_first_segment)\n+\t{\n+\t  rust_error_at (segment->get_locus (),\n+\t\t\t \"failed to resolve TypePath: %s in this scope\",\n+\t\t\t segment->as_string ().c_str ());\n+\t  return false;\n+\t}\n     }\n \n   if (resolved_node_id != UNKNOWN_NODEID)"}, {"sha": "425ba848fc049700a19211d8579186c63e4cec49", "filename": "gcc/testsuite/rust/compile/self-path1.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0844def89deb7953b6eee563833b0e8e8e2668d/gcc%2Ftestsuite%2Frust%2Fcompile%2Fself-path1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0844def89deb7953b6eee563833b0e8e8e2668d/gcc%2Ftestsuite%2Frust%2Fcompile%2Fself-path1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fself-path1.rs?ref=e0844def89deb7953b6eee563833b0e8e8e2668d", "patch": "@@ -0,0 +1,12 @@\n+// { dg-additional-options \"-w\" }\n+struct foo;\n+\n+fn bar() -> self::foo {\n+    crate::foo\n+}\n+\n+fn baz() {\n+    let a: foo = self::bar();\n+\n+    crate::bar();\n+}"}, {"sha": "b9b82cae5a6a502a6e6223976f8da8c5b0e7bc7b", "filename": "gcc/testsuite/rust/compile/self-path2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0844def89deb7953b6eee563833b0e8e8e2668d/gcc%2Ftestsuite%2Frust%2Fcompile%2Fself-path2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0844def89deb7953b6eee563833b0e8e8e2668d/gcc%2Ftestsuite%2Frust%2Fcompile%2Fself-path2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fself-path2.rs?ref=e0844def89deb7953b6eee563833b0e8e8e2668d", "patch": "@@ -0,0 +1,21 @@\n+// { dg-additional-options \"-w\" }\n+struct foo;\n+\n+fn bar() -> self::foo {\n+    crate::foo\n+}\n+\n+fn baz() {\n+    let a: foo = self::bar();\n+\n+    crate::bar();\n+\n+    crate::self::foo();\n+    // { dg-error \"failed to resolve: .self. in paths can only be used in start position\" \"\" { target *-*-* } .-1 }\n+}\n+\n+type a = foo;\n+type b = crate::foo;\n+type c = self::foo;\n+type d = crate::self::foo;\n+// { dg-error \"failed to resolve: .self. in paths can only be used in start position\" \"\" { target *-*-* } .-1 }"}, {"sha": "970e86f917a28d35e4ccb3521be7e327d86f73b0", "filename": "gcc/testsuite/rust/execute/torture/issue-1231.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0844def89deb7953b6eee563833b0e8e8e2668d/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1231.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0844def89deb7953b6eee563833b0e8e8e2668d/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1231.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1231.rs?ref=e0844def89deb7953b6eee563833b0e8e8e2668d", "patch": "@@ -0,0 +1,36 @@\n+// { dg-additional-options \"-w\" }\n+// { dg-output \"outer\\ninner\\n\" }\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+fn machin() {\n+    unsafe {\n+        let a = \"outer\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, 123);\n+    }\n+}\n+\n+fn bidule() {\n+    fn machin() {\n+        unsafe {\n+            let a = \"inner\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, 123);\n+        }\n+    }\n+\n+    self::machin();\n+    machin();\n+}\n+\n+fn main() -> i32 {\n+    bidule();\n+\n+    0\n+}"}]}