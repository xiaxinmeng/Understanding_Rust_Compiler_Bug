{"sha": "6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmExZTM1MmUxZWZiZGYzM2EzZGY4OTJkYWRkNzI1ZjBiMDljNzBjOQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2015-02-13T04:52:45Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2015-02-13T04:52:45Z"}, "message": "re PR rtl-optimization/32219 (optimizer causes wrong code in pic/hidden/weak symbol checking.)\n\nPR rtl/32219\n\ngcc/\n\t* cgraphunit.c (cgraph_node::finalize_function): Set definition\n\tbefore notice_global_symbol.\n\t(varpool_node::finalize_decl): Likewise.\n\t* varasm.c (default_binds_local_p_2): Rename from\n\tdefault_binds_local_p_1, add weak_dominate argument.  Use direct\n\treturns instead of assigning to local variable.  Unify varpool and\n\tcgraph paths via symtab_node.  Reject undef weak variables before\n\ttesting visibility.  Reorder tests for simplicity.\n\t(default_binds_local_p): Use default_binds_local_p_2.\n\t(default_binds_local_p_1): Likewise.\n\t(decl_binds_to_current_def_p): Unify varpool and cgraph paths\n\tvia symtab_node.\n\t(default_elf_asm_output_external): Emit visibility when specified.\ngcc/testsuite/\n\t* gcc.dg/visibility-22.c: New test.\n\t* gcc.dg/visibility-23.c: New test.\n\t* gcc.target/i386/pr32219-1.c: New test.\n\t* gcc.target/i386/pr32219-2.c: New test.\n\t* gcc.target/i386/pr32219-3.c: New test.\n\t* gcc.target/i386/pr32219-4.c: New test.\n\t* gcc.target/i386/pr32219-5.c: New test.\n\t* gcc.target/i386/pr32219-6.c: New test.\n\t* gcc.target/i386/pr32219-7.c: New test.\n\t* gcc.target/i386/pr32219-8.c: New test.\n\t* gcc.target/i386/pr64317.c: Expect GOTOFF, not GOT.\n\nCo-Authored-By: Richard Henderson <rth@redhat.com>\n\nFrom-SVN: r220674", "tree": {"sha": "0b7c95151ce5d3baedf0ed3fc3544b11a92ae3a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b7c95151ce5d3baedf0ed3fc3544b11a92ae3a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa47895fe650bc724adbdb3d5fd24348fd315277", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa47895fe650bc724adbdb3d5fd24348fd315277", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa47895fe650bc724adbdb3d5fd24348fd315277"}], "stats": {"total": 373, "additions": 283, "deletions": 90}, "files": [{"sha": "375d9f4ea9f02b1fd9ca1fb888b3ee8536d0a5cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "patch": "@@ -1,3 +1,21 @@\n+2015-02-12  H.J. Lu  <hongjiu.lu@intel.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\tPR rtl/32219\n+\t* cgraphunit.c (cgraph_node::finalize_function): Set definition\n+\tbefore notice_global_symbol.\n+\t(varpool_node::finalize_decl): Likewise.\n+\t* varasm.c (default_binds_local_p_2): Rename from\n+\tdefault_binds_local_p_1, add weak_dominate argument.  Use direct\n+\treturns instead of assigning to local variable.  Unify varpool and\n+\tcgraph paths via symtab_node.  Reject undef weak variables before\n+\ttesting visibility.  Reorder tests for simplicity.\n+\t(default_binds_local_p): Use default_binds_local_p_2.\n+\t(default_binds_local_p_1): Likewise.\n+\t(decl_binds_to_current_def_p): Unify varpool and cgraph paths\n+\tvia symtab_node.\n+\t(default_elf_asm_output_external): Emit visibility when specified.\n+\n 2015-02-13  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/rs6000.c (rs6000_emit_epilogue): Fix typo in"}, {"sha": "942826d368212216a182514b8dd56e919ba635d2", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "patch": "@@ -442,8 +442,10 @@ cgraph_node::finalize_function (tree decl, bool no_collect)\n       node->local.redefined_extern_inline = true;\n     }\n \n-  notice_global_symbol (decl);\n+  /* Set definition first before calling notice_global_symbol so that\n+     it is available to notice_global_symbol.  */\n   node->definition = true;\n+  notice_global_symbol (decl);\n   node->lowered = DECL_STRUCT_FUNCTION (decl)->cfg != NULL;\n \n   /* With -fkeep-inline-functions we are keeping all inline functions except\n@@ -803,8 +805,10 @@ varpool_node::finalize_decl (tree decl)\n \n   if (node->definition)\n     return;\n-  notice_global_symbol (decl);\n+  /* Set definition first before calling notice_global_symbol so that\n+     it is available to notice_global_symbol.  */\n   node->definition = true;\n+  notice_global_symbol (decl);\n   if (TREE_THIS_VOLATILE (decl) || DECL_PRESERVE_P (decl)\n       /* Traditionally we do not eliminate static variables when not\n \t optimizing and when not doing toplevel reoder.  */"}, {"sha": "4f11dc607770bff756118e7dd853160ac4505252", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "patch": "@@ -1,3 +1,18 @@\n+2015-02-12  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR rtl/32219\n+\t* gcc.dg/visibility-22.c: New test.\n+\t* gcc.dg/visibility-23.c: New test.\n+\t* gcc.target/i386/pr32219-1.c: New test.\n+\t* gcc.target/i386/pr32219-2.c: New test.\n+\t* gcc.target/i386/pr32219-3.c: New test.\n+\t* gcc.target/i386/pr32219-4.c: New test.\n+\t* gcc.target/i386/pr32219-5.c: New test.\n+\t* gcc.target/i386/pr32219-6.c: New test.\n+\t* gcc.target/i386/pr32219-7.c: New test.\n+\t* gcc.target/i386/pr32219-8.c: New test.\n+\t* gcc.target/i386/pr64317.c: Expect GOTOFF, not GOT.\n+\n 2015-02-12  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/57822"}, {"sha": "52f59be33415d6fd9da08ae7bcf36776ec215b53", "filename": "gcc/testsuite/gcc.dg/visibility-22.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.dg%2Fvisibility-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.dg%2Fvisibility-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvisibility-22.c?ref=6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "patch": "@@ -0,0 +1,17 @@\n+/* PR target/32219 */\n+/* { dg-do run } */\n+/* { dg-require-visibility \"\" } */\n+/* { dg-options \"-O2 -fPIC\" { target fpic } } */\n+/* This test requires support for undefined weak symbols.  This support\n+   is not available on hppa*-*-hpux*.  The test is skipped rather than\n+   xfailed to suppress the warning that would otherwise arise.  */\n+/* { dg-skip-if \"\" { \"hppa*-*-hpux*\" \"*-*-aix*\" \"*-*-darwin*\" } \"*\" { \"\" } }  */\n+\n+extern void foo () __attribute__((weak,visibility(\"hidden\")));\n+int\n+main()\n+{\n+  if (foo)\n+    foo ();\n+  return 0;\n+}"}, {"sha": "0fa9ef4c3e24af00ca16a49512ba0e3ad2f22fb4", "filename": "gcc/testsuite/gcc.dg/visibility-23.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.dg%2Fvisibility-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.dg%2Fvisibility-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvisibility-23.c?ref=6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "patch": "@@ -0,0 +1,15 @@\n+/* PR target/32219 */\n+/* { dg-do compile } */\n+/* { dg-require-visibility \"\" } */\n+/* { dg-final { scan-hidden \"foo\" } } */\n+/* { dg-options \"-O2 -fPIC\" { target fpic } } */\n+/* { dg-skip-if \"\" { \"hppa*-*-hpux*\" \"*-*-aix*\" \"*-*-darwin*\" } \"*\" { \"\" } }  */\n+\n+extern void foo () __attribute__((weak,visibility(\"hidden\")));\n+int\n+main()\n+{\n+  if (foo)\n+    foo ();\n+  return 0;\n+}"}, {"sha": "5bd80a0cd47aa6edb77c86ff61afae9f23a0e21e", "filename": "gcc/testsuite/gcc.target/i386/pr32219-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-1.c?ref=6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fpie\" } */\n+\n+/* Common symbol with -fpie.  */\n+int xxx;\n+\n+int\n+foo ()\n+{\n+  return xxx;\n+}\n+\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]xxx\\\\(%rip\\\\), %eax\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"xxx@GOTPCREL\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]xxx@GOTOFF\\\\(%\\[^,\\]*\\\\), %eax\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]xxx@GOT\\\\(%\\[^,\\]*\\\\), %eax\" { target ia32 } } } */"}, {"sha": "0cf2eb565c8f9169b5436135ba4289699d33ad1c", "filename": "gcc/testsuite/gcc.target/i386/pr32219-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-2.c?ref=6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fpic\" } */\n+\n+/* Common symbol with -fpic.  */\n+int xxx;\n+\n+int\n+foo ()\n+{\n+  return xxx;\n+}\n+\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]xxx\\\\(%rip\\\\), %eax\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"xxx@GOTPCREL\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]xxx@GOTOFF\\\\(%\\[^,\\]*\\\\), %eax\" { target ia32 } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]xxx@GOT\\\\(%\\[^,\\]*\\\\), %eax\" { target ia32 } } } */"}, {"sha": "911f2a56d5d7413e565712e55676a36b112088e2", "filename": "gcc/testsuite/gcc.target/i386/pr32219-3.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-3.c?ref=6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fpie\" } */\n+\n+/* Weak common symbol with -fpie.  */\n+__attribute__((weak))\n+int xxx;\n+\n+int\n+foo ()\n+{\n+  return xxx;\n+}\n+\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]xxx\\\\(%rip\\\\), %eax\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"xxx@GOTPCREL\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]xxx@GOTOFF\\\\(%\\[^,\\]*\\\\), %eax\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]xxx@GOT\\\\(%\\[^,\\]*\\\\), %eax\" { target ia32 } } } */"}, {"sha": "3d4343935380a8b881ef4ac7014ac6ed2d018ddb", "filename": "gcc/testsuite/gcc.target/i386/pr32219-4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-4.c?ref=6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fpic\" } */\n+\n+/* Weak common symbol with -fpic.  */\n+__attribute__((weak))\n+int xxx;\n+\n+int\n+foo ()\n+{\n+  return xxx;\n+}\n+\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]xxx\\\\(%rip\\\\), %eax\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"xxx@GOTPCREL\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]xxx@GOTOFF\\\\(%\\[^,\\]*\\\\), %eax\" { target ia32 } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]xxx@GOT\\\\(%\\[^,\\]*\\\\), %eax\" { target ia32 } } } */"}, {"sha": "ee7442eb8035c6c0a7ff2cadd9d9f4f4c4c5d6ce", "filename": "gcc/testsuite/gcc.target/i386/pr32219-5.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-5.c?ref=6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fpie\" } */\n+\n+/* Initialized symbol with -fpie.  */\n+int xxx = -1;\n+\n+int\n+foo ()\n+{\n+  return xxx;\n+}\n+\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]xxx\\\\(%rip\\\\), %eax\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"xxx@GOTPCREL\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]xxx@GOTOFF\\\\(%\\[^,\\]*\\\\), %eax\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]xxx@GOT\\\\(%\\[^,\\]*\\\\), %eax\" { target ia32 } } } */"}, {"sha": "f261433538e016ff9f1fc9e7cabfce760e3ee89e", "filename": "gcc/testsuite/gcc.target/i386/pr32219-6.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-6.c?ref=6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fpic\" } */\n+\n+/* Initialized symbol with -fpic.  */\n+int xxx = -1;\n+\n+int\n+foo ()\n+{\n+  return xxx;\n+}\n+\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]xxx\\\\(%rip\\\\), %eax\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"xxx@GOTPCREL\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]xxx@GOTOFF\\\\(%\\[^,\\]*\\\\), %eax\" { target ia32 } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]xxx@GOT\\\\(%\\[^,\\]*\\\\), %eax\" { target ia32 } } } */"}, {"sha": "12aaf7224d8d797ccd3a986b3f2921aded1bf4a2", "filename": "gcc/testsuite/gcc.target/i386/pr32219-7.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-7.c?ref=6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fpie\" } */\n+\n+/* Weak initialized symbol with -fpie.  */\n+__attribute__((weak))\n+int xxx = -1;\n+\n+int\n+foo ()\n+{\n+  return xxx;\n+}\n+\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]xxx\\\\(%rip\\\\), %eax\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"xxx@GOTPCREL\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]xxx@GOTOFF\\\\(%\\[^,\\]*\\\\), %eax\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]xxx@GOT\\\\(%\\[^,\\]*\\\\), %eax\" { target ia32 } } } */"}, {"sha": "2e4fba07a05eb00717d2f3edc1e35046506756cf", "filename": "gcc/testsuite/gcc.target/i386/pr32219-8.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr32219-8.c?ref=6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fpic\" } */\n+\n+/* Weak initialized symbol with -fpic.  */\n+__attribute__((weak))\n+int xxx = -1;\n+\n+int\n+foo ()\n+{\n+  return xxx;\n+}\n+\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]xxx\\\\(%rip\\\\), %eax\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"xxx@GOTPCREL\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]xxx@GOTOFF\\\\(%\\[^,\\]*\\\\), %eax\" { target ia32 } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]xxx@GOT\\\\(%\\[^,\\]*\\\\), %eax\" { target ia32 } } } */"}, {"sha": "32969fc689acb3de9b4a63f37f04c1862de6f472", "filename": "gcc/testsuite/gcc.target/i386/pr64317.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr64317.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr64317.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr64317.c?ref=6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile { target { *-*-linux* && ia32 } } } */\n /* { dg-options \"-O2 -fpie\" } */\n /* { dg-final { scan-assembler \"addl\\[ \\\\t\\]+\\[$\\]_GLOBAL_OFFSET_TABLE_, %ebx\" } } */\n-/* { dg-final { scan-assembler \"movl\\[ \\\\t\\]+c@GOT\\[(\\]%ebx\\[)\\]\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\\\t\\]+c@GOTOFF\\[(\\]%ebx\\[)\\]\" } } */\n /* { dg-final { scan-assembler-not \"movl\\[ \\\\t\\]+\\[0-9]+\\[(\\]%esp\\[)\\], %ebx\" } } */\n long c;\n "}, {"sha": "0211306dba26acf05639f32812cbd93936fb4b18", "filename": "gcc/varasm.c", "status": "modified", "additions": 79, "deletions": 87, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a1e352e1efbdf33a3df892dadd725f0b09c70c9/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=6a1e352e1efbdf33a3df892dadd725f0b09c70c9", "patch": "@@ -6802,97 +6802,96 @@ resolution_local_p (enum ld_plugin_symbol_resolution resolution)\n \t  || resolution == LDPR_RESOLVED_EXEC);\n }\n \n-/* Assume ELF-ish defaults, since that's pretty much the most liberal\n-   wrt cross-module name binding.  */\n-\n-bool\n-default_binds_local_p (const_tree exp)\n-{\n-  return default_binds_local_p_1 (exp, flag_shlib);\n-}\n-\n-bool\n-default_binds_local_p_1 (const_tree exp, int shlib)\n+static bool\n+default_binds_local_p_2 (const_tree exp, bool shlib, bool weak_dominate)\n {\n-  bool local_p;\n-  bool resolved_locally = false;\n-  bool resolved_to_local_def = false;\n-\n-  /* With resolution file in hands, take look into resolutions.\n-     We can't just return true for resolved_locally symbols,\n-     because dynamic linking might overwrite symbols\n-     in shared libraries.  */\n-  if (TREE_CODE (exp) == VAR_DECL && TREE_PUBLIC (exp)\n-      && (TREE_STATIC (exp) || DECL_EXTERNAL (exp)))\n-    {\n-      varpool_node *vnode = varpool_node::get (exp);\n-      if (vnode && (resolution_local_p (vnode->resolution) || vnode->in_other_partition))\n-\tresolved_locally = true;\n-      if (vnode\n-\t  && resolution_to_local_definition_p (vnode->resolution))\n-\tresolved_to_local_def = true;\n-    }\n-  else if (TREE_CODE (exp) == FUNCTION_DECL && TREE_PUBLIC (exp))\n-    {\n-      struct cgraph_node *node = cgraph_node::get (exp);\n-      if (node\n-\t  && (resolution_local_p (node->resolution) || node->in_other_partition))\n-\tresolved_locally = true;\n-      if (node\n-\t  && resolution_to_local_definition_p (node->resolution))\n-\tresolved_to_local_def = true;\n-    }\n-\n   /* A non-decl is an entry in the constant pool.  */\n   if (!DECL_P (exp))\n-    local_p = true;\n+    return true;\n+\n   /* Weakrefs may not bind locally, even though the weakref itself is always\n      static and therefore local.  Similarly, the resolver for ifunc functions\n      might resolve to a non-local function.\n      FIXME: We can resolve the weakref case more curefuly by looking at the\n      weakref alias.  */\n-  else if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (exp))\n+  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (exp))\n \t   || (TREE_CODE (exp) == FUNCTION_DECL\n \t       && lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (exp))))\n-    local_p = false;\n+    return false;\n+\n   /* Static variables are always local.  */\n-  else if (! TREE_PUBLIC (exp))\n-    local_p = true;\n-  /* A variable is local if the user has said explicitly that it will\n-     be.  */\n-  else if ((DECL_VISIBILITY_SPECIFIED (exp)\n-\t    || resolved_to_local_def)\n-\t   && DECL_VISIBILITY (exp) != VISIBILITY_DEFAULT)\n-    local_p = true;\n-  /* Variables defined outside this object might not be local.  */\n-  else if (DECL_EXTERNAL (exp) && !resolved_locally)\n-    local_p = false;\n-  /* If defined in this object and visibility is not default, must be\n-     local.  */\n-  else if (DECL_VISIBILITY (exp) != VISIBILITY_DEFAULT)\n-    local_p = true;\n-  /* Default visibility weak data can be overridden by a strong symbol\n-     in another module and so are not local.  */\n-  else if (DECL_WEAK (exp)\n-\t   && !resolved_locally)\n-    local_p = false;\n+  if (! TREE_PUBLIC (exp))\n+    return true;\n+\n+  /* With resolution file in hand, take look into resolutions.\n+     We can't just return true for resolved_locally symbols,\n+     because dynamic linking might overwrite symbols\n+     in shared libraries.  */\n+  bool resolved_locally = false;\n+  bool defined_locally = false;\n+  if (symtab_node *node = symtab_node::get (exp))\n+    {\n+      if (node->definition || node->in_other_partition)\n+\t{\n+\t  defined_locally = true;\n+\t  resolved_locally = (weak_dominate && !shlib);\n+\t}\n+      if (resolution_to_local_definition_p (node->resolution))\n+\tdefined_locally = resolved_locally = true;\n+      else if (resolution_local_p (node->resolution))\n+\tresolved_locally = true;\n+    }\n+\n+  /* Undefined weak symbols are never defined locally.  */\n+  if (DECL_WEAK (exp) && !defined_locally)\n+    return false;\n+\n+  /* A symbol is local if the user has said explicitly that it will be,\n+     or if we have a definition for the symbol.  We cannot infer visibility\n+     for undefined symbols.  */\n+  if (DECL_VISIBILITY (exp) != VISIBILITY_DEFAULT\n+      && (DECL_VISIBILITY_SPECIFIED (exp) || defined_locally))\n+    return true;\n+\n   /* If PIC, then assume that any global name can be overridden by\n      symbols resolved from other modules.  */\n-  else if (shlib)\n-    local_p = false;\n+  if (shlib)\n+    return false;\n+\n+  /* Variables defined outside this object might not be local.  */\n+  if (DECL_EXTERNAL (exp) && !resolved_locally)\n+    return false;\n+\n+  /* Non-dominant weak symbols are not defined locally.  */\n+  if (DECL_WEAK (exp) && !resolved_locally)\n+    return false;\n+\n   /* Uninitialized COMMON variable may be unified with symbols\n      resolved from other modules.  */\n-  else if (DECL_COMMON (exp)\n-\t   && !resolved_locally\n-\t   && (DECL_INITIAL (exp) == NULL\n-\t       || (!in_lto_p && DECL_INITIAL (exp) == error_mark_node)))\n-    local_p = false;\n+  if (DECL_COMMON (exp)\n+      && !resolved_locally\n+      && (DECL_INITIAL (exp) == NULL\n+\t  || (!in_lto_p && DECL_INITIAL (exp) == error_mark_node)))\n+    return false;\n+\n   /* Otherwise we're left with initialized (or non-common) global data\n      which is of necessity defined locally.  */\n-  else\n-    local_p = true;\n+  return true;\n+}\n+\n+/* Assume ELF-ish defaults, since that's pretty much the most liberal\n+   wrt cross-module name binding.  */\n+\n+bool\n+default_binds_local_p (const_tree exp)\n+{\n+  return default_binds_local_p_2 (exp, flag_shlib != 0, true);\n+}\n \n-  return local_p;\n+bool\n+default_binds_local_p_1 (const_tree exp, int shlib)\n+{\n+  return default_binds_local_p_2 (exp, shlib != 0, false);\n }\n \n /* Return true when references to DECL must bind to current definition in\n@@ -6914,22 +6913,14 @@ decl_binds_to_current_def_p (const_tree decl)\n     return false;\n   if (!TREE_PUBLIC (decl))\n     return true;\n+\n   /* When resolution is available, just use it.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n-      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n+  if (symtab_node *node = symtab_node::get (decl))\n     {\n-      varpool_node *vnode = varpool_node::get (decl);\n-      if (vnode\n-\t  && vnode->resolution != LDPR_UNKNOWN)\n-\treturn resolution_to_local_definition_p (vnode->resolution);\n-    }\n-  else if (TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      struct cgraph_node *node = cgraph_node::get (decl);\n-      if (node\n-\t  && node->resolution != LDPR_UNKNOWN)\n+      if (node->resolution != LDPR_UNKNOWN)\n \treturn resolution_to_local_definition_p (node->resolution);\n     }\n+\n   /* Otherwise we have to assume the worst for DECL_WEAK (hidden weaks\n      binds locally but still can be overwritten), DECL_COMMON (can be merged\n      with a non-common definition somewhere in the same module) or\n@@ -7449,9 +7440,10 @@ default_elf_asm_output_external (FILE *file ATTRIBUTE_UNUSED,\n {\n   /* We output the name if and only if TREE_SYMBOL_REFERENCED is\n      set in order to avoid putting out names that are never really\n-     used. */\n+     used.  Always output visibility specified in the source.  */\n   if (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n-      && targetm.binds_local_p (decl))\n+      && (DECL_VISIBILITY_SPECIFIED (decl)\n+\t  || targetm.binds_local_p (decl)))\n     maybe_assemble_visibility (decl);\n }\n "}]}