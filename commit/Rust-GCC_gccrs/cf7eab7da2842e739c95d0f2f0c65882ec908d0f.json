{"sha": "cf7eab7da2842e739c95d0f2f0c65882ec908d0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y3ZWFiN2RhMjg0MmU3MzljOTVkMGYyZjBjNjU4ODJlYzkwOGQwZg==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2011-07-21T22:57:00Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2011-07-21T22:57:00Z"}, "message": "Cleanup function params using a struct.\n\n2011-07-21  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* graphite-clast-to-gimple.c (struct ivs_params): New.\n\t(clast_name_to_gcc): Use ivs_params to pass around parameters.\n\t(clast_to_gcc_expression): Same.\n\t(clast_to_gcc_expression_red): Same.\n\t(gcc_type_for_clast_term): Same.\n\t(gcc_type_for_clast_expr): Same.\n\t(gcc_type_for_clast_red): Same.\n\t(gcc_type_for_clast_bin): Same.\n\t(gcc_type_for_clast_eq): Same.\n\t(graphite_translate_clast_equation): Same.\n\t(graphite_create_guard_cond_expr): Same.\n\t(graphite_create_new_guard): Same.\n\t(graphite_create_new_loop): Same.\n\t(build_iv_mapping): Same.\n\t(translate_clast_user): Same.\n\t(graphite_create_new_loop_guard): Same.\n\t(translate_clast): Same.\n\t(translate_clast_for_loop): Same.\n\t(translate_clast_for): Same.\n\t(translate_clast_guard): Same.\n\t(initialize_cloog_names): Fix typo.\n\t(gloog): Initialize an ivs_params struct, pass it to translate_clast.\n\nFrom-SVN: r176599", "tree": {"sha": "a33ad0033b480044f4eb7f148ef08c7d2951076c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a33ad0033b480044f4eb7f148ef08c7d2951076c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf7eab7da2842e739c95d0f2f0c65882ec908d0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf7eab7da2842e739c95d0f2f0c65882ec908d0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf7eab7da2842e739c95d0f2f0c65882ec908d0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf7eab7da2842e739c95d0f2f0c65882ec908d0f/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b1e9596d3f5d1e5bdfb36bd60f708b2a4a187a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b1e9596d3f5d1e5bdfb36bd60f708b2a4a187a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b1e9596d3f5d1e5bdfb36bd60f708b2a4a187a1"}], "stats": {"total": 361, "additions": 155, "deletions": 206}, "files": [{"sha": "8a7a08fc654e5e84d3cb39d9c35f92d182d26620", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7eab7da2842e739c95d0f2f0c65882ec908d0f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7eab7da2842e739c95d0f2f0c65882ec908d0f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf7eab7da2842e739c95d0f2f0c65882ec908d0f", "patch": "@@ -1,3 +1,28 @@\n+2011-07-21  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* graphite-clast-to-gimple.c (struct ivs_params): New.\n+\t(clast_name_to_gcc): Use ivs_params to pass around parameters.\n+\t(clast_to_gcc_expression): Same.\n+\t(clast_to_gcc_expression_red): Same.\n+\t(gcc_type_for_clast_term): Same.\n+\t(gcc_type_for_clast_expr): Same.\n+\t(gcc_type_for_clast_red): Same.\n+\t(gcc_type_for_clast_bin): Same.\n+\t(gcc_type_for_clast_eq): Same.\n+\t(graphite_translate_clast_equation): Same.\n+\t(graphite_create_guard_cond_expr): Same.\n+\t(graphite_create_new_guard): Same.\n+\t(graphite_create_new_loop): Same.\n+\t(build_iv_mapping): Same.\n+\t(translate_clast_user): Same.\n+\t(graphite_create_new_loop_guard): Same.\n+\t(translate_clast): Same.\n+\t(translate_clast_for_loop): Same.\n+\t(translate_clast_for): Same.\n+\t(translate_clast_guard): Same.\n+\t(initialize_cloog_names): Fix typo.\n+\t(gloog): Initialize an ivs_params struct, pass it to translate_clast.\n+\n 2011-07-21  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* graphite-clast-to-gimple.c (struct clast_name_index): Add level."}, {"sha": "099109ab025576db0ae9b4bd33e04ff9fe8bb0a9", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 130, "deletions": 206, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf7eab7da2842e739c95d0f2f0c65882ec908d0f/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf7eab7da2842e739c95d0f2f0c65882ec908d0f/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=cf7eab7da2842e739c95d0f2f0c65882ec908d0f", "patch": "@@ -171,29 +171,39 @@ eq_clast_name_indexes (const void *e1, const void *e2)\n \n \f\n \n+/* NEWIVS_INDEX binds CLooG's scattering name to the index of the tree\n+   induction variable in NEWIVS.\n+\n+   PARAMS_INDEX binds CLooG's parameter name to the index of the tree\n+   parameter in PARAMS.  */\n+\n+typedef struct ivs_params {\n+  VEC (tree, heap) *params, **newivs;\n+  htab_t newivs_index, params_index;\n+  sese region;\n+} *ivs_params_p;\n+\n /* Returns the tree variable from the name NAME that was given in\n    Cloog representation.  */\n \n static tree\n-clast_name_to_gcc (clast_name_p name, sese region, VEC (tree, heap) *newivs,\n-\t\t   htab_t newivs_index, htab_t params_index)\n+clast_name_to_gcc (clast_name_p name, ivs_params_p ip)\n {\n   int index;\n-  VEC (tree, heap) *params = SESE_PARAMS (region);\n \n-  if (params && params_index)\n+  if (ip->params && ip->params_index)\n     {\n-      index = clast_name_to_index (name, params_index);\n+      index = clast_name_to_index (name, ip->params_index);\n \n       if (index >= 0)\n-\treturn VEC_index (tree, params, index);\n+\treturn VEC_index (tree, ip->params, index);\n     }\n \n-  gcc_assert (newivs && newivs_index);\n-  index = clast_name_to_index (name, newivs_index);\n+  gcc_assert (*(ip->newivs) && ip->newivs_index);\n+  index = clast_name_to_index (name, ip->newivs_index);\n   gcc_assert (index >= 0);\n \n-  return VEC_index (tree, newivs, index);\n+  return VEC_index (tree, *(ip->newivs), index);\n }\n \n /* Returns the signed maximal precision type for expressions TYPE1 and TYPE2.  */\n@@ -250,27 +260,22 @@ max_precision_type (tree type1, tree type2)\n }\n \n static tree\n-clast_to_gcc_expression (tree, struct clast_expr *, sese, VEC (tree, heap) *,\n-\t\t\t htab_t, htab_t);\n+clast_to_gcc_expression (tree, struct clast_expr *, ivs_params_p);\n \n /* Converts a Cloog reduction expression R with reduction operation OP\n    to a GCC expression tree of type TYPE.  */\n \n static tree\n clast_to_gcc_expression_red (tree type, enum tree_code op,\n-\t\t\t     struct clast_reduction *r,\n-\t\t\t     sese region, VEC (tree, heap) *newivs,\n-\t\t\t     htab_t newivs_index, htab_t params_index)\n+\t\t\t     struct clast_reduction *r, ivs_params_p ip)\n {\n   int i;\n-  tree res = clast_to_gcc_expression (type, r->elts[0], region, newivs,\n-\t\t\t\t      newivs_index, params_index);\n+  tree res = clast_to_gcc_expression (type, r->elts[0], ip);\n   tree operand_type = (op == POINTER_PLUS_EXPR) ? sizetype : type;\n \n   for (i = 1; i < r->n; i++)\n     {\n-      tree t = clast_to_gcc_expression (operand_type, r->elts[i], region,\n-\t\t\t\t\tnewivs, newivs_index, params_index);\n+      tree t = clast_to_gcc_expression (operand_type, r->elts[i], ip);\n       res = fold_build2 (op, type, res, t);\n     }\n \n@@ -281,9 +286,7 @@ clast_to_gcc_expression_red (tree type, enum tree_code op,\n    type TYPE.  */\n \n static tree\n-clast_to_gcc_expression (tree type, struct clast_expr *e,\n-\t\t\t sese region, VEC (tree, heap) *newivs,\n-\t\t\t htab_t newivs_index, htab_t params_index)\n+clast_to_gcc_expression (tree type, struct clast_expr *e, ivs_params_p ip)\n {\n   switch (e->type)\n     {\n@@ -295,8 +298,7 @@ clast_to_gcc_expression (tree type, struct clast_expr *e,\n \t  {\n \t    if (mpz_cmp_si (t->val, 1) == 0)\n \t      {\n-\t\ttree name = clast_name_to_gcc (t->var, region, newivs,\n-\t\t\t\t\t       newivs_index, params_index);\n+\t\ttree name = clast_name_to_gcc (t->var, ip);\n \n \t\tif (POINTER_TYPE_P (TREE_TYPE (name)) != POINTER_TYPE_P (type))\n \t\t  name = fold_convert (sizetype, name);\n@@ -307,8 +309,7 @@ clast_to_gcc_expression (tree type, struct clast_expr *e,\n \n \t    else if (mpz_cmp_si (t->val, -1) == 0)\n \t      {\n-\t\ttree name = clast_name_to_gcc (t->var, region, newivs,\n-\t\t\t\t\t       newivs_index, params_index);\n+\t\ttree name = clast_name_to_gcc (t->var, ip);\n \n \t\tif (POINTER_TYPE_P (TREE_TYPE (name)) != POINTER_TYPE_P (type))\n \t\t  name = fold_convert (sizetype, name);\n@@ -319,8 +320,7 @@ clast_to_gcc_expression (tree type, struct clast_expr *e,\n \t      }\n \t    else\n \t      {\n-\t\ttree name = clast_name_to_gcc (t->var, region, newivs,\n-\t\t\t\t\t       newivs_index, params_index);\n+\t\ttree name = clast_name_to_gcc (t->var, ip);\n \t\ttree cst = gmp_cst_to_tree (type, t->val);\n \n \t\tif (POINTER_TYPE_P (TREE_TYPE (name)) != POINTER_TYPE_P (type))\n@@ -348,17 +348,13 @@ clast_to_gcc_expression (tree type, struct clast_expr *e,\n \t  case clast_red_sum:\n \t    return clast_to_gcc_expression_red\n \t      (type, POINTER_TYPE_P (type) ? POINTER_PLUS_EXPR : PLUS_EXPR,\n-\t       r, region, newivs, newivs_index, params_index);\n+\t       r, ip);\n \n \t  case clast_red_min:\n-\t    return clast_to_gcc_expression_red (type, MIN_EXPR, r, region,\n-\t\t\t\t\t\tnewivs, newivs_index,\n-\t\t\t\t\t\tparams_index);\n+\t    return clast_to_gcc_expression_red (type, MIN_EXPR, r, ip);\n \n \t  case clast_red_max:\n-\t    return clast_to_gcc_expression_red (type, MAX_EXPR, r, region,\n-\t\t\t\t\t\tnewivs, newivs_index,\n-\t\t\t\t\t\tparams_index);\n+\t    return clast_to_gcc_expression_red (type, MAX_EXPR, r, ip);\n \n \t  default:\n \t    gcc_unreachable ();\n@@ -370,8 +366,7 @@ clast_to_gcc_expression (tree type, struct clast_expr *e,\n       {\n \tstruct clast_binary *b = (struct clast_binary *) e;\n \tstruct clast_expr *lhs = (struct clast_expr *) b->LHS;\n-\ttree tl = clast_to_gcc_expression (type, lhs, region, newivs,\n-\t\t\t\t\t   newivs_index, params_index);\n+\ttree tl = clast_to_gcc_expression (type, lhs, ip);\n \ttree tr = gmp_cst_to_tree (type, b->RHS);\n \n \tswitch (b->type)\n@@ -448,47 +443,40 @@ gcc_type_for_value (mpz_t val)\n \n static tree\n gcc_type_for_clast_term (struct clast_term *t,\n-\t\t\t sese region, VEC (tree, heap) *newivs,\n-\t\t\t htab_t newivs_index, htab_t params_index)\n+\t\t\t ivs_params_p ip)\n {\n   gcc_assert (t->expr.type == clast_expr_term);\n \n   if (!t->var)\n     return gcc_type_for_value (t->val);\n \n-  return TREE_TYPE (clast_name_to_gcc (t->var, region, newivs,\n-\t\t\t\t       newivs_index, params_index));\n+  return TREE_TYPE (clast_name_to_gcc (t->var, ip));\n }\n \n static tree\n-gcc_type_for_clast_expr (struct clast_expr *, sese,\n-\t\t\t VEC (tree, heap) *, htab_t, htab_t);\n+gcc_type_for_clast_expr (struct clast_expr *, ivs_params_p);\n \n /* Return the type for the clast_reduction R used in STMT.  */\n \n static tree\n-gcc_type_for_clast_red (struct clast_reduction *r, sese region,\n-\t\t\tVEC (tree, heap) *newivs,\n-\t\t\thtab_t newivs_index, htab_t params_index)\n+gcc_type_for_clast_red (struct clast_reduction *r,\n+\t\t\tivs_params_p ip)\n {\n   int i;\n   tree type = NULL_TREE;\n \n   if (r->n == 1)\n-    return gcc_type_for_clast_expr (r->elts[0], region, newivs,\n-\t\t\t\t    newivs_index, params_index);\n+    return gcc_type_for_clast_expr (r->elts[0], ip);\n \n   switch (r->type)\n     {\n     case clast_red_sum:\n     case clast_red_min:\n     case clast_red_max:\n-      type = gcc_type_for_clast_expr (r->elts[0], region, newivs,\n-\t\t\t\t      newivs_index, params_index);\n+      type = gcc_type_for_clast_expr (r->elts[0], ip);\n       for (i = 1; i < r->n; i++)\n \ttype = max_precision_type (type, gcc_type_for_clast_expr\n-\t\t\t\t   (r->elts[i], region, newivs,\n-\t\t\t\t    newivs_index, params_index));\n+\t\t\t\t   (r->elts[i], ip));\n \n       return type;\n \n@@ -503,12 +491,9 @@ gcc_type_for_clast_red (struct clast_reduction *r, sese region,\n /* Return the type for the clast_binary B used in STMT.  */\n \n static tree\n-gcc_type_for_clast_bin (struct clast_binary *b,\n-\t\t\tsese region, VEC (tree, heap) *newivs,\n-\t\t\thtab_t newivs_index, htab_t params_index)\n+gcc_type_for_clast_bin (struct clast_binary *b, ivs_params_p ip)\n {\n-  tree l = gcc_type_for_clast_expr ((struct clast_expr *) b->LHS, region,\n-\t\t\t\t    newivs, newivs_index, params_index);\n+  tree l = gcc_type_for_clast_expr ((struct clast_expr *) b->LHS, ip);\n   tree r = gcc_type_for_value (b->RHS);\n   return max_signed_precision_type (l, r);\n }\n@@ -518,22 +503,18 @@ gcc_type_for_clast_bin (struct clast_binary *b,\n \n static tree\n gcc_type_for_clast_expr (struct clast_expr *e,\n-\t\t\t sese region, VEC (tree, heap) *newivs,\n-\t\t\t htab_t newivs_index, htab_t params_index)\n+\t\t\t ivs_params_p ip)\n {\n   switch (e->type)\n     {\n     case clast_expr_term:\n-      return gcc_type_for_clast_term ((struct clast_term *) e, region,\n-\t\t\t\t      newivs, newivs_index, params_index);\n+      return gcc_type_for_clast_term ((struct clast_term *) e, ip);\n \n     case clast_expr_red:\n-      return gcc_type_for_clast_red ((struct clast_reduction *) e, region,\n-\t\t\t\t     newivs, newivs_index, params_index);\n+      return gcc_type_for_clast_red ((struct clast_reduction *) e, ip);\n \n     case clast_expr_bin:\n-      return gcc_type_for_clast_bin ((struct clast_binary *) e, region,\n-\t\t\t\t     newivs, newivs_index, params_index);\n+      return gcc_type_for_clast_bin ((struct clast_binary *) e, ip);\n \n     default:\n       gcc_unreachable ();\n@@ -546,31 +527,23 @@ gcc_type_for_clast_expr (struct clast_expr *e,\n \n static tree\n gcc_type_for_clast_eq (struct clast_equation *cleq,\n-\t\t       sese region, VEC (tree, heap) *newivs,\n-\t\t       htab_t newivs_index, htab_t params_index)\n+\t\t       ivs_params_p ip)\n {\n-  tree l = gcc_type_for_clast_expr (cleq->LHS, region, newivs,\n-\t\t\t\t    newivs_index, params_index);\n-  tree r = gcc_type_for_clast_expr (cleq->RHS, region, newivs,\n-\t\t\t\t    newivs_index, params_index);\n+  tree l = gcc_type_for_clast_expr (cleq->LHS, ip);\n+  tree r = gcc_type_for_clast_expr (cleq->RHS, ip);\n   return max_precision_type (l, r);\n }\n \n /* Translates a clast equation CLEQ to a tree.  */\n \n static tree\n-graphite_translate_clast_equation (sese region,\n-\t\t\t\t   struct clast_equation *cleq,\n-\t\t\t\t   VEC (tree, heap) *newivs,\n-\t\t\t\t   htab_t newivs_index, htab_t params_index)\n+graphite_translate_clast_equation (struct clast_equation *cleq,\n+\t\t\t\t   ivs_params_p ip)\n {\n   enum tree_code comp;\n-  tree type = gcc_type_for_clast_eq (cleq, region, newivs, newivs_index,\n-\t\t\t\t     params_index);\n-  tree lhs = clast_to_gcc_expression (type, cleq->LHS, region, newivs,\n-\t\t\t\t      newivs_index, params_index);\n-  tree rhs = clast_to_gcc_expression (type, cleq->RHS, region, newivs,\n-\t\t\t\t      newivs_index, params_index);\n+  tree type = gcc_type_for_clast_eq (cleq, ip);\n+  tree lhs = clast_to_gcc_expression (type, cleq->LHS, ip);\n+  tree rhs = clast_to_gcc_expression (type, cleq->RHS, ip);\n \n   if (cleq->sign == 0)\n     comp = EQ_EXPR;\n@@ -587,18 +560,15 @@ graphite_translate_clast_equation (sese region,\n /* Creates the test for the condition in STMT.  */\n \n static tree\n-graphite_create_guard_cond_expr (sese region, struct clast_guard *stmt,\n-\t\t\t\t VEC (tree, heap) *newivs,\n-\t\t\t\t htab_t newivs_index, htab_t params_index)\n+graphite_create_guard_cond_expr (struct clast_guard *stmt,\n+\t\t\t\t ivs_params_p ip)\n {\n   tree cond = NULL;\n   int i;\n \n   for (i = 0; i < stmt->n; i++)\n     {\n-      tree eq = graphite_translate_clast_equation (region, &stmt->eq[i],\n-\t\t\t\t\t\t   newivs, newivs_index,\n-\t\t\t\t\t\t   params_index);\n+      tree eq = graphite_translate_clast_equation (&stmt->eq[i], ip);\n \n       if (cond)\n \tcond = fold_build2 (TRUTH_AND_EXPR, TREE_TYPE (eq), cond, eq);\n@@ -612,13 +582,10 @@ graphite_create_guard_cond_expr (sese region, struct clast_guard *stmt,\n /* Creates a new if region corresponding to Cloog's guard.  */\n \n static edge\n-graphite_create_new_guard (sese region, edge entry_edge,\n-\t\t\t   struct clast_guard *stmt,\n-\t\t\t   VEC (tree, heap) *newivs,\n-\t\t\t   htab_t newivs_index, htab_t params_index)\n+graphite_create_new_guard (edge entry_edge, struct clast_guard *stmt,\n+\t\t\t   ivs_params_p ip)\n {\n-  tree cond_expr = graphite_create_guard_cond_expr (region, stmt, newivs,\n-\t\t\t\t\t\t    newivs_index, params_index);\n+  tree cond_expr = graphite_create_guard_cond_expr (stmt, ip);\n   edge exit_edge = create_empty_if_region_on_edge (entry_edge, cond_expr);\n   return exit_edge;\n }\n@@ -720,11 +687,9 @@ gcc_type_for_iv_of_clast_loop (struct clast_for *stmt_for, int level,\n    vector and is of type TYPE.  */\n \n static struct loop *\n-graphite_create_new_loop (edge entry_edge,\n-\t\t\t  struct clast_for *stmt,\n-\t\t\t  loop_p outer, VEC (tree, heap) **newivs,\n-\t\t\t  htab_t newivs_index,\n-\t\t\t  tree type, tree lb, tree ub, int level)\n+graphite_create_new_loop (edge entry_edge, struct clast_for *stmt,\n+\t\t\t  loop_p outer, tree type, tree lb, tree ub,\n+\t\t\t  int level, ivs_params_p ip)\n {\n   tree stride = gmp_cst_to_tree (type, stmt->stride);\n   tree ivvar = create_tmp_var (type, \"graphite_IV\");\n@@ -735,20 +700,18 @@ graphite_create_new_loop (edge entry_edge,\n \n   add_referenced_var (ivvar);\n \n-  save_clast_name_index (newivs_index, stmt->iterator,\n-\t\t\t VEC_length (tree, *newivs), level);\n-  VEC_safe_push (tree, heap, *newivs, iv);\n+  save_clast_name_index (ip->newivs_index, stmt->iterator,\n+\t\t\t VEC_length (tree, *(ip->newivs)), level);\n+  VEC_safe_push (tree, heap, *(ip->newivs), iv);\n   return loop;\n }\n \n /* Inserts in iv_map a tuple (OLD_LOOP->num, NEW_NAME) for the\n    induction variables of the loops around GBB in SESE.  */\n \n static void\n-build_iv_mapping (VEC (tree, heap) *iv_map, sese region,\n-\t\t  VEC (tree, heap) *newivs, htab_t newivs_index,\n-\t\t  struct clast_user_stmt *user_stmt,\n-\t\t  htab_t params_index)\n+build_iv_mapping (VEC (tree, heap) *iv_map, struct clast_user_stmt *user_stmt,\n+\t\t  ivs_params_p ip)\n {\n   struct clast_stmt *t;\n   int depth = 0;\n@@ -760,11 +723,9 @@ build_iv_mapping (VEC (tree, heap) *iv_map, sese region,\n     {\n       struct clast_expr *expr = (struct clast_expr *)\n        ((struct clast_assignment *)t)->RHS;\n-      tree type = gcc_type_for_clast_expr (expr, region, newivs,\n-\t\t\t\t\t   newivs_index, params_index);\n-      tree new_name = clast_to_gcc_expression (type, expr, region, newivs,\n-\t\t\t\t\t       newivs_index, params_index);\n-      loop_p old_loop = gbb_loop_at_index (gbb, region, depth);\n+      tree type = gcc_type_for_clast_expr (expr, ip);\n+      tree new_name = clast_to_gcc_expression (type, expr, ip);\n+      loop_p old_loop = gbb_loop_at_index (gbb, ip->region, depth);\n \n       VEC_replace (tree, iv_map, old_loop->num, new_name);\n     }\n@@ -855,17 +816,13 @@ dependency_in_loop_p (loop_p loop, htab_t bb_pbb_mapping, int level)\n \n /* Translates a clast user statement STMT to gimple.\n \n-   - REGION is the sese region we used to generate the scop.\n    - NEXT_E is the edge where new generated code should be attached.\n    - CONTEXT_LOOP is the loop in which the generated code will be placed\n-   - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.\n-   - PARAMS_INDEX connects the cloog parameters with the gimple parameters in\n-     the sese region.  */\n+   - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.  */\n+\n static edge\n-translate_clast_user (sese region, struct clast_user_stmt *stmt, edge next_e,\n-\t\t      VEC (tree, heap) **newivs,\n-\t\t      htab_t newivs_index, htab_t bb_pbb_mapping,\n-\t\t      htab_t params_index)\n+translate_clast_user (struct clast_user_stmt *stmt, edge next_e,\n+\t\t      htab_t bb_pbb_mapping, ivs_params_p ip)\n {\n   int i, nb_loops;\n   basic_block new_bb;\n@@ -881,8 +838,8 @@ translate_clast_user (sese region, struct clast_user_stmt *stmt, edge next_e,\n   for (i = 0; i < nb_loops; i++)\n     VEC_quick_push (tree, iv_map, NULL_TREE);\n \n-  build_iv_mapping (iv_map, region, *newivs, newivs_index, stmt, params_index);\n-  next_e = copy_bb_and_scalar_dependences (GBB_BB (gbb), region,\n+  build_iv_mapping (iv_map, stmt, ip);\n+  next_e = copy_bb_and_scalar_dependences (GBB_BB (gbb), ip->region,\n \t\t\t\t\t   next_e, iv_map);\n   VEC_free (tree, heap, iv_map);\n \n@@ -897,24 +854,18 @@ translate_clast_user (sese region, struct clast_user_stmt *stmt, edge next_e,\n    count is zero (lb > ub).  */\n \n static edge\n-graphite_create_new_loop_guard (sese region, edge entry_edge,\n-\t\t\t\tstruct clast_for *stmt,\n-\t\t\t\tVEC (tree, heap) *newivs,\n-\t\t\t\thtab_t newivs_index, htab_t params_index,\n-\t\t\t\tint level, tree *type, tree *lb, tree *ub)\n+graphite_create_new_loop_guard (edge entry_edge, struct clast_for *stmt,\n+\t\t\t\tint level, tree *type, tree *lb, tree *ub,\n+\t\t\t\tivs_params_p ip)\n {\n   tree cond_expr;\n   edge exit_edge;\n-  tree lb_type = gcc_type_for_clast_expr (stmt->LB, region, newivs,\n-\t\t\t\t\t  newivs_index, params_index);\n-  tree ub_type = gcc_type_for_clast_expr (stmt->UB, region, newivs,\n-\t\t\t\t\t  newivs_index, params_index);\n+  tree lb_type = gcc_type_for_clast_expr (stmt->LB, ip);\n+  tree ub_type = gcc_type_for_clast_expr (stmt->UB, ip);\n \n   *type = gcc_type_for_iv_of_clast_loop (stmt, level, lb_type, ub_type);\n-  *lb = clast_to_gcc_expression (*type, stmt->LB, region, newivs,\n-\t\t\t\t newivs_index, params_index);\n-  *ub = clast_to_gcc_expression (*type, stmt->UB, region, newivs,\n-\t\t\t\t newivs_index, params_index);\n+  *lb = clast_to_gcc_expression (*type, stmt->LB, ip);\n+  *ub = clast_to_gcc_expression (*type, stmt->UB, ip);\n \n   /* When ub is simply a constant or a parameter, use lb <= ub.  */\n   if (TREE_CODE (*ub) == INTEGER_CST || TREE_CODE (*ub) == SSA_NAME)\n@@ -941,29 +892,20 @@ graphite_create_new_loop_guard (sese region, edge entry_edge,\n }\n \n static edge\n-translate_clast (sese, loop_p, struct clast_stmt *, edge,\n-\t\t VEC (tree, heap) **, htab_t, htab_t, int, htab_t);\n+translate_clast (loop_p, struct clast_stmt *, edge, htab_t, int, ivs_params_p);\n \n /* Create the loop for a clast for statement.\n \n-   - REGION is the sese region we used to generate the scop.\n    - NEXT_E is the edge where new generated code should be attached.\n-   - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.\n-   - PARAMS_INDEX connects the cloog parameters with the gimple parameters in\n-     the sese region.  */\n+   - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.  */\n \n static edge\n-translate_clast_for_loop (sese region, loop_p context_loop,\n-\t\t\t  struct clast_for *stmt, edge next_e,\n-\t\t\t  VEC (tree, heap) **newivs,\n-\t\t\t  htab_t newivs_index, htab_t bb_pbb_mapping,\n-\t\t\t  int level, htab_t params_index, tree type,\n-\t\t\t  tree lb, tree ub)\n+translate_clast_for_loop (loop_p context_loop, struct clast_for *stmt,\n+\t\t\t  edge next_e, htab_t bb_pbb_mapping, int level,\n+\t\t\t  tree type, tree lb, tree ub, ivs_params_p ip)\n {\n-  struct loop *loop = graphite_create_new_loop (next_e, stmt,\n- \t\t\t\t\t\tcontext_loop, newivs,\n-\t\t\t\t\t\tnewivs_index,\n-\t\t\t\t\t\ttype, lb, ub, level);\n+  struct loop *loop = graphite_create_new_loop (next_e, stmt, context_loop,\n+\t\t\t\t\t\ttype, lb, ub, level, ip);\n   edge last_e = single_exit (loop);\n   edge to_body = single_succ_edge (loop->header);\n   basic_block after = to_body->dest;\n@@ -972,9 +914,8 @@ translate_clast_for_loop (sese region, loop_p context_loop,\n   last_e = single_succ_edge (split_edge (last_e));\n \n   /* Translate the body of the loop.  */\n-  next_e = translate_clast (region, loop, stmt->body, to_body,\n-\t\t\t    newivs, newivs_index, bb_pbb_mapping, level + 1,\n-\t\t\t    params_index);\n+  next_e = translate_clast (loop, stmt->body, to_body, bb_pbb_mapping,\n+\t\t\t    level + 1, ip);\n   redirect_edge_succ_nodup (next_e, after);\n   set_immediate_dominator (CDI_DOMINATORS, next_e->dest, next_e->src);\n \n@@ -989,51 +930,38 @@ translate_clast_for_loop (sese region, loop_p context_loop,\n    protecting the loop, if it is executed zero times.  In this guard we create\n    the real loop structure.\n \n-   - REGION is the sese region we used to generate the scop.\n    - NEXT_E is the edge where new generated code should be attached.\n-   - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.\n-   - PARAMS_INDEX connects the cloog parameters with the gimple parameters in\n-     the sese region.  */\n+   - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.  */\n+\n static edge\n-translate_clast_for (sese region, loop_p context_loop, struct clast_for *stmt,\n-\t\t     edge next_e, VEC (tree, heap) **newivs,\n-\t\t     htab_t newivs_index, htab_t bb_pbb_mapping, int level,\n-\t\t     htab_t params_index)\n+translate_clast_for (loop_p context_loop, struct clast_for *stmt, edge next_e,\n+\t\t     htab_t bb_pbb_mapping, int level, ivs_params_p ip)\n {\n   tree type, lb, ub;\n-  edge last_e = graphite_create_new_loop_guard (region, next_e, stmt, *newivs,\n-\t\t\t\t\t\tnewivs_index, params_index,\n-\t\t\t\t\t\tlevel, &type, &lb, &ub);\n+  edge last_e = graphite_create_new_loop_guard (next_e, stmt, level, &type,\n+\t\t\t\t\t\t&lb, &ub, ip);\n   edge true_e = get_true_edge_from_guard_bb (next_e->dest);\n \n-  translate_clast_for_loop (region, context_loop, stmt, true_e, newivs,\n-\t\t\t    newivs_index, bb_pbb_mapping, level,\n-\t\t\t    params_index, type, lb, ub);\n+  translate_clast_for_loop (context_loop, stmt, true_e, bb_pbb_mapping, level,\n+\t\t\t    type, lb, ub, ip);\n   return last_e;\n }\n \n /* Translates a clast guard statement STMT to gimple.\n \n-   - REGION is the sese region we used to generate the scop.\n    - NEXT_E is the edge where new generated code should be attached.\n    - CONTEXT_LOOP is the loop in which the generated code will be placed\n-   - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.\n-   - PARAMS_INDEX connects the cloog parameters with the gimple parameters in\n-     the sese region.  */\n+   - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.  */\n+\n static edge\n-translate_clast_guard (sese region, loop_p context_loop,\n-\t\t       struct clast_guard *stmt, edge next_e,\n-\t\t       VEC (tree, heap) **newivs,\n-\t\t       htab_t newivs_index, htab_t bb_pbb_mapping, int level,\n-\t\t       htab_t params_index)\n+translate_clast_guard (loop_p context_loop, struct clast_guard *stmt,\n+\t\t       edge next_e, htab_t bb_pbb_mapping, int level,\n+\t\t       ivs_params_p ip)\n {\n-  edge last_e = graphite_create_new_guard (region, next_e, stmt, *newivs,\n-\t\t\t\t\t   newivs_index, params_index);\n+  edge last_e = graphite_create_new_guard (next_e, stmt, ip);\n   edge true_e = get_true_edge_from_guard_bb (next_e->dest);\n \n-  translate_clast (region, context_loop, stmt->then, true_e,\n-\t\t   newivs, newivs_index, bb_pbb_mapping,\n-\t\t   level, params_index);\n+  translate_clast (context_loop, stmt->then, true_e, bb_pbb_mapping, level, ip);\n   return last_e;\n }\n \n@@ -1043,11 +971,10 @@ translate_clast_guard (sese region, loop_p context_loop,\n    - NEXT_E is the edge where new generated code should be attached.\n    - CONTEXT_LOOP is the loop in which the generated code will be placed\n    - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.  */\n+\n static edge\n-translate_clast (sese region, loop_p context_loop, struct clast_stmt *stmt,\n-\t\t edge next_e, VEC (tree, heap) **newivs,\n-\t\t htab_t newivs_index, htab_t bb_pbb_mapping, int level,\n-\t\t htab_t params_index)\n+translate_clast (loop_p context_loop, struct clast_stmt *stmt, edge next_e,\n+\t\t htab_t bb_pbb_mapping, int level, ivs_params_p ip)\n {\n   if (!stmt)\n     return next_e;\n@@ -1056,36 +983,28 @@ translate_clast (sese region, loop_p context_loop, struct clast_stmt *stmt,\n     ; /* Do nothing.  */\n \n   else if (CLAST_STMT_IS_A (stmt, stmt_user))\n-    next_e = translate_clast_user (region, (struct clast_user_stmt *) stmt,\n-\t\t\t\t   next_e, newivs, newivs_index,\n-\t\t\t\t   bb_pbb_mapping, params_index);\n+    next_e = translate_clast_user ((struct clast_user_stmt *) stmt,\n+\t\t\t\t   next_e, bb_pbb_mapping, ip);\n \n   else if (CLAST_STMT_IS_A (stmt, stmt_for))\n-    next_e = translate_clast_for (region, context_loop,\n-\t\t\t\t  (struct clast_for *) stmt, next_e,\n-\t\t\t\t  newivs, newivs_index,\n-\t\t\t\t  bb_pbb_mapping, level, params_index);\n+    next_e = translate_clast_for (context_loop, (struct clast_for *) stmt,\n+\t\t\t\t  next_e, bb_pbb_mapping, level, ip);\n \n   else if (CLAST_STMT_IS_A (stmt, stmt_guard))\n-    next_e = translate_clast_guard (region, context_loop,\n-\t\t\t\t    (struct clast_guard *) stmt, next_e,\n-\t\t\t\t    newivs, newivs_index,\n-\t\t\t\t    bb_pbb_mapping, level, params_index);\n+    next_e = translate_clast_guard (context_loop, (struct clast_guard *) stmt,\n+\t\t\t\t    next_e, bb_pbb_mapping, level, ip);\n \n   else if (CLAST_STMT_IS_A (stmt, stmt_block))\n-    next_e = translate_clast (region, context_loop,\n-\t\t\t      ((struct clast_block *) stmt)->body,\n-\t\t\t      next_e, newivs, newivs_index,\n-\t\t\t      bb_pbb_mapping, level, params_index);\n+    next_e = translate_clast (context_loop, ((struct clast_block *) stmt)->body,\n+\t\t\t      next_e, bb_pbb_mapping, level, ip);\n   else\n     gcc_unreachable();\n \n   recompute_all_dominators ();\n   graphite_verify ();\n \n-  return translate_clast (region, context_loop, stmt->next, next_e,\n-\t\t\t  newivs, newivs_index,\n-\t\t\t  bb_pbb_mapping, level, params_index);\n+  return translate_clast (context_loop, stmt->next, next_e, bb_pbb_mapping,\n+\t\t\t  level, ip);\n }\n \n /* Free the SCATTERING domain list.  */\n@@ -1124,7 +1043,7 @@ initialize_cloog_names (scop_p scop, CloogProgram *prog)\n \n   for (i = 0; i < nb_parameters; i++)\n     {\n-      tree param = VEC_index (tree, SESE_PARAMS(region), i);\n+      tree param = VEC_index (tree, SESE_PARAMS (region), i);\n       const char *name = get_name (param);\n       int len;\n \n@@ -1461,6 +1380,7 @@ gloog (scop_p scop, htab_t bb_pbb_mapping)\n   ifsese if_region = NULL;\n   htab_t newivs_index, params_index;\n   cloog_prog_clast pc;\n+  struct ivs_params ip;\n \n   timevar_push (TV_GRAPHITE_CODE_GEN);\n   gloog_error = false;\n@@ -1493,10 +1413,14 @@ gloog (scop_p scop, htab_t bb_pbb_mapping)\n \n   create_params_index (params_index, pc.prog);\n \n-  translate_clast (region, context_loop, pc.stmt,\n-\t\t   if_region->true_region->entry,\n-\t\t   &newivs, newivs_index,\n-\t\t   bb_pbb_mapping, 0, params_index);\n+  ip.newivs = &newivs;\n+  ip.newivs_index = newivs_index;\n+  ip.params = SESE_PARAMS (region);\n+  ip.params_index = params_index;\n+  ip.region = region;\n+\n+  translate_clast (context_loop, pc.stmt, if_region->true_region->entry,\n+\t\t   bb_pbb_mapping, 0, &ip);\n   graphite_verify ();\n   scev_reset ();\n   recompute_all_dominators ();"}]}