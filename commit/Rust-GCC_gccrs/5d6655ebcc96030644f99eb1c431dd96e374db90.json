{"sha": "5d6655ebcc96030644f99eb1c431dd96e374db90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ2NjU1ZWJjYzk2MDMwNjQ0Zjk5ZWIxYzQzMWRkOTZlMzc0ZGI5MA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-01-02T06:02:37Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2019-01-02T06:02:37Z"}, "message": "gimple-fold.h (get_range_strlen): Update prototype.\n\n\t* gimple-fold.h (get_range_strlen): Update prototype.\n\t* builtins.c (check_access): Update call to get_range_strlen to use\n\tc_strlen_data pointer.   Change various variable accesses to instead\n\tpull data from the c_strlen_data structure.\n\t(check_strncat_sizes, expand_builtin_strncat): Likewise.\n\t* calls.c (maybe_warn_nonstring_arg): Likewise.\n\t* tree-ssa-strlen.c (maybe_diag_stxncpy_trunc): Likewise.  Reset\n\tminimum length if maximum lengh is unknown.\n\t* gimple-ssa-sprintf.c (get_string_length): Likewise.  Drop code\n\tthat used c_strlen, it's no longer needed.  Restructure slightly.\n\t(format_string): Set unlikely range appropriately.\n\t* gimple-fold.c (get_range_strlen): Update comments.  Fix minor\n\tformatting issues.\n\t(get_range_strlen):  Accept c_strlen_data pointer for external\n\tcall sites as well.  Pass through to call to internal get_range_strlen.\n\tAdjust minlen, maxlen and maxbound as needed.\n\t(get_maxval_strlen): Update comments.\n\t(gimple_fold_builtin_strlen):  Update call to get_range_strlen\n\tto use c_strlen_data pointer.  Change variable accesses to instead\n\tuse c_strlen_data data members.\n\n\t* gcc.dg/strlenopt-40.c: Disable a couple tests.\n\t* gcc.dg/strlenopt-48.c: Twiddle test.\n\t* gcc.dg/strlenopt-59.c: New test.\n\t* gcc.dg/tree-ssa/builtin-snprintf-5.c: New test.\n\t* g++.dg/init/strlen.C: New test.\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r267503", "tree": {"sha": "254a28a425e845f22414200219cf3f13aec1f0a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/254a28a425e845f22414200219cf3f13aec1f0a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d6655ebcc96030644f99eb1c431dd96e374db90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d6655ebcc96030644f99eb1c431dd96e374db90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d6655ebcc96030644f99eb1c431dd96e374db90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d6655ebcc96030644f99eb1c431dd96e374db90/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "79b1c2295b3031764904ce66ae294aa57aef50ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79b1c2295b3031764904ce66ae294aa57aef50ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79b1c2295b3031764904ce66ae294aa57aef50ae"}], "stats": {"total": 542, "additions": 371, "deletions": 171}, "files": [{"sha": "a57567cd8c92777012657441e96d686d35566f72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d6655ebcc96030644f99eb1c431dd96e374db90", "patch": "@@ -1,6 +1,27 @@\n 2019-01-01  Martin Sebor  <msebor@redhat.com>\n             Jeff Law  <law@redhat.com>\n \n+\t* gimple-fold.h (get_range_strlen): Update prototype.\n+\t* builtins.c (check_access): Update call to get_range_strlen to use\n+\tc_strlen_data pointer.   Change various variable accesses to instead\n+\tpull data from the c_strlen_data structure.\n+\t(check_strncat_sizes, expand_builtin_strncat): Likewise.\n+\t* calls.c (maybe_warn_nonstring_arg): Likewise.\n+\t* tree-ssa-strlen.c (maybe_diag_stxncpy_trunc): Likewise.  Reset\n+\tminimum length if maximum lengh is unknown.\n+\t* gimple-ssa-sprintf.c (get_string_length): Likewise.  Drop code\n+\tthat used c_strlen, it's no longer needed.  Restructure slightly.\n+\t(format_string): Set unlikely range appropriately.\n+\t* gimple-fold.c (get_range_strlen): Update comments.  Fix minor\n+\tformatting issues.\n+\t(get_range_strlen):  Accept c_strlen_data pointer for external\n+\tcall sites as well.  Pass through to call to internal get_range_strlen.\n+\tAdjust minlen, maxlen and maxbound as needed.\n+\t(get_maxval_strlen): Update comments.\n+\t(gimple_fold_builtin_strlen):  Update call to get_range_strlen\n+\tto use c_strlen_data pointer.  Change variable accesses to instead\n+\tuse c_strlen_data data members.\n+\n \t* gimple-fold.c (get_range_strlen): Update prototype.\n \t(get_range_strlen_tree): Update prototype.  Drop minlen/maxlen\n \tlocal variables.  Use pdata to return information to caller."}, {"sha": "28155b8c0aa8678bd252685143479042da6f7728", "filename": "gcc/builtins.c", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=5d6655ebcc96030644f99eb1c431dd96e374db90", "patch": "@@ -3341,7 +3341,10 @@ check_access (tree exp, tree, tree, tree dstwrite,\n \t     the upper bound given by MAXREAD add one to it for\n \t     the terminating nul.  Otherwise, set it to one for\n \t     the same reason, or to MAXREAD as appropriate.  */\n-\t  get_range_strlen (srcstr, range);\n+\t  c_strlen_data lendata = { };\n+\t  get_range_strlen (srcstr, &lendata, /* eltsize = */ 1);\n+\t  range[0] = lendata.minlen;\n+\t  range[1] = lendata.maxbound;\n \t  if (range[0] && (!maxread || TREE_CODE (maxread) == INTEGER_CST))\n \t    {\n \t      if (maxread && tree_int_cst_le (maxread, range[0]))\n@@ -4209,8 +4212,8 @@ check_strncat_sizes (tree exp, tree objsize)\n \n   /* Try to determine the range of lengths that the source expression\n      refers to.  */\n-  tree lenrange[2];\n-  get_range_strlen (src, lenrange);\n+  c_strlen_data lendata = { };\n+  get_range_strlen (src, &lendata, /* eltsize = */ 1);\n \n   /* Try to verify that the destination is big enough for the shortest\n      string.  */\n@@ -4224,8 +4227,8 @@ check_strncat_sizes (tree exp, tree objsize)\n     }\n \n   /* Add one for the terminating nul.  */\n-  tree srclen = (lenrange[0]\n-\t\t ? fold_build2 (PLUS_EXPR, size_type_node, lenrange[0],\n+  tree srclen = (lendata.minlen\n+\t\t ? fold_build2 (PLUS_EXPR, size_type_node, lendata.minlen,\n \t\t\t\tsize_one_node)\n \t\t : NULL_TREE);\n \n@@ -4277,21 +4280,24 @@ expand_builtin_strncat (tree exp, rtx)\n   tree slen = c_strlen (src, 1);\n \n   /* Try to determine the range of lengths that the source expression\n-     refers to.  */\n-  tree lenrange[2];\n-  if (slen)\n-    lenrange[0] = lenrange[1] = slen;\n-  else\n-    get_range_strlen (src, lenrange);\n+     refers to.  Since the lengths are only used for warning and not\n+     for code generation disable strict mode below.  */\n+  tree maxlen = slen;\n+  if (!maxlen)\n+    {\n+      c_strlen_data lendata = { };\n+      get_range_strlen (src, &lendata, /* eltsize = */ 1);\n+      maxlen = lendata.maxbound;\n+    }\n \n   /* Try to verify that the destination is big enough for the shortest\n      string.  First try to determine the size of the destination object\n      into which the source is being copied.  */\n   tree destsize = compute_objsize (dest, warn_stringop_overflow - 1);\n \n   /* Add one for the terminating nul.  */\n-  tree srclen = (lenrange[0]\n-\t\t ? fold_build2 (PLUS_EXPR, size_type_node, lenrange[0],\n+  tree srclen = (maxlen\n+\t\t ? fold_build2 (PLUS_EXPR, size_type_node, maxlen,\n \t\t\t\tsize_one_node)\n \t\t : NULL_TREE);\n "}, {"sha": "04aafde99f6d81b41cd157b19fdbc198eb68d746", "filename": "gcc/calls.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=5d6655ebcc96030644f99eb1c431dd96e374db90", "patch": "@@ -1569,9 +1569,11 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n   /* The bound argument to a bounded string function like strncpy.  */\n   tree bound = NULL_TREE;\n \n-  /* The range of lengths of a string argument to one of the comparison\n-     functions.  If the length is less than the bound it is used instead.  */\n-  tree lenrng[2] = { NULL_TREE, NULL_TREE };\n+  /* The longest known or possible string argument to one of the comparison\n+     functions.  If the length is less than the bound it is used instead.\n+     Since the length is only used for warning and not for code generation\n+     disable strict mode in the calls to get_range_strlen below.  */\n+  tree maxlen = NULL_TREE;\n \n   /* It's safe to call \"bounded\" string functions with a non-string\n      argument since the functions provide an explicit bound for this\n@@ -1591,11 +1593,15 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n \t   and to adjust the range of the bound of the bounded ones.  */\n \tfor (unsigned argno = 0;\n \t     argno < MIN (nargs, 2)\n-\t     && !(lenrng[1] && TREE_CODE (lenrng[1]) == INTEGER_CST); argno++)\n+\t       && !(maxlen && TREE_CODE (maxlen) == INTEGER_CST); argno++)\n \t  {\n \t    tree arg = CALL_EXPR_ARG (exp, argno);\n \t    if (!get_attr_nonstring_decl (arg))\n-\t      get_range_strlen (arg, lenrng);\n+\t      {\n+\t\tc_strlen_data lendata = { };\n+\t\tget_range_strlen (arg, &lendata, /* eltsize = */ 1);\n+\t\tmaxlen = lendata.maxbound;\n+\t      }\n \t  }\n       }\n       /* Fall through.  */\n@@ -1616,8 +1622,11 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n       {\n \ttree arg = CALL_EXPR_ARG (exp, 0);\n \tif (!get_attr_nonstring_decl (arg))\n-\t  get_range_strlen (arg, lenrng);\n-\n+\t  {\n+\t    c_strlen_data lendata = { };\n+\t    get_range_strlen (arg, &lendata, /* eltsize = */ 1);\n+\t    maxlen = lendata.maxbound;\n+\t  }\n \tif (nargs > 1)\n \t  bound = CALL_EXPR_ARG (exp, 1);\n \tbreak;\n@@ -1658,28 +1667,28 @@ maybe_warn_nonstring_arg (tree fndecl, tree exp)\n \t}\n     }\n \n-  if (lenrng[1] && TREE_CODE (lenrng[1]) == INTEGER_CST)\n+  if (maxlen && !integer_all_onesp (maxlen))\n     {\n       /* Add one for the nul.  */\n-      lenrng[1] = const_binop (PLUS_EXPR, TREE_TYPE (lenrng[1]),\n-\t\t\t       lenrng[1], size_one_node);\n+      maxlen = const_binop (PLUS_EXPR, TREE_TYPE (maxlen), maxlen,\n+\t\t\t    size_one_node);\n \n       if (!bndrng[0])\n \t{\n \t  /* Conservatively use the upper bound of the lengths for\n \t     both the lower and the upper bound of the operation.  */\n-\t  bndrng[0] = lenrng[1];\n-\t  bndrng[1] = lenrng[1];\n+\t  bndrng[0] = maxlen;\n+\t  bndrng[1] = maxlen;\n \t  bound = void_type_node;\n \t}\n       else\n \t{\n \t  /* Replace the bound on the operation with the upper bound\n \t     of the length of the string if the latter is smaller.  */\n-\t  if (tree_int_cst_lt (lenrng[1], bndrng[0]))\n-\t    bndrng[0] = lenrng[1];\n-\t  else if (tree_int_cst_lt (lenrng[1], bndrng[1]))\n-\t    bndrng[1] = lenrng[1];\n+\t  if (tree_int_cst_lt (maxlen, bndrng[0]))\n+\t    bndrng[0] = maxlen;\n+\t  else if (tree_int_cst_lt (maxlen, bndrng[1]))\n+\t    bndrng[1] = maxlen;\n \t}\n     }\n "}, {"sha": "6185f98e6bd60d2db85a6a2c91f6f976f479afb4", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 48, "deletions": 47, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=5d6655ebcc96030644f99eb1c431dd96e374db90", "patch": "@@ -1502,11 +1502,14 @@ get_range_strlen_tree (tree arg, bitmap *visited,\n   return true;\n }\n \n-/* Obtain the minimum and maximum string length or minimum and maximum\n-   value of ARG in LENGTH[0] and LENGTH[1], respectively.\n-   If ARG is an SSA name variable, follow its use-def chains.  When\n-   TYPE == 0, if LENGTH[1] is not equal to the length we determine or\n-   if we are unable to determine the length or value, return false.\n+/* For an ARG referencing one or more strings, try to obtain the range\n+   of their lengths, or the size of the largest array ARG referes to if\n+   the range of lengths cannot be determined, and store all in *PDATA.\n+   For an integer ARG (when RKIND == SRK_INT_VALUE), try to determine\n+   the maximum constant value.\n+   If ARG is an SSA_NAME, follow its use-def chains.  When RKIND ==\n+   SRK_STRLEN, then if PDATA->MAXLEN is not equal to the determined\n+   length or if we are unable to determine the length, return false.\n    VISITED is a bitmap of visited variables.\n    RKIND determines the kind of value or range to obtain (see\n    strlen_range_kind).\n@@ -1516,8 +1519,7 @@ get_range_strlen_tree (tree arg, bitmap *visited,\n    Return true if *PDATA was successfully populated and false otherwise.  */\n \n static bool\n-get_range_strlen (tree arg, bitmap *visited,\n-\t\t  strlen_range_kind rkind,\n+get_range_strlen (tree arg, bitmap *visited, strlen_range_kind rkind,\n \t\t  c_strlen_data *pdata, bool *flexp, unsigned eltsize)\n {\n \n@@ -1612,6 +1614,7 @@ get_range_strlen (tree arg, bitmap *visited,\n         return false;\n     }\n }\n+\n /* Determine the minimum and maximum value or string length that ARG\n    refers to and store each in the first two elements of MINMAXLEN.\n    For expressions that point to strings of unknown lengths that are\n@@ -1638,47 +1641,39 @@ get_range_strlen (tree arg, bitmap *visited,\n    4 for wide characer strings.  ELTSIZE is by default 1.  */\n \n bool\n-get_range_strlen (tree arg, tree minmaxlen[2], unsigned eltsize,\n-\t\t  bool strict, tree *nonstr /* = NULL */)\n+get_range_strlen (tree arg, c_strlen_data *pdata, unsigned eltsize, bool strict)\n {\n   bitmap visited = NULL;\n \n-  minmaxlen[0] = NULL_TREE;\n-  minmaxlen[1] = NULL_TREE;\n-\n-  tree nonstrbuf;\n-  if (!nonstr)\n-    nonstr = &nonstrbuf;\n-  *nonstr = NULL_TREE;\n-\n   bool flexarray = false;\n-  c_strlen_data lendata = { };\n-  if (!get_range_strlen (arg, &visited,\n-\t\t\t strict ? SRK_LENRANGE : SRK_LENRANGE_2,\n-\t\t\t &lendata, &flexarray, eltsize))\n-    {\n-      minmaxlen[0] = NULL_TREE;\n-      minmaxlen[1] = NULL_TREE;\n-    }\n-  else\n+  if (!get_range_strlen (arg, &visited, strict ? SRK_LENRANGE : SRK_LENRANGE_2, pdata, &flexarray, eltsize))\n     {\n-      minmaxlen[0] = lendata.minlen;\n-      minmaxlen[1] = lendata.maxlen;\n+      /* On failure extend the length range to an impossible maximum\n+\t (a valid MAXLEN must be less than PTRDIFF_MAX - 1).  Other\n+\t members can stay unchanged regardless.  */\n+      pdata->minlen = ssize_int (0);\n+      pdata->maxlen = build_all_ones_cst (size_type_node);\n     }\n+  else if (!pdata->minlen)\n+    pdata->minlen = ssize_int (0);\n+\n+  /* Unless its null, leave the more conservative MAXBOUND unchanged.  */\n+  if (!pdata->maxbound)\n+    pdata->maxbound = pdata->maxlen;\n \n-  *nonstr = lendata.decl;\n   if (visited)\n     BITMAP_FREE (visited);\n \n   return flexarray;\n }\n \n-/* Return the maximum string length for ARG, counting by TYPE\n-   (1, 2 or 4 for normal or wide chars).  NONSTR indicates\n-   if the caller is prepared to handle unterminated strings.\n+/* Return the maximum value for ARG given RKIND (see strlen_range_kind).\n+   For ARG of pointer types, NONSTR indicates if the caller is prepared\n+   to handle unterminated strings.   For integer ARG and when RKIND ==\n+   SRK_INT_VALUE, NONSTR must be null.\n \n-   If an unterminated string is discovered and our caller handles\n-   unterminated strings, then bubble up the offending DECL and\n+   If an unterminated array is discovered and our caller handles\n+   unterminated arrays, then bubble up the offending DECL and\n    return the maximum size.  Otherwise return NULL.  */\n \n static tree\n@@ -1692,10 +1687,15 @@ get_maxval_strlen (tree arg, strlen_range_kind rkind, tree *nonstr = NULL)\n \n   bitmap visited = NULL;\n \n-  bool dummy;\n+  /* Reset DATA.MAXLEN if the call fails or when DATA.MAXLEN\n+     is unbounded.  */\n   c_strlen_data lendata = { };\n+  bool dummy;\n   if (!get_range_strlen (arg, &visited, rkind, &lendata, &dummy, 1))\n     lendata.maxlen = NULL_TREE;\n+  else if (lendata.maxlen && integer_all_onesp (lendata.maxlen))\n+    lendata.maxlen = NULL_TREE;\n+\n   if (visited)\n     BITMAP_FREE (visited);\n \n@@ -3668,21 +3668,19 @@ gimple_fold_builtin_strlen (gimple_stmt_iterator *gsi)\n   wide_int minlen;\n   wide_int maxlen;\n \n-  /* Set to non-null if ARG refers to an unterminated array.  */\n-  tree nonstr;\n-  tree lenrange[2];\n-  if (!get_range_strlen (arg, lenrange, 1, true, &nonstr)\n-      && !nonstr\n-      && lenrange[0] && TREE_CODE (lenrange[0]) == INTEGER_CST\n-      && lenrange[1] && TREE_CODE (lenrange[1]) == INTEGER_CST)\n+  c_strlen_data lendata = { };\n+  if (!get_range_strlen (arg, &lendata, /* eltsize = */ 1)\n+      && !lendata.decl\n+      && lendata.minlen && TREE_CODE (lendata.minlen) == INTEGER_CST\n+      && lendata.maxlen && TREE_CODE (lendata.maxlen) == INTEGER_CST)\n     {\n       /* The range of lengths refers to either a single constant\n \t string or to the longest and shortest constant string\n \t referenced by the argument of the strlen() call, or to\n \t the strings that can possibly be stored in the arrays\n \t the argument refers to.  */\n-      minlen = wi::to_wide (lenrange[0]);\n-      maxlen = wi::to_wide (lenrange[1]);\n+      minlen = wi::to_wide (lendata.minlen);\n+      maxlen = wi::to_wide (lendata.maxlen);\n     }\n   else\n     {\n@@ -3694,9 +3692,12 @@ gimple_fold_builtin_strlen (gimple_stmt_iterator *gsi)\n \n   if (minlen == maxlen)\n     {\n-      lenrange[0] = force_gimple_operand_gsi (gsi, lenrange[0], true, NULL,\n-\t\t\t\t\t      true, GSI_SAME_STMT);\n-      replace_call_with_value (gsi, lenrange[0]);\n+      /* Fold the strlen call to a constant.  */\n+      tree type = TREE_TYPE (lendata.minlen);\n+      tree len = force_gimple_operand_gsi (gsi,\n+\t\t\t\t\t   wide_int_to_tree (type, minlen),\n+\t\t\t\t\t   true, NULL, true, GSI_SAME_STMT);\n+      replace_call_with_value (gsi, len);\n       return true;\n     }\n "}, {"sha": "35f1ba26953c10f1fb4192c228cb52173f6d6996", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=5d6655ebcc96030644f99eb1c431dd96e374db90", "patch": "@@ -25,8 +25,8 @@ along with GCC; see the file COPYING3.  If not see\n extern tree create_tmp_reg_or_ssa_name (tree, gimple *stmt = NULL);\n extern tree canonicalize_constructor_val (tree, tree);\n extern tree get_symbol_constant_value (tree);\n-extern bool get_range_strlen (tree, tree[2], unsigned = 1,\n-\t\t\t      bool = false, tree * = NULL);\n+struct c_strlen_data;\n+extern bool get_range_strlen (tree, c_strlen_data *, unsigned eltsize, bool = false);\n extern void gimplify_and_update_call_from_tree (gimple_stmt_iterator *, tree);\n extern bool fold_stmt (gimple_stmt_iterator *);\n extern bool fold_stmt (gimple_stmt_iterator *, tree (*) (tree));"}, {"sha": "65aab5ba0924773b8d2fbbde0e4bc932f3006551", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 63, "deletions": 79, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=5d6655ebcc96030644f99eb1c431dd96e374db90", "patch": "@@ -2003,90 +2003,73 @@ get_string_length (tree str, unsigned eltsize)\n   if (!str)\n     return fmtresult ();\n \n-  c_strlen_data data = { };\n-  tree slen = c_strlen (str, 1, &data, eltsize);\n-  if (slen && TREE_CODE (slen) == INTEGER_CST)\n-    {\n-      /* The string is properly terminated and\n-\t we know its length.  */\n-      fmtresult res (tree_to_shwi (slen));\n-      res.nonstr = NULL_TREE;\n-      return res;\n-    }\n-  else if (!slen\n-\t   && data.decl\n-\t   && data.minlen\n-\t   && TREE_CODE (data.minlen) == INTEGER_CST)\n-    {\n-      /* STR was not properly NUL terminated, but we have\n-\t length information about the unterminated string.  */\n-      fmtresult res (tree_to_shwi (data.minlen));\n-      res.nonstr = data.decl;\n-      return res;\n-    }\n-\n   /* Determine the length of the shortest and longest string referenced\n      by STR.  Strings of unknown lengths are bounded by the sizes of\n      arrays that subexpressions of STR may refer to.  Pointers that\n-     aren't known to point any such arrays result in LENRANGE[1] set\n-     to SIZE_MAX.  NONSTR is set to the declaration of the constant\n-     array that is known not to be nul-terminated.  */\n-  tree lenrange[2];\n-  tree nonstr;\n-  bool flexarray = get_range_strlen (str, lenrange, eltsize, false, &nonstr);\n+     aren't known to point any such arrays result in LENDATA.MAXLEN\n+     set to SIZE_MAX.  */\n+  c_strlen_data lendata = { };\n+  bool flexarray = get_range_strlen (str, &lendata, eltsize);\n+\n+  /* Return the default result when nothing is known about the string. */\n+  if (integer_all_onesp (lendata.maxbound)\n+      && integer_all_onesp (lendata.maxlen))\n+    return fmtresult ();\n \n-  if (lenrange [0] || lenrange [1])\n+  HOST_WIDE_INT min\n+    = (tree_fits_uhwi_p (lendata.minlen)\n+       ? tree_to_uhwi (lendata.minlen)\n+       : 0);\n+\n+  HOST_WIDE_INT max\n+    = (tree_fits_uhwi_p (lendata.maxbound)\n+       ? tree_to_uhwi (lendata.maxbound)\n+       : HOST_WIDE_INT_M1U);\n+\n+  const bool unbounded = flexarray || integer_all_onesp (lendata.maxlen);\n+\n+  /* Set the max/likely counters to unbounded when a minimum is known\n+     but the maximum length isn't bounded.  This implies that STR is\n+     a conditional expression involving a string of known length and\n+     and an expression of unknown/unbounded length.  */\n+  if (min\n+      && (unsigned HOST_WIDE_INT)min < HOST_WIDE_INT_M1U\n+      && unbounded)\n+    max = HOST_WIDE_INT_M1U;\n+\n+  /* get_range_strlen() returns the target value of SIZE_MAX for\n+     strings of unknown length.  Bump it up to HOST_WIDE_INT_M1U\n+     which may be bigger.  */\n+  if ((unsigned HOST_WIDE_INT)min == target_size_max ())\n+    min = HOST_WIDE_INT_M1U;\n+  if ((unsigned HOST_WIDE_INT)max == target_size_max ())\n+    max = HOST_WIDE_INT_M1U;\n+\n+  fmtresult res (min, max);\n+  res.nonstr = lendata.decl;\n+\n+  /* Set RES.KNOWNRANGE to true if and only if all strings referenced\n+     by STR are known to be bounded (though not necessarily by their\n+     actual length but perhaps by their maximum possible length).  */\n+  if (res.range.max < target_int_max ())\n     {\n-      HOST_WIDE_INT min\n-\t= (tree_fits_uhwi_p (lenrange[0])\n-\t   ? tree_to_uhwi (lenrange[0])\n-\t   : 0);\n-\n-      HOST_WIDE_INT max\n-\t= (tree_fits_uhwi_p (lenrange[1])\n-\t   ? tree_to_uhwi (lenrange[1])\n-\t   : HOST_WIDE_INT_M1U);\n-\n-      /* get_range_strlen() returns the target value of SIZE_MAX for\n-\t strings of unknown length.  Bump it up to HOST_WIDE_INT_M1U\n-\t which may be bigger.  */\n-      if ((unsigned HOST_WIDE_INT)min == target_size_max ())\n-\tmin = HOST_WIDE_INT_M1U;\n-      if ((unsigned HOST_WIDE_INT)max == target_size_max ())\n-\tmax = HOST_WIDE_INT_M1U;\n-\n-      fmtresult res (min, max);\n-      res.nonstr = nonstr;\n-\n-      /* Set RES.KNOWNRANGE to true if and only if all strings referenced\n-\t by STR are known to be bounded (though not necessarily by their\n-\t actual length but perhaps by their maximum possible length).  */\n-      if (res.range.max < target_int_max ())\n-\t{\n-\t  res.knownrange = true;\n-\t  /* When the the length of the longest string is known and not\n-\t     excessive use it as the likely length of the string(s).  */\n-\t  res.range.likely = res.range.max;\n-\t}\n-      else\n-\t{\n-\t  /* When the upper bound is unknown (it can be zero or excessive)\n-\t     set the likely length to the greater of 1 and the length of\n-\t     the shortest string and reset the lower bound to zero.  */\n-\t  res.range.likely = res.range.min ? res.range.min : warn_level > 1;\n-\t  res.range.min = 0;\n-\t}\n-\n-      /* If the range of string length has been estimated from the size\n-\t of an array at the end of a struct assume that it's longer than\n-\t the array bound says it is in case it's used as a poor man's\n-\t flexible array member, such as in struct S { char a[4]; };  */\n-      res.range.unlikely = flexarray ? HOST_WIDE_INT_MAX : res.range.max;\n-\n-      return res;\n+      res.knownrange = true;\n+      /* When the the length of the longest string is known and not\n+\t excessive use it as the likely length of the string(s).  */\n+      res.range.likely = res.range.max;\n+    }\n+  else\n+    {\n+      /* When the upper bound is unknown (it can be zero or excessive)\n+\t set the likely length to the greater of 1 and the length of\n+\t the shortest string and reset the lower bound to zero.  */\n+      res.range.likely = res.range.min ? res.range.min : warn_level > 1;\n+      res.range.min = 0;\n     }\n \n-  return fmtresult ();\n+  res.range.unlikely = unbounded ? HOST_WIDE_INT_MAX : res.range.max;\n+\n+  return res;\n }\n \n /* Return the minimum and maximum number of characters formatted\n@@ -2326,6 +2309,8 @@ format_string (const directive &dir, tree arg, vr_values *)\n \t  if ((unsigned HOST_WIDE_INT)dir.prec[1] < slen.range.max)\n \t    res.range.max = dir.prec[1];\n \t  res.range.likely = dir.prec[1] ? warn_level > 1 : 0;\n+\t  if ((unsigned HOST_WIDE_INT)dir.prec[1] < slen.range.unlikely)\n+\t    res.range.unlikely = dir.prec[1];\n \t}\n       else if (slen.range.min >= target_int_max ())\n \t{\n@@ -2335,6 +2320,7 @@ format_string (const directive &dir, tree arg, vr_values *)\n \t     empty, while at level 1 they are assumed to be one byte\n \t     long.  */\n \t  res.range.likely = warn_level > 1;\n+\t  res.range.unlikely = HOST_WIDE_INT_MAX;\n \t}\n       else\n \t{\n@@ -2344,8 +2330,6 @@ format_string (const directive &dir, tree arg, vr_values *)\n \t  if (res.range.likely >= target_int_max ())\n \t    res.range.likely = warn_level > 1;\n \t}\n-\n-      res.range.unlikely = res.range.max;\n     }\n \n   /* If the argument isn't a nul-terminated string and the number"}, {"sha": "60eaac7d2cd162d06ad01a94e1172b8d6c79ee76", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5d6655ebcc96030644f99eb1c431dd96e374db90", "patch": "@@ -1,3 +1,12 @@\n+2019-01-01  Martin Sebor  <msebor@redhat.com>\n+            Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/strlenopt-40.c: Disable a couple tests.\n+\t* gcc.dg/strlenopt-48.c: Twiddle test slightly.\n+\t* gcc.dg/strlenopt-59.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-snprintf-5.c: New test.\n+\t* g++.dg/init/strlen.C: New test.\n+\n 2019-01-01  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/82743"}, {"sha": "aa8950e2dc08b27af94cd7e96ec0c4e025e433fa", "filename": "gcc/testsuite/g++.dg/init/strlen.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fstrlen.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fstrlen.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fstrlen.C?ref=5d6655ebcc96030644f99eb1c431dd96e374db90", "patch": "@@ -0,0 +1,43 @@\n+// Test to verify that the strlen() optimization doesn't make assumptions\n+// about the static type of the object pointed to by its argument.  See\n+// the following thread for background:\n+//   https://gcc.gnu.org/ml/gcc-patches/2018-08/msg00260.html\n+\n+// { dg-do run }\n+// { dg-options \"-O2 -Wall -fdump-tree-optimized\" }\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void *operator new[] (size_t, void *p) { return p; }\n+\n+struct S { int x; char a[1]; char b[64]; };\n+\n+__attribute__ ((noipa)) void\n+init (char *s)\n+{\n+  *s++ = '1';\n+  *s++ = '\\0';\n+}\n+\n+__attribute__ ((noipa)) void\n+test_dynamic_type (S *p)\n+{\n+  // The placement new call below isn't strictly valid because it\n+  // creates an object that is larger than the space of the p->a\n+  // subobject in which it is created.  However, the corresponding\n+  // GIMPLE considers it valid and there's apparently no way to\n+  // distinguish invalid cases from ones like it that might be valid.\n+  // If/when GIMPLE changes to make this possible this test can be\n+  // removed.\n+  char *q = new (p->a) char [16];\n+\n+  init (q);\n+\n+  if (0 == __builtin_strlen (q))\n+    __builtin_abort();\n+}\n+\n+int main ()\n+{\n+  test_dynamic_type (new S);\n+}"}, {"sha": "e24b510deebef184091390be8f4eec13f0899bbf", "filename": "gcc/testsuite/gcc.dg/strlenopt-40.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-40.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-40.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-40.c?ref=5d6655ebcc96030644f99eb1c431dd96e374db90", "patch": "@@ -124,8 +124,8 @@ void elim_global_arrays (int i)\n   ELIM_TRUE (strlen (a7) < sizeof a7);\n \n   ELIM_TRUE (strlen (ax) != DIFF_MAX);\n-  ELIM_TRUE (strlen (ax) != DIFF_MAX - 1);\n-  ELIM_TRUE (strlen (ax) < DIFF_MAX - 1);\n+  /* ELIM_TRUE (strlen (ax) != DIFF_MAX - 1); */\n+  /* ELIM_TRUE (strlen (ax) < DIFF_MAX - 1); */\n }\n \n void elim_pointer_to_arrays (void)"}, {"sha": "179edd82a43338ca3e47058d711a47b6ac32da23", "filename": "gcc/testsuite/gcc.dg/strlenopt-48.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-48.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-48.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-48.c?ref=5d6655ebcc96030644f99eb1c431dd96e374db90", "patch": "@@ -11,23 +11,23 @@ void f (void)\n {\n   extern char a[2][1];\n   int n = strlen (a[1]);\n-  if (n)\n+  if (n >= sizeof a)\n     abort();\n }\n \n void g (void)\n {\n   extern char b[3][2][1];\n   int n = strlen (b[2][1]);\n-  if (n)\n+  if (n >= sizeof b)\n     abort();\n }\n \n void h (void)\n {\n   extern char c[4][3][2][1];\n   int n = strlen (c[3][2][1]);\n-  if (n)\n+  if (n >= sizeof c)\n     abort();\n }\n "}, {"sha": "9bacf8748765d26d6cc89c30d946ef40f53ed31d", "filename": "gcc/testsuite/gcc.dg/strlenopt-59.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-59.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-59.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-59.c?ref=5d6655ebcc96030644f99eb1c431dd96e374db90", "patch": "@@ -0,0 +1,73 @@\n+/* Verify that strlen() calls with constant conditional expressions are\n+   eliminated as expected.\n+\n+   { dg-do compile }\n+   { dg-options \"-O1 -fdump-tree-optimized\" }  */\n+\n+extern void abort (void);\n+extern __SIZE_TYPE__ strlen (const char*);\n+\n+\n+#define CAT(x, y) x ## y\n+#define CONCAT(x, y) CAT (x, y)\n+#define FAILNAME(name) CONCAT (call_ ## name ##_on_line_, __LINE__)\n+\n+#define FAIL(name) do {\t\t\t\t\\\n+    extern void FAILNAME (name) (void);\t\t\\\n+    FAILNAME (name)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macros to emit a call to funcation named\n+     call_failed_to_be_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ELIM(expr) \\\n+  if ((expr)) FAIL (test_not_eliminated); else (void)0\n+\n+extern char a3[3];\n+extern char a7[7];\n+\n+struct MemArrays { char a[7], b[9]; };\n+\n+struct MemArrays ma;\n+\n+void test_elim_condexpr (int i)\n+{\n+  ELIM (6 < strlen (i ? \"\" : \"123456\"));\n+  ELIM (6 < strlen (i ? \"123456\" : \"\"));\n+\n+  ELIM (4 < strlen (i < 1 ? \"a\" : i == 1 ? \"ab\" : \"abc\"));\n+\n+  ELIM (3 < strlen (i ? \"\" : a3));\n+  ELIM (3 < strlen (i ? a3 : \"1\"));\n+\n+  ELIM (6 < strlen (i ? \"12\" : a7));\n+  ELIM (6 < strlen (i ? a7 : \"123\"));\n+\n+  ELIM (6 < strlen (i ? \"1234\" : a7));\n+  ELIM (7 < strlen (i ? a7 : \"1234567\"));\n+\n+  ELIM (3 < strlen (i < 1 ? \"a\" : i == 1 ? \"ab\" : a3));\n+  ELIM (3 < strlen (i < 1 ? \"a\" : i == 1 ? a3 : \"abc\"));\n+  ELIM (3 < strlen (i < 1 ? a3 : i == 1 ? \"a\" : \"abc\"));\n+\n+  ELIM (6 < strlen (i < 1 ? \"a\" : i == 1 ? \"ab\" : a7));\n+  ELIM (6 < strlen (i < 1 ? \"a\" : i == 1 ? a7 : \"abc\"));\n+  ELIM (6 < strlen (i < 1 ? a7 : i == 1 ? \"a\" : \"abc\"));\n+\n+  ELIM (6 < strlen (i < 1 ? \"a\" : i == 1 ? a7 : a3));\n+  ELIM (6 < strlen (i < 1 ? a7 : i == 1 ? \"a\" : a3));\n+\n+  {\n+    enum { maxlen = sizeof ma - 1 };\n+    ELIM (maxlen < strlen (ma.a));\n+  }\n+\n+  {\n+    enum { maxlen = sizeof ma - __builtin_offsetof (struct MemArrays, b) - 1 };\n+    ELIM (maxlen < strlen (ma.b));\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"test_not_eliminated_\" 0 \"optimized\" } } */"}, {"sha": "ad9a99b5073240b237244bacdab61ba762f899a2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-snprintf-5.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-snprintf-5.c?ref=5d6655ebcc96030644f99eb1c431dd96e374db90", "patch": "@@ -0,0 +1,51 @@\n+/*\n+  { dg-do compile }\n+  { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void abort (void);\n+extern int snprintf (char*, size_t, const char*, ...);\n+\n+const char s0[] = \"\";\n+const char s1[] = \"a\";\n+const char s2[] = \"ab\";\n+\n+extern char ax[];\n+extern const char* const ptr;\n+\n+#define CAT(x, y)      x ## y\n+#define CONCAT(x, y)   CAT (x, y)\n+#define TEST           CONCAT (test_on_line_, __LINE__)\n+\n+#define KEEP(expr) do {\t\t\t\t\\\n+    if ((expr))\t{\t\t\t\t\\\n+      extern void TEST (void);\t\t\t\\\n+      TEST ();\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+void test_literal (int i)\n+{\n+  KEEP (0 < snprintf (0, 0, \"%s\", i ? \"\" : ax));\n+  KEEP (1 < snprintf (0, 0, \"%s\", i ? ax : \"1\"));\n+  KEEP (2 < snprintf (0, 0, \"%s\", i ? \"12\" : ptr));\n+\n+  KEEP (1 > snprintf (0, 0, \"%s\", i ? \"\" : ax));\n+  KEEP (1 > snprintf (0, 0, \"%s\", i ? ax : \"1\"));\n+  KEEP (2 > snprintf (0, 0, \"%s\", i ? \"12\" : ptr));\n+}\n+\n+void test_cststr (int i)\n+{\n+  KEEP (0 < snprintf (0, 0, \"%s\", i ? s0 : ax));\n+  KEEP (1 < snprintf (0, 0, \"%s\", i ? ax : s1));\n+  KEEP (2 < snprintf (0, 0, \"%s\", i ? s2 : ptr));\n+\n+  KEEP (1 > snprintf (0, 0, \"%s\", i ? s0 : ax));\n+  KEEP (1 > snprintf (0, 0, \"%s\", i ? ax : s1));\n+  KEEP (2 > snprintf (0, 0, \"%s\", i ? s2 : ptr));\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"test_on_line_\" 12 \"optimized\" } } */"}, {"sha": "f64bc9bea79725b53151c513eb374a89598462fa", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d6655ebcc96030644f99eb1c431dd96e374db90/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=5d6655ebcc96030644f99eb1c431dd96e374db90", "patch": "@@ -1989,15 +1989,18 @@ maybe_diag_stxncpy_trunc (gimple_stmt_iterator gsi, tree src, tree cnt)\n     lenrange[0] = lenrange[1] = wi::shwi (~sidx, prec);\n   else\n     {\n-      tree range[2];\n-      get_range_strlen (src, range);\n-      if (range[0] != NULL_TREE\n-\t  && TREE_CODE (range[0]) == INTEGER_CST\n-\t  && range[1] != NULL_TREE\n-\t  && TREE_CODE (range[1]) == INTEGER_CST)\n-\t{\n-\t  lenrange[0] = wi::to_wide (range[0], prec);\n-\t  lenrange[1] = wi::to_wide (range[1], prec);\n+      c_strlen_data lendata = { };\n+      get_range_strlen (src, &lendata, /* eltsize = */1);\n+      if (TREE_CODE (lendata.minlen) == INTEGER_CST\n+\t  && TREE_CODE (lendata.maxbound) == INTEGER_CST)\n+\t{\n+\t  /* When LENDATA.MAXLEN is unknown, reset LENDATA.MINLEN\n+\t     which stores the length of the shortest known string.  */\n+\t  if (integer_all_onesp (lendata.maxlen))\n+\t    lenrange[0] = wi::shwi (0, prec);\n+\t  else\n+\t    lenrange[0] = wi::to_wide (lendata.minlen, prec);\n+\t  lenrange[1] = wi::to_wide (lendata.maxbound, prec);\n \t}\n       else\n \t{"}]}