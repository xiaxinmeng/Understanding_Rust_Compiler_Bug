{"sha": "36cbfdb06604b63e743d3644fdec7dd20d7c0843", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZjYmZkYjA2NjA0YjYzZTc0M2QzNjQ0ZmRlYzdkZDIwZDdjMDg0Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-10-08T16:23:26Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-10-08T16:23:26Z"}, "message": "Further P0135 refinement.\n\n\t* call.c (build_user_type_conversion_1): Consider conversions from\n\ta single element in an initializer-list.\n\t(build_temp): Undo early_elide_copy change.\n\t(build_over_call): Check that we don't try to copy a TARGET_EXPR\n\tin C++17 mode.  Set user_conv_p here.\n\t(convert_like_real): Not here.\n\t(check_self_delegation): Split out from...\n\t(build_special_member_call): ...here.  Handle C++17 copy elision.\n\t* cvt.c (early_elide_copy): Remove.\n\t(ocp_convert): Undo early_elide_copy change.\n\t* except.c (build_throw): Likewise.\n\t* init.c (expand_default_init): Likewise.\n\t* typeck.c (cp_build_modify_expr): Likewise.\n\nFrom-SVN: r240889", "tree": {"sha": "af475d0e794d94b605e4e12b2a7ae82b9d1972cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af475d0e794d94b605e4e12b2a7ae82b9d1972cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36cbfdb06604b63e743d3644fdec7dd20d7c0843", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36cbfdb06604b63e743d3644fdec7dd20d7c0843", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36cbfdb06604b63e743d3644fdec7dd20d7c0843", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36cbfdb06604b63e743d3644fdec7dd20d7c0843/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "80994c4654c32987e32430121e442df861226966", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80994c4654c32987e32430121e442df861226966", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80994c4654c32987e32430121e442df861226966"}], "stats": {"total": 173, "additions": 112, "deletions": 61}, "files": [{"sha": "0bd0457f01a7c283cb57f93fe453c3319af83f95", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cbfdb06604b63e743d3644fdec7dd20d7c0843/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cbfdb06604b63e743d3644fdec7dd20d7c0843/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=36cbfdb06604b63e743d3644fdec7dd20d7c0843", "patch": "@@ -1,3 +1,20 @@\n+2016-10-07  Jason Merrill  <jason@redhat.com>\n+\n+\tFurther P0135 refinement.\n+\t* call.c (build_user_type_conversion_1): Consider conversions from\n+\ta single element in an initializer-list.\n+\t(build_temp): Undo early_elide_copy change.\n+\t(build_over_call): Check that we don't try to copy a TARGET_EXPR\n+\tin C++17 mode.  Set user_conv_p here.\n+\t(convert_like_real): Not here.\n+\t(check_self_delegation): Split out from...\n+\t(build_special_member_call): ...here.  Handle C++17 copy elision.\n+\t* cvt.c (early_elide_copy): Remove.\n+\t(ocp_convert): Undo early_elide_copy change.\n+\t* except.c (build_throw): Likewise.\n+\t* init.c (expand_default_init): Likewise.\n+\t* typeck.c (cp_build_modify_expr): Likewise.\n+\n 2016-10-07  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/64433"}, {"sha": "4bee487857d7a63a19ef498fe87686b293195d1c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 78, "deletions": 20, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cbfdb06604b63e743d3644fdec7dd20d7c0843/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cbfdb06604b63e743d3644fdec7dd20d7c0843/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=36cbfdb06604b63e743d3644fdec7dd20d7c0843", "patch": "@@ -3671,6 +3671,14 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n        creating a garbage BASELINK; constructors can't be inherited.  */\n     ctors = lookup_fnfields_slot (totype, complete_ctor_identifier);\n \n+  /* FIXME P0135 doesn't say what to do in C++17 about list-initialization from\n+     a single element.  For now, let's handle constructors as before and also\n+     consider conversion operators from the element.  */\n+  if (cxx_dialect >= cxx1z\n+      && BRACE_ENCLOSED_INITIALIZER_P (expr)\n+      && CONSTRUCTOR_NELTS (expr) == 1)\n+    fromtype = TREE_TYPE (CONSTRUCTOR_ELT (expr, 0)->value);\n+\n   if (MAYBE_CLASS_TYPE_P (fromtype))\n     {\n       tree to_nonref = non_reference (totype);\n@@ -3745,7 +3753,13 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n     }\n \n   if (conv_fns)\n-    first_arg = expr;\n+    {\n+      if (BRACE_ENCLOSED_INITIALIZER_P (expr))\n+\t/* FIXME see above about C++17.  */\n+\tfirst_arg = CONSTRUCTOR_ELT (expr, 0)->value;\n+      else\n+\tfirst_arg = expr;\n+    }\n \n   for (; conv_fns; conv_fns = TREE_CHAIN (conv_fns))\n     {\n@@ -6367,11 +6381,6 @@ build_temp (tree expr, tree type, int flags,\n \n   *diagnostic_kind = DK_UNSPECIFIED;\n \n-  if (TREE_CODE (expr) == CONSTRUCTOR)\n-    expr = get_target_expr_sfinae (expr, complain);\n-  if (early_elide_copy (type, expr))\n-    return expr;\n-\n   /* If the source is a packed field, calling the copy constructor will require\n      binding the field to the reference parameter to the copy constructor, and\n      we'll end up with an infinite loop.  If we can use a bitwise copy, then\n@@ -6563,7 +6572,6 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n       {\n \tstruct z_candidate *cand = convs->cand;\n \ttree convfn = cand->fn;\n-\tunsigned i;\n \n \t/* When converting from an init list we consider explicit\n \t   constructors, but actually trying to call one is an error.  */\n@@ -6609,12 +6617,10 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \n \texpr = mark_rvalue_use (expr);\n \n-\t/* Set user_conv_p on the argument conversions, so rvalue/base\n-\t   handling knows not to allow any more UDCs.  */\n-\tfor (i = 0; i < cand->num_convs; ++i)\n-\t  cand->convs[i]->user_conv_p = true;\n-\n-\texpr = build_over_call (cand, LOOKUP_NORMAL, complain);\n+\t/* Pass LOOKUP_NO_CONVERSION so rvalue/base handling knows not to allow\n+\t   any more UDCs.  */\n+\texpr = build_over_call (cand, LOOKUP_NORMAL|LOOKUP_NO_CONVERSION,\n+\t\t\t\tcomplain);\n \n \t/* If this is a constructor or a function returning an aggr type,\n \t   we need to build up a TARGET_EXPR.  */\n@@ -6792,6 +6798,10 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \tflags |= LOOKUP_ONLYCONVERTING;\n       if (convs->rvaluedness_matches_p)\n \tflags |= LOOKUP_PREFER_RVALUE;\n+      if (TREE_CODE (expr) == TARGET_EXPR\n+\t  && TARGET_EXPR_LIST_INIT_P (expr))\n+\t/* Copy-list-initialization doesn't actually involve a copy.  */\n+\treturn expr;\n       expr = build_temp (expr, totype, flags, &diag_kind, complain);\n       if (diag_kind && complain)\n \t{\n@@ -7710,6 +7720,13 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t\t       \"  (you can disable this with -fno-deduce-init-list)\");\n \t    }\n \t}\n+\n+      /* Set user_conv_p on the argument conversions, so rvalue/base handling\n+\t knows not to allow any more UDCs.  This needs to happen after we\n+\t process cand->warnings.  */\n+      if (flags & LOOKUP_NO_CONVERSION)\n+\tconv->user_conv_p = true;\n+\n       val = convert_like_with_context (conv, arg, fn, i - is_method,\n \t\t\t\t       conversion_warning\n \t\t\t\t       ? complain\n@@ -7825,8 +7842,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t subobject.  */\n       if (CHECKING_P && cxx_dialect >= cxx1z)\n \tgcc_assert (TREE_CODE (arg) != TARGET_EXPR\n-\t\t    // FIXME we shouldn't copy for direct-init either\n-\t\t    || !(flags & LOOKUP_ONLYCONVERTING)\n+\t\t    || seen_error ()\n \t\t    /* See unsafe_copy_elision_p.  */\n \t\t    || DECL_BASE_CONSTRUCTOR_P (fn));\n \n@@ -8089,6 +8105,19 @@ in_charge_arg_for_name (tree name)\n   return NULL_TREE;\n }\n \n+/* We've built up a constructor call RET.  Complain if it delegates to the\n+   constructor we're currently compiling.  */\n+\n+static void\n+check_self_delegation (tree ret)\n+{\n+  if (TREE_CODE (ret) == TARGET_EXPR)\n+    ret = TARGET_EXPR_INITIAL (ret);\n+  tree fn = cp_get_callee_fndecl (ret);\n+  if (fn && DECL_ABSTRACT_ORIGIN (fn) == current_function_decl)\n+    error (\"constructor delegates to itself\");\n+}\n+\n /* Build a call to a constructor, destructor, or an assignment\n    operator for INSTANCE, an expression with class type.  NAME\n    indicates the special member function to call; *ARGS are the\n@@ -8162,6 +8191,38 @@ build_special_member_call (tree instance, tree name, vec<tree, va_gc> **args,\n \n   gcc_assert (instance != NULL_TREE);\n \n+  /* In C++17, \"If the initializer expression is a prvalue and the\n+     cv-unqualified version of the source type is the same class as the class\n+     of the destination, the initializer expression is used to initialize the\n+     destination object.\"  Handle that here to avoid doing overload\n+     resolution.  */\n+  if (cxx_dialect >= cxx1z\n+      && args && vec_safe_length (*args) == 1\n+      && name == complete_ctor_identifier)\n+    {\n+      tree arg = (**args)[0];\n+\n+      /* FIXME P0135 doesn't say how to handle direct initialization from a\n+\t type with a suitable conversion operator.  Let's handle it like\n+\t copy-initialization, but allowing explict conversions.  */\n+      if (!reference_related_p (class_type, TREE_TYPE (arg)))\n+\targ = perform_implicit_conversion_flags (class_type, arg,\n+\t\t\t\t\t\t tf_warning, flags);\n+      if (TREE_CODE (arg) == TARGET_EXPR\n+\t  && (same_type_ignoring_top_level_qualifiers_p\n+\t      (class_type, TREE_TYPE (arg))))\n+\t{\n+\t  if (is_dummy_object (instance))\n+\t    return arg;\n+\t  if ((complain & tf_error)\n+\t      && (flags & LOOKUP_DELEGATING_CONS))\n+\t    check_self_delegation (arg);\n+\t  /* Avoid change of behavior on Wunused-var-2.C.  */\n+\t  mark_lvalue_use (instance);\n+\t  return build2 (INIT_EXPR, class_type, instance, arg);\n+\t}\n+    }\n+\n   fns = lookup_fnfields (binfo, name, 1);\n \n   /* When making a call to a constructor or destructor for a subobject\n@@ -8206,11 +8267,8 @@ build_special_member_call (tree instance, tree name, vec<tree, va_gc> **args,\n \n   if ((complain & tf_error)\n       && (flags & LOOKUP_DELEGATING_CONS)\n-      && name == complete_ctor_identifier \n-      && TREE_CODE (ret) == CALL_EXPR\n-      && (DECL_ABSTRACT_ORIGIN (TREE_OPERAND (CALL_EXPR_FN (ret), 0))\n-\t  == current_function_decl))\n-    error (\"constructor delegates to itself\");\n+      && name == complete_ctor_identifier)\n+    check_self_delegation (ret);\n \n   return ret;\n }"}, {"sha": "8b0442f9ff435907cfd691398e7674431f76140a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cbfdb06604b63e743d3644fdec7dd20d7c0843/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cbfdb06604b63e743d3644fdec7dd20d7c0843/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=36cbfdb06604b63e743d3644fdec7dd20d7c0843", "patch": "@@ -5692,7 +5692,6 @@ extern tree convert_to_reference\t\t(tree, tree, int, int, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree convert_from_reference\t\t(tree);\n extern tree force_rvalue\t\t\t(tree, tsubst_flags_t);\n-extern bool early_elide_copy\t\t\t(tree, tree);\n extern tree ocp_convert\t\t\t\t(tree, tree, int, int,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree cp_convert\t\t\t\t(tree, tree, tsubst_flags_t);"}, {"sha": "2f5f15a2c8269c6f0ea003737b2828c4ee7ba203", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cbfdb06604b63e743d3644fdec7dd20d7c0843/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cbfdb06604b63e743d3644fdec7dd20d7c0843/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=36cbfdb06604b63e743d3644fdec7dd20d7c0843", "patch": "@@ -658,27 +658,6 @@ cp_convert_and_check (tree type, tree expr, tsubst_flags_t complain)\n   return result;\n }\n \n-/* Returns true if we should avoid even doing overload resolution for copying\n-   EXPR to initialize a TYPE.  */\n-\n-bool\n-early_elide_copy (tree type, tree expr)\n-{\n-  if (TREE_CODE (expr) != TARGET_EXPR)\n-    return false;\n-  /* List-initialization and direct-initialization don't involve a copy.  */\n-  if (TARGET_EXPR_LIST_INIT_P (expr)\n-      || TARGET_EXPR_DIRECT_INIT_P (expr))\n-    return true;\n-  /* In C++17, \"If the initializer expression is a prvalue and the\n-     cv-unqualified version of the source type is the same class as the class\n-     of the destination, the initializer expression is used to initialize the\n-     destination object.\"  */\n-  return (cxx_dialect >= cxx1z\n-\t  && (same_type_ignoring_top_level_qualifiers_p\n-\t      (type, TREE_TYPE (expr))));\n-}\n-\n /* Conversion...\n \n    FLAGS indicates how we should behave.  */\n@@ -714,8 +693,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n   if (error_operand_p (e))\n     return error_mark_node;\n \n-  if (MAYBE_CLASS_TYPE_P (type) && (convtype & CONV_FORCE_TEMP)\n-      && !early_elide_copy (type, e))\n+  if (MAYBE_CLASS_TYPE_P (type) && (convtype & CONV_FORCE_TEMP))\n     /* We need a new temporary; don't take this shortcut.  */;\n   else if (same_type_ignoring_top_level_qualifiers_p (type, TREE_TYPE (e)))\n     {"}, {"sha": "1c60b08bb1089a1167e6cae836057ee24a1f0e4f", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cbfdb06604b63e743d3644fdec7dd20d7c0843/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cbfdb06604b63e743d3644fdec7dd20d7c0843/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=36cbfdb06604b63e743d3644fdec7dd20d7c0843", "patch": "@@ -683,7 +683,7 @@ build_throw (tree exp)\n       object = cp_build_indirect_ref (object, RO_NULL, tf_warning_or_error);\n \n       /* And initialize the exception object.  */\n-      if (CLASS_TYPE_P (temp_type) && !early_elide_copy (temp_type, exp))\n+      if (CLASS_TYPE_P (temp_type))\n \t{\n \t  int flags = LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING;\n \t  vec<tree, va_gc> *exp_vec;"}, {"sha": "b4b5e0acd45e7a8c81ab6ba7486973aa65ca5703", "filename": "gcc/cp/init.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cbfdb06604b63e743d3644fdec7dd20d7c0843/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cbfdb06604b63e743d3644fdec7dd20d7c0843/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=36cbfdb06604b63e743d3644fdec7dd20d7c0843", "patch": "@@ -1644,13 +1644,6 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n \tinit = reshape_init (type, init, complain);\n     }\n \n-  /* Also pull out a TARGET_EXPR that we want to avoid copying.  */\n-  if (init && true_exp == exp\n-      && TREE_CODE (init) == TREE_LIST\n-      && list_length (init) == 1\n-      && early_elide_copy (type, TREE_VALUE (init)))\n-    init = TREE_VALUE (init);\n-\n   if (init && BRACE_ENCLOSED_INITIALIZER_P (init)\n       && CP_AGGREGATE_TYPE_P (type))\n     /* A brace-enclosed initializer for an aggregate.  In C++0x this can\n@@ -1661,12 +1654,14 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n      initializer, whether that happened just above or in\n      cp_parser_late_parsing_nsdmi.\n \n-     A TARGET_EXPR for which early_elide_copy is true represents the whole\n-     initialization, so we shouldn't build up another ctor call.  */\n-\n+     A TARGET_EXPR with TARGET_EXPR_DIRECT_INIT_P or TARGET_EXPR_LIST_INIT_P\n+     set represents the whole initialization, so we shouldn't build up\n+     another ctor call.  */\n   if (init\n       && (TREE_CODE (init) == CONSTRUCTOR\n-\t  || early_elide_copy (type, init))\n+\t  || (TREE_CODE (init) == TARGET_EXPR\n+\t      && (TARGET_EXPR_DIRECT_INIT_P (init)\n+\t\t  || TARGET_EXPR_LIST_INIT_P (init))))\n       && same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (init), type))\n     {\n       /* Early initialization via a TARGET_EXPR only works for"}, {"sha": "569442f38ac095bada11908f21bf74a1e528e953", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cbfdb06604b63e743d3644fdec7dd20d7c0843/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cbfdb06604b63e743d3644fdec7dd20d7c0843/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=36cbfdb06604b63e743d3644fdec7dd20d7c0843", "patch": "@@ -7639,8 +7639,6 @@ cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n \t}\n       else if (! MAYBE_CLASS_TYPE_P (lhstype))\n \t/* Do the default thing.  */;\n-      else if (early_elide_copy (lhstype, rhs))\n-\t/* Do the default thing.  */;\n       else\n \t{\n \t  vec<tree, va_gc> *rhs_vec = make_tree_vector_single (rhs);"}, {"sha": "f72a6dac5255502c0d0c51aa44040189b8e1c406", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist12.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cbfdb06604b63e743d3644fdec7dd20d7c0843/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cbfdb06604b63e743d3644fdec7dd20d7c0843/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist12.C?ref=36cbfdb06604b63e743d3644fdec7dd20d7c0843", "patch": "@@ -1,6 +1,5 @@\n // PR c++/38698\n // { dg-do compile { target c++11 } }\n-// { dg-prune-output \"note\" }\n \n struct A\n {"}, {"sha": "48b89b10b294e74d8574525e37d4daf8523932ea", "filename": "gcc/testsuite/g++.dg/cpp1z/elide1.C", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cbfdb06604b63e743d3644fdec7dd20d7c0843/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Felide1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cbfdb06604b63e743d3644fdec7dd20d7c0843/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Felide1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Felide1.C?ref=36cbfdb06604b63e743d3644fdec7dd20d7c0843", "patch": "@@ -23,3 +23,10 @@ A f() {\n   else\n     return A();\n }\n+\n+A* ap = new A(f());\n+\n+struct B {\n+  A a;\n+  B(): a(A()) {}\n+};"}, {"sha": "4016d9e2c7d619f3a3b42dca56ac56eca67cbf70", "filename": "libstdc++-v3/testsuite/20_util/variant/compile.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36cbfdb06604b63e743d3644fdec7dd20d7c0843/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36cbfdb06604b63e743d3644fdec7dd20d7c0843/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc?ref=36cbfdb06604b63e743d3644fdec7dd20d7c0843", "patch": "@@ -91,8 +91,8 @@ void move_ctor()\n {\n   static_assert(is_move_constructible_v<variant<int, string>>, \"\");\n   static_assert(!is_move_constructible_v<variant<AllDeleted, string>>, \"\");\n-  static_assert(!noexcept(variant<int, Empty>(variant<int, Empty>())), \"\");\n-  static_assert(noexcept(variant<int, DefaultNoexcept>(variant<int, DefaultNoexcept>())), \"\");\n+  static_assert(!noexcept(variant<int, Empty>(declval<variant<int, Empty>>())), \"\");\n+  static_assert(noexcept(variant<int, DefaultNoexcept>(declval<variant<int, DefaultNoexcept>>())), \"\");\n }\n \n void arbitrary_ctor()"}]}