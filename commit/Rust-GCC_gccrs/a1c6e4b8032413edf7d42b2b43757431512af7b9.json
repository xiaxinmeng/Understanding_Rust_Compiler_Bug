{"sha": "a1c6e4b8032413edf7d42b2b43757431512af7b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFjNmU0YjgwMzI0MTNlZGY3ZDQyYjJiNDM3NTc0MzE1MTJhZjdiOQ==", "commit": {"author": {"name": "Trevor Smigiel", "email": "Trevor_Smigiel@playstation.sony.com", "date": "2006-12-09T01:22:39Z"}, "committer": {"name": "Trevor Smigiel", "email": "tsmigiel@gcc.gnu.org", "date": "2006-12-09T01:22:39Z"}, "message": "spu-protos.h (spu_split_immediate): Renamed from spu_split_address.\n\n        * config/spu/spu-protos.h (spu_split_immediate): Renamed from\n        spu_split_address.\n        (cpat_const_p, gen_cpat_const): Add.\n        * config/spu/spu.c (immediate_class): New enum.\n        (cpat_info, classify_immediate): New.\n        (print_operand): Use S, D, T instead of F, G, H.  Use\n        classify_immediate.  Handle cpat cases.\n        (spu_split_immediate):  Renamed from spu_split_address.  Split all\n        immediates that can be split.\n        (immediate_load_p): Use classify_immediate.\n        (spu_legitimate_constant_p): Accept everything except some cases of\n        CONST_VECTOR.\n        (spu_expand_move): Use spu_split_immedate.\n        (fsmbi_const_p): Use classify_immediate.\n        (cpat_const_p): New.\n        (gen_cpat_const: New.\n        * config/spu/constraints.md (j,k,l): New constraints for cpat\n        instructions.\n        * config/spu/spu.md (unnamed splitter): Change address splitter to\n        handle all immediates.\n        (_mov<mode>, _movdi, _movti): Handle i, j, k constraints for cpat\n        instructions.\n        (cpat, _cpat, splitter): Generate a TImode constant for cpat patterns\n        when possible.\n\nFrom-SVN: r119682", "tree": {"sha": "b092c04bc9fe69e1a7e2c26921cde187d1f338c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b092c04bc9fe69e1a7e2c26921cde187d1f338c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1c6e4b8032413edf7d42b2b43757431512af7b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c6e4b8032413edf7d42b2b43757431512af7b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1c6e4b8032413edf7d42b2b43757431512af7b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c6e4b8032413edf7d42b2b43757431512af7b9/comments", "author": null, "committer": null, "parents": [{"sha": "55eb837db10fdcdb88bf3fdf7c2c431857dad42b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55eb837db10fdcdb88bf3fdf7c2c431857dad42b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55eb837db10fdcdb88bf3fdf7c2c431857dad42b"}], "stats": {"total": 718, "additions": 482, "deletions": 236}, "files": [{"sha": "27358a0938090717d084aa69942f5f025a67229b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c6e4b8032413edf7d42b2b43757431512af7b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c6e4b8032413edf7d42b2b43757431512af7b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1c6e4b8032413edf7d42b2b43757431512af7b9", "patch": "@@ -1,3 +1,30 @@\n+2006-12-08  Trevor Smigiel  <trevor_smigiel@playstation.sony.com>\n+\n+\t* config/spu/spu-protos.h (spu_split_immediate): Renamed from\n+\tspu_split_address.\n+\t(cpat_const_p, gen_cpat_const): Add.\n+\t* config/spu/spu.c (immediate_class): New enum.\n+\t(cpat_info, classify_immediate): New.\n+\t(print_operand): Use S, D, T instead of F, G, H.  Use\n+\tclassify_immediate.  Handle cpat cases.\n+\t(spu_split_immediate):  Renamed from spu_split_address.  Split all\n+\timmediates that can be split.\n+\t(immediate_load_p): Use classify_immediate.\n+\t(spu_legitimate_constant_p): Accept everything except some cases of\n+\tCONST_VECTOR.\n+\t(spu_expand_move): Use spu_split_immedate.\n+\t(fsmbi_const_p): Use classify_immediate.\n+\t(cpat_const_p): New.\n+\t(gen_cpat_const: New.\n+\t* config/spu/constraints.md (j,k,l): New constraints for cpat\n+\tinstructions.\n+\t* config/spu/spu.md (unnamed splitter): Change address splitter to\n+\thandle all immediates.\n+\t(_mov<mode>, _movdi, _movti): Handle i, j, k constraints for cpat\n+\tinstructions.\n+\t(cpat, _cpat, splitter): Generate a TImode constant for cpat patterns\n+\twhen possible.\n+\n 2006-12-08  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR target/30039"}, {"sha": "45aafd0350d580018715501c9d30454dd8c9666a", "filename": "gcc/config/spu/constraints.md", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c6e4b8032413edf7d42b2b43757431512af7b9/gcc%2Fconfig%2Fspu%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c6e4b8032413edf7d42b2b43757431512af7b9/gcc%2Fconfig%2Fspu%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fconstraints.md?ref=a1c6e4b8032413edf7d42b2b43757431512af7b9", "patch": "@@ -18,7 +18,7 @@\n \n \f\n ;; GCC standard constraints:  g, i, m, n, o, p, r, s, E-H, I-P, V, X\n-;; unused for SPU:  E-H, L, Q, d, e, h, j-l, q, t-z\n+;; unused for SPU:  E-H, L, Q, d, e, h, q, t-z\n \n ;; For most immediate constraints we have 3 variations to deal with the\n ;; fact const_int has no mode.  One variation treats const_int as 32 bit,\n@@ -84,6 +84,22 @@\n   \"An immediate which can be loaded with fsmbi.\"\n   (and (match_code \"const_int,const_double,const_vector\")\n        (match_test \"fsmbi_const_p (op)\")))\n+\n+(define_constraint \"j\"\n+  \"An immediate which can be loaded with one of the cbd/chd/cwd/cdd instructions.  const_int is treated as a 32 bit value.\"\n+  (and (match_code \"const_int,const_double,const_vector\")\n+       (match_test \"cpat_const_p (op, SImode)\")))\n+\n+(define_constraint \"k\"\n+  \"An immediate which can be loaded with one of the cbd/chd/cwd/cdd instructions.  const_int is treated as a 64 bit value.\"\n+  (and (match_code \"const_int,const_double,const_vector\")\n+       (match_test \"cpat_const_p (op, DImode)\")))\n+\n+(define_constraint \"l\"\n+  \"An immediate which can be loaded with one of the cbd/chd/cwd/cdd instructions.\"\n+  (and (match_code \"const_double,const_vector\")\n+       (match_test \"cpat_const_p (op, TImode)\")))\n+\n \f\n ;; Integer constraints\n "}, {"sha": "710c833746ae54aa99fcb61be2f79cde7021fb15", "filename": "gcc/config/spu/spu-protos.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c6e4b8032413edf7d42b2b43757431512af7b9/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c6e4b8032413edf7d42b2b43757431512af7b9/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-protos.h?ref=a1c6e4b8032413edf7d42b2b43757431512af7b9", "patch": "@@ -34,7 +34,7 @@ extern HOST_WIDE_INT const_double_to_hwint (rtx x);\n extern rtx hwint_to_const_double (enum machine_mode mode, HOST_WIDE_INT v);\n extern void print_operand_address (FILE * file, register rtx addr);\n extern void print_operand (FILE * file, rtx x, int code);\n-extern void spu_split_address (rtx * ops);\n+extern int spu_split_immediate (rtx * ops);\n extern int spu_saved_regs_size (void);\n extern int direct_return (void);\n extern void spu_expand_prologue (void);\n@@ -69,6 +69,8 @@ extern void spu_split_load (rtx * ops);\n extern void spu_split_store (rtx * ops);\n extern int spu_valid_move (rtx * ops);\n extern int fsmbi_const_p (rtx x);\n+extern int cpat_const_p (rtx x, enum machine_mode mode);\n+extern rtx gen_cpat_const (rtx * ops);\n extern void constant_to_array (enum machine_mode mode, rtx x,\n \t\t\t       unsigned char *arr);\n extern rtx array_to_constant (enum machine_mode mode, unsigned char *arr);"}, {"sha": "70f09c5d918725f7c6405181f6fb8802bb198760", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 376, "deletions": 200, "changes": 576, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c6e4b8032413edf7d42b2b43757431512af7b9/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c6e4b8032413edf7d42b2b43757431512af7b9/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=a1c6e4b8032413edf7d42b2b43757431512af7b9", "patch": "@@ -143,9 +143,22 @@ enum spu_immediate {\n   SPU_ORBI,\n   SPU_IOHL\n };\n+enum immediate_class\n+{\n+  IC_POOL,\t\t\t/* constant pool */\n+  IC_IL1,\t\t\t/* one il* instruction */\n+  IC_IL2,\t\t\t/* both ilhu and iohl instructions */\n+  IC_IL1s,\t\t\t/* one il* instruction */\n+  IC_IL2s,\t\t\t/* both ilhu and iohl instructions */\n+  IC_FSMBI,\t\t\t/* the fsmbi instruction */\n+  IC_CPAT,\t\t\t/* one of the c*d instructions */\n+};\n \n static enum spu_immediate which_immediate_load (HOST_WIDE_INT val);\n static enum spu_immediate which_logical_immediate (HOST_WIDE_INT val);\n+static int cpat_info(unsigned char *arr, int size, int *prun, int *pstart);\n+static enum immediate_class classify_immediate (rtx op,\n+\t\t\t\t\t\tenum machine_mode mode);\n \n /* Built in types.  */\n tree spu_builtin_types[SPU_BTI_MAX];\n@@ -972,24 +985,22 @@ print_operand (FILE * file, rtx x, int code)\n   HOST_WIDE_INT val;\n   unsigned char arr[16];\n   int xcode = GET_CODE (x);\n+  int i, info;\n   if (GET_MODE (x) == VOIDmode)\n     switch (code)\n       {\n-      case 'H':\t\t\t/* 128 bits, signed */\n       case 'L':\t\t\t/* 128 bits, signed */\n       case 'm':\t\t\t/* 128 bits, signed */\n       case 'T':\t\t\t/* 128 bits, signed */\n       case 't':\t\t\t/* 128 bits, signed */\n \tmode = TImode;\n \tbreak;\n-      case 'G':\t\t\t/* 64 bits, signed */\n       case 'K':\t\t\t/* 64 bits, signed */\n       case 'k':\t\t\t/* 64 bits, signed */\n       case 'D':\t\t\t/* 64 bits, signed */\n       case 'd':\t\t\t/* 64 bits, signed */\n \tmode = DImode;\n \tbreak;\n-      case 'F':\t\t\t/* 32 bits, signed */\n       case 'J':\t\t\t/* 32 bits, signed */\n       case 'j':\t\t\t/* 32 bits, signed */\n       case 's':\t\t\t/* 32 bits, signed */\n@@ -1062,94 +1073,131 @@ print_operand (FILE * file, rtx x, int code)\n     case 't':\t\t\t/* 128 bits, signed */\n     case 'd':\t\t\t/* 64 bits, signed */\n     case 's':\t\t\t/* 32 bits, signed */\n-      if (xcode == CONST_INT\n-\t  || xcode == CONST_DOUBLE || xcode == CONST_VECTOR)\n+      if (CONSTANT_P (x))\n \t{\n-\t  gcc_assert (immediate_load_p (x, mode));\n-\t  constant_to_array (mode, x, arr);\n-\t  val = (arr[0] << 24) | (arr[1] << 16) | (arr[2] << 8) | arr[3];\n-\t  val = trunc_int_for_mode (val, SImode);\n-\t  switch (which_immediate_load (val))\n-\t  {\n-\t  case SPU_IL:\n-\t    break;\n-\t  case SPU_ILA:\n-\t    fprintf (file, \"a\");\n-\t    break;\n-\t  case SPU_ILH:\n-\t    fprintf (file, \"h\");\n-\t    break;\n-\t  case SPU_ILHU:\n-\t    fprintf (file, \"hu\");\n-\t    break;\n-\t  default:\n-\t    gcc_unreachable();\n-\t  }\n+\t  enum immediate_class c = classify_immediate (x, mode);\n+\t  switch (c)\n+\t    {\n+\t    case IC_IL1:\n+\t      constant_to_array (mode, x, arr);\n+\t      val = (arr[0] << 24) | (arr[1] << 16) | (arr[2] << 8) | arr[3];\n+\t      val = trunc_int_for_mode (val, SImode);\n+\t      switch (which_immediate_load (val))\n+\t\t{\n+\t\tcase SPU_IL:\n+\t\t  break;\n+\t\tcase SPU_ILA:\n+\t\t  fprintf (file, \"a\");\n+\t\t  break;\n+\t\tcase SPU_ILH:\n+\t\t  fprintf (file, \"h\");\n+\t\t  break;\n+\t\tcase SPU_ILHU:\n+\t\t  fprintf (file, \"hu\");\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      break;\n+\t    case IC_CPAT:\n+\t      constant_to_array (mode, x, arr);\n+\t      cpat_info (arr, GET_MODE_SIZE (mode), &info, 0);\n+\t      if (info == 1)\n+\t\tfprintf (file, \"b\");\n+\t      else if (info == 2)\n+\t\tfprintf (file, \"h\");\n+\t      else if (info == 4)\n+\t\tfprintf (file, \"w\");\n+\t      else if (info == 8)\n+\t\tfprintf (file, \"d\");\n+\t      break;\n+\t    case IC_IL1s:\n+\t      if (xcode == CONST_VECTOR)\n+\t\t{\n+\t\t  x = CONST_VECTOR_ELT (x, 0);\n+\t\t  xcode = GET_CODE (x);\n+\t\t}\n+\t      if (xcode == SYMBOL_REF || xcode == LABEL_REF || xcode == CONST)\n+\t\tfprintf (file, \"a\");\n+\t      else if (xcode == HIGH)\n+\t\tfprintf (file, \"hu\");\n+\t      break;\n+\t    case IC_FSMBI:\n+\t    case IC_IL2:\n+\t    case IC_IL2s:\n+\t    case IC_POOL:\n+\t      abort ();\n+\t    }\n \t}\n-      else if (xcode == SYMBOL_REF || xcode == LABEL_REF || xcode == CONST)\n-\tfprintf (file, \"a\");\n-      else if (xcode == HIGH)\n-\tfprintf (file, \"hu\");\n       else\n \tgcc_unreachable ();\n       return;\n \n     case 'T':\t\t\t/* 128 bits, signed */\n     case 'D':\t\t\t/* 64 bits, signed */\n     case 'S':\t\t\t/* 32 bits, signed */\n-      if (xcode == CONST_INT\n-\t  || xcode == CONST_DOUBLE || xcode == CONST_VECTOR)\n+      if (CONSTANT_P (x))\n \t{\n-\t  gcc_assert (immediate_load_p (x, mode));\n-\t  constant_to_array (mode, x, arr);\n-\t  val = (arr[0] << 24) | (arr[1] << 16) | (arr[2] << 8) | arr[3];\n-\t  val = trunc_int_for_mode (val, SImode);\n-\t  switch (which_immediate_load (val))\n+\t  enum immediate_class c = classify_immediate (x, mode);\n+\t  switch (c)\n \t    {\n-\t    case SPU_IL:\n-\t    case SPU_ILA:\n+\t    case IC_IL1:\n+\t      constant_to_array (mode, x, arr);\n+\t      val = (arr[0] << 24) | (arr[1] << 16) | (arr[2] << 8) | arr[3];\n+\t      val = trunc_int_for_mode (val, SImode);\n+\t      switch (which_immediate_load (val))\n+\t\t{\n+\t\tcase SPU_IL:\n+\t\tcase SPU_ILA:\n+\t\t  break;\n+\t\tcase SPU_ILH:\n+\t\tcase SPU_ILHU:\n+\t\t  val = trunc_int_for_mode (((arr[0] << 8) | arr[1]), HImode);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n+\t      fprintf (file, HOST_WIDE_INT_PRINT_DEC, val);\n \t      break;\n-\t    case SPU_ILH:\n-\t    case SPU_ILHU:\n-\t      val = trunc_int_for_mode (((arr[0] << 8) | arr[1]), HImode);\n+\t    case IC_FSMBI:\n+\t      constant_to_array (mode, x, arr);\n+\t      val = 0;\n+\t      for (i = 0; i < 16; i++)\n+\t\t{\n+\t\t  val <<= 1;\n+\t\t  val |= arr[i] & 1;\n+\t\t}\n+\t      print_operand (file, GEN_INT (val), 0);\n+\t      break;\n+\t    case IC_CPAT:\n+\t      constant_to_array (mode, x, arr);\n+\t      cpat_info (arr, GET_MODE_SIZE (mode), 0, &info);\n+\t      fprintf (file, HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT)info);\n+\t      break;\n+\t    case IC_IL1s:\n+\t      if (xcode == CONST_VECTOR)\n+\t\t{\n+\t\t  x = CONST_VECTOR_ELT (x, 0);\n+\t\t  xcode = GET_CODE (x);\n+\t\t}\n+\t      if (xcode == HIGH)\n+\t\t{\n+\t\t  output_addr_const (file, XEXP (x, 0));\n+\t\t  fprintf (file, \"@h\");\n+\t\t}\n+\t      else\n+\t\toutput_addr_const (file, x);\n \t      break;\n-\t    default:\n-\t      gcc_unreachable();\n+\t    case IC_IL2:\n+\t    case IC_IL2s:\n+\t    case IC_POOL:\n+\t      abort ();\n \t    }\n-\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, val);\n-\t}\n-      else if (xcode == CONST || xcode == SYMBOL_REF || xcode == LABEL_REF)\n-\toutput_addr_const (file, x);\n-      else if (xcode == HIGH)\n-\t{\n-\t  output_addr_const (file, XEXP (x, 0));\n-\t  fprintf (file, \"@h\");\n \t}\n       else\n \tgcc_unreachable ();\n       return;\n \n-    case 'F':\n-    case 'G':\n-    case 'H':\n-      if (xcode == CONST_INT\n-\t  || xcode == CONST_DOUBLE || xcode == CONST_VECTOR)\n-\t{\t\t\t/* immediate operand for fsmbi */\n-\t  int i;\n-\t  HOST_WIDE_INT val = 0;\n-\t  unsigned char arr[16];\n-\t  constant_to_array (mode, x, arr);\n-\t  for (i = 0; i < 16; i++)\n-\t    {\n-\t      val <<= 1;\n-\t      val |= arr[i] & 1;\n-\t    }\n-\t  print_operand (file, GEN_INT (val), 0);\n-\t}\n-      else\n-\tgcc_unreachable();\n-      return;\n-\n     case 'C':\n       if (xcode == CONST_INT)\n \t{\n@@ -1246,7 +1294,7 @@ print_operand (FILE * file, rtx x, int code)\n       else if (xcode == MEM)\n \toutput_address (XEXP (x, 0));\n       else if (xcode == CONST_VECTOR)\n-\toutput_addr_const (file, CONST_VECTOR_ELT (x, 0));\n+\tprint_operand (file, CONST_VECTOR_ELT (x, 0), 0);\n       else\n \toutput_addr_const (file, x);\n       return;\n@@ -1276,23 +1324,76 @@ get_pic_reg (void)\n \n /* Split constant addresses to handle cases that are too large.  Also, add in\n    the pic register when in PIC mode. */\n-void\n-spu_split_address (rtx * ops)\n+int\n+spu_split_immediate (rtx * ops)\n {\n-  if (TARGET_LARGE_MEM\n-      || (GET_CODE (ops[1]) == CONST && !legitimate_const (ops[1], 0)))\n-    {\n-      emit_insn (gen_high (ops[0], ops[1]));\n-      emit_insn (gen_low (ops[0], ops[0], ops[1]));\n-    }\n-  else if (flag_pic)\n-    emit_insn (gen_pic (ops[0], ops[1]));\n-  if (flag_pic)\n+  enum machine_mode mode = GET_MODE (ops[0]);\n+  enum immediate_class c = classify_immediate (ops[1], mode);\n+\n+  switch (c)\n     {\n-      rtx pic_reg = get_pic_reg ();\n-      emit_insn (gen_addsi3 (ops[0], ops[0], pic_reg));\n-      current_function_uses_pic_offset_table = 1;\n+    case IC_IL2:\n+      {\n+\tunsigned char arrhi[16];\n+\tunsigned char arrlo[16];\n+\trtx to, hi, lo;\n+\tint i;\n+\tconstant_to_array (mode, ops[1], arrhi);\n+\tto = no_new_pseudos ? ops[0] : gen_reg_rtx (mode);\n+\tfor (i = 0; i < 16; i += 4)\n+\t  {\n+\t    arrlo[i + 2] = arrhi[i + 2];\n+\t    arrlo[i + 3] = arrhi[i + 3];\n+\t    arrlo[i + 0] = arrlo[i + 1] = 0;\n+\t    arrhi[i + 2] = arrhi[i + 3] = 0;\n+\t  }\n+\thi = array_to_constant (mode, arrhi);\n+\tlo = array_to_constant (mode, arrlo);\n+\temit_move_insn (to, hi);\n+\temit_insn (gen_rtx_SET\n+\t\t   (VOIDmode, ops[0], gen_rtx_IOR (mode, to, lo)));\n+\treturn 1;\n+      }\n+    case IC_POOL:\n+      if (reload_in_progress || reload_completed)\n+\t{\n+\t  rtx mem = force_const_mem (mode, ops[1]);\n+\t  if (TARGET_LARGE_MEM)\n+\t    {\n+\t      rtx addr = gen_rtx_REG (Pmode, REGNO (ops[0]));\n+\t      emit_move_insn (addr, XEXP (mem, 0));\n+\t      mem = replace_equiv_address (mem, addr);\n+\t    }\n+\t  emit_move_insn (ops[0], mem);\n+\t  return 1;\n+\t}\n+      break;\n+    case IC_IL1s:\n+    case IC_IL2s:\n+      if (reload_completed && GET_CODE (ops[1]) != HIGH)\n+\t{\n+\t  if (c == IC_IL2s)\n+\t    {\n+\t      emit_insn (gen_high (ops[0], ops[1]));\n+\t      emit_insn (gen_low (ops[0], ops[0], ops[1]));\n+\t    }\n+\t  else if (flag_pic)\n+\t    emit_insn (gen_pic (ops[0], ops[1]));\n+\t  if (flag_pic)\n+\t    {\n+\t      rtx pic_reg = get_pic_reg ();\n+\t      emit_insn (gen_addsi3 (ops[0], ops[0], pic_reg));\n+\t      current_function_uses_pic_offset_table = 1;\n+\t    }\n+\t  return flag_pic || c == IC_IL2s;\n+\t}\n+      break;\n+    case IC_IL1:\n+    case IC_FSMBI:\n+    case IC_CPAT:\n+      break;\n     }\n+  return 0;\n }\n \n /* SAVING is TRUE when we are generating the actual load and store\n@@ -2202,38 +2303,154 @@ which_immediate_load (HOST_WIDE_INT val)\n   return SPU_NONE;\n }\n \n+/* Return true when OP can be loaded by one of the il instructions, or\n+   when flow2 is not completed and OP can be loaded using ilhu and iohl. */\n int\n immediate_load_p (rtx op, enum machine_mode mode)\n+{\n+  if (CONSTANT_P (op))\n+    {\n+      enum immediate_class c = classify_immediate (op, mode);\n+      return c == IC_IL1 || (!flow2_completed && c == IC_IL2);\n+    }\n+  return 0;\n+}\n+\n+/* Return true if the first SIZE bytes of arr is a constant that can be\n+   generated with cbd, chd, cwd or cdd.  When non-NULL, PRUN and PSTART\n+   represent the size and offset of the instruction to use. */\n+static int\n+cpat_info(unsigned char *arr, int size, int *prun, int *pstart)\n+{\n+  int cpat, run, i, start;\n+  cpat = 1;\n+  run = 0;\n+  start = -1;\n+  for (i = 0; i < size && cpat; i++)\n+    if (arr[i] != i+16)\n+      { \n+\tif (!run)\n+\t  {\n+\t    start = i;\n+\t    if (arr[i] == 3)\n+\t      run = 1;\n+\t    else if (arr[i] == 2 && arr[i+1] == 3)\n+\t      run = 2;\n+\t    else if (arr[i] == 0)\n+\t      {\n+\t\twhile (arr[i+run] == run && i+run < 16)\n+\t\t  run++;\n+\t\tif (run != 4 && run != 8)\n+\t\t  cpat = 0;\n+\t      }\n+\t    else\n+\t      cpat = 0;\n+\t    if ((i & (run-1)) != 0)\n+\t      cpat = 0;\n+\t    i += run;\n+\t  }\n+\telse\n+\t  cpat = 0;\n+      }\n+  if (cpat)\n+    {\n+      if (run == 0)\n+\trun = 1;\n+      if (prun)\n+\t*prun = run;\n+      if (pstart)\n+\t*pstart = start == -1 ? 16-run : start;\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* OP is a CONSTANT_P.  Determine what instructions can be used to load\n+   it into a regiser.  MODE is only valid when OP is a CONST_INT. */\n+static enum immediate_class\n+classify_immediate (rtx op, enum machine_mode mode)\n {\n   HOST_WIDE_INT val;\n   unsigned char arr[16];\n-  int i, j;\n+  int i, j, repeated, fsmbi;\n+\n+  gcc_assert (CONSTANT_P (op));\n+\n   if (GET_MODE (op) != VOIDmode)\n     mode = GET_MODE (op);\n \n-  gcc_assert (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE\n-\t      || GET_CODE (op) == CONST_VECTOR);\n-\n-  /* V4SI with all identical symbols is valid. */\n+  /* A V4SI const_vector with all identical symbols is ok. */\n   if (mode == V4SImode\n-      && GET_CODE (CONST_VECTOR_ELT (op, 0)) == SYMBOL_REF)\n-    return !TARGET_LARGE_MEM && !flag_pic\n-\t   && CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 1)\n-\t   && CONST_VECTOR_ELT (op, 1) == CONST_VECTOR_ELT (op, 2)\n-\t   && CONST_VECTOR_ELT (op, 2) == CONST_VECTOR_ELT (op, 3);\n+      && GET_CODE (op) == CONST_VECTOR\n+      && GET_CODE (CONST_VECTOR_ELT (op, 0)) != CONST_INT\n+      && GET_CODE (CONST_VECTOR_ELT (op, 0)) != CONST_DOUBLE\n+      && CONST_VECTOR_ELT (op, 0) == CONST_VECTOR_ELT (op, 1)\n+      && CONST_VECTOR_ELT (op, 1) == CONST_VECTOR_ELT (op, 2)\n+      && CONST_VECTOR_ELT (op, 2) == CONST_VECTOR_ELT (op, 3))\n+    op = CONST_VECTOR_ELT (op, 0);\n+\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return TARGET_LARGE_MEM ? IC_IL2s : IC_IL1s;\n \n-  constant_to_array (mode, op, arr);\n+    case CONST:\n+      return TARGET_LARGE_MEM\n+\t|| !legitimate_const (op, 0) ? IC_IL2s : IC_IL1s;\n \n-  /* Check that bytes are repeated. */\n-  for (i = 4; i < 16; i += 4)\n-    for (j = 0; j < 4; j++)\n-      if (arr[j] != arr[i + j])\n-\treturn 0;\n+    case HIGH:\n+      return IC_IL1s;\n \n-  val = (arr[0] << 24) | (arr[1] << 16) | (arr[2] << 8) | arr[3];\n-  val = trunc_int_for_mode (val, SImode);\n+    case CONST_VECTOR:\n+      for (i = 0; i < GET_MODE_NUNITS (mode); i++)\n+\tif (GET_CODE (CONST_VECTOR_ELT (op, i)) != CONST_INT\n+\t    && GET_CODE (CONST_VECTOR_ELT (op, i)) != CONST_DOUBLE)\n+\t  return IC_POOL;\n+      /* Fall through. */\n+\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+      constant_to_array (mode, op, arr);\n+\n+      /* Check that each 4-byte slot is identical. */\n+      repeated = 1;\n+      for (i = 4; i < 16; i += 4)\n+\tfor (j = 0; j < 4; j++)\n+\t  if (arr[j] != arr[i + j])\n+\t    repeated = 0;\n \n-  return which_immediate_load (val) != SPU_NONE;\n+      if (repeated)\n+\t{\n+\t  val = (arr[0] << 24) | (arr[1] << 16) | (arr[2] << 8) | arr[3];\n+\t  val = trunc_int_for_mode (val, SImode);\n+\n+\t  if (which_immediate_load (val) != SPU_NONE)\n+\t    return IC_IL1;\n+\t}\n+\n+      /* Any mode of 2 bytes or smaller can be loaded with an il\n+         instruction. */\n+      gcc_assert (GET_MODE_SIZE (mode) > 2);\n+\n+      fsmbi = 1;\n+      for (i = 0; i < 16 && fsmbi; i++)\n+\tif (arr[i] != 0 && arr[i] != 0xff)\n+\t  fsmbi = 0;\n+      if (fsmbi)\n+\treturn IC_FSMBI;\n+\n+      if (cpat_info (arr, GET_MODE_SIZE (mode), 0, 0))\n+\treturn IC_CPAT;\n+\n+      if (repeated)\n+\treturn IC_IL2;\n+\n+      return IC_POOL;\n+    default:\n+      break;\n+    }\n+  gcc_unreachable ();\n }\n \n static enum spu_immediate\n@@ -2361,31 +2578,7 @@ arith_immediate_p (rtx op, enum machine_mode mode,\n int\n spu_legitimate_constant_p (rtx x)\n {\n-  unsigned char arr[16];\n-  int i, j;\n-\n-  if (GET_CODE (x) == HIGH\n-      || GET_CODE (x) == CONST\n-      || GET_CODE (x) == SYMBOL_REF\n-      || GET_CODE (x) == LABEL_REF)\n-    return 1;\n-\n-  if (fsmbi_const_p (x))\n-    return 1;\n-\n-  if (GET_CODE (x) == CONST_INT)\n-    return (INTVAL (x) >= -0x80000000ll && INTVAL (x) <= 0x7fffffffll)\n-      || ((INTVAL (x) >> 32) & 0xffffffffll) == (INTVAL (x) & 0xffffffffll);\n-\n-  if (GET_MODE (x) == SFmode)\n-    return 1;\n-\n-  if (GET_MODE (x) == DFmode)\n-    {\n-      HOST_WIDE_INT val = const_double_to_hwint (x);\n-      return ((val >> 32) & 0xffffffffll) == (val & 0xffffffffll);\n-    }\n-\n+  int i;\n   /* V4SI with all identical symbols is valid. */\n   if (GET_MODE (x) == V4SImode\n       && (GET_CODE (CONST_VECTOR_ELT (x, 0)) == SYMBOL_REF\n@@ -2401,15 +2594,6 @@ spu_legitimate_constant_p (rtx x)\n       if (GET_CODE (CONST_VECTOR_ELT (x, i)) != CONST_INT\n \t  && GET_CODE (CONST_VECTOR_ELT (x, i)) != CONST_DOUBLE)\n \treturn 0;\n-\n-  constant_to_array (SImode, x, arr);\n-\n-  /* Check that bytes are repeated. */\n-  for (i = 4; i < 16; i += 4)\n-    for (j = 0; j < 4; j++)\n-      if (arr[j] != arr[i + j])\n-\treturn 0;\n-\n   return 1;\n }\n \n@@ -3069,56 +3253,8 @@ spu_expand_mov (rtx * ops, enum machine_mode mode)\n     }\n   if (reload_in_progress || reload_completed)\n     {\n-      enum machine_mode mode = GET_MODE (ops[0]);\n-      if (GET_CODE (ops[1]) == CONST_INT\n-\t  && (mode == DImode || mode == TImode)\n-\t  && ((INTVAL (ops[1]) >> 32) & 0xffffffffll) !=\n-\t  (INTVAL (ops[1]) & 0xffffffffll))\n-\t{\n-\t  rtx mem = force_const_mem (mode, ops[1]);\n-\t  if (TARGET_LARGE_MEM)\n-\t    {\n-\t      rtx addr = gen_rtx_REG (Pmode, REGNO (ops[0]));\n-\t      emit_move_insn (addr, XEXP (mem, 0));\n-\t      mem = replace_equiv_address (mem, addr);\n-\t    }\n-\t  emit_move_insn (ops[0], mem);\n-\t  return 1;\n-\t}\n-      else if ((GET_CODE (ops[1]) == CONST_INT\n-\t\t|| GET_CODE (ops[1]) == CONST_DOUBLE\n-\t\t|| GET_CODE (ops[1]) == CONST_VECTOR)\n-\t       && !immediate_load_p (ops[1], mode)\n-\t       && !fsmbi_const_p (ops[1]))\n-\t{\n-\t  unsigned char arrlo[16];\n-\t  unsigned char arrhi[16];\n-\t  rtx to = ops[0], hi, lo;\n-\t  int i;\n-\t  constant_to_array (mode, ops[1], arrhi);\n-\t  for (i = 0; i < 16; i += 4)\n-\t    {\n-\t      arrlo[i + 2] = arrhi[i + 2];\n-\t      arrlo[i + 3] = arrhi[i + 3];\n-\t      arrlo[i + 0] = arrlo[i + 1] = 0;\n-\t      arrhi[i + 2] = arrhi[i + 3] = 0;\n-\t    }\n-\t  if (mode == SFmode)\n-\t    {\n-\t      to = spu_gen_subreg (SImode, ops[0]);\n-\t      mode = SImode;\n-\t    }\n-\t  else if (mode == V4SFmode)\n-\t    {\n-\t      to = spu_gen_subreg (V4SImode, ops[0]);\n-\t      mode = V4SImode;\n-\t    }\n-\t  hi = array_to_constant (mode, arrhi);\n-\t  lo = array_to_constant (mode, arrlo);\n-\t  emit_move_insn (to, hi);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, to, gen_rtx_IOR (mode, to, lo)));\n-\t  return 1;\n-\t}\n+      if (CONSTANT_P (ops[1]))\n+\treturn spu_split_immediate (ops);\n       return 0;\n     }\n   else\n@@ -3474,19 +3610,59 @@ spu_valid_move (rtx * ops)\n int\n fsmbi_const_p (rtx x)\n {\n-  enum machine_mode mode;\n-  unsigned char arr[16];\n-  int i;\n+  if (CONSTANT_P (x))\n+    {\n+      /* We can always choose DImode for CONST_INT because the high bits\n+         of an SImode will always be all 1s, i.e., valid for fsmbi. */\n+      enum immediate_class c = classify_immediate (x, DImode);\n+      return c == IC_FSMBI;\n+    }\n+  return 0;\n+}\n+\n+/* Return TRUE if x is a CONST_INT, CONST_DOUBLE or CONST_VECTOR that\n+   can be generated using the cbd, chd, cwd or cdd instruction. */\n+int\n+cpat_const_p (rtx x, enum machine_mode mode)\n+{\n+  if (CONSTANT_P (x))\n+    {\n+      enum immediate_class c = classify_immediate (x, mode);\n+      return c == IC_CPAT;\n+    }\n+  return 0;\n+}\n \n-  /* We can always choose DImode for CONST_INT because the high bits of\n-     an SImode will always be all 1s, i.e., valid for fsmbi. */\n-  mode = GET_CODE (x) == CONST_INT ? DImode : GET_MODE (x);\n-  constant_to_array (mode, x, arr);\n+rtx\n+gen_cpat_const (rtx * ops)\n+{\n+  unsigned char dst[16];\n+  int i, offset, shift, isize;\n+  if (GET_CODE (ops[3]) != CONST_INT\n+      || GET_CODE (ops[2]) != CONST_INT\n+      || (GET_CODE (ops[1]) != CONST_INT\n+\t  && GET_CODE (ops[1]) != REG))\n+    return 0;\n+  if (GET_CODE (ops[1]) == REG\n+      && (!REG_POINTER (ops[1])\n+\t  || REGNO_POINTER_ALIGN (ORIGINAL_REGNO (ops[1])) < 128))\n+    return 0;\n \n   for (i = 0; i < 16; i++)\n-    if (arr[i] != 0 && arr[i] != 0xff)\n-      return 0;\n-  return 1;\n+    dst[i] = i + 16;\n+  isize = INTVAL (ops[3]);\n+  if (isize == 1)\n+    shift = 3;\n+  else if (isize == 2)\n+    shift = 2;\n+  else\n+    shift = 0;\n+  offset = (INTVAL (ops[2]) +\n+\t    (GET_CODE (ops[1]) ==\n+\t     CONST_INT ? INTVAL (ops[1]) : 0)) & 15;\n+  for (i = 0; i < isize; i++)\n+    dst[offset + i] = i + shift;\n+  return array_to_constant (TImode, dst);\n }\n \n /* Convert a CONST_INT, CONST_DOUBLE, or CONST_VECTOR into a 16 byte"}, {"sha": "9cb0dc7f40091c2ff4dcf360c70ea6d660ede34f", "filename": "gcc/config/spu/spu.md", "status": "modified", "additions": 59, "deletions": 34, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c6e4b8032413edf7d42b2b43757431512af7b9/gcc%2Fconfig%2Fspu%2Fspu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c6e4b8032413edf7d42b2b43757431512af7b9/gcc%2Fconfig%2Fspu%2Fspu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.md?ref=a1c6e4b8032413edf7d42b2b43757431512af7b9", "patch": "@@ -238,26 +238,19 @@\n   })\n \n (define_split \n-  [(set (match_operand:SI 0 \"spu_reg_operand\" \"=r\")\n-\t(match_operand:SI 1 \"immediate_operand\" \"s\"))]\n-\n-  \"(flag_pic || TARGET_LARGE_MEM\n-    || (GET_CODE (operands[1]) == CONST\n-        && !legitimate_const (operands[1], 0)))\n-   && (reload_in_progress || reload_completed)\n-   && (GET_CODE (operands[1]) == CONST\n-       || GET_CODE (operands[1]) == SYMBOL_REF\n-       || GET_CODE (operands[1]) == LABEL_REF)\"\n-  [(parallel\n-    [(set (match_dup:SI 0)\n-\t  (match_dup:SI 1))\n-     (use (const_int 0))])\n-   (set (match_dup:SI 0)\n-\t(plus:SI (match_dup:SI 0)\n-\t\t (match_dup:SI 2)))]\n+  [(set (match_operand 0 \"spu_reg_operand\")\n+\t(match_operand 1 \"immediate_operand\"))]\n+\n+  \"\"\n+  [(set (match_dup 0)\n+\t(high (match_dup 1)))\n+   (set (match_dup 0)\n+\t(lo_sum (match_dup 0)\n+\t        (match_dup 1)))]\n   {\n-    spu_split_address(operands);\n-    DONE;\n+    if (spu_split_immediate (operands))\n+      DONE;\n+    FAIL;\n   })\n \n (define_insn \"pic\"\n@@ -285,16 +278,17 @@\n ;; move internal\n \n (define_insn \"_mov<mode>\"\n-  [(set (match_operand:MOV 0 \"spu_nonimm_operand\" \"=r,r,r,r,m\")\n-\t(match_operand:MOV 1 \"spu_mov_operand\" \"r,A,f,m,r\"))]\n+  [(set (match_operand:MOV 0 \"spu_nonimm_operand\" \"=r,r,r,r,r,m\")\n+\t(match_operand:MOV 1 \"spu_mov_operand\" \"r,A,f,j,m,r\"))]\n   \"spu_valid_move (operands)\"\n   \"@\n    ori\\t%0,%1,0\n    il%s1\\t%0,%S1\n-   fsmbi\\t%0,%F1\n+   fsmbi\\t%0,%S1\n+   c%s1d\\t%0,%S1($sp)\n    lq%p1\\t%0,%1\n    stq%p0\\t%1,%0\"\n-  [(set_attr \"type\" \"fx2,fx2,shuf,load,store\")])\n+  [(set_attr \"type\" \"fx2,fx2,shuf,shuf,load,store\")])\n \n (define_insn \"high\"\n   [(set (match_operand:SI 0 \"spu_reg_operand\" \"=r\")\n@@ -310,28 +304,30 @@\n   \"iohl\\t%0,%2@l\")\n \n (define_insn \"_movdi\"\n-  [(set (match_operand:DI 0 \"spu_nonimm_operand\" \"=r,r,r,r,m\")\n-\t(match_operand:DI 1 \"spu_mov_operand\" \"r,a,f,m,r\"))]\n+  [(set (match_operand:DI 0 \"spu_nonimm_operand\" \"=r,r,r,r,r,m\")\n+\t(match_operand:DI 1 \"spu_mov_operand\" \"r,a,f,k,m,r\"))]\n   \"spu_valid_move (operands)\"\n   \"@\n    ori\\t%0,%1,0\n    il%d1\\t%0,%D1\n-   fsmbi\\t%0,%G1\n+   fsmbi\\t%0,%D1\n+   c%d1d\\t%0,%D1($sp)\n    lq%p1\\t%0,%1\n    stq%p0\\t%1,%0\"\n-  [(set_attr \"type\" \"fx2,fx2,shuf,load,store\")])\n+  [(set_attr \"type\" \"fx2,fx2,shuf,shuf,load,store\")])\n \n (define_insn \"_movti\"\n-  [(set (match_operand:TI 0 \"spu_nonimm_operand\" \"=r,r,r,r,m\")\n-\t(match_operand:TI 1 \"spu_mov_operand\" \"r,U,f,m,r\"))]\n+  [(set (match_operand:TI 0 \"spu_nonimm_operand\" \"=r,r,r,r,r,m\")\n+\t(match_operand:TI 1 \"spu_mov_operand\" \"r,U,f,l,m,r\"))]\n   \"spu_valid_move (operands)\"\n   \"@\n    ori\\t%0,%1,0\n    il%t1\\t%0,%T1\n-   fsmbi\\t%0,%H1\n+   fsmbi\\t%0,%T1\n+   c%t1d\\t%0,%T1($sp)\n    lq%p1\\t%0,%1\n    stq%p0\\t%1,%0\"\n-  [(set_attr \"type\" \"fx2,fx2,shuf,load,store\")])\n+  [(set_attr \"type\" \"fx2,fx2,shuf,shuf,load,store\")])\n \n (define_insn_and_split \"load\"\n   [(set (match_operand 0 \"spu_reg_operand\" \"=r\")\n@@ -358,17 +354,46 @@\n   { spu_split_store(operands); DONE; })\n \n ;; Operand 3 is the number of bytes. 1:b 2:h 4:w 8:d\n-(define_insn \"cpat\"\n+\n+(define_expand \"cpat\"\n   [(set (match_operand:TI 0 \"spu_reg_operand\" \"=r,r\")\n-        (unspec:TI [(match_operand:SI 1 \"spu_reg_operand\" \"r,r\")\n-                    (match_operand:SI 2 \"spu_nonmem_operand\" \"r,n\")\n+\t(unspec:TI [(match_operand:SI 1 \"spu_reg_operand\" \"r,r\")\n+\t\t    (match_operand:SI 2 \"spu_nonmem_operand\" \"r,n\")\n+\t\t    (match_operand:SI 3 \"immediate_operand\" \"i,i\")] UNSPEC_CPAT))]\n+  \"\"\n+  {\n+    rtx x = gen_cpat_const (operands);\n+    if (x)\n+      {\n+        emit_move_insn (operands[0], x);\n+        DONE;\n+      }\n+  })\n+\n+(define_insn \"_cpat\"\n+  [(set (match_operand:TI 0 \"spu_reg_operand\" \"=r,r\")\n+\t(unspec:TI [(match_operand:SI 1 \"spu_reg_operand\" \"r,r\")\n+\t\t    (match_operand:SI 2 \"spu_nonmem_operand\" \"r,n\")\n \t\t    (match_operand:SI 3 \"immediate_operand\" \"i,i\")] UNSPEC_CPAT))]\n   \"\"\n   \"@\n    c%M3x\\t%0,%1,%2\n    c%M3d\\t%0,%C2(%1)\"\n   [(set_attr \"type\" \"shuf\")])\n \n+(define_split\n+  [(set (match_operand:TI 0 \"spu_reg_operand\")\n+\t(unspec:TI [(match_operand:SI 1 \"spu_nonmem_operand\")\n+\t\t    (match_operand:SI 2 \"immediate_operand\")\n+\t\t    (match_operand:SI 3 \"immediate_operand\")] UNSPEC_CPAT))]\n+  \"\"\n+  [(set (match_dup:TI 0)\n+        (match_dup:TI 4))]\n+  {\n+    operands[4] = gen_cpat_const (operands);\n+    if (!operands[4])\n+      FAIL;\n+  })\n \f\n ;; extend\n "}]}