{"sha": "ed2181fc2a3ff3a0f65110c906093d5ce0d8e048", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQyMTgxZmMyYTNmZjNhMGY2NTExMGM5MDYwOTNkNWNlMGQ4ZTA0OA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2019-11-12T01:09:47Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2019-11-12T01:09:47Z"}, "message": "[RS6000] Remove TARGET_TLS_MARKERS and require binutils 2.20\n\nThis patch removes !TARGET_TLS_MARKERS support.  -mtls-markers (and\n-mno-tls-markers) disappear as valid options too, because I figure\nthey haven't been used too much except by people testing the\ncompiler.\n\n\t* config/rs6000/rs6000.opt (mtls-markers): Delete.\n\t* config/rs6000/rs6000.h (TARGET_TLS_MARKERS): Don't define.\n\t(IS_NOMARK_TLSGETADDR): Likewise.\n\t* config/rs6000/rs6000-protos.h (rs6000_output_tlsargs): Delete.\n\t* config/rs6000/rs6000.c (rs6000_output_tlsargs): Delete.\n\t(rs6000_legitimize_tls_address): Remove !TARGET_TLS_MARKERS code.\n\t(rs6000_call_template_1): Delete TARGET_TLS_MARKERS test and\n\tallow other UNSPECs besides UNSPEC_TLSGD and UNSPEC_TLSLD.\n\t(rs6000_indirect_call_template_1): Likewise.\n\t(rs6000_pltseq_template): Likewise.\n\t(rs6000_opt_vars): Remove \"tls-markers\" entry.\n\t* config/rs6000/rs6000.md (tls_gd<bits>): Replace TARGET_TLS_MARKERS\n\twith TARGET_ELF.\n\t(tls_gd_high<bits>, tls_gd_low<bits>): Likewise.\n\t(tls_ld<bits>, tls_ld_high<bits>, tls_ld_low<bits>): Likewise.\n\t(pltseq_plt_pcrel<mode>): Likewise.\n\t(call_value_local32): Remove IS_NOMARK_TLSGETADDR predicate test.\n\t(call_value_local64): Likewise.\n\t(call_value_indirect_nonlocal_sysv<mode>): Remove IS_NOMARK_TLSGETADDR\n\toutput and length attribute sub-expression.\n\t(call_value_nonlocal_sysv<mode>),\n\t(call_value_nonlocal_sysv_secure<mode>),\n\t(call_value_local_aix<mode>, call_value_nonlocal_aix<mode>),\n\t(call_value_indirect_aix<mode>, call_value_indirect_elfv2<mode>),\n\t(call_value_indirect_pcrel<mode>): Likewise.\n\t* doc/install.texi (powerpc-*-*): Require binutils-2.20.\n\t* configure.ac (HAVE_AS_TLS_MARKERS): Delete test.\n\t* configure: Regenerate.\n\t* config.in: Regenerate.\n\nFrom-SVN: r278075", "tree": {"sha": "e0ec94ff898295cafab368eb84df1015c8792dc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0ec94ff898295cafab368eb84df1015c8792dc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a2615b0690d1fabdb17e4545a1c48d5c63bcfb00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2615b0690d1fabdb17e4545a1c48d5c63bcfb00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2615b0690d1fabdb17e4545a1c48d5c63bcfb00"}], "stats": {"total": 283, "additions": 70, "deletions": 213}, "files": [{"sha": "4fdb911ab8bf0dc9232e94e8854c317e96cd8dc7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed2181fc2a3ff3a0f65110c906093d5ce0d8e048", "patch": "@@ -1,3 +1,35 @@\n+2019-11-12  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/rs6000.opt (mtls-markers): Delete.\n+\t* config/rs6000/rs6000.h (TARGET_TLS_MARKERS): Don't define.\n+\t(IS_NOMARK_TLSGETADDR): Likewise.\n+\t* config/rs6000/rs6000-protos.h (rs6000_output_tlsargs): Delete.\n+\t* config/rs6000/rs6000.c (rs6000_output_tlsargs): Delete.\n+\t(rs6000_legitimize_tls_address): Remove !TARGET_TLS_MARKERS code.\n+\t(rs6000_call_template_1): Delete TARGET_TLS_MARKERS test and\n+\tallow other UNSPECs besides UNSPEC_TLSGD and UNSPEC_TLSLD.\n+\t(rs6000_indirect_call_template_1): Likewise.\n+\t(rs6000_pltseq_template): Likewise.\n+\t(rs6000_opt_vars): Remove \"tls-markers\" entry.\n+\t* config/rs6000/rs6000.md (tls_gd<bits>): Replace TARGET_TLS_MARKERS\n+\twith TARGET_ELF.\n+\t(tls_gd_high<bits>, tls_gd_low<bits>): Likewise.\n+\t(tls_ld<bits>, tls_ld_high<bits>, tls_ld_low<bits>): Likewise.\n+\t(pltseq_plt_pcrel<mode>): Likewise.\n+\t(call_value_local32): Remove IS_NOMARK_TLSGETADDR predicate test.\n+\t(call_value_local64): Likewise.\n+\t(call_value_indirect_nonlocal_sysv<mode>): Remove IS_NOMARK_TLSGETADDR\n+\toutput and length attribute sub-expression.\n+\t(call_value_nonlocal_sysv<mode>),\n+\t(call_value_nonlocal_sysv_secure<mode>),\n+\t(call_value_local_aix<mode>, call_value_nonlocal_aix<mode>),\n+\t(call_value_indirect_aix<mode>, call_value_indirect_elfv2<mode>),\n+\t(call_value_indirect_pcrel<mode>): Likewise.\n+\t* doc/install.texi (powerpc-*-*): Require binutils-2.20.\n+\t* configure.ac (HAVE_AS_TLS_MARKERS): Delete test.\n+\t* configure: Regenerate.\n+\t* config.in: Regenerate.\n+\n 2019-11-11  Michael Meissner  <meissner@linux.ibm.com>\n \n \t* config/rs6000/predicates.md (prefixed_memory): New predicate."}, {"sha": "e2542ad8ff5fbfc780b1d8ae018a3388940c82a5", "filename": "gcc/config.in", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=ed2181fc2a3ff3a0f65110c906093d5ce0d8e048", "patch": "@@ -669,12 +669,6 @@\n #endif\n \n \n-/* Define if your assembler supports arg info for __tls_get_addr. */\n-#ifndef USED_FOR_TARGET\n-#undef HAVE_AS_TLS_MARKERS\n-#endif\n-\n-\n /* Define if your assembler supports vl/vst/vlm/vstm with an optional\n    alignment hint argument. */\n #ifndef USED_FOR_TARGET"}, {"sha": "0dddb4017ee9a3726325d7e50b648f16499ef177", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=ed2181fc2a3ff3a0f65110c906093d5ce0d8e048", "patch": "@@ -139,7 +139,6 @@ extern bool valid_sf_si_move (rtx, rtx, machine_mode);\n extern void rs6000_emit_move (rtx, rtx, machine_mode);\n extern bool rs6000_legitimate_offset_address_p (machine_mode, rtx,\n \t\t\t\t\t\tbool, bool);\n-extern void rs6000_output_tlsargs (rtx *);\n extern rtx rs6000_find_base_term (rtx);\n extern rtx rs6000_return_addr (int, rtx);\n extern void rs6000_output_symbol_ref (FILE*, rtx);"}, {"sha": "892ee94032f56d1d036fb4721c46b71e2c4e3326", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 9, "deletions": 65, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ed2181fc2a3ff3a0f65110c906093d5ce0d8e048", "patch": "@@ -8500,41 +8500,6 @@ rs6000_legitimize_tls_address_aix (rtx addr, enum tls_model model)\n   return dest;\n }\n \n-/* Output arg setup instructions for a !TARGET_TLS_MARKERS\n-   __tls_get_addr call.  */\n-\n-void\n-rs6000_output_tlsargs (rtx *operands)\n-{\n-  /* Set up operands for output_asm_insn, without modifying OPERANDS.  */\n-  rtx op[3];\n-\n-  /* The set dest of the call, ie. r3, which is also the first arg reg.  */\n-  op[0] = operands[0];\n-  /* The TLS symbol from global_tlsarg stashed as CALL operand 2.  */\n-  op[1] = XVECEXP (operands[2], 0, 0);\n-  if (XINT (operands[2], 1) == UNSPEC_TLSGD)\n-    {\n-      /* The GOT register.  */\n-      op[2] = XVECEXP (operands[2], 0, 1);\n-      if (TARGET_CMODEL != CMODEL_SMALL)\n-\toutput_asm_insn (\"addis %0,%2,%1@got@tlsgd@ha\\n\\t\"\n-\t\t\t \"addi %0,%0,%1@got@tlsgd@l\", op);\n-      else\n-\toutput_asm_insn (\"addi %0,%2,%1@got@tlsgd\", op);\n-    }\n-  else if (XINT (operands[2], 1) == UNSPEC_TLSLD)\n-    {\n-      if (TARGET_CMODEL != CMODEL_SMALL)\n-\toutput_asm_insn (\"addis %0,%1,%&@got@tlsld@ha\\n\\t\"\n-\t\t\t \"addi %0,%0,%&@got@tlsld@l\", op);\n-      else\n-\toutput_asm_insn (\"addi %0,%1,%&@got@tlsld\", op);\n-    }\n-  else\n-    gcc_unreachable ();\n-}\n-\n /* Passes the tls arg value for global dynamic and local dynamic\n    emit_library_call_value in rs6000_legitimize_tls_address to\n    rs6000_call_aix and rs6000_call_sysv.  This is used to emit the\n@@ -8636,16 +8601,10 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n \t  rtx arg = gen_rtx_UNSPEC (Pmode, gen_rtvec (2, addr, got),\n \t\t\t\t    UNSPEC_TLSGD);\n \t  tga = rs6000_tls_get_addr ();\n+\t  rtx argreg = gen_rtx_REG (Pmode, 3);\n+\t  emit_insn (gen_rtx_SET (argreg, arg));\n \t  global_tlsarg = arg;\n-\t  if (TARGET_TLS_MARKERS)\n-\t    {\n-\t      rtx argreg = gen_rtx_REG (Pmode, 3);\n-\t      emit_insn (gen_rtx_SET (argreg, arg));\n-\t      emit_library_call_value (tga, dest, LCT_CONST, Pmode,\n-\t\t\t\t       argreg, Pmode);\n-\t    }\n-\t  else\n-\t    emit_library_call_value (tga, dest, LCT_CONST, Pmode);\n+\t  emit_library_call_value (tga, dest, LCT_CONST, Pmode, argreg, Pmode);\n \t  global_tlsarg = NULL_RTX;\n \n \t  /* Make a note so that the result of this call can be CSEd.  */\n@@ -8658,16 +8617,10 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n \t  rtx arg = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, got), UNSPEC_TLSLD);\n \t  tga = rs6000_tls_get_addr ();\n \t  tmp1 = gen_reg_rtx (Pmode);\n+\t  rtx argreg = gen_rtx_REG (Pmode, 3);\n+\t  emit_insn (gen_rtx_SET (argreg, arg));\n \t  global_tlsarg = arg;\n-\t  if (TARGET_TLS_MARKERS)\n-\t    {\n-\t      rtx argreg = gen_rtx_REG (Pmode, 3);\n-\t      emit_insn (gen_rtx_SET (argreg, arg));\n-\t      emit_library_call_value (tga, tmp1, LCT_CONST, Pmode,\n-\t\t\t\t       argreg, Pmode);\n-\t    }\n-\t  else\n-\t    emit_library_call_value (tga, tmp1, LCT_CONST, Pmode);\n+\t  emit_library_call_value (tga, tmp1, LCT_CONST, Pmode, argreg, Pmode);\n \t  global_tlsarg = NULL_RTX;\n \n \t  /* Make a note so that the result of this call can be CSEd.  */\n@@ -13455,14 +13408,12 @@ rs6000_call_template_1 (rtx *operands, unsigned int funop, bool sibcall)\n \n   char arg[12];\n   arg[0] = 0;\n-  if (TARGET_TLS_MARKERS && GET_CODE (operands[funop + 1]) == UNSPEC)\n+  if (GET_CODE (operands[funop + 1]) == UNSPEC)\n     {\n       if (XINT (operands[funop + 1], 1) == UNSPEC_TLSGD)\n \tsprintf (arg, \"(%%%u@tlsgd)\", funop + 1);\n       else if (XINT (operands[funop + 1], 1) == UNSPEC_TLSLD)\n \tsprintf (arg, \"(%%&@tlsld)\");\n-      else\n-\tgcc_unreachable ();\n     }\n \n   /* The magic 32768 offset here corresponds to the offset of\n@@ -13603,16 +13554,14 @@ rs6000_indirect_call_template_1 (rtx *operands, unsigned int funop,\n       const char *rel64 = TARGET_64BIT ? \"64\" : \"\";\n       char tls[29];\n       tls[0] = 0;\n-      if (TARGET_TLS_MARKERS && GET_CODE (operands[funop + 1]) == UNSPEC)\n+      if (GET_CODE (operands[funop + 1]) == UNSPEC)\n \t{\n \t  if (XINT (operands[funop + 1], 1) == UNSPEC_TLSGD)\n \t    sprintf (tls, \".reloc .,R_PPC%s_TLSGD,%%%u\\n\\t\",\n \t\t     rel64, funop + 1);\n \t  else if (XINT (operands[funop + 1], 1) == UNSPEC_TLSLD)\n \t    sprintf (tls, \".reloc .,R_PPC%s_TLSLD,%%&\\n\\t\",\n \t\t     rel64);\n-\t  else\n-\t    gcc_unreachable ();\n \t}\n \n       const char *notoc = rs6000_pcrel_p (cfun) ? \"_NOTOC\" : \"\";\n@@ -13699,7 +13648,7 @@ rs6000_pltseq_template (rtx *operands, int which)\n   const char *rel64 = TARGET_64BIT ? \"64\" : \"\";\n   char tls[30];\n   tls[0] = 0;\n-  if (TARGET_TLS_MARKERS && GET_CODE (operands[3]) == UNSPEC)\n+  if (GET_CODE (operands[3]) == UNSPEC)\n     {\n       char off = which == RS6000_PLTSEQ_PLT_PCREL34 ? '8' : '4';\n       if (XINT (operands[3], 1) == UNSPEC_TLSGD)\n@@ -13708,8 +13657,6 @@ rs6000_pltseq_template (rtx *operands, int which)\n       else if (XINT (operands[3], 1) == UNSPEC_TLSLD)\n \tsprintf (tls, \".reloc .-%c,R_PPC%s_TLSLD,%%&\\n\\t\",\n \t\t off, rel64);\n-      else\n-\tgcc_unreachable ();\n     }\n \n   gcc_assert (DEFAULT_ABI == ABI_ELFv2 || DEFAULT_ABI == ABI_V4);\n@@ -22976,9 +22923,6 @@ static struct rs6000_opt_var const rs6000_opt_vars[] =\n   { \"align-branch-targets\",\n     offsetof (struct gcc_options, x_TARGET_ALIGN_BRANCH_TARGETS),\n     offsetof (struct cl_target_option, x_TARGET_ALIGN_BRANCH_TARGETS), },\n-  { \"tls-markers\",\n-    offsetof (struct gcc_options, x_tls_markers),\n-    offsetof (struct cl_target_option, x_tls_markers), },\n   { \"sched-prolog\",\n     offsetof (struct gcc_options, x_TARGET_SCHED_PROLOG),\n     offsetof (struct cl_target_option, x_TARGET_SCHED_PROLOG), },"}, {"sha": "7f9cb1ce2e31ac751366289eb258a09583594e61", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=ed2181fc2a3ff3a0f65110c906093d5ce0d8e048", "patch": "@@ -228,15 +228,6 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define TARGET_MFCRF 0\n #endif\n \n-/* Define TARGET_TLS_MARKERS if the target assembler does not support\n-   arg markers for __tls_get_addr calls.  */\n-#ifndef HAVE_AS_TLS_MARKERS\n-#undef  TARGET_TLS_MARKERS\n-#define TARGET_TLS_MARKERS 0\n-#else\n-#define TARGET_TLS_MARKERS tls_markers\n-#endif\n-\n #ifndef TARGET_SECURE_PLT\n #define TARGET_SECURE_PLT 0\n #endif\n@@ -1488,13 +1479,6 @@ enum rs6000_pltseq_enum {\n #define IS_V4_FP_ARGS(OP) \\\n   ((INTVAL (OP) & (CALL_V4_CLEAR_FP_ARGS | CALL_V4_SET_FP_ARGS)) != 0)\n \n-/* Whether OP is an UNSPEC used in !TARGET_TLS_MARKER calls.  */\n-#define IS_NOMARK_TLSGETADDR(OP)\t\t\\\n-  (!TARGET_TLS_MARKERS\t\t\t\t\\\n-   && GET_CODE (OP) == UNSPEC\t\t\t\\\n-   && (XINT (OP, 1) == UNSPEC_TLSGD\t\t\\\n-       || XINT (OP, 1) == UNSPEC_TLSLD))\n-\n /* We don't have prologue and epilogue functions to save/restore\n    everything for most ABIs.  */\n #define WORLD_SAVE_P(INFO) 0"}, {"sha": "0fc0f952611cdb22ddeb6de1e79df195a5226d84", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 28, "deletions": 78, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=ed2181fc2a3ff3a0f65110c906093d5ce0d8e048", "patch": "@@ -9500,7 +9500,7 @@\n \t(unspec:P [(match_operand:P 1 \"rs6000_tls_symbol_ref\" \"\")\n \t\t   (match_operand:P 2 \"gpc_reg_operand\" \"b\")]\n \t\t  UNSPEC_TLSGD))]\n-  \"HAVE_AS_TLS && TARGET_TLS_MARKERS\"\n+  \"HAVE_AS_TLS && TARGET_ELF\"\n   \"addi %0,%2,%1@got@tlsgd\"\n   \"&& TARGET_CMODEL != CMODEL_SMALL\"\n   [(set (match_dup 3)\n@@ -9523,7 +9523,7 @@\n        (unspec:P [(match_operand:P 1 \"rs6000_tls_symbol_ref\" \"\")\n \t\t  (match_operand:P 2 \"gpc_reg_operand\" \"b\")]\n \t\t UNSPEC_TLSGD)))]\n-  \"HAVE_AS_TLS && TARGET_TLS_MARKERS && TARGET_CMODEL != CMODEL_SMALL\"\n+  \"HAVE_AS_TLS && TARGET_ELF && TARGET_CMODEL != CMODEL_SMALL\"\n   \"addis %0,%2,%1@got@tlsgd@ha\")\n \n (define_insn \"*tls_gd_low<bits>\"\n@@ -9532,14 +9532,14 @@\n        (unspec:P [(match_operand:P 2 \"rs6000_tls_symbol_ref\" \"\")\n \t\t  (match_operand:P 3 \"gpc_reg_operand\" \"b\")]\n \t\t UNSPEC_TLSGD)))]\n-  \"HAVE_AS_TLS && TARGET_TLS_MARKERS && TARGET_CMODEL != CMODEL_SMALL\"\n+  \"HAVE_AS_TLS && TARGET_ELF && TARGET_CMODEL != CMODEL_SMALL\"\n   \"addi %0,%1,%2@got@tlsgd@l\")\n \n (define_insn_and_split \"*tls_ld<bits>\"\n   [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n \t(unspec:P [(match_operand:P 1 \"gpc_reg_operand\" \"b\")]\n \t\t  UNSPEC_TLSLD))]\n-  \"HAVE_AS_TLS && TARGET_TLS_MARKERS\"\n+  \"HAVE_AS_TLS && TARGET_ELF\"\n   \"addi %0,%1,%&@got@tlsld\"\n   \"&& TARGET_CMODEL != CMODEL_SMALL\"\n   [(set (match_dup 2)\n@@ -9561,15 +9561,15 @@\n      (high:P\n        (unspec:P [(match_operand:P 1 \"gpc_reg_operand\" \"b\")]\n \t\t UNSPEC_TLSLD)))]\n-  \"HAVE_AS_TLS && TARGET_TLS_MARKERS && TARGET_CMODEL != CMODEL_SMALL\"\n+  \"HAVE_AS_TLS && TARGET_ELF && TARGET_CMODEL != CMODEL_SMALL\"\n   \"addis %0,%1,%&@got@tlsld@ha\")\n \n (define_insn \"*tls_ld_low<bits>\"\n   [(set (match_operand:P 0 \"gpc_reg_operand\" \"=b\")\n      (lo_sum:P (match_operand:P 1 \"gpc_reg_operand\" \"b\")\n        (unspec:P [(match_operand:P 2 \"gpc_reg_operand\" \"b\")]\n \t\t UNSPEC_TLSLD)))]\n-  \"HAVE_AS_TLS && TARGET_TLS_MARKERS && TARGET_CMODEL != CMODEL_SMALL\"\n+  \"HAVE_AS_TLS && TARGET_ELF && TARGET_CMODEL != CMODEL_SMALL\"\n   \"addi %0,%1,%&@got@tlsld@l\")\n \n (define_insn \"tls_dtprel_<bits>\"\n@@ -10303,7 +10303,7 @@\n \t\t   (match_operand:P 2 \"symbol_ref_operand\" \"s\")\n \t\t   (match_operand:P 3 \"\" \"\")]\n \t\t  UNSPEC_PLT_PCREL))]\n-  \"HAVE_AS_PLTSEQ && TARGET_TLS_MARKERS\n+  \"HAVE_AS_PLTSEQ && TARGET_ELF\n    && rs6000_pcrel_p (cfun)\"\n {\n   return rs6000_pltseq_template (operands, RS6000_PLTSEQ_PLT_PCREL34);\n@@ -10418,8 +10418,7 @@\n \t      (match_operand 2)))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n    (clobber (reg:SI LR_REGNO))]\n-  \"(INTVAL (operands[3]) & CALL_LONG) == 0\n-   && !IS_NOMARK_TLSGETADDR (operands[2])\"\n+  \"(INTVAL (operands[3]) & CALL_LONG) == 0\"\n {\n   if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n     output_asm_insn (\"crxor 6,6,6\", operands);\n@@ -10439,8 +10438,7 @@\n \t      (match_operand 2)))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n    (clobber (reg:DI LR_REGNO))]\n-  \"TARGET_64BIT && (INTVAL (operands[3]) & CALL_LONG) == 0\n-   && !IS_NOMARK_TLSGETADDR (operands[2])\"\n+  \"TARGET_64BIT && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n {\n   if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n     output_asm_insn (\"crxor 6,6,6\", operands);\n@@ -10538,10 +10536,7 @@\n   \"DEFAULT_ABI == ABI_V4\n    || DEFAULT_ABI == ABI_DARWIN\"\n {\n-  if (IS_NOMARK_TLSGETADDR (operands[2]))\n-    rs6000_output_tlsargs (operands);\n-\n-  else if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n+  if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n     output_asm_insn (\"crxor 6,6,6\", operands);\n \n   else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n@@ -10552,8 +10547,7 @@\n   [(set_attr \"type\" \"jmpreg\")\n    (set (attr \"length\")\n \t(plus\n-\t  (if_then_else (ior (match_test \"IS_NOMARK_TLSGETADDR (operands[2])\")\n-\t\t\t     (match_test \"IS_V4_FP_ARGS (operands[3])\"))\n+\t  (if_then_else (match_test \"IS_V4_FP_ARGS (operands[3])\")\n \t    (const_int 4)\n \t    (const_int 0))\n \t  (if_then_else (and (match_test \"!rs6000_speculate_indirect_jumps\")\n@@ -10571,10 +10565,7 @@\n     || (DEFAULT_ABI == ABI_V4\n \t&& (INTVAL (operands[3]) & CALL_LONG) == 0))\"\n {\n-  if (IS_NOMARK_TLSGETADDR (operands[2]))\n-    rs6000_output_tlsargs (operands);\n-\n-  else if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n+  if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n     output_asm_insn (\"crxor 6,6,6\", operands);\n \n   else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n@@ -10584,8 +10575,7 @@\n }\n   [(set_attr \"type\" \"branch\")\n    (set (attr \"length\")\n-\t(if_then_else (ior (match_test \"IS_NOMARK_TLSGETADDR (operands[2])\")\n-\t\t\t   (match_test \"IS_V4_FP_ARGS (operands[3])\"))\n+\t(if_then_else (match_test \"IS_V4_FP_ARGS (operands[3])\")\n \t  (const_int 8)\n \t  (const_int 4)))])\n \n@@ -10600,10 +10590,7 @@\n     && TARGET_SECURE_PLT && flag_pic && !SYMBOL_REF_LOCAL_P (operands[1])\n     && (INTVAL (operands[3]) & CALL_LONG) == 0)\"\n {\n-  if (IS_NOMARK_TLSGETADDR (operands[2]))\n-    rs6000_output_tlsargs (operands);\n-\n-  else if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n+  if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n     output_asm_insn (\"crxor 6,6,6\", operands);\n \n   else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n@@ -10613,8 +10600,7 @@\n }\n   [(set_attr \"type\" \"branch\")\n    (set (attr \"length\")\n-\t(if_then_else (ior (match_test \"IS_NOMARK_TLSGETADDR (operands[2])\")\n-\t\t\t   (match_test \"IS_V4_FP_ARGS (operands[3])\"))\n+\t(if_then_else (match_test \"IS_V4_FP_ARGS (operands[3])\")\n \t  (const_int 8)\n \t  (const_int 4)))])\n \n@@ -10637,8 +10623,7 @@\n \t(call (mem:SI (match_operand:P 1 \"current_file_function_operand\" \"s\"))\n \t      (match_operand 2)))\n    (clobber (reg:P LR_REGNO))]\n-  \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n-   && !IS_NOMARK_TLSGETADDR (operands[2])\"\n+  \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n {\n   if (rs6000_pcrel_p (cfun))\n     return \"bl %z1@notoc\";\n@@ -10670,21 +10655,13 @@\n    (clobber (reg:P LR_REGNO))]\n   \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n {\n-  if (IS_NOMARK_TLSGETADDR (operands[2]))\n-    rs6000_output_tlsargs (operands);\n-\n   return rs6000_call_template (operands, 1);\n }\n   [(set_attr \"type\" \"branch\")\n    (set (attr \"length\")\n-\t(plus (if_then_else (match_test \"IS_NOMARK_TLSGETADDR (operands[2])\")\n-\t\t(if_then_else (match_test \"TARGET_CMODEL != CMODEL_SMALL\")\n-\t\t  (const_int 8)\n-\t\t  (const_int 4))\n-\t\t(const_int 0))\n-\t      (if_then_else (match_test \"rs6000_pcrel_p (cfun)\")\n-\t\t(const_int 4)\n-\t\t(const_int 8))))])\n+\t(if_then_else (match_test \"rs6000_pcrel_p (cfun)\")\n+\t    (const_int 4)\n+\t    (const_int 8)))])\n \n ;; Call to indirect functions with the AIX abi using a 3 word descriptor.\n ;; Operand0 is the addresss of the function to call\n@@ -10719,23 +10696,14 @@\n    (clobber (reg:P LR_REGNO))]\n   \"DEFAULT_ABI == ABI_AIX\"\n {\n-  if (IS_NOMARK_TLSGETADDR (operands[2]))\n-    rs6000_output_tlsargs (operands);\n-\n   return rs6000_indirect_call_template (operands, 1);\n }\n   [(set_attr \"type\" \"jmpreg\")\n    (set (attr \"length\")\n-\t(plus\n-\t  (if_then_else (match_test \"IS_NOMARK_TLSGETADDR (operands[2])\")\n-\t    (if_then_else (match_test \"TARGET_CMODEL != CMODEL_SMALL\")\n-\t      (const_int 8)\n-\t      (const_int 4))\n-\t    (const_int 0))\n-\t  (if_then_else (and (match_test \"!rs6000_speculate_indirect_jumps\")\n-\t\t\t     (match_test \"which_alternative != 1\"))\n+\t(if_then_else (and (match_test \"!rs6000_speculate_indirect_jumps\")\n+\t\t\t   (match_test \"which_alternative != 1\"))\n \t    (const_string \"16\")\n-\t    (const_string \"12\"))))])\n+\t    (const_string \"12\")))])\n \n ;; Call to indirect functions with the ELFv2 ABI.\n ;; Operand0 is the addresss of the function to call\n@@ -10782,23 +10750,14 @@\n    (clobber (reg:P LR_REGNO))]\n   \"DEFAULT_ABI == ABI_ELFv2\"\n {\n-  if (IS_NOMARK_TLSGETADDR (operands[2]))\n-    rs6000_output_tlsargs (operands);\n-\n   return rs6000_indirect_call_template (operands, 1);\n }\n   [(set_attr \"type\" \"jmpreg\")\n    (set (attr \"length\")\n-\t(plus\n-\t  (if_then_else (match_test \"IS_NOMARK_TLSGETADDR (operands[2])\")\n-\t    (if_then_else (match_test \"TARGET_CMODEL != CMODEL_SMALL\")\n-\t      (const_int 8)\n-\t      (const_int 4))\n-\t    (const_int 0))\n-\t  (if_then_else (and (match_test \"!rs6000_speculate_indirect_jumps\")\n-\t\t\t     (match_test \"which_alternative != 1\"))\n+\t(if_then_else (and (match_test \"!rs6000_speculate_indirect_jumps\")\n+\t\t\t   (match_test \"which_alternative != 1\"))\n \t    (const_string \"12\")\n-\t    (const_string \"8\"))))])\n+\t    (const_string \"8\")))])\n \n (define_insn \"*call_value_indirect_pcrel<mode>\"\n   [(set (match_operand 0 \"\" \"\")\n@@ -10807,23 +10766,14 @@\n    (clobber (reg:P LR_REGNO))]\n   \"rs6000_pcrel_p (cfun)\"\n {\n-  if (IS_NOMARK_TLSGETADDR (operands[2]))\n-    rs6000_output_tlsargs (operands);\n-\n   return rs6000_indirect_call_template (operands, 1);\n }\n   [(set_attr \"type\" \"jmpreg\")\n    (set (attr \"length\")\n-\t(plus\n-\t  (if_then_else (match_test \"IS_NOMARK_TLSGETADDR (operands[2])\")\n-\t    (if_then_else (match_test \"TARGET_CMODEL != CMODEL_SMALL\")\n-\t      (const_int 8)\n-\t      (const_int 4))\n-\t    (const_int 0))\n-\t  (if_then_else (and (match_test \"!rs6000_speculate_indirect_jumps\")\n-\t\t\t     (match_test \"which_alternative != 1\"))\n+\t(if_then_else (and (match_test \"!rs6000_speculate_indirect_jumps\")\n+\t\t\t   (match_test \"which_alternative != 1\"))\n \t    (const_string \"8\")\n-\t    (const_string \"4\"))))])\n+\t    (const_string \"4\")))])\n \n ;; Call subroutine returning any type.\n (define_expand \"untyped_call\""}, {"sha": "9ee7c0af3ee0260d0e3fd313d112dac6ce96b475", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=ed2181fc2a3ff3a0f65110c906093d5ce0d8e048", "patch": "@@ -246,10 +246,6 @@ mavoid-indexed-addresses\n Target Report Var(TARGET_AVOID_XFORM) Init(-1) Save\n Avoid generation of indexed load/store instructions when possible.\n \n-mtls-markers\n-Target Report Var(tls_markers) Init(1) Save\n-Mark __tls_get_addr calls with argument info.\n-\n msched-epilog\n Target Undocumented Var(TARGET_SCHED_PROLOG) Init(1) Save\n "}, {"sha": "b60458e21929023627faf7b77c860331f27eb719", "filename": "gcc/configure", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=ed2181fc2a3ff3a0f65110c906093d5ce0d8e048", "patch": "@@ -27314,42 +27314,6 @@ if test $gcc_cv_as_powerpc_gnu_attribute = yes; then\n \n $as_echo \"#define HAVE_AS_GNU_ATTRIBUTE 1\" >>confdefs.h\n \n-fi\n-\n-\n-    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for tls marker support\" >&5\n-$as_echo_n \"checking assembler for tls marker support... \" >&6; }\n-if ${gcc_cv_as_powerpc_tls_markers+:} false; then :\n-  $as_echo_n \"(cached) \" >&6\n-else\n-  gcc_cv_as_powerpc_tls_markers=no\n-    if test $in_tree_gas = yes; then\n-    if test $gcc_cv_gas_vers -ge `expr \\( \\( 2 \\* 1000 \\) + 20 \\) \\* 1000 + 0`\n-  then gcc_cv_as_powerpc_tls_markers=yes\n-fi\n-  elif test x$gcc_cv_as != x; then\n-    $as_echo ' bl __tls_get_addr(x@tlsgd)' > conftest.s\n-    if { ac_try='$gcc_cv_as $gcc_cv_as_flags  -o conftest.o conftest.s >&5'\n-  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n-  (eval $ac_try) 2>&5\n-  ac_status=$?\n-  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n-  test $ac_status = 0; }; }\n-    then\n-\tgcc_cv_as_powerpc_tls_markers=yes\n-    else\n-      echo \"configure: failed program was\" >&5\n-      cat conftest.s >&5\n-    fi\n-    rm -f conftest.o conftest.s\n-  fi\n-fi\n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_powerpc_tls_markers\" >&5\n-$as_echo \"$gcc_cv_as_powerpc_tls_markers\" >&6; }\n-if test $gcc_cv_as_powerpc_tls_markers = yes; then\n-\n-$as_echo \"#define HAVE_AS_TLS_MARKERS 1\" >>confdefs.h\n-\n fi\n \n "}, {"sha": "b9cc2435cdfffcffe7362150a73a443f41079197", "filename": "gcc/configure.ac", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=ed2181fc2a3ff3a0f65110c906093d5ce0d8e048", "patch": "@@ -4811,12 +4811,6 @@ LCF0:\n       [AC_DEFINE(HAVE_AS_GNU_ATTRIBUTE, 1,\n \t  [Define if your assembler supports .gnu_attribute.])])\n \n-    gcc_GAS_CHECK_FEATURE([tls marker support],\n-      gcc_cv_as_powerpc_tls_markers, [2,20,0],,\n-      [ bl __tls_get_addr(x@tlsgd)],,\n-      [AC_DEFINE(HAVE_AS_TLS_MARKERS, 1,\n-\t  [Define if your assembler supports arg info for __tls_get_addr.])])\n-\n     gcc_GAS_CHECK_FEATURE([prologue entry point marker support],\n       gcc_cv_as_powerpc_entry_markers, [2,26,0],-a64 --fatal-warnings,\n       [ .reloc .,R_PPC64_ENTRY; nop],,"}, {"sha": "215a6fa38ff9712e6f64bec17da86186195cb33d", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed2181fc2a3ff3a0f65110c906093d5ce0d8e048/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=ed2181fc2a3ff3a0f65110c906093d5ce0d8e048", "patch": "@@ -4390,7 +4390,7 @@ The OpenRISC 1000 32-bit processor with delay slots.\n You can specify a default version for the @option{-mcpu=@var{cpu_type}}\n switch by using the configure option @option{--with-cpu-@var{cpu_type}}.\n \n-You will need GNU binutils 2.15 or newer.\n+You will need GNU binutils 2.20 or newer.\n \n @html\n <hr />"}]}