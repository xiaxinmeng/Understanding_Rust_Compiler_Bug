{"sha": "0f59171d711aaa9623e2ebc708324299662e55bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY1OTE3MWQ3MTFhYWE5NjIzZTJlYmM3MDgzMjQyOTk2NjJlNTViZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-06-23T00:26:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-06-23T00:26:04Z"}, "message": "tree.def (VTABLE_REF): Remove.\n\n        * tree.def (VTABLE_REF): Remove.\n        (OBJ_TYPE_REF): New.\n        (TRY_CATCH_EXPR, TRY_FINALLY_EXPR): Set type 's'.\n        * expr.c (expand_expr_real_1): Replace VTABLE_REF with OBJ_TYPE_REF.\n        * fold-const.c (non_lvalue): Likewise.\n        * gimplify.c (gimplify_expr): Likewise.\n        (gimplify_call_expr): Use is_gimple_call_addr.\n        * langhooks-def.h (LANG_HOOKS_FOLD_OBJ_TYPE_REF): New.\n        * langhooks.h (fold_obj_type_ref): New.\n        * tree-gimple.c (is_gimple_call_addr): New.\n        * tree-gimple.h (is_gimple_call_addr): Declare.\n        * tree-inline.c (inlinable_function_p): Fix merge error.\n        (estimate_num_insns_1): Replace VTABLE_REF with OBJ_TYPE_REF.\n        * tree-pretty-print.c (dump_generic_node): Likewise.\n        (print_call_name): Handle OBJ_TYPE_REF.\n        * tree-ssa-ccp.c (fold_stmt): Fold OBJ_TYPE_REF.\n        * tree-ssa-operands.c (get_expr_operands): Handle OBJ_TYPE_REF.\n        * tree.h (OBJ_TYPE_REF_EXPR): New.\n        (OBJ_TYPE_REF_OBJECT, OBJ_TYPE_REF_TOKEN): New.\n        * doc/c-tree.texi (VTABLE_REF): Remove.\n        * objc/objc-act.c (build_objc_method_call): Build an OBJ_TYPE_REF.\ncp/\n        * class.c (build_vfn_ref): Take a pointer not object.  Build\n        an OBJ_TYPE_REF.\n        (cp_fold_obj_type_ref): New.\n        * call.c (build_over_call): Update build_vfn_ref call.\n        * cp-lang.c (LANG_HOOKS_FOLD_OBJ_TYPE_REF): New.\n        * cp-tree.h (cp_fold_obj_type_ref): Declare.\ntestsuite/\n        * g++.dg/opt/devirt1.C: New.\n\nFrom-SVN: r83531", "tree": {"sha": "0be6b0f8e11f86590d8a53628df5d2776497a29c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0be6b0f8e11f86590d8a53628df5d2776497a29c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f59171d711aaa9623e2ebc708324299662e55bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f59171d711aaa9623e2ebc708324299662e55bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f59171d711aaa9623e2ebc708324299662e55bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f59171d711aaa9623e2ebc708324299662e55bd/comments", "author": null, "committer": null, "parents": [{"sha": "2f60699380c4bc929efc444b2413d830bad3e9b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f60699380c4bc929efc444b2413d830bad3e9b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f60699380c4bc929efc444b2413d830bad3e9b5"}], "stats": {"total": 305, "additions": 196, "deletions": 109}, "files": [{"sha": "d53095a9c71d8b35357555a831069e2cff84a366", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -1,3 +1,27 @@\n+2004-06-22  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree.def (VTABLE_REF): Remove.\n+\t(OBJ_TYPE_REF): New.\n+\t(TRY_CATCH_EXPR, TRY_FINALLY_EXPR): Set type 's'.\n+\t* expr.c (expand_expr_real_1): Replace VTABLE_REF with OBJ_TYPE_REF.\n+\t* fold-const.c (non_lvalue): Likewise.\n+\t* gimplify.c (gimplify_expr): Likewise.\n+\t(gimplify_call_expr): Use is_gimple_call_addr.\n+\t* langhooks-def.h (LANG_HOOKS_FOLD_OBJ_TYPE_REF): New.\n+\t* langhooks.h (fold_obj_type_ref): New.\n+\t* tree-gimple.c (is_gimple_call_addr): New.\n+\t* tree-gimple.h (is_gimple_call_addr): Declare.\n+\t* tree-inline.c (inlinable_function_p): Fix merge error.\n+\t(estimate_num_insns_1): Replace VTABLE_REF with OBJ_TYPE_REF.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t(print_call_name): Handle OBJ_TYPE_REF.\n+\t* tree-ssa-ccp.c (fold_stmt): Fold OBJ_TYPE_REF.\n+\t* tree-ssa-operands.c (get_expr_operands): Handle OBJ_TYPE_REF.\n+\t* tree.h (OBJ_TYPE_REF_EXPR): New.\n+\t(OBJ_TYPE_REF_OBJECT, OBJ_TYPE_REF_TOKEN): New.\n+\t* doc/c-tree.texi (VTABLE_REF): Remove.\n+\t* objc/objc-act.c (build_objc_method_call): Build an OBJ_TYPE_REF.\n+\n 2004-06-22  Richard Henderson  <rth@redhat.com>\n \n \tPR middle-end/16026"}, {"sha": "f67eb221408fbe69b9010f2a27334b93f5dffb2a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -1,3 +1,12 @@\n+2004-06-22  Richard Henderson  <rth@redhat.com>\n+\n+\t* class.c (build_vfn_ref): Take a pointer not object.  Build\n+\tan OBJ_TYPE_REF.\n+\t(cp_fold_obj_type_ref): New.\n+\t* call.c (build_over_call): Update build_vfn_ref call.\n+\t* cp-lang.c (LANG_HOOKS_FOLD_OBJ_TYPE_REF): New.\n+\t* cp-tree.h (cp_fold_obj_type_ref): Declare.\n+\n 2004-06-21  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/16112"}, {"sha": "2a659cce1ef052e8d3b558b32306bb563d5d1915", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -4835,7 +4835,7 @@ build_over_call (struct z_candidate *cand, int flags)\n       if (DECL_CONTEXT (fn) && TYPE_JAVA_INTERFACE (DECL_CONTEXT (fn)))\n \tfn = build_java_interface_fn_ref (fn, *p);\n       else\n-\tfn = build_vfn_ref (build_indirect_ref (*p, 0), DECL_VINDEX (fn));\n+\tfn = build_vfn_ref (*p, DECL_VINDEX (fn));\n       TREE_TYPE (fn) = t;\n     }\n   else if (DECL_INLINE (fn))"}, {"sha": "d58577f496f8c59bec2706d4e046dbcb2b2d89bd", "filename": "gcc/cp/class.c", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -542,20 +542,25 @@ build_vtbl_ref (tree instance, tree idx)\n   return aref;\n }\n \n-/* Given an object INSTANCE, return an expression which yields a\n-   function pointer corresponding to vtable element INDEX.  */\n+/* Given a stable object pointer INSTANCE_PTR, return an expression which\n+   yields a function pointer corresponding to vtable element INDEX.  */\n \n tree\n-build_vfn_ref (tree instance, tree idx)\n+build_vfn_ref (tree instance_ptr, tree idx)\n {\n-  tree aref = build_vtbl_ref_1 (instance, idx);\n+  tree aref;\n+\n+  aref = build_vtbl_ref_1 (build_indirect_ref (instance_ptr, 0), idx);\n \n   /* When using function descriptors, the address of the\n      vtable entry is treated as a function pointer.  */\n   if (TARGET_VTABLE_USES_DESCRIPTORS)\n     aref = build1 (NOP_EXPR, TREE_TYPE (aref),\n \t\t   build_unary_op (ADDR_EXPR, aref, /*noconvert=*/1));\n \n+  /* Remember this as a method reference, for later devirtualization.  */\n+  aref = build (OBJ_TYPE_REF, TREE_TYPE (aref), aref, instance_ptr, idx);\n+\n   return aref;\n }\n \n@@ -7912,3 +7917,31 @@ build_rtti_vtbl_entries (tree binfo, vtbl_init_data* vid)\n   *vid->last_init = build_tree_list (NULL_TREE, init);\n   vid->last_init = &TREE_CHAIN (*vid->last_init);\n }\n+\n+/* Fold a OBJ_TYPE_REF expression to the address of a function.\n+   KNOWN_TYPE carries the true type of OBJ_TYPE_REF_OBJECT(REF).  */\n+\n+tree\n+cp_fold_obj_type_ref (tree ref, tree known_type)\n+{\n+  HOST_WIDE_INT index = tree_low_cst (OBJ_TYPE_REF_TOKEN (ref), 1);\n+  HOST_WIDE_INT i = 0;\n+  tree v = TYPE_BINFO_VIRTUALS (known_type); \n+  tree fndecl;\n+\n+  while (i != index)\n+    {\n+      i += (TARGET_VTABLE_USES_DESCRIPTORS\n+\t    ? TARGET_VTABLE_USES_DESCRIPTORS : 1);\n+      v = TREE_CHAIN (v);\n+    }\n+\n+  fndecl = BV_FN (v);\n+\n+#ifdef ENABLE_CHECKING\n+  if (!tree_int_cst_equal (OBJ_TYPE_REF_TOKEN (ref), DECL_VINDEX (fndecl)))\n+    abort ();\n+#endif\n+\n+  return build_address (fndecl);\n+}"}, {"sha": "5af5b97333d80b6ab06aacf52cca7e111370580a", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -182,6 +182,8 @@ static void cxx_initialize_diagnostics (diagnostic_context *);\n #define LANG_HOOKS_REGISTER_BUILTIN_TYPE c_register_builtin_type\n #undef LANG_HOOKS_GIMPLIFY_EXPR\n #define LANG_HOOKS_GIMPLIFY_EXPR cp_gimplify_expr\n+#undef LANG_HOOKS_FOLD_OBJ_TYPE_REF\n+#define LANG_HOOKS_FOLD_OBJ_TYPE_REF cp_fold_obj_type_ref\n \n /* Each front end provides its own hooks, for toplev.c.  */\n const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;"}, {"sha": "36d98c60195bdcdc47eb49198137e48b20b21e4d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -3678,6 +3678,7 @@ extern tree get_vtt_name                        (tree);\n extern tree get_primary_binfo                   (tree);\n extern void debug_class\t\t\t\t(tree);\n extern void debug_thunks \t\t\t(tree);\n+extern tree cp_fold_obj_type_ref\t\t(tree, tree);\n \n /* in cvt.c */\n extern tree convert_to_reference (tree, tree, int, int, tree);"}, {"sha": "92e87aa4157488eea005a7c0322dfe74942c5890", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -1742,7 +1742,6 @@ This macro returns the attributes on the type @var{type}.\n @tindex SAVE_EXPR\n @tindex TARGET_EXPR\n @tindex AGGR_INIT_EXPR\n-@tindex VTABLE_REF\n @tindex VA_ARG_EXPR\n \n The internal representation for expressions is for the most part quite\n@@ -2345,17 +2344,6 @@ list.\n \n In either case, the expression is void.\n \n-@item VTABLE_REF\n-A @code{VTABLE_REF} indicates that the interior expression computes\n-a value that is a vtable entry.  It is used with @option{-fvtable-gc}\n-to track the reference through to front end to the middle end, at\n-which point we transform this to a @code{REG_VTABLE_REF} note, which\n-survives the balance of code generation.\n-\n-The first operand is the expression that computes the vtable reference.\n-The second operand is the @code{VAR_DECL} of the vtable.  The third\n-operand is an @code{INTEGER_CST} of the byte offset into the vtable.\n-\n @item VA_ARG_EXPR\n This node is used to implement support for the C/C++ variable argument-list\n mechanism.  It represents expressions like @code{va_arg (ap, type)}."}, {"sha": "259eac1c989a02007fa963f7556f7279e7d85dd1", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 36, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -7495,42 +7495,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \treturn target;\n       }\n \n-    case VTABLE_REF:\n-      {\n-\trtx insn, before = get_last_insn (), vtbl_ref;\n-\n-\t/* Evaluate the interior expression.  */\n-\tsubtarget = expand_expr (TREE_OPERAND (exp, 0), target,\n-\t\t\t\t tmode, modifier);\n-\n-\t/* Get or create an instruction off which to hang a note.  */\n-\tif (REG_P (subtarget))\n-\t  {\n-\t    target = subtarget;\n-\t    insn = get_last_insn ();\n-\t    if (insn == before)\n-\t      abort ();\n-\t    if (! INSN_P (insn))\n-\t      insn = prev_nonnote_insn (insn);\n-\t  }\n-\telse\n-\t  {\n-\t    target = gen_reg_rtx (GET_MODE (subtarget));\n-\t    insn = emit_move_insn (target, subtarget);\n-\t  }\n-\n-\t/* Collect the data for the note.  */\n-\tvtbl_ref = XEXP (DECL_RTL (TREE_OPERAND (exp, 1)), 0);\n-\tvtbl_ref = plus_constant (vtbl_ref,\n-\t\t\t\t  tree_low_cst (TREE_OPERAND (exp, 2), 0));\n-\t/* Discard the initial CONST that was added.  */\n-\tvtbl_ref = XEXP (vtbl_ref, 0);\n-\n-\tREG_NOTES (insn)\n-\t  = gen_rtx_EXPR_LIST (REG_VTABLE_REF, vtbl_ref, REG_NOTES (insn));\n-\n-\treturn target;\n-      }\n+    case OBJ_TYPE_REF:\n+      return expand_expr (OBJ_TYPE_REF_EXPR (exp), target, tmode, modifier);\n \n       /* Intended for a reference to a buffer of a file-object in Pascal.\n \t But it's not certain that a special tree code will really be"}, {"sha": "8a09795c624ea856238e5ead0a7e63d821924657", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -2022,7 +2022,7 @@ non_lvalue (tree x)\n   case ARRAY_RANGE_REF:\n   case BIT_FIELD_REF:\n   case BUFFER_REF:\n-  case VTABLE_REF:\n+  case OBJ_TYPE_REF:\n \n   case REALPART_EXPR:\n   case IMAGPART_EXPR:"}, {"sha": "f65dd4cdbcdf34c5abc2fc1b53739061696e812b", "filename": "gcc/gimplify.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -2179,7 +2179,7 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool (*gimple_test_f) (tree))\n      the calling expression must occur before the actual call.  Force\n      gimplify_expr to use an internal post queue.  */\n   ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, NULL,\n-\t\t       is_gimple_val, fb_rvalue);\n+\t\t       is_gimple_call_addr, fb_rvalue);\n \n   if (PUSH_ARGS_REVERSED)\n     TREE_OPERAND (*expr_p, 1) = nreverse (TREE_OPERAND (*expr_p, 1));\n@@ -3709,12 +3709,15 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  ret = GS_ALL_DONE;\n \t  break;\n \n-\tcase VTABLE_REF:\n-\t  /* This moves much of the actual computation out of the\n-\t     VTABLE_REF.  Perhaps this should be revisited once we want to\n-\t     do clever things with VTABLE_REFs.  */\n-\t  ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,\n-\t\t\t       is_gimple_min_lval, fb_lvalue);\n+\tcase OBJ_TYPE_REF:\n+\t  {\n+\t    enum gimplify_status r0, r1;\n+\t    r0 = gimplify_expr (&OBJ_TYPE_REF_OBJECT (*expr_p), pre_p, post_p,\n+\t\t\t        is_gimple_val, fb_rvalue);\n+\t    r1 = gimplify_expr (&OBJ_TYPE_REF_EXPR (*expr_p), pre_p, post_p,\n+\t\t\t        is_gimple_val, fb_rvalue);\n+\t    ret = MIN (r0, r1);\n+\t  }\n \t  break;\n \n \tcase MIN_EXPR:"}, {"sha": "60642990794123ab40fbe83dd1ff719f343cc260", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -200,6 +200,7 @@ extern int lhd_gimplify_expr (tree *, tree *, tree *);\n \n /* Hooks for tree gimplification.  */\n #define LANG_HOOKS_GIMPLIFY_EXPR lhd_gimplify_expr\n+#define LANG_HOOKS_FOLD_OBJ_TYPE_REF NULL\n #define LANG_HOOKS_GIMPLE_BEFORE_INLINING true\n \n /* Tree dump hooks.  */\n@@ -315,6 +316,7 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_DECLS, \\\n   LANG_HOOKS_FOR_TYPES_INITIALIZER, \\\n   LANG_HOOKS_GIMPLIFY_EXPR, \\\n+  LANG_HOOKS_FOLD_OBJ_TYPE_REF, \\\n   LANG_HOOKS_GIMPLE_BEFORE_INLINING \\\n }\n "}, {"sha": "a8c0ccac2a79649965400fb13a6c8387cce03f4a", "filename": "gcc/langhooks.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -419,6 +419,10 @@ struct lang_hooks\n      enum gimplify_status, though we can't see that type here.  */\n   int (*gimplify_expr) (tree *, tree *, tree *);\n \n+  /* Fold an OBJ_TYPE_REF expression to the address of a function.\n+     KNOWN_TYPE carries the true type of the OBJ_TYPE_REF_OBJECT.  */\n+  tree (*fold_obj_type_ref) (tree, tree);\n+\n   /* True if the front end has gimplified the function before running the\n      inliner, false if the front end generates GENERIC directly.  */\n   bool gimple_before_inlining;"}, {"sha": "9664273529db715eb88764a979d5aa77b77992d9", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -5866,6 +5866,7 @@ build_objc_method_call (int super_flag, tree method_prototype,\n        (ret_type,\n \tget_arg_type_list\n \t(method_prototype, METHOD_REF, super_flag)));\n+  tree method, t;\n \n   lookup_object = build_c_cast (rcv_p, lookup_object);\n \n@@ -5886,38 +5887,33 @@ build_objc_method_call (int super_flag, tree method_prototype,\n       method_params = tree_cons (NULL_TREE, lookup_object,\n \t\t\t\t tree_cons (NULL_TREE, selector,\n \t\t\t\t\t    method_params));\n-      TREE_USED (sender) = 1;\n-      assemble_external (sender);\n-      /* We want to cast the sender, not convert it.  */\n-      return build_function_call (build_c_cast (sender_cast, sender),\n-\t\t\t\t  method_params);\n+      method = build_fold_addr_expr (sender);\n     }\n   else\n     {\n       /* This is the portable (GNU) way.  */\n-      tree method, object;\n+      tree object;\n \n       /* First, call the lookup function to get a pointer to the method,\n \t then cast the pointer, then call it with the method arguments.\n \t Use SAVE_EXPR to avoid evaluating the receiver twice.  */\n       lookup_object = save_expr (lookup_object);\n       object = (super_flag ? self_decl : lookup_object);\n-      TREE_USED (sender) = 1;\n-      assemble_external (sender);\n-      method\n-\t= build_function_call (sender,\n-\t\t\t       tree_cons (NULL_TREE, lookup_object,\n-\t\t\t\t\t  tree_cons (NULL_TREE, selector,\n-\t\t\t\t\t\t     NULL_TREE)));\n+\n+      t = tree_cons (NULL_TREE, selector, NULL_TREE);\n+      t = tree_cons (NULL_TREE, lookup_object, t);\n+      method = build_function_call (sender, t);\n \n       /* Pass the object to the method.  */\n-      TREE_USED (method) = 1;\n-      assemble_external (method);\n-      return build_function_call\n-\t     (build_c_cast (sender_cast, method),\n-\t      tree_cons (NULL_TREE, object,\n-\t\t\t tree_cons (NULL_TREE, selector, method_params)));\n+      method_params = tree_cons (NULL_TREE, object,\n+\t\t\t\t tree_cons (NULL_TREE, selector,\n+\t\t\t\t\t    method_params));\n     }\n+\n+  /* ??? Selector is not at this point something we can use inside\n+     the compiler itself.  Set it to garbage for the nonce.  */\n+  t = build (OBJ_TYPE_REF, sender_cast, method, lookup_object, size_zero_node);\n+  return build_function_call (t, method_params);\n }\n \f\n static void\n@@ -7607,7 +7603,8 @@ comp_method_with_proto (tree method, tree proto)\n     function1_template = make_node (FUNCTION_TYPE);\n \n   /* Install argument types - normally set by build_function_type.  */\n-  TYPE_ARG_TYPES (function1_template) = get_arg_type_list (proto, METHOD_DEF, 0);\n+  TYPE_ARG_TYPES (function1_template)\n+    = get_arg_type_list (proto, METHOD_DEF, 0);\n \n   /* install return type */\n   TREE_TYPE (function1_template) = groktypename (TREE_TYPE (proto));"}, {"sha": "de2afeab752dcf93d6e843bb953337ab7fbd95ec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -1,4 +1,8 @@\n-2004-06-22 Kelley Cook <kcook@gcc.gnu.org>\n+2006-06-22  Richard Henderson  <rth@redhat.com>\n+\n+\t* g++.dg/opt/devirt1.C: New.\n+\n+2004-06-22  Kelley Cook <kcook@gcc.gnu.org>\n \n \t* g++.dg/opt/pr15551.C: New testcase.\n "}, {"sha": "617db0504348a91be5150cefb59a5e46b52439d9", "filename": "gcc/testsuite/g++.dg/opt/devirt1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdevirt1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdevirt1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdevirt1.C?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -0,0 +1,7 @@\n+// { dg-do compile }\n+// { dg-options \"-O\" }\n+// { dg-final { scan-assembler \"xyzzy\" } }\n+\n+struct S { S(); virtual void xyzzy(); };\n+inline void foo(S *s) { s->xyzzy(); }\n+void bar() { S s; foo(&s); }"}, {"sha": "2deee183964398d9f7c02c13dc1a6a4a7227c00b", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -111,7 +111,7 @@ Boston, MA 02111-1307, USA.  */\n        op0 -> lhs\n        op1 -> rhs\n    call-stmt: CALL_EXPR\n-     op0 -> ID | '&' ID\n+     op0 -> ID | '&' ID | OBJ_TYPE_REF\n      op1 -> arglist\n \n    addr-expr-arg : compref | ID\n@@ -158,6 +158,7 @@ Boston, MA 02111-1307, USA.  */\n \t      | unop val\n \t      | val binop val\n \t      | '(' cast ')' val\n+\t      | method_ref\n \n \t      (cast here stands for all valid C typecasts)\n \n@@ -240,6 +241,7 @@ is_gimple_rhs (tree t)\n     case STRING_CST:\n     case COMPLEX_CST:\n     case VECTOR_CST:\n+    case OBJ_TYPE_REF:\n       return 1;\n \n     default:\n@@ -493,6 +495,14 @@ is_gimple_cast (tree t)\n           || TREE_CODE (t) == FIX_ROUND_EXPR);\n }\n \n+/* Return true if T is a valid op0 of a CALL_EXPR.  */\n+\n+bool\n+is_gimple_call_addr (tree t)\n+{\n+  return (TREE_CODE (t) == OBJ_TYPE_REF\n+\t  || is_gimple_val (t));\n+}\n \n /* If T makes a function call, return the corresponding CALL_EXPR operand.\n    Otherwise, return NULL_TREE.  */"}, {"sha": "9e6209d7afae58497951cc088c1be6bb2805222f", "filename": "gcc/tree-gimple.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftree-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftree-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.h?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -75,6 +75,8 @@ extern bool is_gimple_constructor_elt (tree);\n /* Returns true iff T is a variable that does not need to live in memory.  */\n extern bool is_gimple_non_addressable (tree t);\n \n+/* Returns true iff T is a valid call address expression.  */\n+bool is_gimple_call_addr (tree);\n /* If T makes a function call, returns the CALL_EXPR operand.  */\n extern tree get_call_expr_in (tree t);\n "}, {"sha": "1d6e4c4dbaef1c46b12bd6ec2b07e2849d4d57b5", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -1136,12 +1136,6 @@ inlinable_function_p (tree fn)\n   else if (!DECL_INLINE (fn) && !flag_unit_at_a_time)\n     inlinable = false;\n \n-#ifdef INLINER_FOR_JAVA\n-  /* Synchronized methods can't be inlined.  This is a bug.  */\n-  else if (METHOD_SYNCHRONIZED (fn))\n-    inlinable = false;\n-#endif /* INLINER_FOR_JAVA */\n-\n   else if (inline_forbidden_p (fn))\n     {\n       /* See if we should warn about uninlinable functions.  Previously,\n@@ -1203,7 +1197,7 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case BUFFER_REF:\n     case ARRAY_REF:\n     case ARRAY_RANGE_REF:\n-    case VTABLE_REF:\n+    case OBJ_TYPE_REF:\n     case EXC_PTR_EXPR: /* ??? */\n     case FILTER_EXPR: /* ??? */\n     case COMPOUND_EXPR:"}, {"sha": "6ebf07564c7c0504b9b83e48008cb1901d41675a", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -1367,14 +1367,15 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_character (buffer, ':');\n       break;\n \n-    case VTABLE_REF:\n-      pp_string (buffer, \"VTABLE_REF <(\");\n-      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n-      pp_string (buffer, \"),\");\n-      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n-      pp_character (buffer, ',');\n-      dump_generic_node (buffer, TREE_OPERAND (node, 2), spc, flags, false);\n+    case OBJ_TYPE_REF:\n+      pp_string (buffer, \"OBJ_TYPE_REF(\");\n+      dump_generic_node (buffer, OBJ_TYPE_REF_EXPR (node), spc, flags, false);\n+      pp_character (buffer, ';');\n+      dump_generic_node (buffer, OBJ_TYPE_REF_OBJECT (node), spc, flags, false);\n+      pp_character (buffer, '-');\n       pp_character (buffer, '>');\n+      dump_generic_node (buffer, OBJ_TYPE_REF_TOKEN (node), spc, flags, false);\n+      pp_character (buffer, ')');\n       break;\n \n     case PHI_NODE:\n@@ -1880,6 +1881,7 @@ print_call_name (pretty_printer *buffer, tree node)\n       break;\n \n     case SSA_NAME:\n+    case OBJ_TYPE_REF:\n       dump_generic_node (buffer, op0, 0, 0, false);\n       break;\n "}, {"sha": "ef0c12be3783b9e55b03b733d6532e256549d50e", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -2037,13 +2037,41 @@ fold_stmt (tree *stmt_p)\n     return changed;\n   result = NULL_TREE;\n \n-  /* Check for builtins that CCP can handle using information not\n-     available in the generic fold routines.  */\n   if (TREE_CODE (rhs) == CALL_EXPR)\n     {\n-      tree callee = get_callee_fndecl (rhs);\n+      tree callee;\n+\n+      /* Check for builtins that CCP can handle using information not\n+\t available in the generic fold routines.  */\n+      callee = get_callee_fndecl (rhs);\n       if (callee && DECL_BUILT_IN (callee))\n \tresult = ccp_fold_builtin (stmt, rhs);\n+      else\n+\t{\n+\t  /* Check for resolvable OBJ_TYPE_REF.  The only sorts we can resolve\n+\t     here are when we've propagated the address of a decl into the\n+\t     object slot.  */\n+\t  /* ??? Should perhaps do this in fold proper.  However, doing it\n+\t     there requires that we create a new CALL_EXPR, and that requires\n+\t     copying EH region info to the new node.  Easier to just do it\n+\t     here where we can just smash the call operand.  */\n+\t  callee = TREE_OPERAND (rhs, 0);\n+\t  if (TREE_CODE (callee) == OBJ_TYPE_REF\n+\t      && lang_hooks.fold_obj_type_ref\n+\t      && TREE_CODE (OBJ_TYPE_REF_OBJECT (callee)) == ADDR_EXPR\n+\t      && DECL_P (TREE_OPERAND (OBJ_TYPE_REF_OBJECT (callee), 0)))\n+\t    {\n+\t      tree t;\n+\n+\t      t = TREE_TYPE (TREE_OPERAND (OBJ_TYPE_REF_OBJECT (callee), 0));\n+\t      t = lang_hooks.fold_obj_type_ref (callee, t);\n+\t      if (t)\n+\t\t{\n+\t\t  TREE_OPERAND (rhs, 0) = t;\n+\t\t  changed = true;\n+\t\t}\n+\t    }\n+\t}\n     }\n \n   /* If we couldn't fold the RHS, hand over to the generic fold routines.  */"}, {"sha": "68da398c9ef7588f8166536ccebbaa21957f519c", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -1169,7 +1169,8 @@ get_expr_operands (tree stmt, tree *expr_p, int flags, voperands_t prev_vops)\n       || code == TRUTH_AND_EXPR\n       || code == TRUTH_OR_EXPR\n       || code == TRUTH_XOR_EXPR\n-      || code == COMPOUND_EXPR)\n+      || code == COMPOUND_EXPR\n+      || code == OBJ_TYPE_REF)\n     {\n       tree op0 = TREE_OPERAND (expr, 0);\n       tree op1 = TREE_OPERAND (expr, 1);"}, {"sha": "57596a2b45827add95517ff7a3d8877a36d9481c", "filename": "gcc/tree.def", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -387,12 +387,17 @@ DEFTREECODE (ARRAY_REF, \"array_ref\", 'r', 4)\n    of the range is taken from the type of the expression.  */\n DEFTREECODE (ARRAY_RANGE_REF, \"array_range_ref\", 'r', 4)\n \n-/* Vtable indexing.  Carries data useful for emitting information\n-   for vtable garbage collection.\n-   Operand 0: an array_ref (or equivalent expression)\n-   Operand 1: the vtable base (must be a var_decl)\n-   Operand 2: index into vtable (must be an integer_cst).  */\n-DEFTREECODE (VTABLE_REF, \"vtable_ref\", 'r', 3)\n+/* Used to represent lookup of runtime type dependent data.  Often this is\n+   a reference to a vtable, but it needn't be.  Operands are:\n+   OBJ_TYPE_REF_EXPR: An expression that evaluates the value to use.\n+   OBJ_TYPE_REF_OBJECT: Is the object on whose behalf the lookup is\n+   being performed.  Through this the optimizers may be able to statically\n+   determine the dynamic type of the object.\n+   OBJ_TYPE_REF_TOKEN: Something front-end specific used to resolve the\n+   reference to something simpler, usually to the address of a DECL.\n+   Never touched by the middle-end.  Good choices would be either an\n+   identifier or a vtable index.  */\n+DEFTREECODE (OBJ_TYPE_REF, \"obj_type_ref\", 'e', 3)\n \n /* The exception object from the runtime.  */\n DEFTREECODE (EXC_PTR_EXPR, \"exc_ptr_expr\", 'e', 0)\n@@ -790,12 +795,12 @@ DEFTREECODE (VA_ARG_EXPR, \"va_arg_expr\", 'e', 1)\n \n    This differs from TRY_FINALLY_EXPR in that operand 2 is not evaluated\n    on a normal or jump exit, only on an exception.  */\n-DEFTREECODE (TRY_CATCH_EXPR, \"try_catch_expr\", 'e', 2)\n+DEFTREECODE (TRY_CATCH_EXPR, \"try_catch_expr\", 's', 2)\n \n /* Evaluate the first operand.\n    The second operand is a cleanup expression which is evaluated\n    on any exit (normal, exception, or jump out) from this expression.  */\n-DEFTREECODE (TRY_FINALLY_EXPR, \"try_finally\", 'e', 2)\n+DEFTREECODE (TRY_FINALLY_EXPR, \"try_finally\", 's', 2)\n \f\n /* These types of expressions have no useful value,\n    and always have side effects.  */"}, {"sha": "c404b84d1bcd7be588703ebeabc3eec8e606cd9d", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f59171d711aaa9623e2ebc708324299662e55bd/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0f59171d711aaa9623e2ebc708324299662e55bd", "patch": "@@ -1114,6 +1114,11 @@ struct tree_vec GTY(())\n #define EH_FILTER_FAILURE(NODE)\tTREE_OPERAND (EH_FILTER_EXPR_CHECK (NODE), 1)\n #define EH_FILTER_MUST_NOT_THROW(NODE) TREE_STATIC (EH_FILTER_EXPR_CHECK (NODE))\n \n+/* OBJ_TYPE_REF accessors.  */\n+#define OBJ_TYPE_REF_EXPR(NODE)\t  TREE_OPERAND (OBJ_TYPE_REF_CHECK (NODE), 0)\n+#define OBJ_TYPE_REF_OBJECT(NODE) TREE_OPERAND (OBJ_TYPE_REF_CHECK (NODE), 1)\n+#define OBJ_TYPE_REF_TOKEN(NODE)  TREE_OPERAND (OBJ_TYPE_REF_CHECK (NODE), 2)\n+\n struct tree_exp GTY(())\n {\n   struct tree_common common;"}]}