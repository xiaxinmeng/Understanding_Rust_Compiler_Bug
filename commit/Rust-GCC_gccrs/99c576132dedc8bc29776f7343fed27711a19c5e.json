{"sha": "99c576132dedc8bc29776f7343fed27711a19c5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTljNTc2MTMyZGVkYzhiYzI5Nzc2ZjczNDNmZWQyNzcxMWExOWM1ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-10-18T23:54:10Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-10-18T23:54:10Z"}, "message": "real.c (cmp_significand_0, [...]): New.\n\n        * real.c (cmp_significand_0, rtd_divmod, ten_to_mptwo): New.\n        (real_to_decimal): Re-implement using the logic from the\n        gcc 3.2 etoasc.  Comment heavily.\n        (div_significands): Simplify loop startup and comparison logic.\n\nFrom-SVN: r58295", "tree": {"sha": "0b12113fe6acc8d2ddcc20108fb09b1c19c65bc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b12113fe6acc8d2ddcc20108fb09b1c19c65bc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99c576132dedc8bc29776f7343fed27711a19c5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99c576132dedc8bc29776f7343fed27711a19c5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99c576132dedc8bc29776f7343fed27711a19c5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99c576132dedc8bc29776f7343fed27711a19c5e/comments", "author": null, "committer": null, "parents": [{"sha": "80bbd03da1268e32cb559ec81f1ac361da82bd41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80bbd03da1268e32cb559ec81f1ac361da82bd41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80bbd03da1268e32cb559ec81f1ac361da82bd41"}], "stats": {"total": 352, "additions": 277, "deletions": 75}, "files": [{"sha": "018a40429be57fb16d1e6006d51dc9d8440e9477", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c576132dedc8bc29776f7343fed27711a19c5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c576132dedc8bc29776f7343fed27711a19c5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99c576132dedc8bc29776f7343fed27711a19c5e", "patch": "@@ -1,3 +1,10 @@\n+2002-10-18  Richard Henderson  <rth@redhat.com>\n+\n+\t* real.c (cmp_significand_0, rtd_divmod, ten_to_mptwo): New.\n+\t(real_to_decimal): Re-implement using the logic from the\n+\tgcc 3.2 etoasc.  Comment heavily.\n+\t(div_significands): Simplify loop startup and comparison logic.\n+\n 2002-10-18  Mark Mitchell  <mark@codesourcery.com>\n \n \t* target-def.h (TARGET_ASM_OUTPUT_MI_THUNK): Default to NULL."}, {"sha": "e9fa3424b322b3fac9e11b7d804e89ccc4d7cd72", "filename": "gcc/real.c", "status": "modified", "additions": 270, "deletions": 75, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c576132dedc8bc29776f7343fed27711a19c5e/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c576132dedc8bc29776f7343fed27711a19c5e/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=99c576132dedc8bc29776f7343fed27711a19c5e", "patch": "@@ -102,6 +102,7 @@ static void neg_significand PARAMS ((REAL_VALUE_TYPE *,\n \t\t\t\t     const REAL_VALUE_TYPE *));\n static int cmp_significands PARAMS ((const REAL_VALUE_TYPE *,\n \t\t\t\t     const REAL_VALUE_TYPE *));\n+static int cmp_significand_0 PARAMS ((const REAL_VALUE_TYPE *));\n static void set_significand_bit PARAMS ((REAL_VALUE_TYPE *, unsigned int));\n static void clear_significand_bit PARAMS ((REAL_VALUE_TYPE *, unsigned int));\n static bool test_significand_bit PARAMS ((REAL_VALUE_TYPE *, unsigned int));\n@@ -121,10 +122,13 @@ static void do_divide PARAMS ((REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *,\n \t\t\t       const REAL_VALUE_TYPE *));\n static int do_compare PARAMS ((const REAL_VALUE_TYPE *,\n \t\t\t       const REAL_VALUE_TYPE *, int));\n-static void do_fix_trunc PARAMS ((REAL_VALUE_TYPE *,\n-\t\t\t\t  const REAL_VALUE_TYPE *));\n+static void do_fix_trunc PARAMS ((REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *));\n+\n+static unsigned long rtd_divmod PARAMS ((REAL_VALUE_TYPE *,\n+\t\t\t\t\t REAL_VALUE_TYPE *));\n \n static const REAL_VALUE_TYPE * ten_to_ptwo PARAMS ((int));\n+static const REAL_VALUE_TYPE * ten_to_mptwo PARAMS ((int));\n static const REAL_VALUE_TYPE * real_digit PARAMS ((int));\n static void times_pten PARAMS ((REAL_VALUE_TYPE *, int));\n \n@@ -311,11 +315,11 @@ add_significands (r, a, b)\n \n       if (carry)\n \t{\n-          carry = ri < ai;\n+\t  carry = ri < ai;\n \t  carry |= ++ri == 0;\n \t}\n       else\n-        carry = ri < ai;\n+\tcarry = ri < ai;\n \n       r->sig[i] = ri;\n     }\n@@ -341,11 +345,11 @@ sub_significands (r, a, b)\n \n       if (carry)\n \t{\n-          carry = ri > ai;\n+\t  carry = ri > ai;\n \t  carry |= ~--ri == 0;\n \t}\n       else\n-        carry = ri > ai;\n+\tcarry = ri > ai;\n \n       r->sig[i] = ri;\n     }\n@@ -406,6 +410,21 @@ cmp_significands (a, b)\n   return 0;\n }\n \n+/* Return true if A is non-zero.  */\n+\n+static inline int \n+cmp_significand_0 (a)\n+     const REAL_VALUE_TYPE *a;\n+{\n+  int i;\n+\n+  for (i = SIGSZ - 1; i >= 0; --i)\n+    if (a->sig[i])\n+      return 1;\n+\n+  return 0;\n+}\n+\n /* Set bit N of the significand of R.  */\n \n static inline void\n@@ -466,31 +485,21 @@ div_significands (r, a, b)\n      const REAL_VALUE_TYPE *a, *b;\n {\n   REAL_VALUE_TYPE u;\n-  int bit = SIGNIFICAND_BITS - 1;\n-  int i;\n-  long inexact;\n+  int i, bit = SIGNIFICAND_BITS - 1;\n+  unsigned long msb, inexact;\n \n   u = *a;\n   memset (r->sig, 0, sizeof (r->sig));\n \n+  msb = 0;\n   goto start;\n   do\n     {\n-      if ((u.sig[SIGSZ-1] & SIG_MSB) == 0)\n+      msb = u.sig[SIGSZ-1] & SIG_MSB;\n+      lshift_significand_1 (&u, &u);\n+    start:\n+      if (msb || cmp_significands (&u, b) >= 0)\n \t{\n-\t  lshift_significand_1 (&u, &u);\n-\tstart:\n-\t  if (cmp_significands (&u, b) >= 0)\n-\t    {\n-\t      sub_significands (&u, &u, b);\n-\t      set_significand_bit (r, bit);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* We lose a bit here, and thus know the next quotient bit\n-\t     will be one.  */\n-\t  lshift_significand_1 (&u, &u);\n \t  sub_significands (&u, &u, b);\n \t  set_significand_bit (r, bit);\n \t}\n@@ -757,7 +766,7 @@ do_multiply (r, a, b)\n \t\t A  B  C  D\n \t      *  E  F  G  H\n \t     --------------\n-                DE DF DG DH\n+\t        DE DF DG DH\n \t     CE CF CG CH\n \t  BE BF BG BH\n        AE AF AG AH\n@@ -972,7 +981,7 @@ do_fix_trunc (r, a)\n {\n   *r = *a;\n \n-  switch (a->class)\n+  switch (r->class)\n     {\n     case rvc_zero:\n     case rvc_inf:\n@@ -1396,6 +1405,43 @@ real_to_integer2 (plow, phigh, r)\n   *phigh = high;\n }\n \n+/* A subroutine of real_to_decimal.  Compute the quotient and remainder\n+   of NUM / DEN.  Return the quotient and place the remainder in NUM.\n+   It is expected that NUM / DEN are close enough that the quotient is\n+   small.  */\n+\n+static unsigned long\n+rtd_divmod (num, den)\n+     REAL_VALUE_TYPE *num, *den;\n+{\n+  unsigned long q, msb;\n+  int expn = num->exp, expd = den->exp;\n+\n+  if (expn < expd)\n+    return 0;\n+\n+  q = msb = 0;\n+  goto start;\n+  do\n+    {\n+      msb = num->sig[SIGSZ-1] & SIG_MSB;\n+      q <<= 1;\n+      lshift_significand_1 (num, num);\n+    start:\n+      if (msb || cmp_significands (num, den) >= 0)\n+\t{\n+\t  sub_significands (num, num, den);\n+\t  q |= 1;\n+\t}\n+    }\n+  while (--expn >= expd);\n+\n+  num->exp = expd;\n+  normalize (num);\n+\n+  return q;\n+}\n+\n /* Render R as a decimal floating point constant.  Emit DIGITS significant\n    digits in the result, bounded by BUF_SIZE.  If DIGITS is 0, choose the\n    maximum for the representation.  If CROP_TRAILING_ZEROS, strip trailing\n@@ -1410,12 +1456,11 @@ real_to_decimal (str, r_orig, buf_size, digits, crop_trailing_zeros)\n      size_t buf_size, digits;\n      int crop_trailing_zeros;\n {\n-  REAL_VALUE_TYPE r;\n   const REAL_VALUE_TYPE *one, *ten;\n-  int dec_exp, d, cmp_half;\n+  REAL_VALUE_TYPE r, pten, u, v;\n+  int dec_exp, cmp_one, digit;\n   size_t max_digits;\n   char *p, *first, *last;\n-  char exp_buf[16];\n   bool sign;\n \n   r = *r_orig;\n@@ -1437,97 +1482,230 @@ real_to_decimal (str, r_orig, buf_size, digits, crop_trailing_zeros)\n       abort ();\n     }\n \n+  /* Estimate the decimal exponent, and compute the length of the string it\n+     will print as.  Be conservative and add one to account for possible\n+     overflow or rounding error.  */\n+  dec_exp = r.exp * M_LOG10_2;\n+  for (max_digits = 1; dec_exp ; max_digits++)\n+    dec_exp /= 10;\n+\n+  /* Bound the number of digits printed by the size of the output buffer.  */\n+  max_digits = buf_size - 1 - 1 - 2 - max_digits - 1;\n+  if (max_digits > buf_size)\n+    abort ();\n+  if (digits > max_digits)\n+    digits = max_digits;\n+\n+  /* Bound the number of digits printed by the size of the representation.  */\n+  max_digits = SIGNIFICAND_BITS * M_LOG10_2;\n+  if (digits == 0 || digits > max_digits)\n+    digits = max_digits;\n+\n   one = real_digit (1);\n   ten = ten_to_ptwo (0);\n \n   sign = r.sign;\n   r.sign = 0;\n \n-  /* Estimate the decimal exponent.  */\n-  dec_exp = r.exp * M_LOG10_2;\n-  \n-  /* Scale the number such that it is in [1, 10).  */\n-  times_pten (&r, (dec_exp > 0 ? -dec_exp : -(--dec_exp)));\n+  dec_exp = 0;\n+  pten = *one;\n \n-  /* Assert that the number is in the proper range.  Round-off can\n-     prevent the above from working exactly.  */\n-  if (do_compare (&r, one, -1) < 0)\n+  cmp_one = do_compare (&r, one, 0);\n+  if (cmp_one > 0)\n     {\n-      do_multiply (&r, &r, ten);\n-      dec_exp--;\n+      int m;\n+\n+      /* Number is greater than one.  Convert significand to an integer\n+\t and strip trailing decimal zeros.  */\n+\n+      u = r;\n+      u.exp = SIGNIFICAND_BITS - 1;\n+\n+      /* Largest M, such that 10**2**M fits within SIGNIFICAND_BITS.  */\n+      m = floor_log2 (max_digits);\n+\n+      /* Iterate over the bits of the possible powers of 10 that might\n+\t be present in U and eliminate them.  That is, if we find that\n+\t 10**2**M divides U evenly, keep the division and increase \n+\t DEC_EXP by 2**M.  */\n+      do\n+\t{\n+\t  REAL_VALUE_TYPE t;\n+\n+\t  do_divide (&t, &u, ten_to_ptwo (m));\n+\t  do_fix_trunc (&v, &t);\n+\t  if (cmp_significands (&v, &t) == 0)\n+\t    {\n+\t      u = t;\n+\t      dec_exp += 1 << m;\n+\t    }\n+\t}\n+      while (--m >= 0);\n+\n+      /* Revert the scaling to integer that we performed earlier.  */\n+      u.exp += r.exp - (SIGNIFICAND_BITS - 1);\n+      r = u;\n+\n+      /* Find power of 10.  Do this by dividing out 10**2**M when\n+\t this is larger than the current remainder.  Fill PTEN with \n+\t the power of 10 that we compute.  */\n+      m = floor_log2 ((int)(r.exp * M_LOG10_2)) + 1;\n+      do\n+\t{\n+\t  const REAL_VALUE_TYPE *ptentwo = ten_to_ptwo (m);\n+\t  if (do_compare (&u, ptentwo, 0) >= 0)\n+\t    {\n+\t      do_divide (&u, &u, ptentwo);\n+\t      do_multiply (&pten, &pten, ptentwo);\n+\t      dec_exp += 1 << m;\n+\t    }\n+\t}\n+      while (--m >= 0);\n     }\n-  else if (do_compare (&r, ten, 1) >= 0)\n+  else if (cmp_one < 0)\n     {\n-      do_divide (&r, &r, ten);\n-      dec_exp++;\n+      int m;\n+\n+      /* Number is less than one.  Pad significand with leading\n+\t decimal zeros.  */\n+\n+      v = r;\n+      while (1)\n+\t{\n+\t  /* Stop if we'd shift bits off the bottom.  */\n+\t  if (v.sig[0] & 7)\n+\t    break;\n+\n+\t  do_multiply (&u, &v, ten);\n+\n+\t  /* Stop if we're now >= 1.  */\n+\t  if (u.exp > 0)\n+\t    break;\n+\n+\t  v = u;\n+\t  dec_exp -= 1;\n+\t}\n+      r = v;\n+\n+      /* Find power of 10.  Do this by multiplying in P=10**2**M when\n+\t the current remainder is smaller than 1/P.  Fill PTEN with the\n+\t power of 10 that we compute.  */\n+      m = floor_log2 ((int)(-r.exp * M_LOG10_2)) + 1;\n+      do\n+\t{\n+\t  const REAL_VALUE_TYPE *ptentwo = ten_to_ptwo (m);\n+\t  const REAL_VALUE_TYPE *ptenmtwo = ten_to_mptwo (m);\n+\n+\t  if (do_compare (&v, ptenmtwo, 0) <= 0)\n+\t    {\n+\t      do_multiply (&v, &v, ptentwo);\n+\t      do_multiply (&pten, &pten, ptentwo);\n+\t      dec_exp -= 1 << m;\n+\t    }\n+\t}\n+      while (--m >= 0);\n+\n+      /* Invert the positive power of 10 that we've collected so far.  */\n+      do_divide (&pten, one, &pten);\n     }\n \n   p = str;\n   if (sign)\n     *p++ = '-';\n   first = p++;\n \n-  sprintf (exp_buf, \"e%+d\", dec_exp);\n+  /* At this point, PTEN should contain the nearest power of 10 smaller\n+     than R, such that this division produces the first digit.\n \n-  /* Bound the number of digits printed by the size of the representation.  */\n-  max_digits = SIGNIFICAND_BITS * M_LOG10_2;\n-  if (digits == 0 || digits > max_digits)\n-    digits = max_digits;\n+     Using a divide-step primitive that returns the complete integral\n+     remainder avoids the rounding error that would be produced if\n+     we were to use do_divide here and then simply multiply by 10 for\n+     each subsequent digit.  */\n \n-  /* Bound the number of digits printed by the size of the output buffer.  */\n-  max_digits = buf_size - strlen (exp_buf) - sign - 1;\n-  if (max_digits > buf_size)\n-    abort ();\n-  if (digits > max_digits)\n-    digits = max_digits;\n+  digit = rtd_divmod (&r, &pten);\n \n-  while (1)\n+  /* Be prepared for error in that division via underflow ... */\n+  if (digit == 0 && cmp_significand_0 (&r))\n     {\n-      d = real_to_integer ((const REAL_VALUE_TYPE *) &r);\n-      do_add (&r, &r, real_digit (d), 1);\n+      /* Multiply by 10 and try again.  */\n+      do_multiply (&r, &r, ten);\n+      digit = rtd_divmod (&r, &pten);\n+      dec_exp -= 1;\n+      if (digit == 0)\n+\tabort ();\n+    }\n \n-      *p++ = d + '0';\n-      if (--digits == 0)\n-\tbreak;\n+  /* ... or overflow.  */\n+  if (digit == 10)\n+    {\n+      *p++ = '1';\n+      if (--digits > 0)\n+\t*p++ = '0';\n+      dec_exp += 1;\n+    }\n+  else if (digit > 10)\n+    abort ();\n+  else\n+    *p++ = digit + '0';\n+\n+  /* Generate subsequent digits.  */\n+  while (--digits > 0)\n+    {\n       do_multiply (&r, &r, ten);\n+      digit = rtd_divmod (&r, &pten);\n+      *p++ = digit + '0';\n     }\n   last = p;\n \n-  /* Round the result.  Compare R vs 0.5 by doing R*2 vs 1.0.  */\n-  r.exp += 1;\n-  cmp_half = do_compare (&r, one, -1);\n-  if (cmp_half == 0)\n-    /* Round to even.  */\n-    cmp_half += d & 1;\n-  if (cmp_half > 0)\n+  /* Generate one more digit with which to do rounding.  */\n+  do_multiply (&r, &r, ten);\n+  digit = rtd_divmod (&r, &pten);\n+\n+  /* Round the result.  */\n+  if (digit == 5)\n+    {\n+      /* Round to nearest.  If R is non-zero there are additional\n+\t non-zero digits to be extracted.  */\n+      if (cmp_significand_0 (&r))\n+\tdigit++;\n+      /* Round to even.  */\n+      else if ((p[-1] - '0') & 1)\n+\tdigit++;\n+    }\n+  if (digit > 5)\n     {\n       while (p > first)\n \t{\n-\t  d = *--p;\n-\t  if (d == '9')\n+\t  digit = *--p;\n+\t  if (digit == '9')\n \t    *p = '0';\n \t  else\n \t    {\n-\t      *p = d + 1;\n+\t      *p = digit + 1;\n \t      break;\n \t    }\n \t}\n \n+      /* Carry out of the first digit.  This means we had all 9's and\n+\t now have all 0's.  \"Prepend\" a 1 by overwriting the first 0.  */\n       if (p == first)\n \t{\n \t  first[1] = '1';\n \t  dec_exp++;\n \t}\n     }\n   \n+  /* Insert the decimal point.  */\n   first[0] = first[1];\n   first[1] = '.';\n \n+  /* If requested, drop trailing zeros.  Never crop past \"1.0\".  */\n   if (crop_trailing_zeros)\n     while (last > first + 3 && last[-1] == '0')\n       last--;\n \n-  strcpy (last, exp_buf);\n+  /* Append the exponent.  */\n+  sprintf (last, \"e%+d\", dec_exp);\n }\n \n /* Render R as a hexadecimal floating point constant.  Emit DIGITS\n@@ -1774,7 +1952,7 @@ real_from_string (r, str)\n \t}\n \n       if (exp)\n-        times_pten (r, exp);\n+\ttimes_pten (r, exp);\n     }\n \n   r->sign = sign;\n@@ -1857,7 +2035,7 @@ real_from_integer (r, mode, low, high, unsigned_p)\n     real_convert (r, mode, r);\n }\n \n-/* Returns 10**2**n.  */\n+/* Returns 10**2**N.  */\n \n static const REAL_VALUE_TYPE *\n ten_to_ptwo (n)\n@@ -1890,6 +2068,23 @@ ten_to_ptwo (n)\n   return &tens[n];\n }\n \n+/* Returns 10**(-2**N).  */\n+\n+static const REAL_VALUE_TYPE *\n+ten_to_mptwo (n)\n+     int n;\n+{\n+  static REAL_VALUE_TYPE tens[EXP_BITS];\n+\n+  if (n < 0 || n >= EXP_BITS)\n+    abort ();\n+\n+  if (tens[n].class == rvc_zero)\n+    do_divide (&tens[n], real_digit (1), ten_to_ptwo (n));\n+\n+  return &tens[n];\n+}\n+\n /* Returns N.  */\n \n static const REAL_VALUE_TYPE *\n@@ -2159,10 +2354,10 @@ round_for_format (fmt, r)\n \t  if (diff > p2)\n \t    goto underflow;\n \n-          /* De-normalize the significand.  */\n-          sticky_rshift_significand (r, r, diff);\n-          r->exp += diff;\n-        }\n+\t  /* De-normalize the significand.  */\n+\t  sticky_rshift_significand (r, r, diff);\n+\t  r->exp += diff;\n+\t}\n     }\n \n   /* There are P2 true significand bits, followed by one guard bit,"}]}