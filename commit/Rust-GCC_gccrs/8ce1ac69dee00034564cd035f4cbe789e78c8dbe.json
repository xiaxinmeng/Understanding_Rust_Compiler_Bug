{"sha": "8ce1ac69dee00034564cd035f4cbe789e78c8dbe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNlMWFjNjlkZWUwMDAzNDU2NGNkMDM1ZjRjYmU3ODllNzhjOGRiZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2006-03-20T23:22:13Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2006-03-20T23:22:13Z"}, "message": "target-supports.exp (check_no_compiler_messages): New procedure.\n\n\t* lib/target-supports.exp (check_no_compiler_messages): New procedure.\n\t(check_visibility_available): Use it.\n\t(check_effective_target_default_packed): Likewise.\n\t(check_effective_target_pcc_bitfield_type_matters): Likewise.\n\t(check_effective_target_fopenmp): Likewise.\n\t(check_effective_target_freorder): Likewise.\n\t(check_effective_target_fpic): Likewise.\n\t(check_named_sections_available): Likewise.\n\t(check_effective_target_ilp32): Likewise.\n\t(check_effective_target_lp64): Likewise.\n\nFrom-SVN: r112232", "tree": {"sha": "784d9afe3d60c78d2d71688318bb8048d21e79ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/784d9afe3d60c78d2d71688318bb8048d21e79ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ce1ac69dee00034564cd035f4cbe789e78c8dbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ce1ac69dee00034564cd035f4cbe789e78c8dbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ce1ac69dee00034564cd035f4cbe789e78c8dbe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ce1ac69dee00034564cd035f4cbe789e78c8dbe/comments", "author": null, "committer": null, "parents": [{"sha": "c6d5644365d3e0ee9bf85580058df12f4dfe1540", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6d5644365d3e0ee9bf85580058df12f4dfe1540", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6d5644365d3e0ee9bf85580058df12f4dfe1540"}], "stats": {"total": 358, "additions": 76, "deletions": 282}, "files": [{"sha": "210dbfc7adda3befce7239ea1d0922eb66ed09ee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce1ac69dee00034564cd035f4cbe789e78c8dbe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce1ac69dee00034564cd035f4cbe789e78c8dbe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8ce1ac69dee00034564cd035f4cbe789e78c8dbe", "patch": "@@ -1,3 +1,16 @@\n+2006-03-20  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* lib/target-supports.exp (check_no_compiler_messages): New procedure.\n+\t(check_visibility_available): Use it.\n+\t(check_effective_target_default_packed): Likewise.\n+\t(check_effective_target_pcc_bitfield_type_matters): Likewise.\n+\t(check_effective_target_fopenmp): Likewise.\n+\t(check_effective_target_freorder): Likewise.\n+\t(check_effective_target_fpic): Likewise.\n+\t(check_named_sections_available): Likewise.\n+\t(check_effective_target_ilp32): Likewise.\n+\t(check_effective_target_lp64): Likewise.\n+\n 2006-03-20  Thomas Koenig  <Thomas.Koenig@online.de>\n \n \tPR fortran/20935"}, {"sha": "40f06982897a91cd0753ecbccaac8e4e2ec34e1b", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 63, "deletions": 282, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce1ac69dee00034564cd035f4cbe789e78c8dbe/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce1ac69dee00034564cd035f4cbe789e78c8dbe/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=8ce1ac69dee00034564cd035f4cbe789e78c8dbe", "patch": "@@ -61,6 +61,26 @@ proc current_target_name { } {\n     return $answer\n }\n \n+# Implement an effective-target check for property PROP by invoking\n+# the compiler and seeing if it prints any messages.  Assume that the\n+# property holds if the compiler doesn't print anything.  The other\n+# arguments are as for get_compiler_messages, starting with TYPE.\n+proc check_no_compiler_messages {prop args} {\n+    global et_cache\n+\n+    set target [current_target_name]\n+    if {![info exists et_cache($prop,target)]\n+\t|| $et_cache($prop,target) != $target} {\n+\tverbose \"check_effective_target $prop: compiling source for $target\" 2\n+\tset et_cache($prop,target) $target\n+\tset et_cache($prop,value) \\\n+\t    [string match \"\" [eval get_compiler_messages $prop $args]]\n+    }\n+    set value $et_cache($prop,value)\n+    verbose \"check_effective_target $prop: returning $value for $target\" 2\n+    return $value\n+}\n+\n ###############################\n # proc check_weak_available { }\n ###############################\n@@ -127,7 +147,6 @@ proc check_weak_available { } {\n # The argument is the kind of visibility, default/protected/hidden/internal.\n \n proc check_visibility_available { what_kind } {\n-    global visibility_available_saved\n     global tool\n     global target_triplet\n \n@@ -138,27 +157,10 @@ proc check_visibility_available { what_kind } {\n \n     if [string match \"\" $what_kind] { set what_kind \"hidden\" }\n \n-    if { [info exists visibility_available_saved] } {\n-\tverbose \"Saved result is <$visibility_available_saved>\" 1\n-\tif { [ lsearch -exact $visibility_available_saved $what_kind ] != -1 } {\n-\t    return 1\n-\t} elseif { [ lsearch -exact $visibility_available_saved \"!$what_kind\" ] != -1 } {\n-\t    return 0\n-\t}\n-    }\n-\n-    set lines [get_compiler_messages visibility object \"\n+    return [check_no_compiler_messages visibility_available_$what_kind object \"\n \tvoid f() __attribute__((visibility(\\\"$what_kind\\\")));\n \tvoid f() {}\n     \"]\n-    if [string match \"\" $lines] then {\n-\tset answer 1\n-\tlappend visibility_available_saved $what_kind\n-    } else {\n-\tset answer 0\n-\tlappend visibility_available_saved \"!$what_kind\"\n-    }\n-    return $answer\n }\n \n ###############################\n@@ -317,78 +319,23 @@ proc check_profiling_available { test_what } {\n # false.\n \n proc check_effective_target_default_packed { } {\n-    global et_default_packed_saved\n-    global et_default_packed_target_name\n-\n-    if { ![info exists et_default_packed_target_name] } {\n-\tset et_default_packed_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_default_packed_target_name } {\n-\tverbose \"check_effective_target_default_packed: `$et_default_packed_target_name'\" 2\n-\tset et_default_packed_target_name $current_target\n-\tif [info exists et_default_packed_saved] {\n-\t    verbose \"check_effective_target_default_packed: removing cached result\" 2\n-\t    unset et_default_packed_saved\n-\t}\n-    }\n-\n-    if [info exists et_default_packed_saved] {\n-\tverbose \"check_effective_target_default_packed: using cached result\" 2\n-    } else {\n-\tverbose \"check_effective_target_default_packed: compiling source\" 2\n-\n-\tset et_default_packed_saved \\\n-\t    [string match \"\" [get_compiler_messages default_packed assembly {\n-\t    struct x { char a; long b; } c;\n-\t    int s[sizeof (c) == sizeof (char) + sizeof (long) ? 1 : -1];\n-\t} ]]\n-\n-    }\n-    verbose \"check_effective_target_default_packed: returning $et_default_packed_saved\" 2\n-    return $et_default_packed_saved\n+    return [check_no_compiler_messages default_packed assembly {\n+\tstruct x { char a; long b; } c;\n+\tint s[sizeof (c) == sizeof (char) + sizeof (long) ? 1 : -1];\n+    }]\n }\n \n # Return 1 if target has PCC_BITFIELD_TYPE_MATTERS defined.  See\n # documentation, where the test also comes from.\n \n proc check_effective_target_pcc_bitfield_type_matters { } {\n-    global et_pcc_bitfield_type_matters_saved\n-    global et_pcc_bitfield_type_matters_target_name\n-\n-    if { ![info exists et_pcc_bitfield_type_matters_target_name] } {\n-\tset et_pcc_bitfield_type_matters_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_pcc_bitfield_type_matters_target_name } {\n-\tverbose \"check_effective_target_pcc_bitfield_type_matters: `$et_pcc_bitfield_type_matters_target_name'\" 2\n-\tset et_pcc_bitfield_type_matters_target_name $current_target\n-\tif [info exists et_pcc_bitfield_type_matters_saved] {\n-\t    verbose \"check_effective_target_pcc_bitfield_type_matters: removing cached result\" 2\n-\t    unset et_pcc_bitfield_type_matters_saved\n-\t}\n-    }\n-\n-    if [info exists et_pcc_bitfield_type_matters_saved] {\n-\tverbose \"check_effective_target_pcc_bitfield_type_matters: using cached result\" 2\n-    } else {\n-\tverbose \"check_effective_target_pcc_bitfield_type_matters: compiling source\" 2\n-\n-\t# PCC_BITFIELD_TYPE_MATTERS isn't just about unnamed or empty\n-\t# bitfields, but let's stick to the example code from the docs.\n-\tset et_pcc_bitfield_type_matters_saved \\\n-\t    [string match \"\" [get_compiler_messages pcc_bitfield_type_matters assembly {\n-\t    struct foo1 { char x; char :0; char y; };\n-\t    struct foo2 { char x; int :0; char y; };\n-\t    int s[sizeof (struct foo1) != sizeof (struct foo2) ? 1 : -1];\n-\t} ]]\n-    }\n-    verbose \"check_effective_target_pcc_bitfield_type_matters: returning $et_pcc_bitfield_type_matters_saved\" 2\n-    return $et_pcc_bitfield_type_matters_saved\n+    # PCC_BITFIELD_TYPE_MATTERS isn't just about unnamed or empty\n+    # bitfields, but let's stick to the example code from the docs.\n+    return [check_no_compiler_messages pcc_bitfield_type_matters assembly {\n+\tstruct foo1 { char x; char :0; char y; };\n+\tstruct foo2 { char x; int :0; char y; };\n+\tint s[sizeof (struct foo1) != sizeof (struct foo2) ? 1 : -1];\n+    }]\n }\n \n # Return 1 if thread local storage (TLS) is supported, 0 otherwise.\n@@ -473,119 +420,37 @@ proc check_effective_target_tls_runtime {} {\n # code, 0 otherwise.\n \n proc check_effective_target_fopenmp {} {\n-    global et_fopenmp_saved\n-    global et_fopenmp_target_name\n-\n-    if { ![info exists et_fopenmp_target_name] } {\n-\tset et_fopenmp_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_fopenmp_target_name } {\n-\tverbose \"check_effective_target_fopenmp: `$et_fopenmp_target_name'\" 2\n-\tset et_fopenmp_target_name $current_target\n-\tif [info exists et_fopenmp_saved] {\n-\t    verbose \"check_effective_target_fopenmp: removing cached result\" 2\n-\t    unset et_fopenmp_saved\n-\t}\n-    }\n-\n-    if [info exists et_fopenmp_saved] {\n-\tverbose \"check_effective_target_fopenmp: using cached result\" 2\n-    } else {\n-\tverbose \"check_effective_target_fopenmp: compiling source\" 2\n-\n-\tset et_fopenmp_saved [string match \"\" [get_compiler_messages fopenmp object {\n-\t    void foo (void) { }\n-\t} \"-fopenmp\"]]\n-    }\n-    verbose \"check_effective_target_fopenmp: returning $et_fopenmp_saved\" 2\n-    return $et_fopenmp_saved\n+    return [check_no_compiler_messages fopenmp object {\n+\tvoid foo (void) { }\n+    } \"-fopenmp\"]\n }\n \n # Return 1 if compilation with -freorder-blocks-and-partition is error-free\n # for trivial code, 0 otherwise.\n \n proc check_effective_target_freorder {} {\n-    global et_freorder_saved\n-    global et_freorder_target_name\n-\n-    if { ![info exists et_freorder_target_name] } {\n-\tset et_freorder_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_freorder_target_name } {\n-\tverbose \"check_effective_target_freorder: `$et_freorder_target_name'\" 2\n-\tset et_freorder_target_name $current_target\n-\tif [info exists et_freorder_saved] {\n-\t    verbose \"check_effective_target_freorder: removing cached result\" 2\n-\t    unset et_freorder_saved\n-\t}\n-    }\n-\n-    if [info exists et_freorder_saved] {\n-\tverbose \"check_effective_target_freorder: using cached result\" 2\n-    } else {\n-\tverbose \"check_effective_target_freorder: compiling source\" 2\n-\n-\tset et_freorder_saved [string match \"\" [get_compiler_messages freorder object {\n-\t    void foo (void) { }\n-\t} \"-freorder-blocks-and-partition\"]]\n-    }\n-    verbose \"check_effective_target_freorder: returning $et_freorder_saved\" 2\n-    return $et_freorder_saved\n+    return [check_no_compiler_messages freorder object {\n+\tvoid foo (void) { }\n+    } \"-freorder-blocks-and-partition\"]\n }\n \n # Return 1 if -fpic and -fPIC are supported, as in no warnings or errors\n # emitted, 0 otherwise.  Whether a shared library can actually be built is\n # out of scope for this test.\n-#\n-# When the target name changes, replace the cached result.\n \n proc check_effective_target_fpic { } {\n-    global et_fpic_saved\n-    global et_fpic_target_name\n-\n-    if { ![info exists et_fpic_target_name] } {\n-\tset et_fpic_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_fpic_target_name } {\n-\tverbose \"check_effective_target_fpic: `$et_fpic_target_name'\" 2\n-\tset et_fpic_target_name $current_target\n-\tif [info exists et_fpic_saved] {\n-\t    verbose \"check_effective_target_fpic: removing cached result\" 2\n-\t    unset et_fpic_saved\n-\t}\n-    }\n-\n-    if [info exists et_fpic_saved] {\n-\tverbose \"check_effective_target_fpic: using cached result\" 2\n-    } else {\n-\tverbose \"check_effective_target_fpic: compiling source\" 2\n-\n-\t# Note that M68K has a multilib that supports -fpic but not\n-\t# -fPIC, so we need to check both.  We test with a program that\n-\t# requires GOT references.\n-\tset et_fpic_saved [string match \"\" [get_compiler_messages fpic object {\n+    # Note that M68K has a multilib that supports -fpic but not\n+    # -fPIC, so we need to check both.  We test with a program that\n+    # requires GOT references.\n+    foreach arg {fpic fPIC} {\n+\tif [check_no_compiler_messages $arg object {\n \t    extern int foo (void); extern int bar;\n \t    int baz (void) { return foo () + bar; }\n-\t} \"-fpic\"]]\n-\n-\tif { $et_fpic_saved != 0 } {\n-\t    set et_fpic_saved [string match \"\" [get_compiler_messages fpic object {\n-\t\textern int foo (void); extern int bar;\n-\t\tint baz (void) { return foo () + bar; }\n-\t    } \"-fPIC\"]]\n+\t} \"-$arg\"] {\n+\t    return 1\n \t}\n     }\n-    verbose \"check_effective_target_fpic: returning $et_fpic_saved\" 2\n-    return $et_fpic_saved\n+    return 0\n }\n \n # Return true if iconv is supported on the target. In particular IBM1047.\n@@ -633,16 +498,11 @@ proc check_iconv_available { test_what } {\n }\n \n # Return true if named sections are supported on this target.\n-# This proc does not cache results, because the answer may vary\n-# when cycling over subtarget options (e.g. irix o32/n32/n64) in\n-# the same test run.\n+\n proc check_named_sections_available { } {\n-    verbose \"check_named_sections_available: compiling source\" 2\n-    set answer [string match \"\" [get_compiler_messages named assembly {\n+    return [check_no_compiler_messages named_sections assembly {\n \tint __attribute__ ((section(\"whatever\"))) foo;\n-    }]]\n-    verbose \"check_named_sections_available: returning $answer\" 2\n-    return $answer\n+    }]\n }\n \n # Return 1 if the target supports Fortran real kinds larger than real(8),\n@@ -1057,74 +917,24 @@ proc check_mkfifo_available {} {\n \n # Return 1 if we're generating 32-bit code using default options, 0\n # otherwise.\n-#\n-# When the target name changes, replace the cached result.\n \n proc check_effective_target_ilp32 { } {\n-    global et_ilp32_saved\n-    global et_ilp32_target_name\n-\n-    if { ![info exists et_ilp32_target_name] } {\n-\tset et_ilp32_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_ilp32_target_name } {\n-\tverbose \"check_effective_target_ilp32: `$et_ilp32_target_name' `$current_target'\" 2\n-\tset et_ilp32_target_name $current_target\n-\tif { [info exists et_ilp32_saved] } {\n-\t    verbose \"check_effective_target_ilp32: removing cached result\" 2\n-\t    unset et_ilp32_saved\n-\t}\n-    }\n-\n-    if [info exists et_ilp32_saved] {\n-\tverbose \"check-effective_target_ilp32: using cached result\" 2\n-    } else {\n-\tverbose \"check_effective_target_ilp32: compiling source\" 2\n-\tset et_ilp32_saved [string match \"\" [get_compiler_messages ilp32 object {\n-\t    int dummy[(sizeof (int) == 4 && sizeof (void *) == 4 && sizeof (long) == 4 ) ? 1 : -1];\n-\t}]]\n-    }\n-    verbose \"check_effective_target_ilp32: returning $et_ilp32_saved\" 2\n-    return $et_ilp32_saved\n+    return [check_no_compiler_messages ilp32 object {\n+\tint dummy[sizeof (int) == 4\n+\t\t  && sizeof (void *) == 4\n+\t\t  && sizeof (long) == 4 ? 1 : -1];\n+    }]\n }\n \n # Return 1 if we're generating 64-bit code using default options, 0\n # otherwise.\n-#\n-# When the target name changes, replace the cached result.\n \n proc check_effective_target_lp64 { } {\n-    global et_lp64_saved\n-    global et_lp64_target_name\n-\n-    if { ![info exists et_lp64_target_name] } {\n-\tset et_lp64_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_lp64_target_name } {\n-\tverbose \"check_effective_target_lp64: `$et_lp64_target_name' `$current_target'\" 2\n-\tset et_lp64_target_name $current_target\n-\tif [info exists et_lp64_saved] {\n-\t    verbose \"check_effective_target_lp64: removing cached result\" 2\n-\t    unset et_lp64_saved\n-\t}\n-    }\n-\n-    if [info exists et_lp64_saved] {\n-\tverbose \"check_effective_target_lp64: using cached result\" 2\n-    } else {\n-\tverbose \"check_effective_target_lp64: compiling source\" 2\n-\tset et_lp64_saved [string match \"\" [get_compiler_messages lp64 object {\n-\t    int dummy[(sizeof (int) == 4 && sizeof (void *) == 8 && sizeof (long) == 8 ) ? 1 : -1];\n-\t}]]\n-    }\n-    verbose \"check_effective_target_lp64: returning $et_lp64_saved\" 2\n-    return $et_lp64_saved\n+    return [check_no_compiler_messages lp64 object {\n+\tint dummy[sizeof (int) == 4\n+\t\t  && sizeof (void *) == 8\n+\t\t  && sizeof (long) == 8 ? 1 : -1];\n+    }]\n }\n \n # Return 1 if the target supports compiling decimal floating point,\n@@ -1799,38 +1609,9 @@ proc is-effective-target-keyword { arg } {\n # Return 1 if target default to short enums\n \n proc check_effective_target_short_enums { } {\n-    global et_short_enums_saved\n-    global et_short_enums_target_name\n-\n-    if { ![info exists et_short_enums_target_name] } {\n-\tset et_short_enums_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_short_enums_target_name } {\n-\tverbose \"check_effective_target_short_enums: `$et_short_enums_target_name'\" 2\n-\tset et_short_enums_target_name $current_target\n-\tif [info exists et_short_enums_saved] {\n-\t    verbose \"check_effective_target_short_enums: removing cached result\" 2\n-\t    unset et_short_enums_saved\n-\t}\n-    }\n-\n-    if [info exists et_short_enums_saved] {\n-\tverbose \"check_effective_target_short_enums: using cached result\" 2\n-    } else {\n-\tverbose \"check_effective_target_short_enums: compiling source\" 2\n-\n-\t# PCC_BITFIELD_TYPE_MATTERS isn't just about unnamed or empty\n-\t# bitfields, but let's stick to the example code from the docs.\n-\tset et_short_enums_saved \\\n-\t    [string match \"\" [get_compiler_messages short_enums assembly {\n-\t    enum foo { bar };\n-\t    int s[sizeof (enum foo) == 1 ? 1 : -1];\n-\t} ]]\n-    }\n-    verbose \"check_effective_target_short_enums: returning $et_short_enums_saved\" 2\n-    return $et_short_enums_saved\n+    return [check_no_compiler_messages short_enums assembly {\n+\tenum foo { bar };\n+\tint s[sizeof (enum foo) == 1 ? 1 : -1];\n+    }]\n }\n "}]}