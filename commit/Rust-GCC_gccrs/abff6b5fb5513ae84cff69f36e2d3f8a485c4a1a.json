{"sha": "abff6b5fb5513ae84cff69f36e2d3f8a485c4a1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJmZjZiNWZiNTUxM2FlODRjZmY2OWYzNmUyZDNmOGE0ODVjNGExYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-22T23:48:08Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-12-22T23:48:08Z"}, "message": "Avoid infinite recursion looking up method in invalid recursive type.\n\nFrom-SVN: r168186", "tree": {"sha": "cf7d28a5a0d5e6088e0faf2f4c7df38823ab17e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf7d28a5a0d5e6088e0faf2f4c7df38823ab17e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abff6b5fb5513ae84cff69f36e2d3f8a485c4a1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abff6b5fb5513ae84cff69f36e2d3f8a485c4a1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abff6b5fb5513ae84cff69f36e2d3f8a485c4a1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abff6b5fb5513ae84cff69f36e2d3f8a485c4a1a/comments", "author": null, "committer": null, "parents": [{"sha": "7cfc62ba9e973c3c47d0c6e47009959115546ab0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cfc62ba9e973c3c47d0c6e47009959115546ab0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cfc62ba9e973c3c47d0c6e47009959115546ab0"}], "stats": {"total": 49, "additions": 37, "deletions": 12}, "files": [{"sha": "9bdb92612b14b23fc61501eb07018bebee9e2e50", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abff6b5fb5513ae84cff69f36e2d3f8a485c4a1a/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abff6b5fb5513ae84cff69f36e2d3f8a485c4a1a/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=abff6b5fb5513ae84cff69f36e2d3f8a485c4a1a", "patch": "@@ -7622,13 +7622,14 @@ Type::bind_field_or_method(Gogo* gogo, const Type* type, Expression* expr,\n \n   bool receiver_can_be_pointer = (expr->type()->points_to() != NULL\n \t\t\t\t  || expr->is_addressable());\n+  std::vector<const Named_type*> seen;\n   bool is_method = false;\n   bool found_pointer_method = false;\n   std::string ambig1;\n   std::string ambig2;\n-  if (Type::find_field_or_method(type, name, receiver_can_be_pointer, NULL,\n-\t\t\t\t &is_method, &found_pointer_method,\n-\t\t\t\t &ambig1, &ambig2))\n+  if (Type::find_field_or_method(type, name, receiver_can_be_pointer,\n+\t\t\t\t &seen, NULL, &is_method,\n+\t\t\t\t &found_pointer_method, &ambig1, &ambig2))\n     {\n       Expression* ret;\n       if (!is_method)\n@@ -7704,13 +7705,16 @@ Type::bind_field_or_method(Gogo* gogo, const Type* type, Expression* expr,\n // ambiguity.  If a method is found, sets *IS_METHOD to true;\n // otherwise, if a field is found, set it to false.  If\n // RECEIVER_CAN_BE_POINTER is false, then the receiver is a value\n-// whose address can not be taken.  When returning false, this sets\n-// *FOUND_POINTER_METHOD if we found a method we couldn't use because\n-// it requires a pointer.  LEVEL is used for recursive calls, and can\n-// be NULL for a non-recursive call.  When this function returns false\n-// because it finds that the name is ambiguous, it will store a path\n-// to the ambiguous names in *AMBIG1 and *AMBIG2.  If the name is not\n-// found at all, *AMBIG1 and *AMBIG2 will be unchanged.\n+// whose address can not be taken.  SEEN is used to avoid infinite\n+// recursion on invalid types.\n+\n+// When returning false, this sets *FOUND_POINTER_METHOD if we found a\n+// method we couldn't use because it requires a pointer.  LEVEL is\n+// used for recursive calls, and can be NULL for a non-recursive call.\n+// When this function returns false because it finds that the name is\n+// ambiguous, it will store a path to the ambiguous names in *AMBIG1\n+// and *AMBIG2.  If the name is not found at all, *AMBIG1 and *AMBIG2\n+// will be unchanged.\n \n // This function just returns whether or not there is a field or\n // method, and whether it is a field or method.  It doesn't build an\n@@ -7723,6 +7727,7 @@ bool\n Type::find_field_or_method(const Type* type,\n \t\t\t   const std::string& name,\n \t\t\t   bool receiver_can_be_pointer,\n+\t\t\t   std::vector<const Named_type*>* seen,\n \t\t\t   int* level,\n \t\t\t   bool* is_method,\n \t\t\t   bool* found_pointer_method,\n@@ -7749,6 +7754,17 @@ Type::find_field_or_method(const Type* type,\n \t  // else.\n \t  *found_pointer_method = true;\n \t}\n+\n+      for (std::vector<const Named_type*>::const_iterator p = seen->begin();\n+\t   p != seen->end();\n+\t   ++p)\n+\t{\n+\t  if (*p == nt)\n+\t    {\n+\t      // We've already seen this type when searching for methods.\n+\t      return false;\n+\t    }\n+\t}\n     }\n \n   // Interface types can have methods.\n@@ -7768,6 +7784,9 @@ Type::find_field_or_method(const Type* type,\n   if (fields == NULL)\n     return false;\n \n+  if (nt != NULL)\n+    seen->push_back(nt);\n+\n   int found_level = 0;\n   bool found_is_method = false;\n   std::string found_ambig1;\n@@ -7780,6 +7799,8 @@ Type::find_field_or_method(const Type* type,\n       if (pf->field_name() == name)\n \t{\n \t  *is_method = false;\n+\t  if (nt != NULL)\n+\t    seen->pop_back();\n \t  return true;\n \t}\n \n@@ -7800,6 +7821,7 @@ Type::find_field_or_method(const Type* type,\n       bool subfound = Type::find_field_or_method(fnt,\n \t\t\t\t\t\t name,\n \t\t\t\t\t\t receiver_can_be_pointer,\n+\t\t\t\t\t\t seen,\n \t\t\t\t\t\t &sublevel,\n \t\t\t\t\t\t &sub_is_method,\n \t\t\t\t\t\t found_pointer_method,\n@@ -7856,6 +7878,9 @@ Type::find_field_or_method(const Type* type,\n   // FOUND_AMBIG2 are not empty.  If we found the field, FOUND_LEVEL\n   // is not 0 and FOUND_AMBIG1 and FOUND_AMBIG2 are empty.\n \n+  if (nt != NULL)\n+    seen->pop_back();\n+\n   if (found_level == 0)\n     return false;\n   else if (!found_ambig1.empty())"}, {"sha": "45297e1822fd3cf49ccb2156aeedfb57762140c9", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abff6b5fb5513ae84cff69f36e2d3f8a485c4a1a/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abff6b5fb5513ae84cff69f36e2d3f8a485c4a1a/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=abff6b5fb5513ae84cff69f36e2d3f8a485c4a1a", "patch": "@@ -1067,8 +1067,8 @@ class Type\n   static bool\n   find_field_or_method(const Type* type, const std::string& name,\n \t\t       bool receiver_can_be_pointer,\n-\t\t       int* level, bool* is_method,\n-\t\t       bool* found_pointer_method,\n+\t\t       std::vector<const Named_type*>*, int* level,\n+\t\t       bool* is_method, bool* found_pointer_method,\n \t\t       std::string* ambig1, std::string* ambig2);\n \n   // Get a tree for a type without looking in the hash table for"}]}