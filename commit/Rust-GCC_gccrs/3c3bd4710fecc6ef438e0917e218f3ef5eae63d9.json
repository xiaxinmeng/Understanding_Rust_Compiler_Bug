{"sha": "3c3bd4710fecc6ef438e0917e218f3ef5eae63d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MzYmQ0NzEwZmVjYzZlZjQzOGUwOTE3ZTIxOGYzZWY1ZWFlNjNkOQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-09-23T10:04:33Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-09-23T10:04:33Z"}, "message": "re PR rtl-optimization/44374 (Hoist same instructions in different branches)\n\n\tPR rtl-optimization/44374\n\t* basic-block.h (enum bb_flags): Add BB_MODIFIED.\n\t* df-core.c (df_set_bb_dirty): Set it.\n\t* ifcvt.c (find_memory): Remove function.\n\t(dead_or_predicable): Use can_move_insns_across.\n\t* df.h (can_move_insns_across): Declare function.\n\t* cfgcleanup.c (block_was_dirty): New static variable.\n\t(try_crossjump_bb, try_forward_edges): Test BB_MODIFIED flag rather\n\tthan df_get_bb_dirty.\n\t(try_head_merge_bb): New static function.\n\t(try_optimize_cfg): Call it.  Call df_analyze if block_was_dirty\n\tis set.\n\t* df-problems.c: Include \"target.h\"\n\t(df_simulate_find_uses): New static function.\n\t(MEMREF_NORMAL, MEMREF_VOLATILE): New macros.\n\t(find_memory, find_memory_store): New static functions.\n\t(can_move_insns_across): New function.\n\t* Makefile.in (df-problems.o): Update dependencies.\n\ntestsuite/\n\tPR rtl-optimization/44374\n\t* gcc.target/arm/headmerge-1.c: New test.\n\t* gcc.target/arm/headmerge-2.c: New test.\n\t* gcc.target/i386/headmerge-1.c: New test.\n\t* gcc.target/i386/headmerge-2.c: New test.\n\nFrom-SVN: r164552", "tree": {"sha": "5a8f0323c12091c2776f698fa75f292d39574f04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a8f0323c12091c2776f698fa75f292d39574f04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/comments", "author": null, "committer": null, "parents": [{"sha": "87350d4af5ff329ab694092f0edf91969ef0e2c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87350d4af5ff329ab694092f0edf91969ef0e2c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87350d4af5ff329ab694092f0edf91969ef0e2c9"}], "stats": {"total": 892, "additions": 759, "deletions": 133}, "files": [{"sha": "156f09c78c7d11fc8ba1958073a14f8cfafd780d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c3bd4710fecc6ef438e0917e218f3ef5eae63d9", "patch": "@@ -1,3 +1,24 @@\n+2010-09-23  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR rtl-optimization/44374\n+\t* basic-block.h (enum bb_flags): Add BB_MODIFIED.\n+\t* df-core.c (df_set_bb_dirty): Set it.\n+\t* ifcvt.c (find_memory): Remove function.\n+\t(dead_or_predicable): Use can_move_insns_across.\n+\t* df.h (can_move_insns_across): Declare function.\n+\t* cfgcleanup.c (block_was_dirty): New static variable.\n+\t(try_crossjump_bb, try_forward_edges): Test BB_MODIFIED flag rather\n+\tthan df_get_bb_dirty.\n+\t(try_head_merge_bb): New static function.\n+\t(try_optimize_cfg): Call it.  Call df_analyze if block_was_dirty\n+\tis set.\n+\t* df-problems.c: Include \"target.h\"\n+\t(df_simulate_find_uses): New static function.\n+\t(MEMREF_NORMAL, MEMREF_VOLATILE): New macros.\n+\t(find_memory, find_memory_store): New static functions.\n+\t(can_move_insns_across): New function.\n+\t* Makefile.in (df-problems.o): Update dependencies.\n+\n 2010-09-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR java/44095"}, {"sha": "54643e3f79b6b80a7576647182f0f673d51b46cb", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=3c3bd4710fecc6ef438e0917e218f3ef5eae63d9", "patch": "@@ -3171,7 +3171,7 @@ df-core.o : df-core.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n df-problems.o : df-problems.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h \\\n    hard-reg-set.h $(BASIC_BLOCK_H) $(DF_H) $(BITMAP_H) sbitmap.h $(TIMEVAR_H) \\\n-   $(TM_P_H) $(FLAGS_H) output.h $(EXCEPT_H) dce.h vecprim.h\n+   $(TM_P_H) $(TARGET_H) $(FLAGS_H) output.h $(EXCEPT_H) dce.h vecprim.h\n df-scan.o : df-scan.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(RECOG_H) $(FUNCTION_H) $(REGS_H) alloc-pool.h \\\n    hard-reg-set.h $(BASIC_BLOCK_H) $(DF_H) $(BITMAP_H) sbitmap.h $(TIMEVAR_H) \\"}, {"sha": "e274d6c044f23f00f65c8b2ac1f276a2b61459f4", "filename": "gcc/basic-block.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=3c3bd4710fecc6ef438e0917e218f3ef5eae63d9", "patch": "@@ -246,7 +246,13 @@ enum bb_flags\n \n   /* Set on blocks that cannot be threaded through.\n      Only used in cfgcleanup.c.  */\n-  BB_NONTHREADABLE_BLOCK = 1 << 11\n+  BB_NONTHREADABLE_BLOCK = 1 << 11,\n+\n+  /* Set on blocks that were modified in some way.  This bit is set in\n+     df_set_bb_dirty, but not cleared by df_analyze, so it can be used\n+     to test whether a block has been modified prior to a df_analyze\n+     call.  */\n+  BB_MODIFIED = 1 << 12\n };\n \n /* Dummy flag for convenience in the hot/cold partitioning code.  */"}, {"sha": "6b128ebe549ec85fcdb7e7a19a943becff60ecdf", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 285, "deletions": 8, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=3c3bd4710fecc6ef438e0917e218f3ef5eae63d9", "patch": "@@ -66,6 +66,10 @@ static bool first_pass;\n /* Set to true if crossjumps occured in the latest run of try_optimize_cfg.  */\n static bool crossjumps_occured;\n \n+/* Set to true if we couldn't run an optimization due to stale liveness\n+   information; we should run df_analyze to enable more opportunities.  */\n+static bool block_was_dirty;\n+\n static bool try_crossjump_to_edge (int, edge, edge);\n static bool try_crossjump_bb (int, basic_block);\n static bool outgoing_edges_match (int, basic_block, basic_block);\n@@ -432,7 +436,7 @@ try_forward_edges (int mode, basic_block b)\n       int counter, goto_locus;\n       bool threaded = false;\n       int nthreaded_edges = 0;\n-      bool may_thread = first_pass | df_get_bb_dirty (b);\n+      bool may_thread = first_pass || (b->flags & BB_MODIFIED) != 0;\n \n       /* Skip complex edges because we don't know how to update them.\n \n@@ -467,7 +471,7 @@ try_forward_edges (int mode, basic_block b)\n \t{\n \t  basic_block new_target = NULL;\n \t  bool new_target_threaded = false;\n-\t  may_thread |= df_get_bb_dirty (target);\n+\t  may_thread |= (target->flags & BB_MODIFIED) != 0;\n \n \t  if (FORWARDER_BLOCK_P (target)\n \t      && !(single_succ_edge (target)->flags & EDGE_CROSSING)\n@@ -1857,8 +1861,8 @@ try_crossjump_bb (int mode, basic_block bb)\n \t  /* If nothing changed since the last attempt, there is nothing\n \t     we can do.  */\n \t  if (!first_pass\n-\t      && (!(df_get_bb_dirty (e->src))\n-\t\t  && !(df_get_bb_dirty (fallthru->src))))\n+\t      && !((e->src->flags & BB_MODIFIED)\n+\t\t   || (fallthru->src->flags & BB_MODIFIED)))\n \t    continue;\n \n \t  if (try_crossjump_to_edge (mode, e, fallthru))\n@@ -1907,8 +1911,8 @@ try_crossjump_bb (int mode, basic_block bb)\n \t  /* If nothing changed since the last attempt, there is nothing\n \t     we can do.  */\n \t  if (!first_pass\n-\t      && (!(df_get_bb_dirty (e->src))\n-\t\t  && !(df_get_bb_dirty (e2->src))))\n+\t      && !((e->src->flags & BB_MODIFIED)\n+\t\t   || (e2->src->flags & BB_MODIFIED)))\n \t    continue;\n \n \t  if (try_crossjump_to_edge (mode, e, e2))\n@@ -1927,6 +1931,265 @@ try_crossjump_bb (int mode, basic_block bb)\n   return changed;\n }\n \n+/* Search the successors of BB for common insn sequences.  When found,\n+   share code between them by moving it across the basic block\n+   boundary.  Return true if any changes made.  */\n+\n+static bool\n+try_head_merge_bb (basic_block bb)\n+{\n+  basic_block final_dest_bb = NULL;\n+  int max_match = INT_MAX;\n+  edge e0;\n+  rtx *headptr, *currptr;\n+  bool changed, moveall;\n+  unsigned ix;\n+  rtx e0_last_head, cond, move_before;\n+  unsigned nedges = EDGE_COUNT (bb->succs);\n+  rtx jump = BB_END (bb);\n+  regset live, live_union;\n+\n+  /* Nothing to do if there is not at least two outgoing edges.  */\n+  if (nedges < 2)\n+    return false;\n+\n+  /* Don't crossjump if this block ends in a computed jump,\n+     unless we are optimizing for size.  */\n+  if (optimize_bb_for_size_p (bb)\n+      && bb != EXIT_BLOCK_PTR\n+      && computed_jump_p (BB_END (bb)))\n+    return false;\n+\n+  cond = get_condition (jump, &move_before, true, false);\n+  if (cond == NULL_RTX)\n+    move_before = jump;\n+\n+  for (ix = 0; ix < nedges; ix++)\n+    if (EDGE_SUCC (bb, ix)->dest == EXIT_BLOCK_PTR)\n+      return false;\n+\n+  for (ix = 0; ix < nedges; ix++)\n+    {\n+      edge e = EDGE_SUCC (bb, ix);\n+      basic_block other_bb = e->dest;\n+\n+      if (df_get_bb_dirty (other_bb))\n+\t{\n+\t  block_was_dirty = true;\n+\t  return false;\n+\t}\n+\n+      if (e->flags & EDGE_ABNORMAL)\n+\treturn false;\n+\n+      /* Normally, all destination blocks must only be reachable from this\n+\t block, i.e. they must have one incoming edge.\n+\n+\t There is one special case we can handle, that of multiple consecutive\n+\t jumps where the first jumps to one of the targets of the second jump.\n+\t This happens frequently in switch statements for default labels.\n+\t The structure is as follows:\n+\t FINAL_DEST_BB\n+\t ....\n+\t if (cond) jump A;\n+\t fall through\n+\t BB\n+\t jump with targets A, B, C, D...\n+\t A\n+\t has two incoming edges, from FINAL_DEST_BB and BB\n+\n+\t In this case, we can try to move the insns through BB and into\n+\t FINAL_DEST_BB.  */\n+      if (EDGE_COUNT (other_bb->preds) != 1)\n+\t{\n+\t  edge incoming_edge, incoming_bb_other_edge;\n+\t  edge_iterator ei;\n+\n+\t  if (final_dest_bb != NULL\n+\t      || EDGE_COUNT (other_bb->preds) != 2)\n+\t    return false;\n+\n+\t  /* We must be able to move the insns across the whole block.  */\n+\t  move_before = BB_HEAD (bb);\n+\t  while (!NONDEBUG_INSN_P (move_before))\n+\t    move_before = NEXT_INSN (move_before);\n+\n+\t  if (EDGE_COUNT (bb->preds) != 1)\n+\t    return false;\n+\t  incoming_edge = EDGE_PRED (bb, 0);\n+\t  final_dest_bb = incoming_edge->src;\n+\t  if (EDGE_COUNT (final_dest_bb->succs) != 2)\n+\t    return false;\n+\t  FOR_EACH_EDGE (incoming_bb_other_edge, ei, final_dest_bb->succs)\n+\t    if (incoming_bb_other_edge != incoming_edge)\n+\t      break;\n+\t  if (incoming_bb_other_edge->dest != other_bb)\n+\t    return false;\n+\t}\n+    }\n+\n+  e0 = EDGE_SUCC (bb, 0);\n+  e0_last_head = NULL_RTX;\n+  changed = false;\n+\n+  for (ix = 1; ix < nedges; ix++)\n+    {\n+      edge e = EDGE_SUCC (bb, ix);\n+      rtx e0_last, e_last;\n+      int nmatch;\n+\n+      nmatch = flow_find_head_matching_sequence (e0->dest, e->dest,\n+\t\t\t\t\t\t &e0_last, &e_last, 0);\n+      if (nmatch == 0)\n+\treturn false;\n+\n+      if (nmatch < max_match)\n+\t{\n+\t  max_match = nmatch;\n+\t  e0_last_head = e0_last;\n+\t}\n+    }\n+\n+  /* If we matched an entire block, we probably have to avoid moving the\n+     last insn.  */\n+  if (max_match > 0\n+      && e0_last_head == BB_END (e0->dest)\n+      && (find_reg_note (e0_last_head, REG_EH_REGION, 0)\n+\t  || control_flow_insn_p (e0_last_head)))\n+    {\n+      max_match--;\n+      if (max_match == 0)\n+\treturn false;\n+      do\n+\te0_last_head = prev_real_insn (e0_last_head);\n+      while (DEBUG_INSN_P (e0_last_head));\n+    }\n+\n+  if (max_match == 0)\n+    return false;\n+\n+  /* We must find a union of the live registers at each of the end points.  */\n+  live = BITMAP_ALLOC (NULL);\n+  live_union = BITMAP_ALLOC (NULL);\n+\n+  currptr = XNEWVEC (rtx, nedges);\n+  headptr = XNEWVEC (rtx, nedges);\n+\n+  for (ix = 0; ix < nedges; ix++)\n+    {\n+      int j;\n+      basic_block merge_bb = EDGE_SUCC (bb, ix)->dest;\n+      rtx head = BB_HEAD (merge_bb);\n+\n+      while (!NONDEBUG_INSN_P (head))\n+\thead = NEXT_INSN (head);\n+      headptr[ix] = head;\n+      currptr[ix] = head;\n+\n+      /* Compute the end point and live information  */\n+      for (j = 1; j < max_match; j++)\n+\tdo\n+\t  head = NEXT_INSN (head);\n+\twhile (!NONDEBUG_INSN_P (head));\n+      simulate_backwards_to_point (merge_bb, live, head);\n+      IOR_REG_SET (live_union, live);\n+    }\n+\n+  /* If we're moving across two blocks, verify the validity of the\n+     first move, then adjust the target and let the loop below deal\n+     with the final move.  */\n+  if (final_dest_bb != NULL)\n+    {\n+      rtx move_upto;\n+\n+      moveall = can_move_insns_across (currptr[0], e0_last_head, move_before,\n+\t\t\t\t       jump, e0->dest, live_union,\n+\t\t\t\t       NULL, &move_upto);\n+      if (!moveall)\n+\te0_last_head = move_upto;\n+      if (e0_last_head == NULL_RTX)\n+\tgoto out;\n+\n+      jump = BB_END (final_dest_bb);\n+      cond = get_condition (jump, &move_before, true, false);\n+      if (cond == NULL_RTX)\n+\tmove_before = jump;\n+    }\n+\n+  do\n+    {\n+      rtx move_upto;\n+      moveall = can_move_insns_across (currptr[0], e0_last_head,\n+\t\t\t\t       move_before, jump, e0->dest, live_union,\n+\t\t\t\t       NULL, &move_upto);\n+      if (!moveall && move_upto == NULL_RTX)\n+\t{\n+\t  if (jump == move_before)\n+\t    break;\n+\n+\t  /* Try again, using a different insertion point.  */\n+\t  move_before = jump;\n+\t  continue;\n+\t}\n+\n+      if (final_dest_bb && !moveall)\n+\t/* We haven't checked whether a partial move would be OK for the first\n+\t   move, so we have to fail this case.  */\n+\tbreak;\n+\n+      changed = true;\n+      for (;;)\n+\t{\n+\t  if (currptr[0] == move_upto)\n+\t    break;\n+\t  for (ix = 0; ix < nedges; ix++)\n+\t    {\n+\t      rtx curr = currptr[ix];\n+\t      do\n+\t\tcurr = NEXT_INSN (curr);\n+\t      while (!NONDEBUG_INSN_P (curr));\n+\t      currptr[ix] = curr;\n+\t    }\n+\t}\n+\n+      reorder_insns (headptr[0], currptr[0], PREV_INSN (move_before));\n+      df_set_bb_dirty (EDGE_SUCC (bb, 0)->dest);\n+      if (final_dest_bb != NULL)\n+\tdf_set_bb_dirty (final_dest_bb);\n+      df_set_bb_dirty (bb);\n+      for (ix = 1; ix < nedges; ix++)\n+\t{\n+\t  df_set_bb_dirty (EDGE_SUCC (bb, ix)->dest);\n+\t  delete_insn_chain (headptr[ix], currptr[ix], false);\n+\t}\n+      if (!moveall)\n+\t{\n+\t  if (jump == move_before)\n+\t    break;\n+\n+\t  /* Try again, using a different insertion point.  */\n+\t  move_before = jump;\n+\t  for (ix = 0; ix < nedges; ix++)\n+\t    {\n+\t      rtx curr = currptr[ix];\n+\t      do\n+\t\tcurr = NEXT_INSN (curr);\n+\t      while (!NONDEBUG_INSN_P (curr));\n+\t      currptr[ix] = headptr[ix] = curr;\n+\t    }\n+\t}\n+    }\n+  while (!moveall);\n+\n+ out:\n+  free (currptr);\n+  free (headptr);\n+\n+  crossjumps_occured |= changed;\n+\n+  return changed;\n+}\n+\n /* Return true if BB contains just bb note, or bb note followed\n    by only DEBUG_INSNs.  */\n \n@@ -1972,6 +2235,7 @@ try_optimize_cfg (int mode)\n \t one predecessor, they may be combined.  */\n       do\n \t{\n+\t  block_was_dirty = false;\n \t  changed = false;\n \t  iterations++;\n \n@@ -2170,6 +2434,13 @@ try_optimize_cfg (int mode)\n \t\t  && try_crossjump_bb (mode, b))\n \t\tchanged_here = true;\n \n+\t      if ((mode & CLEANUP_CROSSJUMP)\n+\t\t  /* This can lengthen register lifetimes.  Do it only after\n+\t\t     reload.  */\n+\t\t  && reload_completed\n+\t\t  && try_head_merge_bb (b))\n+\t\tchanged_here = true;\n+\n \t      /* Don't get confused by the index shift caused by\n \t\t deleting blocks.  */\n \t      if (!changed_here)\n@@ -2182,6 +2453,13 @@ try_optimize_cfg (int mode)\n \t      && try_crossjump_bb (mode, EXIT_BLOCK_PTR))\n \t    changed = true;\n \n+\t  if (block_was_dirty)\n+\t    {\n+\t      /* This should only be set by head-merging.  */\n+\t      gcc_assert (mode & CLEANUP_CROSSJUMP);\n+\t      df_analyze ();\n+\t    }\n+\n #ifdef ENABLE_CHECKING\n \t  if (changed)\n \t    verify_flow_info ();\n@@ -2366,8 +2644,7 @@ cleanup_cfg (int mode)\n \t  if ((mode & CLEANUP_EXPENSIVE) && !reload_completed\n \t      && !delete_trivially_dead_insns (get_insns (), max_reg_num ()))\n \t    break;\n-\t  else if ((mode & CLEANUP_CROSSJUMP)\n-\t\t   && crossjumps_occured)\n+\t  if ((mode & CLEANUP_CROSSJUMP) && crossjumps_occured)\n \t    run_fast_dce ();\n \t}\n       else"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/config/i386/core2.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Fconfig%2Fi386%2Fcore2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Fconfig%2Fi386%2Fcore2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcore2.md?ref=3c3bd4710fecc6ef438e0917e218f3ef5eae63d9"}, {"sha": "7c49ccddce9048c6ea9ff175a7211b2af28c00a6", "filename": "gcc/df-core.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=3c3bd4710fecc6ef438e0917e218f3ef5eae63d9", "patch": "@@ -1413,6 +1413,7 @@ df_get_bb_dirty (basic_block bb)\n void\n df_set_bb_dirty (basic_block bb)\n {\n+  bb->flags |= BB_MODIFIED;\n   if (df)\n     {\n       int p;"}, {"sha": "82a0d0b6a57a5714e3abea3aca7dd75bbe9be2e3", "filename": "gcc/df-problems.c", "status": "modified", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=3c3bd4710fecc6ef438e0917e218f3ef5eae63d9", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"basic-block.h\"\n #include \"sbitmap.h\"\n #include \"bitmap.h\"\n+#include \"target.h\"\n #include \"timevar.h\"\n #include \"df.h\"\n #include \"except.h\"\n@@ -3500,6 +3501,27 @@ df_simulate_find_defs (rtx insn, bitmap defs)\n     }\n }\n \n+/* Find the set of uses for INSN.  This includes partial defs.  */\n+\n+static void\n+df_simulate_find_uses (rtx insn, bitmap uses)\n+{\n+  df_ref *rec;\n+  unsigned int uid = INSN_UID (insn);\n+\n+  for (rec = DF_INSN_UID_DEFS (uid); *rec; rec++)\n+    {\n+      df_ref def = *rec;\n+      if (DF_REF_FLAGS (def) & (DF_REF_PARTIAL | DF_REF_CONDITIONAL))\n+\tbitmap_set_bit (uses, DF_REF_REGNO (def));\n+    }\n+  for (rec = DF_INSN_UID_USES (uid); *rec; rec++)\n+    {\n+      df_ref use = *rec;\n+      bitmap_set_bit (uses, DF_REF_REGNO (use));\n+    }\n+}\n+\n /* Find the set of real DEFs, which are not clobbers, for INSN.  */\n \n void\n@@ -3727,7 +3749,301 @@ df_simulate_one_insn_forwards (basic_block bb, rtx insn, bitmap live)\n     }\n   df_simulate_fixup_sets (bb, live);\n }\n+\f\n+/* Used by the next two functions to encode information about the\n+   memory references we found.  */\n+#define MEMREF_NORMAL 1\n+#define MEMREF_VOLATILE 2\n+\n+/* A subroutine of can_move_insns_across_p called through for_each_rtx.\n+   Return either MEMREF_NORMAL or MEMREF_VOLATILE if a memory is found.  */\n+\n+static int\n+find_memory (rtx *px, void *data ATTRIBUTE_UNUSED)\n+{\n+  rtx x = *px;\n+\n+  if (GET_CODE (x) == ASM_OPERANDS && MEM_VOLATILE_P (x))\n+    return MEMREF_VOLATILE;\n+\n+  if (!MEM_P (x))\n+    return 0;\n+  if (MEM_VOLATILE_P (x))\n+    return MEMREF_VOLATILE;\n+  if (MEM_READONLY_P (x))\n+    return 0;\n+\n+  return MEMREF_NORMAL;\n+}\n+\n+/* A subroutine of can_move_insns_across_p called through note_stores.\n+   DATA points to an integer in which we set either the bit for\n+   MEMREF_NORMAL or the bit for MEMREF_VOLATILE if we find a MEM\n+   of either kind.  */\n+\n+static void\n+find_memory_stores (rtx x, const_rtx pat ATTRIBUTE_UNUSED,\n+\t\t    void *data ATTRIBUTE_UNUSED)\n+{\n+  int *pflags = (int *)data;\n+  if (GET_CODE (x) == SUBREG)\n+    x = XEXP (x, 0);\n+  /* Treat stores to SP as stores to memory, this will prevent problems\n+     when there are references to the stack frame.  */\n+  if (x == stack_pointer_rtx)\n+    *pflags |= MEMREF_VOLATILE;\n+  if (!MEM_P (x))\n+    return;\n+  *pflags |= MEM_VOLATILE_P (x) ? MEMREF_VOLATILE : MEMREF_NORMAL;\n+}\n+\n+/* Scan BB backwards, using df_simulate functions to keep track of\n+   lifetimes, up to insn POINT.  The result is stored in LIVE.  */\n+\n+void\n+simulate_backwards_to_point (basic_block bb, regset live, rtx point)\n+{\n+  rtx insn;\n+  bitmap_copy (live, df_get_live_out (bb));\n+  df_simulate_initialize_backwards (bb, live);\n+\n+  /* Scan and update life information until we reach the point we're\n+     interested in.  */\n+  for (insn = BB_END (bb); insn != point; insn = PREV_INSN (insn))\n+    df_simulate_one_insn_backwards (bb, insn, live);\n+}\n+\n+/* Return true if it is safe to move a group of insns, described by\n+   the range FROM to TO, backwards across another group of insns,\n+   described by ACROSS_FROM to ACROSS_TO.  It is assumed that there\n+   are no insns between ACROSS_TO and FROM, but they may be in\n+   different basic blocks; MERGE_BB is the block from which the\n+   insns will be moved.  The caller must pass in a regset MERGE_LIVE\n+   which specifies the registers live after TO.\n+\n+   This function may be called in one of two cases: either we try to\n+   move identical instructions from all successor blocks into their\n+   predecessor, or we try to move from only one successor block.  If\n+   OTHER_BRANCH_LIVE is nonnull, it indicates that we're dealing with\n+   the second case.  It should contain a set of registers live at the\n+   end of ACROSS_TO which must not be clobbered by moving the insns.\n+   In that case, we're also more careful about moving memory references\n+   and trapping insns.\n+\n+   We return false if it is not safe to move the entire group, but it\n+   may still be possible to move a subgroup.  PMOVE_UPTO, if nonnull,\n+   is set to point at the last moveable insn in such a case.  */\n \n+bool\n+can_move_insns_across (rtx from, rtx to, rtx across_from, rtx across_to,\n+\t\t       basic_block merge_bb, regset merge_live,\n+\t\t       regset other_branch_live, rtx *pmove_upto)\n+{\n+  rtx insn, next, max_to;\n+  bitmap merge_set, merge_use, local_merge_live;\n+  bitmap test_set, test_use;\n+  unsigned i, fail = 0;\n+  bitmap_iterator bi;\n+  int memrefs_in_across = 0;\n+  int mem_sets_in_across = 0;\n+  bool trapping_insns_in_across = false;\n+\n+  if (pmove_upto != NULL)\n+    *pmove_upto = NULL_RTX;\n+\n+  /* Find real bounds, ignoring debug insns.  */\n+  while (!NONDEBUG_INSN_P (from) && from != to)\n+    from = NEXT_INSN (from);\n+  while (!NONDEBUG_INSN_P (to) && from != to)\n+    to = PREV_INSN (to);\n+\n+  for (insn = across_to; ; insn = next)\n+    {\n+      if (NONDEBUG_INSN_P (insn))\n+\t{\n+\t  memrefs_in_across |= for_each_rtx (&PATTERN (insn), find_memory,\n+\t\t\t\t\t     NULL);\n+\t  note_stores (PATTERN (insn), find_memory_stores,\n+\t\t       &mem_sets_in_across);\n+\t  /* This is used just to find sets of the stack pointer.  */\n+\t  memrefs_in_across |= mem_sets_in_across;\n+\t  trapping_insns_in_across |= may_trap_p (PATTERN (insn));\n+\t}\n+      next = PREV_INSN (insn);\n+      if (insn == across_from)\n+\tbreak;\n+    }\n+\n+  /* Collect:\n+     MERGE_SET = set of registers set in MERGE_BB\n+     MERGE_USE = set of registers used in MERGE_BB and live at its top\n+     MERGE_LIVE = set of registers live at the point inside the MERGE\n+     range that we've reached during scanning\n+     TEST_SET = set of registers set between ACROSS_FROM and ACROSS_END.\n+     TEST_USE = set of registers used between ACROSS_FROM and ACROSS_END,\n+     and live before ACROSS_FROM.  */\n+\n+  merge_set = BITMAP_ALLOC (&reg_obstack);\n+  merge_use = BITMAP_ALLOC (&reg_obstack);\n+  local_merge_live = BITMAP_ALLOC (&reg_obstack);\n+  test_set = BITMAP_ALLOC (&reg_obstack);\n+  test_use = BITMAP_ALLOC (&reg_obstack);\n+\n+  /* Compute the set of registers set and used in the ACROSS range.  */\n+  if (other_branch_live != NULL)\n+    bitmap_copy (test_use, other_branch_live);\n+  df_simulate_initialize_backwards (merge_bb, test_use);\n+  for (insn = across_to; ; insn = next)\n+    {\n+      if (NONDEBUG_INSN_P (insn))\n+\t{\n+\t  df_simulate_find_defs (insn, test_set);\n+\t  df_simulate_defs (insn, test_use);\n+\t  df_simulate_uses (insn, test_use);\n+\t}\n+      next = PREV_INSN (insn);\n+      if (insn == across_from)\n+\tbreak;\n+    }\n+\n+  /* Compute an upper bound for the amount of insns moved, by finding\n+     the first insn in MERGE that sets a register in TEST_USE, or uses\n+     a register in TEST_SET.  We also check for calls, trapping operations,\n+     and memory references.  */\n+  max_to = NULL_RTX;\n+  for (insn = from; ; insn = next)\n+    {\n+      if (CALL_P (insn))\n+\tbreak;\n+      if (NONDEBUG_INSN_P (insn))\n+\t{\n+\t  if (may_trap_p (PATTERN (insn))\n+\t      && (trapping_insns_in_across || other_branch_live != NULL))\n+\t    break;\n+\n+\t  /* We cannot move memory stores past each other, or move memory\n+\t     reads past stores, at least not without tracking them and\n+\t     calling true_dependence on every pair.\n+\n+\t     If there is no other branch and no memory references or\n+\t     sets in the ACROSS range, we can move memory references\n+\t     freely, even volatile ones.\n+\n+\t     Otherwise, the rules are as follows: volatile memory\n+\t     references and stores can't be moved at all, and any type\n+\t     of memory reference can't be moved if there are volatile\n+\t     accesses or stores in the ACROSS range.  That leaves\n+\t     normal reads, which can be moved, as the trapping case is\n+\t     dealt with elsewhere.  */\n+\t  if (other_branch_live != NULL || memrefs_in_across != 0)\n+\t    {\n+\t      int mem_ref_flags = 0;\n+\t      int mem_set_flags = 0;\n+\t      note_stores (PATTERN (insn), find_memory_stores, &mem_set_flags);\n+\t      mem_ref_flags = for_each_rtx (&PATTERN (insn), find_memory,\n+\t\t\t\t\t    NULL);\n+\t      /* Catch sets of the stack pointer.  */\n+\t      mem_ref_flags |= mem_set_flags;\n+\n+\t      if ((mem_ref_flags | mem_set_flags) & MEMREF_VOLATILE)\n+\t\tbreak;\n+\t      if ((memrefs_in_across & MEMREF_VOLATILE) && mem_ref_flags != 0)\n+\t\tbreak;\n+\t      if (mem_set_flags != 0\n+\t\t  || (mem_sets_in_across != 0 && mem_ref_flags != 0))\n+\t\tbreak;\n+\t    }\n+\t  df_simulate_find_uses (insn, merge_use);\n+\t  /* We're only interested in uses which use a value live at\n+\t     the top, not one previously set in this block.  */\n+\t  bitmap_and_compl_into (merge_use, merge_set);\n+\t  df_simulate_find_defs (insn, merge_set);\n+\t  if (bitmap_intersect_p (merge_set, test_use)\n+\t      || bitmap_intersect_p (merge_use, test_set))\n+\t    break;\n+\t  max_to = insn;\n+\t}\n+      next = NEXT_INSN (insn);\n+      if (insn == to)\n+\tbreak;\n+    }\n+  if (max_to != to)\n+    fail = 1;\n+\n+  if (max_to == NULL_RTX || (fail && pmove_upto == NULL))\n+    goto out;\n+\n+  /* Now, lower this upper bound by also taking into account that\n+     a range of insns moved across ACROSS must not leave a register\n+     live at the end that will be clobbered in ACROSS.  We need to\n+     find a point where TEST_SET & LIVE == 0.\n+\n+     Insns in the MERGE range that set registers which are also set\n+     in the ACROSS range may still be moved as long as we also move\n+     later insns which use the results of the set, and make the\n+     register dead again.  This is verified by the condition stated\n+     above.  We only need to test it for registers that are set in\n+     the moved region.\n+\n+     MERGE_LIVE is provided by the caller and holds live registers after\n+     TO.  */\n+  bitmap_copy (local_merge_live, merge_live);\n+  for (insn = to; insn != max_to; insn = PREV_INSN (insn))\n+    df_simulate_one_insn_backwards (merge_bb, insn, local_merge_live);\n+\n+  /* We're not interested in registers that aren't set in the moved\n+     region at all.  */\n+  bitmap_and_into (local_merge_live, merge_set);\n+  for (;;)\n+    {\n+      if (NONDEBUG_INSN_P (insn))\n+\t{\n+\t  if (!bitmap_intersect_p (test_set, local_merge_live))\n+\t    {\n+\t      max_to = insn;\n+\t      break;\n+\t    }\n+\n+\t  df_simulate_one_insn_backwards (merge_bb, insn,\n+\t\t\t\t\t  local_merge_live);\n+\t}\n+      if (insn == from)\n+\t{\n+\t  fail = 1;\n+\t  goto out;\n+\t}\n+      insn = PREV_INSN (insn);\n+    }\n+\n+  if (max_to != to)\n+    fail = 1;\n+\n+  if (pmove_upto)\n+    *pmove_upto = max_to;\n+\n+  /* For small register class machines, don't lengthen lifetimes of\n+     hard registers before reload.  */\n+  if (! reload_completed\n+      && targetm.small_register_classes_for_mode_p (VOIDmode))\n+    {\n+      EXECUTE_IF_SET_IN_BITMAP (merge_set, 0, i, bi)\n+\t{\n+\t  if (i < FIRST_PSEUDO_REGISTER\n+\t      && ! fixed_regs[i]\n+\t      && ! global_regs[i])\n+\t    fail = 1;\n+\t}\n+    }\n+\n+ out:\n+  BITMAP_FREE (merge_set);\n+  BITMAP_FREE (merge_use);\n+  BITMAP_FREE (local_merge_live);\n+  BITMAP_FREE (test_set);\n+  BITMAP_FREE (test_use);\n+\n+  return !fail;\n+}\n \n \f\n /*----------------------------------------------------------------------------"}, {"sha": "a831c9a3664fab81146aab6446cf30f9630de2ab", "filename": "gcc/df.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=3c3bd4710fecc6ef438e0917e218f3ef5eae63d9", "patch": "@@ -971,7 +971,9 @@ extern void df_simulate_one_insn_backwards (basic_block, rtx, bitmap);\n extern void df_simulate_finalize_backwards (basic_block, bitmap);\n extern void df_simulate_initialize_forwards (basic_block, bitmap);\n extern void df_simulate_one_insn_forwards (basic_block, rtx, bitmap);\n-\n+extern void simulate_backwards_to_point (basic_block, regset, rtx);\n+extern bool can_move_insns_across (rtx, rtx, rtx, rtx, basic_block, regset,\n+\t\t\t\t   regset, rtx *);\n /* Functions defined in df-scan.c.  */\n \n extern void df_scan_alloc (bitmap);"}, {"sha": "4e3a6850b8cfd02585b0507e4de4779a8fd4c4e4", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 19, "deletions": 122, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=3c3bd4710fecc6ef438e0917e218f3ef5eae63d9", "patch": "@@ -101,7 +101,6 @@ static int noce_find_if_block (basic_block, edge, edge, int);\n static int cond_exec_find_if_block (ce_if_block_t *);\n static int find_if_case_1 (basic_block, edge, edge);\n static int find_if_case_2 (basic_block, edge, edge);\n-static int find_memory (rtx *, void *);\n static int dead_or_predicable (basic_block, basic_block, basic_block,\n \t\t\t       basic_block, int);\n static void noce_emit_move_insn (rtx, rtx);\n@@ -3882,15 +3881,6 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n   return TRUE;\n }\n \n-/* A subroutine of dead_or_predicable called through for_each_rtx.\n-   Return 1 if a memory is found.  */\n-\n-static int\n-find_memory (rtx *px, void *data ATTRIBUTE_UNUSED)\n-{\n-  return MEM_P (*px);\n-}\n-\n /* Used by the code above to perform the actual rtl transformations.\n    Return TRUE if successful.\n \n@@ -3992,131 +3982,38 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n       earliest = jump;\n     }\n #endif\n+  /* If we allocated new pseudos (e.g. in the conditional move\n+     expander called from noce_emit_cmove), we must resize the\n+     array first.  */\n+  if (max_regno < max_reg_num ())\n+    max_regno = max_reg_num ();\n+\n   /* Try the NCE path if the CE path did not result in any changes.  */\n   if (n_validated_changes == 0)\n     {\n+      rtx cond;\n+      regset live;\n+      bool success;\n+\n       /* In the non-conditional execution case, we have to verify that there\n \t are no trapping operations, no calls, no references to memory, and\n \t that any registers modified are dead at the branch site.  */\n \n-      rtx insn, cond, prev;\n-      bitmap merge_set, merge_set_noclobber, test_live, test_set;\n-      unsigned i, fail = 0;\n-      bitmap_iterator bi;\n-\n-      /* Check for no calls or trapping operations.  */\n-      for (insn = head; ; insn = NEXT_INSN (insn))\n-\t{\n-\t  if (CALL_P (insn))\n-\t    return FALSE;\n-\t  if (NONDEBUG_INSN_P (insn))\n-\t    {\n-\t      if (may_trap_p (PATTERN (insn)))\n-\t\treturn FALSE;\n-\n-\t      /* ??? Even non-trapping memories such as stack frame\n-\t\t references must be avoided.  For stores, we collect\n-\t\t no lifetime info; for reads, we'd have to assert\n-\t\t true_dependence false against every store in the\n-\t\t TEST range.  */\n-\t      if (for_each_rtx (&PATTERN (insn), find_memory, NULL))\n-\t\treturn FALSE;\n-\t    }\n-\t  if (insn == end)\n-\t    break;\n-\t}\n-\n-      if (! any_condjump_p (jump))\n+      if (!any_condjump_p (jump))\n \treturn FALSE;\n \n       /* Find the extent of the conditional.  */\n       cond = noce_get_condition (jump, &earliest, false);\n-      if (! cond)\n+      if (!cond)\n \treturn FALSE;\n \n-      /* Collect:\n-\t   MERGE_SET = set of registers set in MERGE_BB\n-\t   MERGE_SET_NOCLOBBER = like MERGE_SET, but only includes registers\n-\t     that are really set, not just clobbered.\n-\t   TEST_LIVE = set of registers live at EARLIEST\n-\t   TEST_SET = set of registers set between EARLIEST and the\n-\t     end of the block.  */\n-\n-      merge_set = BITMAP_ALLOC (&reg_obstack);\n-      merge_set_noclobber = BITMAP_ALLOC (&reg_obstack);\n-      test_live = BITMAP_ALLOC (&reg_obstack);\n-      test_set = BITMAP_ALLOC (&reg_obstack);\n-\n-      /* ??? bb->local_set is only valid during calculate_global_regs_live,\n-\t so we must recompute usage for MERGE_BB.  Not so bad, I suppose,\n-         since we've already asserted that MERGE_BB is small.  */\n-      /* If we allocated new pseudos (e.g. in the conditional move\n-\t expander called from noce_emit_cmove), we must resize the\n-\t array first.  */\n-      if (max_regno < max_reg_num ())\n-\tmax_regno = max_reg_num ();\n-\n-      FOR_BB_INSNS (merge_bb, insn)\n-\t{\n-\t  if (NONDEBUG_INSN_P (insn))\n-\t    {\n-\t      df_simulate_find_defs (insn, merge_set);\n-\t      df_simulate_find_noclobber_defs (insn, merge_set_noclobber);\n-\t    }\n-\t}\n-\n-      /* For small register class machines, don't lengthen lifetimes of\n-\t hard registers before reload.  */\n-      if (! reload_completed\n-\t  && targetm.small_register_classes_for_mode_p (VOIDmode))\n-\t{\n-          EXECUTE_IF_SET_IN_BITMAP (merge_set_noclobber, 0, i, bi)\n-\t    {\n-\t      if (i < FIRST_PSEUDO_REGISTER\n-\t\t  && ! fixed_regs[i]\n-\t\t  && ! global_regs[i])\n-\t\tfail = 1;\n-\t    }\n-\t}\n-\n-      /* For TEST, we're interested in a range of insns, not a whole block.\n-\t Moreover, we're interested in the insns live from OTHER_BB.  */\n-\n-      /* The loop below takes the set of live registers\n-         after JUMP, and calculates the live set before EARLIEST. */\n-      bitmap_copy (test_live, df_get_live_in (other_bb));\n-      df_simulate_initialize_backwards (test_bb, test_live);\n-      for (insn = jump; ; insn = prev)\n-\t{\n-\t  if (INSN_P (insn))\n-\t    {\n-\t      df_simulate_find_defs (insn, test_set);\n-\t      df_simulate_one_insn_backwards (test_bb, insn, test_live);\n-\t    }\n-\t  prev = PREV_INSN (insn);\n-\t  if (insn == earliest)\n-\t    break;\n-\t}\n-\n-      /* We can perform the transformation if\n-\t   MERGE_SET_NOCLOBBER & TEST_SET\n-\t and\n-\t   MERGE_SET & TEST_LIVE)\n-\t and\n-\t   TEST_SET & DF_LIVE_IN (merge_bb)\n-\t are empty.  */\n-\n-      if (bitmap_intersect_p (test_set, merge_set_noclobber)\n-\t  || bitmap_intersect_p (test_live, merge_set)\n-\t  || bitmap_intersect_p (test_set, df_get_live_in (merge_bb)))\n-\tfail = 1;\n-\n-      BITMAP_FREE (merge_set_noclobber);\n-      BITMAP_FREE (merge_set);\n-      BITMAP_FREE (test_live);\n-      BITMAP_FREE (test_set);\n-\n-      if (fail)\n+      live = BITMAP_ALLOC (&reg_obstack);\n+      simulate_backwards_to_point (merge_bb, live, end);\n+      success = can_move_insns_across (head, end, earliest, jump,\n+\t\t\t\t       merge_bb, live,\n+\t\t\t\t       df_get_live_in (other_bb), NULL);\n+      BITMAP_FREE (live);\n+      if (!success)\n \treturn FALSE;\n     }\n "}, {"sha": "58497f3bc794530ece33072e06b50fe606efb4ff", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3c3bd4710fecc6ef438e0917e218f3ef5eae63d9", "patch": "@@ -1,3 +1,11 @@\n+2010-09-23  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR rtl-optimization/44374\n+\t* gcc.target/arm/headmerge-1.c: New test.\n+\t* gcc.target/arm/headmerge-2.c: New test.\n+\t* gcc.target/i386/headmerge-1.c: New test.\n+\t* gcc.target/i386/headmerge-2.c: New test.\n+\n 2010-09-23  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/38936"}, {"sha": "218c6a21ebd27bc373a7908f0a5333c3cbc79291", "filename": "gcc/testsuite/gcc.target/arm/headmerge-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fheadmerge-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fheadmerge-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fheadmerge-1.c?ref=3c3bd4710fecc6ef438e0917e218f3ef5eae63d9", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile }  */\n+/* { dg-options \"-O2\" }  */\n+/* { dg-final { scan-assembler-times \"#120\" 1 } } */\n+\n+extern void foo1 (int);\n+extern void foo2 (int);\n+\n+void t (int x, int y)\n+{\n+  if (y < 5)\n+    foo1 (120);\n+  else\n+    foo2 (120);\n+}"}, {"sha": "36637a64eb3276b18f0a09f5fc5f8a8ed8565bd8", "filename": "gcc/testsuite/gcc.target/arm/headmerge-2.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fheadmerge-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fheadmerge-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fheadmerge-2.c?ref=3c3bd4710fecc6ef438e0917e218f3ef5eae63d9", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile }  */\n+/* { dg-options \"-O2\" }  */\n+/* { dg-final { scan-assembler-times \"120\" 1 } } */\n+\n+extern void foo1 (int);\n+extern void foo2 (int);\n+extern void foo3 (int);\n+extern void foo4 (int);\n+extern void foo5 (int);\n+extern void foo6 (int);\n+\n+void t (int x, int y)\n+{\n+  switch (y)\n+    {\n+    case 1:\n+      foo1 (120);\n+      break;\n+    case 5:\n+      foo2 (120);\n+      break;\n+    case 7:\n+      foo3 (120);\n+      break;\n+    case 10:\n+      foo4 (120);\n+      break;\n+    case 13:\n+      foo5 (120);\n+      break;\n+    default:\n+      foo6 (120);\n+      break;\n+    }\n+}"}, {"sha": "941028c31db66a5fb95e1955df8e12cf70a4651f", "filename": "gcc/testsuite/gcc.target/i386/headmerge-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fheadmerge-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fheadmerge-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fheadmerge-1.c?ref=3c3bd4710fecc6ef438e0917e218f3ef5eae63d9", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile }  */\n+/* { dg-options \"-O2\" }  */\n+/* { dg-final { scan-assembler-times \"120\" 1 } } */\n+\n+extern void foo1 (int);\n+extern void foo2 (int);\n+\n+void t (int x, int y)\n+{\n+  if (y < 5)\n+    foo1 (120);\n+  else\n+    foo2 (120);\n+}"}, {"sha": "36637a64eb3276b18f0a09f5fc5f8a8ed8565bd8", "filename": "gcc/testsuite/gcc.target/i386/headmerge-2.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fheadmerge-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3bd4710fecc6ef438e0917e218f3ef5eae63d9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fheadmerge-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fheadmerge-2.c?ref=3c3bd4710fecc6ef438e0917e218f3ef5eae63d9", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile }  */\n+/* { dg-options \"-O2\" }  */\n+/* { dg-final { scan-assembler-times \"120\" 1 } } */\n+\n+extern void foo1 (int);\n+extern void foo2 (int);\n+extern void foo3 (int);\n+extern void foo4 (int);\n+extern void foo5 (int);\n+extern void foo6 (int);\n+\n+void t (int x, int y)\n+{\n+  switch (y)\n+    {\n+    case 1:\n+      foo1 (120);\n+      break;\n+    case 5:\n+      foo2 (120);\n+      break;\n+    case 7:\n+      foo3 (120);\n+      break;\n+    case 10:\n+      foo4 (120);\n+      break;\n+    case 13:\n+      foo5 (120);\n+      break;\n+    default:\n+      foo6 (120);\n+      break;\n+    }\n+}"}]}