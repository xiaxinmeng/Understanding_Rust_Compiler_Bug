{"sha": "18dbb8590310fedf2948bf0677d18cddb85fa5c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThkYmI4NTkwMzEwZmVkZjI5NDhiZjA2NzdkMThjZGRiODVmYTVjOQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2010-08-31T17:39:51Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2010-08-31T17:39:51Z"}, "message": "re PR libstdc++/44480 ([C++0x] Linear performance of begin() in unordered associative containers)\n\n2010-08-31  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR libstdc++/44480\n\t* include/bits/hashtable.h (_Hashtable<>::_M_begin_bucket_index):\n\tAdd, caching the index of the first non-empty bucket.\n\t(begin, cbegin): Use it.\n\t(_Hashtable<>::_Hashtable(_InputIterator, _InputIterator, ...),\n\t_Hashtable(const _Hashtable&), _Hashtable(_Hashtable&&),\n\tswap(_Hashtable&), clear): Adjust.\n\t(_M_insert_bucket, _M_insert, erase(const_iterator),\n\terase(const key_type&), _M_rehash): Update it.\n\n\t* include/bits/hashtable.h (_Hashtable<>::_M_erase): Remove.\n\t(erase(const_iterator)): Inline the latter.\n\nFrom-SVN: r163686", "tree": {"sha": "abf771e125f7ff3903e8b48ccac872d9b91c645d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abf771e125f7ff3903e8b48ccac872d9b91c645d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18dbb8590310fedf2948bf0677d18cddb85fa5c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18dbb8590310fedf2948bf0677d18cddb85fa5c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18dbb8590310fedf2948bf0677d18cddb85fa5c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18dbb8590310fedf2948bf0677d18cddb85fa5c9/comments", "author": null, "committer": null, "parents": [{"sha": "6208468d29f6c51810131721cb205d81f1b7d23e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6208468d29f6c51810131721cb205d81f1b7d23e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6208468d29f6c51810131721cb205d81f1b7d23e"}], "stats": {"total": 129, "additions": 76, "deletions": 53}, "files": [{"sha": "07b058ef36a6f066325b174d1639335172d4f5b1", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbb8590310fedf2948bf0677d18cddb85fa5c9/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbb8590310fedf2948bf0677d18cddb85fa5c9/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=18dbb8590310fedf2948bf0677d18cddb85fa5c9", "patch": "@@ -1,3 +1,18 @@\n+2010-08-31  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR libstdc++/44480\n+\t* include/bits/hashtable.h (_Hashtable<>::_M_begin_bucket_index):\n+\tAdd, caching the index of the first non-empty bucket.\n+\t(begin, cbegin): Use it.\n+\t(_Hashtable<>::_Hashtable(_InputIterator, _InputIterator, ...),\n+\t_Hashtable(const _Hashtable&), _Hashtable(_Hashtable&&),\n+\tswap(_Hashtable&), clear): Adjust.\n+\t(_M_insert_bucket, _M_insert, erase(const_iterator),\n+\terase(const key_type&), _M_rehash): Update it.\n+\n+\t* include/bits/hashtable.h (_Hashtable<>::_M_erase): Remove.\n+\t(erase(const_iterator)): Inline the latter.\n+\n 2010-08-31  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* testsuite/23_containers/forward_list/operations/remove_freed.cc:"}, {"sha": "be6d9a185d6ed57225488cd5f543fc21ab06d58c", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 61, "deletions": 53, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18dbb8590310fedf2948bf0677d18cddb85fa5c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18dbb8590310fedf2948bf0677d18cddb85fa5c9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=18dbb8590310fedf2948bf0677d18cddb85fa5c9", "patch": "@@ -175,6 +175,7 @@ namespace std\n       _Node_allocator_type   _M_node_allocator;\n       _Node**                _M_buckets;\n       size_type              _M_bucket_count;\n+      size_type              _M_begin_bucket_index; // First non-empty bucket.\n       size_type              _M_element_count;\n       _RehashPolicy          _M_rehash_policy;\n       \n@@ -236,21 +237,11 @@ namespace std\n       // Basic container operations\n       iterator\n       begin()\n-      {\n-\titerator __i(_M_buckets);\n-\tif (!__i._M_cur_node)\n-\t  __i._M_incr_bucket();\n-\treturn __i;\n-      }\n+      { return iterator(_M_buckets + _M_begin_bucket_index); }\n \n       const_iterator\n       begin() const\n-      {\n-\tconst_iterator __i(_M_buckets);\n-\tif (!__i._M_cur_node)\n-\t  __i._M_incr_bucket();\n-\treturn __i;\n-      }\n+      { return const_iterator(_M_buckets + _M_begin_bucket_index); }\n \n       iterator\n       end()\n@@ -262,12 +253,7 @@ namespace std\n \n       const_iterator\n       cbegin() const\n-      {\n-\tconst_iterator __i(_M_buckets);\n-\tif (!__i._M_cur_node)\n-\t  __i._M_incr_bucket();\n-\treturn __i;\n-      }\n+      { return const_iterator(_M_buckets + _M_begin_bucket_index); }\n \n       const_iterator\n       cend() const\n@@ -408,10 +394,7 @@ namespace std\n       iterator\n       _M_insert(const value_type&, std::false_type);\n \n-      void\n-      _M_erase_node(_Node*, _Node**);\n-\n-    public:\t\t\t\t\n+    public:\n       // Insert and erase\n       _Insert_Return_Type\n       insert(const value_type& __v) \n@@ -571,6 +554,7 @@ namespace std\n     {\n       _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint);\n       _M_buckets = _M_allocate_buckets(_M_bucket_count);\n+      _M_begin_bucket_index = _M_bucket_count;\n     }\n \n   template<typename _Key, typename _Value, \n@@ -601,6 +585,7 @@ namespace std\n \t\t\t\t\t\t       __distance_fw(__f,\n \t\t\t\t\t\t\t\t     __l)));\n \t_M_buckets = _M_allocate_buckets(_M_bucket_count);\n+\t_M_begin_bucket_index = _M_bucket_count;\n \t__try\n \t  {\n \t    for (; __f != __l; ++__f)\n@@ -627,6 +612,7 @@ namespace std\n       __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(__ht),\n       _M_node_allocator(__ht._M_node_allocator),\n       _M_bucket_count(__ht._M_bucket_count),\n+      _M_begin_bucket_index(__ht._M_begin_bucket_index),\n       _M_element_count(__ht._M_element_count),\n       _M_rehash_policy(__ht._M_rehash_policy)\n     {\n@@ -668,12 +654,14 @@ namespace std\n       _M_node_allocator(__ht._M_node_allocator),\n       _M_buckets(__ht._M_buckets),\n       _M_bucket_count(__ht._M_bucket_count),\n+      _M_begin_bucket_index(__ht._M_begin_bucket_index),\n       _M_element_count(__ht._M_element_count),\n       _M_rehash_policy(__ht._M_rehash_policy)\n     {\n       size_type __n_bkt = __ht._M_rehash_policy._M_next_bkt(0);\n       __ht._M_buckets = __ht._M_allocate_buckets(__n_bkt);\n       __ht._M_bucket_count = __n_bkt;\n+      __ht._M_begin_bucket_index = __ht._M_bucket_count;\n       __ht._M_element_count = 0;\n       __ht._M_rehash_policy = _RehashPolicy();\n     }\n@@ -713,6 +701,7 @@ namespace std\n       std::swap(_M_rehash_policy, __x._M_rehash_policy);\n       std::swap(_M_buckets, __x._M_buckets);\n       std::swap(_M_bucket_count, __x._M_bucket_count);\n+      std::swap(_M_begin_bucket_index, __x._M_begin_bucket_index);\n       std::swap(_M_element_count, __x._M_element_count);\n     }\n \n@@ -915,6 +904,8 @@ namespace std\n \t  this->_M_store_code(__new_node, __code);\n \t  _M_buckets[__n] = __new_node;\n \t  ++_M_element_count;\n+\t  if (__n < _M_begin_bucket_index)\n+\t    _M_begin_bucket_index = __n;\n \t  return iterator(__new_node, _M_buckets + __n);\n \t}\n       __catch(...)\n@@ -981,41 +972,15 @@ namespace std\n \t{\n \t  __new_node->_M_next = _M_buckets[__n];\n \t  _M_buckets[__n] = __new_node;\n+\t  if (__n < _M_begin_bucket_index)\n+\t    _M_begin_bucket_index = __n;\n \t}\n       this->_M_store_code(__new_node, __code);\n \n       ++_M_element_count;\n       return iterator(__new_node, _M_buckets + __n);\n     }\n \n-  // For erase(iterator) and erase(const_iterator).\n-  template<typename _Key, typename _Value, \n-\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   bool __chc, bool __cit, bool __uk>\n-    void\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_erase_node(_Node* __p, _Node** __b)\n-    {\n-      _Node* __cur = *__b;\n-      if (__cur == __p)\n-\t*__b = __cur->_M_next;\n-      else\n-\t{\n-\t  _Node* __next = __cur->_M_next;\n-\t  while (__next != __p)\n-\t    {\n-\t      __cur = __next;\n-\t      __next = __cur->_M_next;\n-\t    }\n-\t  __cur->_M_next = __next->_M_next;\n-\t}\n-\n-      _M_deallocate_node(__p);\n-      --_M_element_count;\n-    }\n-\n   template<typename _Key, typename _Value, \n \t   typename _Allocator, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n@@ -1050,7 +1015,31 @@ namespace std\n     {\n       iterator __result(__it._M_cur_node, __it._M_cur_bucket);\n       ++__result;\n-      _M_erase_node(__it._M_cur_node, __it._M_cur_bucket);\n+\n+      _Node* __cur = *__it._M_cur_bucket;\n+      if (__cur == __it._M_cur_node)\n+\t{\n+\t  *__it._M_cur_bucket = __cur->_M_next;\n+\n+\t  // If _M_begin_bucket_index no longer indexes the first non-empty\n+\t  // bucket - its single node is being erased - update it.\n+\t  if (!_M_buckets[_M_begin_bucket_index])\n+\t    _M_begin_bucket_index = __result._M_cur_bucket - _M_buckets;\n+\t}\n+      else\n+\t{\n+\t  _Node* __next = __cur->_M_next;\n+\t  while (__next != __it._M_cur_node)\n+\t    {\n+\t      __cur = __next;\n+\t      __next = __cur->_M_next;\n+\t    }\n+\t  __cur->_M_next = __next->_M_next;\n+\t}\n+\n+      _M_deallocate_node(__it._M_cur_node);\n+      --_M_element_count;\n+\n       return __result;\n     }\n \n@@ -1104,6 +1093,20 @@ namespace std\n \t  ++__result;\n \t}\n \n+      // If the entire bucket indexed by _M_begin_bucket_index has been\n+      // erased look forward for the first non-empty bucket.\n+      if (!_M_buckets[_M_begin_bucket_index])\n+\t{\n+\t  if (!_M_element_count)\n+\t    _M_begin_bucket_index = _M_bucket_count;\n+\t  else\n+\t    {\n+\t      ++_M_begin_bucket_index;\n+\t      while (!_M_buckets[_M_begin_bucket_index])\n+\t\t++_M_begin_bucket_index;\n+\t    }\n+\t}\n+\n       return __result;\n     }\n \n@@ -1121,8 +1124,8 @@ namespace std\n \t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n     erase(const_iterator __first, const_iterator __last)\n     {\n-      while (__first != __last)\n-\t__first = this->erase(__first);\n+       while (__first != __last)\n+\t __first = this->erase(__first);\n       return iterator(__last._M_cur_node, __last._M_cur_bucket);\n     }\n \n@@ -1137,6 +1140,7 @@ namespace std\n     {\n       _M_deallocate_nodes(_M_buckets, _M_bucket_count);\n       _M_element_count = 0;\n+      _M_begin_bucket_index = _M_bucket_count;\n     }\n  \n   template<typename _Key, typename _Value, \n@@ -1165,13 +1169,16 @@ namespace std\n       _Node** __new_array = _M_allocate_buckets(__n);\n       __try\n \t{\n+\t  _M_begin_bucket_index = __n;\n \t  for (size_type __i = 0; __i < _M_bucket_count; ++__i)\n \t    while (_Node* __p = _M_buckets[__i])\n \t      {\n \t\tstd::size_t __new_index = this->_M_bucket_index(__p, __n);\n \t\t_M_buckets[__i] = __p->_M_next;\n \t\t__p->_M_next = __new_array[__new_index];\n \t\t__new_array[__new_index] = __p;\n+\t\tif (__new_index < _M_begin_bucket_index)\n+\t\t  _M_begin_bucket_index = __new_index;\n \t      }\n \t  _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n \t  _M_bucket_count = __n;\n@@ -1187,6 +1194,7 @@ namespace std\n \t  _M_deallocate_buckets(__new_array, __n);\n \t  _M_deallocate_nodes(_M_buckets, _M_bucket_count);\n \t  _M_element_count = 0;\n+\t  _M_begin_bucket_index = _M_bucket_count;\n \t  __throw_exception_again;\n \t}\n     }"}]}