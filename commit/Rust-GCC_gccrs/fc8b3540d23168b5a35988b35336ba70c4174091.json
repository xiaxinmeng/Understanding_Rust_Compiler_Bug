{"sha": "fc8b3540d23168b5a35988b35336ba70c4174091", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM4YjM1NDBkMjMxNjhiNWEzNTk4OGIzNTMzNmJhNzBjNDE3NDA5MQ==", "commit": {"author": {"name": "Ilya Verbin", "email": "ilya.verbin@intel.com", "date": "2014-11-13T13:47:46Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-11-13T13:47:46Z"}, "message": "[PATCH 4/7] OpenMP 4.0 offloading infrastructure: lto-wrapper.\n\ngcc/\n\t* gcc.c (spec_host_machine, accel_dir_suffix): New variables.\n\t(process_command): Tweak path construction for the possibility\n\tof being configured as an offload compiler.\n\t(driver::maybe_putenv_OFFLOAD_TARGETS): New function.\n\t(driver::main): Call maybe_putenv_OFFLOAD_TARGETS.\n\t(driver::set_up_specs): Tweak path construction for the possibility of\n\tbeing configured as an offload compiler.\n\t* lto-wrapper.c (OFFLOAD_TARGET_NAMES_ENV): Define.\n\t(offload_names, offloadbegin, offloadend): New static variables.\n\t(free_array_of_ptrs, parse_env_var, access_check, compile_offload_image)\n\t(compile_images_for_offload_targets, copy_file, find_offloadbeginend):\n\tNew static functions.\n\t(run_gcc): Determine whether offload sections are present.  If so, run\n\tcompile_images_for_offload_targets and return the names of new generated\n\tobjects to linker.  If there are offload sections, but no LTO sections,\n\tthen return the copies of input objects without link-time recompilation.\n\nlto-plugin/\n\t* lto-plugin.c (OFFLOAD_SECTION, OFFLOAD_SECTION_LEN): Define.\n\t(struct plugin_objfile): Add new field \"offload\".\n\t(process_offload_section): New static function.\n\t(claim_file_handler): Claim file if it contains offload sections.\n\nCo-Authored-By: Andrey Turetskiy <andrey.turetskiy@intel.com>\nCo-Authored-By: Bernd Schmidt <bernds@codesourcery.com>\nCo-Authored-By: Michael Zolotukhin <michael.v.zolotukhin@intel.com>\n\nFrom-SVN: r217491", "tree": {"sha": "01939e74e91ddfabc8de28a27fd8c4f87e5feb2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01939e74e91ddfabc8de28a27fd8c4f87e5feb2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc8b3540d23168b5a35988b35336ba70c4174091", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc8b3540d23168b5a35988b35336ba70c4174091", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc8b3540d23168b5a35988b35336ba70c4174091", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc8b3540d23168b5a35988b35336ba70c4174091/comments", "author": null, "committer": null, "parents": [{"sha": "ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec6fe917cd323dfe1f84aebe9f3c2eda2b5cbdd1"}], "stats": {"total": 377, "additions": 365, "deletions": 12}, "files": [{"sha": "c40487d2d877225da0cdbbaf3792993082ca3f82", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc8b3540d23168b5a35988b35336ba70c4174091/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc8b3540d23168b5a35988b35336ba70c4174091/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc8b3540d23168b5a35988b35336ba70c4174091", "patch": "@@ -1,3 +1,25 @@\n+2014-11-13  Ilya Verbin  <ilya.verbin@intel.com>\n+\t    Bernd Schmidt  <bernds@codesourcery.com>\n+\t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n+\t    Michael Zolotukhin  <michael.v.zolotukhin@intel.com>\n+\n+\t* gcc.c (spec_host_machine, accel_dir_suffix): New variables.\n+\t(process_command): Tweak path construction for the possibility\n+\tof being configured as an offload compiler.\n+\t(driver::maybe_putenv_OFFLOAD_TARGETS): New function.\n+\t(driver::main): Call maybe_putenv_OFFLOAD_TARGETS.\n+\t(driver::set_up_specs): Tweak path construction for the possibility of\n+\tbeing configured as an offload compiler.\n+\t* lto-wrapper.c (OFFLOAD_TARGET_NAMES_ENV): Define.\n+\t(offload_names, offloadbegin, offloadend): New static variables.\n+\t(free_array_of_ptrs, parse_env_var, access_check, compile_offload_image)\n+\t(compile_images_for_offload_targets, copy_file, find_offloadbeginend):\n+\tNew static functions.\n+\t(run_gcc): Determine whether offload sections are present.  If so, run\n+\tcompile_images_for_offload_targets and return the names of new generated\n+\tobjects to linker.  If there are offload sections, but no LTO sections,\n+\tthen return the copies of input objects without link-time recompilation.\n+\n 2014-11-13  Richard Biener  <rguenther@suse.de>\n \n \t* genmatch.c (dt_node::gen_kids): Fix placement of break statement."}, {"sha": "abadfbf2e9308d298c820895ee74681046d97c95", "filename": "gcc/gcc.c", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc8b3540d23168b5a35988b35336ba70c4174091/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc8b3540d23168b5a35988b35336ba70c4174091/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=fc8b3540d23168b5a35988b35336ba70c4174091", "patch": "@@ -157,6 +157,7 @@ static const char *const spec_version = DEFAULT_TARGET_VERSION;\n /* The target machine.  */\n \n static const char *spec_machine = DEFAULT_TARGET_MACHINE;\n+static const char *spec_host_machine = DEFAULT_REAL_TARGET_MACHINE;\n \n /* Nonzero if cross-compiling.\n    When -b is used, the value comes from the `specs' file.  */\n@@ -1296,6 +1297,9 @@ static const char *const standard_startfile_prefix_2\n    relative to the driver.  */\n static const char *const tooldir_base_prefix = TOOLDIR_BASE_PREFIX;\n \n+/* A prefix to be used when this is an accelerator compiler.  */\n+static const char *const accel_dir_suffix = ACCEL_DIR_SUFFIX;\n+\n /* Subdirectory to use for locating libraries.  Set by\n    set_multilib_dir based on the compilation options.  */\n \n@@ -4129,15 +4133,15 @@ process_command (unsigned int decoded_options_count,\n     }\n \n   gcc_assert (!IS_ABSOLUTE_PATH (tooldir_base_prefix));\n-  tooldir_prefix2 = concat (tooldir_base_prefix, spec_machine,\n+  tooldir_prefix2 = concat (tooldir_base_prefix, spec_host_machine,\n \t\t\t    dir_separator_str, NULL);\n \n   /* Look for tools relative to the location from which the driver is\n      running, or, if that is not available, the configured prefix.  */\n   tooldir_prefix\n     = concat (gcc_exec_prefix ? gcc_exec_prefix : standard_exec_prefix,\n-\t      spec_machine, dir_separator_str,\n-\t      spec_version, dir_separator_str, tooldir_prefix2, NULL);\n+\t      spec_host_machine, dir_separator_str, spec_version,\n+\t      accel_dir_suffix, dir_separator_str, tooldir_prefix2, NULL);\n   free (tooldir_prefix2);\n \n   add_prefix (&exec_prefixes,\n@@ -6749,6 +6753,7 @@ class driver\n   void set_up_specs () const;\n   void putenv_COLLECT_GCC (const char *argv0) const;\n   void maybe_putenv_COLLECT_LTO_WRAPPER () const;\n+  void maybe_putenv_OFFLOAD_TARGETS () const;\n   void handle_unrecognized_options () const;\n   int maybe_print_and_exit () const;\n   bool prepare_infiles ();\n@@ -6791,6 +6796,7 @@ driver::main (int argc, char **argv)\n   set_up_specs ();\n   putenv_COLLECT_GCC (argv[0]);\n   maybe_putenv_COLLECT_LTO_WRAPPER ();\n+  maybe_putenv_OFFLOAD_TARGETS ();\n   handle_unrecognized_options ();\n \n   if (!maybe_print_and_exit ())\n@@ -6960,6 +6966,7 @@ driver::build_multilib_strings () const\n void\n driver::set_up_specs () const\n {\n+  const char *spec_machine_suffix;\n   char *specs_file;\n   size_t i;\n \n@@ -6983,8 +6990,8 @@ driver::set_up_specs () const\n \n   /* Read specs from a file if there is one.  */\n \n-  machine_suffix = concat (spec_machine, dir_separator_str,\n-\t\t\t   spec_version, dir_separator_str, NULL);\n+  machine_suffix = concat (spec_host_machine, dir_separator_str, spec_version,\n+\t\t\t   accel_dir_suffix, dir_separator_str, NULL);\n   just_machine_suffix = concat (spec_machine, dir_separator_str, NULL);\n \n   specs_file = find_a_file (&startfile_prefixes, \"specs\", R_OK, true);\n@@ -6994,13 +7001,18 @@ driver::set_up_specs () const\n   else\n     init_spec ();\n \n-  /* We need to check standard_exec_prefix/just_machine_suffix/specs\n+#ifdef ACCEL_COMPILER\n+  spec_machine_suffix = machine_suffix;\n+#else\n+  spec_machine_suffix = just_machine_suffix;\n+#endif\n+\n+  /* We need to check standard_exec_prefix/spec_machine_suffix/specs\n      for any override of as, ld and libraries.  */\n   specs_file = (char *) alloca (strlen (standard_exec_prefix)\n-\t\t       + strlen (just_machine_suffix) + sizeof (\"specs\"));\n-\n+\t\t       + strlen (spec_machine_suffix) + sizeof (\"specs\"));\n   strcpy (specs_file, standard_exec_prefix);\n-  strcat (specs_file, just_machine_suffix);\n+  strcat (specs_file, spec_machine_suffix);\n   strcat (specs_file, \"specs\");\n   if (access (specs_file, R_OK) == 0)\n     read_specs (specs_file, true, false);\n@@ -7182,8 +7194,9 @@ driver::set_up_specs () const\n \n   /* If we have a GCC_EXEC_PREFIX envvar, modify it for cpp's sake.  */\n   if (gcc_exec_prefix)\n-    gcc_exec_prefix = concat (gcc_exec_prefix, spec_machine, dir_separator_str,\n-\t\t\t      spec_version, dir_separator_str, NULL);\n+    gcc_exec_prefix = concat (gcc_exec_prefix, spec_host_machine,\n+\t\t\t      dir_separator_str, spec_version,\n+\t\t\t      accel_dir_suffix, dir_separator_str, NULL);\n \n   /* Now we have the specs.\n      Set the `valid' bits for switches that match anything in any spec.  */\n@@ -7234,6 +7247,21 @@ driver::maybe_putenv_COLLECT_LTO_WRAPPER () const\n \n }\n \n+/* Set up to remember the names of offload targets.  */\n+\n+void\n+driver::maybe_putenv_OFFLOAD_TARGETS () const\n+{\n+  if (strlen (OFFLOAD_TARGETS) > 0)\n+    {\n+      obstack_grow (&collect_obstack, \"OFFLOAD_TARGET_NAMES=\",\n+\t\t    sizeof (\"OFFLOAD_TARGET_NAMES=\") - 1);\n+      obstack_grow (&collect_obstack, OFFLOAD_TARGETS,\n+\t\t    strlen (OFFLOAD_TARGETS) + 1);\n+      xputenv (XOBFINISH (&collect_obstack, char *));\n+    }\n+}\n+\n /* Reject switches that no pass was interested in.  */\n \n void"}, {"sha": "cbda36bface32e5a4f4283f4f9e4507f7c3e6686", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc8b3540d23168b5a35988b35336ba70c4174091/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc8b3540d23168b5a35988b35336ba70c4174091/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=fc8b3540d23168b5a35988b35336ba70c4174091", "patch": "@@ -49,6 +49,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"lto-section-names.h\"\n #include \"collect-utils.h\"\n \n+/* Environment variable, used for passing the names of offload targets from GCC\n+   driver to lto-wrapper.  */\n+#define OFFLOAD_TARGET_NAMES_ENV\t\"OFFLOAD_TARGET_NAMES\"\n+\n enum lto_mode_d {\n   LTO_MODE_NONE,\t\t\t/* Not doing LTO.  */\n   LTO_MODE_LTO,\t\t\t\t/* Normal LTO.  */\n@@ -63,6 +67,8 @@ static char *flto_out;\n static unsigned int nr;\n static char **input_names;\n static char **output_names;\n+static char **offload_names;\n+static const char *offloadbegin, *offloadend;\n static char *makefile;\n \n const char tool_name[] = \"lto-wrapper\";\n@@ -364,6 +370,223 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n     }\n }\n \n+/* Auxiliary function that frees elements of PTR and PTR itself.\n+   N is number of elements to be freed.  If PTR is NULL, nothing is freed.\n+   If an element is NULL, subsequent elements are not freed.  */\n+\n+static void **\n+free_array_of_ptrs (void **ptr, unsigned n)\n+{\n+  if (!ptr)\n+    return NULL;\n+  for (unsigned i = 0; i < n; i++)\n+    {\n+      if (!ptr[i])\n+\tbreak;\n+      free (ptr[i]);\n+    }\n+  free (ptr);\n+  return NULL;\n+}\n+\n+/* Parse STR, saving found tokens into PVALUES and return their number.\n+   Tokens are assumed to be delimited by ':'.  If APPEND is non-null,\n+   append it to every token we find.  */\n+\n+static unsigned\n+parse_env_var (const char *str, char ***pvalues, const char *append)\n+{\n+  const char *curval, *nextval;\n+  char **values;\n+  unsigned num = 1, i;\n+\n+  curval = strchr (str, ':');\n+  while (curval)\n+    {\n+      num++;\n+      curval = strchr (curval + 1, ':');\n+    }\n+\n+  values = (char**) xmalloc (num * sizeof (char*));\n+  curval = str;\n+  nextval = strchrnul (curval, ':');\n+\n+  int append_len = append ? strlen (append) : 0;\n+  for (i = 0; i < num; i++)\n+    {\n+      int l = nextval - curval;\n+      values[i] = (char*) xmalloc (l + 1 + append_len);\n+      memcpy (values[i], curval, l);\n+      values[i][l] = 0;\n+      if (append)\n+\tstrcat (values[i], append);\n+      curval = nextval + 1;\n+      nextval = strchrnul (curval, ':');\n+    }\n+  *pvalues = values;\n+  return num;\n+}\n+\n+/* Check whether NAME can be accessed in MODE.  This is like access,\n+   except that it never considers directories to be executable.  */\n+\n+static int\n+access_check (const char *name, int mode)\n+{\n+  if (mode == X_OK)\n+    {\n+      struct stat st;\n+\n+      if (stat (name, &st) < 0\n+\t  || S_ISDIR (st.st_mode))\n+\treturn -1;\n+    }\n+\n+  return access (name, mode);\n+}\n+\n+/* Prepare a target image for offload TARGET, using mkoffload tool from\n+   COMPILER_PATH.  Return the name of the resultant object file.  */\n+\n+static char *\n+compile_offload_image (const char *target, const char *compiler_path,\n+\t\t       unsigned in_argc, char *in_argv[])\n+{\n+  char *filename = NULL;\n+  char **argv;\n+  char *suffix\n+    = XALLOCAVEC (char, sizeof (\"/accel//mkoffload\") + strlen (target));\n+  strcpy (suffix, \"/accel/\");\n+  strcat (suffix, target);\n+  strcat (suffix, \"/mkoffload\");\n+\n+  char **paths = NULL;\n+  unsigned n_paths = parse_env_var (compiler_path, &paths, suffix);\n+\n+  const char *compiler = NULL;\n+  for (unsigned i = 0; i < n_paths; i++)\n+    if (access_check (paths[i], X_OK) == 0)\n+      {\n+\tcompiler = paths[i];\n+\tbreak;\n+      }\n+\n+  if (compiler)\n+    {\n+      /* Generate temporary output file name.  */\n+      filename = make_temp_file (\".target.o\");\n+\n+      struct obstack argv_obstack;\n+      obstack_init (&argv_obstack);\n+      obstack_ptr_grow (&argv_obstack, compiler);\n+      obstack_ptr_grow (&argv_obstack, \"-o\");\n+      obstack_ptr_grow (&argv_obstack, filename);\n+\n+      for (unsigned i = 1; i < in_argc; i++)\n+\tobstack_ptr_grow (&argv_obstack, in_argv[i]);\n+      obstack_ptr_grow (&argv_obstack, NULL);\n+\n+      argv = XOBFINISH (&argv_obstack, char **);\n+      fork_execute (argv[0], argv, true);\n+      obstack_free (&argv_obstack, NULL);\n+    }\n+\n+  free_array_of_ptrs ((void **) paths, n_paths);\n+  return filename;\n+}\n+\n+\n+/* The main routine dealing with offloading.\n+   The routine builds a target image for each offload target.  IN_ARGC and\n+   IN_ARGV specify options and input object files.  As all of them could contain\n+   target sections, we pass them all to target compilers.  */\n+\n+static void\n+compile_images_for_offload_targets (unsigned in_argc, char *in_argv[])\n+{\n+  char **names = NULL;\n+  const char *target_names = getenv (OFFLOAD_TARGET_NAMES_ENV);\n+  if (!target_names)\n+    return;\n+  unsigned num_targets = parse_env_var (target_names, &names, NULL);\n+\n+  const char *compiler_path = getenv (\"COMPILER_PATH\");\n+  if (!compiler_path)\n+    goto out;\n+\n+  /* Prepare an image for each target and save the name of the resultant object\n+     file to the OFFLOAD_NAMES array.  It is terminated by a NULL entry.  */\n+  offload_names = XCNEWVEC (char *, num_targets + 1);\n+  for (unsigned i = 0; i < num_targets; i++)\n+    {\n+      offload_names[i] = compile_offload_image (names[i], compiler_path,\n+\t\t\t\t\t\tin_argc, in_argv);\n+      if (!offload_names[i])\n+\tfatal_error (\"problem with building target image for %s\\n\", names[i]);\n+    }\n+\n+ out:\n+  free_array_of_ptrs ((void **) names, num_targets);\n+}\n+\n+/* Copy a file from SRC to DEST.  */\n+\n+static void\n+copy_file (const char *dest, const char *src)\n+{\n+  FILE *d = fopen (dest, \"wb\");\n+  FILE *s = fopen (src, \"rb\");\n+  char buffer[512];\n+  while (!feof (s))\n+    {\n+      size_t len = fread (buffer, 1, 512, s);\n+      if (ferror (s) != 0)\n+\tfatal_error (\"reading input file\");\n+      if (len > 0)\n+\t{\n+\t  fwrite (buffer, 1, len, d);\n+\t  if (ferror (d) != 0)\n+\t    fatal_error (\"writing output file\");\n+\t}\n+    }\n+}\n+\n+/* Find the crtoffloadbegin.o and crtoffloadend.o files in LIBRARY_PATH, make\n+   copies and store the names of the copies in offloadbegin and offloadend.  */\n+\n+static void\n+find_offloadbeginend (void)\n+{\n+  char **paths = NULL;\n+  const char *library_path = getenv (\"LIBRARY_PATH\");\n+  if (!library_path)\n+    return;\n+  unsigned n_paths = parse_env_var (library_path, &paths, \"/crtoffloadbegin.o\");\n+\n+  unsigned i;\n+  for (i = 0; i < n_paths; i++)\n+    if (access_check (paths[i], R_OK) == 0)\n+      {\n+\tsize_t len = strlen (paths[i]);\n+\tchar *tmp = xstrdup (paths[i]);\n+\tstrcpy (paths[i] + len - strlen (\"begin.o\"), \"end.o\");\n+\tif (access_check (paths[i], R_OK) != 0)\n+\t  fatal_error (\"installation error, can't find crtoffloadend.o\");\n+\t/* The linker will delete the filenames we give it, so make\n+\t   copies.  */\n+\toffloadbegin = make_temp_file (\".o\");\n+\toffloadend = make_temp_file (\".o\");\n+\tcopy_file (offloadbegin, tmp);\n+\tcopy_file (offloadend, paths[i]);\n+\tfree (tmp);\n+\tbreak;\n+      }\n+  if (i == n_paths)\n+    fatal_error (\"installation error, can't find crtoffloadbegin.o\");\n+\n+  free_array_of_ptrs ((void **) paths, n_paths);\n+}\n+\n /* Execute gcc. ARGC is the number of arguments. ARGV contains the arguments. */\n \n static void\n@@ -384,6 +607,8 @@ run_gcc (unsigned argc, char *argv[])\n   unsigned int decoded_options_count;\n   struct obstack argv_obstack;\n   int new_head_argc;\n+  bool have_lto = false;\n+  bool have_offload = false;\n \n   /* Get the driver and options.  */\n   collect_gcc = getenv (\"COLLECT_GCC\");\n@@ -432,13 +657,17 @@ run_gcc (unsigned argc, char *argv[])\n \t  close (fd);\n \t  continue;\n \t}\n+      if (simple_object_find_section (sobj, OFFLOAD_SECTION_NAME_PREFIX \".opts\",\n+\t\t\t\t      &offset, &length, &errmsg, &err))\n+\thave_offload = true;\n       if (!simple_object_find_section (sobj, LTO_SECTION_NAME_PREFIX \".\" \"opts\",\n \t\t\t\t       &offset, &length, &errmsg, &err))\n \t{\n \t  simple_object_release_read (sobj);\n \t  close (fd);\n \t  continue;\n \t}\n+      have_lto = true;\n       lseek (fd, file_offset + offset, SEEK_SET);\n       data = (char *)xmalloc (length);\n       read (fd, data, length);\n@@ -633,6 +862,43 @@ run_gcc (unsigned argc, char *argv[])\n   /* Remember at which point we can scrub args to re-use the commons.  */\n   new_head_argc = obstack_object_size (&argv_obstack) / sizeof (void *);\n \n+  if (have_offload)\n+    {\n+      compile_images_for_offload_targets (argc, argv);\n+      if (offload_names)\n+\t{\n+\t  find_offloadbeginend ();\n+\t  for (i = 0; offload_names[i]; i++)\n+\t    printf (\"%s\\n\", offload_names[i]);\n+\t  free_array_of_ptrs ((void **) offload_names, i);\n+\t}\n+    }\n+\n+  if (offloadbegin)\n+    printf (\"%s\\n\", offloadbegin);\n+\n+  /* If object files contain offload sections, but do not contain LTO sections,\n+     then there is no need to perform a link-time recompilation, i.e.\n+     lto-wrapper is used only for a compilation of offload images.  */\n+  if (have_offload && !have_lto)\n+    {\n+      for (i = 1; i < argc; ++i)\n+\tif (strncmp (argv[i], \"-fresolution=\", sizeof (\"-fresolution=\") - 1))\n+\t  {\n+\t    char *out_file;\n+\t    /* Can be \".o\" or \".so\".  */\n+\t    char *ext = strrchr (argv[i], '.');\n+\t    if (ext == NULL)\n+\t      out_file = make_temp_file (\"\");\n+\t    else\n+\t      out_file = make_temp_file (ext);\n+\t    /* The linker will delete the files we give it, so make copies.  */\n+\t    copy_file (out_file, argv[i]);\n+\t    printf (\"%s\\n\", out_file);\n+\t  }\n+      goto finish;\n+    }\n+\n   if (lto_mode == LTO_MODE_LTO)\n     {\n       flto_out = make_temp_file (\".lto.o\");\n@@ -859,6 +1125,10 @@ run_gcc (unsigned argc, char *argv[])\n       obstack_free (&env_obstack, NULL);\n     }\n \n+ finish:\n+  if (offloadend)\n+    printf (\"%s\\n\", offloadend);\n+\n   obstack_free (&argv_obstack, NULL);\n }\n "}, {"sha": "69af7814e6f1f9c182bf467d7548a5942b029120", "filename": "lto-plugin/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc8b3540d23168b5a35988b35336ba70c4174091/lto-plugin%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc8b3540d23168b5a35988b35336ba70c4174091/lto-plugin%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2FChangeLog?ref=fc8b3540d23168b5a35988b35336ba70c4174091", "patch": "@@ -1,3 +1,13 @@\n+2014-11-13  Ilya Verbin  <ilya.verbin@intel.com>\n+\t    Bernd Schmidt  <bernds@codesourcery.com>\n+\t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n+\t    Michael Zolotukhin  <michael.v.zolotukhin@intel.com>\n+\n+\t* lto-plugin.c (OFFLOAD_SECTION, OFFLOAD_SECTION_LEN): Define.\n+\t(struct plugin_objfile): Add new field \"offload\".\n+\t(process_offload_section): New static function.\n+\t(claim_file_handler): Claim file if it contains offload sections.\n+\n 2014-11-13  Bernd Schmidt  <bernds@codesourcery.com>\n \t    Thomas Schwinge  <thomas@codesourcery.com>\n \t    Ilya Verbin  <ilya.verbin@intel.com>"}, {"sha": "fb6555daf9118046d9dbd553101f3e87c290f2f0", "filename": "lto-plugin/lto-plugin.c", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc8b3540d23168b5a35988b35336ba70c4174091/lto-plugin%2Flto-plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc8b3540d23168b5a35988b35336ba70c4174091/lto-plugin%2Flto-plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/lto-plugin%2Flto-plugin.c?ref=fc8b3540d23168b5a35988b35336ba70c4174091", "patch": "@@ -86,6 +86,8 @@ along with this program; see the file COPYING3.  If not see\n \n #define LTO_SECTION_PREFIX\t\".gnu.lto_.symtab\"\n #define LTO_SECTION_PREFIX_LEN\t(sizeof (LTO_SECTION_PREFIX) - 1)\n+#define OFFLOAD_SECTION\t\t\".gnu.offload_lto_.opts\"\n+#define OFFLOAD_SECTION_LEN\t(sizeof (OFFLOAD_SECTION) - 1)\n \n /* The part of the symbol table the plugin has to keep track of. Note that we\n    must keep SYMS until all_symbols_read is called to give the linker time to\n@@ -111,6 +113,7 @@ struct plugin_symtab\n struct plugin_objfile\n {\n   int found;\n+  int offload;\n   simple_object_read *objfile;\n   struct plugin_symtab *out;\n   const struct ld_plugin_input_file *file;\n@@ -862,6 +865,21 @@ process_symtab (void *data, const char *name, off_t offset, off_t length)\n   return 0;\n }\n \n+/* Find an offload section of an object file.  */\n+\n+static int\n+process_offload_section (void *data, const char *name, off_t offset, off_t len)\n+{\n+  if (!strncmp (name, OFFLOAD_SECTION, OFFLOAD_SECTION_LEN))\n+    {\n+      struct plugin_objfile *obj = (struct plugin_objfile *) data;\n+      obj->offload = 1;\n+      return 0;\n+    }\n+\n+  return 1;\n+}\n+\n /* Callback used by gold to check if the plugin will claim FILE. Writes\n    the result in CLAIMED. */\n \n@@ -899,6 +917,7 @@ claim_file_handler (const struct ld_plugin_input_file *file, int *claimed)\n   *claimed = 0;\n   obj.file = file;\n   obj.found = 0;\n+  obj.offload = 0;\n   obj.out = &lto_file.symtab;\n   errmsg = NULL;\n   obj.objfile = simple_object_start_read (file->fd, file->offset, LTO_SEGMENT_NAME,\n@@ -920,7 +939,11 @@ claim_file_handler (const struct ld_plugin_input_file *file, int *claimed)\n       goto err;\n     }\n \n-  if (obj.found == 0)\n+  if (obj.objfile)\n+    simple_object_find_sections (obj.objfile, process_offload_section,\n+\t\t\t\t &obj, &err);\n+\n+  if (obj.found == 0 && obj.offload == 0)\n     goto err;\n \n   if (obj.found > 1)"}]}