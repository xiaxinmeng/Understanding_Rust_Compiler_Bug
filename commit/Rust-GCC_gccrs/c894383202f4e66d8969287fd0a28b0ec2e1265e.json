{"sha": "c894383202f4e66d8969287fd0a28b0ec2e1265e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg5NDM4MzIwMmY0ZTY2ZDg5NjkyODdmZDBhMjhiMGVjMmUxMjY1ZQ==", "commit": {"author": {"name": "Vladimir Yanovsky", "email": "yanov@il.ibm.com", "date": "2007-09-03T11:50:45Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2007-09-03T11:50:45Z"}, "message": "Change SMS behavior upon failure\n\nCo-Authored-By: Ayal Zaks <zaks@il.ibm.com>\nCo-Authored-By: Revital Eres <eres@il.ibm.com>\n\nFrom-SVN: r128040", "tree": {"sha": "5ad08ade11709012e9a06b72a46d4cc68126cc59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ad08ade11709012e9a06b72a46d4cc68126cc59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c894383202f4e66d8969287fd0a28b0ec2e1265e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c894383202f4e66d8969287fd0a28b0ec2e1265e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c894383202f4e66d8969287fd0a28b0ec2e1265e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c894383202f4e66d8969287fd0a28b0ec2e1265e/comments", "author": null, "committer": null, "parents": [{"sha": "d4d96a5aef412d51447c9e3632c18c6107b9315c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4d96a5aef412d51447c9e3632c18c6107b9315c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4d96a5aef412d51447c9e3632c18c6107b9315c"}], "stats": {"total": 501, "additions": 370, "deletions": 131}, "files": [{"sha": "671c1f891c6ca333199be471f13e1282591a8704", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c894383202f4e66d8969287fd0a28b0ec2e1265e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c894383202f4e66d8969287fd0a28b0ec2e1265e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c894383202f4e66d8969287fd0a28b0ec2e1265e", "patch": "@@ -1,3 +1,17 @@\n+2007-09-03  Vladimir Yanovsky  <yanov@il.ibm.com>\n+            Ayal Zaks  <zaks@il.ibm.com>\n+            Revital Eres  <eres@il.ibm.com>\n+\n+\t* modulo-sched.c (ps_insert_empty_row, verify_partial_schedule,\n+\tcompute_split_row): New functions.\n+\t(ps_unschedule_node): Remove.\n+\t(normalize_sched_times): Iterate over the already scheduled\n+\tinsns instead of the number of nodes.\n+\t(MAX_SPLIT_NUM): New definition.\n+\t(sms_schedule_by_order): Change the scheduling heuristic to\n+\tavoid useless increases of initiation interval ii.\n+\t(get_sched_window): Add dump printouts.\n+\n 2007-09-02  David Daney  <ddaney@avtrex.com>\n \n \t* config/mips/mips.md (UNSPEC_COMPARE_AND_SWAP, UNSPEC_SYNC_OLD_OP,"}, {"sha": "bb940a72a2bb6565e48379f980401d7fe7423fc4", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 356, "deletions": 131, "changes": 487, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c894383202f4e66d8969287fd0a28b0ec2e1265e/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c894383202f4e66d8969287fd0a28b0ec2e1265e/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=c894383202f4e66d8969287fd0a28b0ec2e1265e", "patch": "@@ -172,13 +172,15 @@ static partial_schedule_ptr create_partial_schedule (int ii, ddg_ptr, int histor\n static void free_partial_schedule (partial_schedule_ptr);\n static void reset_partial_schedule (partial_schedule_ptr, int new_ii);\n void print_partial_schedule (partial_schedule_ptr, FILE *);\n+static void verify_partial_schedule (partial_schedule_ptr, sbitmap);\n static ps_insn_ptr ps_add_node_check_conflicts (partial_schedule_ptr,\n \t\t\t\t\t\tddg_node_ptr node, int cycle,\n \t\t\t\t\t\tsbitmap must_precede,\n \t\t\t\t\t\tsbitmap must_follow);\n static void rotate_partial_schedule (partial_schedule_ptr, int);\n void set_row_column_for_ps (partial_schedule_ptr);\n-static bool ps_unschedule_node (partial_schedule_ptr, ddg_node_ptr );\n+static void ps_insert_empty_row (partial_schedule_ptr, int, sbitmap);\n+static int compute_split_row (sbitmap, int, int, int, ddg_node_ptr);\n \n \f\n /* This page defines constants and structures for the modulo scheduling\n@@ -568,23 +570,27 @@ free_undo_replace_buff (struct undo_replace_buff_elem *reg_move_replaces)\n static void\n normalize_sched_times (partial_schedule_ptr ps)\n {\n-  int i;\n-  ddg_ptr g = ps->g;\n+  int row;\n   int amount = PS_MIN_CYCLE (ps);\n   int ii = ps->ii;\n+  ps_insn_ptr crr_insn;\n \n-  /* Don't include the closing branch assuming that it is the last node.  */\n-  for (i = 0; i < g->num_nodes - 1; i++)\n-    {\n-      ddg_node_ptr u = &g->nodes[i];\n-      int normalized_time = SCHED_TIME (u) - amount;\n-\n-      gcc_assert (normalized_time >= 0);\n-\n-      SCHED_TIME (u) = normalized_time;\n-      SCHED_ROW (u) = normalized_time % ii;\n-      SCHED_STAGE (u) = normalized_time / ii;\n-    }\n+  for (row = 0; row < ii; row++)\n+    for (crr_insn = ps->rows[row]; crr_insn; crr_insn = crr_insn->next_in_row)\n+      {\n+\tddg_node_ptr u = crr_insn->node;\n+\tint normalized_time = SCHED_TIME (u) - amount;\n+\n+\tif (dump_file)\n+\t  fprintf (dump_file, \"crr_insn->node=%d, crr_insn->cycle=%d,\\\n+\t\t   min_cycle=%d\\n\", crr_insn->node->cuid, SCHED_TIME\n+\t\t   (u), ps->min_cycle);\n+\tgcc_assert (SCHED_TIME (u) >= ps->min_cycle);\n+\tgcc_assert (SCHED_TIME (u) <= ps->max_cycle);\n+\tSCHED_TIME (u) = normalized_time;\n+\tSCHED_ROW (u) = normalized_time % ii;\n+\tSCHED_STAGE (u) = normalized_time / ii;\n+      }\n }\n \n /* Set SCHED_COLUMN of each node according to its position in PS.  */\n@@ -1277,6 +1283,9 @@ sms_schedule (void)\n    set to 0 to save compile time.  */\n #define DFA_HISTORY SMS_DFA_HISTORY\n \n+/* A threshold for the number of repeated unsuccessful attempts to insert\n+   an empty row, before we flush the partial schedule and start over.  */\n+#define MAX_SPLIT_NUM 10\n /* Given the partial schedule PS, this function calculates and returns the\n    cycles in which we can schedule the node with the given index I.\n    NOTE: Here we do the backtracking in SMS, in some special cases. We have\n@@ -1315,6 +1324,18 @@ get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n       for (e = u_node->in; e != 0; e = e->next_in)\n \t{\n \t  ddg_node_ptr v_node = e->src;\n+\n+          if (dump_file)\n+            {     \n+\t      fprintf (dump_file, \"\\nProcessing edge: \");\n+              print_ddg_edge (dump_file, e);\n+\t      fprintf (dump_file,\n+\t\t       \"\\nScheduling %d (%d) in psp_not_empty,\"\n+\t\t       \" checking node %d (%d): \", u_node->cuid,\n+\t\t       INSN_UID (u_node->insn), v_node->cuid, INSN_UID\n+\t\t       (v_node->insn));\n+            }\n+\n \t  if (TEST_BIT (sched_nodes, v_node->cuid))\n \t    {\n \t      int node_st = SCHED_TIME (v_node)\n@@ -1329,6 +1350,11 @@ get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n       start = early_start;\n       end = MIN (end, early_start + ii);\n       step = 1;\n+\n+      if (dump_file)\n+        fprintf (dump_file,\n+\t\t \"\\nScheduling %d (%d) in a window (%d..%d) with step %d\\n\",\n+\t\t u_node->cuid, INSN_UID (u_node->insn), start, end, step);\n     }\n \n   else if (!psp_not_empty && pss_not_empty)\n@@ -1339,18 +1365,45 @@ get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n       for (e = u_node->out; e != 0; e = e->next_out)\n \t{\n \t  ddg_node_ptr v_node = e->dest;\n+\n+          if (dump_file)\n+            {\n+              fprintf (dump_file, \"\\nProcessing edge:\");\n+              print_ddg_edge (dump_file, e);\n+              fprintf (dump_file,\n+                       \"\\nScheduling %d (%d) in pss_not_empty,\"\n+                       \" checking node %d (%d): \", u_node->cuid,\n+                       INSN_UID (u_node->insn), v_node->cuid, INSN_UID\n+                       (v_node->insn));\n+            }\n+\n \t  if (TEST_BIT (sched_nodes, v_node->cuid))\n \t    {\n \t      late_start = MIN (late_start,\n \t\t\t\tSCHED_TIME (v_node) - e->latency\n \t\t\t\t+ (e->distance * ii));\n+               if (dump_file)\n+                 fprintf (dump_file, \"late_start = %d;\", late_start);\n+\n \t      if (e->data_type == MEM_DEP)\n \t\tend = MAX (end, SCHED_TIME (v_node) - ii + 1);\n+             if (dump_file)\n+                 fprintf (dump_file, \"end = %d\\n\", end);\n+\n \t    }\n+          else if (dump_file)\n+            fprintf (dump_file, \"the node is not scheduled\\n\");\n+\n \t}\n       start = late_start;\n       end = MAX (end, late_start - ii);\n       step = -1;\n+\n+      if (dump_file)\n+        fprintf (dump_file,\n+                 \"\\nScheduling %d (%d) in a window (%d..%d) with step %d\\n\",\n+                 u_node->cuid, INSN_UID (u_node->insn), start, end, step);\n+\n     }\n \n   else if (psp_not_empty && pss_not_empty)\n@@ -1364,6 +1417,17 @@ get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n \t{\n \t  ddg_node_ptr v_node = e->src;\n \n+\t  if (dump_file)\n+\t    {\n+              fprintf (dump_file, \"\\nProcessing edge:\");\n+              print_ddg_edge (dump_file, e);\n+\t      fprintf (dump_file,\n+\t\t       \"\\nScheduling %d (%d) in psp_pss_not_empty,\"\n+\t\t       \" checking p %d (%d): \", u_node->cuid, INSN_UID\n+\t\t       (u_node->insn), v_node->cuid, INSN_UID\n+\t\t       (v_node->insn));\n+\t    }\n+\n \t  if (TEST_BIT (sched_nodes, v_node->cuid))\n \t    {\n \t      early_start = MAX (early_start,\n@@ -1377,6 +1441,17 @@ get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n \t{\n \t  ddg_node_ptr v_node = e->dest;\n \n+\t  if (dump_file)\n+\t    {\n+              fprintf (dump_file, \"\\nProcessing edge:\");\n+              print_ddg_edge (dump_file, e);\n+\t      fprintf (dump_file,\n+\t\t       \"\\nScheduling %d (%d) in psp_pss_not_empty,\"\n+\t\t       \" checking s %d (%d): \", u_node->cuid, INSN_UID\n+\t\t       (u_node->insn), v_node->cuid, INSN_UID\n+\t\t       (v_node->insn));\n+\t    }\n+\n \t  if (TEST_BIT (sched_nodes, v_node->cuid))\n \t    {\n \t      late_start = MIN (late_start,\n@@ -1404,8 +1479,13 @@ get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n   sbitmap_free (pss);\n \n   if ((start >= end && step == 1) || (start <= end && step == -1))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\nEmpty window: start=%d, end=%d, step=%d\\n\",\n+\t\t start, end, step);\n     return -1;\n-  else\n+    }\n+\n     return 0;\n }\n \n@@ -1415,10 +1495,11 @@ static partial_schedule_ptr\n sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n {\n   int ii = mii;\n-  int i, c, success;\n-  int try_again_with_larger_ii = true;\n+  int i, c, success, num_splits = 0;\n+  int flush_and_start_over = true;\n   int num_nodes = g->num_nodes;\n   ddg_edge_ptr e;\n+  ps_insn_ptr psi;\n   int start, end, step; /* Place together into one struct?  */\n   sbitmap sched_nodes = sbitmap_alloc (num_nodes);\n   sbitmap must_precede = sbitmap_alloc (num_nodes);\n@@ -1430,19 +1511,13 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n   sbitmap_ones (tobe_scheduled);\n   sbitmap_zero (sched_nodes);\n \n-  while ((! sbitmap_equal (tobe_scheduled, sched_nodes)\n-\t || try_again_with_larger_ii ) && ii < maxii)\n+  while (flush_and_start_over && (ii < maxii))\n     {\n-      int j;\n-      bool unscheduled_nodes = false;\n \n       if (dump_file)\n \tfprintf (dump_file, \"Starting with ii=%d\\n\", ii);\n-      if (try_again_with_larger_ii)\n-\t{\n-\t  try_again_with_larger_ii = false;\n-\t  sbitmap_zero (sched_nodes);\n-\t}\n+      flush_and_start_over = false;\n+      sbitmap_zero (sched_nodes);\n \n       for (i = 0; i < num_nodes; i++)\n \t{\n@@ -1466,101 +1541,271 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n \t    continue;\n \n \t  /* Try to get non-empty scheduling window.  */\n-\t  j = i;\n-\t  while (get_sched_window (ps, nodes_order, i, sched_nodes, ii, &start, &step, &end) < 0\n-\t\t && j > 0)\n-\t    {\n-\t      unscheduled_nodes = true;\n-\t      if (TEST_BIT (NODE_PREDECESSORS (u_node), nodes_order[j - 1])\n-\t\t  || TEST_BIT (NODE_SUCCESSORS (u_node), nodes_order[j - 1]))\n-\t\t{\n-\t\t  ps_unschedule_node (ps, &ps->g->nodes[nodes_order[j - 1]]);\n-\t\t  RESET_BIT (sched_nodes, nodes_order [j - 1]);\n-\t\t}\n-\t      j--;\n-\t    }\n-\t  if (j < 0)\n-\t    {\n-\t      /* ??? Try backtracking instead of immediately ii++?  */\n-\t      ii++;\n-\t      try_again_with_larger_ii = true;\n-\t      reset_partial_schedule (ps, ii);\n-\t      break;\n-\t    }\n-\t  /* 2. Try scheduling u in window.  */\n-\t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \"Trying to schedule node %d in (%d .. %d) step %d\\n\",\n-\t\t     u, start, end, step);\n-\n-          /* use must_follow & must_precede bitmaps to determine order\n-\t     of nodes within the cycle.  */\n-          sbitmap_zero (must_precede);\n-          sbitmap_zero (must_follow);\n-          /* TODO: We can add an insn to the must_precede or must_follow\n-             bitmaps only if it has tight dependence to U and they\n-             both scheduled in the same row.  The current check is less\n-             conservative and content with the fact that both U and the\n-             insn are scheduled in the same row.  */\n-          for (e = u_node->in; e != 0; e = e->next_in)\n-            if (TEST_BIT (sched_nodes, e->src->cuid)\n-                && (SMODULO (SCHED_TIME (e->src), ii) == SMODULO (start, ii)))\n-              SET_BIT (must_precede, e->src->cuid);\n-\n-          for (e = u_node->out; e != 0; e = e->next_out)\n-            if (TEST_BIT (sched_nodes, e->dest->cuid)\n-                && (SMODULO (SCHED_TIME (e->dest), ii) ==\n-                    SMODULO ((end - step), ii)))\n-              SET_BIT (must_follow, e->dest->cuid);\n-\n-\t  success = 0;\n-\t  if ((step > 0 && start < end) ||  (step < 0 && start > end))\n-\t    for (c = start; c != end; c += step)\n-\t      {\n-\t\tps_insn_ptr psi;\n-\n-\t\tpsi = ps_add_node_check_conflicts (ps, u_node, c,\n-\t\t\t\t\t\t   must_precede,\n-\t\t\t\t\t\t   must_follow);\n-\n-  \t\tif (psi)\n-\t\t  {\n-\t\t    SCHED_TIME (u_node) = c;\n-\t\t    SET_BIT (sched_nodes, u);\n-\t\t    success = 1;\n-\t\t    if (dump_file)\n-\t\t      fprintf (dump_file, \"Schedule in %d\\n\", c);\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t  if (!success)\n-\t    {\n-\t      /* ??? Try backtracking instead of immediately ii++?  */\n-\t      ii++;\n-\t      try_again_with_larger_ii = true;\n-\t      reset_partial_schedule (ps, ii);\n-\t      break;\n-\t    }\n-\t  if (unscheduled_nodes)\n-\t    break;\n+\t success = 0;\n+         if (get_sched_window (ps, nodes_order, i, sched_nodes, ii, &start,\n+                                &step, &end) == 0)\n+            {\n+              if (dump_file)\n+                fprintf (dump_file, \"\\nTrying to schedule node %d \\\n+                        INSN = %d  in (%d .. %d) step %d\\n\", u, (INSN_UID\n+                        (g->nodes[u].insn)), start, end, step);\n+              /* Use must_follow & must_precede bitmaps to determine order\n+                 of nodes within the cycle.  */\n+\n+              /* use must_follow & must_precede bitmaps to determine order\n+                 of nodes within the cycle.  */\n+              sbitmap_zero (must_precede);\n+              sbitmap_zero (must_follow);\n+              /* TODO: We can add an insn to the must_precede or must_follow\n+                 bitmaps only if it has tight dependence to U and they\n+                 both scheduled in the same row.  The current check is less\n+                 conservative and content with the fact that both U and the\n+                 insn are scheduled in the same row.  */\n+              for (e = u_node->in; e != 0; e = e->next_in)\n+                if (TEST_BIT (sched_nodes, e->src->cuid)\n+                    && (SMODULO (SCHED_TIME (e->src), ii) ==\n+                        SMODULO (start, ii)))\n+                  SET_BIT (must_precede, e->src->cuid);\n+\n+              for (e = u_node->out; e != 0; e = e->next_out)\n+                if (TEST_BIT (sched_nodes, e->dest->cuid)\n+                    && (SMODULO (SCHED_TIME (e->dest), ii) ==\n+                        SMODULO ((end - step), ii)))\n+                  SET_BIT (must_follow, e->dest->cuid);\n+\n+              gcc_assert ((step > 0 && start < end)\n+                          || (step < 0 && start > end));\n+\n+              for (c = start; c != end; c += step)\n+                {\n+                  verify_partial_schedule (ps, sched_nodes);\n+\n+                  psi = ps_add_node_check_conflicts (ps, u_node, c,\n+                                                     must_precede,\n+                                                     must_follow);\n+\n+                  if (psi)\n+                    {\n+                      SCHED_TIME (u_node) = c;\n+                      SET_BIT (sched_nodes, u);\n+                      success = 1;\n+                      num_splits = 0;\n+                      if (dump_file)\n+                        fprintf (dump_file, \"Scheduled w/o split in %d\\n\", c);\n+\n+                      break;\n+                    }\n+                }\n+              verify_partial_schedule (ps, sched_nodes);\n+            }\n+            if (!success)\n+            {\n+              int split_row;\n+\n+              if (ii++ == maxii)\n+                break;\n+\n+              if (num_splits >= MAX_SPLIT_NUM)\n+                {\n+                  num_splits = 0;\n+                  flush_and_start_over = true;\n+                  verify_partial_schedule (ps, sched_nodes);\n+                  reset_partial_schedule (ps, ii);\n+                  verify_partial_schedule (ps, sched_nodes);\n+                  break;\n+                }\n+\n+              num_splits++;\n+              if (step == 1)\n+                split_row = compute_split_row (sched_nodes, start, end,\n+                                               ps->ii, u_node);\n+              else\n+                split_row = compute_split_row (sched_nodes, end, start,\n+                                               ps->ii, u_node);\n \n-\t  /* ??? If (success), check register pressure estimates.  */\n-\t} /* Continue with next node.  */\n-    } /* While try_again_with_larger_ii.  */\n+              ps_insert_empty_row (ps, split_row, sched_nodes);\n+              i--;              /* Go back and retry node i.  */\n \n-  sbitmap_free (sched_nodes);\n-  sbitmap_free (must_precede);\n-  sbitmap_free (must_follow);\n-  sbitmap_free (tobe_scheduled);\n+              if (dump_file)\n+                fprintf (dump_file, \"num_splits=%d\\n\", num_splits);\n+            }\n \n+          /* ??? If (success), check register pressure estimates.  */\n+        }                       /* Continue with next node.  */\n+    }                           /* While flush_and_start_over.  */\n   if (ii >= maxii)\n     {\n       free_partial_schedule (ps);\n       ps = NULL;\n     }\n+  else\n+    gcc_assert (sbitmap_equal (tobe_scheduled, sched_nodes));\n+\n+  sbitmap_free (sched_nodes);\n+  sbitmap_free (must_precede);\n+  sbitmap_free (must_follow);\n+  sbitmap_free (tobe_scheduled);\n+\n   return ps;\n }\n \n+/* This function inserts a new empty row into PS at the position\n+   according to SPLITROW, keeping all already scheduled instructions\n+   intact and updating their SCHED_TIME and cycle accordingly.  */\n+static void\n+ps_insert_empty_row (partial_schedule_ptr ps, int split_row,\n+\t\t     sbitmap sched_nodes)\n+{\n+  ps_insn_ptr crr_insn;\n+  ps_insn_ptr *rows_new;\n+  int ii = ps->ii;\n+  int new_ii = ii + 1;\n+  int row;\n+\n+  verify_partial_schedule (ps, sched_nodes);\n+\n+  /* We normalize sched_time and rotate ps to have only non-negative sched\n+     times, for simplicity of updating cycles after inserting new row.  */\n+  split_row -= ps->min_cycle;\n+  split_row = SMODULO (split_row, ii);\n+  if (dump_file)\n+    fprintf (dump_file, \"split_row=%d\\n\", split_row);\n+\n+  normalize_sched_times (ps);\n+  rotate_partial_schedule (ps, ps->min_cycle);\n+\n+  rows_new = (ps_insn_ptr *) xcalloc (new_ii, sizeof (ps_insn_ptr));\n+  for (row = 0; row < split_row; row++)\n+    {\n+      rows_new[row] = ps->rows[row];\n+      ps->rows[row] = NULL;\n+      for (crr_insn = rows_new[row];\n+\t   crr_insn; crr_insn = crr_insn->next_in_row)\n+\t{\n+\t  ddg_node_ptr u = crr_insn->node;\n+\t  int new_time = SCHED_TIME (u) + (SCHED_TIME (u) / ii);\n+\n+\t  SCHED_TIME (u) = new_time;\n+\t  crr_insn->cycle = new_time;\n+\t  SCHED_ROW (u) = new_time % new_ii;\n+\t  SCHED_STAGE (u) = new_time / new_ii;\n+\t}\n+\n+    }\n+\n+  rows_new[split_row] = NULL;\n+\n+  for (row = split_row; row < ii; row++)\n+    {\n+      rows_new[row + 1] = ps->rows[row];\n+      ps->rows[row] = NULL;\n+      for (crr_insn = rows_new[row + 1];\n+\t   crr_insn; crr_insn = crr_insn->next_in_row)\n+\t{\n+\t  ddg_node_ptr u = crr_insn->node;\n+\t  int new_time = SCHED_TIME (u) + (SCHED_TIME (u) / ii) + 1;\n+\n+\t  SCHED_TIME (u) = new_time;\n+\t  crr_insn->cycle = new_time;\n+\t  SCHED_ROW (u) = new_time % new_ii;\n+\t  SCHED_STAGE (u) = new_time / new_ii;\n+\t}\n+    }\n+\n+  /* Updating ps.  */\n+  ps->min_cycle = ps->min_cycle + ps->min_cycle / ii\n+    + (SMODULO (ps->min_cycle, ii) >= split_row ? 1 : 0);\n+  ps->max_cycle = ps->max_cycle + ps->max_cycle / ii\n+    + (SMODULO (ps->max_cycle, ii) >= split_row ? 1 : 0);\n+  free (ps->rows);\n+  ps->rows = rows_new;\n+  ps->ii = new_ii;\n+  gcc_assert (ps->min_cycle >= 0);\n+\n+  verify_partial_schedule (ps, sched_nodes);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"min_cycle=%d, max_cycle=%d\\n\", ps->min_cycle,\n+\t     ps->max_cycle);\n+}\n+\n+/* Given U_NODE which is the node that failed to be scheduled; LOW and\n+   UP which are the boundaries of it's scheduling window; compute using\n+   SCHED_NODES and II a row in the partial schedule that can be splitted\n+   which will separate a critical predecessor from a critical successor\n+   thereby expanding the window, and return it.  */\n+static int\n+compute_split_row (sbitmap sched_nodes, int low, int up, int ii,\n+\t\t   ddg_node_ptr u_node)\n+{\n+  ddg_edge_ptr e;\n+  int lower = INT_MIN, upper = INT_MAX;\n+  ddg_node_ptr crit_pred = NULL;\n+  ddg_node_ptr crit_succ = NULL;\n+  int crit_cycle;\n+\n+  for (e = u_node->in; e != 0; e = e->next_in)\n+    {\n+      ddg_node_ptr v_node = e->src;\n+\n+      if (TEST_BIT (sched_nodes, v_node->cuid)\n+\t  && (low == SCHED_TIME (v_node) + e->latency - (e->distance * ii)))\n+\tif (SCHED_TIME (v_node) > lower)\n+\t  {\n+\t    crit_pred = v_node;\n+\t    lower = SCHED_TIME (v_node);\n+\t  }\n+    }\n+\n+  if (crit_pred != NULL)\n+    {\n+      crit_cycle = SCHED_TIME (crit_pred) + 1;\n+      return SMODULO (crit_cycle, ii);\n+    }\n+\n+  for (e = u_node->out; e != 0; e = e->next_out)\n+    {\n+      ddg_node_ptr v_node = e->dest;\n+      if (TEST_BIT (sched_nodes, v_node->cuid)\n+\t  && (up == SCHED_TIME (v_node) - e->latency + (e->distance * ii)))\n+\tif (SCHED_TIME (v_node) < upper)\n+\t  {\n+\t    crit_succ = v_node;\n+\t    upper = SCHED_TIME (v_node);\n+\t  }\n+    }\n+\n+  if (crit_succ != NULL)\n+    {\n+      crit_cycle = SCHED_TIME (crit_succ);\n+      return SMODULO (crit_cycle, ii);\n+    }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Both crit_pred and crit_succ are NULL\\n\");\n+\n+  return SMODULO ((low + up + 1) / 2, ii);\n+}\n+\n+static void\n+verify_partial_schedule (partial_schedule_ptr ps, sbitmap sched_nodes)\n+{\n+  int row;\n+  ps_insn_ptr crr_insn;\n+\n+  for (row = 0; row < ps->ii; row++)\n+    for (crr_insn = ps->rows[row]; crr_insn; crr_insn = crr_insn->next_in_row)\n+      {\n+\tddg_node_ptr u = crr_insn->node;\n+\n+\tgcc_assert (TEST_BIT (sched_nodes, u->cuid));\n+\t/* ??? Test also that all nodes of sched_nodes are in ps, perhaps by\n+\t   popcount (sched_nodes) == number of insns in ps.  */\n+\tgcc_assert (SCHED_TIME (u) >= ps->min_cycle);\n+\tgcc_assert (SCHED_TIME (u) <= ps->max_cycle);\n+      }\n+}\n+\n \f\n /* This page implements the algorithm for ordering the nodes of a DDG\n    for modulo scheduling, activated through the\n@@ -2361,26 +2606,6 @@ rotate_partial_schedule (partial_schedule_ptr ps, int start_cycle)\n   ps->min_cycle -= start_cycle;\n }\n \n-/* Remove the node N from the partial schedule PS; because we restart the DFA\n-   each time we want to check for resource conflicts; this is equivalent to\n-   unscheduling the node N.  */\n-static bool\n-ps_unschedule_node (partial_schedule_ptr ps, ddg_node_ptr n)\n-{\n-  ps_insn_ptr ps_i;\n-  int row = SMODULO (SCHED_TIME (n), ps->ii);\n-\n-  if (row < 0 || row > ps->ii)\n-    return false;\n-\n-  for (ps_i = ps->rows[row];\n-       ps_i &&  ps_i->node != n;\n-       ps_i = ps_i->next_in_row);\n-  if (!ps_i)\n-    return false;\n-\n-  return remove_node_from_ps (ps, ps_i);\n-}\n #endif /* INSN_SCHEDULING */\n \f\n static bool"}]}