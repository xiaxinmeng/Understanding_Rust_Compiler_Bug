{"sha": "95c7d828164dd40974b14ace4604f9412f8dc813", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVjN2Q4MjgxNjRkZDQwOTc0YjE0YWNlNDYwNGY5NDEyZjhkYzgxMw==", "commit": {"author": {"name": "Tim Shen", "email": "timshen91@gmail.com", "date": "2013-07-31T22:36:11Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2013-07-31T22:36:11Z"}, "message": "Thompson matcher refactored.\n\n2013-07-31  Tim Shen  <timshen91@gmail.com>\n\n\tThompson matcher refactored. Fix grouping problem.\n\t* include/bits/regex.h: Use a dispatcher _M_get_matcher().\n\t* include/bits/regex_compiler.h: Tweak for auto switching.\n\t* include/bits/regex_grep_matcher.h: Class structure.\n\t* include/bits/regex_grep_matcher.tcc: _BFSMatcher(Thompson\n\tmatcher) refactoring.\n\t* include/bits/regex_nfa.h: Change _Results's interfaces.\n\t* include/std/regex: Includes <map> and <queue>.\n\t* testsuite/28_regex/algorithms/regex_match/extended/53622.cc:\n\tFor both matchers.\n\t* testsuite/28_regex/algorithms/regex_match/extended/57173.cc:\n\tFor both matchers.\n\t* testsuite/28_regex/algorithms/regex_match/extended/\n\tstring_dispatch_01.cc: New.\n\nFrom-SVN: r201391", "tree": {"sha": "832860caade8e593fab47e871ea8b752e97e3baa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/832860caade8e593fab47e871ea8b752e97e3baa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95c7d828164dd40974b14ace4604f9412f8dc813", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95c7d828164dd40974b14ace4604f9412f8dc813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95c7d828164dd40974b14ace4604f9412f8dc813", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95c7d828164dd40974b14ace4604f9412f8dc813/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d86e633abc4aeb1be6c443b3dc3593629491a838", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d86e633abc4aeb1be6c443b3dc3593629491a838", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d86e633abc4aeb1be6c443b3dc3593629491a838"}], "stats": {"total": 629, "additions": 429, "deletions": 200}, "files": [{"sha": "48cde9e710f0d1919c1386710a0b4aba4eb18953", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=95c7d828164dd40974b14ace4604f9412f8dc813", "patch": "@@ -1,3 +1,20 @@\n+2013-07-31  Tim Shen  <timshen91@gmail.com>\n+\n+\tThompson matcher refactored. Fix grouping problem.\n+\t* include/bits/regex.h: Use a dispatcher _M_get_matcher().\n+\t* include/bits/regex_compiler.h: Tweak for auto switching.\n+\t* include/bits/regex_grep_matcher.h: Class structure.\n+\t* include/bits/regex_grep_matcher.tcc: _BFSMatcher(Thompson\n+\tmatcher) refactoring.\n+\t* include/bits/regex_nfa.h: Change _Results's interfaces.\n+\t* include/std/regex: Includes <map> and <queue>.\n+\t* testsuite/28_regex/algorithms/regex_match/extended/53622.cc:\n+\tFor both matchers.\n+\t* testsuite/28_regex/algorithms/regex_match/extended/57173.cc:\n+\tFor both matchers.\n+\t* testsuite/28_regex/algorithms/regex_match/extended/\n+\tstring_dispatch_01.cc: New.\n+\n 2013-07-31  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR libstdc++/56627"}, {"sha": "c1f65339848e2df5d9832442506d5340a53cbb26", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=95c7d828164dd40974b14ace4604f9412f8dc813", "patch": "@@ -2175,7 +2175,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     bool\n     regex_match(_Bi_iter                                 __s,\n                 _Bi_iter                                 __e,\n-                match_results<_Bi_iter, _Alloc>&     __m,\n+                match_results<_Bi_iter, _Alloc>&         __m,\n                 const basic_regex<_Ch_type, _Rx_traits>& __re,\n                 regex_constants::match_flag_type         __flags\n                                = regex_constants::match_default)\n@@ -2184,8 +2184,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __detail::_Automaton::_SizeT __sz = __a->_M_sub_count();\n       __detail::_SpecializedCursor<_Bi_iter> __cs(__s, __e);\n       __detail::_SpecializedResults<_Bi_iter, _Alloc> __r(__sz, __cs, __m);\n-      __detail::_Grep_matcher __matcher(__cs, __r, __a, __flags);\n-      return __matcher._M_dfs_match();\n+      return __a->_M_get_matcher(__cs, __r, __a, __flags)->_M_match();\n     }\n \n   /**\n@@ -2336,8 +2335,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       for (auto __cur = __first; __cur != __last; ++__cur) // Any KMP-like algo?\n         {\n           __detail::_SpecializedCursor<_Bi_iter> __curs(__cur, __last);\n-          __detail::_Grep_matcher __matcher(__curs, __r, __a, __flags);\n-          if (__matcher._M_dfs_search_from_first())\n+          auto __matcher = __a->_M_get_matcher(__curs, __r, __a, __flags);\n+          if (__matcher->_M_search_from_first())\n             {\n               __r._M_set_range(__m.size(),\n                                __detail::_SpecializedCursor<_Bi_iter>"}, {"sha": "badea8c641e29c6483cbedc42b56e40c7d5626fb", "filename": "libstdc++-v3/include/bits/regex_compiler.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h?ref=95c7d828164dd40974b14ace4604f9412f8dc813", "patch": "@@ -936,7 +936,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (_M_match_token(_ScannerT::_S_token_backref))\n \t{\n \t  // __m.push(_Matcher::_S_opcode_ordchar, _M_cur_value);\n-\t  return true;\n+          _M_state_store._M_set_back_ref(true);\n+\t  //return true;\n \t}\n       if (_M_match_token(_ScannerT::_S_token_subexpr_begin))\n \t{"}, {"sha": "474d8a291142e71d83eb020d22c5f87c92e2962e", "filename": "libstdc++-v3/include/bits/regex_grep_matcher.h", "status": "modified", "additions": 112, "deletions": 25, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.h?ref=95c7d828164dd40974b14ace4604f9412f8dc813", "patch": "@@ -60,6 +60,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t  const _SpecializedCursor<_FwdIterT>& __cursor,\n \t\t\t  match_results<_FwdIterT, _Alloc>& __m);\n \n+      ~_SpecializedResults()\n+      {\n+        if (_M_managed)\n+          delete &_M_results;\n+      }\n+\n+    private:\n+      _SpecializedResults(const _SpecializedResults& __rhs)\n+      : _M_results(*new match_results<_FwdIterT, _Alloc>(__rhs._M_results)),\n+      _M_managed(true)\n+      { }\n+\n+    public:\n       void\n       _M_set_pos(int __i, int __j, const _PatternCursor& __pc);\n \n@@ -76,16 +89,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_set_matched(int __i, bool __is_matched)\n       { _M_results.at(__i).matched = __is_matched; }\n \n+      std::unique_ptr<_Results>\n+      _M_clone() const\n+      { return unique_ptr<_Results>(new _SpecializedResults(*this)); }\n+\n+      void\n+      _M_assign(const _Results& __rhs)\n+      {\n+        auto __r = static_cast<const _SpecializedResults*>(&__rhs);\n+        _M_results = __r->_M_results;\n+      }\n+\n     private:\n       match_results<_FwdIterT, _Alloc>& _M_results;\n+      bool                              _M_managed;\n     };\n \n   template<typename _FwdIterT, typename _Alloc>\n     _SpecializedResults<_FwdIterT, _Alloc>::\n     _SpecializedResults(const _Automaton::_SizeT __size,\n     \t\t\tconst _SpecializedCursor<_FwdIterT>& __cursor,\n                         match_results<_FwdIterT, _Alloc>& __m)\n-    : _M_results(__m)\n+    : _M_results(__m), _M_managed(false)\n     {\n       _M_results.clear();\n       _M_results.reserve(__size + 2);\n@@ -105,14 +130,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef const _SpecializedCursor<_FwdIterT>& _CursorT;\n       _CursorT __c = static_cast<_CursorT>(__pc);\n       if (__j == 0)\n-\t_M_results.at(__i).first = __c._M_pos();\n+        _M_results.at(__i).first = __c._M_pos();\n       else\n         _M_results.at(__i).second = __c._M_pos();\n     }\n \n-  /// A stack of states used in evaluating the NFA.\n-  typedef std::stack<_StateIdT, std::vector<_StateIdT> > _StateStack;\n-\n   /// Executes a regular expression NFA/DFA over a range using a\n   /// variant of the parallel execution algorithm featured in the grep\n   /// utility, modified to use Laurikari tags.\n@@ -124,45 +146,110 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                   const _AutomatonPtr&              __automaton,\n                   regex_constants::match_flag_type  __flags)\n     : _M_nfa(static_pointer_cast<_Nfa>(__automaton)),\n-      _M_pattern(__p), _M_results(__r)\n+      _M_str_cur(__p), _M_results(__r)\n+    { }\n+\n+    virtual\n+    ~_Grep_matcher()\n     { }\n \n     // Set matched when string exactly match the pattern.\n-    void\n-    _M_match();\n+    virtual bool\n+    _M_match() = 0;\n \n     // Set matched when some prefix of the string matches the pattern.\n-    void\n-    _M_search_from_first();\n+    virtual bool\n+    _M_search_from_first() = 0;\n+\n+  protected:\n+    const std::shared_ptr<_Nfa>        _M_nfa;\n+    _PatternCursor&                    _M_str_cur;\n+    _Results&                          _M_results;\n+  };\n+\n+  // Time complexity: exponential\n+  // Space complexity: O(_M_str_cur.size())\n+  // _M_dfs() take a state, along with current string cursor(_M_str_cur),\n+  // trying to match current state with current character.\n+  // Only _S_opcode_match will consume a character.\n+  class _DFSMatcher\n+  : public _Grep_matcher\n+  {\n+  public:\n+    _DFSMatcher(_PatternCursor&                   __p,\n+                _Results&                         __r,\n+                const _AutomatonPtr&              __automaton,\n+                regex_constants::match_flag_type  __flags)\n+    : _Grep_matcher(__p, __r, __automaton, __flags)\n+    { }\n \n-    // TODO: in the future this function will be _M_match, in another class.\n     bool\n-    _M_dfs_match()\n+    _M_match()\n     { return _M_dfs<true>(_M_nfa->_M_start()); }\n \n-    // TODO: in the future this function will be _M_search_from_first,\n-    // in another class.\n     bool\n-    _M_dfs_search_from_first()\n+    _M_search_from_first()\n     { return _M_dfs<false>(_M_nfa->_M_start()); }\n \n   private:\n-    _StateSet\n-    _M_e_closure(_StateIdT __i);\n+    template<bool __match_mode>\n+      bool\n+      _M_dfs(_StateIdT __i);\n+  };\n+\n+  // It's essentially a variant of Single-Source-Shortest-Path problem, where,\n+  // the matching results is the final distance and should be minimized.\n+  // Instead of using Dijkstra Algorithm, I pick up the queue-optimizaed\n+  // (BFS-like) Bellman-Ford algorithm,\n+  // SPFA(http://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm).\n+  //\n+  // Every entry of _M_current saves the solution(grouping status) for every\n+  // matching head. When states transfer, solutions will be compared and\n+  // deduplicated(based on which greedy mode we have).\n+  //\n+  // Time complexity: O(_M_str_cur.size() * _M_nfa.size())\n+  // Space complexity: O(_M_nfa.size() * _M_nfa.mark_count())\n+  class _BFSMatcher\n+  : public _Grep_matcher\n+  {\n+  public:\n+    _BFSMatcher(_PatternCursor&                   __p,\n+                _Results&                         __r,\n+                const _AutomatonPtr&              __automaton,\n+                regex_constants::match_flag_type  __flags)\n+    : _Grep_matcher(__p, __r, __automaton, __flags)\n+    {\n+      if (_M_nfa->_M_start() != _S_invalid_state_id)\n+        _M_current[_M_nfa->_M_start()] = _M_results._M_clone();\n+      _M_e_closure();\n+    }\n \n-    _StateSet\n-    _M_e_closure(const _StateSet& __s);\n+    bool\n+    _M_match()\n+    { return _M_main_loop<true>(); }\n \n-    _StateSet\n-    _M_e_closure(_StateStack& __stack, const _StateSet& __s);\n+    bool\n+    _M_search_from_first()\n+    { return _M_main_loop<false>(); }\n \n+  private:\n     template<bool __match_mode>\n       bool\n-      _M_dfs(_StateIdT __i);\n+      _M_main_loop();\n \n-    const std::shared_ptr<_Nfa>        _M_nfa;\n-    _PatternCursor&                    _M_pattern;\n-    _Results&                          _M_results;\n+    void\n+    _M_e_closure();\n+\n+    void\n+    _M_move();\n+\n+    bool\n+    _M_match_less_than(_StateIdT __u, _StateIdT __v) const;\n+\n+    bool\n+    _M_includes_some() const;\n+\n+    std::map<_StateIdT, std::unique_ptr<_Results>>     _M_current;\n   };\n \n  //@} regex-detail"}, {"sha": "8ea7998474de8f2aa8feb6dd63223c7d57e1697b", "filename": "libstdc++-v3/include/bits/regex_grep_matcher.tcc", "status": "modified", "additions": 141, "deletions": 141, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc?ref=95c7d828164dd40974b14ace4604f9412f8dc813", "patch": "@@ -32,83 +32,13 @@\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n-namespace\n-{\n-  // A stack of states used in evaluating the NFA.\n-  typedef std::stack<std::__detail::_StateIdT,\n-                     std::vector<std::__detail::_StateIdT>\n-\t\t     > _StateStack;\n-\n-  // Obtains the next state set given the current state set __s and the current\n-  // input character.\n-  inline std::__detail::_StateSet\n-  __move(const std::__detail::_PatternCursor& __p,\n-         const std::__detail::_Nfa& __nfa,\n-         const std::__detail::_StateSet& __s)\n-  {\n-    std::__detail::_StateSet __m;\n-    for (std::__detail::_StateSet::const_iterator __i = __s.begin();\n-\t __i != __s.end(); ++__i)\n-      {\n-\tif (*__i == std::__detail::_S_invalid_state_id)\n-\t  continue;\n-\n-\tconst std::__detail::_State& __state = __nfa[*__i];\n-\tif (__state._M_opcode == std::__detail::_S_opcode_match\n-\t    && __state._M_matches(__p))\n-\t  __m.insert(__state._M_next);\n-      }\n-    return __m;\n-  }\n-\n-  // returns true if (__s intersect __t) is not empty\n-  inline bool\n-  __includes_some(const std::__detail::_StateSet& __s,\n-                  const std::__detail::_StateSet& __t)\n-  {\n-    if (__s.size() > 0 && __t.size() > 0)\n-      {\n-\tstd::__detail::_StateSet::const_iterator __first = __s.begin();\n-\tstd::__detail::_StateSet::const_iterator __second = __t.begin();\n-\twhile (__first != __s.end() && __second != __t.end())\n-\t  {\n-\t    if (*__first < *__second)\n-\t      ++__first;\n-\t    else if (*__second < *__first)\n-\t      ++__second;\n-\t    else\n-\t      return true;\n-\t  }\n-      }\n-    return false;\n-  }\n-\n-  // If an identified state __u is not already in the current state set __e,\n-  // insert it and push it on the current state stack __s.\n-  inline void\n-  __add_visited_state(const std::__detail::_StateIdT __u,\n-                      _StateStack&                  __s,\n-                      std::__detail::_StateSet&      __e)\n-  {\n-    if (__e.count(__u) == 0)\n-      {\n-\t__e.insert(__u);\n-\t__s.push(__u);\n-      }\n-  }\n-\n-} // anonymous namespace\n-\n namespace __detail\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n-  // _M_dfs() take a state, along with current string cursor(_M_pattern),\n-  // trying to match current state with current character.\n-  // Only _S_opcode_match will consume a character.\n   // TODO: This is too slow. Try to compile the NFA to a DFA.\n   template<bool __match_mode>\n-    bool _Grep_matcher::\n+    bool _DFSMatcher::\n     _M_dfs(_StateIdT __i)\n     {\n       if (__i == _S_invalid_state_id)\n@@ -126,116 +56,186 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n             || _M_dfs<__match_mode>(__state._M_next);\n           break;\n         case _S_opcode_subexpr_begin:\n-          __state._M_tagger(_M_pattern, _M_results);\n+          __state._M_tagger(_M_str_cur, _M_results);\n           __ret = _M_dfs<__match_mode>(__state._M_next);\n           break;\n         case _S_opcode_subexpr_end:\n-          __state._M_tagger(_M_pattern, _M_results);\n+          __state._M_tagger(_M_str_cur, _M_results);\n           __ret = _M_dfs<__match_mode>(__state._M_next);\n           _M_results._M_set_matched(__state._M_subexpr, __ret);\n           break;\n         case _S_opcode_match:\n-          if (!_M_pattern._M_at_end() && __state._M_matches(_M_pattern))\n+          if (!_M_str_cur._M_at_end() && __state._M_matches(_M_str_cur))\n             {\n-              _M_pattern._M_next();\n+              _M_str_cur._M_next();\n               __ret = _M_dfs<__match_mode>(__state._M_next);\n-              _M_pattern._M_prev();\n+              _M_str_cur._M_prev();\n             }\n           break;\n         case _S_opcode_accept:\n           if (__match_mode)\n-            __ret = _M_pattern._M_at_end();\n+            __ret = _M_str_cur._M_at_end();\n           else\n             __ret = true;\n           break;\n         default:\n-          _GLIBCXX_DEBUG_ASSERT( false );\n+          _GLIBCXX_DEBUG_ASSERT(false);\n         }\n       return __ret;\n     }\n \n-  inline void _Grep_matcher::\n-  _M_match()\n-  {\n-    __detail::_StateSet __t = this->_M_e_closure(_M_nfa->_M_start());\n-    for (; !_M_pattern._M_at_end(); _M_pattern._M_next())\n-      __t = this->_M_e_closure(__move(_M_pattern, *_M_nfa, __t));\n-\n-    _M_results._M_set_matched(0,\n-                              __includes_some(_M_nfa->_M_final_states(), __t));\n-  }\n+  template<bool __match_mode>\n+    bool _BFSMatcher::\n+    _M_main_loop()\n+    {\n+      while (!_M_str_cur._M_at_end())\n+        {\n+          if (!__match_mode)\n+            if (_M_includes_some())\n+              return true;\n+          _M_move();\n+          _M_str_cur._M_next();\n+          _M_e_closure();\n+        }\n+      return _M_includes_some();\n+    }\n \n-  inline void _Grep_matcher::\n-  _M_search_from_first()\n+  // The SPFA approach.\n+  // FIXME: move it to src/c++11 when it's stable, and make it not inlined.\n+  inline\n+  void _BFSMatcher::\n+  _M_e_closure()\n   {\n-    __detail::_StateSet __t = this->_M_e_closure(_M_nfa->_M_start());\n-    for (; !_M_pattern._M_at_end(); _M_pattern._M_next())\n+    std::queue<_StateIdT> __q;\n+    std::vector<bool> __in_q(_M_nfa->size(), false);\n+    for (auto& __it : _M_current)\n       {\n-        if (__includes_some(_M_nfa->_M_final_states(), __t)) // KISS\n-          {\n-            _M_results._M_set_matched(0, true);\n+        __in_q[__it.first] = true;\n+        __q.push(__it.first);\n+      }\n+    while (!__q.empty())\n+      {\n+        auto __u = __q.front();\n+        __q.pop();\n+        __in_q[__u] = false;\n+        const auto& __state = (*_M_nfa)[__u];\n+\n+        // Can be implemented using method, but there're too much arguments.\n+        auto __add_visited_state = [&](_StateIdT __v)\n+        {\n+          if (__v == _S_invalid_state_id)\n             return;\n+          if (_M_match_less_than(__u, __v))\n+            {\n+              _M_current[__v] = _M_current[__u]->_M_clone();\n+              // if a state is updated, it's outgoing neighbors should be\n+              // reconsidered too. Push them to the queue.\n+              if (!__in_q[__v])\n+                {\n+                  __in_q[__v] = true;\n+                  __q.push(__v);\n+                }\n+            }\n+        };\n+\n+        switch (__state._M_opcode)\n+          {\n+            case _S_opcode_alternative:\n+              __add_visited_state(__state._M_next);\n+              __add_visited_state(__state._M_alt);\n+              break;\n+            case _S_opcode_subexpr_begin:\n+              __state._M_tagger(_M_str_cur, *_M_current[__u]);\n+              __add_visited_state(__state._M_next);\n+              break;\n+            case _S_opcode_subexpr_end:\n+              __state._M_tagger(_M_str_cur, *_M_current[__u]);\n+              _M_current[__u]->_M_set_matched(__state._M_subexpr, true);\n+              __add_visited_state(__state._M_next);\n+              break;\n+            case _S_opcode_match:\n+              break;\n+            case _S_opcode_accept:\n+              __add_visited_state(__state._M_next);\n+              break;\n+            default:\n+              _GLIBCXX_DEBUG_ASSERT(false);\n           }\n-        __t = this->_M_e_closure(__move(_M_pattern, *_M_nfa, __t));\n       }\n-    _M_results._M_set_matched(0, false);\n   }\n \n-  // Creates the e-closure set for the initial state __i.\n-  inline _StateSet _Grep_matcher::\n-  _M_e_closure(_StateIdT __i)\n+  // FIXME: move it to src/c++11 when it's stable, and make it not inlined.\n+  inline\n+  void _BFSMatcher::\n+  _M_move()\n   {\n-    _StateSet __s;\n-    __s.insert(__i);\n-    _StateStack __stack;\n-    __stack.push(__i);\n-    return this->_M_e_closure(__stack, __s);\n+    decltype(_M_current) __next;\n+    for (auto& __it : _M_current)\n+      {\n+        const auto& __state = (*_M_nfa)[__it.first];\n+        if (__state._M_opcode == _S_opcode_match\n+            && __state._M_matches(_M_str_cur))\n+          if (_M_match_less_than(__it.first, __state._M_next)\n+              && __state._M_next != _S_invalid_state_id)\n+            __next[__state._M_next] = __it.second->_M_clone();\n+      }\n+    _M_current = move(__next);\n   }\n \n-  // Creates the e-closure set for an arbitrary state set __s.\n-  inline _StateSet _Grep_matcher::\n-  _M_e_closure(const _StateSet& __s)\n+  // FIXME: move it to src/c++11 when it's stable, and make it not inlined.\n+  inline\n+  bool _BFSMatcher::\n+  _M_match_less_than(_StateIdT __u, _StateIdT __v) const\n   {\n-    _StateStack __stack;\n-    for (_StateSet::const_iterator __i = __s.begin(); __i != __s.end(); ++__i)\n-      __stack.push(*__i);\n-    return this->_M_e_closure(__stack, __s);\n+    if (_M_current.count(__u) == 0)\n+      return false;\n+    if (_M_current.count(__v) > 0)\n+      return true;\n+    // TODO: Greedy and Non-greedy support\n+    return true;\n   }\n \n-  inline _StateSet _Grep_matcher::\n-  _M_e_closure(_StateStack& __stack, const _StateSet& __s)\n+  // FIXME: move it to src/c++11 when it's stable, and make it not inlined.\n+  inline\n+  bool _BFSMatcher::\n+  _M_includes_some() const\n   {\n-    _StateSet __e = __s;\n-    while (!__stack.empty())\n+    auto& __s = _M_nfa->_M_final_states();\n+    auto& __t = _M_current;\n+    if (__s.size() > 0 && __t.size() > 0)\n       {\n-\t_StateIdT __t = __stack.top(); __stack.pop();\n-\tif (__t == _S_invalid_state_id)\n-\t  continue;\n-\t// for each __u with edge from __t to __u labeled e do ...\n-\tconst _State& __state = _M_nfa->operator[](__t);\n-\tswitch (__state._M_opcode)\n+\tauto __first = __s.begin();\n+\tauto __second = __t.begin();\n+\twhile (__first != __s.end() && __second != __t.end())\n \t  {\n-\t  case _S_opcode_alternative:\n-\t    __add_visited_state(__state._M_next, __stack, __e);\n-\t    __add_visited_state(__state._M_alt, __stack, __e);\n-\t    break;\n-\t  case _S_opcode_subexpr_begin:\n-\t    __add_visited_state(__state._M_next, __stack, __e);\n-\t    __state._M_tagger(_M_pattern, _M_results);\n-\t    break;\n-\t  case _S_opcode_subexpr_end:\n-\t    __add_visited_state(__state._M_next, __stack, __e);\n-\t    __state._M_tagger(_M_pattern, _M_results);\n-\t    _M_results._M_set_matched(__state._M_subexpr, true);\n-\t    break;\n-\t  case _S_opcode_accept:\n-\t    __add_visited_state(__state._M_next, __stack, __e);\n-\t    break;\n-\t  default:\n-\t    break;\n+\t    if (*__first < __second->first)\n+\t      ++__first;\n+\t    else if (__second->first < *__first)\n+\t      ++__second;\n+\t    else\n+              {\n+                _M_results._M_assign(*__second->second);\n+                return true;\n+              }\n \t  }\n       }\n-    return __e;\n+    return false;\n+  }\n+\n+  // FIXME: move it to src/c++11 when it's stable, and make it not inlined.\n+  inline\n+  std::unique_ptr<_Grep_matcher> _Nfa::\n+  _M_get_matcher(_PatternCursor&                   __p,\n+                 _Results&                         __r,\n+                 const _AutomatonPtr&              __a,\n+                 regex_constants::match_flag_type  __flags)\n+  {\n+    if (_M_has_back_ref)\n+      return unique_ptr<_Grep_matcher>(\n+        new _DFSMatcher(__p, __r, __a, __flags));\n+    else\n+      return unique_ptr<_Grep_matcher>(\n+        new _BFSMatcher(__p, __r, __a, __flags));\n   }\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "1bae1b78ed4c9d1b63a9925975d6ce5c5942e72f", "filename": "libstdc++-v3/include/bits/regex_nfa.h", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_nfa.h?ref=95c7d828164dd40974b14ace4604f9412f8dc813", "patch": "@@ -39,6 +39,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @{\n    */\n \n+  /// Provides a generic facade for a templated match_results.\n+  struct _Results\n+  {\n+    virtual\n+    ~_Results()\n+    { }\n+    virtual void _M_set_pos(int __i, int __j, const _PatternCursor& __p) = 0;\n+    virtual void _M_set_matched(int __i, bool __is_matched) = 0;\n+    virtual std::unique_ptr<_Results> _M_clone() const = 0;\n+    virtual void _M_assign(const _Results& __rhs) = 0;\n+  };\n+\n+  class _Grep_matcher;\n+  class _Automaton;\n+\n+  /// Generic shared pointer to an automaton.\n+  typedef std::shared_ptr<_Automaton> _AutomatonPtr;\n+\n   /// Base class for, um, automata.  Could be an NFA or a DFA.  Your choice.\n   class _Automaton\n   {\n@@ -52,15 +70,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     virtual _SizeT\n     _M_sub_count() const = 0;\n \n+    virtual std::unique_ptr<_Grep_matcher>\n+    _M_get_matcher(_PatternCursor&                   __p,\n+                   _Results&                         __r,\n+                   const _AutomatonPtr&              __automaton,\n+                   regex_constants::match_flag_type  __flags) = 0;\n+\n #ifdef _GLIBCXX_DEBUG\n     virtual std::ostream&\n     _M_dot(std::ostream& __ostr) const = 0;\n #endif\n   };\n \n-  /// Generic shared pointer to an automaton.  \n-  typedef std::shared_ptr<_Automaton> _AutomatonPtr;\n-\n   /// Operation codes that define the type of transitions within the base NFA\n   /// that represents the regular expression.\n   enum _Opcode\n@@ -73,13 +94,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _S_opcode_accept        = 255\n   };\n \n-  /// Provides a generic facade for a templated match_results.\n-  struct _Results\n-  {\n-    virtual void _M_set_pos(int __i, int __j, const _PatternCursor& __p) = 0;\n-    virtual void _M_set_matched(int __i, bool __is_matched) = 0;\n-  };\n-\n   /// Tags current state (for subexpr begin/end).\n   typedef std::function<void (const _PatternCursor&, _Results&)> _Tagger;\n \n@@ -113,7 +127,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { __r._M_set_pos(_M_index, 1, __pc); }\n \n       int       _M_index;\n-      _FwdIterT _M_pos;\n     };\n \n   /// Indicates if current state matches cursor current.\n@@ -275,7 +288,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     typedef regex_constants::syntax_option_type _FlagT;\n \n     _Nfa(_FlagT __f)\n-    : _M_flags(__f), _M_start_state(0), _M_subexpr_count(0)\n+    : _M_flags(__f), _M_start_state(0), _M_subexpr_count(0),\n+    // TODO: BFS by default. Your choice. Need to be set by the compiler.\n+    _M_has_back_ref(false)\n     { }\n \n     ~_Nfa()\n@@ -334,6 +349,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return this->size()-1;\n     }\n \n+    void\n+    _M_set_back_ref(bool __b)\n+    { _M_has_back_ref = __b; }\n+\n+    std::unique_ptr<_Grep_matcher>\n+    _M_get_matcher(_PatternCursor&                   __p,\n+                   _Results&                         __r,\n+                   const _AutomatonPtr&              __automaton,\n+                   regex_constants::match_flag_type  __flags);\n+\n #ifdef _GLIBCXX_DEBUG\n     std::ostream&\n     _M_dot(std::ostream& __ostr) const;\n@@ -344,6 +369,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _StateIdT  _M_start_state;\n     _StateSet  _M_accepting_states;\n     _SizeT     _M_subexpr_count;\n+    bool       _M_has_back_ref;\n   };\n \n   /// Describes a sequence of one or more %_State, its current start"}, {"sha": "b0918ed4afe8e50414cf2aafc269cbd6b0d8319b", "filename": "libstdc++-v3/include/std/regex", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fregex?ref=95c7d828164dd40974b14ace4604f9412f8dc813", "patch": "@@ -44,6 +44,8 @@\n #include <iterator>\n #include <locale>\n #include <memory>\n+#include <map>\n+#include <queue>\n #include <set>\n #include <sstream>\n #include <stack>"}, {"sha": "10e2ff43765b31847e38d1ffdfdda190c2818a75", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/extended/53622.cc", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2F53622.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2F53622.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2F53622.cc?ref=95c7d828164dd40974b14ace4604f9412f8dc813", "patch": "@@ -32,16 +32,31 @@ test01()\n {\n   bool test __attribute__((unused)) = true;\n \n-  std::regex  re(\"zxcv/(one.*)abc\", std::regex::extended);\n-  std::string target(\"zxcv/onetwoabc\");\n-  std::smatch m;\n-\n-  VERIFY( std::regex_search(target, m, re) );\n-  VERIFY( m.size() == 2 );\n-  VERIFY( m[0].matched == true );\n-  VERIFY( std::string(m[0].first, m[0].second) == \"zxcv/onetwoabc\" );\n-  VERIFY( m[1].matched == true );\n-  VERIFY( std::string(m[1].first, m[1].second) == \"onetwo\" );\n+  {\n+    std::regex  re(\"zxcv/(one.*)abc\", std::regex::extended);\n+    std::string target(\"zxcv/onetwoabc\");\n+    std::smatch m;\n+\n+    VERIFY( std::regex_search(target, m, re) );\n+    VERIFY( m.size() == 2 );\n+    VERIFY( m[0].matched == true );\n+    VERIFY( std::string(m[0].first, m[0].second) == \"zxcv/onetwoabc\" );\n+    VERIFY( m[1].matched == true );\n+    VERIFY( std::string(m[1].first, m[1].second) == \"onetwo\" );\n+  }\n+\n+  {\n+    std::regex  re(\"zxcv/(one.*)abc()\\\\2\", std::regex::extended);\n+    std::string target(\"zxcv/onetwoabc\");\n+    std::smatch m;\n+\n+    VERIFY( std::regex_search(target, m, re) );\n+    VERIFY( m.size() == 3 );\n+    VERIFY( m[0].matched == true );\n+    VERIFY( std::string(m[0].first, m[0].second) == \"zxcv/onetwoabc\" );\n+    VERIFY( m[1].matched == true );\n+    VERIFY( std::string(m[1].first, m[1].second) == \"onetwo\" );\n+  }\n }\n \n int"}, {"sha": "cb3a54f4d88203186445cacac3ea64ec8c8ccd16", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/extended/57173.cc", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2F57173.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2F57173.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2F57173.cc?ref=95c7d828164dd40974b14ace4604f9412f8dc813", "patch": "@@ -33,13 +33,24 @@ test01()\n {\n   bool test __attribute__((unused)) = true;\n \n-  std::regex  re(\"/asdf(/.*)\", std::regex::extended);\n-  std::string target(\"/asdf/qwerty\");\n-  std::smatch m;\n+  {\n+    std::regex  re(\"/asdf(/.*)\", std::regex::extended);\n+    std::string target(\"/asdf/qwerty\");\n+    std::smatch m;\n \n-  VERIFY( std::regex_match(target, m, re) );\n-  VERIFY( m.size() == 2 );\n-  VERIFY( std::string(m[1].first, m[1].second) == \"/qwerty\");\n+    VERIFY( std::regex_match(target, m, re) );\n+    VERIFY( m.size() == 2 );\n+    VERIFY( std::string(m[1].first, m[1].second) == \"/qwerty\");\n+  }\n+  {\n+    std::regex  re(\"/asdf(/.*)()\\\\2\", std::regex::extended);\n+    std::string target(\"/asdf/qwerty\");\n+    std::smatch m;\n+\n+    VERIFY( std::regex_match(target, m, re) );\n+    VERIFY( m.size() == 3 );\n+    VERIFY( std::string(m[1].first, m[1].second) == \"/qwerty\");\n+  }\n }\n \n int"}, {"sha": "86fab85a434a475659de5860f89cd65275621727", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/extended/string_dispatch_01.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_dispatch_01.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95c7d828164dd40974b14ace4604f9412f8dc813/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_dispatch_01.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fextended%2Fstring_dispatch_01.cc?ref=95c7d828164dd40974b14ace4604f9412f8dc813", "patch": "@@ -0,0 +1,71 @@\n+// { dg-options \"-std=gnu++11\" }\n+\n+//\n+// 2013-07-29  Tim Shen <timshen91@gmail.com>\n+//\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 28.11.2 regex_match\n+// Tests Extended automatic matcher dispatching against a std::string target.\n+\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+template<typename _Bi_iter, typename _Alloc,\n+         typename _Ch_type, typename _Rx_traits>\n+  void\n+  fake_match(_Bi_iter                                 __s,\n+             _Bi_iter                                 __e,\n+             match_results<_Bi_iter, _Alloc>&         __m,\n+             const basic_regex<_Ch_type, _Rx_traits>& __re,\n+             regex_constants::match_flag_type         __flags\n+                            = regex_constants::match_default)\n+  {\n+    __detail::_AutomatonPtr __a = __re._M_get_automaton();\n+    __detail::_Automaton::_SizeT __sz = __a->_M_sub_count();\n+    __detail::_SpecializedCursor<_Bi_iter> __cs(__s, __e);\n+    __detail::_SpecializedResults<_Bi_iter, _Alloc> __r(__sz, __cs, __m);\n+    VERIFY( dynamic_cast<__detail::_DFSMatcher *>(\n+              &*__a->_M_get_matcher(__cs, __r, __a, __flags)) != nullptr );\n+  }\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  regex  re(\"()(one(.*))abc\\\\1\"); // backref cause DFS\n+  const string target(\"onetwoabc\");\n+  smatch m;\n+  fake_match(target.begin(), target.end(), m, re);\n+\n+  regex_match(target, m, re);\n+  VERIFY( m[2].matched );\n+  VERIFY( m[3].matched );\n+  VERIFY( std::string(m[2].first, m[2].second) == \"onetwo\" );\n+  VERIFY( std::string(m[3].first, m[3].second) == \"two\" );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}]}