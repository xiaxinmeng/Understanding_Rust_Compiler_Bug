{"sha": "7edfb4c6492dc8f503f5277adcaf5ab25c62cc46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VkZmI0YzY0OTJkYzhmNTAzZjUyNzdhZGNhZjVhYjI1YzYyY2M0Ng==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2014-02-25T15:03:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-25T15:03:23Z"}, "message": "2014-02-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.ads Update the usage of flag\n\tUses_Sec_Stack. Uses_Sec_Stack now applies to E_Loop entities.\n\t* exp_ch5.adb (Expand_Iterator_Loop): The temporary for a cursor\n\tnow starts with the letter 'C'. This makes reading expanded\n\tcode easier.\n\t* exp_ch7.adb (Establish_Transient_Scope): Add local variable\n\tIter_Loop. Signal that an Ada 2012 iterator loop requires\n\tsecondary stack management when creating a transient scope for\n\tan element reference.\n\t* exp_util.adb (Process_Statements_For_Controlled_Objects):\n\tWhen wrapping the statements of a loop, pass the E_Loop entity\n\tto the wrapping machinery.\n\t(Wrap_Statements_In_Block): Add\n\tformal parameter Scop along with comment on usage. Add local\n\tvariables Block_Id, Block_Nod and Iter_Loop. Mark the generated\n\tblock as requiring secondary stack management when the block is\n\tcreated inside an Ada 2012 iterator loop. This ensures that any\n\treference objects are reclaimed on each iteration of the loop.\n\t* sem_ch5.adb (Analyze_Loop_Statement): Mark the generated block\n\ttasked with the handling of container iterators as requiring\n\tsecondary stack management. This ensures that iterators are\n\treclaimed when the loop terminates or is exited in any fashion.\n\t* sem_util.adb (Add_Block_Identifier): New routine.\n\t(Find_Enclosing_Iterator_Loop): New routine.\n\t* sem_util.ads (Add_Block_Identifier): New routine.\n\t(Find_Enclosing_Iterator_Loop): New routine.\n\nFrom-SVN: r208133", "tree": {"sha": "5c5f51d2f9af2943bc3851a9c729ed0f00505b78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c5f51d2f9af2943bc3851a9c729ed0f00505b78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bbe9779cc857a7bbd28ab316bb325abd5ff0df71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbe9779cc857a7bbd28ab316bb325abd5ff0df71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbe9779cc857a7bbd28ab316bb325abd5ff0df71"}], "stats": {"total": 262, "additions": 233, "deletions": 29}, "files": [{"sha": "ed288b3d0532d41fd0934f80b648e2e572ad708b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7edfb4c6492dc8f503f5277adcaf5ab25c62cc46", "patch": "@@ -1,3 +1,32 @@\n+2014-02-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.ads Update the usage of flag\n+\tUses_Sec_Stack. Uses_Sec_Stack now applies to E_Loop entities.\n+\t* exp_ch5.adb (Expand_Iterator_Loop): The temporary for a cursor\n+\tnow starts with the letter 'C'. This makes reading expanded\n+\tcode easier.\n+\t* exp_ch7.adb (Establish_Transient_Scope): Add local variable\n+\tIter_Loop. Signal that an Ada 2012 iterator loop requires\n+\tsecondary stack management when creating a transient scope for\n+\tan element reference.\n+\t* exp_util.adb (Process_Statements_For_Controlled_Objects):\n+\tWhen wrapping the statements of a loop, pass the E_Loop entity\n+\tto the wrapping machinery.\n+\t(Wrap_Statements_In_Block): Add\n+\tformal parameter Scop along with comment on usage. Add local\n+\tvariables Block_Id, Block_Nod and Iter_Loop. Mark the generated\n+\tblock as requiring secondary stack management when the block is\n+\tcreated inside an Ada 2012 iterator loop. This ensures that any\n+\treference objects are reclaimed on each iteration of the loop.\n+\t* sem_ch5.adb (Analyze_Loop_Statement): Mark the generated block\n+\ttasked with the handling of container iterators as requiring\n+\tsecondary stack management. This ensures that iterators are\n+\treclaimed when the loop terminates or is exited in any fashion.\n+\t* sem_util.adb (Add_Block_Identifier): New routine.\n+\t(Find_Enclosing_Iterator_Loop): New routine.\n+\t* sem_util.ads (Add_Block_Identifier): New routine.\n+\t(Find_Enclosing_Iterator_Loop): New routine.\n+\n 2014-02-25  Robert Dewar  <dewar@adacore.com>\n \n \t* sinfo.ads: Minor reformatting."}, {"sha": "a9106b2e75b326e872a7c4f2eb7c82842bf4c644", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=7edfb4c6492dc8f503f5277adcaf5ab25c62cc46", "patch": "@@ -4074,9 +4074,9 @@ package Einfo is\n --       Protection object (see System.Tasking.Protected_Objects).\n \n --    Uses_Sec_Stack (Flag95)\n---       Defined in scope entities (blocks,functions, procedures, tasks,\n---       entries). Set to True when secondary stack is used in this scope and\n---       must be released on exit unless Sec_Stack_Needed_For_Return is set.\n+--       Defined in scope entities (block, entry, function, loop, procedure,\n+--       task). Set to True when secondary stack is used in this scope and must\n+--       be released on exit unless Sec_Stack_Needed_For_Return is set.\n \n --    Warnings_Off (Flag96)\n --       Defined in all entities. Set if a pragma Warnings (Off, entity-name)\n@@ -5633,6 +5633,7 @@ package Einfo is\n    --    Has_Loop_Entry_Attributes           (Flag260)\n    --    Has_Master_Entity                   (Flag21)\n    --    Has_Nested_Block_With_Handler       (Flag101)\n+   --    Uses_Sec_Stack                      (Flag95)\n \n    --  E_Modular_Integer_Type\n    --  E_Modular_Integer_Subtype"}, {"sha": "2fd38ac86a610326a38d2abc5f779fd83b463db1", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=7edfb4c6492dc8f503f5277adcaf5ab25c62cc46", "patch": "@@ -3264,7 +3264,7 @@ package body Exp_Ch5 is\n                Ent           : Entity_Id;\n \n             begin\n-               Cursor := Make_Temporary (Loc, 'I');\n+               Cursor := Make_Temporary (Loc, 'C');\n \n                --  For an container element iterator, the iterator type\n                --  is obtained from the corresponding aspect, whose return"}, {"sha": "dccf8318db7f04ebfc1aacb2c18c5e06db9fab0e", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 48, "deletions": 9, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=7edfb4c6492dc8f503f5277adcaf5ab25c62cc46", "patch": "@@ -3558,6 +3558,7 @@ package body Exp_Ch7 is\n \n    procedure Establish_Transient_Scope (N : Node_Id; Sec_Stack : Boolean) is\n       Loc       : constant Source_Ptr := Sloc (N);\n+      Iter_Loop : Entity_Id;\n       Wrap_Node : Node_Id;\n \n    begin\n@@ -3571,8 +3572,8 @@ package body Exp_Ch7 is\n \n             return;\n \n-         --  If we have encountered Standard there are no enclosing\n-         --  transient scopes.\n+         --  If we have encountered Standard there are no enclosing transient\n+         --  scopes.\n \n          elsif Scope_Stack.Table (S).Entity = Standard_Standard then\n             exit;\n@@ -3581,17 +3582,17 @@ package body Exp_Ch7 is\n \n       Wrap_Node := Find_Node_To_Be_Wrapped (N);\n \n-      --  Case of no wrap node, false alert, no transient scope needed\n+      --  The context does not contain a node that requires a transient scope,\n+      --  nothing to do.\n \n       if No (Wrap_Node) then\n          null;\n \n-      --  If the node to wrap is an iteration_scheme, the expression is\n-      --  one of the bounds, and the expansion will make an explicit\n-      --  declaration for it (see Analyze_Iteration_Scheme, sem_ch5.adb),\n-      --  so do not apply any transformations here. Same for an Ada 2012\n-      --  iterator specification, where a block is created for the expression\n-      --  that build the container.\n+      --  If the node to wrap is an iteration_scheme, the expression is one of\n+      --  the bounds, and the expansion will make an explicit declaration for\n+      --  it (see Analyze_Iteration_Scheme, sem_ch5.adb), so do not apply any\n+      --  transformations here. Same for an Ada 2012 iterator specification,\n+      --  where a block is created for the expression that build the container.\n \n       elsif Nkind_In (Wrap_Node, N_Iteration_Scheme,\n                                  N_Iterator_Specification)\n@@ -3608,13 +3609,51 @@ package body Exp_Ch7 is\n       then\n          null;\n \n+      --  Create a block entity to act as a transient scope. Note that when the\n+      --  node to be wrapped is an expression or a statement, a real physical\n+      --  block is constructed (see routines Wrap_Transient_Expression and\n+      --  Wrap_Transient_Statement) and inserted into the tree.\n+\n       else\n          Push_Scope (New_Internal_Entity (E_Block, Current_Scope, Loc, 'B'));\n          Set_Scope_Is_Transient;\n \n+         --  The transient scope must also take care of the secondary stack\n+         --  management.\n+\n          if Sec_Stack then\n             Set_Uses_Sec_Stack (Current_Scope);\n             Check_Restriction (No_Secondary_Stack, N);\n+\n+            --  The expansion of iterator loops generates references to objects\n+            --  in order to extract elements from a container:\n+\n+            --    Ref : Reference_Type_Ptr := Reference (Container, Cursor);\n+            --    Obj : <object type> renames Ref.all.Element.all;\n+\n+            --  These references are controlled and returned on the secondary\n+            --  stack. A new reference is created at each iteration of the loop\n+            --  and as a result it must be finalized and the space occupied by\n+            --  it on the secondary stack reclaimed at the end of the current\n+            --  iteration.\n+\n+            --  When the context that requires a transient scope is a call to\n+            --  routine Reference, the node to be wrapped is the source object:\n+\n+            --    for Obj of Container loop\n+\n+            --  Routine Wrap_Transient_Declaration however does not generate a\n+            --  physical block as wrapping a declaration will kill it too ealy.\n+            --  To handle this peculiar case, mark the related iterator loop as\n+            --  requiring the secondary stack. This signals the finalization\n+            --  machinery to manage the secondary stack (see routine\n+            --  Process_Statements_For_Controlled_Objects).\n+\n+            Iter_Loop := Find_Enclosing_Iterator_Loop (Current_Scope);\n+\n+            if Present (Iter_Loop) then\n+               Set_Uses_Sec_Stack (Iter_Loop);\n+            end if;\n          end if;\n \n          Set_Etype (Current_Scope, Standard_Void_Type);"}, {"sha": "f409cb07ae5215571579203ac9ca7317663bde4d", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 44, "deletions": 7, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=7edfb4c6492dc8f503f5277adcaf5ab25c62cc46", "patch": "@@ -6383,9 +6383,12 @@ package body Exp_Util is\n       function Are_Wrapped (L : List_Id) return Boolean;\n       --  Determine whether list L contains only one statement which is a block\n \n-      function Wrap_Statements_In_Block (L : List_Id) return Node_Id;\n+      function Wrap_Statements_In_Block\n+        (L    : List_Id;\n+         Scop : Entity_Id := Current_Scope) return Node_Id;\n       --  Given a list of statements L, wrap it in a block statement and return\n-      --  the generated node.\n+      --  the generated node. Scop is either the current scope or the scope of\n+      --  the context (if applicable).\n \n       -----------------\n       -- Are_Wrapped --\n@@ -6404,14 +6407,39 @@ package body Exp_Util is\n       -- Wrap_Statements_In_Block --\n       ------------------------------\n \n-      function Wrap_Statements_In_Block (L : List_Id) return Node_Id is\n+      function Wrap_Statements_In_Block\n+        (L    : List_Id;\n+         Scop : Entity_Id := Current_Scope) return Node_Id\n+      is\n+         Block_Id  : Entity_Id;\n+         Block_Nod : Node_Id;\n+         Iter_Loop : Entity_Id;\n+\n       begin\n-         return\n+         Block_Nod :=\n            Make_Block_Statement (Loc,\n-             Declarations => No_List,\n+             Declarations               => No_List,\n              Handled_Statement_Sequence =>\n                Make_Handled_Sequence_Of_Statements (Loc,\n                  Statements => L));\n+\n+         --  Create a label for the block in case the block needs to manage the\n+         --  secondary stack. A label allows for flag Uses_Sec_Stack to be set.\n+\n+         Add_Block_Identifier (Block_Nod, Block_Id);\n+\n+         --  When wrapping the statements of an iterator loop, check whether\n+         --  the loop requires secondary stack management and if so, propagate\n+         --  the flag to the block. This way the secondary stack is marked and\n+         --  released at each iteration of the loop.\n+\n+         Iter_Loop := Find_Enclosing_Iterator_Loop (Scop);\n+\n+         if Present (Iter_Loop) and then Uses_Sec_Stack (Iter_Loop) then\n+            Set_Uses_Sec_Stack (Block_Id);\n+         end if;\n+\n+         return Block_Nod;\n       end Wrap_Statements_In_Block;\n \n       --  Local variables\n@@ -6475,9 +6503,18 @@ package body Exp_Util is\n               and then not Are_Wrapped (Statements (N))\n               and then Requires_Cleanup_Actions (Statements (N), False, False)\n             then\n-               Block := Wrap_Statements_In_Block (Statements (N));\n-               Set_Statements (N, New_List (Block));\n+               if Nkind (N) = N_Loop_Statement\n+                 and then Present (Identifier (N))\n+               then\n+                  Block :=\n+                    Wrap_Statements_In_Block\n+                      (L    => Statements (N),\n+                       Scop => Entity (Identifier (N)));\n+               else\n+                  Block := Wrap_Statements_In_Block (Statements (N));\n+               end if;\n \n+               Set_Statements (N, New_List (Block));\n                Analyze (Block);\n             end if;\n "}, {"sha": "30c26f0dc07fb67bec201a5df0169a2cea3c01dc", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=7edfb4c6492dc8f503f5277adcaf5ab25c62cc46", "patch": "@@ -2767,20 +2767,46 @@ package body Sem_Ch5 is\n       --  Iteration over a container in Ada 2012 involves the creation of a\n       --  controlled iterator object. Wrap the loop in a block to ensure the\n       --  timely finalization of the iterator and release of container locks.\n+      --  The same applies to the use of secondary stack when obtaining an\n+      --  iterator.\n \n       if Ada_Version >= Ada_2012\n         and then Is_Container_Iterator (Iter)\n         and then not Is_Wrapped_In_Block (N)\n       then\n-         Rewrite (N,\n-           Make_Block_Statement (Loc,\n-             Declarations               => New_List,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => New_List (Relocate_Node (N)))));\n-\n-         Analyze (N);\n-         return;\n+         declare\n+            Block_Nod : Node_Id;\n+            Block_Id  : Entity_Id;\n+\n+         begin\n+            Block_Nod :=\n+              Make_Block_Statement (Loc,\n+                Declarations               => New_List,\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => New_List (Relocate_Node (N))));\n+\n+            Add_Block_Identifier (Block_Nod, Block_Id);\n+\n+            --  The expansion of iterator loops generates an iterator in order\n+            --  to traverse the elements of a container:\n+\n+            --    Iter : <iterator type> := Iterate (Container)'reference;\n+\n+            --  The iterator is controlled and returned on the secondary stack.\n+            --  The analysis of the call to Iterate establishes a transient\n+            --  scope to deal with the secondary stack management, but never\n+            --  really creates a physical block as this would kill the iterator\n+            --  too early (see Wrap_Transient_Declaration). To address this\n+            --  case, mark the generated block as needing secondary stack\n+            --  management.\n+\n+            Set_Uses_Sec_Stack (Block_Id);\n+\n+            Rewrite (N, Block_Nod);\n+            Analyze (N);\n+            return;\n+         end;\n       end if;\n \n       --  Kill current values on entry to loop, since statements in the body of"}, {"sha": "d33c235e9cd435592e61f1a0700c3c3718278319", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=7edfb4c6492dc8f503f5277adcaf5ab25c62cc46", "patch": "@@ -217,6 +217,33 @@ package body Sem_Util is\n       Append_Elmt (A, L);\n    end Add_Access_Type_To_Process;\n \n+   --------------------------\n+   -- Add_Block_Identifier --\n+   --------------------------\n+\n+   procedure Add_Block_Identifier (N : Node_Id; Id : out Entity_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+   begin\n+      pragma Assert (Nkind (N) = N_Block_Statement);\n+\n+      --  The block already has a label, return its entity\n+\n+      if Present (Identifier (N)) then\n+         Id := Entity (Identifier (N));\n+\n+      --  Create a new block label and set its attributes\n+\n+      else\n+         Id := New_Internal_Entity (E_Block, Current_Scope, Loc, 'B');\n+         Set_Etype  (Id, Standard_Void_Type);\n+         Set_Parent (Id, N);\n+\n+         Set_Identifier (N, New_Occurrence_Of (Id, Loc));\n+         Set_Block_Node (Id, Identifier (N));\n+      end if;\n+   end Add_Block_Identifier;\n+\n    -----------------------\n    -- Add_Contract_Item --\n    -----------------------\n@@ -5592,6 +5619,40 @@ package body Sem_Util is\n       raise Program_Error;\n    end Find_Corresponding_Discriminant;\n \n+   ----------------------------------\n+   -- Find_Enclosing_Iterator_Loop --\n+   ----------------------------------\n+\n+   function Find_Enclosing_Iterator_Loop (Id : Entity_Id) return Entity_Id is\n+      Constr : Node_Id;\n+      S      : Entity_Id;\n+\n+   begin\n+      --  Traverse the scope chain looking for an iterator loop. Such loops are\n+      --  usually transformed into blocks, hence the use of Original_Node.\n+\n+      S := Id;\n+      while Present (S) and then S /= Standard_Standard loop\n+         if Ekind (S) = E_Loop\n+           and then Nkind (Parent (S)) = N_Implicit_Label_Declaration\n+         then\n+            Constr := Original_Node (Label_Construct (Parent (S)));\n+\n+            if Nkind (Constr) = N_Loop_Statement\n+              and then Present (Iteration_Scheme (Constr))\n+              and then Nkind (Iterator_Specification (Iteration_Scheme\n+                         (Constr))) = N_Iterator_Specification\n+            then\n+               return S;\n+            end if;\n+         end if;\n+\n+         S := Scope (S);\n+      end loop;\n+\n+      return Empty;\n+   end Find_Enclosing_Iterator_Loop;\n+\n    ------------------------------------\n    -- Find_Loop_In_Conditional_Block --\n    ------------------------------------"}, {"sha": "86a2b5260093e4c77641883461127864ab5464db", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7edfb4c6492dc8f503f5277adcaf5ab25c62cc46/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=7edfb4c6492dc8f503f5277adcaf5ab25c62cc46", "patch": "@@ -43,6 +43,12 @@ package Sem_Util is\n    --  Add A to the list of access types to process when expanding the\n    --  freeze node of E.\n \n+   procedure Add_Block_Identifier (N : Node_Id; Id : out Entity_Id);\n+   --  Given a block statement N, generate an internal E_Block label and make\n+   --  it the identifier of the block. Id denotes the generated entity. If the\n+   --  block already has an identifier, Id denotes the entity of the existing\n+   --  label.\n+\n    procedure Add_Contract_Item (Prag : Node_Id; Id : Entity_Id);\n    --  Add pragma Prag to the contract of an entry, a package [body], a\n    --  subprogram [body] or variable denoted by Id. The following are valid\n@@ -569,6 +575,11 @@ package Sem_Util is\n    --  analyzed. Subsequent uses of this id on a different type denotes the\n    --  discriminant at the same position in this new type.\n \n+   function Find_Enclosing_Iterator_Loop (Id : Entity_Id) return Entity_Id;\n+   --  Given an arbitrary entity, try to find the nearest enclosing iterator\n+   --  loop. If such a loop is found, return the entity of its identifier (the\n+   --  E_Loop scope), otherwise return Empty.\n+\n    function Find_Loop_In_Conditional_Block (N : Node_Id) return Node_Id;\n    --  Find the nested loop statement in a conditional block. Loops subject to\n    --  attribute 'Loop_Entry are transformed into blocks. Parts of the original"}]}