{"sha": "6bd37418a378bec4916ad70403375af00df91938", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJkMzc0MThhMzc4YmVjNDkxNmFkNzA0MDMzNzVhZjAwZGY5MTkzOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-02-19T15:32:34Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-02-19T15:32:34Z"}, "message": "runtime: abort stack scan in cases that we cannot unwind the stack\n    \n    In signal-triggered stack scan, if the signal is delivered at\n    certain bad time (e.g. in vdso, or in the middle of setcontext?),\n    the unwinder may not be able to unwind the whole stack, while it\n    still reports _URC_END_OF_STACK. So we cannot rely on _URC_END_OF_STACK\n    to tell if it successfully scanned the stack. Instead, we check\n    the last Go frame to see it actually reached the end of the stack.\n    For Go-created stack, this is runtime.kickoff. For C-created\n    stack, we need to record the outermost Go frame when it enters\n    the Go side.\n    \n    Also we cannot unwind the stack if the signal is delivered in the\n    middle of runtime.gogo, halfway through a goroutine switch, where\n    the g and the stack don't match. Give up in this case as well.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/159098\n\nFrom-SVN: r269018", "tree": {"sha": "6cc264135130829edd8bf0fa234f727d4f929cc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cc264135130829edd8bf0fa234f727d4f929cc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bd37418a378bec4916ad70403375af00df91938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bd37418a378bec4916ad70403375af00df91938", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bd37418a378bec4916ad70403375af00df91938", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bd37418a378bec4916ad70403375af00df91938/comments", "author": null, "committer": null, "parents": [{"sha": "23c4471ee530a7a752ca8c7eff111aaa39e8d118", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23c4471ee530a7a752ca8c7eff111aaa39e8d118", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23c4471ee530a7a752ca8c7eff111aaa39e8d118"}], "stats": {"total": 76, "additions": 59, "deletions": 17}, "files": [{"sha": "07437d4809c4fb31b9a9bb83b18e1914e1ba9d88", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd37418a378bec4916ad70403375af00df91938/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd37418a378bec4916ad70403375af00df91938/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=6bd37418a378bec4916ad70403375af00df91938", "patch": "@@ -1,4 +1,4 @@\n-9605c2efd99aa9c744652a9153e208e0653b8596\n+672572130ba7a7b277a4c9c8f93576fc42accf63\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "e4d27e8ab67f888df3ea0db70d5133bc3b7f46f7", "filename": "libgo/go/runtime/cgo_gccgo.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd37418a378bec4916ad70403375af00df91938/libgo%2Fgo%2Fruntime%2Fcgo_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd37418a378bec4916ad70403375af00df91938/libgo%2Fgo%2Fruntime%2Fcgo_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcgo_gccgo.go?ref=6bd37418a378bec4916ad70403375af00df91938", "patch": "@@ -80,6 +80,10 @@ func CgocallBack() {\n \t\tgp = getg()\n \t\tmp := gp.m\n \t\tmp.dropextram = true\n+\n+\t\t// This is a C-created stack.\n+\t\t// Record the outermost Go frame to help stack scan.\n+\t\tgp.entrysp = getcallersp()\n \t}\n \n \tlockOSThread()"}, {"sha": "1c944d64752b9b0f978fe4893086e5c8952d36e5", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd37418a378bec4916ad70403375af00df91938/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd37418a378bec4916ad70403375af00df91938/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=6bd37418a378bec4916ad70403375af00df91938", "patch": "@@ -1192,6 +1192,9 @@ func kickoff() {\n \t\tgp.param = nil\n \t}\n \n+\t// Record the entry SP to help stack scan.\n+\tgp.entrysp = getsp()\n+\n \tfv(param)\n \tgoexit1()\n }"}, {"sha": "4f823e09b4be04b221cad522a2c2a128c79535d9", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd37418a378bec4916ad70403375af00df91938/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd37418a378bec4916ad70403375af00df91938/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=6bd37418a378bec4916ad70403375af00df91938", "patch": "@@ -433,6 +433,7 @@ type g struct {\n \n \tentry    func(unsafe.Pointer) // goroutine function to run\n \tentryfn  uintptr              // function address passed to __go_go\n+\tentrysp  uintptr              // the stack pointer of the outermost Go frame\n \tfromgogo bool                 // whether entered from gogo function\n \n \tscanningself bool // whether goroutine is scanning its own stack"}, {"sha": "dfdb38e8010620d9ed47bb40c6b3ea6708f7d53d", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd37418a378bec4916ad70403375af00df91938/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd37418a378bec4916ad70403375af00df91938/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=6bd37418a378bec4916ad70403375af00df91938", "patch": "@@ -231,6 +231,10 @@ func getcallerpc() uintptr\n //go:noescape\n func getcallersp() uintptr // implemented as an intrinsic on all platforms\n \n+// getsp returns the stack pointer (SP) of the caller of getsp.\n+//go:noinline\n+func getsp() uintptr { return getcallersp() }\n+\n func asmcgocall(fn, arg unsafe.Pointer) int32 {\n \tthrow(\"asmcgocall\")\n \treturn 0"}, {"sha": "9fd9596926ab70587c3635d1c04aa91540fd4703", "filename": "libgo/runtime/go-unwind.c", "status": "modified", "additions": 46, "deletions": 16, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bd37418a378bec4916ad70403375af00df91938/libgo%2Fruntime%2Fgo-unwind.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bd37418a378bec4916ad70403375af00df91938/libgo%2Fruntime%2Fgo-unwind.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unwind.c?ref=6bd37418a378bec4916ad70403375af00df91938", "patch": "@@ -649,6 +649,19 @@ findstackmaps (struct _Unwind_Context *context, _Unwind_Ptr *ip, _Unwind_Ptr *sp\n   _sleb128_t index;\n   int size;\n \n+#ifdef HAVE_GETIPINFO\n+  ip1 = _Unwind_GetIPInfo (context, &ip_before_insn);\n+#else\n+  ip1 = _Unwind_GetIP (context);\n+#endif\n+  if (! ip_before_insn)\n+    --ip1;\n+\n+  if (ip != NULL)\n+    *ip = ip1;\n+  if (sp != NULL)\n+    *sp = _Unwind_GetCFA (context);\n+\n #ifdef __ARM_EABI_UNWINDER__\n   {\n     _Unwind_Control_Block *ucbp;\n@@ -672,14 +685,6 @@ findstackmaps (struct _Unwind_Context *context, _Unwind_Ptr *ip, _Unwind_Ptr *sp\n   if (info.TType == NULL)\n     return NOTFOUND_OK;\n \n-#ifdef HAVE_GETIPINFO\n-  ip1 = _Unwind_GetIPInfo (context, &ip_before_insn);\n-#else\n-  ip1 = _Unwind_GetIP (context);\n-#endif\n-  if (! ip_before_insn)\n-    --ip1;\n-\n   size = value_size (info.ttype_encoding);\n \n   action_record = NULL;\n@@ -738,15 +743,16 @@ findstackmaps (struct _Unwind_Context *context, _Unwind_Ptr *ip, _Unwind_Ptr *sp\n   if (stackmap1 == NULL)\n     return NOTFOUND_BAD;\n \n-  if (ip != NULL)\n-    *ip = ip1;\n-  if (sp != NULL)\n-    *sp = _Unwind_GetCFA (context);\n   if (stackmap != NULL)\n     *stackmap = stackmap1;\n   return FOUND;\n }\n \n+struct scanstate {\n+  void* gcw;      // the GC worker, passed into scanstackwithmap_callback\n+  uintptr lastsp; // the last (outermost) SP of Go function seen in a traceback, set by the callback\n+};\n+\n // Callback function to scan a stack frame with stack maps.\n // It skips non-Go functions.\n static _Unwind_Reason_Code\n@@ -755,7 +761,11 @@ scanstackwithmap_callback (struct _Unwind_Context *context, void *arg)\n   struct _stackmap *stackmap;\n   _Unwind_Ptr ip, sp;\n   G* gp;\n-  void *gcw = arg;\n+  struct scanstate* state = (struct scanstate*) arg;\n+  void *gcw;\n+\n+  gp = runtime_g ();\n+  gcw = state->gcw;\n \n   switch (findstackmaps (context, &ip, &sp, &stackmap))\n     {\n@@ -767,7 +777,6 @@ scanstackwithmap_callback (struct _Unwind_Context *context, void *arg)\n           // No stack map found.\n           // If we're scanning from the signal stack, the goroutine\n           // may be not stopped at a safepoint. Allow this case.\n-          gp = runtime_g ();\n           if (gp != gp->m->gsignal)\n             {\n               // TODO: print gp, pc, sp\n@@ -781,6 +790,7 @@ scanstackwithmap_callback (struct _Unwind_Context *context, void *arg)\n         abort ();\n     }\n \n+  state->lastsp = sp;\n   runtime_scanstackblockwithmap (ip, sp, (uintptr)(stackmap->len) * sizeof(uintptr), stackmap->data, gcw);\n \n   return _URC_NO_REASON;\n@@ -792,10 +802,30 @@ bool\n scanstackwithmap (void *gcw)\n {\n   _Unwind_Reason_Code code;\n+  bool ret;\n+  struct scanstate state;\n+  G* gp;\n+  G* curg;\n+\n+  state.gcw = gcw;\n+  state.lastsp = 0;\n+  gp = runtime_g ();\n+  curg = gp->m->curg;\n+\n   runtime_xadd (&__go_runtime_in_callers, 1);\n-  code = _Unwind_Backtrace (scanstackwithmap_callback, gcw);\n+  code = _Unwind_Backtrace (scanstackwithmap_callback, (void*)&state);\n   runtime_xadd (&__go_runtime_in_callers, -1);\n-  return code == _URC_END_OF_STACK;\n+  ret = (code == _URC_END_OF_STACK);\n+  if (ret && gp == gp->m->gsignal)\n+    {\n+      // For signal-triggered scan, the unwinder may not be able to unwind\n+      // the whole stack while it still reports _URC_END_OF_STACK (e.g.\n+      // signal is delivered in vdso). Check that we actually reached the\n+      // the end of the stack, that is, the SP on entry.\n+      if (state.lastsp != curg->entrysp)\n+        ret = false;\n+    }\n+  return ret;\n }\n \n // Returns whether stack map is enabled."}]}