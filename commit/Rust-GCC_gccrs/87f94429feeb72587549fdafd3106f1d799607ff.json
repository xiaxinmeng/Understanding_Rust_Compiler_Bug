{"sha": "87f94429feeb72587549fdafd3106f1d799607ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdmOTQ0MjlmZWViNzI1ODc1NDlmZGFmZDMxMDZmMWQ3OTk2MDdmZg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-10-30T07:56:22Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-10-30T07:56:22Z"}, "message": "Remove cgraph_local_info structure.\n\n2019-10-30  Martin Liska  <mliska@suse.cz>\n\n\t* cgraph.c (cgraph_node::local_info): Transform to ...\n\t(cgraph_node::local_info_node): ... this.\n\t(cgraph_node::dump): Remove cgraph_local_info and\n\tput its fields directly into cgraph_node.\n\t(cgraph_node::get_availability): Likewise.\n\t(cgraph_node::make_local): Likewise.\n\t(cgraph_node::verify_node): Likewise.\n\t* cgraph.h (struct GTY): Likewise.\n\t* cgraphclones.c (set_new_clone_decl_and_node_flags): Likewise.\n\t(duplicate_thunk_for_node): Likewise.\n\t(cgraph_node::create_clone): Likewise.\n\t(cgraph_node::create_virtual_clone): Likewise.\n\t(cgraph_node::create_version_clone): Likewise.\n\t* cgraphunit.c (cgraph_node::reset): Likewise.\n\t(cgraph_node::finalize_function): Likewise.\n\t(cgraph_node::add_new_function): Likewise.\n\t(analyze_functions): Likewise.\n\t* combine.c (setup_incoming_promotions): Likewise.\n\t* config/i386/i386.c (ix86_function_regparm): Likewise.\n\t(ix86_function_sseregparm): Likewise.\n\t(init_cumulative_args): Likewise.\n\t* ipa-cp.c (determine_versionability): Likewise.\n\t(count_callers): Likewise.\n\t(set_single_call_flag): Likewise.\n\t(initialize_node_lattices): Likewise.\n\t(estimate_local_effects): Likewise.\n\t(create_specialized_node): Likewise.\n\t(identify_dead_nodes): Likewise.\n\t* ipa-fnsummary.c (compute_fn_summary): Likewise.\n\t(ipa_fn_summary_generate): Likewise.\n\t* ipa-hsa.c (check_warn_node_versionable): Likewise.\n\t(process_hsa_functions): Likewise.\n\t* ipa-icf.c (set_local): Likewise.\n\t* ipa-inline-analysis.c (initialize_inline_failed): Likewise.\n\t* ipa-inline.c (speculation_useful_p): Likewise.\n\t* ipa-profile.c (ipa_propagate_frequency): Likewise.\n\t(ipa_profile): Likewise.\n\t* ipa-split.c (split_function): Likewise.\n\t(execute_split_functions): Likewise.\n\t* ipa-sra.c (ipa_sra_preliminary_function_checks): Likewise.\n\t(ipa_sra_ipa_function_checks): Likewise.\n\t* ipa-visibility.c (function_and_variable_visibility): Likewise.\n\t* ipa.c (symbol_table::remove_unreachable_nodes): Likewise.\n\t* lto-cgraph.c (lto_output_node): Likewise.\n\t(input_overwrite_node): Likewise.\n\t* multiple_target.c (expand_target_clones): Likewise.\n\t* omp-simd-clone.c (simd_clone_create): Likewise.\n\t* trans-mem.c (expand_call_tm): Likewise.\n\t(ipa_tm_mayenterirr_function): Likewise.\n\t(ipa_tm_diagnose_tm_safe): Likewise.\n\t(ipa_tm_diagnose_transaction): Likewise.\n\t(ipa_tm_create_version): Likewise.\n\t(ipa_tm_transform_calls_redirect): Likewise.\n\t(ipa_tm_execute): Likewise.\n\t* tree-inline.c (expand_call_inline): Likewise.\n\nFrom-SVN: r277601", "tree": {"sha": "08ffc5d297681144170e188457770e59e6573fe1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08ffc5d297681144170e188457770e59e6573fe1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87f94429feeb72587549fdafd3106f1d799607ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87f94429feeb72587549fdafd3106f1d799607ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87f94429feeb72587549fdafd3106f1d799607ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87f94429feeb72587549fdafd3106f1d799607ff/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a62bfab5d2a332925fcf10c45b4c5d8ca499439d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a62bfab5d2a332925fcf10c45b4c5d8ca499439d"}], "stats": {"total": 272, "additions": 160, "deletions": 112}, "files": [{"sha": "72d6ec76e9e3ca31062c3a73e644478909430582", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -1,3 +1,61 @@\n+2019-10-30  Martin Liska  <mliska@suse.cz>\n+\n+\t* cgraph.c (cgraph_node::local_info): Transform to ...\n+\t(cgraph_node::local_info_node): ... this.\n+\t(cgraph_node::dump): Remove cgraph_local_info and\n+\tput its fields directly into cgraph_node.\n+\t(cgraph_node::get_availability): Likewise.\n+\t(cgraph_node::make_local): Likewise.\n+\t(cgraph_node::verify_node): Likewise.\n+\t* cgraph.h (struct GTY): Likewise.\n+\t* cgraphclones.c (set_new_clone_decl_and_node_flags): Likewise.\n+\t(duplicate_thunk_for_node): Likewise.\n+\t(cgraph_node::create_clone): Likewise.\n+\t(cgraph_node::create_virtual_clone): Likewise.\n+\t(cgraph_node::create_version_clone): Likewise.\n+\t* cgraphunit.c (cgraph_node::reset): Likewise.\n+\t(cgraph_node::finalize_function): Likewise.\n+\t(cgraph_node::add_new_function): Likewise.\n+\t(analyze_functions): Likewise.\n+\t* combine.c (setup_incoming_promotions): Likewise.\n+\t* config/i386/i386.c (ix86_function_regparm): Likewise.\n+\t(ix86_function_sseregparm): Likewise.\n+\t(init_cumulative_args): Likewise.\n+\t* ipa-cp.c (determine_versionability): Likewise.\n+\t(count_callers): Likewise.\n+\t(set_single_call_flag): Likewise.\n+\t(initialize_node_lattices): Likewise.\n+\t(estimate_local_effects): Likewise.\n+\t(create_specialized_node): Likewise.\n+\t(identify_dead_nodes): Likewise.\n+\t* ipa-fnsummary.c (compute_fn_summary): Likewise.\n+\t(ipa_fn_summary_generate): Likewise.\n+\t* ipa-hsa.c (check_warn_node_versionable): Likewise.\n+\t(process_hsa_functions): Likewise.\n+\t* ipa-icf.c (set_local): Likewise.\n+\t* ipa-inline-analysis.c (initialize_inline_failed): Likewise.\n+\t* ipa-inline.c (speculation_useful_p): Likewise.\n+\t* ipa-profile.c (ipa_propagate_frequency): Likewise.\n+\t(ipa_profile): Likewise.\n+\t* ipa-split.c (split_function): Likewise.\n+\t(execute_split_functions): Likewise.\n+\t* ipa-sra.c (ipa_sra_preliminary_function_checks): Likewise.\n+\t(ipa_sra_ipa_function_checks): Likewise.\n+\t* ipa-visibility.c (function_and_variable_visibility): Likewise.\n+\t* ipa.c (symbol_table::remove_unreachable_nodes): Likewise.\n+\t* lto-cgraph.c (lto_output_node): Likewise.\n+\t(input_overwrite_node): Likewise.\n+\t* multiple_target.c (expand_target_clones): Likewise.\n+\t* omp-simd-clone.c (simd_clone_create): Likewise.\n+\t* trans-mem.c (expand_call_tm): Likewise.\n+\t(ipa_tm_mayenterirr_function): Likewise.\n+\t(ipa_tm_diagnose_tm_safe): Likewise.\n+\t(ipa_tm_diagnose_transaction): Likewise.\n+\t(ipa_tm_create_version): Likewise.\n+\t(ipa_tm_transform_calls_redirect): Likewise.\n+\t(ipa_tm_execute): Likewise.\n+\t* tree-inline.c (expand_call_inline): Likewise.\n+\n 2019-10-29  Martin Liska  <mliska@suse.cz>\n \n \t* symbol-summary.h (function_summary): Pass memory location"}, {"sha": "33fba5a8f1c7e0cb216293995de34b50f726e6fd", "filename": "gcc/cgraph.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -1834,16 +1834,16 @@ cgraph_node::mark_address_taken (void)\n   node->address_taken = 1;\n }\n \n-/* Return local info for the compiled function.  */\n+/* Return local info node for the compiled function.  */\n \n-cgraph_local_info *\n-cgraph_node::local_info (tree decl)\n+cgraph_node *\n+cgraph_node::local_info_node (tree decl)\n {\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n   cgraph_node *node = get (decl);\n   if (!node)\n     return NULL;\n-  return &node->ultimate_alias_target ()->local;\n+  return node->ultimate_alias_target ();\n }\n \n /* Return RTL info for the compiled function.  */\n@@ -1991,9 +1991,9 @@ cgraph_node::dump (FILE *f)\n     fprintf (f, \" body\");\n   if (process)\n     fprintf (f, \" process\");\n-  if (local.local)\n+  if (local)\n     fprintf (f, \" local\");\n-  if (local.redefined_extern_inline)\n+  if (redefined_extern_inline)\n     fprintf (f, \" redefined_extern_inline\");\n   if (only_called_at_startup)\n     fprintf (f, \" only_called_at_startup\");\n@@ -2217,7 +2217,7 @@ cgraph_node::get_availability (symtab_node *ref)\n   enum availability avail;\n   if (!analyzed)\n     avail = AVAIL_NOT_AVAILABLE;\n-  else if (local.local)\n+  else if (local)\n     avail = AVAIL_LOCAL;\n   else if (inlined_to)\n     avail = AVAIL_AVAILABLE;\n@@ -2340,7 +2340,7 @@ cgraph_node::make_local (cgraph_node *node, void *)\n       node->set_comdat_group (NULL);\n       node->externally_visible = false;\n       node->forced_by_abi = false;\n-      node->local.local = true;\n+      node->local = true;\n       node->set_section (NULL);\n       node->unique_name = ((node->resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t\t   || node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n@@ -3090,7 +3090,7 @@ cgraph_node::verify_node (void)\n       error (\"inline clone in same comdat group list\");\n       error_found = true;\n     }\n-  if (!definition && !in_other_partition && local.local)\n+  if (!definition && !in_other_partition && local)\n     {\n       error (\"local symbols must be defined\");\n       error_found = true;"}, {"sha": "0c5a6960d103e891741bd140c5e2b01ecec0e8ed", "filename": "gcc/cgraph.h", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -707,29 +707,6 @@ struct GTY(()) cgraph_thunk_info {\n   bool thunk_p;\n };\n \n-/* Information about the function collected locally.\n-   Available after function is analyzed.  */\n-\n-struct GTY(()) cgraph_local_info {\n-  /* Set when function is visible in current compilation unit only and\n-     its address is never taken.  */\n-  unsigned local : 1;\n-\n-  /* False when there is something makes versioning impossible.  */\n-  unsigned versionable : 1;\n-\n-  /* False when function calling convention and signature cannot be changed.\n-     This is the case when __builtin_apply_args is used.  */\n-  unsigned can_change_signature : 1;\n-\n-  /* True when the function has been originally extern inline, but it is\n-     redefined now.  */\n-  unsigned redefined_extern_inline : 1;\n-\n-  /* True if the function may enter serial irrevocable mode.  */\n-  unsigned tm_may_enter_irr : 1;\n-};\n-\n /* Represent which DECL tree (or reference to such tree)\n    will be replaced by another tree while versioning.  */\n struct GTY(()) ipa_replace_map\n@@ -1370,7 +1347,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   static cgraph_node * get_create (tree);\n \n   /* Return local info for the compiled function.  */\n-  static cgraph_local_info *local_info (tree decl);\n+  static cgraph_node *local_info_node (tree decl);\n \n   /* Return RTL info for the compiled function.  */\n   static struct cgraph_rtl_info *rtl_info (const_tree);\n@@ -1436,8 +1413,6 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n      per-function in order to allow IPA passes to introduce new functions.  */\n   vec<ipa_opt_pass> GTY((skip)) ipa_transforms_to_apply;\n \n-  cgraph_local_info local;\n-\n   /* For inline clones this points to the function they will be\n      inlined into.  */\n   cgraph_node *inlined_to;\n@@ -1495,6 +1470,19 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   unsigned split_part : 1;\n   /* True if the function appears as possible target of indirect call.  */\n   unsigned indirect_call_target : 1;\n+  /* Set when function is visible in current compilation unit only and\n+     its address is never taken.  */\n+  unsigned local : 1;\n+  /* False when there is something makes versioning impossible.  */\n+  unsigned versionable : 1;\n+  /* False when function calling convention and signature cannot be changed.\n+     This is the case when __builtin_apply_args is used.  */\n+  unsigned can_change_signature : 1;\n+  /* True when the function has been originally extern inline, but it is\n+     redefined now.  */\n+  unsigned redefined_extern_inline : 1;\n+  /* True if the function may enter serial irrevocable mode.  */\n+  unsigned tm_may_enter_irr : 1;\n \n private:\n   /* Unique id of the node.  */"}, {"sha": "84d6e71a20b81453dc95e51c582c4f79c0c2dd75", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -159,7 +159,7 @@ set_new_clone_decl_and_node_flags (cgraph_node *new_node)\n   DECL_SET_IS_OPERATOR_DELETE (new_node->decl, 0);\n \n   new_node->externally_visible = 0;\n-  new_node->local.local = 1;\n+  new_node->local = 1;\n   new_node->lowered = true;\n }\n \n@@ -223,7 +223,7 @@ duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)\n   new_thunk = cgraph_node::create (new_decl);\n   set_new_clone_decl_and_node_flags (new_thunk);\n   new_thunk->definition = true;\n-  new_thunk->local.can_change_signature = node->local.can_change_signature;\n+  new_thunk->can_change_signature = node->can_change_signature;\n   new_thunk->thunk = thunk->thunk;\n   new_thunk->unique_name = in_lto_p;\n   new_thunk->former_clone_of = thunk->decl;\n@@ -353,10 +353,13 @@ cgraph_node::create_clone (tree new_decl, profile_count prof_count,\n     }\n   new_node->analyzed = analyzed;\n   new_node->definition = definition;\n-  new_node->local = local;\n+  new_node->versionable = versionable;\n+  new_node->can_change_signature = can_change_signature;\n+  new_node->redefined_extern_inline = redefined_extern_inline;\n+  new_node->tm_may_enter_irr = tm_may_enter_irr;\n   new_node->externally_visible = false;\n   new_node->no_reorder = no_reorder;\n-  new_node->local.local = true;\n+  new_node->local = true;\n   new_node->inlined_to = new_inlined_to;\n   new_node->rtl = rtl;\n   new_node->frequency = frequency;\n@@ -524,11 +527,11 @@ cgraph_node::create_virtual_clone (vec<cgraph_edge *> redirect_callers,\n   ipa_replace_map *map;\n   char *name;\n \n-  gcc_checking_assert (local.versionable);\n+  gcc_checking_assert (versionable);\n   /* TODO: It would be nice if we could recognize that param_adjustments do not\n      actually perform any changes, but at the moment let's require it simply\n      does not exist.  */\n-  gcc_assert (local.can_change_signature || !param_adjustments);\n+  gcc_assert (can_change_signature || !param_adjustments);\n \n   /* Make a new FUNCTION_DECL tree node */\n   if (!param_adjustments)\n@@ -860,7 +863,7 @@ cgraph_node::create_version_clone (tree new_decl,\n    new_version->local = local;\n    new_version->externally_visible = false;\n    new_version->no_reorder = no_reorder;\n-   new_version->local.local = new_version->definition;\n+   new_version->local = new_version->definition;\n    new_version->inlined_to = inlined_to;\n    new_version->rtl = rtl;\n    new_version->count = count;\n@@ -931,7 +934,7 @@ cgraph_node::create_version_clone_with_body\n     return NULL;\n \n   /* TODO: Restore an assert that we do not change signature if\n-     local.can_change_signature is false.  We cannot just check that\n+     can_change_signature is false.  We cannot just check that\n      param_adjustments is NULL because unfortunately ipa-split removes return\n      values from such functions.  */\n \n@@ -987,7 +990,7 @@ cgraph_node::create_version_clone_with_body\n   new_version_node->make_decl_local ();\n   DECL_VIRTUAL_P (new_version_node->decl) = 0;\n   new_version_node->externally_visible = 0;\n-  new_version_node->local.local = 1;\n+  new_version_node->local = 1;\n   new_version_node->lowered = true;\n   if (!implicit_section)\n     new_version_node->set_section (get_section ());"}, {"sha": "5bb4ec8e8ced4ba28eff8ddd1dc75d9548415acf", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -391,7 +391,6 @@ cgraph_node::reset (void)\n   gcc_assert (!process);\n \n   /* Reset our data structures so we can analyze the function again.  */\n-  memset (&local, 0, sizeof (local));\n   inlined_to = NULL;\n   memset (&rtl, 0, sizeof (rtl));\n   analyzed = false;\n@@ -445,7 +444,7 @@ cgraph_node::finalize_function (tree decl, bool no_collect)\n       gcc_assert (!DECL_CONTEXT (decl)\n \t\t  || TREE_CODE (DECL_CONTEXT (decl)) !=\tFUNCTION_DECL);\n       node->reset ();\n-      node->local.redefined_extern_inline = true;\n+      node->redefined_extern_inline = true;\n     }\n \n   /* Set definition first before calling notice_global_symbol so that\n@@ -553,7 +552,7 @@ cgraph_node::add_new_function (tree fndecl, bool lowered)\n \t/* Bring the function into finalized state and enqueue for later\n \t   analyzing and compilation.  */\n \tnode = cgraph_node::get_create (fndecl);\n-\tnode->local.local = false;\n+\tnode->local = false;\n \tnode->definition = true;\n \tnode->force_output = true;\n \tif (TREE_PUBLIC (fndecl))\n@@ -1121,7 +1120,7 @@ analyze_functions (bool first_time)\n \t\t  && !cnode->dispatcher_function)\n \t\t{\n \t\t  cnode->reset ();\n-\t\t  cnode->local.redefined_extern_inline = true;\n+\t\t  cnode->redefined_extern_inline = true;\n \t\t  continue;\n \t\t}\n "}, {"sha": "857ea30dafd917445220de42a845ff5c65275e8b", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -1600,7 +1600,8 @@ setup_incoming_promotions (rtx_insn *first)\n          function lie within the current compilation unit.  (This does\n \t take into account the exporting of a function via taking its\n \t address, and so forth.)  */\n-      strictly_local = cgraph_node::local_info (current_function_decl)->local;\n+      strictly_local\n+\t= cgraph_node::local_info_node (current_function_decl)->local;\n \n       /* The mode and signedness of the argument before any promotions happen\n          (equal to the mode of the pseudo holding it at that stage).  */"}, {"sha": "b9122a4ded92f27276fb36ee597e56e3f8e1c3e7", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -1119,8 +1119,7 @@ ix86_function_regparm (const_tree type, const_tree decl)\n       if (target && opt_for_fn (target->decl, optimize)\n \t  && !(profile_flag && !flag_fentry))\n \t{\n-\t  cgraph_local_info *i = &target->local;\n-\t  if (i && i->local && i->can_change_signature)\n+\t  if (target->local && target->can_change_signature)\n \t    {\n \t      int local_regparm, globals = 0, regno;\n \n@@ -1216,8 +1215,7 @@ ix86_function_sseregparm (const_tree type, const_tree decl, bool warn)\n       && opt_for_fn (target->decl, optimize)\n       && !(profile_flag && !flag_fentry))\n     {\n-      cgraph_local_info *i = &target->local;\n-      if (i && i->local && i->can_change_signature)\n+      if (target->local && target->can_change_signature)\n \t{\n \t  /* Refuse to produce wrong code when local function with SSE enabled\n \t     is called from SSE disabled function.\n@@ -1698,7 +1696,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n \t\t      tree fndecl,\n \t\t      int caller)\n {\n-  struct cgraph_local_info *i = NULL;\n+  struct cgraph_node *local_info_node = NULL;\n   struct cgraph_node *target = NULL;\n \n   memset (cum, 0, sizeof (*cum));\n@@ -1709,7 +1707,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n       if (target)\n \t{\n \t  target = target->function_symbol ();\n-\t  i = cgraph_node::local_info (target->decl);\n+\t  local_info_node = cgraph_node::local_info_node (target->decl);\n \t  cum->call_abi = ix86_function_abi (target->decl);\n \t}\n       else\n@@ -1751,7 +1749,8 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n      va_start so for local functions maybe_vaarg can be made aggressive\n      helping K&R code.\n      FIXME: once typesytem is fixed, we won't need this code anymore.  */\n-  if (i && i->local && i->can_change_signature)\n+  if (local_info_node && local_info_node->local\n+      && local_info_node->can_change_signature)\n     fntype = TREE_TYPE (target->decl);\n   cum->stdarg = stdarg_p (fntype);\n   cum->maybe_vaarg = (fntype"}, {"sha": "8a5f8d362f6f31a130bca7e5a20bfbcd8e616984", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -594,7 +594,7 @@ determine_versionability (struct cgraph_node *node,\n      present.  */\n   if (node->alias || node->thunk.thunk_p)\n     reason = \"alias or thunk\";\n-  else if (!node->local.versionable)\n+  else if (!node->versionable)\n     reason = \"not a tree_versionable_function\";\n   else if (node->get_availability () <= AVAIL_INTERPOSABLE)\n     reason = \"insufficient body availability\";\n@@ -1150,7 +1150,7 @@ count_callers (cgraph_node *node, void *data)\n   for (cgraph_edge *cs = node->callers; cs; cs = cs->next_caller)\n     /* Local thunks can be handled transparently, but if the thunk cannot\n        be optimized out, count it as a real use.  */\n-    if (!cs->caller->thunk.thunk_p || !cs->caller->local.local)\n+    if (!cs->caller->thunk.thunk_p || !cs->caller->local)\n       ++*caller_count;\n   return false;\n }\n@@ -1163,7 +1163,7 @@ set_single_call_flag (cgraph_node *node, void *)\n {\n   cgraph_edge *cs = node->callers;\n   /* Local thunks can be handled transparently, skip them.  */\n-  while (cs && cs->caller->thunk.thunk_p && cs->caller->local.local)\n+  while (cs && cs->caller->thunk.thunk_p && cs->caller->local)\n     cs = cs->next_caller;\n   if (cs)\n     {\n@@ -1187,7 +1187,7 @@ initialize_node_lattices (struct cgraph_node *node)\n \n   if (!ipa_get_param_count (info))\n     disable = true;\n-  else if (node->local.local)\n+  else if (node->local)\n     {\n       int caller_count = 0;\n       node->call_for_symbol_thunks_and_aliases (count_callers, &caller_count,\n@@ -2935,7 +2935,7 @@ estimate_local_effects (struct cgraph_node *node)\n   int devirt_bonus = devirtualization_time_bonus (node, known_csts,\n \t\t\t\t\t   known_contexts, known_aggs_ptrs);\n   if (always_const || devirt_bonus\n-      || (removable_params_cost && node->local.can_change_signature))\n+      || (removable_params_cost && node->can_change_signature))\n     {\n       struct caller_statistics stats;\n       ipa_hints hints;\n@@ -2957,7 +2957,7 @@ estimate_local_effects (struct cgraph_node *node)\n \tfprintf (dump_file, \" - context independent values, size: %i, \"\n \t\t \"time_benefit: %f\\n\", size, (base_time - time).to_double ());\n \n-      if (size <= 0 || node->local.local)\n+      if (size <= 0 || node->local)\n \t{\n \t  info->do_clone_for_all_contexts = true;\n \n@@ -3892,7 +3892,7 @@ create_specialized_node (struct cgraph_node *node,\n   ipa_param_adjustments *old_adjustments = node->clone.param_adjustments;\n   ipa_param_adjustments *new_adjustments;\n   gcc_assert (!info->ipcp_orig_node);\n-  gcc_assert (node->local.can_change_signature\n+  gcc_assert (node->can_change_signature\n \t      || !old_adjustments);\n \n   if (old_adjustments)\n@@ -3907,7 +3907,7 @@ create_specialized_node (struct cgraph_node *node,\n       for (i = 0; i < old_adj_count; i++)\n \t{\n \t  ipa_adjusted_param *old_adj = &(*old_adjustments->m_adj_params)[i];\n-\t  if (!node->local.can_change_signature\n+\t  if (!node->can_change_signature\n \t      || old_adj->op != IPA_PARAM_OP_COPY\n \t      || (!known_csts[old_adj->base_index]\n \t\t  && ipa_is_param_used (info, old_adj->base_index)))\n@@ -3924,7 +3924,7 @@ create_specialized_node (struct cgraph_node *node,\n \t\t\t ipa_param_adjustments (new_params, count,\n \t\t\t\t\t\tskip_return));\n     }\n-  else if (node->local.can_change_signature\n+  else if (node->can_change_signature\n \t   && want_remove_some_param_p (node, known_csts))\n     {\n       ipa_adjusted_param adj;\n@@ -4990,7 +4990,7 @@ identify_dead_nodes (struct cgraph_node *node)\n {\n   struct cgraph_node *v;\n   for (v = node; v; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n-    if (v->local.local\n+    if (v->local\n \t&& !v->call_for_symbol_thunks_and_aliases\n \t     (has_undead_caller_from_outside_scc_p, NULL, true))\n       IPA_NODE_REF (v)->node_dead = 1;"}, {"sha": "795e96566237d578100a4b42969919acd8b32055", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -2712,7 +2712,7 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n       ipa_call_summary *es = ipa_call_summaries->get_create (node->callees);\n       predicate t = true;\n \n-      node->local.can_change_signature = false;\n+      node->can_change_signature = false;\n       es->call_stmt_size = eni_size_weights.call_cost;\n       es->call_stmt_time = eni_time_weights.call_cost;\n       info->account_size_time (ipa_fn_summary::size_scale\n@@ -2751,12 +2751,12 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n \t      with simd attribute.  */\n \t   || lookup_attribute (\"omp declare simd\",\n \t\t\t\tDECL_ATTRIBUTES (node->decl)))\n-\t node->local.can_change_signature = false;\n+\t node->can_change_signature = false;\n        else\n \t {\n \t   /* Otherwise, inlinable functions always can change signature.  */\n \t   if (info->inlinable)\n-\t     node->local.can_change_signature = true;\n+\t     node->can_change_signature = true;\n \t   else\n \t     {\n \t       /* Functions calling builtin_apply cannot change signature.  */\n@@ -2767,7 +2767,7 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n \t\t       || fndecl_built_in_p (cdecl, BUILT_IN_VA_START))\n \t\t     break;\n \t\t }\n-\t       node->local.can_change_signature = !e;\n+\t       node->can_change_signature = !e;\n \t     }\n \t }\n        analyze_function_body (node, early);\n@@ -3485,7 +3485,7 @@ ipa_fn_summary_generate (void)\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (DECL_STRUCT_FUNCTION (node->decl))\n-      node->local.versionable = tree_versionable_function_p (node->decl);\n+      node->versionable = tree_versionable_function_p (node->decl);\n \n   ipa_fn_summary_alloc ();\n "}, {"sha": "32280f3acac72a3d86638f8f5a15ad6c25acb0c4", "filename": "gcc/ipa-hsa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-hsa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-hsa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-hsa.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -51,7 +51,7 @@ namespace {\n static bool\n check_warn_node_versionable (cgraph_node *node)\n {\n-  if (!node->local.versionable)\n+  if (!node->versionable)\n     {\n       warning_at (EXPR_LOCATION (node->decl), OPT_Whsa,\n \t\t  \"could not emit HSAIL for function %s: function cannot be \"\n@@ -113,7 +113,7 @@ process_hsa_functions (void)\n \t  TREE_PUBLIC (clone->decl) = TREE_PUBLIC (node->decl);\n \t  clone->externally_visible = node->externally_visible;\n \n-\t  if (!node->local.local)\n+\t  if (!node->local)\n \t    clone->force_output = true;\n \t  hsa_summaries->link_functions (clone, node, HSA_FUNCTION, false);\n "}, {"sha": "0d17fe990fc4fe01b830dc6c9043e7e711a028d5", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -926,7 +926,7 @@ sem_function::equals_private (sem_item *item)\n static bool\n set_local (cgraph_node *node, void *data)\n {\n-  node->local.local = data != NULL;\n+  node->local = data != NULL;\n   return false;\n }\n "}, {"sha": "fb3299d896f97e079bd0833f92a2338e02560692", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -68,7 +68,7 @@ initialize_inline_failed (struct cgraph_edge *e)\n     e->inline_failed = CIF_INDIRECT_UNKNOWN_CALL;\n   else if (!callee->definition)\n     e->inline_failed = CIF_BODY_NOT_AVAILABLE;\n-  else if (callee->local.redefined_extern_inline)\n+  else if (callee->redefined_extern_inline)\n     e->inline_failed = CIF_REDEFINED_EXTERN_INLINE;\n   else\n     e->inline_failed = CIF_FUNCTION_NOT_CONSIDERED;"}, {"sha": "05bc8e70677fe243d6e567cfa1d62837ed805551", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -1757,7 +1757,7 @@ speculation_useful_p (struct cgraph_edge *e, bool anticipate_inlining)\n      to an ipa-cp clone (that are seen by having local flag set),\n      it is probably pointless to inline it unless hardware is missing\n      indirect call predictor.  */\n-  if (!anticipate_inlining && !target->local.local)\n+  if (!anticipate_inlining && !target->local)\n     return false;\n   /* For overwritable targets there is not much to do.  */\n   if (!can_inline_edge_p (e, false)"}, {"sha": "a1acd2e413a5f3c955ceeef33806140b8f3719c5", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -393,7 +393,7 @@ ipa_propagate_frequency (struct cgraph_node *node)\n \n   /* We cannot propagate anything useful about externally visible functions\n      nor about virtuals.  */\n-  if (!node->local.local\n+  if (!node->local\n       || node->alias\n       || (opt_for_fn (node->decl, flag_devirtualize)\n \t  && DECL_VIRTUAL_P (node->decl)))\n@@ -682,12 +682,12 @@ ipa_profile (void)\n   order_pos = ipa_reverse_postorder (order);\n   for (i = order_pos - 1; i >= 0; i--)\n     {\n-      if (order[i]->local.local\n+      if (order[i]->local\n \t  && opt_for_fn (order[i]->decl, flag_ipa_profile)\n \t  && ipa_propagate_frequency (order[i]))\n \t{\n \t  for (e = order[i]->callees; e; e = e->next_callee)\n-\t    if (e->callee->local.local && !e->callee->aux)\n+\t    if (e->callee->local && !e->callee->aux)\n \t      {\n \t        something_changed = true;\n \t        e->callee->aux = (void *)1;\n@@ -706,7 +706,7 @@ ipa_profile (void)\n \t      && ipa_propagate_frequency (order[i]))\n \t    {\n \t      for (e = order[i]->callees; e; e = e->next_callee)\n-\t\tif (e->callee->local.local && !e->callee->aux)\n+\t\tif (e->callee->local && !e->callee->aux)\n \t\t  {\n \t\t    something_changed = true;\n \t\t    e->callee->aux = (void *)1;"}, {"sha": "0444bda704d3fede7d28098544e1623b112b6c57", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -1204,7 +1204,7 @@ split_function (basic_block return_bb, class split_point *split_point,\n       dump_split_point (dump_file, split_point);\n     }\n \n-  if (cur_node->local.can_change_signature)\n+  if (cur_node->can_change_signature)\n     args_to_skip = BITMAP_ALLOC (NULL);\n   else\n     args_to_skip = NULL;\n@@ -1757,7 +1757,7 @@ execute_split_functions (void)\n      then inlining would still benefit.  */\n   if ((!node->callers\n        /* Local functions called once will be completely inlined most of time.  */\n-       || (!node->callers->next_caller && node->local.local))\n+       || (!node->callers->next_caller && node->local))\n       && !node->address_taken\n       && !node->has_aliases_p ()\n       && (!flag_lto || !node->externally_visible))"}, {"sha": "ad11d6f85555f7dc5f64a0ada602fa3935b30766", "filename": "gcc/ipa-sra.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -552,7 +552,7 @@ struct obstack gensum_obstack;\n static bool\n ipa_sra_preliminary_function_checks (cgraph_node *node)\n {\n-  if (!node->local.can_change_signature)\n+  if (!node->can_change_signature)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Function cannot change signature.\\n\");\n@@ -2882,7 +2882,7 @@ ipa_sra_ipa_function_checks (cgraph_node *node)\n \t\t \"made local.\\n\", node->dump_name ());\n       return false;\n     }\n-  if (!node->local.can_change_signature)\n+  if (!node->can_change_signature)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Function can not change signature.\\n\");"}, {"sha": "f470465f93591eb5c956ac41335a31fb1f763cd4", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -747,8 +747,8 @@ function_and_variable_visibility (bool whole_program)\n     }\n   FOR_EACH_DEFINED_FUNCTION (node)\n     {\n-      if (!node->local.local)\n-        node->local.local |= node->local_p ();\n+      if (!node->local)\n+\tnode->local |= node->local_p ();\n \n       /* If we know that function cannot be overwritten by a\n \t different semantics and moreover its section cannot be\n@@ -868,7 +868,7 @@ function_and_variable_visibility (bool whole_program)\n     {\n       fprintf (dump_file, \"\\nMarking local functions:\");\n       FOR_EACH_DEFINED_FUNCTION (node)\n-\tif (node->local.local)\n+\tif (node->local)\n \t  fprintf (dump_file, \" %s\", node->name ());\n       fprintf (dump_file, \"\\n\\n\");\n       fprintf (dump_file, \"\\nMarking externally visible functions:\");"}, {"sha": "934e49785f3a1fc5ea079e74476234b7c1e59964", "filename": "gcc/ipa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -544,7 +544,7 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n \t\t= remove_attribute (\"always_inline\",\n \t\t\t\t    DECL_ATTRIBUTES (node->decl));\n \t      if (!node->in_other_partition)\n-\t\tnode->local.local = false;\n+\t\tnode->local = false;\n \t      node->remove_callees ();\n \t      node->remove_all_references ();\n \t      changed = true;\n@@ -655,7 +655,7 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n \t\t    || !node->call_for_symbol_and_aliases\n \t\t       (is_indirect_call_target_p, NULL, true)))\n \t      {\n-\t\tnode->local.local = true;\n+\t\tnode->local = true;\n \t\tif (file)\n \t\t  fprintf (file, \" (local)\");\n \t      }"}, {"sha": "5b11150bc2f76ea8affdefdd73d78d732fcf9a56", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -507,13 +507,13 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   streamer_write_hwi_stream (ob->main_stream, node->tp_first_run);\n \n   bp = bitpack_create (ob->main_stream);\n-  bp_pack_value (&bp, node->local.local, 1);\n+  bp_pack_value (&bp, node->local, 1);\n   bp_pack_value (&bp, node->externally_visible, 1);\n   bp_pack_value (&bp, node->no_reorder, 1);\n   bp_pack_value (&bp, node->definition, 1);\n-  bp_pack_value (&bp, node->local.versionable, 1);\n-  bp_pack_value (&bp, node->local.can_change_signature, 1);\n-  bp_pack_value (&bp, node->local.redefined_extern_inline, 1);\n+  bp_pack_value (&bp, node->versionable, 1);\n+  bp_pack_value (&bp, node->can_change_signature, 1);\n+  bp_pack_value (&bp, node->redefined_extern_inline, 1);\n   bp_pack_value (&bp, node->force_output, 1);\n   bp_pack_value (&bp, node->forced_by_abi, 1);\n   bp_pack_value (&bp, node->unique_name, 1);\n@@ -1139,13 +1139,13 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->aux = (void *) tag;\n   node->lto_file_data = file_data;\n \n-  node->local.local = bp_unpack_value (bp, 1);\n+  node->local = bp_unpack_value (bp, 1);\n   node->externally_visible = bp_unpack_value (bp, 1);\n   node->no_reorder = bp_unpack_value (bp, 1);\n   node->definition = bp_unpack_value (bp, 1);\n-  node->local.versionable = bp_unpack_value (bp, 1);\n-  node->local.can_change_signature = bp_unpack_value (bp, 1);\n-  node->local.redefined_extern_inline = bp_unpack_value (bp, 1);\n+  node->versionable = bp_unpack_value (bp, 1);\n+  node->can_change_signature = bp_unpack_value (bp, 1);\n+  node->redefined_extern_inline = bp_unpack_value (bp, 1);\n   node->force_output = bp_unpack_value (bp, 1);\n   node->forced_by_abi = bp_unpack_value (bp, 1);\n   node->unique_name = bp_unpack_value (bp, 1);"}, {"sha": "19dcfc94b27e5d3732ebb1c88a6a366650b80e6a", "filename": "gcc/multiple_target.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fmultiple_target.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fmultiple_target.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmultiple_target.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -429,7 +429,7 @@ expand_target_clones (struct cgraph_node *node, bool definition)\n \t\t\t\t\t\t   attributes);\n       if (new_node == NULL)\n \treturn false;\n-      new_node->local.local = false;\n+      new_node->local = false;\n       XDELETEVEC (suffix);\n \n       decl2_v = new_node->function_version ();\n@@ -457,7 +457,7 @@ expand_target_clones (struct cgraph_node *node, bool definition)\n   tree attributes = make_attribute (\"target\", \"default\",\n \t\t\t\t    DECL_ATTRIBUTES (node->decl));\n   DECL_ATTRIBUTES (node->decl) = attributes;\n-  node->local.local = false;\n+  node->local = false;\n   return true;\n }\n "}, {"sha": "76aea56bdcf3abcdbbf360bfb90fe407f607d147", "filename": "gcc/omp-simd-clone.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fomp-simd-clone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Fomp-simd-clone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -475,7 +475,7 @@ simd_clone_create (struct cgraph_node *old_node)\n   /* The method cgraph_version_clone_with_body () will force the new\n      symbol local.  Undo this, and inherit external visibility from\n      the old node.  */\n-  new_node->local.local = old_node->local.local;\n+  new_node->local = old_node->local;\n   new_node->externally_visible = old_node->externally_visible;\n \n   return new_node;"}, {"sha": "2e7752865406193ddd51a610bf67b2414171b8c0", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -2541,12 +2541,12 @@ expand_call_tm (struct tm_region *region,\n \t  gimple_call_set_fndecl (stmt, repl);\n \t  update_stmt (stmt);\n \t  node = cgraph_node::create (repl);\n-\t  node->local.tm_may_enter_irr = false;\n+\t  node->tm_may_enter_irr = false;\n \t  return expand_call_tm (region, gsi);\n \t}\n       gcc_unreachable ();\n     }\n-  if (node->local.tm_may_enter_irr)\n+  if (node->tm_may_enter_irr)\n     transaction_subcode_ior (region, GTMA_MAY_ENTER_IRREVOCABLE);\n \n   if (is_tm_abort (fn_decl))\n@@ -4722,7 +4722,7 @@ ipa_tm_mayenterirr_function (struct cgraph_node *node)\n \n   /* We may have previously marked this function as tm_may_enter_irr;\n      see pass_diagnose_tm_blocks.  */\n-  if (node->local.tm_may_enter_irr)\n+  if (node->tm_may_enter_irr)\n     return true;\n \n   /* Recurse on the main body for aliases.  In general, this will\n@@ -4746,7 +4746,7 @@ ipa_tm_diagnose_tm_safe (struct cgraph_node *node)\n \n   for (e = node->callees; e ; e = e->next_callee)\n     if (!is_tm_callable (e->callee->decl)\n-\t&& e->callee->local.tm_may_enter_irr)\n+\t&& e->callee->tm_may_enter_irr)\n       error_at (gimple_location (e->call_stmt),\n \t\t\"unsafe function call %qD within \"\n \t\t\"%<transaction_safe%> function\", e->callee->decl);\n@@ -4814,7 +4814,7 @@ ipa_tm_diagnose_transaction (struct cgraph_node *node,\n \t      if (is_tm_callable (fndecl))\n \t\tcontinue;\n \n-\t      if (cgraph_node::local_info (fndecl)->tm_may_enter_irr)\n+\t      if (cgraph_node::local_info_node (fndecl)->tm_may_enter_irr)\n \t\terror_at (gimple_location (stmt),\n \t\t\t  \"unsafe function call %qD within \"\n \t\t\t  \"atomic transaction\", fndecl);\n@@ -4989,7 +4989,7 @@ ipa_tm_create_version (struct cgraph_node *old_node)\n \n   gcc_assert (!old_node->ipa_transforms_to_apply.exists ());\n   new_node = old_node->create_version_clone (new_decl, vNULL, NULL);\n-  new_node->local.local = false;\n+  new_node->local = false;\n   new_node->externally_visible = old_node->externally_visible;\n   new_node->lowered = true;\n   new_node->tm_clone = 1;\n@@ -5209,7 +5209,7 @@ ipa_tm_transform_calls_redirect (struct cgraph_node *node,\n \t CALLER.  Also note that find_tm_replacement_function also\n \t contains mappings into the TM runtime, e.g. memcpy.  These\n \t we know won't go irrevocable.  */\n-      new_node->local.tm_may_enter_irr = 1;\n+      new_node->tm_may_enter_irr = 1;\n     }\n   else\n     {\n@@ -5417,7 +5417,7 @@ ipa_tm_execute (void)\n \t   No need to do this if the function's address can't be taken.  */\n \tif (is_tm_pure (node->decl))\n \t  {\n-\t    if (!node->local.local)\n+\t    if (!node->local)\n \t      record_tm_clone_pair (node->decl, node->decl);\n \t    continue;\n \t  }\n@@ -5544,14 +5544,14 @@ ipa_tm_execute (void)\n       node = irr_worklist[i];\n       d = get_cg_data (&node, true);\n       d->in_worklist = false;\n-      node->local.tm_may_enter_irr = true;\n+      node->tm_may_enter_irr = true;\n \n       /* Propagate back to normal callers.  */\n       for (e = node->callers; e ; e = e->next_caller)\n \t{\n \t  caller = e->caller;\n \t  if (!is_tm_safe_or_pure (caller->decl)\n-\t      && !caller->local.tm_may_enter_irr)\n+\t      && !caller->tm_may_enter_irr)\n \t    {\n \t      d = get_cg_data (&caller, true);\n \t      maybe_push_queue (caller, &irr_worklist, &d->in_worklist);\n@@ -5562,7 +5562,7 @@ ipa_tm_execute (void)\n       FOR_EACH_ALIAS (node, ref)\n \t{\n \t  caller = dyn_cast<cgraph_node *> (ref->referring);\n-\t  if (!caller->local.tm_may_enter_irr)\n+\t  if (!caller->tm_may_enter_irr)\n \t    {\n \t      /* ?? Do not traverse aliases here.  */\n \t      d = get_cg_data (&caller, false);"}, {"sha": "2b8b9ee58c196c4658c7e052e94a09436154d314", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87f94429feeb72587549fdafd3106f1d799607ff/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=87f94429feeb72587549fdafd3106f1d799607ff", "patch": "@@ -4688,7 +4688,7 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n \t     be to be able to keep both bodies and use extern inline body\n \t     for inlining, but we can't do that because frontends overwrite\n \t     the body.  */\n-\t  && !cg_edge->callee->local.redefined_extern_inline\n+\t  && !cg_edge->callee->redefined_extern_inline\n \t  /* During early inline pass, report only when optimization is\n \t     not turned on.  */\n \t  && (symtab->global_info_ready"}]}