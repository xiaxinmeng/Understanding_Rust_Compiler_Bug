{"sha": "8dc0b179fdba835b29eb3285062e31cd991d6197", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRjMGIxNzlmZGJhODM1YjI5ZWIzMjg1MDYyZTMxY2Q5OTFkNjE5Nw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-10-11T21:02:37Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-10-11T21:02:37Z"}, "message": "(unroll_loop): Set map->const_equiv_map_size to new_maxregnum.\n\n(copy_loop_body): When set const_age_map entry for split dest reg,\nverify that it is within the bounds of the map.\n(find_splittable_regs): Count number of biv sets, not number of\nbivs.  Don't pass result to find_splittable_givs.\n(find_splittable_givs): Delete parameter result.  Add local variable result.\n\nFrom-SVN: r5741", "tree": {"sha": "2bf2813d3ce41485827a6483efc733a688a61675", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bf2813d3ce41485827a6483efc733a688a61675"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dc0b179fdba835b29eb3285062e31cd991d6197", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc0b179fdba835b29eb3285062e31cd991d6197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dc0b179fdba835b29eb3285062e31cd991d6197", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc0b179fdba835b29eb3285062e31cd991d6197/comments", "author": null, "committer": null, "parents": [{"sha": "242cef1e253ea513b4735f88d62f78d42a2bb92c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/242cef1e253ea513b4735f88d62f78d42a2bb92c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/242cef1e253ea513b4735f88d62f78d42a2bb92c"}], "stats": {"total": 25, "additions": 16, "deletions": 9}, "files": [{"sha": "038c99854ecacb4f493aea3686fa85b468c517d8", "filename": "gcc/unroll.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc0b179fdba835b29eb3285062e31cd991d6197/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc0b179fdba835b29eb3285062e31cd991d6197/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=8dc0b179fdba835b29eb3285062e31cd991d6197", "patch": "@@ -999,6 +999,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n   map->const_equiv_map = (rtx *) alloca (new_maxregnum * sizeof (rtx));\n   map->const_age_map = (unsigned *) alloca (new_maxregnum * sizeof (unsigned));\n \n+  map->const_equiv_map_size = new_maxregnum;\n   global_const_equiv_map = map->const_equiv_map;\n \n   /* Search the list of bivs and givs to find ones which need to be remapped\n@@ -1718,7 +1719,8 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t    {\n \t      int regno = REGNO (SET_DEST (pattern));\n \n-\t      if (map->const_age_map[regno] == map->const_age)\n+\t      if (regno < map->const_equiv_map_size\n+\t\t  && map->const_age_map[regno] == map->const_age)\n \t\tmap->const_age_map[regno] = -1;\n \t    }\n \t  break;\n@@ -2226,7 +2228,10 @@ approx_final_value (comparison_code, comparison_value, unsigned_p, compare_dir)\n    It must be set to the initial value of the induction variable here.\n    Otherwise, splittable_regs will hold the difference between the current\n    value of the induction variable and the value the induction variable had\n-   at the top of the loop.  It must be set to the value 0 here.  */\n+   at the top of the loop.  It must be set to the value 0 here.\n+\n+   Returns the total number of instructions that set registers that are\n+   splittable.  */\n \n /* ?? If the loop is only unrolled twice, then most of the restrictions to\n    constant values are unnecessary, since we can easily calculate increment\n@@ -2335,8 +2340,7 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n \t     we can treat the last one specially.  */\n \n \t  splittable_regs_updates[bl->regno] = bl->biv_count;\n-\n-\t  result++;\n+\t  result += bl->biv_count;\n \n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream,\n@@ -2348,8 +2352,8 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n \t depend on it may be splittable if the biv is live outside the\n \t loop, and the givs aren't.  */\n \n-      result = find_splittable_givs (bl, unroll_type, loop_start, loop_end,\n-\t\t\t\t     increment, unroll_number, result);\n+      result += find_splittable_givs (bl, unroll_type, loop_start, loop_end,\n+\t\t\t\t     increment, unroll_number);\n \n       /* If final value is non-zero, then must emit an instruction which sets\n \t the value of the biv to the proper value.  This is done after\n@@ -2393,20 +2397,23 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n }\n \n /* For every giv based on the biv BL, check to determine whether it is\n-   splittable.  This is a subroutine to find_splittable_regs ().  */\n+   splittable.  This is a subroutine to find_splittable_regs ().\n+\n+   Return the number of instructions that set splittable registers.  */\n \n static int\n find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n-\t\t      unroll_number, result)\n+\t\t      unroll_number)\n      struct iv_class *bl;\n      enum unroll_types unroll_type;\n      rtx loop_start, loop_end;\n      rtx increment;\n-     int unroll_number, result;\n+     int unroll_number;\n {\n   struct induction *v;\n   rtx final_value;\n   rtx tem;\n+  int result = 0;\n \n   for (v = bl->giv; v; v = v->next_iv)\n     {"}]}