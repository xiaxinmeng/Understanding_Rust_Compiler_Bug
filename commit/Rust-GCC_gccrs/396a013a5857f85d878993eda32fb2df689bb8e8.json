{"sha": "396a013a5857f85d878993eda32fb2df689bb8e8", "node_id": "C_kwDOANBUbNoAKDM5NmEwMTNhNTg1N2Y4NWQ4Nzg5OTNlZGEzMmZiMmRmNjg5YmI4ZTg", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2022-04-11T15:11:08Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2022-04-11T15:11:08Z"}, "message": "c++: Set loc on call even if result is discarded\n\nThis patch fixes a divergence in line numbers in diagnostics and,\npresumably, debug information, between targets whose cdtors return\nthis and those that don't.\n\nThe problem was visible in g++.dg/cpp2a/constexpr-dtor3.C: while the\ndtor call in the cleanup for f4 was expected at the closing brace, on\nreturning-this targets it came up at the assignment.\n\nThe reason is convoluted: statements in cleanups have their location\ninformation removed, to avoid bumpy debugger behavior, and then set to\nthe location of the end of the scope.\n\nThe cleanup dtor call has its locus cleared in both kinds of targets,\nbut the end-of-scope locus doesn't make it on returning-this targets.\nThe calls are wrapped with a cast-to-void to discard the unused return\nvalue, and the existing logic only attached the locus to the\nconversion NOP_EXPR.\n\nThe call thus remains locus-less.  When constexpr logic copies and\nevals the body, it sets unset locations; while copying cleanups, the\nlocus is taken from the cleanup expression, rather than matching the\nend-of-scope locus set by the parser.  So we end up with different\nlocations.\n\nThis patch sets the locus of the call even when it's wrapped by a\nconvert-to-void NOP_EXPR, so it won't diverge any more.\n\n\nfor  gcc/cp/ChangeLog\n\n\t* semantics.cc (set_cleanup_locs): Propagate locus to call\n\twrapped in cast-to-void.", "tree": {"sha": "3ae0f323ca99b222791957eaeeeddeabb53faa8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ae0f323ca99b222791957eaeeeddeabb53faa8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/396a013a5857f85d878993eda32fb2df689bb8e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/396a013a5857f85d878993eda32fb2df689bb8e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/396a013a5857f85d878993eda32fb2df689bb8e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/396a013a5857f85d878993eda32fb2df689bb8e8/comments", "author": null, "committer": null, "parents": [{"sha": "4132f6ba9583e128a00d55961ae8c8e7245b2223", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4132f6ba9583e128a00d55961ae8c8e7245b2223", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4132f6ba9583e128a00d55961ae8c8e7245b2223"}], "stats": {"total": 12, "additions": 11, "deletions": 1}, "files": [{"sha": "43627ed30afcb2bcab2e5a8094738f9124aacd1f", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/396a013a5857f85d878993eda32fb2df689bb8e8/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/396a013a5857f85d878993eda32fb2df689bb8e8/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=396a013a5857f85d878993eda32fb2df689bb8e8", "patch": "@@ -609,7 +609,17 @@ set_cleanup_locs (tree stmts, location_t loc)\n {\n   if (TREE_CODE (stmts) == CLEANUP_STMT)\n     {\n-      protected_set_expr_location (CLEANUP_EXPR (stmts), loc);\n+      tree t = CLEANUP_EXPR (stmts);\n+      protected_set_expr_location (t, loc);\n+      /* Avoid locus differences for C++ cdtor calls depending on whether\n+\t cdtor_returns_this: a conversion to void is added to discard the return\n+\t value, and this conversion ends up carrying the location, and when it\n+\t gets discarded, the location is lost.  So hold it in the call as\n+\t well.  */\n+      if (TREE_CODE (t) == NOP_EXPR\n+\t  && TREE_TYPE (t) == void_type_node\n+\t  && TREE_CODE (TREE_OPERAND (t, 0)) == CALL_EXPR)\n+\tprotected_set_expr_location (TREE_OPERAND (t, 0), loc);\n       set_cleanup_locs (CLEANUP_BODY (stmts), loc);\n     }\n   else if (TREE_CODE (stmts) == STATEMENT_LIST)"}]}