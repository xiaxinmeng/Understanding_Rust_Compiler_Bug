{"sha": "46b02c6d614586e17d73588f4a99f7fbb87fb276", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZiMDJjNmQ2MTQ1ODZlMTdkNzM1ODhmNGE5OWY3ZmJiODdmYjI3Ng==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-04-30T18:29:47Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-04-30T18:29:47Z"}, "message": "86th Cygnus<->FSF quick merge\n\nFrom-SVN: r11905", "tree": {"sha": "ad205fecf0149917578a2fb649bcd3cc4665855b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad205fecf0149917578a2fb649bcd3cc4665855b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46b02c6d614586e17d73588f4a99f7fbb87fb276", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46b02c6d614586e17d73588f4a99f7fbb87fb276", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46b02c6d614586e17d73588f4a99f7fbb87fb276", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46b02c6d614586e17d73588f4a99f7fbb87fb276/comments", "author": null, "committer": null, "parents": [{"sha": "e28b8ef8d16c3ec6f3eb48684a755460c9cf9063", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e28b8ef8d16c3ec6f3eb48684a755460c9cf9063", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e28b8ef8d16c3ec6f3eb48684a755460c9cf9063"}], "stats": {"total": 600, "additions": 380, "deletions": 220}, "files": [{"sha": "9d9a755a9a2233ca6ca9a0ae3d3d7c035672c010", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=46b02c6d614586e17d73588f4a99f7fbb87fb276", "patch": "@@ -1,7 +1,61 @@\n+Mon Apr 29 15:38:29 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c (import_export_vtable): Use DECL_ONE_ONLY.\n+\t(import_export_decl): Ditto.\n+\t(finish_prevtable_vardecl): Disable vtable hack if\n+\tSUPPORTS_ONE_ONLY > 1.\n+\n+Mon Apr 29 14:32:47 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (build_modify_expr): PREINCREMENT_EXPR and\n+\tPREDECREMENT_EXPRs take two arguments, not one.\n+\n+Mon Apr 29 00:27:53 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* class.c (build_vtable_entry): Don't build thunks for abstract\n+ \tvirtuals.\n+\n+\t* lex.c (real_yylex): Fix handling of __PRETTY_FUNCTION__ like C\n+ \tfrontend.\n+\n+Sat Apr 27 16:45:35 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* class.c (set_rtti_entry): Use size_zero_node.\n+\t(build_vtable): Ditto.\n+\n+Sat Apr 27 14:48:57 1996  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* class.c (finish_struct_1): Pass size_zero_node to set_rtti_entry.\n+\t(prepare_fresh_vtable): Ditto.\n+\n+Fri Apr 26 13:14:14 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* method.c (emit_thunk): Call mark_used on the target function.\n+\n+\t* call.c (build_method_call): Don't warn about pending templates.\n+\n Thu Apr 25 14:55:44 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl2.c (finish_file): Fix list walking logic.\n \n+\t* typeck2.c (check_for_new_type): Only warn if -pedantic.\n+\n+Wed Apr 24 15:41:15 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* class.c (finish_struct_1): Remove old code for\n+\tdont_allow_type_definitions.\n+\t* cp-tree.h: Ditto.\n+\t* spew.c: Make sure cp-tree.h is included before parse.h, so the\n+\tdefinition of flagged_type_tree is found before it is used.\n+\t* lex.c: Ditto.\n+\t* parse.y: Added the ftype member to the type union, and changed a\n+ \tnumber of rules to use it instead of ttype. Added calls to\n+\tcheck_for_new_type() as appropriate.\n+\t* typeck2.c (check_for_new_type): New function for checking\n+\tif a newly defined type appears in the specified tree.\n+\t* cp-tree.h: Add new type flagged_type_tree. Add a prototype\n+\tfor check_for_new_type().\n+\n Wed Apr 24 00:36:21 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl2.c (finish_file): Only use a sentry if the decl is public."}, {"sha": "638db4cd793ba932073ec3e4418a0ebcd5dfaa31", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=46b02c6d614586e17d73588f4a99f7fbb87fb276", "patch": "@@ -2389,7 +2389,9 @@ build_method_call (instance, name, parms, basetype_path, flags)\n     synthesize_method (function);\n \n   if (pedantic && DECL_THIS_INLINE (function) && ! DECL_ARTIFICIAL (function)\n-       && ! DECL_INITIAL (function) && ! DECL_PENDING_INLINE_INFO (function))\n+      && ! DECL_INITIAL (function) && ! DECL_PENDING_INLINE_INFO (function)\n+      && ! (DECL_TEMPLATE_INFO (function)\n+\t    && TREE_LANG_FLAG_0 (DECL_TEMPLATE_INFO (function))))\n     cp_warning (\"inline function `%#D' called before definition\", function);\n \n   fntype = TREE_TYPE (function);"}, {"sha": "01ea19c367e600b58941a3d9a0bd6e7e2c6de87b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=46b02c6d614586e17d73588f4a99f7fbb87fb276", "patch": "@@ -90,8 +90,6 @@ int current_lang_stacksize;\n tree lang_name_c, lang_name_cplusplus;\n tree current_lang_name;\n \n-char *dont_allow_type_definitions;\n-\n /* When layout out an aggregate type, the size of the\n    basetypes (virtual and non-virtual) is passed to layout_record\n    via this node.  */\n@@ -376,7 +374,7 @@ build_vtable_entry (delta, pfn)\n   if (flag_vtable_thunks)\n     {\n       HOST_WIDE_INT idelta = TREE_INT_CST_LOW (delta);\n-      if (idelta)\n+      if (idelta && ! DECL_ABSTRACT_VIRTUAL_P (TREE_OPERAND (pfn, 0)))\n \t{\n \t  pfn = build1 (ADDR_EXPR, vtable_entry_type,\n \t\t\tmake_thunk (pfn, idelta));\n@@ -590,7 +588,7 @@ set_rtti_entry (virtuals, offset, type)\n   if (flag_rtti)\n     vfn = build1 (ADDR_EXPR, vfunc_ptr_type_node, get_tinfo_fn (type));\n   else\n-    vfn = build1 (NOP_EXPR, vfunc_ptr_type_node, integer_zero_node);\n+    vfn = build1 (NOP_EXPR, vfunc_ptr_type_node, size_zero_node);\n   TREE_CONSTANT (vfn) = 1;\n \n   if (! flag_vtable_thunks)\n@@ -600,11 +598,11 @@ set_rtti_entry (virtuals, offset, type)\n       tree voff = build1 (NOP_EXPR, vfunc_ptr_type_node, offset);\n       TREE_CONSTANT (voff) = 1;\n \n-      TREE_VALUE (virtuals) = build_vtable_entry (integer_zero_node, voff);\n+      TREE_VALUE (virtuals) = build_vtable_entry (size_zero_node, voff);\n \n       /* The second slot is for the tdesc pointer when thunks are used.  */\n       TREE_VALUE (TREE_CHAIN (virtuals))\n-\t= build_vtable_entry (integer_zero_node, vfn);\n+\t= build_vtable_entry (size_zero_node, vfn);\n     }\n }\n \n@@ -628,7 +626,7 @@ build_vtable (binfo, type)\n \n       /* Now do rtti stuff.  */\n       offset = get_derived_offset (TYPE_BINFO (type), NULL_TREE);\n-      offset = size_binop (MINUS_EXPR, integer_zero_node, offset);\n+      offset = size_binop (MINUS_EXPR, size_zero_node, offset);\n       set_rtti_entry (virtuals, offset, type);\n     }\n   else\n@@ -787,7 +785,7 @@ prepare_fresh_vtable (binfo, for_type)\n     offset = BINFO_OFFSET (binfo);\n \n   set_rtti_entry (BINFO_VIRTUALS (binfo),\n-\t\t  size_binop (MINUS_EXPR, integer_zero_node, offset),\n+\t\t  size_binop (MINUS_EXPR, size_zero_node, offset),\n \t\t  for_type);\n \n #ifdef GATHER_STATISTICS\n@@ -3046,12 +3044,6 @@ finish_struct_1 (t, attributes, warn_anon)\n       return t;\n     }\n \n-  if (dont_allow_type_definitions)\n-    {\n-      pedwarn (\"types cannot be defined %s\",\n-\t       dont_allow_type_definitions);\n-    }\n-\n   GNU_xref_decl (current_function_decl, t);\n \n   /* If this type was previously laid out as a forward reference,\n@@ -3979,7 +3971,7 @@ finish_struct_1 (t, attributes, warn_anon)\n \t  /* The first slot is for the rtti offset.  */\n \t  pending_virtuals = tree_cons (NULL_TREE, NULL_TREE, pending_virtuals);\n \n-\t  set_rtti_entry (pending_virtuals, integer_zero_node, t);\n+\t  set_rtti_entry (pending_virtuals, size_zero_node, t);\n \t  build_vtable (NULL_TREE, t);\n \t}\n       else"}, {"sha": "e3a9297a3d602a823e8d8a8caeee482864dc71f6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=46b02c6d614586e17d73588f4a99f7fbb87fb276", "patch": "@@ -51,6 +51,12 @@ struct lang_id2\n   tree type_desc, as_list, error_locus;\n };\n \n+typedef struct \n+{\n+  tree t;\n+  int new_type_flag;\n+} flagged_type_tree;\n+\n /* To identify to the debug emitters if it should pay attention to the\n    flag `-Wtemplate-debugging'.  */\n #define HAVE_TEMPLATES 1\n@@ -1942,7 +1948,6 @@ extern tree build_overload_call\t\t\tPROTO((tree, tree, int, struct candidate *));\n extern tree build_overload_call_maybe\t\tPROTO((tree, tree, int, struct candidate *));\n \n /* in class.c */\n-extern char *dont_allow_type_definitions;\n extern tree build_vbase_pointer\t\t\tPROTO((tree, tree));\n extern tree build_vbase_path\t\t\tPROTO((enum tree_code, tree, tree, tree, int));\n extern tree build_vtable_entry\t\t\tPROTO((tree, tree));\n@@ -2490,6 +2495,7 @@ extern tree build_m_component_ref\t\tPROTO((tree, tree));\n extern tree build_functional_cast\t\tPROTO((tree, tree));\n extern char *enum_name_string\t\t\tPROTO((tree, tree));\n extern void report_case_error\t\t\tPROTO((int, tree, tree, tree));\n+extern void check_for_new_typeid\t\tPROTO((char *,flagged_type_tree));\n \n /* in xref.c */\n extern void GNU_xref_begin\t\t\tPROTO((char *));"}, {"sha": "cdfcfa084d259d9079f5455fe8801e765ecc7020", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=46b02c6d614586e17d73588f4a99f7fbb87fb276", "patch": "@@ -37,6 +37,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"lex.h\"\n #include \"output.h\"\n \n+#ifndef SUPPORTS_ONE_ONLY\n+#define SUPPORTS_ONE_ONLY 0\n+#endif\n+\n extern tree get_file_function_name ();\n extern tree cleanups_this_call;\n static void grok_function_init PROTO((tree, tree));\n@@ -2508,15 +2512,23 @@ import_export_vtable (decl, type, final)\n \n       if (final || ! found)\n \t{\n-#ifdef ASSEMBLE_EXTERNAL\n-\t  if (TREE_PUBLIC (decl))\n-\t    cp_error (\"all virtual functions redeclared inline\");\n+#ifdef DECL_ONE_ONLY\n+\t  if (SUPPORTS_ONE_ONLY)\n+\t    {\n+\t      TREE_PUBLIC (decl) = 1;\n+\t      DECL_ONE_ONLY (decl) = 1;\n+\t    }\n+\t  else\n #endif\n \t  if (flag_weak)\n \t    {\n \t      TREE_PUBLIC (decl) = 1;\n \t      DECL_WEAK (decl) = 1;\n \t    }\n+#ifdef ASSEMBLE_EXTERNAL\n+\t  else if (TREE_PUBLIC (decl))\n+\t    cp_error (\"all virtual functions redeclared inline\");\n+#endif\n \t  else\n \t    TREE_PUBLIC (decl) = 0;\n \t  DECL_EXTERNAL (decl) = 0;\n@@ -2551,6 +2563,7 @@ finish_prevtable_vardecl (prev, vars)\n   import_export_template (ctype);\n \n   if (CLASSTYPE_INTERFACE_UNKNOWN (ctype) && TYPE_VIRTUAL_P (ctype)\n+      && ! (SUPPORTS_ONE_ONLY > 1)\n       && ! CLASSTYPE_TEMPLATE_INSTANTIATION (ctype))\n     {\n       tree method;\n@@ -2564,9 +2577,6 @@ finish_prevtable_vardecl (prev, vars)\n \t      SET_CLASSTYPE_INTERFACE_KNOWN (ctype);\n \t      CLASSTYPE_VTABLE_NEEDS_WRITING (ctype) = ! DECL_EXTERNAL (method);\n \t      CLASSTYPE_INTERFACE_ONLY (ctype) = DECL_EXTERNAL (method);\n-#ifdef ADJUST_VTABLE_LINKAGE\n-\t      ADJUST_VTABLE_LINKAGE (vars, method);\n-#endif\n \t      break;\n \t    }\n \t}\n@@ -2731,6 +2741,11 @@ import_export_decl (decl)\n \t{\n \t  if (TREE_CODE (decl) == FUNCTION_DECL)\n \t    {\n+#ifdef DECL_ONE_ONLY\n+\t      if (SUPPORTS_ONE_ONLY)\n+\t\tDECL_ONE_ONLY (decl) = 1;\n+\t      else\n+#endif\n \t      if (flag_weak)\n \t\tDECL_WEAK (decl) = 1;\n \t      else\n@@ -2745,6 +2760,10 @@ import_export_decl (decl)\n \t      DECL_COMMON (decl) = 1;\n \t      DECL_INITIAL (decl) = error_mark_node;\n \t    }\n+#ifdef DECL_ONE_ONLY\n+\t  else if (SUPPORTS_ONE_ONLY)\n+\t    DECL_ONE_ONLY (decl) = 1;\n+#endif\n \t  /* Statically initialized vars are weak or comdat, if supported.  */\n \t  else if (flag_weak)\n \t    DECL_WEAK (decl) = 1;\n@@ -2762,6 +2781,10 @@ import_export_decl (decl)\n \t    = ! (CLASSTYPE_INTERFACE_ONLY (ctype)\n \t\t || (DECL_THIS_INLINE (decl) && ! flag_implement_inlines));\n \t}\n+#ifdef DECL_ONE_ONLY\n+      else if (SUPPORTS_ONE_ONLY)\n+\tDECL_ONE_ONLY (decl) = 1;\n+#endif\n       else if (flag_weak)\n \tDECL_WEAK (decl) = 1;\n       else\n@@ -2779,13 +2802,21 @@ import_export_decl (decl)\n \t}\n       else if (TYPE_BUILT_IN (ctype) && ctype == TYPE_MAIN_VARIANT (ctype))\n \tDECL_NOT_REALLY_EXTERN (decl) = 0;\n+#ifdef DECL_ONE_ONLY\n+      else if (SUPPORTS_ONE_ONLY)\n+\tDECL_ONE_ONLY (decl) = 1;\n+#endif\n       else if (flag_weak)\n \tDECL_WEAK (decl) = 1;\n       else\n \tTREE_PUBLIC (decl) = 0;\n     } \n   else if (DECL_C_STATIC (decl))\n     TREE_PUBLIC (decl) = 0;\n+#ifdef DECL_ONE_ONLY\n+  else if (SUPPORTS_ONE_ONLY)\n+    DECL_ONE_ONLY (decl) = 1;\n+#endif\n   else if (flag_weak)\n     DECL_WEAK (decl) = 1;\n   else"}, {"sha": "fb0ebbc72792e82450f4b27688413649ab62ca02", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=46b02c6d614586e17d73588f4a99f7fbb87fb276", "patch": "@@ -33,8 +33,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"input.h\"\n #include \"tree.h\"\n #include \"lex.h\"\n-#include \"parse.h\"\n #include \"cp-tree.h\"\n+#include \"parse.h\"\n #include \"flags.h\"\n #include \"obstack.h\"\n #include \"c-pragma.h\"\n@@ -3096,7 +3096,12 @@ real_yylex ()\n \t\t&& DECL_INITIAL (tmp) != NULL_TREE\n \t\t&& TREE_CODE (DECL_INITIAL (tmp)) == STRING_CST)\n \t      {\n-\t\tyylval.ttype = DECL_INITIAL (tmp);\n+\t\ttree stringval = DECL_INITIAL (tmp);\n+\t      \n+\t\t/* Copy the string value so that we won't clobber anything\n+\t\t   if we put something in the TREE_CHAIN of this one.  */\n+\t\tyylval.ttype = build_string (TREE_STRING_LENGTH (stringval),\n+\t\t\t\t\t     TREE_STRING_POINTER (stringval));\n \t\tvalue = STRING;\n \t      }\n \t  }"}, {"sha": "d31ea15479bea9973507e2636477c75de8ac343a", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=46b02c6d614586e17d73588f4a99f7fbb87fb276", "patch": "@@ -1872,6 +1872,8 @@ emit_thunk (thunk_fndecl)\n   if (current_function_decl)\n     abort ();\n   current_function_decl = thunk_fndecl;\n+  TREE_ADDRESSABLE (function) = 1;\n+  mark_used (function);\n #ifdef ASM_OUTPUT_MI_THUNK\n   assemble_start_function (thunk_fndecl, fnname);\n   ASM_OUTPUT_MI_THUNK (asm_out_file, thunk_fndecl, delta, function);"}, {"sha": "1b79dec67952a46de992a27b3bd6d99368ce6d90", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 251, "deletions": 193, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=46b02c6d614586e17d73588f4a99f7fbb87fb276", "patch": "@@ -99,7 +99,7 @@ empty_parms ()\n \n %start program\n \n-%union {long itype; tree ttype; char *strtype; enum tree_code code; }\n+%union {long itype; tree ttype; char *strtype; enum tree_code code; flagged_type_tree ftype; }\n \n /* All identifiers that are not reserved words\n    and are not declared typedefs in the current block */\n@@ -195,10 +195,10 @@ empty_parms ()\n %type <ttype> identifier IDENTIFIER TYPENAME CONSTANT expr nonnull_exprlist\n %type <ttype> paren_expr_or_null nontrivial_exprlist SELFNAME\n %type <ttype> expr_no_commas cast_expr unary_expr primary string STRING\n-%type <ttype> typed_declspecs reserved_declspecs boolean.literal\n-%type <ttype> typed_typespecs reserved_typespecquals\n-%type <ttype> declmods typespec typespecqual_reserved\n-%type <ttype> SCSPEC TYPESPEC TYPE_QUAL nonempty_type_quals maybe_type_qual\n+%type <ttype> reserved_declspecs boolean.literal\n+%type <ttype> reserved_typespecquals\n+%type <ttype> declmods \n+%type <ttype> SCSPEC TYPESPEC TYPE_QUAL maybe_type_qual\n %type <itype> initdecls notype_initdecls initdcl\t/* C++ modification */\n %type <ttype> init initlist maybeasm maybe_init\n %type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers\n@@ -210,23 +210,27 @@ empty_parms ()\n %type <ttype> declarator notype_declarator after_type_declarator\n %type <ttype> direct_notype_declarator direct_after_type_declarator\n \n-%type <ttype> structsp opt.component_decl_list component_decl_list\n+%type <ttype> opt.component_decl_list component_decl_list\n %type <ttype> component_decl component_decl_1 components notype_components\n %type <ttype> component_declarator component_declarator0 self_reference\n %type <ttype> notype_component_declarator notype_component_declarator0\n %type <ttype> after_type_component_declarator after_type_component_declarator0\n %type <ttype> enumlist enumerator\n-%type <ttype> type_id absdcl type_quals\n+%type <ttype> absdcl type_quals\n %type <ttype> direct_abstract_declarator conversion_declarator\n-%type <ttype> new_type_id new_declarator direct_new_declarator\n-%type <ttype> xexpr parmlist parms parm bad_parm full_parm\n+%type <ttype> new_declarator direct_new_declarator\n+%type <ttype> xexpr parmlist parms bad_parm \n %type <ttype> identifiers_or_typenames\n %type <ttype> fcast_or_absdcl regcast_or_absdcl\n %type <ttype> expr_or_declarator complex_notype_declarator\n %type <ttype> notype_unqualified_id unqualified_id qualified_id\n %type <ttype> overqualified_id notype_qualified_id any_id\n %type <ttype> complex_direct_notype_declarator functional_cast\n-%type <ttype> named_parm complex_parmlist typed_declspecs1 parms_comma\n+%type <ttype> complex_parmlist parms_comma\n+\n+%type <ftype> type_id new_type_id typed_typespecs typespec typed_declspecs\n+%type <ftype> typed_declspecs1 type_specifier_seq nonempty_type_quals\n+%type <ftype> structsp typespecqual_reserved parm named_parm full_parm\n \n /* C++ extensions */\n %token <ttype> TYPENAME_ELLIPSIS PTYPENAME\n@@ -258,7 +262,7 @@ empty_parms ()\n %type <ttype> complete_type_name notype_identifier\n %type <ttype> complex_type_name nested_name_specifier_1\n %type <itype> nomods_initdecls nomods_initdcl0\n-%type <ttype> new_initializer new_placement type_specifier_seq\n+%type <ttype> new_initializer new_placement\n %type <ttype> using_decl .poplevel\n \n /* in order to recognize aggr tags as defining and thus shadowing. */\n@@ -455,11 +459,11 @@ template_parm:\n \t  template_type_parm\n \t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n \t| template_type_parm '=' type_id\n-\t\t{ $$ = build_tree_list (groktypename ($3), $1); }\n+\t\t{ $$ = build_tree_list (groktypename ($3.t), $1); }\n \t| parm\n-\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n+\t\t{ $$ = build_tree_list (NULL_TREE, $1.t); }\n \t| parm '=' expr_no_commas %prec ARITHCOMPARE\n-\t\t{ $$ = build_tree_list ($3, $1); }\n+\t\t{ $$ = build_tree_list ($3, $1.t); }\n \t;\n \n overloaddef:\n@@ -497,14 +501,14 @@ datadef:\n \t\t}\n \t| typed_declspecs initdecls ';'\n \t\t{\n-\t\t  note_list_got_semicolon ($<ttype>$);\n+\t\t  note_list_got_semicolon ($1.t);\n \t\t}\n \t/* Normal case: make this fast.  */\n \t| typed_declspecs declarator ';'\n \t\t{ tree d, specs, attrs;\n-\t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  split_specs_attrs ($1.t, &specs, &attrs);\n \t\t  note_list_got_semicolon (specs);\n-\t\t  d = start_decl ($<ttype>2, specs, 0, NULL_TREE);\n+\t\t  d = start_decl ($2, specs, 0, NULL_TREE);\n \t\t  cplus_decl_attributes (d, NULL_TREE, attrs);\n \t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n \t\t}\n@@ -514,9 +518,9 @@ datadef:\n \t| typed_declspecs ';'\n \t  {\n \t    tree t, attrs;\n-\t    split_specs_attrs ($1, &t, &attrs);\n+\t    split_specs_attrs ($1.t, &t, &attrs);\n \t    shadow_tag (t);\n-\t    note_list_got_semicolon ($<ttype>$);\n+\t    note_list_got_semicolon ($1.t);\n \t  }\n \t| error ';'\n \t| error '}'\n@@ -645,7 +649,7 @@ constructor_declarator:\n fn.def1:\n \t  typed_declspecs declarator exception_specification_opt\n \t\t{ tree specs, attrs;\n-\t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  split_specs_attrs ($1.t, &specs, &attrs);\n \t\t  if (! start_function (specs, $2, $3, attrs, 0))\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function ();\n@@ -702,7 +706,7 @@ fn.def2:\n \t| component_constructor_declarator exception_specification_opt\n \t\t{ $$ = start_method (NULL_TREE, $1, $2); goto rest_of_mdef; }\n \t| typed_declspecs declarator exception_specification_opt\n-\t\t{ tree specs = strip_attrs ($1);\n+\t\t{ tree specs = strip_attrs ($1.t);\n \t\t  $$ = start_method (specs, $2, $3); goto rest_of_mdef; }\n \t| declmods notype_declarator exception_specification_opt\n \t\t{ tree specs = strip_attrs ($1);\n@@ -829,7 +833,7 @@ explicit_instantiation:\n \t  TEMPLATE aggr template_type\n \t\t{ do_type_instantiation ($3, NULL_TREE); }\n \t| TEMPLATE typed_declspecs declarator\n-\t\t{ tree specs = strip_attrs ($2);\n+\t\t{ tree specs = strip_attrs ($2.t);\n \t\t  do_function_instantiation (specs, $3, NULL_TREE); }\n \t| TEMPLATE notype_declarator\n \t\t{ do_function_instantiation (NULL_TREE, $2, NULL_TREE); }\n@@ -838,7 +842,7 @@ explicit_instantiation:\n \t| SCSPEC TEMPLATE aggr template_type\n \t\t{ do_type_instantiation ($4, $1); }\n \t| SCSPEC TEMPLATE typed_declspecs declarator\n-\t\t{ tree specs = strip_attrs ($3);\n+\t\t{ tree specs = strip_attrs ($3.t);\n \t\t  do_function_instantiation (specs, $4, $1); }\n \t| SCSPEC TEMPLATE notype_declarator\n \t\t{ do_function_instantiation (NULL_TREE, $3, $1); }\n@@ -912,7 +916,7 @@ template_arg_list:\n \n template_arg:\n \t  type_id\n-\t\t{ $$ = groktypename ($$); }\n+\t\t{ $$ = groktypename ($1.t); }\n \t| expr_no_commas  %prec ARITHCOMPARE\n \t;\n \n@@ -973,7 +977,7 @@ condition:\n \t\t\tcp_error (\"definition of enum `%T' in condition\", s);\n \t\t    }\n \t\t  }\n-\t\t  current_declspecs = $1;\n+\t\t  current_declspecs = $1.t;\n \t\t  $<itype>6 = suspend_momentary ();\n \t\t  $<ttype>$ = start_decl ($<ttype>2, current_declspecs, 1, $3);\n \t\t  cplus_decl_attributes ($<ttype>$, $5,\n@@ -1082,31 +1086,40 @@ unary_expr:\n \t| SIZEOF unary_expr  %prec UNARY\n \t\t{ $$ = expr_sizeof ($2); }\n \t| SIZEOF '(' type_id ')'  %prec HYPERUNARY\n-\t\t{ $$ = c_sizeof (groktypename ($3)); }\n+\t\t{ $$ = c_sizeof (groktypename ($3.t)); }\n \t| ALIGNOF unary_expr  %prec UNARY\n \t\t{ $$ = grok_alignof ($2); }\n \t| ALIGNOF '(' type_id ')'  %prec HYPERUNARY\n-\t\t{ $$ = c_alignof (groktypename ($3)); }\n+\t\t{ $$ = c_alignof (groktypename ($3.t)); \n+\t\t  check_for_new_type (\"alignof\", $3); }\n \n \t/* The %prec EMPTY's here are required by the = init initializer\n \t   syntax extension; see below.  */\n \t| new new_type_id %prec EMPTY\n-\t\t{ $$ = build_new (NULL_TREE, $2, NULL_TREE, $1); }\n+\t\t{ $$ = build_new (NULL_TREE, $2.t, NULL_TREE, $1); \n+\t\t  check_for_new_type (\"new\", $2); }\n \t| new new_type_id new_initializer\n-\t\t{ $$ = build_new (NULL_TREE, $2, $3, $1); }\n+\t\t{ $$ = build_new (NULL_TREE, $2.t, $3, $1); \n+\t\t  check_for_new_type (\"new\", $2); }\n \t| new new_placement new_type_id %prec EMPTY\n-\t\t{ $$ = build_new ($2, $3, NULL_TREE, $1); }\n+\t\t{ $$ = build_new ($2, $3.t, NULL_TREE, $1); \n+\t\t  check_for_new_type (\"new\", $3); }\n \t| new new_placement new_type_id new_initializer\n-\t\t{ $$ = build_new ($2, $3, $4, $1); }\n+\t\t{ $$ = build_new ($2, $3.t, $4, $1); \n+\t\t  check_for_new_type (\"new\", $3); }\n \t| new '(' type_id ')' %prec EMPTY\n-\t\t{ $$ = build_new (NULL_TREE, groktypename($3),\n-\t\t\t\t  NULL_TREE, $1); }\n+\t\t{ $$ = build_new (NULL_TREE, groktypename($3.t),\n+\t\t\t\t  NULL_TREE, $1); \n+\t\t  check_for_new_type (\"new\", $3); }\n \t| new '(' type_id ')' new_initializer\n-\t\t{ $$ = build_new (NULL_TREE, groktypename($3), $5, $1); }\n+\t\t{ $$ = build_new (NULL_TREE, groktypename($3.t), $5, $1); \n+\t\t  check_for_new_type (\"new\", $3); }\n \t| new new_placement '(' type_id ')' %prec EMPTY\n-\t\t{ $$ = build_new ($2, groktypename($4), NULL_TREE, $1); }\n+\t\t{ $$ = build_new ($2, groktypename($4.t), NULL_TREE, $1); \n+\t\t  check_for_new_type (\"new\", $4); }\n \t| new new_placement '(' type_id ')' new_initializer\n-\t\t{ $$ = build_new ($2, groktypename($4), $6, $1); }\n+\t\t{ $$ = build_new ($2, groktypename($4.t), $6, $1); \n+\t\t  check_for_new_type (\"new\", $4); }\n \n \t| delete cast_expr  %prec UNARY\n \t\t{ $$ = delete_sanity ($2, NULL_TREE, 0, $1); }\n@@ -1137,7 +1150,7 @@ new_initializer:\n \t\t{ $$ = NULL_TREE; }\n \t| '(' typespec ')'\n \t\t{\n-\t\t  cp_error (\"`%T' is not a valid expression\", $2);\n+\t\t  cp_error (\"`%T' is not a valid expression\", $2.t);\n \t\t  $$ = error_mark_node;\n \t\t}\n \t/* GNU extension so people can use initializer lists.  Note that\n@@ -1154,14 +1167,16 @@ new_initializer:\n /* This is necessary to postpone reduction of `int ((int)(int)(int))'.  */\n regcast_or_absdcl:\n \t  '(' type_id ')' %prec EMPTY\n-\t\t{ $2 = tree_cons (NULL_TREE, $2, void_list_node);\n-\t\t  TREE_PARMLIST ($2) = 1;\n-\t\t  $$ = build_parse_node (CALL_EXPR, NULL_TREE, $2, \n-\t\t\t\t\t NULL_TREE); }\n+\t\t{ $2.t = tree_cons (NULL_TREE, $2.t, void_list_node);\n+\t\t  TREE_PARMLIST ($2.t) = 1;\n+\t\t  $$ = build_parse_node (CALL_EXPR, NULL_TREE, $2.t, \n+\t\t\t\t\t NULL_TREE);\n+\t\t  check_for_new_type (\"cast\", $2); }\n \t| regcast_or_absdcl '(' type_id ')' %prec EMPTY\n-\t\t{ $3 = tree_cons (NULL_TREE, $3, void_list_node);\n-\t\t  TREE_PARMLIST ($3) = 1;\n-\t\t  $$ = build_parse_node (CALL_EXPR, $$, $3, NULL_TREE); }\n+\t\t{ $3.t = tree_cons (NULL_TREE, $3.t, void_list_node);\n+\t\t  TREE_PARMLIST ($3.t) = 1;\n+\t\t  $$ = build_parse_node (CALL_EXPR, $$, $3.t, NULL_TREE);\n+\t\t  check_for_new_type (\"cast\", $3); }\n \t;\n \n cast_expr:\n@@ -1241,7 +1256,7 @@ expr_no_commas:\n \t| object unop expr_no_commas  %prec UNARY\n \t\t{ $$ = build_m_component_ref ($$, build_x_unary_op ($2, $3)); }\n \t| object '(' type_id ')' expr_no_commas  %prec UNARY\n-\t\t{ tree type = groktypename ($3);\n+\t\t{ tree type = groktypename ($3.t);\n \t\t  $$ = build_m_component_ref ($$, build_c_cast (type, $5, 0)); }\n \t| object primary_no_id  %prec UNARY\n \t\t{ $$ = build_m_component_ref ($$, $2); }\n@@ -1443,38 +1458,27 @@ primary:\n \t\t    }\n \t\t}\n \t| functional_cast\n-\t| DYNAMIC_CAST '<'\n-\t\t{ dont_allow_type_definitions = \"inside dynamic_cast\"; }\n-\t  type_id '>'\n-\t\t{ dont_allow_type_definitions = 0; }\n-\t  '(' expr ')'\n-\t\t{ tree type = groktypename ($4);\n-\t\t  $$ = build_dynamic_cast (type, $8); }\n-\t| STATIC_CAST '<'\n-\t\t{ dont_allow_type_definitions = \"inside static_cast\"; }\n-\t  type_id '>'\n-\t\t{ dont_allow_type_definitions = 0; }\n-\t  '(' expr ')'\n-\t\t{ tree type = groktypename ($4);\n-\t\t  $$ = build_static_cast (type, $8); }\n-\t| REINTERPRET_CAST '<'\n-\t\t{ dont_allow_type_definitions = \"inside reinterpret_cast\"; }\n-\t  type_id '>'\n-\t\t{ dont_allow_type_definitions = 0; }\n-\t  '(' expr ')'\n-\t\t{ tree type = groktypename ($4);\n-\t\t  $$ = build_reinterpret_cast (type, $8); }\n-\t| CONST_CAST '<'\n-\t\t{ dont_allow_type_definitions = \"inside const_cast\"; }\n-\t  type_id '>'\n-\t\t{ dont_allow_type_definitions = 0; }\n-\t  '(' expr ')'\n-\t\t{ tree type = groktypename ($4);\n-\t\t  $$ = build_const_cast (type, $8); }\n+\t| DYNAMIC_CAST '<' type_id '>' '(' expr ')'\n+\t\t{ tree type = groktypename ($3.t);\n+\t\t  check_for_new_type (\"dynamic_cast\", $3);\n+\t\t  $$ = build_dynamic_cast (type, $6); }\n+\t| STATIC_CAST '<' type_id '>' '(' expr ')'\n+\t\t{ tree type = groktypename ($3.t);\n+\t\t  check_for_new_type (\"static_cast\", $3);\n+\t\t  $$ = build_static_cast (type, $6); }\n+\t| REINTERPRET_CAST '<' type_id '>' '(' expr ')'\n+\t\t{ tree type = groktypename ($3.t);\n+\t\t  check_for_new_type (\"reinterpret_cast\", $3);\n+\t\t  $$ = build_reinterpret_cast (type, $6); }\n+\t| CONST_CAST '<' type_id '>' '(' expr ')'\n+\t\t{ tree type = groktypename ($3.t);\n+\t\t  check_for_new_type (\"const_cast\", $3);\n+\t\t  $$ = build_const_cast (type, $6); }\n \t| TYPEID '(' expr ')'\n \t\t{ $$ = build_typeid ($3); }\n \t| TYPEID '(' type_id ')'\n-\t\t{ tree type = groktypename ($3);\n+\t\t{ tree type = groktypename ($3.t);\n+\t\t  check_for_new_type (\"typeid\", $3);\n \t\t  $$ = get_typeid (TYPE_MAIN_VARIANT (type)); }\n \t| global_scope IDENTIFIER\n \t\t{ $$ = do_scoped_id ($2, 1); }\n@@ -1671,42 +1675,42 @@ object:\t  primary '.'\n decl:\n \t/* Normal case: make this fast.  */\n \t  typespec declarator ';'\n-\t\t{ tree d = get_decl_list ($1);\n+\t\t{ tree d = get_decl_list ($1.t);\n \t\t  int yes = suspend_momentary ();\n \t\t  d = start_decl ($2, d, 0, NULL_TREE);\n \t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n \t\t  resume_momentary (yes);\n-\t\t  if (IS_AGGR_TYPE_CODE (TREE_CODE ($1)))\n-\t\t    note_got_semicolon ($1);\n+\t\t  if (IS_AGGR_TYPE_CODE (TREE_CODE ($1.t)))\n+\t\t    note_got_semicolon ($1.t);\n \t\t}\n \t| typed_declspecs declarator ';'\n \t\t{ tree d, specs, attrs;\n \t\t  int yes;\n-\t\t  split_specs_attrs ($1, &specs, &attrs);\n+\t\t  split_specs_attrs ($1.t, &specs, &attrs);\n \t\t  yes = suspend_momentary ();\n \t\t  d = start_decl ($2, specs, 0, NULL_TREE);\n \t\t  cplus_decl_attributes (d, NULL_TREE, attrs);\n \t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n \t\t  resume_momentary (yes);\n-\t\t  note_list_got_semicolon ($1);\n+\t\t  note_list_got_semicolon ($1.t);\n \t\t}\n \t| typespec initdecls ';'\n \t\t{\n \t\t  resume_momentary ($2);\n-\t\t  if (IS_AGGR_TYPE_CODE (TREE_CODE ($1)))\n-\t\t    note_got_semicolon ($1);\n+\t\t  if (IS_AGGR_TYPE_CODE (TREE_CODE ($1.t)))\n+\t\t    note_got_semicolon ($1.t);\n \t\t}\n \t| typed_declspecs initdecls ';'\n \t\t{\n \t\t  resume_momentary ($2);\n-\t\t  note_list_got_semicolon ($1);\n+\t\t  note_list_got_semicolon ($1.t);\n \t\t}\n \t| declmods notype_initdecls ';'\n \t\t{ resume_momentary ($2); }\n \t| typed_declspecs ';'\n \t\t{\n-\t\t  shadow_tag ($1);\n-\t\t  note_list_got_semicolon ($1);\n+\t\t  shadow_tag ($1.t);\n+\t\t  note_list_got_semicolon ($1.t);\n \t\t}\n \t| declmods ';'\n \t\t{ warning (\"empty declaration\"); }\n@@ -1733,15 +1737,20 @@ fcast_or_absdcl:\n /* ANSI type-id (8.1) */\n type_id:\n \t  typed_typespecs absdcl\n-\t\t{ $$ = build_decl_list ($$, $2); }\n+\t\t{ $$.t = build_decl_list ($1.t, $2); \n+\t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| nonempty_type_quals absdcl\n-\t\t{ $$ = build_decl_list ($$, $2); }\n+\t\t{ $$.t = build_decl_list ($1.t, $2); \n+\t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typespec absdcl\n-\t\t{ $$ = build_decl_list (get_decl_list ($$), $2); }\n+\t\t{ $$.t = build_decl_list (get_decl_list ($1.t), $2); \n+\t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typed_typespecs %prec EMPTY\n-\t\t{ $$ = build_decl_list ($$, NULL_TREE); }\n+\t\t{ $$.t = build_decl_list ($1.t, NULL_TREE);\n+\t\t  $$.new_type_flag = $1.new_type_flag;  }\n \t| nonempty_type_quals %prec EMPTY\n-\t\t{ $$ = build_decl_list ($$, NULL_TREE); }\n+\t\t{ $$.t = build_decl_list ($1.t, NULL_TREE); \n+\t\t  $$.new_type_flag = $1.new_type_flag; }\n \t;\n \n /* Declspecs which contain at least one type specifier or typedef name.\n@@ -1756,18 +1765,24 @@ typed_declspecs:\n \n typed_declspecs1:\n \t  declmods typespec\n-\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }\n+\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, $1); \n+\t\t  $$.new_type_flag = $2.new_type_flag; }\n \t| typespec reserved_declspecs\t%prec HYPERUNARY\n-\t\t{ $$ = decl_tree_cons (NULL_TREE, $$, $2); }\n+\t\t{ $$.t = decl_tree_cons (NULL_TREE, $1.t, $2); \n+\t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typespec reserved_typespecquals reserved_declspecs\n-\t\t{ $$ = decl_tree_cons (NULL_TREE, $$, chainon ($2, $3)); }\n+\t\t{ $$.t = decl_tree_cons (NULL_TREE, $1.t, chainon ($2, $3)); \n+\t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| declmods typespec reserved_declspecs\n-\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, chainon ($3, $$)); }\n+\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, chainon ($3, $1)); \n+\t\t  $$.new_type_flag = $2.new_type_flag; }\n \t| declmods typespec reserved_typespecquals\n-\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, chainon ($3, $$)); }\n+\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, chainon ($3, $1)); \n+\t\t  $$.new_type_flag = $2.new_type_flag; }\n \t| declmods typespec reserved_typespecquals reserved_declspecs\n-\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, \n-\t\t\t\t       chainon ($3, chainon ($4, $$))); }\n+\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t,\n+\t\t\t\t\t chainon ($3, chainon ($4, $1))); \n+\t\t  $$.new_type_flag = $2.new_type_flag; }\n \t;\n \n reserved_declspecs:\n@@ -1777,7 +1792,7 @@ reserved_declspecs:\n \t\t\t     IDENTIFIER_POINTER ($$));\n \t\t  $$ = build_decl_list (NULL_TREE, $$); }\n \t| reserved_declspecs typespecqual_reserved\n-\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }\n+\t\t{ $$ = decl_tree_cons (NULL_TREE, $2.t, $$); }\n \t| reserved_declspecs SCSPEC\n \t\t{ if (extra_warnings)\n \t\t    warning (\"`%s' is not at beginning of declaration\",\n@@ -1796,7 +1811,7 @@ reserved_declspecs:\n \n declmods:\n \t  nonempty_type_quals %prec EMPTY\n-\t\t{ TREE_STATIC ($$) = 1; }\n+\t\t{ $$ = $1.t; TREE_STATIC ($$) = 1; }\n \t| SCSPEC\n \t\t{ $$ = IDENTIFIER_AS_LIST ($$); }\n \t| declmods TYPE_QUAL\n@@ -1822,20 +1837,24 @@ declmods:\n \n typed_typespecs:\n \t  typespec  %prec EMPTY\n-\t\t{ $$ = get_decl_list ($$); }\n+\t\t{ $$.t = get_decl_list ($1.t); \n+\t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| nonempty_type_quals typespec\n-\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }\n+\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, $1.t); \n+\t\t  $$.new_type_flag = $2.new_type_flag; }\n \t| typespec reserved_typespecquals\n-\t\t{ $$ = decl_tree_cons (NULL_TREE, $$, $2); }\n+\t\t{ $$.t = decl_tree_cons (NULL_TREE, $1.t, $2); \n+\t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| nonempty_type_quals typespec reserved_typespecquals\n-\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, chainon ($3, $$)); }\n+\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t)); \n+\t\t  $$.new_type_flag = $1.new_type_flag; }\n \t;\n \n reserved_typespecquals:\n \t  typespecqual_reserved\n-\t\t{ $$ = build_decl_list (NULL_TREE, $$); }\n+\t\t{ $$ = build_decl_list (NULL_TREE, $1.t); }\n \t| reserved_typespecquals typespecqual_reserved\n-\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }\n+\t\t{ $$ = decl_tree_cons (NULL_TREE, $2.t, $1); }\n \t;\n \n /* A typespec (but not a type qualifier).\n@@ -1844,49 +1863,57 @@ reserved_typespecquals:\n \n typespec: structsp\n \t| TYPESPEC  %prec EMPTY\n+\t\t{ $$.t = $1; $$.new_type_flag = 0; }\n \t| complete_type_name\n+\t\t{ $$.t = $1; $$.new_type_flag = 0; }\n \t| TYPEOF '(' expr ')'\n-\t\t{ $$ = TREE_TYPE ($3);\n+\t\t{ $$.t = TREE_TYPE ($3);\n+\t\t  $$.new_type_flag = 0;\n \t\t  if (pedantic && !in_system_header)\n \t\t    pedwarn (\"ANSI C++ forbids `typeof'\"); }\n \t| TYPEOF '(' type_id ')'\n-\t\t{ $$ = groktypename ($3);\n+\t\t{ $$.t = groktypename ($3.t);\n \t\t  if (pedantic && !in_system_header)\n-\t\t    pedwarn (\"ANSI C++ forbids `typeof'\"); }\n+\t\t    pedwarn (\"ANSI C++ forbids `typeof'\"); \n+\t\t  $$.new_type_flag = 0; }\n \t| SIGOF '(' expr ')'\n \t\t{ tree type = TREE_TYPE ($3);\n \n+                  $$.new_type_flag = 0;\n \t\t  if (IS_AGGR_TYPE (type))\n \t\t    {\n \t\t      sorry (\"sigof type specifier\");\n-\t\t      $$ = type;\n+\t\t      $$.t = type;\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      error (\"`sigof' applied to non-aggregate expression\");\n-\t\t      $$ = error_mark_node;\n+\t\t      $$.t = error_mark_node;\n \t\t    }\n \t\t}\n \t| SIGOF '(' type_id ')'\n-\t\t{ tree type = groktypename ($3);\n+\t\t{ tree type = groktypename ($3.t);\n \n+                  $$.new_type_flag = 0;\n \t\t  if (IS_AGGR_TYPE (type))\n \t\t    {\n \t\t      sorry (\"sigof type specifier\");\n-\t\t      $$ = type;\n+\t\t      $$.t = type;\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      error(\"`sigof' applied to non-aggregate type\");\n-\t\t      $$ = error_mark_node;\n+\t\t      $$.t = error_mark_node;\n \t\t    }\n \t\t}\n \t;\n \n /* A typespec that is a reserved word, or a type qualifier.  */\n \n typespecqual_reserved: TYPESPEC\n+\t\t{ $$.t = $1; $$.new_type_flag = 0; }\n \t| TYPE_QUAL\n+\t\t{ $$.t = $1; $$.new_type_flag = 0; }\n \t| structsp\n \t;\n \n@@ -2131,38 +2158,47 @@ pending_inlines:\n structsp:\n \t  ENUM identifier '{'\n \t\t{ $<itype>3 = suspend_momentary ();\n-\t\t  $$ = start_enum ($2); }\n+\t\t  $<ttype>$ = start_enum ($2); }\n \t  enumlist maybecomma_warn '}'\n-\t\t{ $$ = finish_enum ($<ttype>4, $5);\n+\t\t{ $$.t = finish_enum ($<ttype>4, $5);\n+\t\t  $$.new_type_flag = 1;\n \t\t  resume_momentary ((int) $<itype>3);\n \t\t  check_for_missing_semicolon ($<ttype>4); }\n \t| ENUM identifier '{' '}'\n-\t\t{ $$ = finish_enum (start_enum ($2), NULL_TREE);\n-\t\t  check_for_missing_semicolon ($$); }\n+\t\t{ $$.t = finish_enum (start_enum ($2), NULL_TREE);\n+\t\t  $$.new_type_flag = 1;\n+\t\t  check_for_missing_semicolon ($$.t); }\n \t| ENUM '{'\n \t\t{ $<itype>2 = suspend_momentary ();\n-\t\t  $$ = start_enum (make_anon_name ()); }\n+\t\t  $<ttype>$ = start_enum (make_anon_name ()); }\n \t  enumlist maybecomma_warn '}'\n-\t\t{ $$ = finish_enum ($<ttype>3, $4);\n+\t\t{ $$.t = finish_enum ($<ttype>3, $4);\n \t\t  resume_momentary ((int) $<itype>1);\n-\t\t  check_for_missing_semicolon ($<ttype>3); }\n+\t\t  check_for_missing_semicolon ($<ttype>3);\n+\t\t  $$.new_type_flag = 1; }\n \t| ENUM '{' '}'\n-\t\t{ $$ = finish_enum (start_enum (make_anon_name()), NULL_TREE);\n-\t\t  check_for_missing_semicolon ($$); }\n+\t\t{ $$.t = finish_enum (start_enum (make_anon_name()), NULL_TREE);\n+\t\t  $$.new_type_flag = 1;\n+\t\t  check_for_missing_semicolon ($$.t); }\n \t| ENUM identifier\n-\t\t{ $$ = xref_tag (enum_type_node, $2, NULL_TREE, 1); }\n+\t\t{ $$.t = xref_tag (enum_type_node, $2, NULL_TREE, 1); \n+\t\t  $$.new_type_flag = 0; }\n \t| ENUM complex_type_name\n-\t\t{ $$ = xref_tag (enum_type_node, $2, NULL_TREE, 1); }\n+\t\t{ $$.t = xref_tag (enum_type_node, $2, NULL_TREE, 1); \n+\t\t  $$.new_type_flag = 0; }\n \t| TYPENAME_KEYWORD nested_name_specifier identifier\n-\t\t{ $$ = make_typename_type ($2, $3); }\n+\t\t{ $$.t = make_typename_type ($2, $3); \n+\t\t  $$.new_type_flag = 0; }\n \t| TYPENAME_KEYWORD global_scope nested_name_specifier identifier\n-\t\t{ $$ = make_typename_type ($3, $4); }\n+\t\t{ $$.t = make_typename_type ($3, $4); \n+\t\t  $$.new_type_flag = 0; }\n \t/* C++ extensions, merged with C to avoid shift/reduce conflicts */\n \t| class_head left_curly opt.component_decl_list '}' maybe_attribute\n \t\t{\n \t\t  int semi;\n \t\t  tree id;\n \n+\t\t  $<ttype>$ = $1;\n #if 0\n \t\t  /* Need to rework class nesting in the\n \t\t     presence of nested classes, etc.  */\n@@ -2193,14 +2229,17 @@ structsp:\n \t\t    do_pending_inlines ();\n \t\t}\n \t  pending_inlines\n-\t\t{ $$ = $<ttype>6; }\n+\t\t{ $$.t = $<ttype>6;\n+\t\t  $$.new_type_flag = 1; }\n \t| class_head  %prec EMPTY\n \t\t{\n+\t\t  $$.t = $1;\n+\t\t  $$.new_type_flag = 0;\n \t\t  /* struct B: public A; is not accepted by the WP grammar.  */\n-\t\t  if (TYPE_BINFO_BASETYPES ($$) && !TYPE_SIZE ($$)\n-\t\t      && ! TYPE_BEING_DEFINED ($$))\n+\t\t  if (TYPE_BINFO_BASETYPES ($$.t) && !TYPE_SIZE ($$.t)\n+\t\t      && ! TYPE_BEING_DEFINED ($$.t))\n \t\t    cp_error (\"base clause without member specification for `%#T'\",\n-\t\t\t      $$);\n+\t\t\t      $$.t);\n \t\t}\n \t;\n \n@@ -2403,10 +2442,10 @@ base_class.1:\n \t\t{\n \t\t  if (current_aggr == signature_type_node)\n \t\t    {\n-\t\t      if (IS_AGGR_TYPE (groktypename ($3)))\n+\t\t      if (IS_AGGR_TYPE (groktypename ($3.t)))\n \t\t\t{\n \t\t\t  sorry (\"`sigof' as base signature specifier\");\n-\t\t\t  $$ = groktypename ($3);\n+\t\t\t  $$ = groktypename ($3.t);\n \t\t\t}\n \t\t      else\n \t\t\t{\n@@ -2625,7 +2664,7 @@ component_decl_1:\n \t   speed; we need to call grok_x_components for enums, so the\n \t   speedup would be insignificant.  */\n \t  typed_declspecs components\n-\t\t{ $$ = grok_x_components ($1, $2); }\n+\t\t{ $$ = grok_x_components ($1.t, $2); }\n \t| declmods notype_components\n \t\t{ $$ = grok_x_components ($1, $2); }\n \t| notype_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n@@ -2783,17 +2822,20 @@ enumerator:\n /* ANSI new-type-id (5.3.4) */\n new_type_id:\n \t  type_specifier_seq new_declarator\n-\t\t{ $$ = build_decl_list ($$, $2); }\n+\t\t{ $$.t = build_decl_list ($1.t, $2); \n+\t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| type_specifier_seq %prec EMPTY\n-\t\t{ $$ = build_decl_list ($$, NULL_TREE); }\n+\t\t{ $$.t = build_decl_list ($1.t, NULL_TREE); \n+\t\t  $$.new_type_flag = $1.new_type_flag; }\n \t/* GNU extension to allow arrays of arbitrary types with\n \t   non-constant dimension.  */\n \t| '(' type_id ')' '[' expr ']'\n \t\t{\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids array dimensions with parenthesized type in new\");\n-\t\t  $$ = build_parse_node (ARRAY_REF, TREE_VALUE ($2), $5);\n-\t\t  $$ = build_decl_list (TREE_PURPOSE ($2), $$);\n+\t\t  $$.t = build_parse_node (ARRAY_REF, TREE_VALUE ($2.t), $5);\n+\t\t  $$.t = build_decl_list (TREE_PURPOSE ($2.t), $$.t);\n+\t\t  $$.new_type_flag = $2.new_type_flag;\n \t\t}\n \t;\n \n@@ -2806,9 +2848,11 @@ type_quals:\n \n nonempty_type_quals:\n \t  TYPE_QUAL\n-\t\t{ $$ = IDENTIFIER_AS_LIST ($$); }\n+\t\t{ $$.t = IDENTIFIER_AS_LIST ($1); \n+\t\t  $$.new_type_flag = 0; }\n \t| nonempty_type_quals TYPE_QUAL\n-\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }\n+\t\t{ $$.t = decl_tree_cons (NULL_TREE, $2, $1.t); \n+\t\t  $$.new_type_flag = $1.new_type_flag; }\n \t;\n \n /* These rules must follow the rules for function declarations\n@@ -2839,9 +2883,9 @@ maybe_parmlist:\n /* may all be followed by prec '.' */\n after_type_declarator:\n \t  '*' nonempty_type_quals after_type_declarator  %prec UNARY\n-\t\t{ $$ = make_pointer_declarator ($2, $3); }\n+\t\t{ $$ = make_pointer_declarator ($2.t, $3); }\n \t| '&' nonempty_type_quals after_type_declarator  %prec UNARY\n-\t\t{ $$ = make_reference_declarator ($2, $3); }\n+\t\t{ $$ = make_reference_declarator ($2.t, $3); }\n \t| '*' after_type_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator (NULL_TREE, $2); }\n \t| '&' after_type_declarator  %prec UNARY\n@@ -2913,9 +2957,9 @@ direct_after_type_declarator:\n \n notype_declarator:\n \t  '*' nonempty_type_quals notype_declarator  %prec UNARY\n-\t\t{ $$ = make_pointer_declarator ($2, $3); }\n+\t\t{ $$ = make_pointer_declarator ($2.t, $3); }\n \t| '&' nonempty_type_quals notype_declarator  %prec UNARY\n-\t\t{ $$ = make_reference_declarator ($2, $3); }\n+\t\t{ $$ = make_reference_declarator ($2.t, $3); }\n \t| '*' notype_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator (NULL_TREE, $2); }\n \t| '&' notype_declarator  %prec UNARY\n@@ -2929,9 +2973,9 @@ notype_declarator:\n \n complex_notype_declarator:\n \t  '*' nonempty_type_quals notype_declarator  %prec UNARY\n-\t\t{ $$ = make_pointer_declarator ($2, $3); }\n+\t\t{ $$ = make_pointer_declarator ($2.t, $3); }\n \t| '&' nonempty_type_quals notype_declarator  %prec UNARY\n-\t\t{ $$ = make_reference_declarator ($2, $3); }\n+\t\t{ $$ = make_reference_declarator ($2.t, $3); }\n \t| '*' complex_notype_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator (NULL_TREE, $2); }\n \t| '&' complex_notype_declarator  %prec UNARY\n@@ -2981,11 +3025,11 @@ overqualified_id:\n \n functional_cast:\n \t  typespec '(' nonnull_exprlist ')'\n-\t\t{ $$ = build_functional_cast ($$, $3); }\n+\t\t{ $$ = build_functional_cast ($1.t, $3); }\n \t| typespec '(' expr_or_declarator ')'\n-\t\t{ $$ = reparse_decl_as_expr ($$, $3); }\n+\t\t{ $$ = reparse_decl_as_expr ($1.t, $3); }\n \t| typespec fcast_or_absdcl %prec EMPTY\n-\t\t{ $$ = reparse_absdcl_as_expr ($$, $2); }\n+\t\t{ $$ = reparse_absdcl_as_expr ($1.t, $2); }\n \t;\n \n type_name:\n@@ -3099,19 +3143,19 @@ direct_new_declarator:\n /* ANSI abstract-declarator (8.1) */\n absdcl:\n \t  '*' nonempty_type_quals absdcl\n-\t\t{ $$ = make_pointer_declarator ($2, $3); }\n+\t\t{ $$ = make_pointer_declarator ($2.t, $3); }\n \t| '*' absdcl\n \t\t{ $$ = make_pointer_declarator (NULL_TREE, $2); }\n \t| '*' nonempty_type_quals  %prec EMPTY\n-\t\t{ $$ = make_pointer_declarator ($2, NULL_TREE); }\n+\t\t{ $$ = make_pointer_declarator ($2.t, NULL_TREE); }\n \t| '*' %prec EMPTY\n \t\t{ $$ = make_pointer_declarator (NULL_TREE, NULL_TREE); }\n \t| '&' nonempty_type_quals absdcl\n-\t\t{ $$ = make_reference_declarator ($2, $3); }\n+\t\t{ $$ = make_reference_declarator ($2.t, $3); }\n \t| '&' absdcl\n \t\t{ $$ = make_reference_declarator (NULL_TREE, $2); }\n \t| '&' nonempty_type_quals %prec EMPTY\n-\t\t{ $$ = make_reference_declarator ($2, NULL_TREE); }\n+\t\t{ $$ = make_reference_declarator ($2.t, NULL_TREE); }\n \t| '&' %prec EMPTY\n \t\t{ $$ = make_reference_declarator (NULL_TREE, NULL_TREE); }\n \t| ptr_to_mem type_quals %prec EMPTY\n@@ -3673,11 +3717,7 @@ try_block:\n \n handler_seq:\n \t  /* empty */\n-\t| handler_seq CATCH .pushlevel\n-\t\t{ dont_allow_type_definitions = \"inside exception declarations\"; }\n-\t  handler_args\n-\t\t{ dont_allow_type_definitions = 0; }\n-\t  compstmt\n+\t| handler_seq CATCH .pushlevel handler_args compstmt\n \t\t{ expand_end_catch_block (); }\n \t  .poplevel\n \t;\n@@ -3692,17 +3732,22 @@ handler_args:\n \t\t{ expand_start_catch_block (NULL_TREE, NULL_TREE); }\n \t/* This doesn't allow reference parameters, the below does.\n \t| '(' type_specifier_seq absdcl ')'\n-\t\t{ expand_start_catch_block ($2, $3); }\n+\t\t{ check_for_new_type (\"inside exception declarations\", $2);\n+\t\t  expand_start_catch_block ($2.t, $3); }\n \t| '(' type_specifier_seq ')'\n-\t\t{ expand_start_catch_block ($2, NULL_TREE); }\n+\t\t{ check_for_new_type (\"inside exception declarations\", $2);\n+\t\t  expand_start_catch_block ($2.t, NULL_TREE); }\n \t| '(' type_specifier_seq notype_declarator ')'\n-\t\t{ expand_start_catch_block ($2, $3); }\n+\t\t{ check_for_new_type (\"inside exception declarations\", $2);\n+\t\t  expand_start_catch_block ($2.t, $3); }\n \t| '(' typed_typespecs after_type_declarator ')'\n-\t\t{ expand_start_catch_block ($2, $3); }\n+\t\t{ check_for_new_type (\"inside exception declarations\", $2);\n+\t\t  expand_start_catch_block ($2.t, $3); }\n \tThis allows reference parameters... */\n \t| '(' parm ')'\n-\t\t{ expand_start_catch_block (TREE_PURPOSE ($2),\n-\t\t\t\t\t    TREE_VALUE ($2)); }\n+\t\t{ check_for_new_type (\"inside exception declarations\", $2);\n+\t\t  expand_start_catch_block (TREE_PURPOSE ($2.t),\n+\t\t\t\t\t    TREE_VALUE ($2.t)); }\n \t;\n \n label_colon:\n@@ -3782,15 +3827,13 @@ asm_clobbers:\n \n parmlist:  /* empty */\n \t\t{\n-\t\t  if (strict_prototype)\n-\t\t    $$ = void_list_node;\n-\t\t  else\n-\t\t    $$ = NULL_TREE;\n+\t\t  $$ = empty_parms();\n \t\t}\n \t| complex_parmlist\n \t| type_id\n-\t\t{ $$ = tree_cons (NULL_TREE, $$, void_list_node);\n-\t\t  TREE_PARMLIST ($$) = 1; }\n+\t\t{ $$ = tree_cons (NULL_TREE, $1.t, void_list_node);\n+\t\t  TREE_PARMLIST ($$) = 1; \n+\t\t  check_for_new_type (\"inside parameter list\", $1); }\n \t;\n \n /* This nonterminal does not include the common sequence '(' type_id ')',\n@@ -3812,7 +3855,7 @@ complex_parmlist:\n \t\t}\n \t| type_id ELLIPSIS\n \t\t{\n-\t\t  $$ = build_tree_list (NULL_TREE, $$); \n+\t\t  $$ = build_tree_list (NULL_TREE, $1.t); \n \t\t  TREE_PARMLIST ($$) = 1;\n \t\t}\n \t| ELLIPSIS\n@@ -3829,7 +3872,7 @@ complex_parmlist:\n \t\t}\n \t| type_id TYPENAME_ELLIPSIS\n \t\t{\n-\t\t  $$ = build_tree_list (NULL_TREE, $$);\n+\t\t  $$ = build_tree_list (NULL_TREE, $1.t);\n \t\t  TREE_PARMLIST ($$) = 1;\n \t\t}\n \t| parms ':'\n@@ -3849,7 +3892,7 @@ complex_parmlist:\n \t\t     parse errors, for example, a missing right\n \t\t     parenthesis.  */\n \t\t  yyerror (\"possibly missing ')'\");\n-\t\t  $$ = tree_cons (NULL_TREE, $$, void_list_node);\n+\t\t  $$ = tree_cons (NULL_TREE, $1.t, void_list_node);\n \t\t  TREE_PARMLIST ($$) = 1;\n \t\t  yyungetc (':', 0);\n \t\t  yychar = ')';\n@@ -3859,11 +3902,14 @@ complex_parmlist:\n /* A nonempty list of parameter declarations or type names.  */\n parms:\n \t  named_parm\n-\t\t{ $$ = build_tree_list (NULL_TREE, $$); }\n+\t\t{ check_for_new_type (\"in a parameter list\", $1);\n+\t\t  $$ = build_tree_list (NULL_TREE, $1.t); }\n \t| parm '=' init\n-\t\t{ $$ = build_tree_list ($3, $$); }\n+\t\t{ check_for_new_type (\"in a parameter list\", $1);\n+\t\t  $$ = build_tree_list ($3, $1.t); }\n \t| parms_comma full_parm\n-\t\t{ $$ = chainon ($$, $2); }\n+\t\t{ check_for_new_type (\"in a parameter list\", $2);\n+\t\t  $$ = chainon ($$, $2.t); }\n \t| parms_comma bad_parm\n \t\t{ $$ = chainon ($$, build_tree_list (NULL_TREE, $2)); }\n \t| parms_comma bad_parm '=' init\n@@ -3873,7 +3919,8 @@ parms:\n parms_comma:\n \t  parms ','\n \t| type_id ','\n-\t\t{ $$ = build_tree_list (NULL_TREE, $$); }\n+\t\t{ check_for_new_type (\"in a parameter list\", $1);\n+\t\t  $$ = build_tree_list (NULL_TREE, $1.t); }\n \t;\n \n /* A single parameter declaration or parameter type name,\n@@ -3883,41 +3930,52 @@ parms_comma:\n named_parm:\n /*\n \t  typed_declspecs dont_see_typename '*' IDENTIFIER\n-\t\t{ tree specs = strip_attrs ($1);\n-\t\t  $$ = build_tree_list (specs, build_parse_node (INDIRECT_REF, $4));\n+\t\t{ tree specs = strip_attrs ($1.t);\n+\t\t  $$.t = build_tree_list (specs, build_parse_node (INDIRECT_REF, $4));\n+\t\t  $$.new_type_flag = $1.new_type_flag;\n \t\t  see_typename (); }\n \t| typed_declspecs dont_see_typename '&' IDENTIFIER\n-\t\t{ tree specs = strip_attrs ($1);\n-\t\t  $$ = build_tree_list (specs, build_parse_node (ADDR_EXPR, $4));\n+\t\t{ tree specs = strip_attrs ($1.t);\n+\t\t  $$.t = build_tree_list (specs, build_parse_node (ADDR_EXPR, $4));\n+\t\t  $$.new_type_flag = $1.new_type_flag;\n \t\t  see_typename (); }\n \t| TYPENAME IDENTIFIER\n-\t\t{ $$ = build_tree_list (get_decl_list ($$), $2);  }\n+\t\t{ $$.t = build_tree_list (get_decl_list ($$), $2);  \n+\t\t  $$.new_type_flag = 0; }\n \t| TYPESPEC IDENTIFIER\n-\t\t{ $$ = build_tree_list (get_decl_list ($$), $2); }\n+\t\t{ $$.t = build_tree_list (get_decl_list ($$), $2); \n+\t\t  $$.new_type_flag = 0; }\n \t| */\n \t/* Here we expand typed_declspecs inline to avoid mis-parsing of\n \t   TYPESPEC IDENTIFIER.  */\n \t  typed_declspecs1 declarator\n-\t\t{ tree specs = strip_attrs ($1);\n-\t\t  $$ = build_tree_list (specs, $2); }\n+\t\t{ tree specs = strip_attrs ($1.t);\n+\t\t  $$.new_type_flag = $1.new_type_flag;\n+\t\t  $$.t = build_tree_list (specs, $2); }\n \t| typed_typespecs declarator\n-\t\t{ $$ = build_tree_list ($$, $2); }\n+\t\t{ $$.t = build_tree_list ($1.t, $2); \n+\t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typespec declarator\n-\t\t{ $$ = build_tree_list (get_decl_list ($$), $2); }\n+\t\t{ $$.t = build_tree_list (get_decl_list ($1.t), $2); \n+\t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typed_declspecs1 absdcl\n-\t\t{ tree specs = strip_attrs ($1);\n-\t\t  $$ = build_tree_list (specs, $2); }\n+\t\t{ tree specs = strip_attrs ($1.t);\n+\t\t  $$.t = build_tree_list (specs, $2);\n+\t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typed_declspecs1 %prec EMPTY\n-\t\t{ tree specs = strip_attrs ($1);\n-\t\t  $$ = build_tree_list (specs, NULL_TREE); }\n+\t\t{ tree specs = strip_attrs ($1.t);\n+\t\t  $$.t = build_tree_list (specs, NULL_TREE); \n+\t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| declmods notype_declarator\n \t\t{ tree specs = strip_attrs ($1);\n-\t\t  $$ = build_tree_list (specs, $2); }\n+\t\t  $$.t = build_tree_list (specs, $2); \n+\t\t  $$.new_type_flag = 0; }\n \t;\n \n full_parm:\n \t  parm maybe_init\n-\t\t{ $$ = build_tree_list ($2, $$); }\n+\t\t{ $$.t = build_tree_list ($2, $1.t);\n+\t\t  $$.new_type_flag = $1.new_type_flag;  }\n \t;\n \n parm:\n@@ -3974,7 +4032,7 @@ exception_specification_opt:\n \n ansi_raise_identifier:\n \t  type_id\n-\t\t{ $$ = build_decl_list (NULL_TREE, groktypename($$)); }\n+\t\t{ $$ = build_decl_list (NULL_TREE, groktypename($1.t)); }\n \t;\n \n ansi_raise_identifiers:\n@@ -4072,7 +4130,7 @@ operator_name:\n \t\t{ $$ = ansi_opname[VEC_DELETE_EXPR]; }\n \t/* Names here should be looked up in class scope ALSO.  */\n \t| operator type_specifier_seq conversion_declarator\n-\t\t{ $$ = grokoptypename ($2, $3); }\n+\t\t{ $$ = grokoptypename ($2.t, $3); }\n \t| operator error\n \t\t{ $$ = ansi_opname[ERROR_MARK]; }\n \t;"}, {"sha": "12575ec28de2234bf9f85768bc2e61803ab4b05d", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=46b02c6d614586e17d73588f4a99f7fbb87fb276", "patch": "@@ -28,8 +28,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"input.h\"\n #include \"tree.h\"\n #include \"lex.h\"\n-#include \"parse.h\"\n #include \"cp-tree.h\"\n+#include \"parse.h\"\n #include \"flags.h\"\n #include \"obstack.h\"\n "}, {"sha": "4b9b11eff7092605b62c04a6eafb1b17851f27f8", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=46b02c6d614586e17d73588f4a99f7fbb87fb276", "patch": "@@ -5460,7 +5460,8 @@ build_modify_expr (lhs, modifycode, rhs)\n     case PREINCREMENT_EXPR:\n       if (TREE_SIDE_EFFECTS (TREE_OPERAND (lhs, 0)))\n \tlhs = build (TREE_CODE (lhs), TREE_TYPE (lhs),\n-\t\t     stabilize_reference (TREE_OPERAND (lhs, 0)));\n+\t\t     stabilize_reference (TREE_OPERAND (lhs, 0)),\n+\t\t     TREE_OPERAND (lhs, 1));\n       return build (COMPOUND_EXPR, lhstype,\n \t\t    lhs,\n \t\t    build_modify_expr (TREE_OPERAND (lhs, 0),"}, {"sha": "b0ea21cc117a25fdafcd925704ee72113127abd8", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b02c6d614586e17d73588f4a99f7fbb87fb276/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=46b02c6d614586e17d73588f4a99f7fbb87fb276", "patch": "@@ -1592,3 +1592,12 @@ report_case_error (code, type, new_value, old_value)\n     }\n }\n #endif\n+\n+void\n+check_for_new_type (string, inptree)\n+     char *string;\n+     flagged_type_tree inptree;\n+{\n+  if (pedantic && inptree.new_type_flag)\n+    pedwarn (\"ANSI C++ forbids defining types within %s\",string);\n+}"}]}