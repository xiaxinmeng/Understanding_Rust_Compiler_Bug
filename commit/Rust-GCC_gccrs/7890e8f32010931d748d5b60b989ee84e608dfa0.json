{"sha": "7890e8f32010931d748d5b60b989ee84e608dfa0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg5MGU4ZjMyMDEwOTMxZDc0OGQ1YjYwYjk4OWVlODRlNjA4ZGZhMA==", "commit": {"author": {"name": "Michael Hayes", "email": "mph@paradise.net.nz", "date": "2003-01-26T06:10:37Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2003-01-26T06:10:37Z"}, "message": "df.h: Update comments, tidy formatting.\n\n\t* df.h: Update comments, tidy formatting.\n\t(DF_FORWARD, DF_REVERSE, DF_UNION, DF_INTERSECTION): Rename from FORWARD,\n\tREVERSE, UNION, INTERSECTION.  All uses updated.\n\t(OLD_DF_INTERFACE): Remove.\n\t(struct insn_info): Remove commented out insn field.\n\t* df.c: Update comments, tidy formatting.\n\t(df_def_table_realloc): Remove.\n\nFrom-SVN: r61819", "tree": {"sha": "c9f88f6125818db1d96c7eb7e037a2987f434971", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9f88f6125818db1d96c7eb7e037a2987f434971"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7890e8f32010931d748d5b60b989ee84e608dfa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7890e8f32010931d748d5b60b989ee84e608dfa0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7890e8f32010931d748d5b60b989ee84e608dfa0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7890e8f32010931d748d5b60b989ee84e608dfa0/comments", "author": null, "committer": null, "parents": [{"sha": "b820d2b8702a1702e8e869fcdb2382e89f014b4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b820d2b8702a1702e8e869fcdb2382e89f014b4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b820d2b8702a1702e8e869fcdb2382e89f014b4c"}], "stats": {"total": 297, "additions": 161, "deletions": 136}, "files": [{"sha": "9a827a484e486feb16ab93ac98067fd001354219", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7890e8f32010931d748d5b60b989ee84e608dfa0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7890e8f32010931d748d5b60b989ee84e608dfa0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7890e8f32010931d748d5b60b989ee84e608dfa0", "patch": "@@ -1,3 +1,14 @@\n+2003-01-26  Michael Hayes  <mph@paradise.net.nz>\n+\n+\t* df.h: Update comments, tidy formatting.\n+\t(DF_FORWARD, DF_REVERSE, DF_UNION, DF_INTERSECTION): Rename from FORWARD,\n+\tREVERSE, UNION, INTERSECTION.  All uses updated.\n+\t(OLD_DF_INTERFACE): Remove.\n+\t(struct insn_info): Remove commented out insn field.\n+\t* df.c: Update comments, tidy formatting.\n+\t(df_def_table_realloc): Remove.\n+\n+\n 2003-01-26  Alan Modra  <amodra@bigpond.net.au>\n \n \t* calls.c (save_fixed_argument_area): Tidy."}, {"sha": "bea0206699437aa081d74bec3da500b94247ae4f", "filename": "gcc/df.c", "status": "modified", "additions": 103, "deletions": 94, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7890e8f32010931d748d5b60b989ee84e608dfa0/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7890e8f32010931d748d5b60b989ee84e608dfa0/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=7890e8f32010931d748d5b60b989ee84e608dfa0", "patch": "@@ -1,5 +1,5 @@\n /* Dataflow support routines.\n-   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz,\n                                     mhayes@redhat.com)\n \n@@ -54,7 +54,8 @@ Here's an example of using the dataflow routines.\n \n df_init simply creates a poor man's object (df) that needs to be\n passed to all the dataflow routines.  df_finish destroys this\n-object and frees up any allocated memory.\n+object and frees up any allocated memory.   DF_ALL says to analyse\n+everything.\n \n df_analyse performs the following:\n \n@@ -112,6 +113,7 @@ rather than searching the def or use bitmaps.\n If the insns are in SSA form then the reg-def and use-def lists\n should only contain the single defining ref.\n \n+\n TODO:\n \n 1) Incremental dataflow analysis.\n@@ -129,9 +131,7 @@ insns so when df_analyse is called we can easily determine all the new\n or deleted refs.  Currently the global dataflow information is\n recomputed from scratch but this could be propagated more efficiently.\n \n-2) Improved global data flow computation using depth first search.\n-\n-3) Reduced memory requirements.\n+2) Reduced memory requirements.\n \n We could operate a pool of ref structures.  When a ref is deleted it\n gets returned to the pool (say by linking on to a chain of free refs).\n@@ -140,18 +140,35 @@ tell which ones have been changed.  Alternatively, we could\n periodically squeeze the def and use tables and associated bitmaps and\n renumber the def and use ids.\n \n-4) Ordering of reg-def and reg-use lists.\n+3) Ordering of reg-def and reg-use lists.\n \n Should the first entry in the def list be the first def (within a BB)?\n Similarly, should the first entry in the use list be the last use\n (within a BB)?\n \n-5) Working with a sub-CFG.\n+4) Working with a sub-CFG.\n \n Often the whole CFG does not need to be analyzed, for example,\n when optimising a loop, only certain registers are of interest.\n Perhaps there should be a bitmap argument to df_analyse to specify\n- which registers should be analyzed?   */\n+which registers should be analyzed?   \n+\n+\n+NOTES:\n+\n+Embedded addressing side-effects, such as POST_INC or PRE_INC, generate\n+both a use and a def.  These are both marked read/write to show that they \n+are dependent. For example, (set (reg 40) (mem (post_inc (reg 42))))\n+will generate a use of reg 42 followed by a def of reg 42 (both marked \n+read/write).  Similarly, (set (reg 40) (mem (pre_dec (reg 41)))) \n+generates a use of reg 41 then a def of reg 41 (both marked read/write),\n+even though reg 41 is decremented before it is used for the memory\n+address in this second example.\n+\n+A set to a REG inside a ZERO_EXTRACT, SIGN_EXTRACT, or SUBREG invokes\n+a read-modify write operation.  We generate both a use and a def\n+and again mark them read/write.\n+*/\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -184,9 +201,6 @@ static struct obstack df_ref_obstack;\n static struct df *ddf;\n \n static void df_reg_table_realloc PARAMS((struct df *, int));\n-#if 0\n-static void df_def_table_realloc PARAMS((struct df *, int));\n-#endif\n static void df_insn_table_realloc PARAMS((struct df *, unsigned int));\n static void df_bitmaps_alloc PARAMS((struct df *, int));\n static void df_bitmaps_free PARAMS((struct df *, int));\n@@ -276,6 +290,7 @@ static struct ref *df_bb_insn_regno_first_def_find PARAMS((struct df *,\n static void df_chain_dump PARAMS((struct df_link *, FILE *file));\n static void df_chain_dump_regno PARAMS((struct df_link *, FILE *file));\n static void df_regno_debug PARAMS ((struct df *, unsigned int, FILE *));\n+static void df_regno_rtl_debug PARAMS ((struct df *, unsigned int, FILE *));\n static void df_ref_debug PARAMS ((struct df *, struct ref *, FILE *));\n static void df_rd_transfer_function PARAMS ((int, int *, bitmap, bitmap,\n \t\t\t\t\t     bitmap, bitmap, void *));\n@@ -310,7 +325,7 @@ df_insn_table_realloc (df, size)\n   if (size <= df->insn_size)\n     return;\n \n-  /* Make the table a little larger than requested, so we don't need\n+  /* Make the table a little larger than requested, so we do not need\n      to enlarge it so often.  */\n   size += df->insn_size / 4;\n \n@@ -355,38 +370,6 @@ df_reg_table_realloc (df, size)\n }\n \n \n-#if 0\n-/* Not currently used.  */\n-static void\n-df_def_table_realloc (df, size)\n-     struct df *df;\n-     int size;\n-{\n-  int i;\n-  struct ref *refs;\n-\n-  /* Make table 25 percent larger by default.  */\n-  if (! size)\n-    size = df->def_size / 4;\n-\n-  df->def_size += size;\n-  df->defs = xrealloc (df->defs,\n-\t\t       df->def_size * sizeof (*df->defs));\n-\n-  /* Allocate a new block of memory and link into list of blocks\n-     that will need to be freed later.  */\n-\n-  refs = xmalloc (size * sizeof (*refs));\n-\n-  /* Link all the new refs together, overloading the chain field.  */\n-  for (i = 0; i < size - 1; i++)\n-    refs[i].chain = (struct df_link *) (refs + i + 1);\n-  refs[size - 1].chain = 0;\n-}\n-#endif\n-\n-\n-\n /* Allocate bitmaps for each basic block.  */\n static void\n df_bitmaps_alloc (df, flags)\n@@ -878,9 +861,9 @@ df_ref_record (df, reg, loc, insn, ref_type, ref_flags)\n       if (! (df->flags & DF_HARD_REGS))\n \treturn;\n \n-      /* GET_MODE (reg) is correct here.  We don't want to go into a SUBREG\n+      /* GET_MODE (reg) is correct here.  We do not want to go into a SUBREG\n          for the mode, because we only want to add references to regs, which\n-\t are really referenced.  E.g. a (subreg:SI (reg:DI 0) 0) does _not_\n+\t are really referenced.  E.g., a (subreg:SI (reg:DI 0) 0) does _not_\n \t reference the whole reg 0 in DI mode (which would also include\n \t reg 1, at least, if 0 and 1 are SImode registers).  */\n       endregno = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n@@ -899,9 +882,9 @@ df_ref_record (df, reg, loc, insn, ref_type, ref_flags)\n     }\n }\n \n-/* Writes to paradoxical subregs, or subregs which are too narrow\n-   are read-modify-write.  */\n \n+/* Return non-zero if writes to paradoxical SUBREGs, or SUBREGs which\n+   are too narrow, are read-modify-write.  */\n static inline bool\n read_modify_subreg_p (x)\n      rtx x;\n@@ -920,6 +903,7 @@ read_modify_subreg_p (x)\n   return true;\n }\n \n+\n /* Process all the registers defined in the rtx, X.  */\n static void\n df_def_record_1 (df, x, bb, insn)\n@@ -950,14 +934,14 @@ df_def_record_1 (df, x, bb, insn)\n     flags |= DF_REF_MODE_CHANGE;\n #endif\n \n-  /* May be, we should flag the use of strict_low_part somehow.  Might be\n-     handy for the reg allocator.  */\n+  /* Maybe, we should flag the use of STRICT_LOW_PART somehow.  It might\n+     be handy for the reg allocator.  */\n   while (GET_CODE (dst) == STRICT_LOW_PART\n \t || GET_CODE (dst) == ZERO_EXTRACT\n \t || GET_CODE (dst) == SIGN_EXTRACT\n \t || read_modify_subreg_p (dst))\n     {\n-      /* Strict low part always contains SUBREG, but we don't want to make\n+      /* Strict low part always contains SUBREG, but we do not want to make\n \t it appear outside, as whole register is always considered.  */\n       if (GET_CODE (dst) == STRICT_LOW_PART)\n \t{\n@@ -1059,7 +1043,7 @@ df_uses_record (df, loc, ref_type, bb, insn, flags)\n     case SUBREG:\n       /* While we're here, optimize this case.  */\n \n-      /* In case the SUBREG is not of a register, don't optimize.  */\n+      /* In case the SUBREG is not of a REG, do not optimize.  */\n       if (GET_CODE (SUBREG_REG (x)) != REG)\n \t{\n \t  loc = &SUBREG_REG (x);\n@@ -1075,7 +1059,7 @@ df_uses_record (df, loc, ref_type, bb, insn, flags)\n       /* ... Fall through ...  */\n \n     case REG:\n-      /* See a register (or subreg) other than being set.  */\n+      /* See a REG (or SUBREG) other than being set.  */\n       df_ref_record (df, x, loc, insn, ref_type, flags);\n       return;\n \n@@ -1113,7 +1097,7 @@ df_uses_record (df, loc, ref_type, bb, insn, flags)\n \t\t\t      bb, insn, 0);\n \t      break;\n \t    case STRICT_LOW_PART:\n-\t      /* A strict_low_part uses the whole reg not only the subreg.  */\n+\t      /* A strict_low_part uses the whole REG and not just the SUBREG.  */\n \t      dst = XEXP (dst, 0);\n \t      if (GET_CODE (dst) != SUBREG)\n \t\tabort ();\n@@ -1286,7 +1270,6 @@ df_insn_refs_record (df, bb, insn)\n       df_uses_record (df, &PATTERN (insn),\n \t\t      DF_REF_REG_USE, bb, insn, 0);\n \n-\n       if (GET_CODE (insn) == CALL_INSN)\n \t{\n \t  rtx note;\n@@ -1379,9 +1362,11 @@ df_bb_reg_def_chain_create (df, bb)\n \t{\n \t  struct ref *def = link->ref;\n \t  unsigned int dregno = DF_REF_REGNO (def);\n-          /* Don't add ref's to the chain two times.  I.e. only add\n-             new refs.  XXX the same could be done by testing if the current\n-             insn is a modified (or a new) one.  This would be faster.  */\n+\n+          /* Do not add ref's to the chain twice, i.e., only add new\n+             refs.  XXX the same could be done by testing if the\n+             current insn is a modified (or a new) one.  This would be\n+             faster.  */\n           if (DF_REF_ID (def) < df->def_id_save)\n             continue;\n \n@@ -1417,8 +1402,8 @@ df_bb_reg_use_chain_create (df, bb)\n {\n   rtx insn;\n \n-  /* Scan in forward order so that the last uses appear at the\n-\t start of the chain.  */\n+  /* Scan in forward order so that the last uses appear at the start\n+     of the chain.  */\n \n   for (insn = bb->head; insn && insn != NEXT_INSN (bb->end);\n        insn = NEXT_INSN (insn))\n@@ -1433,9 +1418,11 @@ df_bb_reg_use_chain_create (df, bb)\n \t{\n \t  struct ref *use = link->ref;\n \t  unsigned int uregno = DF_REF_REGNO (use);\n-          /* Don't add ref's to the chain two times.  I.e. only add\n-             new refs.  XXX the same could be done by testing if the current\n-             insn is a modified (or a new) one.  This would be faster.  */\n+\n+          /* Do not add ref's to the chain twice, i.e., only add new\n+             refs.  XXX the same could be done by testing if the\n+             current insn is a modified (or a new) one.  This would be\n+             faster.  */\n           if (DF_REF_ID (use) < df->use_id_save)\n             continue;\n \n@@ -1606,7 +1593,7 @@ df_bb_ud_chain_create (df, bb)\n \t}\n \n \n-      /* For each def in insn...record the last def of each reg.  */\n+      /* For each def in insn... record the last def of each reg.  */\n       for (def_link = df->insns[uid].defs; def_link; def_link = def_link->next)\n \t{\n \t  struct ref *def = def_link->ref;\n@@ -1644,6 +1631,8 @@ df_rd_transfer_function (bb, changed, in, out, gen, kill, data)\n {\n   *changed = bitmap_union_of_diff (out, gen, in, kill);\n }\n+\n+\n static void\n df_ru_transfer_function (bb, changed, in, out, gen, kill, data)\n      int bb ATTRIBUTE_UNUSED;\n@@ -1654,6 +1643,7 @@ df_ru_transfer_function (bb, changed, in, out, gen, kill, data)\n   *changed = bitmap_union_of_diff (in, gen, out, kill);\n }\n \n+\n static void\n df_lr_transfer_function (bb, changed, in, out, use, def, data)\n      int bb ATTRIBUTE_UNUSED;\n@@ -1968,6 +1958,7 @@ df_luids_set (df, blocks)\n   return total;\n }\n \n+\n /* Perform dataflow analysis using existing DF structure for blocks\n    within BLOCKS.  If BLOCKS is zero, use all basic blocks in the CFG.  */\n static void\n@@ -2077,7 +2068,7 @@ df_analyse_1 (df, blocks, flags, update)\n \t    kill[bb->index] = DF_BB_INFO (df, bb)->rd_kill;\n \t  }\n \titerative_dataflow_bitmap (in, out, gen, kill, df->all_blocks,\n-\t\t\t\t   FORWARD, UNION, df_rd_transfer_function,\n+\t\t\t\t   DF_FORWARD, DF_UNION, df_rd_transfer_function,\n \t\t\t\t   df->inverse_rc_map, NULL);\n \tfree (in);\n \tfree (out);\n@@ -2113,7 +2104,7 @@ df_analyse_1 (df, blocks, flags, update)\n \t    kill[bb->index] = DF_BB_INFO (df, bb)->ru_kill;\n \t  }\n \titerative_dataflow_bitmap (in, out, gen, kill, df->all_blocks,\n-\t\t\t\t   BACKWARD, UNION, df_ru_transfer_function,\n+\t\t\t\t   DF_BACKWARD, DF_UNION, df_ru_transfer_function,\n \t\t\t\t   df->inverse_rts_map, NULL);\n \tfree (in);\n \tfree (out);\n@@ -2152,7 +2143,7 @@ df_analyse_1 (df, blocks, flags, update)\n \t    def[bb->index] = DF_BB_INFO (df, bb)->lr_def;\n \t  }\n \titerative_dataflow_bitmap (in, out, use, def, df->all_blocks,\n-\t\t\t\t   BACKWARD, UNION, df_lr_transfer_function,\n+\t\t\t\t   DF_BACKWARD, DF_UNION, df_lr_transfer_function,\n \t\t\t\t   df->inverse_rts_map, NULL);\n \tfree (in);\n \tfree (out);\n@@ -2243,7 +2234,7 @@ df_bb_refs_update (df, bb)\n   rtx insn;\n   int count = 0;\n \n-  /* While we have to scan the chain of insns for this BB, we don't\n+  /* While we have to scan the chain of insns for this BB, we do not\n      need to allocate and queue a long chain of BB/INSN pairs.  Using\n      a bitmap for insns_modified saves memory and avoids queuing\n      duplicates.  */\n@@ -2502,7 +2493,8 @@ df_insn_modify (df, bb, insn)\n }\n \n \n-typedef struct replace_args {\n+typedef struct replace_args\n+{\n   rtx match;\n   rtx replacement;\n   rtx insn;\n@@ -3282,6 +3274,8 @@ df_chain_dump (link, file)\n   fprintf (file, \"}\");\n }\n \n+\n+/* Dump a chain of refs with the associated regno.  */\n static void\n df_chain_dump_regno (link, file)\n      struct df_link *link;\n@@ -3298,6 +3292,7 @@ df_chain_dump_regno (link, file)\n   fprintf (file, \"}\");\n }\n \n+\n /* Dump dataflow info.  */\n void\n df_dump (df, flags, file)\n@@ -3501,6 +3496,7 @@ df_insn_debug (df, insn, file)\n   fprintf (file, \"\\n\");\n }\n \n+\n void\n df_insn_debug_regno (df, insn, file)\n      struct df *df;\n@@ -3529,6 +3525,7 @@ df_insn_debug_regno (df, insn, file)\n   fprintf (file, \"\\n\");\n }\n \n+\n static void\n df_regno_debug (df, regno, file)\n      struct df *df;\n@@ -3564,7 +3561,8 @@ df_ref_debug (df, ref, file)\n   df_chain_dump (DF_REF_CHAIN (ref), file);\n   fprintf (file, \"\\n\");\n }\n-\n+\f\n+/* Functions for debugging from GDB.  */\n \n void\n debug_df_insn (insn)\n@@ -3622,6 +3620,7 @@ debug_df_chain (link)\n   df_chain_dump (link, stderr);\n   fputc ('\\n', stderr);\n }\n+\f\n \n /* Hybrid search algorithm from \"Implementation Techniques for\n    Efficient Data-Flow Analysis of Large Programs\".  */\n@@ -3642,42 +3641,43 @@ hybrid_search_bitmap (block, in, out, gen, kill, dir,\n   int i = block->index;\n   edge e;\n   basic_block bb = block;\n+\n   SET_BIT (visited, block->index);\n   if (TEST_BIT (pending, block->index))\n     {\n-      if (dir == FORWARD)\n+      if (dir == DF_FORWARD)\n \t{\n-\t  /*  Calculate <conf_op> of predecessor_outs */\n+\t  /*  Calculate <conf_op> of predecessor_outs.  */\n \t  bitmap_zero (in[i]);\n \t  for (e = bb->pred; e != 0; e = e->pred_next)\n \t    {\n \t      if (e->src == ENTRY_BLOCK_PTR)\n \t\tcontinue;\n \t      switch (conf_op)\n \t\t{\n-\t\tcase UNION:\n+\t\tcase DF_UNION:\n \t\t  bitmap_a_or_b (in[i], in[i], out[e->src->index]);\n \t\t  break;\n-\t\tcase INTERSECTION:\n+\t\tcase DF_INTERSECTION:\n \t\t  bitmap_a_and_b (in[i], in[i], out[e->src->index]);\n \t\t  break;\n \t\t}\n \t    }\n \t}\n       else\n \t{\n-\t  /* Calculate <conf_op> of successor ins */\n+\t  /* Calculate <conf_op> of successor ins.  */\n \t  bitmap_zero (out[i]);\n \t  for (e = bb->succ; e != 0; e = e->succ_next)\n \t    {\n \t      if (e->dest == EXIT_BLOCK_PTR)\n \t\tcontinue;\n \t      switch (conf_op)\n \t\t{\n-\t\tcase UNION:\n+\t\tcase DF_UNION:\n \t\t  bitmap_a_or_b (out[i], out[i], in[e->dest->index]);\n \t\t  break;\n-\t\tcase INTERSECTION:\n+\t\tcase DF_INTERSECTION:\n \t\t  bitmap_a_and_b (out[i], out[i], in[e->dest->index]);\n \t\t  break;\n \t\t}\n@@ -3688,7 +3688,7 @@ hybrid_search_bitmap (block, in, out, gen, kill, dir,\n       RESET_BIT (pending, i);\n       if (changed)\n \t{\n-\t  if (dir == FORWARD)\n+\t  if (dir == DF_FORWARD)\n \t    {\n \t      for (e = bb->succ; e != 0; e = e->succ_next)\n \t\t{\n@@ -3708,7 +3708,7 @@ hybrid_search_bitmap (block, in, out, gen, kill, dir,\n \t    }\n \t}\n     }\n-  if (dir == FORWARD)\n+  if (dir == DF_FORWARD)\n     {\n       for (e = bb->succ; e != 0; e = e->succ_next)\n \t{\n@@ -3753,53 +3753,54 @@ hybrid_search_sbitmap (block, in, out, gen, kill, dir,\n   int i = block->index;\n   edge e;\n   basic_block bb = block;\n+\n   SET_BIT (visited, block->index);\n   if (TEST_BIT (pending, block->index))\n     {\n-      if (dir == FORWARD)\n+      if (dir == DF_FORWARD)\n \t{\n-\t  /*  Calculate <conf_op> of predecessor_outs */\n+\t  /* Calculate <conf_op> of predecessor_outs.  */\n \t  sbitmap_zero (in[i]);\n \t  for (e = bb->pred; e != 0; e = e->pred_next)\n \t    {\n \t      if (e->src == ENTRY_BLOCK_PTR)\n \t\tcontinue;\n \t      switch (conf_op)\n \t\t{\n-\t\tcase UNION:\n+\t\tcase DF_UNION:\n \t\t  sbitmap_a_or_b (in[i], in[i], out[e->src->index]);\n \t\t  break;\n-\t\tcase INTERSECTION:\n+\t\tcase DF_INTERSECTION:\n \t\t  sbitmap_a_and_b (in[i], in[i], out[e->src->index]);\n \t\t  break;\n \t\t}\n \t    }\n \t}\n       else\n \t{\n-\t  /* Calculate <conf_op> of successor ins */\n+\t  /* Calculate <conf_op> of successor ins.  */\n \t  sbitmap_zero (out[i]);\n \t  for (e = bb->succ; e != 0; e = e->succ_next)\n \t    {\n \t      if (e->dest == EXIT_BLOCK_PTR)\n \t\tcontinue;\n \t      switch (conf_op)\n \t\t{\n-\t\tcase UNION:\n+\t\tcase DF_UNION:\n \t\t  sbitmap_a_or_b (out[i], out[i], in[e->dest->index]);\n \t\t  break;\n-\t\tcase INTERSECTION:\n+\t\tcase DF_INTERSECTION:\n \t\t  sbitmap_a_and_b (out[i], out[i], in[e->dest->index]);\n \t\t  break;\n \t\t}\n \t    }\n \t}\n-      /* Common part */\n+      /* Common part.  */\n       (*transfun)(i, &changed, in[i], out[i], gen[i], kill[i], data);\n       RESET_BIT (pending, i);\n       if (changed)\n \t{\n-\t  if (dir == FORWARD)\n+\t  if (dir == DF_FORWARD)\n \t    {\n \t      for (e = bb->succ; e != 0; e = e->succ_next)\n \t\t{\n@@ -3819,7 +3820,7 @@ hybrid_search_sbitmap (block, in, out, gen, kill, dir,\n \t    }\n \t}\n     }\n-  if (dir == FORWARD)\n+  if (dir == DF_FORWARD)\n     {\n       for (e = bb->succ; e != 0; e = e->succ_next)\n \t{\n@@ -3846,8 +3847,6 @@ hybrid_search_sbitmap (block, in, out, gen, kill, dir,\n }\n \n \n-\n-\n /* gen = GEN set.\n    kill = KILL set.\n    in, out = Filled in by function.\n@@ -3883,20 +3882,23 @@ iterative_dataflow_sbitmap (in, out, gen, kill, blocks,\n   fibheap_t worklist;\n   basic_block bb;\n   sbitmap visited, pending;\n+\n   pending = sbitmap_alloc (last_basic_block);\n   visited = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (pending);\n   sbitmap_zero (visited);\n   worklist = fibheap_new ();\n+\n   EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n   {\n     fibheap_insert (worklist, order[i], (void *) (size_t) i);\n     SET_BIT (pending, i);\n-    if (dir == FORWARD)\n+    if (dir == DF_FORWARD)\n       sbitmap_copy (out[i], gen[i]);\n     else\n       sbitmap_copy (in[i], gen[i]);\n   });\n+\n   while (sbitmap_first_set_bit (pending) != -1)\n     {\n       while (!fibheap_empty (worklist))\n@@ -3907,6 +3909,7 @@ iterative_dataflow_sbitmap (in, out, gen, kill, blocks,\n \t    hybrid_search_sbitmap (bb, in, out, gen, kill, dir,\n \t\t\t\t   conf_op, transfun, visited, pending, data);\n \t}\n+\n       if (sbitmap_first_set_bit (pending) != -1)\n \t{\n \t  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n@@ -3920,13 +3923,15 @@ iterative_dataflow_sbitmap (in, out, gen, kill, blocks,\n \t  break;\n \t}\n     }\n+\n   sbitmap_free (pending);\n   sbitmap_free (visited);\n   fibheap_delete (worklist);\n }\n \n+\n /* Exactly the same as iterative_dataflow_sbitmap, except it works on\n-   bitmaps instead */\n+   bitmaps instead.  */\n void\n iterative_dataflow_bitmap (in, out, gen, kill, blocks,\n \t\t\t   dir, conf_op, transfun, order, data)\n@@ -3942,20 +3947,23 @@ iterative_dataflow_bitmap (in, out, gen, kill, blocks,\n   fibheap_t worklist;\n   basic_block bb;\n   sbitmap visited, pending;\n+\n   pending = sbitmap_alloc (last_basic_block);\n   visited = sbitmap_alloc (last_basic_block);\n   sbitmap_zero (pending);\n   sbitmap_zero (visited);\n   worklist = fibheap_new ();\n+\n   EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n   {\n     fibheap_insert (worklist, order[i], (void *) (size_t) i);\n     SET_BIT (pending, i);\n-    if (dir == FORWARD)\n+    if (dir == DF_FORWARD)\n       bitmap_copy (out[i], gen[i]);\n     else\n       bitmap_copy (in[i], gen[i]);\n   });\n+\n   while (sbitmap_first_set_bit (pending) != -1)\n     {\n       while (!fibheap_empty (worklist))\n@@ -3966,6 +3974,7 @@ iterative_dataflow_bitmap (in, out, gen, kill, blocks,\n \t    hybrid_search_bitmap (bb, in, out, gen, kill, dir,\n \t\t\t\t  conf_op, transfun, visited, pending, data);\n \t}\n+\n       if (sbitmap_first_set_bit (pending) != -1)\n \t{\n \t  EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,"}, {"sha": "d20d298cf7a5884f6b65075dbac87e8c3a78e9f6", "filename": "gcc/df.h", "status": "modified", "additions": 47, "deletions": 42, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7890e8f32010931d748d5b60b989ee84e608dfa0/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7890e8f32010931d748d5b60b989ee84e608dfa0/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=7890e8f32010931d748d5b60b989ee84e608dfa0", "patch": "@@ -1,6 +1,6 @@\n /* Form lists of pseudo register references for autoinc optimization\n    for GNU compiler.  This is part of flow optimization.  \n-   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n    Contributed by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz)\n \n This file is part of GCC.\n@@ -29,18 +29,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define DF_RD_CHAIN\t64\t/* Reg-def chain.  */\n #define DF_RU_CHAIN    128\t/* Reg-use chain.  */\n #define DF_ALL\t       255\n-#define DF_HARD_REGS  1024\n+#define DF_HARD_REGS  1024\t/* Mark hard registers.  */\n #define DF_EQUIV_NOTES 2048\t/* Mark uses present in EQUIV/EQUAL notes.  */\n \n enum df_ref_type {DF_REF_REG_DEF, DF_REF_REG_USE, DF_REF_REG_MEM_LOAD,\n \t\t  DF_REF_REG_MEM_STORE};\n \n #define DF_REF_TYPE_NAMES {\"def\", \"use\", \"mem load\", \"mem store\"}\n \n-/* ???> Perhaps all these data structures should be made private\n-   to enforce the interface.  */\n-\n-\n /* Link on a def-use or use-def chain.  */\n struct df_link\n {\n@@ -50,27 +46,33 @@ struct df_link\n \n enum df_ref_flags\n   {\n+    /* Read-modify-write refs generate both a use and a def and\n+       these are marked with this flag to show that they are not\n+       independent.  */\n     DF_REF_READ_WRITE = 1,\n-\n-    /* This flag is set on register references itself representing a or\n-       being inside a subreg on machines which have CLASS_CANNOT_CHANGE_MODE\n-       and where the mode change of that subreg expression is invalid for\n-       this class.  Note, that this flag can also be set on df_refs\n-       representing the REG itself (i.e. one might not see the subreg\n-       anymore).  Also note, that this flag is set also for hardreg refs.\n-       I.e. you must check yourself if it's a pseudo.  */\n+    \n+    /* This flag is set on register references inside a subreg on\n+       machines which have CLASS_CANNOT_CHANGE_MODE and where the mode\n+       change of that subreg expression is invalid for this class.\n+       Note, that this flag can also be set on df_refs representing\n+       the REG itself (i.e., one might not see the subreg anyore).\n+       Also note, that this flag is set also for hardreg refs, i.e.,\n+       you must check yourself if it's a pseudo.  */\n     DF_REF_MODE_CHANGE = 2\n   };\n \n-/* Define a register reference structure.  */\n+\n+/* Define a register reference structure.  One of these is allocated\n+   for every register reference (use or def).  Note some register\n+   references (e.g., post_inc, subreg) generate both a def and a use.  */\n struct ref\n {\n   rtx reg;\t\t\t/* The register referenced.  */\n   rtx insn;\t\t\t/* Insn containing ref.  */\n-  rtx *loc;\t\t\t/* Loc is the location of the reg.  */\n+  rtx *loc;\t\t\t/* The location of the reg.  */\n   struct df_link *chain;\t/* Head of def-use or use-def chain.  */\n-  enum df_ref_type type;\t/* Type of ref.  */\n   unsigned int id;\t\t/* Ref index.  */\n+  enum df_ref_type type;\t/* Type of ref.  */\n   enum df_ref_flags flags;\t/* Various flags.  */\n };\n \n@@ -80,12 +82,9 @@ struct insn_info\n {\n   struct df_link *defs;\t\t/* Head of insn-def chain.  */\n   struct df_link *uses;\t\t/* Head of insn-use chain.  */\n-  /* ???? The following luid field should be considered private so that\n+  /* ???? The following luid field should be considerd private so that\n      we can change it on the fly to accommodate new insns?  */\n   int luid;\t\t\t/* Logical UID.  */\n-#if 0\n-  rtx insn;\t\t\t/* Backpointer to the insn.  */\n-#endif\n };\n \n \n@@ -151,12 +150,12 @@ struct df\n   /* The sbitmap vector of dominators or NULL if not computed. \n      Ideally, this should be a pointer to a CFG object.  */\n   sbitmap *dom;\n-  int * dfs_order; /* DFS order -> block number */\n-  int * rc_order; /* reverse completion order -> block number */\n-  int * rts_order; /* reverse top sort order -> block number */\n-  int * inverse_rc_map; /* block number -> reverse completion order */\n-  int * inverse_dfs_map; /* block number -> DFS order */\n-  int * inverse_rts_map; /* block number -> reverse top-sort order */\n+  int *dfs_order;\t\t/* DFS order -> block number.  */\n+  int *rc_order;\t\t/* Reverse completion order -> block number.  */\n+  int *rts_order;\t\t/* Reverse top sort order -> block number.  */\n+  int *inverse_rc_map;\t\t/* Block number -> reverse completion order.  */\n+  int *inverse_dfs_map;\t\t/* Block number -> DFS order.  */\n+  int *inverse_rts_map;\t\t/* Block number -> reverse top-sort order.  */\n };\n \n \n@@ -171,18 +170,14 @@ struct df_map\n \n \n /* Macros to access the elements within the ref structure.  */\n+\n #define DF_REF_REAL_REG(REF) (GET_CODE ((REF)->reg) == SUBREG \\\n \t\t\t\t? SUBREG_REG ((REF)->reg) : ((REF)->reg))\n #define DF_REF_REGNO(REF) REGNO (DF_REF_REAL_REG (REF))\n #define DF_REF_REAL_LOC(REF) (GET_CODE ((REF)->reg) == SUBREG \\\n \t\t\t        ? &SUBREG_REG ((REF)->reg) : ((REF)->loc))\n-#ifdef OLD_DF_INTERFACE\n-#define DF_REF_REG(REF) DF_REF_REAL_REG(REF)\n-#define DF_REF_LOC(REF) DF_REF_REAL_LOC(REF)\n-#else\n #define DF_REF_REG(REF) ((REF)->reg)\n #define DF_REF_LOC(REF) ((REF)->loc)\n-#endif\n #define DF_REF_BB(REF) (BLOCK_FOR_INSN ((REF)->insn))\n #define DF_REF_BBNO(REF) (BLOCK_FOR_INSN ((REF)->insn)->index)\n #define DF_REF_INSN(REF) ((REF)->insn)\n@@ -199,7 +194,7 @@ struct df_map\n #define DF_REF_REG_MEM_STORE_P(REF) (DF_REF_TYPE (REF) == DF_REF_REG_MEM_STORE)\n #define DF_REF_REG_MEM_LOAD_P(REF) (DF_REF_TYPE (REF) == DF_REF_REG_MEM_LOAD)\n #define DF_REF_REG_MEM_P(REF) (DF_REF_REG_MEM_STORE_P (REF) \\\n-                            || DF_REF_REG_MEM_LOAD_P (REF))\n+                               || DF_REF_REG_MEM_LOAD_P (REF))\n \n \n /* Macros to access the elements within the reg_info structure table.  */\n@@ -234,6 +229,7 @@ extern void df_finish PARAMS ((struct df *));\n \n extern void df_dump PARAMS ((struct df *, int, FILE *));\n \n+\n /* Functions to modify insns.  */\n \n extern void df_insn_modify PARAMS ((struct df *, basic_block, rtx));\n@@ -247,7 +243,7 @@ extern rtx df_jump_pattern_emit_after PARAMS ((struct df *, rtx,\n \t\t\t\t\t       basic_block, rtx));\n \n extern rtx df_pattern_emit_after PARAMS ((struct df *, rtx, \n-\t\t\t\t\t   basic_block, rtx));\n+\t\t\t\t\t  basic_block, rtx));\n \n extern rtx df_insn_move_before PARAMS ((struct df *, basic_block, rtx,\n \t\t\t\t\tbasic_block, rtx));\n@@ -311,32 +307,41 @@ extern void debug_df_useno PARAMS ((unsigned int));\n extern void debug_df_ref PARAMS ((struct ref *));\n \n extern void debug_df_chain PARAMS ((struct df_link *));\n+\n extern void df_insn_debug PARAMS ((struct df *, rtx, FILE *));\n+\n extern void df_insn_debug_regno PARAMS ((struct df *, rtx, FILE *));\n-/* Meet over any path (UNION) or meet over all paths (INTERSECTION) */\n+\n+\n+/* Meet over any path (UNION) or meet over all paths (INTERSECTION).  */\n enum df_confluence_op\n   {\n-    UNION,\n-    INTERSECTION\n+    DF_UNION,\n+    DF_INTERSECTION\n   };\n-/* Dataflow direction */\n+\n+\n+/* Dataflow direction.  */\n enum df_flow_dir\n   {\n-    FORWARD,\n-    BACKWARD\n+    DF_FORWARD,\n+    DF_BACKWARD\n   };\n \n+\n typedef void (*transfer_function_sbitmap) PARAMS ((int, int *, sbitmap, sbitmap, \n-\t\t\t\t\t   sbitmap, sbitmap, void *));\n+\t\t\t\t\t\t   sbitmap, sbitmap, void *));\n+\n typedef void (*transfer_function_bitmap) PARAMS ((int, int *, bitmap, bitmap,\n-\t\t\t\t\t  bitmap, bitmap, void *));\n+\t\t\t\t\t\t  bitmap, bitmap, void *));\n \n extern void iterative_dataflow_sbitmap PARAMS ((sbitmap *, sbitmap *, \n \t\t\t\t\t\tsbitmap *, sbitmap *, \n \t\t\t\t\t\tbitmap, enum df_flow_dir, \n \t\t\t\t\t\tenum df_confluence_op, \n \t\t\t\t\t\ttransfer_function_sbitmap, \n \t\t\t\t\t\tint *, void *));\n+\n extern void iterative_dataflow_bitmap PARAMS ((bitmap *, bitmap *, bitmap *, \n \t\t\t\t\t       bitmap *, bitmap, \n \t\t\t\t\t       enum df_flow_dir, "}]}