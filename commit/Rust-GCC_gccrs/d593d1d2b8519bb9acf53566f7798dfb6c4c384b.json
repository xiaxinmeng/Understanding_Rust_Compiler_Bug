{"sha": "d593d1d2b8519bb9acf53566f7798dfb6c4c384b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU5M2QxZDJiODUxOWJiOWFjZjUzNTY2Zjc3OThkZmI2YzRjMzg0Yg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "1999-12-06T14:02:16Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "1999-12-06T14:02:16Z"}, "message": "frame.c (start_fde_sort): Only allocate erratic array, if linear one was allocated.\n\n\t* frame.c (start_fde_sort): Only allocate erratic array, if\n\tlinear one was allocated. Return allocated flag.\n\t(fde_insert): Only insert, if there's a valid array.\n\t(fde_end_sort): Split, sort and merge if linear and erratic\n\tarrays exist, else just sort linear one.\n\t(search_fdes): New function. Linear search through original fde\n\tstructure.\n\t(frame_init): Permit multiple initializations. Cope with\n\tmemory shortages.\n\t(find_fde): Fallback on linear search, if failed to sort array.\n\t(__deregister_frame_info): Only free sorted array, if we\n\tallocated it.\n\nFrom-SVN: r30799", "tree": {"sha": "6963636df197396b13f5306d8a6e88970b7319a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6963636df197396b13f5306d8a6e88970b7319a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d593d1d2b8519bb9acf53566f7798dfb6c4c384b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d593d1d2b8519bb9acf53566f7798dfb6c4c384b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d593d1d2b8519bb9acf53566f7798dfb6c4c384b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d593d1d2b8519bb9acf53566f7798dfb6c4c384b/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8ab56d5de5ca48086456c709056b651da09f352b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ab56d5de5ca48086456c709056b651da09f352b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ab56d5de5ca48086456c709056b651da09f352b"}], "stats": {"total": 143, "additions": 113, "deletions": 30}, "files": [{"sha": "48b84868dedd2752f71cc7ef7cb9b53196b13973", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d593d1d2b8519bb9acf53566f7798dfb6c4c384b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d593d1d2b8519bb9acf53566f7798dfb6c4c384b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d593d1d2b8519bb9acf53566f7798dfb6c4c384b", "patch": "@@ -1,3 +1,18 @@\n+1999-12-06  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* frame.c (start_fde_sort): Only allocate erratic array, if\n+\tlinear one was allocated. Return allocated flag.\n+\t(fde_insert): Only insert, if there's a valid array.\n+\t(fde_end_sort): Split, sort and merge if linear and erratic\n+\tarrays exist, else just sort linear one.\n+\t(search_fdes): New function. Linear search through original fde\n+\tstructure.\n+\t(frame_init): Permit multiple initializations. Cope with\n+\tmemory shortages.\n+\t(find_fde): Fallback on linear search, if failed to sort array.\n+\t(__deregister_frame_info): Only free sorted array, if we\n+\tallocated it.\n+\n 1999-12-06  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/sparc/sparc.h (MUST_PASS_IN_STACK): New macro."}, {"sha": "e6f71bedec22af2a2ef5fdb373070adb068d6f99", "filename": "gcc/frame.c", "status": "modified", "additions": 98, "deletions": 30, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d593d1d2b8519bb9acf53566f7798dfb6c4c384b/gcc%2Fframe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d593d1d2b8519bb9acf53566f7798dfb6c4c384b/gcc%2Fframe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fframe.c?ref=d593d1d2b8519bb9acf53566f7798dfb6c4c384b", "patch": "@@ -283,19 +283,23 @@ typedef struct fde_accumulator\n   fde_vector erratic;\n } fde_accumulator;\n \n-static inline void\n+static inline int\n start_fde_sort (fde_accumulator *accu, size_t count)\n {\n   accu->linear.array = (fde **) malloc (sizeof (fde *) * count);\n-  accu->erratic.array = (fde **) malloc (sizeof (fde *) * count);\n+  accu->erratic.array = accu->linear.array ?\n+      (fde **) malloc (sizeof (fde *) * count) : NULL;\n   accu->linear.count = 0;\n   accu->erratic.count = 0;\n+  \n+  return accu->linear.array != NULL;\n }\n \n static inline void\n fde_insert (fde_accumulator *accu, fde *this_fde)\n {\n-  accu->linear.array[accu->linear.count++] = this_fde;\n+  if (accu->linear.array)\n+    accu->linear.array[accu->linear.count++] = this_fde;\n }\n \n /* Split LINEAR into a linear sequence with low values and an erratic\n@@ -443,14 +447,25 @@ fde_merge (fde_vector *v1, const fde_vector *v2)\n static fde **\n end_fde_sort (fde_accumulator *accu, size_t count)\n {\n-  if (accu->linear.count != count)\n-    abort ();\n-  fde_split (&accu->linear, &accu->erratic);\n-  if (accu->linear.count + accu->erratic.count != count)\n+  if (accu->linear.array && accu->linear.count != count)\n     abort ();\n-  frame_heapsort (&accu->erratic);\n-  fde_merge (&accu->linear, &accu->erratic);\n-  free (accu->erratic.array);\n+  \n+  if (accu->erratic.array)\n+    {\n+      fde_split (&accu->linear, &accu->erratic);\n+      if (accu->linear.count + accu->erratic.count != count)\n+\tabort ();\n+      frame_heapsort (&accu->erratic);\n+      fde_merge (&accu->linear, &accu->erratic);\n+      if (accu->erratic.array)\n+        free (accu->erratic.array);\n+    }\n+  else\n+    {\n+      /* We've not managed to malloc an erratic array, so heap sort in the\n+         linear one.  */\n+      frame_heapsort (&accu->linear);\n+    }\n   return accu->linear.array;\n }\n \n@@ -495,29 +510,50 @@ add_fdes (fde *this_fde, fde_accumulator *accu, void **beg_ptr, void **end_ptr)\n   *end_ptr = pc_end;\n }\n \n+/* search this fde table for the one containing the pc */\n+static fde *\n+search_fdes (fde *this_fde, void *pc)\n+{\n+  for (; this_fde->length != 0; this_fde = next_fde (this_fde))\n+    {\n+      /* Skip CIEs and linked once FDE entries.  */\n+      if (this_fde->CIE_delta == 0 || this_fde->pc_begin == 0)\n+\tcontinue;\n+\n+      if ((uaddr)((char *)pc - (char *)this_fde->pc_begin) < this_fde->pc_range)\n+\treturn this_fde;\n+    }\n+  return NULL;\n+}\n+\n /* Set up a sorted array of pointers to FDEs for a loaded object.  We\n    count up the entries before allocating the array because it's likely to\n-   be faster.  */\n+   be faster.  We can be called multiple times, should we have failed to\n+   allocate a sorted fde array on a previous occasion.  */\n \n static void\n frame_init (struct object* ob)\n {\n   size_t count;\n   fde_accumulator accu;\n   void *pc_begin, *pc_end;\n+  fde **array;\n \n-  if (ob->fde_array)\n+  if (ob->pc_begin)\n+    count = ob->count;\n+  else if (ob->fde_array)\n     {\n       fde **p = ob->fde_array;\n       for (count = 0; *p; ++p)\n \tcount += count_fdes (*p);\n     }\n   else\n     count = count_fdes (ob->fde_begin);\n-\n   ob->count = count;\n \n-  start_fde_sort (&accu, count);\n+  if (!start_fde_sort (&accu, count) && ob->pc_begin)\n+    return;\n+\n   pc_begin = (void*)(uaddr)-1;\n   pc_end = 0;\n \n@@ -530,7 +566,9 @@ frame_init (struct object* ob)\n   else\n     add_fdes (ob->fde_begin, &accu, &pc_begin, &pc_end);\n \n-  ob->fde_array = end_fde_sort (&accu, count);\n+  array = end_fde_sort (&accu, count);\n+  if (array)\n+    ob->fde_array = array;\n   ob->pc_begin = pc_begin;\n   ob->pc_end = pc_end;\n }\n@@ -546,6 +584,7 @@ find_fde (void *pc)\n   init_object_mutex_once ();\n   __gthread_mutex_lock (&object_mutex);\n \n+  /* Linear search through the objects, to find the one containing the pc. */\n   for (ob = objects; ob; ob = ob->next)\n     {\n       if (ob->pc_begin == 0)\n@@ -554,25 +593,54 @@ find_fde (void *pc)\n \tbreak;\n     }\n \n-  __gthread_mutex_unlock (&object_mutex);\n-\n   if (ob == 0)\n-    return 0;\n-\n-  /* Standard binary search algorithm.  */\n-  for (lo = 0, hi = ob->count; lo < hi; )\n     {\n-      size_t i = (lo + hi) / 2;\n-      fde *f = ob->fde_array[i];\n+      __gthread_mutex_unlock (&object_mutex);\n+      return 0;\n+    }\n \n-      if (pc < f->pc_begin)\n-\thi = i;\n-      else if (pc >= f->pc_begin + f->pc_range)\n-\tlo = i + 1;\n+  if (!ob->fde_array || (void *)ob->fde_array == (void *)ob->fde_begin)\n+    frame_init (ob);\n+\n+  if (ob->fde_array && (void *)ob->fde_array != (void *)ob->fde_begin)\n+    {\n+      __gthread_mutex_unlock (&object_mutex);\n+      \n+      /* Standard binary search algorithm.  */\n+      for (lo = 0, hi = ob->count; lo < hi; )\n+\t{\n+\t  size_t i = (lo + hi) / 2;\n+\t  fde *f = ob->fde_array[i];\n+\n+\t  if (pc < f->pc_begin)\n+\t    hi = i;\n+\t  else if (pc >= f->pc_begin + f->pc_range)\n+\t    lo = i + 1;\n+\t  else\n+\t    return f;\n+\t}\n+    }\n+  else\n+    {\n+      /* Long slow labourious linear search, cos we've no memory. */\n+      fde *f;\n+      \n+      if (ob->fde_array)\n+\t{\n+\t  fde **p = ob->fde_array;\n+\t  \n+\t  for (; *p; ++p)\n+\t    {\n+\t      f = search_fdes (*p, pc);\n+\t      if (f)\n+\t\tbreak;\n+\t    }\n+\t}\n       else\n-\treturn f;\n+\tf = search_fdes (ob->fde_begin, pc);\n+      __gthread_mutex_unlock (&object_mutex);\n+      return f;\n     }\n-\n   return 0;\n }\n \f\n@@ -825,7 +893,7 @@ __deregister_frame_info (void *begin)\n \t  *p = (*p)->next;\n \n \t  /* If we've run init_frame for this object, free the FDE array.  */\n-\t  if (ob->pc_begin)\n+\t  if (ob->fde_array && ob->fde_array != begin)\n \t    free (ob->fde_array);\n \n \t  __gthread_mutex_unlock (&object_mutex);"}]}