{"sha": "225b8835c4d7b07c3701aae5c49d6ac01c02773e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI1Yjg4MzVjNGQ3YjA3YzM3MDFhYWU1YzQ5ZDZhYzAxYzAyNzczZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1995-03-27T19:39:04Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1995-03-27T19:39:04Z"}, "message": "Add support for mult instruction in 64 bit mode\n\nFrom-SVN: r9234", "tree": {"sha": "b9af22a53414a7bf4c8b326db336e51144a5bf0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9af22a53414a7bf4c8b326db336e51144a5bf0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/225b8835c4d7b07c3701aae5c49d6ac01c02773e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/225b8835c4d7b07c3701aae5c49d6ac01c02773e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/225b8835c4d7b07c3701aae5c49d6ac01c02773e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/225b8835c4d7b07c3701aae5c49d6ac01c02773e/comments", "author": null, "committer": null, "parents": [{"sha": "b6da85666d4180adde474902aa289b512ccc8c2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6da85666d4180adde474902aa289b512ccc8c2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6da85666d4180adde474902aa289b512ccc8c2e"}], "stats": {"total": 528, "additions": 429, "deletions": 99}, "files": [{"sha": "d492ced44028efcd4a7ab749f1574369e11d7d31", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 76, "deletions": 14, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225b8835c4d7b07c3701aae5c49d6ac01c02773e/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225b8835c4d7b07c3701aae5c49d6ac01c02773e/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=225b8835c4d7b07c3701aae5c49d6ac01c02773e", "patch": "@@ -246,7 +246,7 @@ char mips_reg_names[][8] =\n  \"$f8\",  \"$f9\",  \"$f10\", \"$f11\", \"$f12\", \"$f13\", \"$f14\", \"$f15\",\n  \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\n  \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"$f31\",\n- \"hi\",   \"lo\",   \"$fcr31\"\n+ \"hi\",   \"lo\",   \"accum\",\"$fcr31\"\n };\n \n /* Mips software names for the registers, used to overwrite the\n@@ -262,7 +262,7 @@ char mips_sw_reg_names[][8] =\n   \"$f8\",  \"$f9\",  \"$f10\", \"$f11\", \"$f12\", \"$f13\", \"$f14\", \"$f15\",\n   \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\n   \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"$f31\",\n-  \"hi\",   \"lo\",   \"$fcr31\"\n+  \"hi\",   \"lo\",   \"accum\",\"$fcr31\"\n };\n \n /* Map hard register number to register class */\n@@ -284,7 +284,7 @@ enum reg_class mips_regno_to_class[] =\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n-  HI_REG,\tLO_REG,\t\tST_REGS\n+  HI_REG,\tLO_REG,\t\tHILO_REG,\tST_REGS\n };\n \n /* Map register constraint character to register class.  */\n@@ -927,7 +927,10 @@ mips_move_1word (operands, insn, unsignedp)\n \t      else if (MD_REG_P (regno1))\n \t\t{\n \t\t  delay = DELAY_HILO;\n-\t\t  ret = \"mf%1\\t%0\";\n+\t\t  if (regno1 != HILO_REGNUM)\n+\t\t    ret = \"mf%1\\t%0\";\n+\t\t  else\n+\t\t    ret = \"mflo\\t%0\";\n \t\t}\n \n \t      else\n@@ -958,7 +961,8 @@ mips_move_1word (operands, insn, unsignedp)\n \t      if (GP_REG_P (regno1))\n \t\t{\n \t\t  delay = DELAY_HILO;\n-\t\t  ret = \"mt%0\\t%1\";\n+\t\t  if (regno0 != HILO_REGNUM)\n+\t\t    ret = \"mt%0\\t%1\";\n \t\t}\n \t    }\n \n@@ -1040,6 +1044,12 @@ mips_move_1word (operands, insn, unsignedp)\n \t\t  delay = DELAY_LOAD;\n \t\t  ret = \"mtc1\\t%z1,%0\";\n \t\t}\n+\n+\t      else if (MD_REG_P (regno0))\n+\t\t{\n+\t\t  delay = DELAY_HILO;\n+\t\t  ret = \"mt%0\\t%.\";\n+\t\t}\n \t    }\n \n \t  else if (GP_REG_P (regno0))\n@@ -1301,7 +1311,12 @@ mips_move_2words (operands, insn)\n \t    {\n \t      delay = DELAY_HILO;\n \t      if (TARGET_64BIT)\n-\t\tret = \"mt%0\\t%1\";\n+\t\t{\n+\t\t  if (regno0 != HILO_REGNUM)\n+\t\t    ret = \"mt%0\\t%1\";\n+\t\t  else if (regno1 == 0)\n+\t\t    ret = \"mtlo\\t%.\\n\\tmthi\\t%.\";\n+\t\t}\n \t      else\n \t\tret = \"mthi\\t%M1\\n\\tmtlo\\t%L1\";\n \t    }\n@@ -1310,7 +1325,10 @@ mips_move_2words (operands, insn)\n \t    {\n \t      delay = DELAY_HILO;\n \t      if (TARGET_64BIT)\n-\t\tret = \"mf%1\\t%0\";\n+\t\t{\n+\t\t  if (regno1 != HILO_REGNUM)\n+\t\t    ret = \"mf%1\\t%0\";\n+\t\t}\n \t      else\n \t\tret = \"mfhi\\t%M0\\n\\tmflo\\t%L0\";\n \t    }\n@@ -1398,6 +1416,14 @@ mips_move_2words (operands, insn)\n \t\t\t\t   ? \"li.d\\t%0,%1\"\n \t\t\t\t   : \"mtc1\\t%.,%0\\n\\tmtc1\\t%.,%D0\");\n \t    }\n+\t  else if (MD_REG_P (regno0))\n+\t    {\n+\t      delay = DELAY_HILO;\n+\t      if (regno0 != HILO_REGNUM)\n+\t\tret = \"mt%0\\t%.\\n\";\n+\t      else\n+\t\tret = \"mtlo\\t%.\\n\\tmthi\\t%.\";\n+\t    }\n \t}\n \t\n       else if (code1 == CONST_INT && GET_MODE (op0) == DImode && GP_REG_P (regno0))\n@@ -3352,7 +3378,9 @@ override_options ()\n   mips_char_to_class['f'] = ((TARGET_HARD_FLOAT) ? FP_REGS : NO_REGS);\n   mips_char_to_class['h'] = HI_REG;\n   mips_char_to_class['l'] = LO_REG;\n+  mips_char_to_class['a'] = HILO_REG;\n   mips_char_to_class['x'] = MD_REGS;\n+  mips_char_to_class['b'] = ALL_REGS;\n   mips_char_to_class['y'] = GR_REGS;\n   mips_char_to_class['z'] = ST_REGS;\n \n@@ -5533,24 +5561,58 @@ mips_function_value (valtype, func)\n }\n #endif\n \n-/* Moving the HI or LO register somewhere requires a general register.  */\n+/* This function returns the register class required for a secondary\n+   register when copying between one of the registers in CLASS, and X,\n+   using MODE.  If IN_P is nonzero, the copy is going from X to the\n+   register, otherwise the register is the source.  A return value of\n+   NO_REGS means that no secondary register is required.  */\n \n enum reg_class\n-mips_secondary_reload_class (class, mode, x)\n+mips_secondary_reload_class (class, mode, x, in_p)\n      enum reg_class class;\n      enum machine_mode mode;\n      rtx x;\n+     int in_p;\n {\n-  if (class != HI_REG && class != LO_REG && class != MD_REGS)\n-    return NO_REGS;\n+  int regno = -1;\n \n   if (GET_CODE (x) == REG || GET_CODE (x) == SUBREG)\n+    regno = true_regnum (x);\n+\n+  /* We always require a general register when copying anything to\n+     HILO_REGNUM, except when copying an SImode value from HILO_REGNUM\n+     to a general register, or when copying from register 0.  */\n+  if (class == HILO_REG && regno != GP_REG_FIRST + 0)\n+    {\n+      if (! in_p\n+\t  && GP_REG_P (regno)\n+\t  && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (SImode))\n+\treturn NO_REGS;\n+      return GR_REGS;\n+    }\n+  if (regno == HILO_REGNUM)\n     {\n-      int regno = true_regnum (x);\n+      if (in_p\n+\t  && class == GR_REGS\n+\t  && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (SImode))\n+\treturn NO_REGS;\n+      return GR_REGS;\n+    }\n \n-      if (regno >= GP_REG_FIRST && regno <= GP_REG_LAST)\n+  /* Copying from HI or LO to anywhere other than a general register\n+     requires a general register.  */\n+  if (class == HI_REG || class == LO_REG || class == MD_REGS)\n+    {\n+      if (GP_REG_P (regno))\n+\treturn NO_REGS;\n+      return GR_REGS;\n+    }\n+  if (MD_REG_P (regno))\n+    {\n+      if (class == GR_REGS)\n \treturn NO_REGS;\n+      return GR_REGS;\n     }\n \n-  return GR_REGS;\n+  return NO_REGS;\n }"}, {"sha": "0408ed09a58893e6fad115678a21106cb04bc625", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225b8835c4d7b07c3701aae5c49d6ac01c02773e/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225b8835c4d7b07c3701aae5c49d6ac01c02773e/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=225b8835c4d7b07c3701aae5c49d6ac01c02773e", "patch": "@@ -1138,10 +1138,13 @@ do {\t\t\t\t\t\t\t\\\n    All registers that the compiler knows about must be given numbers,\n    even those that are not normally considered general registers.\n \n-   On the Mips, we have 32 integer registers, 32 floating point registers\n-   and the special registers hi, lo, and fp status.  */\n+   On the Mips, we have 32 integer registers, 32 floating point\n+   registers and the special registers hi, lo, hilo, and fp status.\n+   The hilo register is only used in 64 bit mode.  It represents a 64\n+   bit value stored as two 32 bit values in the hi and lo registers;\n+   this is the result of the mult instruction.  */\n \n-#define FIRST_PSEUDO_REGISTER 67\n+#define FIRST_PSEUDO_REGISTER 68\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n@@ -1154,7 +1157,7 @@ do {\t\t\t\t\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n-  0, 0, 1\t\t\t\t\t\t\t\t\\\n+  0, 0, 0, 1\t\t\t\t\t\t\t\t\\\n }\n \n \n@@ -1171,7 +1174,7 @@ do {\t\t\t\t\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1,\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n-  1, 1, 1\t\t\t\t\t\t\t\t\\\n+  1, 1, 1, 1\t\t\t\t\t\t\t\t\\\n }\n \n \n@@ -1190,16 +1193,17 @@ do {\t\t\t\t\t\t\t\\\n #define FP_DBX_FIRST ((write_symbols == DBX_DEBUG) ? 38 : 32)\n \n #define MD_REG_FIRST 64\n-#define MD_REG_LAST  65\n+#define MD_REG_LAST  66\n #define MD_REG_NUM   (MD_REG_LAST - MD_REG_FIRST + 1)\n \n-#define ST_REG_FIRST 66\n-#define ST_REG_LAST  66\n+#define ST_REG_FIRST 67\n+#define ST_REG_LAST  67\n #define ST_REG_NUM   (ST_REG_LAST - ST_REG_FIRST + 1)\n \n #define AT_REGNUM\t(GP_REG_FIRST + 1)\n #define HI_REGNUM\t(MD_REG_FIRST + 0)\n #define LO_REGNUM\t(MD_REG_FIRST + 1)\n+#define HILO_REGNUM\t(MD_REG_FIRST + 2)\n #define FPSW_REGNUM\tST_REG_FIRST\n \n #define GP_REG_P(REGNO) ((unsigned) ((REGNO) - GP_REG_FIRST) < GP_REG_NUM)\n@@ -1342,6 +1346,7 @@ enum reg_class\n   FP_REGS,\t\t\t/* floating point registers */\n   HI_REG,\t\t\t/* hi register */\n   LO_REG,\t\t\t/* lo register */\n+  HILO_REG,\t\t\t/* hilo register pair for 64 bit mode mult */\n   MD_REGS,\t\t\t/* multiply/divide registers (hi/lo) */\n   ST_REGS,\t\t\t/* status registers (fp status) */\n   ALL_REGS,\t\t\t/* all registers */\n@@ -1363,6 +1368,7 @@ enum reg_class\n   \"FP_REGS\",\t\t\t\t\t\t\t\t\\\n   \"HI_REG\",\t\t\t\t\t\t\t\t\\\n   \"LO_REG\",\t\t\t\t\t\t\t\t\\\n+  \"HILO_REG\",\t\t\t\t\t\t\t\t\\\n   \"MD_REGS\",\t\t\t\t\t\t\t\t\\\n   \"ST_REGS\",\t\t\t\t\t\t\t\t\\\n   \"ALL_REGS\"\t\t\t\t\t\t\t\t\\\n@@ -1386,9 +1392,10 @@ enum reg_class\n   { 0x00000000, 0xffffffff, 0x00000000 },\t/* floating registers*/\t\\\n   { 0x00000000, 0x00000000, 0x00000001 },\t/* hi register */\t\\\n   { 0x00000000, 0x00000000, 0x00000002 },\t/* lo register */\t\\\n+  { 0x00000000, 0x00000000, 0x00000004 },\t/* hilo register */\t\\\n   { 0x00000000, 0x00000000, 0x00000003 },\t/* mul/div registers */\t\\\n-  { 0x00000000, 0x00000000, 0x00000004 },\t/* status registers */\t\\\n-  { 0xffffffff, 0xffffffff, 0x00000007 }\t/* all registers */\t\\\n+  { 0x00000000, 0x00000000, 0x00000008 },\t/* status registers */\t\\\n+  { 0xffffffff, 0xffffffff, 0x0000000f }\t/* all registers */\t\\\n }\n \n \n@@ -1428,7 +1435,9 @@ extern enum reg_class mips_regno_to_class[];\n    'h'\tHi register\n    'l'\tLo register\n    'x'\tMultiply/divide registers\n-   'z'\tFP Status register */\n+   'a'\tHILO_REG\n+   'z'\tFP Status register\n+   'b'\tAll registers */\n \n extern enum reg_class mips_char_to_class[];\n \n@@ -1548,8 +1557,10 @@ extern enum reg_class mips_char_to_class[];\n /* The HI and LO registers can only be reloaded via the general\n    registers.  */\n \n-#define SECONDARY_RELOAD_CLASS(CLASS, MODE, X)\t\t\t\t\\\n-  mips_secondary_reload_class (CLASS, MODE, X)\n+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\t\\\n+  mips_secondary_reload_class (CLASS, MODE, X, 1)\n+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\t\\\n+  mips_secondary_reload_class (CLASS, MODE, X, 0)\n \n /* Not declared above, with the other functions, because enum\n    reg_class is not declared yet.  */\n@@ -2870,9 +2881,11 @@ while (0)\n    : (FROM) == FP_REGS && (TO) == FP_REGS ? 2\t\t\t\t\\\n    : (FROM) == GR_REGS && (TO) == FP_REGS ? 4\t\t\t\t\\\n    : (FROM) == FP_REGS && (TO) == GR_REGS ? 4\t\t\t\t\\\n-   : (((FROM) == HI_REG || (FROM) == LO_REG || (FROM) == MD_REGS)\t\\\n+   : (((FROM) == HI_REG || (FROM) == LO_REG\t\t\t\t\\\n+       || (FROM) == MD_REGS || (FROM) == HILO_REG)\t\t\t\\\n       && (TO) == GR_REGS) ? 6\t\t\t\t\t\t\\\n-   : (((TO) == HI_REG || (TO) == LO_REG || (TO) == MD_REGS)\t\t\\\n+   : (((TO) == HI_REG || (TO) == LO_REG\t\t\t\t\t\\\n+       || (TO) == MD_REGS || (FROM) == HILO_REG)\t\t\t\\\n       && (FROM) == GR_REGS) ? 6\t\t\t\t\t\t\\\n    : 12)\n \n@@ -3085,6 +3098,7 @@ while (0)\n   &mips_reg_names[64][0],\t\t\t\t\t\t\\\n   &mips_reg_names[65][0],\t\t\t\t\t\t\\\n   &mips_reg_names[66][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[67][0],\t\t\t\t\t\t\\\n }\n \n /* print-rtl.c can't use REGISTER_NAMES, since it depends on mips.c.\n@@ -3099,7 +3113,7 @@ while (0)\n   \"$f8\",  \"$f9\",  \"$f10\", \"$f11\", \"$f12\", \"$f13\", \"$f14\", \"$f15\",\t\\\n   \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\t\\\n   \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"$f31\",\t\\\n-  \"hi\",   \"lo\",   \"$fcr31\"\t\t\t\t\t\t\\\n+  \"hi\",   \"lo\",   \"accum\",\"$fcr31\"\t\t\t\t\t\\\n }\n \n /* If defined, a C initializer for an array of structures"}, {"sha": "da557924c858c70cefe72abc9329b76e7618f2b9", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 323, "deletions": 69, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225b8835c4d7b07c3701aae5c49d6ac01c02773e/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225b8835c4d7b07c3701aae5c49d6ac01c02773e/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=225b8835c4d7b07c3701aae5c49d6ac01c02773e", "patch": "@@ -830,7 +830,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:SI 3 \"=h\"))]\n+   (clobber (match_scratch:SI 3 \"=h\"))\n+   (clobber (match_scratch:SI 4 \"=a\"))]\n   \"\"\n   \"\n {\n@@ -847,7 +848,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:SI 3 \"=h\"))]\n+   (clobber (match_scratch:SI 3 \"=h\"))\n+   (clobber (match_scratch:SI 4 \"=a\"))]\n   \"mips_cpu != PROCESSOR_R4000\"\n   \"mult\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n@@ -859,7 +861,8 @@\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n    (clobber (match_scratch:SI 3 \"=h\"))\n-   (clobber (match_scratch:SI 4 \"=l\"))]\n+   (clobber (match_scratch:SI 4 \"=l\"))\n+   (clobber (match_scratch:SI 5 \"=a\"))]\n   \"mips_cpu == PROCESSOR_R4000\"\n   \"*\n {\n@@ -881,7 +884,8 @@\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n    (clobber (match_scratch:SI 3 \"=h\"))\n-   (clobber (match_scratch:SI 4 \"=l\"))]\n+   (clobber (match_scratch:SI 4 \"=l\"))\n+   (clobber (match_scratch:SI 5 \"=a\"))]\n   \"TARGET_MAD\"\n   \"mul\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n@@ -892,7 +896,8 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n \t(mult:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:DI 3 \"=h\"))]\n+   (clobber (match_scratch:DI 3 \"=h\"))\n+   (clobber (match_scratch:DI 4 \"=a\"))]\n   \"TARGET_64BIT\"\n   \"\n {\n@@ -907,7 +912,8 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=l\")\n \t(mult:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n-   (clobber (match_scratch:DI 3 \"=h\"))]\n+   (clobber (match_scratch:DI 3 \"=h\"))\n+   (clobber (match_scratch:DI 4 \"=a\"))]\n   \"TARGET_64BIT && mips_cpu != PROCESSOR_R4000\"\n   \"dmult\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n@@ -919,7 +925,8 @@\n \t(mult:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n    (clobber (match_scratch:DI 3 \"=h\"))\n-   (clobber (match_scratch:DI 4 \"=l\"))]\n+   (clobber (match_scratch:DI 4 \"=l\"))\n+   (clobber (match_scratch:DI 5 \"=a\"))]\n   \"TARGET_64BIT && mips_cpu == PROCESSOR_R4000\"\n   \"*\n {\n@@ -936,53 +943,104 @@\n    (set_attr \"mode\"\t\"DI\")\n    (set_attr \"length\"\t\"3\")])\t\t;; mult + mflo + delay\n \n-;; In 64 bit mode the mult instruction still writes 32 bits each to HI\n-;; and LO, so to do mulsidi3 and umultsidi3 we need to pull the values\n-;; out and combine them by hand into the single output register.  Not\n-;; supported for now.\n-\n ;; ??? We could define a mulditi3 pattern when TARGET_64BIT.\n \n-(define_insn \"mulsidi3\"\n+(define_expand \"mulsidi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n \t\t (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n+  \"\"\n+  \"\n+{\n+  if (TARGET_64BIT)\n+    emit_insn (gen_mulsidi3_64bit (operands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_mulsidi3_internal (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_insn \"mulsidi3_internal\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n+\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t\t (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))\n+   (clobber (match_scratch:SI 3 \"=a\"))]\n   \"!TARGET_64BIT\"\n   \"mult\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"1\")])\n \n+(define_insn \"mulsidi3_64bit\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t\t (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))\n+   (clobber (match_scratch:DI 3 \"=l\"))\n+   (clobber (match_scratch:DI 4 \"=h\"))]\n+  \"TARGET_64BIT\"\n+  \"mult\\\\t%1,%2\"\n+  [(set_attr \"type\"\t\"imul\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"1\")])\n+\n (define_insn \"smulsi3_highpart\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=h\")\n \t(truncate:SI\n \t (lshiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n \t\t\t       (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))\n \t\t      (const_int 32))))\n-   (clobber (match_scratch:SI 3 \"=l\"))]\n+   (clobber (match_scratch:SI 3 \"=l\"))\n+   (clobber (match_scratch:SI 4 \"=a\"))]\n   \"\"\n   \"mult\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"1\")])\n \n-(define_insn \"umulsidi3\"\n+(define_expand \"umulsidi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n \t\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n+  \"\"\n+  \"\n+{\n+  if (TARGET_64BIT)\n+    emit_insn (gen_umulsidi3_64bit (operands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_umulsidi3_internal (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_insn \"umulsidi3_internal\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=x\")\n+\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))\n+   (clobber (match_scratch:SI 3 \"=a\"))]\n   \"!TARGET_64BIT\"\n   \"multu\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"1\")])\n \n+(define_insn \"umulsidi3_64bit\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))\n+   (clobber (match_scratch:DI 3 \"=l\"))\n+   (clobber (match_scratch:DI 4 \"=h\"))]\n+  \"TARGET_64BIT\"\n+  \"multu\\\\t%1,%2\"\n+  [(set_attr \"type\"\t\"imul\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"1\")])\n+\n (define_insn \"umulsi3_highpart\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=h\")\n \t(truncate:SI\n \t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n \t\t\t       (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\")))\n \t\t      (const_int 32))))\n-   (clobber (match_scratch:SI 3 \"=l\"))]\n+   (clobber (match_scratch:SI 3 \"=l\"))\n+   (clobber (match_scratch:SI 4 \"=a\"))]\n   \"\"\n   \"multu\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n@@ -995,7 +1053,8 @@\n \t (lshiftrt:TI (mult:TI (sign_extend:TI (match_operand:DI 1 \"register_operand\" \"d\"))\n \t\t\t       (sign_extend:TI (match_operand:DI 2 \"register_operand\" \"d\")))\n \t\t      (const_int 64))))\n-   (clobber (match_scratch:DI 3 \"=l\"))]\n+   (clobber (match_scratch:DI 3 \"=l\"))\n+   (clobber (match_scratch:DI 4 \"=a\"))]\n   \"TARGET_64BIT\"\n   \"dmult\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n@@ -1008,7 +1067,8 @@\n \t (lshiftrt:TI (mult:TI (zero_extend:TI (match_operand:DI 1 \"register_operand\" \"d\"))\n \t\t\t       (zero_extend:TI (match_operand:DI 2 \"register_operand\" \"d\")))\n \t\t      (const_int 64))))\n-   (clobber (match_scratch:DI 3 \"=l\"))]\n+   (clobber (match_scratch:DI 3 \"=l\"))\n+   (clobber (match_scratch:DI 4 \"=a\"))]\n   \"TARGET_64BIT\"\n   \"dmultu\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n@@ -1023,43 +1083,72 @@\n \t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t\t  (match_operand:SI 2 \"register_operand\" \"d\"))\n \t\t (match_dup 0)))\n-   (clobber (match_scratch:SI 3 \"=h\"))]\n+   (clobber (match_scratch:SI 3 \"=h\"))\n+   (clobber (match_scratch:SI 4 \"=a\"))]\n   \"TARGET_MAD\"\n   \"mad\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"   \"1\")])\n \n-;; ??? We can only refer to HI/LO as a register pair when not\n-;; compiling 64 bit code.  That's because we don't know how to extract\n-;; the two 32 bit values into a single 64 bit register.\n-\n (define_insn \"maddi\"\n   [(set (match_operand:DI 0 \"register_operand\" \"+x\")\n \t(plus:DI (mult:DI (sign_extend:DI\n \t\t\t   (match_operand:SI 1 \"register_operand\" \"d\"))\n \t\t\t  (sign_extend:DI\n \t\t\t   (match_operand:SI 2 \"register_operand\" \"d\")))\n-\t\t (match_dup 0)))]\n+\t\t (match_dup 0)))\n+   (clobber (match_scratch:SI 3 \"=a\"))]\n   \"TARGET_MAD && ! TARGET_64BIT\"\n   \"mad\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"   \"1\")])\n \n+(define_insn \"maddi_64bit\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"+a\")\n+\t(plus:DI (mult:DI (sign_extend:DI\n+\t\t\t   (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t\t\t  (sign_extend:DI\n+\t\t\t   (match_operand:SI 2 \"register_operand\" \"d\")))\n+\t\t (match_dup 0)))\n+   (clobber (match_scratch:DI 3 \"=l\"))\n+   (clobber (match_scratch:DI 4 \"=h\"))]\n+  \"TARGET_MAD && TARGET_64BIT\"\n+  \"mad\\\\t%1,%2\"\n+  [(set_attr \"type\"\t\"imul\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"   \"1\")])\n+\n (define_insn \"umaddi\"\n   [(set (match_operand:DI 0 \"register_operand\" \"+x\")\n \t(plus:DI (mult:DI (zero_extend:DI\n \t\t\t   (match_operand:SI 1 \"register_operand\" \"d\"))\n \t\t\t  (zero_extend:DI\n \t\t\t   (match_operand:SI 2 \"register_operand\" \"d\")))\n-\t\t (match_dup 0)))]\n+\t\t (match_dup 0)))\n+   (clobber (match_scratch:SI 3 \"=a\"))]\n   \"TARGET_MAD && ! TARGET_64BIT\"\n   \"madu\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"   \"1\")])\n \n+(define_insn \"umaddi_64bit\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"+a\")\n+\t(plus:DI (mult:DI (zero_extend:DI\n+\t\t\t   (match_operand:SI 1 \"register_operand\" \"d\"))\n+\t\t\t  (zero_extend:DI\n+\t\t\t   (match_operand:SI 2 \"register_operand\" \"d\")))\n+\t\t (match_dup 0)))\n+   (clobber (match_scratch:DI 3 \"=l\"))\n+   (clobber (match_scratch:DI 4 \"=h\"))]\n+  \"TARGET_MAD && TARGET_64BIT\"\n+  \"madu\\\\t%1,%2\"\n+  [(set_attr \"type\"\t\"imul\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"   \"1\")])\n+\n ;; Floating point multiply accumulate instructions.\n \n (define_insn \"\"\n@@ -1200,7 +1289,8 @@\n \t(mod:SI (match_dup 1)\n \t\t(match_dup 2)))\n    (clobber (match_scratch:SI 4 \"=l\"))\n-   (clobber (match_scratch:SI 5 \"=h\"))]\n+   (clobber (match_scratch:SI 5 \"=h\"))\n+   (clobber (match_scratch:SI 6 \"=a\"))]\n   \"optimize\"\n   \"*\n {\n@@ -1224,7 +1314,8 @@\n \t(mod:DI (match_dup 1)\n \t\t(match_dup 2)))\n    (clobber (match_scratch:DI 4 \"=l\"))\n-   (clobber (match_scratch:DI 5 \"=h\"))]\n+   (clobber (match_scratch:DI 5 \"=h\"))\n+   (clobber (match_scratch:DI 6 \"=a\"))]\n   \"TARGET_64BIT && optimize\"\n   \"*\n {\n@@ -1248,7 +1339,8 @@\n \t(umod:SI (match_dup 1)\n \t\t (match_dup 2)))\n    (clobber (match_scratch:SI 4 \"=l\"))\n-   (clobber (match_scratch:SI 5 \"=h\"))]\n+   (clobber (match_scratch:SI 5 \"=h\"))\n+   (clobber (match_scratch:SI 6 \"=a\"))]\n   \"optimize\"\n   \"*\n {\n@@ -1272,7 +1364,8 @@\n \t(umod:DI (match_dup 1)\n \t\t (match_dup 2)))\n    (clobber (match_scratch:DI 4 \"=l\"))\n-   (clobber (match_scratch:DI 5 \"=h\"))]\n+   (clobber (match_scratch:DI 5 \"=h\"))\n+   (clobber (match_scratch:DI 6 \"=a\"))]\n   \"TARGET_64BIT && optimize\"\n   \"*\n {\n@@ -1293,7 +1386,8 @@\n \t(div:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t(match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n    (clobber (match_scratch:SI 3 \"=l\"))\n-   (clobber (match_scratch:SI 4 \"=h\"))]\n+   (clobber (match_scratch:SI 4 \"=h\"))\n+   (clobber (match_scratch:SI 6 \"=a\"))]\n   \"!optimize\"\n   \"div\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n@@ -1305,7 +1399,8 @@\n \t(div:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t(match_operand:DI 2 \"nonmemory_operand\" \"di\")))\n    (clobber (match_scratch:DI 3 \"=l\"))\n-   (clobber (match_scratch:DI 4 \"=h\"))]\n+   (clobber (match_scratch:DI 4 \"=h\"))\n+   (clobber (match_scratch:DI 6 \"=a\"))]\n   \"TARGET_64BIT && !optimize\"\n   \"ddiv\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n@@ -1317,7 +1412,8 @@\n \t(mod:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t(match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n    (clobber (match_scratch:SI 3 \"=l\"))\n-   (clobber (match_scratch:SI 4 \"=h\"))]\n+   (clobber (match_scratch:SI 4 \"=h\"))\n+   (clobber (match_scratch:SI 6 \"=a\"))]\n   \"!optimize\"\n   \"rem\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n@@ -1329,7 +1425,8 @@\n \t(mod:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t(match_operand:DI 2 \"nonmemory_operand\" \"di\")))\n    (clobber (match_scratch:DI 3 \"=l\"))\n-   (clobber (match_scratch:DI 4 \"=h\"))]\n+   (clobber (match_scratch:DI 4 \"=h\"))\n+   (clobber (match_scratch:DI 6 \"=a\"))]\n   \"TARGET_64BIT && !optimize\"\n   \"drem\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n@@ -1341,7 +1438,8 @@\n \t(udiv:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t (match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n    (clobber (match_scratch:SI 3 \"=l\"))\n-   (clobber (match_scratch:SI 4 \"=h\"))]\n+   (clobber (match_scratch:SI 4 \"=h\"))\n+   (clobber (match_scratch:SI 6 \"=a\"))]\n   \"!optimize\"\n   \"divu\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n@@ -1353,7 +1451,8 @@\n \t(udiv:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t (match_operand:DI 2 \"nonmemory_operand\" \"di\")))\n    (clobber (match_scratch:DI 3 \"=l\"))\n-   (clobber (match_scratch:DI 4 \"=h\"))]\n+   (clobber (match_scratch:DI 4 \"=h\"))\n+   (clobber (match_scratch:DI 6 \"=a\"))]\n   \"TARGET_64BIT && !optimize\"\n   \"ddivu\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n@@ -1365,7 +1464,8 @@\n \t(umod:SI (match_operand:SI 1 \"register_operand\" \"d\")\n \t\t (match_operand:SI 2 \"nonmemory_operand\" \"di\")))\n    (clobber (match_scratch:SI 3 \"=l\"))\n-   (clobber (match_scratch:SI 4 \"=h\"))]\n+   (clobber (match_scratch:SI 4 \"=h\"))\n+   (clobber (match_scratch:SI 6 \"=a\"))]\n   \"!optimize\"\n   \"remu\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n@@ -1377,7 +1477,8 @@\n \t(umod:DI (match_operand:DI 1 \"register_operand\" \"d\")\n \t\t (match_operand:DI 2 \"nonmemory_operand\" \"di\")))\n    (clobber (match_scratch:DI 3 \"=l\"))\n-   (clobber (match_scratch:DI 4 \"=h\"))]\n+   (clobber (match_scratch:DI 4 \"=h\"))\n+   (clobber (match_scratch:DI 6 \"=a\"))]\n   \"TARGET_64BIT && !optimize\"\n   \"dremu\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"idiv\")\n@@ -2925,18 +3026,149 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"\")\n \n (define_insn \"movdi_internal2\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*d,*x\")\n-\t(match_operand:DI 1 \"general_operand\" \" d,S,IKL,Mnis,R,m,dJ,dJ,*x,*d\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*d,*x,*a\")\n+\t(match_operand:DI 1 \"general_operand\" \" d,S,IKL,Mnis,R,m,dJ,dJ,*x,*d,*I\"))]\n   \"TARGET_64BIT\n    && (register_operand (operands[0], DImode)\n        || register_operand (operands[1], DImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0)\n        || operands[1] == CONST0_RTX (DImode))\"\n   \"* return mips_move_2words (operands, insn); \"\n-  [(set_attr \"type\"\t\"move,load,arith,arith,load,load,store,store,hilo,hilo\")\n+  [(set_attr \"type\"\t\"move,load,arith,arith,load,load,store,store,hilo,hilo,hilo\")\n    (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"1,2,1,2,1,2,1,2,1,1\")])\n+   (set_attr \"length\"\t\"1,2,1,2,1,2,1,2,1,1,2\")])\n+\n+;; Handle input reloads in DImode.\n+;; This is mainly to handle reloading HILO_REGNUM.  Note that we may\n+;; see it as the source or the destination, depending upon which way\n+;; reload handles the instruction.\n+;; Making the second operand TImode is a trick.  The compiler may\n+;; reuse the same register for operand 0 and operand 2.  Using TImode\n+;; gives us two registers, so we can always use the one which is not\n+;; used.\n+\n+(define_expand \"reload_indi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=b\")\n+\t(match_operand:DI 1 \"general_operand\" \"b\"))\n+   (clobber (match_operand:TI 2 \"register_operand\" \"=&d\"))]\n+  \"TARGET_64BIT\"\n+  \"\n+{\n+  rtx scratch = gen_rtx (REG, DImode,\n+\t\t\t (REGNO (operands[0]) == REGNO (operands[2]) \n+\t\t\t  ? REGNO (operands[2]) + 1\n+\t\t\t  : REGNO (operands[2])));\n+\n+  if (GET_CODE (operands[0]) == REG && REGNO (operands[0]) == HILO_REGNUM)\n+    {\n+      if (GET_CODE (operands[1]) == MEM)\n+\t{\n+\t  rtx memword, offword, hiword, loword;\n+\n+\t  scratch = gen_rtx (REG, SImode, REGNO (scratch));\n+\t  memword = change_address (operands[1], SImode, NULL_RTX);\n+\t  offword = change_address (adj_offsettable_operand (operands[1], 4),\n+\t\t\t\t    SImode, NULL_RTX);\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    {\n+\t      hiword = memword;\n+\t      loword = offword;\n+\t    }\n+\t  else\n+\t    {\n+\t      hiword = offword;\n+\t      loword = memword;\n+\t    }\n+\t  emit_move_insn (scratch, hiword);\n+\t  emit_move_insn (gen_rtx (REG, SImode, 64), scratch);\n+\t  emit_move_insn (scratch, loword);\n+\t  emit_move_insn (gen_rtx (REG, SImode, 65), scratch);\n+\t}\n+      else\n+\t{\n+\t  emit_insn (gen_ashrdi3 (scratch, operands[1], GEN_INT (32)));\n+\t  emit_insn (gen_movdi (gen_rtx (REG, DImode, 64), scratch));\n+\t  emit_insn (gen_ashldi3 (scratch, operands[1], GEN_INT (32)));\n+\t  emit_insn (gen_ashrdi3 (scratch, scratch, GEN_INT (32)));\n+\t  emit_insn (gen_movdi (gen_rtx (REG, DImode, 65), scratch));\n+\t}\n+      DONE;\n+    }\n+  if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) == HILO_REGNUM)\n+    {\n+      emit_insn (gen_movdi (scratch, gen_rtx (REG, DImode, 65)));\n+      emit_insn (gen_ashldi3 (scratch, scratch, GEN_INT (32)));\n+      emit_insn (gen_lshrdi3 (scratch, scratch, GEN_INT (32)));\n+      emit_insn (gen_movdi (operands[0], gen_rtx (REG, DImode, 64)));\n+      emit_insn (gen_ashldi3 (operands[0], operands[0], GEN_INT (32)));\n+      emit_insn (gen_iordi3 (operands[0], operands[0], scratch));\n+      DONE;\n+    }\n+  /* This handles moves between a float register and HI/LO.  */\n+  emit_move_insn (scratch, operands[1]);\n+  emit_move_insn (operands[0], scratch);\n+  DONE;\n+}\")\n \n+;; Handle output reloads in DImode.\n+\n+(define_expand \"reload_outdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=b\")\n+\t(match_operand:DI 1 \"register_operand\" \"b\"))\n+   (clobber (match_operand:DI 2 \"register_operand\" \"=&d\"))]\n+  \"TARGET_64BIT\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == REG && REGNO (operands[0]) == HILO_REGNUM)\n+    {\n+      emit_insn (gen_ashrdi3 (operands[2], operands[1], GEN_INT (32)));\n+      emit_insn (gen_movdi (gen_rtx (REG, DImode, 64), operands[2]));\n+      emit_insn (gen_ashldi3 (operands[2], operands[1], GEN_INT (32)));\n+      emit_insn (gen_ashrdi3 (operands[2], operands[2], GEN_INT (32)));\n+      emit_insn (gen_movdi (gen_rtx (REG, DImode, 65), operands[2]));\n+      DONE;\n+    }\n+  if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) == HILO_REGNUM)\n+    {\n+      if (GET_CODE (operands[0]) == MEM)\n+\t{\n+\t  rtx scratch, memword, offword, hiword, loword;\n+\n+\t  scratch = gen_rtx (REG, SImode, REGNO (operands[2]));\n+\t  memword = change_address (operands[0], SImode, NULL_RTX);\n+\t  offword = change_address (adj_offsettable_operand (operands[0], 4),\n+\t\t\t\t    SImode, NULL_RTX);\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    {\n+\t      hiword = memword;\n+\t      loword = offword;\n+\t    }\n+\t  else\n+\t    {\n+\t      hiword = offword;\n+\t      loword = memword;\n+\t    }\n+\t  emit_move_insn (scratch, gen_rtx (REG, SImode, 64));\n+\t  emit_move_insn (hiword, scratch);\n+\t  emit_move_insn (scratch, gen_rtx (REG, SImode, 65));\n+\t  emit_move_insn (loword, scratch);\n+\t}\n+      else\n+\t{\n+\t  emit_insn (gen_movdi (operands[2], gen_rtx (REG, DImode, 65)));\n+\t  emit_insn (gen_ashldi3 (operands[2], operands[2], GEN_INT (32)));\n+\t  emit_insn (gen_lshrdi3 (operands[2], operands[2], GEN_INT (32)));\n+\t  emit_insn (gen_movdi (operands[0], gen_rtx (REG, DImode, 64)));\n+\t  emit_insn (gen_ashldi3 (operands[0], operands[0], GEN_INT (32)));\n+\t  emit_insn (gen_iordi3 (operands[0], operands[0], operands[2]));\n+\t}\n+      DONE;\n+    }\n+  /* This handles moves between a float register and HI/LO.  */\n+  emit_move_insn (operands[2], operands[1]);\n+  emit_move_insn (operands[0], operands[2]);\n+  DONE;\n+}\")\n \n ;; 32-bit Integer moves\n \n@@ -3011,29 +3243,51 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; in FP registers (off by default, use -mdebugh to enable).\n \n (define_insn \"movsi_internal1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*d,*f*z,*f,*f,*f,*R,*m,*x,*d\")\n-\t(match_operand:SI 1 \"general_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*f*z,*d,*f,*R,*m,*f,*f,*d,*x\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*d,*f*z,*f,*f,*f,*R,*m,*x,*x,*d,*d\")\n+\t(match_operand:SI 1 \"general_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*f*z,*d,*f,*R,*m,*f,*f,I,*d,*x,*a\"))]\n   \"TARGET_DEBUG_H_MODE\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n   \"* return mips_move_1word (operands, insn, FALSE);\"\n-  [(set_attr \"type\"\t\"move,load,arith,arith,load,load,store,store,xfer,xfer,move,load,load,store,store,hilo,hilo\")\n+  [(set_attr \"type\"\t\"move,load,arith,arith,load,load,store,store,xfer,xfer,move,load,load,store,store,hilo,hilo,hilo,hilo\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"1,2,1,2,1,2,1,2,1,1,1,1,2,1,2,1,1\")])\n+   (set_attr \"length\"\t\"1,2,1,2,1,2,1,2,1,1,1,1,2,1,2,1,1,1,1\")])\n \n (define_insn \"movsi_internal2\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*d,*z,*d,*x\")\n-\t(match_operand:SI 1 \"general_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*z,*d,*x,*d\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,d,d,d,R,m,*d,*z,*x,*d,*x,*d\")\n+\t(match_operand:SI 1 \"general_operand\" \"d,S,IKL,Mnis,R,m,dJ,dJ,*z,*d,I,*x,*d,*a\"))]\n   \"!TARGET_DEBUG_H_MODE\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode)\n        || (GET_CODE (operands[1]) == CONST_INT && INTVAL (operands[1]) == 0))\"\n   \"* return mips_move_1word (operands, insn, FALSE);\"\n-  [(set_attr \"type\"\t\"move,load,arith,arith,load,load,store,store,xfer,xfer,hilo,hilo\")\n+  [(set_attr \"type\"\t\"move,load,arith,arith,load,load,store,store,xfer,xfer,hilo,hilo,hilo,hilo\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"1,2,1,2,1,2,1,2,1,1,1,1\")])\n+   (set_attr \"length\"\t\"1,2,1,2,1,2,1,2,1,1,1,1,1,1\")])\n \n+;; Reload HILO_REGNUM in SI mode.  This needs a scratch register in\n+;; order to set the sign bit correctly in the HI register.\n+\n+(define_expand \"reload_outsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=b\")\n+\t(match_operand:SI 1 \"register_operand\" \"d\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&d\"))]\n+  \"TARGET_64BIT\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == REG && REGNO (operands[0]) == HILO_REGNUM)\n+    {\n+      emit_insn (gen_movsi (gen_rtx (REG, SImode, 65), operands[1]));\n+      emit_insn (gen_ashrsi3 (operands[2], operands[1], GEN_INT (31)));\n+      emit_insn (gen_movsi (gen_rtx (REG, SImode, 64), operands[2]));\n+      DONE;\n+    }\n+  /* This handles moves between a float register and HI/LO.  */\n+  emit_move_insn (operands[2], operands[1]);\n+  emit_move_insn (operands[0], operands[2]);\n+  DONE;\n+}\")\n \n ;; 16-bit Integer moves\n \n@@ -4201,7 +4455,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_insn \"branch_fp_ne\"\n   [(set (pc)\n-\t(if_then_else (ne:CC_FP (reg:CC_FP 66)\n+\t(if_then_else (ne:CC_FP (reg:CC_FP 67)\n \t\t\t\t(const_int 0))\n \t\t      (match_operand 0 \"pc_or_label_operand\" \"\")\n \t\t      (match_operand 1 \"pc_or_label_operand\" \"\")))]\n@@ -4217,7 +4471,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_insn \"branch_fp_ne_rev\"\n   [(set (pc)\n-\t(if_then_else (ne:CC_REV_FP (reg:CC_REV_FP 66)\n+\t(if_then_else (ne:CC_REV_FP (reg:CC_REV_FP 67)\n \t\t\t\t    (const_int 0))\n \t\t      (match_operand 0 \"pc_or_label_operand\" \"\")\n \t\t      (match_operand 1 \"pc_or_label_operand\" \"\")))]\n@@ -4233,7 +4487,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_insn \"branch_fp_eq\"\n   [(set (pc)\n-\t(if_then_else (eq:CC_FP (reg:CC_FP 66)\n+\t(if_then_else (eq:CC_FP (reg:CC_FP 67)\n \t\t\t\t(const_int 0))\n \t\t      (match_operand 0 \"pc_or_label_operand\" \"\")\n \t\t      (match_operand 1 \"pc_or_label_operand\" \"\")))]\n@@ -4249,7 +4503,7 @@ move\\\\t%0,%z4\\\\n\\\\\n \n (define_insn \"branch_fp_eq_rev\"\n   [(set (pc)\n-\t(if_then_else (eq:CC_REV_FP (reg:CC_REV_FP 66)\n+\t(if_then_else (eq:CC_REV_FP (reg:CC_REV_FP 67)\n \t\t\t\t    (const_int 0))\n \t\t      (match_operand 0 \"pc_or_label_operand\" \"\")\n \t\t      (match_operand 1 \"pc_or_label_operand\" \"\")))]\n@@ -5285,7 +5539,7 @@ move\\\\t%0,%z4\\\\n\\\\\n ;;  ....................\n \n (define_insn \"seq_df\"\n-  [(set (reg:CC_FP 66)\n+  [(set (reg:CC_FP 67)\n \t(eq:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n \t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n@@ -5303,7 +5557,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"sne_df\"\n-  [(set (reg:CC_REV_FP 66)\n+  [(set (reg:CC_REV_FP 67)\n \t(ne:CC_REV_FP (match_operand:DF 0 \"register_operand\" \"f\")\n \t\t      (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n@@ -5321,7 +5575,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"slt_df\"\n-  [(set (reg:CC_FP 66)\n+  [(set (reg:CC_FP 67)\n \t(lt:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n \t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n@@ -5339,7 +5593,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"sle_df\"\n-  [(set (reg:CC_FP 66)\n+  [(set (reg:CC_FP 67)\n \t(le:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n \t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n@@ -5357,7 +5611,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"sgt_df\"\n-  [(set (reg:CC_FP 66)\n+  [(set (reg:CC_FP 67)\n \t(gt:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n \t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n@@ -5375,7 +5629,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"sge_df\"\n-  [(set (reg:CC_FP 66)\n+  [(set (reg:CC_FP 67)\n \t(ge:CC_FP (match_operand:DF 0 \"register_operand\" \"f\")\n \t\t  (match_operand:DF 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n@@ -5393,7 +5647,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"seq_sf\"\n-  [(set (reg:CC_FP 66)\n+  [(set (reg:CC_FP 67)\n \t(eq:CC_FP (match_operand:SF 0 \"register_operand\" \"f\")\n \t\t  (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n@@ -5411,7 +5665,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"sne_sf\"\n-  [(set (reg:CC_REV_FP 66)\n+  [(set (reg:CC_REV_FP 67)\n \t(ne:CC_REV_FP (match_operand:SF 0 \"register_operand\" \"f\")\n \t\t      (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n@@ -5429,7 +5683,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"slt_sf\"\n-  [(set (reg:CC_FP 66)\n+  [(set (reg:CC_FP 67)\n \t(lt:CC_FP (match_operand:SF 0 \"register_operand\" \"f\")\n \t\t  (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n@@ -5447,7 +5701,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"sle_sf\"\n-  [(set (reg:CC_FP 66)\n+  [(set (reg:CC_FP 67)\n \t(le:CC_FP (match_operand:SF 0 \"register_operand\" \"f\")\n \t\t  (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n@@ -5465,7 +5719,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"sgt_sf\"\n-  [(set (reg:CC_FP 66)\n+  [(set (reg:CC_FP 67)\n \t(gt:CC_FP (match_operand:SF 0 \"register_operand\" \"f\")\n \t\t  (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n@@ -5483,7 +5737,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   (set_attr \"length\"\t\"1\")])\n \n (define_insn \"sge_sf\"\n-  [(set (reg:CC_FP 66)\n+  [(set (reg:CC_FP 67)\n \t(ge:CC_FP (match_operand:SF 0 \"register_operand\" \"f\")\n \t\t  (match_operand:SF 1 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n@@ -6193,7 +6447,7 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n \t(if_then_else:SI\n-\t (match_operator 3 \"equality_op\" [(reg:CC_FP 66) (const_int 0)])\n+\t (match_operator 3 \"equality_op\" [(reg:CC_FP 67) (const_int 0)])\n \t (match_operand:SI 1 \"reg_or_0_operand\" \"dJ,0\")\n \t (match_operand:SI 2 \"reg_or_0_operand\" \"0,dJ\")))]\n   \"mips_isa >= 4\"\n@@ -6221,7 +6475,7 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n \t(if_then_else:DI\n-\t (match_operator 3 \"equality_op\" [(reg:CC_FP 66) (const_int 0)])\n+\t (match_operator 3 \"equality_op\" [(reg:CC_FP 67) (const_int 0)])\n \t (match_operand:DI 1 \"reg_or_0_operand\" \"dJ,0\")\n \t (match_operand:DI 2 \"reg_or_0_operand\" \"0,dJ\")))]\n   \"mips_isa >= 4\"\n@@ -6249,7 +6503,7 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n \t(if_then_else:SF\n-\t (match_operator 3 \"equality_op\" [(reg:CC_FP 66) (const_int 0)])\n+\t (match_operator 3 \"equality_op\" [(reg:CC_FP 67) (const_int 0)])\n \t (match_operand:SF 1 \"register_operand\" \"f,0\")\n \t (match_operand:SF 2 \"register_operand\" \"0,f\")))]\n   \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n@@ -6277,7 +6531,7 @@ move\\\\t%0,%z4\\\\n\\\\\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n \t(if_then_else:DF\n-\t (match_operator 3 \"equality_op\" [(reg:CC_FP 66) (const_int 0)])\n+\t (match_operator 3 \"equality_op\" [(reg:CC_FP 67) (const_int 0)])\n \t (match_operand:DF 1 \"register_operand\" \"f,0\")\n \t (match_operand:DF 2 \"register_operand\" \"0,f\")))]\n   \"mips_isa >= 4 && TARGET_HARD_FLOAT\""}]}