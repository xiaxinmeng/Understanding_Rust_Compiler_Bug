{"sha": "f996902d097063cdb85bbb545e42fe099ca637b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk5NjkwMmQwOTcwNjNjZGI4NWJiYjU0NWU0MmZlMDk5Y2E2MzdiOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-05-23T21:55:30Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-05-23T21:55:30Z"}, "message": "configure.in (HAVE_AS_TLS): New test.\n\n\t* configure.in (HAVE_AS_TLS): New test.\n\t* config.in, configure: Rebuild.\n\t* config/i386/i386.c (TARGET_HAVE_TLS): Set if HAVE_AS_TLS.\n\t(ix86_tls_dialect_string, ix86_tls_dialect): New.\n\t(override_options): Set it.\n\t(tls_model_chars, tls_symbolic_operand): New.\n\t(tls_symbolic_operand_1, global_dynamic_symbolic_operand): New.\n\t(local_dynamic_symbolic_operand, initial_exec_symbolic_operand): New.\n\t(local_exec_symbolic_operand): New.\n\t(get_pic_label_name): Merge into output_set_got.\n\t(ix86_asm_file_end): Emit pic_label_name if defined.\n\t(legitimate_constant_p, constant_address_p): New.\n\t(legitimate_pic_operand_p): New.\n\t(legitimate_pic_address_disp_p): Handle GOTTPOFF, NTPOFF, DTPOFF.\n\t(legitimate_address_p): Likewise.\n\t(ix86_encode_section_info): Rename from i386_; handle tls decls.\n\t(ix86_strip_name_encoding): New.\n\t(get_thread_pointer): New.\n\t(legitimize_address): Handle tls symbols.\n\t(output_pic_addr_const): Handle GOTTPOFF, TPOFF, NTPOFF, DTPOFF.\n\tRemove UNSPEC_PLT.\n\t(struct machine_function): Add some_ld_name.\n\t(get_some_local_dynamic_name, get_some_local_dynamic_name_1): Set it.\n\t(print_operand) [&]: Use it.  Handle UNSPEC_TP.\n\t(output_addr_const_extra): New.\n\t(maybe_get_pool_constant): New.\n\t(ix86_split_to_parts): Use it.\n\t(ix86_expand_move): Handle tls symbols.\n\t(ix86_tls_get_addr): New.\n\t* config/i386/i386.h (TARGET_GNU_TLS, TARGET_SUN_TLS): New.\n\t(TARGET_OPTIONS): Add tls-dialect.\n\t(CONSTANT_ADDRESS_P): Use new out-of-line function.\n\t(LEGITIMATE_CONSTANT_P): Likewise.\n\t(LEGITIMATE_PIC_OPERAND_P): Likewise.\n\t(TARGET_STRIP_NAME_ENCODING): New.\n\t(ASM_OUTPUT_LABELREF): New.\n\t(PRINT_OPERAND_PUNCT_VALID_P): Add '&'.\n\t(OUTPUT_ADDR_CONST_EXTRA): New.\n\t(PREDICATE_CODES): Update.\n\t(ix86_tls_dialect, ix86_tls_dialect_string): New.\n\t* config/i386/i386.md: Regroup and renumber unspec constants.\n\t(tls_global_dynamic_gnu, tls_global_dynamic_sun): New.\n\t(tls_local_dynamic_base_gnu, tls_local_dynamic_base_sun): New.\n\t(tls_global_dynamic, tls_local_dynamic_base): New.\n\t(tls_local_dynamic_once): New.\n\t* config/i386/i386-protos.h: Update.\n\nFrom-SVN: r53812", "tree": {"sha": "c1b2e00bd4d42f8bb8685ead98e7da60c3f0d7f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1b2e00bd4d42f8bb8685ead98e7da60c3f0d7f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f996902d097063cdb85bbb545e42fe099ca637b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f996902d097063cdb85bbb545e42fe099ca637b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f996902d097063cdb85bbb545e42fe099ca637b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f996902d097063cdb85bbb545e42fe099ca637b8/comments", "author": null, "committer": null, "parents": [{"sha": "821e35ba25c6cdb74cb245471bafd725e463595e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/821e35ba25c6cdb74cb245471bafd725e463595e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/821e35ba25c6cdb74cb245471bafd725e463595e"}], "stats": {"total": 1115, "additions": 1011, "deletions": 104}, "files": [{"sha": "6209ff60bde1d9a7939e04034493e04410270901", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f996902d097063cdb85bbb545e42fe099ca637b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f996902d097063cdb85bbb545e42fe099ca637b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f996902d097063cdb85bbb545e42fe099ca637b8", "patch": "@@ -1,3 +1,52 @@\n+2002-05-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* configure.in (HAVE_AS_TLS): New test.\n+\t* config.in, configure: Rebuild.\n+\t* config/i386/i386.c (TARGET_HAVE_TLS): Set if HAVE_AS_TLS.\n+\t(ix86_tls_dialect_string, ix86_tls_dialect): New.\n+\t(override_options): Set it.\n+\t(tls_model_chars, tls_symbolic_operand): New.\n+\t(tls_symbolic_operand_1, global_dynamic_symbolic_operand): New.\n+\t(local_dynamic_symbolic_operand, initial_exec_symbolic_operand): New.\n+\t(local_exec_symbolic_operand): New.\n+\t(get_pic_label_name): Merge into output_set_got.\n+\t(ix86_asm_file_end): Emit pic_label_name if defined.\n+\t(legitimate_constant_p, constant_address_p): New.\n+\t(legitimate_pic_operand_p): New.\n+\t(legitimate_pic_address_disp_p): Handle GOTTPOFF, NTPOFF, DTPOFF.\n+\t(legitimate_address_p): Likewise.\n+\t(ix86_encode_section_info): Rename from i386_; handle tls decls.\n+\t(ix86_strip_name_encoding): New.\n+\t(get_thread_pointer): New.\n+\t(legitimize_address): Handle tls symbols.\n+\t(output_pic_addr_const): Handle GOTTPOFF, TPOFF, NTPOFF, DTPOFF.\n+\tRemove UNSPEC_PLT.\n+\t(struct machine_function): Add some_ld_name.\n+\t(get_some_local_dynamic_name, get_some_local_dynamic_name_1): Set it.\n+\t(print_operand) [&]: Use it.  Handle UNSPEC_TP.\n+\t(output_addr_const_extra): New.\n+\t(maybe_get_pool_constant): New.\n+\t(ix86_split_to_parts): Use it.\n+\t(ix86_expand_move): Handle tls symbols.\n+\t(ix86_tls_get_addr): New.\n+\t* config/i386/i386.h (TARGET_GNU_TLS, TARGET_SUN_TLS): New.\n+\t(TARGET_OPTIONS): Add tls-dialect.\n+\t(CONSTANT_ADDRESS_P): Use new out-of-line function.\n+\t(LEGITIMATE_CONSTANT_P): Likewise.\n+\t(LEGITIMATE_PIC_OPERAND_P): Likewise.\n+\t(TARGET_STRIP_NAME_ENCODING): New.\n+\t(ASM_OUTPUT_LABELREF): New.\n+\t(PRINT_OPERAND_PUNCT_VALID_P): Add '&'.\n+\t(OUTPUT_ADDR_CONST_EXTRA): New.\n+\t(PREDICATE_CODES): Update.\n+\t(ix86_tls_dialect, ix86_tls_dialect_string): New.\n+\t* config/i386/i386.md: Regroup and renumber unspec constants.\n+\t(tls_global_dynamic_gnu, tls_global_dynamic_sun): New.\n+\t(tls_local_dynamic_base_gnu, tls_local_dynamic_base_sun): New.\n+\t(tls_global_dynamic, tls_local_dynamic_base): New.\n+\t(tls_local_dynamic_once): New.\n+\t* config/i386/i386-protos.h: Update.\n+\n 2002-05-23  Richard Henderson  <rth@redhat.com>\n \n \t* genemit.c (gen_insn): Print file:lineno comment before function."}, {"sha": "73a466bc3756ed6cdf2ff4706742b5f562635a01", "filename": "gcc/config.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f996902d097063cdb85bbb545e42fe099ca637b8/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f996902d097063cdb85bbb545e42fe099ca637b8/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=f996902d097063cdb85bbb545e42fe099ca637b8", "patch": "@@ -528,6 +528,9 @@\n /* Define if your assembler supports marking sections with SHF_MERGE flag. */\n #undef HAVE_GAS_SHF_MERGE\n \n+/* Define if your assembler supports thread-local storage. */\n+#undef HAVE_AS_TLS\n+\n /* Define if your assembler supports explicit relocations. */\n #undef HAVE_AS_EXPLICIT_RELOCS\n "}, {"sha": "1690d8a9e084ad3cda332e61d2ecc499d5a14081", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f996902d097063cdb85bbb545e42fe099ca637b8/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f996902d097063cdb85bbb545e42fe099ca637b8/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=f996902d097063cdb85bbb545e42fe099ca637b8", "patch": "@@ -50,6 +50,11 @@ extern int x86_64_immediate_operand PARAMS ((rtx, enum machine_mode));\n extern int x86_64_zext_immediate_operand PARAMS ((rtx, enum machine_mode));\n extern int const_int_1_operand PARAMS ((rtx, enum machine_mode));\n extern int symbolic_operand PARAMS ((rtx, enum machine_mode));\n+extern int tls_symbolic_operand PARAMS ((rtx, enum machine_mode));\n+extern int global_dynamic_symbolic_operand PARAMS ((rtx, enum machine_mode));\n+extern int local_dynamic_symbolic_operand PARAMS ((rtx, enum machine_mode));\n+extern int initial_exec_symbolic_operand PARAMS ((rtx, enum machine_mode));\n+extern int local_exec_symbolic_operand PARAMS ((rtx, enum machine_mode));\n extern int pic_symbolic_operand PARAMS ((rtx, enum machine_mode));\n extern int call_insn_operand PARAMS ((rtx, enum machine_mode));\n extern int constant_call_address_operand PARAMS ((rtx, enum machine_mode));\n@@ -83,6 +88,9 @@ extern int ix86_expand_movstr PARAMS ((rtx, rtx, rtx, rtx));\n extern int ix86_expand_clrstr PARAMS ((rtx, rtx, rtx));\n extern int ix86_expand_strlen PARAMS ((rtx, rtx, rtx, rtx));\n \n+extern bool legitimate_constant_p PARAMS ((rtx));\n+extern bool constant_address_p PARAMS ((rtx));\n+extern bool legitimate_pic_operand_p PARAMS ((rtx));\n extern int legitimate_pic_address_disp_p PARAMS ((rtx));\n extern int legitimate_address_p PARAMS ((enum machine_mode, rtx, int));\n extern rtx legitimize_pic_address PARAMS ((rtx, rtx));\n@@ -91,6 +99,7 @@ extern rtx legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n extern void print_reg PARAMS ((rtx, int, FILE*));\n extern void print_operand PARAMS ((FILE*, rtx, int));\n extern void print_operand_address PARAMS ((FILE*, rtx));\n+extern bool output_addr_const_extra PARAMS ((FILE*, rtx));\n \n extern void split_di PARAMS ((rtx[], int, rtx[], rtx[]));\n extern void split_ti PARAMS ((rtx[], int, rtx[], rtx[]));\n@@ -198,6 +207,8 @@ extern void i386_pe_asm_named_section PARAMS ((const char *, unsigned int));\n extern void x86_output_mi_thunk PARAMS ((FILE *, int, tree));\n #endif\n \n+extern rtx ix86_tls_get_addr PARAMS ((void));\n+\n /* In winnt.c  */\n extern void i386_pe_encode_section_info PARAMS ((tree, int));\n extern const char *i386_pe_strip_name_encoding PARAMS ((const char *));"}, {"sha": "ba52c7c3eac1bf643e0454da39878ee131d1c4b4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 639, "deletions": 61, "changes": 700, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f996902d097063cdb85bbb545e42fe099ca637b8/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f996902d097063cdb85bbb545e42fe099ca637b8/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f996902d097063cdb85bbb545e42fe099ca637b8", "patch": "@@ -544,6 +544,10 @@ int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER] =\n rtx ix86_compare_op0 = NULL_RTX;\n rtx ix86_compare_op1 = NULL_RTX;\n \n+/* The encoding characters for the four TLS models present in ELF.  */\n+\n+static char const tls_model_chars[] = \"GLil\";\n+\n #define MAX_386_STACK_LOCALS 3\n /* Size of the register save area.  */\n #define X86_64_VARARGS_SIZE (REGPARM_MAX * UNITS_PER_WORD + SSE_REGPARM_MAX * 16)\n@@ -552,6 +556,7 @@ rtx ix86_compare_op1 = NULL_RTX;\n struct machine_function\n {\n   rtx stack_locals[(int) MAX_MACHINE_MODE][MAX_386_STACK_LOCALS];\n+  const char *some_ld_name;\n   int save_varrargs_registers;\n   int accesses_prev_frame;\n };\n@@ -604,6 +609,9 @@ enum cmodel ix86_cmodel;\n /* Asm dialect.  */\n const char *ix86_asm_string;\n enum asm_dialect ix86_asm_dialect = ASM_ATT;\n+/* TLS dialext.  */\n+const char *ix86_tls_dialect_string;\n+enum tls_dialect ix86_tls_dialect = TLS_DIALECT_GNU;\n \n /* Which unit we are generating floating point math for.  */\n enum fpmath_unit ix86_fpmath;\n@@ -653,13 +661,17 @@ static char internal_label_prefix[16];\n static int internal_label_prefix_len;\n \f\n static int local_symbolic_operand PARAMS ((rtx, enum machine_mode));\n-static const char *get_pic_label_name PARAMS ((void));\n+static int tls_symbolic_operand_1 PARAMS ((rtx, enum tls_model));\n static void output_pic_addr_const PARAMS ((FILE *, rtx, int));\n static void put_condition_code PARAMS ((enum rtx_code, enum machine_mode,\n \t\t\t\t       int, int, FILE *));\n+static const char *get_some_local_dynamic_name PARAMS ((void));\n+static int get_some_local_dynamic_name_1 PARAMS ((rtx *, void *));\n+static rtx maybe_get_pool_constant PARAMS ((rtx));\n static rtx ix86_expand_int_compare PARAMS ((enum rtx_code, rtx, rtx));\n static enum rtx_code ix86_prepare_fp_compare_args PARAMS ((enum rtx_code,\n \t\t\t\t\t\t\t   rtx *, rtx *));\n+static rtx get_thread_pointer PARAMS ((void));\n static rtx gen_push PARAMS ((rtx));\n static int memory_address_length PARAMS ((rtx addr));\n static int ix86_flags_dependant PARAMS ((rtx, rtx, enum attr_type));\n@@ -698,7 +710,9 @@ struct ix86_address\n \n static int ix86_decompose_address PARAMS ((rtx, struct ix86_address *));\n \n-static void i386_encode_section_info PARAMS ((tree, int)) ATTRIBUTE_UNUSED;\n+static void ix86_encode_section_info PARAMS ((tree, int)) ATTRIBUTE_UNUSED;\n+static const char *ix86_strip_name_encoding PARAMS ((const char *))\n+     ATTRIBUTE_UNUSED;\n \n struct builtin_description;\n static rtx ix86_expand_sse_comi PARAMS ((const struct builtin_description *,\n@@ -831,6 +845,11 @@ static enum x86_64_reg_class merge_classes PARAMS ((enum x86_64_reg_class,\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD \\\n   ia32_multipass_dfa_lookahead\n \n+#ifdef HAVE_AS_TLS\n+#undef TARGET_HAVE_TLS\n+#define TARGET_HAVE_TLS true\n+#endif\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Sometimes certain combinations of command options do not make\n@@ -1120,6 +1139,17 @@ override_options ()\n \tix86_branch_cost = i;\n     }\n \n+  if (ix86_tls_dialect_string)\n+    {\n+      if (strcmp (ix86_tls_dialect_string, \"gnu\") == 0)\n+\tix86_tls_dialect = TLS_DIALECT_GNU;\n+      else if (strcmp (ix86_tls_dialect_string, \"sun\") == 0)\n+\tix86_tls_dialect = TLS_DIALECT_SUN;\n+      else\n+\terror (\"bad value (%s) for -mtls-dialect= switch\",\n+\t       ix86_tls_dialect_string);\n+    }\n+\n   /* Keep nonleaf frame pointers.  */\n   if (TARGET_OMIT_LEAF_FRAME_POINTER)\n     flag_omit_frame_pointer = 1;\n@@ -2962,6 +2992,70 @@ local_symbolic_operand (op, mode)\n   return 0;\n }\n \n+/* Test for various thread-local symbols.  See ix86_encode_section_info. */\n+\n+int\n+tls_symbolic_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  const char *symbol_str;\n+\n+  if (GET_CODE (op) != SYMBOL_REF)\n+    return 0;\n+  symbol_str = XSTR (op, 0);\n+\n+  if (symbol_str[0] != '%')\n+    return 0;\n+  return strchr (tls_model_chars, symbol_str[1]) - tls_model_chars + 1;\n+}\n+\n+static int\n+tls_symbolic_operand_1 (op, kind)\n+     rtx op;\n+     enum tls_model kind;\n+{\n+  const char *symbol_str;\n+\n+  if (GET_CODE (op) != SYMBOL_REF)\n+    return 0;\n+  symbol_str = XSTR (op, 0);\n+\n+  return symbol_str[0] == '%' && symbol_str[1] == tls_model_chars[kind];\n+}\n+\n+int\n+global_dynamic_symbolic_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return tls_symbolic_operand_1 (op, TLS_MODEL_GLOBAL_DYNAMIC);\n+}\n+\n+int\n+local_dynamic_symbolic_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return tls_symbolic_operand_1 (op, TLS_MODEL_LOCAL_DYNAMIC);\n+}\n+\n+int\n+initial_exec_symbolic_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return tls_symbolic_operand_1 (op, TLS_MODEL_INITIAL_EXEC);\n+}\n+\n+int\n+local_exec_symbolic_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return tls_symbolic_operand_1 (op, TLS_MODEL_LOCAL_EXEC);\n+}\n+\n /* Test for a valid operand for a call instruction.  Don't allow the\n    arg pointer register or virtual regs since they may decay into\n    reg + const, which the patterns can't handle.  */\n@@ -3802,14 +3896,6 @@ ix86_setup_frame_addresses ()\n \f\n static char pic_label_name[32];\n \n-static const char *\n-get_pic_label_name ()\n-{\n-  if (! pic_label_name[0])\n-    ASM_GENERATE_INTERNAL_LABEL (pic_label_name, \"LPR\", 0);\n-  return pic_label_name;\n-}\n-\n /* This function generates code for -fpic that loads %ebx with\n    the return address of the caller and then returns.  */\n \n@@ -3819,7 +3905,7 @@ ix86_asm_file_end (file)\n {\n   rtx xops[2];\n \n-  if (! TARGET_DEEP_BRANCH_PREDICTION || pic_label_name[0] == 0)\n+  if (pic_label_name[0] == 0)\n     return;\n \n   /* ??? Binutils 2.10 and earlier has a linkonce elimination bug related\n@@ -3890,7 +3976,10 @@ output_set_got (dest)\n     }\n   else\n     {\n-      xops[2] = gen_rtx_SYMBOL_REF (Pmode, get_pic_label_name ());\n+      if (! pic_label_name[0])\n+\tASM_GENERATE_INTERNAL_LABEL (pic_label_name, \"LPR\", 0);\n+\n+      xops[2] = gen_rtx_SYMBOL_REF (Pmode, pic_label_name);\n       xops[2] = gen_rtx_MEM (QImode, xops[2]);\n       output_asm_insn (\"call\\t%X2\", xops);\n     }\n@@ -4676,13 +4765,123 @@ ix86_find_base_term (x)\n   return term;\n }\n \f\n+/* Determine if a given RTX is a valid constant.  We already know this\n+   satisfies CONSTANT_P.  */\n+\n+bool\n+legitimate_constant_p (x)\n+     rtx x;\n+{\n+  rtx inner;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case SYMBOL_REF:\n+      /* TLS symbols are not constant.  */\n+      if (tls_symbolic_operand (x, Pmode))\n+\treturn false;\n+      break;\n+\n+    case CONST:\n+      inner = XEXP (x, 0);\n+\n+      /* Offsets of TLS symbols are never valid.\n+\t Discourage CSE from creating them.  */\n+      if (GET_CODE (inner) == PLUS\n+\t  && tls_symbolic_operand (XEXP (inner, 0), Pmode))\n+\treturn false;\n+\n+      /* Only some unspecs are valid as \"constants\".  */\n+      if (GET_CODE (inner) == UNSPEC)\n+\tswitch (XINT (inner, 1))\n+\t  {\n+\t  case UNSPEC_TPOFF:\n+\t    return local_exec_symbolic_operand (XVECEXP (inner, 0, 0), Pmode);\n+\t  case UNSPEC_TP:\n+\t    return true;\n+\t  default:\n+\t    return false;\n+\t  }\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Otherwise we handle everything else in the move patterns.  */\n+  return true;\n+}\n+\n+/* Determine if a given RTX is a valid constant address.  */\n+\n+bool\n+constant_address_p (x)\n+     rtx x;\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case LABEL_REF:\n+    case CONST_INT:\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      return TARGET_64BIT;\n+\n+    case CONST:\n+    case SYMBOL_REF:\n+      return !flag_pic && legitimate_constant_p (x);\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Nonzero if the constant value X is a legitimate general operand\n+   when generating PIC code.  It is given that flag_pic is on and \n+   that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+bool\n+legitimate_pic_operand_p (x)\n+     rtx x;\n+{\n+  rtx inner;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case CONST:\n+      inner = XEXP (x, 0);\n+\n+      /* Only some unspecs are valid as \"constants\".  */\n+      if (GET_CODE (inner) == UNSPEC)\n+\tswitch (XINT (inner, 1))\n+\t  {\n+\t  case UNSPEC_TPOFF:\n+\t    return local_exec_symbolic_operand (XVECEXP (inner, 0, 0), Pmode);\n+\t  case UNSPEC_TP:\n+\t    return true;\n+\t  default:\n+\t    return false;\n+\t  }\n+      /* FALLTHRU */\n+\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return legitimate_pic_address_disp_p (x);\n+\n+    default:\n+      return true;\n+    }\n+}\n+\n /* Determine if a given CONST RTX is a valid memory displacement\n    in PIC mode.  */\n \n int\n legitimate_pic_address_disp_p (disp)\n      register rtx disp;\n {\n+  bool saw_plus;\n+\n   /* In 64bit mode we can allow direct addresses of symbols and labels\n      when they are not dynamic symbols.  */\n   if (TARGET_64BIT)\n@@ -4718,23 +4917,40 @@ legitimate_pic_address_disp_p (disp)\n       return 1;\n     }\n \n+  saw_plus = false;\n   if (GET_CODE (disp) == PLUS)\n     {\n       if (GET_CODE (XEXP (disp, 1)) != CONST_INT)\n \treturn 0;\n       disp = XEXP (disp, 0);\n+      saw_plus = true;\n     }\n \n   if (GET_CODE (disp) != UNSPEC)\n     return 0;\n \n-  /* Must be @GOT or @GOTOFF.  */\n   switch (XINT (disp, 1))\n     {\n     case UNSPEC_GOT:\n+      if (saw_plus)\n+\treturn false;\n       return GET_CODE (XVECEXP (disp, 0, 0)) == SYMBOL_REF;\n     case UNSPEC_GOTOFF:\n       return local_symbolic_operand (XVECEXP (disp, 0, 0), Pmode);\n+    case UNSPEC_GOTTPOFF:\n+      if (saw_plus)\n+\treturn false;\n+      return initial_exec_symbolic_operand (XVECEXP (disp, 0, 0), Pmode);\n+    case UNSPEC_NTPOFF:\n+      /* ??? Could support offset here.  */\n+      if (saw_plus)\n+\treturn false;\n+      return local_exec_symbolic_operand (XVECEXP (disp, 0, 0), Pmode);\n+    case UNSPEC_DTPOFF:\n+      /* ??? Could support offset here.  */\n+      if (saw_plus)\n+\treturn false;\n+      return local_dynamic_symbolic_operand (XVECEXP (disp, 0, 0), Pmode);\n     }\n     \n   return 0;\n@@ -4873,12 +5089,6 @@ legitimate_address_p (mode, addr, strict)\n     {\n       reason_rtx = disp;\n \n-      if (!CONSTANT_ADDRESS_P (disp))\n-\t{\n-\t  reason = \"displacement is not constant\";\n-\t  goto report_error;\n-\t}\n-\n       if (TARGET_64BIT)\n \t{\n \t  if (!x86_64_sign_extended_value (disp))\n@@ -4896,8 +5106,30 @@ legitimate_address_p (mode, addr, strict)\n \t    }\n \t}\n \n-      if (flag_pic && SYMBOLIC_CONST (disp))\n+      if (GET_CODE (disp) == CONST\n+\t  && GET_CODE (XEXP (disp, 0)) == UNSPEC)\n+\tswitch (XINT (XEXP (disp, 0), 1))\n+\t  {\n+\t  case UNSPEC_GOT:\n+\t  case UNSPEC_GOTOFF:\n+\t  case UNSPEC_GOTPCREL:\n+\t    if (!flag_pic)\n+\t      abort ();\n+\t    goto is_legitimate_pic;\n+\n+\t  case UNSPEC_GOTTPOFF:\n+\t  case UNSPEC_NTPOFF:\n+\t  case UNSPEC_DTPOFF:\n+\t    break;\n+\n+\t  default:\n+\t    reason = \"invalid address unspec\";\n+\t    goto report_error;\n+\t  }\n+\n+      else if (flag_pic && SYMBOLIC_CONST (disp))\n \t{\n+\tis_legitimate_pic:\n \t  if (TARGET_64BIT && (index || base))\n \t    {\n \t      reason = \"non-constant pic memory reference\";\n@@ -4940,6 +5172,11 @@ legitimate_address_p (mode, addr, strict)\n \t      goto report_error;\n \t    }\n \t}\n+      else if (!CONSTANT_ADDRESS_P (disp))\n+\t{\n+\t  reason = \"displacement is not constant\";\n+\t  goto report_error;\n+\t}\n     }\n \n   /* Everything looks valid.  */\n@@ -5122,23 +5359,100 @@ legitimize_pic_address (orig, reg)\n   return new;\n }\n \n-/* If using PIC, mark a SYMBOL_REF for a non-global symbol so that we\n-   may access it directly in the GOT.  */\n-\n static void\n-i386_encode_section_info (decl, first)\n+ix86_encode_section_info (decl, first)\n      tree decl;\n      int first ATTRIBUTE_UNUSED;\n {\n+  bool local_p = (*targetm.binds_local_p) (decl);\n+  rtx rtl, symbol;\n+\n+  rtl = DECL_P (decl) ? DECL_RTL (decl) : TREE_CST_RTL (decl);\n+  if (GET_CODE (rtl) != MEM)\n+    return;\n+  symbol = XEXP (rtl, 0);\n+  if (GET_CODE (symbol) != SYMBOL_REF)\n+    return;\n+\n+  /* For basic x86, if using PIC, mark a SYMBOL_REF for a non-global\n+     symbol so that we may access it directly in the GOT.  */\n+\n   if (flag_pic)\n+    SYMBOL_REF_FLAG (symbol) = local_p;\n+\n+  /* For ELF, encode thread-local data with %[GLil] for \"global dynamic\",\n+     \"local dynamic\", \"initial exec\" or \"local exec\" TLS models\n+     respectively.  */\n+\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL (decl))\n     {\n-      rtx rtl = DECL_P (decl) ? DECL_RTL (decl) : TREE_CST_RTL (decl);\n+      const char *symbol_str;\n+      char *newstr;\n+      size_t len;\n+      enum tls_model kind;\n+\n+      if (!flag_pic)\n+\t{\n+\t  if (local_p)\n+\t    kind = TLS_MODEL_LOCAL_EXEC;\n+\t  else\n+\t    kind = TLS_MODEL_INITIAL_EXEC;\n+\t}\n+      /* Local dynamic is inefficient when we're not combining the\n+\t parts of the address.  */\n+      else if (optimize && local_p)\n+\tkind = TLS_MODEL_LOCAL_DYNAMIC;\n+      else\n+\tkind = TLS_MODEL_GLOBAL_DYNAMIC;\n+      if (kind < flag_tls_default)\n+\tkind = flag_tls_default;\n+\n+      symbol_str = XSTR (symbol, 0);\n \n-      if (GET_CODE (rtl) == MEM && GET_CODE (XEXP (rtl, 0)) == SYMBOL_REF)\n-\tSYMBOL_REF_FLAG (XEXP (rtl, 0)) = (*targetm.binds_local_p) (decl);\n+      if (symbol_str[0] == '%')\n+\t{\n+\t  if (symbol_str[1] == tls_model_chars[kind])\n+\t    return;\n+\t  symbol_str += 2;\n+\t}\n+      len = strlen (symbol_str) + 1;\n+      newstr = alloca (len + 2);\n+\n+      newstr[0] = '%';\n+      newstr[1] = tls_model_chars[kind];\n+      memcpy (newstr + 2, symbol_str, len);\n+\n+      XSTR (symbol, 0) = ggc_alloc_string (newstr, len + 2 - 1);\n     }\n }\n+\n+/* Undo the above when printing symbol names.  */\n+\n+static const char *\n+ix86_strip_name_encoding (str)\n+     const char *str;\n+{\n+  if (str[0] == '%')\n+    str += 2;\n+  if (str [0] == '*')\n+    str += 1;\n+  return str;\n+}\n \f\n+/* Load the thread pointer into a register.  */\n+\n+static rtx\n+get_thread_pointer ()\n+{\n+  rtx tp;\n+\n+  tp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx), UNSPEC_TP);\n+  tp = gen_rtx_CONST (Pmode, tp);\n+  tp = force_reg (Pmode, tp);\n+\n+  return tp;\n+}\n+  \n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.\n    This macro is used in only one place: `memory_address' in explow.c.\n@@ -5176,6 +5490,85 @@ legitimize_address (x, oldx, mode)\n       debug_rtx (x);\n     }\n \n+  /* Note that tls_symbolic_operand return is biased by 1 to return true.  */\n+  log = tls_symbolic_operand (x, mode);\n+  if (log)\n+    {\n+      rtx dest, base, off, pic;\n+\n+      switch (log - 1)\n+        {\n+        case TLS_MODEL_GLOBAL_DYNAMIC:\n+\t  dest = gen_reg_rtx (Pmode);\n+          emit_insn (gen_tls_global_dynamic (dest, x));\n+\t  break;\n+\n+        case TLS_MODEL_LOCAL_DYNAMIC:\n+\t  base = gen_reg_rtx (Pmode);\n+\t  emit_insn (gen_tls_local_dynamic_base (base));\n+\n+\t  off = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), UNSPEC_DTPOFF);\n+\t  off = gen_rtx_CONST (Pmode, off);\n+\n+\t  return gen_rtx_PLUS (Pmode, base, off);\n+\n+        case TLS_MODEL_INITIAL_EXEC:\n+\t  if (flag_pic)\n+\t    {\n+\t      current_function_uses_pic_offset_table = 1;\n+\t      pic = pic_offset_table_rtx;\n+\t    }\n+\t  else\n+\t    {\n+\t      pic = gen_reg_rtx (Pmode);\n+\t      emit_insn (gen_set_got (pic));\n+\t    }\n+\n+\t  base = get_thread_pointer ();\n+\n+\t  off = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x), UNSPEC_GOTTPOFF);\n+\t  off = gen_rtx_CONST (Pmode, off);\n+\t  off = gen_rtx_PLUS (Pmode, pic, off);\n+\t  off = gen_rtx_MEM (Pmode, off);\n+\t  RTX_UNCHANGING_P (off) = 1;\n+\t  set_mem_alias_set (off, ix86_GOT_alias_set ());\n+\n+\t  /* Damn Sun for specifing a set of dynamic relocations without\n+\t     considering the two-operand nature of the architecture!\n+\t     We'd be much better off with a \"GOTNTPOFF\" relocation that\n+\t     already contained the negated constant.  */\n+\t  /* ??? Using negl and reg+reg addressing appears to be a lose\n+\t     size-wise.  The negl is two bytes, just like the extra movl\n+\t     incurred by the two-operand subl, but reg+reg addressing\n+\t     uses the two-byte modrm form, unlike plain reg.  */\n+\n+\t  dest = gen_reg_rtx (Pmode);\n+\t  emit_insn (gen_subsi3 (dest, base, off));\n+\t  break;\n+\n+        case TLS_MODEL_LOCAL_EXEC:\n+\t  base = get_thread_pointer ();\n+\n+\t  off = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, x),\n+\t\t\t\tTARGET_GNU_TLS ? UNSPEC_NTPOFF : UNSPEC_TPOFF);\n+\t  off = gen_rtx_CONST (Pmode, off);\n+\n+\t  if (TARGET_GNU_TLS)\n+\t    return gen_rtx_PLUS (Pmode, base, off);\n+\t  else\n+\t    {\n+\t      dest = gen_reg_rtx (Pmode);\n+\t      emit_insn (gen_subsi3 (dest, base, off));\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+        }\n+\n+      return dest;\n+    }\n+\n   if (flag_pic && SYMBOLIC_CONST (x))\n     return legitimize_pic_address (x, 0);\n \n@@ -5425,12 +5818,21 @@ output_pic_addr_const (file, x, code)\n \tcase UNSPEC_GOTOFF:\n \t  fputs (\"@GOTOFF\", file);\n \t  break;\n-\tcase UNSPEC_PLT:\n-\t  fputs (\"@PLT\", file);\n-\t  break;\n \tcase UNSPEC_GOTPCREL:\n \t  fputs (\"@GOTPCREL(%RIP)\", file);\n \t  break;\n+\tcase UNSPEC_GOTTPOFF:\n+\t  fputs (\"@GOTTPOFF\", file);\n+\t  break;\n+\tcase UNSPEC_TPOFF:\n+\t  fputs (\"@TPOFF\", file);\n+\t  break;\n+\tcase UNSPEC_NTPOFF:\n+\t  fputs (\"@NTPOFF\", file);\n+\t  break;\n+\tcase UNSPEC_DTPOFF:\n+\t  fputs (\"@DTPOFF\", file);\n+\t  break;\n \tdefault:\n \t  output_operand_lossage (\"invalid UNSPEC as operand\");\n \t  break;\n@@ -5720,6 +6122,43 @@ print_reg (x, code, file)\n     }\n }\n \n+/* Locate some local-dynamic symbol still in use by this function\n+   so that we can print its name in some tls_local_dynamic_base\n+   pattern.  */\n+\n+static const char *\n+get_some_local_dynamic_name ()\n+{\n+  rtx insn;\n+\n+  if (cfun->machine->some_ld_name)\n+    return cfun->machine->some_ld_name;\n+\n+  for (insn = get_insns (); insn ; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn)\n+\t&& for_each_rtx (&PATTERN (insn), get_some_local_dynamic_name_1, 0))\n+      return cfun->machine->some_ld_name;\n+\n+  abort ();\n+}\n+\n+static int\n+get_some_local_dynamic_name_1 (px, data)\n+     rtx *px;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  rtx x = *px;\n+\n+  if (GET_CODE (x) == SYMBOL_REF\n+      && local_dynamic_symbolic_operand (x, Pmode))\n+    {\n+      cfun->machine->some_ld_name = XSTR (x, 0);\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n /* Meaning of CODE:\n    L,W,B,Q,S,T -- print the opcode suffix for specified size of operand.\n    C -- print opcode suffix for set/cmov insn.\n@@ -5744,6 +6183,7 @@ print_reg (x, code, file)\n    D -- print condition for SSE cmp instruction.\n    P -- if PIC, print an @PLT suffix.\n    X -- don't print any sort of PIC '@' suffix for a symbol.\n+   & -- print some in-use local-dynamic symbol name.\n  */\n \n void\n@@ -5761,6 +6201,10 @@ print_operand (file, x, code)\n \t    putc ('*', file);\n \t  return;\n \n+\tcase '&':\n+\t  assemble_name (file, get_some_local_dynamic_name ());\n+\t  return;\n+\n \tcase 'A':\n \t  if (ASSEMBLER_DIALECT == ASM_ATT)\n \t    putc ('*', file);\n@@ -6090,6 +6534,18 @@ print_operand (file, x, code)\n       REAL_VALUE_TO_DECIMAL (r, \"%.22e\", dstr);\n       fprintf (file, \"%s\", dstr);\n     }\n+\n+  else if (GET_CODE (x) == CONST\n+\t   && GET_CODE (XEXP (x, 0)) == UNSPEC\n+\t   && XINT (XEXP (x, 0), 1) == UNSPEC_TP)\n+    {\n+      if (ASSEMBLER_DIALECT == ASM_INTEL)\n+\tfputs (\"DWORD PTR \", file);\n+      if (ASSEMBLER_DIALECT == ASM_ATT || USER_LABEL_PREFIX[0] == 0)\n+\tputc ('%', file);\n+      fputs (\"gs:0\", file);\n+    }\n+\n   else\n     {\n       if (code != 'P')\n@@ -6238,6 +6694,43 @@ print_operand_address (file, addr)\n \t}\n     }\n }\n+\n+bool\n+output_addr_const_extra (file, x)\n+     FILE *file;\n+     rtx x;\n+{\n+  rtx op;\n+\n+  if (GET_CODE (x) != UNSPEC)\n+    return false;\n+\n+  op = XVECEXP (x, 0, 0);\n+  switch (XINT (x, 1))\n+    {\n+    case UNSPEC_GOTTPOFF:\n+      output_addr_const (file, op);\n+      fputs (\"@GOTTPOFF\", file);\n+      break;\n+    case UNSPEC_TPOFF:\n+      output_addr_const (file, op);\n+      fputs (\"@TPOFF\", file);\n+      break;\n+    case UNSPEC_NTPOFF:\n+      output_addr_const (file, op);\n+      fputs (\"@NTPOFF\", file);\n+      break;\n+    case UNSPEC_DTPOFF:\n+      output_addr_const (file, op);\n+      fputs (\"@DTPOFF\", file);\n+      break;\n+\n+    default:\n+      return false;\n+    }\n+\n+  return true;\n+}\n \f\n /* Split one or more DImode RTL references into pairs of SImode\n    references.  The RTL can be REG, offsettable MEM, integer constant, or\n@@ -6775,51 +7268,117 @@ ix86_expand_clear (dest)\n   emit_insn (tmp);\n }\n \n+/* X is an unchanging MEM.  If it is a constant pool reference, return\n+   the constant pool rtx, else NULL.  */\n+\n+static rtx\n+maybe_get_pool_constant (x)\n+     rtx x;\n+{\n+  x = XEXP (x, 0);\n+\n+  if (flag_pic)\n+    {\n+      if (GET_CODE (x) != PLUS)\n+\treturn NULL_RTX;\n+      if (XEXP (x, 0) != pic_offset_table_rtx)\n+\treturn NULL_RTX;\n+      x = XEXP (x, 1);\n+      if (GET_CODE (x) != CONST)\n+\treturn NULL_RTX;\n+      x = XEXP (x, 0);\n+      if (GET_CODE (x) != UNSPEC)\n+\treturn NULL_RTX;\n+      if (XINT (x, 1) != UNSPEC_GOTOFF)\n+\treturn NULL_RTX;\n+      x = XVECEXP (x, 0, 0);\n+    }\n+\n+  if (GET_CODE (x) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (x))\n+    return get_pool_constant (x);\n+\n+  return NULL_RTX;\n+}\n+\n void\n ix86_expand_move (mode, operands)\n      enum machine_mode mode;\n      rtx operands[];\n {\n   int strict = (reload_in_progress || reload_completed);\n-  rtx insn;\n+  rtx insn, op0, op1, tmp;\n+\n+  op0 = operands[0];\n+  op1 = operands[1];\n+\n+  /* ??? We have a slight problem.  We need to say that tls symbols are\n+     not legitimate constants so that reload does not helpfully reload\n+     these constants from a REG_EQUIV, which we cannot handle.  (Recall\n+     that general- and local-dynamic address resolution requires a\n+     function call.)\n \n-  if (flag_pic && mode == Pmode && symbolic_operand (operands[1], Pmode))\n+     However, if we say that tls symbols are not legitimate constants,\n+     then emit_move_insn helpfully drop them into the constant pool.\n+\n+     It is far easier to work around emit_move_insn than reload.  Recognize\n+     the MEM that we would have created and extract the symbol_ref.  */\n+\n+  if (mode == Pmode\n+      && GET_CODE (op1) == MEM\n+      && RTX_UNCHANGING_P (op1))\n     {\n-      /* Emit insns to move operands[1] into operands[0].  */\n+      tmp = maybe_get_pool_constant (op1);\n+      /* Note that we only care about symbolic constants here, which\n+\t unlike CONST_INT will always have a proper mode.  */\n+      if (tmp && GET_MODE (tmp) == Pmode)\n+\top1 = tmp;\n+    }\n \n-      if (GET_CODE (operands[0]) == MEM)\n-\toperands[1] = force_reg (Pmode, operands[1]);\n+  if (tls_symbolic_operand (op1, Pmode))\n+    {\n+      op1 = legitimize_address (op1, op1, VOIDmode);\n+      if (GET_CODE (op0) == MEM)\n+\t{\n+\t  tmp = gen_reg_rtx (mode);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, tmp, op1));\n+\t  op1 = tmp;\n+\t}\n+    }\n+  else if (flag_pic && mode == Pmode && symbolic_operand (op1, Pmode))\n+    {\n+      if (GET_CODE (op0) == MEM)\n+\top1 = force_reg (Pmode, op1);\n       else\n \t{\n-\t  rtx temp = operands[0];\n+\t  rtx temp = op0;\n \t  if (GET_CODE (temp) != REG)\n \t    temp = gen_reg_rtx (Pmode);\n-\t  temp = legitimize_pic_address (operands[1], temp);\n-\t  if (temp == operands[0])\n+\t  temp = legitimize_pic_address (op1, temp);\n+\t  if (temp == op0)\n \t    return;\n-\t  operands[1] = temp;\n+\t  op1 = temp;\n \t}\n     }\n   else\n     {\n-      if (GET_CODE (operands[0]) == MEM\n+      if (GET_CODE (op0) == MEM\n \t  && (PUSH_ROUNDING (GET_MODE_SIZE (mode)) != GET_MODE_SIZE (mode)\n-\t      || !push_operand (operands[0], mode))\n-\t  && GET_CODE (operands[1]) == MEM)\n-\toperands[1] = force_reg (mode, operands[1]);\n+\t      || !push_operand (op0, mode))\n+\t  && GET_CODE (op1) == MEM)\n+\top1 = force_reg (mode, op1);\n \n-      if (push_operand (operands[0], mode)\n-\t  && ! general_no_elim_operand (operands[1], mode))\n-\toperands[1] = copy_to_mode_reg (mode, operands[1]);\n+      if (push_operand (op0, mode)\n+\t  && ! general_no_elim_operand (op1, mode))\n+\top1 = copy_to_mode_reg (mode, op1);\n \n       /* Force large constants in 64bit compilation into register\n \t to get them CSEed.  */\n       if (TARGET_64BIT && mode == DImode\n-\t  && immediate_operand (operands[1], mode)\n-\t  && !x86_64_zero_extended_value (operands[1])\n-\t  && !register_operand (operands[0], mode)\n+\t  && immediate_operand (op1, mode)\n+\t  && !x86_64_zero_extended_value (op1)\n+\t  && !register_operand (op0, mode)\n \t  && optimize && !reload_completed && !reload_in_progress)\n-\toperands[1] = copy_to_mode_reg (mode, operands[1]);\n+\top1 = copy_to_mode_reg (mode, op1);\n \n       if (FLOAT_MODE_P (mode))\n \t{\n@@ -6829,13 +7388,13 @@ ix86_expand_move (mode, operands)\n \n \t  if (strict)\n \t    ;\n-\t  else if (GET_CODE (operands[1]) == CONST_DOUBLE\n-\t\t   && register_operand (operands[0], mode))\n-\t    operands[1] = validize_mem (force_const_mem (mode, operands[1]));\n+\t  else if (GET_CODE (op1) == CONST_DOUBLE\n+\t\t   && register_operand (op0, mode))\n+\t    op1 = validize_mem (force_const_mem (mode, op1));\n \t}\n     }\n \n-  insn = gen_rtx_SET (VOIDmode, operands[0], operands[1]);\n+  insn = gen_rtx_SET (VOIDmode, op0, op1);\n \n   emit_insn (insn);\n }\n@@ -8684,13 +9243,14 @@ ix86_split_to_parts (operand, parts, mode)\n   if (size < 2 || size > 3)\n     abort ();\n \n-  /* Optimize constant pool reference to immediates.  This is used by fp moves,\n-     that force all constants to memory to allow combining.  */\n-\n-  if (GET_CODE (operand) == MEM\n-      && GET_CODE (XEXP (operand, 0)) == SYMBOL_REF\n-      && CONSTANT_POOL_ADDRESS_P (XEXP (operand, 0)))\n-    operand = get_pool_constant (XEXP (operand, 0));\n+  /* Optimize constant pool reference to immediates.  This is used by fp\n+     moves, that force all constants to memory to allow combining.  */\n+  if (GET_CODE (operand) == MEM && RTX_UNCHANGING_P (operand))\n+    {\n+      rtx tmp = maybe_get_pool_constant (operand);\n+      if (tmp)\n+\toperand = tmp;\n+    }\n \n   if (GET_CODE (operand) == MEM && !offsettable_memref_p (operand))\n     {\n@@ -9993,6 +10553,24 @@ assign_386_stack_local (mode, n)\n \n   return ix86_stack_locals[(int) mode][n];\n }\n+\n+/* Construct the SYMBOL_REF for the tls_get_addr function.  */\n+\n+rtx\n+ix86_tls_get_addr ()\n+{\n+  static rtx symbol;\n+\n+  if (!symbol)\n+    {\n+      symbol = gen_rtx_SYMBOL_REF (Pmode, (TARGET_GNU_TLS\n+\t\t\t\t\t   ? \"___tls_get_addr\"\n+\t\t\t\t\t   : \"__tls_get_addr\"));\n+      ggc_add_rtx_root (&symbol, 1);\n+    }\n+\n+  return symbol;\n+}\n \f\n /* Calculate the length of the memory address in the instruction\n    encoding.  Does not include the one-byte modrm, opcode, or prefix.  */"}, {"sha": "59463704d0b44bc8e64504131c7f3f49b56a5aea", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f996902d097063cdb85bbb545e42fe099ca637b8/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f996902d097063cdb85bbb545e42fe099ca637b8/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=f996902d097063cdb85bbb545e42fe099ca637b8", "patch": "@@ -282,6 +282,9 @@ extern int x86_prefetch_sse;\n \n #define TARGET_RED_ZONE (!(target_flags & MASK_NO_RED_ZONE))\n \n+#define TARGET_GNU_TLS (ix86_tls_dialect == TLS_DIALECT_GNU)\n+#define TARGET_SUN_TLS (ix86_tls_dialect == TLS_DIALECT_SUN)\n+\n /* WARNING: Do not mark empty strings for translation, as calling\n             gettext on an empty string does NOT return an empty\n             string. */\n@@ -426,6 +429,8 @@ extern int x86_prefetch_sse;\n     \"\" /* Undocumented. */ },\t\t\t\t\t\\\n   { \"asm=\", &ix86_asm_string,\t\t\t\t\t\\\n     N_(\"Use given assembler dialect\") },\t\t\t\\\n+  { \"tls-dialect=\", &ix86_tls_dialect_string,\t\t\t\\\n+    N_(\"Use given thread-local storage dialect\") },\t\t\\\n   SUBTARGET_OPTIONS\t\t\t\t\t\t\\\n }\n \n@@ -1876,15 +1881,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define MAX_REGS_PER_ADDRESS 2\n \n-#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\\\n-   || GET_CODE (X) == CONST_DOUBLE)\n+#define CONSTANT_ADDRESS_P(X)  constant_address_p (X)\n \n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n-#define LEGITIMATE_CONSTANT_P(X) 1\n+#define LEGITIMATE_CONSTANT_P(X)  legitimate_constant_p (X)\n \n #ifdef REG_OK_STRICT\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n@@ -1947,9 +1949,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    when generating PIC code.  It is given that flag_pic is on and \n    that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n-#define LEGITIMATE_PIC_OPERAND_P(X)\t\t\\\n-  (! SYMBOLIC_CONST (X)\t\t\t\t\\\n-   || legitimate_pic_address_disp_p (X))\n+#define LEGITIMATE_PIC_OPERAND_P(X) legitimate_pic_operand_p (X)\n \n #define SYMBOLIC_CONST(X)\t\\\n   (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\t\\\n@@ -2392,7 +2392,20 @@ enum ix86_builtins\n   IX86_BUILTIN_MAX\n };\n \f\n-#define TARGET_ENCODE_SECTION_INFO  i386_encode_section_info\n+#define TARGET_ENCODE_SECTION_INFO  ix86_encode_section_info\n+#define TARGET_STRIP_NAME_ENCODING  ix86_strip_name_encoding\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    const char *xname = (NAME);\t\t\t\\\n+    if (xname[0] == '%')\t\t\t\\\n+      xname += 2;\t\t\t\t\\\n+    if (xname[0] == '*')\t\t\t\\\n+      xname += 1;\t\t\t\t\\\n+    else\t\t\t\t\t\\\n+      fputs (user_label_prefix, FILE);\t\t\\\n+    fputs (xname, FILE);\t\t\t\\\n+  } while (0)\n \n /* The `FINALIZE_PIC' macro serves as a hook to emit these special\n    codes once the function is being compiled into assembly code, but\n@@ -3047,7 +3060,7 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n    print_operand function.  */\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CODE) \\\n-  ((CODE) == '*' || (CODE) == '+')\n+  ((CODE) == '*' || (CODE) == '+' || (CODE) == '&')\n \n /* Print the name of a register based on its machine mode and number.\n    If CODE is 'w', pretend the mode is HImode.\n@@ -3066,6 +3079,12 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n #define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n   print_operand_address ((FILE), (ADDR))\n \n+#define OUTPUT_ADDR_CONST_EXTRA(FILE, X, FAIL)\t\\\n+do {\t\t\t\t\t\t\\\n+  if (! output_addr_const_extra (FILE, (X)))\t\\\n+    goto FAIL;\t\t\t\t\t\\\n+} while (0);\n+\n /* Print the name of a register for based on its machine mode and number.\n    This macro is used to print debugging output.\n    This macro is different from PRINT_REG in that it may be used in\n@@ -3195,7 +3214,12 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n   {\"memory_displacement_operand\", {MEM}},\t\t\t\t\\\n   {\"cmpsi_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\\\n \t\t     LABEL_REF, SUBREG, REG, MEM, AND}},\t\t\\\n-  {\"long_memory_operand\", {MEM}},\n+  {\"long_memory_operand\", {MEM}},\t\t\t\t\t\\\n+  {\"tls_symbolic_operand\", {SYMBOL_REF}},\t\t\t\t\\\n+  {\"global_dynamic_symbolic_operand\", {SYMBOL_REF}},\t\t\t\\\n+  {\"local_dynamic_symbolic_operand\", {SYMBOL_REF}},\t\t\t\\\n+  {\"initial_exec_symbolic_operand\", {SYMBOL_REF}},\t\t\t\\\n+  {\"local_exec_symbolic_operand\", {SYMBOL_REF}},\n \n /* A list of predicates that do special things with modes, and so\n    should not elicit warnings for VOIDmode match_operand.  */\n@@ -3233,6 +3257,15 @@ enum fpmath_unit\n extern enum fpmath_unit ix86_fpmath;\n extern const char *ix86_fpmath_string;\n \n+enum tls_dialect\n+{\n+  TLS_DIALECT_GNU,\n+  TLS_DIALECT_SUN\n+};\n+\n+extern enum tls_dialect ix86_tls_dialect;\n+extern const char *ix86_tls_dialect_string;\n+\n enum cmodel {\n   CM_32,\t/* The traditional 32-bit ABI.  */\n   CM_SMALL,\t/* Assumes all code and data fits in the low 31 bits.  */"}, {"sha": "2d19645f3a2bf57e2d227a43f5f9e063bbebbc8b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 150, "deletions": 16, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f996902d097063cdb85bbb545e42fe099ca637b8/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f996902d097063cdb85bbb545e42fe099ca637b8/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=f996902d097063cdb85bbb545e42fe099ca637b8", "patch": "@@ -53,23 +53,36 @@\n ;; UNSPEC usage:\n \n (define_constants\n-  [(UNSPEC_SCAS\t\t\t0)\n-   (UNSPEC_SIN\t\t\t1)\n-   (UNSPEC_COS\t\t\t2)\n-   (UNSPEC_STACK_PROBE\t\t3)\n-   (UNSPEC_STACK_ALLOC\t\t4)\n-   (UNSPEC_BSF\t\t\t5)\n-   (UNSPEC_GOT\t\t\t6)\n-   (UNSPEC_GOTOFF\t\t7)\n-   (UNSPEC_PLT\t\t\t8)\n-   (UNSPEC_FNSTSW\t\t9)\n-   (UNSPEC_SAHF\t\t\t10)\n-   (UNSPEC_FSTCW\t\t11)\n-   (UNSPEC_ADD_CARRY\t\t12)\n+  [; Relocation specifiers\n+   (UNSPEC_GOT\t\t\t0)\n+   (UNSPEC_GOTOFF\t\t1)\n+   (UNSPEC_GOTPCREL\t\t2)\n+   (UNSPEC_GOTTPOFF\t\t3)\n+   (UNSPEC_TPOFF\t\t4)\n+   (UNSPEC_NTPOFF\t\t5)\n+   (UNSPEC_DTPOFF\t\t6)\n+\n+   ; Prologue support\n+   (UNSPEC_STACK_PROBE\t\t10)\n+   (UNSPEC_STACK_ALLOC\t\t11)\n+   (UNSPEC_SET_GOT\t\t12)\n    (UNSPEC_SSE_PROLOGUE_SAVE\t13)\n-   (UNSPEC_FLDCW\t\t14)\n-   (UNSPEC_GOTPCREL\t\t15)\n-   (UNSPEC_SET_GOT\t\t16)\n+\n+   ; TLS support\n+   (UNSPEC_TP\t\t\t15)\n+   (UNSPEC_TLS_GD\t\t16)\n+   (UNSPEC_TLS_LD_BASE\t\t17)\n+\n+   ; Other random patterns\n+   (UNSPEC_SCAS\t\t\t20)\n+   (UNSPEC_SIN\t\t\t21)\n+   (UNSPEC_COS\t\t\t22)\n+   (UNSPEC_BSF\t\t\t23)\n+   (UNSPEC_FNSTSW\t\t24)\n+   (UNSPEC_SAHF\t\t\t25)\n+   (UNSPEC_FSTCW\t\t26)\n+   (UNSPEC_ADD_CARRY\t\t27)\n+   (UNSPEC_FLDCW\t\t28)\n \n    ; For SSE/MMX support:\n    (UNSPEC_FIX\t\t\t30)\n@@ -13330,6 +13343,127 @@\n ;; ffshi2 is not useful -- 4 word prefix ops are needed, which is larger\n ;; and slower than the two-byte movzx insn needed to do the work in SImode.\n \f\n+;; Thread-local storage patterns for ELF.\n+;;\n+;; Note that these code sequences must appear exactly as shown\n+;; in order to allow linker relaxation.\n+\n+(define_insn \"*tls_global_dynamic_gnu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:SI 2 \"tls_symbolic_operand\" \"\")\n+\t\t    (match_operand:SI 3 \"call_insn_operand\" \"\")]\n+\t\t    UNSPEC_TLS_GD))\n+   (clobber (match_scratch:SI 4 \"=d\"))\n+   (clobber (match_scratch:SI 5 \"=c\"))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_GNU_TLS\"\n+  \"lea{l}\\t{%a2@TLSGD(,%1,1), %0|%0, %a2@TLSGD[%1*1]}\\;call\\t%P3\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"12\")])\n+\n+(define_insn \"*tls_global_dynamic_sun\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t    (match_operand:SI 2 \"tls_symbolic_operand\" \"\")\n+\t\t    (match_operand:SI 3 \"call_insn_operand\" \"\")]\n+\t\t    UNSPEC_TLS_GD))\n+   (clobber (match_scratch:SI 4 \"=d\"))\n+   (clobber (match_scratch:SI 5 \"=c\"))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_SUN_TLS\"\n+  \"lea{l}\\t{%a2@DTLNDX(%1), %4|%4, %a2@DTLNDX[%1]}\n+\tpush{l}\\t%4\\;call\\t%a2@TLSPLT\\;pop{l}\\t%4\\;nop\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"14\")])\n+\n+(define_expand \"tls_global_dynamic\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (unspec:SI\n+\t\t    [(match_dup 2)\n+\t\t     (match_operand:SI 1 \"tls_symbolic_operand\" \"\")\n+\t\t     (match_dup 3)]\n+\t\t    UNSPEC_TLS_GD))\n+\t      (clobber (match_scratch:SI 4 \"\"))\n+\t      (clobber (match_scratch:SI 5 \"\"))\n+\t      (clobber (reg:CC 17))])]\n+  \"\"\n+{\n+  if (!flag_pic)\n+    abort ();\n+  current_function_uses_pic_offset_table = 1;\n+  operands[2] = pic_offset_table_rtx;\n+  operands[3] = ix86_tls_get_addr ();\n+})\n+\n+(define_insn \"*tls_local_dynamic_base_gnu\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n+                    (match_operand:SI 2 \"call_insn_operand\" \"\")]\n+\t\t   UNSPEC_TLS_LD_BASE))\n+   (clobber (match_scratch:SI 3 \"=d\"))\n+   (clobber (match_scratch:SI 4 \"=c\"))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_GNU_TLS\"\n+  \"lea{l}\\t{%&@TLSLDM(%1), %0|%0, %&@TLSLDM[%1]}\\;call\\t%P2\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"11\")])\n+\n+(define_insn \"*tls_local_dynamic_base_sun\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n+                    (match_operand:SI 2 \"call_insn_operand\" \"\")]\n+\t\t   UNSPEC_TLS_LD_BASE))\n+   (clobber (match_scratch:SI 3 \"=d\"))\n+   (clobber (match_scratch:SI 4 \"=c\"))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_SUN_TLS\"\n+  \"lea{l}\\t{%&@TMDNX(%1), %3|%3, %&@TMDNX[%1]}\n+\tpush{l}\\t%3\\;call\\t%&@TLSPLT\\;pop{l}\\t%3\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"13\")])\n+\n+(define_expand \"tls_local_dynamic_base\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (unspec:SI [(match_dup 1) (match_dup 2)]\n+\t\t\t      UNSPEC_TLS_LD_BASE))\n+\t      (clobber (match_scratch:SI 3 \"\"))\n+\t      (clobber (match_scratch:SI 4 \"\"))\n+\t      (clobber (reg:CC 17))])]\n+  \"\"\n+{\n+  if (!flag_pic)\n+    abort ();\n+  current_function_uses_pic_offset_table = 1;\n+  operands[1] = pic_offset_table_rtx;\n+  operands[2] = ix86_tls_get_addr ();\n+})\n+\n+;; Local dynamic of a single variable is a lose.  Show combine how\n+;; to convert that back to global dynamic.\n+\n+(define_insn_and_split \"*tls_local_dynamic_once\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(plus:SI (unspec:SI [(match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t\t     (match_operand:SI 2 \"call_insn_operand\" \"\")]\n+\t\t\t    UNSPEC_TLS_LD_BASE)\n+\t\t (const:SI (unspec:SI\n+\t\t\t    [(match_operand:SI 3 \"tls_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_DTPOFF))))\n+   (clobber (match_scratch:SI 4 \"=d\"))\n+   (clobber (match_scratch:SI 5 \"=c\"))\n+   (clobber (reg:CC 17))]\n+  \"\"\n+  \"#\"\n+  \"\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (unspec:SI [(match_dup 1) (match_dup 3) (match_dup 2)]\n+\t\t\t      UNSPEC_TLS_GD))\n+\t      (clobber (match_dup 4))\n+\t      (clobber (match_dup 5))\n+\t      (clobber (reg:CC 17))])]\n+  \"\")\n+\f\n ;; These patterns match the binary 387 instructions for addM3, subM3,\n ;; mulM3 and divM3.  There are three patterns for each of DFmode and\n ;; SFmode.  The first is the normal insn, the second the same insn but"}, {"sha": "483178de2187308de8fdb789b0bc3e642ddef5ba", "filename": "gcc/configure", "status": "modified", "additions": 66, "deletions": 16, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f996902d097063cdb85bbb545e42fe099ca637b8/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f996902d097063cdb85bbb545e42fe099ca637b8/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=f996902d097063cdb85bbb545e42fe099ca637b8", "patch": "@@ -7244,7 +7244,7 @@ libgcc_visibility=$gcc_cv_as_hidden\n \n \n echo $ac_n \"checking assembler leb128 support\"\"... $ac_c\" 1>&6\n-echo \"configure:7228: checking assembler leb128 support\" >&5\n+echo \"configure:7248: checking assembler leb128 support\" >&5\n gcc_cv_as_leb128=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x; then\n   if test \"$gcc_cv_gas_major_version\" -eq 2 -a \"$gcc_cv_gas_minor_version\" -ge 11 -o \"$gcc_cv_gas_major_version\" -gt 2 && grep 'obj_format = elf' ../gas/Makefile > /dev/null; then\n@@ -7289,7 +7289,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_leb128\" 1>&6\n \n echo $ac_n \"checking assembler eh_frame optimization\"\"... $ac_c\" 1>&6\n-echo \"configure:7273: checking assembler eh_frame optimization\" >&5\n+echo \"configure:7293: checking assembler eh_frame optimization\" >&5\n gcc_cv_as_eh_frame=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x; then\n   if test \"$gcc_cv_gas_major_version\" -eq 2 -a \"$gcc_cv_gas_minor_version\" -ge 12 -o \"$gcc_cv_gas_major_version\" -gt 2 && grep 'obj_format = elf' ../gas/Makefile > /dev/null; then\n@@ -7370,7 +7370,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_eh_frame\" 1>&6\n \n echo $ac_n \"checking assembler section merging support\"\"... $ac_c\" 1>&6\n-echo \"configure:7354: checking assembler section merging support\" >&5\n+echo \"configure:7374: checking assembler section merging support\" >&5\n gcc_cv_as_shf_merge=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x; then\n   if test \"$gcc_cv_gas_major_version\" -eq 2 -a \"$gcc_cv_gas_minor_version\" -ge 12 -o \"$gcc_cv_gas_major_version\" -gt 2 && grep 'obj_format = elf' ../gas/Makefile > /dev/null; then\n@@ -7392,11 +7392,61 @@ EOF\n fi\n echo \"$ac_t\"\"$gcc_cv_as_shf_merge\" 1>&6\n \n+echo $ac_n \"checking assembler thread-local storage support\"\"... $ac_c\" 1>&6\n+echo \"configure:7397: checking assembler thread-local storage support\" >&5\n+gcc_cv_as_tls=no\n+conftest_s=\n+tls_first_major=\n+tls_first_minor=\n+case \"$target\" in\n+  i[34567]86-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\tmovl\t%gs:0, %eax\n+\tleal\tfoo@TLSGD(,%ebx,1), %eax\n+\tleal\tfoo@TLSLDM(%ebx), %eax\n+\tleal\tfoo@DTPOFF(%eax), %edx\n+\tmovl\tfoo@GOTTPOFF(%ebx), %eax\n+\tsubl\tfoo@GOTTPOFF(%ebx), %eax\n+\tmovl\t$foo@TPOFF, %eax\n+\tsubl\t$foo@TPOFF, %eax\n+\tleal\tfoo@NTPOFF(%ecx), %eax'\n+\ttls_first_major=2\n+\ttls_first_minor=13\n+\t;;\n+esac\n+if test -z \"$tls_first_major\"; then\n+  :\n+elif test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x\n+then\n+  if test \"$gcc_cv_gas_major_version\" -eq \"$tls_first_major\" \\\n+\t  -a \"$gcc_cv_gas_minor_version\" -ge \"$tls_first_minor\" \\\n+\t  -o \"$gcc_cv_gas_major_version\" -gt \"$tls_first_major\"; then\n+    gcc_cv_as_tls=yes\n+  fi\n+elif test x$gcc_cv_as != x; then\n+  echo \"$conftest_s\" > conftest.s\n+  if $gcc_cv_as --fatal-warnings -o conftest.o conftest.s > /dev/null 2>&1\n+  then\n+    gcc_cv_as_tls=yes\n+  fi\n+  rm -f conftest.s conftest.o\n+fi\n+if test \"$gcc_cv_as_tls\" = yes; then\n+  cat >> confdefs.h <<\\EOF\n+#define HAVE_AS_TLS 1\n+EOF\n+\n+fi\n+echo \"$ac_t\"\"$gcc_cv_as_tls\" 1>&6\n+\n case \"$target\" in\n   # All TARGET_ABI_OSF targets.\n   alpha*-*-osf* | alpha*-*-linux* | alpha*-*-*bsd*)\n     echo $ac_n \"checking assembler supports explicit relocations\"\"... $ac_c\" 1>&6\n-echo \"configure:7380: checking assembler supports explicit relocations\" >&5\n+echo \"configure:7450: checking assembler supports explicit relocations\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_explicit_relocs'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7446,7 +7496,7 @@ EOF\n     ;;\n   sparc*-*-*)\n     echo $ac_n \"checking assembler .register pseudo-op support\"\"... $ac_c\" 1>&6\n-echo \"configure:7430: checking assembler .register pseudo-op support\" >&5\n+echo \"configure:7500: checking assembler .register pseudo-op support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_register_pseudo_op'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7474,7 +7524,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler supports -relax\"\"... $ac_c\" 1>&6\n-echo \"configure:7458: checking assembler supports -relax\" >&5\n+echo \"configure:7528: checking assembler supports -relax\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_relax_opt'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7502,7 +7552,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler and linker support unaligned pc related relocs\"\"... $ac_c\" 1>&6\n-echo \"configure:7486: checking assembler and linker support unaligned pc related relocs\" >&5\n+echo \"configure:7556: checking assembler and linker support unaligned pc related relocs\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_sparc_ua_pcrel'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7529,7 +7579,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler and linker support unaligned pc related relocs against hidden symbols\"\"... $ac_c\" 1>&6\n-echo \"configure:7513: checking assembler and linker support unaligned pc related relocs against hidden symbols\" >&5\n+echo \"configure:7583: checking assembler and linker support unaligned pc related relocs against hidden symbols\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_sparc_ua_pcrel_hidden'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7570,7 +7620,7 @@ EOF\n \n     if test \"x$gcc_cv_as_flags64\" != xno; then\n \techo $ac_n \"checking for assembler offsetable %lo() support\"\"... $ac_c\" 1>&6\n-echo \"configure:7554: checking for assembler offsetable %lo() support\" >&5\n+echo \"configure:7624: checking for assembler offsetable %lo() support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_offsetable_lo10'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7610,7 +7660,7 @@ EOF\n \n   i[34567]86-*-* | x86_64-*-*)\n     echo $ac_n \"checking assembler instructions\"\"... $ac_c\" 1>&6\n-echo \"configure:7594: checking assembler instructions\" >&5\n+echo \"configure:7664: checking assembler instructions\" >&5\n     gcc_cv_as_instructions=\n     if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x; then\n       if test \"$gcc_cv_gas_major_version\" -eq 2 -a \"$gcc_cv_gas_minor_version\" -ge 9 -o \"$gcc_cv_gas_major_version\" -gt 2; then\n@@ -7637,7 +7687,7 @@ EOF\n     echo \"$ac_t\"\"$gcc_cv_as_instructions\" 1>&6\n \n     echo $ac_n \"checking assembler GOTOFF in data directives\"\"... $ac_c\" 1>&6\n-echo \"configure:7621: checking assembler GOTOFF in data directives\" >&5\n+echo \"configure:7691: checking assembler GOTOFF in data directives\" >&5\n     gcc_cv_as_gotoff_in_data=no\n     if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x\n     then\n@@ -7667,7 +7717,7 @@ EOF\n esac\n \n echo $ac_n \"checking assembler dwarf2 debug_line support\"\"... $ac_c\" 1>&6\n-echo \"configure:7651: checking assembler dwarf2 debug_line support\" >&5\n+echo \"configure:7721: checking assembler dwarf2 debug_line support\" >&5\n gcc_cv_as_dwarf2_debug_line=no\n # ??? Not all targets support dwarf2 debug_line, even within a version\n # of gas.  Moreover, we need to emit a valid instruction to trigger any\n@@ -7723,7 +7773,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_dwarf2_debug_line\" 1>&6\n \n echo $ac_n \"checking assembler --gdwarf2 support\"\"... $ac_c\" 1>&6\n-echo \"configure:7707: checking assembler --gdwarf2 support\" >&5\n+echo \"configure:7777: checking assembler --gdwarf2 support\" >&5\n gcc_cv_as_gdwarf2_flag=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x;\n then\n@@ -7752,7 +7802,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_gdwarf2_flag\" 1>&6\n \n echo $ac_n \"checking assembler --gstabs support\"\"... $ac_c\" 1>&6\n-echo \"configure:7736: checking assembler --gstabs support\" >&5\n+echo \"configure:7806: checking assembler --gstabs support\" >&5\n gcc_cv_as_gstabs_flag=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x;\n then\n@@ -7780,7 +7830,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_gstabs_flag\" 1>&6\n \n echo $ac_n \"checking linker PT_GNU_EH_FRAME support\"\"... $ac_c\" 1>&6\n-echo \"configure:7764: checking linker PT_GNU_EH_FRAME support\" >&5\n+echo \"configure:7834: checking linker PT_GNU_EH_FRAME support\" >&5\n gcc_cv_ld_eh_frame_hdr=no\n if test x$gcc_cv_gld_major_version != x -a x$gcc_cv_gld_minor_version != x; then\n   if test \"$gcc_cv_gld_major_version\" -eq 2 -a \"$gcc_cv_gld_minor_version\" -ge 12 -o \"$gcc_cv_gld_major_version\" -gt 2 && grep 'EMUL = elf' ../ld/Makefile > /dev/null; then\n@@ -7943,7 +7993,7 @@ fi\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:7927: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:7997: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\""}, {"sha": "8dcb671cf32a6c8a29cfe639c8a88309a10f84e5", "filename": "gcc/configure.in", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f996902d097063cdb85bbb545e42fe099ca637b8/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f996902d097063cdb85bbb545e42fe099ca637b8/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=f996902d097063cdb85bbb545e42fe099ca637b8", "patch": "@@ -1718,6 +1718,55 @@ if test x\"$gcc_cv_as_shf_merge\" = xyes; then\n fi\n AC_MSG_RESULT($gcc_cv_as_shf_merge)\n \n+AC_MSG_CHECKING(assembler thread-local storage support)\n+gcc_cv_as_tls=no\n+conftest_s=\n+tls_first_major=\n+tls_first_minor=\n+case \"$target\" in\n+changequote(,)dnl\n+  i[34567]86-*-*)\n+changequote([,])dnl\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\tmovl\t%gs:0, %eax\n+\tleal\tfoo@TLSGD(,%ebx,1), %eax\n+\tleal\tfoo@TLSLDM(%ebx), %eax\n+\tleal\tfoo@DTPOFF(%eax), %edx\n+\tmovl\tfoo@GOTTPOFF(%ebx), %eax\n+\tsubl\tfoo@GOTTPOFF(%ebx), %eax\n+\tmovl\t$foo@TPOFF, %eax\n+\tsubl\t$foo@TPOFF, %eax\n+\tleal\tfoo@NTPOFF(%ecx), %eax'\n+\ttls_first_major=2\n+\ttls_first_minor=13\n+\t;;\n+esac\n+if test -z \"$tls_first_major\"; then\n+  :\n+elif test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x\n+then\n+  if test \"$gcc_cv_gas_major_version\" -eq \"$tls_first_major\" \\\n+\t  -a \"$gcc_cv_gas_minor_version\" -ge \"$tls_first_minor\" \\\n+\t  -o \"$gcc_cv_gas_major_version\" -gt \"$tls_first_major\"; then\n+    gcc_cv_as_tls=yes\n+  fi\n+elif test x$gcc_cv_as != x; then\n+  echo \"$conftest_s\" > conftest.s\n+  if $gcc_cv_as --fatal-warnings -o conftest.o conftest.s > /dev/null 2>&1\n+  then\n+    gcc_cv_as_tls=yes\n+  fi\n+  rm -f conftest.s conftest.o\n+fi\n+if test \"$gcc_cv_as_tls\" = yes; then\n+  AC_DEFINE(HAVE_AS_TLS, 1,\n+\t    [Define if your assembler supports thread-local storage.])\n+fi\n+AC_MSG_RESULT($gcc_cv_as_tls)\n+\n case \"$target\" in\n   # All TARGET_ABI_OSF targets.\n   alpha*-*-osf* | alpha*-*-linux* | alpha*-*-*bsd*)"}]}