{"sha": "ea010af6b4d780261b791999e43ba056edce2af0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWEwMTBhZjZiNGQ3ODAyNjFiNzkxOTk5ZTQzYmEwNTZlZGNlMmFmMA==", "commit": {"author": {"name": "Will Schmidt", "email": "will_schmidt@vnet.ibm.com", "date": "2018-10-11T21:03:30Z"}, "committer": {"name": "Will Schmidt", "email": "willschm@gcc.gnu.org", "date": "2018-10-11T21:03:30Z"}, "message": "rs6000.c (map_to_integral_tree_type): New helper function.\n\n[gcc]\n\n2018-10-09  Will Schmidt <will_schmidt@vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (map_to_integral_tree_type): New helper\n\tfunction.\n\t(fold_mergeeo_helper): New helper function.\n\t(rs6000_gimple_fold_builtin): Add hooks for vec_mergee and vec_mergeo\n\tintrinsics.  Correct some whitespace indentation issues.\n\nFrom-SVN: r265063", "tree": {"sha": "7e98936e39180e1196f785ef8eb47454c60db727", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e98936e39180e1196f785ef8eb47454c60db727"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea010af6b4d780261b791999e43ba056edce2af0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea010af6b4d780261b791999e43ba056edce2af0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea010af6b4d780261b791999e43ba056edce2af0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea010af6b4d780261b791999e43ba056edce2af0/comments", "author": {"login": "willschm", "id": 44359, "node_id": "MDQ6VXNlcjQ0MzU5", "avatar_url": "https://avatars.githubusercontent.com/u/44359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willschm", "html_url": "https://github.com/willschm", "followers_url": "https://api.github.com/users/willschm/followers", "following_url": "https://api.github.com/users/willschm/following{/other_user}", "gists_url": "https://api.github.com/users/willschm/gists{/gist_id}", "starred_url": "https://api.github.com/users/willschm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willschm/subscriptions", "organizations_url": "https://api.github.com/users/willschm/orgs", "repos_url": "https://api.github.com/users/willschm/repos", "events_url": "https://api.github.com/users/willschm/events{/privacy}", "received_events_url": "https://api.github.com/users/willschm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5746195cdc224e341c78aacd8360795b21459484", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5746195cdc224e341c78aacd8360795b21459484", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5746195cdc224e341c78aacd8360795b21459484"}], "stats": {"total": 313, "additions": 188, "deletions": 125}, "files": [{"sha": "d6a4cade483f4c99d054903e431838448741a554", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea010af6b4d780261b791999e43ba056edce2af0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea010af6b4d780261b791999e43ba056edce2af0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea010af6b4d780261b791999e43ba056edce2af0", "patch": "@@ -1,3 +1,11 @@\n+2018-10-11  Will Schmidt <will_schmidt@vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (map_to_integral_tree_type): New helper\n+\tfunction.\n+\t(fold_mergeeo_helper): New helper function.\n+\t(rs6000_gimple_fold_builtin): Add hooks for vec_mergee and vec_mergeo\n+\tintrinsics.  Correct some whitespace indentation issues.\n+\n 2018-10-11  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \tPR target/87511"}, {"sha": "85b05f6618cef7278c35f3df089dd5dd6cd6e681", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 180, "deletions": 125, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea010af6b4d780261b791999e43ba056edce2af0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea010af6b4d780261b791999e43ba056edce2af0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ea010af6b4d780261b791999e43ba056edce2af0", "patch": "@@ -15238,6 +15238,25 @@ fold_compare_helper (gimple_stmt_iterator *gsi, tree_code code, gimple *stmt)\n   gsi_replace (gsi, g, true);\n }\n \n+/* Helper function to map V2DF and V4SF types to their\n+ integral equivalents (V2DI and V4SI).  */\n+tree map_to_integral_tree_type (tree input_tree_type)\n+{\n+  if (INTEGRAL_TYPE_P (TREE_TYPE (input_tree_type)))\n+    return input_tree_type;\n+  else\n+    {\n+      if (types_compatible_p (TREE_TYPE (input_tree_type),\n+\t\t\t      TREE_TYPE (V2DF_type_node)))\n+\treturn V2DI_type_node;\n+      else if (types_compatible_p (TREE_TYPE (input_tree_type),\n+\t\t\t\t   TREE_TYPE (V4SF_type_node)))\n+\treturn V4SI_type_node;\n+      else\n+\tgcc_unreachable ();\n+    }\n+}\n+\n /* Helper function to handle the vector merge[hl] built-ins.  The\n    implementation difference between h and l versions for this code are in\n    the values used when building of the permute vector for high word versus\n@@ -15260,19 +15279,7 @@ fold_mergehl_helper (gimple_stmt_iterator *gsi, gimple *stmt, int use_high)\n      float types, the permute type needs to map to the V2 or V4 type that\n      matches size.  */\n   tree permute_type;\n-  if (INTEGRAL_TYPE_P (TREE_TYPE (lhs_type)))\n-    permute_type = lhs_type;\n-  else\n-    {\n-      if (types_compatible_p (TREE_TYPE (lhs_type),\n-\t\t\t      TREE_TYPE (V2DF_type_node)))\n-\tpermute_type = V2DI_type_node;\n-      else if (types_compatible_p (TREE_TYPE (lhs_type),\n-\t\t\t\t   TREE_TYPE (V4SF_type_node)))\n-\tpermute_type = V4SI_type_node;\n-      else\n-\tgcc_unreachable ();\n-    }\n+  permute_type = map_to_integral_tree_type (lhs_type);\n   tree_vector_builder elts (permute_type, VECTOR_CST_NELTS (arg0), 1);\n \n   for (int i = 0; i < midpoint; i++)\n@@ -15290,6 +15297,40 @@ fold_mergehl_helper (gimple_stmt_iterator *gsi, gimple *stmt, int use_high)\n   gsi_replace (gsi, g, true);\n }\n \n+/* Helper function to handle the vector merge[eo] built-ins.  */\n+static void\n+fold_mergeeo_helper (gimple_stmt_iterator *gsi, gimple *stmt, int use_odd)\n+{\n+  tree arg0 = gimple_call_arg (stmt, 0);\n+  tree arg1 = gimple_call_arg (stmt, 1);\n+  tree lhs = gimple_call_lhs (stmt);\n+  tree lhs_type = TREE_TYPE (lhs);\n+  int n_elts = TYPE_VECTOR_SUBPARTS (lhs_type);\n+\n+  /* The permute_type will match the lhs for integral types.  For double and\n+     float types, the permute type needs to map to the V2 or V4 type that\n+     matches size.  */\n+  tree permute_type;\n+  permute_type = map_to_integral_tree_type (lhs_type);\n+\n+  tree_vector_builder elts (permute_type, VECTOR_CST_NELTS (arg0), 1);\n+\n+ /* Build the permute vector.  */\n+  for (int i = 0; i < n_elts / 2; i++)\n+    {\n+      elts.safe_push (build_int_cst (TREE_TYPE (permute_type),\n+\t\t\t\t     2*i + use_odd));\n+      elts.safe_push (build_int_cst (TREE_TYPE (permute_type),\n+\t\t\t\t     2*i + use_odd + n_elts));\n+    }\n+\n+  tree permute = elts.build ();\n+\n+  gimple *g = gimple_build_assign (lhs, VEC_PERM_EXPR, arg0, arg1, permute);\n+  gimple_set_location (g, gimple_location (stmt));\n+  gsi_replace (gsi, g, true);\n+}\n+\n /* Fold a machine-dependent built-in in GIMPLE.  (For folding into\n    a constant, use rs6000_fold_builtin.)  */\n \n@@ -15765,34 +15806,34 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case VSX_BUILTIN_LXVD2X_V2DF:\n     case VSX_BUILTIN_LXVD2X_V2DI:\n       {\n-\t arg0 = gimple_call_arg (stmt, 0);  // offset\n-\t arg1 = gimple_call_arg (stmt, 1);  // address\n-\t lhs = gimple_call_lhs (stmt);\n-\t location_t loc = gimple_location (stmt);\n-\t /* Since arg1 may be cast to a different type, just use ptr_type_node\n-\t    here instead of trying to enforce TBAA on pointer types.  */\n-\t tree arg1_type = ptr_type_node;\n-\t tree lhs_type = TREE_TYPE (lhs);\n-\t /* In GIMPLE the type of the MEM_REF specifies the alignment.  The\n-\t   required alignment (power) is 4 bytes regardless of data type.  */\n-\t tree align_ltype = build_aligned_type (lhs_type, 4);\n-\t /* POINTER_PLUS_EXPR wants the offset to be of type 'sizetype'.  Create\n-\t    the tree using the value from arg0.  The resulting type will match\n-\t    the type of arg1.  */\n-\t gimple_seq stmts = NULL;\n-\t tree temp_offset = gimple_convert (&stmts, loc, sizetype, arg0);\n-\t tree temp_addr = gimple_build (&stmts, loc, POINTER_PLUS_EXPR,\n+\targ0 = gimple_call_arg (stmt, 0);  // offset\n+\targ1 = gimple_call_arg (stmt, 1);  // address\n+\tlhs = gimple_call_lhs (stmt);\n+\tlocation_t loc = gimple_location (stmt);\n+\t/* Since arg1 may be cast to a different type, just use ptr_type_node\n+\t   here instead of trying to enforce TBAA on pointer types.  */\n+\ttree arg1_type = ptr_type_node;\n+\ttree lhs_type = TREE_TYPE (lhs);\n+\t/* In GIMPLE the type of the MEM_REF specifies the alignment.  The\n+\t  required alignment (power) is 4 bytes regardless of data type.  */\n+\ttree align_ltype = build_aligned_type (lhs_type, 4);\n+\t/* POINTER_PLUS_EXPR wants the offset to be of type 'sizetype'.  Create\n+\t   the tree using the value from arg0.  The resulting type will match\n+\t   the type of arg1.  */\n+\tgimple_seq stmts = NULL;\n+\ttree temp_offset = gimple_convert (&stmts, loc, sizetype, arg0);\n+\ttree temp_addr = gimple_build (&stmts, loc, POINTER_PLUS_EXPR,\n \t\t\t\t       arg1_type, arg1, temp_offset);\n-\t gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n-\t /* Use the build2 helper to set up the mem_ref.  The MEM_REF could also\n-\t    take an offset, but since we've already incorporated the offset\n-\t    above, here we just pass in a zero.  */\n-\t gimple *g;\n-\t g = gimple_build_assign (lhs, build2 (MEM_REF, align_ltype, temp_addr,\n-\t\t\t\t\t\tbuild_int_cst (arg1_type, 0)));\n-\t gimple_set_location (g, loc);\n-\t gsi_replace (gsi, g, true);\n-\t return true;\n+\tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\t/* Use the build2 helper to set up the mem_ref.  The MEM_REF could also\n+\t   take an offset, but since we've already incorporated the offset\n+\t   above, here we just pass in a zero.  */\n+\tgimple *g;\n+\tg = gimple_build_assign (lhs, build2 (MEM_REF, align_ltype, temp_addr,\n+\t\t\t\t\t      build_int_cst (arg1_type, 0)));\n+\tgimple_set_location (g, loc);\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n       }\n \n     /* unaligned Vector stores.  */\n@@ -15803,29 +15844,29 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case VSX_BUILTIN_STXVD2X_V2DF:\n     case VSX_BUILTIN_STXVD2X_V2DI:\n       {\n-\t arg0 = gimple_call_arg (stmt, 0); /* Value to be stored.  */\n-\t arg1 = gimple_call_arg (stmt, 1); /* Offset.  */\n-\t tree arg2 = gimple_call_arg (stmt, 2); /* Store-to address.  */\n-\t location_t loc = gimple_location (stmt);\n-\t tree arg0_type = TREE_TYPE (arg0);\n-\t /* Use ptr_type_node (no TBAA) for the arg2_type.  */\n-\t tree arg2_type = ptr_type_node;\n-\t /* In GIMPLE the type of the MEM_REF specifies the alignment.  The\n-\t    required alignment (power) is 4 bytes regardless of data type.  */\n-\t tree align_stype = build_aligned_type (arg0_type, 4);\n-\t /* POINTER_PLUS_EXPR wants the offset to be of type 'sizetype'.  Create\n-\t    the tree using the value from arg1.  */\n-\t gimple_seq stmts = NULL;\n-\t tree temp_offset = gimple_convert (&stmts, loc, sizetype, arg1);\n-\t tree temp_addr = gimple_build (&stmts, loc, POINTER_PLUS_EXPR,\n+\targ0 = gimple_call_arg (stmt, 0); /* Value to be stored.  */\n+\targ1 = gimple_call_arg (stmt, 1); /* Offset.  */\n+\ttree arg2 = gimple_call_arg (stmt, 2); /* Store-to address.  */\n+\tlocation_t loc = gimple_location (stmt);\n+\ttree arg0_type = TREE_TYPE (arg0);\n+\t/* Use ptr_type_node (no TBAA) for the arg2_type.  */\n+\ttree arg2_type = ptr_type_node;\n+\t/* In GIMPLE the type of the MEM_REF specifies the alignment.  The\n+\t   required alignment (power) is 4 bytes regardless of data type.  */\n+\ttree align_stype = build_aligned_type (arg0_type, 4);\n+\t/* POINTER_PLUS_EXPR wants the offset to be of type 'sizetype'.  Create\n+\t   the tree using the value from arg1.  */\n+\tgimple_seq stmts = NULL;\n+\ttree temp_offset = gimple_convert (&stmts, loc, sizetype, arg1);\n+\ttree temp_addr = gimple_build (&stmts, loc, POINTER_PLUS_EXPR,\n \t\t\t\t       arg2_type, arg2, temp_offset);\n-\t gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n-\t gimple *g;\n-\t g = gimple_build_assign (build2 (MEM_REF, align_stype, temp_addr,\n-\t\t\t\t\t   build_int_cst (arg2_type, 0)), arg0);\n-\t gimple_set_location (g, loc);\n-\t gsi_replace (gsi, g, true);\n-\t return true;\n+\tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\tgimple *g;\n+\tg = gimple_build_assign (build2 (MEM_REF, align_stype, temp_addr,\n+\t\t\t\t\t build_int_cst (arg2_type, 0)), arg0);\n+\tgimple_set_location (g, loc);\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n       }\n \n     /* Vector Fused multiply-add (fma).  */\n@@ -15897,35 +15938,34 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case ALTIVEC_BUILTIN_VSPLTISH:\n     case ALTIVEC_BUILTIN_VSPLTISW:\n       {\n-\t int size;\n-\n-         if (fn_code == ALTIVEC_BUILTIN_VSPLTISB)\n-           size = 8;\n-         else if (fn_code == ALTIVEC_BUILTIN_VSPLTISH)\n-           size = 16;\n-         else\n-           size = 32;\n-\n-\t arg0 = gimple_call_arg (stmt, 0);\n-\t lhs = gimple_call_lhs (stmt);\n-\n-\t /* Only fold the vec_splat_*() if the lower bits of arg 0 is a\n-\t    5-bit signed constant in range -16 to +15.  */\n-\t if (TREE_CODE (arg0) != INTEGER_CST\n-\t     || !IN_RANGE (sext_hwi(TREE_INT_CST_LOW (arg0), size),\n-\t\t\t   -16, 15))\n-\t   return false;\n-\t gimple_seq stmts = NULL;\n-\t location_t loc = gimple_location (stmt);\n-\t tree splat_value = gimple_convert (&stmts, loc,\n-\t\t\t\t\t    TREE_TYPE (TREE_TYPE (lhs)), arg0);\n-\t gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n-\t tree splat_tree = build_vector_from_val (TREE_TYPE (lhs), splat_value);\n-\t g = gimple_build_assign (lhs, splat_tree);\n-\t gimple_set_location (g, gimple_location (stmt));\n-\t gsi_replace (gsi, g, true);\n-\t return true;\n-\t}\n+\tint size;\n+\tif (fn_code == ALTIVEC_BUILTIN_VSPLTISB)\n+\t  size = 8;\n+\telse if (fn_code == ALTIVEC_BUILTIN_VSPLTISH)\n+\t  size = 16;\n+\telse\n+\t  size = 32;\n+\n+\targ0 = gimple_call_arg (stmt, 0);\n+\tlhs = gimple_call_lhs (stmt);\n+\n+\t/* Only fold the vec_splat_*() if the lower bits of arg 0 is a\n+\t   5-bit signed constant in range -16 to +15.  */\n+\tif (TREE_CODE (arg0) != INTEGER_CST\n+\t    || !IN_RANGE (sext_hwi (TREE_INT_CST_LOW (arg0), size),\n+\t\t\t  -16, 15))\n+\t  return false;\n+\tgimple_seq stmts = NULL;\n+\tlocation_t loc = gimple_location (stmt);\n+\ttree splat_value = gimple_convert (&stmts, loc,\n+\t\t\t\t\t   TREE_TYPE (TREE_TYPE (lhs)), arg0);\n+\tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\ttree splat_tree = build_vector_from_val (TREE_TYPE (lhs), splat_value);\n+\tg = gimple_build_assign (lhs, splat_tree);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n+      }\n \n     /* Flavors of vec_splat.  */\n     /* a = vec_splat (b, 0x3) becomes a = { b[3],b[3],b[3],...};  */\n@@ -15977,8 +16017,8 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case VSX_BUILTIN_VEC_MERGEL_V2DI:\n     case VSX_BUILTIN_XXMRGLW_4SF:\n     case VSX_BUILTIN_VEC_MERGEL_V2DF:\n-\tfold_mergehl_helper (gsi, stmt, 1);\n-\treturn true;\n+      fold_mergehl_helper (gsi, stmt, 1);\n+      return true;\n     /* vec_mergeh (integrals).  */\n     case ALTIVEC_BUILTIN_VMRGHH:\n     case ALTIVEC_BUILTIN_VMRGHW:\n@@ -15987,55 +16027,70 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case VSX_BUILTIN_VEC_MERGEH_V2DI:\n     case VSX_BUILTIN_XXMRGHW_4SF:\n     case VSX_BUILTIN_VEC_MERGEH_V2DF:\n-\tfold_mergehl_helper (gsi, stmt, 0);\n-\treturn true;\n+      fold_mergehl_helper (gsi, stmt, 0);\n+      return true;\n+\n+    /* Flavors of vec_mergee.  */\n+    case P8V_BUILTIN_VMRGEW_V4SI:\n+    case P8V_BUILTIN_VMRGEW_V2DI:\n+    case P8V_BUILTIN_VMRGEW_V4SF:\n+    case P8V_BUILTIN_VMRGEW_V2DF:\n+      fold_mergeeo_helper (gsi, stmt, 0);\n+      return true;\n+    /* Flavors of vec_mergeo.  */\n+    case P8V_BUILTIN_VMRGOW_V4SI:\n+    case P8V_BUILTIN_VMRGOW_V2DI:\n+    case P8V_BUILTIN_VMRGOW_V4SF:\n+    case P8V_BUILTIN_VMRGOW_V2DF:\n+      fold_mergeeo_helper (gsi, stmt, 1);\n+      return true;\n \n     /* d = vec_pack (a, b) */\n     case P8V_BUILTIN_VPKUDUM:\n     case ALTIVEC_BUILTIN_VPKUHUM:\n     case ALTIVEC_BUILTIN_VPKUWUM:\n       {\n-       arg0 = gimple_call_arg (stmt, 0);\n-       arg1 = gimple_call_arg (stmt, 1);\n-       lhs = gimple_call_lhs (stmt);\n-       gimple *g = gimple_build_assign (lhs, VEC_PACK_TRUNC_EXPR, arg0, arg1);\n-       gimple_set_location (g, gimple_location (stmt));\n-       gsi_replace (gsi, g, true);\n-       return true;\n+\targ0 = gimple_call_arg (stmt, 0);\n+\targ1 = gimple_call_arg (stmt, 1);\n+\tlhs = gimple_call_lhs (stmt);\n+\tgimple *g = gimple_build_assign (lhs, VEC_PACK_TRUNC_EXPR, arg0, arg1);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n       }\n \n-   /* d = vec_unpackh (a) */\n-   /* Note that the UNPACK_{HI,LO}_EXPR used in the gimple_build_assign call\n-      in this code is sensitive to endian-ness, and needs to be inverted to\n-      handle both LE and BE targets.  */\n+    /* d = vec_unpackh (a) */\n+    /* Note that the UNPACK_{HI,LO}_EXPR used in the gimple_build_assign call\n+       in this code is sensitive to endian-ness, and needs to be inverted to\n+       handle both LE and BE targets.  */\n     case ALTIVEC_BUILTIN_VUPKHSB:\n     case ALTIVEC_BUILTIN_VUPKHSH:\n     case P8V_BUILTIN_VUPKHSW:\n       {\n-       arg0 = gimple_call_arg (stmt, 0);\n-       lhs = gimple_call_lhs (stmt);\n-       if (BYTES_BIG_ENDIAN)\n-\t g = gimple_build_assign (lhs, VEC_UNPACK_HI_EXPR, arg0);\n-       else\n-\t g = gimple_build_assign (lhs, VEC_UNPACK_LO_EXPR, arg0);\n-       gimple_set_location (g, gimple_location (stmt));\n-       gsi_replace (gsi, g, true);\n-       return true;\n+\targ0 = gimple_call_arg (stmt, 0);\n+\tlhs = gimple_call_lhs (stmt);\n+\tif (BYTES_BIG_ENDIAN)\n+\t  g = gimple_build_assign (lhs, VEC_UNPACK_HI_EXPR, arg0);\n+\telse\n+\t  g = gimple_build_assign (lhs, VEC_UNPACK_LO_EXPR, arg0);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n       }\n-   /* d = vec_unpackl (a) */\n+    /* d = vec_unpackl (a) */\n     case ALTIVEC_BUILTIN_VUPKLSB:\n     case ALTIVEC_BUILTIN_VUPKLSH:\n     case P8V_BUILTIN_VUPKLSW:\n       {\n-       arg0 = gimple_call_arg (stmt, 0);\n-       lhs = gimple_call_lhs (stmt);\n-       if (BYTES_BIG_ENDIAN)\n-\t g = gimple_build_assign (lhs, VEC_UNPACK_LO_EXPR, arg0);\n-       else\n-\t g = gimple_build_assign (lhs, VEC_UNPACK_HI_EXPR, arg0);\n-       gimple_set_location (g, gimple_location (stmt));\n-       gsi_replace (gsi, g, true);\n-       return true;\n+\targ0 = gimple_call_arg (stmt, 0);\n+\tlhs = gimple_call_lhs (stmt);\n+\tif (BYTES_BIG_ENDIAN)\n+\t  g = gimple_build_assign (lhs, VEC_UNPACK_LO_EXPR, arg0);\n+\telse\n+\t  g = gimple_build_assign (lhs, VEC_UNPACK_HI_EXPR, arg0);\n+\tgimple_set_location (g, gimple_location (stmt));\n+\tgsi_replace (gsi, g, true);\n+\treturn true;\n       }\n     /* There is no gimple type corresponding with pixel, so just return.  */\n     case ALTIVEC_BUILTIN_VUPKHPX:"}]}