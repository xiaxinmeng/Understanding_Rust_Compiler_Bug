{"sha": "e7056ca417326a70eca05defb6a8b20b737d3417", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTcwNTZjYTQxNzMyNmE3MGVjYTA1ZGVmYjZhOGIyMGI3MzdkMzQxNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-20T08:52:48Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-20T08:52:48Z"}, "message": "Use function_arg_info for TARGET_SETUP_INCOMING_ARGS\n\nThe hook is passed the promoted mode instead of the original type mode.\n\n2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* target.def (setup_incoming_varargs): Take a function_arg_info\n\tinstead of a mode and tree.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.h (default_setup_incoming_varargs): Take a\n\tfunction_arg_info instead of a mode and tree.\n\t* targhooks.c (default_setup_incoming_varargs): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_setup_incoming_varargs): Likewise.\n\t* config/alpha/alpha.c (alpha_setup_incoming_varargs): Likewise.\n\t* config/arc/arc.c (arc_setup_incoming_varargs): Likewise.\n\t* config/arm/arm.c (arm_setup_incoming_varargs): Likewise.\n\t* config/bfin/bfin.c (setup_incoming_varargs): Likewise.\n\t* config/cris/cris.c (cris_setup_incoming_varargs): Likewise.\n\t* config/csky/csky.c (csky_setup_incoming_varargs): Likewise.\n\t* config/epiphany/epiphany.c (epiphany_setup_incoming_varargs):\n\tLikewise.\n\t* config/fr30/fr30.c (fr30_setup_incoming_varargs): Likewise.\n\t* config/frv/frv.c (frv_setup_incoming_varargs): Likewise.\n\t* config/ft32/ft32.c (ft32_setup_incoming_varargs): Likewise.\n\t* config/i386/i386.c (ix86_setup_incoming_varargs): Likewise.\n\t* config/ia64/ia64.c (ia64_setup_incoming_varargs): Likewise.\n\t* config/iq2000/iq2000.c (iq2000_setup_incoming_varargs): Likewise.\n\t* config/lm32/lm32.c (lm32_setup_incoming_varargs): Likewise.\n\t* config/m32r/m32r.c (m32r_setup_incoming_varargs): Likewise.\n\t* config/mcore/mcore.c (mcore_setup_incoming_varargs): Likewise.\n\t* config/mips/mips.c (mips_setup_incoming_varargs): Likewise.\n\t* config/mmix/mmix.c (mmix_setup_incoming_varargs): Likewise.\n\t* config/moxie/moxie.c (moxie_setup_incoming_varargs): Likewise.\n\t* config/nds32/nds32.c (nds32_setup_incoming_varargs): Likewise.\n\t* config/nios2/nios2.c (nios2_setup_incoming_varargs): Likewise.\n\t* config/riscv/riscv.c (riscv_setup_incoming_varargs): Likewise.\n\t* config/rs6000/rs6000-internal.h (setup_incoming_varargs): Likewise.\n\t* config/rs6000/rs6000-call.c (setup_incoming_varargs): Likewise.\n\t* config/sh/sh.c (sh_setup_incoming_varargs): Likewise.\n\t* config/spu/spu.c (spu_setup_incoming_varargs): Likewise.\n\t* config/tilegx/tilegx.c (tilegx_setup_incoming_varargs): Likewise.\n\t* config/tilepro/tilepro.c (tilepro_setup_incoming_varargs): Likewise.\n\t* config/visium/visium.c (visium_setup_incoming_varargs): Likewise.\n\t* function.c (assign_parms_setup_varargs): Update call to\n\ttargetm.calls.setup_incoming_varargs.\n\nFrom-SVN: r274699", "tree": {"sha": "e330e61756c734f2502bd7e7aeb2ed3fd2e9baeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e330e61756c734f2502bd7e7aeb2ed3fd2e9baeb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7056ca417326a70eca05defb6a8b20b737d3417", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7056ca417326a70eca05defb6a8b20b737d3417", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7056ca417326a70eca05defb6a8b20b737d3417", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7056ca417326a70eca05defb6a8b20b737d3417/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "52090e4dbd064f486af606e3f8a283dbddc7c18a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52090e4dbd064f486af606e3f8a283dbddc7c18a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52090e4dbd064f486af606e3f8a283dbddc7c18a"}], "stats": {"total": 361, "additions": 201, "deletions": 160}, "files": [{"sha": "f9cfcc0a990502cb4828865588a2af5adb4de390", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -1,3 +1,45 @@\n+2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* target.def (setup_incoming_varargs): Take a function_arg_info\n+\tinstead of a mode and tree.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.h (default_setup_incoming_varargs): Take a\n+\tfunction_arg_info instead of a mode and tree.\n+\t* targhooks.c (default_setup_incoming_varargs): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_setup_incoming_varargs): Likewise.\n+\t* config/alpha/alpha.c (alpha_setup_incoming_varargs): Likewise.\n+\t* config/arc/arc.c (arc_setup_incoming_varargs): Likewise.\n+\t* config/arm/arm.c (arm_setup_incoming_varargs): Likewise.\n+\t* config/bfin/bfin.c (setup_incoming_varargs): Likewise.\n+\t* config/cris/cris.c (cris_setup_incoming_varargs): Likewise.\n+\t* config/csky/csky.c (csky_setup_incoming_varargs): Likewise.\n+\t* config/epiphany/epiphany.c (epiphany_setup_incoming_varargs):\n+\tLikewise.\n+\t* config/fr30/fr30.c (fr30_setup_incoming_varargs): Likewise.\n+\t* config/frv/frv.c (frv_setup_incoming_varargs): Likewise.\n+\t* config/ft32/ft32.c (ft32_setup_incoming_varargs): Likewise.\n+\t* config/i386/i386.c (ix86_setup_incoming_varargs): Likewise.\n+\t* config/ia64/ia64.c (ia64_setup_incoming_varargs): Likewise.\n+\t* config/iq2000/iq2000.c (iq2000_setup_incoming_varargs): Likewise.\n+\t* config/lm32/lm32.c (lm32_setup_incoming_varargs): Likewise.\n+\t* config/m32r/m32r.c (m32r_setup_incoming_varargs): Likewise.\n+\t* config/mcore/mcore.c (mcore_setup_incoming_varargs): Likewise.\n+\t* config/mips/mips.c (mips_setup_incoming_varargs): Likewise.\n+\t* config/mmix/mmix.c (mmix_setup_incoming_varargs): Likewise.\n+\t* config/moxie/moxie.c (moxie_setup_incoming_varargs): Likewise.\n+\t* config/nds32/nds32.c (nds32_setup_incoming_varargs): Likewise.\n+\t* config/nios2/nios2.c (nios2_setup_incoming_varargs): Likewise.\n+\t* config/riscv/riscv.c (riscv_setup_incoming_varargs): Likewise.\n+\t* config/rs6000/rs6000-internal.h (setup_incoming_varargs): Likewise.\n+\t* config/rs6000/rs6000-call.c (setup_incoming_varargs): Likewise.\n+\t* config/sh/sh.c (sh_setup_incoming_varargs): Likewise.\n+\t* config/spu/spu.c (spu_setup_incoming_varargs): Likewise.\n+\t* config/tilegx/tilegx.c (tilegx_setup_incoming_varargs): Likewise.\n+\t* config/tilepro/tilepro.c (tilepro_setup_incoming_varargs): Likewise.\n+\t* config/visium/visium.c (visium_setup_incoming_varargs): Likewise.\n+\t* function.c (assign_parms_setup_varargs): Update call to\n+\ttargetm.calls.setup_incoming_varargs.\n+\n 2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* target.def (pass_by_reference): Take a function_arg_info instead"}, {"sha": "4c5871c15d62ad4288f558d07751af0b9fc665d6", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -14511,9 +14511,9 @@ aarch64_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n /* Implement TARGET_SETUP_INCOMING_VARARGS.  */\n \n static void\n-aarch64_setup_incoming_varargs (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t\ttree type, int *pretend_size ATTRIBUTE_UNUSED,\n-\t\t\t\tint no_rtl)\n+aarch64_setup_incoming_varargs (cumulative_args_t cum_v,\n+\t\t\t\tconst function_arg_info &arg,\n+\t\t\t\tint *pretend_size ATTRIBUTE_UNUSED, int no_rtl)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   CUMULATIVE_ARGS local_cum;\n@@ -14524,7 +14524,8 @@ aarch64_setup_incoming_varargs (cumulative_args_t cum_v, machine_mode mode,\n      argument.  Advance a local copy of CUM past the last \"real\" named\n      argument, to find out how many registers are left over.  */\n   local_cum = *cum;\n-  aarch64_function_arg_advance (pack_cumulative_args(&local_cum), mode, type, true);\n+  aarch64_function_arg_advance (pack_cumulative_args(&local_cum),\n+\t\t\t\targ.mode, arg.type, arg.named);\n \n   /* Found out how many registers we need to save.\n      Honor tree-stdvar analysis results.  */"}, {"sha": "2aace8896071c0912ec41f8f44cdff0608350b39", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -6090,14 +6090,15 @@ alpha_stdarg_optimize_hook (struct stdarg_info *si, const gimple *stmt)\n    variable number of arguments.  */\n \n static void\n-alpha_setup_incoming_varargs (cumulative_args_t pcum, machine_mode mode,\n-\t\t\t      tree type, int *pretend_size, int no_rtl)\n+alpha_setup_incoming_varargs (cumulative_args_t pcum,\n+\t\t\t      const function_arg_info &arg,\n+\t\t\t      int *pretend_size, int no_rtl)\n {\n   CUMULATIVE_ARGS cum = *get_cumulative_args (pcum);\n \n   /* Skip the current argument.  */\n-  targetm.calls.function_arg_advance (pack_cumulative_args (&cum), mode, type,\n-\t\t\t\t      true);\n+  targetm.calls.function_arg_advance (pack_cumulative_args (&cum),\n+\t\t\t\t      arg.mode, arg.type, arg.named);\n \n #if TARGET_ABI_OPEN_VMS\n   /* For VMS, we allocate space for all 6 arg registers plus a count."}, {"sha": "bfa38abcd4b4ff21613a8471dfc66706c5019802", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -2415,12 +2415,12 @@ arc_double_limm_p (rtx value)\n    create a register parameter block, and then copy any anonymous arguments\n    in registers to memory.\n \n-   CUM has not been updated for the last named argument which has type TYPE\n-   and mode MODE, and we rely on this fact.  */\n+   CUM has not been updated for the last named argument (which is given\n+   by ARG), and we rely on this fact.  */\n \n static void\n arc_setup_incoming_varargs (cumulative_args_t args_so_far,\n-\t\t\t    machine_mode mode, tree type,\n+\t\t\t    const function_arg_info &arg,\n \t\t\t    int *pretend_size, int no_rtl)\n {\n   int first_anon_arg;\n@@ -2430,7 +2430,7 @@ arc_setup_incoming_varargs (cumulative_args_t args_so_far,\n \n   next_cum = *get_cumulative_args (args_so_far);\n   arc_function_arg_advance (pack_cumulative_args (&next_cum),\n-\t\t\t    mode, type, true);\n+\t\t\t    arg.mode, arg.type, arg.named);\n   first_anon_arg = next_cum;\n \n   if (FUNCTION_ARG_REGNO_P (first_anon_arg))"}, {"sha": "f713945a299650370711802b9fb6931d703a2dac", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -212,8 +212,8 @@ static void arm_file_end (void);\n static void arm_file_start (void);\n static void arm_insert_attributes (tree, tree *);\n \n-static void arm_setup_incoming_varargs (cumulative_args_t, machine_mode,\n-\t\t\t\t\ttree, int *, int);\n+static void arm_setup_incoming_varargs (cumulative_args_t,\n+\t\t\t\t\tconst function_arg_info &, int *, int);\n static bool arm_pass_by_reference (cumulative_args_t,\n \t\t\t\t   const function_arg_info &);\n static bool arm_promote_prototypes (const_tree);\n@@ -27054,8 +27054,7 @@ arm_output_load_gr (rtx *operands)\n \n static void\n arm_setup_incoming_varargs (cumulative_args_t pcum_v,\n-\t\t\t    machine_mode mode,\n-\t\t\t    tree type,\n+\t\t\t    const function_arg_info &arg,\n \t\t\t    int *pretend_size,\n \t\t\t    int second_time ATTRIBUTE_UNUSED)\n {\n@@ -27068,17 +27067,17 @@ arm_setup_incoming_varargs (cumulative_args_t pcum_v,\n       nregs = pcum->aapcs_ncrn;\n       if (nregs & 1)\n \t{\n-\t  int res = arm_needs_doubleword_align (mode, type);\n+\t  int res = arm_needs_doubleword_align (arg.mode, arg.type);\n \t  if (res < 0 && warn_psabi)\n \t    inform (input_location, \"parameter passing for argument of \"\n-\t\t    \"type %qT changed in GCC 7.1\", type);\n+\t\t    \"type %qT changed in GCC 7.1\", arg.type);\n \t  else if (res > 0)\n \t    {\n \t      nregs++;\n \t      if (res > 1 && warn_psabi)\n \t\tinform (input_location,\n \t\t\t\"parameter passing for argument of type \"\n-\t\t\t\"%qT changed in GCC 9.1\", type);\n+\t\t\t\"%qT changed in GCC 9.1\", arg.type);\n \t    }\n \t}\n     }"}, {"sha": "7dd0a24fb21a188a1ffb7b8172eccc1905377d7a", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -540,7 +540,7 @@ expand_epilogue_reg_restore (rtx spreg, bool saveall, bool is_inthandler)\n \n    CUM is as above.\n \n-   MODE and TYPE are the mode and type of the current parameter.\n+   ARG is the last named argument.\n \n    PRETEND_SIZE is a variable that should be set to the amount of stack\n    that must be pushed by the prolog to pretend that our caller pushed\n@@ -559,8 +559,7 @@ expand_epilogue_reg_restore (rtx spreg, bool saveall, bool is_inthandler)\n \n static void\n setup_incoming_varargs (cumulative_args_t cum,\n-\t\t\tmachine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\ttree type ATTRIBUTE_UNUSED, int *pretend_size,\n+\t\t\tconst function_arg_info &, int *pretend_size,\n \t\t\tint no_rtl)\n {\n   rtx mem;"}, {"sha": "0b2947e2319377463ef19d605238058fa27dd2fc", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -108,8 +108,9 @@ static struct machine_function * cris_init_machine_status (void);\n \n static rtx cris_struct_value_rtx (tree, int);\n \n-static void cris_setup_incoming_varargs (cumulative_args_t, machine_mode,\n-\t\t\t\t\t tree type, int *, int);\n+static void cris_setup_incoming_varargs (cumulative_args_t,\n+\t\t\t\t\t const function_arg_info &,\n+\t\t\t\t\t int *, int);\n \n static int cris_initial_frame_pointer_offset (void);\n \n@@ -4021,8 +4022,7 @@ cris_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n \n static void\n cris_setup_incoming_varargs (cumulative_args_t ca_v,\n-\t\t\t     machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t     tree type ATTRIBUTE_UNUSED,\n+\t\t\t     const function_arg_info &,\n \t\t\t     int *pretend_arg_size,\n \t\t\t     int second_time)\n {"}, {"sha": "c85135406330b07e7885360e77e889d39683f3c1", "filename": "gcc/config/csky/csky.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fcsky%2Fcsky.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fcsky%2Fcsky.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcsky%2Fcsky.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -1937,8 +1937,7 @@ csky_arg_partial_bytes (cumulative_args_t pcum_v, const function_arg_info &arg)\n \n static void\n csky_setup_incoming_varargs (cumulative_args_t pcum_v,\n-\t\t\t     machine_mode mode,\n-\t\t\t     tree type,\n+\t\t\t     const function_arg_info &arg,\n \t\t\t     int *pretend_size,\n \t\t\t     int second_time ATTRIBUTE_UNUSED)\n {\n@@ -1949,7 +1948,7 @@ csky_setup_incoming_varargs (cumulative_args_t pcum_v,\n \n   cfun->machine->uses_anonymous_args = 1;\n   local_cum = *pcum;\n-  csky_function_arg_advance (local_cum_v, mode, type, true);\n+  csky_function_arg_advance (local_cum_v, arg.mode, arg.type, arg.named);\n   regs_to_push = CSKY_NPARM_REGS - local_cum;\n   if (regs_to_push)\n     *pretend_size  = regs_to_push * UNITS_PER_WORD;"}, {"sha": "9dd1643ddf5fa4afd7457478cc6408c81692cdb2", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -711,24 +711,25 @@ epiphany_function_arg_boundary (machine_mode mode, const_tree type)\n /* Do any needed setup for a variadic function.  For the EPIPHANY, we\n    actually emit the code in epiphany_expand_prologue.\n \n-   CUM has not been updated for the last named argument which has type TYPE\n-   and mode MODE, and we rely on this fact.  */\n+   CUM has not been updated for the last named argument (which is given\n+   by ARG), and we rely on this fact.  */\n \n \n static void\n-epiphany_setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n-\t\t\t\t tree type, int *pretend_size, int no_rtl)\n+epiphany_setup_incoming_varargs (cumulative_args_t cum,\n+\t\t\t\t const function_arg_info &arg,\n+\t\t\t\t int *pretend_size, int no_rtl)\n {\n   int first_anon_arg;\n   CUMULATIVE_ARGS next_cum;\n   machine_function_t *mf = MACHINE_FUNCTION (cfun);\n \n   /* All BLKmode values are passed by reference.  */\n-  gcc_assert (mode != BLKmode);\n+  gcc_assert (arg.mode != BLKmode);\n \n   next_cum = *get_cumulative_args (cum);\n-  next_cum\n-    = ROUND_ADVANCE_CUM (next_cum, mode, type) + ROUND_ADVANCE_ARG (mode, type);\n+  next_cum = (ROUND_ADVANCE_CUM (next_cum, arg.mode, arg.type)\n+\t      + ROUND_ADVANCE_ARG (arg.mode, arg.type));\n   first_anon_arg = next_cum;\n \n   if (first_anon_arg < MAX_EPIPHANY_PARM_REGS && !no_rtl)"}, {"sha": "d6c835130bbf48b65d2c17f3baa87c73eed8bf63", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -113,8 +113,9 @@ static struct fr30_frame_info \tcurrent_frame_info;\n /* Zero structure to initialize current_frame_info.  */\n static struct fr30_frame_info \tzero_frame_info;\n \n-static void fr30_setup_incoming_varargs (cumulative_args_t, machine_mode,\n-\t\t\t\t\t tree, int *, int);\n+static void fr30_setup_incoming_varargs (cumulative_args_t,\n+\t\t\t\t\t const function_arg_info &,\n+\t\t\t\t\t int *, int);\n static bool fr30_must_pass_in_stack (machine_mode, const_tree);\n static int fr30_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t   const function_arg_info &);\n@@ -459,12 +460,11 @@ fr30_expand_epilogue (void)\n    named argument, from registers into memory.  * copying actually done in\n    fr30_expand_prologue().\n \n-   ARG_REGS_USED_SO_FAR has *not* been updated for the last named argument\n-   which has type TYPE and mode MODE, and we rely on this fact.  */\n+   CUM has not been updated for the last named argument which has type TYPE\n+   and mode MODE, and we rely on this fact.  */\n void\n fr30_setup_incoming_varargs (cumulative_args_t arg_regs_used_so_far_v,\n-\t\t\t     machine_mode mode,\n-\t\t\t     tree type ATTRIBUTE_UNUSED,\n+\t\t\t     const function_arg_info &arg,\n \t\t\t     int *pretend_size,\n \t\t\t     int second_time ATTRIBUTE_UNUSED)\n {\n@@ -473,15 +473,15 @@ fr30_setup_incoming_varargs (cumulative_args_t arg_regs_used_so_far_v,\n   int size;\n \n   /* All BLKmode values are passed by reference.  */\n-  gcc_assert (mode != BLKmode);\n+  gcc_assert (arg.mode != BLKmode);\n \n   /* ??? This run-time test as well as the code inside the if\n      statement is probably unnecessary.  */\n   if (targetm.calls.strict_argument_naming (arg_regs_used_so_far_v))\n     /* If TARGET_STRICT_ARGUMENT_NAMING returns true, then the last named\n        arg must not be treated as an anonymous arg.  */\n     /* ??? This is a pointer increment, which makes no sense.  */\n-    arg_regs_used_so_far += fr30_num_arg_regs (mode, type);\n+    arg_regs_used_so_far += fr30_num_arg_regs (arg.mode, arg.type);\n \n   size = FR30_NUM_ARG_REGS - (* arg_regs_used_so_far);\n "}, {"sha": "5e06cf691f33ad83e395e7feaeee071c58482d4c", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -359,8 +359,8 @@ static bool frv_in_small_data_p\t\t\t(const_tree);\n static void frv_asm_output_mi_thunk\n   (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree);\n static void frv_setup_incoming_varargs\t\t(cumulative_args_t,\n-\t\t\t\t\t\t machine_mode,\n-\t\t\t\t\t\t tree, int *, int);\n+\t\t\t\t\t\t const function_arg_info &,\n+\t\t\t\t\t\t int *, int);\n static rtx frv_expand_builtin_saveregs\t\t(void);\n static void frv_expand_builtin_va_start\t\t(tree, rtx);\n static bool frv_rtx_costs\t\t\t(rtx, machine_mode, int, int,\n@@ -2109,17 +2109,16 @@ frv_initial_elimination_offset (int from, int to)\n \n static void\n frv_setup_incoming_varargs (cumulative_args_t cum_v,\n-                            machine_mode mode,\n-                            tree type ATTRIBUTE_UNUSED,\n-                            int *pretend_size,\n-                            int second_time)\n+\t\t\t    const function_arg_info &arg,\n+\t\t\t    int *pretend_size,\n+\t\t\t    int second_time)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n   if (TARGET_DEBUG_ARG)\n     fprintf (stderr,\n \t     \"setup_vararg: words = %2d, mode = %4s, pretend_size = %d, second_time = %d\\n\",\n-\t     *cum, GET_MODE_NAME (mode), *pretend_size, second_time);\n+\t     *cum, GET_MODE_NAME (arg.mode), *pretend_size, second_time);\n }\n \n \f"}, {"sha": "ee073c8c9fdde29e068514016694780b895856bf", "filename": "gcc/config/ft32/ft32.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fft32%2Fft32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fft32%2Fft32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -630,13 +630,12 @@ ft32_initial_elimination_offset (int from, int to)\n \n static void\n ft32_setup_incoming_varargs (cumulative_args_t cum_v,\n-\t\t\t     machine_mode mode,\n-\t\t\t     tree type ATTRIBUTE_UNUSED,\n+\t\t\t     const function_arg_info &arg,\n \t\t\t     int *pretend_size, int no_rtl ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int named_size =\n-    GET_MODE_SIZE (SImode) * (*cum - FT32_R0) + GET_MODE_SIZE (mode);\n+    GET_MODE_SIZE (SImode) * (*cum - FT32_R0) + GET_MODE_SIZE (arg.mode);\n \n   if (named_size < 24)\n     *pretend_size = 24 - named_size;"}, {"sha": "67959c1e34e400cb34927c44be8aa0842fbddc0e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -4096,8 +4096,9 @@ setup_incoming_varargs_ms_64 (CUMULATIVE_ARGS *cum)\n }\n \n static void\n-ix86_setup_incoming_varargs (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t     tree type, int *, int no_rtl)\n+ix86_setup_incoming_varargs (cumulative_args_t cum_v,\n+\t\t\t     const function_arg_info &arg,\n+\t\t\t     int *, int no_rtl)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   CUMULATIVE_ARGS next_cum;\n@@ -4116,8 +4117,8 @@ ix86_setup_incoming_varargs (cumulative_args_t cum_v, machine_mode mode,\n      For stdargs, we do want to skip the last named argument.  */\n   next_cum = *cum;\n   if (stdarg_p (fntype))\n-    ix86_function_arg_advance (pack_cumulative_args (&next_cum), mode, type,\n-\t\t\t       true);\n+    ix86_function_arg_advance (pack_cumulative_args (&next_cum),\n+\t\t\t       arg.mode, arg.type, arg.named);\n \n   if (cum->call_abi == MS_ABI)\n     setup_incoming_varargs_ms_64 (&next_cum);"}, {"sha": "3bd20687e525893f265e6562151196be68da2db6", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -199,8 +199,9 @@ static rtx gen_fr_restore_x (rtx, rtx, rtx);\n static void ia64_option_override (void);\n static bool ia64_can_eliminate (const int, const int);\n static machine_mode hfa_element_mode (const_tree, bool);\n-static void ia64_setup_incoming_varargs (cumulative_args_t, machine_mode,\n-\t\t\t\t\t tree, int *, int);\n+static void ia64_setup_incoming_varargs (cumulative_args_t,\n+\t\t\t\t\t const function_arg_info &,\n+\t\t\t\t\t int *, int);\n static int ia64_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t   const function_arg_info &);\n static rtx ia64_function_arg_1 (cumulative_args_t, machine_mode,\n@@ -4585,19 +4586,21 @@ ia64_trampoline_init (rtx m_tramp, tree fndecl, rtx static_chain)\n }\n \f\n /* Do any needed setup for a variadic function.  CUM has not been updated\n-   for the last named argument which has type TYPE and mode MODE.\n+   for the last named argument, which is given by ARG.\n \n    We generate the actual spill instructions during prologue generation.  */\n \n static void\n-ia64_setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n-\t\t\t     tree type, int * pretend_size,\n+ia64_setup_incoming_varargs (cumulative_args_t cum,\n+\t\t\t     const function_arg_info &arg,\n+\t\t\t     int *pretend_size,\n \t\t\t     int second_time ATTRIBUTE_UNUSED)\n {\n   CUMULATIVE_ARGS next_cum = *get_cumulative_args (cum);\n \n   /* Skip the current argument.  */\n-  ia64_function_arg_advance (pack_cumulative_args (&next_cum), mode, type, 1);\n+  ia64_function_arg_advance (pack_cumulative_args (&next_cum),\n+\t\t\t     arg.mode, arg.type, arg.named);\n \n   if (next_cum.words < MAX_ARGUMENT_SLOTS)\n     {"}, {"sha": "ec615df27347e531798fecc50f1dfcd0d7dba48e", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -152,8 +152,8 @@ static void iq2000_init_builtins      (void);\n static rtx  iq2000_expand_builtin     (tree, rtx, rtx, machine_mode, int);\n static bool iq2000_return_in_memory   (const_tree, const_tree);\n static void iq2000_setup_incoming_varargs (cumulative_args_t,\n-\t\t\t\t\t   machine_mode, tree, int *,\n-\t\t\t\t\t   int);\n+\t\t\t\t\t   const function_arg_info &,\n+\t\t\t\t\t   int *, int);\n static bool iq2000_rtx_costs          (rtx, machine_mode, int, int, int *, bool);\n static int  iq2000_address_cost       (rtx, machine_mode, addr_space_t,\n \t\t\t\t       bool);\n@@ -2894,9 +2894,8 @@ iq2000_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n \n static void\n iq2000_setup_incoming_varargs (cumulative_args_t cum_v,\n-\t\t\t       machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t       tree type ATTRIBUTE_UNUSED, int * pretend_size,\n-\t\t\t       int no_rtl)\n+\t\t\t       const function_arg_info &,\n+\t\t\t       int *pretend_size, int no_rtl)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   unsigned int iq2000_off = ! cum->last_arg_fp; "}, {"sha": "c9d863d62f19e4dbe941e6eb52869f5b8a491748", "filename": "gcc/config/lm32/lm32.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Flm32%2Flm32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Flm32%2Flm32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -64,7 +64,7 @@ static void expand_save_restore (struct lm32_frame_info *info, int op);\n static void stack_adjust (HOST_WIDE_INT amount);\n static bool lm32_in_small_data_p (const_tree);\n static void lm32_setup_incoming_varargs (cumulative_args_t cum,\n-\t\t\t\t\t machine_mode mode, tree type,\n+\t\t\t\t\t const function_arg_info &,\n \t\t\t\t\t int *pretend_size, int no_rtl);\n static bool lm32_rtx_costs (rtx x, machine_mode mode, int outer_code, int opno,\n \t\t\t    int *total, bool speed);\n@@ -684,8 +684,9 @@ lm32_compute_initial_elimination_offset (int from, int to)\n }\n \n static void\n-lm32_setup_incoming_varargs (cumulative_args_t cum_v, machine_mode mode,\n-\t\t\t     tree type, int *pretend_size, int no_rtl)\n+lm32_setup_incoming_varargs (cumulative_args_t cum_v,\n+\t\t\t     const function_arg_info &arg,\n+\t\t\t     int *pretend_size, int no_rtl)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n   int first_anon_arg;\n@@ -702,12 +703,7 @@ lm32_setup_incoming_varargs (cumulative_args_t cum_v, machine_mode mode,\n          registers, if any used in passing this named paramter in\n          order to determine which is the first registers used to pass\n          anonymous arguments.  */\n-      int size;\n-\n-      if (mode == BLKmode)\n-\tsize = int_size_in_bytes (type);\n-      else\n-\tsize = GET_MODE_SIZE (mode);\n+      int size = arg.promoted_size_in_bytes ();\n \n       first_anon_arg =\n \t*cum + LM32_FIRST_ARG_REG +"}, {"sha": "01bbec9ca0c565337ffdddbe254408d5b9f19a77", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -86,8 +86,9 @@ static bool m32r_return_in_memory (const_tree, const_tree);\n static rtx m32r_function_value (const_tree, const_tree, bool);\n static rtx m32r_libcall_value (machine_mode, const_rtx);\n static bool m32r_function_value_regno_p (const unsigned int);\n-static void m32r_setup_incoming_varargs (cumulative_args_t, machine_mode,\n-\t\t\t\t\t tree, int *, int);\n+static void m32r_setup_incoming_varargs (cumulative_args_t,\n+\t\t\t\t\t const function_arg_info &,\n+\t\t\t\t\t int *, int);\n static void init_idents (void);\n static bool m32r_rtx_costs (rtx, machine_mode, int, int, int *, bool speed);\n static int m32r_memory_move_cost (machine_mode, reg_class_t, bool);\n@@ -1280,23 +1281,25 @@ m32r_function_value_regno_p (const unsigned int regno)\n    create a register parameter block, and then copy any anonymous arguments\n    in registers to memory.\n \n-   CUM has not been updated for the last named argument which has type TYPE\n-   and mode MODE, and we rely on this fact.  */\n+   CUM has not been updated for the last named argument (which is given\n+   by ARG), and we rely on this fact.  */\n \n static void\n-m32r_setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n-\t\t\t     tree type, int *pretend_size, int no_rtl)\n+m32r_setup_incoming_varargs (cumulative_args_t cum,\n+\t\t\t     const function_arg_info &arg,\n+\t\t\t     int *pretend_size, int no_rtl)\n {\n   int first_anon_arg;\n \n   if (no_rtl)\n     return;\n \n   /* All BLKmode values are passed by reference.  */\n-  gcc_assert (mode != BLKmode);\n+  gcc_assert (arg.mode != BLKmode);\n \n-  first_anon_arg = (ROUND_ADVANCE_CUM (*get_cumulative_args (cum), mode, type)\n-\t\t    + ROUND_ADVANCE_ARG (mode, type));\n+  first_anon_arg = (ROUND_ADVANCE_CUM (*get_cumulative_args (cum),\n+\t\t\t\t       arg.mode, arg.type)\n+\t\t    + ROUND_ADVANCE_ARG (arg.mode, arg.type));\n \n   if (first_anon_arg < M32R_MAX_PARM_REGS)\n     {"}, {"sha": "98f01117d501f27e6db314a624ed4ab7307c8b67", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -99,7 +99,9 @@ static int        calc_live_regs                (int *);\n static int        try_constant_tricks           (HOST_WIDE_INT, HOST_WIDE_INT *, HOST_WIDE_INT *);\n static const char *     output_inline_const     (machine_mode, rtx *);\n static void       layout_mcore_frame            (struct mcore_frame *);\n-static void       mcore_setup_incoming_varargs\t(cumulative_args_t, machine_mode, tree, int *, int);\n+static void       mcore_setup_incoming_varargs\t(cumulative_args_t,\n+\t\t\t\t\t\t const function_arg_info &,\n+\t\t\t\t\t\t int *, int);\n static cond_type  is_cond_candidate             (rtx);\n static rtx_insn  *emit_new_cond_insn            (rtx_insn *, int);\n static rtx_insn  *conditionalize_block          (rtx_insn *);\n@@ -1942,7 +1944,7 @@ mcore_initial_elimination_offset (int from, int to)\n \n static void\n mcore_setup_incoming_varargs (cumulative_args_t args_so_far_v,\n-\t\t\t      machine_mode mode, tree type,\n+\t\t\t      const function_arg_info &arg,\n \t\t\t      int * ptr_pretend_size ATTRIBUTE_UNUSED,\n \t\t\t      int second_time ATTRIBUTE_UNUSED)\n {\n@@ -1953,7 +1955,8 @@ mcore_setup_incoming_varargs (cumulative_args_t args_so_far_v,\n   /* We need to know how many argument registers are used before\n      the varargs start, so that we can push the remaining argument\n      registers during the prologue.  */\n-  number_of_regs_before_varargs = *args_so_far + mcore_num_arg_regs (mode, type);\n+  number_of_regs_before_varargs\n+    = *args_so_far + mcore_num_arg_regs (arg.mode, arg.type);\n   \n   /* There is a bug somewhere in the arg handling code.\n      Until I can find it this workaround always pushes the"}, {"sha": "1427e99c7aacf5a07dbdaaa6f5cdb56e93af51eb", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -6544,9 +6544,9 @@ mips_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n /* Implement TARGET_SETUP_INCOMING_VARARGS.  */\n \n static void\n-mips_setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n-\t\t\t     tree type, int *pretend_size ATTRIBUTE_UNUSED,\n-\t\t\t     int no_rtl)\n+mips_setup_incoming_varargs (cumulative_args_t cum,\n+\t\t\t     const function_arg_info &arg,\n+\t\t\t     int *pretend_size ATTRIBUTE_UNUSED, int no_rtl)\n {\n   CUMULATIVE_ARGS local_cum;\n   int gp_saved, fp_saved;\n@@ -6555,8 +6555,8 @@ mips_setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n      argument.  Advance a local copy of CUM past the last \"real\" named\n      argument, to find out how many registers are left over.  */\n   local_cum = *get_cumulative_args (cum);\n-  mips_function_arg_advance (pack_cumulative_args (&local_cum), mode, type,\n-\t\t\t     true);\n+  mips_function_arg_advance (pack_cumulative_args (&local_cum),\n+\t\t\t     arg.mode, arg.type, arg.named);\n \n   /* Found out how many registers we need to save.  */\n   gp_saved = MAX_ARGS_IN_REGISTERS - local_cum.num_gprs;"}, {"sha": "cb70a2dbd40e5f1f57d6622cee037113ff7d286a", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -138,7 +138,7 @@ static void mmix_reorg (void);\n static void mmix_asm_output_mi_thunk\n   (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree);\n static void mmix_setup_incoming_varargs\n-  (cumulative_args_t, machine_mode, tree, int *, int);\n+  (cumulative_args_t, const function_arg_info &, int *, int);\n static void mmix_file_start (void);\n static void mmix_file_end (void);\n static void mmix_init_libfuncs (void);\n@@ -960,8 +960,7 @@ mmix_function_profiler (FILE *stream ATTRIBUTE_UNUSED,\n \n static void\n mmix_setup_incoming_varargs (cumulative_args_t args_so_farp_v,\n-\t\t\t     machine_mode mode,\n-\t\t\t     tree vartype,\n+\t\t\t     const function_arg_info &arg,\n \t\t\t     int *pretend_sizep,\n \t\t\t     int second_time ATTRIBUTE_UNUSED)\n {\n@@ -974,7 +973,7 @@ mmix_setup_incoming_varargs (cumulative_args_t args_so_farp_v,\n \n   /* We assume that one argument takes up one register here.  That should\n      be true until we start messing with multi-reg parameters.  */\n-  if ((7 + (MMIX_FUNCTION_ARG_SIZE (mode, vartype))) / 8 != 1)\n+  if ((7 + (MMIX_FUNCTION_ARG_SIZE (arg.mode, arg.type))) / 8 != 1)\n     internal_error (\"MMIX Internal: Last named vararg would not fit in a register\");\n }\n "}, {"sha": "a8e1bf23c4499c86084b3a8048140333c9aba7e4", "filename": "gcc/config/moxie/moxie.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fmoxie%2Fmoxie.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -385,8 +385,7 @@ moxie_initial_elimination_offset (int from, int to)\n \n static void\n moxie_setup_incoming_varargs (cumulative_args_t cum_v,\n-\t\t\t      machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t      tree type ATTRIBUTE_UNUSED,\n+\t\t\t      const function_arg_info &,\n \t\t\t      int *pretend_size, int no_rtl)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);"}, {"sha": "b076aa4a667a1a0c56c094adf1f01dc4b9d33884", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -2345,8 +2345,7 @@ nds32_warn_func_return (tree decl)\n \n static void\n nds32_setup_incoming_varargs (cumulative_args_t ca,\n-\t\t\t      machine_mode mode,\n-\t\t\t      tree type,\n+\t\t\t      const function_arg_info &arg,\n \t\t\t      int *pretend_args_size,\n \t\t\t      int second_time ATTRIBUTE_UNUSED)\n {\n@@ -2370,14 +2369,14 @@ nds32_setup_incoming_varargs (cumulative_args_t ca,\n \n   cum = get_cumulative_args (ca);\n \n-  /* The MODE and TYPE describe the last argument.\n+  /* ARG describes the last argument.\n      We need those information to determine the remaining registers\n      for varargs.  */\n   total_args_regs\n     = NDS32_MAX_GPR_REGS_FOR_ARGS + NDS32_GPR_ARG_FIRST_REGNUM;\n   num_of_used_regs\n-    = NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG (cum->gpr_offset, mode, type)\n-      + NDS32_NEED_N_REGS_FOR_ARG (mode, type);\n+    = NDS32_AVAILABLE_REGNUM_FOR_GPR_ARG (cum->gpr_offset, arg.mode, arg.type)\n+      + NDS32_NEED_N_REGS_FOR_ARG (arg.mode, arg.type);\n \n   remaining_reg_count = total_args_regs - num_of_used_regs;\n   *pretend_args_size = remaining_reg_count * UNITS_PER_WORD;"}, {"sha": "b93274a12a7bea297fb350ffb720f4a5e59486cb", "filename": "gcc/config/nios2/nios2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fnios2%2Fnios2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fnios2%2Fnios2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -3516,8 +3516,8 @@ nios2_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n    own va_arg type.  */\n static void\n nios2_setup_incoming_varargs (cumulative_args_t cum_v,\n-                              machine_mode mode, tree type,\n-                              int *pretend_size, int second_time)\n+\t\t\t      const function_arg_info &arg,\n+\t\t\t      int *pretend_size, int second_time)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v); \n   CUMULATIVE_ARGS local_cum;\n@@ -3527,7 +3527,7 @@ nios2_setup_incoming_varargs (cumulative_args_t cum_v,\n \n   cfun->machine->uses_anonymous_args = 1;\n   local_cum = *cum;\n-  nios2_function_arg_advance (local_cum_v, mode, type, true);\n+  nios2_function_arg_advance (local_cum_v, arg.mode, arg.type, arg.named);\n \n   regs_to_push = NUM_ARG_REGS - local_cum.regs_used;\n "}, {"sha": "47d9001187c2674b930f560781b0448879a9de21", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -2854,9 +2854,9 @@ riscv_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n /* Implement TARGET_SETUP_INCOMING_VARARGS.  */\n \n static void\n-riscv_setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n-\t\t\t     tree type, int *pretend_size ATTRIBUTE_UNUSED,\n-\t\t\t     int no_rtl)\n+riscv_setup_incoming_varargs (cumulative_args_t cum,\n+\t\t\t      const function_arg_info &arg,\n+\t\t\t      int *pretend_size ATTRIBUTE_UNUSED, int no_rtl)\n {\n   CUMULATIVE_ARGS local_cum;\n   int gp_saved;\n@@ -2865,7 +2865,8 @@ riscv_setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n      argument.  Advance a local copy of CUM past the last \"real\" named\n      argument, to find out how many registers are left over.  */\n   local_cum = *get_cumulative_args (cum);\n-  riscv_function_arg_advance (pack_cumulative_args (&local_cum), mode, type, 1);\n+  riscv_function_arg_advance (pack_cumulative_args (&local_cum),\n+\t\t\t      arg.mode, arg.type, arg.named);\n \n   /* Found out how many registers we need to save.  */\n   gp_saved = MAX_ARGS_IN_REGISTERS - local_cum.num_gprs;"}, {"sha": "874d525c73d2623dc446297f7c74e0dc836d7c07", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -2365,7 +2365,7 @@ rs6000_move_block_from_reg (int regno, rtx x, int nregs)\n \n    CUM is as above.\n \n-   MODE and TYPE are the mode and type of the current parameter.\n+   ARG is the last named argument.\n \n    PRETEND_SIZE is a variable that should be set to the amount of stack\n    that must be pushed by the prolog to pretend that our caller pushed\n@@ -2375,9 +2375,9 @@ rs6000_move_block_from_reg (int regno, rtx x, int nregs)\n    stack and set PRETEND_SIZE to the length of the registers pushed.  */\n \n void\n-setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n-\t\t\ttree type, int *pretend_size ATTRIBUTE_UNUSED,\n-\t\t\tint no_rtl)\n+setup_incoming_varargs (cumulative_args_t cum,\n+\t\t\tconst function_arg_info &arg,\n+\t\t\tint *pretend_size ATTRIBUTE_UNUSED, int no_rtl)\n {\n   CUMULATIVE_ARGS next_cum;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n@@ -2387,7 +2387,7 @@ setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n \n   /* Skip the last named argument.  */\n   next_cum = *get_cumulative_args (cum);\n-  rs6000_function_arg_advance_1 (&next_cum, mode, type, true, 0);\n+  rs6000_function_arg_advance_1 (&next_cum, arg.mode, arg.type, arg.named, 0);\n \n   if (DEFAULT_ABI == ABI_V4)\n     {\n@@ -2461,8 +2461,8 @@ setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n       first_reg_offset = next_cum.words;\n       save_area = crtl->args.internal_arg_pointer;\n \n-      if (targetm.calls.must_pass_in_stack (mode, type))\n-\tfirst_reg_offset += rs6000_arg_size (TYPE_MODE (type), type);\n+      if (targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n+\tfirst_reg_offset += rs6000_arg_size (TYPE_MODE (arg.type), arg.type);\n     }\n \n   set = get_varargs_alias_set ();"}, {"sha": "45a6a7a5e3da52988e79fb946da380ebf89e9f6b", "filename": "gcc/config/rs6000/rs6000-internal.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -152,9 +152,8 @@ extern bool rs6000_return_in_memory (const_tree type,\n extern bool rs6000_return_in_msb (const_tree valtype);\n extern bool rs6000_pass_by_reference (cumulative_args_t,\n \t\t\t\t      const function_arg_info &);\n-extern void setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n-\t\t\t\t    tree type, int *pretend_size ATTRIBUTE_UNUSED,\n-\t\t\t\t    int no_rtl);\n+extern void setup_incoming_varargs (cumulative_args_t,\n+\t\t\t\t    const function_arg_info &, int *, int);\n extern unsigned int rs6000_function_arg_boundary (machine_mode mode,\n \t\t\t\t\t\t  const_tree type);\n extern bool rs6000_must_pass_in_stack (machine_mode mode, const_tree type);"}, {"sha": "bcd82cb75989474356485f8b63a1871d1cb3b6fa", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -280,8 +280,8 @@ static bool sh_function_value_regno_p (const unsigned int);\n static rtx sh_libcall_value (machine_mode, const_rtx);\n static bool sh_return_in_memory (const_tree, const_tree);\n static rtx sh_builtin_saveregs (void);\n-static void sh_setup_incoming_varargs (cumulative_args_t, machine_mode,\n-\t\t\t\t       tree, int *, int);\n+static void sh_setup_incoming_varargs (cumulative_args_t,\n+\t\t\t\t       const function_arg_info &, int *, int);\n static bool sh_strict_argument_naming (cumulative_args_t);\n static bool sh_pretend_outgoing_varargs_named (cumulative_args_t);\n static void sh_atomic_assign_expand_fenv (tree *, tree *, tree *);\n@@ -8184,8 +8184,7 @@ sh_return_in_memory (const_tree type, const_tree fndecl)\n    function that tell if a function uses varargs or stdarg.  */\n static void\n sh_setup_incoming_varargs (cumulative_args_t ca,\n-\t\t\t   machine_mode mode,\n-\t\t\t   tree type,\n+\t\t\t   const function_arg_info &arg,\n \t\t\t   int *pretend_arg_size,\n \t\t\t   int second_time ATTRIBUTE_UNUSED)\n {\n@@ -8194,10 +8193,9 @@ sh_setup_incoming_varargs (cumulative_args_t ca,\n     {\n       int named_parm_regs, anon_parm_regs;\n \n-      named_parm_regs = (sh_round_reg (*get_cumulative_args (ca), mode)\n-\t\t\t + (mode == BLKmode\n-\t\t\t    ? CEIL (int_size_in_bytes (type), UNITS_PER_WORD)\n-\t\t\t    : CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD)));\n+      named_parm_regs = (sh_round_reg (*get_cumulative_args (ca), arg.mode)\n+\t\t\t + CEIL (arg.promoted_size_in_bytes (),\n+\t\t\t\t UNITS_PER_WORD));\n       anon_parm_regs = NPARM_REGS (SImode) - named_parm_regs;\n       if (anon_parm_regs > 0)\n \t*pretend_arg_size = anon_parm_regs * 4;"}, {"sha": "92dd556b3468a0b04fd15447b70d9690280fd047", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -4089,8 +4089,9 @@ spu_gimplify_va_arg_expr (tree valist, tree type, gimple_seq * pre_p,\n    in the stack then save no registers.  Set pretend_args_size to the\n    amount of space needed to save the registers. */\n static void\n-spu_setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n-\t\t\t    tree type, int *pretend_size, int no_rtl)\n+spu_setup_incoming_varargs (cumulative_args_t cum,\n+\t\t\t    const function_arg_info &arg,\n+\t\t\t    int *pretend_size, int no_rtl)\n {\n   if (!no_rtl)\n     {\n@@ -4101,7 +4102,8 @@ spu_setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n \n       /* cum currently points to the last named argument, we want to\n          start at the next argument. */\n-      spu_function_arg_advance (pack_cumulative_args (&ncum), mode, type, true);\n+      spu_function_arg_advance (pack_cumulative_args (&ncum),\n+\t\t\t\targ.mode, arg.type, arg.named);\n \n       offset = -STACK_POINTER_OFFSET;\n       for (regno = ncum; regno < MAX_REGISTER_ARGS; regno++)"}, {"sha": "6f33482548c23ea2f71dbf7c44e9dd0afced2db1", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -390,8 +390,8 @@ tilegx_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n /* Implement TARGET_SETUP_INCOMING_VARARGS.  */\n static void\n tilegx_setup_incoming_varargs (cumulative_args_t cum,\n-\t\t\t       machine_mode mode,\n-\t\t\t       tree type, int *pretend_args, int no_rtl)\n+\t\t\t       const function_arg_info &arg,\n+\t\t\t       int *pretend_args, int no_rtl)\n {\n   CUMULATIVE_ARGS local_cum = *get_cumulative_args (cum);\n   int first_reg;\n@@ -400,7 +400,7 @@ tilegx_setup_incoming_varargs (cumulative_args_t cum,\n      argument.  Advance a local copy of CUM past the last \"real\" named\n      argument, to find out how many registers are left over.  */\n   targetm.calls.function_arg_advance (pack_cumulative_args (&local_cum),\n-\t\t\t\t      mode, type, true);\n+\t\t\t\t      arg.mode, arg.type, arg.named);\n   first_reg = local_cum;\n \n   if (local_cum < TILEGX_NUM_ARG_REGS)"}, {"sha": "dd537712a5051027a5040b4f12c22c0cca4d83cb", "filename": "gcc/config/tilepro/tilepro.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -342,8 +342,8 @@ tilepro_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n /* Implement TARGET_SETUP_INCOMING_VARARGS.  */\n static void\n tilepro_setup_incoming_varargs (cumulative_args_t cum,\n-\t\t\t\tmachine_mode mode,\n-\t\t\t\ttree type, int *pretend_args, int no_rtl)\n+\t\t\t\tconst function_arg_info &arg,\n+\t\t\t\tint *pretend_args, int no_rtl)\n {\n   CUMULATIVE_ARGS local_cum = *get_cumulative_args (cum);\n   int first_reg;\n@@ -352,7 +352,7 @@ tilepro_setup_incoming_varargs (cumulative_args_t cum,\n      argument.  Advance a local copy of CUM past the last \"real\" named\n      argument, to find out how many registers are left over.  */\n   targetm.calls.function_arg_advance (pack_cumulative_args (&local_cum),\n-\t\t\t\t      mode, type, true);\n+\t\t\t\t      arg.mode, arg.type, arg.named);\n   first_reg = local_cum;\n \n   if (local_cum < TILEPRO_NUM_ARG_REGS)"}, {"sha": "2dd261a5d73d6bd867351a86cc0a29a9401695ee", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -175,8 +175,8 @@ static rtx visium_function_value (const_tree, const_tree fn_decl_or_type,\n static rtx visium_libcall_value (machine_mode, const_rtx);\n \n static void visium_setup_incoming_varargs (cumulative_args_t,\n-\t\t\t\t\t   machine_mode,\n-\t\t\t\t\t   tree, int *, int);\n+\t\t\t\t\t   const function_arg_info &,\n+\t\t\t\t\t   int *, int);\n \n static void visium_va_start (tree valist, rtx nextarg);\n \n@@ -1460,8 +1460,7 @@ visium_libcall_value (machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n \n static void\n visium_setup_incoming_varargs (cumulative_args_t pcum_v,\n-\t\t\t       machine_mode mode,\n-\t\t\t       tree type,\n+\t\t\t       const function_arg_info &arg,\n \t\t\t       int *pretend_size ATTRIBUTE_UNUSED,\n \t\t\t       int no_rtl)\n {\n@@ -1487,7 +1486,8 @@ visium_setup_incoming_varargs (cumulative_args_t pcum_v,\n   /* The caller has advanced ARGS_SO_FAR up to, but not beyond, the last named\n      argument.  Advance a local copy of ARGS_SO_FAR past the last \"real\" named\n      argument, to find out how many registers are left over.  */\n-  TARGET_FUNCTION_ARG_ADVANCE (local_args_so_far, mode, type, 1);\n+  TARGET_FUNCTION_ARG_ADVANCE (local_args_so_far, arg.mode,\n+\t\t\t       arg.type, arg.named);\n \n   /* Find how many registers we need to save.  */\n   locargs = get_cumulative_args (local_args_so_far);"}, {"sha": "6beb578d3c991e8fe5846a5275a023599eb4dea8", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -5202,7 +5202,7 @@ return value of this function should be an RTX that contains the value\n to use as the return of @code{__builtin_saveregs}.\n @end deftypefn\n \n-@deftypefn {Target Hook} void TARGET_SETUP_INCOMING_VARARGS (cumulative_args_t @var{args_so_far}, machine_mode @var{mode}, tree @var{type}, int *@var{pretend_args_size}, int @var{second_time})\n+@deftypefn {Target Hook} void TARGET_SETUP_INCOMING_VARARGS (cumulative_args_t @var{args_so_far}, const function_arg_info @var{&arg}, int *@var{pretend_args_size}, int @var{second_time})\n This target hook offers an alternative to using\n @code{__builtin_saveregs} and defining the hook\n @code{TARGET_EXPAND_BUILTIN_SAVEREGS}.  Use it to store the anonymous\n@@ -5213,8 +5213,8 @@ pass all their arguments on the stack.\n \n The argument @var{args_so_far} points to the @code{CUMULATIVE_ARGS} data\n structure, containing the values that are obtained after processing the\n-named arguments.  The arguments @var{mode} and @var{type} describe the\n-last named argument---its machine mode and its data type as a tree node.\n+named arguments.  The argument @var{arg} describes the last of these named\n+arguments.\n \n The target hook should do two things: first, push onto the stack all the\n argument registers @emph{not} used for the named arguments, and second,"}, {"sha": "ad61662943e43818e7b44e5c77fb7bea51247e4b", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -2485,9 +2485,9 @@ assign_parms_setup_varargs (struct assign_parm_data_all *all,\n {\n   int varargs_pretend_bytes = 0;\n \n-  targetm.calls.setup_incoming_varargs (all->args_so_far,\n-\t\t\t\t\tdata->promoted_mode,\n-\t\t\t\t\tdata->passed_type,\n+  function_arg_info last_named_arg (data->passed_type, data->promoted_mode,\n+\t\t\t\t    /*named=*/true);\n+  targetm.calls.setup_incoming_varargs (all->args_so_far, last_named_arg,\n \t\t\t\t\t&varargs_pretend_bytes, no_rtl);\n \n   /* If the back-end has requested extra stack space, record how much is"}, {"sha": "1756314981fe3273c3508cdc3759573007f2456a", "filename": "gcc/target.def", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -4486,8 +4486,8 @@ pass all their arguments on the stack.\\n\\\n \\n\\\n The argument @var{args_so_far} points to the @code{CUMULATIVE_ARGS} data\\n\\\n structure, containing the values that are obtained after processing the\\n\\\n-named arguments.  The arguments @var{mode} and @var{type} describe the\\n\\\n-last named argument---its machine mode and its data type as a tree node.\\n\\\n+named arguments.  The argument @var{arg} describes the last of these named\\n\\\n+arguments.\\n\\\n \\n\\\n The target hook should do two things: first, push onto the stack all the\\n\\\n argument registers @emph{not} used for the named arguments, and second,\\n\\\n@@ -4507,7 +4507,7 @@ arguments of the function are being analyzed for the second time.  This\\n\\\n happens for an inline function, which is not actually compiled until the\\n\\\n end of the source file.  The hook @code{TARGET_SETUP_INCOMING_VARARGS} should\\n\\\n not generate any instructions in this case.\",\n- void, (cumulative_args_t args_so_far, machine_mode mode, tree type,\n+ void, (cumulative_args_t args_so_far, const function_arg_info &arg,\n \tint *pretend_args_size, int second_time),\n  default_setup_incoming_varargs)\n "}, {"sha": "854f2404faea23a715aabdc3e821b059da53b204", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -193,11 +193,8 @@ default_expand_builtin_saveregs (void)\n }\n \n void\n-default_setup_incoming_varargs (cumulative_args_t ca ATTRIBUTE_UNUSED,\n-\t\t\t\tmachine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t\ttree type ATTRIBUTE_UNUSED,\n-\t\t\t\tint *pretend_arg_size ATTRIBUTE_UNUSED,\n-\t\t\t\tint second_time ATTRIBUTE_UNUSED)\n+default_setup_incoming_varargs (cumulative_args_t,\n+\t\t\t\tconst function_arg_info &, int *, int)\n {\n }\n "}, {"sha": "34bb3c0430de61422a57fd575109055a2347e19d", "filename": "gcc/targhooks.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7056ca417326a70eca05defb6a8b20b737d3417/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=e7056ca417326a70eca05defb6a8b20b737d3417", "patch": "@@ -40,7 +40,9 @@ extern machine_mode default_cc_modes_compatible (machine_mode,\n extern bool default_return_in_memory (const_tree, const_tree);\n \n extern rtx default_expand_builtin_saveregs (void);\n-extern void default_setup_incoming_varargs (cumulative_args_t, machine_mode, tree, int *, int);\n+extern void default_setup_incoming_varargs (cumulative_args_t,\n+\t\t\t\t\t    const function_arg_info &,\n+\t\t\t\t\t    int *, int);\n extern rtx default_builtin_setjmp_frame_value (void);\n extern bool default_pretend_outgoing_varargs_named (cumulative_args_t);\n "}]}