{"sha": "f802a42401e16c7b918cee539e3c38f4d6f7a336", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgwMmE0MjQwMWUxNmM3YjkxOGNlZTUzOWUzYzM4ZjRkNmY3YTMzNg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2016-02-24T14:54:01Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-02-24T14:54:01Z"}, "message": "re PR tree-optimization/69760 (Wrong 64-bit memory address caused by an unneeded overflowing 32-bit integer multiplication on x86_64 under -O2 and -O3 code optimization)\n\n2016-02-24  Richard Biener  <rguenther@suse.de>\n\tJakub Jelinek  <jakub@redhat.com>\n\n\tPR middle-end/69760\n\t* tree-scalar-evolution.c (interpret_rhs_expr): Re-write\n\tconditionally executed ops to well-defined overflow behavior.\n\n\t* gcc.dg/torture/pr69760.c: New testcase.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r233669", "tree": {"sha": "2abaef0504af1d06e7a5df00c463d575dd11e6a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2abaef0504af1d06e7a5df00c463d575dd11e6a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f802a42401e16c7b918cee539e3c38f4d6f7a336", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f802a42401e16c7b918cee539e3c38f4d6f7a336", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f802a42401e16c7b918cee539e3c38f4d6f7a336", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f802a42401e16c7b918cee539e3c38f4d6f7a336/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "525f795f86f448a6cedb6b35317ae28de64d23e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/525f795f86f448a6cedb6b35317ae28de64d23e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/525f795f86f448a6cedb6b35317ae28de64d23e0"}], "stats": {"total": 133, "additions": 120, "deletions": 13}, "files": [{"sha": "0c2c960612c93b240909c5968c5c9e1bc3424879", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f802a42401e16c7b918cee539e3c38f4d6f7a336/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f802a42401e16c7b918cee539e3c38f4d6f7a336/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f802a42401e16c7b918cee539e3c38f4d6f7a336", "patch": "@@ -1,3 +1,10 @@\n+2016-02-24  Richard Biener  <rguenther@suse.de>\n+\tJakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/69760\n+\t* tree-scalar-evolution.c (interpret_rhs_expr): Re-write\n+\tconditionally executed ops to well-defined overflow behavior.\n+\n 2016-02-24  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/69915"}, {"sha": "2e4158839c9d6160b86d35f508b73572fb43c6ec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f802a42401e16c7b918cee539e3c38f4d6f7a336/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f802a42401e16c7b918cee539e3c38f4d6f7a336/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f802a42401e16c7b918cee539e3c38f4d6f7a336", "patch": "@@ -1,3 +1,9 @@\n+2016-02-24  Richard Biener  <rguenther@suse.de>\n+\tJakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/69760\n+\t* gcc.dg/torture/pr69760.c: New testcase.\n+\n 2016-02-24  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* gcc.dg/debug/dwarf2/prod-options.c: Use different DW_AT_producer"}, {"sha": "8f24608d232f9a064567dc36fe2ade6155447eb7", "filename": "gcc/testsuite/gcc.dg/torture/pr69760.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f802a42401e16c7b918cee539e3c38f4d6f7a336/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr69760.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f802a42401e16c7b918cee539e3c38f4d6f7a336/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr69760.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr69760.c?ref=f802a42401e16c7b918cee539e3c38f4d6f7a336", "patch": "@@ -0,0 +1,50 @@\n+/* PR tree-optimization/69760 */\n+/* { dg-do run { target { { *-*-linux* *-*-gnu* } && mmap } } } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <unistd.h>\n+#include <sys/mman.h>\n+\n+__attribute__((noinline, noclone)) void\n+test_func (double *a, int L, int m, int n, int N)\n+{\n+  int i, k;\n+  for (i = 0; i < N; i++)\n+    {\n+      k = i - m;\n+      if (k >= 0 && k < n)\n+\ta[L * k] = 0.0;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  char *p;\n+  int L, m, n, N;\n+  long l;\n+  L = 10000000;\n+  n = 4;\n+  N = 100 * n;\n+  long pgsz = sysconf(_SC_PAGESIZE);\n+  if (pgsz < sizeof (double) || pgsz > L * sizeof (double))\n+    return 0;\n+  p = mmap ((void *) 0, L * n * sizeof (double), PROT_NONE,\n+\t    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+  if (p == MAP_FAILED)\n+    return 0;\n+  if (mprotect (p, pgsz, PROT_READ | PROT_WRITE))\n+    return 0;\n+  l = (L * sizeof (double)) / pgsz * pgsz;\n+  if (mprotect (p + l, pgsz, PROT_READ | PROT_WRITE))\n+    return 0;\n+  l = (2 * L * sizeof (double)) / pgsz * pgsz;\n+  if (mprotect (p + l, pgsz, PROT_READ | PROT_WRITE))\n+    return 0;\n+  l = (3 * L * sizeof (double)) / pgsz * pgsz;\n+  if (mprotect (p + l, pgsz, PROT_READ | PROT_WRITE))\n+    return 0;\n+  for (m = 0; m < N; m += n)\n+    test_func ((double *) p, L, m, n, N);\n+  return 0;\n+}"}, {"sha": "fdd5da0589a86c0405db79655a205f08f9cbe801", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f802a42401e16c7b918cee539e3c38f4d6f7a336/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f802a42401e16c7b918cee539e3c38f4d6f7a336/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=f802a42401e16c7b918cee539e3c38f4d6f7a336", "patch": "@@ -1703,7 +1703,7 @@ static tree\n interpret_rhs_expr (struct loop *loop, gimple *at_stmt,\n \t\t    tree type, tree rhs1, enum tree_code code, tree rhs2)\n {\n-  tree res, chrec1, chrec2;\n+  tree res, chrec1, chrec2, ctype;\n   gimple *def;\n \n   if (get_gimple_rhs_class (code) == GIMPLE_SINGLE_RHS)\n@@ -1798,30 +1798,63 @@ interpret_rhs_expr (struct loop *loop, gimple *at_stmt,\n     case PLUS_EXPR:\n       chrec1 = analyze_scalar_evolution (loop, rhs1);\n       chrec2 = analyze_scalar_evolution (loop, rhs2);\n-      chrec1 = chrec_convert (type, chrec1, at_stmt);\n-      chrec2 = chrec_convert (type, chrec2, at_stmt);\n+      ctype = type;\n+      /* When the stmt is conditionally executed re-write the CHREC\n+         into a form that has well-defined behavior on overflow.  */\n+      if (at_stmt\n+\t  && INTEGRAL_TYPE_P (type)\n+\t  && ! TYPE_OVERFLOW_WRAPS (type)\n+\t  && ! dominated_by_p (CDI_DOMINATORS, loop->latch,\n+\t\t\t       gimple_bb (at_stmt)))\n+\tctype = unsigned_type_for (type);\n+      chrec1 = chrec_convert (ctype, chrec1, at_stmt);\n+      chrec2 = chrec_convert (ctype, chrec2, at_stmt);\n       chrec1 = instantiate_parameters (loop, chrec1);\n       chrec2 = instantiate_parameters (loop, chrec2);\n-      res = chrec_fold_plus (type, chrec1, chrec2);\n+      res = chrec_fold_plus (ctype, chrec1, chrec2);\n+      if (type != ctype)\n+\tres = chrec_convert (type, res, at_stmt);\n       break;\n \n     case MINUS_EXPR:\n       chrec1 = analyze_scalar_evolution (loop, rhs1);\n       chrec2 = analyze_scalar_evolution (loop, rhs2);\n-      chrec1 = chrec_convert (type, chrec1, at_stmt);\n-      chrec2 = chrec_convert (type, chrec2, at_stmt);\n+      ctype = type;\n+      /* When the stmt is conditionally executed re-write the CHREC\n+         into a form that has well-defined behavior on overflow.  */\n+      if (at_stmt\n+\t  && INTEGRAL_TYPE_P (type)\n+\t  && ! TYPE_OVERFLOW_WRAPS (type)\n+\t  && ! dominated_by_p (CDI_DOMINATORS,\n+\t\t\t       loop->latch, gimple_bb (at_stmt)))\n+\tctype = unsigned_type_for (type);\n+      chrec1 = chrec_convert (ctype, chrec1, at_stmt);\n+      chrec2 = chrec_convert (ctype, chrec2, at_stmt);\n       chrec1 = instantiate_parameters (loop, chrec1);\n       chrec2 = instantiate_parameters (loop, chrec2);\n-      res = chrec_fold_minus (type, chrec1, chrec2);\n+      res = chrec_fold_minus (ctype, chrec1, chrec2);\n+      if (type != ctype)\n+\tres = chrec_convert (type, res, at_stmt);\n       break;\n \n     case NEGATE_EXPR:\n       chrec1 = analyze_scalar_evolution (loop, rhs1);\n-      chrec1 = chrec_convert (type, chrec1, at_stmt);\n+      ctype = type;\n+      /* When the stmt is conditionally executed re-write the CHREC\n+         into a form that has well-defined behavior on overflow.  */\n+      if (at_stmt\n+\t  && INTEGRAL_TYPE_P (type)\n+\t  && ! TYPE_OVERFLOW_WRAPS (type)\n+\t  && ! dominated_by_p (CDI_DOMINATORS,\n+\t\t\t       loop->latch, gimple_bb (at_stmt)))\n+\tctype = unsigned_type_for (type);\n+      chrec1 = chrec_convert (ctype, chrec1, at_stmt);\n       /* TYPE may be integer, real or complex, so use fold_convert.  */\n       chrec1 = instantiate_parameters (loop, chrec1);\n-      res = chrec_fold_multiply (type, chrec1,\n-\t\t\t\t fold_convert (type, integer_minus_one_node));\n+      res = chrec_fold_multiply (ctype, chrec1,\n+\t\t\t\t fold_convert (ctype, integer_minus_one_node));\n+      if (type != ctype)\n+\tres = chrec_convert (type, res, at_stmt);\n       break;\n \n     case BIT_NOT_EXPR:\n@@ -1837,11 +1870,22 @@ interpret_rhs_expr (struct loop *loop, gimple *at_stmt,\n     case MULT_EXPR:\n       chrec1 = analyze_scalar_evolution (loop, rhs1);\n       chrec2 = analyze_scalar_evolution (loop, rhs2);\n-      chrec1 = chrec_convert (type, chrec1, at_stmt);\n-      chrec2 = chrec_convert (type, chrec2, at_stmt);\n+      ctype = type;\n+      /* When the stmt is conditionally executed re-write the CHREC\n+         into a form that has well-defined behavior on overflow.  */\n+      if (at_stmt\n+\t  && INTEGRAL_TYPE_P (type)\n+\t  && ! TYPE_OVERFLOW_WRAPS (type)\n+\t  && ! dominated_by_p (CDI_DOMINATORS,\n+\t\t\t       loop->latch, gimple_bb (at_stmt)))\n+\tctype = unsigned_type_for (type);\n+      chrec1 = chrec_convert (ctype, chrec1, at_stmt);\n+      chrec2 = chrec_convert (ctype, chrec2, at_stmt);\n       chrec1 = instantiate_parameters (loop, chrec1);\n       chrec2 = instantiate_parameters (loop, chrec2);\n-      res = chrec_fold_multiply (type, chrec1, chrec2);\n+      res = chrec_fold_multiply (ctype, chrec1, chrec2);\n+      if (type != ctype)\n+\tres = chrec_convert (type, res, at_stmt);\n       break;\n \n     case LSHIFT_EXPR:"}]}