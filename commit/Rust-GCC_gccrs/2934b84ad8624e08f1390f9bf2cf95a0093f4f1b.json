{"sha": "2934b84ad8624e08f1390f9bf2cf95a0093f4f1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjkzNGI4NGFkODYyNGUwOGYxMzkwZjliZjJjZjk1YTAwOTNmNGYxYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-23T10:11:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-23T10:11:21Z"}, "message": "[multiple changes]\n\n2014-10-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* checks.adb (Ensure_Valid): Update the subprogram\n\tprofile. Propagate the contex attributes to Insert_Valid_Check.\n\t(Insert_Valid_Check): Update the subprogram profile. Propagate\n\tthe attributes of the context to Duplicate_Subexpr_No_Checks.\n\t(Validity_Check_Range): Update the subprogram profile. Propagate\n\tthe context attribute to Ensure_Valid.\n\t* checks.ads (Ensure_Valid): Update the subprogram profile\n\talong with the comment on usage.\n\t(Insert_Valid_Check): Update the subprogram profile along with the\n\tcomment on usage.\n\t(Validity_Check_Range): Update the subprogram profile along with\n\tthe comment on usage.\n\t* exp_util.adb (Build_Temporary): New routine.\n\t(Duplicate_Subexpr_No_Checks): Update the subprogram\n\tprofile. Propagate the attributes of the context to Remove_Side_Effects.\n\t(Remove_Side_Effects): Update the subprogram profile. Update all calls\n\tto Make_Temporary to invoke Build_Temporary.\n\t* exp_util.ads (Duplicate_Subexpr_No_Checks): Update\n\tthe subprogram profile along with the comment on usage.\n\t(Remove_Side_Effects): Update the subprogram profile along with\n\tthe comment on usage.\n\t* sem_ch3.adb (Process_Range_Expr_In_Decl): Pass the subtype\n\tto the validity check machinery.  Explain the reason for this\n\tpropagation.\n\n2014-10-23  Robert Dewar  <dewar@adacore.com>\n\n\t* a-strsea.adb: Minor reformatting.\n\nFrom-SVN: r216581", "tree": {"sha": "9524c6826a5f9f1e6e163cbfe6c0dd6e078260b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9524c6826a5f9f1e6e163cbfe6c0dd6e078260b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2934b84ad8624e08f1390f9bf2cf95a0093f4f1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2934b84ad8624e08f1390f9bf2cf95a0093f4f1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2934b84ad8624e08f1390f9bf2cf95a0093f4f1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2934b84ad8624e08f1390f9bf2cf95a0093f4f1b/comments", "author": null, "committer": null, "parents": [{"sha": "3fdb58e2eb3b2dbb3ec9bb12daf8c02fcc387e9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fdb58e2eb3b2dbb3ec9bb12daf8c02fcc387e9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fdb58e2eb3b2dbb3ec9bb12daf8c02fcc387e9e"}], "stats": {"total": 316, "additions": 243, "deletions": 73}, "files": [{"sha": "85917acb087e18d22ca6c4c567582f6a9d477b6f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2934b84ad8624e08f1390f9bf2cf95a0093f4f1b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2934b84ad8624e08f1390f9bf2cf95a0093f4f1b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2934b84ad8624e08f1390f9bf2cf95a0093f4f1b", "patch": "@@ -1,3 +1,34 @@\n+2014-10-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* checks.adb (Ensure_Valid): Update the subprogram\n+\tprofile. Propagate the contex attributes to Insert_Valid_Check.\n+\t(Insert_Valid_Check): Update the subprogram profile. Propagate\n+\tthe attributes of the context to Duplicate_Subexpr_No_Checks.\n+\t(Validity_Check_Range): Update the subprogram profile. Propagate\n+\tthe context attribute to Ensure_Valid.\n+\t* checks.ads (Ensure_Valid): Update the subprogram profile\n+\talong with the comment on usage.\n+\t(Insert_Valid_Check): Update the subprogram profile along with the\n+\tcomment on usage.\n+\t(Validity_Check_Range): Update the subprogram profile along with\n+\tthe comment on usage.\n+\t* exp_util.adb (Build_Temporary): New routine.\n+\t(Duplicate_Subexpr_No_Checks): Update the subprogram\n+\tprofile. Propagate the attributes of the context to Remove_Side_Effects.\n+\t(Remove_Side_Effects): Update the subprogram profile. Update all calls\n+\tto Make_Temporary to invoke Build_Temporary.\n+\t* exp_util.ads (Duplicate_Subexpr_No_Checks): Update\n+\tthe subprogram profile along with the comment on usage.\n+\t(Remove_Side_Effects): Update the subprogram profile along with\n+\tthe comment on usage.\n+\t* sem_ch3.adb (Process_Range_Expr_In_Decl): Pass the subtype\n+\tto the validity check machinery.  Explain the reason for this\n+\tpropagation.\n+\n+2014-10-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-strsea.adb: Minor reformatting.\n+\n 2014-10-23  Thomas Quinot  <quinot@adacore.com>\n \n \t* bcheck.adb (Check_Consistent_SSO_Default): Exclude internal"}, {"sha": "dd3d75c143a37837b854761679fcb91e424b8296", "filename": "gcc/ada/a-strsea.adb", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2934b84ad8624e08f1390f9bf2cf95a0093f4f1b/gcc%2Fada%2Fa-strsea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2934b84ad8624e08f1390f9bf2cf95a0093f4f1b/gcc%2Fada%2Fa-strsea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strsea.adb?ref=2934b84ad8624e08f1390f9bf2cf95a0093f4f1b", "patch": "@@ -241,14 +241,6 @@ package body Ada.Strings.Search is\n       First  : out Positive;\n       Last   : out Natural)\n    is\n-\n-      --  RM 2005 A.4.3 (68/1)) specifies that an exception must be raised if\n-      --  Source'First is not positive and is assigned to First. Formulation\n-      --  is slightly different in RM 2012, but the intent seems similar, so\n-      --  we enable range checks for this routine.\n-\n-      pragma Unsuppress (Range_Check);\n-\n    begin\n       for J in Source'Range loop\n          if Belongs (Source (J), Set, Test) then\n@@ -271,8 +263,18 @@ package body Ada.Strings.Search is\n \n       --  Here if no token found\n \n-      First := Source'First;\n-      Last  := 0;\n+      --  RM 2005 A.4.3 (68/1)) specifies that an exception must be raised if\n+      --  Source'First is not positive and is assigned to First. Formulation\n+      --  is slightly different in RM 2012, but the intent seems similar, so\n+      --  we check explicitly for that condition.\n+\n+      if Source'First not in Positive then\n+         raise Constraint_Error;\n+\n+      else\n+         First := Source'First;\n+         Last  := 0;\n+      end if;\n    end Find_Token;\n \n    -----------"}, {"sha": "046c5177f3c7dfde44b774e80814ca8d748fb40a", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 44, "deletions": 17, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2934b84ad8624e08f1390f9bf2cf95a0093f4f1b/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2934b84ad8624e08f1390f9bf2cf95a0093f4f1b/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=2934b84ad8624e08f1390f9bf2cf95a0093f4f1b", "patch": "@@ -5627,7 +5627,13 @@ package body Checks is\n    -- Ensure_Valid --\n    ------------------\n \n-   procedure Ensure_Valid (Expr : Node_Id; Holes_OK : Boolean := False) is\n+   procedure Ensure_Valid\n+     (Expr          : Node_Id;\n+      Holes_OK      : Boolean   := False;\n+      Related_Id    : Entity_Id := Empty;\n+      Is_Low_Bound  : Boolean   := False;\n+      Is_High_Bound : Boolean   := False)\n+   is\n       Typ : constant Entity_Id  := Etype (Expr);\n \n    begin\n@@ -5793,7 +5799,7 @@ package body Checks is\n \n       --  If we fall through, a validity check is required\n \n-      Insert_Valid_Check (Expr);\n+      Insert_Valid_Check (Expr, Related_Id, Is_Low_Bound, Is_High_Bound);\n \n       if Is_Entity_Name (Expr)\n         and then Safe_To_Capture_Value (Expr, Entity (Expr))\n@@ -6996,14 +7002,19 @@ package body Checks is\n    -- Insert_Valid_Check --\n    ------------------------\n \n-   procedure Insert_Valid_Check (Expr : Node_Id) is\n+   procedure Insert_Valid_Check\n+     (Expr          : Node_Id;\n+      Related_Id    : Entity_Id := Empty;\n+      Is_Low_Bound  : Boolean   := False;\n+      Is_High_Bound : Boolean   := False)\n+   is\n       Loc : constant Source_Ptr := Sloc (Expr);\n       Typ : constant Entity_Id  := Etype (Expr);\n       Exp : Node_Id;\n \n    begin\n-      --  Do not insert if checks off, or if not checking validity or\n-      --  if expression is known to be valid\n+      --  Do not insert if checks off, or if not checking validity or if\n+      --  expression is known to be valid.\n \n       if not Validity_Checks_On\n         or else Range_Or_Validity_Checks_Suppressed (Expr)\n@@ -7073,7 +7084,13 @@ package body Checks is\n \n          --  Build the prefix for the 'Valid call\n \n-         PV := Duplicate_Subexpr_No_Checks (Exp, Name_Req => False);\n+         PV :=\n+           Duplicate_Subexpr_No_Checks\n+             (Exp           => Exp,\n+              Name_Req      => False,\n+              Related_Id    => Related_Id,\n+              Is_Low_Bound  => Is_Low_Bound,\n+              Is_High_Bound => Is_High_Bound);\n \n          --  A rather specialized test. If PV is an analyzed expression which\n          --  is an indexed component of a packed array that has not been\n@@ -7098,14 +7115,14 @@ package body Checks is\n          --  a name, and we don't care in this context!\n \n          CE :=\n-            Make_Raise_Constraint_Error (Loc,\n-              Condition =>\n-                Make_Op_Not (Loc,\n-                  Right_Opnd =>\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix         => PV,\n-                      Attribute_Name => Name_Valid)),\n-              Reason => CE_Invalid_Data);\n+           Make_Raise_Constraint_Error (Loc,\n+             Condition =>\n+               Make_Op_Not (Loc,\n+                 Right_Opnd =>\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix         => PV,\n+                     Attribute_Name => Name_Valid)),\n+             Reason    => CE_Invalid_Data);\n \n          --  Insert the validity check. Note that we do this with validity\n          --  checks turned off, to avoid recursion, we do not want validity\n@@ -10113,12 +10130,22 @@ package body Checks is\n    -- Validity_Check_Range --\n    --------------------------\n \n-   procedure Validity_Check_Range (N : Node_Id) is\n+   procedure Validity_Check_Range\n+     (N          : Node_Id;\n+      Related_Id : Entity_Id := Empty)\n+   is\n    begin\n       if Validity_Checks_On and Validity_Check_Operands then\n          if Nkind (N) = N_Range then\n-            Ensure_Valid (Low_Bound (N));\n-            Ensure_Valid (High_Bound (N));\n+            Ensure_Valid\n+              (Expr          => Low_Bound (N),\n+               Related_Id    => Related_Id,\n+               Is_Low_Bound  => True);\n+\n+            Ensure_Valid\n+              (Expr          => High_Bound (N),\n+               Related_Id    => Related_Id,\n+               Is_High_Bound => True);\n          end if;\n       end if;\n    end Validity_Check_Range;"}, {"sha": "15a456b111748fbfe6f5d8cf0d79ca9612d66655", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2934b84ad8624e08f1390f9bf2cf95a0093f4f1b/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2934b84ad8624e08f1390f9bf2cf95a0093f4f1b/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=2934b84ad8624e08f1390f9bf2cf95a0093f4f1b", "patch": "@@ -849,7 +849,12 @@ package Checks is\n    --  13.9.1(9-11)) such assignments are not permitted to result in erroneous\n    --  behavior in the case of invalid subscript values.\n \n-   procedure Ensure_Valid (Expr : Node_Id; Holes_OK : Boolean := False);\n+   procedure Ensure_Valid\n+     (Expr          : Node_Id;\n+      Holes_OK      : Boolean   := False;\n+      Related_Id    : Entity_Id := Empty;\n+      Is_Low_Bound  : Boolean   := False;\n+      Is_High_Bound : Boolean   := False);\n    --  Ensure that Expr represents a valid value of its type. If this type\n    --  is not a scalar type, then the call has no effect, since validity\n    --  is only an issue for scalar types. The effect of this call is to\n@@ -865,6 +870,12 @@ package Checks is\n    --  will make a separate check for this case anyway). If Holes_OK is False,\n    --  then this case is checked, and code is inserted to ensure that Expr is\n    --  valid, raising Constraint_Error if the value is not valid.\n+   --\n+   --  Related_Id denotes the entity of the context where Expr appears. Flags\n+   --  Is_Low_Bound and Is_High_Bound specify whether the expression to check\n+   --  is the low or the high bound of a range. These three optional arguments\n+   --  signal Remove_Side_Effects to create an external symbol of the form\n+   --  Chars (Related_Id)_FIRST/_LAST.\n \n    function Expr_Known_Valid (Expr : Node_Id) return Boolean;\n    --  This function tests it the value of Expr is known to be valid in the\n@@ -876,10 +887,20 @@ package Checks is\n    --  it can be determined that the value is Valid. Otherwise False is\n    --  returned.\n \n-   procedure Insert_Valid_Check (Expr : Node_Id);\n-   --  Inserts code that will check for the value of Expr being valid, in\n-   --  the sense of the 'Valid attribute returning True. Constraint_Error\n-   --  will be raised if the value is not valid.\n+   procedure Insert_Valid_Check\n+     (Expr          : Node_Id;\n+      Related_Id    : Entity_Id := Empty;\n+      Is_Low_Bound  : Boolean   := False;\n+      Is_High_Bound : Boolean   := False);\n+   --  Inserts code that will check for the value of Expr being valid, in the\n+   --  sense of the 'Valid attribute returning True. Constraint_Error will be\n+   --  raised if the value is not valid.\n+   --\n+   --  Related_Id denotes the entity of the context where Expr appears. Flags\n+   --  Is_Low_Bound and Is_High_Bound specify whether the expression to check\n+   --  is the low or the high bound of a range. These three optional arguments\n+   --  signal Remove_Side_Effects to create an external symbol of the form\n+   --  Chars (Related_Id)_FIRST/_LAST.\n \n    procedure Null_Exclusion_Static_Checks (N : Node_Id);\n    --  Ada 2005 (AI-231): Check bad usages of the null-exclusion issue\n@@ -889,9 +910,12 @@ package Checks is\n    --  conditionally (on the right side of And Then/Or Else. This call\n    --  removes only embedded checks (Do_Range_Check, Do_Overflow_Check).\n \n-   procedure Validity_Check_Range (N : Node_Id);\n-   --  If N is an N_Range node, then Ensure_Valid is called on its bounds,\n-   --  if validity checking of operands is enabled.\n+   procedure Validity_Check_Range\n+     (N          : Node_Id;\n+      Related_Id : Entity_Id := Empty);\n+   --  If N is an N_Range node, then Ensure_Valid is called on its bounds, if\n+   --  validity checking of operands is enabled. Related_Id denotes the entity\n+   --  of the context where N appears.\n \n    -----------------------------\n    -- Handling of Check Names --"}, {"sha": "b43731d30eb1a8e19b9119dc97abb5115cf67ef1", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 70, "deletions": 16, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2934b84ad8624e08f1390f9bf2cf95a0093f4f1b/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2934b84ad8624e08f1390f9bf2cf95a0093f4f1b/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=2934b84ad8624e08f1390f9bf2cf95a0093f4f1b", "patch": "@@ -1922,14 +1922,24 @@ package body Exp_Util is\n    ---------------------------------\n \n    function Duplicate_Subexpr_No_Checks\n-     (Exp          : Node_Id;\n-      Name_Req     : Boolean := False;\n-      Renaming_Req : Boolean := False) return Node_Id\n+     (Exp           : Node_Id;\n+      Name_Req      : Boolean   := False;\n+      Renaming_Req  : Boolean   := False;\n+      Related_Id    : Entity_Id := Empty;\n+      Is_Low_Bound  : Boolean   := False;\n+      Is_High_Bound : Boolean   := False) return Node_Id\n    is\n       New_Exp : Node_Id;\n \n    begin\n-      Remove_Side_Effects (Exp, Name_Req, Renaming_Req);\n+      Remove_Side_Effects\n+        (Exp           => Exp,\n+         Name_Req      => Name_Req,\n+         Renaming_Req  => Renaming_Req,\n+         Related_Id    => Related_Id,\n+         Is_Low_Bound  => Is_Low_Bound,\n+         Is_High_Bound => Is_High_Bound);\n+\n       New_Exp := New_Copy_Tree (Exp);\n       Remove_Checks (New_Exp);\n       return New_Exp;\n@@ -7188,11 +7198,53 @@ package body Exp_Util is\n    -------------------------\n \n    procedure Remove_Side_Effects\n-     (Exp          : Node_Id;\n-      Name_Req     : Boolean := False;\n-      Renaming_Req : Boolean := False;\n-      Variable_Ref : Boolean := False)\n+     (Exp           : Node_Id;\n+      Name_Req      : Boolean   := False;\n+      Renaming_Req  : Boolean   := False;\n+      Variable_Ref  : Boolean   := False;\n+      Related_Id    : Entity_Id := Empty;\n+      Is_Low_Bound  : Boolean   := False;\n+      Is_High_Bound : Boolean   := False)\n    is\n+      function Build_Temporary\n+        (Loc         : Source_Ptr;\n+         Id          : Character;\n+         Related_Nod : Node_Id := Empty) return Entity_Id;\n+      --  Create an external symbol of the form xxx_FIRST/_LAST if Related_Id\n+      --  is present, otherwise it generates an internal temporary.\n+\n+      ---------------------\n+      -- Build_Temporary --\n+      ---------------------\n+\n+      function Build_Temporary\n+        (Loc         : Source_Ptr;\n+         Id          : Character;\n+         Related_Nod : Node_Id := Empty) return Entity_Id\n+      is\n+         Temp_Nam : Name_Id;\n+\n+      begin\n+         --  The context requires an external symbol\n+\n+         if Present (Related_Id) then\n+            if Is_Low_Bound then\n+               Temp_Nam := New_External_Name (Chars (Related_Id), \"_FIRST\");\n+            else pragma Assert (Is_High_Bound);\n+               Temp_Nam := New_External_Name (Chars (Related_Id), \"_LAST\");\n+            end if;\n+\n+            return Make_Defining_Identifier (Loc, Temp_Nam);\n+\n+         --  Otherwise generate an internal temporary\n+\n+         else\n+            return Make_Temporary (Loc, Id, Related_Nod);\n+         end if;\n+      end Build_Temporary;\n+\n+      --  Local variables\n+\n       Loc          : constant Source_Ptr      := Sloc (Exp);\n       Exp_Type     : constant Entity_Id       := Etype (Exp);\n       Svg_Suppress : constant Suppress_Record := Scope_Suppress;\n@@ -7203,6 +7255,8 @@ package body Exp_Util is\n       Ref_Type     : Entity_Id;\n       Res          : Node_Id;\n \n+   --  Start of processing for Remove_Side_Effects\n+\n    begin\n       --  Handle cases in which there is nothing to do. In GNATprove mode,\n       --  removal of side effects is useful for the light expansion of\n@@ -7260,7 +7314,7 @@ package body Exp_Util is\n                    or else (not Name_Req\n                              and then Is_Volatile_Reference (Exp)))\n       then\n-         Def_Id := Make_Temporary (Loc, 'R', Exp);\n+         Def_Id := Build_Temporary (Loc, 'R', Exp);\n          Set_Etype (Def_Id, Exp_Type);\n          Res := New_Occurrence_Of (Def_Id, Loc);\n \n@@ -7309,7 +7363,7 @@ package body Exp_Util is\n       elsif Nkind (Exp) = N_Explicit_Dereference\n         and then not Is_Volatile_Reference (Exp)\n       then\n-         Def_Id := Make_Temporary (Loc, 'R', Exp);\n+         Def_Id := Build_Temporary (Loc, 'R', Exp);\n          Res :=\n            Make_Explicit_Dereference (Loc, New_Occurrence_Of (Def_Id, Loc));\n \n@@ -7351,8 +7405,8 @@ package body Exp_Util is\n             --  Use a renaming to capture the expression, rather than create\n             --  a controlled temporary.\n \n-            Def_Id := Make_Temporary (Loc, 'R', Exp);\n-            Res := New_Occurrence_Of (Def_Id, Loc);\n+            Def_Id := Build_Temporary (Loc, 'R', Exp);\n+            Res    := New_Occurrence_Of (Def_Id, Loc);\n \n             Insert_Action (Exp,\n               Make_Object_Renaming_Declaration (Loc,\n@@ -7361,9 +7415,9 @@ package body Exp_Util is\n                 Name                => Relocate_Node (Exp)));\n \n          else\n-            Def_Id := Make_Temporary (Loc, 'R', Exp);\n+            Def_Id := Build_Temporary (Loc, 'R', Exp);\n             Set_Etype (Def_Id, Exp_Type);\n-            Res := New_Occurrence_Of (Def_Id, Loc);\n+            Res    := New_Occurrence_Of (Def_Id, Loc);\n \n             E :=\n               Make_Object_Declaration (Loc,\n@@ -7397,7 +7451,7 @@ package body Exp_Util is\n \n         and then (Name_Req or else not Treat_As_Volatile (Exp_Type))\n       then\n-         Def_Id := Make_Temporary (Loc, 'R', Exp);\n+         Def_Id := Build_Temporary (Loc, 'R', Exp);\n \n          if Nkind (Exp) = N_Selected_Component\n            and then Nkind (Prefix (Exp)) = N_Function_Call\n@@ -7490,7 +7544,7 @@ package body Exp_Util is\n             end;\n          end if;\n \n-         Def_Id := Make_Temporary (Loc, 'R', Exp);\n+         Def_Id := Build_Temporary (Loc, 'R', Exp);\n \n          --  The regular expansion of functions with side effects involves the\n          --  generation of an access type to capture the return value found on"}, {"sha": "ef319fd56c4c845bf0c41caca06ff354d8f201e0", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2934b84ad8624e08f1390f9bf2cf95a0093f4f1b/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2934b84ad8624e08f1390f9bf2cf95a0093f4f1b/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=2934b84ad8624e08f1390f9bf2cf95a0093f4f1b", "patch": "@@ -372,14 +372,23 @@ package Exp_Util is\n    --  following functions allow this behavior to be modified.\n \n    function Duplicate_Subexpr_No_Checks\n-     (Exp          : Node_Id;\n-      Name_Req     : Boolean := False;\n-      Renaming_Req : Boolean := False) return Node_Id;\n-   --  Identical in effect to Duplicate_Subexpr, except that Remove_Checks\n-   --  is called on the result, so that the duplicated expression does not\n-   --  include checks. This is appropriate for use when Exp, the original\n-   --  expression is unconditionally elaborated before the duplicated\n-   --  expression, so that there is no need to repeat any checks.\n+     (Exp           : Node_Id;\n+      Name_Req      : Boolean   := False;\n+      Renaming_Req  : Boolean   := False;\n+      Related_Id    : Entity_Id := Empty;\n+      Is_Low_Bound  : Boolean   := False;\n+      Is_High_Bound : Boolean   := False) return Node_Id;\n+   --  Identical in effect to Duplicate_Subexpr, except that Remove_Checks is\n+   --  called on the result, so that the duplicated expression does not include\n+   --  checks. This is appropriate for use when Exp, the original expression is\n+   --  unconditionally elaborated before the duplicated expression, so that\n+   --  there is no need to repeat any checks.\n+   --\n+   --  Related_Id denotes the entity of the context where Expr appears. Flags\n+   --  Is_Low_Bound and Is_High_Bound specify whether the expression to check\n+   --  is the low or the high bound of a range. These three optional arguments\n+   --  signal Remove_Side_Effects to create an external symbol of the form\n+   --  Chars (Related_Id)_FIRST/_LAST.\n \n    function Duplicate_Subexpr_Move_Checks\n      (Exp          : Node_Id;\n@@ -823,10 +832,13 @@ package Exp_Util is\n    --  associated with Var, and if found, remove and return that call node.\n \n    procedure Remove_Side_Effects\n-     (Exp          : Node_Id;\n-      Name_Req     : Boolean := False;\n-      Renaming_Req : Boolean := False;\n-      Variable_Ref : Boolean := False);\n+     (Exp           : Node_Id;\n+      Name_Req      : Boolean   := False;\n+      Renaming_Req  : Boolean   := False;\n+      Variable_Ref  : Boolean   := False;\n+      Related_Id    : Entity_Id := Empty;\n+      Is_Low_Bound  : Boolean   := False;\n+      Is_High_Bound : Boolean   := False);\n    --  Given the node for a subexpression, this function replaces the node if\n    --  necessary by an equivalent subexpression that is guaranteed to be side\n    --  effect free. This is done by extracting any actions that could cause\n@@ -840,6 +852,13 @@ package Exp_Util is\n    --  side effect (used in implementing Force_Evaluation). Note: after call to\n    --  Remove_Side_Effects, it is safe to call New_Copy_Tree to obtain a copy\n    --  of the resulting expression.\n+   --\n+   --  Related_Id denotes the entity of the context where Expr appears. Flags\n+   --  Is_Low_Bound and Is_High_Bound specify whether the expression to check\n+   --  is the low or the high bound of a range. These three optional arguments\n+   --  signal Remove_Side_Effects to create an external symbol of the form\n+   --  Chars (Related_Id)_FIRST/_LAST. If Related_Id is set, the exactly one\n+   --  of the Is_xxx_Bound flags must be set.\n \n    function Represented_As_Scalar (T : Entity_Id) return Boolean;\n    --  Returns True iff the implementation of this type in code generation"}, {"sha": "2f0f194e71b11bcfaf274512248c3b9277db6638", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2934b84ad8624e08f1390f9bf2cf95a0093f4f1b/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2934b84ad8624e08f1390f9bf2cf95a0093f4f1b/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=2934b84ad8624e08f1390f9bf2cf95a0093f4f1b", "patch": "@@ -19734,16 +19734,29 @@ package body Sem_Ch3 is\n          Lo := Low_Bound (R);\n          Hi := High_Bound (R);\n \n-         --  We need to ensure validity of the bounds here, because if we\n-         --  go ahead and do the expansion, then the expanded code will get\n-         --  analyzed with range checks suppressed and we miss the check.\n          --  Validity checks on the range of a quantified expression are\n          --  delayed until the construct is transformed into a loop.\n \n-         if Nkind (Parent (R)) /= N_Loop_Parameter_Specification\n-           or else Nkind (Parent (Parent (R))) /= N_Quantified_Expression\n+         if Nkind (Parent (R)) = N_Loop_Parameter_Specification\n+           and then Nkind (Parent (Parent (R))) = N_Quantified_Expression\n          then\n-            Validity_Check_Range (R);\n+            null;\n+\n+         --  We need to ensure validity of the bounds here, because if we\n+         --  go ahead and do the expansion, then the expanded code will get\n+         --  analyzed with range checks suppressed and we miss the check.\n+\n+         --  WARNING: The capture of the range bounds with xxx_FIRST/_LAST and\n+         --  the temporaries generated by routine Remove_Side_Effects by means\n+         --  of validity checks must use the same names. When a range appears\n+         --  in the parent of a generic, the range is processed with checks\n+         --  disabled as part of the generic context and with checks enabled\n+         --  for code generation purposes. This leads to link issues as the\n+         --  generic contains references to xxx_FIRST/_LAST, but the inlined\n+         --  template sees the temporaries generated by Remove_Side_Effects.\n+\n+         else\n+            Validity_Check_Range (R, Subtyp);\n          end if;\n \n          --  If there were errors in the declaration, try and patch up some\n@@ -19784,16 +19797,16 @@ package body Sem_Ch3 is\n          if Nkind (Lo) = N_String_Literal then\n             Rewrite (Lo,\n               Make_Attribute_Reference (Sloc (Lo),\n-                Attribute_Name => Name_First,\n-                Prefix => New_Occurrence_Of (T, Sloc (Lo))));\n+                Prefix         => New_Occurrence_Of (T, Sloc (Lo)),\n+                Attribute_Name => Name_First));\n             Analyze_And_Resolve (Lo);\n          end if;\n \n          if Nkind (Hi) = N_String_Literal then\n             Rewrite (Hi,\n               Make_Attribute_Reference (Sloc (Hi),\n-                Attribute_Name => Name_First,\n-                Prefix => New_Occurrence_Of (T, Sloc (Hi))));\n+                Prefix         => New_Occurrence_Of (T, Sloc (Hi)),\n+                Attribute_Name => Name_First));\n             Analyze_And_Resolve (Hi);\n          end if;\n "}]}