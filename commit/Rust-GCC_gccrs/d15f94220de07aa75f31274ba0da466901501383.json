{"sha": "d15f94220de07aa75f31274ba0da466901501383", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE1Zjk0MjIwZGUwN2FhNzVmMzEyNzRiYTBkYTQ2NjkwMTUwMTM4Mw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-30T13:22:13Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-30T13:22:13Z"}, "message": "[multiple changes]\n\n2011-08-30  Steve Baird  <baird@adacore.com>\n\n\t* sem_util.ads (Deepest_Type_Access_Level): New function; for the type\n\tof a saooaaat (i.e, a stand-alone object of an anonymous access type),\n\treturns the (static) accessibility level of the object. Otherwise, the\n\tsame as Type_Access_Level.\n\t(Dynamic_Accessibility_Level): New function; given an expression which\n\tcould occur as the rhs of an assignment to a saooaaat (i.e., an\n\texpression of an access-to-object type), return the new value for the\n\tsaooaaat's associated Extra_Accessibility object.\n\t(Effective_Extra_Accessibility): New function; same as\n\tEinfo.Extra_Accessibility except that object renames are looked through.\n\t* sem_util.adb \n\t(Deepest_Type_Access_Level): New function; see sem_util.ads description.\n\t(Dynamic_Accessibility_Level): New function; see sem_util.ads\n\tdescription.\n\t(Effective_Extra_Accessibility): New function; see sem_util.ads\n\tdescription.\n\t* einfo.ads (Is_Local_Anonymous_Access): Update comments.\n\t(Extra_Accessibility): Update comments.\n\t(Init_Object_Size_Align): New procedure; same as Init_Size_Align\n\texcept RM_Size field (which is only for types) is unaffected.\n\t* einfo.adb\n\t(Extra_Accessibility): Expand domain to allow objects, not just formals.\n\t(Set_Extra_Accessibility): Expand domain to allow objects, not just\n\tformals.\n\t(Init_Size): Add assertion that we are not trashing the\n\tExtra_Accessibility attribute of an object.\n\t(Init_Size_Align): Add assertion that we are not trashing the\n\tExtra_Accessibility attribute of an object.\n\t(Init_Object_Size_Align): New procedure; see einfo.ads description.\n\t* sem_ch3.adb (Find_Type_Of_Object): Set Is_Local_Anonymous_Access\n\tdifferently for the type of a (non-library-level) saooaaat depending\n\twhether Ada_Version < Ada_2012. This is the only point where Ada_Version\n\tis queried in this set of changes - everything else (in particular,\n\tsetting of the Extra_Accessibility attribute in exp_ch3.adb) is\n\tdriven off of the setting of the Is_Local_Anonymous_Access attribute.\n\tThe special treatment of library-level saooaaats is an optimization,\n\tnot required for correctnesss. This is based on the observation that the\n\tAda2012 rules (static and dynamic) for saooaaats turn out to be\n\tequivalent to the Ada2005 rules in the case of a library-level saooaaat.\n\t* exp_ch3.adb\n\t(Expand_N_Object_Declaration): If Is_Local_Anonymous_Access is\n\tfalse for the type of a saooaaat, declare and initialize its\n\taccessibility level object and set the Extra_Accessibility attribute\n\tof the saooaaat to refer to this object.\n\t* checks.adb (Apply_Accessibility_Check): Add Ada 2012 saooaaat support.\n\t* exp_ch4.adb (Expand_N_In): Replace some Extra_Accessibility calls with\n\tcalls to Effective_Extra_Accessibility in order to support\n\trenames of saooaaats.\n\t(Expand_N_Type_Conversion): Add new local function,\n\tHas_Extra_Accessibility, and call it when determining whether an\n\taccessibility check is needed.\n\tIt returns True iff Present (Effective_Extra_Accessibility (Id)) would\n\tevaluate to True (without raising an exception).\n\t* exp_ch5.adb\n\t(Expand_N_Assignment_Statement): When assigning to an Ada2012\n\tsaooaaat, update its associated Extra_Accessibility object (if\n\tit has one). This includes an accessibility check.\n\t* exp_ch6.adb (Add_Call_By_Copy_Code): When parameter copy-back updates\n\ta saooaaat, update its Extra_Accessibility object too (if it\n\thas one).\n\t(Expand_Call): Replace a couple of calls to Type_Access_Level\n\twith calls to Dynamic_Access_Level to handle cases where\n\tpassing a literal (any literal) is incorrect.\n\t* sem_attr.adb (Resolve_Attribute): Handle the static accessibility\n\tchecks associated with \"Saooaat := Some_Object'Access;\"; this must\n\tbe rejected if Some_Object is declared in a more nested scope\n\tthan Saooaat.\n\t* sem_ch5.adb (Analyze_Assignment): Force accessibility checking for an\n\tassignment to a saooaaat even if Is_Local_Anonymous_Access\n\treturns False for its type (indicating a 2012-style saooaaat).\n\t* sem_ch8.adb\n\t(Analyze_Object_Renaming): Replace a call to Init_Size_Align\n\t(which is only appropriate for objects, not types) with a call\n\tof Init_Object_Size_Align in order to avoid trashing the\n\tExtra_Accessibility attribute of a rename (the two attributes\n\tshare storage).\n\t* sem_res.adb\n\t(Valid_Conversion) Replace six calls to Type_Access_Level with\n\tcalls to Deepest_Type_Access_Level. This is a bit tricky. For an\n\tAda2012 non-library-level saooaaat, the former returns library level\n\twhile the latter returns the (static) accessibility level of the\n\tsaooaaat. A type conversion to the anonymous type of a saooaaat\n\tcan only occur as part of an assignment to the saooaaat, so we\n\tknow that such a conversion must be in a lhs context, so Deepest\n\tyields the result that we need. If such a conversion could occur,\n\tsay, as the operand of an equality operator, then this might not\n\tbe right. Also add a test so that static accessibilty checks are\n\tperformed for converting to a saooaaat's type even if\n\tIs_Local_Anonymous_Access yields False for the type.\n\n2011-08-30  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_disp.adb (Check_Dispatching_Operation): Complete condition that\n\tcontrols generation of a warning associated with late declaration of\n\tdispatching functions. Required to avoid generating spurious\n\twarnings.\n\nFrom-SVN: r178299", "tree": {"sha": "a598fbcfcf4b71e5ab261990ff54efd38fc1483a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a598fbcfcf4b71e5ab261990ff54efd38fc1483a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d15f94220de07aa75f31274ba0da466901501383", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d15f94220de07aa75f31274ba0da466901501383", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d15f94220de07aa75f31274ba0da466901501383", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d15f94220de07aa75f31274ba0da466901501383/comments", "author": null, "committer": null, "parents": [{"sha": "9645d43461599b60a2b27b337f1a56c5a88ff6ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9645d43461599b60a2b27b337f1a56c5a88ff6ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9645d43461599b60a2b27b337f1a56c5a88ff6ba"}], "stats": {"total": 520, "additions": 477, "deletions": 43}, "files": [{"sha": "9a4bc026579124bf41d873b4d079aa94c0dd3ea2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d15f94220de07aa75f31274ba0da466901501383", "patch": "@@ -1,3 +1,102 @@\n+2011-08-30  Steve Baird  <baird@adacore.com>\n+\n+\t* sem_util.ads (Deepest_Type_Access_Level): New function; for the type\n+\tof a saooaaat (i.e, a stand-alone object of an anonymous access type),\n+\treturns the (static) accessibility level of the object. Otherwise, the\n+\tsame as Type_Access_Level.\n+\t(Dynamic_Accessibility_Level): New function; given an expression which\n+\tcould occur as the rhs of an assignment to a saooaaat (i.e., an\n+\texpression of an access-to-object type), return the new value for the\n+\tsaooaaat's associated Extra_Accessibility object.\n+\t(Effective_Extra_Accessibility): New function; same as\n+\tEinfo.Extra_Accessibility except that object renames are looked through.\n+\t* sem_util.adb \n+\t(Deepest_Type_Access_Level): New function; see sem_util.ads description.\n+\t(Dynamic_Accessibility_Level): New function; see sem_util.ads\n+\tdescription.\n+\t(Effective_Extra_Accessibility): New function; see sem_util.ads\n+\tdescription.\n+\t* einfo.ads (Is_Local_Anonymous_Access): Update comments.\n+\t(Extra_Accessibility): Update comments.\n+\t(Init_Object_Size_Align): New procedure; same as Init_Size_Align\n+\texcept RM_Size field (which is only for types) is unaffected.\n+\t* einfo.adb\n+\t(Extra_Accessibility): Expand domain to allow objects, not just formals.\n+\t(Set_Extra_Accessibility): Expand domain to allow objects, not just\n+\tformals.\n+\t(Init_Size): Add assertion that we are not trashing the\n+\tExtra_Accessibility attribute of an object.\n+\t(Init_Size_Align): Add assertion that we are not trashing the\n+\tExtra_Accessibility attribute of an object.\n+\t(Init_Object_Size_Align): New procedure; see einfo.ads description.\n+\t* sem_ch3.adb (Find_Type_Of_Object): Set Is_Local_Anonymous_Access\n+\tdifferently for the type of a (non-library-level) saooaaat depending\n+\twhether Ada_Version < Ada_2012. This is the only point where Ada_Version\n+\tis queried in this set of changes - everything else (in particular,\n+\tsetting of the Extra_Accessibility attribute in exp_ch3.adb) is\n+\tdriven off of the setting of the Is_Local_Anonymous_Access attribute.\n+\tThe special treatment of library-level saooaaats is an optimization,\n+\tnot required for correctnesss. This is based on the observation that the\n+\tAda2012 rules (static and dynamic) for saooaaats turn out to be\n+\tequivalent to the Ada2005 rules in the case of a library-level saooaaat.\n+\t* exp_ch3.adb\n+\t(Expand_N_Object_Declaration): If Is_Local_Anonymous_Access is\n+\tfalse for the type of a saooaaat, declare and initialize its\n+\taccessibility level object and set the Extra_Accessibility attribute\n+\tof the saooaaat to refer to this object.\n+\t* checks.adb (Apply_Accessibility_Check): Add Ada 2012 saooaaat support.\n+\t* exp_ch4.adb (Expand_N_In): Replace some Extra_Accessibility calls with\n+\tcalls to Effective_Extra_Accessibility in order to support\n+\trenames of saooaaats.\n+\t(Expand_N_Type_Conversion): Add new local function,\n+\tHas_Extra_Accessibility, and call it when determining whether an\n+\taccessibility check is needed.\n+\tIt returns True iff Present (Effective_Extra_Accessibility (Id)) would\n+\tevaluate to True (without raising an exception).\n+\t* exp_ch5.adb\n+\t(Expand_N_Assignment_Statement): When assigning to an Ada2012\n+\tsaooaaat, update its associated Extra_Accessibility object (if\n+\tit has one). This includes an accessibility check.\n+\t* exp_ch6.adb (Add_Call_By_Copy_Code): When parameter copy-back updates\n+\ta saooaaat, update its Extra_Accessibility object too (if it\n+\thas one).\n+\t(Expand_Call): Replace a couple of calls to Type_Access_Level\n+\twith calls to Dynamic_Access_Level to handle cases where\n+\tpassing a literal (any literal) is incorrect.\n+\t* sem_attr.adb (Resolve_Attribute): Handle the static accessibility\n+\tchecks associated with \"Saooaat := Some_Object'Access;\"; this must\n+\tbe rejected if Some_Object is declared in a more nested scope\n+\tthan Saooaat.\n+\t* sem_ch5.adb (Analyze_Assignment): Force accessibility checking for an\n+\tassignment to a saooaaat even if Is_Local_Anonymous_Access\n+\treturns False for its type (indicating a 2012-style saooaaat).\n+\t* sem_ch8.adb\n+\t(Analyze_Object_Renaming): Replace a call to Init_Size_Align\n+\t(which is only appropriate for objects, not types) with a call\n+\tof Init_Object_Size_Align in order to avoid trashing the\n+\tExtra_Accessibility attribute of a rename (the two attributes\n+\tshare storage).\n+\t* sem_res.adb\n+\t(Valid_Conversion) Replace six calls to Type_Access_Level with\n+\tcalls to Deepest_Type_Access_Level. This is a bit tricky. For an\n+\tAda2012 non-library-level saooaaat, the former returns library level\n+\twhile the latter returns the (static) accessibility level of the\n+\tsaooaaat. A type conversion to the anonymous type of a saooaaat\n+\tcan only occur as part of an assignment to the saooaaat, so we\n+\tknow that such a conversion must be in a lhs context, so Deepest\n+\tyields the result that we need. If such a conversion could occur,\n+\tsay, as the operand of an equality operator, then this might not\n+\tbe right. Also add a test so that static accessibilty checks are\n+\tperformed for converting to a saooaaat's type even if\n+\tIs_Local_Anonymous_Access yields False for the type.\n+\n+2011-08-30  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_disp.adb (Check_Dispatching_Operation): Complete condition that\n+\tcontrols generation of a warning associated with late declaration of\n+\tdispatching functions. Required to avoid generating spurious\n+\twarnings.\n+\n 2011-08-30  Gary Dismukes  <dismukes@adacore.com>\n \n \t* sem_ch6.adb (Check_Return_Subtype_Indication): Issue error if the"}, {"sha": "a5da4154867eac10f593d854f7e306b986e41947", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=d15f94220de07aa75f31274ba0da466901501383", "patch": "@@ -479,11 +479,26 @@ package body Checks is\n       Insert_Node : Node_Id)\n    is\n       Loc         : constant Source_Ptr := Sloc (N);\n-      Param_Ent   : constant Entity_Id  := Param_Entity (N);\n+      Param_Ent   : Entity_Id  := Param_Entity (N);\n       Param_Level : Node_Id;\n       Type_Level  : Node_Id;\n \n    begin\n+      if Ada_Version >= Ada_2012\n+         and then not Present (Param_Ent)\n+         and then Is_Entity_Name (N)\n+         and then Ekind_In (Entity (N), E_Constant, E_Variable)\n+         and then Present (Effective_Extra_Accessibility (Entity (N)))\n+      then\n+         Param_Ent := Entity (N);\n+         while Present (Renamed_Object (Param_Ent)) loop\n+            --  Renamed_Object must return an Entity_Name here\n+            --  because of preceding \"Present (E_E_A (...))\" test.\n+\n+            Param_Ent := Entity (Renamed_Object (Param_Ent));\n+         end loop;\n+      end if;\n+\n       if Inside_A_Generic then\n          return;\n \n@@ -494,15 +509,16 @@ package body Checks is\n \n       elsif Present (Param_Ent)\n          and then Present (Extra_Accessibility (Param_Ent))\n-         and then UI_Gt (Object_Access_Level (N), Type_Access_Level (Typ))\n+         and then UI_Gt (Object_Access_Level (N),\n+           Deepest_Type_Access_Level (Typ))\n          and then not Accessibility_Checks_Suppressed (Param_Ent)\n          and then not Accessibility_Checks_Suppressed (Typ)\n       then\n          Param_Level :=\n            New_Occurrence_Of (Extra_Accessibility (Param_Ent), Loc);\n \n-         Type_Level :=\n-           Make_Integer_Literal (Loc, Type_Access_Level (Typ));\n+         Type_Level := Make_Integer_Literal (Loc,\n+           Deepest_Type_Access_Level (Typ));\n \n          --  Raise Program_Error if the accessibility level of the access\n          --  parameter is deeper than the level of the target access type."}, {"sha": "3f12cedefb3bcaef6fabb45a1924381541ec9d3e", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=d15f94220de07aa75f31274ba0da466901501383", "patch": "@@ -1038,7 +1038,8 @@ package body Einfo is\n \n    function Extra_Accessibility (Id : E) return E is\n    begin\n-      pragma Assert (Is_Formal (Id) or else Ekind (Id) = E_Variable);\n+      pragma Assert\n+        (Is_Formal (Id) or else Ekind_In (Id, E_Variable, E_Constant));\n       return Node13 (Id);\n    end Extra_Accessibility;\n \n@@ -3506,7 +3507,8 @@ package body Einfo is\n \n    procedure Set_Extra_Accessibility (Id : E; V : E) is\n    begin\n-      pragma Assert (Is_Formal (Id) or else Ekind (Id) = E_Variable);\n+      pragma Assert\n+        (Is_Formal (Id) or else Ekind_In (Id, E_Variable, E_Constant));\n       Set_Node13 (Id, V);\n    end Set_Extra_Accessibility;\n \n@@ -5466,6 +5468,7 @@ package body Einfo is\n    procedure Init_Size (Id : E; V : Int) is\n    begin\n       Set_Uint12 (Id, UI_From_Int (V));  -- Esize\n+      pragma Assert (not Is_Object (Id));\n       Set_Uint13 (Id, UI_From_Int (V));  -- RM_Size\n    end Init_Size;\n \n@@ -5476,10 +5479,21 @@ package body Einfo is\n    procedure Init_Size_Align (Id : E) is\n    begin\n       Set_Uint12 (Id, Uint_0);  -- Esize\n+      pragma Assert (not Is_Object (Id));\n       Set_Uint13 (Id, Uint_0);  -- RM_Size\n       Set_Uint14 (Id, Uint_0);  -- Alignment\n    end Init_Size_Align;\n \n+   ----------------------------\n+   -- Init_Object_Size_Align --\n+   ----------------------------\n+\n+   procedure Init_Object_Size_Align (Id : E) is\n+   begin\n+      Set_Uint12 (Id, Uint_0);  -- Esize\n+      Set_Uint14 (Id, Uint_0);  -- Alignment\n+   end Init_Object_Size_Align;\n+\n    ----------------------------------------------\n    -- Type Representation Attribute Predicates --\n    ----------------------------------------------"}, {"sha": "41ab2675af67d9b14c858ac52ba4d4e0709affa6", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=d15f94220de07aa75f31274ba0da466901501383", "patch": "@@ -2446,10 +2446,11 @@ package Einfo is\n --    Is_Local_Anonymous_Access (Flag194)\n --       Present in access types. Set for an anonymous access type to indicate\n --       that the type is created for a record component with an access\n---       definition, an array component, or a stand-alone object. Such\n---       anonymous types have an accessibility level equal to that of the\n+--       definition, an array component, or (pre-Ada2012) a stand-alone object.\n+--       Such anonymous types have an accessibility level equal to that of the\n --       declaration in which they appear, unlike the anonymous access types\n---       that are created for access parameters and access discriminants.\n+--       that are created for access parameters, access discriminants, and\n+--       (as of Ada2012) stand-alone objects.\n \n --    Is_Machine_Code_Subprogram (Flag137)\n --       Present in subprogram entities. Set to indicate that the subprogram\n@@ -5050,6 +5051,7 @@ package Einfo is\n    --    Discriminal_Link                    (Node10)   (discriminals only)\n    --    Full_View                           (Node11)\n    --    Esize                               (Uint12)\n+   --    Extra_Accessibility                 (Node13)   (constants only)\n    --    Alignment                           (Uint14)\n    --    Return_Flag_Or_Transient_Decl       (Node15)   (constants only)\n    --    Actual_Subtype                      (Node17)\n@@ -7017,6 +7019,10 @@ package Einfo is\n    --  This procedure initializes both size fields and the alignment\n    --  field to all be Unknown.\n \n+   procedure Init_Object_Size_Align (Id : E);\n+   --  Same as Init_Size_Align except RM_Size field (which is only for types)\n+   --  is unaffected.\n+\n    procedure Init_Size (Id : E; V : Int);\n    --  Initialize both the Esize and RM_Size fields of E to V\n "}, {"sha": "3f11e0efcd528b3da5b2252499035e6acfa38862", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=d15f94220de07aa75f31274ba0da466901501383", "patch": "@@ -5261,6 +5261,47 @@ package body Exp_Ch3 is\n          end if;\n       end if;\n \n+      if Nkind (N) = N_Object_Declaration\n+        and then Nkind (Object_Definition (N)) = N_Access_Definition\n+        and then not Is_Local_Anonymous_Access (Etype (Def_Id))\n+      then\n+         --  An Ada 2012 stand-alone object of an anonymous access type\n+\n+         declare\n+            Loc : constant Source_Ptr := Sloc (N);\n+\n+            Level : constant Entity_Id :=\n+              Make_Defining_Identifier (Sloc (N),\n+                Chars  => New_External_Name (Chars (Def_Id),\n+                                             Suffix => \"L\"));\n+            Level_Expr : Node_Id;\n+            Level_Decl : Node_Id;\n+         begin\n+            Set_Ekind (Level, Ekind (Def_Id));\n+            Set_Etype (Level, Standard_Natural);\n+            Set_Scope (Level, Scope (Def_Id));\n+\n+            if No (Expr) then\n+               Level_Expr := Make_Integer_Literal (Loc,\n+                 -- accessibility level of null\n+                 Intval => Scope_Depth (Standard_Standard));\n+            else\n+               Level_Expr := Dynamic_Accessibility_Level (Expr);\n+            end if;\n+\n+            Level_Decl := Make_Object_Declaration (Loc,\n+             Defining_Identifier => Level,\n+             Object_Definition => New_Occurrence_Of (Standard_Natural, Loc),\n+             Expression => Level_Expr,\n+             Constant_Present => Constant_Present (N),\n+             Has_Init_Expression => True);\n+\n+            Insert_Action_After (Init_After, Level_Decl);\n+\n+            Set_Extra_Accessibility (Def_Id, Level);\n+         end;\n+      end if;\n+\n    --  Exception on library entity not available\n \n    exception"}, {"sha": "b7698abe27984f6075b0f2d05f3228e4211a9d06", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=d15f94220de07aa75f31274ba0da466901501383", "patch": "@@ -4996,14 +4996,15 @@ package body Exp_Ch4 is\n \n                   else\n                      if Present (Expr_Entity)\n-                       and then Present (Extra_Accessibility (Expr_Entity))\n+                       and then Present\n+                         (Effective_Extra_Accessibility (Expr_Entity))\n                        and then UI_Gt\n                                   (Object_Access_Level (Lop),\n                                    Type_Access_Level (Rtyp))\n                      then\n                         Param_Level :=\n                           New_Occurrence_Of\n-                            (Extra_Accessibility (Expr_Entity), Loc);\n+                            (Effective_Extra_Accessibility (Expr_Entity), Loc);\n \n                         Type_Level :=\n                           Make_Integer_Literal (Loc, Type_Access_Level (Rtyp));\n@@ -8279,6 +8280,10 @@ package body Exp_Ch4 is\n       procedure Real_Range_Check;\n       --  Handles generation of range check for real target value\n \n+      function Has_Extra_Accessibility (Id : Entity_Id) return Boolean;\n+      --  True iff Present (Effective_Extra_Accessibility (Id)) successfully\n+      --  evaluates to True.\n+\n       -----------------------------------\n       -- Handle_Changed_Representation --\n       -----------------------------------\n@@ -8578,6 +8583,22 @@ package body Exp_Ch4 is\n          Analyze_And_Resolve (N, Btyp);\n       end Real_Range_Check;\n \n+      -----------------------------\n+      -- Has_Extra_Accessibility --\n+      -----------------------------\n+\n+      --  Returns true for a formal of an anonymous access type or for\n+      --  an Ada 2012-style stand-alone object of an anonymous access type.\n+\n+      function Has_Extra_Accessibility (Id : Entity_Id) return Boolean is\n+      begin\n+         if Is_Formal (Id) or else Ekind_In (Id, E_Constant, E_Variable) then\n+            return Present (Effective_Extra_Accessibility (Id));\n+         else\n+            return False;\n+         end if;\n+      end Has_Extra_Accessibility;\n+\n    --  Start of processing for Expand_N_Type_Conversion\n \n    begin\n@@ -8736,13 +8757,7 @@ package body Exp_Ch4 is\n          --  as tagged type checks).\n \n          if Is_Entity_Name (Operand)\n-           and then\n-             (Is_Formal (Entity (Operand))\n-               or else\n-                 (Present (Renamed_Object (Entity (Operand)))\n-                   and then Is_Entity_Name (Renamed_Object (Entity (Operand)))\n-                   and then Is_Formal\n-                              (Entity (Renamed_Object (Entity (Operand))))))\n+           and then Has_Extra_Accessibility (Entity (Operand))\n            and then Ekind (Etype (Operand)) = E_Anonymous_Access_Type\n            and then (Nkind (Original_Node (N)) /= N_Attribute_Reference\n                       or else Attribute_Name (Original_Node (N)) = Name_Access)"}, {"sha": "aa0879b465effe0c612dbc332be8714407aa6a57", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=d15f94220de07aa75f31274ba0da466901501383", "patch": "@@ -1885,6 +1885,57 @@ package body Exp_Ch5 is\n          Apply_Constraint_Check (Rhs, Etype (Lhs));\n       end if;\n \n+      --  Ada 2012 (AI05-148): Update current accessibility level if\n+      --  Rhs is a stand-alone obj of an anonymous access type.\n+\n+      if Is_Access_Type (Typ)\n+        and then Is_Entity_Name (Lhs)\n+        and then Present (Effective_Extra_Accessibility (Entity (Lhs))) then\n+         declare\n+            function Lhs_Entity return Entity_Id;\n+            --  Look through renames to find the underlying entity.\n+            --  For assignment to a rename, we don't care about the\n+            --  Enclosing_Dynamic_Scope of the rename declaration.\n+\n+            ----------------\n+            -- Lhs_Entity --\n+            ----------------\n+\n+            function Lhs_Entity return Entity_Id is\n+               Result : Entity_Id := Entity (Lhs);\n+            begin\n+               while Present (Renamed_Object (Result)) loop\n+                  --  Renamed_Object must return an Entity_Name here\n+                  --  because of preceding \"Present (E_E_A (...))\" test.\n+\n+                  Result := Entity (Renamed_Object (Result));\n+               end loop;\n+               return Result;\n+            end Lhs_Entity;\n+\n+            Access_Check : constant Node_Id :=\n+              Make_Raise_Program_Error (Loc,\n+                Condition =>\n+                  Make_Op_Gt (Loc,\n+                    Left_Opnd => Dynamic_Accessibility_Level (Rhs),\n+                    Right_Opnd =>\n+                      Make_Integer_Literal (Loc,\n+                        Scope_Depth (Enclosing_Dynamic_Scope (Lhs_Entity)))),\n+                Reason => PE_Accessibility_Check_Failed);\n+\n+            Access_Level_Update : constant Node_Id :=\n+              Make_Assignment_Statement (Loc,\n+                Name => New_Occurrence_Of (\n+                  Effective_Extra_Accessibility (Entity (Lhs)), Loc),\n+                Expression => Dynamic_Accessibility_Level (Rhs));\n+         begin\n+            if not Accessibility_Checks_Suppressed (Entity (Lhs)) then\n+               Insert_Action (N, Access_Check);\n+            end if;\n+            Insert_Action (N, Access_Level_Update);\n+         end;\n+      end if;\n+\n       --  Case of assignment to a bit packed array element. If there is a\n       --  change of representation this must be expanded into components,\n       --  otherwise this is a bit-field assignment."}, {"sha": "b3bd10a9230a01c78e84d3ba70bccd425908d896", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=d15f94220de07aa75f31274ba0da466901501383", "patch": "@@ -1201,10 +1201,46 @@ package body Exp_Ch6 is\n \n                Set_Assignment_OK (Lhs);\n \n-               Append_To (Post_Call,\n-                 Make_Assignment_Statement (Loc,\n-                   Name       => Lhs,\n-                   Expression => Expr));\n+               if Is_Access_Type (E_Formal)\n+                 and then Is_Entity_Name (Lhs)\n+                 and then Present (Effective_Extra_Accessibility\n+                 (Entity (Lhs)))\n+               then\n+                  --  Copyback target is an Ada 2012 stand-alone object\n+                  --  of an anonymous access type\n+\n+                  pragma Assert (Ada_Version >= Ada_2012);\n+\n+                  if Type_Access_Level (E_Formal) >\n+                    Object_Access_Level (Lhs) then\n+                     Append_To (Post_Call, Make_Raise_Program_Error (Loc,\n+                       Reason => PE_Accessibility_Check_Failed));\n+                  end if;\n+\n+                  Append_To (Post_Call,\n+                    Make_Assignment_Statement (Loc,\n+                      Name       => Lhs,\n+                      Expression => Expr));\n+\n+                  --  We would like to somehow suppress generation of\n+                  --  the extra_accessibility assignment generated by\n+                  --  the expansion of the above assignment statement.\n+                  --  It's not a correctness issue because the following\n+                  --  assignment renders it dead, but generating back-to-back\n+                  --  assignments to the same target is undesirable. ???\n+\n+                  Append_To (Post_Call,\n+                    Make_Assignment_Statement (Loc,\n+                      Name       => New_Occurrence_Of (\n+                        Effective_Extra_Accessibility (Entity (Lhs)), Loc),\n+                      Expression => Make_Integer_Literal (Loc,\n+                        Type_Access_Level (E_Formal))));\n+               else\n+                  Append_To (Post_Call,\n+                    Make_Assignment_Statement (Loc,\n+                      Name       => Lhs,\n+                      Expression => Expr));\n+               end if;\n             end;\n          end if;\n       end Add_Call_By_Copy_Code;\n@@ -2406,8 +2442,7 @@ package body Exp_Ch6 is\n \n                else\n                   Add_Extra_Actual\n-                    (Make_Integer_Literal (Loc,\n-                       Intval => Type_Access_Level (Etype (Prev_Orig))),\n+                    (Dynamic_Accessibility_Level (Prev_Orig),\n                      Extra_Accessibility (Formal));\n                end if;\n \n@@ -2497,15 +2532,15 @@ package body Exp_Ch6 is\n                           Intval => Scope_Depth (Current_Scope) + 1),\n                         Extra_Accessibility (Formal));\n \n-                  --  For other cases we simply pass the level of the actual's\n-                  --  access type. The type is retrieved from Prev rather than\n-                  --  Prev_Orig, because in some cases Prev_Orig denotes an\n-                  --  original expression that has not been analyzed.\n+                  --  For most other cases we simply pass the level of the\n+                  --  actual's access type. The type is retrieved from\n+                  --  Prev rather than Prev_Orig, because in some cases\n+                  --  Prev_Orig denotes an original expression that has\n+                  --  not been analyzed.\n \n                   when others =>\n                      Add_Extra_Actual\n-                       (Make_Integer_Literal (Loc,\n-                          Intval => Type_Access_Level (Etype (Prev))),\n+                       (Dynamic_Accessibility_Level (Prev),\n                         Extra_Accessibility (Formal));\n                end case;\n             end if;"}, {"sha": "66ff686ed1fd6f7b99a6be6fed62a0439c2d46ab", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=d15f94220de07aa75f31274ba0da466901501383", "patch": "@@ -8312,8 +8312,16 @@ package body Sem_Attr is\n                --  the level is the same of the enclosing composite type.\n \n                if Ada_Version >= Ada_2005\n-                 and then Is_Local_Anonymous_Access (Btyp)\n-                 and then Object_Access_Level (P) > Type_Access_Level (Btyp)\n+                 and then (Is_Local_Anonymous_Access (Btyp)\n+\n+                           --  Handle cases where Btyp is the\n+                           --  anonymous access type of an Ada 2012\n+                           --  stand-alone object.\n+\n+                           or else Nkind (Associated_Node_For_Itype\n+                             (Btyp)) = N_Object_Declaration)\n+                 and then Object_Access_Level (P)\n+                          > Deepest_Type_Access_Level (Btyp)\n                  and then Attr_Id = Attribute_Access\n                then\n                   --  In an instance, this is a runtime check, but one we"}, {"sha": "9babd7ce3d413d1bc518e2f2f389de57237d7818", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d15f94220de07aa75f31274ba0da466901501383", "patch": "@@ -15122,7 +15122,10 @@ package body Sem_Ch3 is\n \n       elsif Def_Kind = N_Access_Definition then\n          T := Access_Definition (Related_Nod, Obj_Def);\n-         Set_Is_Local_Anonymous_Access (T);\n+\n+         Set_Is_Local_Anonymous_Access (T, V => (Ada_Version < Ada_2012)\n+           or else (Nkind (P) /= N_Object_Declaration)\n+           or else Is_Library_Level_Entity (Defining_Identifier (P)));\n \n       --  Otherwise, the object definition is just a subtype_mark\n "}, {"sha": "6b9e256a6c8f87663a219f89fa1b2a164ea820ae", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=d15f94220de07aa75f31274ba0da466901501383", "patch": "@@ -601,6 +601,14 @@ package body Sem_Ch5 is\n       then\n          if Is_Local_Anonymous_Access (T1)\n            or else Ekind (T2) = E_Anonymous_Access_Subprogram_Type\n+\n+           --  Handle assignment to an Ada 2012 stand-alone object\n+           --  of an anonymous access type.\n+\n+           or else (Ekind (T1) = E_Anonymous_Access_Type\n+             and then Nkind (Associated_Node_For_Itype (T1))\n+               = N_Object_Declaration)\n+\n          then\n             Rewrite (Rhs, Convert_To (T1, Relocate_Node (Rhs)));\n             Analyze_And_Resolve (Rhs, T1);"}, {"sha": "47dcbc4b81370a91bdf3051d117b1bc106b3fc2d", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=d15f94220de07aa75f31274ba0da466901501383", "patch": "@@ -1137,7 +1137,7 @@ package body Sem_Ch8 is\n       end if;\n \n       Set_Ekind (Id, E_Variable);\n-      Init_Size_Align (Id);\n+      Init_Object_Size_Align (Id);\n \n       if T = Any_Type or else Etype (Nam) = Any_Type then\n          return;"}, {"sha": "067d1cfdcc0a38b91b6bcc206dbb9049d3bcdbd6", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=d15f94220de07aa75f31274ba0da466901501383", "patch": "@@ -850,9 +850,12 @@ package body Sem_Disp is\n                   Typ := Etype (Subp);\n                end if;\n \n-               if not Is_Class_Wide_Type (Typ)\n+               if Comes_From_Source (Subp)\n                  and then Is_Interface (Typ)\n+                 and then not Is_Class_Wide_Type (Typ)\n                  and then not Is_Derived_Type (Typ)\n+                 and then not Is_Generic_Type (Typ)\n+                 and then not In_Instance\n                then\n                   Error_Msg_N (\"?declaration of& is too late!\", Subp);\n                   Error_Msg_NE"}, {"sha": "cf395f909019e5828b91a5dd3288a97f0506fe0b", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=d15f94220de07aa75f31274ba0da466901501383", "patch": "@@ -10530,8 +10530,9 @@ package body Sem_Res is\n \n          if Ekind (Target_Type) /= E_Anonymous_Access_Type then\n             if Type_Access_Level (Opnd_Type) >\n-               Type_Access_Level (Target_Type)\n+              Deepest_Type_Access_Level (Target_Type)\n             then\n+\n                --  In an instance, this is a run-time check, but one we know\n                --  will fail, so generate an appropriate warning. The raise\n                --  will be generated by Expand_N_Type_Conversion.\n@@ -10562,7 +10563,7 @@ package body Sem_Res is\n \n                if Nkind (Operand) = N_Selected_Component\n                  and then Object_Access_Level (Operand) >\n-                          Type_Access_Level (Target_Type)\n+                   Deepest_Type_Access_Level (Target_Type)\n                then\n                   --  In an instance, this is a run-time check, but one we know\n                   --  will fail, so generate an appropriate warning. The raise\n@@ -10630,6 +10631,8 @@ package body Sem_Res is\n \n          if Ekind (Target_Type) /= E_Anonymous_Access_Type\n            or else Is_Local_Anonymous_Access (Target_Type)\n+           or else Nkind (Associated_Node_For_Itype (Target_Type)) =\n+             N_Object_Declaration\n          then\n             --  Ada 2012 (AI05-0149): Perform legality checking on implicit\n             --  conversions from an anonymous access type to a named general\n@@ -10687,8 +10690,8 @@ package body Sem_Res is\n                   --  statically less deep than that of the target type, else\n                   --  implicit conversion is disallowed (by RM12-8.6(27.1/3)).\n \n-                  elsif Type_Access_Level (Opnd_Type)\n-                          > Type_Access_Level (Target_Type)\n+                  elsif Type_Access_Level (Opnd_Type) >\n+                    Deepest_Type_Access_Level (Target_Type)\n                   then\n                      Error_Msg_N\n                        (\"implicit conversion of anonymous access value \" &\n@@ -10697,8 +10700,8 @@ package body Sem_Res is\n                   end if;\n                end if;\n \n-            elsif Type_Access_Level (Opnd_Type)\n-                    > Type_Access_Level (Target_Type)\n+            elsif Type_Access_Level (Opnd_Type) >\n+              Deepest_Type_Access_Level (Target_Type)\n             then\n \n                --  In an instance, this is a run-time check, but one we know\n@@ -10737,7 +10740,7 @@ package body Sem_Res is\n \n                if Nkind (Operand) = N_Selected_Component\n                  and then Object_Access_Level (Operand) >\n-                          Type_Access_Level (Target_Type)\n+                   Deepest_Type_Access_Level (Target_Type)\n                then\n                   --  In an instance, this is a run-time check, but one we know\n                   --  will fail, so generate an appropriate warning. The raise\n@@ -10909,7 +10912,7 @@ package body Sem_Res is\n          --  Check the static accessibility rule of 4.6(20)\n \n          if Type_Access_Level (Opnd_Type) >\n-            Type_Access_Level (Target_Type)\n+           Deepest_Type_Access_Level (Target_Type)\n          then\n             Error_Msg_N\n               (\"operand type has deeper accessibility level than target\","}, {"sha": "bb2c07d9237ebb6a9998f05e95bf807e41055d23", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d15f94220de07aa75f31274ba0da466901501383", "patch": "@@ -2372,6 +2372,26 @@ package body Sem_Util is\n       end if;\n    end Current_Subprogram;\n \n+   ----------------------------------\n+   -- Deepest_Type_Access_Level --\n+   ----------------------------------\n+\n+   function Deepest_Type_Access_Level (Typ : Entity_Id) return Uint is\n+   begin\n+      if Ekind (Typ) = E_Anonymous_Access_Type\n+        and then not Is_Local_Anonymous_Access (Typ)\n+        and then Nkind (Associated_Node_For_Itype (Typ)) = N_Object_Declaration\n+      then\n+         --  Typ is the type of an Ada 2012 stand-alone object of an\n+         --  anonymous access type.\n+\n+         return Scope_Depth (Enclosing_Dynamic_Scope (Defining_Identifier (\n+           Associated_Node_For_Itype (Typ))));\n+      else\n+         return Type_Access_Level (Typ);\n+      end if;\n+   end Deepest_Type_Access_Level;\n+\n    ---------------------\n    -- Defining_Entity --\n    ---------------------\n@@ -2848,6 +2868,99 @@ package body Sem_Util is\n       end if;\n    end Designate_Same_Unit;\n \n+   ------------------------------------------\n+   -- function Dynamic_Accessibility_Level --\n+   ------------------------------------------\n+\n+   function Dynamic_Accessibility_Level (Expr : Node_Id) return Node_Id is\n+      E : Entity_Id;\n+      Loc : constant Source_Ptr := Sloc (Expr);\n+   begin\n+      if Is_Entity_Name (Expr) then\n+         E := Entity (Expr);\n+\n+         if Present (Renamed_Object (E)) then\n+            return Dynamic_Accessibility_Level (Renamed_Object (E));\n+         end if;\n+\n+         if Is_Formal (E) or else Ekind_In (E, E_Variable, E_Constant) then\n+            if Present (Extra_Accessibility (E)) then\n+               return New_Occurrence_Of (Extra_Accessibility (E), Loc);\n+            end if;\n+         end if;\n+      end if;\n+\n+      --  unimplemented: Ptr.all'Access, where Ptr has Extra_Accessibility ???\n+\n+      case Nkind (Expr) is\n+         --  for access discriminant, the level of the enclosing object\n+\n+         when N_Selected_Component =>\n+            if Ekind (Entity (Selector_Name (Expr))) = E_Discriminant\n+              and then Ekind (Etype (Entity (Selector_Name (Expr)))) =\n+              E_Anonymous_Access_Type then\n+\n+               return Make_Integer_Literal (Loc, Object_Access_Level (Expr));\n+            end if;\n+\n+         when N_Attribute_Reference =>\n+            case Get_Attribute_Id (Attribute_Name (Expr)) is\n+\n+               --  For X'Access, the level of the prefix X\n+\n+               when Attribute_Access =>\n+                  return Make_Integer_Literal (Loc,\n+                    Object_Access_Level (Prefix (Expr)));\n+\n+               --  Treat the unchecked attributes as library-level\n+\n+               when Attribute_Unchecked_Access |\n+                 Attribute_Unrestricted_Access =>\n+                  return Make_Integer_Literal (Loc,\n+                    Scope_Depth (Standard_Standard));\n+\n+               --  No other access-valued attributes\n+\n+               when others =>\n+                  raise Program_Error;\n+            end case;\n+\n+         when N_Allocator =>\n+            --  Unimplemented: depends on context. As an actual\n+            --  parameter where formal type is anonymous, use\n+            --    Scope_Depth (Current_Scope) + 1.\n+            --  For other cases, see 3.10.2(14/3) and following. ???\n+            null;\n+\n+         when N_Type_Conversion =>\n+            if not Is_Local_Anonymous_Access (Etype (Expr)) then\n+               --  Handle type conversions introduced for a\n+               --  rename of an Ada2012 stand-alone object of an\n+               --  anonymous access type.\n+               return Dynamic_Accessibility_Level (Expression (Expr));\n+            end if;\n+\n+         when others =>\n+            null;\n+      end case;\n+\n+      return Make_Integer_Literal (Loc, Type_Access_Level (Etype (Expr)));\n+   end Dynamic_Accessibility_Level;\n+\n+   -----------------------------------\n+   -- Effective_Extra_Accessibility --\n+   -----------------------------------\n+\n+   function Effective_Extra_Accessibility (Id : Entity_Id) return Entity_Id is\n+   begin\n+      if Present (Renamed_Object (Id))\n+        and then Is_Entity_Name (Renamed_Object (Id)) then\n+         return Effective_Extra_Accessibility (Entity (Renamed_Object (Id)));\n+      end if;\n+\n+      return Extra_Accessibility (Id);\n+   end Effective_Extra_Accessibility;\n+\n    --------------------------\n    -- Enclosing_CPP_Parent --\n    --------------------------"}, {"sha": "2b7a93286b967f66fd5fde88515769505ee1ab29", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15f94220de07aa75f31274ba0da466901501383/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=d15f94220de07aa75f31274ba0da466901501383", "patch": "@@ -292,6 +292,15 @@ package Sem_Util is\n    --  Current_Scope is returned. The returned value is Empty if this is called\n    --  from a library package which is not within any subprogram.\n \n+   function Deepest_Type_Access_Level (Typ : Entity_Id) return Uint;\n+   --  Same as Type_Access_Level, except that if the\n+   --  type is the type of an Ada 2012 stand-alone object of an\n+   --  anonymous access type, then return the static accesssibility level\n+   --  of the object. In that case, the dynamic accessibility level\n+   --  of the object may take on values in a range. The low bound of\n+   --  of that range is returned by Type_Access_Level; this\n+   --  function yields the high bound of that range.\n+\n    function Defining_Entity (N : Node_Id) return Entity_Id;\n    --  Given a declaration N, returns the associated defining entity. If the\n    --  declaration has a specification, the entity is obtained from the\n@@ -332,6 +341,16 @@ package Sem_Util is\n    --  these names is supposed to be a selected component name, an expanded\n    --  name, a defining program unit name or an identifier.\n \n+   function Dynamic_Accessibility_Level (Expr : Node_Id) return Node_Id;\n+   --  Expr should be an expression of an access type.\n+   --  Builds an integer literal except in cases involving anonymous\n+   --  access types where accessibility levels are tracked at runtime\n+   --  (access parameters and Ada 2012 stand-alone objects).\n+\n+   function Effective_Extra_Accessibility (Id : Entity_Id) return Entity_Id;\n+   --  Same as Einfo.Extra_Accessibility except thtat object renames\n+   --  are looked through.\n+\n    function Enclosing_CPP_Parent (Typ : Entity_Id) return Entity_Id;\n    --  Returns the closest ancestor of Typ that is a CPP type.\n "}]}