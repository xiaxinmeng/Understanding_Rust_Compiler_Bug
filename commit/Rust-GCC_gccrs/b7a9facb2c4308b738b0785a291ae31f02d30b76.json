{"sha": "b7a9facb2c4308b738b0785a291ae31f02d30b76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdhOWZhY2IyYzQzMDhiNzM4YjA3ODVhMjkxYWUzMWYwMmQzMGI3Ng==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-05-01T20:29:16Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-05-01T20:29:16Z"}, "message": "re PR libstdc++/53115 (_Hashtable::_M_rehash_aux(false_type) is broken)\n\n2012-05-01  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\tPR libstdc++/53115\n\t* include/bits/hashtable.h\n\t(_Hashtable<>::_M_rehash_aux(size_type, false_type)): Fix buckets\n\tafter insertion of several equivalent elements.\n\t* testsuite/23_containers/unordered_multiset/insert/53115.cc: New.\n\t* testsuite/23_containers/unordered_multimap/insert/53115.cc: New.\n\nFrom-SVN: r187025", "tree": {"sha": "b2d182bb501655d7f677c5760dc42881ca1706c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2d182bb501655d7f677c5760dc42881ca1706c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7a9facb2c4308b738b0785a291ae31f02d30b76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7a9facb2c4308b738b0785a291ae31f02d30b76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7a9facb2c4308b738b0785a291ae31f02d30b76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7a9facb2c4308b738b0785a291ae31f02d30b76/comments", "author": null, "committer": null, "parents": [{"sha": "fb99ee9ba67fd5e7554036f9eced8bc9985e9779", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb99ee9ba67fd5e7554036f9eced8bc9985e9779", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb99ee9ba67fd5e7554036f9eced8bc9985e9779"}], "stats": {"total": 283, "additions": 246, "deletions": 37}, "files": [{"sha": "f8f37a8efd70791069e0c09b7508cb6a4e720352", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a9facb2c4308b738b0785a291ae31f02d30b76/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a9facb2c4308b738b0785a291ae31f02d30b76/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b7a9facb2c4308b738b0785a291ae31f02d30b76", "patch": "@@ -1,3 +1,12 @@\n+2012-05-01  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\tPR libstdc++/53115\n+\t* include/bits/hashtable.h\n+\t(_Hashtable<>::_M_rehash_aux(size_type, false_type)): Fix buckets\n+\tafter insertion of several equivalent elements.\n+\t* testsuite/23_containers/unordered_multiset/insert/53115.cc: New.\n+\t* testsuite/23_containers/unordered_multimap/insert/53115.cc: New.\n+\n 2012-04-29  Marc Glisse  <marc.glisse@inria.fr>\n \t    Paolo Carlini  <paolo.carlini@oracle.com>\n "}, {"sha": "9a795494916964771317332e05f9b9bc60b198c6", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a9facb2c4308b738b0785a291ae31f02d30b76/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a9facb2c4308b738b0785a291ae31f02d30b76/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=b7a9facb2c4308b738b0785a291ae31f02d30b76", "patch": "@@ -1698,58 +1698,56 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       while (__p)\n \t{\n-\t  bool __check_now = true;\n \t  __node_type* __next = __p->_M_next();\n \t  std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);\n \n-\t  if (!__new_buckets[__bkt])\n+\t  if (__prev_p && __prev_bkt == __bkt)\n \t    {\n-\t      __p->_M_nxt = _M_before_begin._M_nxt;\n-\t      _M_before_begin._M_nxt = __p;\n-\t      __new_buckets[__bkt] = &_M_before_begin;\n-\t      if (__p->_M_nxt)\n-\t\t__new_buckets[__bbegin_bkt] = __p;\n-\t      __bbegin_bkt = __bkt;\n+\t      // Previous insert was already in this bucket, we insert after\n+\t      // the previously inserted one to preserve equivalent elements\n+\t      // relative order.\n+\t      __p->_M_nxt = __prev_p->_M_nxt;\n+\t      __prev_p->_M_nxt = __p;\n+\n+\t      // Inserting after a node in a bucket require to check that we\n+\t      // haven't change the bucket last node, in this case next\n+\t      // bucket containing its before begin node must be updated. We\n+\t      // schedule a check as soon as we move out of the sequence of\n+\t      // equivalent nodes to limit the number of checks.\n+\t      __check_bucket = true;\n \t    }\n \t  else\n \t    {\n-\t      if (__prev_p && __prev_bkt == __bkt)\n+\t      if (__check_bucket)\n \t\t{\n-\t\t  // Previous insert was already in this bucket, we insert after\n-\t\t  // the previously inserted one to preserve equivalent elements\n-\t\t  // relative order.\n-\t\t  __p->_M_nxt = __prev_p->_M_nxt;\n-\t\t  __prev_p->_M_nxt = __p;\n-\n-\t\t  // Inserting after a node in a bucket require to check that we\n-\t\t  // haven't change the bucket last node, in this case next\n-\t\t  // bucket containing its before begin node must be updated. We\n-\t\t  // schedule a check as soon as we move out of the sequence of\n-\t\t  // equivalent nodes to limit the number of checks.\n-\t\t  __check_bucket = true;\n-\t\t  __check_now = false;\n+\t\t  // Check if we shall update the next bucket because of insertions\n+\t\t  // into __prev_bkt bucket.\n+\t\t  if (__prev_p->_M_nxt)\n+\t\t    {\n+\t\t      std::size_t __next_bkt\n+\t\t\t= __hash_code_base::_M_bucket_index(__prev_p->_M_next(),\n+\t\t\t\t\t\t\t    __n);\n+\t\t      if (__next_bkt != __prev_bkt)\n+\t\t\t__new_buckets[__next_bkt] = __prev_p;\n+\t\t    }\n+\t\t  __check_bucket = false;\n+\t\t}\n+\n+\t      if (!__new_buckets[__bkt])\n+\t\t{\n+\t\t  __p->_M_nxt = _M_before_begin._M_nxt;\n+\t\t  _M_before_begin._M_nxt = __p;\n+\t\t  __new_buckets[__bkt] = &_M_before_begin;\n+\t\t  if (__p->_M_nxt)\n+\t\t    __new_buckets[__bbegin_bkt] = __p;\n+\t\t  __bbegin_bkt = __bkt;\n \t\t}\n \t      else\n \t\t{\n \t\t  __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;\n \t\t  __new_buckets[__bkt]->_M_nxt = __p;\n \t\t}\n \t    }\n-\n-\t  if (__check_now && __check_bucket)\n-\t    {\n-\t      // Check if we shall update the next bucket because of insertions\n-\t      // into __prev_bkt bucket.\n-\t      if (__prev_p->_M_nxt)\n-\t\t{\n-\t\t  std::size_t __next_bkt\n-\t\t    = __hash_code_base::_M_bucket_index(__prev_p->_M_next(),\n-\t\t\t\t\t\t\t__n);\n-\t\t  if (__next_bkt != __prev_bkt)\n-\t\t    __new_buckets[__next_bkt] = __prev_p;\n-\t\t}\n-\t      __check_bucket = false;\n-\t    }\n \t  __prev_p = __p;\n \t  __prev_bkt = __bkt;\n \t  __p = __next;"}, {"sha": "4eb5d426197516b19a2c4c91f9e62c6a2bb32012", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/insert/53115.cc", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a9facb2c4308b738b0785a291ae31f02d30b76/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2F53115.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a9facb2c4308b738b0785a291ae31f02d30b76/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2F53115.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2F53115.cc?ref=b7a9facb2c4308b738b0785a291ae31f02d30b76", "patch": "@@ -0,0 +1,101 @@\n+// { dg-options \"-std=gnu++11\" }\n+//\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+namespace\n+{\n+  std::size_t\n+  get_nb_bucket_elems(const std::unordered_multimap<int, int>& us)\n+  {\n+    std::size_t nb = 0;\n+    for (std::size_t b = 0; b != us.bucket_count(); ++b)\n+      nb += us.bucket_size(b);\n+    return nb;\n+  }\n+}\n+\n+void test01()\n+{\n+  using namespace std;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::unordered_multimap<int, int> umm;\n+  umm.insert(make_pair(10, 1));\n+  VERIFY( umm.size() == 1 );\n+  VERIFY( std::distance(umm.begin(), umm.end()) == umm.size() );\n+  VERIFY( get_nb_bucket_elems(umm) == umm.size() );\n+\n+  umm.insert(make_pair(10, 2)); \n+  VERIFY( umm.size() == 2 );\n+  VERIFY( std::distance(umm.begin(), umm.end()) == umm.size() );\n+  VERIFY( get_nb_bucket_elems(umm) == umm.size() );\n+\n+  umm.insert(make_pair(10, 3));\n+  VERIFY( umm.size() == 3 );\n+  VERIFY( std::distance(umm.begin(), umm.end()) == umm.size() );\n+  VERIFY( get_nb_bucket_elems(umm) == umm.size() );\n+\n+  umm.insert(make_pair(10, 4));\n+  VERIFY( umm.size() == 4 );\n+  VERIFY( std::distance(umm.begin(), umm.end()) == umm.size() );\n+  VERIFY( get_nb_bucket_elems(umm) == umm.size() );\n+\n+  umm.insert(make_pair(10, 5));\n+  VERIFY( umm.size() == 5 );\n+  VERIFY( std::distance(umm.begin(), umm.end()) == umm.size() );\n+  VERIFY( get_nb_bucket_elems(umm) == umm.size() );\n+\n+  umm.insert(make_pair(24, 6));\n+  VERIFY( umm.size() == 6 );\n+  VERIFY( std::distance(umm.begin(), umm.end()) == umm.size() );\n+  VERIFY( get_nb_bucket_elems(umm) == umm.size() );\n+\n+  umm.insert(make_pair(25, 7));\n+  VERIFY( umm.size() == 7 );\n+  VERIFY( std::distance(umm.begin(), umm.end()) == umm.size() );\n+  VERIFY( get_nb_bucket_elems(umm) == umm.size() );\n+\n+  umm.insert(make_pair(2, 8));\n+  VERIFY( umm.size() == 8 );\n+  VERIFY( std::distance(umm.begin(), umm.end()) == umm.size() );\n+  VERIFY( get_nb_bucket_elems(umm) == umm.size() );\n+\n+  umm.insert(make_pair(2, 9));\n+  VERIFY( umm.size() == 9 );\n+  VERIFY( std::distance(umm.begin(), umm.end()) == umm.size() );\n+  VERIFY( get_nb_bucket_elems(umm) == umm.size() );\n+\n+  umm.insert(make_pair(1, 10));\n+  VERIFY( umm.size() == 10 );\n+  VERIFY( std::distance(umm.begin(), umm.end()) == umm.size() );\n+  VERIFY( get_nb_bucket_elems(umm) == umm.size() );\n+\n+  umm.insert(make_pair(10, 11));\n+  VERIFY( umm.size() == 11 );\n+  VERIFY( std::distance(umm.begin(), umm.end()) == umm.size() );\n+  VERIFY( get_nb_bucket_elems(umm) == umm.size() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "a23eacb753fceaf63523a75b76ba4003f2c7ac59", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/insert/53115.cc", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7a9facb2c4308b738b0785a291ae31f02d30b76/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2F53115.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7a9facb2c4308b738b0785a291ae31f02d30b76/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2F53115.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2F53115.cc?ref=b7a9facb2c4308b738b0785a291ae31f02d30b76", "patch": "@@ -0,0 +1,101 @@\n+// { dg-options \"-std=gnu++11\" }\n+//\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+\n+namespace\n+{\n+  std::size_t\n+  get_nb_bucket_elems(const std::unordered_multiset<int>& us)\n+  {\n+    std::size_t nb = 0;\n+    for (std::size_t b = 0; b != us.bucket_count(); ++b)\n+      nb += us.bucket_size(b);\n+    return nb;\n+  }\n+}\n+\n+void test01()\n+{\n+  using namespace std;\n+  bool test __attribute__((unused)) = true;\n+\n+  std::unordered_multiset<int> mms;\n+  mms.insert(10);\n+  VERIFY( mms.size() == 1 );\n+  VERIFY( std::distance(mms.begin(), mms.end()) == mms.size() );\n+  VERIFY( get_nb_bucket_elems(mms) == mms.size() );\n+\n+  mms.insert(10); \n+  VERIFY( mms.size() == 2 );\n+  VERIFY( std::distance(mms.begin(), mms.end()) == mms.size() );\n+  VERIFY( get_nb_bucket_elems(mms) == mms.size() );\n+\n+  mms.insert(10);\n+  VERIFY( mms.size() == 3 );\n+  VERIFY( std::distance(mms.begin(), mms.end()) == mms.size() );\n+  VERIFY( get_nb_bucket_elems(mms) == mms.size() );\n+\n+  mms.insert(10);\n+  VERIFY( mms.size() == 4 );\n+  VERIFY( std::distance(mms.begin(), mms.end()) == mms.size() );\n+  VERIFY( get_nb_bucket_elems(mms) == mms.size() );\n+\n+  mms.insert(10);\n+  VERIFY( mms.size() == 5 );\n+  VERIFY( std::distance(mms.begin(), mms.end()) == mms.size() );\n+  VERIFY( get_nb_bucket_elems(mms) == mms.size() );\n+\n+  mms.insert(24);\n+  VERIFY( mms.size() == 6 );\n+  VERIFY( std::distance(mms.begin(), mms.end()) == mms.size() );\n+  VERIFY( get_nb_bucket_elems(mms) == mms.size() );\n+\n+  mms.insert(25);\n+  VERIFY( mms.size() == 7 );\n+  VERIFY( std::distance(mms.begin(), mms.end()) == mms.size() );\n+  VERIFY( get_nb_bucket_elems(mms) == mms.size() );\n+\n+  mms.insert(2);\n+  VERIFY( mms.size() == 8 );\n+  VERIFY( std::distance(mms.begin(), mms.end()) == mms.size() );\n+  VERIFY( get_nb_bucket_elems(mms) == mms.size() );\n+\n+  mms.insert(2);\n+  VERIFY( mms.size() == 9 );\n+  VERIFY( std::distance(mms.begin(), mms.end()) == mms.size() );\n+  VERIFY( get_nb_bucket_elems(mms) == mms.size() );\n+\n+  mms.insert(1);\n+  VERIFY( mms.size() == 10 );\n+  VERIFY( std::distance(mms.begin(), mms.end()) == mms.size() );\n+  VERIFY( get_nb_bucket_elems(mms) == mms.size() );\n+\n+  mms.insert(10);\n+  VERIFY( mms.size() == 11 );\n+  VERIFY( std::distance(mms.begin(), mms.end()) == mms.size() );\n+  VERIFY( get_nb_bucket_elems(mms) == mms.size() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}