{"sha": "2156dfe3834bd6b3f5f2d411232caa61193e554b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE1NmRmZTM4MzRiZDZiM2Y1ZjJkNDExMjMyY2FhNjExOTNlNTU0Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-09-20T09:53:06Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-09-20T09:53:06Z"}, "message": "(jump_optimize): Delete insns that set registers that are not used elsewhere.\n\nFix some bugs in \"if (...) x = a; else x = b;\" code.\nRemove uses of reorder_insns.\nAdd code to make scc insns for \"if (...) x = exp;\" if EXP is simple enough.\nOptimize \"if (...) x = b;\" if jumps very expensive; don't use a REG as the\nolder value of X since it doesn't help and can hurt.\nCorrectly place generated insns in above case.\n\nFrom-SVN: r2191", "tree": {"sha": "deae361b5a5e075501b62272069b250615b5ba0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/deae361b5a5e075501b62272069b250615b5ba0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2156dfe3834bd6b3f5f2d411232caa61193e554b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2156dfe3834bd6b3f5f2d411232caa61193e554b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2156dfe3834bd6b3f5f2d411232caa61193e554b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2156dfe3834bd6b3f5f2d411232caa61193e554b/comments", "author": null, "committer": null, "parents": [{"sha": "255680cfb0c2be0083f46f9cacdeba9342275b41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/255680cfb0c2be0083f46f9cacdeba9342275b41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/255680cfb0c2be0083f46f9cacdeba9342275b41"}], "stats": {"total": 271, "additions": 230, "deletions": 41}, "files": [{"sha": "ab2a2550396cb1f12790e3d6ae9ece0c6e56f8b1", "filename": "gcc/jump.c", "status": "modified", "additions": 230, "deletions": 41, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2156dfe3834bd6b3f5f2d411232caa61193e554b/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2156dfe3834bd6b3f5f2d411232caa61193e554b/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=2156dfe3834bd6b3f5f2d411232caa61193e554b", "patch": "@@ -143,7 +143,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n      int noop_moves;\n      int after_regscan;\n {\n-  register rtx insn;\n+  register rtx insn, next;\n   int changed;\n   int first = 1;\n   int max_uid = 0;\n@@ -299,7 +299,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n   if (noop_moves)\n     for (insn = f; insn; )\n       {\n-\tregister rtx next = NEXT_INSN (insn);\n+\tnext = NEXT_INSN (insn);\n \n \tif (GET_CODE (insn) == INSN)\n \t  {\n@@ -525,17 +525,36 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n       insn = next;\n     }\n \n+  /* If we haven't yet gotten to reload and we have just run regscan,\n+     delete any insn that sets a register that isn't used elsewhere.\n+     This helps some of the optimizations below by having less insns\n+     being jumped around.  */\n+\n+  if (! reload_completed && after_regscan)\n+    for (insn = f; insn; insn = next)\n+      {\n+\trtx set = single_set (insn);\n+\n+\tnext = NEXT_INSN (insn);\n+\n+\tif (set && GET_CODE (SET_DEST (set)) == REG\n+\t    && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n+\t    && regno_first_uid[REGNO (SET_DEST (set))] == INSN_UID (insn)\n+\t    && regno_last_uid[REGNO (SET_DEST (set))] == INSN_UID (insn)\n+\t    && ! side_effects_p (SET_SRC (set)))\n+\t  delete_insn (insn);\n+      }\n+\n   /* Now iterate optimizing jumps until nothing changes over one pass.  */\n   changed = 1;\n   while (changed)\n     {\n-      register rtx next;\n       changed = 0;\n \n       for (insn = f; insn; insn = next)\n \t{\n \t  rtx reallabelprev;\n-\t  rtx temp, temp1, temp2, temp3, temp4, temp5;\n+\t  rtx temp, temp1, temp2, temp3, temp4, temp5, temp6;\n \t  rtx nlabel;\n \t  int this_is_simplejump, this_is_condjump, reversep;\n #if 0\n@@ -649,12 +668,11 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t    {\n \t      if (GET_CODE (temp1) == BARRIER)\n \t\t{\n-\t\t  reorder_insns (temp, temp, temp1);\n+\t\t  emit_insn_after (PATTERN (temp), temp1);\n \t\t  temp1 = NEXT_INSN (temp1);\n \t\t}\n-\t      else\n-\t\tdelete_insn (temp);\n \n+\t      delete_insn (temp);\n \t      redirect_jump (insn, get_label_before (temp1));\n \t      reallabelprev = prev_real_insn (temp1);\n \t      changed = 1;\n@@ -685,29 +703,30 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t     TEMP to the jump insn preceding \"x = a;\"\n \t     TEMP1 to X\n \t     TEMP2 to the insn that sets \"x = b;\"\n-\t     TEMP3 to the insn that sets \"x = a;\"  */\n+\t     TEMP3 to the insn that sets \"x = a;\"\n+\t     TEMP4 to the set of \"x = b\";  */\n \n \t  if (this_is_simplejump\n \t      && (temp3 = prev_active_insn (insn)) != 0\n \t      && GET_CODE (temp3) == INSN\n-\t      && GET_CODE (PATTERN (temp3)) == SET\n-\t      && GET_CODE (temp1 = SET_DEST (PATTERN (temp3))) == REG\n+\t      && (temp4 = single_set (temp3)) != 0\n+\t      && GET_CODE (temp1 = SET_DEST (temp4)) == REG\n #ifdef SMALL_REGISTER_CLASSES\n \t      && REGNO (temp1) >= FIRST_PSEUDO_REGISTER\n #endif\n \t      && (temp2 = next_active_insn (insn)) != 0\n \t      && GET_CODE (temp2) == INSN\n-\t      && GET_CODE (PATTERN (temp2)) == SET\n-\t      && rtx_equal_p (SET_DEST (PATTERN (temp2)), temp1)\n-\t      && (GET_CODE (SET_SRC (PATTERN (temp2))) == REG\n-\t\t  || GET_CODE (SET_SRC (PATTERN (temp2))) == SUBREG\n-\t\t  || CONSTANT_P (SET_SRC (PATTERN (temp2))))\n+\t      && (temp4 = single_set (temp2)) != 0\n+\t      && rtx_equal_p (SET_DEST (temp4), temp1)\n+\t      && (GET_CODE (SET_SRC (temp4)) == REG\n+\t\t  || GET_CODE (SET_SRC (temp4)) == SUBREG\n+\t\t  || CONSTANT_P (SET_SRC (temp4)))\n \t      && (REG_NOTES (temp2) == 0\n \t\t  || ((REG_NOTE_KIND (REG_NOTES (temp2)) == REG_EQUAL\n \t\t       || REG_NOTE_KIND (REG_NOTES (temp2)) == REG_EQUIV)\n \t\t      && XEXP (REG_NOTES (temp2), 1) == 0\n \t\t      && rtx_equal_p (XEXP (REG_NOTES (temp2), 0),\n-\t\t\t\t      SET_SRC (PATTERN (temp2)))))\n+\t\t\t\t      SET_SRC (temp4))))\n \t      && (temp = prev_active_insn (temp3)) != 0\n \t      && condjump_p (temp) && ! simplejump_p (temp)\n \t      /* TEMP must skip over the \"x = a;\" insn */\n@@ -718,9 +737,9 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t      /* INSN must either branch to the insn after TEMP2 or the insn\n \t\t after TEMP2 must branch to the same place as INSN.  */\n \t      && (reallabelprev == temp2\n-\t\t  || ((temp4 = next_active_insn (temp2)) != 0\n-\t\t      && simplejump_p (temp4)\n-\t\t      && JUMP_LABEL (temp4) == JUMP_LABEL (insn))))\n+\t\t  || ((temp5 = next_active_insn (temp2)) != 0\n+\t\t      && simplejump_p (temp5)\n+\t\t      && JUMP_LABEL (temp5) == JUMP_LABEL (insn))))\n \t    {\n \t      /* The test expression, X, may be a complicated test with\n \t\t multiple branches.  See if we can find all the uses of\n@@ -768,11 +787,11 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t  && no_labels_between_p (p, insn)\n \t\t  && ! reg_referenced_between_p (temp1, p, NEXT_INSN (temp3))\n \t\t  && ! reg_set_between_p (temp1, p, temp3)\n-\t\t  && (GET_CODE (SET_SRC (PATTERN (temp2))) == CONST_INT\n-\t\t      || ! reg_set_between_p (SET_SRC (PATTERN (temp2)),\n-\t\t\t\t\t      p, temp2)))\n+\t\t  && (GET_CODE (SET_SRC (temp4)) == CONST_INT\n+\t\t      || ! reg_set_between_p (SET_SRC (temp4), p, temp2)))\n \t\t{\n-\t\t  reorder_insns_with_line_notes (temp2, temp2, p);\n+\t\t  emit_insn_after_with_line_notes (PATTERN (temp2), p, temp2);\n+\t\t  delete_insn (temp2);\n \n \t\t  /* Set NEXT to an insn that we know won't go away.  */\n \t\t  next = next_active_insn (insn);\n@@ -796,6 +815,151 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t}\n \t    }\n \n+#ifndef HAVE_cc0\n+\t  /* If we have if (...) x = exp;  and branches are expensive,\n+\t     EXP is a single insn, does not have any side effects, cannot\n+\t     trap, and is not too costly, convert this to\n+\t     t = exp; if (...) x = t;\n+\n+\t     Don't do this when we have CC0 because it is unlikely to help\n+\t     and we'd need to worry about where to place the new insn and\n+\t     the potential for conflicts.  We also can't do this when we have\n+\t     notes on the insn for the same reason as above.\n+\n+\t     We set:\n+\n+\t     TEMP to the \"x = exp;\" insn.\n+\t     TEMP1 to the single set in the \"x = exp; insn.\n+\t     TEMP2 to \"x\".  */\n+\n+\t  if (! reload_completed\n+\t      && this_is_condjump && ! this_is_simplejump\n+\t      && BRANCH_COST >= 3\n+\t      && (temp = next_nonnote_insn (insn)) != 0\n+\t      && REG_NOTES (temp) == 0\n+\t      && (reallabelprev == temp\n+\t\t  || ((temp2 = next_active_insn (temp)) != 0\n+\t\t      && simplejump_p (temp2)\n+\t\t      && JUMP_LABEL (temp2) == JUMP_LABEL (insn)))\n+\t      && (temp1 = single_set (temp)) != 0\n+\t      && (temp2 = SET_DEST (temp1), GET_CODE (temp2) == REG)\n+\t      && GET_MODE_CLASS (GET_MODE (temp2)) == MODE_INT\n+#ifdef SMALL_REGISTER_CLASSES\n+\t      && REGNO (temp2) >= FIRST_PSEUDO_REGISTER\n+#endif\n+\t      && GET_CODE (SET_SRC (temp1)) != REG\n+\t      && GET_CODE (SET_SRC (temp1)) != SUBREG\n+\t      && GET_CODE (SET_SRC (temp1)) != CONST_INT\n+\t      && ! side_effects_p (SET_SRC (temp1))\n+\t      && ! may_trap_p (SET_SRC (temp1))\n+\t      && rtx_cost (SET_SRC (temp1)) < 10)\n+\t    {\n+\t      rtx new = gen_reg_rtx (GET_MODE (temp2));\n+\n+\t      if (validate_change (temp, &SET_DEST (temp1), new, 0))\n+\t\t{\n+\t\t  next = emit_insn_after (gen_move_insn (temp2, new), insn);\n+\t\t  emit_insn_after_with_line_notes (PATTERN (temp), \n+\t\t\t\t\t\t   PREV_INSN (insn), temp);\n+\t\t  delete_insn (temp);\n+\t\t}\n+\t    }\n+\n+\t  /* Similarly, if it takes two insns to compute EXP but they\n+\t     have the same destination.  Here TEMP3 will be the second\n+\t     insn and TEMP4 the SET from that insn.  */\n+\n+\t  if (! reload_completed\n+\t      && this_is_condjump && ! this_is_simplejump\n+\t      && BRANCH_COST >= 4\n+\t      && (temp = next_nonnote_insn (insn)) != 0\n+\t      && REG_NOTES (temp) == 0\n+\t      && (temp3 = next_nonnote_insn (temp)) != 0\n+\t      && REG_NOTES (temp3) == 0\n+\t      && (reallabelprev == temp3\n+\t\t  || ((temp2 = next_active_insn (temp3)) != 0\n+\t\t      && simplejump_p (temp2)\n+\t\t      && JUMP_LABEL (temp2) == JUMP_LABEL (insn)))\n+\t      && (temp1 = single_set (temp)) != 0\n+\t      && (temp2 = SET_DEST (temp1), GET_CODE (temp2) == REG)\n+\t      && GET_MODE_CLASS (GET_MODE (temp2)) == MODE_INT\n+#ifdef SMALL_REGISTER_CLASSES\n+\t      && REGNO (temp2) >= FIRST_PSEUDO_REGISTER\n+#endif\n+\t      && ! side_effects_p (SET_SRC (temp1))\n+\t      && ! may_trap_p (SET_SRC (temp1))\n+\t      && rtx_cost (SET_SRC (temp1)) < 10\n+\t      && (temp4 = single_set (temp3)) != 0\n+\t      && rtx_equal_p (SET_DEST (temp4), temp2)\n+\t      && ! side_effects_p (SET_SRC (temp4))\n+\t      && ! may_trap_p (SET_SRC (temp4))\n+\t      && rtx_cost (SET_SRC (temp4)) < 10)\n+\t    {\n+\t      rtx new = gen_reg_rtx (GET_MODE (temp2));\n+\n+\t      if (validate_change (temp, &SET_DEST (temp1), new, 0))\n+\t\t{\n+\t\t  next = emit_insn_after (gen_move_insn (temp2, new), insn);\n+\t\t  emit_insn_after_with_line_notes (PATTERN (temp),\n+\t\t\t\t\t\t   PREV_INSN (insn), temp);\n+\t\t  emit_insn_after_with_line_notes\n+\t\t    (replace_rtx (PATTERN (temp3), temp2, new),\n+\t\t     PREV_INSN (insn), temp3);\n+\t\t  delete_insn (temp);\n+\t\t  delete_insn (temp3);\n+\t\t}\n+\t    }\n+\n+\t  /* Finally, handle the case where two insns are used to \n+\t     compute EXP but a temporary register is used.  Here we must\n+\t     ensure that the temporary register is not used anywhere else. */\n+\n+\t  if (! reload_completed\n+\t      && after_regscan\n+\t      && this_is_condjump && ! this_is_simplejump\n+\t      && BRANCH_COST >= 4\n+\t      && (temp = next_nonnote_insn (insn)) != 0\n+\t      && REG_NOTES (temp) == 0\n+\t      && (temp3 = next_nonnote_insn (temp)) != 0\n+\t      && REG_NOTES (temp3) == 0\n+\t      && (reallabelprev == temp3\n+\t\t  || ((temp2 = next_active_insn (temp3)) != 0\n+\t\t      && simplejump_p (temp2)\n+\t\t      && JUMP_LABEL (temp2) == JUMP_LABEL (insn)))\n+\t      && (temp1 = single_set (temp)) != 0\n+\t      && (temp5 = SET_DEST (temp1), GET_CODE (temp5) == REG)\n+\t      && REGNO (temp5) >= FIRST_PSEUDO_REGISTER\n+\t      && regno_first_uid[REGNO (temp5)] == INSN_UID (temp)\n+\t      && regno_last_uid[REGNO (temp5)] == INSN_UID (temp3)\n+\t      && ! side_effects_p (SET_SRC (temp1))\n+\t      && ! may_trap_p (SET_SRC (temp1))\n+\t      && rtx_cost (SET_SRC (temp1)) < 10\n+\t      && (temp4 = single_set (temp3)) != 0\n+\t      && (temp2 = SET_DEST (temp4), GET_CODE (temp2) == REG)\n+\t      && GET_MODE_CLASS (GET_MODE (temp2)) == MODE_INT\n+#ifdef SMALL_REGISTER_CLASSES\n+\t      && REGNO (temp2) >= FIRST_PSEUDO_REGISTER\n+#endif\n+\t      && rtx_equal_p (SET_DEST (temp4), temp2)\n+\t      && ! side_effects_p (SET_SRC (temp4))\n+\t      && ! may_trap_p (SET_SRC (temp4))\n+\t      && rtx_cost (SET_SRC (temp4)) < 10)\n+\t    {\n+\t      rtx new = gen_reg_rtx (GET_MODE (temp2));\n+\n+\t      if (validate_change (temp3, &SET_DEST (temp4), new, 0))\n+\t\t{\n+\t\t  next = emit_insn_after (gen_move_insn (temp2, new), insn);\n+\t\t  emit_insn_after_with_line_notes (PATTERN (temp),\n+\t\t\t\t\t\t   PREV_INSN (insn), temp);\n+\t\t  emit_insn_after_with_line_notes (PATTERN (temp3),\n+\t\t\t\t\t\t   PREV_INSN (insn), temp3);\n+\t\t  delete_insn (temp);\n+\t\t  delete_insn (temp3);\n+\t\t}\n+\t    }\n+#endif /* HAVE_cc0 */\n+\n \t  /* We deal with four cases:\n \n \t     1) x = a; if (...) x = b; and either A or B is zero,\n@@ -804,6 +968,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t        set bits in A are also set in B and jumps are expensive, and\n \t     4) x = a; if (...) x = b; and A and B non-zero, and jumps are\n \t        more expensive.\n+\t     5) if (...) x = b; if jumps are even more expensive.\n \n \t     In each of these try to use a store-flag insn to avoid the jump.\n \t     (If the jump would be faster, the machine should not have\n@@ -834,18 +999,18 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t      && (GET_CODE (temp2 = SET_SRC (PATTERN (temp))) == REG\n \t\t  || GET_CODE (temp2) == SUBREG\n \t\t  || GET_CODE (temp2) == CONST_INT)\n-\t      /* Allow either form, but prefer the former if both apply.  */\n+\t      /* Allow either form, but prefer the former if both apply. \n+\t\t There is no point in using the old value of TEMP1 if\n+\t\t it is a register, since cse will alias them.  It can\n+\t\t lose if the old value were a hard register since CSE\n+\t\t won't replace hard registers.  */\n \t      && (((temp3 = reg_set_last (temp1, insn)) != 0\n-\t\t   && ((GET_CODE (temp3) == REG\n-#ifdef SMALL_REGISTER_CLASSES\n-\t\t\t&& REGNO (temp3) >= FIRST_PSEUDO_REGISTER\n-#endif\n-\t\t\t)\n-\t\t       || GET_CODE (temp3) == SUBREG\n-\t\t       || GET_CODE (temp3) == CONST_INT))\n+\t\t   && GET_CODE (temp3) == CONST_INT)\n \t\t  /* Make the latter case look like  x = x; if (...) x = 0;  */\n-\t\t  || ((temp3 = temp1, BRANCH_COST >= 2)\n-\t\t      && temp2 == const0_rtx))\n+\t\t  || (temp3 = temp1,\n+\t\t      ((BRANCH_COST >= 2\n+\t\t\t&& temp2 == const0_rtx)\n+\t\t       || BRANCH_COST >= 3)))\n \t      /* INSN must either branch to the insn after TEMP or the insn\n \t\t after TEMP must branch to the same place as INSN.  */\n \t      && (reallabelprev == temp\n@@ -868,7 +1033,16 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t\t  || ((INTVAL (temp2) & INTVAL (temp3)) == INTVAL (temp3)\n \t\t\t      && (reversep = can_reverse_comparison_p (temp4,\n \t\t\t\t\t\t\t\t       insn)))))\n-\t\t  || BRANCH_COST >= 3))\n+\t\t  || BRANCH_COST >= 3)\n+#ifdef HAVE_cc0\n+\t      /* If the previous insn sets CC0 and something else, we can't\n+\t\t do this since we are going to delete that insn.  */\n+\n+\t      && ! ((temp6 = prev_nonnote_insn (insn)) != 0\n+\t\t    && GET_CODE (temp6) == INSN\n+\t\t    && sets_cc0_p (PATTERN (temp6)) == -1)\n+#endif\n+\t      )\n \t    {\n \t      enum rtx_code code = GET_CODE (temp4);\n \t      rtx uval, cval, var = temp1;\n@@ -916,6 +1090,21 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t{\n \t\t  rtx seq;\n \n+\t\t  /* Put the store-flag insns in front of the first insn\n+\t\t     used to compute the condition to ensure that we\n+\t\t     use the same values of them as the current \n+\t\t     comparison.  However, the remainder of the insns we\n+\t\t     generate will be placed directly in front of the\n+\t\t     jump insn, in case any of the pseudos we use\n+\t\t     are modified earlier.  */\n+\n+\t\t  seq = get_insns ();\n+\t\t  end_sequence ();\n+\n+\t\t  emit_insns_before (seq, temp5);\n+\n+\t\t  start_sequence ();\n+\n \t\t  /* Both CVAL and UVAL are non-zero.  */\n \t\t  if (cval != const0_rtx && uval != const0_rtx)\n \t\t    {\n@@ -950,16 +1139,16 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t\t\t\t  && ! preserve_subexpressions_p ()\n \t\t\t\t\t  ? target : NULL_RTX));\n \t\t  \n-\t\t  seq = gen_sequence ();\n+\t\t  emit_move_insn (var, target);\n+\t\t  seq = get_insns ();\n \t\t  end_sequence ();\n-\t\t  emit_insn_before (seq, temp5);\n-\t\t  emit_insn_after (gen_move_insn (var, target), insn);\n+\n+\t\t  emit_insns_before (seq, insn);\n+\n \t\t  delete_insn (temp);\n \t\t  next = NEXT_INSN (insn);\n-#ifdef HAVE_cc0\n-\t\t  delete_insn (prev_nonnote_insn (insn));\n-#endif\n-\t\t  delete_insn (insn);\n+\n+\t\t  delete_jump (insn);\n \t\t  changed = 1;\n \t\t  continue;\n \t\t}"}]}