{"sha": "14be28e5f43fa2710e15441ff8b4e54b64295303", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRiZTI4ZTVmNDNmYTI3MTBlMTU0NDFmZjhiNGU1NGI2NDI5NTMwMw==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@redhat.com", "date": "2001-01-01T00:49:30Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2001-01-01T00:49:30Z"}, "message": "loop.h (struct iv): New.\n\n\t* loop.h (struct iv): New.\n\t(REG_IV_TYPE, REG_IV_CLASS, REG_INFO): Modify to use 'struct iv'.\n\t(struct loop_ivs): Replace 'reg_iv_type', 'reg_iv_info',\n\t'reg_biv_class' fields with 'regs' and 'n_regs'.\n\t(struct ivs): Rename 'loop_iv_list' field to 'list'.\n\t* loop.c (loop_bivs_find, strength_reduce): Use ivs->regs array.\n\t* unroll.c (loop_iterations): Check array bounds with ivs->n_regs.\n\nFrom-SVN: r38582", "tree": {"sha": "33ca0f377662aa610d440a02bd9c36e0241f73aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33ca0f377662aa610d440a02bd9c36e0241f73aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14be28e5f43fa2710e15441ff8b4e54b64295303", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14be28e5f43fa2710e15441ff8b4e54b64295303", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14be28e5f43fa2710e15441ff8b4e54b64295303", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14be28e5f43fa2710e15441ff8b4e54b64295303/comments", "author": null, "committer": null, "parents": [{"sha": "1d2215feb99eee4186a842f93484ac3130f2f20a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d2215feb99eee4186a842f93484ac3130f2f20a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d2215feb99eee4186a842f93484ac3130f2f20a"}], "stats": {"total": 153, "additions": 82, "deletions": 71}, "files": [{"sha": "6f813063c06b29f622100134fe380c441cc29b16", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14be28e5f43fa2710e15441ff8b4e54b64295303/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14be28e5f43fa2710e15441ff8b4e54b64295303/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14be28e5f43fa2710e15441ff8b4e54b64295303", "patch": "@@ -1,3 +1,13 @@\n+2001-01-01  Michael Hayes  <mhayes@redhat.com>\n+\n+\t* loop.h (struct iv): New.\n+\t(REG_IV_TYPE, REG_IV_CLASS, REG_INFO): Modify to use 'struct iv'.\n+\t(struct loop_ivs): Replace 'reg_iv_type', 'reg_iv_info',\n+\t'reg_biv_class' fields with 'regs' and 'n_regs'.\n+\t(struct ivs): Rename 'loop_iv_list' field to 'list'.\n+\t* loop.c (loop_bivs_find, strength_reduce): Use ivs->regs array.\n+\t* unroll.c (loop_iterations): Check array bounds with ivs->n_regs.\n+\n 2000-12-31  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* resource.c (mark_referenced_resources): Abort() before"}, {"sha": "5882a813d518f0fde3c65df6167798980c70c6d6", "filename": "gcc/loop.c", "status": "modified", "additions": 24, "deletions": 35, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14be28e5f43fa2710e15441ff8b4e54b64295303/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14be28e5f43fa2710e15441ff8b4e54b64295303/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=14be28e5f43fa2710e15441ff8b4e54b64295303", "patch": "@@ -3652,27 +3652,16 @@ loop_bivs_find (loop)\n {\n   struct loop_regs *regs = LOOP_REGS (loop);\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n-  /* Temporary list pointers for traversing ivs->loop_iv_list.  */\n+  /* Temporary list pointers for traversing ivs->list.  */\n   struct iv_class *bl, **backbl;\n-  /* Ratio of extra register life span we can justify\n-     for saving an instruction.  More if loop doesn't call subroutines\n-     since in that case saving an insn makes more difference\n-     and more registers are available.  */\n-  /* ??? could set this to last value of threshold in move_movables */\n-\n-  ivs->loop_iv_list = 0;\n \n-  VARRAY_INT_INIT (ivs->reg_iv_type, max_reg_before_loop, \"reg_iv_type\");\n-  VARRAY_GENERIC_PTR_INIT (ivs->reg_iv_info, max_reg_before_loop,\n-\t\t\t   \"reg_iv_info\");\n-  ivs->reg_biv_class = (struct iv_class **)\n-    xcalloc (max_reg_before_loop, sizeof (struct iv_class *));\n+  ivs->list = 0;\n \n   for_each_insn_in_loop (loop, check_insn_for_bivs);\n   \n-  /* Scan ivs->loop_iv_list to remove all regs that proved not to be bivs.\n+  /* Scan ivs->list to remove all regs that proved not to be bivs.\n      Make a sanity check against regs->n_times_set.  */\n-  for (backbl = &ivs->loop_iv_list, bl = *backbl; bl; bl = bl->next)\n+  for (backbl = &ivs->list, bl = *backbl; bl; bl = bl->next)\n     {\n       if (REG_IV_TYPE (ivs, bl->regno) != BASIC_INDUCT\n \t  /* Above happens if register modified by subreg, etc.  */\n@@ -3711,7 +3700,7 @@ loop_bivs_init_find (loop)\n      struct loop *loop;\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n-  /* Temporary list pointers for traversing ivs->loop_iv_list.  */\n+  /* Temporary list pointers for traversing ivs->list.  */\n   struct iv_class *bl;\n   int call_seen;\n   rtx p;\n@@ -3767,11 +3756,11 @@ loop_bivs_check (loop)\n      struct loop *loop;\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n-  /* Temporary list pointers for traversing ivs->loop_iv_list.  */\n+  /* Temporary list pointers for traversing ivs->list.  */\n   struct iv_class *bl;\n   struct iv_class **backbl;\n \n-  for (backbl = &ivs->loop_iv_list; (bl = *backbl); backbl = &bl->next)\n+  for (backbl = &ivs->list; (bl = *backbl); backbl = &bl->next)\n     {\n       rtx src;\n       rtx note;\n@@ -3846,7 +3835,7 @@ loop_givs_check (loop)\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   struct iv_class *bl;\n \n-  for (bl = ivs->loop_iv_list; bl; bl = bl->next)\n+  for (bl = ivs->list; bl; bl = bl->next)\n     {\n       struct induction *v;\n \n@@ -4280,7 +4269,7 @@ strength_reduce (loop, insn_count, flags)\n   struct loop_regs *regs = LOOP_REGS (loop);\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   rtx p;\n-  /* Temporary list pointer for traversing ivs->loop_iv_list.  */\n+  /* Temporary list pointer for traversing ivs->list.  */\n   struct iv_class *bl;\n   /* Ratio of extra register life span we can justify\n      for saving an instruction.  More if loop doesn't call subroutines\n@@ -4309,12 +4298,14 @@ strength_reduce (loop, insn_count, flags)\n   else\n     end_insert_before = emit_note_after (NOTE_INSN_DELETED, loop->end);\n \n+  ivs->n_regs = max_reg_before_loop;\n+  ivs->regs = (struct iv *) xcalloc (ivs->n_regs, sizeof (struct iv));\n \n   /* Find all BIVs in loop.  */\n   loop_bivs_find (loop);\n \n   /* Exit if there are no bivs.  */\n-  if (! ivs->loop_iv_list)\n+  if (! ivs->list)\n     {\n       /* Can still unroll the loop anyways, but indicate that there is no\n \t strength reduction info available.  */\n@@ -4355,13 +4346,13 @@ strength_reduce (loop, insn_count, flags)\n   /* Create reg_map to hold substitutions for replaceable giv regs.\n      Some givs might have been made from biv increments, so look at\n      ivs->reg_iv_type for a suitable size.  */\n-  reg_map_size = ivs->reg_iv_type->num_elements;\n+  reg_map_size = ivs->n_regs;\n   reg_map = (rtx *) xcalloc (reg_map_size, sizeof (rtx));\n \n   /* Examine each iv class for feasibility of strength reduction/induction\n      variable elimination.  */\n \n-  for (bl = ivs->loop_iv_list; bl; bl = bl->next)\n+  for (bl = ivs->list; bl; bl = bl->next)\n     {\n       struct induction *v;\n       int benefit;\n@@ -4581,11 +4572,9 @@ strength_reduce (loop, insn_count, flags)\n     fprintf (loop_dump_stream, \"\\n\");\n \n egress:\n-  VARRAY_FREE (ivs->reg_iv_type);\n-  VARRAY_FREE (ivs->reg_iv_info);\n-  free (ivs->reg_biv_class);\n+  free (ivs->regs);\n   {\n-    struct iv_class *iv = ivs->loop_iv_list;\n+    struct iv_class *iv = ivs->list;\n \n     while (iv) {\n       struct iv_class *next = iv->next;\n@@ -4941,9 +4930,9 @@ record_biv (loop, v, insn, dest_reg, inc_val, mult_val, location,\n       bl->reversed = 0;\n       bl->total_benefit = 0;\n \n-      /* Add this class to ivs->loop_iv_list.  */\n-      bl->next = ivs->loop_iv_list;\n-      ivs->loop_iv_list = bl;\n+      /* Add this class to ivs->list.  */\n+      bl->next = ivs->list;\n+      ivs->list = bl;\n \n       /* Put it in the array of biv register classes.  */\n       REG_IV_CLASS (ivs, REGNO (dest_reg)) = bl;\n@@ -5448,7 +5437,7 @@ update_giv_derive (loop, p)\n      subsequent biv update was performed.  If this adjustment cannot be done,\n      the giv cannot derive further givs.  */\n \n-  for (bl = ivs->loop_iv_list; bl; bl = bl->next)\n+  for (bl = ivs->list; bl; bl = bl->next)\n     for (biv = bl->biv; biv; biv = biv->next_iv)\n       if (GET_CODE (p) == CODE_LABEL || GET_CODE (p) == JUMP_INSN\n \t  || biv->insn == p)\n@@ -5750,7 +5739,7 @@ general_induction_var (loop, x, src_reg, add_val, mult_val, ext_val,\n       /* Since this is now an invariant and wasn't before, it must be a giv\n \t with MULT_VAL == 0.  It doesn't matter which BIV we associate this\n \t with.  */\n-      *src_reg = ivs->loop_iv_list->biv->dest_reg;\n+      *src_reg = ivs->list->biv->dest_reg;\n       *mult_val = const0_rtx;\n       *add_val = x;\n       break;\n@@ -7271,7 +7260,7 @@ check_dbra_loop (loop, insn_count)\n      it will be zero on the last iteration.  Also skip if the biv is\n      used between its update and the test insn.  */\n \n-  for (bl = ivs->loop_iv_list; bl; bl = bl->next)\n+  for (bl = ivs->list; bl; bl = bl->next)\n     {\n       if (bl->biv_count == 1\n \t  && ! bl->biv->maybe_multiple\n@@ -7461,7 +7450,7 @@ check_dbra_loop (loop, insn_count)\n \t   && reversible_mem_store\n \t   && (bl->giv_count + bl->biv_count + loop_info->num_mem_sets\n \t       + LOOP_MOVABLES (loop)->num + compare_and_branch == insn_count)\n-\t   && (bl == ivs->loop_iv_list && bl->next == 0))\n+\t   && (bl == ivs->list && bl->next == 0))\n \t  || no_use_except_counting)\n \t{\n \t  rtx tem;\n@@ -7760,7 +7749,7 @@ check_dbra_loop (loop, insn_count)\n \t\t       REG_EQUAL notes should still be correct.  */\n \t\t    if (! set\n \t\t\t|| GET_CODE (SET_DEST (set)) != REG\n-\t\t\t|| (size_t) REGNO (SET_DEST (set)) >= ivs->reg_iv_type->num_elements\n+\t\t\t|| (size_t) REGNO (SET_DEST (set)) >= ivs->n_regs\n \t\t\t|| REG_IV_TYPE (ivs, REGNO (SET_DEST (set))) != GENERAL_INDUCT\n \t\t\t|| REG_IV_INFO (ivs, REGNO (SET_DEST (set)))->src_reg != bl->biv->src_reg)\n \t\t      for (pnote = &REG_NOTES (p); *pnote;)"}, {"sha": "5b576949fbc8c319c28175568091f2cb638082b2", "filename": "gcc/loop.h", "status": "modified", "additions": 44, "deletions": 32, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14be28e5f43fa2710e15441ff8b4e54b64295303/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14be28e5f43fa2710e15441ff8b4e54b64295303/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=14be28e5f43fa2710e15441ff8b4e54b64295303", "patch": "@@ -54,7 +54,7 @@ Boston, MA 02111-1307, USA.  */\n    value is a linear function of a biv.  */\n \n /* Bivs are recognized by `basic_induction_var';\n-   Givs by `general_induct_var'.  */\n+   Givs by `general_induction_var'.  */\n \n /* An enum for the two different types of givs, those that are used\n    as memory addresses and those that are calculated into registers.  */\n@@ -64,6 +64,7 @@ enum g_types\n   DEST_REG\n };\n \n+\n /* A `struct induction' is created for every instruction that sets\n    an induction variable (either a biv or a giv).  */\n \n@@ -152,6 +153,7 @@ struct induction\n \t\t\t\t   a substitute for the lifetime information.  */\n };\n \n+\n /* A `struct iv_class' is created for each biv.  */\n \n struct iv_class\n@@ -182,35 +184,58 @@ struct iv_class\n                                    been reduced. */\n };\n \n-typedef struct loop_mem_info\n+\n+/* Definitions used by the basic induction variable discovery code.  */\n+enum iv_mode\n {\n-  rtx mem;      /* The MEM itself.  */\n-  rtx reg;      /* Corresponding pseudo, if any.  */\n-  int optimize; /* Nonzero if we can optimize access to this MEM.  */\n-} loop_mem_info;\n+  UNKNOWN_INDUCT,\n+  BASIC_INDUCT,\n+  NOT_BASIC_INDUCT,\n+  GENERAL_INDUCT\n+};\n \n-struct loop_ivs\n+\n+/* A `struct iv' is created for every register.  */\n+\n+struct iv\n {\n-  /* Indexed by register number, indicates whether or not register is\n-     an induction variable, and if so what type.  */\n-  varray_type reg_iv_type;\n+  enum iv_mode type;\n+  union \n+  {\n+    struct iv_class *class;\n+    struct induction *info;\n+  } iv;\n+};\n+\n+\n+#define REG_IV_TYPE(ivs, n) ivs->regs[n].type\n+#define REG_IV_INFO(ivs, n) ivs->regs[n].iv.info\n+#define REG_IV_CLASS(ivs, n) ivs->regs[n].iv.class\n \n+\n+struct loop_ivs\n+{\n   /* Indexed by register number, contains pointer to `struct\n-     induction' if register is an induction variable.  This holds\n-     general info for all induction variables.  */\n-  varray_type reg_iv_info;\n+     iv' if register is an induction variable.  */\n+  struct iv *regs;\n \n-  /* Indexed by register number, contains pointer to `struct iv_class'\n-     if register is a basic induction variable.  This holds info\n-     describing the class (a related group) of induction variables\n-     that the biv belongs to.  */\n-  struct iv_class **reg_biv_class;\n+  /* Size of regs array.  */\n+  unsigned int n_regs;\n \n   /* The head of a list which links together (via the next field)\n      every iv class for the current loop.  */\n-  struct iv_class *loop_iv_list;\n+  struct iv_class *list;\n };\n \n+\n+typedef struct loop_mem_info\n+{\n+  rtx mem;      /* The MEM itself.  */\n+  rtx reg;      /* Corresponding pseudo, if any.  */\n+  int optimize; /* Nonzero if we can optimize access to this MEM.  */\n+} loop_mem_info;\n+\n+\n struct loop_regs\n {\n   int num;\n@@ -342,14 +367,6 @@ struct loop_info\n   int pre_header_has_call;\n };\n \n-/* Definitions used by the basic induction variable discovery code.  */\n-enum iv_mode\n-{\n-  UNKNOWN_INDUCT,\n-  BASIC_INDUCT,\n-  NOT_BASIC_INDUCT,\n-  GENERAL_INDUCT\n-};\n \n /* Variables declared in loop.c, but also needed in unroll.c.  */\n \n@@ -359,11 +376,6 @@ extern unsigned int max_reg_before_loop;\n extern struct loop **uid_loop;\n extern FILE *loop_dump_stream;\n \n-#define REG_IV_TYPE(ivs, n) \\\n-  (*(enum iv_mode *) &VARRAY_INT(ivs->reg_iv_type, (n)))\n-#define REG_IV_INFO(ivs, n) \\\n-  (*(struct induction **) &VARRAY_GENERIC_PTR(ivs->reg_iv_info, (n)))\n-#define REG_IV_CLASS(ivs, n) ivs->reg_biv_class[n]\n \n /* Forward declarations for non-static functions declared in loop.c and\n    unroll.c.  */"}, {"sha": "4597343fc3d818c9d774ad4297c9559d6db620fa", "filename": "gcc/unroll.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14be28e5f43fa2710e15441ff8b4e54b64295303/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14be28e5f43fa2710e15441ff8b4e54b64295303/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=14be28e5f43fa2710e15441ff8b4e54b64295303", "patch": "@@ -1184,7 +1184,7 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n   /* Search the list of bivs and givs to find ones which need to be remapped\n      when split, and set their reg_map entry appropriately.  */\n \n-  for (bl = ivs->loop_iv_list; bl; bl = bl->next)\n+  for (bl = ivs->list; bl; bl = bl->next)\n     {\n       if (REGNO (bl->biv->src_reg) != bl->regno)\n \tmap->reg_map[bl->regno] = bl->biv->src_reg;\n@@ -2447,7 +2447,7 @@ find_splittable_regs (loop, unroll_type, end_insert_before, unroll_number)\n   rtx loop_start = loop->start;\n   rtx loop_end = loop->end;\n \n-  for (bl = ivs->loop_iv_list; bl; bl = bl->next)\n+  for (bl = ivs->list; bl; bl = bl->next)\n     {\n       /* Biv_total_increment must return a constant value,\n \t otherwise we can not calculate the split values.  */\n@@ -3545,7 +3545,7 @@ loop_iterations (loop)\n      will propagate a new pseudo into the old iteration register but\n      this will be marked by having the REG_USERVAR_P bit set.  */\n \n-  if ((unsigned) REGNO (iteration_var) >= ivs->reg_iv_type->num_elements\n+  if ((unsigned) REGNO (iteration_var) >= ivs->n_regs\n       && ! REG_USERVAR_P (iteration_var))\n     abort ();\n \n@@ -3563,7 +3563,7 @@ loop_iterations (loop)\n \n   /* If this is a new register, can't handle it since we don't have any\n      reg_iv_type entry for it.  */\n-  if ((unsigned) REGNO (iteration_var) >= ivs->reg_iv_type->num_elements)\n+  if ((unsigned) REGNO (iteration_var) >= ivs->n_regs)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,"}]}