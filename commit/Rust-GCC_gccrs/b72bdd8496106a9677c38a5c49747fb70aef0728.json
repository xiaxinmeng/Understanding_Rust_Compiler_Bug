{"sha": "b72bdd8496106a9677c38a5c49747fb70aef0728", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjcyYmRkODQ5NjEwNmE5Njc3YzM4YTVjNDk3NDdmYjcwYWVmMDcyOA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1999-02-19T11:59:01Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1999-02-19T11:59:01Z"}, "message": "loop.c (strength_reduce): Check for intervening jumps when converting biv increment to giv.\n\n\t* loop.c (strength_reduce): Check for intervening jumps when\n\tconverting biv increment to giv.\n\nFrom-SVN: r25310", "tree": {"sha": "b431f092cacd7d8874dfeb4c29dccb383f5ca096", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b431f092cacd7d8874dfeb4c29dccb383f5ca096"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b72bdd8496106a9677c38a5c49747fb70aef0728", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b72bdd8496106a9677c38a5c49747fb70aef0728", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b72bdd8496106a9677c38a5c49747fb70aef0728", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b72bdd8496106a9677c38a5c49747fb70aef0728/comments", "author": null, "committer": null, "parents": [{"sha": "4e03cf86c3b35eed694f880dcfc811d6d12df4e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e03cf86c3b35eed694f880dcfc811d6d12df4e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e03cf86c3b35eed694f880dcfc811d6d12df4e7"}], "stats": {"total": 41, "additions": 37, "deletions": 4}, "files": [{"sha": "f356a244a2bc43362cd3826c75c229ff8590c575", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b72bdd8496106a9677c38a5c49747fb70aef0728/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b72bdd8496106a9677c38a5c49747fb70aef0728/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b72bdd8496106a9677c38a5c49747fb70aef0728", "patch": "@@ -1,3 +1,8 @@\n+Fri Feb 19 19:55:06 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* loop.c (strength_reduce): Check for intervening jumps when\n+\tconverting biv increment to giv.\n+\n Thu Feb 18 16:36:58 1999  Per Bothner  <bothner@cygnus.com>\n \n \t* tree.def (TRY_FINALLY_EXPR, GOTO_SUBROUTINE_EXPR):  New tree nodes,"}, {"sha": "43db725fc173f874cfe2184261516c565cbffd09", "filename": "gcc/loop.c", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b72bdd8496106a9677c38a5c49747fb70aef0728/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b72bdd8496106a9677c38a5c49747fb70aef0728/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=b72bdd8496106a9677c38a5c49747fb70aef0728", "patch": "@@ -4136,27 +4136,55 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n       for (bl = loop_iv_list; bl; bl = bl->next)\n \t{\n \t  struct induction **vp, *v, *next;\n-    \n+\t  int biv_dead_after_loop = 0;\n+\n \t  /* The biv increments lists are in reverse order.  Fix this first.  */\n \t  for (v = bl->biv, bl->biv = 0; v; v = next)\n \t    {\n \t      next = v->next_iv;\n \t      v->next_iv = bl->biv;\n \t      bl->biv = v;\n \t    }\n-    \n+\n+\t  /* We must guard against the case that an early exit between v->insn\n+\t     and next->insn leaves the biv live after the loop, since that\n+\t     would mean that we'd be missing an increment for the final\n+\t     value.  The following test to set biv_dead_after_loop is like\n+\t     the first part of the test to set bl->eliminable.\n+\t     We don't check here if we can calculate the final value, since\n+\t     this can't succeed if we already know that there is a jump\n+\t     between v->insn and next->insn, yet next->always_executed is\n+\t     set and next->maybe_multiple is cleared.  Such a combination\n+\t     implies that the jump destination is outseide the loop.\n+\t     If we want to make this check more sophisticated, we should\n+\t     check each branch between v->insn and next->insn individually\n+\t     to see if it the biv is dead at its destination.  */\n+\n+\t  if (uid_luid[REGNO_LAST_UID (bl->regno)] < INSN_LUID (loop_end)\n+\t      && bl->init_insn\n+\t      && INSN_UID (bl->init_insn) < max_uid_for_loop\n+\t      && (uid_luid[REGNO_FIRST_UID (bl->regno)]\n+\t\t  >= INSN_LUID (bl->init_insn))\n+#ifdef HAVE_decrement_and_branch_until_zero\n+\t      && ! bl->nonneg\n+#endif\n+\t      && ! reg_mentioned_p (bl->biv->dest_reg, SET_SRC (bl->init_set)))\n+\t    biv_dead_after_loop = 1;\n+\n \t  for (vp = &bl->biv, next = *vp; v = next, next = v->next_iv;)\n \t    {\n \t      HOST_WIDE_INT offset;\n \t      rtx set, add_val, old_reg, dest_reg, last_use_insn;\n \t      int old_regno, new_regno;\n-    \n+\n \t      if (! v->always_executed\n \t\t  || v->maybe_multiple\n \t\t  || GET_CODE (v->add_val) != CONST_INT\n \t\t  || ! next->always_executed\n \t\t  || next->maybe_multiple\n-\t\t  || ! CONSTANT_P (next->add_val))\n+\t\t  || ! CONSTANT_P (next->add_val)\n+\t\t  || ! (biv_dead_after_loop\n+\t\t\t|| no_jumps_between_p (v->insn, next->insn)))\n \t\t{\n \t\t  vp = &v->next_iv;\n \t\t  continue;"}]}