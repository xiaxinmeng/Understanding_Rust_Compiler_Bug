{"sha": "d78f7214feff90aa70d0788824062d2e6f6ae045", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc4ZjcyMTRmZWZmOTBhYTcwZDA3ODg4MjQwNjJkMmU2ZjZhZTA0NQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-09-22T00:19:44Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-09-22T00:19:44Z"}, "message": "Forgot to commit.\n\nFrom-SVN: r22541", "tree": {"sha": "0055260c2349f80f47d0ad40ea43430c72bc5811", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0055260c2349f80f47d0ad40ea43430c72bc5811"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d78f7214feff90aa70d0788824062d2e6f6ae045", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d78f7214feff90aa70d0788824062d2e6f6ae045", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d78f7214feff90aa70d0788824062d2e6f6ae045", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d78f7214feff90aa70d0788824062d2e6f6ae045/comments", "author": null, "committer": null, "parents": [{"sha": "83d6aca114ba6aef405e6d7d65b6208db0ef1437", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83d6aca114ba6aef405e6d7d65b6208db0ef1437", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83d6aca114ba6aef405e6d7d65b6208db0ef1437"}], "stats": {"total": 1501, "additions": 1501, "deletions": 0}, "files": [{"sha": "fb79cf80a9e4d39d6c79936d55c6b0e85e4b2f47", "filename": "gcc/config/c4x/libgcc.S", "status": "added", "additions": 1501, "deletions": 0, "changes": 1501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d78f7214feff90aa70d0788824062d2e6f6ae045/gcc%2Fconfig%2Fc4x%2Flibgcc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d78f7214feff90aa70d0788824062d2e6f6ae045/gcc%2Fconfig%2Fc4x%2Flibgcc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Flibgcc.S?ref=d78f7214feff90aa70d0788824062d2e6f6ae045", "patch": "@@ -0,0 +1,1501 @@\n+/* libgcc1 routines for the Texas Instruments TMS320C[34]x\n+   Copyright (C) 1997,98 Free Software Foundation, Inc.\n+\n+ Contributed by Michael Hayes (m.hayes@elec.canterbury.cri.nz)\n+            and Herman Ten Brugge (Haj.Ten.Brugge@net.HCC.nl).\n+\n+\t\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file with other programs, and to distribute\n+those programs without any restriction coming from the use of this\n+file.  (The General Public License restrictions do apply in other\n+respects; for example, they cover modification of the file, and\n+distribution when not linked into another program.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+\t\n+; These routines are called using the standard TI register argument\n+; passing model.\n+; The following registers do not have to be saved:\n+; r0, r1, r2, r3, ar0, ar1, ar2, ir0, ir1, bk, rs, rc, re, (r9, r10, r11)\n+;\n+; Perform floating point divqf3\n+;\n+; This routine performs a reciprocal of the divisor using the method\n+; described in the C30/C40 user manuals.  It then multiplies that\n+; result by the dividend.\n+; \n+; Let r be the reciprocal of the divisor v and let the ith estimate\n+; of r be denoted by r[i].  An iterative approach can be used to\n+; improve the estimate of r, given an initial estimate r[0], where\n+;\n+; r[i + 1] = r[i] * (2.0 - v * r[i])\n+;\n+; The normalised error e[i] at the ith iteration is\n+;\n+; e[i] = (r - r[i]) / r = (1 / v - r[i]) * v = (1 - v * r[i])\n+;\n+; Note that \n+;\n+; e[i + 1]  = (1 - v * r[i + 1]) = 1 - 2 * v * r[i] + v^2 + (r[i])^2\n+;           = (1 - v * r[i])^2 = (e[i])^2\n+\n+; r2 dividend, r3 divisor, r0 quotient\n+; clobbers r1, ar1\n+#ifdef L_divqf3\n+\t.text\n+        .global ___divqf3\n+___divqf3:\n+\n+#ifdef _TMS320C4x\n+\t.if .REGPARM == 0\n+\tlda\tsp,ar0\n+\tldf\t*-ar0(2), r3\n+\t.endif\n+\n+\tpop\tar1\t\t; Pop return address\n+\n+; r0 = estimate of r, r1 = tmp, r2 = dividend, r3 = divisor\n+        rcpf    r3, r0\t\t; Compute initial estimate r[0]\n+\n+\tmpyf3\tr0, r3, r1\t; r1 = r[0] * v\n+\tsubrf\t2.0, r1\t\t; r1 = 2.0 - r[0] * v\n+\tmpyf\tr1, r0\t\t; r0 = r[0] * (2.0 - r[0] * v) = r[1]\n+; End of 1st iteration (16 bits accuracy)\n+\n+\tmpyf3\tr0, r3, r1\t; r1 = r[1] * v\n+\tsubrf\t2.0, r1\t\t; r1 = 2.0 - r[1] * v\n+\n+\tbud\tar1\t\t; Delayed branch\n+\tmpyf\tr1, r0\t\t; r0 = r[1] * (2.0 - r[1] * v) = r[2]\n+; End of 2nd iteration (32 bits accuracy)\n+\t.if .REGPARM == 0\n+\tmpyf\t*-ar0(1), r0\t; Multiply by the dividend\n+\t.else\n+\tmpyf\tr2, r0\t\t; Multiply by the dividend\n+\t.endif\n+\trnd\tr0\n+\t; Branch occurs here\n+#else\n+\t.if .REGPARM == 0\n+\tldiu\tsp,ar0\n+\tldf\t*-ar0(2), r3\n+\t.endif\n+\n+\tpop\tar1\t\t; Pop return address\n+\n+; Initial estimate       r[0] = 1.0 * 2^(-e - 1)\n+; where                  v = m * 2^e\n+\n+; r0 = estimate of r, r1 = tmp, r2 = dividend, r3 = divisor\n+\n+; Calculate initial estimate r[0]\n+\tpushf\tr3\n+\tpop\tr0\n+\tnot\tr0\t\t; r0 = -e\n+\t\t\t\t; complement exponent = -e -1\n+\t\t\t\t; complement sign (side effect)\n+\t\t\t\t; complement mantissa (almost 3 bit accurate)\n+\tpush\tr0\n+\tpopf\tr0\t\t; r0 = 1.0 * e^(-e - 1) + inverted mantissa\n+\tldf\t-1.0, r1\t; undo complement sign bit\n+\txor\tr1, r0\n+\n+\tmpyf3\tr0, r3, r1\t; r1 = r[0] * v\n+\tsubrf\t2.0, r1\t\t; r1 = 2.0 - r[0] * v\n+\tmpyf\tr1, r0\t\t; r0 = r[0] * (2.0 - r[0] * v) = r[1]\n+; End of 1st iteration\n+\n+\tmpyf3\tr0, r3, r1\t; r1 = r[1] * v\n+\tsubrf\t2.0, r1\t\t; r1 = 2.0 - r[1] * v\n+\tmpyf\tr1, r0\t\t; r0 = r[1] * (2.0 - r[1] * v) = r[2]\n+; End of 2nd iteration\n+\n+\tmpyf3\tr0, r3, r1\t; r1 = r[2] * v\n+\tsubrf\t2.0, r1\t\t; r1 = 2.0 - r[2] * v\n+\tmpyf\tr1, r0\t\t; r0 = r[2] * (2.0 - r[2] * v) = r[3]\n+; End of 3rd iteration\n+\n+\tor\t080h, r0\t; add 1 lsb to result. needed when complemeting\n+\t\t\t\t; 1.0 / 2.0\n+\trnd\tr0\n+\n+; Use modified last iteration\n+; r[4] = (r[3] * (1.0 - (v * r[3]))) + r[3]\n+\tmpyf3\tr0, r3, r1\t; r1 = r[3] * v\n+\tsubrf\t1.0, r1\t\t; r1 = 1.0 - r[3] * v\n+\tmpyf\tr0, r1\t\t; r1 = r[3] * (1.0 - r[3] * v)\n+\n+\tbud\tar1\t\t; Delayed branch\n+\taddf\tr1, r0\t\t; r0 = r[3] * (1.0 - r[3] * v) + r[3] = r[4]\n+\t.if .REGPARM == 0\n+\tmpyf\t*-ar0(1), r0\t; Multiply by the dividend\n+\t.else\n+\tmpyf\tr2, r0\t\t; Multiply by the dividend\n+\t.endif\n+\trnd\tr0\n+\t; Branch occurs here\n+#endif\n+\n+#endif\n+;\n+; Integer signed division\n+;\n+; ar2 dividend, r2 divisor, r0 quotient\n+; clobbers r1, r3, ar0, ar1, ir0, ir1, rc, rs, re\n+#ifdef L_divqi3\n+\t.text\n+\t.global ___divqi3\n+\t.ref\tudivqi3n\n+___divqi3:\n+\t.if .REGPARM == 0\n+#ifdef _TMS320C4x\n+\tlda\tsp,ar0\n+#else\n+\tldiu\tsp,ar0\n+#endif\n+\tldi\t*-ar0(1), ar2\n+\tldi\t*-ar0(2), r2\n+\t.endif\n+\n+\txor3\tar2, r2, r3\t; Get the sign\n+\tabsi\tar2, r0\n+\tbvd\tdivq32\n+\tldi\tr0, ar2\n+\tabsi\tr2, r2\n+\tcmpi\tar2, r2\t\t; Divisor > dividend?\n+\n+\tpop\tir1\n+\tbhid\tzero\t\t; If so, return 0\n+\n+;\n+; Normalize oeprands.  Use difference exponents as shift count\n+; for divisor, and as repeat count for \"subc\"\n+;\n+\tfloat\tar2, r1\t\t; Normalize dividend\n+\tpushf\tr1\t\t; Get as integer\n+\tpop\tar0\n+\tlsh\t-24, ar0\t; Get exponent\n+\t\n+\tfloat\tr2, r1\t\t; Normalize divisor\n+\tpushf\tr1\t\t; Get as integer\n+\tpop\tir0\n+\tlsh\t-24, ir0\t; Get exponent\n+\n+\tsubi\tir0, ar0\t; Get difference of exponents\n+\tlsh\tar0, r2\t\t; Align divisor with dividend\n+\n+;\n+; Do count + 1 subtracts and shifts\n+;\n+\trpts\tar0\n+\t\tsubc\tr2, ar2\n+\n+;\n+; Mask off the lower count+1 bits of ar2\n+;\n+\tsubri\t31, ar0\t\t; Shift count is (32 - (ar0 + 1))\n+\tlsh\tar0, ar2\t; Shift left\n+\tnegi\tar0, ar0\n+\tlsh3\tar0, ar2, r0\t; Shift right and put result in r0\n+\n+;\n+; Check sign and negate result if necessary\n+;\n+\tbud\tir1\t\t; Delayed return\n+\tnegi\tr0, r1\t\t; Negate result\n+\tash\t-31, r3\t\t; Check sign\n+\tldinz\tr1, r0\t\t; If set, use negative result\n+\t; Branch occurs here\n+\n+zero:\tbud\tir1\t\t; Delayed branch\n+\tldi\t0, r0\n+\tnop\n+\tnop\n+\t; Branch occurs here\n+;\n+; special case where ar2 = abs(ar2) = 0x80000000.  We handle this by\n+; calling unsigned divide and negating the result if necessary.\n+;\n+divq32:\n+\tpush\tr3\t\t; Save sign\n+\tcall\tudivqi3n\n+\tpop\tr3\n+\tpop\tir1\n+\tbd\tir1\n+\tnegi\tr0, r1\t\t; Negate result\n+\tash\t-31, r3\t\t; Check sign\n+\tldinz\tr1, r0\t\t; If set, use negative result\n+\t; Branch occurs here\n+#endif\n+;\n+;\n+; ar2 dividend, r2 divisor, r0 quotient, \n+; clobbers r1, r3, ar0, ar1, ir0, ir1, rc, rs, re\n+#ifdef L_udivqi3\n+\t.text\n+\t.global ___udivqi3\n+\t.global udivqi3n\n+___udivqi3:\n+\t.if .REGPARM == 0\n+#ifdef _TMS320C4x\n+\tlda\tsp,ar0\n+#else\n+\tldiu\tsp,ar0\n+#endif\n+\tldi\t*-ar0(1), ar2\n+\tldi\t*-ar0(2), r2\n+\t.endif\n+\n+udivqi3n:\n+\tpop\tir1\n+\n+\tcmpi\tar2, r2\t\t; If divisor > dividend\n+\tbhi\tqzero\t\t; return zero\n+\tldi\tr2, ar1\t\t; Store divisor in ar1\n+\n+\ttstb\tar2, ar2\t; Check top bit, jump if set to special handler\n+\tbld\tdiv_32\t\t; Delayed branch\n+\n+;\n+; Get divisor exponent\n+;\n+\tfloat\tar1, r1\t\t; Normalize the divisor\n+\tpushf\tr1\t\t; Get into int register\n+\tpop\trc\n+\t; branch occurs here\n+\n+\tbzd\tqzero\t\t; if (float) divisor zero, return zero\n+\n+\tfloat\tar2, r1\t\t; Normalize the dividend\n+\tpushf\tr1\t\t; Get into int register\n+\tpop\tar0\n+\tlsh\t-24, ar0\t; Get both the exponents\n+\tlsh\t-24, rc\n+\n+\tsubi\trc, ar0\t\t; Get the difference between the exponents\n+\tlsh\tar0, ar1\t; Normalize the divisor with the dividend\n+\n+;\n+; Do count_1 subtracts and shifts\n+;\n+\trpts\tar0\n+\t\tsubc\tar1, ar2\n+\n+;\n+; mask off the lower count+1 bits\n+;\n+\tsubri\t31, ar0\t\t; Shift count (31 - (ar0+1))\n+\tbud\tir1\t\t; Delayed return\n+\tlsh3\tar0, ar2, r0\n+\tnegi\tar0, ar0\n+\tlsh\tar0, r0\n+\t; Branch occurs here\n+\n+;\n+; Handle a full 32-bit dividend\n+;\n+div_32:\ttstb\tar1, ar1\n+\tbld\tqone\t\t; if divisor high bit is one, the result is one\n+\tlsh\t-24, rc\n+\tsubri\t31, rc\n+\tlsh\trc, ar1\t\t; Line up the divisor\n+\n+;\n+; Now divisor and dividend are aligned.  Do first SUBC by hand, save\n+; of the forst quotient digit.  Then, shift divisor right rather\n+; than shifting dividend left.  This leaves a zero in the top bit of\n+; the divident\n+;\n+\tldi\t1, ar0\t\t; Initizialize MSB of quotient\n+\tlsh\trc, ar0\t\t; create a mask for MSBs\n+\tsubi\t1, ar0\t\t; mask is (2 << count) - 1\n+\n+\tsubi3\tar1, ar2, r1\n+\tldihs\tr1, ar2\n+\tldihs\t1, r1\n+\tldilo\t0, r1\n+\tlsh\trc, r1\n+\n+\tlsh\t-1, ar1\n+\tsubi\t1, rc\n+;\n+; do the rest of the shifts and subtracts\n+;\n+\trpts\trc\n+\t\tsubc\tar1, ar2\n+\n+\tbud\tir1\n+\tand\tar0, ar2\n+\tor3\tr1, ar2, r0\n+\tnop\n+\n+qone:\n+\tbud\tir1\n+\tldi\t1, r0\n+\tnop\n+\tnop\n+\n+qzero:\n+\tbud\tir1\n+\tldi\t0, r0\n+\tnop\n+\tnop\n+#endif\n+\n+#ifdef L_umodqi3\n+\t.text\n+\t.global\t___umodqi3\n+\t.global\tumodqi3n\n+___umodqi3:\n+\t.if .REGPARM == 0\n+#ifdef _TMS320C4x\n+\tlda\tsp,ar0\n+#else\n+\tldiu\tsp,ar0\n+#endif\n+\tldi\t*-ar0(1), ar2\n+\tldi\t*-ar0(2), r2\n+\t.endif\n+\n+umodqi3n:\n+\tpop     ir1\t\t; return address\n+        cmpi    ar2, r2\t\t; divisor > dividend ? \n+\tbhi     uzero\t\t;    if so, return dividend\n+\tldi     r2, ar1\t\t; load divisor\n+;\n+; If top bit of dividend is set, handle specially.\n+;\n+        tstb    ar2, ar2\t; check top bit\n+\tbld     umod_32\t\t; get divisor exponent, then jump.\n+;\n+; Get divisor exponent by converting to float.\n+;\n+\tfloat   ar1, r1\t\t; normalize divisor\n+\tpushf   r1\t\t; push as float\n+\tpop     rc\t\t; pop as int to get exponent\n+        bzd     uzero\t\t; if (float)divisor was zero, return\n+;\n+; 31 or less bits in dividend.  Get dividend exponent.\n+;\n+        float   ar2, r1\t\t; normalize dividend\n+\tpushf   r1\t\t; push as float\n+\tpop     ar0\t\t; pop as int to get exponent\n+;\n+; Use difference in exponents as shift count to line up MSBs.\n+;\n+\tlsh     -24, rc\t\t; divisor exponent\n+\tlsh     -24, ar0\t; dividend exponent\n+\tsubi    rc, ar0\t\t; difference\n+        lsh     ar0, ar1\t; shift divisor up\n+; \n+; Do COUNT+1 subtract & shifts.\n+;\n+\trpts    ar0\n+\t\tsubc    ar1, ar2  \n+;\n+;  Remainder is in upper 31-COUNT bits.\n+;\n+\tbud     ir1\t\t; delayed branch to return\n+\taddi    1, ar0\t\t; shift count is COUNT+1\n+\tnegi    ar0, ar0\t; negate for right shift\n+\tlsh3    ar0, ar2, r0\t; shift to get result\n+\t; Return occurs here\n+\n+;\n+; The following code handles cases of a full 32-bit dividend.  Before\n+; SUBC can be used, the top bit must be cleared (otherwise SUBC can\n+; possibly shift a significant 1 out the top of the dividend).  This\n+; is accomplished by first doing a normal subtraction, then proceeding\n+; with SUBCs. \n+;\n+umod_32:\n+;\n+; If the top bit of the divisor is set too, the remainder is simply\n+; the difference between the dividend and divisor.  Otherwise, shift \n+; the divisor up to line up the MSBs.\n+;\n+\ttstb    ar1, ar1\t; check divisor\n+\tbld     uone\t\t; if negative, remainder is diff\n+\n+\tlsh     -24, rc\t\t; divisor exponent\n+\tsubri   31, rc\t\t; shift count = 31 - exp\n+\tnegi    rc, ar0\t\t; used later as shift count\n+\tlsh     rc, ar1\t\t; shift up to line up MSBs\n+;\n+; Now MSBs are aligned.  Do first SUBC by hand using a plain subtraction.\n+; Then, shift divisor right rather than shifting dividend left.  This leaves\n+; a 0 in the top bit of the dividend.\n+;\n+\tsubi3   ar1, ar2, r1\t; subtract \n+\tldihs   r1, ar2\t\t; if positive, replace dividend\n+\tsubi    1, rc\t\t; first iteration is done\n+\tlsh     -1, ar1\t\t; shift divisor down\n+; \n+; Do EXP subtract & shifts.\n+;\n+\trpts    rc  \n+\t\tsubc    ar1, ar2   \n+;\n+;  Quotient is in EXP+1 LSBs; shift remainder (in MSBs) down.\n+;\n+\tbud\tir1\n+\tlsh3    ar0, ar2, r0\t; COUNT contains -(EXP+1)\n+\tnop\n+\tnop\n+;\n+;  Return (dividend - divisor).\n+;\n+uone:\tbud\tir1\n+\tsubi3   r2, ar2, r0  \n+\tnop\n+\tnop\n+;\n+;  Return dividend.\n+;\n+uzero:\tbud\tir1\n+\tldi     ar2, r0\t\t; set status from result\n+\tnop\n+\tnop\n+#endif\n+\n+#ifdef L_modqi3\n+\t.text\n+\t.global\t___modqi3\n+\t.ref umodqi3n\n+___modqi3:\n+\t.if .REGPARM == 0\n+#ifdef _TMS320C4x\n+\tlda\tsp,ar0\n+#else\n+\tldiu\tsp,ar0\n+#endif\n+\tldi\t*-ar0(1), ar2\n+\tldi\t*-ar0(2), r2\n+\t.endif\n+\n+; \n+; Determine sign of result.  Get absolute value of operands.\n+; \n+\tldi     ar2, ar0\t; sign of result same as dividend\n+\tabsi    ar2, r0\t\t; make dividend positive\n+\tbvd     mod_32\t\t; if still negative, escape\n+\tabsi    r2, r1\t\t; make divisor positive\n+\tldi     r1, ar1\t\t; save in ar1       \n+        cmpi    r0, ar1\t\t; divisor > dividend ? \n+\n+        pop     ir1            ; return address\n+\tbhid    return \t\t;   if so, return dividend\n+; \n+; Normalize operands.  Use difference in exponents as shift count\n+; for divisor, and as repeat count for SUBC.\n+;\n+        float   r1, r1\t\t; normalize divisor\n+        pushf   r1\t\t; push as float \n+\tpop     rc\t\t; pop as int\n+        bzd     return\t\t; if (float)divisor was zero, return\n+\n+        float   r0, r1\t\t; normalize dividend\n+        pushf   r1\t\t; push as float\n+        pop     r1\t\t; pop as int \n+\n+\tlsh     -24, rc\t\t; get divisor exponent\n+\tlsh     -24, r1\t\t; get dividend exponent\n+\tsubi    rc, r1\t\t; get difference in exponents\n+\tlsh     r1, ar1\t\t; align divisor with dividend\n+; \n+; Do COUNT+1 subtract & shifts.\n+;\n+\trpts    r1\n+\t\tsubc    ar1, r0\n+;\n+;  Remainder is in upper bits of R0\n+;\n+\taddi    1, r1\t\t; shift count is -(r1+1)\n+\tnegi    r1, r1 \n+\tlsh     r1, r0\t\t; shift right\n+;\n+;  Check sign and negate result if necessary.\n+;\n+return:\n+\tbud     ir1\t\t; delayed branch to return\n+        negi    r0, r1\t\t; negate result\n+\tcmpi    0, ar0\t\t; check sign\n+\tldin    r1, r0\t\t; if set, use negative result\n+\t; Return occurs here\n+;\n+; The following code handles cases of a full 32-bit dividend.  This occurs\n+; when R0 = abs(R0) = 080000000h.  Handle this by calling the unsigned mod\n+; function, then negating the result if necessary.\n+;\n+mod_32:\n+        push    ar0\t\t; remember sign\n+\tcall    umodqi3n\t; do divide\n+\n+\tbrd     return\t\t; return\n+\tpop     ar0\t\t; restore sign\n+        pop     ir1             ; return address\n+\tnop\n+#endif\n+\n+#ifdef L_unsfltconst\n+\t.section .const\n+        .global ___unsfltconst\n+___unsfltconst:   .float 4294967296.0\n+#endif\n+\n+#ifdef L_unsfltcompare\n+\t.section .const\n+        .global ___unsfltcompare\n+___unsfltcompare: .float 2147483648.0\n+#endif\n+\n+; Integer 32-bit signed multiplication\n+;\n+; The TMS320C3x MPYI instruction takes two 24-bit signed integers\n+; and produces a 48-bit signed result which is truncated to 32-bits.\n+;\n+; A 32-bit by 32-bit multiplication thus requires a number of steps.\n+;\n+; Consider the product of two 32-bit signed integers,\n+;\n+;\tz = x * y\n+;\n+; where x = (b << 16) + a,  y = (d << 16) + c\n+;\n+; This can be expressed as\n+;\n+;\tz = ((b << 16) + a) * ((d << 16) + c)\n+;\n+;          = ((b * d) << 32) + ((b * c + a * d) << 16) + a * c\n+;\n+; Let z = (f << 16) + e where f < (1 << 16).\n+;\n+; Since we are only interested in a 32-bit result, we can ignore the \n+; (b * d) << 32 term, and thus\n+;\n+;\tf = b * c + a * d,  e = a * c\n+;\n+; We can simplify things if we have some a priori knowledge of the\n+; operands, for example, if -32768 <= y <= 32767, then y = c and d = 0 and thus\n+;\n+;\tf = b * c,  e = a * c\n+;\n+; ar2 multiplier, r2 multiplicand, r0 product\n+; clobbers r1, r2, r3\n+#ifdef L_mulqi3\t\n+\t.text\n+\t.global\t___mulqi3\n+___mulqi3:\n+\t.if .REGPARM == 0\n+#ifdef _TMS320C4x\n+\tlda\tsp,ar0\n+#else\n+\tldiu\tsp,ar0\n+#endif\n+\tldi\t*-ar0(1), ar2\n+\tldi\t*-ar0(2), r2\n+\t.endif\n+\n+        pop     ir1\t\t; return address\n+\tldi\tar2, r0\t\t;\n+\tand\t0ffffh, r0\t; a\n+\tlsh\t-16, ar2\t; b\n+\tldi\tr2, r3\t\t; \n+\tand\t0ffffh, r3\t; c\n+\tmpyi\tr3, ar2\t\t; c * b\t\t\n+\tlsh\t-16, r2\t\t; d\n+\tmpyi\tr0, r2\t\t; a * d\n+\taddi\tar2, r2\t\t; c * b + a * d\n+\tbd\tir1\t\t; delayed branch to return\n+\tlsh\t16, r2\t\t; (c * b + a * d) << 16\n+\tmpyi\tr3, r0\t\t; a * c\n+\taddi\tr2, r0\t\t; a * c + (c * b + a * d) << 16\n+; branch occurs here\n+\n+#endif\t\n+\n+;\n+; Integer 64 by 64 multiply\n+; long1 and long2 on stack\n+; result in r0,r1\n+;\n+#ifdef L_mulhi3\n+\t.text\n+\t.global\t___mulhi3\n+#ifdef _TMS320C4x\n+___mulhi3:\n+\tpop\tar0\n+\tldi\tsp,ar2\n+\tldi\t*-ar2(1),r2\n+\tldi\t*-ar2(3),r3\n+\tmpyi3\tr2,r3,r0\n+\tmpyuhi3\tr2,r3,r1\n+\tmpyi\t*-ar2(2),r2\n+\tbd\tar0\n+\tmpyi\t*-ar2(0),r3\n+\taddi\tr2,r1\n+\taddi\tr3,r1\n+#else\n+___mulhi3:\n+\tldi\tsp,ar2\n+\tldi\t-16,rs\n+\tldi\t*-ar2(2),ar0\n+\tldi\t*-ar2(4),ar1\n+\tldi\tar0,r2\n+\tand\t0ffffh,r2\n+\tldi\tar1,r3\n+\tand\t0ffffh,r3\n+\tlsh\trs,ar0\n+\tlsh\trs,ar1\n+\n+\tmpyi\tr2,r3,r0\n+\tmpyi\tar0,ar1,r1\n+\tmpyi\tr2,ar1,rc\n+\tlsh\trs,rc,re\n+\taddi\tre,r1\n+\tlsh\t16,rc\n+\taddi\trc,r0\n+\taddc\t0,r1\n+\tmpyi\tr3,ar0,rc\n+\tlsh\trs,rc,re\n+\taddi\tre,r1\n+\tlsh\t16,rc\n+\taddi\trc,r0\n+\taddc\t0,r1\n+\n+\tldi\t*-ar2(1),ar0\n+\tldi\tar0,r2\n+\tand\t0ffffh,r2\n+\tlsh\trs,ar0\n+\tmpyi\tr2,r3,rc\n+\taddi\trc,r1\n+\tmpyi\tr2,ar1,rc\n+\tmpyi\tr3,ar0,re\n+\taddi\tre,rc\n+\tlsh\t16,rc\n+\taddi\trc,r1\n+\n+\tldi\t*-ar2(2),ar0\n+\tldi\t*-ar2(3),ar1\n+\tldi\tar0,r2\n+\tand\t0ffffh,r2\n+\tldi\tar1,r3\n+\tand\t0ffffh,r3\n+\tlsh\trs,ar0\n+\tlsh\trs,ar1\n+\tmpyi\tr2,r3,rc\n+\taddi\trc,r1\n+\tmpyi\tr2,ar1,rc\n+\tmpyi\tr3,ar0,re\n+\tpop\tar0\n+\tbd\tar0\n+\taddi\tre,rc\n+\tlsh\t16,rc\n+\taddi\trc,r1\n+#endif\n+#endif\n+\n+;\n+; Integer 32 by 32 multiply highpart unsigned\n+; src1 in ar2\n+; src2 in r2\n+; result in r0\n+;\n+#ifdef L_umulhi3_high\n+\t.text\n+\t.global\t___umulhi3_high\n+___umulhi3_high:\n+\t.if .REGPARM == 0\n+#ifdef _TMS320C4x\n+\tlda\tsp,ar0\n+#else\n+\tldiu\tsp,ar0\n+#endif\n+\tldi\t*-ar0(1), ar2\n+\tldi\t*-ar0(2), r2\n+\t.endif\n+\n+\tldi\t-16,rs\n+\tldi\tr2,r3\n+\tand\t0ffffh,r2\n+\tldi\tar2,ar1\n+\tand\t0ffffh,ar2\n+\tlsh\trs,r3\n+\tlsh\trs,ar1\n+\n+\tmpyi\tar2,r2,r1\n+\tmpyi\tar1,r3,r0\n+\tmpyi\tar2,r3,rc\n+\tlsh\trs,rc,re\n+\taddi\tre,r0\n+\tlsh\t16,rc\n+\taddi\trc,r1\n+\taddc\t0,r0\n+\tmpyi\tr2,ar1,rc\n+\tlsh\trs,rc,re\n+\taddi\tre,r0\n+\tpop\tar0\n+\tbd\tar0\n+\tlsh\t16,rc\n+\taddi\trc,r1\n+\taddc\t0,r0\n+#endif\n+\n+;\n+; Integer 32 by 32 multiply highpart signed\n+; src1 in ar2\n+; src2 in r2\n+; result in r0\n+;\n+#ifdef L_smulhi3_high\n+\t.text\n+\t.global\t___smulhi3_high\n+___smulhi3_high:\n+\t.if .REGPARM == 0\n+#ifdef _TMS320C4x\n+\tlda\tsp,ar0\n+#else\n+\tldiu\tsp,ar0\n+#endif\n+\tldi\t*-ar0(1), ar2\n+\tldi\t*-ar0(2), r2\n+\t.endif\n+\n+\tldi\t-16,rs\n+\tldi\t0,rc\n+\tsubi3\tar2,rc,r0\n+\tldi\tr2,r3\n+\tldilt\tr0,rc\n+\tsubi3\tr2,rc,r0\n+\tldi\tar2,ar1\n+\ttstb\tar1,ar1\n+\tldilt\tr0,rc\n+\tand\t0ffffh,r2\n+\tand\t0ffffh,ar2\n+\tlsh\trs,r3\n+\tlsh\trs,ar1\n+\n+\tmpyi\tar2,r2,r1\n+\tmpyi\tar1,r3,r0\n+\taddi\trc,r0\n+\tmpyi\tar2,r3,rc\n+\tlsh\trs,rc,re\n+\taddi\tre,r0\n+\tlsh\t16,rc\n+\taddi\trc,r1\n+\taddc\t0,r0\n+\tmpyi\tr2,ar1,rc\n+\tlsh\trs,rc,re\n+\taddi\tre,r0\n+\tpop\tar0\n+\tbd\tar0\n+\tlsh\t16,rc\n+\taddi\trc,r1\n+\taddc\t0,r0\n+#endif\n+\n+;\n+; Integer 64 by 64 unsigned divide\n+; long1 and long2 on stack\n+; divide in r0,r1\n+; modulo in r2,r3\n+; routine takes a maximum of 64*9+21=597 cycles = 24 us @ 50Mhz\n+;\n+#ifdef L_udivhi3\n+\t.text\n+\t.global\t___udivhi3\n+\t.global\t___udivide\n+\t.global\t___umodulo\n+\t.ref udivqi3n\n+\t.ref umodqi3n\n+___udivhi3:\n+\tldi\tsp,ar2\n+\tldi     *-ar2(4),ar0\n+\tldi     *-ar2(3),ar1\n+\tldi     *-ar2(2),r0\n+\tldi     *-ar2(1),r1\n+\n+___udivide:\n+\tor\tr1,ar1,r2\n+\tbne\tudiv0\n+\tldi\tar0,r2\n+\tldi\tr0,ar2\n+\tcall\tudivqi3n\n+\tldiu\t0,r1\n+\trets\n+\n+___umodulo:\n+\tor\tr1,ar1,r2\n+\tbne\tudiv0\n+\tldi\tar0,r2\n+\tldi\tr0,ar2\n+\tcall\tumodqi3n\n+\tldi\tr0,r2\n+\tldiu\t0,r3\n+\trets\n+\n+udiv0:\n+\ttstb\tar1,ar1\n+\tbne\tudiv1\n+\ttstb\tar0,ar0\n+\tbn\tudiv1\n+\n+\tldiu\t63,rc\n+#ifdef _TMS320C4x\n+\trptbd\tudivend0\n+\tldiu\t0,r2\n+\taddi\tr0,r0\n+\trolc\tr1\n+#else\n+\tldiu\t0,r2\n+\taddi\tr0,r0\n+\trolc\tr1\n+\trptb\tudivend0\n+#endif\n+\n+\trolc\tr2\n+\tsubi3\tar0,r2,r3\n+\txor\t1,st\n+\tldic\tr3,r2\n+\trolc\tr0\n+udivend0:\n+\trolc\tr1\n+\n+\tldiu\t0,r3\n+\trets\n+udiv1:\n+\tpush\tr4\n+\tpush\tr5\n+\tldiu\t63,rc\n+\tldiu\t0,r2\n+#ifdef _TMS320C4x\n+\trptbd\tudivend1\n+\tldiu\t0,r3\n+\taddi\tr0,r0\n+\trolc\tr1\n+#else\n+\tldiu\t0,r3\n+\taddi\tr0,r0\n+\trolc\tr1\n+\trptb\tudivend1\n+#endif\n+\n+\trolc\tr2\n+\trolc\tr3\n+\tsubi3\tar0,r2,r4\n+\tsubb3\tar1,r3,r5\n+\txor\t1,st\n+\tldic\tr4,r2\n+\tldic\tr5,r3\n+\trolc\tr0\n+udivend1:\n+\trolc\tr1\n+\n+\tpop\tr5\n+\tpop\tr4\n+\trets\n+#endif\n+\n+;\n+; Integer 64 by 64 unsigned modulo\n+; long1 and long2 on stack\n+; result in r0,r1\n+;\n+#ifdef L_umodhi3\n+\t.text\n+\t.global\t___umodhi3\n+\t.ref ___modulo\n+___umodhi3:\n+\tldi\tsp,ar2\n+\tldi     *-ar2(4),ar0\n+\tldi     *-ar2(3),ar1\n+\tldi     *-ar2(2),r0\n+\tldi     *-ar2(1),r1\n+\tcall\t___umodulo\n+\tpop\tar0\n+\tbd\tar0\n+\tldi\tr2,r0\n+\tldi\tr3,r1\n+\tnop\n+#endif\n+\n+;\n+; Integer 64 by 64 signed divide\n+; long1 and long2 on stack\n+; result in r0,r1\n+;\n+#ifdef L_divhi3\n+\t.text\n+\t.global\t___divhi3\n+\t.ref ___udivide\n+___divhi3:\n+\tldi\t0,ir0\n+\tldi\tsp,ar2\n+\tldi     *-ar2(4),r0\n+\tldi     *-ar2(3),r1\n+\tbge\tdiv1\n+\tnegi\tir0\n+\tnegi\tr0\n+\tnegb\tr1\n+div1:\n+\tldi\tr0,ar0\n+\tldi\tr1,ar1\n+\tldi     *-ar2(2),r0\n+\tldi     *-ar2(1),r1\n+\tbge\tdiv2\n+\tnegi\tir0\n+\tnegi\tr0\n+\tnegb\tr1\n+div2:\n+\tcall\t___udivide\n+\ttstb\tir0,ir0\n+\tbge\tdiv3\n+\tnegi\tr0\n+\tnegb\tr1\n+div3:\t\n+\trets\n+#endif\n+\n+;\n+; Integer 64 by 64 signed modulo\n+; long1 and long2 on stack\n+; result in r0,r1\n+;\n+#ifdef L_modhi3\n+\t.text\n+\t.global\t___modhi3\n+\t.ref ___umodulo\n+___modhi3:\n+\tldi\t0,ir0\n+\tldi\tsp,ar2\n+\tldi     *-ar2(4),r0\n+\tldi     *-ar2(3),r1\n+\tbge\tmod1\n+\tnegi\tir0\n+\tnegi\tr0\n+\tnegb\tr1\n+mod1:\n+\tldi\tr0,ar0\n+\tldi\tr1,ar1\n+\tldi     *-ar2(2),r0\n+\tldi     *-ar2(1),r1\n+\tbge\tmod2\n+\tnegi\tir0\n+\tnegi\tr0\n+\tnegb\tr1\n+mod2:\n+\tcall\t___umodulo\n+\tldi\tr2,r0\n+\tldi\tr3,r1\n+\ttstb\tir0,ir0\n+\tbge\tmod3\n+\tnegi\tr0\n+\tnegb\tr1\n+mod3:\t\n+\trets\n+#endif\n+\n+;\n+; double to signed long long converion\n+; input in r2\n+; result in r0,r1\n+;\n+#ifdef L_fix_truncqfhi2\n+\t.text\n+\t.global\t___fix_truncqfhi2\n+\t.ref ufix_truncqfhi2n\n+___fix_truncqfhi2:\n+\t.if .REGPARM == 0\n+#ifdef _TMS320C4x\n+\tlda\tsp,ar0\n+#else\n+\tldiu\tsp,ar0\n+#endif\n+\tldf\t*-ar0(1), r2\n+\t.endif\n+\n+\tcmpf\t0.0,r2\n+\tbge\tufix_truncqfhi2n\n+\tnegf\tr2\n+\tcall\tufix_truncqfhi2n\n+\tnegi\tr0\n+\tnegb\tr1\n+\trets\n+#endif\n+\n+;\n+; double to unsigned long long converion\n+; input in r2\n+; result in r0,r1\n+;\n+#ifdef L_ufix_truncqfhi2\n+\t.text\n+\t.global\t___ufix_truncqfhi2\n+\t.global\tufix_truncqfhi2n\n+___ufix_truncqfhi2:\n+\t.if .REGPARM == 0\n+#ifdef _TMS320C4x\n+\tlda\tsp,ar0\n+#else\n+\tldiu\tsp,ar0\n+#endif\n+\tldf\t*-ar0(1), r2\n+\t.endif\n+\n+ufix_truncqfhi2n:\n+\tcmpf\t0.0,r2\n+\tble\tufix1\n+\tpushf\tr2\n+\tpop\tr3\n+\tash\t-24,r3\n+\tsubi\t31,r3\n+\tcmpi\t32,r3\n+\tbge\tufix1\n+\tcmpi\t-32,r3\n+\tble\tufix1\n+\tldi\t1,r0\n+\tash\t31,r0\n+\tor3\tr0,r2,r0\n+\tldi\tr0,r1\n+\tlsh3\tr3,r0,r0\n+\tsubi\t32,r3\n+\tcmpi\t-32,r3\n+\tldile\t0,r1\n+\tlsh3\tr3,r1,r1\n+\trets\n+ufix1:\n+\tldi\t0,r0\n+\tldi\t0,r1\n+\trets\n+#endif\n+\n+;\n+; signed long long to double converion\n+; input on stack\n+; result in r0\n+;\n+#ifdef L_floathiqf2\n+\t.text\n+\t.global\t___floathiqf2\n+\t.ref ufloathiqf2n\n+___floathiqf2:\n+\tldi\tsp,ar2\n+\tldi\t*-ar2(2),r0\n+\tldi\t*-ar2(1),r1\n+\tbge\tufloathiqf2n\n+\tnegi\tr0\n+\tnegb\tr1\n+\tcall\tufloathiqf2n\n+\tnegf\tr0\n+\trets\n+#endif\n+\n+;\n+; unsigned long long to double converion\n+; input on stack\n+; result in r0\n+;\n+#ifdef L_ufloathiqf2\n+\t.text\n+\t.global\t___ufloathiqf2\n+\t.global\tufloathiqf2n\n+\t.ref ___unsfltconst\n+___ufloathiqf2:\n+\tldi\tsp,ar2\n+\tldi\t*-ar2(2),r0\n+\tldi\t*-ar2(1),r1\n+ufloathiqf2n:\n+\t.if .BIGMODEL\n+#ifdef _TMS320C4x\n+\tldpk\t@___unsfltconst\n+#else\n+\tldp\t@___unsfltconst\n+#endif\n+\t.endif\n+\tldf\t@___unsfltconst,r2\n+\tfloat\tr0\n+\tbge\tuflt1\n+\taddf\tr2,r0\n+uflt1:\n+\tfloat\tr1\n+\tbge\tuflt2\n+\taddf\tr2,r1\n+uflt2:\n+#ifdef _TMS320C4x\n+\tpop\tr3\n+\tbd\tr3\n+\tmpyf\tr2,r1\n+\taddf\tr1,r0\n+\tnop\n+#else\n+\tldf\tr1,r3\n+\tand\t0ffh,r3\n+\tnorm\tr3,r3\n+\tmpyf\tr2,r3\n+\tpop\tar2\n+\tbd\tar2\n+\taddf\tr3,r0\n+\tmpyf\tr2,r1\n+\taddf\tr1,r0\n+#endif\n+#endif\n+\n+;\n+; long double to signed long long converion\n+; input in r2\n+; result in r0,r1\n+;\n+#ifdef L_fix_trunchfhi2\n+\t.text\n+\t.global\t___fix_trunchfhi2\n+\t.ref ufix_trunchfhi2n\n+___fix_trunchfhi2:\n+\t.if .REGPARM == 0\n+#ifdef _TMS320C4x\n+\tlda\tsp,ar0\n+#else\n+\tldiu\tsp,ar0\n+#endif\n+\tldf\t*-ar0(2), r2\n+\tldi\t*-ar0(1), r2\n+\t.endif\n+\n+\tcmpf\t0.0,r2\n+\tbge\tufix_trunchfhi2n\n+\tnegf\tr2\n+\tcall\tufix_trunchfhi2n\n+\tnegi\tr0\n+\tnegb\tr1\n+\trets\n+#endif\n+\n+;\n+; long double to unsigned long long converion\n+; input in r2\n+; result in r0,r1\n+;\n+#ifdef L_ufix_trunchfhi2\n+\t.text\n+\t.global\t___ufix_trunchfhi2\n+\t.global\tufix_trunchfhi2n\n+___ufix_trunchfhi2:\n+\t.if .REGPARM == 0\n+#ifdef _TMS320C4x\n+\tlda\tsp,ar0\n+#else\n+\tldiu\tsp,ar0\n+#endif\n+\tldf\t*-ar0(2), r2\n+\tldi\t*-ar0(1), r2\n+\t.endif\n+\n+ufix_trunchfhi2n:\n+\tcmpf\t0.0,r2\n+\tble\tufixh1\n+\tpushf\tr2\n+\tpop\tr3\n+\tash\t-24,r3\n+\tsubi\t31,r3\n+\tcmpi\t32,r3\n+\tbge\tufixh1\n+\tcmpi\t-32,r3\n+\tble\tufixh1\n+\tldi\t1,r0\n+\tash\t31,r0\n+\tor3\tr0,r2,r0\n+\tldi\tr0,r1\n+\tlsh3\tr3,r0,r0\n+\tsubi\t32,r3\n+\tcmpi\t-32,r3\n+\tldile\t0,r1\n+\tlsh3\tr3,r1,r1\n+\trets\n+ufixh1:\n+\tldi\t0,r0\n+\tldi\t0,r1\n+\trets\n+#endif\n+\n+;\n+; signed long long to long double converion\n+; input on stack\n+; result in r0\n+;\n+#ifdef L_floathihf2\n+\t.text\n+\t.global\t___floathihf2\n+\t.ref ufloathihf2n\n+___floathihf2:\n+\tldi\tsp,ar2\n+\tldi\t*-ar2(2),r0\n+\tldi\t*-ar2(1),r1\n+\tbge\tufloathihf2n\n+\tnegi\tr0\n+\tnegb\tr1\n+\tcall\tufloathihf2n\n+\tnegf\tr0\n+\trets\n+#endif\n+\n+;\n+; unsigned long long to double converion\n+; input on stack\n+; result in r0\n+;\n+#ifdef L_ufloathihf2\n+\t.text\n+\t.global\t___ufloathihf2\n+\t.global\tufloathihf2n\n+\t.ref ___unsfltconst\n+___ufloathihf2:\n+\tldi\tsp,ar2\n+\tldi\t*-ar2(2),r0\n+\tldi\t*-ar2(1),r1\n+ufloathihf2n\n+\t.if .BIGMODEL\n+#ifdef _TMS320C4x\n+\tldpk\t@___unsfltconst\n+#else\n+\tldp\t@___unsfltconst\n+#endif\n+\t.endif\n+\tldf\t@___unsfltconst,r2\n+\tfloat\tr0\n+\tbge\tuflth1\n+\taddf\tr2,r0\n+uflth1:\n+\tfloat\tr1\n+\tbge\tuflth2\n+\taddf\tr2,r1\n+uflth2:\n+#ifdef _TMS320C4x\n+\tpop\tr3\n+\tbd\tr3\n+\tmpyf\tr2,r1\n+\taddf\tr1,r0\n+\tnop\n+#else\n+\tldf\tr1,r3\n+\tand\t0ffh,r3\n+\tnorm\tr3,r3\n+\tmpyf\tr2,r3\n+\tpop\tar2\n+\tbd\tar2\n+\taddf\tr3,r0\n+\tmpyf\tr2,r1\n+\taddf\tr1,r0\n+#endif\n+#endif\n+\n+;\n+; calculate ffs\n+; input in ar2\n+; result in r0\n+;\n+#ifdef L_ffs\n+\t.global\t___ffs\n+\t.ref ___unsfltconst\n+\t.text\n+___ffs:\n+\t.if .REGPARM == 0\n+#ifdef _TMS320C4x\n+\tlda\tsp,ar0\n+#else\n+\tldiu\tsp,ar0\n+#endif\n+\tldi\t*-ar0(1), ar2\n+\t.endif\n+\n+\tnegi\tar2,r0\n+\tand\tar2,r0\n+\tfloat\tr0,r0\n+\tldfu\t0.0,r1\n+\t.if .BIGMODEL\n+#ifdef _TMS320C4x\n+\tldpk\t@___unsfltconst\n+#else\n+\tldp\t@___unsfltconst\n+#endif\n+\t.endif\n+\tldflt\t@___unsfltconst,r1\n+\taddf\tr1,r0\n+\tpushf\tr0\n+\tpop\tr0\n+\tpop\tar0\n+\tbd\tar0\n+\tash\t-24,r0\n+\tldilt\t-1,r0\n+\taddi\t1,r0\n+#endif\n+\n+;\n+; calculate long double * long double\n+; input in r2, r3\n+; output in r0\n+;\n+#ifdef L_mulhf3\n+\t.global ___mulhf3\n+\t.text\n+___mulhf3:\n+\t.if .REGPARM == 0\n+#ifdef _TMS320C4x\n+\tlda\tsp,ar0\n+#else\n+\tldiu\tsp,ar0\n+#endif\n+\tldf\t*-ar0(2), r2\n+\tldi\t*-ar0(1), r2\n+\tldf\t*-ar0(4), r3\n+\tldi\t*-ar0(3), r3\n+\t.endif\n+\n+\tpop\tar2\t\t; return ad\n+\tldf\tr2,r0\t\t; copy lsb0\n+\tldf\tr3,r1\t\t; copy lsb1\n+\tand\t0ffh,r0\t\t; mask lsb0\n+\tand\t0ffh,r1\t\t; mask lsb1\n+\tnorm\tr0,r0\t\t; correct lsb0\n+\tnorm\tr1,r1\t\t; correct lsb1\n+\tmpyf\tr2,r1\t\t; arg0*lsb1\n+\tmpyf\tr3,r0\t\t; arg1*lsb0\n+\tbd\tar2\t\t; return (delayed)\n+\taddf\tr0,r1\t\t; arg0*lsb1 + arg1*lsb0\n+\tmpyf\tr2,r3,r0\t; msb0*msb1\n+\taddf\tr1,r0\t\t; msb0*msb1 + arg0*lsb1 + arg1*lsb0\n+#endif\n+\n+;\n+; calculate long double / long double\n+; r2 dividend, r3 divisor, r0 quotient\n+;\n+#ifdef L_divhf3\n+\t.global ___divhf3\n+\t.text\n+___divhf3:\n+\t.if .REGPARM == 0\n+#ifdef _TMS320C4x\n+\tlda\tsp,ar0\n+#else\n+\tldiu\tsp,ar0\n+#endif\n+\tldf\t*-ar0(2), r2\n+\tldi\t*-ar0(1), r2\n+\tldf\t*-ar0(4), r3\n+\tldi\t*-ar0(3), r3\n+\t.endif\n+\n+#ifdef _TMS320C4x\n+\tpop\tar1\n+        rcpf    r3, r0\n+\tmpyf3\tr0, r3, r1\n+\tsubrf\t2.0, r1\t\t\n+\tmpyf\tr1, r0\t\n+\tmpyf3\tr0, r3, r1\n+\tbud\tar1\n+\tsubrf\t2.0, r1\t\n+\tmpyf\tr1, r0\n+\tmpyf\tr2, r0\n+#else\n+\tpop\tar1\n+\tpushf\tr3\n+\tpop\tr0\n+\tnot\tr0\t\n+\tpush\tr0\n+\tpopf\tr0\n+\tldf\t-1.0, r1\n+\txor\tr1, r0\n+\n+\tmpyf3\tr0, r3, r1\t; r1 = r[0] * v\n+\tsubrf\t2.0, r1\t\t; r1 = 2.0 - r[0] * v\n+\tmpyf\tr1, r0\t\t; r0 = r[0] * (2.0 - r[0] * v) = r[1]\n+; End of 1st iteration\n+\n+\tmpyf3\tr0, r3, r1\t; r1 = r[1] * v\n+\tsubrf\t2.0, r1\t\t; r1 = 2.0 - r[1] * v\n+\tmpyf\tr1, r0\t\t; r0 = r[1] * (2.0 - r[1] * v) = r[2]\n+; End of 2nd iteration\n+\n+\tmpyf3\tr0, r3, r1\t; r1 = r[2] * v\n+\tsubrf\t2.0, r1\t\t; r1 = 2.0 - r[2] * v\n+\tmpyf\tr1, r0\t\t; r0 = r[2] * (2.0 - r[2] * v) = r[3]\n+; End of 3rd iteration\n+\n+\tor\t080h, r0\n+\trnd\tr0\n+\n+;\tmpyf3\tr0, r3, r1\t; r1 = r[3] * v\n+\tpush\tr4\n+\tpushf\tr4\n+\tmpyf\tr0, r3, r1\n+\n+\tldf\tr0, r4\n+\tand\t0ffh, r4\n+\tnorm\tr4, r4\n+\tmpyf\tr3, r4\n+\taddf\tr4, r1\n+\n+\tldf\tr3, r4\n+\tand\t0ffh, r4\n+\tnorm \tr4, r4\n+\tmpyf\tr0, r4\n+\taddf\tr4, r1\n+\t\n+\tsubrf\t2.0, r1\t\t; r1 = 2.0 - r[3] * v\n+\n+\tmpyf\tr1, r0, r3\t; r3 = r[3] * (2.0 - r[3] * v) = r[5]\n+\n+\tldf\tr1, r4\n+\tand\t0ffh, r4\n+\tnorm\tr4, r4\n+\tmpyf\tr0, r4\n+\taddf\tr4, r3\n+\n+\tldf\tr0, r4\n+\tand\t0ffh, r4\n+\tnorm \tr4, r4\n+\tmpyf\tr1, r4\n+\taddf\tr4, r3\n+\n+\tmpyf\tr2, r3, r0\t; Multiply by the dividend\n+\n+\tldf\tr2, r4\n+\tand\t0ffh, r4\n+\tnorm\tr4, r4\n+\tmpyf\tr3, r4\n+\taddf\tr4, r0\n+\n+\tldf\tr3, r4\n+\tand\t0ffh, r4\n+\tnorm \tr4, r4\n+\tmpyf\tr2, r4\n+\tbd\tar1\n+\taddf\tr4, r0\n+\n+\tpopf\tr4\n+\tpop\tr4\n+#endif\n+#endif"}]}