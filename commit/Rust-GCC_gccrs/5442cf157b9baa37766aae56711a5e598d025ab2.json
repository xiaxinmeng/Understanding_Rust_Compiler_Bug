{"sha": "5442cf157b9baa37766aae56711a5e598d025ab2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ0MmNmMTU3YjliYWEzNzc2NmFhZTU2NzExYTVlNTk4ZDAyNWFiMg==", "commit": {"author": {"name": "Mark Kettenis", "email": "kettenis@wins.uva.nl", "date": "2001-07-19T18:20:49Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2001-07-19T18:20:49Z"}, "message": "unwind-dw2.c (_Unwind_FrameState): Add eh_ptr.\n\n\t* unwind-dw2.c (_Unwind_FrameState): Add eh_ptr.\n\t(extract_cie_info): Handle \"eh\" augmentation properly,\n\tremember eh_ptr.\n\t(struct frame_state, __frame_state_for): New.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r44155", "tree": {"sha": "7d98b7a923b641e158c5eaf2f3bf02a0121e8889", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d98b7a923b641e158c5eaf2f3bf02a0121e8889"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5442cf157b9baa37766aae56711a5e598d025ab2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5442cf157b9baa37766aae56711a5e598d025ab2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5442cf157b9baa37766aae56711a5e598d025ab2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5442cf157b9baa37766aae56711a5e598d025ab2/comments", "author": null, "committer": null, "parents": [{"sha": "432fa9f208fd1233b2a1c0a48cbf750945217b83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/432fa9f208fd1233b2a1c0a48cbf750945217b83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/432fa9f208fd1233b2a1c0a48cbf750945217b83"}], "stats": {"total": 88, "additions": 80, "deletions": 8}, "files": [{"sha": "9d23e01d3d375296e25198fed1dadfae7918f092", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5442cf157b9baa37766aae56711a5e598d025ab2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5442cf157b9baa37766aae56711a5e598d025ab2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5442cf157b9baa37766aae56711a5e598d025ab2", "patch": "@@ -1,3 +1,11 @@\n+2001-07-19  Mark Kettenis  <kettenis@wins.uva.nl>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* unwind-dw2.c (_Unwind_FrameState): Add eh_ptr.\n+\t(extract_cie_info): Handle \"eh\" augmentation properly,\n+\tremember eh_ptr.\n+\t(struct frame_state, __frame_state_for): New.\n+\n 2001-07-19  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* config/alpha/osf.h (ASM_OUTPUT_WEAK_ALIAS, ASM_WEAKEN_LABEL,"}, {"sha": "c1aa67fdb5ad2d3b8c1340f660472895b5b263c0", "filename": "gcc/unwind-dw2.c", "status": "modified", "additions": 72, "deletions": 8, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5442cf157b9baa37766aae56711a5e598d025ab2/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5442cf157b9baa37766aae56711a5e598d025ab2/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=5442cf157b9baa37766aae56711a5e598d025ab2", "patch": "@@ -106,6 +106,7 @@ typedef struct\n   unsigned char fde_encoding;\n   unsigned char lsda_encoding;\n   unsigned char saw_z;\n+  void *eh_ptr;\n } _Unwind_FrameState;\n \f\n /* Read unaligned data from the instruction buffer.  */\n@@ -220,6 +221,15 @@ extract_cie_info (struct dwarf_cie *cie, struct _Unwind_Context *context,\n   const unsigned char *ret = NULL;\n   _Unwind_Ptr tmp;\n \n+  /* g++ v2 \"eh\" has pointer immediately following augmentation string,\n+     so it must be handled first.  */\n+  if (aug[0] == 'e' && aug[1] == 'h')\n+    {\n+      fs->eh_ptr = read_pointer (p);\n+      p += sizeof (void *);\n+      aug += 2;\n+    }\n+\n   /* Immediately following the augmentation are the code and\n      data alignment and return address column.  */\n   p = read_uleb128 (p, &tmp); fs->code_align = tmp;\n@@ -242,15 +252,8 @@ extract_cie_info (struct dwarf_cie *cie, struct _Unwind_Context *context,\n   /* Iterate over recognized augmentation subsequences.  */\n   while (*aug != '\\0')\n     {\n-      /* \"eh\" was used by g++ v2; recognize and skip.  */\n-      if (aug[0] == 'e' && aug[1] == 'h')\n-\t{\n-\t  p += sizeof (void *);\n-\t  aug += 2;\n-\t}\n-\n       /* \"L\" indicates a byte showing how the LSDA pointer is encoded.  */\n-      else if (aug[0] == 'L')\n+      if (aug[0] == 'L')\n \t{\n \t  fs->lsda_encoding = *p++;\n \t  aug += 1;\n@@ -937,8 +940,69 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n \n   return _URC_NO_REASON;\n }\n+\f\n+typedef struct frame_state\n+{\n+  void *cfa;\n+  void *eh_ptr;\n+  long cfa_offset;\n+  long args_size;\n+  long reg_or_offset[DWARF_FRAME_REGISTERS+1];\n+  unsigned short cfa_reg;\n+  unsigned short retaddr_column;\n+  char saved[DWARF_FRAME_REGISTERS+1];\n+} frame_state;\n+\n+struct frame_state * __frame_state_for (void *, struct frame_state *);\n+\n+/* Called from pre-G++ 3.0 __throw to find the registers to restore for\n+   a given PC_TARGET.  The caller should allocate a local variable of\n+   `struct frame_state' and pass its address to STATE_IN.  */\n+\n+struct frame_state *\n+__frame_state_for (void *pc_target, struct frame_state *state_in)\n+{\n+  struct _Unwind_Context context;\n+  _Unwind_FrameState fs;\n+  int reg;\n+\n+  memset (&context, 0, sizeof (struct _Unwind_Context));\n+  context.ra = pc_target + 1;\n+\n+  if (uw_frame_state_for (&context, &fs) != _URC_NO_REASON)\n+    return 0;\n \n+  /* We have no way to pass a location expression for the CFA to our\n+     caller.  It wouldn't understand it anyway.  */\n+  if (fs.cfa_how == CFA_EXP)\n+    return 0;\n \n+  for (reg = 0; reg < DWARF_FRAME_REGISTERS + 1; reg++)\n+    {\n+      state_in->saved[reg] = fs.regs.reg[reg].how;\n+      switch (state_in->saved[reg])\n+\t{\n+\tcase REG_SAVED_REG:\n+\t  state_in->reg_or_offset[reg] = fs.regs.reg[reg].loc.reg;\n+\t  break;\n+\tcase REG_SAVED_OFFSET:\n+\t  state_in->reg_or_offset[reg] = fs.regs.reg[reg].loc.offset;\n+\t  break;\n+\tdefault:\n+\t  state_in->reg_or_offset[reg] = 0;\n+\t  break;\n+\t}\n+    }\n+\n+  state_in->cfa_offset = fs.cfa_offset;\n+  state_in->cfa_reg = fs.cfa_reg;\n+  state_in->retaddr_column = fs.retaddr_column;\n+  state_in->args_size = context.args_size;\n+  state_in->eh_ptr = fs.eh_ptr;\n+\n+  return state_in;\n+}\n+\f\n static void\n uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n {"}]}