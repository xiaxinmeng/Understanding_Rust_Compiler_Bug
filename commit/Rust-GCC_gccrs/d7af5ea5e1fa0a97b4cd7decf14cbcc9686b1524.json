{"sha": "d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdhZjVlYTVlMWZhMGE5N2I0Y2Q3ZGVjZjE0Y2JjYzk2ODZiMTUyNA==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2014-01-29T15:30:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-29T15:30:21Z"}, "message": "2014-01-29  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.adb Add an entry for aspect Part_Of in table\n\tCanonical_Aspect.\n\t* aspects.ads Add an entry for aspect Part_Of in tables Aspect_Id,\n\tAspect_Argument, Aspect_Names and Aspect_Delay.\n\t* atree.h Define Elist9.\n\t* atree.adb (Elist9): New routine.\n\t(Set_Elist9): New routine.\n\t* atree.ads (Elist9): New routine.\n\t(Set_Elist9): New routine.\n\t* einfo.adb Add Part_Of_Constituents and Encapsulating_State to\n\tthe list of node usage.  Remove Refined_State from the list of\n\tnode usage.\n\t(Encapsulating_State): New routine.\n\t(Get_Pragma):\n\tHandle pragma Part_Of; (Part_Of_Constituents): New routine.\n\t(Refined_State): Removed.\n\t(Set_Encapsulating_State): New routine.\n\t(Set_Part_Of_Constituents): New routine.\n\t(Set_Refined_State): Removed.\n\t(Write_Field9_Name): Add an entry\n\tfor Part_Of_Constituents (Write_Field10_Name): Add an entry for\n\tEncapsulating_State. Remove the entry for Refined_State.\n\t* einfo.ads Add new attributes Encapsulating_State\n\tand Part_Of_Constituents alond with their usage in\n\tentities. Remove attribute Refined_State along with its\n\tusage in entities.\n\t(Encapsulating_State): New routine and\n\tpragma Inline.\t(Get_Pragma): Update the comment on usage.\n\t(Part_Of_Constituents): New routine and pragma Inline.\n\t(Refined_State): Removed along with pragma Inline.\n\t(Set_Encapsulating_State): New routine and pragma Inline.\n\t(Set_Part_Of_Constituents): New routine and pragma Inline.\n\t(Set_Refined_State): Removed along with pragma Inline.\n\t* par-prag.adb Pragma Part_Of does not need any special processing\n\tby the parser.\n\t* sem_ch3.adb (Analyze_Declarations): Remove local variables\n\tBody_Id and Prag. Call separate routines to analyze the\n\tcontract of a package [body].\n\t(Analyze_Object_Contract):\n\tUpdate the comment on usage. Remove local variables\n\tItems and Nam. Use Get_Pragma rather than traversing the\n\tclassification list.  Verify whether the lack of indicator\n\tPart_Of agrees with the placement of the variable in state space.\n\t(Analyze_Object_Declaration): Initialize the encapsulating state\n\tof a variable.\t(Requires_State_Refinement): Moved to sem_util.\n\t* sem_ch7.adb (Analyze_Package_Body_Contract): New routine.\n\t(Analyze_Package_Contract): New routine.\n\t* sem_ch7.ads (Analyze_Package_Body_Contract): New routine.\n\t(Analyze_Package_Contract): New routine.\n\t* sem_ch10.adb (Decorate_State): Initialize the encapsulating\n\tstate and Part_Of constituents.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications):\n\tAdd processing for aspect Part_Of. Update all\n\tcalls to Decorate_Delayed_Aspect_And_Pragma.\n\t(Check_Aspect_At_Freeze_Point): Aspect Part_Of does\n\tnot need any special processing at freeze time.\n\t(Decorate_Delayed_Aspect_And_Pragma): Renamed to\n\tDecorate_Aspect_And_Pragma.  Add formal parameter Delayed and\n\tupdate the associated comment.\n\t* sem_prag.adb Add an entry for pragma Part_Of in table Sig_Flags.\n\t(Analyze_Abstract_State): Add new global variable State_Id. Remove\n\tlocal constants Errors and Loc. Remove local variables Is_Null\n\tand State_Nam. Create the entity of the abstract state on the\n\tspot, before all remaining checks are performed. Verify that a\n\tmissing Part_Of option agrees with the placement of the abstract\n\tstate within the state space.\n\t(Analyze_Depends_In_Decl_Part):\n\tAdd new global variables Constits_Seen and States_Seen. Check\n\tthat a state and a corresponding constituent do not appear\n\tin pragma [Refined_]Depends.\n\t(Analyze_Global_In_Decl_Part):\n\tAdd new global variables Constits_Seen and States_Seen. Check\n\tthat a state and a corresponding constituent do not appear\n\tin pragma [Refined_]Global.\n\t(Analyze_Global_Item):\n\tRemove the now obsolete code that deals with Part_Of.\n\tAdd the entity of the global item to the list of processed\n\titems.\t(Analyze_Initializes_In_Decl_Part): Add new global\n\tvariables Constits_Seen and States_Seen. Check that a state\n\tand a corresponding constituent do not appear in pragma\n\tInitializes.\n\t(Analyze_Initialization_Item): Add the entity\n\tof the initialization item to the list of processed items.\n\t(Analyze_Input_Item): Add the entity of the initialization\n\titem to the list of processed items.\n\t(Analyze_Input_Output):\n\tRemove the now obsolete code that deals with Part_Of.  Add the\n\tentity of the input/output to the list of processed items.\n\t(Analyze_Part_Of): New routine.\n\t(Analyze_Part_Of_Option): Remove\n\tlocal constant Par_State. Add local constant Encaps and local\n\tvariables Encaps_Id and Legal. Use Analyze_Part of to analyze\n\tthe option. Turn the related state into a Part_Of constituent\n\tif the option is legal.\n\t(Analyze_Pragma): Add processing\n\tfor pragma Part_Of.\n\t(Analyze_Refined_State_In_Decl_Part):\n\tRemove global constants Pack_Body and Spec_Id. Remove\n\tglobal variables Abstr_States and Hidden_States. Add new\n\tglobal variables Available_States, Body_Id, Body_States and\n\tSpec_Id. Add new local constant Body_Decl. Reimplement the\n\tlogic that extracts the states available for refinement from\n\tthe related package and the body hidden states of the said\n\tpackage.\n\t(Analyze_Refinement_Clause): Add local variable Part_Of_Constits.\n\t(Check_Applicable_Policy): Alphabetize body.\n\t(Check_Dependency_Clause): Replace Refined_State\n\twith Encapsulating_State.\n\t(Check_Matching_Constituent):\n\tReimplement the logic that determines whether an item is a valid\n\t/ invalid constituent of the current refined state. Return when\n\ta construct does not denote a valid abstract state. Extract the\n\tlist of Part_Of constituents for further analysis. Check that all\n\tPart_Of constituents of a state have been used in its refinement.\n\t(Check_Matching_State): Update the comment on usage. Operate\n\ton the list of available states.\n\t(Check_Missing_Part_Of): New routine.\n\t(Check_Refined_Global_Item): Replace Refined_State\n\twith Encapsulating_State.\n\t(Check_State_And_Constituent_Use): New routine.\n\t(Create_Abstract_State): New routine.\n\t(Is_Matching_Input): Replace Refined_State with Encapsulating_State.\n\t(Is_Part_Of): Removed.\n\t(Collect_Body_States): New routine.\n\t(Collect_Constituent): Replace Refined_State with Encapsulating_State.\n\t(Collect_Hidden_States): Removed.\n\t(Report_Unrefined_States): Change the profile of the procedure along\n\twith the comment on usage.\n\t(Report_Unused_Constituents): New routine.\n\t(Report_Unused_Hidden_States): Removed.\n\t(Report_Unused_States): New routine.\n\t* sem_prag.ads (Check_Missing_Part_Of): New routine.\n\t* sem_util.adb (Add_Contract_Item): Pragma Part_Of can now\n\tappear in the classification pragmas of a package instantiation\n\tor a variable.\n\t(Find_Placement_In_State_Space): New routine.\n\t(Is_Child): Removed.\n\t(Is_Child_Or_Sibling): Remove formal\n\tparameter Private_Child. Remove the private child checks.\n\t(Requires_State_Refinement): Moved from sem_ch3.\n\t* sem_util.ads Add new type State_Space_Kind along with\n\tcomment on its usage and values.\n\t(Add_Contract_Item): Update the comment on usage.\n\t(Find_Body_Discriminal): Alphabetize spec.\n\t(Find_Placement_In_State_Space): New routine.\n\t(Is_Child_Or_Sibling): Remove formal parameter Private_Child\n\tand update the comment on usage.\n\t(Requires_State_Refinement): Moved from sem_ch3.\n\t* sinfo.ads: Update the documentation of N_Contract.\n\t* snames.ads-tmpl The predefined name for Part_Of is now used\n\tto denote a pragma. Add Pragma_Id for Part_Of.\n\nFrom-SVN: r207251", "tree": {"sha": "2c5cdfc1aeb5cc652003d23476ae5fc7f72921c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c5cdfc1aeb5cc652003d23476ae5fc7f72921c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0830210cffd9a14a5cebcb637b23db9606ad2aba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0830210cffd9a14a5cebcb637b23db9606ad2aba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0830210cffd9a14a5cebcb637b23db9606ad2aba"}], "stats": {"total": 2307, "additions": 1680, "deletions": 627}, "files": [{"sha": "4f853b9a6917a4fa37276ed07ad5fd424d5d0f87", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -1,3 +1,157 @@\n+2014-01-29  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.adb Add an entry for aspect Part_Of in table\n+\tCanonical_Aspect.\n+\t* aspects.ads Add an entry for aspect Part_Of in tables Aspect_Id,\n+\tAspect_Argument, Aspect_Names and Aspect_Delay.\n+\t* atree.h Define Elist9.\n+\t* atree.adb (Elist9): New routine.\n+\t(Set_Elist9): New routine.\n+\t* atree.ads (Elist9): New routine.\n+\t(Set_Elist9): New routine.\n+\t* einfo.adb Add Part_Of_Constituents and Encapsulating_State to\n+\tthe list of node usage.  Remove Refined_State from the list of\n+\tnode usage.\n+\t(Encapsulating_State): New routine.\n+\t(Get_Pragma):\n+\tHandle pragma Part_Of; (Part_Of_Constituents): New routine.\n+\t(Refined_State): Removed.\n+\t(Set_Encapsulating_State): New routine.\n+\t(Set_Part_Of_Constituents): New routine.\n+\t(Set_Refined_State): Removed.\n+\t(Write_Field9_Name): Add an entry\n+\tfor Part_Of_Constituents (Write_Field10_Name): Add an entry for\n+\tEncapsulating_State. Remove the entry for Refined_State.\n+\t* einfo.ads Add new attributes Encapsulating_State\n+\tand Part_Of_Constituents alond with their usage in\n+\tentities. Remove attribute Refined_State along with its\n+\tusage in entities.\n+\t(Encapsulating_State): New routine and\n+\tpragma Inline.\t(Get_Pragma): Update the comment on usage.\n+\t(Part_Of_Constituents): New routine and pragma Inline.\n+\t(Refined_State): Removed along with pragma Inline.\n+\t(Set_Encapsulating_State): New routine and pragma Inline.\n+\t(Set_Part_Of_Constituents): New routine and pragma Inline.\n+\t(Set_Refined_State): Removed along with pragma Inline.\n+\t* par-prag.adb Pragma Part_Of does not need any special processing\n+\tby the parser.\n+\t* sem_ch3.adb (Analyze_Declarations): Remove local variables\n+\tBody_Id and Prag. Call separate routines to analyze the\n+\tcontract of a package [body].\n+\t(Analyze_Object_Contract):\n+\tUpdate the comment on usage. Remove local variables\n+\tItems and Nam. Use Get_Pragma rather than traversing the\n+\tclassification list.  Verify whether the lack of indicator\n+\tPart_Of agrees with the placement of the variable in state space.\n+\t(Analyze_Object_Declaration): Initialize the encapsulating state\n+\tof a variable.\t(Requires_State_Refinement): Moved to sem_util.\n+\t* sem_ch7.adb (Analyze_Package_Body_Contract): New routine.\n+\t(Analyze_Package_Contract): New routine.\n+\t* sem_ch7.ads (Analyze_Package_Body_Contract): New routine.\n+\t(Analyze_Package_Contract): New routine.\n+\t* sem_ch10.adb (Decorate_State): Initialize the encapsulating\n+\tstate and Part_Of constituents.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications):\n+\tAdd processing for aspect Part_Of. Update all\n+\tcalls to Decorate_Delayed_Aspect_And_Pragma.\n+\t(Check_Aspect_At_Freeze_Point): Aspect Part_Of does\n+\tnot need any special processing at freeze time.\n+\t(Decorate_Delayed_Aspect_And_Pragma): Renamed to\n+\tDecorate_Aspect_And_Pragma.  Add formal parameter Delayed and\n+\tupdate the associated comment.\n+\t* sem_prag.adb Add an entry for pragma Part_Of in table Sig_Flags.\n+\t(Analyze_Abstract_State): Add new global variable State_Id. Remove\n+\tlocal constants Errors and Loc. Remove local variables Is_Null\n+\tand State_Nam. Create the entity of the abstract state on the\n+\tspot, before all remaining checks are performed. Verify that a\n+\tmissing Part_Of option agrees with the placement of the abstract\n+\tstate within the state space.\n+\t(Analyze_Depends_In_Decl_Part):\n+\tAdd new global variables Constits_Seen and States_Seen. Check\n+\tthat a state and a corresponding constituent do not appear\n+\tin pragma [Refined_]Depends.\n+\t(Analyze_Global_In_Decl_Part):\n+\tAdd new global variables Constits_Seen and States_Seen. Check\n+\tthat a state and a corresponding constituent do not appear\n+\tin pragma [Refined_]Global.\n+\t(Analyze_Global_Item):\n+\tRemove the now obsolete code that deals with Part_Of.\n+\tAdd the entity of the global item to the list of processed\n+\titems.\t(Analyze_Initializes_In_Decl_Part): Add new global\n+\tvariables Constits_Seen and States_Seen. Check that a state\n+\tand a corresponding constituent do not appear in pragma\n+\tInitializes.\n+\t(Analyze_Initialization_Item): Add the entity\n+\tof the initialization item to the list of processed items.\n+\t(Analyze_Input_Item): Add the entity of the initialization\n+\titem to the list of processed items.\n+\t(Analyze_Input_Output):\n+\tRemove the now obsolete code that deals with Part_Of.  Add the\n+\tentity of the input/output to the list of processed items.\n+\t(Analyze_Part_Of): New routine.\n+\t(Analyze_Part_Of_Option): Remove\n+\tlocal constant Par_State. Add local constant Encaps and local\n+\tvariables Encaps_Id and Legal. Use Analyze_Part of to analyze\n+\tthe option. Turn the related state into a Part_Of constituent\n+\tif the option is legal.\n+\t(Analyze_Pragma): Add processing\n+\tfor pragma Part_Of.\n+\t(Analyze_Refined_State_In_Decl_Part):\n+\tRemove global constants Pack_Body and Spec_Id. Remove\n+\tglobal variables Abstr_States and Hidden_States. Add new\n+\tglobal variables Available_States, Body_Id, Body_States and\n+\tSpec_Id. Add new local constant Body_Decl. Reimplement the\n+\tlogic that extracts the states available for refinement from\n+\tthe related package and the body hidden states of the said\n+\tpackage.\n+\t(Analyze_Refinement_Clause): Add local variable Part_Of_Constits.\n+\t(Check_Applicable_Policy): Alphabetize body.\n+\t(Check_Dependency_Clause): Replace Refined_State\n+\twith Encapsulating_State.\n+\t(Check_Matching_Constituent):\n+\tReimplement the logic that determines whether an item is a valid\n+\t/ invalid constituent of the current refined state. Return when\n+\ta construct does not denote a valid abstract state. Extract the\n+\tlist of Part_Of constituents for further analysis. Check that all\n+\tPart_Of constituents of a state have been used in its refinement.\n+\t(Check_Matching_State): Update the comment on usage. Operate\n+\ton the list of available states.\n+\t(Check_Missing_Part_Of): New routine.\n+\t(Check_Refined_Global_Item): Replace Refined_State\n+\twith Encapsulating_State.\n+\t(Check_State_And_Constituent_Use): New routine.\n+\t(Create_Abstract_State): New routine.\n+\t(Is_Matching_Input): Replace Refined_State with Encapsulating_State.\n+\t(Is_Part_Of): Removed.\n+\t(Collect_Body_States): New routine.\n+\t(Collect_Constituent): Replace Refined_State with Encapsulating_State.\n+\t(Collect_Hidden_States): Removed.\n+\t(Report_Unrefined_States): Change the profile of the procedure along\n+\twith the comment on usage.\n+\t(Report_Unused_Constituents): New routine.\n+\t(Report_Unused_Hidden_States): Removed.\n+\t(Report_Unused_States): New routine.\n+\t* sem_prag.ads (Check_Missing_Part_Of): New routine.\n+\t* sem_util.adb (Add_Contract_Item): Pragma Part_Of can now\n+\tappear in the classification pragmas of a package instantiation\n+\tor a variable.\n+\t(Find_Placement_In_State_Space): New routine.\n+\t(Is_Child): Removed.\n+\t(Is_Child_Or_Sibling): Remove formal\n+\tparameter Private_Child. Remove the private child checks.\n+\t(Requires_State_Refinement): Moved from sem_ch3.\n+\t* sem_util.ads Add new type State_Space_Kind along with\n+\tcomment on its usage and values.\n+\t(Add_Contract_Item): Update the comment on usage.\n+\t(Find_Body_Discriminal): Alphabetize spec.\n+\t(Find_Placement_In_State_Space): New routine.\n+\t(Is_Child_Or_Sibling): Remove formal parameter Private_Child\n+\tand update the comment on usage.\n+\t(Requires_State_Refinement): Moved from sem_ch3.\n+\t* sinfo.ads: Update the documentation of N_Contract.\n+\t* snames.ads-tmpl The predefined name for Part_Of is now used\n+\tto denote a pragma. Add Pragma_Id for Part_Of.\n+\n 2014-01-29  Emmanuel Briot  <briot@adacore.com>\n \n \t* s-regexp.adb (Create_Secondary_Table): Automatically grow the state"}, {"sha": "cff2b811c626f99e07cd3c00afb2bd213b8fe3fb", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -523,6 +523,7 @@ package body Aspects is\n     Aspect_Object_Size                  => Aspect_Object_Size,\n     Aspect_Output                       => Aspect_Output,\n     Aspect_Pack                         => Aspect_Pack,\n+    Aspect_Part_Of                      => Aspect_Part_Of,\n     Aspect_Persistent_BSS               => Aspect_Persistent_BSS,\n     Aspect_Post                         => Aspect_Post,\n     Aspect_Postcondition                => Aspect_Post,"}, {"sha": "1ba3ee0ecceb1778d511073dc4f1c7939418f11f", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -107,6 +107,7 @@ package Aspects is\n       Aspect_Machine_Radix,\n       Aspect_Object_Size,                   -- GNAT\n       Aspect_Output,\n+      Aspect_Part_Of,                       -- GNAT\n       Aspect_Post,\n       Aspect_Postcondition,\n       Aspect_Pre,\n@@ -330,6 +331,7 @@ package Aspects is\n       Aspect_Machine_Radix           => Expression,\n       Aspect_Object_Size             => Expression,\n       Aspect_Output                  => Name,\n+      Aspect_Part_Of                 => Expression,\n       Aspect_Post                    => Expression,\n       Aspect_Postcondition           => Expression,\n       Aspect_Pre                     => Expression,\n@@ -429,6 +431,7 @@ package Aspects is\n       Aspect_Object_Size                  => Name_Object_Size,\n       Aspect_Output                       => Name_Output,\n       Aspect_Pack                         => Name_Pack,\n+      Aspect_Part_Of                      => Name_Part_Of,\n       Aspect_Persistent_BSS               => Name_Persistent_BSS,\n       Aspect_Post                         => Name_Post,\n       Aspect_Postcondition                => Name_Postcondition,\n@@ -679,6 +682,7 @@ package Aspects is\n       Aspect_Convention                   => Never_Delay,\n       Aspect_Dimension                    => Never_Delay,\n       Aspect_Dimension_System             => Never_Delay,\n+      Aspect_Part_Of                      => Never_Delay,\n       Aspect_Refined_Post                 => Never_Delay,\n       Aspect_SPARK_Mode                   => Never_Delay,\n       Aspect_Synchronization              => Never_Delay,"}, {"sha": "e4592359bb5da36e2f54f8e3b8aa4e7de3be48cf", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -2758,6 +2758,17 @@ package body Atree is\n          end if;\n       end Elist8;\n \n+      function Elist9 (N : Node_Id) return Elist_Id is\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Value : constant Union_Id := Nodes.Table (N + 1).Field9;\n+      begin\n+         if Value = 0 then\n+            return No_Elist;\n+         else\n+            return Elist_Id (Value);\n+         end if;\n+      end Elist9;\n+\n       function Elist10 (N : Node_Id) return Elist_Id is\n          pragma Assert (Nkind (N) in N_Entity);\n          Value : constant Union_Id := Nodes.Table (N + 1).Field10;\n@@ -5476,6 +5487,12 @@ package body Atree is\n          Nodes.Table (N + 1).Field8 := Union_Id (Val);\n       end Set_Elist8;\n \n+      procedure Set_Elist9 (N : Node_Id; Val : Elist_Id) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         Nodes.Table (N + 1).Field9 := Union_Id (Val);\n+      end Set_Elist9;\n+\n       procedure Set_Elist10 (N : Node_Id; Val : Elist_Id) is\n       begin\n          pragma Assert (Nkind (N) in N_Entity);"}, {"sha": "48b6858af4cbd1c120d997784740067b88c1e2e2", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -1279,6 +1279,9 @@ package Atree is\n       function Elist8 (N : Node_Id) return Elist_Id;\n       pragma Inline (Elist8);\n \n+      function Elist9 (N : Node_Id) return Elist_Id;\n+      pragma Inline (Elist9);\n+\n       function Elist10 (N : Node_Id) return Elist_Id;\n       pragma Inline (Elist10);\n \n@@ -2585,6 +2588,9 @@ package Atree is\n       procedure Set_Elist8 (N : Node_Id; Val : Elist_Id);\n       pragma Inline (Set_Elist8);\n \n+      procedure Set_Elist9 (N : Node_Id; Val : Elist_Id);\n+      pragma Inline (Set_Elist9);\n+\n       procedure Set_Elist10 (N : Node_Id; Val : Elist_Id);\n       pragma Inline (Set_Elist10);\n "}, {"sha": "7d603ba425dde19a7ef88b38a10b801056fab2bd", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -501,6 +501,7 @@ extern Node_Id Current_Error_Node;\n #define Elist4(N)     Field4  (N)\n #define Elist5(N)     Field5  (N)\n #define Elist8(N)     Field8  (N)\n+#define Elist9(N)     Field9  (N)\n #define Elist10(N)    Field10 (N)\n #define Elist13(N)    Field13 (N)\n #define Elist15(N)    Field15 (N)"}, {"sha": "cc1c23f516127a4132273c23cf6d158d57362a2f", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -86,14 +86,15 @@ package body Einfo is\n \n    --    Class_Wide_Type                 Node9\n    --    Current_Value                   Node9\n+   --    Part_Of_Constituents            Elist9\n    --    Renaming_Map                    Uint9\n \n+   --    Encapsulating_State             Node10\n    --    Direct_Primitive_Operations     Elist10\n    --    Discriminal_Link                Node10\n    --    Float_Rep                       Uint10 (but returns Float_Rep_Kind)\n    --    Handler_Records                 List10\n    --    Normalized_Position_Max         Uint10\n-   --    Refined_State                   Node10\n \n    --    Component_Bit_Offset            Uint11\n    --    Full_View                       Node11\n@@ -1059,6 +1060,12 @@ package body Einfo is\n       return Flag174 (Id);\n    end Elaboration_Entity_Required;\n \n+   function Encapsulating_State (Id : E) return N is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Abstract_State, E_Variable));\n+      return Node10 (Id);\n+   end Encapsulating_State;\n+\n    function Enclosing_Scope (Id : E) return E is\n    begin\n       return Node18 (Id);\n@@ -2630,6 +2637,12 @@ package body Einfo is\n       return Node19 (Base_Type (Id));\n    end Parent_Subtype;\n \n+   function Part_Of_Constituents (Id : E) return L is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Abstract_State);\n+      return Elist9 (Id);\n+   end Part_Of_Constituents;\n+\n    function Postcondition_Proc (Id : E) return E is\n    begin\n       pragma Assert (Ekind (Id) = E_Procedure);\n@@ -2705,12 +2718,6 @@ package body Einfo is\n       return Flag227 (Id);\n    end Referenced_As_Out_Parameter;\n \n-   function Refined_State (Id : E) return N is\n-   begin\n-      pragma Assert (Ekind_In (Id, E_Abstract_State, E_Variable));\n-      return Node10 (Id);\n-   end Refined_State;\n-\n    function Refinement_Constituents (Id : E) return L is\n    begin\n       pragma Assert (Ekind (Id) = E_Abstract_State);\n@@ -3714,6 +3721,12 @@ package body Einfo is\n       Set_Flag174 (Id, V);\n    end Set_Elaboration_Entity_Required;\n \n+   procedure Set_Encapsulating_State (Id : E; V : E) is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Abstract_State, E_Variable));\n+      Set_Node10 (Id, V);\n+   end Set_Encapsulating_State;\n+\n    procedure Set_Enclosing_Scope (Id : E; V : E) is\n    begin\n       Set_Node18 (Id, V);\n@@ -5352,6 +5365,12 @@ package body Einfo is\n       Set_Node19 (Id, V);\n    end Set_Parent_Subtype;\n \n+   procedure Set_Part_Of_Constituents (Id : E; V : L) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Abstract_State);\n+      Set_Elist9 (Id, V);\n+   end Set_Part_Of_Constituents;\n+\n    procedure Set_Postcondition_Proc (Id : E; V : E) is\n    begin\n       pragma Assert (Ekind (Id) = E_Procedure);\n@@ -5435,12 +5454,6 @@ package body Einfo is\n       Set_Flag227 (Id, V);\n    end Set_Referenced_As_Out_Parameter;\n \n-   procedure Set_Refined_State (Id : E; V : E) is\n-   begin\n-      pragma Assert (Ekind_In (Id, E_Abstract_State, E_Variable));\n-      Set_Node10 (Id, V);\n-   end Set_Refined_State;\n-\n    procedure Set_Refinement_Constituents (Id : E; V : L) is\n    begin\n       pragma Assert (Ekind (Id) = E_Abstract_State);\n@@ -6445,6 +6458,7 @@ package body Einfo is\n                   Id = Pragma_Global            or else\n                   Id = Pragma_Initial_Condition or else\n                   Id = Pragma_Initializes       or else\n+                  Id = Pragma_Part_Of           or else\n                   Id = Pragma_Refined_Depends   or else\n                   Id = Pragma_Refined_Global    or else\n                   Id = Pragma_Refined_State;\n@@ -8535,6 +8549,9 @@ package body Einfo is\n          when Object_Kind                                  =>\n             Write_Str (\"Current_Value\");\n \n+         when E_Abstract_State                             =>\n+            Write_Str (\"Part_Of_Constituents\");\n+\n          when E_Function                                   |\n               E_Generic_Function                           |\n               E_Generic_Package                            |\n@@ -8555,6 +8572,10 @@ package body Einfo is\n    procedure Write_Field10_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Abstract_State                             |\n+              E_Variable                                   =>\n+            Write_Str (\"Encapsulating_State\");\n+\n          when Class_Wide_Kind                              |\n               Incomplete_Kind                              |\n               E_Record_Type                                |\n@@ -8580,10 +8601,6 @@ package body Einfo is\n               E_Discriminant                               =>\n             Write_Str (\"Normalized_Position_Max\");\n \n-         when E_Abstract_State                             |\n-              E_Variable                                   =>\n-            Write_Str (\"Refined_State\");\n-\n          when others                                       =>\n             Write_Str (\"Field10??\");\n       end case;"}, {"sha": "538af8ae56e8167f60dc779e4e0e01e2338b3157", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -976,6 +976,10 @@ package Einfo is\n --       then if there is no other elaboration code, obviously there is no\n --       need to set the flag.\n \n+--    Encapsulating_State (Node10)\n+--       Defined in abstract states and variables. Contains the entity of an\n+--       ancestor state whose refinement utilizes this item as a constituent.\n+\n --    Enclosing_Scope (Node18)\n --       Defined in labels. Denotes the innermost enclosing construct that\n --       contains the label. Identical to the scope of the label, except for\n@@ -3435,6 +3439,10 @@ package Einfo is\n --       case it points to the subtype of the parent type. This is the type\n --       that is used as the Etype of the _parent field.\n \n+--    Part_Of_Constituents (Elist9)\n+--       Present in abstract state entities. Contains all constituents that are\n+--       subject to indicator Part_Of (both aspect and option variants).\n+\n --    Postcondition_Proc (Node8)\n --       Defined only in procedure entities, saves the entity of the generated\n --       postcondition proc if one is present, otherwise is set to Empty. Used\n@@ -3549,10 +3557,6 @@ package Einfo is\n --       we have a separate warning for variables that are only assigned and\n --       never read, and out parameters are a special case.\n \n---    Refined_State (Node10)\n---       Defined in abstract states and variables. Contains the entity of an\n---       ancestor state whose refinement mentions this item.\n-\n --    Refinement_Constituents (Elist8)\n --       Present in abstract state entities. Contains all the constituents that\n --       refine the state, in other words, all the hidden states that appear in\n@@ -5146,7 +5150,8 @@ package Einfo is\n \n    --  E_Abstract_State\n    --    Refinement_Constituents             (Elist8)\n-   --    Refined_State                       (Node10)\n+   --    Part_Of_Constituents                (Elist9)\n+   --    Encapsulating_State                 (Node10)\n    --    Body_References                     (Elist16)\n    --    Non_Limited_View                    (Node17)\n    --    From_Limited_With                   (Flag159)\n@@ -5982,7 +5987,7 @@ package Einfo is\n    --  E_Variable\n    --    Hiding_Loop_Variable                (Node8)\n    --    Current_Value                       (Node9)\n-   --    Refined_State                       (Node10)\n+   --    Encapsulating_State                 (Node10)\n    --    Esize                               (Uint12)\n    --    Extra_Accessibility                 (Node13)\n    --    Alignment                           (Uint14)\n@@ -6328,6 +6333,7 @@ package Einfo is\n    function Elaborate_Body_Desirable            (Id : E) return B;\n    function Elaboration_Entity                  (Id : E) return E;\n    function Elaboration_Entity_Required         (Id : E) return B;\n+   function Encapsulating_State                 (Id : E) return E;\n    function Enclosing_Scope                     (Id : E) return E;\n    function Entry_Accepted                      (Id : E) return B;\n    function Entry_Bodies_Array                  (Id : E) return E;\n@@ -6604,6 +6610,7 @@ package Einfo is\n    function Package_Instantiation               (Id : E) return N;\n    function Packed_Array_Type                   (Id : E) return E;\n    function Parent_Subtype                      (Id : E) return E;\n+   function Part_Of_Constituents                (Id : E) return L;\n    function Postcondition_Proc                  (Id : E) return E;\n    function Prival                              (Id : E) return E;\n    function Prival_Link                         (Id : E) return E;\n@@ -6617,7 +6624,6 @@ package Einfo is\n    function Referenced                          (Id : E) return B;\n    function Referenced_As_LHS                   (Id : E) return B;\n    function Referenced_As_Out_Parameter         (Id : E) return B;\n-   function Refined_State                       (Id : E) return E;\n    function Refinement_Constituents             (Id : E) return L;\n    function Register_Exception_Call             (Id : E) return N;\n    function Related_Array_Object                (Id : E) return E;\n@@ -6949,6 +6955,7 @@ package Einfo is\n    procedure Set_Elaborate_Body_Desirable        (Id : E; V : B := True);\n    procedure Set_Elaboration_Entity              (Id : E; V : E);\n    procedure Set_Elaboration_Entity_Required     (Id : E; V : B := True);\n+   procedure Set_Encapsulating_State             (Id : E; V : E);\n    procedure Set_Enclosing_Scope                 (Id : E; V : E);\n    procedure Set_Entry_Accepted                  (Id : E; V : B := True);\n    procedure Set_Entry_Bodies_Array              (Id : E; V : E);\n@@ -7228,6 +7235,7 @@ package Einfo is\n    procedure Set_Package_Instantiation           (Id : E; V : N);\n    procedure Set_Packed_Array_Type               (Id : E; V : E);\n    procedure Set_Parent_Subtype                  (Id : E; V : E);\n+   procedure Set_Part_Of_Constituents            (Id : E; V : L);\n    procedure Set_Postcondition_Proc              (Id : E; V : E);\n    procedure Set_Prival                          (Id : E; V : E);\n    procedure Set_Prival_Link                     (Id : E; V : E);\n@@ -7241,7 +7249,6 @@ package Einfo is\n    procedure Set_Referenced                      (Id : E; V : B := True);\n    procedure Set_Referenced_As_LHS               (Id : E; V : B := True);\n    procedure Set_Referenced_As_Out_Parameter     (Id : E; V : B := True);\n-   procedure Set_Refined_State                   (Id : E; V : E);\n    procedure Set_Refinement_Constituents         (Id : E; V : L);\n    procedure Set_Register_Exception_Call         (Id : E; V : N);\n    procedure Set_Related_Array_Object            (Id : E; V : E);\n@@ -7504,6 +7511,7 @@ package Einfo is\n    --    Global\n    --    Initial_Condition\n    --    Initializes\n+   --    Part_Of\n    --    Precondition\n    --    Postcondition\n    --    Refined_Depends\n@@ -7680,6 +7688,7 @@ package Einfo is\n    pragma Inline (Elaborate_Body_Desirable);\n    pragma Inline (Elaboration_Entity);\n    pragma Inline (Elaboration_Entity_Required);\n+   pragma Inline (Encapsulating_State);\n    pragma Inline (Enclosing_Scope);\n    pragma Inline (Entry_Accepted);\n    pragma Inline (Entry_Bodies_Array);\n@@ -8000,6 +8009,7 @@ package Einfo is\n    pragma Inline (Packed_Array_Type);\n    pragma Inline (Parameter_Mode);\n    pragma Inline (Parent_Subtype);\n+   pragma Inline (Part_Of_Constituents);\n    pragma Inline (Postcondition_Proc);\n    pragma Inline (Prival);\n    pragma Inline (Prival_Link);\n@@ -8013,7 +8023,6 @@ package Einfo is\n    pragma Inline (Referenced);\n    pragma Inline (Referenced_As_LHS);\n    pragma Inline (Referenced_As_Out_Parameter);\n-   pragma Inline (Refined_State);\n    pragma Inline (Refinement_Constituents);\n    pragma Inline (Register_Exception_Call);\n    pragma Inline (Related_Array_Object);\n@@ -8149,6 +8158,7 @@ package Einfo is\n    pragma Inline (Set_Elaborate_Body_Desirable);\n    pragma Inline (Set_Elaboration_Entity);\n    pragma Inline (Set_Elaboration_Entity_Required);\n+   pragma Inline (Set_Encapsulating_State);\n    pragma Inline (Set_Enclosing_Scope);\n    pragma Inline (Set_Entry_Accepted);\n    pragma Inline (Set_Entry_Bodies_Array);\n@@ -8424,6 +8434,7 @@ package Einfo is\n    pragma Inline (Set_Package_Instantiation);\n    pragma Inline (Set_Packed_Array_Type);\n    pragma Inline (Set_Parent_Subtype);\n+   pragma Inline (Set_Part_Of_Constituents);\n    pragma Inline (Set_Postcondition_Proc);\n    pragma Inline (Set_Prival);\n    pragma Inline (Set_Prival_Link);\n@@ -8437,7 +8448,6 @@ package Einfo is\n    pragma Inline (Set_Referenced);\n    pragma Inline (Set_Referenced_As_LHS);\n    pragma Inline (Set_Referenced_As_Out_Parameter);\n-   pragma Inline (Set_Refined_State);\n    pragma Inline (Set_Refinement_Constituents);\n    pragma Inline (Set_Register_Exception_Call);\n    pragma Inline (Set_Related_Array_Object);"}, {"sha": "5b2f4487ffbf747f1d4e8fc2fdba5c9ecd1732c9", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -1236,6 +1236,7 @@ begin\n            Pragma_Overflow_Mode                  |\n            Pragma_Overriding_Renamings           |\n            Pragma_Pack                           |\n+           Pragma_Part_Of                        |\n            Pragma_Partition_Elaboration_Policy   |\n            Pragma_Passive                        |\n            Pragma_Preelaborable_Initialization   |"}, {"sha": "cedcab7b7948f89bbe66a4a3c4fce30789c5d54d", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -5532,8 +5532,9 @@ package body Sem_Ch10 is\n          Set_Ekind                   (Ent, E_Abstract_State);\n          Set_Etype                   (Ent, Standard_Void_Type);\n          Set_Scope                   (Ent, Scop);\n-         Set_Refined_State           (Ent, Empty);\n+         Set_Encapsulating_State     (Ent, Empty);\n          Set_Refinement_Constituents (Ent, New_Elmt_List);\n+         Set_Part_Of_Constituents    (Ent, New_Elmt_List);\n       end Decorate_State;\n \n       -------------------"}, {"sha": "68a6e354587d8399252e26bb1327db04362c3528", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 58, "deletions": 26, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -1140,33 +1140,35 @@ package body Sem_Ch13 is\n    -----------------------------------\n \n    procedure Analyze_Aspect_Specifications (N : Node_Id; E : Entity_Id) is\n-      procedure Decorate_Delayed_Aspect_And_Pragma\n-        (Asp  : Node_Id;\n-         Prag : Node_Id);\n-      --  Establish the linkages between a delayed aspect and its corresponding\n-      --  pragma. Set all delay-related flags on both constructs.\n+      procedure Decorate_Aspect_And_Pragma\n+        (Asp     : Node_Id;\n+         Prag    : Node_Id;\n+         Delayed : Boolean := False);\n+      --  Establish the linkages between an aspect and its corresponding\n+      --  pragma. Flag Delayed should be set when both constructs are delayed.\n \n       procedure Insert_Delayed_Pragma (Prag : Node_Id);\n       --  Insert a postcondition-like pragma into the tree depending on the\n       --  context. Prag must denote one of the following: Pre, Post, Depends,\n       --  Global or Contract_Cases.\n \n-      ----------------------------------------\n-      -- Decorate_Delayed_Aspect_And_Pragma --\n-      ----------------------------------------\n+      --------------------------------\n+      -- Decorate_Aspect_And_Pragma --\n+      --------------------------------\n \n-      procedure Decorate_Delayed_Aspect_And_Pragma\n-        (Asp  : Node_Id;\n-         Prag : Node_Id)\n+      procedure Decorate_Aspect_And_Pragma\n+        (Asp     : Node_Id;\n+         Prag    : Node_Id;\n+         Delayed : Boolean := False)\n       is\n       begin\n-         Set_Aspect_Rep_Item           (Asp, Prag);\n+         Set_Aspect_Rep_Item           (Asp,  Prag);\n          Set_Corresponding_Aspect      (Prag, Asp);\n          Set_From_Aspect_Specification (Prag);\n-         Set_Is_Delayed_Aspect         (Prag);\n-         Set_Is_Delayed_Aspect         (Asp);\n+         Set_Is_Delayed_Aspect         (Prag, Delayed);\n+         Set_Is_Delayed_Aspect         (Asp,  Delayed);\n          Set_Parent                    (Prag, Asp);\n-      end Decorate_Delayed_Aspect_And_Pragma;\n+      end Decorate_Aspect_And_Pragma;\n \n       ---------------------------\n       -- Insert_Delayed_Pragma --\n@@ -2004,7 +2006,7 @@ package body Sem_Ch13 is\n                           Make_Pragma_Argument_Association (Loc,\n                             Expression => Relocate_Node (Expr))),\n                         Pragma_Name                  => Name_Abstract_State);\n-                     Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n+                     Decorate_Aspect_And_Pragma (Aspect, Aitem);\n \n                      if No (Decls) then\n                         Decls := New_List;\n@@ -2036,7 +2038,8 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Depends);\n \n-                  Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n+                  Decorate_Aspect_And_Pragma\n+                    (Aspect, Aitem, Delayed => True);\n                   Insert_Delayed_Pragma (Aitem);\n                   goto Continue;\n \n@@ -2054,7 +2057,8 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Global);\n \n-                  Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n+                  Decorate_Aspect_And_Pragma\n+                    (Aspect, Aitem, Delayed => True);\n                   Insert_Delayed_Pragma (Aitem);\n                   goto Continue;\n \n@@ -2079,7 +2083,9 @@ package body Sem_Ch13 is\n                             Expression => Relocate_Node (Expr))),\n                         Pragma_Name                  =>\n                           Name_Initial_Condition);\n-                     Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n+\n+                     Decorate_Aspect_And_Pragma\n+                       (Aspect, Aitem, Delayed => True);\n \n                      if No (Decls) then\n                         Decls := New_List;\n@@ -2117,7 +2123,9 @@ package body Sem_Ch13 is\n                           Make_Pragma_Argument_Association (Loc,\n                             Expression => Relocate_Node (Expr))),\n                         Pragma_Name                  => Name_Initializes);\n-                     Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n+\n+                     Decorate_Aspect_And_Pragma\n+                       (Aspect, Aitem, Delayed => True);\n \n                      if No (Decls) then\n                         Decls := New_List;\n@@ -2135,6 +2143,24 @@ package body Sem_Ch13 is\n                   goto Continue;\n                end Initializes;\n \n+               --  Part_Of\n+\n+               when Aspect_Part_Of =>\n+                  if Nkind_In (N, N_Object_Declaration,\n+                                  N_Package_Instantiation)\n+                  then\n+                     Make_Aitem_Pragma\n+                       (Pragma_Argument_Associations => New_List (\n+                          Make_Pragma_Argument_Association (Loc,\n+                            Expression => Relocate_Node (Expr))),\n+                        Pragma_Name                  => Name_Part_Of);\n+\n+                  else\n+                     Error_Msg_NE\n+                       (\"aspect & must apply to a variable or package \"\n+                        & \"instantiation\", Aspect, Id);\n+                  end if;\n+\n                --  SPARK_Mode\n \n                when Aspect_SPARK_Mode => SPARK_Mode : declare\n@@ -2152,7 +2178,8 @@ package body Sem_Ch13 is\n                   --  emulate the behavior of a source pragma.\n \n                   if Nkind (N) = N_Package_Body then\n-                     Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n+                     Decorate_Aspect_And_Pragma (Aspect, Aitem);\n+\n                      Decls := Declarations (N);\n \n                      if No (Decls) then\n@@ -2168,7 +2195,8 @@ package body Sem_Ch13 is\n                   --  declarations to emulate the behavior of a source pragma.\n \n                   elsif Nkind (N) = N_Package_Declaration then\n-                     Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n+                     Decorate_Aspect_And_Pragma (Aspect, Aitem);\n+\n                      Decls := Visible_Declarations (Specification (N));\n \n                      if No (Decls) then\n@@ -2195,7 +2223,8 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Refined_Depends);\n \n-                  Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n+                  Decorate_Aspect_And_Pragma\n+                    (Aspect, Aitem, Delayed => True);\n                   Insert_Delayed_Pragma (Aitem);\n                   goto Continue;\n \n@@ -2213,7 +2242,8 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Refined_Global);\n \n-                  Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n+                  Decorate_Aspect_And_Pragma\n+                    (Aspect, Aitem, Delayed => True);\n                   Insert_Delayed_Pragma (Aitem);\n                   goto Continue;\n \n@@ -2245,7 +2275,7 @@ package body Sem_Ch13 is\n                           Make_Pragma_Argument_Association (Loc,\n                             Expression => Relocate_Node (Expr))),\n                         Pragma_Name                  => Name_Refined_State);\n-                     Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n+                     Decorate_Aspect_And_Pragma (Aspect, Aitem);\n \n                      if No (Decls) then\n                         Decls := New_List;\n@@ -2515,7 +2545,8 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Nam);\n \n-                  Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n+                  Decorate_Aspect_And_Pragma\n+                    (Aspect, Aitem, Delayed => True);\n                   Insert_Delayed_Pragma (Aitem);\n                   goto Continue;\n \n@@ -7989,6 +8020,7 @@ package body Sem_Ch13 is\n               Aspect_Implicit_Dereference |\n               Aspect_Initial_Condition    |\n               Aspect_Initializes          |\n+              Aspect_Part_Of              |\n               Aspect_Post                 |\n               Aspect_Postcondition        |\n               Aspect_Pre                  |"}, {"sha": "2cc3ea3e4d4e0ae6041d45baa7b8cd403a3e153a", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 40, "deletions": 153, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -99,6 +99,7 @@ package body Sem_Ch3 is\n    --    Async_Writers\n    --    Effective_Reads\n    --    Effective_Writes\n+   --    Part_Of\n \n    procedure Build_Derived_Type\n      (N             : Node_Id;\n@@ -2086,12 +2087,6 @@ package body Sem_Ch3 is\n       --  If the states have visible refinement, remove the visibility of each\n       --  constituent at the end of the package body declarations.\n \n-      function Requires_State_Refinement\n-        (Spec_Id : Entity_Id;\n-         Body_Id : Entity_Id) return Boolean;\n-      --  Determine whether a package denoted by its spec and body entities\n-      --  requires refinement of abstract states.\n-\n       -----------------\n       -- Adjust_Decl --\n       -----------------\n@@ -2185,89 +2180,11 @@ package body Sem_Ch3 is\n          end if;\n       end Remove_Visible_Refinements;\n \n-      -------------------------------\n-      -- Requires_State_Refinement --\n-      -------------------------------\n-\n-      function Requires_State_Refinement\n-        (Spec_Id : Entity_Id;\n-         Body_Id : Entity_Id) return Boolean\n-      is\n-         function Mode_Is_Off (Prag : Node_Id) return Boolean;\n-         --  Given pragma SPARK_Mode, determine whether the mode is Off\n-\n-         -----------------\n-         -- Mode_Is_Off --\n-         -----------------\n-\n-         function Mode_Is_Off (Prag : Node_Id) return Boolean is\n-            Mode : Node_Id;\n-\n-         begin\n-            --  The default SPARK mode is On\n-\n-            if No (Prag) then\n-               return False;\n-            end if;\n-\n-            Mode :=\n-              Get_Pragma_Arg (First (Pragma_Argument_Associations (Prag)));\n-\n-            --  Then the pragma lacks an argument, the default mode is On\n-\n-            if No (Mode) then\n-               return False;\n-            else\n-               return Chars (Mode) = Name_Off;\n-            end if;\n-         end Mode_Is_Off;\n-\n-      --  Start of processing for Requires_State_Refinement\n-\n-      begin\n-         --  A package that does not define at least one abstract state cannot\n-         --  possibly require refinement.\n-\n-         if No (Abstract_States (Spec_Id)) then\n-            return False;\n-\n-         --  The package instroduces a single null state which does not merit\n-         --  refinement.\n-\n-         elsif Has_Null_Abstract_State (Spec_Id) then\n-            return False;\n-\n-         --  Check whether the package body is subject to pragma SPARK_Mode. If\n-         --  it is and the mode is Off, the package body is considered to be in\n-         --  regular Ada and does not require refinement.\n-\n-         elsif Mode_Is_Off (SPARK_Pragma (Body_Id)) then\n-            return False;\n-\n-         --  The body's SPARK_Mode may be inherited from a similar pragma that\n-         --  appears in the private declarations of the spec. The pragma we are\n-         --  interested appears as the second entry in SPARK_Pragma.\n-\n-         elsif Present (SPARK_Pragma (Spec_Id))\n-           and then Mode_Is_Off (Next_Pragma (SPARK_Pragma (Spec_Id)))\n-         then\n-            return False;\n-\n-         --  The spec defines at least one abstract state and the body has no\n-         --  way of circumventing the refinement.\n-\n-         else\n-            return True;\n-         end if;\n-      end Requires_State_Refinement;\n-\n       --  Local variables\n \n-      Body_Id     : Entity_Id;\n       Context     : Node_Id;\n       Freeze_From : Entity_Id := Empty;\n       Next_Decl   : Node_Id;\n-      Prag        : Node_Id;\n       Spec_Id     : Entity_Id;\n \n       Body_Seen : Boolean := False;\n@@ -2415,54 +2332,21 @@ package body Sem_Ch3 is\n          Decl := Next_Decl;\n       end loop;\n \n+      --  Analyze the contracts of packages and their bodies\n+\n       if Present (L) then\n          Context := Parent (L);\n \n-         --  Analyze pragmas Initializes and Initial_Condition of a package at\n-         --  the end of the visible declarations as the pragmas have visibility\n-         --  over the said region.\n-\n          if Nkind (Context) = N_Package_Specification\n            and then L = Visible_Declarations (Context)\n          then\n-            Spec_Id := Defining_Entity (Parent (Context));\n-            Prag    := Get_Pragma (Spec_Id, Pragma_Initializes);\n-\n-            if Present (Prag) then\n-               Analyze_Initializes_In_Decl_Part (Prag);\n-            end if;\n-\n-            Prag := Get_Pragma (Spec_Id, Pragma_Initial_Condition);\n-\n-            if Present (Prag) then\n-               Analyze_Initial_Condition_In_Decl_Part (Prag);\n-            end if;\n-\n-         --  Analyze the state refinements within a package body now, after\n-         --  all hidden states have been encountered and freely visible.\n-         --  Refinements must be processed before pragmas Refined_Depends and\n-         --  Refined_Global because the last two may mention constituents.\n+            Analyze_Package_Contract (Defining_Entity (Context));\n \n          elsif Nkind (Context) = N_Package_Body then\n             In_Package_Body := True;\n-\n-            Body_Id := Defining_Entity (Context);\n             Spec_Id := Corresponding_Spec (Context);\n-            Prag    := Get_Pragma (Body_Id, Pragma_Refined_State);\n-\n-            --  The analysis of pragma Refined_State detects whether the spec\n-            --  has abstract states available for refinement.\n-\n-            if Present (Prag) then\n-               Analyze_Refined_State_In_Decl_Part (Prag);\n-\n-            --  State refinement is required when the package declaration has\n-            --  abstract states. Null states are not considered.\n \n-            elsif Requires_State_Refinement (Spec_Id, Body_Id) then\n-               Error_Msg_NE\n-                 (\"package & requires state refinement\", Context, Spec_Id);\n-            end if;\n+            Analyze_Package_Body_Contract (Defining_Entity (Context));\n          end if;\n       end if;\n \n@@ -2472,14 +2356,14 @@ package body Sem_Ch3 is\n \n       Decl := First (L);\n       while Present (Decl) loop\n-         if Nkind (Decl) = N_Subprogram_Body then\n+         if Nkind (Decl) = N_Object_Declaration then\n+            Analyze_Object_Contract (Defining_Entity (Decl));\n+\n+         elsif Nkind (Decl) = N_Subprogram_Body then\n             Analyze_Subprogram_Body_Contract (Defining_Entity (Decl));\n \n          elsif Nkind (Decl) = N_Subprogram_Declaration then\n             Analyze_Subprogram_Contract (Defining_Entity (Decl));\n-\n-         elsif Nkind (Decl) = N_Object_Declaration then\n-            Analyze_Object_Contract (Defining_Entity (Decl));\n          end if;\n \n          Next (Decl);\n@@ -3078,8 +2962,6 @@ package body Sem_Ch3 is\n       AW_Val : Boolean := False;\n       ER_Val : Boolean := False;\n       EW_Val : Boolean := False;\n-      Items  : Node_Id;\n-      Nam    : Name_Id;\n       Prag   : Node_Id;\n       Seen   : Boolean := False;\n \n@@ -3127,45 +3009,50 @@ package body Sem_Ch3 is\n             end if;\n          end if;\n \n-         --  Examine the contract\n+         --  Analyze all external properties\n \n-         Items := Contract (Obj_Id);\n+         Prag := Get_Pragma (Obj_Id, Pragma_Async_Readers);\n \n-         if Present (Items) then\n-\n-            --  Analyze classification pragmas\n+         if Present (Prag) then\n+            Analyze_External_Property_In_Decl_Part (Prag, AR_Val);\n+            Seen := True;\n+         end if;\n \n-            Prag := Classifications (Items);\n-            while Present (Prag) loop\n-               Nam := Pragma_Name (Prag);\n+         Prag := Get_Pragma (Obj_Id, Pragma_Async_Writers);\n \n-               if Nam = Name_Async_Readers then\n-                  Analyze_External_Property_In_Decl_Part (Prag, AR_Val);\n-                  Seen := True;\n+         if Present (Prag) then\n+            Analyze_External_Property_In_Decl_Part (Prag, AW_Val);\n+            Seen := True;\n+         end if;\n \n-               elsif Nam = Name_Async_Writers then\n-                  Analyze_External_Property_In_Decl_Part (Prag, AW_Val);\n-                  Seen := True;\n+         Prag := Get_Pragma (Obj_Id, Pragma_Effective_Reads);\n \n-               elsif Nam = Name_Effective_Reads then\n-                  Analyze_External_Property_In_Decl_Part (Prag, ER_Val);\n-                  Seen := True;\n+         if Present (Prag) then\n+            Analyze_External_Property_In_Decl_Part (Prag, ER_Val);\n+            Seen := True;\n+         end if;\n \n-               else pragma Assert (Nam = Name_Effective_Writes);\n-                  Analyze_External_Property_In_Decl_Part (Prag, EW_Val);\n-                  Seen := True;\n-               end if;\n+         Prag := Get_Pragma (Obj_Id, Pragma_Effective_Writes);\n \n-               Prag := Next_Pragma (Prag);\n-            end loop;\n+         if Present (Prag) then\n+            Analyze_External_Property_In_Decl_Part (Prag, EW_Val);\n+            Seen := True;\n          end if;\n \n-         --  Once all external properties have been processed, verify their\n-         --  mutual interaction.\n+         --  Verify the mutual interaction of the various external properties\n \n          if Seen then\n             Check_External_Properties (Obj_Id, AR_Val, AW_Val, ER_Val, EW_Val);\n          end if;\n+\n+         --  Check whether the lack of indicator Part_Of agrees with the\n+         --  placement of the variable with respect to the state space.\n+\n+         Prag := Get_Pragma (Obj_Id, Pragma_Part_Of);\n+\n+         if No (Prag) then\n+            Check_Missing_Part_Of (Obj_Id);\n+         end if;\n       end if;\n    end Analyze_Object_Contract;\n \n@@ -4117,7 +4004,7 @@ package body Sem_Ch3 is\n       --  common destination for legal and illegal object declarations.\n \n       if Ekind (Id) = E_Variable then\n-         Set_Refined_State (Id, Empty);\n+         Set_Encapsulating_State (Id, Empty);\n       end if;\n \n       if Has_Aspects (N) then"}, {"sha": "4b3b613e8da7a6e22dcc94d0404cb93915356977", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 61, "deletions": 2, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -174,6 +174,31 @@ package body Sem_Ch7 is\n       end if;\n    end Analyze_Package_Body;\n \n+   -----------------------------------\n+   -- Analyze_Package_Body_Contract --\n+   -----------------------------------\n+\n+   procedure Analyze_Package_Body_Contract (Body_Id : Entity_Id) is\n+      Spec_Id : constant Entity_Id := Spec_Entity (Body_Id);\n+      Prag    : Node_Id;\n+\n+   begin\n+      Prag := Get_Pragma (Body_Id, Pragma_Refined_State);\n+\n+      --  The analysis of pragma Refined_State detects whether the spec has\n+      --  abstract states available for refinement.\n+\n+      if Present (Prag) then\n+         Analyze_Refined_State_In_Decl_Part (Prag);\n+\n+      --  State refinement is required when the package declaration has\n+      --  abstract states. Null states are not considered.\n+\n+      elsif Requires_State_Refinement (Spec_Id, Body_Id) then\n+         Error_Msg_N (\"package & requires state refinement\", Spec_Id);\n+      end if;\n+   end Analyze_Package_Body_Contract;\n+\n    ---------------------------------\n    -- Analyze_Package_Body_Helper --\n    ---------------------------------\n@@ -801,6 +826,41 @@ package body Sem_Ch7 is\n       end if;\n    end Analyze_Package_Body_Helper;\n \n+   ------------------------------\n+   -- Analyze_Package_Contract --\n+   ------------------------------\n+\n+   procedure Analyze_Package_Contract (Pack_Id : Entity_Id) is\n+      Prag : Node_Id;\n+\n+   begin\n+      --  Analyze the initialization related pragmas. Initializes must come\n+      --  before Initial_Condition due to item dependencies.\n+\n+      Prag := Get_Pragma (Pack_Id, Pragma_Initializes);\n+\n+      if Present (Prag) then\n+         Analyze_Initializes_In_Decl_Part (Prag);\n+      end if;\n+\n+      Prag := Get_Pragma (Pack_Id, Pragma_Initial_Condition);\n+\n+      if Present (Prag) then\n+         Analyze_Initial_Condition_In_Decl_Part (Prag);\n+      end if;\n+\n+      --  Check whether the lack of indicator Part_Of agrees with the placement\n+      --  of the package instantiation with respect to the state space.\n+\n+      if Is_Generic_Instance (Pack_Id) then\n+         Prag := Get_Pragma (Pack_Id, Pragma_Part_Of);\n+\n+         if No (Prag) then\n+            Check_Missing_Part_Of (Pack_Id);\n+         end if;\n+      end if;\n+   end Analyze_Package_Contract;\n+\n    ---------------------------------\n    -- Analyze_Package_Declaration --\n    ---------------------------------\n@@ -2850,8 +2910,7 @@ package body Sem_Ch7 is\n           not Is_Null_State (Node (First_Elmt (Abstract_States (P))))\n       then\n          Error_Msg_N\n-           (\"?Y?info: & requires body (non-null abstract state aspect)\",\n-            P);\n+           (\"?Y?info: & requires body (non-null abstract state aspect)\", P);\n       end if;\n \n       --  Otherwise search entity chain for entity requiring completion"}, {"sha": "2ee0c9ebbb39a42f7d5ec772c6352c156dafc652", "filename": "gcc/ada/sem_ch7.ads", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsem_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsem_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.ads?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -32,6 +32,20 @@ package Sem_Ch7 is\n    procedure Analyze_Package_Specification              (N : Node_Id);\n    procedure Analyze_Private_Type_Declaration           (N : Node_Id);\n \n+   procedure Analyze_Package_Body_Contract (Body_Id : Entity_Id);\n+   --  Analyze all delayed aspects chained on the contract of package body\n+   --  Body_Id as if they appeared at the end of a declarative region. The\n+   --  aspects in consideration are:\n+   --    Refined_State\n+\n+   procedure Analyze_Package_Contract (Pack_Id : Entity_Id);\n+   --  Analyze all delayed aspects chained on the contract of package Pack_Id\n+   --  as if they appeared at the end of a declarative region. The aspects in\n+   --  consideration are:\n+   --    Initial_Condition\n+   --    Initializes\n+   --    Part_Of\n+\n    procedure End_Package_Scope (P : Entity_Id);\n    --  Calls Uninstall_Declarations, and then pops the scope stack\n "}, {"sha": "d976438b854e130d143357acd8cf426e68e18085", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 988, "deletions": 369, "changes": 1357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -203,6 +203,15 @@ package body Sem_Prag is\n    --  _Post, _Invariant, or _Type_Invariant, which are special names used\n    --  in identifiers to represent these attribute references.\n \n+   procedure Check_State_And_Constituent_Use\n+     (States   : Elist_Id;\n+      Constits : Elist_Id;\n+      Context  : Node_Id);\n+   --  Subsidiary to the analysis of pragmas [Refined_]Depends, [Refined_]\n+   --  Global and Initializes. Determine whether a state from list States and a\n+   --  corresponding constituent from list Constits (if any) appear in the same\n+   --  context denoted by Context. If this is the case, emit an error.\n+\n    procedure Collect_Global_Items\n      (Prag               : Node_Id;\n       In_Items           : in out Elist_Id;\n@@ -259,14 +268,6 @@ package body Sem_Prag is\n    --  Get_SPARK_Mode_Type. Convert a name into a corresponding value of type\n    --  SPARK_Mode_Type.\n \n-   function Is_Part_Of\n-     (State    : Entity_Id;\n-      Ancestor : Entity_Id) return Boolean;\n-   --  Subsidiary to the processing of pragma Refined_Depends and pragma\n-   --  Refined_Global. Determine whether abstract state State is part of an\n-   --  ancestor abstract state Ancestor. For this relationship to hold, State\n-   --  must have option Part_Of in its Abstract_State definition.\n-\n    function Is_Unconstrained_Or_Tagged_Item (Item : Entity_Id) return Boolean;\n    --  Subsidiary to Collect_Subprogram_Inputs_Outputs and the analysis of\n    --  pragma Depends. Determine whether the type of dependency item Item is\n@@ -502,6 +503,11 @@ package body Sem_Prag is\n       --  The list is populated with unique entities because output items are\n       --  unique in a dependence relation.\n \n+      Constits_Seen : Elist_Id := No_Elist;\n+      --  A list containing the entities of all constituents processed so far.\n+      --  It aids in detecting illegal usage of a state and a corresponding\n+      --  constituent in pragma [Refinde_]Depends.\n+\n       Global_Seen : Boolean := False;\n       --  A flag set when pragma Global has been processed\n \n@@ -514,6 +520,11 @@ package body Sem_Prag is\n       Spec_Id : Entity_Id;\n       --  The entity of the subprogram subject to pragma [Refined_]Depends\n \n+      States_Seen : Elist_Id := No_Elist;\n+      --  A list containing the entities of all states processed so far. It\n+      --  helps in detecting illegal usage of a state and a corresponding\n+      --  constituent in pragma [Refined_]Depends.\n+\n       Subp_Id : Entity_Id;\n       --  The entity of the subprogram [body or stub] subject to pragma\n       --  [Refined_]Depends.\n@@ -831,35 +842,14 @@ package body Sem_Prag is\n                         Add_Item (Item_Id, All_Inputs_Seen);\n                      end if;\n \n-                     if Ekind (Item_Id) = E_Abstract_State then\n-\n-                        --  The state acts as a constituent of some other\n-                        --  state. Ensure that the other state is a proper\n-                        --  ancestor of the item.\n-\n-                        if Present (Refined_State (Item_Id)) then\n-                           if not Is_Part_Of\n-                                    (Item_Id, Refined_State (Item_Id))\n-                           then\n-                              Error_Msg_Name_1 :=\n-                                Chars (Refined_State (Item_Id));\n-                              Error_Msg_NE\n-                                (\"state & is not a valid constituent of \"\n-                                 & \"ancestor state %\", Item, Item_Id);\n-                              return;\n-                           end if;\n-\n-                        --  An abstract state with visible refinement cannot\n-                        --  appear in pragma [Refined_]Global as its place must\n-                        --  be taken by some of its constituents.\n-\n-                        elsif Has_Visible_Refinement (Item_Id) then\n-                           Error_Msg_NE\n-                             (\"cannot mention state & in global refinement, \"\n-                              & \"use its constituents instead (SPARK RM \"\n-                              & \"6.1.5(3))\", Item, Item_Id);\n-                           return;\n-                        end if;\n+                     if Ekind (Item_Id) = E_Abstract_State\n+                       and then Has_Visible_Refinement (Item_Id)\n+                     then\n+                        Error_Msg_NE\n+                          (\"cannot mention state & in global refinement, use \"\n+                           & \"its constituents instead (SPARK RM 6.1.5(3))\",\n+                           Item, Item_Id);\n+                        return;\n                      end if;\n \n                      --  When the item renames an entire object, replace the\n@@ -871,6 +861,19 @@ package body Sem_Prag is\n                         Analyze (Item);\n                      end if;\n \n+                     --  Add the entity of the current item to the list of\n+                     --  processed items.\n+\n+                     if Ekind (Item_Id) = E_Abstract_State then\n+                        Add_Item (Item_Id, States_Seen);\n+                     end if;\n+\n+                     if Ekind_In (Item_Id, E_Abstract_State, E_Variable)\n+                       and then Present (Encapsulating_State (Item_Id))\n+                     then\n+                        Add_Item (Item_Id, Constits_Seen);\n+                     end if;\n+\n                   --  All other input/output items are illegal\n \n                   else\n@@ -1703,6 +1706,14 @@ package body Sem_Prag is\n       else\n          Error_Msg_N (\"malformed dependency relation\", Clause);\n       end if;\n+\n+      --  Ensure that a state and a corresponding constituent do not appear\n+      --  together in pragma [Refined_]Depends.\n+\n+      Check_State_And_Constituent_Use\n+        (States   => States_Seen,\n+         Constits => Constits_Seen,\n+         Context  => N);\n    end Analyze_Depends_In_Decl_Part;\n \n    --------------------------------------------\n@@ -1761,13 +1772,23 @@ package body Sem_Prag is\n    ---------------------------------\n \n    procedure Analyze_Global_In_Decl_Part (N : Node_Id) is\n+      Constits_Seen : Elist_Id := No_Elist;\n+      --  A list containing the entities of all constituents processed so far.\n+      --  It aids in detecting illegal usage of a state and a corresponding\n+      --  constituent in pragma [Refinde_]Global.\n+\n       Seen : Elist_Id := No_Elist;\n       --  A list containing the entities of all the items processed so far. It\n       --  plays a role in detecting distinct entities.\n \n       Spec_Id : Entity_Id;\n       --  The entity of the subprogram subject to pragma [Refined_]Global\n \n+      States_Seen : Elist_Id := No_Elist;\n+      --  A list containing the entities of all states processed so far. It\n+      --  helps in detecting illegal usage of a state and a corresponding\n+      --  constituent in pragma [Refined_]Global.\n+\n       Subp_Id : Entity_Id;\n       --  The entity of the subprogram [body or stub] subject to pragma\n       --  [Refined_]Global.\n@@ -1886,24 +1907,11 @@ package body Sem_Prag is\n \n                if Ekind (Item_Id) = E_Abstract_State then\n \n-                  --  The state acts as a constituent of some other state.\n-                  --  Ensure that the other state is a proper ancestor of the\n-                  --  item.\n-\n-                  if Present (Refined_State (Item_Id)) then\n-                     if not Is_Part_Of (Item_Id, Refined_State (Item_Id)) then\n-                        Error_Msg_Name_1 := Chars (Refined_State (Item_Id));\n-                        Error_Msg_NE\n-                          (\"state & is not a valid constituent of ancestor \"\n-                           & \"state %\", Item, Item_Id);\n-                        return;\n-                     end if;\n-\n                   --  An abstract state with visible refinement cannot appear\n                   --  in pragma [Refined_]Global as its place must be taken by\n                   --  some of its constituents.\n \n-                  elsif Has_Visible_Refinement (Item_Id) then\n+                  if Has_Visible_Refinement (Item_Id) then\n                      Error_Msg_NE\n                        (\"cannot mention state & in global refinement, use its \"\n                         & \"constituents instead (SPARK RM 6.1.4(8))\",\n@@ -1978,6 +1986,16 @@ package body Sem_Prag is\n \n             else\n                Add_Item (Item_Id, Seen);\n+\n+               if Ekind (Item_Id) = E_Abstract_State then\n+                  Add_Item (Item_Id, States_Seen);\n+               end if;\n+\n+               if Ekind_In (Item_Id, E_Abstract_State, E_Variable)\n+                 and then Present (Encapsulating_State (Item_Id))\n+               then\n+                  Add_Item (Item_Id, Constits_Seen);\n+               end if;\n             end if;\n          end Analyze_Global_Item;\n \n@@ -2227,6 +2245,14 @@ package body Sem_Prag is\n             End_Scope;\n          end if;\n       end if;\n+\n+      --  Ensure that a state and a corresponding constituent do not appear\n+      --  together in pragma [Refined_]Global.\n+\n+      Check_State_And_Constituent_Use\n+        (States   => States_Seen,\n+         Constits => Constits_Seen,\n+         Context  => N);\n    end Analyze_Global_In_Decl_Part;\n \n    --------------------------------------------\n@@ -2425,6 +2451,11 @@ package body Sem_Prag is\n       Pack_Spec : constant Node_Id   := Parent (N);\n       Pack_Id   : constant Entity_Id := Defining_Entity (Parent (Pack_Spec));\n \n+      Constits_Seen : Elist_Id := No_Elist;\n+      --  A list containing the entities of all constituents processed so far.\n+      --  It aids in detecting illegal usage of a state and a corresponding\n+      --  constituent in pragma Initializes.\n+\n       Items_Seen : Elist_Id := No_Elist;\n       --  A list of all initialization items processed so far. This list is\n       --  used to detect duplicate items.\n@@ -2438,6 +2469,11 @@ package body Sem_Prag is\n       --  declarations of the related package. This list is used to detect the\n       --  legality of initialization items.\n \n+      States_Seen : Elist_Id := No_Elist;\n+      --  A list containing the entities of all states processed so far. It\n+      --  helps in detecting illegal usage of a state and a corresponding\n+      --  constituent in pragma Initializes.\n+\n       procedure Analyze_Initialization_Item (Item : Node_Id);\n       --  Verify the legality of a single initialization item\n \n@@ -2510,6 +2546,14 @@ package body Sem_Prag is\n \n                   else\n                      Add_Item (Item_Id, Items_Seen);\n+\n+                     if Ekind (Item_Id) = E_Abstract_State then\n+                        Add_Item (Item_Id, States_Seen);\n+                     end if;\n+\n+                     if Present (Encapsulating_State (Item_Id)) then\n+                        Add_Item (Item_Id, Constits_Seen);\n+                     end if;\n                   end if;\n \n                --  The item references something that is not a state or a\n@@ -2607,6 +2651,14 @@ package body Sem_Prag is\n \n                      else\n                         Add_Item (Input_Id, Inputs_Seen);\n+\n+                        if Ekind (Input_Id) = E_Abstract_State then\n+                           Add_Item (Input_Id, States_Seen);\n+                        end if;\n+\n+                        if Present (Encapsulating_State (Input_Id)) then\n+                           Add_Item (Input_Id, Constits_Seen);\n+                        end if;\n                      end if;\n \n                   --  The input references something that is not a state or a\n@@ -2749,6 +2801,14 @@ package body Sem_Prag is\n             Next (Init);\n          end loop;\n       end if;\n+\n+      --  Ensure that a state and a corresponding constituent do not appear\n+      --  together in pragma Initializes.\n+\n+      Check_State_And_Constituent_Use\n+        (States   => States_Seen,\n+         Constits => Constits_Seen,\n+         Context  => N);\n    end Analyze_Initializes_In_Decl_Part;\n \n    --------------------\n@@ -2794,6 +2854,17 @@ package body Sem_Prag is\n       --  In Ada 95 or 05 mode, these are implementation defined pragmas, so\n       --  should be caught by the No_Implementation_Pragmas restriction.\n \n+      procedure Analyze_Part_Of\n+        (Item_Id : Entity_Id;\n+         State   : Node_Id;\n+         Indic   : Node_Id;\n+         Legal   : out Boolean);\n+      --  Subsidiary to the analysis of pragmas Abstract_State and Part_Of.\n+      --  Perform full analysis of indicator Part_Of. Item_Id is the entity of\n+      --  an abstract state, variable or package instantiation. State is the\n+      --  encapsulating state. Indic is the Part_Of indicator. Flag Legal is\n+      --  set when the indicator is legal.\n+\n       procedure Analyze_Refined_Pragma\n         (Spec_Id : out Entity_Id;\n          Body_Id : out Entity_Id;\n@@ -3344,6 +3415,124 @@ package body Sem_Prag is\n          end if;\n       end Ada_2012_Pragma;\n \n+      ---------------------\n+      -- Analyze_Part_Of --\n+      ---------------------\n+\n+      procedure Analyze_Part_Of\n+        (Item_Id : Entity_Id;\n+         State   : Node_Id;\n+         Indic   : Node_Id;\n+         Legal   : out Boolean)\n+      is\n+         Pack_Id   : Entity_Id;\n+         Placement : State_Space_Kind;\n+         State_Id  : Entity_Id;\n+\n+      begin\n+         --  Assume that the pragma/option is illegal\n+\n+         Legal := False;\n+\n+         Analyze       (State);\n+         Resolve_State (State);\n+\n+         if Is_Entity_Name (State)\n+           and then Ekind (Entity (State)) = E_Abstract_State\n+         then\n+            State_Id := Entity (State);\n+\n+         else\n+            Error_Msg_N\n+              (\"indicator Part_Of must denote an abstract state\", State);\n+            return;\n+         end if;\n+\n+         --  Determine where the state, variable or the package instantiation\n+         --  lives with respect to the enclosing packages or package bodies (if\n+         --  any). This placement dictates the legality of the encapsulating\n+         --  state.\n+\n+         Find_Placement_In_State_Space\n+           (Item_Id   => Item_Id,\n+            Placement => Placement,\n+            Pack_Id   => Pack_Id);\n+\n+         --  The item appears in a non-package construct with a declarative\n+         --  part (subprogram, block, etc). As such, the item is not allowed\n+         --  to be a part of an encapsulating state because the item is not\n+         --  visible.\n+\n+         if Placement = Not_In_Package then\n+            Error_Msg_N\n+              (\"indicator Part_Of may not appear in this context (SPARK RM \"\n+               & \"7.2.6(5))\", Indic);\n+            Error_Msg_Name_1 := Chars (Scope (State_Id));\n+            Error_Msg_NE\n+              (\"\\& is not part of the hidden state of package %\",\n+               Indic, Item_Id);\n+\n+         --  The item appears in the visible state space of some package. In\n+         --  general this scenario does not warrant Part_Of except when the\n+         --  package is a private child unit and the encapsulating state is\n+         --  declared in a parent unit or a public descendant of that parent\n+         --  unit.\n+\n+         elsif Placement = Visible_State_Space then\n+            if Is_Child_Unit (Pack_Id)\n+              and then Is_Private_Descendant (Pack_Id)\n+            then\n+               if not Is_Child_Or_Sibling (Pack_Id, Scope (State_Id)) then\n+                  Error_Msg_N\n+                    (\"indicator Part_Of must denote an abstract state of \"\n+                     & \"parent unit or descendant (SPARK RM 7.2.6(3))\", Indic);\n+               end if;\n+\n+            --  Indicator Part_Of is not needed when the related package is not\n+            --  a private child unit or a public descendant thereof.\n+\n+            else\n+               Error_Msg_N\n+                 (\"indicator Part_Of may not appear in this context (SPARK \"\n+                  & \"RM 7.2.6(5))\", Indic);\n+               Error_Msg_Name_1 := Chars (Pack_Id);\n+               Error_Msg_NE\n+                 (\"\\& is declared in the visible part of package %\",\n+                  Indic, Item_Id);\n+            end if;\n+\n+         --  When the item appears in the private state space of a package, the\n+         --  encapsulating state must be declared in the same package.\n+\n+         elsif Placement = Private_State_Space then\n+            if Scope (State_Id) /= Pack_Id then\n+               Error_Msg_NE\n+                 (\"indicator Part_Of must designate an abstract state of \"\n+                  & \"package & (SPARK RM 7.2.6(2))\", Indic, Pack_Id);\n+               Error_Msg_Name_1 := Chars (Pack_Id);\n+               Error_Msg_NE\n+                 (\"\\& is declared in the private part of package %\",\n+                  Indic, Item_Id);\n+            end if;\n+\n+         --  Items declared in the body state space of a package do not need\n+         --  Part_Of indicators as the refinement has already been seen.\n+\n+         else\n+            Error_Msg_N\n+              (\"indicator Part_Of may not appear in this context (SPARK RM \"\n+               & \"7.2.6(5))\", Indic);\n+\n+            if Scope (State_Id) = Pack_Id then\n+               Error_Msg_Name_1 := Chars (Pack_Id);\n+               Error_Msg_NE\n+                 (\"\\& is declared in the body of package %\", Indic, Item_Id);\n+            end if;\n+         end if;\n+\n+         Legal := True;\n+      end Analyze_Part_Of;\n+\n       ----------------------------\n       -- Analyze_Refined_Pragma --\n       ----------------------------\n@@ -9620,7 +9809,7 @@ package body Sem_Prag is\n          -- Abstract_State --\n          --------------------\n \n-         --  pragma Abstract_State (ABSTRACT_STATE_LIST)\n+         --  pragma Abstract_State (ABSTRACT_STATE_LIST);\n \n          --  ABSTRACT_STATE_LIST ::=\n          --     null\n@@ -9697,6 +9886,9 @@ package body Sem_Prag is\n                ER_Val : Boolean := False;\n                EW_Val : Boolean := False;\n \n+               State_Id : Entity_Id := Empty;\n+               --  The entity to be generated for the current state declaration\n+\n                procedure Analyze_External_Option (Opt : Node_Id);\n                --  Verify the legality of option External\n \n@@ -9725,6 +9917,13 @@ package body Sem_Prag is\n                --  that Prop is not a duplicate property and sets flag Status.\n                --  Opt is not a duplicate property and sets the flag Status.\n \n+               procedure Create_Abstract_State\n+                 (State_Nam : Name_Id;\n+                  Is_Null   : Boolean := False);\n+               --  Generate an abstract state entity with name State_Nam and\n+               --  enter it into visibility. Flag Is_Null should be set when\n+               --  the associated Abstract_State pragma defines a null state.\n+\n                -----------------------------\n                -- Analyze_External_Option --\n                -----------------------------\n@@ -9909,22 +10108,27 @@ package body Sem_Prag is\n                ----------------------------\n \n                procedure Analyze_Part_Of_Option (Opt : Node_Id) is\n-                  Par_State : constant Node_Id := Expression (Opt);\n+                  Encaps    : constant Node_Id := Expression (Opt);\n+                  Encaps_Id : Entity_Id;\n+                  Legal     : Boolean;\n \n                begin\n                   Check_Duplicate_Option (Opt, Part_Of_Seen);\n \n-                  Analyze (Par_State);\n+                  Analyze_Part_Of\n+                    (Item_Id => State_Id,\n+                     State   => Encaps,\n+                     Indic   => First (Choices (Opt)),\n+                     Legal   => Legal);\n \n-                  --  Expression of option Part_Of must denote abstract state\n+                  --  The Part_Of indicator turns an abstract state into a\n+                  --  constituent of the encapsulating state.\n \n-                  if not Is_Entity_Name (Par_State)\n-                    or else No (Entity (Par_State))\n-                    or else Ekind (Entity (Par_State)) /= E_Abstract_State\n-                  then\n-                     Error_Msg_N\n-                       (\"option Part_Of must denote an abstract state\",\n-                        Par_State);\n+                  if Legal then\n+                     Encaps_Id := Entity (Encaps);\n+\n+                     Append_Elmt (State_Id, Part_Of_Constituents (Encaps_Id));\n+                     Set_Encapsulating_State (State_Id, Encaps_Id);\n                   end if;\n                end Analyze_Part_Of_Option;\n \n@@ -9963,15 +10167,46 @@ package body Sem_Prag is\n                   Status := True;\n                end Check_Duplicate_Property;\n \n+               ---------------------------\n+               -- Create_Abstract_State --\n+               ---------------------------\n+\n+               procedure Create_Abstract_State\n+                 (State_Nam : Name_Id;\n+                  Is_Null   : Boolean := False)\n+               is\n+               begin\n+                  --  The generated state abstraction reuses the same chars\n+                  --  from the original state declaration. Decorate the entity.\n+\n+                  State_Id :=\n+                    Make_Defining_Identifier (Sloc (State),\n+                      Chars => New_External_Name (State_Nam));\n+\n+                  --  Null states never come from source\n+\n+                  Set_Comes_From_Source       (State_Id, not Is_Null);\n+                  Set_Parent                  (State_Id, State);\n+                  Set_Ekind                   (State_Id, E_Abstract_State);\n+                  Set_Etype                   (State_Id, Standard_Void_Type);\n+                  Set_Encapsulating_State     (State_Id, Empty);\n+                  Set_Refinement_Constituents (State_Id, New_Elmt_List);\n+                  Set_Part_Of_Constituents    (State_Id, New_Elmt_List);\n+\n+                  --  Every non-null state must be nameable and resolvable the\n+                  --  same way a constant is.\n+\n+                  if not Is_Null then\n+                     Push_Scope (Pack_Id);\n+                     Enter_Name (State_Id);\n+                     Pop_Scope;\n+                  end if;\n+               end Create_Abstract_State;\n+\n                --  Local variables\n \n-               Errors    : constant Nat := Serious_Errors_Detected;\n-               Loc       : constant Source_Ptr := Sloc (State);\n-               Is_Null   : Boolean := False;\n-               Opt       : Node_Id;\n-               Opt_Nam   : Node_Id;\n-               State_Id  : Entity_Id;\n-               State_Nam : Name_Id;\n+               Opt     : Node_Id;\n+               Opt_Nam : Node_Id;\n \n             --  Start of processing for Analyze_Abstract_State\n \n@@ -9986,8 +10221,9 @@ package body Sem_Prag is\n                --  Null states appear as internally generated entities\n \n                elsif Nkind (State) = N_Null then\n-                  State_Nam := New_Internal_Name ('S');\n-                  Is_Null   := True;\n+                  Create_Abstract_State\n+                    (State_Nam => New_Internal_Name ('S'),\n+                     Is_Null   => True);\n                   Null_Seen := True;\n \n                   --  Catch a case where a null state appears in a list of\n@@ -10002,15 +10238,15 @@ package body Sem_Prag is\n                --  Simple state declaration\n \n                elsif Nkind (State) = N_Identifier then\n-                  State_Nam     := Chars (State);\n+                  Create_Abstract_State (Chars (State));\n                   Non_Null_Seen := True;\n \n                --  State declaration with various options. This construct\n                --  appears as an extension aggregate in the tree.\n \n                elsif Nkind (State) = N_Extension_Aggregate then\n                   if Nkind (Ancestor_Part (State)) = N_Identifier then\n-                     State_Nam     := Chars (Ancestor_Part (State));\n+                     Create_Abstract_State (Chars (Ancestor_Part (State)));\n                      Non_Null_Seen := True;\n                   else\n                      Error_Msg_N\n@@ -10035,7 +10271,7 @@ package body Sem_Prag is\n \n                      elsif Chars (Opt) = Name_Part_Of then\n                         Error_Msg_N\n-                          (\"option Part_Of must denote an abstract state \"\n+                          (\"indicator Part_Of must denote an abstract state \"\n                            & \"(SPARK RM 7.1.4(9))\", Opt);\n \n                      else\n@@ -10077,47 +10313,33 @@ package body Sem_Prag is\n                   Error_Msg_N (\"malformed abstract state declaration\", State);\n                end if;\n \n-               --  Do not generate a state abstraction entity if it was not\n-               --  properly declared.\n-\n-               if Serious_Errors_Detected > Errors then\n-                  return;\n-               end if;\n-\n-               --  The generated state abstraction reuses the same characters\n-               --  from the original state declaration. Decorate the entity.\n+               --  Guard against a junk state. In such cases no entity is\n+               --  generated and the subsequent checks cannot be applied.\n \n-               State_Id :=\n-                 Make_Defining_Identifier (Loc, New_External_Name (State_Nam));\n+               if Present (State_Id) then\n \n-               Set_Comes_From_Source       (State_Id, not Is_Null);\n-               Set_Parent                  (State_Id, State);\n-               Set_Ekind                   (State_Id, E_Abstract_State);\n-               Set_Etype                   (State_Id, Standard_Void_Type);\n-               Set_Refined_State           (State_Id, Empty);\n-               Set_Refinement_Constituents (State_Id, New_Elmt_List);\n+                  --  Verify whether the state does not introduce an illegal\n+                  --  hidden state within a package subject to a null abstract\n+                  --  state.\n \n-               --  Every non-null state must be nameable and resolvable the\n-               --  same way a constant is.\n+                  Check_No_Hidden_State (State_Id);\n \n-               if not Is_Null then\n-                  Push_Scope (Pack_Id);\n-                  Enter_Name (State_Id);\n-                  Pop_Scope;\n-               end if;\n+                  --  Check whether the lack of option Part_Of agrees with the\n+                  --  placement of the abstract state with respect to the state\n+                  --  space.\n \n-               --  Verify whether the state introduces an illegal hidden state\n-               --  within a package subject to a null abstract state.\n+                  if not Part_Of_Seen then\n+                     Check_Missing_Part_Of (State_Id);\n+                  end if;\n \n-               Check_No_Hidden_State (State_Id);\n+                  --  Associate the state with its related package\n \n-               --  Associate the state with its related package\n+                  if No (Abstract_States (Pack_Id)) then\n+                     Set_Abstract_States (Pack_Id, New_Elmt_List);\n+                  end if;\n \n-               if No (Abstract_States (Pack_Id)) then\n-                  Set_Abstract_States (Pack_Id, New_Elmt_List);\n+                  Append_Elmt (State_Id, Abstract_States (Pack_Id));\n                end if;\n-\n-               Append_Elmt (State_Id, Abstract_States (Pack_Id));\n             end Analyze_Abstract_State;\n \n             --  Local variables\n@@ -16774,6 +16996,212 @@ package body Sem_Prag is\n          when Pragma_Page =>\n             null;\n \n+         -------------\n+         -- Part_Of --\n+         -------------\n+\n+         --  pragma Part_Of (ABSTRACT_STATE);\n+\n+         --  ABSTRACT_STATE ::= name\n+\n+         when Pragma_Part_Of => Part_Of : declare\n+            procedure Propagate_Part_Of\n+              (Pack_Id  : Entity_Id;\n+               State_Id : Entity_Id;\n+               Instance : Node_Id);\n+            --  Propagate the Part_Of indicator to all abstract states and\n+            --  variables declared in the visible state space of a package\n+            --  denoted by Pack_Id. State_Id is the encapsulating state.\n+            --  Instance is the package instantiation node.\n+\n+            -----------------------\n+            -- Propagate_Part_Of --\n+            -----------------------\n+\n+            procedure Propagate_Part_Of\n+              (Pack_Id  : Entity_Id;\n+               State_Id : Entity_Id;\n+               Instance : Node_Id)\n+            is\n+               Has_Item : Boolean := False;\n+               --  Flag set when the visible state space contains at least one\n+               --  abstract state or variable.\n+\n+               procedure Propagate_Part_Of (Pack_Id : Entity_Id);\n+               --  Propagate the Part_Of indicator to all abstract states and\n+               --  variables declared in the visible state space of a package\n+               --  denoted by Pack_Id.\n+\n+               -----------------------\n+               -- Propagate_Part_Of --\n+               -----------------------\n+\n+               procedure Propagate_Part_Of (Pack_Id : Entity_Id) is\n+                  Item_Id : Entity_Id;\n+\n+               begin\n+                  --  Traverse the entity chain of the package and set relevant\n+                  --  attributes of abstract states and variables declared in\n+                  --  the visible state space of the package.\n+\n+                  Item_Id := First_Entity (Pack_Id);\n+                  while Present (Item_Id)\n+                    and then not In_Private_Part (Item_Id)\n+                  loop\n+                     --  Do not consider internally generated items\n+\n+                     if not Comes_From_Source (Item_Id) then\n+                        null;\n+\n+                     --  The Part_Of indicator turns an abstract state or\n+                     --  variable into a constituent of the encapsulating\n+                     --  state.\n+\n+                     elsif Ekind_In (Item_Id, E_Abstract_State,\n+                                              E_Variable)\n+                     then\n+                        Has_Item := True;\n+\n+                        Append_Elmt (Item_Id, Part_Of_Constituents (State_Id));\n+                        Set_Encapsulating_State (Item_Id, State_Id);\n+\n+                     --  Recursively handle nested packages and instantiations\n+\n+                     elsif Ekind (Item_Id) = E_Package then\n+                        Propagate_Part_Of (Item_Id);\n+                     end if;\n+\n+                     Next_Entity (Item_Id);\n+                  end loop;\n+               end Propagate_Part_Of;\n+\n+            --  Start of processing for Propagate_Part_Of\n+\n+            begin\n+               Propagate_Part_Of (Pack_Id);\n+\n+               --  Detect a package instantiation that is subject to a Part_Of\n+               --  indicator, but has no visible state.\n+\n+               if not Has_Item then\n+                  Error_Msg_NE\n+                    (\"package instantiation & has Part_Of indicator but \"\n+                     & \"lacks visible state\", Instance, Pack_Id);\n+               end if;\n+            end Propagate_Part_Of;\n+\n+            --  Local variables\n+\n+            Item_Id  : Entity_Id;\n+            Legal    : Boolean;\n+            State    : Node_Id;\n+            State_Id : Entity_Id;\n+            Stmt     : Node_Id;\n+\n+         --  Start of processing for Part_Of\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_Arg_Count (1);\n+\n+            --  Ensure the proper placement of the pragma. Part_Of must appear\n+            --  on a variable declaration or a package instantiation.\n+\n+            Stmt := Prev (N);\n+            while Present (Stmt) loop\n+\n+               --  Skip prior pragmas, but check for duplicates\n+\n+               if Nkind (Stmt) = N_Pragma then\n+                  if Pragma_Name (Stmt) = Pname then\n+                     Error_Msg_Name_1 := Pname;\n+                     Error_Msg_Sloc   := Sloc (Stmt);\n+                     Error_Msg_N (\"pragma% duplicates pragma declared#\", N);\n+                  end if;\n+\n+               --  Skip internally generated code\n+\n+               elsif not Comes_From_Source (Stmt) then\n+                  null;\n+\n+               --  The pragma applies to an object declaration (possibly a\n+               --  variable) or a package instantiation. Stop the traversal\n+               --  and continue the analysis.\n+\n+               elsif Nkind_In (Stmt, N_Object_Declaration,\n+                                     N_Package_Instantiation)\n+               then\n+                  exit;\n+\n+               --  The pragma does not apply to a legal construct, issue an\n+               --  error and stop the analysis.\n+\n+               else\n+                  Pragma_Misplaced;\n+                  return;\n+               end if;\n+\n+               Stmt := Prev (Stmt);\n+            end loop;\n+\n+            --  When the context is an object declaration, ensure that we are\n+            --  dealing with a variable.\n+\n+            if Nkind (Stmt) = N_Object_Declaration\n+              and then Ekind (Defining_Entity (Stmt)) /= E_Variable\n+            then\n+               Error_Msg_N (\"indicator Part_Of must apply to a variable\", N);\n+               return;\n+            end if;\n+\n+            --  Extract the entity of the related object declaration or package\n+            --  instantiation. In the case of the instantiation, use the entity\n+            --  of the instance spec.\n+\n+            if Nkind (Stmt) = N_Package_Instantiation then\n+               Stmt := Instance_Spec (Stmt);\n+            end if;\n+\n+            Item_Id := Defining_Entity (Stmt);\n+            State   := Get_Pragma_Arg  (Arg1);\n+\n+            --  Detect any discrepancies between the placement of the object\n+            --  or package instantiation with respect to state space and the\n+            --  encapsulating state.\n+\n+            Analyze_Part_Of\n+              (Item_Id => Item_Id,\n+               State   => State,\n+               Indic   => N,\n+               Legal   => Legal);\n+\n+            if Legal then\n+               State_Id := Entity (State);\n+\n+               --  Add the pragma to the contract of the item. This aids with\n+               --  the detection of a missing but required Part_Of indicator.\n+\n+               Add_Contract_Item (N, Item_Id);\n+\n+               --  The Part_Of indicator turns a variable into a constituent\n+               --  of the encapsulating state.\n+\n+               if Ekind (Item_Id) = E_Variable then\n+                  Append_Elmt (Item_Id, Part_Of_Constituents (State_Id));\n+                  Set_Encapsulating_State (Item_Id, State_Id);\n+\n+               --  Propagate the Part_Of indicator to the visible state space\n+               --  of the package instantiation.\n+\n+               else\n+                  Propagate_Part_Of\n+                    (Pack_Id  => Item_Id,\n+                     State_Id => State_Id,\n+                     Instance => Stmt);\n+               end if;\n+            end if;\n+         end Part_Of;\n+\n          ----------------------------------\n          -- Partition_Elaboration_Policy --\n          ----------------------------------\n@@ -20911,8 +21339,8 @@ package body Sem_Prag is\n \n                               if Ekind_In (Ref_Id, E_Abstract_State,\n                                                    E_Variable)\n-                                and then Present (Refined_State (Ref_Id))\n-                                and then Refined_State (Ref_Id) = Dep_Id\n+                                and then Present (Encapsulating_State (Ref_Id))\n+                                and then Encapsulating_State (Ref_Id) = Dep_Id\n                               then\n                                  Has_Constituent := True;\n                                  Remove (Ref_Input);\n@@ -21211,8 +21639,8 @@ package body Sem_Prag is\n                         --  per the example above.\n \n                         if Ekind_In (Ref_Id, E_Abstract_State, E_Variable)\n-                          and then Present (Refined_State (Ref_Id))\n-                          and then Refined_State (Ref_Id) = Dep_Id\n+                          and then Present (Encapsulating_State (Ref_Id))\n+                          and then Encapsulating_State (Ref_Id) = Dep_Id\n                           and then Inputs_Match\n                                      (Ref_Clause, Do_Checks => False)\n                         then\n@@ -21957,7 +22385,7 @@ package body Sem_Prag is\n             --  The state or variable acts as a constituent of a state, collect\n             --  it for the state completeness checks performed later on.\n \n-            if Present (Refined_State (Item_Id)) then\n+            if Present (Encapsulating_State (Item_Id)) then\n                if Global_Mode = Name_Input then\n                   Add_Item (Item_Id, In_Constits);\n \n@@ -22245,40 +22673,41 @@ package body Sem_Prag is\n    ----------------------------------------\n \n    procedure Analyze_Refined_State_In_Decl_Part (N : Node_Id) is\n-      Pack_Body : constant Node_Id   := Parent (N);\n-      Spec_Id   : constant Entity_Id := Corresponding_Spec (Pack_Body);\n+      Available_States : Elist_Id := No_Elist;\n+      --  A list of all abstract states defined in the package declaration that\n+      --  are available for refinement. The list is used to report unrefined\n+      --  states.\n \n-      Abstr_States : Elist_Id := No_Elist;\n-      --  A list of all abstract states defined in the package declaration. The\n-      --  list is used to report unrefined states.\n+      Body_Id : Entity_Id;\n+      --  The body entity of the package subject to pragma Refined_State\n+\n+      Body_States : Elist_Id := No_Elist;\n+      --  A list of all hidden states that appear in the body of the related\n+      --  package. The list is used to report unused hidden states.\n \n       Constituents_Seen : Elist_Id := No_Elist;\n       --  A list that contains all constituents processed so far. The list is\n       --  used to detect multiple uses of the same constituent.\n \n-      Hidden_States : Elist_Id := No_Elist;\n-      --  A list of all hidden states (abstract states and variables) that\n-      --  appear in the package spec and body. The list is used to report\n-      --  unused hidden states.\n-\n       Refined_States_Seen : Elist_Id := No_Elist;\n       --  A list that contains all refined states processed so far. The list is\n       --  used to detect duplicate refinements.\n \n+      Spec_Id : Entity_Id;\n+      --  The spec entity of the package subject to pragma Refined_State\n+\n       procedure Analyze_Refinement_Clause (Clause : Node_Id);\n       --  Perform full analysis of a single refinement clause\n \n-      procedure Collect_Hidden_States;\n-      --  Gather the entities of all hidden states that appear in the spec and\n-      --  body of the related package in Hidden_States.\n+      function Collect_Body_States (Pack_Id : Entity_Id) return Elist_Id;\n+      --  Gather the entities of all abstract states and variables declared in\n+      --  the body state space of package Pack_Id.\n \n-      procedure Report_Unrefined_States;\n-      --  Emit errors for all abstract states that have not been refined by\n-      --  the pragma.\n+      procedure Report_Unrefined_States (States : Elist_Id);\n+      --  Emit errors for all unrefined abstract states found in list States\n \n-      procedure Report_Unused_Hidden_States;\n-      --  Emit errors for all hidden states of the related package that do not\n-      --  participate in a refinement.\n+      procedure Report_Unused_States (States : Elist_Id);\n+      --  Emit errors for all unused states found in list States\n \n       -------------------------------\n       -- Analyze_Refinement_Clause --\n@@ -22302,9 +22731,13 @@ package body Sem_Prag is\n          --  Flags used to detect multiple uses of null in a single clause or a\n          --  mixture of null and non-null constituents.\n \n+         Part_Of_Constits : Elist_Id := No_Elist;\n+         --  A list of all candidate constituents subject to indicator Part_Of\n+         --  where the encapsulating state is the current state.\n+\n          State    : Node_Id;\n          State_Id : Entity_Id;\n-         --  The state being refined in the current clause\n+         --  The current state being refined\n \n          procedure Analyze_Constituent (Constit : Node_Id);\n          --  Perform full analysis of a single constituent\n@@ -22319,10 +22752,13 @@ package body Sem_Prag is\n          --  this is not the case, emit an error message.\n \n          procedure Check_Matching_State;\n-         --  Determine whether the state being refined appears in Abstr_States.\n-         --  Emit an error when attempting to re-refine the state or when the\n-         --  state is not defined in the package declaration. Otherwise remove\n-         --  the state from Abstr_States.\n+         --  Determine whether the state being refined appears in list\n+         --  Available_States. Emit an error when attempting to re-refine the\n+         --  state or when the state is not defined in the package declaration,\n+         --  otherwise remove the state from Available_States.\n+\n+         procedure Report_Unused_Constituents (Constits : Elist_Id);\n+         --  Emit errors for all unused Part_Of constituents in list Constits\n \n          -------------------------\n          -- Analyze_Constituent --\n@@ -22355,12 +22791,12 @@ package body Sem_Prag is\n \n                   Add_Item (Constit_Id, Constituents_Seen);\n \n-                  --  Collect the constituent in the list of refinement items.\n-                  --  Establish a relation between the refined state and its\n-                  --  constituent.\n+                  --  Collect the constituent in the list of refinement items\n+                  --  and establish a relation between the refined state and\n+                  --  the item.\n \n                   Append_Elmt (Constit_Id, Refinement_Constituents (State_Id));\n-                  Set_Refined_State (Constit_Id, State_Id);\n+                  Set_Encapsulating_State (Constit_Id, State_Id);\n \n                   --  The state has at least one legal constituent, mark the\n                   --  start of the refinement region. The region ends when the\n@@ -22405,70 +22841,59 @@ package body Sem_Prag is\n                   Error_Msg_NE\n                     (\"duplicate use of constituent &\", Constit, Constit_Id);\n                   return;\n+               end if;\n \n-               --  A state can act as a constituent only when it is part of\n-               --  another state. This relation is expressed by option Part_Of\n-               --  of pragma Abstract_State.\n+               --  The constituent is subject to a Part_Of indicator\n \n-               elsif Ekind (Constit_Id) = E_Abstract_State then\n-                  if not Is_Part_Of (Constit_Id, State_Id) then\n-                     Error_Msg_Name_1 := Chars (State_Id);\n-                     Error_Msg_NE\n-                       (\"state & is not a valid constituent of ancestor \"\n-                        & \"state %\", Constit, Constit_Id);\n-                     return;\n+               if Present (Encapsulating_State (Constit_Id)) then\n+                  if Encapsulating_State (Constit_Id) = State_Id then\n+                     Remove (Part_Of_Constits, Constit_Id);\n+                     Collect_Constituent;\n \n-                  --  The constituent has the proper Part_Of option, but may\n-                  --  not appear in the immediate hidden state of the related\n-                  --  package. This case arises when the constituent appears\n-                  --  in a private child or a private sibling. Recognize these\n-                  --  scenarios and collect the constituent.\n+                  --  The constituent is part of another state and is used\n+                  --  incorrectly in the refinement of the current state.\n \n-                  elsif Is_Child_Or_Sibling\n-                          (Pack_1        => Scope (State_Id),\n-                           Pack_2        => Scope (Constit_Id),\n-                           Private_Child => True)\n-                  then\n-                     Collect_Constituent;\n-                     return;\n+                  else\n+                     Error_Msg_Name_1 := Chars (State_Id);\n+                     Error_Msg_NE\n+                       (\"& cannot act as constituent of state %\",\n+                        Constit, Constit_Id);\n+                     Error_Msg_NE\n+                       (\"\\Part_Of indicator specifies & as encapsulating \"\n+                        & \"state\", Constit, Encapsulating_State (Constit_Id));\n                   end if;\n-               end if;\n-\n-               --  Inspect the hidden states of the related package looking for\n-               --  a match.\n \n-               if Present (Hidden_States) then\n-                  State_Elmt := First_Elmt (Hidden_States);\n-                  while Present (State_Elmt) loop\n+               --  The only other source of legal constituents is the body\n+               --  state space of the related package.\n \n-                     --  A valid hidden state or variable acts as a constituent\n+               else\n+                  if Present (Body_States) then\n+                     State_Elmt := First_Elmt (Body_States);\n+                     while Present (State_Elmt) loop\n \n-                     if Node (State_Elmt) = Constit_Id then\n+                        --  Consume a valid constituent to signal that it has\n+                        --  been encountered.\n \n-                        --  Add the constituent to the lis of processed items\n-                        --  to aid with the detection of duplicates. Remove the\n-                        --  constituent from Hidden_States to signal that it\n-                        --  has already been matched.\n+                        if Node (State_Elmt) = Constit_Id then\n+                           Remove_Elmt (Body_States, State_Elmt);\n+                           Collect_Constituent;\n+                           return;\n+                        end if;\n \n-                        Add_Item (Constit_Id, Constituents_Seen);\n-                        Remove_Elmt (Hidden_States, State_Elmt);\n+                        Next_Elmt (State_Elmt);\n+                     end loop;\n+                  end if;\n \n-                        Collect_Constituent;\n-                        return;\n-                     end if;\n+                  --  If we get here, then the constituent is not a hidden\n+                  --  state of the related package and may not be used in a\n+                  --  refinement.\n \n-                     Next_Elmt (State_Elmt);\n-                  end loop;\n+                  Error_Msg_Name_1 := Chars (Spec_Id);\n+                  Error_Msg_NE\n+                    (\"cannot use & in refinement, constituent is not a hidden \"\n+                     & \"state of package % (SPARK RM 7.2.2(9))\",\n+                     Constit, Constit_Id);\n                end if;\n-\n-               --  If we get here, we are refining a state that is not hidden\n-               --  with respect to the related package.\n-\n-               Error_Msg_Name_1 := Chars (Spec_Id);\n-               Error_Msg_NE\n-                 (\"cannot use & in refinement, constituent is not a hidden \"\n-                  & \"state of package % (SPARK RM 7.2.2(9))\",\n-                  Constit, Constit_Id);\n             end Check_Matching_Constituent;\n \n             --  Local variables\n@@ -22593,18 +23018,18 @@ package body Sem_Prag is\n             --  Inspect the abstract states defined in the package declaration\n             --  looking for a match.\n \n-            State_Elmt := First_Elmt (Abstr_States);\n+            State_Elmt := First_Elmt (Available_States);\n             while Present (State_Elmt) loop\n \n                --  A valid abstract state is being refined in the body. Add\n                --  the state to the list of processed refined states to aid\n                --  with the detection of duplicate refinements. Remove the\n-               --  state from Abstr_States to signal that it has already been\n-               --  refined.\n+               --  state from Available_States to signal that it has already\n+               --  been refined.\n \n                if Node (State_Elmt) = State_Id then\n                   Add_Item (State_Id, Refined_States_Seen);\n-                  Remove_Elmt (Abstr_States, State_Elmt);\n+                  Remove_Elmt (Available_States, State_Elmt);\n                   return;\n                end if;\n \n@@ -22620,6 +23045,49 @@ package body Sem_Prag is\n                State, State_Id);\n          end Check_Matching_State;\n \n+         --------------------------------\n+         -- Report_Unused_Constituents --\n+         --------------------------------\n+\n+         procedure Report_Unused_Constituents (Constits : Elist_Id) is\n+            Constit_Elmt : Elmt_Id;\n+            Constit_Id   : Entity_Id;\n+            Posted       : Boolean := False;\n+\n+         begin\n+            if Present (Constits) then\n+               Constit_Elmt := First_Elmt (Constits);\n+               while Present (Constit_Elmt) loop\n+                  Constit_Id := Node (Constit_Elmt);\n+\n+                  --  Generate an error message of the form:\n+\n+                  --    state ... has unused Part_Of constituents\n+                  --      abstract state ... defined at ...\n+                  --      variable ... defined at ...\n+\n+                  if not Posted then\n+                     Posted := True;\n+                     Error_Msg_NE\n+                       (\"state & has unused Part_Of constituents\",\n+                        State, State_Id);\n+                  end if;\n+\n+                  Error_Msg_Sloc := Sloc (Constit_Id);\n+\n+                  if Ekind (Constit_Id) = E_Abstract_State then\n+                     Error_Msg_NE\n+                       (\"\\  abstract state & defined #\", State, Constit_Id);\n+                  else\n+                     Error_Msg_NE\n+                       (\"\\  variable & defined #\", State, Constit_Id);\n+                  end if;\n+\n+                  Next_Elmt (Constit_Elmt);\n+               end loop;\n+            end if;\n+         end Report_Unused_Constituents;\n+\n          --  Local declarations\n \n          Body_Ref      : Node_Id;\n@@ -22651,6 +23119,7 @@ package body Sem_Prag is\n             else\n                Error_Msg_NE\n                  (\"& must denote an abstract state\", State, State_Id);\n+               return;\n             end if;\n \n             --  A global item cannot denote a state abstraction whose\n@@ -22673,10 +23142,11 @@ package body Sem_Prag is\n                end loop;\n             end if;\n \n-            --  The state name is illegal\n+         --  The state name is illegal\n \n          else\n             Error_Msg_N (\"malformed state name in refinement clause\", State);\n+            return;\n          end if;\n \n          --  A refinement clause may only refine one state at a time\n@@ -22688,6 +23158,11 @@ package body Sem_Prag is\n               (\"refinement clause cannot cover multiple states\", Extra_State);\n          end if;\n \n+         --  Replicate the Part_Of constituents of the refined state because\n+         --  the algorithm will consume items.\n+\n+         Part_Of_Constits := New_Copy_Elist (Part_Of_Constituents (State_Id));\n+\n          --  Analyze all constituents of the refinement. Multiple constituents\n          --  appear as an aggregate.\n \n@@ -22768,98 +23243,112 @@ package body Sem_Prag is\n               (\"non-external state & cannot contain external constituents in \"\n                & \"refinement (SPARK RM 7.2.8(1))\", State, State_Id);\n          end if;\n-      end Analyze_Refinement_Clause;\n-\n-      ---------------------------\n-      -- Collect_Hidden_States --\n-      ---------------------------\n-\n-      procedure Collect_Hidden_States is\n-         procedure Collect_Hidden_States_In_Decls (Decls : List_Id);\n-         --  Find all hidden states that appear in declarative list Decls and\n-         --  append their entities to Result.\n \n-         ------------------------------------\n-         -- Collect_Hidden_States_In_Decls --\n-         ------------------------------------\n+         --  Ensure that all Part_Of candidate constituents have been mentioned\n+         --  in the refinement clause.\n \n-         procedure Collect_Hidden_States_In_Decls (Decls : List_Id) is\n-            procedure Collect_Abstract_States (States : Elist_Id);\n-            --  Copy the abstract states defined in list States to list Result\n+         Report_Unused_Constituents (Part_Of_Constits);\n+      end Analyze_Refinement_Clause;\n \n-            -----------------------------\n-            -- Collect_Abstract_States --\n-            -----------------------------\n+      -------------------------\n+      -- Collect_Body_States --\n+      -------------------------\n \n-            procedure Collect_Abstract_States (States : Elist_Id) is\n-               State_Elmt : Elmt_Id;\n-            begin\n-               if Present (States) then\n-                  State_Elmt := First_Elmt (States);\n-                  while Present (State_Elmt) loop\n-                     Add_Item (Node (State_Elmt), Hidden_States);\n-                     Next_Elmt (State_Elmt);\n-                  end loop;\n-               end if;\n-            end Collect_Abstract_States;\n+      function Collect_Body_States (Pack_Id : Entity_Id) return Elist_Id is\n+         Result : Elist_Id := No_Elist;\n+         --  A list containing all body states of Pack_Id\n \n-            --  Local variables\n+         procedure Collect_Visible_States (Pack_Id : Entity_Id);\n+         --  Gather the entities of all abstract states and variables declared\n+         --  in the visible state space of package Pack_Id.\n \n-            Decl : Node_Id;\n+         ----------------------------\n+         -- Collect_Visible_States --\n+         ----------------------------\n \n-         --  Start of processing for Collect_Hidden_States_In_Decls\n+         procedure Collect_Visible_States (Pack_Id : Entity_Id) is\n+            Item_Id : Entity_Id;\n \n          begin\n-            Decl := First (Decls);\n-            while Present (Decl) loop\n+            --  Traverse the entity chain of the package and inspect all\n+            --  visible items.\n \n-               --  Source objects (non-constants) are valid hidden states\n+            Item_Id := First_Entity (Pack_Id);\n+            while Present (Item_Id) and then not In_Private_Part (Item_Id) loop\n \n-               if Nkind (Decl) = N_Object_Declaration\n-                 and then Ekind (Defining_Entity (Decl)) = E_Variable\n-                 and then Comes_From_Source (Decl)\n-               then\n-                  Add_Item (Defining_Entity (Decl), Hidden_States);\n+               --  Do not consider internally generated items as those cannot\n+               --  be named and participate in refinement.\n+\n+               if not Comes_From_Source (Item_Id) then\n+                  null;\n \n-               --  Gather the abstract states of a package along with all\n-               --  hidden states in its visible declarations.\n+               elsif Ekind_In (Item_Id, E_Abstract_State, E_Variable) then\n+                  Add_Item (Item_Id, Result);\n \n-               elsif Nkind (Decl) = N_Package_Declaration then\n-                  Collect_Abstract_States\n-                    (Abstract_States (Defining_Entity (Decl)));\n+               --  Recursively gather the visible states of a nested package\n \n-                  Collect_Hidden_States_In_Decls\n-                    (Visible_Declarations (Specification (Decl)));\n+               elsif Ekind (Item_Id) = E_Package then\n+                  Collect_Visible_States (Item_Id);\n                end if;\n \n-               Next (Decl);\n+               Next_Entity (Item_Id);\n             end loop;\n-         end Collect_Hidden_States_In_Decls;\n+         end Collect_Visible_States;\n \n          --  Local variables\n \n-         Pack_Spec : constant Node_Id := Package_Specification (Spec_Id);\n+         Pack_Body : constant Node_Id :=\n+                       Declaration_Node (Body_Entity (Pack_Id));\n+         Decl      : Node_Id;\n+         Item_Id   : Entity_Id;\n \n-      --  Start of processing for Collect_Hidden_States\n+      --  Start of processing for Collect_Body_States\n \n       begin\n-         --  Process the private declarations of the package spec and the\n-         --  declarations of the body.\n+         --  Inspect the declarations of the body looking for source variables,\n+         --  packages and package instantiations.\n+\n+         Decl := First (Declarations (Pack_Body));\n+         while Present (Decl) loop\n+            if Nkind (Decl) = N_Object_Declaration then\n+               Item_Id := Defining_Entity (Decl);\n+\n+               --  Capture source variables only as internally generated\n+               --  temporaries cannot be named and participate in refinement.\n+\n+               if Ekind (Item_Id) = E_Variable\n+                 and then Comes_From_Source (Item_Id)\n+               then\n+                  Add_Item (Item_Id, Result);\n+               end if;\n+\n+            elsif Nkind (Decl) = N_Package_Declaration then\n+               Item_Id := Defining_Entity (Decl);\n+\n+               --  Capture the visible abstract states and variables of a\n+               --  source package [instantiation].\n+\n+               if Comes_From_Source (Item_Id) then\n+                  Collect_Visible_States (Item_Id);\n+               end if;\n+            end if;\n+\n+            Next (Decl);\n+         end loop;\n \n-         Collect_Hidden_States_In_Decls (Private_Declarations (Pack_Spec));\n-         Collect_Hidden_States_In_Decls (Declarations (Pack_Body));\n-      end Collect_Hidden_States;\n+         return Result;\n+      end Collect_Body_States;\n \n       -----------------------------\n       -- Report_Unrefined_States --\n       -----------------------------\n \n-      procedure Report_Unrefined_States is\n+      procedure Report_Unrefined_States (States : Elist_Id) is\n          State_Elmt : Elmt_Id;\n \n       begin\n-         if Present (Abstr_States) then\n-            State_Elmt := First_Elmt (Abstr_States);\n+         if Present (States) then\n+            State_Elmt := First_Elmt (States);\n             while Present (State_Elmt) loop\n                Error_Msg_N\n                  (\"abstract state & must be refined\", Node (State_Elmt));\n@@ -22869,61 +23358,72 @@ package body Sem_Prag is\n          end if;\n       end Report_Unrefined_States;\n \n-      ---------------------------------\n-      -- Report_Unused_Hidden_States --\n-      ---------------------------------\n+      --------------------------\n+      -- Report_Unused_States --\n+      --------------------------\n \n-      procedure Report_Unused_Hidden_States is\n+      procedure Report_Unused_States (States : Elist_Id) is\n          Posted     : Boolean := False;\n          State_Elmt : Elmt_Id;\n          State_Id   : Entity_Id;\n \n       begin\n-         if Present (Hidden_States) then\n-            State_Elmt := First_Elmt (Hidden_States);\n+         if Present (States) then\n+            State_Elmt := First_Elmt (States);\n             while Present (State_Elmt) loop\n                State_Id := Node (State_Elmt);\n \n                --  Generate an error message of the form:\n \n-               --    package ... has unused hidden states\n+               --    body of package ... has unused hidden states\n                --      abstract state ... defined at ...\n                --      variable ... defined at ...\n \n                if not Posted then\n                   Posted := True;\n-                  Error_Msg_NE\n-                    (\"package & has unused hidden states\", N, Spec_Id);\n+                  Error_Msg_N\n+                    (\"body of package & has unused hidden states\", Body_Id);\n                end if;\n \n                Error_Msg_Sloc := Sloc (State_Id);\n \n                if Ekind (State_Id) = E_Abstract_State then\n-                  Error_Msg_NE (\"\\  abstract state & defined #\", N, State_Id);\n+                  Error_Msg_NE\n+                    (\"\\  abstract state & defined #\", Body_Id, State_Id);\n                else\n-                  Error_Msg_NE (\"\\  variable & defined #\", N, State_Id);\n+                  Error_Msg_NE (\"\\  variable & defined #\", Body_Id, State_Id);\n                end if;\n \n                Next_Elmt (State_Elmt);\n             end loop;\n          end if;\n-      end Report_Unused_Hidden_States;\n+      end Report_Unused_States;\n \n       --  Local declarations\n \n-      Clauses : constant Node_Id :=\n-                  Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n-      Clause  : Node_Id;\n+      Body_Decl : constant Node_Id := Parent (N);\n+      Clauses   : constant Node_Id :=\n+                    Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n+      Clause    : Node_Id;\n \n    --  Start of processing for Analyze_Refined_State_In_Decl_Part\n \n    begin\n       Set_Analyzed (N);\n \n-      --  Initialize the various lists used during analysis\n+      Body_Id := Defining_Entity (Body_Decl);\n+      Spec_Id := Corresponding_Spec (Body_Decl);\n+\n+      --  Replicate the abstract states declared by the package because the\n+      --  matching algorithm will consume states.\n+\n+      Available_States := New_Copy_Elist (Abstract_States (Spec_Id));\n+\n+      --  Gather all abstract states and variables declared in the visible\n+      --  state space of the package body. These items must be utilized as\n+      --  constituents in a state refinement.\n \n-      Abstr_States := New_Copy_Elist (Abstract_States (Spec_Id));\n-      Collect_Hidden_States;\n+      Body_States := Collect_Body_States (Spec_Id);\n \n       --  Multiple non-null state refinements appear as an aggregate\n \n@@ -22949,11 +23449,14 @@ package body Sem_Prag is\n          Analyze_Refinement_Clause (Clauses);\n       end if;\n \n-      --  Ensure that all abstract states have been refined and all hidden\n-      --  states of the related package unilized in refinements.\n+      --  List all abstract states that were left unrefined\n \n-      Report_Unrefined_States;\n-      Report_Unused_Hidden_States;\n+      Report_Unrefined_States (Available_States);\n+\n+      --  Ensure that all abstract states and variables declared in the body\n+      --  state space of the related package are utilized as constituents.\n+\n+      Report_Unused_States (Body_States);\n    end Analyze_Refined_State_In_Decl_Part;\n \n    ------------------------------------\n@@ -23013,6 +23516,85 @@ package body Sem_Prag is\n       return False;\n    end Appears_In;\n \n+   -----------------------------\n+   -- Check_Applicable_Policy --\n+   -----------------------------\n+\n+   procedure Check_Applicable_Policy (N : Node_Id) is\n+      PP     : Node_Id;\n+      Policy : Name_Id;\n+\n+      Ename : constant Name_Id := Original_Aspect_Name (N);\n+\n+   begin\n+      --  No effect if not valid assertion kind name\n+\n+      if not Is_Valid_Assertion_Kind (Ename) then\n+         return;\n+      end if;\n+\n+      --  Loop through entries in check policy list\n+\n+      PP := Opt.Check_Policy_List;\n+      while Present (PP) loop\n+         declare\n+            PPA : constant List_Id := Pragma_Argument_Associations (PP);\n+            Pnm : constant Name_Id := Chars (Get_Pragma_Arg (First (PPA)));\n+\n+         begin\n+            if Ename = Pnm\n+              or else Pnm = Name_Assertion\n+              or else (Pnm = Name_Statement_Assertions\n+                        and then Nam_In (Ename, Name_Assert,\n+                                                Name_Assert_And_Cut,\n+                                                Name_Assume,\n+                                                Name_Loop_Invariant,\n+                                                Name_Loop_Variant))\n+            then\n+               Policy := Chars (Get_Pragma_Arg (Last (PPA)));\n+\n+               case Policy is\n+                  when Name_Off | Name_Ignore =>\n+                     Set_Is_Ignored (N, True);\n+                     Set_Is_Checked (N, False);\n+\n+                  when Name_On | Name_Check =>\n+                     Set_Is_Checked (N, True);\n+                     Set_Is_Ignored (N, False);\n+\n+                  when Name_Disable =>\n+                     Set_Is_Ignored  (N, True);\n+                     Set_Is_Checked  (N, False);\n+                     Set_Is_Disabled (N, True);\n+\n+                  --  That should be exhaustive, the null here is a defence\n+                  --  against a malformed tree from previous errors.\n+\n+                  when others =>\n+                     null;\n+               end case;\n+\n+               return;\n+            end if;\n+\n+            PP := Next_Pragma (PP);\n+         end;\n+      end loop;\n+\n+      --  If there are no specific entries that matched, then we let the\n+      --  setting of assertions govern. Note that this provides the needed\n+      --  compatibility with the RM for the cases of assertion, invariant,\n+      --  precondition, predicate, and postcondition.\n+\n+      if Assertions_Enabled then\n+         Set_Is_Checked (N, True);\n+         Set_Is_Ignored (N, False);\n+      else\n+         Set_Is_Checked (N, False);\n+         Set_Is_Ignored (N, True);\n+      end if;\n+   end Check_Applicable_Policy;\n+\n    -------------------------------\n    -- Check_External_Properties --\n    -------------------------------\n@@ -23120,84 +23702,154 @@ package body Sem_Prag is\n       end if;\n    end Check_Kind;\n \n-   -----------------------------\n-   -- Check_Applicable_Policy --\n-   -----------------------------\n-\n-   procedure Check_Applicable_Policy (N : Node_Id) is\n-      PP     : Node_Id;\n-      Policy : Name_Id;\n+   ---------------------------\n+   -- Check_Missing_Part_Of --\n+   ---------------------------\n \n-      Ename : constant Name_Id := Original_Aspect_Name (N);\n+   procedure Check_Missing_Part_Of (Item_Id : Entity_Id) is\n+      Pack_Id   : Entity_Id;\n+      Placement : State_Space_Kind;\n \n    begin\n-      --  No effect if not valid assertion kind name\n+      --  Do not consider internally generated entities as these can never\n+      --  have a Part_Of indicator.\n \n-      if not Is_Valid_Assertion_Kind (Ename) then\n+      if not Comes_From_Source (Item_Id) then\n+         return;\n+\n+      --  Perform these checks only when SPARK_Mode is enabled as they will\n+      --  interfere with standard Ada rules and produce false positives.\n+\n+      elsif SPARK_Mode /= On then\n          return;\n       end if;\n \n-      --  Loop through entries in check policy list\n+      --  Find where the abstract state, variable or package instantiation\n+      --  lives with respect to the state space.\n \n-      PP := Opt.Check_Policy_List;\n-      while Present (PP) loop\n-         declare\n-            PPA : constant List_Id := Pragma_Argument_Associations (PP);\n-            Pnm : constant Name_Id := Chars (Get_Pragma_Arg (First (PPA)));\n+      Find_Placement_In_State_Space\n+        (Item_Id   => Item_Id,\n+         Placement => Placement,\n+         Pack_Id   => Pack_Id);\n \n-         begin\n-            if Ename = Pnm\n-              or else Pnm = Name_Assertion\n-              or else (Pnm = Name_Statement_Assertions\n-                        and then Nam_In (Ename, Name_Assert,\n-                                                Name_Assert_And_Cut,\n-                                                Name_Assume,\n-                                                Name_Loop_Invariant,\n-                                                Name_Loop_Variant))\n-            then\n-               Policy := Chars (Get_Pragma_Arg (Last (PPA)));\n+      --  Items that appear in a non-package construct (subprogram, block, etc)\n+      --  do not require a Part_Of indicator because they can never act as a\n+      --  hidden state.\n \n-               case Policy is\n-                  when Name_Off | Name_Ignore =>\n-                     Set_Is_Ignored (N, True);\n-                     Set_Is_Checked (N, False);\n+      --  An item declared in the body state space of a package always act as a\n+      --  constituent and does not need explicit Part_Of indicator.\n \n-                  when Name_On | Name_Check =>\n-                     Set_Is_Checked (N, True);\n-                     Set_Is_Ignored (N, False);\n+      --  In general an item declared in the visible state space of a package\n+      --  does not require a Part_Of indicator. The only exception is when the\n+      --  related package is a private child unit in which case Part_Of must\n+      --  denote a state in the parent unit or in one of its descendants.\n \n-                  when Name_Disable =>\n-                     Set_Is_Ignored  (N, True);\n-                     Set_Is_Checked  (N, False);\n-                     Set_Is_Disabled (N, True);\n+      if Placement = Visible_State_Space then\n+         if Is_Child_Unit (Pack_Id)\n+           and then Is_Private_Descendant (Pack_Id)\n+         then\n+            Error_Msg_N\n+              (\"indicator Part_Of is required in this context (SPARK RM \"\n+               & \"7.2.6(3))\", Item_Id);\n+            Error_Msg_Name_1 := Chars (Pack_Id);\n+            Error_Msg_N\n+              (\"\\& is declared in the visible part of private child unit %\",\n+               Item_Id);\n+         end if;\n \n-                  --  That should be exhaustive, the null here is a defence\n-                  --  against a malformed tree from previous errors.\n+      --  When the item appears in the private state space of a packge, it must\n+      --  be a part of some state declared by the said package.\n \n-                  when others =>\n-                     null;\n-               end case;\n+      elsif Placement = Private_State_Space then\n+         Error_Msg_N\n+           (\"indicator Part_Of is required in this context (SPARK RM \"\n+            & \"7.2.6(2))\", Item_Id);\n+         Error_Msg_Name_1 := Chars (Pack_Id);\n+         Error_Msg_N\n+           (\"\\& is declared in the private part of package %\", Item_Id);\n+      end if;\n+   end Check_Missing_Part_Of;\n \n-               return;\n+   -------------------------------------\n+   -- Check_State_And_Constituent_Use --\n+   -------------------------------------\n+\n+   procedure Check_State_And_Constituent_Use\n+     (States   : Elist_Id;\n+      Constits : Elist_Id;\n+      Context  : Node_Id)\n+   is\n+      function Find_Encapsulating_State\n+        (Constit_Id : Entity_Id) return Entity_Id;\n+      --  Given the entity of a constituent, try to find a corresponding\n+      --  encapsulating state that appears in the same context. The routine\n+      --  returns Empty is no such state is found.\n+\n+      ------------------------------\n+      -- Find_Encapsulating_State --\n+      ------------------------------\n+\n+      function Find_Encapsulating_State\n+        (Constit_Id : Entity_Id) return Entity_Id\n+      is\n+         State_Id : Entity_Id;\n+\n+      begin\n+         --  Since a constituent may be part of a larger constituent set, climb\n+         --  the encapsulated state chain looking for a state that appears in\n+         --  the same context.\n+\n+         State_Id := Encapsulating_State (Constit_Id);\n+         while Present (State_Id) loop\n+            if Contains (States, State_Id) then\n+               return State_Id;\n             end if;\n \n-            PP := Next_Pragma (PP);\n-         end;\n-      end loop;\n+            State_Id := Encapsulating_State (State_Id);\n+         end loop;\n \n-      --  If there are no specific entries that matched, then we let the\n-      --  setting of assertions govern. Note that this provides the needed\n-      --  compatibility with the RM for the cases of assertion, invariant,\n-      --  precondition, predicate, and postcondition.\n+         return Empty;\n+      end Find_Encapsulating_State;\n \n-      if Assertions_Enabled then\n-         Set_Is_Checked (N, True);\n-         Set_Is_Ignored (N, False);\n-      else\n-         Set_Is_Checked (N, False);\n-         Set_Is_Ignored (N, True);\n+      --  Local variables\n+\n+      Constit_Elmt : Elmt_Id;\n+      Constit_Id   : Entity_Id;\n+      State_Id     : Entity_Id;\n+\n+   --  Start of processing for Check_State_And_Constituent_Use\n+\n+   begin\n+      --  Nothing to do if there are no states or constituents\n+\n+      if No (States) or else No (Constits) then\n+         return;\n       end if;\n-   end Check_Applicable_Policy;\n+\n+      --  Inspect the list of constituents and try to determine whether its\n+      --  encapsulating state is in list States.\n+\n+      Constit_Elmt := First_Elmt (Constits);\n+      while Present (Constit_Elmt) loop\n+         Constit_Id := Node (Constit_Elmt);\n+\n+         --  Determine whether the constituent is part of an encapsulating\n+         --  state that appears in the same context and if this is the case,\n+         --  emit an error.\n+\n+         State_Id := Find_Encapsulating_State (Constit_Id);\n+\n+         if Present (State_Id) then\n+            Error_Msg_Name_1 := Chars (Constit_Id);\n+            Error_Msg_NE\n+              (\"cannot mention state & and its constituent % in the same \"\n+               & \"context (SPARK RM 7.2.6(7))\", Context, State_Id);\n+            exit;\n+         end if;\n+\n+         Next_Elmt (Constit_Elmt);\n+      end loop;\n+   end Check_State_And_Constituent_Use;\n \n    --------------------------\n    -- Collect_Global_Items --\n@@ -23949,6 +24601,7 @@ package body Sem_Prag is\n       Pragma_Ordered                        =>  0,\n       Pragma_Pack                           =>  0,\n       Pragma_Page                           => -1,\n+      Pragma_Part_Of                        => -1,\n       Pragma_Partition_Elaboration_Policy   => -1,\n       Pragma_Passive                        => -1,\n       Pragma_Persistent_BSS                 =>  0,\n@@ -24091,40 +24744,6 @@ package body Sem_Prag is\n       end if;\n    end Is_Non_Significant_Pragma_Reference;\n \n-   ----------------\n-   -- Is_Part_Of --\n-   ----------------\n-\n-   function Is_Part_Of\n-     (State    : Entity_Id;\n-      Ancestor : Entity_Id) return Boolean\n-   is\n-      Options : constant Node_Id := Parent (State);\n-      Name    : Node_Id;\n-      Option  : Node_Id;\n-      Value   : Node_Id;\n-\n-   begin\n-      --  A state declaration with option Part_Of appears as an extension\n-      --  aggregate with component associations.\n-\n-      if Nkind (Options) = N_Extension_Aggregate then\n-         Option := First (Component_Associations (Options));\n-         while Present (Option) loop\n-            Name  := First (Choices (Option));\n-            Value := Expression (Option);\n-\n-            if Chars (Name) = Name_Part_Of then\n-               return Entity (Value) = Ancestor;\n-            end if;\n-\n-            Next (Option);\n-         end loop;\n-      end if;\n-\n-      return False;\n-   end Is_Part_Of;\n-\n    ------------------------------\n    -- Is_Pragma_String_Literal --\n    ------------------------------"}, {"sha": "9e1d8b397b8761aec7eef7fd60d6ad786c935d67", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -139,6 +139,11 @@ package Sem_Prag is\n    --  is the related variable or state. Ensure legality of the combination and\n    --  issue an error for an illegal combination.\n \n+   procedure Check_Missing_Part_Of (Item_Id : Entity_Id);\n+   --  Determine whether the placement within the state space of an abstract\n+   --  state, variable or package instantiation denoted by Item_Id requires the\n+   --  use of indicator/option Part_Of. If this is the case, emit an error.\n+\n    function Delay_Config_Pragma_Analyze (N : Node_Id) return Boolean;\n    --  N is a pragma appearing in a configuration pragma file. Most such\n    --  pragmas are analyzed when the file is read, before parsing and analyzing"}, {"sha": "bfc2efeb7820cd83175ad9bcb56abacefb453c7b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 171, "deletions": 35, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -233,11 +233,12 @@ package body Sem_Util is\n \n       Nam := Original_Aspect_Name (Prag);\n \n-      --  Contract items related to [generic] packages. The applicable pragmas\n-      --  are:\n+      --  Contract items related to [generic] packages or instantiations. The\n+      --  applicable pragmas are:\n       --    Abstract_States\n       --    Initial_Condition\n       --    Initializes\n+      --    Part_Of (instantiation only)\n \n       if Ekind_In (Id, E_Generic_Package, E_Package) then\n          if Nam_In (Nam, Name_Abstract_State,\n@@ -247,6 +248,12 @@ package body Sem_Util is\n             Set_Next_Pragma (Prag, Classifications (Items));\n             Set_Classifications (Items, Prag);\n \n+         --  Indicator Part_Of must be associated with a package instantiation\n+\n+         elsif Nam = Name_Part_Of and then Is_Generic_Instance (Id) then\n+            Set_Next_Pragma (Prag, Classifications (Items));\n+            Set_Classifications (Items, Prag);\n+\n          --  The pragma is not a proper contract item\n \n          else\n@@ -355,12 +362,14 @@ package body Sem_Util is\n       --    Async_Writers\n       --    Effective_Reads\n       --    Effective_Writes\n+      --    Part_Of\n \n       elsif Ekind (Id) = E_Variable then\n          if Nam_In (Nam, Name_Async_Readers,\n                          Name_Async_Writers,\n                          Name_Effective_Reads,\n-                         Name_Effective_Writes)\n+                         Name_Effective_Writes,\n+                         Name_Part_Of)\n          then\n             Set_Next_Pragma (Prag, Classifications (Items));\n             Set_Classifications (Items, Prag);\n@@ -4201,6 +4210,7 @@ package body Sem_Util is\n                   Set_Defining_Unit_Name (N, Err);\n \n                   return Err;\n+\n                --  If not an entity, get defining identifier\n \n                else\n@@ -5827,6 +5837,75 @@ package body Sem_Util is\n       end if;\n    end Find_Parameter_Type;\n \n+   -----------------------------------\n+   -- Find_Placement_In_State_Space --\n+   -----------------------------------\n+\n+   procedure Find_Placement_In_State_Space\n+     (Item_Id   : Entity_Id;\n+      Placement : out State_Space_Kind;\n+      Pack_Id   : out Entity_Id)\n+   is\n+      Context : Entity_Id;\n+\n+   begin\n+      --  Assume that the item does not appear in the state space of a package\n+\n+      Pack_Id := Empty;\n+\n+      --  Climb the scope stack and examine the enclosing context\n+\n+      Context := Scope (Item_Id);\n+      while Present (Context) and then Context /= Standard_Standard loop\n+         if Ekind (Context) = E_Package then\n+            Pack_Id := Context;\n+\n+            --  A package body is a cut off point for the traversal as the item\n+            --  cannot be visible to the outside from this point on. Note that\n+            --  this test must be done first as a body is also classified as a\n+            --  private part.\n+\n+            if In_Package_Body (Context) then\n+               Placement := Body_State_Space;\n+               return;\n+\n+            --  The private part of a package is a cut off point for the\n+            --  traversal as the item cannot be visible to the outside from\n+            --  this point on.\n+\n+            elsif In_Private_Part (Context) then\n+               Placement := Private_State_Space;\n+               return;\n+\n+            --  When the item appears in the visible state space of a package,\n+            --  continue to climb the scope stack as this may not be the final\n+            --  state space.\n+\n+            else\n+               Placement := Visible_State_Space;\n+\n+               --  The visible state space of a private child unit acts as the\n+               --  proper placement of an item.\n+\n+               if Is_Child_Unit (Context)\n+                 and then Is_Private_Descendant (Context)\n+               then\n+                  return;\n+               end if;\n+            end if;\n+\n+         --  The item or its enclosing package appear in a construct that has\n+         --  no state space.\n+\n+         else\n+            Placement := Not_In_Package;\n+            return;\n+         end if;\n+\n+         Context := Scope (Context);\n+      end loop;\n+   end Find_Placement_In_State_Space;\n+\n    -----------------------------\n    -- Find_Static_Alternative --\n    -----------------------------\n@@ -8948,9 +9027,8 @@ package body Sem_Util is\n    -------------------------\n \n    function Is_Child_Or_Sibling\n-     (Pack_1        : Entity_Id;\n-      Pack_2        : Entity_Id;\n-      Private_Child : Boolean) return Boolean\n+     (Pack_1 : Entity_Id;\n+      Pack_2 : Entity_Id) return Boolean\n    is\n       function Distance_From_Standard (Pack : Entity_Id) return Nat;\n       --  Given an arbitrary package, return the number of \"climbs\" necessary\n@@ -8964,10 +9042,6 @@ package body Sem_Util is\n       --  climb the scope chain until the said depth is reached. The pointer\n       --  to the package and its depth a modified during the climb.\n \n-      function Is_Child (Pack : Entity_Id) return Boolean;\n-      --  Given a package Pack, determine whether it is a child package that\n-      --  satisfies the privacy requirement (if set).\n-\n       ----------------------------\n       -- Distance_From_Standard --\n       ----------------------------\n@@ -9011,26 +9085,6 @@ package body Sem_Util is\n          end loop;\n       end Equalize_Depths;\n \n-      --------------\n-      -- Is_Child --\n-      --------------\n-\n-      function Is_Child (Pack : Entity_Id) return Boolean is\n-      begin\n-         if Is_Child_Unit (Pack) then\n-            if Private_Child then\n-               return Is_Private_Descendant (Pack);\n-            else\n-               return True;\n-            end if;\n-\n-         --  The package is nested, it cannot act a child or a sibling\n-\n-         else\n-            return False;\n-         end if;\n-      end Is_Child;\n-\n       --  Local variables\n \n       P_1       : Entity_Id := Pack_1;\n@@ -9062,7 +9116,10 @@ package body Sem_Util is\n       --      P_1                P_1\n \n       elsif P_1_Depth > P_2_Depth then\n-         Equalize_Depths (P_1, P_1_Depth, P_2_Depth);\n+         Equalize_Depths\n+           (Pack           => P_1,\n+            Depth          => P_1_Depth,\n+            Depth_To_Reach => P_2_Depth);\n          P_1_Child := True;\n \n       --        (root)           P_1\n@@ -9072,7 +9129,10 @@ package body Sem_Util is\n       --             P_2         P_2\n \n       elsif P_2_Depth > P_1_Depth then\n-         Equalize_Depths (P_2, P_2_Depth, P_1_Depth);\n+         Equalize_Depths\n+           (Pack           => P_2,\n+            Depth          => P_2_Depth,\n+            Depth_To_Reach => P_1_Depth);\n          P_2_Child := True;\n       end if;\n \n@@ -9088,9 +9148,10 @@ package body Sem_Util is\n \n       if P_1 = P_2 then\n          if P_1_Child then\n-            return Is_Child (Pack_1);\n+            return Is_Child_Unit (Pack_1);\n+\n          else pragma Assert (P_2_Child);\n-            return Is_Child (Pack_2);\n+            return Is_Child_Unit (Pack_2);\n          end if;\n \n       --  The packages may come from the same package chain or from entirely\n@@ -9107,7 +9168,7 @@ package body Sem_Util is\n             --  The two packages may be siblings\n \n             if P_1 = P_2 then\n-               return Is_Child (Pack_1) and then Is_Child (Pack_2);\n+               return Is_Child_Unit (Pack_1) and then Is_Child_Unit (Pack_2);\n             end if;\n \n             P_1 := Scope (P_1);\n@@ -14554,6 +14615,81 @@ package body Sem_Util is\n       end if;\n    end Require_Entity;\n \n+   -------------------------------\n+   -- Requires_State_Refinement --\n+   -------------------------------\n+\n+   function Requires_State_Refinement\n+     (Spec_Id : Entity_Id;\n+      Body_Id : Entity_Id) return Boolean\n+   is\n+      function Mode_Is_Off (Prag : Node_Id) return Boolean;\n+      --  Given pragma SPARK_Mode, determine whether the mode is Off\n+\n+      -----------------\n+      -- Mode_Is_Off --\n+      -----------------\n+\n+      function Mode_Is_Off (Prag : Node_Id) return Boolean is\n+         Mode : Node_Id;\n+\n+      begin\n+         --  The default SPARK mode is On\n+\n+         if No (Prag) then\n+            return False;\n+         end if;\n+\n+         Mode := Get_Pragma_Arg (First (Pragma_Argument_Associations (Prag)));\n+\n+         --  Then the pragma lacks an argument, the default mode is On\n+\n+         if No (Mode) then\n+            return False;\n+         else\n+            return Chars (Mode) = Name_Off;\n+         end if;\n+      end Mode_Is_Off;\n+\n+   --  Start of processing for Requires_State_Refinement\n+\n+   begin\n+      --  A package that does not define at least one abstract state cannot\n+      --  possibly require refinement.\n+\n+      if No (Abstract_States (Spec_Id)) then\n+         return False;\n+\n+      --  The package instroduces a single null state which does not merit\n+      --  refinement.\n+\n+      elsif Has_Null_Abstract_State (Spec_Id) then\n+         return False;\n+\n+      --  Check whether the package body is subject to pragma SPARK_Mode. If\n+      --  it is and the mode is Off, the package body is considered to be in\n+      --  regular Ada and does not require refinement.\n+\n+      elsif Mode_Is_Off (SPARK_Pragma (Body_Id)) then\n+         return False;\n+\n+      --  The body's SPARK_Mode may be inherited from a similar pragma that\n+      --  appears in the private declarations of the spec. The pragma we are\n+      --  interested appears as the second entry in SPARK_Pragma.\n+\n+      elsif Present (SPARK_Pragma (Spec_Id))\n+        and then Mode_Is_Off (Next_Pragma (SPARK_Pragma (Spec_Id)))\n+      then\n+         return False;\n+\n+      --  The spec defines at least one abstract state and the body has no way\n+      --  of circumventing the refinement.\n+\n+      else\n+         return True;\n+      end if;\n+   end Requires_State_Refinement;\n+\n    ------------------------------\n    -- Requires_Transient_Scope --\n    ------------------------------"}, {"sha": "2fe44fc15a4dd93e1dc37d3b81ec20ccad3957e1", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 100, "deletions": 13, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -44,8 +44,9 @@ package Sem_Util is\n    --  freeze node of E.\n \n    procedure Add_Contract_Item (Prag : Node_Id; Id : Entity_Id);\n-   --  Add pragma Prag to the contract of an entry, a package [body] or a\n-   --  subprogram [body] denoted by Id. The following are valid pragmas:\n+   --  Add pragma Prag to the contract of an entry, a package [body], a\n+   --  subprogram [body] or variable denoted by Id. The following are valid\n+   --  pragmas:\n    --    Abstract_States\n    --    Async_Readers\n    --    Async_Writers\n@@ -56,6 +57,7 @@ package Sem_Util is\n    --    Global\n    --    Initial_Condition\n    --    Initializes\n+   --    Part_Of\n    --    Postcondition\n    --    Precondition\n    --    Refined_Depends\n@@ -571,6 +573,12 @@ package Sem_Util is\n    --  Call is set to the node for the corresponding call. If the node N is not\n    --  an actual parameter then Formal and Call are set to Empty.\n \n+   function Find_Body_Discriminal\n+     (Spec_Discriminant : Entity_Id) return Entity_Id;\n+   --  Given a discriminant of the record type that implements a task or\n+   --  protected type, return the discriminal of the corresponding discriminant\n+   --  of the actual concurrent type.\n+\n    function Find_Corresponding_Discriminant\n      (Id   : Node_Id;\n       Typ  : Entity_Id) return Entity_Id;\n@@ -600,17 +608,93 @@ package Sem_Util is\n    --  Return the type of formal parameter Param as determined by its\n    --  specification.\n \n+   --  The following type describes the placement of an arbitrary entity with\n+   --  respect to SPARK visible / hidden state space.\n+\n+   type State_Space_Kind is\n+     (Not_In_Package,\n+      --  An entity is not in the visible, private or body state space when\n+      --  the immediate enclosing construct is not a package.\n+\n+      Visible_State_Space,\n+      --  An entity is in the visible state space when it appears immediately\n+      --  within the visible declarations of a package or when it appears in\n+      --  the visible state space of a nested package which in turn is declared\n+      --  in the visible declarations of an enclosing package:\n+\n+      --    package Pack is\n+      --       Visible_Variable : ...\n+      --       package Nested\n+      --         with Abstract_State => Visible_State\n+      --       is\n+      --          Visible_Nested_Variable : ...\n+      --       end Nested;\n+      --    end Pack;\n+\n+      --  Entities associated with a package instantiation inherit the state\n+      --  space from the instance placement:\n+\n+      --     generic\n+      --     package Gen is\n+      --        Generic_Variable : ...\n+      --     end Gen;\n+\n+      --     with Gen;\n+      --     package Pack is\n+      --        package Inst is new Gen;\n+      --        --  Generic_Variable is in the visible state space of Pack\n+      --     end Pack;\n+\n+      Private_State_Space,\n+      --  An entity is in the private state space when it appears immediately\n+      --  within the private declarations of a package or when it appears in\n+      --  the visible state space of a nested package which in turn is declared\n+      --  in the private declarations of an enclosing package:\n+\n+      --    package Pack is\n+      --    private\n+      --       Private_Variable : ...\n+      --       package Nested\n+      --         with Abstract_State => Private_State\n+      --       is\n+      --          Private_Nested_Variable : ...\n+      --       end Nested;\n+      --    end Pack;\n+\n+      --  The same placement principle applies to package instantiations\n+\n+      Body_State_Space);\n+      --  An entity is in the body state space when it appears immediately\n+      --  within the declarations of a package body or when it appears in the\n+      --  visible state space of a nested package which in turn is declared in\n+      --  the declarations of an enclosing package body:\n+\n+      --    package body Pack is\n+      --       Body_Variable : ...\n+      --       package Nested\n+      --         with Abstract_State => Body_State\n+      --       is\n+      --          Body_Nested_Variable : ...\n+      --       end Nested;\n+      --    end Pack;\n+\n+      --  The same placement principle applies to package instantiations\n+\n+   procedure Find_Placement_In_State_Space\n+     (Item_Id   : Entity_Id;\n+      Placement : out State_Space_Kind;\n+      Pack_Id   : out Entity_Id);\n+   --  Determine the state space placement of an item. Item_Id denotes the\n+   --  entity of an abstract state, variable or package instantiation.\n+   --  Placement captures the precise placement of the item in the enclosing\n+   --  state space. If the state space is that of a package, Pack_Id denotes\n+   --  its entity, otherwise Pack_Id is Empty.\n+\n    function Find_Static_Alternative (N : Node_Id) return Node_Id;\n    --  N is a case statement whose expression is a compile-time value.\n    --  Determine the alternative chosen, so that the code of non-selected\n    --  alternatives, and the warnings that may apply to them, are removed.\n \n-   function Find_Body_Discriminal\n-     (Spec_Discriminant : Entity_Id) return Entity_Id;\n-   --  Given a discriminant of the record type that implements a task or\n-   --  protected type, return the discriminal of the corresponding discriminant\n-   --  of the actual concurrent type.\n-\n    function First_Actual (Node : Node_Id) return Node_Id;\n    --  Node is an N_Function_Call or N_Procedure_Call_Statement node. The\n    --  result returned is the first actual parameter in declaration order\n@@ -1006,14 +1090,11 @@ package Sem_Util is\n    --  Returns True if N is a call to a CPP constructor\n \n    function Is_Child_Or_Sibling\n-     (Pack_1        : Entity_Id;\n-      Pack_2        : Entity_Id;\n-      Private_Child : Boolean) return Boolean;\n+     (Pack_1 : Entity_Id;\n+      Pack_2 : Entity_Id) return Boolean;\n    --  Determine the following relations between two arbitrary packages:\n    --    1) One package is the parent of a child package\n    --    2) Both packages are siblings and share a common parent\n-   --  If flag Private_Child is set, then the child in case 1) or both siblings\n-   --  in case 2) must be private.\n \n    function Is_Concurrent_Interface (T : Entity_Id) return Boolean;\n    --  First determine whether type T is an interface and then check whether\n@@ -1540,6 +1621,12 @@ package Sem_Util is\n    --  This is used as a defense mechanism against ill-formed trees caused by\n    --  previous errors (particularly in -gnatq mode).\n \n+   function Requires_State_Refinement\n+     (Spec_Id : Entity_Id;\n+      Body_Id : Entity_Id) return Boolean;\n+   --  Determine whether a package denoted by its spec and body entities\n+   --  requires refinement of abstract states.\n+\n    function Requires_Transient_Scope (Id : Entity_Id) return Boolean;\n    --  Id is a type entity. The result is True when temporaries of this type\n    --  need to be wrapped in a transient scope to be reclaimed properly when a"}, {"sha": "8bd23356e2d0744723b363466aac3be95f731d12", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -7283,6 +7283,7 @@ package Sinfo is\n       --    Global\n       --    Initial_Condition\n       --    Initializes\n+      --    Part_Of\n       --    Refined_Depends\n       --    Refined_Global\n       --    Refined_States"}, {"sha": "2cf58f558ad069f8fd7253c2f05d3d0c644b9e97", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=d7af5ea5e1fa0a97b4cd7decf14cbcc9686b1524", "patch": "@@ -565,6 +565,7 @@ package Snames is\n    Name_Ordered                        : constant Name_Id := N + $; -- GNAT\n    Name_Pack                           : constant Name_Id := N + $;\n    Name_Page                           : constant Name_Id := N + $;\n+   Name_Part_Of                        : constant Name_Id := N + $; -- GNAT\n    Name_Passive                        : constant Name_Id := N + $; -- GNAT\n    Name_Post                           : constant Name_Id := N + $; -- GNAT\n    Name_Postcondition                  : constant Name_Id := N + $; -- GNAT\n@@ -761,7 +762,6 @@ package Snames is\n    Name_Optional                       : constant Name_Id := N + $;\n    Name_Policy                         : constant Name_Id := N + $;\n    Name_Parameter_Types                : constant Name_Id := N + $;\n-   Name_Part_Of                        : constant Name_Id := N + $;\n    Name_Proof_In                       : constant Name_Id := N + $;\n    Name_Reason                         : constant Name_Id := N + $;\n    Name_Reference                      : constant Name_Id := N + $;\n@@ -1870,6 +1870,7 @@ package Snames is\n       Pragma_Ordered,\n       Pragma_Pack,\n       Pragma_Page,\n+      Pragma_Part_Of,\n       Pragma_Passive,\n       Pragma_Post,\n       Pragma_Postcondition,"}]}