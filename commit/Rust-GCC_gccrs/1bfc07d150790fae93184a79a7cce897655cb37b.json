{"sha": "1bfc07d150790fae93184a79a7cce897655cb37b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJmYzA3ZDE1MDc5MGZhZTkzMTg0YTc5YTdjY2U4OTc2NTVjYjM3Yg==", "commit": {"author": {"name": "Kwok Cheung Yeung", "email": "kcy@codesourcery.com", "date": "2020-10-20T11:15:59Z"}, "committer": {"name": "Kwok Cheung Yeung", "email": "kcy@codesourcery.com", "date": "2020-10-20T11:16:26Z"}, "message": "openmp: Implement support for OMP_TARGET_OFFLOAD environment variable\n\nThis implements support for the OMP_TARGET_OFFLOAD environment variable\nintroduced in the OpenMP 5.0 standard, which controls how offloading\nis handled.  It may be set to MANDATORY (abort if offloading cannot be\nperformed), DISABLED (no offloading to devices) or DEFAULT (offload to\ndevice if possible, fall back to host if not).\n\n2020-10-20  Kwok Cheung Yeung  <kcy@codesourcery.com>\n\n\tlibgomp/\n\t* env.c (gomp_target_offload_var): New.\n\t(parse_target_offload): New.\n\t(handle_omp_display_env): Print value of OMP_TARGET_OFFLOAD.\n\t(initialize_env): Parse OMP_TARGET_OFFLOAD.\n\t* libgomp.h (gomp_target_offload_t): New.\n\t(gomp_target_offload_var): New.\n\t* libgomp.texi (OMP_TARGET_OFFLOAD): New section.\n\t* target.c (resolve_device): Generate error if device not found and\n\toffloading is mandatory.\n\t(gomp_target_fallback): Generate error if offloading is mandatory.\n\t(GOMP_target): Add argument in call to gomp_target_fallback.\n\t(GOMP_target_ext): Likewise.\n\t(gomp_target_data_fallback): Generate error if offloading is mandatory.\n\t(GOMP_target_data): Add argument in call to gomp_target_data_fallback.\n\t(GOMP_target_data_ext): Likewise.\n\t(gomp_target_task_fn): Add argument in call to gomp_target_fallback.\n\t(gomp_target_init): Return early if offloading is disabled.", "tree": {"sha": "6e596730698b9ed4a72930de00b3ed632e124436", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e596730698b9ed4a72930de00b3ed632e124436"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bfc07d150790fae93184a79a7cce897655cb37b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bfc07d150790fae93184a79a7cce897655cb37b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bfc07d150790fae93184a79a7cce897655cb37b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bfc07d150790fae93184a79a7cce897655cb37b/comments", "author": {"login": "k-yeung", "id": 16960193, "node_id": "MDQ6VXNlcjE2OTYwMTkz", "avatar_url": "https://avatars.githubusercontent.com/u/16960193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/k-yeung", "html_url": "https://github.com/k-yeung", "followers_url": "https://api.github.com/users/k-yeung/followers", "following_url": "https://api.github.com/users/k-yeung/following{/other_user}", "gists_url": "https://api.github.com/users/k-yeung/gists{/gist_id}", "starred_url": "https://api.github.com/users/k-yeung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/k-yeung/subscriptions", "organizations_url": "https://api.github.com/users/k-yeung/orgs", "repos_url": "https://api.github.com/users/k-yeung/repos", "events_url": "https://api.github.com/users/k-yeung/events{/privacy}", "received_events_url": "https://api.github.com/users/k-yeung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "k-yeung", "id": 16960193, "node_id": "MDQ6VXNlcjE2OTYwMTkz", "avatar_url": "https://avatars.githubusercontent.com/u/16960193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/k-yeung", "html_url": "https://github.com/k-yeung", "followers_url": "https://api.github.com/users/k-yeung/followers", "following_url": "https://api.github.com/users/k-yeung/following{/other_user}", "gists_url": "https://api.github.com/users/k-yeung/gists{/gist_id}", "starred_url": "https://api.github.com/users/k-yeung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/k-yeung/subscriptions", "organizations_url": "https://api.github.com/users/k-yeung/orgs", "repos_url": "https://api.github.com/users/k-yeung/repos", "events_url": "https://api.github.com/users/k-yeung/events{/privacy}", "received_events_url": "https://api.github.com/users/k-yeung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94fd05f1f76faca9dc9033b55d44c960155d38e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94fd05f1f76faca9dc9033b55d44c960155d38e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94fd05f1f76faca9dc9033b55d44c960155d38e9"}], "stats": {"total": 138, "additions": 130, "deletions": 8}, "files": [{"sha": "f305b14cf00649539eda4a7f95f2dc7016362f7d", "filename": "libgomp/env.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bfc07d150790fae93184a79a7cce897655cb37b/libgomp%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bfc07d150790fae93184a79a7cce897655cb37b/libgomp%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fenv.c?ref=1bfc07d150790fae93184a79a7cce897655cb37b", "patch": "@@ -75,6 +75,8 @@ struct gomp_task_icv gomp_global_icv = {\n \n unsigned long gomp_max_active_levels_var = gomp_supported_active_levels;\n bool gomp_cancel_var = false;\n+enum gomp_target_offload_t gomp_target_offload_var\n+  = GOMP_TARGET_OFFLOAD_DEFAULT;\n int gomp_max_task_priority_var = 0;\n #ifndef HAVE_SYNC_BUILTINS\n gomp_mutex_t gomp_managed_threads_lock;\n@@ -374,6 +376,48 @@ parse_unsigned_long_list (const char *name, unsigned long *p1stvalue,\n   return false;\n }\n \n+static void\n+parse_target_offload (const char *name, enum gomp_target_offload_t *offload)\n+{\n+  const char *env;\n+  bool found = false;\n+  enum gomp_target_offload_t new_offload;\n+\n+  env = getenv (name);\n+  if (env == NULL)\n+    return;\n+\n+  while (isspace ((unsigned char) *env))\n+    ++env;\n+  if (strncasecmp (env, \"default\", 7) == 0)\n+    {\n+      env += 7;\n+      found = true;\n+      new_offload = GOMP_TARGET_OFFLOAD_DEFAULT;\n+    }\n+  else if (strncasecmp (env, \"mandatory\", 9) == 0)\n+    {\n+      env += 9;\n+      found = true;\n+      new_offload = GOMP_TARGET_OFFLOAD_MANDATORY;\n+    }\n+  else if (strncasecmp (env, \"disabled\", 8) == 0)\n+    {\n+      env += 8;\n+      found = true;\n+      new_offload = GOMP_TARGET_OFFLOAD_DISABLED;\n+    }\n+  while (isspace ((unsigned char) *env))\n+    ++env;\n+  if (found && *env == '\\0')\n+    {\n+      *offload = new_offload;\n+      return;\n+    }\n+\n+  gomp_error (\"Invalid value for environment variable OMP_TARGET_OFFLOAD\");\n+}\n+\n /* Parse environment variable set to a boolean or list of omp_proc_bind_t\n    enum values.  Return true if one was present and it was successfully\n    parsed.  */\n@@ -1334,6 +1378,21 @@ handle_omp_display_env (unsigned long stacksize, int wait_policy)\n     }\n   fputs (\"'\\n\", stderr);\n \n+  fputs (\"  OMP_TARGET_OFFLOAD = '\", stderr);\n+  switch (gomp_target_offload_var)\n+    {\n+    case GOMP_TARGET_OFFLOAD_DEFAULT:\n+      fputs (\"DEFAULT\", stderr);\n+      break;\n+    case GOMP_TARGET_OFFLOAD_MANDATORY:\n+      fputs (\"MANDATORY\", stderr);\n+      break;\n+    case GOMP_TARGET_OFFLOAD_DISABLED:\n+      fputs (\"DISABLED\", stderr);\n+      break;\n+    }\n+  fputs (\"'\\n\", stderr);\n+\n   if (verbose)\n     {\n       fputs (\"  GOMP_CPU_AFFINITY = ''\\n\", stderr);\n@@ -1366,6 +1425,7 @@ initialize_env (void)\n   parse_boolean (\"OMP_CANCELLATION\", &gomp_cancel_var);\n   parse_boolean (\"OMP_DISPLAY_AFFINITY\", &gomp_display_affinity_var);\n   parse_int (\"OMP_DEFAULT_DEVICE\", &gomp_global_icv.default_device_var, true);\n+  parse_target_offload (\"OMP_TARGET_OFFLOAD\", &gomp_target_offload_var);\n   parse_int (\"OMP_MAX_TASK_PRIORITY\", &gomp_max_task_priority_var, true);\n   parse_unsigned_long (\"OMP_MAX_ACTIVE_LEVELS\", &gomp_max_active_levels_var,\n \t\t       true);"}, {"sha": "da7ac037dcd7d3b4959fea1209b21fe4b97c6000", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bfc07d150790fae93184a79a7cce897655cb37b/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bfc07d150790fae93184a79a7cce897655cb37b/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=1bfc07d150790fae93184a79a7cce897655cb37b", "patch": "@@ -434,6 +434,13 @@ struct gomp_task_icv\n   struct target_mem_desc *target_data;\n };\n \n+enum gomp_target_offload_t\n+{\n+  GOMP_TARGET_OFFLOAD_DEFAULT,\n+  GOMP_TARGET_OFFLOAD_MANDATORY,\n+  GOMP_TARGET_OFFLOAD_DISABLED\n+};\n+\n #define gomp_supported_active_levels INT_MAX\n \n extern struct gomp_task_icv gomp_global_icv;\n@@ -442,6 +449,7 @@ extern gomp_mutex_t gomp_managed_threads_lock;\n #endif\n extern unsigned long gomp_max_active_levels_var;\n extern bool gomp_cancel_var;\n+extern enum gomp_target_offload_t gomp_target_offload_var;\n extern int gomp_max_task_priority_var;\n extern unsigned long long gomp_spin_count_var, gomp_throttled_spin_count_var;\n extern unsigned long gomp_available_cpus, gomp_managed_threads;"}, {"sha": "7c6d5fd6efac2e4e6b9e840b594c7bba9e480329", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bfc07d150790fae93184a79a7cce897655cb37b/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bfc07d150790fae93184a79a7cce897655cb37b/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=1bfc07d150790fae93184a79a7cce897655cb37b", "patch": "@@ -1381,6 +1381,7 @@ beginning with @env{GOMP_} are GNU extensions.\n * OMP_PLACES::              Specifies on which CPUs the theads should be placed\n * OMP_STACKSIZE::           Set default thread stack size\n * OMP_SCHEDULE::            How threads are scheduled\n+* OMP_TARGET_OFFLOAD::      Controls offloading behaviour\n * OMP_THREAD_LIMIT::        Set the maximum number of threads\n * OMP_WAIT_POLICY::         How waiting threads are handled\n * GOMP_CPU_AFFINITY::       Bind threads to specific CPUs\n@@ -1654,6 +1655,30 @@ dynamic scheduling and a chunk size of 1 is used.\n \n \n \n+@node OMP_TARGET_OFFLOAD\n+@section @env{OMP_TARGET_OFFLOAD} -- Controls offloading behaviour\n+@cindex Environment Variable\n+@cindex Implementation specific setting\n+@table @asis\n+@item @emph{Description}:\n+Specifies the behaviour with regard to offloading code to a device.  This\n+variable can be set to one of three values - @code{MANDATORY}, @code{DISABLED}\n+or @code{DEFAULT}.\n+\n+If set to @code{MANDATORY}, the program will terminate with an error if\n+the offload device is not present or is not supported.  If set to\n+@code{DISABLED}, then offloading is disabled and all code will run on the\n+host. If set to @code{DEFAULT}, the program will try offloading to the\n+device first, then fall back to running code on the host if it cannot.\n+\n+If undefined, then the program will behave as if @code{DEFAULT} was set.\n+\n+@item @emph{Reference}:\n+@uref{https://www.openmp.org, OpenMP specification v5.0}, Section 6.17\n+@end table\n+\n+\n+\n @node OMP_THREAD_LIMIT\n @section @env{OMP_THREAD_LIMIT} -- Set the maximum number of threads\n @cindex Environment Variable"}, {"sha": "bb643b32c5945e52a6c2e36391c369ed9d8f81ba", "filename": "libgomp/target.c", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bfc07d150790fae93184a79a7cce897655cb37b/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bfc07d150790fae93184a79a7cce897655cb37b/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=1bfc07d150790fae93184a79a7cce897655cb37b", "patch": "@@ -116,14 +116,27 @@ resolve_device (int device_id)\n     }\n \n   if (device_id < 0 || device_id >= gomp_get_num_devices ())\n-    return NULL;\n+    {\n+      if (gomp_target_offload_var == GOMP_TARGET_OFFLOAD_MANDATORY\n+\t  && device_id != GOMP_DEVICE_HOST_FALLBACK)\n+\tgomp_fatal (\"OMP_TARGET_OFFLOAD is set to MANDATORY, \"\n+\t\t    \"but device not found\");\n+\n+      return NULL;\n+    }\n \n   gomp_mutex_lock (&devices[device_id].lock);\n   if (devices[device_id].state == GOMP_DEVICE_UNINITIALIZED)\n     gomp_init_device (&devices[device_id]);\n   else if (devices[device_id].state == GOMP_DEVICE_FINALIZED)\n     {\n       gomp_mutex_unlock (&devices[device_id].lock);\n+\n+      if (gomp_target_offload_var == GOMP_TARGET_OFFLOAD_MANDATORY\n+\t  && device_id != GOMP_DEVICE_HOST_FALLBACK)\n+\tgomp_fatal (\"OMP_TARGET_OFFLOAD is set to MANDATORY, \"\n+\t\t    \"but device is finalized\");\n+\n       return NULL;\n     }\n   gomp_mutex_unlock (&devices[device_id].lock);\n@@ -1997,9 +2010,16 @@ gomp_unload_device (struct gomp_device_descr *devicep)\n /* Host fallback for GOMP_target{,_ext} routines.  */\n \n static void\n-gomp_target_fallback (void (*fn) (void *), void **hostaddrs)\n+gomp_target_fallback (void (*fn) (void *), void **hostaddrs,\n+\t\t      struct gomp_device_descr *devicep)\n {\n   struct gomp_thread old_thr, *thr = gomp_thread ();\n+\n+  if (gomp_target_offload_var == GOMP_TARGET_OFFLOAD_MANDATORY\n+      && devicep != NULL)\n+    gomp_fatal (\"OMP_TARGET_OFFLOAD is set to MANDATORY, but device cannot \"\n+\t\t\"be used for offloading\");\n+\n   old_thr = *thr;\n   memset (thr, '\\0', sizeof (*thr));\n   if (gomp_places_list)\n@@ -2107,7 +2127,7 @@ GOMP_target (int device, void (*fn) (void *), const void *unused,\n       /* All shared memory devices should use the GOMP_target_ext function.  */\n       || devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM\n       || !(fn_addr = gomp_get_target_fn_addr (devicep, fn)))\n-    return gomp_target_fallback (fn, hostaddrs);\n+    return gomp_target_fallback (fn, hostaddrs, devicep);\n \n   struct target_mem_desc *tgt_vars\n     = gomp_map_vars (devicep, mapnum, hostaddrs, NULL, sizes, kinds, false,\n@@ -2243,7 +2263,7 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n \t\t\t\t      tgt_align, tgt_size);\n \t    }\n \t}\n-      gomp_target_fallback (fn, hostaddrs);\n+      gomp_target_fallback (fn, hostaddrs, devicep);\n       return;\n     }\n \n@@ -2276,9 +2296,15 @@ GOMP_target_ext (int device, void (*fn) (void *), size_t mapnum,\n /* Host fallback for GOMP_target_data{,_ext} routines.  */\n \n static void\n-gomp_target_data_fallback (void)\n+gomp_target_data_fallback (struct gomp_device_descr *devicep)\n {\n   struct gomp_task_icv *icv = gomp_icv (false);\n+\n+  if (gomp_target_offload_var == GOMP_TARGET_OFFLOAD_MANDATORY\n+      && devicep != NULL)\n+    gomp_fatal (\"OMP_TARGET_OFFLOAD is set to MANDATORY, but device cannot \"\n+\t\t\"be used for offloading\");\n+\n   if (icv->target_data)\n     {\n       /* Even when doing a host fallback, if there are any active\n@@ -2302,7 +2328,7 @@ GOMP_target_data (int device, const void *unused, size_t mapnum,\n   if (devicep == NULL\n       || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n       || (devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM))\n-    return gomp_target_data_fallback ();\n+    return gomp_target_data_fallback (devicep);\n \n   struct target_mem_desc *tgt\n     = gomp_map_vars (devicep, mapnum, hostaddrs, NULL, sizes, kinds, false,\n@@ -2321,7 +2347,7 @@ GOMP_target_data_ext (int device, size_t mapnum, void **hostaddrs,\n   if (devicep == NULL\n       || !(devicep->capabilities & GOMP_OFFLOAD_CAP_OPENMP_400)\n       || devicep->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n-    return gomp_target_data_fallback ();\n+    return gomp_target_data_fallback (devicep);\n \n   struct target_mem_desc *tgt\n     = gomp_map_vars (devicep, mapnum, hostaddrs, NULL, sizes, kinds, true,\n@@ -2617,7 +2643,7 @@ gomp_target_task_fn (void *data)\n \t  || (devicep->can_run_func && !devicep->can_run_func (fn_addr)))\n \t{\n \t  ttask->state = GOMP_TARGET_TASK_FALLBACK;\n-\t  gomp_target_fallback (ttask->fn, ttask->hostaddrs);\n+\t  gomp_target_fallback (ttask->fn, ttask->hostaddrs, devicep);\n \t  return false;\n \t}\n \n@@ -3258,6 +3284,9 @@ gomp_target_init (void)\n   num_devices = 0;\n   devices = NULL;\n \n+  if (gomp_target_offload_var == GOMP_TARGET_OFFLOAD_DISABLED)\n+    return;\n+\n   cur = OFFLOAD_PLUGINS;\n   if (*cur)\n     do"}]}