{"sha": "1825f9a2f484783311fb5672b127d2caedc79c13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgyNWY5YTJmNDg0NzgzMzExZmI1NjcyYjEyN2QyY2FlZGM3OWMxMw==", "commit": {"author": {"name": "Li Feng", "email": "nemokingdom@gmail.com", "date": "2009-11-25T04:48:51Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-11-25T04:48:51Z"}, "message": "re PR tree-optimization/41118 (Wrong dependence analysis in graphite for unrestricted pointers)\n\n2009-09-17 Li Feng  <nemokingdom@gmail.com>\n\n\tPR middle-end/41118\n\t* graphite-dependences.c (poly_drs_may_alias_p): Adjust definition.\n\t(pddr_original_scattering): Make sure 2 pdr2 in the same base object set.\n\t(graphite_carried_dependence_level_k): Ditto.\n\t* graphite-poly.c (new_poly_dr): Add init of PDR_BASE_OBJECT_SET.\n\t* graphite-poly.h (struct poly_dr): Add member dr_base_object_set.\n\t(new_poly_dr): Adjust declaration.\n\t* graphite-sese-to-poly.c (free_data_refs_aux): New.\n\t(free_gimple_bb): Added free_data_refs_aux.\n\t(build_poly_dr): Add dr_base_object_set.\n\t(partition_drs_to_sets): New.\n\t(dr_same_base_object_p): New.\n\t(build_alias_set_for_drs): New.\n\t(build_base_object_set_for_drs): New.\n\t(build_scop_drs): Add build_base_obj_set_for_drs.\n\t* graphite-sese-to-poly.h: Added #define for alias set number index and\n\tbase object set index.\n\t* libgomp/testsuite/libgomp.graphite/force-parallel-6.c: Refine tests.\n\t* libgomp/testsuite/libgomp.graphite/pr4118.c: New.\n\nFrom-SVN: r154549", "tree": {"sha": "c3a3e11e113cb3a461256142830a77efb4b05a37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3a3e11e113cb3a461256142830a77efb4b05a37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1825f9a2f484783311fb5672b127d2caedc79c13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1825f9a2f484783311fb5672b127d2caedc79c13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1825f9a2f484783311fb5672b127d2caedc79c13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1825f9a2f484783311fb5672b127d2caedc79c13/comments", "author": {"login": "LiFeng", "id": 117740, "node_id": "MDQ6VXNlcjExNzc0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/117740?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LiFeng", "html_url": "https://github.com/LiFeng", "followers_url": "https://api.github.com/users/LiFeng/followers", "following_url": "https://api.github.com/users/LiFeng/following{/other_user}", "gists_url": "https://api.github.com/users/LiFeng/gists{/gist_id}", "starred_url": "https://api.github.com/users/LiFeng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LiFeng/subscriptions", "organizations_url": "https://api.github.com/users/LiFeng/orgs", "repos_url": "https://api.github.com/users/LiFeng/repos", "events_url": "https://api.github.com/users/LiFeng/events{/privacy}", "received_events_url": "https://api.github.com/users/LiFeng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac90803f77eb8434a1a8531440b23fe30c35e050", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac90803f77eb8434a1a8531440b23fe30c35e050", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac90803f77eb8434a1a8531440b23fe30c35e050"}], "stats": {"total": 134, "additions": 108, "deletions": 26}, "files": [{"sha": "e4b593120f40dd5f5d359f415f16f7e7da574f31", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1825f9a2f484783311fb5672b127d2caedc79c13/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1825f9a2f484783311fb5672b127d2caedc79c13/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=1825f9a2f484783311fb5672b127d2caedc79c13", "patch": "@@ -1,3 +1,25 @@\n+2009-09-17 Li Feng  <nemokingdom@gmail.com>\n+\n+\tPR middle-end/41118\n+\t* graphite-dependences.c (poly_drs_may_alias_p): Adjust definition.\n+\t(pddr_original_scattering): Make sure 2 pdr2 in the same base object set.\n+\t(graphite_carried_dependence_level_k): Ditto.\n+\t* graphite-poly.c (new_poly_dr): Add init of PDR_BASE_OBJECT_SET.\n+\t* graphite-poly.h (struct poly_dr): Add member dr_base_object_set.\n+\t(new_poly_dr): Adjust declaration.\n+\t* graphite-sese-to-poly.c (free_data_refs_aux): New.\n+\t(free_gimple_bb): Added free_data_refs_aux.\n+\t(build_poly_dr): Add dr_base_object_set.\n+\t(partition_drs_to_sets): New.\n+\t(dr_same_base_object_p): New.\n+\t(build_alias_set_for_drs): New.\n+\t(build_base_object_set_for_drs): New.\n+\t(build_scop_drs): Add build_base_obj_set_for_drs.\n+\t* graphite-sese-to-poly.h: Added #define for alias set number index and\n+\tbase object set index.\n+\t* libgomp/testsuite/libgomp.graphite/force-parallel-6.c: Refine tests.\n+\t* libgomp/testsuite/libgomp.graphite/pr4118.c: New.\n+\n 2009-09-16  Alexander Monakov  <amonakov@ispras.ru>\n \n \t* graphite-sese-to-poly.c (pdr_add_data_dimensions): Add bounds only"}, {"sha": "f7b8c737daf1105e42c82a2e8a2cc34fb7a819e8", "filename": "gcc/graphite-dependences.c", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1825f9a2f484783311fb5672b127d2caedc79c13/gcc%2Fgraphite-dependences.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1825f9a2f484783311fb5672b127d2caedc79c13/gcc%2Fgraphite-dependences.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.c?ref=1825f9a2f484783311fb5672b127d2caedc79c13", "patch": "@@ -494,8 +494,12 @@ dependence_polyhedron (poly_bb_p pbb1, poly_bb_p pbb2,\n   return res;\n }\n \n+static bool\n+poly_drs_may_alias_p (poly_dr_p pdr1, poly_dr_p pdr2);\n+\n /* Returns the PDDR corresponding to the original schedule, or NULL if\n-   the dependence relation is empty.  */\n+   the dependence relation is empty or unknown (Can't judge dependency\n+   under polyhedral model.  */\n \n static poly_ddr_p\n pddr_original_scattering (poly_bb_p pbb1, poly_bb_p pbb2,\n@@ -507,8 +511,9 @@ pddr_original_scattering (poly_bb_p pbb1, poly_bb_p pbb2,\n   ppl_Polyhedron_t so1 = PBB_ORIGINAL_SCATTERING (pbb1);\n   ppl_Polyhedron_t so2 = PBB_ORIGINAL_SCATTERING (pbb2);\n \n-  if (PDR_NB_SUBSCRIPTS (pdr1) != PDR_NB_SUBSCRIPTS (pdr2)\n-      || (pdr_read_p (pdr1) && pdr_read_p (pdr2)))\n+  if ((pdr_read_p (pdr1) && pdr_read_p (pdr2))\n+      || PDR_BASE_OBJECT_SET (pdr1) != PDR_BASE_OBJECT_SET (pdr2)\n+      || PDR_NB_SUBSCRIPTS (pdr1) != PDR_NB_SUBSCRIPTS (pdr2))\n     return NULL;\n \n   pddr = dependence_polyhedron (pbb1, pbb2, d1, d2, pdr1, pdr2, so1, so2,\n@@ -706,14 +711,19 @@ graphite_carried_dependence_level_k (poly_dr_p pdr1, poly_dr_p pdr2,\n   ppl_dimension_type dim;\n   bool empty_p;\n   poly_ddr_p pddr;\n+  int obj_base_set1 = PDR_BASE_OBJECT_SET (pdr1);\n+  int obj_base_set2 = PDR_BASE_OBJECT_SET (pdr2);\n \n-  if ((PDR_TYPE (pdr1) == PDR_READ && PDR_TYPE (pdr2) == PDR_READ)\n+  if ((pdr_read_p (pdr1) && pdr_read_p (pdr2))\n       || !poly_drs_may_alias_p (pdr1, pdr2))\n     return false;\n \n-  if (PDR_NB_SUBSCRIPTS (pdr1) != PDR_NB_SUBSCRIPTS (pdr2))\n+  if (obj_base_set1 != obj_base_set2)\n     return true;\n \n+  if (PDR_NB_SUBSCRIPTS (pdr1) != PDR_NB_SUBSCRIPTS (pdr2))\n+    return false;\n+\n   pddr = dependence_polyhedron (pbb1, pbb2, d1, d2, pdr1, pdr2, so1, so2,\n \t\t\t\ttrue, false);\n "}, {"sha": "e06bb6dd8354ed8a2da75e0e4bb5e41d833330f2", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1825f9a2f484783311fb5672b127d2caedc79c13/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1825f9a2f484783311fb5672b127d2caedc79c13/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=1825f9a2f484783311fb5672b127d2caedc79c13", "patch": "@@ -307,14 +307,15 @@ pbb_remove_duplicate_pdrs (poly_bb_p pbb)\n    NB_SUBSCRIPTS.  */\n \n void\n-new_poly_dr (poly_bb_p pbb,\n+new_poly_dr (poly_bb_p pbb, int dr_base_object_set,\n \t     ppl_Pointset_Powerset_C_Polyhedron_t accesses,\n \t     enum poly_dr_type type, void *cdr, graphite_dim_t nb_subscripts)\n {\n   static int id = 0;\n   poly_dr_p pdr = XNEW (struct poly_dr);\n \n   PDR_ID (pdr) = id++;\n+  PDR_BASE_OBJECT_SET (pdr) = dr_base_object_set;\n   PDR_NB_REFS (pdr) = 1;\n   PDR_PBB (pdr) = pbb;\n   PDR_ACCESSES (pdr) = accesses;"}, {"sha": "a96d5c20a8a529d1ef4c60a32a453bde5223810f", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1825f9a2f484783311fb5672b127d2caedc79c13/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1825f9a2f484783311fb5672b127d2caedc79c13/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=1825f9a2f484783311fb5672b127d2caedc79c13", "patch": "@@ -72,13 +72,13 @@ struct poly_dr\n \n      The polyhedron contains these dimensions:\n \n-      - The alias set (a):\n-      Every memory access is classified in at least one alias set.\n+     - The alias set (a):\n+     Every memory access is classified in at least one alias set.\n \n-      - The subscripts (s_0, ..., s_n):\n-      The memory is accessed using zero or more subscript dimensions.\n+     - The subscripts (s_0, ..., s_n):\n+     The memory is accessed using zero or more subscript dimensions.\n \n-      - The iteration domain (variables and parameters)\n+     - The iteration domain (variables and parameters)\n \n      Do not hardcode the dimensions.  Use the following accessor functions:\n      - pdr_alias_set_dim\n@@ -135,6 +135,10 @@ struct poly_dr\n      | 0   0   0  -1   15  = 0 */\n   ppl_Pointset_Powerset_C_Polyhedron_t accesses;\n \n+  /* Data reference's base object set number, we must assure 2 pdrs are in the\n+     same base object set before dependency checking.  */\n+  int dr_base_object_set;\n+\n   /* The number of subscripts.  */\n   graphite_dim_t nb_subscripts;\n };\n@@ -145,9 +149,10 @@ struct poly_dr\n #define PDR_PBB(PDR) (PDR->pbb)\n #define PDR_TYPE(PDR) (PDR->type)\n #define PDR_ACCESSES(PDR) (PDR->accesses)\n+#define PDR_BASE_OBJECT_SET(PDR) (PDR->dr_base_object_set)\n #define PDR_NB_SUBSCRIPTS(PDR) (PDR->nb_subscripts)\n \n-void new_poly_dr (poly_bb_p, ppl_Pointset_Powerset_C_Polyhedron_t,\n+void new_poly_dr (poly_bb_p, int, ppl_Pointset_Powerset_C_Polyhedron_t,\n \t\t  enum poly_dr_type, void *, graphite_dim_t);\n void free_poly_dr (poly_dr_p);\n void debug_pdr (poly_dr_p);"}, {"sha": "e2c9cf8599f77c4034506e40fefb77b43528d18c", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 54, "deletions": 13, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1825f9a2f484783311fb5672b127d2caedc79c13/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1825f9a2f484783311fb5672b127d2caedc79c13/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=1825f9a2f484783311fb5672b127d2caedc79c13", "patch": "@@ -282,6 +282,20 @@ new_gimple_bb (basic_block bb, VEC (data_reference_p, heap) *drs)\n   return gbb;\n }\n \n+static void\n+free_data_refs_aux (VEC (data_reference_p, heap) *datarefs)\n+{\n+  unsigned int i;\n+  struct data_reference *dr;\n+\n+  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+    if (!dr->aux)\n+      {\n+\tfree (dr->aux);\n+\tdr->aux = NULL;\n+      }\n+}\n+\n /* Frees GBB.  */\n \n static void\n@@ -290,6 +304,7 @@ free_gimple_bb (struct gimple_bb *gbb)\n   if (GBB_CLOOG_IV_TYPES (gbb))\n     htab_delete (GBB_CLOOG_IV_TYPES (gbb));\n \n+  free_data_refs_aux (GBB_DATA_REFS (gbb));\n   free_data_refs (GBB_DATA_REFS (gbb));\n \n   VEC_free (gimple, heap, GBB_CONDITIONS (gbb));\n@@ -1546,11 +1561,7 @@ pdr_add_alias_set (ppl_Polyhedron_t accesses, data_reference_p dr,\n   int alias_set_num = 0;\n \n   if (dr->aux != NULL)\n-    {\n-      alias_set_num = *((int *)(dr->aux));\n-      free (dr->aux);\n-      dr->aux = NULL;\n-    }\n+    alias_set_num = ((int *)(dr->aux))[ALIAS_SET_INDEX];\n \n   ppl_new_Linear_Expression_with_dimension (&alias, accessp_nb_dims);\n \n@@ -1675,6 +1686,7 @@ build_poly_dr (data_reference_p dr, poly_bb_p pbb)\n   ppl_Pointset_Powerset_C_Polyhedron_t accesses_ps;\n   ppl_dimension_type dom_nb_dims;\n   ppl_dimension_type accessp_nb_dims;\n+  int dr_base_object_set;\n \n   ppl_Pointset_Powerset_C_Polyhedron_space_dimension (PBB_DOMAIN (pbb),\n \t\t\t\t\t\t      &dom_nb_dims);\n@@ -1689,14 +1701,17 @@ build_poly_dr (data_reference_p dr, poly_bb_p pbb)\n   ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron (&accesses_ps,\n \t\t\t\t\t\t\t    accesses);\n   ppl_delete_Polyhedron (accesses);\n-  new_poly_dr (pbb, accesses_ps, DR_IS_READ (dr) ? PDR_READ : PDR_WRITE, dr,\n-\t       DR_NUM_DIMENSIONS (dr));\n-}\n \n-/* Group each data reference in DRS with it's alias set num.  */\n+  dr_base_object_set = ((int *)(dr->aux))[BASE_OBJECT_SET_INDEX];\n+\n+  new_poly_dr (pbb, dr_base_object_set, accesses_ps, DR_IS_READ (dr) ? PDR_READ : PDR_WRITE,\n+\t       dr, DR_NUM_DIMENSIONS (dr));\n+}\n \n static void\n-build_alias_set_for_drs (VEC (data_reference_p, heap) **drs)\n+partition_drs_to_sets (VEC (data_reference_p, heap) **drs, int choice,\n+\t\t\t bool (* edge_exist_p) (const struct data_reference *,\n+\t\t\t\t\t\tconst struct data_reference *))\n {\n   int num_vertex = VEC_length (data_reference_p, *drs);\n   struct graph *g = new_graph (num_vertex);\n@@ -1707,7 +1722,7 @@ build_alias_set_for_drs (VEC (data_reference_p, heap) **drs)\n \n   for (i = 0; VEC_iterate (data_reference_p, *drs, i, dr1); i++)\n     for (j = i+1; VEC_iterate (data_reference_p, *drs, j, dr2); j++)\n-      if (dr_may_alias_p (dr1, dr2))\n+      if ((*edge_exist_p) (dr1, dr2))\n \t{\n \t  add_edge (g, i, j);\n \t  add_edge (g, j, i);\n@@ -1722,14 +1737,38 @@ build_alias_set_for_drs (VEC (data_reference_p, heap) **drs)\n   for (i = 0; i < g->n_vertices; i++)\n     {\n       data_reference_p dr = VEC_index (data_reference_p, *drs, i);\n-      dr->aux = XNEW (int);\n-      *((int *)(dr->aux)) = g->vertices[i].component + 1;\n+      if (!dr->aux)\n+\tdr->aux = XNEWVEC (int, 2);\n+      ((int *)(dr->aux))[choice] = g->vertices[i].component + 1;\n     }\n \n   free (queue);\n   free_graph (g);\n }\n \n+static bool\n+dr_same_base_object_p (const struct data_reference *dr1,\n+\t\t       const struct data_reference *dr2)\n+{\n+  return operand_equal_p (DR_BASE_OBJECT (dr1), DR_BASE_OBJECT (dr2), 0);\n+}\n+\n+/* Group each data reference in DRS with it's alias set num.  */\n+\n+static void\n+build_alias_set_for_drs (VEC (data_reference_p, heap) **drs)\n+{\n+  partition_drs_to_sets (drs, ALIAS_SET_INDEX, dr_may_alias_p);\n+}\n+\n+/* Group each data reference in DRS with it's base object set num.  */\n+\n+static void\n+build_base_obj_set_for_drs (VEC (data_reference_p, heap) **drs)\n+{\n+  partition_drs_to_sets (drs, BASE_OBJECT_SET_INDEX, dr_same_base_object_p);\n+}\n+\n /* Build the data references for PBB.  */\n \n static void\n@@ -1761,6 +1800,8 @@ build_scop_drs (scop_p scop)\n     }\n \n   build_alias_set_for_drs (&drs);\n+  build_base_obj_set_for_drs (&drs);\n+\n   VEC_free (data_reference_p, heap, drs);\n \n   for (i = 0; VEC_iterate (poly_bb_p, SCOP_BBS (scop), i, pbb); i++)"}, {"sha": "9379c14c208b011c8b28c23e77fd44bd6a10474a", "filename": "gcc/graphite-sese-to-poly.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1825f9a2f484783311fb5672b127d2caedc79c13/gcc%2Fgraphite-sese-to-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1825f9a2f484783311fb5672b127d2caedc79c13/gcc%2Fgraphite-sese-to-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.h?ref=1825f9a2f484783311fb5672b127d2caedc79c13", "patch": "@@ -21,6 +21,9 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_GRAPHITE_SESE_TO_POLY_H\n #define GCC_GRAPHITE_SESE_TO_POLY_H\n \n+#define ALIAS_SET_INDEX 0\n+#define BASE_OBJECT_SET_INDEX 1\n+\n bool build_poly_scop (scop_p);\n void check_poly_representation (scop_p);\n "}, {"sha": "dcaaf4814b7af794cc65c7c9c856dcc4858f4f4b", "filename": "libgomp/testsuite/libgomp.graphite/force-parallel-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1825f9a2f484783311fb5672b127d2caedc79c13/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1825f9a2f484783311fb5672b127d2caedc79c13/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.graphite%2Fforce-parallel-6.c?ref=1825f9a2f484783311fb5672b127d2caedc79c13", "patch": "@@ -31,7 +31,7 @@ int main(void)\n }\n \n /* Check that parallel code generation part make the right answer.  */\n-/* { dg-final { scan-tree-dump-times \"1 loops carried no dependency\" 2 \"graphite\" } } */\n+/* { dg-final { scan-tree-dump-times \"1 loops carried no dependency\" 1 \"graphite\" } } */\n /* { dg-final { cleanup-tree-dump \"graphite\" } } */\n /* { dg-final { scan-tree-dump-times \"loopfn.0\" 5 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"parloops\" } } */"}]}