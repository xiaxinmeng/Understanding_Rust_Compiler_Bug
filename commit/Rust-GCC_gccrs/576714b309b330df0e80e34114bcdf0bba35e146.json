{"sha": "576714b309b330df0e80e34114bcdf0bba35e146", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc2NzE0YjMwOWIzMzBkZjBlODBlMzQxMTRiY2RmMGJiYTM1ZTE0Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-01-05T15:35:22Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-01-05T15:35:22Z"}, "message": "phiopt: Optimize x < 0 ? ~y : y to (x >> 31) ^ y [PR96928]\n\nAs requested in the PR, the one's complement abs can be done more\nefficiently without cmov or branching.\n\nHad to change the ifcvt-onecmpl-abs-1.c testcase, we no longer optimize\nit in ifcvt, on x86_64 with -m32 we generate in the end the exact same\ncode, but with -m64:\n        movl    %edi, %eax\n-       notl    %eax\n-       cmpl    %edi, %eax\n-       cmovl   %edi, %eax\n+       sarl    $31, %eax\n+       xorl    %edi, %eax\n        ret\n\n2021-01-05  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/96928\n\t* tree-ssa-phiopt.c (xor_replacement): New function.\n\t(tree_ssa_phiopt_worker): Call it.\n\n\t* gcc.dg/tree-ssa/pr96928.c: New test.\n\t* gcc.target/i386/ifcvt-onecmpl-abs-1.c: Remove -fdump-rtl-ce1,\n\tinstead of scanning rtl dump for ifcvt message check assembly\n\tfor xor instruction.", "tree": {"sha": "61e31f861adc2c8993b85149f5081881f620b0dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61e31f861adc2c8993b85149f5081881f620b0dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/576714b309b330df0e80e34114bcdf0bba35e146", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/576714b309b330df0e80e34114bcdf0bba35e146", "html_url": "https://github.com/Rust-GCC/gccrs/commit/576714b309b330df0e80e34114bcdf0bba35e146", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/576714b309b330df0e80e34114bcdf0bba35e146/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ca2400270e985f9b33d93007f4d831299b9bda7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ca2400270e985f9b33d93007f4d831299b9bda7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ca2400270e985f9b33d93007f4d831299b9bda7"}], "stats": {"total": 150, "additions": 148, "deletions": 2}, "files": [{"sha": "209135726912bbdd2cfb0bb9db846a0e0eeb2419", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr96928.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/576714b309b330df0e80e34114bcdf0bba35e146/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr96928.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/576714b309b330df0e80e34114bcdf0bba35e146/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr96928.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr96928.c?ref=576714b309b330df0e80e34114bcdf0bba35e146", "patch": "@@ -0,0 +1,38 @@\n+/* PR tree-optimization/96928 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-phiopt2\" } */\n+/* { dg-final { scan-tree-dump-times \" = a_\\[0-9]*\\\\\\(D\\\\\\) >> \" 5 \"phiopt2\" } } */\n+/* { dg-final { scan-tree-dump-times \" = ~c_\\[0-9]*\\\\\\(D\\\\\\);\" 1 \"phiopt2\" } } */\n+/* { dg-final { scan-tree-dump-times \" = ~\" 1 \"phiopt2\" } } */\n+/* { dg-final { scan-tree-dump-times \" = \\[abc_0-9\\\\\\(\\\\\\)D]* \\\\\\^ \" 5 \"phiopt2\" } } */\n+/* { dg-final { scan-tree-dump-not \"a < 0\" \"phiopt2\" } } */\n+\n+int\n+foo (int a)\n+{\n+  return a < 0 ? ~a : a;\n+}\n+\n+int\n+bar (int a, int b)\n+{\n+  return a < 0 ? ~b : b;\n+}\n+\n+unsigned\n+baz (int a, unsigned int b)\n+{\n+  return a < 0 ? ~b : b;\n+}\n+\n+unsigned\n+qux (int a, unsigned int c)\n+{\n+  return a >= 0 ? ~c : c;\n+}\n+\n+int\n+corge (int a, int b)\n+{\n+  return a >= 0 ? b : ~b;\n+}"}, {"sha": "6e02dd7a7e8df0db489db670ab0fc4e8925e3ef3", "filename": "gcc/testsuite/gcc.target/i386/ifcvt-onecmpl-abs-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/576714b309b330df0e80e34114bcdf0bba35e146/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fifcvt-onecmpl-abs-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/576714b309b330df0e80e34114bcdf0bba35e146/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fifcvt-onecmpl-abs-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fifcvt-onecmpl-abs-1.c?ref=576714b309b330df0e80e34114bcdf0bba35e146", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-rtl-ce1\" } */\n+/* { dg-options \"-O2\" } */\n \n /* Check code generation for one's complement version of abs */\n \n@@ -10,4 +10,4 @@ int onecmplabs(int x)\n   return x;\n }\n \n-/* { dg-final { scan-rtl-dump \"succeeded through noce_try_abs\" \"ce1\" } } */\n+/* { dg-final { scan-assembler \"\\txor\" } } */"}, {"sha": "bbc78af6996d6f81eae9c220e8d2b4d34a20d2ae", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/576714b309b330df0e80e34114bcdf0bba35e146/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/576714b309b330df0e80e34114bcdf0bba35e146/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=576714b309b330df0e80e34114bcdf0bba35e146", "patch": "@@ -62,6 +62,8 @@ static bool minmax_replacement (basic_block, basic_block,\n \t\t\t\tedge, edge, gimple *, tree, tree);\n static bool abs_replacement (basic_block, basic_block,\n \t\t\t     edge, edge, gimple *, tree, tree);\n+static bool xor_replacement (basic_block, basic_block,\n+\t\t\t     edge, edge, gimple *, tree, tree);\n static bool cond_removal_in_popcount_clz_ctz_pattern (basic_block, basic_block,\n \t\t\t\t\t\t      edge, edge, gimple *,\n \t\t\t\t\t\t      tree, tree);\n@@ -345,6 +347,9 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads, bool early_p)\n \t    cfgchanged = true;\n \t  else if (abs_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n \t    cfgchanged = true;\n+\t  else if (!early_p\n+\t\t   && xor_replacement (bb, bb1, e1, e2, phi, arg0, arg1))\n+\t    cfgchanged = true;\n \t  else if (!early_p\n \t\t   && cond_removal_in_popcount_clz_ctz_pattern (bb, bb1, e1,\n \t\t\t\t\t\t\t\te2, phi, arg0,\n@@ -2098,6 +2103,109 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n   return true;\n }\n \n+/* Optimize x < 0 ? ~y : y into (x >> (prec-1)) ^ y.  */\n+\n+static bool\n+xor_replacement (basic_block cond_bb, basic_block middle_bb,\n+\t\t edge e0 ATTRIBUTE_UNUSED, edge e1,\n+\t\t gimple *phi, tree arg0, tree arg1)\n+{\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (arg1)))\n+    return false;\n+\n+  /* OTHER_BLOCK must have only one executable statement which must have the\n+     form arg0 = ~arg1 or arg1 = ~arg0.  */\n+\n+  gimple *assign = last_and_only_stmt (middle_bb);\n+  /* If we did not find the proper one's complement assignment, then we cannot\n+     optimize.  */\n+  if (assign == NULL)\n+    return false;\n+\n+  /* If we got here, then we have found the only executable statement\n+     in OTHER_BLOCK.  If it is anything other than arg = ~arg1 or\n+     arg1 = ~arg0, then we cannot optimize.  */\n+  if (!is_gimple_assign (assign))\n+    return false;\n+\n+  if (gimple_assign_rhs_code (assign) != BIT_NOT_EXPR)\n+    return false;\n+\n+  tree lhs = gimple_assign_lhs (assign);\n+  tree rhs = gimple_assign_rhs1 (assign);\n+\n+  /* The assignment has to be arg0 = -arg1 or arg1 = -arg0.  */\n+  if (!(lhs == arg0 && rhs == arg1) && !(lhs == arg1 && rhs == arg0))\n+    return false;\n+\n+  gimple *cond = last_stmt (cond_bb);\n+  tree result = PHI_RESULT (phi);\n+\n+  /* Only relationals comparing arg[01] against zero are interesting.  */\n+  enum tree_code cond_code = gimple_cond_code (cond);\n+  if (cond_code != LT_EXPR && cond_code != GE_EXPR)\n+    return false;\n+\n+  /* Make sure the conditional is x OP 0.  */\n+  tree clhs = gimple_cond_lhs (cond);\n+  if (TREE_CODE (clhs) != SSA_NAME\n+      || !INTEGRAL_TYPE_P (TREE_TYPE (clhs))\n+      || TYPE_UNSIGNED (TREE_TYPE (clhs))\n+      || TYPE_PRECISION (TREE_TYPE (clhs)) != TYPE_PRECISION (TREE_TYPE (arg1))\n+      || !integer_zerop (gimple_cond_rhs (cond)))\n+    return false;\n+\n+  /* We need to know which is the true edge and which is the false\n+     edge so that we know if have xor or inverted xor.  */\n+  edge true_edge, false_edge;\n+  extract_true_false_edges_from_block (cond_bb, &true_edge, &false_edge);\n+\n+  /* For GE_EXPR, if the true edge goes to OTHER_BLOCK, then we\n+     will need to invert the result.  Similarly for LT_EXPR if\n+     the false edge goes to OTHER_BLOCK.  */\n+  edge e;\n+  if (cond_code == GE_EXPR)\n+    e = true_edge;\n+  else\n+    e = false_edge;\n+\n+  bool invert = e->dest == middle_bb;\n+\n+  result = duplicate_ssa_name (result, NULL);\n+\n+  gimple_stmt_iterator gsi = gsi_last_bb (cond_bb);\n+\n+  int prec = TYPE_PRECISION (TREE_TYPE (clhs));\n+  gimple *new_stmt\n+    = gimple_build_assign (make_ssa_name (TREE_TYPE (clhs)), RSHIFT_EXPR, clhs,\n+\t\t\t   build_int_cst (integer_type_node, prec - 1));\n+  gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n+\n+  if (!useless_type_conversion_p (TREE_TYPE (result), TREE_TYPE (clhs)))\n+    {\n+      new_stmt = gimple_build_assign (make_ssa_name (TREE_TYPE (result)),\n+\t\t\t\t      NOP_EXPR, gimple_assign_lhs (new_stmt));\n+      gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n+    }\n+  lhs = gimple_assign_lhs (new_stmt);\n+\n+  if (invert)\n+    {\n+      new_stmt = gimple_build_assign (make_ssa_name (TREE_TYPE (result)),\n+\t\t\t\t      BIT_NOT_EXPR, rhs);\n+      gsi_insert_before (&gsi, new_stmt, GSI_SAME_STMT);\n+      rhs = gimple_assign_lhs (new_stmt);\n+    }\n+\n+  new_stmt = gimple_build_assign (result, BIT_XOR_EXPR, lhs, rhs);\n+  gsi_insert_before (&gsi, new_stmt, GSI_NEW_STMT);\n+\n+  replace_phi_edge_with_variable (cond_bb, e1, phi, result);\n+\n+  /* Note that we optimized this PHI.  */\n+  return true;\n+}\n+\n /* Auxiliary functions to determine the set of memory accesses which\n    can't trap because they are preceded by accesses to the same memory\n    portion.  We do that for MEM_REFs, so we only need to track"}]}