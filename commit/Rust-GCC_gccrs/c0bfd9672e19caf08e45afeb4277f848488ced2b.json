{"sha": "c0bfd9672e19caf08e45afeb4277f848488ced2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBiZmQ5NjcyZTE5Y2FmMDhlNDVhZmViNDI3N2Y4NDg0ODhjZWQyYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-30T08:57:02Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-30T09:46:08Z"}, "message": "tree-optimization/97633 - fix SLP scheduling of single-node cycles\n\nThis makes sure to update backedges in single-node cycles.\n\n2020-10-30  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/97633\n\t* tree-vect-slp.c (): Update backedges in single-node cycles.\n\tOptimize processing of externals.\n\n\t* g++.dg/vect/slp-pr97636.cc: New testcase.\n\t* gcc.dg/vect/bb-slp-pr97633.c: Likewise.", "tree": {"sha": "642a29ab93daa78a76c13bc16834256c655c653c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/642a29ab93daa78a76c13bc16834256c655c653c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0bfd9672e19caf08e45afeb4277f848488ced2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0bfd9672e19caf08e45afeb4277f848488ced2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0bfd9672e19caf08e45afeb4277f848488ced2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0bfd9672e19caf08e45afeb4277f848488ced2b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7de23b8c536397117bbea04a722fa1b86564dd7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7de23b8c536397117bbea04a722fa1b86564dd7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7de23b8c536397117bbea04a722fa1b86564dd7c"}], "stats": {"total": 272, "additions": 198, "deletions": 74}, "files": [{"sha": "012342004f1191848329b4a2181b78f61c14968a", "filename": "gcc/testsuite/g++.dg/vect/slp-pr97636.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0bfd9672e19caf08e45afeb4277f848488ced2b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fslp-pr97636.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0bfd9672e19caf08e45afeb4277f848488ced2b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fslp-pr97636.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fslp-pr97636.cc?ref=c0bfd9672e19caf08e45afeb4277f848488ced2b", "patch": "@@ -0,0 +1,83 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target c++17 } */\n+\n+struct u {\n+  int b;\n+  int c;\n+  template <typename d, typename e> u(d, e);\n+};\n+template <class, class> struct f { u g; };\n+template <class h, class i> class v {\n+  typedef f<h, i> k;\n+  k *l[4];\n+  k m;\n+public:\n+  v(h, h);\n+  void aa(h, i);\n+};\n+template <class h, class i> void v<h, i>::aa(h, i) { n(&l[1], &m); }\n+template <class h, class i> void n(f<h, i> **o, f<h, i> *ab) {\n+  bool p, r;\n+  f q = **o;\n+  f<h, i> *t;\n+  h a = q.g;\n+  h b = t->g;\n+  if (r)\n+    ;\n+  else\n+    goto ac;\n+s:\n+  p = a.b || a.c < b.c;\n+  if (p)\n+    goto s;\n+ac:\n+  ab->g = b;\n+  b = t->g;\n+  goto s;\n+}\n+template <class, class, class> class w {};\n+template <class> class x;\n+template <class, class> class z;\n+class ad {\n+public:\n+  template <typename, typename y, typename ae, typename af, typename ag>\n+  static void ah(const z<y, ae> &, const z<y, af> &, x<ag> *&);\n+};\n+template <typename, typename y, typename ae, typename af, typename ag>\n+void ad::ah(const z<y, ae> &ai, const z<y, af> &aj, x<ag> *&) {\n+  u c(0, 0), d(0, 0), g(aj, ai);\n+  v<u, y> e(c, d);\n+  e.aa(g, 0);\n+}\n+template <class, class> class ak;\n+template <class, class, class al, class am, class an>\n+void ao(ak<al, am> ap, ak<al, an> aq) {\n+  x<double> *f;\n+  ad::ah<int>(*ap.ar, *aq.ar, f);\n+}\n+template <typename, typename, typename al, typename am, typename an,\n+          typename as, typename at>\n+void au(w<al, am, as> ap, w<al, an, at> aq) {\n+  ao<int, double>(static_cast<as &>(ap), static_cast<at &>(aq));\n+}\n+template <class, class> class z {};\n+template <class, class> class ak : public w<int, int, ak<int, int>> {\n+public:\n+  z<int, int> *ar;\n+};\n+template <class, class, class> class av;\n+template <typename, typename, typename, typename al, typename am, typename an,\n+          typename aw, typename ax>\n+void ay(av<al, am, aw>, av<al, an, ax>) {\n+  aw h, i;\n+  au<int, double>(h, i);\n+}\n+template <class, class, class> class av {};\n+class az {\n+public:\n+  typedef av<int, double, ak<int, double>> ba;\n+};\n+int main() {\n+  az::ba j, k;\n+  ay<int, double, az>(j, k);\n+}"}, {"sha": "ab0ae1de9c98e86013800d17531e10d3eab9be49", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr97633.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0bfd9672e19caf08e45afeb4277f848488ced2b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr97633.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0bfd9672e19caf08e45afeb4277f848488ced2b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr97633.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr97633.c?ref=c0bfd9672e19caf08e45afeb4277f848488ced2b", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+\n+extern short i (void);\n+\n+struct {\n+  short a;\n+  short b;\n+} c;\n+\n+int d, e;\n+static int f = 1;\n+\n+void g () {\n+  if (e) {\n+    if (f)\n+      goto L;\n+    while (d) {\n+      i ();\n+      short j = d, k = i (), l = k;\n+    L:\n+      if (!(d && e) || l)\n+        goto L;\n+      c.a = j;\n+      c.b = k;\n+    }\n+  }\n+}"}, {"sha": "714e50697bd5c6f3104710794fa33cf3703c9011", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 88, "deletions": 74, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0bfd9672e19caf08e45afeb4277f848488ced2b/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0bfd9672e19caf08e45afeb4277f848488ced2b/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=c0bfd9672e19caf08e45afeb4277f848488ced2b", "patch": "@@ -5554,97 +5554,114 @@ vect_schedule_scc (vec_info *vinfo, slp_tree node, slp_instance instance,\n   gcc_assert (!existed_p);\n   info->dfs = maxdfs;\n   info->lowlink = maxdfs;\n-  info->on_stack = true;\n   maxdfs++;\n+\n+  /* Leaf.  */\n+  if (SLP_TREE_DEF_TYPE (node) != vect_internal_def)\n+    {\n+      info->on_stack = false;\n+      vect_schedule_slp_node (vinfo, node, instance);\n+      return;\n+    }\n+\n+  info->on_stack = true;\n   stack.safe_push (node);\n+\n   unsigned i;\n   slp_tree child;\n-\n-  /* ???  We're keeping SLP_TREE_CHILDREN of externalized nodes.  */\n-  if (SLP_TREE_DEF_TYPE (node) == vect_internal_def)\n-    FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-      {\n-\tif (!child)\n-\t  continue;\n-\tslp_scc_info *child_info = scc_info.get (child);\n-\tif (!child_info)\n-\t  {\n-\t    vect_schedule_scc (vinfo, child, instance, scc_info, maxdfs, stack);\n-\t    /* Recursion might have re-allocated the node.  */\n-\t    info = scc_info.get (node);\n-\t    child_info = scc_info.get (child);\n-\t    info->lowlink = MIN (info->lowlink, child_info->lowlink);\n-\t  }\n-\telse if (child_info->on_stack)\n-\t  info->lowlink = MIN (info->lowlink, child_info->dfs);\n-      }\n+  /* DFS recurse.  */\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+    {\n+      if (!child)\n+\tcontinue;\n+      slp_scc_info *child_info = scc_info.get (child);\n+      if (!child_info)\n+\t{\n+\t  vect_schedule_scc (vinfo, child, instance, scc_info, maxdfs, stack);\n+\t  /* Recursion might have re-allocated the node.  */\n+\t  info = scc_info.get (node);\n+\t  child_info = scc_info.get (child);\n+\t  info->lowlink = MIN (info->lowlink, child_info->lowlink);\n+\t}\n+      else if (child_info->on_stack)\n+\tinfo->lowlink = MIN (info->lowlink, child_info->dfs);\n+    }\n   if (info->lowlink != info->dfs)\n     return;\n \n+  auto_vec<slp_tree, 4> phis_to_fixup;\n+\n   /* Singleton.  */\n   if (stack.last () == node)\n     {\n       stack.pop ();\n       info->on_stack = false;\n       vect_schedule_slp_node (vinfo, node, instance);\n-      return;\n+      if (SLP_TREE_CODE (node) != VEC_PERM_EXPR\n+\t  && is_a <gphi *> (SLP_TREE_REPRESENTATIVE (node)->stmt))\n+\tphis_to_fixup.quick_push (node);\n     }\n-  /* SCC.  */\n-  int last_idx = stack.length () - 1;\n-  while (stack[last_idx] != node)\n-    last_idx--;\n-  /* We can break the cycle at PHIs who have at least one child\n-     code generated.  Then we could re-start the DFS walk until\n-     all nodes in the SCC are covered (we might have new entries\n-     for only back-reachable nodes).  But it's simpler to just\n-     iterate and schedule those that are ready.  */\n-  auto_vec<slp_tree, 4> phis_to_fixup;\n-  unsigned todo = stack.length () - last_idx;\n-  do\n+  else\n     {\n-      for (int idx = stack.length () - 1; idx >= last_idx; --idx)\n+      /* SCC.  */\n+      int last_idx = stack.length () - 1;\n+      while (stack[last_idx] != node)\n+\tlast_idx--;\n+      /* We can break the cycle at PHIs who have at least one child\n+\t code generated.  Then we could re-start the DFS walk until\n+\t all nodes in the SCC are covered (we might have new entries\n+\t for only back-reachable nodes).  But it's simpler to just\n+\t iterate and schedule those that are ready.  */\n+      unsigned todo = stack.length () - last_idx;\n+      do\n \t{\n-\t  slp_tree entry = stack[idx];\n-\t  if (!entry)\n-\t    continue;\n-\t  bool phi = (SLP_TREE_CODE (entry) != VEC_PERM_EXPR\n-\t\t      && is_a <gphi *> (SLP_TREE_REPRESENTATIVE (entry)->stmt));\n-\t  bool ready = !phi;\n-\t  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (entry), i, child)\n-\t    if (!child)\n-\t      {\n-\t\tgcc_assert (phi);\n-\t\tready = true;\n-\t\tbreak;\n-\t      }\n-\t    else if (scc_info.get (child)->on_stack)\n-\t      {\n-\t\tif (!phi)\n-\t\t  {\n-\t\t    ready = false;\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t    else\n-\t      {\n-\t\tif (phi)\n-\t\t  {\n-\t\t    ready = true;\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t  if (ready)\n+\t  for (int idx = stack.length () - 1; idx >= last_idx; --idx)\n \t    {\n-\t      vect_schedule_slp_node (vinfo, entry, instance);\n-\t      scc_info.get (entry)->on_stack = false;\n-\t      stack[idx] = NULL;\n-\t      todo--;\n-\t      if (phi)\n-\t\tphis_to_fixup.safe_push (entry);\n+\t      slp_tree entry = stack[idx];\n+\t      if (!entry)\n+\t\tcontinue;\n+\t      bool phi = (SLP_TREE_CODE (entry) != VEC_PERM_EXPR\n+\t\t\t  && is_a <gphi *> (SLP_TREE_REPRESENTATIVE (entry)->stmt));\n+\t      bool ready = !phi;\n+\t      FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (entry), i, child)\n+\t\t  if (!child)\n+\t\t    {\n+\t\t      gcc_assert (phi);\n+\t\t      ready = true;\n+\t\t      break;\n+\t\t    }\n+\t\t  else if (scc_info.get (child)->on_stack)\n+\t\t    {\n+\t\t      if (!phi)\n+\t\t\t{\n+\t\t\t  ready = false;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (phi)\n+\t\t\t{\n+\t\t\t  ready = true;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    }\n+\t      if (ready)\n+\t\t{\n+\t\t  vect_schedule_slp_node (vinfo, entry, instance);\n+\t\t  scc_info.get (entry)->on_stack = false;\n+\t\t  stack[idx] = NULL;\n+\t\t  todo--;\n+\t\t  if (phi)\n+\t\t    phis_to_fixup.safe_push (entry);\n+\t\t}\n \t    }\n \t}\n+      while (todo != 0);\n+\n+      /* Pop the SCC.  */\n+      stack.truncate (last_idx);\n     }\n-  while (todo != 0);\n \n   /* Now fixup the backedge def of the vectorized PHIs in this SCC.  */\n   slp_tree phi_node;\n@@ -5666,9 +5683,6 @@ vect_schedule_scc (vec_info *vinfo, slp_tree node, slp_instance instance,\n \t\t\t e, gimple_phi_arg_location (phi, dest_idx));\n \t}\n     }\n-\n-  /* Pop the SCC.  */\n-  stack.truncate (last_idx);\n }\n \n /* Generate vector code for SLP_INSTANCES in the loop/basic block.  */"}]}