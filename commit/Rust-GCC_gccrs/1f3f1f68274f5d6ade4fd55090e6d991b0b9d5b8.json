{"sha": "1f3f1f68274f5d6ade4fd55090e6d991b0b9d5b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYzZjFmNjgyNzRmNWQ2YWRlNGZkNTUwOTBlNmQ5OTFiMGI5ZDViOA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2006-10-23T20:24:55Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2006-10-23T20:24:55Z"}, "message": "re PR middle-end/29335 (transcendental functions with constant arguments should be resolved at compile-time)\n\n\tPR middle-end/29335\n\t* builtins.c (fold_builtin_sin, fold_builtin_cos,\n\tfold_builtin_tan): Fold all constant arguments.  Take a \"type\"\n\targument as necessary.\n\t(do_mpfr_arg1): New.\n\t* real.c, real.h (real_from_mpfr, mpfr_from_real): New.\n\nFrom-SVN: r117983", "tree": {"sha": "35df1b444a1a341b02054010ef5e197a40f91be3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35df1b444a1a341b02054010ef5e197a40f91be3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f3f1f68274f5d6ade4fd55090e6d991b0b9d5b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3f1f68274f5d6ade4fd55090e6d991b0b9d5b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f3f1f68274f5d6ade4fd55090e6d991b0b9d5b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3f1f68274f5d6ade4fd55090e6d991b0b9d5b8/comments", "author": null, "committer": null, "parents": [{"sha": "b544aa7b959e4b9a8b1420bc11dd5ff6fdc419bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b544aa7b959e4b9a8b1420bc11dd5ff6fdc419bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b544aa7b959e4b9a8b1420bc11dd5ff6fdc419bf"}], "stats": {"total": 149, "additions": 128, "deletions": 21}, "files": [{"sha": "8e31f4b5e57beddd4605eac37667680299b1a3ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3f1f68274f5d6ade4fd55090e6d991b0b9d5b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3f1f68274f5d6ade4fd55090e6d991b0b9d5b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f3f1f68274f5d6ade4fd55090e6d991b0b9d5b8", "patch": "@@ -1,3 +1,12 @@\n+2006-10-23  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\tPR middle-end/29335\n+\t* builtins.c (fold_builtin_sin, fold_builtin_cos,\n+\tfold_builtin_tan): Fold all constant arguments.  Take a \"type\"\n+\targument as necessary.\n+\t(do_mpfr_arg1): New.\n+\t* real.c, real.h (real_from_mpfr, mpfr_from_real): New.\n+\n 2006-10-23  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/lib1funcs.asm: Use C-style comments."}, {"sha": "2d517f5449e37928f4b7da1dcd6f48cacd0027d5", "filename": "gcc/builtins.c", "status": "modified", "additions": 67, "deletions": 21, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3f1f68274f5d6ade4fd55090e6d991b0b9d5b8/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3f1f68274f5d6ade4fd55090e6d991b0b9d5b8/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1f3f1f68274f5d6ade4fd55090e6d991b0b9d5b8", "patch": "@@ -150,9 +150,9 @@ static tree fold_builtin_sqrt (tree, tree);\n static tree fold_builtin_cbrt (tree, tree);\n static tree fold_builtin_pow (tree, tree, tree);\n static tree fold_builtin_powi (tree, tree, tree);\n-static tree fold_builtin_sin (tree);\n+static tree fold_builtin_sin (tree, tree);\n static tree fold_builtin_cos (tree, tree, tree);\n-static tree fold_builtin_tan (tree);\n+static tree fold_builtin_tan (tree, tree);\n static tree fold_builtin_atan (tree, tree);\n static tree fold_builtin_trunc (tree, tree);\n static tree fold_builtin_floor (tree, tree);\n@@ -205,6 +205,7 @@ static unsigned HOST_WIDE_INT target_s;\n static char target_percent_c[3];\n static char target_percent_s[3];\n static char target_percent_s_newline[4];\n+static tree do_mpfr_arg1 (tree, tree, int (*)(mpfr_ptr, mpfr_srcptr, mp_rnd_t));\n \n /* Return true if NODE should be considered for inline expansion regardless\n    of the optimization level.  This means whenever a function is invoked with\n@@ -7206,17 +7207,17 @@ fold_builtin_cbrt (tree arglist, tree type)\n /* Fold function call to builtin sin, sinf, or sinl.  Return\n    NULL_TREE if no simplification can be made.  */\n static tree\n-fold_builtin_sin (tree arglist)\n+fold_builtin_sin (tree arglist, tree type)\n {\n-  tree arg = TREE_VALUE (arglist);\n+  tree arg = TREE_VALUE (arglist), res;\n \n   if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n     return NULL_TREE;\n \n-  /* Optimize sin (0.0) = 0.0.  */\n-  if (real_zerop (arg))\n-    return arg;\n-\n+  /* Calculate the result when the argument is a constant.  */\n+  if ((res = do_mpfr_arg1 (arg, type, mpfr_sin)))\n+    return res;\n+  \n   return NULL_TREE;\n }\n \n@@ -7225,15 +7226,15 @@ fold_builtin_sin (tree arglist)\n static tree\n fold_builtin_cos (tree arglist, tree type, tree fndecl)\n {\n-  tree arg = TREE_VALUE (arglist);\n+  tree arg = TREE_VALUE (arglist), res;\n \n   if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n     return NULL_TREE;\n \n-  /* Optimize cos (0.0) = 1.0.  */\n-  if (real_zerop (arg))\n-    return build_real (type, dconst1);\n-\n+  /* Calculate the result when the argument is a constant.  */\n+  if ((res = do_mpfr_arg1 (arg, type, mpfr_cos)))\n+    return res;\n+  \n   /* Optimize cos(-x) into cos (x).  */\n   if (TREE_CODE (arg) == NEGATE_EXPR)\n     {\n@@ -7248,18 +7249,18 @@ fold_builtin_cos (tree arglist, tree type, tree fndecl)\n /* Fold function call to builtin tan, tanf, or tanl.  Return\n    NULL_TREE if no simplification can be made.  */\n static tree\n-fold_builtin_tan (tree arglist)\n+fold_builtin_tan (tree arglist, tree type)\n {\n   enum built_in_function fcode;\n-  tree arg = TREE_VALUE (arglist);\n+  tree arg = TREE_VALUE (arglist), res;\n \n   if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n     return NULL_TREE;\n \n-  /* Optimize tan(0.0) = 0.0.  */\n-  if (real_zerop (arg))\n-    return arg;\n-\n+  /* Calculate the result when the argument is a constant.  */\n+  if ((res = do_mpfr_arg1 (arg, type, mpfr_tan)))\n+    return res;\n+  \n   /* Optimize tan(atan(x)) = x.  */\n   fcode = builtin_mathfn_code (arg);\n   if (flag_unsafe_math_optimizations\n@@ -9039,7 +9040,7 @@ fold_builtin_1 (tree fndecl, tree arglist, bool ignore)\n       return fold_builtin_cbrt (arglist, type);\n \n     CASE_FLT_FN (BUILT_IN_SIN):\n-      return fold_builtin_sin (arglist);\n+      return fold_builtin_sin (arglist, type);\n \n     CASE_FLT_FN (BUILT_IN_COS):\n       return fold_builtin_cos (arglist, type, fndecl);\n@@ -9064,7 +9065,7 @@ fold_builtin_1 (tree fndecl, tree arglist, bool ignore)\n       return fold_builtin_logarithm (fndecl, arglist, &dconst10);\n \n     CASE_FLT_FN (BUILT_IN_TAN):\n-      return fold_builtin_tan (arglist);\n+      return fold_builtin_tan (arglist, type);\n \n     CASE_FLT_FN (BUILT_IN_ATAN):\n       return fold_builtin_atan (arglist, type);\n@@ -11278,3 +11279,48 @@ init_target_chars (void)\n     }\n   return true;\n }\n+\n+/* If argument ARG is a REAL_CST, call the one-argument mpfr function\n+   FUNC on it and return the resulting value as a tree with type TYPE.\n+   The mpfr precision is set to the precision of TYPE.  We assume that\n+   function FUNC returns zero if the result could be calculated\n+   exactly within the requested precision.  */\n+\n+static tree\n+do_mpfr_arg1 (tree arg, tree type, int (*func)(mpfr_ptr, mpfr_srcptr, mp_rnd_t))\n+{\n+  tree result = NULL_TREE;\n+  \n+  STRIP_NOPS (arg);\n+\n+  if (TREE_CODE (arg) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg))\n+    {\n+      REAL_VALUE_TYPE r = TREE_REAL_CST (arg);\n+\n+      if (!real_isnan (&r) && !real_isinf (&r))\n+        {\n+\t  const enum machine_mode mode = TYPE_MODE (type);\n+\t  const int prec = REAL_MODE_FORMAT (mode)->p;\n+\t  int exact;\n+\t  mpfr_t m;\n+\n+\t  mpfr_init2 (m, prec);\n+\t  mpfr_from_real (m, &r);\n+\t  exact = func (m, m, GMP_RNDN);\n+\n+\t  /* Proceed iff we get a normal number, i.e. not NaN or Inf.\n+\t     If -frounding-math is set, proceed iff the result of\n+\t     calling FUNC was exact, i.e. FUNC returned zero.  */\n+\t  if (mpfr_number_p (m)\n+\t      && (! flag_rounding_math || exact == 0))\n+\t    {\n+\t      real_from_mpfr (&r, m);\n+\t      real_convert (&r, mode, &r);\n+\t      result = build_real (type, r);\n+\t    }\n+\t  mpfr_clear (m);\n+\t}\n+    }\n+  \n+  return result;\n+}"}, {"sha": "68cb71ba8436de74a1f0593422d4b277dcfb047d", "filename": "gcc/real.c", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3f1f68274f5d6ade4fd55090e6d991b0b9d5b8/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3f1f68274f5d6ade4fd55090e6d991b0b9d5b8/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=1f3f1f68274f5d6ade4fd55090e6d991b0b9d5b8", "patch": "@@ -4922,3 +4922,47 @@ real_copysign (REAL_VALUE_TYPE *r, const REAL_VALUE_TYPE *x)\n   r->sign = x->sign;\n }\n \n+/* Convert from REAL_VALUE_TYPE to MPFR.  The caller is responsible\n+   for initializing and clearing the MPFR parmeter.  */\n+\n+void\n+mpfr_from_real (mpfr_ptr m, const REAL_VALUE_TYPE *r)\n+{\n+  /* We use a string as an intermediate type.  */\n+  char buf[128];\n+\n+  real_to_hexadecimal (buf, r, sizeof (buf), 0, 1);\n+  /* mpfr_set_str() parses hexadecimal floats from strings in the same\n+     format that GCC will output them.  Nothing extra is needed.  */\n+  gcc_assert (mpfr_set_str (m, buf, 16, GMP_RNDN) == 0);\n+}\n+\n+/* Convert from MPFR to REAL_VALUE_TYPE.  */\n+\n+void\n+real_from_mpfr (REAL_VALUE_TYPE *r, mpfr_srcptr m)\n+{\n+  /* We use a string as an intermediate type.  */\n+  char buf[128], *rstr;\n+  mp_exp_t exp;\n+\n+  rstr = mpfr_get_str (NULL, &exp, 16, 0, m, GMP_RNDN);\n+\n+  /* The additional 12 chars add space for the sprintf below.  This\n+     leaves 6 digits for the exponent which is supposedly enough.  */\n+  gcc_assert (rstr != NULL && strlen (rstr) < sizeof (buf) - 12);\n+\n+  /* REAL_VALUE_ATOF expects the exponent for mantissa * 2**exp,\n+     mpfr_get_str returns the exponent for mantissa * 16**exp, adjust\n+     for that.  */\n+  exp *= 4;\n+\n+  if (rstr[0] == '-')\n+    sprintf (buf, \"-0x.%sp%d\", &rstr[1], (int) exp);\n+  else\n+    sprintf (buf, \"0x.%sp%d\", rstr, (int) exp);\n+\n+  mpfr_free_str (rstr);\n+  \n+  real_from_string (r, buf);\n+}"}, {"sha": "5a45892d301613d365e7672e3fe09e5fc1b22a54", "filename": "gcc/real.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f3f1f68274f5d6ade4fd55090e6d991b0b9d5b8/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f3f1f68274f5d6ade4fd55090e6d991b0b9d5b8/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=1f3f1f68274f5d6ade4fd55090e6d991b0b9d5b8", "patch": "@@ -22,6 +22,8 @@\n #ifndef GCC_REAL_H\n #define GCC_REAL_H\n \n+#include <gmp.h>\n+#include <mpfr.h>\n #include \"machmode.h\"\n \n /* An expanded form of the represented number.  */\n@@ -425,4 +427,10 @@ extern void real_round (REAL_VALUE_TYPE *, enum machine_mode,\n /* Set the sign of R to the sign of X.  */\n extern void real_copysign (REAL_VALUE_TYPE *, const REAL_VALUE_TYPE *);\n \n+/* Convert between MPFR and REAL_VALUE_TYPE.  The caller is\n+   responsible for initializing and clearing the MPFR parameter.  */\n+\n+extern void real_from_mpfr (REAL_VALUE_TYPE *, mpfr_srcptr);\n+extern void mpfr_from_real (mpfr_ptr, const REAL_VALUE_TYPE *);\n+\n #endif /* ! GCC_REAL_H */"}]}