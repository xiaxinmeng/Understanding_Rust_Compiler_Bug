{"sha": "e69529cd536c79f1849f271e230e0b61fede7b84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY5NTI5Y2Q1MzZjNzlmMTg0OWYyNzFlMjMwZTBiNjFmZWRlN2I4NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-06-24T16:50:29Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-06-24T16:50:29Z"}, "message": "Makefile.in (cgraph.o): Depend on output.h, not depend on tree-inline.h\n\n\t* Makefile.in (cgraph.o): Depend on output.h, not depend on\n\ttree-inline.h\n\t* cgraph.c: Do not include tree-inline.h; include output.h\n\t(known_fns): Rename to ...\n\t(known_decls): ... this one; update all uses.\n\t(cgraph_varpool_hash): New static variable.\n\t(cgraph_varpool_n_nodes, cgraph_varpool_nodes_queue): New global\n\tvariables.\n\t(cgraph_varpool_hash_node, eq_cgraph_varpool_node, cgraph_varpool_node,\n\tcgraph_varpool_node_for_identifier, cgraph_varpool_mark_needed_node,\n\tcgraph_varpool_finalize_decl, cgraph_varpool_assemble_pending_decls):\n\tNew functions.\n\t* cgraph.h (cgraph_varpool_node): New structure.\n\t(cgraph_varpool_n_nodes, cgraph_varpool_nodes_queue): Declare.\n\t(cgraph_varpool_node, cgraph_varpool_node_for_identifier,\n\tcgraph_varpool_finalize_decl, cgraph_varpool_mark_needed_node,\n\tcgraph_varpool_asemble_pending_decls): Declare.\n\t* cgraphunit.c (record_call_1): Notice variable references.\n\t(cgraph_finalize_compilation_unit): Assemble pending variables.\n\t* toplev.c (wrapup_global_declarations): Use varpool.\n\t(compile_file): Assemble pending declarations.\n\t(rest_of_decl_compilation): Use varpool in unit-at-a-time mode.\n\t* varasm.c (assemble_name): Notice varpool references.\n\nFrom-SVN: r68426", "tree": {"sha": "6d104fc83b2d07c080d44ba705184072c8821bf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d104fc83b2d07c080d44ba705184072c8821bf6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e69529cd536c79f1849f271e230e0b61fede7b84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e69529cd536c79f1849f271e230e0b61fede7b84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e69529cd536c79f1849f271e230e0b61fede7b84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e69529cd536c79f1849f271e230e0b61fede7b84/comments", "author": null, "committer": null, "parents": [{"sha": "6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6df5158a36cb2b8c5f6642f0208648c1ea2d5786", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6df5158a36cb2b8c5f6642f0208648c1ea2d5786"}], "stats": {"total": 238, "additions": 227, "deletions": 11}, "files": [{"sha": "49b6a2474ce492f2c8514f681bdcfa5b68b995c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69529cd536c79f1849f271e230e0b61fede7b84/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69529cd536c79f1849f271e230e0b61fede7b84/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e69529cd536c79f1849f271e230e0b61fede7b84", "patch": "@@ -1,3 +1,29 @@\n+Tue Jun 24 18:49:33 CEST 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* Makefile.in (cgraph.o): Depend on output.h, not depend on\n+\ttree-inline.h\n+\t* cgraph.c: Do not include tree-inline.h; include output.h\n+\t(known_fns): Rename to ...\n+\t(known_decls): ... this one; update all uses.\n+\t(cgraph_varpool_hash): New static variable.\n+\t(cgraph_varpool_n_nodes, cgraph_varpool_nodes_queue): New global\n+\tvariables.\n+\t(cgraph_varpool_hash_node, eq_cgraph_varpool_node, cgraph_varpool_node,\n+\tcgraph_varpool_node_for_identifier, cgraph_varpool_mark_needed_node,\n+\tcgraph_varpool_finalize_decl, cgraph_varpool_assemble_pending_decls):\n+\tNew functions.\n+\t* cgraph.h (cgraph_varpool_node): New structure.\n+\t(cgraph_varpool_n_nodes, cgraph_varpool_nodes_queue): Declare.\n+\t(cgraph_varpool_node, cgraph_varpool_node_for_identifier,\n+\tcgraph_varpool_finalize_decl, cgraph_varpool_mark_needed_node,\n+\tcgraph_varpool_asemble_pending_decls): Declare.\n+\t* cgraphunit.c (record_call_1): Notice variable references.\n+\t(cgraph_finalize_compilation_unit): Assemble pending variables.\n+\t* toplev.c (wrapup_global_declarations): Use varpool.\n+\t(compile_file): Assemble pending declarations.\n+\t(rest_of_decl_compilation): Use varpool in unit-at-a-time mode.\n+\t* varasm.c (assemble_name): Notice varpool references.\n+\n Tue Jun 24 13:52:11 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* langhooks-def.h (LANG_HOOKS_PREPARE_ASSEMBLE_VARIABLE): New macro."}, {"sha": "0f34373128d411bed8ea2fbfbd2c1ccffbf3a193", "filename": "gcc/cgraph.c", "status": "modified", "additions": 145, "deletions": 8, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69529cd536c79f1849f271e230e0b61fede7b84/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69529cd536c79f1849f271e230e0b61fede7b84/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=e69529cd536c79f1849f271e230e0b61fede7b84", "patch": "@@ -24,7 +24,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n-#include \"tree-inline.h\"\n #include \"langhooks.h\"\n #include \"hashtab.h\"\n #include \"toplev.h\"\n@@ -34,13 +33,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"target.h\"\n #include \"cgraph.h\"\n #include \"varray.h\"\n+#include \"output.h\"\n \n /* The known declarations must not get garbage collected.  Callgraph\n    datastructures should not get saved via PCH code since this would\n    make it difficult to extend into intra-module optimizer later.  So\n    we store only the references into the array to prevent gabrage\n    collector from deleting live data.  */\n-static GTY(()) varray_type known_fns;\n+static GTY(()) varray_type known_decls;\n \n /* Hash table used to convert declarations into nodes.  */\n static htab_t cgraph_hash = 0;\n@@ -57,6 +57,15 @@ int cgraph_n_nodes;\n /* Set when whole unit has been analyzed so we can access global info.  */\n bool cgraph_global_info_ready = false;\n \n+/* Hash table used to convert declarations into nodes.  */\n+static htab_t cgraph_varpool_hash = 0;\n+\n+/* Queue of cgraph nodes scheduled to be lowered and output.  */\n+struct cgraph_varpool_node *cgraph_varpool_nodes_queue;\n+\n+/* Number of nodes in existence.  */\n+int cgraph_varpool_n_nodes;\n+\n static struct cgraph_edge *create_edge PARAMS ((struct cgraph_node *,\n \t\t\t\t\t\tstruct cgraph_node *));\n static void cgraph_remove_edge PARAMS ((struct cgraph_node *, struct cgraph_node *));\n@@ -99,7 +108,7 @@ cgraph_node (decl)\n   if (!cgraph_hash)\n     {\n       cgraph_hash = htab_create (10, hash_node, eq_node, NULL);\n-      VARRAY_TREE_INIT (known_fns, 32, \"known_fns\");\n+      VARRAY_TREE_INIT (known_decls, 32, \"known_decls\");\n     }\n \n   slot =\n@@ -125,7 +134,7 @@ cgraph_node (decl)\n       node->next_nested = node->origin->nested;\n       node->origin->nested = node;\n     }\n-  VARRAY_PUSH_TREE (known_fns, decl);\n+  VARRAY_PUSH_TREE (known_decls, decl);\n   return node;\n }\n \n@@ -140,10 +149,7 @@ cgraph_node_for_identifier (id)\n     abort ();\n \n   if (!cgraph_hash)\n-    {\n-      cgraph_hash = htab_create (10, hash_node, eq_node, NULL);\n-      VARRAY_TREE_INIT (known_fns, 32, \"known_fns\");\n-    }\n+    return NULL;\n \n   slot =\n     (struct cgraph_node **) htab_find_slot_with_hash (cgraph_hash, id,\n@@ -356,4 +362,135 @@ dump_cgraph (f)\n     }\n }\n \n+/* Returns a hash code for P.  */\n+\n+static hashval_t\n+cgraph_varpool_hash_node (const PTR p)\n+{\n+  return (hashval_t)\n+    htab_hash_pointer (DECL_ASSEMBLER_NAME\n+\t\t       (((struct cgraph_varpool_node *) p)->decl));\n+}\n+\n+/* Returns non-zero if P1 and P2 are equal.  */\n+\n+static int\n+eq_cgraph_varpool_node (const PTR p1, const PTR p2)\n+{\n+  return ((DECL_ASSEMBLER_NAME (((struct cgraph_varpool_node *) p1)->decl)) ==\n+\t  (tree) p2);\n+}\n+\n+/* Return cgraph_varpool node assigned to DECL.  Create new one when needed.  */\n+struct cgraph_varpool_node *\n+cgraph_varpool_node (tree decl)\n+{\n+  struct cgraph_varpool_node *node;\n+  struct cgraph_varpool_node **slot;\n+\n+  if (!DECL_P (decl) || TREE_CODE (decl) == FUNCTION_DECL)\n+    abort ();\n+\n+  if (!cgraph_varpool_hash)\n+    {\n+      cgraph_varpool_hash = htab_create (10, cgraph_varpool_hash_node, eq_cgraph_varpool_node, NULL);\n+      VARRAY_TREE_INIT (known_decls, 32, \"known_decls\");\n+    }\n+\n+  slot =\n+    (struct cgraph_varpool_node **) htab_find_slot_with_hash (cgraph_varpool_hash,\n+\t\t\t\t\t\t      DECL_ASSEMBLER_NAME (decl),\n+\t\t\t\t\t\t      htab_hash_pointer\n+\t\t\t\t\t\t      (DECL_ASSEMBLER_NAME\n+\t\t\t\t\t\t       (decl)), 1);\n+  if (*slot)\n+    return *slot;\n+  node = xcalloc (sizeof (*node), 1);\n+  node->decl = decl;\n+  cgraph_varpool_n_nodes++;\n+  *slot = node;\n+  VARRAY_PUSH_TREE (known_decls, decl);\n+  return node;\n+}\n+\n+/* Try to find existing function for identifier ID.  */\n+struct cgraph_varpool_node *\n+cgraph_varpool_node_for_identifier (tree id)\n+{\n+  struct cgraph_varpool_node **slot;\n+\n+  if (TREE_CODE (id) != IDENTIFIER_NODE)\n+    abort ();\n+\n+  if (!cgraph_varpool_hash)\n+    return NULL;\n+\n+  slot =\n+    (struct cgraph_varpool_node **) htab_find_slot_with_hash (cgraph_varpool_hash, id,\n+\t\t\t\t\t\t      htab_hash_pointer (id), 0);\n+  if (!slot)\n+    return NULL;\n+  return *slot;\n+}\n+\n+/* Notify finalize_compilation_unit that given node is reachable\n+   or needed.  */\n+void\n+cgraph_varpool_mark_needed_node (struct cgraph_varpool_node *node)\n+{\n+  if (!node->needed && node->finalized)\n+    {\n+      node->aux = cgraph_varpool_nodes_queue;\n+      cgraph_varpool_nodes_queue = node;\n+    }\n+  node->needed = 1;\n+}\n+\n+void\n+cgraph_varpool_finalize_decl (tree decl)\n+{\n+  struct cgraph_varpool_node *node = cgraph_varpool_node (decl);\n+\n+  if (node->needed && !node->finalized)\n+    {\n+      node->aux = cgraph_varpool_nodes_queue;\n+      cgraph_varpool_nodes_queue = node;\n+    }\n+  node->finalized = true;\n+\n+  if (/* Externally visible variables must be output.  The exception are\n+\t COMDAT functions that must be output only when they are needed.  */\n+      (TREE_PUBLIC (decl) && !DECL_COMDAT (decl))\n+      /* Function whose name is output to the assembler file must be produced.\n+\t It is possible to assemble the name later after finalizing the function\n+\t and the fact is noticed in assemble_name then.  */\n+      || (DECL_ASSEMBLER_NAME_SET_P (decl)\n+\t  && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n+    {\n+      cgraph_varpool_mark_needed_node (node);\n+    }\n+}\n+\n+bool\n+cgraph_varpool_assemble_pending_decls ()\n+{\n+  bool changed = false;\n+\n+  while (cgraph_varpool_nodes_queue)\n+    {\n+      tree decl = cgraph_varpool_nodes_queue->decl;\n+      struct cgraph_varpool_node *node = cgraph_varpool_nodes_queue;\n+\n+      cgraph_varpool_nodes_queue = cgraph_varpool_nodes_queue->aux;\n+      if (!TREE_ASM_WRITTEN (decl))\n+\t{\n+\t  assemble_variable (decl, 0, 1, 0);\n+\t  changed = true;\n+\t}\n+      node->aux = NULL;\n+    }\n+  return changed;\n+}\n+\n+\n #include \"gt-cgraph.h\""}, {"sha": "de35a0dbbdc4d6bc544b4764b2585eb5953bb90b", "filename": "gcc/cgraph.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69529cd536c79f1849f271e230e0b61fede7b84/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69529cd536c79f1849f271e230e0b61fede7b84/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=e69529cd536c79f1849f271e230e0b61fede7b84", "patch": "@@ -97,11 +97,32 @@ struct cgraph_edge\n   struct cgraph_edge *next_callee;\n };\n \n+/* The cgraph_varpool data strutcture.\n+   Each static variable decl has assigned cgraph_varpool_node.  */\n+\n+struct cgraph_varpool_node\n+{\n+  tree decl;\n+  void *aux;\n+\n+  /* Set when function must be output - it is externally visible\n+     or it's address is taken.  */\n+  bool needed;\n+  /* Set once it has been finalized so we consider it to be output.  */\n+  bool finalized;\n+  /* Set when function is scheduled to be assembled.  */\n+  bool output;\n+};\n+\n extern struct cgraph_node *cgraph_nodes;\n extern int cgraph_n_nodes;\n extern bool cgraph_global_info_ready;\n extern struct cgraph_node *cgraph_nodes_queue;\n \n+extern int cgraph_varpool_n_nodes;\n+extern struct cgraph_varpool_node *cgraph_varpool_nodes_queue;\n+\n+\n /* In cgraph.c  */\n void dump_cgraph\t\t\tPARAMS ((FILE *));\n void cgraph_remove_call\t\t\tPARAMS ((tree, tree));\n@@ -114,6 +135,12 @@ struct cgraph_local_info *cgraph_local_info PARAMS ((tree));\n struct cgraph_global_info *cgraph_global_info PARAMS ((tree));\n struct cgraph_rtl_info *cgraph_rtl_info PARAMS ((tree));\n \n+struct cgraph_varpool_node *cgraph_varpool_node (tree decl);\n+struct cgraph_varpool_node *cgraph_varpool_node_for_identifier (tree id);\n+void cgraph_varpool_mark_needed_node (struct cgraph_varpool_node *);\n+void cgraph_varpool_finalize_decl (tree);\n+bool cgraph_varpool_assemble_pending_decls (void);\n+\n /* In cgraphunit.c  */\n void cgraph_finalize_function\t\tPARAMS ((tree, tree));\n void cgraph_finalize_compilation_unit\tPARAMS ((void));"}, {"sha": "47390b970c44b8b2da93033265a2ecac64f14c6b", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69529cd536c79f1849f271e230e0b61fede7b84/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69529cd536c79f1849f271e230e0b61fede7b84/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=e69529cd536c79f1849f271e230e0b61fede7b84", "patch": "@@ -93,9 +93,11 @@ record_call_1 (tp, walk_subtrees, data)\n      int *walk_subtrees;\n      void *data;\n {\n+  if (TREE_CODE (*tp) == VAR_DECL && TREE_STATIC (*tp))\n+    cgraph_varpool_mark_needed_node (cgraph_varpool_node (*tp));\n   /* Record dereferences to the functions.  This makes the functions\n      reachable unconditionally.  */\n-  if (TREE_CODE (*tp) == ADDR_EXPR)\n+  else if (TREE_CODE (*tp) == ADDR_EXPR)\n     {\n       tree decl = TREE_OPERAND (*tp, 0);\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n@@ -144,6 +146,8 @@ cgraph_finalize_compilation_unit ()\n   struct cgraph_node *node;\n   struct cgraph_edge *edge;\n \n+  cgraph_varpool_assemble_pending_decls ();\n+\n   if (!quiet_flag)\n     {\n       fprintf (stderr, \"\\n\\nInitial entry points:\");\n@@ -188,6 +192,7 @@ cgraph_finalize_compilation_unit ()\n             cgraph_mark_needed_node (edge->callee, 0);\n \t}\n       node->lowered = true;\n+      cgraph_varpool_assemble_pending_decls ();\n     }\n   /* Collect entry points to the unit.  */\n "}, {"sha": "c36bb6b45f67bc13f26f14bba4edad8b930e4289", "filename": "gcc/toplev.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69529cd536c79f1849f271e230e0b61fede7b84/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69529cd536c79f1849f271e230e0b61fede7b84/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e69529cd536c79f1849f271e230e0b61fede7b84", "patch": "@@ -1897,7 +1897,14 @@ wrapup_global_declarations (tree *vec, int len)\n \t    {\n \t      bool needed = 1;\n \n-\t      if (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n+\t      if (flag_unit_at_a_time\n+\t\t  && cgraph_varpool_node (decl)->finalized)\n+\t\tneeded = 0;\n+\t      else if (flag_unit_at_a_time\n+\t\t       && (TREE_USED (decl)\n+\t\t\t   || TREE_USED (DECL_ASSEMBLER_NAME (decl))))\n+\t\t/* needed */;\n+\t      else if (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n \t\t/* needed */;\n \t      else if (DECL_COMDAT (decl))\n \t\tneeded = 0;\n@@ -2069,6 +2076,8 @@ compile_file (void)\n \n   (*lang_hooks.decls.final_write_globals)();\n \n+  cgraph_varpool_assemble_pending_decls ();\n+\n   /* This must occur after the loop to output deferred functions.\n      Else the coverage initializer would not be emitted if all the\n      functions in this compilation unit were deferred.  */\n@@ -2169,7 +2178,13 @@ rest_of_decl_compilation (tree decl,\n       /* Don't output anything when a tentative file-scope definition\n \t is seen.  But at end of compilation, do output code for them.  */\n       if (at_end || !DECL_DEFER_OUTPUT (decl))\n-\tassemble_variable (decl, top_level, at_end, 0);\n+\t{\n+\t  if (flag_unit_at_a_time && TREE_CODE (decl) != FUNCTION_DECL\n+\t      && top_level)\n+\t    cgraph_varpool_finalize_decl (decl);\n+\t  else\n+\t    assemble_variable (decl, top_level, at_end, 0);\n+\t}\n \n #ifdef ASM_FINISH_DECLARE_OBJECT\n       if (decl == last_assemble_variable_decl)"}, {"sha": "73abd5edc8daeefa9b11bd0ef6e3abd717e0912f", "filename": "gcc/varasm.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e69529cd536c79f1849f271e230e0b61fede7b84/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e69529cd536c79f1849f271e230e0b61fede7b84/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=e69529cd536c79f1849f271e230e0b61fede7b84", "patch": "@@ -1751,8 +1751,14 @@ assemble_name (file, name)\n \t  && !cgraph_global_info_ready)\n \t{\n \t  struct cgraph_node *node = cgraph_node_for_identifier (id);\n+\t  struct cgraph_varpool_node *vnode;\n+\t  \n \t  if (node)\n \t    cgraph_mark_needed_node (node, 1);\n+\n+\t  vnode = cgraph_varpool_node_for_identifier (id);\n+\t  if (vnode)\n+\t    cgraph_varpool_mark_needed_node (vnode);\n \t}\n       TREE_SYMBOL_REFERENCED (id) = 1;\n     }"}]}