{"sha": "c94583fe5577f83df48b156f86d9d36dcb218dbe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk0NTgzZmU1NTc3ZjgzZGY0OGIxNTZmODZkOWQzNmRjYjIxOGRiZQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-09-14T07:43:08Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-09-14T07:43:08Z"}, "message": "unroll.c: Removed.\n\n\t* unroll.c: Removed.\n\t* loop.h: Removed.\n\t* Makefile.in (LOOP_H, unroll.o): Removed.\n\t(toplev.o, passes.o, stmt.o, integrate.o, loop.o): Remove LOOP_H\n\tdependency.\n\t* alias.c (init_alias_analysis): Remove flag_old_unroll_loops\n\treference.\n\t* cfgloop.h (LOOP_PREFETCH, loop_optimize): Moved from loop.h.\n\t* common.opt (fold-unroll-loops, fold-unroll-all-loops): Removed.\n\t* loop.c: Do not include loop.h.\n\t(LOOP_INFO, LOOP_MOVABLES, LOOP_REGS, LOOP_IVS, INSN_LUID,\n\tREGNO_FIRST_LUID, REGNO_LAST_LUID, enum g_types, struct induction,\n\tstruct iv_class, enum iv_mode, struct iv, REG_IV_TYPE, REG_IV_INFO,\n\tREG_IV_CLASS, struct loop_ivs, struct loop_mem_info, struct loop_reg,\n\tstruct loop_regs, struct loop_movables, struct loop_info): Moved\n\tfrom loop.h.\n\t(back_branch_in_range_p, fold_rtx_mult_add, biv_total_increment,\n\treg_dead_after_loop, final_biv_value, loop_find_equiv_value,\n\tfind_common_reg_term, loop_iterations, final_giv_value): Moved\n\tfrom unroll.c.\n\t(uid_luid, uid_loop, max_uid_for_loop, max_reg_before_loop,\n\tloop_dump_stream, for_each_insn_in_loop, express_from,\n\textend_value_for_giv, loop_iv_add_mult_emit_before,\n\tloop_iv_add_mult_sink, loop_iv_add_mult_hoist,\n\tloop_insn_first_p, get_condition_for_loop,\n\tloop_insn_emit_before, loop_insn_hoist,\n\tloop_insn_sink): Made static.\n\t(loop_invariant_p): Made static.  Removed flag_old_unroll_loops\n\treference.\n\t(strength_reduce): Do not call unroller.\n\t(record_giv): Do not initialize unrolled field.\n\t(prescan_loop): Do not set loop_info->preconditioned.\n\t* passes.c: Do not include loop.h.\n\t(rest_of_handle_loop_optimize): Do not call unroller.\n\t* predict.c: Do not include loop.h.\n\t* rtl.h (NOTE_PRECONDITIONED): Removed.\n\t* stmt.c: Do not include loop.h.\n\t* toplev.c: Do not include loop.h.\n\t(process_options): Do not handle flag_old_unroll_loops.\n\n\t* doc/invoke.texi (fold-unroll-loops, fold-unroll-all-loops):\n\tDocumentation removed.\n\t* doc/passes.texi (unroll.c, loop.h): Documentation removed.\n\nFrom-SVN: r87485", "tree": {"sha": "3b159340b1277a2a7c79335b9d3f5e4f0caaa3ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b159340b1277a2a7c79335b9d3f5e4f0caaa3ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c94583fe5577f83df48b156f86d9d36dcb218dbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c94583fe5577f83df48b156f86d9d36dcb218dbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c94583fe5577f83df48b156f86d9d36dcb218dbe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c94583fe5577f83df48b156f86d9d36dcb218dbe/comments", "author": null, "committer": null, "parents": [{"sha": "032618223ba81a0f01b4b20241c0b0a9859db29b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/032618223ba81a0f01b4b20241c0b0a9859db29b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/032618223ba81a0f01b4b20241c0b0a9859db29b"}], "stats": {"total": 5932, "additions": 1505, "deletions": 4427}, "files": [{"sha": "a6de7461d90c4831afaf0dd4a9bf403f4aa4e439", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c94583fe5577f83df48b156f86d9d36dcb218dbe", "patch": "@@ -1,3 +1,49 @@\n+2004-09-14  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* unroll.c: Removed.\n+\t* loop.h: Removed.\n+\t* Makefile.in (LOOP_H, unroll.o): Removed.\n+\t(toplev.o, passes.o, stmt.o, integrate.o, loop.o): Remove LOOP_H\n+\tdependency.\n+\t* alias.c (init_alias_analysis): Remove flag_old_unroll_loops\n+\treference.\n+\t* cfgloop.h (LOOP_PREFETCH, loop_optimize): Moved from loop.h.\n+\t* common.opt (fold-unroll-loops, fold-unroll-all-loops): Removed.\n+\t* loop.c: Do not include loop.h.\n+\t(LOOP_INFO, LOOP_MOVABLES, LOOP_REGS, LOOP_IVS, INSN_LUID,\n+\tREGNO_FIRST_LUID, REGNO_LAST_LUID, enum g_types, struct induction,\n+\tstruct iv_class, enum iv_mode, struct iv, REG_IV_TYPE, REG_IV_INFO,\n+\tREG_IV_CLASS, struct loop_ivs, struct loop_mem_info, struct loop_reg,\n+\tstruct loop_regs, struct loop_movables, struct loop_info): Moved\n+\tfrom loop.h.\n+\t(back_branch_in_range_p, fold_rtx_mult_add, biv_total_increment,\n+\treg_dead_after_loop, final_biv_value, loop_find_equiv_value,\n+\tfind_common_reg_term, loop_iterations, final_giv_value): Moved\n+\tfrom unroll.c.\n+\t(uid_luid, uid_loop, max_uid_for_loop, max_reg_before_loop,\n+\tloop_dump_stream, for_each_insn_in_loop, express_from,\n+\textend_value_for_giv, loop_iv_add_mult_emit_before,\n+\tloop_iv_add_mult_sink, loop_iv_add_mult_hoist,\n+\tloop_insn_first_p, get_condition_for_loop,\n+\tloop_insn_emit_before, loop_insn_hoist,\n+\tloop_insn_sink): Made static.\n+\t(loop_invariant_p): Made static.  Removed flag_old_unroll_loops\n+\treference.\n+\t(strength_reduce): Do not call unroller.\n+\t(record_giv): Do not initialize unrolled field.\n+\t(prescan_loop): Do not set loop_info->preconditioned.\n+\t* passes.c: Do not include loop.h.\n+\t(rest_of_handle_loop_optimize): Do not call unroller.\n+\t* predict.c: Do not include loop.h.\n+\t* rtl.h (NOTE_PRECONDITIONED): Removed.\n+\t* stmt.c: Do not include loop.h.\n+\t* toplev.c: Do not include loop.h.\n+\t(process_options): Do not handle flag_old_unroll_loops.\n+\n+\t* doc/invoke.texi (fold-unroll-loops, fold-unroll-all-loops):\n+\tDocumentation removed.\n+\t* doc/passes.texi (unroll.c, loop.h): Documentation removed.\n+\n 2004-09-14  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* Makefile.in (STAGE1_CHECKING): New variable."}, {"sha": "bdc1b873c10638143bd840559745fd686388432d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c94583fe5577f83df48b156f86d9d36dcb218dbe", "patch": "@@ -701,7 +701,6 @@ RA_H = ra.h bitmap.h sbitmap.h hard-reg-set.h insn-modes.h\n RESOURCE_H = resource.h hard-reg-set.h\n SCHED_INT_H = sched-int.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H)\n INTEGRATE_H = integrate.h varray.h\n-LOOP_H = loop.h varray.h bitmap.h\n CFGLAYOUT_H = cfglayout.h $(BASIC_BLOCK_H)\n CFGLOOP_H = cfgloop.h $(BASIC_BLOCK_H) $(RTL_H)\n CGRAPH_H = cgraph.h bitmap.h tree.h $(HASHTAB_H)\n@@ -921,7 +920,7 @@ OBJS-common = \\\n  reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o\t   \\\n  sbitmap.o sched-deps.o sched-ebb.o sched-rgn.o sched-vis.o sdbout.o\t   \\\n  simplify-rtx.o sreal.o stmt.o stor-layout.o stringpool.o\t\t   \\\n- targhooks.o timevar.o toplev.o tracer.o tree.o tree-dump.o unroll.o\t   \\\n+ targhooks.o timevar.o toplev.o tracer.o tree.o tree-dump.o\t\t   \\\n  varasm.o varray.o vec.o version.o vmsdbgout.o xcoffout.o alloc-pool.o\t   \\\n  et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o\t   \\\n  rtl-profile.o tree-profile.o rtlhooks.o cfgexpand.o lambda-mat.o          \\\n@@ -1719,7 +1718,7 @@ tree-ssa-loop-manip.o : tree-ssa-loop-manip.c $(TREE_FLOW_H) $(CONFIG_H) \\\n tree-ssa-loop-im.o : tree-ssa-loop-im.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) domwalk.h $(PARAMS_H)\\\n    output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n-   tree-pass.h flags.h\n+   tree-pass.h flags.h $(HASHTAB_H)\n tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) tree-inline.h $(FLAGS_H) \\\n    function.h $(TIMEVAR_H) convert.h $(TM_H) coretypes.h \\\n@@ -1793,7 +1792,7 @@ toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) versio\n    function.h $(FLAGS_H) xcoffout.h input.h $(INSN_ATTR_H) output.h $(DIAGNOSTIC_H) \\\n    debug.h insn-config.h intl.h $(RECOG_H) Makefile toplev.h \\\n    dwarf2out.h sdbout.h dbxout.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) \\\n-   graph.h $(LOOP_H) except.h $(REGS_H) $(TIMEVAR_H) value-prof.h \\\n+   graph.h except.h $(REGS_H) $(TIMEVAR_H) value-prof.h \\\n    $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) \\\n    langhooks.h insn-flags.h $(CFGLAYOUT_H) real.h $(CFGLOOP_H) \\\n    hosthooks.h $(LANGHOOKS_DEF_H) $(CGRAPH_H) $(COVERAGE_H) alloc-pool.h\n@@ -1805,7 +1804,7 @@ passes.o : passes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) function.h $(FLAGS_H) xcoffout.h input.h $(INSN_ATTR_H) output.h \\\n    $(DIAGNOSTIC_H) debug.h insn-config.h intl.h $(RECOG_H) toplev.h \\\n    dwarf2out.h sdbout.h dbxout.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) \\\n-   graph.h $(LOOP_H) except.h $(REGS_H) $(TIMEVAR_H) value-prof.h \\\n+   graph.h except.h $(REGS_H) $(TIMEVAR_H) value-prof.h \\\n    $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) \\\n    langhooks.h insn-flags.h $(CFGLAYOUT_H) real.h $(CFGLOOP_H) \\\n    hosthooks.h $(LANGHOOKS_DEF_H) $(CGRAPH_H) $(COVERAGE_H) alloc-pool.h \\\n@@ -1839,7 +1838,7 @@ function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TM_P_H) langhooks.h gt-function.h $(TARGET_H) basic-block.h\n stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) \\\n    function.h insn-config.h hard-reg-set.h $(EXPR_H) libfuncs.h except.h \\\n-   $(LOOP_H) $(RECOG_H) toplev.h output.h varray.h $(GGC_H) $(TM_P_H) \\\n+   $(RECOG_H) toplev.h output.h varray.h $(GGC_H) $(TM_P_H) \\\n    langhooks.h $(PREDICT_H) $(OPTABS_H) $(TARGET_H)\n except.o : except.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) except.h function.h $(EXPR_H) libfuncs.h $(INTEGRATE_H) \\\n@@ -1900,7 +1899,7 @@ emit-rtl.o : emit-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(T\n real.o : real.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) toplev.h $(TM_P_H)\n integrate.o : integrate.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(FLAGS_H) debug.h $(INTEGRATE_H) insn-config.h $(EXPR_H) real.h $(REGS_H) \\\n-   intl.h function.h output.h $(RECOG_H) except.h toplev.h $(LOOP_H) \\\n+   intl.h function.h output.h $(RECOG_H) except.h toplev.h \\\n    $(PARAMS_H) $(TM_P_H) $(TARGET_H) langhooks.h gt-integrate.h\n jump.o : jump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \\\n    hard-reg-set.h $(REGS_H) insn-config.h $(RECOG_H) $(EXPR_H) real.h except.h function.h \\\n@@ -1977,17 +1976,13 @@ rtl-profile.o : tree-profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n value-prof.o : value-prof.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h value-prof.h $(EXPR_H) output.h $(FLAGS_H) \\\n    $(RECOG_H) insn-config.h $(OPTABS_H) $(REGS_H) $(GGC_H)\n-loop.o : loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) $(LOOP_H) \\\n+loop.o : loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \\\n    insn-config.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) \\\n    real.h $(PREDICT_H) $(BASIC_BLOCK_H) function.h $(CFGLOOP_H) \\\n    toplev.h varray.h except.h cselib.h $(OPTABS_H) $(TM_P_H) $(GGC_H)\n loop-doloop.o : loop-doloop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(FLAGS_H) $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) \\\n    toplev.h $(CFGLOOP_H) output.h $(PARAMS_H)\n-unroll.o : unroll.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) insn-config.h \\\n-   function.h $(INTEGRATE_H) $(REGS_H) $(RECOG_H) $(FLAGS_H) $(EXPR_H) $(LOOP_H) toplev.h \\\n-   hard-reg-set.h varray.h $(BASIC_BLOCK_H) $(TM_P_H) $(PREDICT_H) $(PARAMS_H) \\\n-   $(CFGLOOP_H)\n alloc-pool.o : alloc-pool.c $(CONFIG_H) $(SYSTEM_H) alloc-pool.h $(HASHTAB_H)\n flow.o : flow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\"}, {"sha": "24b4605822d4c511520f5469c032e38586bade11", "filename": "gcc/alias.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=c94583fe5577f83df48b156f86d9d36dcb218dbe", "patch": "@@ -2763,11 +2763,6 @@ init_alias_analysis (void)\n \n   new_reg_base_value = xmalloc (maxreg * sizeof (rtx));\n   reg_seen = xmalloc (maxreg);\n-  if (! reload_completed && flag_old_unroll_loops)\n-    {\n-      alias_invariant = ggc_calloc (maxreg, sizeof (rtx));\n-      alias_invariant_size = maxreg;\n-    }\n \n   /* The basic idea is that each pass through this loop will use the\n      \"constant\" information from the previous pass to propagate alias"}, {"sha": "11f4842be035d450af36d2c9683f999d76046204", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=c94583fe5577f83df48b156f86d9d36dcb218dbe", "patch": "@@ -458,4 +458,11 @@ extern void unroll_and_peel_loops (struct loops *, int);\n extern void doloop_optimize_loops (struct loops *);\n extern void move_loop_invariants (struct loops *);\n \n+/* Old loop optimizer interface.  */\n+\n+/* Flags passed to loop_optimize.  */\n+#define LOOP_PREFETCH 1\n+\n+extern void loop_optimize (rtx, FILE *, int);\n+\n #endif /* GCC_CFGLOOP_H */"}, {"sha": "5e37cb9517d3d1e97272c914a4dcaa769b56f66c", "filename": "gcc/common.opt", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=c94583fe5577f83df48b156f86d9d36dcb218dbe", "patch": "@@ -551,14 +551,6 @@ fnon-call-exceptions\n Common Report Var(flag_non_call_exceptions)\n Support synchronous non-call exceptions\n \n-fold-unroll-loops\n-Common Report Var(flag_old_unroll_loops)\n-Perform loop unrolling when iteration count is known\n-\n-fold-unroll-all-loops\n-Common Report Var(flag_old_unroll_all_loops)\n-Perform loop unrolling for all loops\n-\n fomit-frame-pointer\n Common Report Var(flag_omit_frame_pointer)\n When possible do not generate stack frames"}, {"sha": "567dc5caf922556017ea88b373020efb187629ef", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c94583fe5577f83df48b156f86d9d36dcb218dbe", "patch": "@@ -315,7 +315,7 @@ Objective-C and Objective-C++ Dialects}.\n -fsignaling-nans -fsingle-precision-constant  -fspeculative-prefetching @gol\n -fstrength-reduce  -fstrict-aliasing  -ftracer  -fthread-jumps @gol\n -funroll-all-loops  -funroll-loops  -fpeel-loops @gol\n--funswitch-loops  -fold-unroll-loops  -fold-unroll-all-loops @gol\n+-funswitch-loops @gol\n -ftree-pre  -ftree-ccp  -ftree-dce -ftree-loop-optimize @gol\n -ftree-loop-linear -ftree-loop-im -ftree-loop-ivcanon -fivopts @gol\n -ftree-dominator-opts -ftree-dse -ftree-copyrename @gol\n@@ -4423,8 +4423,7 @@ redundant spilling.\n @item -floop-optimize\n @opindex floop-optimize\n Perform loop optimizations: move constant expressions out of loops, simplify\n-exit test conditions and optionally do strength-reduction and loop unrolling as\n-well.\n+exit test conditions and optionally do strength-reduction as well.\n \n Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.\n \n@@ -5222,22 +5221,6 @@ at level @option{-O1}\n Move branches with loop invariant conditions out of the loop, with duplicates\n of the loop on both branches (modified according to result of the condition).\n \n-@item -fold-unroll-loops\n-@opindex fold-unroll-loops\n-Unroll loops whose number of iterations can be determined at compile\n-time or upon entry to the loop, using the old loop unroller whose loop\n-recognition is based on notes from frontend.  @option{-fold-unroll-loops} implies\n-both @option{-fstrength-reduce} and @option{-frerun-cse-after-loop}.  This\n-option makes code larger, and may or may not make it run faster.\n-\n-@item -fold-unroll-all-loops\n-@opindex fold-unroll-all-loops\n-Unroll all loops, even if their number of iterations is uncertain when\n-the loop is entered. This is done using the old loop unroller whose loop\n-recognition is based on notes from frontend.  This usually makes programs run more slowly.\n-@option{-fold-unroll-all-loops} implies the same options as\n-@option{-fold-unroll-loops}.\n-\n @item -fprefetch-loop-arrays\n @opindex fprefetch-loop-arrays\n If supported by the target machine, generate instructions to prefetch"}, {"sha": "00a53978a7d6d02cee96c5680302b442f46f43a1", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=c94583fe5577f83df48b156f86d9d36dcb218dbe", "patch": "@@ -540,11 +540,8 @@ are in @file{lcm.c}.\n \n @item Loop optimization\n \n-This pass moves constant expressions out of loops,\n-and optionally does strength-reduction and loop unrolling as well.\n-Its source files are @file{loop.c} and @file{unroll.c}, plus the header\n-@file{loop.h} used for communication between them.  Loop unrolling uses\n-some functions in @file{integrate.c} and the header @file{integrate.h}.\n+This pass moves constant expressions out of loops, and optionally does\n+strength-reduction as well.  The pass is located in @file{loop.c}.\n Loop dependency analysis routines are contained in @file{dependence.c}.\n This pass is seriously out-of-date and is supposed to be replaced by\n a new one described below in near future."}, {"sha": "ded07efb0b92ee002ed5d2b0c4b717913e9a7631", "filename": "gcc/loop.c", "status": "modified", "additions": 1437, "deletions": 77, "changes": 1514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=c94583fe5577f83df48b156f86d9d36dcb218dbe", "patch": "@@ -57,7 +57,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"recog.h\"\n #include \"flags.h\"\n #include \"real.h\"\n-#include \"loop.h\"\n #include \"cselib.h\"\n #include \"except.h\"\n #include \"toplev.h\"\n@@ -67,6 +66,354 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cfgloop.h\"\n #include \"ggc.h\"\n \n+/* Get the loop info pointer of a loop.  */\n+#define LOOP_INFO(LOOP) ((struct loop_info *) (LOOP)->aux)\n+\n+/* Get a pointer to the loop movables structure.  */\n+#define LOOP_MOVABLES(LOOP) (&LOOP_INFO (LOOP)->movables)\n+\n+/* Get a pointer to the loop registers structure.  */\n+#define LOOP_REGS(LOOP) (&LOOP_INFO (LOOP)->regs)\n+\n+/* Get a pointer to the loop induction variables structure.  */\n+#define LOOP_IVS(LOOP) (&LOOP_INFO (LOOP)->ivs)\n+\n+/* Get the luid of an insn.  Catch the error of trying to reference the LUID\n+   of an insn added during loop, since these don't have LUIDs.  */\n+\n+#define INSN_LUID(INSN)\t\t\t\\\n+  (INSN_UID (INSN) < max_uid_for_loop ? uid_luid[INSN_UID (INSN)] \\\n+   : (abort (), -1))\n+\n+#define REGNO_FIRST_LUID(REGNO)\t\t\t\\\n+  (REGNO_FIRST_UID (REGNO) < max_uid_for_loop\t\\\n+\t? uid_luid[REGNO_FIRST_UID (REGNO)]\t\\\n+\t: 0)\n+#define REGNO_LAST_LUID(REGNO)\t\t\t\\\n+  (REGNO_LAST_UID (REGNO) < max_uid_for_loop\t\\\n+\t? uid_luid[REGNO_LAST_UID (REGNO)]\t\\\n+\t: INT_MAX)\n+\n+/* A \"basic induction variable\" or biv is a pseudo reg that is set\n+   (within this loop) only by incrementing or decrementing it.  */\n+/* A \"general induction variable\" or giv is a pseudo reg whose\n+   value is a linear function of a biv.  */\n+\n+/* Bivs are recognized by `basic_induction_var';\n+   Givs by `general_induction_var'.  */\n+\n+/* An enum for the two different types of givs, those that are used\n+   as memory addresses and those that are calculated into registers.  */\n+enum g_types\n+{\n+  DEST_ADDR,\n+  DEST_REG\n+};\n+\n+\n+/* A `struct induction' is created for every instruction that sets\n+   an induction variable (either a biv or a giv).  */\n+\n+struct induction\n+{\n+  rtx insn;\t\t\t/* The insn that sets a biv or giv */\n+  rtx new_reg;\t\t\t/* New register, containing strength reduced\n+\t\t\t\t   version of this giv.  */\n+  rtx src_reg;\t\t\t/* Biv from which this giv is computed.\n+\t\t\t\t   (If this is a biv, then this is the biv.) */\n+  enum g_types giv_type;\t/* Indicate whether DEST_ADDR or DEST_REG */\n+  rtx dest_reg;\t\t\t/* Destination register for insn: this is the\n+\t\t\t\t   register which was the biv or giv.\n+\t\t\t\t   For a biv, this equals src_reg.\n+\t\t\t\t   For a DEST_ADDR type giv, this is 0.  */\n+  rtx *location;\t\t/* Place in the insn where this giv occurs.\n+\t\t\t\t   If GIV_TYPE is DEST_REG, this is 0.  */\n+\t\t\t\t/* For a biv, this is the place where add_val\n+\t\t\t\t   was found.  */\n+  enum machine_mode mode;\t/* The mode of this biv or giv */\n+  rtx mem;\t\t\t/* For DEST_ADDR, the memory object.  */\n+  rtx mult_val;\t\t\t/* Multiplicative factor for src_reg.  */\n+  rtx add_val;\t\t\t/* Additive constant for that product.  */\n+  int benefit;\t\t\t/* Gain from eliminating this insn.  */\n+  rtx final_value;\t\t/* If the giv is used outside the loop, and its\n+\t\t\t\t   final value could be calculated, it is put\n+\t\t\t\t   here, and the giv is made replaceable.  Set\n+\t\t\t\t   the giv to this value before the loop.  */\n+  unsigned combined_with;\t/* The number of givs this giv has been\n+\t\t\t\t   combined with.  If nonzero, this giv\n+\t\t\t\t   cannot combine with any other giv.  */\n+  unsigned replaceable : 1;\t/* 1 if we can substitute the strength-reduced\n+\t\t\t\t   variable for the original variable.\n+\t\t\t\t   0 means they must be kept separate and the\n+\t\t\t\t   new one must be copied into the old pseudo\n+\t\t\t\t   reg each time the old one is set.  */\n+  unsigned not_replaceable : 1;\t/* Used to prevent duplicating work.  This is\n+\t\t\t\t   1 if we know that the giv definitely can\n+\t\t\t\t   not be made replaceable, in which case we\n+\t\t\t\t   don't bother checking the variable again\n+\t\t\t\t   even if further info is available.\n+\t\t\t\t   Both this and the above can be zero.  */\n+  unsigned ignore : 1;\t\t/* 1 prohibits further processing of giv */\n+  unsigned always_computable : 1;/* 1 if this value is computable every\n+\t\t\t\t    iteration.  */\n+  unsigned always_executed : 1; /* 1 if this set occurs each iteration.  */\n+  unsigned maybe_multiple : 1;\t/* Only used for a biv and  1 if this biv\n+\t\t\t\t   update may be done multiple times per\n+\t\t\t\t   iteration.  */\n+  unsigned cant_derive : 1;\t/* For giv's, 1 if this giv cannot derive\n+\t\t\t\t   another giv.  This occurs in many cases\n+\t\t\t\t   where a giv's lifetime spans an update to\n+\t\t\t\t   a biv.  */\n+  unsigned maybe_dead : 1;\t/* 1 if this giv might be dead.  In that case,\n+\t\t\t\t   we won't use it to eliminate a biv, it\n+\t\t\t\t   would probably lose.  */\n+  unsigned auto_inc_opt : 1;\t/* 1 if this giv had its increment output next\n+\t\t\t\t   to it to try to form an auto-inc address.  */\n+  unsigned shared : 1;\n+  unsigned no_const_addval : 1; /* 1 if add_val does not contain a const.  */\n+  int lifetime;\t\t\t/* Length of life of this giv */\n+  rtx derive_adjustment;\t/* If nonzero, is an adjustment to be\n+\t\t\t\t   subtracted from add_val when this giv\n+\t\t\t\t   derives another.  This occurs when the\n+\t\t\t\t   giv spans a biv update by incrementation.  */\n+  rtx ext_dependent;\t\t/* If nonzero, is a sign or zero extension\n+\t\t\t\t   if a biv on which this giv is dependent.  */\n+  struct induction *next_iv;\t/* For givs, links together all givs that are\n+\t\t\t\t   based on the same biv.  For bivs, links\n+\t\t\t\t   together all biv entries that refer to the\n+\t\t\t\t   same biv register.  */\n+  struct induction *same;\t/* For givs, if the giv has been combined with\n+\t\t\t\t   another giv, this points to the base giv.\n+\t\t\t\t   The base giv will have COMBINED_WITH nonzero.\n+\t\t\t\t   For bivs, if the biv has the same LOCATION\n+\t\t\t\t   than another biv, this points to the base\n+\t\t\t\t   biv.  */\n+  struct induction *same_insn;\t/* If there are multiple identical givs in\n+\t\t\t\t   the same insn, then all but one have this\n+\t\t\t\t   field set, and they all point to the giv\n+\t\t\t\t   that doesn't have this field set.  */\n+  rtx last_use;\t\t\t/* For a giv made from a biv increment, this is\n+\t\t\t\t   a substitute for the lifetime information.  */\n+};\n+\n+\n+/* A `struct iv_class' is created for each biv.  */\n+\n+struct iv_class\n+{\n+  unsigned int regno;\t\t/* Pseudo reg which is the biv.  */\n+  int biv_count;\t\t/* Number of insns setting this reg.  */\n+  struct induction *biv;\t/* List of all insns that set this reg.  */\n+  int giv_count;\t\t/* Number of DEST_REG givs computed from this\n+\t\t\t\t   biv.  The resulting count is only used in\n+\t\t\t\t   check_dbra_loop.  */\n+  struct induction *giv;\t/* List of all insns that compute a giv\n+\t\t\t\t   from this reg.  */\n+  int total_benefit;\t\t/* Sum of BENEFITs of all those givs.  */\n+  rtx initial_value;\t\t/* Value of reg at loop start.  */\n+  rtx initial_test;\t\t/* Test performed on BIV before loop.  */\n+  rtx final_value;\t\t/* Value of reg at loop end, if known.  */\n+  struct iv_class *next;\t/* Links all class structures together.  */\n+  rtx init_insn;\t\t/* insn which initializes biv, 0 if none.  */\n+  rtx init_set;\t\t\t/* SET of INIT_INSN, if any.  */\n+  unsigned incremented : 1;\t/* 1 if somewhere incremented/decremented */\n+  unsigned eliminable : 1;\t/* 1 if plausible candidate for\n+                                   elimination.  */\n+  unsigned nonneg : 1;\t\t/* 1 if we added a REG_NONNEG note for\n+                                   this.  */\n+  unsigned reversed : 1;\t/* 1 if we reversed the loop that this\n+\t\t\t\t   biv controls.  */\n+  unsigned all_reduced : 1;\t/* 1 if all givs using this biv have\n+                                   been reduced.  */\n+};\n+\n+\n+/* Definitions used by the basic induction variable discovery code.  */\n+enum iv_mode\n+{\n+  UNKNOWN_INDUCT,\n+  BASIC_INDUCT,\n+  NOT_BASIC_INDUCT,\n+  GENERAL_INDUCT\n+};\n+\n+\n+/* A `struct iv' is created for every register.  */\n+\n+struct iv\n+{\n+  enum iv_mode type;\n+  union\n+  {\n+    struct iv_class *class;\n+    struct induction *info;\n+  } iv;\n+};\n+\n+\n+#define REG_IV_TYPE(ivs, n) ivs->regs[n].type\n+#define REG_IV_INFO(ivs, n) ivs->regs[n].iv.info\n+#define REG_IV_CLASS(ivs, n) ivs->regs[n].iv.class\n+\n+\n+struct loop_ivs\n+{\n+  /* Indexed by register number, contains pointer to `struct\n+     iv' if register is an induction variable.  */\n+  struct iv *regs;\n+\n+  /* Size of regs array.  */\n+  unsigned int n_regs;\n+\n+  /* The head of a list which links together (via the next field)\n+     every iv class for the current loop.  */\n+  struct iv_class *list;\n+};\n+\n+\n+typedef struct loop_mem_info\n+{\n+  rtx mem;      /* The MEM itself.  */\n+  rtx reg;      /* Corresponding pseudo, if any.  */\n+  int optimize; /* Nonzero if we can optimize access to this MEM.  */\n+} loop_mem_info;\n+\n+\n+\n+struct loop_reg\n+{\n+  /* Number of times the reg is set during the loop being scanned.\n+     During code motion, a negative value indicates a reg that has\n+     been made a candidate; in particular -2 means that it is an\n+     candidate that we know is equal to a constant and -1 means that\n+     it is a candidate not known equal to a constant.  After code\n+     motion, regs moved have 0 (which is accurate now) while the\n+     failed candidates have the original number of times set.\n+\n+     Therefore, at all times, == 0 indicates an invariant register;\n+     < 0 a conditionally invariant one.  */\n+  int set_in_loop;\n+\n+  /* Original value of set_in_loop; same except that this value\n+     is not set negative for a reg whose sets have been made candidates\n+     and not set to 0 for a reg that is moved.  */\n+  int n_times_set;\n+\n+  /* Contains the insn in which a register was used if it was used\n+     exactly once; contains const0_rtx if it was used more than once.  */\n+  rtx single_usage;\n+\n+  /* Nonzero indicates that the register cannot be moved or strength\n+     reduced.  */\n+  char may_not_optimize;\n+\n+  /* Nonzero means reg N has already been moved out of one loop.\n+     This reduces the desire to move it out of another.  */\n+  char moved_once;\n+};\n+\n+\n+struct loop_regs\n+{\n+  int num;\t\t\t/* Number of regs used in table.  */\n+  int size;\t\t\t/* Size of table.  */\n+  struct loop_reg *array;\t/* Register usage info. array.  */\n+  int multiple_uses;\t\t/* Nonzero if a reg has multiple uses.  */\n+};\n+\n+\n+\n+struct loop_movables\n+{\n+  /* Head of movable chain.  */\n+  struct movable *head;\n+  /* Last movable in chain.  */\n+  struct movable *last;\n+};\n+\n+\n+/* Information pertaining to a loop.  */\n+\n+struct loop_info\n+{\n+  /* Nonzero if there is a subroutine call in the current loop.  */\n+  int has_call;\n+  /* Nonzero if there is a libcall in the current loop.  */\n+  int has_libcall;\n+  /* Nonzero if there is a non constant call in the current loop.  */\n+  int has_nonconst_call;\n+  /* Nonzero if there is a prefetch instruction in the current loop.  */\n+  int has_prefetch;\n+  /* Nonzero if there is a volatile memory reference in the current\n+     loop.  */\n+  int has_volatile;\n+  /* Nonzero if there is a tablejump in the current loop.  */\n+  int has_tablejump;\n+  /* Nonzero if there are ways to leave the loop other than falling\n+     off the end.  */\n+  int has_multiple_exit_targets;\n+  /* Nonzero if there is an indirect jump in the current function.  */\n+  int has_indirect_jump;\n+  /* Register or constant initial loop value.  */\n+  rtx initial_value;\n+  /* Register or constant value used for comparison test.  */\n+  rtx comparison_value;\n+  /* Register or constant approximate final value.  */\n+  rtx final_value;\n+  /* Register or constant initial loop value with term common to\n+     final_value removed.  */\n+  rtx initial_equiv_value;\n+  /* Register or constant final loop value with term common to\n+     initial_value removed.  */\n+  rtx final_equiv_value;\n+  /* Register corresponding to iteration variable.  */\n+  rtx iteration_var;\n+  /* Constant loop increment.  */\n+  rtx increment;\n+  enum rtx_code comparison_code;\n+  /* Holds the number of loop iterations.  It is zero if the number\n+     could not be calculated.  Must be unsigned since the number of\n+     iterations can be as high as 2^wordsize - 1.  For loops with a\n+     wider iterator, this number will be zero if the number of loop\n+     iterations is too large for an unsigned integer to hold.  */\n+  unsigned HOST_WIDE_INT n_iterations;\n+  int used_count_register;\n+  /* The loop iterator induction variable.  */\n+  struct iv_class *iv;\n+  /* List of MEMs that are stored in this loop.  */\n+  rtx store_mems;\n+  /* Array of MEMs that are used (read or written) in this loop, but\n+     cannot be aliased by anything in this loop, except perhaps\n+     themselves.  In other words, if mems[i] is altered during\n+     the loop, it is altered by an expression that is rtx_equal_p to\n+     it.  */\n+  loop_mem_info *mems;\n+  /* The index of the next available slot in MEMS.  */\n+  int mems_idx;\n+  /* The number of elements allocated in MEMS.  */\n+  int mems_allocated;\n+  /* Nonzero if we don't know what MEMs were changed in the current\n+     loop.  This happens if the loop contains a call (in which case\n+     `has_call' will also be set) or if we store into more than\n+     NUM_STORES MEMs.  */\n+  int unknown_address_altered;\n+  /* The above doesn't count any readonly memory locations that are\n+     stored.  This does.  */\n+  int unknown_constant_address_altered;\n+  /* Count of memory write instructions discovered in the loop.  */\n+  int num_mem_sets;\n+  /* The insn where the first of these was found.  */\n+  rtx first_loop_store_insn;\n+  /* The chain of movable insns in loop.  */\n+  struct loop_movables movables;\n+  /* The registers used the in loop.  */\n+  struct loop_regs regs;\n+  /* The induction variable information in loop.  */\n+  struct loop_ivs ivs;\n+  /* Nonzero if call is in pre_header extended basic block.  */\n+  int pre_header_has_call;\n+};\n+\n /* Not really meaningful values, but at least something.  */\n #ifndef SIMULTANEOUS_PREFETCHES\n #define SIMULTANEOUS_PREFETCHES 3\n@@ -170,16 +517,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    The luids are like uids but increase monotonically always.\n    We use them to see whether a jump comes from outside a given loop.  */\n \n-int *uid_luid;\n+static int *uid_luid;\n \n /* Indexed by INSN_UID, contains the ordinal giving the (innermost) loop\n    number the insn is contained in.  */\n \n-struct loop **uid_loop;\n+static struct loop **uid_loop;\n \n /* 1 + largest uid of any insn.  */\n \n-int max_uid_for_loop;\n+static int max_uid_for_loop;\n \n /* Number of loops detected in current function.  Used as index to the\n    next few tables.  */\n@@ -188,7 +535,7 @@ static int max_loop_num;\n \n /* Bound on pseudo register number before loop optimization.\n    A pseudo has valid regscan info if its number is < max_reg_before_loop.  */\n-unsigned int max_reg_before_loop;\n+static unsigned int max_reg_before_loop;\n \n /* The value to pass to the next call of reg_scan_update.  */\n static int loop_max_reg;\n@@ -241,7 +588,7 @@ struct movable\n };\n \n \n-FILE *loop_dump_stream;\n+static FILE *loop_dump_stream;\n \n /* Forward declarations.  */\n \n@@ -345,6 +692,18 @@ static rtx check_insn_for_bivs (struct loop *, rtx, int, int);\n static rtx gen_add_mult (rtx, rtx, rtx, rtx);\n static void loop_regs_update (const struct loop *, rtx);\n static int iv_add_mult_cost (rtx, rtx, rtx, rtx);\n+static int loop_invariant_p (const struct loop *, rtx);\n+static rtx loop_insn_hoist (const struct loop *, rtx);\n+static void loop_iv_add_mult_emit_before (const struct loop *, rtx, rtx, rtx,\n+\t\t\t\t\t  rtx, basic_block, rtx);\n+static rtx loop_insn_emit_before (const struct loop *, basic_block,\n+\t\t\t\t  rtx, rtx);\n+static int loop_insn_first_p (rtx, rtx);\n+static rtx get_condition_for_loop (const struct loop *, rtx);\n+static void loop_iv_add_mult_sink (const struct loop *, rtx, rtx, rtx, rtx);\n+static void loop_iv_add_mult_hoist (const struct loop *, rtx, rtx, rtx, rtx);\n+static rtx extend_value_for_giv (struct induction *, rtx);\n+static rtx loop_insn_sink (const struct loop *, rtx);\n \n static rtx loop_insn_emit_after (const struct loop *, basic_block, rtx, rtx);\n static rtx loop_call_insn_emit_before (const struct loop *, basic_block,\n@@ -2517,8 +2876,6 @@ prescan_loop (struct loop *loop)\n   loop_info->first_loop_store_insn = NULL_RTX;\n   loop_info->mems_idx = 0;\n   loop_info->num_mem_sets = 0;\n-  /* If loop opts run twice, this was set on 1st pass for 2nd.  */\n-  loop_info->preconditioned = NOTE_PRECONDITIONED (end);\n \n   for (insn = start; insn && !LABEL_P (insn);\n        insn = PREV_INSN (insn))\n@@ -3237,7 +3594,7 @@ note_set_pseudo_multiple_uses (rtx x, rtx y ATTRIBUTE_UNUSED, void *data)\n    A memory ref is invariant if it is not volatile and does not conflict\n    with anything stored in `loop_info->store_mems'.  */\n \n-int\n+static int\n loop_invariant_p (const struct loop *loop, rtx x)\n {\n   struct loop_info *loop_info = LOOP_INFO (loop);\n@@ -3260,19 +3617,7 @@ loop_invariant_p (const struct loop *loop, rtx x)\n       return 1;\n \n     case LABEL_REF:\n-      /* A LABEL_REF is normally invariant, however, if we are unrolling\n-\t loops, and this label is inside the loop, then it isn't invariant.\n-\t This is because each unrolled copy of the loop body will have\n-\t a copy of this label.  If this was invariant, then an insn loading\n-\t the address of this label into a register might get moved outside\n-\t the loop, and then each loop body would end up using the same label.\n-\n-\t We don't know the loop bounds here though, so just fail for all\n-\t labels.  */\n-      if (flag_old_unroll_loops)\n-\treturn 0;\n-      else\n-\treturn 1;\n+      return 1;\n \n     case PC:\n     case CC0:\n@@ -4232,6 +4577,56 @@ static rtx addr_placeholder;\n    was rerun in loop_optimize whenever a register was added or moved.\n    Also, some of the optimizations could be a little less conservative.  */\n \f\n+/* Searches the insns between INSN and LOOP->END.  Returns 1 if there\n+   is a backward branch in that range that branches to somewhere between\n+   LOOP->START and INSN.  Returns 0 otherwise.  */\n+\n+/* ??? This is quadratic algorithm.  Could be rewritten to be linear.\n+   In practice, this is not a problem, because this function is seldom called,\n+   and uses a negligible amount of CPU time on average.  */\n+\n+static int\n+back_branch_in_range_p (const struct loop *loop, rtx insn)\n+{\n+  rtx p, q, target_insn;\n+  rtx loop_start = loop->start;\n+  rtx loop_end = loop->end;\n+  rtx orig_loop_end = loop->end;\n+\n+  /* Stop before we get to the backward branch at the end of the loop.  */\n+  loop_end = prev_nonnote_insn (loop_end);\n+  if (BARRIER_P (loop_end))\n+    loop_end = PREV_INSN (loop_end);\n+\n+  /* Check in case insn has been deleted, search forward for first non\n+     deleted insn following it.  */\n+  while (INSN_DELETED_P (insn))\n+    insn = NEXT_INSN (insn);\n+\n+  /* Check for the case where insn is the last insn in the loop.  Deal\n+     with the case where INSN was a deleted loop test insn, in which case\n+     it will now be the NOTE_LOOP_END.  */\n+  if (insn == loop_end || insn == orig_loop_end)\n+    return 0;\n+\n+  for (p = NEXT_INSN (insn); p != loop_end; p = NEXT_INSN (p))\n+    {\n+      if (JUMP_P (p))\n+\t{\n+\t  target_insn = JUMP_LABEL (p);\n+\n+\t  /* Search from loop_start to insn, to see if one of them is\n+\t     the target_insn.  We can't use INSN_LUID comparisons here,\n+\t     since insn may not have an LUID entry.  */\n+\t  for (q = loop_start; q != insn; q = NEXT_INSN (q))\n+\t    if (q == target_insn)\n+\t      return 1;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n /* Scan the loop body and call FNCALL for each insn.  In the addition to the\n    LOOP and INSN parameters pass MAYBE_MULTIPLE and NOT_EVERY_ITERATION to the\n    callback.\n@@ -4242,7 +4637,8 @@ static rtx addr_placeholder;\n    MAYBE_MULTIPLE is 1 if current insn may be executed more than once for every\n    loop iteration.\n  */\n-void\n+typedef rtx (*loop_insn_callback) (struct loop *, rtx, int, int);\n+static void\n for_each_insn_in_loop (struct loop *loop, loop_insn_callback fncall)\n {\n   int not_every_iteration = 0;\n@@ -4545,6 +4941,238 @@ loop_givs_check (struct loop *loop)\n     }\n }\n \n+/* Try to generate the simplest rtx for the expression\n+   (PLUS (MULT mult1 mult2) add1).  This is used to calculate the initial\n+   value of giv's.  */\n+\n+static rtx\n+fold_rtx_mult_add (rtx mult1, rtx mult2, rtx add1, enum machine_mode mode)\n+{\n+  rtx temp, mult_res;\n+  rtx result;\n+\n+  /* The modes must all be the same.  This should always be true.  For now,\n+     check to make sure.  */\n+  if ((GET_MODE (mult1) != mode && GET_MODE (mult1) != VOIDmode)\n+      || (GET_MODE (mult2) != mode && GET_MODE (mult2) != VOIDmode)\n+      || (GET_MODE (add1) != mode && GET_MODE (add1) != VOIDmode))\n+    abort ();\n+\n+  /* Ensure that if at least one of mult1/mult2 are constant, then mult2\n+     will be a constant.  */\n+  if (GET_CODE (mult1) == CONST_INT)\n+    {\n+      temp = mult2;\n+      mult2 = mult1;\n+      mult1 = temp;\n+    }\n+\n+  mult_res = simplify_binary_operation (MULT, mode, mult1, mult2);\n+  if (! mult_res)\n+    mult_res = gen_rtx_MULT (mode, mult1, mult2);\n+\n+  /* Again, put the constant second.  */\n+  if (GET_CODE (add1) == CONST_INT)\n+    {\n+      temp = add1;\n+      add1 = mult_res;\n+      mult_res = temp;\n+    }\n+\n+  result = simplify_binary_operation (PLUS, mode, add1, mult_res);\n+  if (! result)\n+    result = gen_rtx_PLUS (mode, add1, mult_res);\n+\n+  return result;\n+}\n+\n+/* Searches the list of induction struct's for the biv BL, to try to calculate\n+   the total increment value for one iteration of the loop as a constant.\n+\n+   Returns the increment value as an rtx, simplified as much as possible,\n+   if it can be calculated.  Otherwise, returns 0.  */\n+\n+static rtx\n+biv_total_increment (const struct iv_class *bl)\n+{\n+  struct induction *v;\n+  rtx result;\n+\n+  /* For increment, must check every instruction that sets it.  Each\n+     instruction must be executed only once each time through the loop.\n+     To verify this, we check that the insn is always executed, and that\n+     there are no backward branches after the insn that branch to before it.\n+     Also, the insn must have a mult_val of one (to make sure it really is\n+     an increment).  */\n+\n+  result = const0_rtx;\n+  for (v = bl->biv; v; v = v->next_iv)\n+    {\n+      if (v->always_computable && v->mult_val == const1_rtx\n+\t  && ! v->maybe_multiple\n+\t  && SCALAR_INT_MODE_P (v->mode))\n+\t{\n+\t  /* If we have already counted it, skip it.  */\n+\t  if (v->same)\n+\t    continue;\n+\n+\t  result = fold_rtx_mult_add (result, const1_rtx, v->add_val, v->mode);\n+\t}\n+      else\n+\treturn 0;\n+    }\n+\n+  return result;\n+}\n+\n+/* Try to prove that the register is dead after the loop exits.  Trace every\n+   loop exit looking for an insn that will always be executed, which sets\n+   the register to some value, and appears before the first use of the register\n+   is found.  If successful, then return 1, otherwise return 0.  */\n+\n+/* ?? Could be made more intelligent in the handling of jumps, so that\n+   it can search past if statements and other similar structures.  */\n+\n+static int\n+reg_dead_after_loop (const struct loop *loop, rtx reg)\n+{\n+  rtx insn, label;\n+  int jump_count = 0;\n+  int label_count = 0;\n+\n+  /* In addition to checking all exits of this loop, we must also check\n+     all exits of inner nested loops that would exit this loop.  We don't\n+     have any way to identify those, so we just give up if there are any\n+     such inner loop exits.  */\n+\n+  for (label = loop->exit_labels; label; label = LABEL_NEXTREF (label))\n+    label_count++;\n+\n+  if (label_count != loop->exit_count)\n+    return 0;\n+\n+  /* HACK: Must also search the loop fall through exit, create a label_ref\n+     here which points to the loop->end, and append the loop_number_exit_labels\n+     list to it.  */\n+  label = gen_rtx_LABEL_REF (VOIDmode, loop->end);\n+  LABEL_NEXTREF (label) = loop->exit_labels;\n+\n+  for (; label; label = LABEL_NEXTREF (label))\n+    {\n+      /* Succeed if find an insn which sets the biv or if reach end of\n+\t function.  Fail if find an insn that uses the biv, or if come to\n+\t a conditional jump.  */\n+\n+      insn = NEXT_INSN (XEXP (label, 0));\n+      while (insn)\n+\t{\n+\t  if (INSN_P (insn))\n+\t    {\n+\t      rtx set, note;\n+\n+\t      if (reg_referenced_p (reg, PATTERN (insn)))\n+\t\treturn 0;\n+\n+\t      note = find_reg_equal_equiv_note (insn);\n+\t      if (note && reg_overlap_mentioned_p (reg, XEXP (note, 0)))\n+\t\treturn 0;\n+\n+\t      set = single_set (insn);\n+\t      if (set && rtx_equal_p (SET_DEST (set), reg))\n+\t\tbreak;\n+\n+\t      if (JUMP_P (insn))\n+\t\t{\n+\t\t  if (GET_CODE (PATTERN (insn)) == RETURN)\n+\t\t    break;\n+\t\t  else if (!any_uncondjump_p (insn)\n+\t\t           /* Prevent infinite loop following infinite loops.  */\n+\t\t           || jump_count++ > 20)\n+\t\t    return 0;\n+\t\t  else\n+\t\t    insn = JUMP_LABEL (insn);\n+\t\t}\n+\t    }\n+\n+\t  insn = NEXT_INSN (insn);\n+\t}\n+    }\n+\n+  /* Success, the register is dead on all loop exits.  */\n+  return 1;\n+}\n+\n+/* Try to calculate the final value of the biv, the value it will have at\n+   the end of the loop.  If we can do it, return that value.  */\n+\n+static rtx\n+final_biv_value (const struct loop *loop, struct iv_class *bl)\n+{\n+  unsigned HOST_WIDE_INT n_iterations = LOOP_INFO (loop)->n_iterations;\n+  rtx increment, tem;\n+\n+  /* ??? This only works for MODE_INT biv's.  Reject all others for now.  */\n+\n+  if (GET_MODE_CLASS (bl->biv->mode) != MODE_INT)\n+    return 0;\n+\n+  /* The final value for reversed bivs must be calculated differently than\n+     for ordinary bivs.  In this case, there is already an insn after the\n+     loop which sets this biv's final value (if necessary), and there are\n+     no other loop exits, so we can return any value.  */\n+  if (bl->reversed)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Final biv value for %d, reversed biv.\\n\", bl->regno);\n+\n+      return const0_rtx;\n+    }\n+\n+  /* Try to calculate the final value as initial value + (number of iterations\n+     * increment).  For this to work, increment must be invariant, the only\n+     exit from the loop must be the fall through at the bottom (otherwise\n+     it may not have its final value when the loop exits), and the initial\n+     value of the biv must be invariant.  */\n+\n+  if (n_iterations != 0\n+      && ! loop->exit_count\n+      && loop_invariant_p (loop, bl->initial_value))\n+    {\n+      increment = biv_total_increment (bl);\n+\n+      if (increment && loop_invariant_p (loop, increment))\n+\t{\n+\t  /* Can calculate the loop exit value, emit insns after loop\n+\t     end to calculate this value into a temporary register in\n+\t     case it is needed later.  */\n+\n+\t  tem = gen_reg_rtx (bl->biv->mode);\n+\t  record_base_value (REGNO (tem), bl->biv->add_val, 0);\n+\t  loop_iv_add_mult_sink (loop, increment, GEN_INT (n_iterations),\n+\t\t\t\t bl->initial_value, tem);\n+\n+\t  if (loop_dump_stream)\n+\t    fprintf (loop_dump_stream,\n+\t\t     \"Final biv value for %d, calculated.\\n\", bl->regno);\n+\n+\t  return tem;\n+\t}\n+    }\n+\n+  /* Check to see if the biv is dead at all loop exits.  */\n+  if (reg_dead_after_loop (loop, bl->biv->src_reg))\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Final biv value for %d, biv dead after loop exit.\\n\",\n+\t\t bl->regno);\n+\n+      return const0_rtx;\n+    }\n+\n+  return 0;\n+}\n \n /* Return nonzero if it is possible to eliminate the biv BL provided\n    all givs are reduced.  This is possible if either the reg is not\n@@ -4988,6 +5616,656 @@ loop_ivs_free (struct loop *loop)\n     }\n }\n \n+/* Look back before LOOP->START for the insn that sets REG and return\n+   the equivalent constant if there is a REG_EQUAL note otherwise just\n+   the SET_SRC of REG.  */\n+\n+static rtx\n+loop_find_equiv_value (const struct loop *loop, rtx reg)\n+{\n+  rtx loop_start = loop->start;\n+  rtx insn, set;\n+  rtx ret;\n+\n+  ret = reg;\n+  for (insn = PREV_INSN (loop_start); insn; insn = PREV_INSN (insn))\n+    {\n+      if (LABEL_P (insn))\n+\tbreak;\n+\n+      else if (INSN_P (insn) && reg_set_p (reg, insn))\n+\t{\n+\t  /* We found the last insn before the loop that sets the register.\n+\t     If it sets the entire register, and has a REG_EQUAL note,\n+\t     then use the value of the REG_EQUAL note.  */\n+\t  if ((set = single_set (insn))\n+\t      && (SET_DEST (set) == reg))\n+\t    {\n+\t      rtx note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n+\n+\t      /* Only use the REG_EQUAL note if it is a constant.\n+\t\t Other things, divide in particular, will cause\n+\t\t problems later if we use them.  */\n+\t      if (note && GET_CODE (XEXP (note, 0)) != EXPR_LIST\n+\t\t  && CONSTANT_P (XEXP (note, 0)))\n+\t\tret = XEXP (note, 0);\n+\t      else\n+\t\tret = SET_SRC (set);\n+\n+\t      /* We cannot do this if it changes between the\n+\t\t assignment and loop start though.  */\n+\t      if (modified_between_p (ret, insn, loop_start))\n+\t\tret = reg;\n+\t    }\n+\t  break;\n+\t}\n+    }\n+  return ret;\n+}\n+\n+/* Find and return register term common to both expressions OP0 and\n+   OP1 or NULL_RTX if no such term exists.  Each expression must be a\n+   REG or a PLUS of a REG.  */\n+\n+static rtx\n+find_common_reg_term (rtx op0, rtx op1)\n+{\n+  if ((REG_P (op0) || GET_CODE (op0) == PLUS)\n+      && (REG_P (op1) || GET_CODE (op1) == PLUS))\n+    {\n+      rtx op00;\n+      rtx op01;\n+      rtx op10;\n+      rtx op11;\n+\n+      if (GET_CODE (op0) == PLUS)\n+\top01 = XEXP (op0, 1), op00 = XEXP (op0, 0);\n+      else\n+\top01 = const0_rtx, op00 = op0;\n+\n+      if (GET_CODE (op1) == PLUS)\n+\top11 = XEXP (op1, 1), op10 = XEXP (op1, 0);\n+      else\n+\top11 = const0_rtx, op10 = op1;\n+\n+      /* Find and return common register term if present.  */\n+      if (REG_P (op00) && (op00 == op10 || op00 == op11))\n+\treturn op00;\n+      else if (REG_P (op01) && (op01 == op10 || op01 == op11))\n+\treturn op01;\n+    }\n+\n+  /* No common register term found.  */\n+  return NULL_RTX;\n+}\n+\n+/* Determine the loop iterator and calculate the number of loop\n+   iterations.  Returns the exact number of loop iterations if it can\n+   be calculated, otherwise returns zero.  */\n+\n+static unsigned HOST_WIDE_INT\n+loop_iterations (struct loop *loop)\n+{\n+  struct loop_info *loop_info = LOOP_INFO (loop);\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n+  rtx comparison, comparison_value;\n+  rtx iteration_var, initial_value, increment, final_value;\n+  enum rtx_code comparison_code;\n+  HOST_WIDE_INT inc;\n+  unsigned HOST_WIDE_INT abs_inc;\n+  unsigned HOST_WIDE_INT abs_diff;\n+  int off_by_one;\n+  int increment_dir;\n+  int unsigned_p, compare_dir, final_larger;\n+  rtx last_loop_insn;\n+  struct iv_class *bl;\n+\n+  loop_info->n_iterations = 0;\n+  loop_info->initial_value = 0;\n+  loop_info->initial_equiv_value = 0;\n+  loop_info->comparison_value = 0;\n+  loop_info->final_value = 0;\n+  loop_info->final_equiv_value = 0;\n+  loop_info->increment = 0;\n+  loop_info->iteration_var = 0;\n+  loop_info->iv = 0;\n+\n+  /* We used to use prev_nonnote_insn here, but that fails because it might\n+     accidentally get the branch for a contained loop if the branch for this\n+     loop was deleted.  We can only trust branches immediately before the\n+     loop_end.  */\n+  last_loop_insn = PREV_INSN (loop->end);\n+\n+  /* ??? We should probably try harder to find the jump insn\n+     at the end of the loop.  The following code assumes that\n+     the last loop insn is a jump to the top of the loop.  */\n+  if (!JUMP_P (last_loop_insn))\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Loop iterations: No final conditional branch found.\\n\");\n+      return 0;\n+    }\n+\n+  /* If there is a more than a single jump to the top of the loop\n+     we cannot (easily) determine the iteration count.  */\n+  if (LABEL_NUSES (JUMP_LABEL (last_loop_insn)) > 1)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Loop iterations: Loop has multiple back edges.\\n\");\n+      return 0;\n+    }\n+\n+  /* Find the iteration variable.  If the last insn is a conditional\n+     branch, and the insn before tests a register value, make that the\n+     iteration variable.  */\n+\n+  comparison = get_condition_for_loop (loop, last_loop_insn);\n+  if (comparison == 0)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Loop iterations: No final comparison found.\\n\");\n+      return 0;\n+    }\n+\n+  /* ??? Get_condition may switch position of induction variable and\n+     invariant register when it canonicalizes the comparison.  */\n+\n+  comparison_code = GET_CODE (comparison);\n+  iteration_var = XEXP (comparison, 0);\n+  comparison_value = XEXP (comparison, 1);\n+\n+  if (!REG_P (iteration_var))\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Loop iterations: Comparison not against register.\\n\");\n+      return 0;\n+    }\n+\n+  /* The only new registers that are created before loop iterations\n+     are givs made from biv increments or registers created by\n+     load_mems.  In the latter case, it is possible that try_copy_prop\n+     will propagate a new pseudo into the old iteration register but\n+     this will be marked by having the REG_USERVAR_P bit set.  */\n+\n+  if ((unsigned) REGNO (iteration_var) >= ivs->n_regs\n+      && ! REG_USERVAR_P (iteration_var))\n+    abort ();\n+\n+  /* Determine the initial value of the iteration variable, and the amount\n+     that it is incremented each loop.  Use the tables constructed by\n+     the strength reduction pass to calculate these values.  */\n+\n+  /* Clear the result values, in case no answer can be found.  */\n+  initial_value = 0;\n+  increment = 0;\n+\n+  /* The iteration variable can be either a giv or a biv.  Check to see\n+     which it is, and compute the variable's initial value, and increment\n+     value if possible.  */\n+\n+  /* If this is a new register, can't handle it since we don't have any\n+     reg_iv_type entry for it.  */\n+  if ((unsigned) REGNO (iteration_var) >= ivs->n_regs)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Loop iterations: No reg_iv_type entry for iteration var.\\n\");\n+      return 0;\n+    }\n+\n+  /* Reject iteration variables larger than the host wide int size, since they\n+     could result in a number of iterations greater than the range of our\n+     `unsigned HOST_WIDE_INT' variable loop_info->n_iterations.  */\n+  else if ((GET_MODE_BITSIZE (GET_MODE (iteration_var))\n+\t    > HOST_BITS_PER_WIDE_INT))\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Loop iterations: Iteration var rejected because mode too large.\\n\");\n+      return 0;\n+    }\n+  else if (GET_MODE_CLASS (GET_MODE (iteration_var)) != MODE_INT)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Loop iterations: Iteration var not an integer.\\n\");\n+      return 0;\n+    }\n+\n+  /* Try swapping the comparison to identify a suitable iv.  */\n+  if (REG_IV_TYPE (ivs, REGNO (iteration_var)) != BASIC_INDUCT\n+      && REG_IV_TYPE (ivs, REGNO (iteration_var)) != GENERAL_INDUCT\n+      && REG_P (comparison_value)\n+      && REGNO (comparison_value) < ivs->n_regs)\n+    {\n+      rtx temp = comparison_value;\n+      comparison_code = swap_condition (comparison_code);\n+      comparison_value = iteration_var;\n+      iteration_var = temp;\n+    }\n+\n+  if (REG_IV_TYPE (ivs, REGNO (iteration_var)) == BASIC_INDUCT)\n+    {\n+      if (REGNO (iteration_var) >= ivs->n_regs)\n+\tabort ();\n+\n+      /* Grab initial value, only useful if it is a constant.  */\n+      bl = REG_IV_CLASS (ivs, REGNO (iteration_var));\n+      initial_value = bl->initial_value;\n+      if (!bl->biv->always_executed || bl->biv->maybe_multiple)\n+\t{\n+\t  if (loop_dump_stream)\n+\t    fprintf (loop_dump_stream,\n+\t\t     \"Loop iterations: Basic induction var not set once in each iteration.\\n\");\n+\t  return 0;\n+\t}\n+\n+      increment = biv_total_increment (bl);\n+    }\n+  else if (REG_IV_TYPE (ivs, REGNO (iteration_var)) == GENERAL_INDUCT)\n+    {\n+      HOST_WIDE_INT offset = 0;\n+      struct induction *v = REG_IV_INFO (ivs, REGNO (iteration_var));\n+      rtx biv_initial_value;\n+\n+      if (REGNO (v->src_reg) >= ivs->n_regs)\n+\tabort ();\n+\n+      if (!v->always_executed || v->maybe_multiple)\n+\t{\n+\t  if (loop_dump_stream)\n+\t    fprintf (loop_dump_stream,\n+\t\t     \"Loop iterations: General induction var not set once in each iteration.\\n\");\n+\t  return 0;\n+\t}\n+\n+      bl = REG_IV_CLASS (ivs, REGNO (v->src_reg));\n+\n+      /* Increment value is mult_val times the increment value of the biv.  */\n+\n+      increment = biv_total_increment (bl);\n+      if (increment)\n+\t{\n+\t  struct induction *biv_inc;\n+\n+\t  increment = fold_rtx_mult_add (v->mult_val,\n+\t\t\t\t\t extend_value_for_giv (v, increment),\n+\t\t\t\t\t const0_rtx, v->mode);\n+\t  /* The caller assumes that one full increment has occurred at the\n+\t     first loop test.  But that's not true when the biv is incremented\n+\t     after the giv is set (which is the usual case), e.g.:\n+\t     i = 6; do {;} while (i++ < 9) .\n+\t     Therefore, we bias the initial value by subtracting the amount of\n+\t     the increment that occurs between the giv set and the giv test.  */\n+\t  for (biv_inc = bl->biv; biv_inc; biv_inc = biv_inc->next_iv)\n+\t    {\n+\t      if (loop_insn_first_p (v->insn, biv_inc->insn))\n+\t\t{\n+\t\t  if (REG_P (biv_inc->add_val))\n+\t\t    {\n+\t\t      if (loop_dump_stream)\n+\t\t\tfprintf (loop_dump_stream,\n+\t\t\t\t \"Loop iterations: Basic induction var add_val is REG %d.\\n\",\n+\t\t\t\t REGNO (biv_inc->add_val));\n+\t\t\treturn 0;\n+\t\t    }\n+\n+\t\t  /* If we have already counted it, skip it.  */\n+\t\t  if (biv_inc->same)\n+\t\t    continue;\n+\n+\t\t  offset -= INTVAL (biv_inc->add_val);\n+\t\t}\n+\t    }\n+\t}\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Loop iterations: Giv iterator, initial value bias %ld.\\n\",\n+\t\t (long) offset);\n+\n+      /* Initial value is mult_val times the biv's initial value plus\n+\t add_val.  Only useful if it is a constant.  */\n+      biv_initial_value = extend_value_for_giv (v, bl->initial_value);\n+      initial_value\n+\t= fold_rtx_mult_add (v->mult_val,\n+\t\t\t     plus_constant (biv_initial_value, offset),\n+\t\t\t     v->add_val, v->mode);\n+    }\n+  else\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Loop iterations: Not basic or general induction var.\\n\");\n+      return 0;\n+    }\n+\n+  if (initial_value == 0)\n+    return 0;\n+\n+  unsigned_p = 0;\n+  off_by_one = 0;\n+  switch (comparison_code)\n+    {\n+    case LEU:\n+      unsigned_p = 1;\n+    case LE:\n+      compare_dir = 1;\n+      off_by_one = 1;\n+      break;\n+    case GEU:\n+      unsigned_p = 1;\n+    case GE:\n+      compare_dir = -1;\n+      off_by_one = -1;\n+      break;\n+    case EQ:\n+      /* Cannot determine loop iterations with this case.  */\n+      compare_dir = 0;\n+      break;\n+    case LTU:\n+      unsigned_p = 1;\n+    case LT:\n+      compare_dir = 1;\n+      break;\n+    case GTU:\n+      unsigned_p = 1;\n+    case GT:\n+      compare_dir = -1;\n+      break;\n+    case NE:\n+      compare_dir = 0;\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  /* If the comparison value is an invariant register, then try to find\n+     its value from the insns before the start of the loop.  */\n+\n+  final_value = comparison_value;\n+  if (REG_P (comparison_value)\n+      && loop_invariant_p (loop, comparison_value))\n+    {\n+      final_value = loop_find_equiv_value (loop, comparison_value);\n+\n+      /* If we don't get an invariant final value, we are better\n+\t off with the original register.  */\n+      if (! loop_invariant_p (loop, final_value))\n+\tfinal_value = comparison_value;\n+    }\n+\n+  /* Calculate the approximate final value of the induction variable\n+     (on the last successful iteration).  The exact final value\n+     depends on the branch operator, and increment sign.  It will be\n+     wrong if the iteration variable is not incremented by one each\n+     time through the loop and (comparison_value + off_by_one -\n+     initial_value) % increment != 0.\n+     ??? Note that the final_value may overflow and thus final_larger\n+     will be bogus.  A potentially infinite loop will be classified\n+     as immediate, e.g. for (i = 0x7ffffff0; i <= 0x7fffffff; i++)  */\n+  if (off_by_one)\n+    final_value = plus_constant (final_value, off_by_one);\n+\n+  /* Save the calculated values describing this loop's bounds, in case\n+     precondition_loop_p will need them later.  These values can not be\n+     recalculated inside precondition_loop_p because strength reduction\n+     optimizations may obscure the loop's structure.\n+\n+     These values are only required by precondition_loop_p and insert_bct\n+     whenever the number of iterations cannot be computed at compile time.\n+     Only the difference between final_value and initial_value is\n+     important.  Note that final_value is only approximate.  */\n+  loop_info->initial_value = initial_value;\n+  loop_info->comparison_value = comparison_value;\n+  loop_info->final_value = plus_constant (comparison_value, off_by_one);\n+  loop_info->increment = increment;\n+  loop_info->iteration_var = iteration_var;\n+  loop_info->comparison_code = comparison_code;\n+  loop_info->iv = bl;\n+\n+  /* Try to determine the iteration count for loops such\n+     as (for i = init; i < init + const; i++).  When running the\n+     loop optimization twice, the first pass often converts simple\n+     loops into this form.  */\n+\n+  if (REG_P (initial_value))\n+    {\n+      rtx reg1;\n+      rtx reg2;\n+      rtx const2;\n+\n+      reg1 = initial_value;\n+      if (GET_CODE (final_value) == PLUS)\n+\treg2 = XEXP (final_value, 0), const2 = XEXP (final_value, 1);\n+      else\n+\treg2 = final_value, const2 = const0_rtx;\n+\n+      /* Check for initial_value = reg1, final_value = reg2 + const2,\n+\t where reg1 != reg2.  */\n+      if (REG_P (reg2) && reg2 != reg1)\n+\t{\n+\t  rtx temp;\n+\n+\t  /* Find what reg1 is equivalent to.  Hopefully it will\n+\t     either be reg2 or reg2 plus a constant.  */\n+\t  temp = loop_find_equiv_value (loop, reg1);\n+\n+\t  if (find_common_reg_term (temp, reg2))\n+\t    initial_value = temp;\n+\t  else if (loop_invariant_p (loop, reg2))\n+\t    {\n+\t      /* Find what reg2 is equivalent to.  Hopefully it will\n+\t\t either be reg1 or reg1 plus a constant.  Let's ignore\n+\t\t the latter case for now since it is not so common.  */\n+\t      temp = loop_find_equiv_value (loop, reg2);\n+\n+\t      if (temp == loop_info->iteration_var)\n+\t\ttemp = initial_value;\n+\t      if (temp == reg1)\n+\t\tfinal_value = (const2 == const0_rtx)\n+\t\t  ? reg1 : gen_rtx_PLUS (GET_MODE (reg1), reg1, const2);\n+\t    }\n+\t}\n+    }\n+\n+  loop_info->initial_equiv_value = initial_value;\n+  loop_info->final_equiv_value = final_value;\n+\n+  /* For EQ comparison loops, we don't have a valid final value.\n+     Check this now so that we won't leave an invalid value if we\n+     return early for any other reason.  */\n+  if (comparison_code == EQ)\n+    loop_info->final_equiv_value = loop_info->final_value = 0;\n+\n+  if (increment == 0)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Loop iterations: Increment value can't be calculated.\\n\");\n+      return 0;\n+    }\n+\n+  if (GET_CODE (increment) != CONST_INT)\n+    {\n+      /* If we have a REG, check to see if REG holds a constant value.  */\n+      /* ??? Other RTL, such as (neg (reg)) is possible here, but it isn't\n+\t clear if it is worthwhile to try to handle such RTL.  */\n+      if (REG_P (increment) || GET_CODE (increment) == SUBREG)\n+\tincrement = loop_find_equiv_value (loop, increment);\n+\n+      if (GET_CODE (increment) != CONST_INT)\n+\t{\n+\t  if (loop_dump_stream)\n+\t    {\n+\t      fprintf (loop_dump_stream,\n+\t\t       \"Loop iterations: Increment value not constant \");\n+\t      print_simple_rtl (loop_dump_stream, increment);\n+\t      fprintf (loop_dump_stream, \".\\n\");\n+\t    }\n+\t  return 0;\n+\t}\n+      loop_info->increment = increment;\n+    }\n+\n+  if (GET_CODE (initial_value) != CONST_INT)\n+    {\n+      if (loop_dump_stream)\n+\t{\n+\t  fprintf (loop_dump_stream,\n+\t\t   \"Loop iterations: Initial value not constant \");\n+\t  print_simple_rtl (loop_dump_stream, initial_value);\n+\t  fprintf (loop_dump_stream, \".\\n\");\n+\t}\n+      return 0;\n+    }\n+  else if (GET_CODE (final_value) != CONST_INT)\n+    {\n+      if (loop_dump_stream)\n+\t{\n+\t  fprintf (loop_dump_stream,\n+\t\t   \"Loop iterations: Final value not constant \");\n+\t  print_simple_rtl (loop_dump_stream, final_value);\n+\t  fprintf (loop_dump_stream, \".\\n\");\n+\t}\n+      return 0;\n+    }\n+  else if (comparison_code == EQ)\n+    {\n+      rtx inc_once;\n+\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream, \"Loop iterations: EQ comparison loop.\\n\");\n+\n+      inc_once = gen_int_mode (INTVAL (initial_value) + INTVAL (increment),\n+\t\t\t       GET_MODE (iteration_var));\n+\n+      if (inc_once == final_value)\n+\t{\n+\t  /* The iterator value once through the loop is equal to the\n+\t     comparison value.  Either we have an infinite loop, or\n+\t     we'll loop twice.  */\n+\t  if (increment == const0_rtx)\n+\t    return 0;\n+\t  loop_info->n_iterations = 2;\n+\t}\n+      else\n+\tloop_info->n_iterations = 1;\n+\n+      if (GET_CODE (loop_info->initial_value) == CONST_INT)\n+\tloop_info->final_value\n+\t  = gen_int_mode ((INTVAL (loop_info->initial_value)\n+\t\t\t   + loop_info->n_iterations * INTVAL (increment)),\n+\t\t\t  GET_MODE (iteration_var));\n+      else\n+\tloop_info->final_value\n+\t  = plus_constant (loop_info->initial_value,\n+\t\t\t   loop_info->n_iterations * INTVAL (increment));\n+      loop_info->final_equiv_value\n+\t= gen_int_mode ((INTVAL (initial_value)\n+\t\t\t + loop_info->n_iterations * INTVAL (increment)),\n+\t\t\tGET_MODE (iteration_var));\n+      return loop_info->n_iterations;\n+    }\n+\n+  /* Final_larger is 1 if final larger, 0 if they are equal, otherwise -1.  */\n+  if (unsigned_p)\n+    final_larger\n+      = ((unsigned HOST_WIDE_INT) INTVAL (final_value)\n+\t > (unsigned HOST_WIDE_INT) INTVAL (initial_value))\n+\t- ((unsigned HOST_WIDE_INT) INTVAL (final_value)\n+\t   < (unsigned HOST_WIDE_INT) INTVAL (initial_value));\n+  else\n+    final_larger = (INTVAL (final_value) > INTVAL (initial_value))\n+      - (INTVAL (final_value) < INTVAL (initial_value));\n+\n+  if (INTVAL (increment) > 0)\n+    increment_dir = 1;\n+  else if (INTVAL (increment) == 0)\n+    increment_dir = 0;\n+  else\n+    increment_dir = -1;\n+\n+  /* There are 27 different cases: compare_dir = -1, 0, 1;\n+     final_larger = -1, 0, 1; increment_dir = -1, 0, 1.\n+     There are 4 normal cases, 4 reverse cases (where the iteration variable\n+     will overflow before the loop exits), 4 infinite loop cases, and 15\n+     immediate exit (0 or 1 iteration depending on loop type) cases.\n+     Only try to optimize the normal cases.  */\n+\n+  /* (compare_dir/final_larger/increment_dir)\n+     Normal cases: (0/-1/-1), (0/1/1), (-1/-1/-1), (1/1/1)\n+     Reverse cases: (0/-1/1), (0/1/-1), (-1/-1/1), (1/1/-1)\n+     Infinite loops: (0/-1/0), (0/1/0), (-1/-1/0), (1/1/0)\n+     Immediate exit: (0/0/X), (-1/0/X), (-1/1/X), (1/0/X), (1/-1/X) */\n+\n+  /* ?? If the meaning of reverse loops (where the iteration variable\n+     will overflow before the loop exits) is undefined, then could\n+     eliminate all of these special checks, and just always assume\n+     the loops are normal/immediate/infinite.  Note that this means\n+     the sign of increment_dir does not have to be known.  Also,\n+     since it does not really hurt if immediate exit loops or infinite loops\n+     are optimized, then that case could be ignored also, and hence all\n+     loops can be optimized.\n+\n+     According to ANSI Spec, the reverse loop case result is undefined,\n+     because the action on overflow is undefined.\n+\n+     See also the special test for NE loops below.  */\n+\n+  if (final_larger == increment_dir && final_larger != 0\n+      && (final_larger == compare_dir || compare_dir == 0))\n+    /* Normal case.  */\n+    ;\n+  else\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream, \"Loop iterations: Not normal loop.\\n\");\n+      return 0;\n+    }\n+\n+  /* Calculate the number of iterations, final_value is only an approximation,\n+     so correct for that.  Note that abs_diff and n_iterations are\n+     unsigned, because they can be as large as 2^n - 1.  */\n+\n+  inc = INTVAL (increment);\n+  if (inc > 0)\n+    {\n+      abs_diff = INTVAL (final_value) - INTVAL (initial_value);\n+      abs_inc = inc;\n+    }\n+  else if (inc < 0)\n+    {\n+      abs_diff = INTVAL (initial_value) - INTVAL (final_value);\n+      abs_inc = -inc;\n+    }\n+  else\n+    abort ();\n+\n+  /* Given that iteration_var is going to iterate over its own mode,\n+     not HOST_WIDE_INT, disregard higher bits that might have come\n+     into the picture due to sign extension of initial and final\n+     values.  */\n+  abs_diff &= ((unsigned HOST_WIDE_INT) 1\n+\t       << (GET_MODE_BITSIZE (GET_MODE (iteration_var)) - 1)\n+\t       << 1) - 1;\n+\n+  /* For NE tests, make sure that the iteration variable won't miss\n+     the final value.  If abs_diff mod abs_incr is not zero, then the\n+     iteration variable will overflow before the loop exits, and we\n+     can not calculate the number of iterations.  */\n+  if (compare_dir == 0 && (abs_diff % abs_inc) != 0)\n+    return 0;\n+\n+  /* Note that the number of iterations could be calculated using\n+     (abs_diff + abs_inc - 1) / abs_inc, provided care was taken to\n+     handle potential overflow of the summation.  */\n+  loop_info->n_iterations = abs_diff / abs_inc + ((abs_diff % abs_inc) != 0);\n+  return loop_info->n_iterations;\n+}\n \n /* Perform strength reduction and induction variable elimination.\n \n@@ -5016,7 +6294,6 @@ strength_reduce (struct loop *loop, int flags)\n   /* Map of pseudo-register replacements.  */\n   rtx *reg_map = NULL;\n   int reg_map_size;\n-  int unrolled_insn_copies = 0;\n   rtx test_reg = gen_rtx_REG (word_mode, LAST_VIRTUAL_REGISTER + 1);\n   int insn_count = count_insns_in_loop (loop);\n \n@@ -5031,11 +6308,6 @@ strength_reduce (struct loop *loop, int flags)\n   /* Exit if there are no bivs.  */\n   if (! ivs->list)\n     {\n-      /* Can still unroll the loop anyways, but indicate that there is no\n-\t strength reduction info available.  */\n-      if (flags & LOOP_UNROLL)\n-\tunroll_loop (loop, insn_count, 0);\n-\n       loop_ivs_free (loop);\n       return;\n     }\n@@ -5247,43 +6519,6 @@ strength_reduce (struct loop *loop, int flags)\n \tINSN_CODE (p) = -1;\n       }\n \n-  if (loop_info->n_iterations > 0)\n-    {\n-      /* When we completely unroll a loop we will likely not need the increment\n-\t of the loop BIV and we will not need the conditional branch at the\n-\t end of the loop.  */\n-      unrolled_insn_copies = insn_count - 2;\n-\n-#ifdef HAVE_cc0\n-      /* When we completely unroll a loop on a HAVE_cc0 machine we will not\n-\t need the comparison before the conditional branch at the end of the\n-\t loop.  */\n-      unrolled_insn_copies -= 1;\n-#endif\n-\n-      /* We'll need one copy for each loop iteration.  */\n-      unrolled_insn_copies *= loop_info->n_iterations;\n-\n-      /* A little slop to account for the ability to remove initialization\n-\t code, better CSE, and other secondary benefits of completely\n-\t unrolling some loops.  */\n-      unrolled_insn_copies -= 1;\n-\n-      /* Clamp the value.  */\n-      if (unrolled_insn_copies < 0)\n-\tunrolled_insn_copies = 0;\n-    }\n-\n-  /* Unroll loops from within strength reduction so that we can use the\n-     induction variable information that strength_reduce has already\n-     collected.  Always unroll loops that would be as small or smaller\n-     unrolled than when rolled.  */\n-  if ((flags & LOOP_UNROLL)\n-      || ((flags & LOOP_AUTO_UNROLL)\n-\t  && loop_info->n_iterations > 0\n-\t  && unrolled_insn_copies <= insn_count))\n-    unroll_loop (loop, insn_count, 1);\n-\n   if (loop_dump_stream)\n     fprintf (loop_dump_stream, \"\\n\");\n \n@@ -5677,7 +6912,6 @@ record_giv (const struct loop *loop, struct induction *v, rtx insn,\n   v->final_value = 0;\n   v->same_insn = 0;\n   v->auto_inc_opt = 0;\n-  v->unrolled = 0;\n   v->shared = 0;\n \n   /* The v->always_computable field is used in update_giv_derive, to\n@@ -5837,6 +7071,132 @@ record_giv (const struct loop *loop, struct induction *v, rtx insn,\n     loop_giv_dump (v, loop_dump_stream, 0);\n }\n \n+/* Try to calculate the final value of the giv, the value it will have at\n+   the end of the loop.  If we can do it, return that value.  */\n+\n+static rtx\n+final_giv_value (const struct loop *loop, struct induction *v)\n+{\n+  struct loop_ivs *ivs = LOOP_IVS (loop);\n+  struct iv_class *bl;\n+  rtx insn;\n+  rtx increment, tem;\n+  rtx seq;\n+  rtx loop_end = loop->end;\n+  unsigned HOST_WIDE_INT n_iterations = LOOP_INFO (loop)->n_iterations;\n+\n+  bl = REG_IV_CLASS (ivs, REGNO (v->src_reg));\n+\n+  /* The final value for givs which depend on reversed bivs must be calculated\n+     differently than for ordinary givs.  In this case, there is already an\n+     insn after the loop which sets this giv's final value (if necessary),\n+     and there are no other loop exits, so we can return any value.  */\n+  if (bl->reversed)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Final giv value for %d, depends on reversed biv\\n\",\n+\t\t REGNO (v->dest_reg));\n+      return const0_rtx;\n+    }\n+\n+  /* Try to calculate the final value as a function of the biv it depends\n+     upon.  The only exit from the loop must be the fall through at the bottom\n+     and the insn that sets the giv must be executed on every iteration\n+     (otherwise the giv may not have its final value when the loop exits).  */\n+\n+  /* ??? Can calculate the final giv value by subtracting off the\n+     extra biv increments times the giv's mult_val.  The loop must have\n+     only one exit for this to work, but the loop iterations does not need\n+     to be known.  */\n+\n+  if (n_iterations != 0\n+      && ! loop->exit_count\n+      && v->always_executed)\n+    {\n+      /* ?? It is tempting to use the biv's value here since these insns will\n+\t be put after the loop, and hence the biv will have its final value\n+\t then.  However, this fails if the biv is subsequently eliminated.\n+\t Perhaps determine whether biv's are eliminable before trying to\n+\t determine whether giv's are replaceable so that we can use the\n+\t biv value here if it is not eliminable.  */\n+\n+      /* We are emitting code after the end of the loop, so we must make\n+\t sure that bl->initial_value is still valid then.  It will still\n+\t be valid if it is invariant.  */\n+\n+      increment = biv_total_increment (bl);\n+\n+      if (increment && loop_invariant_p (loop, increment)\n+\t  && loop_invariant_p (loop, bl->initial_value))\n+\t{\n+\t  /* Can calculate the loop exit value of its biv as\n+\t     (n_iterations * increment) + initial_value */\n+\n+\t  /* The loop exit value of the giv is then\n+\t     (final_biv_value - extra increments) * mult_val + add_val.\n+\t     The extra increments are any increments to the biv which\n+\t     occur in the loop after the giv's value is calculated.\n+\t     We must search from the insn that sets the giv to the end\n+\t     of the loop to calculate this value.  */\n+\n+\t  /* Put the final biv value in tem.  */\n+\t  tem = gen_reg_rtx (v->mode);\n+\t  record_base_value (REGNO (tem), bl->biv->add_val, 0);\n+\t  loop_iv_add_mult_sink (loop, extend_value_for_giv (v, increment),\n+\t\t\t\t GEN_INT (n_iterations),\n+\t\t\t\t extend_value_for_giv (v, bl->initial_value),\n+\t\t\t\t tem);\n+\n+\t  /* Subtract off extra increments as we find them.  */\n+\t  for (insn = NEXT_INSN (v->insn); insn != loop_end;\n+\t       insn = NEXT_INSN (insn))\n+\t    {\n+\t      struct induction *biv;\n+\n+\t      for (biv = bl->biv; biv; biv = biv->next_iv)\n+\t\tif (biv->insn == insn)\n+\t\t  {\n+\t\t    start_sequence ();\n+\t\t    tem = expand_simple_binop (GET_MODE (tem), MINUS, tem,\n+\t\t\t\t\t       biv->add_val, NULL_RTX, 0,\n+\t\t\t\t\t       OPTAB_LIB_WIDEN);\n+\t\t    seq = get_insns ();\n+\t\t    end_sequence ();\n+\t\t    loop_insn_sink (loop, seq);\n+\t\t  }\n+\t    }\n+\n+\t  /* Now calculate the giv's final value.  */\n+\t  loop_iv_add_mult_sink (loop, tem, v->mult_val, v->add_val, tem);\n+\n+\t  if (loop_dump_stream)\n+\t    fprintf (loop_dump_stream,\n+\t\t     \"Final giv value for %d, calc from biv's value.\\n\",\n+\t\t     REGNO (v->dest_reg));\n+\n+\t  return tem;\n+\t}\n+    }\n+\n+  /* Replaceable giv's should never reach here.  */\n+  if (v->replaceable)\n+    abort ();\n+\n+  /* Check to see if the biv is dead at all loop exits.  */\n+  if (reg_dead_after_loop (loop, v->dest_reg))\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Final giv value for %d, giv dead after loop exit.\\n\",\n+\t\t REGNO (v->dest_reg));\n+\n+      return const0_rtx;\n+    }\n+\n+  return 0;\n+}\n+\n /* All this does is determine whether a giv can be made replaceable because\n    its final value can be calculated.  This code can not be part of record_giv\n    above, because final_giv_value requires that the number of loop iterations\n@@ -7124,7 +8484,7 @@ express_from_1 (rtx a, rtx b, rtx mult)\n   return NULL_RTX;\n }\n \n-rtx\n+static rtx\n express_from (struct induction *g1, struct induction *g2)\n {\n   rtx mult, add;\n@@ -7440,7 +8800,7 @@ check_ext_dependent_givs (const struct loop *loop, struct iv_class *bl)\n \n /* Generate a version of VALUE in a mode appropriate for initializing V.  */\n \n-rtx\n+static rtx\n extend_value_for_giv (struct induction *v, rtx value)\n {\n   rtx ext_dep = v->ext_dependent;\n@@ -7702,7 +9062,7 @@ loop_regs_update (const struct loop *loop ATTRIBUTE_UNUSED, rtx seq)\n    multiplicative constant, A an additive constant and REG the\n    destination register.  */\n \n-void\n+static void\n loop_iv_add_mult_emit_before (const struct loop *loop, rtx b, rtx m, rtx a,\n \t\t\t      rtx reg, basic_block before_bb, rtx before_insn)\n {\n@@ -7736,7 +9096,7 @@ loop_iv_add_mult_emit_before (const struct loop *loop, rtx b, rtx m, rtx a,\n    constant, A an additive constant and REG the destination\n    register.  */\n \n-void\n+static void\n loop_iv_add_mult_sink (const struct loop *loop, rtx b, rtx m, rtx a, rtx reg)\n {\n   rtx seq;\n@@ -7763,7 +9123,7 @@ loop_iv_add_mult_sink (const struct loop *loop, rtx b, rtx m, rtx a, rtx reg)\n    value of the basic induction variable, M a multiplicative constant,\n    A an additive constant and REG the destination register.  */\n \n-void\n+static void\n loop_iv_add_mult_hoist (const struct loop *loop, rtx b, rtx m, rtx a, rtx reg)\n {\n   rtx seq;\n@@ -8572,7 +9932,7 @@ maybe_eliminate_biv (const struct loop *loop, struct iv_class *bl,\n /* INSN and REFERENCE are instructions in the same insn chain.\n    Return nonzero if INSN is first.  */\n \n-int\n+static int\n loop_insn_first_p (rtx insn, rtx reference)\n {\n   rtx p, q;\n@@ -9392,7 +10752,7 @@ get_condition (rtx jump, rtx *earliest, int allow_cc_mode, int valid_at_insn_p)\n /* Similar to above routine, except that we also put an invariant last\n    unless both operands are invariants.  */\n \n-rtx\n+static rtx\n get_condition_for_loop (const struct loop *loop, rtx x)\n {\n   rtx comparison = get_condition (x, (rtx*) 0, false, true);\n@@ -10350,7 +11710,7 @@ loop_insn_emit_after (const struct loop *loop ATTRIBUTE_UNUSED,\n    in basic block WHERE_BB (ignored in the interim) within the loop\n    otherwise hoist PATTERN into the loop pre-header.  */\n \n-rtx\n+static rtx\n loop_insn_emit_before (const struct loop *loop,\n \t\t       basic_block where_bb ATTRIBUTE_UNUSED,\n \t\t       rtx where_insn, rtx pattern)\n@@ -10375,7 +11735,7 @@ loop_call_insn_emit_before (const struct loop *loop ATTRIBUTE_UNUSED,\n \n /* Hoist insn for PATTERN into the loop pre-header.  */\n \n-rtx\n+static rtx\n loop_insn_hoist (const struct loop *loop, rtx pattern)\n {\n   return loop_insn_emit_before (loop, 0, loop->start, pattern);\n@@ -10393,7 +11753,7 @@ loop_call_insn_hoist (const struct loop *loop, rtx pattern)\n \n /* Sink insn for PATTERN after the loop end.  */\n \n-rtx\n+static rtx\n loop_insn_sink (const struct loop *loop, rtx pattern)\n {\n   return loop_insn_emit_before (loop, 0, loop->sink, pattern);"}, {"sha": "13b0398e83c651e0d0e72b477d03a2087074136e", "filename": "gcc/loop.h", "status": "removed", "additions": 0, "deletions": 430, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032618223ba81a0f01b4b20241c0b0a9859db29b/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032618223ba81a0f01b4b20241c0b0a9859db29b/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=032618223ba81a0f01b4b20241c0b0a9859db29b", "patch": "@@ -1,430 +0,0 @@\n-/* Loop optimization definitions for GCC\n-   Copyright (C) 1991, 1995, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n-   Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 2, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to the Free\n-Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-02111-1307, USA.  */\n-\n-#include \"bitmap.h\"\n-#include \"sbitmap.h\"\n-#include \"hard-reg-set.h\"\n-#include \"basic-block.h\"\n-\n-/* Flags passed to loop_optimize.  */\n-#define LOOP_UNROLL 1\n-#define LOOP_PREFETCH 2\n-#define LOOP_AUTO_UNROLL 4\n-\n-/* Get the loop info pointer of a loop.  */\n-#define LOOP_INFO(LOOP) ((struct loop_info *) (LOOP)->aux)\n-\n-/* Get a pointer to the loop movables structure.  */\n-#define LOOP_MOVABLES(LOOP) (&LOOP_INFO (LOOP)->movables)\n-\n-/* Get a pointer to the loop registers structure.  */\n-#define LOOP_REGS(LOOP) (&LOOP_INFO (LOOP)->regs)\n-\n-/* Get a pointer to the loop induction variables structure.  */\n-#define LOOP_IVS(LOOP) (&LOOP_INFO (LOOP)->ivs)\n-\n-/* Get the luid of an insn.  Catch the error of trying to reference the LUID\n-   of an insn added during loop, since these don't have LUIDs.  */\n-\n-#define INSN_LUID(INSN)\t\t\t\\\n-  (INSN_UID (INSN) < max_uid_for_loop ? uid_luid[INSN_UID (INSN)] \\\n-   : (abort (), -1))\n-\n-#define REGNO_FIRST_LUID(REGNO)\t\t\t\\\n-  (REGNO_FIRST_UID (REGNO) < max_uid_for_loop\t\\\n-\t? uid_luid[REGNO_FIRST_UID (REGNO)]\t\\\n-\t: 0)\n-#define REGNO_LAST_LUID(REGNO)\t\t\t\\\n-  (REGNO_LAST_UID (REGNO) < max_uid_for_loop\t\\\n-\t? uid_luid[REGNO_LAST_UID (REGNO)]\t\\\n-\t: INT_MAX)\n-\n-/* A \"basic induction variable\" or biv is a pseudo reg that is set\n-   (within this loop) only by incrementing or decrementing it.  */\n-/* A \"general induction variable\" or giv is a pseudo reg whose\n-   value is a linear function of a biv.  */\n-\n-/* Bivs are recognized by `basic_induction_var';\n-   Givs by `general_induction_var'.  */\n-\n-/* An enum for the two different types of givs, those that are used\n-   as memory addresses and those that are calculated into registers.  */\n-enum g_types\n-{\n-  DEST_ADDR,\n-  DEST_REG\n-};\n-\n-\n-/* A `struct induction' is created for every instruction that sets\n-   an induction variable (either a biv or a giv).  */\n-\n-struct induction\n-{\n-  rtx insn;\t\t\t/* The insn that sets a biv or giv */\n-  rtx new_reg;\t\t\t/* New register, containing strength reduced\n-\t\t\t\t   version of this giv.  */\n-  rtx src_reg;\t\t\t/* Biv from which this giv is computed.\n-\t\t\t\t   (If this is a biv, then this is the biv.) */\n-  enum g_types giv_type;\t/* Indicate whether DEST_ADDR or DEST_REG */\n-  rtx dest_reg;\t\t\t/* Destination register for insn: this is the\n-\t\t\t\t   register which was the biv or giv.\n-\t\t\t\t   For a biv, this equals src_reg.\n-\t\t\t\t   For a DEST_ADDR type giv, this is 0.  */\n-  rtx *location;\t\t/* Place in the insn where this giv occurs.\n-\t\t\t\t   If GIV_TYPE is DEST_REG, this is 0.  */\n-\t\t\t\t/* For a biv, this is the place where add_val\n-\t\t\t\t   was found.  */\n-  enum machine_mode mode;\t/* The mode of this biv or giv */\n-  rtx mem;\t\t\t/* For DEST_ADDR, the memory object.  */\n-  rtx mult_val;\t\t\t/* Multiplicative factor for src_reg.  */\n-  rtx add_val;\t\t\t/* Additive constant for that product.  */\n-  int benefit;\t\t\t/* Gain from eliminating this insn.  */\n-  rtx final_value;\t\t/* If the giv is used outside the loop, and its\n-\t\t\t\t   final value could be calculated, it is put\n-\t\t\t\t   here, and the giv is made replaceable.  Set\n-\t\t\t\t   the giv to this value before the loop.  */\n-  unsigned combined_with;\t/* The number of givs this giv has been\n-\t\t\t\t   combined with.  If nonzero, this giv\n-\t\t\t\t   cannot combine with any other giv.  */\n-  unsigned replaceable : 1;\t/* 1 if we can substitute the strength-reduced\n-\t\t\t\t   variable for the original variable.\n-\t\t\t\t   0 means they must be kept separate and the\n-\t\t\t\t   new one must be copied into the old pseudo\n-\t\t\t\t   reg each time the old one is set.  */\n-  unsigned not_replaceable : 1;\t/* Used to prevent duplicating work.  This is\n-\t\t\t\t   1 if we know that the giv definitely can\n-\t\t\t\t   not be made replaceable, in which case we\n-\t\t\t\t   don't bother checking the variable again\n-\t\t\t\t   even if further info is available.\n-\t\t\t\t   Both this and the above can be zero.  */\n-  unsigned ignore : 1;\t\t/* 1 prohibits further processing of giv */\n-  unsigned always_computable : 1;/* 1 if this value is computable every\n-\t\t\t\t    iteration.  */\n-  unsigned always_executed : 1; /* 1 if this set occurs each iteration.  */\n-  unsigned maybe_multiple : 1;\t/* Only used for a biv and  1 if this biv\n-\t\t\t\t   update may be done multiple times per\n-\t\t\t\t   iteration.  */\n-  unsigned cant_derive : 1;\t/* For giv's, 1 if this giv cannot derive\n-\t\t\t\t   another giv.  This occurs in many cases\n-\t\t\t\t   where a giv's lifetime spans an update to\n-\t\t\t\t   a biv.  */\n-  unsigned maybe_dead : 1;\t/* 1 if this giv might be dead.  In that case,\n-\t\t\t\t   we won't use it to eliminate a biv, it\n-\t\t\t\t   would probably lose.  */\n-  unsigned auto_inc_opt : 1;\t/* 1 if this giv had its increment output next\n-\t\t\t\t   to it to try to form an auto-inc address.  */\n-  unsigned unrolled : 1;\t/* 1 if new register has been allocated and\n-\t\t\t\t   initialized in unrolled loop.  */\n-  unsigned shared : 1;\n-  unsigned no_const_addval : 1; /* 1 if add_val does not contain a const.  */\n-  int lifetime;\t\t\t/* Length of life of this giv */\n-  rtx derive_adjustment;\t/* If nonzero, is an adjustment to be\n-\t\t\t\t   subtracted from add_val when this giv\n-\t\t\t\t   derives another.  This occurs when the\n-\t\t\t\t   giv spans a biv update by incrementation.  */\n-  rtx ext_dependent;\t\t/* If nonzero, is a sign or zero extension\n-\t\t\t\t   if a biv on which this giv is dependent.  */\n-  struct induction *next_iv;\t/* For givs, links together all givs that are\n-\t\t\t\t   based on the same biv.  For bivs, links\n-\t\t\t\t   together all biv entries that refer to the\n-\t\t\t\t   same biv register.  */\n-  struct induction *same;\t/* For givs, if the giv has been combined with\n-\t\t\t\t   another giv, this points to the base giv.\n-\t\t\t\t   The base giv will have COMBINED_WITH nonzero.\n-\t\t\t\t   For bivs, if the biv has the same LOCATION\n-\t\t\t\t   than another biv, this points to the base\n-\t\t\t\t   biv.  */\n-  HOST_WIDE_INT const_adjust;\t/* Used by loop unrolling, when an address giv\n-\t\t\t\t   is split, and a constant is eliminated from\n-\t\t\t\t   the address, the -constant is stored here\n-\t\t\t\t   for later use.  */\n-  struct induction *same_insn;\t/* If there are multiple identical givs in\n-\t\t\t\t   the same insn, then all but one have this\n-\t\t\t\t   field set, and they all point to the giv\n-\t\t\t\t   that doesn't have this field set.  */\n-  rtx last_use;\t\t\t/* For a giv made from a biv increment, this is\n-\t\t\t\t   a substitute for the lifetime information.  */\n-};\n-\n-\n-/* A `struct iv_class' is created for each biv.  */\n-\n-struct iv_class\n-{\n-  unsigned int regno;\t\t/* Pseudo reg which is the biv.  */\n-  int biv_count;\t\t/* Number of insns setting this reg.  */\n-  struct induction *biv;\t/* List of all insns that set this reg.  */\n-  int giv_count;\t\t/* Number of DEST_REG givs computed from this\n-\t\t\t\t   biv.  The resulting count is only used in\n-\t\t\t\t   check_dbra_loop.  */\n-  struct induction *giv;\t/* List of all insns that compute a giv\n-\t\t\t\t   from this reg.  */\n-  int total_benefit;\t\t/* Sum of BENEFITs of all those givs.  */\n-  rtx initial_value;\t\t/* Value of reg at loop start.  */\n-  rtx initial_test;\t\t/* Test performed on BIV before loop.  */\n-  rtx final_value;\t\t/* Value of reg at loop end, if known.  */\n-  struct iv_class *next;\t/* Links all class structures together.  */\n-  rtx init_insn;\t\t/* insn which initializes biv, 0 if none.  */\n-  rtx init_set;\t\t\t/* SET of INIT_INSN, if any.  */\n-  unsigned incremented : 1;\t/* 1 if somewhere incremented/decremented */\n-  unsigned eliminable : 1;\t/* 1 if plausible candidate for\n-                                   elimination.  */\n-  unsigned nonneg : 1;\t\t/* 1 if we added a REG_NONNEG note for\n-                                   this.  */\n-  unsigned reversed : 1;\t/* 1 if we reversed the loop that this\n-\t\t\t\t   biv controls.  */\n-  unsigned all_reduced : 1;\t/* 1 if all givs using this biv have\n-                                   been reduced.  */\n-};\n-\n-\n-/* Definitions used by the basic induction variable discovery code.  */\n-enum iv_mode\n-{\n-  UNKNOWN_INDUCT,\n-  BASIC_INDUCT,\n-  NOT_BASIC_INDUCT,\n-  GENERAL_INDUCT\n-};\n-\n-\n-/* A `struct iv' is created for every register.  */\n-\n-struct iv\n-{\n-  enum iv_mode type;\n-  union\n-  {\n-    struct iv_class *class;\n-    struct induction *info;\n-  } iv;\n-};\n-\n-\n-#define REG_IV_TYPE(ivs, n) ivs->regs[n].type\n-#define REG_IV_INFO(ivs, n) ivs->regs[n].iv.info\n-#define REG_IV_CLASS(ivs, n) ivs->regs[n].iv.class\n-\n-\n-struct loop_ivs\n-{\n-  /* Indexed by register number, contains pointer to `struct\n-     iv' if register is an induction variable.  */\n-  struct iv *regs;\n-\n-  /* Size of regs array.  */\n-  unsigned int n_regs;\n-\n-  /* The head of a list which links together (via the next field)\n-     every iv class for the current loop.  */\n-  struct iv_class *list;\n-};\n-\n-\n-typedef struct loop_mem_info\n-{\n-  rtx mem;      /* The MEM itself.  */\n-  rtx reg;      /* Corresponding pseudo, if any.  */\n-  int optimize; /* Nonzero if we can optimize access to this MEM.  */\n-} loop_mem_info;\n-\n-\n-\n-struct loop_reg\n-{\n-  /* Number of times the reg is set during the loop being scanned.\n-     During code motion, a negative value indicates a reg that has\n-     been made a candidate; in particular -2 means that it is an\n-     candidate that we know is equal to a constant and -1 means that\n-     it is a candidate not known equal to a constant.  After code\n-     motion, regs moved have 0 (which is accurate now) while the\n-     failed candidates have the original number of times set.\n-\n-     Therefore, at all times, == 0 indicates an invariant register;\n-     < 0 a conditionally invariant one.  */\n-  int set_in_loop;\n-\n-  /* Original value of set_in_loop; same except that this value\n-     is not set negative for a reg whose sets have been made candidates\n-     and not set to 0 for a reg that is moved.  */\n-  int n_times_set;\n-\n-  /* Contains the insn in which a register was used if it was used\n-     exactly once; contains const0_rtx if it was used more than once.  */\n-  rtx single_usage;\n-\n-  /* Nonzero indicates that the register cannot be moved or strength\n-     reduced.  */\n-  char may_not_optimize;\n-\n-  /* Nonzero means reg N has already been moved out of one loop.\n-     This reduces the desire to move it out of another.  */\n-  char moved_once;\n-};\n-\n-\n-struct loop_regs\n-{\n-  int num;\t\t\t/* Number of regs used in table.  */\n-  int size;\t\t\t/* Size of table.  */\n-  struct loop_reg *array;\t/* Register usage info. array.  */\n-  int multiple_uses;\t\t/* Nonzero if a reg has multiple uses.  */\n-};\n-\n-\n-\n-struct loop_movables\n-{\n-  /* Head of movable chain.  */\n-  struct movable *head;\n-  /* Last movable in chain.  */\n-  struct movable *last;\n-};\n-\n-\n-/* Information pertaining to a loop.  */\n-\n-struct loop_info\n-{\n-  /* Nonzero if there is a subroutine call in the current loop.  */\n-  int has_call;\n-  /* Nonzero if there is a libcall in the current loop.  */\n-  int has_libcall;\n-  /* Nonzero if there is a non constant call in the current loop.  */\n-  int has_nonconst_call;\n-  /* Nonzero if there is a prefetch instruction in the current loop.  */\n-  int has_prefetch;\n-  /* Nonzero if there is a volatile memory reference in the current\n-     loop.  */\n-  int has_volatile;\n-  /* Nonzero if there is a tablejump in the current loop.  */\n-  int has_tablejump;\n-  /* Nonzero if there are ways to leave the loop other than falling\n-     off the end.  */\n-  int has_multiple_exit_targets;\n-  /* Nonzero if there is an indirect jump in the current function.  */\n-  int has_indirect_jump;\n-  /* Whether loop unrolling has emitted copies of the loop body so\n-     that the main loop needs no exit tests.  */\n-  int preconditioned;\n-  /* Register or constant initial loop value.  */\n-  rtx initial_value;\n-  /* Register or constant value used for comparison test.  */\n-  rtx comparison_value;\n-  /* Register or constant approximate final value.  */\n-  rtx final_value;\n-  /* Register or constant initial loop value with term common to\n-     final_value removed.  */\n-  rtx initial_equiv_value;\n-  /* Register or constant final loop value with term common to\n-     initial_value removed.  */\n-  rtx final_equiv_value;\n-  /* Register corresponding to iteration variable.  */\n-  rtx iteration_var;\n-  /* Constant loop increment.  */\n-  rtx increment;\n-  enum rtx_code comparison_code;\n-  /* Holds the number of loop iterations.  It is zero if the number\n-     could not be calculated.  Must be unsigned since the number of\n-     iterations can be as high as 2^wordsize - 1.  For loops with a\n-     wider iterator, this number will be zero if the number of loop\n-     iterations is too large for an unsigned integer to hold.  */\n-  unsigned HOST_WIDE_INT n_iterations;\n-  /* The number of times the loop body was unrolled.  */\n-  unsigned int unroll_number;\n-  int used_count_register;\n-  /* The loop iterator induction variable.  */\n-  struct iv_class *iv;\n-  /* List of MEMs that are stored in this loop.  */\n-  rtx store_mems;\n-  /* Array of MEMs that are used (read or written) in this loop, but\n-     cannot be aliased by anything in this loop, except perhaps\n-     themselves.  In other words, if mems[i] is altered during\n-     the loop, it is altered by an expression that is rtx_equal_p to\n-     it.  */\n-  loop_mem_info *mems;\n-  /* The index of the next available slot in MEMS.  */\n-  int mems_idx;\n-  /* The number of elements allocated in MEMS.  */\n-  int mems_allocated;\n-  /* Nonzero if we don't know what MEMs were changed in the current\n-     loop.  This happens if the loop contains a call (in which case\n-     `has_call' will also be set) or if we store into more than\n-     NUM_STORES MEMs.  */\n-  int unknown_address_altered;\n-  /* The above doesn't count any readonly memory locations that are\n-     stored.  This does.  */\n-  int unknown_constant_address_altered;\n-  /* Count of memory write instructions discovered in the loop.  */\n-  int num_mem_sets;\n-  /* The insn where the first of these was found.  */\n-  rtx first_loop_store_insn;\n-  /* The chain of movable insns in loop.  */\n-  struct loop_movables movables;\n-  /* The registers used the in loop.  */\n-  struct loop_regs regs;\n-  /* The induction variable information in loop.  */\n-  struct loop_ivs ivs;\n-  /* Nonzero if call is in pre_header extended basic block.  */\n-  int pre_header_has_call;\n-};\n-\n-\n-/* Variables declared in loop.c, but also needed in unroll.c.  */\n-\n-extern int *uid_luid;\n-extern int max_uid_for_loop;\n-extern unsigned int max_reg_before_loop;\n-extern struct loop **uid_loop;\n-extern FILE *loop_dump_stream;\n-\n-\n-/* Forward declarations for non-static functions declared in loop.c and\n-   unroll.c.  */\n-extern int loop_invariant_p (const struct loop *, rtx);\n-extern rtx get_condition_for_loop (const struct loop *, rtx);\n-extern void loop_iv_add_mult_hoist (const struct loop *, rtx, rtx, rtx, rtx);\n-extern void loop_iv_add_mult_sink (const struct loop *, rtx, rtx, rtx, rtx);\n-extern void loop_iv_add_mult_emit_before (const struct loop *, rtx, rtx,\n-\t\t\t\t\t  rtx, rtx, basic_block, rtx);\n-extern rtx express_from (struct induction *, struct induction *);\n-extern rtx extend_value_for_giv (struct induction *, rtx);\n-\n-extern void unroll_loop (struct loop *, int, int);\n-extern rtx biv_total_increment (const struct iv_class *);\n-extern unsigned HOST_WIDE_INT loop_iterations (struct loop *);\n-extern int precondition_loop_p (const struct loop *, rtx *, rtx *, rtx *,\n-\t\t\t\tenum machine_mode *mode);\n-extern rtx final_biv_value (const struct loop *, struct iv_class *);\n-extern rtx final_giv_value (const struct loop *, struct induction *);\n-extern void emit_unrolled_add (rtx, rtx, rtx);\n-extern int back_branch_in_range_p (const struct loop *, rtx);\n-\n-extern int loop_insn_first_p (rtx, rtx);\n-typedef rtx (*loop_insn_callback) (struct loop *, rtx, int, int);\n-extern void for_each_insn_in_loop (struct loop *, loop_insn_callback);\n-extern rtx loop_insn_emit_before (const struct loop *, basic_block, rtx, rtx);\n-extern rtx loop_insn_sink (const struct loop *, rtx);\n-extern rtx loop_insn_hoist (const struct loop *, rtx);\n-\n-/* Forward declarations for non-static functions declared in doloop.c.  */\n-extern int doloop_optimize (const struct loop *);"}, {"sha": "986151b57c02c497ead1f9d81f43bea053ef91ec", "filename": "gcc/passes.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=c94583fe5577f83df48b156f86d9d36dcb218dbe", "patch": "@@ -60,7 +60,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"intl.h\"\n #include \"ggc.h\"\n #include \"graph.h\"\n-#include \"loop.h\"\n #include \"regs.h\"\n #include \"timevar.h\"\n #include \"diagnostic.h\"\n@@ -1130,7 +1129,7 @@ rest_of_handle_gcse (void)\n static void\n rest_of_handle_loop_optimize (void)\n {\n-  int do_unroll, do_prefetch;\n+  int do_prefetch;\n \n   timevar_push (TV_LOOP);\n   delete_dead_jumptables ();\n@@ -1140,19 +1139,14 @@ rest_of_handle_loop_optimize (void)\n   /* CFG is no longer maintained up-to-date.  */\n   free_bb_for_insn ();\n \n-  if (flag_unroll_loops)\n-    do_unroll = LOOP_AUTO_UNROLL;\t/* Having two unrollers is useless.  */\n-  else\n-    do_unroll = flag_old_unroll_loops ? LOOP_UNROLL : LOOP_AUTO_UNROLL;\n   do_prefetch = flag_prefetch_loop_arrays ? LOOP_PREFETCH : 0;\n \n   if (flag_rerun_loop_opt)\n     {\n       cleanup_barriers ();\n \n       /* We only want to perform unrolling once.  */\n-      loop_optimize (get_insns (), dump_file, do_unroll);\n-      do_unroll = 0;\n+      loop_optimize (get_insns (), dump_file, 0);\n \n       /* The first call to loop_optimize makes some instructions\n \t trivially dead.  We delete those instructions now in the\n@@ -1165,7 +1159,7 @@ rest_of_handle_loop_optimize (void)\n       reg_scan (get_insns (), max_reg_num (), 1);\n     }\n   cleanup_barriers ();\n-  loop_optimize (get_insns (), dump_file, do_unroll | do_prefetch);\n+  loop_optimize (get_insns (), dump_file, do_prefetch);\n \n   /* Loop can create trivially dead instructions.  */\n   delete_trivially_dead_insns (get_insns (), max_reg_num ());"}, {"sha": "3da32986238c2b2873320211fde81e2598dd38b6", "filename": "gcc/predict.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=c94583fe5577f83df48b156f86d9d36dcb218dbe", "patch": "@@ -51,7 +51,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"sreal.h\"\n #include \"params.h\"\n #include \"target.h\"\n-#include \"loop.h\"\n #include \"cfgloop.h\"\n #include \"tree-flow.h\"\n #include \"ggc.h\""}, {"sha": "d96b3d4c4339194cefe286723a0cb7d569fdc358", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=c94583fe5577f83df48b156f86d9d36dcb218dbe", "patch": "@@ -788,7 +788,6 @@ extern const char * const reg_note_name[];\n #define NOTE_BASIC_BLOCK(INSN)\tXCBBDEF (INSN, 4, NOTE)\n #define NOTE_EXPECTED_VALUE(INSN) XCEXP (INSN, 4, NOTE)\n #define NOTE_PREDICTION(INSN)   XCINT (INSN, 4, NOTE)\n-#define NOTE_PRECONDITIONED(INSN)   XCINT (INSN, 4, NOTE)\n #define NOTE_VAR_LOCATION(INSN)\tXCEXP (INSN, 4, NOTE)\n \n /* In a NOTE that is a line number, this is the line number."}, {"sha": "34ad804b8fc01991e98066024a53dbff4937d076", "filename": "gcc/stmt.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=c94583fe5577f83df48b156f86d9d36dcb218dbe", "patch": "@@ -39,7 +39,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"expr.h\"\n #include \"libfuncs.h\"\n #include \"hard-reg-set.h\"\n-#include \"loop.h\"\n #include \"recog.h\"\n #include \"machmode.h\"\n #include \"toplev.h\""}, {"sha": "1dbe25dc5ca45ccd985e988347357d2c845b6518", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c94583fe5577f83df48b156f86d9d36dcb218dbe/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=c94583fe5577f83df48b156f86d9d36dcb218dbe", "patch": "@@ -61,7 +61,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"intl.h\"\n #include \"ggc.h\"\n #include \"graph.h\"\n-#include \"loop.h\"\n #include \"regs.h\"\n #include \"timevar.h\"\n #include \"diagnostic.h\"\n@@ -1684,24 +1683,7 @@ process_options (void)\n   if (flag_unroll_all_loops)\n     flag_unroll_loops = 1;\n \n-  if (flag_unroll_loops)\n-    {\n-      flag_old_unroll_loops = 0;\n-      flag_old_unroll_all_loops = 0;\n-    }\n-\n-  if (flag_old_unroll_all_loops)\n-    flag_old_unroll_loops = 1;\n-\n-  /* Old loop unrolling requires that strength_reduction be on also.  Silently\n-     turn on strength reduction here if it isn't already on.  Also, the loop\n-     unrolling code assumes that cse will be run after loop, so that must\n-     be turned on also.  */\n-  if (flag_old_unroll_loops)\n-    {\n-      flag_strength_reduce = 1;\n-      flag_rerun_cse_after_loop = 1;\n-    }\n+  /* The loop unrolling code assumes that cse will be run after loop.  */\n   if (flag_unroll_loops || flag_peel_loops)\n     flag_rerun_cse_after_loop = 1;\n "}, {"sha": "cef4c6ecca34fe7fa08728a4b471a0ce4e509544", "filename": "gcc/unroll.c", "status": "removed", "additions": 0, "deletions": 3840, "changes": 3840, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/032618223ba81a0f01b4b20241c0b0a9859db29b/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/032618223ba81a0f01b4b20241c0b0a9859db29b/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=032618223ba81a0f01b4b20241c0b0a9859db29b"}]}