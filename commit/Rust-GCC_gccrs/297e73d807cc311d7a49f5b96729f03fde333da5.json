{"sha": "297e73d807cc311d7a49f5b96729f03fde333da5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk3ZTczZDgwN2NjMzExZDdhNDlmNWI5NjcyOWYwM2ZkZTMzM2RhNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1999-01-21T14:29:33Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-01-21T14:29:33Z"}, "message": "cp-tree.h (PARM_DECL_EXPR): Delete.\n\n\t* cp-tree.h (PARM_DECL_EXPR): Delete.\n\t(convert_default_arg): Change prototype.\n\t(check_default_argument): Declare.\n\t(search_tree): Likewise.\n\t* call.c (convert_default_arg): Take the function to which the\n\tdefault argument belongs as a parameter, and do any necessary\n\tinstantiation here, instead of ...\n\t(build_over_call): Here.\n\t* decl.c (local_variable_p): New function.\n\t(check_default_argument): Likewise, split out and tidied from ...\n\t(grokparms): Here.\n\t* error.c (dump_expr): Don't set PARM_DECL_EXPR.\n\t* pt.c (tsubst_call_declarator_parms): New function.\n\t(for_each_template_parm): Handle ARRAY_REFs.  Do the obvious thing\n\twith CALL_EXPRs, rather than trying to be clever.\n\t(tsubst): Use tsubst_call_declarator_parms.\n\t* tree.c (search_tree): Don't make it static.\n\t* typeck.c (convert_arguments): Use new interface to\n\tconvert_default_arg.\n\nFrom-SVN: r24803", "tree": {"sha": "baf338e3c55393da72e8f2f9e50fa81ec5ca6a34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/baf338e3c55393da72e8f2f9e50fa81ec5ca6a34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/297e73d807cc311d7a49f5b96729f03fde333da5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/297e73d807cc311d7a49f5b96729f03fde333da5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/297e73d807cc311d7a49f5b96729f03fde333da5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/297e73d807cc311d7a49f5b96729f03fde333da5/comments", "author": null, "committer": null, "parents": [{"sha": "939b4a73dbf5ef563c9567c68c6d8e56708f964d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/939b4a73dbf5ef563c9567c68c6d8e56708f964d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/939b4a73dbf5ef563c9567c68c6d8e56708f964d"}], "stats": {"total": 331, "additions": 243, "deletions": 88}, "files": [{"sha": "498560a77cd6bcc58f0dc8fdc451dff2d1c53a5b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/297e73d807cc311d7a49f5b96729f03fde333da5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/297e73d807cc311d7a49f5b96729f03fde333da5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=297e73d807cc311d7a49f5b96729f03fde333da5", "patch": "@@ -1,3 +1,25 @@\n+1999-01-21  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (PARM_DECL_EXPR): Delete.\n+\t(convert_default_arg): Change prototype.\n+\t(check_default_argument): Declare.\n+\t(search_tree): Likewise.\n+\t* call.c (convert_default_arg): Take the function to which the\n+\tdefault argument belongs as a parameter, and do any necessary\n+\tinstantiation here, instead of ...\n+\t(build_over_call): Here.\n+\t* decl.c (local_variable_p): New function.\n+\t(check_default_argument): Likewise, split out and tidied from ...\n+\t(grokparms): Here.\n+\t* error.c (dump_expr): Don't set PARM_DECL_EXPR.\n+\t* pt.c (tsubst_call_declarator_parms): New function.\n+\t(for_each_template_parm): Handle ARRAY_REFs.  Do the obvious thing\n+\twith CALL_EXPRs, rather than trying to be clever.\n+\t(tsubst): Use tsubst_call_declarator_parms.\n+\t* tree.c (search_tree): Don't make it static.\n+\t* typeck.c (convert_arguments): Use new interface to\n+\tconvert_default_arg.\n+\t\n 1999-01-20  Mark Mitchell  <mark@markmitchell.com>\n \n \t* error.c (dump_function_decl): Don't print the argument types for"}, {"sha": "3891ea75b7e3175497a24e45cb903b0ce9669414", "filename": "gcc/cp/call.c", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/297e73d807cc311d7a49f5b96729f03fde333da5/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/297e73d807cc311d7a49f5b96729f03fde333da5/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=297e73d807cc311d7a49f5b96729f03fde333da5", "patch": "@@ -3176,13 +3176,41 @@ convert_arg_to_ellipsis (arg)\n }\n \n /* ARG is a default argument expression being passed to a parameter of\n-   the indicated TYPE.  Do any required conversions.  Return the\n-   converted value.  */\n+   the indicated TYPE, which is a parameter to FN.  Do any required\n+   conversions.  Return the converted value.  */\n \n tree\n-convert_default_arg (type, arg)\n-     tree type, arg;\n+convert_default_arg (type, arg, fn)\n+     tree type;\n+     tree arg;\n+     tree fn;\n {\n+  if (fn && DECL_TEMPLATE_INFO (fn))\n+    {\n+      /* This default argument came from a template.  Instantiate the\n+\t default argument here, not in tsubst.  In the case of\n+\t something like: \n+\n+\t   template <class T>\n+\t   struct S {\n+\t     static T t();\n+\t     void f(T = t());\n+\t   };\n+\n+\t we must be careful to do name lookup in the scope of S<T>,\n+\t rather than in the current class.  */\n+      if (DECL_CLASS_SCOPE_P (fn))\n+\tpushclass (DECL_REAL_CONTEXT (fn), 2);\n+\n+      arg = tsubst_expr (arg, DECL_TI_ARGS (fn), NULL_TREE);\n+\n+      if (DECL_CLASS_SCOPE_P (fn))\n+\tpopclass (1);\n+\n+      /* Make sure the default argument is reasonable.  */\n+      arg = check_default_argument (type, arg);\n+    }\n+\n   arg = break_out_target_exprs (arg);\n \n   if (TREE_CODE (arg) == CONSTRUCTOR)\n@@ -3326,34 +3354,12 @@ build_over_call (cand, args, flags)\n \n   /* Default arguments */\n   for (; parm && parm != void_list_node; parm = TREE_CHAIN (parm))\n-    {\n-      tree arg = TREE_PURPOSE (parm);\n-\n-      if (DECL_TEMPLATE_INFO (fn))\n-\t{\n-\t  /* This came from a template.  Instantiate the default arg here,\n-\t     not in tsubst.  In the case of something like:\n-\n-\t       template <class T>\n-\t       struct S {\n-\t         static T t();\n-\t\t void f(T = t());\n-\t       };\n-\n-\t     we must be careful to do name lookup in the scope of\n-\t     S<T>, rather than in the current class.  */\n-\t  if (DECL_CLASS_SCOPE_P (fn))\n-\t    pushclass (DECL_REAL_CONTEXT (fn), 2);\n-\n-\t  arg = tsubst_expr (arg, DECL_TI_ARGS (fn), NULL_TREE);\n-\n-\t  if (DECL_CLASS_SCOPE_P (fn))\n-\t    popclass (1);\n-\t}\n-      converted_args = expr_tree_cons\n-\t(NULL_TREE, convert_default_arg (TREE_VALUE (parm), arg),\n-\t converted_args);\n-    }\n+    converted_args \n+      = expr_tree_cons (NULL_TREE, \n+\t\t\tconvert_default_arg (TREE_VALUE (parm), \n+\t\t\t\t\t     TREE_PURPOSE (parm),\n+\t\t\t\t\t     fn),\n+\t\t\tconverted_args);\n \n   /* Ellipsis */\n   for (; arg; arg = TREE_CHAIN (arg))"}, {"sha": "7dc06ff2edb3dcf6800232285eb9d9e25a6f856b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/297e73d807cc311d7a49f5b96729f03fde333da5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/297e73d807cc311d7a49f5b96729f03fde333da5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=297e73d807cc311d7a49f5b96729f03fde333da5", "patch": "@@ -43,7 +43,6 @@ Boston, MA 02111-1307, USA.  */\n       BINFO_VBASE_MARKED.\n       BINFO_FIELDS_MARKED.\n       TYPE_VIRTUAL_P.\n-      PARM_DECL_EXPR (in SAVE_EXPR).\n    3: TYPE_USES_VIRTUAL_BASECLASSES (in a class TYPE).\n       BINFO_VTABLE_PATH_MARKED.\n       BINFO_PUSHDECLS_MARKED.\n@@ -1704,9 +1703,6 @@ extern int flag_new_for_scope;\n    specified in its declaration.  */\n #define DECL_THIS_STATIC(NODE) (DECL_LANG_FLAG_6(NODE))\n \n-/* Nonzero for SAVE_EXPR if used to initialize a PARM_DECL.  */\n-#define PARM_DECL_EXPR(NODE) (TREE_LANG_FLAG_2(NODE))\n-\n /* Nonzero in FUNCTION_DECL means it is really an operator.\n    Just used to communicate formatting information to dbxout.c.  */\n #define DECL_OPERATOR(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.operator_attr)\n@@ -2645,7 +2641,7 @@ extern tree build_op_delete_call\t\tPROTO((enum tree_code, tree, tree, int, tree))\n extern int can_convert\t\t\t\tPROTO((tree, tree));\n extern int can_convert_arg\t\t\tPROTO((tree, tree, tree));\n extern void enforce_access                      PROTO((tree, tree));\n-extern tree convert_default_arg                 PROTO((tree, tree));\n+extern tree convert_default_arg                 PROTO((tree, tree, tree));\n extern tree convert_arg_to_ellipsis             PROTO((tree));\n \n /* in class.c */\n@@ -2819,6 +2815,7 @@ extern void fixup_anonymous_union               PROTO((tree));\n extern int check_static_variable_definition     PROTO((tree, tree));\n extern void push_local_binding                  PROTO((tree, tree));\n extern void push_class_binding                  PROTO((tree, tree));\n+extern tree check_default_argument              PROTO((tree, tree));\n \n /* in decl2.c */\n extern int check_java_method\t\t\tPROTO((tree));\n@@ -3300,6 +3297,7 @@ extern void push_expression_obstack\t\tPROTO((void));\n extern tree build_dummy_object\t\t\tPROTO((tree));\n extern tree maybe_dummy_object\t\t\tPROTO((tree, tree *));\n extern int is_dummy_object\t\t\tPROTO((tree));\n+extern tree search_tree                         PROTO((tree, tree (*)(tree)));\n #define scratchalloc expralloc\n #define scratch_tree_cons expr_tree_cons\n #define build_scratch_list build_expr_list"}, {"sha": "161876ee80c791ac24f602545d4d940af7f02a3c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 101, "deletions": 44, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/297e73d807cc311d7a49f5b96729f03fde333da5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/297e73d807cc311d7a49f5b96729f03fde333da5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=297e73d807cc311d7a49f5b96729f03fde333da5", "patch": "@@ -182,6 +182,7 @@ static boolean typename_compare PROTO((hash_table_key, hash_table_key));\n static void push_binding PROTO((tree, tree, struct binding_level*));\n static void add_binding PROTO((tree, tree));\n static void pop_binding PROTO((tree, tree));\n+static tree local_variable_p PROTO((tree));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -11260,6 +11261,103 @@ require_complete_types_for_parms (parms)\n     }\n }\n \n+/* Returns DECL if DECL is a local variable (or parameter).  Returns\n+   NULL_TREE otherwise.  */\n+\n+static tree\n+local_variable_p (t)\n+     tree t;\n+{\n+  if ((TREE_CODE (t) == VAR_DECL \n+       /* A VAR_DECL with a context that is a _TYPE is a static data\n+\t  member.  */\n+       && !TYPE_P (CP_DECL_CONTEXT (t))\n+       /* Any other non-local variable must be at namespace scope.  */\n+       && TREE_CODE (CP_DECL_CONTEXT (t)) != NAMESPACE_DECL)\n+      || (TREE_CODE (t) == PARM_DECL))\n+    return t;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Check that ARG, which is a default-argument expression for a\n+   parameter DECL, is legal.  Returns ARG, or ERROR_MARK_NODE, if\n+   something goes wrong.  DECL may also be a _TYPE node, rather than a\n+   DECL, if there is no DECL available.  */\n+\n+tree\n+check_default_argument (decl, arg)\n+     tree decl;\n+     tree arg;\n+{\n+  tree var;\n+  tree decl_type;\n+\n+  if (TREE_CODE (arg) == DEFAULT_ARG)\n+    /* We get a DEFAULT_ARG when looking at an in-class declaration\n+       with a default argument.  Ignore the argument for now; we'll\n+       deal with it after the class is complete.  */\n+    return arg;\n+\n+  if (processing_template_decl || uses_template_parms (arg))\n+    /* We don't do anything checking until instantiation-time.  Note\n+       that there may be uninstantiated arguments even for an\n+       instantiated function, since default arguments are not\n+       instantiated until they are needed.  */\n+    return arg;\n+\n+  if (TYPE_P (decl))\n+    {\n+      decl_type = decl;\n+      decl = NULL_TREE;\n+    }\n+  else\n+    decl_type = TREE_TYPE (decl);\n+\n+  if (arg == error_mark_node \n+      || decl == error_mark_node\n+      || TREE_TYPE (arg) == error_mark_node\n+      || decl_type == error_mark_node)\n+    /* Something already went wrong.  There's no need to check\n+       further.  */\n+    return error_mark_node;\n+\n+  /* [dcl.fct.default]\n+     \n+     A default argument expression is implicitly converted to the\n+     parameter type.  */\n+  if (!TREE_TYPE (arg)\n+      || !can_convert_arg (decl_type, TREE_TYPE (arg), arg))\n+    {\n+      if (decl)\n+\tcp_error (\"default argument for `%#D' has type `%T'\", \n+\t\t  decl, TREE_TYPE (arg));\n+      else\n+\tcp_error (\"default argument for paramter of type `%T' has type `%T'\",\n+\t\t  decl_type, TREE_TYPE (arg));\n+\n+      return error_mark_node;\n+    }\n+\n+  /* [dcl.fct.default]\n+\n+     Local variables shall not be used in default argument\n+     expressions. \n+\n+     The keyword `this' shall not be used in a default argument of a\n+     member function.  */\n+  var = search_tree (arg, local_variable_p);\n+  if (var)\n+    {\n+      cp_error (\"default argument `%E' uses local variable `%D'\",\n+\t\targ, var);\n+      return error_mark_node;\n+    }\n+\n+  /* All is well.  */\n+  return arg;\n+}\n+\n /* Decode the list of parameter types for a function type.\n    Given the list of things declared inside the parens,\n    return a list of types.\n@@ -11437,51 +11535,10 @@ grokparms (first_parm, funcdef_flag)\n \t\t  && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n \t\tDECL_ARG_TYPE (decl) = integer_type_node;\n #endif\n-\t      if (!any_error)\n+\t      if (!any_error && init)\n \t\t{\n-\t\t  if (init)\n-\t\t    {\n-\t\t      any_init++;\n-\t\t      if (TREE_CODE (init) == SAVE_EXPR)\n-\t\t\tPARM_DECL_EXPR (init) = 1;\n-\t\t      else if (processing_template_decl)\n-\t\t\t;\n-\t\t      /* Unparsed default arg from in-class decl.  */\n-\t\t      else if (TREE_CODE (init) == DEFAULT_ARG)\n-\t\t\t;\n-\t\t      else if (TREE_CODE (init) == PARM_DECL\n-\t\t\t       || TREE_CODE (init) == VAR_DECL)\n-\t\t\t{\n-\t\t\t  if (TREE_CODE (init) == VAR_DECL\n-\t\t\t      && (IDENTIFIER_VALUE (DECL_NAME (init))\n-\t\t\t\t  == init)\n-\t\t\t      && LOCAL_BINDING_P\n-\t\t\t      (IDENTIFIER_BINDING (DECL_NAME\n-\t\t\t\t\t\t   (init))))\n-\t\t\t    {\n-\t\t\t      /* ``Local variables may not be used in\n-\t\t\t\t default argument expressions.''\n-\t\t\t\t dpANSI C++ 8.2.6 */\n-\n-\t\t\t      cp_error (\"local variable `%D' may not be used as a default argument\", init);\n-\t\t\t      any_error = 1;\n-\t\t\t    }\n-\t\t\t  else if (TREE_READONLY_DECL_P (init))\n-\t\t\t    init = decl_constant_value (init);\n-\t\t\t}\n-\t\t      else if (TREE_TYPE (init) == NULL_TREE)\n-\t\t\t{\n-\t\t\t  error (\"argument list may not have an initializer list\");\n-\t\t\t  init = error_mark_node;\n-\t\t\t}\n-\n-\t\t      if (! processing_template_decl\n-\t\t\t  && init != error_mark_node\n-\t\t\t  && TREE_CODE (init) != DEFAULT_ARG\n-\t\t\t  && ! can_convert_arg (type, TREE_TYPE (init), init))\n-\t\t\tcp_pedwarn (\"invalid type `%T' for default argument to `%#D'\",\n-\t\t\t\t    TREE_TYPE (init), decl);\n-\t\t    }\n+\t\t  any_init++;\n+\t\t  init = check_default_argument (decl, init);\n \t\t}\n \t      else\n \t\tinit = NULL_TREE;"}, {"sha": "ec3bf71b00fd7fb9da95e6f7e72ab0b0db79a3eb", "filename": "gcc/cp/error.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/297e73d807cc311d7a49f5b96729f03fde333da5/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/297e73d807cc311d7a49f5b96729f03fde333da5/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=297e73d807cc311d7a49f5b96729f03fde333da5", "patch": "@@ -1344,7 +1344,6 @@ dump_expr (t, nop)\n \t{\n \t  OB_PUTS (\"new \");\n \t  dump_type (TREE_TYPE (TREE_TYPE (t)), 0);\n-\t  PARM_DECL_EXPR (t) = 1;\n \t}\n       else\n \t{"}, {"sha": "9bd73c240b81ee4f4bc760ef382609a7e50941f4", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/297e73d807cc311d7a49f5b96729f03fde333da5/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/297e73d807cc311d7a49f5b96729f03fde333da5/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=297e73d807cc311d7a49f5b96729f03fde333da5", "patch": "@@ -136,6 +136,7 @@ static void check_specialization_scope PROTO((void));\n static tree process_partial_specialization PROTO((tree));\n static void set_current_access_from_decl PROTO((tree));\n static void check_default_tmpl_args PROTO((tree, tree, int, int));\n+static tree tsubst_call_declarator_parms PROTO((tree, tree, tree));\n \n /* We use TREE_VECs to hold template arguments.  If there is only one\n    level of template arguments, then the TREE_VEC contains the\n@@ -3809,6 +3810,10 @@ for_each_template_parm (t, fn, data)\n \t COMPONENT_REF uses template parms.  */\n       return for_each_template_parm (TREE_TYPE (t), fn, data);\n \n+    case ARRAY_REF:\n+      return (for_each_template_parm (TREE_OPERAND (t, 0), fn, data)\n+\t      || for_each_template_parm (TREE_OPERAND (t, 1), fn, data));\n+\n     case IDENTIFIER_NODE:\n       if (!IDENTIFIER_TEMPLATE (t))\n \treturn 0;\n@@ -3917,7 +3922,9 @@ for_each_template_parm (t, fn, data)\n       return 0;\n \n     case CALL_EXPR:\n-      return for_each_template_parm (TREE_TYPE (t), fn, data);\n+      return (for_each_template_parm (TREE_OPERAND (t, 0), fn, data)\n+\t      || for_each_template_parm (TREE_OPERAND (t, 1), fn, data));\n+\t\n     case ADDR_EXPR:\n       return for_each_template_parm (TREE_OPERAND (t, 0), fn, data);\n \n@@ -5628,6 +5635,43 @@ tsubst_arg_types (arg_types, args, in_decl)\n \t\t\t \n }\n \n+/* Substitute into the PARMS of a call-declarator.  */\n+\n+tree\n+tsubst_call_declarator_parms (parms, args, in_decl)\n+     tree parms;\n+     tree args;\n+     tree in_decl;\n+{\n+  tree new_parms;\n+  tree type;\n+  tree defarg;\n+\n+  if (!parms || parms == void_list_node)\n+    return parms;\n+  \n+  new_parms = tsubst_call_declarator_parms (TREE_CHAIN (parms),\n+\t\t\t\t\t    args, in_decl);\n+\n+  /* Figure out the type of this parameter.  */\n+  type = tsubst (TREE_VALUE (parms), args, in_decl);\n+  \n+  /* Figure out the default argument as well.  Note that we use\n+     tsubst_copy since the default argument is really an \n+     expression.  */\n+  defarg = tsubst_expr (TREE_PURPOSE (parms), args, in_decl);\n+\n+  /* Chain this parameter on to the front of those we have already\n+     processed.  We don't use hash_tree_cons because that function\n+     doesn't check TREE_PARMLIST.  */\n+  new_parms = tree_cons (defarg, type, new_parms);\n+\n+  /* And note that these are parameters.  */\n+  TREE_PARMLIST (new_parms) = 1;\n+  \n+  return new_parms;\n+}\n+\n /* Take the tree structure T and replace template parameters used therein\n    with the argument vector ARGS.  IN_DECL is an associated decl for\n    diagnostics.\n@@ -6061,7 +6105,7 @@ tsubst (t, args, in_decl)\n     case CALL_EXPR:\n       return make_call_declarator\n \t(tsubst (TREE_OPERAND (t, 0), args, in_decl),\n-\t tsubst (TREE_OPERAND (t, 1), args, in_decl),\n+\t tsubst_call_declarator_parms (TREE_OPERAND (t, 1), args, in_decl),\n \t TREE_OPERAND (t, 2),\n \t tsubst (TREE_TYPE (t), args, in_decl));\n "}, {"sha": "65ae47a7f637a7fb79fdea96dd415f18a80d7110", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/297e73d807cc311d7a49f5b96729f03fde333da5/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/297e73d807cc311d7a49f5b96729f03fde333da5/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=297e73d807cc311d7a49f5b96729f03fde333da5", "patch": "@@ -1545,7 +1545,7 @@ copy_template_template_parm (t)\n /* Walk through the tree structure T, applying func.  If func ever returns\n    non-null, return that value.  */\n \n-static tree\n+tree\n search_tree (t, func)\n      tree t;\n      tree (*func) PROTO((tree));"}, {"sha": "82ce5144fe26e04e3081da326b55ef4919ad3a32", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/297e73d807cc311d7a49f5b96729f03fde333da5/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/297e73d807cc311d7a49f5b96729f03fde333da5/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=297e73d807cc311d7a49f5b96729f03fde333da5", "patch": "@@ -3088,9 +3088,10 @@ convert_arguments (typelist, values, fndecl, flags)\n \t{\n \t  for (; typetail != void_list_node; ++i)\n \t    {\n-\t      tree type = TREE_VALUE (typetail);\n-\t      tree val = TREE_PURPOSE (typetail);\n-\t      tree parmval = convert_default_arg (type, val);\n+\t      tree parmval \n+\t\t= convert_default_arg (TREE_VALUE (typetail), \n+\t\t\t\t       TREE_PURPOSE (typetail), \n+\t\t\t\t       fndecl);\n \n \t      if (parmval == error_mark_node)\n \t\treturn error_mark_node;"}, {"sha": "68b07a510cc45f7494cf247db060073b03ff786c", "filename": "gcc/testsuite/g++.old-deja/g++.other/defarg1.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/297e73d807cc311d7a49f5b96729f03fde333da5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdefarg1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/297e73d807cc311d7a49f5b96729f03fde333da5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdefarg1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdefarg1.C?ref=297e73d807cc311d7a49f5b96729f03fde333da5", "patch": "@@ -0,0 +1,28 @@\n+// Build don't link:\n+\n+int f (int x)\n+{\n+  extern void g (int i = f (x)); // ERROR - default argument uses local\n+  \n+  g();\n+\n+  return 0;\n+}\n+\n+int f (void);\n+\n+int h1 (int (*)(int) = f);\n+int h2 (int (*)(double) = f); // ERROR - no matching f\n+\n+template <class T>\n+int j (T t)\n+{\n+  extern void k (int i = j (t)); // ERROR - default argument uses local\n+\n+  k ();\n+\n+  return 0;\n+}\n+\n+template int j (double); // ERROR - instantiated from here\n+"}]}