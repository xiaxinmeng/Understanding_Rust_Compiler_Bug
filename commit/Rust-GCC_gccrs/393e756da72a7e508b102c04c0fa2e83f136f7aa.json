{"sha": "393e756da72a7e508b102c04c0fa2e83f136f7aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkzZTc1NmRhNzJhN2U1MDhiMTAyYzA0YzBmYTJlODNmMTM2ZjdhYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-10-11T20:58:46Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-10-11T20:58:46Z"}, "message": "re PR c++/21089 (C++ front-end does not \"inline\" the static const double)\n\n\tPR c++/21089\n\t* call.c (convert_like_real): Use decl_constant_value, not\n\tintegral_constant_value.\n\t* init.c (constant_value_1): New function.\n\t(integral_constant_value): Use it.\n\t(decl_constant_value): Likewise.\n\t* typeck.c (decay_conversion): Use decl_constant_value, not\n\tintegral_constant_value.\n\tPR c++/21089\n\t* g++.dg/init/float1.C: New test.\n\nFrom-SVN: r105256", "tree": {"sha": "ad1f06ab728212d615db8d82cc4ed542b8c44bc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad1f06ab728212d615db8d82cc4ed542b8c44bc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/393e756da72a7e508b102c04c0fa2e83f136f7aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/393e756da72a7e508b102c04c0fa2e83f136f7aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/393e756da72a7e508b102c04c0fa2e83f136f7aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/393e756da72a7e508b102c04c0fa2e83f136f7aa/comments", "author": null, "committer": null, "parents": [{"sha": "8f4c0ef6a4333e52b4a33cecd1bef3c48c701d63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f4c0ef6a4333e52b4a33cecd1bef3c48c701d63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f4c0ef6a4333e52b4a33cecd1bef3c48c701d63"}], "stats": {"total": 97, "additions": 70, "deletions": 27}, "files": [{"sha": "99ea5ec6759ad9192962dca346dcb46bd33506c4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393e756da72a7e508b102c04c0fa2e83f136f7aa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393e756da72a7e508b102c04c0fa2e83f136f7aa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=393e756da72a7e508b102c04c0fa2e83f136f7aa", "patch": "@@ -1,5 +1,14 @@\n 2005-10-11  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/21089\n+\t* call.c (convert_like_real): Use decl_constant_value, not\n+\tintegral_constant_value.\n+\t* init.c (constant_value_1): New function.\n+\t(integral_constant_value): Use it.\n+\t(decl_constant_value): Likewise.\n+\t* typeck.c (decay_conversion): Use decl_constant_value, not\n+\tintegral_constant_value.\n+\n \tPR c++/21369\n \t* parser.c (cp_parser_elaborated_type_specifier): Don't treat\n \tclass types as templates if the type is not appearing as part of a"}, {"sha": "b1a578d5a04f4a98d5cfd07da6d226ecb4b24d89", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393e756da72a7e508b102c04c0fa2e83f136f7aa/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393e756da72a7e508b102c04c0fa2e83f136f7aa/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=393e756da72a7e508b102c04c0fa2e83f136f7aa", "patch": "@@ -4298,7 +4298,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t about to bind it to a reference, in which case we need to\n \t leave it as an lvalue.  */\n       if (inner >= 0)\n-\texpr = integral_constant_value (expr);\n+\texpr = decl_constant_value (expr);\n       if (convs->check_copy_constructor_p)\n \tcheck_constructor_callable (totype, expr);\n       return expr;"}, {"sha": "20c3b356352f8c1cc689fcd15f3ebe51ac4988a5", "filename": "gcc/cp/init.c", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393e756da72a7e508b102c04c0fa2e83f136f7aa/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393e756da72a7e508b102c04c0fa2e83f136f7aa/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=393e756da72a7e508b102c04c0fa2e83f136f7aa", "patch": "@@ -1559,16 +1559,20 @@ build_offset_ref (tree type, tree name, bool address_p)\n   return member;\n }\n \n-/* If DECL is a CONST_DECL, or a constant VAR_DECL initialized by\n-   constant of integral or enumeration type, then return that value.\n-   These are those variables permitted in constant expressions by\n-   [5.19/1].  FIXME:If we did lazy folding, this could be localized.  */\n+/* If DECL is a scalar enumeration constant or variable with a\n+   constant initializer, return the initializer (or, its initializers,\n+   recursively); otherwise, return DECL.  If INTEGRAL_P, the\n+   initializer is only returned if DECL is an integral\n+   constant-expression.  */\n \n-tree\n-integral_constant_value (tree decl)\n+static tree\n+constant_value_1 (tree decl, bool integral_p)\n {\n   while (TREE_CODE (decl) == CONST_DECL\n-\t || DECL_INTEGRAL_CONSTANT_VAR_P (decl))\n+\t || (integral_p \n+\t     ? DECL_INTEGRAL_CONSTANT_VAR_P (decl)\n+\t     : (TREE_CODE (decl) == VAR_DECL\n+\t\t&& CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (decl)))))\n     {\n       tree init;\n       /* If DECL is a static data member in a template class, we must\n@@ -1583,34 +1587,42 @@ integral_constant_value (tree decl)\n \tinit = fold_non_dependent_expr (init);\n       if (!(init || init == error_mark_node)\n \t  || !TREE_TYPE (init)\n-\t  || !INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (init)))\n+\t  || (integral_p\n+\t      ? !INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (init))\n+\t      : (!TREE_CONSTANT (init)\n+\t\t /* Do not return an aggregate constant (of which\n+\t\t    string literals are a special case), as we do not\n+\t\t    want to make inadvertant copies of such entities,\n+\t\t    and we must be sure that their addresses are the\n+\t\t    same everywhere.  */\n+\t\t || TREE_CODE (init) == CONSTRUCTOR\n+\t\t || TREE_CODE (init) == STRING_CST)))\n \tbreak;\n       decl = init;\n     }\n   return decl;\n }\n \n-/* A more relaxed version of integral_constant_value, for which type\n-   is not considered.  This is used by the common C/C++ code, and not\n-   directly by the C++ front end.  */\n+/* If DECL is a CONST_DECL, or a constant VAR_DECL initialized by\n+   constant of integral or enumeration type, then return that value.\n+   These are those variables permitted in constant expressions by\n+   [5.19/1].  */\n \n tree\n-decl_constant_value (tree decl)\n+integral_constant_value (tree decl)\n {\n-  if ((TREE_CODE (decl) == CONST_DECL\n-      || (TREE_CODE (decl) == VAR_DECL\n-\t  /* And so are variables with a 'const' type -- unless they\n-\t     are also 'volatile'.  */\n-\t  && CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (decl))))\n-      && DECL_INITIAL (decl)\n-      && DECL_INITIAL (decl) != error_mark_node\n-      /* This is invalid if initial value is not constant.  If it has\n-\t either a function call, a memory reference, or a variable,\n-\t then re-evaluating it could give different results.  */\n-      && TREE_CONSTANT (DECL_INITIAL (decl)))\n-    return DECL_INITIAL (decl);\n+  return constant_value_1 (decl, /*integral_p=*/true);\n+}\n \n-  return decl;\n+/* A more relaxed version of integral_constant_value, used by the\n+   common C/C++ code and by the C++ front-end for optimization\n+   purposes.  */\n+\n+tree\n+decl_constant_value (tree decl)\n+{\n+  return constant_value_1 (decl, \n+\t\t\t   /*integral_p=*/processing_template_decl);\n }\n \f\n /* Common subroutines of build_new and build_vec_delete.  */"}, {"sha": "7a9a561896bf9b1cd706270cbdb83e7f1b91e5e2", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393e756da72a7e508b102c04c0fa2e83f136f7aa/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393e756da72a7e508b102c04c0fa2e83f136f7aa/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=393e756da72a7e508b102c04c0fa2e83f136f7aa", "patch": "@@ -1356,7 +1356,7 @@ decay_conversion (tree exp)\n       return error_mark_node;\n     }\n \n-  exp = integral_constant_value (exp);\n+  exp = decl_constant_value (exp);\n \n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n      Leave such NOP_EXPRs, since RHS is being used in non-lvalue context.  */"}, {"sha": "b626cdd80192e694e3d4dacee22f9d07ae22edad", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393e756da72a7e508b102c04c0fa2e83f136f7aa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393e756da72a7e508b102c04c0fa2e83f136f7aa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=393e756da72a7e508b102c04c0fa2e83f136f7aa", "patch": "@@ -1,5 +1,8 @@\n 2005-10-11  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/21089\n+\t* g++.dg/init/float1.C: New test.\n+\n \tPR c++/24277\n \t* g++.dg/init/member1.C: Tweak error markers.\n "}, {"sha": "d18ff3db0a2f716776fad406190ef1beabb92fb2", "filename": "gcc/testsuite/g++.dg/init/float1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/393e756da72a7e508b102c04c0fa2e83f136f7aa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Ffloat1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/393e756da72a7e508b102c04c0fa2e83f136f7aa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Ffloat1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Ffloat1.C?ref=393e756da72a7e508b102c04c0fa2e83f136f7aa", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/21089\n+// { dg-do run }\n+\n+extern \"C\" void abort();\n+\n+static const double a = 1.0;\n+struct S {\n+  S();\n+};\n+static S s;\n+static const double b = a + 1.0;\n+\n+S::S() {\n+  if (b < 1.9 || b > 2.1)\n+    abort ();\n+}\n+\n+int main () {\n+}"}]}