{"sha": "e6647190dd8749f039605d04ce83a0d9e3cdcbc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY2NDcxOTBkZDg3NDlmMDM5NjA1ZDA0Y2U4M2EwZDllM2NkY2JjMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-03-21T14:45:36Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-03-21T14:45:36Z"}, "message": "re PR middle-end/39326 (Segmentation fault with -O1, out of memory with -O2)\n\n2013-03-21  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/39326\n\t* tree-ssa-loop-im.c (UNANALYZABLE_MEM_ID): New define.\n\t(MEM_ANALYZABLE): Adjust.\n\t(record_mem_ref_loc): Move bitmap ops ...\n\t(gather_mem_refs_stmt): ... here.  Use the shared mem-ref for\n\tunanalyzable refs, do not record locations for it.\n\t(analyze_memory_references): Allocate ref zero as shared\n\tunanalyzable ref.\n\t(refs_independent_p): Do not test for unanalyzed mems here.\n\t(ref_indep_loop_p_1): Special-case disambiguation against\n\tthe unanalyzed ref.\n\t(ref_indep_loop_p): Assert we are not queried for the\n\tunanalyzed mem.\n\nFrom-SVN: r196878", "tree": {"sha": "76acebdfa9a38d73f37da5a7421971cfba11424b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76acebdfa9a38d73f37da5a7421971cfba11424b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6647190dd8749f039605d04ce83a0d9e3cdcbc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6647190dd8749f039605d04ce83a0d9e3cdcbc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6647190dd8749f039605d04ce83a0d9e3cdcbc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6647190dd8749f039605d04ce83a0d9e3cdcbc0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "65074f54c54e765f5e66ecee17c4ad16f66c3780", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65074f54c54e765f5e66ecee17c4ad16f66c3780", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65074f54c54e765f5e66ecee17c4ad16f66c3780"}], "stats": {"total": 96, "additions": 58, "deletions": 38}, "files": [{"sha": "4a5ea3a720d89991459c6e0dfddd652037e2c3e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6647190dd8749f039605d04ce83a0d9e3cdcbc0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6647190dd8749f039605d04ce83a0d9e3cdcbc0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6647190dd8749f039605d04ce83a0d9e3cdcbc0", "patch": "@@ -1,3 +1,19 @@\n+2013-03-21  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/39326\n+\t* tree-ssa-loop-im.c (UNANALYZABLE_MEM_ID): New define.\n+\t(MEM_ANALYZABLE): Adjust.\n+\t(record_mem_ref_loc): Move bitmap ops ...\n+\t(gather_mem_refs_stmt): ... here.  Use the shared mem-ref for\n+\tunanalyzable refs, do not record locations for it.\n+\t(analyze_memory_references): Allocate ref zero as shared\n+\tunanalyzable ref.\n+\t(refs_independent_p): Do not test for unanalyzed mems here.\n+\t(ref_indep_loop_p_1): Special-case disambiguation against\n+\tthe unanalyzed ref.\n+\t(ref_indep_loop_p): Assert we are not queried for the\n+\tunanalyzed mem.\n+\n 2013-03-21  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* config/arm/arm-protos.h (tune_params): Add"}, {"sha": "ac625959d1368f94fa0b0c499610dc76cd95ffc7", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6647190dd8749f039605d04ce83a0d9e3cdcbc0/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6647190dd8749f039605d04ce83a0d9e3cdcbc0/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=e6647190dd8749f039605d04ce83a0d9e3cdcbc0", "patch": "@@ -189,8 +189,11 @@ static bool ref_indep_loop_p (struct loop *, mem_ref_p);\n #define ALWAYS_EXECUTED_IN(BB) ((struct loop *) (BB)->aux)\n #define SET_ALWAYS_EXECUTED_IN(BB, VAL) ((BB)->aux = (void *) (VAL))\n \n+/* ID of the shared unanalyzable mem.  */\n+#define UNANALYZABLE_MEM_ID 0\n+\n /* Whether the reference was analyzable.  */\n-#define MEM_ANALYZABLE(REF) ((REF)->mem.ref != error_mark_node)\n+#define MEM_ANALYZABLE(REF) ((REF)->id != UNANALYZABLE_MEM_ID)\n \n static struct lim_aux_data *\n init_lim_data (gimple stmt)\n@@ -1526,7 +1529,6 @@ record_mem_ref_loc (mem_ref_p ref, struct loop *loop, gimple stmt, tree *loc)\n {\n   mem_ref_loc_p aref = XNEW (struct mem_ref_loc);\n   mem_ref_locs_p accs;\n-  bitmap ril = memory_accesses.refs_in_loop[loop->num];\n \n   if (ref->accesses_in_loop.length ()\n       <= (unsigned) loop->num)\n@@ -1542,7 +1544,6 @@ record_mem_ref_loc (mem_ref_p ref, struct loop *loop, gimple stmt, tree *loc)\n   aref->ref = loc;\n \n   accs->locs.safe_push (aref);\n-  bitmap_set_bit (ril, ref->id);\n }\n \n /* Marks reference REF as stored in LOOP.  */\n@@ -1578,47 +1579,46 @@ gather_mem_refs_stmt (struct loop *loop, gimple stmt)\n   mem = simple_mem_ref_in_stmt (stmt, &is_stored);\n   if (!mem)\n     {\n-      id = memory_accesses.refs_list.length ();\n-      ref = mem_ref_alloc (error_mark_node, 0, id);\n-      memory_accesses.refs_list.safe_push (ref);\n+      /* We use the shared mem_ref for all unanalyzable refs.  */\n+      id = UNANALYZABLE_MEM_ID;\n+      ref = memory_accesses.refs_list[id];\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Unanalyzed memory reference %u: \", id);\n \t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n \t}\n-      if (gimple_vdef (stmt))\n-\tmark_ref_stored (ref, loop);\n-      record_mem_ref_loc (ref, loop, stmt, mem);\n-      return;\n-    }\n-\n-  hash = iterative_hash_expr (*mem, 0);\n-  slot = htab_find_slot_with_hash (memory_accesses.refs, *mem, hash, INSERT);\n-\n-  if (*slot)\n-    {\n-      ref = (mem_ref_p) *slot;\n-      id = ref->id;\n+      is_stored = gimple_vdef (stmt);\n     }\n   else\n     {\n-      id = memory_accesses.refs_list.length ();\n-      ref = mem_ref_alloc (*mem, hash, id);\n-      memory_accesses.refs_list.safe_push (ref);\n-      *slot = ref;\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n+      hash = iterative_hash_expr (*mem, 0);\n+      slot = htab_find_slot_with_hash (memory_accesses.refs,\n+\t\t\t\t       *mem, hash, INSERT);\n+      if (*slot)\n \t{\n-\t  fprintf (dump_file, \"Memory reference %u: \", id);\n-\t  print_generic_expr (dump_file, ref->mem.ref, TDF_SLIM);\n-\t  fprintf (dump_file, \"\\n\");\n+\t  ref = (mem_ref_p) *slot;\n+\t  id = ref->id;\n \t}\n-    }\n+      else\n+\t{\n+\t  id = memory_accesses.refs_list.length ();\n+\t  ref = mem_ref_alloc (*mem, hash, id);\n+\t  memory_accesses.refs_list.safe_push (ref);\n+\t  *slot = ref;\n \n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Memory reference %u: \", id);\n+\t      print_generic_expr (dump_file, ref->mem.ref, TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t}\n+\n+      record_mem_ref_loc (ref, loop, stmt, mem);\n+    }\n+  bitmap_set_bit (memory_accesses.refs_in_loop[loop->num], ref->id);\n   if (is_stored)\n     mark_ref_stored (ref, loop);\n-\n-  record_mem_ref_loc (ref, loop, stmt, mem);\n   return;\n }\n \n@@ -1744,7 +1744,11 @@ analyze_memory_references (void)\n   bitmap empty;\n \n   memory_accesses.refs = htab_create (100, memref_hash, memref_eq, NULL);\n-  memory_accesses.refs_list.create (0);\n+  memory_accesses.refs_list.create (100);\n+  /* Allocate a special, unanalyzable mem-ref with ID zero.  */\n+  memory_accesses.refs_list.quick_push\n+    (mem_ref_alloc (error_mark_node, 0, UNANALYZABLE_MEM_ID));\n+\n   memory_accesses.refs_in_loop.create (number_of_loops ());\n   memory_accesses.all_refs_in_loop.create (number_of_loops ());\n   memory_accesses.all_refs_stored_in_loop.create (number_of_loops ());\n@@ -2297,10 +2301,6 @@ refs_independent_p (mem_ref_p ref1, mem_ref_p ref2)\n   if (ref1 == ref2)\n     return true;\n \n-  if (!MEM_ANALYZABLE (ref1)\n-      || !MEM_ANALYZABLE (ref2))\n-    return false;\n-\n   /* Reference dependence in a loop is symmetric.  */\n   if (ref1->id > ref2->id)\n     {\n@@ -2363,11 +2363,13 @@ ref_indep_loop_p_1 (struct loop *loop, mem_ref_p ref)\n   else\n     refs_to_check = memory_accesses.all_refs_stored_in_loop[loop->num];\n \n+  if (bitmap_bit_p (refs_to_check, UNANALYZABLE_MEM_ID))\n+    return false;\n+\n   EXECUTE_IF_SET_IN_BITMAP (refs_to_check, 0, i, bi)\n     {\n       aref = memory_accesses.refs_list[i];\n-      if (!MEM_ANALYZABLE (aref)\n-\t  || !refs_independent_p (ref, aref))\n+      if (!refs_independent_p (ref, aref))\n \t{\n \t  ret = false;\n \t  record_indep_loop (loop, aref, false);\n@@ -2386,6 +2388,8 @@ ref_indep_loop_p (struct loop *loop, mem_ref_p ref)\n {\n   bool ret;\n \n+  gcc_checking_assert (MEM_ANALYZABLE (ref));\n+\n   if (bitmap_bit_p (ref->indep_loop, loop->num))\n     return true;\n   if (bitmap_bit_p (ref->dep_loop, loop->num))"}]}