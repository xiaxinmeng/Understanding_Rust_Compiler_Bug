{"sha": "6ca2b0a0388c2944e222aab817db7f09bd2f96c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNhMmIwYTAzODhjMjk0NGUyMjJhYWI4MTdkYjdmMDliZDJmOTZjNA==", "commit": {"author": {"name": "Doug Rupp", "email": "rupp@adacore.com", "date": "2008-07-30T13:06:45Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-07-30T13:06:45Z"}, "message": "gigi.h (build_vms_descriptor64): New function prototype.\n\n2008-07-30  Doug Rupp  <rupp@adacore.com>\n\n\t* gigi.h (build_vms_descriptor64): New function prototype.\n\t(fill_vms_descriptor): Modified function prototype.\n\n\t* utils.c (build_vms_descriptor64): New function.\n\n\t* utils2.c (fill_vms_descriptor): Fix handling on 32bit systems.\n\n\t* trans.c (call_to_gnu): Call fill_vms_descriptor with new third\n\targument.\n\n\t* decl.c (gnat_to_gnu_tree): For By_Descriptor mech, build both a\n\t64bit and 32bit descriptor and save the 64bit version as an alternate\n\tTREE_TYPE in the parameter.\n\t(make_type_from_size) <RECORD_TYPE>: Use the appropriate mode for the\n\tthin pointer.\n\n\t* ada-tree.h (DECL_PARM_ALT, SET_DECL_PARM_ALT): New macros.\n\nFrom-SVN: r138307", "tree": {"sha": "6c15c021426f1cd845672d23d0d9b84ea0fdac47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c15c021426f1cd845672d23d0d9b84ea0fdac47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ca2b0a0388c2944e222aab817db7f09bd2f96c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ca2b0a0388c2944e222aab817db7f09bd2f96c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ca2b0a0388c2944e222aab817db7f09bd2f96c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ca2b0a0388c2944e222aab817db7f09bd2f96c4/comments", "author": {"login": "Cementitious", "id": 115579865, "node_id": "U_kgDOBuOb2Q", "avatar_url": "https://avatars.githubusercontent.com/u/115579865?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Cementitious", "html_url": "https://github.com/Cementitious", "followers_url": "https://api.github.com/users/Cementitious/followers", "following_url": "https://api.github.com/users/Cementitious/following{/other_user}", "gists_url": "https://api.github.com/users/Cementitious/gists{/gist_id}", "starred_url": "https://api.github.com/users/Cementitious/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Cementitious/subscriptions", "organizations_url": "https://api.github.com/users/Cementitious/orgs", "repos_url": "https://api.github.com/users/Cementitious/repos", "events_url": "https://api.github.com/users/Cementitious/events{/privacy}", "received_events_url": "https://api.github.com/users/Cementitious/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "002b2ad6a99fb1e713fb27fffdfc2135319a5a0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/002b2ad6a99fb1e713fb27fffdfc2135319a5a0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/002b2ad6a99fb1e713fb27fffdfc2135319a5a0c"}], "stats": {"total": 426, "additions": 409, "deletions": 17}, "files": [{"sha": "aa6615cdc91abcabe7341fcf383612b4366552a6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca2b0a0388c2944e222aab817db7f09bd2f96c4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca2b0a0388c2944e222aab817db7f09bd2f96c4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6ca2b0a0388c2944e222aab817db7f09bd2f96c4", "patch": "@@ -1,3 +1,23 @@\n+2008-07-30  Doug Rupp  <rupp@adacore.com>\n+\n+\t* gigi.h (build_vms_descriptor64): New function prototype.\n+\t(fill_vms_descriptor): Modified function prototype.\n+\n+\t* utils.c (build_vms_descriptor64): New function.\n+\n+\t* utils2.c (fill_vms_descriptor): Fix handling on 32bit systems.\n+\n+\t* trans.c (call_to_gnu): Call fill_vms_descriptor with new third\n+\targument.\n+\n+\t* decl.c (gnat_to_gnu_tree): For By_Descriptor mech, build both a\n+\t64bit and 32bit descriptor and save the 64bit version as an alternate\n+\tTREE_TYPE in the parameter.\n+\t(make_type_from_size) <RECORD_TYPE>: Use the appropriate mode for the\n+\tthin pointer.\n+\n+\t* ada-tree.h (DECL_PARM_ALT, SET_DECL_PARM_ALT): New macros.\n+\n 2008-07-30  Robert Dewar  <dewar@adacore.com>\n \n \t* make.adb: Minor reformatting"}, {"sha": "9472995effcefea9ed3e430d89537b4722dc42f6", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca2b0a0388c2944e222aab817db7f09bd2f96c4/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca2b0a0388c2944e222aab817db7f09bd2f96c4/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=6ca2b0a0388c2944e222aab817db7f09bd2f96c4", "patch": "@@ -294,6 +294,12 @@ struct lang_type GTY(()) {tree t; };\n #define SET_DECL_FUNCTION_STUB(NODE, X) \\\n   SET_DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE), X)\n \n+/* In a PARM_DECL, points to the alternate TREE_TYPE */\n+#define DECL_PARM_ALT(NODE) \\\n+  GET_DECL_LANG_SPECIFIC (PARM_DECL_CHECK (NODE))\n+#define SET_DECL_PARM_ALT(NODE, X) \\\n+  SET_DECL_LANG_SPECIFIC (PARM_DECL_CHECK (NODE), X)\n+\n /* In a FIELD_DECL corresponding to a discriminant, contains the\n    discriminant number.  */\n #define DECL_DISCRIMINANT_NUMBER(NODE) DECL_INITIAL (FIELD_DECL_CHECK (NODE))"}, {"sha": "61ae653de2a882d4cdb6f3061ffdfa577881173f", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca2b0a0388c2944e222aab817db7f09bd2f96c4/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca2b0a0388c2944e222aab817db7f09bd2f96c4/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=6ca2b0a0388c2944e222aab817db7f09bd2f96c4", "patch": "@@ -4774,6 +4774,7 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n {\n   tree gnu_param_name = get_entity_name (gnat_param);\n   tree gnu_param_type = gnat_to_gnu_type (Etype (gnat_param));\n+  tree gnu_param_type_alt = NULL_TREE;\n   bool in_param = (Ekind (gnat_param) == E_In_Parameter);\n   /* The parameter can be indirectly modified if its address is taken.  */\n   bool ro_param = in_param && !Address_Taken (gnat_param);\n@@ -4820,12 +4821,20 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n     gnu_param_type\n       = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_param_type))));\n \n-  /* VMS descriptors are themselves passed by reference.  */\n+  /* VMS descriptors are themselves passed by reference.\n+     Build both a 32bit and 64bit descriptor, one of which will be chosen\n+     in fill_vms_descriptor based on the allocator size */\n   if (mech == By_Descriptor)\n-    gnu_param_type\n-      = build_pointer_type (build_vms_descriptor (gnu_param_type,\n-\t\t\t\t\t\t  Mechanism (gnat_param),\n-\t\t\t\t\t\t  gnat_subprog));\n+    {\n+      gnu_param_type_alt\n+        = build_pointer_type (build_vms_descriptor64 (gnu_param_type,\n+\t\t\t\t\t\t      Mechanism (gnat_param),\n+\t\t\t\t\t\t      gnat_subprog));\n+      gnu_param_type\n+        = build_pointer_type (build_vms_descriptor (gnu_param_type,\n+\t\t\t\t\t\t    Mechanism (gnat_param),\n+\t\t\t\t\t\t    gnat_subprog));\n+    }\n \n   /* Arrays are passed as pointers to element type for foreign conventions.  */\n   else if (foreign\n@@ -4921,6 +4930,9 @@ gnat_to_gnu_param (Entity_Id gnat_param, Mechanism_Type mech,\n   DECL_POINTS_TO_READONLY_P (gnu_param)\n     = (ro_param && (by_ref || by_component_ptr));\n \n+  /* Save the 64bit descriptor for later. */\n+  SET_DECL_PARM_ALT (gnu_param, gnu_param_type_alt);\n+\n   /* If no Mechanism was specified, indicate what we're using, then\n      back-annotate it.  */\n   if (mech == Default)\n@@ -7155,9 +7167,15 @@ make_type_from_size (tree type, tree size_tree, bool for_biased)\n       /* Do something if this is a fat pointer, in which case we\n \t may need to return the thin pointer.  */\n       if (TYPE_IS_FAT_POINTER_P (type) && size < POINTER_SIZE * 2)\n-\treturn\n-\t  build_pointer_type\n-\t    (TYPE_OBJECT_RECORD_TYPE (TYPE_UNCONSTRAINED_ARRAY (type)));\n+\t{\n+\t  enum machine_mode p_mode = mode_for_size (size, MODE_INT, 0);\n+\t  if (!targetm.valid_pointer_mode (p_mode))\n+\t    p_mode = ptr_mode;\n+\t  return\n+\t    build_pointer_type_for_mode\n+\t      (TYPE_OBJECT_RECORD_TYPE (TYPE_UNCONSTRAINED_ARRAY (type)),\n+\t       p_mode, 0);\n+\t}\n       break;\n \n     case POINTER_TYPE:"}, {"sha": "685bb383bbd25f16a9bdd07329f40571c3d905f5", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca2b0a0388c2944e222aab817db7f09bd2f96c4/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca2b0a0388c2944e222aab817db7f09bd2f96c4/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=6ca2b0a0388c2944e222aab817db7f09bd2f96c4", "patch": "@@ -678,7 +678,7 @@ extern void end_subprog_body (tree body, bool elab_p);\n    Return a constructor for the template.  */\n extern tree build_template (tree template_type, tree array_type, tree expr);\n \n-/* Build a VMS descriptor from a Mechanism_Type, which must specify\n+/* Build a 32bit VMS descriptor from a Mechanism_Type, which must specify\n    a descriptor type, and the GCC type of an object.  Each FIELD_DECL\n    in the type contains in its DECL_INITIAL the expression to use when\n    a constructor is made for the type.  GNAT_ENTITY is a gnat node used\n@@ -687,6 +687,10 @@ extern tree build_template (tree template_type, tree array_type, tree expr);\n extern tree build_vms_descriptor (tree type, Mechanism_Type mech,\n                                   Entity_Id gnat_entity);\n \n+/* Build a 64bit VMS descriptor from a Mechanism_Type. See above. */\n+extern tree build_vms_descriptor64 (tree type, Mechanism_Type mech,\n+                                  Entity_Id gnat_entity);\n+\n /* Build a stub for the subprogram specified by the GCC tree GNU_SUBPROG\n    and the GNAT node GNAT_SUBPROG.  */\n extern void build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog);\n@@ -844,9 +848,9 @@ extern tree build_allocator (tree type, tree init, tree result_type,\n                              Node_Id gnat_node, bool);\n \n /* Fill in a VMS descriptor for EXPR and return a constructor for it.\n-   GNAT_FORMAL is how we find the descriptor record.  */\n-\n-extern tree fill_vms_descriptor (tree expr, Entity_Id gnat_formal);\n+   GNAT_FORMAL is how we find the descriptor record. GNAT_ACTUAL is how we\n+   find the size of the allocator. */\n+extern tree fill_vms_descriptor (tree expr, Entity_Id gnat_formal, Node_Id gnat_actual);\n \n /* Indicate that we need to make the address of EXPR_NODE and it therefore\n    should not be allocated in a register.  Return true if successful.  */"}, {"sha": "3b15e30a222d3d0fd2033842dffc024f6e2f26ba", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca2b0a0388c2944e222aab817db7f09bd2f96c4/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca2b0a0388c2944e222aab817db7f09bd2f96c4/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=6ca2b0a0388c2944e222aab817db7f09bd2f96c4", "patch": "@@ -2368,7 +2368,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t  else\n \t    gnu_actual = build_unary_op (ADDR_EXPR, NULL_TREE,\n \t\t\t\t\t fill_vms_descriptor (gnu_actual,\n-\t\t\t\t\t\t\t      gnat_formal));\n+\t\t\t\t\t\t\t      gnat_formal,\n+\t\t\t\t\t\t\t      gnat_actual));\n \t}\n       else\n \t{"}, {"sha": "01cc9b8948e881e8afb1a027484951921f9ac97f", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 316, "deletions": 1, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca2b0a0388c2944e222aab817db7f09bd2f96c4/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca2b0a0388c2944e222aab817db7f09bd2f96c4/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=6ca2b0a0388c2944e222aab817db7f09bd2f96c4", "patch": "@@ -2635,7 +2635,7 @@ build_template (tree template_type, tree array_type, tree expr)\n   return gnat_build_constructor (template_type, nreverse (template_elts));\n }\n \f\n-/* Build a VMS descriptor from a Mechanism_Type, which must specify\n+/* Build a 32bit VMS descriptor from a Mechanism_Type, which must specify\n    a descriptor type, and the GCC type of an object.  Each FIELD_DECL\n    in the type contains in its DECL_INITIAL the expression to use when\n    a constructor is made for the type.  GNAT_ENTITY is an entity used\n@@ -2937,6 +2937,321 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n   return record_type;\n }\n \n+/* Build a 64bit VMS descriptor from a Mechanism_Type, which must specify\n+   a descriptor type, and the GCC type of an object.  Each FIELD_DECL\n+   in the type contains in its DECL_INITIAL the expression to use when\n+   a constructor is made for the type.  GNAT_ENTITY is an entity used\n+   to print out an error message if the mechanism cannot be applied to\n+   an object of that type and also for the name.  */\n+\n+tree\n+build_vms_descriptor64 (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n+{\n+  tree record64_type = make_node (RECORD_TYPE);\n+  tree pointer64_type;\n+  tree field_list64 = 0;\n+  int class;\n+  int dtype = 0;\n+  tree inner_type;\n+  int ndim;\n+  int i;\n+  tree *idx_arr;\n+  tree tem;\n+\n+  /* If TYPE is an unconstrained array, use the underlying array type.  */\n+  if (TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)\n+    type = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (type))));\n+\n+  /* If this is an array, compute the number of dimensions in the array,\n+     get the index types, and point to the inner type.  */\n+  if (TREE_CODE (type) != ARRAY_TYPE)\n+    ndim = 0;\n+  else\n+    for (ndim = 1, inner_type = type;\n+\t TREE_CODE (TREE_TYPE (inner_type)) == ARRAY_TYPE\n+\t && TYPE_MULTI_ARRAY_P (TREE_TYPE (inner_type));\n+\t ndim++, inner_type = TREE_TYPE (inner_type))\n+      ;\n+\n+  idx_arr = (tree *) alloca (ndim * sizeof (tree));\n+\n+  if (mech != By_Descriptor_NCA\n+      && TREE_CODE (type) == ARRAY_TYPE && TYPE_CONVENTION_FORTRAN_P (type))\n+    for (i = ndim - 1, inner_type = type;\n+\t i >= 0;\n+\t i--, inner_type = TREE_TYPE (inner_type))\n+      idx_arr[i] = TYPE_DOMAIN (inner_type);\n+  else\n+    for (i = 0, inner_type = type;\n+\t i < ndim;\n+\t i++, inner_type = TREE_TYPE (inner_type))\n+      idx_arr[i] = TYPE_DOMAIN (inner_type);\n+\n+  /* Now get the DTYPE value.  */\n+  switch (TREE_CODE (type))\n+    {\n+    case INTEGER_TYPE:\n+    case ENUMERAL_TYPE:\n+      if (TYPE_VAX_FLOATING_POINT_P (type))\n+\tswitch (tree_low_cst (TYPE_DIGITS_VALUE (type), 1))\n+\t  {\n+\t  case 6:\n+\t    dtype = 10;\n+\t    break;\n+\t  case 9:\n+\t    dtype = 11;\n+\t    break;\n+\t  case 15:\n+\t    dtype = 27;\n+\t    break;\n+\t  }\n+      else\n+\tswitch (GET_MODE_BITSIZE (TYPE_MODE (type)))\n+\t  {\n+\t  case 8:\n+\t    dtype = TYPE_UNSIGNED (type) ? 2 : 6;\n+\t    break;\n+\t  case 16:\n+\t    dtype = TYPE_UNSIGNED (type) ? 3 : 7;\n+\t    break;\n+\t  case 32:\n+\t    dtype = TYPE_UNSIGNED (type) ? 4 : 8;\n+\t    break;\n+\t  case 64:\n+\t    dtype = TYPE_UNSIGNED (type) ? 5 : 9;\n+\t    break;\n+\t  case 128:\n+\t    dtype = TYPE_UNSIGNED (type) ? 25 : 26;\n+\t    break;\n+\t  }\n+      break;\n+\n+    case REAL_TYPE:\n+      dtype = GET_MODE_BITSIZE (TYPE_MODE (type)) == 32 ? 52 : 53;\n+      break;\n+\n+    case COMPLEX_TYPE:\n+      if (TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE\n+\t  && TYPE_VAX_FLOATING_POINT_P (type))\n+\tswitch (tree_low_cst (TYPE_DIGITS_VALUE (type), 1))\n+\t  {\n+\t  case 6:\n+\t    dtype = 12;\n+\t    break;\n+\t  case 9:\n+\t    dtype = 13;\n+\t    break;\n+\t  case 15:\n+\t    dtype = 29;\n+\t  }\n+      else\n+\tdtype = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (type))) == 32 ? 54: 55;\n+      break;\n+\n+    case ARRAY_TYPE:\n+      dtype = 14;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Get the CLASS value.  */\n+  switch (mech)\n+    {\n+    case By_Descriptor_A:\n+      class = 4;\n+      break;\n+    case By_Descriptor_NCA:\n+      class = 10;\n+      break;\n+    case By_Descriptor_SB:\n+      class = 15;\n+      break;\n+    case By_Descriptor:\n+    case By_Descriptor_S:\n+    default:\n+      class = 1;\n+      break;\n+    }\n+\n+  /* Make the type for a 64bit descriptor for VMS.  The first six fields\n+     are the same for all types.  */\n+\n+  field_list64 = chainon (field_list64,\n+\t\t\tmake_descriptor_field (\"MBO\",\n+                                               gnat_type_for_size (16, 1),\n+                                               record64_type, size_int (1)));\n+\n+  field_list64 = chainon (field_list64,\n+\t\t\tmake_descriptor_field (\"DTYPE\",\n+\t\t\t\t\t       gnat_type_for_size (8, 1),\n+\t\t\t\t\t       record64_type, size_int (dtype)));\n+  field_list64 = chainon (field_list64,\n+\t\t\tmake_descriptor_field (\"CLASS\",\n+\t\t\t\t\t       gnat_type_for_size (8, 1),\n+\t\t\t\t\t       record64_type, size_int (class)));\n+\n+  field_list64 = chainon (field_list64,\n+\t\t\tmake_descriptor_field (\"MBMO\",\n+                                               gnat_type_for_size (32, 1),\n+                                               record64_type, ssize_int (-1)));\n+\n+  field_list64\n+    = chainon (field_list64,\n+\t       make_descriptor_field\n+\t       (\"LENGTH\", gnat_type_for_size (64, 1), record64_type,\n+\t\tsize_in_bytes (mech == By_Descriptor_A ? inner_type : type)));\n+\n+  pointer64_type = build_pointer_type_for_mode (type, DImode, false);\n+\n+  field_list64\n+    = chainon (field_list64,\n+\t       make_descriptor_field\n+\t       (\"POINTER\", pointer64_type, record64_type,\n+\t\tbuild_unary_op (ADDR_EXPR,\n+\t\t\t\tpointer64_type,\n+\t\t\t\tbuild0 (PLACEHOLDER_EXPR, type))));\n+\n+  switch (mech)\n+    {\n+    case By_Descriptor:\n+    case By_Descriptor_S:\n+      break;\n+\n+    case By_Descriptor_SB:\n+      field_list64\n+\t= chainon (field_list64,\n+\t\t   make_descriptor_field\n+\t\t   (\"SB_L1\", gnat_type_for_size (64, 1), record64_type,\n+\t\t    TREE_CODE (type) == ARRAY_TYPE\n+\t\t    ? TYPE_MIN_VALUE (TYPE_DOMAIN (type)) : size_zero_node));\n+      field_list64\n+\t= chainon (field_list64,\n+\t\t   make_descriptor_field\n+\t\t   (\"SB_U1\", gnat_type_for_size (64, 1), record64_type,\n+\t\t    TREE_CODE (type) == ARRAY_TYPE\n+\t\t    ? TYPE_MAX_VALUE (TYPE_DOMAIN (type)) : size_zero_node));\n+      break;\n+\n+    case By_Descriptor_A:\n+    case By_Descriptor_NCA:\n+      field_list64 = chainon (field_list64,\n+\t\t\t    make_descriptor_field (\"SCALE\",\n+\t\t\t\t\t\t   gnat_type_for_size (8, 1),\n+\t\t\t\t\t\t   record64_type,\n+\t\t\t\t\t\t   size_zero_node));\n+\n+      field_list64 = chainon (field_list64,\n+\t\t\t    make_descriptor_field (\"DIGITS\",\n+\t\t\t\t\t\t   gnat_type_for_size (8, 1),\n+\t\t\t\t\t\t   record64_type,\n+\t\t\t\t\t\t   size_zero_node));\n+\n+      field_list64\n+\t= chainon (field_list64,\n+\t\t   make_descriptor_field\n+\t\t   (\"AFLAGS\", gnat_type_for_size (8, 1), record64_type,\n+\t\t    size_int (mech == By_Descriptor_NCA\n+\t\t\t      ? 0\n+\t\t\t      /* Set FL_COLUMN, FL_COEFF, and FL_BOUNDS.  */\n+\t\t\t      : (TREE_CODE (type) == ARRAY_TYPE\n+\t\t\t\t && TYPE_CONVENTION_FORTRAN_P (type)\n+\t\t\t\t ? 224 : 192))));\n+\n+      field_list64 = chainon (field_list64,\n+\t\t\t    make_descriptor_field (\"DIMCT\",\n+\t\t\t\t\t\t   gnat_type_for_size (8, 1),\n+\t\t\t\t\t\t   record64_type,\n+\t\t\t\t\t\t   size_int (ndim)));\n+\n+      field_list64 = chainon (field_list64,\n+\t\t\t    make_descriptor_field (\"MBZ\",\n+\t\t\t\t\t\t   gnat_type_for_size (32, 1),\n+\t\t\t\t\t\t   record64_type,\n+\t\t\t\t\t\t   size_int (0)));\n+      field_list64 = chainon (field_list64,\n+\t\t\t    make_descriptor_field (\"ARSIZE\",\n+\t\t\t\t\t\t   gnat_type_for_size (64, 1),\n+\t\t\t\t\t\t   record64_type,\n+\t\t\t\t\t\t   size_in_bytes (type)));\n+\n+      /* Now build a pointer to the 0,0,0... element.  */\n+      tem = build0 (PLACEHOLDER_EXPR, type);\n+      for (i = 0, inner_type = type; i < ndim;\n+\t   i++, inner_type = TREE_TYPE (inner_type))\n+\ttem = build4 (ARRAY_REF, TREE_TYPE (inner_type), tem,\n+\t\t      convert (TYPE_DOMAIN (inner_type), size_zero_node),\n+\t\t      NULL_TREE, NULL_TREE);\n+\n+      field_list64\n+\t= chainon (field_list64,\n+\t\t   make_descriptor_field\n+\t\t   (\"A0\",\n+\t\t    build_pointer_type_for_mode (inner_type, DImode, false),\n+\t\t    record64_type,\n+\t\t    build1 (ADDR_EXPR,\n+\t\t\t    build_pointer_type_for_mode (inner_type, DImode,\n+\t\t\t\t\t\t\t false),\n+\t\t\t    tem)));\n+\n+      /* Next come the addressing coefficients.  */\n+      tem = size_one_node;\n+      for (i = 0; i < ndim; i++)\n+\t{\n+\t  char fname[3];\n+\t  tree idx_length\n+\t    = size_binop (MULT_EXPR, tem,\n+\t\t\t  size_binop (PLUS_EXPR,\n+\t\t\t\t      size_binop (MINUS_EXPR,\n+\t\t\t\t\t\t  TYPE_MAX_VALUE (idx_arr[i]),\n+\t\t\t\t\t\t  TYPE_MIN_VALUE (idx_arr[i])),\n+\t\t\t\t      size_int (1)));\n+\n+\t  fname[0] = (mech == By_Descriptor_NCA ? 'S' : 'M');\n+\t  fname[1] = '0' + i, fname[2] = 0;\n+\t  field_list64\n+\t    = chainon (field_list64,\n+\t\t       make_descriptor_field (fname,\n+\t\t\t\t\t      gnat_type_for_size (64, 1),\n+\t\t\t\t\t      record64_type, idx_length));\n+\n+\t  if (mech == By_Descriptor_NCA)\n+\t    tem = idx_length;\n+\t}\n+\n+      /* Finally here are the bounds.  */\n+      for (i = 0; i < ndim; i++)\n+\t{\n+\t  char fname[3];\n+\n+\t  fname[0] = 'L', fname[1] = '0' + i, fname[2] = 0;\n+\t  field_list64\n+\t    = chainon (field_list64,\n+\t\t       make_descriptor_field\n+\t\t       (fname, gnat_type_for_size (64, 1), record64_type,\n+\t\t\tTYPE_MIN_VALUE (idx_arr[i])));\n+\n+\t  fname[0] = 'U';\n+\t  field_list64\n+\t    = chainon (field_list64,\n+\t\t       make_descriptor_field\n+\t\t       (fname, gnat_type_for_size (64, 1), record64_type,\n+\t\t\tTYPE_MAX_VALUE (idx_arr[i])));\n+\t}\n+      break;\n+\n+    default:\n+      post_error (\"unsupported descriptor type for &\", gnat_entity);\n+    }\n+\n+  finish_record_type (record64_type, field_list64, 0, true);\n+  create_type_decl (create_concat_name (gnat_entity, \"DESC64\"), record64_type,\n+\t\t    NULL, true, false, gnat_entity);\n+\n+  return record64_type;\n+}\n+\n /* Utility routine for above code to make a field.  */\n \n static tree"}, {"sha": "1ed1b9f9cdba0bb17e457c9f4fed6eec500b78fa", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca2b0a0388c2944e222aab817db7f09bd2f96c4/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca2b0a0388c2944e222aab817db7f09bd2f96c4/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=6ca2b0a0388c2944e222aab817db7f09bd2f96c4", "patch": "@@ -2151,15 +2151,43 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n }\n \f\n /* Fill in a VMS descriptor for EXPR and return a constructor for it.\n-   GNAT_FORMAL is how we find the descriptor record.  */\n+   GNAT_FORMAL is how we find the descriptor record.  GNAT_ACTUAL is\n+   how we find the allocator size which determines whether to use the\n+   alternate 64bit descriptor. */\n \n tree\n-fill_vms_descriptor (tree expr, Entity_Id gnat_formal)\n+fill_vms_descriptor (tree expr, Entity_Id gnat_formal, Node_Id gnat_actual)\n {\n-  tree record_type = TREE_TYPE (TREE_TYPE (get_gnu_tree (gnat_formal)));\n   tree field;\n+  tree parm_decl = get_gnu_tree (gnat_formal);\n   tree const_list = NULL_TREE;\n+  int size;\n+  tree record_type;\n+\n+  /* A string literal will always be in 32bit space on VMS. Where\n+     will it be on other 64bit systems???\n+     An identifier's allocation may be unknown at compile time.\n+     An explicit dereference could be either in 32bit or 64bit space.\n+     Don't know about other possibilities, so assume unknown which\n+     will result in fetching the 64bit descriptor. ??? */\n+  if (Nkind (gnat_actual) == N_String_Literal)\n+    size = 32;\n+  else if (Nkind (gnat_actual) == N_Identifier)\n+    size = UI_To_Int (Esize (Etype (gnat_actual)));\n+  else if (Nkind (gnat_actual) == N_Explicit_Dereference)\n+    size = UI_To_Int (Esize (Etype (Prefix (gnat_actual))));\n+  else\n+    size = 0;\n+\n+  /* If size is unknown, make it POINTER_SIZE */\n+  if (size == 0)\n+    size = POINTER_SIZE;\n+\n+  /* If size is 64bits grab the alternate 64bit descriptor. */\n+  if (size == 64)\n+    TREE_TYPE (parm_decl) = DECL_PARM_ALT (parm_decl);\n \n+  record_type = TREE_TYPE (TREE_TYPE (parm_decl));\n   expr = maybe_unconstrained_array (expr);\n   gnat_mark_addressable (expr);\n "}]}