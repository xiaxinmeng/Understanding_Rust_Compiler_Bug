{"sha": "c26f60f6a28394e98ac1d830cbe8f632ef576dbb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI2ZjYwZjZhMjgzOTRlOThhYzFkODMwY2JlOGY2MzJlZjU3NmRiYg==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-08-07T14:35:45Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:20Z"}, "message": "Miscellaneous improvements to various target hooks", "tree": {"sha": "8a55e520ae319b1f4e9c9e88b73e3669960b2ee3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a55e520ae319b1f4e9c9e88b73e3669960b2ee3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c26f60f6a28394e98ac1d830cbe8f632ef576dbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c26f60f6a28394e98ac1d830cbe8f632ef576dbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c26f60f6a28394e98ac1d830cbe8f632ef576dbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c26f60f6a28394e98ac1d830cbe8f632ef576dbb/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9dd2cdd8338fd835a227521661eafe259e401830", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dd2cdd8338fd835a227521661eafe259e401830", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dd2cdd8338fd835a227521661eafe259e401830"}], "stats": {"total": 1187, "additions": 638, "deletions": 549}, "files": [{"sha": "3ac6444ff616d70a6243ac96c23f1c0f263517b8", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 636, "deletions": 541, "changes": 1177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c26f60f6a28394e98ac1d830cbe8f632ef576dbb/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c26f60f6a28394e98ac1d830cbe8f632ef576dbb/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=c26f60f6a28394e98ac1d830cbe8f632ef576dbb", "patch": "@@ -32,186 +32,221 @@\n \n /* Predefinition in the preprocessor for this target machine */\n #ifndef TARGET_CPU_CPP_BUILTINS\n-#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      builtin_define_std (\"bfin\");\t\t\\\n-      builtin_define_std (\"BFIN\");\t\t\\\n-      builtin_define (\"__ADSPBLACKFIN__\");\t\\\n-      builtin_define (\"__ADSPLPBLACKFIN__\");\t\\\n-\t\t\t\t\t\t\\\n-      switch (bfin_cpu_type)\t\t\t\\\n-\t{\t\t\t\t\t\\\n-\tcase BFIN_CPU_UNKNOWN:\t\t\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF512:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF512__\");\t\\\n-\t  builtin_define (\"__ADSPBF51x__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF514:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF514__\");\t\\\n-\t  builtin_define (\"__ADSPBF51x__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF516:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF516__\");\t\\\n-\t  builtin_define (\"__ADSPBF51x__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF518:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF518__\");\t\\\n-\t  builtin_define (\"__ADSPBF51x__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF522:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF522__\");\t\\\n-\t  builtin_define (\"__ADSPBF52x__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF523:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF523__\");\t\\\n-\t  builtin_define (\"__ADSPBF52x__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF524:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF524__\");\t\\\n-\t  builtin_define (\"__ADSPBF52x__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF525:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF525__\");\t\\\n-\t  builtin_define (\"__ADSPBF52x__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF526:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF526__\");\t\\\n-\t  builtin_define (\"__ADSPBF52x__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF527:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF527__\");\t\\\n-\t  builtin_define (\"__ADSPBF52x__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF531:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF531__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF532:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF532__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF533:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF533__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF534:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF534__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF536:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF536__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF537:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF537__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF538:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF538__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF539:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF539__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF542M:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF542M__\");\t\\\n-\t  /* FALLTHRU */\t\t\t\\\n-\tcase BFIN_CPU_BF542:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF542__\");\t\\\n-\t  builtin_define (\"__ADSPBF54x__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF544M:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF544M__\");\t\\\n-\t  /* FALLTHRU */\t\t\t\\\n-\tcase BFIN_CPU_BF544:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF544__\");\t\\\n-\t  builtin_define (\"__ADSPBF54x__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF547M:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF547M__\");\t\\\n-\t  /* FALLTHRU */\t\t\t\\\n-\tcase BFIN_CPU_BF547:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF547__\");\t\\\n-\t  builtin_define (\"__ADSPBF54x__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF548M:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF548M__\");\t\\\n-\t  /* FALLTHRU */\t\t\t\\\n-\tcase BFIN_CPU_BF548:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF548__\");\t\\\n-\t  builtin_define (\"__ADSPBF54x__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF549M:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF549M__\");\t\\\n-\t  /* FALLTHRU */\t\t\t\\\n-\tcase BFIN_CPU_BF549:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF549__\");\t\\\n-\t  builtin_define (\"__ADSPBF54x__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF561:\t\t\t\\\n-\t  builtin_define (\"__ADSPBF561__\");\t\\\n-\t  break;\t\t\t\t\\\n-\tcase BFIN_CPU_BF592:            \\\n-\t  builtin_define (\"__ADSPBF592__\"); \\\n-\t  builtin_define (\"__ADSPBF59x__\"); \\\n-\t  break;                \\\n-\t}\t\t\t\t\t\\\n-\t\t\t\t\t\t\\\n-      if (bfin_si_revision != -1)\t\t\\\n-\t{\t\t\t\t\t\\\n-\t  /* space of 0xnnnn and a NUL */\t\\\n-\t  char *buf = XALLOCAVEC (char, 7);\t\\\n-\t\t\t\t\t\t\\\n-\t  sprintf (buf, \"0x%04x\", bfin_si_revision);\t\t\t\\\n-\t  builtin_define_with_value (\"__SILICON_REVISION__\", buf, 0);\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (bfin_workarounds)\t\t\t\t\t\t\\\n-\tbuiltin_define (\"__WORKAROUNDS_ENABLED\");\t\t\t\\\n-      if (ENABLE_WA_SPECULATIVE_LOADS)\t\t\t\t\t\\\n-\tbuiltin_define (\"__WORKAROUND_SPECULATIVE_LOADS\");\t\t\\\n-      if (ENABLE_WA_SPECULATIVE_SYNCS)\t\t\t\t\t\\\n-\tbuiltin_define (\"__WORKAROUND_SPECULATIVE_SYNCS\");\t\t\\\n-      if (ENABLE_WA_INDIRECT_CALLS)\t\t\t\t\t\\\n-\tbuiltin_define (\"__WORKAROUND_INDIRECT_CALLS\");\t\t\t\\\n-      if (ENABLE_WA_RETS)\t\t\t\t\t\t\\\n-\tbuiltin_define (\"__WORKAROUND_RETS\");\t\t\t\t\\\n-\t\t\t\t\t\t\\\n-      if (TARGET_FDPIC)\t\t\t\t\\\n-\t{\t\t\t\t\t\\\n-\t  builtin_define (\"__BFIN_FDPIC__\");\t\\\n-\t  builtin_define (\"__FDPIC__\");\t\t\\\n-\t}\t\t\t\t\t\\\n-      if (TARGET_ID_SHARED_LIBRARY\t\t\\\n-\t  && !TARGET_SEP_DATA)\t\t\t\\\n-\tbuiltin_define (\"__ID_SHARED_LIB__\");\t\\\n-      if (flag_no_builtin)\t\t\t\\\n-\tbuiltin_define (\"__NO_BUILTIN\");\t\\\n-      if (TARGET_MULTICORE)\t\t\t\\\n-\tbuiltin_define (\"__BFIN_MULTICORE\");\t\\\n-      if (TARGET_COREA)\t\t\t\t\\\n-\tbuiltin_define (\"__BFIN_COREA\");\t\\\n-      if (TARGET_COREB)\t\t\t\t\\\n-\tbuiltin_define (\"__BFIN_COREB\");\t\\\n-      if (TARGET_SDRAM)\t\t\t\t\\\n-\tbuiltin_define (\"__BFIN_SDRAM\");\t\\\n-    }\t\t\t\t\t\t\\\n+#define TARGET_CPU_CPP_BUILTINS()                                              \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      builtin_define_std (\"bfin\");                                             \\\n+      builtin_define_std (\"BFIN\");                                             \\\n+      builtin_define (\"__ADSPBLACKFIN__\");                                     \\\n+      builtin_define (\"__ADSPLPBLACKFIN__\");                                   \\\n+                                                                               \\\n+      switch (bfin_cpu_type)                                                   \\\n+\t{                                                                      \\\n+\tcase BFIN_CPU_UNKNOWN:                                                 \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF512:                                                   \\\n+\t  builtin_define (\"__ADSPBF512__\");                                    \\\n+\t  builtin_define (\"__ADSPBF51x__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF514:                                                   \\\n+\t  builtin_define (\"__ADSPBF514__\");                                    \\\n+\t  builtin_define (\"__ADSPBF51x__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF516:                                                   \\\n+\t  builtin_define (\"__ADSPBF516__\");                                    \\\n+\t  builtin_define (\"__ADSPBF51x__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF518:                                                   \\\n+\t  builtin_define (\"__ADSPBF518__\");                                    \\\n+\t  builtin_define (\"__ADSPBF51x__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF522:                                                   \\\n+\t  builtin_define (\"__ADSPBF522__\");                                    \\\n+\t  builtin_define (\"__ADSPBF52x__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF523:                                                   \\\n+\t  builtin_define (\"__ADSPBF523__\");                                    \\\n+\t  builtin_define (\"__ADSPBF52x__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF524:                                                   \\\n+\t  builtin_define (\"__ADSPBF524__\");                                    \\\n+\t  builtin_define (\"__ADSPBF52x__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF525:                                                   \\\n+\t  builtin_define (\"__ADSPBF525__\");                                    \\\n+\t  builtin_define (\"__ADSPBF52x__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF526:                                                   \\\n+\t  builtin_define (\"__ADSPBF526__\");                                    \\\n+\t  builtin_define (\"__ADSPBF52x__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF527:                                                   \\\n+\t  builtin_define (\"__ADSPBF527__\");                                    \\\n+\t  builtin_define (\"__ADSPBF52x__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF531:                                                   \\\n+\t  builtin_define (\"__ADSPBF531__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF532:                                                   \\\n+\t  builtin_define (\"__ADSPBF532__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF533:                                                   \\\n+\t  builtin_define (\"__ADSPBF533__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF534:                                                   \\\n+\t  builtin_define (\"__ADSPBF534__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF536:                                                   \\\n+\t  builtin_define (\"__ADSPBF536__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF537:                                                   \\\n+\t  builtin_define (\"__ADSPBF537__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF538:                                                   \\\n+\t  builtin_define (\"__ADSPBF538__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF539:                                                   \\\n+\t  builtin_define (\"__ADSPBF539__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF542M:                                                  \\\n+\t  builtin_define (\"__ADSPBF542M__\");                                   \\\n+\t  /* FALLTHRU */                                                       \\\n+\tcase BFIN_CPU_BF542:                                                   \\\n+\t  builtin_define (\"__ADSPBF542__\");                                    \\\n+\t  builtin_define (\"__ADSPBF54x__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF544M:                                                  \\\n+\t  builtin_define (\"__ADSPBF544M__\");                                   \\\n+\t  /* FALLTHRU */                                                       \\\n+\tcase BFIN_CPU_BF544:                                                   \\\n+\t  builtin_define (\"__ADSPBF544__\");                                    \\\n+\t  builtin_define (\"__ADSPBF54x__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF547M:                                                  \\\n+\t  builtin_define (\"__ADSPBF547M__\");                                   \\\n+\t  /* FALLTHRU */                                                       \\\n+\tcase BFIN_CPU_BF547:                                                   \\\n+\t  builtin_define (\"__ADSPBF547__\");                                    \\\n+\t  builtin_define (\"__ADSPBF54x__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF548M:                                                  \\\n+\t  builtin_define (\"__ADSPBF548M__\");                                   \\\n+\t  /* FALLTHRU */                                                       \\\n+\tcase BFIN_CPU_BF548:                                                   \\\n+\t  builtin_define (\"__ADSPBF548__\");                                    \\\n+\t  builtin_define (\"__ADSPBF54x__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF549M:                                                  \\\n+\t  builtin_define (\"__ADSPBF549M__\");                                   \\\n+\t  /* FALLTHRU */                                                       \\\n+\tcase BFIN_CPU_BF549:                                                   \\\n+\t  builtin_define (\"__ADSPBF549__\");                                    \\\n+\t  builtin_define (\"__ADSPBF54x__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF561:                                                   \\\n+\t  builtin_define (\"__ADSPBF561__\");                                    \\\n+\t  break;                                                               \\\n+\tcase BFIN_CPU_BF592:                                                   \\\n+\t  builtin_define (\"__ADSPBF592__\");                                    \\\n+\t  builtin_define (\"__ADSPBF59x__\");                                    \\\n+\t  break;                                                               \\\n+\t}                                                                      \\\n+                                                                               \\\n+      if (bfin_si_revision != -1)                                              \\\n+\t{                                                                      \\\n+\t  /* space of 0xnnnn and a NUL */                                      \\\n+\t  char *buf = XALLOCAVEC (char, 7);                                    \\\n+                                                                               \\\n+\t  sprintf (buf, \"0x%04x\", bfin_si_revision);                           \\\n+\t  builtin_define_with_value (\"__SILICON_REVISION__\", buf, 0);          \\\n+\t}                                                                      \\\n+                                                                               \\\n+      if (bfin_workarounds)                                                    \\\n+\tbuiltin_define (\"__WORKAROUNDS_ENABLED\");                              \\\n+      if (ENABLE_WA_SPECULATIVE_LOADS)                                         \\\n+\tbuiltin_define (\"__WORKAROUND_SPECULATIVE_LOADS\");                     \\\n+      if (ENABLE_WA_SPECULATIVE_SYNCS)                                         \\\n+\tbuiltin_define (\"__WORKAROUND_SPECULATIVE_SYNCS\");                     \\\n+      if (ENABLE_WA_INDIRECT_CALLS)                                            \\\n+\tbuiltin_define (\"__WORKAROUND_INDIRECT_CALLS\");                        \\\n+      if (ENABLE_WA_RETS)                                                      \\\n+\tbuiltin_define (\"__WORKAROUND_RETS\");                                  \\\n+                                                                               \\\n+      if (TARGET_FDPIC)                                                        \\\n+\t{                                                                      \\\n+\t  builtin_define (\"__BFIN_FDPIC__\");                                   \\\n+\t  builtin_define (\"__FDPIC__\");                                        \\\n+\t}                                                                      \\\n+      if (TARGET_ID_SHARED_LIBRARY && !TARGET_SEP_DATA)                        \\\n+\tbuiltin_define (\"__ID_SHARED_LIB__\");                                  \\\n+      if (flag_no_builtin)                                                     \\\n+\tbuiltin_define (\"__NO_BUILTIN\");                                       \\\n+      if (TARGET_MULTICORE)                                                    \\\n+\tbuiltin_define (\"__BFIN_MULTICORE\");                                   \\\n+      if (TARGET_COREA)                                                        \\\n+\tbuiltin_define (\"__BFIN_COREA\");                                       \\\n+      if (TARGET_COREB)                                                        \\\n+\tbuiltin_define (\"__BFIN_COREB\");                                       \\\n+      if (TARGET_SDRAM)                                                        \\\n+\tbuiltin_define (\"__BFIN_SDRAM\");                                       \\\n+    }                                                                          \\\n   while (0)\n #endif\n \n-#define DRIVER_SELF_SPECS SUBTARGET_DRIVER_SELF_SPECS\t\"\\\n+/* Rust target CPU info for this machine. Could not add new compilation unit\n+ without significant modification to target, so included as macro instead. */\n+#define TARGET_RUST_CPU_INFO()                                                 \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      rust_add_target_info (\"target_arch\", \"bfin\");                            \\\n+      /* TODO maybe add other features? based on old llvm so ones missing */   \\\n+      if (TARGET_SDRAM)                                                        \\\n+\trust_add_target_info (\"target_feature\", \"sdram\");                      \\\n+      if (TARGET_ICPLB)                                                        \\\n+\trust_add_target_info (\"target_feature\", \"icplb\");                      \\\n+      if (ENABLE_WA_05000074)                                                  \\\n+\trust_add_target_info (\"target_feature\", \"mi-shift-anomaly\");           \\\n+      if (ENABLE_WA_SPECULATIVE_SYNCS)                                         \\\n+\trust_add_target_info (\"target_feature\", \"csync-anomaly\");              \\\n+      if (ENABLE_WA_SPECULATIVE_LOADS)                                         \\\n+\trust_add_target_info (\"target_feature\", \"specld-anomaly\");             \\\n+      if (ENABLE_WA_05000257)                                                  \\\n+\trust_add_target_info (\"target_feature\", \"hwloop-anomaly\");             \\\n+      if (ENABLE_WA_05000283)                                                  \\\n+\trust_add_target_info (\"target_feature\", \"mmr-stall-anomaly\");          \\\n+      if (ENABLE_WA_LOAD_LCREGS)                                               \\\n+\trust_add_target_info (\"target_feature\", \"lcregs-anomaly\");             \\\n+      if (ENABLE_WA_05000315)                                                  \\\n+\trust_add_target_info (\"target_feature\", \"killed-mmr-anomaly\");         \\\n+      if (ENABLE_WA_RETS)                                                      \\\n+\trust_add_target_info (\"target_feature\", \"rets-anomaly\");               \\\n+      if (ENABLE_WA_INDIRECT_CALLS)                                            \\\n+\trust_add_target_info (\"target_feature\", \"ind-call-anomaly\");           \\\n+    }                                                                          \\\n+  while (0)\n+\n+#define DRIVER_SELF_SPECS                                                      \\\n+  SUBTARGET_DRIVER_SELF_SPECS \"\\\n  %{mleaf-id-shared-library:%{!mid-shared-library:-mid-shared-library}} \\\n  %{mfdpic:%{!fpic:%{!fpie:%{!fPIC:%{!fPIE:\\\n    \t    %{!fno-pic:%{!fno-pie:%{!fno-PIC:%{!fno-PIE:-fpie}}}}}}}}} \\\n \"\n #ifndef SUBTARGET_DRIVER_SELF_SPECS\n-# define SUBTARGET_DRIVER_SELF_SPECS\n+#define SUBTARGET_DRIVER_SELF_SPECS\n #endif\n \n-#define LINK_GCC_C_SEQUENCE_SPEC \"\\\n+#define LINK_GCC_C_SEQUENCE_SPEC                                               \\\n+  \"\\\n   %{mfast-fp:-lbffastfp} %G %{!nolibc:%L} %{mfast-fp:-lbffastfp} %G \\\n \"\n \n-#undef  ASM_SPEC\n-#define ASM_SPEC \"\\\n+#undef ASM_SPEC\n+#define ASM_SPEC                                                               \\\n+  \"\\\n     %{mno-fdpic:-mnopic} %{mfdpic}\"\n \n-#define LINK_SPEC \"\\\n+#define LINK_SPEC                                                              \\\n+  \"\\\n %{h*} %{v:-V} \\\n %{mfdpic:-melf32bfinfd -z text} \\\n %{static:-dn -Bstatic} \\\n@@ -220,7 +255,7 @@\n -init __init -fini __fini \"\n \n /* Generate DSP instructions, like DSP halfword loads */\n-#define TARGET_DSP\t\t\t(1)\n+#define TARGET_DSP (1)\n \n #define TARGET_DEFAULT 0\n \n@@ -229,8 +264,8 @@\n \n extern const char *bfin_library_id_string;\n \n-#define FUNCTION_MODE    SImode\n-#define Pmode            SImode\n+#define FUNCTION_MODE SImode\n+#define Pmode SImode\n \n /* store-condition-codes instructions store 0 for false\n    This is the value stored for true.  */\n@@ -273,7 +308,7 @@ extern const char *bfin_library_id_string;\n \n #define FDPIC_FPTR_REGNO REG_P1\n #define FDPIC_REGNO REG_P3\n-#define OUR_FDPIC_REG\tget_hard_reg_initial_val (SImode, FDPIC_REGNO)\n+#define OUR_FDPIC_REG get_hard_reg_initial_val (SImode, FDPIC_REGNO)\n \n /* A static chain register for nested functions.  We need to use a\n    call-clobbered register for this.  */\n@@ -295,10 +330,10 @@ extern const char *bfin_library_id_string;\n /* Define this if the above stack space is to be considered part of the\n  * space allocated by the caller.  */\n #define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1\n-\t  \n+\n /* Define this if the maximum size of all the outgoing args is to be\n    accumulated and pushed during the prologue.  The amount can be\n-   found in the variable crtl->outgoing_args_size. */ \n+   found in the variable crtl->outgoing_args_size. */\n #define ACCUMULATE_OUTGOING_ARGS 1\n \n /*#define DATA_ALIGNMENT(TYPE, BASIC-ALIGN) for arrays.. */\n@@ -316,7 +351,7 @@ extern const char *bfin_library_id_string;\n #define LOCAL_ALIGNMENT(TYPE, ALIGN) bfin_local_alignment ((TYPE), (ALIGN))\n \n #define TRAMPOLINE_SIZE (TARGET_FDPIC ? 30 : 18)\n-\f\n+\n /* Definitions for register eliminations.\n \n    This is an array of structures.  Each structure initializes one pair\n@@ -330,17 +365,21 @@ extern const char *bfin_library_id_string;\n    circumstances.  The hard frame pointer is not used before reload and\n    so it is not eligible for elimination.  */\n \n-#define ELIMINABLE_REGS\t\t\t\t\\\n-{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n- { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\\\n- { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\t\\\n+#define ELIMINABLE_REGS                                                        \\\n+  {                                                                            \\\n+    {ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},                                \\\n+      {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},                              \\\n+    {                                                                          \\\n+      FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM                               \\\n+    }                                                                          \\\n+  }\n \n /* Define the offset between two registers, one to be eliminated, and the other\n    its replacement, at the start of a routine.  */\n \n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)                           \\\n   ((OFFSET) = bfin_initial_elimination_offset ((FROM), (TO)))\n-\f\n+\n /* This processor has\n    8 data register for doing arithmetic\n    8  pointer register for doing addressing, including\n@@ -363,50 +402,54 @@ extern const char *bfin_library_id_string;\n #define IREG_P(X) (REG_P (X) && I_REGNO_P (REGNO (X)))\n #define DPREG_P(X) (REG_P (X) && DP_REGNO_P (REGNO (X)))\n \n-#define REGISTER_NAMES { \\\n-  \"R0\", \"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\", \\\n-  \"P0\", \"P1\", \"P2\", \"P3\", \"P4\", \"P5\", \"SP\", \"FP\", \\\n-  \"I0\", \"I1\", \"I2\", \"I3\", \"B0\", \"B1\", \"B2\", \"B3\", \\\n-  \"L0\", \"L1\", \"L2\", \"L3\", \"M0\", \"M1\", \"M2\", \"M3\", \\\n-  \"A0\", \"A1\", \\\n-  \"CC\", \\\n-  \"RETS\", \"RETI\", \"RETX\", \"RETN\", \"RETE\", \"ASTAT\", \"SEQSTAT\", \"USP\", \\\n-  \"ARGP\", \\\n-  \"LT0\", \"LT1\", \"LC0\", \"LC1\", \"LB0\", \"LB1\" \\\n-}\n-\n-#define SHORT_REGISTER_NAMES { \\\n-\t\"R0.L\",\t\"R1.L\",\t\"R2.L\",\t\"R3.L\", \"R4.L\", \"R5.L\", \"R6.L\", \"R7.L\", \\\n-\t\"P0.L\",\t\"P1.L\",\t\"P2.L\",\t\"P3.L\", \"P4.L\", \"P5.L\", \"SP.L\", \"FP.L\", \\\n-\t\"I0.L\",\t\"I1.L\", \"I2.L\",\t\"I3.L\",\t\"B0.L\",\t\"B1.L\",\t\"B2.L\",\t\"B3.L\", \\\n-\t\"L0.L\",\t\"L1.L\",\t\"L2.L\",\t\"L3.L\",\t\"M0.L\",\t\"M1.L\",\t\"M2.L\",\t\"M3.L\", }\n-\n-#define HIGH_REGISTER_NAMES { \\\n-\t\"R0.H\",\t\"R1.H\",\t\"R2.H\",\t\"R3.H\", \"R4.H\", \"R5.H\", \"R6.H\", \"R7.H\", \\\n-\t\"P0.H\",\t\"P1.H\",\t\"P2.H\",\t\"P3.H\", \"P4.H\", \"P5.H\", \"SP.H\", \"FP.H\", \\\n-\t\"I0.H\",\t\"I1.H\",\t\"I2.H\",\t\"I3.H\",\t\"B0.H\",\t\"B1.H\",\t\"B2.H\",\t\"B3.H\", \\\n-\t\"L0.H\",\t\"L1.H\",\t\"L2.H\",\t\"L3.H\",\t\"M0.H\",\t\"M1.H\",\t\"M2.H\",\t\"M3.H\", }\n-\n-#define DREGS_PAIR_NAMES { \\\n-  \"R1:0.p\", 0, \"R3:2.p\", 0, \"R5:4.p\", 0, \"R7:6.p\", 0,  }\n-\n-#define BYTE_REGISTER_NAMES { \\\n-  \"R0.B\", \"R1.B\", \"R2.B\", \"R3.B\", \"R4.B\", \"R5.B\", \"R6.B\", \"R7.B\",  }\n-\n+#define REGISTER_NAMES                                                         \\\n+  {                                                                            \\\n+    \"R0\", \"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\", \"P0\", \"P1\", \"P2\", \"P3\",    \\\n+      \"P4\", \"P5\", \"SP\", \"FP\", \"I0\", \"I1\", \"I2\", \"I3\", \"B0\", \"B1\", \"B2\", \"B3\",  \\\n+      \"L0\", \"L1\", \"L2\", \"L3\", \"M0\", \"M1\", \"M2\", \"M3\", \"A0\", \"A1\", \"CC\",        \\\n+      \"RETS\", \"RETI\", \"RETX\", \"RETN\", \"RETE\", \"ASTAT\", \"SEQSTAT\", \"USP\",       \\\n+      \"ARGP\", \"LT0\", \"LT1\", \"LC0\", \"LC1\", \"LB0\", \"LB1\"                         \\\n+  }\n+\n+#define SHORT_REGISTER_NAMES                                                   \\\n+  {                                                                            \\\n+    \"R0.L\", \"R1.L\", \"R2.L\", \"R3.L\", \"R4.L\", \"R5.L\", \"R6.L\", \"R7.L\", \"P0.L\",    \\\n+      \"P1.L\", \"P2.L\", \"P3.L\", \"P4.L\", \"P5.L\", \"SP.L\", \"FP.L\", \"I0.L\", \"I1.L\",  \\\n+      \"I2.L\", \"I3.L\", \"B0.L\", \"B1.L\", \"B2.L\", \"B3.L\", \"L0.L\", \"L1.L\", \"L2.L\",  \\\n+      \"L3.L\", \"M0.L\", \"M1.L\", \"M2.L\", \"M3.L\",                                  \\\n+  }\n+\n+#define HIGH_REGISTER_NAMES                                                    \\\n+  {                                                                            \\\n+    \"R0.H\", \"R1.H\", \"R2.H\", \"R3.H\", \"R4.H\", \"R5.H\", \"R6.H\", \"R7.H\", \"P0.H\",    \\\n+      \"P1.H\", \"P2.H\", \"P3.H\", \"P4.H\", \"P5.H\", \"SP.H\", \"FP.H\", \"I0.H\", \"I1.H\",  \\\n+      \"I2.H\", \"I3.H\", \"B0.H\", \"B1.H\", \"B2.H\", \"B3.H\", \"L0.H\", \"L1.H\", \"L2.H\",  \\\n+      \"L3.H\", \"M0.H\", \"M1.H\", \"M2.H\", \"M3.H\",                                  \\\n+  }\n+\n+#define DREGS_PAIR_NAMES                                                       \\\n+  {                                                                            \\\n+    \"R1:0.p\", 0, \"R3:2.p\", 0, \"R5:4.p\", 0, \"R7:6.p\", 0,                        \\\n+  }\n+\n+#define BYTE_REGISTER_NAMES                                                    \\\n+  {                                                                            \\\n+    \"R0.B\", \"R1.B\", \"R2.B\", \"R3.B\", \"R4.B\", \"R5.B\", \"R6.B\", \"R7.B\",            \\\n+  }\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.  */\n \n-#define FIXED_REGISTERS \\\n-/*r0 r1 r2 r3 r4 r5 r6 r7   p0 p1 p2 p3 p4 p5 p6 p7 */ \\\n-{ 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 1, 0,    \\\n-/*i0 i1 i2 i3 b0 b1 b2 b3   l0 l1 l2 l3 m0 m1 m2 m3 */ \\\n-  0, 0, 0, 0, 0, 0, 0, 0,   1, 1, 1, 1, 0, 0, 0, 0,    \\\n-/*a0 a1 cc rets/i/x/n/e     astat seqstat usp argp lt0/1 lc0/1 */ \\\n-  0, 0, 0, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,    \\\n-/*lb0/1 */ \\\n-  1, 1  \\\n-}\n+#define FIXED_REGISTERS                                                        \\\n+  /*r0 r1 r2 r3 r4 r5 r6 r7   p0 p1 p2 p3 p4 p5 p6 p7 */                       \\\n+  {                                                                            \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,                               \\\n+      0, /*i0 i1 i2 i3 b0 b1 b2 b3   l0 l1 l2 l3 m0 m1 m2 m3 */                \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0,                             \\\n+      0, /*a0 a1 cc rets/i/x/n/e     astat seqstat usp argp lt0/1 lc0/1 */     \\\n+      0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /*lb0/1 */               \\\n+      1, 1                                                                     \\\n+  }\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -415,34 +458,32 @@ extern const char *bfin_library_id_string;\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.  */\n \n-#define CALL_USED_REGISTERS \\\n-/*r0 r1 r2 r3 r4 r5 r6 r7   p0 p1 p2 p3 p4 p5 p6 p7 */ \\\n-{ 1, 1, 1, 1, 0, 0, 0, 0,   1, 1, 1, 0, 0, 0, 1, 0, \\\n-/*i0 i1 i2 i3 b0 b1 b2 b3   l0 l1 l2 l3 m0 m1 m2 m3 */ \\\n-  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,   \\\n-/*a0 a1 cc rets/i/x/n/e     astat seqstat usp argp lt0/1 lc0/1 */ \\\n-  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1, \\\n-/*lb0/1 */ \\\n-  1, 1  \\\n-}\n+#define CALL_USED_REGISTERS                                                    \\\n+  /*r0 r1 r2 r3 r4 r5 r6 r7   p0 p1 p2 p3 p4 p5 p6 p7 */                       \\\n+  {                                                                            \\\n+    1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1,                               \\\n+      0, /*i0 i1 i2 i3 b0 b1 b2 b3   l0 l1 l2 l3 m0 m1 m2 m3 */                \\\n+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,                             \\\n+      1, /*a0 a1 cc rets/i/x/n/e     astat seqstat usp argp lt0/1 lc0/1 */     \\\n+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /*lb0/1 */               \\\n+      1, 1                                                                     \\\n+  }\n \n /* Order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.  List frame pointer\n    late and fixed registers last.  Note that, in general, we prefer\n    registers listed in CALL_USED_REGISTERS, keeping the others\n    available for storage of persistent values. */\n \n-#define REG_ALLOC_ORDER \\\n-{ REG_R0, REG_R1, REG_R2, REG_R3, REG_R7, REG_R6, REG_R5, REG_R4, \\\n-  REG_P2, REG_P1, REG_P0, REG_P5, REG_P4, REG_P3, REG_P6, REG_P7, \\\n-  REG_A0, REG_A1, \\\n-  REG_I0, REG_I1, REG_I2, REG_I3, REG_B0, REG_B1, REG_B2, REG_B3, \\\n-  REG_L0, REG_L1, REG_L2, REG_L3, REG_M0, REG_M1, REG_M2, REG_M3, \\\n-  REG_RETS, REG_RETI, REG_RETX, REG_RETN, REG_RETE,\t\t  \\\n-  REG_ASTAT, REG_SEQSTAT, REG_USP, \t\t\t\t  \\\n-  REG_CC, REG_ARGP,\t\t\t\t\t\t  \\\n-  REG_LT0, REG_LT1, REG_LC0, REG_LC1, REG_LB0, REG_LB1\t\t  \\\n-}\n+#define REG_ALLOC_ORDER                                                        \\\n+  {                                                                            \\\n+    REG_R0, REG_R1, REG_R2, REG_R3, REG_R7, REG_R6, REG_R5, REG_R4, REG_P2,    \\\n+      REG_P1, REG_P0, REG_P5, REG_P4, REG_P3, REG_P6, REG_P7, REG_A0, REG_A1,  \\\n+      REG_I0, REG_I1, REG_I2, REG_I3, REG_B0, REG_B1, REG_B2, REG_B3, REG_L0,  \\\n+      REG_L1, REG_L2, REG_L3, REG_M0, REG_M1, REG_M2, REG_M3, REG_RETS,        \\\n+      REG_RETI, REG_RETX, REG_RETN, REG_RETE, REG_ASTAT, REG_SEQSTAT, REG_USP, \\\n+      REG_CC, REG_ARGP, REG_LT0, REG_LT1, REG_LC0, REG_LC1, REG_LB0, REG_LB1   \\\n+  }\n \n /* Define the classes of registers for register constraints in the\n    machine description.  Also define ranges of constants.\n@@ -464,15 +505,15 @@ extern const char *bfin_library_id_string;\n    For any two classes, it is very desirable that there be another\n    class that represents their union. */\n \n-\n enum reg_class\n {\n   NO_REGS,\n   IREGS,\n   BREGS,\n   LREGS,\n   MREGS,\n-  CIRCREGS, /* Circular buffering registers, Ix, Bx, Lx together form.  See Automatic Circular Buffering.  */\n+  CIRCREGS, /* Circular buffering registers, Ix, Bx, Lx together form.  See\n+\t       Automatic Circular Buffering.  */\n   DAGREGS,\n   EVEN_AREGS,\n   ODD_AREGS,\n@@ -502,52 +543,25 @@ enum reg_class\n   LB_REGS,\n   PROLOGUE_REGS,\n   NON_A_CC_REGS,\n-  ALL_REGS, LIM_REG_CLASSES\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n };\n \n-#define N_REG_CLASSES ((int)LIM_REG_CLASSES)\n+#define N_REG_CLASSES ((int) LIM_REG_CLASSES)\n \n #define GENERAL_REGS DPREGS\n \n /* Give names of register classes as strings for dump file.   */\n \n-#define REG_CLASS_NAMES \\\n-{  \"NO_REGS\",\t\t\\\n-   \"IREGS\",\t\t\\\n-   \"BREGS\",\t\t\\\n-   \"LREGS\",\t\t\\\n-   \"MREGS\",\t\t\\\n-   \"CIRCREGS\",\t\t\\\n-   \"DAGREGS\",\t\t\\\n-   \"EVEN_AREGS\",\t\\\n-   \"ODD_AREGS\",\t\t\\\n-   \"AREGS\",\t\t\\\n-   \"CCREGS\",\t\t\\\n-   \"EVEN_DREGS\",\t\\\n-   \"ODD_DREGS\",\t\t\\\n-   \"D0REGS\",\t\t\\\n-   \"D1REGS\",\t\t\\\n-   \"D2REGS\",\t\t\\\n-   \"D3REGS\",\t\t\\\n-   \"D4REGS\",\t\t\\\n-   \"D5REGS\",\t\t\\\n-   \"D6REGS\",\t\t\\\n-   \"D7REGS\",\t\t\\\n-   \"DREGS\",\t\t\\\n-   \"P0REGS\",\t\t\\\n-   \"FDPIC_REGS\",\t\\\n-   \"FDPIC_FPTR_REGS\",\t\\\n-   \"PREGS_CLOBBERED\",\t\\\n-   \"PREGS\",\t\t\\\n-   \"IPREGS\",\t\t\\\n-   \"DPREGS\",\t\t\\\n-   \"MOST_REGS\",\t\t\\\n-   \"LT_REGS\",\t\t\\\n-   \"LC_REGS\",\t\t\\\n-   \"LB_REGS\",\t\t\\\n-   \"PROLOGUE_REGS\",\t\\\n-   \"NON_A_CC_REGS\",\t\\\n-   \"ALL_REGS\" }\n+#define REG_CLASS_NAMES                                                        \\\n+  {                                                                            \\\n+    \"NO_REGS\", \"IREGS\", \"BREGS\", \"LREGS\", \"MREGS\", \"CIRCREGS\", \"DAGREGS\",      \\\n+      \"EVEN_AREGS\", \"ODD_AREGS\", \"AREGS\", \"CCREGS\", \"EVEN_DREGS\", \"ODD_DREGS\", \\\n+      \"D0REGS\", \"D1REGS\", \"D2REGS\", \"D3REGS\", \"D4REGS\", \"D5REGS\", \"D6REGS\",    \\\n+      \"D7REGS\", \"DREGS\", \"P0REGS\", \"FDPIC_REGS\", \"FDPIC_FPTR_REGS\",            \\\n+      \"PREGS_CLOBBERED\", \"PREGS\", \"IPREGS\", \"DPREGS\", \"MOST_REGS\", \"LT_REGS\",  \\\n+      \"LC_REGS\", \"LB_REGS\", \"PROLOGUE_REGS\", \"NON_A_CC_REGS\", \"ALL_REGS\"       \\\n+  }\n \n /* An initializer containing the contents of the register classes, as integers\n    which are bit masks.  The Nth integer specifies the contents of class N.\n@@ -563,102 +577,145 @@ enum reg_class\n /* NOTE: DSP registers, IREGS - AREGS, are not GENERAL_REGS.  We use\n    MOST_REGS as the union of DPREGS and DAGREGS.  */\n \n-#define REG_CLASS_CONTENTS \\\n-    /* 31 - 0       63-32   */ \\\n-{   { 0x00000000,    0 },\t\t/* NO_REGS */\t\\\n-    { 0x000f0000,    0 },\t\t/* IREGS */\t\\\n-    { 0x00f00000,    0 },\t\t/* BREGS */\t\t\\\n-    { 0x0f000000,    0 },\t\t/* LREGS */\t\\\n-    { 0xf0000000,    0 },\t\t/* MREGS */   \\\n-    { 0x0fff0000,    0 },\t\t/* CIRCREGS */   \\\n-    { 0xffff0000,    0 },\t\t/* DAGREGS */   \\\n-    { 0x00000000,    0x1 },\t\t/* EVEN_AREGS */   \\\n-    { 0x00000000,    0x2 },\t\t/* ODD_AREGS */   \\\n-    { 0x00000000,    0x3 },\t\t/* AREGS */   \\\n-    { 0x00000000,    0x4 },\t\t/* CCREGS */  \\\n-    { 0x00000055,    0 },\t\t/* EVEN_DREGS */   \\\n-    { 0x000000aa,    0 },\t\t/* ODD_DREGS */   \\\n-    { 0x00000001,    0 },\t\t/* D0REGS */   \\\n-    { 0x00000002,    0 },\t\t/* D1REGS */   \\\n-    { 0x00000004,    0 },\t\t/* D2REGS */   \\\n-    { 0x00000008,    0 },\t\t/* D3REGS */   \\\n-    { 0x00000010,    0 },\t\t/* D4REGS */   \\\n-    { 0x00000020,    0 },\t\t/* D5REGS */   \\\n-    { 0x00000040,    0 },\t\t/* D6REGS */   \\\n-    { 0x00000080,    0 },\t\t/* D7REGS */   \\\n-    { 0x000000ff,    0 },\t\t/* DREGS */   \\\n-    { 0x00000100,    0x000 },\t\t/* P0REGS */   \\\n-    { 0x00000800,    0x000 },\t\t/* FDPIC_REGS */   \\\n-    { 0x00000200,    0x000 },\t\t/* FDPIC_FPTR_REGS */   \\\n-    { 0x00004700,    0x800 },\t\t/* PREGS_CLOBBERED */   \\\n-    { 0x0000ff00,    0x800 },\t\t/* PREGS */   \\\n-    { 0x000fff00,    0x800 },\t\t/* IPREGS */\t\\\n-    { 0x0000ffff,    0x800 },\t\t/* DPREGS */   \\\n-    { 0xffffffff,    0x800 },\t\t/* MOST_REGS */\\\n-    { 0x00000000,    0x3000 },\t\t/* LT_REGS */\\\n-    { 0x00000000,    0xc000 },\t\t/* LC_REGS */\\\n-    { 0x00000000,    0x30000 },\t\t/* LB_REGS */\\\n-    { 0x00000000,    0x3f7f8 },\t\t/* PROLOGUE_REGS */\\\n-    { 0xffffffff,    0x3fff8 },\t\t/* NON_A_CC_REGS */\\\n-    { 0xffffffff,    0x3ffff }}\t\t/* ALL_REGS */\n-\n-#define IREG_POSSIBLE_P(OUTER)\t\t\t\t     \\\n-  ((OUTER) == POST_INC || (OUTER) == PRE_INC\t\t     \\\n-   || (OUTER) == POST_DEC || (OUTER) == PRE_DEC\t\t     \\\n-   || (OUTER) == MEM || (OUTER) == ADDRESS)\n-\n-#define MODE_CODE_BASE_REG_CLASS(MODE, AS, OUTER, INDEX)\t\\\n+#define REG_CLASS_CONTENTS                                                     \\\n+  /* 31 - 0       63-32   */                                                   \\\n+  {                                                                            \\\n+    {0x00000000, 0},\t     /* NO_REGS */                                     \\\n+      {0x000f0000, 0},\t     /* IREGS */                                       \\\n+      {0x00f00000, 0},\t     /* BREGS */                                       \\\n+      {0x0f000000, 0},\t     /* LREGS */                                       \\\n+      {0xf0000000, 0},\t     /* MREGS */                                       \\\n+      {0x0fff0000, 0},\t     /* CIRCREGS */                                    \\\n+      {0xffff0000, 0},\t     /* DAGREGS */                                     \\\n+      {0x00000000, 0x1},     /* EVEN_AREGS */                                  \\\n+      {0x00000000, 0x2},     /* ODD_AREGS */                                   \\\n+      {0x00000000, 0x3},     /* AREGS */                                       \\\n+      {0x00000000, 0x4},     /* CCREGS */                                      \\\n+      {0x00000055, 0},\t     /* EVEN_DREGS */                                  \\\n+      {0x000000aa, 0},\t     /* ODD_DREGS */                                   \\\n+      {0x00000001, 0},\t     /* D0REGS */                                      \\\n+      {0x00000002, 0},\t     /* D1REGS */                                      \\\n+      {0x00000004, 0},\t     /* D2REGS */                                      \\\n+      {0x00000008, 0},\t     /* D3REGS */                                      \\\n+      {0x00000010, 0},\t     /* D4REGS */                                      \\\n+      {0x00000020, 0},\t     /* D5REGS */                                      \\\n+      {0x00000040, 0},\t     /* D6REGS */                                      \\\n+      {0x00000080, 0},\t     /* D7REGS */                                      \\\n+      {0x000000ff, 0},\t     /* DREGS */                                       \\\n+      {0x00000100, 0x000},   /* P0REGS */                                      \\\n+      {0x00000800, 0x000},   /* FDPIC_REGS */                                  \\\n+      {0x00000200, 0x000},   /* FDPIC_FPTR_REGS */                             \\\n+      {0x00004700, 0x800},   /* PREGS_CLOBBERED */                             \\\n+      {0x0000ff00, 0x800},   /* PREGS */                                       \\\n+      {0x000fff00, 0x800},   /* IPREGS */                                      \\\n+      {0x0000ffff, 0x800},   /* DPREGS */                                      \\\n+      {0xffffffff, 0x800},   /* MOST_REGS */                                   \\\n+      {0x00000000, 0x3000},  /* LT_REGS */                                     \\\n+      {0x00000000, 0xc000},  /* LC_REGS */                                     \\\n+      {0x00000000, 0x30000}, /* LB_REGS */                                     \\\n+      {0x00000000, 0x3f7f8}, /* PROLOGUE_REGS */                               \\\n+      {0xffffffff, 0x3fff8}, /* NON_A_CC_REGS */                               \\\n+    {                                                                          \\\n+      0xffffffff, 0x3ffff                                                      \\\n+    }                                                                          \\\n+  } /* ALL_REGS */\n+\n+#define IREG_POSSIBLE_P(OUTER)                                                 \\\n+  ((OUTER) == POST_INC || (OUTER) == PRE_INC || (OUTER) == POST_DEC            \\\n+   || (OUTER) == PRE_DEC || (OUTER) == MEM || (OUTER) == ADDRESS)\n+\n+#define MODE_CODE_BASE_REG_CLASS(MODE, AS, OUTER, INDEX)                       \\\n   ((MODE) == HImode && IREG_POSSIBLE_P (OUTER) ? IPREGS : PREGS)\n \n-#define INDEX_REG_CLASS         PREGS\n+#define INDEX_REG_CLASS PREGS\n \n-#define REGNO_OK_FOR_BASE_STRICT_P(X, MODE, OUTER, INDEX)\t\\\n-  (P_REGNO_P (X) || (X) == REG_ARGP\t\t\t\t\\\n-   || (IREG_POSSIBLE_P (OUTER) && (MODE) == HImode\t\t\\\n-       && I_REGNO_P (X)))\n+#define REGNO_OK_FOR_BASE_STRICT_P(X, MODE, OUTER, INDEX)                      \\\n+  (P_REGNO_P (X) || (X) == REG_ARGP                                            \\\n+   || (IREG_POSSIBLE_P (OUTER) && (MODE) == HImode && I_REGNO_P (X)))\n \n-#define REGNO_OK_FOR_BASE_NONSTRICT_P(X, MODE, OUTER, INDEX)\t\\\n-  ((X) >= FIRST_PSEUDO_REGISTER\t\t\t\t\t\\\n+#define REGNO_OK_FOR_BASE_NONSTRICT_P(X, MODE, OUTER, INDEX)                   \\\n+  ((X) >= FIRST_PSEUDO_REGISTER                                                \\\n    || REGNO_OK_FOR_BASE_STRICT_P (X, MODE, OUTER, INDEX))\n \n #ifdef REG_OK_STRICT\n-#define REGNO_MODE_CODE_OK_FOR_BASE_P(X, MODE, AS, OUTER, INDEX) \\\n+#define REGNO_MODE_CODE_OK_FOR_BASE_P(X, MODE, AS, OUTER, INDEX)               \\\n   REGNO_OK_FOR_BASE_STRICT_P (X, MODE, OUTER, INDEX)\n #else\n-#define REGNO_MODE_CODE_OK_FOR_BASE_P(X, MODE, AS, OUTER, INDEX) \\\n+#define REGNO_MODE_CODE_OK_FOR_BASE_P(X, MODE, AS, OUTER, INDEX)               \\\n   REGNO_OK_FOR_BASE_NONSTRICT_P (X, MODE, OUTER, INDEX)\n #endif\n \n-#define REGNO_OK_FOR_INDEX_P(X)   0\n+#define REGNO_OK_FOR_INDEX_P(X) 0\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n \n-#define REGNO_REG_CLASS(REGNO) \\\n-((REGNO) == REG_R0 ? D0REGS\t\t\t\t\\\n- : (REGNO) == REG_R1 ? D1REGS\t\t\t\t\\\n- : (REGNO) == REG_R2 ? D2REGS\t\t\t\t\\\n- : (REGNO) == REG_R3 ? D3REGS\t\t\t\t\\\n- : (REGNO) == REG_R4 ? D4REGS\t\t\t\t\\\n- : (REGNO) == REG_R5 ? D5REGS\t\t\t\t\\\n- : (REGNO) == REG_R6 ? D6REGS\t\t\t\t\\\n- : (REGNO) == REG_R7 ? D7REGS\t\t\t\t\\\n- : (REGNO) == REG_P0 ? P0REGS\t\t\t\t\\\n- : (REGNO) < REG_I0 ? PREGS\t\t\t\t\\\n- : (REGNO) == REG_ARGP ? PREGS\t\t\t\t\\\n- : (REGNO) >= REG_I0 && (REGNO) <= REG_I3 ? IREGS\t\\\n- : (REGNO) >= REG_L0 && (REGNO) <= REG_L3 ? LREGS\t\\\n- : (REGNO) >= REG_B0 && (REGNO) <= REG_B3 ? BREGS\t\\\n- : (REGNO) >= REG_M0 && (REGNO) <= REG_M3 ? MREGS\t\\\n- : (REGNO) == REG_A0 || (REGNO) == REG_A1 ? AREGS\t\\\n- : (REGNO) == REG_LT0 || (REGNO) == REG_LT1 ? LT_REGS\t\\\n- : (REGNO) == REG_LC0 || (REGNO) == REG_LC1 ? LC_REGS\t\\\n- : (REGNO) == REG_LB0 || (REGNO) == REG_LB1 ? LB_REGS\t\\\n- : (REGNO) == REG_CC ? CCREGS\t\t\t\t\\\n- : (REGNO) >= REG_RETS ? PROLOGUE_REGS\t\t\t\\\n- : NO_REGS)\n+#define REGNO_REG_CLASS(REGNO)                                                                       \\\n+  ((REGNO) == REG_R0                                                                                 \\\n+     ? D0REGS                                                                                        \\\n+     : (REGNO) == REG_R1                                                                             \\\n+\t ? D1REGS                                                                                    \\\n+\t : (REGNO) == REG_R2                                                                         \\\n+\t     ? D2REGS                                                                                \\\n+\t     : (REGNO) == REG_R3                                                                     \\\n+\t\t ? D3REGS                                                                            \\\n+\t\t : (REGNO) == REG_R4                                                                 \\\n+\t\t     ? D4REGS                                                                        \\\n+\t\t     : (REGNO) == REG_R5                                                             \\\n+\t\t\t ? D5REGS                                                                    \\\n+\t\t\t : (REGNO) == REG_R6                                                         \\\n+\t\t\t     ? D6REGS                                                                \\\n+\t\t\t     : (REGNO) == REG_R7                                                     \\\n+\t\t\t\t ? D7REGS                                                            \\\n+\t\t\t\t : (REGNO) == REG_P0                                                 \\\n+\t\t\t\t     ? P0REGS                                                        \\\n+\t\t\t\t     : (REGNO) < REG_I0                                              \\\n+\t\t\t\t\t ? PREGS                                                     \\\n+\t\t\t\t\t : (REGNO) == REG_ARGP                                       \\\n+\t\t\t\t\t     ? PREGS                                                 \\\n+\t\t\t\t\t     : (REGNO) >= REG_I0                                     \\\n+\t\t\t\t\t\t   && (REGNO) <= REG_I3                              \\\n+\t\t\t\t\t\t ? IREGS                                             \\\n+\t\t\t\t\t\t : (REGNO) >= REG_L0                                 \\\n+\t\t\t\t\t\t       && (REGNO) <= REG_L3                          \\\n+\t\t\t\t\t\t     ? LREGS                                         \\\n+\t\t\t\t\t\t     : (REGNO) >= REG_B0                             \\\n+\t\t\t\t\t\t\t   && (REGNO)                                \\\n+\t\t\t\t\t\t\t\t<= REG_B3                            \\\n+\t\t\t\t\t\t\t ? BREGS                                     \\\n+\t\t\t\t\t\t\t : (REGNO) >= REG_M0                         \\\n+\t\t\t\t\t\t\t       && (REGNO)                            \\\n+\t\t\t\t\t\t\t\t    <= REG_M3                        \\\n+\t\t\t\t\t\t\t     ? MREGS                                 \\\n+\t\t\t\t\t\t\t     : (REGNO)                               \\\n+\t\t\t\t\t\t\t\t     == REG_A0                       \\\n+\t\t\t\t\t\t\t\t   || (REGNO)                        \\\n+\t\t\t\t\t\t\t\t\t== REG_A1                    \\\n+\t\t\t\t\t\t\t\t ? AREGS                             \\\n+\t\t\t\t\t\t\t\t : (REGNO)                           \\\n+\t\t\t\t\t\t\t\t\t == REG_LT0                  \\\n+\t\t\t\t\t\t\t\t       || (REGNO)                    \\\n+\t\t\t\t\t\t\t\t\t    == REG_LT1               \\\n+\t\t\t\t\t\t\t\t     ? LT_REGS                       \\\n+\t\t\t\t\t\t\t\t     : (REGNO)                       \\\n+\t\t\t\t\t\t\t\t\t     == REG_LC0              \\\n+\t\t\t\t\t\t\t\t\t   || (REGNO)                \\\n+\t\t\t\t\t\t\t\t\t\t== REG_LC1           \\\n+\t\t\t\t\t\t\t\t\t ? LC_REGS                   \\\n+\t\t\t\t\t\t\t\t\t : (REGNO)                   \\\n+\t\t\t\t\t\t\t\t\t\t == REG_LB0          \\\n+\t\t\t\t\t\t\t\t\t       || (REGNO)            \\\n+\t\t\t\t\t\t\t\t\t\t    == REG_LB1       \\\n+\t\t\t\t\t\t\t\t\t     ? LB_REGS               \\\n+\t\t\t\t\t\t\t\t\t     : (REGNO)               \\\n+\t\t\t\t\t\t\t\t\t\t   == REG_CC         \\\n+\t\t\t\t\t\t\t\t\t\t ? CCREGS            \\\n+\t\t\t\t\t\t\t\t\t\t : (REGNO)           \\\n+\t\t\t\t\t\t\t\t\t\t       >= REG_RETS   \\\n+\t\t\t\t\t\t\t\t\t\t     ? PROLOGUE_REGS \\\n+\t\t\t\t\t\t\t\t\t\t     : NO_REGS)\n \n /* When this hook returns true for MODE, the compiler allows\n    registers explicitly used in the rtl to be used as spill registers\n@@ -668,9 +725,10 @@ enum reg_class\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n-  ((MODE) == V2PDImode && (CLASS) == AREGS ? 2\t\t\t\t\\\n-   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+#define CLASS_MAX_NREGS(CLASS, MODE)                                           \\\n+  ((MODE) == V2PDImode && (CLASS) == AREGS                                     \\\n+     ? 2                                                                       \\\n+     : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n /* A C expression that is nonzero if hard register TO can be\n    considered for use as a rename register for FROM register */\n@@ -681,41 +739,52 @@ enum reg_class\n    class to use when it is necessary to copy value X into a register\n    in class CLASS.  The value is a register class; perhaps CLASS, or\n    perhaps another, smaller class.  */\n-#define PREFERRED_RELOAD_CLASS(X, CLASS)\t\t\\\n-  (GET_CODE (X) == POST_INC\t\t\t\t\\\n-   || GET_CODE (X) == POST_DEC\t\t\t\t\\\n-   || GET_CODE (X) == PRE_DEC ? PREGS : (CLASS))\n+#define PREFERRED_RELOAD_CLASS(X, CLASS)                                       \\\n+  (GET_CODE (X) == POST_INC || GET_CODE (X) == POST_DEC                        \\\n+       || GET_CODE (X) == PRE_DEC                                              \\\n+     ? PREGS                                                                   \\\n+     : (CLASS))\n \n /* Function Calling Conventions. */\n \n /* The type of the current function; normal functions are of type\n    SUBROUTINE.  */\n-typedef enum {\n-  SUBROUTINE, INTERRUPT_HANDLER, EXCPT_HANDLER, NMI_HANDLER\n+typedef enum\n+{\n+  SUBROUTINE,\n+  INTERRUPT_HANDLER,\n+  EXCPT_HANDLER,\n+  NMI_HANDLER\n } e_funkind;\n-#define FUNCTION_RETURN_REGISTERS { REG_RETS, REG_RETI, REG_RETX, REG_RETN }\n+#define FUNCTION_RETURN_REGISTERS                                              \\\n+  {                                                                            \\\n+    REG_RETS, REG_RETI, REG_RETX, REG_RETN                                     \\\n+  }\n \n-#define FUNCTION_ARG_REGISTERS { REG_R0, REG_R1, REG_R2, -1 }\n+#define FUNCTION_ARG_REGISTERS                                                 \\\n+  {                                                                            \\\n+    REG_R0, REG_R1, REG_R2, -1                                                 \\\n+  }\n \n /* Flags for the call/call_value rtl operations set up by function_arg */\n-#define CALL_NORMAL\t\t0x00000000\t/* no special processing */\n-#define CALL_LONG\t\t0x00000001\t/* always call indirect */\n-#define CALL_SHORT\t\t0x00000002\t/* always call by symbol */\n-\n-typedef struct {\n-  int words;\t\t\t/* # words passed so far */\n-  int nregs;\t\t\t/* # registers available for passing */\n-  int *arg_regs;\t\t/* array of register -1 terminated */\n-  int call_cookie;\t\t/* Do special things for this call */\n+#define CALL_NORMAL 0x00000000 /* no special processing */\n+#define CALL_LONG 0x00000001   /* always call indirect */\n+#define CALL_SHORT 0x00000002  /* always call by symbol */\n+\n+typedef struct\n+{\n+  int words;\t   /* # words passed so far */\n+  int nregs;\t   /* # registers available for passing */\n+  int *arg_regs;   /* array of register -1 terminated */\n+  int call_cookie; /* Do special things for this call */\n } CUMULATIVE_ARGS;\n \n #define FUNCTION_ARG_REGNO_P(REGNO) function_arg_regno_p (REGNO)\n \n-\n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.  */\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT, N_NAMED_ARGS)\t\\\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS)     \\\n   (init_cumulative_args (&CUM, FNTYPE, LIBNAME))\n \n /* Define how to find the value returned by a function.\n@@ -726,14 +795,13 @@ typedef struct {\n \n #define VALUE_REGNO(MODE) (REG_R0)\n \n-#define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE),\t\t\\\n-\t       VALUE_REGNO(TYPE_MODE(VALTYPE)))\n+#define FUNCTION_VALUE(VALTYPE, FUNC)                                          \\\n+  gen_rtx_REG (TYPE_MODE (VALTYPE), VALUE_REGNO (TYPE_MODE (VALTYPE)))\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, VALUE_REGNO(MODE))\n+#define LIBCALL_VALUE(MODE) gen_rtx_REG (MODE, VALUE_REGNO (MODE))\n \n #define FUNCTION_VALUE_REGNO_P(N) ((N) == REG_R0)\n \n@@ -750,11 +818,11 @@ typedef struct {\n #define INCOMING_FRAME_SP_OFFSET 0\n \n /* Describe how we implement __builtin_eh_return.  */\n-#define EH_RETURN_DATA_REGNO(N)\t((N) < 2 ? (N) : INVALID_REGNUM)\n-#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, REG_P2)\n-#define EH_RETURN_HANDLER_RTX \\\n-  gen_frame_mem (Pmode, plus_constant (Pmode, frame_pointer_rtx, \\\n-\t\t\t\t       UNITS_PER_WORD))\n+#define EH_RETURN_DATA_REGNO(N) ((N) < 2 ? (N) : INVALID_REGNUM)\n+#define EH_RETURN_STACKADJ_RTX gen_rtx_REG (Pmode, REG_P2)\n+#define EH_RETURN_HANDLER_RTX                                                  \\\n+  gen_frame_mem (Pmode,                                                        \\\n+\t\t plus_constant (Pmode, frame_pointer_rtx, UNITS_PER_WORD))\n \n /* Addressing Modes */\n \n@@ -764,12 +832,12 @@ typedef struct {\n      would ever accept. */\n #define MAX_REGS_PER_ADDRESS 1\n \n-#define LEGITIMATE_MODE_FOR_AUTOINC_P(MODE) \\\n-      (GET_MODE_SIZE (MODE) <= 4 || (MODE) == PDImode)\n+#define LEGITIMATE_MODE_FOR_AUTOINC_P(MODE)                                    \\\n+  (GET_MODE_SIZE (MODE) <= 4 || (MODE) == PDImode)\n \n #define HAVE_POST_INCREMENT 1\n #define HAVE_POST_DECREMENT 1\n-#define HAVE_PRE_DECREMENT  1\n+#define HAVE_PRE_DECREMENT 1\n \n /* `LEGITIMATE_PIC_OPERAND_P (X)'\n      A C expression that is nonzero if X is a legitimate immediate\n@@ -779,12 +847,11 @@ typedef struct {\n      not check it either.  You need not define this macro if all\n      constants (including `SYMBOL_REF') can be immediate operands when\n      generating position independent code. */\n-#define LEGITIMATE_PIC_OPERAND_P(X) ! SYMBOLIC_CONST (X)\n+#define LEGITIMATE_PIC_OPERAND_P(X) !SYMBOLIC_CONST (X)\n \n-#define SYMBOLIC_CONST(X)\t\\\n-(GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\t\\\n- || GET_CODE (X) == LABEL_REF\t\t\t\t\t\t\\\n- || (GET_CODE (X) == CONST && symbolic_reference_mentioned_p (X)))\n+#define SYMBOLIC_CONST(X)                                                      \\\n+  (GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == LABEL_REF                     \\\n+   || (GET_CODE (X) == CONST && symbolic_reference_mentioned_p (X)))\n \n #define NOTICE_UPDATE_CC(EXPR, INSN) 0\n \n@@ -811,12 +878,12 @@ typedef struct {\n    preferable since it may eliminate subsequent memory access if\n    subsequent accesses occur to other fields in the same word of the\n    structure, but to different bytes.  */\n-#define SLOW_BYTE_ACCESS  0\n+#define SLOW_BYTE_ACCESS 0\n #define SLOW_SHORT_ACCESS 0\n \n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields. */\n-#define BITS_BIG_ENDIAN  0\n+#define BITS_BIG_ENDIAN 0\n \n /* Define this if most significant byte of a word is the lowest numbered.\n    We can't access bytes but if we could we would in the Big Endian order. */\n@@ -865,24 +932,22 @@ typedef struct {\n  *  really cause some alignment problem\n  */\n \n-#define UNITS_PER_FLOAT  ((FLOAT_TYPE_SIZE  + BITS_PER_UNIT - 1) / \\\n-\t\t\t   BITS_PER_UNIT)\n-\n-#define UNITS_PER_DOUBLE ((DOUBLE_TYPE_SIZE + BITS_PER_UNIT - 1) / \\\n- \t\t\t   BITS_PER_UNIT)\n+#define UNITS_PER_FLOAT ((FLOAT_TYPE_SIZE + BITS_PER_UNIT - 1) / BITS_PER_UNIT)\n \n+#define UNITS_PER_DOUBLE                                                       \\\n+  ((DOUBLE_TYPE_SIZE + BITS_PER_UNIT - 1) / BITS_PER_UNIT)\n \n /* what is the 'type' of size_t */\n #define SIZE_TYPE \"long unsigned int\"\n \n /* Define this as 1 if `char' should by default be signed; else as 0.  */\n #define DEFAULT_SIGNED_CHAR 1\n #define FLOAT_TYPE_SIZE BITS_PER_WORD\n-#define SHORT_TYPE_SIZE 16 \n-#define CHAR_TYPE_SIZE\t8\n-#define INT_TYPE_SIZE\t32\n-#define LONG_TYPE_SIZE\t32\n-#define LONG_LONG_TYPE_SIZE 64 \n+#define SHORT_TYPE_SIZE 16\n+#define CHAR_TYPE_SIZE 8\n+#define INT_TYPE_SIZE 32\n+#define LONG_TYPE_SIZE 32\n+#define LONG_LONG_TYPE_SIZE 64\n \n /* Note: Fix this to depend on target switch. -- lev */\n \n@@ -893,8 +958,8 @@ typedef struct {\n  * #define DOUBLES_ARE_FLOATS 1\n  */\n \n-#define DOUBLE_TYPE_SIZE\t64\n-#define LONG_DOUBLE_TYPE_SIZE\t64\n+#define DOUBLE_TYPE_SIZE 64\n+#define LONG_DOUBLE_TYPE_SIZE 64\n \n /* `PROMOTE_MODE (M, UNSIGNEDP, TYPE)'\n      A macro to update M and UNSIGNEDP when an object whose type is\n@@ -919,18 +984,18 @@ typedef struct {\n \n      Do not define this macro if it would never modify M.*/\n \n-#define BFIN_PROMOTE_MODE_P(MODE) \\\n-    (!TARGET_DSP && GET_MODE_CLASS (MODE) == MODE_INT\t\\\n-      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\n-\n-#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)     \\\n-  if (BFIN_PROMOTE_MODE_P(MODE))\t\t\\\n-    {                                           \\\n-      if (MODE == QImode)                       \\\n-        UNSIGNEDP = 1;                          \\\n-      else if (MODE == HImode)                  \\\n-        UNSIGNEDP = 0;      \t\t\t\\\n-      (MODE) = SImode;                          \\\n+#define BFIN_PROMOTE_MODE_P(MODE)                                              \\\n+  (!TARGET_DSP && GET_MODE_CLASS (MODE) == MODE_INT                            \\\n+   && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\n+\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)                                    \\\n+  if (BFIN_PROMOTE_MODE_P (MODE))                                              \\\n+    {                                                                          \\\n+      if (MODE == QImode)                                                      \\\n+\tUNSIGNEDP = 1;                                                         \\\n+      else if (MODE == HImode)                                                 \\\n+\tUNSIGNEDP = 0;                                                         \\\n+      (MODE) = SImode;                                                         \\\n     }\n \n /* Describing Relative Costs of Operations */\n@@ -945,161 +1010,191 @@ typedef struct {\n #define JUMP_TABLES_IN_TEXT_SECTION flag_pic\n \n /* Define if operations between registers always perform the operation\n-   on the full register even if a narrower mode is specified. \n+   on the full register even if a narrower mode is specified.\n #define WORD_REGISTER_OPERATIONS 1\n */\n \n /* Evaluates to true if A and B are mac flags that can be used\n    together in a single multiply insn.  That is the case if they are\n    both the same flag not involving M, or if one is a combination of\n    the other with M.  */\n-#define MACFLAGS_MATCH_P(A, B) \\\n- ((A) == (B) \\\n-  || ((A) == MACFLAG_NONE && (B) == MACFLAG_M) \\\n-  || ((A) == MACFLAG_M && (B) == MACFLAG_NONE) \\\n-  || ((A) == MACFLAG_IS && (B) == MACFLAG_IS_M) \\\n-  || ((A) == MACFLAG_IS_M && (B) == MACFLAG_IS))\n+#define MACFLAGS_MATCH_P(A, B)                                                 \\\n+  ((A) == (B) || ((A) == MACFLAG_NONE && (B) == MACFLAG_M)                     \\\n+   || ((A) == MACFLAG_M && (B) == MACFLAG_NONE)                                \\\n+   || ((A) == MACFLAG_IS && (B) == MACFLAG_IS_M)                               \\\n+   || ((A) == MACFLAG_IS_M && (B) == MACFLAG_IS))\n \n /* Switch into a generic section.  */\n-#define TARGET_ASM_NAMED_SECTION  default_elf_asm_named_section\n+#define TARGET_ASM_NAMED_SECTION default_elf_asm_named_section\n \n-#define PRINT_OPERAND(FILE, RTX, CODE)\t print_operand (FILE, RTX, CODE)\n+#define PRINT_OPERAND(FILE, RTX, CODE) print_operand (FILE, RTX, CODE)\n #define PRINT_OPERAND_ADDRESS(FILE, RTX) print_address_operand (FILE, RTX)\n \n-typedef enum sections {\n-    CODE_DIR,\n-    DATA_DIR,\n-    LAST_SECT_NM\n+typedef enum sections\n+{\n+  CODE_DIR,\n+  DATA_DIR,\n+  LAST_SECT_NM\n } SECT_ENUM_T;\n \n-typedef enum directives {\n-    LONG_CONST_DIR,\n-    SHORT_CONST_DIR,\n-    BYTE_CONST_DIR,\n-    SPACE_DIR,\n-    INIT_DIR,\n-    LAST_DIR_NM\n+typedef enum directives\n+{\n+  LONG_CONST_DIR,\n+  SHORT_CONST_DIR,\n+  BYTE_CONST_DIR,\n+  SPACE_DIR,\n+  INIT_DIR,\n+  LAST_DIR_NM\n } DIR_ENUM_T;\n \n-#define IS_ASM_LOGICAL_LINE_SEPARATOR(C, STR)\t\\\n-  ((C) == ';'\t\t\t\t\t\\\n-   || ((C) == '|' && (STR)[1] == '|'))\n+#define IS_ASM_LOGICAL_LINE_SEPARATOR(C, STR)                                  \\\n+  ((C) == ';' || ((C) == '|' && (STR)[1] == '|'))\n \n #define TEXT_SECTION_ASM_OP \".text;\"\n #define DATA_SECTION_ASM_OP \".data;\"\n \n-#define ASM_APP_ON  \"\"\n+#define ASM_APP_ON \"\"\n #define ASM_APP_OFF \"\"\n \n-#define ASM_GLOBALIZE_LABEL1(FILE, NAME) \\\n-  do {  fputs (\".global \", FILE);\t\t\\\n-        assemble_name (FILE, NAME);\t        \\\n-        fputc (';',FILE);\t\t\t\\\n-        fputc ('\\n',FILE);\t\t\t\\\n-      } while (0)\n-\n-#define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL) \\\n-  do {\t\t\t\t\t\\\n-    fputs (\".type \", FILE);           \t\\\n-    assemble_name (FILE, NAME);         \\\n-    fputs (\", STT_FUNC\", FILE);         \\\n-    fputc (';',FILE);                   \\\n-    fputc ('\\n',FILE);\t\t\t\\\n-    ASM_OUTPUT_LABEL(FILE, NAME);\t\\\n-  } while (0)\n-\n-#define ASM_OUTPUT_LABEL(FILE, NAME)    \\\n-  do {  assemble_name (FILE, NAME);\t\t\\\n-        fputs (\":\\n\",FILE);\t\t\t\\\n-      } while (0)\n-\n-#define ASM_OUTPUT_LABELREF(FILE,NAME) \t\\\n-    do {  fprintf (FILE, \"_%s\", NAME); \\\n-        } while (0)\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)    \t\\\n-do { char __buf[256];\t\t\t\t\t\\\n-     fprintf (FILE, \"\\t.dd\\t\");\t\t\t\t\\\n-     ASM_GENERATE_INTERNAL_LABEL (__buf, \"L\", VALUE);\t\\\n-     assemble_name (FILE, __buf);\t\t\t\\\n-     fputc (';', FILE);\t\t\t\t\t\\\n-     fputc ('\\n', FILE);\t\t\t\t\\\n-   } while (0)\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n-    MY_ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)\n-\n-#define MY_ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)\t\t\\\n-    do {\t\t\t\t\t\t\t\\\n-\tchar __buf[256];\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\t.dd\\t\");\t\t\t\t\\\n-\tASM_GENERATE_INTERNAL_LABEL (__buf, \"L\", VALUE);\t\\\n-\tassemble_name (FILE, __buf);\t\t\t\t\\\n-\tfputs (\" - \", FILE);\t\t\t\t\t\\\n-\tASM_GENERATE_INTERNAL_LABEL (__buf, \"L\", REL);\t\t\\\n-\tassemble_name (FILE, __buf);\t\t\t\t\\\n-\tfputc (';', FILE);\t\t\t\t\t\\\n-\tfputc ('\\n', FILE);\t\t\t\t\t\\\n-    } while (0)\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG) \t\t\t\t\\\n-    do {\t\t\t\t\t\t\t\\\n-      if ((LOG) != 0)\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG));\t\t\\\n-    } while (0)\n-\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)\t\t\\\n-    do {\t\t\t\t\t\\\n-\tasm_output_skip (FILE, SIZE);\t\t\\\n-    } while (0)\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED) \t\\\n-do { \t\t\t\t\t\t\\\n-    switch_to_section (data_section);\t\t\t\t\\\n-    if ((SIZE) >= (unsigned int) 4 ) ASM_OUTPUT_ALIGN(FILE,2);\t\\\n-    ASM_OUTPUT_SIZE_DIRECTIVE (FILE, NAME, SIZE);\t\t\\\n-    ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\\\n-    fprintf (FILE, \"%s %ld;\\n\", ASM_SPACE,\t\t\t\\\n-\t     (ROUNDED) > (unsigned int) 1 ? (ROUNDED) : 1);\t\\\n-} while (0)\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n-     do {\t\t\t\t\t\t\\\n-\tASM_GLOBALIZE_LABEL1(FILE,NAME); \t\t\\\n-        ASM_OUTPUT_LOCAL (FILE, NAME, SIZE, ROUNDED); } while(0)\n+#define ASM_GLOBALIZE_LABEL1(FILE, NAME)                                       \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      fputs (\".global \", FILE);                                                \\\n+      assemble_name (FILE, NAME);                                              \\\n+      fputc (';', FILE);                                                       \\\n+      fputc ('\\n', FILE);                                                      \\\n+    }                                                                          \\\n+  while (0)\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)                            \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      fputs (\".type \", FILE);                                                  \\\n+      assemble_name (FILE, NAME);                                              \\\n+      fputs (\", STT_FUNC\", FILE);                                              \\\n+      fputc (';', FILE);                                                       \\\n+      fputc ('\\n', FILE);                                                      \\\n+      ASM_OUTPUT_LABEL (FILE, NAME);                                           \\\n+    }                                                                          \\\n+  while (0)\n+\n+#define ASM_OUTPUT_LABEL(FILE, NAME)                                           \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      assemble_name (FILE, NAME);                                              \\\n+      fputs (\":\\n\", FILE);                                                     \\\n+    }                                                                          \\\n+  while (0)\n+\n+#define ASM_OUTPUT_LABELREF(FILE, NAME)                                        \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      fprintf (FILE, \"_%s\", NAME);                                             \\\n+    }                                                                          \\\n+  while (0)\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)                                   \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      char __buf[256];                                                         \\\n+      fprintf (FILE, \"\\t.dd\\t\");                                               \\\n+      ASM_GENERATE_INTERNAL_LABEL (__buf, \"L\", VALUE);                         \\\n+      assemble_name (FILE, __buf);                                             \\\n+      fputc (';', FILE);                                                       \\\n+      fputc ('\\n', FILE);                                                      \\\n+    }                                                                          \\\n+  while (0)\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)                       \\\n+  MY_ASM_OUTPUT_ADDR_DIFF_ELT (FILE, VALUE, REL)\n+\n+#define MY_ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)                          \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      char __buf[256];                                                         \\\n+      fprintf (FILE, \"\\t.dd\\t\");                                               \\\n+      ASM_GENERATE_INTERNAL_LABEL (__buf, \"L\", VALUE);                         \\\n+      assemble_name (FILE, __buf);                                             \\\n+      fputs (\" - \", FILE);                                                     \\\n+      ASM_GENERATE_INTERNAL_LABEL (__buf, \"L\", REL);                           \\\n+      assemble_name (FILE, __buf);                                             \\\n+      fputc (';', FILE);                                                       \\\n+      fputc ('\\n', FILE);                                                      \\\n+    }                                                                          \\\n+  while (0)\n+\n+#define ASM_OUTPUT_ALIGN(FILE, LOG)                                            \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      if ((LOG) != 0)                                                          \\\n+\tfprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG));                           \\\n+    }                                                                          \\\n+  while (0)\n+\n+#define ASM_OUTPUT_SKIP(FILE, SIZE)                                            \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      asm_output_skip (FILE, SIZE);                                            \\\n+    }                                                                          \\\n+  while (0)\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)                            \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      switch_to_section (data_section);                                        \\\n+      if ((SIZE) >= (unsigned int) 4)                                          \\\n+\tASM_OUTPUT_ALIGN (FILE, 2);                                            \\\n+      ASM_OUTPUT_SIZE_DIRECTIVE (FILE, NAME, SIZE);                            \\\n+      ASM_OUTPUT_LABEL (FILE, NAME);                                           \\\n+      fprintf (FILE, \"%s %ld;\\n\", ASM_SPACE,                                   \\\n+\t       (ROUNDED) > (unsigned int) 1 ? (ROUNDED) : 1);                  \\\n+    }                                                                          \\\n+  while (0)\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)                           \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      ASM_GLOBALIZE_LABEL1 (FILE, NAME);                                       \\\n+      ASM_OUTPUT_LOCAL (FILE, NAME, SIZE, ROUNDED);                            \\\n+    }                                                                          \\\n+  while (0)\n \n #define ASM_COMMENT_START \"//\"\n \n #define PROFILE_BEFORE_PROLOGUE\n-#define FUNCTION_PROFILER(FILE, LABELNO)\t\\\n-  do {\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t[--SP] = RETS;\\n\");\t\\\n-    if (TARGET_LONG_CALLS)\t\t\t\\\n-      {\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tP2.h = __mcount;\\n\");\t\\\n-\tfprintf (FILE, \"\\tP2.l = __mcount;\\n\");\t\\\n-\tfprintf (FILE, \"\\tCALL (P2);\\n\");\t\\\n-      }\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tCALL __mcount;\\n\");\t\\\n-    fprintf (FILE, \"\\tRETS = [SP++];\\n\");\t\\\n-  } while(0)\n+#define FUNCTION_PROFILER(FILE, LABELNO)                                       \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      fprintf (FILE, \"\\t[--SP] = RETS;\\n\");                                    \\\n+      if (TARGET_LONG_CALLS)                                                   \\\n+\t{                                                                      \\\n+\t  fprintf (FILE, \"\\tP2.h = __mcount;\\n\");                              \\\n+\t  fprintf (FILE, \"\\tP2.l = __mcount;\\n\");                              \\\n+\t  fprintf (FILE, \"\\tCALL (P2);\\n\");                                    \\\n+\t}                                                                      \\\n+      else                                                                     \\\n+\tfprintf (FILE, \"\\tCALL __mcount;\\n\");                                  \\\n+      fprintf (FILE, \"\\tRETS = [SP++];\\n\");                                    \\\n+    }                                                                          \\\n+  while (0)\n \n #undef NO_PROFILE_COUNTERS\n #define NO_PROFILE_COUNTERS 1\n \n-#define ASM_OUTPUT_REG_PUSH(FILE, REGNO) fprintf (FILE, \"\\t[--SP] = %s;\\n\", reg_names[REGNO])\n-#define ASM_OUTPUT_REG_POP(FILE, REGNO)  fprintf (FILE, \"\\t%s = [SP++];\\n\", reg_names[REGNO])\n+#define ASM_OUTPUT_REG_PUSH(FILE, REGNO)                                       \\\n+  fprintf (FILE, \"\\t[--SP] = %s;\\n\", reg_names[REGNO])\n+#define ASM_OUTPUT_REG_POP(FILE, REGNO)                                        \\\n+  fprintf (FILE, \"\\t%s = [SP++];\\n\", reg_names[REGNO])\n \n extern rtx bfin_cc_rtx, bfin_rets_rtx;\n \n /* This works for GAS and some other assemblers.  */\n-#define SET_ASM_OP              \".set \"\n+#define SET_ASM_OP \".set \"\n \n /* DBX register number for a given compiler register number */\n-#define DBX_REGISTER_NUMBER(REGNO)  (REGNO) \n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n \n-#define SIZE_ASM_OP     \"\\t.size\\t\"\n+#define SIZE_ASM_OP \"\\t.size\\t\"\n \n extern int splitting_for_sched, splitting_loops;\n "}, {"sha": "57812b08dfdd9c03d51e181259decc0ca5344f97", "filename": "gcc/config/c6x/c6x-rust.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c26f60f6a28394e98ac1d830cbe8f632ef576dbb/gcc%2Fconfig%2Fc6x%2Fc6x-rust.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c26f60f6a28394e98ac1d830cbe8f632ef576dbb/gcc%2Fconfig%2Fc6x%2Fc6x-rust.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x-rust.c?ref=c26f60f6a28394e98ac1d830cbe8f632ef576dbb", "patch": "@@ -29,7 +29,6 @@ void c6x_rust_target_cpu_info(void) {\n     rust_add_target_info(\"target_arch\", \"tic6x\");\n \n     // llvm seems to have no support for c6x (nor historical support), so names are made up by me\n-    // TODO: very subject to change\n     // TODO maybe put in sub-arches as features? idk\n     if (TARGET_DSBT)\n         rust_add_target_info(\"target_feature\", \"dsbt\");"}, {"sha": "b6c7a76e1afff4f8fd7773e3c2f3539cba257fd0", "filename": "gcc/config/cr16/cr16-rust.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c26f60f6a28394e98ac1d830cbe8f632ef576dbb/gcc%2Fconfig%2Fcr16%2Fcr16-rust.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c26f60f6a28394e98ac1d830cbe8f632ef576dbb/gcc%2Fconfig%2Fcr16%2Fcr16-rust.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16-rust.c?ref=c26f60f6a28394e98ac1d830cbe8f632ef576dbb", "patch": "@@ -29,7 +29,6 @@ void cr16_rust_target_cpu_info(void) {\n     rust_add_target_info(\"target_arch\", \"cr16\");\n \n     // llvm seems to have no support for cr16 (nor historical support), so names are made up by me\n-    // TODO: very subject to change\n     // TODO maybe put in sub-arches as features? idk\n     if (TARGET_BIT_OPS)\n         rust_add_target_info(\"target_feature\", \"bit-ops\");"}, {"sha": "44c34cd706bb6295553abe0c31887dcb2a6b7859", "filename": "gcc/config/csky/csky-rust.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c26f60f6a28394e98ac1d830cbe8f632ef576dbb/gcc%2Fconfig%2Fcsky%2Fcsky-rust.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c26f60f6a28394e98ac1d830cbe8f632ef576dbb/gcc%2Fconfig%2Fcsky%2Fcsky-rust.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcsky%2Fcsky-rust.c?ref=c26f60f6a28394e98ac1d830cbe8f632ef576dbb", "patch": "@@ -29,7 +29,6 @@ void cris_rust_target_cpu_info(void) {\n     rust_add_target_info(\"target_arch\", \"csky\");\n \n     // llvm seems to have no support for sky (nor historical support), so names are made up by me\n-    // TODO: very subject to change\n     // TODO maybe put in sub-arches as features? idk. might be useful in this case \n     if (TARGET_HARD_FLOAT)\n         rust_add_target_info(\"target_feature\", \"hard-float\");"}, {"sha": "952f8679124e3997704ebbef330c03fa08365706", "filename": "gcc/config/epiphany/epiphany-rust.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c26f60f6a28394e98ac1d830cbe8f632ef576dbb/gcc%2Fconfig%2Fepiphany%2Fepiphany-rust.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c26f60f6a28394e98ac1d830cbe8f632ef576dbb/gcc%2Fconfig%2Fepiphany%2Fepiphany-rust.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany-rust.c?ref=c26f60f6a28394e98ac1d830cbe8f632ef576dbb", "patch": "@@ -29,7 +29,6 @@ void epiphany_rust_target_cpu_info(void) {\n     rust_add_target_info(\"target_arch\", \"epiphany\");\n \n     // llvm seems to have no support for sky (nor historical support), so names are made up by me\n-    // TODO: very subject to change\n     // TODO: should the \"no\" dichotomy be preserved? probably not, but which should be chosen?\n     if (TARGET_HALF_REG_FILE)\n         rust_add_target_info(\"target_feature\", \"half-reg-file\");"}, {"sha": "ed66a12e7609f22539b9e41399dfe17b63a10691", "filename": "gcc/config/frv/frv-rust.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c26f60f6a28394e98ac1d830cbe8f632ef576dbb/gcc%2Fconfig%2Ffrv%2Ffrv-rust.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c26f60f6a28394e98ac1d830cbe8f632ef576dbb/gcc%2Fconfig%2Ffrv%2Ffrv-rust.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-rust.c?ref=c26f60f6a28394e98ac1d830cbe8f632ef576dbb", "patch": "@@ -29,7 +29,6 @@ void frv_rust_target_cpu_info(void) {\n     rust_add_target_info(\"target_arch\", \"frv\");\n \n     // llvm seems to have no support for sky (nor historical support), so names are made up by me\n-    // TODO: very subject to change\n     // TODO maybe put in sub-arches as features? idk. might be useful in this case \n     if (TARGET_ACC_4)\n         rust_add_target_info(\"target_feature\", \"acc-4\");"}, {"sha": "769f3b3f9763aa4781a2ace16e5bc8943a126011", "filename": "gcc/config/ft32/ft32.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c26f60f6a28394e98ac1d830cbe8f632ef576dbb/gcc%2Fconfig%2Fft32%2Fft32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c26f60f6a28394e98ac1d830cbe8f632ef576dbb/gcc%2Fconfig%2Fft32%2Fft32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.h?ref=c26f60f6a28394e98ac1d830cbe8f632ef576dbb", "patch": "@@ -468,7 +468,8 @@ do { \\\n     rust_add_target_info(\"target_arch\", \"ft32\");  \\\n     if (TARGET_SIM)   \\\n       rust_add_target_info(\"target_feature\", \"sim\");   \\\n-    /*TODO: figure out how to use lra option*/ \\\n+    if (ft32_lra_flag)   \\\n+      rust_add_target_info(\"target_feature\", \"lra\");   \\\n     if (TARGET_NODIV)   \\\n       rust_add_target_info(\"target_feature\", \"nodiv\");   \\\n     if (TARGET_FT32B)   \\"}, {"sha": "f21cf48333a0b4af6a53ed01b8ba0f655887e14e", "filename": "gcc/config/ia64/ia64-rust.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c26f60f6a28394e98ac1d830cbe8f632ef576dbb/gcc%2Fconfig%2Fia64%2Fia64-rust.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c26f60f6a28394e98ac1d830cbe8f632ef576dbb/gcc%2Fconfig%2Fia64%2Fia64-rust.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-rust.c?ref=c26f60f6a28394e98ac1d830cbe8f632ef576dbb", "patch": "@@ -95,8 +95,6 @@ void ia64_rust_target_cpu_info(void) {\n         rust_add_target_info(\"target_feature\", \"early-stop-bits\");\n     // TODO: do fixed-range somehow (wouldn't work well as define, I don't think), same for tls-size\n \n-    /* TODO: ensure that these variables below are actually accessible, and work (i.e. condition test not\n-     * wrong way around). */\n     if (mflag_sched_br_data_spec)\n         rust_add_target_info(\"target_feature\", \"sched-br-data-spec\");\n     if (mflag_sched_ar_data_spec)"}]}