{"sha": "4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY2YzIxMzE0MmU1Y2U2ZjVlZTE3ZWY1ZDBmMWNiODVjZDBmZjU3Mw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2006-09-29T06:32:58Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-09-29T06:32:58Z"}, "message": "builtins.c (expand_builtin_setjmp): Delete.\n\n\t* builtins.c (expand_builtin_setjmp): Delete.\n\t(expand_builtin) <BUILT_IN_SETJMP>: Mark as unreachable.\n\t<BUILT_IN_SETJMP_SETUP>: New case.\n\t<BUILT_IN_SETJMP_DISPATCHER>: Likewise.\n\t<BUILT_IN_SETJMP_RECEIVER>: Likewise.\n\t* builtins.def (BUILT_IN_SETJMP_SETUP): New built-in stub.\n\t(BUILT_IN_SETJMP_DISPATCHER): Likewise.\n\t(BUILT_IN_SETJMP_RECEIVER): Likewise.\n\t* gimple-low.c (struct lower_data): New field calls_builtin_setjmp.\n\t(lower_function_body): Initialize it to false.  If it is set to true\n\tat the end of the processing, emit the setjmp dispatcher.\n\t(lower_stmt) <CALL_EXPR>: Invoke lower_builtin_setjmp if the callee\n\tis __builtin_setjmp and set calls_builtin_setjmp to true as well.\n\t<MODIFY_EXPR>: Fall through to above case if there is a CALL_EXPR\n\ton the rhs of the assignment.\n\t(lower_builtin_setjmp): New function.\n\t* tree.c (build_common_builtin_nodes): Build BUILT_IN_SETJMP_SETUP,\n\tBUILT_IN_SETJMP_DISPATCHER and BUILT_IN_SETJMP_RECEIVER nodes.\n\t* tree-cfg.c (make_exit_edges) <CALL_EXPR>: Use specific predicate\n\tto detect calls that can go to non-local labels.  Use specific\n\thelper to create the abnormal edges associated with them.\n\t<MODIFY_EXPR>: Likewise.\n\t(make_abnormal_goto_edges): New function extracted from...\n\t(make_goto_expr_edges): ...here.  Call it for computed gotos.\n\t(simple_goto_p): Minor tweak.\n\t(tree_can_make_abnormal_goto): New predicate.\n\t(tree_redirect_edge_and_branch): Return zero on all abnormal edges.\n\t(tree_purge_dead_abnormal_call_edges): New function.\n\t* tree-flow.h (tree_can_make_abnormal_goto): Declare.\n\t(tree_purge_dead_abnormal_call_edges): Likewise.\n\t(make_abnormal_goto_edges): Likewise.\n\t* tree-inline.c (expand_call_inline): Simplify statement frobbing.\n\tPurge all dead abnormal edges if the call was in the last statement.\n\t* tree-optimize.c (has_abnormal_outgoing_edge_p): New predicate.\n\t(execute_fixup_cfg): If there are non-local labels in the function,\n\tscan the basic blocks and split them at calls that can go to non-local\n\tlabels or add missing abnormal call edges.  Write down the CFG in the\n\tdump file.\n\t(pass_fixup_cfg): Remove TODO_dump_func flag.\n\t* unwind-sjlj.c: Poison setjmp.\n\t* doc/install.texi (enable-sjlj-exceptions): Use more general wording.\n\t* doc/tm.texi (DWARF2_UNWIND_INFO): Likewise.\n\t(TARGET_UNWIND_TABLES_DEFAULT): Fix typo.\n\t(DONT_USE_BUILTIN_SETJMP): Document it.\n\nFrom-SVN: r117298", "tree": {"sha": "c8e2772aad71fdf66dba0112c42b9178748e598f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8e2772aad71fdf66dba0112c42b9178748e598f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/comments", "author": null, "committer": null, "parents": [{"sha": "a40e443fe8ce40cabbedbe4d134a3e7d397ea089", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a40e443fe8ce40cabbedbe4d134a3e7d397ea089", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a40e443fe8ce40cabbedbe4d134a3e7d397ea089"}], "stats": {"total": 888, "additions": 708, "deletions": 180}, "files": [{"sha": "3f96481599ed47f07e074576322468a820208d48", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "patch": "@@ -1,3 +1,50 @@\n+2006-09-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* builtins.c (expand_builtin_setjmp): Delete.\n+\t(expand_builtin) <BUILT_IN_SETJMP>: Mark as unreachable.\n+\t<BUILT_IN_SETJMP_SETUP>: New case.\n+\t<BUILT_IN_SETJMP_DISPATCHER>: Likewise.\n+\t<BUILT_IN_SETJMP_RECEIVER>: Likewise.\n+\t* builtins.def (BUILT_IN_SETJMP_SETUP): New built-in stub.\n+\t(BUILT_IN_SETJMP_DISPATCHER): Likewise.\n+\t(BUILT_IN_SETJMP_RECEIVER): Likewise.\n+\t* gimple-low.c (struct lower_data): New field calls_builtin_setjmp.\n+\t(lower_function_body): Initialize it to false.  If it is set to true\n+\tat the end of the processing, emit the setjmp dispatcher.\n+\t(lower_stmt) <CALL_EXPR>: Invoke lower_builtin_setjmp if the callee\n+\tis __builtin_setjmp and set calls_builtin_setjmp to true as well.\n+\t<MODIFY_EXPR>: Fall through to above case if there is a CALL_EXPR\n+\ton the rhs of the assignment.\n+\t(lower_builtin_setjmp): New function.\n+\t* tree.c (build_common_builtin_nodes): Build BUILT_IN_SETJMP_SETUP,\n+\tBUILT_IN_SETJMP_DISPATCHER and BUILT_IN_SETJMP_RECEIVER nodes.\n+\t* tree-cfg.c (make_exit_edges) <CALL_EXPR>: Use specific predicate\n+\tto detect calls that can go to non-local labels.  Use specific\n+\thelper to create the abnormal edges associated with them.\n+\t<MODIFY_EXPR>: Likewise.\n+\t(make_abnormal_goto_edges): New function extracted from...\n+\t(make_goto_expr_edges): ...here.  Call it for computed gotos.\n+\t(simple_goto_p): Minor tweak.\n+\t(tree_can_make_abnormal_goto): New predicate.\n+\t(tree_redirect_edge_and_branch): Return zero on all abnormal edges.\n+\t(tree_purge_dead_abnormal_call_edges): New function.\n+\t* tree-flow.h (tree_can_make_abnormal_goto): Declare.\n+\t(tree_purge_dead_abnormal_call_edges): Likewise.\n+\t(make_abnormal_goto_edges): Likewise.\n+\t* tree-inline.c (expand_call_inline): Simplify statement frobbing.\n+\tPurge all dead abnormal edges if the call was in the last statement.\n+\t* tree-optimize.c (has_abnormal_outgoing_edge_p): New predicate.\n+\t(execute_fixup_cfg): If there are non-local labels in the function,\n+\tscan the basic blocks and split them at calls that can go to non-local\n+\tlabels or add missing abnormal call edges.  Write down the CFG in the\n+\tdump file.\n+\t(pass_fixup_cfg): Remove TODO_dump_func flag.\n+\t* unwind-sjlj.c: Poison setjmp.\n+\t* doc/install.texi (enable-sjlj-exceptions): Use more general wording.\n+\t* doc/tm.texi (DWARF2_UNWIND_INFO): Likewise.\n+\t(TARGET_UNWIND_TABLES_DEFAULT): Fix typo.\n+\t(DONT_USE_BUILTIN_SETJMP): Document it.\n+\n 2006-09-28  Geoffrey Keating  <geoffk@apple.com>\n \n \tPR target/28617"}, {"sha": "8fb58ca052dd3e61e9583e571fc1772d1b39c8a8", "filename": "gcc/builtins.c", "status": "modified", "additions": 57, "deletions": 75, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "patch": "@@ -81,7 +81,6 @@ static int apply_result_size (void);\n #if defined (HAVE_untyped_call) || defined (HAVE_untyped_return)\n static rtx result_vector (int, rtx);\n #endif\n-static rtx expand_builtin_setjmp (tree, rtx);\n static void expand_builtin_update_setjmp_buf (rtx);\n static void expand_builtin_prefetch (tree);\n static rtx expand_builtin_apply_args (void);\n@@ -608,8 +607,8 @@ expand_builtin_return_addr (enum built_in_function fndecl_code, int count)\n static HOST_WIDE_INT setjmp_alias_set = -1;\n \n /* Construct the leading half of a __builtin_setjmp call.  Control will\n-   return to RECEIVER_LABEL.  This is used directly by sjlj exception\n-   handling code.  */\n+   return to RECEIVER_LABEL.  This is also called directly by the SJLJ\n+   exception handling code.  */\n \n void\n expand_builtin_setjmp_setup (rtx buf_addr, rtx receiver_label)\n@@ -660,8 +659,8 @@ expand_builtin_setjmp_setup (rtx buf_addr, rtx receiver_label)\n   current_function_has_nonlocal_label = 1;\n }\n \n-/* Construct the trailing part of a __builtin_setjmp call.\n-   This is used directly by sjlj exception handling code.  */\n+/* Construct the trailing part of a __builtin_setjmp call.  This is\n+   also called directly by the SJLJ exception handling code.  */\n \n void\n expand_builtin_setjmp_receiver (rtx receiver_label ATTRIBUTE_UNUSED)\n@@ -729,73 +728,10 @@ expand_builtin_setjmp_receiver (rtx receiver_label ATTRIBUTE_UNUSED)\n   emit_insn (gen_rtx_ASM_INPUT (VOIDmode, \"\"));\n }\n \n-/* __builtin_setjmp is passed a pointer to an array of five words (not\n-   all will be used on all machines).  It operates similarly to the C\n-   library function of the same name, but is more efficient.  Much of\n-   the code below (and for longjmp) is copied from the handling of\n-   non-local gotos.\n-\n-   NOTE: This is intended for use by GNAT and the exception handling\n-   scheme in the compiler and will only work in the method used by\n-   them.  */\n-\n-static rtx\n-expand_builtin_setjmp (tree arglist, rtx target)\n-{\n-  rtx buf_addr, next_lab, cont_lab;\n-\n-  if (!validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))\n-    return NULL_RTX;\n-\n-  if (target == 0 || !REG_P (target)\n-      || REGNO (target) < FIRST_PSEUDO_REGISTER)\n-    target = gen_reg_rtx (TYPE_MODE (integer_type_node));\n-\n-  buf_addr = expand_normal (TREE_VALUE (arglist));\n-\n-  next_lab = gen_label_rtx ();\n-  cont_lab = gen_label_rtx ();\n-\n-  expand_builtin_setjmp_setup (buf_addr, next_lab);\n-\n-  /* Set TARGET to zero and branch to the continue label.  Use emit_jump to\n-     ensure that pending stack adjustments are flushed.  */\n-  emit_move_insn (target, const0_rtx);\n-  emit_jump (cont_lab);\n-\n-  emit_label (next_lab);\n-\n-  /* Because setjmp and longjmp are not represented in the CFG, a cfgcleanup\n-     may find that the basic block starting with NEXT_LAB is unreachable.\n-     The whole block, along with NEXT_LAB, would be removed (see PR26983).\n-     Make sure that never happens.  */\n-  LABEL_PRESERVE_P (next_lab) = 1;\n-     \n-  expand_builtin_setjmp_receiver (next_lab);\n-\n-  /* Set TARGET to one.  */\n-  emit_move_insn (target, const1_rtx);\n-  emit_label (cont_lab);\n-\n-  /* Tell flow about the strange goings on.  Putting `next_lab' on\n-     `nonlocal_goto_handler_labels' to indicates that function\n-     calls may traverse the arc back to this label.  */\n-\n-  current_function_has_nonlocal_label = 1;\n-  nonlocal_goto_handler_labels\n-    = gen_rtx_EXPR_LIST (VOIDmode, next_lab, nonlocal_goto_handler_labels);\n-\n-  return target;\n-}\n-\n /* __builtin_longjmp is passed a pointer to an array of five words (not\n    all will be used on all machines).  It operates similarly to the C\n    library function of the same name, but is more efficient.  Much of\n-   the code below is copied from the handling of non-local gotos.\n-\n-   NOTE: This is intended for use by GNAT and the exception handling\n-   scheme in the compiler and will only work in the method used by\n-   them.  */\n+   the code below is copied from the handling of non-local gotos.  */\n \n static void\n expand_builtin_longjmp (rtx buf_addr, rtx value)\n@@ -6077,18 +6013,63 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n       break;\n \n     case BUILT_IN_SETJMP:\n-      target = expand_builtin_setjmp (arglist, target);\n-      if (target)\n-\treturn target;\n+      /* This should have been lowered to the builtins below.  */\n+      gcc_unreachable ();\n+\n+    case BUILT_IN_SETJMP_SETUP:\n+      /* __builtin_setjmp_setup is passed a pointer to an array of five words\n+          and the receiver label.  */\n+      if (validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n+\t{\n+\t  rtx buf_addr = expand_expr (TREE_VALUE (arglist), subtarget,\n+\t\t\t\t      VOIDmode, EXPAND_NORMAL);\n+\t  tree label = TREE_OPERAND (TREE_VALUE (TREE_CHAIN (arglist)), 0);\n+\t  rtx label_r = label_rtx (label);\n+\n+\t  /* This is copied from the handling of non-local gotos.  */\n+\t  expand_builtin_setjmp_setup (buf_addr, label_r);\n+\t  nonlocal_goto_handler_labels\n+\t    = gen_rtx_EXPR_LIST (VOIDmode, label_r,\n+\t\t\t\t nonlocal_goto_handler_labels);\n+\t  /* ??? Do not let expand_label treat us as such since we would\n+\t     not want to be both on the list of non-local labels and on\n+\t     the list of forced labels.  */\n+\t  FORCED_LABEL (label) = 0;\n+\t  return const0_rtx;\n+\t}\n+      break;\n+\n+    case BUILT_IN_SETJMP_DISPATCHER:\n+       /* __builtin_setjmp_dispatcher is passed the dispatcher label.  */\n+      if (validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))\n+\t{\n+\t  tree label = TREE_OPERAND (TREE_VALUE (arglist), 0);\n+\t  rtx label_r = label_rtx (label);\n+\n+\t  /* Remove the dispatcher label from the list of non-local labels\n+\t     since the receiver labels have been added to it above.  */\n+\t  remove_node_from_expr_list (label_r, &nonlocal_goto_handler_labels);\n+\t  return const0_rtx;\n+\t}\n+      break;\n+\n+    case BUILT_IN_SETJMP_RECEIVER:\n+       /* __builtin_setjmp_receiver is passed the receiver label.  */\n+      if (validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))\n+\t{\n+\t  tree label = TREE_OPERAND (TREE_VALUE (arglist), 0);\n+\t  rtx label_r = label_rtx (label);\n+\n+\t  expand_builtin_setjmp_receiver (label_r);\n+\t  return const0_rtx;\n+\t}\n       break;\n \n       /* __builtin_longjmp is passed a pointer to an array of five words.\n \t It's similar to the C library longjmp function but works with\n \t __builtin_setjmp above.  */\n     case BUILT_IN_LONGJMP:\n-      if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-\tbreak;\n-      else\n+      if (validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n \t{\n \t  rtx buf_addr = expand_expr (TREE_VALUE (arglist), subtarget,\n \t\t\t\t      VOIDmode, EXPAND_NORMAL);\n@@ -6103,6 +6084,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \t  expand_builtin_longjmp (buf_addr, value);\n \t  return const0_rtx;\n \t}\n+      break;\n \n     case BUILT_IN_NONLOCAL_GOTO:\n       target = expand_builtin_nonlocal_goto (arglist);"}, {"sha": "0e73cf440a40fb17e8e0f063c13d8624cf3b5022", "filename": "gcc/builtins.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "patch": "@@ -690,6 +690,11 @@ DEF_BUILTIN_STUB (BUILT_IN_INIT_TRAMPOLINE, \"__builtin_init_trampoline\")\n DEF_BUILTIN_STUB (BUILT_IN_ADJUST_TRAMPOLINE, \"__builtin_adjust_trampoline\")\n DEF_BUILTIN_STUB (BUILT_IN_NONLOCAL_GOTO, \"__builtin_nonlocal_goto\")\n \n+/* Implementing __builtin_setjmp.  */\n+DEF_BUILTIN_STUB (BUILT_IN_SETJMP_SETUP, \"__builtin_setjmp_setup\")\n+DEF_BUILTIN_STUB (BUILT_IN_SETJMP_DISPATCHER, \"__builtin_setjmp_dispatcher\")\n+DEF_BUILTIN_STUB (BUILT_IN_SETJMP_RECEIVER, \"__builtin_setjmp_receiver\")\n+\n /* Implementing variable sized local variables.  */\n DEF_BUILTIN_STUB (BUILT_IN_STACK_SAVE, \"__builtin_stack_save\")\n DEF_BUILTIN_STUB (BUILT_IN_STACK_RESTORE, \"__builtin_stack_restore\")"}, {"sha": "1925b5577cb619ab2eb1e15678a4c97ff97c023b", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "patch": "@@ -1456,9 +1456,9 @@ file to compile into a @file{.class} file.\n Search for libiconv in @file{DIR/include} and @file{DIR/lib}.\n \n @item --enable-sjlj-exceptions\n-Force use of @code{builtin_setjmp} for exceptions.  @samp{configure}\n-ordinarily picks the correct value based on the platform.  Only use\n-this option if you are sure you need a different setting.\n+Force use of the @code{setjmp}/@code{longjmp}-based scheme for exceptions.\n+@samp{configure} ordinarily picks the correct value based on the platform.\n+Only use this option if you are sure you need a different setting.\n \n @item --with-system-zlib\n Use installed @samp{zlib} rather than that included with GCC@."}, {"sha": "c724a49a40e81446675f327ed20a5939fe7a5344", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "patch": "@@ -7924,33 +7924,39 @@ Define this macro to 0 if your target supports DWARF 2 frame unwind\n information, but it does not yet work with exception handling.\n Otherwise, if your target supports this information (if it defines\n @samp{INCOMING_RETURN_ADDR_RTX} and either @samp{UNALIGNED_INT_ASM_OP}\n-or @samp{OBJECT_FORMAT_ELF}), GCC will provide a default definition of\n-1.\n+or @samp{OBJECT_FORMAT_ELF}), GCC will provide a default definition of 1.\n \n If @code{TARGET_UNWIND_INFO} is defined, the target specific unwinder\n will be used in all cases.  Defining this macro will enable the generation\n of DWARF 2 frame debugging information.\n \n If @code{TARGET_UNWIND_INFO} is not defined, and this macro is defined to 1,\n the DWARF 2 unwinder will be the default exception handling mechanism;\n-otherwise, @code{setjmp}/@code{longjmp} will be used by default.\n+otherwise, the @code{setjmp}/@code{longjmp}-based scheme will be used by\n+default.\n @end defmac\n \n @defmac TARGET_UNWIND_INFO\n Define this macro if your target has ABI specified unwind tables.  Usually\n these will be output by @code{TARGET_UNWIND_EMIT}.\n @end defmac\n \n-@deftypevar {Target Hook} bool TARGET_UNWID_TABLES_DEFAULT\n+@deftypevar {Target Hook} bool TARGET_UNWIND_TABLES_DEFAULT\n This variable should be set to @code{true} if the target ABI requires unwinding\n tables even when exceptions are not used.\n @end deftypevar\n \n @defmac MUST_USE_SJLJ_EXCEPTIONS\n This macro need only be defined if @code{DWARF2_UNWIND_INFO} is\n runtime-variable.  In that case, @file{except.h} cannot correctly\n-determine the corresponding definition of\n-@code{MUST_USE_SJLJ_EXCEPTIONS}, so the target must provide it directly.\n+determine the corresponding definition of @code{MUST_USE_SJLJ_EXCEPTIONS},\n+so the target must provide it directly.\n+@end defmac\n+\n+@defmac DONT_USE_BUILTIN_SETJMP\n+Define this macro to 1 if the @code{setjmp}/@code{longjmp}-based scheme\n+should use the @code{setjmp}/@code{longjmp} functions from the C library\n+instead of the @code{__builtin_setjmp}/@code{__builtin_longjmp} machinery.\n @end defmac\n \n @defmac DWARF_CIE_DATA_ALIGNMENT"}, {"sha": "c6a0312a2bea88bd7a934778832a257034ddb28a", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 184, "deletions": 7, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "patch": "@@ -49,14 +49,18 @@ struct lower_data\n   /* A TREE_LIST of label and return statements to be moved to the end\n      of the function.  */\n   tree return_statements;\n+\n+  /* True if the function calls __builtin_setjmp.  */\n+  bool calls_builtin_setjmp;\n };\n \n static void lower_stmt (tree_stmt_iterator *, struct lower_data *);\n static void lower_bind_expr (tree_stmt_iterator *, struct lower_data *);\n static void lower_cond_expr (tree_stmt_iterator *, struct lower_data *);\n static void lower_return_expr (tree_stmt_iterator *, struct lower_data *);\n+static void lower_builtin_setjmp (tree_stmt_iterator *);\n \n-/* Lowers the body of current_function_decl.  */\n+/* Lower the body of current_function_decl.  */\n \n static unsigned int\n lower_function_body (void)\n@@ -113,6 +117,35 @@ lower_function_body (void)\n       tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n     }\n \n+  /* If the function calls __builtin_setjmp, we need to emit the computed\n+     goto that will serve as the unique dispatcher for all the receivers.  */\n+  if (data.calls_builtin_setjmp)\n+    {\n+      tree disp_label, disp_var, arg;\n+\n+      /* Build 'DISP_LABEL:' and insert.  */\n+      disp_label = create_artificial_label ();\n+      /* This mark will create forward edges from every call site.  */\n+      DECL_NONLOCAL (disp_label) = 1;\n+      current_function_has_nonlocal_label = 1;\n+      x = build1 (LABEL_EXPR, void_type_node, disp_label);\n+      tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n+\n+      /* Build 'DISP_VAR = __builtin_setjmp_dispatcher (DISP_LABEL);'\n+\t and insert.  */\n+      disp_var = create_tmp_var (ptr_type_node, \"setjmpvar\");\n+      t = build_addr (disp_label, current_function_decl);\n+      arg = tree_cons (NULL, t, NULL);\n+      t = implicit_built_in_decls[BUILT_IN_SETJMP_DISPATCHER];\n+      t = build_function_call_expr (t,arg);\n+      x = build2 (MODIFY_EXPR, void_type_node, disp_var, t);\n+\n+      /* Build 'goto DISP_VAR;' and insert.  */\n+      tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n+      x = build1 (GOTO_EXPR, void_type_node, disp_var);\n+      tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n+    }\n+\n   gcc_assert (data.block == DECL_INITIAL (current_function_decl));\n   BLOCK_SUBBLOCKS (data.block)\n     = blocks_nreverse (BLOCK_SUBBLOCKS (data.block));\n@@ -139,7 +172,7 @@ struct tree_opt_pass pass_lower_cf =\n };\n \n \n-/* Lowers the EXPR.  Unlike gimplification the statements are not relowered\n+/* Lower the EXPR.  Unlike gimplification the statements are not relowered\n    when they are changed -- if this has to be done, the lowering routine must\n    do it explicitly.  DATA is passed through the recursion.  */\n \n@@ -171,7 +204,7 @@ lower_omp_directive (tree_stmt_iterator *tsi, struct lower_data *data)\n }\n \n \n-/* Lowers statement TSI.  DATA is passed through the recursion.  */\n+/* Lower statement TSI.  DATA is passed through the recursion.  */\n \n static void\n lower_stmt (tree_stmt_iterator *tsi, struct lower_data *data)\n@@ -207,8 +240,6 @@ lower_stmt (tree_stmt_iterator *tsi, struct lower_data *data)\n       \n     case NOP_EXPR:\n     case ASM_EXPR:\n-    case MODIFY_EXPR:\n-    case CALL_EXPR:\n     case GOTO_EXPR:\n     case LABEL_EXPR:\n     case SWITCH_EXPR:\n@@ -223,6 +254,27 @@ lower_stmt (tree_stmt_iterator *tsi, struct lower_data *data)\n     case OMP_CONTINUE:\n       break;\n \n+    case MODIFY_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (stmt, 1)) == CALL_EXPR)\n+\tstmt = TREE_OPERAND (stmt, 1);\n+      else\n+\tbreak;\n+      /* FALLTHRU */\n+\n+    case CALL_EXPR:\n+      {\n+\ttree decl = get_callee_fndecl (stmt);\n+\tif (decl\n+\t    && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL\n+\t    && DECL_FUNCTION_CODE (decl) == BUILT_IN_SETJMP)\n+\t  {\n+\t    data->calls_builtin_setjmp = true;\n+\t    lower_builtin_setjmp (tsi);\n+\t    return;\n+\t  }\n+      }\n+      break;\n+\n     case OMP_PARALLEL:\n       lower_omp_directive (tsi, data);\n       return;\n@@ -234,7 +286,7 @@ lower_stmt (tree_stmt_iterator *tsi, struct lower_data *data)\n   tsi_next (tsi);\n }\n \n-/* Lowers a bind_expr TSI.  DATA is passed through the recursion.  */\n+/* Lower a bind_expr TSI.  DATA is passed through the recursion.  */\n \n static void\n lower_bind_expr (tree_stmt_iterator *tsi, struct lower_data *data)\n@@ -403,7 +455,7 @@ block_may_fallthru (tree block)\n     }\n }\n \n-/* Lowers a cond_expr TSI.  DATA is passed through the recursion.  */\n+/* Lower a cond_expr TSI.  DATA is passed through the recursion.  */\n \n static void\n lower_cond_expr (tree_stmt_iterator *tsi, struct lower_data *data)\n@@ -498,6 +550,8 @@ lower_cond_expr (tree_stmt_iterator *tsi, struct lower_data *data)\n   tsi_next (tsi);\n }\n \n+/* Lower a return_expr TSI.  DATA is passed through the recursion.  */\n+\n static void\n lower_return_expr (tree_stmt_iterator *tsi, struct lower_data *data)\n {\n@@ -534,6 +588,129 @@ lower_return_expr (tree_stmt_iterator *tsi, struct lower_data *data)\n   tsi_link_before (tsi, t, TSI_SAME_STMT);\n   tsi_delink (tsi);\n }\n+\n+/* Lower a __builtin_setjmp TSI.\n+\n+   __builtin_setjmp is passed a pointer to an array of five words (not\n+   all will be used on all machines).  It operates similarly to the C\n+   library function of the same name, but is more efficient.\n+\n+   It is lowered into 3 other builtins, namely __builtin_setjmp_setup,\n+   __builtin_setjmp_dispatcher and __builtin_setjmp_receiver, but with\n+   __builtin_setjmp_dispatcher shared among all the instances; that's\n+   why it is only emitted at the end by lower_function_body.\n+\n+   After full lowering, the body of the function should look like:\n+\n+    {\n+      void * setjmpvar.0;\n+      int D.1844;\n+      int D.2844;\n+\n+      [...]\n+\n+      __builtin_setjmp_setup (&buf, &<D1847>);\n+      D.1844 = 0;\n+      goto <D1846>;\n+      <D1847>:;\n+      __builtin_setjmp_receiver (&<D1847>);\n+      D.1844 = 1;\n+      <D1846>:;\n+      if (D.1844 == 0) goto <D1848>; else goto <D1849>;\n+\n+      [...]\n+\n+      __builtin_setjmp_setup (&buf, &<D2847>);\n+      D.2844 = 0;\n+      goto <D2846>;\n+      <D2847>:;\n+      __builtin_setjmp_receiver (&<D2847>);\n+      D.2844 = 1;\n+      <D2846>:;\n+      if (D.2844 == 0) goto <D2848>; else goto <D2849>;\n+\n+      [...]\n+\n+      <D3850>:;\n+      return;\n+      <D3853>: [non-local];\n+      setjmpvar.0 = __builtin_setjmp_dispatcher (&<D3853>);\n+      goto setjmpvar.0;\n+    }\n+\n+   The dispatcher block will be both the unique destination of all the\n+   abnormal call edges and the unique source of all the abnormal edges\n+   to the receivers, thus keeping the complexity explosion localized.  */\n+\n+static void\n+lower_builtin_setjmp (tree_stmt_iterator *tsi)\n+{\n+  tree stmt = tsi_stmt (*tsi);\n+  tree cont_label = create_artificial_label ();\n+  tree next_label = create_artificial_label ();\n+  tree dest, t, arg;\n+\n+  /* NEXT_LABEL is the label __builtin_longjmp will jump to.  Its address is\n+     passed to both __builtin_setjmp_setup and __builtin_setjmp_receiver.  */\n+  FORCED_LABEL (next_label) = 1;\n+\n+  if (TREE_CODE (stmt) == MODIFY_EXPR)\n+    {\n+      dest = TREE_OPERAND (stmt, 0);\n+      stmt = TREE_OPERAND (stmt, 1);\n+    }\n+  else\n+    dest = NULL_TREE;\n+\n+  /* Build '__builtin_setjmp_setup (BUF, NEXT_LABEL)' and insert.  */\n+  t = build_addr (next_label, current_function_decl);\n+  arg = tree_cons (NULL, t, NULL);\n+  t = TREE_VALUE (TREE_OPERAND (stmt, 1));\n+  arg = tree_cons (NULL, t, arg);\n+  t = implicit_built_in_decls[BUILT_IN_SETJMP_SETUP];\n+  t = build_function_call_expr (t, arg);\n+  SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n+  tsi_link_before (tsi, t, TSI_SAME_STMT);\n+\n+  /* Build 'DEST = 0' and insert.  */\n+  if (dest)\n+    {\n+      t = build2 (MODIFY_EXPR, void_type_node, dest, integer_zero_node);\n+      SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n+      tsi_link_before (tsi, t, TSI_SAME_STMT);\n+    }\n+\n+  /* Build 'goto CONT_LABEL' and insert.  */\n+  t = build1 (GOTO_EXPR, void_type_node, cont_label);\n+  tsi_link_before (tsi, t, TSI_SAME_STMT);\n+\n+  /* Build 'NEXT_LABEL:' and insert.  */\n+  t = build1 (LABEL_EXPR, void_type_node, next_label);\n+  tsi_link_before (tsi, t, TSI_SAME_STMT);\n+\n+  /* Build '__builtin_setjmp_receiver (NEXT_LABEL)' and insert.  */\n+  t = build_addr (next_label, current_function_decl);\n+  arg = tree_cons (NULL, t, NULL);\n+  t = implicit_built_in_decls[BUILT_IN_SETJMP_RECEIVER];\n+  t = build_function_call_expr (t, arg);\n+  SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n+  tsi_link_before (tsi, t, TSI_SAME_STMT);\n+\n+  /* Build 'DEST = 1' and insert.  */\n+  if (dest)\n+    {\n+      t = build2 (MODIFY_EXPR, void_type_node, dest, integer_one_node);\n+      SET_EXPR_LOCUS (t, EXPR_LOCUS (stmt));\n+      tsi_link_before (tsi, t, TSI_SAME_STMT);\n+    }\n+\n+  /* Build 'CONT_LABEL:' and insert.  */\n+  t = build1 (LABEL_EXPR, void_type_node, cont_label);\n+  tsi_link_before (tsi, t, TSI_SAME_STMT);\n+\n+  /* Remove the call to __builtin_setjmp.  */\n+  tsi_delink (tsi);\n+}\n \f\n \n /* Record the variables in VARS into function FN.  */"}, {"sha": "d59cd1b011ed90b560a66a7c97c97b1964cee688", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "patch": "@@ -1,3 +1,10 @@\n+2006-09-28  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/non-local-goto-1.c: New test.\n+\t* gcc.dg/non-local-goto-2.c: Likewise.\n+\t* gcc.dg/setjmp-3.c: Likewise.\n+\t* gcc.dg/setjmp-4.c: Likewise.\n+\n 2006-09-28  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/self_aggregate_with_pointer.adb: New test."}, {"sha": "2bace076fad3b4fb39deb389bb7685cb853e7304", "filename": "gcc/testsuite/gcc.dg/non-local-goto-1.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftestsuite%2Fgcc.dg%2Fnon-local-goto-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftestsuite%2Fgcc.dg%2Fnon-local-goto-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnon-local-goto-1.c?ref=4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void abort (void);\n+\n+int global;\n+\n+static foo(void) __attribute__((noinline));\n+\n+static foo(void)\n+{\n+  global = 1;\n+}\n+\n+static bar(void)\n+{\n+  foo ();\n+}\n+\n+int execute(int cmd)\n+{\n+  __label__ start;\n+\n+  void raise(void)\n+  {\n+    goto start;\n+  }\n+\n+  int last;\n+\n+  bar ();\n+\n+  last = 0;\n+\n+start:\n+\n+  if (last == 0)\n+    while (1)\n+      {\n+        last = 1;\n+        raise ();\n+      }\n+\n+  if (last == 0)\n+    return 0;\n+  else\n+    return cmd;\n+}\n+\n+int main(void)\n+{\n+  if (execute (1) == 0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "24ed650a9e93b1a0c4bfa188446573e4bb26ca92", "filename": "gcc/testsuite/gcc.dg/non-local-goto-2.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftestsuite%2Fgcc.dg%2Fnon-local-goto-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftestsuite%2Fgcc.dg%2Fnon-local-goto-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnon-local-goto-2.c?ref=4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void abort (void);\n+\n+int global;\n+\n+static foo(void) __attribute__((noinline));\n+\n+static foo(void)\n+{\n+  global = 1;\n+}\n+\n+static bar(void)\n+{\n+  foo ();\n+  global = 0;\n+}\n+\n+int execute(int cmd)\n+{\n+  __label__ start;\n+\n+  void raise(void)\n+  {\n+    goto start;\n+  }\n+\n+  int last;\n+\n+  bar ();\n+\n+  last = 0;\n+\n+start:\n+\n+  if (last == 0)\n+    while (1)\n+      {\n+        last = 1;\n+        raise ();\n+      }\n+\n+  if (last == 0)\n+    return 0;\n+  else\n+    return cmd;\n+}\n+\n+int main(void)\n+{\n+  if (execute (1) == 0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "94dc5906206b83bdefb7ec6561f8af06121c3935", "filename": "gcc/testsuite/gcc.dg/setjmp-3.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftestsuite%2Fgcc.dg%2Fsetjmp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftestsuite%2Fgcc.dg%2Fsetjmp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsetjmp-3.c?ref=4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O\" } */\n+\n+#include <setjmp.h>\n+\n+extern void abort (void);\n+\n+jmp_buf buf;\n+\n+void raise(void)\n+{\n+  __builtin_longjmp (buf, 1);\n+}\n+\n+int execute(int cmd)\n+{\n+  int last = 0;\n+\n+  if (__builtin_setjmp (buf) == 0)\n+    while (1)\n+      {\n+        last = 1;\n+        raise ();\n+      }\n+\n+  if (last == 0)\n+    return 0;\n+  else\n+    return cmd;\n+}\n+\n+int main(void)\n+{\n+  if (execute (1) == 0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "b4a917b89076192cdf2f0c966da6a0f33edd2789", "filename": "gcc/testsuite/gcc.dg/setjmp-4.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftestsuite%2Fgcc.dg%2Fsetjmp-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftestsuite%2Fgcc.dg%2Fsetjmp-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsetjmp-4.c?ref=4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O\" } */\n+\n+#include <setjmp.h>\n+\n+extern void abort (void);\n+\n+jmp_buf buf;\n+\n+void raise(void)\n+{\n+  __builtin_longjmp (buf, 1);\n+}\n+\n+int execute(int cmd)\n+{\n+  int last = 0;\n+\n+  __builtin_setjmp (buf);\n+\n+  if (last == 0)\n+    while (1)\n+      {\n+        last = 1;\n+        raise ();\n+      }\n+\n+  if (last == 0)\n+    return 0;\n+  else\n+    return cmd;\n+}\n+\n+int main(void)\n+{\n+  if (execute (1) == 0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "46ee1b1cf17c00bd7367df3f7780b340777ee226", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 102, "deletions": 68, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "patch": "@@ -489,9 +489,8 @@ make_edges (void)\n \t      /* If this function receives a nonlocal goto, then we need to\n \t\t make edges from this call site to all the nonlocal goto\n \t\t handlers.  */\n-\t      if (TREE_SIDE_EFFECTS (last)\n-\t\t  && current_function_has_nonlocal_label)\n-\t\tmake_goto_expr_edges (bb);\n+\t      if (tree_can_make_abnormal_goto (last))\n+\t\tmake_abnormal_goto_edges (bb, true);\n \n \t      /* If this statement has reachable exception handlers, then\n \t\t create abnormal edges to them.  */\n@@ -507,10 +506,8 @@ make_edges (void)\n \t\t  /* A MODIFY_EXPR may have a CALL_EXPR on its RHS and the\n \t\t     CALL_EXPR may have an abnormal edge.  Search the RHS for\n \t\t     this case and create any required edges.  */\n-\t\t  tree op = get_call_expr_in (last);\n-\t\t  if (op && TREE_SIDE_EFFECTS (op)\n-\t\t      && current_function_has_nonlocal_label)\n-\t\t    make_goto_expr_edges (bb);\n+\t\t  if (tree_can_make_abnormal_goto (last))\n+\t\t    make_abnormal_goto_edges (bb, true);  \n \n \t\t  make_eh_edges (last);\n \t\t}\n@@ -836,76 +833,60 @@ label_to_block_fn (struct function *ifun, tree dest)\n   return VEC_index (basic_block, ifun->cfg->x_label_to_block_map, uid);\n }\n \n+/* Create edges for an abnormal goto statement at block BB.  If FOR_CALL\n+   is true, the source statement is a CALL_EXPR instead of a GOTO_EXPR.  */\n+\n+void\n+make_abnormal_goto_edges (basic_block bb, bool for_call)\n+{\n+  basic_block target_bb;\n+  block_stmt_iterator bsi;\n+\n+  FOR_EACH_BB (target_bb)\n+    for (bsi = bsi_start (target_bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+      {\n+\ttree target = bsi_stmt (bsi);\n+\n+\tif (TREE_CODE (target) != LABEL_EXPR)\n+\t  break;\n+\n+\ttarget = LABEL_EXPR_LABEL (target);\n+\n+\t/* Make an edge to every label block that has been marked as a\n+\t   potential target for a computed goto or a non-local goto.  */\n+\tif ((FORCED_LABEL (target) && !for_call)\n+\t    || (DECL_NONLOCAL (target) && for_call))\n+\t  {\n+\t    make_edge (bb, target_bb, EDGE_ABNORMAL);\n+\t    break;\n+\t  }\n+      }\n+}\n+\n /* Create edges for a goto statement at block BB.  */\n \n static void\n make_goto_expr_edges (basic_block bb)\n {\n-  tree goto_t;\n-  basic_block target_bb;\n-  bool for_call;\n   block_stmt_iterator last = bsi_last (bb);\n+  tree goto_t = bsi_stmt (last);\n \n-  goto_t = bsi_stmt (last);\n-\n-  /* If the last statement is not a GOTO (i.e., it is a RETURN_EXPR,\n-     CALL_EXPR or MODIFY_EXPR), then the edge is an abnormal edge resulting\n-     from a nonlocal goto.  */\n-  if (TREE_CODE (goto_t) != GOTO_EXPR)\n-    for_call = true;\n-  else\n+  /* A simple GOTO creates normal edges.  */\n+  if (simple_goto_p (goto_t))\n     {\n       tree dest = GOTO_DESTINATION (goto_t);\n-      for_call = false;\n-\n-      /* A GOTO to a local label creates normal edges.  */\n-      if (simple_goto_p (goto_t))\n-\t{\n-\t  edge e = make_edge (bb, label_to_block (dest), EDGE_FALLTHRU);\n+      edge e = make_edge (bb, label_to_block (dest), EDGE_FALLTHRU);\n #ifdef USE_MAPPED_LOCATION\n-\t  e->goto_locus = EXPR_LOCATION (goto_t);\n+      e->goto_locus = EXPR_LOCATION (goto_t);\n #else\n-\t  e->goto_locus = EXPR_LOCUS (goto_t);\n+      e->goto_locus = EXPR_LOCUS (goto_t);\n #endif\n-\t  bsi_remove (&last, true);\n-\t  return;\n-\t}\n-\n-      /* Nothing more to do for nonlocal gotos.  */\n-      if (TREE_CODE (dest) == LABEL_DECL)\n-\treturn;\n-\n-      /* Computed gotos remain.  */\n+      bsi_remove (&last, true);\n+      return;\n     }\n \n-  /* Look for the block starting with the destination label.  In the\n-     case of a computed goto, make an edge to any label block we find\n-     in the CFG.  */\n-  FOR_EACH_BB (target_bb)\n-    {\n-      block_stmt_iterator bsi;\n-\n-      for (bsi = bsi_start (target_bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\t{\n-\t  tree target = bsi_stmt (bsi);\n-\n-\t  if (TREE_CODE (target) != LABEL_EXPR)\n-\t    break;\n-\n-\t  if (\n-\t      /* Computed GOTOs.  Make an edge to every label block that has\n-\t\t been marked as a potential target for a computed goto.  */\n-\t      (FORCED_LABEL (LABEL_EXPR_LABEL (target)) && !for_call)\n-\t      /* Nonlocal GOTO target.  Make an edge to every label block\n-\t\t that has been marked as a potential target for a nonlocal\n-\t\t goto.  */\n-\t      || (DECL_NONLOCAL (LABEL_EXPR_LABEL (target)) && for_call))\n-\t    {\n-\t      make_edge (bb, target_bb, EDGE_ABNORMAL);\n-\t      break;\n-\t    }\n-\t}\n-    }\n+  /* A computed GOTO creates abnormal edges.  */\n+  make_abnormal_goto_edges (bb, false);\n }\n \n \n@@ -2517,13 +2498,31 @@ computed_goto_p (tree t)\n }\n \n \n-/* Checks whether EXPR is a simple local goto.  */\n+/* Return true if T is a simple local goto.  */\n+\n+bool\n+simple_goto_p (tree t)\n+{\n+  return (TREE_CODE (t) == GOTO_EXPR\n+\t  && TREE_CODE (GOTO_DESTINATION (t)) == LABEL_DECL);\n+}\n+\n+\n+/* Return true if T can make an abnormal transfer of control flow.\n+   Transfers of control flow associated with EH are excluded.  */\n \n bool\n-simple_goto_p (tree expr)\n+tree_can_make_abnormal_goto (tree t)\n {\n-  return (TREE_CODE (expr) == GOTO_EXPR\n-\t  && TREE_CODE (GOTO_DESTINATION (expr)) == LABEL_DECL);\n+  if (computed_goto_p (t))\n+    return true;\n+  if (TREE_CODE (t) == MODIFY_EXPR)\n+    t = TREE_OPERAND (t, 1);\n+  if (TREE_CODE (t) == WITH_SIZE_EXPR)\n+    t = TREE_OPERAND (t, 0);\n+  if (TREE_CODE (t) == CALL_EXPR)\n+    return TREE_SIDE_EFFECTS (t) && current_function_has_nonlocal_label;\n+  return false;\n }\n \n \n@@ -4072,7 +4071,7 @@ tree_redirect_edge_and_branch (edge e, basic_block dest)\n   edge ret;\n   tree label, stmt;\n \n-  if (e->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))\n+  if (e->flags & EDGE_ABNORMAL)\n     return NULL;\n \n   if (e->src != ENTRY_BLOCK_PTR\n@@ -5374,6 +5373,41 @@ tree_flow_call_edges_add (sbitmap blocks)\n   return blocks_split;\n }\n \n+/* Purge dead abnormal call edges from basic block BB.  */\n+\n+bool\n+tree_purge_dead_abnormal_call_edges (basic_block bb)\n+{\n+  bool changed = tree_purge_dead_eh_edges (bb);\n+\n+  if (current_function_has_nonlocal_label)\n+    {\n+      tree stmt = last_stmt (bb);\n+      edge_iterator ei;\n+      edge e;\n+\n+      if (!(stmt && tree_can_make_abnormal_goto (stmt)))\n+\tfor (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n+\t  {\n+\t    if (e->flags & EDGE_ABNORMAL)\n+\t      {\n+\t\tremove_edge (e);\n+\t\tchanged = true;\n+\t      }\n+\t    else\n+\t      ei_next (&ei);\n+\t  }\n+\n+      /* See tree_purge_dead_eh_edges below.  */\n+      if (changed)\n+\tfree_dominance_info (CDI_DOMINATORS);\n+    }\n+\n+  return changed;\n+}\n+\n+/* Purge dead EH edges from basic block BB.  */\n+\n bool\n tree_purge_dead_eh_edges (basic_block bb)\n {"}, {"sha": "f70eb774f35ae242b22dac87fd1f0fef4c5d882f", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "patch": "@@ -564,6 +564,7 @@ extern bool is_ctrl_stmt (tree);\n extern bool is_ctrl_altering_stmt (tree);\n extern bool computed_goto_p (tree);\n extern bool simple_goto_p (tree);\n+extern bool tree_can_make_abnormal_goto (tree);\n extern basic_block single_noncomplex_succ (basic_block bb);\n extern void tree_dump_bb (basic_block, FILE *, int);\n extern void debug_tree_bb (basic_block);\n@@ -596,6 +597,7 @@ extern bool tree_duplicate_sese_region (edge, edge, basic_block *, unsigned,\n \t\t\t\t\tbasic_block *);\n extern void add_phi_args_after_copy_bb (basic_block);\n extern void add_phi_args_after_copy (basic_block *, unsigned);\n+extern bool tree_purge_dead_abnormal_call_edges (basic_block);\n extern bool tree_purge_dead_eh_edges (basic_block);\n extern bool tree_purge_all_dead_eh_edges (bitmap);\n extern tree gimplify_val (block_stmt_iterator *, tree, tree);\n@@ -607,6 +609,7 @@ extern tree gimplify_build3 (block_stmt_iterator *, enum tree_code,\n \t\t\t     tree, tree, tree, tree);\n extern void init_empty_tree_cfg (void);\n extern void fold_cond_expr_cond (void);\n+extern void make_abnormal_goto_edges (basic_block, bool);\n extern void replace_uses_by (tree, tree);\n extern void start_recording_case_labels (void);\n extern void end_recording_case_labels (void);"}, {"sha": "61b1dab954db8c79c0538258f61edda32d0e7c9b", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "patch": "@@ -1930,6 +1930,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   edge e;\n   block_stmt_iterator bsi, stmt_bsi;\n   bool successfully_inlined = FALSE;\n+  bool purge_dead_abnormal_edges;\n   tree t_step;\n   tree var;\n \n@@ -2024,30 +2025,36 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n #endif\n \n   /* We will be inlining this callee.  */\n-\n   id->eh_region = lookup_stmt_eh_region (stmt);\n \n   /* Split the block holding the CALL_EXPR.  */\n-\n   e = split_block (bb, stmt);\n   bb = e->src;\n   return_block = e->dest;\n   remove_edge (e);\n \n-  /* split_block splits before the statement, work around this by moving\n-     the call into the first half_bb.  Not pretty, but seems easier than\n-     doing the CFG manipulation by hand when the CALL_EXPR is in the last\n-     statement in BB.  */\n+  /* split_block splits after the statement; work around this by\n+     moving the call into the second block manually.  Not pretty,\n+     but seems easier than doing the CFG manipulation by hand\n+     when the CALL_EXPR is in the last statement of BB.  */\n   stmt_bsi = bsi_last (bb);\n+  bsi_remove (&stmt_bsi, false);\n+\n+  /* If the CALL_EXPR was in the last statement of BB, it may have\n+     been the source of abnormal edges.  In this case, schedule\n+     the removal of dead abnormal edges.  */\n   bsi = bsi_start (return_block);\n-  if (!bsi_end_p (bsi))\n-    bsi_move_before (&stmt_bsi, &bsi);\n-  else\n+  if (bsi_end_p (bsi))\n     {\n-      tree stmt = bsi_stmt (stmt_bsi);\n-      bsi_remove (&stmt_bsi, false);\n       bsi_insert_after (&bsi, stmt, BSI_NEW_STMT);\n+      purge_dead_abnormal_edges = true;\n     }\n+  else\n+    {\n+      bsi_insert_before (&bsi, stmt, BSI_NEW_STMT);\n+      purge_dead_abnormal_edges = false;\n+    }\n+\n   stmt_bsi = bsi_start (return_block);\n \n   /* Build a block containing code to initialize the arguments, the\n@@ -2147,9 +2154,8 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n        tsi_delink() will leave the iterator in a sane state.  */\n     bsi_remove (&stmt_bsi, true);\n \n-  bsi_next (&bsi);\n-  if (bsi_end_p (bsi))\n-    tree_purge_dead_eh_edges (return_block);\n+  if (purge_dead_abnormal_edges)\n+    tree_purge_dead_abnormal_call_edges (return_block);\n \n   /* If the value of the new expression is ignored, that's OK.  We\n      don't warn about this for CALL_EXPRs, so we shouldn't warn about"}, {"sha": "50dd22b451fa4f3872ddfc1967510ca56d0cb2f3", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "patch": "@@ -237,9 +237,26 @@ struct tree_opt_pass pass_free_cfg_annotations =\n   0,\t\t\t\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n-/* Pass: fixup_cfg - IPA passes or compilation of earlier functions might've\n-   changed some properties - such as marked functions nothrow.  Remove now\n-   redundant edges and basic blocks.  */\n+\n+/* Return true if BB has at least one abnormal outgoing edge.  */\n+\n+static inline bool\n+has_abnormal_outgoing_edge_p (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (e->flags & EDGE_ABNORMAL)\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Pass: fixup_cfg.  IPA passes, compilation of earlier functions or inlining\n+   might have changed some properties, such as marked functions nothrow or\n+   added calls that can potentially go to non-local labels.  Remove redundant\n+   edges and basic blocks, and create new ones if necessary.  */\n \n static unsigned int\n execute_fixup_cfg (void)\n@@ -262,8 +279,37 @@ execute_fixup_cfg (void)\n \t  }\n \ttree_purge_dead_eh_edges (bb);\n       }\n-    \n+\n+  if (current_function_has_nonlocal_label)\n+    FOR_EACH_BB (bb)\n+      {\n+\tfor (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t  {\n+\t    tree stmt = bsi_stmt (bsi);\n+\t    if (tree_can_make_abnormal_goto (stmt))\n+\t      {\n+\t\tif (stmt == bsi_stmt (bsi_last (bb)))\n+\t\t  {\n+\t\t    if (!has_abnormal_outgoing_edge_p (bb))\n+\t\t      make_abnormal_goto_edges (bb, true);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    edge e = split_block (bb, stmt);\n+\t\t    bb = e->src;\n+\t\t    make_abnormal_goto_edges (bb, true);\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+\n   cleanup_tree_cfg ();\n+\n+  /* Dump a textual representation of the flowgraph.  */\n+  if (dump_file)\n+    dump_tree_cfg (dump_file, dump_flags);\n+\n   return 0;\n }\n \n@@ -280,7 +326,7 @@ struct tree_opt_pass pass_fixup_cfg =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func,\t\t\t/* todo_flags_finish */\n+  0,\t\t\t\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n "}, {"sha": "e838ba1d632c67e71ee6b47702f62fe81a9ac1bd", "filename": "gcc/tree.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "patch": "@@ -6714,6 +6714,26 @@ build_common_builtin_nodes (void)\n \t\t\t\"__builtin_nonlocal_goto\",\n \t\t\tECF_NORETURN | ECF_NOTHROW);\n \n+  tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);\n+  tmp = tree_cons (NULL_TREE, ptr_type_node, tmp);\n+  ftype = build_function_type (void_type_node, tmp);\n+  local_define_builtin (\"__builtin_setjmp_setup\", ftype,\n+\t\t\tBUILT_IN_SETJMP_SETUP,\n+\t\t\t\"__builtin_setjmp_setup\", ECF_NOTHROW);\n+\n+  tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);\n+  ftype = build_function_type (ptr_type_node, tmp);\n+  local_define_builtin (\"__builtin_setjmp_dispatcher\", ftype,\n+\t\t\tBUILT_IN_SETJMP_DISPATCHER,\n+\t\t\t\"__builtin_setjmp_dispatcher\",\n+\t\t\tECF_PURE | ECF_NOTHROW);\n+\n+  tmp = tree_cons (NULL_TREE, ptr_type_node, void_list_node);\n+  ftype = build_function_type (void_type_node, tmp);\n+  local_define_builtin (\"__builtin_setjmp_receiver\", ftype,\n+\t\t\tBUILT_IN_SETJMP_RECEIVER,\n+\t\t\t\"__builtin_setjmp_receiver\", ECF_NOTHROW);\n+\n   ftype = build_function_type (ptr_type_node, void_list_node);\n   local_define_builtin (\"__builtin_stack_save\", ftype, BUILT_IN_STACK_SAVE,\n \t\t\t\"__builtin_stack_save\", ECF_NOTHROW);"}, {"sha": "e1a62c9e02524cc270669e4b054925f763101998", "filename": "gcc/unwind-sjlj.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Funwind-sjlj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573/gcc%2Funwind-sjlj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-sjlj.c?ref=4f6c213142e5ce6f5ee17ef5d0f1cb85cd0ff573", "patch": "@@ -1,5 +1,5 @@\n /* SJLJ exception handling and frame unwind runtime interface routines.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006\n    Free Software Foundation, Inc.\n \n    This file is part of GCC.\n@@ -45,10 +45,14 @@ typedef void *jmp_buf[JMP_BUF_SIZE];\n extern void longjmp(jmp_buf, int) __attribute__((noreturn));\n #endif\n #else\n-#define setjmp __builtin_setjmp\n #define longjmp __builtin_longjmp\n #endif\n \n+/* The setjmp side is dealt with in the except.c file.  */\n+#undef setjmp\n+#define setjmp setjmp_should_not_be_used_in_this_file\n+\n+\n /* This structure is allocated on the stack of the target function.\n    This must match the definition created in except.c:init_eh.  */\n struct SjLj_Function_Context"}]}