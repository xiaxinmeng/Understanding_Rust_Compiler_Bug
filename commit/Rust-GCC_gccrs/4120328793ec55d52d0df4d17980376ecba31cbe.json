{"sha": "4120328793ec55d52d0df4d17980376ecba31cbe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDEyMDMyODc5M2VjNTVkNTJkMGRmNGQxNzk4MDM3NmVjYmEzMWNiZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2014-05-21T09:29:34Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2014-05-21T09:29:34Z"}, "message": "Improve reload code generation by ignoring init insns for reloads.\n\n    \t* reload1.c (remove_init_insns, will_delete_init_insn_p): New static\n    \tfunctions.\n    \t(reload, calculate_needs_all_insns, reload_as_needed): Use them.\n\nFrom-SVN: r210685", "tree": {"sha": "77fb31b7521622814daf1b72a017853d5b55a7cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77fb31b7521622814daf1b72a017853d5b55a7cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4120328793ec55d52d0df4d17980376ecba31cbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4120328793ec55d52d0df4d17980376ecba31cbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4120328793ec55d52d0df4d17980376ecba31cbe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4120328793ec55d52d0df4d17980376ecba31cbe/comments", "author": null, "committer": null, "parents": [{"sha": "0836b77f3d4aa937d0a60dd292301a1021fa5272", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0836b77f3d4aa937d0a60dd292301a1021fa5272", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0836b77f3d4aa937d0a60dd292301a1021fa5272"}], "stats": {"total": 105, "additions": 68, "deletions": 37}, "files": [{"sha": "bfa1ec7eb63d4eb63d6c157d37ededb157ede5e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4120328793ec55d52d0df4d17980376ecba31cbe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4120328793ec55d52d0df4d17980376ecba31cbe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4120328793ec55d52d0df4d17980376ecba31cbe", "patch": "@@ -198,6 +198,10 @@\n \n 2014-05-19  Bernd Schmidt  <bernds@codesourcery.com>\n \n+\t* reload1.c (remove_init_insns, will_delete_init_insn_p): New static\n+\tfunctions.\n+\t(reload, calculate_needs_all_insns, reload_as_needed): Use them.\n+\n \t* simplify-rtx.c (simplify_unary_operation_1): Use CONST_INT_P in\n \tshift simplification where it was intended.\n "}, {"sha": "9daafa45097fc16714b10db6ef463900e2255dec", "filename": "gcc/reload1.c", "status": "modified", "additions": 64, "deletions": 37, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4120328793ec55d52d0df4d17980376ecba31cbe/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4120328793ec55d52d0df4d17980376ecba31cbe/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=4120328793ec55d52d0df4d17980376ecba31cbe", "patch": "@@ -686,6 +686,65 @@ static int failure;\n /* Temporary array of pseudo-register number.  */\n static int *temp_pseudo_reg_arr;\n \n+/* If a pseudo has no hard reg, delete the insns that made the equivalence.\n+   If that insn didn't set the register (i.e., it copied the register to\n+   memory), just delete that insn instead of the equivalencing insn plus\n+   anything now dead.  If we call delete_dead_insn on that insn, we may\n+   delete the insn that actually sets the register if the register dies\n+   there and that is incorrect.  */\n+static void\n+remove_init_insns ()\n+{\n+  for (int i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+    {\n+      if (reg_renumber[i] < 0 && reg_equiv_init (i) != 0)\n+\t{\n+\t  rtx list;\n+\t  for (list = reg_equiv_init (i); list; list = XEXP (list, 1))\n+\t    {\n+\t      rtx equiv_insn = XEXP (list, 0);\n+\n+\t      /* If we already deleted the insn or if it may trap, we can't\n+\t\t delete it.  The latter case shouldn't happen, but can\n+\t\t if an insn has a variable address, gets a REG_EH_REGION\n+\t\t note added to it, and then gets converted into a load\n+\t\t from a constant address.  */\n+\t      if (NOTE_P (equiv_insn)\n+\t\t  || can_throw_internal (equiv_insn))\n+\t\t;\n+\t      else if (reg_set_p (regno_reg_rtx[i], PATTERN (equiv_insn)))\n+\t\tdelete_dead_insn (equiv_insn);\n+\t      else\n+\t\tSET_INSN_DELETED (equiv_insn);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Return true if remove_init_insns will delete INSN.  */\n+static bool\n+will_delete_init_insn_p (rtx insn)\n+{\n+  rtx set = single_set (insn);\n+  if (!set || !REG_P (SET_DEST (set)))\n+    return false;\n+  unsigned regno = REGNO (SET_DEST (set));\n+\n+  if (can_throw_internal (insn))\n+    return false;\n+\n+  if (regno < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n+    return false;\n+\n+  for (rtx list = reg_equiv_init (regno); list; list = XEXP (list, 1))\n+    {\n+      rtx equiv_insn = XEXP (list, 0);\n+      if (equiv_insn == insn)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Main entry point for the reload pass.\n \n    FIRST is the first insn of the function being compiled.\n@@ -993,37 +1052,7 @@ reload (rtx first, int global)\n       if (ep->can_eliminate)\n \tmark_elimination (ep->from, ep->to);\n \n-  /* If a pseudo has no hard reg, delete the insns that made the equivalence.\n-     If that insn didn't set the register (i.e., it copied the register to\n-     memory), just delete that insn instead of the equivalencing insn plus\n-     anything now dead.  If we call delete_dead_insn on that insn, we may\n-     delete the insn that actually sets the register if the register dies\n-     there and that is incorrect.  */\n-\n-  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    {\n-      if (reg_renumber[i] < 0 && reg_equiv_init (i) != 0)\n-\t{\n-\t  rtx list;\n-\t  for (list = reg_equiv_init (i); list; list = XEXP (list, 1))\n-\t    {\n-\t      rtx equiv_insn = XEXP (list, 0);\n-\n-\t      /* If we already deleted the insn or if it may trap, we can't\n-\t\t delete it.  The latter case shouldn't happen, but can\n-\t\t if an insn has a variable address, gets a REG_EH_REGION\n-\t\t note added to it, and then gets converted into a load\n-\t\t from a constant address.  */\n-\t      if (NOTE_P (equiv_insn)\n-\t\t  || can_throw_internal (equiv_insn))\n-\t\t;\n-\t      else if (reg_set_p (regno_reg_rtx[i], PATTERN (equiv_insn)))\n-\t\tdelete_dead_insn (equiv_insn);\n-\t      else\n-\t\tSET_INSN_DELETED (equiv_insn);\n-\t    }\n-\t}\n-    }\n+  remove_init_insns ();\n \n   /* Use the reload registers where necessary\n      by generating move instructions to move the must-be-register\n@@ -1484,14 +1513,9 @@ calculate_needs_all_insns (int global)\n \t  rtx old_notes = REG_NOTES (insn);\n \t  int did_elimination = 0;\n \t  int operands_changed = 0;\n-\t  rtx set = single_set (insn);\n \n \t  /* Skip insns that only set an equivalence.  */\n-\t  if (set && REG_P (SET_DEST (set))\n-\t      && reg_renumber[REGNO (SET_DEST (set))] < 0\n-\t      && (reg_equiv_constant (REGNO (SET_DEST (set)))\n-\t\t  || (reg_equiv_invariant (REGNO (SET_DEST (set)))))\n-\t\t      && reg_equiv_init (REGNO (SET_DEST (set))))\n+\t  if (will_delete_init_insn_p (insn))\n \t    continue;\n \n \t  /* If needed, eliminate any eliminable registers.  */\n@@ -4586,6 +4610,9 @@ reload_as_needed (int live_known)\n       rtx old_prev = PREV_INSN (insn);\n #endif\n \n+      if (will_delete_init_insn_p (insn))\n+\tcontinue;\n+\n       /* If we pass a label, copy the offsets from the label information\n \t into the current offsets of each elimination.  */\n       if (LABEL_P (insn))"}]}