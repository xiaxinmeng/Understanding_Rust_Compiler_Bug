{"sha": "04b98fd2ed2305e477e2511fc5f4a07e440cf71b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRiOThmZDJlZDIzMDVlNDc3ZTI1MTFmYzVmNGEwN2U0NDBjZjcxYg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-03-09T14:41:17Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2010-03-09T14:41:17Z"}, "message": "re PR fortran/43265 (No EOF condition if reading with '(x)' from an empty file)\n\n2010-03-09  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libfortran/43265\n\t* io/read.c: Include fbuf.h and unix.h to enable lower level I/O for\n\tread_x. (read_x): Replace the use of read_sf with equivalent lower level\n\tI/O, eliminating unneeded code and handling EOF and EOR conditions.\n\t* io/io.h: Revise prototype for read_sf.\n\t* io/transfer.c (read_sf): Delete no_error parameter and all uses of it.\n\t(read_block_form): Likewise.\n\t(next_record_r): Delete wrong code call to hit_eof.\n\nFrom-SVN: r157310", "tree": {"sha": "1618576efa6cabe6dfe75dbdbe9586fc3f6b7482", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1618576efa6cabe6dfe75dbdbe9586fc3f6b7482"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04b98fd2ed2305e477e2511fc5f4a07e440cf71b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04b98fd2ed2305e477e2511fc5f4a07e440cf71b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04b98fd2ed2305e477e2511fc5f4a07e440cf71b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04b98fd2ed2305e477e2511fc5f4a07e440cf71b/comments", "author": null, "committer": null, "parents": [{"sha": "2f9b99e6c664ac542529117b198b6ebc1a56cdf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f9b99e6c664ac542529117b198b6ebc1a56cdf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f9b99e6c664ac542529117b198b6ebc1a56cdf0"}], "stats": {"total": 99, "additions": 76, "deletions": 23}, "files": [{"sha": "1f6b514430b8e57dcae50396b37dd1a4431883c9", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04b98fd2ed2305e477e2511fc5f4a07e440cf71b/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04b98fd2ed2305e477e2511fc5f4a07e440cf71b/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=04b98fd2ed2305e477e2511fc5f4a07e440cf71b", "patch": "@@ -1,3 +1,14 @@\n+2010-03-09  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libfortran/43265\n+\t* io/read.c: Include fbuf.h and unix.h to enable lower level I/O for\n+\tread_x. (read_x): Replace the use of read_sf with equivalent lower level\n+\tI/O, eliminating unneeded code and handling EOF and EOR conditions.\n+\t* io/io.h: Revise prototype for read_sf.\n+\t* io/transfer.c (read_sf): Delete no_error parameter and all uses of it.\n+\t(read_block_form): Likewise.\n+\t(next_record_r): Delete wrong code call to hit_eof.\n+\n 2010-03-08  Kai TIetz  <kai.tietz@onevision.com>\n \n \tPR/42950"}, {"sha": "8f482e63191cb68c244914d5bf984782b25539bd", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04b98fd2ed2305e477e2511fc5f4a07e440cf71b/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04b98fd2ed2305e477e2511fc5f4a07e440cf71b/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=04b98fd2ed2305e477e2511fc5f4a07e440cf71b", "patch": "@@ -642,7 +642,7 @@ internal_proto(type_name);\n extern void * read_block_form (st_parameter_dt *, int *);\n internal_proto(read_block_form);\n \n-extern char *read_sf (st_parameter_dt *, int *, int);\n+extern char *read_sf (st_parameter_dt *, int *);\n internal_proto(read_sf);\n \n extern void *write_block (st_parameter_dt *, int);"}, {"sha": "a4c4a58b7bf198b0a260cfe15cbf074443c933be", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 61, "deletions": 5, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04b98fd2ed2305e477e2511fc5f4a07e440cf71b/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04b98fd2ed2305e477e2511fc5f4a07e440cf71b/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=04b98fd2ed2305e477e2511fc5f4a07e440cf71b", "patch": "@@ -24,7 +24,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"io.h\"\n+#include \"fbuf.h\"\n #include \"format.h\"\n+#include \"unix.h\"\n #include <string.h>\n #include <errno.h>\n #include <ctype.h>\n@@ -1022,16 +1024,70 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n  * and never look at it. */\n \n void\n-read_x (st_parameter_dt * dtp, int n)\n+read_x (st_parameter_dt *dtp, int n)\n {\n+  int length;\n+  char *p, q;\n+\n   if ((dtp->u.p.current_unit->pad_status == PAD_NO || is_internal_unit (dtp))\n        && dtp->u.p.current_unit->bytes_left < n)\n     n = dtp->u.p.current_unit->bytes_left;\n+    \n+  if (n == 0)\n+    return;\n \n-  dtp->u.p.sf_read_comma = 0;\n-  if (n > 0)\n-    read_sf (dtp, &n, 1);\n-  dtp->u.p.sf_read_comma = 1;\n+  length = n;\n+\n+  if (is_internal_unit (dtp))\n+    {\n+      p = mem_alloc_r (dtp->u.p.current_unit->s, &length);\n+      if (unlikely (length < n))\n+\tn = length;\n+      goto done;\n+    }\n+\n+  p = fbuf_read (dtp->u.p.current_unit, &length);\n+  if (p == NULL || (length == 0 && dtp->u.p.item_count == 1))\n+    {\n+      hit_eof (dtp);\n+      return;\n+    }\n+\n+  n = 0;\n+  while (n < length)\n+    {\n+      q = *p;\n+      if (q == '\\n' || q == '\\r')\n+\t{\n+\t  /* Unexpected end of line. Set the position.  */\n+\t  fbuf_seek (dtp->u.p.current_unit, n + 1 ,SEEK_CUR);\n+\t  dtp->u.p.sf_seen_eor = 1;\n+\n+\t  /* If we encounter a CR, it might be a CRLF.  */\n+\t  if (q == '\\r') /* Probably a CRLF */\n+\t    {\n+\t      /* See if there is an LF. Use fbuf_read rather then fbuf_getc so\n+\t\t the position is not advanced unless it really is an LF.  */\n+\t      int readlen = 1;\n+\t      p = fbuf_read (dtp->u.p.current_unit, &readlen);\n+\t      if (*p == '\\n' && readlen == 1)\n+\t        {\n+\t\t  dtp->u.p.sf_seen_eor = 2;\n+\t\t  fbuf_seek (dtp->u.p.current_unit, 1 ,SEEK_CUR);\n+\t\t}\n+\t    }\n+\t  goto done;\n+\t}\n+      n++;\n+      p++;\n+    } \n+\n+  fbuf_seek (dtp->u.p.current_unit, n, SEEK_CUR);\n+  \n+ done:\n+  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n+    dtp->u.p.size_used += (GFC_IO_INT) n;\n+  dtp->u.p.current_unit->bytes_left -= n;\n   dtp->u.p.current_unit->strm_pos += (gfc_offset) n;\n }\n "}, {"sha": "c5d26a5973f34b46910f29bffb0053b481ffea35", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04b98fd2ed2305e477e2511fc5f4a07e440cf71b/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04b98fd2ed2305e477e2511fc5f4a07e440cf71b/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=04b98fd2ed2305e477e2511fc5f4a07e440cf71b", "patch": "@@ -192,22 +192,12 @@ current_mode (st_parameter_dt *dtp)\n    heap.  Hopefully this won't happen very often.  */\n \n char *\n-read_sf (st_parameter_dt *dtp, int * length, int no_error)\n+read_sf (st_parameter_dt *dtp, int * length)\n {\n   static char *empty_string[0];\n   char *base, *p, q;\n   int n, lorig, memread, seen_comma;\n \n-  /* If we hit EOF previously with the no_error flag set (i.e. X, T,\n-     TR edit descriptors), and we now try to read again, this time\n-     without setting no_error.  */\n-  if (!no_error && dtp->u.p.at_eof)\n-    {\n-      *length = 0;\n-      hit_eof (dtp);\n-      return NULL;\n-    }\n-\n   /* If we have seen an eor previously, return a length of 0.  The\n      caller is responsible for correctly padding the input field.  */\n   if (dtp->u.p.sf_seen_eor)\n@@ -273,8 +263,6 @@ read_sf (st_parameter_dt *dtp, int * length, int no_error)\n \t     so we can just continue with a short read.  */\n \t  if (dtp->u.p.current_unit->pad_status == PAD_NO)\n \t    {\n-\t      if (likely (no_error))\n-\t\tbreak;\n \t      generate_error (&dtp->common, LIBERROR_EOR, NULL);\n \t      return NULL;\n \t    }\n@@ -304,7 +292,7 @@ read_sf (st_parameter_dt *dtp, int * length, int no_error)\n      some other stuff. Set the relevant flags.  */\n   if (lorig > *length && !dtp->u.p.sf_seen_eor && !seen_comma)\n     {\n-      if (n > 0 || no_error)\n+      if (n > 0)\n         {\n \t  if (dtp->u.p.advance_status == ADVANCE_NO)\n \t    {\n@@ -386,7 +374,7 @@ read_block_form (st_parameter_dt *dtp, int * nbytes)\n       (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL ||\n        dtp->u.p.current_unit->flags.access == ACCESS_STREAM))\n     {\n-      source = read_sf (dtp, nbytes, 0);\n+      source = read_sf (dtp, nbytes);\n       dtp->u.p.current_unit->strm_pos +=\n \t(gfc_offset) (*nbytes + dtp->u.p.sf_seen_eor);\n       return source;\n@@ -2822,8 +2810,6 @@ next_record_r (st_parameter_dt *dtp)\n \t\t{\n                   if (errno != 0)\n                     generate_error (&dtp->common, LIBERROR_OS, NULL);\n-                  else\n-                    hit_eof (dtp);\n \t\t  break;\n                 }\n \t      "}]}