{"sha": "7c775aca298673f95dddfb8605f11b0e2f236361", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M3NzVhY2EyOTg2NzNmOTVkZGRmYjg2MDVmMTFiMGUyZjIzNjM2MQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-01-18T11:10:42Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-01-18T11:10:42Z"}, "message": "ada-tree.h (TYPE_IMPLEMENTS_PACKED_ARRAY_P): Rename to\n\n\t* gcc-interface/ada-tree.h (TYPE_IMPLEMENTS_PACKED_ARRAY_P): Rename to\n\t(TYPE_IMPL_PACKED_ARRAY_P): ...this.\n\t(TYPE_CAN_HAVE_DEBUG_TYPE_P): Do not test TYPE_DEBUG_TYPE.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Simplify NULL_TREE tests\n\tand tweak gnat_encodings tests throughout.\n\t(initial_value_needs_conversion): Likewise.\n\t(intrin_arglists_compatible_p): Likewise.\n\t* gcc-interface/misc.c (gnat_print_type): Likewise.\n\t(gnat_get_debug_type): Likewise.\n\t(gnat_get_fixed_point_type_info): Likewise.\n\t(gnat_get_array_descr_info): Likewise.\n\t(get_array_bit_stride): Likewise.\n\t(gnat_get_type_bias): Fix formatting.\n\t(enumerate_modes): Likewise.\n\t* gcc-interface/trans.c (gnat_to_gnu): Likewise.\n\t(add_decl_expr): Simplify NULL_TREE test.\n\t(end_stmt_group): Likewise.\n\t(build_binary_op_trapv): Fix formatting.\n\t(get_exception_label): Use switch statement.\n\t(init_code_table): Move around.\n\t* gcc-interface/utils.c (global_bindings_p): Simplify NULL_TREE test.\n\t(gnat_poplevel): Likewise.\n\t(gnat_set_type_context): Likewise.\n\t(defer_or_set_type_context): Fix formatting.\n\t(gnat_pushdecl): Simplify NULL_TREE test.\n\t(maybe_pad_type): Likewise.\n\t(add_parallel_type): Likewise.\n\t(create_range_type): Likewise.\n\t(process_deferred_decl_context): Likewise.\n\t(convert): Likewise.\n\t(def_builtin_1): Likewise.\n\t* gcc-interface/utils2.c (find_common_type): Likewise.\n\t(build_binary_op): Likewise.\n\t(gnat_rewrite_reference): Likewise.\n\t(get_inner_constant_reference): Likewise.\n\nFrom-SVN: r232501", "tree": {"sha": "0bffe85bad394e4bb7306e24515f3f47f8dfe5d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bffe85bad394e4bb7306e24515f3f47f8dfe5d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c775aca298673f95dddfb8605f11b0e2f236361", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c775aca298673f95dddfb8605f11b0e2f236361", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c775aca298673f95dddfb8605f11b0e2f236361", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c775aca298673f95dddfb8605f11b0e2f236361/comments", "author": null, "committer": null, "parents": [{"sha": "3dd5f42e90fa6e296d233b0f05c3a760a45d1313", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dd5f42e90fa6e296d233b0f05c3a760a45d1313", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dd5f42e90fa6e296d233b0f05c3a760a45d1313"}], "stats": {"total": 357, "additions": 198, "deletions": 159}, "files": [{"sha": "0c280d82ff62fbe1e260437ed9eeccc4bdca1dea", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c775aca298673f95dddfb8605f11b0e2f236361/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c775aca298673f95dddfb8605f11b0e2f236361/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7c775aca298673f95dddfb8605f11b0e2f236361", "patch": "@@ -1,3 +1,41 @@\n+2016-01-18  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (TYPE_IMPLEMENTS_PACKED_ARRAY_P): Rename to\n+\t(TYPE_IMPL_PACKED_ARRAY_P): ...this.\n+\t(TYPE_CAN_HAVE_DEBUG_TYPE_P): Do not test TYPE_DEBUG_TYPE.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Simplify NULL_TREE tests\n+\tand tweak gnat_encodings tests throughout.\n+\t(initial_value_needs_conversion): Likewise.\n+\t(intrin_arglists_compatible_p): Likewise.\n+\t* gcc-interface/misc.c (gnat_print_type): Likewise.\n+\t(gnat_get_debug_type): Likewise.\n+\t(gnat_get_fixed_point_type_info): Likewise.\n+\t(gnat_get_array_descr_info): Likewise.\n+\t(get_array_bit_stride): Likewise.\n+\t(gnat_get_type_bias): Fix formatting.\n+\t(enumerate_modes): Likewise.\n+\t* gcc-interface/trans.c (gnat_to_gnu): Likewise.\n+\t(add_decl_expr): Simplify NULL_TREE test.\n+\t(end_stmt_group): Likewise.\n+\t(build_binary_op_trapv): Fix formatting.\n+\t(get_exception_label): Use switch statement.\n+\t(init_code_table): Move around.\n+\t* gcc-interface/utils.c (global_bindings_p): Simplify NULL_TREE test.\n+\t(gnat_poplevel): Likewise.\n+\t(gnat_set_type_context): Likewise.\n+\t(defer_or_set_type_context): Fix formatting.\n+\t(gnat_pushdecl): Simplify NULL_TREE test.\n+\t(maybe_pad_type): Likewise.\n+\t(add_parallel_type): Likewise.\n+\t(create_range_type): Likewise.\n+\t(process_deferred_decl_context): Likewise.\n+\t(convert): Likewise.\n+\t(def_builtin_1): Likewise.\n+\t* gcc-interface/utils2.c (find_common_type): Likewise.\n+\t(build_binary_op): Likewise.\n+\t(gnat_rewrite_reference): Likewise.\n+\t(get_inner_constant_reference): Likewise.\n+\n 2016-01-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR ada/69219"}, {"sha": "ceabd175ae46407c4442e61f45cb0474b4ce8333", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c775aca298673f95dddfb8605f11b0e2f236361/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c775aca298673f95dddfb8605f11b0e2f236361/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=7c775aca298673f95dddfb8605f11b0e2f236361", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2015, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2016, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -189,14 +189,12 @@ do {\t\t\t\t\t\t\t \\\n \n /* True for types that implement a packed array and for original packed array\n    types.  */\n-#define TYPE_IMPLEMENTS_PACKED_ARRAY_P(NODE) \\\n-  ((TREE_CODE (NODE) == ARRAY_TYPE && TYPE_PACKED (NODE))\t\t      \\\n-    || (TREE_CODE (NODE) == INTEGER_TYPE && TYPE_PACKED_ARRAY_TYPE_P (NODE))) \\\n+#define TYPE_IMPL_PACKED_ARRAY_P(NODE) \\\n+  ((TREE_CODE (NODE) == ARRAY_TYPE && TYPE_PACKED (NODE)) \\\n+   || (TREE_CODE (NODE) == INTEGER_TYPE && TYPE_PACKED_ARRAY_TYPE_P (NODE)))\n \n /* True for types that can hold a debug type.  */\n-#define TYPE_CAN_HAVE_DEBUG_TYPE_P(NODE)  \\\n- (!TYPE_IMPLEMENTS_PACKED_ARRAY_P (NODE)  \\\n-  && TYPE_DEBUG_TYPE (NODE) != NULL_TREE)\n+#define TYPE_CAN_HAVE_DEBUG_TYPE_P(NODE) (!TYPE_IMPL_PACKED_ARRAY_P (NODE))\n \n /* For an UNCONSTRAINED_ARRAY_TYPE, this is the record containing both the\n    template and the object.\n@@ -385,8 +383,8 @@ do {\t\t\t\t\t\t   \\\n #define SET_TYPE_DEBUG_TYPE(NODE, X) \\\n   SET_TYPE_LANG_SPECIFIC2 (NODE, X)\n \n-/* For types with TYPE_IMPLEMENTS_PACKED_ARRAY_P, this is the original packed\n-   array type.  Note that this predicate is trou for original packed array\n+/* For types with TYPE_IMPL_PACKED_ARRAY_P, this is the original packed\n+   array type.  Note that this predicate is true for original packed array\n    types, so these cannot have a debug type.  */\n #define TYPE_ORIGINAL_PACKED_ARRAY(NODE) \\\n   GET_TYPE_LANG_SPECIFIC2 (NODE)"}, {"sha": "34e9e91f6eae2c6b04f03815d5d836fbc1f59658", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c775aca298673f95dddfb8605f11b0e2f236361/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c775aca298673f95dddfb8605f11b0e2f236361/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=7c775aca298673f95dddfb8605f11b0e2f236361", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2015, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2016, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -1002,7 +1002,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t\t/* We cannot evaluate the first arm of a COMPOUND_EXPR in the\n \t\t   correct place for this case, hence the above test.  */\n-\t\tgcc_assert (init == NULL_TREE);\n+\t\tgcc_assert (!init);\n \n \t\t/* No DECL_EXPR will be created so the expression needs to be\n \t\t   marked manually because it will likely be shared.  */\n@@ -2551,14 +2551,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t types, are biased or are wider than sizetype.  These are GNAT\n \t\t encodings, so we have to include them only when all encodings\n \t\t are requested.  */\n-\t      if (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL\n-\t\t  && (TREE_CODE (gnu_orig_min) != INTEGER_CST\n-\t\t      || TREE_CODE (gnu_orig_max) != INTEGER_CST\n-\t\t      || TREE_CODE (gnu_index_type) != INTEGER_TYPE\n-\t\t      || (TREE_TYPE (gnu_index_type)\n-\t\t\t  && TREE_CODE (TREE_TYPE (gnu_index_type))\n-\t\t\t     != INTEGER_TYPE)\n-\t\t      || TYPE_BIASED_REPRESENTATION_P (gnu_index_type)))\n+\t      if ((TREE_CODE (gnu_orig_min) != INTEGER_CST\n+\t\t   || TREE_CODE (gnu_orig_max) != INTEGER_CST\n+\t\t   || TREE_CODE (gnu_index_type) != INTEGER_TYPE\n+\t\t   || (TREE_TYPE (gnu_index_type)\n+\t\t       && TREE_CODE (TREE_TYPE (gnu_index_type))\n+\t\t\t  != INTEGER_TYPE)\n+\t\t   || TYPE_BIASED_REPRESENTATION_P (gnu_index_type))\n+\t\t  && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n \t\tneed_index_type_struct = true;\n \t    }\n \n@@ -2621,8 +2621,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    }\n \n \t  /* Strip the ___XP suffix for standard DWARF.  */\n-\t  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL\n-\t      && Is_Packed_Array_Impl_Type (gnat_entity))\n+\t  if (Is_Packed_Array_Impl_Type (gnat_entity)\n+\t      && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n \t    {\n \t      Entity_Id gnat_original_array_type\n \t\t= Underlying_Type (Original_Array_Type (gnat_entity));\n@@ -2717,8 +2717,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t{\n \t\t  tree gnu_base_decl\n \t\t    = gnat_to_gnu_entity (Etype (gnat_entity), NULL_TREE, 0);\n-\t\t  if (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL\n-\t\t      && !DECL_ARTIFICIAL (gnu_base_decl))\n+\t\t  if (!DECL_ARTIFICIAL (gnu_base_decl)\n+\t\t      && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n \t\t    add_parallel_type (gnu_type,\n \t\t\t\t       TREE_TYPE (TREE_TYPE (gnu_base_decl)));\n \t\t}\n@@ -4279,7 +4279,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t&& Present (gnat_renamed)\n \t\t&& (Ekind (gnat_renamed) == E_Function\n \t\t    || Ekind (gnat_renamed) == E_Procedure)\n-\t\t&& gnu_decl != NULL_TREE\n+\t\t&& gnu_decl\n \t\t&& TREE_CODE (gnu_decl) == FUNCTION_DECL)\n \t      {\n \t\ttree decl = build_decl (input_location, IMPORTED_DECL,\n@@ -4306,7 +4306,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       to let developers be notified on demand without risking false\n \t       positives with common default sets of options.  */\n \n-\t    if (gnu_builtin_decl == NULL_TREE && warn_shadow)\n+\t    if (!gnu_builtin_decl && warn_shadow)\n \t      post_error (\"?gcc intrinsic not found for&!\", gnat_entity);\n \t  }\n \n@@ -6171,8 +6171,8 @@ initial_value_needs_conversion (tree gnu_type, tree gnu_expr)\n      without one, to keep the object simpler.  */\n   if (TREE_CODE (gnu_type) == RECORD_TYPE\n       && TREE_CODE (TREE_TYPE (gnu_expr)) == RECORD_TYPE\n-      && get_variant_part (gnu_type) != NULL_TREE\n-      && get_variant_part (TREE_TYPE (gnu_expr)) == NULL_TREE)\n+      && get_variant_part (gnu_type)\n+      && !get_variant_part (TREE_TYPE (gnu_expr)))\n     return false;\n \n   /* In all the other cases, convert the expression to the object's type.  */\n@@ -8527,17 +8527,17 @@ intrin_arglists_compatible_p (intrin_binding_t * inb)\n   /* Sequence position of the last argument we checked.  */\n   int argpos = 0;\n \n-  while (1)\n+  while (true)\n     {\n       tree ada_type = function_args_iter_cond (&ada_iter);\n       tree btin_type = function_args_iter_cond (&btin_iter);\n \n       /* If we've exhausted both lists simultaneously, we're done.  */\n-      if (ada_type == NULL_TREE && btin_type == NULL_TREE)\n+      if (!ada_type && !btin_type)\n \tbreak;\n \n       /* If one list is shorter than the other, they fail to match.  */\n-      if (ada_type == NULL_TREE || btin_type == NULL_TREE)\n+      if (!ada_type || !btin_type)\n \treturn false;\n \n       /* If we're done with the Ada args and not with the internal builtin"}, {"sha": "f051c0c0acf6fe5b37d21d6d8b49988a5d012ddd", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 45, "deletions": 48, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c775aca298673f95dddfb8605f11b0e2f236361/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c775aca298673f95dddfb8605f11b0e2f236361/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=7c775aca298673f95dddfb8605f11b0e2f236361", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                           C Implementation File                          *\n  *                                                                          *\n- *          Copyright (C) 1992-2015, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2016, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -112,8 +112,8 @@ gnat_parse_file (void)\n \n   /* ??? Call the SEH initialization routine.  This is to workaround\n   a bootstrap path problem.  The call below should be removed at some\n-  point and the SEH pointer passed to __gnat_initialize() above.  */\n-  __gnat_install_SEH_handler((void *)seh);\n+  point and the SEH pointer passed to __gnat_initialize above.  */\n+  __gnat_install_SEH_handler ((void *)seh);\n \n   /* Call the front-end elaboration procedures.  */\n   adainit ();\n@@ -528,10 +528,10 @@ gnat_print_type (FILE *file, tree node, int indent)\n       break;\n     }\n \n-  if (TYPE_CAN_HAVE_DEBUG_TYPE_P (node) && TYPE_DEBUG_TYPE (node) != NULL_TREE)\n+  if (TYPE_CAN_HAVE_DEBUG_TYPE_P (node) && TYPE_DEBUG_TYPE (node))\n     print_node_brief (file, \"debug type\", TYPE_DEBUG_TYPE (node), indent + 4);\n-  else if (TYPE_IMPLEMENTS_PACKED_ARRAY_P (node)\n-\t   && TYPE_ORIGINAL_PACKED_ARRAY (node) != NULL_TREE)\n+\n+  if (TYPE_IMPL_PACKED_ARRAY_P (node) && TYPE_ORIGINAL_PACKED_ARRAY (node))\n     print_node_brief (file, \"original packed array\",\n \t\t      TYPE_ORIGINAL_PACKED_ARRAY (node), indent + 4);\n }\n@@ -575,23 +575,25 @@ gnat_descriptive_type (const_tree type)\n     return NULL_TREE;\n }\n \n-/* Return the type to used for debugging information instead of TYPE, if any.\n+/* Return the type to be used for debugging information instead of TYPE or\n    NULL_TREE if TYPE is fine.  */\n \n static tree\n gnat_get_debug_type (const_tree type)\n {\n-  if (TYPE_CAN_HAVE_DEBUG_TYPE_P (type))\n+  if (TYPE_CAN_HAVE_DEBUG_TYPE_P (type) && TYPE_DEBUG_TYPE (type))\n     {\n       type = TYPE_DEBUG_TYPE (type);\n-      /* ??? Kludge: the get_debug_type language hook is processed after the\n-\t array descriptor language hook, so if there is an array behind this\n-\t type, the latter is supposed to handle it.  Still, we can get here\n-\t with a type we are not supposed to handle (when the DWARF back-end\n+\n+      /* ??? The get_debug_type language hook is processed after the array\n+\t descriptor language hook, so if there is an array behind this type,\n+\t the latter is supposed to handle it.  Still, we can get here with\n+\t a type we are not supposed to handle (e.g. when the DWARF back-end\n \t processes the type of a variable), so keep this guard.  */\n-      if (type != NULL_TREE && !TYPE_IMPLEMENTS_PACKED_ARRAY_P (type))\n+      if (type && TYPE_CAN_HAVE_DEBUG_TYPE_P (type))\n \treturn const_cast<tree> (type);\n     }\n+\n   return NULL_TREE;\n }\n \n@@ -606,8 +608,8 @@ gnat_get_fixed_point_type_info (const_tree type,\n \n   /* GDB cannot handle fixed-point types yet, so rely on GNAT encodings\n      instead for it.  */\n-  if (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL\n-      || !TYPE_IS_FIXED_POINT_P (type))\n+  if (!TYPE_IS_FIXED_POINT_P (type)\n+      || gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n     return false;\n \n   scale_factor = TYPE_SCALE_FACTOR (type);\n@@ -640,6 +642,7 @@ gnat_get_fixed_point_type_info (const_tree type,\n \t  gcc_assert (num == integer_one_node\n \t\t      && TREE_CODE (base) == INTEGER_CST\n \t\t      && TREE_CODE (exponent) == INTEGER_CST);\n+\n \t  switch (tree_to_shwi (base))\n \t    {\n \t    case 2:\n@@ -661,6 +664,7 @@ gnat_get_fixed_point_type_info (const_tree type,\n \t expect N / D with constant operands.  */\n       gcc_assert (TREE_CODE (num) == INTEGER_CST\n \t\t  && TREE_CODE (den) == INTEGER_CST);\n+\n       info->scale_factor_kind = fixed_point_scale_factor_arbitrary;\n       info->scale_factor.arbitrary.numerator = tree_to_uhwi (num);\n       info->scale_factor.arbitrary.denominator = tree_to_shwi (den);\n@@ -746,7 +750,7 @@ gnat_type_max_size (const_tree gnu_type)\n   return max_unitsize;\n }\n \n-static tree get_array_bit_stride (tree comp_type);\n+static tree get_array_bit_stride (tree);\n \n /* Provide information in INFO for debug output about the TYPE array type.\n    Return whether TYPE is handled.  */\n@@ -759,9 +763,7 @@ gnat_get_array_descr_info (const_tree const_type,\n   bool is_array = false;\n   bool is_fat_ptr = false;\n   bool is_packed_array = false;\n-\n   tree type = const_cast<tree> (const_type);\n-\n   const_tree first_dimen = NULL_TREE;\n   const_tree last_dimen = NULL_TREE;\n   const_tree dimen;\n@@ -774,18 +776,16 @@ gnat_get_array_descr_info (const_tree const_type,\n   tree thinptr_template_expr = NULL_TREE;\n   tree thinptr_bound_field = NULL_TREE;\n \n-  /* ??? Kludge: see gnat_get_debug_type.  */\n-  if (TYPE_CAN_HAVE_DEBUG_TYPE_P (type)\n-      && TYPE_DEBUG_TYPE (type) != NULL_TREE)\n+  /* ??? See gnat_get_debug_type.  */\n+  if (TYPE_CAN_HAVE_DEBUG_TYPE_P (type) && TYPE_DEBUG_TYPE (type))\n     type = TYPE_DEBUG_TYPE (type);\n \n   /* If we have an implementation type for a packed array, get the orignial\n      array type.  */\n-  if (TYPE_IMPLEMENTS_PACKED_ARRAY_P (type)\n-      && TYPE_ORIGINAL_PACKED_ARRAY (type) != NULL_TREE)\n+  if (TYPE_IMPL_PACKED_ARRAY_P (type) && TYPE_ORIGINAL_PACKED_ARRAY (type))\n     {\n-      is_packed_array = true;\n       type = TYPE_ORIGINAL_PACKED_ARRAY (type);\n+      is_packed_array = true;\n     }\n \n   /* First pass: gather all information about this array except everything\n@@ -801,8 +801,8 @@ gnat_get_array_descr_info (const_tree const_type,\n       info->data_location = NULL_TREE;\n     }\n \n-  else if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL\n-\t   && TYPE_IS_FAT_POINTER_P (type))\n+  else if (TYPE_IS_FAT_POINTER_P (type)\n+\t   && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n     {\n       const tree ua_type = TYPE_UNCONSTRAINED_ARRAY (type);\n \n@@ -828,9 +828,9 @@ gnat_get_array_descr_info (const_tree const_type,\n      them to appear in the debug info as pointers to an array type.  That's why\n      we match only the RECORD_TYPE here instead of the POINTER_TYPE with the\n      TYPE_IS_THIN_POINTER_P predicate.  */\n-  else if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL\n-\t   && TREE_CODE (type) == RECORD_TYPE\n-\t   && TYPE_CONTAINS_TEMPLATE_P (type))\n+  else if (TREE_CODE (type) == RECORD_TYPE\n+\t   && TYPE_CONTAINS_TEMPLATE_P (type)\n+\t   && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n     {\n       /* This will be our base object address.  Note that we assume that\n \t pointers to these will actually point to the array field (thin\n@@ -910,9 +910,7 @@ gnat_get_array_descr_info (const_tree const_type,\n      structure.  */\n   for (i = (convention_fortran_p ? info->ndimensions - 1 : 0),\n        dimen = first_dimen;\n-\n        0 <= i && i < info->ndimensions;\n-\n        i += (convention_fortran_p ? -1 : 1),\n        dimen = TREE_TYPE (dimen))\n     {\n@@ -927,12 +925,10 @@ gnat_get_array_descr_info (const_tree const_type,\n \t     there are two cases where we generate self-referencial bound\n \t     expressions:  arrays that are constrained by record discriminants\n \t     and XUA types.  */\n-\t  const bool is_xua_type =\n-\t   (TYPE_CONTEXT (first_dimen) != NULL_TREE\n-            && TREE_CODE (TYPE_CONTEXT (first_dimen)) != RECORD_TYPE\n-\t    && contains_placeholder_p (TYPE_MIN_VALUE (index_type)));\n-\n-\t  if (is_xua_type && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t  if (TYPE_CONTEXT (first_dimen)\n+\t      && TREE_CODE (TYPE_CONTEXT (first_dimen)) != RECORD_TYPE\n+\t      && contains_placeholder_p (TYPE_MIN_VALUE (index_type))\n+\t      && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n \t    {\n \t      info->dimen[i].lower_bound = NULL_TREE;\n \t      info->dimen[i].upper_bound = NULL_TREE;\n@@ -960,9 +956,10 @@ gnat_get_array_descr_info (const_tree const_type,\n \n       /* The DWARF back-end will output exactly INDEX_TYPE as the array index'\n \t \"root\" type, so pell subtypes when possible.  */\n-      while (TREE_TYPE (index_type) != NULL_TREE\n+      while (TREE_TYPE (index_type)\n \t     && !subrange_type_for_debug_p (index_type, NULL, NULL))\n \tindex_type = TREE_TYPE (index_type);\n+\n       info->dimen[i].bounds_type = index_type;\n       info->dimen[i].stride = NULL_TREE;\n     }\n@@ -980,9 +977,9 @@ gnat_get_array_descr_info (const_tree const_type,\n \t element.  This is why we emit a stride in such situations.  */\n       tree source_element_type = info->element_type;\n \n-      while (1)\n+      while (true)\n \t{\n-\t  if (TYPE_DEBUG_TYPE (source_element_type) != NULL_TREE)\n+\t  if (TYPE_DEBUG_TYPE (source_element_type))\n \t    source_element_type = TYPE_DEBUG_TYPE (source_element_type);\n \t  else if (TYPE_IS_PADDING_P (source_element_type))\n \t    source_element_type\n@@ -1024,11 +1021,9 @@ get_array_bit_stride (tree comp_type)\n   if (INTEGRAL_TYPE_P (comp_type))\n     return TYPE_RM_SIZE (comp_type);\n \n-  /* Otherwise, see if this is an array we can analyze.  */\n+  /* Otherwise, see if this is an array we can analyze; if it's not, punt.  */\n   memset (&info, 0, sizeof (info));\n-  if (!gnat_get_array_descr_info (comp_type, &info)\n-      || info.stride == NULL_TREE)\n-    /* If it's not, give it up.  */\n+  if (!gnat_get_array_descr_info (comp_type, &info) || !info.stride)\n     return NULL_TREE;\n \n   /* Otherwise, the array stride is the inner array's stride multiplied by the\n@@ -1047,8 +1042,7 @@ get_array_bit_stride (tree comp_type)\n     {\n       tree count;\n \n-      if (info.dimen[i].lower_bound == NULL_TREE\n-\t  || info.dimen[i].upper_bound == NULL_TREE)\n+      if (!info.dimen[i].lower_bound || !info.dimen[i].upper_bound)\n \treturn NULL_TREE;\n \n       /* Put in count an expression that computes the length of this\n@@ -1080,13 +1074,16 @@ gnat_get_subrange_bounds (const_tree gnu_type, tree *lowval, tree *highval)\n   *highval = TYPE_MAX_VALUE (gnu_type);\n }\n \n+/* Return the bias of GNU_TYPE, if any.  */\n+\n static tree\n gnat_get_type_bias (const_tree gnu_type)\n {\n   if (TREE_CODE (gnu_type) == INTEGER_TYPE\n       && TYPE_BIASED_REPRESENTATION_P (gnu_type)\n       && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n-    return TYPE_RM_MIN_VALUE(gnu_type);\n+    return TYPE_RM_MIN_VALUE (gnu_type);\n+\n   return NULL_TREE;\n }\n \n@@ -1240,7 +1237,7 @@ enumerate_modes (void (*f) (const char *, int, int, int, int, int, int, int))\n \t    digs = fmt->p;\n \n \t  else\n-\t    gcc_unreachable();\n+\t    gcc_unreachable ();\n \t}\n \n       /* First register any C types for this mode that the front end"}, {"sha": "10136e8888b1788c282fb579eb2a013ef0df76b8", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c775aca298673f95dddfb8605f11b0e2f236361/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c775aca298673f95dddfb8605f11b0e2f236361/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=7c775aca298673f95dddfb8605f11b0e2f236361", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2015, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2016, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -6027,7 +6027,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t full view since the clause is on the partial view and we cannot have\n \t 2 different GCC trees for the object.  The only bits of the full view\n \t we will use is the initializer, but it will be directly fetched.  */\n-      if (Ekind(gnat_temp) == E_Constant\n+      if (Ekind (gnat_temp) == E_Constant\n \t  && Present (Address_Clause (gnat_temp))\n \t  && Present (Full_View (gnat_temp)))\n \tsave_gnu_tree (Full_View (gnat_temp), error_mark_node, true);\n@@ -8035,7 +8035,7 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n   /* If this is a variable and an initializer is attached to it, it must be\n      valid for the context.  Similar to init_const in create_var_decl.  */\n   if (TREE_CODE (gnu_decl) == VAR_DECL\n-      && (gnu_init = DECL_INITIAL (gnu_decl)) != NULL_TREE\n+      && (gnu_init = DECL_INITIAL (gnu_decl))\n       && (!gnat_types_compatible_p (type, TREE_TYPE (gnu_init))\n \t  || (TREE_STATIC (gnu_decl)\n \t      && !initializer_constant_valid_p (gnu_init,\n@@ -8128,7 +8128,7 @@ end_stmt_group (void)\n      are cleanups, make a TRY_FINALLY_EXPR.  Last, if there is a BLOCK,\n      make a BIND_EXPR.  Note that we nest in that because the cleanup may\n      reference variables in the block.  */\n-  if (gnu_retval == NULL_TREE)\n+  if (!gnu_retval)\n     gnu_retval = alloc_stmt_list ();\n \n   if (group->cleanups)\n@@ -9023,7 +9023,7 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n       break;\n \n     default:\n-      gcc_unreachable();\n+      gcc_unreachable ();\n     }\n \n   check = fold_build3 (COND_EXPR, boolean_type_node, rhs_lt_zero, check_neg,\n@@ -10083,7 +10083,39 @@ post_error_ne_tree_2 (const char *msg, Node_Id node, Entity_Id ent, tree t,\n   Error_Msg_Uint_2 = UI_From_Int (num);\n   post_error_ne_tree (msg, node, ent, t);\n }\n-\f\n+\n+/* Return a label to branch to for the exception type in KIND or NULL_TREE\n+   if none.  */\n+\n+tree\n+get_exception_label (char kind)\n+{\n+  switch (kind)\n+    {\n+    case N_Raise_Constraint_Error:\n+      return gnu_constraint_error_label_stack->last ();\n+\n+    case N_Raise_Storage_Error:\n+      return gnu_storage_error_label_stack->last ();\n+\n+    case N_Raise_Program_Error:\n+      return gnu_program_error_label_stack->last ();\n+\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Return the decl for the current elaboration procedure.  */\n+\n+tree\n+get_elaboration_procedure (void)\n+{\n+  return gnu_elab_proc_stack->last ();\n+}\n+\n /* Initialize the table that maps GNAT codes to GCC codes for simple\n    binary and unary operations.  */\n \n@@ -10117,28 +10149,4 @@ init_code_table (void)\n   gnu_codes[N_Op_Shift_Right_Arithmetic] = RSHIFT_EXPR;\n }\n \n-/* Return a label to branch to for the exception type in KIND or NULL_TREE\n-   if none.  */\n-\n-tree\n-get_exception_label (char kind)\n-{\n-  if (kind == N_Raise_Constraint_Error)\n-    return gnu_constraint_error_label_stack->last ();\n-  else if (kind == N_Raise_Storage_Error)\n-    return gnu_storage_error_label_stack->last ();\n-  else if (kind == N_Raise_Program_Error)\n-    return gnu_program_error_label_stack->last ();\n-  else\n-    return NULL_TREE;\n-}\n-\n-/* Return the decl for the current elaboration procedure.  */\n-\n-tree\n-get_elaboration_procedure (void)\n-{\n-  return gnu_elab_proc_stack->last ();\n-}\n-\n #include \"gt-ada-trans.h\""}, {"sha": "aac39db2c57f4d878847fb5d8ccffa0bafe9452c", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c775aca298673f95dddfb8605f11b0e2f236361/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c775aca298673f95dddfb8605f11b0e2f236361/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=7c775aca298673f95dddfb8605f11b0e2f236361", "patch": "@@ -429,7 +429,7 @@ build_dummy_unc_pointer_types (Entity_Id gnat_desig_type, tree gnu_desig_type)\n bool\n global_bindings_p (void)\n {\n-  return force_global || current_function_decl == NULL_TREE;\n+  return force_global || !current_function_decl;\n }\n \n /* Enter a new binding level.  */\n@@ -515,7 +515,7 @@ gnat_poplevel (void)\n      parent block.  Otherwise, add it to the list of its parent.  */\n   if (TREE_CODE (BLOCK_SUPERCONTEXT (block)) == FUNCTION_DECL)\n     ;\n-  else if (BLOCK_VARS (block) == NULL_TREE)\n+  else if (!BLOCK_VARS (block))\n     {\n       BLOCK_SUBBLOCKS (level->chain->block)\n \t= block_chainon (BLOCK_SUBBLOCKS (block),\n@@ -570,9 +570,9 @@ gnat_set_type_context (tree type, tree context)\n       /* Give a context to the parallel types and their stub decl, if any.\n \t Some parallel types seems to be present in multiple parallel type\n \t chains, so don't mess with their context if they already have one.  */\n-      if (TYPE_CONTEXT (parallel_type) == NULL_TREE)\n+      if (!TYPE_CONTEXT (parallel_type))\n \t{\n-\t  if (TYPE_STUB_DECL (parallel_type) != NULL_TREE)\n+\t  if (TYPE_STUB_DECL (parallel_type))\n \t    DECL_CONTEXT (TYPE_STUB_DECL (parallel_type)) = context;\n \t  TYPE_CONTEXT (parallel_type) = context;\n \t}\n@@ -625,17 +625,18 @@ get_debug_scope (Node_Id gnat_node, bool *is_subprogram)\n \t     the outer one.  */\n \t  break;\n \t}\n+\n       gnat_entity = Scope (gnat_entity);\n     }\n+\n   return Empty;\n }\n \n-/* If N is NULL, set TYPE's context to CONTEXT. Defer this to the processing of\n-   N otherwise.  */\n+/* If N is NULL, set TYPE's context to CONTEXT.  Defer this to the processing\n+   of N otherwise.  */\n \n static void\n-defer_or_set_type_context (tree type,\n-\t\t\t   tree context,\n+defer_or_set_type_context (tree type, tree context,\n \t\t\t   struct deferred_decl_context_node *n)\n {\n   if (n)\n@@ -644,7 +645,7 @@ defer_or_set_type_context (tree type,\n     gnat_set_type_context (type, context);\n }\n \n-/* Return global_context.  Create it if needed, first.  */\n+/* Return global_context, but create it first if need be.  */\n \n static tree\n get_global_context (void)\n@@ -654,6 +655,7 @@ get_global_context (void)\n       global_context = build_translation_unit_decl (NULL_TREE);\n       debug_hooks->register_main_translation_unit (global_context);\n     }\n+\n   return global_context;\n }\n \n@@ -694,14 +696,14 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \n       /* External declarations (when force_global > 0) may not be in a\n \t local context.  */\n-      else if (current_function_decl != NULL_TREE && force_global == 0)\n+      else if (current_function_decl && force_global == 0)\n \tcontext = current_function_decl;\n     }\n \n   /* If either we are forced to be in global mode or if both the GNAT scope and\n-     the current_function_decl did not help determining the context, use the\n+     the current_function_decl did not help in determining the context, use the\n      global scope.  */\n-  if (!deferred_decl_context && context == NULL_TREE)\n+  if (!deferred_decl_context && !context)\n     context = get_global_context ();\n \n   /* Functions imported in another function are not really nested.\n@@ -710,9 +712,9 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n      lower_nested_functions will then recompute it.  */\n   if (TREE_CODE (decl) == FUNCTION_DECL\n       && !TREE_PUBLIC (decl)\n-      && context != NULL_TREE\n+      && context\n       && (TREE_CODE (context) == FUNCTION_DECL\n-\t  || decl_function_context (context) != NULL_TREE))\n+\t  || decl_function_context (context)))\n     DECL_STATIC_CHAIN (decl) = 1;\n \n   if (!deferred_decl_context)\n@@ -1281,16 +1283,15 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n     SET_TYPE_DEBUG_TYPE (record, type);\n \n-  /* ??? Kludge: padding types around packed array implementation types will be\n+  /* ??? Padding types around packed array implementation types will be\n      considered as root types in the array descriptor language hook (see\n      gnat_get_array_descr_info). Give them the original packed array type\n      name so that the one coming from sources appears in the debugging\n      information.  */\n-  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL\n-      && TYPE_IMPLEMENTS_PACKED_ARRAY_P (type)\n-      && TYPE_ORIGINAL_PACKED_ARRAY (type) != NULL_TREE)\n-    TYPE_NAME (record)\n-      = TYPE_NAME (TYPE_ORIGINAL_PACKED_ARRAY (type));\n+  if (TYPE_IMPL_PACKED_ARRAY_P (type)\n+      && TYPE_ORIGINAL_PACKED_ARRAY (type)\n+      && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n+    TYPE_NAME (record) = TYPE_NAME (TYPE_ORIGINAL_PACKED_ARRAY (type));\n   else if (Present (gnat_entity))\n     TYPE_NAME (record) = create_concat_name (gnat_entity, \"PAD\");\n \n@@ -1855,17 +1856,17 @@ add_parallel_type (tree type, tree parallel_type)\n   SET_DECL_PARALLEL_TYPE (decl, parallel_type);\n \n   /* If PARALLEL_TYPE already has a context, we are done.  */\n-  if (TYPE_CONTEXT (parallel_type) != NULL_TREE)\n+  if (TYPE_CONTEXT (parallel_type))\n     return;\n \n-  /* Otherwise, try to get one from TYPE's context.  */\n-  if (TYPE_CONTEXT (type) != NULL_TREE)\n-    /* TYPE already has a context, so simply propagate it to PARALLEL_TYPE.  */\n+  /* Otherwise, try to get one from TYPE's context.  If so, simply propagate\n+     it to PARALLEL_TYPE.  */\n+  if (TYPE_CONTEXT (type))\n     gnat_set_type_context (parallel_type, TYPE_CONTEXT (type));\n \n-    /* ... otherwise TYPE has not context yet.  We know it will thanks to\n-       gnat_pushdecl, and then its context will be propagated to PARALLEL_TYPE.\n-       So we have nothing to do in this case.  */\n+  /* Otherwise TYPE has not context yet.  We know it will have one thanks to\n+     gnat_pushdecl and then its context will be propagated to PARALLEL_TYPE,\n+     so we have nothing to do in this case.  */\n }\n \n /* Return true if TYPE has a parallel type.  */\n@@ -2269,7 +2270,7 @@ create_range_type (tree type, tree min, tree max)\n {\n   tree range_type;\n \n-  if (type == NULL_TREE)\n+  if (!type)\n     type = sizetype;\n \n   /* First build a type with the base range.  */\n@@ -2905,32 +2906,30 @@ process_deferred_decl_context (bool force)\n       while (Present (gnat_scope))\n \t{\n \t  context = compute_deferred_decl_context (gnat_scope);\n-\t  if (!force || context != NULL_TREE)\n+\t  if (!force || context)\n \t    break;\n \t  gnat_scope = get_debug_scope (gnat_scope, NULL);\n \t}\n \n       /* Imported declarations must not be in a local context (i.e. not inside\n \t a function).  */\n-      if (context != NULL_TREE && node->force_global > 0)\n+      if (context && node->force_global > 0)\n \t{\n \t  tree ctx = context;\n \n-\t  while (ctx != NULL_TREE)\n+\t  while (ctx)\n \t    {\n \t      gcc_assert (TREE_CODE (ctx) != FUNCTION_DECL);\n-\t      ctx = (DECL_P (ctx))\n-\t\t    ? DECL_CONTEXT (ctx)\n-\t\t    : TYPE_CONTEXT (ctx);\n+\t      ctx = DECL_P (ctx) ? DECL_CONTEXT (ctx) : TYPE_CONTEXT (ctx);\n \t    }\n \t}\n \n       /* If FORCE, we want to get rid of all nodes in the queue: in case there\n \t was no elaborated scope, use the global context.  */\n-      if (force && context == NULL_TREE)\n+      if (force && !context)\n \tcontext = get_global_context ();\n \n-      if (context != NULL_TREE)\n+      if (context)\n \t{\n \t  tree t;\n \t  int i;\n@@ -4514,11 +4513,11 @@ convert (tree type, tree expr)\n       if (TYPE_IS_THIN_POINTER_P (etype) && TYPE_IS_THIN_POINTER_P (type))\n \t{\n \t  tree etype_pos\n-\t    = TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (etype)) != NULL_TREE\n+\t    = TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (etype))\n \t      ? byte_position (DECL_CHAIN (TYPE_FIELDS (TREE_TYPE (etype))))\n \t      : size_zero_node;\n \t  tree type_pos\n-\t    = TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type)) != NULL_TREE\n+\t    = TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (type))\n \t      ? byte_position (DECL_CHAIN (TYPE_FIELDS (TREE_TYPE (type))))\n \t      : size_zero_node;\n \t  tree byte_diff = size_diffop (type_pos, etype_pos);\n@@ -6107,7 +6106,7 @@ def_builtin_1 (enum built_in_function fncode,\n \n   /* Preserve an already installed decl.  It most likely was setup in advance\n      (e.g. as part of the internal builtins) for specific reasons.  */\n-  if (builtin_decl_explicit (fncode) != NULL_TREE)\n+  if (builtin_decl_explicit (fncode))\n     return;\n \n   gcc_assert ((!both_p && !fallback_p)"}, {"sha": "803a243c5c595124be46d66ebb728d477c14bd6c", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c775aca298673f95dddfb8605f11b0e2f236361/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c775aca298673f95dddfb8605f11b0e2f236361/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=7c775aca298673f95dddfb8605f11b0e2f236361", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2015, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2016, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -223,8 +223,8 @@ find_common_type (tree t1, tree t2)\n \t  || (TYPE_SIZE (t1) == TYPE_SIZE (t2)\n \t      && !(TREE_CODE (t1) == RECORD_TYPE\n \t\t   && TREE_CODE (t2) == RECORD_TYPE\n-\t\t   && get_variant_part (t1) != NULL_TREE\n-\t\t   && get_variant_part (t2) == NULL_TREE))))\n+\t\t   && get_variant_part (t1)\n+\t\t   && !get_variant_part (t2)))))\n     return t1;\n \n   /* Otherwise, if the lhs type is non-BLKmode, use it.  Note that we know\n@@ -852,7 +852,7 @@ build_binary_op (enum tree_code op_code, tree result_type,\n     {\n     case INIT_EXPR:\n     case MODIFY_EXPR:\n-      gcc_checking_assert (result_type == NULL_TREE);\n+      gcc_checking_assert (!result_type);\n \n       /* If there were integral or pointer conversions on the LHS, remove\n \t them; we'll be putting them back below if needed.  Likewise for\n@@ -2408,7 +2408,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n }\n \f\n /* Indicate that we need to take the address of T and that it therefore\n-   should not be allocated in a register.  Returns true if successful.  */\n+   should not be allocated in a register.  Return true if successful.  */\n \n bool\n gnat_mark_addressable (tree t)\n@@ -2704,7 +2704,7 @@ gnat_rewrite_reference (tree ref, rewrite_fn func, void *data, tree *init)\n       break;\n \n     case COMPOUND_EXPR:\n-      gcc_assert (*init == NULL_TREE);\n+      gcc_assert (!*init);\n       *init = TREE_OPERAND (ref, 0);\n       /* We expect only the pattern built in Call_to_gnu.  */\n       gcc_assert (DECL_P (TREE_OPERAND (ref, 1))\n@@ -2778,7 +2778,7 @@ get_inner_constant_reference (tree exp)\n \t  break;\n \n \tcase COMPONENT_REF:\n-\t  if (TREE_OPERAND (exp, 2) != NULL_TREE)\n+\t  if (TREE_OPERAND (exp, 2))\n \t    return NULL_TREE;\n \n \t  if (!TREE_CONSTANT (DECL_FIELD_OFFSET (TREE_OPERAND (exp, 1))))\n@@ -2788,8 +2788,7 @@ get_inner_constant_reference (tree exp)\n \tcase ARRAY_REF:\n \tcase ARRAY_RANGE_REF:\n \t  {\n-\t    if (TREE_OPERAND (exp, 2) != NULL_TREE\n-\t        || TREE_OPERAND (exp, 3) != NULL_TREE)\n+\t    if (TREE_OPERAND (exp, 2) || TREE_OPERAND (exp, 3))\n \t      return NULL_TREE;\n \n \t    tree array_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n@@ -2917,16 +2916,16 @@ gnat_invariant_expr (tree expr)\n       switch (TREE_CODE (t))\n \t{\n \tcase COMPONENT_REF:\n-\t  if (TREE_OPERAND (t, 2) != NULL_TREE)\n+\t  if (TREE_OPERAND (t, 2))\n \t    return NULL_TREE;\n \t  invariant_p |= DECL_INVARIANT_P (TREE_OPERAND (t, 1));\n \t  break;\n \n \tcase ARRAY_REF:\n \tcase ARRAY_RANGE_REF:\n \t  if (!TREE_CONSTANT (TREE_OPERAND (t, 1))\n-\t      || TREE_OPERAND (t, 2) != NULL_TREE\n-\t      || TREE_OPERAND (t, 3) != NULL_TREE)\n+\t      || TREE_OPERAND (t, 2)\n+\t      || TREE_OPERAND (t, 3))\n \t    return NULL_TREE;\n \t  break;\n "}]}