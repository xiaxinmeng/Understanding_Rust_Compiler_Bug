{"sha": "51a9ed47c9b664c30f7fc8693080f7059ec486e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFhOWVkNDdjOWI2NjRjMzBmN2ZjODY5MzA4MGY3MDU5ZWM0ODZlNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-05-27T09:57:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-05-27T09:57:40Z"}, "message": "lto-streamer-out.c (lto_string_index): break out from...; offset by 1 so 0 means NULL string.\n\n\t* lto-streamer-out.c (lto_string_index): break out from...; offset by 1\n\tso 0 means NULL string.\n\t(lto_output_string_with_length): ... here.\n\t(lto_output_string, output_string_cst, output_identifier): Update handling\n\tof NULL strings.\n\t(lto_output_location_bitpack): New function.\n\t(lto_output_location): Use it.\n\t(lto_output_tree_ref): Use output_record_start.\n\t(pack_ts_type_common_value_fields): Pack aliagn & alias set in var len values.\n\t* lto-streamer-in.c (string_for_index): Break out from ...; offset values by 1.\n\t(input_string_internal): ... here; \n\t(input_string_cst, input_identifier, lto_input_string): Update handling of\n\tNULL strings.\n\t(lto_input_location_bitpack): New function\n\t(lto_input_location): Use it.\n\t(unpack_ts_type_common_value_fields): Pack align & alias in var len values.\n\t* lto-streamer.h (bp_pack_val_len_unsigned, bp_pack_val_len_int,\n\tbp_unpack_val_len_unsigned, bp_unpack_val_len_int): Declare.\n\t(bp_pack_value): Sanity check the value range.\n\t* lto-section-in.c (bp_unpack_val_len_unsigned, bp_unpack_val_len_int):\n\tNew functions.\n\t* lto-section-out.h (bp_pack_val_len_unsigned, bp_pack_val_len_int):\n\tNew functions.\n\nFrom-SVN: r174325", "tree": {"sha": "0714052ce472f19a1f44bab51eb547b0db10018c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0714052ce472f19a1f44bab51eb547b0db10018c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51a9ed47c9b664c30f7fc8693080f7059ec486e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51a9ed47c9b664c30f7fc8693080f7059ec486e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51a9ed47c9b664c30f7fc8693080f7059ec486e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51a9ed47c9b664c30f7fc8693080f7059ec486e5/comments", "author": null, "committer": null, "parents": [{"sha": "dc38fc2e8a3b5ce18e6a22ea160da5ff7ecb0e4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc38fc2e8a3b5ce18e6a22ea160da5ff7ecb0e4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc38fc2e8a3b5ce18e6a22ea160da5ff7ecb0e4b"}], "stats": {"total": 325, "additions": 253, "deletions": 72}, "files": [{"sha": "2bc9180eb08efa50ab10116959509fc3ebd5d041", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51a9ed47c9b664c30f7fc8693080f7059ec486e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51a9ed47c9b664c30f7fc8693080f7059ec486e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51a9ed47c9b664c30f7fc8693080f7059ec486e5", "patch": "@@ -1,3 +1,29 @@\n+2011-05-27  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-streamer-out.c (lto_string_index): break out from...; offset by 1\n+\tso 0 means NULL string.\n+\t(lto_output_string_with_length): ... here.\n+\t(lto_output_string, output_string_cst, output_identifier): Update handling\n+\tof NULL strings.\n+\t(lto_output_location_bitpack): New function.\n+\t(lto_output_location): Use it.\n+\t(lto_output_tree_ref): Use output_record_start.\n+\t(pack_ts_type_common_value_fields): Pack aliagn & alias set in var len values.\n+\t* lto-streamer-in.c (string_for_index): Break out from ...; offset values by 1.\n+\t(input_string_internal): ... here; \n+\t(input_string_cst, input_identifier, lto_input_string): Update handling of\n+\tNULL strings.\n+\t(lto_input_location_bitpack): New function\n+\t(lto_input_location): Use it.\n+\t(unpack_ts_type_common_value_fields): Pack align & alias in var len values.\n+\t* lto-streamer.h (bp_pack_val_len_unsigned, bp_pack_val_len_int,\n+\tbp_unpack_val_len_unsigned, bp_unpack_val_len_int): Declare.\n+\t(bp_pack_value): Sanity check the value range.\n+\t* lto-section-in.c (bp_unpack_val_len_unsigned, bp_unpack_val_len_int):\n+\tNew functions.\n+\t* lto-section-out.h (bp_pack_val_len_unsigned, bp_pack_val_len_int):\n+\tNew functions.\n+\n 2011-05-27  Hariharan Sandanagobalane <hariharan@picochip.com>\n \n \t* config/picochip/picochip.c (reorder_var_tracking_notes): Drop"}, {"sha": "0c2c4c0f1c0fdabfb4f6b767f8b50f9fb8f5cce3", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51a9ed47c9b664c30f7fc8693080f7059ec486e5/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51a9ed47c9b664c30f7fc8693080f7059ec486e5/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=51a9ed47c9b664c30f7fc8693080f7059ec486e5", "patch": "@@ -127,6 +127,51 @@ lto_input_sleb128 (struct lto_input_block *ib)\n }\n \n \n+/* Unpack VAL from BP in a variant of uleb format.  */\n+\n+unsigned HOST_WIDE_INT\n+bp_unpack_var_len_unsigned (struct bitpack_d *bp)\n+{\n+  unsigned HOST_WIDE_INT result = 0;\n+  int shift = 0;\n+  unsigned HOST_WIDE_INT half_byte;\n+\n+  while (true)\n+    {\n+      half_byte = bp_unpack_value (bp, 4);\n+      result |= (half_byte & 0x7) << shift;\n+      shift += 3;\n+      if ((half_byte & 0x8) == 0)\n+\treturn result;\n+    }\n+}\n+\n+\n+/* Unpack VAL from BP in a variant of sleb format.  */\n+\n+HOST_WIDE_INT\n+bp_unpack_var_len_int (struct bitpack_d *bp)\n+{\n+  HOST_WIDE_INT result = 0;\n+  int shift = 0;\n+  unsigned HOST_WIDE_INT half_byte;\n+\n+  while (true)\n+    {\n+      half_byte = bp_unpack_value (bp, 4);\n+      result |= (half_byte & 0x7) << shift;\n+      shift += 3;\n+      if ((half_byte & 0x8) == 0)\n+\t{\n+\t  if ((shift < HOST_BITS_PER_WIDE_INT) && (half_byte & 0x4))\n+\t    result |= - ((HOST_WIDE_INT)1 << shift);\n+\n+\t  return result;\n+\t}\n+    }\n+}\n+\n+\n /* Hooks so that the ipa passes can call into the lto front end to get\n    sections.  */\n "}, {"sha": "55c9d8d165fcacef4477a606c9f4073498a5fdc9", "filename": "gcc/lto-section-out.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51a9ed47c9b664c30f7fc8693080f7059ec486e5/gcc%2Flto-section-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51a9ed47c9b664c30f7fc8693080f7059ec486e5/gcc%2Flto-section-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-out.c?ref=51a9ed47c9b664c30f7fc8693080f7059ec486e5", "patch": "@@ -330,6 +330,48 @@ lto_output_sleb128_stream (struct lto_output_stream *obs, HOST_WIDE_INT work)\n }\n \n \n+/* Pack WORK into BP in a variant of uleb format.  */\n+\n+void\n+bp_pack_var_len_unsigned (struct bitpack_d *bp, unsigned HOST_WIDE_INT work)\n+{\n+  do\n+    {\n+      unsigned int half_byte = (work & 0x7);\n+      work >>= 3;\n+      if (work != 0)\n+\t/* More half_bytes to follow.  */\n+\thalf_byte |= 0x8;\n+\n+      bp_pack_value (bp, half_byte, 4);\n+    }\n+  while (work != 0);\n+}\n+\n+\n+/* Pack WORK into BP in a variant of sleb format.  */\n+\n+void\n+bp_pack_var_len_int (struct bitpack_d *bp, HOST_WIDE_INT work)\n+{\n+  int more, half_byte;\n+\n+  do\n+    {\n+      half_byte = (work & 0x7);\n+      /* arithmetic shift */\n+      work >>= 3;\n+      more = !((work == 0 && (half_byte & 0x4) == 0)\n+\t       || (work == -1 && (half_byte & 0x4) != 0));\n+      if (more)\n+\thalf_byte |= 0x8;\n+\n+      bp_pack_value (bp, half_byte, 4);\n+    }\n+  while (more);\n+}\n+\n+\n /* Lookup NAME in ENCODER.  If NAME is not found, create a new entry in\n    ENCODER for NAME with the next available index of ENCODER,  then\n    print the index to OBS.  True is returned if NAME was added to"}, {"sha": "d2e4ed3ec205653a58ae9e9fa3a7e82186625c5d", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 66, "deletions": 41, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51a9ed47c9b664c30f7fc8693080f7059ec486e5/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51a9ed47c9b664c30f7fc8693080f7059ec486e5/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=51a9ed47c9b664c30f7fc8693080f7059ec486e5", "patch": "@@ -132,19 +132,22 @@ eq_string_slot_node (const void *p1, const void *p2)\n    IB.  Write the length to RLEN.  */\n \n static const char *\n-input_string_internal (struct data_in *data_in, struct lto_input_block *ib,\n-\t\t       unsigned int *rlen)\n+string_for_index (struct data_in *data_in,\n+\t\t  unsigned int loc,\n+\t\t  unsigned int *rlen)\n {\n   struct lto_input_block str_tab;\n   unsigned int len;\n-  unsigned int loc;\n   const char *result;\n \n-  /* Read the location of the string from IB.  */\n-  loc = lto_input_uleb128 (ib);\n+  if (!loc)\n+    {\n+      *rlen = 0;\n+      return NULL;\n+    }\n \n   /* Get the string stored at location LOC in DATA_IN->STRINGS.  */\n-  LTO_INIT_INPUT_BLOCK (str_tab, data_in->strings, loc, data_in->strings_len);\n+  LTO_INIT_INPUT_BLOCK (str_tab, data_in->strings, loc - 1, data_in->strings_len);\n   len = lto_input_uleb128 (&str_tab);\n   *rlen = len;\n \n@@ -157,6 +160,17 @@ input_string_internal (struct data_in *data_in, struct lto_input_block *ib,\n }\n \n \n+/* Read a string from the string table in DATA_IN using input block\n+   IB.  Write the length to RLEN.  */\n+\n+static const char *\n+input_string_internal (struct data_in *data_in, struct lto_input_block *ib,\n+\t\t       unsigned int *rlen)\n+{\n+  return string_for_index (data_in, lto_input_uleb128 (ib), rlen);\n+}\n+\n+\n /* Read a STRING_CST from the string table in DATA_IN using input\n    block IB.  */\n \n@@ -165,13 +179,10 @@ input_string_cst (struct data_in *data_in, struct lto_input_block *ib)\n {\n   unsigned int len;\n   const char * ptr;\n-  unsigned int is_null;\n-\n-  is_null = lto_input_uleb128 (ib);\n-  if (is_null)\n-    return NULL;\n \n   ptr = input_string_internal (data_in, ib, &len);\n+  if (!ptr)\n+    return NULL;\n   return build_string (len, ptr);\n }\n \n@@ -184,13 +195,10 @@ input_identifier (struct data_in *data_in, struct lto_input_block *ib)\n {\n   unsigned int len;\n   const char *ptr;\n-  unsigned int is_null;\n-\n-  is_null = lto_input_uleb128 (ib);\n-  if (is_null)\n-    return NULL;\n \n   ptr = input_string_internal (data_in, ib, &len);\n+  if (!ptr)\n+    return NULL;\n   return get_identifier_with_length (ptr, len);\n }\n \n@@ -215,13 +223,10 @@ lto_input_string (struct data_in *data_in, struct lto_input_block *ib)\n {\n   unsigned int len;\n   const char *ptr;\n-  unsigned int is_null;\n-\n-  is_null = lto_input_uleb128 (ib);\n-  if (is_null)\n-    return NULL;\n \n   ptr = input_string_internal (data_in, ib, &len);\n+  if (!ptr)\n+    return NULL;\n   if (ptr[len - 1] != '\\0')\n     internal_error (\"bytecode stream: found non-null terminated string\");\n \n@@ -284,37 +289,57 @@ clear_line_info (struct data_in *data_in)\n }\n \n \n-/* Read a location from input block IB.  */\n+/* Read a location bitpack from input block IB.  */\n \n static location_t\n-lto_input_location (struct lto_input_block *ib, struct data_in *data_in)\n+lto_input_location_bitpack (struct data_in *data_in, struct bitpack_d *bp)\n {\n-  expanded_location xloc;\n+  bool file_change, line_change, column_change;\n+  unsigned len;\n+  bool prev_file = data_in->current_file != NULL;\n \n-  xloc.file = lto_input_string (data_in, ib);\n-  if (xloc.file == NULL)\n+  if (bp_unpack_value (bp, 1))\n     return UNKNOWN_LOCATION;\n \n-  xloc.file = canon_file_name (xloc.file);\n-  xloc.line = lto_input_sleb128 (ib);\n-  xloc.column = lto_input_sleb128 (ib);\n-  xloc.sysp = lto_input_sleb128 (ib);\n+  file_change = bp_unpack_value (bp, 1);\n+  if (file_change)\n+    data_in->current_file = canon_file_name\n+\t\t\t      (string_for_index (data_in,\n+\t\t\t\t\t\t bp_unpack_var_len_unsigned (bp),\n+\t\t\t\t\t         &len));\n+\n+  line_change = bp_unpack_value (bp, 1);\n+  if (line_change)\n+    data_in->current_line = bp_unpack_var_len_unsigned (bp);\n \n-  if (data_in->current_file != xloc.file)\n+  column_change = bp_unpack_value (bp, 1);\n+  if (column_change)\n+    data_in->current_col = bp_unpack_var_len_unsigned (bp);\n+\n+  if (file_change)\n     {\n-      if (data_in->current_file)\n+      if (prev_file)\n \tlinemap_add (line_table, LC_LEAVE, false, NULL, 0);\n \n-      linemap_add (line_table, LC_ENTER, xloc.sysp, xloc.file, xloc.line);\n+      linemap_add (line_table, LC_ENTER, false, data_in->current_file,\n+\t\t   data_in->current_line);\n     }\n-  else if (data_in->current_line != xloc.line)\n-    linemap_line_start (line_table, xloc.line, xloc.column);\n+  else if (line_change)\n+    linemap_line_start (line_table, data_in->current_line, data_in->current_col);\n+\n+  return linemap_position_for_column (line_table, data_in->current_col);\n+}\n+\n \n-  data_in->current_file = xloc.file;\n-  data_in->current_line = xloc.line;\n-  data_in->current_col = xloc.column;\n+/* Read a location from input block IB.  */\n \n-  return linemap_position_for_column (line_table, xloc.column);\n+static location_t\n+lto_input_location (struct lto_input_block *ib, struct data_in *data_in)\n+{\n+  struct bitpack_d bp;\n+\n+  bp = lto_input_bitpack (ib);\n+  return lto_input_location_bitpack (data_in, &bp);\n }\n \n \n@@ -1766,8 +1791,8 @@ unpack_ts_type_common_value_fields (struct bitpack_d *bp, tree expr)\n     \t= (unsigned) bp_unpack_value (bp, 2);\n   TYPE_USER_ALIGN (expr) = (unsigned) bp_unpack_value (bp, 1);\n   TYPE_READONLY (expr) = (unsigned) bp_unpack_value (bp, 1);\n-  TYPE_ALIGN (expr) = (unsigned) bp_unpack_value (bp, HOST_BITS_PER_INT);\n-  TYPE_ALIAS_SET (expr) = bp_unpack_value (bp, HOST_BITS_PER_INT);\n+  TYPE_ALIGN (expr) = bp_unpack_var_len_unsigned (bp);\n+  TYPE_ALIAS_SET (expr) = bp_unpack_var_len_int (bp);\n }\n \n "}, {"sha": "b9ac6d03245ebcf9656ca8b8d87dacb5a845757c", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 65, "deletions": 31, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51a9ed47c9b664c30f7fc8693080f7059ec486e5/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51a9ed47c9b664c30f7fc8693080f7059ec486e5/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=51a9ed47c9b664c30f7fc8693080f7059ec486e5", "patch": "@@ -143,16 +143,14 @@ destroy_output_block (struct output_block *ob)\n   free (ob);\n }\n \n-\n-/* Output STRING of LEN characters to the string\n-   table in OB. The string might or might not include a trailing '\\0'.\n+/* Return index used to reference STRING of LEN characters in the string table\n+   in OB.  The string might or might not include a trailing '\\0'.\n    Then put the index onto the INDEX_STREAM.  */\n \n-void\n-lto_output_string_with_length (struct output_block *ob,\n-\t\t\t       struct lto_output_stream *index_stream,\n-\t\t\t       const char *s,\n-\t\t\t       unsigned int len)\n+static unsigned\n+lto_string_index (struct output_block *ob,\n+\t\t  const char *s,\n+\t\t  unsigned int len)\n {\n   struct string_slot **slot;\n   struct string_slot s_slot;\n@@ -164,9 +162,6 @@ lto_output_string_with_length (struct output_block *ob,\n   s_slot.len = len;\n   s_slot.slot_num = 0;\n \n-  /* Indicate that this is not a NULL string.  */\n-  lto_output_uleb128_stream (index_stream, 0);\n-\n   slot = (struct string_slot **) htab_find_slot (ob->string_hash_table,\n \t\t\t\t\t\t &s_slot, INSERT);\n   if (*slot == NULL)\n@@ -180,18 +175,33 @@ lto_output_string_with_length (struct output_block *ob,\n       new_slot->len = len;\n       new_slot->slot_num = start;\n       *slot = new_slot;\n-      lto_output_uleb128_stream (index_stream, start);\n       lto_output_uleb128_stream (string_stream, len);\n       lto_output_data_stream (string_stream, string, len);\n+      return start + 1;\n     }\n   else\n     {\n       struct string_slot *old_slot = *slot;\n-      lto_output_uleb128_stream (index_stream, old_slot->slot_num);\n       free (string);\n+      return old_slot->slot_num + 1;\n     }\n }\n \n+\n+/* Output STRING of LEN characters to the string\n+   table in OB. The string might or might not include a trailing '\\0'.\n+   Then put the index onto the INDEX_STREAM.  */\n+\n+void\n+lto_output_string_with_length (struct output_block *ob,\n+\t\t\t       struct lto_output_stream *index_stream,\n+\t\t\t       const char *s,\n+\t\t\t       unsigned int len)\n+{\n+  lto_output_uleb128_stream (index_stream,\n+\t\t\t     lto_string_index (ob, s, len));\n+}\n+\n /* Output the '\\0' terminated STRING to the string\n    table in OB.  Then put the index onto the INDEX_STREAM.  */\n \n@@ -204,7 +214,7 @@ lto_output_string (struct output_block *ob,\n     lto_output_string_with_length (ob, index_stream, string,\n \t\t\t\t   strlen (string) + 1);\n   else\n-    lto_output_uleb128_stream (index_stream, 1);\n+    lto_output_1_stream (index_stream, 0);\n }\n \n \n@@ -221,7 +231,7 @@ output_string_cst (struct output_block *ob,\n \t\t\t\t   TREE_STRING_POINTER (string),\n \t\t\t\t   TREE_STRING_LENGTH (string ));\n   else\n-    lto_output_uleb128_stream (index_stream, 1);\n+    lto_output_1_stream (index_stream, 0);\n }\n \n \n@@ -238,9 +248,10 @@ output_identifier (struct output_block *ob,\n \t\t\t\t   IDENTIFIER_POINTER (id),\n \t\t\t\t   IDENTIFIER_LENGTH (id));\n   else\n-    lto_output_uleb128_stream (index_stream, 1);\n+    lto_output_1_stream (index_stream, 0);\n }\n \n+\n /* Write a zero to the output stream.  */\n \n static void\n@@ -504,8 +515,8 @@ pack_ts_type_common_value_fields (struct bitpack_d *bp, tree expr)\n   bp_pack_value (bp, TYPE_CONTAINS_PLACEHOLDER_INTERNAL (expr), 2);\n   bp_pack_value (bp, TYPE_USER_ALIGN (expr), 1);\n   bp_pack_value (bp, TYPE_READONLY (expr), 1);\n-  bp_pack_value (bp, TYPE_ALIGN (expr), HOST_BITS_PER_INT);\n-  bp_pack_value (bp, TYPE_ALIAS_SET (expr) == 0 ? 0 : -1, HOST_BITS_PER_INT);\n+  bp_pack_var_len_unsigned (bp, TYPE_ALIGN (expr));\n+  bp_pack_var_len_int (bp, TYPE_ALIAS_SET (expr) == 0 ? 0 : -1);\n }\n \n \n@@ -587,32 +598,55 @@ pack_value_fields (struct bitpack_d *bp, tree expr)\n }\n \n \n-/* Emit location LOC to output block OB.  */\n+/* Output info about new location into bitpack BP.\n+   After outputting bitpack, lto_output_location_data has\n+   to be done to output actual data.  */\n \n-static void\n-lto_output_location (struct output_block *ob, location_t loc)\n+static inline void\n+lto_output_location_bitpack (struct bitpack_d *bp,\n+\t\t\t     struct output_block *ob,\n+\t\t\t     location_t loc)\n {\n   expanded_location xloc;\n \n+  bp_pack_value (bp, loc == UNKNOWN_LOCATION, 1);\n   if (loc == UNKNOWN_LOCATION)\n-    {\n-      lto_output_string (ob, ob->main_stream, NULL);\n-      return;\n-    }\n+    return;\n \n   xloc = expand_location (loc);\n \n-  lto_output_string (ob, ob->main_stream, xloc.file);\n-  output_sleb128 (ob, xloc.line);\n-  output_sleb128 (ob, xloc.column);\n-  output_sleb128 (ob, xloc.sysp);\n-\n+  bp_pack_value (bp, ob->current_file != xloc.file, 1);\n+  if (ob->current_file != xloc.file)\n+    bp_pack_var_len_unsigned (bp, lto_string_index (ob,\n+\t\t\t\t\t          xloc.file,\n+\t\t\t\t\t\t  strlen (xloc.file) + 1));\n   ob->current_file = xloc.file;\n+\n+  bp_pack_value (bp, ob->current_line != xloc.line, 1);\n+  if (ob->current_line != xloc.line)\n+    bp_pack_var_len_unsigned (bp, xloc.line);\n   ob->current_line = xloc.line;\n+\n+  bp_pack_value (bp, ob->current_col != xloc.column, 1);\n+  if (ob->current_col != xloc.column)\n+    bp_pack_var_len_unsigned (bp, xloc.column);\n   ob->current_col = xloc.column;\n }\n \n \n+/* Emit location LOC to output block OB.\n+   When bitpack is handy, it is more space effecient to call\n+   lto_output_location_bitpack with existing bitpack.  */\n+\n+static void\n+lto_output_location (struct output_block *ob, location_t loc)\n+{\n+  struct bitpack_d bp = bitpack_create (ob->main_stream);\n+  lto_output_location_bitpack (&bp, ob, loc);\n+  lto_output_bitpack (&bp);\n+}\n+\n+\n /* Return true if tree node T is written to various tables.  For these\n    nodes, we sometimes want to write their phyiscal representation\n    (via lto_output_tree), and sometimes we need to emit an index\n@@ -642,7 +676,7 @@ lto_output_tree_ref (struct output_block *ob, tree expr)\n \n   if (expr == NULL_TREE)\n     {\n-      output_zero (ob);\n+      output_record_start (ob, LTO_null);\n       return;\n     }\n "}, {"sha": "4508818a4a6f2208a490ec417f6bc7cd2ae410f0", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51a9ed47c9b664c30f7fc8693080f7059ec486e5/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51a9ed47c9b664c30f7fc8693080f7059ec486e5/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=51a9ed47c9b664c30f7fc8693080f7059ec486e5", "patch": "@@ -774,6 +774,10 @@ extern void lto_section_overrun (struct lto_input_block *) ATTRIBUTE_NORETURN;\n extern void lto_value_range_error (const char *,\n \t\t\t\t   HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t   HOST_WIDE_INT) ATTRIBUTE_NORETURN;\n+extern void bp_pack_var_len_unsigned (struct bitpack_d *, unsigned HOST_WIDE_INT);\n+extern void bp_pack_var_len_int (struct bitpack_d *, HOST_WIDE_INT);\n+extern unsigned HOST_WIDE_INT bp_unpack_var_len_unsigned (struct bitpack_d *);\n+extern HOST_WIDE_INT bp_unpack_var_len_int (struct bitpack_d *);\n \n /* In lto-section-out.c  */\n extern hashval_t lto_hash_decl_slot_node (const void *);\n@@ -1110,6 +1114,11 @@ bp_pack_value (struct bitpack_d *bp, bitpack_word_t val, unsigned nbits)\n {\n   bitpack_word_t word = bp->word;\n   int pos = bp->pos;\n+\n+  /* Verify that VAL fits in the NBITS.  */\n+  gcc_checking_assert (nbits == BITS_PER_BITPACK_WORD\n+\t\t       || !(val & ~(((bitpack_word_t)1<<nbits)-1)));\n+\n   /* If val does not fit into the current bitpack word switch to the\n      next one.  */\n   if (pos + nbits > BITS_PER_BITPACK_WORD)"}]}