{"sha": "4e0f56d7af9dd58f74d67f9cb303936ef595cdf6", "node_id": "C_kwDOANBUbNoAKDRlMGY1NmQ3YWY5ZGQ1OGY3NGQ2N2Y5Y2IzMDM5MzZlZjU5NWNkZjY", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-10-29T15:28:41Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-11-01T13:24:10Z"}, "message": "Move statics to threader pass class.\n\nThis patch moves all the static functions into the pass class, and\ncleans up things a little.  The goal is to shuffle things around such\nthat we can add debug counters that depend on different threading\npasses, but it's a clean-up on its own right.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-threadbackward.c (BT_NONE): New.\n\t(BT_SPEED): New.\n\t(BT_RESOLVE): New.\n\t(back_threader::back_threader): Add flags.\n\tMove loop initialization here.\n\t(back_threader::~back_threader): New.\n\t(back_threader::find_taken_edge_switch): Change solver and ranger\n\tto pointers.\n\t(back_threader::find_taken_edge_cond): Same.\n\t(back_threader::find_paths_to_names): Same.\n\t(back_threader::find_paths): Same.\n\t(back_threader::dump): Same.\n\t(try_thread_blocks): Merge into thread_blocks.\n\t(back_threader::thread_blocks): New.\n\t(do_early_thread_jumps): Merge into thread_blocks.\n\t(do_thread_jumps): Merge into thread_blocks.\n\t(back_threader::thread_through_all_blocks): Remove.", "tree": {"sha": "3843dab1b4006ae7a2950039a9e40487fa494239", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3843dab1b4006ae7a2950039a9e40487fa494239"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e0f56d7af9dd58f74d67f9cb303936ef595cdf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e0f56d7af9dd58f74d67f9cb303936ef595cdf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e0f56d7af9dd58f74d67f9cb303936ef595cdf6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e0f56d7af9dd58f74d67f9cb303936ef595cdf6/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0187c03be31a58ba561d535687dc00c94f0ff1aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0187c03be31a58ba561d535687dc00c94f0ff1aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0187c03be31a58ba561d535687dc00c94f0ff1aa"}], "stats": {"total": 121, "additions": 60, "deletions": 61}, "files": [{"sha": "d1cc1f7f20f74fd96bc6bf5152c709a371942486", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 60, "deletions": 61, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e0f56d7af9dd58f74d67f9cb303936ef595cdf6/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e0f56d7af9dd58f74d67f9cb303936ef595cdf6/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=4e0f56d7af9dd58f74d67f9cb303936ef595cdf6", "patch": "@@ -69,13 +69,22 @@ class back_threader_profitability\n   const bool m_speed_p;\n };\n \n+// Back threader flags.\n+#define BT_NONE 0\n+// Generate fast code at the expense of code size.\n+#define BT_SPEED 1\n+// Resolve unknown SSAs on entry to a threading path.  If set, use the\n+// ranger.  If not, assume all ranges on entry to a path are VARYING.\n+#define BT_RESOLVE 2\n+\n class back_threader\n {\n public:\n-  back_threader (bool speed_p, bool resolve);\n-  void maybe_thread_block (basic_block bb);\n-  bool thread_through_all_blocks (bool may_peel_loop_headers);\n+  back_threader (function *fun, unsigned flags);\n+  ~back_threader ();\n+  unsigned thread_blocks ();\n private:\n+  void maybe_thread_block (basic_block bb);\n   void find_paths (basic_block bb, tree name);\n   edge maybe_register_path ();\n   bool find_paths_to_names (basic_block bb, bitmap imports);\n@@ -89,8 +98,8 @@ class back_threader\n \n   back_threader_registry m_registry;\n   back_threader_profitability m_profit;\n-  gimple_ranger m_ranger;\n-  path_range_query m_solver;\n+  gimple_ranger *m_ranger;\n+  path_range_query *m_solver;\n \n   // Current path being analyzed.\n   auto_vec<basic_block> m_path;\n@@ -109,19 +118,35 @@ class back_threader\n   // Set to TRUE if unknown SSA names along a path should be resolved\n   // with the ranger.  Otherwise, unknown SSA names are assumed to be\n   // VARYING.  Setting to true is more precise but slower.\n-  bool m_resolve;\n+  function *m_fun;\n+  unsigned m_flags;\n };\n \n // Used to differentiate unreachable edges, so we may stop the search\n // in a the given direction.\n const edge back_threader::UNREACHABLE_EDGE = (edge) -1;\n \n-back_threader::back_threader (bool speed_p, bool resolve)\n-  : m_profit (speed_p),\n-    m_solver (m_ranger, resolve)\n+back_threader::back_threader (function *fun, unsigned flags)\n+  : m_profit (flags & BT_SPEED)\n {\n+  if (flags & BT_SPEED)\n+    loop_optimizer_init (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES);\n+  else\n+    loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n+\n+  m_fun = fun;\n+  m_flags = flags;\n+  m_ranger = new gimple_ranger;\n+  m_solver = new path_range_query (*m_ranger, flags & BT_RESOLVE);\n   m_last_stmt = NULL;\n-  m_resolve = resolve;\n+}\n+\n+back_threader::~back_threader ()\n+{\n+  delete m_solver;\n+  delete m_ranger;\n+\n+  loop_optimizer_finalize ();\n }\n \n // Register the current path for jump threading if it's profitable to\n@@ -186,8 +211,8 @@ back_threader::find_taken_edge_switch (const vec<basic_block> &path,\n   tree name = gimple_switch_index (sw);\n   int_range_max r;\n \n-  m_solver.compute_ranges (path, m_imports);\n-  m_solver.range_of_expr (r, name, sw);\n+  m_solver->compute_ranges (path, m_imports);\n+  m_solver->range_of_expr (r, name, sw);\n \n   if (r.undefined_p ())\n     return UNREACHABLE_EDGE;\n@@ -210,10 +235,10 @@ back_threader::find_taken_edge_cond (const vec<basic_block> &path,\n {\n   int_range_max r;\n \n-  m_solver.compute_ranges (path, m_imports);\n-  m_solver.range_of_stmt (r, cond);\n+  m_solver->compute_ranges (path, m_imports);\n+  m_solver->range_of_stmt (r, cond);\n \n-  if (m_solver.unreachable_path_p ())\n+  if (m_solver->unreachable_path_p ())\n     return UNREACHABLE_EDGE;\n \n   int_range<2> true_range (boolean_true_node, boolean_true_node);\n@@ -381,7 +406,7 @@ back_threader::find_paths_to_names (basic_block bb, bitmap interesting)\n       // Examine blocks that define or export an interesting SSA,\n       // since they may compute a range which resolve this path.\n       if ((def_bb == bb\n-\t   || bitmap_bit_p (m_ranger.gori ().exports (bb), i))\n+\t   || bitmap_bit_p (m_ranger->gori ().exports (bb), i))\n \t  && m_path.length () > 1)\n \t{\n \t  if (maybe_register_path ())\n@@ -436,7 +461,7 @@ back_threader::find_paths (basic_block bb, tree name)\n       bitmap_clear (m_imports);\n \n       auto_bitmap interesting;\n-      bitmap_copy (m_imports, m_ranger.gori ().imports (bb));\n+      bitmap_copy (m_imports, m_ranger->gori ().imports (bb));\n       bitmap_copy (interesting, m_imports);\n       find_paths_to_names (bb, interesting);\n     }\n@@ -486,14 +511,6 @@ back_threader::maybe_thread_block (basic_block bb)\n   find_paths (bb, name);\n }\n \n-// Perform the actual jump threading for the all queued paths.\n-\n-bool\n-back_threader::thread_through_all_blocks (bool may_peel_loop_headers)\n-{\n-  return m_registry.thread_through_all_blocks (may_peel_loop_headers);\n-}\n-\n // Dump a sequence of BBs through the CFG.\n \n DEBUG_FUNCTION void\n@@ -517,7 +534,7 @@ debug (const vec <basic_block> &path)\n void\n back_threader::dump (FILE *out)\n {\n-  m_solver.dump (out);\n+  m_solver->dump (out);\n   fprintf (out, \"\\nCandidates for pre-computation:\\n\");\n   fprintf (out, \"===================================\\n\");\n \n@@ -883,45 +900,24 @@ back_threader_registry::register_path (const vec<basic_block> &m_path,\n   return true;\n }\n \n-// Try to thread blocks in FUN.  RESOLVE is TRUE when fully resolving\n-// unknown SSAs.  SPEED is TRUE when optimizing for speed.\n+// Thread all suitable paths in the current function.\n //\n-// Return TRUE if any jump thread paths were registered.\n+// Return TODO_flags.\n \n-static bool\n-try_thread_blocks (function *fun, bool resolve, bool speed)\n+unsigned int\n+back_threader::thread_blocks ()\n {\n-  back_threader threader (speed, resolve);\n   basic_block bb;\n-  FOR_EACH_BB_FN (bb, fun)\n-    {\n-      if (EDGE_COUNT (bb->succs) > 1)\n-\tthreader.maybe_thread_block (bb);\n-    }\n-  return threader.thread_through_all_blocks (/*peel_loop_headers=*/true);\n-}\n-\n-static unsigned int\n-do_early_thread_jumps (function *fun, bool resolve)\n-{\n-  loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n-\n-  try_thread_blocks (fun, resolve, /*speed=*/false);\n+  FOR_EACH_BB_FN (bb, m_fun)\n+    if (EDGE_COUNT (bb->succs) > 1)\n+      maybe_thread_block (bb);\n \n-  loop_optimizer_finalize ();\n-  return 0;\n-}\n-\n-static unsigned int\n-do_thread_jumps (function *fun, bool resolve)\n-{\n-  loop_optimizer_init (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES);\n+  bool changed = m_registry.thread_through_all_blocks (true);\n \n-  bool changed = try_thread_blocks (fun, resolve, /*speed=*/true);\n+  if (m_flags & BT_SPEED)\n+    return changed ? TODO_cleanup_cfg : 0;\n \n-  loop_optimizer_finalize ();\n-\n-  return changed ? TODO_cleanup_cfg : 0;\n+  return false;\n }\n \n namespace {\n@@ -983,7 +979,8 @@ class pass_early_thread_jumps : public gimple_opt_pass\n   }\n   unsigned int execute (function *fun) override\n   {\n-    return do_early_thread_jumps (fun, /*resolve=*/false);\n+    back_threader threader (fun, BT_NONE);\n+    return threader.thread_blocks ();\n   }\n };\n \n@@ -1004,7 +1001,8 @@ class pass_thread_jumps : public gimple_opt_pass\n   }\n   unsigned int execute (function *fun) override\n   {\n-    return do_thread_jumps (fun, /*resolve=*/false);\n+    back_threader threader (fun, BT_SPEED);\n+    return threader.thread_blocks ();\n   }\n };\n \n@@ -1025,7 +1023,8 @@ class pass_thread_jumps_full : public gimple_opt_pass\n   }\n   unsigned int execute (function *fun) override\n   {\n-    return do_thread_jumps (fun, /*resolve=*/true);\n+    back_threader threader (fun, BT_SPEED | BT_RESOLVE);\n+    return threader.thread_blocks ();\n   }\n };\n "}]}