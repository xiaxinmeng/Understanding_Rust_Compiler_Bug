{"sha": "0fd4b31d684af56704c69cdbc8a0c891403ac672", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZkNGIzMWQ2ODRhZjU2NzA0YzY5Y2RiYzhhMGM4OTE0MDNhYzY3Mg==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-10-21T02:33:33Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-10-21T02:33:33Z"}, "message": "basic-block.h (find_fallthru_edge): Define.\n\n\t* basic-block.h (find_fallthru_edge): Define.\n\t* cfgcleanup.c (merge_blocks_move): Use it.\n\t(try_crossjump_bb): Likewise.\n\t* cfglayout.c (fixup_reorder_chains): Likewise.\n\t(fixup_fallthru_exit_predecessor): Likewise.\n\t* cfgrtl.c (rtl_split_edge): Likewise.\n\t(rtl_verify_flow_info): Likewise.\n\t* function.c (thread_prologue_and_epilogue_insns): Likewise.\n\t* gimple-pretty-print.c (dump_implicit_edges): Likewise.\n\t* ifcvt.c (block_fallthru): Likewise.\n\t* reload1.c (fixup_abnormal_edges): Likewise.\n\t* sched-ebb.c (being_schedule_ready): Likewise.\n\t(schedule_ebb): Likwise.\n\t* sched-rgn.c (find_single_block_region): Likewise.\n\t* sel-sched-ir.c (bb_ends_ebb_p): Likewise.\n\t* tree-complex.c (expand_complex_move): Likewise.\n\t* sched-int.h (find_fallthru_edge): Rename to...\n\t(find_fallthru_edge_from): ...this.\n\t* haifa-sched.c (find_fallthru_edge): Rename to...\n\t(find_fallthru_edge_from): ...this.  Use new find_fallthru_edge.\n\t(init_before_recovery): Call find_fallthru_edge_from.\n\t* sel-sched-ir.c (merge_fences): Likewise.\n\t* sel-sched.c (in_fallthru_bb_p): Likewise.\n\t(move_cond_jump): Likewise.\n\nFrom-SVN: r165748", "tree": {"sha": "46c04a0ca71f226e6c7a15bdb22ae8bb69768800", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46c04a0ca71f226e6c7a15bdb22ae8bb69768800"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fd4b31d684af56704c69cdbc8a0c891403ac672", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fd4b31d684af56704c69cdbc8a0c891403ac672", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fd4b31d684af56704c69cdbc8a0c891403ac672", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fd4b31d684af56704c69cdbc8a0c891403ac672/comments", "author": null, "committer": null, "parents": [{"sha": "b56f8e7c2adbbb60bbb3aef976dc6ebb22810f22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b56f8e7c2adbbb60bbb3aef976dc6ebb22810f22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b56f8e7c2adbbb60bbb3aef976dc6ebb22810f22"}], "stats": {"total": 194, "additions": 91, "deletions": 103}, "files": [{"sha": "cfbbb66dc598416051ead1c5c454837c082bba68", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0fd4b31d684af56704c69cdbc8a0c891403ac672", "patch": "@@ -1,3 +1,30 @@\n+2010-10-20  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* basic-block.h (find_fallthru_edge): Define.\n+\t* cfgcleanup.c (merge_blocks_move): Use it.\n+\t(try_crossjump_bb): Likewise.\n+\t* cfglayout.c (fixup_reorder_chains): Likewise.\n+\t(fixup_fallthru_exit_predecessor): Likewise.\n+\t* cfgrtl.c (rtl_split_edge): Likewise.\n+\t(rtl_verify_flow_info): Likewise.\n+\t* function.c (thread_prologue_and_epilogue_insns): Likewise.\n+\t* gimple-pretty-print.c (dump_implicit_edges): Likewise.\n+\t* ifcvt.c (block_fallthru): Likewise.\n+\t* reload1.c (fixup_abnormal_edges): Likewise.\n+\t* sched-ebb.c (being_schedule_ready): Likewise.\n+\t(schedule_ebb): Likwise.\n+\t* sched-rgn.c (find_single_block_region): Likewise.\n+\t* sel-sched-ir.c (bb_ends_ebb_p): Likewise.\n+\t* tree-complex.c (expand_complex_move): Likewise.\n+\t* sched-int.h (find_fallthru_edge): Rename to...\n+\t(find_fallthru_edge_from): ...this.\n+\t* haifa-sched.c (find_fallthru_edge): Rename to...\n+\t(find_fallthru_edge_from): ...this.  Use new find_fallthru_edge.\n+\t(init_before_recovery): Call find_fallthru_edge_from.\n+\t* sel-sched-ir.c (merge_fences): Likewise.\n+\t* sel-sched.c (in_fallthru_bb_p): Likewise.\n+\t(move_cond_jump): Likewise.\n+\n 2010-10-20  Paul Koning  <ni1d@arrl.net>\n \n \t* config/pdp11/pdp11.md (various): Fix conditions on a number of"}, {"sha": "e3b6e2007e367faa6ceb60f458a35fc98458ce97", "filename": "gcc/basic-block.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=0fd4b31d684af56704c69cdbc8a0c891403ac672", "patch": "@@ -926,6 +926,20 @@ bb_has_abnormal_pred (basic_block bb)\n   return false;\n }\n \n+/* Return the fallthru edge in EDGES if it exists, NULL otherwise.  */\n+static inline edge\n+find_fallthru_edge (VEC(edge,gc) *edges)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, edges)\n+    if (e->flags & EDGE_FALLTHRU)\n+      break;\n+\n+  return e;\n+}\n+\n /* In cfgloopmanip.c.  */\n extern edge mfb_kj_edge;\n extern bool mfb_keep_just (edge);"}, {"sha": "9563e3f55677c226dd7d835157914c253e7e3a90", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=0fd4b31d684af56704c69cdbc8a0c891403ac672", "patch": "@@ -793,7 +793,6 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n       edge tmp_edge, b_fallthru_edge;\n       bool c_has_outgoing_fallthru;\n       bool b_has_incoming_fallthru;\n-      edge_iterator ei;\n \n       /* Avoid overactive code motion, as the forwarder blocks should be\n \t eliminated by edge redirection instead.  One exception might have\n@@ -806,16 +805,10 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n \t and loop notes.  This is done by squeezing out all the notes\n \t and leaving them there to lie.  Not ideal, but functional.  */\n \n-      FOR_EACH_EDGE (tmp_edge, ei, c->succs)\n-\tif (tmp_edge->flags & EDGE_FALLTHRU)\n-\t  break;\n-\n+      tmp_edge = find_fallthru_edge (c->succs);\n       c_has_outgoing_fallthru = (tmp_edge != NULL);\n \n-      FOR_EACH_EDGE (tmp_edge, ei, b->preds)\n-\tif (tmp_edge->flags & EDGE_FALLTHRU)\n-\t  break;\n-\n+      tmp_edge = find_fallthru_edge (b->preds);\n       b_has_incoming_fallthru = (tmp_edge != NULL);\n       b_fallthru_edge = tmp_edge;\n       next = b->prev_bb;\n@@ -1801,7 +1794,6 @@ try_crossjump_bb (int mode, basic_block bb)\n   bool changed;\n   unsigned max, ix, ix2;\n   basic_block ev, ev2;\n-  edge_iterator ei;\n \n   /* Nothing to do if there is not at least two incoming edges.  */\n   if (EDGE_COUNT (bb->preds) < 2)\n@@ -1838,14 +1830,7 @@ try_crossjump_bb (int mode, basic_block bb)\n   if (EDGE_COUNT (bb->preds) > max)\n     return false;\n \n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    {\n-      if (e->flags & EDGE_FALLTHRU)\n-\t{\n-\t  fallthru = e;\n-\t  break;\n-\t}\n-    }\n+  fallthru = find_fallthru_edge (bb->preds);\n \n   changed = false;\n   for (ix = 0, ev = bb; ix < EDGE_COUNT (ev->preds); )"}, {"sha": "9fc05fea854a7d5affddad4dbc8a0208a8e99d9f", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=0fd4b31d684af56704c69cdbc8a0c891403ac672", "patch": "@@ -927,12 +927,7 @@ fixup_reorder_chain (void)\n   /* Annoying special case - jump around dead jumptables left in the code.  */\n   FOR_EACH_BB (bb)\n     {\n-      edge e;\n-      edge_iterator ei;\n-\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\tif (e->flags & EDGE_FALLTHRU)\n-\t  break;\n+      edge e = find_fallthru_edge (bb->succs);\n \n       if (e && !can_fallthru (e->src, e->dest))\n \tforce_nonfallthru (e);\n@@ -1019,17 +1014,16 @@ static void\n fixup_fallthru_exit_predecessor (void)\n {\n   edge e;\n-  edge_iterator ei;\n   basic_block bb = NULL;\n \n   /* This transformation is not valid before reload, because we might\n      separate a call from the instruction that copies the return\n      value.  */\n   gcc_assert (reload_completed);\n \n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n-    if (e->flags & EDGE_FALLTHRU)\n-      bb = e->src;\n+  e = find_fallthru_edge (EXIT_BLOCK_PTR->preds);\n+  if (e)\n+    bb = e->src;\n \n   if (bb && bb->aux)\n     {"}, {"sha": "e46050d02b1e33b1b0beadbd9c29ec7e3bd57502", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=0fd4b31d684af56704c69cdbc8a0c891403ac672", "patch": "@@ -1370,12 +1370,7 @@ rtl_split_edge (edge edge_in)\n      Avoid existence of fallthru predecessors.  */\n   if ((edge_in->flags & EDGE_FALLTHRU) == 0)\n     {\n-      edge e;\n-      edge_iterator ei;\n-\n-      FOR_EACH_EDGE (e, ei, edge_in->dest->preds)\n-\tif (e->flags & EDGE_FALLTHRU)\n-\t  break;\n+      edge e = find_fallthru_edge (edge_in->dest->preds);\n \n       if (e)\n \tforce_nonfallthru (e);\n@@ -2068,7 +2063,6 @@ rtl_verify_flow_info (void)\n   FOR_EACH_BB_REVERSE (bb)\n     {\n       edge e;\n-      edge_iterator ei;\n       rtx head = BB_HEAD (bb);\n       rtx end = BB_END (bb);\n \n@@ -2122,9 +2116,7 @@ rtl_verify_flow_info (void)\n \n       last_head = PREV_INSN (x);\n \n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\tif (e->flags & EDGE_FALLTHRU)\n-\t  break;\n+      e = find_fallthru_edge (bb->succs);\n       if (!e)\n \t{\n \t  rtx insn;"}, {"sha": "d0da7dc8577a5e61bfe4228a1e6f55afaa0fc041", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=0fd4b31d684af56704c69cdbc8a0c891403ac672", "patch": "@@ -5311,9 +5311,7 @@ thread_prologue_and_epilogue_insns (void)\n       basic_block last;\n       rtx label;\n \n-      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n-\tif (e->flags & EDGE_FALLTHRU)\n-\t  break;\n+      e = find_fallthru_edge (EXIT_BLOCK_PTR->preds);\n       if (e == NULL)\n \tgoto epilogue_done;\n       last = e->src;\n@@ -5434,9 +5432,7 @@ thread_prologue_and_epilogue_insns (void)\n      There really shouldn't be a mixture -- either all should have\n      been converted or none, however...  */\n \n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n-    if (e->flags & EDGE_FALLTHRU)\n-      break;\n+  e = find_fallthru_edge (EXIT_BLOCK_PTR->preds);\n   if (e == NULL)\n     goto epilogue_done;\n "}, {"sha": "c74dd0ec7a725a86a60e526b0b74275dde4a592f", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=0fd4b31d684af56704c69cdbc8a0c891403ac672", "patch": "@@ -1976,7 +1976,6 @@ dump_implicit_edges (pretty_printer *buffer, basic_block bb, int indent,\n \t\t     int flags)\n {\n   edge e;\n-  edge_iterator ei;\n   gimple stmt;\n \n   stmt = last_stmt (bb);\n@@ -2004,9 +2003,7 @@ dump_implicit_edges (pretty_printer *buffer, basic_block bb, int indent,\n \n   /* If there is a fallthru edge, we may need to add an artificial\n      goto to the dump.  */\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (e->flags & EDGE_FALLTHRU)\n-      break;\n+  e = find_fallthru_edge (bb->succs);\n \n   if (e && e->dest != bb->next_bb)\n     {"}, {"sha": "015f8b9d5576a87dcfd39f3aef85d200883c7d68", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=0fd4b31d684af56704c69cdbc8a0c891403ac672", "patch": "@@ -4247,32 +4247,33 @@ xrecalloc (void *p, size_t new_nmemb, size_t old_nmemb, size_t size)\n /* Helper function.\n    Find fallthru edge from PRED.  */\n edge\n-find_fallthru_edge (basic_block pred)\n+find_fallthru_edge_from (basic_block pred)\n {\n   edge e;\n-  edge_iterator ei;\n   basic_block succ;\n \n   succ = pred->next_bb;\n   gcc_assert (succ->prev_bb == pred);\n \n   if (EDGE_COUNT (pred->succs) <= EDGE_COUNT (succ->preds))\n     {\n-      FOR_EACH_EDGE (e, ei, pred->succs)\n-\tif (e->flags & EDGE_FALLTHRU)\n-\t  {\n-\t    gcc_assert (e->dest == succ);\n-\t    return e;\n-\t  }\n+      e = find_fallthru_edge (pred->succs);\n+\n+      if (e)\n+\t{\n+\t  gcc_assert (e->dest == succ);\n+\t  return e;\n+\t}\n     }\n   else\n     {\n-      FOR_EACH_EDGE (e, ei, succ->preds)\n-\tif (e->flags & EDGE_FALLTHRU)\n-\t  {\n-\t    gcc_assert (e->src == pred);\n-\t    return e;\n-\t  }\n+      e = find_fallthru_edge (succ->preds);\n+\n+      if (e)\n+\t{\n+\t  gcc_assert (e->src == pred);\n+\t  return e;\n+\t}\n     }\n \n   return NULL;\n@@ -4314,7 +4315,7 @@ init_before_recovery (basic_block *before_recovery_ptr)\n   edge e;\n \n   last = EXIT_BLOCK_PTR->prev_bb;\n-  e = find_fallthru_edge (last);\n+  e = find_fallthru_edge_from (last);\n \n   if (e)\n     {"}, {"sha": "56d9d9eff0fa3e86aa807dfce82daf72d4ffab4c", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=0fd4b31d684af56704c69cdbc8a0c891403ac672", "patch": "@@ -278,12 +278,7 @@ find_active_insn_after (basic_block curr_bb, rtx insn)\n static basic_block\n block_fallthru (basic_block bb)\n {\n-  edge e;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (e->flags & EDGE_FALLTHRU)\n-      break;\n+  edge e = find_fallthru_edge (bb->succs);\n \n   return (e) ? e->dest : NULL_BLOCK;\n }"}, {"sha": "e77a14b425bedf89745164aab6b096c1bf38d7c9", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=0fd4b31d684af56704c69cdbc8a0c891403ac672", "patch": "@@ -9161,9 +9161,7 @@ fixup_abnormal_edges (void)\n \t      BB_END (bb) = insn;\n \t      insn = NEXT_INSN (insn);\n \n-\t      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t\tif (e->flags & EDGE_FALLTHRU)\n-\t\t  break;\n+\t      e = find_fallthru_edge (bb->succs);\n \n \t      while (insn && insn != stop)\n \t\t{"}, {"sha": "8e692158013a8d94483d64c820d239f3df9be28e", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=0fd4b31d684af56704c69cdbc8a0c891403ac672", "patch": "@@ -138,17 +138,14 @@ begin_schedule_ready (rtx insn, rtx last)\n       && last != PREV_INSN (insn))\n     {\n       edge e;\n-      edge_iterator ei;\n       basic_block bb;\n \n       /* An obscure special case, where we do have partially dead\n \t instruction scheduled after last control flow instruction.\n \t In this case we can create new basic block.  It is\n \t always exactly one basic block last in the sequence.  */\n \n-      FOR_EACH_EDGE (e, ei, last_bb->succs)\n-\tif (e->flags & EDGE_FALLTHRU)\n-\t  break;\n+      e = find_fallthru_edge (last_bb->succs);\n \n #ifdef ENABLE_CHECKING\n       gcc_assert (!e || !(e->flags & EDGE_COMPLEX));\n@@ -589,14 +586,11 @@ schedule_ebbs (void)\n       for (;;)\n \t{\n \t  edge e;\n-\t  edge_iterator ei;\n \t  tail = BB_END (bb);\n \t  if (bb->next_bb == EXIT_BLOCK_PTR\n \t      || LABEL_P (BB_HEAD (bb->next_bb)))\n \t    break;\n-\t  FOR_EACH_EDGE (e, ei, bb->succs)\n-\t    if ((e->flags & EDGE_FALLTHRU) != 0)\n-\t      break;\n+\t  e = find_fallthru_edge (bb->succs);\n \t  if (! e)\n \t    break;\n \t  if (e->probability <= probability_cutoff)"}, {"sha": "bea5aab5800ed2c39408f92c529785fc25fa80c3", "filename": "gcc/sched-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=0fd4b31d684af56704c69cdbc8a0c891403ac672", "patch": "@@ -199,7 +199,7 @@ extern int max_issue (struct ready_list *, int, state_t, int *);\n \n extern void ebb_compute_jump_reg_dependencies (rtx, regset, regset, regset);\n \n-extern edge find_fallthru_edge (basic_block);\n+extern edge find_fallthru_edge_from (basic_block);\n \n extern void (* sched_init_only_bb) (basic_block, basic_block);\n extern basic_block (* sched_split_block) (basic_block, rtx);"}, {"sha": "7e971e1d6ecb1a62c9e3583183783287b62a9d66", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=0fd4b31d684af56704c69cdbc8a0c891403ac672", "patch": "@@ -487,7 +487,6 @@ find_single_block_region (bool ebbs_p)\n         for (bb = ebb_start; ; bb = bb->next_bb)\n           {\n             edge e;\n-            edge_iterator ei;\n \n             rgn_bb_table[i] = bb->index;\n             RGN_NR_BLOCKS (nr_regions)++;\n@@ -499,9 +498,7 @@ find_single_block_region (bool ebbs_p)\n                 || LABEL_P (BB_HEAD (bb->next_bb)))\n               break;\n \n-            FOR_EACH_EDGE (e, ei, bb->succs)\n-             if ((e->flags & EDGE_FALLTHRU) != 0)\n-               break;\n+\t    e = find_fallthru_edge (bb->succs);\n             if (! e)\n               break;\n             if (e->probability <= probability_cutoff)"}, {"sha": "141c935f6d83c197b304198751f851cdd0c699cc", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=0fd4b31d684af56704c69cdbc8a0c891403ac672", "patch": "@@ -689,7 +689,7 @@ merge_fences (fence_t f, insn_t insn,\n \n       /* Find fallthrough edge.  */\n       gcc_assert (BLOCK_FOR_INSN (insn)->prev_bb);\n-      candidate = find_fallthru_edge (BLOCK_FOR_INSN (insn)->prev_bb);\n+      candidate = find_fallthru_edge_from (BLOCK_FOR_INSN (insn)->prev_bb);\n \n       if (!candidate\n           || (candidate->src != BLOCK_FOR_INSN (last_scheduled_insn)\n@@ -4667,7 +4667,6 @@ bb_ends_ebb_p (basic_block bb)\n {\n   basic_block next_bb = bb_next_bb (bb);\n   edge e;\n-  edge_iterator ei;\n \n   if (next_bb == EXIT_BLOCK_PTR\n       || bitmap_bit_p (forced_ebb_heads, next_bb->index)\n@@ -4680,13 +4679,13 @@ bb_ends_ebb_p (basic_block bb)\n   if (!in_current_region_p (next_bb))\n     return true;\n \n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if ((e->flags & EDGE_FALLTHRU) != 0)\n-      {\n-\tgcc_assert (e->dest == next_bb);\n-\n-\treturn false;\n-      }\n+  e = find_fallthru_edge (bb->succs);\n+  if (e)\n+    {\n+      gcc_assert (e->dest == next_bb);\n+      \n+      return false;\n+    }\n \n   return true;\n }"}, {"sha": "d93ebaae5a3527de0ac91974a48f8e0c86cd8b05", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=0fd4b31d684af56704c69cdbc8a0c891403ac672", "patch": "@@ -612,12 +612,14 @@ static bool\n in_fallthru_bb_p (rtx insn, rtx succ)\n {\n   basic_block bb = BLOCK_FOR_INSN (insn);\n+  edge e;\n \n   if (bb == BLOCK_FOR_INSN (succ))\n     return true;\n \n-  if (find_fallthru_edge (bb))\n-    bb = find_fallthru_edge (bb)->dest;\n+  e = find_fallthru_edge_from (bb);\n+  if (e)\n+    bb = e->dest;\n   else\n     return false;\n \n@@ -4905,7 +4907,7 @@ move_cond_jump (rtx insn, bnd_t bnd)\n   next = PREV_INSN (insn);\n   BND_TO (bnd) = insn;\n \n-  ft_edge = find_fallthru_edge (block_from);\n+  ft_edge = find_fallthru_edge_from (block_from);\n   block_next = ft_edge->dest;\n   /* There must be a fallthrough block (or where should go\n   control flow in case of false jump predicate otherwise?).  */"}, {"sha": "ec2b438ca47c59d29b7a7e97c00b8e95c26412f9", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fd4b31d684af56704c69cdbc8a0c891403ac672/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=0fd4b31d684af56704c69cdbc8a0c891403ac672", "patch": "@@ -782,17 +782,14 @@ expand_complex_move (gimple_stmt_iterator *gsi, tree type)\n     {\n       if (is_ctrl_altering_stmt (stmt))\n \t{\n-\t  edge_iterator ei;\n \t  edge e;\n \n \t  /* The value is not assigned on the exception edges, so we need not\n \t     concern ourselves there.  We do need to update on the fallthru\n \t     edge.  Find it.  */\n-\t  FOR_EACH_EDGE (e, ei, gsi_bb (*gsi)->succs)\n-\t    if (e->flags & EDGE_FALLTHRU)\n-\t      goto found_fallthru;\n-\t  gcc_unreachable ();\n-\tfound_fallthru:\n+\t  e = find_fallthru_edge (gsi_bb (*gsi)->succs);\n+\t  if (!e)\n+\t    gcc_unreachable ();\n \n \t  r = build1 (REALPART_EXPR, inner_type, lhs);\n \t  i = build1 (IMAGPART_EXPR, inner_type, lhs);"}]}