{"sha": "8f8cba46b89ad16bac2ce58d554c25b54b0e7c7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY4Y2JhNDZiODlhZDE2YmFjMmNlNThkNTU0YzI1YjU0YjBlN2M3Zg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@dacore.com", "date": "2020-07-07T05:47:53Z"}, "committer": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2020-10-14T19:24:45Z"}, "message": "Rework the condition variables support for VxWorks\n\nThis change reworks the condition variables support for VxWorks\nto address the very legit points raised by Rasmus in\n\n https://gcc.gnu.org/pipermail/gcc/2020-May/232524.html\n\nWhile some of the issues were taken care of by the use of semFlush,\na few others were indeed calling for adjustments.\n\nWe first considered resorting to the condvarLib library available\nin VxWorks7. Unfortunately, it is vx7 only and we wanted something working\nfor at least vx 6.9 as well. It also turned out requiring the use of\nrecursive mutexes for condVarWait, which seemed unnecessarily constraining.\n\nInstead, this change corrects the sequencing logic in a few places and\nleverages the semExchange API to ensure the key atomicity requirement on\ncond_wait operations.\n\n2020-10-14  Alexandre Oliva  <oliva@adacore.com>\n\nlibgcc/\n\t* config/gthr-vxworks-thread.c: Include stdlib.h.\n\t(tls_delete_hook): Prototype it.\n\t(__gthread_cond_signal): Return early if no waiters.  Consume\n\tsignal in case the semaphore got full.  Use semInfoGet instead\n\tof kernel-mode-only semInfo.\n\t(__gthread_cond_timedwait): Use semExchange.  Always take the\n\tmutex again before returning.\n\t* config/gthr-vxworks-cond.c (__ghtread_cond_wait): Likewise.", "tree": {"sha": "22bfa60b5c9cd8ccd75d45a53d2c14caffe1f037", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22bfa60b5c9cd8ccd75d45a53d2c14caffe1f037"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f8cba46b89ad16bac2ce58d554c25b54b0e7c7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f8cba46b89ad16bac2ce58d554c25b54b0e7c7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f8cba46b89ad16bac2ce58d554c25b54b0e7c7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f8cba46b89ad16bac2ce58d554c25b54b0e7c7f/comments", "author": null, "committer": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93103603fd66a9fcf3ea2d8b52657e4b2496f544", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93103603fd66a9fcf3ea2d8b52657e4b2496f544", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93103603fd66a9fcf3ea2d8b52657e4b2496f544"}], "stats": {"total": 59, "additions": 47, "deletions": 12}, "files": [{"sha": "65f0a6af183aa690c77eacddda88d955aec5abf4", "filename": "libgcc/config/gthr-vxworks-cond.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f8cba46b89ad16bac2ce58d554c25b54b0e7c7f/libgcc%2Fconfig%2Fgthr-vxworks-cond.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f8cba46b89ad16bac2ce58d554c25b54b0e7c7f/libgcc%2Fconfig%2Fgthr-vxworks-cond.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fgthr-vxworks-cond.c?ref=8f8cba46b89ad16bac2ce58d554c25b54b0e7c7f", "patch": "@@ -66,13 +66,11 @@ __gthread_cond_wait (__gthread_cond_t *cond,\n   if (!mutex)\n     return ERROR;\n \n-  __RETURN_ERRNO_IF_NOT_OK (semGive (*mutex));\n-\n-  __RETURN_ERRNO_IF_NOT_OK (semTake (*cond, WAIT_FOREVER));\n+  int ret = __CHECK_RESULT (semExchange (*mutex, *cond, WAIT_FOREVER));\n \n   __RETURN_ERRNO_IF_NOT_OK (semTake (*mutex, WAIT_FOREVER));\n \n-  return OK;\n+  return ret;\n }\n \n int"}, {"sha": "8e26d855931bf3c3a11e18288d8f0d6b91438282", "filename": "libgcc/config/gthr-vxworks-thread.c", "status": "modified", "additions": 45, "deletions": 8, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f8cba46b89ad16bac2ce58d554c25b54b0e7c7f/libgcc%2Fconfig%2Fgthr-vxworks-thread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f8cba46b89ad16bac2ce58d554c25b54b0e7c7f/libgcc%2Fconfig%2Fgthr-vxworks-thread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fgthr-vxworks-thread.c?ref=8f8cba46b89ad16bac2ce58d554c25b54b0e7c7f", "patch": "@@ -29,6 +29,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #include \"gthr.h\"\n #include <taskLib.h>\n+#include <stdlib.h>\n \n #define __TIMESPEC_TO_NSEC(timespec) \\\n   ((long long)timespec.tv_sec * 1000000000 + (long long)timespec.tv_nsec)\n@@ -38,7 +39,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n     / 1000000000)\n \n #ifdef __RTP__\n-  void tls_delete_hook ();\n+  void tls_delete_hook (void);\n   #define __CALL_DELETE_HOOK(tcb) tls_delete_hook()\n #else\n   /* In kernel mode, we need to pass the TCB to task_delete_hook. The TCB is\n@@ -47,17 +48,55 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n   #define __CALL_DELETE_HOOK(tcb) tls_delete_hook((WIND_TCB *) ((tcb)->task_id))\n #endif\n \n-/* -------------------- Timed Condition Variables --------------------- */\n-\n int\n __gthread_cond_signal (__gthread_cond_t *cond)\n {\n   if (!cond)\n     return ERROR;\n \n-  return __CHECK_RESULT (semGive (*cond));\n+  /* If nobody is waiting, skip the semGive altogether: no one can get\n+     in line while we hold the mutex associated with *COND.  We could\n+     skip this test altogether, but it's presumed cheaper than going\n+     through the give and take below, and that a signal without a\n+     waiter occurs often enough for the test to be worth it.  */\n+  SEM_INFO info;\n+  memset (&info, 0, sizeof (info));\n+  __RETURN_ERRNO_IF_NOT_OK (semInfoGet (*cond, &info));\n+  if (info.numTasks == 0)\n+    return OK;\n+\n+  int ret = __CHECK_RESULT (semGive (*cond));\n+\n+  /* It might be the case, however, that when we called semInfo, there\n+     was a waiter just about to timeout, and by the time we called\n+     semGive, it had already timed out, so our semGive would leave the\n+     *cond semaphore full, so the next caller of wait would pass\n+     through.  We don't want that.  So, make sure we leave the\n+     semaphore empty.  Despite the window in which the semaphore will\n+     be full, this works because:\n+\n+     - we're holding the mutex, so nobody else can semGive, and any\n+       pending semTakes are actually within semExchange.  there might\n+       be others blocked to acquire the mutex, but those are not\n+       relevant for the analysis.\n+\n+     - if there was another non-timed out waiter, semGive will wake it\n+       up immediately instead of leaving the semaphore full, so the\n+       semTake below will time out, and the semantics are as expected\n+\n+     - otherwise, if all waiters timed out before the semGive (or if\n+       there weren't any to begin with), our semGive completed leaving\n+       the semaphore full, and our semTake below will consume it\n+       before any other waiter has a change to reach the semExchange,\n+       because we're holding the mutex.  */\n+  if (ret == OK)\n+    semTake (*cond, NO_WAIT);\n+\n+  return ret;\n }\n \n+/* -------------------- Timed Condition Variables --------------------- */\n+\n int\n __gthread_cond_timedwait (__gthread_cond_t *cond,\n \t\t\t  __gthread_mutex_t *mutex,\n@@ -93,13 +132,11 @@ __gthread_cond_timedwait (__gthread_cond_t *cond,\n   if (waiting_ticks > INT_MAX)\n     waiting_ticks = INT_MAX;\n \n-  __RETURN_ERRNO_IF_NOT_OK (semGive (*mutex));\n-\n-  __RETURN_ERRNO_IF_NOT_OK (semTake (*cond, waiting_ticks));\n+  int ret = __CHECK_RESULT (semExchange (*mutex, *cond, waiting_ticks));\n \n   __RETURN_ERRNO_IF_NOT_OK (semTake (*mutex, WAIT_FOREVER));\n \n-  return OK;\n+  return ret;\n }\n \n /* --------------------------- Timed Mutexes ------------------------------ */"}]}