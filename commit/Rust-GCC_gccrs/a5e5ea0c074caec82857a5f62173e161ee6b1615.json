{"sha": "a5e5ea0c074caec82857a5f62173e161ee6b1615", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVlNWVhMGMwNzRjYWVjODI4NTdhNWY2MjE3M2UxNjFlZTZiMTYxNQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "s.pop@samsung.com", "date": "2015-08-27T19:06:56Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-08-27T19:06:56Z"}, "message": "remove -floop-unroll-and-jam\n\n\t* common.opt (floop-unroll-and-jam): Make alias of floop-nest-optimize.\n\t* doc/invoke.texi (-floop-unroll-and-jam): Document as alias of\n\t-floop-nest-optimize.\n\t* graphite-isl-ast-to-gimple.c (generate_luj_sepclass_opt): Remove.\n\t(generate_luj_sepclass): Remove.\n\t(generate_luj_options): Remove.\n\t(set_options): Remove opt_luj.\n\t(scop_to_isl_ast): Remove opt_luj.\n\t* graphite-optimize-isl.c (getScheduleForBand): Remove check for\n\tflag_loop_unroll_jam.\n\t(getPrevectorMap_full): Remove.\n\t(getScheduleForBandList): Remove map_sepcl.\n\t(getScheduleMap): Same.\n\t(apply_schedule_map_to_scop): Remove sepcl.\n\t(optimize_isl): Same.\n\t* graphite-poly.c (apply_poly_transforms): Remove check for\n\tflag_loop_unroll_jam.\n\t(new_poly_bb): Remove map_sepclass.\n\t* graphite-poly.h (struct poly_bb): Same.\n\t* graphite.c (gate_graphite_transforms): Remove flag_loop_unroll_jam.\n\t* params.def (PARAM_LOOP_UNROLL_JAM_SIZE)\n\t(PARAM_LOOP_UNROLL_JAM_DEPTH): Remove.\n\t* toplev.c (process_options): Remove flag_loop_unroll_jam.\n\nFrom-SVN: r227275", "tree": {"sha": "2f96cff577f230883f6e89429810de3ec56098a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f96cff577f230883f6e89429810de3ec56098a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5e5ea0c074caec82857a5f62173e161ee6b1615", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5e5ea0c074caec82857a5f62173e161ee6b1615", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5e5ea0c074caec82857a5f62173e161ee6b1615", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5e5ea0c074caec82857a5f62173e161ee6b1615/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e994d230f1a57bcad4aba0e987c60c4db496c7dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e994d230f1a57bcad4aba0e987c60c4db496c7dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e994d230f1a57bcad4aba0e987c60c4db496c7dd"}], "stats": {"total": 346, "additions": 55, "deletions": 291}, "files": [{"sha": "e776c16d5b76953459c96cff2d02b564ec361d51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5e5ea0c074caec82857a5f62173e161ee6b1615", "patch": "@@ -1,3 +1,29 @@\n+2015-08-27  Sebastian Pop  <s.pop@samsung.com>\n+\n+\t* common.opt (floop-unroll-and-jam): Make alias of floop-nest-optimize.\n+\t* doc/invoke.texi (-floop-unroll-and-jam): Document as alias of\n+\t-floop-nest-optimize.\n+\t* graphite-isl-ast-to-gimple.c (generate_luj_sepclass_opt): Remove.\n+\t(generate_luj_sepclass): Remove.\n+\t(generate_luj_options): Remove.\n+\t(set_options): Remove opt_luj.\n+\t(scop_to_isl_ast): Remove opt_luj.\n+\t* graphite-optimize-isl.c (getScheduleForBand): Remove check for\n+\tflag_loop_unroll_jam.\n+\t(getPrevectorMap_full): Remove.\n+\t(getScheduleForBandList): Remove map_sepcl.\n+\t(getScheduleMap): Same.\n+\t(apply_schedule_map_to_scop): Remove sepcl.\n+\t(optimize_isl): Same.\n+\t* graphite-poly.c (apply_poly_transforms): Remove check for\n+\tflag_loop_unroll_jam.\n+\t(new_poly_bb): Remove map_sepclass.\n+\t* graphite-poly.h (struct poly_bb): Same.\n+\t* graphite.c (gate_graphite_transforms): Remove flag_loop_unroll_jam.\n+\t* params.def (PARAM_LOOP_UNROLL_JAM_SIZE)\n+\t(PARAM_LOOP_UNROLL_JAM_DEPTH): Remove.\n+\t* toplev.c (process_options): Remove flag_loop_unroll_jam.\n+\n 2015-08-27  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/67317"}, {"sha": "0964ae4fdaeeb6e9bd0a7ba1e7a4a2738d1f9a80", "filename": "gcc/common.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=a5e5ea0c074caec82857a5f62173e161ee6b1615", "patch": "@@ -1353,8 +1353,8 @@ Common Report Var(flag_loop_block) Optimization\n Enable Loop Blocking transformation\n \n floop-unroll-and-jam\n-Common Report Var(flag_loop_unroll_jam) Optimization\n-Enable Loop Unroll Jam transformation\n+Common Alias(floop-nest-optimize)\n+Enable loop nest transforms.  Same as -floop-nest-optimize\n  \n fgnu-tm\n Common Report Var(flag_tm)"}, {"sha": "01423bb1e3dfe44ed3212ea1d6abe19c5a88a8be", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=a5e5ea0c074caec82857a5f62173e161ee6b1615", "patch": "@@ -8849,10 +8849,10 @@ is experimental.\n \n @item -floop-unroll-and-jam\n @opindex floop-unroll-and-jam\n-Enable unroll and jam for the ISL based loop nest optimizer.  The unroll \n-factor can be changed using the @option{loop-unroll-jam-size} parameter.\n-The unrolled dimension (counting from the most inner one) can be changed \n-using the @option{loop-unroll-jam-depth} parameter.                 .\n+Perform loop nest transformations.  Same as\n+@option{-floop-nest-optimize}.  To use this code transformation, GCC has\n+to be configured with @option{--with-isl} to enable the Graphite loop\n+transformation infrastructure.\n \n @item -floop-parallelize-all\n @opindex floop-parallelize-all"}, {"sha": "5434bfdeb6fb7247e78bbc4eb4882c0cccd54999", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 3, "deletions": 99, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=a5e5ea0c074caec82857a5f62173e161ee6b1615", "patch": "@@ -968,92 +968,6 @@ extend_schedule (__isl_take isl_map *schedule, int nb_schedule_dims)\n   return schedule;\n }\n \n-/* Set the separation_class option for unroll and jam. */\n-\n-static __isl_give isl_union_map *\n-generate_luj_sepclass_opt (scop_p scop, __isl_take isl_union_set *domain, \n-\t\t\tint dim, int cl)\n-{\n-  isl_map  *map;\n-  isl_space *space, *space_sep;\n-  isl_ctx *ctx;\n-  isl_union_map *mapu;\n-  int nsched = get_max_schedule_dimensions (scop);\n- \n-  ctx = scop->ctx;\n-  space_sep = isl_space_alloc (ctx, 0, 1, 1);\n-  space_sep = isl_space_wrap (space_sep);\n-  space_sep = isl_space_set_tuple_name (space_sep, isl_dim_set,\n-\t\t\t\t        \"separation_class\");\n-  space = isl_set_get_space (scop->context);\n-  space_sep = isl_space_align_params (space_sep, isl_space_copy(space));\n-  space = isl_space_map_from_domain_and_range (space, space_sep);\n-  space = isl_space_add_dims (space,isl_dim_in, nsched);\n-  map = isl_map_universe (space);\n-  isl_map_fix_si (map,isl_dim_out,0,dim);\n-  isl_map_fix_si (map,isl_dim_out,1,cl);\n-\n-  mapu = isl_union_map_intersect_domain (isl_union_map_from_map (map), \n-\t\t\t\t\t domain);\n-  return (mapu);\n-}\n-\n-/* Compute the separation class for loop unroll and jam.  */\n-\n-static __isl_give isl_union_set *\n-generate_luj_sepclass (scop_p scop)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-  isl_union_set *domain_isl;\n-\n-  domain_isl = isl_union_set_empty (isl_set_get_space (scop->context));\n-\n-  FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n-    {\n-      isl_set *bb_domain;\n-      isl_set *bb_domain_s;\n-\n-      if (pbb->map_sepclass == NULL)\n-\tcontinue;\n-\n-      if (isl_set_is_empty (pbb->domain))\n-\tcontinue;\n-\n-      bb_domain = isl_set_copy (pbb->domain);\n-      bb_domain_s = isl_set_apply (bb_domain, pbb->map_sepclass);\n-      pbb->map_sepclass = NULL;\n-\n-      domain_isl =\n-\tisl_union_set_union (domain_isl, isl_union_set_from_set (bb_domain_s));\n-    }\n-\n-  return domain_isl;\n-}\n-\n-/* Set the AST built options for loop unroll and jam. */\n- \n-static __isl_give isl_union_map *\n-generate_luj_options (scop_p scop)\n-{\n-  isl_union_set *domain_isl;\n-  isl_union_map *options_isl_ss;\n-  isl_union_map *options_isl =\n-    isl_union_map_empty (isl_set_get_space (scop->context));\n-  int dim = get_max_schedule_dimensions (scop) - 1;\n-  int dim1 = dim - PARAM_VALUE (PARAM_LOOP_UNROLL_JAM_DEPTH);\n-\n-  if (!flag_loop_unroll_jam)\n-    return options_isl;\n-\n-  domain_isl = generate_luj_sepclass (scop);\n-\n-  options_isl_ss = generate_luj_sepclass_opt (scop, domain_isl, dim1, 0);\n-  options_isl = isl_union_map_union (options_isl, options_isl_ss);\n-\n-  return options_isl;\n-}\n-\n /* Generates a schedule, which specifies an order used to\n    visit elements in a domain.  */\n \n@@ -1102,13 +1016,11 @@ ast_build_before_for (__isl_keep isl_ast_build *build, void *user)\n }\n \n /* Set the separate option for all dimensions.\n-   This helps to reduce control overhead.\n-   Set the options for unroll and jam.  */\n+   This helps to reduce control overhead.  */\n \n static __isl_give isl_ast_build *\n set_options (__isl_take isl_ast_build *control,\n-\t     __isl_keep isl_union_map *schedule,\n-\t     __isl_take isl_union_map *opt_luj)\n+\t     __isl_keep isl_union_map *schedule)\n {\n   isl_ctx *ctx = isl_union_map_get_ctx (schedule);\n   isl_space *range_space = isl_space_set_alloc (ctx, 0, 1);\n@@ -1119,9 +1031,6 @@ set_options (__isl_take isl_ast_build *control,\n   isl_union_set *domain = isl_union_map_range (isl_union_map_copy (schedule));\n   domain = isl_union_set_universe (domain);\n   isl_union_map *options = isl_union_map_from_domain_and_range (domain, range);\n-\n-  options = isl_union_map_union (options, opt_luj);\n-\n   return isl_ast_build_set_options (control, options);\n }\n \n@@ -1135,14 +1044,9 @@ scop_to_isl_ast (scop_p scop, ivs_params &ip)\n   isl_options_set_ast_build_atomic_upper_bound (scop->ctx, true);\n \n   add_parameters_to_ivs_params (scop, ip);\n-\n-  isl_union_map *options_luj = generate_luj_options (scop);\n-\n   isl_union_map *schedule_isl = generate_isl_schedule (scop);\n   isl_ast_build *context_isl = generate_isl_context (scop);\n-\n-  context_isl = set_options (context_isl, schedule_isl, options_luj);\n-\n+  context_isl = set_options (context_isl, schedule_isl);\n   isl_union_map *dependences = NULL;\n   if (flag_loop_parallelize_all)\n   {"}, {"sha": "470dbfa4aaec4b64cb58abffb9ff11d6c779a60c", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 17, "deletions": 162, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=a5e5ea0c074caec82857a5f62173e161ee6b1615", "patch": "@@ -172,7 +172,7 @@ getScheduleForBand (isl_band *Band, int *Dimensions)\n   PartialSchedule = isl_band_get_partial_schedule (Band);\n   *Dimensions = isl_band_n_member (Band);\n \n-  if (DisableTiling || flag_loop_unroll_jam)\n+  if (DisableTiling)\n     return PartialSchedule;\n \n   /* It does not make any sense to tile a band with just one dimension.  */\n@@ -227,9 +227,7 @@ getScheduleForBand (isl_band *Band, int *Dimensions)\n    constant number of iterations, if the number of loop iterations at\n    DimToVectorize can be devided by VectorWidth. The default VectorWidth is\n    currently constant and not yet target specific. This function does not reason\n-   about parallelism.\n-\n-  */\n+   about parallelism.  */\n static isl_map *\n getPrevectorMap (isl_ctx *ctx, int DimToVectorize,\n \t\t int ScheduleDimensions,\n@@ -296,109 +294,15 @@ getPrevectorMap (isl_ctx *ctx, int DimToVectorize,\n   return TilingMap;\n }\n \n-/* Compute an auxiliary map to getPrevectorMap, for computing the separating \n-   class defined by full tiles.  Used in graphite_isl_ast_to_gimple.c to set the \n-   corresponding option for AST build.\n-\n-   The map (for VectorWidth=4):\n-\n-   [i,j] -> [it,j,ip] : it % 4 = 0 and it <= ip <= it + 3 and it + 3 = i and\n-                        ip >= 0\n-\n-   The image of this map is the separation class. The range of this map includes\n-   all the i multiple of 4 in the domain such as i + 3 is in the domain too.\n-    \n- */ \n-static isl_map *\n-getPrevectorMap_full (isl_ctx *ctx, int DimToVectorize,\n-\t\t int ScheduleDimensions,\n-\t\t int VectorWidth)\n-{\n-  isl_space *Space;\n-  isl_local_space *LocalSpace, *LocalSpaceRange;\n-  isl_set *Modulo;\n-  isl_map *TilingMap;\n-  isl_constraint *c;\n-  isl_aff *Aff;\n-  int PointDimension; /* ip */\n-  int TileDimension;  /* it */\n-  isl_val *VectorWidthMP;\n-  int i;\n-\n-  /* assert (0 <= DimToVectorize && DimToVectorize < ScheduleDimensions);*/\n-\n-  Space = isl_space_alloc (ctx, 0, ScheduleDimensions, ScheduleDimensions + 1);\n-  TilingMap = isl_map_universe (isl_space_copy (Space));\n-  LocalSpace = isl_local_space_from_space (Space);\n-  PointDimension = ScheduleDimensions;\n-  TileDimension = DimToVectorize;\n-\n-  /* Create an identity map for everything except DimToVectorize and the \n-     point loop. */\n-  for (i = 0; i < ScheduleDimensions; i++)\n-    {\n-      if (i == DimToVectorize)\n-        continue;\n-\n-      c = isl_equality_alloc (isl_local_space_copy (LocalSpace));\n-\n-      isl_constraint_set_coefficient_si (c, isl_dim_in, i, -1);\n-      isl_constraint_set_coefficient_si (c, isl_dim_out, i, 1);\n-\n-      TilingMap = isl_map_add_constraint (TilingMap, c);\n-    }\n-\n-  /* it % 'VectorWidth' = 0  */\n-  LocalSpaceRange = isl_local_space_range (isl_local_space_copy (LocalSpace));\n-  Aff = isl_aff_zero_on_domain (LocalSpaceRange);\n-  Aff = isl_aff_set_constant_si (Aff, VectorWidth);\n-  Aff = isl_aff_set_coefficient_si (Aff, isl_dim_in, TileDimension, 1);\n-\n-  VectorWidthMP = isl_val_int_from_si (ctx, VectorWidth);\n-  Aff = isl_aff_mod_val (Aff, VectorWidthMP);\n-  Modulo = isl_pw_aff_zero_set (isl_pw_aff_from_aff (Aff));\n-  TilingMap = isl_map_intersect_range (TilingMap, Modulo);\n-\n-  /* it + ('VectorWidth' - 1) = i0  */\n-  c = isl_equality_alloc (isl_local_space_copy(LocalSpace));\n-  isl_constraint_set_coefficient_si (c, isl_dim_out, TileDimension,-1);\n-  isl_constraint_set_coefficient_si (c, isl_dim_in, TileDimension, 1);\n-  isl_constraint_set_constant_si (c, -VectorWidth + 1);\n-  TilingMap = isl_map_add_constraint (TilingMap, c);\n-\n-  /* ip >= 0 */\n-  c = isl_inequality_alloc (isl_local_space_copy (LocalSpace));\n-  isl_constraint_set_coefficient_si (c, isl_dim_out, PointDimension, 1);\n-  isl_constraint_set_constant_si (c, 0);\n-  TilingMap = isl_map_add_constraint (TilingMap, c);\n-\n-  /* it <= ip */\n-  c = isl_inequality_alloc (isl_local_space_copy (LocalSpace));\n-  isl_constraint_set_coefficient_si (c, isl_dim_out, TileDimension, -1);\n-  isl_constraint_set_coefficient_si (c, isl_dim_out, PointDimension, 1);\n-  TilingMap = isl_map_add_constraint (TilingMap, c);\n-\n-  /* ip <= it + ('VectorWidth' - 1) */\n-  c = isl_inequality_alloc (LocalSpace);\n-  isl_constraint_set_coefficient_si (c, isl_dim_out, TileDimension, 1);\n-  isl_constraint_set_coefficient_si (c, isl_dim_out, PointDimension, -1);\n-  isl_constraint_set_constant_si (c, VectorWidth - 1);\n-  TilingMap = isl_map_add_constraint (TilingMap, c);\n-\n-  return TilingMap;\n-}\n-\n static bool EnablePollyVector = false;\n \n /* getScheduleForBandList - Get the scheduling map for a list of bands.\n-    \n+\n    We walk recursively the forest of bands to combine the schedules of the\n    individual bands to the overall schedule. In case tiling is requested,\n-   the individual bands are tiled.\n-   For unroll and jam the map the schedule for full tiles of the unrolled\n-   dimnesion is computed.  */\n+   the individual bands are tiled.  */\n static isl_union_map *\n-getScheduleForBandList (isl_band_list *BandList, isl_union_map **map_sepcl)\n+getScheduleForBandList (isl_band_list *BandList)\n {\n   int NumBands, i;\n   isl_union_map *Schedule;\n@@ -415,37 +319,25 @@ getScheduleForBandList (isl_band_list *BandList, isl_union_map **map_sepcl)\n       int ScheduleDimensions;\n       isl_space *Space;\n \n-      isl_union_map *PartialSchedule_f;\n-\n       Band = isl_band_list_get_band (BandList, i);\n       PartialSchedule = getScheduleForBand (Band, &ScheduleDimensions);\n       Space = isl_union_map_get_space (PartialSchedule);\n \n-      PartialSchedule_f = NULL;\n-\n       if (isl_band_has_children (Band))\n \t{\n \t  isl_band_list *Children;\n \t  isl_union_map *SuffixSchedule;\n \n \t  Children = isl_band_get_children (Band);\n-\t  SuffixSchedule = getScheduleForBandList (Children, map_sepcl);\n+\t  SuffixSchedule = getScheduleForBandList (Children);\n \t  PartialSchedule = isl_union_map_flat_range_product (PartialSchedule,\n \t\t\t\t\t\t\t      SuffixSchedule);\n \t  isl_band_list_free (Children);\n \t}\n-      else if (EnablePollyVector || flag_loop_unroll_jam)\n+      else if (EnablePollyVector)\n \t{\n-\t  int i;\n-\t  int depth;\n- \n- \t  depth = PARAM_VALUE (PARAM_LOOP_UNROLL_JAM_DEPTH);\n-  \n \t  for (i = ScheduleDimensions - 1 ;  i >= 0 ; i--)\n \t    {\n-\t      if (flag_loop_unroll_jam && (i != (ScheduleDimensions - depth)))\n-\t\tcontinue;\n-\n #ifdef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE\n \t      if (isl_band_member_is_coincident (Band, i))\n #else\n@@ -454,19 +346,8 @@ getScheduleForBandList (isl_band_list *BandList, isl_union_map **map_sepcl)\n \t\t{\n \t\t  isl_map *TileMap;\n \t\t  isl_union_map *TileUMap;\n-\t\t  int stride;\n \n-                  stride = PARAM_VALUE (PARAM_LOOP_UNROLL_JAM_SIZE);    \n-\n-\t\t  TileMap = getPrevectorMap_full (ctx, i, ScheduleDimensions, \n-\t\t\t\t\t\t  stride); \n- \t\t  TileUMap = isl_union_map_from_map (TileMap);\n-\t\t  TileUMap = isl_union_map_align_params\n-\t\t    (TileUMap, isl_space_copy (Space));\n-\t\t  PartialSchedule_f = isl_union_map_apply_range\n-\t\t    (isl_union_map_copy (PartialSchedule), TileUMap);\n-\n-\t\t  TileMap = getPrevectorMap (ctx, i, ScheduleDimensions, stride);\n+\t\t  TileMap = getPrevectorMap (ctx, i, ScheduleDimensions, 4);\n \t\t  TileUMap = isl_union_map_from_map (TileMap);\n \t\t  TileUMap = isl_union_map_align_params\n \t\t    (TileUMap, isl_space_copy (Space));\n@@ -476,35 +357,21 @@ getScheduleForBandList (isl_band_list *BandList, isl_union_map **map_sepcl)\n \t\t}\t\n \t    }\n \t}\n-      Schedule = isl_union_map_union (Schedule, \n-                                      isl_union_map_copy(PartialSchedule));\n+\n+      Schedule = isl_union_map_union (Schedule, PartialSchedule);\n \n       isl_band_free (Band);\n       isl_space_free (Space);\n-\n-      if (!flag_loop_unroll_jam)\n-\t{\n-          isl_union_map_free (PartialSchedule);\n-          continue;\n-\t}\n-\n-      if (PartialSchedule_f)\n-\t{\n-\t  *map_sepcl = isl_union_map_union (*map_sepcl, PartialSchedule_f);\n-          isl_union_map_free (PartialSchedule);\n-\t}\n-      else\n-        *map_sepcl = isl_union_map_union (*map_sepcl, PartialSchedule);\n     }\n \n   return Schedule;\n }\n \n static isl_union_map *\n-getScheduleMap (isl_schedule *Schedule, isl_union_map **map_sepcl)\n+getScheduleMap (isl_schedule *Schedule)\n {\n   isl_band_list *BandList = isl_schedule_get_band_forest (Schedule);\n-  isl_union_map *ScheduleMap = getScheduleForBandList (BandList, map_sepcl);\n+  isl_union_map *ScheduleMap = getScheduleForBandList (BandList);\n   isl_band_list_free (BandList);\n   return ScheduleMap;\n }\n@@ -519,7 +386,7 @@ getSingleMap (__isl_take isl_map *map, void *user)\n }\n \n static void\n-apply_schedule_map_to_scop (scop_p scop, isl_union_map *schedule_map, bool sepcl)\n+apply_schedule_map_to_scop (scop_p scop, isl_union_map *schedule_map)\n {\n   int i;\n   poly_bb_p pbb;\n@@ -534,15 +401,8 @@ apply_schedule_map_to_scop (scop_p scop, isl_union_map *schedule_map, bool sepcl\n \t(isl_union_map_copy (schedule_map),\n \t isl_union_set_from_set (domain));\n       isl_union_map_foreach_map (stmtBand, getSingleMap, &stmtSchedule);\n-\n-      if (!sepcl)\n-\t{\n-\t  isl_map_free (pbb->transformed);\n-\t  pbb->transformed = stmtSchedule;\n-\t}\n-      else\n-\t  pbb->map_sepclass = stmtSchedule;\n-\n+      isl_map_free (pbb->transformed);\n+      pbb->transformed = stmtSchedule;\n       isl_union_map_free (stmtBand);\n     }\n }\n@@ -560,7 +420,6 @@ optimize_isl (scop_p scop)\n   isl_union_set *domain;\n   isl_union_map *validity, *proximity, *dependences;\n   isl_union_map *schedule_map;\n-  isl_union_map *schedule_map_f;\n \n   domain = scop_get_domains (scop);\n   dependences = scop_get_dependences (scop);\n@@ -605,13 +464,9 @@ optimize_isl (scop_p scop)\n   if (!schedule)\n     return false;\n \n-  schedule_map_f = isl_union_map_empty (isl_space_params_alloc (scop->ctx, 0));\n-  schedule_map = getScheduleMap (schedule, &schedule_map_f);\n+  schedule_map = getScheduleMap (schedule);\n \n-  apply_schedule_map_to_scop (scop, schedule_map, false);\n-  if (!isl_union_map_is_empty (schedule_map_f))\n-    apply_schedule_map_to_scop (scop, schedule_map_f, true);\n-  isl_union_map_free (schedule_map_f);\n+  apply_schedule_map_to_scop (scop, schedule_map);\n \n   isl_schedule_free (schedule);\n   isl_union_map_free (schedule_map);"}, {"sha": "7ea938966c9ae50ec953aa443c23b0bec32fbd19", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=a5e5ea0c074caec82857a5f62173e161ee6b1615", "patch": "@@ -258,7 +258,7 @@ apply_poly_transforms (scop_p scop)\n \n   /* This pass needs to be run at the final stage, as it does not\n      update the lst.  */\n-  if (flag_loop_optimize_isl || flag_loop_unroll_jam)\n+  if (flag_loop_optimize_isl)\n     transform_done |= optimize_isl (scop);\n \n   return transform_done;\n@@ -309,7 +309,6 @@ new_poly_bb (scop_p scop, void *black_box)\n   pbb->schedule = NULL;\n   pbb->transformed = NULL;\n   pbb->saved = NULL;\n-  pbb->map_sepclass = NULL;\n   PBB_SCOP (pbb) = scop;\n   pbb_set_black_box (pbb, black_box);\n   PBB_TRANSFORMED (pbb) = NULL;"}, {"sha": "29813e0a6ec9d55dd24781abc7b66b96aad1c7c0", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=a5e5ea0c074caec82857a5f62173e161ee6b1615", "patch": "@@ -356,9 +356,6 @@ struct poly_bb\n   poly_scattering_p _saved;\n   isl_map *saved;\n \n-  /* For tiling, the map for computing the separating class.  */\n-  isl_map *map_sepclass;\n-\n   /* True when this PBB contains only a reduction statement.  */\n   bool is_reduction;\n };"}, {"sha": "4acc172b0afe50d18c93102890394205ebc56e1e", "filename": "gcc/graphite.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=a5e5ea0c074caec82857a5f62173e161ee6b1615", "patch": "@@ -331,8 +331,7 @@ gate_graphite_transforms (void)\n       || flag_loop_strip_mine\n       || flag_graphite_identity\n       || flag_loop_parallelize_all\n-      || flag_loop_optimize_isl\n-      || flag_loop_unroll_jam)\n+      || flag_loop_optimize_isl)\n     flag_graphite = 1;\n \n   return flag_graphite != 0;"}, {"sha": "c8b3a90e2068ee2ff54587bacf154127573fa32b", "filename": "gcc/params.def", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=a5e5ea0c074caec82857a5f62173e161ee6b1615", "patch": "@@ -830,21 +830,6 @@ DEFPARAM (PARAM_LOOP_BLOCK_TILE_SIZE,\n \t  \"size of tiles for loop blocking\",\n \t  51, 0, 0)\n \n-/* Size of unrolling factor for unroll-and-jam.  */\n- \n-DEFPARAM (PARAM_LOOP_UNROLL_JAM_SIZE,\n- \t  \"loop-unroll-jam-size\",\n- \t  \"size of unrolling factor for unroll-and-jam\",\n- \t  4, 0, 0)\n-\n-/* Size of the band formed by the strip mined dimension and the most inner one for unroll-and-jam.  */\n- \n-DEFPARAM (PARAM_LOOP_UNROLL_JAM_DEPTH,\n- \t  \"loop-unroll-jam-depth\",\n- \t  \"depth of unrolled loop for unroll-and-jam\",\n- \t  2, 0, 0)\n-\n-\n /* Maximal number of parameters that we allow in a SCoP.  */\n \n DEFPARAM (PARAM_GRAPHITE_MAX_NB_SCOP_PARAMS,"}, {"sha": "39967d0b298c38edcaae92e408d401bfaa9101fa", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5e5ea0c074caec82857a5f62173e161ee6b1615/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=a5e5ea0c074caec82857a5f62173e161ee6b1615", "patch": "@@ -1320,8 +1320,7 @@ process_options (void)\n       || flag_loop_block\n       || flag_loop_interchange\n       || flag_loop_strip_mine\n-      || flag_loop_parallelize_all\n-      || flag_loop_unroll_jam)\n+      || flag_loop_parallelize_all)\n     sorry (\"Graphite loop optimizations cannot be used (ISL is not available)\" \n \t   \"(-fgraphite, -fgraphite-identity, -floop-block, \"\n \t   \"-floop-interchange, -floop-strip-mine, -floop-parallelize-all, \""}]}