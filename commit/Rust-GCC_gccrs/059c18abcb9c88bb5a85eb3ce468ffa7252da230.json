{"sha": "059c18abcb9c88bb5a85eb3ce468ffa7252da230", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU5YzE4YWJjYjljODhiYjVhODVlYjNjZTQ2OGZmYTcyNTJkYTIzMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-07T18:41:13Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-07T18:41:13Z"}, "message": "Use tree_vector_builder::new_unary_operation for folding\n\nThis patch makes fold-const.c operate directly on the VECTOR_CST\nencoding when folding an operation that has a single VECTOR_CST input.\n\n2017-12-07  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* fold-const.c (fold_negate_expr_1): Use tree_vector_builder and\n\tnew_unary_operation, operating only on the encoded elements.\n\t(const_unop): Likewise.\n\t(exact_inverse): Likewise.\n\t(distributes_over_addition_p): New function.\n\t(const_binop): Use tree_vector_builder and new_unary_operation\n\tfor combinations of VECTOR_CST and INTEGER_CST.  Operate only\n\ton the encoded elements unless the encoding is strided and the\n\toperation does not distribute over addition.\n\t(fold_convert_const):  Use tree_vector_builder and\n\tnew_unary_operation.  Operate only on the encoded elements\n\tfor truncating integer conversions, or for non-stepped encodings.\n\nFrom-SVN: r255476", "tree": {"sha": "b17857f981feeaf586dbb8d29c15e3b8ae09de91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b17857f981feeaf586dbb8d29c15e3b8ae09de91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/059c18abcb9c88bb5a85eb3ce468ffa7252da230", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/059c18abcb9c88bb5a85eb3ce468ffa7252da230", "html_url": "https://github.com/Rust-GCC/gccrs/commit/059c18abcb9c88bb5a85eb3ce468ffa7252da230", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/059c18abcb9c88bb5a85eb3ce468ffa7252da230/comments", "author": null, "committer": null, "parents": [{"sha": "5ebaa4774fb6de458422c660ae11f1c3b7d96262", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ebaa4774fb6de458422c660ae11f1c3b7d96262", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ebaa4774fb6de458422c660ae11f1c3b7d96262"}], "stats": {"total": 96, "additions": 73, "deletions": 23}, "files": [{"sha": "c541ad72c08117ddc921244e807116313cddeb2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059c18abcb9c88bb5a85eb3ce468ffa7252da230/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059c18abcb9c88bb5a85eb3ce468ffa7252da230/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=059c18abcb9c88bb5a85eb3ce468ffa7252da230", "patch": "@@ -1,3 +1,18 @@\n+2017-12-07  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* fold-const.c (fold_negate_expr_1): Use tree_vector_builder and\n+\tnew_unary_operation, operating only on the encoded elements.\n+\t(const_unop): Likewise.\n+\t(exact_inverse): Likewise.\n+\t(distributes_over_addition_p): New function.\n+\t(const_binop): Use tree_vector_builder and new_unary_operation\n+\tfor combinations of VECTOR_CST and INTEGER_CST.  Operate only\n+\ton the encoded elements unless the encoding is strided and the\n+\toperation does not distribute over addition.\n+\t(fold_convert_const):  Use tree_vector_builder and\n+\tnew_unary_operation.  Operate only on the encoded elements\n+\tfor truncating integer conversions, or for non-stepped encodings.\n+\n 2017-12-07  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* config/sparc/sparc.c: Include tree-vector-builder.h."}, {"sha": "af1f426300bc9d521d9bf11a3b922481f50e3dc7", "filename": "gcc/fold-const.c", "status": "modified", "additions": 58, "deletions": 23, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/059c18abcb9c88bb5a85eb3ce468ffa7252da230/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/059c18abcb9c88bb5a85eb3ce468ffa7252da230/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=059c18abcb9c88bb5a85eb3ce468ffa7252da230", "patch": "@@ -566,18 +566,18 @@ fold_negate_expr_1 (location_t loc, tree t)\n \n     case VECTOR_CST:\n       {\n-\tint count = VECTOR_CST_NELTS (t), i;\n-\n-\tauto_vec<tree, 32> elts (count);\n-\tfor (i = 0; i < count; i++)\n+\ttree_vector_builder elts;\n+\telts.new_unary_operation (type, t, true);\n+\tunsigned int count = elts.encoded_nelts ();\n+\tfor (unsigned int i = 0; i < count; ++i)\n \t  {\n \t    tree elt = fold_negate_expr (loc, VECTOR_CST_ELT (t, i));\n \t    if (elt == NULL_TREE)\n \t      return NULL_TREE;\n \t    elts.quick_push (elt);\n \t  }\n \n-\treturn build_vector (type, elts);\n+\treturn elts.build ();\n       }\n \n     case COMPLEX_EXPR:\n@@ -1121,6 +1121,27 @@ int_const_binop (enum tree_code code, const_tree arg1, const_tree arg2)\n   return int_const_binop_1 (code, arg1, arg2, 1);\n }\n \n+/* Return true if binary operation OP distributes over addition in operand\n+   OPNO, with the other operand being held constant.  OPNO counts from 1.  */\n+\n+static bool\n+distributes_over_addition_p (tree_code op, int opno)\n+{\n+  switch (op)\n+    {\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+      return true;\n+\n+    case LSHIFT_EXPR:\n+      return opno == 1;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Combine two constants ARG1 and ARG2 under operation CODE to produce a new\n    constant.  We assume ARG1 and ARG2 have the same data type, or at least\n    are the same kind of constant and the same machine mode.  Return zero if\n@@ -1442,10 +1463,12 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n       && TREE_CODE (arg2) == INTEGER_CST)\n     {\n       tree type = TREE_TYPE (arg1);\n-      int count = VECTOR_CST_NELTS (arg1), i;\n-\n-      auto_vec<tree, 32> elts (count);\n-      for (i = 0; i < count; i++)\n+      bool step_ok_p = distributes_over_addition_p (code, 1);\n+      tree_vector_builder elts;\n+      if (!elts.new_unary_operation (type, arg1, step_ok_p))\n+\treturn NULL_TREE;\n+      unsigned int count = elts.encoded_nelts ();\n+      for (unsigned int i = 0; i < count; ++i)\n \t{\n \t  tree elem1 = VECTOR_CST_ELT (arg1, i);\n \n@@ -1458,7 +1481,7 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n \t  elts.quick_push (elt);\n \t}\n \n-      return build_vector (type, elts);\n+      return elts.build ();\n     }\n   return NULL_TREE;\n }\n@@ -1649,10 +1672,12 @@ const_unop (enum tree_code code, tree type, tree arg0)\n       else if (TREE_CODE (arg0) == VECTOR_CST)\n \t{\n \t  tree elem;\n-\t  unsigned count = VECTOR_CST_NELTS (arg0), i;\n \n-\t  auto_vec<tree, 32> elements (count);\n-\t  for (i = 0; i < count; i++)\n+\t  /* This can cope with stepped encodings because ~x == -1 - x.  */\n+\t  tree_vector_builder elements;\n+\t  elements.new_unary_operation (type, arg0, true);\n+\t  unsigned int i, count = elements.encoded_nelts ();\n+\t  for (i = 0; i < count; ++i)\n \t    {\n \t      elem = VECTOR_CST_ELT (arg0, i);\n \t      elem = const_unop (BIT_NOT_EXPR, TREE_TYPE (type), elem);\n@@ -1661,7 +1686,7 @@ const_unop (enum tree_code code, tree type, tree arg0)\n \t      elements.quick_push (elem);\n \t    }\n \t  if (i == count)\n-\t    return build_vector (type, elements);\n+\t    return elements.build ();\n \t}\n       break;\n \n@@ -2135,18 +2160,27 @@ fold_convert_const (enum tree_code code, tree type, tree arg1)\n       if (TREE_CODE (arg1) == VECTOR_CST\n \t  && TYPE_VECTOR_SUBPARTS (type) == VECTOR_CST_NELTS (arg1))\n \t{\n-\t  int len = VECTOR_CST_NELTS (arg1);\n \t  tree elttype = TREE_TYPE (type);\n-\t  auto_vec<tree, 32> v (len);\n-\t  for (int i = 0; i < len; ++i)\n+\t  tree arg1_elttype = TREE_TYPE (TREE_TYPE (arg1));\n+\t  /* We can't handle steps directly when extending, since the\n+\t     values need to wrap at the original precision first.  */\n+\t  bool step_ok_p\n+\t    = (INTEGRAL_TYPE_P (elttype)\n+\t       && INTEGRAL_TYPE_P (arg1_elttype)\n+\t       && TYPE_PRECISION (elttype) <= TYPE_PRECISION (arg1_elttype));\n+\t  tree_vector_builder v;\n+\t  if (!v.new_unary_operation (type, arg1, step_ok_p))\n+\t    return NULL_TREE;\n+\t  unsigned int len = v.encoded_nelts ();\n+\t  for (unsigned int i = 0; i < len; ++i)\n \t    {\n \t      tree elt = VECTOR_CST_ELT (arg1, i);\n \t      tree cvt = fold_convert_const (code, elttype, elt);\n \t      if (cvt == NULL_TREE)\n \t\treturn NULL_TREE;\n \t      v.quick_push (cvt);\n \t    }\n-\t  return build_vector (type, v);\n+\t  return v.build ();\n \t}\n     }\n   return NULL_TREE;\n@@ -8832,7 +8866,6 @@ exact_inverse (tree type, tree cst)\n   REAL_VALUE_TYPE r;\n   tree unit_type;\n   machine_mode mode;\n-  unsigned vec_nelts, i;\n \n   switch (TREE_CODE (cst))\n     {\n@@ -8846,20 +8879,22 @@ exact_inverse (tree type, tree cst)\n \n     case VECTOR_CST:\n       {\n-\tvec_nelts = VECTOR_CST_NELTS (cst);\n \tunit_type = TREE_TYPE (type);\n \tmode = TYPE_MODE (unit_type);\n \n-\tauto_vec<tree, 32> elts (vec_nelts);\n-\tfor (i = 0; i < vec_nelts; i++)\n+\ttree_vector_builder elts;\n+\tif (!elts.new_unary_operation (type, cst, false))\n+\t  return NULL_TREE;\n+\tunsigned int count = elts.encoded_nelts ();\n+\tfor (unsigned int i = 0; i < count; ++i)\n \t  {\n \t    r = TREE_REAL_CST (VECTOR_CST_ELT (cst, i));\n \t    if (!exact_real_inverse (mode, &r))\n \t      return NULL_TREE;\n \t    elts.quick_push (build_real (unit_type, r));\n \t  }\n \n-\treturn build_vector (type, elts);\n+\treturn elts.build ();\n       }\n \n     default:"}]}