{"sha": "85f0a4d98229203181014fb84a1e4f74813aab9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVmMGE0ZDk4MjI5MjAzMTgxMDE0ZmI4NGExZTRmNzQ4MTNhYWI5ZQ==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2020-11-23T16:27:59Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2020-12-09T11:10:40Z"}, "message": "Import HSA header files from AMD\n\nThese are the same header files that exist in the Radeon Open Compute Runtime\nproject (as of October 2020), but they have been specially relicensed by AMD\nfor use in GCC.\n\nThe header files retain AMD copyright.\n\ninclude/ChangeLog:\n\n\t* hsa.h: Replace whole file.\n\t* hsa_ext_amd.h: New file.\n\t* hsa_ext_image.h: New file.\n\nlibgomp/ChangeLog:\n\n\t* plugin/plugin-gcn.c: Include hsa_ext_amd.h.\n\t(HSA_AMD_AGENT_INFO_COMPUTE_UNIT_COUNT): Delete redundant definition.", "tree": {"sha": "a99494730010035bc8b5a1c93b4ad464f4f4f40a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a99494730010035bc8b5a1c93b4ad464f4f4f40a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85f0a4d98229203181014fb84a1e4f74813aab9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f0a4d98229203181014fb84a1e4f74813aab9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85f0a4d98229203181014fb84a1e4f74813aab9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f0a4d98229203181014fb84a1e4f74813aab9e/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42bdf814493c2c39e7a6bd3fb2dd4491352ce5d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42bdf814493c2c39e7a6bd3fb2dd4491352ce5d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42bdf814493c2c39e7a6bd3fb2dd4491352ce5d9"}], "stats": {"total": 9476, "additions": 8946, "deletions": 530}, "files": [{"sha": "f9b5d9daf85d1f2a0ba3bf757f1c0a22227f1e1c", "filename": "include/hsa.h", "status": "modified", "additions": 5536, "deletions": 525, "changes": 6061, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f0a4d98229203181014fb84a1e4f74813aab9e/include%2Fhsa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f0a4d98229203181014fb84a1e4f74813aab9e/include%2Fhsa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fhsa.h?ref=85f0a4d98229203181014fb84a1e4f74813aab9e"}, {"sha": "1f93e0d96cc471269c4b624e4d6e3f2365e0128f", "filename": "include/hsa_ext_amd.h", "status": "added", "additions": 1969, "deletions": 0, "changes": 1969, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f0a4d98229203181014fb84a1e4f74813aab9e/include%2Fhsa_ext_amd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f0a4d98229203181014fb84a1e4f74813aab9e/include%2Fhsa_ext_amd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fhsa_ext_amd.h?ref=85f0a4d98229203181014fb84a1e4f74813aab9e", "patch": "@@ -0,0 +1,1969 @@\n+////////////////////////////////////////////////////////////////////////////////\n+//\n+// Copyright (C) 2014-2020 Advanced Micro Devices Inc.  All rights reserved.\n+//\n+// Permission is hereby granted, free of charge, to any person or organization\n+// obtaining a copy of the software and accompanying documentation covered by\n+// this license (the \"Software\") to use, reproduce, display, distribute,\n+// execute, and transmit the Software, and to prepare derivative works of the\n+// Software, and to permit third-parties to whom the Software is furnished to\n+// do so, all subject to the following:\n+//\n+// The copyright notices in the Software and this entire statement, including\n+// the above license grant, this restriction and the following disclaimer,\n+// must be included in all copies of the Software, in whole or in part, and\n+// all derivative works of the Software, unless such copies or derivative\n+// works are solely in the form of machine-executable object code generated by\n+// a source language processor.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\n+// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\n+// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n+// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+// DEALINGS IN THE SOFTWARE.\n+//\n+////////////////////////////////////////////////////////////////////////////////\n+\n+// HSA AMD extension.\n+\n+#ifndef HSA_RUNTIME_EXT_AMD_H_\n+#define HSA_RUNTIME_EXT_AMD_H_\n+\n+#include \"hsa.h\"\n+#include \"hsa_ext_image.h\"\n+\n+#define HSA_AMD_INTERFACE_VERSION_MAJOR 1\n+#define HSA_AMD_INTERFACE_VERSION_MINOR 0\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/**\n+ * @brief Enumeration constants added to ::hsa_status_t.\n+ *\n+ * @remark Additions to hsa_status_t\n+ */\n+enum {\n+  /**\n+   * The memory pool is invalid.\n+   */\n+  HSA_STATUS_ERROR_INVALID_MEMORY_POOL = 40,\n+\n+  /**\n+   * Agent accessed memory beyond the maximum legal address.\n+   */\n+  HSA_STATUS_ERROR_MEMORY_APERTURE_VIOLATION = 41,\n+\n+  /**\n+   * Agent executed an invalid shader instruction.\n+   */\n+  HSA_STATUS_ERROR_ILLEGAL_INSTRUCTION = 42,\n+};\n+\n+/**\n+ * @brief Agent attributes.\n+ */\n+typedef enum hsa_amd_agent_info_s {\n+  /**\n+   * Chip identifier. The type of this attribute is uint32_t.\n+   */\n+  HSA_AMD_AGENT_INFO_CHIP_ID = 0xA000,\n+  /**\n+   * Size of a cacheline in bytes. The type of this attribute is uint32_t.\n+   */\n+  HSA_AMD_AGENT_INFO_CACHELINE_SIZE = 0xA001,\n+  /**\n+   * The number of compute unit available in the agent. The type of this\n+   * attribute is uint32_t.\n+   */\n+  HSA_AMD_AGENT_INFO_COMPUTE_UNIT_COUNT = 0xA002,\n+  /**\n+   * The maximum clock frequency of the agent in MHz. The type of this\n+   * attribute is uint32_t.\n+   */\n+  HSA_AMD_AGENT_INFO_MAX_CLOCK_FREQUENCY = 0xA003,\n+  /**\n+   * Internal driver node identifier. The type of this attribute is uint32_t.\n+   */\n+  HSA_AMD_AGENT_INFO_DRIVER_NODE_ID = 0xA004,\n+  /**\n+   * Max number of watch points on memory address ranges to generate exception\n+   * events when the watched addresses are accessed.  The type of this\n+   * attribute is uint32_t.\n+   */\n+  HSA_AMD_AGENT_INFO_MAX_ADDRESS_WATCH_POINTS = 0xA005,\n+  /**\n+   * Agent BDF_ID, named LocationID in thunk. The type of this attribute is\n+   * uint32_t.\n+   */\n+  HSA_AMD_AGENT_INFO_BDFID = 0xA006,\n+  /**\n+   * Memory Interface width, the return value type is uint32_t.\n+   * This attribute is deprecated.\n+   */\n+  HSA_AMD_AGENT_INFO_MEMORY_WIDTH = 0xA007,\n+  /**\n+   * Max Memory Clock, the return value type is uint32_t.\n+   */\n+  HSA_AMD_AGENT_INFO_MEMORY_MAX_FREQUENCY = 0xA008,\n+  /**\n+   * Board name of Agent - populated from MarketingName of Kfd Node\n+   * The value is an Ascii string of 64 chars.\n+   */\n+  HSA_AMD_AGENT_INFO_PRODUCT_NAME = 0xA009,\n+  /**\n+   * Maximum number of waves possible in a Compute Unit.\n+   * The type of this attribute is uint32_t.\n+   */\n+  HSA_AMD_AGENT_INFO_MAX_WAVES_PER_CU = 0xA00A,\n+  /**\n+   * Number of SIMD's per compute unit CU\n+   * The type of this attribute is uint32_t.\n+   */\n+  HSA_AMD_AGENT_INFO_NUM_SIMDS_PER_CU = 0xA00B,\n+  /**\n+   * Number of Shader Engines (SE) in Gpu\n+   * The type of this attribute is uint32_t.\n+   */\n+  HSA_AMD_AGENT_INFO_NUM_SHADER_ENGINES = 0xA00C,\n+  /**\n+   * Number of Shader Arrays Per Shader Engines in Gpu\n+   * The type of this attribute is uint32_t.\n+   */\n+  HSA_AMD_AGENT_INFO_NUM_SHADER_ARRAYS_PER_SE = 0xA00D,\n+  /**\n+   * Address of the HDP flush registers.  Use of these registers does not conform to the HSA memory\n+   * model and should be treated with caution.\n+   * The type of this attribute is hsa_amd_hdp_flush_t.\n+   */\n+  HSA_AMD_AGENT_INFO_HDP_FLUSH = 0xA00E,\n+  /**\n+   * PCIe domain for the agent.  Pairs with HSA_AMD_AGENT_INFO_BDFID\n+   * to give the full physical location of the Agent.\n+   * The type of this attribute is uint32_t.\n+   */\n+  HSA_AMD_AGENT_INFO_DOMAIN = 0xA00F,\n+  /**\n+   * Queries for support of cooperative queues.  See ::HSA_QUEUE_TYPE_COOPERATIVE.\n+   * The type of this attribute is bool.\n+   */\n+  HSA_AMD_AGENT_INFO_COOPERATIVE_QUEUES = 0xA010,\n+  /**\n+   * Queries UUID of an agent. The value is an Ascii string with a maximum\n+   * of 21 chars including NUL. The string value consists of two parts: header\n+   * and body. The header identifies device type (GPU, CPU, DSP) while body\n+   * encodes UUID as a 16 digit hex string\n+   *\n+   * Agents that do not support UUID will return the string \"GPU-XX\" or\n+   * \"CPU-XX\" or \"DSP-XX\" depending upon their device type ::hsa_device_type_t\n+   */\n+  HSA_AMD_AGENT_INFO_UUID = 0xA011,\n+  /**\n+   * Queries for the ASIC revision of an agent. The value is an integer that\n+   * increments for each revision. This can be used by user-level software to\n+   * change how it operates, depending on the hardware version. This allows\n+   * selective workarounds for hardware errata.\n+   * The type of this attribute is uint32_t.\n+   */\n+  HSA_AMD_AGENT_INFO_ASIC_REVISION = 0xA012\n+} hsa_amd_agent_info_t;\n+\n+typedef struct hsa_amd_hdp_flush_s {\n+  uint32_t* HDP_MEM_FLUSH_CNTL;\n+  uint32_t* HDP_REG_FLUSH_CNTL;\n+} hsa_amd_hdp_flush_t;\n+\n+/**\n+ * @brief Region attributes.\n+ */\n+typedef enum hsa_amd_region_info_s {\n+  /**\n+   * Determine if host can access the region. The type of this attribute\n+   * is bool.\n+   */\n+  HSA_AMD_REGION_INFO_HOST_ACCESSIBLE = 0xA000,\n+  /**\n+   * Base address of the region in flat address space.\n+   */\n+  HSA_AMD_REGION_INFO_BASE = 0xA001,\n+  /**\n+   * Memory Interface width, the return value type is uint32_t.\n+   * This attribute is deprecated. Use HSA_AMD_AGENT_INFO_MEMORY_WIDTH.\n+   */\n+  HSA_AMD_REGION_INFO_BUS_WIDTH = 0xA002,\n+  /**\n+   * Max Memory Clock, the return value type is uint32_t.\n+   * This attribute is deprecated. Use HSA_AMD_AGENT_INFO_MEMORY_MAX_FREQUENCY.\n+   */\n+  HSA_AMD_REGION_INFO_MAX_CLOCK_FREQUENCY = 0xA003\n+} hsa_amd_region_info_t;\n+\n+/**\n+ * @brief Coherency attributes of fine grain region.\n+ */\n+typedef enum hsa_amd_coherency_type_s {\n+  /**\n+   * Coherent region.\n+   */\n+  HSA_AMD_COHERENCY_TYPE_COHERENT = 0,\n+  /**\n+   * Non coherent region.\n+   */\n+  HSA_AMD_COHERENCY_TYPE_NONCOHERENT = 1\n+} hsa_amd_coherency_type_t;\n+\n+/**\n+ * @brief Get the coherency type of the fine grain region of an agent.\n+ *\n+ * @param[in] agent A valid agent.\n+ *\n+ * @param[out] type Pointer to a memory location where the HSA runtime will\n+ * store the coherency type of the fine grain region.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p type is NULL.\n+ */\n+hsa_status_t HSA_API hsa_amd_coherency_get_type(hsa_agent_t agent,\n+                                                hsa_amd_coherency_type_t* type);\n+\n+/**\n+ * @brief Set the coherency type of the fine grain region of an agent.\n+ * Deprecated.  This is supported on KV platforms.  For backward compatibility\n+ * other platforms will spuriously succeed.\n+ *\n+ * @param[in] agent A valid agent.\n+ *\n+ * @param[in] type The coherency type to be set.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p type is invalid.\n+ */\n+hsa_status_t HSA_API hsa_amd_coherency_set_type(hsa_agent_t agent,\n+                                                hsa_amd_coherency_type_t type);\n+\n+/**\n+ * @brief Structure containing profiling dispatch time information.\n+ *\n+ * Times are reported as ticks in the domain of the HSA system clock.\n+ * The HSA system clock tick and frequency is obtained via hsa_system_get_info.\n+ */\n+typedef struct hsa_amd_profiling_dispatch_time_s {\n+  /**\n+   * Dispatch packet processing start time.\n+   */\n+  uint64_t start;\n+  /**\n+   * Dispatch packet completion time.\n+   */\n+  uint64_t end;\n+} hsa_amd_profiling_dispatch_time_t;\n+\n+/**\n+ * @brief Structure containing profiling async copy time information.\n+ *\n+ * Times are reported as ticks in the domain of the HSA system clock.\n+ * The HSA system clock tick and frequency is obtained via hsa_system_get_info.\n+ */\n+typedef struct hsa_amd_profiling_async_copy_time_s {\n+  /**\n+   * Async copy processing start time.\n+   */\n+  uint64_t start;\n+  /**\n+   * Async copy completion time.\n+   */\n+  uint64_t end;\n+} hsa_amd_profiling_async_copy_time_t;\n+\n+/**\n+ * @brief Enable or disable profiling capability of a queue.\n+ *\n+ * @param[in] queue A valid queue.\n+ *\n+ * @param[in] enable 1 to enable profiling. 0 to disable profiling.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_QUEUE The queue is invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p queue is NULL.\n+ */\n+hsa_status_t HSA_API\n+    hsa_amd_profiling_set_profiler_enabled(hsa_queue_t* queue, int enable);\n+\n+/**\n+ * @brief Enable or disable asynchronous memory copy profiling.\n+ *\n+ * @details The runtime will provide the copy processing start timestamp and\n+ * completion timestamp of each call to hsa_amd_memory_async_copy if the\n+ * async copy profiling is enabled prior to the call to\n+ * hsa_amd_memory_async_copy. The completion signal object is used to\n+ * hold the last async copy start and end timestamp. The client can retrieve\n+ * these timestamps via call to hsa_amd_profiling_get_async_copy_time.\n+ *\n+ * @param[in] enable True to enable profiling. False to disable profiling.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES Failed on allocating resources\n+ * needed to profile the asynchronous copy.\n+ */\n+hsa_status_t HSA_API\n+    hsa_amd_profiling_async_copy_enable(bool enable);\n+\n+/**\n+ * @brief Retrieve packet processing time stamps.\n+ *\n+ * @param[in] agent The agent with which the signal was last used.  For\n+ * instance, if the profiled dispatch packet is dispatched onto queue Q,\n+ * which was created on agent A, then this parameter must be A.\n+ *\n+ * @param[in] signal A signal used as the completion signal of the dispatch\n+ * packet to retrieve time stamps from.  This dispatch packet must have been\n+ * issued to a queue with profiling enabled and have already completed.  Also\n+ * the signal must not have yet been used in any other packet following the\n+ * completion of the profiled dispatch packet.\n+ *\n+ * @param[out] time Packet processing timestamps in the HSA system clock\n+ * domain.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_SIGNAL The signal is invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p time is NULL.\n+ */\n+hsa_status_t HSA_API hsa_amd_profiling_get_dispatch_time(\n+    hsa_agent_t agent, hsa_signal_t signal,\n+    hsa_amd_profiling_dispatch_time_t* time);\n+\n+/**\n+ * @brief Retrieve asynchronous copy timestamps.\n+ *\n+ * @details Async copy profiling is enabled via call to\n+ * hsa_amd_profiling_async_copy_enable.\n+ *\n+ * @param[in] signal A signal used as the completion signal of the call to\n+ * hsa_amd_memory_async_copy.\n+ *\n+ * @param[out] time Async copy processing timestamps in the HSA system clock\n+ * domain.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_SIGNAL The signal is invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p time is NULL.\n+ */\n+hsa_status_t HSA_API hsa_amd_profiling_get_async_copy_time(\n+    hsa_signal_t signal, hsa_amd_profiling_async_copy_time_t* time);\n+\n+/**\n+ * @brief Computes the frequency ratio and offset between the agent clock and\n+ * HSA system clock and converts the agent's tick to HSA system domain tick.\n+ *\n+ * @param[in] agent The agent used to retrieve the agent_tick. It is user's\n+ * responsibility to make sure the tick number is from this agent, otherwise,\n+ * the behavior is undefined.\n+ *\n+ * @param[in] agent_tick The tick count retrieved from the specified @p agent.\n+ *\n+ * @param[out] system_tick The translated HSA system domain clock counter tick.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p system_tick is NULL;\n+ */\n+hsa_status_t HSA_API\n+    hsa_amd_profiling_convert_tick_to_system_domain(hsa_agent_t agent,\n+                                                    uint64_t agent_tick,\n+                                                    uint64_t* system_tick);\n+\n+/**\n+ * @brief Signal attribute flags.\n+ */\n+typedef enum {\n+  /**\n+   * Signal will only be consumed by AMD GPUs.  Limits signal consumption to\n+   * AMD GPU agents only.  Ignored if @p num_consumers is not zero (all agents).\n+   */\n+  HSA_AMD_SIGNAL_AMD_GPU_ONLY = 1,\n+  /**\n+   * Signal may be used for interprocess communication.\n+   * IPC signals can be read, written, and waited on from any process.\n+   * Profiling using an IPC enabled signal is only supported in a single process\n+   * at a time.  Producing profiling data in one process and consuming it in\n+   * another process is undefined.\n+   */\n+  HSA_AMD_SIGNAL_IPC = 2,\n+} hsa_amd_signal_attribute_t;\n+\n+/**\n+ * @brief Create a signal with specific attributes.\n+ *\n+ * @param[in] initial_value Initial value of the signal.\n+ *\n+ * @param[in] num_consumers Size of @p consumers. A value of 0 indicates that\n+ * any agent might wait on the signal.\n+ *\n+ * @param[in] consumers List of agents that might consume (wait on) the\n+ * signal. If @p num_consumers is 0, this argument is ignored; otherwise, the\n+ * HSA runtime might use the list to optimize the handling of the signal\n+ * object. If an agent not listed in @p consumers waits on the returned\n+ * signal, the behavior is undefined. The memory associated with @p consumers\n+ * can be reused or freed after the function returns.\n+ *\n+ * @param[in] attributes Requested signal attributes.  Multiple signal attributes\n+ * may be requested by combining them with bitwise OR.  Requesting no attributes\n+ * (@p attributes == 0) results in the same signal as would have been obtained\n+ * via hsa_signal_create.\n+ *\n+ * @param[out] signal Pointer to a memory location where the HSA runtime will\n+ * store the newly created signal handle. Must not be NULL.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to allocate\n+ * the required resources.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p signal is NULL, @p\n+ * num_consumers is greater than 0 but @p consumers is NULL, or @p consumers\n+ * contains duplicates.\n+ */\n+hsa_status_t HSA_API hsa_amd_signal_create(hsa_signal_value_t initial_value, uint32_t num_consumers,\n+                                           const hsa_agent_t* consumers, uint64_t attributes,\n+                                           hsa_signal_t* signal);\n+\n+/**\n+ * @brief Asyncronous signal handler function type.\n+ *\n+ * @details Type definition of callback function to be used with\n+ * hsa_amd_signal_async_handler. This callback is invoked if the associated\n+ * signal and condition are met. The callback receives the value of the signal\n+ * which satisfied the associated wait condition and a user provided value. If\n+ * the callback returns true then the callback will be called again if the\n+ * associated signal and condition are satisfied again. If the callback returns\n+ * false then it will not be called again.\n+ *\n+ * @param[in] value Contains the value of the signal observed by\n+ * hsa_amd_signal_async_handler which caused the signal handler to be invoked.\n+ *\n+ * @param[in] arg Contains the user provided value given when the signal handler\n+ * was registered with hsa_amd_signal_async_handler\n+ *\n+ * @retval true resumes monitoring the signal with this handler (as if calling\n+ * hsa_amd_signal_async_handler again with identical parameters)\n+ *\n+ * @retval false stops monitoring the signal with this handler (handler will\n+ * not be called again for this signal)\n+ *\n+ */\n+typedef bool (*hsa_amd_signal_handler)(hsa_signal_value_t value, void* arg);\n+\n+/**\n+ * @brief Register asynchronous signal handler function.\n+ *\n+ * @details Allows registering a callback function and user provided value with\n+ * a signal and wait condition. The callback will be invoked if the associated\n+ * signal and wait condition are satisfied. Callbacks will be invoked serially\n+ * but in an arbitrary order so callbacks should be independent of each other.\n+ * After being invoked a callback may continue to wait for its associated signal\n+ * and condition and, possibly, be invoked again. Or the callback may stop\n+ * waiting. If the callback returns true then it will continue waiting and may\n+ * be called again. If false then the callback will not wait again and will not\n+ * be called again for the associated signal and condition. It is possible to\n+ * register the same callback multiple times with the same or different signals\n+ * and/or conditions. Each registration of the callback will be treated entirely\n+ * independently.\n+ *\n+ * @param[in] signal hsa signal to be asynchronously monitored\n+ *\n+ * @param[in] cond condition value to monitor for\n+ *\n+ * @param[in] value signal value used in condition expression\n+ *\n+ * @param[in] handler asynchronous signal handler invoked when signal's\n+ * condition is met\n+ *\n+ * @param[in] arg user provided value which is provided to handler when handler\n+ * is invoked\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_SIGNAL signal is not a valid hsa_signal_t\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT handler is invalid (NULL)\n+ *\n+ * @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime is out of\n+ * resources or blocking signals are not supported by the HSA driver component.\n+ *\n+ */\n+hsa_status_t HSA_API\n+    hsa_amd_signal_async_handler(hsa_signal_t signal,\n+                                 hsa_signal_condition_t cond,\n+                                 hsa_signal_value_t value,\n+                                 hsa_amd_signal_handler handler, void* arg);\n+\n+/**\n+ * @brief Call a function asynchronously\n+ *\n+ * @details Provides access to the runtime's asynchronous event handling thread\n+ * for general asynchronous functions.  Functions queued this way are executed\n+ * in the same manner as if they were a signal handler who's signal is\n+ * satisfied.\n+ *\n+ * @param[in] callback asynchronous function to be invoked\n+ *\n+ * @param[in] arg user provided value which is provided to handler when handler\n+ * is invoked\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT handler is invalid (NULL)\n+ *\n+ * @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime is out of\n+ * resources or blocking signals are not supported by the HSA driver component.\n+ *\n+ */\n+hsa_status_t HSA_API\n+    hsa_amd_async_function(void (*callback)(void* arg), void* arg);\n+\n+/**\n+ * @brief Wait for any signal-condition pair to be satisfied.\n+ *\n+ * @details Allows waiting for any of several signal and conditions pairs to be\n+ * satisfied. The function returns the index into the list of signals of the\n+ * first satisfying signal-condition pair. The value of the satisfying signal's\n+ * value is returned in satisfying_value unless satisfying_value is NULL. This\n+ * function provides only relaxed memory semantics.\n+ */\n+uint32_t HSA_API\n+    hsa_amd_signal_wait_any(uint32_t signal_count, hsa_signal_t* signals,\n+                            hsa_signal_condition_t* conds,\n+                            hsa_signal_value_t* values, uint64_t timeout_hint,\n+                            hsa_wait_state_t wait_hint,\n+                            hsa_signal_value_t* satisfying_value);\n+\n+/**\n+ * @brief Query image limits.\n+ *\n+ * @param[in] agent A valid agent.\n+ *\n+ * @param[in] attribute HSA image info attribute to query.\n+ *\n+ * @param[out] value Pointer to an application-allocated buffer where to store\n+ * the value of the attribute. If the buffer passed by the application is not\n+ * large enough to hold the value of @p attribute, the behavior is undefined.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_QUEUE @p value is NULL or @p attribute <\n+ * HSA_EXT_AGENT_INFO_IMAGE_1D_MAX_ELEMENTS or @p attribute >\n+ * HSA_EXT_AGENT_INFO_IMAGE_ARRAY_MAX_LAYERS.\n+ *\n+ */\n+hsa_status_t HSA_API hsa_amd_image_get_info_max_dim(hsa_agent_t agent,\n+                                                    hsa_agent_info_t attribute,\n+                                                    void* value);\n+\n+/**\n+ * @brief Set a CU affinity to specific queues within the process, this function\n+ * call is \"atomic\".\n+ *\n+ * @param[in] queue A pointer to HSA queue.\n+ *\n+ * @param[in] num_cu_mask_count Size of CUMask bit array passed in.\n+ *\n+ * @param[in] cu_mask Bit-vector representing the CU mask.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_QUEUE @p queue is NULL or invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p num_cu_mask_count is not\n+ * multiple of 32 or @p cu_mask is NULL.\n+ *\n+ * @retval ::HSA_STATUS_ERROR failed to call thunk api\n+ *\n+ */\n+hsa_status_t HSA_API hsa_amd_queue_cu_set_mask(const hsa_queue_t* queue,\n+                                               uint32_t num_cu_mask_count,\n+                                               const uint32_t* cu_mask);\n+\n+/**\n+ * @brief Memory segments associated with a memory pool.\n+ */\n+typedef enum {\n+  /**\n+   * Global segment. Used to hold data that is shared by all agents.\n+   */\n+  HSA_AMD_SEGMENT_GLOBAL = 0,\n+  /**\n+   * Read-only segment. Used to hold data that remains constant during the\n+   * execution of a kernel.\n+   */\n+  HSA_AMD_SEGMENT_READONLY = 1,\n+  /**\n+   * Private segment. Used to hold data that is local to a single work-item.\n+   */\n+  HSA_AMD_SEGMENT_PRIVATE = 2,\n+  /**\n+   * Group segment. Used to hold data that is shared by the work-items of a\n+   * work-group.\n+   */\n+  HSA_AMD_SEGMENT_GROUP = 3,\n+} hsa_amd_segment_t;\n+\n+/**\n+ * @brief A memory pool encapsulates physical storage on an agent\n+ * along with a memory access model.\n+ *\n+ * @details A memory pool encapsulates a physical partition of an agent's\n+ * memory system along with a memory access model.  Division of a single\n+ * memory system into separate pools allows querying each partition's access\n+ * path properties (see ::hsa_amd_agent_memory_pool_get_info). Allocations\n+ * from a pool are preferentially bound to that pool's physical partition.\n+ * Binding to the pool's preferential physical partition may not be\n+ * possible or persistent depending on the system's memory policy\n+ * and/or state which is beyond the scope of HSA APIs.\n+ *\n+ * For example, a multi-node NUMA memory system may be represented by multiple\n+ * pool's with each pool providing size and access path information for the\n+ * partition it represents.  Allocations from a pool are preferentially bound\n+ * to the pool's partition (which in this example is a NUMA node) while\n+ * following its memory access model. The actual placement may vary or migrate\n+ * due to the system's NUMA policy and state, which is beyond the scope of\n+ * HSA APIs.\n+ */ \n+typedef struct hsa_amd_memory_pool_s {\n+  /**\n+   * Opaque handle.\n+   */\n+  uint64_t handle;\n+} hsa_amd_memory_pool_t;\n+\n+typedef enum hsa_amd_memory_pool_global_flag_s {\n+  /**\n+   * The application can use allocations in the memory pool to store kernel\n+   * arguments, and provide the values for the kernarg segment of\n+   * a kernel dispatch.\n+   */\n+  HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT = 1,\n+  /**\n+   * Updates to memory in this pool conform to HSA memory consistency model.\n+   * If this flag is set, then ::HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_COARSE_GRAINED\n+   * must not be set.\n+   */\n+  HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_FINE_GRAINED = 2,\n+  /**\n+   * Writes to memory in this pool can be performed by a single agent at a time.\n+   */\n+  HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_COARSE_GRAINED = 4\n+} hsa_amd_memory_pool_global_flag_t;\n+\n+/**\n+ * @brief Memory pool features.\n+ */\n+typedef enum {\n+  /**\n+  * Segment where the memory pool resides. The type of this attribute is\n+  * ::hsa_amd_segment_t.\n+  */\n+  HSA_AMD_MEMORY_POOL_INFO_SEGMENT = 0,\n+  /**\n+  * Flag mask. The value of this attribute is undefined if the value of\n+  * ::HSA_AMD_MEMORY_POOL_INFO_SEGMENT is not ::HSA_AMD_SEGMENT_GLOBAL. The type\n+  * of\n+  * this attribute is uint32_t, a bit-field of\n+  * ::hsa_amd_memory_pool_global_flag_t\n+  * values.\n+  */\n+  HSA_AMD_MEMORY_POOL_INFO_GLOBAL_FLAGS = 1,\n+  /**\n+  * Size of this pool, in bytes. The type of this attribute is size_t.\n+  */\n+  HSA_AMD_MEMORY_POOL_INFO_SIZE = 2,\n+  /**\n+  * Indicates whether memory in this pool can be allocated using\n+  * ::hsa_amd_memory_pool_allocate. The type of this attribute is bool.\n+  *\n+  * The value of this flag is always false for memory pools in the group and\n+  * private segments.\n+  */\n+  HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_ALLOWED = 5,\n+  /**\n+  * Allocation granularity of buffers allocated by\n+  * ::hsa_amd_memory_pool_allocate\n+  * in this memory pool. The size of a buffer allocated in this pool is a\n+  * multiple of the value of this attribute. The value of this attribute is\n+  * only defined if ::HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_ALLOWED is true for\n+  * this pool. The type of this attribute is size_t.\n+  */\n+  HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_GRANULE = 6,\n+  /**\n+  * Alignment of buffers allocated by ::hsa_amd_memory_pool_allocate in this\n+  * pool. The value of this attribute is only defined if\n+  * ::HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_ALLOWED is true for this pool, and\n+  * must be a power of 2. The type of this attribute is size_t.\n+  */\n+  HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_ALIGNMENT = 7,\n+  /**\n+  * This memory_pool can be made directly accessible by all the agents in the\n+  * system (::hsa_amd_agent_memory_pool_get_info does not return \n+  * ::HSA_AMD_MEMORY_POOL_ACCESS_NEVER_ALLOWED for any agent). The type of this\n+  * attribute is bool.\n+  */\n+  HSA_AMD_MEMORY_POOL_INFO_ACCESSIBLE_BY_ALL = 15,\n+  /**\n+  * Maximum aggregate allocation size in bytes. The type of this attribute\n+  * is size_t.\n+  */\n+  HSA_AMD_MEMORY_POOL_INFO_ALLOC_MAX_SIZE = 16,\n+} hsa_amd_memory_pool_info_t;\n+\n+/**\n+ * @brief Get the current value of an attribute of a memory pool.\n+ *\n+ * @param[in] memory_pool A valid memory pool.\n+ *\n+ * @param[in] attribute Attribute to query.\n+ *\n+ * @param[out] value Pointer to a application-allocated buffer where to store\n+ * the value of the attribute. If the buffer passed by the application is not\n+ * large enough to hold the value of @p attribute, the behavior is undefined.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ */\n+hsa_status_t HSA_API\n+    hsa_amd_memory_pool_get_info(hsa_amd_memory_pool_t memory_pool,\n+                                 hsa_amd_memory_pool_info_t attribute,\n+                                 void* value);\n+\n+/**\n+ * @brief Iterate over the memory pools associated with a given agent, and\n+ * invoke an application-defined callback on every iteration.\n+ *\n+ * @details An agent can directly access buffers located in some memory pool, or\n+ * be enabled to access them by the application (see ::hsa_amd_agents_allow_access),\n+ * yet that memory pool may not be returned by this function for that given\n+ * agent.\n+ *\n+ * A memory pool of fine-grained type must be associated only with the host.\n+ *\n+ * @param[in] agent A valid agent.\n+ *\n+ * @param[in] callback Callback to be invoked on the same thread that called\n+ * ::hsa_amd_agent_iterate_memory_pools, serially, once per memory pool that is\n+ * associated with the agent.  The HSA runtime passes two arguments to the\n+ * callback: the memory pool, and the application data.  If @p callback\n+ * returns a status other than ::HSA_STATUS_SUCCESS for a particular iteration,\n+ * the traversal stops and ::hsa_amd_agent_iterate_memory_pools returns that status\n+ * value.\n+ *\n+ * @param[in] data Application data that is passed to @p callback on every\n+ * iteration. May be NULL.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p callback is NULL.\n+ */\n+hsa_status_t HSA_API hsa_amd_agent_iterate_memory_pools(\n+    hsa_agent_t agent,\n+    hsa_status_t (*callback)(hsa_amd_memory_pool_t memory_pool, void* data),\n+    void* data);\n+\n+/**\n+ * @brief Allocate a block of memory (or buffer) in the specified pool.\n+ *\n+ * @param[in] memory_pool Memory pool where to allocate memory from. The memory\n+ * pool must have the ::HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_ALLOWED flag set.\n+ *\n+ * @param[in] size Allocation size, in bytes. Must not be zero. This value is\n+ * rounded up to the nearest multiple of\n+ * ::HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_GRANULE in @p memory_pool.\n+ *\n+ * @param[in] flags A bit-field that is used to specify allocation\n+ * directives. Reserved parameter, must be 0.\n+ *\n+ * @param[out] ptr Pointer to the location where to store the base virtual\n+ * address of\n+ * the allocated block. The returned base address is aligned to the value of\n+ * ::HSA_AMD_MEMORY_POOL_INFO_RUNTIME_ALLOC_ALIGNMENT in @p memory_pool. If the\n+ * allocation fails, the returned value is undefined.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES No memory is available.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_MEMORY_POOL The memory pool is invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ALLOCATION The host is not allowed to\n+ * allocate memory in @p memory_pool, or @p size is greater than\n+ * the value of HSA_AMD_MEMORY_POOL_INFO_ALLOC_MAX_SIZE in @p memory_pool.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p ptr is NULL, or @p size is 0,\n+ * or flags is not 0.\n+ *\n+ */\n+hsa_status_t HSA_API\n+    hsa_amd_memory_pool_allocate(hsa_amd_memory_pool_t memory_pool, size_t size,\n+                                 uint32_t flags, void** ptr);\n+\n+/**\n+ * @brief Deallocate a block of memory previously allocated using\n+ * ::hsa_amd_memory_pool_allocate.\n+ *\n+ * @param[in] ptr Pointer to a memory block. If @p ptr does not match a value\n+ * previously returned by ::hsa_amd_memory_pool_allocate, the behavior is undefined.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ */\n+hsa_status_t HSA_API hsa_amd_memory_pool_free(void* ptr);\n+\n+/**\n+ * @brief Asynchronously copy a block of memory from the location pointed to by\n+ * @p src on the @p src_agent to the memory block pointed to by @p dst on the @p\n+ * dst_agent.\n+ * Because the DMA engines used may not be in the same coherency domain, the caller must ensure\n+ * that buffers are system-level coherent. In general this requires the sending device to have\n+ * released the buffer to system scope prior to executing the copy API and the receiving device\n+ * must execute a system scope acquire fence prior to use of the destination buffer.\n+ *\n+ * @param[out] dst Buffer where the content is to be copied.\n+ *\n+ * @param[in] dst_agent Agent associated with the @p dst. The agent must be able to directly\n+ * access both the source and destination buffers in their current locations.\n+ *\n+ * @param[in] src A valid pointer to the source of data to be copied. The source\n+ * buffer must not overlap with the destination buffer, otherwise the copy will succeed\n+ * but contents of @p dst is undefined.\n+ *\n+ * @param[in] src_agent Agent associated with the @p src. The agent must be able to directly\n+ * access both the source and destination buffers in their current locations.\n+ *\n+ * @param[in] size Number of bytes to copy. If @p size is 0, no copy is\n+ * performed and the function returns success. Copying a number of bytes larger\n+ * than the size of the buffers pointed by @p dst or @p src results in undefined\n+ * behavior.\n+ *\n+ * @param[in] num_dep_signals Number of dependent signals. Can be 0.\n+ *\n+ * @param[in] dep_signals List of signals that must be waited on before the copy\n+ * operation starts. The copy will start after every signal has been observed with\n+ * the value 0. The dependent signal should not include completion signal from hsa_amd_memory_async_copy\n+ * operation to be issued in future as that can result in a deadlock. If @p num_dep_signals is 0, this\n+ * argument is ignored.\n+ *\n+ * @param[in] completion_signal Signal used to indicate completion of the copy\n+ * operation. When the copy operation is finished, the value of the signal is\n+ * decremented. The runtime indicates that an error has occurred during the copy\n+ * operation by setting the value of the completion signal to a negative\n+ * number. The signal handle must not be 0.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully. The\n+ * application is responsible for checking for asynchronous error conditions\n+ * (see the description of @p completion_signal).\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_SIGNAL @p completion_signal is invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT The source or destination\n+ * pointers are NULL, or the completion signal is 0.\n+ */\n+hsa_status_t HSA_API\n+    hsa_amd_memory_async_copy(void* dst, hsa_agent_t dst_agent, const void* src,\n+                              hsa_agent_t src_agent, size_t size,\n+                              uint32_t num_dep_signals,\n+                              const hsa_signal_t* dep_signals,\n+                              hsa_signal_t completion_signal);\n+\n+/*\n+[Provisional API]\n+Pitched memory descriptor.\n+All elements must be 4 byte aligned.  Pitch and slice are in bytes.\n+*/\n+typedef struct hsa_pitched_ptr_s {\n+  void* base;\n+  size_t pitch;\n+  size_t slice;\n+} hsa_pitched_ptr_t;\n+\n+/*\n+[Provisional API]\n+Copy direction flag.\n+*/\n+typedef enum {\n+  hsaHostToHost = 0,\n+  hsaHostToDevice = 1,\n+  hsaDeviceToHost = 2,\n+  hsaDeviceToDevice = 3\n+} hsa_amd_copy_direction_t;\n+\n+/*\n+[Provisional API]\n+SDMA 3D memory copy API.  The same requirements must be met by src and dst as in\n+hsa_amd_memory_async_copy.\n+Both src and dst must be directly accessible to the copy_agent during the copy, src and dst rects\n+must not overlap.\n+CPU agents are not supported.  API requires SDMA and will return an error if SDMA is not available.\n+Offsets and range carry x in bytes, y and z in rows and layers.\n+*/\n+hsa_status_t HSA_API hsa_amd_memory_async_copy_rect(\n+    const hsa_pitched_ptr_t* dst, const hsa_dim3_t* dst_offset, const hsa_pitched_ptr_t* src,\n+    const hsa_dim3_t* src_offset, const hsa_dim3_t* range, hsa_agent_t copy_agent,\n+    hsa_amd_copy_direction_t dir, uint32_t num_dep_signals, const hsa_signal_t* dep_signals,\n+    hsa_signal_t completion_signal);\n+\n+/**\n+ * @brief Type of accesses to a memory pool from a given agent.\n+ */\n+typedef enum {\n+  /**\n+  * The agent cannot directly access any buffer in the memory pool.\n+  */\n+  HSA_AMD_MEMORY_POOL_ACCESS_NEVER_ALLOWED = 0,\n+  /**\n+  * The agent can directly access a buffer located in the pool; the application\n+  * does not need to invoke ::hsa_amd_agents_allow_access.\n+  */\n+  HSA_AMD_MEMORY_POOL_ACCESS_ALLOWED_BY_DEFAULT = 1,\n+  /**\n+  * The agent can directly access a buffer located in the pool, but only if the\n+  * application has previously requested access to that buffer using\n+  * ::hsa_amd_agents_allow_access.\n+  */\n+  HSA_AMD_MEMORY_POOL_ACCESS_DISALLOWED_BY_DEFAULT = 2\n+} hsa_amd_memory_pool_access_t;\n+\n+/**\n+ * @brief Properties of the relationship between an agent a memory pool.\n+ */\n+typedef enum {\n+  /**\n+  * Hyper-transport bus type.\n+  */\n+  HSA_AMD_LINK_INFO_TYPE_HYPERTRANSPORT = 0,\n+\n+  /**\n+  * QPI bus type.\n+  */\n+  HSA_AMD_LINK_INFO_TYPE_QPI = 1,\n+\n+  /**\n+  * PCIe bus type.\n+  */\n+  HSA_AMD_LINK_INFO_TYPE_PCIE = 2,\n+\n+  /**\n+  * Infiniband bus type.\n+  */\n+  HSA_AMD_LINK_INFO_TYPE_INFINBAND = 3,\n+\n+  /**\n+  * xGMI link type.\n+  */\n+  HSA_AMD_LINK_INFO_TYPE_XGMI = 4\n+\n+} hsa_amd_link_info_type_t;\n+\n+/**\n+ * @brief Link properties when accessing the memory pool from the specified\n+ * agent.\n+ */\n+typedef struct hsa_amd_memory_pool_link_info_s {\n+  /**\n+  * Minimum transfer latency (rounded to ns).\n+  */\n+  uint32_t min_latency;\n+\n+  /**\n+  * Maximum transfer latency (rounded to ns).\n+  */\n+  uint32_t max_latency;\n+\n+  /**\n+  * Minimum link interface bandwidth in MB/s.\n+  */\n+  uint32_t min_bandwidth;\n+\n+  /**\n+  * Maximum link interface bandwidth in MB/s.\n+  */\n+  uint32_t max_bandwidth;\n+\n+  /**\n+  * Support for 32-bit atomic transactions.\n+  */\n+  bool atomic_support_32bit;\n+\n+  /**\n+  * Support for 64-bit atomic transactions.\n+  */\n+  bool atomic_support_64bit;\n+\n+  /**\n+  * Support for cache coherent transactions.\n+  */\n+  bool coherent_support;\n+\n+  /**\n+  * The type of bus/link.\n+  */\n+  hsa_amd_link_info_type_t link_type;\n+\n+  /**\n+   * NUMA distance of memory pool relative to querying agent\n+   */\n+  uint32_t numa_distance;\n+} hsa_amd_memory_pool_link_info_t;\n+\n+/**\n+ * @brief Properties of the relationship between an agent a memory pool.\n+ */\n+typedef enum {\n+  /**\n+  * Access to buffers located in the memory pool. The type of this attribute\n+  * is ::hsa_amd_memory_pool_access_t.\n+  *\n+  * An agent can always directly access buffers currently located in a memory\n+  * pool that is associated (the memory_pool is one of the values returned by\n+  * ::hsa_amd_agent_iterate_memory_pools on the agent) with that agent. If the\n+  * buffer is currently located in a memory pool that is not associated with\n+  * the agent, and the value returned by this function for the given\n+  * combination of agent and memory pool is not\n+  * HSA_AMD_MEMORY_POOL_ACCESS_NEVER_ALLOWED, the application still needs to invoke\n+  * ::hsa_amd_agents_allow_access in order to gain direct access to the buffer.\n+  *\n+  * If the given agent can directly access buffers the pool, the result is not\n+  * HSA_AMD_MEMORY_POOL_ACCESS_NEVER_ALLOWED. If the memory pool is associated with\n+  * the agent, or it is of fined-grained type, the result must not be\n+  * HSA_AMD_MEMORY_POOL_ACCESS_NEVER_ALLOWED. If the memory pool is not associated\n+  * with the agent, and does not reside in the global segment, the result must\n+  * be HSA_AMD_MEMORY_POOL_ACCESS_NEVER_ALLOWED.\n+  */\n+  HSA_AMD_AGENT_MEMORY_POOL_INFO_ACCESS = 0,\n+\n+  /**\n+  * Number of links to hop when accessing the memory pool from the specified\n+  * agent. The value of this attribute is zero if the memory pool is associated\n+  * with the agent, or if the access type is\n+  * HSA_AMD_MEMORY_POOL_ACCESS_NEVER_ALLOWED. The type of this attribute is\n+  * uint32_t.\n+  */\n+  HSA_AMD_AGENT_MEMORY_POOL_INFO_NUM_LINK_HOPS = 1,\n+\n+  /**\n+  * Details of each link hop when accessing the memory pool starting from the\n+  * specified agent. The type of this attribute is an array size of\n+  * HSA_AMD_AGENT_MEMORY_POOL_INFO_NUM_LINK_HOPS with each element containing\n+  * ::hsa_amd_memory_pool_link_info_t.\n+  */\n+  HSA_AMD_AGENT_MEMORY_POOL_INFO_LINK_INFO = 2\n+\n+} hsa_amd_agent_memory_pool_info_t;\n+\n+/**\n+ * @brief Get the current value of an attribute of the relationship between an\n+ * agent and a memory pool.\n+ *\n+ * @param[in] agent Agent.\n+ *\n+ * @param[in] memory_pool Memory pool.\n+ *\n+ * @param[in] attribute Attribute to query.\n+ *\n+ * @param[out] value Pointer to a application-allocated buffer where to store\n+ * the value of the attribute. If the buffer passed by the application is not\n+ * large enough to hold the value of @p attribute, the behavior is undefined.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ */\n+hsa_status_t HSA_API hsa_amd_agent_memory_pool_get_info(\n+    hsa_agent_t agent, hsa_amd_memory_pool_t memory_pool,\n+    hsa_amd_agent_memory_pool_info_t attribute, void* value);\n+\n+/**\n+ * @brief Enable direct access to a buffer from a given set of agents.\n+ *\n+ * @details\n+ *\n+ * Upon return, only the listed agents and the agent associated with the\n+ * buffer's memory pool have direct access to the @p ptr.\n+ *\n+ * Any agent that has access to the buffer before and after the call to\n+ * ::hsa_amd_agents_allow_access will also have access while\n+ * ::hsa_amd_agents_allow_access is in progress.\n+ *\n+ * The caller is responsible for ensuring that each agent in the list\n+ * must be able to access the memory pool containing @p ptr\n+ * (using ::hsa_amd_agent_memory_pool_get_info with ::HSA_AMD_AGENT_MEMORY_POOL_INFO_ACCESS attribute),\n+ * otherwise error code is returned.\n+ *\n+ * @param[in] num_agents Size of @p agents.\n+ *\n+ * @param[in] agents List of agents. If @p num_agents is 0, this argument is\n+ * ignored.\n+ *\n+ * @param[in] flags A list of bit-field that is used to specify access\n+ * information in a per-agent basis. This is currently reserved and must be NULL.\n+ *\n+ * @param[in] ptr A buffer previously allocated using ::hsa_amd_memory_pool_allocate.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p num_agents is 0, or @p agents\n+ * is NULL, @p flags is not NULL, or attempting to enable access to agent(s)\n+ * because @p ptr is allocated from an inaccessible pool.\n+ *\n+ */\n+hsa_status_t HSA_API\n+    hsa_amd_agents_allow_access(uint32_t num_agents, const hsa_agent_t* agents,\n+                                const uint32_t* flags, const void* ptr);\n+\n+/**\n+ * @brief Query if buffers currently located in some memory pool can be\n+ * relocated to a destination memory pool.\n+ *\n+ * @details If the returned value is non-zero, a migration of a buffer to @p\n+ * dst_memory_pool using ::hsa_amd_memory_migrate may nevertheless fail due to\n+ * resource limitations.\n+ *\n+ * @param[in] src_memory_pool Source memory pool.\n+ *\n+ * @param[in] dst_memory_pool Destination memory pool.\n+ *\n+ * @param[out] result Pointer to a memory location where the result of the query\n+ * is stored. Must not be NULL. If buffers currently located in @p\n+ * src_memory_pool can be relocated to @p dst_memory_pool, the result is\n+ * true.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_MEMORY_POOL One of the memory pools is\n+ * invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p result is NULL.\n+ */\n+hsa_status_t HSA_API\n+    hsa_amd_memory_pool_can_migrate(hsa_amd_memory_pool_t src_memory_pool,\n+                                    hsa_amd_memory_pool_t dst_memory_pool,\n+                                    bool* result);\n+\n+/**\n+ * @brief Relocate a buffer to a new memory pool.\n+ *\n+ * @details When a buffer is migrated, its virtual address remains the same but\n+ * its physical contents are moved to the indicated memory pool.\n+ *\n+ * After migration, only the agent associated with the destination pool will have access.\n+ *\n+ * The caller is also responsible for ensuring that the allocation in the\n+ * source memory pool where the buffer is currently located can be migrated to the\n+ * specified destination memory pool (using ::hsa_amd_memory_pool_can_migrate returns a value of true\n+ * for the source and destination memory pools), otherwise behavior is undefined.\n+ *\n+ * The caller must ensure that the buffer is not accessed while it is migrated.\n+ *\n+ * @param[in] ptr Buffer to be relocated. The buffer must have been released to system\n+ * prior to call this API.  The buffer will be released to system upon completion.\n+ *\n+ * @param[in] memory_pool Memory pool where to place the buffer.\n+ *\n+ * @param[in] flags A bit-field that is used to specify migration\n+ * information. Must be zero.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_MEMORY_POOL The destination memory pool is\n+ * invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES There is a failure in\n+ * allocating the necessary resources.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p flags is not 0.\n+ */\n+hsa_status_t HSA_API hsa_amd_memory_migrate(const void* ptr,\n+                                            hsa_amd_memory_pool_t memory_pool,\n+                                            uint32_t flags);\n+\n+/**\n+ *\n+ * @brief Pin a host pointer allocated by C/C++ or OS allocator (i.e. ordinary system DRAM) and\n+ * return a new pointer accessible by the @p agents. If the @p host_ptr overlaps with previously\n+ * locked memory, then the overlap area is kept locked (i.e multiple mappings are permitted). In\n+ * this case, the same input @p host_ptr may give different locked @p agent_ptr and when it does,\n+ * they are not necessarily coherent (i.e. accessing either @p agent_ptr is not equivalent).\n+ * Accesses to @p agent_ptr are coarse grained.\n+ *\n+ * @param[in] host_ptr A buffer allocated by C/C++ or OS allocator.\n+ *\n+ * @param[in] size The size to be locked.\n+ *\n+ * @param[in] agents Array of agent handle to gain access to the @p host_ptr.\n+ * If this parameter is NULL and the @p num_agent is 0, all agents\n+ * in the platform will gain access to the @p host_ptr.\n+ *\n+ * @param[out] agent_ptr Pointer to the location where to store the new address.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES There is a failure in\n+ * allocating the necessary resources.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT One or more agent in @p agents is\n+ * invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p size is 0 or @p host_ptr or\n+ * @p agent_ptr is NULL or @p agents not NULL but @p num_agent is 0 or @p agents\n+ * is NULL but @p num_agent is not 0.\n+ */\n+hsa_status_t HSA_API hsa_amd_memory_lock(void* host_ptr, size_t size,\n+                                         hsa_agent_t* agents, int num_agent,\n+                                         void** agent_ptr);\n+\n+/**\n+ *\n+ * @brief Pin a host pointer allocated by C/C++ or OS allocator (i.e. ordinary system DRAM) and\n+ * return a new pointer accessible by the @p agents. If the @p host_ptr overlaps with previously\n+ * locked memory, then the overlap area is kept locked (i.e. multiple mappings are permitted).\n+ * In this case, the same input @p host_ptr may give different locked @p agent_ptr and when it\n+ * does, they are not necessarily coherent (i.e. accessing either @p agent_ptr is not equivalent).\n+ * Acesses to the memory via @p agent_ptr have the same access properties as memory allocated from\n+ * @p pool as determined by ::hsa_amd_memory_pool_get_info and ::hsa_amd_agent_memory_pool_get_info\n+ * (ex. coarse/fine grain, platform atomic support, link info).  Physical composition and placement\n+ * of the memory (ex. page size, NUMA binding) is not changed.\n+ *\n+ * @param[in] host_ptr A buffer allocated by C/C++ or OS allocator.\n+ *\n+ * @param[in] size The size to be locked.\n+ *\n+ * @param[in] agents Array of agent handle to gain access to the @p host_ptr.\n+ * If this parameter is NULL and the @p num_agent is 0, all agents\n+ * in the platform will gain access to the @p host_ptr.\n+ *\n+ * @param[in] pool Global memory pool owned by a CPU agent.\n+ *\n+ * @param[in] flags A bit-field that is used to specify allocation\n+ * directives. Reserved parameter, must be 0.\n+ *\n+ * @param[out] agent_ptr Pointer to the location where to store the new address.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES There is a failure in\n+ * allocating the necessary resources.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT One or more agent in @p agents is\n+ * invalid or can not access @p pool.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_MEMORY_POOL @p pool is invalid or not owned\n+ * by a CPU agent.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p size is 0 or @p host_ptr or\n+ * @p agent_ptr is NULL or @p agents not NULL but @p num_agent is 0 or @p agents\n+ * is NULL but @p num_agent is not 0 or flags is not 0.\n+ */\n+hsa_status_t HSA_API hsa_amd_memory_lock_to_pool(void* host_ptr, size_t size, hsa_agent_t* agents,\n+                                                 int num_agent, hsa_amd_memory_pool_t pool,\n+                                                 uint32_t flags, void** agent_ptr);\n+\n+/**\n+ *\n+ * @brief Unpin the host pointer previously pinned via ::hsa_amd_memory_lock or\n+ * ::hsa_amd_memory_lock_to_pool.\n+ *\n+ * @details The behavior is undefined if the host pointer being unpinned does not\n+ * match previous pinned address or if the host pointer was already deallocated.\n+ *\n+ * @param[in] host_ptr A buffer allocated by C/C++ or OS allocator that was\n+ * pinned previously via ::hsa_amd_memory_lock or ::hsa_amd_memory_lock_to_pool.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ */\n+hsa_status_t HSA_API hsa_amd_memory_unlock(void* host_ptr);\n+\n+/**\n+ * @brief Sets the first @p count of uint32_t of the block of memory pointed by\n+ * @p ptr to the specified @p value.\n+ *\n+ * @param[in] ptr Pointer to the block of memory to fill.\n+ *\n+ * @param[in] value Value to be set.\n+ *\n+ * @param[in] count Number of uint32_t element to be set to the value.\n+ *\n+ * @retval HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval HSA_STATUS_ERROR_INVALID_ARGUMENT @p ptr is NULL or\n+ * not 4 bytes aligned\n+ *\n+ * @retval HSA_STATUS_ERROR_INVALID_ALLOCATION if the given memory\n+ * region was not allocated with HSA runtime APIs.\n+ *\n+ */\n+hsa_status_t HSA_API\n+    hsa_amd_memory_fill(void* ptr, uint32_t value, size_t count);\n+\n+/**\n+ * @brief Maps an interop object into the HSA flat address space and establishes\n+ * memory residency.  The metadata pointer is valid during the lifetime of the\n+ * map (until hsa_amd_interop_unmap_buffer is called).\n+ * Multiple calls to hsa_amd_interop_map_buffer with the same interop_handle\n+ * result in multiple mappings with potentially different addresses and\n+ * different metadata pointers.  Concurrent operations on these addresses are\n+ * not coherent.  Memory must be fenced to system scope to ensure consistency,\n+ * between mappings and with any views of this buffer in the originating\n+ * software stack.\n+ *\n+ * @param[in] num_agents Number of agents which require access to the memory\n+ *\n+ * @param[in] agents List of accessing agents.\n+ *\n+ * @param[in] interop_handle Handle of interop buffer (dmabuf handle in Linux)\n+ *\n+ * @param [in] flags Reserved, must be 0\n+ *\n+ * @param[out] size Size in bytes of the mapped object\n+ *\n+ * @param[out] ptr Base address of the mapped object\n+ *\n+ * @param[out] metadata_size Size of metadata in bytes, may be NULL\n+ *\n+ * @param[out] metadata Pointer to metadata, may be NULL\n+ *\n+ * @retval HSA_STATUS_SUCCESS if successfully mapped\n+ *\n+ * @retval HSA_STATUS_ERROR_NOT_INITIALIZED if HSA is not initialized\n+ *\n+ * @retval HSA_STATUS_ERROR_OUT_OF_RESOURCES if there is a failure in allocating\n+ * necessary resources\n+ *\n+ * @retval HSA_STATUS_ERROR_INVALID_ARGUMENT all other errors\n+ */\n+hsa_status_t HSA_API hsa_amd_interop_map_buffer(uint32_t num_agents,\n+                                        hsa_agent_t* agents,\n+                                        int interop_handle,\n+                                        uint32_t flags,\n+                                        size_t* size,\n+                                        void** ptr,\n+                                        size_t* metadata_size,\n+                                        const void** metadata);\n+\n+/**\n+ * @brief Removes a previously mapped interop object from HSA's flat address space.\n+ * Ends lifetime for the mapping's associated metadata pointer.\n+ */\n+hsa_status_t HSA_API hsa_amd_interop_unmap_buffer(void* ptr);\n+\n+/**\n+ * @brief Encodes an opaque vendor specific image format.  The length of data\n+ * depends on the underlying format.  This structure must not be copied as its\n+ * true length can not be determined.\n+ */\n+typedef struct hsa_amd_image_descriptor_s {\n+  /*\n+  Version number of the descriptor\n+  */\n+  uint32_t version;\n+\n+  /*\n+  Vendor and device PCI IDs for the format as VENDOR_ID<<16|DEVICE_ID.\n+  */\n+  uint32_t deviceID;\n+\n+  /*\n+  Start of vendor specific data.\n+  */\n+  uint32_t data[1];\n+} hsa_amd_image_descriptor_t;\n+\n+/**\n+ * @brief Creates an image from an opaque vendor specific image format.\n+ * Does not modify data at image_data.  Intended initially for\n+ * accessing interop images.\n+ *\n+ * @param agent[in] Agent on which to create the image\n+ *\n+ * @param[in] image_descriptor[in] Vendor specific image format\n+ *\n+ * @param[in] image_data Pointer to image backing store\n+ *\n+ * @param[in] access_permission Access permissions for the image object\n+ *\n+ * @param[out] image Created image object.\n+ *\n+ * @retval HSA_STATUS_SUCCESS Image created successfully\n+ *\n+ * @retval HSA_STATUS_ERROR_NOT_INITIALIZED if HSA is not initialized\n+ *\n+ * @retval HSA_STATUS_ERROR_OUT_OF_RESOURCES if there is a failure in allocating\n+ * necessary resources\n+ *\n+ * @retval HSA_STATUS_ERROR_INVALID_ARGUMENT Bad or mismatched descriptor,\n+ * null image_data, or mismatched access_permission.\n+ */\n+hsa_status_t HSA_API hsa_amd_image_create(\n+    hsa_agent_t agent,\n+    const hsa_ext_image_descriptor_t *image_descriptor,\n+    const hsa_amd_image_descriptor_t *image_layout,\n+    const void *image_data,\n+    hsa_access_permission_t access_permission,\n+    hsa_ext_image_t *image\n+);\n+\n+/**\n+ * @brief Denotes the type of memory in a pointer info query.\n+ */\n+typedef enum {\n+  /*\n+  Memory is not known to the HSA driver.  Unallocated or unlocked system memory.\n+  */\n+  HSA_EXT_POINTER_TYPE_UNKNOWN = 0,\n+  /*\n+  Memory was allocated with an HSA memory allocator.\n+  */\n+  HSA_EXT_POINTER_TYPE_HSA = 1,\n+  /*\n+  System memory which has been locked for use with an HSA agent.\n+\n+  Memory of this type is normal malloc'd memory and is always accessible to\n+  the CPU.  Pointer info queries may not include CPU agents in the accessible\n+  agents list as the CPU has implicit access.\n+  */\n+  HSA_EXT_POINTER_TYPE_LOCKED = 2,\n+  /*\n+  Memory originated in a graphics component and is shared with ROCr.\n+  */\n+  HSA_EXT_POINTER_TYPE_GRAPHICS = 3,\n+  /*\n+  Memory has been shared with the local process via ROCr IPC APIs.\n+  */\n+  HSA_EXT_POINTER_TYPE_IPC = 4\n+} hsa_amd_pointer_type_t;\n+\n+/**\n+ * @brief Describes a memory allocation known to ROCr.\n+ * Within a ROCr major version this structure can only grow.\n+ */\n+typedef struct hsa_amd_pointer_info_s {\n+  /*\n+  Size in bytes of this structure.  Used for version control within a major ROCr\n+  revision.  Set to sizeof(hsa_amd_pointer_t) prior to calling\n+  hsa_amd_pointer_info.  If the runtime supports an older version of pointer\n+  info then size will be smaller on return.  Members starting after the return\n+  value of size will not be updated by hsa_amd_pointer_info.\n+  */\n+  uint32_t size;\n+  /*\n+  The type of allocation referenced.\n+  */\n+  hsa_amd_pointer_type_t type;\n+  /*\n+  Base address at which non-host agents may access the allocation.\n+  */\n+  void* agentBaseAddress;\n+  /*\n+  Base address at which the host agent may access the allocation.\n+  */\n+  void* hostBaseAddress;\n+  /*\n+  Size of the allocation\n+  */\n+  size_t sizeInBytes;\n+  /*\n+  Application provided value.\n+  */\n+  void* userData;\n+  /*\n+  Reports an agent which \"owns\" (ie has preferred access to) the pool in which the allocation was\n+  made.  When multiple agents share equal access to a pool (ex: multiple CPU agents, or multi-die\n+  GPU boards) any such agent may be returned.\n+  */\n+  hsa_agent_t agentOwner;\n+} hsa_amd_pointer_info_t;\n+\n+/**\n+ * @brief Retrieves information about the allocation referenced by the given\n+ * pointer.  Optionally returns the number and list of agents which can\n+ * directly access the allocation.\n+ *\n+ * @param[in] ptr Pointer which references the allocation to retrieve info for.\n+ *\n+ * @param[in, out] info Pointer to structure to be filled with allocation info.\n+ * Data member size must be set to the size of the structure prior to calling\n+ * hsa_amd_pointer_info.  On return size will be set to the size of the\n+ * pointer info structure supported by the runtime, if smaller.  Members\n+ * beyond the returned value of size will not be updated by the API.\n+ * Must not be NULL.\n+ *\n+ * @param[in] alloc Function pointer to an allocator used to allocate the\n+ * @p accessible array.  If NULL @p accessible will not be returned.\n+ *\n+ * @param[out] num_agents_accessible Recieves the count of agents in\n+ * @p accessible.  If NULL @p accessible will not be returned.\n+ *\n+ * @param[out] accessible Recieves a pointer to the array, allocated by @p alloc,\n+ * holding the list of agents which may directly access the allocation.\n+ * May be NULL.\n+ *\n+ * @retval HSA_STATUS_SUCCESS Info retrieved successfully\n+ *\n+ * @retval HSA_STATUS_ERROR_NOT_INITIALIZED if HSA is not initialized\n+ *\n+ * @retval HSA_STATUS_ERROR_OUT_OF_RESOURCES if there is a failure in allocating\n+ * necessary resources\n+ *\n+ * @retval HSA_STATUS_ERROR_INVALID_ARGUMENT NULL in @p ptr or @p info.\n+ */\n+hsa_status_t HSA_API hsa_amd_pointer_info(void* ptr,\n+                                          hsa_amd_pointer_info_t* info,\n+                                          void* (*alloc)(size_t),\n+                                          uint32_t* num_agents_accessible,\n+                                          hsa_agent_t** accessible);\n+\n+/**\n+ * @brief Associates an arbitrary pointer with an allocation known to ROCr.\n+ * The pointer can be fetched by hsa_amd_pointer_info in the userData field.\n+ *\n+ * @param[in] ptr Pointer to the first byte of an allocation known to ROCr\n+ * with which to associate @p userdata.\n+ *\n+ * @param[in] userdata Abitrary pointer to associate with the allocation.\n+ *\n+ * @retval HSA_STATUS_SUCCESS @p userdata successfully stored.\n+ *\n+ * @retval HSA_STATUS_ERROR_NOT_INITIALIZED if HSA is not initialized\n+ *\n+ * @retval HSA_STATUS_ERROR_OUT_OF_RESOURCES if there is a failure in allocating\n+ * necessary resources\n+ *\n+ * @retval HSA_STATUS_ERROR_INVALID_ARGUMENT @p ptr is not known to ROCr.\n+ */\n+hsa_status_t HSA_API hsa_amd_pointer_info_set_userdata(void* ptr,\n+                                                       void* userdata);\n+\n+/**\n+ * @brief 256-bit process independent identifier for a ROCr shared memory\n+ * allocation.\n+ */\n+typedef struct hsa_amd_ipc_memory_s {\n+  uint32_t handle[8];\n+} hsa_amd_ipc_memory_t;\n+\n+/**\n+ * @brief Prepares an allocation for interprocess sharing and creates a\n+ * handle of type hsa_amd_ipc_memory_t uniquely identifying the allocation.  A\n+ * handle is valid while the allocation it references remains accessible in\n+ * any process.  In general applications should confirm that a shared memory\n+ * region has been attached (via hsa_amd_ipc_memory_attach) in the remote\n+ * process prior to releasing that memory in the local process.\n+ * Repeated calls for the same allocation may, but are not required to, return\n+ * unique handles.\n+ *\n+ * @param[in] ptr Pointer to memory allocated via ROCr APIs to prepare for\n+ * sharing.\n+ *\n+ * @param[in] len Length in bytes of the allocation to share.\n+ *\n+ * @param[out] handle Process independent identifier referencing the shared\n+ * allocation.\n+ *\n+ * @retval HSA_STATUS_SUCCESS allocation is prepared for interprocess sharing.\n+ *\n+ * @retval HSA_STATUS_ERROR_NOT_INITIALIZED if HSA is not initialized\n+ *\n+ * @retval HSA_STATUS_ERROR_OUT_OF_RESOURCES if there is a failure in allocating\n+ * necessary resources\n+ *\n+ * @retval HSA_STATUS_ERROR_INVALID_ARGUMENT @p ptr does not point to the\n+ * first byte of an allocation made through ROCr, or len is not the full length\n+ * of the allocation or handle is NULL.\n+ */\n+hsa_status_t HSA_API hsa_amd_ipc_memory_create(void* ptr, size_t len,\n+                                               hsa_amd_ipc_memory_t* handle);\n+\n+/**\n+ * @brief Imports shared memory into the local process and makes it accessible\n+ * by the given agents.  If a shared memory handle is attached multiple times\n+ * in a process each attach may return a different address.  Each returned\n+ * address is refcounted and requires a matching number of calls to\n+ * hsa_amd_ipc_memory_detach to release the shared memory mapping.\n+ *\n+ * @param[in] handle Pointer to the identifier for the shared memory.\n+ *\n+ * @param[in] len Length of the shared memory to import.\n+ * Reserved.  Must be the full length of the shared allocation in this version.\n+ *\n+ * @param[in] num_agents Count of agents in @p mapping_agents.\n+ * May be zero if all agents are to be allowed access.\n+ *\n+ * @param[in] mapping_agents List of agents to access the shared memory.\n+ * Ignored if @p num_agents is zero.\n+ *\n+ * @param[out] mapped_ptr Recieves a process local pointer to the shared memory.\n+ *\n+ * @retval HSA_STATUS_SUCCESS if memory is successfully imported.\n+ *\n+ * @retval HSA_STATUS_ERROR_NOT_INITIALIZED if HSA is not initialized\n+ *\n+ * @retval HSA_STATUS_ERROR_OUT_OF_RESOURCES if there is a failure in allocating\n+ * necessary resources\n+ *\n+ * @retval HSA_STATUS_ERROR_INVALID_ARGUMENT @p handle is not valid, @p len is\n+ * incorrect, @p mapped_ptr is NULL, or some agent for which access was\n+ * requested can not access the shared memory.\n+ */\n+hsa_status_t HSA_API hsa_amd_ipc_memory_attach(\n+    const hsa_amd_ipc_memory_t* handle, size_t len,\n+    uint32_t num_agents,\n+    const hsa_agent_t* mapping_agents,\n+    void** mapped_ptr);\n+\n+/**\n+ * @brief Decrements the reference count for the shared memory mapping and\n+ * releases access to shared memory imported with hsa_amd_ipc_memory_attach.\n+ *\n+ * @param[in] mapped_ptr Pointer to the first byte of a shared allocation\n+ * imported with hsa_amd_ipc_memory_attach.\n+ *\n+ * @retval HSA_STATUS_SUCCESS if @p mapped_ptr was imported with\n+ * hsa_amd_ipc_memory_attach.\n+ *\n+ * @retval HSA_STATUS_ERROR_NOT_INITIALIZED if HSA is not initialized\n+ *\n+ * @retval HSA_STATUS_ERROR_INVALID_ARGUMENT @p mapped_ptr was not imported\n+ * with hsa_amd_ipc_memory_attach.\n+ */\n+hsa_status_t HSA_API hsa_amd_ipc_memory_detach(void* mapped_ptr);\n+\n+/**\n+ * @brief 256-bit process independent identifier for a ROCr IPC signal.\n+ */\n+typedef hsa_amd_ipc_memory_t hsa_amd_ipc_signal_t;\n+\n+/**\n+ * @brief Obtains an interprocess sharing handle for a signal.  The handle is\n+ * valid while the signal it references remains valid in any process.  In\n+ * general applications should confirm that the signal has been attached (via\n+ * hsa_amd_ipc_signal_attach) in the remote process prior to destroying that\n+ * signal in the local process.\n+ * Repeated calls for the same signal may, but are not required to, return\n+ * unique handles.\n+ *\n+ * @param[in] signal Signal created with attribute HSA_AMD_SIGNAL_IPC.\n+ *\n+ * @param[out] handle Process independent identifier referencing the shared\n+ * signal.\n+ *\n+ * @retval HSA_STATUS_SUCCESS @p handle is ready to use for interprocess sharing.\n+ *\n+ * @retval HSA_STATUS_ERROR_NOT_INITIALIZED if HSA is not initialized\n+ *\n+ * @retval HSA_STATUS_ERROR_OUT_OF_RESOURCES if there is a failure in allocating\n+ * necessary resources\n+ *\n+ * @retval HSA_STATUS_ERROR_INVALID_ARGUMENT @p signal is not a valid signal\n+ * created with attribute HSA_AMD_SIGNAL_IPC or handle is NULL.\n+ */\n+hsa_status_t HSA_API hsa_amd_ipc_signal_create(hsa_signal_t signal, hsa_amd_ipc_signal_t* handle);\n+\n+/**\n+ * @brief Imports an IPC capable signal into the local process.  If an IPC\n+ * signal handle is attached multiple times in a process each attach may return\n+ * a different signal handle.  Each returned signal handle is refcounted and\n+ * requires a matching number of calls to hsa_signal_destroy to release the\n+ * shared signal.\n+ *\n+ * @param[in] handle Pointer to the identifier for the shared signal.\n+ *\n+ * @param[out] signal Recieves a process local signal handle to the shared signal.\n+ *\n+ * @retval HSA_STATUS_SUCCESS if the signal is successfully imported.\n+ *\n+ * @retval HSA_STATUS_ERROR_NOT_INITIALIZED if HSA is not initialized\n+ *\n+ * @retval HSA_STATUS_ERROR_OUT_OF_RESOURCES if there is a failure in allocating\n+ * necessary resources\n+ *\n+ * @retval HSA_STATUS_ERROR_INVALID_ARGUMENT @p handle is not valid.\n+ */\n+hsa_status_t HSA_API hsa_amd_ipc_signal_attach(const hsa_amd_ipc_signal_t* handle,\n+                                               hsa_signal_t* signal);\n+\n+/**\n+ * @brief GPU system event type.\n+ */\n+typedef enum hsa_amd_event_type_s {\n+  /*\n+   AMD GPU memory fault.\n+   */\n+  HSA_AMD_GPU_MEMORY_FAULT_EVENT = 0,\n+} hsa_amd_event_type_t;\n+\n+/**\n+ * @brief Flags denoting the cause of a memory fault.\n+ */\n+typedef enum {\n+  // Page not present or supervisor privilege.\n+  HSA_AMD_MEMORY_FAULT_PAGE_NOT_PRESENT = 1 << 0,\n+  // Write access to a read-only page.\n+  HSA_AMD_MEMORY_FAULT_READ_ONLY = 1 << 1,\n+  // Execute access to a page marked NX.\n+  HSA_AMD_MEMORY_FAULT_NX = 1 << 2,\n+  // GPU attempted access to a host only page.\n+  HSA_AMD_MEMORY_FAULT_HOST_ONLY = 1 << 3,\n+  // DRAM ECC failure.\n+  HSA_AMD_MEMORY_FAULT_DRAM_ECC = 1 << 4,\n+  // Can't determine the exact fault address.\n+  HSA_AMD_MEMORY_FAULT_IMPRECISE = 1 << 5,\n+  // SRAM ECC failure (ie registers, no fault address).\n+  HSA_AMD_MEMORY_FAULT_SRAM_ECC = 1 << 6,\n+  // GPU reset following unspecified hang.\n+  HSA_AMD_MEMORY_FAULT_HANG = 1 << 31\n+} hsa_amd_memory_fault_reason_t;\n+\n+/**\n+ * @brief AMD GPU memory fault event data.\n+ */\n+typedef struct hsa_amd_gpu_memory_fault_info_s {\n+  /*\n+  The agent where the memory fault occurred.\n+  */\n+  hsa_agent_t agent;\n+  /*\n+  Virtual address accessed.\n+  */\n+  uint64_t virtual_address;\n+  /*\n+  Bit field encoding the memory access failure reasons. There could be multiple bits set\n+  for one fault.  Bits are defined in hsa_amd_memory_fault_reason_t.\n+  */\n+  uint32_t fault_reason_mask;\n+} hsa_amd_gpu_memory_fault_info_t;\n+\n+/**\n+ * @brief AMD GPU event data passed to event handler.\n+ */\n+typedef struct hsa_amd_event_s {\n+  /*\n+  The event type.\n+  */\n+  hsa_amd_event_type_t event_type;\n+  union {\n+    /*\n+    The memory fault info, only valid when @p event_type is HSA_AMD_GPU_MEMORY_FAULT_EVENT.\n+    */\n+    hsa_amd_gpu_memory_fault_info_t memory_fault;\n+  };\n+} hsa_amd_event_t;\n+\n+typedef hsa_status_t (*hsa_amd_system_event_callback_t)(const hsa_amd_event_t* event, void* data);\n+\n+/**\n+ * @brief Register AMD GPU event handler.\n+ *\n+ * @param[in] callback Callback to be invoked when an event is triggered.\n+ * The HSA runtime passes two arguments to the callback: @p event\n+ * is defined per event by the HSA runtime, and @p data is the user data.\n+ *\n+ * @param[in] data User data that is passed to @p callback. May be NULL.\n+ *\n+ * @retval HSA_STATUS_SUCCESS The handler has been registered successfully.\n+ *\n+ * @retval HSA_STATUS_ERROR An event handler has already been registered.\n+ *\n+ * @retval HSA_STATUS_ERROR_INVALID_ARGUMENT @p event is invalid.\n+ */\n+hsa_status_t HSA_API hsa_amd_register_system_event_handler(hsa_amd_system_event_callback_t callback,\n+                                                   void* data);\n+\n+/**\n+ * @brief Per-queue dispatch and wavefront scheduling priority.\n+ */\n+typedef enum hsa_amd_queue_priority_s {\n+  /*\n+  Below normal/high priority compute and all graphics\n+  */\n+  HSA_AMD_QUEUE_PRIORITY_LOW = 0,\n+  /*\n+  Above low priority compute, below high priority compute and all graphics\n+  */\n+  HSA_AMD_QUEUE_PRIORITY_NORMAL = 1,\n+  /*\n+  Above low/normal priority compute and all graphics\n+  */\n+  HSA_AMD_QUEUE_PRIORITY_HIGH = 2,\n+} hsa_amd_queue_priority_t;\n+\n+/**\n+ * @brief Modifies the dispatch and wavefront scheduling prioirty for a\n+ * given compute queue. The default is HSA_AMD_QUEUE_PRIORITY_NORMAL.\n+ *\n+ * @param[in] queue Compute queue to apply new priority to.\n+ *\n+ * @param[in] priority Priority to associate with queue.\n+ *\n+ * @retval HSA_STATUS_SUCCESS if priority was changed successfully.\n+ *\n+ * @retval HSA_STATUS_ERROR_INVALID_QUEUE if queue is not a valid\n+ * compute queue handle.\n+ *\n+ * @retval HSA_STATUS_ERROR_INVALID_ARGUMENT if priority is not a valid\n+ * value from hsa_amd_queue_priority_t.\n+ */\n+hsa_status_t HSA_API hsa_amd_queue_set_priority(hsa_queue_t* queue,\n+                                                hsa_amd_queue_priority_t priority);\n+\n+/**\n+ * @brief Deallocation notifier function type.\n+ */\n+typedef void (*hsa_amd_deallocation_callback_t)(void* ptr, void* user_data);\n+\n+/**\n+ * @brief Registers a deallocation notifier monitoring for release of agent\n+ * accessible address @p ptr.  If successful, @p callback will be invoked when\n+ * @p ptr is removed from accessibility from all agents.\n+ *\n+ * Notification callbacks are automatically deregistered when they are invoked.\n+ *\n+ * Note: The current version supports notifications of address release\n+ * originating from ::hsa_amd_memory_pool_free.  Support for other address\n+ * release APIs will follow.\n+ *\n+ * @param[in] ptr Agent accessible address to monitor for deallocation.  Passed\n+ * to @p callback.\n+ *\n+ * @param[in] callback Notifier to be invoked when @p ptr is released from\n+ * agent accessibility.\n+ *\n+ * @param[in] user_data User provided value passed to @p callback.  May be NULL.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The notifier registered successfully\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ALLOCATION @p ptr does not refer to a valid agent accessible\n+ * address.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p callback is NULL or @p ptr is NULL.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES if there is a failure in allocating\n+ * necessary resources\n+ */\n+hsa_status_t HSA_API hsa_amd_register_deallocation_callback(void* ptr,\n+                                                    hsa_amd_deallocation_callback_t callback,\n+                                                    void* user_data);\n+\n+/**\n+ * @brief Removes a deallocation notifier previously registered with\n+ * ::hsa_amd_register_deallocation_callback.  Arguments must be identical to\n+ * those given in ::hsa_amd_register_deallocation_callback.\n+ *\n+ * @param[in] ptr Agent accessible address which was monitored for deallocation.\n+ *\n+ * @param[in] callback Notifier to be removed.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The notifier has been removed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT The given notifier was not registered.\n+ */\n+hsa_status_t HSA_API hsa_amd_deregister_deallocation_callback(void* ptr,\n+                                                      hsa_amd_deallocation_callback_t callback);\n+\n+#ifdef __cplusplus\n+}  // end extern \"C\" block\n+#endif\n+\n+#endif  // header guard"}, {"sha": "52b695bc9fab9e042639d225213c6b92a1d056be", "filename": "include/hsa_ext_image.h", "status": "added", "additions": 1440, "deletions": 0, "changes": 1440, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f0a4d98229203181014fb84a1e4f74813aab9e/include%2Fhsa_ext_image.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f0a4d98229203181014fb84a1e4f74813aab9e/include%2Fhsa_ext_image.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fhsa_ext_image.h?ref=85f0a4d98229203181014fb84a1e4f74813aab9e", "patch": "@@ -0,0 +1,1440 @@\n+////////////////////////////////////////////////////////////////////////////////\n+//\n+// Copyright (C) 2014-2020 Advanced Micro Devices Inc.  All rights reserved.\n+//\n+// Permission is hereby granted, free of charge, to any person or organization\n+// obtaining a copy of the software and accompanying documentation covered by\n+// this license (the \"Software\") to use, reproduce, display, distribute,\n+// execute, and transmit the Software, and to prepare derivative works of the\n+// Software, and to permit third-parties to whom the Software is furnished to\n+// do so, all subject to the following:\n+//\n+// The copyright notices in the Software and this entire statement, including\n+// the above license grant, this restriction and the following disclaimer,\n+// must be included in all copies of the Software, in whole or in part, and\n+// all derivative works of the Software, unless such copies or derivative\n+// works are solely in the form of machine-executable object code generated by\n+// a source language processor.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\n+// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\n+// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n+// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+// DEALINGS IN THE SOFTWARE.\n+//\n+////////////////////////////////////////////////////////////////////////////////\n+\n+#ifndef HSA_EXT_IMAGE_H\n+#define HSA_EXT_IMAGE_H\n+\n+#include \"hsa.h\"\n+\n+#undef HSA_API\n+#ifdef HSA_EXPORT_IMAGES\n+#define HSA_API HSA_API_EXPORT\n+#else\n+#define HSA_API HSA_API_IMPORT\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif /*__cplusplus*/ \n+\n+/** \\defgroup ext-images Images and Samplers\n+ *  @{\n+ */\n+\n+/**\n+ * @brief Enumeration constants added to ::hsa_status_t by this extension.\n+ *\n+ * @remark Additions to hsa_status_t\n+ */\n+enum {\n+    /**\n+     * Image format is not supported.\n+     */\n+    HSA_EXT_STATUS_ERROR_IMAGE_FORMAT_UNSUPPORTED = 0x3000,\n+    /**\n+     * Image size is not supported.\n+     */\n+    HSA_EXT_STATUS_ERROR_IMAGE_SIZE_UNSUPPORTED = 0x3001,\n+    /**\n+     * Image pitch is not supported or invalid.\n+     */\n+    HSA_EXT_STATUS_ERROR_IMAGE_PITCH_UNSUPPORTED = 0x3002,\n+    /**\n+     * Sampler descriptor is not supported or invalid.\n+     */\n+    HSA_EXT_STATUS_ERROR_SAMPLER_DESCRIPTOR_UNSUPPORTED = 0x3003\n+};\n+\n+/**\n+ * @brief Enumeration constants added to ::hsa_agent_info_t by this\n+ * extension.\n+ *\n+ * @remark Additions to hsa_agent_info_t\n+ */\n+enum {\n+  /**\n+   * Maximum number of elements in 1D images. Must be at least 16384. The type\n+   * of this attribute is size_t.\n+   */\n+  HSA_EXT_AGENT_INFO_IMAGE_1D_MAX_ELEMENTS = 0x3000,\n+  /**\n+   * Maximum number of elements in 1DA images. Must be at least 16384. The type\n+   * of this attribute is size_t.\n+   */\n+  HSA_EXT_AGENT_INFO_IMAGE_1DA_MAX_ELEMENTS = 0x3001,\n+  /**\n+   * Maximum number of elements in 1DB images. Must be at least 65536. The type\n+   * of this attribute is size_t.\n+   */\n+  HSA_EXT_AGENT_INFO_IMAGE_1DB_MAX_ELEMENTS = 0x3002,\n+  /**\n+   * Maximum dimensions (width, height) of 2D images, in image elements. The X\n+   * and Y maximums must be at least 16384. The type of this attribute is\n+   * size_t[2].\n+   */\n+  HSA_EXT_AGENT_INFO_IMAGE_2D_MAX_ELEMENTS = 0x3003,\n+  /**\n+   * Maximum dimensions (width, height) of 2DA images, in image elements. The X\n+   * and Y maximums must be at least 16384. The type of this attribute is\n+   * size_t[2].\n+   */\n+  HSA_EXT_AGENT_INFO_IMAGE_2DA_MAX_ELEMENTS = 0x3004,\n+  /**\n+   * Maximum dimensions (width, height) of 2DDEPTH images, in image\n+   * elements. The X and Y maximums must be at least 16384. The type of this\n+   * attribute is size_t[2].\n+   */\n+  HSA_EXT_AGENT_INFO_IMAGE_2DDEPTH_MAX_ELEMENTS = 0x3005,\n+  /**\n+   * Maximum dimensions (width, height) of 2DADEPTH images, in image\n+   * elements. The X and Y maximums must be at least 16384. The type of this\n+   * attribute is size_t[2].\n+   */\n+  HSA_EXT_AGENT_INFO_IMAGE_2DADEPTH_MAX_ELEMENTS = 0x3006,\n+  /**\n+   * Maximum dimensions (width, height, depth) of 3D images, in image\n+   * elements. The maximum along any dimension must be at least 2048. The type\n+   * of this attribute is size_t[3].\n+   */\n+  HSA_EXT_AGENT_INFO_IMAGE_3D_MAX_ELEMENTS = 0x3007,\n+  /**\n+   * Maximum number of image layers in a image array. Must be at least 2048. The\n+   * type of this attribute is size_t.\n+   */\n+  HSA_EXT_AGENT_INFO_IMAGE_ARRAY_MAX_LAYERS = 0x3008,\n+  /**\n+   * Maximum number of read-only image handles that can be created for an agent at any one\n+   * time. Must be at least 128. The type of this attribute is size_t.\n+   */\n+  HSA_EXT_AGENT_INFO_MAX_IMAGE_RD_HANDLES = 0x3009,\n+  /**\n+   * Maximum number of write-only and read-write image handles (combined) that\n+   * can be created for an agent at any one time. Must be at least 64. The type of this\n+   * attribute is size_t.\n+   */\n+  HSA_EXT_AGENT_INFO_MAX_IMAGE_RORW_HANDLES = 0x300A,\n+  /**\n+   * Maximum number of sampler handlers that can be created for an agent at any one\n+   * time. Must be at least 16. The type of this attribute is size_t.\n+   */\n+  HSA_EXT_AGENT_INFO_MAX_SAMPLER_HANDLERS = 0x300B,\n+  /**\n+   * Image pitch alignment. The agent only supports linear image data\n+   * layouts with a row pitch that is a multiple of this value. Must be\n+   * a power of 2. The type of this attribute is size_t.\n+   */\n+  HSA_EXT_AGENT_INFO_IMAGE_LINEAR_ROW_PITCH_ALIGNMENT = 0x300C\n+};\n+\n+/**\n+ * @brief Image handle, populated by ::hsa_ext_image_create or\n+ * ::hsa_ext_image_create_with_layout. Image\n+ * handles are only unique within an agent, not across agents.\n+ *\n+ */\n+typedef struct hsa_ext_image_s {\n+  /**\n+   *  Opaque handle. For a given agent, two handles reference the same object of\n+   *  the enclosing type if and only if they are equal.\n+   */\n+    uint64_t handle;\n+\n+} hsa_ext_image_t;\n+\n+/**\n+ * @brief Geometry associated with the image. This specifies the\n+ * number of image dimensions and whether the image is an image\n+ * array. See the <em>Image Geometry</em> section in the <em>HSA\n+ * Programming Reference Manual</em> for definitions on each\n+ * geometry. The enumeration values match the BRIG type @p\n+ * hsa_ext_brig_image_geometry_t.\n+ */\n+typedef enum {\n+/**\n+   * One-dimensional image addressed by width coordinate.\n+   */\n+  HSA_EXT_IMAGE_GEOMETRY_1D = 0,\n+\n+  /**\n+   * Two-dimensional image addressed by width and height coordinates.\n+   */\n+  HSA_EXT_IMAGE_GEOMETRY_2D = 1,\n+\n+  /**\n+   * Three-dimensional image addressed by width, height, and depth coordinates.\n+   */\n+  HSA_EXT_IMAGE_GEOMETRY_3D = 2,\n+\n+  /**\n+   * Array of one-dimensional images with the same size and format. 1D arrays\n+   * are addressed by width and index coordinate.\n+   */\n+  HSA_EXT_IMAGE_GEOMETRY_1DA = 3,\n+\n+  /**\n+   * Array of two-dimensional images with the same size and format. 2D arrays\n+   * are addressed by width,  height, and index coordinates.\n+   */\n+  HSA_EXT_IMAGE_GEOMETRY_2DA = 4,\n+\n+  /**\n+   * One-dimensional image addressed by width coordinate. It has\n+   * specific restrictions compared to ::HSA_EXT_IMAGE_GEOMETRY_1D. An\n+   * image with an opaque image data layout will always use a linear\n+   * image data layout, and one with an explicit image data layout\n+   * must specify ::HSA_EXT_IMAGE_DATA_LAYOUT_LINEAR.\n+   */\n+  HSA_EXT_IMAGE_GEOMETRY_1DB = 5,\n+\n+  /**\n+   * Two-dimensional depth image addressed by width and height coordinates.\n+   */\n+  HSA_EXT_IMAGE_GEOMETRY_2DDEPTH = 6,\n+\n+  /**\n+   * Array of two-dimensional depth images with the same size and format. 2D\n+   * arrays are addressed by width, height, and index coordinates.\n+   */\n+  HSA_EXT_IMAGE_GEOMETRY_2DADEPTH = 7\n+} hsa_ext_image_geometry_t;\n+\n+/**\n+ * @brief Channel type associated with the elements of an image. See\n+ * the <em>Channel Type</em> section in the <em>HSA Programming Reference\n+ * Manual</em> for definitions on each channel type. The\n+ * enumeration values and definition match the BRIG type @p\n+ * hsa_ext_brig_image_channel_type_t.\n+ */\n+typedef enum {\n+    HSA_EXT_IMAGE_CHANNEL_TYPE_SNORM_INT8 = 0,\n+    HSA_EXT_IMAGE_CHANNEL_TYPE_SNORM_INT16 = 1,\n+    HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_INT8 = 2,\n+    HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_INT16 = 3,\n+    HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_INT24 = 4,\n+    HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_SHORT_555 = 5,\n+    HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_SHORT_565 = 6,\n+    HSA_EXT_IMAGE_CHANNEL_TYPE_UNORM_SHORT_101010 = 7,\n+    HSA_EXT_IMAGE_CHANNEL_TYPE_SIGNED_INT8 = 8,\n+    HSA_EXT_IMAGE_CHANNEL_TYPE_SIGNED_INT16 = 9,\n+    HSA_EXT_IMAGE_CHANNEL_TYPE_SIGNED_INT32 = 10,\n+    HSA_EXT_IMAGE_CHANNEL_TYPE_UNSIGNED_INT8 = 11,\n+    HSA_EXT_IMAGE_CHANNEL_TYPE_UNSIGNED_INT16 = 12,\n+    HSA_EXT_IMAGE_CHANNEL_TYPE_UNSIGNED_INT32 = 13,\n+    HSA_EXT_IMAGE_CHANNEL_TYPE_HALF_FLOAT = 14,\n+    HSA_EXT_IMAGE_CHANNEL_TYPE_FLOAT = 15\n+} hsa_ext_image_channel_type_t;\n+\n+/**\n+ * @brief A fixed-size type used to represent ::hsa_ext_image_channel_type_t constants.\n+ */\n+typedef uint32_t hsa_ext_image_channel_type32_t;\n+    \n+/**\n+ *\n+ * @brief Channel order associated with the elements of an image. See\n+ * the <em>Channel Order</em> section in the <em>HSA Programming Reference\n+ * Manual</em> for definitions on each channel order. The\n+ * enumeration values match the BRIG type @p\n+ * hsa_ext_brig_image_channel_order_t.\n+ */\n+typedef enum {\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_A = 0,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_R = 1,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_RX = 2,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_RG = 3,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_RGX = 4,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_RA = 5,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_RGB = 6,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_RGBX = 7,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_RGBA = 8,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_BGRA = 9,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_ARGB = 10,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_ABGR = 11,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_SRGB = 12,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_SRGBX = 13,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_SRGBA = 14,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_SBGRA = 15,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_INTENSITY = 16,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_LUMINANCE = 17,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_DEPTH = 18,\n+    HSA_EXT_IMAGE_CHANNEL_ORDER_DEPTH_STENCIL = 19\n+} hsa_ext_image_channel_order_t;\n+\n+/**\n+ * @brief A fixed-size type used to represent ::hsa_ext_image_channel_order_t constants.\n+ */\n+typedef uint32_t hsa_ext_image_channel_order32_t;\n+    \n+\n+/**\n+ * @brief Image format.\n+ */\n+typedef struct hsa_ext_image_format_s {\n+  /**\n+    * Channel type.\n+    */\n+    hsa_ext_image_channel_type32_t channel_type;\n+\n+   /**\n+    * Channel order.\n+    */\n+    hsa_ext_image_channel_order32_t channel_order;\n+} hsa_ext_image_format_t;\n+\n+/**\n+ * @brief Implementation independent image descriptor.\n+ */\n+typedef struct hsa_ext_image_descriptor_s {\n+    /**\n+     * Image geometry.\n+     */\n+    hsa_ext_image_geometry_t geometry;\n+    /**\n+     * Width of the image, in components.\n+     */\n+    size_t width;\n+    /**\n+     * Height of the image, in components. Only used if the geometry is\n+     * ::HSA_EXT_IMAGE_GEOMETRY_2D, ::HSA_EXT_IMAGE_GEOMETRY_3D,\n+     * HSA_EXT_IMAGE_GEOMETRY_2DA, HSA_EXT_IMAGE_GEOMETRY_2DDEPTH, or\n+     * HSA_EXT_IMAGE_GEOMETRY_2DADEPTH, otherwise must be 0.\n+     */\n+    size_t height;\n+    /**\n+     * Depth of the image, in components. Only used if the geometry is\n+     * ::HSA_EXT_IMAGE_GEOMETRY_3D, otherwise must be 0.\n+     */\n+    size_t depth;\n+    /**\n+     * Number of image layers in the image array. Only used if the geometry is\n+     * ::HSA_EXT_IMAGE_GEOMETRY_1DA, ::HSA_EXT_IMAGE_GEOMETRY_2DA, or\n+     * HSA_EXT_IMAGE_GEOMETRY_2DADEPTH, otherwise must be 0.\n+     */\n+    size_t array_size;\n+    /**\n+     * Image format.\n+     */\n+    hsa_ext_image_format_t format;\n+} hsa_ext_image_descriptor_t;\n+\n+/**\n+ * @brief Image capability.\n+ */\n+typedef enum  {\n+   /**\n+    * Images of this geometry, format, and layout are not supported by\n+    * the agent.\n+    */\n+    HSA_EXT_IMAGE_CAPABILITY_NOT_SUPPORTED = 0x0,\n+   /**\n+    * Read-only images of this geometry, format, and layout are\n+    * supported by the agent.\n+    */\n+    HSA_EXT_IMAGE_CAPABILITY_READ_ONLY = 0x1,\n+   /**\n+    * Write-only images of this geometry, format, and layout are\n+    * supported by the agent.\n+    */\n+    HSA_EXT_IMAGE_CAPABILITY_WRITE_ONLY = 0x2,\n+   /**\n+    * Read-write images of this geometry, format, and layout are\n+    * supported by the agent.\n+    */\n+    HSA_EXT_IMAGE_CAPABILITY_READ_WRITE = 0x4,\n+   /**\n+    * @deprecated Images of this geometry, format, and layout can be accessed from\n+    * read-modify-write atomic operations in the agent.\n+    */\n+    HSA_EXT_IMAGE_CAPABILITY_READ_MODIFY_WRITE = 0x8,\n+    /**\n+    * Images of this geometry, format, and layout are guaranteed to\n+    * have a consistent data layout regardless of how they are\n+    * accessed by the associated agent.\n+    */\n+    HSA_EXT_IMAGE_CAPABILITY_ACCESS_INVARIANT_DATA_LAYOUT = 0x10\n+} hsa_ext_image_capability_t;\n+\n+/**\n+ * @brief Image data layout.\n+ *\n+ * @details An image data layout denotes such aspects of image data\n+ * layout as tiling and organization of channels in memory. Some image\n+ * data layouts may only apply to specific image geometries, formats,\n+ * and access permissions. Different agents may support different\n+ * image layout identifiers, including vendor specific layouts. Note\n+ * that an agent may not support the same image data layout for\n+ * different access permissions to images with the same image\n+ * geometry, size, and format. If multiple agents support the same\n+ * image data layout then it is possible to use separate image handles\n+ * for each agent that references the same image data.\n+ */\n+\n+typedef enum  {\n+   /**\n+    * An implementation specific opaque image data layout which can\n+    * vary depending on the agent, geometry, image format, image size,\n+    * and access permissions.\n+    */\n+    HSA_EXT_IMAGE_DATA_LAYOUT_OPAQUE = 0x0,\n+   /**\n+    * The image data layout is specified by the following rules in\n+    * ascending byte address order. For a 3D image, 2DA image array,\n+    * or 1DA image array, the image data is stored as a linear sequence\n+    * of adjacent 2D image slices, 2D images, or 1D images\n+    * respectively, spaced according to the slice pitch. Each 2D image\n+    * is stored as a linear sequence of adjacent image rows, spaced\n+    * according to the row pitch. Each 1D or 1DB image is stored as a\n+    * single image row. Each image row is stored as a linear sequence\n+    * of image elements. Each image element is stored as a linear\n+    * sequence of image components specified by the left to right\n+    * channel order definition. Each image component is stored using\n+    * the memory type specified by the channel type.\n+    *\n+    * The 1DB image geometry always uses the linear image data layout.\n+    */\n+    HSA_EXT_IMAGE_DATA_LAYOUT_LINEAR = 0x1\n+} hsa_ext_image_data_layout_t;\n+\n+/**\n+ * @brief Retrieve the supported image capabilities for a given combination of\n+ * agent, geometry, and image format for an image created with an opaque image\n+ * data layout.\n+ *\n+ * @param[in] agent Agent to be associated with the image handle.\n+ *\n+ * @param[in] geometry Geometry.\n+ *\n+ * @param[in] image_format Pointer to an image format. Must not be NULL.\n+ *\n+ * @param[out] capability_mask Pointer to a memory location where the HSA\n+ * runtime stores a bit-mask of supported image capability\n+ * (::hsa_ext_image_capability_t) values. Must not be NULL.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p image_format is\n+ * NULL, or @p capability_mask is NULL.\n+ */\n+hsa_status_t HSA_API hsa_ext_image_get_capability(\n+    hsa_agent_t agent,\n+    hsa_ext_image_geometry_t geometry,\n+    const hsa_ext_image_format_t *image_format,\n+    uint32_t *capability_mask);\n+\n+/**\n+ * @brief Retrieve the supported image capabilities for a given combination of\n+ * agent, geometry, image format, and image layout for an image created with\n+ * an explicit image data layout.\n+ *\n+ * @param[in] agent Agent to be associated with the image handle.\n+ *\n+ * @param[in] geometry Geometry.\n+ *\n+ * @param[in] image_format Pointer to an image format. Must not be NULL.\n+ *\n+ * @param[in] image_data_layout The image data layout.\n+ * It is invalid to use ::HSA_EXT_IMAGE_DATA_LAYOUT_OPAQUE; use\n+ * ::hsa_ext_image_get_capability instead.\n+ *\n+ * @param[out] capability_mask Pointer to a memory location where the HSA\n+ * runtime stores a bit-mask of supported image capability\n+ * (::hsa_ext_image_capability_t) values. Must not be NULL.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p image_format is\n+ * NULL, @p image_data_layout is ::HSA_EXT_IMAGE_DATA_LAYOUT_OPAQUE,\n+ * or @p capability_mask is NULL.\n+ */\n+hsa_status_t HSA_API hsa_ext_image_get_capability_with_layout(\n+    hsa_agent_t agent,\n+    hsa_ext_image_geometry_t geometry,\n+    const hsa_ext_image_format_t *image_format,\n+    hsa_ext_image_data_layout_t image_data_layout,\n+    uint32_t *capability_mask);\n+\n+/**\n+ * @brief Agent specific image size and alignment requirements, populated by\n+ * ::hsa_ext_image_data_get_info and ::hsa_ext_image_data_get_info_with_layout.\n+ */\n+typedef struct hsa_ext_image_data_info_s {\n+  /**\n+   * Image data size, in bytes.\n+   */\n+  size_t size;\n+\n+  /**\n+   * Image data alignment, in bytes. Must always be a power of 2.\n+   */\n+  size_t alignment;\n+\n+} hsa_ext_image_data_info_t;\n+\n+/**\n+ * @brief Retrieve the image data requirements for a given combination of agent, image\n+ * descriptor, and access permission for an image created with an opaque image\n+ * data layout.\n+ *\n+ * @details The optimal image data size and alignment requirements may\n+ * vary depending on the image attributes specified in @p\n+ * image_descriptor, the @p access_permission, and the @p agent. Also,\n+ * different implementations of the HSA runtime may return different\n+ * requirements for the same input values.\n+ *\n+ * The implementation must return the same image data requirements for\n+ * different access permissions with matching image descriptors as long\n+ * as ::hsa_ext_image_get_capability reports\n+ * ::HSA_EXT_IMAGE_CAPABILITY_ACCESS_INVARIANT_DATA_LAYOUT. Image\n+ * descriptors match if they have the same values, with the exception\n+ * that s-form channel orders match the corresponding non-s-form\n+ * channel order and vice versa.\n+ *\n+ * @param[in] agent Agent to be associated with the image handle.\n+ *\n+ * @param[in] image_descriptor Pointer to an image descriptor. Must not be NULL.\n+ *\n+ * @param[in] access_permission Access permission of the image when\n+ * accessed by @p agent. The access permission defines how the agent\n+ * is allowed to access the image and must match the corresponding\n+ * HSAIL image handle type. The @p agent must support the image format\n+ * specified in @p image_descriptor for the given @p\n+ * access_permission.\n+ *\n+ * @param[out] image_data_info Memory location where the runtime stores the\n+ * size and alignment requirements. Must not be NULL.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n+ *\n+ * @retval ::HSA_EXT_STATUS_ERROR_IMAGE_FORMAT_UNSUPPORTED The @p\n+ * agent does not support the image format specified by @p\n+ * image_descriptor with the specified @p access_permission.\n+ *\n+ * @retval ::HSA_EXT_STATUS_ERROR_IMAGE_SIZE_UNSUPPORTED The agent\n+ * does not support the image dimensions specified by @p\n+ * image_descriptor with the specified @p access_permission.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p image_descriptor is NULL, @p\n+ * access_permission is not a valid access permission value, or @p\n+ * image_data_info is NULL.\n+ */\n+hsa_status_t HSA_API hsa_ext_image_data_get_info(\n+    hsa_agent_t agent,\n+    const hsa_ext_image_descriptor_t *image_descriptor,\n+    hsa_access_permission_t access_permission,\n+    hsa_ext_image_data_info_t *image_data_info);\n+\n+/**\n+ * @brief Retrieve the image data requirements for a given combination of\n+ * image descriptor, access permission, image data layout, image data row pitch,\n+ * and image data slice pitch for an image created with an explicit image\n+ * data layout.\n+ *\n+ * @details The image data size and alignment requirements may vary\n+ * depending on the image attributes specified in @p image_descriptor,\n+ * the @p access_permission, and the image layout. However, different\n+ * implementations of the HSA runtime will return the same\n+ * requirements for the same input values.\n+ *\n+ * The implementation must return the same image data requirements for\n+ * different access permissions with matching image descriptors and\n+ * matching image layouts as long as ::hsa_ext_image_get_capability\n+ * reports\n+ * ::HSA_EXT_IMAGE_CAPABILITY_ACCESS_INVARIANT_DATA_LAYOUT. Image\n+ * descriptors match if they have the same values, with the exception\n+ * that s-form channel orders match the corresponding non-s-form\n+ * channel order and vice versa. Image layouts match if they are the\n+ * same image data layout and use the same image row and slice pitch\n+ * values.\n+ *\n+ * @param[in] image_descriptor Pointer to an image descriptor. Must not be NULL.\n+ *\n+ * @param[in] access_permission Access permission of the image when\n+ * accessed by an agent. The access permission defines how the agent\n+ * is allowed to access the image and must match the corresponding\n+ * HSAIL image handle type.\n+ *\n+ * @param[in] image_data_layout The image data layout to use.\n+ * It is invalid to use ::HSA_EXT_IMAGE_DATA_LAYOUT_OPAQUE; use\n+ * ::hsa_ext_image_data_get_info instead.\n+ *\n+ * @param[in] image_data_row_pitch The size in bytes for a single row\n+ * of the image in the image data. If 0 is specified then the default\n+ * row pitch value is used: image width * image element byte size.\n+ * The value used must be greater than or equal to the default row\n+ * pitch, and be a multiple of the image element byte size. For the\n+ * linear image layout it must also be a multiple of the image linear\n+ * row pitch alignment for the agents that will access the image data\n+ * using image instructions.\n+ *\n+ * @param[in] image_data_slice_pitch The size in bytes of a single\n+ * slice of a 3D image, or the size in bytes of each image layer in an\n+ * image array in the image data. If 0 is specified then the default\n+ * slice pitch value is used: row pitch * height if geometry is\n+ * ::HSA_EXT_IMAGE_GEOMETRY_3D, ::HSA_EXT_IMAGE_GEOMETRY_2DA, or\n+ * ::HSA_EXT_IMAGE_GEOMETRY_2DADEPTH; row pitch if geometry is\n+ * ::HSA_EXT_IMAGE_GEOMETRY_1DA; and 0 otherwise. The value used must\n+ * be 0 if the default slice pitch is 0, be greater than or equal to\n+ * the default slice pitch, and be a multiple of the row pitch.\n+ *\n+ * @param[out] image_data_info Memory location where the runtime stores the\n+ * size and alignment requirements. Must not be NULL.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_EXT_STATUS_ERROR_IMAGE_FORMAT_UNSUPPORTED The image\n+ * format specified by @p image_descriptor is not supported for the\n+ * @p access_permission and @p image_data_layout specified.\n+ *\n+ * @retval ::HSA_EXT_STATUS_ERROR_IMAGE_SIZE_UNSUPPORTED The image\n+ * dimensions specified by @p image_descriptor are not supported for\n+ * the @p access_permission and @p image_data_layout specified.\n+ *\n+ * @retval ::HSA_EXT_STATUS_ERROR_IMAGE_PITCH_UNSUPPORTED The row and\n+ * slice pitch specified by @p image_data_row_pitch and @p\n+ * image_data_slice_pitch are invalid or not supported.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p image_descriptor is\n+ * NULL, @p image_data_layout is ::HSA_EXT_IMAGE_DATA_LAYOUT_OPAQUE,\n+ * or @p image_data_info is NULL.\n+ */\n+hsa_status_t HSA_API hsa_ext_image_data_get_info_with_layout(\n+    hsa_agent_t agent,\n+    const hsa_ext_image_descriptor_t *image_descriptor,\n+    hsa_access_permission_t access_permission,\n+    hsa_ext_image_data_layout_t image_data_layout,\n+    size_t image_data_row_pitch,\n+    size_t image_data_slice_pitch,\n+    hsa_ext_image_data_info_t *image_data_info);\n+\n+/**\n+ * @brief Creates an agent specific image handle to an image with an\n+ * opaque image data layout.\n+ *\n+ * @details Images with an opaque image data layout created with\n+ * different access permissions but matching image descriptors and\n+ * same agent can share the same image data if\n+ * ::HSA_EXT_IMAGE_CAPABILITY_ACCESS_INVARIANT_DATA_LAYOUT is reported\n+ * by ::hsa_ext_image_get_capability for the image format specified in\n+ * the image descriptor. Image descriptors match if they have the same\n+ * values, with the exception that s-form channel orders match the\n+ * corresponding non-s-form channel order and vice versa.\n+ *\n+ * If necessary, an application can use image operations (import,\n+ * export, copy, clear) to prepare the image for the intended use\n+ * regardless of the access permissions.\n+ *\n+ * @param[in] agent agent to be associated with the image handle created.\n+ *\n+ * @param[in] image_descriptor Pointer to an image descriptor. Must not be NULL.\n+ *\n+ * @param[in] image_data Image data buffer that must have been allocated\n+ * according to the size and alignment requirements dictated by\n+ * ::hsa_ext_image_data_get_info. Must not be NULL.\n+ *\n+ * Any previous memory contents are preserved upon creation. The application is\n+ * responsible for ensuring that the lifetime of the image data exceeds that of\n+ * all the associated images.\n+ *\n+ * @param[in] access_permission Access permission of the image when\n+ * accessed by agent. The access permission defines how the agent\n+ * is allowed to access the image using the image handle created and\n+ * must match the corresponding HSAIL image handle type. The agent\n+ * must support the image format specified in @p image_descriptor for\n+ * the given @p access_permission.\n+ *\n+ * @param[out] image Pointer to a memory location where the HSA runtime stores\n+ * the newly created image handle. Must not be NULL.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n+ *\n+ * @retval ::HSA_EXT_STATUS_ERROR_IMAGE_FORMAT_UNSUPPORTED The agent\n+ * does not have the capability to support the image format contained\n+ * in @p image_descriptor using the specified @p access_permission.\n+ *\n+ * @retval ::HSA_EXT_STATUS_ERROR_IMAGE_SIZE_UNSUPPORTED The agent\n+ * does not support the image dimensions specified by @p\n+ * image_descriptor using the specified @p access_permission.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to allocate\n+ * the required resources.\n+ *\n+ * support the creation of more image handles with the given @p access_permission).\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p image_descriptor is NULL, @p\n+ * image_data is NULL, @p image_data does not have a valid alignment,\n+ * @p access_permission is not a valid access permission\n+ * value, or @p image is NULL.\n+ */\n+hsa_status_t HSA_API hsa_ext_image_create(\n+    hsa_agent_t agent,\n+    const hsa_ext_image_descriptor_t *image_descriptor,\n+    const void *image_data,\n+    hsa_access_permission_t access_permission,\n+    hsa_ext_image_t *image);\n+\n+/**\n+ * @brief Creates an agent specific image handle to an image with an explicit\n+ * image data layout.\n+ *\n+ * @details Images with an explicit image data layout created with\n+ * different access permissions but matching image descriptors and\n+ * matching image layout can share the same image data if\n+ * ::HSA_EXT_IMAGE_CAPABILITY_ACCESS_INVARIANT_DATA_LAYOUT is reported\n+ * by ::hsa_ext_image_get_capability_with_layout for the image format\n+ * specified in the image descriptor and specified image data\n+ * layout. Image descriptors match if they have the same values, with\n+ * the exception that s-form channel orders match the corresponding\n+ * non-s-form channel order and vice versa. Image layouts match if\n+ * they are the same image data layout and use the same image row and\n+ * slice values.\n+ *\n+ * If necessary, an application can use image operations (import, export, copy,\n+ * clear) to prepare the image for the intended use regardless of the access\n+ * permissions.\n+ *\n+ * @param[in] agent agent to be associated with the image handle created.\n+ *\n+ * @param[in] image_descriptor Pointer to an image descriptor. Must not be NULL.\n+ *\n+ * @param[in] image_data Image data buffer that must have been allocated\n+ * according to the size and alignment requirements dictated by\n+ * ::hsa_ext_image_data_get_info_with_layout. Must not be NULL.\n+ *\n+ * Any previous memory contents are preserved upon creation. The application is\n+ * responsible for ensuring that the lifetime of the image data exceeds that of\n+ * all the associated images.\n+ *\n+ * @param[in] access_permission Access permission of the image when\n+ * accessed by the agent. The access permission defines how the agent\n+ * is allowed to access the image and must match the corresponding\n+ * HSAIL image handle type. The agent must support the image format\n+ * specified in @p image_descriptor for the given @p access_permission\n+ * and @p image_data_layout.\n+ *\n+ * @param[in] image_data_layout The image data layout to use for the\n+ * @p image_data. It is invalid to use\n+ * ::HSA_EXT_IMAGE_DATA_LAYOUT_OPAQUE; use ::hsa_ext_image_create\n+ * instead.\n+ *\n+ * @param[in] image_data_row_pitch The size in bytes for a single row\n+ * of the image in the image data. If 0 is specified then the default\n+ * row pitch value is used: image width * image element byte size.\n+ * The value used must be greater than or equal to the default row\n+ * pitch, and be a multiple of the image element byte size. For the\n+ * linear image layout it must also be a multiple of the image linear\n+ * row pitch alignment for the agents that will access the image data\n+ * using image instructions.\n+ *\n+ * @param[in] image_data_slice_pitch The size in bytes of a single\n+ * slice of a 3D image, or the size in bytes of each image layer in an\n+ * image array in the image data. If 0 is specified then the default\n+ * slice pitch value is used: row pitch * height if geometry is\n+ * ::HSA_EXT_IMAGE_GEOMETRY_3D, ::HSA_EXT_IMAGE_GEOMETRY_2DA, or\n+ * ::HSA_EXT_IMAGE_GEOMETRY_2DADEPTH; row pitch if geometry is\n+ * ::HSA_EXT_IMAGE_GEOMETRY_1DA; and 0 otherwise. The value used must\n+ * be 0 if the default slice pitch is 0, be greater than or equal to\n+ * the default slice pitch, and be a multiple of the row pitch.\n+ *\n+ * @param[out] image Pointer to a memory location where the HSA runtime stores\n+ * the newly created image handle. Must not be NULL.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n+ *\n+ * @retval ::HSA_EXT_STATUS_ERROR_IMAGE_FORMAT_UNSUPPORTED The agent does\n+ * not have the capability to support the image format contained in the image\n+ * descriptor using the specified @p access_permission and @p image_data_layout.\n+ *\n+ * @retval ::HSA_EXT_STATUS_ERROR_IMAGE_SIZE_UNSUPPORTED The agent\n+ * does not support the image dimensions specified by @p\n+ * image_descriptor using the specified @p access_permission and @p\n+ * image_data_layout.\n+ *\n+ * @retval ::HSA_EXT_STATUS_ERROR_IMAGE_PITCH_UNSUPPORTED The agent does\n+ * not support the row and slice pitch specified by @p image_data_row_pitch\n+ * and @p image_data_slice_pitch, or the values are invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to allocate\n+ * the required resources.\n+ *\n+ * support the creation of more image handles with the given @p access_permission).\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p image_descriptor is NULL, @p\n+ * image_data is NULL, @p image_data does not have a valid alignment,\n+ * @p image_data_layout is ::HSA_EXT_IMAGE_DATA_LAYOUT_OPAQUE,\n+ * or @p image is NULL.\n+ */\n+hsa_status_t HSA_API hsa_ext_image_create_with_layout(\n+    hsa_agent_t agent,\n+    const hsa_ext_image_descriptor_t *image_descriptor,\n+    const void *image_data,\n+    hsa_access_permission_t access_permission,\n+    hsa_ext_image_data_layout_t image_data_layout,\n+    size_t image_data_row_pitch,\n+    size_t image_data_slice_pitch,\n+    hsa_ext_image_t *image);\n+\n+/**\n+ * @brief Destroy an image handle previously created using ::hsa_ext_image_create or\n+ * ::hsa_ext_image_create_with_layout.\n+ *\n+ * @details Destroying the image handle does not free the associated image data,\n+ * or modify its contents. The application should not destroy an image handle while\n+ * there are references to it queued for execution or currently being used in a\n+ * kernel dispatch.\n+ *\n+ * @param[in] agent Agent associated with the image handle.\n+ *\n+ * @param[in] image Image handle to destroy.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n+ */\n+hsa_status_t HSA_API hsa_ext_image_destroy(\n+    hsa_agent_t agent,\n+    hsa_ext_image_t image);\n+\n+/**\n+ * @brief Copies a portion of one image (the source) to another image (the\n+ * destination).\n+ *\n+ * @details The source and destination image formats should be the\n+ * same, with the exception that s-form channel orders match the\n+ * corresponding non-s-form channel order and vice versa. For example,\n+ * it is allowed to copy a source image with a channel order of\n+ * HSA_EXT_IMAGE_CHANNEL_ORDER_SRGB to a destination image with a\n+ * channel order of HSA_EXT_IMAGE_CHANNEL_ORDER_RGB.\n+ *\n+ * The source and destination images do not have to be of the same geometry and\n+ * appropriate scaling is performed by the HSA runtime. It is possible to copy\n+ * subregions between any combinations of source and destination geometries, provided\n+ * that the dimensions of the subregions are the same. For example, it is\n+ * allowed to copy a rectangular region from a 2D image to a slice of a 3D\n+ * image.\n+ *\n+ * If the source and destination image data overlap, or the combination of\n+ * offset and range references an out-out-bounds element in any of the images,\n+ * the behavior is undefined.\n+ *\n+ * @param[in] agent Agent associated with both the source and destination image handles.\n+ *\n+ * @param[in] src_image Image handle of source image. The agent associated with the source\n+ * image handle must be identical to that of the destination image.\n+ *\n+ * @param[in] src_offset Pointer to the offset within the source image where to\n+ * copy the data from. Must not be NULL.\n+ *\n+ * @param[in] dst_image Image handle of destination image.\n+ *\n+ * @param[in] dst_offset Pointer to the offset within the destination\n+ * image where to copy the data. Must not be NULL.\n+ *\n+ * @param[in] range Dimensions of the image portion to be copied. The HSA\n+ * runtime computes the size of the image data to be copied using this\n+ * argument. Must not be NULL.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p src_offset is\n+ * NULL, @p dst_offset is NULL, or @p range is NULL.\n+ */\n+hsa_status_t HSA_API hsa_ext_image_copy(\n+    hsa_agent_t agent,\n+    hsa_ext_image_t src_image,\n+    const hsa_dim3_t* src_offset,\n+    hsa_ext_image_t dst_image,\n+    const hsa_dim3_t* dst_offset,\n+    const hsa_dim3_t* range);\n+\n+/**\n+ * @brief Image region.\n+ */\n+typedef struct hsa_ext_image_region_s {\n+   /**\n+    * Offset within an image (in coordinates).\n+    */\n+    hsa_dim3_t offset;\n+\n+   /**\n+    * Dimension size of the image range (in coordinates). The x, y, and z dimensions\n+    * correspond to width, height, and depth or index respectively.\n+    */\n+    hsa_dim3_t range;\n+} hsa_ext_image_region_t;\n+\n+/**\n+ * @brief Import a linearly organized image data from memory directly to an\n+ * image handle.\n+ *\n+ * @details This operation updates the image data referenced by the image handle\n+ * from the source memory. The size of the data imported from memory is\n+ * implicitly derived from the image region.\n+ *\n+ * It is the application's responsibility to avoid out of bounds memory access.\n+ *\n+ * None of the source memory or destination image data memory can\n+ * overlap. Overlapping of any of the source and destination image\n+ * data memory within the import operation produces undefined results.\n+ *\n+ * @param[in] agent Agent associated with the image handle.\n+ *\n+ * @param[in] src_memory Source memory. Must not be NULL.\n+ *\n+ * @param[in] src_row_pitch The size in bytes of a single row of the image in the\n+ * source memory. If the value is smaller than the destination image region\n+ * width * image element byte size, then region width * image element byte\n+ * size is used.\n+ *\n+ * @param[in] src_slice_pitch The size in bytes of a single 2D slice of a 3D image,\n+ * or the size in bytes of each image layer in an image array in the source memory.\n+ * If the geometry is ::HSA_EXT_IMAGE_GEOMETRY_1DA and the value is smaller than the\n+ * value used for @p src_row_pitch, then the value used for @p src_row_pitch is used.\n+ * If the geometry is ::HSA_EXT_IMAGE_GEOMETRY_3D, ::HSA_EXT_IMAGE_GEOMETRY_2DA, or\n+ * HSA_EXT_IMAGE_GEOMETRY_2DADEPTH and the value is smaller than the value used for\n+ * @p src_row_pitch * destination image region height, then the value used for\n+ * @p src_row_pitch * destination image region height is used.\n+ * Otherwise, the value is not used.\n+ *\n+ * @param[in] dst_image Image handle of destination image.\n+ *\n+ * @param[in] image_region Pointer to the image region to be updated. Must not\n+ * be NULL.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p src_memory is NULL, or @p\n+ * image_region is NULL.\n+ *\n+ */\n+hsa_status_t HSA_API hsa_ext_image_import(\n+    hsa_agent_t agent,\n+    const void *src_memory,\n+    size_t src_row_pitch,\n+    size_t src_slice_pitch,\n+    hsa_ext_image_t dst_image,\n+    const hsa_ext_image_region_t *image_region);\n+\n+/**\n+ * @brief Export the image data to linearly organized memory.\n+ *\n+ * @details The operation updates the destination memory with the image data of\n+ * @p src_image. The size of the data exported to memory is implicitly derived\n+ * from the image region.\n+ *\n+ * It is the application's responsibility to avoid out of bounds memory access.\n+ *\n+ * None of the destination memory or source image data memory can\n+ * overlap. Overlapping of any of the source and destination image\n+ * data memory within the export operation produces undefined results.\n+ *\n+ * @param[in] agent Agent associated with the image handle.\n+ *\n+ * @param[in] src_image Image handle of source image.\n+ *\n+ * @param[in] dst_memory Destination memory. Must not be NULL.\n+ *\n+ * @param[in] dst_row_pitch The size in bytes of a single row of the image in the\n+ * destination memory. If the value is smaller than the source image region\n+ * width * image element byte size, then region width * image element byte\n+ * size is used.\n+ *\n+ * @param[in] dst_slice_pitch The size in bytes of a single 2D slice of a 3D image,\n+ * or the size in bytes of each image in an image array in the destination memory.\n+ * If the geometry is ::HSA_EXT_IMAGE_GEOMETRY_1DA and the value is smaller than the\n+ * value used for @p dst_row_pitch, then the value used for @p dst_row_pitch is used.\n+ * If the geometry is ::HSA_EXT_IMAGE_GEOMETRY_3D, ::HSA_EXT_IMAGE_GEOMETRY_2DA, or\n+ * HSA_EXT_IMAGE_GEOMETRY_2DADEPTH and the value is smaller than the value used for\n+ * @p dst_row_pitch * source image region height, then the value used for\n+ * @p dst_row_pitch * source image region height is used.\n+ * Otherwise, the value is not used.\n+ *\n+ * @param[in] image_region Pointer to the image region to be exported. Must not\n+ * be NULL.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p dst_memory is NULL, or @p\n+ * image_region is NULL.\n+ */\n+hsa_status_t HSA_API hsa_ext_image_export(\n+    hsa_agent_t agent,\n+    hsa_ext_image_t src_image,\n+    void *dst_memory,\n+    size_t dst_row_pitch,\n+    size_t dst_slice_pitch,\n+    const hsa_ext_image_region_t *image_region);\n+\n+/**\n+ * @brief Clear a region of an image so that every image element has\n+ * the specified value.\n+ *\n+ * @param[in] agent Agent associated with the image handle.\n+ *\n+ * @param[in] image Image handle for image to be cleared.\n+ *\n+ * @param[in] data The value to which to set each image element being\n+ * cleared. It is specified as an array of image component values. The\n+ * number of array elements must match the number of access components\n+ * for the image channel order. The type of each array element must\n+ * match the image access type of the image channel type. When the\n+ * value is used to set the value of an image element, the conversion\n+ * method corresponding to the image channel type is used. See the\n+ * <em>Channel Order</em> section and <em>Channel Type</em> section in\n+ * the <em>HSA Programming Reference Manual</em> for more\n+ * information. Must not be NULL.\n+ *\n+ * @param[in] image_region Pointer to the image region to clear. Must not be\n+ * NULL. If the region references an out-out-bounds element, the behavior is\n+ * undefined.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p data is NULL, or @p\n+ * image_region is NULL.\n+ */\n+hsa_status_t HSA_API hsa_ext_image_clear(\n+    hsa_agent_t agent,\n+    hsa_ext_image_t image,\n+    const void* data,\n+    const hsa_ext_image_region_t *image_region);\n+\n+/**\n+ * @brief Sampler handle. Samplers are populated by\n+ * ::hsa_ext_sampler_create. Sampler handles are only unique within an\n+ * agent, not across agents.\n+ */\n+typedef struct hsa_ext_sampler_s {\n+  /**\n+   *  Opaque handle. For a given agent, two handles reference the same object of\n+   *  the enclosing type if and only if they are equal.\n+   */\n+    uint64_t handle;\n+} hsa_ext_sampler_t;\n+\n+/**\n+ * @brief Sampler address modes. The sampler address mode describes\n+ * the processing of out-of-range image coordinates. See the\n+ * <em>Addressing Mode</em> section in the <em>HSA Programming Reference\n+ * Manual</em> for definitions on each address mode. The values\n+ * match the BRIG type @p hsa_ext_brig_sampler_addressing_t.\n+ */\n+typedef enum {\n+  /**\n+   * Out-of-range coordinates are not handled.\n+   */\n+  HSA_EXT_SAMPLER_ADDRESSING_MODE_UNDEFINED = 0,\n+\n+  /**\n+   * Clamp out-of-range coordinates to the image edge.\n+   */\n+  HSA_EXT_SAMPLER_ADDRESSING_MODE_CLAMP_TO_EDGE = 1,\n+\n+  /**\n+   * Clamp out-of-range coordinates to the image border color.\n+   */\n+  HSA_EXT_SAMPLER_ADDRESSING_MODE_CLAMP_TO_BORDER = 2,\n+\n+  /**\n+   * Wrap out-of-range coordinates back into the valid coordinate\n+   * range so the image appears as repeated tiles.\n+   */\n+  HSA_EXT_SAMPLER_ADDRESSING_MODE_REPEAT = 3,\n+\n+  /**\n+   * Mirror out-of-range coordinates back into the valid coordinate\n+   * range so the image appears as repeated tiles with every other\n+   * tile a reflection.\n+   */\n+  HSA_EXT_SAMPLER_ADDRESSING_MODE_MIRRORED_REPEAT = 4\n+\n+} hsa_ext_sampler_addressing_mode_t;\n+\n+/**\n+ * @brief A fixed-size type used to represent ::hsa_ext_sampler_addressing_mode_t constants.\n+ */\n+typedef uint32_t hsa_ext_sampler_addressing_mode32_t;\n+\n+/**\n+ * @brief Sampler coordinate normalization modes. See the\n+ * <em>Coordinate Normalization Mode</em> section in the <em>HSA\n+ * Programming Reference Manual</em> for definitions on each\n+ * coordinate normalization mode. The values match the BRIG type @p\n+ * hsa_ext_brig_sampler_coord_normalization_t.\n+ */\n+typedef enum {\n+\n+  /**\n+   * Coordinates are used to directly address an image element.\n+   */\n+  HSA_EXT_SAMPLER_COORDINATE_MODE_UNNORMALIZED = 0,\n+\n+  /**\n+   * Coordinates are scaled by the image dimension size before being\n+   * used to address an image element.\n+   */\n+  HSA_EXT_SAMPLER_COORDINATE_MODE_NORMALIZED = 1\n+\n+} hsa_ext_sampler_coordinate_mode_t;\n+\n+/**\n+ * @brief A fixed-size type used to represent ::hsa_ext_sampler_coordinate_mode_t constants.\n+ */\n+typedef uint32_t hsa_ext_sampler_coordinate_mode32_t;\n+    \n+\n+/**\n+ * @brief Sampler filter modes. See the <em>Filter Mode</em> section\n+ * in the <em>HSA Programming Reference Manual</em> for definitions\n+ * on each address mode. The enumeration values match the BRIG type @p\n+ * hsa_ext_brig_sampler_filter_t.\n+ */\n+typedef enum {\n+  /**\n+   * Filter to the image element nearest (in Manhattan distance) to the\n+   * specified coordinate.\n+   */\n+  HSA_EXT_SAMPLER_FILTER_MODE_NEAREST = 0,\n+\n+  /**\n+   * Filter to the image element calculated by combining the elements in a 2x2\n+   * square block or 2x2x2 cube block around the specified coordinate. The\n+   * elements are combined using linear interpolation.\n+   */\n+  HSA_EXT_SAMPLER_FILTER_MODE_LINEAR = 1\n+\n+} hsa_ext_sampler_filter_mode_t;\n+\n+/**\n+ * @brief A fixed-size type used to represent ::hsa_ext_sampler_filter_mode_t constants.\n+ */\n+typedef uint32_t hsa_ext_sampler_filter_mode32_t;\n+\n+/**\n+ * @brief Implementation independent sampler descriptor.\n+ */\n+typedef struct hsa_ext_sampler_descriptor_s {\n+  /**\n+   * Sampler coordinate mode describes the normalization of image coordinates.\n+   */\n+  hsa_ext_sampler_coordinate_mode32_t coordinate_mode;\n+\n+  /**\n+   * Sampler filter type describes the type of sampling performed.\n+   */\n+  hsa_ext_sampler_filter_mode32_t filter_mode;\n+\n+  /**\n+   * Sampler address mode describes the processing of out-of-range image\n+   * coordinates.\n+   */\n+  hsa_ext_sampler_addressing_mode32_t address_mode;\n+\n+} hsa_ext_sampler_descriptor_t;\n+\n+/**\n+ * @brief Create an agent specific sampler handle for a given agent\n+ * independent sampler descriptor and agent.\n+ *\n+ * @param[in] agent Agent to be associated with the sampler handle created.\n+ *\n+ * @param[in] sampler_descriptor Pointer to a sampler descriptor. Must not be\n+ * NULL.\n+ *\n+ * @param[out] sampler Memory location where the HSA runtime stores the newly\n+ * created sampler handle. Must not be NULL.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n+ *\n+ * @retval ::HSA_EXT_STATUS_ERROR_SAMPLER_DESCRIPTOR_UNSUPPORTED The\n+ * @p agent does not have the capability to support the properties\n+ * specified by @p sampler_descriptor or it is invalid.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_OUT_OF_RESOURCES The HSA runtime failed to allocate\n+ * the required resources.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_ARGUMENT @p sampler_descriptor is NULL, or\n+ * @p sampler is NULL.\n+ */\n+hsa_status_t HSA_API hsa_ext_sampler_create(\n+    hsa_agent_t agent,\n+    const hsa_ext_sampler_descriptor_t *sampler_descriptor,\n+    hsa_ext_sampler_t *sampler);\n+\n+/**\n+ * @brief Destroy a sampler handle previously created using ::hsa_ext_sampler_create.\n+ *\n+ * @details The sampler handle should not be destroyed while there are\n+ * references to it queued for execution or currently being used in a\n+ * kernel dispatch.\n+ *\n+ * @param[in] agent Agent associated with the sampler handle.\n+ *\n+ * @param[in] sampler Sampler handle to destroy.\n+ *\n+ * @retval ::HSA_STATUS_SUCCESS The function has been executed successfully.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_NOT_INITIALIZED The HSA runtime has not been\n+ * initialized.\n+ *\n+ * @retval ::HSA_STATUS_ERROR_INVALID_AGENT The agent is invalid.\n+ */\n+hsa_status_t HSA_API hsa_ext_sampler_destroy(\n+    hsa_agent_t agent,\n+    hsa_ext_sampler_t sampler);\n+\n+\n+#define hsa_ext_images_1_00\n+\n+/**\n+ * @brief The function pointer table for the images v1.00 extension. Can be returned by ::hsa_system_get_extension_table or ::hsa_system_get_major_extension_table.\n+ */\n+typedef struct hsa_ext_images_1_00_pfn_s {\n+\n+  hsa_status_t (*hsa_ext_image_get_capability)(\n+    hsa_agent_t agent,\n+    hsa_ext_image_geometry_t geometry,\n+    const hsa_ext_image_format_t *image_format,\n+    uint32_t *capability_mask);\n+\n+  hsa_status_t (*hsa_ext_image_data_get_info)(\n+    hsa_agent_t agent,\n+    const hsa_ext_image_descriptor_t *image_descriptor,\n+    hsa_access_permission_t access_permission,\n+    hsa_ext_image_data_info_t *image_data_info);\n+\n+  hsa_status_t (*hsa_ext_image_create)(\n+    hsa_agent_t agent,\n+    const hsa_ext_image_descriptor_t *image_descriptor,\n+    const void *image_data,\n+    hsa_access_permission_t access_permission,\n+    hsa_ext_image_t *image);\n+\n+  hsa_status_t (*hsa_ext_image_destroy)(\n+    hsa_agent_t agent,\n+    hsa_ext_image_t image);\n+\n+  hsa_status_t (*hsa_ext_image_copy)(\n+    hsa_agent_t agent,\n+    hsa_ext_image_t src_image,\n+    const hsa_dim3_t* src_offset,\n+    hsa_ext_image_t dst_image,\n+    const hsa_dim3_t* dst_offset,\n+    const hsa_dim3_t* range);\n+\n+  hsa_status_t (*hsa_ext_image_import)(\n+    hsa_agent_t agent,\n+    const void *src_memory,\n+    size_t src_row_pitch,\n+    size_t src_slice_pitch,\n+    hsa_ext_image_t dst_image,\n+    const hsa_ext_image_region_t *image_region);\n+\n+  hsa_status_t (*hsa_ext_image_export)(\n+    hsa_agent_t agent,\n+    hsa_ext_image_t src_image,\n+    void *dst_memory,\n+    size_t dst_row_pitch,\n+    size_t dst_slice_pitch,\n+    const hsa_ext_image_region_t *image_region);\n+\n+  hsa_status_t (*hsa_ext_image_clear)(\n+    hsa_agent_t agent,\n+    hsa_ext_image_t image,\n+    const void* data,\n+    const hsa_ext_image_region_t *image_region);\n+\n+  hsa_status_t (*hsa_ext_sampler_create)(\n+    hsa_agent_t agent,\n+    const hsa_ext_sampler_descriptor_t *sampler_descriptor,\n+    hsa_ext_sampler_t *sampler);\n+\n+  hsa_status_t (*hsa_ext_sampler_destroy)(\n+    hsa_agent_t agent,\n+    hsa_ext_sampler_t sampler);\n+\n+} hsa_ext_images_1_00_pfn_t;\n+\n+#define hsa_ext_images_1\n+\n+/**\n+ * @brief The function pointer table for the images v1 extension. Can be returned by ::hsa_system_get_extension_table or ::hsa_system_get_major_extension_table.\n+ */\n+typedef struct hsa_ext_images_1_pfn_s {\n+\n+  hsa_status_t (*hsa_ext_image_get_capability)(\n+    hsa_agent_t agent,\n+    hsa_ext_image_geometry_t geometry,\n+    const hsa_ext_image_format_t *image_format,\n+    uint32_t *capability_mask);\n+\n+  hsa_status_t (*hsa_ext_image_data_get_info)(\n+    hsa_agent_t agent,\n+    const hsa_ext_image_descriptor_t *image_descriptor,\n+    hsa_access_permission_t access_permission,\n+    hsa_ext_image_data_info_t *image_data_info);\n+\n+  hsa_status_t (*hsa_ext_image_create)(\n+    hsa_agent_t agent,\n+    const hsa_ext_image_descriptor_t *image_descriptor,\n+    const void *image_data,\n+    hsa_access_permission_t access_permission,\n+    hsa_ext_image_t *image);\n+\n+  hsa_status_t (*hsa_ext_image_destroy)(\n+    hsa_agent_t agent,\n+    hsa_ext_image_t image);\n+\n+  hsa_status_t (*hsa_ext_image_copy)(\n+    hsa_agent_t agent,\n+    hsa_ext_image_t src_image,\n+    const hsa_dim3_t* src_offset,\n+    hsa_ext_image_t dst_image,\n+    const hsa_dim3_t* dst_offset,\n+    const hsa_dim3_t* range);\n+\n+  hsa_status_t (*hsa_ext_image_import)(\n+    hsa_agent_t agent,\n+    const void *src_memory,\n+    size_t src_row_pitch,\n+    size_t src_slice_pitch,\n+    hsa_ext_image_t dst_image,\n+    const hsa_ext_image_region_t *image_region);\n+\n+  hsa_status_t (*hsa_ext_image_export)(\n+    hsa_agent_t agent,\n+    hsa_ext_image_t src_image,\n+    void *dst_memory,\n+    size_t dst_row_pitch,\n+    size_t dst_slice_pitch,\n+    const hsa_ext_image_region_t *image_region);\n+\n+  hsa_status_t (*hsa_ext_image_clear)(\n+    hsa_agent_t agent,\n+    hsa_ext_image_t image,\n+    const void* data,\n+    const hsa_ext_image_region_t *image_region);\n+\n+  hsa_status_t (*hsa_ext_sampler_create)(\n+    hsa_agent_t agent,\n+    const hsa_ext_sampler_descriptor_t *sampler_descriptor,\n+    hsa_ext_sampler_t *sampler);\n+\n+  hsa_status_t (*hsa_ext_sampler_destroy)(\n+    hsa_agent_t agent,\n+    hsa_ext_sampler_t sampler);\n+\n+  hsa_status_t (*hsa_ext_image_get_capability_with_layout)(\n+    hsa_agent_t agent,\n+    hsa_ext_image_geometry_t geometry,\n+    const hsa_ext_image_format_t *image_format,\n+    hsa_ext_image_data_layout_t image_data_layout,\n+    uint32_t *capability_mask);\n+\n+  hsa_status_t (*hsa_ext_image_data_get_info_with_layout)(\n+    hsa_agent_t agent,\n+    const hsa_ext_image_descriptor_t *image_descriptor,\n+    hsa_access_permission_t access_permission,\n+    hsa_ext_image_data_layout_t image_data_layout,\n+    size_t image_data_row_pitch,\n+    size_t image_data_slice_pitch,\n+    hsa_ext_image_data_info_t *image_data_info);\n+\n+  hsa_status_t (*hsa_ext_image_create_with_layout)(\n+    hsa_agent_t agent,\n+    const hsa_ext_image_descriptor_t *image_descriptor,\n+    const void *image_data,\n+    hsa_access_permission_t access_permission,\n+    hsa_ext_image_data_layout_t image_data_layout,\n+    size_t image_data_row_pitch,\n+    size_t image_data_slice_pitch,\n+    hsa_ext_image_t *image);\n+\n+} hsa_ext_images_1_pfn_t;\n+/** @} */\n+    \n+#ifdef __cplusplus\n+}  // end extern \"C\" block\n+#endif /*__cplusplus*/ \n+\n+#endif"}, {"sha": "e53c6def9724db078d8f0153066603ce9f23fa22", "filename": "libgomp/plugin/plugin-gcn.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f0a4d98229203181014fb84a1e4f74813aab9e/libgomp%2Fplugin%2Fplugin-gcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f0a4d98229203181014fb84a1e4f74813aab9e/libgomp%2Fplugin%2Fplugin-gcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-gcn.c?ref=85f0a4d98229203181014fb84a1e4f74813aab9e", "patch": "@@ -37,6 +37,7 @@\n #include <stdbool.h>\n #include <limits.h>\n #include <hsa.h>\n+#include <hsa_ext_amd.h>\n #include <dlfcn.h>\n #include <signal.h>\n #include \"libgomp-plugin.h\"\n@@ -46,11 +47,6 @@\n #include \"oacc-int.h\"\n #include <assert.h>\n \n-/* Additional definitions not in HSA 1.1.\n-   FIXME: this needs to be updated in hsa.h for upstream, but the only source\n-          right now is the ROCr source which may cause license issues.  */\n-#define HSA_AMD_AGENT_INFO_COMPUTE_UNIT_COUNT 0xA002\n-\n /* These probably won't be in elf.h for a while.  */\n #ifndef R_AMDGPU_NONE\n #define R_AMDGPU_NONE\t\t0"}]}