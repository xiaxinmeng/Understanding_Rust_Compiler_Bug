{"sha": "7462a71535a4cb6768099b77057ff7558dc303eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ2MmE3MTUzNWE0Y2I2NzY4MDk5Yjc3MDU3ZmY3NTU4ZGMzMDNlYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2008-08-09T18:21:50Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2008-08-09T18:21:50Z"}, "message": "mips.c (mips_unspec_address_offset): Move earlier in file.\n\ngcc/\n\t* config/mips/mips.c (mips_unspec_address_offset): Move earlier in file.\n\t(mips_unspec_address, mips_unspec_offset_high): Likewise.\n\t(mips_ok_for_lazy_binding_p, mips_load_call_address): Likewise.\n\t(mips16_cfun_returns_in_fpr_p): Likewise.\n\nFrom-SVN: r138911", "tree": {"sha": "8a821f104451c851f75d2f4aa6adf5eb46eea58d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a821f104451c851f75d2f4aa6adf5eb46eea58d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7462a71535a4cb6768099b77057ff7558dc303eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7462a71535a4cb6768099b77057ff7558dc303eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7462a71535a4cb6768099b77057ff7558dc303eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7462a71535a4cb6768099b77057ff7558dc303eb/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "579725054c9c297a856c1a24224829ce0fb602c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/579725054c9c297a856c1a24224829ce0fb602c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/579725054c9c297a856c1a24224829ce0fb602c7"}], "stats": {"total": 209, "additions": 108, "deletions": 101}, "files": [{"sha": "513e54d05b5d10e1a53a39f3b982e9425bf67c45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7462a71535a4cb6768099b77057ff7558dc303eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7462a71535a4cb6768099b77057ff7558dc303eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7462a71535a4cb6768099b77057ff7558dc303eb", "patch": "@@ -1,3 +1,10 @@\n+2008-08-09  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* config/mips/mips.c (mips_unspec_address_offset): Move earlier in file.\n+\t(mips_unspec_address, mips_unspec_offset_high): Likewise.\n+\t(mips_ok_for_lazy_binding_p, mips_load_call_address): Likewise.\n+\t(mips16_cfun_returns_in_fpr_p): Likewise.\n+\n 2008-08-09  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* config/mips/mips.h (MASK_RETURN_ADDR): Expand commentary."}, {"sha": "d8336bbfa9e088f2b198b66d5c51741ed5015857", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 101, "deletions": 101, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7462a71535a4cb6768099b77057ff7558dc303eb/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7462a71535a4cb6768099b77057ff7558dc303eb/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=7462a71535a4cb6768099b77057ff7558dc303eb", "patch": "@@ -2261,6 +2261,51 @@ mips_emit_call_insn (rtx pattern, bool lazy_p)\n   return insn;\n }\n \f\n+/* Wrap symbol or label BASE in an UNSPEC address of type SYMBOL_TYPE,\n+   then add CONST_INT OFFSET to the result.  */\n+\n+static rtx\n+mips_unspec_address_offset (rtx base, rtx offset,\n+\t\t\t    enum mips_symbol_type symbol_type)\n+{\n+  base = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, base),\n+\t\t\t UNSPEC_ADDRESS_FIRST + symbol_type);\n+  if (offset != const0_rtx)\n+    base = gen_rtx_PLUS (Pmode, base, offset);\n+  return gen_rtx_CONST (Pmode, base);\n+}\n+\n+/* Return an UNSPEC address with underlying address ADDRESS and symbol\n+   type SYMBOL_TYPE.  */\n+\n+rtx\n+mips_unspec_address (rtx address, enum mips_symbol_type symbol_type)\n+{\n+  rtx base, offset;\n+\n+  split_const (address, &base, &offset);\n+  return mips_unspec_address_offset (base, offset, symbol_type);\n+}\n+\n+/* If mips_unspec_address (ADDR, SYMBOL_TYPE) is a 32-bit value, add the\n+   high part to BASE and return the result.  Just return BASE otherwise.\n+   TEMP is as for mips_force_temporary.\n+\n+   The returned expression can be used as the first operand to a LO_SUM.  */\n+\n+static rtx\n+mips_unspec_offset_high (rtx temp, rtx base, rtx addr,\n+\t\t\t enum mips_symbol_type symbol_type)\n+{\n+  if (mips_split_p[symbol_type])\n+    {\n+      addr = gen_rtx_HIGH (Pmode, mips_unspec_address (addr, symbol_type));\n+      addr = mips_force_temporary (temp, addr);\n+      base = mips_force_temporary (temp, gen_rtx_PLUS (Pmode, addr, base));\n+    }\n+  return base;\n+}\n+\f\n /* Return an instruction that copies $gp into register REG.  We want\n    GCC to treat the register's value as constant, so that its value\n    can be rematerialized on demand.  */\n@@ -2358,51 +2403,6 @@ mips_split_symbol (rtx temp, rtx addr, enum machine_mode mode, rtx *lo_sum_out)\n   return true;\n }\n \n-/* Wrap symbol or label BASE in an UNSPEC address of type SYMBOL_TYPE,\n-   then add CONST_INT OFFSET to the result.  */\n-\n-static rtx\n-mips_unspec_address_offset (rtx base, rtx offset,\n-\t\t\t    enum mips_symbol_type symbol_type)\n-{\n-  base = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, base),\n-\t\t\t UNSPEC_ADDRESS_FIRST + symbol_type);\n-  if (offset != const0_rtx)\n-    base = gen_rtx_PLUS (Pmode, base, offset);\n-  return gen_rtx_CONST (Pmode, base);\n-}\n-\n-/* Return an UNSPEC address with underlying address ADDRESS and symbol\n-   type SYMBOL_TYPE.  */\n-\n-rtx\n-mips_unspec_address (rtx address, enum mips_symbol_type symbol_type)\n-{\n-  rtx base, offset;\n-\n-  split_const (address, &base, &offset);\n-  return mips_unspec_address_offset (base, offset, symbol_type);\n-}\n-\n-/* If mips_unspec_address (ADDR, SYMBOL_TYPE) is a 32-bit value, add the\n-   high part to BASE and return the result.  Just return BASE otherwise.\n-   TEMP is as for mips_force_temporary.\n-\n-   The returned expression can be used as the first operand to a LO_SUM.  */\n-\n-static rtx\n-mips_unspec_offset_high (rtx temp, rtx base, rtx addr,\n-\t\t\t enum mips_symbol_type symbol_type)\n-{\n-  if (mips_split_p[symbol_type])\n-    {\n-      addr = gen_rtx_HIGH (Pmode, mips_unspec_address (addr, symbol_type));\n-      addr = mips_force_temporary (temp, addr);\n-      base = mips_force_temporary (temp, gen_rtx_PLUS (Pmode, addr, base));\n-    }\n-  return base;\n-}\n-\n /* Return a legitimate address for REG + OFFSET.  TEMP is as for\n    mips_force_temporary; it is only needed when OFFSET is not a\n    SMALL_OPERAND.  */\n@@ -5208,6 +5208,49 @@ mips_end_function_definition (const char *name)\n     }\n }\n \f\n+/* Return true if calls to X can use R_MIPS_CALL* relocations.  */\n+\n+static bool\n+mips_ok_for_lazy_binding_p (rtx x)\n+{\n+  return (TARGET_USE_GOT\n+\t  && GET_CODE (x) == SYMBOL_REF\n+\t  && !mips_symbol_binds_local_p (x));\n+}\n+\n+/* Load function address ADDR into register DEST.  SIBCALL_P is true\n+   if the address is needed for a sibling call.  Return true if we\n+   used an explicit lazy-binding sequence.  */\n+\n+static bool\n+mips_load_call_address (rtx dest, rtx addr, bool sibcall_p)\n+{\n+  /* If we're generating PIC, and this call is to a global function,\n+     try to allow its address to be resolved lazily.  This isn't\n+     possible for sibcalls when $gp is call-saved because the value\n+     of $gp on entry to the stub would be our caller's gp, not ours.  */\n+  if (TARGET_EXPLICIT_RELOCS\n+      && !(sibcall_p && TARGET_CALL_SAVED_GP)\n+      && mips_ok_for_lazy_binding_p (addr))\n+    {\n+      rtx high, lo_sum_symbol;\n+\n+      high = mips_unspec_offset_high (dest, pic_offset_table_rtx,\n+\t\t\t\t      addr, SYMBOL_GOTOFF_CALL);\n+      lo_sum_symbol = mips_unspec_address (addr, SYMBOL_GOTOFF_CALL);\n+      if (Pmode == SImode)\n+\temit_insn (gen_load_callsi (dest, high, lo_sum_symbol));\n+      else\n+\temit_insn (gen_load_calldi (dest, high, lo_sum_symbol));\n+      return true;\n+    }\n+  else\n+    {\n+      mips_emit_move (dest, addr);\n+      return false;\n+    }\n+}\n+\f\n /* A chained list of functions for which mips16_build_call_stub has already\n    generated a stub.  NAME is the name of the function and FP_RET_P is true\n    if the function returns a value in floating-point registers.  */\n@@ -5668,49 +5711,6 @@ mips16_build_call_stub (rtx retval, rtx fn, rtx args_size, int fp_code)\n   return insn;\n }\n \f\n-/* Return true if calls to X can use R_MIPS_CALL* relocations.  */\n-\n-static bool\n-mips_ok_for_lazy_binding_p (rtx x)\n-{\n-  return (TARGET_USE_GOT\n-\t  && GET_CODE (x) == SYMBOL_REF\n-\t  && !mips_symbol_binds_local_p (x));\n-}\n-\n-/* Load function address ADDR into register DEST.  SIBCALL_P is true\n-   if the address is needed for a sibling call.  Return true if we\n-   used an explicit lazy-binding sequence.  */\n-\n-static bool\n-mips_load_call_address (rtx dest, rtx addr, bool sibcall_p)\n-{\n-  /* If we're generating PIC, and this call is to a global function,\n-     try to allow its address to be resolved lazily.  This isn't\n-     possible for sibcalls when $gp is call-saved because the value\n-     of $gp on entry to the stub would be our caller's gp, not ours.  */\n-  if (TARGET_EXPLICIT_RELOCS\n-      && !(sibcall_p && TARGET_CALL_SAVED_GP)\n-      && mips_ok_for_lazy_binding_p (addr))\n-    {\n-      rtx high, lo_sum_symbol;\n-\n-      high = mips_unspec_offset_high (dest, pic_offset_table_rtx,\n-\t\t\t\t      addr, SYMBOL_GOTOFF_CALL);\n-      lo_sum_symbol = mips_unspec_address (addr, SYMBOL_GOTOFF_CALL);\n-      if (Pmode == SImode)\n-\temit_insn (gen_load_callsi (dest, high, lo_sum_symbol));\n-      else\n-\temit_insn (gen_load_calldi (dest, high, lo_sum_symbol));\n-      return true;\n-    }\n-  else\n-    {\n-      mips_emit_move (dest, addr);\n-      return false;\n-    }\n-}\n-\n /* Expand a \"call\", \"sibcall\", \"call_value\" or \"sibcall_value\" instruction.\n    RESULT is where the result will go (null for \"call\"s and \"sibcall\"s),\n    ADDR is the address of the function, ARGS_SIZE is the size of the\n@@ -7884,6 +7884,19 @@ mips_function_has_gp_insn (void)\n   return cfun->machine->has_gp_insn_p;\n }\n \n+/* Return true if the current function returns its value in a floating-point\n+   register in MIPS16 mode.  */\n+\n+static bool\n+mips16_cfun_returns_in_fpr_p (void)\n+{\n+  tree return_type = DECL_RESULT (current_function_decl);\n+  return (TARGET_MIPS16\n+\t  && TARGET_HARD_FLOAT_ABI\n+\t  && !aggregate_value_p (return_type, current_function_decl)\n+ \t  && mips_return_mode_in_fpr_p (DECL_MODE (return_type)));\n+}\n+\n /* Return the register that should be used as the global pointer\n    within this function.  Return 0 if the function doesn't need\n    a global pointer.  */\n@@ -7942,19 +7955,6 @@ mips_global_pointer (void)\n   return GLOBAL_POINTER_REGNUM;\n }\n \n-/* Return true if the current function returns its value in a floating-point\n-   register in MIPS16 mode.  */\n-\n-static bool\n-mips16_cfun_returns_in_fpr_p (void)\n-{\n-  tree return_type = DECL_RESULT (current_function_decl);\n-  return (TARGET_MIPS16\n-\t  && TARGET_HARD_FLOAT_ABI\n-\t  && !aggregate_value_p (return_type, current_function_decl)\n- \t  && mips_return_mode_in_fpr_p (DECL_MODE (return_type)));\n-}\n-\n /* Return true if the current function must save register REGNO.  */\n \n static bool"}]}