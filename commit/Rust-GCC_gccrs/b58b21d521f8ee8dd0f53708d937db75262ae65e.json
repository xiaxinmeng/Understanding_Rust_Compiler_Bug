{"sha": "b58b21d521f8ee8dd0f53708d937db75262ae65e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU4YjIxZDUyMWY4ZWU4ZGQwZjUzNzA4ZDkzN2RiNzUyNjJhZTY1ZQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-12-02T01:39:20Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-12-02T01:39:20Z"}, "message": "re PR rtl-optimization/12322 (Significant slowdown when compiling computed-goto code in Parrot)\n\n\n\tPR optimization/12322\n\t* gcse.c (struct ls_expr): Change type of hash_index from int to\n\tunsigned int.\n\t(hash_expr): Document hash_table_size parameter and wrap long line.\n\t(ldst_entry): Calculate expression's hash_index and record in ptr.\n\t(trim_ld_motion_mems): Use hash_index to search a single bucket\n\tinstead of scanning the entire hash_table.  Remove the \"del\" local\n\tvariable and use the equivalent \"expr == 0\" instead.  Change last\n\tto be a pointer to the pointer to the current element, to simplify\n\tand speed-up deleting from a linked list.\n\nFrom-SVN: r74144", "tree": {"sha": "9af4e807352e25d03e2723102e67712a53d561d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9af4e807352e25d03e2723102e67712a53d561d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b58b21d521f8ee8dd0f53708d937db75262ae65e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b58b21d521f8ee8dd0f53708d937db75262ae65e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b58b21d521f8ee8dd0f53708d937db75262ae65e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b58b21d521f8ee8dd0f53708d937db75262ae65e/comments", "author": null, "committer": null, "parents": [{"sha": "98376d4a7e314f36ec28ad7fae40d0e23cd77a7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98376d4a7e314f36ec28ad7fae40d0e23cd77a7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98376d4a7e314f36ec28ad7fae40d0e23cd77a7f"}], "stats": {"total": 113, "additions": 57, "deletions": 56}, "files": [{"sha": "3f755a6619041a0fbd6a173c27218ecf4488ed45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58b21d521f8ee8dd0f53708d937db75262ae65e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58b21d521f8ee8dd0f53708d937db75262ae65e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b58b21d521f8ee8dd0f53708d937db75262ae65e", "patch": "@@ -1,3 +1,16 @@\n+2003-12-01  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR optimization/12322\n+\t* gcse.c (struct ls_expr): Change type of hash_index from int to\n+\tunsigned int.\n+\t(hash_expr): Document hash_table_size parameter and wrap long line.\n+\t(ldst_entry): Calculate expression's hash_index and record in ptr.\n+\t(trim_ld_motion_mems): Use hash_index to search a single bucket\n+\tinstead of scanning the entire hash_table.  Remove the \"del\" local\n+\tvariable and use the equivalent \"expr == 0\" instead.  Change last\n+\tto be a pointer to the pointer to the current element, to simplify\n+\tand speed-up deleting from a linked list.\n+\n 2003-12-01  James E Wilson  <wilson@specifixinc.com>\n \n \t* doc/c-tree.texi (CONSTRUCTOR): Clarify element order and handling"}, {"sha": "73f293bf24e758fbb47828038cf108b6090e7749", "filename": "gcc/gcse.c", "status": "modified", "additions": 44, "deletions": 56, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b58b21d521f8ee8dd0f53708d937db75262ae65e/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b58b21d521f8ee8dd0f53708d937db75262ae65e/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=b58b21d521f8ee8dd0f53708d937db75262ae65e", "patch": "@@ -468,7 +468,7 @@ struct ls_expr\n   struct ls_expr * next;\t/* Next in the list.  */\n   int invalid;\t\t\t/* Invalid for some reason.  */\n   int index;\t\t\t/* If it maps to a bitmap index.  */\n-  int hash_index;\t\t/* Index when in a hash table.  */\n+  unsigned int hash_index;\t/* Index when in a hash table.  */\n   rtx reaching_reg;\t\t/* Register to use when re-writing.  */\n };\n \n@@ -1513,12 +1513,14 @@ oprs_available_p (rtx x, rtx insn)\n \n    MODE is only used if X is a CONST_INT.  DO_NOT_RECORD_P is a boolean\n    indicating if a volatile operand is found or if the expression contains\n-   something we don't want to insert in the table.\n+   something we don't want to insert in the table.  HASH_TABLE_SIZE is\n+   the current size of the hash table to be probed.\n \n    ??? One might want to merge this with canon_hash.  Later.  */\n \n static unsigned int\n-hash_expr (rtx x, enum machine_mode mode, int *do_not_record_p, int hash_table_size)\n+hash_expr (rtx x, enum machine_mode mode, int *do_not_record_p,\n+\t   int hash_table_size)\n {\n   unsigned int hash;\n \n@@ -6519,28 +6521,29 @@ one_code_hoisting_pass (void)\n static struct ls_expr *\n ldst_entry (rtx x)\n {\n+  int do_not_record_p = 0;\n   struct ls_expr * ptr;\n+  unsigned int hash;\n \n-  for (ptr = first_ls_expr(); ptr != NULL; ptr = next_ls_expr (ptr))\n-    if (expr_equiv_p (ptr->pattern, x))\n-      break;\n+  hash = hash_expr_1 (x, GET_MODE (x), & do_not_record_p);\n \n-  if (!ptr)\n-    {\n-      ptr = xmalloc (sizeof (struct ls_expr));\n+  for (ptr = pre_ldst_mems; ptr != NULL; ptr = ptr->next)\n+    if (ptr->hash_index == hash && expr_equiv_p (ptr->pattern, x))\n+      return ptr;\n \n-      ptr->next         = pre_ldst_mems;\n-      ptr->expr         = NULL;\n-      ptr->pattern      = x;\n-      ptr->pattern_regs\t= NULL_RTX;\n-      ptr->loads        = NULL_RTX;\n-      ptr->stores       = NULL_RTX;\n-      ptr->reaching_reg = NULL_RTX;\n-      ptr->invalid      = 0;\n-      ptr->index        = 0;\n-      ptr->hash_index   = 0;\n-      pre_ldst_mems     = ptr;\n-    }\n+  ptr = xmalloc (sizeof (struct ls_expr));\n+\n+  ptr->next         = pre_ldst_mems;\n+  ptr->expr         = NULL;\n+  ptr->pattern      = x;\n+  ptr->pattern_regs = NULL_RTX;\n+  ptr->loads        = NULL_RTX;\n+  ptr->stores       = NULL_RTX;\n+  ptr->reaching_reg = NULL_RTX;\n+  ptr->invalid      = 0;\n+  ptr->index        = 0;\n+  ptr->hash_index   = hash;\n+  pre_ldst_mems     = ptr;\n \n   return ptr;\n }\n@@ -6800,56 +6803,41 @@ compute_ld_motion_mems (void)\n static void\n trim_ld_motion_mems (void)\n {\n-  struct ls_expr * last = NULL;\n-  struct ls_expr * ptr = first_ls_expr ();\n+  struct ls_expr * * last = & pre_ldst_mems;\n+  struct ls_expr * ptr = pre_ldst_mems;\n \n   while (ptr != NULL)\n     {\n-      int del = ptr->invalid;\n-      struct expr * expr = NULL;\n+      struct expr * expr;\n \n       /* Delete if entry has been made invalid.  */\n-      if (!del)\n+      if (! ptr->invalid)\n \t{\n-\t  unsigned int i;\n-\n-\t  del = 1;\n \t  /* Delete if we cannot find this mem in the expression list.  */\n-\t  for (i = 0; i < expr_hash_table.size && del; i++)\n-\t    {\n-\t      for (expr = expr_hash_table.table[i];\n-\t\t   expr != NULL;\n-\t\t   expr = expr->next_same_hash)\n-\t\tif (expr_equiv_p (expr->expr, ptr->pattern))\n-\t\t  {\n-\t\t    del = 0;\n-\t\t    break;\n-\t\t  }\n-\t    }\n-\t}\n+\t  unsigned int hash = ptr->hash_index % expr_hash_table.size;\n \n-      if (del)\n-\t{\n-\t  if (last != NULL)\n-\t    {\n-\t      last->next = ptr->next;\n-\t      free_ldst_entry (ptr);\n-\t      ptr = last->next;\n-\t    }\n-\t  else\n-\t    {\n-\t      pre_ldst_mems = pre_ldst_mems->next;\n-\t      free_ldst_entry (ptr);\n-\t      ptr = pre_ldst_mems;\n-\t    }\n+\t  for (expr = expr_hash_table.table[hash];\n+\t       expr != NULL;\n+\t       expr = expr->next_same_hash)\n+\t    if (expr_equiv_p (expr->expr, ptr->pattern))\n+\t      break;\n \t}\n       else\n+\texpr = (struct expr *) 0;\n+\n+      if (expr)\n \t{\n \t  /* Set the expression field if we are keeping it.  */\n-\t  last = ptr;\n \t  ptr->expr = expr;\n+\t  last = & ptr->next;\n \t  ptr = ptr->next;\n \t}\n+      else\n+\t{\n+\t  *last = ptr->next;\n+\t  free_ldst_entry (ptr);\n+\t  ptr = * last;\n+\t}\n     }\n \n   /* Show the world what we've found.  */"}]}