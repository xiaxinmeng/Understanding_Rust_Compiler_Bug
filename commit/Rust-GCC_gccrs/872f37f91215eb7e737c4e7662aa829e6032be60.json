{"sha": "872f37f91215eb7e737c4e7662aa829e6032be60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODcyZjM3ZjkxMjE1ZWI3ZTczN2M0ZTc2NjJhYTgyOWU2MDMyYmU2MA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-05-04T14:54:18Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-05-04T14:54:18Z"}, "message": "cp-tree.h (special_function_kind): Add various kinds of destructors.\n\n\t* cp-tree.h (special_function_kind): Add various kinds of\n\tdestructors.\n\t(special_function_p): New function.\n\t* class.c (overrides): Don't let one kind of destructor override\n\tanother.\n\t* decl2.c (mark_used): Use DECL_NON_THUNK_FUNCTION_P when deciding\n\twhether or not to instantiate a template.\n\t* tree.c (special_function_p): Define.\n\nFrom-SVN: r33668", "tree": {"sha": "afa1bd1d9dfc8d268635e08179700f055b9f48cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afa1bd1d9dfc8d268635e08179700f055b9f48cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/872f37f91215eb7e737c4e7662aa829e6032be60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/872f37f91215eb7e737c4e7662aa829e6032be60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/872f37f91215eb7e737c4e7662aa829e6032be60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/872f37f91215eb7e737c4e7662aa829e6032be60/comments", "author": null, "committer": null, "parents": [{"sha": "72b9c7fb371a69f8430e70beb466911694de669b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72b9c7fb371a69f8430e70beb466911694de669b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72b9c7fb371a69f8430e70beb466911694de669b"}], "stats": {"total": 73, "additions": 64, "deletions": 9}, "files": [{"sha": "9ae429e8918236c601da75e68b08dd22dd8e7a8e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/872f37f91215eb7e737c4e7662aa829e6032be60/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/872f37f91215eb7e737c4e7662aa829e6032be60/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=872f37f91215eb7e737c4e7662aa829e6032be60", "patch": "@@ -1,3 +1,14 @@\n+2000-05-04  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (special_function_kind): Add various kinds of\n+\tdestructors.\n+\t(special_function_p): New function.\n+\t* class.c (overrides): Don't let one kind of destructor override\n+\tanother.\n+\t* decl2.c (mark_used): Use DECL_NON_THUNK_FUNCTION_P when deciding\n+\twhether or not to instantiate a template.\n+\t* tree.c (special_function_p): Define.\n+\n 2000-05-03  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.def (THUNK_DECL): Remove."}, {"sha": "f0136b240a35ffb79b61aa79146a7a1cabf32b2b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/872f37f91215eb7e737c4e7662aa829e6032be60/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/872f37f91215eb7e737c4e7662aa829e6032be60/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=872f37f91215eb7e737c4e7662aa829e6032be60", "patch": "@@ -2284,18 +2284,21 @@ static int\n overrides (fndecl, base_fndecl)\n      tree fndecl, base_fndecl;\n {\n-  /* Destructors have special names.  */\n-  if (DECL_DESTRUCTOR_P (base_fndecl) && DECL_DESTRUCTOR_P (fndecl))\n+  /* One destructor overrides another if they are the same kind of\n+     destructor.  */\n+  if (DECL_DESTRUCTOR_P (base_fndecl) && DECL_DESTRUCTOR_P (fndecl)\n+      && special_function_p (base_fndecl) == special_function_p (fndecl))\n     return 1;\n+  /* But a non-destructor never overrides a destructor, nor vice\n+     versa, nor do different kinds of destructors override\n+     one-another.  For example, a complete object destructor does not\n+     override a deleting destructor.  */\n   if (DECL_DESTRUCTOR_P (base_fndecl) || DECL_DESTRUCTOR_P (fndecl))\n     return 0;\n+\n   if (DECL_NAME (fndecl) == DECL_NAME (base_fndecl))\n     {\n       tree types, base_types;\n-#if 0\n-      retypes = TREE_TYPE (TREE_TYPE (fndecl));\n-      base_retypes = TREE_TYPE (TREE_TYPE (base_fndecl));\n-#endif\n       types = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n       base_types = TYPE_ARG_TYPES (TREE_TYPE (base_fndecl));\n       if ((TYPE_QUALS (TREE_TYPE (TREE_VALUE (base_types)))"}, {"sha": "5e2b43308570b17a5ce07da2a06d2c85981178fd", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/872f37f91215eb7e737c4e7662aa829e6032be60/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/872f37f91215eb7e737c4e7662aa829e6032be60/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=872f37f91215eb7e737c4e7662aa829e6032be60", "patch": "@@ -1988,7 +1988,7 @@ struct lang_decl\n    && DECL_NAME (NODE) == base_dtor_identifier)\n \n /* Nonzero if NODE (a FUNCTION_DECL) is a destructor for a complete\n-   object.  */\n+   object that deletes the object after it has been destroyed.  */\n #define DECL_DELETING_DESTRUCTOR_P(NODE)\t\t\\\n   (DECL_DESTRUCTOR_P (NODE) \t\t\t\t\\\n    && DECL_NAME (NODE) == deleting_dtor_identifier)\n@@ -3218,12 +3218,21 @@ typedef enum access_kind {\n   ak_private = 3           /* Accessible, as a `private' thing.  */\n } access_kind;\n \n+/* The various kinds of special functions.  If you add to this list,\n+   you should update special_function_p as well.  */\n typedef enum special_function_kind {\n-  sfk_none,                /* Not a special function.  */\n+  sfk_none = 0,            /* Not a special function.  This enumeral\n+\t\t\t      must have value zero; see\n+\t\t\t      special_function_p.  */\n   sfk_constructor,         /* A constructor.  */\n   sfk_copy_constructor,    /* A copy constructor.  */\n   sfk_assignment_operator, /* An assignment operator.  */\n   sfk_destructor,          /* A destructor.  */\n+  sfk_complete_destructor, /* A destructor for complete objects.  */\n+  sfk_base_destructor,     /* A destructor for base subobjects.  */\n+  sfk_deleting_destructor, /* A destructor for complete objects that\n+\t\t\t      deletes the object after it has been\n+\t\t\t      destroyed.  */\n   sfk_conversion           /* A conversion operator.  */\n } special_function_kind;\n \n@@ -4527,6 +4536,7 @@ extern void remap_save_expr                     PARAMS ((tree *, splay_tree, tre\n #define cp_build_qualified_type(TYPE, QUALS) \\\n   cp_build_qualified_type_real ((TYPE), (QUALS), /*complain=*/1)\n extern tree build_shared_int_cst                PARAMS ((int));\n+extern special_function_kind special_function_p PARAMS ((tree));\n \n /* in typeck.c */\n extern int string_conv_p\t\t\tPARAMS ((tree, tree, int));"}, {"sha": "85bc908dfcce573d31e30499763a237e7bd4b6ce", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/872f37f91215eb7e737c4e7662aa829e6032be60/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/872f37f91215eb7e737c4e7662aa829e6032be60/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=872f37f91215eb7e737c4e7662aa829e6032be60", "patch": "@@ -5243,7 +5243,7 @@ mark_used (decl)\n      template, we now know that we will need to actually do the\n      instantiation. We check that DECL is not an explicit\n      instantiation because that is not checked in instantiate_decl.  */\n-  if ((TREE_CODE (decl) == FUNCTION_DECL || TREE_CODE (decl) == VAR_DECL)\n+  if ((DECL_NON_THUNK_FUNCTION_P (decl) || TREE_CODE (decl) == VAR_DECL)\n       && DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl)\n       && (!DECL_EXPLICIT_INSTANTIATION (decl)\n \t  || (TREE_CODE (decl) == FUNCTION_DECL && DECL_INLINE (decl))))"}, {"sha": "712e40d2001b1bb9a2ff4459cd7e6e1a4f6be474", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/872f37f91215eb7e737c4e7662aa829e6032be60/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/872f37f91215eb7e737c4e7662aa829e6032be60/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=872f37f91215eb7e737c4e7662aa829e6032be60", "patch": "@@ -2413,3 +2413,34 @@ cp_unsave (tp)\n   /* Clean up.  */\n   splay_tree_delete (st);\n }\n+\n+/* Returns the kind of special function that DECL (a FUNCTION_DECL)\n+   is.  Note that this sfk_none is zero, so this function can be used\n+   as a predicate to test whether or not DECL is a special function.  */\n+\n+special_function_kind\n+special_function_p (decl)\n+     tree decl;\n+{\n+  /* Rather than doing all this stuff with magic names, we should\n+     probably have a field of type `special_function_kind' in\n+     DECL_LANG_SPECIFIC.  */\n+  if (DECL_COPY_CONSTRUCTOR_P (decl))\n+    return sfk_copy_constructor;\n+  if (DECL_CONSTRUCTOR_P (decl))\n+    return sfk_constructor;\n+  if (DECL_NAME (decl) == ansi_opname[(int) MODIFY_EXPR])\n+    return sfk_assignment_operator;\n+  if (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (decl))\n+    return sfk_destructor;\n+  if (DECL_COMPLETE_DESTRUCTOR_P (decl))\n+    return sfk_complete_destructor;\n+  if (DECL_BASE_DESTRUCTOR_P (decl))\n+    return sfk_base_destructor;\n+  if (DECL_DELETING_DESTRUCTOR_P (decl))\n+    return sfk_deleting_destructor;\n+  if (DECL_CONV_FN_P (decl))\n+    return sfk_conversion;\n+\n+  return sfk_none;\n+}"}]}