{"sha": "8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ1OWIyMzAxODk5ZWU3Y2MzMmJjZTc5ZDc2NmNlMDYxOGZmYTJmNA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2003-01-14T04:56:56Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-01-14T04:56:56Z"}, "message": "Renames, namespaces for testsuite utilities.\n\n\n2003-01-12  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tRenames, namespaces for testsuite utilities.\n\t* testsuite/testsuite_hooks.h: Put into namespace __gnu_cxx_test.\n\t(gnu_allocator_tracker): Rename to allocation_tracker.\n\t(gnu_new_allocator): Rename to tracker_alloc.\n\t(__set_testsuite_memlimit): Rename to set_memory_limits.\n\t(gnu_assignment_operator): Rename to assignment_operator.\n\t(gnu_destructor): Rename to destructor.\n\t(gnu_copy_tracker): Rename to copy_tracker.\n\t(gnu_char, gnu_int, gnu_long): Rename to pod_char, pod_int, pod_long.\n\t(run_tests_wrapped_locale): New.\n\t(run_tests_wrapped_env): New.\n\t* testsuite/testsuite_hooks.cc: Same.\n\t(class locale_data): Add.\n\t(class enviornment_variable): Add.\n\t(class not_found): Add.\n\t* testsuite/testsuite_allocator.h: Same.\n\t* testsuite/testsuite_allocator.cc: Same.\n\t* testsuite/23_containers/deque_ctor.cc\n\t(test_copy_ctor_exception_safety): Change gnu_allocator_tracker to\n\tallocation_tracker.\n\tChange gnu_new_allocator to tracker_alloc.\n\tChange gnu_counting_struct to counter.\n\tChange gnu_copy_tracker to copy_tracker.\n\tChange gnu_copy_constructor to copy_constructor.\n\tChange gnu_assignment_operator to assignment_operator.\n\tInject.\n\t* testsuite/23_containers/vector_capacity.cc: Same.\n\t* testsuite/23_containers/vector_ctor.cc (test01): Same.\n\t* testsuite/23_containers/list_modifiers.cc: Change\n\tgnu_copy_tracker to copy_tracker.\n\t* testsuite/21_strings/ctor_copy_dtor.cc (main): Change\n\t__set_testsuite_memlimit to set_memory_limits.\n\t* testsuite/21_strings/insert.cc (main): Same.\n\t* testsuite/27_io/filebuf.cc: Change gnu_char to pod_char.\n\t* testsuite/27_io/stringstream.cc: Same.\n\t* testsuite/27_io/stringbuf.cc: Same.\n\t* testsuite/27_io/streambuf.cc: Same.\n\t* testsuite/27_io/ostream.cc: Same.\n\t* testsuite/27_io/istream.cc: Same.\n\t* testsuite/27_io/fstream.cc: Same.\n\t* testsuite/lib/libstdc++-v3-dg.exp\n\t(libstdc++-v3-list-sourcefiles): Additionally handle files two and\n\tthree levels deeper in glob patterns.\n\nFrom-SVN: r61261", "tree": {"sha": "1e8b2a72bf64356353b23acf94b44346988a9d2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e8b2a72bf64356353b23acf94b44346988a9d2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/comments", "author": null, "committer": null, "parents": [{"sha": "fd371a93fb81f1db3af0711b4764742f81930de1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd371a93fb81f1db3af0711b4764742f81930de1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd371a93fb81f1db3af0711b4764742f81930de1"}], "stats": {"total": 1129, "additions": 652, "deletions": 477}, "files": [{"sha": "d67b56e73a77f8fb79105a7c3c238f3e3360a2ea", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -1,3 +1,49 @@\n+2003-01-12  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tRenames, namespaces for testsuite utilities.\t\n+\t* testsuite/testsuite_hooks.h: Put into namespace __gnu_cxx_test.\n+\t(gnu_allocator_tracker): Rename to allocation_tracker.\n+\t(gnu_new_allocator): Rename to tracker_alloc.\n+\t(__set_testsuite_memlimit): Rename to set_memory_limits.\n+\t(gnu_assignment_operator): Rename to assignment_operator.\n+\t(gnu_destructor): Rename to destructor.\n+\t(gnu_copy_tracker): Rename to copy_tracker.\n+\t(gnu_char, gnu_int, gnu_long): Rename to pod_char, pod_int, pod_long.\n+\t(run_tests_wrapped_locale): New.\n+\t(run_tests_wrapped_env): New.\n+\t* testsuite/testsuite_hooks.cc: Same.\n+\t(class locale_data): Add.\n+\t(class enviornment_variable): Add.\n+\t(class not_found): Add.\n+\t* testsuite/testsuite_allocator.h: Same.\n+\t* testsuite/testsuite_allocator.cc: Same.\n+\t* testsuite/23_containers/deque_ctor.cc\n+\t(test_copy_ctor_exception_safety): Change gnu_allocator_tracker to\n+\tallocation_tracker. \n+\tChange gnu_new_allocator to tracker_alloc.\n+\tChange gnu_counting_struct to counter.\n+\tChange gnu_copy_tracker to copy_tracker.\n+\tChange gnu_copy_constructor to copy_constructor.\n+\tChange gnu_assignment_operator to assignment_operator.\t\n+\tInject.\n+\t* testsuite/23_containers/vector_capacity.cc: Same.\n+\t* testsuite/23_containers/vector_ctor.cc (test01): Same.\n+\t* testsuite/23_containers/list_modifiers.cc: Change\n+\tgnu_copy_tracker to copy_tracker.\n+\t* testsuite/21_strings/ctor_copy_dtor.cc (main): Change\n+\t__set_testsuite_memlimit to set_memory_limits.\n+\t* testsuite/21_strings/insert.cc (main): Same.\n+\t* testsuite/27_io/filebuf.cc: Change gnu_char to pod_char.\n+\t* testsuite/27_io/stringstream.cc: Same.\n+\t* testsuite/27_io/stringbuf.cc: Same.\n+\t* testsuite/27_io/streambuf.cc: Same.\n+\t* testsuite/27_io/ostream.cc: Same.\n+\t* testsuite/27_io/istream.cc: Same.\n+\t* testsuite/27_io/fstream.cc: Same.\n+\t* testsuite/lib/libstdc++-v3-dg.exp\n+\t(libstdc++-v3-list-sourcefiles): Additionally handle files two and\n+\tthree levels deeper in glob patterns.\n+\n 2003-01-11  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* docs/doxygen/tables.html:  Finished now."}, {"sha": "28e9d8ef160ace95a2ead1c671a807700156be27", "filename": "libstdc++-v3/testsuite/21_strings/ctor_copy_dtor.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fctor_copy_dtor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fctor_copy_dtor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fctor_copy_dtor.cc?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -1,6 +1,6 @@\n // 1999-06-04 bkoz\n \n-// Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -230,7 +230,7 @@ void test05()\n \n int main()\n { \n-  __set_testsuite_memlimit();\n+  __gnu_cxx_test::set_memory_limits();\n   test01();\n   test02();\n   test03();"}, {"sha": "5e1eda8695911c06150bb0b1b823bb1e4fe0a0b8", "filename": "libstdc++-v3/testsuite/21_strings/insert.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Finsert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Finsert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Finsert.cc?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -1,6 +1,6 @@\n // 1999-06-03 bkoz\n \n-// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -246,7 +246,7 @@ int test02(void)\n \n int main()\n { \n-  __set_testsuite_memlimit();\n+  __gnu_cxx_test::set_memory_limits();\n   test01();\n   test02();\n   return 0;"}, {"sha": "50a813368bb722510909315910e00ceab183de17", "filename": "libstdc++-v3/testsuite/23_containers/deque_ctor.cc", "status": "modified", "additions": 50, "deletions": 42, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque_ctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque_ctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque_ctor.cc?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -1,6 +1,6 @@\n // 2001-12-27 pme\n //\n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -26,7 +26,15 @@\n #include <testsuite_allocator.h>\n #include <testsuite_hooks.h>\n \n-typedef std::deque<gnu_counting_struct>   gdeque;\n+using __gnu_cxx_test::copy_tracker;\n+using __gnu_cxx_test::allocation_tracker;\n+using __gnu_cxx_test::tracker_alloc;\n+using __gnu_cxx_test::copy_constructor;\n+using __gnu_cxx_test::assignment_operator;\n+using __gnu_cxx_test::counter;\n+using __gnu_cxx_test::destructor;\n+\n+typedef std::deque<counter>   gdeque;\n \n bool test = true;\n \n@@ -133,10 +141,10 @@ void\n defaultConstructorCheck()\n {\n   // setup\n-  typedef gnu_copy_tracker  T;\n+  typedef copy_tracker  T;\n   typedef std::deque<T>     X;\n \n-  gnu_copy_tracker::reset();\n+  copy_tracker::reset();\n \n   // run test\n   const X u;\n@@ -171,15 +179,15 @@ void\n copyConstructorCheck()\n {\n   // setup\n-  typedef gnu_copy_tracker  T;\n+  typedef copy_tracker  T;\n   typedef std::deque<T>     X;\n \n   const int copyBaseSize = 17;  // arbitrary\n \n   X a;\n   for (int i = 0; i < copyBaseSize; ++i)\n     a.push_back(i);\n-  gnu_copy_tracker::reset();\n+  copy_tracker::reset();\n \n   // assert preconditions\n   VERIFY(!a.empty());\n@@ -192,7 +200,7 @@ copyConstructorCheck()\n \n   // assert postconditions\n   VERIFY(u == a);\n-  VERIFY(copyBaseSize == gnu_copy_constructor::count());\n+  VERIFY(copyBaseSize == copy_constructor::count());\n \n   // teardown\n }\n@@ -212,20 +220,20 @@ void\n fillConstructorCheck()\n {\n   // setup\n-  typedef gnu_copy_tracker  T;\n+  typedef copy_tracker  T;\n   typedef std::deque<T>   X;\n \n   const X::size_type  n(23);  \n   const X::value_type t(111);\n \n-  gnu_copy_tracker::reset();\n+  copy_tracker::reset();\n \n   // run test\n   X a(n, t);\n \n   // assert postconditions\n   VERIFY(n == a.size());\n-  VERIFY(n == gnu_copy_constructor::count());\n+  VERIFY(n == copy_constructor::count());\n \n   // teardown\n }\n@@ -239,18 +247,18 @@ fillConstructorCheck()\n void\n fillConstructorCheck2()\n {\n-  typedef gnu_copy_tracker  T;\n+  typedef copy_tracker  T;\n   typedef std::deque<T>   X;\n \n   const int f = 23;  \n   const int l = 111;\n \n-  gnu_copy_tracker::reset();\n+  copy_tracker::reset();\n \n   X a(f, l);\n \n   VERIFY(f == a.size());\n-  VERIFY(f == gnu_copy_constructor::count());\n+  VERIFY(f == copy_constructor::count());\n }\n \n \n@@ -265,7 +273,7 @@ void\n rangeConstructorCheckForwardIterator()\n {\n   // setup\n-  typedef gnu_copy_tracker  T;\n+  typedef copy_tracker  T;\n   typedef std::deque<T>   X;\n \n   const X::size_type  n(726); \n@@ -275,14 +283,14 @@ rangeConstructorCheckForwardIterator()\n   X::iterator j = source.end();\n   X::size_type rangeSize = std::distance(i, j);\n \n-  gnu_copy_tracker::reset();\n+  copy_tracker::reset();\n \n   // test\n   X a(i, j);\n \n   // assert postconditions\n   VERIFY(rangeSize == a.size());\n-  VERIFY(gnu_copy_constructor::count() <= rangeSize);\n+  VERIFY(copy_constructor::count() <= rangeSize);\n }\n \n \n@@ -295,41 +303,41 @@ rangeConstructorCheckForwardIterator()\n void\n rangeConstructorCheckInputIterator()\n {\n-  typedef gnu_copy_tracker  T;\n+  typedef copy_tracker  T;\n   typedef std::deque<T>     X;\n \n   std::istringstream ibuf(\"1234567890123456789\");\n   const X::size_type rangeSize = ibuf.str().size();  \n   std::istream_iterator<char>  i(ibuf);\n   std::istream_iterator<char>  j;\n \n-  gnu_copy_tracker::reset();\n+  copy_tracker::reset();\n \n   X a(i, j);\n \n   VERIFY(rangeSize == a.size());\n-  VERIFY(gnu_copy_constructor::count() <= (2 * rangeSize));\n+  VERIFY(copy_constructor::count() <= (2 * rangeSize));\n }\n \n \n // 23.2.1     copy assignment\n void\n copyAssignmentCheck()\n {\n-  typedef gnu_copy_tracker  T;\n+  typedef copy_tracker  T;\n   typedef std::deque<T>     X;\n \n   const X::size_type  n(18);  \n   const X::value_type t(1023);\n   X a(n, t);\n   X r;\n \n-  gnu_copy_tracker::reset();\n+  copy_tracker::reset();\n \n   r = a;\n \n   VERIFY(r == a);\n-  VERIFY(n == gnu_copy_constructor::count());\n+  VERIFY(n == copy_constructor::count());\n }\n \n \n@@ -343,7 +351,7 @@ copyAssignmentCheck()\n void\n fillAssignmentCheck()\n {\n-  typedef gnu_copy_tracker  T;\n+  typedef copy_tracker  T;\n   typedef std::deque<T>   X;\n \n   const X::size_type  starting_size(10);  \n@@ -352,7 +360,7 @@ fillAssignmentCheck()\n   const X::value_type t(111);\n \n   X a(starting_size, starting_value);\n-  gnu_copy_tracker::reset();\n+  copy_tracker::reset();\n \n   // preconditions\n   VERIFY(starting_size == a.size());\n@@ -362,8 +370,8 @@ fillAssignmentCheck()\n \n   // postconditions\n   VERIFY(n == a.size());\n-  VERIFY(n == (gnu_copy_constructor::count() + gnu_assignment_operator::count()));\n-  VERIFY(starting_size == (gnu_destructor::count() + gnu_assignment_operator::count()));\n+  VERIFY(n == (copy_constructor::count() + assignment_operator::count()));\n+  VERIFY(starting_size == (destructor::count() + assignment_operator::count()));\n }\n \n \n@@ -391,7 +399,7 @@ fillAssignmentCheck()\n void\n rangeAssignmentCheck()\n {\n-  typedef gnu_copy_tracker  T;\n+  typedef copy_tracker  T;\n   typedef std::deque<T>   X;\n \n   const X::size_type  source_size(726); \n@@ -407,13 +415,13 @@ rangeAssignmentCheck()\n   X a(starting_size, starting_value);\n   VERIFY(starting_size == a.size());\n \n-  gnu_copy_tracker::reset();\n+  copy_tracker::reset();\n \n   a.assign(i, j);\n \n   VERIFY(source == a);\n-  VERIFY(rangeSize == (gnu_copy_constructor::count() + gnu_assignment_operator::count()));\n-  VERIFY(starting_size == (gnu_destructor::count() + gnu_assignment_operator::count()));\n+  VERIFY(rangeSize == (copy_constructor::count() + assignment_operator::count()));\n+  VERIFY(starting_size == (destructor::count() + assignment_operator::count()));\n }\n \n \n@@ -423,7 +431,7 @@ void\n rangeAssignmentCheckWithException()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n+  typedef copy_tracker T;\n   typedef std::deque<T>    X;\n \n   // test\n@@ -436,7 +444,7 @@ void\n fillAssignmentCheck2()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n+  typedef copy_tracker T;\n   typedef std::deque<T>    X;\n \n   // test\n@@ -449,12 +457,12 @@ void\n test_default_ctor_exception_safety()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n-  typedef std::deque<T, gnu_new_allocator<T> > X;\n+  typedef copy_tracker T;\n+  typedef std::deque<T, tracker_alloc<T> > X;\n \n   T::reset();\n-  gnu_copy_constructor::throw_on(3);\n-  gnu_allocator_tracker::resetCounts();\n+  copy_constructor::throw_on(3);\n+  allocation_tracker::resetCounts();\n \n   // test\n   try\n@@ -467,7 +475,7 @@ test_default_ctor_exception_safety()\n   }\n \n   // assert postconditions\n-  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+  VERIFY(allocation_tracker::allocationTotal() == allocation_tracker::deallocationTotal());\n \n   // teardown\n }\n@@ -477,14 +485,14 @@ void\n test_copy_ctor_exception_safety()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n-  typedef std::deque<T, gnu_new_allocator<T> > X;\n+  typedef copy_tracker T;\n+  typedef std::deque<T, tracker_alloc<T> > X;\n \n-  gnu_allocator_tracker::resetCounts();\n+  allocation_tracker::resetCounts();\n   {\n     X a(7);\n     T::reset();\n-    gnu_copy_constructor::throw_on(3);\n+    copy_constructor::throw_on(3);\n \n \n     // test\n@@ -499,7 +507,7 @@ test_copy_ctor_exception_safety()\n   }\n \n   // assert postconditions\n-  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+  VERIFY(allocation_tracker::allocationTotal() == allocation_tracker::deallocationTotal());\n \n   // teardown\n }"}, {"sha": "213fc41f17ddff9de8ddf13db1c1bc76c5489178", "filename": "libstdc++-v3/testsuite/23_containers/list_modifiers.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist_modifiers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist_modifiers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist_modifiers.cc?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -21,7 +21,7 @@\n #include <list>\n #include <testsuite_hooks.h>\n \n-typedef gnu_copy_tracker  T;\n+typedef __gnu_cxx_test::copy_tracker  T;\n \n bool test = true;\n "}, {"sha": "b6e347de3099450fd63df7641dc59e0c62f84a8e", "filename": "libstdc++-v3/testsuite/23_containers/vector_capacity.cc", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_capacity.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_capacity.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_capacity.cc?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -1,7 +1,7 @@\n // 1999-05-07\n // bkoz \n \n-// Copyright (C) 1999, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -26,6 +26,13 @@\n #include <testsuite_allocator.h>\n #include <testsuite_hooks.h>\n \n+using __gnu_cxx_test::copy_tracker;\n+using __gnu_cxx_test::allocation_tracker;\n+using __gnu_cxx_test::tracker_alloc;\n+using __gnu_cxx_test::copy_constructor;\n+using __gnu_cxx_test::assignment_operator;\n+using __gnu_cxx_test::destructor;\n+ \n template<typename T>\n   struct A { };\n \n@@ -58,7 +65,6 @@ void test01()\n void test02()\n {\n   bool test = true;\n-\n   {\n     std::vector<int>  array;\n     const std::size_t size = array.max_size();\n@@ -104,10 +110,11 @@ void test02()\n void\n test_reserve()\n {\n-  typedef gnu_copy_tracker T;\n-  typedef std::vector<T, gnu_new_allocator<T> > X;\n+  bool test = true;\n+  typedef copy_tracker T;\n+  typedef std::vector<T, tracker_alloc<T> > X;\n \n-  gnu_allocator_tracker::resetCounts();\n+  allocation_tracker::resetCounts();\n   {\n     X a(3);\n     const X::size_type old_size     = a.size();\n@@ -121,29 +128,30 @@ test_reserve()\n     VERIFY(new_capacity <= a.capacity());\n     // [23.2.4.1 (3)]\n     VERIFY(old_size == a.size());\n-    VERIFY(gnu_copy_constructor::count() <= old_size);\n-    VERIFY(gnu_destructor::count() <= old_size);\n+    VERIFY(copy_constructor::count() <= old_size);\n+    VERIFY(destructor::count() <= old_size);\n   }\n   // check for memory leaks\n-  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+  VERIFY(allocation_tracker::allocationTotal() == allocation_tracker::deallocationTotal());\n }\n \n // Verifies that reserve() with reallocation offers the strong\n // exception guarantee.\n void\n test_reserve_exception_guarantee()\n {\n-  typedef gnu_copy_tracker T;\n-  typedef std::vector<T, gnu_new_allocator<T> > X;\n+  bool test = true;\n+  typedef copy_tracker T;\n+  typedef std::vector<T, tracker_alloc<T> > X;\n \n-  gnu_allocator_tracker::resetCounts();\n+  allocation_tracker::resetCounts();\n   {\n     X a(7);\n     const X::size_type old_size     = a.size();\n     const X::size_type old_capacity = a.capacity();\n     const X::size_type new_capacity = old_capacity + 10;\n     T::reset();\n-    gnu_copy_constructor::throw_on(3);\n+    copy_constructor::throw_on(3);\n     \n     try\n     {\n@@ -155,9 +163,9 @@ test_reserve_exception_guarantee()\n     }\n \n     VERIFY(old_capacity == a.capacity());\n-    VERIFY(gnu_copy_constructor::count() == gnu_destructor::count()+1);\n+    VERIFY(copy_constructor::count() == destructor::count()+1);\n   }\n-  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+  VERIFY(allocation_tracker::allocationTotal() == allocation_tracker::deallocationTotal());\n }\n \n int main()"}, {"sha": "8b93207606e13b67600d2169e2fdac2512a83adb", "filename": "libstdc++-v3/testsuite/23_containers/vector_ctor.cc", "status": "modified", "additions": 150, "deletions": 130, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_ctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_ctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_ctor.cc?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -1,6 +1,6 @@\n // 1999-06-29 bkoz\n \n-// Copyright (C) 1999-2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 1999-2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -25,14 +25,19 @@\n #include <testsuite_allocator.h>\n #include <testsuite_hooks.h>\n \n+using __gnu_cxx_test::copy_tracker;\n+using __gnu_cxx_test::allocation_tracker;\n+using __gnu_cxx_test::tracker_alloc;\n+using __gnu_cxx_test::copy_constructor;\n+using __gnu_cxx_test::assignment_operator;\n+ \n template<typename T>\n   struct A { };\n \n struct B { };\n \n void test01()\n {\n-\n   // 1\n   bool test = true;\n   std::vector< A<B> > vec01;\n@@ -62,22 +67,22 @@ void test02()\n void\n test03()\n {\n-    const int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n-    const int B[] = {7, 7, 7, 7, 7};\n-    const int N = sizeof(A) / sizeof(int);\n-    const int M = sizeof(B) / sizeof(int);\n-    bool test = true;\n-\n-    std::vector<int> v3(A, A + N);\n-    VERIFY(std::equal(v3.begin(), v3.end(), A));\n-\n-    std::vector<int> v4(v3.begin(), v3.end());\n-    VERIFY(std::equal(v4.begin(), v4.end(), A));\n-\n-    std::vector<int> v5(M, 7);\n-    VERIFY(std::equal(v5.begin(), v5.end(), B));\n-    VERIFY(std::equal(B, B + M, v5.begin()));\n-\n+  bool test = true;\n+  const int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n+  const int B[] = {7, 7, 7, 7, 7};\n+  const int N = sizeof(A) / sizeof(int);\n+  const int M = sizeof(B) / sizeof(int);\n+  \n+  std::vector<int> v3(A, A + N);\n+  VERIFY(std::equal(v3.begin(), v3.end(), A));\n+  \n+  std::vector<int> v4(v3.begin(), v3.end());\n+  VERIFY(std::equal(v4.begin(), v4.end(), A));\n+  \n+  std::vector<int> v5(M, 7);\n+  VERIFY(std::equal(v5.begin(), v5.end(), B));\n+  VERIFY(std::equal(B, B + M, v5.begin()));\n+  \n #ifdef DEBUG_ASSERT\n   assert(test);\n #endif\n@@ -105,12 +110,13 @@ void\n test_default_ctor_exception_gurantee()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n-  typedef std::vector<T, gnu_new_allocator<T> > X;\n+  bool test = true;\n+  typedef copy_tracker T;\n+  typedef std::vector<T, tracker_alloc<T> > X;\n \n-  gnu_copy_tracker::reset();\n-  gnu_copy_constructor::throw_on(3);\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  copy_constructor::throw_on(3);\n+  allocation_tracker::resetCounts();\n \n   // run test\n   try\n@@ -124,7 +130,7 @@ test_default_ctor_exception_gurantee()\n \n   // assert postconditions\n   VERIFY((\"memory leak detected:\",\n-          gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal()));\n+          allocation_tracker::allocationTotal() == allocation_tracker::deallocationTotal()));\n \n   // teardown\n }\n@@ -137,14 +143,15 @@ void\n test_copy_ctor_exception_gurantee()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n-  typedef std::vector<T, gnu_new_allocator<T> > X;\n+  bool test = true;\n+  typedef copy_tracker T;\n+  typedef std::vector<T, tracker_alloc<T> > X;\n \n-  gnu_allocator_tracker::resetCounts();\n+  allocation_tracker::resetCounts();\n   {\n     X a(7);\n-    gnu_copy_tracker::reset();\n-    gnu_copy_constructor::throw_on(3);\n+    copy_tracker::reset();\n+    copy_constructor::throw_on(3);\n \n     // run test\n     try\n@@ -158,11 +165,11 @@ test_copy_ctor_exception_gurantee()\n   }\n \n   // assert postconditions\n-  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+  VERIFY(allocation_tracker::allocationTotal() == allocation_tracker::deallocationTotal());\n \n   // teardown\n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n }\n \n // operator=()\n@@ -175,13 +182,14 @@ void\n test_assignment_operator_1()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n-  typedef std::vector<T, gnu_new_allocator<T> > X;\n+  bool test = true;\n+  typedef copy_tracker T;\n+  typedef std::vector<T, tracker_alloc<T> > X;\n \n   X r(9);\n   X a(r.size() - 2);\n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n \n   // preconditions\n   VERIFY(r.size() > a.size());\n@@ -191,25 +199,26 @@ test_assignment_operator_1()\n \n   // assert postconditions\n   VERIFY(r == a);\n-  VERIFY(gnu_allocator_tracker::allocationTotal() == 0);\n+  VERIFY(allocation_tracker::allocationTotal() == 0);\n \n   // teardown\n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n }\n \n void\n test_assignment_operator_2()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n-  typedef std::vector<T, gnu_new_allocator<T> > X;\n+  bool test = true;\n+  typedef copy_tracker T;\n+  typedef std::vector<T, tracker_alloc<T> > X;\n \n   X r(1);\n   r.reserve(17);\n   X a(r.size() + 7);\n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n \n   // preconditions\n   VERIFY(r.size() < a.size());\n@@ -220,25 +229,26 @@ test_assignment_operator_2()\n \n   // assert postconditions\n   VERIFY(r == a);\n-  VERIFY(gnu_allocator_tracker::allocationTotal() == 0);\n+  VERIFY(allocation_tracker::allocationTotal() == 0);\n \n   // teardown\n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n }\n \n void\n test_assignment_operator_3()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n-  typedef std::vector<T, gnu_new_allocator<T> > X;\n+  bool test = true;\n+  typedef copy_tracker T;\n+  typedef std::vector<T, tracker_alloc<T> > X;\n \n-  gnu_allocator_tracker::resetCounts();\n+  allocation_tracker::resetCounts();\n   {\n     X r(1);\n     X a(r.capacity() + 7);\n-    gnu_copy_tracker::reset();\n+    copy_tracker::reset();\n \n     // preconditions\n     VERIFY(r.capacity() < a.size());\n@@ -249,26 +259,27 @@ test_assignment_operator_3()\n     // assert postconditions\n     VERIFY(r == a);\n   }\n-  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+  VERIFY(allocation_tracker::allocationTotal() == allocation_tracker::deallocationTotal());\n \n   // teardown\n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n }\n \n void\n test_assignment_operator_3_exception_guarantee()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n-  typedef std::vector<T, gnu_new_allocator<T> > X;\n+  bool test = true;\n+  typedef copy_tracker T;\n+  typedef std::vector<T, tracker_alloc<T> > X;\n \n-  gnu_allocator_tracker::resetCounts();\n+  allocation_tracker::resetCounts();\n   {\n     X r(1);\n     X a(r.capacity() + 7);\n-    gnu_copy_tracker::reset();\n-    gnu_copy_constructor::throw_on(3);\n+    copy_tracker::reset();\n+    copy_constructor::throw_on(3);\n \n     // preconditions\n     VERIFY(r.capacity() < a.size());\n@@ -285,11 +296,11 @@ test_assignment_operator_3_exception_guarantee()\n   }\n \n   // assert postconditions\n-  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+  VERIFY(allocation_tracker::allocationTotal() == allocation_tracker::deallocationTotal());\n \n   // teardown\n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n }\n \n // fill assign()\n@@ -304,35 +315,37 @@ void\n test_fill_assign_1()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n-  typedef std::vector<T, gnu_new_allocator<T> > X;\n+  bool test = true;\n+  typedef copy_tracker T;\n+  typedef std::vector<T, tracker_alloc<T> > X;\n \n   X a(7);\n   X::size_type old_size = a.size();\n   X::size_type new_size = old_size - 2;\n   const T t;\n \n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n \n   // run test\n   a.assign(new_size, t);\n \n   // assert postconditions\n   VERIFY(a.size() == new_size);\n-  VERIFY(gnu_allocator_tracker::allocationTotal() == 0);\n+  VERIFY(allocation_tracker::allocationTotal() == 0);\n \n   // teardown\n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n }\n \n void\n test_fill_assign_2()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n-  typedef std::vector<T, gnu_new_allocator<T> > X;\n+  bool test = true;\n+  typedef copy_tracker T;\n+  typedef std::vector<T, tracker_alloc<T> > X;\n \n   X a(7);\n   a.reserve(11);\n@@ -341,8 +354,8 @@ test_fill_assign_2()\n   X::size_type new_size     = old_size + 2;\n   const T t;\n \n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n \n   // assert preconditions\n   VERIFY(old_size < new_size);\n@@ -353,29 +366,30 @@ test_fill_assign_2()\n \n   // assert postconditions\n   VERIFY(a.size() == new_size);\n-  VERIFY(gnu_allocator_tracker::allocationTotal() == 0);\n+  VERIFY(allocation_tracker::allocationTotal() == 0);\n \n   // teardown\n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n }\n \n void\n test_fill_assign_3()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n-  typedef std::vector<T, gnu_new_allocator<T> > X;\n+  bool test = true;\n+  typedef copy_tracker T;\n+  typedef std::vector<T, tracker_alloc<T> > X;\n \n-  gnu_allocator_tracker::resetCounts();\n+  allocation_tracker::resetCounts();\n   {\n     X a(7);\n     X::size_type old_size     = a.size();\n     X::size_type old_capacity = a.capacity();\n     X::size_type new_size     = old_capacity + 4;\n     const T t;\n \n-    gnu_copy_tracker::reset();\n+    copy_tracker::reset();\n \n     // assert preconditions\n     VERIFY(new_size > old_capacity);\n@@ -387,31 +401,32 @@ test_fill_assign_3()\n     VERIFY(a.size() == new_size);\n   }\n \n-  VERIFY(gnu_allocator_tracker::allocationTotal() > 0);\n-  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+  VERIFY(allocation_tracker::allocationTotal() > 0);\n+  VERIFY(allocation_tracker::allocationTotal() == allocation_tracker::deallocationTotal());\n \n   // teardown\n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n }\n \n void\n test_fill_assign_3_exception_guarantee()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n-  typedef std::vector<T, gnu_new_allocator<T> > X;\n+  bool test = true;\n+  typedef copy_tracker T;\n+  typedef std::vector<T, tracker_alloc<T> > X;\n \n-  gnu_allocator_tracker::resetCounts();\n+  allocation_tracker::resetCounts();\n   {\n     X a(7);\n     X::size_type old_size     = a.size();\n     X::size_type old_capacity = a.capacity();\n     X::size_type new_size     = old_capacity + 4;\n     const T t;\n \n-    gnu_copy_tracker::reset();\n-    gnu_copy_constructor::throw_on(3);\n+    copy_tracker::reset();\n+    copy_constructor::throw_on(3);\n \n     // assert preconditions\n     VERIFY(new_size > old_capacity);\n@@ -431,39 +446,40 @@ test_fill_assign_3_exception_guarantee()\n     VERIFY(a.capacity() == old_capacity);\n   }\n \n-  VERIFY(gnu_allocator_tracker::allocationTotal() > 0);\n-  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+  VERIFY(allocation_tracker::allocationTotal() > 0);\n+  VERIFY(allocation_tracker::allocationTotal() == allocation_tracker::deallocationTotal());\n \n   // teardown\n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n }\n \n void\n test_fill_assign_4()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n-  typedef std::vector<T, gnu_new_allocator<T> > X;\n+  bool test = true;\n+  typedef copy_tracker T;\n+  typedef std::vector<T, tracker_alloc<T> > X;\n \n   X a(7);\n   X::size_type old_size  = a.size();\n   X::size_type new_size  = old_size - 2;\n   X::size_type new_value = 117;\n \n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n \n   // run test\n   a.assign(new_size, new_value);\n \n   // assert postconditions\n   VERIFY(a.size() == new_size);\n-  VERIFY(gnu_allocator_tracker::allocationTotal() == 0);\n+  VERIFY(allocation_tracker::allocationTotal() == 0);\n \n   // teardown\n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n }\n \n // range assign()\n@@ -486,15 +502,16 @@ void\n test_range_assign_2()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n-  typedef std::vector<T, gnu_new_allocator<T> > X;\n+  bool test = true;\n+  typedef copy_tracker T;\n+  typedef std::vector<T, tracker_alloc<T> > X;\n \n   X a(7);\n   X b(3);\n   X::size_type old_size = a.size();\n \n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n \n   // assert preconditions\n   VERIFY(b.size() < a.capacity());\n@@ -505,27 +522,28 @@ test_range_assign_2()\n   // assert postconditions\n   VERIFY(a.size() == b.size());\n   VERIFY(a == b);\n-  VERIFY(gnu_allocator_tracker::allocationTotal() == 0);\n+  VERIFY(allocation_tracker::allocationTotal() == 0);\n \n   // teardown\n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n }\n \n void\n test_range_assign_3()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n-  typedef std::vector<T, gnu_new_allocator<T> > X;\n+  bool test = true;\n+  typedef copy_tracker T;\n+  typedef std::vector<T, tracker_alloc<T> > X;\n \n   X a(7);\n   a.reserve(a.size() + 7);\n   X b(a.size() + 3);\n   X::size_type old_size = a.size();\n \n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n \n   // assert preconditions\n   VERIFY(a.size() < b.size());\n@@ -537,27 +555,28 @@ test_range_assign_3()\n   // assert postconditions\n   VERIFY(a.size() == b.size());\n   VERIFY(a == b);\n-  VERIFY(gnu_allocator_tracker::allocationTotal() == 0);\n+  VERIFY(allocation_tracker::allocationTotal() == 0);\n \n   // teardown\n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n }\n \n void\n test_range_assign_4()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n-  typedef std::vector<T, gnu_new_allocator<T> > X;\n+  bool test = true;\n+  typedef copy_tracker T;\n+  typedef std::vector<T, tracker_alloc<T> > X;\n \n-  gnu_allocator_tracker::resetCounts();\n+  allocation_tracker::resetCounts();\n   {\n     X a(7);\n     X b(a.capacity() + 7);\n     X::size_type old_size = a.size();\n \n-    gnu_copy_tracker::reset();\n+    copy_tracker::reset();\n \n     // assert preconditions\n     VERIFY(b.size() > a.capacity());\n@@ -569,29 +588,30 @@ test_range_assign_4()\n     VERIFY(a.size() == b.size());\n     VERIFY(a == b);\n   }\n-  VERIFY(gnu_allocator_tracker::allocationTotal() > 0);\n-  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+  VERIFY(allocation_tracker::allocationTotal() > 0);\n+  VERIFY(allocation_tracker::allocationTotal() == allocation_tracker::deallocationTotal());\n \n   // teardown\n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n }\n \n void\n test_range_assign_4_exception_guarantee()\n {\n   // setup\n-  typedef gnu_copy_tracker T;\n-  typedef std::vector<T, gnu_new_allocator<T> > X;\n+  bool test = true;\n+  typedef copy_tracker T;\n+  typedef std::vector<T, tracker_alloc<T> > X;\n \n-  gnu_allocator_tracker::resetCounts();\n+  allocation_tracker::resetCounts();\n   {\n     X a(7);\n     X b(a.capacity() + 7);\n     X::size_type old_size = a.size();\n \n-    gnu_copy_tracker::reset();\n-    gnu_copy_constructor::throw_on(3);\n+    copy_tracker::reset();\n+    copy_constructor::throw_on(3);\n \n     // assert preconditions\n     VERIFY(b.size() > a.capacity());\n@@ -608,12 +628,12 @@ test_range_assign_4_exception_guarantee()\n   }\n \n   // assert postconditions\n-  VERIFY(gnu_allocator_tracker::allocationTotal() > 0);\n-  VERIFY(gnu_allocator_tracker::allocationTotal() == gnu_allocator_tracker::deallocationTotal());\n+  VERIFY(allocation_tracker::allocationTotal() > 0);\n+  VERIFY(allocation_tracker::allocationTotal() == allocation_tracker::deallocationTotal());\n \n   // teardown\n-  gnu_copy_tracker::reset();\n-  gnu_allocator_tracker::resetCounts();\n+  copy_tracker::reset();\n+  allocation_tracker::resetCounts();\n }\n \n "}, {"sha": "ab873be82b5fb41b97f54f5e9fe4340cdb1be509", "filename": "libstdc++-v3/testsuite/27_io/filebuf.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf.cc?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -1,6 +1,6 @@\n // 1999-01-17 bkoz test functionality of basic_filebuf for char_type == char\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002 \n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -45,9 +45,10 @@ void test01()\n namespace test \n {\n   using namespace std;\n+  using __gnu_cxx_test::pod_char;\n   typedef short type_t;\n   template class basic_filebuf<type_t, char_traits<type_t> >;\n-  template class basic_filebuf<gnu_char, char_traits<gnu_char> >;\n+  template class basic_filebuf<pod_char, char_traits<pod_char> >;\n } // test\n \n "}, {"sha": "c37be6bbfcb77d17b8dd5f3ef666c22c89c7e175", "filename": "libstdc++-v3/testsuite/27_io/fstream.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffstream.cc?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -1,6 +1,6 @@\n // 2002-07-25 Benjamin Kosnik <bkoz@redhat.com>\n \n-// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -50,9 +50,10 @@ void test01()\n namespace test \n {\n   using namespace std;\n+  using __gnu_cxx_test::pod_char;\n   typedef short type_t;\n   template class basic_fstream<type_t, char_traits<type_t> >;\n-  template class basic_fstream<gnu_char, char_traits<gnu_char> >;\n+  template class basic_fstream<pod_char, char_traits<pod_char> >;\n } // test\n \n int main() "}, {"sha": "c8146ea923660bd9bd7f879e996988e380ec105b", "filename": "libstdc++-v3/testsuite/27_io/istream.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream.cc?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -1,6 +1,6 @@\n // 1999-09-20 bkoz\n \n-// Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -50,9 +50,10 @@ void test01()\n namespace test \n {\n   using namespace std;\n+  using __gnu_cxx_test::pod_char;\n   typedef short type_t;\n   template class basic_istream<type_t, char_traits<type_t> >;\n-  template class basic_istream<gnu_char, char_traits<gnu_char> >;\n+  template class basic_istream<pod_char, char_traits<pod_char> >;\n } // test\n \n int main() "}, {"sha": "7efd65381a3183deacc8bc3e0b98682263936d8c", "filename": "libstdc++-v3/testsuite/27_io/ostream.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostream.cc?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -1,6 +1,6 @@\n // 1999-09-20 bkoz\n \n-// Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -50,9 +50,10 @@ void test01()\n namespace test \n {\n   using namespace std;\n+  using __gnu_cxx_test::pod_char;\n   typedef short type_t;\n   template class basic_ostream<type_t, char_traits<type_t> >;\n-  template class basic_ostream<gnu_char, char_traits<gnu_char> >;\n+  template class basic_ostream<pod_char, char_traits<pod_char> >;\n } // test\n \n int main() "}, {"sha": "29c771b9074646eb781dcc15f844317530e7d6c6", "filename": "libstdc++-v3/testsuite/27_io/streambuf.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstreambuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstreambuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstreambuf.cc?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -1,6 +1,6 @@\n // 2002-07-25 Benjamin Kosnik <bkoz@redhat.com>\n \n-// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -50,9 +50,10 @@ void test01()\n namespace test \n {\n   using namespace std;\n+  using __gnu_cxx_test::pod_char;\n   typedef short type_t;\n   template class basic_streambuf<type_t, char_traits<type_t> >;\n-  template class basic_streambuf<gnu_char, char_traits<gnu_char> >;\n+  template class basic_streambuf<pod_char, char_traits<pod_char> >;\n } // test\n \n int main() "}, {"sha": "a91deab2f1d8f6768c1e41253c44198a0fece7b7", "filename": "libstdc++-v3/testsuite/27_io/stringbuf.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringbuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringbuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringbuf.cc?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -1,6 +1,6 @@\n // 2002-07-25 Benjamin Kosnik <bkoz@redhat.com>\n \n-// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -50,9 +50,10 @@ void test01()\n namespace test \n {\n   using namespace std;\n+  using __gnu_cxx_test::pod_char;\n   typedef short type_t;\n   template class basic_stringbuf<type_t, char_traits<type_t> >;\n-  template class basic_stringbuf<gnu_char, char_traits<gnu_char> >;\n+  template class basic_stringbuf<pod_char, char_traits<pod_char> >;\n } // test\n \n int main() "}, {"sha": "576b72d5282f0a29b9f1cdd32a1d3181935d1d72", "filename": "libstdc++-v3/testsuite/27_io/stringstream.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringstream.cc?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -1,6 +1,6 @@\n // 2002-07-25 Benjamin Kosnik <bkoz@redhat.com>\n \n-// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -50,9 +50,10 @@ void test01()\n namespace test \n {\n   using namespace std;\n+  using __gnu_cxx_test::pod_char;\n   typedef short type_t;\n   template class basic_stringstream<type_t, char_traits<type_t> >;\n-  template class basic_stringstream<gnu_char, char_traits<gnu_char> >;\n+  template class basic_stringstream<pod_char, char_traits<pod_char> >;\n } // test\n \n int main() "}, {"sha": "89cb34942d675aad36818338ff49f13ea1cc7157", "filename": "libstdc++-v3/testsuite/lib/libstdc++-v3-dg.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B-v3-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B-v3-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B-v3-dg.exp?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -233,7 +233,7 @@ proc libstdc++-v3-list-sourcefiles { } {\n \tset f [open $files_file \"w\"]\n \tset where_we_were [pwd]\n \tcd $srcdir\n-\tforeach s [lsort [glob -nocomplain \"{,*/}*/*.cc\"]] {\n+\tforeach s [lsort [glob -nocomplain \"*/*.cc\" \"*/*/*.cc\" \"{,*/}*/*/*/*.cc\" ]] {\n \t    lappend sfiles ${srcdir}/${s}\n \t    puts $f $s\n \t}"}, {"sha": "775b253502666cec71ae2d26e9339e89a3169fe0", "filename": "libstdc++-v3/testsuite/testsuite_allocator.cc", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.cc?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -1,5 +1,7 @@\n+// -*- C++ -*-\n+// Testing allocator for the C++ library testsuite.\n //\n-// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -28,8 +30,11 @@\n \n #include <testsuite_allocator.h>\n \n-gnu_allocator_tracker::size_type gnu_allocator_tracker::allocationTotal_   = 0;\n-gnu_allocator_tracker::size_type gnu_allocator_tracker::deallocationTotal_ = 0;\n-int                              gnu_allocator_tracker::constructCount_    = 0;\n-int                              gnu_allocator_tracker::destructCount_     = 0;\n+namespace __gnu_cxx_test\n+{\n+  allocation_tracker::size_type allocation_tracker::allocationTotal_   = 0;\n+  allocation_tracker::size_type allocation_tracker::deallocationTotal_ = 0;\n+  int allocation_tracker::constructCount_    = 0;\n+  int allocation_tracker::destructCount_     = 0;\n+}; // namespace __cxx_test\n "}, {"sha": "3c77260f5d50420dc709ad3adf0e5c03f8c46e77", "filename": "libstdc++-v3/testsuite/testsuite_allocator.h", "status": "modified", "additions": 73, "deletions": 79, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_allocator.h?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -1,6 +1,7 @@\n+// -*- C++ -*-\n // Testing allocator for the C++ library testsuite.\n //\n-// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -37,71 +38,66 @@\n #include <cstddef>\n #include <limits>\n \n-class gnu_allocator_tracker\n+namespace __gnu_cxx_test\n {\n- public:\n-  typedef std::size_t    size_type; \n-  \n-  static void*\n-  allocate(size_type blocksize)\n+  class allocation_tracker\n   {\n-    allocationTotal_ += blocksize;\n-    return ::operator new(blocksize);\n-  }\n-\n-  static void\n-  construct()\n-  { constructCount_++; }\n-\n-  static void\n-  destroy()\n-  { destructCount_++; }\n-\n-  static void\n-  deallocate(void* p, size_type blocksize)\n-  {\n-    ::operator delete(p);\n-    deallocationTotal_ += blocksize;\n-  }\n-\n-  static size_type\n-  allocationTotal() \n-  { return allocationTotal_; }\n+  public:\n+    typedef std::size_t    size_type; \n+    \n+    static void*\n+    allocate(size_type blocksize)\n+    {\n+      allocationTotal_ += blocksize;\n+      return ::operator new(blocksize);\n+    }\n+    \n+    static void\n+    construct() { constructCount_++; }\n \n-  static size_type\n-  deallocationTotal()\n-  { return deallocationTotal_; }\n+    static void\n+    destroy() { destructCount_++; }\n \n-  static int\n-  constructCount() \n-  { return constructCount_; }\n+    static void\n+    deallocate(void* p, size_type blocksize)\n+    {\n+      ::operator delete(p);\n+      deallocationTotal_ += blocksize;\n+    }\n+    \n+    static size_type\n+    allocationTotal() { return allocationTotal_; }\n+    \n+    static size_type\n+    deallocationTotal() { return deallocationTotal_; }\n+    \n+    static int\n+    constructCount() { return constructCount_; }\n \n-  static int\n-  destructCount() \n-  { return destructCount_; }\n+    static int\n+    destructCount() { return destructCount_; }\n     \n-  static void\n-  resetCounts()\n-  {\n-    allocationTotal_ = 0;\n-    deallocationTotal_ = 0;\n-    constructCount_ = 0;\n+    static void\n+    resetCounts()\n+    {\n+      allocationTotal_ = 0;\n+      deallocationTotal_ = 0;\n+      constructCount_ = 0;\n     destructCount_ = 0;\n-  }\n+    }\n \n  private:\n-  static size_type  allocationTotal_;\n-  static size_type  deallocationTotal_;\n-  static int        constructCount_;\n-  static int        destructCount_;\n-};\n-\n-// A simple basic allocator that just forwards to the\n-// gnu_allocator_tracker to fulfill memory requests.  This class is\n-// templated on the target object type, but gnu_allocator_tracker\n-// isn't.\n-template<class T>\n-  class gnu_new_allocator\n+    static size_type  allocationTotal_;\n+    static size_type  deallocationTotal_;\n+    static int        constructCount_;\n+    static int        destructCount_;\n+  };\n+\n+  // A simple basic allocator that just forwards to the\n+  // allocation_tracker to fulfill memory requests.  This class is\n+  // templated on the target object type, but tracker isn't.\n+  template<class T>\n+  class tracker_alloc\n   {\n   public:\n     typedef T              value_type;\n@@ -112,7 +108,7 @@ template<class T>\n     typedef std::size_t    size_type; \n     typedef std::ptrdiff_t difference_type; \n     \n-    template<class U> struct rebind { typedef gnu_new_allocator<U> other; };\n+    template<class U> struct rebind { typedef tracker_alloc<U> other; };\n     \n     pointer\n     address(reference value) const\n@@ -122,60 +118,58 @@ template<class T>\n     address(const_reference value) const\n     { return &value; }\n     \n-    gnu_new_allocator() throw()\n+    tracker_alloc() throw()\n     { }\n \n-    gnu_new_allocator(const gnu_new_allocator&) throw()\n+    tracker_alloc(const tracker_alloc&) throw()\n     { }\n \n     template<class U>\n-      gnu_new_allocator(const gnu_new_allocator<U>&) throw()\n+      tracker_alloc(const tracker_alloc<U>&) throw()\n       { }\n \n-    ~gnu_new_allocator() throw()\n+    ~tracker_alloc() throw()\n     { }\n \n     size_type\n     max_size() const throw()\n     { return std::numeric_limits<std::size_t>::max() / sizeof(T); }\n \n     pointer\n-    allocate(size_type num, const void* = 0)\n+    allocate(size_type n, const void* = 0)\n     { \n-      return static_cast<pointer>(gnu_allocator_tracker::allocate(num * \n-\t\t\t\t\t\t\t\t  sizeof(T))); \n+      return static_cast<pointer>(allocation_tracker::allocate(n * sizeof(T)));\n     }\n \n     void\n     construct(pointer p, const T& value)\n     {\n       new (p) T(value);\n-      gnu_allocator_tracker::construct();\n+      allocation_tracker::construct();\n     }\n \n     void\n     destroy(pointer p)\n     {\n       p->~T();\n-      gnu_allocator_tracker::destroy();\n+      allocation_tracker::destroy();\n     }\n \n     void\n     deallocate(pointer p, size_type num)\n-    { gnu_allocator_tracker::deallocate(p, num * sizeof(T)); }\n+    { allocation_tracker::deallocate(p, num * sizeof(T)); }\n   };\n \n-template<class T1, class T2>\n-  bool\n-  operator==(const gnu_new_allocator<T1>&, \n-\t     const gnu_new_allocator<T2>&) throw()\n-  { return true; }\n-\n-template<class T1, class T2>\n-  bool\n-  operator!=(const gnu_new_allocator<T1>&, \n-\t     const gnu_new_allocator<T2>&) throw()\n-  { return false; }\n+  template<class T1, class T2>\n+    bool\n+    operator==(const tracker_alloc<T1>&, const tracker_alloc<T2>&) throw()\n+    { return true; }\n+\n+  template<class T1, class T2>\n+    bool\n+    operator!=(const tracker_alloc<T1>&, const tracker_alloc<T2>&) throw()\n+    { return false; }\n+}; // namespace __gnu_cxx_test\n \n #endif // _GLIBCPP_TESTSUITE_ALLOCATOR_H\n "}, {"sha": "4e714fa6cbaf501c238c79fc99cb7432f58c07f2", "filename": "libstdc++-v3/testsuite/testsuite_hooks.cc", "status": "modified", "additions": 97, "deletions": 17, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.cc?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -1,6 +1,7 @@\n-// Utility subroutines for the C++ library testsuite.\n+// -*- C++ -*-\n+// Utility subroutines for the C++ library testsuite. \n //\n-// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -33,14 +34,22 @@\n #include <unistd.h>\n #include <sys/time.h>\n #include <sys/resource.h>\n+#endif\n+#include <list>\n+#include <string>\n+#include <stdexcept>\n+#include <clocale>\n+#include <locale>\n \n-void\n-__set_testsuite_memlimit(float __size)\n+namespace __gnu_cxx_test\n {\n+#ifdef _GLIBCPP_MEM_LIMITS\n+  void \n+  set_memory_limits(float size)\n+  {\n     struct rlimit r;\n     // Cater to the absence of rlim_t.\n-    __typeof__ (r.rlim_cur) limit\n-      = (__typeof__ (r.rlim_cur))(__size * 1048576);\n+    __typeof__ (r.rlim_cur) limit = (__typeof__ (r.rlim_cur))(size * 1048576);\n \n     // Heap size, seems to be common.\n #if _GLIBCPP_HAVE_MEMLIMIT_DATA\n@@ -69,19 +78,90 @@ __set_testsuite_memlimit(float __size)\n     r.rlim_cur = limit;\n     setrlimit(RLIMIT_AS, &r);\n #endif\n-}\n+  }\n+\n #else\n-void\n-__set_testsuite_memlimit(float) { }\n-#endif /* _GLIBCPP_MEM_LIMITS */\n+  void\n+  set_memory_limits(float) { }\n+#endif \n+\n+  // Useful exceptions.\n+  class locale_data : public std::runtime_error \n+  {\n+  public:\n+    explicit \n+    locale_data(const std::string&  __arg) : runtime_error(__arg) { }\n+  };\n \n+  class environment_variable: public std::runtime_error \n+  {\n+  public:\n+    explicit \n+    environment_variable(const std::string&  __arg) : runtime_error(__arg) { }\n+  };\n \n-gnu_counting_struct::size_type  gnu_counting_struct::count = 0;\n+  class not_found : public std::runtime_error \n+  {\n+  public:\n+    explicit \n+    not_found(const std::string&  __arg) : runtime_error(__arg) { }\n+  };\n \n-unsigned int gnu_copy_constructor::count_ = 0;\n-unsigned int gnu_copy_constructor::throw_on_ = 0;\n-unsigned int gnu_assignment_operator::count_ = 0;\n-unsigned int gnu_assignment_operator::throw_on_ = 0;\n-unsigned int gnu_destructor::count_ = 0;\n-int gnu_copy_tracker::next_id_ = 0;\n+  void \n+  run_tests_wrapped_locale(const char* name, const func_callback& l)\n+  {\n+    using namespace std;\n+    bool test = true;\n+    \n+    // Set the global locale. \n+    locale loc_name(name);\n+    locale orig = locale::global(loc_name);\n+    \n+    const char* res = setlocale(LC_ALL, name);\n+    if (res != NULL)\n+      {\n+\tstring preLC_ALL = res;\n+\tfor (func_callback::const_iterator i = l.begin(); i != l.end(); ++i)\n+\t  (*i)();\n+\tstring postLC_ALL= setlocale(LC_ALL, NULL);\n+\tVERIFY( preLC_ALL == postLC_ALL );\n+      }\n+    else\n+      throw environment_variable(string(\"LC_ALL for\") + string(name));\n+  }\n+  \n+  void \n+  run_tests_wrapped_env(const char* name, const char* env,\n+\t\t\tconst func_callback& l)\n+  {\n+    using namespace std;\n+    bool test = true;\n+    \n+#ifdef _GLIBCPP_HAVE_SETENV \n+    // Set the global locale. \n+    locale loc_name(name);\n+    locale orig = locale::global(loc_name);\n+\n+    // Set environment variable env to value in name. \n+    const char* oldENV = getenv(env);\n+    if (!setenv(env, name, 1))\n+      {\n+\tfor (func_callback::const_iterator i = l.begin(); i != l.end(); ++i)\n+\t  (*i)();\n+\tsetenv(env, oldENV ? oldENV : \"\", 1);\n+      }\n+    else\n+      throw environment_variable(string(env) + string(\" to \") + string(name));\n+#else\n+    throw not_found(\"setenv\");\n+#endif\n+  }\n \n+  counter::size_type  counter::count = 0;\n+  unsigned int copy_constructor::count_ = 0;\n+  unsigned int copy_constructor::throw_on_ = 0;\n+  unsigned int assignment_operator::count_ = 0;\n+  unsigned int assignment_operator::throw_on_ = 0;\n+  unsigned int destructor::_M_count = 0;\n+  int copy_tracker::next_id_ = 0;\n+}; // namespace __cxx_test"}, {"sha": "cd05443dacd33a8b6e8dd399365031e72dda532b", "filename": "libstdc++-v3/testsuite/testsuite_hooks.h", "status": "modified", "additions": 176, "deletions": 169, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d59b2301899ee7cc32bce79d766ce0618ffa2f4/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.h?ref=8d59b2301899ee7cc32bce79d766ce0618ffa2f4", "patch": "@@ -1,6 +1,7 @@\n-// Utility subroutines for the C++ library testsuite.\n+// -*- C++ -*-\n+// Utility subroutines for the C++ library testsuite. \n //\n-// Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -34,211 +35,232 @@\n //   #define(able) assert() behavior for debugging/testing. It may be\n //   a suitable location for other furry woodland creatures as well.\n //\n-// 2)  __set_testsuite_memlimit()\n-//   __set_testsuite_memlimit() uses setrlimit() to restrict dynamic memory\n+// 2)  set_memory_limits()\n+//   set_memory_limits() uses setrlimit() to restrict dynamic memory\n //   allocation.  We provide a default memory limit if none is passed by the\n-//   calling application.  The argument to __set_testsuite_memlimit() is the\n+//   calling application.  The argument to set_memory_limits() is the\n //   limit in megabytes (a floating-point number).  If _GLIBCPP_MEM_LIMITS is\n //   not #defined before including this header, then no limiting is attempted.\n //\n-// 3)  gnu_counting_struct\n+// 3)  counter\n //   This is a POD with a static data member, gnu_counting_struct::count,\n //   which starts at zero, increments on instance construction, and decrements\n //   on instance destruction.  \"assert_count(n)\" can be called to VERIFY()\n //   that the count equals N.\n //\n-// 4)  gnu_copy_tracker, from Stephen M. Webb <stephen@bregmasoft.com>.\n+// 4)  copy_tracker, from Stephen M. Webb <stephen@bregmasoft.com>.\n //   A class with nontrivial ctor/dtor that provides the ability to track the\n //   number of copy ctors and dtors, and will throw on demand during copy.\n //\n-// 5) gnu_char, gnu_char_traits, abstract character classes and\n-// char_traits specializations for testing instantiations.\n+// 5) pod_char, pod_int, , abstract character classes and\n+//   char_traits specializations for testing instantiations.\n \n #ifndef _GLIBCPP_TESTSUITE_HOOKS_H\n #define _GLIBCPP_TESTSUITE_HOOKS_H\n \n #include <bits/c++config.h>\n #include <bits/functexcept.h>\n #include <cstddef>\n-\n #ifdef DEBUG_ASSERT\n # include <cassert>\n # define VERIFY(fn) assert(fn)\n #else\n # define VERIFY(fn) test &= (fn)\n #endif\n+#include <list>\n \n-// Defined in GLIBCPP_CONFIGURE_TESTSUITE.\n-#ifndef _GLIBCPP_MEM_LIMITS\n-// Don't do memory limits.\n-extern void\n-__set_testsuite_memlimit(float x = 0);\n+namespace __gnu_cxx_test\n+{\n+  // All macros are defined in GLIBCPP_CONFIGURE_TESTSUITE and imported\n+  // from c++config.h\n \n+  // Set memory limits if possible, if not set to 0.\n+#ifndef _GLIBCPP_MEM_LIMITS\n+#  define MEMLIMIT_MB 0\n #else\n-\n-// Do memory limits.\n-#ifndef MEMLIMIT_MB\n-#define MEMLIMIT_MB 16.0\n+# ifndef MEMLIMIT_MB\n+#  define MEMLIMIT_MB 16.0\n+# endif\n #endif\n+  extern void\n+  set_memory_limits(float __size = MEMLIMIT_MB);\n \n-extern void\n-__set_testsuite_memlimit(float __size = MEMLIMIT_MB);\n-#endif\n+  // Simple callback structure for variable numbers of tests (all with\n+  // same signature).  Assume all unit tests are of the signature\n+  // void test01(); \n+  typedef void (*test_func) (void);\n+  typedef std::list<test_func> func_callback;\n \n+  // Run select unit tests after setting global locale.\n+  void \n+  run_tests_wrapped_locale(const char*, const func_callback&);\n \n-struct gnu_counting_struct\n-{\n+  // Run select unit tests after setting environment variables.\n+  void \n+  run_tests_wrapped_env(const char*, const char*, const func_callback&);\n+\n+  // Test data types.\n+  struct pod_char\n+  {\n+    unsigned char c;\n+  };\n+  \n+  struct pod_int\n+  {\n+    int i;\n+  };\n+  \n+  struct pod_unsigned_int\n+  {\n+    unsigned int i;\n+  };\n+  \n+  struct pod_long\n+  {\n+    unsigned long i;\n+  };\n+  \n+  struct state\n+  {\n+    unsigned long l;\n+    unsigned long l2;\n+  };\n+\n+  // Counting.\n+  struct counter\n+  {\n     // Specifically and glaringly-obviously marked 'signed' so that when\n     // COUNT mistakenly goes negative, we can track the patterns of\n     // deletions more easily.\n     typedef  signed int     size_type;\n     static size_type   count;\n-    gnu_counting_struct() { ++count; }\n-    gnu_counting_struct (const gnu_counting_struct&) { ++count; }\n-    ~gnu_counting_struct() { --count; }\n-};\n-\n-#define assert_count(n)   VERIFY(gnu_counting_struct::count == n)\n-\n-// A (static) class for counting copy constructors and possibly throwing an\n-// exception on a desired count.\n-class gnu_copy_constructor\n-{\n-public:\n-  static unsigned int\n-  count()\n-  { return count_; }\n-\n-  static void\n-  mark_call()\n+    counter() { ++count; }\n+    counter (const counter&) { ++count; }\n+    ~counter() { --count; }\n+  };\n+  \n+#define assert_count(n)   VERIFY(__gnu_cxx_test::counter::count == n)\n+  \n+  // A (static) class for counting copy constructors and possibly throwing an\n+  // exception on a desired count.\n+  class copy_constructor\n   {\n-    count_++;\n-    if (count_ == throw_on_)\n+  public:\n+    static unsigned int\n+    count() { return count_; }\n+    \n+    static void\n+    mark_call()\n     {\n-      __throw_exception_again \"copy constructor exception\";\n+      count_++;\n+      if (count_ == throw_on_)\n+\t__throw_exception_again \"copy constructor exception\";\n     }\n-  }\n+      \n+    static void\n+    reset()\n+    {\n+      count_ = 0;\n+      throw_on_ = 0;\n+    }\n+      \n+    static void\n+    throw_on(unsigned int count) { throw_on_ = count; }\n \n-  static void\n-  reset()\n+  private:\n+    static unsigned int count_;\n+    static unsigned int throw_on_;\n+  };\n+  \n+  // A (static) class for counting assignment operator calls and\n+  // possibly throwing an exception on a desired count.\n+  class assignment_operator\n   {\n-    count_ = 0;\n-    throw_on_ = 0;\n-  }\n-\n-  static void\n-  throw_on(unsigned int count)\n-  { throw_on_ = count; }\n-\n-private:\n-  static unsigned int count_;\n-  static unsigned int throw_on_;\n-};\n-\n-// A (static) class for counting assignment operator calls and possibly\n-// throwing an exception on a desired count.\n-class gnu_assignment_operator\n-{\n-public:\n-  static unsigned int\n-  count()\n-  { return count_; }\n+  public:\n+    static unsigned int\n+    count() { return count_; }\n+    \n+    static void\n+    mark_call()\n+    {\n+      count_++;\n+      if (count_ == throw_on_)\n+\t__throw_exception_again \"assignment operator exception\";\n+    }\n \n-  static void\n-  mark_call()\n-  {\n-    count_++;\n-    if (count_ == throw_on_)\n+    static void\n+    reset()\n     {\n-      __throw_exception_again \"assignment operator exception\";\n+      count_ = 0;\n+      throw_on_ = 0;\n     }\n-  }\n \n-  static void\n-  reset()\n-  {\n-    count_ = 0;\n-    throw_on_ = 0;\n-  }\n+    static void\n+    throw_on(unsigned int count) { throw_on_ = count; }\n \n-  static void\n-  throw_on(unsigned int count)\n-  { throw_on_ = count; }\n+  private:\n+    static unsigned int count_;\n+    static unsigned int throw_on_;\n+  };\n+  \n+  // A (static) class for tracking calls to an object's destructor.\n+  class destructor\n+  {\n+  public:\n+    static unsigned int\n+    count() { return _M_count; }\n+    \n+    static void\n+    mark_call() { _M_count++; }\n \n-private:\n-  static unsigned int count_;\n-  static unsigned int throw_on_;\n-};\n+    static void\n+    reset() { _M_count = 0; }\n \n-// A (static) class for tracking calls to an object's destructor.\n-class gnu_destructor\n-{\n-public:\n-  static unsigned int\n-  count()\n-  { return count_; }\n-\n-  static void\n-  mark_call()\n-  { count_++; }\n-\n-  static void\n-  reset()\n-  { count_ = 0; }\n-\n-private:\n-  static unsigned int count_;\n-};\n-\n-// An class of objects that can be used for validating various behaviours and\n-// guarantees of containers and algorithms defined in the standard library.\n-class gnu_copy_tracker\n-{\n+  private:\n+    static unsigned int _M_count;\n+  };\n+  \n+  // An class of objects that can be used for validating various\n+  // behaviours and guarantees of containers and algorithms defined in\n+  // the standard library.\n+  class copy_tracker\n+  {\n   public:\n-    // Creates a copy-tracking object with the given ID number.\n-    // If \"throw_on_copy\" is set, an exception will be thrown if\n-    // an attempt is made to copy this object.\n-    gnu_copy_tracker(int id = next_id_--, bool throw_on_copy = false)\n-    : id_(id)\n-    , throw_on_copy_(throw_on_copy)\n-    {\n-    }\n+    // Creates a copy-tracking object with the given ID number.  If\n+    // \"throw_on_copy\" is set, an exception will be thrown if an\n+    // attempt is made to copy this object.\n+    copy_tracker(int id = next_id_--, bool throw_on_copy = false)\n+    : id_(id) , throw_on_copy_(throw_on_copy) { }\n \n     // Copy-constructs the object, marking a call to the copy\n     // constructor and forcing an exception if indicated.\n-    gnu_copy_tracker(const gnu_copy_tracker& rhs)\n+    copy_tracker(const copy_tracker& rhs)\n     : id_(rhs.id()), throw_on_copy_(rhs.throw_on_copy_)\n     {\n       int kkk = throw_on_copy_;\n       if (throw_on_copy_)\n-      {\n-        gnu_copy_constructor::throw_on(gnu_copy_constructor::count() + 1);\n-      }\n-      gnu_copy_constructor::mark_call();\n+\tcopy_constructor::throw_on(copy_constructor::count() + 1);\n+      copy_constructor::mark_call();\n     }\n \n     // Assigns the value of another object to this one, tracking the\n     // number of times this member function has been called and if the\n     // other object is supposed to throw an exception when it is\n     // copied, well, make it so.\n-    gnu_copy_tracker&\n-    operator=(const gnu_copy_tracker& rhs)\n+    copy_tracker&\n+    operator=(const copy_tracker& rhs)\n     { \n       id_ = rhs.id();\n       if (rhs.throw_on_copy_)\n-      {\n-        gnu_assignment_operator::throw_on(gnu_assignment_operator::count() \n-\t\t\t\t\t  + 1);\n-      }\n-      gnu_assignment_operator::mark_call();\n+        assignment_operator::throw_on(assignment_operator::count() + 1);\n+      assignment_operator::mark_call();\n     }\n \n-    ~gnu_copy_tracker()\n-    { gnu_destructor::mark_call(); }\n+    ~copy_tracker()\n+    { destructor::mark_call(); }\n \n     int\n-    id() const\n-    { return id_; }\n+    id() const { return id_; }\n \n   private:\n     int   id_;\n@@ -248,59 +270,44 @@ class gnu_copy_tracker\n     static void\n     reset()\n     {\n-      gnu_copy_constructor::reset();\n-      gnu_assignment_operator::reset();\n-      gnu_destructor::reset();\n+      copy_constructor::reset();\n+      assignment_operator::reset();\n+      destructor::reset();\n     }\n \n     // for backwards-compatibility\n     static int\n     copyCount() \n-    { return gnu_copy_constructor::count(); }\n+    { return copy_constructor::count(); }\n \n     // for backwards-compatibility\n     static int\n     dtorCount() \n-    { return gnu_destructor::count(); }\n+    { return destructor::count(); }\n \n   private:\n     static int next_id_;\n-};\n-\n-inline bool\n-operator==(const gnu_copy_tracker& lhs, const gnu_copy_tracker& rhs)\n-{ return lhs.id() == rhs.id(); }\n-\n-struct gnu_char\n-{\n-  unsigned long c;\n-};\n+  };\n \n-struct gnu_int\n-{\n-  unsigned long i;\n-};\n-\n-struct gnu_state\n-{\n-  unsigned long l;\n-  unsigned long l2;\n-};\n+  inline bool\n+  operator==(const copy_tracker& lhs, const copy_tracker& rhs)\n+  { return lhs.id() == rhs.id(); }\n+}; // namespace __gnu_cxx_test\n \n-// char_traits specialization\n namespace std\n {\n   template<class _CharT>\n     struct char_traits;\n \n+  // char_traits specialization\n   template<>\n-    struct char_traits<gnu_char>\n+    struct char_traits<__gnu_cxx_test::pod_char>\n     {\n-      typedef gnu_char \t\tchar_type;\n-      typedef gnu_int  \t\tint_type;\n-      typedef long \t\tpos_type;\n-      typedef unsigned long \toff_type;\n-      typedef gnu_state \tstate_type;\n+      typedef __gnu_cxx_test::pod_char\tchar_type;\n+      typedef __gnu_cxx_test::pod_int  \tint_type;\n+      typedef long \t\t\tpos_type;\n+      typedef unsigned long \t\toff_type;\n+      typedef __gnu_cxx_test::state   \tstate_type;\n       \n       static void \n       assign(char_type& __c1, const char_type& __c2);"}]}