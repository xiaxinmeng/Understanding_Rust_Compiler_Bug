{"sha": "116784bbde9ed391393320d936ae2fff37442779", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE2Nzg0YmJkZTllZDM5MTM5MzMyMGQ5MzZhZTJmZmYzNzQ0Mjc3OQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2020-05-02T15:30:01Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2020-05-02T15:33:30Z"}, "message": "Add asan subdirectory for gfortran.dg.\n\nBecause the test case for PR 94788 requires -fsanitize=address to expose\nthe double free, I have created a subdirectory under gfortran.dg\nwhere such test cases can go.\n\nI have tested this with\n\nmake check-fortran RUNTESTFLAGS=\"asan.exp=*\"\n\nand it works; with a compiler that introduces the double free bug\n\tinto the test case, the result is as expected\n\n2020-05-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/94788\n\t* gfortran.dg/asan: New directory.\n\t* gfortran.dg/asan/asan.exp: New file.\n\t* gfortran.dg/asan/pointer_assign_16.f90: New test case.", "tree": {"sha": "7a67016ce94ef696dfa1876d86316a53d715ebc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a67016ce94ef696dfa1876d86316a53d715ebc8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/116784bbde9ed391393320d936ae2fff37442779", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/116784bbde9ed391393320d936ae2fff37442779", "html_url": "https://github.com/Rust-GCC/gccrs/commit/116784bbde9ed391393320d936ae2fff37442779", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/116784bbde9ed391393320d936ae2fff37442779/comments", "author": null, "committer": null, "parents": [{"sha": "dcbf228e4a1818f4733ffcadd323be5eaf5e520a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcbf228e4a1818f4733ffcadd323be5eaf5e520a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcbf228e4a1818f4733ffcadd323be5eaf5e520a"}], "stats": {"total": 351, "additions": 351, "deletions": 0}, "files": [{"sha": "a9c72f982feade7201cbdc778e282072b0f422db", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/116784bbde9ed391393320d936ae2fff37442779/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/116784bbde9ed391393320d936ae2fff37442779/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=116784bbde9ed391393320d936ae2fff37442779", "patch": "@@ -1,3 +1,10 @@\n+2020-05-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/94788\n+\t* gfortran.dg/asan: New directory.\n+\t* gfortran.dg/asan/asan.exp: New file.\n+\t* gfortran.dg/asan/pointer_assign_16.f90: New test case.\n+\n 2020-05-01  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/93492"}, {"sha": "056f21f62cd91dfcb2bd51338d2d4657fbd7aa22", "filename": "gcc/testsuite/gfortran.dg/asan/asan.exp", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/116784bbde9ed391393320d936ae2fff37442779/gcc%2Ftestsuite%2Fgfortran.dg%2Fasan%2Fasan.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/116784bbde9ed391393320d936ae2fff37442779/gcc%2Ftestsuite%2Fgfortran.dg%2Fasan%2Fasan.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fasan%2Fasan.exp?ref=116784bbde9ed391393320d936ae2fff37442779", "patch": "@@ -0,0 +1,40 @@\n+# Copyright (C) 2020 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite for gfortran that checks for -fsanitize=address error.\n+\n+# Contributed by Thomas K\u00f6nig, <tkoenig@gcc.gnu.org>\n+\n+# Load support procs.\n+load_lib gfortran-dg.exp\n+load_lib asan-dg.exp\n+\n+\n+# Initialize `dg'.\n+dg-init\n+asan_init\n+\n+# Main loop.\n+if [check_effective_target_fsanitize_address] {\n+    gfortran-dg-runtest [lsort \\\n+       [glob -nocomplain $srcdir/$subdir/*.\\[fF\\]{,90,95,03,08} ] ] \"-fsanitize=address\" \"\"\n+}\n+\n+# All done.\n+asan_finish\n+dg-finish"}, {"sha": "b2728d606663c788039cd421fc9aa664da2df7ec", "filename": "gcc/testsuite/gfortran.dg/asan/pointer_assign_16.f90", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/116784bbde9ed391393320d936ae2fff37442779/gcc%2Ftestsuite%2Fgfortran.dg%2Fasan%2Fpointer_assign_16.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/116784bbde9ed391393320d936ae2fff37442779/gcc%2Ftestsuite%2Fgfortran.dg%2Fasan%2Fpointer_assign_16.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fasan%2Fpointer_assign_16.f90?ref=116784bbde9ed391393320d936ae2fff37442779", "patch": "@@ -0,0 +1,304 @@\n+! { dg-do run }\n+! PR fortran/94788 - this leads to a double free.\n+! Test case by Juergen Reuter.\n+module iso_varying_string\n+  implicit none\n+  integer, parameter, private :: GET_BUFFER_LEN = 1\n+  type, public :: varying_string\n+     private\n+     character(LEN=1), dimension(:), allocatable :: chars\n+  end type varying_string\n+\n+  interface assignment(=)\n+     module procedure op_assign_CH_VS\n+     module procedure op_assign_VS_CH\n+  end interface assignment(=)\n+\n+  interface char\n+     module procedure char_auto\n+     module procedure char_fixed\n+  end interface char\n+\n+ interface len\n+     module procedure len_\n+  end interface len\n+\n+  interface var_str\n+     module procedure var_str_\n+  end interface var_str\n+\n+  public :: assignment(=)\n+  public :: char\n+  public :: len\n+  public :: var_str\n+\n+  private :: op_assign_CH_VS\n+  private :: op_assign_VS_CH\n+  private :: op_eq_VS_VS\n+  private :: op_eq_CH_VS\n+  private :: op_eq_VS_CH\n+  private :: char_auto\n+  private :: char_fixed\n+  private :: len_\n+  private :: var_str_\n+\n+contains\n+\n+  elemental function len_ (string) result (length)\n+    type(varying_string), intent(in) :: string\n+    integer                          :: length\n+    if(ALLOCATED(string%chars)) then\n+       length = SIZE(string%chars)\n+    else\n+       length = 0\n+    endif\n+  end function len_\n+\n+  elemental subroutine op_assign_CH_VS (var, exp)\n+    character(LEN=*), intent(out)    :: var\n+    type(varying_string), intent(in) :: exp\n+    var = char(exp)\n+  end subroutine op_assign_CH_VS\n+\n+  elemental subroutine op_assign_VS_CH (var, exp)\n+    type(varying_string), intent(out) :: var\n+    character(LEN=*), intent(in)      :: exp\n+    var = var_str(exp)\n+  end subroutine op_assign_VS_CH\n+\n+  elemental function op_eq_VS_VS (string_a, string_b) result (op_eq)\n+    type(varying_string), intent(in) :: string_a\n+    type(varying_string), intent(in) :: string_b\n+    logical                          :: op_eq\n+    op_eq = char(string_a) == char(string_b)\n+  end function op_eq_VS_VS\n+\n+  elemental function op_eq_CH_VS (string_a, string_b) result (op_eq)\n+    character(LEN=*), intent(in)     :: string_a\n+    type(varying_string), intent(in) :: string_b\n+    logical                          :: op_eq\n+    op_eq = string_a == char(string_b)\n+  end function op_eq_CH_VS\n+\n+  elemental function op_eq_VS_CH (string_a, string_b) result (op_eq)\n+    type(varying_string), intent(in) :: string_a\n+    character(LEN=*), intent(in)     :: string_b\n+    logical                          :: op_eq\n+    op_eq = char(string_a) == string_b\n+  end function op_eq_VS_CH\n+\n+\n+  pure function char_auto (string) result (char_string)\n+    type(varying_string), intent(in) :: string\n+    character(LEN=len(string))       :: char_string\n+    integer                          :: i_char\n+    forall(i_char = 1:len(string))\n+       char_string(i_char:i_char) = string%chars(i_char)\n+    end forall\n+\n+  end function char_auto\n+\n+  pure function char_fixed (string, length) result (char_string)\n+    type(varying_string), intent(in) :: string\n+    integer, intent(in)              :: length\n+    character(LEN=length)            :: char_string\n+    char_string = char(string)\n+  end function char_fixed\n+\n+  elemental function var_str_ (char) result (string)\n+    character(LEN=*), intent(in) :: char\n+    type(varying_string)         :: string\n+    integer                      :: length\n+    integer                      :: i_char\n+    length = LEN(char)\n+    ALLOCATE(string%chars(length))\n+    forall(i_char = 1:length)\n+       string%chars(i_char) = char(i_char:i_char)\n+    end forall\n+  end function var_str_\n+\n+end module iso_varying_string\n+\n+\n+module parser\n+  implicit none\n+  private\n+  public :: parse_node_t\n+  public :: parse_tree_t\n+  type :: parse_node_t\n+     private\n+  end type parse_node_t\n+\n+  type :: parse_tree_t\n+     private\n+     type(parse_node_t), pointer :: root_node => null ()\n+   contains\n+     procedure :: get_root_ptr => parse_tree_get_root_ptr\n+  end type parse_tree_t\n+\n+contains\n+  function parse_tree_get_root_ptr (parse_tree) result (node)\n+    class(parse_tree_t), intent(in) :: parse_tree\n+    type(parse_node_t), pointer :: node\n+    node => parse_tree%root_node\n+  end function parse_tree_get_root_ptr\n+\n+end module parser\n+\n+\n+\n+module rt_data\n+  use iso_varying_string, string_t => varying_string\n+  use parser, only: parse_node_t\n+  implicit none\n+  private\n+\n+  public :: rt_data_t\n+\n+  type :: rt_parse_nodes_t\n+     type(parse_node_t), pointer :: weight_expr => null ()\n+  end type rt_parse_nodes_t\n+\n+  type :: rt_data_t\n+     type(rt_parse_nodes_t) :: pn\n+     type(string_t) :: logfile\n+   contains\n+     procedure :: global_init => rt_data_global_init\n+     procedure :: local_init => rt_data_local_init\n+     procedure :: activate => rt_data_activate\n+  end type rt_data_t\n+\n+\n+contains\n+\n+  subroutine rt_data_global_init (global, logfile)\n+    class(rt_data_t), intent(out), target :: global\n+    type(string_t), intent(in), optional :: logfile\n+    integer :: seed\n+    if (present (logfile)) then\n+       global%logfile = logfile\n+    else\n+       global%logfile = \"\"\n+    end if\n+    call system_clock (seed)\n+  end subroutine rt_data_global_init\n+\n+  subroutine rt_data_local_init (local, global, env)\n+    class(rt_data_t), intent(inout), target :: local\n+    type(rt_data_t), intent(in), target :: global\n+    integer, intent(in), optional :: env\n+    local%logfile = global%logfile\n+  end subroutine rt_data_local_init\n+\n+  subroutine rt_data_activate (local)\n+    class(rt_data_t), intent(inout), target :: local\n+    class(rt_data_t), pointer :: global\n+    \n+    ! global => local%context\n+    ! if (associated (global)) then\n+    !    local%logfile = global%logfile\n+    !    local%pn = global%pn\n+    ! end if\n+  end subroutine rt_data_activate\n+\n+end module rt_data\n+\n+module events\n+  implicit none\n+  private\n+  public :: event_t\n+\n+  type :: event_config_t\n+  end type event_config_t\n+\n+  type :: event_t\n+     type(event_config_t) :: config\n+  end type event_t\n+\n+end module events\n+\n+\n+module simulations\n+  use iso_varying_string, string_t => varying_string\n+  use events \n+  use rt_data\n+\n+  implicit none\n+  private\n+\n+  public :: simulation_t\n+\n+  type, extends (event_t) :: entry_t\n+     private\n+     type(entry_t), pointer :: next => null ()\n+  end type entry_t\n+\n+  type, extends (entry_t) :: alt_entry_t\n+   contains\n+     procedure :: init_alt => alt_entry_init\n+  end type alt_entry_t\n+\n+  type :: simulation_t\n+     private\n+     type(rt_data_t), pointer :: local => null ()\n+     integer :: n_alt = 0\n+     type(entry_t), dimension(:), allocatable :: entry\n+     type(alt_entry_t), dimension(:,:), allocatable :: alt_entry\n+   contains\n+     procedure :: init => simulation_init\n+  end type simulation_t\n+\n+\n+contains\n+\n+  subroutine alt_entry_init (entry, local)\n+    class(alt_entry_t), intent(inout), target :: entry\n+    type(rt_data_t), intent(inout), target :: local\n+    integer :: i\n+  end subroutine alt_entry_init\n+\n+  subroutine simulation_init (simulation, &\n+       integrate, generate, local, global, alt_env)\n+    class(simulation_t), intent(out), target :: simulation\n+    logical, intent(in) :: integrate, generate\n+    type(rt_data_t), intent(inout), target :: local\n+    type(rt_data_t), intent(inout), optional, target :: global\n+    type(rt_data_t), dimension(:), intent(inout), optional, target :: alt_env\n+    simulation%local => local\n+    allocate (simulation%entry (1))\n+    if (present (alt_env)) then\n+       simulation%n_alt = size (alt_env)\n+    end if\n+  end subroutine simulation_init\n+\n+end module simulations\n+\n+\n+program main_ut\n+  use iso_varying_string, string_t => varying_string\n+  use parser, only: parse_tree_t\n+  use rt_data\n+  use simulations\n+  implicit none\n+  call simulations_10 (6)\n+\n+contains\n+\n+  subroutine simulations_10 (u)\n+    integer, intent(in) :: u\n+    type(rt_data_t), target :: global\n+    type(rt_data_t), dimension(1), target :: alt_env\n+    type(parse_tree_t) :: pt_weight\n+    type(simulation_t), target :: simulation\n+\n+    call global%global_init ()\n+    call alt_env(1)%local_init (global)\n+    call alt_env(1)%activate ()\n+\n+    !!!! This causes the pointer hiccup\n+    alt_env(1)%pn%weight_expr => pt_weight%get_root_ptr ()\n+    call simulation%init (.true., .true., global, alt_env=alt_env)\n+\n+  end subroutine simulations_10\n+  \n+end program main_ut"}]}