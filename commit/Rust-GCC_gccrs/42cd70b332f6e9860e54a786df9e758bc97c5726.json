{"sha": "42cd70b332f6e9860e54a786df9e758bc97c5726", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJjZDcwYjMzMmY2ZTk4NjBlNTRhNzg2ZGY5ZTc1OGJjOTdjNTcyNg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-04-28T22:46:43Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-04-28T22:46:43Z"}, "message": "remove EH from backend.\n\nFrom-SVN: r7170", "tree": {"sha": "d20adc5a7f166d376cdf6816260fac4285aa3ffe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d20adc5a7f166d376cdf6816260fac4285aa3ffe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42cd70b332f6e9860e54a786df9e758bc97c5726", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42cd70b332f6e9860e54a786df9e758bc97c5726", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42cd70b332f6e9860e54a786df9e758bc97c5726", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42cd70b332f6e9860e54a786df9e758bc97c5726/comments", "author": null, "committer": null, "parents": [{"sha": "d5c88b0ab97df0b667cf74ec23b929e5e9574cb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5c88b0ab97df0b667cf74ec23b929e5e9574cb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5c88b0ab97df0b667cf74ec23b929e5e9574cb0"}], "stats": {"total": 328, "additions": 0, "deletions": 328}, "files": [{"sha": "a6b708fa48fd72e1dbb71f5beafb4b647676bca5", "filename": "gcc/stmt.c", "status": "modified", "additions": 0, "deletions": 328, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42cd70b332f6e9860e54a786df9e758bc97c5726/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42cd70b332f6e9860e54a786df9e758bc97c5726/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=42cd70b332f6e9860e54a786df9e758bc97c5726", "patch": "@@ -301,29 +301,6 @@ struct nesting\n \t  /* Nonzero if a case label has been seen in this case stmt.  */\n \t  char seenlabel;\n \t} case_stmt;\n-      /* For exception contours.  */\n-      struct\n-\t{\n-\t  /* List of exceptions raised.  This is a TREE_LIST\n-\t     of whatever you want.  */\n-\t  tree raised;\n-\t  /* List of exceptions caught.  This is also a TREE_LIST\n-\t     of whatever you want.  As a special case, it has the\n-\t     value `void_type_node' if it handles default exceptions.  */\n-\t  tree handled;\n-\n-\t  /* First insn of TRY block, in case resumptive model is needed.  */\n-\t  rtx first_insn;\n-\t  /* Label for the catch clauses.  */\n-\t  rtx except_label;\n-\t  /* Label for unhandled exceptions.  */\n-\t  rtx unhandled_label;\n-\t  /* Label at the end of whole construct.  */\n-\t  rtx after_label;\n-\t  /* Label which \"escapes\" the exception construct.\n-\t     Like EXIT_LABEL for BREAK construct, but for exceptions.  */\n-\t  rtx escape_label;\n-\t} except_stmt;\n     } data;\n };\n \n@@ -345,9 +322,6 @@ struct nesting *loop_stack;\n /* Chain of all pending case or switch statements.  */\n struct nesting *case_stack;\n \n-/* Chain of all pending exception contours.  */\n-struct nesting *except_stack;\n-\n /* Separate chain including all of the above,\n    chained through the `all' field.  */\n struct nesting *nesting_stack;\n@@ -379,8 +353,6 @@ do { struct nesting *target = STACK;\t\t\t\\\n \t    stack_block_stack = stack_block_stack->next; \\\n \t  if (case_stack == this)\t\t\t\\\n \t    case_stack = case_stack->next;\t\t\\\n-\t  if (except_stack == this)\t\t\t\\\n-\t    except_stack = except_stack->next;\t\t\\\n \t  nesting_depth = nesting_stack->depth - 1;\t\\\n \t  nesting_stack = this->all;\t\t\t\\\n \t  obstack_free (&stmt_obstack, this); }\t\t\\\n@@ -1885,306 +1857,6 @@ expand_end_stmt_expr (t)\n   return t;\n }\n \f\n-/* The exception handling nesting looks like this:\n-\n-\t\t<-- Level N-1\n-    {\t\t<-- exception handler block\n-\t\t<-- Level N\n-\t\t<-- in an exception handler\n-\t{\t<-- try block\n-\t:\t<-- in a TRY block\n-\t:\t<-- in an exception handler\n-\t:\n-\t}\n-\n-\t{\t<-- except block\n-\t:\t<-- in an except block\n-\t:\t<-- in an exception handler\n-\t:\n-\t}\n-\n-    }\n-*/\n-\n-/* Return nonzero iff in a try block at level LEVEL.  */\n-\n-int\n-in_try_block (level)\n-     int level;\n-{\n-  struct nesting *n = except_stack;\n-  while (1)\n-    {\n-      while (n && n->data.except_stmt.after_label != 0)\n-\tn = n->next;\n-      if (n == 0)\n-\treturn 0;\n-      if (level == 0)\n-\treturn n != 0;\n-      level--;\n-      n = n->next;\n-    }\n-}\n-\n-/* Return nonzero iff in an except block at level LEVEL.  */\n-\n-int\n-in_except_block (level)\n-     int level;\n-{\n-  struct nesting *n = except_stack;\n-  while (1)\n-    {\n-      while (n && n->data.except_stmt.after_label == 0)\n-\tn = n->next;\n-      if (n == 0)\n-\treturn 0;\n-      if (level == 0)\n-\treturn n != 0;\n-      level--;\n-      n = n->next;\n-    }\n-}\n-\n-/* Return nonzero iff in an exception handler at level LEVEL.  */\n-\n-int\n-in_exception_handler (level)\n-     int level;\n-{\n-  struct nesting *n = except_stack;\n-  while (n && level--)\n-    n = n->next;\n-  return n != 0;\n-}\n-\n-/* Record the fact that the current exception nesting raises\n-   exception EX.  If not in an exception handler, return 0.  */\n-int\n-expand_raise (ex)\n-     tree ex;\n-{\n-  tree *raises_ptr;\n-\n-  if (except_stack == 0)\n-    return 0;\n-  raises_ptr = &except_stack->data.except_stmt.raised;\n-  if (! value_member (ex, *raises_ptr))\n-    *raises_ptr = tree_cons (NULL_TREE, ex, *raises_ptr);\n-  return 1;\n-}\n-\n-/* Generate RTL for the start of a try block.\n-\n-   TRY_CLAUSE is the condition to test to enter the try block.  */\n-\n-void\n-expand_start_try (try_clause, exitflag, escapeflag)\n-     tree try_clause;\n-     int exitflag;\n-     int escapeflag;\n-{\n-  struct nesting *thishandler = ALLOC_NESTING ();\n-\n-  /* Make an entry on cond_stack for the cond we are entering.  */\n-\n-  thishandler->next = except_stack;\n-  thishandler->all = nesting_stack;\n-  thishandler->depth = ++nesting_depth;\n-  thishandler->data.except_stmt.raised = 0;\n-  thishandler->data.except_stmt.handled = 0;\n-  thishandler->data.except_stmt.first_insn = get_insns ();\n-  thishandler->data.except_stmt.except_label = gen_label_rtx ();\n-  thishandler->data.except_stmt.unhandled_label = 0;\n-  thishandler->data.except_stmt.after_label = 0;\n-  thishandler->data.except_stmt.escape_label\n-    = escapeflag ? thishandler->data.except_stmt.except_label : 0;\n-  thishandler->exit_label = exitflag ? gen_label_rtx () : 0;\n-  except_stack = thishandler;\n-  nesting_stack = thishandler;\n-\n-  do_jump (try_clause, thishandler->data.except_stmt.except_label, NULL_RTX);\n-}\n-\n-/* End of a TRY block.  Nothing to do for now.  */\n-\n-void\n-expand_end_try ()\n-{\n-  except_stack->data.except_stmt.after_label = gen_label_rtx ();\n-  expand_goto_internal (NULL_TREE, except_stack->data.except_stmt.after_label,\n-\t\t\tNULL_RTX);\n-}\n-\n-/* Start an `except' nesting contour.\n-   EXITFLAG says whether this contour should be able to `exit' something.\n-   ESCAPEFLAG says whether this contour should be escapable.  */\n-\n-void\n-expand_start_except (exitflag, escapeflag)\n-     int exitflag;\n-     int escapeflag;\n-{\n-  if (exitflag)\n-    {\n-      struct nesting *n;\n-      /* An `exit' from catch clauses goes out to next exit level,\n-\t if there is one.  Otherwise, it just goes to the end\n-\t of the construct.  */\n-      for (n = except_stack->next; n; n = n->next)\n-\tif (n->exit_label != 0)\n-\t  {\n-\t    except_stack->exit_label = n->exit_label;\n-\t    break;\n-\t  }\n-      if (n == 0)\n-\texcept_stack->exit_label = except_stack->data.except_stmt.after_label;\n-    }\n-  if (escapeflag)\n-    {\n-      struct nesting *n;\n-      /* An `escape' from catch clauses goes out to next escape level,\n-\t if there is one.  Otherwise, it just goes to the end\n-\t of the construct.  */\n-      for (n = except_stack->next; n; n = n->next)\n-\tif (n->data.except_stmt.escape_label != 0)\n-\t  {\n-\t    except_stack->data.except_stmt.escape_label\n-\t      = n->data.except_stmt.escape_label;\n-\t    break;\n-\t  }\n-      if (n == 0)\n-\texcept_stack->data.except_stmt.escape_label\n-\t  = except_stack->data.except_stmt.after_label;\n-    }\n-  do_pending_stack_adjust ();\n-  emit_label (except_stack->data.except_stmt.except_label);\n-}\n-\n-/* Generate code to `escape' from an exception contour.  This\n-   is like `exiting', but does not conflict with constructs which\n-   use `exit_label'.\n-\n-   Return nonzero if this contour is escapable, otherwise\n-   return zero, and language-specific code will emit the\n-   appropriate error message.  */\n-int\n-expand_escape_except ()\n-{\n-  struct nesting *n;\n-  last_expr_type = 0;\n-  for (n = except_stack; n; n = n->next)\n-    if (n->data.except_stmt.escape_label != 0)\n-      {\n-\texpand_goto_internal (NULL_TREE,\n-\t\t\t      n->data.except_stmt.escape_label, NULL_RTX);\n-\treturn 1;\n-      }\n-\n-  return 0;\n-}\n-\n-/* Finish processing and `except' contour.\n-   Culls out all exceptions which might be raise but not\n-   handled, and returns the list to the caller.\n-   Language-specific code is responsible for dealing with these\n-   exceptions.  */\n-\n-tree\n-expand_end_except ()\n-{\n-  struct nesting *n;\n-  tree raised = NULL_TREE;\n-\n-  do_pending_stack_adjust ();\n-  emit_label (except_stack->data.except_stmt.after_label);\n-\n-  n = except_stack->next;\n-  if (n)\n-    {\n-      /* Propagate exceptions raised but not handled to next\n-\t highest level.  */\n-      tree handled = except_stack->data.except_stmt.raised;\n-      if (handled != void_type_node)\n-\t{\n-\t  tree prev = NULL_TREE;\n-\t  raised = except_stack->data.except_stmt.raised;\n-\t  while (handled)\n-\t    {\n-\t      tree this_raise;\n-\t      for (this_raise = raised, prev = 0; this_raise;\n-\t\t   this_raise = TREE_CHAIN (this_raise))\n-\t\t{\n-\t\t  if (value_member (TREE_VALUE (this_raise), handled))\n-\t\t    {\n-\t\t      if (prev)\n-\t\t\tTREE_CHAIN (prev) = TREE_CHAIN (this_raise);\n-\t\t      else\n-\t\t\t{\n-\t\t\t  raised = TREE_CHAIN (raised);\n-\t\t\t  if (raised == NULL_TREE)\n-\t\t\t    goto nada;\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n-\t\t    prev = this_raise;\n-\t\t}\n-\t      handled = TREE_CHAIN (handled);\n-\t    }\n-\t  if (prev == NULL_TREE)\n-\t    prev = raised;\n-\t  if (prev)\n-\t    TREE_CHAIN (prev) = n->data.except_stmt.raised;\n-\tnada:\n-\t  n->data.except_stmt.raised = raised;\n-\t}\n-    }\n-\n-  POPSTACK (except_stack);\n-  last_expr_type = 0;\n-  return raised;\n-}\n-\n-/* Record that exception EX is caught by this exception handler.\n-   Return nonzero if in exception handling construct, otherwise return 0.  */\n-int\n-expand_catch (ex)\n-     tree ex;\n-{\n-  tree *raises_ptr;\n-\n-  if (except_stack == 0)\n-    return 0;\n-  raises_ptr = &except_stack->data.except_stmt.handled;\n-  if (*raises_ptr != void_type_node\n-      && ex != NULL_TREE\n-      && ! value_member (ex, *raises_ptr))\n-    *raises_ptr = tree_cons (NULL_TREE, ex, *raises_ptr);\n-  return 1;\n-}\n-\n-/* Record that this exception handler catches all exceptions.\n-   Return nonzero if in exception handling construct, otherwise return 0.  */\n-\n-int\n-expand_catch_default ()\n-{\n-  if (except_stack == 0)\n-    return 0;\n-  except_stack->data.except_stmt.handled = void_type_node;\n-  return 1;\n-}\n-\n-int\n-expand_end_catch ()\n-{\n-  if (except_stack == 0 || except_stack->data.except_stmt.after_label == 0)\n-    return 0;\n-  expand_goto_internal (NULL_TREE, except_stack->data.except_stmt.after_label,\n-\t\t\tNULL_RTX);\n-  return 1;\n-}\n-\f\n /* Generate RTL for the start of an if-then.  COND is the expression\n    whose truth should be tested.\n "}]}