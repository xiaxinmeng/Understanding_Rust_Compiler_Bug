{"sha": "5d5148841e6b19d143273d5474b24f9dadc34776", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ1MTQ4ODQxZTZiMTlkMTQzMjczZDU0NzRiMjRmOWRhZGMzNDc3Ng==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2018-05-30T08:56:29Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-30T08:56:29Z"}, "message": "[Ada] Unnesting: properly handle subprogram instantiations\n\n2018-05-30  Ed Schonberg  <schonberg@adacore.com>\n\ngcc/ada/\n\n\t* exp_unst.adb (Visit_Node): Handle properly subprogram instantiations\n\tthat have no corresponding body and appear as attributes of the\n\tcorresponding wrapper package declaration.\n\t(Register_Subprogram): New subprogram, used for subprogram bodies and\n\tfor subprogram instantiations to enter callable entity into Subp table.\n\nFrom-SVN: r260925", "tree": {"sha": "a30469117c846bb073f7c71f624ea5f6ace4efb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a30469117c846bb073f7c71f624ea5f6ace4efb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d5148841e6b19d143273d5474b24f9dadc34776", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d5148841e6b19d143273d5474b24f9dadc34776", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d5148841e6b19d143273d5474b24f9dadc34776", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d5148841e6b19d143273d5474b24f9dadc34776/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1df65b8982b0b941a3d6ac1e84437fff08e3462c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1df65b8982b0b941a3d6ac1e84437fff08e3462c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1df65b8982b0b941a3d6ac1e84437fff08e3462c"}], "stats": {"total": 547, "additions": 293, "deletions": 254}, "files": [{"sha": "e5b1868f67c5216805b0c0d6065eed4ff48e8313", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5148841e6b19d143273d5474b24f9dadc34776/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5148841e6b19d143273d5474b24f9dadc34776/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5d5148841e6b19d143273d5474b24f9dadc34776", "patch": "@@ -1,3 +1,11 @@\n+2018-05-30  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_unst.adb (Visit_Node): Handle properly subprogram instantiations\n+\tthat have no corresponding body and appear as attributes of the\n+\tcorresponding wrapper package declaration.\n+\t(Register_Subprogram): New subprogram, used for subprogram bodies and\n+\tfor subprogram instantiations to enter callable entity into Subp table.\n+\n 2018-05-30  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* libgnat/s-secsta.adb: Reimplement the secondary stack support."}, {"sha": "c65f5ca3861b2de32a6d31a55b1b1eaef6e4a910", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 285, "deletions": 254, "changes": 539, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5148841e6b19d143273d5474b24f9dadc34776/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5148841e6b19d143273d5474b24f9dadc34776/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=5d5148841e6b19d143273d5474b24f9dadc34776", "patch": "@@ -367,9 +367,7 @@ package body Exp_Unst is\n             Callee : Entity_Id;\n \n             procedure Check_Static_Type\n-              (T  : Entity_Id;\n-               N  : Node_Id;\n-               DT : in out Boolean);\n+              (T : Entity_Id; N : Node_Id; DT : in out Boolean);\n             --  Given a type T, checks if it is a static type defined as a type\n             --  with no dynamic bounds in sight. If so, the only action is to\n             --  set Is_Static_Type True for T. If T is not a static type, then\n@@ -388,14 +386,16 @@ package body Exp_Unst is\n             --  from within Caller to entity E declared in Callee. E can be a\n             --  an object or a type.\n \n+            procedure Register_Subprogram (E : Entity_Id; Bod : Node_Id);\n+            --  Enter a subprogram whose body is visible or which is a\n+            --  subprogram instance into the subprogram table.\n+\n             -----------------------\n             -- Check_Static_Type --\n             -----------------------\n \n             procedure Check_Static_Type\n-              (T  : Entity_Id;\n-               N  : Node_Id;\n-               DT : in out Boolean)\n+              (T : Entity_Id; N : Node_Id; DT : in out Boolean)\n             is\n                procedure Note_Uplevel_Bound (N : Node_Id; Ref : Node_Id);\n                --  N is the bound of a dynamic type. This procedure notes that\n@@ -414,9 +414,9 @@ package body Exp_Unst is\n                begin\n                   --  Entity name case. Make sure that the entity is declared\n                   --  in a subprogram. This may not be the case for for a type\n-                  --  in a loop appearing in a precondition. Exclude explicitly\n-                  --  discriminants (that can appear in bounds of discriminated\n-                  --  components).\n+                  --  in a loop appearing in a precondition.\n+                  --  Exclude explicitly  discriminants (that can appear\n+                  --  in bounds of discriminated components).\n \n                   if Is_Entity_Name (N) then\n                      if Present (Entity (N))\n@@ -613,316 +613,341 @@ package body Exp_Unst is\n                Urefs.Append ((N, Full_E, Caller, Callee));\n             end Note_Uplevel_Ref;\n \n+            -------------------------\n+            -- Register_Subprogram --\n+            -------------------------\n+\n+            procedure Register_Subprogram (E : Entity_Id; Bod : Node_Id) is\n+               L : constant Nat := Get_Level (Subp, E);\n+            begin\n+               Subps.Append\n+                 ((Ent           => E,\n+                   Bod           => Bod,\n+                   Lev           => L,\n+                   Reachable     => False,\n+                   Uplevel_Ref   => L,\n+                   Declares_AREC => False,\n+                   Uents         => No_Elist,\n+                   Last          => 0,\n+                   ARECnF        => Empty,\n+                   ARECn         => Empty,\n+                   ARECnT        => Empty,\n+                   ARECnPT       => Empty,\n+                   ARECnP        => Empty,\n+                   ARECnU        => Empty));\n+               Set_Subps_Index (E, UI_From_Int (Subps.Last));\n+            end Register_Subprogram;\n+\n          --  Start of processing for Visit_Node\n \n          begin\n-            --  Record a call\n+            case Nkind (N) is\n \n-            if Nkind_In (N, N_Procedure_Call_Statement, N_Function_Call) then\n+               --  Record a subprogram call\n \n-              --  We are only interested in direct calls, not indirect calls\n-              --  (where Name (N) is an explicit dereference) at least for now!\n+               when N_Procedure_Call_Statement | N_Function_Call =>\n+                  --  We are only interested in direct calls, not indirect\n+                  --  calls (where Name (N) is an explicit dereference).\n+                  --  at least for now!\n \n-               if Nkind (Name (N)) in N_Has_Entity then\n-                  Ent := Entity (Name (N));\n+                  if Nkind (Name (N)) in N_Has_Entity then\n+                     Ent := Entity (Name (N));\n \n-                  --  We are only interested in calls to subprograms nested\n-                  --  within Subp. Calls to Subp itself or to subprograms\n-                  --  that are outside the nested structure do not affect us.\n+                     --  We are only interested in calls to subprograms nested\n+                     --  within Subp. Calls to Subp itself or to subprograms\n+                     --  outside the nested structure do not affect us.\n \n-                  if Scope_Within (Ent, Subp) then\n-\n-                     --  Ignore calls to imported routines\n+                     if Scope_Within (Ent, Subp)\n+                        and then Is_Subprogram (Ent)\n+                        and then not Is_Imported (Ent)\n+                     then\n+                        Append_Unique_Call ((N, Current_Subprogram, Ent));\n+                     end if;\n+                  end if;\n \n-                     if Is_Imported (Ent) then\n-                        null;\n+                  --  For all calls where the formal is an unconstrained array\n+                  --  and the actual is constrained we need to check the bounds\n+                  --  for uplevel references.\n \n-                     --  Here we have a call to keep and analyze\n+                  declare\n+                     Subp   : Entity_Id;\n+                     Actual : Entity_Id;\n+                     Formal : Node_Id;\n+                     DT     : Boolean := False;\n \n+                  begin\n+                     if Nkind (Name (N)) = N_Explicit_Dereference then\n+                        Subp := Etype (Name (N));\n                      else\n-                        --  Both caller and callee must be subprograms\n+                        Subp := Entity (Name (N));\n+                     end if;\n \n-                        if Is_Subprogram (Ent) then\n-                           Append_Unique_Call ((N, Current_Subprogram, Ent));\n+                     Actual := First_Actual (N);\n+                     Formal := First_Formal_With_Extras (Subp);\n+                     while Present (Actual) loop\n+                        if Is_Array_Type (Etype (Formal))\n+                          and then not Is_Constrained (Etype (Formal))\n+                          and then Is_Constrained (Etype (Actual))\n+                        then\n+                           Check_Static_Type (Etype (Actual), Empty, DT);\n                         end if;\n-                     end if;\n-                  end if;\n-               end if;\n \n-               --  for all calls where the formal is an unconstrained array and\n-               --  the actual is constrained we need to check the bounds.\n+                        Next_Actual (Actual);\n+                        Next_Formal_With_Extras (Formal);\n+                     end loop;\n+                  end;\n \n-               declare\n-                  Actual : Entity_Id;\n-                  DT     : Boolean := False;\n-                  Formal : Node_Id;\n-                  Subp   : Entity_Id;\n+               --  An At_End_Proc in a statement sequence indicates that\n+               --  there's a call from the enclosing construct or block\n+               --  to that subprogram. As above, the called entity must\n+               --  be local and not imported.\n \n-               begin\n-                  if Nkind (Name (N)) = N_Explicit_Dereference then\n-                     Subp := Etype (Name (N));\n-                  else\n-                     Subp := Entity (Name (N));\n+               when N_Handled_Sequence_Of_Statements =>\n+                  if Present (At_End_Proc (N))\n+                    and then Scope_Within (Entity (At_End_Proc (N)), Subp)\n+                    and then not Is_Imported (Entity (At_End_Proc (N)))\n+                  then\n+                     Append_Unique_Call ((N, Current_Subprogram,\n+                                           Entity (At_End_Proc (N))));\n                   end if;\n \n-                  Actual := First_Actual (N);\n-                  Formal := First_Formal_With_Extras (Subp);\n-                  while Present (Actual) loop\n-                     if Is_Array_Type (Etype (Formal))\n-                       and then not Is_Constrained (Etype (Formal))\n-                       and then Is_Constrained (Etype (Actual))\n-                     then\n-                        Check_Static_Type (Etype (Actual), Empty, DT);\n-                     end if;\n+               --  A 'Access reference is a (potential) call.\n+               --  Other attributes require special handling.\n \n-                     Next_Actual (Actual);\n-                     Next_Formal_With_Extras (Formal);\n-                  end loop;\n-               end;\n+               when N_Attribute_Reference =>\n+                  declare\n+                     Attr : constant Attribute_Id :=\n+                              Get_Attribute_Id (Attribute_Name (N));\n+                  begin\n+                     case Attr is\n+                        when Attribute_Access\n+                           | Attribute_Unchecked_Access\n+                           | Attribute_Unrestricted_Access\n+                        =>\n+                           if Nkind (Prefix (N)) in N_Has_Entity then\n+                              Ent := Entity (Prefix (N));\n+\n+                              --  We only need to examine calls to subprograms\n+                              --  nested within current Subp.\n+\n+                              if Scope_Within (Ent, Subp) then\n+                                 if Is_Imported (Ent) then\n+                                    null;\n+\n+                                 elsif Is_Subprogram (Ent) then\n+                                    Append_Unique_Call\n+                                      ((N, Current_Subprogram, Ent));\n+                                 end if;\n+                              end if;\n+                           end if;\n \n-            elsif Nkind (N) = N_Handled_Sequence_Of_Statements\n-              and then Present (At_End_Proc (N))\n-            then\n-               --  An At_End_Proc means there's a call from this block to that\n-               --  subprogram.\n+                        --  References to bounds can be uplevel references if\n+                        --  the type isn't static.\n+\n+                        when Attribute_First\n+                           | Attribute_Last\n+                           | Attribute_Length\n+                        =>\n+                           --  Special-case attributes of objects whose bounds\n+                           --  may be uplevel references. More complex prefixes\n+                           --  handled during full traversal. Note that if the\n+                           --  nominal subtype of the prefix is unconstrained,\n+                           --  the bound must be obtained from the object, not\n+                           --  from the (possibly) uplevel reference.\n+\n+                           if Is_Constrained (Etype (Prefix (N))) then\n+                              declare\n+                                 DT : Boolean := False;\n+                              begin\n+                                 Check_Static_Type (Etype (Prefix (N)),\n+                                                    Empty, DT);\n+                              end;\n \n-               Append_Unique_Call\n-                 ((N, Current_Subprogram, Entity (At_End_Proc (N))));\n+                              return OK;\n+                           end if;\n \n-            --  Handle a 'Access as a (potential) call\n+                        when others =>\n+                           null;\n+                     end case;\n+                  end;\n \n-            elsif Nkind (N) = N_Attribute_Reference then\n-               declare\n-                  Attr : constant Attribute_Id :=\n-                           Get_Attribute_Id (Attribute_Name (N));\n+               --  Indexed references can be uplevel if the type isn't static\n+               --  and if the lower bound (or an inner bound for a multi-\n+               --  dimensional array) is uplevel.\n \n-               begin\n-                  case Attr is\n-                     when Attribute_Access\n-                        | Attribute_Unchecked_Access\n-                        | Attribute_Unrestricted_Access\n-                     =>\n-                        if Nkind (Prefix (N)) in N_Has_Entity then\n-                           Ent := Entity (Prefix (N));\n-\n-                           --  We are only interested in calls to subprograms\n-                           --  nested within Subp.\n-\n-                           if Scope_Within (Ent, Subp) then\n-                              if Is_Imported (Ent) then\n-                                 null;\n-\n-                              elsif Is_Subprogram (Ent) then\n-                                 Append_Unique_Call\n-                                   ((N, Current_Subprogram, Ent));\n-                              end if;\n-                           end if;\n-                        end if;\n+               when N_Indexed_Component | N_Slice =>\n+                  if Is_Constrained (Etype (Prefix (N))) then\n+                     declare\n+                        DT : Boolean := False;\n+                     begin\n+                        Check_Static_Type (Etype (Prefix (N)), Empty, DT);\n+                     end;\n+                  end if;\n \n-                     --  References to bounds can be uplevel references if the\n-                     --  type isn't static.\n-\n-                     when Attribute_First\n-                        | Attribute_Last\n-                        | Attribute_Length\n-                     =>\n-                        --  Special-case attributes of objects whose bounds\n-                        --  may be uplevel references. More complex prefixes\n-                        --  handled during full traversal. Note that if the\n-                        --  nominal subtype of the prefix is unconstrained,\n-                        --  the bound must be obtained from the object, not\n-                        --  from the (possibly) uplevel reference.\n-\n-                        if Is_Constrained (Etype (Prefix (N))) then\n-                           declare\n-                              DT : Boolean := False;\n-                           begin\n-                              Check_Static_Type\n-                                (Etype (Prefix (N)), Empty, DT);\n-                           end;\n+                  --  A selected component can have an implicit up-level\n+                  --  reference due to the bounds of previous fields in the\n+                  --  record. We simplify the processing here by examining\n+                  --  all components of the record.\n \n-                           return OK;\n-                        end if;\n+                  --  Selected components appear as unit names and end labels\n+                  --  for child units. Prefixes of these nodes denote parent\n+                  --  units and carry no type information so they are skipped.\n \n-                     when others =>\n-                        null;\n-                  end case;\n-               end;\n+               when N_Selected_Component =>\n+                  if Present (Etype (Prefix (N))) then\n+                     declare\n+                        DT : Boolean := False;\n+                     begin\n+                        Check_Static_Type (Etype (Prefix (N)), Empty, DT);\n+                     end;\n+                  end if;\n \n-            --  Indexed references can be uplevel if the type isn't static and\n-            --  if the lower bound (or an inner bound for a multidimensional\n-            --  array) is uplevel.\n+               --  Record a subprogram. We record a subprogram body that acts\n+               --  as a spec. Otherwise we record a subprogram declaration,\n+               --  providing that it has a corresponding body we can get hold\n+               --  of. The case of no corresponding body being available is\n+               --  ignored for now.\n \n-            elsif Nkind_In (N, N_Indexed_Component, N_Slice)\n-              and then Is_Constrained (Etype (Prefix (N)))\n-            then\n-               declare\n-                  DT : Boolean := False;\n-               begin\n-                  Check_Static_Type (Etype (Prefix (N)), Empty, DT);\n-               end;\n+               when N_Subprogram_Body =>\n+                  Ent := Unique_Defining_Entity (N);\n \n-            --  A selected component can have an implicit up-level reference\n-            --  due to the bounds of previous fields in the record. We simplify\n-            --  the processing here by examining all components of the record.\n+                  --  Ignore generic subprogram\n \n-            --  Selected components appear as unit names and end labels for\n-            --  child units. The prefixes of these nodes denote parent units\n-            --  and carry no type information so they are skipped.\n+                  if Is_Generic_Subprogram (Ent) then\n+                     return Skip;\n+                  end if;\n \n-            elsif Nkind (N) = N_Selected_Component\n-              and then Present (Etype (Prefix (N)))\n-            then\n-               declare\n-                  DT : Boolean := False;\n-               begin\n-                  Check_Static_Type (Etype (Prefix (N)), Empty, DT);\n-               end;\n+                  --  Make new entry in subprogram table if not already made\n+                  Register_Subprogram (Ent, N);\n \n-            --  Record a subprogram. We record a subprogram body that acts as a\n-            --  spec. Otherwise we record a subprogram declaration, providing\n-            --  that it has a corresponding body we can get hold of. The case\n-            --  of no corresponding body being available is ignored for now.\n+                  --  We make a recursive call to scan the subprogram body, so\n+                  --  that we can save and restore Current_Subprogram.\n \n-            elsif Nkind (N) = N_Subprogram_Body then\n-               Ent := Unique_Defining_Entity (N);\n+                  declare\n+                     Save_CS : constant Entity_Id := Current_Subprogram;\n+                     Decl    : Node_Id;\n \n-               --  Ignore generic subprogram\n+                  begin\n+                     Current_Subprogram := Ent;\n \n-               if Is_Generic_Subprogram (Ent) then\n-                  return Skip;\n-               end if;\n+                     --  Scan declarations\n \n-               --  Make new entry in subprogram table if not already made\n+                     Decl := First (Declarations (N));\n+                     while Present (Decl) loop\n+                        Visit (Decl);\n+                        Next (Decl);\n+                     end loop;\n \n-               declare\n-                  L : constant Nat := Get_Level (Subp, Ent);\n-               begin\n-                  Subps.Append\n-                    ((Ent           => Ent,\n-                      Bod           => N,\n-                      Lev           => L,\n-                      Reachable     => False,\n-                      Uplevel_Ref   => L,\n-                      Declares_AREC => False,\n-                      Uents         => No_Elist,\n-                      Last          => 0,\n-                      ARECnF        => Empty,\n-                      ARECn         => Empty,\n-                      ARECnT        => Empty,\n-                      ARECnPT       => Empty,\n-                      ARECnP        => Empty,\n-                      ARECnU        => Empty));\n-                  Set_Subps_Index (Ent, UI_From_Int (Subps.Last));\n-               end;\n+                     --  Scan statements\n \n-               --  We make a recursive call to scan the subprogram body, so\n-               --  that we can save and restore Current_Subprogram.\n+                     Visit (Handled_Statement_Sequence (N));\n \n-               declare\n-                  Save_CS : constant Entity_Id := Current_Subprogram;\n-                  Decl    : Node_Id;\n+                     --  Restore current subprogram setting\n \n-               begin\n-                  Current_Subprogram := Ent;\n+                     Current_Subprogram := Save_CS;\n+                  end;\n \n-                  --  Scan declarations\n+                  --  Now at this level, return skipping the subprogram body\n+                  --  descendants, since we already took care of them!\n \n-                  Decl := First (Declarations (N));\n-                  while Present (Decl) loop\n-                     Visit (Decl);\n-                     Next (Decl);\n-                  end loop;\n+                  return Skip;\n \n-                  --  Scan statements\n+               --  If we have a body stub, visit the associated subunit,\n+               --  which is a semantic descendant of the stub.\n \n-                  Visit (Handled_Statement_Sequence (N));\n+               when N_Body_Stub =>\n+                  Visit (Library_Unit (N));\n \n-                  --  Restore current subprogram setting\n+               --  A declaration of a wrapper package indicates a subprogram\n+               --  instance for which there is no explicit body. Enter the\n+               --  subprogram instance in the table.\n \n-                  Current_Subprogram := Save_CS;\n-               end;\n+               when N_Package_Declaration =>\n+                  if Is_Wrapper_Package (Defining_Entity (N)) then\n+                     Register_Subprogram\n+                       (Related_Instance (Defining_Entity (N)), Empty);\n+                  end if;\n \n-               --  Now at this level, return skipping the subprogram body\n-               --  descendants, since we already took care of them!\n+               --  Skip generic declarations\n+\n+               when N_Generic_Declaration =>\n+                  return Skip;\n \n-               return Skip;\n+               --  Skip generic package body\n+\n+               when N_Package_Body =>\n+                  if Present (Corresponding_Spec (N))\n+                    and then Ekind (Corresponding_Spec (N)) = E_Generic_Package\n+                  then\n+                     return Skip;\n+                  end if;\n \n-            --  Record an uplevel reference\n+               --  Otherwise record an uplevel reference\n \n-            elsif Nkind (N) in N_Has_Entity and then Present (Entity (N)) then\n-               Ent := Entity (N);\n+               when others =>\n+                  if\n+                    Nkind (N) in N_Has_Entity and then Present (Entity (N))\n+                  then\n+                     Ent := Entity (N);\n \n-               --  Only interested in entities declared within our nest\n+                     --  Only interested in entities declared within our nest\n \n-               if not Is_Library_Level_Entity (Ent)\n-                 and then Scope_Within_Or_Same (Scope (Ent), Subp)\n+                     if not Is_Library_Level_Entity (Ent)\n+                       and then Scope_Within_Or_Same (Scope (Ent), Subp)\n \n-                  --  Skip entities defined in inlined subprograms\n+                        --  Skip entities defined in inlined subprograms\n \n-                 and then Chars (Enclosing_Subprogram (Ent)) /= Name_uParent\n-                 and then\n+                       and then\n+                         Chars (Enclosing_Subprogram (Ent)) /= Name_uParent\n \n-                   --  Constants and variables are potentially\n-                   --  uplevel references to global declarations.\n+                      --  Constants and variables are potentially\n+                      --  uplevel references to global declarations.\n \n-                   (Ekind_In (Ent, E_Constant, E_Variable)\n+                       and then\n+                         (Ekind_In (Ent, E_Constant, E_Variable)\n \n                      --  Formals are interesting, but not if being used as mere\n                      --  names of parameters for name notation calls.\n \n-                     or else\n-                       (Is_Formal (Ent)\n-                         and then not\n-                          (Nkind (Parent (N)) = N_Parameter_Association\n-                            and then Selector_Name (Parent (N)) = N))\n+                        or else\n+                          (Is_Formal (Ent)\n+                            and then not\n+                             (Nkind (Parent (N)) = N_Parameter_Association\n+                               and then Selector_Name (Parent (N)) = N))\n \n-                     --  Types other than known Is_Static types are interesting\n+                        --  Types other than known Is_Static types are\n+                        --  potentially interesting\n \n-                     or else (Is_Type (Ent)\n-                               and then not Is_Static_Type (Ent)))\n-               then\n-                  --  Here we have a possible interesting uplevel reference\n+                        or else (Is_Type (Ent)\n+                                  and then not Is_Static_Type (Ent)))\n+                     then\n+                        --  Here we have a potentially interesting uplevel\n+                        --  reference to examine.\n \n-                  if Is_Type (Ent) then\n-                     declare\n-                        DT : Boolean := False;\n+                        if Is_Type (Ent) then\n+                           declare\n+                              DT : Boolean := False;\n \n-                     begin\n-                        Check_Static_Type (Ent, N, DT);\n+                           begin\n+                              Check_Static_Type (Ent, N, DT);\n \n-                        if Is_Static_Type (Ent) then\n-                           return OK;\n+                              if Is_Static_Type (Ent) then\n+                                 return OK;\n+                              end if;\n+                           end;\n                         end if;\n-                     end;\n-                  end if;\n \n-                  Caller := Current_Subprogram;\n-                  Callee := Enclosing_Subprogram (Ent);\n+                        Caller := Current_Subprogram;\n+                        Callee := Enclosing_Subprogram (Ent);\n \n-                  if Callee /= Caller and then not Is_Static_Type (Ent) then\n-                     Note_Uplevel_Ref (Ent, N, Caller, Callee);\n+                        if Callee /= Caller\n+                          and then not Is_Static_Type (Ent)\n+                        then\n+                           Note_Uplevel_Ref (Ent, N, Caller, Callee);\n+                        end if;\n+                     end if;\n                   end if;\n-               end if;\n-\n-            --  If we have a body stub, visit the associated subunit\n-\n-            elsif Nkind (N) in N_Body_Stub then\n-               Visit (Library_Unit (N));\n-\n-            --  Skip generic declarations\n-\n-            elsif Nkind (N) in N_Generic_Declaration then\n-               return Skip;\n-\n-            --  Skip generic package body\n-\n-            elsif Nkind (N) = N_Package_Body\n-              and then Present (Corresponding_Spec (N))\n-              and then Ekind (Corresponding_Spec (N)) = E_Generic_Package\n-            then\n-               return Skip;\n-            end if;\n+            end case;\n \n             --  Fall through to continue scanning children of this node\n \n@@ -1127,14 +1152,20 @@ package body Exp_Unst is\n \n                   --  Rewrite declaration and body to null statements\n \n-                  Spec := Corresponding_Spec (STJ.Bod);\n+                  --  A subprogram instantiation does not have an explicit\n+                  --  body. If unused, we could remove the corresponding\n+                  --  wrapper package and its body (TBD).\n \n-                  if Present (Spec) then\n-                     Decl := Parent (Declaration_Node (Spec));\n-                     Rewrite (Decl, Make_Null_Statement (Sloc (Decl)));\n-                  end if;\n+                  if Present (STJ.Bod) then\n+                     Spec := Corresponding_Spec (STJ.Bod);\n \n-                  Rewrite (STJ.Bod, Make_Null_Statement (Sloc (STJ.Bod)));\n+                     if Present (Spec) then\n+                        Decl := Parent (Declaration_Node (Spec));\n+                        Rewrite (Decl, Make_Null_Statement (Sloc (Decl)));\n+                     end if;\n+\n+                     Rewrite (STJ.Bod, Make_Null_Statement (Sloc (STJ.Bod)));\n+                  end if;\n                end if;\n             end;\n          end loop;"}]}