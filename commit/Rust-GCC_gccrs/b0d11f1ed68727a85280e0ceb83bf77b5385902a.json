{"sha": "b0d11f1ed68727a85280e0ceb83bf77b5385902a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBkMTFmMWVkNjg3MjdhODUyODBlMGNlYjgzYmY3N2I1Mzg1OTAyYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2019-08-29T14:06:32Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2019-08-29T14:06:32Z"}, "message": "[preprocessor] Include stacking\n\nhttps://gcc.gnu.org/ml/gcc-patches/2019-08/msg01971.html\n\t* internal.h (enum include_type): Add IT_MAIN, IT_DIRECTIVE_HWM,\n\tIT_HEADER_HWM.\n\t(_cpp_stack_file): Take include_type, not a bool.\n\t* files.c (_cpp_find_file): Refactor to not hide an if inside a\n\tfor conditional.\n\t(should_stack_file): Break apart to ...\n\t(is_known_idempotent_file, has_unique_contents): ... these.\n\t(_cpp_stack_file): Replace IMPORT boolean with include_type enum.\n\tRefactor to use new predicates.  Do linemap compensation here ...\n\t(_cpp_stack_include): ... not here.\n\t* init.c (cpp_read_main_file): Pass IT_MAIN to _cpp_stack_file.\n\nFrom-SVN: r275034", "tree": {"sha": "d343c7483c9b5485fe33ff454c466a9d24d4f765", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d343c7483c9b5485fe33ff454c466a9d24d4f765"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0d11f1ed68727a85280e0ceb83bf77b5385902a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d11f1ed68727a85280e0ceb83bf77b5385902a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0d11f1ed68727a85280e0ceb83bf77b5385902a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d11f1ed68727a85280e0ceb83bf77b5385902a/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d02a0412422b144f6e84605997302a1c36e81600", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d02a0412422b144f6e84605997302a1c36e81600", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d02a0412422b144f6e84605997302a1c36e81600"}], "stats": {"total": 320, "additions": 165, "deletions": 155}, "files": [{"sha": "8af0ad2eacbc832226661bd88d5b7cb27f28b3be", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0d11f1ed68727a85280e0ceb83bf77b5385902a/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0d11f1ed68727a85280e0ceb83bf77b5385902a/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=b0d11f1ed68727a85280e0ceb83bf77b5385902a", "patch": "@@ -1,3 +1,17 @@\n+2019-08-29  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* internal.h (enum include_type): Add IT_MAIN, IT_DIRECTIVE_HWM,\n+\tIT_HEADER_HWM.\n+\t(_cpp_stack_file): Take include_type, not a bool.\n+\t* files.c (_cpp_find_file): Refactor to not hide an if inside a\n+\tfor conditional.\n+\t(should_stack_file): Break apart to ...\n+\t(is_known_idempotent_file, has_unique_contents): ... these.\n+\t(_cpp_stack_file): Replace IMPORT boolean with include_type enum.\n+\tRefactor to use new predicates.  Do linemap compensation here ...\n+\t(_cpp_stack_include): ... not here.\n+\t* init.c (cpp_read_main_file): Pass IT_MAIN to _cpp_stack_file.\n+\n 2019-08-28  Nathan Sidwell  <nathan@acm.org>\n \n \t* directives-only.c (_cpp_preprocess_dir_only): Use false, not"}, {"sha": "ee31aff606d8a063850b20a2461d7c7d8c3e8ad8", "filename": "libcpp/files.c", "status": "modified", "additions": 145, "deletions": 152, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0d11f1ed68727a85280e0ceb83bf77b5385902a/libcpp%2Ffiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0d11f1ed68727a85280e0ceb83bf77b5385902a/libcpp%2Ffiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ffiles.c?ref=b0d11f1ed68727a85280e0ceb83bf77b5385902a", "patch": "@@ -176,8 +176,6 @@ static bool read_file_guts (cpp_reader *pfile, _cpp_file *file,\n \t\t\t    location_t loc);\n static bool read_file (cpp_reader *pfile, _cpp_file *file,\n \t\t       location_t loc);\n-static bool should_stack_file (cpp_reader *, _cpp_file *file, bool import,\n-\t\t\t       location_t loc);\n static struct cpp_dir *search_path_head (cpp_reader *, const char *fname,\n \t\t\t\t int angle_brackets, enum include_type);\n static const char *dir_name_of_file (_cpp_file *file);\n@@ -536,79 +534,86 @@ _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir,\n        || (pfile->buffer\n \t   && pfile->buffer->file->implicit_preinclude));\n \n-  /* Try each path in the include chain.  */\n-  for (; !fake ;)\n-    {\n-      if (find_file_in_dir (pfile, file, &invalid_pch, loc))\n-\tbreak;\n-\n-      file->dir = file->dir->next;\n-      if (file->dir == NULL)\n-\t{\n-\t  if (search_path_exhausted (pfile, fname, file))\n-\t    {\n-\t      /* Although this file must not go in the cache, because\n-\t\t the file found might depend on things (like the current file)\n-\t\t that aren't represented in the cache, it still has to go in\n-\t\t the list of all files so that #import works.  */\n-\t      file->next_file = pfile->all_files;\n-\t      pfile->all_files = file;\n-\t      if (*hash_slot == NULL)\n-\t\t{\n-\t\t  /* If *hash_slot is NULL, the above htab_find_slot_with_hash\n-\t\t     call just created the slot, but we aren't going to store\n-\t\t     there anything, so need to remove the newly created entry.\n-\t\t     htab_clear_slot requires that it is non-NULL, so store\n-\t\t     there some non-NULL pointer, htab_clear_slot will\n-\t\t     overwrite it immediately.  */\n-\t\t  *hash_slot = file;\n-\t\t  htab_clear_slot (pfile->file_hash, hash_slot);\n-\t\t}\n-\t      return file;\n-\t    }\n-\n-\t  if (invalid_pch)\n-\t    {\n-\t      cpp_error (pfile, CPP_DL_ERROR,\n-\t       \"one or more PCH files were found, but they were invalid\");\n-\t      if (!cpp_get_options (pfile)->warn_invalid_pch)\n-\t\tcpp_error (pfile, CPP_DL_ERROR,\n-\t\t\t   \"use -Winvalid-pch for more information\");\n-\t    }\n-\t  if (implicit_preinclude)\n-\t    {\n-\t      free ((char *) file->name);\n-\t      free (file);\n-\t      if (*hash_slot == NULL)\n-\t\t{\n-\t\t  /* See comment on the above htab_clear_slot call.  */\n-\t\t  *hash_slot = file;\n-\t\t  htab_clear_slot (pfile->file_hash, hash_slot);\n-\t\t}\n-\t      return NULL;\n-\t    }\n-\t  else\n-\t    open_file_failed (pfile, file, angle_brackets, loc);\n+  if (!fake)\n+    /* Try each path in the include chain.  */\n+    for (;;)\n+      {\n+\tif (find_file_in_dir (pfile, file, &invalid_pch, loc))\n \t  break;\n-\t}\n \n-      /* Only check the cache for the starting location (done above)\n-\t and the quote and bracket chain heads because there are no\n-\t other possible starting points for searches.  */\n-      if (file->dir == pfile->bracket_include)\n-\tsaw_bracket_include = true;\n-      else if (file->dir == pfile->quote_include)\n-\tsaw_quote_include = true;\n-      else\n-\tcontinue;\n+\tfile->dir = file->dir->next;\n+\tif (file->dir == NULL)\n+\t  {\n+\t    if (search_path_exhausted (pfile, fname, file))\n+\t      {\n+\t\t/* Although this file must not go in the cache,\n+\t\t   because the file found might depend on things (like\n+\t\t   the current file) that aren't represented in the\n+\t\t   cache, it still has to go in the list of all files\n+\t\t   so that #import works.  */\n+\t\tfile->next_file = pfile->all_files;\n+\t\tpfile->all_files = file;\n+\t\tif (*hash_slot == NULL)\n+\t\t  {\n+\t\t    /* If *hash_slot is NULL, the above\n+\t\t       htab_find_slot_with_hash call just created the\n+\t\t       slot, but we aren't going to store there\n+\t\t       anything, so need to remove the newly created\n+\t\t       entry.  htab_clear_slot requires that it is\n+\t\t       non-NULL, so store there some non-NULL pointer,\n+\t\t       htab_clear_slot will overwrite it\n+\t\t       immediately.  */\n+\t\t    *hash_slot = file;\n+\t\t    htab_clear_slot (pfile->file_hash, hash_slot);\n+\t\t  }\n+\t\treturn file;\n+\t      }\n+\n+\t    if (invalid_pch)\n+\t      {\n+\t\tcpp_error (pfile, CPP_DL_ERROR,\n+\t\t\t   \"one or more PCH files were found,\"\n+\t\t\t   \" but they were invalid\");\n+\t\tif (!cpp_get_options (pfile)->warn_invalid_pch)\n+\t\t  cpp_error (pfile, CPP_DL_ERROR,\n+\t\t\t     \"use -Winvalid-pch for more information\");\n+\t      }\n+\n+\t    if (implicit_preinclude)\n+\t      {\n+\t\tfree ((char *) file->name);\n+\t\tfree (file);\n+\t\tif (*hash_slot == NULL)\n+\t\t  {\n+\t\t    /* See comment on the above htab_clear_slot call.  */\n+\t\t    *hash_slot = file;\n+\t\t    htab_clear_slot (pfile->file_hash, hash_slot);\n+\t\t  }\n+\t\treturn NULL;\n+\t      }\n \n-      entry = search_cache ((struct cpp_file_hash_entry *) *hash_slot, file->dir);\n-      if (entry)\n-\t{\n-\t  found_in_cache = file->dir;\n-\t  break;\n-\t}\n-    }\n+\t    open_file_failed (pfile, file, angle_brackets, loc);\n+\t    break;\n+\t  }\n+\n+\t/* Only check the cache for the starting location (done above)\n+\t   and the quote and bracket chain heads because there are no\n+\t   other possible starting points for searches.  */\n+\tif (file->dir == pfile->bracket_include)\n+\t  saw_bracket_include = true;\n+\telse if (file->dir == pfile->quote_include)\n+\t  saw_quote_include = true;\n+\telse\n+\t  continue;\n+\n+\tentry\n+\t  = search_cache ((struct cpp_file_hash_entry *) *hash_slot, file->dir);\n+\tif (entry)\n+\t  {\n+\t    found_in_cache = file->dir;\n+\t    break;\n+\t  }\n+      }\n \n   if (entry)\n     {\n@@ -778,18 +783,14 @@ read_file (cpp_reader *pfile, _cpp_file *file, location_t loc)\n   return !file->dont_read;\n }\n \n-/* Returns TRUE if FILE's contents have been successfully placed in\n-   FILE->buffer and the file should be stacked, otherwise false.\n-   Use LOC for any diagnostics.  */\n+/* Returns TRUE if FILE is already known to be idempotent, and should\n+   therefore not be read again.  */\n static bool\n-should_stack_file (cpp_reader *pfile, _cpp_file *file, bool import,\n-\t\t   location_t loc)\n+is_known_idempotent_file (cpp_reader *pfile, _cpp_file *file, bool import)\n {\n-  _cpp_file *f;\n-\n   /* Skip once-only files.  */\n   if (file->once_only)\n-    return false;\n+    return true;\n \n   /* We must mark the file once-only if #import now, before header\n      guard checks.  Otherwise, undefining the header guard might\n@@ -800,13 +801,13 @@ should_stack_file (cpp_reader *pfile, _cpp_file *file, bool import,\n \n       /* Don't stack files that have been stacked before.  */\n       if (file->stack_count)\n-\treturn false;\n+\treturn true;\n     }\n \n   /* Skip if the file had a header guard and the macro is defined.\n      PCH relies on this appearing before the PCH handler below.  */\n   if (file->cmacro && cpp_macro_p (file->cmacro))\n-    return false;\n+    return true;\n \n   /* Handle PCH files immediately; don't stack them.  */\n   if (file->pchname)\n@@ -815,12 +816,19 @@ should_stack_file (cpp_reader *pfile, _cpp_file *file, bool import,\n       file->fd = -1;\n       free ((void *) file->pchname);\n       file->pchname = NULL;\n-      return false;\n+      return true;\n     }\n \n-  if (!read_file (pfile, file, loc))\n-    return false;\n+  return false;\n+}\n \n+/* Return TRUE if file has unique contents, so we should read process\n+   it.  The file's contents must already have been read.  */\n+\n+static bool\n+has_unique_contents (cpp_reader *pfile, _cpp_file *file, bool import,\n+\t\t     location_t loc)\n+{\n   /* Check the file against the PCH file.  This is done before\n      checking against files we've already seen, since it may save on\n      I/O.  */\n@@ -841,18 +849,17 @@ should_stack_file (cpp_reader *pfile, _cpp_file *file, bool import,\n \n   /* We may have read the file under a different name.  Look\n      for likely candidates and compare file contents to be sure.  */\n-  for (f = pfile->all_files; f; f = f->next_file)\n+  for (_cpp_file *f = pfile->all_files; f; f = f->next_file)\n     {\n       if (f == file)\n-\tcontinue;\n+\tcontinue; /* It'sa me!  */\n \n       if ((import || f->once_only)\n \t  && f->err_no == 0\n \t  && f->st.st_mtime == file->st.st_mtime\n \t  && f->st.st_size == file->st.st_size)\n \t{\n \t  _cpp_file *ref_file;\n-\t  bool same_file_p = false;\n \n \t  if (f->buffer && !f->buffer_valid)\n \t    {\n@@ -865,12 +872,11 @@ should_stack_file (cpp_reader *pfile, _cpp_file *file, bool import,\n \t    /* The file is not stacked anymore.  We can reuse it.  */\n \t    ref_file = f;\n \n-\t  same_file_p = read_file (pfile, ref_file, loc)\n-\t\t\t/* Size might have changed in read_file().  */\n-\t\t\t&& ref_file->st.st_size == file->st.st_size\n-\t\t\t&& !memcmp (ref_file->buffer,\n-\t\t\t\t    file->buffer,\n-\t\t\t\t    file->st.st_size);\n+\t  bool same_file_p = (read_file (pfile, ref_file, loc)\n+\t\t\t      /* Size might have changed in read_file().  */\n+\t\t\t      && ref_file->st.st_size == file->st.st_size\n+\t\t\t      && !memcmp (ref_file->buffer, file->buffer,\n+\t\t\t\t\t  file->st.st_size));\n \n \t  if (f->buffer && !f->buffer_valid)\n \t    {\n@@ -879,47 +885,51 @@ should_stack_file (cpp_reader *pfile, _cpp_file *file, bool import,\n \t    }\n \n \t  if (same_file_p)\n-\t    break;\n+\t    /* Already seen under a different name.  */\n+\t    return false;\n \t}\n     }\n \n-  return f == NULL;\n+  return true;\n }\n \n /* Place the file referenced by FILE into a new buffer on the buffer\n    stack if possible.  IMPORT is true if this stacking attempt is\n    because of a #import directive.  Returns true if a buffer is\n    stacked.  Use LOC for any diagnostics.  */\n bool\n-_cpp_stack_file (cpp_reader *pfile, _cpp_file *file, bool import,\n+_cpp_stack_file (cpp_reader *pfile, _cpp_file *file, include_type type,\n \t\t location_t loc)\n {\n-  cpp_buffer *buffer;\n-  int sysp;\n+  if (is_known_idempotent_file (pfile, file, type == IT_IMPORT))\n+    return false;\n \n-  if (!should_stack_file (pfile, file, import, loc))\n+  if (!read_file (pfile, file, loc))\n     return false;\n \n-  if (pfile->buffer == NULL || file->dir == NULL)\n-    sysp = 0;\n-  else\n-    sysp = MAX (pfile->buffer->sysp,  file->dir->sysp);\n+  if (!has_unique_contents (pfile, file, type == IT_IMPORT, loc))\n+    return false;\n+\n+  int sysp = 0;\n+  if (pfile->buffer && file->dir)\n+    sysp = MAX (pfile->buffer->sysp, file->dir->sysp);\n \n   /* Add the file to the dependencies on its first inclusion.  */\n-  if (!file->stack_count\n-      && CPP_OPTION (pfile, deps.style) > !!sysp\n+  if (CPP_OPTION (pfile, deps.style) > (sysp != 0)\n+      && !file->stack_count\n       && file->path[0]\n-      && (!file->main_file || !CPP_OPTION (pfile, deps.ignore_main_file)))\n+      && !(file->main_file && CPP_OPTION (pfile, deps.ignore_main_file)))\n     deps_add_dep (pfile->deps, file->path);\n \n   /* Clear buffer_valid since _cpp_clean_line messes it up.  */\n   file->buffer_valid = false;\n   file->stack_count++;\n \n   /* Stack the buffer.  */\n-  buffer = cpp_push_buffer (pfile, file->buffer, file->st.st_size,\n-\t\t\t    CPP_OPTION (pfile, preprocessed)\n-\t\t\t    && !CPP_OPTION (pfile, directives_only));\n+  cpp_buffer *buffer\n+    = cpp_push_buffer (pfile, file->buffer, file->st.st_size,\n+\t\t       CPP_OPTION (pfile, preprocessed)\n+\t\t       && !CPP_OPTION (pfile, directives_only));\n   buffer->file = file;\n   buffer->sysp = sysp;\n   buffer->to_free = file->buffer_start;\n@@ -928,7 +938,27 @@ _cpp_stack_file (cpp_reader *pfile, _cpp_file *file, bool import,\n   pfile->mi_valid = true;\n   pfile->mi_cmacro = 0;\n \n-  /* Generate the call back.  */\n+  /* Compensate for the increment in linemap_add that occurs when in\n+     do_file_change.   In the case of a normal #include, we're\n+     currently at the start of the line *following* the #include.  A\n+     separate location_t for this location makes no sense (until we do\n+     the LC_LEAVE), and complicates LAST_SOURCE_LINE_LOCATION.  This\n+     does not apply if we found a PCH file (in which case linemap_add\n+     is not called) or we were included from the command-line.  In the\n+     case that the #include is the last line in the file,\n+     highest_location still points to the current line, not the start\n+     of the next line, so we do not decrement in this case.  See\n+     plugin/location-overflow-test-pr83173.h for an example.  */\n+  bool decremented = false;\n+  if (file->pchname == NULL && file->err_no == 0 && type < IT_DIRECTIVE_HWM)\n+    {\n+      decremented = (pfile->line_table->highest_line\n+\t\t     == pfile->line_table->highest_location);\n+      if (decremented)\n+\tpfile->line_table->highest_location--;\n+    }\n+\n+  /* Add line map and do callbacks.  */\n   _cpp_do_file_change (pfile, LC_ENTER, file->path, 1, sysp);\n \n   return true;\n@@ -1009,11 +1039,6 @@ bool\n _cpp_stack_include (cpp_reader *pfile, const char *fname, int angle_brackets,\n \t\t    enum include_type type, location_t loc)\n {\n-  struct cpp_dir *dir;\n-  _cpp_file *file;\n-  bool stacked;\n-  bool decremented = false;\n-\n   /* For -include command-line flags we have type == IT_CMDLINE.\n      When the first -include file is processed we have the case, where\n      pfile->cur_token == pfile->cur_run->base, we are directly called up\n@@ -1026,48 +1051,16 @@ _cpp_stack_include (cpp_reader *pfile, const char *fname, int angle_brackets,\n   if (type == IT_CMDLINE && pfile->cur_token != pfile->cur_run->base)\n     pfile->cur_token[-1].src_loc = 0;\n \n-  dir = search_path_head (pfile, fname, angle_brackets, type);\n+  cpp_dir *dir = search_path_head (pfile, fname, angle_brackets, type);\n   if (!dir)\n     return false;\n \n-  file = _cpp_find_file (pfile, fname, dir, false, angle_brackets,\n-\t\t\t type == IT_DEFAULT, loc);\n+  _cpp_file *file = _cpp_find_file (pfile, fname, dir, false, angle_brackets,\n+\t\t\t\t    type == IT_DEFAULT, loc);\n   if (type == IT_DEFAULT && file == NULL)\n     return false;\n \n-  /* Compensate for the increment in linemap_add that occurs if\n-     _cpp_stack_file actually stacks the file.  In the case of a normal\n-     #include, we're currently at the start of the line *following* the\n-     #include.  A separate location_t for this location makes no\n-     sense (until we do the LC_LEAVE), and complicates\n-     LAST_SOURCE_LINE_LOCATION.  This does not apply if we found a PCH\n-     file (in which case linemap_add is not called) or we were included\n-     from the command-line.  In the case that the #include is the last\n-     line in the file, highest_location still points to the current\n-     line, not the start of the next line, so we do not decrement in\n-     this case.  See plugin/location-overflow-test-pr83173.h for an\n-     example.  */\n-  if (file->pchname == NULL && file->err_no == 0\n-      && type != IT_CMDLINE && type != IT_DEFAULT)\n-    {\n-      int highest_line = linemap_get_expansion_line (pfile->line_table,\n-\t\t\t\t\t\t     pfile->line_table->highest_location);\n-      int source_line = linemap_get_expansion_line (pfile->line_table, loc);\n-      if (highest_line > source_line)\n-\t{\n-\t  pfile->line_table->highest_location--;\n-\t  decremented = true;\n-\t}\n-    }\n-\n-  stacked = _cpp_stack_file (pfile, file, type == IT_IMPORT, loc);\n-\n-  if (decremented && !stacked)\n-    /* _cpp_stack_file didn't stack the file, so let's rollback the\n-       compensation dance we performed above.  */\n-    pfile->line_table->highest_location++;\n-\n-  return stacked;\n+  return _cpp_stack_file (pfile, file, type, loc);\n }\n \n /* Could not open FILE.  The complication is dependency output.  */"}, {"sha": "ccbfc96489d918bb544dac99f96192ea17d6c907", "filename": "libcpp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0d11f1ed68727a85280e0ceb83bf77b5385902a/libcpp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0d11f1ed68727a85280e0ceb83bf77b5385902a/libcpp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finit.c?ref=b0d11f1ed68727a85280e0ceb83bf77b5385902a", "patch": "@@ -651,7 +651,7 @@ cpp_read_main_file (cpp_reader *pfile, const char *fname)\n   if (_cpp_find_failed (pfile->main_file))\n     return NULL;\n \n-  _cpp_stack_file (pfile, pfile->main_file, false, loc);\n+  _cpp_stack_file (pfile, pfile->main_file, IT_MAIN, 0);\n \n   /* For foo.i, read the original filename foo.c now, for the benefit\n      of the front ends.  */"}, {"sha": "d4768aee7133cd2b357d95e8555925bd367baa2f", "filename": "libcpp/internal.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0d11f1ed68727a85280e0ceb83bf77b5385902a/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0d11f1ed68727a85280e0ceb83bf77b5385902a/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=b0d11f1ed68727a85280e0ceb83bf77b5385902a", "patch": "@@ -123,6 +123,10 @@ enum include_type\n    /* Non-directive including mechanisms.  */\n    IT_CMDLINE,  /* -include */\n    IT_DEFAULT,  /* forced header  */\n+   IT_MAIN,     /* main  */\n+\n+   IT_DIRECTIVE_HWM = IT_IMPORT + 1,  /* Directives below this.  */\n+   IT_HEADER_HWM = IT_DEFAULT + 1,    /* Header files below this.  */\n   };\n \n union utoken\n@@ -671,8 +675,7 @@ extern _cpp_file *_cpp_find_file (cpp_reader *, const char *, cpp_dir *,\n extern bool _cpp_find_failed (_cpp_file *);\n extern void _cpp_mark_file_once_only (cpp_reader *, struct _cpp_file *);\n extern void _cpp_fake_include (cpp_reader *, const char *);\n-extern bool _cpp_stack_file (cpp_reader *, _cpp_file*, bool,\n-\t\t\t     location_t);\n+extern bool _cpp_stack_file (cpp_reader *, _cpp_file*, include_type, location_t);\n extern bool _cpp_stack_include (cpp_reader *, const char *, int,\n \t\t\t\tenum include_type, location_t);\n extern int _cpp_compare_file_date (cpp_reader *, const char *, int);"}]}