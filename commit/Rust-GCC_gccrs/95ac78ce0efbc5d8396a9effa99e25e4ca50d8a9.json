{"sha": "95ac78ce0efbc5d8396a9effa99e25e4ca50d8a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVhYzc4Y2UwZWZiYzVkODM5NmE5ZWZmYTk5ZTI1ZTRjYTUwZDhhOQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2016-12-06T10:33:41Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2016-12-06T10:33:41Z"}, "message": "re PR middle-end/78566 (gcc.dg/uninit-pred-6_[abc]*.c regressions on some non-x86 platforms)\n\n\tPR middle-end/78566\n\t* tree-ssa-uninit.c (can_one_predicate_be_invalidated_p): Change\n\targument type to a pred_chain.\n\t(can_chain_union_be_invalidated_p): Use pred_chain instead of a\n\tworklist.\n\t(flatten_out_predicate_chains): Remove.\n\t(uninit_uses_cannot_happen): Rename from\n\tuninit_ops_invalidate_phi_use.\n\tChange logic so that we are checking that the PHI use will\n\tinvalidate _ALL_ possibly uninitialized operands.\n\t(is_use_properly_guarded): Rename call to\n\tuninit_ops_invalidate_phi_use into uninit_uses_cannot_happen.\n\nFrom-SVN: r243288", "tree": {"sha": "b61ff8abafdc4b82bbef89d0cbd5ee6af83a5691", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b61ff8abafdc4b82bbef89d0cbd5ee6af83a5691"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95ac78ce0efbc5d8396a9effa99e25e4ca50d8a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95ac78ce0efbc5d8396a9effa99e25e4ca50d8a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95ac78ce0efbc5d8396a9effa99e25e4ca50d8a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95ac78ce0efbc5d8396a9effa99e25e4ca50d8a9/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "99b7a28da867b09d219a71cd5c29eff45c6effa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99b7a28da867b09d219a71cd5c29eff45c6effa4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99b7a28da867b09d219a71cd5c29eff45c6effa4"}], "stats": {"total": 175, "additions": 68, "deletions": 107}, "files": [{"sha": "8141125068de05fda00658a0600758efd59692d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ac78ce0efbc5d8396a9effa99e25e4ca50d8a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ac78ce0efbc5d8396a9effa99e25e4ca50d8a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95ac78ce0efbc5d8396a9effa99e25e4ca50d8a9", "patch": "@@ -1,3 +1,18 @@\n+2016-12-06  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\tPR middle-end/78566\n+\t* tree-ssa-uninit.c (can_one_predicate_be_invalidated_p): Change\n+\targument type to a pred_chain.\n+\t(can_chain_union_be_invalidated_p): Use pred_chain instead of a\n+\tworklist.\n+\t(flatten_out_predicate_chains): Remove.\n+\t(uninit_uses_cannot_happen): Rename from\n+\tuninit_ops_invalidate_phi_use.\n+\tChange logic so that we are checking that the PHI use will\n+\tinvalidate _ALL_ possibly uninitialized operands.\n+\t(is_use_properly_guarded): Rename call to\n+\tuninit_ops_invalidate_phi_use into uninit_uses_cannot_happen.\n+\n 2016-12-06  Tamar Christina  <tamar.christina@arm.com>\n \n \t* gcc/config/aarch64/arm_neon.h"}, {"sha": "a648995ab8684469bd0364c9ea30d7fe87c653d3", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 53, "deletions": 107, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ac78ce0efbc5d8396a9effa99e25e4ca50d8a9/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ac78ce0efbc5d8396a9effa99e25e4ca50d8a9/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=95ac78ce0efbc5d8396a9effa99e25e4ca50d8a9", "patch": "@@ -2155,115 +2155,66 @@ normalize_preds (pred_chain_union preds, gimple *use_or_def, bool is_use)\n \n static bool\n can_one_predicate_be_invalidated_p (pred_info predicate,\n-\t\t\t\t    vec<pred_info *> worklist)\n+\t\t\t\t    pred_chain use_guard)\n {\n-  for (size_t i = 0; i < worklist.length (); ++i)\n+  for (size_t i = 0; i < use_guard.length (); ++i)\n     {\n-      pred_info *p = worklist[i];\n-\n       /* NOTE: This is a very simple check, and only understands an\n \t exact opposite.  So, [i == 0] is currently only invalidated\n \t by [.NOT. i == 0] or [i != 0].  Ideally we should also\n \t invalidate with say [i > 5] or [i == 8].  There is certainly\n \t room for improvement here.  */\n-      if (pred_neg_p (predicate, *p))\n+      if (pred_neg_p (predicate, use_guard[i]))\n \treturn true;\n     }\n   return false;\n }\n \n-/* Return TRUE if all USE_PREDS can be invalidated by some predicate\n-   in WORKLIST.  */\n+/* Return TRUE if all predicates in UNINIT_PRED are invalidated by\n+   USE_GUARD being true.  */\n \n static bool\n-can_chain_union_be_invalidated_p (pred_chain_union use_preds,\n-\t\t\t\t  vec<pred_info *> worklist)\n+can_chain_union_be_invalidated_p (pred_chain_union uninit_pred,\n+\t\t\t\t  pred_chain use_guard)\n {\n-  /* Remember:\n-       PRED_CHAIN_UNION = PRED_CHAIN1 || PRED_CHAIN2 || PRED_CHAIN3\n-       PRED_CHAIN = PRED_INFO1 && PRED_INFO2 && PRED_INFO3, etc.\n-\n-       We need to invalidate the entire PRED_CHAIN_UNION, which means,\n-       invalidating every PRED_CHAIN in this union.  But to invalidate\n-       an individual PRED_CHAIN, all we need to invalidate is _any_ one\n-       PRED_INFO, by boolean algebra !PRED_INFO1 || !PRED_INFO2...  */\n-  for (size_t i = 0; i < use_preds.length (); ++i)\n+  if (uninit_pred.is_empty ())\n+    return false;\n+  for (size_t i = 0; i < uninit_pred.length (); ++i)\n     {\n-      pred_chain c = use_preds[i];\n-      bool entire_pred_chain_invalidated = false;\n+      pred_chain c = uninit_pred[i];\n       for (size_t j = 0; j < c.length (); ++j)\n-\tif (can_one_predicate_be_invalidated_p (c[j], worklist))\n-\t  {\n-\t    entire_pred_chain_invalidated = true;\n-\t    break;\n-\t  }\n-      if (!entire_pred_chain_invalidated)\n-\treturn false;\n+\tif (!can_one_predicate_be_invalidated_p (c[j], use_guard))\n+\t  return false;\n     }\n   return true;\n }\n \n-/* Flatten out all the factors in all the pred_chain_union's in PREDS\n-   into a WORKLIST of individual PRED_INFO's.\n+/* Return TRUE if none of the uninitialized operands in UNINT_OPNDS\n+   can actually happen if we arrived at a use for PHI.\n \n-   N is the number of pred_chain_union's in PREDS.\n+   PHI_USE_GUARDS are the guard conditions for the use of the PHI.  */\n \n-   Since we are interested in the inverse of the PRED_CHAIN's, by\n-   boolean algebra, an inverse turns those PRED_CHAINS into unions,\n-   which means we can flatten all the factors out for easy access.  */\n-\n-static void\n-flatten_out_predicate_chains (pred_chain_union preds[], size_t n,\n-\t\t\t      vec<pred_info *> *worklist)\n+static bool\n+uninit_uses_cannot_happen (gphi *phi, unsigned uninit_opnds,\n+\t\t\t   pred_chain_union phi_use_guards)\n {\n-  for (size_t i = 0; i < n; ++i)\n-    {\n-      pred_chain_union u = preds[i];\n-      for (size_t j = 0; j < u.length (); ++j)\n-\t{\n-\t  pred_chain c = u[j];\n-\t  for (size_t k = 0; k < c.length (); ++k)\n-\t    worklist->safe_push (&c[k]);\n-\t}\n-    }\n-}\n-\n-/* Return TRUE if executing the path to some uninitialized operands in\n-   a PHI will invalidate the use of the PHI result later on.\n-\n-   UNINIT_OPNDS is a bit vector specifying which PHI arguments have\n-   arguments which are considered uninitialized.\n-\n-   USE_PREDS is the pred_chain_union specifying the guard conditions\n-   for the use of the PHI result.\n-\n-   What we want to do is disprove each of the guards in the factors of\n-   the USE_PREDS.  So if we have:\n-\n-   # USE_PREDS guards of:\n-   #\t1. i > 5 && i < 100\n-   #\t2. j > 10 && j < 88\n-\n-   Then proving that the control dependenies for the UNINIT_OPNDS are:\n-\n-   #      [i <= 5]\n-   # .OR. [i >= 100]\n-   #\n+  unsigned phi_args = gimple_phi_num_args (phi);\n+  if (phi_args > max_phi_args)\n+    return false;\n \n-   ...we can prove that the 1st guard above in USE_PREDS is invalid.\n-   Similarly for the 2nd guard.  We return TRUE if we can disprove\n-   both of the guards in USE_PREDS above.  */\n+  /* PHI_USE_GUARDS are OR'ed together.  If we have more than one\n+     possible guard, there's no way of knowing which guard was true.\n+     Since we need to be absolutely sure that the uninitialized\n+     operands will be invalidated, bail.  */\n+  if (phi_use_guards.length () != 1)\n+    return false;\n \n-static bool\n-uninit_ops_invalidate_phi_use (gphi *phi, unsigned uninit_opnds,\n-\t\t\t       pred_chain_union use_preds)\n-{\n   /* Look for the control dependencies of all the uninitialized\n-     operands and build predicates describing them.  */\n+     operands and build guard predicates describing them.  */\n   unsigned i;\n   pred_chain_union uninit_preds[max_phi_args];\n-  memset (uninit_preds, 0, sizeof (pred_chain_union) * max_phi_args);\n-  for (i = 0; i < MIN (max_phi_args, gimple_phi_num_args (phi)); i++)\n+  memset (uninit_preds, 0, sizeof (pred_chain_union) * phi_args);\n+  for (i = 0; i < phi_args; ++i)\n     {\n       if (!MASK_TEST_BIT (uninit_opnds, i))\n \tcontinue;\n@@ -2274,32 +2225,27 @@ uninit_ops_invalidate_phi_use (gphi *phi, unsigned uninit_opnds,\n       size_t num_chains = 0;\n       int num_calls = 0;\n \n-      /* Build the control dependency chain for `i'...  */\n-      if (compute_control_dep_chain (find_dom (e->src),\n-\t\t\t\t     e->src,\n-\t\t\t\t     dep_chains,\n-\t\t\t\t     &num_chains,\n-\t\t\t\t     &cur_chain,\n-\t\t\t\t     &num_calls))\n-\t{\n-\t  /* ...and convert it into a set of predicates.  */\n-\t  convert_control_dep_chain_into_preds (dep_chains, num_chains,\n-\t\t\t\t\t\t&uninit_preds[i]);\n-\t  for (size_t j = 0; j < num_chains; ++j)\n-\t    dep_chains[j].release ();\n-\t  simplify_preds (&uninit_preds[i], NULL, false);\n-\t  uninit_preds[i]\n-\t    = normalize_preds (uninit_preds[i], NULL, false);\n-\t}\n+      /* Build the control dependency chain for uninit operand `i'...  */\n+      if (!compute_control_dep_chain (find_dom (e->src),\n+\t\t\t\t      e->src, dep_chains, &num_chains,\n+\t\t\t\t      &cur_chain, &num_calls))\n+\treturn false;\n+      /* ...and convert it into a set of predicates.  */\n+      convert_control_dep_chain_into_preds (dep_chains, num_chains,\n+\t\t\t\t\t    &uninit_preds[i]);\n+      for (size_t j = 0; j < num_chains; ++j)\n+\tdep_chains[j].release ();\n+      simplify_preds (&uninit_preds[i], NULL, false);\n+      uninit_preds[i]\n+\t= normalize_preds (uninit_preds[i], NULL, false);\n+\n+      /* Can the guard for this uninitialized operand be invalidated\n+\t by the PHI use?  */\n+      if (!can_chain_union_be_invalidated_p (uninit_preds[i],\n+\t\t\t\t\t     phi_use_guards[0]))\n+\treturn false;\n     }\n-\n-  /* Munge all the predicates into one worklist, and see if we can\n-     invalidate all the chains in USE_PREDs with the predicates in\n-     WORKLIST.  */\n-  auto_vec<pred_info *> worklist;\n-  flatten_out_predicate_chains (uninit_preds, i, &worklist);\n-  bool ret = can_chain_union_be_invalidated_p (use_preds, worklist);\n-  return ret;\n+  return true;\n }\n \n /* Computes the predicates that guard the use and checks\n@@ -2361,8 +2307,8 @@ is_use_properly_guarded (gimple *use_stmt,\n      for UNINIT_OPNDS are true, that the control dependencies for\n      USE_STMT can never be true.  */\n   if (!is_properly_guarded)\n-    is_properly_guarded |= uninit_ops_invalidate_phi_use (phi, uninit_opnds,\n-\t\t\t\t\t\t\t  preds);\n+    is_properly_guarded |= uninit_uses_cannot_happen (phi, uninit_opnds,\n+\t\t\t\t\t\t      preds);\n \n   if (is_properly_guarded)\n     {"}]}