{"sha": "4f9a2b4e884acb7db0e9acb3c13b0adfbce65725", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY5YTJiNGU4ODRhY2I3ZGIwZTlhY2IzYzEzYjBhZGZiY2U2NTcyNQ==", "commit": {"author": {"name": "Alan Lawrence", "email": "alan.lawrence@arm.com", "date": "2015-07-02T11:47:31Z"}, "committer": {"name": "Alan Lawrence", "email": "alalaw01@gcc.gnu.org", "date": "2015-07-02T11:47:31Z"}, "message": "tree-pass.h (make_pass_ch_vect): New.\n\ngcc/:\n\n\t* tree-pass.h (make_pass_ch_vect): New.\n\t* passes.def: Add pass_ch_vect just before pass_if_conversion.\n\n\t* tree-ssa-loop-ch.c (ch_base, pass_ch_vect, pass_data_ch_vect,\n\tpass_ch::process_loop_p, pass_ch_vect::process_loop_p,\n\tmake_pass_ch_vect): New.\n\t(pass_ch): Extend ch_base.\n\n\t(pass_ch::execute): Move all but loop_optimizer_init/finalize to...\n\t(ch_base::copy_headers): ...here.\n\ngcc/testsuite/:\n\n\t* gcc.dg/vect/vect-strided-a-u16-i4.c (main1): Narrow scope of x,y,z,w.\n\t* gcc.dg/vect/vect-ifcvt-11.c: New testcase.\n\nFrom-SVN: r225311", "tree": {"sha": "03b839a9ffb0c5708c3e05e1fbf436749d1db944", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03b839a9ffb0c5708c3e05e1fbf436749d1db944"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f9a2b4e884acb7db0e9acb3c13b0adfbce65725", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f9a2b4e884acb7db0e9acb3c13b0adfbce65725", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f9a2b4e884acb7db0e9acb3c13b0adfbce65725", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f9a2b4e884acb7db0e9acb3c13b0adfbce65725/comments", "author": null, "committer": null, "parents": [{"sha": "5fa79de857ef94a396c313826b290c4bb548c135", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fa79de857ef94a396c313826b290c4bb548c135", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fa79de857ef94a396c313826b290c4bb548c135"}], "stats": {"total": 212, "additions": 196, "deletions": 16}, "files": [{"sha": "3b15e2e2479863a4f74a94d2042e0249909c9f58", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f9a2b4e884acb7db0e9acb3c13b0adfbce65725/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f9a2b4e884acb7db0e9acb3c13b0adfbce65725/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f9a2b4e884acb7db0e9acb3c13b0adfbce65725", "patch": "@@ -1,3 +1,16 @@\n+2015-07-02  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\t* tree-pass.h (make_pass_ch_vect): New.\n+\t* passes.def: Add pass_ch_vect just before pass_if_conversion.\n+\n+\t* tree-ssa-loop-ch.c (ch_base, pass_ch_vect, pass_data_ch_vect,\n+\tpass_ch::process_loop_p, pass_ch_vect::process_loop_p,\n+\tmake_pass_ch_vect): New.\n+\t(pass_ch): Extend ch_base.\n+\n+\t(pass_ch::execute): Move all but loop_optimizer_init/finalize to...\n+\t(ch_base::copy_headers): ...here.\n+\n 2015-07-02  Richard Biener  <rguenther@suse.de>\n \n \t* builtins.c (get_pointer_alignment_1): Handle POINTER_PLUS_EXPR."}, {"sha": "0d8356b9bda0aeba72bdb4a6b06abffd5e86058b", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f9a2b4e884acb7db0e9acb3c13b0adfbce65725/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f9a2b4e884acb7db0e9acb3c13b0adfbce65725/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=4f9a2b4e884acb7db0e9acb3c13b0adfbce65725", "patch": "@@ -247,6 +247,7 @@ along with GCC; see the file COPYING3.  If not see\n \t  PUSH_INSERT_PASSES_WITHIN (pass_parallelize_loops)\n \t      NEXT_PASS (pass_expand_omp_ssa);\n \t  POP_INSERT_PASSES ()\n+\t  NEXT_PASS (pass_ch_vect);\n \t  NEXT_PASS (pass_if_conversion);\n \t  /* pass_vectorize must immediately follow pass_if_conversion.\n \t     Please do not add any other passes in between.  */"}, {"sha": "e7b749b1cf8c0e7a42b85adda9286b0bfe17439c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f9a2b4e884acb7db0e9acb3c13b0adfbce65725/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f9a2b4e884acb7db0e9acb3c13b0adfbce65725/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4f9a2b4e884acb7db0e9acb3c13b0adfbce65725", "patch": "@@ -1,3 +1,8 @@\n+2015-07-02  Alan Lawrence  <alan.lawrence@arm.com>\n+\n+\t* gcc.dg/vect/vect-strided-a-u16-i4.c (main1): Narrow scope of x,y,z,w.\n+\t* gcc.dg/vect/vect-ifcvt-11.c: New testcase.\n+\n 2015-07-02  Richard Biener  <rguenther@suse.de>\n \n \tPR testsuite/66719"}, {"sha": "7e323693087598942f57aa8b7cf3686dde4a52c9", "filename": "gcc/testsuite/gcc.dg/vect/vect-ifcvt-11.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f9a2b4e884acb7db0e9acb3c13b0adfbce65725/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f9a2b4e884acb7db0e9acb3c13b0adfbce65725/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-ifcvt-11.c?ref=4f9a2b4e884acb7db0e9acb3c13b0adfbce65725", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-require-effective-target vect_condition } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+extern void abort (void);\n+\n+int A[N] = {36, 39, 42, 45, 43, 32, 21, 12, 23, 34, 45, 56, 67, 78, 81, 11};\n+int B[N] = {144,195,210,225,172,128,105,60, 92, 136,225,280,268,390,324,55};\n+\n+__attribute__((noinline))\n+void foo ()\n+{\n+  for (int i = 0; i < N; i++)\n+    {\n+      int m = (A[i] & i) ? 5 : 4;\n+      A[i] = A[i] * m;\n+    }\n+}\n+\n+int main ()\n+{\n+\n+  check_vect ();\n+  foo ();\n+  /* check results:  */\n+  for (int i = 0; i < N; i++)\n+    if (A[i] != B[i])\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "0be68b31198d70f428173cb4d7e2462d3fd1f5b2", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-a-u16-i4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f9a2b4e884acb7db0e9acb3c13b0adfbce65725/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u16-i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f9a2b4e884acb7db0e9acb3c13b0adfbce65725/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u16-i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-a-u16-i4.c?ref=4f9a2b4e884acb7db0e9acb3c13b0adfbce65725", "patch": "@@ -21,7 +21,6 @@ main1 ()\n   s *ptr = arr;\n   s res[N];\n   int i;\n-  unsigned short x, y, z, w;\n \n   for (i = 0; i < N; i++)\n     {\n@@ -35,6 +34,7 @@ main1 ()\n \n   for (i = 0; i < N; i++)\n     {\n+      unsigned short x, y, z, w;\n       x = ptr->b - ptr->a;\n       y = ptr->d - ptr->c;\n       res[i].c = x + y;"}, {"sha": "2808dad2d7d8fface5f7faccdfea70b6c2d0e285", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f9a2b4e884acb7db0e9acb3c13b0adfbce65725/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f9a2b4e884acb7db0e9acb3c13b0adfbce65725/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=4f9a2b4e884acb7db0e9acb3c13b0adfbce65725", "patch": "@@ -381,6 +381,7 @@ extern gimple_opt_pass *make_pass_loop_prefetch (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_iv_optimize (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_tree_loop_done (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_ch (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_ch_vect (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_ccp (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_phi_only_cprop (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_build_ssa (gcc::context *ctxt);"}, {"sha": "121e3d80bd396f3f7692b899bb39be19e735a096", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 139, "deletions": 15, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f9a2b4e884acb7db0e9acb3c13b0adfbce65725/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f9a2b4e884acb7db0e9acb3c13b0adfbce65725/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=4f9a2b4e884acb7db0e9acb3c13b0adfbce65725", "patch": "@@ -135,12 +135,23 @@ do_while_loop_p (struct loop *loop)\n   return true;\n }\n \n-/* For all loops, copy the condition at the end of the loop body in front\n-   of the loop.  This is beneficial since it increases efficiency of\n-   code motion optimizations.  It also saves one jump on entry to the loop.  */\n-\n namespace {\n \n+/* Common superclass for both header-copying phases.  */\n+class ch_base : public gimple_opt_pass\n+{\n+  protected:\n+    ch_base (pass_data data, gcc::context *ctxt)\n+      : gimple_opt_pass (data, ctxt)\n+    {}\n+\n+  /* Copies headers of all loops in FUN for which process_loop_p is true.  */\n+  unsigned int copy_headers (function *fun);\n+\n+  /* Return true to copy headers of LOOP or false to skip.  */\n+  virtual bool process_loop_p (struct loop *loop) = 0;\n+};\n+\n const pass_data pass_data_ch =\n {\n   GIMPLE_PASS, /* type */\n@@ -154,21 +165,68 @@ const pass_data pass_data_ch =\n   0, /* todo_flags_finish */\n };\n \n-class pass_ch : public gimple_opt_pass\n+class pass_ch : public ch_base\n {\n public:\n   pass_ch (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_ch, ctxt)\n+    : ch_base (pass_data_ch, ctxt)\n   {}\n \n   /* opt_pass methods: */\n   virtual bool gate (function *) { return flag_tree_ch != 0; }\n+  \n+  /* Initialize and finalize loop structures, copying headers inbetween.  */\n   virtual unsigned int execute (function *);\n \n+protected:\n+  /* ch_base method: */\n+  virtual bool process_loop_p (struct loop *loop);\n }; // class pass_ch\n \n+const pass_data pass_data_ch_vect =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"ch_vect\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  TV_TREE_CH, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+/* This is a more aggressive version of the same pass, designed to run just\n+   before if-conversion and vectorization, to put more loops into the form\n+   required for those phases.  */\n+class pass_ch_vect : public ch_base\n+{\n+public:\n+  pass_ch_vect (gcc::context *ctxt)\n+    : ch_base (pass_data_ch_vect, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *fun)\n+  {\n+    return flag_tree_ch != 0\n+\t   && (flag_tree_loop_vectorize != 0 || fun->has_force_vectorize_loops);\n+  }\n+  \n+  /* Just copy headers, no initialization/finalization of loop structures.  */\n+  virtual unsigned int execute (function *);\n+\n+protected:\n+  /* ch_base method: */\n+  virtual bool process_loop_p (struct loop *loop);\n+}; // class pass_ch_vect\n+\n+/* For all loops, copy the condition at the end of the loop body in front\n+   of the loop.  This is beneficial since it increases efficiency of\n+   code motion optimizations.  It also saves one jump on entry to the loop.  */\n+\n unsigned int\n-pass_ch::execute (function *fun)\n+ch_base::copy_headers (function *fun)\n {\n   struct loop *loop;\n   basic_block header;\n@@ -178,13 +236,8 @@ pass_ch::execute (function *fun)\n   unsigned bbs_size;\n   bool changed = false;\n \n-  loop_optimizer_init (LOOPS_HAVE_PREHEADERS\n-\t\t       | LOOPS_HAVE_SIMPLE_LATCHES);\n   if (number_of_loops (fun) <= 1)\n-    {\n-      loop_optimizer_finalize ();\n       return 0;\n-    }\n \n   bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (fun));\n   copied_bbs = XNEWVEC (basic_block, n_basic_blocks_for_fn (fun));\n@@ -201,7 +254,7 @@ pass_ch::execute (function *fun)\n \t written as such, or because jump threading transformed it into one),\n \t we might be in fact peeling the first iteration of the loop.  This\n \t in general is not a good idea.  */\n-      if (do_while_loop_p (loop))\n+      if (!process_loop_p (loop))\n \tcontinue;\n \n       /* Iterate the header copying up to limit; this takes care of the cases\n@@ -288,16 +341,87 @@ pass_ch::execute (function *fun)\n       changed = true;\n     }\n \n-  update_ssa (TODO_update_ssa);\n+  if (changed)\n+    update_ssa (TODO_update_ssa);\n   free (bbs);\n   free (copied_bbs);\n \n-  loop_optimizer_finalize ();\n   return changed ? TODO_cleanup_cfg : 0;\n }\n \n+/* Initialize the loop structures we need, and finalize after.  */\n+\n+unsigned int\n+pass_ch::execute (function *fun)\n+{\n+  loop_optimizer_init (LOOPS_HAVE_PREHEADERS\n+\t\t       | LOOPS_HAVE_SIMPLE_LATCHES);\n+\n+  unsigned int res = copy_headers (fun);\n+\n+  loop_optimizer_finalize ();\n+  return res;\n+}\n+\n+/* Assume an earlier phase has already initialized all the loop structures that\n+   we need here (and perhaps others too), and that these will be finalized by\n+   a later phase.  */\n+   \n+unsigned int\n+pass_ch_vect::execute (function *fun)\n+{\n+  return copy_headers (fun);\n+}\n+\n+/* Apply header copying according to a very simple test of do-while shape.  */\n+\n+bool\n+pass_ch::process_loop_p (struct loop *loop)\n+{\n+  return !do_while_loop_p (loop);\n+}\n+\n+/* Apply header-copying to loops where we might enable vectorization.  */\n+\n+bool\n+pass_ch_vect::process_loop_p (struct loop *loop)\n+{\n+  if (!flag_tree_vectorize && !loop->force_vectorize)\n+    return false;\n+\n+  if (loop->dont_vectorize)\n+    return false;\n+\n+  if (!do_while_loop_p (loop))\n+    return true;\n+\n+ /* The vectorizer won't handle anything with multiple exits, so skip.  */\n+  edge exit = single_exit (loop);\n+  if (!exit)\n+    return false;\n+\n+  /* Copy headers iff there looks to be code in the loop after the exit block,\n+     i.e. the exit block has an edge to another block (besides the latch,\n+     which should be empty).  */\n+  edge_iterator ei;\n+  edge e;\n+  FOR_EACH_EDGE (e, ei, exit->src->succs)\n+    if (!loop_exit_edge_p (loop, e)\n+\t&& e->dest != loop->header\n+\t&& e->dest != loop->latch)\n+      return true;\n+\n+  return false;\n+}\n+\n } // anon namespace\n \n+gimple_opt_pass *\n+make_pass_ch_vect (gcc::context *ctxt)\n+{\n+  return new pass_ch_vect (ctxt);\n+}\n+\n gimple_opt_pass *\n make_pass_ch (gcc::context *ctxt)\n {"}]}