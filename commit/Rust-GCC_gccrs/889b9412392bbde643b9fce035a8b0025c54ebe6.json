{"sha": "889b9412392bbde643b9fce035a8b0025c54ebe6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg5Yjk0MTIzOTJiYmRlNjQzYjlmY2UwMzVhOGIwMDI1YzU0ZWJlNg==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2013-05-01T10:33:57Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2013-05-01T10:33:57Z"}, "message": "[AArch64] Improve description of <F>CM instructions in RTL\n\ngcc/\n\t* config/aarch64/aarch64-simd-builtins.def (cmhs): Rename to...\n\t(cmgeu): ...This.\n\t(cmhi): Rename to...\n\t(cmgtu): ...This.\n\t* config/aarch64/aarch64-simd.md\n\t(simd_mode): Add SF.\n\t(aarch64_vcond_internal): Use new names for unsigned comparison insns.\n\t(aarch64_cm<optab><mode>): Rewrite to not use UNSPECs.\n\t* config/aarch64/aarch64.md (*cstore<mode>_neg): Rename to...\n\t(cstore<mode>_neg): ...This.\n\t* config/aarch64/iterators.md\n\t(VALLF): new.\n\t(unspec): Remove UNSPEC_CM<EQ, LE, LT, GE, GT, HS, HI, TST>.\n\t(COMPARISONS): New.\n\t(UCOMPARISONS): Likewise.\n\t(optab): Add missing comparisons.\n\t(n_optab): New.\n\t(cmp_1): Likewise.\n\t(cmp_2): Likewise.\n\t(CMP): Likewise.\n\t(cmp): Remove.\n\t(VCMP_S): Likewise.\n\t(VCMP_U): Likewise.\n\t(V_cmp_result): Add DF, SF modes.\n\t(v_cmp_result): Likewise.\n\t(v): Likewise.\n\t(vmtype): Likewise.\n\t* config/aarch64/predicates.md (aarch64_reg_or_fp_zero): New.\n\nFrom-SVN: r198490", "tree": {"sha": "5f70f8cde6f94c60dca8e40d97739091f65cb3ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f70f8cde6f94c60dca8e40d97739091f65cb3ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/889b9412392bbde643b9fce035a8b0025c54ebe6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/889b9412392bbde643b9fce035a8b0025c54ebe6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/889b9412392bbde643b9fce035a8b0025c54ebe6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/889b9412392bbde643b9fce035a8b0025c54ebe6/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0a7dbb76614d042a49d7fe2a0ef247361a21300c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a7dbb76614d042a49d7fe2a0ef247361a21300c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a7dbb76614d042a49d7fe2a0ef247361a21300c"}], "stats": {"total": 288, "additions": 236, "deletions": 52}, "files": [{"sha": "6c26738515987a799e63081f0e869672191597e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/889b9412392bbde643b9fce035a8b0025c54ebe6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/889b9412392bbde643b9fce035a8b0025c54ebe6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=889b9412392bbde643b9fce035a8b0025c54ebe6", "patch": "@@ -1,3 +1,34 @@\n+2013-05-01  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* config/aarch64/aarch64-simd-builtins.def (cmhs): Rename to...\n+\t(cmgeu): ...This.\n+\t(cmhi): Rename to...\n+\t(cmgtu): ...This.\n+\t* config/aarch64/aarch64-simd.md\n+\t(simd_mode): Add SF.\n+\t(aarch64_vcond_internal): Use new names for unsigned comparison insns.\n+\t(aarch64_cm<optab><mode>): Rewrite to not use UNSPECs.\n+\t* config/aarch64/aarch64.md (*cstore<mode>_neg): Rename to...\n+\t(cstore<mode>_neg): ...This.\n+\t* config/aarch64/iterators.md\n+\t(VALLF): new.\n+\t(unspec): Remove UNSPEC_CM<EQ, LE, LT, GE, GT, HS, HI, TST>.\n+\t(COMPARISONS): New.\n+\t(UCOMPARISONS): Likewise.\n+\t(optab): Add missing comparisons.\n+\t(n_optab): New.\n+\t(cmp_1): Likewise.\n+\t(cmp_2): Likewise.\n+\t(CMP): Likewise.\n+\t(cmp): Remove.\n+\t(VCMP_S): Likewise.\n+\t(VCMP_U): Likewise.\n+\t(V_cmp_result): Add DF, SF modes.\n+\t(v_cmp_result): Likewise.\n+\t(v): Likewise.\n+\t(vmtype): Likewise.\n+\t* config/aarch64/predicates.md (aarch64_reg_or_fp_zero): New.\n+\n 2013-05-01  Greta Yorsh  <Greta.Yorsh@arm.com>\n \n \t* config/arm/thumb2.md (thumb2_smaxsi3,thumb2_sminsi3): Convert"}, {"sha": "2ae28816ef10d3a0856242dd877feb6965e68a7e", "filename": "gcc/config/aarch64/aarch64-simd-builtins.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/889b9412392bbde643b9fce035a8b0025c54ebe6/gcc%2Fconfig%2Faarch64%2Faarch64-simd-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/889b9412392bbde643b9fce035a8b0025c54ebe6/gcc%2Fconfig%2Faarch64%2Faarch64-simd-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd-builtins.def?ref=889b9412392bbde643b9fce035a8b0025c54ebe6", "patch": "@@ -230,8 +230,8 @@\n   BUILTIN_VSDQ_I_DI (BINOP, cmle, 0)\n   BUILTIN_VSDQ_I_DI (BINOP, cmlt, 0)\n   /* Implemented by aarch64_cm<cmp><mode>.  */\n-  BUILTIN_VSDQ_I_DI (BINOP, cmhs, 0)\n-  BUILTIN_VSDQ_I_DI (BINOP, cmhi, 0)\n+  BUILTIN_VSDQ_I_DI (BINOP, cmgeu, 0)\n+  BUILTIN_VSDQ_I_DI (BINOP, cmgtu, 0)\n   BUILTIN_VSDQ_I_DI (BINOP, cmtst, 0)\n \n   /* Implemented by aarch64_<fmaxmin><mode>.  */"}, {"sha": "389344474ac939b21a6ec3c8d34c3f5f03860c6b", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 159, "deletions": 26, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/889b9412392bbde643b9fce035a8b0025c54ebe6/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/889b9412392bbde643b9fce035a8b0025c54ebe6/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=889b9412392bbde643b9fce035a8b0025c54ebe6", "patch": "@@ -21,7 +21,7 @@\n \n ; Main data types used by the insntructions\n \n-(define_attr \"simd_mode\" \"unknown,none,V8QI,V16QI,V4HI,V8HI,V2SI,V4SI,V2DI,V2SF,V4SF,V2DF,OI,CI,XI,DI,DF,SI,HI,QI\"\n+(define_attr \"simd_mode\" \"unknown,none,V8QI,V16QI,V4HI,V8HI,V2SI,V4SI,V2DI,V2SF,V4SF,V2DF,OI,CI,XI,DI,DF,SI,SF,HI,QI\"\n   (const_string \"unknown\"))\n \n \n@@ -1728,12 +1728,12 @@\n \n     case LTU:\n     case GEU:\n-      emit_insn (gen_aarch64_cmhs<mode> (mask, operands[4], operands[5]));\n+      emit_insn (gen_aarch64_cmgeu<mode> (mask, operands[4], operands[5]));\n       break;\n \n     case LEU:\n     case GTU:\n-      emit_insn (gen_aarch64_cmhi<mode> (mask, operands[4], operands[5]));\n+      emit_insn (gen_aarch64_cmgtu<mode> (mask, operands[4], operands[5]));\n       break;\n \n     case NE:\n@@ -3170,48 +3170,181 @@\n )\n \n \n-;; cm(eq|ge|le|lt|gt)\n+;; cm(eq|ge|gt|lt|le)\n+;; Note, we have constraints for Dz and Z as different expanders\n+;; have different ideas of what should be passed to this pattern.\n \n-(define_insn \"aarch64_cm<cmp><mode>\"\n+(define_insn \"aarch64_cm<optab><mode>\"\n   [(set (match_operand:<V_cmp_result> 0 \"register_operand\" \"=w,w\")\n-        (unspec:<V_cmp_result>\n-\t  [(match_operand:VSDQ_I_DI 1 \"register_operand\" \"w,w\")\n-\t   (match_operand:VSDQ_I_DI 2 \"aarch64_simd_reg_or_zero\" \"w,Z\")]\n-          VCMP_S))]\n+\t(neg:<V_cmp_result>\n+\t  (COMPARISONS:<V_cmp_result>\n+\t    (match_operand:VDQ 1 \"register_operand\" \"w,w\")\n+\t    (match_operand:VDQ 2 \"aarch64_simd_reg_or_zero\" \"w,ZDz\")\n+\t  )))]\n   \"TARGET_SIMD\"\n   \"@\n-  cm<cmp>\\t%<v>0<Vmtype>, %<v>1<Vmtype>, %<v>2<Vmtype>\n-  cm<cmp>\\t%<v>0<Vmtype>, %<v>1<Vmtype>, #0\"\n+  cm<n_optab>\\t%<v>0<Vmtype>, %<v><cmp_1><Vmtype>, %<v><cmp_2><Vmtype>\n+  cm<optab>\\t%<v>0<Vmtype>, %<v>1<Vmtype>, #0\"\n   [(set_attr \"simd_type\" \"simd_cmp\")\n    (set_attr \"simd_mode\" \"<MODE>\")]\n )\n \n-;; cm(hs|hi|tst)\n+(define_insn_and_split \"aarch64_cm<optab>di\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=w,w,r\")\n+\t(neg:DI\n+\t  (COMPARISONS:DI\n+\t    (match_operand:DI 1 \"register_operand\" \"w,w,r\")\n+\t    (match_operand:DI 2 \"aarch64_simd_reg_or_zero\" \"w,ZDz,r\")\n+\t  )))]\n+  \"TARGET_SIMD\"\n+  \"@\n+  cm<n_optab>\\t%d0, %d<cmp_1>, %d<cmp_2>\n+  cm<optab>\\t%d0, %d1, #0\n+  #\"\n+  \"reload_completed\n+   /* We need to prevent the split from\n+      happening in the 'w' constraint cases.  */\n+   && GP_REGNUM_P (REGNO (operands[0]))\n+   && GP_REGNUM_P (REGNO (operands[1]))\"\n+  [(set (reg:CC CC_REGNUM)\n+    (compare:CC\n+      (match_dup 1)\n+      (match_dup 2)))\n+  (set (match_dup 0)\n+    (neg:DI\n+      (COMPARISONS:DI\n+\t(match_operand 3 \"cc_register\" \"\")\n+\t(const_int 0))))]\n+  {\n+    enum machine_mode mode = SELECT_CC_MODE (<CMP>, operands[1], operands[2]);\n+    rtx cc_reg = aarch64_gen_compare_reg (<CMP>, operands[1], operands[2]);\n+    rtx comparison = gen_rtx_<CMP> (mode, operands[1], operands[2]);\n+    emit_insn (gen_cstoredi_neg (operands[0], comparison, cc_reg));\n+    DONE;\n+  }\n+  [(set_attr \"simd_type\" \"simd_cmp\")\n+   (set_attr \"simd_mode\" \"DI\")]\n+)\n \n-(define_insn \"aarch64_cm<cmp><mode>\"\n+;; cm(hs|hi)\n+\n+(define_insn \"aarch64_cm<optab><mode>\"\n   [(set (match_operand:<V_cmp_result> 0 \"register_operand\" \"=w\")\n-        (unspec:<V_cmp_result>\n-\t  [(match_operand:VSDQ_I_DI 1 \"register_operand\" \"w\")\n-\t   (match_operand:VSDQ_I_DI 2 \"register_operand\" \"w\")]\n-          VCMP_U))]\n+\t(neg:<V_cmp_result>\n+\t  (UCOMPARISONS:<V_cmp_result>\n+\t    (match_operand:VDQ 1 \"register_operand\" \"w\")\n+\t    (match_operand:VDQ 2 \"register_operand\" \"w\")\n+\t  )))]\n   \"TARGET_SIMD\"\n-  \"cm<cmp>\\t%<v>0<Vmtype>, %<v>1<Vmtype>, %<v>2<Vmtype>\"\n+  \"cm<n_optab>\\t%<v>0<Vmtype>, %<v><cmp_1><Vmtype>, %<v><cmp_2><Vmtype>\"\n+  [(set_attr \"simd_type\" \"simd_cmp\")\n+   (set_attr \"simd_mode\" \"<MODE>\")]\n+)\n+\n+(define_insn_and_split \"aarch64_cm<optab>di\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=w,r\")\n+\t(neg:DI\n+\t  (UCOMPARISONS:DI\n+\t    (match_operand:DI 1 \"register_operand\" \"w,r\")\n+\t    (match_operand:DI 2 \"aarch64_simd_reg_or_zero\" \"w,r\")\n+\t  )))]\n+  \"TARGET_SIMD\"\n+  \"@\n+  cm<n_optab>\\t%d0, %d<cmp_1>, %d<cmp_2>\n+  #\"\n+  \"reload_completed\n+   /* We need to prevent the split from\n+      happening in the 'w' constraint cases.  */\n+   && GP_REGNUM_P (REGNO (operands[0]))\n+   && GP_REGNUM_P (REGNO (operands[1]))\"\n+  [(set (reg:CC CC_REGNUM)\n+    (compare:CC\n+      (match_dup 1)\n+      (match_dup 2)))\n+  (set (match_dup 0)\n+    (neg:DI\n+      (UCOMPARISONS:DI\n+\t(match_operand 3 \"cc_register\" \"\")\n+\t(const_int 0))))]\n+  {\n+    enum machine_mode mode = SELECT_CC_MODE (<CMP>, operands[1], operands[2]);\n+    rtx cc_reg = aarch64_gen_compare_reg (<CMP>, operands[1], operands[2]);\n+    rtx comparison = gen_rtx_<CMP> (mode, operands[1], operands[2]);\n+    emit_insn (gen_cstoredi_neg (operands[0], comparison, cc_reg));\n+    DONE;\n+  }\n+  [(set_attr \"simd_type\" \"simd_cmp\")\n+   (set_attr \"simd_mode\" \"DI\")]\n+)\n+\n+;; cmtst\n+\n+(define_insn \"aarch64_cmtst<mode>\"\n+  [(set (match_operand:<V_cmp_result> 0 \"register_operand\" \"=w\")\n+\t(neg:<V_cmp_result>\n+\t  (ne:<V_cmp_result>\n+\t    (and:VDQ\n+\t      (match_operand:VDQ 1 \"register_operand\" \"w\")\n+\t      (match_operand:VDQ 2 \"register_operand\" \"w\"))\n+\t    (vec_duplicate:<V_cmp_result> (const_int 0)))))]\n+  \"TARGET_SIMD\"\n+  \"cmtst\\t%<v>0<Vmtype>, %<v>1<Vmtype>, %<v>2<Vmtype>\"\n   [(set_attr \"simd_type\" \"simd_cmp\")\n    (set_attr \"simd_mode\" \"<MODE>\")]\n )\n \n-;; fcm(eq|ge|le|lt|gt)\n+(define_insn_and_split \"aarch64_cmtstdi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=w,r\")\n+\t(neg:DI\n+\t  (ne:DI\n+\t    (and:DI\n+\t      (match_operand:DI 1 \"register_operand\" \"w,r\")\n+\t      (match_operand:DI 2 \"register_operand\" \"w,r\"))\n+\t    (const_int 0))))]\n+  \"TARGET_SIMD\"\n+  \"@\n+  cmtst\\t%d0, %d1, %d2\n+  #\"\n+  \"reload_completed\n+   /* We need to prevent the split from\n+      happening in the 'w' constraint cases.  */\n+   && GP_REGNUM_P (REGNO (operands[0]))\n+   && GP_REGNUM_P (REGNO (operands[1]))\"\n+   [(set (reg:CC_NZ CC_REGNUM)\n+\t(compare:CC_NZ\n+\t (and:DI (match_dup 1)\n+\t\t  (match_dup 2))\n+\t (const_int 0)))\n+  (set (match_dup 0)\n+    (neg:DI\n+      (ne:DI\n+\t(match_operand 3 \"cc_register\" \"\")\n+\t(const_int 0))))]\n+  {\n+    rtx and_tree = gen_rtx_AND (DImode, operands[1], operands[2]);\n+    enum machine_mode mode = SELECT_CC_MODE (NE, and_tree, const0_rtx);\n+    rtx cc_reg = aarch64_gen_compare_reg (NE, and_tree, const0_rtx);\n+    rtx comparison = gen_rtx_NE (mode, and_tree, const0_rtx);\n+    emit_insn (gen_cstoredi_neg (operands[0], comparison, cc_reg));\n+    DONE;\n+  }\n+  [(set_attr \"simd_type\" \"simd_cmp\")\n+   (set_attr \"simd_mode\" \"DI\")]\n+)\n \n-(define_insn \"aarch64_cm<cmp><mode>\"\n+;; fcm(eq|ge|gt|le|lt)\n+\n+(define_insn \"aarch64_cm<optab><mode>\"\n   [(set (match_operand:<V_cmp_result> 0 \"register_operand\" \"=w,w\")\n-\t(unspec:<V_cmp_result>\n-\t  [(match_operand:VDQF 1 \"register_operand\" \"w,w\")\n-\t   (match_operand:VDQF 2 \"aarch64_simd_reg_or_zero\" \"w,Dz\")]\n-\t   VCMP_S))]\n+\t(neg:<V_cmp_result>\n+\t  (COMPARISONS:<V_cmp_result>\n+\t    (match_operand:VALLF 1 \"register_operand\" \"w,w\")\n+\t    (match_operand:VALLF 2 \"aarch64_simd_reg_or_zero\" \"w,YDz\")\n+\t  )))]\n   \"TARGET_SIMD\"\n   \"@\n-  fcm<cmp>\\t%<v>0<Vmtype>, %<v>1<Vmtype>, %<v>2<Vmtype>\n-  fcm<cmp>\\t%<v>0<Vmtype>, %<v>1<Vmtype>, 0\"\n+  fcm<n_optab>\\t%<v>0<Vmtype>, %<v><cmp_1><Vmtype>, %<v><cmp_2><Vmtype>\n+  fcm<optab>\\t%<v>0<Vmtype>, %<v>1<Vmtype>, 0\"\n   [(set_attr \"simd_type\" \"simd_fcmp\")\n    (set_attr \"simd_mode\" \"<MODE>\")]\n )"}, {"sha": "96be7a101d974cf9e1b4c7b4539e47a92d3da198", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/889b9412392bbde643b9fce035a8b0025c54ebe6/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/889b9412392bbde643b9fce035a8b0025c54ebe6/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=889b9412392bbde643b9fce035a8b0025c54ebe6", "patch": "@@ -2409,7 +2409,7 @@\n    (set_attr \"mode\" \"SI\")]\n )\n \n-(define_insn \"*cstore<mode>_neg\"\n+(define_insn \"cstore<mode>_neg\"\n   [(set (match_operand:ALLI 0 \"register_operand\" \"=r\")\n \t(neg:ALLI (match_operator:ALLI 1 \"aarch64_comparison_operator\"\n \t\t  [(match_operand 2 \"cc_register\" \"\") (const_int 0)])))]"}, {"sha": "0b9f9e84069dca631dd6d67a7ec033dba0905404", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 38, "deletions": 23, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/889b9412392bbde643b9fce035a8b0025c54ebe6/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/889b9412392bbde643b9fce035a8b0025c54ebe6/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=889b9412392bbde643b9fce035a8b0025c54ebe6", "patch": "@@ -83,6 +83,9 @@\n ;; Vector Float modes.\n (define_mode_iterator VDQF [V2SF V4SF V2DF])\n \n+;; All Float modes.\n+(define_mode_iterator VALLF [V2SF V4SF V2DF SF DF])\n+\n ;; Vector Float modes with 2 elements.\n (define_mode_iterator V2F [V2SF V2DF])\n \n@@ -213,21 +216,13 @@\n     UNSPEC_URSHL\t; Used in aarch64-simd.md.\n     UNSPEC_SQRSHL\t; Used in aarch64-simd.md.\n     UNSPEC_UQRSHL\t; Used in aarch64-simd.md.\n-    UNSPEC_CMEQ\t\t; Used in aarch64-simd.md.\n-    UNSPEC_CMLE\t\t; Used in aarch64-simd.md.\n-    UNSPEC_CMLT\t\t; Used in aarch64-simd.md.\n-    UNSPEC_CMGE\t\t; Used in aarch64-simd.md.\n-    UNSPEC_CMGT\t\t; Used in aarch64-simd.md.\n-    UNSPEC_CMHS\t\t; Used in aarch64-simd.md.\n-    UNSPEC_CMHI\t\t; Used in aarch64-simd.md.\n     UNSPEC_SSLI\t\t; Used in aarch64-simd.md.\n     UNSPEC_USLI\t\t; Used in aarch64-simd.md.\n     UNSPEC_SSRI\t\t; Used in aarch64-simd.md.\n     UNSPEC_USRI\t\t; Used in aarch64-simd.md.\n     UNSPEC_SSHLL\t; Used in aarch64-simd.md.\n     UNSPEC_USHLL\t; Used in aarch64-simd.md.\n     UNSPEC_ADDP\t\t; Used in aarch64-simd.md.\n-    UNSPEC_CMTST\t; Used in aarch64-simd.md.\n     UNSPEC_FMAX\t\t; Used in aarch64-simd.md.\n     UNSPEC_FMIN\t\t; Used in aarch64-simd.md.\n     UNSPEC_TBL\t\t; Used in vector permute patterns.\n@@ -253,6 +248,7 @@\n \n ;; For scalar usage of vector/FP registers\n (define_mode_attr v [(QI \"b\") (HI \"h\") (SI \"s\") (DI \"d\")\n+\t\t    (SF \"s\") (DF \"d\")\n \t\t    (V8QI \"\") (V16QI \"\")\n \t\t    (V4HI \"\") (V8HI \"\")\n \t\t    (V2SI \"\") (V4SI  \"\")\n@@ -307,7 +303,8 @@\n \t\t\t (V4SF \".4s\") (V2DF \".2d\")\n \t\t\t (DI   \"\")    (SI   \"\")\n \t\t\t (HI   \"\")    (QI   \"\")\n-\t\t\t (TI   \"\")])\n+\t\t\t (TI   \"\")    (SF   \"\")\n+\t\t\t (DF   \"\")])\n \n ;; Register suffix narrowed modes for VQN.\n (define_mode_attr Vmntype [(V8HI \".8b\") (V4SI \".4h\")\n@@ -446,15 +443,17 @@\n \t\t\t\t(V2SI \"V2SI\") (V4SI  \"V4SI\")\n \t\t\t\t(DI   \"DI\")   (V2DI  \"V2DI\")\n \t\t\t\t(V2SF \"V2SI\") (V4SF  \"V4SI\")\n-\t\t\t\t(V2DF \"V2DI\")])\n+\t\t\t\t(V2DF \"V2DI\") (DF    \"DI\")\n+\t\t\t\t(SF   \"SI\")])\n \n ;; Lower case mode of results of comparison operations.\n (define_mode_attr v_cmp_result [(V8QI \"v8qi\") (V16QI \"v16qi\")\n \t\t\t\t(V4HI \"v4hi\") (V8HI  \"v8hi\")\n \t\t\t\t(V2SI \"v2si\") (V4SI  \"v4si\")\n \t\t\t\t(DI   \"di\")   (V2DI  \"v2di\")\n \t\t\t\t(V2SF \"v2si\") (V4SF  \"v4si\")\n-\t\t\t\t(V2DF \"v2di\")])\n+\t\t\t\t(V2DF \"v2di\") (DF    \"di\")\n+\t\t\t\t(SF   \"si\")])\n \n ;; Vm for lane instructions is restricted to FP_LO_REGS.\n (define_mode_attr vwx [(V4HI \"x\") (V8HI \"x\") (HI \"x\")\n@@ -548,6 +547,12 @@\n ;; Code iterator for signed variants of vector saturating binary ops.\n (define_code_iterator SBINQOPS [ss_plus ss_minus])\n \n+;; Comparison operators for <F>CM.\n+(define_code_iterator COMPARISONS [lt le eq ge gt])\n+\n+;; Unsigned comparison operators.\n+(define_code_iterator UCOMPARISONS [ltu leu geu gtu])\n+\n ;; -------------------------------------------------------------------\n ;; Code Attributes\n ;; -------------------------------------------------------------------\n@@ -580,7 +585,28 @@\n \t\t\t (eq \"eq\")\n \t\t\t (ne \"ne\")\n \t\t\t (lt \"lt\")\n-\t\t\t (ge \"ge\")])\n+\t\t\t (ge \"ge\")\n+\t\t\t (le \"le\")\n+\t\t\t (gt \"gt\")\n+\t\t\t (ltu \"ltu\")\n+\t\t\t (leu \"leu\")\n+\t\t\t (geu \"geu\")\n+\t\t\t (gtu \"gtu\")])\n+\n+;; For comparison operators we use the FCM* and CM* instructions.\n+;; As there are no CMLE or CMLT instructions which act on 3 vector\n+;; operands, we must use CMGE or CMGT and swap the order of the\n+;; source operands.\n+\n+(define_code_attr n_optab [(lt \"gt\") (le \"ge\") (eq \"eq\") (ge \"ge\") (gt \"gt\")\n+\t\t\t   (ltu \"hi\") (leu \"hs\") (geu \"hs\") (gtu \"hi\")])\n+(define_code_attr cmp_1   [(lt \"2\") (le \"2\") (eq \"1\") (ge \"1\") (gt \"1\")\n+\t\t\t   (ltu \"2\") (leu \"2\") (geu \"1\") (gtu \"1\")])\n+(define_code_attr cmp_2   [(lt \"1\") (le \"1\") (eq \"2\") (ge \"2\") (gt \"2\")\n+\t\t\t   (ltu \"1\") (leu \"1\") (geu \"2\") (gtu \"2\")])\n+\n+(define_code_attr CMP [(lt \"LT\") (le \"LE\") (eq \"EQ\") (ge \"GE\") (gt \"GT\")\n+\t\t\t   (ltu \"LTU\") (leu \"LEU\") (geu \"GEU\") (gtu \"GTU\")])\n \n (define_code_attr fix_trunc_optab [(fix \"fix_trunc\")\n \t\t\t\t   (unsigned_fix \"fixuns_trunc\")])\n@@ -693,11 +719,6 @@\n                                UNSPEC_SQSHRN UNSPEC_UQSHRN\n                                UNSPEC_SQRSHRN UNSPEC_UQRSHRN])\n \n-(define_int_iterator VCMP_S [UNSPEC_CMEQ UNSPEC_CMGE UNSPEC_CMGT\n-\t\t\t     UNSPEC_CMLE UNSPEC_CMLT])\n-\n-(define_int_iterator VCMP_U [UNSPEC_CMHS UNSPEC_CMHI UNSPEC_CMTST])\n-\n (define_int_iterator PERMUTE [UNSPEC_ZIP1 UNSPEC_ZIP2\n \t\t\t      UNSPEC_TRN1 UNSPEC_TRN2\n \t\t\t      UNSPEC_UZP1 UNSPEC_UZP2])\n@@ -784,12 +805,6 @@\n \t\t\t (UNSPEC_RADDHN2 \"add\")\n \t\t\t (UNSPEC_RSUBHN2 \"sub\")])\n \n-(define_int_attr cmp [(UNSPEC_CMGE \"ge\") (UNSPEC_CMGT \"gt\")\n-\t\t      (UNSPEC_CMLE \"le\") (UNSPEC_CMLT \"lt\")\n-                      (UNSPEC_CMEQ \"eq\")\n-\t\t      (UNSPEC_CMHS \"hs\") (UNSPEC_CMHI \"hi\")\n-\t\t      (UNSPEC_CMTST \"tst\")])\n-\n (define_int_attr offsetlr [(UNSPEC_SSLI\t\"1\") (UNSPEC_USLI \"1\")\n \t\t\t   (UNSPEC_SSRI\t\"0\") (UNSPEC_USRI \"0\")])\n "}, {"sha": "8514e8f8fbdda73ecec5d79a336b54a2bd7be4f3", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/889b9412392bbde643b9fce035a8b0025c54ebe6/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/889b9412392bbde643b9fce035a8b0025c54ebe6/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=889b9412392bbde643b9fce035a8b0025c54ebe6", "patch": "@@ -31,6 +31,11 @@\n        (ior (match_operand 0 \"register_operand\")\n \t    (match_test \"op == const0_rtx\"))))\n \n+(define_predicate \"aarch64_reg_or_fp_zero\"\n+  (and (match_code \"reg,subreg,const_double\")\n+       (ior (match_operand 0 \"register_operand\")\n+\t    (match_test \"aarch64_float_const_zero_rtx_p (op)\"))))\n+\n (define_predicate \"aarch64_reg_zero_or_m1_or_1\"\n   (and (match_code \"reg,subreg,const_int\")\n        (ior (match_operand 0 \"register_operand\")"}]}