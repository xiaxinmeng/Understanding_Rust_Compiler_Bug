{"sha": "1f10d710e321ad92322adf90342cf99fa3f9d356", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYxMGQ3MTBlMzIxYWQ5MjMyMmFkZjkwMzQyY2Y5OWZhM2Y5ZDM1Ng==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2017-03-25T18:48:01Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2017-03-25T18:48:01Z"}, "message": "re PR fortran/78881 ([F03] reading from string with DTIO procedure does not work properly)\n\n2017-03-25  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/78881\n\t* io/io.h (st_parameter_dt): Rename unused component last_char to\n\tchild_saved_iostat. Move comment to gfc_unit.\n\t* io/list_read.c (list_formatted_read_scalar): After call to\n\tchild READ procedure, save the returned iostat value for later\n\tcheck. (finish_list_read): Only finish READ if child_saved_iostat\n\twas OK.\n\t* io/transfer.c (read_sf_internal): If there is a saved character\n\tin last character, seek back one. Add a new check for EOR\n\tcondition. (read_sf): If there is a saved character\n\tin last character, seek back one. (formatted_transfer_scalar_read):\n\tInitialize last character before invoking child procedure.\n\t(data_transfer_init): If child dtio, set advance\n\tstatus to nonadvancing. Move update of size and check for EOR\n\tcondition to before child dtio return.\n\n\t* gfortran.dg/dtio_26.f90: New test.\n\nFrom-SVN: r246478", "tree": {"sha": "90a8308501114af4ae633be668c2d78a40fdebef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90a8308501114af4ae633be668c2d78a40fdebef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f10d710e321ad92322adf90342cf99fa3f9d356", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f10d710e321ad92322adf90342cf99fa3f9d356", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f10d710e321ad92322adf90342cf99fa3f9d356", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f10d710e321ad92322adf90342cf99fa3f9d356/comments", "author": null, "committer": null, "parents": [{"sha": "410366864025c2aa6ce1928d1737bc9cc4f752e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/410366864025c2aa6ce1928d1737bc9cc4f752e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/410366864025c2aa6ce1928d1737bc9cc4f752e6"}], "stats": {"total": 169, "additions": 148, "deletions": 21}, "files": [{"sha": "005cbe4dec38b2878f8778eba1dd59d92ca5f8a8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f10d710e321ad92322adf90342cf99fa3f9d356/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f10d710e321ad92322adf90342cf99fa3f9d356/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1f10d710e321ad92322adf90342cf99fa3f9d356", "patch": "@@ -1,3 +1,8 @@\n+2017-03-25  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/78881\n+\t* gfortran.dg/dtio_26.f90: New test.\n+\n 2017-03-25  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/80156"}, {"sha": "e947545fb49ebfbf0e50810b5ac80d1c862591e8", "filename": "gcc/testsuite/gfortran.dg/dtio_26.f03", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f10d710e321ad92322adf90342cf99fa3f9d356/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_26.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f10d710e321ad92322adf90342cf99fa3f9d356/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_26.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_26.f03?ref=1f10d710e321ad92322adf90342cf99fa3f9d356", "patch": "@@ -0,0 +1,69 @@\n+! { dg-do run }\n+! PR78881 test for correct end of record condition and ignoring advance=\n+module t_m\n+   use, intrinsic :: iso_fortran_env, only : iostat_end, iostat_eor, output_unit\n+   implicit none\n+   type, public :: t\n+      character(len=:), allocatable :: m_s\n+   contains\n+      procedure, pass(this) :: read_t\n+      generic :: read(formatted) => read_t\n+   end type t\n+contains\n+subroutine read_t(this, lun, iotype, vlist, istat, imsg)\n+  class(t), intent(inout)         :: this\n+  integer, intent(in)             :: lun\n+  character(len=*), intent(in)    :: iotype\n+  integer, intent(in)             :: vlist(:)\n+  integer, intent(out)            :: istat\n+  character(len=*), intent(inout) :: imsg\n+  character(len=1) :: c\n+  integer :: i\n+  i = 0 ; imsg=''\n+  loop_read: do\n+    i = i + 1\n+    read( unit=lun, fmt='(a1)', iostat=istat, iomsg=imsg) c\n+    select case ( istat )\n+    case ( 0 )\n+      if (i.eq.1 .and. c.ne.'h') exit loop_read\n+      !write( output_unit, fmt=sfmt) \"i = \", i, \", c = \", c\n+    case ( iostat_end )\n+      !write( output_unit, fmt=sfmt) \"i = \", i, \", istat = iostat_end\"\n+      exit loop_read\n+    case ( iostat_eor )\n+      !write( output_unit, fmt=sfmt) \"i = \", i, \", istat = iostat_eor\"\n+      exit loop_read\n+    case default\n+      !write( output_unit, fmt=sfmt) \"i = \", i, \", istat = \", istat\n+      exit loop_read\n+    end select\n+    if (i.gt.10) exit loop_read\n+  end do loop_read\n+end subroutine read_t\n+end module t_m\n+\n+program p\n+  use t_m, only : t\n+  implicit none\n+  \n+  character(len=:), allocatable :: s\n+  type(t) :: foo\n+  character(len=256) :: imsg\n+  integer :: istat\n+  \n+  open(10, status=\"scratch\")\n+  write(10,'(a)') 'hello'\n+  rewind(10)\n+  read(unit=10, fmt='(dt)', iostat=istat, iomsg=imsg) foo\n+  if (imsg.ne.\"End of record\") call abort\n+  rewind(10)\n+  read(unit=10, fmt=*, iostat=istat, iomsg=imsg) foo\n+  if (imsg.ne.\"End of record\") call abort\n+  s = \"hello\"\n+  read( unit=s, fmt='(dt)', iostat=istat, iomsg=imsg) foo\n+  if (imsg.ne.\"End of record\") call abort\n+  read( unit=s, fmt=*, iostat=istat, iomsg=imsg) foo\n+  if (imsg.ne.\"End of record\") call abort\n+end program p\n+\n+! { dg-final { cleanup-modules \"t_m\" } }"}, {"sha": "12e3f1fa696bf598996496fcdc65b242f36d91c2", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f10d710e321ad92322adf90342cf99fa3f9d356/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f10d710e321ad92322adf90342cf99fa3f9d356/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=1f10d710e321ad92322adf90342cf99fa3f9d356", "patch": "@@ -1,3 +1,21 @@\n+2017-03-25  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/78881\n+\t* io/io.h (st_parameter_dt): Rename unused component last_char to\n+\tchild_saved_iostat. Move comment to gfc_unit.\n+\t* io/list_read.c (list_formatted_read_scalar): After call to\n+\tchild READ procedure, save the returned iostat value for later\n+\tcheck. (finish_list_read): Only finish READ if child_saved_iostat\n+\twas OK.\n+\t* io/transfer.c (read_sf_internal): If there is a saved character\n+\tin last character, seek back one. Add a new check for EOR\n+\tcondition. (read_sf): If there is a saved character\n+\tin last character, seek back one. (formatted_transfer_scalar_read):\n+\tInitialize last character before invoking child procedure.\n+\t(data_transfer_init): If child dtio, set advance\n+\tstatus to nonadvancing. Move update of size and check for EOR\n+\tcondition to before child dtio return.\n+\n 2017-03-17  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR libfortran/79956"}, {"sha": "df4915773491a60877255f2303df591d8c60732b", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f10d710e321ad92322adf90342cf99fa3f9d356/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f10d710e321ad92322adf90342cf99fa3f9d356/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=1f10d710e321ad92322adf90342cf99fa3f9d356", "patch": "@@ -534,10 +534,7 @@ typedef struct st_parameter_dt\n \t  unsigned expanded_read : 1;\n \t  /* 13 unused bits.  */\n \n-\t  /* Used for ungetc() style functionality. Possible values\n-\t     are an unsigned char, EOF, or EOF - 1 used to mark the\n-\t     field as not valid.  */\n-\t  int last_char; /* No longer used, moved to gfc_unit.  */\n+\t  int child_saved_iostat;\n \t  int nml_delim;\n \t  int repeat_count;\n \t  int saved_length;\n@@ -701,6 +698,10 @@ typedef struct gfc_unit\n \n   /* DTIO Parent/Child procedure, 0 = parent, >0 = child level.  */\n   int child_dtio;\n+\n+  /* Used for ungetc() style functionality. Possible values\n+     are an unsigned char, EOF, or EOF - 1 used to mark the\n+     field as not valid.  */\n   int last_char;\n   bool has_size;\n   GFC_IO_INT size_used;"}, {"sha": "39805baaeabd159d93d98689d643d12f8ee12817", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f10d710e321ad92322adf90342cf99fa3f9d356/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f10d710e321ad92322adf90342cf99fa3f9d356/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=1f10d710e321ad92322adf90342cf99fa3f9d356", "patch": "@@ -2221,6 +2221,7 @@ list_formatted_read_scalar (st_parameter_dt *dtp, bt type, void *p,\n \t  dtp->u.p.fdtio_ptr (p, &unit, iotype, &vlist,\n \t\t\t      child_iostat, child_iomsg,\n \t\t\t      iotype_len, child_iomsg_len);\n+\t  dtp->u.p.child_saved_iostat = *child_iostat;\n \t  dtp->u.p.current_unit->child_dtio--;\n       }\n       break;\n@@ -2352,15 +2353,18 @@ finish_list_read (st_parameter_dt *dtp)\n       /* Set the next_char and push_char worker functions.  */\n       set_workers (dtp);\n \n-      c = next_char (dtp);\n-      if (c == EOF)\n+      if (likely (dtp->u.p.child_saved_iostat == LIBERROR_OK))\n \t{\n-\t  free_line (dtp);\n-\t  hit_eof (dtp);\n-\t  return;\n+\t  c = next_char (dtp);\n+\t  if (c == EOF)\n+\t    {\n+\t      free_line (dtp);\n+\t      hit_eof (dtp);\n+\t      return;\n+\t    }\n+\t  if (c != '\\n')\n+\t    eat_line (dtp);\n \t}\n-      if (c != '\\n')\n-\teat_line (dtp);\n     }\n \n   free_line (dtp);"}, {"sha": "1e56b5de1362085701f24801bc3dcedbd6061f1f", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f10d710e321ad92322adf90342cf99fa3f9d356/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f10d710e321ad92322adf90342cf99fa3f9d356/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=1f10d710e321ad92322adf90342cf99fa3f9d356", "patch": "@@ -226,7 +226,7 @@ static char *\n read_sf_internal (st_parameter_dt *dtp, int * length)\n {\n   static char *empty_string[0];\n-  char *base;\n+  char *base = NULL;\n   int lorig;\n \n   /* Zero size array gives internal unit len of 0.  Nothing to read. */\n@@ -244,6 +244,15 @@ read_sf_internal (st_parameter_dt *dtp, int * length)\n       return (char*) empty_string;\n     }\n \n+  /* There are some cases with mixed DTIO where we have read a character\n+     and saved it in the last character buffer, so we need to backup.  */\n+  if (unlikely (dtp->u.p.current_unit->child_dtio > 0 &&\n+\t\tdtp->u.p.current_unit->last_char != EOF - 1))\n+    {\n+      dtp->u.p.current_unit->last_char = EOF - 1;\n+      sseek (dtp->u.p.current_unit->s, -1, SEEK_CUR);\n+    }\n+\n   lorig = *length;\n   if (is_char4_unit(dtp))\n     {\n@@ -263,6 +272,12 @@ read_sf_internal (st_parameter_dt *dtp, int * length)\n       return NULL;\n     }\n \n+  if (base && *base == 0)\n+    {\n+      generate_error (&dtp->common, LIBERROR_EOR, NULL);\n+      return NULL;\n+    }\n+\n   dtp->u.p.current_unit->bytes_left -= *length;\n \n   if (((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0) ||\n@@ -304,6 +319,15 @@ read_sf (st_parameter_dt *dtp, int * length)\n       return (char*) empty_string;\n     }\n \n+  /* There are some cases with mixed DTIO where we have read a character\n+     and saved it in the last character buffer, so we need to backup.  */\n+  if (unlikely (dtp->u.p.current_unit->child_dtio > 0 &&\n+\t\tdtp->u.p.current_unit->last_char != EOF - 1))\n+    {\n+      dtp->u.p.current_unit->last_char = EOF - 1;\n+      fbuf_seek (dtp->u.p.current_unit, -1, SEEK_CUR);\n+    }\n+\n   n = seen_comma = 0;\n \n   /* Read data into format buffer and scan through it.  */\n@@ -1499,6 +1523,7 @@ formatted_transfer_scalar_read (st_parameter_dt *dtp, bt type, void *p, int kind\n \n \t  /* Call the user defined formatted READ procedure.  */\n \t  dtp->u.p.current_unit->child_dtio++;\n+\t  dtp->u.p.current_unit->last_char = EOF - 1;\n \t  dtp->u.p.fdtio_ptr (p, &unit, iotype, f->u.udf.vlist,\n \t\t\t      child_iostat, child_iomsg,\n \t\t\t      iotype_len, child_iomsg_len);\n@@ -2856,6 +2881,11 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \t}\n     }\n \n+  /* Child IO is non-advancing and any ADVANCE= specifier is ignored.\n+     F2008 9.6.2.4  */\n+  if (dtp->u.p.current_unit->child_dtio  > 0)\n+    dtp->u.p.advance_status = ADVANCE_NO;\n+\n   if (read_flag)\n     {\n       dtp->u.p.current_unit->previous_nonadvancing_write = 0;\n@@ -3856,6 +3886,15 @@ finalize_transfer (st_parameter_dt *dtp)\n \t namelist_write (dtp);\n     }\n \n+  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n+    *dtp->size = dtp->u.p.current_unit->size_used;\n+\n+  if (dtp->u.p.eor_condition)\n+    {\n+      generate_error (&dtp->common, LIBERROR_EOR, NULL);\n+      goto done;\n+    }\n+\n   if (dtp->u.p.current_unit && (dtp->u.p.current_unit->child_dtio  > 0))\n     {\n       if (cf & IOPARM_DT_HAS_FORMAT)\n@@ -3866,15 +3905,6 @@ finalize_transfer (st_parameter_dt *dtp)\n       return;\n     }\n \n-  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n-    *dtp->size = dtp->u.p.current_unit->size_used;\n-\n-  if (dtp->u.p.eor_condition)\n-    {\n-      generate_error (&dtp->common, LIBERROR_EOR, NULL);\n-      goto done;\n-    }\n-\n   if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     {\n       if (dtp->u.p.current_unit && current_mode (dtp) == UNFORMATTED_SEQUENTIAL)"}]}