{"sha": "69c3654cc6596daad012afc093ed05b6756b0377", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjljMzY1NGNjNjU5NmRhYWQwMTJhZmMwOTNlZDA1YjY3NTZiMDM3Nw==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2014-07-26T09:49:00Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2014-07-26T09:49:00Z"}, "message": "check.c (gfc_check_sizeof): Permit for assumed type if and only if it has an array descriptor.\n\n2014-07-26  Tobias Burnus  <burnus@net-b.de>\n\n        * check.c (gfc_check_sizeof): Permit for assumed type if and\n        only if it has an array descriptor.\n        * intrinsic.c (do_ts29113_check): Permit SIZEOF.\n        (add_functions): SIZEOF is an Inquiry function.\n        * intrinsic.texi (SIZEOF): Add note that only contiguous\n        arrays are permitted.\n        * trans-expr.c (gfc_conv_intrinsic_to_class): Handle assumed\n        rank.\n        * trans-intrinsic.c (gfc_conv_intrinsic_sizeof): Handle\n        assumed type + array descriptor, CLASS and assumed rank.\n        (gfc_conv_intrinsic_storage_size): Handle class arrays.\n\n2014-07-26  Tobias Burnus  <burnus@net-b.de>\n\n        * gfortran.dg/sizeof_2.f90: Change dg-error.\n        * gfortran.dg/sizeof_4.f90: New.\n        * gfortran.dg/storage_size_1.f08: Correct expected\n        value.\n\nFrom-SVN: r213079", "tree": {"sha": "b74b389b6eb95e38ae8dfd0d215a3cb99608ffb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b74b389b6eb95e38ae8dfd0d215a3cb99608ffb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69c3654cc6596daad012afc093ed05b6756b0377", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69c3654cc6596daad012afc093ed05b6756b0377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69c3654cc6596daad012afc093ed05b6756b0377", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69c3654cc6596daad012afc093ed05b6756b0377/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2da068d5c04c748a27fa0694eb00bb385bac13aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2da068d5c04c748a27fa0694eb00bb385bac13aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2da068d5c04c748a27fa0694eb00bb385bac13aa"}], "stats": {"total": 231, "additions": 176, "deletions": 55}, "files": [{"sha": "9a82894275be26c8745d360a02fb1460911c1f32", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69c3654cc6596daad012afc093ed05b6756b0377/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69c3654cc6596daad012afc093ed05b6756b0377/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=69c3654cc6596daad012afc093ed05b6756b0377", "patch": "@@ -1,3 +1,17 @@\n+2014-07-26  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* check.c (gfc_check_sizeof): Permit for assumed type if and\n+\tonly if it has an array descriptor.\n+\t* intrinsic.c (do_ts29113_check): Permit SIZEOF.\n+\t(add_functions): SIZEOF is an Inquiry function.\n+\t* intrinsic.texi (SIZEOF): Add note that only contiguous\n+\tarrays are permitted.\n+\t* trans-expr.c (gfc_conv_intrinsic_to_class): Handle assumed\n+\trank.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_sizeof): Handle\n+\tassumed type + array descriptor, CLASS and assumed rank.\n+\t(gfc_conv_intrinsic_storage_size): Handle class arrays.\n+\n 2014-07-25  Tobias Burnus  <burnus@net-b.de>\n \n \t* simplify.c (gfc_simplify_storage_size): Use proper"}, {"sha": "95d28693f2737b020f9e2d10d11e09cf43b99b6a", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69c3654cc6596daad012afc093ed05b6756b0377/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69c3654cc6596daad012afc093ed05b6756b0377/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=69c3654cc6596daad012afc093ed05b6756b0377", "patch": "@@ -3902,7 +3902,12 @@ gfc_check_sizeof (gfc_expr *arg)\n       return false;\n     }\n \n-  if (arg->ts.type == BT_ASSUMED)\n+  /* TYPE(*) is acceptable if and only if it uses an array descriptor.  */\n+  if (arg->ts.type == BT_ASSUMED\n+      && (arg->symtree->n.sym->as == NULL\n+\t  || (arg->symtree->n.sym->as->type != AS_ASSUMED_SHAPE\n+\t      && arg->symtree->n.sym->as->type != AS_DEFERRED\n+\t      && arg->symtree->n.sym->as->type != AS_ASSUMED_RANK)))\n     {\n       gfc_error (\"'%s' argument of '%s' intrinsic at %L shall not be TYPE(*)\",\n \t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,"}, {"sha": "1ad1e6921354ba49581f5990211dbda277e28f0a", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69c3654cc6596daad012afc093ed05b6756b0377/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69c3654cc6596daad012afc093ed05b6756b0377/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=69c3654cc6596daad012afc093ed05b6756b0377", "patch": "@@ -204,6 +204,7 @@ do_ts29113_check (gfc_intrinsic_sym *specific, gfc_actual_arglist *arg)\n \t       && specific->id != GFC_ISYM_RANK\n \t       && specific->id != GFC_ISYM_SHAPE\n \t       && specific->id != GFC_ISYM_SIZE\n+\t       && specific->id != GFC_ISYM_SIZEOF\n \t       && specific->id != GFC_ISYM_UBOUND\n \t       && specific->id != GFC_ISYM_C_LOC)\n \t{\n@@ -2765,8 +2766,9 @@ add_functions (void)\n \t     ar, BT_REAL, dr, REQUIRED, dm, BT_INTEGER, ii, OPTIONAL);\n   make_from_module();\n \n-  add_sym_1 (\"sizeof\", GFC_ISYM_SIZEOF, CLASS_IMPURE, ACTUAL_NO, BT_INTEGER, ii,\n-\t     GFC_STD_GNU, gfc_check_sizeof, gfc_simplify_sizeof, NULL,\n+  add_sym_1 (\"sizeof\", GFC_ISYM_SIZEOF, CLASS_INQUIRY, ACTUAL_NO,\n+\t     BT_INTEGER, ii, GFC_STD_GNU,\n+\t     gfc_check_sizeof, gfc_simplify_sizeof, NULL,\n \t     x, BT_UNKNOWN, 0, REQUIRED);\n \n   make_generic (\"sizeof\", GFC_ISYM_SIZEOF, GFC_STD_GNU);"}, {"sha": "6c4cb0917a411c0f2597e02877daba3e69b62626", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69c3654cc6596daad012afc093ed05b6756b0377/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69c3654cc6596daad012afc093ed05b6756b0377/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=69c3654cc6596daad012afc093ed05b6756b0377", "patch": "@@ -12205,7 +12205,9 @@ to is returned.  If the argument is of a derived type with @code{POINTER}\n or @code{ALLOCATABLE} components, the return value does not account for\n the sizes of the data pointed to by these components. If the argument is\n polymorphic, the size according to the declared type is returned. The argument\n-may not be a procedure or procedure pointer.\n+may not be a procedure or procedure pointer. Note that the code assumes for\n+arrays that those are contiguous; for contiguous arrays, it returns the\n+storage or an array element multiplicated by the size of the array.\n \n @item @emph{Example}:\n @smallexample"}, {"sha": "02cec973c1a45789097584164ff71dd6c6ebe0a9", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69c3654cc6596daad012afc093ed05b6756b0377/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69c3654cc6596daad012afc093ed05b6756b0377/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=69c3654cc6596daad012afc093ed05b6756b0377", "patch": "@@ -564,7 +564,7 @@ gfc_conv_intrinsic_to_class (gfc_se *parmse, gfc_expr *e,\n   var = gfc_create_var (tmp, \"class\");\n \n   /* Set the vptr.  */\n-  ctree =  gfc_class_vptr_get (var);\n+  ctree = gfc_class_vptr_get (var);\n \n   vtab = gfc_find_vtab (&e->ts);\n   gcc_assert (vtab);\n@@ -573,7 +573,7 @@ gfc_conv_intrinsic_to_class (gfc_se *parmse, gfc_expr *e,\n \t\t  fold_convert (TREE_TYPE (ctree), tmp));\n \n   /* Now set the data field.  */\n-  ctree =  gfc_class_data_get (var);\n+  ctree = gfc_class_data_get (var);\n   if (parmse->ss && parmse->ss->info->useflags)\n     {\n       /* For an array reference in an elemental procedure call we need\n@@ -589,15 +589,31 @@ gfc_conv_intrinsic_to_class (gfc_se *parmse, gfc_expr *e,\n \t{\n \t  parmse->ss = NULL;\n \t  gfc_conv_expr_reference (parmse, e);\n-\t  tmp = fold_convert (TREE_TYPE (ctree), parmse->expr);\n+\t  if (class_ts.u.derived->components->as\n+\t      && class_ts.u.derived->components->as->type == AS_ASSUMED_RANK)\n+\t    {\n+\t      tmp = gfc_conv_scalar_to_descriptor (parmse, parmse->expr,\n+\t\t\t\t\t\t   gfc_expr_attr (e));\n+\t      tmp = fold_build1_loc (input_location, VIEW_CONVERT_EXPR,\n+\t\t\t\t     TREE_TYPE (ctree), tmp);\n+\t    }\n+\t  else\n+\t      tmp = fold_convert (TREE_TYPE (ctree), parmse->expr);\n \t  gfc_add_modify (&parmse->pre, ctree, tmp);\n \t}\n       else\n \t{\n \t  parmse->ss = ss;\n \t  parmse->use_offset = 1;\n \t  gfc_conv_expr_descriptor (parmse, e);\n-\t  gfc_add_modify (&parmse->pre, ctree, parmse->expr);\n+\t  if (class_ts.u.derived->components->as->rank != e->rank)\n+\t    {\n+\t      tmp = fold_build1_loc (input_location, VIEW_CONVERT_EXPR,\n+\t\t\t\t     TREE_TYPE (ctree), parmse->expr);\n+\t      gfc_add_modify (&parmse->pre, ctree, tmp);\n+\t    }\n+\t  else\n+\t    gfc_add_modify (&parmse->pre, ctree, parmse->expr);\n \t}\n     }\n "}, {"sha": "9059878b9daf5019f3a556b96403e3c24394d925", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 120, "deletions": 45, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69c3654cc6596daad012afc093ed05b6756b0377/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69c3654cc6596daad012afc093ed05b6756b0377/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=69c3654cc6596daad012afc093ed05b6756b0377", "patch": "@@ -5891,62 +5891,131 @@ gfc_conv_intrinsic_sizeof (gfc_se *se, gfc_expr *expr)\n   gfc_expr *arg;\n   gfc_se argse;\n   tree source_bytes;\n-  tree type;\n   tree tmp;\n   tree lower;\n   tree upper;\n+  tree byte_size;\n   int n;\n \n-  arg = expr->value.function.actual->expr;\n-\n   gfc_init_se (&argse, NULL);\n+  arg = expr->value.function.actual->expr;\n \n-  if (arg->rank == 0)\n+  if (arg->rank || arg->ts.type == BT_ASSUMED)\n+    gfc_conv_expr_descriptor (&argse, arg);\n+  else\n+    gfc_conv_expr_reference (&argse, arg);\n+\n+  if (arg->ts.type == BT_ASSUMED)\n+    {\n+      /* This only works if an array descriptor has been passed; thus, extract\n+\t  the size from the descriptor.  */\n+      gcc_assert (TYPE_PRECISION (gfc_array_index_type)\n+\t\t  == TYPE_PRECISION (size_type_node));\n+      tmp = arg->symtree->n.sym->backend_decl;\n+      tmp = DECL_LANG_SPECIFIC (tmp)\n+\t    && GFC_DECL_SAVED_DESCRIPTOR (tmp) != NULL_TREE\n+\t    ? GFC_DECL_SAVED_DESCRIPTOR (tmp) : tmp;\n+      if (POINTER_TYPE_P (TREE_TYPE (tmp)))\n+\ttmp = build_fold_indirect_ref_loc (input_location, tmp);\n+      tmp = fold_convert (size_type_node, gfc_conv_descriptor_dtype (tmp));\n+      tmp = fold_build2_loc (input_location, RSHIFT_EXPR, TREE_TYPE (tmp), tmp,\n+\t\t\t     build_int_cst (TREE_TYPE (tmp),\n+\t\t\t\t\t    GFC_DTYPE_SIZE_SHIFT));\n+      byte_size = fold_convert (gfc_array_index_type, tmp);\n+    }\n+  else if (arg->ts.type == BT_CLASS)\n+    {\n+      if (arg->rank)\n+\tbyte_size = gfc_vtable_size_get (TREE_OPERAND (argse.expr, 0));\n+      else\n+\tbyte_size = gfc_vtable_size_get (argse.expr);\n+    }\n+  else\n     {\n-      if (arg->ts.type == BT_CLASS)\n-\tgfc_add_data_component (arg);\n-\n-      gfc_conv_expr_reference (&argse, arg);\n-\n-      type = TREE_TYPE (build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t argse.expr));\n-\n-      /* Obtain the source word length.  */\n       if (arg->ts.type == BT_CHARACTER)\n-\tse->expr = size_of_string_in_bytes (arg->ts.kind,\n-\t\t\t\t\t    argse.string_length);\n+\tbyte_size = size_of_string_in_bytes (arg->ts.kind, argse.string_length);\n       else\n-\tse->expr = fold_convert (gfc_array_index_type, size_in_bytes (type)); \n+\t{\n+\t  if (arg->rank == 0)\n+\t    byte_size = TREE_TYPE (build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t\t\targse.expr));\n+\t  else\n+\t    byte_size = gfc_get_element_type (TREE_TYPE (argse.expr));\n+\t  byte_size = fold_convert (gfc_array_index_type,\n+\t\t\t\t    size_in_bytes (byte_size));\n+\t}\n     }\n+\n+  if (arg->rank == 0)\n+    se->expr = byte_size;\n   else\n     {\n       source_bytes = gfc_create_var (gfc_array_index_type, \"bytes\");\n-      argse.want_pointer = 0;\n-      gfc_conv_expr_descriptor (&argse, arg);\n-      type = gfc_get_element_type (TREE_TYPE (argse.expr));\n+      gfc_add_modify (&argse.pre, source_bytes, byte_size);\n \n-      /* Obtain the argument's word length.  */\n-      if (arg->ts.type == BT_CHARACTER)\n-\ttmp = size_of_string_in_bytes (arg->ts.kind, argse.string_length);\n-      else\n-\ttmp = fold_convert (gfc_array_index_type,\n-\t\t\t    size_in_bytes (type)); \n-      gfc_add_modify (&argse.pre, source_bytes, tmp);\n-\n-      /* Obtain the size of the array in bytes.  */\n-      for (n = 0; n < arg->rank; n++)\n+      if (arg->rank == -1)\n \t{\n-\t  tree idx;\n-\t  idx = gfc_rank_cst[n];\n-\t  lower = gfc_conv_descriptor_lbound_get (argse.expr, idx);\n-\t  upper = gfc_conv_descriptor_ubound_get (argse.expr, idx);\n-\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t\t gfc_array_index_type, upper, lower);\n-\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t gfc_array_index_type, tmp, gfc_index_one_node);\n+\t  tree cond, loop_var, exit_label;\n+          stmtblock_t body;\n+\n+\t  tmp = fold_convert (gfc_array_index_type,\n+\t\t\t      gfc_conv_descriptor_rank (argse.expr));\n+\t  loop_var = gfc_create_var (gfc_array_index_type, \"i\");\n+\t  gfc_add_modify (&argse.pre, loop_var, gfc_index_zero_node);\n+          exit_label = gfc_build_label_decl (NULL_TREE);\n+\n+\t  /* Create loop:\n+\t     for (;;)\n+\t\t{\n+\t\t  if (i >= rank)\n+\t\t    goto exit;\n+\t\t  source_bytes = source_bytes * array.dim[i].extent;\n+\t\t  i = i + 1;\n+\t\t}\n+\t      exit:  */\n+\t  gfc_start_block (&body);\n+\t  cond = fold_build2_loc (input_location, GE_EXPR, boolean_type_node,\n+\t\t\t\t  loop_var, tmp);\n+\t  tmp = build1_v (GOTO_EXPR, exit_label);\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t cond, tmp, build_empty_stmt (input_location));\n+\t  gfc_add_expr_to_block (&body, tmp);\n+\n+\t  lower = gfc_conv_descriptor_lbound_get (argse.expr, loop_var);\n+\t  upper = gfc_conv_descriptor_ubound_get (argse.expr, loop_var);\n+\t  tmp = gfc_conv_array_extent_dim (lower, upper, NULL);\n \t  tmp = fold_build2_loc (input_location, MULT_EXPR,\n \t\t\t\t gfc_array_index_type, tmp, source_bytes);\n-\t  gfc_add_modify (&argse.pre, source_bytes, tmp);\n+\t  gfc_add_modify (&body, source_bytes, tmp);\n+\n+\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, loop_var,\n+\t\t\t\t gfc_index_one_node);\n+\t  gfc_add_modify_loc (input_location, &body, loop_var, tmp);\n+\n+\t  tmp = gfc_finish_block (&body);\n+\n+\t  tmp = fold_build1_loc (input_location, LOOP_EXPR, void_type_node,\n+\t\t\t\t tmp);\n+\t  gfc_add_expr_to_block (&argse.pre, tmp);\n+\n+\t  tmp = build1_v (LABEL_EXPR, exit_label);\n+\t  gfc_add_expr_to_block (&argse.pre, tmp);\n+\t}\n+      else\n+\t{\n+\t  /* Obtain the size of the array in bytes.  */\n+\t  for (n = 0; n < arg->rank; n++)\n+\t    {\n+\t      tree idx;\n+\t      idx = gfc_rank_cst[n];\n+\t      lower = gfc_conv_descriptor_lbound_get (argse.expr, idx);\n+\t      upper = gfc_conv_descriptor_ubound_get (argse.expr, idx);\n+\t      tmp = gfc_conv_array_extent_dim (lower, upper, NULL);\n+\t      tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t     gfc_array_index_type, tmp, source_bytes);\n+\t      gfc_add_modify (&argse.pre, source_bytes, tmp);\n+\t    }\n \t}\n       se->expr = source_bytes;\n     }\n@@ -5970,13 +6039,13 @@ gfc_conv_intrinsic_storage_size (gfc_se *se, gfc_expr *expr)\n   if (arg->rank == 0)\n     {\n       if (arg->ts.type == BT_CLASS)\n-      {\n-\tgfc_add_vptr_component (arg);\n-\tgfc_add_size_component (arg);\n-\tgfc_conv_expr (&argse, arg);\n-\ttmp = fold_convert (result_type, argse.expr);\n-\tgoto done;\n-      }\n+\t{\n+\t  gfc_add_vptr_component (arg);\n+\t  gfc_add_size_component (arg);\n+\t  gfc_conv_expr (&argse, arg);\n+\t  tmp = fold_convert (result_type, argse.expr);\n+\t  goto done;\n+\t}\n \n       gfc_conv_expr_reference (&argse, arg);\n       type = TREE_TYPE (build_fold_indirect_ref_loc (input_location, \n@@ -5986,6 +6055,12 @@ gfc_conv_intrinsic_storage_size (gfc_se *se, gfc_expr *expr)\n     {\n       argse.want_pointer = 0;\n       gfc_conv_expr_descriptor (&argse, arg);\n+      if (arg->ts.type == BT_CLASS)\n+\t{\n+\t  tmp = gfc_vtable_size_get (TREE_OPERAND (argse.expr, 0));\n+\t  tmp = fold_convert (result_type, tmp);\n+\t  goto done;\n+\t}\n       type = gfc_get_element_type (TREE_TYPE (argse.expr));\n     }\n     "}, {"sha": "e007f31a782de893b017650b635144adb009e635", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69c3654cc6596daad012afc093ed05b6756b0377/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69c3654cc6596daad012afc093ed05b6756b0377/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=69c3654cc6596daad012afc093ed05b6756b0377", "patch": "@@ -1,3 +1,10 @@\n+2014-07-26  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.dg/sizeof_2.f90: Change dg-error.\n+\t* gfortran.dg/sizeof_4.f90: New.\n+\t* gfortran.dg/storage_size_1.f08: Correct expected\n+\tvalue.\n+\n 2014-07-26  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR target/44551"}, {"sha": "e6661a56b30787801995dd537222a117feb7850f", "filename": "gcc/testsuite/gfortran.dg/sizeof_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69c3654cc6596daad012afc093ed05b6756b0377/gcc%2Ftestsuite%2Fgfortran.dg%2Fsizeof_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69c3654cc6596daad012afc093ed05b6756b0377/gcc%2Ftestsuite%2Fgfortran.dg%2Fsizeof_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsizeof_2.f90?ref=69c3654cc6596daad012afc093ed05b6756b0377", "patch": "@@ -10,7 +10,7 @@ subroutine foo(x, y)\n   integer(8) :: ii\n   procedure() :: proc\n \n-  ii = sizeof (x) ! { dg-error \"Assumed-type argument at .1. is not permitted as actual argument to the intrinsic sizeof\" }\n+  ii = sizeof (x) ! { dg-error \"'x' argument of 'sizeof' intrinsic at \\\\(1\\\\) shall not be TYPE\\\\(\\\\*\\\\)\" }\n   ii = c_sizeof (x) ! { dg-error \"Assumed-type argument at .1. is not permitted as actual argument to the intrinsic c_sizeof\" }\n   ii = storage_size (x) ! { dg-error \"Assumed-type argument at .1. is not permitted as actual argument to the intrinsic storage_size\" }\n "}, {"sha": "71d3589c8ed227d1b5d9bdeb0ac85dcf6010bcc9", "filename": "gcc/testsuite/gfortran.dg/storage_size_1.f08", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69c3654cc6596daad012afc093ed05b6756b0377/gcc%2Ftestsuite%2Fgfortran.dg%2Fstorage_size_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69c3654cc6596daad012afc093ed05b6756b0377/gcc%2Ftestsuite%2Fgfortran.dg%2Fstorage_size_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstorage_size_1.f08?ref=69c3654cc6596daad012afc093ed05b6756b0377", "patch": "@@ -25,7 +25,7 @@\n if (sizeof(b)        /= 24) call abort()\n if (storage_size(b)  /= 64) call abort()\n \n-if (sizeof(cp)       /=  8) call abort()\n+if (sizeof(cp)       /= 12) call abort()\n if (storage_size(cp) /= 96) call abort()\n \n end"}]}