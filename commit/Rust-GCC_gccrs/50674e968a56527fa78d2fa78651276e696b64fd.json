{"sha": "50674e968a56527fa78d2fa78651276e696b64fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA2NzRlOTY4YTU2NTI3ZmE3OGQyZmE3ODY1MTI3NmU2OTZiNjRmZA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2006-01-19T16:55:52Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2006-01-19T16:55:52Z"}, "message": "tree-pretty-print.c (dump_generic_node): Handle OMP_PARALLEL_FN, OMP_PARALLEL_DATA_ARG and OMP_RETURN_EXPR.\n\n\n\t* tree-pretty-print.c (dump_generic_node): Handle\n\tOMP_PARALLEL_FN, OMP_PARALLEL_DATA_ARG and OMP_RETURN_EXPR.\n\t* cgraph.c (cgraph_expand_queue): Rename from\n\tcgraph_analyze_queue.\n\tUpdate all users.\n\t* cgraphunit.c (cgraph_assemble_pending_functions): Process\n\tcgraph_expand_queue.\n\t(cgraph_expand_all_functions): Likewise.\n\t(cgraph_finalize_pending_functions): Remove.  Update callers.\n\n\t* tree.h (OMP_DIRECTIVE_P): Define.\n\t(OMP_PARALLEL_FN): Define.\n\t(OMP_PARALLEL_DATA_ARG): Define.\n\t(OMP_SECTIONS_SECTIONS): Define.\n\t* tree-pass.h (pass_expand_omp): Declare.\n\t* omp-low.c (struct omp_region): Declare.\n\t(struct omp_context): Remove fields 'parallel_type',\n\t'parallel_start_ix' and 'parallel_start_additional_args'.\n\tUpdate all users.\n\t(struct omp_for_data): Rename from struct expand_omp_for_data.\n\t(omp_regions): New static variable.\n\t(root_omp_region): New static variable.\n\t(find_omp_clause): Make static.\n\t(is_in_combined_parallel_ctx): Remove.\n\t(is_combined_parallel): New.\n\t(extract_omp_for_data): Move earlier in the file.\n\t(workshare_safe_to_combine_p): New.\n\t(get_ws_args_for): New.\n\t(determine_parallel_type): Move earlier in the file.\n\t(omp_copy_decl_2): Do not set DECL_CONTEXT of new local to the\n\tchild function.\n\t(omp_copy_decl): Likewise.\n\t(create_omp_child_function): Likewise.\n\t(lookup_omp_region): New.\n\t(dump_omp_region): New.\n\t(debug_omp_region): New.\n\t(debug_all_omp_regions): New.\n\t(new_omp_region): New.\n\t(scan_omp_parallel): If parallel_nesting_level > 1, the\n\tdirective is nested within another parallel directive.\n\tSet OMP_PARALLEL_FN.\n\t(scan_omp_for): Do not try to handle combined parallel+for\n\tcases.\n\tRemove FIXME comment.\n\t(scan_omp_nested): Remove.\n\t(scan_omp_1): Do not call scan_omp_nested when\n\tparallel_nesting_level is > 1.\n\tDo not change the DECL_CONTEXT of local variables found.\n\t(lookup_decl_in_outer_ctx): New.\n\t(lower_rec_input_clauses): Rename from expand_rec_input_clauses.\n\t(lower_lastprivate_clauses): Rename from expand_lastprivate_clauses.\n\t(lower_reduction_clauses): Rename from expand_reduction_clauses.\n\t(lower_copyprivate_clauses): Rename from expand_copyprivate_clauses.\n\tIf CTX is nested, lookup VAR in the outer context when\n\tbuilding copy assignment.\n\t(lower_send_clauses): Rename from expand_send_clauses.\n\tIf CTX is nested, lookup VAR in the outer context when\n\tbuilding copy assignments.\n\t(lower_send_shared_vars): Rename from expand_send_shared_vars.\n\tIf CTX is nested, lookup VAR in the outer context when\n\tbuilding copy assignments.\n\t(expand_parallel_call): Rename from build_parallel_call.\n\tHandle combined parallel+workshare cases.\n\tRe-implement to emit code into the CFG.\n\t(list2chain): New.\n\t(expand_omp_parallel): Re-implement to emit code into the CFG.\n\tCall move_sese_region_to_fn to outline the sub-graph\n\tcontaining the parallel region.\n\t(expand_omp_for_1): Remove.\n\t(expand_omp_for_generic): Re-implement to emit code into the\n\tCFG.\n\t(expand_omp_for_static_nochunk): Likewise.\n\t(expand_omp_for_static_chunk): Likewise.\n\t(expand_omp_for): Likewise.\n\t(expand_omp_sections): Likewise.\n\t(remove_exit_barriers): New.\n\t(expand_omp_synch): New.\n\t(expand_omp): New.\n\t(build_omp_regions_1): New.\n\t(build_omp_regions): New.\n\t(execute_expand_omp): New.\n\t(gate_expand_omp): New.\n\t(pass_expand_omp): Define.\n\t(lower_omp_sections): Rename from expand_omp_sections.\n\tSet OMP_SECTIONS_SECTIONS.\n\t(lower_omp_single_simple): Rename from expand_omp_single_simple.\n\t(lower_omp_single_copy): Rename from expand_omp_single_copy.\n\t(lower_omp_single): Rename from expand_omp_simple.\n\t(lower_omp_master): Rename from expand_omp_master.\n\t(lower_omp_ordered): Rename from expand_omp_ordered.\n\t(lower_omp_critical): Rename from expand_omp_critical.\n\t(lower_omp_for_lastprivate): Rename from expand_omp_for_lastprivate.\n\t(lower_omp_for): Re-implement.\n\t(lower_omp_parallel): Re-implement.\n\t(lower_regimplify): Rename from expand_regimplify.\n\t(lower_omp_1): Rename from expand_omp_1.\n\tIf there are syntax errors in the program, replace every\n\tOpenMP directive with NOP.\n\tCall lower_omp_* instead of expand_omp_*.\n\t(lower_omp): Rename from expand_omp.\n\n\t* tree-gimple.c (is_gimple_stmt): Handle OMP_RETURN_EXPR.\n\t* tree-gimple.h (enum omp_parallel_type): Remove.\n\t(gimple_boolify): Declare extern.\n\t(find_omp_clause, determine_parallel_type): Remove.\n\n\t* gimple-low.c (lower_omp_directive): New.\n\t(lower_stmt): Call it.\n\t(record_vars_into): Move from ...\n\t(record_vars): ... here.\n\tCall record_vars_into with current_function_decl.\n\n\t* gimplify.c (struct gimplify_ctx): Remove fields\n\tcombined_pre_p and combined_ctxp.  Update users.\n\t(get_formal_tmp_var): Add documentation.\n\t(gimple_boolify): Make extern.\n\t(gimplify_expr_in_ctx): Remove.  Update callers.\n\t(gimplify_omp_parallel): Do not assume that OMP_PARALLEL_BODY\n\twill always be a BIND_EXPR.\n\t(gimplify_expr): Handle OMP_RETURN_EXPR.\n\t* tree.def (BLOCK): Remove documentation about BLOCK_TYPE_TAGS.\n\t(OMP_PARALLEL): Add 3 operands.\n\t(OMP_SECTIONS): Add 1 operand.\n\t(OMP_RETURN_EXPR): Define.\n\n\t* tree-inline.c (estimate_num_insns_1): Handle OpenMP directives.\n\t(copy_tree_r): Restore TREE_CHAIN in OMP_CLAUSE_*.\n\t* tree-iterator.c (alloc_stmt_list): Assert that we are not\n\tcreating a circular free list.\n\t(free_stmt_list): Assert that we are not freeing stmt_list_cache.\n\n\t* tree-flow.h (move_sese_region_to_fn): Declare.\n\t(record_vars_into): Declare.\n\t* tree-cfg.c (make_omp_sections_edges): New.\n\t(make_exit_edges): Handle OMP_PARALLEL, OMP_FOR, OMP_SINGLE,\n\tOMP_MASTER, OMP_ORDERED, OMP_CRITICAL, OMP_RETURN_EXPR,\n\tOMP_SECTIONS and OMP_SECTION.\n\t(is_ctrl_altering_stmt): Return true for OMP_DIRECTIVE_P.\n\t(set_bb_for_stmt): Undo change to check currently_expanding_to_rtl.\n\t(verify_stmt): Do not handle OMP_DIRECTIVE_P.\n\t(gather_blocks_in_sese_region): New.\n\t(struct move_stmt_d): Declare.\n\t(move_stmt_r): New.\n\t(move_block_to_fn): New.\n\t(move_sese_region_to_fn): New.\n\n\t* passes.c (init_optimization_passes): Schedule\n\tpass_expand_omp after pass_init_datastructures.\n\n\t* tree-ssa-operands.c (get_expr_operands): Handle\n\tOMP_PARALLEL, OMP_SECTIONS, OMP_FOR, OMP_RETURN_EXPR,\n\tOMP_SINGLE, OMP_MASTER, OMP_ORDERED, OMP_CRITICAL.\n\n\ntestsuite/\n\n\t* testsuite/gcc.dg/gomp/for-13.c: Use -fdump-tree-ompexp.\n\t* testsuite/gcc.dg/gomp/critical-1.c: Likewise.\n\t* testsuite/gcc.dg/gomp/critical-3.c: Likewise.\n\t* testsuite/gcc.dg/gomp/empty.c: Likewise.\n\t* testsuite/gcc.dg/gomp/ordered-1.c: Likewise.\n\t* testsuite/gcc.dg/gomp/for-4.c: Likewise.\n\t* testsuite/gcc.dg/gomp/for-6.c: Likewise.\n\t* testsuite/gcc.dg/gomp/master-3.c: Likewise.\n\t* testsuite/gcc.dg/gomp/for-8.c: Likewise.\n\t* testsuite/gcc.dg/gomp/for-10.c: Likewise.\n\t* testsuite/gcc.dg/gomp/for-18.c: Likewise.\n\t* testsuite/gcc.dg/gomp/for-5.c: Likewise.\n\t* testsuite/gcc.dg/gomp/for-7.c: Likewise.\n\t* testsuite/gcc.dg/gomp/for-9.c: Likewise.\n\nFrom-SVN: r109969", "tree": {"sha": "40a0696b5a88f85ca1ddd8a91201d544d829b1f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40a0696b5a88f85ca1ddd8a91201d544d829b1f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50674e968a56527fa78d2fa78651276e696b64fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50674e968a56527fa78d2fa78651276e696b64fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50674e968a56527fa78d2fa78651276e696b64fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50674e968a56527fa78d2fa78651276e696b64fd/comments", "author": null, "committer": null, "parents": [{"sha": "307d19feb13bd6ba0886ef8bda1f17bf5ab5362c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/307d19feb13bd6ba0886ef8bda1f17bf5ab5362c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/307d19feb13bd6ba0886ef8bda1f17bf5ab5362c"}], "stats": {"total": 3582, "additions": 2634, "deletions": 948}, "files": [{"sha": "30f66bd4ba70da9ea8a87c9f855d1f60e96c3f14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -1,3 +1,157 @@\n+2006-01-19  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-pretty-print.c (dump_generic_node): Handle\n+\tOMP_PARALLEL_FN, OMP_PARALLEL_DATA_ARG and OMP_RETURN_EXPR.\n+\t* cgraph.c (cgraph_expand_queue): Rename from\n+\tcgraph_analyze_queue.  Update all users.\n+\t* cgraphunit.c (cgraph_assemble_pending_functions): Process\n+\tcgraph_expand_queue.\n+\t(cgraph_expand_all_functions): Likewise.\n+\t(cgraph_finalize_pending_functions): Remove.  Update callers.\n+\n+\t* tree.h (OMP_DIRECTIVE_P): Define.\n+\t(OMP_PARALLEL_FN): Define.\n+\t(OMP_PARALLEL_DATA_ARG): Define.\n+\t(OMP_SECTIONS_SECTIONS): Define.\n+\t* tree-pass.h (pass_expand_omp): Declare.\n+\t* omp-low.c (struct omp_region): Declare.\n+\t(struct omp_context): Remove fields 'parallel_type',\n+\t'parallel_start_ix' and 'parallel_start_additional_args'.\n+\tUpdate all users.\n+\t(struct omp_for_data): Rename from struct expand_omp_for_data.\n+\t(omp_regions): New static variable.\n+\t(root_omp_region): New static variable.\n+\t(find_omp_clause): Make static.\n+\t(is_in_combined_parallel_ctx): Remove.\n+\t(is_combined_parallel): New.\n+\t(extract_omp_for_data): Move earlier in the file.\n+\t(workshare_safe_to_combine_p): New.\n+\t(get_ws_args_for): New.\n+\t(determine_parallel_type): Move earlier in the file.\n+\t(omp_copy_decl_2): Do not set DECL_CONTEXT of new local to the\n+\tchild function.\n+\t(omp_copy_decl): Likewise.\n+\t(create_omp_child_function): Likewise.\n+\t(lookup_omp_region): New.\n+\t(dump_omp_region): New.\n+\t(debug_omp_region): New.\n+\t(debug_all_omp_regions): New.\n+\t(new_omp_region): New.\n+\t(scan_omp_parallel): If parallel_nesting_level > 1, the\n+\tdirective is nested within another parallel directive.\n+\tSet OMP_PARALLEL_FN.\n+\t(scan_omp_for): Do not try to handle combined parallel+for\n+\tcases.\n+\tRemove FIXME comment.\n+\t(scan_omp_nested): Remove.\n+\t(scan_omp_1): Do not call scan_omp_nested when\n+\tparallel_nesting_level is > 1.\n+\tDo not change the DECL_CONTEXT of local variables found.\n+\t(lookup_decl_in_outer_ctx): New.\n+\t(lower_rec_input_clauses): Rename from expand_rec_input_clauses.\n+\t(lower_lastprivate_clauses): Rename from expand_lastprivate_clauses.\n+\t(lower_reduction_clauses): Rename from expand_reduction_clauses.\n+\t(lower_copyprivate_clauses): Rename from expand_copyprivate_clauses.\n+\tIf CTX is nested, lookup VAR in the outer context when\n+\tbuilding copy assignment.\n+\t(lower_send_clauses): Rename from expand_send_clauses.\n+\tIf CTX is nested, lookup VAR in the outer context when\n+\tbuilding copy assignments.\n+\t(lower_send_shared_vars): Rename from expand_send_shared_vars.\n+\tIf CTX is nested, lookup VAR in the outer context when\n+\tbuilding copy assignments.\n+\t(expand_parallel_call): Rename from build_parallel_call.\n+\tHandle combined parallel+workshare cases.\n+\tRe-implement to emit code into the CFG.\n+\t(list2chain): New.\n+\t(expand_omp_parallel): Re-implement to emit code into the CFG.\n+\tCall move_sese_region_to_fn to outline the sub-graph\n+\tcontaining the parallel region.\n+\t(expand_omp_for_1): Remove.\n+\t(expand_omp_for_generic): Re-implement to emit code into the\n+\tCFG.\n+\t(expand_omp_for_static_nochunk): Likewise.\n+\t(expand_omp_for_static_chunk): Likewise.\n+\t(expand_omp_for): Likewise.\n+\t(expand_omp_sections): Likewise.\n+\t(remove_exit_barriers): New.\n+\t(expand_omp_synch): New.\n+\t(expand_omp): New.\n+\t(build_omp_regions_1): New.\n+\t(build_omp_regions): New.\n+\t(execute_expand_omp): New.\n+\t(gate_expand_omp): New.\n+\t(pass_expand_omp): Define.\n+\t(lower_omp_sections): Rename from expand_omp_sections.\n+\tSet OMP_SECTIONS_SECTIONS.\n+\t(lower_omp_single_simple): Rename from expand_omp_single_simple.\n+\t(lower_omp_single_copy): Rename from expand_omp_single_copy.\n+\t(lower_omp_single): Rename from expand_omp_simple.\n+\t(lower_omp_master): Rename from expand_omp_master.\n+\t(lower_omp_ordered): Rename from expand_omp_ordered.\n+\t(lower_omp_critical): Rename from expand_omp_critical.\n+\t(lower_omp_for_lastprivate): Rename from expand_omp_for_lastprivate.\n+\t(lower_omp_for): Re-implement.\n+\t(lower_omp_parallel): Re-implement.\n+\t(lower_regimplify): Rename from expand_regimplify.\n+\t(lower_omp_1): Rename from expand_omp_1.\n+\tIf there are syntax errors in the program, replace every\n+\tOpenMP directive with NOP.\n+\tCall lower_omp_* instead of expand_omp_*.\n+\t(lower_omp): Rename from expand_omp.\n+\n+\t* tree-gimple.c (is_gimple_stmt): Handle OMP_RETURN_EXPR.\n+\t* tree-gimple.h (enum omp_parallel_type): Remove.\n+\t(gimple_boolify): Declare extern.\n+\t(find_omp_clause, determine_parallel_type): Remove.\n+\n+\t* gimple-low.c (lower_omp_directive): New.\n+\t(lower_stmt): Call it.\n+\t(record_vars_into): Move from ...\n+\t(record_vars): ... here.\n+\tCall record_vars_into with current_function_decl.\n+\n+\t* gimplify.c (struct gimplify_ctx): Remove fields\n+\tcombined_pre_p and combined_ctxp.  Update users.\n+\t(get_formal_tmp_var): Add documentation.\n+\t(gimple_boolify): Make extern.\n+\t(gimplify_expr_in_ctx): Remove.  Update callers.\n+\t(gimplify_omp_parallel): Do not assume that OMP_PARALLEL_BODY\n+\twill always be a BIND_EXPR.\n+\t(gimplify_expr): Handle OMP_RETURN_EXPR.\n+\t* tree.def (BLOCK): Remove documentation about BLOCK_TYPE_TAGS.\n+\t(OMP_PARALLEL): Add 3 operands.\n+\t(OMP_SECTIONS): Add 1 operand.\n+\t(OMP_RETURN_EXPR): Define.\n+\n+\t* tree-inline.c (estimate_num_insns_1): Handle OpenMP directives.\n+\t(copy_tree_r): Restore TREE_CHAIN in OMP_CLAUSE_*.\n+\t* tree-iterator.c (alloc_stmt_list): Assert that we are not\n+\tcreating a circular free list.\n+\t(free_stmt_list): Assert that we are not freeing stmt_list_cache.\n+\n+\t* tree-flow.h (move_sese_region_to_fn): Declare.\n+\t(record_vars_into): Declare.\n+\t* tree-cfg.c (make_omp_sections_edges): New.\n+\t(make_exit_edges): Handle OMP_PARALLEL, OMP_FOR, OMP_SINGLE,\n+\tOMP_MASTER, OMP_ORDERED, OMP_CRITICAL, OMP_RETURN_EXPR,\n+\tOMP_SECTIONS and OMP_SECTION.\n+\t(is_ctrl_altering_stmt): Return true for OMP_DIRECTIVE_P.\n+\t(set_bb_for_stmt): Undo change to check currently_expanding_to_rtl.\n+\t(verify_stmt): Do not handle OMP_DIRECTIVE_P.\n+\t(gather_blocks_in_sese_region): New.\n+\t(struct move_stmt_d): Declare.\n+\t(move_stmt_r): New.\n+\t(move_block_to_fn): New.\n+\t(move_sese_region_to_fn): New.\n+\n+\t* passes.c (init_optimization_passes): Schedule\n+\tpass_expand_omp after pass_init_datastructures.\n+\n+\t* tree-ssa-operands.c (get_expr_operands): Handle\n+\tOMP_PARALLEL, OMP_SECTIONS, OMP_FOR, OMP_RETURN_EXPR,\n+\tOMP_SINGLE, OMP_MASTER, OMP_ORDERED, OMP_CRITICAL.\n+\n 2006-01-19  Jeff Law  <law@redhat.com>\n \n \t* tree-vrp.c (extract_range_from_assert): Refine the result range"}, {"sha": "a05f76dffd32873c4e3e5ac9512493fd28bf7213", "filename": "gcc/cgraph.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -113,8 +113,10 @@ struct cgraph_node *cgraph_nodes;\n /* Queue of cgraph nodes scheduled to be lowered.  */\n struct cgraph_node *cgraph_nodes_queue;\n \n-/* Queue of cgraph nodes scheduled to be analyzed.  */\n-struct cgraph_node *cgraph_analyze_queue;\n+/* Queue of cgraph nodes scheduled to be expanded.  This is a\n+   secondary queue used during optimization to accomodate passes that\n+   may generate new functions that need to be optimized and expanded.  */\n+struct cgraph_node *cgraph_expand_queue;\n \n /* Number of nodes in existence.  */\n int cgraph_n_nodes;\n@@ -1095,19 +1097,23 @@ cgraph_variable_initializer_availability (struct cgraph_varpool_node *node)\n }\n \n \n-/* Add the function FNDECL to the call graph.  This assumes that the\n-   body of FNDECL is in GENERIC form and ready to be processed by\n-   cgraph_finalize_function.  */\n+/* Add the function FNDECL to the call graph.  FNDECL is assumed to be\n+   in low GIMPLE form and ready to be processed by cgraph_finalize_function.\n+\n+   When operating in unit-at-a-time, a new callgraph node is added to\n+   CGRAPH_EXPAND_QUEUE, which is processed after all the original\n+   functions in the call graph .\n+\n+   When not in unit-at-a-time, the new callgraph node is added to\n+   CGRAPH_NODES_QUEUE for cgraph_assemble_pending_functions to\n+   process.  */\n \n void\n cgraph_add_new_function (tree fndecl)\n {\n-  /* We're called while lowering another function.  We can't do anything\n-     at this time without recursing.  Which would cause a GC at an \n-     inappropriate time.  */\n   struct cgraph_node *n = cgraph_node (fndecl);\n-  n->next_needed = cgraph_analyze_queue;\n-  cgraph_analyze_queue = n;\n+  n->next_needed = cgraph_expand_queue;\n+  cgraph_expand_queue = n;\n }\n \n #include \"gt-cgraph.h\""}, {"sha": "6e60f8c205e76a4b036f6803f526a521e0dfe3c7", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -152,7 +152,7 @@ struct cgraph_node GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n   /* Set when function is reachable by call from other function\n      that is either reachable or needed.  */\n   bool reachable;\n-  /* Set once the function is lowered (ie it's CFG is built).  */\n+  /* Set once the function is lowered (i.e. its CFG is built).  */\n   bool lowered;\n   /* Set once the function has been instantiated and its callee\n      lists created.  */\n@@ -239,7 +239,7 @@ extern GTY(()) int cgraph_max_uid;\n extern bool cgraph_global_info_ready;\n extern bool cgraph_function_flags_ready;\n extern GTY(()) struct cgraph_node *cgraph_nodes_queue;\n-extern GTY(()) struct cgraph_node *cgraph_analyze_queue;\n+extern GTY(()) struct cgraph_node *cgraph_expand_queue;\n \n extern GTY(()) struct cgraph_varpool_node *cgraph_varpool_first_unanalyzed_node;\n extern GTY(()) struct cgraph_varpool_node *cgraph_varpool_nodes_queue;"}, {"sha": "2b7942970bf3fbe89133c76a66b8989880203abc", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -353,8 +353,22 @@ cgraph_assemble_pending_functions (void)\n \t}\n     }\n \n+  /* Process CGRAPH_EXPAND_QUEUE, these are functions created during\n+     the expansion process.  Note that this queue may grow as its\n+     being processed, as the new functions may generate new ones.  */\n+  while (cgraph_expand_queue)\n+    {\n+      struct cgraph_node *n = cgraph_expand_queue;\n+      cgraph_expand_queue = cgraph_expand_queue->next_needed;\n+      n->next_needed = NULL;\n+      cgraph_finalize_function (n->decl, false);\n+      output = true;\n+    }\n+\n   return output;\n }\n+\n+\n /* As an GCC extension we allow redefinition of the function.  The\n    semantics when both copies of bodies differ is not well defined.\n    We replace the old body with new body so in unit at a time mode\n@@ -418,20 +432,6 @@ cgraph_lower_function (struct cgraph_node *node)\n   node->lowered = true;\n }\n \n-static void\n-cgraph_finalize_pending_functions (void)\n-{\n-  struct cgraph_node *next, *node = cgraph_analyze_queue;\n-\n-  cgraph_analyze_queue = NULL;\n-  for (; node ; node = next)\n-    {\n-      next = node->next_needed;\n-      node->next_needed = NULL;\n-      cgraph_finalize_function (node->decl, true);\n-    }\n-}\n-\n /* DECL has been parsed.  Take it, queue it, compile it at the whim of the\n    logic in effect.  If NESTED is true, then our caller cannot stand to have\n    the garbage collector run at the moment.  We would need to either create\n@@ -458,7 +458,6 @@ cgraph_finalize_function (tree decl, bool nested)\n   if (!flag_unit_at_a_time)\n     {\n       cgraph_analyze_function (node);\n-      cgraph_finalize_pending_functions ();\n       cgraph_decide_inlining_incrementally (node, false);\n     }\n \n@@ -982,7 +981,6 @@ cgraph_finalize_compilation_unit (void)\n       gcc_assert (DECL_SAVED_TREE (decl));\n \n       cgraph_analyze_function (node);\n-      cgraph_finalize_pending_functions ();\n \n       for (edge = node->callees; edge; edge = edge->next_callee)\n \tif (!edge->callee->reachable)\n@@ -1166,7 +1164,21 @@ cgraph_expand_all_functions (void)\n \t  cgraph_expand_function (node);\n \t}\n     }\n+\n   free (order);\n+\n+  /* Process CGRAPH_EXPAND_QUEUE, these are functions created during\n+     the expansion process.  Note that this queue may grow as its\n+     being processed, as the new functions may generate new ones.  */\n+  while (cgraph_expand_queue)\n+    {\n+      node = cgraph_expand_queue;\n+      cgraph_expand_queue = cgraph_expand_queue->next_needed;\n+      node->next_needed = NULL;\n+      node->output = 0;\n+      node->lowered = DECL_STRUCT_FUNCTION (node->decl)->cfg != NULL;\n+      cgraph_expand_function (node);\n+    }\n }\n \n /* This is used to sort the node types by the cgraph order number.  */"}, {"sha": "8b2581bbc85dacabedadcdc5b3e25e8b04a072f5", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -151,6 +151,32 @@ lower_stmt_body (tree expr, struct lower_data *data)\n     lower_stmt (&tsi, data);\n }\n \n+\n+/* Lower the OpenMP directive statement pointed by TSI.  DATA is\n+   passed through the recursion.  */\n+\n+static void\n+lower_omp_directive (tree_stmt_iterator *tsi, struct lower_data *data)\n+{\n+  tree clause, stmt;\n+  \n+  stmt = tsi_stmt (*tsi);\n+\n+  clause = (TREE_CODE (stmt) >= OMP_PARALLEL && TREE_CODE (stmt) <= OMP_SINGLE)\n+\t   ? OMP_CLAUSES (stmt)\n+\t   : NULL_TREE;\n+\n+  for (; clause; clause = OMP_CLAUSE_CHAIN (clause))\n+    TREE_BLOCK (clause) = TREE_BLOCK (stmt);\n+\n+  lower_stmt_body (OMP_BODY (stmt), data);\n+  tsi_link_before (tsi, stmt, TSI_SAME_STMT);\n+  tsi_link_before (tsi, OMP_BODY (stmt), TSI_SAME_STMT);\n+  OMP_BODY (stmt) = NULL_TREE;\n+  tsi_delink (tsi);\n+}\n+\n+\n /* Lowers statement TSI.  DATA is passed through the recursion.  */\n \n static void\n@@ -192,8 +218,20 @@ lower_stmt (tree_stmt_iterator *tsi, struct lower_data *data)\n     case GOTO_EXPR:\n     case LABEL_EXPR:\n     case SWITCH_EXPR:\n+    case OMP_RETURN_EXPR:\n       break;\n \n+    case OMP_PARALLEL:\n+    case OMP_FOR:\n+    case OMP_SECTIONS:\n+    case OMP_SECTION:\n+    case OMP_SINGLE:\n+    case OMP_MASTER:\n+    case OMP_ORDERED:\n+    case OMP_CRITICAL:\n+      lower_omp_directive (tsi, data);\n+      return;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -503,11 +541,16 @@ lower_return_expr (tree_stmt_iterator *tsi, struct lower_data *data)\n }\n \f\n \n-/* Record the variables in VARS.  */\n+/* Record the variables in VARS into function FN.  */\n \n void\n-record_vars (tree vars)\n+record_vars_into (tree vars, tree fn)\n {\n+  struct function *saved_cfun = cfun;\n+\n+  if (fn != current_function_decl)\n+    cfun = DECL_STRUCT_FUNCTION (fn);\n+\n   for (; vars; vars = TREE_CHAIN (vars))\n     {\n       tree var = vars;\n@@ -516,6 +559,7 @@ record_vars (tree vars)\n          we don't need to care about.  */\n       if (TREE_CODE (var) != VAR_DECL)\n \tcontinue;\n+\n       /* Nothing to do in this case.  */\n       if (DECL_EXTERNAL (var))\n \tcontinue;\n@@ -524,6 +568,18 @@ record_vars (tree vars)\n       cfun->unexpanded_var_list = tree_cons (NULL_TREE, var,\n \t\t\t\t\t     cfun->unexpanded_var_list);\n     }\n+\n+  if (fn != current_function_decl)\n+    cfun = saved_cfun;\n+}\n+\n+\n+/* Record the variables in VARS into current_function_decl.  */\n+\n+void\n+record_vars (tree vars)\n+{\n+  record_vars_into (vars, current_function_decl);\n }\n \n "}, {"sha": "7d7b80f6104e1f53dc29765bbddcffd1c1c4cac2", "filename": "gcc/gimplify.c", "status": "modified", "additions": 19, "deletions": 94, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -92,16 +92,6 @@ struct gimplify_ctx\n   int conditions;\n   bool save_stack;\n   bool into_ssa;\n-\n-  /* When gimplifying combined omp parallel directives (omp parallel\n-     loop and omp parallel sections), any prefix code needed to setup\n-     the associated worksharing construct needs to be emitted in the\n-     pre-queue of its parent parallel, otherwise the lowering process\n-     will move that code to the child function.  Similarly, we need to\n-     move up to the gimplification context of the parent parallel\n-     directive so temporaries are declared in the right context.  */\n-  tree *combined_pre_p;\n-  struct gimplify_ctx *combined_ctxp;\n };\n \n static struct gimplify_ctx *gimplify_ctxp;\n@@ -634,6 +624,10 @@ internal_get_tmp_var (tree val, tree *pre_p, tree *post_p, bool is_formal)\n   return t;\n }\n \n+/* Returns a formal temporary variable initialized with VAL.  PRE_P\n+   points to a statement list where side-effects needed to compute VAL\n+   should be stored.  */\n+\n tree\n get_formal_tmp_var (tree val, tree *pre_p)\n {\n@@ -2297,7 +2291,7 @@ shortcut_cond_expr (tree expr)\n \n /* EXPR is used in a boolean context; make sure it has BOOLEAN_TYPE.  */\n \n-static tree\n+tree\n gimple_boolify (tree expr)\n {\n   tree type = TREE_TYPE (expr);\n@@ -4131,29 +4125,6 @@ gimplify_to_stmt_list (tree *stmt_p)\n     }\n }\n \n-/* Gimplify *EXPR_P as if it had been used inside the gimplification\n-   context CTX_P.  The other arguments are as in gimplify_expr.  */\n-\n-static enum gimplify_status\n-gimplify_expr_in_ctx (tree *expr_p, tree *pre_p, tree *post_p, \n-\t\t      bool (* gimple_test_f) (tree), fallback_t fallback,\n-\t\t      struct gimplify_ctx *ctx_p,\n-\t\t      struct gimplify_omp_ctx *omp_ctx_p)\n-{\n-  enum gimplify_status ret;\n-  struct gimplify_ctx *prev_ctxp;\n-  struct gimplify_omp_ctx *prev_omp_ctxp;\n-  \n-  prev_ctxp = gimplify_ctxp;\n-  gimplify_ctxp = ctx_p;\n-  prev_omp_ctxp = gimplify_omp_ctxp;\n-  gimplify_omp_ctxp = omp_ctx_p;\n-  ret = gimplify_expr (expr_p, pre_p, post_p, gimple_test_f, fallback);\n-  gimplify_ctxp = prev_ctxp;\n-  gimplify_omp_ctxp = prev_omp_ctxp;\n-\n-  return ret;\n-}\n \n /* Add FIRSTPRIVATE entries for DECL in the OpenMP the surrounding parallels\n    to CTX.  If entries already exist, force them to be some flavor of private.\n@@ -4531,19 +4502,6 @@ gimplify_scan_omp_clauses (tree *list_p, tree *pre_p, bool in_parallel)\n \t  break;\n \n \tcase OMP_CLAUSE_SCHEDULE:\n-\t  if (gimplify_ctxp->combined_pre_p)\n-\t    {\n-\t      gcc_assert (gimplify_omp_ctxp == outer_ctx);\n-\t      gs = gimplify_expr_in_ctx (&OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c),\n-\t\t\t\t\t gimplify_ctxp->combined_pre_p, NULL,\n-\t\t\t\t\t is_gimple_val, fb_rvalue,\n-\t\t\t\t\t gimplify_ctxp->combined_ctxp,\n-\t\t\t\t\t outer_ctx->outer_context);\n-\t      if (gs == GS_ERROR)\n-\t\tremove = true;\n-\t      break;\n-\t    }\n-\t  /* FALLTHRU */\n \tcase OMP_CLAUSE_IF:\n \tcase OMP_CLAUSE_NUM_THREADS:\n \t  gs = gimplify_expr (&TREE_OPERAND (c, 0), pre_p, NULL,\n@@ -4708,17 +4666,12 @@ gimplify_omp_parallel (tree *expr_p, tree *pre_p)\n \n   push_gimplify_context ();\n \n-  if (determine_parallel_type (expr) == IS_COMBINED_PARALLEL)\n-    {\n-      gimplify_ctxp->combined_pre_p = pre_p;\n-      gimplify_ctxp->combined_ctxp = gimplify_ctxp->prev_context;\n-    }\n-\n   gimplify_stmt (&OMP_PARALLEL_BODY (expr));\n-  pop_gimplify_context (OMP_PARALLEL_BODY (expr));\n \n-  gimplify_ctxp->combined_pre_p = NULL;\n-  gimplify_ctxp->combined_ctxp = NULL;\n+  if (TREE_CODE (OMP_PARALLEL_BODY (expr)) == BIND_EXPR)\n+    pop_gimplify_context (OMP_PARALLEL_BODY (expr));\n+  else\n+    pop_gimplify_context (NULL_TREE);\n \n   gimplify_adjust_omp_clauses (&OMP_PARALLEL_CLAUSES (expr));\n \n@@ -4732,13 +4685,9 @@ gimplify_omp_for (tree *expr_p, tree *pre_p)\n {\n   tree for_stmt, decl, t;\n   enum gimplify_status ret = 0;\n-  struct gimplify_omp_ctx *outer_combined_omp_ctxp = NULL;\n \n   for_stmt = *expr_p;\n \n-  if (gimplify_ctxp->combined_pre_p)\n-    outer_combined_omp_ctxp = gimplify_omp_ctxp->outer_context;\n-\n   gimplify_scan_omp_clauses (&OMP_FOR_CLAUSES (for_stmt), pre_p, false);\n \n   t = OMP_FOR_INIT (for_stmt);\n@@ -4754,33 +4703,15 @@ gimplify_omp_for (tree *expr_p, tree *pre_p)\n   else\n     omp_add_variable (gimplify_omp_ctxp, decl, GOVD_PRIVATE | GOVD_SEEN);\n \n-  /* Gimplify inside our parent's context if this is part of a combined\n-     parallel+workshare directive.  */\n-  if (gimplify_ctxp->combined_pre_p)\n-    ret |= gimplify_expr_in_ctx (&TREE_OPERAND (t, 1),\n-\t\t\t\t gimplify_ctxp->combined_pre_p, NULL,\n-\t\t\t\t is_gimple_val, fb_rvalue,\n-\t\t\t\t gimplify_ctxp->combined_ctxp,\n-\t\t\t\t outer_combined_omp_ctxp);\n-  else\n-    ret |= gimplify_expr (&TREE_OPERAND (t, 1), &OMP_FOR_PRE_BODY (for_stmt),\n-\t\t\t  NULL, is_gimple_val, fb_rvalue);\n+  ret |= gimplify_expr (&TREE_OPERAND (t, 1), &OMP_FOR_PRE_BODY (for_stmt),\n+\t\t\tNULL, is_gimple_val, fb_rvalue);\n \n   t = OMP_FOR_COND (for_stmt);\n   gcc_assert (COMPARISON_CLASS_P (t));\n   gcc_assert (TREE_OPERAND (t, 0) == decl);\n \n-  /* Gimplify inside our parent's context if this is part of a combined\n-     parallel+workshare directive.  */\n-  if (gimplify_ctxp->combined_pre_p)\n-    ret |= gimplify_expr_in_ctx (&TREE_OPERAND (t, 1),\n-\t\t\t\t gimplify_ctxp->combined_pre_p, NULL,\n-\t\t\t\t is_gimple_val, fb_rvalue,\n-\t\t\t\t gimplify_ctxp->combined_ctxp,\n-\t\t\t\t outer_combined_omp_ctxp);\n-  else\n-    ret |= gimplify_expr (&TREE_OPERAND (t, 1), &OMP_FOR_PRE_BODY (for_stmt),\n-\t\t\t  NULL, is_gimple_val, fb_rvalue);\n+  ret |= gimplify_expr (&TREE_OPERAND (t, 1), &OMP_FOR_PRE_BODY (for_stmt),\n+\t\t\tNULL, is_gimple_val, fb_rvalue);\n \n   t = OMP_FOR_INCR (for_stmt);\n   switch (TREE_CODE (t))\n@@ -4818,18 +4749,8 @@ gimplify_omp_for (tree *expr_p, tree *pre_p)\n \t  gcc_unreachable ();\n \t}\n \n-      /* Gimplify inside our parent's context if this is part of a\n-\t combined parallel+workshare directive.  */\n-      if (gimplify_ctxp->combined_pre_p)\n-\tret |= gimplify_expr_in_ctx (&TREE_OPERAND (t, 1),\n-\t\t\t\t     gimplify_ctxp->combined_pre_p, NULL,\n-\t\t\t\t     is_gimple_val, fb_rvalue,\n-\t\t\t\t     gimplify_ctxp->combined_ctxp,\n-\t\t\t\t     outer_combined_omp_ctxp);\n-      else\n-\tret |= gimplify_expr (&TREE_OPERAND (t, 1),\n-\t\t\t      &OMP_FOR_PRE_BODY (for_stmt), NULL,\n-\t\t\t      is_gimple_val, fb_rvalue);\n+      ret |= gimplify_expr (&TREE_OPERAND (t, 1), &OMP_FOR_PRE_BODY (for_stmt),\n+\t\t\t    NULL, is_gimple_val, fb_rvalue);\n       break;\n \n     default:\n@@ -5622,6 +5543,10 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  ret = gimplify_omp_atomic (expr_p, pre_p);\n \t  break;\n \n+\tcase OMP_RETURN_EXPR:\n+\t  ret = GS_ALL_DONE;\n+\t  break;\n+\n \tdefault:\n \t  switch (TREE_CODE_CLASS (TREE_CODE (*expr_p)))\n \t    {"}, {"sha": "f5bdcb99791446e9a0d484c8113436a497785874", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1781, "deletions": 741, "changes": 2522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=50674e968a56527fa78d2fa78651276e696b64fd"}, {"sha": "8301590d98a7c1bdb0f5126fa96739c15474ccaa", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -481,6 +481,7 @@ init_optimization_passes (void)\n   p = &all_passes;\n   NEXT_PASS (pass_fixup_cfg);\n   NEXT_PASS (pass_init_datastructures);\n+  NEXT_PASS (pass_expand_omp);\n   NEXT_PASS (pass_all_optimizations);\n   NEXT_PASS (pass_warn_function_noreturn);\n   NEXT_PASS (pass_mudflap_2);"}, {"sha": "bc23ccb9e38c8e75216a215a5ff445f31d9b5f14", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -1,3 +1,20 @@\n+2006-01-19  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* testsuite/gcc.dg/gomp/for-13.c: Use -fdump-tree-ompexp.\n+\t* testsuite/gcc.dg/gomp/critical-1.c: Likewise.\n+\t* testsuite/gcc.dg/gomp/critical-3.c: Likewise.\n+\t* testsuite/gcc.dg/gomp/empty.c: Likewise.\n+\t* testsuite/gcc.dg/gomp/ordered-1.c: Likewise.\n+\t* testsuite/gcc.dg/gomp/for-4.c: Likewise.\n+\t* testsuite/gcc.dg/gomp/for-6.c: Likewise.\n+\t* testsuite/gcc.dg/gomp/master-3.c: Likewise.\n+\t* testsuite/gcc.dg/gomp/for-8.c: Likewise.\n+\t* testsuite/gcc.dg/gomp/for-10.c: Likewise.\n+\t* testsuite/gcc.dg/gomp/for-18.c: Likewise.\n+\t* testsuite/gcc.dg/gomp/for-5.c: Likewise.\n+\t* testsuite/gcc.dg/gomp/for-7.c: Likewise.\n+\t* testsuite/gcc.dg/gomp/for-9.c: Likewise.\n+\n 2006-01-18  Jeff Law  <law@redhat.com>\n \n \t* gcc.dg/tree-ssa/vrp25.c: New test."}, {"sha": "6f3348c8884f6cac029b1b8095bd98e66080810b", "filename": "gcc/testsuite/gcc.dg/gomp/critical-1.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcritical-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcritical-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcritical-1.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fopenmp -fdump-tree-omplower\" } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n \n extern void bar(int);\n \n@@ -21,8 +21,8 @@ void foo (void)\n     bar(3);\n }\n \n-/* { dg-final { scan-tree-dump-times \"GOMP_critical_start\" 2 \"omplower\" } } */\n-/* { dg-final { scan-tree-dump-times \"GOMP_critical_end\" 2 \"omplower\" } } */\n-/* { dg-final { scan-tree-dump-times \"GOMP_critical_name_start\" 2 \"omplower\" } } */\n-/* { dg-final { scan-tree-dump-times \"GOMP_critical_name_end\" 2 \"omplower\" } } */\n-/* { dg-final { cleanup-tree-dump \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_critical_start\" 2 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_critical_end\" 2 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_critical_name_start\" 2 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_critical_name_end\" 2 \"ompexp\" } } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "6726e6a03d45b37e35a17518ebf0dbae131c5d09", "filename": "gcc/testsuite/gcc.dg/gomp/critical-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcritical-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcritical-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fcritical-3.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -1,5 +1,5 @@\n // { dg-do compile }\n-// { dg-options \"-fopenmp -fdump-tree-omplower\" }\n+// { dg-options \"-fopenmp -fdump-tree-ompexp\" }\n \n void bar(void);\n void foo(void)\n@@ -8,4 +8,4 @@ void foo(void)\n     bar();\n }\n \n-// { dg-final { scan-tree-dump-times \"\\\\&\\\\.gomp_critical_user_xyzzy\" 2 \"omplower\" } }\n+// { dg-final { scan-tree-dump-times \"\\\\&\\\\.gomp_critical_user_xyzzy\" 2 \"ompexp\" } }"}, {"sha": "6a21c0460eca55d72e33eae8c1b720e16f01b07f", "filename": "gcc/testsuite/gcc.dg/gomp/empty.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fempty.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fempty.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fempty.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O -fopenmp -fdump-tree-omplower\" } */\n+/* { dg-options \"-O -fopenmp -fdump-tree-ompexp\" } */\n \n main()\n {\n@@ -8,5 +8,5 @@ main()\n }\n \n /* There should not be a GOMP_parallel_start call.  */\n-/* { dg-final { scan-tree-dump-times \"GOMP_parallel_start\" 0 \"omplower\"} } */\n-/* { dg-final { cleanup-tree-dump \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_parallel_start\" 0 \"ompexp\"} } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "f21404249c765f68020ad1864b1edfba13b77bc4", "filename": "gcc/testsuite/gcc.dg/gomp/for-10.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-10.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fopenmp -fdump-tree-lower\" } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n \n extern void bar(int);\n \n@@ -12,6 +12,6 @@ void foo (int n)\n     bar(i);\n }\n \n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_runtime_start\" 1 \"lower\" } } */\n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_runtime_next\" 1 \"lower\" } } */\n-/* { dg-final { cleanup-tree-dump \"lower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_runtime_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_runtime_next\" 1 \"ompexp\" } } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "607de49c7495a037fb85aa009693054f795c66f4", "filename": "gcc/testsuite/gcc.dg/gomp/for-13.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-13.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -2,7 +2,7 @@\n // for iteration variable as private.\n \n // { dg-do compile }\n-// { dg-options \"-fopenmp -fdump-tree-lower\" }\n+// { dg-options \"-fopenmp -fdump-tree-ompexp\" }\n \n extern void bar(int);\n void foo(void)\n@@ -14,5 +14,5 @@ void foo(void)\n     bar(i);\n }\n \n-// { dg-final { scan-tree-dump-times \"omp_data_o\" 0 \"lower\" } }\n-// { dg-final { cleanup-tree-dump \"lower\" } }\n+// { dg-final { scan-tree-dump-times \"omp_data_o\" 0 \"ompexp\" } }\n+// { dg-final { cleanup-tree-dump \"ompexp\" } }"}, {"sha": "545f271c80b79f761a52565f544fee3d7b9c2649", "filename": "gcc/testsuite/gcc.dg/gomp/for-18.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-18.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O -fopenmp -fdump-tree-omplower\" } */\n+/* { dg-options \"-O -fopenmp -fdump-tree-ompexp\" } */\n \n void\n foo (int *a, int i)\n@@ -37,6 +37,6 @@ bar (int *a, int i)\n     a[j] = 4;\n }\n \n-/* { dg-final { scan-tree-dump-times \"GOMP_parallel_loop_dynamic_start\" 4 \"omplower\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"GOMP_parallel_loop_guided_start\" 4 \"omplower\" { xfail *-*-* } } } */\n-/* { dg-final { cleanup-tree-dump \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_parallel_loop_dynamic_start\" 4 \"ompexp\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_parallel_loop_guided_start\" 4 \"ompexp\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "fb6994ea20b8a533f9129cf2fb04e71bfe6e7020", "filename": "gcc/testsuite/gcc.dg/gomp/for-4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-4.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fopenmp -fdump-tree-lower\" } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n \n extern void bar(int);\n \n@@ -12,6 +12,6 @@ void foo (int n)\n     bar(i);\n }\n \n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_dynamic_start\" 1 \"lower\" } } */\n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_dynamic_next\" 1 \"lower\" } } */\n-/* { dg-final { cleanup-tree-dump \"lower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_dynamic_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_dynamic_next\" 1 \"ompexp\" } } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "5912a4e5561ed5aade4116d5ff3377b058ccdf7b", "filename": "gcc/testsuite/gcc.dg/gomp/for-5.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-5.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fopenmp -fdump-tree-lower\" } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n \n extern void bar(int);\n \n@@ -12,6 +12,6 @@ void foo (int n)\n     bar(i);\n }\n \n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_guided_start\" 1 \"lower\" } } */\n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_guided_next\" 1 \"lower\" } } */\n-/* { dg-final { cleanup-tree-dump \"lower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_guided_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_guided_next\" 1 \"ompexp\" } } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "100ee2c8c2198b096fa15eb1554eb43d9c5603a9", "filename": "gcc/testsuite/gcc.dg/gomp/for-6.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-6.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fopenmp -fdump-tree-lower\" } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n \n extern void bar(int);\n \n@@ -12,6 +12,6 @@ void foo (int n)\n     bar(i);\n }\n \n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_runtime_start\" 1 \"lower\" } } */\n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_runtime_next\" 1 \"lower\" } } */\n-/* { dg-final { cleanup-tree-dump \"lower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_runtime_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_runtime_next\" 1 \"ompexp\" } } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "10763dc596c2755f5c3ca2fd7cbccecb09736cac", "filename": "gcc/testsuite/gcc.dg/gomp/for-7.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-7.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fopenmp -fdump-tree-lower\" } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n \n extern void bar(int);\n \n@@ -12,6 +12,6 @@ void foo (int n)\n     bar(i);\n }\n \n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_static_start\" 1 \"lower\" } } */\n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_static_next\" 1 \"lower\" } } */\n-/* { dg-final { cleanup-tree-dump \"lower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_static_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_static_next\" 1 \"ompexp\" } } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "1bc66c49a0d60b81277c8a0fc3d560bbf2a4e699", "filename": "gcc/testsuite/gcc.dg/gomp/for-8.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-8.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fopenmp -fdump-tree-lower\" } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n \n extern void bar(int);\n \n@@ -12,6 +12,6 @@ void foo (int n)\n     bar(i);\n }\n \n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_dynamic_start\" 1 \"lower\" } } */\n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_dynamic_next\" 1 \"lower\" } } */\n-/* { dg-final { cleanup-tree-dump \"lower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_dynamic_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_dynamic_next\" 1 \"ompexp\" } } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "af99e216e793a78cccb9bf38265206befd08cf59", "filename": "gcc/testsuite/gcc.dg/gomp/for-9.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-9.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fopenmp -fdump-tree-lower\" } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n \n extern void bar(int);\n \n@@ -12,6 +12,6 @@ void foo (int n)\n     bar(i);\n }\n \n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_guided_start\" 1 \"lower\" } } */\n-/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_guided_next\" 1 \"lower\" } } */\n-/* { dg-final { cleanup-tree-dump \"lower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_guided_start\" 1 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_loop_ordered_guided_next\" 1 \"ompexp\" } } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "fee09ddd798c8f357c4497a5473c1a6cf4986302", "filename": "gcc/testsuite/gcc.dg/gomp/master-3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fmaster-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fmaster-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fmaster-3.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fopenmp -fdump-tree-omplower\" } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n \n extern void bar(int);\n \n@@ -9,5 +9,5 @@ void foo (void)\n     bar(0);\n }\n \n-/* { dg-final { scan-tree-dump-times \"omp_get_thread_num\" 1 \"omplower\" } } */\n-/* { dg-final { cleanup-tree-dump \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"omp_get_thread_num\" 1 \"ompexp\" } } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "de5e116ebd21e4022f7a5699937c17f226836b36", "filename": "gcc/testsuite/gcc.dg/gomp/ordered-1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fordered-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fordered-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fordered-1.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-fopenmp -fdump-tree-omplower\" } */\n+/* { dg-options \"-fopenmp -fdump-tree-ompexp\" } */\n \n extern void bar(int);\n \n@@ -15,6 +15,6 @@ void foo (void)\n   }\n }\n \n-/* { dg-final { scan-tree-dump-times \"GOMP_ordered_start\" 2 \"omplower\" } } */\n-/* { dg-final { scan-tree-dump-times \"GOMP_ordered_end\" 2 \"omplower\" } } */\n-/* { dg-final { cleanup-tree-dump \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_ordered_start\" 2 \"ompexp\" } } */\n+/* { dg-final { scan-tree-dump-times \"GOMP_ordered_end\" 2 \"ompexp\" } } */\n+/* { dg-final { cleanup-tree-dump \"ompexp\" } } */"}, {"sha": "f76f663ef695dca9841a1b495b8bcf7feb0172b2", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 393, "deletions": 6, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -486,6 +486,37 @@ make_edges (void)\n }\n \n \n+/* Link an OMP_SECTIONS block to all the OMP_SECTION blocks in its body.  */\n+\n+static void\n+make_omp_sections_edges (basic_block bb)\n+{\n+  basic_block exit_bb;\n+  size_t i, n;\n+  tree vec, stmt;\n+\n+  stmt = last_stmt (bb);\n+  vec = OMP_SECTIONS_SECTIONS (stmt);\n+  n = TREE_VEC_LENGTH (vec);\n+  exit_bb = bb_for_stmt (TREE_VEC_ELT (vec, n - 1));\n+\n+  for (i = 0; i < n - 1; i += 2)\n+    {\n+      basic_block start_bb = bb_for_stmt (TREE_VEC_ELT (vec, i));\n+      basic_block end_bb = bb_for_stmt (TREE_VEC_ELT (vec, i + 1));\n+      make_edge (bb, start_bb, EDGE_ABNORMAL);\n+      make_edge (end_bb, exit_bb, EDGE_FALLTHRU);\n+    }\n+\n+  /* Once the CFG has been built, the vector of sections is no longer\n+     useful.  The region can be easily obtained with build_omp_regions.\n+     Furthermore, this sharing of tree expressions is not allowed by the\n+     statement verifier.  */\n+  OMP_SECTIONS_SECTIONS (stmt) = NULL_TREE;\n+}\n+\n+\n+\n /* Create edges for control statement at basic block BB.  */\n \n static void\n@@ -581,6 +612,27 @@ make_exit_edges (basic_block bb)\n       make_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n       break;\n \n+    case OMP_PARALLEL:\n+    case OMP_FOR:\n+    case OMP_SINGLE:\n+    case OMP_MASTER:\n+    case OMP_ORDERED:\n+    case OMP_CRITICAL:\n+      make_edge (bb, bb->next_bb, EDGE_ABNORMAL);\n+\n+    case OMP_RETURN_EXPR:\n+      if (EDGE_COUNT (bb->succs) == 0)\n+\tmake_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n+      break;\n+\n+    case OMP_SECTIONS:\n+      make_omp_sections_edges (bb);\n+      break;\n+\n+    case OMP_SECTION:\n+      make_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -2503,6 +2555,10 @@ is_ctrl_altering_stmt (tree t)\n \treturn true;\n     }\n \n+  /* OpenMP directives alter control flow.  */\n+  if (flag_openmp && OMP_DIRECTIVE_P (t))\n+    return true;\n+\n   /* If a statement can throw, it alters control flow.  */\n   return tree_can_throw_internal (t);\n }\n@@ -2746,12 +2802,9 @@ set_bb_for_stmt (tree t, basic_block bb)\n       stmt_ann_t ann = get_stmt_ann (t);\n       ann->bb = bb;\n \n-      /* If the statement is a label, add the label to block-to-labels\n-\t map so that we can speed up edge creation for GOTO_EXPRs.\n-\t Note that LABEL_TO_BLOCK_MAP may not exist if we are\n-\t currently expanding into RTL (in which case, this mapping is\n-\t unnecessary, anyway).  */\n-      if (TREE_CODE (t) == LABEL_EXPR && !currently_expanding_to_rtl)\n+      /* If the statement is a label, add the label to block-to-labels map\n+        so that we can speed up edge creation for GOTO_EXPRs.  */\n+      if (TREE_CODE (t) == LABEL_EXPR)\n \t{\n \t  int uid;\n \n@@ -3432,6 +3485,17 @@ verify_stmt (tree stmt, bool last_in_block)\n {\n   tree addr;\n \n+  if (OMP_DIRECTIVE_P (stmt))\n+    {\n+      /* OpenMP directives are validated by the FE and never operated\n+\t on by the optimizers.  Furthermore, OMP_FOR may contain\n+\t non-gimple expressions when the main index variable has had\n+\t its address taken.  This does not affect the loop itself\n+\t because the header of an OMP_FOR is merely used to determine\n+\t how to setup the parallel iteration.  */\n+      return false;\n+    }\n+\n   if (!is_gimple_stmt (stmt))\n     {\n       error (\"is not a valid GIMPLE statement\");\n@@ -4494,6 +4558,329 @@ tree_duplicate_sese_region (edge entry, edge exit,\n   return true;\n }\n \n+/*\n+DEF_VEC_P(basic_block);\n+DEF_VEC_ALLOC_P(basic_block,heap);\n+*/\n+\n+/* Add all the blocks dominated by ENTRY to the array BBS_P.  Stop\n+   adding blocks when the dominator traversal reaches EXIT.  This\n+   function silently assumes that ENTRY strictly dominates EXIT.  */\n+\n+static void\n+gather_blocks_in_sese_region (basic_block entry, basic_block exit,\n+\t\t\t      VEC(basic_block,heap) **bbs_p)\n+{\n+  basic_block son;\n+\n+  for (son = first_dom_son (CDI_DOMINATORS, entry);\n+       son;\n+       son = next_dom_son (CDI_DOMINATORS, son))\n+    {\n+      VEC_safe_push (basic_block, heap, *bbs_p, son);\n+      if (son != exit)\n+\tgather_blocks_in_sese_region (son, exit, bbs_p);\n+    }\n+}\n+\n+\n+struct move_stmt_d\n+{\n+  tree block;\n+  tree from_context;\n+  tree to_context;\n+  bitmap vars_to_remove;\n+  bool remap_decls_p;\n+};\n+\n+/* Helper for move_block_to_fn.  Set TREE_BLOCK in every expression\n+   contained in *TP and change the DECL_CONTEXT of every local\n+   variable referenced in *TP.  */\n+\n+static tree\n+move_stmt_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED, void *data)\n+{\n+  struct move_stmt_d *p = (struct move_stmt_d *) data;\n+\n+  if (p->block && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (*tp))))\n+    TREE_BLOCK (*tp) = p->block;\n+\n+  if (OMP_DIRECTIVE_P (*tp))\n+    {\n+      /* Do not remap variables inside OMP directives.  Variables\n+\t referenced in clauses and directive header belong to the\n+\t parent function and should not be moved into the child\n+\t function.  */\n+      p->remap_decls_p = false;\n+    }\n+\n+  if (p->remap_decls_p\n+      && DECL_P (*tp)\n+      && DECL_CONTEXT (*tp) == p->from_context)\n+    {\n+      DECL_CONTEXT (*tp) = p->to_context;\n+\n+      if (TREE_CODE (*tp) == VAR_DECL)\n+\t{\n+\t  struct function *f = DECL_STRUCT_FUNCTION (p->to_context);\n+\t  f->unexpanded_var_list = tree_cons (0, *tp, f->unexpanded_var_list);\n+\n+\t  /* Mark *TP to be removed from the original function,\n+\t     otherwise it will be given a DECL_RTL when the original\n+\t     function is expanded.  */\n+\t  bitmap_set_bit (p->vars_to_remove, DECL_UID (*tp));\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* Move basic block BB from function CFUN to function DEST_FN.  The\n+   block is moved out of the original linked list and placed after\n+   block AFTER in the new list.  Also, the block is removed from the\n+   original array of blocks and placed in DEST_FN's array of blocks.\n+   If UPDATE_EDGE_COUNT_P is true, the edge counts on both CFGs is\n+   updated to reflect the moved edges.\n+   \n+   On exit, local variables that need to be removed from\n+   CFUN->UNEXPANDED_VAR_LIST will have been added to VARS_TO_REMOVE.  */\n+\n+static void\n+move_block_to_fn (struct function *dest_cfun, basic_block bb,\n+\t\t  basic_block after, bool update_edge_count_p,\n+\t\t  bitmap vars_to_remove)\n+{\n+  struct control_flow_graph *cfg;\n+  edge_iterator ei;\n+  edge e;\n+  block_stmt_iterator si;\n+  struct move_stmt_d d;\n+  unsigned sz;\n+\n+  /* Link BB to the new linked list.  */\n+  move_block_after (bb, after);\n+\n+  /* Update the edge count in the corresponding flowgraphs.  */\n+  if (update_edge_count_p)\n+    FOR_EACH_EDGE (e, ei, bb->succs)\n+      {\n+\tcfun->cfg->x_n_edges--;\n+\tdest_cfun->cfg->x_n_edges++;\n+      }\n+\n+  /* Remove BB from the original basic block array.  */\n+  VEC_replace (basic_block, cfun->cfg->x_basic_block_info, bb->index, NULL);\n+  cfun->cfg->x_n_basic_blocks--;\n+\n+  /* Grow DEST_CFUN's basic block array if needed.  */\n+  cfg = dest_cfun->cfg;\n+  cfg->x_n_basic_blocks++;\n+  if (bb->index > cfg->x_last_basic_block)\n+    cfg->x_last_basic_block = bb->index;\n+\n+  sz = VEC_length (basic_block, cfg->x_basic_block_info);\n+  if ((unsigned) cfg->x_last_basic_block >= sz)\n+    {\n+      sz = cfg->x_last_basic_block + (cfg->x_last_basic_block + 3) / 4;\n+      VEC_safe_grow (basic_block, gc, cfg->x_basic_block_info, sz);\n+    }\n+\n+  VEC_replace (basic_block, cfg->x_basic_block_info,\n+               cfg->x_last_basic_block, bb);\n+\n+  /* The statements in BB need to be associated with a new TREE_BLOCK.\n+     Labels need to be associated with a new label-to-block map.  */\n+  memset (&d, 0, sizeof (d));\n+  d.vars_to_remove = vars_to_remove;\n+\n+  for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+    {\n+      tree stmt = bsi_stmt (si);\n+\n+      d.from_context = cfun->decl;\n+      d.to_context = dest_cfun->decl;\n+      d.remap_decls_p = true;\n+      if (TREE_BLOCK (stmt))\n+\td.block = DECL_INITIAL (dest_cfun->decl);\n+\n+      walk_tree (&stmt, move_stmt_r, &d, NULL);\n+\n+      if (TREE_CODE (stmt) == LABEL_EXPR)\n+\t{\n+\t  unsigned old_len;\n+\t  tree label = LABEL_EXPR_LABEL (stmt);\n+\t  int uid = LABEL_DECL_UID (label);\n+\n+\t  gcc_assert (uid > -1);\n+\n+\t  old_len = VEC_length (basic_block, cfg->x_label_to_block_map);\n+\t  if (old_len <= (unsigned) uid)\n+\t    {\n+\t      basic_block *addr;\n+\t      unsigned new_len = 3 * uid / 2;\n+\t      VEC_safe_grow (basic_block, gc, cfg->x_label_to_block_map,\n+\t\t\t     new_len);\n+\t      addr = VEC_address (basic_block, cfg->x_label_to_block_map);\n+\t      memset (&addr[old_len], 0,\n+\t\t      sizeof (basic_block) * (new_len - old_len));\n+\t    }\n+\n+\t  VEC_replace (basic_block, cfg->x_label_to_block_map, uid, bb);\n+\t  VEC_replace (basic_block, cfun->cfg->x_label_to_block_map, uid, NULL);\n+\n+\t  gcc_assert (DECL_CONTEXT (label) == dest_cfun->decl);\n+\n+\t  if (uid >= dest_cfun->last_label_uid)\n+\t    dest_cfun->last_label_uid = uid + 1;\n+\t}\n+    }\n+}\n+\n+\n+/* Move a single-entry, single-exit region delimited by ENTRY_BB and\n+   EXIT_BB to function DEST_CFUN.  The whole region is replaced by a\n+   single basic block in the original CFG and the new basic block is\n+   returned.  DEST_CFUN must not have a CFG yet.\n+\n+   Note that the region need not be a pure SESE region.  Blocks inside\n+   the region may contain calls to abort/exit.  The only restriction\n+   is that ENTRY_BB should be the only entry point and it must\n+   dominate EXIT_BB.\n+\n+   All local variables referenced in the region are assumed to be in\n+   the corresponding BLOCK_VARS and unexpanded variable lists\n+   associated with DEST_CFUN.  */\n+\n+basic_block\n+move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n+\t\t        basic_block exit_bb)\n+{\n+  VEC(basic_block,heap) *bbs;\n+  basic_block after, bb, *entry_pred, *exit_succ;\n+  struct function *saved_cfun;\n+  int *entry_flag, *exit_flag;\n+  unsigned i, num_entry_edges, num_exit_edges;\n+  edge e;\n+  edge_iterator ei;\n+  bitmap vars_to_remove;\n+\n+  saved_cfun = cfun;\n+\n+  /* Collect all the blocks in the region.  Manually add ENTRY_BB\n+     because it won't be added by dfs_enumerate_from.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  /* If ENTRY does not strictly dominate EXIT, this cannot be an SESE\n+     region.  */\n+  gcc_assert (entry_bb != exit_bb\n+              && dominated_by_p (CDI_DOMINATORS, exit_bb, entry_bb));\n+\n+  bbs = NULL;\n+  VEC_safe_push (basic_block, heap, bbs, entry_bb);\n+  gather_blocks_in_sese_region (entry_bb, exit_bb, &bbs);\n+\n+  /* Detach ENTRY_BB and EXIT_BB from CFUN->CFG.  We need to remember\n+     the predecessor edges to ENTRY_BB and the successor edges to\n+     EXIT_BB so that we can re-attach them to the new basic block that\n+     will replace the region.  */\n+  num_entry_edges = EDGE_COUNT (entry_bb->preds);\n+  entry_pred = (basic_block *) xcalloc (num_entry_edges, sizeof (basic_block));\n+  entry_flag = (int *) xcalloc (num_entry_edges, sizeof (int));\n+  i = 0;\n+  for (ei = ei_start (entry_bb->preds); (e = ei_safe_edge (ei)) != NULL;)\n+    {\n+      entry_flag[i] = e->flags;\n+      entry_pred[i++] = e->src;\n+      remove_edge (e);\n+    }\n+\n+  num_exit_edges = EDGE_COUNT (exit_bb->succs);\n+  exit_succ = (basic_block *) xcalloc (num_exit_edges, sizeof (basic_block));\n+  exit_flag = (int *) xcalloc (num_exit_edges, sizeof (int));\n+  i = 0;\n+  for (ei = ei_start (exit_bb->succs); (e = ei_safe_edge (ei)) != NULL;)\n+    {\n+      exit_flag[i] = e->flags;\n+      exit_succ[i++] = e->dest;\n+      remove_edge (e);\n+    }\n+\n+  /* Switch context to the child function to initialize DEST_FN's CFG.  */\n+  gcc_assert (dest_cfun->cfg == NULL);\n+  cfun = dest_cfun;\n+  init_empty_tree_cfg ();\n+  cfun = saved_cfun;\n+\n+  /* Move blocks from BBS into DEST_CFUN.  */\n+  gcc_assert (VEC_length (basic_block, bbs) >= 2);\n+  after = dest_cfun->cfg->x_entry_block_ptr;\n+  vars_to_remove = BITMAP_ALLOC (NULL);\n+  for (i = 0; VEC_iterate (basic_block, bbs, i, bb); i++)\n+    {\n+      /* No need to update edge counts on the last block.  It has\n+\t already been updated earlier when we detached the region from\n+\t the original CFG.  */\n+      move_block_to_fn (dest_cfun, bb, after, bb != exit_bb, vars_to_remove);\n+      after = bb;\n+    }\n+\n+  /* Remove the variables marked in VARS_TO_REMOVE from\n+     CFUN->UNEXPANDED_VAR_LIST.  Otherwise, they will be given a\n+     DECL_RTL in the context of CFUN.  */\n+  if (!bitmap_empty_p (vars_to_remove))\n+    {\n+      tree *p;\n+\n+      for (p = &cfun->unexpanded_var_list; *p; )\n+\t{\n+\t  tree var = TREE_VALUE (*p);\n+\t  if (bitmap_bit_p (vars_to_remove, DECL_UID (var)))\n+\t    {\n+\t      *p = TREE_CHAIN (*p);\n+\t      continue;\n+\t    }\n+\n+\t  p = &TREE_CHAIN (*p);\n+\t}\n+    }\n+\n+  BITMAP_FREE (vars_to_remove);\n+\n+  /* Rewire the entry and exit blocks.  The successor to the entry\n+     block turns into the successor of DEST_FN's ENTRY_BLOCK_PTR in\n+     the child function.  Similarly, the predecessor of DEST_FN's\n+     EXIT_BLOCK_PTR turns into the predecessor of EXIT_BLOCK_PTR.  We\n+     need to switch CFUN between DEST_CFUN and SAVED_CFUN so that the\n+     various CFG manipulation function get to the right CFG.\n+\n+     FIXME, this is silly.  The CFG ought to become a parameter to\n+     these helpers.  */\n+  cfun = dest_cfun;\n+  make_edge (ENTRY_BLOCK_PTR, entry_bb, EDGE_FALLTHRU);\n+  make_edge (exit_bb,  EXIT_BLOCK_PTR, 0);\n+  cfun = saved_cfun;\n+\n+  /* Back in the original function, the SESE region has disappeared,\n+     create a new basic block in its place.  */\n+  bb = create_empty_bb (entry_pred[0]);\n+  for (i = 0; i < num_entry_edges; i++)\n+    make_edge (entry_pred[i], bb, entry_flag[i]);\n+\n+  for (i = 0; i < num_exit_edges; i++)\n+    make_edge (bb, exit_succ[i], exit_flag[i]);\n+\n+  free (exit_flag);\n+  free (entry_flag);\n+  free (entry_pred);\n+  free (exit_succ);\n+  free_dominance_info (CDI_DOMINATORS);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+  VEC_free (basic_block, heap, bbs);\n+\n+  return bb;\n+}\n+\n \n /* Dump FUNCTION_DECL FN to file FILE using FLAGS (see TDF_* in tree.h)  */\n "}, {"sha": "0c5e96b669b0a9a943437b66bb0ae4fb3ab61b6f", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -540,6 +540,8 @@ extern void fold_cond_expr_cond (void);\n extern void replace_uses_by (tree, tree);\n extern void start_recording_case_labels (void);\n extern void end_recording_case_labels (void);\n+extern basic_block move_sese_region_to_fn (struct function *, basic_block,\n+\t\t\t\t           basic_block);\n \n /* In tree-cfgcleanup.c  */\n extern bool cleanup_tree_cfg (void);\n@@ -580,8 +582,9 @@ extern void remove_phi_node (tree, tree);\n extern tree phi_reverse (tree);\n \n /* In gimple-low.c  */\n+extern void record_vars_into (tree, tree);\n extern void record_vars (tree);\n-extern bool block_may_fallthru (tree block);\n+extern bool block_may_fallthru (tree);\n \n /* In tree-ssa-alias.c  */\n extern void dump_may_aliases_for (FILE *, tree);\n@@ -886,6 +889,7 @@ tree create_mem_ref (block_stmt_iterator *, tree,\n rtx addr_for_mem_ref (struct mem_address *, bool);\n void get_address_description (tree, struct mem_address *);\n tree maybe_fold_tmr (tree);\n+\n /* This structure is simply used during pushing fields onto the fieldstack\n    to track the offset of the field, since bitpos_of_field gives it relative\n    to its immediate containing type, and we want it relative to the ultimate"}, {"sha": "b47b0012c68afd8cd40fd8dc5e29157ba7351c1f", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -224,6 +224,7 @@ is_gimple_stmt (tree t)\n     case OMP_MASTER:\n     case OMP_ORDERED:\n     case OMP_CRITICAL:\n+    case OMP_RETURN_EXPR:\n       /* These are always void.  */\n       return true;\n "}, {"sha": "9cba07f55975559190d96078ee200c83de0278d6", "filename": "gcc/tree-gimple.h", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.h?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -109,21 +109,6 @@ enum gimplify_status {\n   GS_ALL_DONE\t= 1\t/* The expression is fully gimplified.  */\n };\n \n-/* Type of parallel constructs.  Used to decide what runtime function\n-   to use for launching children threads and the gimplification\n-   strategy.  */\n-\n-enum omp_parallel_type {\n-    IS_NOT_PARALLEL = 0,\n-\n-    /* Regular omp parallel  */\n-    IS_PARALLEL,\n-\n-    /* Combined parallel + workshare (parallel loop and parallel\n-       sections).  */\n-    IS_COMBINED_PARALLEL\n-};\n-\n extern enum gimplify_status gimplify_expr (tree *, tree *, tree *,\n \t\t\t\t\t   bool (*) (tree), fallback_t);\n extern void gimplify_type_sizes (tree, tree *);\n@@ -147,12 +132,11 @@ extern tree force_labels_r (tree *, int *, void *);\n extern enum gimplify_status gimplify_va_arg_expr (tree *, tree *, tree *);\n struct gimplify_omp_ctx;\n extern void omp_firstprivatize_variable (struct gimplify_omp_ctx *, tree);\n+extern tree gimple_boolify (tree);\n \n /* In omp-low.c.  */\n-extern tree find_omp_clause (tree, enum tree_code);\n extern void diagnose_omp_structured_block_errors (tree);\n extern tree omp_reduction_init (tree, tree);\n-enum omp_parallel_type determine_parallel_type (tree stmt);\n \n /* In tree-nested.c.  */\n extern void lower_nested_functions (tree);"}, {"sha": "c75cc9b7bd2e6d5461c9b2418fba9ebe9aa8ea90", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -1598,6 +1598,29 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case LOOP_EXPR:\n     case PHI_NODE:\n     case WITH_SIZE_EXPR:\n+    case OMP_PARALLEL:\n+    case OMP_FOR:\n+    case OMP_SECTIONS:\n+    case OMP_SINGLE:\n+    case OMP_SECTION:\n+    case OMP_MASTER:\n+    case OMP_ORDERED:\n+    case OMP_CRITICAL:\n+    case OMP_ATOMIC:\n+    case OMP_CLAUSE_PRIVATE:\n+    case OMP_CLAUSE_SHARED:\n+    case OMP_CLAUSE_FIRSTPRIVATE:\n+    case OMP_CLAUSE_LASTPRIVATE:\n+    case OMP_CLAUSE_REDUCTION:\n+    case OMP_CLAUSE_COPYIN:\n+    case OMP_CLAUSE_COPYPRIVATE:\n+    case OMP_CLAUSE_IF:\n+    case OMP_CLAUSE_NUM_THREADS:\n+    case OMP_CLAUSE_SCHEDULE:\n+    case OMP_CLAUSE_NOWAIT:\n+    case OMP_CLAUSE_ORDERED:\n+    case OMP_CLAUSE_DEFAULT:\n+    case OMP_RETURN_EXPR:\n       break;\n \n     /* We don't account constants for now.  Assume that the cost is amortized\n@@ -2285,7 +2308,22 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \n       /* Now, restore the chain, if appropriate.  That will cause\n \t walk_tree to walk into the chain as well.  */\n-      if (code == PARM_DECL || code == TREE_LIST)\n+      if (code == PARM_DECL\n+\t  || code == TREE_LIST\n+\t  /* OpenMP clauses are linked through TREE_CHAIN.  */\n+\t  || code == OMP_CLAUSE_PRIVATE\n+\t  || code == OMP_CLAUSE_SHARED\n+\t  || code == OMP_CLAUSE_FIRSTPRIVATE\n+\t  || code == OMP_CLAUSE_LASTPRIVATE\n+\t  || code == OMP_CLAUSE_REDUCTION\n+\t  || code == OMP_CLAUSE_COPYIN\n+\t  || code == OMP_CLAUSE_COPYPRIVATE\n+\t  || code == OMP_CLAUSE_IF\n+\t  || code == OMP_CLAUSE_NUM_THREADS\n+\t  || code == OMP_CLAUSE_SCHEDULE\n+\t  || code == OMP_CLAUSE_NOWAIT\n+\t  || code == OMP_CLAUSE_ORDERED\n+\t  || code == OMP_CLAUSE_DEFAULT)\n \tTREE_CHAIN (*tp) = chain;\n \n       /* For now, we don't update BLOCKs when we make copies.  So, we"}, {"sha": "ad2b47ea8cd4d8c8a7999a75a7b7b244b3ab3d9f", "filename": "gcc/tree-iterator.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-iterator.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -40,6 +40,7 @@ alloc_stmt_list (void)\n   if (list)\n     {\n       stmt_list_cache = TREE_CHAIN (list);\n+      gcc_assert (stmt_list_cache != list);\n       memset (list, 0, sizeof(struct tree_common));\n       TREE_SET_CODE (list, STATEMENT_LIST);\n     }\n@@ -54,6 +55,9 @@ free_stmt_list (tree t)\n {\n   gcc_assert (!STATEMENT_LIST_HEAD (t));\n   gcc_assert (!STATEMENT_LIST_TAIL (t));\n+  /* If this triggers, it's a sign that the same list is being freed\n+     twice.  */\n+  gcc_assert (t != stmt_list_cache || stmt_list_cache == NULL);\n   TREE_CHAIN (t) = stmt_list_cache;\n   stmt_list_cache = t;\n }"}, {"sha": "82e8c107765a2f5420505baa2a8036d9cd696e0a", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -263,6 +263,7 @@ extern struct tree_opt_pass pass_lower_complex;\n extern struct tree_opt_pass pass_lower_vector;\n extern struct tree_opt_pass pass_lower_vector_ssa;\n extern struct tree_opt_pass pass_lower_omp;\n+extern struct tree_opt_pass pass_expand_omp;\n extern struct tree_opt_pass pass_object_sizes;\n extern struct tree_opt_pass pass_fold_builtins;\n extern struct tree_opt_pass pass_stdarg;"}, {"sha": "b23416df306cc20f6cf0454db2fa334a1dce2061", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -1702,6 +1702,21 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n     case OMP_PARALLEL:\n       pp_string (buffer, \"#pragma omp parallel\");\n       dump_omp_clauses (buffer, OMP_PARALLEL_CLAUSES (node), spc, flags);\n+      if (OMP_PARALLEL_FN (node))\n+\t{\n+\t  pp_string (buffer, \" [child fn: \");\n+\t  dump_generic_node (buffer, OMP_PARALLEL_FN (node), spc, flags, false);\n+\n+\t  pp_string (buffer, \" (\");\n+\n+\t  if (OMP_PARALLEL_DATA_ARG (node))\n+\t    dump_generic_node (buffer, OMP_PARALLEL_DATA_ARG (node), spc, flags,\n+\t\t               false);\n+\t  else\n+\t    pp_string (buffer, \"???\");\n+\n+\t  pp_string (buffer, \")]\");\n+\t}\n \n     dump_omp_body:\n       if (!(flags & TDF_SLIM) && OMP_BODY (node))\n@@ -1803,6 +1818,11 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       dump_omp_clauses (buffer, OMP_SINGLE_CLAUSES (node), spc, flags);\n       goto dump_omp_body;\n \n+    case OMP_RETURN_EXPR:\n+      pp_string (buffer, \"OMP_RETURN\");\n+      is_expr = false;\n+      break;\n+\n     case REDUC_MAX_EXPR:\n       pp_string (buffer, \" REDUC_MAX_EXPR < \");\n       dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);"}, {"sha": "fbee0b915e1b28ca3fe2c3bfb94e710d397f0f9a", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -1288,6 +1288,14 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n     case FILTER_EXPR:\n     case LABEL_DECL:\n     case CONST_DECL:\n+    case OMP_PARALLEL:\n+    case OMP_SECTIONS:\n+    case OMP_FOR:\n+    case OMP_RETURN_EXPR:\n+    case OMP_SINGLE:\n+    case OMP_MASTER:\n+    case OMP_ORDERED:\n+    case OMP_CRITICAL:\n       /* Expressions that make no memory references.  */\n       return;\n "}, {"sha": "f99b2474f7fd31ecbe23aa758b3d55bd6917dbb2", "filename": "gcc/tree.def", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -65,7 +65,6 @@ DEFTREECODE (TREE_VEC, \"tree_vec\", tcc_exceptional, 0)\n      For a block which represents the outermost scope of a function, it\n      points to the FUNCTION_DECL node.\n    BLOCK_VARS points to a chain of decl nodes.\n-   BLOCK_TYPE_TAGS points to a chain of types which have their own names.\n    BLOCK_CHAIN points to the next BLOCK at the same level.\n    BLOCK_ABSTRACT_ORIGIN points to the original (abstract) tree node which\n    this block is an instance of, or else is NULL to indicate that this\n@@ -957,8 +956,15 @@ DEFTREECODE (TARGET_MEM_REF, \"target_mem_ref\", tcc_reference, 7)\n    exposed to TREE_RANGE_CHECK.  */\n /* OpenMP - #pragma omp parallel [clause1 ... clauseN]\n    Operand 0: OMP_PARALLEL_BODY: Code to be executed by all threads.\n-   Operand 1: OMP_PARALLEL_CLAUSES: List of clauses.  */\n-DEFTREECODE (OMP_PARALLEL, \"omp_parallel\", tcc_statement, 2)\n+   Operand 1: OMP_PARALLEL_CLAUSES: List of clauses.\n+   Operand 2: OMP_PARALLEL_FN: FUNCTION_DECL used when outlining the\n+\t      body of the parallel region.  Only valid after\n+\t      pass_lower_omp.\n+   Operand 3: OMP_PARALLEL_DATA_ARG: Local variable in the parent\n+\t      function containing data to be shared with the child\n+\t      function.  */\n+\n+DEFTREECODE (OMP_PARALLEL, \"omp_parallel\", tcc_statement, 4)\n \n /* OpenMP - #pragma omp for [clause1 ... clauseN]\n    Operand 0: OMP_FOR_BODY: Loop body.\n@@ -983,8 +989,11 @@ DEFTREECODE (OMP_FOR, \"omp_for\", tcc_statement, 6)\n \n /* OpenMP - #pragma omp sections [clause1 ... clauseN]\n    Operand 0: OMP_SECTIONS_BODY: Sections body.\n-   Operand 1: OMP_SECTIONS_CLAUSES: List of clauses.  */\n-DEFTREECODE (OMP_SECTIONS, \"omp_sections\", tcc_statement, 2)\n+   Operand 1: OMP_SECTIONS_CLAUSES: List of clauses.\n+   Operand 2: OMP_SECTIONS_SECTIONS: Vector of the different sections\n+\t      in the body.  Only valid after lowering and destroyed\n+\t      after the CFG has been built.  */\n+DEFTREECODE (OMP_SECTIONS, \"omp_sections\", tcc_statement, 3)\n \n /* OpenMP - #pragma omp single\n    Operand 0: OMP_SINGLE_BODY: Single section body.\n@@ -1063,6 +1072,9 @@ DEFTREECODE (OMP_CLAUSE_ORDERED, \"ordered\", tcc_expression, 0)\n /* OpenMP clause: default.  */\n DEFTREECODE (OMP_CLAUSE_DEFAULT, \"default\", tcc_expression, 0)\n \n+/* Return from an OpenMP directive.  */\n+DEFTREECODE (OMP_RETURN_EXPR, \"omp_return\", tcc_statement, 0)\n+\n /* Reduction operations. \n    Operations that take a vector of elements and \"reduce\" it to a scalar\n    result (e.g. summing the elements of the vector, finding the minimum over"}, {"sha": "99463aed57030510dd1a286272c81f46b0efc7cf", "filename": "gcc/tree.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50674e968a56527fa78d2fa78651276e696b64fd/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=50674e968a56527fa78d2fa78651276e696b64fd", "patch": "@@ -166,6 +166,19 @@ extern const enum tree_code_class tree_code_type[];\n \n #define EXPR_P(NODE) IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (NODE)))\n \n+/* Returns nonzero iff NODE is an OpenMP directive.  */\n+\n+#define OMP_DIRECTIVE_P(NODE)\t\t\t\t\\\n+    (TREE_CODE (NODE) == OMP_PARALLEL\t\t\t\\\n+     || TREE_CODE (NODE) == OMP_SECTIONS\t\t\\\n+     || TREE_CODE (NODE) == OMP_SECTION\t\t\t\\\n+     || TREE_CODE (NODE) == OMP_FOR\t\t\t\\\n+     || TREE_CODE (NODE) == OMP_RETURN_EXPR\t\t\\\n+     || TREE_CODE (NODE) == OMP_SINGLE\t\t\t\\\n+     || TREE_CODE (NODE) == OMP_MASTER\t\t\t\\\n+     || TREE_CODE (NODE) == OMP_ORDERED\t\t\t\\\n+     || TREE_CODE (NODE) == OMP_CRITICAL)\n+\n /* Number of argument-words in each kind of tree-node.  */\n \n extern const unsigned char tree_code_length[];\n@@ -1424,6 +1437,8 @@ struct tree_constructor GTY(())\n \n #define OMP_PARALLEL_BODY(NODE)    TREE_OPERAND (OMP_PARALLEL_CHECK (NODE), 0)\n #define OMP_PARALLEL_CLAUSES(NODE) TREE_OPERAND (OMP_PARALLEL_CHECK (NODE), 1)\n+#define OMP_PARALLEL_FN(NODE) TREE_OPERAND (OMP_PARALLEL_CHECK (NODE), 2)\n+#define OMP_PARALLEL_DATA_ARG(NODE) TREE_OPERAND (OMP_PARALLEL_CHECK (NODE), 3)\n \n #define OMP_FOR_BODY(NODE)\t   TREE_OPERAND (OMP_FOR_CHECK (NODE), 0)\n #define OMP_FOR_CLAUSES(NODE)\t   TREE_OPERAND (OMP_FOR_CHECK (NODE), 1)\n@@ -1434,6 +1449,7 @@ struct tree_constructor GTY(())\n \n #define OMP_SECTIONS_BODY(NODE)    TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 0)\n #define OMP_SECTIONS_CLAUSES(NODE) TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 1)\n+#define OMP_SECTIONS_SECTIONS(NODE) TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 2)\n \n #define OMP_SECTION_BODY(NODE)\t   TREE_OPERAND (OMP_SECTION_CHECK (NODE), 0)\n "}]}