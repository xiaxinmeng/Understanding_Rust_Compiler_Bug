{"sha": "e5069d626e754ca7dd2d269dbb57d83e3a0eca38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTUwNjlkNjI2ZTc1NGNhN2RkMmQyNjlkYmI1N2Q4M2UzYTBlY2EzOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-03-20T16:27:05Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-03-20T16:27:05Z"}, "message": "i386.c (vselect_insn): New variable.\n\n\t* config/i386/i386.c (vselect_insn): New variable.\n\t(init_vselect_insn): New function.\n\t(expand_vselect, expand_vselect_insn): Add testing_p argument.\n\tCall init_vselect_insn if vselect_insn is NULL.  Adjust\n\tPATTERN (vselect_insn), instead of creating a new insn each time,\n\tonly emit a copy of it if not testing and recog has been successful.\n\t(expand_vec_perm_pshufb, expand_vec_perm_1,\n\texpand_vec_perm_pshuflw_pshufhw, expand_vec_perm_broadcast_1): Adjust\n\tcallers.\n\nFrom-SVN: r185578", "tree": {"sha": "bc8243ddf7ed3298ce8108696fe0570a6af4ed42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc8243ddf7ed3298ce8108696fe0570a6af4ed42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5069d626e754ca7dd2d269dbb57d83e3a0eca38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5069d626e754ca7dd2d269dbb57d83e3a0eca38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5069d626e754ca7dd2d269dbb57d83e3a0eca38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5069d626e754ca7dd2d269dbb57d83e3a0eca38/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6945a32ec3fb20b5bba0d98a419da26c1c6b62d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6945a32ec3fb20b5bba0d98a419da26c1c6b62d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6945a32ec3fb20b5bba0d98a419da26c1c6b62d4"}], "stats": {"total": 112, "additions": 86, "deletions": 26}, "files": [{"sha": "f54b3206a2d1754977bcd4233a6de870637951a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5069d626e754ca7dd2d269dbb57d83e3a0eca38/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5069d626e754ca7dd2d269dbb57d83e3a0eca38/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5069d626e754ca7dd2d269dbb57d83e3a0eca38", "patch": "@@ -1,5 +1,15 @@\n 2012-03-20  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* config/i386/i386.c (vselect_insn): New variable.\n+\t(init_vselect_insn): New function.\n+\t(expand_vselect, expand_vselect_insn): Add testing_p argument.\n+\tCall init_vselect_insn if vselect_insn is NULL.  Adjust\n+\tPATTERN (vselect_insn), instead of creating a new insn each time,\n+\tonly emit a copy of it if not testing and recog has been successful.\n+\t(expand_vec_perm_pshufb, expand_vec_perm_1,\n+\texpand_vec_perm_pshuflw_pshufhw, expand_vec_perm_broadcast_1): Adjust\n+\tcallers.\n+\n \tPR target/52607\n \t* config/i386/i386.md (\"isa\" attribute): Add avx2 and noavx2.\n \t(\"enabled\" attribute): Handle avx2 and noavx2 isas."}, {"sha": "99c9d3dde4b940a08cd6c98a5a583cf7c0577eaa", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 76, "deletions": 26, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5069d626e754ca7dd2d269dbb57d83e3a0eca38/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5069d626e754ca7dd2d269dbb57d83e3a0eca38/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e5069d626e754ca7dd2d269dbb57d83e3a0eca38", "patch": "@@ -35535,43 +35535,88 @@ ix86_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n     }\n }\n \n+/* A cached (set (nil) (vselect (vconcat (nil) (nil)) (parallel [])))\n+   insn, so that expand_vselect{,_vconcat} doesn't have to create a fresh\n+   insn every time.  */\n+\n+static GTY(()) rtx vselect_insn;\n+\n+/* Initialize vselect_insn.  */\n+\n+static void\n+init_vselect_insn (void)\n+{\n+  unsigned i;\n+  rtx x;\n+\n+  x = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (MAX_VECT_LEN));\n+  for (i = 0; i < MAX_VECT_LEN; ++i)\n+    XVECEXP (x, 0, i) = const0_rtx;\n+  x = gen_rtx_VEC_SELECT (V2DFmode, gen_rtx_VEC_CONCAT (V4DFmode, const0_rtx,\n+\t\t\t\t\t\t\tconst0_rtx), x);\n+  x = gen_rtx_SET (VOIDmode, const0_rtx, x);\n+  start_sequence ();\n+  vselect_insn = emit_insn (x);\n+  end_sequence ();\n+}\n+\n /* Construct (set target (vec_select op0 (parallel perm))) and\n    return true if that's a valid instruction in the active ISA.  */\n \n static bool\n-expand_vselect (rtx target, rtx op0, const unsigned char *perm, unsigned nelt)\n+expand_vselect (rtx target, rtx op0, const unsigned char *perm,\n+\t\tunsigned nelt, bool testing_p)\n {\n-  rtx rperm[MAX_VECT_LEN], x;\n-  unsigned i;\n+  unsigned int i;\n+  rtx x, save_vconcat;\n+  int icode;\n+\n+  if (vselect_insn == NULL_RTX)\n+    init_vselect_insn ();\n \n+  x = XEXP (SET_SRC (PATTERN (vselect_insn)), 1);\n+  PUT_NUM_ELEM (XVEC (x, 0), nelt);\n   for (i = 0; i < nelt; ++i)\n-    rperm[i] = GEN_INT (perm[i]);\n+    XVECEXP (x, 0, i) = GEN_INT (perm[i]);\n+  save_vconcat = XEXP (SET_SRC (PATTERN (vselect_insn)), 0);\n+  XEXP (SET_SRC (PATTERN (vselect_insn)), 0) = op0;\n+  PUT_MODE (SET_SRC (PATTERN (vselect_insn)), GET_MODE (target));\n+  SET_DEST (PATTERN (vselect_insn)) = target;\n+  icode = recog_memoized (vselect_insn);\n \n-  x = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (nelt, rperm));\n-  x = gen_rtx_VEC_SELECT (GET_MODE (target), op0, x);\n-  x = gen_rtx_SET (VOIDmode, target, x);\n+  if (icode >= 0 && !testing_p)\n+    emit_insn (copy_rtx (PATTERN (vselect_insn)));\n \n-  x = emit_insn (x);\n-  if (recog_memoized (x) < 0)\n-    {\n-      remove_insn (x);\n-      return false;\n-    }\n-  return true;\n+  SET_DEST (PATTERN (vselect_insn)) = const0_rtx;\n+  XEXP (SET_SRC (PATTERN (vselect_insn)), 0) = save_vconcat;\n+  INSN_CODE (vselect_insn) = -1;\n+\n+  return icode >= 0;\n }\n \n /* Similar, but generate a vec_concat from op0 and op1 as well.  */\n \n static bool\n expand_vselect_vconcat (rtx target, rtx op0, rtx op1,\n-\t\t\tconst unsigned char *perm, unsigned nelt)\n+\t\t\tconst unsigned char *perm, unsigned nelt,\n+\t\t\tbool testing_p)\n {\n   enum machine_mode v2mode;\n   rtx x;\n+  bool ok;\n+\n+  if (vselect_insn == NULL_RTX)\n+    init_vselect_insn ();\n \n   v2mode = GET_MODE_2XWIDER_MODE (GET_MODE (op0));\n-  x = gen_rtx_VEC_CONCAT (v2mode, op0, op1);\n-  return expand_vselect (target, x, perm, nelt);\n+  x = XEXP (SET_SRC (PATTERN (vselect_insn)), 0);\n+  PUT_MODE (x, v2mode);\n+  XEXP (x, 0) = op0;\n+  XEXP (x, 1) = op1;\n+  ok = expand_vselect (target, x, perm, nelt, testing_p);\n+  XEXP (x, 0) = const0_rtx;\n+  XEXP (x, 1) = const0_rtx;\n+  return ok;\n }\n \n /* A subroutine of ix86_expand_vec_perm_builtin_1.  Try to implement D\n@@ -35903,7 +35948,7 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n \t\t    return true;\n \t\t  return expand_vselect (gen_lowpart (V4DImode, d->target),\n \t\t\t\t\t gen_lowpart (V4DImode, d->op0),\n-\t\t\t\t\t perm, 4);\n+\t\t\t\t\t perm, 4, false);\n \t\t}\n \n \t      /* Next see if vpermd can be used.  */\n@@ -36051,7 +36096,7 @@ expand_vec_perm_1 (struct expand_vec_perm_d *d)\n \t    }\n \t}\n \n-      if (expand_vselect (d->target, d->op0, perm2, nelt))\n+      if (expand_vselect (d->target, d->op0, perm2, nelt, d->testing_p))\n \treturn true;\n \n       /* There are plenty of patterns in sse.md that are written for\n@@ -36065,7 +36110,8 @@ expand_vec_perm_1 (struct expand_vec_perm_d *d)\n \t  perm2[i] = d->perm[i] & mask;\n \t  perm2[i + 1] = (d->perm[i + 1] & mask) + nelt;\n \t}\n-      if (expand_vselect_vconcat (d->target, d->op0, d->op0, perm2, nelt))\n+      if (expand_vselect_vconcat (d->target, d->op0, d->op0, perm2, nelt,\n+\t\t\t\t  d->testing_p))\n \treturn true;\n \n       /* Recognize shufps, which means adding {0, 0, nelt, nelt}.  */\n@@ -36079,13 +36125,15 @@ expand_vec_perm_1 (struct expand_vec_perm_d *d)\n \t      perm2[i + 3] = (d->perm[i + 3] & mask) + nelt;\n \t    }\n \n-\t  if (expand_vselect_vconcat (d->target, d->op0, d->op0, perm2, nelt))\n+\t  if (expand_vselect_vconcat (d->target, d->op0, d->op0, perm2, nelt,\n+\t\t\t\t      d->testing_p))\n \t    return true;\n \t}\n     }\n \n   /* Finally, try the fully general two operand permute.  */\n-  if (expand_vselect_vconcat (d->target, d->op0, d->op1, d->perm, nelt))\n+  if (expand_vselect_vconcat (d->target, d->op0, d->op1, d->perm, nelt,\n+\t\t\t      d->testing_p))\n     return true;\n \n   /* Recognize interleave style patterns with reversed operands.  */\n@@ -36101,7 +36149,8 @@ expand_vec_perm_1 (struct expand_vec_perm_d *d)\n \t  perm2[i] = e;\n \t}\n \n-      if (expand_vselect_vconcat (d->target, d->op1, d->op0, perm2, nelt))\n+      if (expand_vselect_vconcat (d->target, d->op1, d->op0, perm2, nelt,\n+\t\t\t\t  d->testing_p))\n \treturn true;\n     }\n \n@@ -36149,14 +36198,14 @@ expand_vec_perm_pshuflw_pshufhw (struct expand_vec_perm_d *d)\n   memcpy (perm2, d->perm, 4);\n   for (i = 4; i < 8; ++i)\n     perm2[i] = i;\n-  ok = expand_vselect (d->target, d->op0, perm2, 8);\n+  ok = expand_vselect (d->target, d->op0, perm2, 8, d->testing_p);\n   gcc_assert (ok);\n \n   /* Emit the pshufhw.  */\n   memcpy (perm2 + 4, d->perm + 4, 4);\n   for (i = 0; i < 4; ++i)\n     perm2[i] = i;\n-  ok = expand_vselect (d->target, d->target, perm2, 8);\n+  ok = expand_vselect (d->target, d->target, perm2, 8, d->testing_p);\n   gcc_assert (ok);\n \n   return true;\n@@ -37190,7 +37239,8 @@ expand_vec_perm_broadcast_1 (struct expand_vec_perm_d *d)\n       while (vmode != V4SImode);\n \n       memset (perm2, elt, 4);\n-      ok = expand_vselect (gen_lowpart (V4SImode, d->target), op0, perm2, 4);\n+      ok = expand_vselect (gen_lowpart (V4SImode, d->target), op0, perm2, 4,\n+\t\t\t   d->testing_p);\n       gcc_assert (ok);\n       return true;\n "}]}