{"sha": "cb4d476cf4ea3b6889efa676d23f64efb81ecb1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I0ZDQ3NmNmNGVhM2I2ODg5ZWZhNjc2ZDIzZjY0ZWZiODFlY2IxZQ==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2003-10-29T21:44:16Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2003-10-29T21:44:16Z"}, "message": "pa-linux.h (ASM_OUTPUT_ADDR_VEC_ELT): Use label in big switch ELTs.\n\n\t* pa-linux.h (ASM_OUTPUT_ADDR_VEC_ELT): Use label in big switch ELTs.\n\t(ASM_OUTPUT_ADDR_DIFF_ELT): Use label difference in big switch ELTs.\n\t* pa.c (pa_adjust_insn_length): Check for btable branches using\n\tattribute TYPE_BTABLE_BRANCH.\n\t(pa_reorg): Simplify.\n\t* pa.h (CASE_VECTOR_MODE): Change big switch mode to SImode.\n\t(ASM_OUTPUT_ADDR_VEC_ELT): As above.\n\t(ASM_OUTPUT_ADDR_DIFF_ELT): As above.\n\t* pa.md (btable_branch): New instruction type.\n\t(in_branch_delay, in_nullified_branch_delay, in_call_delay): Disallow\n\tbtable branches.\n\t(define_delay): Add btable branches to insn types that may have an\n\tinsn in the delay position.\n\t(Z2, Z3): Add btable branch to list.\n\tSimplify unamed pattern set copy pic_label_operand to register.  Add\n\tPA 2.0 variant.\n\t(short_jump): New jump for use in branch tables.\n\t(casesi, casesi0): Revise for new branch table formats.\n\t(casesi32, casesi32p, casesi64p): New casesi patterns.\n\t(indirect_jump): Move.\n\nFrom-SVN: r73064", "tree": {"sha": "3f9b013a36f8c65c1295068d6f7270904d4bc863", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f9b013a36f8c65c1295068d6f7270904d4bc863"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb4d476cf4ea3b6889efa676d23f64efb81ecb1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb4d476cf4ea3b6889efa676d23f64efb81ecb1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb4d476cf4ea3b6889efa676d23f64efb81ecb1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb4d476cf4ea3b6889efa676d23f64efb81ecb1e/comments", "author": null, "committer": null, "parents": [{"sha": "c1aa3958b1832d2c728c6fc192ab78c3ea737c3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1aa3958b1832d2c728c6fc192ab78c3ea737c3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1aa3958b1832d2c728c6fc192ab78c3ea737c3b"}], "stats": {"total": 164, "additions": 81, "deletions": 83}, "files": [{"sha": "628b5037c8689a88f1effde6d928292d8dcda9f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4d476cf4ea3b6889efa676d23f64efb81ecb1e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4d476cf4ea3b6889efa676d23f64efb81ecb1e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb4d476cf4ea3b6889efa676d23f64efb81ecb1e", "patch": "@@ -1,3 +1,26 @@\n+2003-10-29  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* pa-linux.h (ASM_OUTPUT_ADDR_VEC_ELT): Use label in big switch ELTs.\n+\t(ASM_OUTPUT_ADDR_DIFF_ELT): Use label difference in big switch ELTs.\n+\t* pa.c (pa_adjust_insn_length): Check for btable branches using\n+\tattribute TYPE_BTABLE_BRANCH.\n+\t(pa_reorg): Simplify.\n+\t* pa.h (CASE_VECTOR_MODE): Change big switch mode to SImode.\n+\t(ASM_OUTPUT_ADDR_VEC_ELT): As above.\n+\t(ASM_OUTPUT_ADDR_DIFF_ELT): As above.\n+\t* pa.md (btable_branch): New instruction type.\n+\t(in_branch_delay, in_nullified_branch_delay, in_call_delay): Disallow\n+\tbtable branches.\n+\t(define_delay): Add btable branches to insn types that may have an\n+\tinsn in the delay position.\n+\t(Z2, Z3): Add btable branch to list.\n+\tSimplify unamed pattern set copy pic_label_operand to register.  Add\n+\tPA 2.0 variant.\n+\t(short_jump): New jump for use in branch tables.\n+\t(casesi, casesi0): Revise for new branch table formats.\n+\t(casesi32, casesi32p, casesi64p): New casesi patterns.\n+\t(indirect_jump): Move.\n+\n 2003-10-29  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/rs6000.h (UNITS_PER_WORD): Revert to"}, {"sha": "2a714e3ebdffd274c0eb2beb9d660229c1fcae68", "filename": "gcc/config/pa/pa-linux.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4d476cf4ea3b6889efa676d23f64efb81ecb1e/gcc%2Fconfig%2Fpa%2Fpa-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4d476cf4ea3b6889efa676d23f64efb81ecb1e/gcc%2Fconfig%2Fpa%2Fpa-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-linux.h?ref=cb4d476cf4ea3b6889efa676d23f64efb81ecb1e", "patch": "@@ -121,14 +121,14 @@ Boston, MA 02111-1307, USA.  */\n #undef ASM_OUTPUT_ADDR_VEC_ELT\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n   if (TARGET_BIG_SWITCH)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tstw %%r1,-16(%%r30)\\n\\tldil LR'.L%d,%%r1\\n\\tbe RR'.L%d(%%sr4,%%r1)\\n\\tldw -16(%%r30),%%r1\\n\", VALUE, VALUE);\t\t\\\n+    fprintf (FILE, \"\\t.word .L%d\\n\", VALUE);\t\t\t\\\n   else\t\t\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\tb .L%d\\n\\tnop\\n\", VALUE)\n \n #undef ASM_OUTPUT_ADDR_DIFF_ELT\n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   if (TARGET_BIG_SWITCH)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tstw %%r1,-16(%%r30)\\n\\tldw T'.L%d(%%r19),%%r1\\n\\tbv %%r0(%%r1)\\n\\tldw -16(%%r30),%%r1\\n\", VALUE);\t\t\t\t\\\n+    fprintf (FILE, \"\\t.word .L%d-.L%d\\n\", VALUE, REL);\t\t\\\n   else\t\t\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\tb .L%d\\n\\tnop\\n\", VALUE)\n "}, {"sha": "5e6d28383490192a601c88c77de57537bd2c7baf", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 21, "deletions": 55, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4d476cf4ea3b6889efa676d23f64efb81ecb1e/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4d476cf4ea3b6889efa676d23f64efb81ecb1e/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=cb4d476cf4ea3b6889efa676d23f64efb81ecb1e", "patch": "@@ -4319,8 +4319,8 @@ pa_adjust_insn_length (rtx insn, int length)\n   /* Jumps inside switch tables which have unfilled delay slots need\n      adjustment.  */\n   if (GET_CODE (insn) == JUMP_INSN\n-\t   && simplejump_p (insn)\n-\t   && GET_MODE (insn) == SImode)\n+      && GET_CODE (pat) == PARALLEL\n+      && get_attr_type (insn) == TYPE_BTABLE_BRANCH)\n     return 4;\n   /* Millicode insn with an unfilled delay slot.  */\n   else if (GET_CODE (insn) == INSN\n@@ -7848,7 +7848,8 @@ following_call (rtx insn)\n    The jump instructions within the table are special; we must be able\n    to identify them during assembly output (if the jumps don't get filled\n    we need to emit a nop rather than nullifying the delay slot)).  We\n-   identify jumps in switch tables by marking the SET with DImode.\n+   identify jumps in switch tables by using insns with the attribute\n+   type TYPE_BTABLE_BRANCH.\n \n    We also surround the jump table itself with BEGIN_BRTAB and END_BRTAB\n    insns.  This serves two purposes, first it prevents jump.c from\n@@ -7874,7 +7875,7 @@ pa_reorg (void)\n       /* Find and explode all ADDR_VEC or ADDR_DIFF_VEC insns.  */\n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \t{\n-\t  rtx pattern, tmp, location;\n+\t  rtx pattern, tmp, location, label;\n \t  unsigned int length, i;\n \n \t  /* Find an ADDR_VEC or ADDR_DIFF_VEC insn to explode.  */\n@@ -7900,57 +7901,17 @@ pa_reorg (void)\n \t      location = NEXT_INSN (location);\n \n \t      if (GET_CODE (pattern) == ADDR_VEC)\n-\t\t{\n-\t\t  /* Emit the jump itself.  */\n-\t\t  tmp = gen_jump (XEXP (XVECEXP (pattern, 0, i), 0));\n-\t\t  tmp = emit_jump_insn_after (tmp, location);\n-\t\t  JUMP_LABEL (tmp) = XEXP (XVECEXP (pattern, 0, i), 0);\n-\t\t  /* It is easy to rely on the branch table markers\n-\t\t     during assembly output to trigger the correct code\n-\t\t     for a switch table jump with an unfilled delay slot,\n-\n-\t\t     However, that requires state and assumes that we look\n-\t\t     at insns in order.\n-\n-\t\t     We can't make such assumptions when computing the length\n-\t\t     of instructions.  Ugh.  We could walk the insn chain to\n-\t\t     determine if this instruction is in a branch table, but\n-\t\t     that can get rather expensive, particularly during the\n-\t\t     branch shortening phase of the compiler.\n-\n-\t\t     So instead we mark this jump as being special.  This is\n-\t\t     far from ideal and knows that no code after this will\n-\t\t     muck around with the mode of the JUMP_INSN itself.  */\n-\t\t  PUT_MODE (tmp, SImode);\n-\t\t  LABEL_NUSES (JUMP_LABEL (tmp))++;\n-\t\t  location = NEXT_INSN (location);\n-\t\t}\n+\t\tlabel = XEXP (XVECEXP (pattern, 0, i), 0);\n \t      else\n-\t\t{\n-\t\t  /* Emit the jump itself.  */\n-\t\t  tmp = gen_jump (XEXP (XVECEXP (pattern, 1, i), 0));\n-\t\t  tmp = emit_jump_insn_after (tmp, location);\n-\t\t  JUMP_LABEL (tmp) = XEXP (XVECEXP (pattern, 1, i), 0);\n-\t\t  /* It is easy to rely on the branch table markers\n-\t\t     during assembly output to trigger the correct code\n-\t\t     for a switch table jump with an unfilled delay slot,\n-\n-\t\t     However, that requires state and assumes that we look\n-\t\t     at insns in order.\n-\n-\t\t     We can't make such assumptions when computing the length\n-\t\t     of instructions.  Ugh.  We could walk the insn chain to\n-\t\t     determine if this instruction is in a branch table, but\n-\t\t     that can get rather expensive, particularly during the\n-\t\t     branch shortening phase of the compiler.\n-\n-\t\t     So instead we mark this jump as being special.  This is\n-\t\t     far from ideal and knows that no code after this will\n-\t\t     muck around with the mode of the JUMP_INSN itself.  */\n-\t\t  PUT_MODE (tmp, SImode);\n-\t\t  LABEL_NUSES (JUMP_LABEL (tmp))++;\n-\t\t  location = NEXT_INSN (location);\n-\t\t}\n+\t\tlabel = XEXP (XVECEXP (pattern, 1, i), 0);\n+\n+\t      tmp = gen_short_jump (label);\n+\n+\t      /* Emit the jump itself.  */\n+\t      tmp = emit_jump_insn_after (tmp, location);\n+\t      JUMP_LABEL (tmp) = label;\n+\t      LABEL_NUSES (label)++;\n+\t      location = NEXT_INSN (location);\n \n \t      /* Emit a BARRIER after the jump.  */\n \t      emit_barrier_after (location);\n@@ -7968,7 +7929,12 @@ pa_reorg (void)\n     }\n   else\n     {\n-      /* Sill need an end_brtab insn.  */\n+      /* Still need brtab marker insns.  FIXME: the presence of these\n+\t markers disables output of the branch table to readonly memory,\n+\t and any alignment directives that might be needed.  Possibly,\n+\t the begin_brtab insn should be output before the label for the\n+\t table.  This doesn matter at the moment since the tables are\n+\t always output in the text section.  */\n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \t{\n \t  /* Find an ADDR_VEC insn.  */"}, {"sha": "37d36538f5f6a32c3835af120de5e5d90aa1db07", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb4d476cf4ea3b6889efa676d23f64efb81ecb1e/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb4d476cf4ea3b6889efa676d23f64efb81ecb1e/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=cb4d476cf4ea3b6889efa676d23f64efb81ecb1e", "patch": "@@ -1550,11 +1550,14 @@ do { \t\t\t\t\t\t\t\t\t\\\n \n #define FUNCTION_NAME_P(NAME)  (*(NAME) == '@')\n \n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE (TARGET_BIG_SWITCH ? TImode : DImode)\n-\n-/* Jump tables must be 32 bit aligned, no matter the size of the element.  */\n+/* Specify the machine mode that this machine uses for the index in the\n+   tablejump instruction.  For small tables, an element consists of a\n+   ia-relative branch and its delay slot.  When -mbig-switch is specified,\n+   we use a 32-bit absolute address for non-pic code, and a 32-bit offset\n+   for both 32 and 64-bit pic code.  */\n+#define CASE_VECTOR_MODE (TARGET_BIG_SWITCH ? SImode : DImode)\n+\n+/* Jump tables must be 32-bit aligned, no matter the size of the element.  */\n #define ADDR_VEC_ALIGN(ADDR_VEC) 2\n \n /* Define this as 1 if `char' should by default be signed; else as 0.  */\n@@ -1724,35 +1727,41 @@ do { \t\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \\\n   output_ascii ((FILE), (P), (SIZE))\n \n-/* This is how to output an element of a case-vector that is absolute.\n-   Note that this method makes filling these branch delay slots\n-   impossible.  */\n+/* Jump tables are always placed in the text section.  Technically, it\n+   is possible to put them in the readonly data section when -mbig-switch\n+   is specified.  This has the benefit of getting the table out of .text\n+   and reducing branch lengths as a result.  The downside is that an\n+   additional insn (addil) is needed to access the table when generating\n+   PIC code.  The address difference table also has to use 32-bit\n+   pc-relative relocations.  Currently, GAS does not support these\n+   relocations, although it is easily modified to do this operation.\n+   The table entries need to look like \"$L1+(.+8-$L0)-$PIC_pcrel$0\"\n+   when using ELF GAS.  A simple difference can be used when using\n+   SOM GAS or the HP assembler.  The final downside is GDB complains\n+   about the nesting of the label for the table when debugging.  */\n \n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  if (TARGET_BIG_SWITCH)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tstw %%r1,-16(%%r30)\\n\\tldil LR'L$%04d,%%r1\\n\\tbe RR'L$%04d(%%sr4,%%r1)\\n\\tldw -16(%%r30),%%r1\\n\", VALUE, VALUE);\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tb L$%04d\\n\\tnop\\n\", VALUE)\n-\n-/* Jump tables are executable code and live in the TEXT section on the PA.  */\n #define JUMP_TABLES_IN_TEXT_SECTION 1\n \n-/* This is how to output an element of a case-vector that is relative.\n-   This must be defined correctly as it is used when generating PIC code.\n+/* This is how to output an element of a case-vector that is absolute.  */\n \n-   I believe it safe to use the same definition as ASM_OUTPUT_ADDR_VEC_ELT\n-   on the PA since ASM_OUTPUT_ADDR_VEC_ELT uses pc-relative jump instructions\n-   rather than a table of absolute addresses.  */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  if (TARGET_BIG_SWITCH)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.word L$%04d\\n\", VALUE);\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tb L$%04d\\n\\tnop\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative. \n+   Since we always place jump tables in the text section, the difference\n+   is absolute and requires no relocation.  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n-  if (TARGET_BIG_SWITCH)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tstw %%r1,-16(%%r30)\\n\\tldw T'L$%04d(%%r19),%%r1\\n\\tbv %%r0(%%r1)\\n\\tldw -16(%%r30),%%r1\\n\", VALUE);\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n+  if (TARGET_BIG_SWITCH)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.word L$%04d-L$%04d\\n\", VALUE, REL);\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\tb L$%04d\\n\\tnop\\n\", VALUE)\n \n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.  */\n+/* This is how to output an assembler line that says to advance the\n+   location counter to a multiple of 2**LOG bytes.  */\n \n #define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n     fprintf (FILE, \"\\t.align %d\\n\", (1<<(LOG)))"}]}