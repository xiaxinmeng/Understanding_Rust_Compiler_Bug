{"sha": "27e484bc572d80b8862f96bf0b9529e955afafac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdlNDg0YmM1NzJkODBiODg2MmY5NmJmMGI5NTI5ZTk1NWFmYWZhYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2003-03-26T07:48:15Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2003-03-26T07:48:15Z"}, "message": "re PR target/7784 ([Sparc] ICE in extract_insn, at recog.c:2148)\n\n\tPR target/7784\n\t* reload.c (find_reloads_address): Handle\n\t(PLUS (PLUS (REG) (REG)) (CONST_INT)) form for\n\tall base registers.\n\nFrom-SVN: r64887", "tree": {"sha": "8d96699feab644c4819e1ad2ab11cbb406364b27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d96699feab644c4819e1ad2ab11cbb406364b27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27e484bc572d80b8862f96bf0b9529e955afafac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27e484bc572d80b8862f96bf0b9529e955afafac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27e484bc572d80b8862f96bf0b9529e955afafac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27e484bc572d80b8862f96bf0b9529e955afafac/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "72eb6d424130d9556d49dada6d769e32b2d49bbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72eb6d424130d9556d49dada6d769e32b2d49bbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72eb6d424130d9556d49dada6d769e32b2d49bbe"}], "stats": {"total": 196, "additions": 175, "deletions": 21}, "files": [{"sha": "b5f15e01334aaae2e31468de1fc87f95d7ed0d45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e484bc572d80b8862f96bf0b9529e955afafac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e484bc572d80b8862f96bf0b9529e955afafac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27e484bc572d80b8862f96bf0b9529e955afafac", "patch": "@@ -1,3 +1,10 @@\n+2003-03-26  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR target/7784\n+\t* reload.c (find_reloads_address): Handle\n+\t(PLUS (PLUS (REG) (REG)) (CONST_INT)) form for\n+\tall base registers.\n+\n 2003-03-25  Marcelo Abreu  <mmabreu@inf.ufrgs.br>\n \n \tPR other/10203"}, {"sha": "e360e26c0daeb6a4e0547225bc0e938d8136f825", "filename": "gcc/reload.c", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e484bc572d80b8862f96bf0b9529e955afafac/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e484bc572d80b8862f96bf0b9529e955afafac/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=27e484bc572d80b8862f96bf0b9529e955afafac", "patch": "@@ -4890,25 +4890,23 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n      that the index needs a reload and find_reloads_address_1 will take care\n      of it.\n \n-     If we decide to do something here, it must be that\n-     `double_reg_address_ok' is true and that this address rtl was made by\n-     eliminate_regs.  We generate a reload of the fp/sp/ap + constant and\n+     Handle all base registers here, not just fp/ap/sp, because on some\n+     targets (namely Sparc) we can also get invalid addresses from preventive\n+     subreg big-endian corrections made by find_reloads_toplev.\n+\n+     If we decide to do something, it must be that `double_reg_address_ok'\n+     is true.  We generate a reload of the base register + constant and\n      rework the sum so that the reload register will be added to the index.\n      This is safe because we know the address isn't shared.\n \n-     We check for fp/ap/sp as both the first and second operand of the\n-     innermost PLUS.  */\n+     We check for the base register as both the first and second operand of\n+     the innermost PLUS.  */\n \n   else if (GET_CODE (ad) == PLUS && GET_CODE (XEXP (ad, 1)) == CONST_INT\n \t   && GET_CODE (XEXP (ad, 0)) == PLUS\n-\t   && (XEXP (XEXP (ad, 0), 0) == frame_pointer_rtx\n-#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-\t       || XEXP (XEXP (ad, 0), 0) == hard_frame_pointer_rtx\n-#endif\n-#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-\t       || XEXP (XEXP (ad, 0), 0) == arg_pointer_rtx\n-#endif\n-\t       || XEXP (XEXP (ad, 0), 0) == stack_pointer_rtx)\n+\t   && GET_CODE (XEXP (XEXP (ad, 0), 0)) == REG\n+\t   && REGNO (XEXP (XEXP (ad, 0), 0)) < FIRST_PSEUDO_REGISTER\n+\t   && REG_MODE_OK_FOR_BASE_P (XEXP (XEXP (ad, 0), 0), mode)\n \t   && ! maybe_memory_address_p (mode, ad, &XEXP (XEXP (ad, 0), 1)))\n     {\n       *loc = ad = gen_rtx_PLUS (GET_MODE (ad),\n@@ -4926,14 +4924,9 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \n   else if (GET_CODE (ad) == PLUS && GET_CODE (XEXP (ad, 1)) == CONST_INT\n \t   && GET_CODE (XEXP (ad, 0)) == PLUS\n-\t   && (XEXP (XEXP (ad, 0), 1) == frame_pointer_rtx\n-#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-\t       || XEXP (XEXP (ad, 0), 1) == hard_frame_pointer_rtx\n-#endif\n-#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-\t       || XEXP (XEXP (ad, 0), 1) == arg_pointer_rtx\n-#endif\n-\t       || XEXP (XEXP (ad, 0), 1) == stack_pointer_rtx)\n+\t   && GET_CODE (XEXP (XEXP (ad, 0), 1)) == REG\n+\t   && REGNO (XEXP (XEXP (ad, 0), 1)) < FIRST_PSEUDO_REGISTER\n+\t   && REG_MODE_OK_FOR_BASE_P (XEXP (XEXP (ad, 0), 1), mode)\n \t   && ! maybe_memory_address_p (mode, ad, &XEXP (XEXP (ad, 0), 0)))\n     {\n       *loc = ad = gen_rtx_PLUS (GET_MODE (ad),"}, {"sha": "38966bb9656272d2e5b060ef95bc7da0ccf8cb89", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e484bc572d80b8862f96bf0b9529e955afafac/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e484bc572d80b8862f96bf0b9529e955afafac/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=27e484bc572d80b8862f96bf0b9529e955afafac", "patch": "@@ -1,3 +1,7 @@\n+2003-03-26  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* gcc.dg/ultrasp6.c: New test.\n+\n 2003-03-25  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* gcc.dg/i386-signbit-1.c: New test."}, {"sha": "0518086402ead0718628920c42ee76fcc0be3daa", "filename": "gcc/testsuite/gcc.dg/ultrasp6.c", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27e484bc572d80b8862f96bf0b9529e955afafac/gcc%2Ftestsuite%2Fgcc.dg%2Fultrasp6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27e484bc572d80b8862f96bf0b9529e955afafac/gcc%2Ftestsuite%2Fgcc.dg%2Fultrasp6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fultrasp6.c?ref=27e484bc572d80b8862f96bf0b9529e955afafac", "patch": "@@ -0,0 +1,150 @@\n+/* PR target/7784 */\n+/* Originator: Peter van Hoof <p.van-hoof@qub.ac.uk> */\n+/* { dg-do compile { target sparc-*-* } } */\n+/* { dg-options \"-O2 -mcpu=ultrasparc\" } */\n+\n+typedef struct\n+{\n+  float EnergyErg;\n+  float ots;\n+} EmLine;\n+\n+extern const int ipH_LIKE ;\n+extern const int ipHYDROGEN ;\n+extern const int ipH1s;\n+extern const int ipH2s;\n+extern const int ipH2p;\n+\n+extern EmLine ****EmisLines;\n+\n+typedef struct\n+{\n+  long n;\n+  long s;\n+  long l;\n+} Elevels;\n+\n+extern struct t_iso\n+{\n+  float ***Pop2Ion;\n+  long int numLevels[2][30L];\n+} iso;\n+\n+extern struct t_LineSave\n+{\n+  long int nsum;\n+  long int ndsum;\n+  long int nComment;\n+  long int npxdd;\n+  long int ipass;\n+  char chHoldComments[10][200];\n+} LineSave;\n+\n+extern struct t_hydro\n+{\n+  int lgHydEmiss;\n+  float **pestrk ;\n+} hydro;\n+\n+extern struct t_dense\n+{\n+  double DensityLaw[10];\n+  float frad[500];\n+  float fhden[500];\n+  float den0;\n+  double eden;\n+} dense;\n+\n+extern struct t_abund\n+{\n+  float xIonFracs[30L +3][30L +1];\n+} abund;\n+\n+extern struct t_CaseBHS\n+{\n+  long int nDensity[2][8] , ntemp[2][8] , ncut[2][8] ;\n+  int lgHCaseBOK[2][8];\n+} CaseBHS ;\n+\n+extern struct t_smbeta\n+{\n+  float SimHBeta,\n+    cn4861,\n+    cn1216,\n+    sv4861,\n+    sv1216;\n+} smbeta;\n+\n+extern struct t_phycon\n+{\n+  float te;\n+} phycon;\n+\n+\n+extern struct t_sphere\n+{\n+  int lgSphere;\n+  float covgeo;\n+} sphere;\n+\n+void linadd(double xInten, float wavelength, char *chLab, char chInfo);\n+\n+extern struct t_radiusVar\n+{\n+  int lgDrNeg;\n+  double dVeff;\n+} radius;\n+\n+void lines_hydro(void)\n+{\n+  long int i, nelem, ipHi, ipLo;\n+  double hbetab, em , EmisFac, pump;\n+  char chLabel[5];\n+\n+  linadd(abund.xIonFracs[ipHYDROGEN][1]*iso.Pop2Ion[ipH_LIKE][ipHYDROGEN][3]*hydro.pestrk[3][2]*3.025e-12, 6563,\"Strk\",'i');\n+\n+  linadd(abund.xIonFracs[ipHYDROGEN][1]*iso.Pop2Ion[ipH_LIKE][ipHYDROGEN][4]*hydro.pestrk[4][2]*4.084e-12, 4861,\"Strk\",'i');\n+\n+  linadd(abund.xIonFracs[ipHYDROGEN][1]*iso.Pop2Ion[ipH_LIKE][ipHYDROGEN][4]*hydro.pestrk[4][3]*1.059e-12, 18751,\"Strk\",'i');\n+\n+  linadd(abund.xIonFracs[ipHYDROGEN][1]*iso.Pop2Ion[ipH_LIKE][ipHYDROGEN][5]*hydro.pestrk[5][4]*4.900e-13, 40512,\"Strk\",'i');\n+\n+  ((void)((LineSave.ipass <1 || EmisLines[ipH_LIKE][ipHYDROGEN][ipH2p][ipH1s].ots>= 0.) || (__assert(\"LineSave.ipass <1 || EmisLines[ipH_LIKE][ipHYDROGEN][ipH2p][ipH1s].ots>= 0.\", \"lines_hydro.c\", 118), 0)));\n+\n+  linadd(EmisLines[ipH_LIKE][ipHYDROGEN][3][ipH2s].ots*EmisLines[ipH_LIKE][ipHYDROGEN][3][ipH2s].EnergyErg, 6563,\"Dest\",'i');\n+\n+  linadd(EmisLines[ipH_LIKE][ipHYDROGEN][5][4].ots*EmisLines[ipH_LIKE][ipHYDROGEN][5][4].EnergyErg,40516, \"Dest\",'i');\n+\n+  smbeta.SimHBeta = smbeta.SimHBeta/(float)radius.dVeff*sphere.covgeo;\n+\n+  linadd(smbeta.SimHBeta,4861,\"Q(H)\",'i');\n+\n+  smbeta.SimHBeta = smbeta.SimHBeta*(float)radius.dVeff/sphere.covgeo;\n+\n+  for( nelem=0; nelem < 30L; nelem++ )\n+  {\n+    int iCase;\n+    for( iCase=0; iCase<2; ++iCase )\n+    {\n+      char chAB[2]={'A','B'};\n+      char chLab[5]=\"Ca  \";\n+\n+      for( ipLo=1+iCase; ipLo<(((6)<(iso.numLevels[ipH_LIKE][nelem])) ? (6) : (5)); ++ipLo )\n+      {\n+        for( ipHi=ipLo+1; ipHi< (((ipLo+5)<(iso.numLevels[ipH_LIKE][nelem])) ? (ipLo+5) : (iso.numLevels[ipH_LIKE][nelem])); ++ipHi )\n+        {\n+          float wl;\n+\n+          hbetab = HSRate( ipHi,ipLo , nelem+1, phycon.te , dense.eden, chAB[iCase] );\n+          if( hbetab<=0. )\n+            CaseBHS.lgHCaseBOK[iCase][nelem] = 0;\n+\n+          if( !hydro.lgHydEmiss )\n+            hbetab *= abund.xIonFracs[nelem][nelem+1]*dense.eden;\n+\n+         linadd(hbetab,wl,chLab,'i' );\n+        }\n+      }\n+    }\n+  }\n+}"}]}