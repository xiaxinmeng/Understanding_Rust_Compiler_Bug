{"sha": "3736837806fdb26daa51300bee1554bef89db9fe", "node_id": "C_kwDOANBUbNoAKDM3MzY4Mzc4MDZmZGIyNmRhYTUxMzAwYmVlMTU1NGJlZjg5ZGI5ZmU", "commit": {"author": {"name": "Petter Tomner", "email": "tomner@kth.se", "date": "2021-11-29T19:44:07Z"}, "committer": {"name": "Petter Tomner", "email": "tomner@kth.se", "date": "2021-12-14T17:18:07Z"}, "message": "Add support for global rvalue initialization and constructors\n\nThis patch adds support for initialization of global variables\nwith rvalues and creating constructors for array, struct and\nunion types which can be used as rvalues.\n\nSigned-off-by:\n2021-12-14\tPetter Tomner\t<tomner@kth.se>\n\ngcc/jit/\n\t* jit-common.h: New enum\n\t* jit-playback.c : Folding an setting intitial\n\t(global_new_decl) : Handle const global generation\n\t(new_global) : New flag\n\t(global_set_init_rvalue) : New\n\t(new_ctor) : New\n\t(new_global_initialized) : Flag\n\t(as_truth_value) : Fold\n\t(new_unary_op) : Fold\n\t(new_binary_op) : Fold\n\t(new_comparison) : Fold\n\t(new_array_access) : Fold\n\t(new_dereference) : Fold\n\t(get_address) : Fold\n\t* jit-playback.h :\n\t(global_set_init_rvalue) : New\n\t(new_ctor) : New\n\t* jit-recording.c :\n\t* jit-recording.h :\n\t(new_global_init_rvalue) : New\n\t(new_ctor) : New\n\t(ctor) : New, inherits rvalue\n\t(global_init_rvalue) : New, inherits memento\n\t(type::is_union) : New\n\t* libgccjit++.h : New entrypoints, see C-header\n\t* libgccjit.c : See .h\n\t* libgccjit.h : New entrypoints\n\t(gcc_jit_context_new_array_constructor) : New\n\t(gcc_jit_context_new_struct_constructor) : New\n\t(gcc_jit_context_new_union_constructor) : New\n\t(gcc_jit_global_set_initializer_rvalue) : New\n\t(LIBGCCJIT_HAVE_CTORS) : New feuture macro\n\t* libgccjit.map : New entrypoints added to ABI 19\n\t* docs/topics/expressions.rst : Updated docs\n\ngcc/testsuite/\n\t* jit.dg/all-non-failing-tests.h: Added two tests\n\t* jit.dg/test-error-ctor-array-wrong-obj.c: New\n\t* jit.dg/test-error-ctor-struct-too-big.c: New\n\t* jit.dg/test-error-ctor-struct-wrong-field-obj.c: New\n\t* jit.dg/test-error-ctor-struct-wrong-type.c: New\n\t* jit.dg/test-error-ctor-struct-wrong-type2.c\n\t* jit.dg/test-error-ctor-union-wrong-field-name.c: New\n\t* jit.dg/test-error-global-already-init.c: New\n\t* jit.dg/test-error-global-common-section.c: New\n\t* jit.dg/test-error-global-init-too-small-array.c: New\n\t* jit.dg/test-error-global-lvalue-init.c: New\n\t* jit.dg/test-error-global-nonconst-init.c: New\n\t* jit.dg/test-global-init-rvalue.c: New\n\t* jit.dg/test-local-init-rvalue.c: New", "tree": {"sha": "874865030ed635b65e50b15bc717891b8047afd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/874865030ed635b65e50b15bc717891b8047afd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3736837806fdb26daa51300bee1554bef89db9fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3736837806fdb26daa51300bee1554bef89db9fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3736837806fdb26daa51300bee1554bef89db9fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3736837806fdb26daa51300bee1554bef89db9fe/comments", "author": {"login": "pvilhelm", "id": 2867017, "node_id": "MDQ6VXNlcjI4NjcwMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/2867017?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvilhelm", "html_url": "https://github.com/pvilhelm", "followers_url": "https://api.github.com/users/pvilhelm/followers", "following_url": "https://api.github.com/users/pvilhelm/following{/other_user}", "gists_url": "https://api.github.com/users/pvilhelm/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvilhelm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvilhelm/subscriptions", "organizations_url": "https://api.github.com/users/pvilhelm/orgs", "repos_url": "https://api.github.com/users/pvilhelm/repos", "events_url": "https://api.github.com/users/pvilhelm/events{/privacy}", "received_events_url": "https://api.github.com/users/pvilhelm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvilhelm", "id": 2867017, "node_id": "MDQ6VXNlcjI4NjcwMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/2867017?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvilhelm", "html_url": "https://github.com/pvilhelm", "followers_url": "https://api.github.com/users/pvilhelm/followers", "following_url": "https://api.github.com/users/pvilhelm/following{/other_user}", "gists_url": "https://api.github.com/users/pvilhelm/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvilhelm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvilhelm/subscriptions", "organizations_url": "https://api.github.com/users/pvilhelm/orgs", "repos_url": "https://api.github.com/users/pvilhelm/repos", "events_url": "https://api.github.com/users/pvilhelm/events{/privacy}", "received_events_url": "https://api.github.com/users/pvilhelm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c613165a55b212c59a83796b20a1d555e096504", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c613165a55b212c59a83796b20a1d555e096504", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c613165a55b212c59a83796b20a1d555e096504"}], "stats": {"total": 4760, "additions": 4727, "deletions": 33}, "files": [{"sha": "0a96872551ba582424516450dbe6b8085cdbca82", "filename": "gcc/jit/docs/topics/expressions.rst", "status": "modified", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Fdocs%2Ftopics%2Fexpressions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Fdocs%2Ftopics%2Fexpressions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fexpressions.rst?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -126,6 +126,147 @@ Simple expressions\n    underlying string, so it is valid to pass in a pointer to an on-stack\n    buffer.\n \n+Constructor expressions\n+***********************\n+\n+   The following functions make constructors for array, struct and union\n+   types.\n+\n+   The constructor rvalue can be used for assignment to locals.\n+   It can be used to initialize global variables with\n+   :func:`gcc_jit_global_set_initializer_rvalue`. It can also be used as a\n+   temporary value for function calls and return values, but its address\n+   can't be taken.\n+\n+   Note that arrays in libgccjit do not collapse to pointers like in\n+   C. I.e. if an array constructor is used as e.g. a return value, the whole\n+   array would be returned by value - array constructors can be assigned to\n+   array variables.\n+\n+   The constructor can contain nested constructors.\n+\n+   Note that a string literal rvalue can't be used to construct a char array;\n+   the latter needs one rvalue for each char.\n+\n+   These entrypoints were added in :ref:`LIBGCCJIT_ABI_19`; you can test for\n+   their presence using:\n+\n+   .. code-block:: c\n+     #ifdef LIBGCCJIT_HAVE_CTORS\n+\n+.. function:: gcc_jit_rvalue *\\\n+\t      gcc_jit_context_new_array_constructor (gcc_jit_context *ctxt,\\\n+\t\t\t\t\t\t     gcc_jit_location *loc,\\\n+\t\t\t\t\t\t     gcc_jit_type *type,\\\n+\t\t\t\t\t\t     size_t num_values,\\\n+\t\t\t\t\t\t     gcc_jit_rvalue **values)\n+\n+   Create a constructor for an array as an rvalue.\n+\n+   Returns NULL on error. ``values`` are copied and\n+   do not have to outlive the context.\n+\n+   ``type`` specifies what the constructor will build and has to be\n+   an array.\n+\n+   ``num_values`` specifies the number of elements in ``values`` and\n+   it can't have more elements than the array type.\n+\n+   Each value in ``values`` sets the corresponding value in the array.\n+   If the array type itself has more elements than ``values``, the\n+   left-over elements will be zeroed.\n+\n+   Each value in ``values`` need to be the same unqualified type as the\n+   array type's element type.\n+\n+   If ``num_values`` is 0, the ``values`` parameter will be\n+   ignored and zero initialization will be used.\n+\n+   This entrypoint was added in :ref:`LIBGCCJIT_ABI_19`; you can test for its\n+   presence using:\n+\n+   .. code-block:: c\n+     #ifdef LIBGCCJIT_HAVE_CTORS\n+\n+.. function:: gcc_jit_rvalue *\\\n+\t      gcc_jit_context_new_struct_constructor (gcc_jit_context *ctxt,\\\n+\t\t\t\t\t\t      gcc_jit_location *loc,\\\n+\t\t\t\t\t\t      gcc_jit_type *type,\\\n+\t\t\t\t\t\t      size_t num_values,\\\n+\t\t\t\t\t\t      gcc_jit_field **fields,\\\n+\t\t\t\t\t\t      gcc_jit_rvalue **value)\n+\n+\n+   Create a constructor for a struct as an rvalue.\n+\n+   Returns NULL on error. The two parameter arrays are copied and\n+   do not have to outlive the context.\n+\n+   ``type`` specifies what the constructor will build and has to be\n+   a struct.\n+\n+   ``num_values`` specifies the number of elements in ``values``.\n+\n+   ``fields`` need to have the same length as ``values``, or be NULL.\n+\n+   If ``fields`` is null, the values are applied in definition order.\n+\n+   Otherwise, each field in ``fields`` specifies which field in the struct to\n+   set to the corresponding value in ``values``. ``fields`` and ``values``\n+   are paired by index.\n+\n+   The fields in ``fields`` have to be in definition order, but there\n+   can be gaps. Any field in the struct that is not specified in\n+   ``fields`` will be zeroed.\n+\n+   The fields in ``fields`` need to be the same objects that were used\n+   to create the struct.\n+\n+   Each value has to have have the same unqualified type as the field\n+   it is applied to.\n+\n+   A NULL value element  in ``values`` is a shorthand for zero initialization\n+   of the corresponding field.\n+\n+   If ``num_values`` is 0, the array parameters will be\n+   ignored and zero initialization will be used.\n+\n+   This entrypoint was added in :ref:`LIBGCCJIT_ABI_19`; you can test for its\n+   presence using:\n+\n+   .. code-block:: c\n+     #ifdef LIBGCCJIT_HAVE_CTORS\n+\n+.. function:: gcc_jit_rvalue *\\\n+\t      gcc_jit_context_new_union_constructor (gcc_jit_context *ctxt,\\\n+\t\t\t\t\t\t     gcc_jit_location *loc,\\\n+\t\t\t\t\t\t     gcc_jit_type *type,\\\n+\t\t\t\t\t\t     gcc_jit_field *field,\\\n+\t\t\t\t\t\t     gcc_jit_rvalue *value)\n+\n+   Create a constructor for a union as an rvalue.\n+\n+   Returns NULL on error.\n+\n+   ``type`` specifies what the constructor will build and has to be\n+   an union.\n+\n+   ``field`` specifies which field to set. If it is NULL, the first\n+   field in the union will be set.``field`` need to be the same object\n+   that were used to create the union.\n+\n+   ``value`` specifies what value to set the corresponding field to.\n+   If ``value`` is NULL, zero initialization will be used.\n+\n+   Each value has to have have the same unqualified type as the field\n+   it is applied to.\n+\n+   This entrypoint was added in :ref:`LIBGCCJIT_ABI_19`; you can test for its\n+   presence using:\n+\n+   .. code-block:: c\n+     #ifdef LIBGCCJIT_HAVE_CTORS\n+\n Vector expressions\n ******************\n \n@@ -661,6 +802,38 @@ Global variables\n \n       #ifdef LIBGCCJIT_HAVE_gcc_jit_global_set_initializer\n \n+.. function:: gcc_jit_lvalue *\\\n+\t      gcc_jit_global_set_initializer_rvalue (gcc_jit_lvalue *global,\n+\t                                             gcc_jit_rvalue *init_value)\n+\n+   Set the initial value of a global with an rvalue.\n+\n+   The rvalue needs to be a constant expression, e.g. no function calls.\n+\n+   The global can't have the ``kind`` :ref:`GCC_JIT_GLOBAL_IMPORTED`.\n+\n+   As a non-comprehensive example it is OK to do the equivalent of:\n+\n+   .. code-block:: c\n+\n+       int foo = 3 * 2; /* rvalue from gcc_jit_context_new_binary_op.  */\n+       int arr[] = {1,2,3,4}; /* rvalue from gcc_jit_context_new_constructor.  */\n+       int *bar = &arr[2] + 1; /* rvalue from nested \"get address\" of \"array access\".  */\n+       const int baz = 3; /* rvalue from gcc_jit_context_rvalue_from_int.  */\n+       int boz = baz; /* rvalue from gcc_jit_lvalue_as_rvalue.  */\n+\n+   Use together with :ref:`gcc_jit_context_new_constructor` to\n+   initialize structs, unions and arrays.\n+\n+   On success, returns the ``global`` parameter unchanged. Otherwise, ``NULL``.\n+\n+   This entrypoint was added in :ref:`LIBGCCJIT_ABI_19`; you can test for its\n+   presence using:\n+\n+   .. code-block:: c\n+\n+      #ifdef LIBGCCJIT_HAVE_CTORS\n+\n Working with pointers, structs and unions\n -----------------------------------------\n "}, {"sha": "2e723c38d789a2fbe2ea972eb2f1d4e20df1c5b6", "filename": "gcc/jit/jit-common.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Fjit-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Fjit-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-common.h?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -202,6 +202,15 @@ enum inner_bool_option\n   NUM_INNER_BOOL_OPTIONS\n };\n \n+/* Flags for global variables class.  For when the playback of the\n+   global need to know what will happen to it later.  */\n+enum global_var_flags\n+{\n+  GLOBAL_VAR_FLAGS_NONE = 0,\n+  GLOBAL_VAR_FLAGS_WILL_BE_RVAL_INIT = 1,\n+  GLOBAL_VAR_FLAGS_WILL_BE_BLOB_INIT = 2,\n+};\n+\n } // namespace gcc::jit\n \n } // namespace gcc"}, {"sha": "64755b6c6fe28988d81c3af30128a77515da540c", "filename": "gcc/jit/jit-playback.c", "status": "modified", "additions": 208, "deletions": 15, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Fjit-playback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Fjit-playback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.c?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -97,6 +97,43 @@ namespace jit {\n  Playback.\n  **********************************************************************/\n \n+/* Fold a readonly non-volatile variable with an initial constant value,\n+   to that value.\n+\n+   Otherwise return the argument unchanged.\n+\n+   This fold is needed for setting a variable's DECL_INITIAL to the value\n+   of a const variable.  The c-frontend does this in its own special\n+   fold (), so we lift this part out and do it explicitly where there is a\n+   potential for variables to be used as rvalues.  */\n+static tree\n+fold_const_var (tree node)\n+{\n+  /* See c_fully_fold_internal in c-fold.c and decl_constant_value_1\n+     in c-typeck.c.  */\n+  if (VAR_P (node)\n+      && TREE_READONLY (node)\n+      && !TREE_THIS_VOLATILE (node)\n+      && DECL_INITIAL (node) != NULL_TREE\n+      /* \"This is invalid if initial value is not constant.\n+\t  If it has either a function call, a memory reference,\n+\t  or a variable, then re-evaluating it could give different\n+\t  results.\"  */\n+      && TREE_CONSTANT (DECL_INITIAL (node)))\n+    {\n+      tree ret = DECL_INITIAL (node);\n+      /* \"Avoid unwanted tree sharing between the initializer and current\n+\t  function's body where the tree can be modified e.g. by the\n+\t  gimplifier.\"  */\n+      if (TREE_STATIC (node))\n+\tret = unshare_expr (ret);\n+\n+      return ret;\n+    }\n+\n+  return node;\n+}\n+\n /* Build a STRING_CST tree for STR, or return NULL if it is NULL.\n    The TREE_TYPE is not initialized.  */\n \n@@ -538,15 +575,28 @@ playback::context::\n global_new_decl (location *loc,\n \t\t enum gcc_jit_global_kind kind,\n \t\t type *type,\n-\t\t const char *name)\n+\t\t const char *name,\n+\t\t enum global_var_flags flags)\n {\n   gcc_assert (type);\n   gcc_assert (name);\n+\n+  tree type_tree = type->as_tree ();\n+\n   tree inner = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n \t\t\t   get_identifier (name),\n-\t\t\t   type->as_tree ());\n+\t\t\t   type_tree);\n+\n   TREE_PUBLIC (inner) = (kind != GCC_JIT_GLOBAL_INTERNAL);\n-  DECL_COMMON (inner) = 1;\n+\n+\n+  int will_be_init = flags & (GLOBAL_VAR_FLAGS_WILL_BE_RVAL_INIT |\n+\t\t\t      GLOBAL_VAR_FLAGS_WILL_BE_BLOB_INIT);\n+\n+  /* A VAR_DECL with DECL_INITIAL will not end up in .common section.  */\n+  if (!will_be_init)\n+    DECL_COMMON (inner) = 1;\n+\n   switch (kind)\n     {\n     default:\n@@ -565,6 +615,9 @@ global_new_decl (location *loc,\n       break;\n     }\n \n+  if (TYPE_READONLY (type_tree))\n+    TREE_READONLY (inner) = 1;\n+\n   if (loc)\n     set_tree_location (inner, loc);\n \n@@ -589,13 +642,121 @@ playback::context::\n new_global (location *loc,\n \t    enum gcc_jit_global_kind kind,\n \t    type *type,\n-\t    const char *name)\n+\t    const char *name,\n+\t    enum global_var_flags flags)\n {\n-  tree inner = global_new_decl (loc, kind, type, name);\n+  tree inner =\n+    global_new_decl (loc, kind, type, name, flags);\n \n   return global_finalize_lvalue (inner);\n }\n \n+void\n+playback::context::\n+global_set_init_rvalue (lvalue* variable,\n+\t\t\trvalue* init)\n+{\n+  tree inner = variable->as_tree ();\n+\n+  /* We need to fold all expressions as much as possible.  The code\n+     for a DECL_INITIAL only handles some operations,\n+     etc addition, minus, 'address of'.  See output_addressed_constants ()\n+     in varasm.c.  */\n+  tree init_tree = init->as_tree ();\n+  tree folded = fold_const_var (init_tree);\n+\n+  if (!TREE_CONSTANT (folded))\n+    {\n+      tree name = DECL_NAME (inner);\n+\n+      if (name != NULL_TREE)\n+\tadd_error (NULL,\n+\t\t   \"unable to convert initial value for the global variable %s\"\n+\t\t   \" to a compile-time constant\",\n+\t\t   IDENTIFIER_POINTER (name));\n+      else\n+\tadd_error (NULL,\n+\t\t   \"unable to convert initial value for global variable\"\n+\t\t   \" to a compile-time constant\");\n+      return;\n+    }\n+\n+  DECL_INITIAL (inner) = folded;\n+}\n+\n+playback::rvalue *\n+playback::context::\n+new_ctor (location *loc,\n+\t  type *type,\n+\t  const auto_vec<field*> *fields,\n+\t  const auto_vec<rvalue*> *rvalues)\n+{\n+  tree type_tree = type->as_tree ();\n+\n+  /* Handle empty ctors first.  I.e. set everything to 0.  */\n+  if (rvalues->length () == 0)\n+    return new rvalue (this, build_constructor (type_tree, NULL));\n+\n+  /* Handle arrays (and return).  */\n+  if (TREE_CODE (type_tree) == ARRAY_TYPE)\n+    {\n+      int n = rvalues->length ();\n+      /* The vec for the constructor node.  */\n+      vec<constructor_elt, va_gc> *v = NULL;\n+      vec_alloc (v, n);\n+\n+      for (int i = 0; i < n; i++)\n+\t{\n+\t  rvalue *rv = (*rvalues)[i];\n+\t  /* null rvalues indicate that the element should be zeroed.  */\n+\t  if (rv)\n+\t    CONSTRUCTOR_APPEND_ELT (v,\n+\t\t\t\t    build_int_cst (size_type_node, i),\n+\t\t\t\t    rv->as_tree ());\n+\t  else\n+\t    CONSTRUCTOR_APPEND_ELT (v,\n+\t\t\t\t    build_int_cst (size_type_node, i),\n+\t\t\t\t    build_zero_cst (TREE_TYPE (type_tree)));\n+\t}\n+\n+      tree ctor = build_constructor (type_tree, v);\n+\n+      if (loc)\n+\tset_tree_location (ctor, loc);\n+\n+      return new rvalue (this, ctor);\n+    }\n+\n+  /* Handle structs and unions.  */\n+  int n = fields->length ();\n+\n+  /* The vec for the constructor node.  */\n+  vec<constructor_elt, va_gc> *v = NULL;\n+  vec_alloc (v, n);\n+\n+  /* Iterate over the fields, building initializations.  */\n+  for (int i = 0;i < n; i++)\n+    {\n+      tree field = (*fields)[i]->as_tree ();\n+      rvalue *rv = (*rvalues)[i];\n+      /* If the value is NULL, it means we should zero the field.  */\n+      if (rv)\n+\tCONSTRUCTOR_APPEND_ELT (v, field, rv->as_tree ());\n+      else\n+\t{\n+\t  tree zero_cst = build_zero_cst (TREE_TYPE (field));\n+\t  CONSTRUCTOR_APPEND_ELT (v, field, zero_cst);\n+\t}\n+    }\n+\n+  tree ctor = build_constructor (type_tree, v);\n+\n+  if (loc)\n+    set_tree_location (ctor, loc);\n+\n+  return new rvalue (this, build_constructor (type_tree, v));\n+}\n+\n /* Fill 'constructor_elements' with the memory content of\n    'initializer'.  Each element of the initializer is of the size of\n    type T.  In use by new_global_initialized.*/\n@@ -629,9 +790,10 @@ new_global_initialized (location *loc,\n                         size_t element_size,\n \t\t\tsize_t initializer_num_elem,\n \t\t\tconst void *initializer,\n-\t\t\tconst char *name)\n+\t\t\tconst char *name,\n+\t\t\tenum global_var_flags flags)\n {\n-  tree inner = global_new_decl (loc, kind, type, name);\n+  tree inner = global_new_decl (loc, kind, type, name, flags);\n \n   vec<constructor_elt, va_gc> *constructor_elements = NULL;\n \n@@ -831,7 +993,8 @@ as_truth_value (tree expr, location *loc)\n   if (loc)\n     set_tree_location (typed_zero, loc);\n \n-  expr = build2 (NE_EXPR, integer_type_node, expr, typed_zero);\n+  expr = fold_build2_loc (UNKNOWN_LOCATION,\n+    NE_EXPR, integer_type_node, expr, typed_zero);\n   if (loc)\n     set_tree_location (expr, loc);\n \n@@ -867,6 +1030,8 @@ new_unary_op (location *loc,\n   gcc_assert (a);\n \n   tree node = a->as_tree ();\n+  node = fold_const_var (node);\n+\n   tree inner_result = NULL;\n \n   switch (op)\n@@ -898,6 +1063,10 @@ new_unary_op (location *loc,\n   inner_result = build1 (inner_op,\n \t\t\t result_type->as_tree (),\n \t\t\t node);\n+\n+  /* Try to fold.  */\n+  inner_result = fold (inner_result);\n+\n   if (loc)\n     set_tree_location (inner_result, loc);\n \n@@ -922,7 +1091,10 @@ new_binary_op (location *loc,\n   gcc_assert (b);\n \n   tree node_a = a->as_tree ();\n+  node_a = fold_const_var (node_a);\n+\n   tree node_b = b->as_tree ();\n+  node_b = fold_const_var (node_b);\n \n   switch (op)\n     {\n@@ -992,6 +1164,10 @@ new_binary_op (location *loc,\n \t\t\t    result_type->as_tree (),\n \t\t\t    node_a,\n \t\t\t    node_b);\n+\n+  /* Try to fold the expression.  */\n+  inner_expr = fold (inner_expr);\n+\n   if (loc)\n     set_tree_location (inner_expr, loc);\n \n@@ -1039,10 +1215,19 @@ new_comparison (location *loc,\n       break;\n     }\n \n+  tree node_a = a->as_tree ();\n+  node_a = fold_const_var (node_a);\n+  tree node_b = b->as_tree ();\n+  node_b = fold_const_var (node_b);\n+\n   tree inner_expr = build2 (inner_op,\n \t\t\t    boolean_type_node,\n-\t\t\t    a->as_tree (),\n-\t\t\t    b->as_tree ());\n+\t\t\t    node_a,\n+\t\t\t    node_b);\n+\n+  /* Try to fold.  */\n+  inner_expr = fold (inner_expr);\n+\n   if (loc)\n     set_tree_location (inner_expr, loc);\n   return new rvalue (this, inner_expr);\n@@ -1142,6 +1327,8 @@ playback::context::build_cast (playback::location *loc,\n \n      Only some kinds of cast are currently supported here.  */\n   tree t_expr = expr->as_tree ();\n+  t_expr = fold_const_var (t_expr);\n+\n   tree t_dst_type = type_->as_tree ();\n   tree t_ret = NULL;\n   t_ret = targetm.convert_to_type (t_dst_type, t_expr);\n@@ -1220,14 +1407,18 @@ new_array_access (location *loc,\n        c-family/c-common.c: pointer_int_sum\n   */\n   tree t_ptr = ptr->as_tree ();\n+  t_ptr = fold_const_var (t_ptr);\n   tree t_index = index->as_tree ();\n+  t_index = fold_const_var (t_index);\n+\n   tree t_type_ptr = TREE_TYPE (t_ptr);\n   tree t_type_star_ptr = TREE_TYPE (t_type_ptr);\n \n   if (TREE_CODE (t_type_ptr) == ARRAY_TYPE)\n     {\n       tree t_result = build4 (ARRAY_REF, t_type_star_ptr, t_ptr, t_index,\n \t\t\t      NULL_TREE, NULL_TREE);\n+      t_result = fold (t_result);\n       if (loc)\n \tset_tree_location (t_result, loc);\n       return new lvalue (this, t_result);\n@@ -1237,12 +1428,14 @@ new_array_access (location *loc,\n       /* Convert index to an offset in bytes.  */\n       tree t_sizeof = size_in_bytes (t_type_star_ptr);\n       t_index = fold_build1 (CONVERT_EXPR, sizetype, t_index);\n-      tree t_offset = build2 (MULT_EXPR, sizetype, t_index, t_sizeof);\n+      tree t_offset = fold_build2_loc (UNKNOWN_LOCATION,\n+\tMULT_EXPR, sizetype, t_index, t_sizeof);\n \n       /* Locate (ptr + offset).  */\n-      tree t_address = build2 (POINTER_PLUS_EXPR, t_type_ptr, t_ptr, t_offset);\n+      tree t_address = fold_build2_loc (UNKNOWN_LOCATION,\n+\tPOINTER_PLUS_EXPR, t_type_ptr, t_ptr, t_offset);\n \n-      tree t_indirection = build1 (INDIRECT_REF, t_type_star_ptr, t_address);\n+      tree t_indirection = fold_build1 (INDIRECT_REF, t_type_star_ptr, t_address);\n       if (loc)\n \t{\n \t  set_tree_location (t_sizeof, loc);\n@@ -1290,7 +1483,7 @@ new_dereference (tree ptr,\n   gcc_assert (ptr);\n \n   tree type = TREE_TYPE (TREE_TYPE(ptr));\n-  tree datum = build1 (INDIRECT_REF, type, ptr);\n+  tree datum = fold_build1 (INDIRECT_REF, type, ptr);\n   if (loc)\n     set_tree_location (datum, loc);\n   return datum;\n@@ -1444,7 +1637,7 @@ get_address (location *loc)\n   tree t_lvalue = as_tree ();\n   tree t_thistype = TREE_TYPE (t_lvalue);\n   tree t_ptrtype = build_pointer_type (t_thistype);\n-  tree ptr = build1 (ADDR_EXPR, t_ptrtype, t_lvalue);\n+  tree ptr = fold_build1 (ADDR_EXPR, t_ptrtype, t_lvalue);\n   if (loc)\n     get_context ()->set_tree_location (ptr, loc);\n   if (mark_addressable (loc))"}, {"sha": "6ca492cc2e006e78b5ab3e7d651760e72bddd340", "filename": "gcc/jit/jit-playback.h", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Fjit-playback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Fjit-playback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.h?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -109,7 +109,8 @@ class context : public log_user\n   new_global (location *loc,\n \t      enum gcc_jit_global_kind kind,\n \t      type *type,\n-\t      const char *name);\n+\t      const char *name,\n+\t      enum global_var_flags flags);\n \n   lvalue *\n   new_global_initialized (location *loc,\n@@ -118,7 +119,19 @@ class context : public log_user\n                           size_t element_size,\n                           size_t initializer_num_elem,\n                           const void *initializer,\n-                          const char *name);\n+\t\t\t  const char *name,\n+\t\t\t  enum global_var_flags flags);\n+\n+  rvalue *\n+  new_ctor (location *log,\n+\t    type *type,\n+\t    const auto_vec<field*> *fields,\n+\t    const auto_vec<rvalue*> *rvalues);\n+\n+\n+  void\n+  global_set_init_rvalue (lvalue* variable,\n+\t\t\t  rvalue* init);\n \n   template <typename HOST_TYPE>\n   rvalue *\n@@ -286,7 +299,8 @@ class context : public log_user\n   global_new_decl (location *loc,\n                    enum gcc_jit_global_kind kind,\n                    type *type,\n-                   const char *name);\n+\t\t   const char *name,\n+\t\t   enum global_var_flags flags);\n   lvalue *\n   global_finalize_lvalue (tree inner);\n "}, {"sha": "764e7a33c7688b36c8a74ebe444af9a47340d840", "filename": "gcc/jit/jit-recording.c", "status": "modified", "additions": 458, "deletions": 13, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -1062,6 +1062,18 @@ recording::context::new_global (recording::location *loc,\n   return result;\n }\n \n+void\n+recording::context::new_global_init_rvalue (lvalue *variable,\n+\t\t\t\t\t    rvalue *init)\n+{\n+  recording::global_init_rvalue *obj =\n+    new recording::global_init_rvalue (this, variable, init);\n+  record (obj);\n+\n+  global *gbl = (global *) variable;\n+  gbl->set_rvalue_init (init); /* Needed by the global for write dump.  */\n+}\n+\n /* Create a recording::memento_of_new_string_literal instance and add it\n    to this context's list of mementos.\n \n@@ -1094,6 +1106,72 @@ recording::context::new_rvalue_from_vector (location *loc,\n   return result;\n }\n \n+recording::rvalue *\n+recording::context::new_ctor (recording::location *loc,\n+\t\t\t      recording::type *type,\n+\t\t\t      size_t num_values,\n+\t\t\t      field **fields,\n+\t\t\t      rvalue **values)\n+{\n+  recording::ctor *result = new ctor (this, loc, type);\n+\n+  /* Short cut for zero init.  */\n+  if (!num_values)\n+    {\n+      record (result);\n+      return result;\n+    }\n+\n+  bool is_struct_or_union = type->is_struct () || type->is_union ();\n+\n+  /* We need to copy fields and values into result's auto_vec:s.\n+     Both for structs and unions and only values for arrays.  */\n+  if (type->is_array () != NULL)\n+    {\n+      result->m_values.reserve (num_values, false);\n+\n+      for (size_t i = 0; i < num_values; i++)\n+\tresult->m_values.quick_push (values[i]);\n+    }\n+  else if (is_struct_or_union && fields)\n+    {\n+      /* ctor values are paired with user specified fields.  */\n+\n+      result->m_values.reserve (num_values, false);\n+      result->m_fields.reserve (num_values, false);\n+\n+      for (size_t i = 0; i < num_values; i++)\n+\t{\n+\t  result->m_values.quick_push (values[i]);\n+\t  result->m_fields.quick_push (fields[i]);\n+\t}\n+    }\n+  else if (is_struct_or_union && !fields)\n+    {\n+      /* ctor values are in definition order one by one,\n+\t so take the fields from the type object.  */\n+\n+      result->m_values.reserve (num_values, false);\n+      result->m_fields.reserve (num_values, false);\n+\n+      compound_type *ct = reinterpret_cast<compound_type *>(type);\n+      recording::fields *fields = ct->get_fields ();\n+\n+      /* The entry point checks that num_values is not greater than\n+\t the amount of fields in 'fields'.  */\n+      for (size_t i = 0; i < num_values; i++)\n+\t{\n+\t  result->m_values.quick_push (values[i]);\n+\t  result->m_fields.quick_push (fields->get_field (i));\n+\t}\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  record (result);\n+  return result;\n+}\n+\n /* Create a recording::unary_op instance and add it to this context's\n    list of mementos.\n \n@@ -4581,11 +4659,13 @@ recording::global::replay_into (replayer *r)\n \t\t\t\t m_initializer_num_bytes\n \t\t\t\t / m_type->dereference ()->get_size (),\n \t\t\t\t m_initializer,\n-\t\t\t\t playback_string (m_name))\n-  : r->new_global (playback_location (r, m_loc),\n+\t\t\t\t playback_string (m_name),\n+\t\t\t\t m_flags)\n+    : r->new_global (playback_location (r, m_loc),\n \t\t     m_kind,\n \t\t     m_type->playback_type (),\n-\t\t     playback_string (m_name));\n+\t\t     playback_string (m_name),\n+\t\t     m_flags);\n \n   if (m_tls_model != GCC_JIT_TLS_MODEL_NONE)\n     global->set_tls_model (recording::tls_models[m_tls_model]);\n@@ -4642,21 +4722,30 @@ recording::global::write_to_dump (dump &d)\n \t   m_type->get_debug_string (),\n \t   get_debug_string ());\n \n-  if (!m_initializer)\n+  if (!m_initializer && !m_rvalue_init)\n     {\n       d.write (\";\\n\");\n-      return;\n     }\n-\n-  d.write (\"=\\n  { \");\n-  const unsigned char *p = (const unsigned char *)m_initializer;\n-  for (size_t i = 0; i < m_initializer_num_bytes; i++)\n+  else if (m_initializer)\n     {\n-      d.write (\"0x%x, \", p[i]);\n-      if (i && !(i % 64))\n-\td.write (\"\\n    \");\n+      d.write (\"=\\n  { \");\n+      const unsigned char *p = (const unsigned char *)m_initializer;\n+      for (size_t i = 0; i < m_initializer_num_bytes; i++)\n+\t{\n+\t  d.write (\"0x%x, \", p[i]);\n+\t  if (i && !(i % 64))\n+\t    d.write (\"\\n    \");\n+\t}\n+      d.write (\"};\\n\");\n     }\n-  d.write (\"};\\n\");\n+  else if (m_rvalue_init)\n+    {\n+      d.write (\" = \");\n+      d.write (m_rvalue_init->get_debug_string ());\n+      d.write (\";\\n\");\n+    }\n+\n+  return;\n }\n \n /* A table of enum gcc_jit_global_kind values expressed in string\n@@ -5123,6 +5212,201 @@ recording::memento_of_new_rvalue_from_vector::write_reproducer (reproducer &r)\n \t   elements_id);\n }\n \n+void\n+recording::ctor::visit_children (rvalue_visitor *v)\n+{\n+  for (unsigned int i = 0; i < m_values.length (); i++)\n+    v->visit (m_values[i]);\n+}\n+\n+recording::string *\n+recording::ctor::make_debug_string ()\n+{\n+  //Make a compound literal-ish\n+  pretty_printer pp;\n+\n+  pp_string (&pp, \"(\");\n+  pp_string (&pp, m_type->get_debug_string ());\n+  pp_string (&pp, \") {\");\n+\n+  size_t field_n = m_fields.length ();\n+  size_t values_n = m_values.length ();\n+\n+  if (!field_n && !values_n)\n+    ;\n+  else if (!field_n && values_n)\n+    {\n+      for (size_t i = 0; i < values_n; i++)\n+\t{\n+\t  if (m_values[i])\n+\t    pp_string (&pp, m_values[i]->get_debug_string ());\n+\t  else\n+\t    pp_string (&pp, \"0\");\n+\t  if (i + 1 != values_n)\n+\t    pp_string (&pp, \", \");\n+\t}\n+    }\n+  else if (field_n && values_n)\n+    {\n+      for (size_t i = 0; i < values_n; i++)\n+\t{\n+\t  pp_string (&pp, \".\");\n+\t  pp_string (&pp, m_fields[i]->get_debug_string ());\n+\t  pp_string (&pp, \"=\");\n+\t  if (m_values[i])\n+\t    pp_string (&pp, m_values[i]->get_debug_string ());\n+\t  else\n+\t    pp_string (&pp, \"0\");\n+\t  if (i + 1 != values_n)\n+\t    pp_string (&pp, \", \");\n+\t}\n+    }\n+  /* m_fields are never populated with m_values empty.  */\n+\n+  pp_string (&pp, \"}\");\n+\n+  return new_string (pp_formatted_text (&pp));\n+}\n+\n+void\n+recording::ctor::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"rvalue\");\n+  type *type = get_type ();\n+\n+  r.write (\"  gcc_jit_rvalue *%s;\\n\", id);\n+  r.write (\"  {\\n\"); /* Open scope for locals.  */\n+\n+  if (type->is_union ())\n+    {\n+      if (m_values.length () == 0)\n+\tr.write (\"    gcc_jit_rvalue *value = NULL;\\n\");\n+      else\n+\tr.write (\"    gcc_jit_rvalue *value = %s;\\n\",\n+\t\t r.get_identifier (m_values[0]));\n+\n+      if (m_fields.length () == 0)\n+\tr.write (\"    gcc_jit_field *field = NULL;\\n\");\n+      else\n+\tr.write (\"    gcc_jit_field *field = %s;\\n\",\n+\t\t r.get_identifier (m_fields[0]));\n+    }\n+  else\n+    {\n+      /* Write the array of values.  */\n+      if (m_values.length () == 0)\n+\tr.write (\"    gcc_jit_rvalue **values = NULL;\\n\");\n+      else\n+\t{\n+\t  r.write (\"    gcc_jit_rvalue *values[] = {\\n\");\n+\t  for (size_t i = 0; i < m_values.length (); i++)\n+\t    r.write (\"        %s,\\n\", r.get_identifier (m_values[i]));\n+\t  r.write (\"      };\\n\");\n+\t}\n+      /* Write the array of fields.  */\n+      if (m_fields.length () == 0)\n+\tr.write (\"    gcc_jit_field **fields = NULL;\\n\");\n+      else\n+\t{\n+\t  r.write (\"    gcc_jit_field *fields[] = {\\n\");\n+\t  for (size_t i = 0; i < m_fields.length (); i++)\n+\t    r.write (\"        %s,\\n\", r.get_identifier (m_fields[i]));\n+\t  r.write (\"      };\\n\");\n+\t}\n+    }\n+  if (type->is_array ())\n+    r.write (\n+\"    %s =\\n\"\n+\"      gcc_jit_context_new_array_constructor (%s,\\n\"\n+\"                                             %s, /* gcc_jit_location *loc */\\n\"\n+\"                                             %s, /* gcc_jit_type *type */\\n\"\n+\"                                             %i, /* int num_values */\\n\"\n+\"                                             values);\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier (m_loc),\n+\t   r.get_identifier_as_type (get_type ()),\n+\t   m_values.length ());\n+  else if (type->is_struct ())\n+    r.write (\n+\"    %s =\\n\"\n+\"      gcc_jit_context_new_struct_constructor (%s,\\n\"\n+\"                                              %s, /* loc */\\n\"\n+\"                                              %s, /* gcc_jit_type *type */\\n\"\n+\"                                              %i, /* int num_values */\\n\"\n+\"                                              fields,\\n\"\n+\"                                              values);\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier (m_loc),\n+\t   r.get_identifier_as_type (get_type ()),\n+\t   m_values.length ());\n+  else if (type->is_union ())\n+    r.write (\n+\"    %s =\\n\"\n+\"      gcc_jit_context_new_union_constructor (%s,\\n\"\n+\"                                             %s, /* loc */\\n\"\n+\"                                             %s, /* gcc_jit_type *type */\\n\"\n+\"                                             field,\\n\"\n+\"                                             value);\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier (m_loc),\n+\t   r.get_identifier_as_type (get_type ()));\n+  else\n+    gcc_unreachable ();\n+\n+  r.write (\"  }\\n\"); /* Close scope for locals.  */\n+}\n+\n+void\n+recording::ctor::replay_into (replayer *r)\n+{\n+  auto_vec<playback::rvalue *> playback_values;\n+  auto_vec<playback::field *> playback_fields;\n+\n+  int n = m_values.length ();\n+\n+  type *type = get_type ();\n+\n+  /* Handle arrays, and return.  */\n+  if (type->is_array ())\n+    {\n+      playback_values.reserve (n, false);\n+\n+      for (int i = 0; i < n; i++)\n+\t{\n+\t  /* null m_values element indicates zero ctor.  */\n+\t  playback_values.quick_push (m_values[i] ?\n+\t\t\t\t      m_values[i]->playback_rvalue () :\n+\t\t\t\t      NULL);\n+\t}\n+      set_playback_obj (r->new_ctor (playback_location (r, m_loc),\n+\t\t\t\t     get_type ()->playback_type (),\n+\t\t\t\t     NULL,\n+\t\t\t\t     &playback_values));\n+      return;\n+    }\n+  /* ... else handle unions and structs.  */\n+\n+  playback_values.reserve (n, false);\n+  playback_fields.reserve (n, false);\n+\n+  for (int i = 0; i < n; i++)\n+    {\n+      /* null m_values element indicates zero ctor.  */\n+      playback_values.quick_push (m_values[i] ?\n+\t\t\t\t    m_values[i]->playback_rvalue () :\n+\t\t\t\t    NULL);\n+      playback_fields.quick_push (m_fields[i]->playback_field ());\n+    }\n+\n+  set_playback_obj (r->new_ctor (playback_location (r, m_loc),\n+\t\t\t\t get_type ()->playback_type (),\n+\t\t\t\t &playback_fields,\n+\t\t\t\t &playback_values));\n+}\n+\n /* The implementation of class gcc::jit::recording::unary_op.  */\n \n /* Implementation of pure virtual hook recording::memento::replay_into\n@@ -7087,6 +7371,167 @@ recording::top_level_asm::write_reproducer (reproducer &r)\n \t   m_asm_stmts->get_debug_string ());\n }\n \n+void\n+recording::global_init_rvalue::replay_into (replayer *r)\n+{\n+  r->global_set_init_rvalue (m_variable->playback_lvalue (),\n+\t\t\t     m_init->playback_rvalue ());\n+}\n+\n+void\n+recording::global_init_rvalue::write_reproducer (reproducer &r)\n+{\n+  r.write (\n+    \"  gcc_jit_global_set_initializer_rvalue (%s, /* lvalue *global */\\n\"\n+    \"                                         %s);/* rvalue *init */\\n\",\n+    r.get_identifier (m_variable),\n+    r.get_identifier_as_rvalue (m_init));\n+}\n+\n+void\n+recording::global_init_rvalue::write_to_dump (dump &d)\n+{\n+  d.write (\"%s;\\n\", get_debug_string ());\n+}\n+\n+recording::string *\n+recording::global_init_rvalue::make_debug_string ()\n+{\n+    return string::from_printf (m_ctxt, \"%s = %s\",\n+      m_variable->get_debug_string (),\n+      m_init->get_debug_string ());\n+}\n+\n+enum strip_flags {\n+  STRIP_FLAG_NONE,\n+  STRIP_FLAG_ARR,\n+  STRIP_FLAG_VEC\n+};\n+\n+/* Strips type down to array, vector or base type (whichever comes first)\n+\n+   Also saves 'ptr_depth' and sets 'flags' for array or vector types.  */\n+static\n+recording::type *\n+strip_and_count (recording::type *type_to_strip,\n+\t\t int &ptr_depth,\n+\t\t strip_flags &flags)\n+{\n+  recording::type *t = type_to_strip;\n+\n+  while (true)\n+    {\n+      if (!t)\n+\tgcc_unreachable (); /* Should only happen on corrupt input.  */\n+\n+      recording::type *pointed_to_type = t->is_pointer ();\n+      if (pointed_to_type != NULL)\n+\t{\n+\t  ptr_depth++;\n+\t  t = pointed_to_type;\n+\t  continue;\n+\t}\n+\n+      recording::type *array_el = t->is_array ();\n+      if (array_el != NULL)\n+\t{\n+\t  flags = STRIP_FLAG_ARR;\n+\t  break;\n+\t}\n+\n+      recording::type *vec = t->dyn_cast_vector_type ();\n+      if (vec != NULL)\n+\t{\n+\t  flags = STRIP_FLAG_VEC;\n+\t  break;\n+\t}\n+\n+      /* unqualified () returns 'this' on base types.  */\n+      recording::type *next = t->unqualified ();\n+      if (next == t)\n+\t{\n+\t  break;\n+\t}\n+      t = next;\n+    }\n+\n+  return t;\n+}\n+\n+/* Strip qualifiers and count pointer depth, returning true\n+   if the types' base type and pointer depth are\n+   the same, otherwise false.\n+\n+   For array and vector types the number of element also\n+   has to match.\n+\n+   Do not call this directly.  Call 'types_kinda_same'.  */\n+bool\n+types_kinda_same_internal (recording::type *a, recording::type *b)\n+{\n+  int ptr_depth_a = 0;\n+  int ptr_depth_b = 0;\n+  recording::type *base_a;\n+  recording::type *base_b;\n+\n+  strip_flags flags_a = STRIP_FLAG_NONE;\n+  strip_flags flags_b = STRIP_FLAG_NONE;\n+\n+  base_a = strip_and_count (a, ptr_depth_a, flags_a);\n+  base_b = strip_and_count (b, ptr_depth_b, flags_b);\n+\n+  if (ptr_depth_a != ptr_depth_b)\n+    return false;\n+\n+  if (base_a == base_b)\n+    return true;\n+\n+  if (flags_a != flags_b)\n+    return false;\n+\n+  /* If the \"base type\" is an array or vector we might need to\n+     check deeper.  */\n+  if (flags_a == STRIP_FLAG_ARR)\n+    {\n+      recording::array_type *arr_a =\n+\tstatic_cast<recording::array_type*> (base_a);\n+      recording::array_type *arr_b =\n+\tstatic_cast<recording::array_type*> (base_b);\n+\n+      if (arr_a->num_elements () != arr_b->num_elements ())\n+\treturn false;\n+\n+      /* is_array returns element type.  */\n+      recording::type *el_a = arr_a->is_array ();\n+      recording::type *el_b = arr_b->is_array ();\n+\n+      if (el_a == el_b)\n+\treturn true;\n+\n+      return types_kinda_same_internal (el_a, el_b);\n+    }\n+  if (flags_a == STRIP_FLAG_VEC)\n+    {\n+      recording::vector_type *arr_a =\n+\tstatic_cast<recording::vector_type*> (base_a);\n+      recording::vector_type *arr_b =\n+\tstatic_cast<recording::vector_type*> (base_b);\n+\n+      if (arr_a->get_num_units () != arr_b->get_num_units ())\n+\treturn false;\n+\n+      recording::type *el_a = arr_a->get_element_type ();\n+      recording::type *el_b = arr_b->get_element_type ();\n+\n+      if (el_a == el_b)\n+\treturn true;\n+\n+      return types_kinda_same_internal (el_a, el_b);\n+    }\n+\n+  return false;\n+}\n+\n } // namespace gcc::jit\n \n } // namespace gcc"}, {"sha": "e9760c47ad0af1a10220ff3d3efc673d16d513a3", "filename": "gcc/jit/jit-recording.h", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -149,6 +149,17 @@ class context : public log_user\n \t      type *type,\n \t      const char *name);\n \n+  rvalue *\n+  new_ctor (location *loc,\n+\t    type *type,\n+\t    size_t num_values,\n+\t    field **fields,\n+\t    rvalue **values);\n+\n+  void\n+  new_global_init_rvalue (lvalue *variable,\n+\t\t\t  rvalue *init);\n+\n   template <typename HOST_TYPE>\n   rvalue *\n   new_rvalue_from_const (type *type,\n@@ -549,6 +560,7 @@ class type : public memento\n   virtual type *is_const () { return NULL; }\n   virtual type *is_array () = 0;\n   virtual struct_ *is_struct () { return NULL; }\n+  virtual bool is_union () const { return false; }\n   virtual bool is_void () const { return false; }\n   virtual vector_type *is_vector () { return NULL; }\n   virtual bool has_known_size () const { return true; }\n@@ -1016,6 +1028,8 @@ class union_ : public compound_type\n \n   void replay_into (replayer *r) FINAL OVERRIDE;\n \n+  virtual bool is_union () const FINAL OVERRIDE { return true; }\n+\n private:\n   string * make_debug_string () FINAL OVERRIDE;\n   void write_reproducer (reproducer &r) FINAL OVERRIDE;\n@@ -1421,6 +1435,23 @@ class global : public lvalue\n     m_initializer_num_bytes = num_bytes;\n   }\n \n+  void set_flags (int flag_fields)\n+  {\n+    m_flags = (enum global_var_flags)(m_flags | flag_fields);\n+  }\n+  /* Returns true if any of the flags in the argument is set.  */\n+  bool test_flags_anyof (int flag_fields) const\n+  {\n+    return m_flags & flag_fields;\n+  }\n+\n+  enum gcc_jit_global_kind get_kind () const\n+  {\n+    return m_kind;\n+  }\n+\n+  void set_rvalue_init (rvalue *val) { m_rvalue_init = val; }\n+\n private:\n   string * make_debug_string () FINAL OVERRIDE { return m_name; }\n   template <typename T>\n@@ -1433,8 +1464,10 @@ class global : public lvalue\n \n private:\n   enum gcc_jit_global_kind m_kind;\n+  enum global_var_flags m_flags = GLOBAL_VAR_FLAGS_NONE;\n   string *m_name;\n   void *m_initializer;\n+  rvalue *m_rvalue_init = nullptr; /* Only needed for write_dump.  */\n   size_t m_initializer_num_bytes;\n };\n \n@@ -1519,6 +1552,32 @@ class memento_of_new_rvalue_from_vector : public rvalue\n   auto_vec<rvalue *> m_elements;\n };\n \n+class ctor : public rvalue\n+{\n+public:\n+  ctor (context *ctxt,\n+\tlocation *loc,\n+\ttype *type)\n+  : rvalue (ctxt, loc, type)\n+  { }\n+\n+  void replay_into (replayer *r) FINAL OVERRIDE;\n+\n+  void visit_children (rvalue_visitor *) FINAL OVERRIDE;\n+\n+private:\n+  string * make_debug_string () FINAL OVERRIDE;\n+  void write_reproducer (reproducer &r) FINAL OVERRIDE;\n+  enum precedence get_precedence () const FINAL OVERRIDE\n+  {\n+    return PRECEDENCE_PRIMARY;\n+  }\n+\n+public:\n+  auto_vec<field *> m_fields;\n+  auto_vec<rvalue *> m_values;\n+};\n+\n class unary_op : public rvalue\n {\n public:\n@@ -2362,6 +2421,24 @@ class top_level_asm : public memento\n   string *m_asm_stmts;\n };\n \n+class global_init_rvalue : public memento\n+{\n+public:\n+  global_init_rvalue (context *ctxt, lvalue *variable, rvalue *init) :\n+    memento (ctxt), m_variable (variable), m_init (init) {};\n+\n+  void write_to_dump (dump &d) FINAL OVERRIDE;\n+\n+private:\n+  void replay_into (replayer *r) FINAL OVERRIDE;\n+  string * make_debug_string () FINAL OVERRIDE;\n+  void write_reproducer (reproducer &r) FINAL OVERRIDE;\n+\n+private:\n+  lvalue *m_variable;\n+  rvalue *m_init;\n+};\n+\n } // namespace gcc::jit::recording\n \n /* Create a recording::memento_of_new_rvalue_from_const instance and add\n@@ -2381,6 +2458,23 @@ recording::context::new_rvalue_from_const (recording::type *type,\n   return result;\n }\n \n+/* Don't call this directly.  Call types_kinda_same.  */\n+bool\n+types_kinda_same_internal (recording::type *a,\n+\t\t\t   recording::type *b);\n+\n+/* Strip all qualifiers and count pointer depth, returning true\n+   if the types and pointer depth are the same, otherwise false.\n+\n+   For array and vector types the number of element also\n+   has to match, aswell as the element types themself.  */\n+static inline bool\n+types_kinda_same (recording::type *a, recording::type *b)\n+{\n+  /* Handle trivial case here, to allow for inlining.  */\n+  return a == b || types_kinda_same_internal (a, b);\n+}\n+\n } // namespace gcc::jit\n \n } // namespace gcc"}, {"sha": "25414620afb249a3fcbcfda5343740e474d608cf", "filename": "gcc/jit/libgccjit++.h", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Flibgccjit%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Flibgccjit%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit%2B%2B.h?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -197,6 +197,20 @@ namespace gccjit\n     rvalue new_rvalue (type vector_type,\n \t\t       std::vector<rvalue> elements) const;\n \n+    rvalue new_struct_ctor (type type_,\n+\t\t\t    std::vector<field> &fields,\n+\t\t\t    std::vector<rvalue> &values,\n+\t\t\t    location loc = location ());\n+\n+    rvalue new_array_ctor (type type_,\n+\t\t\t   std::vector<rvalue> &values,\n+\t\t\t   location loc = location ());\n+\n+    rvalue new_union_ctor (type type_,\n+\t\t\t   field field,\n+\t\t\t   rvalue value,\n+\t\t\t   location loc = location ());\n+\n     /* Generic unary operations...  */\n     rvalue new_unary_op (enum gcc_jit_unary_op op,\n \t\t\t type result_type,\n@@ -500,6 +514,7 @@ namespace gccjit\n \n     rvalue get_address (location loc = location ());\n     lvalue set_initializer (const void *blob, size_t num_bytes);\n+    lvalue set_initializer_rvalue (rvalue init_value);\n   };\n \n   class param : public lvalue\n@@ -1831,6 +1846,81 @@ lvalue::set_initializer (const void *blob, size_t num_bytes)\n   return *this;\n }\n \n+inline lvalue\n+lvalue::set_initializer_rvalue (rvalue init_value)\n+{\n+  return lvalue (gcc_jit_global_set_initializer_rvalue (\n+\t\t   get_inner_lvalue (),\n+\t\t   init_value.get_inner_rvalue ()));\n+}\n+\n+inline rvalue\n+context::new_struct_ctor (type type_,\n+\t\t\t  std::vector<field> &fields,\n+\t\t\t  std::vector<rvalue> &values,\n+\t\t\t  location loc)\n+{\n+  field *pfields = nullptr;\n+  if (fields.size ())\n+    pfields = &fields[0];\n+\n+  gcc_jit_field **fields_arr =\n+    reinterpret_cast<gcc_jit_field **> (pfields);\n+\n+  rvalue *pvalues = nullptr;\n+  if (values.size ())\n+    pvalues = &values[0];\n+\n+  gcc_jit_rvalue **values_arr =\n+    reinterpret_cast<gcc_jit_rvalue **> (pvalues);\n+\n+  return rvalue (\n+\t   gcc_jit_context_new_struct_constructor (\n+\t     m_inner_ctxt,\n+\t     loc.get_inner_location (),\n+\t     type_.get_inner_type (),\n+\t     (int)values.size (),\n+\t     fields_arr,\n+\t     values_arr));\n+}\n+\n+inline rvalue\n+context::new_array_ctor (type type_,\n+\t\t\t std::vector<rvalue> &values,\n+\t\t\t location loc)\n+{\n+  rvalue *pvalues = nullptr;\n+  if (values.size ())\n+    pvalues = &values[0];\n+\n+  gcc_jit_rvalue **values_arr =\n+    reinterpret_cast<gcc_jit_rvalue **> (pvalues);\n+\n+  return rvalue (\n+\t   gcc_jit_context_new_array_constructor (\n+\t     m_inner_ctxt,\n+\t     loc.get_inner_location (),\n+\t     type_.get_inner_type (),\n+\t     (int)values.size (),\n+\t     values_arr));\n+}\n+\n+inline rvalue\n+context::new_union_ctor (type type_,\n+\t\t\t field field,\n+\t\t\t rvalue value,\n+\t\t\t location loc)\n+{\n+  return rvalue (\n+\t   gcc_jit_context_new_union_constructor (\n+\t     m_inner_ctxt,\n+\t     loc.get_inner_location (),\n+\t     type_.get_inner_type (),\n+\t     field.get_inner_field (),\n+\t     value.get_inner_rvalue ()));\n+}\n+\n+\n // class param : public lvalue\n inline param::param () : lvalue () {}\n inline param::param (gcc_jit_param *inner)"}, {"sha": "5cb27a20d4180624338be26181895b88cb5943e9", "filename": "gcc/jit/libgccjit.c", "status": "modified", "additions": 403, "deletions": 2, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Flibgccjit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Flibgccjit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.c?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -1386,6 +1386,393 @@ gcc_jit_context_new_global (gcc_jit_context *ctxt,\n   return (gcc_jit_lvalue *)ctxt->new_global (loc, kind, type, name);\n }\n \n+extern gcc_jit_rvalue *\n+gcc_jit_context_new_struct_constructor (gcc_jit_context *ctxt,\n+\t\t\t\t\tgcc_jit_location *loc,\n+\t\t\t\t\tgcc_jit_type *type,\n+\t\t\t\t\tsize_t num_values,\n+\t\t\t\t\tgcc_jit_field **fields,\n+\t\t\t\t\tgcc_jit_rvalue **values)\n+{\n+  using namespace gcc::jit::recording;\n+\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  RETURN_NULL_IF_FAIL (type, ctxt, loc, \"NULL type\");\n+\n+  RETURN_NULL_IF_FAIL_PRINTF1 (type->is_struct (),\n+\t\t\t       ctxt, loc,\n+\t\t\t       \"constructor type is not a struct: %s\",\n+\t\t\t       type->get_debug_string ());\n+\n+  compound_type *ct = reinterpret_cast<compound_type *>(type);\n+  gcc::jit::recording::fields *fields_struct = ct->get_fields ();\n+  size_t n_fields = fields_struct->length ();\n+\n+  RETURN_NULL_IF_FAIL_PRINTF1 (ct->has_known_size (),\n+\t\t\t       ctxt, loc,\n+\t\t\t       \"struct can't be opaque: %s\",\n+\t\t\t       type->get_debug_string ());\n+  RETURN_NULL_IF_FAIL_PRINTF1 (n_fields,\n+\t\t\t       ctxt, loc,\n+\t\t\t       \"no fields in struct: %s\",\n+\t\t\t       type->get_debug_string ());\n+\n+  /* If there is no array input we just short circuit to zero the struct.  */\n+  if (!num_values)\n+    return (gcc_jit_rvalue *)ctxt->new_ctor (loc, type, 0, NULL, NULL);\n+\n+  RETURN_NULL_IF_FAIL_PRINTF3 (n_fields >= num_values,\n+\t\t\t       ctxt, loc,\n+\t\t\t       \"more values in constructor (n=%zu) than fields\"\n+\t\t\t       \" in target %s (n=%zu)\",\n+\t\t\t       num_values,\n+\t\t\t       type->get_debug_string (),\n+\t\t\t       n_fields);\n+\n+  /* It is OK if fields are null here, indicating definiton order,\n+     but there has to be a values array.  */\n+  RETURN_NULL_IF_FAIL (values,\n+\t\t       ctxt, loc,\n+\t\t       \"'values' NULL with non-zero 'num_values'\");\n+\n+  size_t idx = 0; /* Runner index for fields in the type object.  */\n+\n+  for (size_t i = 0; i < num_values; i++)\n+    {\n+      gcc::jit::recording::rvalue *rv = values[i];\n+\n+      /* rv kan be NULL, which would indicate zero init for the field.  */\n+      gcc::jit::recording::type *rv_type = rv ? rv->get_type () : nullptr;\n+\n+      /* If fields are specified we need to check that they are in\n+\t definition order.  */\n+      if (fields)\n+\t{\n+\t  gcc::jit::recording::field *f = fields[i];\n+\n+\t  RETURN_NULL_IF_FAIL_PRINTF1 (\n+\t    f,\n+\t    ctxt, loc,\n+\t    \"NULL field in 'fields', at index %zu\", i);\n+\n+\t  RETURN_NULL_IF_FAIL_PRINTF3 (\n+\t    f->get_container () ==\n+\t    static_cast<gcc::jit::recording::type*>(type),\n+\t    ctxt, loc,\n+\t    \"field object at index %zu (%s), was not used when creating \"\n+\t    \"the %s\",\n+\t    i,\n+\t    f->get_debug_string (),\n+\t    type->get_debug_string ());\n+\n+\t  /* Fields in the constructor need to be in struct definition\n+\t     order, but there can be gaps.  */\n+\t  size_t j;\n+\t  for (j = idx; j < n_fields; j++)\n+\t    {\n+\t      field *fs = fields_struct->get_field (j);\n+\t      if (fs == f)\n+\t\t{\n+\t\t  idx = j; /* Advance runner index for next iteration.  */\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  RETURN_NULL_IF_FAIL_PRINTF3 (\n+\t    j != n_fields,\n+\t    ctxt, loc,\n+\t    \"field at index %zu in 'fields' is not in definition order \"\n+\t    \"(struct: %s) (ctor field: %s)\",\n+\t    i,\n+\t    type->get_debug_string (),\n+\t    f->get_debug_string ());\n+\n+\t  /* Check that the specified field has the same type as the\n+\t     value, unless the value is null (a zero value init).  */\n+\t  RETURN_NULL_IF_FAIL_PRINTF5 (\n+\t    !rv || gcc::jit::types_kinda_same (rv_type,\n+\t\t\t\t\t       f->get_type ()),\n+\t    ctxt, loc,\n+\t    \"value and field not the same unqualified type, at index %zu\"\n+\t    \" (%s.%s: %s)(value type: %s)\",\n+\t    i,\n+\t    type->get_debug_string (),\n+\t    f->get_debug_string (),\n+\t    f->get_type ()->get_debug_string (),\n+\t    rv_type->get_debug_string ());\n+\t}\n+\n+      /* If no fields are specified, check that the value has the same type\n+\t as the field in the definition of the struct.  */\n+      if (rv && !fields)\n+\t{\n+\t  RETURN_NULL_IF_FAIL_PRINTF5 (\n+\t    gcc::jit::types_kinda_same (rv_type,\n+\t\t\t\t\tfields_struct->\n+\t\t\t\t\t  get_field (i)->get_type ()),\n+\t    ctxt, loc,\n+\t    \"value and field not the same unqualified type, at index %zu\"\n+\t    \" (%s.%s: %s)(value type: %s)\",\n+\t    i,\n+\t    type->get_debug_string (),\n+\t    fields_struct->get_field (i)->get_debug_string (),\n+\t    fields_struct->get_field (i)->get_type ()->get_debug_string (),\n+\t    rv_type->get_debug_string ());\n+\t}\n+\n+      if (rv)\n+\t{\n+\t  RETURN_NULL_IF_FAIL_PRINTF1 (\n+\t    !rv_type->is_void (),\n+\t    ctxt, loc,\n+\t    \"can't construct the void type, at index %zu\", i);\n+\t}\n+    }\n+\n+  return (gcc_jit_rvalue *)ctxt->new_ctor (\n+    loc,\n+    type,\n+    num_values,\n+    reinterpret_cast<gcc::jit::recording::field**>(fields),\n+    reinterpret_cast<gcc::jit::recording::rvalue**>(values));\n+}\n+\n+extern gcc_jit_rvalue *\n+gcc_jit_context_new_union_constructor (gcc_jit_context *ctxt,\n+\t\t\t\t       gcc_jit_location *loc,\n+\t\t\t\t       gcc_jit_type *type,\n+\t\t\t\t       gcc_jit_field *field,\n+\t\t\t\t       gcc_jit_rvalue *value)\n+{\n+  using namespace gcc::jit::recording;\n+\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  RETURN_NULL_IF_FAIL (type, ctxt, loc, \"NULL type\");\n+\n+  RETURN_NULL_IF_FAIL_PRINTF1 (type->is_union (),\n+\t\t\t       ctxt, loc,\n+\t\t\t       \"constructor type is not an union: %s\",\n+\t\t\t       type->get_debug_string ());\n+\n+  compound_type *ct = reinterpret_cast<compound_type *>(type);\n+  gcc::jit::recording::fields *fields_union = ct->get_fields ();\n+  size_t n_fields = fields_union->length ();\n+\n+  RETURN_NULL_IF_FAIL_PRINTF1 (ct->has_known_size (),\n+\t\t\t       ctxt, loc,\n+\t\t\t       \"union can't be opaque: %s\",\n+\t\t\t       type->get_debug_string ());\n+  RETURN_NULL_IF_FAIL_PRINTF1 (n_fields,\n+\t\t\t       ctxt, loc,\n+\t\t\t       \"no fields in union: %s\",\n+\t\t\t       type->get_debug_string ());\n+\n+  /* If value is NULL we are just supposed to zero the whole union.  */\n+  if (!value)\n+    return (gcc_jit_rvalue *)ctxt->new_ctor (loc, type, 0, NULL, NULL);\n+\n+  gcc::jit::recording::type *rv_type = value->get_type ();\n+\n+  RETURN_NULL_IF_FAIL (\n+    !rv_type->is_void (),\n+    ctxt, loc,\n+    \"can't construct the void type\");\n+\n+  if (field)\n+    {\n+      RETURN_NULL_IF_FAIL_PRINTF2 (\n+\tfield->get_container () ==\n+\tstatic_cast<gcc::jit::recording::type*>(type),\n+\tctxt, loc,\n+\t\"field object (%s) was not used when creating \"\n+\t\"the type %s\",\n+\tfield->get_debug_string (),\n+\ttype->get_debug_string ());\n+\n+      RETURN_NULL_IF_FAIL_PRINTF4 (\n+\tgcc::jit::types_kinda_same (rv_type,\n+\t\t\t\t    field->get_type ()),\n+\tctxt, loc,\n+\t\"value and field are not the same unqualified type\"\n+\t\" (%s.%s: %s)(value type: %s)\",\n+\ttype->get_debug_string (),\n+\tfield->get_debug_string (),\n+\tfield->get_type ()->get_debug_string (),\n+\trv_type->get_debug_string ());\n+    }\n+  /* If no field is specified, check that the value has the same type\n+     as the first field in the definition of the union.  */\n+  if (!field)\n+    RETURN_NULL_IF_FAIL_PRINTF2 (\n+      gcc::jit::types_kinda_same (rv_type,\n+\t\t\t\t  fields_union->\n+\t\t\t\t    get_field (0)->get_type ()),\n+      ctxt, loc,\n+      \"value and first union field not the same unqualified type\"\n+      \" (field type: %s)(value type: %s)\",\n+      fields_union->get_field (0)->get_type ()->get_debug_string (),\n+      rv_type->get_debug_string ());\n+\n+\n+  return (gcc_jit_rvalue *)ctxt->new_ctor (\n+    loc,\n+    type,\n+    1,\n+    /* A NULL fields array tells new_ctor to take fields from the type obj.  */\n+    reinterpret_cast<gcc::jit::recording::field**>(field ? &field : NULL),\n+    reinterpret_cast<gcc::jit::recording::rvalue**>(&value));\n+}\n+\n+extern gcc_jit_rvalue *\n+gcc_jit_context_new_array_constructor (gcc_jit_context *ctxt,\n+\t\t\t\t       gcc_jit_location *loc,\n+\t\t\t\t       gcc_jit_type *type,\n+\t\t\t\t       size_t num_values,\n+\t\t\t\t       gcc_jit_rvalue **values)\n+{\n+  using namespace gcc::jit::recording;\n+\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, loc, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  RETURN_NULL_IF_FAIL (type, ctxt, loc, \"NULL type\");\n+\n+  RETURN_NULL_IF_FAIL (type->is_array () != NULL,\n+\t\t       ctxt, loc,\n+\t\t       \"constructor type not an array\");\n+\n+  if (!num_values)\n+    values = NULL;\n+\n+  if (num_values)\n+    {\n+      RETURN_NULL_IF_FAIL (\n+\tvalues,\n+\tctxt, loc,\n+\t\"'values' NULL with non-zero 'num_values'\");\n+\n+      gcc::jit::recording::array_type *arr_type =\n+\treinterpret_cast<gcc::jit::recording::array_type*>(type);\n+      size_t n_el = arr_type->num_elements ();\n+\n+      RETURN_NULL_IF_FAIL_PRINTF2 (\n+\tn_el >= num_values,\n+\tctxt, loc,\n+\t\"array constructor has more values than the array type's length\"\n+\t\" (array type length: %zu, constructor length: %zu)\",\n+\tn_el,\n+\tnum_values);\n+\n+      /* For arrays, all values need to be the same base type.  */\n+      gcc::jit::recording::type *type0 = NULL;\n+      size_t i = 0;\n+      /* Find first non-null value.  */\n+      for (;i < num_values; i++)\n+\t{\n+\t  if (values[i])\n+\t    break;\n+\t}\n+\n+      if (i < num_values) /* All values might be null and i == num_values.  */\n+\ttype0 = values[i]->get_type ();\n+\n+      /* If we got a type0, check that all other values have\n+\t the same type.  */\n+      for (; i < num_values; i++)\n+\t{\n+\t  if (values[i])\n+\t    RETURN_NULL_IF_FAIL_PRINTF3 (\n+\t      gcc::jit::types_kinda_same (type0,\n+\t\t\t\t\t  values[i]->get_type ()),\n+\t      ctxt, loc,\n+\t      \"value type at index %zu differ from first value type\"\n+\t      \" (first type: %s)(different type: %s)\",\n+\t      i,\n+\t      type0->get_debug_string (),\n+\t      values[i]->get_type ()->get_debug_string ());\n+\t}\n+\n+      /* Compare type0 with the element type specified in the\n+\t type of the array.  */\n+      if (type0)\n+\t{\n+\t  gcc::jit::recording::type *el_type =\n+\t    type->is_array ();\n+\n+\t  RETURN_NULL_IF_FAIL_PRINTF2 (\n+\t    gcc::jit::types_kinda_same (type0, el_type),\n+\t    ctxt, loc,\n+\t    \"array element value types differ from types in 'values'\"\n+\t    \" (element type: %s)('values' type: %s)\",\n+\t    el_type->get_debug_string (),\n+\t    type0->get_debug_string ());\n+\t}\n+    }\n+\n+  return (gcc_jit_rvalue *)ctxt->new_ctor (\n+    loc,\n+    type,\n+    num_values,\n+    NULL,\n+    reinterpret_cast<gcc::jit::recording::rvalue**>(values));\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.  */\n+\n+extern gcc_jit_lvalue *\n+gcc_jit_global_set_initializer_rvalue (gcc_jit_lvalue *global,\n+\t\t\t\t       gcc_jit_rvalue *init_rvalue)\n+{\n+  RETURN_NULL_IF_FAIL (global, NULL, NULL,\"NULL global\");\n+\n+  gcc::jit::recording::context *ctxt = global->get_context ();\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL,\"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  RETURN_NULL_IF_FAIL (init_rvalue, ctxt, NULL,\"NULL init_rvalue\");\n+\n+  RETURN_NULL_IF_FAIL_PRINTF1 (global->is_global (),\n+\t\t\t       ctxt, NULL,\n+\t\t\t       \"lvalue \\\"%s\\\" not a global\",\n+\t\t\t       global->get_debug_string ());\n+\n+  gcc::jit::recording::global *gbl =\n+    reinterpret_cast<gcc::jit::recording::global *> (global);\n+\n+  RETURN_NULL_IF_FAIL_PRINTF1 (gbl->get_kind () !=\n+\t\t\t       GCC_JIT_GLOBAL_IMPORTED,\n+\t\t\t       ctxt, NULL,\n+\t\t\t       \"can't initialize \\\"%s\\\", it is imported\",\n+\t\t\t       global->get_debug_string ());\n+\n+  RETURN_NULL_IF_FAIL_PRINTF4 (gcc::jit::types_kinda_same (\n+\t\t\t\t global->get_type (),\n+\t\t\t\t init_rvalue->get_type ()),\n+\t\t\t       ctxt, NULL,\n+\t\t\t       \"mismatching types:\"\n+\t\t\t       \" initializing %s (type: %s) with %s (type: %s)\",\n+\t\t\t       global->get_debug_string (),\n+\t\t\t       global->get_type ()->get_debug_string (),\n+\t\t\t       init_rvalue->get_debug_string (),\n+\t\t\t       init_rvalue->get_type ()->get_debug_string ());\n+\n+  /* Check that there are no initializers set for the global yet.  */\n+  RETURN_NULL_IF_FAIL_PRINTF1 (!gbl->test_flags_anyof (\n+\t\t\t\t  gcc::jit::GLOBAL_VAR_FLAGS_WILL_BE_RVAL_INIT |\n+\t\t\t\t  gcc::jit::GLOBAL_VAR_FLAGS_WILL_BE_BLOB_INIT),\n+\t\t\t       ctxt, NULL,\n+\t\t\t       \"global variable already initialized: %s\",\n+\t\t\t       global->get_debug_string ());\n+\n+  /* The global need to know during playback that it will be\n+     initialized.  */\n+  gbl->set_flags (gcc::jit::GLOBAL_VAR_FLAGS_WILL_BE_RVAL_INIT);\n+\n+  ctxt->new_global_init_rvalue (global, init_rvalue);\n+\n+  return global;\n+}\n+\n /* Public entrypoint.  See description in libgccjit.h.\n \n    After error-checking, the real work is done by the\n@@ -1419,8 +1806,22 @@ gcc_jit_global_set_initializer (gcc_jit_lvalue *global,\n     \" global \\\"%s\\\" has size %zu whereas initializer has size %zu\",\n     global->get_debug_string (), lvalue_size, num_bytes);\n \n-  reinterpret_cast <gcc::jit::recording::global *> (global)\n-    ->set_initializer (blob, num_bytes);\n+  /* Check that the rvalue initializer is not set for this global.\n+     Note that we do not check if this blob type initializer is\n+     already set, since that check was not present when the entrypoint\n+     was initially written.  */\n+  gcc::jit::recording::global *gbl =\n+    reinterpret_cast<gcc::jit::recording::global *> (global);\n+  RETURN_NULL_IF_FAIL_PRINTF1 (!gbl->test_flags_anyof (\n+\t\t\t\t  gcc::jit::GLOBAL_VAR_FLAGS_WILL_BE_RVAL_INIT),\n+\t\t\t       NULL, NULL,\n+\t\t\t       \"global variable already initialized: %s\",\n+\t\t\t       global->get_debug_string ());\n+\n+  gbl->set_initializer (blob, num_bytes);\n+  /* The global need to know during playback that it will be\n+     initialized.  */\n+  gbl->set_flags (gcc::jit::GLOBAL_VAR_FLAGS_WILL_BE_BLOB_INIT);\n \n   return global;\n }"}, {"sha": "80a915fb8c426611f483aea41939aeefe467da25", "filename": "gcc/jit/libgccjit.h", "status": "modified", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Flibgccjit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Flibgccjit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.h?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -822,6 +822,159 @@ gcc_jit_context_new_global (gcc_jit_context *ctxt,\n \t\t\t    gcc_jit_type *type,\n \t\t\t    const char *name);\n \n+#define LIBGCCJIT_HAVE_CTORS\n+\n+/* Create a constructor for a struct as an rvalue.\n+\n+   Returns NULL on error.  The two parameter arrays are copied and\n+   do not have to outlive the context.\n+\n+   `type` specifies what the constructor will build and has to be\n+   a struct.\n+\n+   `num_values` specifies the number of elements in `values`.\n+\n+   `fields` need to have the same length as `values`, or be NULL.\n+\n+   If `fields` is null, the values are applied in definition order.\n+\n+   Otherwise, each field in `fields` specifies which field in the struct to\n+   set to the corresponding value in `values`.  `fields` and `values`\n+   are paired by index.\n+\n+   Each value has to have have the same unqualified type as the field\n+   it is applied to.\n+\n+   A NULL value element  in `values` is a shorthand for zero initialization\n+   of the corresponding field.\n+\n+   The fields in `fields` have to be in definition order, but there\n+   can be gaps.  Any field in the struct that is not specified in\n+   `fields` will be zeroed.\n+\n+   The fields in `fields` need to be the same objects that were used\n+   to create the struct.\n+\n+   If `num_values` is 0, the array parameters will be\n+   ignored and zero initialization will be used.\n+\n+   The constructor rvalue can be used for assignment to locals.\n+   It can be used to initialize global variables with\n+   gcc_jit_global_set_initializer_rvalue.  It can also be used as a\n+   temporary value for function calls and return values.\n+\n+   The constructor can contain nested constructors.\n+\n+   This entrypoint was added in LIBGCCJIT_ABI_19; you can test for its\n+   presence using:\n+   #ifdef LIBGCCJIT_HAVE_CTORS\n+*/\n+\n+extern gcc_jit_rvalue *\n+gcc_jit_context_new_struct_constructor (gcc_jit_context *ctxt,\n+\t\t\t\t\tgcc_jit_location *loc,\n+\t\t\t\t\tgcc_jit_type *type,\n+\t\t\t\t\tsize_t num_values,\n+\t\t\t\t\tgcc_jit_field **fields,\n+\t\t\t\t\tgcc_jit_rvalue **values);\n+\n+/* Create a constructor for a union as an rvalue.\n+\n+   Returns NULL on error.\n+\n+   `type` specifies what the constructor will build and has to be\n+   an union.\n+\n+   `field` specifies which field to set.  If it is NULL, the first\n+   field in the union will be set.  `field` need to be the same\n+   object that were used to create the union.\n+\n+   `value` specifies what value to set the corresponding field to.\n+   If `value` is NULL, zero initialization will be used.\n+\n+   Each value has to have have the same unqualified type as the field\n+   it is applied to.\n+\n+   `field` need to be the same objects that were used\n+   to create the union.\n+\n+   The constructor rvalue can be used for assignment to locals.\n+   It can be used to initialize global variables with\n+   gcc_jit_global_set_initializer_rvalue.  It can also be used as a\n+   temporary value for function calls and return values.\n+\n+   The constructor can contain nested constructors.\n+\n+   This entrypoint was added in LIBGCCJIT_ABI_19; you can test for its\n+   presence using:\n+   #ifdef LIBGCCJIT_HAVE_CTORS\n+*/\n+\n+extern gcc_jit_rvalue *\n+gcc_jit_context_new_union_constructor (gcc_jit_context *ctxt,\n+\t\t\t\t       gcc_jit_location *loc,\n+\t\t\t\t       gcc_jit_type *type,\n+\t\t\t\t       gcc_jit_field *field,\n+\t\t\t\t       gcc_jit_rvalue *value);\n+\n+/* Create a constructor for an array as an rvalue.\n+\n+   Returns NULL on error.  `values` are copied and\n+   do not have to outlive the context.\n+\n+   `type` specifies what the constructor will build and has to be\n+   an array.\n+\n+   `num_values` specifies the number of elements in `values` and\n+   it can't have more elements than the array type.\n+\n+   Each value in `values` sets the corresponding value in the array.\n+   If the array type itself has more elements than `values`, the\n+   left-over elements will be zeroed.\n+\n+   Each value in `values` need to be the same unqualified type as the\n+   array type's element type.\n+\n+   If `num_values` is 0, the `values` parameter will be\n+   ignored and zero initialization will be used.\n+\n+   Note that a string literal rvalue can't be used to construct a char\n+   array.  It needs one rvalue for each char.\n+\n+   This entrypoint was added in LIBGCCJIT_ABI_19; you can test for its\n+   presence using:\n+   #ifdef LIBGCCJIT_HAVE_CTORS\n+*/\n+\n+extern gcc_jit_rvalue *\n+gcc_jit_context_new_array_constructor (gcc_jit_context *ctxt,\n+\t\t\t\t       gcc_jit_location *loc,\n+\t\t\t\t       gcc_jit_type *type,\n+\t\t\t\t       size_t num_values,\n+\t\t\t\t       gcc_jit_rvalue **values);\n+\n+/* Set the initial value of a global of any type with an rvalue.\n+\n+   The rvalue needs to be a constant expression, e.g. no function calls.\n+\n+   The global can't have the 'kind' GCC_JIT_GLOBAL_IMPORTED.\n+\n+   Use together with gcc_jit_context_new_constructor () to\n+   initialize structs, unions and arrays.\n+\n+   On success, returns the 'global' parameter unchanged.  Otherwise, NULL.\n+\n+   'values' is copied and does not have to outlive the context.\n+\n+   This entrypoint was added in LIBGCCJIT_ABI_19; you can test for its\n+   presence using:\n+     #ifdef LIBGCCJIT_HAVE_CTORS\n+*/\n+\n+extern gcc_jit_lvalue *\n+gcc_jit_global_set_initializer_rvalue (gcc_jit_lvalue *global,\n+\t\t\t\t       gcc_jit_rvalue *init_value);\n+\n #define LIBGCCJIT_HAVE_gcc_jit_global_set_initializer\n \n /* Set an initial value for a global, which must be an array of"}, {"sha": "c0135e0dbd0d0f3f19843b7c998505d51abb9de6", "filename": "gcc/jit/libgccjit.map", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Flibgccjit.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Fjit%2Flibgccjit.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.map?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -236,3 +236,10 @@ LIBGCCJIT_ABI_18 {\n   global:\n     gcc_jit_lvalue_set_link_section;\n } LIBGCCJIT_ABI_17;\n+\n+LIBGCCJIT_ABI_19 {\n+    gcc_jit_context_new_array_constructor;\n+    gcc_jit_context_new_struct_constructor;\n+    gcc_jit_context_new_union_constructor;\n+    gcc_jit_global_set_initializer_rvalue;\n+} LIBGCCJIT_ABI_18;"}, {"sha": "29afe064db62a706f64bb7cffdbbd1c9c4a2b5db", "filename": "gcc/testsuite/jit.dg/all-non-failing-tests.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -181,6 +181,13 @@\n #undef create_code\n #undef verify_code\n \n+/* test-global-init-rvalue.c */\n+#define create_code create_code_global_init_rvalue\n+#define verify_code verify_code_global_init_rvalue\n+#include \"test-global-init-rvalue.c\"\n+#undef create_code\n+#undef verify_code\n+\n /* test-global-set-initializer.c */\n #define create_code create_code_global_set_initializer\n #define verify_code verify_code_global_set_initializer\n@@ -219,6 +226,13 @@\n #undef create_code\n #undef verify_code\n \n+/* test-local-init-rvalue.c */\n+#define create_code create_code_local_init_rvalue\n+#define verify_code verify_code_local_init_rvalue\n+#include \"test-local-init-rvalue.c\"\n+#undef create_code\n+#undef verify_code\n+\n /* test-long-names.c */\n #define create_code create_code_long_names\n #define verify_code verify_code_long_names\n@@ -431,12 +445,18 @@ const struct testcase testcases[] = {\n   {\"builtin-types\",\n    create_code_builtin_types,\n    verify_code_builtin_types},\n+  {\"global_rvalue_init\",\n+   create_code_global_init_rvalue,\n+   verify_code_global_init_rvalue},\n   {\"hello_world\",\n    create_code_hello_world,\n    verify_code_hello_world},\n   {\"linked_list\",\n    create_code_linked_list,\n    verify_code_linked_list},\n+  {\"local_rvalue_init\",\n+   create_code_local_init_rvalue,\n+   verify_code_local_init_rvalue},\n   {\"long_names\",\n    create_code_long_names,\n    verify_code_long_names},"}, {"sha": "6b54b8546fc4da400da9289320e7e0a628023c7e", "filename": "gcc/testsuite/jit.dg/test-error-ctor-array-wrong-obj.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-ctor-array-wrong-obj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-ctor-array-wrong-obj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-ctor-array-wrong-obj.c?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -0,0 +1,54 @@\n+/*\n+\n+  Test that the proper error is triggered when we build a ctor\n+  for an array type, but has the type wrong on an element.\n+\n+*/\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_type *int_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_INT);\n+  gcc_jit_type *float_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_FLOAT);\n+\n+  gcc_jit_type *arr_type =\n+    gcc_jit_context_new_array_type (ctxt, 0, int_type, 10);\n+\n+  gcc_jit_rvalue *frv = gcc_jit_context_new_rvalue_from_double (ctxt,\n+\t\t\t\t\t\t\t\tfloat_type,\n+\t\t\t\t\t\t\t\t12);\n+\n+  gcc_jit_rvalue *ctor = gcc_jit_context_new_array_constructor\n+    (ctxt, 0,\n+     arr_type,\n+     1,\n+     &frv);\n+\n+  CHECK_VALUE (ctor, NULL);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  /* Ensure that the bad API usage prevents the API giving a bogus\n+     result back.  */\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted. */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_context_new_array_constructor: array element \"\n+\t\t      \"value types differ from types in 'values' (element \"\n+\t\t      \"type: int)('values' type: float)\");\n+  CHECK_STRING_VALUE (gcc_jit_context_get_last_error (ctxt),\n+\t\t      \"gcc_jit_context_new_array_constructor: array element \"\n+\t\t      \"value types differ from types in 'values' (element \"\n+\t\t      \"type: int)('values' type: float)\");\n+}"}, {"sha": "6bc20459cd5487334120a7eac748f3e8ed6952f3", "filename": "gcc/testsuite/jit.dg/test-error-ctor-struct-too-big.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-ctor-struct-too-big.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-ctor-struct-too-big.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-ctor-struct-too-big.c?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -0,0 +1,71 @@\n+/*\n+\n+  Test that the proper error is triggered when we build a ctor\n+  for an struct type, but have too many fields and values.\n+\n+*/\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_type *int_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_INT);\n+\n+  gcc_jit_field *b1 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t int_type,\n+\t\t\t\t\t\t \"a\");\n+  gcc_jit_field *b2 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t int_type,\n+\t\t\t\t\t\t \"b\");\n+  gcc_jit_field *b3 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t int_type,\n+\t\t\t\t\t\t \"c\");\n+  gcc_jit_field *fields_b[] = {b1, b2, b3};\n+\n+  gcc_jit_type *struct_bar_type =\n+    gcc_jit_struct_as_type (\n+      gcc_jit_context_new_struct_type (ctxt,\n+\t\t\t\t       0,\n+\t\t\t\t       \"bar\",\n+\t\t\t\t       3,\n+\t\t\t\t       fields_b));\n+\n+  gcc_jit_field *fields_ctor[] = {b1, b2, b3, b3};\n+  gcc_jit_rvalue *values[] = {0,0,0,0};\n+\n+  gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+    (ctxt, 0,\n+     struct_bar_type,\n+     4,\n+     fields_ctor,\n+     values);\n+\n+  CHECK_VALUE (ctor, NULL);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  /* Ensure that the bad API usage prevents the API giving a bogus\n+     result back.  */\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted. */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_context_new_struct_constructor: more values in \"\n+\t\t      \"constructor (n=4) than fields in target struct \"\n+\t\t      \"bar (n=3)\");\n+  CHECK_STRING_VALUE (gcc_jit_context_get_last_error (ctxt),\n+\t\t      \"gcc_jit_context_new_struct_constructor: more values in \"\n+\t\t      \"constructor (n=4) than fields in target struct \"\n+\t\t      \"bar (n=3)\");\n+}"}, {"sha": "bc191e14d07447713e8144a6aeb44ec500e553ca", "filename": "gcc/testsuite/jit.dg/test-error-ctor-struct-wrong-field-obj.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-ctor-struct-wrong-field-obj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-ctor-struct-wrong-field-obj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-ctor-struct-wrong-field-obj.c?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -0,0 +1,86 @@\n+/*\n+\n+  Test that the proper error is triggered when we build a ctor\n+  for an struct type, but try to use a field object that was not\n+  used to create the struct type.\n+\n+*/\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_type *int_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_INT);\n+\n+  gcc_jit_field *b1 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t int_type,\n+\t\t\t\t\t\t \"a\");\n+  gcc_jit_field *b2 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t int_type,\n+\t\t\t\t\t\t \"b\");\n+  gcc_jit_field *b3 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t int_type,\n+\t\t\t\t\t\t \"c\");\n+  gcc_jit_field *b4 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t int_type,\n+\t\t\t\t\t\t \"d\");\n+  gcc_jit_field *b5 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t int_type,\n+\t\t\t\t\t\t \"d\");\n+  gcc_jit_field *fields_b[] = {b1, b2, b3, b4, b5};\n+\n+  gcc_jit_type *struct_bar_type =\n+    gcc_jit_struct_as_type (\n+      gcc_jit_context_new_struct_type (ctxt,\n+\t\t\t\t       0,\n+\t\t\t\t       \"bar\",\n+\t\t\t\t       5,\n+\t\t\t\t       fields_b));\n+\n+\n+  gcc_jit_field *b44 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t  0,\n+\t\t\t\t\t\t  int_type,\n+\t\t\t\t\t\t  \"c\");\n+\n+  gcc_jit_field *fields_ctor[] = {b1, b2, b44, b5};\n+  gcc_jit_rvalue *values[] = {0,0,0,0};\n+\n+  gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+    (ctxt, 0,\n+     struct_bar_type,\n+     4,\n+     fields_ctor,\n+     values);\n+\n+  CHECK_VALUE (ctor, NULL);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  /* Ensure that the bad API usage prevents the API giving a bogus\n+     result back.  */\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted. */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_context_new_struct_constructor: field object \"\n+\t\t      \"at index 2 (c), was not used when creating the \"\n+\t\t      \"struct bar\");\n+  CHECK_STRING_VALUE (gcc_jit_context_get_last_error (ctxt),\n+\t\t      \"gcc_jit_context_new_struct_constructor: field object \"\n+\t\t      \"at index 2 (c), was not used when creating the \"\n+\t\t      \"struct bar\");\n+}"}, {"sha": "364610bd21fb1fb6190f6cf2aa0a59651ff46d5d", "filename": "gcc/testsuite/jit.dg/test-error-ctor-struct-wrong-type.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-ctor-struct-wrong-type.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-ctor-struct-wrong-type.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-ctor-struct-wrong-type.c?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -0,0 +1,76 @@\n+/*\n+\n+  Test that the proper error is triggered when we build a ctor\n+  for an struct type, but has the type wrong on a field.\n+\n+*/\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_type *int_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_INT);\n+  gcc_jit_type *float_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_FLOAT);\n+\n+  gcc_jit_field *b1 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t int_type,\n+\t\t\t\t\t\t \"a\");\n+  gcc_jit_field *b2 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t int_type,\n+\t\t\t\t\t\t \"b\");\n+  gcc_jit_field *b3 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t int_type,\n+\t\t\t\t\t\t \"c\");\n+  gcc_jit_field *fields_b[] = {b1, b2, b3};\n+\n+  gcc_jit_type *struct_bar_type =\n+    gcc_jit_struct_as_type (\n+      gcc_jit_context_new_struct_type (ctxt,\n+\t\t\t\t       0,\n+\t\t\t\t       \"bar\",\n+\t\t\t\t       3,\n+\t\t\t\t       fields_b));\n+  gcc_jit_rvalue *frv = gcc_jit_context_new_rvalue_from_double (ctxt,\n+\t\t\t\t\t\t\t\tfloat_type,\n+\t\t\t\t\t\t\t\t12);\n+\n+  gcc_jit_field *fields_ctor[] = {b2};\n+  gcc_jit_rvalue *values[] = {frv};\n+\n+  gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+    (ctxt, 0,\n+     struct_bar_type,\n+     1,\n+     fields_ctor,\n+     values);\n+\n+  CHECK_VALUE (ctor, NULL);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  /* Ensure that the bad API usage prevents the API giving a bogus\n+     result back.  */\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted. */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_context_new_struct_constructor: value and \"\n+\t\t      \"field not the same unqualified type, at index 0 \"\n+\t\t      \"(struct bar.b: int)(value type: float)\");\n+  CHECK_STRING_VALUE (gcc_jit_context_get_last_error (ctxt),\n+\t\t      \"gcc_jit_context_new_struct_constructor: value and \"\n+\t\t      \"field not the same unqualified type, at index 0 \"\n+\t\t      \"(struct bar.b: int)(value type: float)\");\n+}"}, {"sha": "c2309de87dfb2b8f14f40f37e9f643cb8b3040ae", "filename": "gcc/testsuite/jit.dg/test-error-ctor-struct-wrong-type2.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-ctor-struct-wrong-type2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-ctor-struct-wrong-type2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-ctor-struct-wrong-type2.c?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -0,0 +1,77 @@\n+/*\n+\n+  Test that the proper error is triggered when we build a ctor\n+  for an struct type, but has the type wrong on a field.\n+\n+  Like test-error-ctor-struct-wrong-type.c, but with implicit fields.\n+\n+*/\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_type *int_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_INT);\n+  gcc_jit_type *float_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_FLOAT);\n+\n+  gcc_jit_field *b1 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t int_type,\n+\t\t\t\t\t\t \"a\");\n+  gcc_jit_field *b2 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t int_type,\n+\t\t\t\t\t\t \"b\");\n+  gcc_jit_field *b3 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t int_type,\n+\t\t\t\t\t\t \"c\");\n+  gcc_jit_field *fields_b[] = {b1, b2, b3};\n+\n+  gcc_jit_type *struct_bar_type =\n+    gcc_jit_struct_as_type (\n+      gcc_jit_context_new_struct_type (ctxt,\n+\t\t\t\t       0,\n+\t\t\t\t       \"bar\",\n+\t\t\t\t       3,\n+\t\t\t\t       fields_b));\n+  gcc_jit_rvalue *frv = gcc_jit_context_new_rvalue_from_double (ctxt,\n+\t\t\t\t\t\t\t\tfloat_type,\n+\t\t\t\t\t\t\t\t12);\n+\n+  gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+    (ctxt, 0,\n+     struct_bar_type,\n+     1,\n+     0,\n+     &frv);\n+\n+  CHECK_VALUE (ctor, NULL);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  /* Ensure that the bad API usage prevents the API giving a bogus\n+     result back.  */\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted. */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_context_new_struct_constructor: value and \"\n+\t\t      \"field not \"\n+\t\t      \"the same unqualified type, \"\n+\t\t      \"at index 0 (struct bar.a: int)(value type: float)\");\n+  CHECK_STRING_VALUE (gcc_jit_context_get_last_error (ctxt),\n+\t\t      \"gcc_jit_context_new_struct_constructor: value and \"\n+\t\t      \"field not \"\n+\t\t      \"the same unqualified type, \"\n+\t\t      \"at index 0 (struct bar.a: int)(value type: float)\");\n+}"}, {"sha": "2bf8ee4023e0c94bce76a8ec8eb766bf06eb4d46", "filename": "gcc/testsuite/jit.dg/test-error-ctor-union-wrong-field-name.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-ctor-union-wrong-field-name.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-ctor-union-wrong-field-name.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-ctor-union-wrong-field-name.c?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -0,0 +1,76 @@\n+/*\n+\n+  Test that the proper error is triggered when we build a ctor\n+  for an union type, but don't provide a correct field.\n+\n+*/\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_type *int_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_INT);\n+  gcc_jit_type *float_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_FLOAT);\n+  gcc_jit_type *double_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_DOUBLE);\n+\n+  gcc_jit_field *b1 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t int_type,\n+\t\t\t\t\t\t \"a\");\n+  gcc_jit_field *b2 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t float_type,\n+\t\t\t\t\t\t \"b\");\n+  gcc_jit_field *b3 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t double_type,\n+\t\t\t\t\t\t \"c\");\n+  gcc_jit_field *fields_b[] = {b1, b2, b3};\n+\n+  gcc_jit_type *union_bar_type =\n+      gcc_jit_context_new_union_type (ctxt,\n+\t\t\t\t      0,\n+\t\t\t\t      \"bar\",\n+\t\t\t\t      3,\n+\t\t\t\t      fields_b);\n+\n+  gcc_jit_field *b33 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t  0,\n+\t\t\t\t\t\t  double_type,\n+\t\t\t\t\t\t  \"c\");\n+\n+  gcc_jit_rvalue *val =\n+    gcc_jit_context_new_rvalue_from_double (ctxt, double_type, 1);\n+\n+  gcc_jit_rvalue *ctor = gcc_jit_context_new_union_constructor\n+    (ctxt, 0,\n+     union_bar_type,\n+     b33,\n+     val);\n+\n+  CHECK_VALUE (ctor, NULL);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  /* Ensure that the bad API usage prevents the API giving a bogus\n+     result back.  */\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted. */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_context_new_union_constructor: field object (c)\"\n+\t\t      \" was not used when creating the type union bar\");\n+  CHECK_STRING_VALUE (gcc_jit_context_get_last_error (ctxt),\n+\t\t      \"gcc_jit_context_new_union_constructor: field object (c)\"\n+\t\t      \" was not used when creating the type union bar\");\n+}"}, {"sha": "ecead87fc15ef9ef63fa01f1d77e0d74a46ce944", "filename": "gcc/testsuite/jit.dg/test-error-global-already-init.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-global-already-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-global-already-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-global-already-init.c?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -0,0 +1,46 @@\n+/*\n+\n+  Test that we can't set the initializer on a global twice.\n+\n+*/\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_type *int_type = gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+  gcc_jit_lvalue *bar =  gcc_jit_context_new_global (\n+    ctxt, NULL,\n+    GCC_JIT_GLOBAL_EXPORTED,\n+    int_type,\n+    \"global_lvalueinit_int_0\");\n+\n+  gcc_jit_global_set_initializer_rvalue (\n+    bar,\n+    gcc_jit_context_new_rvalue_from_int (ctxt, int_type, 1));\n+  gcc_jit_global_set_initializer_rvalue (\n+    bar,\n+    gcc_jit_context_new_rvalue_from_int (ctxt, int_type, 1));\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  /* Ensure that the bad API usage prevents the API giving a bogus\n+     result back.  */\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted. */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_global_set_initializer_rvalue: global variable \"\n+\t\t      \"already initialized: global_lvalueinit_int_0\");\n+  CHECK_STRING_VALUE (gcc_jit_context_get_last_error (ctxt),\n+\t\t      \"gcc_jit_global_set_initializer_rvalue: global variable \"\n+\t\t      \"already initialized: global_lvalueinit_int_0\");\n+}"}, {"sha": "2f994545165a310de4749d7bf84167a4c9fad417", "filename": "gcc/testsuite/jit.dg/test-error-global-common-section.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-global-common-section.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-global-common-section.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-global-common-section.c?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -0,0 +1,54 @@\n+/*\n+\n+  Test that the proper error is triggered when we initialize\n+  a global with a global that has no DECL_INITIAL (and is marked\n+  DECL_COMMON(NODE) = 1).\n+\n+*/\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_type *int_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_INT);\n+\n+  /* const int foo;\n+     int bar = foo;\n+   */\n+  gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+    ctxt, NULL,\n+    GCC_JIT_GLOBAL_EXPORTED,\n+    gcc_jit_type_get_const (int_type),\n+    \"global_const_int_0\");\n+  gcc_jit_lvalue *bar =  gcc_jit_context_new_global (\n+    ctxt, NULL,\n+    GCC_JIT_GLOBAL_EXPORTED,\n+    int_type,\n+    \"global_lvalueinit_int_0\");\n+  gcc_jit_global_set_initializer_rvalue (bar,\n+\t\t\t\t\t gcc_jit_lvalue_as_rvalue (foo));\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  /* Ensure that the bad API usage prevents the API giving a bogus\n+     result back.  */\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted. */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"unable to convert initial value for the global \"\n+\t\t      \"variable global_lvalueinit_int_0 to a compile-time\"\n+\t\t      \" constant\");\n+  CHECK_STRING_VALUE (gcc_jit_context_get_last_error (ctxt),\n+\t\t      \"unable to convert initial value for the global \"\n+\t\t      \"variable global_lvalueinit_int_0 to a compile-time\"\n+\t\t      \" constant\");\n+}"}, {"sha": "2a3db7af365915aa1d4bb59ba394208adc59cb65", "filename": "gcc/testsuite/jit.dg/test-error-global-init-too-small-array.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-global-init-too-small-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-global-init-too-small-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-global-init-too-small-array.c?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -0,0 +1,65 @@\n+/*\n+\n+  Test that the proper error is triggered when we initialize\n+  a global array with a ctor with too many values.\n+\n+  Using gcc_jit_global_set_initializer_rvalue()\n+\n+*/\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{ /* float foo[1] = {1,2}; */\n+\n+  gcc_jit_type *float_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_FLOAT);\n+  gcc_jit_type *arr_type = gcc_jit_context_new_array_type (ctxt,\n+\t\t\t\t\t\t\t   0,\n+\t\t\t\t\t\t\t   float_type,\n+\t\t\t\t\t\t\t   1);\n+  gcc_jit_rvalue *rval_1 = gcc_jit_context_new_rvalue_from_int (\n+    ctxt, float_type, 1);\n+  gcc_jit_rvalue *rval_2 = gcc_jit_context_new_rvalue_from_int (\n+    ctxt, float_type, 2);\n+\n+  gcc_jit_rvalue *values[] = {rval_1, rval_2};\n+\n+  gcc_jit_rvalue *ctor = gcc_jit_context_new_array_constructor (ctxt,\n+\t\t\t\t\t\t\t\t0,\n+\t\t\t\t\t\t\t\tarr_type,\n+\t\t\t\t\t\t\t\t2,\n+\t\t\t\t\t\t\t\tvalues);\n+  if (!ctor)\n+    return;\n+\n+  gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+    ctxt, NULL,\n+    GCC_JIT_GLOBAL_EXPORTED,\n+    arr_type,\n+    \"global_floatarr_12\");\n+  gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  /* Ensure that the bad API usage prevents the API giving a bogus\n+     result back.  */\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted. */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_context_new_array_constructor: array \"\n+\t\t      \"constructor has more values than the array type's \"\n+\t\t      \"length (array type length: 1, constructor length: 2)\");\n+  CHECK_STRING_VALUE (gcc_jit_context_get_last_error (ctxt),\n+\t\t      \"gcc_jit_context_new_array_constructor: array \"\n+\t\t      \"constructor has more values than the array type's \"\n+\t\t      \"length (array type length: 1, constructor length: 2)\");\n+}"}, {"sha": "65aa8a80b49fc40357d5ff397ccdb61fdde78151", "filename": "gcc/testsuite/jit.dg/test-error-global-lvalue-init.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-global-lvalue-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-global-lvalue-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-global-lvalue-init.c?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -0,0 +1,60 @@\n+/*\n+\n+  Test that the proper error is triggered when we initialize\n+  a global with another non-const global's rvalue.\n+\n+  Using gcc_jit_global_set_initializer_rvalue()\n+\n+*/\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_type *int_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_INT);\n+\n+  gcc_jit_lvalue *foo;\n+  { /* int bar; */\n+    foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      int_type,\n+      \"global_lvalueinit_int1\");\n+    gcc_jit_rvalue *rval = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+    gcc_jit_global_set_initializer_rvalue (foo,\n+      rval);\n+  }\n+  { /* int foo = bar; */\n+\n+    gcc_jit_lvalue *bar =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      int_type,\n+      \"global_lvalueinit_int2\");\n+    gcc_jit_global_set_initializer_rvalue (bar,\n+\t\t\t\t\t   gcc_jit_lvalue_as_rvalue (foo));\n+  }\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  /* Ensure that the bad API usage prevents the API giving a bogus\n+     result back.  */\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted. */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"unable to convert initial value for the global variable\"\n+\t\t      \" global_lvalueinit_int2 to a compile-time constant\");\n+  CHECK_STRING_VALUE (gcc_jit_context_get_last_error (ctxt),\n+\t\t      \"unable to convert initial value for the global variable\"\n+\t\t      \" global_lvalueinit_int2 to a compile-time constant\");\n+}"}, {"sha": "9dffe06eac32a09428d1de5e2ebe3bea5e164484", "filename": "gcc/testsuite/jit.dg/test-error-global-nonconst-init.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-global-nonconst-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-global-nonconst-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-global-nonconst-init.c?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -0,0 +1,80 @@\n+/*\n+\n+  Test that the proper error is triggered when we initialize\n+  a global with a function call.\n+\n+  Using gcc_jit_global_set_initializer_rvalue()\n+\n+*/\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_type *int_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_INT);\n+\n+  gcc_jit_function *fn_int_3;\n+  { /* int foo () { int local = 3; return local;} */\n+    fn_int_3 =\n+      gcc_jit_context_new_function (ctxt,\n+\t\t\t\t    0,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    int_type,\n+\t\t\t\t    \"fn_int_3\",\n+\t\t\t\t    0,\n+\t\t\t\t    0,\n+\t\t\t\t    0);\n+    gcc_jit_block *block = gcc_jit_function_new_block (fn_int_3, \"start\");\n+    gcc_jit_lvalue *local = gcc_jit_function_new_local (fn_int_3,\n+\t\t\t\t\t\t\t0,\n+\t\t\t\t\t\t\tint_type,\n+\t\t\t\t\t\t\t\"local\");\n+    gcc_jit_rvalue *rval = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+\n+    gcc_jit_block_add_assignment (block, 0, local, rval);\n+\n+    gcc_jit_block_end_with_return (block,\n+\t\t\t\t   0,\n+\t\t\t\t   gcc_jit_lvalue_as_rvalue(local));\n+\n+  }\n+\n+  { /* int bar = foo(); */\n+    gcc_jit_rvalue *rval =\n+      gcc_jit_context_new_call (ctxt,\n+\t\t\t\t0,\n+\t\t\t\tfn_int_3,\n+\t\t\t\t0,0);\n+\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      int_type,\n+      \"global_nonconst_int\");\n+    gcc_jit_global_set_initializer_rvalue (foo,\n+      rval);\n+  }\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  /* Ensure that the bad API usage prevents the API giving a bogus\n+     result back.  */\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted. */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"unable to convert initial value for the global variable\"\n+\t\t      \" global_nonconst_int to a compile-time constant\");\n+  CHECK_STRING_VALUE (gcc_jit_context_get_last_error (ctxt),\n+\t\t      \"unable to convert initial value for the global variable\"\n+\t\t      \" global_nonconst_int to a compile-time constant\");\n+}"}, {"sha": "4866462ff4ab01fde8e4d0d955df7bfdfd70b927", "filename": "gcc/testsuite/jit.dg/test-global-init-rvalue.c", "status": "added", "additions": 1643, "deletions": 0, "changes": 1643, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-global-init-rvalue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-global-init-rvalue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-global-init-rvalue.c?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -0,0 +1,1643 @@\n+/* This testcase checks that gcc_jit_global_set_initializer_rvalue() works\n+   with rvalues, especially with gcc_jit_context_new_*_constructor() for\n+   struct, unions and arrays. */\n+\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"libgccjit.h\"\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_type *int_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_INT);\n+  gcc_jit_type *short_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_SHORT);\n+  gcc_jit_type *pint_type = gcc_jit_type_get_pointer (int_type);\n+  gcc_jit_type *double_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_DOUBLE);\n+  gcc_jit_type *float_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_FLOAT);\n+  gcc_jit_type *bool_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_BOOL);\n+  gcc_jit_type *char_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_CHAR);\n+  gcc_jit_type *cpchar_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_CONST_CHAR_PTR);\n+  gcc_jit_type *size_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_SIZE_T);\n+\n+  /* Make a struct: struct fi { float f; int i;} */\n+  gcc_jit_field *fi_f = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t   0,\n+\t\t\t\t\t\t   float_type,\n+\t\t\t\t\t\t   \"f\");\n+  gcc_jit_field *fi_i = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t   0,\n+\t\t\t\t\t\t   int_type,\n+\t\t\t\t\t\t   \"i\");\n+  gcc_jit_field *fields[] = {fi_f, fi_i};\n+\n+  gcc_jit_type *struct_fi_type =\n+    gcc_jit_struct_as_type (\n+      gcc_jit_context_new_struct_type (ctxt,\n+\t\t\t\t       0,\n+\t\t\t\t       \"fi\",\n+\t\t\t\t       2,\n+\t\t\t\t       fields));\n+\n+  /* Make a struct:\n+\n+     struct bar {\n+       int ii;\n+       struct fi fi;\n+       float ff;\n+     }\n+  */\n+  gcc_jit_field *bar_ff = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t     0,\n+\t\t\t\t\t\t     float_type,\n+\t\t\t\t\t\t     \"ff\");\n+  gcc_jit_field *bar_ii = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t     0,\n+\t\t\t\t\t\t     int_type,\n+\t\t\t\t\t\t     \"ii\");\n+  gcc_jit_field *bar_fi = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t     0,\n+\t\t\t\t\t\t     struct_fi_type,\n+\t\t\t\t\t\t     \"fi\");\n+  gcc_jit_field *fields2[] = {bar_ff, bar_fi, bar_ii};\n+\n+  gcc_jit_type *struct_bar_type =\n+    gcc_jit_struct_as_type (\n+      gcc_jit_context_new_struct_type (ctxt,\n+\t\t\t\t       0,\n+\t\t\t\t       \"bar\",\n+\t\t\t\t       3,\n+\t\t\t\t       fields2));\n+\n+  /* Make an union:\n+\n+     union ubar {\n+       float ff;\n+       int ii;\n+     };\n+  */\n+  gcc_jit_field *ubar_ff = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t      0,\n+\t\t\t\t\t\t      float_type,\n+\t\t\t\t\t\t      \"ff\");\n+  gcc_jit_field *ubar_ii = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t      0,\n+\t\t\t\t\t\t      int_type,\n+\t\t\t\t\t\t      \"ii\");\n+  gcc_jit_field *fields3[] = {ubar_ff, ubar_ii};\n+\n+  gcc_jit_type *ubar = gcc_jit_context_new_union_type (ctxt,\n+\t\t\t\t\t\t       0,\n+\t\t\t\t\t\t       \"ubar\",\n+\t\t\t\t\t\t       2,\n+\t\t\t\t\t\t       fields3);\n+\n+  { /* struct bar bar = {.ff=1, .fi={.f=2, .i=3}, .ii=4};\n+       I.e. nested ctors and with fields specified\n+     */\n+    gcc_jit_lvalue *bar = gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      struct_bar_type,\n+      \"global_struct_bar_1234_1\");\n+\n+    gcc_jit_rvalue *fval = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 2);\n+    gcc_jit_rvalue *ival = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+\n+    gcc_jit_rvalue *vals[] = { fval, ival};\n+    gcc_jit_field *fields[] = {fi_f, fi_i};\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+      (ctxt, 0,\n+       struct_fi_type,\n+       2,\n+       fields,\n+       vals);\n+\n+    ival = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 4);\n+    fval = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 1);\n+\n+    gcc_jit_rvalue *vals2[] = {fval, ctor, ival};\n+    gcc_jit_field *fields2[] = {bar_ff, bar_fi, bar_ii};\n+\n+    gcc_jit_rvalue *ctor_bar = gcc_jit_context_new_struct_constructor\n+      (ctxt, 0,\n+       struct_bar_type,\n+       3,\n+       fields2,\n+       vals2);\n+\n+    gcc_jit_global_set_initializer_rvalue (bar, ctor_bar);\n+  }\n+  { /* struct bar bar = {1, {2, 3}, 4};\n+       I.e. nested ctors and fields implicit in definition order (fields=NULL)\n+     */\n+    gcc_jit_lvalue *bar = gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      struct_bar_type,\n+      \"global_struct_bar_1234_2\");\n+\n+    gcc_jit_rvalue *fval = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 2);\n+    gcc_jit_rvalue *ival = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+\n+    gcc_jit_rvalue *vals[] = { fval, ival};\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+      (ctxt, 0,\n+       struct_fi_type,\n+       2,\n+       0,\n+       vals);\n+\n+    ival = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 4);\n+    fval = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 1);\n+\n+    gcc_jit_rvalue *vals2[] = {fval, ctor, ival};\n+\n+    gcc_jit_rvalue *ctor_bar = gcc_jit_context_new_struct_constructor\n+      (ctxt, 0,\n+       struct_bar_type,\n+       3,\n+       0,\n+       vals2);\n+\n+    gcc_jit_global_set_initializer_rvalue (bar, ctor_bar);\n+  }\n+  { /* struct fi foo = {.f=2, .i=3}; */\n+    gcc_jit_lvalue *foo = gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      struct_fi_type,\n+      \"global_struct_fi_23_1\");\n+\n+    gcc_jit_rvalue *fval = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 2);\n+    gcc_jit_rvalue *ival = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+\n+    gcc_jit_rvalue *vals[] = { fval, ival};\n+    gcc_jit_field *fields[] = {fi_f, fi_i};\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+      (ctxt, 0,\n+       struct_fi_type,\n+       2,\n+       fields,\n+       vals);\n+\n+    gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* struct fi foo = {2, 3}; */\n+    gcc_jit_lvalue *foo = gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      struct_fi_type,\n+      \"global_struct_fi_23_2\");\n+\n+    gcc_jit_rvalue *fval = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 2);\n+    gcc_jit_rvalue *ival = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+\n+    gcc_jit_rvalue *vals[] = { fval, ival};\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+      (ctxt, 0,\n+       struct_fi_type,\n+       2,\n+       0,\n+       vals);\n+\n+    gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* struct fi foo = {.i=0, .f=0}; (null init) */\n+    gcc_jit_lvalue *foo = gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      struct_fi_type,\n+      \"global_struct_fi_00_1\");\n+\n+    gcc_jit_rvalue *vals[] = { 0, 0};\n+    gcc_jit_field *fields[] = {fi_f, fi_i};\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+      (ctxt, 0,\n+       struct_fi_type,\n+       2,\n+       fields,\n+       vals);\n+\n+    gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* struct fi foo = {0, 0}; (null fields, null elements in values) */\n+    gcc_jit_lvalue *foo = gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      struct_fi_type,\n+      \"global_struct_fi_00_2\");\n+\n+    gcc_jit_rvalue *vals[] = { 0, 0};\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+      (ctxt, 0,\n+       struct_fi_type,\n+       2,\n+       0,\n+       vals);\n+\n+    gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* struct fi foo = {.i = 0} (null init);\n+\n+       Null init values. */\n+    gcc_jit_lvalue *foo = gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      struct_fi_type,\n+      \"global_struct_fi_0_1\");\n+\n+    gcc_jit_rvalue *vals[] = {0};\n+    gcc_jit_field *fields[] = {fi_i};\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+      (ctxt, 0,\n+       struct_fi_type,\n+       1,\n+       fields,\n+       vals);\n+    gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* struct fi foo = {0};\n+\n+       Null init values. */\n+    gcc_jit_lvalue *foo = gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      struct_fi_type,\n+      \"global_struct_fi_0_2\");\n+\n+    gcc_jit_rvalue *vals[] = {0};\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+      (ctxt, 0,\n+       struct_fi_type,\n+       1,\n+       0,\n+       vals);\n+    gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* struct fi foo = {}; (null init)\n+\n+       Null fields and values. */\n+    gcc_jit_lvalue *foo = gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      struct_fi_type,\n+      \"global_struct_fi_6\");\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+      (ctxt, 0,\n+       struct_fi_type,\n+       0,\n+       0,\n+       0);\n+    gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* struct fi foo = {2 * 2, 3}; */\n+    gcc_jit_lvalue *foo = gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      struct_fi_type,\n+      \"global_struct_fi_3\");\n+\n+    gcc_jit_rvalue *fval = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 2);\n+    gcc_jit_rvalue *fval2 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 2);\n+    gcc_jit_rvalue *ival = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+    gcc_jit_rvalue *rval_mul = gcc_jit_context_new_binary_op (ctxt, 0,\n+      GCC_JIT_BINARY_OP_MULT,\n+      float_type,\n+      fval,\n+      fval2);\n+\n+    gcc_jit_rvalue *vals[] = { rval_mul, ival};\n+    gcc_jit_field *fields[] = {fi_f, fi_i};\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+      (ctxt, 0,\n+       struct_fi_type,\n+       2,\n+       fields,\n+       vals);\n+\n+    gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* union ubar foo = {.ff = 3}; */\n+     gcc_jit_lvalue *foo = gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      ubar,\n+      \"global_union_ufoo_ff3\");\n+\n+     gcc_jit_rvalue *fval = gcc_jit_context_new_rvalue_from_int (\n+       ctxt, float_type, 3);\n+\n+     gcc_jit_rvalue *ctor = gcc_jit_context_new_union_constructor (\n+       ctxt,\n+       0,\n+       ubar,\n+       ubar_ff,\n+       fval);\n+\n+     gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* union ubar foo = {.ii = 2}; */\n+     gcc_jit_lvalue *foo = gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      ubar,\n+      \"global_union_ufoo_ii2\");\n+\n+     gcc_jit_rvalue *ival = gcc_jit_context_new_rvalue_from_int (\n+       ctxt, int_type, 2);\n+\n+     gcc_jit_rvalue *ctor = gcc_jit_context_new_union_constructor (\n+       ctxt,\n+       0,\n+       ubar,\n+       ubar_ii,\n+       ival);\n+\n+     gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* union ubar foo = {1.1f}; should init first field  */\n+     gcc_jit_lvalue *foo = gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      ubar,\n+      \"global_union_ufoo_ff1c1\");\n+\n+     gcc_jit_rvalue *fval = gcc_jit_context_new_rvalue_from_double (\n+       ctxt, float_type, 1.1);\n+\n+     gcc_jit_rvalue *ctor = gcc_jit_context_new_union_constructor (\n+       ctxt,\n+       0,\n+       ubar,\n+       0,\n+       fval);\n+\n+     gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* union ubar foo = (union ubar){}; */\n+     gcc_jit_lvalue *foo = gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      ubar,\n+      \"global_union_ufoo_0\");\n+\n+     gcc_jit_rvalue *ctor = gcc_jit_context_new_union_constructor (\n+       ctxt,\n+       0,\n+       ubar,\n+       0,\n+       0);\n+\n+     gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* int foo = 3; */\n+    gcc_jit_rvalue *rval = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      int_type,\n+      \"global_int1_3\");\n+    gcc_jit_global_set_initializer_rvalue (foo,\n+      rval);\n+  }\n+  { /* const volatile int foo = 3; */\n+    gcc_jit_rvalue *rval = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      gcc_jit_type_get_const (gcc_jit_type_get_volatile (int_type)),\n+      \"global_cvint1_3\");\n+    gcc_jit_global_set_initializer_rvalue (foo,\n+      rval);\n+  }\n+  { /* Try the above, but with opposite order of global and literal calls */\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      int_type,\n+      \"global_int2_3\");\n+    gcc_jit_rvalue *rval = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+    gcc_jit_global_set_initializer_rvalue (foo,\n+      rval);\n+  }\n+  { /* int foo = 3 * (3 + 3) */\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      int_type,\n+      \"global_int3_18\");\n+    gcc_jit_rvalue *rval3_0 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+    gcc_jit_rvalue *rval3_1 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+    gcc_jit_rvalue *rval3_2 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+    gcc_jit_rvalue *rval_plus = gcc_jit_context_new_binary_op (ctxt, 0,\n+      GCC_JIT_BINARY_OP_PLUS,\n+      int_type,\n+      rval3_0,\n+      rval3_1);\n+    gcc_jit_rvalue *rval_mul = gcc_jit_context_new_binary_op (ctxt, 0,\n+      GCC_JIT_BINARY_OP_MULT,\n+      int_type,\n+      rval_plus,\n+      rval3_2);\n+\n+    gcc_jit_global_set_initializer_rvalue (foo,\n+      rval_mul);\n+  }\n+  { /* int foo = ~(-(((((2 | 8) & 15) ^ 0) << 3 >> 2 - 1) / 2)); */\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      int_type,\n+      \"global_int_alotofoperators\");\n+    gcc_jit_rvalue *rval_0 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 2);\n+    gcc_jit_rvalue *rval_1 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 8);\n+    gcc_jit_rvalue *rval_2 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 15);\n+    gcc_jit_rvalue *rval_3 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 0);\n+    gcc_jit_rvalue *rval_4 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+    gcc_jit_rvalue *rval_5 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 2);\n+    gcc_jit_rvalue *rval_6 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 1);\n+    gcc_jit_rvalue *rval_7 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 2);\n+\n+    gcc_jit_rvalue *rval_or = gcc_jit_context_new_binary_op (ctxt, 0,\n+      GCC_JIT_BINARY_OP_BITWISE_OR,\n+      int_type,\n+      rval_0,\n+      rval_1);\n+    gcc_jit_rvalue *rval_and = gcc_jit_context_new_binary_op (ctxt, 0,\n+      GCC_JIT_BINARY_OP_BITWISE_AND,\n+      int_type,\n+      rval_or,\n+      rval_2);\n+    gcc_jit_rvalue *rval_xor = gcc_jit_context_new_binary_op (ctxt, 0,\n+      GCC_JIT_BINARY_OP_BITWISE_XOR,\n+      int_type,\n+      rval_and,\n+      rval_3);\n+    gcc_jit_rvalue *rval_lsh = gcc_jit_context_new_binary_op (ctxt, 0,\n+      GCC_JIT_BINARY_OP_LSHIFT,\n+      int_type,\n+      rval_xor,\n+      rval_4);\n+    gcc_jit_rvalue *rval_rsh = gcc_jit_context_new_binary_op (ctxt, 0,\n+      GCC_JIT_BINARY_OP_RSHIFT,\n+      int_type,\n+      rval_lsh,\n+      rval_5);\n+    gcc_jit_rvalue *rval_min = gcc_jit_context_new_binary_op (ctxt, 0,\n+      GCC_JIT_BINARY_OP_MINUS,\n+      int_type,\n+      rval_rsh,\n+      rval_6);\n+    gcc_jit_rvalue *rval_div = gcc_jit_context_new_binary_op (ctxt, 0,\n+      GCC_JIT_BINARY_OP_DIVIDE,\n+      int_type,\n+      rval_min,\n+      rval_7);\n+    gcc_jit_rvalue *rval_umin =  gcc_jit_context_new_unary_op (ctxt, 0,\n+      GCC_JIT_UNARY_OP_MINUS,\n+      int_type,\n+      rval_div);\n+    gcc_jit_rvalue *rval_neg =  gcc_jit_context_new_unary_op (ctxt, 0,\n+      GCC_JIT_UNARY_OP_BITWISE_NEGATE,\n+      int_type,\n+      rval_umin);\n+\n+    gcc_jit_global_set_initializer_rvalue (foo,\n+      rval_neg);\n+  }\n+  { /* int foo = 3; int *pfoo = &foo; */\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      int_type,\n+      \"global_int4_3\");\n+    gcc_jit_rvalue *rval = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+    gcc_jit_global_set_initializer_rvalue (foo,\n+      rval);\n+\n+    gcc_jit_lvalue *pfoo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      pint_type,\n+      \"global_pint5\");\n+    gcc_jit_global_set_initializer_rvalue (pfoo,\n+      gcc_jit_lvalue_get_address (foo, 0));\n+  }\n+  { /* static int foo; int *pfoo = &foo; */\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_INTERNAL,\n+      int_type,\n+      \"global_int5_3\");\n+\n+    gcc_jit_lvalue *pfoo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      pint_type,\n+      \"global_pint6\");\n+    gcc_jit_global_set_initializer_rvalue (pfoo,\n+      gcc_jit_lvalue_get_address (foo, 0));\n+\n+    gcc_jit_function *fn =\n+      gcc_jit_context_new_function (ctxt,\n+\t\t\t\t    0,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    gcc_jit_type_get_pointer(int_type),\n+\t\t\t\t    \"fn_pint_0\",\n+\t\t\t\t    0,\n+\t\t\t\t    0,\n+\t\t\t\t    0);\n+\n+    gcc_jit_block *block = gcc_jit_function_new_block (fn, \"start\");\n+\n+    gcc_jit_block_end_with_return (block,\n+\t\t\t\t   0,\n+\t\t\t\t   gcc_jit_lvalue_get_address (foo, 0));\n+  }\n+  { /* int foo = 3; int *pfoo = &foo + 1; */\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      int_type,\n+      \"global_int6_3\");\n+    gcc_jit_rvalue *rval = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+    gcc_jit_global_set_initializer_rvalue (foo,\n+      rval);\n+\n+    gcc_jit_lvalue *pfoo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      pint_type,\n+      \"global_pint7\");\n+    gcc_jit_global_set_initializer_rvalue (pfoo,\n+      gcc_jit_lvalue_get_address (\n+\tgcc_jit_context_new_array_access(\n+\t  ctxt,\n+\t  0,\n+\t  gcc_jit_lvalue_get_address(foo, 0),\n+\t  gcc_jit_context_one(ctxt, int_type)),\n+\t0));\n+  }\n+  { /* double foo = 3; */\n+    gcc_jit_lvalue *double1 =  gcc_jit_context_new_global (\n+\tctxt, NULL,\n+\tGCC_JIT_GLOBAL_EXPORTED,\n+\tdouble_type,\n+\t\"global_double1_3\");\n+    gcc_jit_rvalue *rval = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, double_type, 3);\n+    gcc_jit_global_set_initializer_rvalue (double1,\n+      rval);\n+  }\n+  { /* double foo = 3 * 3 + 3 */\n+    gcc_jit_lvalue *double1 =  gcc_jit_context_new_global (\n+\tctxt, NULL,\n+\tGCC_JIT_GLOBAL_EXPORTED,\n+\tdouble_type,\n+\t\"global_double2_12\");\n+    gcc_jit_rvalue *rval = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, double_type, 3);\n+    gcc_jit_rvalue *rval_mul = gcc_jit_context_new_binary_op (ctxt, 0,\n+      GCC_JIT_BINARY_OP_MULT,\n+      double_type,\n+      rval,\n+      rval);\n+    gcc_jit_rvalue *rval_plus = gcc_jit_context_new_binary_op (ctxt, 0,\n+      GCC_JIT_BINARY_OP_PLUS,\n+      double_type,\n+      rval_mul,\n+      rval);\n+    gcc_jit_global_set_initializer_rvalue (double1,\n+      rval_plus);\n+  }\n+  { /* bool foo = 3 + 3 <= 6; */\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      bool_type,\n+      \"global_bool1_1\");\n+    gcc_jit_rvalue *rval3_0 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+    gcc_jit_rvalue *rval3_1 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+    gcc_jit_rvalue *rval6 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 6);\n+    gcc_jit_rvalue *rval_plus = gcc_jit_context_new_binary_op (ctxt,\n+      0,\n+      GCC_JIT_BINARY_OP_PLUS,\n+      int_type,\n+      rval3_0,\n+      rval3_1);\n+    gcc_jit_rvalue *rval_le = gcc_jit_context_new_comparison (ctxt,\n+      0,\n+      GCC_JIT_COMPARISON_LE,\n+      rval_plus,\n+      rval6);\n+\n+    gcc_jit_global_set_initializer_rvalue (foo,\n+      rval_le);\n+  }\n+  gcc_jit_lvalue *global_intarr_1234;\n+  { /* int foo[] = {1,2,3,4}; */\n+\n+    gcc_jit_type *arr_type = gcc_jit_context_new_array_type (ctxt,\n+\t\t\t\t\t\t\t     0,\n+\t\t\t\t\t\t\t     int_type,\n+\t\t\t\t\t\t\t     4);\n+    gcc_jit_rvalue *rval_1 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 1);\n+    gcc_jit_rvalue *rval_2 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 2);\n+    gcc_jit_rvalue *rval_3 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+    gcc_jit_rvalue *rval_4 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 4);\n+\n+    gcc_jit_rvalue *values[] = {rval_1, rval_2, rval_3, rval_4};\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_array_constructor (ctxt,\n+\t\t\t\t\t\t\t\t  0,\n+\t\t\t\t\t\t\t\t  arr_type,\n+\t\t\t\t\t\t\t\t  4,\n+\t\t\t\t\t\t\t\t  values);\n+    global_intarr_1234 = gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      arr_type,\n+      \"global_intarr_1234\");\n+    gcc_jit_global_set_initializer_rvalue (global_intarr_1234, ctor);\n+  }\n+  { /* float foo[4] = {1,2}; */\n+\n+    gcc_jit_type *arr_type = gcc_jit_context_new_array_type (ctxt,\n+\t\t\t\t\t\t\t     0,\n+\t\t\t\t\t\t\t     float_type,\n+\t\t\t\t\t\t\t     4);\n+    gcc_jit_rvalue *rval_1 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 1);\n+    gcc_jit_rvalue *rval_2 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 2);\n+\n+    gcc_jit_rvalue *values[] = {rval_1, rval_2};\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_array_constructor (ctxt,\n+\t\t\t\t\t\t\t\t  0,\n+\t\t\t\t\t\t\t\t  arr_type,\n+\t\t\t\t\t\t\t\t  2,\n+\t\t\t\t\t\t\t\t  values);\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      arr_type,\n+      \"global_floatarr_12\");\n+    gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* float foo[4] = {1,2};\n+       With different array objects of same size and type. */\n+\n+    gcc_jit_type *arr_type = gcc_jit_context_new_array_type (ctxt,\n+\t\t\t\t\t\t\t     0,\n+\t\t\t\t\t\t\t     float_type,\n+\t\t\t\t\t\t\t     4);\n+    gcc_jit_type *arr_type1 = gcc_jit_context_new_array_type (ctxt,\n+\t\t\t\t\t\t\t      0,\n+\t\t\t\t\t\t\t      float_type,\n+\t\t\t\t\t\t\t      4);\n+    gcc_jit_rvalue *rval_1 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 1);\n+    gcc_jit_rvalue *rval_2 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 2);\n+\n+    gcc_jit_rvalue *values[] = {rval_1, rval_2};\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_array_constructor (ctxt,\n+\t\t\t\t\t\t\t\t  0,\n+\t\t\t\t\t\t\t\t  arr_type1,\n+\t\t\t\t\t\t\t\t  2,\n+\t\t\t\t\t\t\t\t  values);\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      arr_type,\n+      \"global_floatarr_12_2\");\n+    gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* float foo[4] = {1,2,0}; (null init) */\n+\n+    gcc_jit_type *arr_type = gcc_jit_context_new_array_type (ctxt,\n+\t\t\t\t\t\t\t     0,\n+\t\t\t\t\t\t\t     float_type,\n+\t\t\t\t\t\t\t     4);\n+    gcc_jit_rvalue *rval_1 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 1);\n+    gcc_jit_rvalue *rval_2 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 2);\n+\n+    gcc_jit_rvalue *values[] = {rval_1, rval_2, 0};\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_array_constructor (ctxt,\n+\t\t\t\t\t\t\t\t  0,\n+\t\t\t\t\t\t\t\t  arr_type,\n+\t\t\t\t\t\t\t\t  2,\n+\t\t\t\t\t\t\t\t  values);\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      arr_type,\n+      \"global_floatarr_120\");\n+    gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* float foo[4] = {}; (null init) */\n+\n+    gcc_jit_type *arr_type = gcc_jit_context_new_array_type (ctxt,\n+\t\t\t\t\t\t\t     0,\n+\t\t\t\t\t\t\t     float_type,\n+\t\t\t\t\t\t\t     4);\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_array_constructor (ctxt,\n+\t\t\t\t\t\t\t\t  0,\n+\t\t\t\t\t\t\t\t  arr_type,\n+\t\t\t\t\t\t\t\t  0,\n+\t\t\t\t\t\t\t\t  0);\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      arr_type,\n+      \"global_floatarr_0000\");\n+    gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* float foo[4] = {NULL , NULL, 3, NULL, 5, 6}; (null init) */\n+\n+    gcc_jit_type *arr_type = gcc_jit_context_new_array_type (ctxt,\n+\t\t\t\t\t\t\t     0,\n+\t\t\t\t\t\t\t     float_type,\n+\t\t\t\t\t\t\t     8);\n+    gcc_jit_rvalue *rval3 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 3);\n+    gcc_jit_rvalue *rval5 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 5);\n+    gcc_jit_rvalue *rval6 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 6);\n+\n+    gcc_jit_rvalue *values[] = {0, 0, rval3, 0, rval5, rval6, 0 };\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_array_constructor (ctxt,\n+\t\t\t\t\t\t\t\t  0,\n+\t\t\t\t\t\t\t\t  arr_type,\n+\t\t\t\t\t\t\t\t  7,\n+\t\t\t\t\t\t\t\t  values);\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      arr_type,\n+      \"global_floatarr_00305600\");\n+    gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* int *foo[4] = {0, &global_intarr_1234[1], 0}; */\n+\n+    gcc_jit_type *arr_type = gcc_jit_context_new_array_type (ctxt,\n+\t\t\t\t\t\t\t     0,\n+\t\t\t\t\t\t\t     pint_type,\n+\t\t\t\t\t\t\t     4);\n+    gcc_jit_rvalue *rval_1 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 1);\n+    gcc_jit_lvalue *arr_access = gcc_jit_context_new_array_access (\n+      ctxt,\n+      0,\n+      gcc_jit_lvalue_as_rvalue (global_intarr_1234),\n+      rval_1);\n+    gcc_jit_rvalue *rval_2 = gcc_jit_lvalue_get_address (arr_access, 0);\n+    gcc_jit_rvalue *rval_3 = gcc_jit_context_null (ctxt, pint_type);\n+\n+    gcc_jit_rvalue *values[] = {0, rval_2, rval_3};\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_array_constructor (ctxt,\n+\t\t\t\t\t\t\t\t  0,\n+\t\t\t\t\t\t\t\t  arr_type,\n+\t\t\t\t\t\t\t\t  2,\n+\t\t\t\t\t\t\t\t  values);\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      arr_type,\n+      \"global_pintarr_x2xx\");\n+    gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* char foo[4] = {'q','w','e',0}; */\n+\n+    gcc_jit_type *arr_type = gcc_jit_context_new_array_type (ctxt,\n+\t\t\t\t\t\t\t     0,\n+\t\t\t\t\t\t\t     char_type,\n+\t\t\t\t\t\t\t     4);\n+\n+\n+    gcc_jit_rvalue *rvals[] = {\n+      gcc_jit_context_new_rvalue_from_int ( ctxt, char_type, 'q'),\n+      gcc_jit_context_new_rvalue_from_int ( ctxt, char_type, 'w'),\n+      gcc_jit_context_new_rvalue_from_int ( ctxt, char_type, 'e'),\n+      gcc_jit_context_new_rvalue_from_int ( ctxt, char_type, 0)\n+    };\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_array_constructor (ctxt,\n+\t\t\t\t\t\t\t\t  0,\n+\t\t\t\t\t\t\t\t  arr_type,\n+\t\t\t\t\t\t\t\t  4,\n+\t\t\t\t\t\t\t\t  rvals);\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      arr_type,\n+      \"global_chararr_qwe\");\n+    gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* int foo[2][2] = {{1,2},{3,4}}; */\n+\n+    gcc_jit_type *row_type = gcc_jit_context_new_array_type (ctxt,\n+\t\t\t\t\t\t\t     0,\n+\t\t\t\t\t\t\t     int_type,\n+\t\t\t\t\t\t\t     2);\n+\n+    gcc_jit_type *arr_type = gcc_jit_context_new_array_type (ctxt,\n+\t\t\t\t\t\t\t     0,\n+\t\t\t\t\t\t\t     row_type,\n+\t\t\t\t\t\t\t     2);\n+    gcc_jit_rvalue *rvals_row0[] = {\n+      gcc_jit_context_new_rvalue_from_int ( ctxt, int_type, 1),\n+      gcc_jit_context_new_rvalue_from_int ( ctxt, int_type, 2)\n+    };\n+    gcc_jit_rvalue *rvals_row1[] = {\n+      gcc_jit_context_new_rvalue_from_int ( ctxt, int_type, 3),\n+      gcc_jit_context_new_rvalue_from_int ( ctxt, int_type, 4)\n+    };\n+\n+    gcc_jit_rvalue *ctor_row0 =\n+      gcc_jit_context_new_array_constructor (ctxt,\n+\t\t\t\t\t     0,\n+\t\t\t\t\t     row_type,\n+\t\t\t\t\t     2,\n+\t\t\t\t\t     rvals_row0);\n+    gcc_jit_rvalue *ctor_row1 =\n+      gcc_jit_context_new_array_constructor (ctxt,\n+\t\t\t\t\t     0,\n+\t\t\t\t\t     row_type,\n+\t\t\t\t\t     2,\n+\t\t\t\t\t     rvals_row1);\n+    gcc_jit_rvalue *ctors_row[] = {ctor_row0, ctor_row1};\n+\n+    gcc_jit_rvalue *ctor_arr =\n+      gcc_jit_context_new_array_constructor (ctxt,\n+\t\t\t\t\t     0,\n+\t\t\t\t\t     arr_type,\n+\t\t\t\t\t     2,\n+\t\t\t\t\t     ctors_row);\n+\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      arr_type,\n+      \"global_int2x2matrix_1234\");\n+\n+    gcc_jit_global_set_initializer_rvalue (foo, ctor_arr);\n+  }\n+  { /* const char *foo[4] = {\"qwe\", \"asd\"}; */\n+\n+    gcc_jit_type *arr_type = gcc_jit_context_new_array_type (ctxt,\n+\t\t\t\t\t\t\t     0,\n+\t\t\t\t\t\t\t     cpchar_type,\n+\t\t\t\t\t\t\t     4);\n+\n+\n+    gcc_jit_rvalue *rvals[] = {\n+      gcc_jit_context_new_string_literal (ctxt, \"qwe\"),\n+      gcc_jit_context_new_string_literal (ctxt, \"asd\")\n+    };\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_array_constructor (ctxt,\n+\t\t\t\t\t\t\t\t  0,\n+\t\t\t\t\t\t\t\t  arr_type,\n+\t\t\t\t\t\t\t\t  2,\n+\t\t\t\t\t\t\t\t  rvals);\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      arr_type,\n+      \"global_cpchararr_qwe_asd\");\n+    gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  { /* const int foo = 3;\n+       int bar = foo;\n+     */\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      gcc_jit_type_get_const (int_type),\n+      \"global_const_int_3\");\n+    gcc_jit_rvalue *rval3 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+    gcc_jit_global_set_initializer_rvalue (foo,\n+\trval3);\n+    gcc_jit_lvalue *bar =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      int_type,\n+      \"global_lvalueinit_int_3\");\n+    gcc_jit_global_set_initializer_rvalue (bar,\n+\t\t\t\t\t   gcc_jit_lvalue_as_rvalue (foo));\n+  }\n+  { /* int foo = 3 * 2;\n+       int arr[] = {1,2,3,4};\n+       int *bar = &arr[2] + 1\n+\n+       Example in the docs.\n+     */\n+\n+    gcc_jit_type *arr_type = gcc_jit_context_new_array_type (ctxt,\n+\t\t\t\t\t\t\t     0,\n+\t\t\t\t\t\t\t     int_type,\n+\t\t\t\t\t\t\t     4);\n+    gcc_jit_rvalue *rval_1 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 1);\n+    gcc_jit_rvalue *rval_2 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 2);\n+    gcc_jit_rvalue *rval_3 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+    gcc_jit_rvalue *rval_4 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 4);\n+\n+    gcc_jit_rvalue *values[] = {rval_1, rval_2, rval_3, rval_4};\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_array_constructor (ctxt,\n+\t\t\t\t\t\t\t\t  0,\n+\t\t\t\t\t\t\t\t  arr_type,\n+\t\t\t\t\t\t\t\t  4,\n+\t\t\t\t\t\t\t\t  values);\n+    gcc_jit_lvalue *global_intarr_1234 =\n+      gcc_jit_context_new_global (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_GLOBAL_EXPORTED,\n+\t\t\t\t  arr_type,\n+\t\t\t\t  \"global_intarr_1234_2\");\n+\n+    gcc_jit_global_set_initializer_rvalue (global_intarr_1234, ctor);\n+\n+    gcc_jit_lvalue *bar =\n+      gcc_jit_context_new_global (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_GLOBAL_EXPORTED,\n+\t\t\t\t  int_type,\n+\t\t\t\t  \"global_int_6\");\n+    gcc_jit_global_set_initializer_rvalue\n+      (bar,\n+       gcc_jit_context_new_binary_op\n+\t (ctxt, 0, GCC_JIT_BINARY_OP_MULT,\n+\t  int_type,\n+\t  gcc_jit_context_new_rvalue_from_int (ctxt, int_type, 3),\n+\t  gcc_jit_context_new_rvalue_from_int (ctxt, int_type, 2)));\n+\n+    gcc_jit_lvalue *pfoo =\n+      gcc_jit_context_new_global (ctxt, NULL,\n+\t\t\t\t  GCC_JIT_GLOBAL_EXPORTED,\n+\t\t\t\t  gcc_jit_type_get_pointer (int_type),\n+\t\t\t\t  \"global_pint_4\");\n+    /* int *bar = &arr[2] + 1;\n+\n+       In practice we could just do &foo[3]\n+       but just prove folding this works. */\n+    gcc_jit_global_set_initializer_rvalue (\n+       pfoo,\n+       gcc_jit_lvalue_get_address (\n+\t gcc_jit_context_new_array_access (\n+\t   ctxt, 0,\n+\t   gcc_jit_lvalue_get_address (\n+\t     gcc_jit_context_new_array_access (\n+\t       ctxt, 0,\n+\t       gcc_jit_lvalue_as_rvalue (global_intarr_1234),\n+\t       gcc_jit_context_new_rvalue_from_int (ctxt, int_type, 2)),\n+\t       0),\n+\t   gcc_jit_context_new_rvalue_from_int (ctxt, int_type, 1)),\n+\t   0));\n+  }\n+  { /*  static int bar = 11;\n+\tint foo () { return bar; } */\n+\n+    gcc_jit_lvalue *bar =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_INTERNAL,\n+      int_type,\n+      \"global_static_int_11\");\n+    gcc_jit_rvalue *rval1 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 11);\n+    gcc_jit_global_set_initializer_rvalue (bar,\n+\trval1);\n+\n+    gcc_jit_function *fn11 =\n+      gcc_jit_context_new_function (ctxt,\n+\t\t\t\t    0,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    int_type,\n+\t\t\t\t    \"fn_int_11\",\n+\t\t\t\t    0,\n+\t\t\t\t    0,\n+\t\t\t\t    0);\n+    gcc_jit_block *block = gcc_jit_function_new_block (fn11, \"start\");\n+\n+    gcc_jit_block_end_with_return (block,\n+\t\t\t\t   0,\n+\t\t\t\t   gcc_jit_lvalue_as_rvalue(bar));\n+  }\n+  { /* static const int cbar = 11;\n+       int cfoo () { return cbar; } */\n+\n+    gcc_jit_lvalue *bar =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_INTERNAL,\n+      gcc_jit_type_get_const (int_type),\n+      \"global_static_cint_11\");\n+    gcc_jit_rvalue *rval1 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 11);\n+    gcc_jit_global_set_initializer_rvalue (bar,\n+\trval1);\n+\n+    gcc_jit_function *fn11 =\n+      gcc_jit_context_new_function (ctxt,\n+\t\t\t\t    0,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    int_type,\n+\t\t\t\t    \"fn_cint_11\",\n+\t\t\t\t    0,\n+\t\t\t\t    0,\n+\t\t\t\t    0);\n+    gcc_jit_block *block = gcc_jit_function_new_block (fn11, \"start\");\n+\n+    gcc_jit_block_end_with_return (block,\n+\t\t\t\t   0,\n+\t\t\t\t   gcc_jit_lvalue_as_rvalue(bar));\n+  }\n+  { /* static const int cbar = 12;\n+       const int* cfoo () { return &cbar; } */\n+\n+    gcc_jit_lvalue *bar =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_INTERNAL,\n+      gcc_jit_type_get_const (int_type),\n+      \"global_static_cint_12\");\n+    gcc_jit_rvalue *rval1 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 12);\n+    gcc_jit_global_set_initializer_rvalue (bar,\n+\trval1);\n+\n+    gcc_jit_function *fn11 =\n+      gcc_jit_context_new_function (ctxt,\n+\t\t\t\t    0,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    gcc_jit_type_get_pointer(int_type),\n+\t\t\t\t    \"fn_cint_12\",\n+\t\t\t\t    0,\n+\t\t\t\t    0,\n+\t\t\t\t    0);\n+\n+    gcc_jit_block *block = gcc_jit_function_new_block (fn11, \"start\");\n+\n+    gcc_jit_block_end_with_return (block,\n+\t\t\t\t   0,\n+\t\t\t\t   gcc_jit_lvalue_get_address (bar, 0));\n+  }\n+  { /* const int foo = 3;\n+       short bar = (short)foo;\n+\n+       Assure casts fold\n+     */\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      gcc_jit_type_get_const (int_type),\n+      \"global_const_int_4\");\n+    gcc_jit_rvalue *rval3 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+    gcc_jit_global_set_initializer_rvalue (foo,\n+\trval3);\n+    gcc_jit_lvalue *bar =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      short_type,\n+      \"global_lvalueinit_short_3\");\n+    gcc_jit_global_set_initializer_rvalue (\n+      bar,\n+      gcc_jit_context_new_cast( ctxt, 0,\n+\t\t\t\tgcc_jit_lvalue_as_rvalue (foo),\n+\t\t\t\tshort_type));\n+  }\n+  { /* const int foo = 3;\n+       const int const *bar = &foo; */\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      gcc_jit_type_get_const (int_type),\n+      \"global_const_int_6\");\n+    gcc_jit_rvalue *rval3 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+    gcc_jit_global_set_initializer_rvalue (foo,\n+\trval3);\n+    gcc_jit_lvalue *bar =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      gcc_jit_type_get_const (\n+\tgcc_jit_type_get_pointer (\n+\t  gcc_jit_type_get_const (\n+\t    int_type))),\n+      \"global_lvalueinit_cpcint_3\");\n+    gcc_jit_global_set_initializer_rvalue (\n+      bar,\n+      gcc_jit_lvalue_get_address (foo, 0));\n+  }\n+  { /* const int __attribute__ ((aligned (64))) foo = 3;\n+       int bar = foo;\n+\n+       Assure alignement does not make the constant \"miss\"\n+       or something strange.\n+     */\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      gcc_jit_type_get_const (gcc_jit_type_get_aligned (int_type, 64)),\n+      \"global_const_int_7\");\n+    gcc_jit_rvalue *rval = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 4);\n+    gcc_jit_global_set_initializer_rvalue (foo,\n+\trval);\n+    gcc_jit_lvalue *bar =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      int_type,\n+      \"global_lvalueinit_int_4\");\n+    gcc_jit_global_set_initializer_rvalue (bar,\n+\t\t\t\t\t   gcc_jit_lvalue_as_rvalue (foo));\n+  }\n+  {\n+    /* union upintsize { size_t s; int *p } u = {.s = 0xEEEFBEEF}; */\n+    gcc_jit_field *f1 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t   0,\n+\t\t\t\t\t\t   size_type,\n+\t\t\t\t\t\t   \"s\");\n+    gcc_jit_field *f2 = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t   0,\n+\t\t\t\t\t\t   pint_type,\n+\t\t\t\t\t\t   \"p\");\n+    gcc_jit_field *fields1[] = {f1, f2};\n+\n+    gcc_jit_type *ubar = gcc_jit_context_new_union_type (ctxt,\n+\t\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t\t \"upintsize\",\n+\t\t\t\t\t\t\t 2,\n+\t\t\t\t\t\t\t fields1);\n+    gcc_jit_lvalue *foo =  gcc_jit_context_new_global (\n+      ctxt, NULL,\n+      GCC_JIT_GLOBAL_EXPORTED,\n+      gcc_jit_type_get_const (ubar),\n+      \"global_const_upintsize_1\");\n+\n+    gcc_jit_rvalue *val = gcc_jit_context_new_rvalue_from_long (\n+      ctxt, size_type, 0xEEEFBEEF);\n+\n+    gcc_jit_rvalue *ctor =\n+      gcc_jit_context_new_union_constructor (ctxt,\n+\t\t\t\t\t     0,\n+\t\t\t\t\t     ubar,\n+\t\t\t\t\t     f1,\n+\t\t\t\t\t     val);\n+\n+    gcc_jit_global_set_initializer_rvalue (foo, ctor);\n+  }\n+  {/*\n+      struct B;\n+      struct A { B* b; };\n+      struct B { A* a; };\n+      extern struct B b;\n+      struct A a = {.b = b};\n+      struct B b = {.a = a};\n+\n+      See that opaque structs and circular pointers works.\n+   */\n+\n+    gcc_jit_struct *struct_B =\n+      gcc_jit_context_new_opaque_struct(ctxt,\n+\t\t\t\t\t0, \"B\");\n+\n+    gcc_jit_field *fields_A[] =\n+      {\n+\tgcc_jit_context_new_field (ctxt, 0,\n+\t\t\t\t   gcc_jit_type_get_pointer (\n+\t\t\t\t     gcc_jit_struct_as_type (struct_B)),\n+\t\t\t\t   \"b\")\n+      };\n+\n+    gcc_jit_struct *struct_A =\n+      gcc_jit_context_new_struct_type(ctxt, 0, \"A\", 1, fields_A);\n+\n+    gcc_jit_field *fields_B[] =\n+      {\n+\tgcc_jit_context_new_field (ctxt, 0,\n+\t\t\t\t   gcc_jit_type_get_pointer (\n+\t\t\t\t     gcc_jit_struct_as_type (struct_A)),\n+\t\t\t\t   \"a\")\n+      };\n+\n+    gcc_jit_struct_set_fields (struct_B, 0, 1, fields_B);\n+\n+    gcc_jit_lvalue *a =\n+      gcc_jit_context_new_global (ctxt, 0, GCC_JIT_GLOBAL_EXPORTED,\n+\t\t\t\t  gcc_jit_struct_as_type (struct_A),\n+\t\t\t\t  \"a_glb\");\n+    gcc_jit_lvalue *b =\n+      gcc_jit_context_new_global (ctxt, 0, GCC_JIT_GLOBAL_EXPORTED,\n+\t\t\t\t  gcc_jit_struct_as_type (struct_B),\n+\t\t\t\t  \"b_glb\");\n+    gcc_jit_rvalue *b_addr = gcc_jit_lvalue_get_address( b, 0);\n+    gcc_jit_rvalue *a_ctor =\n+      gcc_jit_context_new_struct_constructor (ctxt, 0,\n+\t\t\t\t\t      gcc_jit_struct_as_type (struct_A),\n+\t\t\t\t\t      1, 0,\n+\t\t\t\t\t      &b_addr);\n+    gcc_jit_rvalue *a_addr = gcc_jit_lvalue_get_address( a, 0);\n+    gcc_jit_rvalue *b_ctor =\n+      gcc_jit_context_new_struct_constructor (ctxt, 0,\n+\t\t\t\t\t      gcc_jit_struct_as_type (struct_B),\n+\t\t\t\t\t      1, 0,\n+\t\t\t\t\t      &a_addr);\n+\n+    gcc_jit_global_set_initializer_rvalue(a, a_ctor);\n+    gcc_jit_global_set_initializer_rvalue(b, b_ctor);\n+  }\n+}\n+\n+struct fi {\n+  float f;\n+  int i;\n+};\n+\n+struct bar1 {\n+  float ff;\n+  struct fi fi;\n+  int ii;\n+};\n+\n+union ubar1 {\n+  float ff;\n+  int ii;\n+};\n+\n+union upintsize {\n+  size_t s;\n+  int *p;\n+};\n+\n+struct B_glb;\n+struct A_glb {\n+  struct B_glb *b;\n+};\n+struct B_glb {\n+  struct A_glb *a;\n+};\n+\n+int test_aligned64_works_in_linker_1 __attribute__ ((aligned (64))) = 0;\n+int test_aligned64_works_in_linker_2 __attribute__ ((aligned (64))) = 0;\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_NON_NULL (result);\n+\n+  {\n+    struct bar1 *bar =\n+      gcc_jit_result_get_global (result, \"global_struct_bar_1234_1\");\n+\n+    CHECK_VALUE (bar->ff, 1);\n+    CHECK_VALUE (bar->fi.f, 2);\n+    CHECK_VALUE (bar->fi.i, 3);\n+    CHECK_VALUE (bar->ii, 4);\n+  }\n+  {\n+    struct bar1 *bar =\n+      gcc_jit_result_get_global (result, \"global_struct_bar_1234_2\");\n+\n+    CHECK_VALUE (bar->ff, 1);\n+    CHECK_VALUE (bar->fi.f, 2);\n+    CHECK_VALUE (bar->fi.i, 3);\n+    CHECK_VALUE (bar->ii, 4);\n+  }\n+  {\n+    struct fi *fi = gcc_jit_result_get_global (result, \"global_struct_fi_23_1\");\n+\n+    CHECK_VALUE (fi->f, 2);\n+    CHECK_VALUE (fi->i, 3);\n+  }\n+  {\n+    struct fi *fi = gcc_jit_result_get_global (result, \"global_struct_fi_23_2\");\n+\n+    CHECK_VALUE (fi->f, 2);\n+    CHECK_VALUE (fi->i, 3);\n+  }\n+  {\n+    struct fi *fi = gcc_jit_result_get_global (result, \"global_struct_fi_00_1\");\n+\n+    CHECK_VALUE (fi->f, 0);\n+    CHECK_VALUE (fi->i, 0);\n+  }\n+  {\n+    struct fi *fi = gcc_jit_result_get_global (result, \"global_struct_fi_00_2\");\n+\n+    CHECK_VALUE (fi->f, 0);\n+    CHECK_VALUE (fi->i, 0);\n+  }\n+  {\n+    struct fi *fi = gcc_jit_result_get_global (result, \"global_struct_fi_0_1\");\n+\n+    CHECK_VALUE (fi->f, 0);\n+    CHECK_VALUE (fi->i, 0);\n+  }\n+  {\n+    struct fi *fi = gcc_jit_result_get_global (result, \"global_struct_fi_0_2\");\n+\n+    CHECK_VALUE (fi->f, 0);\n+    CHECK_VALUE (fi->i, 0);\n+  }\n+  {\n+    struct fi *fi = gcc_jit_result_get_global (result, \"global_struct_fi_6\");\n+\n+    CHECK_VALUE (fi->f, 0);\n+    CHECK_VALUE (fi->i, 0);\n+  }\n+  {\n+    struct fi *fi = gcc_jit_result_get_global (result, \"global_struct_fi_3\");\n+\n+    CHECK_VALUE (fi->f, 2 * 2);\n+    CHECK_VALUE (fi->i, 3);\n+  }\n+  {\n+    union ubar1 *foo = gcc_jit_result_get_global (result,\n+\t\t\t\t\t\t  \"global_union_ufoo_ff3\");\n+    CHECK_VALUE (foo->ff, 3);\n+  }\n+  {\n+    union ubar1 *foo = gcc_jit_result_get_global (result,\n+\t\t\t\t\t\t  \"global_union_ufoo_ii2\");\n+    CHECK_VALUE (foo->ii, 2);\n+  }\n+  {\n+    union ubar1 *foo = gcc_jit_result_get_global (result,\n+\t\t\t\t\t\t  \"global_union_ufoo_ff1c1\");\n+    CHECK_VALUE (foo->ff, 1.1f);\n+  }\n+  {\n+    union ubar1 *foo = gcc_jit_result_get_global (result,\n+\t\t\t\t\t\t  \"global_union_ufoo_0\");\n+    CHECK_VALUE (foo->ii, 0);\n+  }\n+  {\n+    int *foo = gcc_jit_result_get_global (result, \"global_int1_3\");\n+\n+    CHECK_VALUE (*foo, 3);\n+  }\n+  {\n+    int *foo = gcc_jit_result_get_global (result, \"global_cvint1_3\");\n+\n+    CHECK_VALUE (*foo, 3);\n+  }\n+  {\n+    int *foo = gcc_jit_result_get_global (result, \"global_int2_3\");\n+\n+    CHECK_VALUE (*foo, 3);\n+  }\n+  {\n+    int *foo = gcc_jit_result_get_global (result, \"global_int3_18\");\n+\n+    CHECK_VALUE (*foo, 18);\n+  }\n+  {\n+    int *foo = gcc_jit_result_get_global (result, \"global_int_alotofoperators\");\n+\n+    CHECK_VALUE (*foo, ~(-((((((2 | 8) & 15) ^ 0) << 3 >> 2) - 1) / 2)));\n+  }\n+  {\n+    int *foo = gcc_jit_result_get_global (result, \"global_int4_3\");\n+    int **pfoo = gcc_jit_result_get_global (result, \"global_pint5\");\n+\n+    CHECK_VALUE (*foo, 3);\n+    CHECK_VALUE (foo, *pfoo);\n+    CHECK_VALUE (**pfoo, 3);\n+  }\n+  {\n+    int * (*foo) (void) = gcc_jit_result_get_code (result, \"fn_pint_0\");\n+    int **pfoo = gcc_jit_result_get_global (result, \"global_pint6\");\n+\n+    CHECK_VALUE (*foo (), 0);\n+    CHECK_VALUE (foo (), *pfoo);\n+    CHECK_VALUE (**pfoo, 0);\n+  }\n+  {\n+    int *foo = gcc_jit_result_get_global (result, \"global_int6_3\");\n+    int **pfoo = gcc_jit_result_get_global (result, \"global_pint7\");\n+\n+    CHECK_VALUE (*foo, 3);\n+    CHECK_VALUE (foo + 1, *pfoo);\n+    CHECK_VALUE (*(*pfoo - 1), 3);\n+  }\n+  {\n+    double *foo = gcc_jit_result_get_global (result, \"global_double1_3\");\n+\n+    CHECK_VALUE (*foo, 3);\n+  }\n+  {\n+    double *foo = gcc_jit_result_get_global (result, \"global_double2_12\");\n+\n+    CHECK_VALUE (*foo, 12);\n+  }\n+  {\n+    _Bool *foo = gcc_jit_result_get_global (result, \"global_bool1_1\");\n+\n+    CHECK_VALUE (*foo, 1);\n+  }\n+  {\n+    int *foo = gcc_jit_result_get_global (result, \"global_intarr_1234\");\n+\n+    CHECK_VALUE (foo[0], 1);\n+    CHECK_VALUE (foo[1], 2);\n+    CHECK_VALUE (foo[2], 3);\n+    CHECK_VALUE (foo[3], 4);\n+  }\n+  {\n+    float *foo = gcc_jit_result_get_global (result, \"global_floatarr_12\");\n+\n+    CHECK_VALUE (foo[0], 1);\n+    CHECK_VALUE (foo[1], 2);\n+    CHECK_VALUE (foo[2], 0);\n+    CHECK_VALUE (foo[3], 0);\n+  }\n+  {\n+    float *foo = gcc_jit_result_get_global (result, \"global_floatarr_12_2\");\n+\n+    CHECK_VALUE (foo[0], 1);\n+    CHECK_VALUE (foo[1], 2);\n+    CHECK_VALUE (foo[2], 0);\n+    CHECK_VALUE (foo[3], 0);\n+  }\n+  {\n+    float *foo = gcc_jit_result_get_global (result, \"global_floatarr_120\");\n+\n+    CHECK_VALUE (foo[0], 1);\n+    CHECK_VALUE (foo[1], 2);\n+    CHECK_VALUE (foo[2], 0);\n+    CHECK_VALUE (foo[3], 0);\n+  }\n+  {\n+    float *foo = gcc_jit_result_get_global (result, \"global_floatarr_0000\");\n+\n+    CHECK_VALUE (foo[0], 0);\n+    CHECK_VALUE (foo[1], 0);\n+    CHECK_VALUE (foo[2], 0);\n+    CHECK_VALUE (foo[3], 0);\n+  }\n+  {\n+    float *foo = gcc_jit_result_get_global (result, \"global_floatarr_00305600\");\n+\n+    float key[] = {0,0,3,0,5,6,0,0};\n+\n+    CHECK_VALUE (memcmp (foo, key, sizeof key), 0);\n+  }\n+  {\n+    int **foo = gcc_jit_result_get_global (result, \"global_pintarr_x2xx\");\n+\n+    CHECK_VALUE (foo[0], 0);\n+    CHECK_VALUE (*foo[1], 2);\n+  }\n+  {\n+    char *foo = gcc_jit_result_get_global (result, \"global_chararr_qwe\");\n+    const char *key = \"qwe\";\n+    CHECK_VALUE (strcmp (foo, key), 0);\n+  }\n+  {\n+    int *foo = gcc_jit_result_get_global (result, \"global_int2x2matrix_1234\");\n+\n+    for (int i = 0; i < 4; i++)\n+      CHECK_VALUE (foo[i], i + 1);\n+  }\n+  {\n+    const char **foo =\n+      gcc_jit_result_get_global (result, \"global_cpchararr_qwe_asd\");\n+\n+    CHECK_VALUE (strcmp (foo[0], \"qwe\"), 0);\n+    CHECK_VALUE (strcmp (foo[1], \"asd\"), 0);\n+  }\n+  {\n+    int *foo = gcc_jit_result_get_global (result, \"global_lvalueinit_int_3\");\n+\n+    CHECK_VALUE (*foo, 3);\n+  }\n+  {\n+    int **pint =\n+      gcc_jit_result_get_global (result, \"global_pint_4\");\n+    int *foo =\n+      gcc_jit_result_get_global (result, \"global_int_6\");\n+    CHECK_VALUE (**pint, 4);\n+    CHECK_VALUE (*foo, 6);\n+  }\n+  {\n+    int (*fn)(void) = gcc_jit_result_get_code (result, \"fn_int_11\");\n+    CHECK_VALUE (fn (), 11);\n+  }\n+  {\n+    int (*fn)(void) = gcc_jit_result_get_code (result, \"fn_cint_11\");\n+    CHECK_VALUE (fn (), 11);\n+  }\n+  {\n+    int *(*fn)(void) = gcc_jit_result_get_code (result, \"fn_cint_12\");\n+    CHECK_VALUE (*fn (), 12);\n+  }\n+  {\n+    short *foo =\n+      gcc_jit_result_get_code (result, \"global_lvalueinit_short_3\");\n+    CHECK_VALUE (*foo, 3);\n+  }\n+  {\n+    int **foo =\n+      gcc_jit_result_get_code (result, \"global_lvalueinit_cpcint_3\");\n+    CHECK_VALUE (**foo, 3);\n+  }\n+  {\n+    int *foo =\n+      gcc_jit_result_get_code (result, \"global_lvalueinit_int_4\");\n+    CHECK_VALUE (*foo, 4);\n+\n+    int *bar =\n+      gcc_jit_result_get_code (result, \"global_const_int_7\");\n+    CHECK_VALUE (*bar, 4);\n+    /* The linker does not have to support up to 64 alignment, so test that\n+       it does before testing that it works in libgccjit. */\n+    if ((size_t) &test_aligned64_works_in_linker_1 % 64 == 0 &&\n+\t(size_t) &test_aligned64_works_in_linker_2 % 64 == 0)\n+      CHECK_VALUE ((size_t) bar % 64, 0); /* __attribute__ ((aligned (64))) */\n+  }\n+  {\n+    union upintsize *foo =\n+      gcc_jit_result_get_code (result, \"global_const_upintsize_1\");\n+    CHECK_VALUE (foo->p, (void*)0xEEEFBEEF);\n+  }\n+  {\n+    struct A_glb *a =\n+      gcc_jit_result_get_code (result, \"a_glb\");\n+    struct B_glb *b =\n+      gcc_jit_result_get_code (result, \"b_glb\");\n+\n+    CHECK_VALUE (a->b, b);\n+    CHECK_VALUE (b->a, a);\n+  }\n+}"}, {"sha": "1d74679c07c06d6ca0725c7d8045f6150fa481c8", "filename": "gcc/testsuite/jit.dg/test-local-init-rvalue.c", "status": "added", "additions": 707, "deletions": 0, "changes": 707, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-local-init-rvalue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3736837806fdb26daa51300bee1554bef89db9fe/gcc%2Ftestsuite%2Fjit.dg%2Ftest-local-init-rvalue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-local-init-rvalue.c?ref=3736837806fdb26daa51300bee1554bef89db9fe", "patch": "@@ -0,0 +1,707 @@\n+#include <stdio.h>\n+#include \"libgccjit.h\"\n+#include \"harness.h\"\n+\n+/* This testcase checks that gcc_jit_context_new_constructor() works\n+   with locals. Tests that constructors can be used as return\n+   values or function call values. Test that constructors can have side\n+   effects and be assigned to locals.\n+ */\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_type *int_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_INT);\n+  gcc_jit_type *pint_type = gcc_jit_type_get_pointer (int_type);\n+  gcc_jit_type *double_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_DOUBLE);\n+  gcc_jit_type *float_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_FLOAT);\n+  gcc_jit_type *bool_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_BOOL);\n+  gcc_jit_type *char_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_CHAR);\n+  gcc_jit_type *size_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_SIZE_T);\n+  gcc_jit_type *voidptr_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_VOID_PTR);\n+  gcc_jit_type *void_type = gcc_jit_context_get_type (ctxt,\n+    GCC_JIT_TYPE_VOID);\n+\n+  /* Make a struct: struct fi { float f; int i;} */\n+  gcc_jit_field *fi_f = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t float_type,\n+\t\t\t\t\t\t \"f\");\n+  gcc_jit_field *fi_i = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t int_type,\n+\t\t\t\t\t\t \"i\");\n+  gcc_jit_field *fields[] = {fi_f, fi_i};\n+\n+  gcc_jit_type *struct_fi_type =\n+    gcc_jit_struct_as_type (\n+      gcc_jit_context_new_struct_type (ctxt,\n+\t\t\t\t       0,\n+\t\t\t\t       \"fi\",\n+\t\t\t\t       2,\n+\t\t\t\t       fields));\n+\n+  /* Make a struct:\n+\n+     struct bar {\n+       int ii;\n+       int arr[50];\n+       float ff;\n+       char cc;\n+     }\n+  */\n+  gcc_jit_field *bar_ff = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t  0,\n+\t\t\t\t  float_type,\n+\t\t\t\t  \"ff\");\n+  gcc_jit_field *bar_ii = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t  0,\n+\t\t\t\t  int_type,\n+\t\t\t\t  \"ii\");\n+  gcc_jit_field *bar_cc = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t  0,\n+\t\t\t\t  char_type,\n+\t\t\t\t  \"cc\");\n+  gcc_jit_type *int50arr_type =\n+    gcc_jit_context_new_array_type (ctxt,\n+\t\t\t\t    0,\n+\t\t\t\t    int_type,\n+\t\t\t\t    50);\n+  gcc_jit_field *bar_fi = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t 0,\n+\t\t\t\t\t\t int50arr_type,\n+\t\t\t\t\t\t \"arr\");\n+  gcc_jit_field *fields2[] = {bar_ff, bar_fi, bar_ii, bar_cc};\n+\n+  gcc_jit_type *struct_bar_type =\n+    gcc_jit_struct_as_type (\n+      gcc_jit_context_new_struct_type (ctxt,\n+\t\t\t\t       0,\n+\t\t\t\t       \"bar\",\n+\t\t\t\t       4,\n+\t\t\t\t       fields2));\n+\n+  /* Make an union:\n+\n+     union ubar {\n+       float ff;\n+       int ii;\n+     };\n+  */\n+  gcc_jit_field *ubar_ff = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t      0,\n+\t\t\t\t\t\t      float_type,\n+\t\t\t\t\t\t      \"ff\");\n+  gcc_jit_field *ubar_ii = gcc_jit_context_new_field (ctxt,\n+\t\t\t\t\t\t      0,\n+\t\t\t\t\t\t      int_type,\n+\t\t\t\t\t\t      \"ii\");\n+  gcc_jit_field *fields3[] = {ubar_ff, ubar_ii};\n+  gcc_jit_type *ubar = gcc_jit_context_new_union_type (ctxt,\n+\t\t\t\t\t\t       0,\n+\t\t\t\t\t\t       \"ubar\",\n+\t\t\t\t\t\t       2,\n+\t\t\t\t\t\t       fields3);\n+\n+  (void) ubar;\n+  (void) struct_bar_type;\n+  (void) struct_fi_type;\n+  (void) bool_type;\n+  (void) double_type;\n+  (void) pint_type;\n+  (void) voidptr_type;\n+  (void) size_type;\n+\n+  gcc_jit_function *fn_int_3;\n+  { /* int foo () { int local = 3; return local;} */\n+    fn_int_3 =\n+      gcc_jit_context_new_function (ctxt,\n+\t\t\t\t    0,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    int_type,\n+\t\t\t\t    \"fn_int_3\",\n+\t\t\t\t    0,\n+\t\t\t\t    0,\n+\t\t\t\t    0);\n+    gcc_jit_block *block = gcc_jit_function_new_block (fn_int_3, \"start\");\n+    gcc_jit_lvalue *local = gcc_jit_function_new_local (fn_int_3,\n+\t\t\t\t\t\t\t0,\n+\t\t\t\t\t\t\tint_type,\n+\t\t\t\t\t\t\t\"local\");\n+    gcc_jit_rvalue *rval = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 3);\n+\n+    gcc_jit_block_add_assignment (block, 0, local, rval);\n+\n+    gcc_jit_block_end_with_return (block,\n+\t\t\t\t   0,\n+\t\t\t\t   gcc_jit_lvalue_as_rvalue(local));\n+  }\n+  { /* struct fi foo() { return (struct fi){1,2};} */\n+    gcc_jit_function *fn =\n+      gcc_jit_context_new_function (ctxt,\n+\t\t\t\t    0,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    struct_fi_type,\n+\t\t\t\t    \"fn_fi_1_2\",\n+\t\t\t\t    0,\n+\t\t\t\t    0,\n+\t\t\t\t    0);\n+    gcc_jit_block *block = gcc_jit_function_new_block (fn, \"start\");\n+\n+    gcc_jit_rvalue *rval_f1 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 1);\n+    gcc_jit_rvalue *rval_i2 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 2);\n+\n+    gcc_jit_rvalue *vals[] = { rval_f1, rval_i2};\n+    gcc_jit_field *fields[] = {fi_f, fi_i};\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+      (ctxt, 0,\n+       struct_fi_type,\n+       2,\n+       fields,\n+       vals);\n+\n+    gcc_jit_block_end_with_return (block,\n+\t\t\t\t   0,\n+\t\t\t\t   ctor);\n+  }\n+  { /*\n+       struct fi foo()\n+       {\n+\t struct fi local = {1,2};\n+\t local = (struct fi){5,6};\n+\t return local;\n+       }\n+     */\n+    gcc_jit_function *fn =\n+      gcc_jit_context_new_function (ctxt,\n+\t\t\t\t    0,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    struct_fi_type,\n+\t\t\t\t    \"fn_fi_5_6\",\n+\t\t\t\t    0,\n+\t\t\t\t    0,\n+\t\t\t\t    0);\n+    gcc_jit_lvalue *local = gcc_jit_function_new_local (fn,\n+\t\t\t\t\t\t\t0,\n+\t\t\t\t\t\t\tstruct_fi_type,\n+\t\t\t\t\t\t\t\"local\");\n+    gcc_jit_block *block = gcc_jit_function_new_block (fn, \"start\");\n+\n+    {\n+      gcc_jit_rvalue *rval_f1 =\n+\tgcc_jit_context_new_rvalue_from_int (ctxt, float_type, 1);\n+      gcc_jit_rvalue *rval_i2 =\n+\tgcc_jit_context_new_rvalue_from_int (ctxt, int_type, 2);\n+\n+      gcc_jit_rvalue *vals[] = { rval_f1, rval_i2};\n+      gcc_jit_field *fields[] = {fi_f, fi_i};\n+\n+      gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+\t(ctxt, 0,\n+\t struct_fi_type,\n+\t 2,\n+\t fields,\n+\t vals);\n+      gcc_jit_block_add_assignment (block, 0, local, ctor);\n+    }\n+    {\n+      gcc_jit_rvalue *rval_f1 =\n+\tgcc_jit_context_new_rvalue_from_int (ctxt, float_type, 5);\n+      gcc_jit_rvalue *rval_i2 =\n+\tgcc_jit_context_new_rvalue_from_int (ctxt, int_type, 6);\n+\n+      gcc_jit_rvalue *vals[] = { rval_f1, rval_i2};\n+      gcc_jit_field *fields[] = {fi_f, fi_i};\n+\n+      gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+\t(ctxt, 0,\n+\t struct_fi_type,\n+\t 2,\n+\t fields,\n+\t vals);\n+      gcc_jit_block_add_assignment (block, 0, local, ctor);\n+    }\n+\n+    gcc_jit_block_end_with_return (block,\n+\t\t\t\t   0,\n+\t\t\t\t   gcc_jit_lvalue_as_rvalue(local));\n+  }\n+  { /* struct fi foo() { struct fi local = {1, fn_int_3()};\n+\t\t\t return local;}\n+\n+       The ctor has a side effect (funccall) */\n+    gcc_jit_function *fn =\n+      gcc_jit_context_new_function (ctxt,\n+\t\t\t\t    0,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    struct_fi_type,\n+\t\t\t\t    \"fn_fi_1_3\",\n+\t\t\t\t    0,\n+\t\t\t\t    0,\n+\t\t\t\t    0);\n+    gcc_jit_lvalue *local = gcc_jit_function_new_local (fn,\n+\t\t\t\t\t\t\t0,\n+\t\t\t\t\t\t\tstruct_fi_type,\n+\t\t\t\t\t\t\t\"local\");\n+    gcc_jit_block *block = gcc_jit_function_new_block (fn, \"start\");\n+\n+    {\n+      gcc_jit_rvalue *rval_f1 =\n+\tgcc_jit_context_new_rvalue_from_int (ctxt, float_type, 1);\n+      gcc_jit_rvalue *rval_i2 =\n+\tgcc_jit_context_new_call (ctxt, 0, fn_int_3, 0, 0);\n+\n+      gcc_jit_rvalue *vals[] = { rval_f1, rval_i2};\n+      gcc_jit_field *fields[] = {fi_f, fi_i};\n+\n+      gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+\t(ctxt, 0,\n+\t struct_fi_type,\n+\t 2,\n+\t fields,\n+\t vals);\n+      gcc_jit_block_add_assignment (block, 0, local, ctor);\n+    }\n+\n+    gcc_jit_block_end_with_return (block,\n+\t\t\t\t   0,\n+\t\t\t\t   gcc_jit_lvalue_as_rvalue(local));\n+  }\n+  { /* struct fi foo(fi) { return fi;}\n+       struct fi bar() { return foo((struct fi){3, 4}); }\n+     */\n+\n+    gcc_jit_param *fi_param =\n+      gcc_jit_context_new_param (ctxt, 0, struct_fi_type, \"fi\");\n+\n+    gcc_jit_function *fn0 =\n+      gcc_jit_context_new_function (ctxt,\n+\t\t\t\t    0,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    struct_fi_type,\n+\t\t\t\t    \"fn_fi_x_x\",\n+\t\t\t\t    1,\n+\t\t\t\t    &fi_param,\n+\t\t\t\t    0);\n+    gcc_jit_block *block0 = gcc_jit_function_new_block (fn0, \"start\");\n+    gcc_jit_block_end_with_return (block0,\n+\t\t\t\t   0,\n+\t\t\t\t   gcc_jit_param_as_rvalue (\n+\t\t\t\t     gcc_jit_function_get_param (fn0, 0)));\n+\n+    gcc_jit_function *fn =\n+      gcc_jit_context_new_function (ctxt,\n+\t\t\t\t    0,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    struct_fi_type,\n+\t\t\t\t    \"fn_fi_3_4\",\n+\t\t\t\t    0,\n+\t\t\t\t    0,\n+\t\t\t\t    0);\n+    gcc_jit_block *block = gcc_jit_function_new_block (fn, \"start\");\n+\n+    gcc_jit_rvalue *rval_f1 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, float_type, 3);\n+    gcc_jit_rvalue *rval_i2 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 4);\n+\n+    gcc_jit_rvalue *vals[] = { rval_f1, rval_i2};\n+    gcc_jit_field *fields[] = {fi_f, fi_i};\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+      (ctxt, 0,\n+       struct_fi_type,\n+       2,\n+       fields,\n+       vals);\n+\n+    gcc_jit_rvalue *call = gcc_jit_context_new_call (ctxt, 0, fn0, 1, &ctor);\n+\n+    gcc_jit_block_end_with_return (block,\n+\t\t\t\t   0,\n+\t\t\t\t   call);\n+  }\n+  { /*\n+       void foo(struct bar *b) { *b = (struct bar) {.arr = {1,2}; }\n+     */\n+\n+    gcc_jit_param *param =\n+      gcc_jit_context_new_param (ctxt, 0,\n+\t\t\t\t gcc_jit_type_get_pointer (struct_bar_type),\n+\t\t\t\t \"b\");\n+\n+\n+    gcc_jit_function *fn =\n+      gcc_jit_context_new_function (ctxt,\n+\t\t\t\t    0,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    void_type,\n+\t\t\t\t    \"fn_pbar_12\",\n+\t\t\t\t    1,\n+\t\t\t\t    &param,\n+\t\t\t\t    0);\n+    gcc_jit_block *block = gcc_jit_function_new_block (fn, \"start\");\n+\n+    gcc_jit_rvalue *rval_i1 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 1);\n+    gcc_jit_rvalue *rval_i2 = gcc_jit_context_new_rvalue_from_int (\n+      ctxt, int_type, 2);\n+\n+    gcc_jit_rvalue *arr_vals[] = { rval_i1, rval_i2};\n+\n+    gcc_jit_rvalue *arr_ctor = gcc_jit_context_new_array_constructor\n+      (ctxt, 0,\n+       int50arr_type,\n+       2,\n+       arr_vals);\n+\n+    gcc_jit_rvalue *str_ctor = gcc_jit_context_new_struct_constructor\n+      (ctxt,\n+       0,\n+       struct_bar_type,\n+       1,\n+       &bar_fi,\n+       &arr_ctor);\n+\n+    gcc_jit_param *p0 = gcc_jit_function_get_param (fn, 0);\n+    gcc_jit_lvalue *lv0 =  gcc_jit_param_as_lvalue (p0);\n+    gcc_jit_lvalue *deref =\n+      gcc_jit_rvalue_dereference (gcc_jit_lvalue_as_rvalue (lv0), 0);\n+\n+    gcc_jit_block_add_assignment (block, 0,\n+\t\t\t\t  deref,\n+\t\t\t\t  str_ctor);\n+\n+    gcc_jit_block_end_with_void_return (block, 0);\n+  }\n+  { /* struct bar foo() { struct bar local = {};\n+\t\t\t  return local;}\n+     */\n+    gcc_jit_function *fn =\n+      gcc_jit_context_new_function (ctxt,\n+\t\t\t\t    0,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    struct_bar_type,\n+\t\t\t\t    \"fn_bar_0s\",\n+\t\t\t\t    0,\n+\t\t\t\t    0,\n+\t\t\t\t    0);\n+    gcc_jit_lvalue *local =\n+      gcc_jit_function_new_local (fn,\n+\t\t\t\t  0,\n+\t\t\t\t  struct_bar_type,\n+\t\t\t\t  \"local\");\n+    gcc_jit_block *block = gcc_jit_function_new_block (fn, \"start\");\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_struct_constructor\n+\t(ctxt, 0,\n+\t struct_bar_type,\n+\t 0,\n+\t 0,\n+\t 0);\n+    gcc_jit_block_add_assignment (block, 0, local, ctor);\n+\n+    gcc_jit_block_end_with_return (block,\n+\t\t\t\t   0,\n+\t\t\t\t   gcc_jit_lvalue_as_rvalue(local));\n+  }\n+  { /* struct bar foo() { struct bar local;\n+\t\t\t  local.arr = (int [50]){1,2,3,4,5,6};\n+\t\t\t  return local;}\n+     */\n+    gcc_jit_function *fn =\n+      gcc_jit_context_new_function (ctxt,\n+\t\t\t\t    0,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    struct_bar_type,\n+\t\t\t\t    \"fn_bar_123s\",\n+\t\t\t\t    0,\n+\t\t\t\t    0,\n+\t\t\t\t    0);\n+    gcc_jit_lvalue *local =\n+      gcc_jit_function_new_local (fn,\n+\t\t\t\t  0,\n+\t\t\t\t  struct_bar_type,\n+\t\t\t\t  \"local\");\n+    gcc_jit_block *block = gcc_jit_function_new_block (fn, \"start\");\n+\n+    gcc_jit_rvalue *values[6];\n+\n+    for (int i = 0; i < 6; i++)\n+      values[i] = gcc_jit_context_new_rvalue_from_int (ctxt, int_type, i + 1);\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_array_constructor\n+\t(ctxt, 0,\n+\t int50arr_type,\n+\t 6,\n+\t values);\n+\n+    gcc_jit_lvalue *arr_lv = gcc_jit_lvalue_access_field (local,\n+\t\t\t\t\t\t\t  0,\n+\t\t\t\t\t\t\t  bar_fi);\n+    gcc_jit_block_add_assignment (block, 0, arr_lv, ctor);\n+\n+    gcc_jit_block_end_with_return (block,\n+\t\t\t\t   0,\n+\t\t\t\t   gcc_jit_lvalue_as_rvalue(local));\n+  }\n+  { /* int[50] foo() { int arr[50];\n+\t\t       arr = (int [50]){1,2,3,4,5,6};\n+\t\t       return arr;}\n+\n+       N.B: Not a typo, returning an array.\n+     */\n+    gcc_jit_function *fn =\n+      gcc_jit_context_new_function (ctxt,\n+\t\t\t\t    0,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    int50arr_type,\n+\t\t\t\t    \"fn_int50arr_123s\",\n+\t\t\t\t    0,\n+\t\t\t\t    0,\n+\t\t\t\t    0);\n+    gcc_jit_lvalue *local =\n+      gcc_jit_function_new_local (fn,\n+\t\t\t\t  0,\n+\t\t\t\t  int50arr_type,\n+\t\t\t\t  \"local\");\n+    gcc_jit_block *block = gcc_jit_function_new_block (fn, \"start\");\n+\n+    gcc_jit_rvalue *values[6];\n+\n+    for (int i = 0; i < 6; i++)\n+      values[i] = gcc_jit_context_new_rvalue_from_int (ctxt, int_type, i + 1);\n+\n+    gcc_jit_rvalue *ctor = gcc_jit_context_new_array_constructor (\n+\t ctxt,\n+\t 0,\n+\t int50arr_type,\n+\t 6,\n+\t values);\n+\n+    gcc_jit_block_add_assignment (block, 0, local, ctor);\n+\n+    gcc_jit_block_end_with_return (block,\n+\t\t\t\t   0,\n+\t\t\t\t   gcc_jit_lvalue_as_rvalue(local));\n+  }\n+  { /*\n+      Verify that circular linked lists compiles, .e.g.\n+      that visit_children does not run in circles or something.\n+\n+      struct llist { struct llist *next; };\n+\n+      bool foo (void)\n+      {\n+\tvolatile struct llist a;\n+\tvolatile struct llist b;\n+\n+\ta = (struct llist) {.next = &b};\n+\tb = (struct llist) {.next = &a};\n+\n+\treturn a.next == &b;\n+      }\n+    */\n+    gcc_jit_struct *llist =\n+      gcc_jit_context_new_opaque_struct(ctxt,\n+\t\t\t\t\t0, \"llist_lcl\");\n+    gcc_jit_field *fields[] =\n+      {\n+\tgcc_jit_context_new_field (ctxt, 0,\n+\t\t\t\t   gcc_jit_type_get_pointer (\n+\t\t\t\t     gcc_jit_struct_as_type (llist)),\n+\t\t\t\t   \"next\")\n+      };\n+    gcc_jit_struct_set_fields (llist, 0, 1, fields);\n+    gcc_jit_type *t_llist = gcc_jit_struct_as_type (llist);\n+\n+    gcc_jit_function *fn =\n+      gcc_jit_context_new_function (ctxt,\n+\t\t\t\t    0,\n+\t\t\t\t    GCC_JIT_FUNCTION_EXPORTED,\n+\t\t\t\t    bool_type,\n+\t\t\t\t    \"fn_llist\",\n+\t\t\t\t    0,\n+\t\t\t\t    0,\n+\t\t\t\t    0);\n+    gcc_jit_block *block = gcc_jit_function_new_block (fn, \"start\");\n+\n+    gcc_jit_lvalue *a =\n+      gcc_jit_function_new_local (fn,\n+\t\t\t\t  0,\n+\t\t\t\t  gcc_jit_type_get_volatile (t_llist),\n+\t\t\t\t  \"a\");\n+    gcc_jit_lvalue *b =\n+      gcc_jit_function_new_local (fn,\n+\t\t\t\t  0,\n+\t\t\t\t  gcc_jit_type_get_volatile (t_llist),\n+\t\t\t\t  \"b\");\n+\n+    gcc_jit_rvalue *a_addr = gcc_jit_lvalue_get_address( a, 0);\n+    gcc_jit_rvalue *b_addr = gcc_jit_lvalue_get_address( b, 0);\n+\n+    gcc_jit_rvalue *a_ctor = gcc_jit_context_new_struct_constructor (\n+\t ctxt,\n+\t 0,\n+\t t_llist,\n+\t 1,\n+\t 0,\n+\t &b_addr);\n+\n+    gcc_jit_rvalue *b_ctor = gcc_jit_context_new_struct_constructor (\n+\t ctxt,\n+\t 0,\n+\t t_llist,\n+\t 1,\n+\t 0,\n+\t &a_addr);\n+\n+    gcc_jit_block_add_assignment (block, 0,\n+\t\t\t\t  a, a_ctor);\n+    gcc_jit_block_add_assignment (block, 0,\n+\t\t\t\t  b, b_ctor);\n+\n+    gcc_jit_rvalue *cmp =\n+      gcc_jit_context_new_comparison (\n+\tctxt, 0,\n+\tGCC_JIT_COMPARISON_EQ,\n+\tgcc_jit_rvalue_access_field (gcc_jit_lvalue_as_rvalue (a),\n+\t\t\t\t     0, fields[0]),\n+\tgcc_jit_context_new_cast (ctxt, 0,\n+\t\t\t\t  gcc_jit_lvalue_get_address (b, 0),\n+\t\t\t\t  gcc_jit_type_get_pointer (t_llist)));\n+\n+    gcc_jit_block_end_with_return (block,\n+\t\t\t\t   0, cmp);\n+  }\n+}\n+\n+struct fi2 {\n+  float f;\n+  int i;\n+};\n+\n+struct bar2 {\n+  float ff;\n+  int arr[50];\n+  int ii;\n+  char c;\n+};\n+\n+union ubar2 {\n+  float ff;\n+  int ii;\n+};\n+\n+struct int50arr {\n+  int arr[50];\n+};\n+\n+void __attribute__((optimize(0)))\n+scramble_stack(void)\n+  {\n+    char *p = alloca(100);\n+    for (int i = 0; i < 100; i++)\n+      *p++ = 0xF0;\n+    asm(\"\"); /* Mark for side-effect */\n+  }\n+\n+void __attribute__((optimize(0)))\n+scramble_arr (char *arr, int len)\n+{\n+  for (int i = 0; i < len; i++)\n+    *arr++ = i;\n+  asm(\"\"); /* Mark for side-effect */\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_NON_NULL (result);\n+\n+  {\n+    struct fi2 (*fn) (void) = gcc_jit_result_get_code (result, \"fn_fi_1_2\");\n+    scramble_stack ();\n+    struct fi2 fi = fn ();\n+    CHECK_VALUE (fi.f, 1);\n+    CHECK_VALUE (fi.i, 2);\n+  }\n+  {\n+    struct fi2 (*fn) (void) = gcc_jit_result_get_code (result, \"fn_fi_5_6\");\n+    struct fi2 fi = fn ();\n+    CHECK_VALUE (fi.f, 5);\n+    CHECK_VALUE (fi.i, 6);\n+  }\n+  {\n+    struct fi2 (*fn) (void) = gcc_jit_result_get_code (result, \"fn_fi_1_3\");\n+    struct fi2 fi = fn ();\n+    CHECK_VALUE (fi.f, 1);\n+    CHECK_VALUE (fi.i, 3);\n+  }\n+  {\n+    struct fi2 (*fn) (void) = gcc_jit_result_get_code (result, \"fn_fi_3_4\");\n+    struct fi2 fi = fn ();\n+    CHECK_VALUE (fi.f, 3);\n+    CHECK_VALUE (fi.i, 4);\n+  }\n+  {\n+    scramble_stack();\n+    struct bar2 (*fn) (void) = gcc_jit_result_get_code (result, \"fn_bar_0s\");\n+    struct bar2 bar = fn ();\n+    struct bar2 key = {};\n+\n+    CHECK_VALUE (bar.ff, 0);\n+    CHECK_VALUE (bar.ii, 0);\n+    CHECK_VALUE (memcmp (&bar.arr, &key.arr, sizeof (key.arr)), 0);\n+  }\n+  {\n+\n+    void (*fn) (struct bar2 *) = gcc_jit_result_get_code (result, \"fn_pbar_12\");\n+\n+    struct bar2 bar = (struct bar2) {};\n+\n+    scramble_arr ((char*)&bar, sizeof bar);\n+    scramble_stack();\n+\n+    fn (&bar);\n+\n+    struct bar2 key = {.arr = {1,2}};\n+    __builtin_clear_padding (&key);\n+\n+    CHECK_VALUE (memcmp (&bar, &key, sizeof (key)), 0);\n+  }\n+  {\n+    scramble_stack();\n+    struct bar2 (*fn) (void) = gcc_jit_result_get_code (result, \"fn_bar_123s\");\n+    struct bar2 bar = fn ();\n+    struct bar2 key = {.arr = {1,2,3,4,5,6} };\n+\n+    CHECK_VALUE (memcmp (&bar.arr, &key.arr, sizeof (key.arr)), 0);\n+  }\n+  {\n+    scramble_stack ();\n+    /* This is abit shady. Lets just pretend that array returns \u00e0 la Fortran\n+       is the same thing as returning a struct with an array in it in C. */\n+    struct int50arr (*fn) (void) =\n+      gcc_jit_result_get_code (result, \"fn_int50arr_123s\");\n+    struct int50arr ans = fn ();\n+    int key[50] = {1,2,3,4,5,6};\n+\n+    CHECK_VALUE (memcmp (ans.arr, key, sizeof (key)), 0);\n+  }\n+  {\n+    _Bool (*fn) (void) = gcc_jit_result_get_code (result, \"fn_llist\");\n+    CHECK_VALUE (fn (), 1);\n+  }\n+}"}]}