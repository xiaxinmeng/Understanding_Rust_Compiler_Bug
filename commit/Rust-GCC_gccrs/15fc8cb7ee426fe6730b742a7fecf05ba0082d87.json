{"sha": "15fc8cb7ee426fe6730b742a7fecf05ba0082d87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVmYzhjYjdlZTQyNmZlNjczMGI3NDJhN2ZlY2YwNWJhMDA4MmQ4Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T08:04:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T08:04:26Z"}, "message": "[multiple changes]\n\n2017-04-25  Bob Duff  <duff@adacore.com>\n\n\t* s-osinte-linux.ads (pthread_mutexattr_setprotocol,\n\tpthread_mutexattr_setprioceiling): Add new interfaces for these\n\tpthread operations.\n\t* s-taprop-linux.adb (Initialize_Lock, Initialize_TCB): Set\n\tprotocols as appropriate for Locking_Policy 'C' and 'I'.\n\t* s-taprop-posix.adb: Minor reformatting to make it more similar\n\tto s-taprop-linux.adb.\n\n2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Get_Discriminant_Value, Search_Derivation_Levels):\n\tHandle properly a multi- level derivation involving both renamed\n\tand constrained parent discriminants, when the type to be\n\tconstrained has fewer discriminants that the ultimate ancestor.\n\n2017-04-25  Bob Duff  <duff@adacore.com>\n\n\t* sem_util.adb (Is_Object_Reference): In the\n\tcase of N_Explicit_Dereference, return False if it came from a\n\tconditional expression.\n\n2017-04-25  Bob Duff  <duff@adacore.com>\n\n\t* par-ch4.adb (P_Case_Expression): If a semicolon\n\tis followed by \"when\", assume that \";\" was meant to be \",\".\n\nFrom-SVN: r247139", "tree": {"sha": "eb02414acaa1e65bd9d939345990675a14ecf64c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb02414acaa1e65bd9d939345990675a14ecf64c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15fc8cb7ee426fe6730b742a7fecf05ba0082d87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15fc8cb7ee426fe6730b742a7fecf05ba0082d87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15fc8cb7ee426fe6730b742a7fecf05ba0082d87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15fc8cb7ee426fe6730b742a7fecf05ba0082d87/comments", "author": null, "committer": null, "parents": [{"sha": "611d5e3c8275011282ac59e75ff3bc22ac50951a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/611d5e3c8275011282ac59e75ff3bc22ac50951a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/611d5e3c8275011282ac59e75ff3bc22ac50951a"}], "stats": {"total": 254, "additions": 214, "deletions": 40}, "files": [{"sha": "e06d7585e239aafdb6a68a48b7eb85c43b67b9fc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15fc8cb7ee426fe6730b742a7fecf05ba0082d87/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15fc8cb7ee426fe6730b742a7fecf05ba0082d87/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=15fc8cb7ee426fe6730b742a7fecf05ba0082d87", "patch": "@@ -1,3 +1,31 @@\n+2017-04-25  Bob Duff  <duff@adacore.com>\n+\n+\t* s-osinte-linux.ads (pthread_mutexattr_setprotocol,\n+\tpthread_mutexattr_setprioceiling): Add new interfaces for these\n+\tpthread operations.\n+\t* s-taprop-linux.adb (Initialize_Lock, Initialize_TCB): Set\n+\tprotocols as appropriate for Locking_Policy 'C' and 'I'.\n+\t* s-taprop-posix.adb: Minor reformatting to make it more similar\n+\tto s-taprop-linux.adb.\n+\n+2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Get_Discriminant_Value, Search_Derivation_Levels):\n+\tHandle properly a multi- level derivation involving both renamed\n+\tand constrained parent discriminants, when the type to be\n+\tconstrained has fewer discriminants that the ultimate ancestor.\n+\n+2017-04-25  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_util.adb (Is_Object_Reference): In the\n+\tcase of N_Explicit_Dereference, return False if it came from a\n+\tconditional expression.\n+\n+2017-04-25  Bob Duff  <duff@adacore.com>\n+\n+\t* par-ch4.adb (P_Case_Expression): If a semicolon\n+\tis followed by \"when\", assume that \";\" was meant to be \",\".\n+\n 2017-04-25  Gary Dismukes  <dismukes@adacore.com>\n \n \t* sem_ch9.adb, sem_ch10.adb, sem_util.adb: Minor reformatting and typo"}, {"sha": "4e6c8a765dc74f87fee5bcf56c1984ccc134bb9a", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15fc8cb7ee426fe6730b742a7fecf05ba0082d87/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15fc8cb7ee426fe6730b742a7fecf05ba0082d87/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=15fc8cb7ee426fe6730b742a7fecf05ba0082d87", "patch": "@@ -3199,6 +3199,20 @@ package body Ch4 is\n          if Token = Tok_When then\n             T_Comma;\n \n+         --  A semicolon followed by \"when\" is probably meant to be a comma\n+\n+         elsif Token = Tok_Semicolon then\n+            Save_Scan_State (Save_State);\n+            Scan; -- past the semicolon\n+\n+            if Token /= Tok_When then\n+               Restore_Scan_State (Save_State);\n+               exit;\n+            end if;\n+\n+            Error_Msg_SP -- CODEFIX\n+              (\"|\"\";\"\" should be \"\",\"\"\");\n+\n          --  If comma/WHEN, skip comma and we have another alternative\n \n          elsif Token = Tok_Comma then"}, {"sha": "fa1e060405afd06feb2443dbe6cac35ac3e391e8", "filename": "gcc/ada/s-osinte-linux.ads", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15fc8cb7ee426fe6730b742a7fecf05ba0082d87/gcc%2Fada%2Fs-osinte-linux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15fc8cb7ee426fe6730b742a7fecf05ba0082d87/gcc%2Fada%2Fs-osinte-linux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-linux.ads?ref=15fc8cb7ee426fe6730b742a7fecf05ba0082d87", "patch": "@@ -452,6 +452,20 @@ package System.OS_Interface is\n    -- POSIX.1c  Section 13 --\n    --------------------------\n \n+   PTHREAD_PRIO_NONE    : constant := 0;\n+   PTHREAD_PRIO_INHERIT : constant := 1;\n+   PTHREAD_PRIO_PROTECT : constant := 2;\n+\n+   function pthread_mutexattr_setprotocol\n+     (attr     : access pthread_mutexattr_t;\n+      protocol : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprotocol);\n+\n+   function pthread_mutexattr_setprioceiling\n+     (attr        : access pthread_mutexattr_t;\n+      prioceiling : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprioceiling);\n+\n    type struct_sched_param is record\n       sched_priority : int;  --  scheduling priority\n    end record;"}, {"sha": "00cf9ceeb5c0689e7b2eb5329e599e24b4592362", "filename": "gcc/ada/s-taprop-linux.adb", "status": "modified", "additions": 134, "deletions": 28, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15fc8cb7ee426fe6730b742a7fecf05ba0082d87/gcc%2Fada%2Fs-taprop-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15fc8cb7ee426fe6730b742a7fecf05ba0082d87/gcc%2Fada%2Fs-taprop-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-linux.adb?ref=15fc8cb7ee426fe6730b742a7fecf05ba0082d87", "patch": "@@ -111,6 +111,14 @@ package body System.Task_Primitives.Operations is\n    --  Constant to indicate that the thread identifier has not yet been\n    --  initialized.\n \n+   function geteuid return Integer;\n+   pragma Import (C, geteuid, \"geteuid\");\n+   pragma Warnings (Off, \"non-static call not allowed in preelaborated unit\");\n+   Superuser : constant Boolean := geteuid = 0;\n+   pragma Warnings (On, \"non-static call not allowed in preelaborated unit\");\n+   --  True if we are running as 'root'. On Linux, ceiling priorities work only\n+   --  in that case, so if this is False, we ignore Locking_Policy = 'C'.\n+\n    --------------------\n    -- Local Packages --\n    --------------------\n@@ -161,6 +169,11 @@ package body System.Task_Primitives.Operations is\n \n    procedure Abort_Handler (signo : Signal);\n \n+   function GNAT_pthread_condattr_setup\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C,\n+     GNAT_pthread_condattr_setup, \"__gnat_pthread_condattr_setup\");\n+\n    -------------------\n    -- Abort_Handler --\n    -------------------\n@@ -261,8 +274,6 @@ package body System.Task_Primitives.Operations is\n      (Prio : System.Any_Priority;\n       L    : not null access Lock)\n    is\n-      pragma Unreferenced (Prio);\n-\n    begin\n       if Locking_Policy = 'R' then\n          declare\n@@ -291,36 +302,91 @@ package body System.Task_Primitives.Operations is\n \n       else\n          declare\n+            Attributes : aliased pthread_mutexattr_t;\n             Result : Interfaces.C.int;\n \n          begin\n-            Result := pthread_mutex_init (L.WO'Access, null);\n+            Result := pthread_mutexattr_init (Attributes'Access);\n+            pragma Assert (Result = 0 or else Result = ENOMEM);\n \n+            if Result = ENOMEM then\n+               raise Storage_Error;\n+            end if;\n+\n+            if Locking_Policy = 'C' then\n+               if Superuser then\n+                  Result := pthread_mutexattr_setprotocol\n+                    (Attributes'Access, PTHREAD_PRIO_PROTECT);\n+                  pragma Assert (Result = 0);\n+\n+                  Result := pthread_mutexattr_setprioceiling\n+                     (Attributes'Access, Interfaces.C.int (Prio));\n+                  pragma Assert (Result = 0);\n+               end if;\n+\n+            elsif Locking_Policy = 'I' then\n+               Result := pthread_mutexattr_setprotocol\n+                 (Attributes'Access, PTHREAD_PRIO_INHERIT);\n+               pragma Assert (Result = 0);\n+            end if;\n+\n+            Result := pthread_mutex_init (L.WO'Access, Attributes'Access);\n             pragma Assert (Result = 0 or else Result = ENOMEM);\n \n             if Result = ENOMEM then\n+               Result := pthread_mutexattr_destroy (Attributes'Access);\n                raise Storage_Error with \"Failed to allocate a lock\";\n             end if;\n+\n+            Result := pthread_mutexattr_destroy (Attributes'Access);\n+            pragma Assert (Result = 0);\n          end;\n       end if;\n    end Initialize_Lock;\n \n    procedure Initialize_Lock\n-     (L     : not null access RTS_Lock;\n-      Level : Lock_Level)\n+     (L : not null access RTS_Lock; Level : Lock_Level)\n    is\n       pragma Unreferenced (Level);\n \n-      Result : Interfaces.C.int;\n+      Attributes : aliased pthread_mutexattr_t;\n+      Result     : Interfaces.C.int;\n \n    begin\n-      Result := pthread_mutex_init (L, null);\n+      Result := pthread_mutexattr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      if Locking_Policy = 'C' then\n+         if Superuser then\n+            Result := pthread_mutexattr_setprotocol\n+              (Attributes'Access, PTHREAD_PRIO_PROTECT);\n+            pragma Assert (Result = 0);\n+\n+            Result := pthread_mutexattr_setprioceiling\n+              (Attributes'Access, Interfaces.C.int (System.Any_Priority'Last));\n+            pragma Assert (Result = 0);\n+         end if;\n+\n+      elsif Locking_Policy = 'I' then\n+         Result := pthread_mutexattr_setprotocol\n+           (Attributes'Access, PTHREAD_PRIO_INHERIT);\n+         pragma Assert (Result = 0);\n+      end if;\n \n+      Result := pthread_mutex_init (L, Attributes'Access);\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n       if Result = ENOMEM then\n+         Result := pthread_mutexattr_destroy (Attributes'Access);\n          raise Storage_Error;\n       end if;\n+\n+      Result := pthread_mutexattr_destroy (Attributes'Access);\n+      pragma Assert (Result = 0);\n    end Initialize_Lock;\n \n    -------------------\n@@ -361,11 +427,10 @@ package body System.Task_Primitives.Operations is\n          Result := pthread_mutex_lock (L.WO'Access);\n       end if;\n \n-      Ceiling_Violation := Result = EINVAL;\n-\n-      --  Assume the cause of EINVAL is a priority ceiling violation\n+      --  The cause of EINVAL is a priority ceiling violation\n \n-      pragma Assert (Result = 0 or else Result = EINVAL);\n+      Ceiling_Violation := Result = EINVAL;\n+      pragma Assert (Result = 0 or else Ceiling_Violation);\n    end Write_Lock;\n \n    procedure Write_Lock\n@@ -405,11 +470,10 @@ package body System.Task_Primitives.Operations is\n          Result := pthread_mutex_lock (L.WO'Access);\n       end if;\n \n-      Ceiling_Violation := Result = EINVAL;\n+      --  The cause of EINVAL is a priority ceiling violation\n \n-      --  Assume the cause of EINVAL is a priority ceiling violation\n-\n-      pragma Assert (Result = 0 or else Result = EINVAL);\n+      Ceiling_Violation := Result = EINVAL;\n+      pragma Assert (Result = 0 or else Ceiling_Violation);\n    end Read_Lock;\n \n    ------------\n@@ -855,8 +919,9 @@ package body System.Task_Primitives.Operations is\n    --------------------\n \n    procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n-      Cond_Attr : aliased pthread_condattr_t;\n+      Mutex_Attr : aliased pthread_mutexattr_t;\n       Result    : Interfaces.C.int;\n+      Cond_Attr : aliased pthread_condattr_t;\n \n    begin\n       --  Give the task a unique serial number\n@@ -868,23 +933,62 @@ package body System.Task_Primitives.Operations is\n       Self_ID.Common.LL.Thread := Null_Thread_Id;\n \n       if not Single_Lock then\n-         Result :=\n-           pthread_mutex_init (Self_ID.Common.LL.L'Access, null);\n+         Result := pthread_mutexattr_init (Mutex_Attr'Access);\n          pragma Assert (Result = 0 or else Result = ENOMEM);\n \n+         if Result = 0 then\n+            if Locking_Policy = 'C' then\n+               if Superuser then\n+                  Result :=\n+                    pthread_mutexattr_setprotocol\n+                      (Mutex_Attr'Access,\n+                       PTHREAD_PRIO_PROTECT);\n+                  pragma Assert (Result = 0);\n+\n+                  Result :=\n+                    pthread_mutexattr_setprioceiling\n+                      (Mutex_Attr'Access,\n+                       Interfaces.C.int (System.Any_Priority'Last));\n+                  pragma Assert (Result = 0);\n+               end if;\n+\n+            elsif Locking_Policy = 'I' then\n+               Result :=\n+                 pthread_mutexattr_setprotocol\n+                   (Mutex_Attr'Access,\n+                    PTHREAD_PRIO_INHERIT);\n+               pragma Assert (Result = 0);\n+            end if;\n+\n+            Result :=\n+              pthread_mutex_init\n+                (Self_ID.Common.LL.L'Access,\n+                 Mutex_Attr'Access);\n+            pragma Assert (Result = 0 or else Result = ENOMEM);\n+         end if;\n+\n          if Result /= 0 then\n             Succeeded := False;\n             return;\n          end if;\n+\n+         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+         pragma Assert (Result = 0);\n       end if;\n \n       Result := pthread_condattr_init (Cond_Attr'Access);\n-      pragma Assert (Result = 0);\n-\n-      Result :=\n-        pthread_cond_init (Self_ID.Common.LL.CV'Access, Cond_Attr'Access);\n       pragma Assert (Result = 0 or else Result = ENOMEM);\n \n+      if Result = 0 then\n+         Result := GNAT_pthread_condattr_setup (Cond_Attr'Access);\n+         pragma Assert (Result = 0);\n+\n+         Result :=\n+           pthread_cond_init\n+             (Self_ID.Common.LL.CV'Access, Cond_Attr'Access);\n+         pragma Assert (Result = 0 or else Result = ENOMEM);\n+      end if;\n+\n       if Result = 0 then\n          Succeeded := True;\n       else\n@@ -895,6 +999,9 @@ package body System.Task_Primitives.Operations is\n \n          Succeeded := False;\n       end if;\n+\n+      Result := pthread_condattr_destroy (Cond_Attr'Access);\n+      pragma Assert (Result = 0);\n    end Initialize_TCB;\n \n    -----------------\n@@ -1042,12 +1149,11 @@ package body System.Task_Primitives.Operations is\n       --  safe to do this, since we know we have no problems with aliasing and\n       --  Unrestricted_Access bypasses this check.\n \n-      Result :=\n-        pthread_create\n-          (T.Common.LL.Thread'Unrestricted_Access,\n-           Attributes'Access,\n-           Thread_Body_Access (Wrapper),\n-           To_Address (T));\n+      Result := pthread_create\n+        (T.Common.LL.Thread'Unrestricted_Access,\n+         Attributes'Access,\n+         Thread_Body_Access (Wrapper),\n+         To_Address (T));\n \n       pragma Assert\n         (Result = 0 or else Result = EAGAIN or else Result = ENOMEM);"}, {"sha": "fc647aa2d5e2e8268f40d53a06da649acc0a693c", "filename": "gcc/ada/s-taprop-posix.adb", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15fc8cb7ee426fe6730b742a7fecf05ba0082d87/gcc%2Fada%2Fs-taprop-posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15fc8cb7ee426fe6730b742a7fecf05ba0082d87/gcc%2Fada%2Fs-taprop-posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-posix.adb?ref=15fc8cb7ee426fe6730b742a7fecf05ba0082d87", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -352,12 +352,11 @@ package body System.Task_Primitives.Operations is\n    -- Initialize_Lock --\n    ---------------------\n \n-   --  Note: mutexes and cond_variables needed per-task basis are\n-   --        initialized in Initialize_TCB and the Storage_Error is\n-   --        handled. Other mutexes (such as RTS_Lock, Memory_Lock...)\n-   --        used in RTS is initialized before any status change of RTS.\n-   --        Therefore raising Storage_Error in the following routines\n-   --        should be able to be handled safely.\n+   --  Note: mutexes and cond_variables needed per-task basis are initialized\n+   --  in Initialize_TCB and the Storage_Error is handled. Other mutexes (such\n+   --  as RTS_Lock, Memory_Lock...) used in RTS is initialized before any\n+   --  status change of RTS. Therefore raising Storage_Error in the following\n+   --  routines should be able to be handled safely.\n \n    procedure Initialize_Lock\n      (Prio : System.Any_Priority;\n@@ -474,10 +473,10 @@ package body System.Task_Primitives.Operations is\n    begin\n       Result := pthread_mutex_lock (L.WO'Access);\n \n-      --  Assume that the cause of EINVAL is a priority ceiling violation\n+      --  The cause of EINVAL is a priority ceiling violation\n \n-      Ceiling_Violation := (Result = EINVAL);\n-      pragma Assert (Result = 0 or else Result = EINVAL);\n+      Ceiling_Violation := Result = EINVAL;\n+      pragma Assert (Result = 0 or else Ceiling_Violation);\n    end Write_Lock;\n \n    procedure Write_Lock"}, {"sha": "0c3b08eeb8729ebb4591f7e14e0bed3b129e585c", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15fc8cb7ee426fe6730b742a7fecf05ba0082d87/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15fc8cb7ee426fe6730b742a7fecf05ba0082d87/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=15fc8cb7ee426fe6730b742a7fecf05ba0082d87", "patch": "@@ -17660,7 +17660,12 @@ package body Sem_Ch3 is\n          end if;\n \n          while Present (Disc) loop\n-            pragma Assert (Present (Assoc));\n+            --  If no further associations return the discriminant, value\n+            --  will be found on the second pass.\n+\n+            if No (Assoc) then\n+               return Result;\n+            end if;\n \n             if Original_Record_Component (Disc) = Result_Entity then\n                return Node (Assoc);\n@@ -17690,6 +17695,8 @@ package body Sem_Ch3 is\n       --  ??? This routine is a gigantic mess and will be deleted. For the\n       --  time being just test for the trivial case before calling recurse.\n \n+      --  We are now celebrating the 20th anniversary of this comment!\n+\n       if Base_Type (Scope (Discriminant)) = Base_Type (Typ_For_Constraint) then\n          declare\n             D : Entity_Id;"}, {"sha": "f0690556bcf7afcf9bb66c158352055c5c9f5d4e", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15fc8cb7ee426fe6730b742a7fecf05ba0082d87/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15fc8cb7ee426fe6730b742a7fecf05ba0082d87/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=15fc8cb7ee426fe6730b742a7fecf05ba0082d87", "patch": "@@ -13548,8 +13548,14 @@ package body Sem_Util is\n                      (Is_Object_Reference (Prefix (N))\n                        or else Is_Access_Type (Etype (Prefix (N))));\n \n+            --  An explicit dereference denotes an object, except that a\n+            --  conditional expression gets turned into an explicit dereference\n+            --  in some cases, and conditional expressions are not object\n+            --  names.\n+\n             when N_Explicit_Dereference =>\n-               return True;\n+               return not Nkind_In\n+                 (Original_Node (N), N_If_Expression, N_Case_Expression);\n \n             --  A view conversion of a tagged object is an object reference\n "}]}