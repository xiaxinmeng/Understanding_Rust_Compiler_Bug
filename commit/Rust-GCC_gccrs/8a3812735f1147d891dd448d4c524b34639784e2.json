{"sha": "8a3812735f1147d891dd448d4c524b34639784e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGEzODEyNzM1ZjExNDdkODkxZGQ0NDhkNGM1MjRiMzQ2Mzk3ODRlMg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2003-01-28T02:18:43Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2003-01-28T02:18:43Z"}, "message": "mips.h (UNITS_PER_HWFPVALUE): Renamed from...\n\n* config/mips/mips.h (UNITS_PER_HWFPVALUE): Renamed from...\n(UNITS_PER_FPVALUE): Defined as the width of a long double, or\nzero if no hardware floating point.\n(LONG_DUBLE_TYPE_SIZE): Set to 128 on N32 and N64.\n(MAX_FIXED_MODE_SIZE): Define to LONG_DOUBLE_TYPE_SIZE.\n(LIBGCC2_LONG_DOUBLE_TYPE_SIZE): Define.\n(BIGGEST_ALIGNMENT): Same as LONG_DOUBLE_TYPE_SIZE.\n(FUNCTION_VALUE_REGNO_P): Set for FP_RETURN+2 on N32 and N64.\n* config/mips/mips.c (mips_arg_info): Pass TFmode values in\neven FP registers on N32 and N64.\n(mips_setup_incoming_varargs): Use UNITS_PER_HWFPVALUE.\n(mips_va_start): Adjust alignment of ARG_POINTER_REGNUM.\n(mips_va_arg): Use UNITS_PER_HWFPVALUE.  Impose additional\neven-register-like alignment to 128-bit arguments.\n(save_restore_insns): Use UNITS_PER_HWFPVALUE.\n(mips_function_value): Likewise.  Return TFmode in $f0 and $f2\non N32 or N64.\n* config/mips/_tilib.c (__negti2, __ashlti3, __lshrti3): New.\n* config/mips/t-iris6 (LIB2FUNCS_EXTRA): Add _tilib.c.\n(TPBIT): Set to tp-bit.c.\n(tp-bit.c): Create out of fp-bit.c.\n\nFrom-SVN: r61945", "tree": {"sha": "c23c9024815042ca83c255f73c3f6cd18d246ca1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c23c9024815042ca83c255f73c3f6cd18d246ca1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a3812735f1147d891dd448d4c524b34639784e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a3812735f1147d891dd448d4c524b34639784e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a3812735f1147d891dd448d4c524b34639784e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a3812735f1147d891dd448d4c524b34639784e2/comments", "author": null, "committer": null, "parents": [{"sha": "2956f353baff55a44b0cac9807774b47c3f3ab02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2956f353baff55a44b0cac9807774b47c3f3ab02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2956f353baff55a44b0cac9807774b47c3f3ab02"}], "stats": {"total": 120, "additions": 104, "deletions": 16}, "files": [{"sha": "9d5ff317abc67b402dcc4b513577816cad63edd0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a3812735f1147d891dd448d4c524b34639784e2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a3812735f1147d891dd448d4c524b34639784e2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a3812735f1147d891dd448d4c524b34639784e2", "patch": "@@ -1,3 +1,27 @@\n+2003-01-28  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* config/mips/mips.h (UNITS_PER_HWFPVALUE): Renamed from...\n+\t(UNITS_PER_FPVALUE): Defined as the width of a long double, or\n+\tzero if no hardware floating point.\n+\t(LONG_DUBLE_TYPE_SIZE): Set to 128 on N32 and N64.\n+\t(MAX_FIXED_MODE_SIZE): Define to LONG_DOUBLE_TYPE_SIZE.\n+\t(LIBGCC2_LONG_DOUBLE_TYPE_SIZE): Define.\n+\t(BIGGEST_ALIGNMENT): Same as LONG_DOUBLE_TYPE_SIZE.\n+\t(FUNCTION_VALUE_REGNO_P): Set for FP_RETURN+2 on N32 and N64.\n+\t* config/mips/mips.c (mips_arg_info): Pass TFmode values in\n+\teven FP registers on N32 and N64.\n+\t(mips_setup_incoming_varargs): Use UNITS_PER_HWFPVALUE.\n+\t(mips_va_start): Adjust alignment of ARG_POINTER_REGNUM.\n+\t(mips_va_arg): Use UNITS_PER_HWFPVALUE.  Impose additional\n+\teven-register-like alignment to 128-bit arguments.\n+\t(save_restore_insns): Use UNITS_PER_HWFPVALUE.\n+\t(mips_function_value): Likewise.  Return TFmode in $f0 and $f2\n+\ton N32 or N64.\n+\t* config/mips/_tilib.c (__negti2, __ashlti3, __lshrti3): New.\n+\t* config/mips/t-iris6 (LIB2FUNCS_EXTRA): Add _tilib.c.\n+\t(TPBIT): Set to tp-bit.c.\n+\t(tp-bit.c): Create out of fp-bit.c.\n+\n 2003-01-28  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* c-parse.in: Remove '%expect 32' directive in objc mode."}, {"sha": "b1408f190244c20098802dde51a41a634ae63662", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a3812735f1147d891dd448d4c524b34639784e2/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a3812735f1147d891dd448d4c524b34639784e2/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=8a3812735f1147d891dd448d4c524b34639784e2", "patch": "@@ -4315,9 +4315,11 @@ mips_arg_info (cum, mode, type, named, info)\n \t is a double, but $f14 if it is a single.  Otherwise, on a\n \t 32-bit double-float machine, each FP argument must start in a\n \t new register pair.  */\n-      even_reg_p = ((mips_abi == ABI_O64 && mode == SFmode) || FP_INC > 1);\n+      even_reg_p = (GET_MODE_SIZE (mode) > UNITS_PER_HWFPVALUE\n+\t\t    || (mips_abi == ABI_O64 && mode == SFmode)\n+\t\t    || FP_INC > 1);\n     }\n-  else if (!TARGET_64BIT)\n+  else if (!TARGET_64BIT || LONG_DOUBLE_TYPE_SIZE == 128)\n     {\n       if (GET_MODE_CLASS (mode) == MODE_INT\n \t  || GET_MODE_CLASS (mode) == MODE_FLOAT)\n@@ -4629,7 +4631,7 @@ mips_setup_incoming_varargs (cum, mode, type, no_rtl)\n \t      rtx ptr = plus_constant (virtual_incoming_args_rtx, off);\n \t      emit_move_insn (gen_rtx_MEM (mode, ptr),\n \t\t\t      gen_rtx_REG (mode, FP_ARG_FIRST + i));\n-\t      off += UNITS_PER_FPVALUE;\n+\t      off += UNITS_PER_HWFPVALUE;\n \t    }\n \t}\n     }\n@@ -4706,6 +4708,15 @@ mips_va_start (valist, nextarg)\n {\n   const CUMULATIVE_ARGS *cum = &current_function_args_info;\n \n+  /* ARG_POINTER_REGNUM is initialized to STACK_POINTER_BOUNDARY, but\n+     since the stack is aligned for a pair of argument-passing slots,\n+     and the beginning of a variable argument list may be an odd slot,\n+     we have to decrease its alignment.  */\n+  if (cfun && cfun->emit->regno_pointer_align)\n+    while (((current_function_pretend_args_size * BITS_PER_UNIT)\n+\t    & (REGNO_POINTER_ALIGN (ARG_POINTER_REGNUM) - 1)) != 0)\n+      REGNO_POINTER_ALIGN (ARG_POINTER_REGNUM) /= 2;\n+\n   if (mips_abi == ABI_EABI)\n     {\n       int gpr_save_area_size;\n@@ -4903,9 +4914,9 @@ mips_va_arg (valist, type)\n \t      off = build (COMPONENT_REF, TREE_TYPE (f_foff), valist, f_foff);\n \n \t      /* When floating-point registers are saved to the stack,\n-\t\t each one will take up UNITS_PER_FPVALUE bytes, regardless\n+\t\t each one will take up UNITS_PER_HWFPVALUE bytes, regardless\n \t\t of the float's precision.  */\n-\t      rsize = UNITS_PER_FPVALUE;\n+\t      rsize = UNITS_PER_HWFPVALUE;\n \t    }\n \t  else\n \t    {\n@@ -4924,7 +4935,7 @@ mips_va_arg (valist, type)\n \t     bytes (= PARM_BOUNDARY bits).  RSIZE can sometimes be smaller\n \t     than that, such as in the combination -mgp64 -msingle-float\n \t     -fshort-double.  Doubles passed in registers will then take\n-\t     up UNITS_PER_FPVALUE bytes, but those passed on the stack\n+\t     up UNITS_PER_HWFPVALUE bytes, but those passed on the stack\n \t     take up UNITS_PER_WORD bytes.  */\n \t  osize = MAX (rsize, UNITS_PER_WORD);\n \n@@ -4998,7 +5009,10 @@ mips_va_arg (valist, type)\n \t that alignments <= UNITS_PER_WORD are preserved by the va_arg\n \t increment mechanism.  */\n \n-      if (TARGET_64BIT)\n+      if ((mips_abi == ABI_N32 || mips_abi == ABI_64)\n+\t  && TYPE_ALIGN (type) > 64)\n+\talign = 16;\n+      else if (TARGET_64BIT)\n \talign = 8;\n       else if (TYPE_ALIGN (type) > 32)\n \talign = 8;\n@@ -7080,7 +7094,7 @@ save_restore_insns (store_p, large_reg, large_offset)\n       /* Pick which pointer to use as a base register.  */\n       fp_offset = cfun->machine->frame.fp_sp_offset;\n       end_offset = fp_offset - (cfun->machine->frame.fp_reg_size\n-\t\t\t\t- UNITS_PER_FPVALUE);\n+\t\t\t\t- UNITS_PER_HWFPVALUE);\n \n       if (fp_offset < 0 || end_offset < 0)\n \tinternal_error\n@@ -7133,7 +7147,7 @@ save_restore_insns (store_p, large_reg, large_offset)\n \t    else\n \t      emit_move_insn (reg_rtx, mem_rtx);\n \n-\t    fp_offset -= UNITS_PER_FPVALUE;\n+\t    fp_offset -= UNITS_PER_HWFPVALUE;\n \t  }\n     }\n }\n@@ -8264,11 +8278,26 @@ mips_function_value (valtype, func, mode)\n     }\n   mclass = GET_MODE_CLASS (mode);\n \n-  if (mclass == MODE_FLOAT && GET_MODE_SIZE (mode) <= UNITS_PER_FPVALUE)\n+  if (mclass == MODE_FLOAT && GET_MODE_SIZE (mode) <= UNITS_PER_HWFPVALUE)\n     reg = FP_RETURN;\n \n+  else if (mclass == MODE_FLOAT && mode == TFmode)\n+    /* long doubles are really split between f0 and f2, not f1.  Eek.\n+       Use DImode for each component, since GCC wants integer modes\n+       for subregs.  */\n+    return gen_rtx_PARALLEL\n+      (VOIDmode,\n+       gen_rtvec (2,\n+\t\t  gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t     gen_rtx_REG (DImode, FP_RETURN),\n+\t\t\t\t     GEN_INT (0)),\n+\t\t  gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t     gen_rtx_REG (DImode, FP_RETURN + 2),\n+\t\t\t\t     GEN_INT (GET_MODE_SIZE (mode) / 2))));\n+       \n+\n   else if (mclass == MODE_COMPLEX_FLOAT\n-\t   && GET_MODE_SIZE (mode) <= UNITS_PER_FPVALUE * 2)\n+\t   && GET_MODE_SIZE (mode) <= UNITS_PER_HWFPVALUE * 2)\n     {\n       enum machine_mode cmode = GET_MODE_INNER (mode);\n "}, {"sha": "61a6b0db735bd228f1d84d3cb1ced21b5081140a", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a3812735f1147d891dd448d4c524b34639784e2/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a3812735f1147d891dd448d4c524b34639784e2/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=8a3812735f1147d891dd448d4c524b34639784e2", "patch": "@@ -1517,8 +1517,14 @@ do {\t\t\t\t\t\t\t\\\n    the next available register.  */\n #define FP_INC (TARGET_FLOAT64 || TARGET_SINGLE_FLOAT ? 1 : 2)\n \n-/* The largest size of value that can be held in floating-point registers.  */\n-#define UNITS_PER_FPVALUE (TARGET_SOFT_FLOAT ? 0 : FP_INC * UNITS_PER_FPREG)\n+/* The largest size of value that can be held in floating-point\n+   registers and moved with a single instruction.  */\n+#define UNITS_PER_HWFPVALUE (TARGET_SOFT_FLOAT ? 0 : FP_INC * UNITS_PER_FPREG)\n+\n+/* The largest size of value that can be held in floating-point\n+   registers.  */\n+#define UNITS_PER_FPVALUE \\\n+  (TARGET_SOFT_FLOAT ? 0 : (LONG_DOUBLE_TYPE_SIZE / BITS_PER_UNIT))\n \n /* The number of bytes in a double.  */\n #define UNITS_PER_DOUBLE (TYPE_PRECISION (double_type_node) / BITS_PER_UNIT)\n@@ -1565,7 +1571,21 @@ do {\t\t\t\t\t\t\t\\\n /* A C expression for the size in bits of the type `long double' on\n    the target machine.  If you don't define this, the default is two\n    words.  */\n-#define LONG_DOUBLE_TYPE_SIZE 64\n+#define LONG_DOUBLE_TYPE_SIZE \\\n+  (mips_abi == ABI_N32 || mips_abi == ABI_64 ? 128 : 64)\n+\n+/* long double is not a fixed mode, but the idea is that, if we\n+   support long double, we also want a 128-bit integer type.  */\n+#define MAX_FIXED_MODE_SIZE LONG_DOUBLE_TYPE_SIZE\n+\n+#ifdef IN_LIBGCC2\n+#if  (defined _ABIN32 && _MIPS_SIM == _ABIN32) \\\n+  || (defined _ABI64 && _MIPS_SIM == _ABI64)\n+#  define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 128\n+# else\n+#  define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 64\n+# endif\n+#endif\n \n /* Width in bits of a pointer.\n    See also the macro `Pmode' defined below.  */\n@@ -1592,7 +1612,7 @@ do {\t\t\t\t\t\t\t\\\n #define STRUCTURE_SIZE_BOUNDARY 8\n \n /* There is no point aligning anything to a rounder boundary than this.  */\n-#define BIGGEST_ALIGNMENT 64\n+#define BIGGEST_ALIGNMENT LONG_DOUBLE_TYPE_SIZE\n \n /* Set this nonzero if move instructions will actually fail to work\n    when given unaligned data.  */\n@@ -2654,7 +2674,9 @@ extern enum reg_class mips_char_to_class[256];\n    On the MIPS, R2 R3 and F0 F2 are the only register thus used.\n    Currently, R2 and F0 are only implemented  here (C has no complex type)  */\n \n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == GP_RETURN || (N) == FP_RETURN)\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == GP_RETURN || (N) == FP_RETURN \\\n+  || (LONG_DOUBLE_TYPE_SIZE == 128 && FP_RETURN != GP_RETURN \\\n+      && (N) == FP_RETURN + 2))\n \n /* 1 if N is a possible register number for function argument passing.\n    We have no FP argument registers when soft-float.  When FP registers"}, {"sha": "a1be0b9c9ed2faa968a0ff5a927a3ddf6fbca4b8", "filename": "gcc/config/mips/t-iris6", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a3812735f1147d891dd448d4c524b34639784e2/gcc%2Fconfig%2Fmips%2Ft-iris6", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a3812735f1147d891dd448d4c524b34639784e2/gcc%2Fconfig%2Fmips%2Ft-iris6", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-iris6?ref=8a3812735f1147d891dd448d4c524b34639784e2", "patch": "@@ -18,3 +18,16 @@ CRTSTUFF_T_CFLAGS=-g1\n # This is only needed in the static libgcc as a band-aid until gcc correctly\n # implements the N32/N64 ABI structure passing conventions\n LIB2FUNCS_STATIC_EXTRA = $(srcdir)/config/mips/irix6-libc-compat.c\n+\n+LIB2FUNCS_EXTRA = $(srcdir)/config/mips/_tilib.c\n+\n+TPBIT = tp-bit.c\n+\n+tp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#ifdef __MIPSEL__' > tp-bit.c\n+\techo '# define FLOAT_BIT_ORDER_MISMATCH' >> tp-bit.c\n+\techo '#endif' >> tp-bit.c\n+\techo '#if __LDBL_MANT_DIG__ == 106' >> tp-bit.c\n+\techo '# define TFLOAT' >> tp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> tp-bit.c\n+\techo '#endif' >> tp-bit.c"}]}