{"sha": "4b259e3fd8a2459f2c5d36fcc573884b725ada14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIyNTllM2ZkOGEyNDU5ZjJjNWQzNmZjYzU3Mzg4NGI3MjVhZGExNA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-12-15T10:31:52Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-12-15T10:31:52Z"}, "message": "loop.h (struct induction): Delete times_used member.\n\n\t* loop.h (struct induction): Delete times_used member.\n\t* loop.c (n_times_set): Rename to set_in_loop.  Changed all users.\n\t(n_times_used): Rename to n_times_set.  Changed all users.\n\t(scan_loop): Free reg_single_usage before strength reduction.\n\t(record_giv, combine_givs): Remove handling of times_used member.\n\t(combine_givs_used_once): Rename to:\n\t(combine_givs_used_by_other) .  Changed all callers.\n\nFrom-SVN: r24324", "tree": {"sha": "4433e30dd9eb67c2f12b3797d24aeb1014c0ba10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4433e30dd9eb67c2f12b3797d24aeb1014c0ba10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b259e3fd8a2459f2c5d36fcc573884b725ada14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b259e3fd8a2459f2c5d36fcc573884b725ada14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b259e3fd8a2459f2c5d36fcc573884b725ada14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b259e3fd8a2459f2c5d36fcc573884b725ada14/comments", "author": null, "committer": null, "parents": [{"sha": "06d84d69355885992c5494eef50633624ee14bf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d84d69355885992c5494eef50633624ee14bf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06d84d69355885992c5494eef50633624ee14bf6"}], "stats": {"total": 136, "additions": 72, "deletions": 64}, "files": [{"sha": "2d6e58d6d9a226bc43384e01897c8d0c9da58fea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b259e3fd8a2459f2c5d36fcc573884b725ada14/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b259e3fd8a2459f2c5d36fcc573884b725ada14/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b259e3fd8a2459f2c5d36fcc573884b725ada14", "patch": "@@ -1,3 +1,13 @@\n+Tue Dec 15 18:27:39 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* loop.h (struct induction): Delete times_used member.\n+\t* loop.c (n_times_set): Rename to set_in_loop.  Changed all users.\n+\t(n_times_used): Rename to n_times_set.  Changed all users.\n+\t(scan_loop): Free reg_single_usage before strength reduction.\n+\t(record_giv, combine_givs): Remove handling of times_used member.\n+\t(combine_givs_used_once): Rename to:\n+\t(combine_givs_used_by_other) .  Changed all callers.\n+\n Tue Dec 15 01:45:26 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* dwarf2out.c (gen_struct_or_union_type_die): Check AGGREGATE_TYPE_P"}, {"sha": "cb000c0e8ebf76cd864acf356b4a70389ff737b7", "filename": "gcc/loop.c", "status": "modified", "additions": 62, "deletions": 63, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b259e3fd8a2459f2c5d36fcc573884b725ada14/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b259e3fd8a2459f2c5d36fcc573884b725ada14/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=4b259e3fd8a2459f2c5d36fcc573884b725ada14", "patch": "@@ -141,13 +141,13 @@ static rtx loop_continue;\n    Therefore, at all times, == 0 indicates an invariant register;\n    < 0 a conditionally invariant one.  */\n \n-static varray_type n_times_set;\n+static varray_type set_in_loop;\n \n-/* Original value of n_times_set; same except that this value\n+/* Original value of set_in_loop; same except that this value\n    is not set negative for a reg whose sets have been made candidates\n    and not set to 0 for a reg that is moved.  */\n \n-static varray_type n_times_used;\n+static varray_type n_times_set;\n \n /* Index by register number, 1 indicates that the register\n    cannot be moved or strength reduced.  */\n@@ -718,8 +718,8 @@ scan_loop (loop_start, end, unroll_p, bct_p)\n      we won't have to reallocate these arrays.  However, we do grow\n      the arrays, if necessary, in load_mems_recount_loop_regs_set.  */\n   nregs = max_reg_num () + loop_mems_idx + 16;\n+  VARRAY_INT_INIT (set_in_loop, nregs, \"set_in_loop\");\n   VARRAY_INT_INIT (n_times_set, nregs, \"n_times_set\");\n-  VARRAY_INT_INIT (n_times_used, nregs, \"n_times_used\");\n   VARRAY_CHAR_INIT (may_not_optimize, nregs, \"may_not_optimize\");\n \n   if (loop_has_call)\n@@ -731,7 +731,7 @@ scan_loop (loop_start, end, unroll_p, bct_p)\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n       VARRAY_CHAR (may_not_optimize, i) = 1;\n-      VARRAY_INT (n_times_set, i) = 1;\n+      VARRAY_INT (set_in_loop, i) = 1;\n     }\n \n #ifdef AVOID_CCMODE_COPIES\n@@ -742,8 +742,8 @@ scan_loop (loop_start, end, unroll_p, bct_p)\n       VARRAY_CHAR (may_not_optimize, i) = 1;\n #endif\n \n-  bcopy ((char *) &n_times_set->data, \n-\t (char *) &n_times_used->data, nregs * sizeof (int));\n+  bcopy ((char *) &set_in_loop->data, \n+\t (char *) &n_times_set->data, nregs * sizeof (int));\n \n   if (loop_dump_stream)\n     {\n@@ -755,7 +755,7 @@ scan_loop (loop_start, end, unroll_p, bct_p)\n     }\n \n   /* Scan through the loop finding insns that are safe to move.\n-     Set n_times_set negative for the reg being set, so that\n+     Set set_in_loop negative for the reg being set, so that\n      this reg will be considered invariant for subsequent insns.\n      We consider whether subsequent insns use the reg\n      in deciding whether it is worth actually moving.\n@@ -840,12 +840,12 @@ scan_loop (loop_start, end, unroll_p, bct_p)\n \t  else if ((tem = invariant_p (src))\n \t\t   && (dependencies == 0\n \t\t       || (tem2 = invariant_p (dependencies)) != 0)\n-\t\t   && (VARRAY_INT (n_times_set, \n+\t\t   && (VARRAY_INT (set_in_loop, \n \t\t\t\t   REGNO (SET_DEST (set))) == 1\n \t\t       || (tem1\n \t\t\t   = consec_sets_invariant_p \n \t\t\t   (SET_DEST (set),\n-\t\t\t    VARRAY_INT (n_times_set, REGNO (SET_DEST (set))),\n+\t\t\t    VARRAY_INT (set_in_loop, REGNO (SET_DEST (set))),\n \t\t\t    p)))\n \t\t   /* If the insn can cause a trap (such as divide by zero),\n \t\t      can't move it unless it's guaranteed to be executed\n@@ -877,7 +877,7 @@ scan_loop (loop_start, end, unroll_p, bct_p)\n \t\t  && REGNO_FIRST_UID (regno) == INSN_UID (p)\n \t\t  && (REGNO_LAST_UID (regno)\n \t\t      == INSN_UID (VARRAY_RTX (reg_single_usage, regno)))\n-\t\t  && VARRAY_INT (n_times_set, regno) == 1\n+\t\t  && VARRAY_INT (set_in_loop, regno) == 1\n \t\t  && ! side_effects_p (SET_SRC (set))\n \t\t  && ! find_reg_note (p, REG_RETVAL, NULL_RTX)\n \t\t  && (! SMALL_REGISTER_CLASSES\n@@ -905,7 +905,7 @@ scan_loop (loop_start, end, unroll_p, bct_p)\n \t\t  PUT_CODE (p, NOTE);\n \t\t  NOTE_LINE_NUMBER (p) = NOTE_INSN_DELETED;\n \t\t  NOTE_SOURCE_FILE (p) = 0;\n-\t\t  VARRAY_INT (n_times_set, regno) = 0;\n+\t\t  VARRAY_INT (set_in_loop, regno) = 0;\n \t\t  continue;\n \t\t}\n \n@@ -916,7 +916,7 @@ scan_loop (loop_start, end, unroll_p, bct_p)\n \t      m->dependencies = dependencies;\n \t      m->set_dest = SET_DEST (set);\n \t      m->force = 0;\n-\t      m->consec = VARRAY_INT (n_times_set, \n+\t      m->consec = VARRAY_INT (set_in_loop, \n \t\t\t\t      REGNO (SET_DEST (set))) - 1;\n \t      m->done = 0;\n \t      m->forces = 0;\n@@ -934,10 +934,10 @@ scan_loop (loop_start, end, unroll_p, bct_p)\n \t      m->match = 0;\n \t      m->lifetime = (uid_luid[REGNO_LAST_UID (regno)]\n \t\t\t     - uid_luid[REGNO_FIRST_UID (regno)]);\n-\t      m->savings = VARRAY_INT (n_times_used, regno);\n+\t      m->savings = VARRAY_INT (n_times_set, regno);\n \t      if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n \t\tm->savings += libcall_benefit (p);\n-\t      VARRAY_INT (n_times_set, regno) = move_insn ? -2 : -1;\n+\t      VARRAY_INT (set_in_loop, regno) = move_insn ? -2 : -1;\n \t      /* Add M to the end of the chain MOVABLES.  */\n \t      if (movables == 0)\n \t\tmovables = m;\n@@ -996,7 +996,7 @@ scan_loop (loop_start, end, unroll_p, bct_p)\n \t\t   && !reg_mentioned_p (SET_DEST (set), SET_SRC (set1)))\n \t    {\n \t      register int regno = REGNO (SET_DEST (set));\n-\t      if (VARRAY_INT (n_times_set, regno) == 2)\n+\t      if (VARRAY_INT (set_in_loop, regno) == 2)\n \t\t{\n \t\t  register struct movable *m;\n \t\t  m = (struct movable *) alloca (sizeof (struct movable));\n@@ -1046,7 +1046,7 @@ scan_loop (loop_start, end, unroll_p, bct_p)\n \t\t  m->lifetime = (uid_luid[REGNO_LAST_UID (regno)]\n \t\t\t\t - uid_luid[REGNO_FIRST_UID (regno)]);\n \t\t  m->savings = 1;\n-\t\t  VARRAY_INT (n_times_set, regno) = -1;\n+\t\t  VARRAY_INT (set_in_loop, regno) = -1;\n \t\t  /* Add M to the end of the chain MOVABLES.  */\n \t\t  if (movables == 0)\n \t\t    movables = m;\n@@ -1111,7 +1111,7 @@ scan_loop (loop_start, end, unroll_p, bct_p)\n   combine_movables (movables, nregs);\n \t\n   /* Now consider each movable insn to decide whether it is worth moving.\n-     Store 0 in n_times_set for each reg that is moved.\n+     Store 0 in set_in_loop for each reg that is moved.\n \n      Generally this increases code size, so do not move moveables when\n      optimizing for code size.  */\n@@ -1121,10 +1121,10 @@ scan_loop (loop_start, end, unroll_p, bct_p)\n \t\t   insn_count, loop_start, end, nregs);\n \n   /* Now candidates that still are negative are those not moved.\n-     Change n_times_set to indicate that those are not actually invariant.  */\n+     Change set_in_loop to indicate that those are not actually invariant.  */\n   for (i = 0; i < nregs; i++)\n-    if (VARRAY_INT (n_times_set, i) < 0)\n-      VARRAY_INT (n_times_set, i) = VARRAY_INT (n_times_used, i);\n+    if (VARRAY_INT (set_in_loop, i) < 0)\n+      VARRAY_INT (set_in_loop, i) = VARRAY_INT (n_times_set, i);\n \n   /* Now that we've moved some things out of the loop, we able to\n      hoist even more memory references.  There's no need to pass\n@@ -1133,17 +1133,19 @@ scan_loop (loop_start, end, unroll_p, bct_p)\n \t\t\t\t       loop_start, 0,\n \t\t\t\t       &insn_count);\n \n+  /* set_in_loop is still used by invariant_p, so we can't free it now.  */\n+  VARRAY_FREE (reg_single_usage);\n+\n   if (flag_strength_reduce)\n     {\n       the_movables = movables;\n       strength_reduce (scan_start, end, loop_top,\n \t\t       insn_count, loop_start, end, unroll_p, bct_p);\n     }\n \n+  VARRAY_FREE (set_in_loop);\n   VARRAY_FREE (n_times_set);\n-  VARRAY_FREE (n_times_used);\n   VARRAY_FREE (may_not_optimize);\n-  VARRAY_FREE (reg_single_usage);\n }\n \f\n /* Add elements to *OUTPUT to record all the pseudo-regs\n@@ -1417,7 +1419,7 @@ combine_movables (movables, nregs)\n   /* Perhaps testing m->consec_sets would be more appropriate here?  */\n \n   for (m = movables; m; m = m->next)\n-    if (m->match == 0 && VARRAY_INT (n_times_used, m->regno) == 1 && !m->partial)\n+    if (m->match == 0 && VARRAY_INT (n_times_set, m->regno) == 1 && !m->partial)\n       {\n \tregister struct movable *m1;\n \tint regno = m->regno;\n@@ -1428,7 +1430,7 @@ combine_movables (movables, nregs)\n \t/* We want later insns to match the first one.  Don't make the first\n \t   one match any later ones.  So start this loop at m->next.  */\n \tfor (m1 = m->next; m1; m1 = m1->next)\n-\t  if (m != m1 && m1->match == 0 && VARRAY_INT (n_times_used, m1->regno) == 1\n+\t  if (m != m1 && m1->match == 0 && VARRAY_INT (n_times_set, m1->regno) == 1\n \t      /* A reg used outside the loop mustn't be eliminated.  */\n \t      && !m1->global\n \t      /* A reg used for zero-extending mustn't be eliminated.  */\n@@ -1565,15 +1567,15 @@ rtx_equal_for_loop_p (x, y, movables)\n \n   /* If we have a register and a constant, they may sometimes be\n      equal.  */\n-  if (GET_CODE (x) == REG && VARRAY_INT (n_times_set, REGNO (x)) == -2\n+  if (GET_CODE (x) == REG && VARRAY_INT (set_in_loop, REGNO (x)) == -2\n       && CONSTANT_P (y))\n     {\n       for (m = movables; m; m = m->next)\n \tif (m->move_insn && m->regno == REGNO (x)\n \t    && rtx_equal_p (m->set_src, y))\n \t  return 1;\n     }\n-  else if (GET_CODE (y) == REG && VARRAY_INT (n_times_set, REGNO (y)) == -2\n+  else if (GET_CODE (y) == REG && VARRAY_INT (set_in_loop, REGNO (y)) == -2\n \t   && CONSTANT_P (x))\n     {\n       for (m = movables; m; m = m->next)\n@@ -1800,7 +1802,7 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t      || (threshold * savings * m->lifetime) >=\n \t\t (moved_once[regno] ? insn_count * 2 : insn_count)\n \t      || (m->forces && m->forces->done\n-\t\t  && VARRAY_INT (n_times_used, m->forces->regno) == 1))\n+\t\t  && VARRAY_INT (n_times_set, m->forces->regno) == 1))\n \t    {\n \t      int count;\n \t      register struct movable *m1;\n@@ -2110,7 +2112,7 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \n \t      /* The reg set here is now invariant.  */\n \t      if (! m->partial)\n-\t\tVARRAY_INT (n_times_set, regno) = 0;\n+\t\tVARRAY_INT (set_in_loop, regno) = 0;\n \n \t      m->done = 1;\n \n@@ -2167,7 +2169,7 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t\t      /* The reg merged here is now invariant,\n \t\t\t if the reg it matches is invariant.  */\n \t\t      if (! m->partial)\n-\t\t\tVARRAY_INT (n_times_set, m1->regno) = 0;\n+\t\t\tVARRAY_INT (set_in_loop, m1->regno) = 0;\n \t\t    }\n \t    }\n \t  else if (loop_dump_stream)\n@@ -3075,10 +3077,10 @@ invariant_p (x)\n \t  && REGNO (x) < FIRST_PSEUDO_REGISTER && call_used_regs[REGNO (x)])\n \treturn 0;\n \n-      if (VARRAY_INT (n_times_set, REGNO (x)) < 0)\n+      if (VARRAY_INT (set_in_loop, REGNO (x)) < 0)\n \treturn 2;\n \n-      return VARRAY_INT (n_times_set, REGNO (x)) == 0;\n+      return VARRAY_INT (set_in_loop, REGNO (x)) == 0;\n \n     case MEM:\n       /* Volatile memory references must be rejected.  Do this before\n@@ -3166,15 +3168,15 @@ consec_sets_invariant_p (reg, n_sets, insn)\n   rtx temp;\n   /* Number of sets we have to insist on finding after INSN.  */\n   int count = n_sets - 1;\n-  int old = VARRAY_INT (n_times_set, regno);\n+  int old = VARRAY_INT (set_in_loop, regno);\n   int value = 0;\n   int this;\n \n   /* If N_SETS hit the limit, we can't rely on its value.  */\n   if (n_sets == 127)\n     return 0;\n \n-  VARRAY_INT (n_times_set, regno) = 0;\n+  VARRAY_INT (set_in_loop, regno) = 0;\n \n   while (count > 0)\n     {\n@@ -3213,12 +3215,12 @@ consec_sets_invariant_p (reg, n_sets, insn)\n \tcount--;\n       else if (code != NOTE)\n \t{\n-\t  VARRAY_INT (n_times_set, regno) = old;\n+\t  VARRAY_INT (set_in_loop, regno) = old;\n \t  return 0;\n \t}\n     }\n \n-  VARRAY_INT (n_times_set, regno) = old;\n+  VARRAY_INT (set_in_loop, regno) = old;\n   /* If invariant_p ever returned 2, we return 2.  */\n   return 1 + (value & 2);\n }\n@@ -3326,7 +3328,7 @@ count_one_set (insn, x, may_not_move, last_set)\n \t     in current basic block, and it was set before,\n \t     it must be set in two basic blocks, so it cannot\n \t     be moved out of the loop.  */\n-\t  if (VARRAY_INT (n_times_set, regno) > 0 \n+\t  if (VARRAY_INT (set_in_loop, regno) > 0 \n \t      && last_set[regno] == 0)\n \t    VARRAY_CHAR (may_not_move, regno) = 1;\n \t  /* If this is not first setting in current basic block,\n@@ -3335,16 +3337,16 @@ count_one_set (insn, x, may_not_move, last_set)\n \t  if (last_set[regno] != 0\n \t      && reg_used_between_p (dest, last_set[regno], insn))\n \t    VARRAY_CHAR (may_not_move, regno) = 1;\n-\t  if (VARRAY_INT (n_times_set, regno) < 127)\n-\t    ++VARRAY_INT (n_times_set, regno);\n+\t  if (VARRAY_INT (set_in_loop, regno) < 127)\n+\t    ++VARRAY_INT (set_in_loop, regno);\n \t  last_set[regno] = insn;\n \t}\n     }\n }\n \n-/* Increment N_TIMES_SET at the index of each register\n+/* Increment SET_IN_LOOP at the index of each register\n    that is modified by an insn between FROM and TO.\n-   If the value of an element of N_TIMES_SET becomes 127 or more,\n+   If the value of an element of SET_IN_LOOP becomes 127 or more,\n    stop incrementing it, to avoid overflow.\n \n    Store in SINGLE_USAGE[I] the single insn in which register I is\n@@ -4861,7 +4863,6 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n     {\n       v->mode = GET_MODE (*location);\n       v->lifetime = 1;\n-      v->times_used = 1;\n     }\n   else /* type == DEST_REG */\n     {\n@@ -4870,8 +4871,6 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n       v->lifetime = (uid_luid[REGNO_LAST_UID (REGNO (dest_reg))]\n \t\t     - uid_luid[REGNO_FIRST_UID (REGNO (dest_reg))]);\n \n-      v->times_used = VARRAY_INT (n_times_used, REGNO (dest_reg));\n-\n       /* If the lifetime is zero, it means that this register is\n \t really a dead store.  So mark this as a giv that can be\n \t ignored.  This will not prevent the biv from being eliminated.  */\n@@ -5005,8 +5004,8 @@ record_giv (v, insn, src_reg, dest_reg, mult_val, add_val, benefit,\n \n       fprintf (loop_dump_stream, \" src reg %d benefit %d\",\n \t       REGNO (src_reg), v->benefit);\n-      fprintf (loop_dump_stream, \" used %d lifetime %d\",\n-\t       v->times_used, v->lifetime);\n+      fprintf (loop_dump_stream, \" lifetime %d\",\n+\t       v->lifetime);\n \n       if (v->replaceable)\n  \tfprintf (loop_dump_stream, \" replaceable\");\n@@ -6305,21 +6304,23 @@ cmp_combine_givs_stats (x, y)\n   return d;\n }\n \n-/* If one of these givs is a DEST_REG that was only used once, by the\n-   other giv, this is actually a single use.  Return 0 if this is not\n+/* If one of these givs is a DEST_REG that was used by the other giv,\n+   this is actually a single use.  Return 0 if this is not\n    the case, -1 if g1 is the DEST_REG involved, and 1 if it was g2.  */\n \n static int\n-combine_givs_used_once (g1, g2)\n+combine_givs_used_by_other (g1, g2)\n      struct induction *g1, *g2;\n {\n+  /* Lines marked with ??? test a condition that wasn't meant to be tested\n+     and should be deleted.  */\n   if (g1->giv_type == DEST_REG\n-      && VARRAY_INT (n_times_used, REGNO (g1->dest_reg)) == 1\n+      && VARRAY_INT (n_times_set, REGNO (g1->dest_reg)) == 1 /* ??? */\n       && reg_mentioned_p (g1->dest_reg, PATTERN (g2->insn)))\n     return -1;\n \n   if (g2->giv_type == DEST_REG\n-      && VARRAY_INT (n_times_used, REGNO (g2->dest_reg)) == 1\n+      && VARRAY_INT (n_times_set, REGNO (g2->dest_reg)) == 1 /* ??? */\n       && reg_mentioned_p (g2->dest_reg, PATTERN (g1->insn)))\n     return 1;\n \n@@ -6330,7 +6331,7 @@ static int\n combine_givs_benefit_from (g1, g2)\n      struct induction *g1, *g2;\n {\n-  int tmp = combine_givs_used_once (g1, g2);\n+  int tmp = combine_givs_used_by_other (g1, g2);\n   if (tmp < 0)\n     return 0;\n   else if (tmp > 0)\n@@ -6441,8 +6442,6 @@ combine_givs (bl)\n \t      g2->new_reg = can_combine[i*giv_count + j];\n \t      g2->same = g1;\n \t      g1->combined_with = 1;\n-\t      if (!combine_givs_used_once (g1, g2))\n-\t\tg1->times_used += 1;\n \t      g1->lifetime += g2->lifetime;\n \n \t      g1_add_benefit += combine_givs_benefit_from (g1, g2);\n@@ -8332,7 +8331,7 @@ insert_loop_mem (mem, data)\n   return 0;\n }\n \n-/* Like load_mems, but also ensures that N_TIMES_SET,\n+/* Like load_mems, but also ensures that SET_IN_LOOP,\n    MAY_NOT_OPTIMIZE, REG_SINGLE_USAGE, and INSN_COUNT have the correct\n    values after load_mems.  */\n \n@@ -8350,7 +8349,7 @@ load_mems_and_recount_loop_regs_set (scan_start, end, loop_top, start,\n \n   load_mems (scan_start, end, loop_top, start);\n   \n-  /* Recalculate n_times_set and friends since load_mems may have\n+  /* Recalculate set_in_loop and friends since load_mems may have\n      created new registers.  */\n   if (max_reg_num () > nregs)\n     {\n@@ -8360,17 +8359,17 @@ load_mems_and_recount_loop_regs_set (scan_start, end, loop_top, start,\n       old_nregs = nregs;\n       nregs = max_reg_num ();\n \n-      if ((unsigned) nregs > n_times_set->num_elements)\n+      if ((unsigned) nregs > set_in_loop->num_elements)\n \t{\n \t  /* Grow all the arrays.  */\n+\t  VARRAY_GROW (set_in_loop, nregs);\n \t  VARRAY_GROW (n_times_set, nregs);\n-\t  VARRAY_GROW (n_times_used, nregs);\n \t  VARRAY_GROW (may_not_optimize, nregs);\n \t  if (reg_single_usage)\n \t    VARRAY_GROW (reg_single_usage, nregs);\n \t}\n       /* Clear the arrays */\n-      bzero ((char *) &n_times_set->data, nregs * sizeof (int));\n+      bzero ((char *) &set_in_loop->data, nregs * sizeof (int));\n       bzero ((char *) &may_not_optimize->data, nregs * sizeof (char));\n       if (reg_single_usage)\n \tbzero ((char *) &reg_single_usage->data, nregs * sizeof (rtx));\n@@ -8382,7 +8381,7 @@ load_mems_and_recount_loop_regs_set (scan_start, end, loop_top, start,\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t{\n \t  VARRAY_CHAR (may_not_optimize, i) = 1;\n-\t  VARRAY_INT (n_times_set, i) = 1;\n+\t  VARRAY_INT (set_in_loop, i) = 1;\n \t}\n       \n #ifdef AVOID_CCMODE_COPIES\n@@ -8393,9 +8392,9 @@ load_mems_and_recount_loop_regs_set (scan_start, end, loop_top, start,\n \t  VARRAY_CHAR (may_not_optimize, i) = 1;\n #endif\n \n-      /* Set n_times_used for the new registers.  */\n-      bcopy ((char *) (&n_times_set->data.i[0] + old_nregs),\n-\t     (char *) (&n_times_used->data.i[0] + old_nregs),\n+      /* Set n_times_set for the new registers.  */\n+      bcopy ((char *) (&set_in_loop->data.i[0] + old_nregs),\n+\t     (char *) (&n_times_set->data.i[0] + old_nregs),\n \t     (nregs - old_nregs) * sizeof (int));\n     }\n }"}, {"sha": "8d0055e1dd03521e508715703694e4da86109122", "filename": "gcc/loop.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b259e3fd8a2459f2c5d36fcc573884b725ada14/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b259e3fd8a2459f2c5d36fcc573884b725ada14/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=4b259e3fd8a2459f2c5d36fcc573884b725ada14", "patch": "@@ -97,7 +97,6 @@ struct induction\n   unsigned shared : 1;\n   unsigned no_const_addval : 1; /* 1 if add_val does not contain a const. */\n   int lifetime;\t\t\t/* Length of life of this giv */\n-  int times_used;\t\t/* # times this giv is used. */\n   rtx derive_adjustment;\t/* If nonzero, is an adjustment to be\n \t\t\t\t   subtracted from add_val when this giv\n \t\t\t\t   derives another.  This occurs when the"}]}