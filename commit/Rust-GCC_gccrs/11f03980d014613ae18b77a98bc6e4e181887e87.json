{"sha": "11f03980d014613ae18b77a98bc6e4e181887e87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFmMDM5ODBkMDE0NjEzYWUxOGI3N2E5OGJjNmU0ZTE4MTg4N2U4Nw==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2007-04-06T09:22:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:22:07Z"}, "message": "g-debpoo.adb (Validity): New package with a complete new implementation of subprograms Is_Valid and...\n\n2007-04-06  Vincent Celier  <celier@adacore.com>\n\n\t* g-debpoo.adb (Validity): New package with a complete new\n\timplementation of subprograms Is_Valid and Set_Valid.\n\t(Is_Valid): Move to local package Validity\n\t(Set_Valid): Move to local package Validity\n\nFrom-SVN: r123572", "tree": {"sha": "229cb58e4d3f0b9616d46b11dfa66bbd7faf9bb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/229cb58e4d3f0b9616d46b11dfa66bbd7faf9bb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11f03980d014613ae18b77a98bc6e4e181887e87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11f03980d014613ae18b77a98bc6e4e181887e87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11f03980d014613ae18b77a98bc6e4e181887e87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11f03980d014613ae18b77a98bc6e4e181887e87/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "358f47f3b16dc4af70740ae3a13a3016b20bd73a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/358f47f3b16dc4af70740ae3a13a3016b20bd73a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/358f47f3b16dc4af70740ae3a13a3016b20bd73a"}], "stats": {"total": 341, "additions": 139, "deletions": 202}, "files": [{"sha": "030a235e30f98656d052f887a559149c31504f49", "filename": "gcc/ada/g-debpoo.adb", "status": "modified", "additions": 139, "deletions": 202, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11f03980d014613ae18b77a98bc6e4e181887e87/gcc%2Fada%2Fg-debpoo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11f03980d014613ae18b77a98bc6e4e181887e87/gcc%2Fada%2Fg-debpoo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.adb?ref=11f03980d014613ae18b77a98bc6e4e181887e87", "patch": "@@ -53,12 +53,6 @@ package body GNAT.Debug_Pools is\n    --  and at the same time makes it easy to find the location of the extra\n    --  header allocated for each chunk.\n \n-   Initial_Memory_Size : constant Storage_Offset := 2 ** 26; --  64 Mb\n-   --  Initial size of memory that the debug pool can handle. This is used to\n-   --  compute the size of the htable used to monitor the blocks, but this is\n-   --  dynamic and will grow as needed. Having a bigger size here means a\n-   --  longer setup time, but less time spent later on to grow the array.\n-\n    Max_Ignored_Levels : constant Natural := 10;\n    --  Maximum number of levels that will be ignored in backtraces. This is so\n    --  that we still have enough significant levels in the tracebacks returned\n@@ -210,64 +204,6 @@ package body GNAT.Debug_Pools is\n    --  Minimal allocation: size of allocation_header rounded up to next\n    --  multiple of default alignment + worst-case padding.\n \n-   -----------------------\n-   -- Allocations table --\n-   -----------------------\n-\n-   --  This table is indexed on addresses modulo Default_Alignment, and for\n-   --  each index it indicates whether that memory block is valid. Its behavior\n-   --  is similar to GNAT.Table, except that we need to pack the table to save\n-   --  space, so we cannot reuse GNAT.Table as is.\n-\n-   --  This table is the reason why all alignments have to be forced to common\n-   --  value (Default_Alignment), so that this table can be kept to a\n-   --  reasonnable size.\n-\n-   type Byte is mod 2 ** System.Storage_Unit;\n-\n-   Big_Table_Size : constant Storage_Offset :=\n-                      (Storage_Offset'Last - 1) / Default_Alignment;\n-   type Big_Table is array (0 .. Big_Table_Size) of Byte;\n-   --  A simple, flat-array type used to access memory bytes (see the comment\n-   --  for Valid_Blocks below).\n-   --\n-   --  It would be cleaner to represent this as a packed array of Boolean.\n-   --  However, we cannot specify pragma Pack for such an array, since the\n-   --  total size on a 64 bit machine would be too big (> Integer'Last).\n-   --\n-   --  Given an address, we know if it is under control of the debug pool if\n-   --  the byte at index:\n-   --       ((Address - Edata'Address) / Default_Alignment)\n-   --        / Storage_unit\n-   --  has the bit\n-   --       ((Address - Edata'Address) / Default_Alignment)\n-   --        mod Storage_Unit\n-   --  set to 1.\n-   --\n-   --  See the subprograms Is_Valid and Set_Valid for proper manipulation of\n-   --  this array.\n-\n-   type Table_Ptr is access Big_Table;\n-   function To_Pointer is new Ada.Unchecked_Conversion\n-     (System.Address, Table_Ptr);\n-\n-   Valid_Blocks      : Table_Ptr      := null;\n-   Valid_Blocks_Size : Storage_Offset := 0;\n-   --  These two variables represents a mapping of the currently allocated\n-   --  memory. Every time the pool works on an address, we first check that the\n-   --  index Address / Default_Alignment is True. If not, this means that this\n-   --  address is not under control of the debug pool and thus this is probably\n-   --  an invalid memory access (it could also be a general access type).\n-   --\n-   --  Note that in fact we never allocate the full size of Big_Table, only a\n-   --  slice big enough to manage the currently allocated memory.\n-\n-   Edata : System.Address := System.Null_Address;\n-   --  Address in memory that matches the index 0 in Valid_Blocks. It is named\n-   --  after the symbol _edata, which, on most systems, indicate the lowest\n-   --  possible address returned by malloc. Unfortunately, this symbol doesn't\n-   --  exist on windows, so we cannot use it instead of this variable.\n-\n    -----------------------\n    -- Local subprograms --\n    -----------------------\n@@ -297,16 +233,19 @@ package body GNAT.Debug_Pools is\n    --  addresses up to the first one in the range\n    --  Ignored_Frame_Start .. Ignored_Frame_End\n \n-   function Is_Valid (Storage : System.Address) return Boolean;\n-   pragma Inline (Is_Valid);\n-   --  Return True if Storage is an address that the debug pool has under its\n-   --  control.\n+   package Validity is\n+      function Is_Valid (Storage : System.Address) return Boolean;\n+      pragma Inline (Is_Valid);\n+      --  Return True if Storage is an address that the debug pool has under\n+      --  its control.\n \n-   procedure Set_Valid (Storage : System.Address; Value : Boolean);\n-   pragma Inline (Set_Valid);\n-   --  Mark the address Storage as being under control of the memory pool (if\n-   --  Value is True), or not (if Value is False). This procedure will\n-   --  reallocate the table Valid_Blocks as needed.\n+      procedure Set_Valid (Storage : System.Address; Value : Boolean);\n+      pragma Inline (Set_Valid);\n+      --  Mark the address Storage as being under control of the memory pool\n+      --  (if Value is True), or not (if Value is False).\n+   end Validity;\n+\n+   use Validity;\n \n    procedure Set_Dead_Beef\n      (Storage_Address          : System.Address;\n@@ -551,143 +490,129 @@ package body GNAT.Debug_Pools is\n    end Find_Or_Create_Traceback;\n \n    --------------\n-   -- Is_Valid --\n+   -- Validity --\n    --------------\n \n-   function Is_Valid (Storage : System.Address) return Boolean is\n+   package body Validity is\n \n-      --  We use the following constant declaration, instead of\n-      --     Offset : constant Storage_Offset :=\n-      --                (Storage - Edata) / Default_Alignment;\n-      --  See comments in Set_Valid for details.\n+      --  The validity bits of the allocated blocks are kept in a has table.\n+      --  Each component of the hash table contains the validity bits for a\n+      --  16 Mbyte memory chunk.\n \n-      Offset : constant Storage_Offset :=\n-                 Storage_Offset ((To_Integer (Storage) - To_Integer (Edata)) /\n-                                   Default_Alignment);\n+      --  The reason the validity bits are kept for chunks of memory rather\n+      --  than in a big array is that on some 64 bit platforms, it may happen\n+      --  that two chunk of allocated data are very far from each other.\n \n-      Bit : constant Byte := 2 ** Natural (Offset mod System.Storage_Unit);\n+      Memory_Chunk_Size : constant Integer_Address := 2 ** 24; --  16 MB\n+      Validity_Divisor  : constant := Default_Alignment * System.Storage_Unit;\n \n-   begin\n-      return (Storage mod Default_Alignment) = 0\n-        and then Offset >= 0\n-        and then Offset < Valid_Blocks_Size * Storage_Unit\n-        and then (Valid_Blocks (Offset / Storage_Unit) and Bit) /= 0;\n-   end Is_Valid;\n+      Max_Validity_Byte_Index : constant :=\n+                                 Memory_Chunk_Size / Validity_Divisor;\n \n-   ---------------\n-   -- Set_Valid --\n-   ---------------\n+      subtype Validity_Byte_Index is Integer_Address\n+                                      range 0 .. Max_Validity_Byte_Index - 1;\n \n-   procedure Set_Valid (Storage : System.Address; Value : Boolean) is\n-      Offset : Storage_Offset;\n-      Bit    : Byte;\n-      Bytes  : Storage_Offset;\n-      Tmp    : constant Table_Ptr := Valid_Blocks;\n+      type Byte is mod 2 ** System.Storage_Unit;\n \n-      Edata_Align : constant Storage_Offset :=\n-                      Default_Alignment * Storage_Unit;\n+      type Validity_Bits is array (Validity_Byte_Index) of Byte;\n \n-      procedure Memset (A : Address; C : Integer; N : size_t);\n-      pragma Import (C, Memset, \"memset\");\n+      type Validity_Bits_Ref is access all Validity_Bits;\n+      No_Validity_Bits : constant Validity_Bits_Ref := null;\n \n-      procedure Memmove (Dest, Src : Address; N : size_t);\n-      pragma Import (C, Memmove, \"memmove\");\n+      Max_Header_Num : constant := 1023;\n \n-   begin\n-      --  Allocate, or reallocate, the valid blocks table as needed. We start\n-      --  with a size big enough to handle Initial_Memory_Size bytes of memory,\n-      --  to avoid too many reallocations. The table will typically be around\n-      --  16Mb in that case, which is still small enough.\n+      type Header_Num is range 0 .. Max_Header_Num - 1;\n \n-      if Valid_Blocks_Size = 0 then\n-         Valid_Blocks_Size := (Initial_Memory_Size / Default_Alignment)\n-                                                      / Storage_Unit;\n-         Valid_Blocks := To_Pointer (Alloc (size_t (Valid_Blocks_Size)));\n-         Edata := Storage;\n+      function Hash (F : Integer_Address) return Header_Num;\n \n-         --  Reset the memory using memset, which is much faster than the\n-         --  standard Ada code with \"when others\"\n-\n-         Memset (Valid_Blocks.all'Address, 0, size_t (Valid_Blocks_Size));\n-      end if;\n-\n-      --  First case : the new address is outside of the current scope of\n-      --  Valid_Blocks, before the current start address. We need to reallocate\n-      --  the table accordingly. This should be a rare occurence, since in most\n-      --  cases, the first allocation will also have the lowest address. But\n-      --  there is no garantee...\n-\n-      if Storage < Edata then\n-\n-         --  The difference between the new Edata and the current one must be\n-         --  a multiple of Default_Alignment * Storage_Unit, so that the bit\n-         --  representing an address in Valid_Blocks are kept the same.\n-\n-         Offset := ((Edata - Storage) / Edata_Align + 1) * Edata_Align;\n-         Offset := Offset / Default_Alignment;\n-         Bytes  := Offset / Storage_Unit;\n-         Valid_Blocks :=\n-           To_Pointer (Alloc (Size => size_t (Valid_Blocks_Size + Bytes)));\n-         Memmove (Dest => Valid_Blocks.all'Address + Bytes,\n-                  Src  => Tmp.all'Address,\n-                  N    => size_t (Valid_Blocks_Size));\n-         Memset (A => Valid_Blocks.all'Address,\n-                 C => 0,\n-                 N => size_t (Bytes));\n-         Free (Tmp.all'Address);\n-         Valid_Blocks_Size := Valid_Blocks_Size + Bytes;\n-\n-         --  Take into the account the new start address\n-\n-         Edata := Storage - Edata_Align + (Edata - Storage) mod Edata_Align;\n-      end if;\n+      package Validy_Htable is new GNAT.HTable.Simple_HTable\n+        (Header_Num => Header_Num,\n+         Element    => Validity_Bits_Ref,\n+         No_Element => No_Validity_Bits,\n+         Key        => Integer_Address,\n+         Hash       => Hash,\n+         Equal      => \"=\");\n+      --  Table to keep the validity bit blocks for the allocated data\n \n-      --  Second case : the new address is outside of the current scope of\n-      --  Valid_Blocks, so we have to grow the table as appropriate.\n+      function To_Pointer is new Ada.Unchecked_Conversion\n+        (System.Address, Validity_Bits_Ref);\n \n-      --  Note: it might seem more natural for the following statement to\n-      --  be written:\n+      procedure Memset (A : Address; C : Integer; N : size_t);\n+      pragma Import (C, Memset, \"memset\");\n \n-      --      Offset := (Storage - Edata) / Default_Alignment;\n+      ----------\n+      -- Hash --\n+      ----------\n \n-      --  but that won't work since Storage_Offset is signed, and it is\n-      --  possible to subtract a small address from a large address and\n-      --  get a negative value. This may seem strange, but it is quite\n-      --  specifically allowed in the RM, and is what most implementations\n-      --  including GNAT actually do. Hence the conversion to Integer_Address\n-      --  which is a full range modular type, not subject to this glitch.\n+      function Hash (F : Integer_Address) return Header_Num is\n+      begin\n+         return Header_Num (F mod Max_Header_Num);\n+      end Hash;\n+\n+      --------------\n+      -- Is_Valid --\n+      --------------\n+\n+      function Is_Valid (Storage : System.Address) return Boolean is\n+         Int_Storage  : constant Integer_Address := To_Integer (Storage);\n+         Block_Number : constant Integer_Address :=\n+                          Int_Storage /  Memory_Chunk_Size;\n+         Ptr          : constant Validity_Bits_Ref :=\n+                          Validy_Htable.Get (Block_Number);\n+         Offset       : constant Integer_Address :=\n+                          (Int_Storage - (Block_Number * Memory_Chunk_Size)) /\n+                             Default_Alignment;\n+         Bit          : constant Byte :=\n+                          2 ** Natural (Offset mod System.Storage_Unit);\n+      begin\n+         if Ptr = No_Validity_Bits then\n+            return False;\n+         else\n+            return (Ptr (Offset / System.Storage_Unit) and Bit) /= 0;\n+         end if;\n+      end Is_Valid;\n+\n+      ---------------\n+      -- Set_Valid --\n+      ---------------\n+\n+      procedure Set_Valid (Storage : System.Address; Value : Boolean) is\n+         Int_Storage  : constant Integer_Address := To_Integer (Storage);\n+         Block_Number : constant Integer_Address :=\n+                          Int_Storage /  Memory_Chunk_Size;\n+         Ptr          : Validity_Bits_Ref := Validy_Htable.Get (Block_Number);\n+         Offset       : constant Integer_Address :=\n+                          (Int_Storage - (Block_Number * Memory_Chunk_Size)) /\n+                             Default_Alignment;\n+         Bit          : constant Byte :=\n+                          2 ** Natural (Offset mod System.Storage_Unit);\n \n-      Offset := Storage_Offset ((To_Integer (Storage) - To_Integer (Edata)) /\n-                                              Default_Alignment);\n+      begin\n+         if Ptr = No_Validity_Bits then\n \n-      if Offset >= Valid_Blocks_Size * System.Storage_Unit then\n-         Bytes := Valid_Blocks_Size;\n-         loop\n-            Bytes := 2 * Bytes;\n-            exit when Offset <= Bytes * System.Storage_Unit;\n-         end loop;\n+            --  First time in this memory area: allocate a new block and put\n+            --  it in the table.\n \n-         Valid_Blocks := To_Pointer\n-           (Realloc (Ptr  => Valid_Blocks.all'Address,\n-                     Size => size_t (Bytes)));\n-         Memset\n-           (Valid_Blocks.all'Address + Valid_Blocks_Size,\n-            0,\n-            size_t (Bytes - Valid_Blocks_Size));\n-         Valid_Blocks_Size := Bytes;\n-      end if;\n+            if Value then\n+               Ptr := To_Pointer (Alloc (size_t (Max_Validity_Byte_Index)));\n+               Validy_Htable.Set (Block_Number, Ptr);\n+               Memset (Ptr.all'Address, 0, size_t (Max_Validity_Byte_Index));\n+               Ptr (Offset / System.Storage_Unit) := Bit;\n+            end if;\n \n-      Bit    := 2 ** Natural (Offset mod System.Storage_Unit);\n-      Bytes  := Offset / Storage_Unit;\n+         else\n+            if Value then\n+               Ptr (Offset / System.Storage_Unit) :=\n+                 Ptr (Offset / System.Storage_Unit) or Bit;\n \n-      --  Then set the value as valid\n+            else\n+               Ptr (Offset / System.Storage_Unit) :=\n+                 Ptr (Offset / System.Storage_Unit) and (not Bit);\n+            end if;\n+         end if;\n+      end Set_Valid;\n \n-      if Value then\n-         Valid_Blocks (Bytes) := Valid_Blocks (Bytes) or Bit;\n-      else\n-         Valid_Blocks (Bytes) := Valid_Blocks (Bytes) and (not Bit);\n-      end if;\n-   end Set_Valid;\n+   end Validity;\n \n    --------------\n    -- Allocate --\n@@ -706,11 +631,10 @@ package body GNAT.Debug_Pools is\n         (1 .. Size_In_Storage_Elements + Minimum_Allocation);\n \n       type Ptr is access Local_Storage_Array;\n-      --  On some systems, we might want to physically protect pages\n-      --  against writing when they have been freed (of course, this is\n-      --  expensive in terms of wasted memory). To do that, all we should\n-      --  have to do it to set the size of this array to the page size.\n-      --  See mprotect().\n+      --  On some systems, we might want to physically protect pages against\n+      --  writing when they have been freed (of course, this is expensive in\n+      --  terms of wasted memory). To do that, all we should have to do it to\n+      --  set the size of this array to the page size. See mprotect().\n \n       P : Ptr;\n \n@@ -723,10 +647,10 @@ package body GNAT.Debug_Pools is\n \n       --  If necessary, start physically releasing memory. The reason this is\n       --  done here, although Pool.Logically_Deallocated has not changed above,\n-      --  is so that we do this only after a series of deallocations (e.g a\n-      --  loop that deallocates a big array). If we were doing that in\n-      --  Deallocate, we might be physically freeing memory several times\n-      --  during the loop, which is expensive.\n+      --  is so that we do this only after a series of deallocations (e.g loop\n+      --  that deallocates a big array). If we were doing that in Deallocate,\n+      --  we might be physically freeing memory several times during the loop,\n+      --  which is expensive.\n \n       if Pool.Logically_Deallocated >\n         Byte_Count (Pool.Maximum_Logically_Freed_Memory)\n@@ -764,8 +688,8 @@ package body GNAT.Debug_Pools is\n          Allocate_Label'Address, Code_Address_For_Allocate_End);\n \n       pragma Warnings (Off);\n-      --  Turn warning on alignment for convert call off. We know that in\n-      --  fact this conversion is safe since P itself is always aligned on\n+      --  Turn warning on alignment for convert call off. We know that in fact\n+      --  this conversion is safe since P itself is always aligned on\n       --  Default_Alignment.\n \n       Header_Of (Storage_Address).all :=\n@@ -822,9 +746,9 @@ package body GNAT.Debug_Pools is\n    -- Allocate_End --\n    ------------------\n \n-   --  DO NOT MOVE, this must be right after Allocate. This is similar to\n-   --  what is done in a-except, so that we can hide the traceback frames\n-   --  internal to this package\n+   --  DO NOT MOVE, this must be right after Allocate. This is similar to what\n+   --  is done in a-except, so that we can hide the traceback frames internal\n+   --  to this package\n \n    procedure Allocate_End is\n    begin\n@@ -946,7 +870,7 @@ package body GNAT.Debug_Pools is\n             Header := Header_Of (Tmp);\n \n             --  If we know, or at least assume, the block is no longer\n-            --  reference anywhere, we can free it physically.\n+            --  referenced anywhere, we can free it physically.\n \n             if Ignore_Marks or else not Marked (Tmp) then\n \n@@ -1043,6 +967,7 @@ package body GNAT.Debug_Pools is\n \n                   --  Do not even attempt to mark blocks in use. That would\n                   --  screw up the whole application, of course.\n+\n                   if Header.Block_Size < 0 then\n                      Mark (Header, Pointed, In_Use => True);\n                   end if;\n@@ -1085,7 +1010,11 @@ package body GNAT.Debug_Pools is\n       Lock_Task.all;\n \n       if Pool.Advanced_Scanning then\n-         Reset_Marks; --  Reset the mark for each freed block\n+\n+         --  Reset the mark for each freed block\n+\n+         Reset_Marks;\n+\n          Mark_Blocks;\n       end if;\n \n@@ -1232,8 +1161,11 @@ package body GNAT.Debug_Pools is\n    --------------------\n \n    --  DO NOT MOVE, this must be right after Deallocate\n+\n    --  See Allocate_End\n \n+   --  This is making assumptions about code order that may be invalid ???\n+\n    procedure Deallocate_End is\n    begin\n       <<Deallocate_End_Label>>\n@@ -1301,8 +1233,11 @@ package body GNAT.Debug_Pools is\n    ---------------------\n \n    --  DO NOT MOVE: this must be right after Dereference\n+\n    --  See Allocate_End\n \n+   --  This is making assumptions about code order that may be invalid ???\n+\n    procedure Dereference_End is\n    begin\n       <<Dereference_End_Label>>\n@@ -1651,6 +1586,8 @@ package body GNAT.Debug_Pools is\n       fclose (File);\n    end Dump_Gnatmem;\n \n+--  Package initialization\n+\n begin\n    Allocate_End;\n    Deallocate_End;"}]}