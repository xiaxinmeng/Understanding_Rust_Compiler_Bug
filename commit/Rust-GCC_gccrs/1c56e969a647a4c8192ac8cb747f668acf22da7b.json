{"sha": "1c56e969a647a4c8192ac8cb747f668acf22da7b", "node_id": "C_kwDOANBUbNoAKDFjNTZlOTY5YTY0N2E0YzgxOTJhYzhjYjc0N2Y2NjhhY2YyMmRhN2I", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-04-26T08:30:44Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-04-28T13:44:34Z"}, "message": "ast: resolve: Implement `resolve_visibility` method", "tree": {"sha": "40fb9a20b8432f0d0267683d04be36250e154ac9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40fb9a20b8432f0d0267683d04be36250e154ac9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c56e969a647a4c8192ac8cb747f668acf22da7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c56e969a647a4c8192ac8cb747f668acf22da7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c56e969a647a4c8192ac8cb747f668acf22da7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c56e969a647a4c8192ac8cb747f668acf22da7b/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06c5f54ccc1b94e0e7025478d3f36ee2eb334bde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06c5f54ccc1b94e0e7025478d3f36ee2eb334bde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06c5f54ccc1b94e0e7025478d3f36ee2eb334bde"}], "stats": {"total": 171, "additions": 109, "deletions": 62}, "files": [{"sha": "9dc61a881c895e81ecf46a22604b89bc3b0c4ce3", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c56e969a647a4c8192ac8cb747f668acf22da7b/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c56e969a647a4c8192ac8cb747f668acf22da7b/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=1c56e969a647a4c8192ac8cb747f668acf22da7b", "patch": "@@ -701,6 +701,7 @@ struct Visibility\n \n   std::string as_string () const;\n   const SimplePath &get_path () const { return in_path; }\n+  SimplePath &get_path () { return in_path; }\n \n protected:\n   // Clone function implementation - not currently virtual but may be if"}, {"sha": "2a86618e04396a25e0719bd284b28c1990e8806f", "filename": "gcc/rust/resolve/rust-ast-resolve-base.cc", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c56e969a647a4c8192ac8cb747f668acf22da7b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c56e969a647a4c8192ac8cb747f668acf22da7b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.cc?ref=1c56e969a647a4c8192ac8cb747f668acf22da7b", "patch": "@@ -17,15 +17,27 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-resolve-expr.h\"\n+#include \"rust-ast-resolve-path.h\"\n+#include \"rust-item.h\"\n \n namespace Rust {\n namespace Resolver {\n \n bool\n-resolve_visibility (const AST::Visibility &vis)\n+ResolverBase::resolve_visibility (const AST::Visibility &vis)\n {\n-  gcc_unreachable ();\n-  return false;\n+  if (vis.has_path ())\n+    {\n+      auto path = vis.get_path ();\n+      ResolvePath::go (&path, parent);\n+\n+      // Do we need to lookup something here?\n+      // Is it just about resolving the names correctly so we can look them up\n+      // later?\n+    }\n+\n+  return true;\n }\n \n // Default visitors implementations"}, {"sha": "2c383c927fa60534586b645364fca1576d19b5e6", "filename": "gcc/rust/resolve/rust-ast-resolve-item.cc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c56e969a647a4c8192ac8cb747f668acf22da7b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c56e969a647a4c8192ac8cb747f668acf22da7b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc?ref=1c56e969a647a4c8192ac8cb747f668acf22da7b", "patch": "@@ -238,6 +238,8 @@ ResolveItem::visit (AST::Module &module)\n   mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t   module.get_node_id (), cpath);\n \n+  resolve_visibility (module.get_visibility ());\n+\n   NodeId scope_node_id = module.get_node_id ();\n   resolver->get_name_scope ().push (scope_node_id);\n   resolver->get_type_scope ().push (scope_node_id);\n@@ -267,6 +269,8 @@ ResolveItem::visit (AST::TupleStruct &struct_decl)\n   mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t   struct_decl.get_node_id (), cpath);\n \n+  resolve_visibility (struct_decl.get_visibility ());\n+\n   NodeId scope_node_id = struct_decl.get_node_id ();\n   resolver->get_type_scope ().push (scope_node_id);\n \n@@ -286,6 +290,8 @@ ResolveItem::visit (AST::TupleStruct &struct_decl)\n       if (field.get_field_type ()->is_marked_for_strip ())\n \tcontinue;\n \n+      resolve_visibility (field.get_visibility ());\n+\n       ResolveType::go (field.get_field_type ().get (),\n \t\t       struct_decl.get_node_id ());\n     }\n@@ -303,6 +309,8 @@ ResolveItem::visit (AST::Enum &enum_decl)\n   mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t   enum_decl.get_node_id (), cpath);\n \n+  resolve_visibility (enum_decl.get_visibility ());\n+\n   NodeId scope_node_id = enum_decl.get_node_id ();\n   resolver->get_type_scope ().push (scope_node_id);\n \n@@ -328,6 +336,9 @@ ResolveItem::visit (AST::Enum &enum_decl)\n void\n ResolveItem::visit (AST::EnumItem &item)\n {\n+  // Since at this point we cannot have visibilities on enum items anymore, we\n+  // can skip handling them\n+\n   auto decl\n     = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n   auto path = prefix.append (decl);\n@@ -396,6 +407,8 @@ ResolveItem::visit (AST::StructStruct &struct_decl)\n   mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t   struct_decl.get_node_id (), cpath);\n \n+  resolve_visibility (struct_decl.get_visibility ());\n+\n   NodeId scope_node_id = struct_decl.get_node_id ();\n   resolver->get_type_scope ().push (scope_node_id);\n \n@@ -415,6 +428,8 @@ ResolveItem::visit (AST::StructStruct &struct_decl)\n       if (field.get_field_type ()->is_marked_for_strip ())\n \tcontinue;\n \n+      resolve_visibility (field.get_visibility ());\n+\n       ResolveType::go (field.get_field_type ().get (),\n \t\t       struct_decl.get_node_id ());\n     }\n@@ -432,6 +447,8 @@ ResolveItem::visit (AST::Union &union_decl)\n   mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t   union_decl.get_node_id (), cpath);\n \n+  resolve_visibility (union_decl.get_visibility ());\n+\n   NodeId scope_node_id = union_decl.get_node_id ();\n   resolver->get_type_scope ().push (scope_node_id);\n \n@@ -485,6 +502,8 @@ ResolveItem::visit (AST::ConstantItem &constant)\n   mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t   constant.get_node_id (), cpath);\n \n+  resolve_visibility (constant.get_visibility ());\n+\n   ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n   ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (), path,\n \t\t   cpath);\n@@ -505,6 +524,8 @@ ResolveItem::visit (AST::Function &function)\n   mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t   function.get_node_id (), cpath);\n \n+  resolve_visibility (function.get_visibility ());\n+\n   NodeId scope_node_id = function.get_node_id ();\n   resolver->get_name_scope ().push (scope_node_id);\n   resolver->get_type_scope ().push (scope_node_id);\n@@ -559,6 +580,8 @@ ResolveItem::visit (AST::InherentImpl &impl_block)\n   resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n   resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n \n+  resolve_visibility (impl_block.get_visibility ());\n+\n   if (impl_block.has_generics ())\n     {\n       for (auto &generic : impl_block.get_generic_params ())\n@@ -640,6 +663,9 @@ ResolveItem::visit (AST::Method &method)\n \t\t\t\t   method.get_node_id (), cpath);\n \n   NodeId scope_node_id = method.get_node_id ();\n+\n+  resolve_visibility (method.get_visibility ());\n+\n   resolver->get_name_scope ().push (scope_node_id);\n   resolver->get_type_scope ().push (scope_node_id);\n   resolver->get_label_scope ().push (scope_node_id);\n@@ -711,6 +737,9 @@ void\n ResolveItem::visit (AST::TraitImpl &impl_block)\n {\n   NodeId scope_node_id = impl_block.get_node_id ();\n+\n+  resolve_visibility (impl_block.get_visibility ());\n+\n   resolver->get_name_scope ().push (scope_node_id);\n   resolver->get_type_scope ().push (scope_node_id);\n   resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n@@ -812,6 +841,9 @@ void\n ResolveItem::visit (AST::Trait &trait)\n {\n   NodeId scope_node_id = trait.get_node_id ();\n+\n+  resolve_visibility (trait.get_visibility ());\n+\n   resolver->get_name_scope ().push (scope_node_id);\n   resolver->get_type_scope ().push (scope_node_id);\n   resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n@@ -862,6 +894,8 @@ ResolveItem::visit (AST::Trait &trait)\n void\n ResolveItem::visit (AST::ExternBlock &extern_block)\n {\n+  resolve_visibility (extern_block.get_visibility ());\n+\n   for (auto &item : extern_block.get_extern_items ())\n     {\n       resolve_extern_item (item.get ());\n@@ -895,6 +929,8 @@ ResolveImplItems::visit (AST::TypeAlias &alias)\n {\n   ResolveItem::visit (alias);\n \n+  resolve_visibility (alias.get_visibility ());\n+\n   // FIXME this stops the erronious unused decls which will be fixed later on\n   resolver->get_type_scope ().append_reference_for_def (alias.get_node_id (),\n \t\t\t\t\t\t\talias.get_node_id ());\n@@ -911,6 +947,9 @@ void\n ResolveExternItem::visit (AST::ExternalFunctionItem &function)\n {\n   NodeId scope_node_id = function.get_node_id ();\n+\n+  resolve_visibility (function.get_visibility ());\n+\n   resolver->get_name_scope ().push (scope_node_id);\n   resolver->get_type_scope ().push (scope_node_id);\n   resolver->get_label_scope ().push (scope_node_id);\n@@ -945,6 +984,8 @@ ResolveExternItem::visit (AST::ExternalFunctionItem &function)\n void\n ResolveExternItem::visit (AST::ExternalStaticItem &item)\n {\n+  resolve_visibility (item.get_visibility ());\n+\n   ResolveType::go (item.get_type ().get (), item.get_node_id ());\n }\n "}, {"sha": "c7597a25070a3e7d2b5dcfe4ce0b9debf21d67ab", "filename": "gcc/rust/resolve/rust-ast-resolve-path.cc", "status": "modified", "additions": 38, "deletions": 59, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c56e969a647a4c8192ac8cb747f668acf22da7b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c56e969a647a4c8192ac8cb747f668acf22da7b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc?ref=1c56e969a647a4c8192ac8cb747f668acf22da7b", "patch": "@@ -279,90 +279,69 @@ ResolvePath::resolve_segments (CanonicalPath prefix, size_t offs,\n     }\n }\n \n-void\n-ResolvePath::resolve_path (AST::SimplePath *expr)\n+static bool\n+lookup_and_insert_segment (Resolver *resolver, CanonicalPath path,\n+\t\t\t   NodeId segment_id, NodeId *to_resolve, bool &is_type)\n {\n-  // resolve root segment first then apply segments in turn\n-  auto &segs = expr->get_segments ();\n-  auto &root_segment = segs.at (0);\n-  auto &root_ident_seg = root_segment.get_segment_name ();\n-\n-  /**\n-   * TODO: We need to handle functions and types later on for `use` statements.\n-   * So we will also need to check the type scope\n-   *\n-   * bool segment_is_type = false;\n-   * bool segment_is_func = false;\n-   */\n-  CanonicalPath root_seg_path\n-    = CanonicalPath::new_seg (root_segment.get_node_id (), root_ident_seg);\n-\n-  // name scope first\n-  if (resolver->get_name_scope ().lookup (root_seg_path, &resolved_node))\n+  if (resolver->get_name_scope ().lookup (path, to_resolve))\n     {\n-      resolver->insert_resolved_name (root_segment.get_node_id (),\n-\t\t\t\t      resolved_node);\n-      resolver->insert_new_definition (root_segment.get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n+      resolver->insert_resolved_name (segment_id, *to_resolve);\n     }\n-  else\n+  else if (resolver->get_type_scope ().lookup (path, to_resolve))\n     {\n-      rust_error_at (expr->get_locus (),\n-\t\t     \"Cannot find path %<%s%> in this scope\",\n-\t\t     root_segment.as_string ().c_str ());\n-      return;\n+      is_type = true;\n+      resolver->insert_resolved_type (segment_id, *to_resolve);\n     }\n-\n-  bool is_single_segment = segs.size () == 1;\n-  if (is_single_segment)\n+  else\n     {\n-      // if (segment_is_type)\n-      // resolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n-\n-      resolver->insert_resolved_name (expr->get_node_id (), resolved_node);\n-      resolver->insert_new_definition (expr->get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n-      return;\n+      return false;\n     }\n \n-  resolve_simple_path_segments (root_seg_path, 1, expr->get_segments (),\n-\t\t\t\texpr->get_node_id (), expr->get_locus ());\n+  return true;\n }\n \n void\n-ResolvePath::resolve_simple_path_segments (\n-  CanonicalPath prefix, size_t offs,\n-  const std::vector<AST::SimplePathSegment> &segs, NodeId expr_node_id,\n-  Location expr_locus)\n+ResolvePath::resolve_path (AST::SimplePath *simple_path)\n {\n-  /**\n-   * TODO: We also need to handle types and functions here\n-   */\n+  // resolve root segment first then apply segments in turn\n+  auto expr_node_id = simple_path->get_node_id ();\n+  auto is_type = false;\n \n-  CanonicalPath path = prefix;\n-  for (const auto &seg : segs)\n+  auto path = CanonicalPath::create_empty ();\n+  for (const auto &seg : simple_path->get_segments ())\n     {\n       auto s = ResolveSimplePathSegmentToCanonicalPath::resolve (seg);\n       path = path.append (s);\n \n+      // Reset state\n       resolved_node = UNKNOWN_NODEID;\n+      is_type = false;\n \n-      if (resolver->get_name_scope ().lookup (path, &resolved_node))\n+      if (!lookup_and_insert_segment (resolver, path, seg.get_node_id (),\n+\t\t\t\t      &resolved_node, is_type))\n \t{\n-\t  resolver->insert_resolved_name (seg.get_node_id (), resolved_node);\n-\t  resolver->insert_new_definition (seg.get_node_id (),\n-\t\t\t\t\t   Definition{expr_node_id, parent});\n+\t  rust_error_at (seg.get_locus (),\n+\t\t\t \"cannot find simple path segment %qs\",\n+\t\t\t seg.as_string ().c_str ());\n+\t  return;\n \t}\n     }\n \n-  if (resolved_node != UNKNOWN_NODEID)\n+  if (resolved_node == UNKNOWN_NODEID)\n     {\n-      resolver->insert_resolved_name (expr_node_id, resolved_node);\n-      resolver->insert_new_definition (expr_node_id,\n-\t\t\t\t       Definition{expr_node_id, parent});\n+      rust_error_at (simple_path->get_locus (),\n+\t\t     \"could not resolve simple path %qs\",\n+\t\t     simple_path->as_string ().c_str ());\n+      return;\n     }\n+\n+  if (is_type)\n+    resolver->insert_resolved_type (expr_node_id, resolved_node);\n+  else\n+    resolver->insert_resolved_name (expr_node_id, resolved_node);\n+\n+  resolver->insert_new_definition (expr_node_id,\n+\t\t\t\t   Definition{expr_node_id, parent});\n }\n \n } // namespace Resolver"}, {"sha": "01fb65ea61065195872837d5e971c34f392f01cd", "filename": "gcc/testsuite/rust/compile/pub_restricted_1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c56e969a647a4c8192ac8cb747f668acf22da7b/gcc%2Ftestsuite%2Frust%2Fcompile%2Fpub_restricted_1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c56e969a647a4c8192ac8cb747f668acf22da7b/gcc%2Ftestsuite%2Frust%2Fcompile%2Fpub_restricted_1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fpub_restricted_1.rs?ref=1c56e969a647a4c8192ac8cb747f668acf22da7b", "patch": "@@ -0,0 +1,14 @@\n+pub mod foo {\n+    pub mod bar {\n+        pub fn baz() {}\n+    }\n+}\n+\n+// this is invalid Rust: We just want to make sure the paths get resolved properly\n+pub(in foo::bar::baz) struct A0;\n+\n+pub(in foo::fah::baz) struct A1; // { dg-error \"cannot find simple path segment .fah.\" }\n+pub(in fro::bulator::saindoux) struct A2; // { dg-error \"cannot find simple path segment .fro.\" }\n+pub(in foo::bar::saindoux) struct A3; // { dg-error \"cannot find simple path segment .saindoux.\" }\n+\n+fn main() {}"}]}