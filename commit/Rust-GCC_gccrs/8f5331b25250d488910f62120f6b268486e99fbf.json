{"sha": "8f5331b25250d488910f62120f6b268486e99fbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY1MzMxYjI1MjUwZDQ4ODkxMGY2MjEyMGY2YjI2ODQ4NmU5OWZiZg==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2019-07-26T13:05:39Z"}, "committer": {"name": "Tamar Christina", "email": "tnfchris@gcc.gnu.org", "date": "2019-07-26T13:05:39Z"}, "message": "Add rules to strip away unneeded type casts in expressions\n\nThis patch moves part of the type conversion code from convert.c to match.pd\nbecause match.pd is able to apply these transformations in the presence of\nintermediate temporary variables.\n\nConcretely it makes both these cases behave the same\n\n  float e = (float)a * (float)b;\n  *c = (_Float16)e;\n\nand \n\n  *c = (_Float16)((float)a * (float)b);\n\ngcc/ChangeLog:\n\n\t* convert.c (convert_to_real_1): Move part of conversion code...\n\t* match.pd: ...To here.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/type-convert-var.c: New test.\n\nFrom-SVN: r273826", "tree": {"sha": "6eef823e90e1830504cf32902e0eb32fca94bda2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6eef823e90e1830504cf32902e0eb32fca94bda2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f5331b25250d488910f62120f6b268486e99fbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f5331b25250d488910f62120f6b268486e99fbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f5331b25250d488910f62120f6b268486e99fbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f5331b25250d488910f62120f6b268486e99fbf/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4517b378af6b412e053e8927972434d8580162d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4517b378af6b412e053e8927972434d8580162d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4517b378af6b412e053e8927972434d8580162d0"}], "stats": {"total": 238, "additions": 121, "deletions": 117}, "files": [{"sha": "301030fef3d853f30e61377d3a0b881c7b711dd8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5331b25250d488910f62120f6b268486e99fbf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5331b25250d488910f62120f6b268486e99fbf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f5331b25250d488910f62120f6b268486e99fbf", "patch": "@@ -1,3 +1,8 @@\n+2019-07-26  Tamar Christina  <tamar.christina@arm.com>\n+\n+\t* convert.c (convert_to_real_1): Move part of conversion code...\n+\t* match.pd: ...To here.\n+\n 2019-07-26  Martin Jambor  <mjambor@suse.cz>\n \n \tPR ipa/89330"}, {"sha": "7f0d933f4d9e29719acb27eb1b32a9e540d93073", "filename": "gcc/convert.c", "status": "modified", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5331b25250d488910f62120f6b268486e99fbf/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5331b25250d488910f62120f6b268486e99fbf/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=8f5331b25250d488910f62120f6b268486e99fbf", "patch": "@@ -298,92 +298,6 @@ convert_to_real_1 (tree type, tree expr, bool fold_p)\n \t      return build1 (TREE_CODE (expr), type, arg);\n \t    }\n \t  break;\n-\t/* Convert (outertype)((innertype0)a+(innertype1)b)\n-\t   into ((newtype)a+(newtype)b) where newtype\n-\t   is the widest mode from all of these.  */\n-\tcase PLUS_EXPR:\n-\tcase MINUS_EXPR:\n-\tcase MULT_EXPR:\n-\tcase RDIV_EXPR:\n-\t   {\n-\t     tree arg0 = strip_float_extensions (TREE_OPERAND (expr, 0));\n-\t     tree arg1 = strip_float_extensions (TREE_OPERAND (expr, 1));\n-\n-\t     if (FLOAT_TYPE_P (TREE_TYPE (arg0))\n-\t\t && FLOAT_TYPE_P (TREE_TYPE (arg1))\n-\t\t && DECIMAL_FLOAT_TYPE_P (itype) == DECIMAL_FLOAT_TYPE_P (type))\n-\t       {\n-\t\t  tree newtype = type;\n-\n-\t\t  if (TYPE_MODE (TREE_TYPE (arg0)) == SDmode\n-\t\t      || TYPE_MODE (TREE_TYPE (arg1)) == SDmode\n-\t\t      || TYPE_MODE (type) == SDmode)\n-\t\t    newtype = dfloat32_type_node;\n-\t\t  if (TYPE_MODE (TREE_TYPE (arg0)) == DDmode\n-\t\t      || TYPE_MODE (TREE_TYPE (arg1)) == DDmode\n-\t\t      || TYPE_MODE (type) == DDmode)\n-\t\t    newtype = dfloat64_type_node;\n-\t\t  if (TYPE_MODE (TREE_TYPE (arg0)) == TDmode\n-\t\t      || TYPE_MODE (TREE_TYPE (arg1)) == TDmode\n-\t\t      || TYPE_MODE (type) == TDmode)\n-                    newtype = dfloat128_type_node;\n-\t\t  if (newtype == dfloat32_type_node\n-\t\t      || newtype == dfloat64_type_node\n-\t\t      || newtype == dfloat128_type_node)\n-\t\t    {\n-\t\t      expr = build2 (TREE_CODE (expr), newtype,\n-\t\t\t\t     convert_to_real_1 (newtype, arg0,\n-\t\t\t\t\t\t\tfold_p),\n-\t\t\t\t     convert_to_real_1 (newtype, arg1,\n-\t\t\t\t\t\t\tfold_p));\n-\t\t      if (newtype == type)\n-\t\t\treturn expr;\n-\t\t      break;\n-\t\t    }\n-\n-\t\t  if (TYPE_PRECISION (TREE_TYPE (arg0)) > TYPE_PRECISION (newtype))\n-\t\t    newtype = TREE_TYPE (arg0);\n-\t\t  if (TYPE_PRECISION (TREE_TYPE (arg1)) > TYPE_PRECISION (newtype))\n-\t\t    newtype = TREE_TYPE (arg1);\n-\t\t  /* Sometimes this transformation is safe (cannot\n-\t\t     change results through affecting double rounding\n-\t\t     cases) and sometimes it is not.  If NEWTYPE is\n-\t\t     wider than TYPE, e.g. (float)((long double)double\n-\t\t     + (long double)double) converted to\n-\t\t     (float)(double + double), the transformation is\n-\t\t     unsafe regardless of the details of the types\n-\t\t     involved; double rounding can arise if the result\n-\t\t     of NEWTYPE arithmetic is a NEWTYPE value half way\n-\t\t     between two representable TYPE values but the\n-\t\t     exact value is sufficiently different (in the\n-\t\t     right direction) for this difference to be\n-\t\t     visible in ITYPE arithmetic.  If NEWTYPE is the\n-\t\t     same as TYPE, however, the transformation may be\n-\t\t     safe depending on the types involved: it is safe\n-\t\t     if the ITYPE has strictly more than twice as many\n-\t\t     mantissa bits as TYPE, can represent infinities\n-\t\t     and NaNs if the TYPE can, and has sufficient\n-\t\t     exponent range for the product or ratio of two\n-\t\t     values representable in the TYPE to be within the\n-\t\t     range of normal values of ITYPE.  */\n-\t\t  if (TYPE_PRECISION (newtype) < TYPE_PRECISION (itype)\n-\t\t      && (flag_unsafe_math_optimizations\n-\t\t\t  || (TYPE_PRECISION (newtype) == TYPE_PRECISION (type)\n-\t\t\t      && real_can_shorten_arithmetic (TYPE_MODE (itype),\n-\t\t\t\t\t\t\t      TYPE_MODE (type))\n-\t\t\t      && !excess_precision_type (newtype))))\n-\t\t    {\n-\t\t      expr = build2 (TREE_CODE (expr), newtype,\n-\t\t\t\t     convert_to_real_1 (newtype, arg0,\n-\t\t\t\t\t\t\tfold_p),\n-\t\t\t\t     convert_to_real_1 (newtype, arg1,\n-\t\t\t\t\t\t\tfold_p));\n-\t\t      if (newtype == type)\n-\t\t\treturn expr;\n-\t\t    }\n-\t       }\n-\t   }\n-\t  break;\n \tdefault:\n \t  break;\n       }"}, {"sha": "0317bc704f771f626ab72189b3a54de00087ad5a", "filename": "gcc/match.pd", "status": "modified", "additions": 103, "deletions": 31, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5331b25250d488910f62120f6b268486e99fbf/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5331b25250d488910f62120f6b268486e99fbf/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=8f5331b25250d488910f62120f6b268486e99fbf", "patch": "@@ -4938,37 +4938,109 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n    the C/C++ front-ends by shorten_binary_op and shorten_compare.  Long\n    term we want to move all that code out of the front-ends into here.  */\n \n-/* If we have a narrowing conversion of an arithmetic operation where\n-   both operands are widening conversions from the same type as the outer\n-   narrowing conversion.  Then convert the innermost operands to a suitable\n-   unsigned type (to avoid introducing undefined behavior), perform the\n-   operation and convert the result to the desired type.  */\n-(for op (plus minus)\n-  (simplify\n-    (convert (op:s (convert@2 @0) (convert?@3 @1)))\n-    (if (INTEGRAL_TYPE_P (type)\n-\t /* We check for type compatibility between @0 and @1 below,\n-\t    so there's no need to check that @1/@3 are integral types.  */\n-\t && INTEGRAL_TYPE_P (TREE_TYPE (@0))\n-\t && INTEGRAL_TYPE_P (TREE_TYPE (@2))\n-\t /* The precision of the type of each operand must match the\n-\t    precision of the mode of each operand, similarly for the\n-\t    result.  */\n-\t && type_has_mode_precision_p (TREE_TYPE (@0))\n-\t && type_has_mode_precision_p (TREE_TYPE (@1))\n-\t && type_has_mode_precision_p (type)\n-\t /* The inner conversion must be a widening conversion.  */\n-\t && TYPE_PRECISION (TREE_TYPE (@2)) > TYPE_PRECISION (TREE_TYPE (@0))\n-\t && types_match (@0, type)\n-\t && (types_match (@0, @1)\n-\t     /* Or the second operand is const integer or converted const\n-\t\tinteger from valueize.  */\n-\t     || TREE_CODE (@1) == INTEGER_CST))\n-      (if (TYPE_OVERFLOW_WRAPS (TREE_TYPE (@0)))\n-\t(op @0 (convert @1))\n-\t(with { tree utype = unsigned_type_for (TREE_TYPE (@0)); }\n-\t (convert (op (convert:utype @0)\n-\t\t      (convert:utype @1))))))))\n+/* Convert (outertype)((innertype0)a+(innertype1)b)\n+   into ((newtype)a+(newtype)b) where newtype\n+   is the widest mode from all of these.  */\n+(for op (plus minus mult rdiv)\n+ (simplify\n+   (convert (op:s@0 (convert1?@3 @1) (convert2?@4 @2)))\n+   /* If we have a narrowing conversion of an arithmetic operation where\n+      both operands are widening conversions from the same type as the outer\n+      narrowing conversion.  Then convert the innermost operands to a\n+      suitable unsigned type (to avoid introducing undefined behavior),\n+      perform the operation and convert the result to the desired type.  */\n+   (if (INTEGRAL_TYPE_P (type)\n+\t&& op != MULT_EXPR\n+\t&& op != RDIV_EXPR\n+\t/* We check for type compatibility between @0 and @1 below,\n+\t   so there's no need to check that @2/@4 are integral types.  */\n+\t&& INTEGRAL_TYPE_P (TREE_TYPE (@1))\n+\t&& INTEGRAL_TYPE_P (TREE_TYPE (@3))\n+\t/* The precision of the type of each operand must match the\n+\t   precision of the mode of each operand, similarly for the\n+\t   result.  */\n+\t&& type_has_mode_precision_p (TREE_TYPE (@1))\n+\t&& type_has_mode_precision_p (TREE_TYPE (@2))\n+\t&& type_has_mode_precision_p (type)\n+\t/* The inner conversion must be a widening conversion.  */\n+\t&& TYPE_PRECISION (TREE_TYPE (@3)) > TYPE_PRECISION (TREE_TYPE (@1))\n+\t&& types_match (@1, type)\n+\t&& (types_match (@1, @2)\n+\t    /* Or the second operand is const integer or converted const\n+\t       integer from valueize.  */\n+\t    || TREE_CODE (@2) == INTEGER_CST))\n+     (if (TYPE_OVERFLOW_WRAPS (TREE_TYPE (@1)))\n+       (op @1 (convert @2))\n+       (with { tree utype = unsigned_type_for (TREE_TYPE (@1)); }\n+\t(convert (op (convert:utype @1)\n+\t\t     (convert:utype @2)))))\n+     (if (FLOAT_TYPE_P (type)\n+\t  && DECIMAL_FLOAT_TYPE_P (TREE_TYPE (@0))\n+\t       == DECIMAL_FLOAT_TYPE_P (type))\n+      (with { tree arg0 = strip_float_extensions (@1);\n+\t      tree arg1 = strip_float_extensions (@2);\n+\t      tree itype = TREE_TYPE (@0);\n+\t      tree ty1 = TREE_TYPE (arg0);\n+\t      tree ty2 = TREE_TYPE (arg1);\n+\t      enum tree_code code = TREE_CODE (itype); }\n+\t(if (FLOAT_TYPE_P (ty1)\n+\t     && FLOAT_TYPE_P (ty2))\n+\t (with { tree newtype = type;\n+\t\t if (TYPE_MODE (ty1) == SDmode\n+\t\t     || TYPE_MODE (ty2) == SDmode\n+\t\t     || TYPE_MODE (type) == SDmode)\n+\t\t   newtype = dfloat32_type_node;\n+\t\t if (TYPE_MODE (ty1) == DDmode\n+\t\t     || TYPE_MODE (ty2) == DDmode\n+\t\t     || TYPE_MODE (type) == DDmode)\n+\t\t   newtype = dfloat64_type_node;\n+\t\t if (TYPE_MODE (ty1) == TDmode\n+\t\t     || TYPE_MODE (ty2) == TDmode\n+\t\t     || TYPE_MODE (type) == TDmode)\n+\t\t   newtype = dfloat128_type_node; }\n+\t  (if ((newtype == dfloat32_type_node\n+\t\t|| newtype == dfloat64_type_node\n+\t\t|| newtype == dfloat128_type_node)\n+\t      && newtype == type\n+\t      && types_match (newtype, type))\n+\t    (op (convert:newtype @1) (convert:newtype @2))\n+\t    (with { if (TYPE_PRECISION (ty1) > TYPE_PRECISION (newtype))\n+\t\t      newtype = ty1;\n+\t\t    if (TYPE_PRECISION (ty2) > TYPE_PRECISION (newtype))\n+\t\t      newtype = ty2; }\n+\t       /* Sometimes this transformation is safe (cannot\n+\t\t  change results through affecting double rounding\n+\t\t  cases) and sometimes it is not.  If NEWTYPE is\n+\t\t  wider than TYPE, e.g. (float)((long double)double\n+\t\t  + (long double)double) converted to\n+\t\t  (float)(double + double), the transformation is\n+\t\t  unsafe regardless of the details of the types\n+\t\t  involved; double rounding can arise if the result\n+\t\t  of NEWTYPE arithmetic is a NEWTYPE value half way\n+\t\t  between two representable TYPE values but the\n+\t\t  exact value is sufficiently different (in the\n+\t\t  right direction) for this difference to be\n+\t\t  visible in ITYPE arithmetic.  If NEWTYPE is the\n+\t\t  same as TYPE, however, the transformation may be\n+\t\t  safe depending on the types involved: it is safe\n+\t\t  if the ITYPE has strictly more than twice as many\n+\t\t  mantissa bits as TYPE, can represent infinities\n+\t\t  and NaNs if the TYPE can, and has sufficient\n+\t\t  exponent range for the product or ratio of two\n+\t\t  values representable in the TYPE to be within the\n+\t\t  range of normal values of ITYPE.  */\n+\t      (if (TYPE_PRECISION (newtype) < TYPE_PRECISION (itype)\n+\t\t   && (flag_unsafe_math_optimizations\n+\t\t       || (TYPE_PRECISION (newtype) == TYPE_PRECISION (type)\n+\t\t\t   && real_can_shorten_arithmetic (TYPE_MODE (itype),\n+\t\t\t\t\t\t\t   TYPE_MODE (type))\n+\t\t\t   && !excess_precision_type (newtype)))\n+\t\t   && !types_match (itype, newtype))\n+\t\t (convert:type (op (convert:newtype @1)\n+\t\t\t\t   (convert:newtype @2)))\n+\t )))) )\n+   ))\n+)))\n \n /* This is another case of narrowing, specifically when there's an outer\n    BIT_AND_EXPR which masks off bits outside the type of the innermost"}, {"sha": "f899b5bb0aa8f039a7f0541a7d5f8bc6cc5137f1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5331b25250d488910f62120f6b268486e99fbf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5331b25250d488910f62120f6b268486e99fbf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8f5331b25250d488910f62120f6b268486e99fbf", "patch": "@@ -1,3 +1,7 @@\n+2018-07-24  Tamar Christina  <tamar.christina@arm.com>\n+\n+\t* gcc.dg/type-convert-var.c: New test.\n+\n 2019-07-26  Martin Jambor  <mjambor@suse.cz>\n \n \tPR ipa/89330"}, {"sha": "88d74e2a49d7123515b87ff64a18bd9b306d57e9", "filename": "gcc/testsuite/gcc.dg/type-convert-var.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f5331b25250d488910f62120f6b268486e99fbf/gcc%2Ftestsuite%2Fgcc.dg%2Ftype-convert-var.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f5331b25250d488910f62120f6b268486e99fbf/gcc%2Ftestsuite%2Fgcc.dg%2Ftype-convert-var.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftype-convert-var.c?ref=8f5331b25250d488910f62120f6b268486e99fbf", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-O1 -fdump-tree-optimized\" } */\n+void foo (float a, float b, float *c)\n+{\n+  double e = (double)a * (double)b;\n+  *c = (float)e;\n+}\n+\n+/* { dg-final { scan-tree-dump-not {double} \"optimized\" } } */"}]}