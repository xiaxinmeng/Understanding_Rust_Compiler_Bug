{"sha": "82b6d25d289195d41e53fc91f63325864e3e28d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJiNmQyNWQyODkxOTVkNDFlNTNmYzkxZjYzMzI1ODY0ZTNlMjhkMA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-10-28T15:05:01Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-11-15T16:57:08Z"}, "message": "Remove duplicate vr_values::extract_range_builtin code.\n\nNow that we know the vr_values and ranger versions are in sync, it is\nsafe to remove the vr_values version and just call the ranger one.\n\nI am leaving the UBSAN bits in place since they make use of\nrelationals which are still not implemented in the ranger.\n\ngcc/ChangeLog:\n\n\t* vr-values.c (vr_values::extract_range_builtin): Rename to...\n\t(vr_values::extract_range_from_ubsan_builtin): ...this.\n\tRemove everything but UBSAN code.\n\t(vr_values::extract_range_basic): Call ranger version for\n\teverything except UBSAN built-ins.\n\t* vr-values.h (class vr_values): Rename extract_range_builtin to\n\textract_range_from_ubsan_builtin.", "tree": {"sha": "b6031e1aa6cde627ffb059b66ba2d957dcf66bfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6031e1aa6cde627ffb059b66ba2d957dcf66bfd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82b6d25d289195d41e53fc91f63325864e3e28d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82b6d25d289195d41e53fc91f63325864e3e28d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82b6d25d289195d41e53fc91f63325864e3e28d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82b6d25d289195d41e53fc91f63325864e3e28d0/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "253c415a1acba50711c82693426391743ac18040", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/253c415a1acba50711c82693426391743ac18040", "html_url": "https://github.com/Rust-GCC/gccrs/commit/253c415a1acba50711c82693426391743ac18040"}], "stats": {"total": 248, "additions": 21, "deletions": 227}, "files": [{"sha": "3db72a360a603885b731ae0c1ea9c624900078ed", "filename": "gcc/vr-values.c", "status": "modified", "additions": 20, "deletions": 226, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b6d25d289195d41e53fc91f63325864e3e28d0/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b6d25d289195d41e53fc91f63325864e3e28d0/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=82b6d25d289195d41e53fc91f63325864e3e28d0", "patch": "@@ -1159,188 +1159,16 @@ check_for_binary_op_overflow (range_query *query,\n    successful.  */\n \n bool\n-vr_values::extract_range_builtin (value_range_equiv *vr, gimple *stmt)\n+vr_values::extract_range_from_ubsan_builtin (value_range_equiv *vr, gimple *stmt)\n {\n   gcc_assert (is_gimple_call (stmt));\n   tree type = gimple_expr_type (stmt);\n-  tree arg;\n-  int mini, maxi, zerov = 0, prec;\n   enum tree_code subcode = ERROR_MARK;\n   combined_fn cfn = gimple_call_combined_fn (stmt);\n   scalar_int_mode mode;\n \n   switch (cfn)\n     {\n-    case CFN_BUILT_IN_CONSTANT_P:\n-      /* Resolve calls to __builtin_constant_p after inlining.  */\n-      if (cfun->after_inlining)\n-\t{\n-\t  vr->set_zero (type);\n-\t  vr->equiv_clear ();\n-\t  return true;\n-\t}\n-      break;\n-      /* Both __builtin_ffs* and __builtin_popcount return\n-\t [0, prec].  */\n-    CASE_CFN_FFS:\n-    CASE_CFN_POPCOUNT:\n-      arg = gimple_call_arg (stmt, 0);\n-      prec = TYPE_PRECISION (TREE_TYPE (arg));\n-      mini = 0;\n-      maxi = prec;\n-      if (TREE_CODE (arg) == SSA_NAME)\n-\t{\n-\t  const value_range_equiv *vr0 = get_value_range (arg);\n-\t  /* If arg is non-zero, then ffs or popcount are non-zero.  */\n-\t  if (range_includes_zero_p (vr0) == 0)\n-\t    mini = 1;\n-\t  /* If some high bits are known to be zero,\n-\t     we can decrease the maximum.  */\n-\t  if (vr0->kind () == VR_RANGE\n-\t      && TREE_CODE (vr0->max ()) == INTEGER_CST\n-\t      && !operand_less_p (vr0->min (),\n-\t\t\t\t  build_zero_cst (TREE_TYPE (vr0->min ()))))\n-\t    maxi = tree_floor_log2 (vr0->max ()) + 1;\n-\t}\n-      goto bitop_builtin;\n-      /* __builtin_parity* returns [0, 1].  */\n-    CASE_CFN_PARITY:\n-      mini = 0;\n-      maxi = 1;\n-      goto bitop_builtin;\n-      /* __builtin_clz* return [0, prec-1], except for\n-\t when the argument is 0, but that is undefined behavior.\n-\t Always handle __builtin_clz* which can be only written\n-\t by user as UB on 0 and so [0, prec-1] range, and the internal-fn\n-\t calls depending on how CLZ_DEFINED_VALUE_AT_ZERO is defined.  */\n-    CASE_CFN_CLZ:\n-      arg = gimple_call_arg (stmt, 0);\n-      prec = TYPE_PRECISION (TREE_TYPE (arg));\n-      mini = 0;\n-      maxi = prec - 1;\n-      mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg));\n-      if (gimple_call_internal_p (stmt))\n-\t{\n-\t  if (optab_handler (clz_optab, mode) != CODE_FOR_nothing\n-\t      && CLZ_DEFINED_VALUE_AT_ZERO (mode, zerov) == 2)\n-\t    {\n-\t      /* Handle only the single common value.  */\n-\t      if (zerov == prec)\n-\t\tmaxi = prec;\n-\t      /* Magic value to give up, unless vr0 proves\n-\t\t arg is non-zero.  */\n-\t      else\n-\t\tmini = -2;\n-\t    }\n-\t}\n-      if (TREE_CODE (arg) == SSA_NAME)\n-\t{\n-\t  const value_range_equiv *vr0 = get_value_range (arg);\n-\t  /* From clz of VR_RANGE minimum we can compute\n-\t     result maximum.  */\n-\t  if (vr0->kind () == VR_RANGE\n-\t      && TREE_CODE (vr0->min ()) == INTEGER_CST\n-\t      && integer_nonzerop (vr0->min ()))\n-\t    {\n-\t      maxi = prec - 1 - tree_floor_log2 (vr0->min ());\n-\t      if (mini == -2)\n-\t\tmini = 0;\n-\t    }\n-\t  else if (vr0->kind () == VR_ANTI_RANGE\n-\t\t   && integer_zerop (vr0->min ()))\n-\t    {\n-\t      maxi = prec - 1;\n-\t      mini = 0;\n-\t    }\n-\t  if (mini == -2)\n-\t    break;\n-\t  /* From clz of VR_RANGE maximum we can compute\n-\t     result minimum.  */\n-\t  if (vr0->kind () == VR_RANGE\n-\t      && TREE_CODE (vr0->max ()) == INTEGER_CST)\n-\t    {\n-\t      int newmini = prec - 1 - tree_floor_log2 (vr0->max ());\n-\t      if (newmini == prec)\n-\t\t{\n-\t\t  if (maxi == prec)\n-\t\t    mini = prec;\n-\t\t}\n-\t      else\n-\t\tmini = newmini;\n-\t    }\n-\t}\n-      if (mini == -2)\n-\tbreak;\n-      goto bitop_builtin;\n-      /* __builtin_ctz* return [0, prec-1], except for\n-\t when the argument is 0, but that is undefined behavior.\n-\t Always handle __builtin_ctz* which can be only written\n-\t by user as UB on 0 and so [0, prec-1] range, and the internal-fn\n-\t calls depending on how CTZ_DEFINED_VALUE_AT_ZERO is defined.  */\n-    CASE_CFN_CTZ:\n-      arg = gimple_call_arg (stmt, 0);\n-      prec = TYPE_PRECISION (TREE_TYPE (arg));\n-      mini = 0;\n-      maxi = prec - 1;\n-      mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg));\n-      if (gimple_call_internal_p (stmt))\n-\t{\n-\t  if (optab_handler (ctz_optab, mode) != CODE_FOR_nothing\n-\t      && CTZ_DEFINED_VALUE_AT_ZERO (mode, zerov) == 2)\n-\t    {\n-\t      /* Handle only the two common values.  */\n-\t      if (zerov == -1)\n-\t\tmini = -1;\n-\t      else if (zerov == prec)\n-\t\tmaxi = prec;\n-\t      else\n-\t\t/* Magic value to give up, unless vr0 proves\n-\t\t   arg is non-zero.  */\n-\t\tmini = -2;\n-\t    }\n-\t}\n-      if (TREE_CODE (arg) == SSA_NAME)\n-\t{\n-\t  const value_range_equiv *vr0 = get_value_range (arg);\n-\t  /* If arg is non-zero, then use [0, prec - 1].  */\n-\t  if ((vr0->kind () == VR_RANGE\n-\t       && integer_nonzerop (vr0->min ()))\n-\t      || (vr0->kind () == VR_ANTI_RANGE\n-\t\t  && integer_zerop (vr0->min ())))\n-\t    {\n-\t      mini = 0;\n-\t      maxi = prec - 1;\n-\t    }\n-\t  /* If some high bits are known to be zero,\n-\t     we can decrease the result maximum.  */\n-\t  if (vr0->kind () == VR_RANGE\n-\t      && TREE_CODE (vr0->max ()) == INTEGER_CST)\n-\t    {\n-\t      int newmaxi = tree_floor_log2 (vr0->max ());\n-\t      if (newmaxi == -1)\n-\t\t{\n-\t\t  if (mini == -1)\n-\t\t    maxi = -1;\n-\t\t  else if (maxi == prec)\n-\t\t    mini = prec;\n-\t\t}\n-\t      else if (maxi != prec)\n-\t\tmaxi = newmaxi;\n-\t    }\n-\t}\n-      if (mini == -2)\n-\tbreak;\n-      goto bitop_builtin;\n-      /* __builtin_clrsb* returns [0, prec-1].  */\n-    CASE_CFN_CLRSB:\n-      arg = gimple_call_arg (stmt, 0);\n-      prec = TYPE_PRECISION (TREE_TYPE (arg));\n-      mini = 0;\n-      maxi = prec - 1;\n-      goto bitop_builtin;\n-    bitop_builtin:\n-      vr->set (build_int_cst (type, mini), build_int_cst (type, maxi));\n-      return true;\n     case CFN_UBSAN_CHECK_ADD:\n       subcode = PLUS_EXPR;\n       break;\n@@ -1350,47 +1178,6 @@ vr_values::extract_range_builtin (value_range_equiv *vr, gimple *stmt)\n     case CFN_UBSAN_CHECK_MUL:\n       subcode = MULT_EXPR;\n       break;\n-    case CFN_GOACC_DIM_SIZE:\n-    case CFN_GOACC_DIM_POS:\n-      /* Optimizing these two internal functions helps the loop\n-\t optimizer eliminate outer comparisons.  Size is [1,N]\n-\t and pos is [0,N-1].  */\n-      {\n-\tbool is_pos = cfn == CFN_GOACC_DIM_POS;\n-\tint axis = oacc_get_ifn_dim_arg (stmt);\n-\tint size = oacc_get_fn_dim_size (current_function_decl, axis);\n-\n-\tif (!size)\n-\t  /* If it's dynamic, the backend might know a hardware\n-\t     limitation.  */\n-\t  size = targetm.goacc.dim_limit (axis);\n-\n-\ttree type = TREE_TYPE (gimple_call_lhs (stmt));\n-\tvr->set(build_int_cst (type, is_pos ? 0 : 1),\n-\t\tsize\n-\t\t? build_int_cst (type, size - is_pos) : vrp_val_max (type));\n-      }\n-      return true;\n-    case CFN_BUILT_IN_STRLEN:\n-      if (tree lhs = gimple_call_lhs (stmt))\n-\tif (ptrdiff_type_node\n-\t    && (TYPE_PRECISION (ptrdiff_type_node)\n-\t\t== TYPE_PRECISION (TREE_TYPE (lhs))))\n-\t  {\n-\t    tree type = TREE_TYPE (lhs);\n-\t    tree max = vrp_val_max (ptrdiff_type_node);\n-\t    wide_int wmax = wi::to_wide (max, TYPE_PRECISION (TREE_TYPE (max)));\n-\t    tree range_min = build_zero_cst (type);\n-\t    /* To account for the terminating NUL, the maximum length\n-\t       is one less than the maximum array size, which in turn\n-\t       is one  less than PTRDIFF_MAX (or SIZE_MAX where it's\n-\t       smaller than the former type).\n-\t       FIXME: Use max_object_size() - 1 here.  */\n-\t    tree range_max = wide_int_to_tree (type, wmax - 2);\n-\t    vr->set (range_min, range_max);\n-\t    return true;\n-\t  }\n-      break;\n     default:\n       break;\n     }\n@@ -1430,20 +1217,27 @@ vr_values::extract_range_basic (value_range_equiv *vr, gimple *stmt)\n   bool sop;\n   tree type = gimple_expr_type (stmt);\n \n-  if (is_gimple_call (stmt) && extract_range_builtin (vr, stmt))\n+  if (is_gimple_call (stmt))\n     {\n       combined_fn cfn = gimple_call_combined_fn (stmt);\n-      if (cfn == CFN_UBSAN_CHECK_ADD\n-\t  || cfn == CFN_UBSAN_CHECK_SUB\n-\t  || cfn == CFN_UBSAN_CHECK_MUL)\n-\treturn;\n-\n-      value_range_equiv tmp;\n-      /* Assert that any ranges vr_values::extract_range_builtin gets\n-\t are also handled by the ranger counterpart.  */\n-      gcc_assert (range_of_builtin_call (*this, tmp, as_a<gcall *> (stmt)));\n-      gcc_assert (tmp.equal_p (*vr, /*ignore_equivs=*/false));\n-      return;\n+      switch (cfn)\n+\t{\n+\tcase CFN_UBSAN_CHECK_ADD:\n+\tcase CFN_UBSAN_CHECK_SUB:\n+\tcase CFN_UBSAN_CHECK_MUL:\n+\t  if (extract_range_from_ubsan_builtin (vr, stmt))\n+\t    return;\n+\t  break;\n+\tdefault:\n+\t  if (range_of_builtin_call (*this, *vr, as_a<gcall *> (stmt)))\n+\t    {\n+\t      /* The original code nuked equivalences every time a\n+\t\t range was found, so do the same here.  */\n+\t      vr->equiv_clear ();\n+\t      return;\n+\t    }\n+\t  break;\n+\t}\n     }\n   /* Handle extraction of the two results (result of arithmetics and\n      a flag whether arithmetics overflowed) from {ADD,SUB,MUL}_OVERFLOW"}, {"sha": "712d029909f8caf22aea735a98991dde4ed9fec8", "filename": "gcc/vr-values.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b6d25d289195d41e53fc91f63325864e3e28d0/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b6d25d289195d41e53fc91f63325864e3e28d0/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=82b6d25d289195d41e53fc91f63325864e3e28d0", "patch": "@@ -148,7 +148,7 @@ class vr_values : public range_query\n   void extract_range_from_comparison (value_range_equiv *, gimple *);\n   void vrp_visit_assignment_or_call (gimple*, tree *, value_range_equiv *);\n   void vrp_visit_switch_stmt (gswitch *, edge *);\n-  bool extract_range_builtin (value_range_equiv *, gimple *);\n+  bool extract_range_from_ubsan_builtin (value_range_equiv *, gimple *);\n \n   /* This probably belongs in the lattice rather than in here.  */\n   bool values_propagated;"}]}