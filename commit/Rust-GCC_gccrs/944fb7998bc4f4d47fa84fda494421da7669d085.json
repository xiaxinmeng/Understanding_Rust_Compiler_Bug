{"sha": "944fb7998bc4f4d47fa84fda494421da7669d085", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ0ZmI3OTk4YmM0ZjRkNDdmYTg0ZmRhNDk0NDIxZGE3NjY5ZDA4NQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2011-05-04T18:25:20Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2011-05-04T18:25:20Z"}, "message": "Fixup whitespacing.\n\nFrom-SVN: r173388", "tree": {"sha": "07d97f3d016f0540978a7cd2ab6948ce8a11c34c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07d97f3d016f0540978a7cd2ab6948ce8a11c34c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/944fb7998bc4f4d47fa84fda494421da7669d085", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/944fb7998bc4f4d47fa84fda494421da7669d085", "html_url": "https://github.com/Rust-GCC/gccrs/commit/944fb7998bc4f4d47fa84fda494421da7669d085", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/944fb7998bc4f4d47fa84fda494421da7669d085/comments", "author": null, "committer": null, "parents": [{"sha": "42375e2ea3a9043cd0e397b380b35bebf1315202", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42375e2ea3a9043cd0e397b380b35bebf1315202", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42375e2ea3a9043cd0e397b380b35bebf1315202"}], "stats": {"total": 1670, "additions": 835, "deletions": 835}, "files": [{"sha": "f31a75419a9b6c7235070d2a8702dfb4bb15d5a6", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=944fb7998bc4f4d47fa84fda494421da7669d085", "patch": "@@ -21,7 +21,7 @@\n \t(objc_detect_field_duplicates): New.\n \t(hash_instance_variable): New.\n \t(eq_instance_variable): New.\n-\t\n+\n 2011-04-14  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_declare_protocols): Renamed to\n@@ -35,7 +35,7 @@\n \tidentifier as argument instead of a tree list.  This means callers\n \tdon't have to build temporary tree lists to call this function.\n \t(synth_module_prologue): Updated calls to objc_declare_class.\n-\t\n+\n 2011-04-13  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (build_keyword_selector): Use get_identifier_with_length\n@@ -59,7 +59,7 @@\n \tinefficient temporary argument lists.  Compare the arguments\n \tdirectly.  (match_proto_with_proto): Removed; incorporated into\n \tcomp_proto_with_proto ().\n-\t\n+\n 2011-04-12  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (printable_ivar_name): New.\n@@ -89,7 +89,7 @@\n 2011-02-26  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_v2_encode_prop_attr): Rewritten.\n-\t\n+\n 2011-02-23  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (build_private_template): Do not copy the\n@@ -250,7 +250,7 @@\n \thook.  Added assert.  Use the get_class_super_ref and\n \tget_category_super_ref runtime hooks.\n \t(objc_v2_encode_prop_attr): New.\n-\t\n+\n 2011-01-17  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tPR objc/47314\n@@ -339,7 +339,7 @@\n \t(objc_build_setter_call, objc_build_message_expr,\n \tobjc_finish_foreach_loop): Updated call to\n \tobjc_finish_message_expr.\n-\t\n+\n 2010-12-28  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tPR objc/47076\n@@ -432,7 +432,7 @@\n \tc-family/c-objc.h.\n \t(objc/objc-lang.o): Same change.\n \t* config-lang.in (gtfiles): Added c-family/c-objc.h.\n-\t\n+\n 2010-12-02  Joseph Myers  <joseph@codesourcery.com>\n \n \t* lang-specs.h: Don't handle -ftraditional.\n@@ -459,7 +459,7 @@\n \tAllow 'make check-objc -j2'\n \t* Make-lang.in (lang_checks_parallelized): New.\n \t(check_objc_parallelize): New.\n-\t\n+\n 2010-11-29  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (start_class): When a class is reimplemented,\n@@ -500,7 +500,7 @@\n \treadonly properties.\n \t(objc_build_class_component_ref): Updated call to\n \tmaybe_make_artificial_property_decl.\n-\t\n+\n 2010-11-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_build_struct): Fixed loops that save and\n@@ -509,7 +509,7 @@\n \tDuplicate TYPE_LANG_SPECIFIC for each type before restoring\n \tTYPE_OBJC_INFO.\n \t(objc_get_protocol_qualified_type): Updated comments.\n-\t\n+\n 2010-11-25  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_build_struct): Install TYPE_OBJC_INTERFACE\n@@ -554,8 +554,8 @@\n \tclass of a category.  Recognize the 'deprecated' attribute when\n \tstarting and interface, and mark the interface with\n \tTREE_DEPRECATED if present.  Store attributes in the interface.\n-\t\n-2010-11-19  Nicola Pero  <nicola.pero@meta-innovation.com>\t\n+\n+2010-11-19  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (lookup_protocol): Added 'warn_if_deprecated'\n \targument.  If it is 'true' and the protocol is deprecated, emit a\n@@ -573,7 +573,7 @@\n \t(check_protocol_recursively): Same change.\n \t(lookup_and_install_protocols): Same change.\n \t* objc-act.h: Updated comments.\n-\t\n+\n 2010-11-17  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (lookup_method_in_protocol_list): Search methods in\n@@ -633,7 +633,7 @@\n \t(objc_add_synthesize_declaration_for_property): Check that the\n \tproperty to synthesize and the instance variable to use have the\n \tsame type.\n-\t\n+\n 2010-11-10  Joseph Myers  <joseph@codesourcery.com>\n \n \t* objc-act.c (objc_init): Use %' in diagnostic.\n@@ -672,7 +672,7 @@\n \tprotocols and superclasses as well.\n \t(objc_synthesize_setter): Search for the setter declaration in\n \tprotocols and superclasses as well.\n-\t\n+\n 2010-11-08  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (lookup_property): When checking categories, also\n@@ -690,7 +690,7 @@\n \tPROPERTY_GETTER_NAME here; this is now done earlier, in\n \tobjc_add_property_declaration.\n \t* objc-act.h (CLASS_NAME, CLASS_SUPER_NAME): Added comments.\n-\t\n+\n 2010-11-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tFixed using the Objective-C 2.0 dot-syntax with self and super.\n@@ -715,7 +715,7 @@\n \t* objc-tree.def (PROPERTY_REF): Increased the number of operands\n \tfrom 2 to 3.  Updated comments.\n \t* objc-act.h (PROPERTY_REF_GETTER_CALL): New.\n-\t\n+\n 2010-11-06  Iain Sandoe  <iains@gcc.gnu.org>\n \n \tPR target/44981\n@@ -725,7 +725,7 @@\n \n 2010-11-04  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n-\tFixed using the Objective-C 2.0 dot-syntax with class names.\t\n+\tFixed using the Objective-C 2.0 dot-syntax with class names.\n \t* objc-act.c (objc_build_class_component_ref): New.\n \n 2010-11-03  Nicola Pero  <nicola.pero@meta-innovation.com>\n@@ -740,7 +740,7 @@\n \tand do not warn if the property is readonly or if the type is a Class.\n \t(objc_finish_foreach_loop): Updated calls to\n \tobjc_type_valid_for_messaging.\n-\t\n+\n 2010-11-03  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tImplemented -fobjc-std=objc1 flag.\n@@ -772,7 +772,7 @@\n \t(PROPERTY_HAS_NO_GETTER): New.\n \t(PROPERTY_HAS_NO_SETTER): New.\n \t* objc-tree.def: Updated comment.\n-\t\n+\n 2010-11-01  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tImplemented format and noreturn attributes for Objective-C methods.\n@@ -788,16 +788,16 @@\n \t\"deprecated\".  In the case of \"format\", adjust the arguments.\n \tAlways process the attributes in the same way no matter if\n \t\"sentinel\" is in the list or not.\n-\t\n+\n 2010-11-01  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_maybe_build_component_ref): Warn about using\n \tdeprecated properties.\n \t(objc_maybe_printable_name): Support PROPERTY_DECL.\n-\t\n+\n 2010-11-01  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n-\tImplemented Objective-C 2.0 property accessors.\t\n+\tImplemented Objective-C 2.0 property accessors.\n \t* objc-act.h (enum objc_tree_index): Added OCTI_GET_PROPERTY_DECL,\n \tOCTI_SET_PROPERTY_DECL, OCTI_COPY_STRUCT_DECL,\n \tOCTI_GET_PROPERTY_STRUCT_DECL and OCTI_SET_PROPERTY_STRUCT_DECL.\n@@ -814,7 +814,7 @@\n \twork with properties that are not nonatomic, assign properties.\n \t(objc_synthesize_setter): Implemented synthesizing setters that\n \twork with properties that are not nonatomic, assign properties.\n-\t\n+\n 2010-10-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tImplemented Objective-C 2.0 @property, @synthesize and @dynamic.\n@@ -905,7 +905,7 @@\n \t(objc_gimplify_property_ref): New.\n \t(objc_gimplify_expr): Use a switch.  In case of a PROPERTY_REF, call\n \tobjc_gimplify_property_ref.\n-\t\n+\n 2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_add_property_declaration): Added arguments to\n@@ -919,18 +919,18 @@\n \t(property_setter): Removed.\n \t(property_getter): Removed.\n \t(property_ivar): Removed.\n-\t(property_copies): Removed.\t\n+\t(property_copies): Removed.\n \t(objc_set_property_attr): Removed.\n \t* objc-act.h (enum property_assign_semantics): New.\n-\t\n+\n 2010-10-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_add_property_variable): Renamed to\n \tobjc_add_property_declaration.  Added location argument.  Updated\n \twarnings and errors to use it.  Use error, not fatal_error, if a\n \tproperty declaration is found outside an interface or\n \timplementation context.\n-\t\n+\n 2010-10-24  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_build_keyword_decl): Updated comments.  Do not\n@@ -945,7 +945,7 @@\n \tof DECLs that we don't recognize.  Immediately return NULL for them.\n \t(objc_printable_name): Removed C++-specific case, which is no\n \tlonger used.  Updated comments.\n-\t\n+\n 2010-10-23  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (OBJC_GEN_METHOD_LABEL): Updated comments.\n@@ -961,7 +961,7 @@\n 2010-10-21  Iain Sandoe  <iains@gcc.gnu.org>\n \n \tBased on the CFString implementation in FSF apple/trunk branch.\n-\t\n+\n \t* objc/objc-act.c (objc_build_string_object): Handle CFStrings.\n \n 2010-10-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n@@ -990,7 +990,7 @@\n \ttwice.  Added missing gcc_unreachable for default case - twice.\n \t(dump_interface): Use a switch instead of a chain of ifs.\n \t(handle_impent): Same change.\n-\t\n+\n 2010-10-20  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.h (objc_inherit_code): Removed.\n@@ -1006,8 +1006,8 @@\n \t(objc_synthesize_getter): Updated call to\n \tobjc_start_method_definition.  Do not set objc_inherit_code.\n \t(objc_synthesize_setter): Updated call to\n-\tobjc_start_method_definition.  Do not set objc_inherit_code.\t\n-\t\n+\tobjc_start_method_definition.  Do not set objc_inherit_code.\n+\n 2010-10-20  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tMerge from 'apple/trunk' branch on FSF servers.  Obvious updates\n@@ -1023,8 +1023,8 @@\n \t(objc_declare_class): Enter class name into hash table.\n \t(objc_is_class_name): Do a hash look up of class name.\n \t(hash_init): Initialize the two new hash tables.\n-\t* objc-act.h: Added cls_name_hash_list and als_name_hash_list \n-\tdeclarations, removed class_chain and alias_chain.\t\n+\t* objc-act.h: Added cls_name_hash_list and als_name_hash_list\n+\tdeclarations, removed class_chain and alias_chain.\n \n 2010-10-20  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n@@ -1036,19 +1036,19 @@\n \tfor syntax-only run or PCH generation as this is done by the\n \tcallers.\n \t* objc-act.h (objc_finish_file): Removed.\n-\t\n+\n 2010-10-18  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tImplemented parsing @synthesize and @dynamic for\n \tObjective-C/Objective-C++.\n \t* objc-act.c (objc_add_synthesize_declaration): New.\n \t(objc_add_dynamic_declaration): New.\n \n-2010-10-18  Nicola Pero  <nicola.pero@meta-innovation.com>\t\n+2010-10-18  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (lookup_and_install_protocols): Return NULL if passed\n \terror_mark_node.\n-\t\n+\n 2010-10-18  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tMerge from 'apple/trunk' branch on FSF servers.\n@@ -1059,31 +1059,31 @@\n \t* objc/objc-act.c (objc_is_class_name): template parameter is not\n         an objective class name.\n         (objc_generate_cxx_cdtors): Check for the null\n-        objc_implementation_context.\t\n+        objc_implementation_context.\n \n 2010-10-18  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n-\tMerge from 'apple/trunk' branch on FSF servers.\t\n-\t\n+\tMerge from 'apple/trunk' branch on FSF servers.\n+\n \t2005-11-08  Fariborz Jahanian <fjahanian@apple.com>\n \n \tRadar 4330422\n \t* objc/objc-act.c (objc_non_volatilized_type): New\n \n \t2005-10-07  Fariborz Jahanian <fjahanian@apple.com>\n-\t\n+\n         Radar 4204796\n \t* objc-act.c (objc_build_volatilized_type): Build 'volatilzed'\n \ttypes with proper attribute set and correctly.\n \t(objc_volatilize_decl): Remove unneeded code.\n \t(objc_type_quals_match): Use the new attribute to check on\n \t'volatilzed' type.\n \t(hash_init): removed unneeded code.\n-\t\n+\n 2010-10-17  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tMerge from 'apple/trunk' branch on FSF servers.\n-\t\n+\n \t2006-03-27 Fariborz Jahanian <fjahanian@apple.com>\n \n \tRadar 4133425\n@@ -1092,20 +1092,20 @@\n 2010-10-17  Iain Sandoe  <iains@gcc.gnu.org>\n \n \t* objc-act.c: Rename 'objc_public_flag' to  objc_ivar_visibility and\n-\tmake its type 'objc_ivar_visibility_kind'.  \n+\tmake its type 'objc_ivar_visibility_kind'.\n \t(objc_start_class_interface): Update to use visibility enum.\n \t(objc_start_class_implementation): Likewise.\n-\t(objc_set_visibility): Update to use visibility enum, warn that \n+\t(objc_set_visibility): Update to use visibility enum, warn that\n \t@package is handle as per @public.\n \t(add_instance_variable): Handle OBJC_IVAR_VIS_PACKAGE.\n \t* objc-act.h: Rename 'objc_public_flag' to  objc_ivar_visibility and\n \tmake its type 'objc_ivar_visibility_kind'.\n \n 2010-10-14  Iain Sandoe  <iains@gcc.gnu.org>\n \n-\tmerge from FSF apple 'trunk' branch. \n+\tmerge from FSF apple 'trunk' branch.\n \t2006 Fariborz Jahanian <fjahanian@apple.com>\n-\t\n+\n \tRadars 4436866, 4505126, 4506903, 4517826\n \t* objc-act.c (CALL_EXPR_OBJC_PROPERTY_GETTER): New.\n \tproperty_readonly, property_getter, property_setter, property_ivar,\n@@ -1153,7 +1153,7 @@\n \n 2010-10-13  Iain Sandoe  <iains@gcc.gnu.org>\n \n-\tmerge from FSF apple 'trunk' branch. \n+\tmerge from FSF apple 'trunk' branch.\n \n \t2006-04-26 Fariborz Jahanian <fjahanian@apple.com>\n \tRadar 3803157 (method attributes)\n@@ -1180,13 +1180,13 @@\n \n 2010-10-07  Iain Sandoe  <iains@gcc.gnu.org>\n \n-\t* objc-act.c (build_objc_method_call): Replace calls to \n+\t* objc-act.c (build_objc_method_call): Replace calls to\n \tbuild_function_call () with the VEC equivalent.  Construct parameter\n \tlists as VECs.\n \n 2010-10-07  Iain Sandoe  <iains@gcc.gnu.org>\n \n-\t* objc-act.c (objc_build_message_expr):  Call mark_exp_read () to \n+\t* objc-act.c (objc_build_message_expr):  Call mark_exp_read () to\n \tsignal that the receiver has been used.\n \n 2010-10-06  Nicola Pero  <nicola.pero@meta-innovation.com>\n@@ -1220,7 +1220,7 @@\n \tfor valid objc object types.\n \t(objc_finish_foreach_loop): Check for invalid objc objects in\n \tforeach header.\n-\t\n+\n 2010-10-05  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tMerge from 'apple/trunk' branch on FSF servers.\n@@ -1230,7 +1230,7 @@\n         Radar 4290840\n \t* objc-act.c (objc_start_method_definition): Check for\n \terror_mark_node for the selector name and make a quick exit.\n-\t\n+\n 2010-10-04  Andi Kleen <ak@linux.intel.com>\n \n \t* Make-lang.in (cc1obj-dummy, cc1obj): Add + to build rule.\n@@ -1251,7 +1251,7 @@\n        * objc/objc-act.h (CLASS_OPTIONAL_CLS_METHODS,\n        CLASS_OPTIONAL_NST_METHODS): New macros accessing a protocol\n        class's optional method chains.\n-\t\n+\n 2010-09-30  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tMerge from 'apple/trunk' branch on FSF servers.\n@@ -1276,8 +1276,8 @@\n \t* objc-act.c (objc_is_reserved_word): Removed.\n \n 2010-09-28  Iain Sandoe  <iains@gcc.gnu.org>\n-\t\n-\t* objc-act.c (objc_add_method_declaration): Handle and ignore \n+\n+\t* objc-act.c (objc_add_method_declaration): Handle and ignore\n \tattributes.\n \t(objc_start_method_definition): Likewise.\n \t(objc_generate_cxx_ctor_or_dtor): Pass NULL attributes to ctor/dtor.\n@@ -1304,7 +1304,7 @@\n \t* objc-act.c (objc_decay_parm_type): New function.\n \t(get_arg_type_list): Decay types for all named arguments.\n \t(objc_push_parm): Rebuild the PARM_DECL if its type has\n-\tbeen decayed.\t\n+\tbeen decayed.\n \n 2010-09-28  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n@@ -1321,7 +1321,7 @@\n \t* objc-act.c (objc_compare_types): A new silent comparison\n \tmode (-4), differing from regular comparison (-3) in that\n \t'false' is returned instead of issuing warnings.\n-\t\n+\n 2010-09-28  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (encode_type): Do not add 'r' with the next runtime.\n@@ -1358,7 +1358,7 @@\n \tEncode C++ reference types as pointers.  Call encode_vector to\n \tencode vectors.\n \t(encode_vector): New function.\n-\t\n+\n 2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tMerge from 'apple/trunk' branch on FSF servers.  I modified the\n@@ -1369,7 +1369,7 @@\n         Radar 4301047\n \n \t* objc-act.c (encode_type): Remove the hack.\n-\t\n+\n \t2005-07-20  Ziemowit Laski  <zlaski@apple.com>\n \n \tRadar 4136935\n@@ -1385,12 +1385,12 @@\n \n \tRadar 4229905\n \t* objc-act.c (objc_have_common_types): New function.\n-\t\n+\n \t2005-06-22  Ziemowit Laski  <zlaski@apple.com>\n \n \tRadar 4154928\n \t* objc-act.c (objc_common_type): New function.\n-\t\n+\n 2010-09-27  Richard Guenther  <rguenther@suse.de>\n \n \t* objc-act.c (objc_get_class_reference): Use CP_TYPE_CONTEXT.\n@@ -1414,7 +1414,7 @@\n \t* objc-act.c (objc_get_interface_ivars): New function.\n \t(objc_collecting_ivars): New variable.\n \t(continue_class): Set and reset objc_collecting_ivars for context.\n-\t\n+\n 2010-09-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tMerge from 'apple/trunk' branch on FSF servers.\n@@ -1445,7 +1445,7 @@\n \t* objc-act.c (objc_get_protocol_qualified_type): When looking\n \tat a typedef, retrieve the precise type it describes (rather\n \tthan merely looking up a class by name).\n-\t\n+\n 2010-09-10  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc/objc-act.c (objc_begin_try_stmt): Generate an error if\n@@ -1461,38 +1461,38 @@\n \tPR objc/44140\n \t* objc-act.c: build_objc_string_decl() remove declaration.\n \t(finish_var_decl): Remove forcing of var output and marking\n-\tas \"Used\". \n-\t(init_def_list): Use integer_zero_node. \n+\tas \"Used\".\n+\t(init_def_list): Use integer_zero_node.\n \t(init_objc_symtab): Use integer_zero_node, make the short\n \tinteger type specific on relevant nodes.\n-\t(generate_objc_symtab_decl): Remove call to \n+\t(generate_objc_symtab_decl): Remove call to\n \tforward_declare_categories().  Use null_pointer_node where\n-\tappropriate.  \n-\t(build_module_descriptor): Comment and mark this item as \n-\tDECL_PRESERVE_P. \n+\tappropriate.\n+\t(build_module_descriptor): Comment and mark this item as\n+\tDECL_PRESERVE_P.\n \t(generate_static_references): Use gcc_unreachable instead of\n-\tabort (). \n+\tabort ().\n \t(diagnose_missing_method): New.\n \t(build_next_selector_translation_table): New.\n \t(build_gnu_selector_translation_table): New.\n \t(add_objc_string): Merge code from build_objc_string_decl...\n \t... and delete build_objc_string_decl().\n \t(generate_dispatch_table): Make integer types explicit.\n \t(generate_category): Pass implent and arrange for the data\n-\tto be extracted within the routine.  Do not start new vars, \n+\tto be extracted within the routine.  Do not start new vars,\n \tbut finish the ones collcted during parsing.\n \t(generate_shared_structures): Likewise.\n \t(finish_objc):  Reorder code so that we finish variables before\n \treferencing them.  Save the global data before calling meta-data\n-\tcreation routines, and pass the current reference to the two \n-\tmain routines.  Only call generate_objc_image_info () for the \n+\tcreation routines, and pass the current reference to the two\n+\tmain routines.  Only call generate_objc_image_info () for the\n \tNeXT runtime.\n \t(generate_classref_translation_entry): Comment on and make this\n \titem DECL_PRESERVE_P.\n \t(handle_class_ref): Use varpool interfaces, comment on and make\n \tthis item DECL_PRESERVE_P.\n \t(handle_impent): Likewise.\n-\t(generate_objc_image_info): Only generate when the content is \n+\t(generate_objc_image_info): Only generate when the content is\n \tnon-zero.  Make integer types explict.\n \n 2010-07-03  Nathan Froyd  <froydnj@codesourcery.com>\n@@ -1685,10 +1685,10 @@\n 2009-07-17  Aldy Hernandez  <aldyh@redhat.com>\n \t    Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n-\tPR 40435 \n+\tPR 40435\n \t* objc-act.c: Add location argument to all calls to\n \tbuild_fold_addr_expr.\n-\t\n+\n 2009-07-14  Taras Glek  <tglek@mozilla.com>\n \t    Rafael Espindola  <espindola@google.com>\n \n@@ -1699,23 +1699,23 @@\n \n \t* objc-act.c (next_sjlj_build_catch_list): Replace EXPR_LOCUS by\n \tEXPR_LOCATION.\n-\t\n+\n 2009-07-07  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* objc-act.c: Replace %J by an explicit location. Update all\n \tcalls.\n-\t\n+\n 2009-07-07  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* objc-act.c: Replace %H by an explicit location. Update all\n \tcalls.\n-\t\n+\n 2009-06-22  Steven Bosscher  <steven@gcc.gnu.org>\n \n \tPR objc/28050\n \t* objc-act.c (objc_build_message_args): Return if ARGS is the\n \terror_mark_node.\n-\t\n+\n 2009-06-19  Ian Lance Taylor  <iant@google.com>\n \n \t* objc-act.c (objc_in_struct, objc_struct_types): Remove.\n@@ -1730,7 +1730,7 @@\n \tlabel_context_stack_se or label_context_stack_vm.\n \n 2009-06-12  Aldy Hernandez  <aldyh@redhat.com>\n-\t\n+\n \t* objc-act.c (finish_var_decl): Pass location to finish_decl.\n \t(objc_get_parm_info): Same.\n \t(get_super_receiver): Same.\n@@ -1756,7 +1756,7 @@\n \tbuild_modify_expr, build_compound_expr.\n \t* objc-act.c: Add location to all calls to start_struct, build_decl,\n \tfinish_struct.\n-\t\n+\n 2009-06-09  Ian Lance Taylor  <iant@google.com>\n \n \t* objc-act.c (objc_gimplify_expr): Change return type to int.\n@@ -2087,11 +2087,11 @@\n \t(add_class): Likewise.\n \n 2007-01-02  Douglas Gregor  <doug.gregor@gmail.com>\n-\t\n+\n \t* objc-act.c (objc_build_volatilized_type): Keep track of\n \tcanonical types.\n \t(objc_get_protocol_qualified_type): Ditto.\n-\t\n+\n 2006-11-02  Andreas Tobler  <a.tobler@schweiz.org>\n \n \t* objc-act.c (objc_finish_file): Remove ifdef clause for OBJCPLUS and"}, {"sha": "357028f26ea4e48c9c216b05ebe69a26a84f4e2d", "filename": "gcc/objc/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FMake-lang.in?ref=944fb7998bc4f4d47fa84fda494421da7669d085", "patch": "@@ -93,7 +93,7 @@ objc/objc-next-runtime-abi-01.o: objc/objc-next-runtime-abi-01.c $(START_HDRS) \\\n objc/objc-next-runtime-abi-02.o: objc/objc-next-runtime-abi-02.c $(START_HDRS) \\\n    $(GGC_H) objc/objc-runtime-hooks.h \\\n    objc/objc-next-metadata-tags.h gt-objc-objc-next-runtime-abi-02.h $(TARGET_H) \\\n-   objc/objc-runtime-shared-support.h $(OBSTACK_H) \n+   objc/objc-runtime-shared-support.h $(OBSTACK_H)\n \n objc/objc-act.o : objc/objc-act.c $(START_HDRS) $(GGC_H) \\\n    $(DIAGNOSTIC_CORE_H) toplev.h $(FLAGS_H) input.h $(FUNCTION_H) output.h debug.h \\"}, {"sha": "025f37544f9ec637208611fa4899d4f46072e591", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 327, "deletions": 327, "changes": 654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=944fb7998bc4f4d47fa84fda494421da7669d085", "patch": "@@ -163,7 +163,7 @@ static void objc_generate_cxx_cdtors (void);\n #endif\n \n /* objc attribute */\n-static void objc_decl_method_attributes (tree*, tree, int); \n+static void objc_decl_method_attributes (tree*, tree, int);\n static tree build_keyword_selector (tree);\n \n /* Hash tables to manage the global pool of method prototypes.  */\n@@ -232,7 +232,7 @@ static tree check_duplicates (hash, int, int);\n #define OBJC_LOOKUP_NO_SUPER\t2\n /* Disable returning an instance method of a root class when a class\n    method can't be found.  */\n-#define OBJC_LOOKUP_NO_INSTANCE_METHODS_OF_ROOT_CLASS 4 \n+#define OBJC_LOOKUP_NO_INSTANCE_METHODS_OF_ROOT_CLASS 4\n \n /* The OCTI_... enumeration itself is in objc/objc-act.h.  */\n tree objc_global_trees[OCTI_MAX];\n@@ -458,7 +458,7 @@ objc_write_global_declarations (void)\n \n   /* TODO: consider an early exit here if either errorcount or sorrycount\n      is non-zero.  Not only is it wasting time to generate the metadata,\n-     it needlessly imposes need to re-check for things that are already \n+     it needlessly imposes need to re-check for things that are already\n      determined to be errors.  */\n \n   /* Finalize Objective-C runtime data.  No need to generate tables\n@@ -590,7 +590,7 @@ objc_start_class_interface (tree klass, tree super_class,\n \t\t\t    tree protos, tree attributes)\n {\n   if (flag_objc1_only && attributes)\n-    error_at (input_location, \"class attributes are not available in Objective-C 1.0\");\t\n+    error_at (input_location, \"class attributes are not available in Objective-C 1.0\");\n \n   objc_interface_context\n     = objc_ivar_context\n@@ -607,7 +607,7 @@ objc_start_category_interface (tree klass, tree categ,\n       if (flag_objc1_only)\n \terror_at (input_location, \"category attributes are not available in Objective-C 1.0\");\n       else\n-\twarning_at (input_location, OPT_Wattributes, \n+\twarning_at (input_location, OPT_Wattributes,\n \t\t    \"category attributes are not available in this version\"\n \t\t    \" of the compiler, (ignored)\");\n     }\n@@ -627,7 +627,7 @@ objc_start_category_interface (tree klass, tree categ,\n \t\t as the one we are extending, produce an error.  */\n \t    if (TREE_CODE (t->imp_context) == CLASS_IMPLEMENTATION_TYPE\n \t\t&& IDENTIFIER_POINTER (CLASS_NAME (t->imp_context)) == IDENTIFIER_POINTER (klass))\n-\t      error_at (input_location, \n+\t      error_at (input_location,\n \t\t\t\"class extension for class %qE declared after its %<@implementation%>\",\n \t\t\tklass);\n \t    }\n@@ -643,7 +643,7 @@ void\n objc_start_protocol (tree name, tree protos, tree attributes)\n {\n   if (flag_objc1_only && attributes)\n-    error_at (input_location, \"protocol attributes are not available in Objective-C 1.0\");\t\n+    error_at (input_location, \"protocol attributes are not available in Objective-C 1.0\");\n \n   objc_interface_context\n     = start_protocol (PROTOCOL_INTERFACE_TYPE, name, protos, attributes);\n@@ -730,13 +730,13 @@ objc_set_method_opt (bool optional)\n   if (flag_objc1_only)\n     {\n       if (optional)\n-\terror_at (input_location, \"%<@optional%> is not available in Objective-C 1.0\");\t\n+\terror_at (input_location, \"%<@optional%> is not available in Objective-C 1.0\");\n       else\n-\terror_at (input_location, \"%<@required%> is not available in Objective-C 1.0\");\t\n+\terror_at (input_location, \"%<@required%> is not available in Objective-C 1.0\");\n     }\n \n   objc_method_optional_flag = optional;\n-  if (!objc_interface_context \n+  if (!objc_interface_context\n       || TREE_CODE (objc_interface_context) != PROTOCOL_INTERFACE_TYPE)\n     {\n       if (optional)\n@@ -808,11 +808,11 @@ lookup_property (tree interface_type, tree property)\n \t}\n \n       /*  Failing to find in categories, look for property in protocol list. */\n-      if (CLASS_PROTOCOL_LIST (inter) \n+      if (CLASS_PROTOCOL_LIST (inter)\n \t  && (x = lookup_property_in_protocol_list\n \t      (CLASS_PROTOCOL_LIST (inter), property)))\n \treturn x;\n-      \n+\n       /* Failing that, climb up the inheritance hierarchy.  */\n       inter = lookup_interface (CLASS_SUPER_NAME (inter));\n     }\n@@ -863,7 +863,7 @@ objc_add_property_declaration (location_t location, tree decl,\n     {\n       if (parsed_property_readonly)\n \tproperty_readonly = true;\n-  \n+\n       if (parsed_property_readwrite)\n \tproperty_readonly = false;\n     }\n@@ -915,7 +915,7 @@ objc_add_property_declaration (location_t location, tree decl,\n   if (TREE_CODE (decl) != FIELD_DECL)\n     {\n       error_at (location, \"invalid property declaration\");\n-      return;      \n+      return;\n     }\n \n   /* Do some spot-checks for the most obvious invalid types.  */\n@@ -941,7 +941,7 @@ objc_add_property_declaration (location_t location, tree decl,\n \t underlying instance variable could be a bitfield, but that is\n \t a different matter.  */\n       error_at (location, \"property can not be a bit-field\");\n-      return;      \n+      return;\n     }\n #endif\n \n@@ -970,20 +970,20 @@ objc_add_property_declaration (location_t location, tree decl,\n \t  /* Use 'false' so we do not warn for Class objects.  */\n \t  if (objc_type_valid_for_messaging (TREE_TYPE (decl), false))\n \t    {\n-\t      warning_at (location, \n+\t      warning_at (location,\n \t\t\t  0,\n-\t\t\t  \"object property %qD has no %<assign%>, %<retain%> or %<copy%> attribute; assuming %<assign%>\", \n+\t\t\t  \"object property %qD has no %<assign%>, %<retain%> or %<copy%> attribute; assuming %<assign%>\",\n \t\t\t  decl);\n-\t      inform (location, \n+\t      inform (location,\n \t\t      \"%<assign%> can be unsafe for Objective-C objects; please state explicitly if you need it\");\n \t    }\n \t}\n     }\n-  \n+\n   if (property_assign_semantics == OBJC_PROPERTY_RETAIN\n       && !objc_type_valid_for_messaging (TREE_TYPE (decl), true))\n     error_at (location, \"%<retain%> attribute is only valid for Objective-C objects\");\n-  \n+\n   if (property_assign_semantics == OBJC_PROPERTY_COPY\n       && !objc_type_valid_for_messaging (TREE_TYPE (decl), true))\n     error_at (location, \"%<copy%> attribute is only valid for Objective-C objects\");\n@@ -1011,7 +1011,7 @@ objc_add_property_declaration (location_t location, tree decl,\n   else\n     {\n       if (!property_readonly)\n-\tparsed_property_setter_ident = get_identifier (objc_build_property_setter_name \n+\tparsed_property_setter_ident = get_identifier (objc_build_property_setter_name\n \t\t\t\t\t\t       (DECL_NAME (decl)));\n     }\n \n@@ -1039,9 +1039,9 @@ objc_add_property_declaration (location_t location, tree decl,\n \t  else\n \t    {\n \t      location_t original_location = DECL_SOURCE_LOCATION (x);\n-\t      \n+\n \t      error_at (location, \"redeclaration of property %qD\", decl);\n-\t      \n+\n \t      if (original_location != UNKNOWN_LOCATION)\n \t\tinform (original_location, \"originally specified here\");\n \t      return;\n@@ -1106,7 +1106,7 @@ objc_add_property_declaration (location_t location, tree decl,\n \t{\n \t  warning_at (location, 0,\n \t\t      \"'nonatomic' attribute of property %qD conflicts with previous declaration\", decl);\n-      \n+\n \t  if (original_location != UNKNOWN_LOCATION)\n \t    inform (original_location, \"originally specified here\");\n \t  return;\n@@ -1116,7 +1116,7 @@ objc_add_property_declaration (location_t location, tree decl,\n \t{\n \t  warning_at (location, 0,\n \t\t      \"'getter' attribute of property %qD conflicts with previous declaration\", decl);\n-      \n+\n \t  if (original_location != UNKNOWN_LOCATION)\n \t    inform (original_location, \"originally specified here\");\n \t  return;\n@@ -1129,7 +1129,7 @@ objc_add_property_declaration (location_t location, tree decl,\n \t    {\n \t      warning_at (location, 0,\n \t\t\t  \"'setter' attribute of property %qD conflicts with previous declaration\", decl);\n-\t      \n+\n \t      if (original_location != UNKNOWN_LOCATION)\n \t\tinform (original_location, \"originally specified here\");\n \t      return;\n@@ -1140,7 +1140,7 @@ objc_add_property_declaration (location_t location, tree decl,\n \t{\n \t  warning_at (location, 0,\n \t\t      \"assign semantics attributes of property %qD conflict with previous declaration\", decl);\n-      \n+\n \t  if (original_location != UNKNOWN_LOCATION)\n \t    inform (original_location, \"originally specified here\");\n \t  return;\n@@ -1151,7 +1151,7 @@ objc_add_property_declaration (location_t location, tree decl,\n \t{\n \t  warning_at (location, 0,\n \t\t      \"'readonly' attribute of property %qD conflicts with previous declaration\", decl);\n-      \n+\n \t  if (original_location != UNKNOWN_LOCATION)\n \t    inform (original_location, \"originally specified here\");\n \t  return;\n@@ -1183,7 +1183,7 @@ objc_add_property_declaration (location_t location, tree decl,\n       if (!comptypes (TREE_TYPE (x), TREE_TYPE (decl))\n \t  /* ... unless the property is readonly, in which case we\n \t     allow a new, more specialized, declaration.  */\n-\t  && (!property_readonly \n+\t  && (!property_readonly\n \t      || !objc_compare_types (TREE_TYPE (x),\n \t\t\t\t      TREE_TYPE (decl), -5, NULL_TREE)))\n \t{\n@@ -1213,7 +1213,7 @@ objc_add_property_declaration (location_t location, tree decl,\n   TREE_TYPE (property_decl) = TREE_TYPE (decl);\n   DECL_SOURCE_LOCATION (property_decl) = DECL_SOURCE_LOCATION (decl);\n   TREE_DEPRECATED (property_decl) = TREE_DEPRECATED (decl);\n-  \n+\n   /* Add property-specific information.  */\n   PROPERTY_NAME (property_decl) = DECL_NAME (decl);\n   PROPERTY_GETTER_NAME (property_decl) = parsed_property_getter_ident;\n@@ -1253,7 +1253,7 @@ objc_add_property_declaration (location_t location, tree decl,\n    any is found, then create an artificial property that uses them.\n    Return NULL_TREE if 'getter' or 'setter' could not be found.  */\n static tree\n-maybe_make_artificial_property_decl (tree interface, tree implementation, \n+maybe_make_artificial_property_decl (tree interface, tree implementation,\n \t\t\t\t     tree protocol_list, tree component, bool is_class,\n \t\t\t\t     tree getter_name)\n {\n@@ -1275,7 +1275,7 @@ maybe_make_artificial_property_decl (tree interface, tree implementation,\n \t Turn it off.  */\n       if (is_class)\n \tflags = OBJC_LOOKUP_CLASS | OBJC_LOOKUP_NO_INSTANCE_METHODS_OF_ROOT_CLASS;\n-      \n+\n       getter = lookup_method_static (interface, getter_name, flags);\n       setter = lookup_method_static (interface, setter_name, flags);\n     }\n@@ -1293,7 +1293,7 @@ maybe_make_artificial_property_decl (tree interface, tree implementation,\n \t  else\n \t    {\n \t      getter = lookup_method (CLASS_NST_METHODS (implementation), getter_name);\n-\t      setter = lookup_method (CLASS_NST_METHODS (implementation), setter_name);\t      \n+\t      setter = lookup_method (CLASS_NST_METHODS (implementation), setter_name);\n \t    }\n \t}\n     }\n@@ -1313,17 +1313,17 @@ maybe_make_artificial_property_decl (tree interface, tree implementation,\n       /* Yes ... determine the type of the expression.  */\n       tree property_decl;\n       tree type;\n-      \n+\n       if (getter)\n \ttype = TREE_VALUE (TREE_TYPE (getter));\n       else\n \ttype = TREE_VALUE (TREE_TYPE (METHOD_SEL_ARGS (setter)));\n-      \n+\n       /* Create an artificial property declaration with the\n \t information we collected on the type and getter/setter\n \t names.  */\n       property_decl = make_node (PROPERTY_DECL);\n-      \n+\n       TREE_TYPE (property_decl) = type;\n       DECL_SOURCE_LOCATION (property_decl) = input_location;\n       TREE_DEPRECATED (property_decl) = 0;\n@@ -1383,10 +1383,10 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \n   /* Try to determine if 'object' is an Objective-C object or not.  If\n      not, return.  */\n-  if (object == NULL_TREE || object == error_mark_node \n+  if (object == NULL_TREE || object == error_mark_node\n       || (rtype = TREE_TYPE (object)) == NULL_TREE)\n     return NULL_TREE;\n-  \n+\n   if (property_ident == NULL_TREE || property_ident == error_mark_node\n       || TREE_CODE (property_ident) != IDENTIFIER_NODE)\n     return NULL_TREE;\n@@ -1416,7 +1416,7 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n       if (TYPE_HAS_OBJC_INFO (TREE_TYPE (rtype)))\n \t{\n \t  tree rprotos = TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (rtype));\n-\t  \n+\n \t  if (rprotos)\n \t    {\n \t      /* No point looking up declared @properties if we are\n@@ -1434,7 +1434,7 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t\t     an artifical property based on them if found.  */\n \t\t  x = maybe_make_artificial_property_decl (NULL_TREE,\n \t\t\t\t\t\t\t   NULL_TREE,\n-\t\t\t\t\t\t\t   rprotos, \n+\t\t\t\t\t\t\t   rprotos,\n \t\t\t\t\t\t\t   property_ident,\n \t\t\t\t\t\t\t   IS_CLASS (rtype),\n \t\t\t\t\t\t\t   NULL_TREE);\n@@ -1454,7 +1454,7 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t\t\t\t\t\t\t   rprotos,\n \t\t\t\t\t\t\t   property_ident,\n \t\t\t\t\t\t\t   false,\n-\t\t\t\t\t\t\t   PROPERTY_GETTER_NAME (x));\t\t  \n+\t\t\t\t\t\t\t   PROPERTY_GETTER_NAME (x));\n \t\t}\n \t    }\n \t}\n@@ -1469,8 +1469,8 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t\t || CONVERT_EXPR_P (t)\n \t\t || TREE_CODE (t) == COMPONENT_REF)\n \t    t = TREE_OPERAND (t, 0);\n-\t  \n-\t  if (t == UOBJC_SUPER_decl)\t\n+\n+\t  if (t == UOBJC_SUPER_decl)\n \t    interface_type = lookup_interface (CLASS_SUPER_NAME (implementation_template));\n \t  else if (t == self_decl)\n \t    interface_type = lookup_interface (CLASS_NAME (implementation_template));\n@@ -1479,7 +1479,7 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t    {\n \t      if (TREE_CODE (objc_method_context) != CLASS_METHOD_DECL)\n \t\tx = lookup_property (interface_type, property_ident);\n-\t\n+\n \t      if (x == NULL_TREE)\n \t\t{\n \t\t  /* Try the dot-syntax without a declared property.\n@@ -1492,8 +1492,8 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \n \t\t  if (t == self_decl)\n \t\t    implementation = objc_implementation_context;\n-\t\t  \n-\t\t  x = maybe_make_artificial_property_decl \n+\n+\t\t  x = maybe_make_artificial_property_decl\n \t\t    (interface_type, implementation, NULL_TREE,\n \t\t     property_ident,\n \t\t     (TREE_CODE (objc_method_context) == CLASS_METHOD_DECL),\n@@ -1502,16 +1502,16 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t      else if (PROPERTY_OPTIONAL (x) && PROPERTY_READONLY (x))\n \t\t{\n \t\t  tree implementation = NULL_TREE;\n-\t\t  \n+\n \t\t  if (t == self_decl)\n \t\t    implementation = objc_implementation_context;\n-\t\t  \n+\n \t\t  x = maybe_make_artificial_property_decl (interface_type,\n \t\t\t\t\t\t\t   implementation,\n \t\t\t\t\t\t\t   NULL_TREE,\n \t\t\t\t\t\t\t   property_ident,\n \t\t\t\t\t\t\t   false,\n-\t\t\t\t\t\t\t   PROPERTY_GETTER_NAME (x));\t\t  \n+\t\t\t\t\t\t\t   PROPERTY_GETTER_NAME (x));\n \t\t}\n \t    }\n \t}\n@@ -1530,7 +1530,7 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \n       /* Traverse typedefs.  */\n       while (basetype != NULL_TREE\n-\t     && TREE_CODE (basetype) == RECORD_TYPE \n+\t     && TREE_CODE (basetype) == RECORD_TYPE\n \t     && OBJC_TYPE_NAME (basetype)\n \t     && TREE_CODE (OBJC_TYPE_NAME (basetype)) == TYPE_DECL\n \t     && DECL_ORIGINAL_TYPE (OBJC_TYPE_NAME (basetype)))\n@@ -1541,7 +1541,7 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t  tree interface_type = TYPE_OBJC_INTERFACE (basetype);\n \t  tree protocol_list = TYPE_OBJC_PROTOCOL_LIST (basetype);\n \n-\t  if (interface_type \n+\t  if (interface_type\n \t      && (TREE_CODE (interface_type) == CLASS_INTERFACE_TYPE\n \t\t  || TREE_CODE (interface_type) == CATEGORY_INTERFACE_TYPE\n \t\t  || TREE_CODE (interface_type) == PROTOCOL_INTERFACE_TYPE))\n@@ -1551,12 +1551,12 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t      if (!IS_CLASS (rtype))\n \t\t{\n \t\t  x = lookup_property (interface_type, property_ident);\n-\t\t  \n+\n \t\t  if (x == NULL_TREE)\n-\t\t    x = lookup_property_in_protocol_list (protocol_list, \n+\t\t    x = lookup_property_in_protocol_list (protocol_list,\n \t\t\t\t\t\t\t  property_ident);\n \t\t}\n-\t      \n+\n \t      if (x == NULL_TREE)\n \t\t{\n \t\t  /* Try the dot-syntax without a declared property.\n@@ -1568,13 +1568,13 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t\t  tree implementation = NULL_TREE;\n \n \t\t  if (objc_implementation_context\n-\t\t      && CLASS_NAME (objc_implementation_context) \n+\t\t      && CLASS_NAME (objc_implementation_context)\n \t\t      == OBJC_TYPE_NAME (interface_type))\n \t\t    implementation = objc_implementation_context;\n-\t\t  \n+\n \t\t  x = maybe_make_artificial_property_decl (interface_type,\n \t\t\t\t\t\t\t   implementation,\n-\t\t\t\t\t\t\t   protocol_list, \n+\t\t\t\t\t\t\t   protocol_list,\n \t\t\t\t\t\t\t   property_ident,\n \t\t\t\t\t\t\t   IS_CLASS (rtype),\n \t\t\t\t\t\t\t   NULL_TREE);\n@@ -1584,17 +1584,17 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t\t  tree implementation = NULL_TREE;\n \n \t\t  if (objc_implementation_context\n-\t\t      && CLASS_NAME (objc_implementation_context) \n+\t\t      && CLASS_NAME (objc_implementation_context)\n \t\t      == OBJC_TYPE_NAME (interface_type))\n \t\t    implementation = objc_implementation_context;\n-\t\t  \n+\n \t\t  x = maybe_make_artificial_property_decl (interface_type,\n \t\t\t\t\t\t\t   implementation,\n \t\t\t\t\t\t\t   protocol_list,\n \t\t\t\t\t\t\t   property_ident,\n \t\t\t\t\t\t\t   false,\n-\t\t\t\t\t\t\t   PROPERTY_GETTER_NAME (x));\t\t  \n-\t\t}\t      \n+\t\t\t\t\t\t\t   PROPERTY_GETTER_NAME (x));\n+\t\t}\n \t    }\n \t}\n     }\n@@ -1643,7 +1643,7 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n \t\t\t   deprecated_method_prototype);\n       SET_EXPR_LOCATION (expression, input_location);\n       TREE_SIDE_EFFECTS (expression) = 1;\n-      \n+\n       return expression;\n     }\n \n@@ -1659,45 +1659,45 @@ objc_build_class_component_ref (tree class_name, tree property_ident)\n {\n   tree x = NULL_TREE;\n   tree object, rtype;\n-  \n+\n   if (flag_objc1_only)\n     error_at (input_location, \"the dot syntax is not available in Objective-C 1.0\");\n-  \n+\n   if (class_name == NULL_TREE || class_name == error_mark_node\n       || TREE_CODE (class_name) != IDENTIFIER_NODE)\n     return error_mark_node;\n-  \n+\n   if (property_ident == NULL_TREE || property_ident == error_mark_node\n       || TREE_CODE (property_ident) != IDENTIFIER_NODE)\n     return NULL_TREE;\n-  \n+\n   object = objc_get_class_reference (class_name);\n   if (!object)\n     {\n       /* We know that 'class_name' is an Objective-C class name as the\n \t parser won't call this function if it is not.  This is only a\n \t double-check for safety.  */\n-      error_at (input_location, \"could not find class %qE\", class_name); \n+      error_at (input_location, \"could not find class %qE\", class_name);\n       return error_mark_node;\n     }\n \n   rtype = lookup_interface (class_name);\n   if (!rtype)\n     {\n       /* Again, this should never happen, but we do check.  */\n-      error_at (input_location, \"could not find interface for class %qE\", class_name); \n+      error_at (input_location, \"could not find interface for class %qE\", class_name);\n       return error_mark_node;\n     }\n   else\n     {\n       if (TREE_DEPRECATED (rtype))\n-\twarning (OPT_Wdeprecated_declarations, \"class %qE is deprecated\", class_name);    \n+\twarning (OPT_Wdeprecated_declarations, \"class %qE is deprecated\", class_name);\n     }\n \n   x = maybe_make_artificial_property_decl (rtype, NULL_TREE, NULL_TREE,\n \t\t\t\t\t   property_ident,\n \t\t\t\t\t   true, NULL_TREE);\n-  \n+\n   if (x)\n     {\n       tree expression;\n@@ -1720,8 +1720,8 @@ objc_build_class_component_ref (tree class_name, tree property_ident)\n     }\n   else\n     {\n-      error_at (input_location, \"could not find setter/getter for %qE in class %qE\", \n-\t\tproperty_ident,\tclass_name); \n+      error_at (input_location, \"could not find setter/getter for %qE in class %qE\",\n+\t\tproperty_ident,\tclass_name);\n       return error_mark_node;\n     }\n \n@@ -1753,21 +1753,21 @@ objc_build_setter_call (tree lhs, tree rhs)\n {\n   tree object_expr = PROPERTY_REF_OBJECT (lhs);\n   tree property_decl = PROPERTY_REF_PROPERTY_DECL (lhs);\n-  \n+\n   if (PROPERTY_READONLY (property_decl))\n     {\n-      error (\"readonly property can not be set\");\t  \n+      error (\"readonly property can not be set\");\n       return error_mark_node;\n     }\n   else\n     {\n       tree setter_argument = build_tree_list (NULL_TREE, rhs);\n       tree setter;\n-      \n+\n       /* TODO: Check that the setter return type is 'void'.  */\n \n       /* TODO: Decay arguments in C.  */\n-      setter = objc_finish_message_expr (object_expr, \n+      setter = objc_finish_message_expr (object_expr,\n \t\t\t\t\t PROPERTY_SETTER_NAME (property_decl),\n \t\t\t\t\t setter_argument, NULL);\n       return setter;\n@@ -1829,7 +1829,7 @@ objc_maybe_build_modify_expr (tree lhs, tree rhs)\n       if (TREE_SIDE_EFFECTS (rhs))\n \t{\n \t  tree bind;\n-      \n+\n \t  /* Declare __objc_property_temp in a local bind.  */\n \t  setter_argument = objc_create_temporary_var (TREE_TYPE (rhs), \"__objc_property_temp\");\n \t  DECL_SOURCE_LOCATION (setter_argument) = input_location;\n@@ -1850,19 +1850,19 @@ objc_maybe_build_modify_expr (tree lhs, tree rhs)\n \t  setter_argument = rhs;\n \t  s1 = NULL_TREE;\n \t}\n-      \n+\n       /* Now build the compound statement.  */\n-  \n+\n       /* s2: [object setProperty: x] */\n       s2 = objc_build_setter_call (lhs, setter_argument);\n-      \n+\n       /* This happens if building the setter failed because the\n \t property is readonly.  */\n       if (s2 == error_mark_node)\n \treturn error_mark_node;\n \n       SET_EXPR_LOCATION (s2, input_location);\n-  \n+\n       /* s3: x */\n       s3 = convert (TREE_TYPE (lhs), setter_argument);\n \n@@ -1871,7 +1871,7 @@ objc_maybe_build_modify_expr (tree lhs, tree rhs)\n       if (s1)\n \tcompound_expr = build_compound_expr (input_location, build_compound_expr (input_location, s1, s2), s3);\n       else\n-\tcompound_expr = build_compound_expr (input_location, s2, s3);\t\n+\tcompound_expr = build_compound_expr (input_location, s2, s3);\n \n       /* Without this, with -Wall you get a 'valued computed is not\n \t used' every time there is a \"object.property = x\" where the\n@@ -1897,25 +1897,25 @@ objc_maybe_build_modify_expr (tree lhs, tree rhs)\n    'setter' for the property in an appropriate way to build the\n    appropriate expression.  'code' is the code for the expression (one\n    of the four mentioned above); 'argument' is the PROPERTY_REF, and\n-   'increment' is how much we need to add or subtract.  */   \n+   'increment' is how much we need to add or subtract.  */\n tree\n objc_build_incr_expr_for_property_ref (location_t location,\n-\t\t\t\t       enum tree_code code, \n+\t\t\t\t       enum tree_code code,\n \t\t\t\t       tree argument, tree increment)\n {\n   /* Here are the expressions that we want to build:\n \n      For PREINCREMENT_EXPR / PREDECREMENT_EXPR:\n     (temp = [object property] +/- increment, [object setProperty: temp], temp)\n-    \n+\n     For POSTINCREMENT_EXPR / POSTECREMENT_EXPR:\n     (temp = [object property], [object setProperty: temp +/- increment], temp) */\n-  \n+\n   tree temp_variable_decl, bind;\n   /* s1, s2 and s3 are the tree statements that we need in the\n      compound expression.  */\n   tree s1, s2, s3, compound_expr;\n-  \n+\n   /* Safety check.  */\n   if (!argument || TREE_CODE (argument) != PROPERTY_REF)\n     return error_mark_node;\n@@ -1927,28 +1927,28 @@ objc_build_incr_expr_for_property_ref (location_t location,\n   SET_EXPR_LOCATION (bind, location);\n   TREE_SIDE_EFFECTS (bind) = 1;\n   add_stmt (bind);\n-  \n+\n   /* Now build the compound statement.  */\n-  \n+\n   /* Note that the 'getter' is generated at gimplify time; at this\n      time, we can simply put the property_ref (ie, argument) wherever\n      we want the getter ultimately to be.  */\n-  \n+\n   /* s1: __objc_property_temp = [object property] <+/- increment> */\n   switch (code)\n     {\n-    case PREINCREMENT_EXPR:\t \n+    case PREINCREMENT_EXPR:\n       /* __objc_property_temp = [object property] + increment */\n       s1 = build_modify_expr (location, temp_variable_decl, NULL_TREE,\n \t\t\t      NOP_EXPR,\n-\t\t\t      location, build2 (PLUS_EXPR, TREE_TYPE (argument), \n+\t\t\t      location, build2 (PLUS_EXPR, TREE_TYPE (argument),\n \t\t\t\t\t\targument, increment), NULL_TREE);\n       break;\n     case PREDECREMENT_EXPR:\n       /* __objc_property_temp = [object property] - increment */\n       s1 = build_modify_expr (location, temp_variable_decl, NULL_TREE,\n \t\t\t      NOP_EXPR,\n-\t\t\t      location, build2 (MINUS_EXPR, TREE_TYPE (argument), \n+\t\t\t      location, build2 (MINUS_EXPR, TREE_TYPE (argument),\n \t\t\t\t\t\targument, increment), NULL_TREE);\n       break;\n     case POSTINCREMENT_EXPR:\n@@ -1961,25 +1961,25 @@ objc_build_incr_expr_for_property_ref (location_t location,\n     default:\n       gcc_unreachable ();\n     }\n-  \n+\n   /* s2: [object setProperty: __objc_property_temp <+/- increment>] */\n   switch (code)\n     {\n-    case PREINCREMENT_EXPR:\t \n+    case PREINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n       /* [object setProperty: __objc_property_temp] */\n       s2 = objc_build_setter_call (argument, temp_variable_decl);\n       break;\n     case POSTINCREMENT_EXPR:\n       /* [object setProperty: __objc_property_temp + increment] */\n       s2 = objc_build_setter_call (argument,\n-\t\t\t\t   build2 (PLUS_EXPR, TREE_TYPE (argument), \n+\t\t\t\t   build2 (PLUS_EXPR, TREE_TYPE (argument),\n \t\t\t\t\t   temp_variable_decl, increment));\n       break;\n     case POSTDECREMENT_EXPR:\n       /* [object setProperty: __objc_property_temp - increment] */\n       s2 = objc_build_setter_call (argument,\n-\t\t\t\t   build2 (MINUS_EXPR, TREE_TYPE (argument), \n+\t\t\t\t   build2 (MINUS_EXPR, TREE_TYPE (argument),\n \t\t\t\t\t   temp_variable_decl, increment));\n       break;\n     default:\n@@ -1991,11 +1991,11 @@ objc_build_incr_expr_for_property_ref (location_t location,\n   if (s2 == error_mark_node)\n     return error_mark_node;\n \n-  SET_EXPR_LOCATION (s2, location); \n-  \n+  SET_EXPR_LOCATION (s2, location);\n+\n   /* s3: __objc_property_temp */\n   s3 = convert (TREE_TYPE (argument), temp_variable_decl);\n-  \n+\n   /* Now build the compound statement (s1, s2, s3) */\n   compound_expr = build_compound_expr (location, build_compound_expr (location, s1, s2), s3);\n \n@@ -2391,8 +2391,8 @@ objc_common_type (tree type1, tree type2)\n      -2\t\tInitialization;\n      -3\t\tComparison (LTYP and RTYP may match in either direction);\n      -4\t\tSilent comparison (for C++ overload resolution);\n-     -5\t\tSilent \"specialization\" comparison for RTYP to be a \"specialization\" \n-                of LTYP (a specialization means that RTYP is LTYP plus some constraints, \n+     -5\t\tSilent \"specialization\" comparison for RTYP to be a \"specialization\"\n+                of LTYP (a specialization means that RTYP is LTYP plus some constraints,\n                 so that each object of type RTYP is also of type LTYP).  This is used\n                 when comparing property types.  */\n \n@@ -2496,7 +2496,7 @@ objc_compare_types (tree ltyp, tree rtyp, int argno, tree callee)\n       if (!lproto && objc_is_object_id (ltyp))\n \treturn true;\n     }\n-  \n+\n   pointers_compatible = (TYPE_MAIN_VARIANT (ltyp) == TYPE_MAIN_VARIANT (rtyp));\n \n   /* If the underlying types are the same, and at most one of them has\n@@ -2521,7 +2521,7 @@ objc_compare_types (tree ltyp, tree rtyp, int argno, tree callee)\n \t    pointers_compatible\n \t      = (objc_is_object_id (ltyp) || objc_is_object_id (rtyp));\n \t  else\n-\t    pointers_compatible = objc_is_object_id (ltyp);\t    \n+\t    pointers_compatible = objc_is_object_id (ltyp);\n \t}\n \n       if (!pointers_compatible)\n@@ -2588,7 +2588,7 @@ objc_compare_types (tree ltyp, tree rtyp, int argno, tree callee)\n    variety and calls objc_common_type to obtain a common type. There is no commonolty\n    between two function-pointers in this regard. */\n \n-bool \n+bool\n objc_have_common_type (tree ltyp, tree rtyp, int argno, tree callee)\n {\n   if (objc_compare_types (ltyp, rtyp, argno, callee))\n@@ -2785,7 +2785,7 @@ objc_get_protocol_qualified_type (tree interface, tree protocols)\n \t  TREE_TYPE (type) = build_variant_type_copy (orig_pointee_type);\n \n \t  /* Set up the canonical type information. */\n-\t  TYPE_CANONICAL (type) \n+\t  TYPE_CANONICAL (type)\n \t    = TYPE_CANONICAL (TYPE_POINTER_TO (orig_pointee_type));\n \n \t  TYPE_POINTER_TO (TREE_TYPE (type)) = type;\n@@ -2993,12 +2993,12 @@ synth_module_prologue (void)\n \n   /* Declare struct _objc_fast_enumeration_state { ... };  */\n   build_fast_enumeration_state_template ();\n-  \n+\n   /* void objc_enumeration_mutation (id) */\n   type = build_function_type_list (void_type_node,\n \t\t\t\t   objc_object_type, NULL_TREE);\n-  objc_enumeration_mutation_decl \n-    = add_builtin_function (TAG_ENUMERATION_MUTATION, type, 0, NOT_BUILT_IN, \n+  objc_enumeration_mutation_decl\n+    = add_builtin_function (TAG_ENUMERATION_MUTATION, type, 0, NOT_BUILT_IN,\n \t\t\t    NULL, NULL_TREE);\n   TREE_NOTHROW (objc_enumeration_mutation_decl) = 0;\n \n@@ -3140,11 +3140,11 @@ objc_build_string_object (tree string)\n   TREE_SET_CODE (string, STRING_CST);\n   length = TREE_STRING_LENGTH (string) - 1;\n \n-  /* The target may have different ideas on how to construct an ObjC string \n-     literal.  On Darwin (Mac OS X), for example, we may wish to obtain a \n+  /* The target may have different ideas on how to construct an ObjC string\n+     literal.  On Darwin (Mac OS X), for example, we may wish to obtain a\n      constant CFString reference instead.\n      At present, this is only supported for the NeXT runtime.  */\n-  if (flag_next_runtime \n+  if (flag_next_runtime\n       && targetcm.objc_construct_string_object)\n     {\n       tree constructor = (*targetcm.objc_construct_string_object) (string);\n@@ -3192,7 +3192,7 @@ objc_build_string_object (tree string)\n     {\n       *loc = desc = ggc_alloc_string_descriptor ();\n       desc->literal = string;\n-      desc->constructor = \n+      desc->constructor =\n \t(*runtime.build_const_string_constructor) (input_location, string, length);\n     }\n \n@@ -3354,7 +3354,7 @@ objc_declare_alias (tree alias_ident, tree class_ident)\n #ifdef OBJCPLUS\n       pop_lang_context ();\n #endif\n-      hash_class_name_enter (als_name_hash_list, alias_ident, \n+      hash_class_name_enter (als_name_hash_list, alias_ident,\n \t\t\t     underlying_class);\n     }\n }\n@@ -3371,14 +3371,14 @@ objc_declare_class (tree identifier)\n   if (! objc_is_class_name (identifier))\n     {\n       tree record = lookup_name (identifier), type = record;\n-      \n+\n       if (record)\n \t{\n \t  if (TREE_CODE (record) == TYPE_DECL)\n \t    type = DECL_ORIGINAL_TYPE (record)\n \t      ? DECL_ORIGINAL_TYPE (record)\n \t      : TREE_TYPE (record);\n-\t  \n+\n \t  if (!TYPE_HAS_OBJC_INFO (type)\n \t      || !TYPE_OBJC_INTERFACE (type))\n \t    {\n@@ -3388,7 +3388,7 @@ objc_declare_class (tree identifier)\n \t\t     record);\n \t    }\n \t}\n-      \n+\n       record = xref_tag (RECORD_TYPE, identifier);\n       INIT_TYPE_OBJC_INFO (record);\n       /* In the case of a @class declaration, we store the ident in\n@@ -3577,7 +3577,7 @@ objc_build_global_assignment (tree lhs, tree rhs)\n \t\t    NULL_TREE));\n \n   assemble_external (objc_assign_global_decl);\n-  return build_function_call (input_location, \n+  return build_function_call (input_location,\n \t\t\t      objc_assign_global_decl, func_params);\n }\n \n@@ -3867,18 +3867,18 @@ eq_instance_variable (const PTR p1, const PTR p2)\n bool\n objc_detect_field_duplicates (bool check_superclasses_only)\n {\n-  if (!objc_collecting_ivars || !objc_interface_context \n+  if (!objc_collecting_ivars || !objc_interface_context\n       || TREE_CODE (objc_interface_context) != CLASS_INTERFACE_TYPE)\n     return false;\n \n   /* We have two ways of doing this check:\n-     \n+\n   \"direct comparison\": we iterate over the instance variables and\n   compare them directly.  This works great for small numbers of\n   instance variables (such as 10 or 20), which are extremely common.\n   But it will potentially take forever for the pathological case with\n   a huge number (eg, 10k) of instance variables.\n-  \n+\n   \"hashtable\": we use a hashtable, which requires a single sweep\n   through the list of instances variables.  This is much slower for a\n   small number of variables, and we only use it for large numbers.\n@@ -3901,7 +3901,7 @@ objc_detect_field_duplicates (bool check_superclasses_only)\n     /* Exit if there is nothing to do.  */\n     if (number_of_ivars_to_check == 0)\n       return true;\n-    \n+\n     /* In case that there are only 1 or 2 instance variables to check,\n        we always use direct comparison.  If there are more, it is\n        worth iterating over the instance variables in the superclass\n@@ -3926,7 +3926,7 @@ objc_detect_field_duplicates (bool check_superclasses_only)\n \t}\n \n \t/* We use a hashtable if we have over 10k comparisons.  */\n-\tif (number_of_ivars_to_check * (number_of_superclass_ivars \n+\tif (number_of_ivars_to_check * (number_of_superclass_ivars\n \t\t\t\t\t+ (number_of_ivars_to_check / 2))\n \t    > 10000)\n \t  {\n@@ -3954,7 +3954,7 @@ objc_detect_field_duplicates (bool check_superclasses_only)\n \t\t      }\n \t\t  }\n \t      }\n-\t    \n+\n \t    /* Now, we go through all the instance variables in the\n \t       class, and check that they are not in the\n \t       hashtable.  */\n@@ -4015,7 +4015,7 @@ objc_detect_field_duplicates (bool check_superclasses_only)\n \t  }\n       }\n   }\n-  \n+\n   /* This is the \"direct comparison\" approach, which is used in most\n      non-pathological cases.  */\n   {\n@@ -4026,7 +4026,7 @@ objc_detect_field_duplicates (bool check_superclasses_only)\n \n     if (check_superclasses_only)\n       interface = lookup_interface (CLASS_SUPER_NAME (interface));\n-    \n+\n     for ( ; interface; interface = lookup_interface\n \t    (CLASS_SUPER_NAME (interface)))\n       {\n@@ -4037,7 +4037,7 @@ objc_detect_field_duplicates (bool check_superclasses_only)\n \t     ivar_being_checked = DECL_CHAIN (ivar_being_checked))\n \t  {\n \t    tree decl;\n-\t    \n+\n \t    /* Ignore anonymous ivars.  */\n \t    if (DECL_NAME (ivar_being_checked) == NULL_TREE)\n \t      continue;\n@@ -4205,7 +4205,7 @@ objc_begin_catch_clause (tree decl)\n \t   && TYPE_OBJC_PROTOCOL_LIST (TREE_TYPE (type)))\n     {\n       error (\"@catch parameter can not be protocol-qualified\");\n-      type = error_mark_node;      \n+      type = error_mark_node;\n     }\n   else if (POINTER_TYPE_P (type) && objc_is_object_id (TREE_TYPE (type)))\n     /* @catch (id xyz) or @catch (...) but we note this for runtimes that\n@@ -4217,11 +4217,11 @@ objc_begin_catch_clause (tree decl)\n \t them and get a simple pointer to the class.  */\n       bool is_typedef = false;\n       tree x = TYPE_MAIN_VARIANT (type);\n-      \n+\n       /* Skip from the pointer to the pointee.  */\n       if (TREE_CODE (x) == POINTER_TYPE)\n \tx = TREE_TYPE (x);\n-      \n+\n       /* Traverse typedef aliases */\n       while (TREE_CODE (x) == RECORD_TYPE && OBJC_TYPE_NAME (x)\n \t     && TREE_CODE (OBJC_TYPE_NAME (x)) == TYPE_DECL\n@@ -4364,7 +4364,7 @@ objc_build_synchronized (location_t start_locus, tree object_expr, tree body)\n \t  object_expr = error_mark_node;\n \t}\n     }\n-  \n+\n   if (object_expr == error_mark_node)\n     {\n       /* If we found an error, we simply ignore the '@synchronized'.\n@@ -4377,7 +4377,7 @@ objc_build_synchronized (location_t start_locus, tree object_expr, tree body)\n       tree call;\n       tree args;\n \n-      /* objc_sync_enter (object_expr); */      \n+      /* objc_sync_enter (object_expr); */\n       object_expr = save_expr (object_expr);\n       args = tree_cons (NULL, object_expr, NULL);\n       call = build_function_call (input_location,\n@@ -4394,10 +4394,10 @@ objc_build_synchronized (location_t start_locus, tree object_expr, tree body)\n \n       /* @try { body; } */\n       objc_begin_try_stmt (start_locus, body);\n-      \n+\n       /* @finally { objc_sync_exit (object_expr); } */\n       objc_build_finally_clause (input_location, call);\n-      \n+\n       /* End of try statement.  */\n       return objc_finish_try_stmt ();\n     }\n@@ -4789,7 +4789,7 @@ adjust_type_for_id_default (tree type)\n \n    For example, take the Objective-C method\n \n-   -(NSString *)pathForResource:(NSString *)resource ofType:(NSString *)type; \n+   -(NSString *)pathForResource:(NSString *)resource ofType:(NSString *)type;\n \n    the two fragments \"pathForResource:(NSString *)resource\" and\n    \"ofType:(NSString *)type\" will generate a KEYWORD_DECL each.  The\n@@ -4809,7 +4809,7 @@ adjust_type_for_id_default (tree type)\n    'arg_name' is an identifier node and is required.\n    'attributes' is an optional tree containing parameter attributes.  */\n tree\n-objc_build_keyword_decl (tree key_name, tree arg_type, \n+objc_build_keyword_decl (tree key_name, tree arg_type,\n \t\t\t tree arg_name, tree attributes)\n {\n   tree keyword_decl;\n@@ -4951,14 +4951,14 @@ objc_decl_method_attributes (tree *node, tree attributes, int flags)\n       for (attribute = attributes; attribute; attribute = TREE_CHAIN (attribute))\n \t{\n \t  tree name = TREE_PURPOSE (attribute);\n-\t  \n+\n \t  if (is_attribute_p  (\"deprecated\", name)\n \t      || is_attribute_p (\"sentinel\", name)\n \t      || is_attribute_p (\"noreturn\", name))\n \t    {\n \t      /* An attribute that we support; add it to the filtered\n \t\t attributes.  */\n-\t      filtered_attributes = chainon (filtered_attributes, \n+\t      filtered_attributes = chainon (filtered_attributes,\n \t\t\t\t\t     copy_node (attribute));\n \t    }\n \t  else if (is_attribute_p (\"format\", name))\n@@ -4998,11 +4998,11 @@ objc_decl_method_attributes (tree *node, tree attributes, int flags)\n \t\t      && TREE_CODE (number) == INTEGER_CST\n \t\t      && TREE_INT_CST_HIGH (number) == 0)\n \t\t    {\n-\t\t      TREE_VALUE (second_argument) \n+\t\t      TREE_VALUE (second_argument)\n \t\t\t= build_int_cst (integer_type_node,\n \t\t\t\t\t TREE_INT_CST_LOW (number) + 2);\n \t\t    }\n-\t\t  \n+\n \t\t  /* This is the third argument, the \"first-to-check\",\n \t\t     which specifies the index of the first argument to\n \t\t     check.  This could be 0, meaning it is not available,\n@@ -5014,7 +5014,7 @@ objc_decl_method_attributes (tree *node, tree attributes, int flags)\n \t\t      && TREE_INT_CST_HIGH (number) == 0\n \t\t      && TREE_INT_CST_LOW (number) != 0)\n \t\t    {\n-\t\t      TREE_VALUE (third_argument) \n+\t\t      TREE_VALUE (third_argument)\n \t\t\t= build_int_cst (integer_type_node,\n \t\t\t\t\t TREE_INT_CST_LOW (number) + 2);\n \t\t    }\n@@ -5040,15 +5040,15 @@ objc_decl_method_attributes (tree *node, tree attributes, int flags)\n \t (by setting TREE_DEPRECATED and TREE_THIS_VOLATILE) so there\n \t is nothing to do.  */\n       tree saved_type = TREE_TYPE (*node);\n-      TREE_TYPE (*node) = build_function_type \n+      TREE_TYPE (*node) = build_function_type\n \t(TREE_VALUE (saved_type), get_arg_type_list (*node, METHOD_REF, 0));\n       decl_attributes (node, filtered_attributes, flags);\n       METHOD_TYPE_ATTRIBUTES (*node) = TYPE_ATTRIBUTES (TREE_TYPE (*node));\n       TREE_TYPE (*node) = saved_type;\n     }\n }\n \n-bool \n+bool\n objc_method_decl (enum tree_code opcode)\n {\n   return opcode == INSTANCE_METHOD_DECL || opcode == CLASS_METHOD_DECL;\n@@ -5461,7 +5461,7 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params,\n       if (!rtype || TREE_CODE (rtype) == IDENTIFIER_NODE)\n \t{\n \t  rtype = NULL_TREE;\n-\t  /* We could not find an @interface declaration, yet Message maybe in a \n+\t  /* We could not find an @interface declaration, yet Message maybe in a\n \t     @class's protocol. */\n \t  if (!method_prototype && rprotos)\n \t    method_prototype\n@@ -5521,7 +5521,7 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params,\n \t  = lookup_method_in_hash_lists (sel_name, class_tree != NULL_TREE);\n     }\n \n-  if (!method_prototype) \n+  if (!method_prototype)\n     {\n       static bool warn_missing_methods = false;\n \n@@ -5540,11 +5540,11 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params,\n \n       if (!warn_missing_methods)\n \t{\n-\t  warning_at (input_location, \n+\t  warning_at (input_location,\n \t\t      0, \"(Messages without a matching method signature\");\n-\t  warning_at (input_location, \n+\t  warning_at (input_location,\n \t\t      0, \"will be assumed to return %<id%> and accept\");\n-\t  warning_at (input_location, \n+\t  warning_at (input_location,\n \t\t      0, \"%<...%> as arguments.)\");\n \t  warn_missing_methods = true;\n \t}\n@@ -5578,9 +5578,9 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params,\n   current_objc_message_selector = sel_name;\n \n   /* Build the method call.\n-     TODO: Get the location from somewhere that will work for delayed \n+     TODO: Get the location from somewhere that will work for delayed\n \t   expansion.  */\n-  \n+\n   retval = (*runtime.build_objc_method_call) (input_location, method_prototype,\n \t\t\t\t\t      receiver, rtype, sel_name,\n \t\t\t\t\t      method_params, super);\n@@ -5591,7 +5591,7 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params,\n }\n \f\n \n-/* This routine creates a static variable used to implement @protocol(MyProtocol) \n+/* This routine creates a static variable used to implement @protocol(MyProtocol)\n    expression. This variable will be initialized to global protocol_t meta-data\n    pointer. */\n \n@@ -5930,7 +5930,7 @@ lookup_method_static (tree interface, tree ident, int flags)\n     }\n   else\n     {\n-      /* If an instance method was not found, return 0.  */      \n+      /* If an instance method was not found, return 0.  */\n       return NULL_TREE;\n     }\n }\n@@ -6004,7 +6004,7 @@ objc_add_method (tree klass, tree method, int is_class, bool is_optional)\n \t    existing_method = lookup_method (PROTOCOL_OPTIONAL_CLS_METHODS (klass), method);\n \t  else\n \t    existing_method = lookup_method (PROTOCOL_OPTIONAL_NST_METHODS (klass), method);\n-\t  \n+\n \t  if (!is_optional && existing_method)\n \t    {\n \t      error (\"method %<%c%E%> declared %<@optional%> and %<@required%> at the same time\",\n@@ -6217,7 +6217,7 @@ printable_ivar_name (tree field_decl)\n    VISIBILITY is 1 for public, 0 for protected, and 2 for private.  */\n \n static tree\n-add_instance_variable (tree klass, objc_ivar_visibility_kind visibility, \n+add_instance_variable (tree klass, objc_ivar_visibility_kind visibility,\n \t\t       tree field_decl)\n {\n   tree field_type = TREE_TYPE (field_decl);\n@@ -6260,7 +6260,7 @@ add_instance_variable (tree klass, objc_ivar_visibility_kind visibility,\n       error (\"instance variable %qs uses flexible array member\",\n \t     printable_ivar_name (field_decl));\n       /* Return class as is without adding this ivar.  */\n-      return klass;      \n+      return klass;\n     }\n #endif\n \n@@ -6385,9 +6385,9 @@ ivar_of_class (tree klass, tree ivar_name_ident)\n   while (CLASS_SUPER_NAME (klass))\n     {\n       klass = lookup_interface (CLASS_SUPER_NAME (klass));\n-      \n+\n       decl_chain = CLASS_RAW_IVARS (klass);\n-  \n+\n       for ( ; decl_chain; decl_chain = DECL_CHAIN (decl_chain))\n \tif (DECL_NAME (decl_chain) == ivar_name_ident)\n \t  return decl_chain;\n@@ -6515,7 +6515,7 @@ check_methods (tree chain, tree implementation, int mtype)\n \t    && (PROPERTY_GETTER_NAME (x) == METHOD_SEL_NAME (chain)\n \t\t|| PROPERTY_SETTER_NAME (x) == METHOD_SEL_NAME (chain)))\n \t  break;\n-      \n+\n       if (x != NULL_TREE)\n \t{\n \t  chain = TREE_CHAIN (chain); /* next method...  */\n@@ -6544,7 +6544,7 @@ check_methods (tree chain, tree implementation, int mtype)\n \t\t  if (lookup_method (CLASS_NST_METHODS (interface), chain))\n \t\t    {\n \t\t      chain = DECL_CHAIN (chain);\n-\t\t      continue;\t\t      \n+\t\t      continue;\n \t\t    }\n \n \t\t  /* Else, get the superclass.  */\n@@ -6650,12 +6650,12 @@ check_methods_accessible (tree chain, tree context, int mtype)\n \t    && (PROPERTY_GETTER_NAME (x) == METHOD_SEL_NAME (chain)\n \t\t|| PROPERTY_SETTER_NAME (x) == METHOD_SEL_NAME (chain)))\n \t  break;\n-      \n+\n       if (x != NULL_TREE)\n \t{\n \t  chain = TREE_CHAIN (chain); /* next method...  */\n \t  continue;\n-\t}\t\n+\t}\n \n       context = base_context;\n       while (context)\n@@ -6834,7 +6834,7 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \n       if (super)\n \tsuper_interface = lookup_interface (super);\n-      \n+\n       if (!super_interface)\n \t{\n \t  error (\"cannot find interface declaration for %qE, superclass of %qE\",\n@@ -6845,7 +6845,7 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n       else\n \t{\n \t  if (TREE_DEPRECATED (super_interface))\n-\t    warning (OPT_Wdeprecated_declarations, \"class %qE is deprecated\", \n+\t    warning (OPT_Wdeprecated_declarations, \"class %qE is deprecated\",\n \t\t     super);\n \t  super_name = super;\n \t}\n@@ -6872,7 +6872,7 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n     case CLASS_IMPLEMENTATION_TYPE:\n       {\n \ttree chain;\n-\t\n+\n \tfor (chain = implemented_classes; chain; chain = TREE_CHAIN (chain))\n \t  if (TREE_VALUE (chain) == class_name)\n \t    {\n@@ -6933,7 +6933,7 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n #endif\n       else\n \tadd_class (klass, class_name);\n-       \n+\n       if (protocol_list)\n \tCLASS_PROTOCOL_LIST (klass)\n \t  = lookup_and_install_protocols (protocol_list, /* definition_required */ true);\n@@ -6944,7 +6944,7 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \t  for (attribute = attributes; attribute; attribute = TREE_CHAIN (attribute))\n \t    {\n \t      tree name = TREE_PURPOSE (attribute);\n-\t      \n+\n \t      /* TODO: Document what the objc_exception attribute is/does.  */\n \t      /* We handle the 'deprecated' and (undocumented) 'objc_exception'\n \t\t attributes.  */\n@@ -6958,12 +6958,12 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \t    }\n \t  TYPE_ATTRIBUTES (klass) = attributes;\n \t}\n-      break;     \n+      break;\n \n     case CATEGORY_INTERFACE_TYPE:\n       {\n \ttree class_category_is_assoc_with;\n-\t\n+\n \t/* For a category, class_name is really the name of the class that\n \t   the following set of methods will be associated with. We must\n \t   find the interface so that can derive the objects template.  */\n@@ -6976,7 +6976,7 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \telse\n \t  {\n \t    if (TREE_DEPRECATED (class_category_is_assoc_with))\n-\t      warning (OPT_Wdeprecated_declarations, \"class %qE is deprecated\", \n+\t      warning (OPT_Wdeprecated_declarations, \"class %qE is deprecated\",\n \t\t       class_name);\n \n \t    if (super_name == NULL_TREE)\n@@ -7000,7 +7000,7 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \t    else\n \t      {\n \t\tadd_category (class_category_is_assoc_with, klass);\n-\t\t\n+\n \t\tif (protocol_list)\n \t\t  CLASS_PROTOCOL_LIST (klass)\n \t\t    = lookup_and_install_protocols\n@@ -7009,7 +7009,7 @@ start_class (enum tree_code code, tree class_name, tree super_name,\n \t  }\n       }\n       break;\n-\t\n+\n     case CATEGORY_IMPLEMENTATION_TYPE:\n       /* Reset for multiple classes per file.  */\n       method_slot = 0;\n@@ -7047,7 +7047,7 @@ continue_class (tree klass)\n \n \tif (CLASS_RAW_IVARS (klass))\n \t  check_ivars (implementation_template, klass);\n-\t\n+\n \t/* code generation */\n #ifdef OBJCPLUS\n \tpush_lang_context (lang_name_c);\n@@ -7083,7 +7083,7 @@ continue_class (tree klass)\n #ifdef OBJCPLUS\n \tpop_lang_context ();\n #endif /* OBJCPLUS */\n-\t\n+\n \treturn get_class_ivars (implementation_template, true);\n \tbreak;\n       }\n@@ -7121,18 +7121,18 @@ objc_build_property_setter_name (tree ident)\n \n /* This routine prepares the declarations of the property accessor\n    helper functions (objc_getProperty(), etc) that are used when\n-   @synthesize is used.  \n-   \n-   runtime-specific routines are built in the respective runtime \n+   @synthesize is used.\n+\n+   runtime-specific routines are built in the respective runtime\n    initialize functions.  */\n-static void \n+static void\n build_common_objc_property_accessor_helpers (void)\n {\n   tree type;\n \n   /* Declare the following function:\n      id\n-     objc_getProperty (id self, SEL _cmd, \n+     objc_getProperty (id self, SEL _cmd,\n                        ptrdiff_t offset, BOOL is_atomic);  */\n   type = build_function_type_list (objc_object_type,\n \t\t\t\t   objc_object_type,\n@@ -7144,11 +7144,11 @@ build_common_objc_property_accessor_helpers (void)\n \t\t\t\t\t\ttype, 0, NOT_BUILT_IN,\n \t\t\t\t\t\tNULL, NULL_TREE);\n   TREE_NOTHROW (objc_getProperty_decl) = 0;\n-  \n+\n   /* Declare the following function:\n      void\n-     objc_setProperty (id self, SEL _cmd, \n-                       ptrdiff_t offset, id new_value, \n+     objc_setProperty (id self, SEL _cmd,\n+                       ptrdiff_t offset, id new_value,\n                        BOOL is_atomic, BOOL should_copy);  */\n   type = build_function_type_list (void_type_node,\n \t\t\t\t   objc_object_type,\n@@ -7171,16 +7171,16 @@ lookup_ivar (tree interface, tree instance_variable_name)\n   while (interface)\n     {\n       tree decl_chain;\n-      \n+\n       for (decl_chain = CLASS_IVARS (interface); decl_chain; decl_chain = DECL_CHAIN (decl_chain))\n \tif (DECL_NAME (decl_chain) == instance_variable_name)\n \t  return decl_chain;\n-      \n+\n       /* Not found.  Search superclass if any.  */\n       if (CLASS_SUPER_NAME (interface))\n \tinterface = lookup_interface (CLASS_SUPER_NAME (interface));\n     }\n-  \n+\n   return NULL_TREE;\n }\n \n@@ -7273,7 +7273,7 @@ objc_synthesize_getter (tree klass, tree class_methods ATTRIBUTE_UNUSED, tree pr\n \t      (NULL_TREE, is_atomic, NULL_TREE)))));\n       }\n       break;\n-    case OBJC_PROPERTY_ASSIGN:    \n+    case OBJC_PROPERTY_ASSIGN:\n       if (PROPERTY_NONATOMIC (property))\n \t{\n \t  /* We build \"return self->PROPERTY_IVAR_NAME;\"  */\n@@ -7305,12 +7305,12 @@ objc_synthesize_getter (tree klass, tree class_methods ATTRIBUTE_UNUSED, tree pr\n \t  size_of = c_sizeof_or_alignof_type (location, TREE_TYPE (property),\n \t\t\t\t\t      true /* is_sizeof */,\n \t\t\t\t\t      false /* complain */);\n-\t  \n+\n \t  if (PROPERTY_NONATOMIC (property))\n \t    is_atomic = boolean_false_node;\n \t  else\n \t    is_atomic = boolean_true_node;\n-\t  \n+\n \t  if (objc_copyStruct_decl)\n \t    function_decl = objc_copyStruct_decl;\n \t  else\n@@ -7326,8 +7326,8 @@ objc_synthesize_getter (tree klass, tree class_methods ATTRIBUTE_UNUSED, tree pr\n \t\there causes invalid code to be generated.  */\n \t     (NULL_TREE, build_unary_op (location, ADDR_EXPR, objc_property_temp_decl, 0),\n \t      tree_cons /* &(self->PROPERTY_IVAR_NAME); */\n-\t      (NULL_TREE, build_fold_addr_expr_loc (location, \n-\t\t\t\t\t\t    objc_lookup_ivar \n+\t      (NULL_TREE, build_fold_addr_expr_loc (location,\n+\t\t\t\t\t\t    objc_lookup_ivar\n \t\t\t\t\t\t    (NULL_TREE, PROPERTY_IVAR_NAME (property))),\n \t       tree_cons /* sizeof (PROPERTY_IVAR) */\n \t       (NULL_TREE, size_of,\n@@ -7451,7 +7451,7 @@ objc_synthesize_setter (tree klass, tree class_methods ATTRIBUTE_UNUSED, tree pr\n \t  is_atomic = boolean_false_node;\n \telse\n \t  is_atomic = boolean_true_node;\n-\t\n+\n \tif (PROPERTY_ASSIGN_SEMANTICS (property) == OBJC_PROPERTY_COPY)\n \t  should_copy = boolean_true_node;\n \telse\n@@ -7471,19 +7471,19 @@ objc_synthesize_setter (tree klass, tree class_methods ATTRIBUTE_UNUSED, tree pr\n \t      tree_cons /* new_value */\n \t      (NULL_TREE, new_value,\n \t       tree_cons /* is_atomic */\n-\t       (NULL_TREE, is_atomic, \n+\t       (NULL_TREE, is_atomic,\n \t\ttree_cons /* should_copy */\n \t\t(NULL_TREE, should_copy, NULL_TREE)))))));\n       }\n       break;\n-    case OBJC_PROPERTY_ASSIGN:    \n+    case OBJC_PROPERTY_ASSIGN:\n       if (PROPERTY_NONATOMIC (property))\n \t{\n \t  /* We build \"self->PROPERTY_IVAR_NAME = new_value;\"  */\n \t  statement = build_modify_expr\n \t    (location,\n \t     objc_lookup_ivar (NULL_TREE, PROPERTY_IVAR_NAME (property)),\n-\t     NULL_TREE, NOP_EXPR, \n+\t     NULL_TREE, NOP_EXPR,\n \t     location, new_value, NULL_TREE);\n \t  break;\n \t}\n@@ -7505,25 +7505,25 @@ objc_synthesize_setter (tree klass, tree class_methods ATTRIBUTE_UNUSED, tree pr\n \t  size_of = c_sizeof_or_alignof_type (location, TREE_TYPE (property),\n \t\t\t\t\t      true /* is_sizeof */,\n \t\t\t\t\t      false /* complain */);\n-\t  \n+\n \t  if (PROPERTY_NONATOMIC (property))\n \t    is_atomic = boolean_false_node;\n \t  else\n \t    is_atomic = boolean_true_node;\n-\t  \n+\n \t  if (objc_copyStruct_decl)\n \t    function_decl = objc_copyStruct_decl;\n \t  else\n \t    function_decl = objc_setPropertyStruct_decl;\n \n-\t  statement = build_function_call \n+\t  statement = build_function_call\n \t    (location,\n \t     /* Function prototype.  */\n \t     function_decl,\n \t     /* Parameters.  */\n \t     tree_cons /* &(self->PROPERTY_IVAR_NAME); */\n-\t     (NULL_TREE, build_fold_addr_expr_loc (location, \n-\t\t\t\t\t\t   objc_lookup_ivar \n+\t     (NULL_TREE, build_fold_addr_expr_loc (location,\n+\t\t\t\t\t\t   objc_lookup_ivar\n \t\t\t\t\t\t   (NULL_TREE, PROPERTY_IVAR_NAME (property))),\n \t      tree_cons /* &new_value */\n \t      (NULL_TREE, build_fold_addr_expr_loc (location, new_value),\n@@ -7542,7 +7542,7 @@ objc_synthesize_setter (tree klass, tree class_methods ATTRIBUTE_UNUSED, tree pr\n     }\n   gcc_assert (statement);\n \n-  add_stmt (statement);  \n+  add_stmt (statement);\n   add_stmt (c_end_compound_stmt (location, body, true));\n   fn = current_function_decl;\n #ifdef OBJCPLUS\n@@ -7568,14 +7568,14 @@ objc_add_synthesize_declaration_for_property (location_t location, tree interfac\n     if (PROPERTY_NAME (property) == property_name)\n       {\n \tlocation_t original_location = DECL_SOURCE_LOCATION (property);\n-\t\n+\n \tif (PROPERTY_DYNAMIC (property))\n-\t  error_at (location, \"property %qs already specified in %<@dynamic%>\", \n+\t  error_at (location, \"property %qs already specified in %<@dynamic%>\",\n \t\t    IDENTIFIER_POINTER (property_name));\n \telse\n-\t  error_at (location, \"property %qs already specified in %<@synthesize%>\", \n+\t  error_at (location, \"property %qs already specified in %<@synthesize%>\",\n \t\t    IDENTIFIER_POINTER (property_name));\n-\t\n+\n \tif (original_location != UNKNOWN_LOCATION)\n \t  inform (original_location, \"originally specified here\");\n \treturn;\n@@ -7587,7 +7587,7 @@ objc_add_synthesize_declaration_for_property (location_t location, tree interfac\n \n   if (!property)\n     {\n-      error_at (location, \"no declaration of property %qs found in the interface\", \n+      error_at (location, \"no declaration of property %qs found in the interface\",\n \t\tIDENTIFIER_POINTER (property_name));\n       return;\n     }\n@@ -7614,7 +7614,7 @@ objc_add_synthesize_declaration_for_property (location_t location, tree interfac\n     tree type_of_ivar;\n     if (!ivar)\n       {\n-\terror_at (location, \"ivar %qs used by %<@synthesize%> declaration must be an existing ivar\", \n+\terror_at (location, \"ivar %qs used by %<@synthesize%> declaration must be an existing ivar\",\n \t\t  IDENTIFIER_POINTER (property_name));\n \treturn;\n       }\n@@ -7623,7 +7623,7 @@ objc_add_synthesize_declaration_for_property (location_t location, tree interfac\n       type_of_ivar = DECL_BIT_FIELD_TYPE (ivar);\n     else\n       type_of_ivar = TREE_TYPE (ivar);\n-    \n+\n     /* If the instance variable has a different C type, we throw an error ...  */\n     if (!comptypes (TREE_TYPE (property), type_of_ivar)\n \t/* ... unless the property is readonly, in which case we allow\n@@ -7634,11 +7634,11 @@ objc_add_synthesize_declaration_for_property (location_t location, tree interfac\n \t\t\t\t    type_of_ivar, -5, NULL_TREE)))\n       {\n \tlocation_t original_location = DECL_SOURCE_LOCATION (ivar);\n-\t\n+\n \terror_at (location, \"property %qs is using instance variable %qs of incompatible type\",\n \t\t  IDENTIFIER_POINTER (property_name),\n \t\t  IDENTIFIER_POINTER (ivar_name));\n-\t\n+\n \tif (original_location != UNKNOWN_LOCATION)\n \t  inform (original_location, \"originally specified here\");\n       }\n@@ -7656,11 +7656,11 @@ objc_add_synthesize_declaration_for_property (location_t location, tree interfac\n \tif (PROPERTY_ASSIGN_SEMANTICS (property) != OBJC_PROPERTY_ASSIGN)\n \t  {\n \t    location_t original_location = DECL_SOURCE_LOCATION (ivar);\n-\t    \n+\n \t    error_at (location, \"'assign' property %qs is using bit-field instance variable %qs\",\n \t\t      IDENTIFIER_POINTER (property_name),\n \t\t      IDENTIFIER_POINTER (ivar_name));\n-\t\n+\n \t    if (original_location != UNKNOWN_LOCATION)\n \t      inform (original_location, \"originally specified here\");\n \t    return;\n@@ -7669,11 +7669,11 @@ objc_add_synthesize_declaration_for_property (location_t location, tree interfac\n \tif (!PROPERTY_NONATOMIC (property))\n \t  {\n \t    location_t original_location = DECL_SOURCE_LOCATION (ivar);\n-\t    \n+\n \t    error_at (location, \"'atomic' property %qs is using bit-field instance variable %qs\",\n \t\t      IDENTIFIER_POINTER (property_name),\n \t\t      IDENTIFIER_POINTER (ivar_name));\n-\t    \n+\n \t    if (original_location != UNKNOWN_LOCATION)\n \t      inform (original_location, \"originally specified here\");\n \t    return;\n@@ -7687,14 +7687,14 @@ objc_add_synthesize_declaration_for_property (location_t location, tree interfac\n     if (PROPERTY_IVAR_NAME (x) == ivar_name)\n       {\n \tlocation_t original_location = DECL_SOURCE_LOCATION (x);\n-\t\n+\n \terror_at (location, \"property %qs is using the same instance variable as property %qs\",\n \t\t  IDENTIFIER_POINTER (property_name),\n \t\t  IDENTIFIER_POINTER (PROPERTY_NAME (x)));\n-\t\n+\n \tif (original_location != UNKNOWN_LOCATION)\n \t  inform (original_location, \"originally specified here\");\n-\t\n+\n \t/* We keep going on.  This won't cause the compiler to fail;\n \t   the failure would most likely be at runtime.  */\n       }\n@@ -7703,7 +7703,7 @@ objc_add_synthesize_declaration_for_property (location_t location, tree interfac\n      PROPERTY_IVAR_NAME to a non-NULL_TREE.  You can recognize a\n      @synthesize by that.  */\n   PROPERTY_IVAR_NAME (property) = ivar_name;\n-  \n+\n   /* PROPERTY_SETTER_NAME and PROPERTY_GETTER_NAME are copied from the\n      original declaration; they are always set (with the exception of\n      PROPERTY_SETTER_NAME not being set if PROPERTY_READONLY == 1).  */\n@@ -7754,15 +7754,15 @@ objc_add_synthesize_declaration (location_t location, tree property_and_ivar_lis\n   if (!interface)\n     {\n       /* I can't see how this could happen, but it is good as a safety check.  */\n-      error_at (location, \n+      error_at (location,\n \t\t\"%<@synthesize%> requires the @interface of the class to be available\");\n       return;\n     }\n \n   /* Now, iterate over the properties and do each of them.  */\n   for (chain = property_and_ivar_list; chain; chain = TREE_CHAIN (chain))\n     {\n-      objc_add_synthesize_declaration_for_property (location, interface, TREE_VALUE (chain), \n+      objc_add_synthesize_declaration_for_property (location, interface, TREE_VALUE (chain),\n \t\t\t\t\t\t    TREE_PURPOSE (chain));\n     }\n }\n@@ -7783,9 +7783,9 @@ objc_add_dynamic_declaration_for_property (location_t location, tree interface,\n     if (PROPERTY_NAME (property) == property_name)\n       {\n \tlocation_t original_location = DECL_SOURCE_LOCATION (property);\n-\t\n+\n \tif (PROPERTY_DYNAMIC (property))\n-\t  error_at (location, \"property %qs already specified in %<@dynamic%>\", \n+\t  error_at (location, \"property %qs already specified in %<@dynamic%>\",\n \t\t    IDENTIFIER_POINTER (property_name));\n \telse\n \t  error_at (location, \"property %qs already specified in %<@synthesize%>\",\n@@ -7860,7 +7860,7 @@ objc_add_dynamic_declaration (location_t location, tree property_list)\n       interface = lookup_interface (CLASS_NAME (objc_implementation_context));\n       break;\n     case CATEGORY_IMPLEMENTATION_TYPE:\n-      interface = lookup_category (implementation_template, \n+      interface = lookup_category (implementation_template,\n \t\t\t\t   CLASS_SUPER_NAME (objc_implementation_context));\n       break;\n     default:\n@@ -7882,7 +7882,7 @@ objc_add_dynamic_declaration (location_t location, tree property_list)\n     }\n }\n \n-/* Main routine to generate code/data for all the property information for \n+/* Main routine to generate code/data for all the property information for\n    current implementation (class or category). CLASS is the interface where\n    ivars are declared.  CLASS_METHODS is where methods are found which\n    could be a class or a category depending on whether we are implementing\n@@ -7898,12 +7898,12 @@ objc_gen_property_data (tree klass, tree class_methods)\n       /* @dynamic property - nothing to check or synthesize.  */\n       if (PROPERTY_DYNAMIC (x))\n \tcontinue;\n-      \n+\n       /* @synthesize property - need to synthesize the accessors.  */\n       if (PROPERTY_IVAR_NAME (x))\n \t{\n \t  objc_synthesize_getter (klass, class_methods, x);\n-\t  \n+\n \t  if (PROPERTY_READONLY (x) == 0)\n \t    objc_synthesize_setter (klass, class_methods, x);\n \n@@ -7924,7 +7924,7 @@ finish_class (tree klass)\n     case CLASS_IMPLEMENTATION_TYPE:\n       {\n \t/* All metadata generation is done in runtime.generate_metadata().  */\n-\t\n+\n \t/* Generate what needed for property; setters, getters, etc. */\n \tobjc_gen_property_data (implementation_template, implementation_template);\n \n@@ -7946,7 +7946,7 @@ finish_class (tree klass)\n     case CATEGORY_IMPLEMENTATION_TYPE:\n       {\n \ttree category = lookup_category (implementation_template, CLASS_SUPER_NAME (klass));\n-\t\n+\n \tif (category)\n \t  {\n \t    /* Generate what needed for property; setters, getters, etc. */\n@@ -7957,7 +7957,7 @@ finish_class (tree klass)\n \t\t\t   objc_implementation_context, '+');\n \t    check_methods (CLASS_NST_METHODS (category),\n \t\t\t   objc_implementation_context, '-');\n-\t    \n+\n \t    if (CLASS_PROTOCOL_LIST (category))\n \t      check_protocols (CLASS_PROTOCOL_LIST (category),\n \t\t\t       \"category\",\n@@ -7977,7 +7977,7 @@ finish_class (tree klass)\n \t       and if not, we declare one ourselves.  */\n \t    tree getter_decl = lookup_method (CLASS_NST_METHODS (klass),\n \t\t\t\t\t      PROPERTY_GETTER_NAME (x));\n-\t    \n+\n \t    if (getter_decl)\n \t      {\n \t\t/* TODO: Check that the declaration is consistent with the property.  */\n@@ -7990,8 +7990,8 @@ finish_class (tree klass)\n \t\t   will be of the form\n \t\t   -(type)property_getter_name;  */\n \t\ttree rettype = build_tree_list (NULL_TREE, TREE_TYPE (x));\n-\t\tgetter_decl = build_method_decl (INSTANCE_METHOD_DECL, \n-\t\t\t\t\t\t rettype, PROPERTY_GETTER_NAME (x), \n+\t\tgetter_decl = build_method_decl (INSTANCE_METHOD_DECL,\n+\t\t\t\t\t\t rettype, PROPERTY_GETTER_NAME (x),\n \t\t\t\t\t\t NULL_TREE, false);\n \t\tif (PROPERTY_OPTIONAL (x))\n \t\t  objc_add_method (objc_interface_context, getter_decl, false, true);\n@@ -8005,9 +8005,9 @@ finish_class (tree klass)\n \t      {\n \t\t/* Now we check that the appropriate setter is declared,\n \t\t   and if not, we declare on ourselves.  */\n-\t\ttree setter_decl = lookup_method (CLASS_NST_METHODS (klass), \n+\t\ttree setter_decl = lookup_method (CLASS_NST_METHODS (klass),\n \t\t\t\t\t\t  PROPERTY_SETTER_NAME (x));\n-\t\t\n+\n \t\tif (setter_decl)\n \t\t  {\n \t\t    /* TODO: Check that the declaration is consistent with the property.  */\n@@ -8025,15 +8025,15 @@ finish_class (tree klass)\n \t\t    size_t length = strlen (full_setter_name);\n \t\t    char *setter_name = (char *) alloca (length);\n \t\t    tree ret_type, selector, arg_type, arg_name;\n-\t\t    \n+\n \t\t    strcpy (setter_name, full_setter_name);\n \t\t    setter_name[length - 1] = '\\0';\n \t\t    ret_type = build_tree_list (NULL_TREE, void_type_node);\n \t\t    arg_type = build_tree_list (NULL_TREE, TREE_TYPE (x));\n \t\t    arg_name = get_identifier (\"_value\");\n \t\t    selector = objc_build_keyword_decl (get_identifier (setter_name),\n \t\t\t\t\t\t\targ_type, arg_name, NULL);\n-\t\t    setter_decl = build_method_decl (INSTANCE_METHOD_DECL, \n+\t\t    setter_decl = build_method_decl (INSTANCE_METHOD_DECL,\n \t\t\t\t\t\t     ret_type, selector,\n \t\t\t\t\t\t     build_tree_list (NULL_TREE, NULL_TREE),\n \t\t\t\t\t\t     false);\n@@ -8043,7 +8043,7 @@ finish_class (tree klass)\n \t\t      objc_add_method (objc_interface_context, setter_decl, false, false);\n \t\t    TREE_DEPRECATED (setter_decl) = TREE_DEPRECATED (x);\n \t\t    METHOD_PROPERTY_CONTEXT (setter_decl) = x;\n-\t\t  }\t       \n+\t\t  }\n \t      }\n \t  }\n \tbreak;\n@@ -8100,7 +8100,7 @@ lookup_protocol (tree ident, bool warn_if_deprecated, bool definition_required)\n \t    /* It would be nice to use warn_deprecated_use() here, but\n \t       we are using TREE_CHAIN (which is supposed to be the\n \t       TYPE_STUB_DECL for a TYPE) for something different.  */\n-\t    warning (OPT_Wdeprecated_declarations, \"protocol %qE is deprecated\", \n+\t    warning (OPT_Wdeprecated_declarations, \"protocol %qE is deprecated\",\n \t\t     PROTOCOL_NAME (chain));\n \t  }\n \n@@ -8135,7 +8135,7 @@ objc_declare_protocol (tree name, tree attributes)\n       for (attribute = attributes; attribute; attribute = TREE_CHAIN (attribute))\n \t{\n \t  tree name = TREE_PURPOSE (attribute);\n-\t  \n+\n \t  if (is_attribute_p  (\"deprecated\", name))\n \t    deprecated = true;\n \t  else\n@@ -8147,15 +8147,15 @@ objc_declare_protocol (tree name, tree attributes)\n \t\t       /* definition_required */ false) == NULL_TREE)\n     {\n       tree protocol = make_node (PROTOCOL_INTERFACE_TYPE);\n-      \n+\n       TYPE_LANG_SLOT_1 (protocol)\n \t= make_tree_vec (PROTOCOL_LANG_SLOT_ELTS);\n       PROTOCOL_NAME (protocol) = name;\n       PROTOCOL_LIST (protocol) = NULL_TREE;\n       add_protocol (protocol);\n       PROTOCOL_DEFINED (protocol) = 0;\n       PROTOCOL_FORWARD_DECL (protocol) = NULL_TREE;\n-      \n+\n       if (attributes)\n \t{\n \t  /* TODO: Do we need to store the attributes here ? */\n@@ -8186,7 +8186,7 @@ start_protocol (enum tree_code code, tree name, tree list, tree attributes)\n       for (attribute = attributes; attribute; attribute = TREE_CHAIN (attribute))\n \t{\n \t  tree name = TREE_PURPOSE (attribute);\n-\t  \n+\n \t  if (is_attribute_p  (\"deprecated\", name))\n \t    deprecated = true;\n \t  else\n@@ -8438,7 +8438,7 @@ objc_types_are_equivalent (tree type1, tree type2)\n      identical.  */\n   if (type1 == NULL_TREE && type2 == NULL_TREE)\n     return 1;\n-  \n+\n   /* If one has protocols, and the other one hasn't, they are not\n      identical.  */\n   if ((type1 == NULL_TREE && type2 != NULL_TREE)\n@@ -8455,11 +8455,11 @@ objc_types_are_equivalent (tree type1, tree type2)\n       for (t = type2; t; t = TREE_CHAIN (t))\n \tif (!lookup_protocol_in_reflist (type1, TREE_VALUE (t)))\n \t  return 0;\n-      \n+\n       for (t = type1; t; t = TREE_CHAIN (t))\n \tif (!lookup_protocol_in_reflist (type2, TREE_VALUE (t)))\n \t  return 0;\n-      \n+\n       return 1;\n     }\n }\n@@ -8516,16 +8516,16 @@ comp_proto_with_proto (tree proto1, tree proto2, int strict)\n       {\n \ttype1 = TREE_VALUE (TREE_TYPE (arg1));\n \ttype2 = TREE_VALUE (TREE_TYPE (arg2));\n-\t\n+\n \t/* FIXME: Do we need to decay argument types to compare them ?  */\n \ttype1 = objc_decay_parm_type (type1);\n \ttype2 = objc_decay_parm_type (type2);\n-\t\n+\n \tif (!objc_types_are_equivalent (type1, type2)\n \t    && (strict || !objc_types_share_size_and_alignment (type1, type2)))\n \t  return 0;\n       }\n-    \n+\n     /* The loop ends when arg1 or arg2 are NULL.  Make sure they are\n        both NULL.  */\n     if (arg1 != arg2)\n@@ -8544,17 +8544,17 @@ comp_proto_with_proto (tree proto1, tree proto2, int strict)\n \t  {\n \t    type1 = TREE_TYPE (TREE_VALUE (arg1));\n \t    type2 = TREE_TYPE (TREE_VALUE (arg2));\n-\t    \n+\n \t    /* FIXME: Do we need to decay argument types to compare them ?  */\n \t    type1 = objc_decay_parm_type (type1);\n \t    type2 = objc_decay_parm_type (type2);\n-\t    \n+\n \t    if (!objc_types_are_equivalent (type1, type2)\n \t\t&& (strict || !objc_types_share_size_and_alignment (type1, type2)))\n \t      return 0;\n \t  }\n       }\n-    \n+\n     /* The loop ends when arg1 or arg2 are NULL.  Make sure they are\n        both NULL.  */\n     if (arg1 != arg2)\n@@ -8768,7 +8768,7 @@ really_start_method (tree method,\n \n \t  if (interface)\n \t    objc_add_method (interface, copy_node (method),\n-\t\t\t     TREE_CODE (method) == CLASS_METHOD_DECL, \n+\t\t\t     TREE_CODE (method) == CLASS_METHOD_DECL,\n \t\t\t     /* is_optional= */ false);\n \t}\n     }\n@@ -8799,7 +8799,7 @@ get_super_receiver (void)\n \tDECL_READ_P (UOBJC_SUPER_decl) = 1;\n \tlang_hooks.decls.pushdecl (UOBJC_SUPER_decl);\n         finish_decl (UOBJC_SUPER_decl, input_location, NULL_TREE, NULL_TREE,\n-\t    \t     NULL_TREE);\n+\t\t     NULL_TREE);\n \tUOBJC_SUPER_scope = objc_get_current_scope ();\n       }\n \n@@ -8821,7 +8821,7 @@ get_super_receiver (void)\n       inst_meth = (TREE_CODE (objc_method_context) == INSTANCE_METHOD_DECL);\n \n       if (TREE_CODE (objc_implementation_context) == CLASS_IMPLEMENTATION_TYPE)\n-\tclass_expr =  (*runtime.get_class_super_ref) (input_location, \n+\tclass_expr =  (*runtime.get_class_super_ref) (input_location,\n \t\t\t\t\t\t      imp_list, inst_meth);\n       else\n \t/* We have a category.  */\n@@ -8837,20 +8837,20 @@ get_super_receiver (void)\n \t      return error_mark_node;\n \t    }\n \n-\t  super_class = (*runtime.get_category_super_ref) (input_location, \n+\t  super_class = (*runtime.get_category_super_ref) (input_location,\n \t\t\t\t\t\t\t   imp_list, inst_meth);\n-\t  class_expr = build_c_cast (input_location, \n+\t  class_expr = build_c_cast (input_location,\n \t\t\t\t     TREE_TYPE (super_expr), super_class);\n \t}\n \n-      super_expr = build_modify_expr (input_location, super_expr, NULL_TREE, \n+      super_expr = build_modify_expr (input_location, super_expr, NULL_TREE,\n \t\t\t\t      NOP_EXPR,\n \t\t\t\t      input_location, class_expr, NULL_TREE);\n \n-      super_expr_list = build_compound_expr (input_location, \n+      super_expr_list = build_compound_expr (input_location,\n \t\t\t\t\t     super_expr_list, super_expr);\n \n-      super_expr = build_unary_op (input_location, \n+      super_expr = build_unary_op (input_location,\n \t\t\t\t   ADDR_EXPR, UOBJC_SUPER_decl, 0);\n       super_expr_list = build_compound_expr (input_location,\n \t\t\t\t\t     super_expr_list, super_expr);\n@@ -8981,7 +8981,7 @@ gen_type_name_0 (tree type)\n     type = DECL_NAME (type);\n \n   strcat (errbuf, TREE_CODE (type) == IDENTIFIER_NODE\n-\t  \t  ? IDENTIFIER_POINTER (type)\n+\t\t  ? IDENTIFIER_POINTER (type)\n \t\t  : \"\");\n \n   /* For 'id' and 'Class', adopted protocols are stored in the pointee.  */\n@@ -9150,7 +9150,7 @@ objc_pretty_print_method (bool is_class_method,\n {\n   if (category_name)\n     {\n-      char *result = XNEWVEC (char, strlen (class_name) + strlen (category_name) \n+      char *result = XNEWVEC (char, strlen (class_name) + strlen (category_name)\n \t\t\t      + strlen (selector) + 7);\n \n       if (is_class_method)\n@@ -9170,7 +9170,7 @@ objc_pretty_print_method (bool is_class_method,\n       else\n \tsprintf (result, \"-[%s %s]\", class_name, selector);\n \n-      return result;      \n+      return result;\n     }\n }\n #endif\n@@ -9284,7 +9284,7 @@ objc_demangle (const char *mangled)\n \t     is impossible to disambiguate.  */\n \t  for (; *cp; cp++)\n \t    if (*cp == '_')\n-\t      *cp = ':';         \n+\t      *cp = ':';\n \t}\n       *cp++ = ']';              /* closing right brace */\n       *cp++ = 0;                /* string terminator */\n@@ -9351,8 +9351,8 @@ objc_printable_name (tree decl, int v)\n     return IDENTIFIER_POINTER (DECL_NAME (decl));\n }\n \n-/* Routine is called to issue diagnostic when reference to a private \n-   ivar is made and no other variable with same name is found in \n+/* Routine is called to issue diagnostic when reference to a private\n+   ivar is made and no other variable with same name is found in\n    current scope.  */\n bool\n objc_diagnose_private_ivar (tree id)\n@@ -9363,7 +9363,7 @@ objc_diagnose_private_ivar (tree id)\n   ivar = is_ivar (objc_ivar_chain, id);\n   if (ivar && is_private (ivar))\n     {\n-      error (\"instance variable %qs is declared private\", \n+      error (\"instance variable %qs is declared private\",\n \t     IDENTIFIER_POINTER (id));\n       return true;\n     }\n@@ -9394,7 +9394,7 @@ objc_lookup_ivar (tree other, tree id)\n \n   /* Look up the ivar, but do not use it if it is not accessible.  */\n   ivar = is_ivar (objc_ivar_chain, id);\n-  \n+\n   if (!ivar || is_private (ivar))\n     return other;\n \n@@ -9483,7 +9483,7 @@ objc_gimplify_property_ref (tree *expr_p)\n     }\n #endif\n   gcc_assert (TREE_CODE (call_exp) == CALL_EXPR);\n-  \n+\n   *expr_p = call_exp;\n }\n \n@@ -9516,7 +9516,7 @@ objc_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t\t\t      is_gimple_val, fb_rvalue);\n \t  r1 = gimplify_expr (&OBJ_TYPE_REF_EXPR (*expr_p), pre_p, post_p,\n \t\t\t      is_gimple_val, fb_rvalue);\n-\t  \n+\n \t  return MIN (r0, r1);\n \t}\n       break;\n@@ -9549,7 +9549,7 @@ objc_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n    };\n \n    Confusingly enough, NSFastEnumeration is then defined by libraries\n-   to be the same structure.  \n+   to be the same structure.\n */\n \n static void\n@@ -9558,22 +9558,22 @@ build_fast_enumeration_state_template (void)\n   tree decls, *chain = NULL;\n \n   /* { */\n-  objc_fast_enumeration_state_template = objc_start_struct (get_identifier \n+  objc_fast_enumeration_state_template = objc_start_struct (get_identifier\n \t\t\t\t\t\t\t    (TAG_FAST_ENUMERATION_STATE));\n \n   /* unsigned long state; */\n   decls = add_field_decl (long_unsigned_type_node, \"state\", &chain);\n \n   /* id            *itemsPtr; */\n-  add_field_decl (build_pointer_type (objc_object_type), \n+  add_field_decl (build_pointer_type (objc_object_type),\n \t\t  \"itemsPtr\", &chain);\n \n   /* unsigned long *mutationsPtr; */\n-  add_field_decl (build_pointer_type (long_unsigned_type_node), \n+  add_field_decl (build_pointer_type (long_unsigned_type_node),\n \t\t  \"mutationsPtr\", &chain);\n \n   /* unsigned long extra[5]; */\n-  add_field_decl (build_sized_array_type (long_unsigned_type_node, 5), \n+  add_field_decl (build_sized_array_type (long_unsigned_type_node, 5),\n \t\t  \"extra\", &chain);\n \n   /* } */\n@@ -9594,7 +9594,7 @@ build_fast_enumeration_state_template (void)\n   'continue').\n \n   The syntax is\n-  \n+\n   for (<object expression> in <collection expression>)\n     <statements>\n \n@@ -9608,7 +9608,7 @@ build_fast_enumeration_state_template (void)\n     __objc_foreach_collection = <collection expression>;\n     __objc_foreach_enum_state = { 0 };\n     __objc_foreach_batchsize = [__objc_foreach_collection countByEnumeratingWithState: &__objc_foreach_enum_state  objects: __objc_foreach_items  count: 16];\n-    \n+\n     if (__objc_foreach_batchsize == 0)\n       <object expression> = nil;\n     else\n@@ -9639,7 +9639,7 @@ build_fast_enumeration_state_template (void)\n   the user expects to 'continue' or 'break' the entire foreach loop.\n   We are provided the labels that 'break' and 'continue' jump to, so\n   we place them where we want them to jump to when they pick them.\n-  \n+\n   Optimization TODO: we could cache the IMP of\n   countByEnumeratingWithState:objects:count:.\n */\n@@ -9652,7 +9652,7 @@ build_fast_enumeration_state_template (void)\n #endif\n \n void\n-objc_finish_foreach_loop (location_t location, tree object_expression, tree collection_expression, tree for_body, \n+objc_finish_foreach_loop (location_t location, tree object_expression, tree collection_expression, tree for_body,\n \t\t\t  tree break_label, tree continue_label)\n {\n   /* A tree representing the __objcFastEnumerationState struct type,\n@@ -9736,7 +9736,7 @@ objc_finish_foreach_loop (location_t location, tree object_expression, tree coll\n \t    if (DECL_ORIGINAL_TYPE (objc_NSFastEnumeration_type))\n \t      objc_fast_enumeration_state_type = DECL_ORIGINAL_TYPE (objc_NSFastEnumeration_type);\n \t    else\n-\t      objc_fast_enumeration_state_type = TREE_TYPE (objc_NSFastEnumeration_type);\t      \n+\t      objc_fast_enumeration_state_type = TREE_TYPE (objc_NSFastEnumeration_type);\n \t  }\n       }\n   }\n@@ -9778,7 +9778,7 @@ objc_finish_foreach_loop (location_t location, tree object_expression, tree coll\n   bind = build3 (BIND_EXPR, void_type_node, objc_foreach_batchsize_decl, NULL, NULL);\n   SET_EXPR_LOCATION (bind, location);\n   TREE_SIDE_EFFECTS (bind) = 1;\n-  \n+\n   /*  __objc_foreach_collection = <collection expression>; */\n   t = build2 (MODIFY_EXPR, void_type_node, objc_foreach_collection_decl, collection_expression);\n   SET_EXPR_LOCATION (t, location);\n@@ -9787,21 +9787,21 @@ objc_finish_foreach_loop (location_t location, tree object_expression, tree coll\n   mark_exp_read (collection_expression);\n \n   /*  __objc_foreach_enum_state.state = 0; */\n-  t = build2 (MODIFY_EXPR, void_type_node, objc_build_component_ref (objc_foreach_enum_state_decl, \n+  t = build2 (MODIFY_EXPR, void_type_node, objc_build_component_ref (objc_foreach_enum_state_decl,\n \t\t\t\t\t\t\t\t     get_identifier (\"state\")),\n \t      build_int_cst (long_unsigned_type_node, 0));\n   SET_EXPR_LOCATION (t, location);\n   append_to_statement_list (t, &BIND_EXPR_BODY (bind));\n \n   /*  __objc_foreach_enum_state.itemsPtr = NULL; */\n-  t = build2 (MODIFY_EXPR, void_type_node, objc_build_component_ref (objc_foreach_enum_state_decl, \n+  t = build2 (MODIFY_EXPR, void_type_node, objc_build_component_ref (objc_foreach_enum_state_decl,\n \t\t\t\t\t\t\t\t     get_identifier (\"itemsPtr\")),\n \t      null_pointer_node);\n   SET_EXPR_LOCATION (t, location);\n   append_to_statement_list (t, &BIND_EXPR_BODY (bind));\n \n   /*  __objc_foreach_enum_state.mutationsPtr = NULL; */\n-  t = build2 (MODIFY_EXPR, void_type_node, objc_build_component_ref (objc_foreach_enum_state_decl, \n+  t = build2 (MODIFY_EXPR, void_type_node, objc_build_component_ref (objc_foreach_enum_state_decl,\n \t\t\t\t\t\t\t\t     get_identifier (\"mutationsPtr\")),\n \t      null_pointer_node);\n   SET_EXPR_LOCATION (t, location);\n@@ -9815,14 +9815,14 @@ objc_finish_foreach_loop (location_t location, tree object_expression, tree coll\n   for (i = 0; i < 5 ; i++)\n     {\n       t = build2 (MODIFY_EXPR, void_type_node,\n-\t\t  build_array_ref (location, objc_build_component_ref (objc_foreach_enum_state_decl, \n+\t\t  build_array_ref (location, objc_build_component_ref (objc_foreach_enum_state_decl,\n \t\t\t\t\t\t\t\t       get_identifier (\"extra\")),\n \t\t\t\t   build_int_cst (NULL_TREE, i)),\n \t\t  build_int_cst (long_unsigned_type_node, 0));\n       SET_EXPR_LOCATION (t, location);\n       append_to_statement_list (t, &BIND_EXPR_BODY (bind));\n     }\n-    \n+\n   /* __objc_foreach_batchsize = [__objc_foreach_collection countByEnumeratingWithState: &__objc_foreach_enum_state  objects: __objc_foreach_items  count: 16]; */\n   selector_name = get_identifier (\"countByEnumeratingWithState:objects:count:\");\n #ifdef OBJCPLUS\n@@ -9855,13 +9855,13 @@ objc_finish_foreach_loop (location_t location, tree object_expression, tree coll\n   append_to_statement_list (t, &BIND_EXPR_BODY (bind));\n \n   /* if (__objc_foreach_batchsize == 0) */\n-  first_if = build3 (COND_EXPR, void_type_node, \n+  first_if = build3 (COND_EXPR, void_type_node,\n \t\t     /* Condition.  */\n-\t\t     c_fully_fold \n-\t\t     (c_common_truthvalue_conversion \n-\t\t      (location, \n+\t\t     c_fully_fold\n+\t\t     (c_common_truthvalue_conversion\n+\t\t      (location,\n \t\t       build_binary_op (location,\n-\t\t\t\t\tEQ_EXPR, \n+\t\t\t\t\tEQ_EXPR,\n \t\t\t\t\tobjc_foreach_batchsize_decl,\n \t\t\t\t\tbuild_int_cst (long_unsigned_type_node, 0), 1)),\n \t\t      false, NULL),\n@@ -9892,19 +9892,19 @@ objc_finish_foreach_loop (location_t location, tree object_expression, tree coll\n   TREE_SIDE_EFFECTS (first_else) = 1;\n \n   /* __objc_foreach_mutations_pointer = *__objc_foreach_enum_state.mutationsPtr; */\n-  t = build2 (MODIFY_EXPR, void_type_node, objc_foreach_mutations_pointer_decl, \n-\t      build_indirect_ref (location, objc_build_component_ref (objc_foreach_enum_state_decl, \n+  t = build2 (MODIFY_EXPR, void_type_node, objc_foreach_mutations_pointer_decl,\n+\t      build_indirect_ref (location, objc_build_component_ref (objc_foreach_enum_state_decl,\n \t\t\t\t\t\t\t\t      get_identifier (\"mutationsPtr\")),\n \t\t\t\t  RO_UNARY_STAR));\n   SET_EXPR_LOCATION (t, location);\n   append_to_statement_list (t, &BIND_EXPR_BODY (first_else));\n \n   /* next_batch: */\n   next_batch_label_decl = create_artificial_label (location);\n-  t = build1 (LABEL_EXPR, void_type_node, next_batch_label_decl); \n+  t = build1 (LABEL_EXPR, void_type_node, next_batch_label_decl);\n   SET_EXPR_LOCATION (t, location);\n   append_to_statement_list (t, &BIND_EXPR_BODY (first_else));\n-  \n+\n   /* { */\n \n   /* unsigned long __objc_foreach_index; */\n@@ -9929,17 +9929,17 @@ objc_finish_foreach_loop (location_t location, tree object_expression, tree coll\n   append_to_statement_list (t, &BIND_EXPR_BODY (next_batch_bind));\n \n   /* if (__objc_foreach_mutation_pointer != *__objc_foreach_enum_state.mutationsPtr) objc_enumeration_mutation (<collection expression>); */\n-  t = build3 (COND_EXPR, void_type_node, \n+  t = build3 (COND_EXPR, void_type_node,\n \t      /* Condition.  */\n-\t      c_fully_fold \n-\t      (c_common_truthvalue_conversion \n-\t       (location, \n-\t\tbuild_binary_op \n+\t      c_fully_fold\n+\t      (c_common_truthvalue_conversion\n+\t       (location,\n+\t\tbuild_binary_op\n \t\t(location,\n-\t\t NE_EXPR, \n+\t\t NE_EXPR,\n \t\t objc_foreach_mutations_pointer_decl,\n-\t\t build_indirect_ref (location, \n-\t\t\t\t     objc_build_component_ref (objc_foreach_enum_state_decl, \n+\t\t build_indirect_ref (location,\n+\t\t\t\t     objc_build_component_ref (objc_foreach_enum_state_decl,\n \t\t\t\t\t\t\t       get_identifier (\"mutationsPtr\")),\n \t\t\t\t     RO_UNARY_STAR), 1)),\n \t       false, NULL),\n@@ -9953,8 +9953,8 @@ objc_finish_foreach_loop (location_t location, tree object_expression, tree coll\n   append_to_statement_list (t, &BIND_EXPR_BODY (next_batch_bind));\n \n   /* <object expression> = enumState.itemsPtr[__objc_foreach_index]; */\n-  t = build2 (MODIFY_EXPR, void_type_node, object_expression, \n-\t      build_array_ref (location, objc_build_component_ref (objc_foreach_enum_state_decl, \n+  t = build2 (MODIFY_EXPR, void_type_node, object_expression,\n+\t      build_array_ref (location, objc_build_component_ref (objc_foreach_enum_state_decl,\n \t\t\t\t\t\t\t\t   get_identifier (\"itemsPtr\")),\n \t\t\t       objc_foreach_index_decl));\n   SET_EXPR_LOCATION (t, location);\n@@ -9972,7 +9972,7 @@ objc_finish_foreach_loop (location_t location, tree object_expression, tree coll\n     }\n \n   /* __objc_foreach_index++; */\n-  t = build2 (MODIFY_EXPR, void_type_node, objc_foreach_index_decl, \n+  t = build2 (MODIFY_EXPR, void_type_node, objc_foreach_index_decl,\n \t      build_binary_op (location,\n \t\t\t       PLUS_EXPR,\n \t\t\t       objc_foreach_index_decl,\n@@ -9981,13 +9981,13 @@ objc_finish_foreach_loop (location_t location, tree object_expression, tree coll\n   append_to_statement_list (t, &BIND_EXPR_BODY (next_batch_bind));\n \n   /* if (__objc_foreach_index < __objc_foreach_batchsize) goto next_object; */\n-  t = build3 (COND_EXPR, void_type_node, \n+  t = build3 (COND_EXPR, void_type_node,\n \t      /* Condition.  */\n-\t      c_fully_fold \n-\t      (c_common_truthvalue_conversion \n-\t       (location, \n+\t      c_fully_fold\n+\t      (c_common_truthvalue_conversion\n+\t       (location,\n \t\tbuild_binary_op (location,\n-\t\t\t\t LT_EXPR, \n+\t\t\t\t LT_EXPR,\n \t\t\t\t objc_foreach_index_decl,\n \t\t\t\t objc_foreach_batchsize_decl, 1)),\n \t       false, NULL),\n@@ -9997,7 +9997,7 @@ objc_finish_foreach_loop (location_t location, tree object_expression, tree coll\n \t      NULL_TREE);\n   SET_EXPR_LOCATION (t, location);\n   append_to_statement_list (t, &BIND_EXPR_BODY (next_batch_bind));\n-  \n+\n   /* __objc_foreach_batchsize = [__objc_foreach_collection countByEnumeratingWithState: &__objc_foreach_enum_state  objects: __objc_foreach_items  count: 16]; */\n #ifdef OBJCPLUS\n   t = objc_finish_message_expr (objc_foreach_collection_decl, selector_name,\n@@ -10023,21 +10023,21 @@ objc_finish_foreach_loop (location_t location, tree object_expression, tree coll\n \t\t\t\t    (NULL_TREE, build_int_cst (NULL_TREE, 16), NULL_TREE))), NULL);\n   }\n #endif\n-  t = build2 (MODIFY_EXPR, void_type_node, objc_foreach_batchsize_decl, \n+  t = build2 (MODIFY_EXPR, void_type_node, objc_foreach_batchsize_decl,\n \t      convert (long_unsigned_type_node, t));\n   SET_EXPR_LOCATION (t, location);\n   append_to_statement_list (t, &BIND_EXPR_BODY (next_batch_bind));\n \n   /* } */\n \n   /* if (__objc_foreach_batchsize != 0) goto next_batch; */\n-  t = build3 (COND_EXPR, void_type_node, \n+  t = build3 (COND_EXPR, void_type_node,\n \t      /* Condition.  */\n-\t      c_fully_fold \n-\t      (c_common_truthvalue_conversion \n-\t       (location, \n+\t      c_fully_fold\n+\t      (c_common_truthvalue_conversion\n+\t       (location,\n \t\tbuild_binary_op (location,\n-\t\t\t\t NE_EXPR, \n+\t\t\t\t NE_EXPR,\n \t\t\t\t objc_foreach_batchsize_decl,\n \t\t\t\t build_int_cst (long_unsigned_type_node, 0), 1)),\n \t       false, NULL),\n@@ -10092,14 +10092,14 @@ objc_string_ref_type_p (tree strp)\n   tmv = TYPE_MAIN_VARIANT (TREE_TYPE (strp));\n   tmv = OBJC_TYPE_NAME (tmv);\n   return (tmv\n-  \t  && TREE_CODE (tmv) == IDENTIFIER_NODE\n-  \t  && IDENTIFIER_POINTER (tmv)\n+\t  && TREE_CODE (tmv) == IDENTIFIER_NODE\n+\t  && IDENTIFIER_POINTER (tmv)\n \t  && !strncmp (IDENTIFIER_POINTER (tmv), \"NSString\", 8));\n }\n \n /* At present the behavior of this is undefined and it does nothing.  */\n void\n-objc_check_format_arg (tree ARG_UNUSED (format_arg), \n+objc_check_format_arg (tree ARG_UNUSED (format_arg),\n \t\t       tree ARG_UNUSED (args_list))\n {\n }\n@@ -10254,7 +10254,7 @@ encode_pointer (tree type, int curtype, int format)\n \t      /* It appears that \"r*\" means \"const char *\" rather than\n \t\t \"char *const\".  \"char *const\" is encoded as \"*\",\n \t\t which is identical to \"char *\", so the \"const\" is\n-\t\t unfortunately lost.  */\t\t \n+\t\t unfortunately lost.  */\n \t      if (TYPE_READONLY (pointer_to))\n \t\tobstack_1grow (&util_obstack, 'r');\n \t    }\n@@ -10275,7 +10275,7 @@ encode_array (tree type, int curtype, int format)\n   tree an_int_cst = TYPE_SIZE (type);\n   tree array_of = TREE_TYPE (type);\n   char buffer[40];\n-  \n+\n   if (an_int_cst == NULL)\n     {\n       /* We are trying to encode an incomplete array.  An incomplete\n@@ -10304,7 +10304,7 @@ encode_array (tree type, int curtype, int format)\n       */\n       {\n \tchar *enc = obstack_base (&util_obstack) + curtype;\n-\tif (memchr (enc, '=', \n+\tif (memchr (enc, '=',\n \t\t    obstack_object_size (&util_obstack) - curtype) == NULL)\n \t  {\n \t    /* We are not inside a struct.  Encode the array as a\n@@ -10350,7 +10350,7 @@ encode_vector (tree type, int curtype, int format)\n   sprintf (buffer, \"![\" HOST_WIDE_INT_PRINT_DEC \",%d\",\n \t   /* We want to compute the equivalent of sizeof (<vector>).\n \t      Code inspired by c_sizeof_or_alignof_type.  */\n-\t   ((TREE_INT_CST_LOW (TYPE_SIZE_UNIT (type)) \n+\t   ((TREE_INT_CST_LOW (TYPE_SIZE_UNIT (type))\n \t     / (TYPE_PRECISION (char_type_node) / BITS_PER_UNIT))),\n \t   /* We want to compute the equivalent of __alignof__\n \t      (<vector>).  Code inspired by\n@@ -10435,10 +10435,10 @@ encode_aggregate_within (tree type, int curtype, int format, int left,\n       */\n       char c1 = ob_size > 1 ? *(obstack_next_free (&util_obstack) - 2) : 0;\n       char c0 = ob_size > 0 ? *(obstack_next_free (&util_obstack) - 1) : 0;\n-      \n+\n       if (c0 == '^' || (c1 == '^' && c0 == 'r'))\n \tpointed_to = true;\n-      \n+\n       if (format == OBJC_ENCODE_INLINE_DEFS || generating_instance_variables)\n \t{\n \t  if (!pointed_to)\n@@ -10647,15 +10647,15 @@ encode_type (tree type, int curtype, int format)\n       obstack_1grow (&util_obstack, '?');\n       break;\n     }\n-  \n+\n   if (flag_next_runtime)\n     {\n       /* Super-kludge.  Some ObjC qualifier and type combinations need\n \t to be rearranged for compatibility with gcc-3.3.  */\n       if (code == POINTER_TYPE && obstack_object_size (&util_obstack) >= 3)\n \t{\n \t  char *enc = obstack_base (&util_obstack) + curtype;\n-\t  \n+\n \t  /* Rewrite \"in const\" from \"nr\" to \"rn\".  */\n \t  if (curtype >= 1 && !strncmp (enc - 1, \"nr\", 2))\n \t    strncpy (enc - 1, \"rn\", 2);\n@@ -10810,7 +10810,7 @@ objc_v2_encode_prop_attr (tree property)\n     }\n \n   if (PROPERTY_DYNAMIC (property))\n-    obstack_grow (&util_obstack, \",D\", 2);    \n+    obstack_grow (&util_obstack, \",D\", 2);\n \n   if (PROPERTY_NONATOMIC (property))\n     obstack_grow (&util_obstack, \",N\", 2);"}, {"sha": "30c74c58f71ca912b3324fd1e4c431c3cbf29b64", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=944fb7998bc4f4d47fa84fda494421da7669d085", "patch": "@@ -129,7 +129,7 @@ typedef enum objc_property_assign_semantics {\n /* PROPERTY_REF_PROPERTY_DECL is the PROPERTY_DECL for the property\n    used in the expression.  From it, you can get the property type,\n    and the getter/setter names.  This PROPERTY_DECL could be artificial\n-   if we are processing an 'object.component' syntax with no matching \n+   if we are processing an 'object.component' syntax with no matching\n    declared property.  */\n #define PROPERTY_REF_PROPERTY_DECL(NODE) TREE_OPERAND (PROPERTY_REF_CHECK (NODE), 1)\n \n@@ -524,9 +524,9 @@ extern GTY(()) tree objc_global_trees[OCTI_MAX];\n #define objc_setjmp_decl\tobjc_global_trees[OCTI_SETJMP_DECL]\n #define objc_stack_exception_data\t\t\\\n \t\t\t\tobjc_global_trees[OCTI_STACK_EXCEPTION_DATA_DECL]\n-#define objc_caught_exception\tobjc_global_trees[OCTI_LOCAL_EXCEPTION_DECL]\t\n-#define objc_rethrow_exception\tobjc_global_trees[OCTI_RETHROW_EXCEPTION_DECL]\t\n-#define objc_eval_once\t\tobjc_global_trees[OCTI_EVAL_ONCE_DECL]\t\n+#define objc_caught_exception\tobjc_global_trees[OCTI_LOCAL_EXCEPTION_DECL]\n+#define objc_rethrow_exception\tobjc_global_trees[OCTI_RETHROW_EXCEPTION_DECL]\n+#define objc_eval_once\t\tobjc_global_trees[OCTI_EVAL_ONCE_DECL]\n #define objc_catch_type\t\tobjc_global_trees[OCTI_CATCH_TYPE]\n \n #define execclass_decl\t\tobjc_global_trees[OCTI_EXECCLASS_DECL]\n@@ -643,7 +643,7 @@ typedef enum string_section\n #define METHOD_REF\t\t\t1\n \n /* (Decide if these can ever be validly changed.) */\n-#define OBJC_ENCODE_INLINE_DEFS \t0\n+#define OBJC_ENCODE_INLINE_DEFS\t\t0\n #define OBJC_ENCODE_DONT_INLINE_DEFS\t1\n \n #define BUFSIZE\t\t\t\t1024\n@@ -668,7 +668,7 @@ typedef enum string_section\n #define OBJC_VOID_AT_END\t\tvoid_list_node\n \n /* Exception handling constructs.  We begin by having the parser do most\n-   of the work and passing us blocks.  \n+   of the work and passing us blocks.\n    This allows us to handle different exceptions implementations.  */\n \n /* Stack of open try blocks.  */\n@@ -706,7 +706,7 @@ struct objc_try_context\n    than making them externs.  */\n \n extern tree objc_create_temporary_var (tree, const char *);\n-  \n+\n #define objc_is_object_id(TYPE) (OBJC_TYPE_NAME (TYPE) == objc_object_id)\n #define objc_is_class_id(TYPE) (OBJC_TYPE_NAME (TYPE) == objc_class_id)\n "}, {"sha": "fdeebea18c43d42c1c9c62eff1f00d77bd037fb0", "filename": "gcc/objc/objc-gnu-runtime-abi-01.c", "status": "modified", "additions": 79, "deletions": 79, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-gnu-runtime-abi-01.c?ref=944fb7998bc4f4d47fa84fda494421da7669d085", "patch": "@@ -71,10 +71,10 @@ along with GCC; see the file COPYING3.  If not see\n \n /* This macro provides a method of removing ambiguity between runtimes\n    when LTO is in use on targets supporting multiple runtimes.\n-   \n+\n    For example, at present, any target that includes an implementation of\n    the NeXT runtime needs to place Objective-C meta-data into specific\n-   named sections.  This should _not_ be done for the GNU runtime, and the \n+   named sections.  This should _not_ be done for the GNU runtime, and the\n    folowing macro is used to attach Objective-C private attributes that may\n    be used to identify the runtime for which the meta-data are intended.  */\n \n@@ -120,7 +120,7 @@ static tree begin_catch (struct objc_try_context **, tree, tree, tree, bool);\n static void finish_catch (struct objc_try_context **, tree);\n static tree finish_try_stmt (struct objc_try_context **);\n \n-bool \n+bool\n objc_gnu_runtime_abi_01_init (objc_runtime_hooks *rthooks)\n {\n   /* GNU runtime does not need the compiler to change code in order to do GC. */\n@@ -265,14 +265,14 @@ static void gnu_runtime_01_initialize (void)\n \t\t\t    NULL, NULL_TREE);\n \n   /* id objc_getMetaClass (const char *); */\n-  objc_get_meta_class_decl = add_builtin_function (TAG_GETMETACLASS, type, \n+  objc_get_meta_class_decl = add_builtin_function (TAG_GETMETACLASS, type,\n \t\t\t\t\t\t   0, NOT_BUILT_IN, NULL,\n \t\t\t\t\t\t   NULL_TREE);\n \n   /* static SEL _OBJC_SELECTOR_TABLE[]; */\n   build_selector_table_decl ();\n-  \n-  /* Stuff for properties.  \n+\n+  /* Stuff for properties.\n      The codegen relies on this being NULL for GNU.  */\n   objc_copyStruct_decl = NULL_TREE;\n \n@@ -281,28 +281,28 @@ static void gnu_runtime_01_initialize (void)\n   type = build_function_type_list (void_type_node,\n \t\t\t\t   ptr_type_node,\n \t\t\t\t   const_ptr_type_node,\n-\t\t\t\t   ptrdiff_type_node,       \n+\t\t\t\t   ptrdiff_type_node,\n \t\t\t\t   boolean_type_node,\n \t\t\t\t   boolean_type_node,\n \t\t\t\t   NULL_TREE);\n \n   /* Declare the following function:\n \t void\n-\t objc_getPropertyStruct (void *destination, const void *source, \n+\t objc_getPropertyStruct (void *destination, const void *source,\n                                  ptrdiff_t size, BOOL is_atomic, BOOL has_strong);  */\n   objc_getPropertyStruct_decl = add_builtin_function (\"objc_getPropertyStruct\",\n \t\t\t\t\t\t\t  type, 0, NOT_BUILT_IN,\n \t\t\t\t\t\t\t  NULL, NULL_TREE);\n   TREE_NOTHROW (objc_getPropertyStruct_decl) = 0;\n   /* Declare the following function:\n \t void\n-\t objc_setPropertyStruct (void *destination, const void *source, \n+\t objc_setPropertyStruct (void *destination, const void *source,\n \t                         ptrdiff_t size, BOOL is_atomic, BOOL has_strong);  */\n   objc_setPropertyStruct_decl = add_builtin_function (\"objc_setPropertyStruct\",\n \t\t\t\t\t\t\t  type, 0, NOT_BUILT_IN,\n \t\t\t\t\t\t\t  NULL, NULL_TREE);\n   TREE_NOTHROW (objc_setPropertyStruct_decl) = 0;\n-  \n+\n   using_eh_for_cleanups ();\n   lang_hooks.eh_runtime_type = objc_eh_runtime_type;\n   lang_hooks.eh_personality = objc_eh_personality;\n@@ -391,7 +391,7 @@ build_class_template (void)\n   /* struct objc_class *sibling_class; */\n   ptype = build_pointer_type (objc_class_template);\n   add_field_decl (ptype, \"sibling_class\", &chain);\n- \n+\n   /* struct _objc_protocol **protocol_list; */\n   ptype = build_pointer_type (build_pointer_type\n \t\t\t      (xref_tag (RECORD_TYPE,\n@@ -504,7 +504,7 @@ gnu_runtime_abi_01_class_decl (tree klass)\n {\n   tree decl;\n   char buf[BUFSIZE];\n-  snprintf (buf, BUFSIZE, \"_OBJC_Class_%s\", \n+  snprintf (buf, BUFSIZE, \"_OBJC_Class_%s\",\n \t    IDENTIFIER_POINTER (CLASS_NAME (klass)));\n   decl = start_var_decl (objc_class_template, buf);\n   OBJCMETA (decl, objc_meta, meta_base);\n@@ -516,7 +516,7 @@ gnu_runtime_abi_01_metaclass_decl (tree klass)\n {\n   tree decl;\n   char buf[BUFSIZE];\n-  snprintf (buf, BUFSIZE, \"_OBJC_MetaClass_%s\", \n+  snprintf (buf, BUFSIZE, \"_OBJC_MetaClass_%s\",\n \t    IDENTIFIER_POINTER (CLASS_NAME (klass)));\n   decl = start_var_decl (objc_class_template, buf);\n   OBJCMETA (decl, objc_meta, meta_base);\n@@ -528,7 +528,7 @@ gnu_runtime_abi_01_category_decl (tree klass)\n {\n   tree decl;\n   char buf[BUFSIZE];\n-  snprintf (buf, BUFSIZE, \"_OBJC_Category_%s_on_%s\", \n+  snprintf (buf, BUFSIZE, \"_OBJC_Category_%s_on_%s\",\n \t    IDENTIFIER_POINTER (CLASS_SUPER_NAME (klass)),\n \t    IDENTIFIER_POINTER (CLASS_NAME (klass)));\n   decl = start_var_decl (objc_category_template, buf);\n@@ -551,7 +551,7 @@ gnu_runtime_abi_01_protocol_decl (tree p)\n }\n \n static tree\n-gnu_runtime_abi_01_string_decl (tree type, const char *name, \n+gnu_runtime_abi_01_string_decl (tree type, const char *name,\n \t\t\t\tstring_section where ATTRIBUTE_UNUSED)\n {\n   tree decl = start_var_decl (type, name);\n@@ -568,7 +568,7 @@ gnu_runtime_abi_01_get_class_reference (tree ident)\n \n   add_class_reference (ident);\n \n-  params = build_tree_list (NULL_TREE, my_build_string_pointer \n+  params = build_tree_list (NULL_TREE, my_build_string_pointer\n \t\t\t\t\t\t(IDENTIFIER_LENGTH (ident) + 1,\n \t\t\t\t\t\t IDENTIFIER_POINTER (ident)));\n \n@@ -577,7 +577,7 @@ gnu_runtime_abi_01_get_class_reference (tree ident)\n   return build_function_call (input_location, objc_get_class_decl, params);\n }\n \n-/* Used by get_arg_type_list.  \n+/* Used by get_arg_type_list.\n    Return the types for receiver & _cmd at the start of a method argument list.\n    context is either METHOD_DEF or METHOD_REF, saying whether we are trying\n    to define a method or call one.  superflag says this is for a send to super.\n@@ -621,9 +621,9 @@ gnu_runtime_abi_01_build_typed_selector_reference (location_t loc, tree ident,\n \n   while (*chain)\n     {\n-      /* When we do a lookup for @selector () we have no idea of the \n+      /* When we do a lookup for @selector () we have no idea of the\n          prototype - so match the first we find.  */\n-      if (TREE_VALUE (*chain) == ident \n+      if (TREE_VALUE (*chain) == ident\n           && (!prototype || TREE_PURPOSE (*chain) == prototype))\n \tgoto return_at_index;\n \n@@ -633,7 +633,7 @@ gnu_runtime_abi_01_build_typed_selector_reference (location_t loc, tree ident,\n \n   *chain = tree_cons (prototype, ident, NULL_TREE);\n \n-  /* TODO: Use a vec and keep this in it to (a) avoid re-creating and \n+  /* TODO: Use a vec and keep this in it to (a) avoid re-creating and\n      (b) provide better diagnostics for the first time an undefined\n      selector is used.  */\n  return_at_index:\n@@ -657,7 +657,7 @@ build_objc_method_call (location_t loc, int super_flag, tree method_prototype,\n \t\t\ttree lookup_object, tree selector,\n \t\t\ttree method_params)\n {\n-  tree sender = (super_flag ? umsg_super_decl \n+  tree sender = (super_flag ? umsg_super_decl\n \t\t\t    : (flag_objc_direct_dispatch ? umsg_fast_decl\n \t\t\t\t\t\t\t : umsg_decl));\n   tree rcv_p = (super_flag ? objc_super_type : objc_object_type);\n@@ -673,15 +673,15 @@ build_objc_method_call (location_t loc, int super_flag, tree method_prototype,\n        ? TREE_VALUE (TREE_TYPE (method_prototype))\n        : objc_object_type);\n \n-  tree method_param_types = \n-  \t\tget_arg_type_list (method_prototype, METHOD_REF, super_flag);\n+  tree method_param_types =\n+    get_arg_type_list (method_prototype, METHOD_REF, super_flag);\n   tree ftype = build_function_type (ret_type, method_param_types);\n   tree sender_cast;\n   tree method, t;\n \n   if (method_prototype && METHOD_TYPE_ATTRIBUTES (method_prototype))\n-    ftype = build_type_attribute_variant (ftype, \n-\t\t\t\t\t  METHOD_TYPE_ATTRIBUTES \n+    ftype = build_type_attribute_variant (ftype,\n+\t\t\t\t\t  METHOD_TYPE_ATTRIBUTES\n \t\t\t\t\t  (method_prototype));\n \n   sender_cast = build_pointer_type (ftype);\n@@ -728,9 +728,9 @@ gnu_runtime_abi_01_build_objc_method_call (location_t loc,\n \t\t\t\t\t   tree method_params,\n \t\t\t\t\t   int super ATTRIBUTE_UNUSED)\n {\n-  tree selector = \n-\tgnu_runtime_abi_01_build_typed_selector_reference (loc, \n-\t\t\t\t\t\t\t  sel_name, \n+  tree selector =\n+\tgnu_runtime_abi_01_build_typed_selector_reference (loc,\n+\t\t\t\t\t\t\t  sel_name,\n \t\t\t\t\t\t\t  method_prototype);\n \n   return build_objc_method_call (loc, super, method_prototype, receiver,\n@@ -767,7 +767,7 @@ gnu_runtime_abi_01_get_protocol_reference (location_t loc, tree p)\n   /* This type is a struct containing the fields of a Protocol\n      object.  (Cfr. objc_protocol_type instead is the type of a pointer\n      to such a struct).  */\n-  protocol_struct_type = xref_tag (RECORD_TYPE, \n+  protocol_struct_type = xref_tag (RECORD_TYPE,\n \t\t\t\t   get_identifier (PROTOCOL_OBJECT_CLASS_NAME));\n \n   /* Look for the list of Protocol statically allocated instances\n@@ -797,7 +797,7 @@ gnu_runtime_abi_01_get_protocol_reference (location_t loc, tree p)\n /* For ABI 8 an IVAR is just a fixed offset in the class struct.  */\n \n static tree\n-gnu_runtime_abi_01_build_ivar_ref (location_t loc ATTRIBUTE_UNUSED, \n+gnu_runtime_abi_01_build_ivar_ref (location_t loc ATTRIBUTE_UNUSED,\n \t\t\t\t   tree base, tree id)\n {\n   return objc_build_component_ref (base, id);\n@@ -807,29 +807,29 @@ gnu_runtime_abi_01_build_ivar_ref (location_t loc ATTRIBUTE_UNUSED,\n    built for the sake of efficiency).  */\n \n static tree\n-gnu_runtime_abi_01_get_class_super_ref (location_t loc ATTRIBUTE_UNUSED, \n+gnu_runtime_abi_01_get_class_super_ref (location_t loc ATTRIBUTE_UNUSED,\n \t\t\t\t\tstruct imp_entry *imp, bool inst_meth)\n {\n   if (inst_meth)\n     {\n       if (!ucls_super_ref)\n-\tucls_super_ref = \n-\t\tobjc_build_component_ref (imp->class_decl, \n+\tucls_super_ref =\n+\t\tobjc_build_component_ref (imp->class_decl,\n \t\t\t\t\t  get_identifier (\"super_class\"));\n \treturn ucls_super_ref;\n     }\n   else\n     {\n       if (!uucls_super_ref)\n-\tuucls_super_ref = \n-\t\tobjc_build_component_ref (imp->meta_decl, \n+\tuucls_super_ref =\n+\t\tobjc_build_component_ref (imp->meta_decl,\n \t\t\t\t\t  get_identifier (\"super_class\"));\n \treturn uucls_super_ref;\n     }\n }\n \n static tree\n-gnu_runtime_abi_01_get_category_super_ref (location_t loc ATTRIBUTE_UNUSED, \n+gnu_runtime_abi_01_get_category_super_ref (location_t loc ATTRIBUTE_UNUSED,\n \t\t\t\t\t   struct imp_entry *imp, bool inst_meth)\n {\n   tree super_name = CLASS_SUPER_NAME (imp->imp_template);\n@@ -886,7 +886,7 @@ objc_add_static_instance (tree constructor, tree class_decl)\n   OBJCMETA (decl, objc_meta, meta_base);\n \n   /* We may be writing something else just now.\n-     Postpone till end of input. */ \n+     Postpone till end of input. */\n   DECL_DEFER_OUTPUT (decl) = 1;\n   pushdecl_top_level (decl);\n   rest_of_decl_compilation (decl, 1, 0);\n@@ -903,13 +903,13 @@ gnu_runtime_abi_01_build_const_string_constructor (location_t loc, tree string,\n {\n   tree constructor, fields;\n   VEC(constructor_elt,gc) *v = NULL;\n-  \n+\n   /* GNU:    (NXConstantString *) & ((__builtin_ObjCString) { NULL, string, length })  */\n   fields = TYPE_FIELDS (internal_const_str_type);\n   CONSTRUCTOR_APPEND_ELT (v, fields, build_int_cst (NULL_TREE, 0));\n \n   fields = DECL_CHAIN (fields);\n-  CONSTRUCTOR_APPEND_ELT (v, fields, build_unary_op (loc, \n+  CONSTRUCTOR_APPEND_ELT (v, fields, build_unary_op (loc,\n \t\t\t\t\t\t     ADDR_EXPR, string, 1));\n \n   fields = DECL_CHAIN (fields);\n@@ -1035,9 +1035,9 @@ handle_impent (struct imp_entry *impent)\n       {\n \tconst char *const class_name =\n \t  IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context));\n-\t\n+\n \tstring = (char *) alloca (strlen (class_name) + 30);\n-\t\n+\n \tsprintf (string, \"__objc_class_name_%s\", class_name);\n \tbreak;\n       }\n@@ -1047,10 +1047,10 @@ handle_impent (struct imp_entry *impent)\n \t  IDENTIFIER_POINTER (CLASS_NAME (impent->imp_context));\n \tconst char *const class_super_name =\n \t  IDENTIFIER_POINTER (CLASS_SUPER_NAME (impent->imp_context));\n-\t\n+\n \tstring = (char *) alloca (strlen (class_name)\n \t\t\t\t  + strlen (class_super_name) + 30);\n-\t\n+\n \t/* Do the same for categories.  Even though no references to\n \t   these symbols are generated automatically by the compiler,\n \t   it gives you a handle to pull them into an archive by\n@@ -1093,7 +1093,7 @@ build_protocol_initializer (tree type, tree protocol_name, tree protocol_list,\n \n   /* TODO: pass the loc in or find it from args.  */\n   loc = input_location;\n-  ttyp = build_pointer_type (xref_tag (RECORD_TYPE, \n+  ttyp = build_pointer_type (xref_tag (RECORD_TYPE,\n \t\t\t\t       get_identifier (UTAG_CLASS)));\n   /* Filling the \"isa\" in with a version allows the runtime system to\n      detect this ...   */\n@@ -1171,15 +1171,15 @@ generate_protocol_list (tree i_or_p, tree klass_ctxt)\n   switch (TREE_CODE (i_or_p))\n     {\n     case PROTOCOL_INTERFACE_TYPE:\n-      snprintf (buf, BUFSIZE, \"_OBJC_ProtocolRefs_%s\", \n+      snprintf (buf, BUFSIZE, \"_OBJC_ProtocolRefs_%s\",\n \t\tIDENTIFIER_POINTER (PROTOCOL_NAME (i_or_p)));\n       break;\n     case CLASS_INTERFACE_TYPE:\n-      snprintf (buf, BUFSIZE, \"_OBJC_ClassProtocols_%s\", \n+      snprintf (buf, BUFSIZE, \"_OBJC_ClassProtocols_%s\",\n \t\tIDENTIFIER_POINTER (CLASS_NAME (i_or_p)));\n       break;\n     case CATEGORY_INTERFACE_TYPE:\n-      snprintf (buf, BUFSIZE, \"_OBJC_CategoryProtocols_%s_%s\", \n+      snprintf (buf, BUFSIZE, \"_OBJC_CategoryProtocols_%s_%s\",\n \t\tIDENTIFIER_POINTER (CLASS_NAME (klass_ctxt)),\n \t\tIDENTIFIER_POINTER (CLASS_SUPER_NAME (klass_ctxt)));\n       break;\n@@ -1197,7 +1197,7 @@ generate_protocol_list (tree i_or_p, tree klass_ctxt)\n   return refs_decl;\n }\n \n-static tree \n+static tree\n generate_v1_meth_descriptor_table (tree chain, tree protocol, const char *prefix)\n {\n   tree method_list_template, initlist, decl;\n@@ -1210,18 +1210,18 @@ generate_v1_meth_descriptor_table (tree chain, tree protocol, const char *prefix\n \n   if (!objc_method_prototype_template)\n     objc_method_prototype_template = build_method_prototype_template ();\n-  \n+\n   size = list_length (chain);\n-  method_list_template = \n+  method_list_template =\n \tbuild_method_prototype_list_template (objc_method_prototype_template,\n \t\t\t\t\t      size);\n-  snprintf (buf, BUFSIZE, \"%s_%s\", prefix, \n+  snprintf (buf, BUFSIZE, \"%s_%s\", prefix,\n \t    IDENTIFIER_POINTER (PROTOCOL_NAME (protocol)));\n \n   decl = start_var_decl (method_list_template, buf);\n \n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, size));\n-  initlist = \n+  initlist =\n \tbuild_descriptor_table_initializer (objc_method_prototype_template,\n \t\t\t\t\t    chain);\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, initlist);\n@@ -1300,7 +1300,7 @@ generate_protocols (void)\n \t  nst_methods = DECL_CHAIN (nst_methods);\n \t}\n \n-      UOBJC_INSTANCE_METHODS_decl = \n+      UOBJC_INSTANCE_METHODS_decl =\n \tgenerate_v1_meth_descriptor_table (PROTOCOL_NST_METHODS (p), p,\n \t\t\t\t\t   \"_OBJC_PROTOCOL_INSTANCE_METHODS\");\n \n@@ -1315,7 +1315,7 @@ generate_protocols (void)\n \t  cls_methods = DECL_CHAIN (cls_methods);\n \t}\n \n-      UOBJC_CLASS_METHODS_decl = \n+      UOBJC_CLASS_METHODS_decl =\n \tgenerate_v1_meth_descriptor_table (PROTOCOL_CLS_METHODS (p), p,\n \t\t\t\t\t   \"_OBJC_PROTOCOL_CLASS_METHODS\");\n /*      generate_method_descriptors (p);*/\n@@ -1363,7 +1363,7 @@ generate_dispatch_table (tree chain, const char *name)\n   decl = start_var_decl (method_list_template, name);\n \n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, integer_zero_node);\n-  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n \t\t\t  build_int_cst (integer_type_node, size));\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, initlist);\n \n@@ -1515,24 +1515,24 @@ build_shared_structure_initializer (tree type, tree isa, tree super,\n \n   /* objc_ivar_list = */\n   if (!ivar_list)\n-    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n \t\t\t    build_int_cst (objc_ivar_list_ptr, 0));\n   else\n     {\n       expr = convert (objc_ivar_list_ptr,\n-\t\t      build_unary_op (input_location, ADDR_EXPR, \n+\t\t      build_unary_op (input_location, ADDR_EXPR,\n \t\t\t\t      ivar_list, 0));\n       CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n     }\n \n   /* objc_method_list = */\n   if (!dispatch_table)\n-    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n \t\t\t   convert (objc_method_list_ptr, null_pointer_node));\n   else\n     {\n       expr = convert (objc_method_list_ptr,\n-\t\t      build_unary_op (input_location, ADDR_EXPR, \n+\t\t      build_unary_op (input_location, ADDR_EXPR,\n \t\t\t\t      dispatch_table, 0));\n       CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n     }\n@@ -1564,7 +1564,7 @@ build_shared_structure_initializer (tree type, tree isa, tree super,\n   else\n     {\n       expr = convert (ltyp,\n-\t\t      build_unary_op (input_location, ADDR_EXPR, \n+\t\t      build_unary_op (input_location, ADDR_EXPR,\n \t\t\t\t      protocol_list, 0));\n       CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n     }\n@@ -1627,14 +1627,14 @@ generate_class_structures (struct imp_entry *impent)\n   location_t loc;\n   char buf[BUFSIZE];\n   int cls_flags = 0 ;\n-  \n+\n /*  objc_implementation_context = impent->imp_context;\n   implementation_template = impent->imp_template;*/\n   class_decl = impent->class_decl;\n   meta_decl = impent->meta_decl;\n /*  UOBJC_CLASS_decl = impent->class_decl;\n   UOBJC_METACLASS_decl = impent->meta_decl;*/\n-  \n+\n   loc = DECL_SOURCE_LOCATION (impent->class_decl);\n \n   my_super_id = CLASS_SUPER_NAME (impent->imp_template);\n@@ -1670,7 +1670,7 @@ generate_class_structures (struct imp_entry *impent)\n     super_expr = add_objc_string (my_super_id, class_names);\n   else\n     super_expr = null_pointer_node;\n-    \n+\n   super_expr = build_c_cast (loc, cast_type, super_expr);\n \n   root_expr = add_objc_string (my_root_id, class_names);\n@@ -1703,11 +1703,11 @@ generate_class_structures (struct imp_entry *impent)\n \n   /* static struct objc_class _OBJC_METACLASS_Foo = { ... }; */\n \n-  initlist = \n-\tbuild_shared_structure_initializer \n+  initlist =\n+\tbuild_shared_structure_initializer\n \t\t\t(TREE_TYPE (meta_decl),\n \t\t\troot_expr, super_expr, name_expr,\n-\t\t\tconvert (integer_type_node, \n+\t\t\tconvert (integer_type_node,\n \t\t\t\tTYPE_SIZE_UNIT (objc_class_template)),\n \t\t\tCLS_META, class_methods, class_ivars,\n \t\t\tprotocol_decl);\n@@ -1731,8 +1731,8 @@ generate_class_structures (struct imp_entry *impent)\n       inst_ivars = generate_ivars_list (chain, buf);\n     }\n \n-  initlist = \n-\tbuild_shared_structure_initializer \n+  initlist =\n+\tbuild_shared_structure_initializer\n \t\t(TREE_TYPE (class_decl),\n \t\tbuild_unary_op (loc, ADDR_EXPR, meta_decl, 0),\n \t\tsuper_expr, name_expr,\n@@ -1777,7 +1777,7 @@ handle_class_ref (tree chain)\n   DECL_READ_P (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_INITIAL (decl) = error_mark_node;\n- \n+\n   /* We must force the reference.  */\n   DECL_PRESERVE_P (decl) = 1;\n \n@@ -1831,7 +1831,7 @@ build_gnu_selector_translation_table (void)\n       CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n       CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, encoding);\n       expr = objc_build_constructor (objc_selector_template, v);\n-      \n+\n       CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, expr);\n     } /* each element in the chain */\n \n@@ -1880,7 +1880,7 @@ generate_static_references (void)\n       klass = TREE_VALUE (cl_chain);\n       class_name = get_objc_string_decl (OBJC_TYPE_NAME (klass), class_names);\n       CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n-\t\t\t      build_unary_op (input_location, \n+\t\t\t      build_unary_op (input_location,\n \t\t\t\t\t      ADDR_EXPR, class_name, 1));\n \n       /* Output {..., instance, ...}.  */\n@@ -2019,20 +2019,20 @@ init_objc_symtab (tree type)\n \n   ltyp = build_pointer_type (objc_selector_type);\n   if (sel_ref_chain)\n-    expr = convert (ltyp, build_unary_op (loc, ADDR_EXPR, \n+    expr = convert (ltyp, build_unary_op (loc, ADDR_EXPR,\n \t\t\t\t\t  UOBJC_SELECTOR_TABLE_decl, 1));\n   else\n     expr = convert (ltyp, null_pointer_node);\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n \n   /* cls_def_cnt = { ..., 5, ... } */\n \n-  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n \t\t\t  build_int_cst (short_integer_type_node, imp_count));\n \n   /* cat_def_cnt = { ..., 5, ... } */\n \n-  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n \t\t\t  build_int_cst (short_integer_type_node, cat_count));\n \n   /* cls_def = { ..., { &Foo, &Bar, ...}, ... } */\n@@ -2110,7 +2110,7 @@ objc_generate_v1_gnu_metadata (void)\n     {\n       /* Make sure that the meta-data are identified as being\n \t GNU-runtime.  */\n-      build_module_descriptor (OBJC_VERSION, \n+      build_module_descriptor (OBJC_VERSION,\n \t\t\t       build_tree_list (objc_meta, meta_base));\n       build_module_initializer_routine ();\n     }\n@@ -2156,7 +2156,7 @@ objc_eh_runtime_type (tree type)\n   if (POINTER_TYPE_P (type) && objc_is_object_id (TREE_TYPE (type)))\n     /* We don't want to identify 'id' for GNU. Instead, build a 0\n        entry in the exceptions table.  */\n-    return null_pointer_node; \n+    return null_pointer_node;\n \n   if (!POINTER_TYPE_P (type) || !TYPED_OBJECT (TREE_TYPE (type)))\n     {\n@@ -2229,7 +2229,7 @@ objc_build_exc_ptr (struct objc_try_context **x ATTRIBUTE_UNUSED)\n   return fold_convert (objc_object_type, t);\n }\n \n-static tree \n+static tree\n begin_catch (struct objc_try_context **cur_try_context, tree type,\n \t     tree decl, tree compound, bool ellipsis ATTRIBUTE_UNUSED)\n {\n@@ -2248,13 +2248,13 @@ begin_catch (struct objc_try_context **cur_try_context, tree type,\n   return build2 (MODIFY_EXPR, void_type_node, decl, t);\n }\n \n-static void \n+static void\n finish_catch (struct objc_try_context **cur_try_context, tree current_catch)\n {\n   append_to_statement_list (current_catch, &((*cur_try_context)->catch_list));\n }\n \n-static tree \n+static tree\n finish_try_stmt (struct objc_try_context **cur_try_context)\n {\n   struct objc_try_context *c = *cur_try_context;"}, {"sha": "b1bbb9e1fc0a8cc2293a22c8885375d9c79f5653", "filename": "gcc/objc/objc-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-lang.c?ref=944fb7998bc4f4d47fa84fda494421da7669d085", "patch": "@@ -46,7 +46,7 @@ enum c_language_kind c_language = clk_objc;\n #define LANG_HOOKS_INIT objc_init\n #undef LANG_HOOKS_DECL_PRINTABLE_NAME\n #define LANG_HOOKS_DECL_PRINTABLE_NAME objc_printable_name\n-#undef LANG_HOOKS_GIMPLIFY_EXPR \n+#undef LANG_HOOKS_GIMPLIFY_EXPR\n #define LANG_HOOKS_GIMPLIFY_EXPR objc_gimplify_expr\n #undef LANG_HOOKS_INIT_TS\n #define LANG_HOOKS_INIT_TS objc_common_init_ts"}, {"sha": "c43ab184cfb10608ced28127c14a6c7c1edfbcd0", "filename": "gcc/objc/objc-next-metadata-tags.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-next-metadata-tags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-next-metadata-tags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-metadata-tags.h?ref=944fb7998bc4f4d47fa84fda494421da7669d085", "patch": "@@ -1,6 +1,6 @@\n /* Declarations for meta-data attribute tags.\n    Copyright (C) 2011 Free Software Foundation, Inc.\n-   Contributed by Iain Sandoe \n+   Contributed by Iain Sandoe\n \n This file is part of GCC.\n \n@@ -25,29 +25,29 @@ enum objc_runtime_tree_index\n {\n   OCTI_RT_OBJC_META,\n   OCTI_RT_META_BASE,\n-  \n+\n   OCTI_RT_META_CLASS,\n   OCTI_RT_META_METACLASS,\n   OCTI_RT_META_CATEGORY,\n   OCTI_RT_META_PROTOCOL,\n-  \n+\n   OCTI_RT_META_CLASS_CLS_VARS,\n   OCTI_RT_META_CLASS_NST_VARS,\n-  \n+\n   OCTI_RT_META_CLASS_CLS_METH,\n   OCTI_RT_META_CLASS_NST_METH,\n   OCTI_RT_META_CATEG_CLS_METH,\n   OCTI_RT_META_CATEG_NST_METH,\n   OCTI_RT_META_PROTO_CLS_METH,\n   OCTI_RT_META_PROTO_NST_METH,\n-  \n+\n   OCTI_RT_META_CLASS_PROT,\n   OCTI_RT_META_CATEG_PROT,\n   OCTI_RT_META_PROT_REFS,\n-  \n+\n   OCTI_RT_META_MSG_REFS,\n   OCTI_RT_META_SEL_REFS,\n-  \n+\n   OCTI_RT_META_CLSLST_REFS,\n   OCTI_RT_META_CLASS_REF,\n   OCTI_RT_META_SUPER_REF,\n@@ -56,34 +56,34 @@ enum objc_runtime_tree_index\n   OCTI_RT_META_LAB_PROTOLIST,\n   OCTI_RT_META_LAB_NLZY_CAT,\n   OCTI_RT_META_LAB_CAT,\n-  \n+\n   OCTI_RT_META_PROPERTY_LIST,\n   OCTI_RT_META_PROTOCOL_EXT,\n   OCTI_RT_META_CLASS_EXT,\n-  \n+\n   OCTI_RT_META_CLASS_NAME,\n   OCTI_RT_META_METHD_NAME,\n   OCTI_RT_META_METHD_TYPE,\n   OCTI_RT_META_PROPN_ATTR,\n-  \n+\n   OCTI_RT_META_MODULES,\n   OCTI_RT_META_SYMTAB,\n   OCTI_RT_META_INFO,\n-  \n+\n   OCTI_RT_META_EHTYPE,\n-  \n+\n   OCTI_RT_META_CONST_STR,\n \n   OCTI_RT_META_MAX\n };\n \n /* Tags for the META data so that the backend can put them in the correct\n-   sections for targets/runtimes (Darwin/NeXT) that require this.  \n+   sections for targets/runtimes (Darwin/NeXT) that require this.\n    This information also survives LTO - which might produce mixed language\n    output.  */\n \n /* Objective-C meta data attribute tag */\n-#define objc_meta\tobjc_rt_trees[OCTI_RT_OBJC_META] \n+#define objc_meta\tobjc_rt_trees[OCTI_RT_OBJC_META]\n /* Attribute values, base = default section. */\n #define meta_base\tobjc_rt_trees[OCTI_RT_META_BASE]\n "}, {"sha": "4fb2a38541fe8725490c7d05b167a15501d3846b", "filename": "gcc/objc/objc-next-runtime-abi-01.c", "status": "modified", "additions": 97, "deletions": 97, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c?ref=944fb7998bc4f4d47fa84fda494421da7669d085", "patch": "@@ -140,13 +140,13 @@ static tree begin_catch (struct objc_try_context **, tree, tree, tree, bool);\n static void finish_catch (struct objc_try_context **, tree);\n static tree finish_try_stmt (struct objc_try_context **);\n \n-bool \n+bool\n objc_next_runtime_abi_01_init (objc_runtime_hooks *rthooks)\n {\n-  if (flag_objc_exceptions \n+  if (flag_objc_exceptions\n       && !flag_objc_sjlj_exceptions)\n     {\n-      warning_at (UNKNOWN_LOCATION, OPT_Wall, \n+      warning_at (UNKNOWN_LOCATION, OPT_Wall,\n \t\t\"%<-fobjc-sjlj-exceptions%> is the only supported exceptions \"\n \t\t\"system for %<-fnext-runtime%> with %<-fobjc-abi-version%> < 2\");\n     }\n@@ -192,7 +192,7 @@ objc_next_runtime_abi_01_init (objc_runtime_hooks *rthooks)\n    given variable, since each type is expected (by the runtime) to be\n    found in a specific named section.  The solution must be usable\n    with LTO.\n-   \n+\n    The scheme used for NeXT ABI 0/1 (partial matching of variable\n    names) is not satisfactory for LTO & ABI-2.  We now tag ObjC\n    meta-data with identification attributes in the front end.  The\n@@ -233,15 +233,15 @@ next_runtime_abi_01_init_metadata_attributes (void)\n   meta_meth_name = get_identifier (\"V1_METN\");\n   meta_meth_type = get_identifier (\"V1_METT\");\n   meta_prop_name_attr = get_identifier (\"V1_STRG\");\n-  \n+\n   meta_modules = get_identifier (\"V1_MODU\");\n   meta_symtab = get_identifier (\"V1_SYMT\");\n   meta_info = get_identifier (\"V1_INFO\");\n-  \n+\n   meta_proplist = get_identifier (\"V1_PLST\");\n   meta_protocol_extension = get_identifier (\"V1_PEXT\");\n   meta_class_extension = get_identifier (\"V1_CEXT\");\n-  \n+\n   meta_const_str = get_identifier (\"V1_CSTR\");\n }\n \n@@ -366,13 +366,13 @@ static void next_runtime_01_initialize (void)\n   type = build_function_type_list (void_type_node,\n \t\t\t\t   ptr_type_node,\n \t\t\t\t   const_ptr_type_node,\n-\t\t\t\t   ptrdiff_type_node,       \n+\t\t\t\t   ptrdiff_type_node,\n \t\t\t\t   boolean_type_node,\n \t\t\t\t   boolean_type_node,\n \t\t\t\t   NULL_TREE);\n   /* Declare the following function:\n \t void\n-         objc_copyStruct (void *destination, const void *source, \n+         objc_copyStruct (void *destination, const void *source,\n \t                  ptrdiff_t size, BOOL is_atomic, BOOL has_strong); */\n   objc_copyStruct_decl = add_builtin_function (\"objc_copyStruct\",\n \t\t\t\t\t\t   type, 0, NOT_BUILT_IN,\n@@ -390,7 +390,7 @@ static void next_runtime_01_initialize (void)\n \n /* --- templates --- */\n \n-/* struct _objc_class \n+/* struct _objc_class\n    {\n      struct _objc_class *isa;\n      struct _objc_class *super_class;\n@@ -520,11 +520,11 @@ build_v1_category_template (void)\n   if (flag_objc_abi >= 1)\n     {\n       add_field_decl (integer_type_node, \"size\", &chain);\n- \n+\n       /* struct _objc_property_list *instance_properties;\n          This field describes a category's @property declarations.\n          Properties from inherited protocols are not included.  */\n-      ptype = build_pointer_type (xref_tag (RECORD_TYPE, \n+      ptype = build_pointer_type (xref_tag (RECORD_TYPE,\n \t\t\t\t\t    get_identifier (UTAG_PROPERTY_LIST)));\n       add_field_decl (ptype, \"instance_properties\", &chain);\n     }\n@@ -540,7 +540,7 @@ build_v1_category_template (void)\n      struct _objc_protocol_extension *isa;\n    #else\n      struct _objc_class *isa;\n-   #endif \n+   #endif\n \n      char *protocol_name;\n      struct _objc_protocol **protocol_list;\n@@ -597,7 +597,7 @@ next_runtime_abi_01_class_decl (tree klass)\n {\n   tree decl;\n   char buf[BUFSIZE];\n-  snprintf (buf, BUFSIZE, \"_OBJC_Class_%s\", \n+  snprintf (buf, BUFSIZE, \"_OBJC_Class_%s\",\n \t    IDENTIFIER_POINTER (CLASS_NAME (klass)));\n   decl = start_var_decl (objc_class_template, buf);\n   OBJCMETA (decl, objc_meta, meta_class);\n@@ -609,7 +609,7 @@ next_runtime_abi_01_metaclass_decl (tree klass)\n {\n   tree decl;\n   char buf[BUFSIZE];\n-  snprintf (buf, BUFSIZE, \"_OBJC_MetaClass_%s\", \n+  snprintf (buf, BUFSIZE, \"_OBJC_MetaClass_%s\",\n \t    IDENTIFIER_POINTER (CLASS_NAME (klass)));\n   decl = start_var_decl (objc_class_template, buf);\n   OBJCMETA (decl, objc_meta, meta_metaclass);\n@@ -621,7 +621,7 @@ next_runtime_abi_01_category_decl (tree klass)\n {\n   tree decl;\n   char buf[BUFSIZE];\n-  snprintf (buf, BUFSIZE, \"_OBJC_Category_%s_on_%s\", \n+  snprintf (buf, BUFSIZE, \"_OBJC_Category_%s_on_%s\",\n \t    IDENTIFIER_POINTER (CLASS_SUPER_NAME (klass)),\n \t    IDENTIFIER_POINTER (CLASS_NAME (klass)));\n   decl = start_var_decl (objc_category_template, buf);\n@@ -662,7 +662,7 @@ next_runtime_abi_01_string_decl (tree type, const char *name,  string_section wh\n       case prop_names_attr:\n \tOBJCMETA (var, objc_meta, meta_prop_name_attr);\n \tbreak;\n-      default: \n+      default:\n \tOBJCMETA (var, objc_meta, meta_base);\n \tbreak;\n     }\n@@ -721,7 +721,7 @@ next_runtime_abi_01_get_class_reference (tree ident)\n     }\n }\n \n-/* Used by get_arg_type_list.  \n+/* Used by get_arg_type_list.\n    Return the types for receiver & _cmd at the start of a method argument list.\n    context is either METHOD_DEF or METHOD_REF, saying whether we are trying\n    to define a method or call one.  superflag says this is for a send to super.\n@@ -771,7 +771,7 @@ build_selector_reference_decl (tree ident)\n   t = buf;\n   while (*t)\n     {\n-      if (*t==':') \n+      if (*t==':')\n         *t = '$'; /* Underscore would clash between foo:bar and foo_bar.  */\n       t++;\n     }\n@@ -829,13 +829,13 @@ build_objc_method_call (location_t loc, int super_flag, tree method_prototype,\n        ? TREE_VALUE (TREE_TYPE (method_prototype))\n        : objc_object_type);\n \n-  tree method_param_types = \n-  \t\tget_arg_type_list (method_prototype, METHOD_REF, super_flag);\n+  tree method_param_types =\n+    get_arg_type_list (method_prototype, METHOD_REF, super_flag);\n   tree ftype = build_function_type (ret_type, method_param_types);\n \n   if (method_prototype && METHOD_TYPE_ATTRIBUTES (method_prototype))\n-    ftype = build_type_attribute_variant (ftype, \n-\t\t\t\t\t  METHOD_TYPE_ATTRIBUTES \n+    ftype = build_type_attribute_variant (ftype,\n+\t\t\t\t\t  METHOD_TYPE_ATTRIBUTES\n \t\t\t\t\t  (method_prototype));\n \n   sender_cast = build_pointer_type (ftype);\n@@ -858,11 +858,11 @@ build_objc_method_call (location_t loc, int super_flag, tree method_prototype,\n \t  || TREE_CODE (ret_type) == UNION_TYPE)\n       && targetm.calls.return_in_memory (ret_type, 0))\n     sender = (super_flag ? umsg_super_stret_decl\n-\t\t\t : flag_nil_receivers ? umsg_stret_decl \n+\t\t\t : flag_nil_receivers ? umsg_stret_decl\n \t\t\t\t\t      : umsg_nonnil_stret_decl);\n   else\n-    sender = (super_flag ? umsg_super_decl \n-\t\t\t : (flag_nil_receivers  ? (flag_objc_direct_dispatch \n+    sender = (super_flag ? umsg_super_decl\n+\t\t\t : (flag_nil_receivers  ? (flag_objc_direct_dispatch\n \t\t\t\t\t\t\t? umsg_fast_decl\n \t\t\t\t\t\t\t: umsg_decl)\n \t\t\t\t\t\t: umsg_nonnil_decl));\n@@ -878,7 +878,7 @@ build_objc_method_call (location_t loc, int super_flag, tree method_prototype,\n       VEC_quick_push (tree, parms, TREE_VALUE (method_params));\n \n   /* Build an obj_type_ref, with the correct cast for the method call.  */\n-  t = build3 (OBJ_TYPE_REF, sender_cast, method, \n+  t = build3 (OBJ_TYPE_REF, sender_cast, method,\n \t\t\t    lookup_object, size_zero_node);\n   t = build_function_call_vec (loc, t, parms, NULL);\n   VEC_free (tree, gc, parms);\n@@ -916,7 +916,7 @@ next_runtime_abi_01_get_protocol_reference (location_t loc, tree p)\n /* For ABI 0/1 and IVAR is just a fixed offset in the class struct.  */\n \n static tree\n-next_runtime_abi_01_build_ivar_ref (location_t loc ATTRIBUTE_UNUSED, \n+next_runtime_abi_01_build_ivar_ref (location_t loc ATTRIBUTE_UNUSED,\n \t\t\t\t   tree base, tree id)\n {\n   return objc_build_component_ref (base, id);\n@@ -932,23 +932,23 @@ next_runtime_abi_01_get_class_super_ref (location_t loc ATTRIBUTE_UNUSED,\n   if (inst_meth)\n     {\n       if (!ucls_super_ref)\n-\tucls_super_ref = \n-\t\tobjc_build_component_ref (imp->class_decl, \n+\tucls_super_ref =\n+\t\tobjc_build_component_ref (imp->class_decl,\n \t\t\t\t\t  get_identifier (\"super_class\"));\n \treturn ucls_super_ref;\n     }\n   else\n     {\n       if (!uucls_super_ref)\n-\tuucls_super_ref = \n-\t\tobjc_build_component_ref (imp->meta_decl, \n+\tuucls_super_ref =\n+\t\tobjc_build_component_ref (imp->meta_decl,\n \t\t\t\t\t  get_identifier (\"super_class\"));\n \treturn uucls_super_ref;\n     }\n }\n \n static tree\n-next_runtime_abi_01_get_category_super_ref (location_t loc ATTRIBUTE_UNUSED, \n+next_runtime_abi_01_get_category_super_ref (location_t loc ATTRIBUTE_UNUSED,\n \t\t\t\t\t   struct imp_entry *imp, bool inst_meth)\n {\n   tree super_name = CLASS_SUPER_NAME (imp->imp_template);\n@@ -959,16 +959,16 @@ next_runtime_abi_01_get_category_super_ref (location_t loc ATTRIBUTE_UNUSED,\n       super_class = objc_get_class_reference (super_name);\n \n       if (!inst_meth)\n-\t\n+\n \t/* If we are in a class method, we must retrieve the\n \t   _metaclass_ for the current class, pointed at by\n \t   the class's \"isa\" pointer.  The following assumes that\n \t   \"isa\" is the first ivar in a class (which it must be).  */\n-\t   super_class = \n+\t   super_class =\n \t\tbuild_indirect_ref (input_location,\n \t\t\t\t    build_c_cast (input_location,\n \t\t\t\t\tbuild_pointer_type (objc_class_type),\n-\t\t\t\t\tsuper_class), \n+\t\t\t\t\tsuper_class),\n \t\t\t\t    RO_UNARY_STAR);\n       return super_class;\n     }\n@@ -1035,7 +1035,7 @@ next_runtime_abi_01_build_const_string_constructor (location_t loc, tree string,\n /* This routine builds the following type:\n    struct _prop_t {\n      const char * const name;\t\t\t// property name\n-     const char * const attributes;\t\t// comma-delimited, encoded, \n+     const char * const attributes;\t\t// comma-delimited, encoded,\n \t\t\t\t\t\t// property attributes\n    };\n */\n@@ -1072,12 +1072,12 @@ build_v1_property_template (void)\n \n static GTY(()) tree objc_protocol_extension_template;\n \n-static void \n+static void\n build_v1_objc_protocol_extension_template (void)\n {\n   tree decls, *chain = NULL;\n-  \n-  objc_protocol_extension_template = \n+\n+  objc_protocol_extension_template =\n \tobjc_start_struct (get_identifier (UTAG_PROTOCOL_EXT));\n \n   /*  uint32_t size; */\n@@ -1096,7 +1096,7 @@ build_v1_objc_protocol_extension_template (void)\n }\n \n /* This routine build following struct type:\n-   struct _objc_class_ext \n+   struct _objc_class_ext\n      {\n        uint32_t size;\t// sizeof(struct _objc_class_ext)\n        const char *weak_ivar_layout;\n@@ -1140,7 +1140,7 @@ build_metadata_templates (void)\n \n /* --- emit metadata --- */\n \n-static tree \n+static tree\n generate_v1_meth_descriptor_table (tree chain, tree protocol,\n \t\t\t\t   const char *prefix, tree attr)\n {\n@@ -1154,18 +1154,18 @@ generate_v1_meth_descriptor_table (tree chain, tree protocol,\n \n   if (!objc_method_prototype_template)\n     objc_method_prototype_template = build_method_prototype_template ();\n-  \n+\n   size = list_length (chain);\n-  method_list_template = \n+  method_list_template =\n \tbuild_method_prototype_list_template (objc_method_prototype_template,\n \t\t\t\t\t      size);\n-  snprintf (buf, BUFSIZE, \"%s_%s\", prefix, \n+  snprintf (buf, BUFSIZE, \"%s_%s\", prefix,\n \t    IDENTIFIER_POINTER (PROTOCOL_NAME (protocol)));\n \n   decl = start_var_decl (method_list_template, buf);\n \n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, size));\n-  initlist = \n+  initlist =\n \tbuild_descriptor_table_initializer (objc_method_prototype_template,\n \t\t\t\t\t    chain);\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, initlist);\n@@ -1180,7 +1180,7 @@ generate_v1_meth_descriptor_table (tree chain, tree protocol,\n    or NULL_TREE if none are present.  */\n \n static tree\n-generate_v1_objc_protocol_extension (tree proto_interface, \n+generate_v1_objc_protocol_extension (tree proto_interface,\n \t\t\t\t     tree opt_instance_meth,\n \t\t\t\t     tree opt_class_meth,\n \t\t\t\t     tree instance_props)\n@@ -1196,18 +1196,18 @@ generate_v1_objc_protocol_extension (tree proto_interface,\n     return NULL_TREE;\n \n   if (!objc_protocol_extension_template)\n-    build_v1_objc_protocol_extension_template ();    \n+    build_v1_objc_protocol_extension_template ();\n \n   /* uint32_t size */\n   size = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (objc_protocol_extension_template));\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, size));\n \n   /* Try for meaningful diagnostics.  */\n   loc = DECL_SOURCE_LOCATION (PROTOCOL_FORWARD_DECL (proto_interface));\n-  \n+\n   /* struct objc_method_list *optional_instance_methods; */\n   if (opt_instance_meth)\n-    expr = convert (objc_method_list_ptr, \n+    expr = convert (objc_method_list_ptr,\n \t\t    build_unary_op (loc, ADDR_EXPR, opt_instance_meth, 0));\n   else\n     expr = convert (objc_method_list_ptr, null_pointer_node);\n@@ -1216,15 +1216,15 @@ generate_v1_objc_protocol_extension (tree proto_interface,\n \n   /* struct objc_method_list *optional_class_methods; */\n   if (opt_class_meth)\n-    expr = convert (objc_method_list_ptr, \n+    expr = convert (objc_method_list_ptr,\n \t\t    build_unary_op (loc, ADDR_EXPR, opt_class_meth, 0));\n   else\n     expr = convert (objc_method_list_ptr, null_pointer_node);\n \n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n   /* struct objc_prop_list *instance_properties; */\n   if (instance_props)\n-      expr = convert (objc_prop_list_ptr, \n+      expr = convert (objc_prop_list_ptr,\n \t\t      build_unary_op (loc, ADDR_EXPR, instance_props, 0));\n   else\n     expr = convert (objc_prop_list_ptr, null_pointer_node);\n@@ -1256,7 +1256,7 @@ build_v1_property_list_template (tree list_type, int size)\n \n   /* anonymous.  */\n   property_list_t_record = objc_start_struct (NULL_TREE);\n- \n+\n   /* uint32_t const entsize */\n   decls = add_field_decl (integer_type_node, \"entsize\", &chain);\n \n@@ -1290,11 +1290,11 @@ build_v1_property_table_initializer (tree type, tree context)\n       VEC(constructor_elt,gc) *elemlist = NULL;\n       tree attribute, name_ident = PROPERTY_NAME (x);\n \n-      CONSTRUCTOR_APPEND_ELT (elemlist, NULL_TREE, \n+      CONSTRUCTOR_APPEND_ELT (elemlist, NULL_TREE,\n \t\t\t      add_objc_string (name_ident, prop_names_attr));\n \n       attribute = objc_v2_encode_prop_attr (x);\n-      CONSTRUCTOR_APPEND_ELT (elemlist, NULL_TREE, \n+      CONSTRUCTOR_APPEND_ELT (elemlist, NULL_TREE,\n \t\t\t      add_objc_string (attribute, prop_names_attr));\n \n       CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE,\n@@ -1317,7 +1317,7 @@ generate_v1_property_table (tree context, tree klass_ctxt)\n   VEC(constructor_elt,gc) *inits = NULL;\n   int init_val, size = 0;\n   char buf[BUFSIZE];\n-  \n+\n   if (context)\n     {\n       gcc_assert (TREE_CODE (context) == PROTOCOL_INTERFACE_TYPE);\n@@ -1334,10 +1334,10 @@ generate_v1_property_table (tree context, tree klass_ctxt)\n     return NULL_TREE;\n \n   if (!objc_v1_property_template)\n-    objc_v1_property_template = build_v1_property_template (); \n+    objc_v1_property_template = build_v1_property_template ();\n \n-  property_list_template = \n-\tbuild_v1_property_list_template (objc_v1_property_template, \n+  property_list_template =\n+\tbuild_v1_property_list_template (objc_v1_property_template,\n \t\t\t\t\t size);\n   initlist = build_v1_property_table_initializer (objc_v1_property_template,\n \t\t\t\t\t\t  is_proto ? context\n@@ -1411,17 +1411,17 @@ generate_v1_protocol_list (tree i_or_p, tree klass_ctxt)\n   switch (TREE_CODE (i_or_p))\n     {\n     case PROTOCOL_INTERFACE_TYPE:\n-      snprintf (buf, BUFSIZE, \"_OBJC_ProtocolRefs_%s\", \n+      snprintf (buf, BUFSIZE, \"_OBJC_ProtocolRefs_%s\",\n \t\tIDENTIFIER_POINTER (PROTOCOL_NAME (i_or_p)));\n       attr = meta_proto_ref;\n       break;\n     case CLASS_INTERFACE_TYPE:\n-      snprintf (buf, BUFSIZE, \"_OBJC_ClassProtocols_%s\", \n+      snprintf (buf, BUFSIZE, \"_OBJC_ClassProtocols_%s\",\n \t\tIDENTIFIER_POINTER (CLASS_NAME (i_or_p)));\n       attr = meta_clas_prot;\n       break;\n     case CATEGORY_INTERFACE_TYPE:\n-      snprintf (buf, BUFSIZE, \"_OBJC_CategoryProtocols_%s_%s\", \n+      snprintf (buf, BUFSIZE, \"_OBJC_CategoryProtocols_%s_%s\",\n \t\tIDENTIFIER_POINTER (CLASS_NAME (klass_ctxt)),\n \t\tIDENTIFIER_POINTER (CLASS_SUPER_NAME (klass_ctxt)));\n       attr = meta_catg_prot;\n@@ -1449,9 +1449,9 @@ build_v1_protocol_initializer (tree type, tree protocol_name, tree protocol_list\n   tree expr, ttyp;\n   location_t loc;\n   VEC(constructor_elt,gc) *inits = NULL;\n-  \n+\n   if (!objc_protocol_extension_template)\n-    build_v1_objc_protocol_extension_template ();    \n+    build_v1_objc_protocol_extension_template ();\n \n   /* TODO: find a better representation of location from the inputs.  */\n   loc = UNKNOWN_LOCATION;\n@@ -1483,7 +1483,7 @@ build_v1_protocol_initializer (tree type, tree protocol_name, tree protocol_list\n   return objc_build_constructor (type, inits);\n }\n \n-/* An updated version of generate_protocols () that emit the protocol \n+/* An updated version of generate_protocols () that emit the protocol\n    extension for ABI=1.  */\n \n /* For each protocol which was referenced either from a @protocol()\n@@ -1551,7 +1551,7 @@ generate_v1_protocols (void)\n \t  nst_methods = TREE_CHAIN (nst_methods);\n \t}\n \n-      UOBJC_INSTANCE_METHODS_decl = \n+      UOBJC_INSTANCE_METHODS_decl =\n \tgenerate_v1_meth_descriptor_table (PROTOCOL_NST_METHODS (p), p,\n \t\t\t\t\t   \"_OBJC_ProtocolInstanceMethods\",\n \t\t\t\t\t   meta_proto_nst_meth);\n@@ -1567,18 +1567,18 @@ generate_v1_protocols (void)\n \t  cls_methods = TREE_CHAIN (cls_methods);\n \t}\n \n-      UOBJC_CLASS_METHODS_decl = \n+      UOBJC_CLASS_METHODS_decl =\n \tgenerate_v1_meth_descriptor_table (PROTOCOL_CLS_METHODS (p), p,\n \t\t\t\t\t   \"_OBJC_ProtocolClassMethods\",\n \t\t\t\t\t   meta_proto_cls_meth);\n \n-      /* There should be no optional methods for ABI-0 - but we need to \n+      /* There should be no optional methods for ABI-0 - but we need to\n          check all this here before the lists are made.  */\n       nst_methods = PROTOCOL_OPTIONAL_NST_METHODS (p);\n       while (nst_methods)\n         {\n           if (! METHOD_ENCODING (nst_methods))\n-            {                     \n+            {\n               encoding = encode_method_prototype (nst_methods);\n               METHOD_ENCODING (nst_methods) = encoding;\n             }\n@@ -1591,7 +1591,7 @@ generate_v1_protocols (void)\n \t\t\t\t\t   meta_proto_nst_meth);\n \n       cls_methods = PROTOCOL_OPTIONAL_CLS_METHODS (p);\n-      while (cls_methods)                    \n+      while (cls_methods)\n         {\n           if (! METHOD_ENCODING (cls_methods))\n             {\n@@ -1602,7 +1602,7 @@ generate_v1_protocols (void)\n           cls_methods = TREE_CHAIN (cls_methods);\n         }\n \n-      V1_Protocol_OPT_CLS_METHODS_decl = \n+      V1_Protocol_OPT_CLS_METHODS_decl =\n \tgenerate_v1_meth_descriptor_table (PROTOCOL_OPTIONAL_CLS_METHODS (p), p,\n \t\t\t\t\t   \"_OBJC_OptionalProtocolClassMethods\",\n \t\t\t\t\t   meta_proto_cls_meth);\n@@ -1623,11 +1623,11 @@ generate_v1_protocols (void)\n \t\t\t     build_unary_op (loc, ADDR_EXPR, refs_decl, 0));\n       else\n         refs_expr = convert (refs_type, null_pointer_node);\n-      \n+\n       if (flag_objc_abi < 1)\n \t{\n \t  /* Original ABI.  */\n-\t  initlist = \n+\t  initlist =\n \t\tbuild_protocol_initializer (TREE_TYPE (decl),\n \t\t\t\t\t    protocol_name_expr, refs_expr,\n \t\t\t\t\t    UOBJC_INSTANCE_METHODS_decl,\n@@ -1638,13 +1638,13 @@ generate_v1_protocols (void)\n \n       /* else - V1 extensions.  */\n \n-      V1_Property_decl = \n+      V1_Property_decl =\n \t\tgenerate_v1_property_table (p, NULL_TREE);\n \n-      V1_ProtocolExt_decl = \n-\tgenerate_v1_objc_protocol_extension (p, \n+      V1_ProtocolExt_decl =\n+\tgenerate_v1_objc_protocol_extension (p,\n \t\t\t\t\t     V1_Protocol_OPT_NST_METHODS_decl,\n-\t\t\t\t\t     V1_Protocol_OPT_CLS_METHODS_decl, \n+\t\t\t\t\t     V1_Protocol_OPT_CLS_METHODS_decl,\n \t\t\t\t\t     V1_Property_decl);\n \n       initlist = build_v1_protocol_initializer (TREE_TYPE (decl),\n@@ -1676,7 +1676,7 @@ generate_dispatch_table (tree chain, const char *name, tree attr)\n   decl = start_var_decl (method_list_template, name);\n \n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, integer_zero_node);\n-  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n \t\t\t  build_int_cst (integer_type_node, size));\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, initlist);\n \n@@ -1814,7 +1814,7 @@ generate_objc_class_ext (tree property_list, tree context)\n   /* TODO: pass the loc in or find it from args.  */\n   loc = UNKNOWN_LOCATION;\n \n-  /* const char *weak_ivar_layout \n+  /* const char *weak_ivar_layout\n      TODO: Figure the ivar layouts out... */\n   weak_ivar_layout_tree = NULL_TREE;\n \n@@ -1834,7 +1834,7 @@ generate_objc_class_ext (tree property_list, tree context)\n   else\n     expr = convert (ltyp, null_pointer_node);\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n-    \n+\n   /* struct _prop_list_t *properties; */\n   ltyp = objc_prop_list_ptr;\n   if (property_list)\n@@ -1922,7 +1922,7 @@ build_v1_shared_structure_initializer (tree type, tree isa, tree super,\n     expr = convert (ltyp, null_pointer_node);\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, expr);\n \n-  ltyp = build_pointer_type (xref_tag (RECORD_TYPE, \n+  ltyp = build_pointer_type (xref_tag (RECORD_TYPE,\n \t\t\t\t\tget_identifier (\"objc_cache\")));\n   /* method_cache = */\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, convert (ltyp, null_pointer_node));\n@@ -2007,15 +2007,15 @@ generate_v1_class_structs (struct imp_entry *impent)\n   int cls_flags;\n   location_t loc;\n   char buf[BUFSIZE];\n-  \n+\n /*  objc_implementation_context = impent->imp_context;\n   implementation_template = impent->imp_template;*/\n   class_decl = impent->class_decl;\n   meta_decl = impent->meta_decl;\n   cls_flags = impent->has_cxx_cdtors ? CLS_HAS_CXX_STRUCTORS : 0 ;\n-  \n+\n   loc = DECL_SOURCE_LOCATION (impent->class_decl);\n-  \n+\n   if (flag_objc_abi >= 1)\n     {\n       /* ABI=1 additions.  */\n@@ -2089,7 +2089,7 @@ generate_v1_class_structs (struct imp_entry *impent)\n \n   /* static struct objc_class _OBJC_METACLASS_Foo = { ... }; */\n \n-  initlist = build_v1_shared_structure_initializer \n+  initlist = build_v1_shared_structure_initializer\n \t\t(TREE_TYPE (meta_decl),\n \t\troot_expr, super_expr, name_expr,\n \t\tconvert (integer_type_node, TYPE_SIZE_UNIT (objc_class_template)),\n@@ -2119,7 +2119,7 @@ generate_v1_class_structs (struct imp_entry *impent)\n \t\t(TREE_TYPE (class_decl),\n \t\tbuild_unary_op (loc, ADDR_EXPR, meta_decl, 0),\n \t\tsuper_expr, name_expr,\n-\t\tconvert (integer_type_node, \n+\t\tconvert (integer_type_node,\n \t\t\t TYPE_SIZE_UNIT (CLASS_STATIC_TEMPLATE (impent->imp_template))),\n \t\tCLS_FACTORY | cls_flags, inst_methods, inst_ivars,\n \t\tprotocol_decl, class_ext_decl);\n@@ -2225,18 +2225,18 @@ init_objc_symtab (tree type)\n \n   /* refs = { ..., _OBJC_SELECTOR_TABLE, ... } */\n \n-  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n \t\t\t  convert (build_pointer_type (objc_selector_type),\n \t\t\t\t\t\t\tinteger_zero_node));\n \n   /* cls_def_cnt = { ..., 5, ... } */\n \n-  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n \t\t\t  build_int_cst (short_integer_type_node, imp_count));\n \n   /* cat_def_cnt = { ..., 5, ... } */\n \n-  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n \t\t\t  build_int_cst (short_integer_type_node, cat_count));\n \n   /* cls_def = { ..., { &Foo, &Bar, ...}, ... } */\n@@ -2291,11 +2291,11 @@ handle_next_impent (struct imp_entry *impent)\n   switch (TREE_CODE (impent->imp_context))\n     {\n     case CLASS_IMPLEMENTATION_TYPE:\n-      snprintf (buf, BUFSIZE, \".objc_class_name_%s\", \n+      snprintf (buf, BUFSIZE, \".objc_class_name_%s\",\n \t\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)));\n       break;\n     case CATEGORY_IMPLEMENTATION_TYPE:\n-      snprintf (buf, BUFSIZE, \"*.objc_category_name_%s_%s\", \n+      snprintf (buf, BUFSIZE, \"*.objc_category_name_%s_%s\",\n \t\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)),\n \t\tIDENTIFIER_POINTER (CLASS_SUPER_NAME (impent->imp_context)));\n       break;\n@@ -2345,7 +2345,7 @@ generate_objc_image_info (void)\n        | (flag_objc_gc ? 2 : 0));\n   VEC(constructor_elt,gc) *v = NULL;\n   tree array_type;\n-  \n+\n   array_type  = build_sized_array_type (integer_type_node, 2);\n \n   decl = start_var_decl (array_type, \"_OBJC_ImageInfo\");\n@@ -2788,7 +2788,7 @@ next_sjlj_build_try_catch_finally (struct objc_try_context **ctcp)\n   /* Build the complete FINALLY statement list.  */\n   t = next_sjlj_build_try_exit (ctcp);\n   t = build_stmt (input_location, COND_EXPR,\n-\t\t  c_common_truthvalue_conversion \n+\t\t  c_common_truthvalue_conversion\n \t\t    (input_location, rethrow_decl),\n \t\t  NULL, t);\n   SET_EXPR_LOCATION (t, cur_try_context->finally_locus);\n@@ -2801,7 +2801,7 @@ next_sjlj_build_try_catch_finally (struct objc_try_context **ctcp)\n   t = build_function_call (input_location,\n \t\t\t   objc_exception_throw_decl, t);\n   t = build_stmt (input_location, COND_EXPR,\n-\t\t  c_common_truthvalue_conversion (input_location, \n+\t\t  c_common_truthvalue_conversion (input_location,\n \t\t\t\t\t\t  rethrow_decl),\n \t\t  t, NULL);\n   SET_EXPR_LOCATION (t, cur_try_context->end_finally_locus);\n@@ -2924,7 +2924,7 @@ objc_build_exc_ptr (struct objc_try_context **cur_try_context)\n     }\n }\n \n-static tree \n+static tree\n begin_catch (struct objc_try_context **cur_try_context, tree type,\n \t     tree decl, tree compound, bool ellipsis ATTRIBUTE_UNUSED)\n {\n@@ -2941,13 +2941,13 @@ begin_catch (struct objc_try_context **cur_try_context, tree type,\n   return build2 (MODIFY_EXPR, void_type_node, decl, t);\n }\n \n-static void \n+static void\n finish_catch (struct objc_try_context **cur_try_context, tree current_catch)\n {\n   append_to_statement_list (current_catch, &((*cur_try_context)->catch_list));\n }\n \n-static tree \n+static tree\n finish_try_stmt (struct objc_try_context **cur_try_context)\n {\n   tree stmt;"}, {"sha": "90660d75a98f344e560881d221286b89daeef9a5", "filename": "gcc/objc/objc-next-runtime-abi-02.c", "status": "modified", "additions": 203, "deletions": 203, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c?ref=944fb7998bc4f4d47fa84fda494421da7669d085", "patch": "@@ -21,7 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n /* The NeXT ABI2 is used for m64 implementations on Darwin/OSX machines.\n-   \n+\n    This version is intended to match (logically) the output of Apple's\n    4.2.1 compiler.  */\n \n@@ -85,7 +85,7 @@ extern char *util_firstobj;\n #define OBJC2_CLS_HAS_CXX_STRUCTORS\t0x0004L\n \n enum objc_v2_tree_index\n-{    \n+{\n   /* Templates.  */\n   OCTI_V2_CLS_TEMPL,\n   OCTI_V2_CAT_TEMPL,\n@@ -95,7 +95,7 @@ enum objc_v2_tree_index\n   OCTI_V2_IVAR_LIST_TEMPL,\n   OCTI_V2_MESSAGE_REF_TEMPL,\n   OCTI_V2_SUPER_MESSAGE_REF_TEMPL,\n-    \n+\n   OCTI_V2_MESSAGE_SELECTOR_TYPE,\n   OCTI_V2_SUPER_MESSAGE_SELECTOR_TYPE,\n   OCTI_V2_IMP_TYPE,\n@@ -105,20 +105,20 @@ enum objc_v2_tree_index\n   OCTI_V2_VTABLE_DECL,\n \n   OCTI_V2_PROPERTY_TEMPL,\n-    \n+\n   /* V2 messaging.  */\n   OCTI_V2_UMSG_FIXUP_DECL,\n   OCTI_V2_UMSG_STRET_FIXUP_DECL,\n   OCTI_V2_UMSG_ID_FIXUP_DECL,\n   OCTI_V2_UMSG_ID_STRET_FIXUP_DECL,\n   OCTI_V2_UMSG_SUPER2_FIXUP_DECL,\n   OCTI_V2_UMSG_SUPER2_STRET_FIXUP_DECL,\n-    \n+\n   /* Exceptions - related.  */\n   OCTI_V2_BEGIN_CATCH_DECL,\n   OCTI_V2_END_CATCH_DECL,\n   OCTI_V2_RETHROW_DECL,\n-  \n+\n   OCTI_V2_MAX\n };\n \n@@ -132,21 +132,21 @@ enum objc_v2_tree_index\n \n /* struct message_ref_t */\n #define objc_v2_message_ref_template \\\n-\t\t\t\tobjc_v2_global_trees[OCTI_V2_MESSAGE_REF_TEMPL]      \n+\t\t\t\tobjc_v2_global_trees[OCTI_V2_MESSAGE_REF_TEMPL]\n \n #define objc_v2_ivar_list_ptr\tobjc_v2_global_trees[OCTI_V2_IVAR_LIST_TEMPL]\n \n /* struct super_message_ref_t */\n #define objc_v2_super_message_ref_template \\\n-\t\t\t\tobjc_v2_global_trees[OCTI_V2_SUPER_MESSAGE_REF_TEMPL]      \n+\t\t\t\tobjc_v2_global_trees[OCTI_V2_SUPER_MESSAGE_REF_TEMPL]\n \n /* struct message_ref_t* */\n-#define objc_v2_selector_type\tobjc_v2_global_trees[OCTI_V2_MESSAGE_SELECTOR_TYPE]\t\n+#define objc_v2_selector_type\tobjc_v2_global_trees[OCTI_V2_MESSAGE_SELECTOR_TYPE]\n /* struct super_super_message_ref_t */\n #define objc_v2_super_selector_type \\\n-\t\t\t\tobjc_v2_global_trees[OCTI_V2_SUPER_MESSAGE_SELECTOR_TYPE]\t\n+\t\t\t\tobjc_v2_global_trees[OCTI_V2_SUPER_MESSAGE_SELECTOR_TYPE]\n #define objc_v2_imp_type\tobjc_v2_global_trees[OCTI_V2_IMP_TYPE]\n-#define objc_v2_super_imp_type \tobjc_v2_global_trees[OCTI_V2_SUPER_IMP_TYPE]\n+#define objc_v2_super_imp_type\tobjc_v2_global_trees[OCTI_V2_SUPER_IMP_TYPE]\n \n #define UOBJC_V2_CACHE_decl\tobjc_v2_global_trees[OCTI_V2_CACHE_DECL]\n #define UOBJC_V2_VTABLE_decl\tobjc_v2_global_trees[OCTI_V2_VTABLE_DECL]\n@@ -158,14 +158,14 @@ enum objc_v2_tree_index\n /* V2 Messaging */\n \n /* objc_msgSend_fixup_rtp */\n-#define umsg_fixup_decl\t\tobjc_v2_global_trees[OCTI_V2_UMSG_FIXUP_DECL]   \n+#define umsg_fixup_decl\t\tobjc_v2_global_trees[OCTI_V2_UMSG_FIXUP_DECL]\n /* objc_msgSend_stret_fixup_rtp */\n-#define umsg_stret_fixup_decl\tobjc_v2_global_trees[OCTI_V2_UMSG_STRET_FIXUP_DECL]   \n+#define umsg_stret_fixup_decl\tobjc_v2_global_trees[OCTI_V2_UMSG_STRET_FIXUP_DECL]\n /* objc_msgSendId_fixup_rtp */\n-#define umsg_id_fixup_decl\tobjc_v2_global_trees[OCTI_V2_UMSG_ID_FIXUP_DECL]   \n+#define umsg_id_fixup_decl\tobjc_v2_global_trees[OCTI_V2_UMSG_ID_FIXUP_DECL]\n /* objc_msgSendId_stret_fixup_rtp */\n #define umsg_id_stret_fixup_decl \\\n-\t\t\t\tobjc_v2_global_trees[OCTI_V2_UMSG_ID_STRET_FIXUP_DECL]   \n+\t\t\t\tobjc_v2_global_trees[OCTI_V2_UMSG_ID_STRET_FIXUP_DECL]\n /* objc_msgSendSuper2_fixup_rtp */\n #define umsg_id_super2_fixup_decl \\\n \t\t\t\tobjc_v2_global_trees[OCTI_V2_UMSG_SUPER2_FIXUP_DECL]\n@@ -237,15 +237,15 @@ static tree finish_try_stmt (struct objc_try_context **);\n \n static GTY ((length (\"SIZEHASHTABLE\"))) hash *extern_names;\n \n-bool \n+bool\n objc_next_runtime_abi_02_init (objc_runtime_hooks *rthooks)\n {\n   extern_names = ggc_alloc_cleared_vec_hash (SIZEHASHTABLE);\n \n   if (flag_objc_exceptions && flag_objc_sjlj_exceptions)\n     {\n       inform (UNKNOWN_LOCATION, \"%<-fobjc-sjlj-exceptions%> is ignored for \"\n-      \t\t\t\t\"%<-fnext-runtime%> when %<-fobjc-abi-version%> >= 2\");\n+\t\t\t\t\"%<-fnext-runtime%> when %<-fobjc-abi-version%> >= 2\");\n       flag_objc_sjlj_exceptions = 0;\n     }\n \n@@ -289,7 +289,7 @@ objc_next_runtime_abi_02_init (objc_runtime_hooks *rthooks)\n /* We need a way to convey what kind of meta-data are represented by a given\n    variable, since each type is expected (by the runtime) to be found in a\n    specific named section.  The solution must be usable with LTO.\n-   \n+\n    The scheme used for NeXT ABI 0/1 (partial matching of variable names) is not\n    satisfactory when LTO is used with ABI-2.  We now tag ObjC meta-data with\n    identification attributes in the front end.  The back-end may choose to act\n@@ -315,7 +315,7 @@ next_runtime_abi_02_init_metadata_attributes (void)\n   meta_clac_meth =\n   meta_clai_meth =\n   meta_catc_meth =\n-  meta_cati_meth = \n+  meta_cati_meth =\n   meta_proto_cls_meth =\n   meta_proto_nst_meth = meta_base;\n \n@@ -371,14 +371,14 @@ static void next_runtime_02_initialize (void)\n      objc_v2_selector_type.  */\n   build_v2_message_ref_templates ();\n \n-  objc_v2_ivar_list_ptr = \n-\t\tbuild_pointer_type (xref_tag (RECORD_TYPE, \n+  objc_v2_ivar_list_ptr =\n+\t\tbuild_pointer_type (xref_tag (RECORD_TYPE,\n \t\t\t\t    get_identifier (\"_ivar_list_t\")));\n \n-  objc_prop_list_ptr = \n+  objc_prop_list_ptr =\n \t\tbuild_pointer_type (xref_tag (RECORD_TYPE,\n \t\t\t\t    get_identifier (\"_prop_list_t\")));\n- \n+\n   build_v2_class_templates ();\n   build_v2_super_template ();\n   build_v2_protocol_template ();\n@@ -406,14 +406,14 @@ static void next_runtime_02_initialize (void)\n \t\t\t\t\t     NULL, NULL_TREE);\n   TREE_NOTHROW (umsg_id_fixup_decl) = 0;\n \n-  /* id objc_msgSendId_stret_fixup_rtp \n+  /* id objc_msgSendId_stret_fixup_rtp\n \t\t\t(id, struct message_ref_t*, ...); */\n   umsg_id_stret_fixup_decl = add_builtin_function (\"objc_msgSendId_stret_fixup\",\n \t\t\t\t\t\t   type, 0, NOT_BUILT_IN,\n \t\t\t\t\t\t   NULL, NULL_TREE);\n   TREE_NOTHROW (umsg_id_stret_fixup_decl) = 0;\n \n- /* id objc_msgSendSuper2_fixup_rtp \n+ /* id objc_msgSendSuper2_fixup_rtp\n \t\t\t(struct objc_super *, struct message_ref_t*, ...); */\n   type = build_varargs_function_type_list (objc_object_type,\n \t\t\t\t\t   objc_super_type,\n@@ -424,16 +424,16 @@ static void next_runtime_02_initialize (void)\n \t\t\t\t\t\t    NULL, NULL_TREE);\n   TREE_NOTHROW (umsg_id_super2_fixup_decl) = 0;\n \n-  /* id objc_msgSendSuper2_stret_fixup_rtp \n+  /* id objc_msgSendSuper2_stret_fixup_rtp\n \t\t\t(struct objc_super *, struct message_ref_t*, ...); */\n-  umsg_id_super2_stret_fixup_decl = \n+  umsg_id_super2_stret_fixup_decl =\n \t\t\tadd_builtin_function (\"objc_msgSendSuper2_stret_fixup\",\n-\t\t\t\t\t      type, 0, NOT_BUILT_IN, \n+\t\t\t\t\t      type, 0, NOT_BUILT_IN,\n \t\t\t\t\t      NULL, NULL_TREE);\n   TREE_NOTHROW (umsg_id_super2_stret_fixup_decl) = 0;\n \n   /* Present in the library, but unused by the FE.  */\n-  /* Protocol *objc_getProtocol (const char *) \n+  /* Protocol *objc_getProtocol (const char *)\n   type = build_function_type_list (objc_protocol_type,\n \t\t\t\t   const_string_type_node,\n \t\t\t\t   NULL_TREE);\n@@ -452,12 +452,12 @@ static void next_runtime_02_initialize (void)\n   type = build_function_type_list (objc_object_type,\n                                    const_string_type_node,\n                                    NULL_TREE);\n-  objc_get_class_decl = add_builtin_function (TAG_GETCLASS, \n+  objc_get_class_decl = add_builtin_function (TAG_GETCLASS,\n \t\t\t\t\t      type, 0, NOT_BUILT_IN,\n \t\t\t\t\t      NULL, NULL_TREE);\n \n   /* id objc_getMetaClass (const char *); */\n-  objc_get_meta_class_decl = add_builtin_function (TAG_GETMETACLASS, \n+  objc_get_meta_class_decl = add_builtin_function (TAG_GETMETACLASS,\n \t\t\t\t\t\t   type, 0, NOT_BUILT_IN,\n \t\t\t\t\t\t   NULL, NULL_TREE);\n \n@@ -466,13 +466,13 @@ static void next_runtime_02_initialize (void)\n   type = build_function_type_list (void_type_node,\n \t\t\t\t   ptr_type_node,\n \t\t\t\t   const_ptr_type_node,\n-\t\t\t\t   ptrdiff_type_node,       \n+\t\t\t\t   ptrdiff_type_node,\n \t\t\t\t   boolean_type_node,\n \t\t\t\t   boolean_type_node,\n \t\t\t\t   NULL_TREE);\n   /* Declare the following function:\n \t void\n-         objc_copyStruct (void *destination, const void *source, \n+         objc_copyStruct (void *destination, const void *source,\n \t                  ptrdiff_t size, BOOL is_atomic, BOOL has_strong); */\n   objc_copyStruct_decl = add_builtin_function (\"objc_copyStruct\",\n \t\t\t\t\t\t   type, 0, NOT_BUILT_IN,\n@@ -508,7 +508,7 @@ static void next_runtime_02_initialize (void)\n   TREE_NOTHROW (objc2_end_catch_decl) = 0;\n \n   /* void objc_exception_rethrow (void) */\n-  objc_rethrow_exception_decl = \n+  objc_rethrow_exception_decl =\n \t\t\tadd_builtin_function (\"objc_exception_rethrow\",\n \t\t\t\t\t      type, 0, NOT_BUILT_IN,\n \t\t\t\t\t      NULL, NULL_TREE);\n@@ -552,12 +552,12 @@ build_v2_message_ref_templates (void)\n \t\tobjc_start_struct (get_identifier (\"_message_ref_t\"));\n \n   /* IMP messenger; */\n-  ptr_message_ref_t = \n-\t\tbuild_pointer_type (xref_tag (RECORD_TYPE, \n+  ptr_message_ref_t =\n+\t\tbuild_pointer_type (xref_tag (RECORD_TYPE,\n \t\t\t\t    get_identifier (\"_message_ref_t\")));\n \n-  objc_v2_imp_type = \n-\t\tbuild_pointer_type (build_function_type_list \n+  objc_v2_imp_type =\n+\t\tbuild_pointer_type (build_function_type_list\n \t\t\t\t\t(objc_object_type,\n \t\t\t\t\t objc_object_type,\n \t\t\t\t\t ptr_message_ref_t,\n@@ -578,12 +578,12 @@ build_v2_message_ref_templates (void)\n \t\tobjc_start_struct (get_identifier (\"_super_message_ref_t\"));\n \n   /* SUPER_IMP messenger; */\n-  ptr_message_ref_t = build_pointer_type \n-\t\t\t(xref_tag (RECORD_TYPE, \n+  ptr_message_ref_t = build_pointer_type\n+\t\t\t(xref_tag (RECORD_TYPE,\n \t\t\t\t   get_identifier (\"_super_message_ref_t\")));\n \n-  objc_v2_super_imp_type = \n-\t\tbuild_pointer_type (build_function_type_list \n+  objc_v2_super_imp_type =\n+\t\tbuild_pointer_type (build_function_type_list\n \t\t\t\t\t(objc_object_type,\n \t\t\t\t\t objc_super_type,\n \t\t\t\t\t ptr_message_ref_t,\n@@ -595,7 +595,7 @@ build_v2_message_ref_templates (void)\n   add_field_decl (objc_selector_type, \"name\", &chain);\n \n   objc_finish_struct (objc_v2_super_message_ref_template, decls);\n-  objc_v2_super_selector_type = \n+  objc_v2_super_selector_type =\n \t\tbuild_pointer_type (objc_v2_super_message_ref_template);\n }\n \n@@ -624,7 +624,7 @@ struct class_t\n     struct class_t *superclass;\n     void *cache;\n     IMP *vtable;\n-    \n+\n     ...When this is active - it will point to a rw version, but\n        when we build the meta-data we point it to the ro...\n     struct class_ro_t *data;\n@@ -639,7 +639,7 @@ build_v2_class_templates (void)\n   tree decls, *chain = NULL;\n \n   /* struct class_ro_t {...} */\n-  objc_v2_class_ro_template = \n+  objc_v2_class_ro_template =\n \tobjc_start_struct (get_identifier (UTAG_V2_CLASS_RO));\n \n   /* uint32_t const flags; */\n@@ -667,13 +667,13 @@ build_v2_class_templates (void)\n   add_field_decl (objc_method_list_ptr, \"baseMethods\", &chain);\n \n   /* const struct objc_protocol_list *const baseProtocols; */\n-  add_field_decl (build_pointer_type \n-\t\t\t(xref_tag (RECORD_TYPE, \n+  add_field_decl (build_pointer_type\n+\t\t\t(xref_tag (RECORD_TYPE,\n \t\t\t\t   get_identifier (UTAG_V2_PROTOCOL_LIST))),\n \t\t\t\t  \"baseProtocols\", &chain);\n \n   /* const struct ivar_list_t *const ivars; */\n-  add_field_decl (objc_v2_ivar_list_ptr, \"ivars\", &chain);  \n+  add_field_decl (objc_v2_ivar_list_ptr, \"ivars\", &chain);\n \n   /* const uint8_t * const weakIvarLayout; */\n   add_field_decl (cnst_strg_type, \"weakIvarLayout\",  &chain);\n@@ -685,7 +685,7 @@ build_v2_class_templates (void)\n \n   chain = NULL;\n   /* struct class_t {...} */\n-  objc_v2_class_template = \n+  objc_v2_class_template =\n \tobjc_start_struct (get_identifier (UTAG_V2_CLASS));\n \n   /* struct class_t *isa; */\n@@ -703,7 +703,7 @@ build_v2_class_templates (void)\n   add_field_decl (build_pointer_type (objc_v2_imp_type), \"vtable\", &chain);\n \n   /* struct class_ro_t *ro; */\n-  add_field_decl (build_pointer_type (objc_v2_class_ro_template), \"ro\", &chain); \n+  add_field_decl (build_pointer_type (objc_v2_class_ro_template), \"ro\", &chain);\n \n   objc_finish_struct (objc_v2_class_template, decls);\n }\n@@ -731,7 +731,7 @@ build_v2_super_template (void)\n \n /* struct protocol_t\n   {\n-     Class isa; \n+     Class isa;\n      const char * const protocol_name;\n      const struct protocol_list_t * const protocol_list;\n      const struct method_list_t * const instance_methods;\n@@ -748,7 +748,7 @@ build_v2_protocol_template (void)\n {\n   tree decls, *chain = NULL;\n \n-  objc_v2_protocol_template = \n+  objc_v2_protocol_template =\n \tobjc_start_struct (get_identifier (UTAG_V2_PROTOCOL));\n \n   /* Class isa; */\n@@ -802,7 +802,7 @@ build_v2_category_template (void)\n {\n   tree decls, *chain = NULL;\n \n-  objc_v2_category_template = \n+  objc_v2_category_template =\n \tobjc_start_struct (get_identifier (\"_category_t\"));\n \n   /* char *name; */\n@@ -853,7 +853,7 @@ hash_name_lookup (hash *hashlist, tree name)\n    table.  Note that hashing is done on its inner IDENTIFIER_NODE\n    node.  */\n \n-static void \n+static void\n hash_name_enter (hash *hashlist, tree id)\n {\n   hash obj;\n@@ -878,7 +878,7 @@ create_extern_decl (tree type, const char *name)\n   if (var)\n       return var;\n   /* New name. */\n-  var = start_var_decl (type, name); \n+  var = start_var_decl (type, name);\n   TREE_STATIC (var) = 0;\n   DECL_EXTERNAL (var) = 1;\n   TREE_PUBLIC (var) = 1;\n@@ -911,7 +911,7 @@ create_global_decl (tree type, const char *name)\n /* Create a symbol with __attribute__ ((visibility (\"hidden\")))\n    attribute (private extern).  */\n \n-static tree \n+static tree\n create_hidden_decl (tree type, const char *name)\n {\n     tree decl = create_global_decl (type, name);\n@@ -939,7 +939,7 @@ next_runtime_abi_02_class_decl (tree klass)\n {\n   tree decl;\n   char buf[BUFSIZE];\n-  snprintf (buf, BUFSIZE, \"OBJC_CLASS_$_%s\", \n+  snprintf (buf, BUFSIZE, \"OBJC_CLASS_$_%s\",\n \t    IDENTIFIER_POINTER (CLASS_NAME (klass)));\n   /* ObjC2 classes are extern visible.  */\n   decl = create_global_decl (objc_v2_class_template, buf);\n@@ -952,7 +952,7 @@ next_runtime_abi_02_metaclass_decl (tree klass)\n {\n   tree decl;\n   char buf[BUFSIZE];\n-  snprintf (buf, BUFSIZE, \"OBJC_METACLASS_$_%s\", \n+  snprintf (buf, BUFSIZE, \"OBJC_METACLASS_$_%s\",\n \t    IDENTIFIER_POINTER (CLASS_NAME (klass)));\n   /* ObjC2 classes are extern visible.  */\n   decl = create_global_decl (objc_v2_class_template, buf);\n@@ -965,7 +965,7 @@ next_runtime_abi_02_category_decl (tree klass)\n {\n   tree decl;\n   char buf[BUFSIZE];\n-  snprintf (buf, BUFSIZE, \"_OBJC_Category_%s_on_%s\", \n+  snprintf (buf, BUFSIZE, \"_OBJC_Category_%s_on_%s\",\n \t    IDENTIFIER_POINTER (CLASS_SUPER_NAME (klass)),\n \t    IDENTIFIER_POINTER (CLASS_NAME (klass)));\n   decl = start_var_decl (objc_v2_category_template, buf);\n@@ -1005,7 +1005,7 @@ next_runtime_abi_02_string_decl (tree type, const char *name,  string_section wh\n       case prop_names_attr:\n \tOBJCMETA (var, objc_meta, meta_prop_name_attr);\n \tbreak;\n-      default: \n+      default:\n \tOBJCMETA (var, objc_meta, meta_base);\n \tbreak;\n     }\n@@ -1136,7 +1136,7 @@ build_selector_reference_decl (tree ident)\n   t = buf;\n   while (*t)\n     {\n-      if (*t==':') \n+      if (*t==':')\n         *t = '$'; /* Underscore would clash between foo:bar and foo_bar.  */\n       t++;\n     }\n@@ -1189,7 +1189,7 @@ build_v2_message_reference_decl (tree sel_name, tree message_func_ident)\n   t = buf;\n   while (*t)\n     {\n-      if (*t==':') \n+      if (*t==':')\n         *t = '$'; /* Underscore would clash between foo:bar and foo_bar.  */\n       t++;\n     }\n@@ -1230,7 +1230,7 @@ build_v2_selector_messenger_reference (tree sel_name, tree message_func_decl)\n     msgrefs = VEC_alloc (msgref_entry, gc, 32);\n \n   /* We come here if we don't find a match or at the start.  */\n-  decl = build_v2_message_reference_decl (sel_name, \n+  decl = build_v2_message_reference_decl (sel_name,\n \t\t\t\t\t  DECL_NAME (message_func_decl));\n   e.func = message_func_decl;\n   e.selname = sel_name;\n@@ -1246,7 +1246,7 @@ build_v2_protocollist_ref_decl (tree protocol)\n   tree protocol_ident = PROTOCOL_NAME (protocol);\n   char buf[BUFSIZE];\n \n-  snprintf (buf, BUFSIZE, \"_OBJC_ProtocolRef_%s\", \n+  snprintf (buf, BUFSIZE, \"_OBJC_ProtocolRef_%s\",\n \t    IDENTIFIER_POINTER (protocol_ident));\n   /* TODO: other compiler versions make these hidden & weak.  */\n   decl = create_global_decl (objc_protocol_type, buf);\n@@ -1316,7 +1316,7 @@ objc_is_ivar (tree expr, tree component, tree *klass)\n   tree field = NULL_TREE;\n   tree basetype = TYPE_MAIN_VARIANT (TREE_TYPE (expr));\n \n-  if (TREE_CODE (basetype) == RECORD_TYPE \n+  if (TREE_CODE (basetype) == RECORD_TYPE\n       && TYPE_HAS_OBJC_INFO (basetype) && TYPE_OBJC_INTERFACE (basetype))\n     {\n       *klass = lookup_interface (OBJC_TYPE_NAME (basetype));\n@@ -1337,7 +1337,7 @@ objc_is_ivar (tree expr, tree component, tree *klass)\n \t}\n     }\n   return field;\n-} \n+}\n \n static void\n create_ivar_offset_name (char *buf, tree class_name, tree field_decl)\n@@ -1380,13 +1380,13 @@ objc_v2_build_ivar_ref (tree datum, tree component)\n   ftype = TREE_TYPE (field);\n \n   /* (char*)datum */\n-  expr = build_c_cast (input_location, \n+  expr = build_c_cast (input_location,\n \t\t       string_type_node, build_fold_addr_expr (datum));\n \n   /* (char*)datum + offset */\n-  expr = fold_build2_loc (input_location, \n+  expr = fold_build2_loc (input_location,\n \t\t\t  POINTER_PLUS_EXPR, string_type_node, expr, offset);\n-  \n+\n   /* (ftype*)((char*)datum + offset) */\n   expr = build_c_cast (input_location, build_pointer_type (ftype), expr);\n \n@@ -1415,7 +1415,7 @@ objc_v2_build_ivar_ref (tree datum, tree component)\n    on the fly.  That is, unless they refer to (private) fields in  the\n    class stucture.  */\n static tree\n-next_runtime_abi_02_build_ivar_ref (location_t loc ATTRIBUTE_UNUSED, \n+next_runtime_abi_02_build_ivar_ref (location_t loc ATTRIBUTE_UNUSED,\n \t\t\t\t   tree base, tree id)\n {\n   tree ivar;\n@@ -1484,7 +1484,7 @@ next_runtime_abi_02_get_class_super_ref (location_t loc ATTRIBUTE_UNUSED,\n }\n \n static tree\n-next_runtime_abi_02_get_category_super_ref (location_t loc ATTRIBUTE_UNUSED, \n+next_runtime_abi_02_get_category_super_ref (location_t loc ATTRIBUTE_UNUSED,\n \t\t\t\t\t   struct imp_entry *imp, bool inst_meth)\n {\n   /* ??? is this OK when zero-link = true?  */\n@@ -1496,16 +1496,16 @@ next_runtime_abi_02_get_category_super_ref (location_t loc ATTRIBUTE_UNUSED,\n       super_class = objc_get_class_reference (CLASS_NAME (imp->imp_template));\n \n       if (!inst_meth)\n-\t\n+\n \t/* If we are in a class method, we must retrieve the\n \t   _metaclass_ for the current class, pointed at by the\n \t   class's \"isa\" pointer.  The following assumes that \"isa\" is\n \t   the first ivar in a class (which it must be).  */\n-\t   super_class = \n+\t   super_class =\n \t\tbuild_indirect_ref (input_location,\n \t\t\t\t    build_c_cast (input_location,\n \t\t\t\t\tbuild_pointer_type (objc_class_type),\n-\t\t\t\t\tsuper_class), \n+\t\t\t\t\tsuper_class),\n \t\t\t\t    RO_UNARY_STAR);\n       return super_class;\n     }\n@@ -1551,13 +1551,13 @@ objc_copy_to_temp_side_effect_params (tree typelist, tree values)\n   gcc_assert (TREE_CHAIN (typelist));\n   typetail = TREE_CHAIN (TREE_CHAIN (typelist));\n \n-  for (valtail = values; valtail; \n+  for (valtail = values; valtail;\n        valtail = TREE_CHAIN (valtail), typetail = TREE_CHAIN (typetail))\n     {\n       tree value = TREE_VALUE (valtail);\n       tree type = typetail ? TREE_VALUE (typetail) : NULL_TREE;\n       if (type == NULL_TREE)\n-\tbreak; \n+\tbreak;\n       if (!TREE_SIDE_EFFECTS (value))\n \tcontinue;\n       /* To prevent re-evaluation.  */\n@@ -1583,7 +1583,7 @@ build_v2_build_objc_method_call (int super_flag, tree method_prototype,\n     = (method_prototype\n        ? TREE_VALUE (TREE_TYPE (method_prototype))\n        : objc_object_type);\n-  tree method_param_types = get_arg_type_list (method_prototype, \n+  tree method_param_types = get_arg_type_list (method_prototype,\n \t\t\t\t\t       METHOD_REF, super_flag);\n \n   tree ftype = build_function_type (ret_type, method_param_types);\n@@ -1596,11 +1596,11 @@ build_v2_build_objc_method_call (int super_flag, tree method_prototype,\n   sender_cast = build_pointer_type (ftype);\n \n   if (check_for_nil)\n-    method_params = objc_copy_to_temp_side_effect_params (method_param_types, \n+    method_params = objc_copy_to_temp_side_effect_params (method_param_types,\n \t\t\t\t\t\t\t  method_params);\n \n   /* Get &message_ref_t.messenger.  */\n-  sender = build_c_cast (input_location, \n+  sender = build_c_cast (input_location,\n \t\t\t build_pointer_type (super_flag\n \t\t\t\t\t     ? objc_v2_super_imp_type\n \t\t\t\t\t     : objc_v2_imp_type),\n@@ -1638,19 +1638,19 @@ build_v2_build_objc_method_call (int super_flag, tree method_prototype,\n       else\n \tftree = fold_convert (ret_type, integer_zero_node);\n \n-      ifexp = build_binary_op (input_location, NE_EXPR, \n-\t\t\t       lookup_object, \n+      ifexp = build_binary_op (input_location, NE_EXPR,\n+\t\t\t       lookup_object,\n \t\t\t       fold_convert (rcv_p, integer_zero_node), 1);\n \n #ifdef OBJCPLUS\n       ret_val = build_conditional_expr (ifexp, ret_val, ftree, tf_warning_or_error);\n #else\n      /* ??? CHECKME.   */\n-      ret_val = build_conditional_expr (input_location, \n+      ret_val = build_conditional_expr (input_location,\n \t\t\t\t\tifexp, 1,\n \t\t\t\t\tret_val, NULL_TREE,\n \t\t\t\t\tftree, NULL_TREE);\n-#endif \n+#endif\n     }\n   return ret_val;\n }\n@@ -1668,54 +1668,54 @@ next_runtime_abi_02_build_objc_method_call (location_t loc,\n   tree message_func_decl;\n   bool check_for_nil = flag_objc_nilcheck;\n \n-  ret_type = (method_prototype ? \n-\t      \t    TREE_VALUE (TREE_TYPE (method_prototype)) : \n-\t\t    objc_object_type);\n+  ret_type = method_prototype\n+\t     ? TREE_VALUE (TREE_TYPE (method_prototype))\n+\t     : objc_object_type;\n \n   /* Do we need to check for nil receivers ? */\n   /* For now, message sent to classes need no nil check.  In the\n       future, class declaration marked as weak_import must be nil\n       checked.  */\n-  if (super \n-      || (TREE_CODE (receiver) == VAR_DECL \n+  if (super\n+      || (TREE_CODE (receiver) == VAR_DECL\n \t  && TREE_TYPE (receiver) == objc_class_type))\n     check_for_nil = false;\n \n   if (!targetm.calls.struct_value_rtx (0, 0)\n-          && (TREE_CODE (ret_type) == RECORD_TYPE \n-       \t      || TREE_CODE (ret_type) == UNION_TYPE)\n+          && (TREE_CODE (ret_type) == RECORD_TYPE\n+\t      || TREE_CODE (ret_type) == UNION_TYPE)\n           && targetm.calls.return_in_memory (ret_type, 0))\n     {\n       if (super)\n \tmessage_func_decl = umsg_id_super2_stret_fixup_decl;\n       else\n-\tmessage_func_decl = objc_is_id (rtype) \n-\t\t\t    \t  ? umsg_id_stret_fixup_decl \n-\t\t\t\t  : umsg_stret_fixup_decl;\n+\tmessage_func_decl = objc_is_id (rtype)\n+\t\t\t    ? umsg_id_stret_fixup_decl\n+\t\t\t    : umsg_stret_fixup_decl;\n     }\n   else\n     {\n       if (super)\n \tmessage_func_decl = umsg_id_super2_fixup_decl;\n       else\n-\tmessage_func_decl = objc_is_id (rtype) \n-\t\t    \t  \t? umsg_id_fixup_decl \n-\t\t\t  \t: umsg_fixup_decl;\n+\tmessage_func_decl = objc_is_id (rtype)\n+\t\t\t    ? umsg_id_fixup_decl\n+\t\t\t    : umsg_fixup_decl;\n     }\n \n-  selector = build_v2_selector_messenger_reference (sel_name,  \n+  selector = build_v2_selector_messenger_reference (sel_name,\n \t\t\t\t\t\t      message_func_decl);\n \n   /* selector = &_msg; */\n   selector = build_unary_op (loc, ADDR_EXPR, selector, 0);\n- \n-  selector = build_c_cast (loc, (super ? objc_v2_super_selector_type \n+\n+  selector = build_c_cast (loc, (super ? objc_v2_super_selector_type\n \t\t\t\t       : objc_v2_selector_type),\n \t\t\t   selector);\n \n   /* (*_msg.messenger) (receiver, &_msg, ...); */\n   return build_v2_build_objc_method_call (super, method_prototype,\n-\t\t\t\t\t  receiver, selector, \n+\t\t\t\t\t  receiver, selector,\n \t\t\t\t\t  method_params, check_for_nil);\n }\n \n@@ -1739,7 +1739,7 @@ next_runtime_abi_02_setup_const_string_class_decl (void)\n      available yet (in fact it is not in most cases).  So, declare an\n      extern OBJC_CLASS_$_NSConstantString in its place. */\n   if (!string_class_decl)\n-    string_class_decl = \n+    string_class_decl =\n \tcreate_extern_decl (objc_v2_class_template,\n \t\t\t    IDENTIFIER_POINTER (constant_string_global_id));\n \n@@ -1781,7 +1781,7 @@ next_runtime_abi_02_build_const_string_constructor (location_t loc, tree string,\n    struct _prop_t\n    {\n      const char * const name;\t\t\t// property name\n-     const char * const attributes;\t\t// comma-delimited, encoded, \n+     const char * const attributes;\t\t// comma-delimited, encoded,\n \t\t\t\t\t\t// property attributes\n    };\n */\n@@ -1823,7 +1823,7 @@ build_v2_ivar_t_template (void)\n   objc_ivar_record = objc_start_struct (objc_ivar_id);\n \n   /* unsigned long int *offset; */\n-  decls = add_field_decl (build_pointer_type \n+  decls = add_field_decl (build_pointer_type\n \t\t\t   (TREE_TYPE (size_zero_node)), \"offset\", &chain);\n \n   /* char *name; */\n@@ -1850,7 +1850,7 @@ build_metadata_templates (void)\n     objc_method_template = build_method_template ();\n \n   if (!objc_v2_property_template)\n-    objc_v2_property_template = build_v2_property_template (); \n+    objc_v2_property_template = build_v2_property_template ();\n \n   if (!objc_v2_ivar_template)\n     objc_v2_ivar_template = build_v2_ivar_t_template ();\n@@ -1865,8 +1865,8 @@ static char *\n objc_build_internal_classname (tree ident, bool metaclass)\n {\n   static char string[512];\n-  snprintf (string, 512, \"%s_%s\", metaclass ? \"OBJC_METACLASS_$\" \n-\t\t\t\t\t    : \"OBJC_CLASS_$\", \n+  snprintf (string, 512, \"%s_%s\", metaclass ? \"OBJC_METACLASS_$\"\n+\t\t\t\t\t    : \"OBJC_CLASS_$\",\n \t    IDENTIFIER_POINTER (ident));\n   return string;\n }\n@@ -1889,11 +1889,11 @@ newabi_append_ro (const char *name)\n   return string;\n }\n \n-/* Build the struct message_ref_t msg = \n-\t       {objc_msgSend_fixup_xxx, @selector(func)} \n+/* Build the struct message_ref_t msg =\n+\t       {objc_msgSend_fixup_xxx, @selector(func)}\n    table.  */\n \n-static \n+static\n void build_v2_message_ref_translation_table (void)\n {\n   int count;\n@@ -1919,7 +1919,7 @@ void build_v2_message_ref_translation_table (void)\n       expr = build_selector (ref->selname);\n       CONSTRUCTOR_APPEND_ELT (initializer, NULL_TREE, expr);\n       constructor = objc_build_constructor (struct_type, initializer);\n-      finish_var_decl (ref->refdecl, constructor); \n+      finish_var_decl (ref->refdecl, constructor);\n     }\n }\n \n@@ -1949,7 +1949,7 @@ build_v2_classrefs_table (void)\n \t  expr = convert (objc_class_type, build_fold_addr_expr (expr));\n \t}\n       /* The runtime wants this, even if it appears unused, so we must force the\n-\t output. \n+\t output.\n       DECL_PRESERVE_P (decl) = 1; */\n       finish_var_decl (decl, expr);\n     }\n@@ -1991,7 +1991,7 @@ build_v2_super_classrefs_table (bool metaclass)\n \n static GTY(()) VEC(tree,gc) *class_list;\n \n-static void \n+static void\n objc_v2_add_to_class_list (tree global_class_decl)\n {\n   if (!class_list)\n@@ -2004,7 +2004,7 @@ static GTY(()) VEC(tree,gc) *nonlazy_class_list;\n /* Add the global class meta-data declaration to the list which later\n    on ends up in the __nonlazy_class section.  */\n \n-static void \n+static void\n objc_v2_add_to_nonlazy_class_list (tree global_class_decl)\n {\n   if (!nonlazy_class_list)\n@@ -2017,7 +2017,7 @@ static GTY(()) VEC(tree,gc) *category_list;\n /* Add the category meta-data declaration to the list which later on\n    ends up in the __nonlazy_category section.  */\n \n-static void \n+static void\n objc_v2_add_to_category_list (tree decl)\n {\n   if (!category_list)\n@@ -2030,7 +2030,7 @@ static GTY(()) VEC(tree,gc) *nonlazy_category_list;\n /* Add the category meta-data declaration to the list which later on\n    ends up in the __category_list section.  */\n \n-static void \n+static void\n objc_v2_add_to_nonlazy_category_list (tree decl)\n {\n   if (!nonlazy_category_list)\n@@ -2077,7 +2077,7 @@ build_v2_address_table (VEC(tree,gc) *src, const char *nam, tree attr)\n       CONSTRUCTOR_APPEND_ELT (initlist, purpose, expr);\n     }\n   gcc_assert (count > 0);\n-  type = build_array_type (objc_class_type, \n+  type = build_array_type (objc_class_type,\n \t\t\t   build_index_type (build_int_cst (NULL_TREE, count - 1)));\n   decl = start_var_decl (type, nam);\n   /* The runtime wants this, even if it appears unused, so we must\n@@ -2097,7 +2097,7 @@ build_v2_protocol_list_translation_table (void)\n {\n   int count;\n   prot_list_entry *ref;\n-  \n+\n   if (!protrefs)\n     return;\n \n@@ -2106,7 +2106,7 @@ build_v2_protocol_list_translation_table (void)\n       char buf[BUFSIZE];\n       tree expr;\n       gcc_assert (TREE_CODE (ref->id) == PROTOCOL_INTERFACE_TYPE);\n-      snprintf (buf, BUFSIZE, \"_OBJC_Protocol_%s\", \n+      snprintf (buf, BUFSIZE, \"_OBJC_Protocol_%s\",\n \t\tIDENTIFIER_POINTER (PROTOCOL_NAME (ref->id)));\n       expr = start_var_decl (objc_v2_protocol_template, buf);\n       expr = convert (objc_protocol_type, build_fold_addr_expr (expr));\n@@ -2210,15 +2210,15 @@ generate_v2_protocol_list (tree i_or_p, tree klass_ctxt)\n   switch (TREE_CODE (i_or_p))\n     {\n     case PROTOCOL_INTERFACE_TYPE:\n-      snprintf (buf, BUFSIZE, \"_OBJC_ProtocolRefs_%s\", \n+      snprintf (buf, BUFSIZE, \"_OBJC_ProtocolRefs_%s\",\n \t\tIDENTIFIER_POINTER (PROTOCOL_NAME (i_or_p)));\n       break;\n     case CLASS_INTERFACE_TYPE:\n-      snprintf (buf, BUFSIZE, \"_OBJC_ClassProtocols_%s\", \n+      snprintf (buf, BUFSIZE, \"_OBJC_ClassProtocols_%s\",\n \t\tIDENTIFIER_POINTER (CLASS_NAME (i_or_p)));\n       break;\n     case CATEGORY_INTERFACE_TYPE:\n-      snprintf (buf, BUFSIZE, \"_OBJC_CategoryProtocols_%s_%s\", \n+      snprintf (buf, BUFSIZE, \"_OBJC_CategoryProtocols_%s_%s\",\n \t\tIDENTIFIER_POINTER (CLASS_NAME (klass_ctxt)),\n \t\tIDENTIFIER_POINTER (CLASS_SUPER_NAME (klass_ctxt)));\n       break;\n@@ -2231,7 +2231,7 @@ generate_v2_protocol_list (tree i_or_p, tree klass_ctxt)\n   /* ObjC2 puts all these in the base section.  */\n   OBJCMETA (refs_decl, objc_meta, meta_base);\n   DECL_PRESERVE_P (refs_decl) = 1;\n-  finish_var_decl (refs_decl, \n+  finish_var_decl (refs_decl,\n \t\t   objc_build_constructor (TREE_TYPE (refs_decl),initlist));\n   return refs_decl;\n }\n@@ -2250,14 +2250,14 @@ build_v2_descriptor_table_initializer (tree type, tree entries)\n   do\n     {\n       VEC(constructor_elt,gc) *eltlist = NULL;\n-      CONSTRUCTOR_APPEND_ELT (eltlist, NULL_TREE, \n+      CONSTRUCTOR_APPEND_ELT (eltlist, NULL_TREE,\n \t\t\t      build_selector (METHOD_SEL_NAME (entries)));\n-      CONSTRUCTOR_APPEND_ELT (eltlist, NULL_TREE, \n+      CONSTRUCTOR_APPEND_ELT (eltlist, NULL_TREE,\n \t\t\t      add_objc_string (METHOD_ENCODING (entries),\n \t\t\t\t\t\tmeth_var_types));\n       CONSTRUCTOR_APPEND_ELT (eltlist, NULL_TREE, null_pointer_node);\n \n-      CONSTRUCTOR_APPEND_ELT (initlist, NULL_TREE, \n+      CONSTRUCTOR_APPEND_ELT (initlist, NULL_TREE,\n \t\t\t      objc_build_constructor (type, eltlist));\n       entries = TREE_CHAIN (entries);\n     }\n@@ -2280,7 +2280,7 @@ build_v2_method_list_template (tree list_type, int size)\n   tree array_type, decls, *chain = NULL;\n \n   method_list_t_record = objc_start_struct (NULL_TREE);\n- \n+\n   /* uint32_t const entsize; */\n   decls = add_field_decl (integer_type_node, \"entsize\", &chain);\n \n@@ -2298,7 +2298,7 @@ build_v2_method_list_template (tree list_type, int size)\n /* Note, as above that we are building to the objc_method_template\n    which has the *imp field.  ABI0/1 build with\n    objc_method_prototype_template which is missing this field.  */\n-static tree \n+static tree\n generate_v2_meth_descriptor_table (tree chain, tree protocol,\n \t\t\t\t   const char *prefix, tree attr)\n {\n@@ -2323,15 +2323,15 @@ generate_v2_meth_descriptor_table (tree chain, tree protocol,\n   gcc_assert (size);\n   method_list_template = build_v2_method_list_template (objc_method_template,\n \t\t\t\t\t\t\tsize);\n-  snprintf (buf, BUFSIZE, \"%s_%s\", prefix, \n+  snprintf (buf, BUFSIZE, \"%s_%s\", prefix,\n \t    IDENTIFIER_POINTER (PROTOCOL_NAME (protocol)));\n \n   decl = start_var_decl (method_list_template, buf);\n \n   entsize = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (objc_method_template));\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, entsize));\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, build_int_cst (NULL_TREE, size));\n-  initlist = \n+  initlist =\n \tbuild_v2_descriptor_table_initializer (objc_method_template,\n \t\t\t\t\t    chain);\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, initlist);\n@@ -2361,11 +2361,11 @@ build_v2_property_table_initializer (tree type, tree context)\n \t later.  */\n       tree attribute, name_ident = PROPERTY_NAME (x);\n \n-      CONSTRUCTOR_APPEND_ELT (elemlist, NULL_TREE, \n+      CONSTRUCTOR_APPEND_ELT (elemlist, NULL_TREE,\n \t\t\t      add_objc_string (name_ident, prop_names_attr));\n \n       attribute = objc_v2_encode_prop_attr (x);\n-      CONSTRUCTOR_APPEND_ELT (elemlist, NULL_TREE, \n+      CONSTRUCTOR_APPEND_ELT (elemlist, NULL_TREE,\n \t\t\t      add_objc_string (attribute, prop_names_attr));\n \n       CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE,\n@@ -2392,7 +2392,7 @@ build_v2_property_list_template (tree list_type, int size)\n \n   /* anonymous.  */\n   property_list_t_record = objc_start_struct (NULL_TREE);\n- \n+\n   /* uint32_t const entsize; */\n   decls = add_field_decl (integer_type_node, \"entsize\", &chain);\n \n@@ -2434,8 +2434,8 @@ generate_v2_property_table (tree context, tree klass_ctxt)\n   if (size == 0)\n     return NULL_TREE;\n \n-  property_list_template = \n-\tbuild_v2_property_list_template (objc_v2_property_template, \n+  property_list_template =\n+\tbuild_v2_property_list_template (objc_v2_property_template,\n \t\t\t\t\t size);\n \n   initlist = build_v2_property_table_initializer (objc_v2_property_template,\n@@ -2452,9 +2452,9 @@ generate_v2_property_table (tree context, tree klass_ctxt)\n \n   decl = start_var_decl (property_list_template, buf);\n \n-  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, \n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE,\n \t\t\t  build_int_cst (NULL_TREE, init_val));\n-  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, \n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE,\n \t\t\t  build_int_cst (NULL_TREE, size));\n   CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, initlist);\n \n@@ -2465,7 +2465,7 @@ generate_v2_property_table (tree context, tree klass_ctxt)\n \n static tree\n build_v2_protocol_initializer (tree type, tree protocol_name, tree protocol_list,\n-\t\t\t      tree inst_methods, tree class_methods, \n+\t\t\t      tree inst_methods, tree class_methods,\n \t\t\t      tree opt_ins_meth, tree opt_cls_meth,\n \t\t\t      tree property_list)\n {\n@@ -2477,7 +2477,7 @@ build_v2_protocol_initializer (tree type, tree protocol_name, tree protocol_list\n   loc = UNKNOWN_LOCATION;\n \n   /*  This is NULL for the new ABI.  */\n-  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, \n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE,\n \t\t\t      convert (objc_object_type, null_pointer_node));\n \n   CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, protocol_name);\n@@ -2516,7 +2516,7 @@ build_v2_protocol_initializer (tree type, tree protocol_name, tree protocol_list\n   CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, expr);\n \n   /* const uint32_t size;  = sizeof(struct protocol_t) */\n-  expr = build_int_cst (integer_type_node, \n+  expr = build_int_cst (integer_type_node,\n \t      TREE_INT_CST_LOW (TYPE_SIZE_UNIT (objc_v2_protocol_template)));\n   CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, expr);\n   /* const uint32_t flags; = 0 */\n@@ -2558,12 +2558,12 @@ generate_v2_protocols (void)\n       loc = DECL_SOURCE_LOCATION (decl);\n       some = true;\n \n-      inst_meth = \n+      inst_meth =\n \tgenerate_v2_meth_descriptor_table (PROTOCOL_NST_METHODS (p), p,\n \t\t\t\t\t   \"_OBJC_ProtocolInstanceMethods\",\n \t\t\t\t\t   meta_proto_nst_meth);\n \n-      class_meth = \n+      class_meth =\n \tgenerate_v2_meth_descriptor_table (PROTOCOL_CLS_METHODS (p), p,\n \t\t\t\t\t   \"_OBJC_ProtocolClassMethods\",\n \t\t\t\t\t   meta_proto_cls_meth);\n@@ -2573,7 +2573,7 @@ generate_v2_protocols (void)\n \t\t\t\t\t   \"_OBJC_OptProtocolInstMethods\",\n \t\t\t\t\t   meta_proto_nst_meth);\n \n-      opt_class_meth = \n+      opt_class_meth =\n \tgenerate_v2_meth_descriptor_table (PROTOCOL_OPTIONAL_CLS_METHODS (p), p,\n \t\t\t\t\t   \"_OBJC_OptProtocolClassMethods\",\n \t\t\t\t\t   meta_proto_cls_meth);\n@@ -2632,9 +2632,9 @@ generate_v2_dispatch_table (tree chain, const char *name, tree attr)\n   decl = start_var_decl  (method_list_template, name);\n \n   init_val = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (objc_method_template));\n-  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n \t\t\t  build_int_cst (integer_type_node, init_val));\n-  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, \n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n \t\t\t  build_int_cst (integer_type_node, size));\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, initlist);\n \n@@ -2700,11 +2700,11 @@ generate_v2_category (struct imp_entry *impent)\n   tree cat_decl = impent->class_decl;\n   location_t loc;\n   char buf[BUFSIZE];\n-  \n+\n   loc = DECL_SOURCE_LOCATION (cat_decl);\n \n   /* ??? not sure this is really necessary, the following references should\n-     force appropriate linkage linkage... \n+     force appropriate linkage linkage...\n      -- but ... ensure a reference to the class...  */\n   t = objc_v2_get_class_reference (CLASS_NAME (cat));\n   /* ... which we ignore so force it out.. */\n@@ -2823,7 +2823,7 @@ build_v2_ivar_list_initializer (tree class_name, tree type, tree field_decl)\n {\n   VEC(constructor_elt,gc) *inits = NULL;\n \n-  do \n+  do\n     {\n       VEC(constructor_elt,gc) *ivar = NULL;\n       int val;\n@@ -2839,8 +2839,8 @@ build_v2_ivar_list_initializer (tree class_name, tree type, tree field_decl)\n       /* Set offset.  */\n       CONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE,\n \t\t\t      build_unary_op (input_location,\n-\t\t\t\t\t      ADDR_EXPR, \n-\t\t\t\t\t      ivar_offset_ref (class_name, \n+\t\t\t\t\t      ADDR_EXPR,\n+\t\t\t\t\t      ivar_offset_ref (class_name,\n \t\t\t\t\t\t\t       field_decl), 0));\n \n       /* Set name.  */\n@@ -2862,12 +2862,12 @@ build_v2_ivar_list_initializer (tree class_name, tree type, tree field_decl)\n       /* Set alignment.  */\n       val = DECL_ALIGN_UNIT (field_decl);\n       val = exact_log2 (val);\n-      CONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE, \n+      CONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE,\n \t\t\t      build_int_cst (integer_type_node, val));\n- \n+\n       /* Set size.  */\n       val = TREE_INT_CST_LOW (DECL_SIZE_UNIT (field_decl));\n-      CONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE, \n+      CONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE,\n \t\t\t      build_int_cst (integer_type_node, val));\n \n       CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE,\n@@ -2925,20 +2925,20 @@ generate_v2_ivars_list (tree chain, const char *name, tree attr, tree templ)\n   tree decl, initlist, ivar_list_template;\n   VEC(constructor_elt,gc) *inits = NULL;\n   int size, ivar_t_size;\n-  \n+\n   if (!chain || !name || !(size = ivar_list_length (chain)))\n     return NULL_TREE;\n \n   generating_instance_variables = 1;\n   ivar_list_template = build_v2_ivar_list_t_template (objc_v2_ivar_template,\n \t\t\t\t\t\t      size);\n- \n+\n   initlist = build_v2_ivar_list_initializer (CLASS_NAME (templ),\n \t\t\t\t\t     objc_v2_ivar_template, chain);\n   ivar_t_size = TREE_INT_CST_LOW  (TYPE_SIZE_UNIT (objc_v2_ivar_template));\n-  \n+\n   decl = start_var_decl (ivar_list_template, name);\n-  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE, \n+  CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE,\n \t\t\t  build_int_cst (integer_type_node, ivar_t_size));\n   CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE,\n \t\t\t  build_int_cst (integer_type_node, size));\n@@ -2985,11 +2985,11 @@ build_v2_class_t_initializer (tree type, tree isa, tree superclass,\n /* Routine to build object of struct class_ro_t { ... }; */\n \n static tree\n-build_v2_class_ro_t_initializer (tree type, tree name, \n+build_v2_class_ro_t_initializer (tree type, tree name,\n \t\t\t       unsigned int flags, unsigned int instanceStart,\n-\t\t\t       unsigned int instanceSize, \n-\t\t\t       tree ivarLayout, \n-\t\t\t       tree baseMethods, tree baseProtocols, \n+\t\t\t       unsigned int instanceSize,\n+\t\t\t       tree ivarLayout,\n+\t\t\t       tree baseMethods, tree baseProtocols,\n \t\t\t       tree ivars, tree property_list)\n {\n   tree expr, unsigned_char_star, ltyp;\n@@ -3000,21 +3000,21 @@ build_v2_class_ro_t_initializer (tree type, tree name,\n   loc = UNKNOWN_LOCATION;\n \n   /* flags */\n-  CONSTRUCTOR_APPEND_ELT (initlist, NULL_TREE, \n+  CONSTRUCTOR_APPEND_ELT (initlist, NULL_TREE,\n \t\t\t  build_int_cst (integer_type_node, flags));\n \n   /* instanceStart */\n-  CONSTRUCTOR_APPEND_ELT (initlist, NULL_TREE, \n+  CONSTRUCTOR_APPEND_ELT (initlist, NULL_TREE,\n \t\t\t  build_int_cst (integer_type_node, instanceStart));\n \n   /* instanceSize */\n-  CONSTRUCTOR_APPEND_ELT (initlist, NULL_TREE, \n+  CONSTRUCTOR_APPEND_ELT (initlist, NULL_TREE,\n \t\t\t  build_int_cst (integer_type_node, instanceSize));\n \n   /* This ABI is currently only used on m64 NeXT.  We always\n      explicitly declare the alignment padding.  */\n   /* reserved, pads alignment.  */\n-  CONSTRUCTOR_APPEND_ELT (initlist, NULL_TREE, \n+  CONSTRUCTOR_APPEND_ELT (initlist, NULL_TREE,\n \t\t\t    build_int_cst (integer_type_node, 0));\n \n   /* ivarLayout */\n@@ -3037,7 +3037,7 @@ build_v2_class_ro_t_initializer (tree type, tree name,\n   CONSTRUCTOR_APPEND_ELT (initlist, NULL_TREE, expr);\n \n   /* baseProtocols */\n-  ltyp = build_pointer_type (xref_tag (RECORD_TYPE, \n+  ltyp = build_pointer_type (xref_tag (RECORD_TYPE,\n \t\t\t               get_identifier (UTAG_V2_PROTOCOL_LIST)));\n   if (baseProtocols)\n     expr = convert (ltyp, build_unary_op (loc, ADDR_EXPR, baseProtocols, 0));\n@@ -3055,7 +3055,7 @@ build_v2_class_ro_t_initializer (tree type, tree name,\n \n   /* TODO: We don't yet have the weak/strong stuff...  */\n   /* weakIvarLayout */\n-  CONSTRUCTOR_APPEND_ELT (initlist, NULL_TREE, \n+  CONSTRUCTOR_APPEND_ELT (initlist, NULL_TREE,\n \t\t\t  convert (unsigned_char_star, null_pointer_node));\n \n   /* property list */\n@@ -3142,9 +3142,9 @@ generate_v2_class_structs (struct imp_entry *impent)\n         }\n       while (1);\n \n-      /* {extern} struct class_t OBJC_METACLASS_$_<my_root_int> \n+      /* {extern} struct class_t OBJC_METACLASS_$_<my_root_int>\n          create extern if not already declared.  */\n-      snprintf (buf, BUFSIZE, \"OBJC_METACLASS_$_%s\", \n+      snprintf (buf, BUFSIZE, \"OBJC_METACLASS_$_%s\",\n \t\tIDENTIFIER_POINTER (CLASS_NAME (my_root_int)));\n       root_expr = create_extern_decl (objc_v2_class_template, buf);\n       root_expr = build_fold_addr_expr (root_expr);\n@@ -3153,12 +3153,12 @@ generate_v2_class_structs (struct imp_entry *impent)\n       interface = lookup_interface (my_super_id);\n       gcc_assert (interface);\n       /* Similarly, for OBJC_CLASS_$_<interface>...  */\n-      snprintf (buf, BUFSIZE, \"OBJC_CLASS_$_%s\", \n+      snprintf (buf, BUFSIZE, \"OBJC_CLASS_$_%s\",\n \t\tIDENTIFIER_POINTER (CLASS_NAME (interface)));\n       class_superclass_expr = create_extern_decl (objc_v2_class_template, buf);\n       class_superclass_expr = build_fold_addr_expr (class_superclass_expr);\n       /* ... and for OBJC_METACLASS_$_<interface>.  */\n-      snprintf (buf, BUFSIZE, \"OBJC_METACLASS_$_%s\", \n+      snprintf (buf, BUFSIZE, \"OBJC_METACLASS_$_%s\",\n \t\tIDENTIFIER_POINTER (CLASS_NAME (interface)));\n       metaclass_superclass_expr = create_extern_decl (objc_v2_class_template, buf);\n       metaclass_superclass_expr = build_fold_addr_expr (metaclass_superclass_expr);\n@@ -3188,7 +3188,7 @@ generate_v2_class_structs (struct imp_entry *impent)\n     {\n       snprintf (buf, BUFSIZE, \"_OBJC_ClassMethods_%s\",\n \t\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)));\n-      class_methods = \n+      class_methods =\n \tgenerate_v2_dispatch_table (CLASS_CLS_METHODS (impent->imp_context),\n \t\t\t\t    buf, meta_clac_meth);\n     }\n@@ -3203,7 +3203,7 @@ generate_v2_class_structs (struct imp_entry *impent)\n \n   class_ivars = NULL_TREE;\n   /* TODO: Add total size of class variables when implemented. */\n-  instanceSize = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (objc_v2_class_template)); \n+  instanceSize = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (objc_v2_class_template));\n \n   /* So now build the META CLASS structs.  */\n   /* static struct class_ro_t  _OBJC_METACLASS_Foo = { ... }; */\n@@ -3213,23 +3213,23 @@ generate_v2_class_structs (struct imp_entry *impent)\n \t\t\t\t\t\t(DECL_NAME (metaclass_decl))));\n \n   /* TODO: ivarLayout needs t be built.  */\n-  initlist = \n+  initlist =\n \tbuild_v2_class_ro_t_initializer (TREE_TYPE (decl), name_expr,\n \t\t\t\t\t(flags | cls_flags), instanceStart,\n-\t\t\t\t\tinstanceSize, ivarLayout, \n+\t\t\t\t\tinstanceSize, ivarLayout,\n \t\t\t\t\tclass_methods, protocol_decl,\n \t\t\t\t\tclass_ivars, NULL_TREE);\n   /* The ROs sit in the default const section.  */\n   OBJCMETA (decl, objc_meta, meta_base);\n   finish_var_decl (decl, initlist);\n \n   /* static struct class_t _OBJC_METACLASS_Foo = { ... }; */\n-  initlist = \n+  initlist =\n \tbuild_v2_class_t_initializer (TREE_TYPE (metaclass_decl),\n \t\t\t\t      root_expr,\n \t\t\t\t      metaclass_superclass_expr,\n \t\t\t\t      build_fold_addr_expr (decl),\n-\t\t\t\t      build_fold_addr_expr (UOBJC_V2_CACHE_decl), \n+\t\t\t\t      build_fold_addr_expr (UOBJC_V2_CACHE_decl),\n \t\t\t\t      build_fold_addr_expr (UOBJC_V2_VTABLE_decl));\n   /* The class section attributes are set when they are created.  */\n   finish_var_decl (metaclass_decl, initlist);\n@@ -3251,7 +3251,7 @@ generate_v2_class_structs (struct imp_entry *impent)\n     {\n       snprintf (buf, BUFSIZE, \"_OBJC_InstanceMethods_%s\",\n \t\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)));\n-      inst_methods = \n+      inst_methods =\n \tgenerate_v2_dispatch_table (CLASS_NST_METHODS (impent->imp_context),\n \t\t\t\t    buf, meta_clai_meth);\n     }\n@@ -3261,7 +3261,7 @@ generate_v2_class_structs (struct imp_entry *impent)\n     {\n       snprintf (buf, BUFSIZE, \"_OBJC_InstanceIvars_%s\",\n \t\tIDENTIFIER_POINTER (CLASS_NAME (impent->imp_context)));\n-      inst_ivars = generate_v2_ivars_list (chain, buf, meta_clai_vars, \n+      inst_ivars = generate_v2_ivars_list (chain, buf, meta_clai_vars,\n \t\t\t\t\t   impent->imp_template);\n     }\n \n@@ -3282,9 +3282,9 @@ generate_v2_class_structs (struct imp_entry *impent)\n   while (field && TREE_CHAIN (field)\n          && TREE_CODE (TREE_CHAIN (field)) == FIELD_DECL)\n     field = TREE_CHAIN (field);\n-  \n+\n   if (field && TREE_CODE (field) == FIELD_DECL)\n-    instanceSize = int_byte_position (field) * BITS_PER_UNIT \n+    instanceSize = int_byte_position (field) * BITS_PER_UNIT\n \t\t   + tree_low_cst (DECL_SIZE (field), 0);\n   else\n     instanceSize = 0;\n@@ -3294,19 +3294,19 @@ generate_v2_class_structs (struct imp_entry *impent)\n \n   /* If the class has no ivars, instanceStart should be set to the\n      superclass's instanceSize.  */\n-  instanceStart = \n-\t(inst_ivars != NULL_TREE) ? (unsigned) int_byte_position (firstIvar) \n+  instanceStart =\n+\t(inst_ivars != NULL_TREE) ? (unsigned) int_byte_position (firstIvar)\n \t\t\t\t  : instanceSize;\n \n   /* static struct class_ro_t  _OBJC_CLASS_Foo = { ... }; */\n-  decl = start_var_decl (objc_v2_class_ro_template, \n+  decl = start_var_decl (objc_v2_class_ro_template,\n \t\t\t newabi_append_ro (IDENTIFIER_POINTER\n-\t\t\t\t\t\t(DECL_NAME (class_decl))));  \n+\t\t\t\t\t\t(DECL_NAME (class_decl))));\n \n-  initlist = \n+  initlist =\n \tbuild_v2_class_ro_t_initializer (TREE_TYPE (decl), name_expr,\n \t\t\t\t\t (flags | cls_flags), instanceStart,\n-\t\t\t\t\t instanceSize, ivarLayout, \n+\t\t\t\t\t instanceSize, ivarLayout,\n \t\t\t\t\t inst_methods, protocol_decl,\n \t\t\t\t\t inst_ivars, props);\n   /* The ROs sit in the default const section.  */\n@@ -3318,8 +3318,8 @@ generate_v2_class_structs (struct imp_entry *impent)\n \t\t\t\t\tbuild_fold_addr_expr (metaclass_decl),\n \t\t\t\t\tclass_superclass_expr,\n \t\t\t\t\tbuild_fold_addr_expr (decl),\n-\t\t\t\t\tbuild_fold_addr_expr (UOBJC_V2_CACHE_decl), \n-\t\t\t\t\tbuild_fold_addr_expr (UOBJC_V2_VTABLE_decl)); \n+\t\t\t\t\tbuild_fold_addr_expr (UOBJC_V2_CACHE_decl),\n+\t\t\t\t\tbuild_fold_addr_expr (UOBJC_V2_VTABLE_decl));\n \n   /* The class section attributes are set when they are created.  */\n   finish_var_decl (class_decl, initlist);\n@@ -3356,12 +3356,12 @@ generate_v2_objc_image_info (void)\n {\n   tree decl, array_type;\n   VEC(constructor_elt,gc) *v = NULL;\n-  int flags = \n+  int flags =\n \t((flag_replace_objc_classes && imp_count ? 1 : 0)\n \t  | (flag_objc_gc ? 2 : 0));\n \n   flags |= 16;\n-  \n+\n   array_type  = build_sized_array_type (integer_type_node, 2);\n \n   decl = start_var_decl (array_type, \"_OBJC_ImageInfo\");\n@@ -3416,13 +3416,13 @@ objc_generate_v2_next_metadata (void)\n   build_v2_protocol_list_translation_table ();\n   build_v2_protocol_list_address_table ();\n \n-  build_v2_address_table (class_list, \"_OBJC_ClassList$\", \n+  build_v2_address_table (class_list, \"_OBJC_ClassList$\",\n \t\t\t  meta_label_classlist);\n-  build_v2_address_table (category_list, \"_OBJC_CategoryList$\", \n+  build_v2_address_table (category_list, \"_OBJC_CategoryList$\",\n \t\t\t  meta_label_categorylist);\n-  build_v2_address_table (nonlazy_class_list, \"_OBJC_NonLazyClassList$\", \n+  build_v2_address_table (nonlazy_class_list, \"_OBJC_NonLazyClassList$\",\n \t\t\t  meta_label_nonlazy_classlist);\n-  build_v2_address_table (nonlazy_category_list, \"_OBJC_NonLazyCategoryList$\", \n+  build_v2_address_table (nonlazy_category_list, \"_OBJC_NonLazyCategoryList$\",\n \t\t\t  meta_label_nonlazy_categorylist);\n \n   /* This conveys information on GC usage and zero-link.  */\n@@ -3515,7 +3515,7 @@ build_ehtype (tree name, const char *eh_name, bool weak)\n   name_expr = add_objc_string (name, class_names);\n   /* Extern ref. for the class. ???  Maybe we can look this up\n      somewhere.  */\n-  class_name_expr = \n+  class_name_expr =\n \tcreate_extern_decl (objc_v2_class_template,\n \t\t\t    objc_build_internal_classname (name, false));\n   class_name_expr = build_fold_addr_expr (class_name_expr);\n@@ -3541,10 +3541,10 @@ objc2_objc_exception_attr (tree cls)\n       cls = lookup_interface (CLASS_SUPER_NAME (cls));\n     }\n \n-  return false; \n+  return false;\n }\n \n-static bool \n+static bool\n is_implemented (tree name)\n {\n   struct imp_entry *t;\n@@ -3615,7 +3615,7 @@ next_runtime_02_eh_type (tree type)\n \t{\n \t  /* This is provided by the Apple/NeXT libobjc.dylib so we\n \t     need only to reference it.  */\n-\t  next_v2_EHTYPE_id_decl = \n+\t  next_v2_EHTYPE_id_decl =\n \t\tstart_var_decl (objc_v2_ehtype_template, \"OBJC_EHTYPE_id\");\n \t  DECL_EXTERNAL (next_v2_EHTYPE_id_decl) = 1;\n \t  TREE_PUBLIC (next_v2_EHTYPE_id_decl) = 1;\n@@ -3635,9 +3635,9 @@ next_runtime_02_eh_type (tree type)\n       goto err_mark_in;\n #endif\n     }\n-  else \n+  else\n     t = OBJC_TYPE_NAME (TREE_TYPE (type));\n-  \n+\n   /* We have to build a reference to the OBJC_EHTYPE_<Class>.  */\n   t = lookup_ehtype_ref (t);\n   if (!t)\n@@ -3724,7 +3724,7 @@ static tree begin_catch (struct objc_try_context **cur_try_context, tree type,\n }\n \n /* try { catch-body } finally { objc_end_catch (); } */\n-static void \n+static void\n finish_catch (struct objc_try_context **cur_try_context, tree curr_catch)\n {\n   struct objc_try_context *ct;\n@@ -3751,7 +3751,7 @@ finish_catch (struct objc_try_context **cur_try_context, tree curr_catch)\n     }\n \n   /* Pick up the new context we made in begin_try above...  */\n-  ct = *cur_try_context; \n+  ct = *cur_try_context;\n   func = build_function_call_vec (loc, objc2_end_catch_decl, NULL, NULL);\n   append_to_statement_list (func, &ct->finally_body);\n   try_exp = build_stmt (loc, TRY_FINALLY_EXPR, ct->try_body, ct->finally_body);\n@@ -3761,7 +3761,7 @@ finish_catch (struct objc_try_context **cur_try_context, tree curr_catch)\n   append_to_statement_list (curr_catch, &((*cur_try_context)->catch_list));\n }\n \n-static tree \n+static tree\n finish_try_stmt (struct objc_try_context **cur_try_context)\n {\n   struct objc_try_context *c = *cur_try_context;"}, {"sha": "d2606ff0d9814c58d0b994f14dcefcfdd5fece36", "filename": "gcc/objc/objc-runtime-hooks.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-runtime-hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-runtime-hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-runtime-hooks.h?ref=944fb7998bc4f4d47fa84fda494421da7669d085", "patch": "@@ -1,6 +1,6 @@\n /* Hooks to abstract the runtime meta-data generation for Objective C.\n    Copyright (C) 2011 Free Software Foundation, Inc.\n-   Contributed by Iain Sandoe \n+   Contributed by Iain Sandoe\n \n This file is part of GCC.\n \n@@ -23,27 +23,27 @@ along with GCC; see the file COPYING3.  If not see\n \n /* A set of hooks for the front end to obtain runtime-specific actions.  */\n \n-/* Objective-C supports several runtime library variants: \n+/* Objective-C supports several runtime library variants:\n \n    \"GNU\" runtime selected by -fgnu-runtime (currently at ABI version 8).\n    \"NeXT\" runtime (selected by -fnext-runtime) and installed on OSX/Darwin\n    systems at API version 1 (for m32 code) and version 2 (for m64 code).\n-   \n+\n    The runtimes require different data types/layouts, method call mechanisms\n    and so on, and the purpose of this interface is to abstract such\n    differences from the parser's perspective.  */\n \n /* TODO: Do we want the initial underscore ? */\n-typedef struct _objc_runtime_hooks_r \n+typedef struct _objc_runtime_hooks_r\n {\n   /* TODO: Expand comments in this file.  */\n \n   /* Initialize for this runtime.  */\n   void (*initialize) (void);\n   const char *default_constant_string_class_name;\n-  \n+\n   /* FIXME: Having to check this name should not be necessary.  */\n-  const char *tag_getclass; \n+  const char *tag_getclass;\n   /* id for superclass class field - named differently in the existing\n      runtimes.  */\n   tree (*super_superclassfield_ident) (void);\n@@ -78,21 +78,21 @@ typedef struct _objc_runtime_hooks_r\n   tree (*get_arg_type_list_base) (tree, int, int);\n   /* Build method call.  */\n   tree (*build_objc_method_call) (location_t, tree, tree, tree, tree, tree, int);\n-  \n+\n   /* Check for or otherwise handle a request to check that the constant\n      string class reference is set-up & OK.  */\n   bool (*setup_const_string_class_decl) (void);\n   /* Return the tree reprenting a const string constructor for the arg.\n      Most of the data are in global trees.  */\n   tree (*build_const_string_constructor) (location_t, tree, int);\n-  \n+\n   /* Exceptions.  */\n   tree (*build_throw_stmt) (location_t, tree, bool);\n   tree (*build_exc_ptr) (struct objc_try_context **);\n   tree (*begin_catch) (struct objc_try_context **, tree, tree, tree, bool);\n   void (*finish_catch) (struct objc_try_context **, tree);\n   tree (*finish_try_stmt) (struct objc_try_context **);\n-  \n+\n   /* Emit all the metadata required by the runtime - based on the tables built\n      during parsing.  */\n   void (*generate_metadata) (void);"}, {"sha": "78505f4d5e80dd65dc1f30f863d6d9a621bdcb46", "filename": "gcc/objc/objc-runtime-shared-support.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-runtime-shared-support.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-runtime-shared-support.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-runtime-shared-support.c?ref=944fb7998bc4f4d47fa84fda494421da7669d085", "patch": "@@ -159,8 +159,8 @@ build_selector (tree ident)\n \n /* struct _objc_super {\n      struct _objc_object *self;\n-     struct _objc_class *super_class; \n-     \t\t[or Class cls; for the abi v2]\n+     struct _objc_class *super_class;\n+\t\t[or Class cls; for the abi v2]\n    };  */\n \n void\n@@ -302,7 +302,7 @@ add_objc_string (tree ident, string_section section)\n {\n   tree *chain, decl, type;\n   char buf[BUFSIZE];\n-  \n+\n   switch (section)\n     {\n     case class_names:\n@@ -336,13 +336,13 @@ add_objc_string (tree ident, string_section section)\n     }\n \n   type = build_sized_array_type (char_type_node, IDENTIFIER_LENGTH (ident) + 1);\n-  /* Get a runtime-specific string decl which will be finish_var()'ed in \n+  /* Get a runtime-specific string decl which will be finish_var()'ed in\n      generate_strings ().  */\n   decl = (*runtime.string_decl) (type, buf, section);\n   TREE_CONSTANT (decl) = 1;\n   *chain = tree_cons (decl, ident, NULL_TREE);\n \n-  return convert (string_type_node, \n+  return convert (string_type_node,\n \t\t  build_unary_op (input_location, ADDR_EXPR, decl, 1));\n }\n \n@@ -442,7 +442,7 @@ init_module_descriptor (tree type, long vers)\n \n   /* No really useful place to point to.  */\n   loc = UNKNOWN_LOCATION;\n-  \n+\n   /* version = { 1, ... } */\n \n   expr = build_int_cst (long_integer_type_node, vers);\n@@ -463,7 +463,7 @@ init_module_descriptor (tree type, long vers)\n   /* symtab = { ..., _OBJC_SYMBOLS, ... } */\n \n   ltyp = build_pointer_type (xref_tag (RECORD_TYPE,\n-\t\t\t\t       get_identifier (UTAG_SYMTAB)));  \n+\t\t\t\t       get_identifier (UTAG_SYMTAB)));\n   if (UOBJC_SYMBOLS_decl)\n     expr = convert (ltyp, build_unary_op (loc,\n \t\t\t   ADDR_EXPR, UOBJC_SYMBOLS_decl, 0));\n@@ -519,7 +519,7 @@ build_module_descriptor (long vers, tree attr)\n   /* Allow the runtime to mark meta-data such that it can be assigned to target\n      specific sections by the back-end.  */\n   if (attr)\n-    DECL_ATTRIBUTES (UOBJC_MODULES_decl) = attr; \n+    DECL_ATTRIBUTES (UOBJC_MODULES_decl) = attr;\n \n   finish_var_decl (UOBJC_MODULES_decl,\n \t\t   init_module_descriptor (TREE_TYPE (UOBJC_MODULES_decl),\n@@ -640,7 +640,7 @@ build_next_selector_translation_table (void)\n       if (warn_selector)\n \t{\n \t  location_t loc;\n-\t  if (decl) \n+\t  if (decl)\n \t    loc = DECL_SOURCE_LOCATION (decl);\n \t  else\n \t    loc = UNKNOWN_LOCATION;\n@@ -652,7 +652,7 @@ build_next_selector_translation_table (void)\n       if (decl)\n \t{\n \t  /* Entries of this form are used for references to methods.\n-\t  The runtime re-writes these on start-up, but the compiler can't see \n+\t  The runtime re-writes these on start-up, but the compiler can't see\n \t  that and optimizes it away unless we force it.  */\n \t  DECL_PRESERVE_P (decl) = 1;\n \t  finish_var_decl (decl, expr);"}, {"sha": "ace9039552a912e377fb236195dc6d649386923b", "filename": "gcc/objc/objc-runtime-shared-support.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-runtime-shared-support.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-runtime-shared-support.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-runtime-shared-support.h?ref=944fb7998bc4f4d47fa84fda494421da7669d085", "patch": "@@ -1,6 +1,6 @@\n /* Support routines shared by all runtimes.\n    Copyright (C) 2011 Free Software Foundation, Inc.\n-   Contributed by Iain Sandoe \n+   Contributed by Iain Sandoe\n \n This file is part of GCC.\n "}, {"sha": "9086d22571cdf4bf22d163e9bc595448aef7889f", "filename": "gcc/objc/objc-tree.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fb7998bc4f4d47fa84fda494421da7669d085/gcc%2Fobjc%2Fobjc-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-tree.def?ref=944fb7998bc4f4d47fa84fda494421da7669d085", "patch": "@@ -64,7 +64,7 @@ DEFTREECODE (CLASS_REFERENCE_EXPR, \"class_reference_expr\", tcc_expression, 1)\n       it and we just need to swap Operand 2 in, and emit the deprecation\n       warnings from Operand 3 if needed.\n \n-  Please note that when the Objective-C 2.0 \"dot-syntax\" 'object.component' \n+  Please note that when the Objective-C 2.0 \"dot-syntax\" 'object.component'\n   is encountered, where 'component' is not a property but there are valid\n   setter/getter methods for it, an artificial PROPERTY_DECL is generated\n   and used in the PROPERTY_REF.  */"}]}