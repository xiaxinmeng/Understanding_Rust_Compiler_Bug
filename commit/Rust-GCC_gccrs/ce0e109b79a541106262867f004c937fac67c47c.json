{"sha": "ce0e109b79a541106262867f004c937fac67c47c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UwZTEwOWI3OWE1NDExMDYyNjI4NjdmMDA0YzkzN2ZhYzY3YzQ3Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-21T21:58:47Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-21T21:58:47Z"}, "message": "(reload): More accurately compute nongroup needs.\n\n(reloads_conflict): New function.\n\nFrom-SVN: r6838", "tree": {"sha": "63e868dfe2406d83490df994256eb47b8e984483", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63e868dfe2406d83490df994256eb47b8e984483"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce0e109b79a541106262867f004c937fac67c47c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce0e109b79a541106262867f004c937fac67c47c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce0e109b79a541106262867f004c937fac67c47c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce0e109b79a541106262867f004c937fac67c47c/comments", "author": null, "committer": null, "parents": [{"sha": "3bd4f3b8c9695ee63cab5169546199987e3bcdc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd4f3b8c9695ee63cab5169546199987e3bcdc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bd4f3b8c9695ee63cab5169546199987e3bcdc9"}], "stats": {"total": 218, "additions": 198, "deletions": 20}, "files": [{"sha": "ec6ceda6a1359ee2f077f99db61cdfa1e454d3eb", "filename": "gcc/reload1.c", "status": "modified", "additions": 198, "deletions": 20, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce0e109b79a541106262867f004c937fac67c47c/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce0e109b79a541106262867f004c937fac67c47c/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ce0e109b79a541106262867f004c937fac67c47c", "patch": "@@ -346,6 +346,7 @@ static int hard_reg_use_compare\t\tPROTO((struct hard_reg_n_uses *,\n \t\t\t\t\t       struct hard_reg_n_uses *));\n static void order_regs_for_reload\tPROTO((void));\n static void reload_as_needed\t\tPROTO((rtx, int));\n+static int reloads_conflict \t\tPROTO((int, int));\n static void forget_old_reloads_1\tPROTO((rtx, rtx));\n static int reload_reg_class_lower\tPROTO((short *, short *));\n static void mark_reload_reg_in_use\tPROTO((int, int, enum reload_type,\n@@ -929,40 +930,48 @@ reload (first, global, dumpfile)\n \t      /* These just count RELOAD_OTHER.  */\n \t      int insn_needs[N_REG_CLASSES];\n \t      int insn_groups[N_REG_CLASSES];\n+\t      int insn_nongroups[N_REG_CLASSES];\n \t      int insn_total_groups = 0;\n \n \t      /* Count RELOAD_FOR_INPUT reloads.  */\n \t      int insn_needs_for_inputs[N_REG_CLASSES];\n+\t      int insn_nongroups_for_inputs[N_REG_CLASSES];\n \t      int insn_groups_for_inputs[N_REG_CLASSES];\n \t      int insn_total_groups_for_inputs = 0;\n \n \t      /* Count RELOAD_FOR_OUTPUT reloads.  */\n \t      int insn_needs_for_outputs[N_REG_CLASSES];\n+\t      int insn_nongroups_for_outputs[N_REG_CLASSES];\n \t      int insn_groups_for_outputs[N_REG_CLASSES];\n \t      int insn_total_groups_for_outputs = 0;\n \n \t      /* Count RELOAD_FOR_INSN reloads.  */\n \t      int insn_needs_for_insn[N_REG_CLASSES];\n+\t      int insn_nongroups_for_insn[N_REG_CLASSES];\n \t      int insn_groups_for_insn[N_REG_CLASSES];\n \t      int insn_total_groups_for_insn = 0;\n \n \t      /* Count RELOAD_FOR_OTHER_ADDRESS reloads.  */\n \t      int insn_needs_for_other_addr[N_REG_CLASSES];\n+\t      int insn_nongroups_for_other_addr[N_REG_CLASSES];\n \t      int insn_groups_for_other_addr[N_REG_CLASSES];\n \t      int insn_total_groups_for_other_addr = 0;\n \n \t      /* Count RELOAD_FOR_INPUT_ADDRESS reloads.  */\n \t      int insn_needs_for_in_addr[MAX_RECOG_OPERANDS][N_REG_CLASSES];\n+\t      int insn_nongroups_for_in_addr[MAX_RECOG_OPERANDS][N_REG_CLASSES];\n \t      int insn_groups_for_in_addr[MAX_RECOG_OPERANDS][N_REG_CLASSES];\n \t      int insn_total_groups_for_in_addr[MAX_RECOG_OPERANDS];\n \n \t      /* Count RELOAD_FOR_OUTPUT_ADDRESS reloads.  */\n \t      int insn_needs_for_out_addr[MAX_RECOG_OPERANDS][N_REG_CLASSES];\n+\t      int insn_nongroups_for_out_addr[MAX_RECOG_OPERANDS][N_REG_CLASSES];\n \t      int insn_groups_for_out_addr[MAX_RECOG_OPERANDS][N_REG_CLASSES];\n \t      int insn_total_groups_for_out_addr[MAX_RECOG_OPERANDS];\n \n \t      /* Count RELOAD_FOR_OPERAND_ADDRESS reloads.  */\n \t      int insn_needs_for_op_addr[N_REG_CLASSES];\n+\t      int insn_nongroups_for_op_addr[N_REG_CLASSES];\n \t      int insn_groups_for_op_addr[N_REG_CLASSES];\n \t      int insn_total_groups_for_op_addr = 0;\n \n@@ -1059,12 +1068,27 @@ reload (first, global, dumpfile)\n \n \t      for (i = 0; i < N_REG_CLASSES; i++)\n \t\t{\n-\t\t  insn_needs[i] = 0, insn_groups[i] = 0;\n-\t\t  insn_needs_for_inputs[i] = 0, insn_groups_for_inputs[i] = 0;\n-\t\t  insn_needs_for_outputs[i] = 0, insn_groups_for_outputs[i] = 0;\n-\t\t  insn_needs_for_insn[i] = 0, insn_groups_for_insn[i] = 0;\n-\t\t  insn_needs_for_op_addr[i] = 0, insn_groups_for_op_addr[i] = 0;\n-\t\t  insn_needs_for_other_addr[i] = 0;\n+\t\t  insn_needs[i] = 0, insn_nongroups[i] = 0, \n+\t\t  insn_groups[i] = 0;\n+\n+\t\t  insn_needs_for_inputs[i] = 0, \n+\t\t  insn_nongroups_for_inputs[i] = 0,\n+\t\t  insn_groups_for_inputs[i] = 0;\n+\n+\t\t  insn_needs_for_outputs[i] = 0, \n+\t\t  insn_nongroups_for_outputs[i] = 0,\n+\t\t  insn_groups_for_outputs[i] = 0;\n+\n+\t\t  insn_needs_for_insn[i] = 0, \n+\t\t  insn_nongroups_for_insn[i] = 0,\n+\t\t  insn_groups_for_insn[i] = 0;\n+\n+\t\t  insn_needs_for_op_addr[i] = 0, \n+\t\t  insn_nongroups_for_op_addr[i] = 0,\n+\t\t  insn_groups_for_op_addr[i] = 0;\n+\n+\t\t  insn_needs_for_other_addr[i] = 0, \n+\t\t  insn_nongroups_for_other_addr[i] = 0,\n \t\t  insn_groups_for_other_addr[i] = 0;\n \t\t}\n \n@@ -1077,6 +1101,8 @@ reload (first, global, dumpfile)\n \t\t    {\n \t\t      insn_needs_for_in_addr[i][j] = 0;\n \t\t      insn_needs_for_out_addr[i][j] = 0;\n+\t\t      insn_nongroups_for_in_addr[i][j] = 0;\n+\t\t      insn_nongroups_for_out_addr[i][j] = 0;\n \t\t      insn_groups_for_in_addr[i][j] = 0;\n \t\t      insn_groups_for_out_addr[i][j] = 0;\n \t\t    }\n@@ -1091,6 +1117,7 @@ reload (first, global, dumpfile)\n \t\t  enum reg_class class = reload_reg_class[i];\n \t\t  int size;\n \t\t  enum machine_mode mode;\n+\t\t  int nongroup_need;\n \t\t  int *this_groups;\n \t\t  int *this_needs;\n \t\t  int *this_total_groups;\n@@ -1115,55 +1142,93 @@ reload (first, global, dumpfile)\n \t\t      new_basic_block_needs = 1;\n \t\t    }\n \n+\t\t  /* If this class doesn't want a group determine if\n+\t\t     we have a nongroup need or a regular need. */\n+\n+\t\t  nongroup_need = 0;\n+\t\t  if (CLASS_MAX_NREGS (class, mode) == 1)\n+\t\t    for (j = i + 1; j < n_reloads; j++)\n+\t\t      if (reloads_conflict (i, j)\n+\t\t\t  && reg_classes_intersect_p (class,\n+\t\t\t\t\t\t      reload_reg_class[j]))\n+\t\t\t{\n+\t\t\t  nongroup_need = 1;\n+\t\t\t  break;\n+\t\t\t}\n+\n \t\t  /* Decide which time-of-use to count this reload for.  */\n \t\t  switch (reload_when_needed[i])\n \t\t    {\n \t\t    case RELOAD_OTHER:\n-\t\t      this_needs = insn_needs;\n+\t\t      if (nongroup_need)\n+\t\t\tthis_needs = insn_nongroups;\n+\t\t      else\n+\t\t\tthis_needs = insn_needs;\n \t\t      this_groups = insn_groups;\n \t\t      this_total_groups = &insn_total_groups;\n \t\t      break;\n \n \t\t    case RELOAD_FOR_INPUT:\n-\t\t      this_needs = insn_needs_for_inputs;\n+\t\t      if (nongroup_need)\n+\t\t\tthis_needs = insn_nongroups_for_inputs;\n+\t\t      else\n+\t\t\tthis_needs = insn_needs_for_inputs;\n \t\t      this_groups = insn_groups_for_inputs;\n \t\t      this_total_groups = &insn_total_groups_for_inputs;\n \t\t      break;\n \n \t\t    case RELOAD_FOR_OUTPUT:\n-\t\t      this_needs = insn_needs_for_outputs;\n+\t\t      if (nongroup_need)\n+\t\t\tthis_needs = insn_nongroups_for_outputs;\n+\t\t      else\n+\t\t\tthis_needs = insn_needs_for_outputs;\n \t\t      this_groups = insn_groups_for_outputs;\n \t\t      this_total_groups = &insn_total_groups_for_outputs;\n \t\t      break;\n \n \t\t    case RELOAD_FOR_INSN:\n-\t\t      this_needs = insn_needs_for_insn;\n+\t\t      if (nongroup_need)\n+\t\t\tthis_needs = insn_nongroups_for_insn;\n+\t\t      else\n+\t\t\tthis_needs = insn_needs_for_insn;\n \t\t      this_groups = insn_groups_for_insn;\n \t\t      this_total_groups = &insn_total_groups_for_insn;\n \t\t      break;\n \n \t\t    case RELOAD_FOR_OTHER_ADDRESS:\n-\t\t      this_needs = insn_needs_for_other_addr;\n+\t\t      if (nongroup_need)\n+\t\t\tthis_needs = insn_nongroups_for_other_addr;\n+\t\t      else\n+\t\t\tthis_needs = insn_needs_for_other_addr;\n \t\t      this_groups = insn_groups_for_other_addr;\n \t\t      this_total_groups = &insn_total_groups_for_other_addr;\n \t\t      break;\n \n \t\t    case RELOAD_FOR_INPUT_ADDRESS:\n-\t\t      this_needs = insn_needs_for_in_addr[reload_opnum[i]];\n+\t\t      if (nongroup_need)\n+\t\t\tthis_needs = insn_nongroups_for_in_addr[reload_opnum[i]];\n+\t\t      else\n+\t\t\tthis_needs = insn_needs_for_in_addr[reload_opnum[i]];\n \t\t      this_groups = insn_groups_for_in_addr[reload_opnum[i]];\n \t\t      this_total_groups\n \t\t\t= &insn_total_groups_for_in_addr[reload_opnum[i]];\n \t\t      break;\n \n \t\t    case RELOAD_FOR_OUTPUT_ADDRESS:\n-\t\t      this_needs = insn_needs_for_out_addr[reload_opnum[i]];\n+\t\t      if (nongroup_need)\n+\t\t\tthis_needs = insn_nongroups_for_out_addr[reload_opnum[i]];\n+\t\t      else\n+\t\t\tthis_needs = insn_needs_for_out_addr[reload_opnum[i]];\n \t\t      this_groups = insn_groups_for_out_addr[reload_opnum[i]];\n \t\t      this_total_groups\n \t\t\t= &insn_total_groups_for_out_addr[reload_opnum[i]];\n \t\t      break;\n \n \t\t    case RELOAD_FOR_OPERAND_ADDRESS:\n-\t\t      this_needs = insn_needs_for_op_addr;\n+\t\t      if (nongroup_need)\n+\t\t\tthis_needs = insn_nongroups_for_op_addr;\n+\t\t      else\n+\t\t\tthis_needs = insn_needs_for_op_addr;\n \t\t      this_groups = insn_groups_for_op_addr;\n \t\t      this_total_groups = &insn_total_groups_for_op_addr;\n \t\t      break;\n@@ -1259,6 +1324,27 @@ reload (first, global, dumpfile)\n \t\t\t\t\t     insn_needs_for_outputs[i]),\n \t\t\t\t\tinsn_needs_for_other_addr[i]);\n \n+\t\t  for (in_max = 0, out_max = 0, j = 0;\n+\t\t       j < reload_n_operands; j++)\n+\t\t    {\n+\t\t      in_max = MAX (in_max, insn_nongroups_for_in_addr[j][i]);\n+\t\t      out_max = MAX (out_max, insn_nongroups_for_out_addr[j][i]);\n+\t\t    }\n+\n+\t\t  in_max = MAX (in_max, insn_nongroups_for_op_addr[i]);\n+\t\t  out_max = MAX (out_max, insn_nongroups_for_insn[i]);\n+\n+\t\t  insn_nongroups_for_inputs[i]\n+\t\t    = MAX (insn_nongroups_for_inputs[i]\n+\t\t\t   + insn_nongroups_for_op_addr[i]\n+\t\t\t   + insn_nongroups_for_insn[i],\n+\t\t\t   in_max + insn_nongroups_for_inputs[i]);\n+\n+\t\t  insn_nongroups_for_outputs[i] += out_max;\n+\t\t  insn_nongroups[i] += MAX (MAX (insn_nongroups_for_inputs[i],\n+\t\t\t\t\t\t insn_nongroups_for_outputs[i]),\n+\t\t\t\t\t    insn_nongroups_for_other_addr[i]);\n+\n \t\t  for (in_max = 0, out_max = 0, j = 0;\n \t\t       j < reload_n_operands; j++)\n \t\t    {\n@@ -1435,12 +1521,11 @@ reload (first, global, dumpfile)\n \t\t      max_groups[i] = insn_groups[i];\n \t\t      max_groups_insn[i] = insn;\n \t\t    }\n-\t\t  if (insn_total_groups > 0)\n-\t\t    if (max_nongroups[i] < insn_needs[i])\n-\t\t      {\n-\t\t\tmax_nongroups[i] = insn_needs[i];\n-\t\t\tmax_nongroups_insn[i] = insn;\n-\t\t      }\n+\t\t  if (max_nongroups[i] < insn_nongroups[i])\n+\t\t    {\n+\t\t      max_nongroups[i] = insn_nongroups[i];\n+\t\t      max_nongroups_insn[i] = insn;\n+\t\t    }\n \t\t}\n \t    }\n \t  /* Note that there is a continue statement above.  */\n@@ -3970,6 +4055,99 @@ forget_old_reloads_1 (x, ignored)\n     if (n_reloads == 0 || reg_has_output_reload[regno + nr] == 0)\n       reg_last_reload_reg[regno + nr] = 0;\n }\n+\n+/* 1 if reload1 and reload2 conflict with each other */\n+\n+static int\n+reloads_conflict (reload1, reload2)\n+int reload1, reload2;\n+{\n+  int i;\n+  enum reload_type reload1_type = reload_when_needed[reload1];\n+  enum reload_type reload2_type = reload_when_needed[reload2];\n+  int reload1_opnum = reload_opnum[reload1];\n+  int reload2_opnum = reload_opnum[reload2];\n+\n+  /* RELOAD_OTHER conflicts with everything. */\n+  \n+  if (reload1_type == RELOAD_OTHER \n+      || reload2_type == RELOAD_OTHER)\n+    return 1;\n+\n+  switch (reload1_type)\n+    {\n+    case RELOAD_FOR_OTHER_ADDRESS:\n+      if (reload2_type == RELOAD_FOR_OTHER_ADDRESS)\n+\treturn 1;\n+      break;\n+\n+    case RELOAD_FOR_INPUT:\n+      if (reload2_type == RELOAD_FOR_INSN \n+\t  || reload2_type == RELOAD_FOR_OPERAND_ADDRESS\n+\t  || reload2_type == RELOAD_FOR_INPUT)\n+\treturn 1;\n+\n+      /* RELOAD_FOR_INPUT conflicts with any later\n+\t RELOAD_FOR_INPUT_ADDRESS reloads */\n+      for (i = reload2_opnum + 1; i < n_reloads; i++) \n+\tif (reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS) \n+\t  return 1;\n+      break;\n+\n+    case RELOAD_FOR_INPUT_ADDRESS:\n+      if (reload2_type == RELOAD_FOR_INPUT_ADDRESS \n+\t  && (reload1_opnum == reload2_opnum))\n+\treturn 1;\n+\n+      /* RELOAD_FOR_INPUT_ADDRESS conflicts with any\n+\t earlier RELOAD_FOR_INPUT reloads */\n+      for (i = 0; i < reload2_opnum; i++)\n+\tif (reload_when_needed[i] == RELOAD_FOR_INPUT)\n+\t  return 1;\n+      break;\n+\n+    case RELOAD_FOR_OUTPUT_ADDRESS:\n+      if (reload2_type == RELOAD_FOR_OUTPUT_ADDRESS\n+\t  && (reload1_opnum == reload2_opnum))\n+\treturn 1;\n+\n+      for (i = reload2_opnum; i < n_reloads; i++)\n+\tif (reload_when_needed[i] == RELOAD_FOR_INPUT)\n+\t  return 1;\n+      break;\n+\n+    case RELOAD_FOR_OPERAND_ADDRESS:\n+      if (reload2_type == RELOAD_FOR_INPUT \n+\t  || reload2_type == RELOAD_FOR_INSN\n+\t  || reload2_type == RELOAD_FOR_OPERAND_ADDRESS)\n+\t  return 1;\n+      break;\n+\n+    case RELOAD_FOR_OUTPUT:\n+      if (reload2_type == RELOAD_FOR_INSN \n+\t  || reload2_type == RELOAD_FOR_OUTPUT)\n+\t  return 1;\n+\n+      for (i = 0; i <= reload2_opnum; i++)\n+\tif (reload_when_needed[i] == RELOAD_FOR_OUTPUT_ADDRESS)\n+\t  return 1;\n+      break;\n+\n+    case RELOAD_FOR_INSN:\n+      if (reload2_type == RELOAD_FOR_INPUT\n+\t  || reload2_type == RELOAD_FOR_OUTPUT\n+\t  || reload2_type == RELOAD_FOR_INSN\n+\t  || reload2_type == RELOAD_FOR_OPERAND_ADDRESS\n+\t  || reload2_type == RELOAD_FOR_OTHER_ADDRESS)\n+\treturn 1;\n+      break;\n+    }\n+\n+  /* No conflict */\n+  return 0;\n+}\n+\n+\n \f\n /* For each reload, the mode of the reload register.  */\n static enum machine_mode reload_mode[MAX_RELOADS];"}]}