{"sha": "732dcb6f2a8254467d15cffc3cebf3467c4d010f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMyZGNiNmYyYTgyNTQ0NjdkMTVjZmZjM2NlYmYzNDY3YzRkMDEwZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-04-03T14:13:24Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-04-03T14:13:24Z"}, "message": "Implement empty base optimization.\n\n\t* class.c (finish_struct_1): Add vbase fields earlier.  Set\n\tCLASSTYPE_SIZE of an empty base to 0.  Types with bases can be empty.\n\t* search.c (dfs_check_overlap, dfs_no_overlap_yet): New fns.\n\t(types_overlap_p): New fn.\n\t* tree.c (avoid_overlap): New fn.\n\t(build_base_fields): Use it to avoid overlapping empty bases.\n\t* cp-tree.h, decl2.c, lang-options.h: Add -fnew-abi.\n\nFrom-SVN: r18978", "tree": {"sha": "78b6049387f4015025e8331467e00ee2485df68d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78b6049387f4015025e8331467e00ee2485df68d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/732dcb6f2a8254467d15cffc3cebf3467c4d010f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/732dcb6f2a8254467d15cffc3cebf3467c4d010f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/732dcb6f2a8254467d15cffc3cebf3467c4d010f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/732dcb6f2a8254467d15cffc3cebf3467c4d010f/comments", "author": null, "committer": null, "parents": [{"sha": "e9eaed43b9308d4da24ffde5b108a2962da959d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9eaed43b9308d4da24ffde5b108a2962da959d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9eaed43b9308d4da24ffde5b108a2962da959d4"}], "stats": {"total": 171, "additions": 152, "deletions": 19}, "files": [{"sha": "99555d8bc4f9d1de5ba9a69d6168afdd2521cf56", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732dcb6f2a8254467d15cffc3cebf3467c4d010f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732dcb6f2a8254467d15cffc3cebf3467c4d010f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=732dcb6f2a8254467d15cffc3cebf3467c4d010f", "patch": "@@ -1,5 +1,14 @@\n Fri Apr  3 02:22:59 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n+\tImplement empty base optimization.\n+\t* class.c (finish_struct_1): Add vbase fields earlier.  Set \n+\tCLASSTYPE_SIZE of an empty base to 0.  Types with bases can be empty.\n+\t* search.c (dfs_check_overlap, dfs_no_overlap_yet): New fns.\n+\t(types_overlap_p): New fn.\n+\t* tree.c (avoid_overlap): New fn.\n+\t(build_base_fields): Use it to avoid overlapping empty bases.\n+\t* cp-tree.h, decl2.c, lang-options.h: Add -fnew-abi.\n+\n \t* decl.c (cplus_expand_expr_stmt): Strip unused INDIRECT_REFs.\n \n \tRe-implement allocation of base class subobjects."}, {"sha": "dc4cc313cf064d425f961158e78c14adbdc72eb8", "filename": "gcc/cp/class.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732dcb6f2a8254467d15cffc3cebf3467c4d010f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732dcb6f2a8254467d15cffc3cebf3467c4d010f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=732dcb6f2a8254467d15cffc3cebf3467c4d010f", "patch": "@@ -3131,7 +3131,6 @@ finish_struct_1 (t, warn_anon)\n       cant_have_const_ctor = base_info.cant_have_const_ctor;\n       no_const_asn_ref = base_info.no_const_asn_ref;\n       aggregate = 0;\n-      empty = 0;\n     }\n   else\n     {\n@@ -3209,6 +3208,9 @@ finish_struct_1 (t, warn_anon)\n \t}\n     }\n \n+  if (n_baseclasses)\n+    fields = chainon (build_vbase_pointer_fields (t), fields);\n+\n   last_x = NULL_TREE;\n   for (x = fields; x; x = TREE_CHAIN (x))\n     {\n@@ -3757,9 +3759,6 @@ finish_struct_1 (t, warn_anon)\n     \n   }\n \n-  if (n_baseclasses)\n-    fields = chainon (build_vbase_pointer_fields (t), fields);\n-\n   if (vfield == NULL_TREE && has_virtual)\n     {\n       /* We build this decl with ptr_type_node, and\n@@ -3852,21 +3851,33 @@ finish_struct_1 (t, warn_anon)\n   TYPE_FIELDS (t) = fields;\n \n   if (n_baseclasses)\n-    TYPE_FIELDS (t) = chainon (build_base_fields (t), fields);\n-  else if (empty)\n+    {\n+      last_x = build_base_fields (t);\n+\n+      /* If all our bases are empty, we can be empty too.  */\n+      for (x = last_x; empty && x; x = TREE_CHAIN (x))\n+\tif (DECL_SIZE (x) != integer_zero_node)\n+\t  empty = 0;\n+    }\n+  if (empty)\n     {\n       /* C++: do not let empty structures exist.  */\n       tree decl = build_lang_field_decl\n \t(FIELD_DECL, NULL_TREE, char_type_node);\n-      TREE_CHAIN (decl) = TYPE_FIELDS (t);\n+      TREE_CHAIN (decl) = fields;\n       TYPE_FIELDS (t) = decl;\n     }\n+  if (n_baseclasses)\n+    TYPE_FIELDS (t) = chainon (last_x, TYPE_FIELDS (t));\n \n   layout_type (t);\n \n   /* Remember the size and alignment of the class before adding\n      the virtual bases.  */\n-  CLASSTYPE_SIZE (t) = TYPE_SIZE (t);\n+  if (empty && flag_new_abi)\n+    CLASSTYPE_SIZE (t) = integer_zero_node;\n+  else\n+    CLASSTYPE_SIZE (t) = TYPE_SIZE (t);\n   CLASSTYPE_ALIGN (t) = TYPE_ALIGN (t);\n \n   finish_struct_anon (t);"}, {"sha": "443c83edc4fed18382f8b5cc4519fedd650c1854", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732dcb6f2a8254467d15cffc3cebf3467c4d010f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732dcb6f2a8254467d15cffc3cebf3467c4d010f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=732dcb6f2a8254467d15cffc3cebf3467c4d010f", "patch": "@@ -1914,6 +1914,10 @@ extern int flag_implicit_templates;\n \n extern int flag_weak;\n \n+/* Nonzero to enable experimental ABI changes.  */\n+\n+extern int flag_new_abi;\n+\n /* Nonzero if we're done parsing and into end-of-file activities.  */\n \n extern int at_eof;"}, {"sha": "cf9b07680ce6357329a64bcabdf3c00f4b8314a6", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732dcb6f2a8254467d15cffc3cebf3467c4d010f/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732dcb6f2a8254467d15cffc3cebf3467c4d010f/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=732dcb6f2a8254467d15cffc3cebf3467c4d010f", "patch": "@@ -401,6 +401,8 @@ int flag_new_for_scope = 1;\n \n int flag_weak = 1;\n \n+int flag_new_abi = 1;\n+\n /* Maximum template instantiation depth. Must be at least 17 for ANSI\n    compliance. */\n \n@@ -467,7 +469,8 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"check-new\", &flag_check_new, 1},\n   {\"repo\", &flag_use_repository, 1},\n   {\"for-scope\", &flag_new_for_scope, 2},\n-  {\"weak\", &flag_weak, 1}\n+  {\"weak\", &flag_weak, 1},\n+  {\"new-abi\", &flag_new_abi, 1}\n };\n \n /* Decode the string P as a language-specific option."}, {"sha": "f4f262dc062c47d45c93f9903cc4579215c992fa", "filename": "gcc/cp/lang-options.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732dcb6f2a8254467d15cffc3cebf3467c4d010f/gcc%2Fcp%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732dcb6f2a8254467d15cffc3cebf3467c4d010f/gcc%2Fcp%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-options.h?ref=732dcb6f2a8254467d15cffc3cebf3467c4d010f", "patch": "@@ -67,6 +67,8 @@ Boston, MA 02111-1307, USA.  */\n   \"-fmemoize-lookups\",\n   \"-fno-memoize-lookups\",\n   \"-fname-mangling-version-\",\n+  \"-fnew-abi\",\n+  \"-fno-new-abi\",\n   \"-fnonnull-objects\",\n   \"-fno-nonnull-objects\",\n   \"-foperator-names\","}, {"sha": "488220adc2abffb4fe55be20e6d7a5f167f0250b", "filename": "gcc/cp/search.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732dcb6f2a8254467d15cffc3cebf3467c4d010f/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732dcb6f2a8254467d15cffc3cebf3467c4d010f/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=732dcb6f2a8254467d15cffc3cebf3467c4d010f", "patch": "@@ -3830,3 +3830,49 @@ get_template_base (template, binfo)\n \n   return rval;\n }\n+\n+/* Check whether the empty class indicated by EMPTY_BINFO is also present\n+   at offset 0 in COMPARE_TYPE, and set found_overlap if so.  */\n+\n+static tree compare_type;\n+static int found_overlap;\n+static void\n+dfs_check_overlap (empty_binfo)\n+     tree empty_binfo;\n+{\n+  tree binfo;\n+  for (binfo = TYPE_BINFO (compare_type); ; binfo = BINFO_BASETYPE (binfo, 0))\n+    {\n+      if (BINFO_TYPE (binfo) == BINFO_TYPE (empty_binfo))\n+\t{\n+\t  found_overlap = 1;\n+\t  break;\n+\t}\n+      else if (BINFO_BASETYPES (binfo) == NULL_TREE)\n+\tbreak;\n+    }\n+}\n+\n+/* Trivial function to stop base traversal when we find something.  */\n+\n+static int\n+dfs_no_overlap_yet (t)\n+     tree t;\n+{\n+  return found_overlap == 0;\n+}\n+\n+/* Returns nonzero if EMPTY_TYPE or any of its bases can also be found at\n+   offset 0 in NEXT_TYPE.  Used in laying out empty base class subobjects.  */\n+\n+int\n+types_overlap_p (empty_type, next_type)\n+     tree empty_type, next_type;\n+{\n+  if (! IS_AGGR_TYPE (next_type))\n+    return 0;\n+  compare_type = next_type;\n+  found_overlap = 0;\n+  dfs_walk (TYPE_BINFO (empty_type), dfs_check_overlap, dfs_no_overlap_yet);\n+  return found_overlap;\n+}"}, {"sha": "b314185605bf5b7d6a66938829e97d07bb0ad477", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 68, "deletions": 10, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732dcb6f2a8254467d15cffc3cebf3467c4d010f/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732dcb6f2a8254467d15cffc3cebf3467c4d010f/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=732dcb6f2a8254467d15cffc3cebf3467c4d010f", "patch": "@@ -750,6 +750,28 @@ layout_basetypes (rec, max)\n   return max;\n }\n \n+/* If the empty base field in DECL overlaps with a base of the same type in\n+   NEWDECL, which is either another base field or the first data field of\n+   the class, pad the base just before NEWDECL and return 1.  Otherwise,\n+   return 0.  */\n+\n+static int\n+avoid_overlap (decl, newdecl)\n+     tree decl, newdecl;\n+{\n+  tree field;\n+\n+  if (newdecl == NULL_TREE\n+      || ! types_overlap_p (TREE_TYPE (decl), TREE_TYPE (newdecl)))\n+    return 0;\n+\n+  for (field = decl; TREE_CHAIN (field) && TREE_CHAIN (field) != newdecl;\n+       field = TREE_CHAIN (field))\n+    ;\n+\n+  DECL_SIZE (field) = integer_one_node;\n+}\n+\n /* Returns a list of fields to stand in for the base class subobjects\n    of REC.  These fields are later removed by layout_basetypes.  */\n \n@@ -762,8 +784,8 @@ build_base_fields (rec)\n   tree base_decls = NULL_TREE;\n   tree binfos = TYPE_BINFO_BASETYPES (rec);\n   int n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-  tree decl;\n-  int i;\n+  tree decl, nextdecl;\n+  int i, saw_empty = 0;\n   unsigned int base_align = 0;\n \n   for (i = 0; i < n_baseclasses; ++i)\n@@ -787,18 +809,54 @@ build_base_fields (rec)\n       TREE_CHAIN (decl) = base_decls;\n       base_decls = decl;\n \n-      /* Brain damage for backwards compatibility.  For no good reason, the\n-\t old layout_basetypes made every base at least as large as the\n-\t alignment for the bases up to that point, gratuitously wasting\n-\t space.  So we do the same thing here.  */\n-      base_align = MAX (base_align, DECL_ALIGN (decl));\n-      DECL_SIZE (decl) = size_int (MAX (TREE_INT_CST_LOW (DECL_SIZE (decl)),\n-\t\t\t\t\tbase_align));\n+      if (! flag_new_abi)\n+\t{\n+\t  /* Brain damage for backwards compatibility.  For no good reason,\n+\t     the old layout_basetypes made every base at least as large as\n+\t     the alignment for the bases up to that point, gratuitously\n+\t     wasting space.  So we do the same thing here.  */\n+\t  base_align = MAX (base_align, DECL_ALIGN (decl));\n+\t  DECL_SIZE (decl)\n+\t    = size_int (MAX (TREE_INT_CST_LOW (DECL_SIZE (decl)),\n+\t\t\t     base_align));\n+\t}\n+      else if (DECL_SIZE (decl) == integer_zero_node)\n+\tsaw_empty = 1;\n     }\n \n   /* Reverse the list of fields so we allocate the bases in the proper\n      order.  */\n-  return nreverse (base_decls);\n+  base_decls = nreverse (base_decls);\n+\n+  /* In the presence of empty base classes, we run the risk of allocating\n+     two objects of the same class on top of one another.  Avoid that.  */\n+  if (flag_new_abi && saw_empty)\n+    for (decl = base_decls; decl; decl = TREE_CHAIN (decl))\n+      {\n+\tif (DECL_SIZE (decl) == integer_zero_node)\n+\t  {\n+\t    /* First step through the following bases until we find\n+\t       an overlap or a non-empty base.  */\n+\t    for (nextdecl = TREE_CHAIN (decl); nextdecl;\n+\t\t nextdecl = TREE_CHAIN (nextdecl))\n+\t      {\n+\t\tif (avoid_overlap (decl, nextdecl)\n+\t\t    || DECL_SIZE (nextdecl) != integer_zero_node)\n+\t\t  goto nextbase;\n+\t      }\n+\n+\t    /* If we're still looking, also check against the first\n+\t       field.  */\n+\t    for (nextdecl = TYPE_FIELDS (rec);\n+\t\t nextdecl && TREE_CODE (nextdecl) != FIELD_DECL;\n+\t\t nextdecl = TREE_CHAIN (nextdecl))\n+\t      /* keep looking */;\n+\t    avoid_overlap (decl, nextdecl);\n+\t  }\n+      nextbase:;\n+      }\n+\n+  return base_decls;\n }\n \n /* Returns list of virtual base class pointers in a FIELD_DECL chain.  */"}]}