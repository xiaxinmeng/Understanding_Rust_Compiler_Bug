{"sha": "42cbdeac683d395849c9fee5e3e07b6a00093c5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJjYmRlYWM2ODNkMzk1ODQ5YzlmZWU1ZTNlMDdiNmEwMDA5M2M1YQ==", "commit": {"author": {"name": "Victor Kaplansky", "email": "victork@il.ibm.com", "date": "2007-09-17T09:37:31Z"}, "committer": {"name": "Victor Kaplansky", "email": "victork@gcc.gnu.org", "date": "2007-09-17T09:37:31Z"}, "message": "re PR tree-optimization/33319 (g++.dg/tree-ssa/pr27549.C ICE with vectorization)\n\n\n        PR tree-optimization/33319\n        * tree-vect-analyze.c (vect_same_range_drs): New.\n        (vect_vfa_range_equal): New.\n        (vect_is_duplicate_ddr): Removed.\n        (vect_mark_for_runtime_alias_test): Do not perform marking when\n        optimizing for size or max_param for alias checking is zero.\n        Move the function before vect_analyze_data_ref_dependence.\n        (vect_analyze_data_ref_dependence): Add call to\n        vect_mark_for_runtime_alias_test in two cases when dependence\n        is not clear.\n        (vect_analyze_data_ref_dependences): Do not call to\n        vect_mark_for_runtime_alias_test.\n        (vect_prune_runtime_alias_test_list): New.\n        (vect_analyze_loop): Add call to vect_prune_runtime_alias_test_list.\n        * tree-vect-transform.c (vect_estimate_min_profitable_iters):\n        Update vec_outside_cost.\n        (vect_vfa_segment_size): More compact code, use TYPE_SIZE_UNIT.\n        (vect_create_cond_for_alias_checks): Build the base address of data\n        reference from DR_GROUP_FIRST_DR.\n        (vect_loop_versioning): New.\n        (vect_transform_loop): Add a call to vect_loop_versioning.\n        Remove factored out code.\n\nFrom-SVN: r128539", "tree": {"sha": "6c4cbac41c92d399625c0f73e00db5b78e435def", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c4cbac41c92d399625c0f73e00db5b78e435def"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42cbdeac683d395849c9fee5e3e07b6a00093c5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42cbdeac683d395849c9fee5e3e07b6a00093c5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42cbdeac683d395849c9fee5e3e07b6a00093c5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42cbdeac683d395849c9fee5e3e07b6a00093c5a/comments", "author": null, "committer": null, "parents": [{"sha": "2adde4ffdc7d4e2b529bd7c8a82afa73d8bbf775", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2adde4ffdc7d4e2b529bd7c8a82afa73d8bbf775", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2adde4ffdc7d4e2b529bd7c8a82afa73d8bbf775"}], "stats": {"total": 535, "additions": 335, "deletions": 200}, "files": [{"sha": "2099869bbe2ebccb5fb73b56f23c123346ae2db3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42cbdeac683d395849c9fee5e3e07b6a00093c5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42cbdeac683d395849c9fee5e3e07b6a00093c5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=42cbdeac683d395849c9fee5e3e07b6a00093c5a", "patch": "@@ -1,3 +1,28 @@\n+2007-09-17  Victor Kaplansky  <victork@il.ibm.com>\n+\n+\tPR tree-optimization/33319\n+\t* tree-vect-analyze.c (vect_same_range_drs): New.\n+\t(vect_vfa_range_equal): New.\n+\t(vect_is_duplicate_ddr): Removed.\n+\t(vect_mark_for_runtime_alias_test): Do not perform marking when\n+\toptimizing for size or max_param for alias checking is zero.\n+\tMove the function before vect_analyze_data_ref_dependence.\n+\t(vect_analyze_data_ref_dependence): Add call to\n+\tvect_mark_for_runtime_alias_test in two cases when dependence\n+\tis not clear.\n+\t(vect_analyze_data_ref_dependences): Do not call to\n+\tvect_mark_for_runtime_alias_test.\n+\t(vect_prune_runtime_alias_test_list): New.\n+\t(vect_analyze_loop): Add call to vect_prune_runtime_alias_test_list.\n+\t* tree-vect-transform.c (vect_estimate_min_profitable_iters):\n+\tUpdate vec_outside_cost.\n+\t(vect_vfa_segment_size): More compact code, use TYPE_SIZE_UNIT.\n+\t(vect_create_cond_for_alias_checks): Build the base address of data\n+\treference from DR_GROUP_FIRST_DR.\n+\t(vect_loop_versioning): New.\n+\t(vect_transform_loop): Add a call to vect_loop_versioning.\n+\tRemove factored out code.\n+\n 2007-09-16  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR middle-end/33273"}, {"sha": "86ca6b65ca4711ed41db97db3bb7480e62c8039e", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 165, "deletions": 91, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42cbdeac683d395849c9fee5e3e07b6a00093c5a/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42cbdeac683d395849c9fee5e3e07b6a00093c5a/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=42cbdeac683d395849c9fee5e3e07b6a00093c5a", "patch": "@@ -1118,11 +1118,85 @@ vect_check_interleaving (struct data_reference *dra,\n     }\n }\n \n+/* Check if data references pointed by DR_I and DR_J are same or\n+   belong to same interleaving group.  Return FALSE if drs are\n+   different, otherwise return TRUE.  */\n+\n+static bool\n+vect_same_range_drs (data_reference_p dr_i, data_reference_p dr_j)\n+{\n+  tree stmt_i = DR_STMT (dr_i);\n+  tree stmt_j = DR_STMT (dr_j);\n+\n+  if (operand_equal_p (DR_REF (dr_i), DR_REF (dr_j), 0)\n+      || (DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt_i))\n+\t    && DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt_j))\n+\t    && (DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt_i))\n+\t\t== DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt_j)))))\n+    return true;\n+  else\n+    return false;\n+}\n+\n+/* If address ranges represented by DDR_I and DDR_J are equal,\n+   return TRUE, otherwise return FALSE.  */\n+\n+static bool\n+vect_vfa_range_equal (ddr_p ddr_i, ddr_p ddr_j)\n+{\n+  if ((vect_same_range_drs (DDR_A (ddr_i), DDR_A (ddr_j))\n+       && vect_same_range_drs (DDR_B (ddr_i), DDR_B (ddr_j)))\n+      || (vect_same_range_drs (DDR_A (ddr_i), DDR_B (ddr_j))\n+\t  && vect_same_range_drs (DDR_B (ddr_i), DDR_A (ddr_j))))\n+    return true;\n+  else\n+    return false;\n+}\n+\n+/* Insert DDR into LOOP_VINFO list of ddrs that may alias and need to be\n+   tested at run-time.  Return TRUE if DDR was successfully inserted.\n+   Return false if versioning is not supported.  */\n+\n+static bool\n+vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n+{\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+\n+  if ((unsigned) PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS) == 0)\n+    return false;\n+\n+  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+    {\n+      fprintf (vect_dump, \"mark for run-time aliasing test between \");\n+      print_generic_expr (vect_dump, DR_REF (DDR_A (ddr)), TDF_SLIM);\n+      fprintf (vect_dump, \" and \");\n+      print_generic_expr (vect_dump, DR_REF (DDR_B (ddr)), TDF_SLIM);\n+    }\n+\n+  if (optimize_size)\n+    {\n+      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\tfprintf (vect_dump, \"versioning not supported when optimizing for size.\");\n+      return false;\n+    }\n+\n+  /* FORNOW: We don't support versioning with outer-loop vectorization.  */\n+  if (loop->inner)\n+    {\n+      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\tfprintf (vect_dump, \"versioning not yet supported for outer-loops.\");\n+      return false;\n+    }\n+\n+  VEC_safe_push (ddr_p, heap, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo), ddr);\n+  return true;\n+}\n \n /* Function vect_analyze_data_ref_dependence.\n \n    Return TRUE if there (might) exist a dependence between a memory-reference\n-   DRA and a memory-reference DRB.  */\n+   DRA and a memory-reference DRB.  When versioning for alias may check a\n+   dependence at run-time, return FALSE.  */\n       \n static bool\n vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n@@ -1160,7 +1234,8 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n           fprintf (vect_dump, \" and \");\n           print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n         }\n-      return true;\n+      /* Add to list of ddrs that need to be tested at run-time.  */\n+      return !vect_mark_for_runtime_alias_test (ddr, loop_vinfo);\n     }\n \n   if (DDR_NUM_DIST_VECTS (ddr) == 0)\n@@ -1172,7 +1247,8 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n           fprintf (vect_dump, \" and \");\n           print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n         }\n-      return true;\n+      /* Add to list of ddrs that need to be tested at run-time.  */\n+      return !vect_mark_for_runtime_alias_test (ddr, loop_vinfo);\n     }    \n \n   loop_depth = index_in_loop_nest (loop->num, DDR_LOOP_NEST (ddr));\n@@ -1224,10 +1300,10 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t  continue;\n \t}\n \n-      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \t{\n \t  fprintf (vect_dump,\n-\t\t   \"versioning for alias required: possible dependence \"\n+\t\t   \"not vectorized, possible dependence \"\n \t\t   \"between data-refs \");\n \t  print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n \t  fprintf (vect_dump, \" and \");\n@@ -1240,88 +1316,6 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n   return false;\n }\n \n-/* Return TRUE if DDR_NEW is already found in MAY_ALIAS_DDRS list.  */\n-\n-static bool\n-vect_is_duplicate_ddr (VEC (ddr_p, heap) * may_alias_ddrs, ddr_p ddr_new)\n-{\n-  unsigned i;\n-  ddr_p ddr;\n-\n-  for (i = 0; VEC_iterate (ddr_p, may_alias_ddrs, i, ddr); i++)\n-    {\n-      tree dref_A_i, dref_B_i, dref_A_j, dref_B_j;\n-\n-      dref_A_i = DR_REF (DDR_A (ddr));\n-      dref_B_i = DR_REF (DDR_B (ddr));\n-      dref_A_j = DR_REF (DDR_A (ddr_new));\n-      dref_B_j = DR_REF (DDR_B (ddr_new));\n-\n-      if ((operand_equal_p (dref_A_i, dref_A_j, 0)\n-\t   && operand_equal_p (dref_B_i, dref_B_j, 0))\n-\t  || (operand_equal_p (dref_A_i, dref_B_j, 0)\n-\t      && operand_equal_p (dref_B_i, dref_A_j, 0)))\n-\t{\n-\t  if (vect_print_dump_info (REPORT_DR_DETAILS))\n-\t    {\n-\t      fprintf (vect_dump, \"found same pair of data references \");\n-\t      print_generic_expr (vect_dump, dref_A_i, TDF_SLIM);\n-\t      fprintf (vect_dump, \" and \");\n-\t      print_generic_expr (vect_dump, dref_B_i, TDF_SLIM);\n-\t    }\n-\t  return true;\n-\t}\n-    }\n-  return false;\n-}\n-\n-/* Save DDR in LOOP_VINFO list of ddrs that may alias and need to be\n-   tested at run-time.  Returns false if number of run-time checks\n-   inserted by vectorizer is greater than maximum defined by\n-   PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS.  */\n-static bool\n-vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n-{\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-\n-  if (vect_print_dump_info (REPORT_DR_DETAILS))\n-    {\n-      fprintf (vect_dump, \"mark for run-time aliasing test between \");\n-      print_generic_expr (vect_dump, DR_REF (DDR_A (ddr)), TDF_SLIM);\n-      fprintf (vect_dump, \" and \");\n-      print_generic_expr (vect_dump, DR_REF (DDR_B (ddr)), TDF_SLIM);\n-    }\n-\n-  /* FORNOW: We don't support versioning with outer-loop vectorization.  */\n-  if (loop->inner)\n-    {\n-      if (vect_print_dump_info (REPORT_DR_DETAILS))\n-\tfprintf (vect_dump, \"versioning not yet supported for outer-loops.\");\n-      return false;\n-    }\n-\n-  /* Do not add to the list duplicate ddrs.  */\n-  if (vect_is_duplicate_ddr (LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo), ddr))\n-    return true;\n-\n-  if (VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo))\n-      >= (unsigned) PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS))\n-    {\n-      if (vect_print_dump_info (REPORT_DR_DETAILS))\n-\t{\n-\t  fprintf (vect_dump,\n-\t\t   \"disable versioning for alias - max number of generated \"\n-\t\t   \"checks exceeded.\");\n-\t}\n-\n-      VEC_truncate (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo), 0);\n-\n-      return false;\n-    }\n-  VEC_safe_push (ddr_p, heap, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo), ddr);\n-  return true;\n-}\n-\n /* Function vect_analyze_data_ref_dependences.\n           \n    Examine all the data references in the loop, and make sure there do not\n@@ -1339,11 +1333,7 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n      \n   for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n     if (vect_analyze_data_ref_dependence (ddr, loop_vinfo))\n-      {\n-\t/* Add to list of ddrs that need to be tested at run-time.  */\n-\tif (!vect_mark_for_runtime_alias_test (ddr, loop_vinfo))\n       return false;\n-      }\n \n   return true;\n }\n@@ -2381,6 +2371,77 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n   return true;\n }\n \n+/* Function vect_prune_runtime_alias_test_list.\n+\n+   Prune a list of ddrs to be tested at run-time by versioning for alias.\n+   Return FALSE if resulting list of ddrs is longer then allowed by\n+   PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS, otherwise return TRUE.  */\n+\n+static bool\n+vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n+{\n+  VEC (ddr_p, heap) * ddrs =\n+    LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo);\n+  unsigned i, j;\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"=== vect_prune_runtime_alias_test_list ===\");\n+\n+  for (i = 0; i < VEC_length (ddr_p, ddrs); )\n+    {\n+      bool found;\n+      ddr_p ddr_i;\n+\n+      ddr_i = VEC_index (ddr_p, ddrs, i);\n+      found = false;\n+\n+      for (j = 0; j < i; j++)\n+        {\n+\t  ddr_p ddr_j = VEC_index (ddr_p, ddrs, j);\n+\n+\t  if (vect_vfa_range_equal (ddr_i, ddr_j))\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t\t{\n+\t\t  fprintf (vect_dump, \"found equal ranges \");\n+\t\t  print_generic_expr (vect_dump, DR_REF (DDR_A (ddr_i)), TDF_SLIM);\n+\t\t  fprintf (vect_dump, \", \");\n+\t\t  print_generic_expr (vect_dump, DR_REF (DDR_B (ddr_i)), TDF_SLIM);\n+\t\t  fprintf (vect_dump, \" and \");\n+\t\t  print_generic_expr (vect_dump, DR_REF (DDR_A (ddr_j)), TDF_SLIM);\n+\t\t  fprintf (vect_dump, \", \");\n+\t\t  print_generic_expr (vect_dump, DR_REF (DDR_B (ddr_j)), TDF_SLIM);\n+\t\t}\n+\t      found = true;\n+\t      break;\n+\t    }\n+\t}\n+      \n+      if (found)\n+      {\n+\tVEC_ordered_remove (ddr_p, ddrs, i);\n+\tcontinue;\n+      }\n+      i++;\n+    }\n+\n+  if (VEC_length (ddr_p, ddrs) >\n+       (unsigned) PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS))\n+    {\n+      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\t{\n+\t  fprintf (vect_dump,\n+\t\t   \"disable versioning for alias - max number of generated \"\n+\t\t   \"checks exceeded.\");\n+\t}\n+\n+      VEC_truncate (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo), 0);\n+\n+      return false;\n+    }\n+\n+  return true;\n+}\n \n /* Recursively free the memory allocated for the SLP tree rooted at NODE.  */\n \n@@ -4231,6 +4292,19 @@ vect_analyze_loop (struct loop *loop)\n       return NULL;\n     }\n \n+  /* Prune the list of ddrs to be tested at run-time by versioning for alias.\n+     It is important to call pruning after vect_analyze_data_ref_accesses,\n+     since we use grouping information gathered by interleaving analysis.  */\n+  ok = vect_prune_runtime_alias_test_list (loop_vinfo);\n+  if (!ok)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"too long list of versioning for alias \"\n+\t\t\t    \"run-time tests.\");\n+      destroy_loop_vec_info (loop_vinfo, true);\n+      return NULL;\n+    }\n+\n   /* Check the SLP opportunities in the loop, analyze and build SLP trees.  */\n   ok = vect_analyze_slp (loop_vinfo);\n   if (ok)"}, {"sha": "f02d912b29f63bc9f027cd2a6aa329e0a62eb626", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 145, "deletions": 109, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42cbdeac683d395849c9fee5e3e07b6a00093c5a/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42cbdeac683d395849c9fee5e3e07b6a00093c5a/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=42cbdeac683d395849c9fee5e3e07b6a00093c5a", "patch": "@@ -137,15 +137,32 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n       return 0;\n     }\n \n-  /* Requires loop versioning tests to handle misalignment.\n-     FIXME: Make cost depend on number of stmts in may_misalign list.  */\n+  /* Requires loop versioning tests to handle misalignment.  */\n \n   if (VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo)))\n     {\n-      vec_outside_cost += TARG_COND_TAKEN_BRANCH_COST;\n+      /*  FIXME: Make cost depend on complexity of individual check.  */\n+      vec_outside_cost +=\n+        VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo));\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"cost model: Adding cost of checks for loop \"\n+                 \"versioning to treat misalignment.\\n\");\n+    }\n+\n+  if (VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)))\n+    {\n+      /*  FIXME: Make cost depend on complexity of individual check.  */\n+      vec_outside_cost +=\n+        VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo));\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"cost model: Adding cost of checks for loop \"\n-                 \"versioning.\\n\");\n+                 \"versioning aliasing.\\n\");\n+    }\n+\n+  if (VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo))\n+      || VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)))\n+    {\n+      vec_outside_cost += TARG_COND_TAKEN_BRANCH_COST;\n     }\n \n   /* Count statements in scalar loop.  Using this as scalar cost for a single\n@@ -6864,31 +6881,18 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n static tree\n vect_vfa_segment_size (struct data_reference *dr, tree vect_factor)\n {\n-  tree segment_length;\n+  tree segment_length = fold_build2 (MULT_EXPR, integer_type_node,\n+\t\t\t             DR_STEP (dr), vect_factor);\n \n   if (vect_supportable_dr_alignment (dr) == dr_explicit_realign_optimized)\n     {\n-      tree vector_size =\n-        build_int_cst (integer_type_node,\n-          GET_MODE_SIZE (TYPE_MODE (STMT_VINFO_VECTYPE\n-\t    (vinfo_for_stmt (DR_STMT (dr))))));\n+      tree vector_size = TYPE_SIZE_UNIT\n+\t\t\t  (STMT_VINFO_VECTYPE (vinfo_for_stmt (DR_STMT (dr))));\n \n-      segment_length =\n-\tfold_convert (sizetype,\n-\t  fold_build2 (PLUS_EXPR, integer_type_node,\n-\t    fold_build2 (MULT_EXPR, integer_type_node, DR_STEP (dr),\n-\t\t\t vect_factor),\n-\t    vector_size));\n+      segment_length = fold_build2 (PLUS_EXPR, integer_type_node,\n+\t\t\t\t    segment_length, vector_size);\n     }\n-  else\n-    {\n-      segment_length =\n-\tfold_convert (sizetype,\n-\t  fold_build2 (MULT_EXPR, integer_type_node, DR_STEP (dr),\n-\t\t       vect_factor));\n-    }\n-\n-    return segment_length;\n+  return fold_convert (sizetype, segment_length);\n }\n \n /* Function vect_create_cond_for_alias_checks.\n@@ -6907,6 +6911,8 @@ vect_vfa_segment_size (struct data_reference *dr, tree vect_factor)\n    COND_EXPR - conditional expression.\n    COND_EXPR_STMT_LIST - statements needed to construct the conditional\n                          expression.\n+\n+\n    The returned value is the conditional expression to be used in the if\n    statement that controls which version of the loop gets executed at runtime.\n */\n@@ -6940,26 +6946,47 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n \n   for (i = 0; VEC_iterate (ddr_p, may_alias_ddrs, i, ddr); i++)\n     {\n-      tree stmt_a = DR_STMT (DDR_A (ddr));\n-      tree stmt_b = DR_STMT (DDR_B (ddr));\n+      struct data_reference *dr_a, *dr_b;\n+      tree dr_group_first_a, dr_group_first_b;\n+      tree addr_base_a, addr_base_b;\n+      tree segment_length_a, segment_length_b;\n+      tree stmt_a, stmt_b;\n \n-      tree addr_base_a =\n+      dr_a = DDR_A (ddr);\n+      stmt_a = DR_STMT (DDR_A (ddr));\n+      dr_group_first_a = DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt_a));\n+      if (dr_group_first_a)\n+        {\n+\t  stmt_a = dr_group_first_a;\n+\t  dr_a = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt_a));\n+\t}\n+\n+      dr_b = DDR_B (ddr);\n+      stmt_b = DR_STMT (DDR_B (ddr));\n+      dr_group_first_b = DR_GROUP_FIRST_DR (vinfo_for_stmt (stmt_b));\n+      if (dr_group_first_b)\n+        {\n+\t  stmt_b = dr_group_first_b;\n+\t  dr_b = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt_b));\n+\t}\n+\n+      addr_base_a =\n         vect_create_addr_base_for_vector_ref (stmt_a, cond_expr_stmt_list,\n \t\t\t\t\t      NULL_TREE, loop);\n-      tree addr_base_b =\n+      addr_base_b =\n         vect_create_addr_base_for_vector_ref (stmt_b, cond_expr_stmt_list,\n \t\t\t\t\t      NULL_TREE, loop);\n \n-      tree segment_length_a = vect_vfa_segment_size (DDR_A (ddr), vect_factor);\n-      tree segment_length_b = vect_vfa_segment_size (DDR_B (ddr), vect_factor);\n+      segment_length_a = vect_vfa_segment_size (dr_a, vect_factor);\n+      segment_length_b = vect_vfa_segment_size (dr_b, vect_factor);\n \n       if (vect_print_dump_info (REPORT_DR_DETAILS))\n \t{\n \t  fprintf (vect_dump,\n \t\t   \"create runtime check for data references \");\n-\t  print_generic_expr (vect_dump, DR_REF (DDR_A (ddr)), TDF_SLIM);\n+\t  print_generic_expr (vect_dump, DR_REF (dr_a), TDF_SLIM);\n \t  fprintf (vect_dump, \" and \");\n-\t  print_generic_expr (vect_dump, DR_REF (DDR_B (ddr)), TDF_SLIM);\n+\t  print_generic_expr (vect_dump, DR_REF (dr_b), TDF_SLIM);\n \t}\n \n \n@@ -6988,6 +7015,91 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n \n }\n \n+/* Function vect_loop_versioning.\n+ \n+   If the loop has data references that may or may not be aligned or/and\n+   has data reference relations whose independence was not proven then\n+   two versions of the loop need to be generated, one which is vectorized\n+   and one which isn't.  A test is then generated to control which of the\n+   loops is executed.  The test checks for the alignment of all of the\n+   data references that may or may not be aligned.  An additional\n+   sequence of runtime tests is generated for each pairs of DDRs whose\n+   independence was not proven.  The vectorized version of loop is \n+   executed only if both alias and alignment tests are passed.  */\n+\n+static void\n+vect_loop_versioning (loop_vec_info loop_vinfo)\n+{\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  struct loop *nloop;\n+  tree cond_expr = NULL_TREE;\n+  tree cond_expr_stmt_list = NULL_TREE;\n+  basic_block condition_bb;\n+  block_stmt_iterator cond_exp_bsi;\n+  basic_block merge_bb;\n+  basic_block new_exit_bb;\n+  edge new_exit_e, e;\n+  tree orig_phi, new_phi, arg;\n+  unsigned prob = 4 * REG_BR_PROB_BASE / 5;\n+  tree gimplify_stmt_list;\n+\n+  if (!VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo))\n+      && !VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)))\n+    return;\n+\n+  if (VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo)))\n+    cond_expr =\n+      vect_create_cond_for_align_checks (loop_vinfo, &cond_expr_stmt_list);\n+\n+  if (VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)))\n+    vect_create_cond_for_alias_checks (loop_vinfo, &cond_expr, &cond_expr_stmt_list);\n+\n+  cond_expr =\n+    fold_build2 (NE_EXPR, boolean_type_node, cond_expr, integer_zero_node);\n+  cond_expr =\n+    force_gimple_operand (cond_expr, &gimplify_stmt_list, true,\n+\t\t\t  NULL_TREE);\n+  append_to_statement_list (gimplify_stmt_list, &cond_expr_stmt_list);\n+\n+  initialize_original_copy_tables ();\n+  nloop = loop_version (loop, cond_expr, &condition_bb,\n+\t\t\tprob, prob, REG_BR_PROB_BASE - prob, true);\n+  free_original_copy_tables();\n+\n+  /* Loop versioning violates an assumption we try to maintain during \n+     vectorization - that the loop exit block has a single predecessor.\n+     After versioning, the exit block of both loop versions is the same\n+     basic block (i.e. it has two predecessors). Just in order to simplify\n+     following transformations in the vectorizer, we fix this situation\n+     here by adding a new (empty) block on the exit-edge of the loop,\n+     with the proper loop-exit phis to maintain loop-closed-form.  */\n+  \n+  merge_bb = single_exit (loop)->dest;\n+  gcc_assert (EDGE_COUNT (merge_bb->preds) == 2);\n+  new_exit_bb = split_edge (single_exit (loop));\n+  new_exit_e = single_exit (loop);\n+  e = EDGE_SUCC (new_exit_bb, 0);\n+\n+  for (orig_phi = phi_nodes (merge_bb); orig_phi; \n+\torig_phi = PHI_CHAIN (orig_phi))\n+    {\n+      new_phi = create_phi_node (SSA_NAME_VAR (PHI_RESULT (orig_phi)),\n+\t\t\t\t  new_exit_bb);\n+      arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, e);\n+      add_phi_arg (new_phi, arg, new_exit_e);\n+      SET_PHI_ARG_DEF (orig_phi, e->dest_idx, PHI_RESULT (new_phi));\n+    } \n+\n+  /* End loop-exit-fixes after versioning.  */\n+\n+  update_ssa (TODO_update_ssa);\n+  if (cond_expr_stmt_list)\n+    {\n+      cond_exp_bsi = bsi_last (condition_bb);\n+      bsi_insert_before (&cond_exp_bsi, cond_expr_stmt_list, BSI_SAME_STMT);\n+    }\n+}\n+\n /* Remove a group of stores (for SLP or interleaving), free their \n    stmt_vec_info.  */\n \n@@ -7096,7 +7208,6 @@ vect_schedule_slp (loop_vec_info loop_vinfo, unsigned int nunits)\n   return is_store;\n }\n \n-\n /* Function vect_transform_loop.\n \n    The analysis phase has determined that the loop is vectorizable.\n@@ -7119,82 +7230,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vec_transform_loop ===\");\n-\n-  /* If the loop has data references that may or may not be aligned or/and\n-     has data reference relations whose independence was not proven then\n-     two versions of the loop need to be generated, one which is vectorized\n-     and one which isn't.  A test is then generated to control which of the\n-     loops is executed.  The test checks for the alignment of all of the\n-     data references that may or may not be aligned.  An additional\n-     sequence of runtime tests is generated for each pairs of DDRs whose\n-     independence was not proven.  The vectorized version of loop is \n-     executed only if both alias and alignment tests are passed.  */\n-\n-  if (VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo))\n-      || VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)))\n-    {\n-      struct loop *nloop;\n-      tree cond_expr = NULL_TREE;\n-      tree cond_expr_stmt_list = NULL_TREE;\n-      basic_block condition_bb;\n-      block_stmt_iterator cond_exp_bsi;\n-      basic_block merge_bb;\n-      basic_block new_exit_bb;\n-      edge new_exit_e, e;\n-      tree orig_phi, new_phi, arg;\n-      unsigned prob = 4 * REG_BR_PROB_BASE / 5;\n-      tree gimplify_stmt_list;\n-\n-      if (VEC_length (tree, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo)))\n-\tcond_expr =\n-\t  vect_create_cond_for_align_checks (loop_vinfo, &cond_expr_stmt_list);\n-\n-      if (VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)))\n-\tvect_create_cond_for_alias_checks (loop_vinfo, &cond_expr,\n-                                                     &cond_expr_stmt_list);\n-\n-      cond_expr =\n-        fold_build2 (NE_EXPR, boolean_type_node, cond_expr, integer_zero_node);\n-      cond_expr =\n-        force_gimple_operand (cond_expr, &gimplify_stmt_list, true,\n-                              NULL_TREE);\n-      append_to_statement_list (gimplify_stmt_list, &cond_expr_stmt_list);\n-\n-      initialize_original_copy_tables ();\n-      nloop = loop_version (loop, cond_expr, &condition_bb,\n-\t\t\t    prob, prob, REG_BR_PROB_BASE - prob, true);\n-      free_original_copy_tables();\n-\n-      /** Loop versioning violates an assumption we try to maintain during \n-\t vectorization - that the loop exit block has a single predecessor.\n-\t After versioning, the exit block of both loop versions is the same\n-\t basic block (i.e. it has two predecessors). Just in order to simplify\n-\t following transformations in the vectorizer, we fix this situation\n-\t here by adding a new (empty) block on the exit-edge of the loop,\n-\t with the proper loop-exit phis to maintain loop-closed-form.  **/\n-      \n-      merge_bb = single_exit (loop)->dest;\n-      gcc_assert (EDGE_COUNT (merge_bb->preds) == 2);\n-      new_exit_bb = split_edge (single_exit (loop));\n-      new_exit_e = single_exit (loop);\n-      e = EDGE_SUCC (new_exit_bb, 0);\n-\n-      for (orig_phi = phi_nodes (merge_bb); orig_phi; \n-\t   orig_phi = PHI_CHAIN (orig_phi))\n-\t{\n-          new_phi = create_phi_node (SSA_NAME_VAR (PHI_RESULT (orig_phi)),\n-\t\t\t\t     new_exit_bb);\n-          arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, e);\n-          add_phi_arg (new_phi, arg, new_exit_e);\n-\t  SET_PHI_ARG_DEF (orig_phi, e->dest_idx, PHI_RESULT (new_phi));\n-\t} \n-\n-      /** end loop-exit-fixes after versioning  **/\n-\n-      update_ssa (TODO_update_ssa);\n-      cond_exp_bsi = bsi_last (condition_bb);\n-      bsi_insert_before (&cond_exp_bsi, cond_expr_stmt_list, BSI_SAME_STMT);\n-    }\n+  vect_loop_versioning (loop_vinfo);\n \n   /* CHECKME: we wouldn't need this if we called update_ssa once\n      for all loops.  */"}]}