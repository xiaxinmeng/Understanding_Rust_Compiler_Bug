{"sha": "5e77b60afdb1ef7b0a6b3a711bd71560dc7c00d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU3N2I2MGFmZGIxZWY3YjBhNmIzYTcxMWJkNzE1NjBkYzdjMDBkNA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2005-03-18T11:47:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-18T11:47:50Z"}, "message": "checks.adb (Apply_Array_Size_Check): Completely remove this for GCC 3, since we now expect GCC 3 to do all the work.\n\n2005-03-17  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb (Apply_Array_Size_Check): Completely remove this for GCC\n\t3, since we now expect GCC 3 to do all the work.\n\nFrom-SVN: r96663", "tree": {"sha": "3c0f49201ad46a35dbca57e499513aa05393d294", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c0f49201ad46a35dbca57e499513aa05393d294"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e77b60afdb1ef7b0a6b3a711bd71560dc7c00d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e77b60afdb1ef7b0a6b3a711bd71560dc7c00d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e77b60afdb1ef7b0a6b3a711bd71560dc7c00d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e77b60afdb1ef7b0a6b3a711bd71560dc7c00d4/comments", "author": null, "committer": null, "parents": [{"sha": "5fa28bbb0316e6258088bc985b63fdac7d077928", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fa28bbb0316e6258088bc985b63fdac7d077928", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fa28bbb0316e6258088bc985b63fdac7d077928"}], "stats": {"total": 217, "additions": 95, "deletions": 122}, "files": [{"sha": "5255e214f53047b63b09327fc842e1a8b92551bd", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 95, "deletions": 122, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e77b60afdb1ef7b0a6b3a711bd71560dc7c00d4/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e77b60afdb1ef7b0a6b3a711bd71560dc7c00d4/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=5e77b60afdb1ef7b0a6b3a711bd71560dc7c00d4", "patch": "@@ -714,10 +714,6 @@ package body Checks is\n    -- Apply_Array_Size_Check --\n    ----------------------------\n \n-   --  Note: Really of course this entre check should be in the backend,\n-   --  and perhaps this is not quite the right value, but it is good\n-   --  enough to catch the normal cases (and the relevant ACVC tests!)\n-\n    --  The situation is as follows. In GNAT 3 (GCC 2.x), the size in bits\n    --  is computed in 32 bits without an overflow check. That's a real\n    --  problem for Ada. So what we do in GNAT 3 is to approximate the\n@@ -726,8 +722,8 @@ package body Checks is\n \n    --  In GNAT 5, the size in byte is still computed in 32 bits without\n    --  an overflow check in the dynamic case, but the size in bits is\n-   --  computed in 64 bits. We assume that's good enough, so we use the\n-   --  size in bits for the test.\n+   --  computed in 64 bits. We assume that's good enough, and we do not\n+   --  bother to generate any front end test.\n \n    procedure Apply_Array_Size_Check (N : Node_Id; Typ : Entity_Id) is\n       Loc  : constant Source_Ptr := Sloc (N);\n@@ -808,6 +804,14 @@ package body Checks is\n    --  Start of processing for Apply_Array_Size_Check\n \n    begin\n+      --  Do size check on local arrays. We only need this in the GCC 2\n+      --  case, since in GCC 3, we expect the back end to properly handle\n+      --  things. This routine can be removed when we baseline GNAT 3.\n+\n+      if Opt.GCC_Version >= 3 then\n+         return;\n+      end if;\n+\n       --  No need for a check if not expanding\n \n       if not Expander_Active then\n@@ -843,144 +847,113 @@ package body Checks is\n          end if;\n       end loop;\n \n-      --  GCC 3 case\n+      --  First step is to calculate the maximum number of elements. For\n+      --  this calculation, we use the actual size of the subtype if it is\n+      --  static, and if a bound of a subtype is non-static, we go to the\n+      --  bound of the base type.\n \n-      if Opt.GCC_Version = 3 then\n+      Siz := Uint_1;\n+      Indx := First_Index (Typ);\n+      while Present (Indx) loop\n+         Xtyp := Etype (Indx);\n+         Lo := Type_Low_Bound (Xtyp);\n+         Hi := Type_High_Bound (Xtyp);\n \n-         --  No problem if size is known at compile time (even if the front\n-         --  end does not know it) because the back end does do overflow\n-         --  checking on the size in bytes if it is compile time known.\n+         --  If any bound raises constraint error, we will never get this\n+         --  far, so there is no need to generate any kind of check.\n \n-         if Size_Known_At_Compile_Time (Typ) then\n+         if Raises_Constraint_Error (Lo)\n+           or else\n+             Raises_Constraint_Error (Hi)\n+         then\n+            Uintp.Release (Umark);\n             return;\n          end if;\n-      end if;\n-\n-      --  Following code is temporarily deleted, since GCC 3 is returning\n-      --  zero for size in bits of large dynamic arrays. ???\n-\n---           --  Otherwise we check for the size in bits exceeding 2**31-1 * 8.\n---           --  This is the case in which we could end up with problems from\n---           --  an unnoticed overflow in computing the size in bytes\n---\n---           Check_Siz := (Uint_2 ** 31 - Uint_1) * Uint_8;\n---\n---           Sizx :=\n---             Make_Attribute_Reference (Loc,\n---               Prefix => New_Occurrence_Of (Typ, Loc),\n---               Attribute_Name => Name_Size);\n \n-      --  GCC 2 case (for now this is for GCC 3 dynamic case as well)\n+         --  Otherwise get bounds values\n \n-      begin\n-         --  First step is to calculate the maximum number of elements. For\n-         --  this calculation, we use the actual size of the subtype if it is\n-         --  static, and if a bound of a subtype is non-static, we go to the\n-         --  bound of the base type.\n-\n-         Siz := Uint_1;\n-         Indx := First_Index (Typ);\n-         while Present (Indx) loop\n-            Xtyp := Etype (Indx);\n-            Lo := Type_Low_Bound (Xtyp);\n-            Hi := Type_High_Bound (Xtyp);\n-\n-            --  If any bound raises constraint error, we will never get this\n-            --  far, so there is no need to generate any kind of check.\n-\n-            if Raises_Constraint_Error (Lo)\n-              or else\n-                Raises_Constraint_Error (Hi)\n-            then\n-               Uintp.Release (Umark);\n-               return;\n-            end if;\n+         if Is_Static_Expression (Lo) then\n+            Lob := Expr_Value (Lo);\n+         else\n+            Lob := Expr_Value (Type_Low_Bound (Base_Type (Xtyp)));\n+            Static := False;\n+         end if;\n \n-            --  Otherwise get bounds values\n+         if Is_Static_Expression (Hi) then\n+            Hib := Expr_Value (Hi);\n+         else\n+            Hib := Expr_Value (Type_High_Bound (Base_Type (Xtyp)));\n+            Static := False;\n+         end if;\n \n-            if Is_Static_Expression (Lo) then\n-               Lob := Expr_Value (Lo);\n-            else\n-               Lob := Expr_Value (Type_Low_Bound (Base_Type (Xtyp)));\n-               Static := False;\n-            end if;\n+         Siz := Siz *  UI_Max (Hib - Lob + 1, Uint_0);\n+         Next_Index (Indx);\n+      end loop;\n \n-            if Is_Static_Expression (Hi) then\n-               Hib := Expr_Value (Hi);\n-            else\n-               Hib := Expr_Value (Type_High_Bound (Base_Type (Xtyp)));\n-               Static := False;\n-            end if;\n+      --  Compute the limit against which we want to check. For subprograms,\n+      --  where the array will go on the stack, we use 8*2**24, which (in\n+      --  bits) is the size of a 16 megabyte array.\n \n-            Siz := Siz *  UI_Max (Hib - Lob + 1, Uint_0);\n-            Next_Index (Indx);\n-         end loop;\n+      if Is_Subprogram (Scope (Ent)) then\n+         Check_Siz := Uint_2 ** 27;\n+      else\n+         Check_Siz := Uint_2 ** 31;\n+      end if;\n \n-         --  Compute the limit against which we want to check. For subprograms,\n-         --  where the array will go on the stack, we use 8*2**24, which (in\n-         --  bits) is the size of a 16 megabyte array.\n+      --  If we have all static bounds and Siz is too large, then we know\n+      --  we know we have a storage error right now, so generate message\n \n-         if Is_Subprogram (Scope (Ent)) then\n-            Check_Siz := Uint_2 ** 27;\n-         else\n-            Check_Siz := Uint_2 ** 31;\n-         end if;\n+      if Static and then Siz >= Check_Siz then\n+         Insert_Action (N,\n+           Make_Raise_Storage_Error (Loc,\n+             Reason => SE_Object_Too_Large));\n+         Error_Msg_N (\"?Storage_Error will be raised at run-time\", N);\n+         Uintp.Release (Umark);\n+         return;\n+      end if;\n \n-         --  If we have all static bounds and Siz is too large, then we know\n-         --  we know we have a storage error right now, so generate message\n+      --  Case of component size known at compile time. If the array\n+      --  size is definitely in range, then we do not need a check.\n \n-         if Static and then Siz >= Check_Siz then\n-            Insert_Action (N,\n-              Make_Raise_Storage_Error (Loc,\n-                Reason => SE_Object_Too_Large));\n-            Error_Msg_N (\"?Storage_Error will be raised at run-time\", N);\n-            Uintp.Release (Umark);\n-            return;\n-         end if;\n+      if Known_Esize (Ctyp)\n+        and then Siz * Esize (Ctyp) < Check_Siz\n+      then\n+         Uintp.Release (Umark);\n+         return;\n+      end if;\n \n-         --  Case of component size known at compile time. If the array\n-         --  size is definitely in range, then we do not need a check.\n+      --  Here if a dynamic check is required\n \n-         if Known_Esize (Ctyp)\n-           and then Siz * Esize (Ctyp) < Check_Siz\n-         then\n-            Uintp.Release (Umark);\n-            return;\n-         end if;\n+      --  What we do is to build an expression for the size of the array,\n+      --  which is computed as the 'Size of the array component, times\n+      --  the size of each dimension.\n \n-         --  Here if a dynamic check is required\n+      Uintp.Release (Umark);\n \n-         --  What we do is to build an expression for the size of the array,\n-         --  which is computed as the 'Size of the array component, times\n-         --  the size of each dimension.\n+      Sizx :=\n+        Make_Attribute_Reference (Loc,\n+          Prefix =>         New_Occurrence_Of (Ctyp, Loc),\n+          Attribute_Name => Name_Size);\n \n-         Uintp.Release (Umark);\n+      Indx := First_Index (Typ);\n+      for J in 1 .. Number_Dimensions (Typ) loop\n+         if Sloc (Etype (Indx)) = Sloc (N) then\n+            Ensure_Defined (Etype (Indx), N);\n+         end if;\n \n          Sizx :=\n-           Make_Attribute_Reference (Loc,\n-             Prefix =>         New_Occurrence_Of (Ctyp, Loc),\n-             Attribute_Name => Name_Size);\n-\n-         Indx := First_Index (Typ);\n-         for J in 1 .. Number_Dimensions (Typ) loop\n-            if Sloc (Etype (Indx)) = Sloc (N) then\n-               Ensure_Defined (Etype (Indx), N);\n-            end if;\n+           Make_Op_Multiply (Loc,\n+             Left_Opnd  => Sizx,\n+             Right_Opnd =>\n+               Make_Attribute_Reference (Loc,\n+                 Prefix         => New_Occurrence_Of (Typ, Loc),\n+                 Attribute_Name => Name_Length,\n+                 Expressions    => New_List (\n+                   Make_Integer_Literal (Loc, J))));\n+         Next_Index (Indx);\n+      end loop;\n \n-            Sizx :=\n-              Make_Op_Multiply (Loc,\n-                Left_Opnd  => Sizx,\n-                Right_Opnd =>\n-                  Make_Attribute_Reference (Loc,\n-                    Prefix         => New_Occurrence_Of (Typ, Loc),\n-                    Attribute_Name => Name_Length,\n-                    Expressions    => New_List (\n-                                        Make_Integer_Literal (Loc, J))));\n-            Next_Index (Indx);\n-         end loop;\n-      end;\n-\n-      --  Common code to actually emit the check\n+      --  Emit the check\n \n       Code :=\n         Make_Raise_Storage_Error (Loc,\n@@ -990,7 +963,7 @@ package body Checks is\n               Right_Opnd =>\n                 Make_Integer_Literal (Loc,\n                   Intval    => Check_Siz)),\n-                  Reason    => SE_Object_Too_Large);\n+          Reason => SE_Object_Too_Large);\n \n       Set_Size_Check_Code (Defining_Identifier (N), Code);\n       Insert_Action (N, Code, Suppress => All_Checks);"}]}