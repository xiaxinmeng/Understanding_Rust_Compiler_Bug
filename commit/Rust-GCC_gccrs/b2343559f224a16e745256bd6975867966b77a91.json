{"sha": "b2343559f224a16e745256bd6975867966b77a91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjIzNDM1NTlmMjI0YTE2ZTc0NTI1NmJkNjk3NTg2Nzk2NmI3N2E5MQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2016-11-13T22:57:45Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2016-11-13T22:57:45Z"}, "message": "Add array support to std::shared_ptr for C++17\n\n\t* doc/xml/manual/status_cxx2017.xml: Update status.\n\t* doc/html/manual/status.html: Regenerate.\n\t* include/bits/shared_ptr.h (shared_ptr(unique_ptr<_Yp, _Del>)): Add\n\textension constructor to maintain C++14 behaviour.\n\t* include/bits/shared_ptr_base.h (__sp_array_delete): Add new struct.\n\t(__shared_count(_Ptr, false_type), __shared_count(_Ptr, true_type)):\n\tNew constructors.\n\t(__sp_compatible_with, __sp_is_constructible): Add specializations\n\tfor array support.\n\t(__sp_is_constructible_arr, __sp_is_constructible_arrN): New helpers.\n\t(__shared_ptr_access): New base class for observer member functions.\n\t(__shared_ptr::element_type): Use remove_extent.\n\t(__shared_ptr::_UniqCompatible): Add __sp_compatible_with check.\n\t(__shared_ptr(_Yp*)): Use tag dispatching to call new __shared_count\n\tconstructor.\n\t(__shared_ptr(unique_ptr<_Yp, _Del>)): Add extension constructor.\n\t(__shared_ptr::operator*, __shared_ptr::operator->): Remove and\n\tinherit from __shared_ptr_access base class.\n\t(__shared_ptr::__has_esft_base): Return false for array types.\n\t(__weak_ptr::element_type): Use remove_extent.\n\t* include/experimental/bits/shared_ptr.h (__libfund_v1): Remove.\n\t(__shared_ptr<__libfund_v1<_Tp>>): Remove specializations.\n\t(__wak_ptr<__libfund_v1<_Tp>>): Likewise.\n\t(experimental::__sp_compatible_v): Redefine using\n\t__sp_compatible_with.\n\t(experimental::__sp_is_constructible_v): Redefine using\n\t__sp_is_constructible.\n\t(get_deleter, operator<<): Change argument from __shared_ptr to\n\tshared_ptr.\n\t* testsuite/20_util/shared_ptr/cons/array.cc: New test.\n\t* testsuite/20_util/shared_ptr/cons/unique_ptr_array.cc: Adjust for\n\tnew behaviour.\n\t* testsuite/20_util/shared_ptr/observers/array.cc: Test observers for\n\tarrays.\n\t* testsuite/20_util/shared_ptr/observers/array_neg.cc: New test.\n\nFrom-SVN: r242369", "tree": {"sha": "337e0fb8d1ad5c0079fe0387d179ceacfc1638ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/337e0fb8d1ad5c0079fe0387d179ceacfc1638ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2343559f224a16e745256bd6975867966b77a91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2343559f224a16e745256bd6975867966b77a91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2343559f224a16e745256bd6975867966b77a91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2343559f224a16e745256bd6975867966b77a91/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2b4c1882337d1a051ef667449a1a6ca061e58f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2b4c1882337d1a051ef667449a1a6ca061e58f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2b4c1882337d1a051ef667449a1a6ca061e58f1"}], "stats": {"total": 1303, "additions": 617, "deletions": 686}, "files": [{"sha": "83a61393cbba66f453143dd4dd948574bc604be7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2343559f224a16e745256bd6975867966b77a91/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2343559f224a16e745256bd6975867966b77a91/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b2343559f224a16e745256bd6975867966b77a91", "patch": "@@ -1,3 +1,41 @@\n+2016-11-13  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* doc/xml/manual/status_cxx2017.xml: Update status.\n+\t* doc/html/manual/status.html: Regenerate.\n+\t* include/bits/shared_ptr.h (shared_ptr(unique_ptr<_Yp, _Del>)): Add\n+\textension constructor to maintain C++14 behaviour.\n+\t* include/bits/shared_ptr_base.h (__sp_array_delete): Add new struct.\n+\t(__shared_count(_Ptr, false_type), __shared_count(_Ptr, true_type)):\n+\tNew constructors.\n+\t(__sp_compatible_with, __sp_is_constructible): Add specializations\n+\tfor array support.\n+\t(__sp_is_constructible_arr, __sp_is_constructible_arrN): New helpers.\n+\t(__shared_ptr_access): New base class for observer member functions.\n+\t(__shared_ptr::element_type): Use remove_extent.\n+\t(__shared_ptr::_UniqCompatible): Add __sp_compatible_with check.\n+\t(__shared_ptr(_Yp*)): Use tag dispatching to call new __shared_count\n+\tconstructor.\n+\t(__shared_ptr(unique_ptr<_Yp, _Del>)): Add extension constructor.\n+\t(__shared_ptr::operator*, __shared_ptr::operator->): Remove and\n+\tinherit from __shared_ptr_access base class.\n+\t(__shared_ptr::__has_esft_base): Return false for array types.\n+\t(__weak_ptr::element_type): Use remove_extent.\n+\t* include/experimental/bits/shared_ptr.h (__libfund_v1): Remove.\n+\t(__shared_ptr<__libfund_v1<_Tp>>): Remove specializations.\n+\t(__wak_ptr<__libfund_v1<_Tp>>): Likewise.\n+\t(experimental::__sp_compatible_v): Redefine using\n+\t__sp_compatible_with.\n+\t(experimental::__sp_is_constructible_v): Redefine using\n+\t__sp_is_constructible.\n+\t(get_deleter, operator<<): Change argument from __shared_ptr to\n+\tshared_ptr.\n+\t* testsuite/20_util/shared_ptr/cons/array.cc: New test.\n+\t* testsuite/20_util/shared_ptr/cons/unique_ptr_array.cc: Adjust for\n+\tnew behaviour.\n+\t* testsuite/20_util/shared_ptr/observers/array.cc: Test observers for\n+\tarrays.\n+\t* testsuite/20_util/shared_ptr/observers/array_neg.cc: New test.\n+\n 2016-11-13  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tImplement P0403R1, Literal suffixes for basic_string_view."}, {"sha": "08c9ad06deae4a7f99a1ce3369f827c0ccbcbf4f", "filename": "libstdc++-v3/doc/html/manual/status.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2343559f224a16e745256bd6975867966b77a91/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fstatus.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2343559f224a16e745256bd6975867966b77a91/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fstatus.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fstatus.html?ref=b2343559f224a16e745256bd6975867966b77a91", "patch": "@@ -565,11 +565,11 @@\n \t<a class=\"link\" href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html\" target=\"_top\">\n \tP0220R1\n \t</a>\n-      </td><td align=\"center\"> 7 </td><td align=\"left\"> <code class=\"code\">__cpp_lib_apply &gt;= 201603</code> </td></tr><tr bgcolor=\"#C8B0B0\"><td align=\"left\"> Library Fundamentals V1 TS Components: <code class=\"code\">shared_ptr&lt;T[]&gt;</code> </td><td align=\"left\">\n+      </td><td align=\"center\"> 7 </td><td align=\"left\"> <code class=\"code\">__cpp_lib_apply &gt;= 201603</code> </td></tr><tr><td align=\"left\"> Library Fundamentals V1 TS Components: <code class=\"code\">shared_ptr&lt;T[]&gt;</code> </td><td align=\"left\">\n \t<a class=\"link\" href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html\" target=\"_top\">\n \tP0220R1\n \t</a>\n-      </td><td align=\"center\"> No </td><td align=\"left\"> <code class=\"code\">__cpp_lib_shared_ptr_arrays &gt;= 201603</code> </td></tr><tr><td align=\"left\"> Library Fundamentals V1 TS Components: Searchers </td><td align=\"left\">\n+      </td><td align=\"center\"> 7 </td><td align=\"left\"> <code class=\"code\">__cpp_lib_shared_ptr_arrays &gt;= 201603</code> </td></tr><tr><td align=\"left\"> Library Fundamentals V1 TS Components: Searchers </td><td align=\"left\">\n \t<a class=\"link\" href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html\" target=\"_top\">\n \tP0220R1\n \t</a>"}, {"sha": "dbb26c8f8670b09540cdb4c2e75d59041a522b90", "filename": "libstdc++-v3/doc/xml/manual/status_cxx2017.xml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2343559f224a16e745256bd6975867966b77a91/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2017.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2343559f224a16e745256bd6975867966b77a91/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2017.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2017.xml?ref=b2343559f224a16e745256bd6975867966b77a91", "patch": "@@ -158,14 +158,13 @@ Feature-testing recommendations for C++</link>.\n     </row>\n \n     <row>\n-      <?dbhtml bgcolor=\"#C8B0B0\" ?>\n       <entry> Library Fundamentals V1 TS Components: <code>shared_ptr&lt;T[]&gt;</code> </entry>\n       <entry>\n \t<link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0220r1.html\">\n \tP0220R1\n \t</link>\n       </entry>\n-      <entry align=\"center\"> No </entry>\n+      <entry align=\"center\"> 7 </entry>\n       <entry> <code>__cpp_lib_shared_ptr_arrays >= 201603</code> </entry>\n     </row>\n "}, {"sha": "cbe4144359e12741c01233a4d6f8f71f25f683df", "filename": "libstdc++-v3/include/bits/shared_ptr.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2343559f224a16e745256bd6975867966b77a91/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2343559f224a16e745256bd6975867966b77a91/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h?ref=b2343559f224a16e745256bd6975867966b77a91", "patch": "@@ -277,6 +277,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tshared_ptr(unique_ptr<_Yp, _Del>&& __r)\n \t: __shared_ptr<_Tp>(std::move(__r)) { }\n \n+#if __cplusplus <= 201402L && _GLIBCXX_USE_DEPRECATED\n+      // This non-standard constructor exists to support conversions that\n+      // were possible in C++11 and C++14 but are ill-formed in C++17.\n+      // If an exception is thrown this constructor has no effect.\n+      template<typename _Yp, typename _Del,\n+\t\t_Constructible<unique_ptr<_Yp, _Del>, __sp_array_delete>* = 0>\n+\tshared_ptr(unique_ptr<_Yp, _Del>&& __r)\n+\t: __shared_ptr<_Tp>(std::move(__r), __sp_array_delete()) { }\n+#endif\n+\n       /**\n        *  @brief  Construct an empty %shared_ptr.\n        *  @post   use_count() == 0 && get() == nullptr"}, {"sha": "953aa87436e3b0a69cffcca9a83a1a721d89a69b", "filename": "libstdc++-v3/include/bits/shared_ptr_base.h", "status": "modified", "additions": 193, "deletions": 26, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2343559f224a16e745256bd6975867966b77a91/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2343559f224a16e745256bd6975867966b77a91/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h?ref=b2343559f224a16e745256bd6975867966b77a91", "patch": "@@ -559,6 +559,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Impl _M_impl;\n     };\n \n+  // The default deleter for shared_ptr<T[]> and shared_ptr<T[N]>.\n+  struct __sp_array_delete\n+  {\n+    template<typename _Yp>\n+      void operator()(_Yp* __p) const { delete[] __p; }\n+  };\n \n   template<_Lock_policy _Lp>\n     class __shared_count\n@@ -582,6 +588,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    }\n \t}\n \n+      template<typename _Ptr>\n+\t__shared_count(_Ptr __p, /* is_array = */ false_type)\n+\t: __shared_count(__p)\n+\t{ }\n+\n+      template<typename _Ptr>\n+\t__shared_count(_Ptr __p, /* is_array = */ true_type)\n+\t: __shared_count(__p, __sp_array_delete{}, allocator<void>())\n+\t{ }\n+\n       template<typename _Ptr, typename _Deleter>\n \t__shared_count(_Ptr __p, _Deleter __d)\n \t: __shared_count(__p, std::move(__d), allocator<void>())\n@@ -848,8 +864,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_pi = nullptr;\n     }\n \n-  // Helper traits for shared_ptr\n+#define __cpp_lib_shared_ptr_arrays 201603\n+\n+  // Helper traits for shared_ptr of array:\n \n+  // A pointer type Y* is said to be compatible with a pointer type T* when\n+  // either Y* is convertible to T* or Y is U[N] and T is U cv [].\n   template<typename _Yp_ptr, typename _Tp_ptr>\n     struct __sp_compatible_with\n     : false_type\n@@ -860,17 +880,161 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : is_convertible<_Yp*, _Tp*>::type\n     { };\n \n+  template<typename _Up, size_t _Nm>\n+    struct __sp_compatible_with<_Up(*)[_Nm], _Up(*)[]>\n+    : true_type\n+    { };\n+\n+  template<typename _Up, size_t _Nm>\n+    struct __sp_compatible_with<_Up(*)[_Nm], const _Up(*)[]>\n+    : true_type\n+    { };\n+\n+  template<typename _Up, size_t _Nm>\n+    struct __sp_compatible_with<_Up(*)[_Nm], volatile _Up(*)[]>\n+    : true_type\n+    { };\n+\n+  template<typename _Up, size_t _Nm>\n+    struct __sp_compatible_with<_Up(*)[_Nm], const volatile _Up(*)[]>\n+    : true_type\n+    { };\n+\n+  // Test conversion from Y(*)[N] to U(*)[N] without forming invalid type Y[N].\n+  template<typename _Up, size_t _Nm, typename _Yp, typename = void>\n+    struct __sp_is_constructible_arrN\n+    : false_type\n+    { };\n+\n+  template<typename _Up, size_t _Nm, typename _Yp>\n+    struct __sp_is_constructible_arrN<_Up, _Nm, _Yp, __void_t<_Yp[_Nm]>>\n+    : is_convertible<_Yp(*)[_Nm], _Up(*)[_Nm]>::type\n+    { };\n+\n+  // Test conversion from Y(*)[] to U(*)[] without forming invalid type Y[].\n+  template<typename _Up, typename _Yp, typename = void>\n+    struct __sp_is_constructible_arr\n+    : false_type\n+    { };\n+\n+  template<typename _Up, typename _Yp>\n+    struct __sp_is_constructible_arr<_Up, _Yp, __void_t<_Yp[]>>\n+    : is_convertible<_Yp(*)[], _Up(*)[]>::type\n+    { };\n+\n+  // Trait to check if shared_ptr<T> can be constructed from Y*.\n+  template<typename _Tp, typename _Yp>\n+    struct __sp_is_constructible;\n+\n+  // When T is U[N], Y(*)[N] shall be convertible to T*;\n+  template<typename _Up, size_t _Nm, typename _Yp>\n+    struct __sp_is_constructible<_Up[_Nm], _Yp>\n+    : __sp_is_constructible_arrN<_Up, _Nm, _Yp>::type\n+    { };\n+\n+  // when T is U[], Y(*)[] shall be convertible to T*;\n+  template<typename _Up, typename _Yp>\n+    struct __sp_is_constructible<_Up[], _Yp>\n+    : __sp_is_constructible_arr<_Up, _Yp>::type\n+    { };\n+\n+  // otherwise, Y* shall be convertible to T*.\n+  template<typename _Tp, typename _Yp>\n+    struct __sp_is_constructible\n+    : is_convertible<_Yp*, _Tp*>::type\n+    { };\n+\n+\n+  // Define operator* and operator-> for shared_ptr<T>.\n+  template<typename _Tp, _Lock_policy _Lp,\n+\t   bool = is_array<_Tp>::value, bool = is_void<_Tp>::value>\n+    class __shared_ptr_access\n+    {\n+    public:\n+      using element_type = _Tp;\n+\n+      element_type&\n+      operator*() const noexcept\n+      {\n+\t__glibcxx_assert(_M_get() != nullptr);\n+\treturn *_M_get();\n+      }\n+\n+      element_type*\n+      operator->() const noexcept\n+      {\n+\t_GLIBCXX_DEBUG_PEDASSERT(_M_get() != nullptr);\n+\treturn _M_get();\n+      }\n+\n+    private:\n+      element_type*\n+      _M_get() const noexcept\n+      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }\n+    };\n+\n+  // Define operator-> for shared_ptr<cv void>.\n   template<typename _Tp, _Lock_policy _Lp>\n-    class __shared_ptr\n+    class __shared_ptr_access<_Tp, _Lp, false, true>\n     {\n     public:\n       using element_type = _Tp;\n \n+      element_type*\n+      operator->() const noexcept\n+      {\n+\t_GLIBCXX_DEBUG_PEDASSERT(_M_get() != nullptr);\n+\treturn static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get();\n+      }\n+    };\n+\n+  // Define operator[] for shared_ptr<T[]> and shared_ptr<T[N]>.\n+  template<typename _Tp, _Lock_policy _Lp>\n+    class __shared_ptr_access<_Tp, _Lp, true, false>\n+    {\n+    public:\n+      using element_type = typename remove_extent<_Tp>::type;\n+\n+#if __cplusplus <= 201402L\n+      [[__deprecated__(\"shared_ptr<T[]>::operator* is absent from C++17\")]]\n+      element_type&\n+      operator*() const noexcept\n+      {\n+\t__glibcxx_assert(_M_ptr != nullptr);\n+\treturn *_M_get();\n+      }\n+\n+      [[__deprecated__(\"shared_ptr<T[]>::operator-> is absent from C++17\")]]\n+      element_type*\n+      operator->() const noexcept\n+      {\n+\t_GLIBCXX_DEBUG_PEDASSERT(_M_get() != nullptr);\n+\treturn _M_get();\n+      }\n+#endif\n+\n+      element_type&\n+      operator[](ptrdiff_t __i) const\n+      {\n+\t__glibcxx_assert(_M_get() != nullptr);\n+\t__glibcxx_assert(!extent<_Tp>::value || __i < extent<_Tp>::value);\n+\treturn _M_get()[__i];\n+      }\n+\n     private:\n-      // Trait to check if shared_ptr<T> can be constructed from Y*.\n-      template<typename _Tp1, typename _Yp>\n-\tusing __sp_is_constructible = is_convertible<_Yp*, _Tp1*>;\n+      element_type*\n+      _M_get() const noexcept\n+      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }\n+    };\n \n+  template<typename _Tp, _Lock_policy _Lp>\n+    class __shared_ptr\n+    : public __shared_ptr_access<_Tp, _Lp>\n+    {\n+    public:\n+      using element_type = typename remove_extent<_Tp>::type;\n+\n+    private:\n       // Constraint for taking ownership of a pointer of type _Yp*:\n       template<typename _Yp>\n \tusing _SafeConv\n@@ -888,9 +1052,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // Constraint for construction from unique_ptr:\n       template<typename _Yp, typename _Del, typename _Res = void,\n \t       typename _Ptr = typename unique_ptr<_Yp, _Del>::pointer>\n-\tusing _UniqCompatible = typename enable_if<\n-\t  is_convertible<_Ptr, element_type*>::value\n-\t  , _Res>::type;\n+\tusing _UniqCompatible = typename enable_if<__and_<\n+\t  __sp_compatible_with<_Yp*, _Tp*>, is_convertible<_Ptr, element_type*>\n+\t  >::value, _Res>::type;\n \n       // Constraint for assignment from unique_ptr:\n       template<typename _Yp, typename _Del>\n@@ -909,7 +1073,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Yp, typename = _SafeConv<_Yp>>\n \texplicit\n \t__shared_ptr(_Yp* __p)\n-\t: _M_ptr(__p), _M_refcount(__p)\n+\t: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())\n \t{\n \t  static_assert( !is_void<_Yp>::value, \"incomplete type\" );\n \t  static_assert( sizeof(_Yp) > 0, \"incomplete type\" );\n@@ -995,6 +1159,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_enable_shared_from_this_with(__raw);\n \t}\n \n+#if __cplusplus <= 201402L && _GLIBCXX_USE_DEPRECATED\n+    protected:\n+      // If an exception is thrown this constructor has no effect.\n+      template<typename _Tp1, typename _Del,\n+\t       typename enable_if<__and_<\n+\t\t __not_<is_array<_Tp>>, is_array<_Tp1>,\n+\t         is_convertible<typename unique_ptr<_Tp1, _Del>::pointer, _Tp*>\n+\t       >::value, bool>::type = true>\n+\t__shared_ptr(unique_ptr<_Tp1, _Del>&& __r, __sp_array_delete)\n+\t: _M_ptr(__r.get()), _M_refcount()\n+\t{\n+\t  auto __raw = _S_raw_ptr(__r.get());\n+\t  _M_refcount = __shared_count<_Lp>(std::move(__r));\n+\t  _M_enable_shared_from_this_with(__raw);\n+\t}\n+    public:\n+#endif\n+\n #if _GLIBCXX_USE_DEPRECATED\n       // Postcondition: use_count() == 1 and __r.get() == 0\n       template<typename _Yp, typename = _Compatible<_Yp>>\n@@ -1068,21 +1250,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treset(_Yp* __p, _Deleter __d, _Alloc __a)\n         { __shared_ptr(__p, __d, std::move(__a)).swap(*this); }\n \n-      // Allow class instantiation when _Tp is [cv-qual] void.\n-      typename std::add_lvalue_reference<element_type>::type\n-      operator*() const noexcept\n-      {\n-\t__glibcxx_assert(_M_ptr != 0);\n-\treturn *_M_ptr;\n-      }\n-\n-      element_type*\n-      operator->() const noexcept\n-      {\n-\t_GLIBCXX_DEBUG_PEDASSERT(_M_ptr != 0);\n-\treturn _M_ptr;\n-      }\n-\n       element_type*\n       get() const noexcept\n       { return _M_ptr; }\n@@ -1193,7 +1360,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       template<typename _Yp>\n \tstruct __has_esft_base<_Yp, __void_t<__esft_base_t<_Yp>>>\n-\t: true_type { };\n+\t: __not_<is_array<_Tp>> { }; // No enable shared_from_this for arrays\n \n       template<typename _Yp>\n \ttypename enable_if<__has_esft_base<_Yp>::value>::type\n@@ -1428,7 +1595,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tusing _Assignable = _Compatible<_Yp, __weak_ptr&>;\n \n     public:\n-      using element_type = _Tp;\n+      using element_type = typename remove_extent<_Tp>::type;\n \n       constexpr __weak_ptr() noexcept\n       : _M_ptr(nullptr), _M_refcount()"}, {"sha": "8a1fc52caf80ca691b673a4fa4bf8df8e75b23d7", "filename": "libstdc++-v3/include/experimental/bits/shared_ptr.h", "status": "modified", "additions": 10, "deletions": 656, "changes": 666, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2343559f224a16e745256bd6975867966b77a91/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fshared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2343559f224a16e745256bd6975867966b77a91/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fshared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Fshared_ptr.h?ref=b2343559f224a16e745256bd6975867966b77a91", "patch": "@@ -46,665 +46,20 @@ namespace experimental\n inline namespace fundamentals_v2\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n-  template<typename _Tp> class enable_shared_from_this;\n-_GLIBCXX_END_NAMESPACE_VERSION\n-} // namespace fundamentals_v2\n-} // namespace experimental\n-\n-#define __cpp_lib_experimental_shared_ptr_arrays 201406\n-\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n-  /*\n-   * The specification of std::experimental::shared_ptr is slightly different\n-   * to std::shared_ptr (specifically in terms of \"compatible\" pointers) so\n-   * to implement std::experimental::shared_ptr without too much duplication\n-   * we make it derive from a partial specialization of std::__shared_ptr\n-   * using a special tag type, __libfund_v1.\n-   *\n-   * There are two partial specializations for the tag type, supporting the\n-   * different interfaces of the array and non-array forms.\n-  */\n-\n-  template <typename _Tp, bool = is_array<_Tp>::value>\n-    struct __libfund_v1 { using type = _Tp; };\n-\n-  // Partial specialization for base class of experimental::shared_ptr<T>\n-  // (i.e. the non-array form of experimental::shared_ptr)\n-  template<typename _Tp, _Lock_policy _Lp>\n-    class __shared_ptr<__libfund_v1<_Tp, false>, _Lp>\n-    : private __shared_ptr<_Tp, _Lp>\n-    {\n-      // For non-arrays, Y* is compatible with T* if Y* is convertible to T*.\n-      template<typename _Yp, typename _Res = void>\n-\tusing _Compatible\n-\t  = enable_if_t<experimental::is_convertible_v<_Yp*, _Tp*>, _Res>;\n-\n-      template<typename _Yp, typename _Del,\n-\t       typename _Ptr = typename unique_ptr<_Yp, _Del>::pointer,\n-\t       typename _Res = void>\n-\tusing _UniqCompatible = enable_if_t<\n-\t  experimental::is_convertible_v<_Yp*, _Tp*>\n-\t  && experimental::is_convertible_v<_Ptr, _Tp*>,\n-\t  _Res>;\n-\n-      using _Base_type = __shared_ptr<_Tp>;\n-\n-      _Base_type&  _M_get_base() { return *this; }\n-      const _Base_type&  _M_get_base() const { return *this; }\n-\n-    public:\n-      using element_type = _Tp;\n-\n-      constexpr __shared_ptr() noexcept = default;\n-\n-      template<typename _Tp1, typename = _Compatible<_Tp1>>\n-\texplicit\n-\t__shared_ptr(_Tp1* __p)\n-\t: _Base_type(__p)\n-\t{ }\n-\n-      template<typename _Tp1, typename _Deleter, typename = _Compatible<_Tp1>>\n-\t__shared_ptr(_Tp1* __p, _Deleter __d)\n-\t: _Base_type(__p, __d)\n-\t{ }\n-\n-      template<typename _Tp1, typename _Deleter, typename _Alloc,\n-\t       typename = _Compatible<_Tp1>>\n-\t__shared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)\n-\t: _Base_type(__p, __d, __a)\n-\t{ }\n-\n-      template<typename _Deleter>\n-\t__shared_ptr(nullptr_t __p, _Deleter __d)\n-\t: _Base_type(__p, __d)\n-\t{ }\n-\n-      template<typename _Deleter, typename _Alloc>\n-\t__shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)\n-\t: _Base_type(__p, __d, __a)\n-\t{ }\n-\n-      template<typename _Tp1>\n-\t__shared_ptr(const __shared_ptr<__libfund_v1<_Tp1>, _Lp>& __r,\n-\t\t     element_type* __p) noexcept\n-\t: _Base_type(__r._M_get_base(), __p)\n-\t{ }\n-\n-      __shared_ptr(const __shared_ptr&) noexcept = default;\n-      __shared_ptr(__shared_ptr&&) noexcept = default;\n-      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;\n-      __shared_ptr& operator=(__shared_ptr&&) noexcept = default;\n-      ~__shared_ptr() = default;\n-\n-      template<typename _Tp1, typename = _Compatible<_Tp1>>\n-\t__shared_ptr(const __shared_ptr<__libfund_v1<_Tp1>, _Lp>& __r) noexcept\n-\t: _Base_type(__r._M_get_base())\n-\t{ }\n-\n-      template<typename _Tp1, typename = _Compatible<_Tp1>>\n-\t__shared_ptr(__shared_ptr<__libfund_v1<_Tp1>, _Lp>&& __r) noexcept\n-\t: _Base_type(std::move((__r._M_get_base())))\n-\t{ }\n-\n-      template<typename _Tp1, typename = _Compatible<_Tp1>>\n-\texplicit\n-\t__shared_ptr(const __weak_ptr<__libfund_v1<_Tp1>, _Lp>& __r)\n-\t: _Base_type(__r._M_get_base())\n-\t{ }\n-\n-      template<typename _Tp1, typename _Del,\n-\t       typename = _UniqCompatible<_Tp1, _Del>>\n-\t__shared_ptr(unique_ptr<_Tp1, _Del>&& __r)\n-\t: _Base_type(std::move(__r))\n-\t{ }\n-\n-#if _GLIBCXX_USE_DEPRECATED\n-      // Postcondition: use_count() == 1 and __r.get() == 0\n-      template<typename _Tp1, typename = _Compatible<_Tp1>>\n-\t__shared_ptr(std::auto_ptr<_Tp1>&& __r)\n-        : _Base_type(std::move(__r))\n-\t{ }\n-#endif\n-\n-      constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }\n-\n-      // reset\n-      void\n-      reset() noexcept\n-      { __shared_ptr(nullptr).swap(*this); }\n-\n-      template<typename _Tp1>\n-\t_Compatible<_Tp1>\n-\treset(_Tp1* __p)\n-\t{\n-\t  _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != get());\n-\t  __shared_ptr(__p).swap(*this);\n-\t}\n-\n-      template<typename _Tp1, typename _Deleter>\n-\t_Compatible<_Tp1>\n-\treset(_Tp1* __p, _Deleter __d)\n-\t{ __shared_ptr(__p, __d).swap(*this); }\n-\n-      template<typename _Tp1, typename _Deleter, typename _Alloc>\n-\t_Compatible<_Tp1>\n-\treset(_Tp1* __p, _Deleter __d, _Alloc __a)\n-\t{ __shared_ptr(__p, __d, std::move(__a)).swap(*this); }\n-\n-      using _Base_type::operator*;\n-      using _Base_type::operator->;\n-\n-      template<typename _Tp1>\n-\t_Compatible<_Tp1, __shared_ptr&>\n-\toperator=(const __shared_ptr<__libfund_v1<_Tp1>, _Lp>& __r) noexcept\n-\t{\n-\t  _Base_type::operator=(__r._M_get_base());\n-\t  return *this;\n-\t}\n-\n-      template<class _Tp1>\n-\t_Compatible<_Tp1, __shared_ptr&>\n-\toperator=(__shared_ptr<__libfund_v1<_Tp1>, _Lp>&& __r) noexcept\n-\t{\n-\t  _Base_type::operator=(std::move(__r._M_get_base()));\n-\t  return *this;\n-\t}\n-\n-      template<typename _Tp1, typename _Del>\n-\t_UniqCompatible<_Tp1, _Del, __shared_ptr&>\n-\toperator=(unique_ptr<_Tp1, _Del>&& __r)\n-\t{\n-\t  _Base_type::operator=(std::move(__r));\n-\t  return *this;\n-\t}\n-\n-#if _GLIBCXX_USE_DEPRECATED\n-      template<typename _Tp1>\n-\t_Compatible<_Tp1, __shared_ptr&>\n-\toperator=(std::auto_ptr<_Tp1>&& __r)\n-\t{\n-\t  _Base_type::operator=(std::move(__r));\n-\t  return *this;\n-\t}\n-#endif\n-\n-      void\n-      swap(__shared_ptr& __other) noexcept\n-      { _Base_type::swap(__other); }\n-\n-      template<typename _Tp1>\n-\tbool\n-\towner_before(__shared_ptr<__libfund_v1<_Tp1>, _Lp> const& __rhs) const\n-\t{ return _Base_type::owner_before(__rhs._M_get_base()); }\n-\n-      template<typename _Tp1>\n-\tbool\n-\towner_before(__weak_ptr<__libfund_v1<_Tp1>, _Lp> const& __rhs) const\n-\t{ return _Base_type::owner_before(__rhs._M_get_base()); }\n-\n-      using _Base_type::operator bool;\n-      using _Base_type::get;\n-      using _Base_type::unique;\n-      using _Base_type::use_count;\n-\n-    protected:\n-\n-      // make_shared not yet support for shared_ptr_arrays\n-      //template<typename _Alloc, typename... _Args>\n-      //  __shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,\n-      //\t             _Args&&... __args)\n-      //\t: _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,\n-      //\t                        std::forward<_Args>(__args)...)\n-      //\t{\n-      //\t  void* __p = _M_refcount._M_get_deleter(typeid(__tag));\n-      //\t  _M_ptr = static_cast<_Tp*>(__p);\n-      //\t}\n-\n-      // __weak_ptr::lock()\n-      __shared_ptr(const __weak_ptr<__libfund_v1<_Tp>, _Lp>& __r,\n-\t\t   std::nothrow_t)\n-      : _Base_type(__r._M_get_base(), std::nothrow)\n-      { }\n-\n-    private:\n-      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n-      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n-\n-      // TODO\n-      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>\n-\tfriend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&) noexcept;\n-    };\n-\n-  // Helper traits for shared_ptr of array:\n \n-  // Trait that tests if Y* is compatible with T*, for shared_ptr purposes.\n-  template<typename _Yp, typename _Tp>\n-    struct __sp_compatible\n-    : is_convertible<_Yp*, _Tp*>::type\n-    { };\n+  // 8.2.1\n \n-  template<size_t _Nm, typename _Tp>\n-    struct __sp_compatible<_Tp[_Nm], _Tp[]>\n-    : true_type\n-    { };\n-\n-  template<size_t _Nm, typename _Tp>\n-    struct __sp_compatible<_Tp[_Nm], const _Tp[]>\n-    : true_type\n-    { };\n+  template<typename _Tp> class shared_ptr;\n+  template<typename _Tp> class weak_ptr;\n+  template<typename _Tp> class enable_shared_from_this;\n \n   template<typename _Yp, typename _Tp>\n     constexpr bool __sp_compatible_v\n-      = __sp_compatible<_Yp, _Tp>::value;\n-\n-  // Test conversion from Y(*)[N] to U(*)[N] without forming invalid type Y[N].\n-  template<typename _Up, size_t _Nm, typename _Yp, typename = void>\n-    struct __sp_is_constructible_arrN\n-    : false_type\n-    { };\n-\n-  template<typename _Up, size_t _Nm, typename _Yp>\n-    struct __sp_is_constructible_arrN<_Up, _Nm, _Yp, __void_t<_Yp[_Nm]>>\n-    : is_convertible<_Yp(*)[_Nm], _Up(*)[_Nm]>::type\n-    { };\n-\n-  // Test conversion from Y(*)[] to U(*)[] without forming invalid type Y[].\n-  template<typename _Up, typename _Yp, typename = void>\n-    struct __sp_is_constructible_arr\n-    : false_type\n-    { };\n-\n-  template<typename _Up, typename _Yp>\n-    struct __sp_is_constructible_arr<_Up, _Yp, __void_t<_Yp[]>>\n-    : is_convertible<_Yp(*)[], _Up(*)[]>::type\n-    { };\n-\n-  // Trait to check if shared_ptr<T> can be constructed from Y*.\n-  template<typename _Tp, typename _Yp>\n-    struct __sp_is_constructible;\n-\n-  // When T is U[N], Y(*)[N] shall be convertible to T*;\n-  template<typename _Up, size_t _Nm, typename _Yp>\n-    struct __sp_is_constructible<_Up[_Nm], _Yp>\n-    : __sp_is_constructible_arrN<_Up, _Nm, _Yp>::type\n-    { };\n-\n-  // when T is U[], Y(*)[] shall be convertible to T*;\n-  template<typename _Up, typename _Yp>\n-    struct __sp_is_constructible<_Up[], _Yp>\n-    : __sp_is_constructible_arr<_Up, _Yp>::type\n-    { };\n-\n-  // otherwise, Y* shall be convertible to T*.\n-  template<typename _Tp, typename _Yp>\n-    struct __sp_is_constructible\n-    : is_convertible<_Yp*, _Tp*>::type\n-    { };\n+      = std::__sp_compatible_with<_Yp*, _Tp*>::value;\n \n   template<typename _Tp, typename _Yp>\n     constexpr bool __sp_is_constructible_v\n-      = __sp_is_constructible<_Tp, _Yp>::value;\n-\n-\n-  // Partial specialization for base class of experimental::shared_ptr<T[N]>\n-  // and experimental::shared_ptr<T[]> (i.e. the array forms).\n-  template<typename _Tp, _Lock_policy _Lp>\n-    class __shared_ptr<__libfund_v1<_Tp, true>, _Lp>\n-    : private __shared_ptr<remove_extent_t<_Tp>, _Lp>\n-    {\n-    public:\n-      using element_type = remove_extent_t<_Tp>;\n-\n-    private:\n-      struct _Array_deleter\n-      {\n-\tvoid\n-\toperator()(element_type const *__p) const\n-\t{ delete [] __p; }\n-      };\n-\n-      // Constraint for constructing/resetting with a pointer of type _Yp*:\n-      template<typename _Yp>\n-\tusing _SafeConv = enable_if_t<__sp_is_constructible_v<_Tp, _Yp>>;\n-\n-      // Constraint for constructing/assigning from smart_pointer<_Tp1>:\n-      template<typename _Tp1, typename _Res = void>\n-\tusing _Compatible = enable_if_t<__sp_compatible_v<_Tp1, _Tp>, _Res>;\n-\n-      // Constraint for constructing/assigning from unique_ptr<_Tp1, _Del>:\n-      template<typename _Tp1, typename _Del,\n-\t       typename _Ptr = typename unique_ptr<_Tp1, _Del>::pointer,\n-\t       typename _Res = void>\n-\tusing _UniqCompatible = enable_if_t<\n-\t  __sp_compatible_v<_Tp1, _Tp>\n-\t  && experimental::is_convertible_v<_Ptr, element_type*>,\n-\t  _Res>;\n-\n-      using _Base_type = __shared_ptr<element_type>;\n-\n-      _Base_type&  _M_get_base() { return *this; }\n-      const _Base_type&  _M_get_base() const { return *this; }\n-\n-    public:\n-      constexpr __shared_ptr() noexcept\n-      : _Base_type()\n-      { }\n-\n-      template<typename _Tp1, typename = _SafeConv<_Tp1>>\n-\texplicit\n-\t__shared_ptr(_Tp1* __p)\n-\t: _Base_type(__p, _Array_deleter())\n-\t{ }\n-\n-      template<typename _Tp1, typename _Deleter, typename = _SafeConv<_Tp1>>\n-\t__shared_ptr(_Tp1* __p, _Deleter __d)\n-\t: _Base_type(__p, __d)\n-\t{ }\n-\n-      template<typename _Tp1, typename _Deleter, typename _Alloc,\n-\t       typename = _SafeConv<_Tp1>>\n-\t__shared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)\n-\t: _Base_type(__p, __d, __a)\n-\t{ }\n-\n-      template<typename _Deleter>\n-\t__shared_ptr(nullptr_t __p, _Deleter __d)\n-\t: _Base_type(__p, __d)\n-\t{ }\n-\n-      template<typename _Deleter, typename _Alloc>\n-\t__shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)\n-\t: _Base_type(__p, __d, __a)\n-\t{ }\n-\n-      template<typename _Tp1>\n-\t__shared_ptr(const __shared_ptr<__libfund_v1<_Tp1>, _Lp>& __r,\n-\t\t     element_type* __p) noexcept\n-\t: _Base_type(__r._M_get_base(), __p)\n-\t{ }\n-\n-      __shared_ptr(const __shared_ptr&) noexcept = default;\n-      __shared_ptr(__shared_ptr&&) noexcept = default;\n-      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;\n-      __shared_ptr& operator=(__shared_ptr&&) noexcept = default;\n-      ~__shared_ptr() = default;\n-\n-      template<typename _Tp1, typename = _Compatible<_Tp1>>\n-\t__shared_ptr(const __shared_ptr<__libfund_v1<_Tp1>, _Lp>& __r) noexcept\n-\t: _Base_type(__r._M_get_base())\n-\t{ }\n-\n-      template<typename _Tp1, typename = _Compatible<_Tp1>>\n-\t__shared_ptr(__shared_ptr<__libfund_v1<_Tp1>, _Lp>&& __r) noexcept\n-\t: _Base_type(std::move((__r._M_get_base())))\n-\t{ }\n-\n-      template<typename _Tp1, typename = _Compatible<_Tp1>>\n-\texplicit\n-\t__shared_ptr(const __weak_ptr<__libfund_v1<_Tp1>, _Lp>& __r)\n-\t: _Base_type(__r._M_get_base())\n-\t{ }\n-\n-      template<typename _Tp1, typename _Del,\n-\t       typename = _UniqCompatible<_Tp1, _Del>>\n-\t__shared_ptr(unique_ptr<_Tp1, _Del>&& __r)\n-\t: _Base_type(std::move(__r))\n-\t{ }\n-\n-#if _GLIBCXX_USE_DEPRECATED\n-      // Postcondition: use_count() == 1 and __r.get() == 0\n-      template<typename _Tp1, typename = _Compatible<_Tp1>>\n-\t__shared_ptr(auto_ptr<_Tp1>&& __r)\n-        : _Base_type(std::move(__r))\n-\t{ }\n-#endif\n-\n-      constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }\n-\n-      // reset\n-      void\n-      reset() noexcept\n-      { __shared_ptr(nullptr).swap(*this); }\n-\n-      template<typename _Tp1>\n-\t_SafeConv<_Tp1>\n-\treset(_Tp1* __p)\n-\t{\n-\t  _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != get());\n-\t  __shared_ptr(__p, _Array_deleter()).swap(*this);\n-\t}\n-\n-      template<typename _Tp1, typename _Deleter>\n-\t_SafeConv<_Tp1>\n-\treset(_Tp1* __p, _Deleter __d)\n-\t{ __shared_ptr(__p, __d).swap(*this); }\n-\n-      template<typename _Tp1, typename _Deleter, typename _Alloc>\n-\t_SafeConv<_Tp1>\n-\treset(_Tp1* __p, _Deleter __d, _Alloc __a)\n-\t{ __shared_ptr(__p, __d, std::move(__a)).swap(*this); }\n-\n-      element_type&\n-      operator[](ptrdiff_t i) const noexcept\n-      {\n-\t_GLIBCXX_DEBUG_ASSERT(get() != 0 && i >= 0);\n-\treturn get()[i];\n-      }\n-\n-      template<typename _Tp1>\n-\t_Compatible<_Tp1, __shared_ptr&>\n-\toperator=(const __shared_ptr<__libfund_v1<_Tp1>, _Lp>& __r) noexcept\n-\t{\n-\t  _Base_type::operator=(__r._M_get_base());\n-\t  return *this;\n-\t}\n-\n-      template<class _Tp1>\n-\t_Compatible<_Tp1, __shared_ptr&>\n-\toperator=(__shared_ptr<__libfund_v1<_Tp1>, _Lp>&& __r) noexcept\n-\t{\n-\t  _Base_type::operator=(std::move(__r._M_get_base()));\n-\t  return *this;\n-\t}\n-\n-      template<typename _Tp1, typename _Del>\n-\t_UniqCompatible<_Tp1, _Del, __shared_ptr&>\n-\toperator=(unique_ptr<_Tp1, _Del>&& __r)\n-\t{\n-\t  _Base_type::operator=(std::move(__r));\n-\t  return *this;\n-\t}\n-\n-#if _GLIBCXX_USE_DEPRECATED\n-      template<typename _Tp1>\n-\t_Compatible<_Tp1, __shared_ptr&>\n-\toperator=(auto_ptr<_Tp1>&& __r)\n-\t{\n-\t  _Base_type::operator=(std::move(__r));\n-\t  return *this;\n-\t}\n-#endif\n-\n-      void\n-      swap(__shared_ptr& __other) noexcept\n-      { _Base_type::swap(__other); }\n-\n-      template<typename _Tp1>\n-\tbool\n-\towner_before(__shared_ptr<__libfund_v1<_Tp1>, _Lp> const& __rhs) const\n-\t{ return _Base_type::owner_before(__rhs._M_get_base()); }\n-\n-      template<typename _Tp1>\n-\tbool\n-\towner_before(__weak_ptr<__libfund_v1<_Tp1>, _Lp> const& __rhs) const\n-\t{ return _Base_type::owner_before(__rhs._M_get_base()); }\n-\n-      using _Base_type::operator bool;\n-      using _Base_type::get;\n-      using _Base_type::unique;\n-      using _Base_type::use_count;\n-\n-    protected:\n-\n-      // make_shared not yet support for shared_ptr_arrays\n-      //template<typename _Alloc, typename... _Args>\n-      //  __shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,\n-      //\t             _Args&&... __args)\n-      //\t: _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,\n-      //\t                        std::forward<_Args>(__args)...)\n-      //\t{\n-      //\t  void* __p = _M_refcount._M_get_deleter(typeid(__tag));\n-      //\t  _M_ptr = static_cast<_Tp*>(__p);\n-      //\t}\n-\n-      // __weak_ptr::lock()\n-      __shared_ptr(const __weak_ptr<__libfund_v1<_Tp>, _Lp>& __r,\n-\t\t   std::nothrow_t)\n-      : _Base_type(__r._M_get_base(), std::nothrow)\n-      { }\n-\n-    private:\n-      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n-      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n-\n-      // TODO\n-      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>\n-\tfriend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&) noexcept;\n-    };\n-\n-  // weak_ptr specialization for __shared_ptr array\n-  template<typename _Tp, _Lock_policy _Lp>\n-    class __weak_ptr<__libfund_v1<_Tp>, _Lp>\n-    : __weak_ptr<remove_extent_t<_Tp>, _Lp>\n-    {\n-      template<typename _Tp1, typename _Res = void>\n-\tusing _Compatible\n-\t  = enable_if_t<__sp_compatible_v<_Tp1, _Tp>, _Res>;\n-\n-      using _Base_type = __weak_ptr<remove_extent_t<_Tp>>;\n-\n-      _Base_type&  _M_get_base() { return *this; }\n-      const _Base_type&  _M_get_base() const { return *this; }\n-\n-    public:\n-      using element_type = remove_extent_t<_Tp>;\n-\n-      constexpr __weak_ptr() noexcept\n-      : _Base_type()\n-      { }\n-\n-      __weak_ptr(const __weak_ptr&) noexcept = default;\n-\n-      ~__weak_ptr() = default;\n-\n-      template<typename _Tp1, typename = _Compatible<_Tp1>>\n-\t__weak_ptr(const __weak_ptr<__libfund_v1<_Tp1>, _Lp>& __r) noexcept\n-\t: _Base_type(__r._M_get_base())\n-\t{ }\n-\n-      template<typename _Tp1, typename = _Compatible<_Tp1>>\n-\t__weak_ptr(const __shared_ptr<__libfund_v1<_Tp1>, _Lp>& __r) noexcept\n-\t: _Base_type(__r._M_get_base())\n-\t{ }\n-\n-      __weak_ptr(__weak_ptr&& __r) noexcept\n-      : _Base_type(std::move(__r))\n-      { }\n-\n-      template<typename _Tp1, typename = _Compatible<_Tp1>>\n-\t__weak_ptr(__weak_ptr<__libfund_v1<_Tp1>, _Lp>&& __r) noexcept\n-\t: _Base_type(std::move(__r._M_get_base()))\n-\t{ }\n-\n-      __weak_ptr&\n-      operator=(const __weak_ptr& __r) noexcept = default;\n-\n-      template<typename _Tp1>\n-\t_Compatible<_Tp1, __weak_ptr&>\n-\toperator=(const __weak_ptr<__libfund_v1<_Tp1>, _Lp>& __r) noexcept\n-\t{\n-\t  this->_Base_type::operator=(__r._M_get_base());\n-\t  return *this;\n-\t}\n-\n-      template<typename _Tp1>\n-\t_Compatible<_Tp1, __weak_ptr&>\n-\toperator=(const __shared_ptr<_Tp1, _Lp>& __r) noexcept\n-\t{\n-\t  this->_Base_type::operator=(__r._M_get_base());\n-\t  return *this;\n-\t}\n-\n-      __weak_ptr&\n-      operator=(__weak_ptr&& __r) noexcept\n-      {\n-\tthis->_Base_type::operator=(std::move(__r));\n-\treturn *this;\n-      }\n-\n-      template<typename _Tp1>\n-\t_Compatible<_Tp1, __weak_ptr&>\n-\toperator=(__weak_ptr<_Tp1, _Lp>&& __r) noexcept\n-\t{\n-\t  this->_Base_type::operator=(std::move(__r._M_get_base()));\n-\t  return *this;\n-\t}\n-\n-      void\n-      swap(__weak_ptr& __other) noexcept\n-      { this->_Base_type::swap(__other); }\n-\n-      template<typename _Tp1>\n-\tbool\n-\towner_before(const __shared_ptr<__libfund_v1<_Tp1>, _Lp>& __rhs) const\n-\t{ return _Base_type::owner_before(__rhs._M_get_base()); }\n-\n-      template<typename _Tp1>\n-\tbool\n-\towner_before(const __weak_ptr<__libfund_v1<_Tp1>, _Lp>& __rhs) const\n-\t{ return _Base_type::owner_before(__rhs._M_get_base()); }\n-\n-      __shared_ptr<__libfund_v1<_Tp>, _Lp>\n-      lock() const noexcept  // should not be element_type\n-      { return __shared_ptr<__libfund_v1<_Tp>, _Lp>(*this, std::nothrow); }\n-\n-      using _Base_type::use_count;\n-      using _Base_type::expired;\n-      using _Base_type::reset;\n-\n-    private:\n-      // Used by __enable_shared_from_this.\n-      void\n-      _M_assign(element_type* __ptr,\n-\t\tconst __shared_count<_Lp>& __refcount) noexcept\n-      { this->_Base_type::_M_assign(__ptr, __refcount); }\n-\n-      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n-      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n-      friend class __enable_shared_from_this<_Tp, _Lp>;\n-      friend class experimental::enable_shared_from_this<_Tp>;\n-      friend class enable_shared_from_this<_Tp>;\n-    };\n-\n-_GLIBCXX_END_NAMESPACE_VERSION\n-\n-namespace experimental\n-{\n-inline namespace fundamentals_v2\n-{\n-_GLIBCXX_BEGIN_NAMESPACE_VERSION\n-\n-    // 8.2.1\n-\n-  template<typename _Tp> class shared_ptr;\n-  template<typename _Tp> class weak_ptr;\n-\n-  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n-    using __shared_ptr = std::__shared_ptr<__libfund_v1<_Tp>, _Lp>;\n-\n-  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n-    using __weak_ptr = std::__weak_ptr<__libfund_v1<_Tp>, _Lp>;\n+      = std::__sp_is_constructible<_Tp, _Yp>::value;\n \n   template<typename _Tp>\n     class shared_ptr : public __shared_ptr<_Tp>\n@@ -1128,16 +483,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { __a.swap(__b); }\n \n   /// C++14 \u00a720.8.2.2.10\n-  template<typename _Del, typename _Tp, _Lock_policy _Lp>\n+  template<typename _Del, typename _Tp>\n     inline _Del*\n-    get_deleter(const __shared_ptr<_Tp, _Lp>& __p) noexcept\n+    get_deleter(const shared_ptr<_Tp>& __p) noexcept\n     { return std::get_deleter<_Del>(__p); }\n \n   // C++14 \u00a720.8.2.2.11\n-  template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>\n+  template<typename _Ch, typename _Tr, typename _Tp>\n     inline std::basic_ostream<_Ch, _Tr>&\n-    operator<<(std::basic_ostream<_Ch, _Tr>& __os,\n-\t       const __shared_ptr<_Tp, _Lp>& __p)\n+    operator<<(std::basic_ostream<_Ch, _Tr>& __os, const shared_ptr<_Tp>& __p)\n     {\n       __os << __p.get();\n       return __os;"}, {"sha": "d56dc6692e98716e9b06b4c4b49b863fd52b49e0", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/array.cc", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2343559f224a16e745256bd6975867966b77a91/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Farray.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2343559f224a16e745256bd6975867966b77a91/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Farray.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Farray.cc?ref=b2343559f224a16e745256bd6975867966b77a91", "patch": "@@ -0,0 +1,273 @@\n+// { dg-do run { target c++11 } }\n+\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+// C++1z 20.11.2.2.1 shared_ptr constructors [util.smartptr.shared.const]\n+\n+template<typename To, typename From>\n+constexpr bool check()\n+{\n+  using std::shared_ptr;\n+  using std::is_constructible;\n+  return !is_constructible<shared_ptr<To>, shared_ptr<From>>::value\n+    && !is_constructible<shared_ptr<To>, shared_ptr<From>&>::value;\n+}\n+\n+static_assert( check<int, int[]>() );\n+static_assert( check<int, int[2]>() );\n+static_assert( check<int[2], void>() );\n+static_assert( check<int[2], int>() );\n+static_assert( check<int[2], int[]>() );\n+static_assert( check<int[], void>() );\n+static_assert( check<int[], int>() );\n+\n+int count = 0;\n+\n+struct A {\n+  A() { ++count; }\n+  ~A() { --count; }\n+};\n+\n+struct B : A { };\n+\n+static_assert( check<A, B[2]>() );\n+static_assert( check<A, B[]>() );\n+static_assert( check<A[2], B>() );\n+static_assert( check<A[2], B[2]>() );\n+static_assert( check<A[2], B[]>() );\n+static_assert( check<A[], B>() );\n+static_assert( check<A[], B[2]>() );\n+static_assert( check<A[], B[]>() );\n+\n+void\n+test01()\n+{\n+  std::shared_ptr<A[2]> p;\n+  VERIFY( p.get() == nullptr );\n+  VERIFY( p.use_count() == 0 );\n+  p.reset();\n+  VERIFY( count == 0 );\n+}\n+\n+void\n+test02()\n+{\n+  std::shared_ptr<A[]> p;\n+  VERIFY( p.get() == nullptr );\n+  VERIFY( p.use_count() == 0 );\n+  p.reset();\n+  VERIFY( count == 0 );\n+}\n+\n+void\n+test03()\n+{\n+  std::shared_ptr<A[2]> p(nullptr);\n+  VERIFY( p.get() == nullptr );\n+  VERIFY( p.use_count() == 0 );\n+  p.reset();\n+  VERIFY( count == 0 );\n+}\n+\n+void\n+test04()\n+{\n+  std::shared_ptr<A[]> p(nullptr);\n+  VERIFY( p.get() == nullptr );\n+  VERIFY( p.use_count() == 0 );\n+  p.reset();\n+  VERIFY( count == 0 );\n+}\n+\n+// Construction from pointer\n+\n+void\n+test05()\n+{\n+  A * const a = nullptr;\n+  std::shared_ptr<A[2]> p(a);\n+  VERIFY( p.get() == nullptr );\n+  VERIFY( p.use_count() == 1 );\n+  p.reset();\n+  VERIFY( count == 0 );\n+}\n+\n+void\n+test06()\n+{\n+  A * const a = nullptr;\n+  std::shared_ptr<A[]> p(a);\n+  VERIFY( p.get() == nullptr );\n+  VERIFY( p.use_count() == 1 );\n+  p.reset();\n+  VERIFY( count == 0 );\n+}\n+\n+void\n+test07()\n+{\n+  A * const a = new A[2];\n+  std::shared_ptr<A[2]> p(a);\n+  VERIFY( p.get() == a );\n+  VERIFY( p.use_count() == 1 );\n+  p.reset();\n+  VERIFY( count == 0 );\n+}\n+\n+void\n+test08()\n+{\n+  A * const a = new A[2];\n+  std::shared_ptr<A[]> p(a);\n+  VERIFY( p.get() == a );\n+  VERIFY( p.use_count() == 1 );\n+  p.reset();\n+  VERIFY( count == 0 );\n+}\n+\n+// Converting constrcutor\n+\n+void\n+test09()\n+{\n+  A * const a = new A[2];\n+  std::shared_ptr<A[2]> p(a);\n+  std::shared_ptr<const A[2]> p2(p);\n+  VERIFY( p2.get() == a );\n+  VERIFY( p.use_count() == 2 );\n+  VERIFY( p2.use_count() == 2 );\n+  p.reset();\n+  VERIFY( count != 0 );\n+  p2.reset();\n+  VERIFY( count == 0 );\n+}\n+\n+void\n+test10()\n+{\n+  A * const a = new A[2];\n+  std::shared_ptr<A[]> p(a);\n+  std::shared_ptr<const A[]> p2(p);\n+  VERIFY( p2.get() == a );\n+  VERIFY( p.use_count() == 2 );\n+  VERIFY( p2.use_count() == 2 );\n+  p.reset();\n+  VERIFY( count != 0 );\n+  p2.reset();\n+  VERIFY( count == 0 );\n+}\n+\n+void\n+test11()\n+{\n+  A * const a = new A[2];\n+  std::shared_ptr<A[2]> p(a);\n+  std::shared_ptr<const A[]> p2(p);\n+  VERIFY( p2.get() == a );\n+  VERIFY( p.use_count() == 2 );\n+  VERIFY( p2.use_count() == 2 );\n+  p.reset();\n+  VERIFY( count != 0 );\n+  p2.reset();\n+  VERIFY( count == 0 );\n+}\n+\n+// Copy construction\n+\n+void\n+test12()\n+{\n+  A * const a = new A[2];\n+  std::shared_ptr<A[2]> p(a);\n+  std::shared_ptr<A[2]> p2(p);\n+  VERIFY( p2.get() == a );\n+  VERIFY( p.use_count() == 2 );\n+  VERIFY( p2.use_count() == 2 );\n+  p.reset();\n+  VERIFY( count != 0 );\n+  p2.reset();\n+  VERIFY( count == 0 );\n+}\n+\n+void\n+test13()\n+{\n+  A * const a = new A[2];\n+  std::shared_ptr<A[2]> p(a);\n+  std::shared_ptr<A[]> p2(p);\n+  VERIFY( p2.get() == a );\n+  VERIFY( p.use_count() == 2 );\n+  VERIFY( p2.use_count() == 2 );\n+  p.reset();\n+  VERIFY( count != 0 );\n+  p2.reset();\n+  VERIFY( count == 0 );\n+}\n+\n+// Move construction\n+\n+void\n+test14()\n+{\n+  A * const a = new A[2];\n+  std::shared_ptr<A[2]> p(a);\n+  std::shared_ptr<A[2]> p2(std::move(p));\n+  VERIFY( p.get() == nullptr );\n+  VERIFY( p2.get() == a );\n+  VERIFY( p.use_count() == 0 );\n+  VERIFY( p2.use_count() == 1 );\n+  p2.reset();\n+  VERIFY( count == 0 );\n+}\n+\n+void\n+test15()\n+{\n+  A * const a = new A[2];\n+  std::shared_ptr<A[2]> p(a);\n+  std::shared_ptr<A[]> p2(std::move(p));\n+  VERIFY( p.get() == nullptr );\n+  VERIFY( p2.get() == a );\n+  VERIFY( p.use_count() == 0 );\n+  VERIFY( p2.use_count() == 1 );\n+  p2.reset();\n+  VERIFY( count == 0 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+  test07();\n+  test08();\n+  test09();\n+  test10();\n+  test11();\n+  test12();\n+  test13();\n+  test14();\n+  test15();\n+}"}, {"sha": "bc1fcf12225b1dbfc22f71a68ca3b93c890c34c0", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/cons/unique_ptr_array.cc", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2343559f224a16e745256bd6975867966b77a91/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr_array.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2343559f224a16e745256bd6975867966b77a91/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr_array.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcons%2Funique_ptr_array.cc?ref=b2343559f224a16e745256bd6975867966b77a91", "patch": "@@ -22,6 +22,13 @@\n #include <memory>\n #include <testsuite_hooks.h>\n \n+#if __cpp_lib_shared_ptr_arrays >= 201603\n+# define SHARED_PTR_ARRAYS\n+#endif\n+#if __cpp_lib_enable_shared_from_this >= 201603\n+# define WEAK_FROM_THIS\n+#endif\n+\n int destroyed = 0;\n \n struct A : std::enable_shared_from_this<A>\n@@ -36,12 +43,22 @@ int\n test01()\n {\n   std::unique_ptr<A[]> up(new A[2]);\n+#ifdef SHARED_PTR_ARRAYS\n+  std::shared_ptr<A[]> sp(std::move(up));\n+#else\n   std::shared_ptr<A> sp(std::move(up));\n+#endif\n   VERIFY( up.get() == 0 );\n   VERIFY( sp.get() != 0 );\n   VERIFY( sp.use_count() == 1 );\n \n+#ifdef SHARED_PTR_ARRAYS\n+# ifdef WEAK_FROM_THIS\n+  VERIFY( sp[0].weak_from_this().expired() );\n+# endif\n+#else\n   VERIFY( sp->shared_from_this() != nullptr );\n+#endif\n \n   sp.reset();\n   VERIFY( destroyed == 2 );"}, {"sha": "c47859d659a0ab0034656188dd624d4fe73688c4", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/observers/array.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2343559f224a16e745256bd6975867966b77a91/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Farray.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2343559f224a16e745256bd6975867966b77a91/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Farray.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Farray.cc?ref=b2343559f224a16e745256bd6975867966b77a91", "patch": "@@ -0,0 +1,73 @@\n+// { dg-do run { target c++11 } }\n+\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  int i = 0;\n+};\n+\n+// C++1z 20.11.2.2.5 shared_ptr observers [util.smartptr.shared.obs]\n+\n+// get\n+void\n+test01()\n+{\n+  A * const a = new A[2];\n+  const std::shared_ptr<A[2]> p(a);\n+  VERIFY( p.get() == a );\n+}\n+\n+// get\n+void\n+test02()\n+{\n+  A * const a = new A[2];\n+  const std::shared_ptr<A[]> p(a);\n+  VERIFY( p.get() == a );\n+}\n+\n+// operator[]\n+void\n+test03()\n+{\n+  A * const a = new A[2];\n+  const std::shared_ptr<A[2]> p(a);\n+  VERIFY( &p[0] == a );\n+}\n+\n+// operator[]\n+void\n+test04()\n+{\n+  A * const a = new A[2];\n+  const std::shared_ptr<A[]> p(a);\n+  VERIFY( &p[0] == a );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}]}