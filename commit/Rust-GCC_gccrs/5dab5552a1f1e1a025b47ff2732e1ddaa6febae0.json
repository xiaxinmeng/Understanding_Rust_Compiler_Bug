{"sha": "5dab5552a1f1e1a025b47ff2732e1ddaa6febae0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRhYjU1NTJhMWYxZTFhMDI1YjQ3ZmYyNzMyZTFkZGFhNmZlYmFlMA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-05-13T00:19:57Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-05-13T00:19:57Z"}, "message": "calls.c (expand_call): Only destroy temporaries at the end of function calls, if flag_short_temps is set.\n\n        * calls.c (expand_call): Only destroy temporaries at the end\n        of function calls, if flag_short_temps is set.\n        * expr.c (safe_from_p, expand_expr): Handle CLEANUP_POINT_EXPRs.\n        * expr.c (expand_expr): Improve handling of temporaries inside\n        COND_EXPRs, cures call to sorry.\n        * expr.c (defer_cleanups_to): New routine to handle the deferral\n        of cleanups.\n        * flags.h (flag_short_temps): New flag, to allow better control\n        over the lifetime of temporaries.\n        * toplev.c (flag_short_temps, lang_options): Ditto.\n        * tree.def (CLEANUP_POINT_EXPR): Add, to allow better control over\n        the lifetime of temporaries.\n\nFrom-SVN: r7289", "tree": {"sha": "3f07160e300eeeba7a188bb0fe8b6d16a89335b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f07160e300eeeba7a188bb0fe8b6d16a89335b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5dab5552a1f1e1a025b47ff2732e1ddaa6febae0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dab5552a1f1e1a025b47ff2732e1ddaa6febae0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dab5552a1f1e1a025b47ff2732e1ddaa6febae0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dab5552a1f1e1a025b47ff2732e1ddaa6febae0/comments", "author": null, "committer": null, "parents": [{"sha": "51b8fc2c697ae80971166d44acd18a1cb2c0d19b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b8fc2c697ae80971166d44acd18a1cb2c0d19b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51b8fc2c697ae80971166d44acd18a1cb2c0d19b"}], "stats": {"total": 185, "additions": 162, "deletions": 23}, "files": [{"sha": "cc6a74a5668d2a8d5068d433994f5628a6f9dfd9", "filename": "gcc/calls.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dab5552a1f1e1a025b47ff2732e1ddaa6febae0/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dab5552a1f1e1a025b47ff2732e1ddaa6febae0/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=5dab5552a1f1e1a025b47ff2732e1ddaa6febae0", "patch": "@@ -1995,9 +1995,12 @@ expand_call (exp, target, ignore)\n     }\n #endif\n \n-  /* Perform all cleanups needed for the arguments of this call\n-     (i.e. destructors in C++).  */\n-  expand_cleanups_to (old_cleanups);\n+  if (flag_short_temps)\n+    {\n+      /* Perform all cleanups needed for the arguments of this call\n+\t (i.e. destructors in C++).  */\n+      expand_cleanups_to (old_cleanups);\n+    }\n \n   /* If size of args is variable or this was a constructor call for a stack\n      argument, restore saved stack-pointer value.  */"}, {"sha": "55ee134f07bcfd0dc40bc97c574030ba6edd1212", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dab5552a1f1e1a025b47ff2732e1ddaa6febae0/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dab5552a1f1e1a025b47ff2732e1ddaa6febae0/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=5dab5552a1f1e1a025b47ff2732e1ddaa6febae0", "patch": "@@ -2176,7 +2176,9 @@ delete_insns_since (from)\n   last_insn = from;\n }\n \n-/* Move a consecutive bunch of insns to a different place in the chain.\n+/* This function is deprecated, please use sequences instead.\n+\n+   Move a consecutive bunch of insns to a different place in the chain.\n    The insns to be moved are those between FROM and TO.\n    They are moved to a new position after the insn AFTER.\n    AFTER must not be FROM or TO or any insn in between."}, {"sha": "38789ffecc98b768ebe7b305743569d90abb0068", "filename": "gcc/expr.c", "status": "modified", "additions": 135, "deletions": 17, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dab5552a1f1e1a025b47ff2732e1ddaa6febae0/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dab5552a1f1e1a025b47ff2732e1ddaa6febae0/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5dab5552a1f1e1a025b47ff2732e1ddaa6febae0", "patch": "@@ -179,6 +179,7 @@ static void do_jump_by_parts_equality_rtx PROTO((rtx, rtx, rtx));\n static void do_jump_for_compare\tPROTO((rtx, rtx, rtx));\n static rtx compare\t\tPROTO((tree, enum rtx_code, enum rtx_code));\n static rtx do_store_flag\tPROTO((tree, rtx, enum machine_mode, int));\n+static tree defer_cleanups_to\tPROTO((tree));\n \n /* Record for each mode whether we can move a register directly to or\n    from an object of that mode in memory.  If we can't, we won't try\n@@ -3535,6 +3536,9 @@ safe_from_p (x, exp)\n \t  exp_rtl = RTL_EXPR_RTL (exp);\n \t  break;\n \n+\tcase CLEANUP_POINT_EXPR:\n+\t  return safe_from_p (x, TREE_OPERAND (exp, 0));\n+\n \tcase SAVE_EXPR:\n \t  exp_rtl = SAVE_EXPR_RTL (exp);\n \t  break;\n@@ -4609,6 +4613,14 @@ expand_expr (exp, target, tmode, modifier)\n \t}\n       return RTL_EXPR_RTL (exp);\n \n+    case CLEANUP_POINT_EXPR:\n+      {\n+\ttree old_cleanups = cleanups_this_call;\n+\top0 = expand_expr (TREE_OPERAND (exp, 0), target, VOIDmode, modifier);\n+\texpand_cleanups_to (old_cleanups);\n+      }\n+      return op0;\n+\n     case CALL_EXPR:\n       /* Check for a built-in function.  */\n       if (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n@@ -5295,6 +5307,17 @@ expand_expr (exp, target, tmode, modifier)\n \n     case COND_EXPR:\n       {\n+\trtx flag = NULL_RTX;\n+\ttree left_cleanups = NULL_TREE;\n+\ttree right_cleanups = NULL_TREE;\n+\n+\t/* Used to save a pointer to the place to put the setting of\n+\t   the flag that indicates if this side of the conditional was\n+\t   taken.  We backpatch the code, if we find out later that we\n+\t   have any conditional cleanups that need to be performed. */\n+\trtx dest_right_flag = NULL_RTX;\n+\trtx dest_left_flag = NULL_RTX;\n+\n \t/* Note that COND_EXPRs whose type is a structure or union\n \t   are required to be constructed to contain assignments of\n \t   a temporary variable, so that we can evaluate them here\n@@ -5306,7 +5329,6 @@ expand_expr (exp, target, tmode, modifier)\n \ttree singleton = 0;\n \ttree binary_op = 0, unary_op = 0;\n \ttree old_cleanups = cleanups_this_call;\n-\tcleanups_this_call = 0;\n \n \t/* If this is (A ? 1 : 0) and A is a condition, just evaluate it and\n \t   convert it to our mode, if necessary.  */\n@@ -5430,6 +5452,7 @@ expand_expr (exp, target, tmode, modifier)\n \tNO_DEFER_POP;\n \top0 = gen_label_rtx ();\n \n+\tflag = gen_reg_rtx (word_mode);\n \tif (singleton && ! TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 0)))\n \t  {\n \t    if (temp != 0)\n@@ -5448,16 +5471,14 @@ expand_expr (exp, target, tmode, modifier)\n \t    else\n \t      expand_expr (singleton,\n \t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n-\t    if (cleanups_this_call)\n-\t      {\n-\t\tsorry (\"aggregate value in COND_EXPR\");\n-\t\tcleanups_this_call = 0;\n-\t      }\n+\t    dest_left_flag = get_last_insn ();\n \t    if (singleton == TREE_OPERAND (exp, 1))\n \t      jumpif (TREE_OPERAND (exp, 0), op0);\n \t    else\n \t      jumpifnot (TREE_OPERAND (exp, 0), op0);\n \n+\t    /* Allows cleanups up to here. */\n+\t    old_cleanups = cleanups_this_call;\n \t    if (binary_op && temp == 0)\n \t      /* Just touch the other operand.  */\n \t      expand_expr (TREE_OPERAND (binary_op, 1),\n@@ -5472,6 +5493,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t  make_tree (type, temp)),\n \t\t\t  temp, 0);\n \t    op1 = op0;\n+\t    dest_right_flag = get_last_insn ();\n \t  }\n #if 0\n \t/* This is now done in jump.c and is better done there because it\n@@ -5498,9 +5520,14 @@ expand_expr (exp, target, tmode, modifier)\n \t    if (GET_CODE (temp) == REG && REGNO (temp) < FIRST_PSEUDO_REGISTER)\n \t      temp = gen_reg_rtx (mode);\n \t    store_expr (TREE_OPERAND (exp, 2), temp, 0);\n+\t    dest_left_flag = get_last_insn ();\n \t    jumpifnot (TREE_OPERAND (exp, 0), op0);\n+\n+\t    /* Allows cleanups up to here. */\n+\t    old_cleanups = cleanups_this_call;\n \t    store_expr (TREE_OPERAND (exp, 1), temp, 0);\n \t    op1 = op0;\n+\t    dest_right_flag = get_last_insn ();\n \t  }\n #endif\n \t/* Check for A op 0 ? A : FOO and A op 0 ? FOO : A where OP is any\n@@ -5518,9 +5545,14 @@ expand_expr (exp, target, tmode, modifier)\n \t    if (GET_CODE (temp) == REG && REGNO (temp) < FIRST_PSEUDO_REGISTER)\n \t      temp = gen_reg_rtx (mode);\n \t    store_expr (TREE_OPERAND (exp, 1), temp, 0);\n+\t    dest_left_flag = get_last_insn ();\n \t    jumpif (TREE_OPERAND (exp, 0), op0);\n+\n+\t    /* Allows cleanups up to here. */\n+\t    old_cleanups = cleanups_this_call;\n \t    store_expr (TREE_OPERAND (exp, 2), temp, 0);\n \t    op1 = op0;\n+\t    dest_right_flag = get_last_insn ();\n \t  }\n \telse if (temp\n \t\t && TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, 0))) == '<'\n@@ -5533,24 +5565,31 @@ expand_expr (exp, target, tmode, modifier)\n \t    if (GET_CODE (temp) == REG && REGNO (temp) < FIRST_PSEUDO_REGISTER)\n \t      temp = gen_reg_rtx (mode);\n \t    store_expr (TREE_OPERAND (exp, 2), temp, 0);\n+\t    dest_left_flag = get_last_insn ();\n \t    jumpifnot (TREE_OPERAND (exp, 0), op0);\n+\n+\t    /* Allows cleanups up to here. */\n+\t    old_cleanups = cleanups_this_call;\n \t    store_expr (TREE_OPERAND (exp, 1), temp, 0);\n \t    op1 = op0;\n+\t    dest_right_flag = get_last_insn ();\n \t  }\n \telse\n \t  {\n \t    op1 = gen_label_rtx ();\n \t    jumpifnot (TREE_OPERAND (exp, 0), op0);\n+\n+\t    /* Allows cleanups up to here. */\n+\t    old_cleanups = cleanups_this_call;\n \t    if (temp != 0)\n \t      store_expr (TREE_OPERAND (exp, 1), temp, 0);\n \t    else\n \t      expand_expr (TREE_OPERAND (exp, 1),\n \t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n-\t    if (cleanups_this_call)\n-\t      {\n-\t\tsorry (\"aggregate value in COND_EXPR\");\n-\t\tcleanups_this_call = 0;\n-\t      }\n+\t    dest_left_flag = get_last_insn ();\n+\n+\t    /* Handle conditional cleanups, if any. */\n+\t    left_cleanups = defer_cleanups_to (old_cleanups);\n \n \t    emit_queue ();\n \t    emit_jump_insn (gen_jump (op1));\n@@ -5561,18 +5600,58 @@ expand_expr (exp, target, tmode, modifier)\n \t    else\n \t      expand_expr (TREE_OPERAND (exp, 2),\n \t\t\t   ignore ? const0_rtx : NULL_RTX, VOIDmode, 0);\n+\t    dest_right_flag = get_last_insn ();\n \t  }\n \n-\tif (cleanups_this_call)\n-\t  {\n-\t    sorry (\"aggregate value in COND_EXPR\");\n-\t    cleanups_this_call = 0;\n-\t  }\n+\t/* Handle conditional cleanups, if any. */\n+\tright_cleanups = defer_cleanups_to (old_cleanups);\n \n \temit_queue ();\n \temit_label (op1);\n \tOK_DEFER_POP;\n-\tcleanups_this_call = old_cleanups;\n+\n+\t/* Add back in, any conditional cleanups. */\n+\tif (left_cleanups || right_cleanups)\n+\t  {\n+\t    tree new_cleanups;\n+\t    tree cond;\n+\t    rtx last;\n+\n+\t    /* Now that we know that a flag is needed, go back and add in the\n+\t       setting of the flag. */\n+\n+\t    /* Do the left side flag. */\n+\t    last = get_last_insn ();\n+\t    /* Flag left cleanups as needed. */\n+\t    emit_move_insn (flag, const1_rtx);\n+\t    /* ??? deprecated, use sequences instead.  */\n+\t    reorder_insns (NEXT_INSN (last), get_last_insn (), dest_left_flag);\n+\n+\t    /* Do the right side flag. */\n+\t    last = get_last_insn ();\n+\t    /* Flag left cleanups as needed. */\n+\t    emit_move_insn (flag, const0_rtx);\n+\t    /* ??? deprecated, use sequences instead.  */\n+\t    reorder_insns (NEXT_INSN (last), get_last_insn (), dest_right_flag);\n+\n+\t    /* convert flag, which is an rtx, into a tree. */\n+\t    cond = make_node (RTL_EXPR);\n+\t    TREE_TYPE (cond) = integer_type_node;\n+\t    RTL_EXPR_RTL (cond) = flag;\n+\t    RTL_EXPR_SEQUENCE (cond) = NULL_RTX;\n+\n+\t    if (! left_cleanups)\n+\t      left_cleanups = integer_zero_node;\n+\t    if (! right_cleanups)\n+\t      right_cleanups = integer_zero_node;\n+\t    new_cleanups = build (COND_EXPR, void_type_node, cond,\n+\t\t\t\t  left_cleanups, right_cleanups);\n+\t    new_cleanups = fold (new_cleanups);\n+\n+\t    /* Now add in the conditionalized cleanups. */\n+\t    cleanups_this_call\n+\t      = tree_cons (NULL_TREE, new_cleanups, cleanups_this_call);\n+\t  }\n \treturn temp;\n       }\n \n@@ -8170,6 +8249,45 @@ do_pending_stack_adjust ()\n     }\n }\n \n+/* Defer the expansion all cleanups up to OLD_CLEANUPS.\n+   Returns the cleanups to be performed.  */\n+\n+static tree\n+defer_cleanups_to (old_cleanups)\n+     tree old_cleanups;\n+{\n+  tree new_cleanups = NULL_TREE;\n+  tree cleanups = cleanups_this_call;\n+  tree last = NULL_TREE;\n+\n+  while (cleanups_this_call != old_cleanups)\n+    {\n+      cleanups_this_call = TREE_CHAIN (cleanups_this_call);\n+    }      \n+\n+  if (last)\n+    {\n+      /* Remove the list from the chain of cleanups.  */\n+      TREE_CHAIN (last) = NULL_TREE;\n+\n+      /* reverse them so that we can build them in the right order.  */\n+      cleanups = nreverse (cleanups);\n+\n+      while (cleanups)\n+\t{\n+\t  if (new_cleanups)\n+\t    new_cleanups = build (COMPOUND_EXPR, TREE_TYPE (new_cleanups),\n+\t\t\t\t  TREE_VALUE (cleanups), new_cleanups);\n+\t  else\n+\t    new_cleanups = TREE_VALUE (cleanups);\n+\n+\t  cleanups = TREE_CHAIN (cleanups);\n+\t}\n+    }\n+\n+  return new_cleanups;\n+}\n+\n /* Expand all cleanups up to OLD_CLEANUPS.\n    Needed here, and also for language-dependent calls.  */\n "}, {"sha": "07ea73490eec0e4624cda0f2fa054c69d60ee6ae", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dab5552a1f1e1a025b47ff2732e1ddaa6febae0/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dab5552a1f1e1a025b47ff2732e1ddaa6febae0/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=5dab5552a1f1e1a025b47ff2732e1ddaa6febae0", "patch": "@@ -294,6 +294,10 @@ extern int flag_schedule_insns_after_reload;\n \n extern int flag_delayed_branch;\n \n+/* Nonzero means to run cleanups after CALL_EXPRs. */\n+\n+extern int flag_short_temps;\n+\n /* Nonzero means pretend it is OK to examine bits of target floats,\n    even if that isn't true.  The resulting code will have incorrect constants,\n    but the same series of instructions that the native compiler would make.  */"}, {"sha": "ec0baa4abdd2bc32b15c613fecc60808201e2d41", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dab5552a1f1e1a025b47ff2732e1ddaa6febae0/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dab5552a1f1e1a025b47ff2732e1ddaa6febae0/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=5dab5552a1f1e1a025b47ff2732e1ddaa6febae0", "patch": "@@ -448,6 +448,10 @@ int flag_shared_data;\n \n int flag_delayed_branch;\n \n+/* Nonzero means to run cleanups after CALL_EXPRs.  */\n+\n+int flag_short_temps;\n+\n /* Nonzero if we are compiling pure (sharable) code.\n    Value is 1 if we are doing reasonable (i.e. simple\n    offset into offset table) pic.  Value is 2 if we can\n@@ -666,6 +670,8 @@ char *lang_options[] =\n   \"-fno-nonnull-objects\",\n   \"-fsave-memoized\",\n   \"-fno-save-memoized\",\n+  \"-fshort-temps\",\n+  \"-fno-short-temps\",\n   \"-fstats\",\n   \"-fno-stats\",\n   \"-fstrict-prototype\","}, {"sha": "71d638640eb6a46a5195cc941135a6c09d4c2d48", "filename": "gcc/tree.def", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dab5552a1f1e1a025b47ff2732e1ddaa6febae0/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dab5552a1f1e1a025b47ff2732e1ddaa6febae0/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=5dab5552a1f1e1a025b47ff2732e1ddaa6febae0", "patch": "@@ -436,10 +436,16 @@ DEFTREECODE (METHOD_CALL_EXPR, \"method_call_expr\", \"e\", 4)\n    Operand 2 is the cleanup expression for the object.\n      The RTL_EXPR is used in this expression, which is how the expression\n      manages to act on the proper value.\n-   The cleanup is executed when the value is no longer needed,\n-   which is not at precisely the same time that this value is computed.  */\n+   The cleanup is executed by the first enclosing CLEANUP_POINT_EXPR, if\n+   it exists, otherwise it is the responsibility of the caller to manually\n+   call expand_cleanups_to, as needed.  */\n DEFTREECODE (WITH_CLEANUP_EXPR, \"with_cleanup_expr\", \"e\", 3)\n \n+/* Specify a cleanup point.\n+   Operand 0 is the expression that has cleanups that we want ensure are\n+   cleaned up.  */\n+DEFTREECODE (CLEANUP_POINT_EXPR, \"cleanup_point_expr\", \"e\", 1)\n+\n /* The following two codes are used in languages that have types where\n    the position and/or sizes of fields vary from object to object of the\n    same type, i.e., where some other field in the object contains a value"}]}