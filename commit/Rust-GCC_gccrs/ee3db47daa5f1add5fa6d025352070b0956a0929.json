{"sha": "ee3db47daa5f1add5fa6d025352070b0956a0929", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWUzZGI0N2RhYTVmMWFkZDVmYTZkMDI1MzUyMDcwYjA5NTZhMDkyOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-10-07T22:54:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-10-07T22:54:35Z"}, "message": "expr.c (store_expr_with_bounds): Handle aggregate moves from BLKmode.\n\n\n\t* expr.c (store_expr_with_bounds): Handle aggregate moves from\n\tBLKmode.\n\t* gimple-expr.c (useless_type_conversion_p): Do not use TYPE_CANONICAL\n\tto define gimple type system; compare aggregates only by size.\n\nFrom-SVN: r228586", "tree": {"sha": "42a9c5df71558c4b9f561422da10083a7fc6fc6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42a9c5df71558c4b9f561422da10083a7fc6fc6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee3db47daa5f1add5fa6d025352070b0956a0929", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee3db47daa5f1add5fa6d025352070b0956a0929", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee3db47daa5f1add5fa6d025352070b0956a0929", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee3db47daa5f1add5fa6d025352070b0956a0929/comments", "author": null, "committer": null, "parents": [{"sha": "d44bd40ef006102f4001a54a2ac37fbf3b67f128", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d44bd40ef006102f4001a54a2ac37fbf3b67f128", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d44bd40ef006102f4001a54a2ac37fbf3b67f128"}], "stats": {"total": 40, "additions": 30, "deletions": 10}, "files": [{"sha": "bc6fbc6446f9c82c474d7764aaed49b97a682924", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee3db47daa5f1add5fa6d025352070b0956a0929/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee3db47daa5f1add5fa6d025352070b0956a0929/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee3db47daa5f1add5fa6d025352070b0956a0929", "patch": "@@ -1,11 +1,17 @@\n+2015-10-07  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* expr.c (store_expr_with_bounds): Handle aggregate moves from\n+\tBLKmode.\n+\t* gimple-expr.c (useless_type_conversion_p): Do not use TYPE_CANONICAL\n+\tto define gimple type system; compare aggregates only by size.\n+\n 2015-10-07  Jeff Law  <law@redhat.com>\n \n \t* tree-ssa-dom.c (optimize_stmt): Don't set LOOPS_NEED_FIXUP here.\n \t* tree-ssa-threadupdate.c (remove_ctrl_stmt_and_useless_edges): Do it\n \there instead.  Tighten test to avoid setting LOOPS_NEED_FIXUP \n \tunnecessarily.\n \n-@@ -1848,12 +1848,6 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n 2015-10-07  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n "}, {"sha": "6f6554d25c0088149c652e68c61f79682ba444a3", "filename": "gcc/expr.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee3db47daa5f1add5fa6d025352070b0956a0929/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee3db47daa5f1add5fa6d025352070b0956a0929/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ee3db47daa5f1add5fa6d025352070b0956a0929", "patch": "@@ -5425,6 +5425,14 @@ store_expr_with_bounds (tree exp, rtx target, int call_param_p,\n     temp = convert_modes (GET_MODE (target), TYPE_MODE (TREE_TYPE (exp)),\n \t\t\t  temp, TYPE_UNSIGNED (TREE_TYPE (exp)));\n \n+  /* We allow move between structures of same size but different mode.\n+     If source is in memory and the mode differs, simply change the memory.  */\n+  if (GET_MODE (temp) == BLKmode && GET_MODE (target) != BLKmode)\n+    {\n+      gcc_assert (MEM_P (temp));\n+      temp = adjust_address_nv (temp, GET_MODE (target), 0);\n+    }\n+\n   /* If value was not generated in the target, store it there.\n      Convert the value to TARGET's type first if necessary and emit the\n      pending incrementations that have been queued when expanding EXP."}, {"sha": "2a6ba1aadb919be62589d8eee67f980f814755c5", "filename": "gcc/gimple-expr.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee3db47daa5f1add5fa6d025352070b0956a0929/gcc%2Fgimple-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee3db47daa5f1add5fa6d025352070b0956a0929/gcc%2Fgimple-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.c?ref=ee3db47daa5f1add5fa6d025352070b0956a0929", "patch": "@@ -87,11 +87,6 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n   if (inner_type == outer_type)\n     return true;\n \n-  /* If we know the canonical types, compare them.  */\n-  if (TYPE_CANONICAL (inner_type)\n-      && TYPE_CANONICAL (inner_type) == TYPE_CANONICAL (outer_type))\n-    return true;\n-\n   /* Changes in machine mode are never useless conversions unless we\n      deal with aggregate types in which case we defer to later checks.  */\n   if (TYPE_MODE (inner_type) != TYPE_MODE (outer_type)\n@@ -270,12 +265,23 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n       return true;\n     }\n \n-  /* For aggregates we rely on TYPE_CANONICAL exclusively and require\n-     explicit conversions for types involving to be structurally\n-     compared types.  */\n+  /* For aggregates compare only the size.  Accesses to fields do have\n+     a type information by themselves and thus we only care if we can i.e.\n+     use the types in move operations.  */\n   else if (AGGREGATE_TYPE_P (inner_type)\n \t   && TREE_CODE (inner_type) == TREE_CODE (outer_type))\n-    return false;\n+    return (!TYPE_SIZE (outer_type)\n+\t    || (TYPE_SIZE (inner_type)\n+\t\t&& operand_equal_p (TYPE_SIZE (inner_type),\n+\t\t\t\t    TYPE_SIZE (outer_type), 0)));\n+\n+  else if (TREE_CODE (inner_type) == OFFSET_TYPE\n+\t   && TREE_CODE (outer_type) == OFFSET_TYPE)\n+    return useless_type_conversion_p (TREE_TYPE (outer_type),\n+\t\t\t\t      TREE_TYPE (inner_type))\n+\t   && useless_type_conversion_p\n+\t        (TYPE_OFFSET_BASETYPE (outer_type),\n+\t\t TYPE_OFFSET_BASETYPE (inner_type));\n \n   return false;\n }"}]}