{"sha": "02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJlMjRjN2FiMGNjNjMyZmVmYjYyMWFlM2RiY2UyYTJhMDVkYmMzYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-09-10T10:46:00Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-09-10T10:46:00Z"}, "message": "tree.h (DECL_ORIGIN): New macro.\n\n\t* tree.h (DECL_ORIGIN): New macro.\n\t* integrate.c (copy_and_set_decl_abstract_origin): New function.\n\t(copy_decl_list): Use it.\n\t(integrate_parm_decls): Likewise.\n\t(integrate_decl_tree): Likewise.\n\t* dwarf2out.c (decl_ultimate_origin): Simplify.\n\t* dwarfout.c (decl_ultimate_origin): Likewise.\n\t* c-decl.c (duplicate_decls): Use DECL_ORIGIN.\n\t(pushdecl): Likewise.\n\nFrom-SVN: r22380", "tree": {"sha": "de9738c2acffbfb708c950c2f7ba7a0d60650a14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de9738c2acffbfb708c950c2f7ba7a0d60650a14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c/comments", "author": null, "committer": null, "parents": [{"sha": "76f42086770774e0584495b4613cf360a0759c3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76f42086770774e0584495b4613cf360a0759c3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76f42086770774e0584495b4613cf360a0759c3f"}], "stats": {"total": 111, "additions": 61, "deletions": 50}, "files": [{"sha": "d49c23253afb1aa4e8fb0a2ba83c63d0585a8aa8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c", "patch": "@@ -1,3 +1,15 @@\n+Thu Sep 10 10:46:01 1998  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* tree.h (DECL_ORIGIN): New macro.\n+\t* integrate.c (copy_and_set_decl_abstract_origin): New function.\n+\t(copy_decl_list): Use it.\n+\t(integrate_parm_decls): Likewise.\n+\t(integrate_decl_tree): Likewise.\n+\t* dwarf2out.c (decl_ultimate_origin): Simplify.\n+\t* dwarfout.c (decl_ultimate_origin): Likewise.\n+\t* c-decl.c (duplicate_decls): Use DECL_ORIGIN.\n+\t(pushdecl): Likewise.\n+\n Thu Sep 10 08:01:31 1998  Anthony Green  <green@cygnus.com>\n \n \t* config/rs6000/rs6000.c (output_epilog): Add Java support.\n@@ -388,7 +400,6 @@ Thu Sep  3 18:05:16 1998  David Edelsohn  <edelsohn@mhpcc.edu>\n \t(movdf): Remove TARGET_POWERPC64 explicit secondary-reload-like\n \tfunctionality.\n \n->>>>>>> 1.2012\n Thu Sep  3 11:41:40 1998  Robert Lipe   <robertl@dgii.com>\n \n \t* fixinc.sco: Borrow code to wrap 'bool' typedefs from tinfo.h"}, {"sha": "168400bd7f5ada0c1605a00af6b0911c52f8d719", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c", "patch": "@@ -2020,7 +2020,7 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t  DECL_SAVED_INSNS (newdecl) = DECL_SAVED_INSNS (olddecl);\n \t  DECL_ARGUMENTS (newdecl) = DECL_ARGUMENTS (olddecl);\n \t  if (DECL_INLINE (newdecl))\n-\t    DECL_ABSTRACT_ORIGIN (newdecl) = olddecl;\n+\t    DECL_ABSTRACT_ORIGIN (newdecl) = DECL_ORIGIN (olddecl);\n \t}\n     }\n   if (different_binding_level)\n@@ -2384,7 +2384,7 @@ pushdecl (x)\n \t\t      DECL_ARGUMENTS (x) = DECL_ARGUMENTS (oldglobal);\n \t\t      DECL_RESULT (x) = DECL_RESULT (oldglobal);\n \t\t      TREE_ASM_WRITTEN (x) = TREE_ASM_WRITTEN (oldglobal);\n-\t\t      DECL_ABSTRACT_ORIGIN (x) = oldglobal;\n+\t\t      DECL_ABSTRACT_ORIGIN (x) = DECL_ORIGIN (oldglobal);\n \t\t    }\n \t\t  /* Inner extern decl is built-in if global one is.  */\n \t\t  if (DECL_BUILT_IN (oldglobal))"}, {"sha": "d768320b2dec30508d33da2349d9c6cfdae06095", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c", "patch": "@@ -3539,24 +3539,14 @@ static tree\n decl_ultimate_origin (decl)\n      register tree decl;\n {\n-  register tree immediate_origin = DECL_ABSTRACT_ORIGIN (decl);\n-\n-  if (immediate_origin == NULL_TREE)\n-    return NULL_TREE;\n-  else\n-    {\n-      register tree ret_val;\n-      register tree lookahead = immediate_origin;\n-\n-      do\n-\t{\n-\t  ret_val = lookahead;\n-\t  lookahead = DECL_ABSTRACT_ORIGIN (ret_val);\n-\t}\n-      while (lookahead != NULL && lookahead != ret_val);\n+#ifdef ENABLE_CHECKING \n+  if (DECL_FROM_INLINE (DECL_ORIGIN (decl)))\n+    /* Since the DECL_ABSTRACT_ORIGIN for a DECL is supposed to be the\n+       most distant ancestor, this should never happen.  */\n+    abort ();\n+#endif\n \n-      return ret_val;\n-    }\n+  return DECL_ABSTRACT_ORIGIN (decl);\n }\n \n /* Determine the \"ultimate origin\" of a block.  The block may be an inlined\n@@ -9432,7 +9422,7 @@ dwarf2out_decl (decl)\n   if (DECL_IGNORED_P (decl))\n     {\n       if (TREE_CODE (decl) == FUNCTION_DECL\n-\t  && DECL_INITIAL (decl) != NULL)\n+          && DECL_INITIAL (decl) != NULL)\n \tabort ();\n \n       return;"}, {"sha": "660865b11d6223c6a0a8ffc4f40868719bc0a48d", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c", "patch": "@@ -1150,23 +1150,14 @@ static tree\n decl_ultimate_origin (decl)\n      register tree decl;\n {\n-  register tree immediate_origin = DECL_ABSTRACT_ORIGIN (decl);\n-\n-  if (immediate_origin == NULL)\n-    return NULL;\n-  else\n-    {\n-      register tree ret_val;\n-      register tree lookahead = immediate_origin;\n+#ifdef ENABLE_CHECKING \n+  if (DECL_FROM_INLINE (DECL_ORIGIN (decl)))\n+    /* Since the DECL_ABSTRACT_ORIGIN for a DECL is supposed to be the\n+       most distant ancestor, this should never happen.  */\n+    abort ();\n+#endif\n \n-      do\n-\t{\n-\t  ret_val = lookahead;\n-\t  lookahead = DECL_ABSTRACT_ORIGIN (ret_val);\n-\t}\n-      while (lookahead != NULL && lookahead != ret_val);\n-      return ret_val;\n-    }\n+  return DECL_ABSTRACT_ORIGIN (decl);\n }\n \n /* Determine the \"ultimate origin\" of a block.  The block may be an"}, {"sha": "a84eb19435ff1ebf5b7821fc7af0fa83de565917", "filename": "gcc/integrate.c", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c", "patch": "@@ -78,6 +78,7 @@ static void set_decl_origin_self PROTO((tree));\n static void set_block_abstract_flags PROTO((tree, int));\n \n void set_decl_abstract_flags\tPROTO((tree, int));\n+static tree copy_and_set_decl_abstract_origin PROTO((tree));\n \f\n /* Returns the Ith entry in the label_map contained in MAP.  If the\n    Ith entry has not yet been set, return a fresh label.  This function\n@@ -752,11 +753,30 @@ save_for_inline_copying (fndecl)\n     free (label_map);\n }\n \n+/* Copy NODE (as with copy_node).  NODE must be a DECL.  Set the\n+   DECL_ABSTRACT_ORIGIN for the new accordinly.  */\n+\n+static tree\n+copy_and_set_decl_abstract_origin (node)\n+     tree node;\n+{\n+  tree copy = copy_node (node);\n+  if (DECL_ABSTRACT_ORIGIN (copy) != NULL_TREE)\n+    /* That means that NODE already had a DECL_ABSTRACT_ORIGIN.  (This\n+       situation occurs if we inline a function which itself made\n+       calls to inline functions.)  Since DECL_ABSTRACT_ORIGIN is the\n+       most distant ancestor, we don't have to do anything here.  */\n+    ;\n+  else\n+    /* The most distant ancestor must be NODE.  */\n+    DECL_ABSTRACT_ORIGIN (copy) = node;\n+\n+  return copy;\n+}\n+\n /* Return a copy of a chain of nodes, chained through the TREE_CHAIN field.\n    For example, this can copy a list made of TREE_LIST nodes.  While copying,\n-   for each node copied which doesn't already have is DECL_ABSTRACT_ORIGIN\n-   set to some non-zero value, set the DECL_ABSTRACT_ORIGIN of the copy to\n-   point to the corresponding (abstract) original node.  */\n+   set DECL_ABSTRACT_ORIGIN appropriately.  */\n \n static tree\n copy_decl_list (list)\n@@ -768,17 +788,13 @@ copy_decl_list (list)\n   if (list == 0)\n     return 0;\n \n-  head = prev = copy_node (list);\n-  if (DECL_ABSTRACT_ORIGIN (head) == NULL_TREE)\n-    DECL_ABSTRACT_ORIGIN (head) = list;\n+  head = prev = copy_and_set_decl_abstract_origin (head);\n   next = TREE_CHAIN (list);\n   while (next)\n     {\n       register tree copy;\n \n-      copy = copy_node (next);\n-      if (DECL_ABSTRACT_ORIGIN (copy) == NULL_TREE)\n-\tDECL_ABSTRACT_ORIGIN (copy) = next;\n+      copy = copy_and_set_decl_abstract_origin (next);\n       TREE_CHAIN (prev) = copy;\n       prev = copy;\n       next = TREE_CHAIN (next);\n@@ -2192,7 +2208,7 @@ integrate_parm_decls (args, map, arg_vector)\n       /* These args would always appear unused, if not for this.  */\n       TREE_USED (decl) = 1;\n       /* Prevent warning for shadowing with these.  */\n-      DECL_ABSTRACT_ORIGIN (decl) = tail;\n+      DECL_ABSTRACT_ORIGIN (decl) = DECL_ORIGIN (tail);\n       pushdecl (decl);\n       /* Fully instantiate the address with the equivalent form so that the\n \t debugging information contains the actual register, instead of the\n@@ -2231,7 +2247,7 @@ integrate_decl_tree (let, level, map)\n \n       push_obstacks_nochange ();\n       saveable_allocation ();\n-      d = copy_node (t);\n+      d = copy_and_set_decl_abstract_origin (t);\n       pop_obstacks ();\n \n       if (DECL_RTL (t) != 0)\n@@ -2246,8 +2262,6 @@ integrate_decl_tree (let, level, map)\n \t}\n       /* These args would always appear unused, if not for this.  */\n       TREE_USED (d) = 1;\n-      /* Prevent warning for shadowing with these.  */\n-      DECL_ABSTRACT_ORIGIN (d) = t;\n \n       if (DECL_LANG_SPECIFIC (d))\n \tcopy_lang_decl (d);"}, {"sha": "aee712fc97fdf24d4d0ecd415eb440c39b76b702", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=02e24c7ab0cc632fefb621ae3dbce2a2a05dbc3c", "patch": "@@ -1101,6 +1101,11 @@ struct tree_type\n    definition.  */\n #define DECL_ABSTRACT_ORIGIN(NODE) (DECL_CHECK (NODE)->decl.abstract_origin)\n \n+/* Like DECL_ABSTRACT_ORIGIN, but returns NODE if there's no abstract\n+   origin.  This is useful when setting the DECL_ABSTRACT_ORIGIN.  */\n+#define DECL_ORIGIN(NODE) \\\n+  (DECL_ABSTRACT_ORIGIN (NODE) ? DECL_ABSTRACT_ORIGIN (NODE) : NODE)\n+\n /* Nonzero for any sort of ..._DECL node means this decl node represents\n    an inline instance of some original (abstract) decl from an inline function;\n    suppress any warnings about shadowing some other variable.  */"}]}