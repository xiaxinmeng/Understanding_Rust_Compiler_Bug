{"sha": "a8a6b603730faa3abbc8fd6c2cc3f066dbb70bfa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThhNmI2MDM3MzBmYWEzYWJiYzhmZDZjMmNjM2YwNjZkYmI3MGJmYQ==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2004-07-10T11:21:42Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-07-10T11:21:42Z"}, "message": "trans-common.c: Fix whitespace issues, make variable names more readable.\n\n* trans-common.c: Fix whitespace issues, make variable names\nmore readable.\n(create_common): Additionally, make loop logic more obvious.\n\nCo-Authored-By: Paul Brook <paul@codesourcery.com>\n\nFrom-SVN: r84453", "tree": {"sha": "17560223d99fb7c4281da2c64c492c6c61e40dc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17560223d99fb7c4281da2c64c492c6c61e40dc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8a6b603730faa3abbc8fd6c2cc3f066dbb70bfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8a6b603730faa3abbc8fd6c2cc3f066dbb70bfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8a6b603730faa3abbc8fd6c2cc3f066dbb70bfa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8a6b603730faa3abbc8fd6c2cc3f066dbb70bfa/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44bce8bfac2304add83f6c860f534c9287640090", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44bce8bfac2304add83f6c860f534c9287640090", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44bce8bfac2304add83f6c860f534c9287640090"}], "stats": {"total": 233, "additions": 120, "deletions": 113}, "files": [{"sha": "f95d64a4345bc81769ebb68cba6a42157c19aad0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a6b603730faa3abbc8fd6c2cc3f066dbb70bfa/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a6b603730faa3abbc8fd6c2cc3f066dbb70bfa/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a8a6b603730faa3abbc8fd6c2cc3f066dbb70bfa", "patch": "@@ -1,4 +1,10 @@\n-2004-07-10 Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+2004-07-10  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\t* trans-common.c: Fix whitespace issues, make variable names\n+\tmore readable.\n+\t(create_common): Additionally, make loop logic more obvious.\n+\n+2004-07-10  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \tPaul Brook  <paul@codesourcery.com>\n \n \tPR fortran/13415"}, {"sha": "d20a60be906cf4c616b9a98518bf3ad3ccb9fa50", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 113, "deletions": 112, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8a6b603730faa3abbc8fd6c2cc3f066dbb70bfa/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8a6b603730faa3abbc8fd6c2cc3f066dbb70bfa/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=a8a6b603730faa3abbc8fd6c2cc3f066dbb70bfa", "patch": "@@ -113,7 +113,7 @@ typedef struct segment_info\n   HOST_WIDE_INT offset;\n   HOST_WIDE_INT length;\n   /* This will contain the field type until the field is created.  */\n-  tree field; \n+  tree field;\n   struct segment_info *next;\n } segment_info;\n \n@@ -123,7 +123,6 @@ static gfc_namespace *gfc_common_ns = NULL;\n \n #define BLANK_COMMON_NAME \"__BLNK__\"\n \n-\n /* Make a segment_info based on a symbol.  */\n \n static segment_info *\n@@ -146,15 +145,15 @@ get_segment_info (gfc_symbol * sym, HOST_WIDE_INT offset)\n   return s;\n }\n \n-/* Add combine segment V and segement LIST.  */\n+/* Add combine segment V and segment LIST.  */\n \n static segment_info *\n add_segments (segment_info *list, segment_info *v)\n {\n   segment_info *s;\n   segment_info *p;\n   segment_info *next;\n-  \n+\n   p = NULL;\n   s = list;\n \n@@ -184,6 +183,7 @@ add_segments (segment_info *list, segment_info *v)\n       p = v;\n       v = next;\n     }\n+\n   return list;\n }\n \n@@ -197,13 +197,15 @@ gfc_sym_mangled_common_id (const char  *name)\n \n   if (strcmp (name, BLANK_COMMON_NAME) == 0)\n     return get_identifier (name);\n+\n   if (gfc_option.flag_underscoring)\n     {\n       has_underscore = strchr (name, '_') != 0;\n       if (gfc_option.flag_second_underscore && has_underscore)\n         snprintf (mangled_name, sizeof mangled_name, \"%s__\", name);\n       else\n         snprintf (mangled_name, sizeof mangled_name, \"%s_\", name);\n+\n       return get_identifier (mangled_name);\n     }\n   else\n@@ -275,7 +277,7 @@ build_equiv_decl (tree union_type, bool is_init)\n /* Get storage for common block.  */\n \n static tree\n-build_common_decl (gfc_common_head *com, const char *name, \n+build_common_decl (gfc_common_head *com, const char *name,\n \t\t   tree union_type, bool is_init)\n {\n   gfc_symbol *common_sym;\n@@ -298,8 +300,8 @@ build_common_decl (gfc_common_head *com, const char *name,\n              in all scoping units of a program in which they appear, but\n              blank common blocks may be of different sizes.  */\n           if (strcmp (name, BLANK_COMMON_NAME))\n-              gfc_warning (\"Named COMMON block '%s' at %L shall be of the \"\n-                           \"same size\", name, &com->where);\n+\t    gfc_warning (\"Named COMMON block '%s' at %L shall be of the \"\n+\t\t\t \"same size\", name, &com->where);\n           DECL_SIZE_UNIT (decl) = size;\n         }\n      }\n@@ -331,7 +333,6 @@ build_common_decl (gfc_common_head *com, const char *name,\n       DECL_INITIAL (decl) = NULL_TREE;\n       DECL_COMMON (decl) = 1;\n       DECL_DEFER_OUTPUT (decl) = 1;\n-\n     }\n   else\n     {\n@@ -348,8 +349,8 @@ build_common_decl (gfc_common_head *com, const char *name,\n \n static void\n create_common (gfc_common_head *com, const char *name)\n-{ \n-  segment_info *h, *next_s; \n+{\n+  segment_info *s, *next_s;\n   tree union_type;\n   tree *field_link;\n   record_layout_info rli;\n@@ -361,19 +362,17 @@ create_common (gfc_common_head *com, const char *name)\n   rli = start_record_layout (union_type);\n   field_link = &TYPE_FIELDS (union_type);\n \n-  for (h = current_common; h; h = next_s)\n+  for (s = current_common; s; s = s->next)\n     {\n-      build_field (h, union_type, rli);\n+      build_field (s, union_type, rli);\n \n       /* Link the field into the type.  */\n-      *field_link = h->field;\n-      field_link = &TREE_CHAIN (h->field);\n+      *field_link = s->field;\n+      field_link = &TREE_CHAIN (s->field);\n \n-      /* Has initial value.  */      \n-      if (h->sym->value)\n+      /* Has initial value.  */\n+      if (s->sym->value)\n         is_init = true;\n-    \n-      next_s = h->next;\n     }\n   finish_record_layout (rli, true);\n \n@@ -389,46 +388,46 @@ create_common (gfc_common_head *com, const char *name)\n       HOST_WIDE_INT offset = 0;\n \n       list = NULL_TREE;\n-      for (h = current_common; h; h = h->next)\n+      for (s = current_common; s; s = s->next)\n         {\n-          if (h->sym->value)\n+          if (s->sym->value)\n             {\n-              if (h->offset < offset)\n+              if (s->offset < offset)\n                 {\n \t\t    /* We have overlapping initializers.  It could either be\n-\t\t       partially initilalized arrays (lagal), or the user\n+\t\t       partially initilalized arrays (legal), or the user\n \t\t       specified multiple initial values (illegal).\n \t\t       We don't implement this yet, so bail out.  */\n                   gfc_todo_error (\"Initialization of overlapping variables\");\n                 }\n-              if (h->sym->attr.dimension)\n+              if (s->sym->attr.dimension)\n                 {\n-                  tmp = gfc_conv_array_initializer (TREE_TYPE (h->field),\n-                                                  h->sym->value);\n-                  list = tree_cons (h->field, tmp, list);\n+                  tmp = gfc_conv_array_initializer (TREE_TYPE (s->field),\n+\t\t\t\t\t\t    s->sym->value);\n+                  list = tree_cons (s->field, tmp, list);\n                 }\n               else\n                 {\n-\t\t  switch (h->sym->ts.type)\n+\t\t  switch (s->sym->ts.type)\n \t\t    {\n \t\t    case BT_CHARACTER:\n \t\t      se.expr = gfc_conv_string_init\n-\t\t\t(h->sym->ts.cl->backend_decl, h->sym->value);\n+\t\t\t(s->sym->ts.cl->backend_decl, s->sym->value);\n \t\t      break;\n \n \t\t    case BT_DERIVED:\n \t\t      gfc_init_se (&se, NULL);\n-\t\t      gfc_conv_structure (&se, h->sym->value, 1);\n+\t\t      gfc_conv_structure (&se, s->sym->value, 1);\n \t\t      break;\n \n \t\t    default:\n \t\t      gfc_init_se (&se, NULL);\n-\t\t      gfc_conv_expr (&se, h->sym->value);\n+\t\t      gfc_conv_expr (&se, s->sym->value);\n \t\t      break;\n \t\t    }\n-                  list = tree_cons (h->field, se.expr, list);\n+                  list = tree_cons (s->field, se.expr, list);\n                 }\n-              offset = h->offset + h->length;\n+              offset = s->offset + s->length;\n             }\n         }\n       assert (list);\n@@ -445,23 +444,23 @@ create_common (gfc_common_head *com, const char *name)\n     }\n \n   /* Build component reference for each variable.  */\n-  for (h = current_common; h; h = next_s)\n+  for (s = current_common; s; s = next_s)\n     {\n-      h->sym->backend_decl = build (COMPONENT_REF, TREE_TYPE (h->field),\n-                                    decl, h->field, NULL_TREE);\n+      s->sym->backend_decl = build (COMPONENT_REF, TREE_TYPE (s->field),\n+                                    decl, s->field, NULL_TREE);\n \n-      next_s = h->next;\n-      gfc_free (h);\n+      next_s = s->next;\n+      gfc_free (s);\n     }\n-}   \n+}\n \n \n /* Given a symbol, find it in the current segment list. Returns NULL if\n-   not found.  */ \n+   not found.  */\n \n-static segment_info * \n+static segment_info *\n find_segment_info (gfc_symbol *symbol)\n-{          \n+{\n   segment_info *n;\n \n   for (n = current_segment; n; n = n->next)\n@@ -470,53 +469,54 @@ find_segment_info (gfc_symbol *symbol)\n \treturn n;\n     }\n \n-  return NULL;    \n-} \n+  return NULL;\n+}\n \n \n /* Given an expression node, make sure it is a constant integer and return\n-   the mpz_t value.  */     \n+   the mpz_t value.  */\n \n-static mpz_t * \n-get_mpz (gfc_expr *g)\n+static mpz_t *\n+get_mpz (gfc_expr *e)\n {\n-  if (g->expr_type != EXPR_CONSTANT)\n+\n+  if (e->expr_type != EXPR_CONSTANT)\n     gfc_internal_error (\"get_mpz(): Not an integer constant\");\n \n-  return &g->value.integer;\n-}      \n+  return &e->value.integer;\n+}\n \n \n /* Given an array specification and an array reference, figure out the\n    array element number (zero based). Bounds and elements are guaranteed\n    to be constants.  If something goes wrong we generate an error and\n-   return zero.  */ \n+   return zero.  */\n  \n static HOST_WIDE_INT\n element_number (gfc_array_ref *ar)\n-{       \n-  mpz_t multiplier, offset, extent, l;\n+{\n+  mpz_t multiplier, offset, extent, n;\n   gfc_array_spec *as;\n-  HOST_WIDE_INT b, rank;\n+  HOST_WIDE_INT i, rank;\n \n   as = ar->as;\n   rank = as->rank;\n   mpz_init_set_ui (multiplier, 1);\n   mpz_init_set_ui (offset, 0);\n   mpz_init (extent);\n-  mpz_init (l);\n+  mpz_init (n);\n \n-  for (b = 0; b < rank; b++)\n+  for (i = 0; i < rank; i++)\n     { \n-      if (ar->dimen_type[b] != DIMEN_ELEMENT)\n+      if (ar->dimen_type[i] != DIMEN_ELEMENT)\n         gfc_internal_error (\"element_number(): Bad dimension type\");\n \n-      mpz_sub (l, *get_mpz (ar->start[b]), *get_mpz (as->lower[b]));\n+      mpz_sub (n, *get_mpz (ar->start[i]), *get_mpz (as->lower[i]));\n  \n-      mpz_mul (l, l, multiplier);\n-      mpz_add (offset, offset, l);\n+      mpz_mul (n, n, multiplier);\n+      mpz_add (offset, offset, n);\n  \n-      mpz_sub (extent, *get_mpz (as->upper[b]), *get_mpz (as->lower[b]));\n+      mpz_sub (extent, *get_mpz (as->upper[i]), *get_mpz (as->lower[i]));\n       mpz_add_ui (extent, extent, 1);\n  \n       if (mpz_sgn (extent) < 0)\n@@ -525,14 +525,14 @@ element_number (gfc_array_ref *ar)\n       mpz_mul (multiplier, multiplier, extent);\n     } \n  \n-  b = mpz_get_ui (offset);\n+  i = mpz_get_ui (offset);\n  \n   mpz_clear (multiplier);\n   mpz_clear (offset);\n   mpz_clear (extent);\n-  mpz_clear (l);\n+  mpz_clear (n);\n  \n-  return b;\n+  return i;\n }\n \n \n@@ -543,16 +543,16 @@ element_number (gfc_array_ref *ar)\n    have to calculate the further reference.  */\n \n static HOST_WIDE_INT\n-calculate_offset (gfc_expr *s)\n+calculate_offset (gfc_expr *e)\n {\n-  HOST_WIDE_INT a, element_size, offset;\n+  HOST_WIDE_INT n, element_size, offset;\n   gfc_typespec *element_type;\n   gfc_ref *reference;\n \n   offset = 0;\n-  element_type = &s->symtree->n.sym->ts;\n+  element_type = &e->symtree->n.sym->ts;\n \n-  for (reference = s->ref; reference; reference = reference->next)\n+  for (reference = e->ref; reference; reference = reference->next)\n     switch (reference->type)\n       {\n       case REF_ARRAY:\n@@ -562,16 +562,16 @@ calculate_offset (gfc_expr *s)\n \t    break;\n \n           case AR_ELEMENT:\n-\t    a = element_number (&reference->u.ar);\n+\t    n = element_number (&reference->u.ar);\n \t    if (element_type->type == BT_CHARACTER)\n \t      gfc_conv_const_charlen (element_type->cl);\n \t    element_size =\n               int_size_in_bytes (gfc_typenode_for_spec (element_type));\n-\t    offset += a * element_size;\n+\t    offset += n * element_size;\n \t    break;\n \n           default:\n-\t    gfc_error (\"Bad array reference at %L\", &s->where);\n+\t    gfc_error (\"Bad array reference at %L\", &e->where);\n           }\n         break;\n       case REF_SUBSTRING:\n@@ -580,12 +580,12 @@ calculate_offset (gfc_expr *s)\n         break;\n       default:\n         gfc_error (\"Illegal reference type at %L as EQUIVALENCE object\",\n-                   &s->where);\n-    } \n+                   &e->where);\n+    }\n   return offset;\n }\n \n- \n+\n /* Add a new segment_info structure to the current segment.  eq1 is already\n    in the list, eq2 is not.  */\n \n@@ -594,7 +594,7 @@ new_condition (segment_info *v, gfc_equiv *eq1, gfc_equiv *eq2)\n {\n   HOST_WIDE_INT offset1, offset2;\n   segment_info *a;\n- \n+\n   offset1 = calculate_offset (eq1->expr);\n   offset2 = calculate_offset (eq2->expr);\n \n@@ -610,21 +610,21 @@ new_condition (segment_info *v, gfc_equiv *eq1, gfc_equiv *eq2)\n    is.  */\n \n static void\n-confirm_condition (segment_info *k, gfc_equiv *eq1, segment_info *e,\n+confirm_condition (segment_info *s1, gfc_equiv *eq1, segment_info *s2,\n                    gfc_equiv *eq2)\n {\n   HOST_WIDE_INT offset1, offset2;\n \n   offset1 = calculate_offset (eq1->expr);\n   offset2 = calculate_offset (eq2->expr);\n- \n-  if (k->offset + offset1 != e->offset + offset2)          \n+\n+  if (s1->offset + offset1 != s2->offset + offset2)\n     gfc_error (\"Inconsistent equivalence rules involving '%s' at %L and \"\n-\t       \"'%s' at %L\", k->sym->name, &k->sym->declared_at,\n-\t       e->sym->name, &e->sym->declared_at);\n-} \n+\t       \"'%s' at %L\", s1->sym->name, &s1->sym->declared_at,\n+\t       s2->sym->name, &s2->sym->declared_at);\n+}\n+\n \n- \n /* Process a new equivalence condition. eq1 is know to be in segment f.\n    If eq2 is also present then confirm that the condition holds.\n    Otherwise add a new variable to the segment list.  */\n@@ -648,49 +648,49 @@ add_condition (segment_info *f, gfc_equiv *eq1, gfc_equiv *eq2)\n    checks for rules involving the first symbol in the equivalence set.  */\n  \n static bool\n-find_equivalence (segment_info *f)\n+find_equivalence (segment_info *n)\n {\n-  gfc_equiv *c, *l, *eq, *other;\n+  gfc_equiv *e1, *e2, *eq, *other;\n   bool found;\n  \n   found = FALSE;\n-  for (c = f->sym->ns->equiv; c; c = c->next)\n+  for (e1 = n->sym->ns->equiv; e1; e1 = e1->next)\n     {\n       other = NULL;\n-      for (l = c->eq; l; l = l->eq)\n+      for (e2 = e1->eq; e2; e2 = e2->eq)\n \t{\n-\t  if (l->used)\n+\t  if (e2->used)\n \t    continue;\n \n-\t  if (c->expr->symtree->n.sym == f-> sym)\n+\t  if (e1->expr->symtree->n.sym == n->sym)\n \t    {\n-\t      eq = c;\n-\t      other = l;\n+\t      eq = e1;\n+\t      other = e2;\n \t    }\n-\t  else if (l->expr->symtree->n.sym == f->sym)\n+\t  else if (e2->expr->symtree->n.sym == n->sym)\n \t    {\n-\t      eq = l;\n-\t      other = c;\n+\t      eq = e2;\n+\t      other = e1;\n \t    }\n \t  else\n \t    eq = NULL;\n \t  \n \t  if (eq)\n \t    {\n-\t      add_condition (f, eq, other);\n+\t      add_condition (n, eq, other);\n \t      eq->used = 1;\n \t      found = TRUE;\n \t      /* If this symbol is the first in the chain we may find other\n \t\t matches. Otherwise we can skip to the next equivalence.  */\n-\t      if (eq == l) \n+\t      if (eq == e2)\n \t\tbreak;\n \t    }\n \t}\n     }\n   return found;\n }\n \n- \n+\n /* Add all symbols equivalenced within a segment.  We need to scan the\n    segment list multiple times to include indirect equivalences.  */\n \n@@ -714,28 +714,27 @@ add_equivalences (void)\n \t}\n     }\n }\n-    \n-    \n+\n+\n /* Given a seed symbol, create a new segment consisting of that symbol\n    and all of the symbols equivalenced with that symbol.  */\n- \n+\n static void\n new_segment (gfc_common_head *common, const char *name, gfc_symbol *sym)\n {\n+\n   current_segment = get_segment_info (sym, current_offset);\n \n-  /* The offset of the next common variable.  */ \n+  /* The offset of the next common variable.  */\n   current_offset += current_segment->length;\n \n   /* Add all object directly or indirectly equivalenced with this common\n-     variable.  */ \n+     variable.  */\n   add_equivalences ();\n \n   if (current_segment->offset < 0)\n     gfc_error (\"The equivalence set for '%s' cause an invalid extension \"\n-\t       \"to COMMON '%s' at %L\",\n-\t       sym->name, name, &common->where);\n-\n+\t       \"to COMMON '%s' at %L\", sym->name, name, &common->where);\n \n   /* Add these to the common block.  */\n   current_common = add_segments (current_common, current_segment);\n@@ -753,9 +752,10 @@ finish_equivalences (gfc_namespace *ns)\n   HOST_WIDE_INT min_offset;\n \n   for (z = ns->equiv; z; z = z->next)\n-    for (y= z->eq; y; y = y->eq)\n+    for (y = z->eq; y; y = y->eq)\n       {\n-        if (y->used) continue;\n+        if (y->used) \n+\t  continue;\n         sym = z->expr->symtree->n.sym;\n         current_segment = get_segment_info (sym, 0);\n \n@@ -778,8 +778,8 @@ finish_equivalences (gfc_namespace *ns)\n \n /* Translate a single common block.  */\n \n-static void \n-translate_common (gfc_common_head *common, const char *name, \n+static void\n+translate_common (gfc_common_head *common, const char *name,\n \t\t  gfc_symbol *var_list)\n {\n   gfc_symbol *sym;\n@@ -795,23 +795,24 @@ translate_common (gfc_common_head *common, const char *name,\n     }\n \n   create_common (common, name);\n-}          \n- \n+}\n+\n \n /* Work function for translating a named common block.  */\n \n static void\n named_common (gfc_symtree *st)\n {\n+\n   translate_common (st->n.common, st->name, st->n.common->head);\n }\n \n \n /* Translate the common blocks in a namespace. Unlike other variables,\n    these have to be created before code, because the backend_decl depends\n    on the rest of the common block.  */\n- \n-void \n+\n+void\n gfc_trans_common (gfc_namespace *ns)\n {\n   gfc_common_head *c;\n@@ -824,7 +825,7 @@ gfc_trans_common (gfc_namespace *ns)\n     }\n  \n   /* Translate all named common blocks.  */\n-  gfc_traverse_symtree (ns->common_root, named_common); \n+  gfc_traverse_symtree (ns->common_root, named_common);\n \n   /* Commit the newly created symbols for common blocks.  */\n   gfc_commit_symbols ();"}]}