{"sha": "381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgxY2RhZTQ5Nzg1ZmM0YjE5NDFhNmIzN2JhZDNlOGM2ZjNmNDI4ZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2016-05-03T12:06:19Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-05-03T12:06:19Z"}, "message": "gimplify.h (get_initialized_tmp_var): Add allow_ssa parameter default true.\n\n2016-05-03  Richard Biener  <rguenther@suse.de>\n\n\t* gimplify.h (get_initialized_tmp_var): Add allow_ssa parameter\n\tdefault true.\n\t(gimplify_arg): Likewise.\n\t* gimplify.c (gimplify_expr): Add overload with allow_ssa parameter,\n\tre-writing the result to a decl if required.\n\t(internal_get_tmp_var): Add allow_ssa parameter\n\tand override into_ssa with it.\n\t(get_formal_tmp_var): Adjust.\n\t(get_initialized_tmp_var): Add allow_ssa parameter.\n\t(gimplify_arg): Add allow_ssa parameter and avoid generating\n\tSSA names for the result false.\n\t(gimplify_call_expr): If the call may return twice do not\n\tgimplify parameters into SSA.\n\t(prepare_gimple_addressable): Do not allow an SSA name as\n\ttemporary.\n\t(gimplify_modify_expr): Adjust assert.  For noreturn calls\n\twith a SSA name LHS adjust its def.\n\t(gimplify_save_expr): Do not allow an SSA name as save-expr\n\tresult.\n\t(gimplify_one_sizepos): Do not allow an SSA name as a sizepos.\n\t(gimplify_body): Init GIMPLE SSA data structures and gimplify\n\tinto-SSA.\n\t(gimplify_scan_omp_clauses): Make sure OMP_CLAUSE_SIZE is not\n\tan SSA name.  Likewise for OMP_CLAUSE_REDUCTION operands.\n\t(gimplify_omp_for): Likewise for OMP_CLAUSE_DECL.  Likewise\n\tfor OMP_FOR_COND,  OMP_FOR_INCR and OMP_CLAUSE_LINEAR_STEP.\n\t(optimize_target_teams): Do not allow SSA names for clause operands.\n\t(gimplify_expr): Likewise for where we mark the result addressable.\n\t* passes.def (pass_init_datastructures): Remove.\n\t* tree-into-ssa.c (mark_def_sites): Ignore existing SSA names.\n\t(rewrite_stmt): Likewise.\n\t* tree-inline.c (initialize_cfun): Properly transfer SSA state.\n\t(replace_locals_op): Replace SSA names.\n\t(copy_gimple_seq_and_replace_locals): Init src_cfun.\n\t* gimple-low.c (lower_builtin_setjmp): Deal with SSA.\n\t* cgraph.c (release_function_body): Free CFG annotations only\n\twhen we have a CFG.  Simplify.\n\t* gimple-fold.c (gimplify_and_update_call_from_tree): Use\n\tforce_gimple_operand instead of get_initialized_tmp_var.\n\t* tree-pass.h (make_pass_init_datastructures): Remove.\n\t* tree-ssa.c (execute_init_datastructures): Remove.\n\t(pass_data_init_datastructures): Likewise.\n\t(class pass_init_datastructures): Likewise.\n\t(make_pass_init_datastructures): Likewise.\n\t* omp-low.c (create_omp_child_function): Init SSA data structures.\n\t(grid_expand_target_grid_body): Likewise.\n\t* tree-cfg.c (move_block_to_fn): Double-check the DEF is an SSA\n\tname before adding it to names_to_release.\n\t(remove_bb): Always release SSA defs.\n\t* tree-ssa-ccp.c (get_default_value): Check SSA_NAME_VAR\n\tbefore dereferencing it.\n\t* cgraphunit.c (init_lowered_empty_function): Always\n\tint SSA data structures.\n\t* tree-ssanames.c (release_defs): Remove assert that we are in\n\tSSA form.\n\t* trans-mem.c (diagnose_tm_1): Handle SSA name function.\n\n\tc-family/\n\t* cilk.c (cilk_gimplify_call_params_in_spawned_fn): Do not\n\tallow call args to gimplify to SSA names.\n\n\t* gcc.dg/pr30172-1.c: Adjust.\n\t* gcc.dg/pr63743.c: Likewise.\n\t* gcc.dg/tm/pr51696.c: Likewise.\n\t* c-c++-common/tm/safe-1.c: Likewise.\n\t* gcc.dg/tree-prof/val-prof-3.c: Likewise.\n\t* gcc.dg/plugin/self-assign-test-1.c: XFAIL case that needs CSE.\n\t* g++.dg/plugin/self-assign-test-1.C: Likewise.\n\t* g++.dg/plugin/self-assign-test-2.C: Likewise.\n\nFrom-SVN: r235817", "tree": {"sha": "8bc819891d359849868f63dae660e41900fd0d61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bc819891d359849868f63dae660e41900fd0d61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "31ed166586451e3955d0da9c7931c71da968eee4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31ed166586451e3955d0da9c7931c71da968eee4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31ed166586451e3955d0da9c7931c71da968eee4"}], "stats": {"total": 426, "additions": 268, "deletions": 158}, "files": [{"sha": "ba7f10d6d2a4f956e022b2e4d1d51b295cbb9a01", "filename": "gcc/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -1,3 +1,62 @@\n+2016-05-03  Richard Biener  <rguenther@suse.de>\n+\n+\t* gimplify.h (get_initialized_tmp_var): Add allow_ssa parameter\n+\tdefault true.\n+\t(gimplify_arg): Likewise.\n+\t* gimplify.c (gimplify_expr): Add overload with allow_ssa parameter,\n+\tre-writing the result to a decl if required.\n+\t(internal_get_tmp_var): Add allow_ssa parameter\n+\tand override into_ssa with it.\n+\t(get_formal_tmp_var): Adjust.\n+\t(get_initialized_tmp_var): Add allow_ssa parameter.\n+\t(gimplify_arg): Add allow_ssa parameter and avoid generating\n+\tSSA names for the result false.\n+\t(gimplify_call_expr): If the call may return twice do not\n+\tgimplify parameters into SSA.\n+\t(prepare_gimple_addressable): Do not allow an SSA name as\n+\ttemporary.\n+\t(gimplify_modify_expr): Adjust assert.  For noreturn calls\n+\twith a SSA name LHS adjust its def.\n+\t(gimplify_save_expr): Do not allow an SSA name as save-expr\n+\tresult.\n+\t(gimplify_one_sizepos): Do not allow an SSA name as a sizepos.\n+\t(gimplify_body): Init GIMPLE SSA data structures and gimplify\n+\tinto-SSA.\n+\t(gimplify_scan_omp_clauses): Make sure OMP_CLAUSE_SIZE is not\n+\tan SSA name.  Likewise for OMP_CLAUSE_REDUCTION operands.\n+\t(gimplify_omp_for): Likewise for OMP_CLAUSE_DECL.  Likewise\n+\tfor OMP_FOR_COND,  OMP_FOR_INCR and OMP_CLAUSE_LINEAR_STEP.\n+\t(optimize_target_teams): Do not allow SSA names for clause operands.\n+\t(gimplify_expr): Likewise for where we mark the result addressable.\n+\t* passes.def (pass_init_datastructures): Remove.\n+\t* tree-into-ssa.c (mark_def_sites): Ignore existing SSA names.\n+\t(rewrite_stmt): Likewise.\n+\t* tree-inline.c (initialize_cfun): Properly transfer SSA state.\n+\t(replace_locals_op): Replace SSA names.\n+\t(copy_gimple_seq_and_replace_locals): Init src_cfun.\n+\t* gimple-low.c (lower_builtin_setjmp): Deal with SSA.\n+\t* cgraph.c (release_function_body): Free CFG annotations only\n+\twhen we have a CFG.  Simplify.\n+\t* gimple-fold.c (gimplify_and_update_call_from_tree): Use\n+\tforce_gimple_operand instead of get_initialized_tmp_var.\n+\t* tree-pass.h (make_pass_init_datastructures): Remove.\n+\t* tree-ssa.c (execute_init_datastructures): Remove.\n+\t(pass_data_init_datastructures): Likewise.\n+\t(class pass_init_datastructures): Likewise.\n+\t(make_pass_init_datastructures): Likewise.\n+\t* omp-low.c (create_omp_child_function): Init SSA data structures.\n+\t(grid_expand_target_grid_body): Likewise.\n+\t* tree-cfg.c (move_block_to_fn): Double-check the DEF is an SSA\n+\tname before adding it to names_to_release.\n+\t(remove_bb): Always release SSA defs.\n+\t* tree-ssa-ccp.c (get_default_value): Check SSA_NAME_VAR\n+\tbefore dereferencing it.\n+\t* cgraphunit.c (init_lowered_empty_function): Always\n+\tint SSA data structures.\n+\t* tree-ssanames.c (release_defs): Remove assert that we are in\n+\tSSA form.\n+\t* trans-mem.c (diagnose_tm_1): Handle SSA name function.\n+\n 2016-05-03  Jakub Jelinek  <jakub@redhat.com>\n \t    Uros Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "b34e8ed82c9451ff417ea9d3bef3d3e972502ff9", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -1,3 +1,8 @@\n+2016-05-03  Richard Biener  <rguenther@suse.de>\n+\n+\t* cilk.c (cilk_gimplify_call_params_in_spawned_fn): Do not\n+\tallow call args to gimplify to SSA names.\n+\n 2016-05-03  Marek Polacek  <polacek@redhat.com>\n \n \t* c-common.h (enum c_omp_region_type): Remove stray comma."}, {"sha": "8f34cd6c5e4f690d86600295ce54dfd426024280", "filename": "gcc/c-family/cilk.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fc-family%2Fcilk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fc-family%2Fcilk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fcilk.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -795,9 +795,13 @@ cilk_gimplify_call_params_in_spawned_fn (tree *expr_p, gimple_seq *pre_p)\n     fix_parm_expr = &TREE_OPERAND (*expr_p, 1);\n \n   if (TREE_CODE (*fix_parm_expr) == CALL_EXPR)\n-    for (ii = 0; ii < call_expr_nargs (*fix_parm_expr); ii++)\n-      gimplify_arg (&CALL_EXPR_ARG (*fix_parm_expr, ii), pre_p,\n-\t\t    EXPR_LOCATION (*fix_parm_expr));\n+    {\n+      /* Cilk outlining assumes GENERIC bodies, avoid leaking SSA names\n+         via parameters.  */\n+      for (ii = 0; ii < call_expr_nargs (*fix_parm_expr); ii++)\n+\tgimplify_arg (&CALL_EXPR_ARG (*fix_parm_expr, ii), pre_p,\n+\t\t      EXPR_LOCATION (*fix_parm_expr), false);\n+    }\n }\n \n "}, {"sha": "3105aec82556b94b372219c9dcbec952dfb31bff", "filename": "gcc/cgraph.c", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -1729,30 +1729,26 @@ release_function_body (tree decl)\n   if (fn)\n     {\n       if (fn->cfg\n-\t  || fn->gimple_df)\n+\t  && loops_for_fn (fn))\n \t{\n-\t  if (fn->cfg\n-\t      && loops_for_fn (fn))\n-\t    {\n-\t      fn->curr_properties &= ~PROP_loops;\n-\t      loop_optimizer_finalize (fn);\n-\t    }\n-\t  if (fn->gimple_df)\n-\t    {\n-\t      delete_tree_ssa (fn);\n-\t      delete_tree_cfg_annotations (fn);\n-\t      fn->eh = NULL;\n-\t    }\n-\t  if (fn->cfg)\n-\t    {\n-\t      gcc_assert (!dom_info_available_p (fn, CDI_DOMINATORS));\n-\t      gcc_assert (!dom_info_available_p (fn, CDI_POST_DOMINATORS));\n-\t      clear_edges (fn);\n-\t      fn->cfg = NULL;\n-\t    }\n-\t  if (fn->value_histograms)\n-\t    free_histograms (fn);\n+\t  fn->curr_properties &= ~PROP_loops;\n+\t  loop_optimizer_finalize (fn);\n+\t}\n+      if (fn->gimple_df)\n+\t{\n+\t  delete_tree_ssa (fn);\n+\t  fn->eh = NULL;\n+\t}\n+      if (fn->cfg)\n+\t{\n+\t  gcc_assert (!dom_info_available_p (fn, CDI_DOMINATORS));\n+\t  gcc_assert (!dom_info_available_p (fn, CDI_POST_DOMINATORS));\n+\t  delete_tree_cfg_annotations (fn);\n+\t  clear_edges (fn);\n+\t  fn->cfg = NULL;\n \t}\n+      if (fn->value_histograms)\n+\tfree_histograms (fn);\n       gimple_set_body (decl, NULL);\n       /* Struct function hangs a lot of data that would leak if we didn't\n          removed all pointers to it.   */"}, {"sha": "57618807c490433d09ccea3f49982afc076f3150", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -1428,10 +1428,10 @@ init_lowered_empty_function (tree decl, bool in_ssa, gcov_type count)\n   allocate_struct_function (decl, false);\n   gimple_register_cfg_hooks ();\n   init_empty_tree_cfg ();\n+  init_tree_ssa (cfun);\n \n   if (in_ssa)\n     {\n-      init_tree_ssa (cfun);\n       init_ssa_operands (cfun);\n       cfun->gimple_df->in_ssa_p = true;\n       cfun->curr_properties |= PROP_ssa;"}, {"sha": "d3968e98620c121c42d32f06548ba73ac622214d", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -542,7 +542,7 @@ gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n     }\n   else\n     {\n-      tree tmp = get_initialized_tmp_var (expr, &stmts, NULL);\n+      tree tmp = force_gimple_operand (expr, &stmts, false, NULL_TREE);\n       new_stmt = gimple_build_assign (lhs, tmp);\n       i = gsi_last (stmts);\n       gsi_insert_after_without_update (&i, new_stmt,"}, {"sha": "9ea17af6637508a028e830d97a3c5ec2436bb9dd", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -740,7 +740,9 @@ lower_builtin_setjmp (gimple_stmt_iterator *gsi)\n      passed to both __builtin_setjmp_setup and __builtin_setjmp_receiver.  */\n   FORCED_LABEL (next_label) = 1;\n \n-  dest = gimple_call_lhs (stmt);\n+  tree orig_dest = dest = gimple_call_lhs (stmt);\n+  if (orig_dest && TREE_CODE (orig_dest) == SSA_NAME)\n+    dest = create_tmp_reg (TREE_TYPE (orig_dest));\n \n   /* Build '__builtin_setjmp_setup (BUF, NEXT_LABEL)' and insert.  */\n   arg = build_addr (next_label);\n@@ -789,6 +791,13 @@ lower_builtin_setjmp (gimple_stmt_iterator *gsi)\n   g = gimple_build_label (cont_label);\n   gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \n+  /* Build orig_dest = dest if necessary.  */\n+  if (dest != orig_dest)\n+    {\n+      g = gimple_build_assign (orig_dest, dest);\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+    }\n+\n   /* Remove the call to __builtin_setjmp.  */\n   gsi_remove (gsi, false);\n }"}, {"sha": "9fe9bd5ed89838eba0177f6f0742af3a73d7921f", "filename": "gcc/gimplify.c", "status": "modified", "additions": 95, "deletions": 30, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -185,6 +185,8 @@ static struct gimplify_omp_ctx *gimplify_omp_ctxp;\n /* Forward declaration.  */\n static enum gimplify_status gimplify_compound_expr (tree *, gimple_seq *, bool);\n static hash_map<tree, tree> *oacc_declare_returns;\n+static enum gimplify_status gimplify_expr (tree *, gimple_seq *, gimple_seq *,\n+\t\t\t\t\t   bool (*) (tree), fallback_t, bool);\n \n /* Shorter alias name for the above function for use in gimplify.c\n    only.  */\n@@ -547,7 +549,7 @@ lookup_tmp_var (tree val, bool is_formal)\n \n static tree\n internal_get_tmp_var (tree val, gimple_seq *pre_p, gimple_seq *post_p,\n-                      bool is_formal)\n+                      bool is_formal, bool allow_ssa)\n {\n   tree t, mod;\n \n@@ -556,9 +558,18 @@ internal_get_tmp_var (tree val, gimple_seq *pre_p, gimple_seq *post_p,\n   gimplify_expr (&val, pre_p, post_p, is_gimple_reg_rhs_or_call,\n \t\t fb_rvalue);\n \n-  if (gimplify_ctxp->into_ssa\n+  if (allow_ssa\n+      && gimplify_ctxp->into_ssa\n       && is_gimple_reg_type (TREE_TYPE (val)))\n-    t = make_ssa_name (TYPE_MAIN_VARIANT (TREE_TYPE (val)));\n+    {\n+      t = make_ssa_name (TYPE_MAIN_VARIANT (TREE_TYPE (val)));\n+      if (! gimple_in_ssa_p (cfun))\n+\t{\n+\t  const char *name = get_name (val);\n+\t  if (name)\n+\t    SET_SSA_NAME_VAR_OR_IDENTIFIER (t, create_tmp_var_name (name));\n+\t}\n+    }\n   else\n     t = lookup_tmp_var (val, is_formal);\n \n@@ -588,16 +599,17 @@ internal_get_tmp_var (tree val, gimple_seq *pre_p, gimple_seq *post_p,\n tree\n get_formal_tmp_var (tree val, gimple_seq *pre_p)\n {\n-  return internal_get_tmp_var (val, pre_p, NULL, true);\n+  return internal_get_tmp_var (val, pre_p, NULL, true, true);\n }\n \n /* Return a temporary variable initialized with VAL.  PRE_P and POST_P\n    are as in gimplify_expr.  */\n \n tree\n-get_initialized_tmp_var (tree val, gimple_seq *pre_p, gimple_seq *post_p)\n+get_initialized_tmp_var (tree val, gimple_seq *pre_p, gimple_seq *post_p,\n+\t\t\t bool allow_ssa)\n {\n-  return internal_get_tmp_var (val, pre_p, post_p, false);\n+  return internal_get_tmp_var (val, pre_p, post_p, false, allow_ssa);\n }\n \n /* Declare all the variables in VARS in SCOPE.  If DEBUG_INFO is true,\n@@ -2279,10 +2291,12 @@ maybe_with_size_expr (tree *expr_p)\n \n /* Helper for gimplify_call_expr.  Gimplify a single argument *ARG_P\n    Store any side-effects in PRE_P.  CALL_LOCATION is the location of\n-   the CALL_EXPR.  */\n+   the CALL_EXPR.  If ALLOW_SSA is set the actual parameter may be\n+   gimplified to an SSA name.  */\n \n enum gimplify_status\n-gimplify_arg (tree *arg_p, gimple_seq *pre_p, location_t call_location)\n+gimplify_arg (tree *arg_p, gimple_seq *pre_p, location_t call_location,\n+\t      bool allow_ssa)\n {\n   bool (*test) (tree);\n   fallback_t fb;\n@@ -2319,7 +2333,7 @@ gimplify_arg (tree *arg_p, gimple_seq *pre_p, location_t call_location)\n      the argument list must occur before the actual call. So, when\n      gimplifying arguments, force gimplify_expr to use an internal\n      post queue which is then appended to the end of PRE_P.  */\n-  return gimplify_expr (arg_p, pre_p, NULL, test, fb);\n+  return gimplify_expr (arg_p, pre_p, NULL, test, fb, allow_ssa);\n }\n \n /* Don't fold inside offloading or taskreg regions: it can break code by\n@@ -2522,6 +2536,12 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n \t}\n     }\n \n+  /* If the call returns twice then after building the CFG the call\n+     argument computations will no longer dominate the call because\n+     we add an abnormal incoming edge to the call.  So do not use SSA\n+     vars there.  */\n+  bool returns_twice = call_expr_flags (*expr_p) & ECF_RETURNS_TWICE;\n+\n   /* Gimplify the function arguments.  */\n   if (nargs > 0)\n     {\n@@ -2536,7 +2556,7 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n           if ((i != 1) || !builtin_va_start_p)\n             {\n               t = gimplify_arg (&CALL_EXPR_ARG (*expr_p, i), pre_p,\n-\t\t\t\tEXPR_LOCATION (*expr_p));\n+\t\t\t\tEXPR_LOCATION (*expr_p), ! returns_twice);\n \n               if (t == GS_ERROR)\n                 ret = GS_ERROR;\n@@ -2553,7 +2573,7 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n \t{\n \t  enum gimplify_status t;\n \t  t = gimplify_arg (&CALL_EXPR_STATIC_CHAIN (*expr_p), pre_p,\n-\t\t\t    EXPR_LOCATION (*expr_p));\n+\t\t\t    EXPR_LOCATION (*expr_p), ! returns_twice);\n \t  if (t == GS_ERROR)\n \t    ret = GS_ERROR;\n \t}\n@@ -3316,7 +3336,8 @@ prepare_gimple_addressable (tree *expr_p, gimple_seq *seq_p)\n     expr_p = &TREE_OPERAND (*expr_p, 0);\n   if (is_gimple_reg (*expr_p))\n     {\n-      tree var = get_initialized_tmp_var (*expr_p, seq_p, NULL);\n+      /* Do not allow an SSA name as the temporary.  */\n+      tree var = get_initialized_tmp_var (*expr_p, seq_p, NULL, false);\n       DECL_GIMPLE_REG_P (var) = 0;\n       *expr_p = var;\n     }\n@@ -4848,6 +4869,11 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  || TREE_ADDRESSABLE (TREE_TYPE (*to_p))\n \t  || TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (*to_p))) != INTEGER_CST)\n \tgimple_call_set_lhs (call_stmt, *to_p);\n+      else if (TREE_CODE (*to_p) == SSA_NAME)\n+\t/* The above is somewhat premature, avoid ICEing later for a\n+\t   SSA name w/o a definition.  We may have uses in the GIMPLE IL.\n+\t   ???  This doesn't make it a default-def.  */\n+\tSSA_NAME_DEF_STMT (*to_p) = gimple_build_nop ();\n       assign = call_stmt;\n     }\n   else\n@@ -4861,7 +4887,8 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n   if (gimplify_ctxp->into_ssa && is_gimple_reg (*to_p))\n     {\n       /* We should have got an SSA name from the start.  */\n-      gcc_assert (TREE_CODE (*to_p) == SSA_NAME);\n+      gcc_assert (TREE_CODE (*to_p) == SSA_NAME\n+\t\t  || ! gimple_in_ssa_p (cfun));\n     }\n \n   gimplify_seq_add_stmt (pre_p, assign);\n@@ -4994,7 +5021,9 @@ gimplify_save_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t  val = NULL;\n \t}\n       else\n-\tval = get_initialized_tmp_var (val, pre_p, post_p);\n+\t/* The temporary may not be an SSA name as later abnormal and EH\n+\t   control flow may invalidate use/def domination.  */\n+\tval = get_initialized_tmp_var (val, pre_p, post_p, false);\n \n       TREE_OPERAND (*expr_p, 0) = val;\n       SAVE_EXPR_RESOLVED_P (*expr_p) = 1;\n@@ -6653,7 +6682,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t    {\n \t      tree type = TREE_TYPE (decl);\n \t      if (gimplify_expr (&TYPE_MAX_VALUE (TYPE_DOMAIN (type)), pre_p,\n-\t\t\t\t NULL, is_gimple_val, fb_rvalue) == GS_ERROR)\n+\t\t\t\t NULL, is_gimple_val, fb_rvalue, false)\n+\t\t  == GS_ERROR)\n \t\t{\n \t\t  remove = true;\n \t\t  break;\n@@ -6668,7 +6698,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t      if (TREE_CODE (decl) == POINTER_PLUS_EXPR)\n \t\t{\n \t\t  if (gimplify_expr (&TREE_OPERAND (decl, 1), pre_p,\n-\t\t\t\t     NULL, is_gimple_val, fb_rvalue)\n+\t\t\t\t     NULL, is_gimple_val, fb_rvalue, false)\n \t\t      == GS_ERROR)\n \t\t    {\n \t\t      remove = true;\n@@ -6865,7 +6895,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t   && TREE_CODE (OMP_CLAUSE_SIZE (c)) != INTEGER_CST)\n \t    {\n \t      OMP_CLAUSE_SIZE (c)\n-\t\t= get_initialized_tmp_var (OMP_CLAUSE_SIZE (c), pre_p, NULL);\n+\t\t= get_initialized_tmp_var (OMP_CLAUSE_SIZE (c), pre_p, NULL,\n+\t\t\t\t\t   false);\n \t      omp_add_variable (ctx, OMP_CLAUSE_SIZE (c),\n \t\t\t\tGOVD_FIRSTPRIVATE | GOVD_SEEN);\n \t    }\n@@ -8609,7 +8640,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t    {\n \t      TREE_OPERAND (t, 1)\n \t\t= get_initialized_tmp_var (TREE_OPERAND (t, 1),\n-\t\t\t\t\t   pre_p, NULL);\n+\t\t\t\t\t   pre_p, NULL, false);\n \t      tree c = build_omp_clause (input_location,\n \t\t\t\t\t OMP_CLAUSE_FIRSTPRIVATE);\n \t      OMP_CLAUSE_DECL (c) = TREE_OPERAND (t, 1);\n@@ -8624,7 +8655,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t      TREE_OPERAND (t, 1)\n \t\t= get_initialized_tmp_var (TREE_OPERAND (t, 1),\n \t\t\t\t\t   gimple_seq_empty_p (for_pre_body)\n-\t\t\t\t\t   ? pre_p : &for_pre_body, NULL);\n+\t\t\t\t\t   ? pre_p : &for_pre_body, NULL,\n+\t\t\t\t\t   false);\n \t      tree c = build_omp_clause (input_location,\n \t\t\t\t\t OMP_CLAUSE_FIRSTPRIVATE);\n \t      OMP_CLAUSE_DECL (c) = TREE_OPERAND (t, 1);\n@@ -8646,7 +8678,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t{\n \t\t  gimple_seq *seq = gimple_seq_empty_p (for_pre_body)\n \t\t\t\t    ? pre_p : &for_pre_body;\n-\t\t  *tp = get_initialized_tmp_var (*tp, seq, NULL);\n+\t\t  *tp = get_initialized_tmp_var (*tp, seq, NULL, false);\n \t\t  tree c = build_omp_clause (input_location,\n \t\t\t\t\t     OMP_CLAUSE_FIRSTPRIVATE);\n \t\t  OMP_CLAUSE_DECL (c) = *tp;\n@@ -8982,7 +9014,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \tvar = decl;\n \n       tret = gimplify_expr (&TREE_OPERAND (t, 1), &for_pre_body, NULL,\n-\t\t\t    is_gimple_val, fb_rvalue);\n+\t\t\t    is_gimple_val, fb_rvalue, false);\n       ret = MIN (ret, tret);\n       if (ret == GS_ERROR)\n \treturn ret;\n@@ -8993,7 +9025,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n       gcc_assert (TREE_OPERAND (t, 0) == decl);\n \n       tret = gimplify_expr (&TREE_OPERAND (t, 1), &for_pre_body, NULL,\n-\t\t\t    is_gimple_val, fb_rvalue);\n+\t\t\t    is_gimple_val, fb_rvalue, false);\n       ret = MIN (ret, tret);\n \n       /* Handle OMP_FOR_INCR.  */\n@@ -9060,7 +9092,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t    }\n \n \t  tret = gimplify_expr (&TREE_OPERAND (t, 1), &for_pre_body, NULL,\n-\t\t\t\tis_gimple_val, fb_rvalue);\n+\t\t\t\tis_gimple_val, fb_rvalue, false);\n \t  ret = MIN (ret, tret);\n \t  if (c)\n \t    {\n@@ -9076,7 +9108,7 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\t{\n \t\t  tret = gimplify_expr (&OMP_CLAUSE_LINEAR_STEP (c),\n \t\t\t\t\t&for_pre_body, NULL,\n-\t\t\t\t\tis_gimple_val, fb_rvalue);\n+\t\t\t\t\tis_gimple_val, fb_rvalue, false);\n \t\t  ret = MIN (ret, tret);\n \t\t}\n \t    }\n@@ -9530,7 +9562,7 @@ optimize_target_teams (tree target, gimple_seq *pre_p)\n \t  }\n \t*p = expr;\n \tgimplify_omp_ctxp = gimplify_omp_ctxp->outer_context;\n-\tif (gimplify_expr (p, pre_p, NULL, is_gimple_val, fb_rvalue)\n+\tif (gimplify_expr (p, pre_p, NULL, is_gimple_val, fb_rvalue, false)\n \t    == GS_ERROR)\n \t  {\n \t    gimplify_omp_ctxp = target_ctx;\n@@ -10248,7 +10280,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t     required.  */\n \t  if (fallback == fb_lvalue)\n \t    {\n-\t      *expr_p = get_initialized_tmp_var (*expr_p, pre_p, post_p);\n+\t      *expr_p = get_initialized_tmp_var (*expr_p, pre_p, post_p, false);\n \t      mark_addressable (*expr_p);\n \t      ret = GS_OK;\n \t    }\n@@ -10263,7 +10295,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t     required.  */\n \t  if (fallback == fb_lvalue)\n \t    {\n-\t      *expr_p = get_initialized_tmp_var (*expr_p, pre_p, post_p);\n+\t      *expr_p = get_initialized_tmp_var (*expr_p, pre_p, post_p, false);\n \t      mark_addressable (*expr_p);\n \t      ret = GS_OK;\n \t    }\n@@ -10558,7 +10590,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t     required.  */\n \t  else if (fallback == fb_lvalue)\n \t    {\n-\t      *expr_p = get_initialized_tmp_var (*expr_p, pre_p, post_p);\n+\t      *expr_p = get_initialized_tmp_var (*expr_p, pre_p, post_p, false);\n \t      mark_addressable (*expr_p);\n \t      ret = GS_OK;\n \t    }\n@@ -11256,6 +11288,35 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n   return ret;\n }\n \n+/* Like gimplify_expr but make sure the gimplified result is not itself\n+   a SSA name (but a decl if it were).  Temporaries required by\n+   evaluating *EXPR_P may be still SSA names.  */\n+\n+static enum gimplify_status\n+gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n+\t       bool (*gimple_test_f) (tree), fallback_t fallback,\n+\t       bool allow_ssa)\n+{\n+  bool was_ssa_name_p = TREE_CODE (*expr_p) == SSA_NAME;\n+  enum gimplify_status ret = gimplify_expr (expr_p, pre_p, post_p,\n+\t\t\t\t\t    gimple_test_f, fallback);\n+  if (! allow_ssa\n+      && TREE_CODE (*expr_p) == SSA_NAME)\n+    {\n+      tree name = *expr_p;\n+      if (was_ssa_name_p)\n+\t*expr_p = get_initialized_tmp_var (*expr_p, pre_p, NULL, false);\n+      else\n+\t{\n+\t  /* Avoid the extra copy if possible.  */\n+\t  *expr_p = create_tmp_reg (TREE_TYPE (name));\n+\t  gimple_set_lhs (SSA_NAME_DEF_STMT (name), *expr_p);\n+\t  release_ssa_name (name);\n+\t}\n+    }\n+  return ret;\n+}\n+\n /* Look through TYPE for variable-sized objects and gimplify each such\n    size that we find.  Add to LIST_P any statements generated.  */\n \n@@ -11378,7 +11439,9 @@ gimplify_one_sizepos (tree *expr_p, gimple_seq *stmt_p)\n \n   *expr_p = unshare_expr (expr);\n \n-  gimplify_expr (expr_p, stmt_p, NULL, is_gimple_val, fb_rvalue);\n+  /* SSA names in decl/type fields are a bad idea - they'll get reclaimed\n+     if the def vanishes.  */\n+  gimplify_expr (expr_p, stmt_p, NULL, is_gimple_val, fb_rvalue, false);\n }\n \n /* Gimplify the body of statements of FNDECL and return a GIMPLE_BIND node\n@@ -11396,12 +11459,14 @@ gimplify_body (tree fndecl, bool do_parms)\n \n   timevar_push (TV_TREE_GIMPLIFY);\n \n+  init_tree_ssa (cfun);\n+\n   /* Initialize for optimize_insn_for_s{ize,peed}_p possibly called during\n      gimplification.  */\n   default_rtl_profile ();\n \n   gcc_assert (gimplify_ctxp == NULL);\n-  push_gimplify_context ();\n+  push_gimplify_context (true);\n \n   if (flag_openacc || flag_openmp)\n     {"}, {"sha": "27823e6bb993a8b0b8c22002b4f95b8f8080210f", "filename": "gcc/gimplify.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fgimplify.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fgimplify.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.h?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -57,7 +57,8 @@ extern gbind *gimple_current_bind_expr (void);\n extern vec<gbind *> gimple_bind_expr_stack (void);\n extern void gimplify_and_add (tree, gimple_seq *);\n extern tree get_formal_tmp_var (tree, gimple_seq *);\n-extern tree get_initialized_tmp_var (tree, gimple_seq *, gimple_seq *);\n+extern tree get_initialized_tmp_var (tree, gimple_seq *, gimple_seq *,\n+\t\t\t\t     bool = true);\n extern void declare_vars (tree, gimple *, bool);\n extern void gimple_add_tmp_var (tree);\n extern void gimple_add_tmp_var_fn (struct function *, tree);\n@@ -77,7 +78,8 @@ extern enum gimplify_status gimplify_expr (tree *, gimple_seq *, gimple_seq *,\n extern void gimplify_type_sizes (tree, gimple_seq *);\n extern void gimplify_one_sizepos (tree *, gimple_seq *);\n extern gbind *gimplify_body (tree, bool);\n-extern enum gimplify_status gimplify_arg (tree *, gimple_seq *, location_t);\n+extern enum gimplify_status gimplify_arg (tree *, gimple_seq *, location_t,\n+\t\t\t\t\t  bool = true);\n extern void gimplify_function_tree (tree);\n extern enum gimplify_status gimplify_va_arg_expr (tree *, gimple_seq *,\n \t\t\t\t\t\t  gimple_seq *);"}, {"sha": "c9600fb6d33424f46e78fe221fc041745c4efb09", "filename": "gcc/omp-low.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -2570,6 +2570,7 @@ create_omp_child_function (omp_context *ctx, bool task_copy)\n      it afterward.  */\n   push_struct_function (decl);\n   cfun->function_end_locus = gimple_location (ctx->stmt);\n+  init_tree_ssa (cfun);\n   pop_cfun ();\n }\n \n@@ -13672,6 +13673,7 @@ grid_expand_target_grid_body (struct omp_region *target)\n   DECL_INITIAL (kern_fndecl) = fniniblock;\n   push_struct_function (kern_fndecl);\n   cfun->function_end_locus = gimple_location (tgt_stmt);\n+  init_tree_ssa (cfun);\n   pop_cfun ();\n \n   tree old_parm_decl = DECL_ARGUMENTS (kern_fndecl);"}, {"sha": "0e55829fe62327e7335b01cd50f30fcd6d71b108", "filename": "gcc/passes.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -54,7 +54,6 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_build_ssa_passes);\n   PUSH_INSERT_PASSES_WITHIN (pass_build_ssa_passes)\n       NEXT_PASS (pass_fixup_cfg);\n-      NEXT_PASS (pass_init_datastructures);\n       NEXT_PASS (pass_build_ssa);\n       NEXT_PASS (pass_warn_nonnull_compare);\n       NEXT_PASS (pass_ubsan);"}, {"sha": "2ccbfa6d366a12f24a83358d660d0671bfa2fab1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -1,3 +1,14 @@\n+2016-05-03  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/pr30172-1.c: Adjust.\n+\t* gcc.dg/pr63743.c: Likewise.\n+\t* gcc.dg/tm/pr51696.c: Likewise.\n+\t* c-c++-common/tm/safe-1.c: Likewise.\n+\t* gcc.dg/tree-prof/val-prof-3.c: Likewise.\n+\t* gcc.dg/plugin/self-assign-test-1.c: XFAIL case that needs CSE.\n+\t* g++.dg/plugin/self-assign-test-1.C: Likewise.\n+\t* g++.dg/plugin/self-assign-test-2.C: Likewise.\n+\n 2016-05-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/70467"}, {"sha": "4a81a78c396b1fc190d1268f6fb060a7bd66b1eb", "filename": "gcc/testsuite/c-c++-common/tm/safe-1.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fsafe-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fsafe-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fsafe-1.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -35,9 +35,9 @@ foo(void)\n   /* tu(); */\n \n   (*ps)();\n-  (*pc)();\t\t/* { dg-error \"unsafe function call\" } */\n-  (*pi)();\t\t/* { dg-error \"unsafe function call\" } */\n-  (*pu)();\t\t/* { dg-error \"unsafe function call\" } */\n+  (*pc)();\t\t/* { dg-error \"unsafe indirect function call\" } */\n+  (*pi)();\t\t/* { dg-error \"unsafe indirect function call\" } */\n+  (*pu)();\t\t/* { dg-error \"unsafe indirect function call\" } */\n \n   asm(\"\");\t\t/* { dg-error \"asm not allowed\" } */\n   asm(\"\" : \"=g\"(i));\t/* { dg-error \"asm not allowed\" } */\n@@ -57,10 +57,10 @@ bar(void)\n   tm();\n \n   (*ps)();\n-  (*pc)();\t\t/* { dg-error \"unsafe function call\" } */\n-  (*pi)();\t\t/* { dg-error \"unsafe function call\" } */\n+  (*pc)();\t\t/* { dg-error \"unsafe indirect function call\" } */\n+  (*pi)();\t\t/* { dg-error \"unsafe indirect function call\" } */\n   (*pm)();\n-  (*pu)();\t\t/* { dg-error \"unsafe function call\" } */\n+  (*pu)();\t\t/* { dg-error \"unsafe indirect function call\" } */\n \n   asm(\"\");\t\t/* { dg-error \"asm not allowed\" } */\n   asm(\"\" : \"=g\"(i));\t/* { dg-error \"asm not allowed\" } */"}, {"sha": "95d39dd0ce666d2a529adc1427165de3ab1c6bae", "filename": "gcc/testsuite/g++.dg/plugin/self-assign-test-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fself-assign-test-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fself-assign-test-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fself-assign-test-1.C?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -44,7 +44,7 @@ int func()\n   foo = foo; // { dg-warning \"assigned to itself\" }\n   foo.setA(5);\n   bar_array[3].c_ = bar_array[3].c_; // { dg-warning \"assigned to itself\" }\n-  bar_array[x+g].b_ = bar_array[x+g].b_; // { dg-warning \"self-assignment detected\" }\n+  bar_array[x+g].b_ = bar_array[x+g].b_; // { dg-warning \"self-assignment detected\" \"\" { xfail *-*-* } }\n   y = x;\n   x = y;\n }"}, {"sha": "da963c42db26f66719b89fe48f4e5c1957250752", "filename": "gcc/testsuite/g++.dg/plugin/self-assign-test-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fself-assign-test-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fself-assign-test-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fself-assign-test-2.C?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -44,7 +44,7 @@ int func()\n   foo = foo; // { dg-bogus \"assigned to itself\" }\n   foo.setA(5);\n   bar_array[3].c_ = bar_array[3].c_; // { dg-warning \"assigned to itself\" }\n-  bar_array[x+g].b_ = bar_array[x+g].b_; // { dg-warning \"self-assignment detected\" }\n+  bar_array[x+g].b_ = bar_array[x+g].b_; // { dg-warning \"self-assignment detected\" \"\" { xfail *-*-* } }\n   y = x;\n   x = y;\n }"}, {"sha": "0fa050eb2928738b1a356b5901b347f82822563d", "filename": "gcc/testsuite/gcc.dg/fold-perm.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-perm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-perm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-perm.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O -fdump-tree-ccp1\" } */\n+/* { dg-options \"-O -fdump-tree-fre1\" } */\n \n typedef int veci __attribute__ ((vector_size (4 * sizeof (int))));\n \n@@ -14,6 +14,6 @@ void fun (veci *f, veci *g, veci *h, veci *i)\n   *f = __builtin_shuffle (*f, *g, n);\n }\n \n-/* { dg-final { scan-tree-dump \"VEC_PERM_EXPR.*{ 3, 3, 0, 2 }\" \"ccp1\" } } */\n-/* { dg-final { scan-tree-dump \"VEC_PERM_EXPR.*{ 1, 1, 3, 2 }\" \"ccp1\" } } */\n-/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 2 \"ccp1\" } } */\n+/* { dg-final { scan-tree-dump \"VEC_PERM_EXPR.*{ 3, 3, 0, 2 }\" \"fre1\" } } */\n+/* { dg-final { scan-tree-dump \"VEC_PERM_EXPR.*{ 1, 1, 3, 2 }\" \"fre1\" } } */\n+/* { dg-final { scan-tree-dump-times \"VEC_PERM_EXPR\" 2 \"fre1\" } } */"}, {"sha": "28c14dd762a692191de2bd82e1a393668b55dc4d", "filename": "gcc/testsuite/gcc.dg/plugin/self-assign-test-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fself-assign-test-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fself-assign-test-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fself-assign-test-1.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -16,7 +16,7 @@ int main()\n   static int y;\n   struct Bar b_array[5];\n \n-  b_array[x+g].b_ = b_array[x+g].b_; /* { dg-warning \"self-assignment detected\" } */\n+  b_array[x+g].b_ = b_array[x+g].b_; /* { dg-warning \"self-assignment detected\" \"\" { xfail *-*-* } } */\n   g = g; /* { dg-warning \"assigned to itself\" } */\n   y = y; /* { dg-warning \"assigned to itself\" } */\n   bar->b_ = bar->b_; /* { dg-warning \"assigned to itself\" } */"}, {"sha": "ee6efdeebb8aeeb641481ce2a90672ed1026b40e", "filename": "gcc/testsuite/gcc.dg/pr30172-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30172-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30172-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr30172-1.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -10,5 +10,5 @@ _Complex double test5 (double x, double y) { return (x + y * 1.i) * -1.i; }\n /* { dg-final { scan-tree-dump \"COMPLEX_EXPR <x, 1.0e\\\\+0>\" \"gimple\" } } */\n /* { dg-final { scan-tree-dump \"COMPLEX_EXPR <1.0e\\\\+0, x>\" \"gimple\" } } */\n /* { dg-final { scan-tree-dump \"COMPLEX_EXPR <x, y>\" \"gimple\" } } */\n-/* { dg-final { scan-tree-dump \"D.* = -y;\\n.*COMPLEX_EXPR <D.*, x>\" \"gimple\" } } */\n-/* { dg-final { scan-tree-dump \"D.* = -x;\\n.*COMPLEX_EXPR <y, D.*>\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \" = -y;\\n.*COMPLEX_EXPR <\\[^,\\]*, x>\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \" = -x;\\n.*COMPLEX_EXPR <y, \" \"gimple\" } } */"}, {"sha": "ba492b9fe8132b2ea6e1506fd5fc968afa73d987", "filename": "gcc/testsuite/gcc.dg/pr63743.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr63743.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr63743.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr63743.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -4,7 +4,8 @@\n double\n libcall_dep (double x, double y)\n {\n-  return x * (x + y);\n+  double tem = x + y;\n+  return x * tem;\n }\n \n /* { dg-final { scan-rtl-dump-times \"Swap operands\" 1 \"expand\" } } */"}, {"sha": "e39c6ca140bf0c4fdc17d21e70cc32e32d0f5016", "filename": "gcc/testsuite/gcc.dg/tm/pr51696.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr51696.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr51696.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr51696.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -10,5 +10,5 @@ static void (*compare)();\n __attribute__((transaction_safe))\n static void func () {\n   listPtr->compare(); /* { dg-error \"unsafe indirect function call\" } */\n-  compare(); /* { dg-error \"unsafe function call\" } */\n+  compare(); /* { dg-error \"unsafe indirect function call\" } */\n }"}, {"sha": "9a600c334eef04a8b1f7877e88b16635fd2d8bf4", "filename": "gcc/testsuite/gcc.dg/tree-prof/val-prof-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fval-prof-3.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -27,5 +27,5 @@ main ()\n /* { dg-final-use { scan-ipa-dump \"Mod subtract transformation on insn\" \"profile\" } } */\n /* This is part of code checking that n is greater than the divisor so we are sure that it\n    didn't get optimized out.  */\n-/* { dg-final-use { scan-tree-dump \"if \\\\(n_\\[0-9\\]* \\\\>\" \"optimized\"} } */\n+/* { dg-final-use { scan-tree-dump \"if \\\\(_\\[0-9\\]* \\\\< n_\\[0-9\\]*\" \"optimized\"} } */\n /* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */"}, {"sha": "1dabd39e569d5fc5b7666cfcefe45115282f90e5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/forwprop-28.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-28.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -84,5 +84,5 @@ test_8 (int code)\n    the negated code == 22 compare to code != 22 first.  It turns out if\n    we do that we even generate better code on x86 at least.  */\n \n-/* { dg-final { scan-tree-dump-times \"simplified to if \\\\\\(\\[^ ]* <\" 4 \"forwprop1\"} } */\n+/* { dg-final { scan-tree-dump-times \"simplified to if \\\\\\(\\[^ ]* \\[<>\\]\" 4 \"forwprop1\"} } */\n "}, {"sha": "89cddcd7486e3450085ae50734cc71f5d0c5670d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-43.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-43.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -1,6 +1,6 @@\n /* PR tree-optimization/64193 */\n /* { dg-do compile } */\n-/* { dg-options \"-O -fdump-tree-fre1-details\" } */\n+/* { dg-options \"-O -fdump-tree-fre1\" } */\n \n double T,T2,E1[5];\n int J;\n@@ -24,5 +24,4 @@ PA(double E[])\n /* We should remove 15 dead loads and some related stmts, fully propagating\n    their replacements with exactly 4 loads and 4 stores from/to E remaining.  */\n \n-/* { dg-final { scan-tree-dump-times \"Removing dead stmt\" 19 \"fre1\" } } */\n-/* { dg-final { scan-tree-dump-not \"Not changing value number\" \"fre1\" } } */\n+/* { dg-final { scan-tree-dump-times \"MEM\" 8 \"fre1\" } } */"}, {"sha": "2a6e101e9f2a52218702e149e95ffb75cb3af76c", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -726,7 +726,8 @@ diagnose_tm_1 (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t\t\t\t\"atomic transaction\", fn);\n \t\t    else\n \t\t      {\n-\t\t\tif (!DECL_P (fn) || DECL_NAME (fn))\n+\t\t\tif ((!DECL_P (fn) || DECL_NAME (fn))\n+\t\t\t    && TREE_CODE (fn) != SSA_NAME)\n \t\t\t  error_at (gimple_location (stmt),\n \t\t\t\t    \"unsafe function call %qE within \"\n \t\t\t\t    \"atomic transaction\", fn);\n@@ -744,7 +745,8 @@ diagnose_tm_1 (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t\t\t\t\"%<transaction_safe%> function\", fn);\n \t\t    else\n \t\t      {\n-\t\t\tif (!DECL_P (fn) || DECL_NAME (fn))\n+\t\t\tif ((!DECL_P (fn) || DECL_NAME (fn))\n+\t\t\t    && TREE_CODE (fn) != SSA_NAME)\n \t\t\t  error_at (gimple_location (stmt),\n \t\t\t\t    \"unsafe function call %qE within \"\n \t\t\t\t    \"%<transaction_safe%> function\", fn);"}, {"sha": "657370288432ea399aba2110cab7520d4f9d210d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -2135,13 +2135,8 @@ remove_bb (basic_block bb)\n \t    }\n \t  else\n \t    {\n-\t      /* Release SSA definitions if we are in SSA.  Note that we\n-\t\t may be called when not in SSA.  For example,\n-\t\t final_cleanup calls this function via\n-\t\t cleanup_tree_cfg.  */\n-\t      if (gimple_in_ssa_p (cfun))\n-\t\trelease_defs (stmt);\n-\n+\t      /* Release SSA definitions.  */\n+\t      release_defs (stmt);\n \t      gsi_remove (&i, true);\n \t    }\n "}, {"sha": "19f202e53714f6a023a448161c5424f36de71cb3", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -2456,8 +2456,9 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count)\n   if (src_cfun->gimple_df)\n     {\n       init_tree_ssa (cfun);\n-      cfun->gimple_df->in_ssa_p = true;\n-      init_ssa_operands (cfun);\n+      cfun->gimple_df->in_ssa_p = src_cfun->gimple_df->in_ssa_p;\n+      if (cfun->gimple_df->in_ssa_p)\n+\tinit_ssa_operands (cfun);\n     }\n }\n \n@@ -5119,10 +5120,21 @@ replace_locals_op (tree *tp, int *walk_subtrees, void *data)\n   tree *n;\n   tree expr = *tp;\n \n+  /* For recursive invocations this is no longer the LHS itself.  */\n+  bool is_lhs = wi->is_lhs;\n+  wi->is_lhs = false;\n+\n+  if (TREE_CODE (expr) == SSA_NAME)\n+    {\n+      *tp = remap_ssa_name (*tp, id);\n+      *walk_subtrees = 0;\n+      if (is_lhs)\n+\tSSA_NAME_DEF_STMT (*tp) = gsi_stmt (wi->gsi);\n+    }\n   /* Only a local declaration (variable or label).  */\n-  if ((TREE_CODE (expr) == VAR_DECL\n-       && !TREE_STATIC (expr))\n-      || TREE_CODE (expr) == LABEL_DECL)\n+  else if ((TREE_CODE (expr) == VAR_DECL\n+\t    && !TREE_STATIC (expr))\n+\t   || TREE_CODE (expr) == LABEL_DECL)\n     {\n       /* Lookup the declaration.  */\n       n = st->get (expr);\n@@ -5262,6 +5274,7 @@ copy_gimple_seq_and_replace_locals (gimple_seq seq)\n   memset (&id, 0, sizeof (id));\n   id.src_fn = current_function_decl;\n   id.dst_fn = current_function_decl;\n+  id.src_cfun = cfun;\n   id.decl_map = new hash_map<tree, tree>;\n   id.debug_map = NULL;\n "}, {"sha": "f83cad2e93610dfd49fce1db2e1965c4280b3704", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -666,6 +666,8 @@ mark_def_sites (basic_block bb, gimple *stmt, bitmap kills)\n   FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n     {\n       tree sym = USE_FROM_PTR (use_p);\n+      if (TREE_CODE (sym) == SSA_NAME)\n+\tcontinue;\n       gcc_checking_assert (DECL_P (sym));\n       if (!bitmap_bit_p (kills, DECL_UID (sym)))\n \tset_livein_block (sym, bb);\n@@ -676,6 +678,8 @@ mark_def_sites (basic_block bb, gimple *stmt, bitmap kills)\n      each def to the set of killed symbols.  */\n   FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n     {\n+      if (TREE_CODE (def) == SSA_NAME)\n+\tcontinue;\n       gcc_checking_assert (DECL_P (def));\n       set_def_block (def, bb, false);\n       bitmap_set_bit (kills, DECL_UID (def));\n@@ -1310,6 +1314,8 @@ rewrite_stmt (gimple_stmt_iterator *si)\n \tFOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)\n \t  {\n \t    tree var = USE_FROM_PTR (use_p);\n+\t    if (TREE_CODE (var) == SSA_NAME)\n+\t      continue;\n \t    gcc_checking_assert (DECL_P (var));\n \t    SET_USE (use_p, get_reaching_def (var));\n \t  }\n@@ -1323,6 +1329,8 @@ rewrite_stmt (gimple_stmt_iterator *si)\n \ttree name;\n \ttree tracked_var;\n \n+\tif (TREE_CODE (var) == SSA_NAME)\n+\t  continue;\n \tgcc_checking_assert (DECL_P (var));\n \n \tif (gimple_clobber_p (stmt)"}, {"sha": "66e103ae37e8d19fbd475ae6ec30dc63bc8d0c9c", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -506,7 +506,6 @@ extern ipa_opt_pass_d *make_pass_ipa_comdats (gcc::context *ctxt);\n \n extern gimple_opt_pass *make_pass_cleanup_cfg_post_optimizing (gcc::context\n \t\t\t\t\t\t\t       *ctxt);\n-extern gimple_opt_pass *make_pass_init_datastructures (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_fixup_cfg (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_backprop (gcc::context *ctxt);\n "}, {"sha": "ae120a8ff955d704e973bfec804be1d1caf1eee7", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -273,6 +273,7 @@ get_default_value (tree var)\n \t can assume initially that it is UNDEFINED, otherwise we must\n \t consider it VARYING.  */\n       if (!virtual_operand_p (var)\n+\t  && SSA_NAME_VAR (var)\n \t  && TREE_CODE (SSA_NAME_VAR (var)) == VAR_DECL)\n \tval.lattice_val = UNDEFINED;\n       else"}, {"sha": "0a59dd209ffe776321fee026f7f1cc68f7f52bcb", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -1051,62 +1051,6 @@ init_tree_ssa (struct function *fn)\n   init_ssanames (fn, 0);\n }\n \n-/* Do the actions required to initialize internal data structures used\n-   in tree-ssa optimization passes.  */\n-\n-static unsigned int\n-execute_init_datastructures (void)\n-{\n-  /* Allocate hash tables, arrays and other structures.  */\n-  gcc_assert (!cfun->gimple_df);\n-  init_tree_ssa (cfun);\n-  return 0;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_init_datastructures =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"*init_datastructures\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  TV_NONE, /* tv_id */\n-  PROP_cfg, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_init_datastructures : public gimple_opt_pass\n-{\n-public:\n-  pass_init_datastructures (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_init_datastructures, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *fun)\n-    {\n-      /* Do nothing for funcions that was produced already in SSA form.  */\n-      return !(fun->curr_properties & PROP_ssa);\n-    }\n-\n-  virtual unsigned int execute (function *)\n-    {\n-      return execute_init_datastructures ();\n-    }\n-\n-}; // class pass_init_datastructures\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_init_datastructures (gcc::context *ctxt)\n-{\n-  return new pass_init_datastructures (ctxt);\n-}\n-\n /* Deallocate memory associated with SSA data structures for FNDECL.  */\n \n void"}, {"sha": "91a8f97ebea3d673a3d8b4f0123f8e727287f73e", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/381cdae49785fc4b1941a6b37bad3e8c6f3f428d/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=381cdae49785fc4b1941a6b37bad3e8c6f3f428d", "patch": "@@ -740,10 +740,6 @@ release_defs (gimple *stmt)\n   tree def;\n   ssa_op_iter iter;\n \n-  /* Make sure that we are in SSA.  Otherwise, operand cache may point\n-     to garbage.  */\n-  gcc_assert (gimple_in_ssa_p (cfun));\n-\n   FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n     if (TREE_CODE (def) == SSA_NAME)\n       release_ssa_name (def);"}]}