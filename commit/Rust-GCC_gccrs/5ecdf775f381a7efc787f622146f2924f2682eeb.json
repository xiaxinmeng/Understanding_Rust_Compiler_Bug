{"sha": "5ecdf775f381a7efc787f622146f2924f2682eeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVjZGY3NzVmMzgxYTdlZmM3ODdmNjIyMTQ2ZjI5MjRmMjY4MmVlYg==", "commit": {"author": {"name": "Ben Chelf", "email": "chelf@gcc.gnu.org", "date": "2000-07-10T11:03:04Z"}, "committer": {"name": "Ben Chelf", "email": "chelf@gcc.gnu.org", "date": "2000-07-10T11:03:04Z"}, "message": "c-parse.y: Regenerate.\n\n2000-07-10  Benjamin Chelf  <chelf@codesourcery.com>\n\n\t* c-parse.y: Regenerate.\n\t* c-pasre.c: Likewise.\n\nFrom-SVN: r34944", "tree": {"sha": "564c670a78713280f5a3e6e3de3aa9f49f0b78ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/564c670a78713280f5a3e6e3de3aa9f49f0b78ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ecdf775f381a7efc787f622146f2924f2682eeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ecdf775f381a7efc787f622146f2924f2682eeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ecdf775f381a7efc787f622146f2924f2682eeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ecdf775f381a7efc787f622146f2924f2682eeb/comments", "author": null, "committer": null, "parents": [{"sha": "0dfdeca6e06b76d99dfb3150f36c4dd2a501058c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dfdeca6e06b76d99dfb3150f36c4dd2a501058c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dfdeca6e06b76d99dfb3150f36c4dd2a501058c"}], "stats": {"total": 332, "additions": 105, "deletions": 227}, "files": [{"sha": "20e202463b10e8326e31319712b7d76646856d95", "filename": "gcc/c-parse.c", "status": "modified", "additions": 81, "deletions": 142, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ecdf775f381a7efc787f622146f2924f2682eeb/gcc%2Fc-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ecdf775f381a7efc787f622146f2924f2682eeb/gcc%2Fc-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.c?ref=5ecdf775f381a7efc787f622146f2924f2682eeb", "patch": "@@ -415,12 +415,12 @@ static const short yyrline[] = { 0,\n   1506,  1524,  1529,  1534,  1537,  1551,  1560,  1564,  1568,  1572,\n   1578,  1582,  1587,  1590,  1595,  1598,  1599,  1615,  1620,  1623,\n   1635,  1637,  1647,  1657,  1658,  1665,  1667,  1679,  1683,  1697,\n-  1703,  1709,  1710,  1715,  1720,  1724,  1728,  1739,  1746,  1753,\n-  1760,  1771,  1777,  1780,  1785,  1808,  1838,  1869,  1900,  1915,\n-  1929,  1933,  1937,  1940,  1945,  1947,  1950,  1952,  1956,  1961,\n-  1964,  1970,  1975,  1980,  1982,  1991,  1992,  1998,  2000,  2010,\n-  2012,  2016,  2019,  2025,  2034,  2042,  2050,  2059,  2072,  2077,\n-  2082,  2084,  2093,  2096,  2101,  2104,  2108\n+  1703,  1709,  1710,  1714,  1718,  1722,  1726,  1737,  1744,  1751,\n+  1758,  1769,  1775,  1778,  1783,  1806,  1836,  1842,  1848,  1854,\n+  1868,  1872,  1876,  1879,  1884,  1886,  1889,  1891,  1895,  1900,\n+  1903,  1909,  1914,  1919,  1921,  1930,  1931,  1937,  1939,  1949,\n+  1951,  1955,  1958,  1964,  1973,  1981,  1989,  1998,  2011,  2016,\n+  2021,  2023,  2032,  2035,  2040,  2043,  2047\n };\n #endif\n \n@@ -1271,7 +1271,7 @@ static const short yycheck[] = {    38,\n     48,    49,    50,    51,    52,    53,    54,    55,    56,    57\n };\n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/share/misc/bison.simple\"\n+#line 3 \"/usr/lib/bison.simple\"\n /* This file comes from bison-1.28.  */\n \n /* Skeleton output parser for bison,\n@@ -1485,7 +1485,7 @@ __yy_memcpy (char *to, char *from, unsigned int count)\n #endif\n #endif\n \f\n-#line 217 \"/usr/share/misc/bison.simple\"\n+#line 217 \"/usr/lib/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -3345,32 +3345,30 @@ case 352:\n     break;}\n case 353:\n #line 1711 \"c-parse.y\"\n-{ stmt_count++;\n-\t\t  emit_line_note (yyvsp[-3].filename, yyvsp[-2].lineno);\n-\t\t  if ( ! expand_exit_something ())\n-\t\t    error (\"break statement not within loop or switch\"); ;\n+{ tree break_stmt = build_break_stmt ();\n+\t\t  stmt_count++;\n+\t\t  genrtl_break_stmt (); ;\n     break;}\n case 354:\n-#line 1716 \"c-parse.y\"\n-{ stmt_count++;\n-\t\t  emit_line_note (yyvsp[-3].filename, yyvsp[-2].lineno);\n-\t\t  if (! expand_continue_loop (NULL_PTR))\n-\t\t    error (\"continue statement not within a loop\"); ;\n+#line 1715 \"c-parse.y\"\n+{ tree continue_stmt = build_continue_stmt ();\n+                  stmt_count++;\n+\t\t  genrtl_continue_stmt (); ;\n     break;}\n case 355:\n-#line 1721 \"c-parse.y\"\n-{ stmt_count++;\n-\t\t  emit_line_note (yyvsp[-3].filename, yyvsp[-2].lineno);\n-\t\t  c_expand_return (NULL_TREE); ;\n+#line 1719 \"c-parse.y\"\n+{ tree return_stmt = build_return_stmt (NULL_TREE);\n+                  stmt_count++;\n+\t\t  genrtl_return_stmt (RETURN_EXPR(return_stmt)); ;\n     break;}\n case 356:\n-#line 1725 \"c-parse.y\"\n-{ stmt_count++;\n-\t\t  emit_line_note (yyvsp[-4].filename, yyvsp[-3].lineno);\n-\t\t  c_expand_return (yyvsp[-1].ttype); ;\n+#line 1723 \"c-parse.y\"\n+{ tree return_stmt = build_return_stmt (yyvsp[-1].ttype);\n+                  stmt_count++;\n+\t\t  genrtl_return_stmt (RETURN_EXPR(return_stmt)); ;\n     break;}\n case 357:\n-#line 1729 \"c-parse.y\"\n+#line 1727 \"c-parse.y\"\n { stmt_count++;\n \t\t  emit_line_note (yyvsp[-7].filename, yyvsp[-6].lineno);\n \t\t  STRIP_NOPS (yyvsp[-2].ttype);\n@@ -3382,31 +3380,31 @@ case 357:\n \t\t    error (\"argument of `asm' is not a constant string\"); ;\n     break;}\n case 358:\n-#line 1740 \"c-parse.y\"\n+#line 1738 \"c-parse.y\"\n { stmt_count++;\n \t\t  emit_line_note (yyvsp[-9].filename, yyvsp[-8].lineno);\n \t\t  c_expand_asm_operands (yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE, NULL_TREE,\n \t\t\t\t\t yyvsp[-6].ttype == ridpointers[(int)RID_VOLATILE],\n \t\t\t\t\t input_filename, lineno); ;\n     break;}\n case 359:\n-#line 1747 \"c-parse.y\"\n+#line 1745 \"c-parse.y\"\n { stmt_count++;\n \t\t  emit_line_note (yyvsp[-11].filename, yyvsp[-10].lineno);\n \t\t  c_expand_asm_operands (yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype, NULL_TREE,\n \t\t\t\t\t yyvsp[-8].ttype == ridpointers[(int)RID_VOLATILE],\n \t\t\t\t\t input_filename, lineno); ;\n     break;}\n case 360:\n-#line 1755 \"c-parse.y\"\n+#line 1753 \"c-parse.y\"\n { stmt_count++;\n \t\t  emit_line_note (yyvsp[-13].filename, yyvsp[-12].lineno);\n \t\t  c_expand_asm_operands (yyvsp[-8].ttype, yyvsp[-6].ttype, yyvsp[-4].ttype, yyvsp[-2].ttype,\n \t\t\t\t\t yyvsp[-10].ttype == ridpointers[(int)RID_VOLATILE],\n \t\t\t\t\t input_filename, lineno); ;\n     break;}\n case 361:\n-#line 1761 \"c-parse.y\"\n+#line 1759 \"c-parse.y\"\n { tree decl;\n \t\t  stmt_count++;\n \t\t  emit_line_note (yyvsp[-4].filename, yyvsp[-3].lineno);\n@@ -3419,15 +3417,15 @@ case 361:\n \t\t;\n     break;}\n case 362:\n-#line 1772 \"c-parse.y\"\n+#line 1770 \"c-parse.y\"\n { if (pedantic)\n \t\t    pedwarn (\"ANSI C forbids `goto *expr;'\");\n \t\t  stmt_count++;\n \t\t  emit_line_note (yyvsp[-5].filename, yyvsp[-4].lineno);\n \t\t  expand_computed_goto (convert (ptr_type_node, yyvsp[-1].ttype)); ;\n     break;}\n case 365:\n-#line 1787 \"c-parse.y\"\n+#line 1785 \"c-parse.y\"\n {\n \t    /* The value returned by this action is  */\n \t    /*      1 if everything is OK */ \n@@ -3450,97 +3448,38 @@ case 365:\n \t  ;\n     break;}\n case 366:\n-#line 1808 \"c-parse.y\"\n+#line 1806 \"c-parse.y\"\n {\n \t    if (yyvsp[-1].itype)\n \t      iterator_for_loop_end (yyvsp[-3].ttype);\n \t  ;\n     break;}\n case 367:\n-#line 1839 \"c-parse.y\"\n-{ register tree value = check_case_value (yyvsp[-1].ttype);\n-\t\t  register tree label\n-\t\t    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\n+#line 1837 \"c-parse.y\"\n+{ tree case_label_tree = build_case_label (yyvsp[-1].ttype, NULL_TREE);\n \t\t  stmt_count++;\n-\n-\t\t  if (value != error_mark_node)\n-\t\t    {\n-\t\t      tree duplicate;\n-\t\t      int success;\n-\n-\t\t      if (pedantic && ! INTEGRAL_TYPE_P (TREE_TYPE (value)))\n-\t\t\tpedwarn (\"label must have integral type in ANSI C\");\n-\n-\t\t      success = pushcase (value, convert_and_check,\n-\t\t\t\t\t  label, &duplicate);\n-\n-\t\t      if (success == 1)\n-\t\t\terror (\"case label not within a switch statement\");\n-\t\t      else if (success == 2)\n-\t\t\t{\n-\t\t\t  error (\"duplicate case value\");\n-\t\t\t  error_with_decl (duplicate, \"this is the first entry for that value\");\n-\t\t\t}\n-\t\t      else if (success == 3)\n-\t\t\twarning (\"case value out of range\");\n-\t\t      else if (success == 5)\n-\t\t\terror (\"case label within scope of cleanup or variable array\");\n-\t\t    }\n-\t\t  position_after_white_space (); ;\n+\t\t  genrtl_case_label(CASE_LOW(case_label_tree), CASE_HIGH(case_label_tree));\n+\t\t  position_after_white_space ();\n+\t\t;\n     break;}\n case 368:\n-#line 1870 \"c-parse.y\"\n-{ register tree value1 = check_case_value (yyvsp[-3].ttype);\n-\t\t  register tree value2 = check_case_value (yyvsp[-1].ttype);\n-\t\t  register tree label\n-\t\t    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids case ranges\");\n+#line 1843 \"c-parse.y\"\n+{ tree case_label_tree = build_case_label (yyvsp[-3].ttype, yyvsp[-1].ttype);\n \t\t  stmt_count++;\n-\n-\t\t  if (value1 != error_mark_node && value2 != error_mark_node)\n-\t\t    {\n-\t\t      tree duplicate;\n-\t\t      int success = pushcase_range (value1, value2,\n-\t\t\t\t\t\t    convert_and_check, label,\n-\t\t\t\t\t\t    &duplicate);\n-\t\t      if (success == 1)\n-\t\t\terror (\"case label not within a switch statement\");\n-\t\t      else if (success == 2)\n-\t\t\t{\n-\t\t\t  error (\"duplicate case value\");\n-\t\t\t  error_with_decl (duplicate, \"this is the first entry for that value\");\n-\t\t\t}\n-\t\t      else if (success == 3)\n-\t\t\twarning (\"case value out of range\");\n-\t\t      else if (success == 4)\n-\t\t\twarning (\"empty case range\");\n-\t\t      else if (success == 5)\n-\t\t\terror (\"case label within scope of cleanup or variable array\");\n-\t\t    }\n-\t\t  position_after_white_space (); ;\n+\t\t  genrtl_case_label(CASE_LOW(case_label_tree), CASE_HIGH(case_label_tree));\n+\t\t  position_after_white_space ();\n+\t\t;\n     break;}\n case 369:\n-#line 1901 \"c-parse.y\"\n-{\n-\t\t  tree duplicate;\n-\t\t  register tree label\n-\t\t    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\t\t  int success = pushcase (NULL_TREE, 0, label, &duplicate);\n+#line 1849 \"c-parse.y\"\n+{ tree case_label_tree = build_case_label (NULL_TREE, NULL_TREE);\n \t\t  stmt_count++;\n-\t\t  if (success == 1)\n-\t\t    error (\"default label not within a switch statement\");\n-\t\t  else if (success == 2)\n-\t\t    {\n-\t\t      error (\"multiple default labels in one switch\");\n-\t\t      error_with_decl (duplicate, \"this is the first default label\");\n-\t\t    }\n-\t\t  position_after_white_space (); ;\n+\t\t  genrtl_case_label(CASE_LOW(case_label_tree), CASE_HIGH(case_label_tree));\n+\t\t  position_after_white_space ();\n+\t\t;\n     break;}\n case 370:\n-#line 1916 \"c-parse.y\"\n+#line 1855 \"c-parse.y\"\n { tree label = define_label (input_filename, lineno, yyvsp[-2].ttype);\n \t\t  stmt_count++;\n \t\t  emit_nop ();\n@@ -3552,52 +3491,52 @@ case 370:\n \t\t  position_after_white_space (); ;\n     break;}\n case 371:\n-#line 1931 \"c-parse.y\"\n+#line 1870 \"c-parse.y\"\n { emit_line_note (input_filename, lineno);\n \t\t  yyval.ttype = NULL_TREE; ;\n     break;}\n case 372:\n-#line 1934 \"c-parse.y\"\n+#line 1873 \"c-parse.y\"\n { emit_line_note (input_filename, lineno); ;\n     break;}\n case 373:\n-#line 1939 \"c-parse.y\"\n+#line 1878 \"c-parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 375:\n-#line 1946 \"c-parse.y\"\n+#line 1885 \"c-parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 378:\n-#line 1953 \"c-parse.y\"\n+#line 1892 \"c-parse.y\"\n { yyval.ttype = chainon (yyvsp[-2].ttype, yyvsp[0].ttype); ;\n     break;}\n case 379:\n-#line 1958 \"c-parse.y\"\n+#line 1897 \"c-parse.y\"\n { yyval.ttype = build_tree_list (yyvsp[-3].ttype, yyvsp[-1].ttype); ;\n     break;}\n case 380:\n-#line 1963 \"c-parse.y\"\n+#line 1902 \"c-parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, combine_strings (yyvsp[0].ttype), NULL_TREE); ;\n     break;}\n case 381:\n-#line 1965 \"c-parse.y\"\n+#line 1904 \"c-parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, combine_strings (yyvsp[0].ttype), yyvsp[-2].ttype); ;\n     break;}\n case 382:\n-#line 1971 \"c-parse.y\"\n+#line 1910 \"c-parse.y\"\n { pushlevel (0);\n \t\t  clear_parm_order ();\n \t\t  declare_parm_level (0); ;\n     break;}\n case 383:\n-#line 1975 \"c-parse.y\"\n+#line 1914 \"c-parse.y\"\n { yyval.ttype = yyvsp[0].ttype;\n \t\t  parmlist_tags_warning ();\n \t\t  poplevel (0, 0, 0); ;\n     break;}\n case 385:\n-#line 1983 \"c-parse.y\"\n+#line 1922 \"c-parse.y\"\n { tree parm;\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C forbids forward parameter declarations\");\n@@ -3607,19 +3546,19 @@ case 385:\n \t\t  clear_parm_order (); ;\n     break;}\n case 386:\n-#line 1991 \"c-parse.y\"\n+#line 1930 \"c-parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 387:\n-#line 1993 \"c-parse.y\"\n+#line 1932 \"c-parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE); ;\n     break;}\n case 388:\n-#line 1999 \"c-parse.y\"\n+#line 1938 \"c-parse.y\"\n { yyval.ttype = get_parm_info (0); ;\n     break;}\n case 389:\n-#line 2001 \"c-parse.y\"\n+#line 1940 \"c-parse.y\"\n { yyval.ttype = get_parm_info (0);\n \t\t  /* Gcc used to allow this as an extension.  However, it does\n \t\t     not work for all targets, and thus has been disabled.\n@@ -3631,23 +3570,23 @@ case 389:\n \t\t;\n     break;}\n case 390:\n-#line 2011 \"c-parse.y\"\n+#line 1950 \"c-parse.y\"\n { yyval.ttype = get_parm_info (1); ;\n     break;}\n case 391:\n-#line 2013 \"c-parse.y\"\n+#line 1952 \"c-parse.y\"\n { yyval.ttype = get_parm_info (0); ;\n     break;}\n case 392:\n-#line 2018 \"c-parse.y\"\n+#line 1957 \"c-parse.y\"\n { push_parm_decl (yyvsp[0].ttype); ;\n     break;}\n case 393:\n-#line 2020 \"c-parse.y\"\n+#line 1959 \"c-parse.y\"\n { push_parm_decl (yyvsp[0].ttype); ;\n     break;}\n case 394:\n-#line 2027 \"c-parse.y\"\n+#line 1966 \"c-parse.y\"\n { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t yyvsp[-1].ttype),\n \t\t\t\t\tbuild_tree_list (prefix_attributes,\n@@ -3657,7 +3596,7 @@ case 394:\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); ;\n     break;}\n case 395:\n-#line 2035 \"c-parse.y\"\n+#line 1974 \"c-parse.y\"\n { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t yyvsp[-1].ttype),\n \t\t\t\t\tbuild_tree_list (prefix_attributes,\n@@ -3667,7 +3606,7 @@ case 395:\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); ;\n     break;}\n case 396:\n-#line 2043 \"c-parse.y\"\n+#line 1982 \"c-parse.y\"\n { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t yyvsp[-1].ttype),\n \t\t\t\t\tbuild_tree_list (prefix_attributes,\n@@ -3677,7 +3616,7 @@ case 396:\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); ;\n     break;}\n case 397:\n-#line 2051 \"c-parse.y\"\n+#line 1990 \"c-parse.y\"\n { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t yyvsp[-1].ttype),\n \t\t\t\t\tbuild_tree_list (prefix_attributes,\n@@ -3687,7 +3626,7 @@ case 397:\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); ;\n     break;}\n case 398:\n-#line 2060 \"c-parse.y\"\n+#line 1999 \"c-parse.y\"\n { yyval.ttype = build_tree_list (build_tree_list (current_declspecs,\n \t\t\t\t\t\t\t yyvsp[-1].ttype),\n \t\t\t\t\tbuild_tree_list (prefix_attributes,\n@@ -3697,50 +3636,50 @@ case 398:\n \t\t  declspec_stack = TREE_CHAIN (declspec_stack); ;\n     break;}\n case 399:\n-#line 2073 \"c-parse.y\"\n+#line 2012 \"c-parse.y\"\n { pushlevel (0);\n \t\t  clear_parm_order ();\n \t\t  declare_parm_level (1); ;\n     break;}\n case 400:\n-#line 2077 \"c-parse.y\"\n+#line 2016 \"c-parse.y\"\n { yyval.ttype = yyvsp[0].ttype;\n \t\t  parmlist_tags_warning ();\n \t\t  poplevel (0, 0, 0); ;\n     break;}\n case 402:\n-#line 2085 \"c-parse.y\"\n+#line 2024 \"c-parse.y\"\n { tree t;\n \t\t  for (t = yyvsp[-1].ttype; t; t = TREE_CHAIN (t))\n \t\t    if (TREE_VALUE (t) == NULL_TREE)\n \t\t      error (\"`...' in old-style identifier list\");\n \t\t  yyval.ttype = tree_cons (NULL_TREE, NULL_TREE, yyvsp[-1].ttype); ;\n     break;}\n case 403:\n-#line 2095 \"c-parse.y\"\n+#line 2034 \"c-parse.y\"\n { yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 404:\n-#line 2097 \"c-parse.y\"\n+#line 2036 \"c-parse.y\"\n { yyval.ttype = chainon (yyvsp[-2].ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;\n     break;}\n case 405:\n-#line 2103 \"c-parse.y\"\n+#line 2042 \"c-parse.y\"\n { yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ttype); ;\n     break;}\n case 406:\n-#line 2105 \"c-parse.y\"\n+#line 2044 \"c-parse.y\"\n { yyval.ttype = chainon (yyvsp[-2].ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;\n     break;}\n case 407:\n-#line 2110 \"c-parse.y\"\n+#line 2049 \"c-parse.y\"\n { yyval.ttype = SAVE_WARN_FLAGS();\n \t\t  pedantic = 0;\n \t\t  warn_pointer_arith = 0; ;\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 543 \"/usr/share/misc/bison.simple\"\n+#line 543 \"/usr/lib/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -3960,5 +3899,5 @@ case 407:\n     }\n   return 1;\n }\n-#line 2115 \"c-parse.y\"\n+#line 2054 \"c-parse.y\"\n "}, {"sha": "11b06569acda8a07dc94057e0aaded03a7bc48cd", "filename": "gcc/c-parse.y", "status": "modified", "additions": 24, "deletions": 85, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ecdf775f381a7efc787f622146f2924f2682eeb/gcc%2Fc-parse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ecdf775f381a7efc787f622146f2924f2682eeb/gcc%2Fc-parse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.y?ref=5ecdf775f381a7efc787f622146f2924f2682eeb", "patch": "@@ -1708,23 +1708,21 @@ stmt:\n \t  lineno_labeled_stmt\n \t\t{ expand_end_case ($3); }\n \t| BREAK ';'\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  if ( ! expand_exit_something ())\n-\t\t    error (\"break statement not within loop or switch\"); }\n+\t        { tree break_stmt = build_break_stmt ();\n+\t\t  stmt_count++;\n+\t\t  genrtl_break_stmt (); }\n \t| CONTINUE ';'\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  if (! expand_continue_loop (NULL_PTR))\n-\t\t    error (\"continue statement not within a loop\"); }\n+                { tree continue_stmt = build_continue_stmt ();\n+                  stmt_count++;\n+\t\t  genrtl_continue_stmt (); }\n \t| RETURN ';'\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  c_expand_return (NULL_TREE); }\n+                { tree return_stmt = build_return_stmt (NULL_TREE);\n+                  stmt_count++;\n+\t\t  genrtl_return_stmt (RETURN_EXPR(return_stmt)); }\n \t| RETURN expr ';'\n-\t\t{ stmt_count++;\n-\t\t  emit_line_note ($<filename>-1, $<lineno>0);\n-\t\t  c_expand_return ($2); }\n+                { tree return_stmt = build_return_stmt ($2);\n+                  stmt_count++;\n+\t\t  genrtl_return_stmt (RETURN_EXPR(return_stmt)); }\n \t| ASM_KEYWORD maybe_type_qual '(' expr ')' ';'\n \t\t{ stmt_count++;\n \t\t  emit_line_note ($<filename>-1, $<lineno>0);\n@@ -1836,82 +1834,23 @@ all_iter_stmt_with_decl:\n    also at the end of a compound statement.  */\n \n label:\t  CASE expr_no_commas ':'\n-\t\t{ register tree value = check_case_value ($2);\n-\t\t  register tree label\n-\t\t    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\n+                { tree case_label_tree = build_case_label ($2, NULL_TREE);\n \t\t  stmt_count++;\n-\n-\t\t  if (value != error_mark_node)\n-\t\t    {\n-\t\t      tree duplicate;\n-\t\t      int success;\n-\n-\t\t      if (pedantic && ! INTEGRAL_TYPE_P (TREE_TYPE (value)))\n-\t\t\tpedwarn (\"label must have integral type in ANSI C\");\n-\n-\t\t      success = pushcase (value, convert_and_check,\n-\t\t\t\t\t  label, &duplicate);\n-\n-\t\t      if (success == 1)\n-\t\t\terror (\"case label not within a switch statement\");\n-\t\t      else if (success == 2)\n-\t\t\t{\n-\t\t\t  error (\"duplicate case value\");\n-\t\t\t  error_with_decl (duplicate, \"this is the first entry for that value\");\n-\t\t\t}\n-\t\t      else if (success == 3)\n-\t\t\twarning (\"case value out of range\");\n-\t\t      else if (success == 5)\n-\t\t\terror (\"case label within scope of cleanup or variable array\");\n-\t\t    }\n-\t\t  position_after_white_space (); }\n+\t\t  genrtl_case_label(CASE_LOW(case_label_tree), CASE_HIGH(case_label_tree));\n+\t\t  position_after_white_space ();\n+\t\t}\n \t| CASE expr_no_commas ELLIPSIS expr_no_commas ':'\n-\t\t{ register tree value1 = check_case_value ($2);\n-\t\t  register tree value2 = check_case_value ($4);\n-\t\t  register tree label\n-\t\t    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C forbids case ranges\");\n+                { tree case_label_tree = build_case_label ($2, $4);\n \t\t  stmt_count++;\n-\n-\t\t  if (value1 != error_mark_node && value2 != error_mark_node)\n-\t\t    {\n-\t\t      tree duplicate;\n-\t\t      int success = pushcase_range (value1, value2,\n-\t\t\t\t\t\t    convert_and_check, label,\n-\t\t\t\t\t\t    &duplicate);\n-\t\t      if (success == 1)\n-\t\t\terror (\"case label not within a switch statement\");\n-\t\t      else if (success == 2)\n-\t\t\t{\n-\t\t\t  error (\"duplicate case value\");\n-\t\t\t  error_with_decl (duplicate, \"this is the first entry for that value\");\n-\t\t\t}\n-\t\t      else if (success == 3)\n-\t\t\twarning (\"case value out of range\");\n-\t\t      else if (success == 4)\n-\t\t\twarning (\"empty case range\");\n-\t\t      else if (success == 5)\n-\t\t\terror (\"case label within scope of cleanup or variable array\");\n-\t\t    }\n-\t\t  position_after_white_space (); }\n+\t\t  genrtl_case_label(CASE_LOW(case_label_tree), CASE_HIGH(case_label_tree));\n+\t\t  position_after_white_space ();\n+\t\t}\n \t| DEFAULT ':'\n-\t\t{\n-\t\t  tree duplicate;\n-\t\t  register tree label\n-\t\t    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\t\t  int success = pushcase (NULL_TREE, 0, label, &duplicate);\n+                { tree case_label_tree = build_case_label (NULL_TREE, NULL_TREE);\n \t\t  stmt_count++;\n-\t\t  if (success == 1)\n-\t\t    error (\"default label not within a switch statement\");\n-\t\t  else if (success == 2)\n-\t\t    {\n-\t\t      error (\"multiple default labels in one switch\");\n-\t\t      error_with_decl (duplicate, \"this is the first default label\");\n-\t\t    }\n-\t\t  position_after_white_space (); }\n+\t\t  genrtl_case_label(CASE_LOW(case_label_tree), CASE_HIGH(case_label_tree));\n+\t\t  position_after_white_space ();\n+\t\t}\n \t| identifier ':' maybe_attribute\n \t\t{ tree label = define_label (input_filename, lineno, $1);\n \t\t  stmt_count++;"}]}