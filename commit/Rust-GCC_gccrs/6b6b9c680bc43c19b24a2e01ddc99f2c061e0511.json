{"sha": "6b6b9c680bc43c19b24a2e01ddc99f2c061e0511", "node_id": "C_kwDOANBUbNoAKDZiNmI5YzY4MGJjNDNjMTliMjRhMmUwMWRkYzk5ZjJjMDYxZTA1MTE", "commit": {"author": {"name": "Ju-Zhe Zhong", "email": "juzhe.zhong@rivai.ai", "date": "2023-01-18T03:24:34Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2023-01-27T12:31:51Z"}, "message": "RISC-V: Finalize VSETVL PASS implementation\n\ngcc/ChangeLog:\n\n\t* config/riscv/riscv-vsetvl.cc (vsetvl_insn_p): Add condition to avoid ICE.\n\t(vsetvl_discard_result_insn_p): New function.\n\t(reg_killed_by_bb_p): rename to find_reg_killed_by.\n\t(find_reg_killed_by): New name.\n\t(get_vl): allow it to be called by more functions.\n\t(has_vsetvl_killed_avl_p): Add condition.\n\t(get_avl): allow it to be called by more functions.\n\t(insn_should_be_added_p): New function.\n\t(get_all_nonphi_defs): Refine function.\n\t(get_all_sets): Ditto.\n\t(get_same_bb_set): New function.\n\t(any_insn_in_bb_p): Ditto.\n\t(any_set_in_bb_p): Ditto.\n\t(get_vl_vtype_info): Add VLMAX forward optimization.\n\t(source_equal_p): Fix issues.\n\t(extract_single_source): Refine.\n\t(avl_info::multiple_source_equal_p): New function.\n\t(avl_info::operator==): Adjust for final version.\n\t(vl_vtype_info::operator==): Ditto.\n\t(vl_vtype_info::same_avl_p): Ditto.\n\t(vector_insn_info::parse_insn): Ditto.\n\t(vector_insn_info::available_p): New function.\n\t(vector_insn_info::merge): Adjust for final version.\n\t(vector_insn_info::dump): Add hard_empty.\n\t(pass_vsetvl::hard_empty_block_p): New function.\n\t(pass_vsetvl::backward_demand_fusion): Adjust for final version.\n\t(pass_vsetvl::forward_demand_fusion): Ditto.\n\t(pass_vsetvl::demand_fusion): Ditto.\n\t(pass_vsetvl::cleanup_illegal_dirty_blocks): New function.\n\t(pass_vsetvl::compute_local_properties): Adjust for final version.\n\t(pass_vsetvl::can_refine_vsetvl_p): Ditto.\n\t(pass_vsetvl::refine_vsetvls): Ditto.\n\t(pass_vsetvl::commit_vsetvls): Ditto.\n\t(pass_vsetvl::propagate_avl): New function.\n\t(pass_vsetvl::lazy_vsetvl): Adjust for new version.\n\t* config/riscv/riscv-vsetvl.h (enum def_type): New enum.", "tree": {"sha": "5b6883dbe9b81564a5a051c9181b7c5d7fb0dd4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b6883dbe9b81564a5a051c9181b7c5d7fb0dd4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b6b9c680bc43c19b24a2e01ddc99f2c061e0511", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b6b9c680bc43c19b24a2e01ddc99f2c061e0511", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b6b9c680bc43c19b24a2e01ddc99f2c061e0511", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b6b9c680bc43c19b24a2e01ddc99f2c061e0511/comments", "author": {"login": "zhongjuzhe", "id": 66454988, "node_id": "MDQ6VXNlcjY2NDU0OTg4", "avatar_url": "https://avatars.githubusercontent.com/u/66454988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhongjuzhe", "html_url": "https://github.com/zhongjuzhe", "followers_url": "https://api.github.com/users/zhongjuzhe/followers", "following_url": "https://api.github.com/users/zhongjuzhe/following{/other_user}", "gists_url": "https://api.github.com/users/zhongjuzhe/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhongjuzhe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhongjuzhe/subscriptions", "organizations_url": "https://api.github.com/users/zhongjuzhe/orgs", "repos_url": "https://api.github.com/users/zhongjuzhe/repos", "events_url": "https://api.github.com/users/zhongjuzhe/events{/privacy}", "received_events_url": "https://api.github.com/users/zhongjuzhe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffa29648b2fbb1a14c70a33d3b6cd420ba4e9f9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa29648b2fbb1a14c70a33d3b6cd420ba4e9f9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffa29648b2fbb1a14c70a33d3b6cd420ba4e9f9d"}], "stats": {"total": 960, "additions": 737, "deletions": 223}, "files": [{"sha": "ef5b74c58d241f8c5731c1e82def9e6fc89008d4", "filename": "gcc/config/riscv/riscv-vsetvl.cc", "status": "modified", "additions": 708, "deletions": 222, "changes": 930, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6b9c680bc43c19b24a2e01ddc99f2c061e0511/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6b9c680bc43c19b24a2e01ddc99f2c061e0511/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.cc?ref=6b6b9c680bc43c19b24a2e01ddc99f2c061e0511", "patch": "@@ -53,6 +53,8 @@ along with GCC; see the file COPYING3.  If not see\n        used any more and VL operand of VSETVL instruction if it is not used by\n        any non-debug instructions.\n \n+    -  Phase 6 - Propagate AVL between vsetvl instructions.\n+\n     Implementation:\n \n     -  The subroutine of optimize == 0 is simple_vsetvl.\n@@ -174,8 +176,20 @@ vector_config_insn_p (rtx_insn *rinsn)\n static bool\n vsetvl_insn_p (rtx_insn *rinsn)\n {\n+  if (!vector_config_insn_p (rinsn))\n+    return false;\n   return (INSN_CODE (rinsn) == CODE_FOR_vsetvldi\n-\t || INSN_CODE (rinsn) == CODE_FOR_vsetvlsi);\n+\t  || INSN_CODE (rinsn) == CODE_FOR_vsetvlsi);\n+}\n+\n+/* Return true if it is vsetvl zero, rs1.  */\n+static bool\n+vsetvl_discard_result_insn_p (rtx_insn *rinsn)\n+{\n+  if (!vector_config_insn_p (rinsn))\n+    return false;\n+  return (INSN_CODE (rinsn) == CODE_FOR_vsetvl_discard_resultdi\n+\t  || INSN_CODE (rinsn) == CODE_FOR_vsetvl_discard_resultsi);\n }\n \n static bool\n@@ -190,15 +204,27 @@ before_p (const insn_info *insn1, const insn_info *insn2)\n   return insn1->compare_with (insn2) < 0;\n }\n \n-static bool\n-reg_killed_by_bb_p (const bb_info *bb, rtx x)\n+static insn_info *\n+find_reg_killed_by (const bb_info *bb, rtx x)\n {\n-  if (!x || vlmax_avl_p (x))\n-    return false;\n-  for (const insn_info *insn : bb->real_nondebug_insns ())\n+  if (!x || vlmax_avl_p (x) || !REG_P (x))\n+    return nullptr;\n+  for (insn_info *insn : bb->reverse_real_nondebug_insns ())\n     if (find_access (insn->defs (), REGNO (x)))\n-      return true;\n-  return false;\n+      return insn;\n+  return nullptr;\n+}\n+\n+/* Helper function to get VL operand.  */\n+static rtx\n+get_vl (rtx_insn *rinsn)\n+{\n+  if (has_vl_op (rinsn))\n+    {\n+      extract_insn_cached (rinsn);\n+      return recog_data.operand[get_attr_vl_op_idx (rinsn)];\n+    }\n+  return SET_DEST (XVECEXP (PATTERN (rinsn), 0, 0));\n }\n \n static bool\n@@ -207,6 +233,9 @@ has_vsetvl_killed_avl_p (const bb_info *bb, const vector_insn_info &info)\n   if (info.dirty_with_killed_avl_p ())\n     {\n       rtx avl = info.get_avl ();\n+      if (vlmax_avl_p (avl))\n+\treturn find_reg_killed_by (bb, get_vl (info.get_insn ()->rtl ()))\n+\t       != nullptr;\n       for (const insn_info *insn : bb->reverse_real_nondebug_insns ())\n \t{\n \t  def_info *def = find_access (insn->defs (), REGNO (avl));\n@@ -228,18 +257,6 @@ has_vsetvl_killed_avl_p (const bb_info *bb, const vector_insn_info &info)\n   return false;\n }\n \n-/* Helper function to get VL operand.  */\n-static rtx\n-get_vl (rtx_insn *rinsn)\n-{\n-  if (has_vl_op (rinsn))\n-    {\n-      extract_insn_cached (rinsn);\n-      return recog_data.operand[get_attr_vl_op_idx (rinsn)];\n-    }\n-  return SET_DEST (XVECEXP (PATTERN (rinsn), 0, 0));\n-}\n-\n /* An \"anticipatable occurrence\" is one that is the first occurrence in the\n    basic block, the operands are not modified in the basic block prior\n    to the occurrence and the output is not used between the start of\n@@ -418,30 +435,30 @@ backward_propagate_worthwhile_p (const basic_block cfg_bb,\n   return true;\n }\n \n-/* Helper function to get AVL operand.  */\n-static rtx\n-get_avl (rtx_insn *rinsn)\n+static bool\n+insn_should_be_added_p (const insn_info *insn, unsigned int types)\n {\n-  if (vsetvl_insn_p (rinsn))\n-    return XVECEXP (SET_SRC (XVECEXP (PATTERN (rinsn), 0, 0)), 0, 0);\n-\n-  if (!has_vl_op (rinsn))\n-    return NULL_RTX;\n-  if (get_attr_avl_type (rinsn) == VLMAX)\n-    return RVV_VLMAX;\n-  extract_insn_cached (rinsn);\n-  return recog_data.operand[get_attr_vl_op_idx (rinsn)];\n+  if (insn->is_real () && (types & REAL_SET))\n+    return true;\n+  if (insn->is_phi () && (types & PHI_SET))\n+    return true;\n+  if (insn->is_bb_head () && (types & BB_HEAD_SET))\n+    return true;\n+  if (insn->is_bb_end () && (types & BB_END_SET))\n+    return true;\n+  return false;\n }\n \n-/* Recursively find all real define instructions if it is a real instruction. */\n-static hash_set<insn_info *>\n-get_all_nonphi_defs (phi_info *phi)\n+/* Recursively find all define instructions. The kind of instruction is\n+   specified by the DEF_TYPE.  */\n+static hash_set<set_info *>\n+get_all_sets (phi_info *phi, unsigned int types)\n {\n-  hash_set<insn_info *> insns;\n+  hash_set<set_info *> insns;\n   auto_vec<phi_info *> work_list;\n   hash_set<phi_info *> visited_list;\n   if (!phi)\n-    return insns;\n+    return hash_set<set_info *> ();\n   work_list.safe_push (phi);\n \n   while (!work_list.is_empty ())\n@@ -451,20 +468,17 @@ get_all_nonphi_defs (phi_info *phi)\n       for (use_info *use : phi->inputs ())\n \t{\n \t  def_info *def = use->def ();\n-\t  if (!def)\n-\t    {\n-\t      /* if def is null, treat undefined */\n-\t      insns.empty ();\n-\t      return insns;\n-\t    }\n+\t  set_info *set = safe_dyn_cast<set_info *> (def);\n+\t  if (!set)\n+\t    return hash_set<set_info *> ();\n \n-\t  gcc_assert (!def->insn ()->is_debug_insn ());\n+\t  gcc_assert (!set->insn ()->is_debug_insn ());\n \n-\t  if (!def->insn ()->is_phi ())\n-\t    insns.add (def->insn ());\n-\t  if (def->insn ()->is_phi ())\n+\t  if (insn_should_be_added_p (set->insn (), types))\n+\t    insns.add (set);\n+\t  if (set->insn ()->is_phi ())\n \t    {\n-\t      phi_info *new_phi = as_a<phi_info *> (def);\n+\t      phi_info *new_phi = as_a<phi_info *> (set);\n \t      if (!visited_list.contains (new_phi))\n \t\twork_list.safe_push (new_phi);\n \t    }\n@@ -473,6 +487,47 @@ get_all_nonphi_defs (phi_info *phi)\n   return insns;\n }\n \n+static hash_set<set_info *>\n+get_all_sets (set_info *set, bool /* get_real_inst */ real_p,\n+\t      bool /*get_phi*/ phi_p, bool /* get_function_parameter*/ param_p)\n+{\n+  if (real_p && phi_p && param_p)\n+    return get_all_sets (safe_dyn_cast<phi_info *> (set),\n+\t\t\t REAL_SET | PHI_SET | BB_HEAD_SET | BB_END_SET);\n+\n+  else if (real_p && param_p)\n+    return get_all_sets (safe_dyn_cast<phi_info *> (set),\n+\t\t\t REAL_SET | BB_HEAD_SET | BB_END_SET);\n+\n+  else if (real_p)\n+    return get_all_sets (safe_dyn_cast<phi_info *> (set), REAL_SET);\n+  return hash_set<set_info *> ();\n+}\n+\n+/* Helper function to get AVL operand.  */\n+static rtx\n+get_avl (rtx_insn *rinsn)\n+{\n+  if (vsetvl_insn_p (rinsn) || vsetvl_discard_result_insn_p (rinsn))\n+    return XVECEXP (SET_SRC (XVECEXP (PATTERN (rinsn), 0, 0)), 0, 0);\n+\n+  if (!has_vl_op (rinsn))\n+    return NULL_RTX;\n+  if (get_attr_avl_type (rinsn) == VLMAX)\n+    return RVV_VLMAX;\n+  extract_insn_cached (rinsn);\n+  return recog_data.operand[get_attr_vl_op_idx (rinsn)];\n+}\n+\n+static set_info *\n+get_same_bb_set (hash_set<set_info *> &sets, const basic_block cfg_bb)\n+{\n+  for (set_info *set : sets)\n+    if (set->bb ()->cfg_bb () == cfg_bb)\n+      return set;\n+  return nullptr;\n+}\n+\n /* Recursively find all predecessor blocks for cfg_bb. */\n static hash_set<basic_block>\n get_all_predecessors (basic_block cfg_bb)\n@@ -500,10 +555,10 @@ get_all_predecessors (basic_block cfg_bb)\n \n /* Return true if there is an INSN in insns staying in the block BB.  */\n static bool\n-any_insn_in_bb_p (hash_set<insn_info *> insns, const bb_info *bb)\n+any_set_in_bb_p (hash_set<set_info *> sets, const bb_info *bb)\n {\n-  for (const insn_info *insn : insns)\n-    if (insn->bb ()->index () == bb->index ())\n+  for (const set_info *set : sets)\n+    if (set->bb ()->index () == bb->index ())\n       return true;\n   return false;\n }\n@@ -833,10 +888,6 @@ insert_insn_end_basic_block (rtx_insn *rinsn, basic_block cfg_bb)\n static vl_vtype_info\n get_vl_vtype_info (const insn_info *insn)\n {\n-  if (vector_config_insn_p (insn->rtl ()))\n-    gcc_assert (vsetvl_insn_p (insn->rtl ())\n-\t\t&& \"Can't handle X0, rs1 vsetvli yet\");\n-\n   set_info *set = nullptr;\n   rtx avl = ::get_avl (insn->rtl ());\n   if (avl && REG_P (avl) && !vlmax_avl_p (avl))\n@@ -941,8 +992,12 @@ change_vsetvl_insn (const insn_info *insn, const vector_insn_info &info)\n }\n \n static bool\n-source_equal_p (rtx_insn *rinsn1, rtx_insn *rinsn2)\n+source_equal_p (insn_info *insn1, insn_info *insn2)\n {\n+  if (!insn1 || !insn2)\n+    return false;\n+  rtx_insn *rinsn1 = insn1->rtl ();\n+  rtx_insn *rinsn2 = insn2->rtl ();\n   if (!rinsn1 || !rinsn2)\n     return false;\n   rtx note1 = find_reg_equal_equiv_note (rinsn1);\n@@ -952,40 +1007,70 @@ source_equal_p (rtx_insn *rinsn1, rtx_insn *rinsn2)\n \n   if (note1 && note2 && rtx_equal_p (note1, note2))\n     return true;\n-  if (single_set1 && single_set2\n-      && rtx_equal_p (SET_SRC (single_set1), SET_SRC (single_set2)))\n-    return true;\n-  return false;\n+\n+  /* Since vsetvl instruction is not single SET.\n+     We handle this case specially here.  */\n+  if (vsetvl_insn_p (insn1->rtl ()) && vsetvl_insn_p (insn2->rtl ()))\n+    {\n+      /* For example:\n+\t   vsetvl1 a6,a5,e32m1\n+\t   RVV 1 (use a6 as AVL)\n+\t   vsetvl2 a5,a5,e8mf4\n+\t   RVV 2 (use a5 as AVL)\n+\t We consider AVL of RVV 1 and RVV 2 are same so that we can\n+\t gain more optimization opportunities.\n+\n+\t Note: insn1_info.compatible_avl_p (insn2_info)\n+\t will make sure there is no instruction between vsetvl1 and vsetvl2\n+\t modify a5 since their def will be different if there is instruction\n+\t modify a5 and compatible_avl_p will return false.  */\n+      vector_insn_info insn1_info, insn2_info;\n+      insn1_info.parse_insn (insn1);\n+      insn2_info.parse_insn (insn2);\n+      if (insn1_info.same_vlmax_p (insn2_info)\n+\t  && insn1_info.compatible_avl_p (insn2_info))\n+\treturn true;\n+    }\n+\n+  /* We only handle AVL is set by instructions with no side effects.  */\n+  if (!single_set1 || !single_set2)\n+    return false;\n+  if (!rtx_equal_p (SET_SRC (single_set1), SET_SRC (single_set2)))\n+    return false;\n+  gcc_assert (insn1->uses ().size () == insn2->uses ().size ());\n+  for (size_t i = 0; i < insn1->uses ().size (); i++)\n+    if (insn1->uses ()[i] != insn2->uses ()[i])\n+      return false;\n+  return true;\n }\n \n /* Helper function to get single same real RTL source.\n    return NULL if it is not a single real RTL source.  */\n-static rtx_insn *\n+static insn_info *\n extract_single_source (set_info *set)\n {\n   if (!set)\n     return nullptr;\n   if (set->insn ()->is_real ())\n-    return set->insn ()->rtl ();\n+    return set->insn ();\n   if (!set->insn ()->is_phi ())\n     return nullptr;\n-  phi_info *phi = safe_dyn_cast<phi_info *> (set);\n-  hash_set<insn_info *> insns = get_all_nonphi_defs (phi);\n+  hash_set<set_info *> sets = get_all_sets (set, true, false, true);\n \n-  insn_info *first_insn = (*insns.begin ());\n+  insn_info *first_insn = (*sets.begin ())->insn ();\n   if (first_insn->is_artificial ())\n     return nullptr;\n-  for (const insn_info *insn : insns)\n+  for (const set_info *set : sets)\n     {\n       /* If there is a head or end insn, we conservative return\n \t NULL so that VSETVL PASS will insert vsetvl directly.  */\n-      if (insn->is_artificial ())\n+      if (set->insn ()->is_artificial ())\n \treturn nullptr;\n-      if (!source_equal_p (insn->rtl (), first_insn->rtl ()))\n+      if (!source_equal_p (set->insn (), first_insn))\n \treturn nullptr;\n     }\n \n-  return (*insns.begin ())->rtl ();\n+  return first_insn;\n }\n \n avl_info::avl_info (const avl_info &other)\n@@ -1003,9 +1088,82 @@ avl_info::single_source_equal_p (const avl_info &other) const\n {\n   set_info *set1 = m_source;\n   set_info *set2 = other.get_source ();\n-  rtx_insn *rinsn1 = extract_single_source (set1);\n-  rtx_insn *rinsn2 = extract_single_source (set2);\n-  return source_equal_p (rinsn1, rinsn2);\n+  insn_info *insn1 = extract_single_source (set1);\n+  insn_info *insn2 = extract_single_source (set2);\n+  if (!insn1 || !insn2)\n+    return false;\n+  return source_equal_p (insn1, insn2);\n+}\n+\n+bool\n+avl_info::multiple_source_equal_p (const avl_info &other) const\n+{\n+  /* TODO: We don't do too much optimization here since it's\n+     too complicated in case of analyzing the PHI node.\n+\n+     For example:\n+       void f (void * restrict in, void * restrict out, int n, int m, int cond)\n+\t{\n+\t  size_t vl;\n+\t  switch (cond)\n+\t  {\n+\t  case 1:\n+\t    vl = 100;\n+\t    break;\n+\t  case 2:\n+\t    vl = *(size_t*)(in + 100);\n+\t    break;\n+\t  case 3:\n+\t    {\n+\t      size_t new_vl = *(size_t*)(in + 500);\n+\t      size_t new_vl2 = *(size_t*)(in + 600);\n+\t      vl = new_vl + new_vl2 + 777;\n+\t      break;\n+\t    }\n+\t  default:\n+\t    vl = 4000;\n+\t    break;\n+\t  }\n+\t  for (size_t i = 0; i < n; i++)\n+\t    {\n+\t      vint8mf8_t v = __riscv_vle8_v_i8mf8 (in + i, vl);\n+\t      __riscv_vse8_v_i8mf8 (out + i, v, vl);\n+\n+\t      vint8mf8_t v2 = __riscv_vle8_v_i8mf8_tu (v, in + i + 100, vl);\n+\t      __riscv_vse8_v_i8mf8 (out + i + 100, v2, vl);\n+\t    }\n+\n+\t  size_t vl2;\n+\t  switch (cond)\n+\t  {\n+\t  case 1:\n+\t    vl2 = 100;\n+\t    break;\n+\t  case 2:\n+\t    vl2 = *(size_t*)(in + 100);\n+\t    break;\n+\t  case 3:\n+\t    {\n+\t      size_t new_vl = *(size_t*)(in + 500);\n+\t      size_t new_vl2 = *(size_t*)(in + 600);\n+\t      vl2 = new_vl + new_vl2 + 777;\n+\t      break;\n+\t    }\n+\t  default:\n+\t    vl2 = 4000;\n+\t    break;\n+\t  }\n+\t  for (size_t i = 0; i < m; i++)\n+\t    {\n+\t      vint8mf8_t v = __riscv_vle8_v_i8mf8 (in + i + 300, vl2);\n+\t      __riscv_vse8_v_i8mf8 (out + i + 300, v, vl2);\n+\t      vint8mf8_t v2 = __riscv_vle8_v_i8mf8_tu (v, in + i + 200, vl2);\n+\t      __riscv_vse8_v_i8mf8 (out + i + 200, v2, vl2);\n+\t    }\n+\t}\n+     Such case may not be necessary to optimize since the codes of defining\n+     vl and vl2 are redundant.  */\n+  return m_source == other.get_source ();\n }\n \n avl_info &\n@@ -1024,11 +1182,6 @@ avl_info::operator== (const avl_info &other) const\n   if (!other.get_value ())\n     return false;\n \n-  /* It's safe to consider they are equal if their RTX value are\n-     strictly the same.  */\n-  if (m_value == other.get_value ())\n-    return true;\n-\n   if (GET_CODE (m_value) != GET_CODE (other.get_value ()))\n     return false;\n \n@@ -1040,10 +1193,6 @@ avl_info::operator== (const avl_info &other) const\n   if (vlmax_avl_p (m_value))\n     return vlmax_avl_p (other.get_value ());\n \n-  /* If Pseudo REGNO are same, it's safe to consider they are same.  */\n-  if (ORIGINAL_REGNO (m_value) == ORIGINAL_REGNO (other.get_value ()))\n-    return true;\n-\n   /* If any source is undef value, we think they are not equal.  */\n   if (!m_source || !other.get_source ())\n     return false;\n@@ -1053,9 +1202,7 @@ avl_info::operator== (const avl_info &other) const\n   if (single_source_equal_p (other))\n     return true;\n \n-  /* TODO: Support avl defined by PHI which includes multiple different insn\n-   * later.  */\n-  return false;\n+  return multiple_source_equal_p (other);\n }\n \n bool\n@@ -1077,7 +1224,7 @@ vl_vtype_info::vl_vtype_info (avl_info avl_in, uint8_t sew_in,\n bool\n vl_vtype_info::operator== (const vl_vtype_info &other) const\n {\n-  return m_avl == other.get_avl_info () && m_sew == other.get_sew ()\n+  return same_avl_p (other) && m_sew == other.get_sew ()\n \t && m_vlmul == other.get_vlmul () && m_ta == other.get_ta ()\n \t && m_ma == other.get_ma () && m_ratio == other.get_ratio ();\n }\n@@ -1101,7 +1248,12 @@ vl_vtype_info::has_non_zero_avl () const\n bool\n vl_vtype_info::same_avl_p (const vl_vtype_info &other) const\n {\n-  return get_avl () == other.get_avl ();\n+  /* We need to compare both RTL and SET. If both AVL are CONST_INT.\n+     For example, const_int 3 and const_int 4, we need to compare\n+     RTL. If both AVL are REG and their REGNO are same, we need to\n+     compare SET.  */\n+  return get_avl () == other.get_avl ()\n+\t && get_avl_source () == other.get_avl_source ();\n }\n \n bool\n@@ -1282,6 +1434,25 @@ vector_insn_info::parse_insn (insn_info *insn)\n     m_demands[DEMAND_TAIL_POLICY] = true;\n   if (get_attr_ma (insn->rtl ()) != INVALID_ATTRIBUTE)\n     m_demands[DEMAND_MASK_POLICY] = true;\n+\n+  if (vector_config_insn_p (insn->rtl ()))\n+    return;\n+\n+  if (!has_avl_reg () || !m_avl.get_source ()\n+      || !m_avl.get_source ()->insn ()->is_phi ())\n+    return;\n+\n+  insn_info *def_insn = extract_single_source (m_avl.get_source ());\n+  if (def_insn)\n+    {\n+      vector_insn_info new_info;\n+      new_info.parse_insn (def_insn);\n+      if (!same_vlmax_p (new_info))\n+\treturn;\n+      /* TODO: Currently, we don't forward AVL for non-VLMAX vsetvl.  */\n+      if (vlmax_avl_p (new_info.get_avl ()))\n+\tset_avl_info (new_info.get_avl_info ());\n+    }\n }\n \n void\n@@ -1395,12 +1566,21 @@ vector_insn_info::compatible_p (const vl_vtype_info &curr_info) const\n   return compatible_avl_p (curr_info) && compatible_vtype_p (curr_info);\n }\n \n+bool\n+vector_insn_info::available_p (const vector_insn_info &other) const\n+{\n+  if (*this >= other)\n+    return true;\n+  return false;\n+}\n+\n vector_insn_info\n vector_insn_info::merge (const vector_insn_info &merge_info,\n \t\t\t enum merge_type type = LOCAL_MERGE) const\n {\n-  gcc_assert (this->compatible_p (merge_info)\n-\t      && \"Can't merge incompatible demanded infos\");\n+  if (!vsetvl_insn_p (get_insn ()->rtl ()))\n+    gcc_assert (this->compatible_p (merge_info)\n+\t\t&& \"Can't merge incompatible demanded infos\");\n \n   vector_insn_info new_info;\n   new_info.demand_vl_vtype ();\n@@ -1512,6 +1692,8 @@ vector_insn_info::dump (FILE *file) const\n     fprintf (file, \"UNKNOWN,\");\n   else if (empty_p ())\n     fprintf (file, \"EMPTY,\");\n+  else if (hard_empty_p ())\n+    fprintf (file, \"HARD_EMPTY,\");\n   else if (dirty_with_killed_avl_p ())\n     fprintf (file, \"DIRTY_WITH_KILLED_AVL,\");\n   else\n@@ -1605,7 +1787,7 @@ vector_infos_manager::get_all_available_exprs (\n {\n   auto_vec<size_t> available_list;\n   for (size_t i = 0; i < vector_exprs.length (); i++)\n-    if (info >= *vector_exprs[i])\n+    if (info.available_p (*vector_exprs[i]))\n       available_list.safe_push (i);\n   return available_list;\n }\n@@ -1861,14 +2043,16 @@ class pass_vsetvl : public rtl_opt_pass\n   /* Phase 3.  */\n   enum fusion_type get_backward_fusion_type (const bb_info *,\n \t\t\t\t\t     const vector_insn_info &);\n+  bool hard_empty_block_p (const bb_info *, const vector_insn_info &) const;\n   bool backward_demand_fusion (void);\n   bool forward_demand_fusion (void);\n+  bool cleanup_illegal_dirty_blocks (void);\n   void demand_fusion (void);\n \n   /* Phase 4.  */\n   void prune_expressions (void);\n   void compute_local_properties (void);\n-  bool can_refine_vsetvl_p (const basic_block, uint8_t) const;\n+  bool can_refine_vsetvl_p (const basic_block, const vector_insn_info &) const;\n   void refine_vsetvls (void) const;\n   void cleanup_vsetvls (void);\n   bool commit_vsetvls (void);\n@@ -1877,6 +2061,9 @@ class pass_vsetvl : public rtl_opt_pass\n   /* Phase 5.  */\n   void cleanup_insns (void) const;\n \n+  /* Phase 6.  */\n+  void propagate_avl (void) const;\n+\n   void init (void);\n   void done (void);\n   void compute_probabilities (void);\n@@ -2078,134 +2265,241 @@ pass_vsetvl::get_backward_fusion_type (const bb_info *bb,\n \n   gcc_assert (reg);\n   def_info *def = find_access (insn->uses (), REGNO (reg))->def ();\n-  if (def->insn ()->is_phi ())\n+  if (!def->insn ()->is_phi () && def->insn ()->bb () == insn->bb ())\n+    return INVALID_FUSION;\n+  hash_set<set_info *> sets\n+    = get_all_sets (prop.get_avl_source (), true, true, true);\n+  if (any_set_in_bb_p (sets, insn->bb ()))\n+    return INVALID_FUSION;\n+\n+  if (vlmax_avl_p (prop.get_avl ()))\n     {\n-      hash_set<insn_info *> insns\n-\t= get_all_nonphi_defs (as_a<phi_info *> (def));\n-      if (any_insn_in_bb_p (insns, insn->bb ()))\n+      if (find_reg_killed_by (bb, reg))\n \treturn INVALID_FUSION;\n+      else\n+\treturn VALID_AVL_FUSION;\n     }\n-  else\n-    {\n-      if (def->insn ()->bb () == insn->bb ())\n-\treturn INVALID_FUSION;\n+\n+  /* By default, we always enable backward fusion so that we can\n+     gain more optimizations.  */\n+  if (!find_reg_killed_by (bb, reg))\n+    return VALID_AVL_FUSION;\n+  return KILLED_AVL_FUSION;\n+}\n+\n+/* We almost enable all cases in get_backward_fusion_type, this function\n+   disable the backward fusion by changing dirty blocks into hard empty\n+   blocks in forward dataflow. We can have more accurate optimization by\n+   this method.  */\n+bool\n+pass_vsetvl::hard_empty_block_p (const bb_info *bb,\n+\t\t\t\t const vector_insn_info &info) const\n+{\n+  if (!info.dirty_p () || !info.has_avl_reg ())\n+    return false;\n+\n+  basic_block cfg_bb = bb->cfg_bb ();\n+  sbitmap avin = m_vector_manager->vector_avin[cfg_bb->index];\n+  rtx avl = vlmax_avl_p (info.get_avl ()) ? get_vl (info.get_insn ()->rtl ())\n+\t\t\t\t\t  : get_avl (info.get_insn ()->rtl ());\n+  insn_info *insn = info.get_insn ();\n+  set_info *set = find_access (insn->uses (), REGNO (avl))->def ();\n+  hash_set<set_info *> sets = get_all_sets (set, true, false, false);\n+  hash_set<basic_block> pred_cfg_bbs = get_all_predecessors (cfg_bb);\n+\n+  if (find_reg_killed_by (bb, avl))\n+    {\n+      /* Condition 1:\n+\t Dirty block with killed AVL means that the empty block (no RVV\n+\t instructions) are polluted as Dirty blocks with the value of current\n+\t AVL is killed. For example:\n+\t      bb 0:\n+\t\t...\n+\t      bb 1:\n+\t\tdef a5\n+\t      bb 2:\n+\t\tRVV (use a5)\n+\t In backward dataflow, we will polluted BB0 and BB1 as Dirt with AVL\n+\t killed. since a5 is killed in BB1.\n+\t In this case, let's take a look at this example:\n+\n+\t      bb 3:        bb 4:\n+\t\tdef3 a5       def4 a5\n+\t      bb 5:        bb 6:\n+\t\tdef1 a5       def2 a5\n+\t\t    \\         /\n+\t\t     \\       /\n+\t\t      \\     /\n+\t\t       \\   /\n+\t\t\tbb 7:\n+\t\t    RVV (use a5)\n+\t In thi case, we can polluted BB5 and BB6 as dirty if get-def\n+\t of a5 from RVV instruction in BB7 is the def1 in BB5 and\n+\t def2 BB6 so we can return false early here for HARD_EMPTY_BLOCK_P.\n+\t However, we are not sure whether BB3 and BB4 can be\n+\t polluted as Dirty with AVL killed so we can't return false\n+\t for HARD_EMPTY_BLOCK_P here since it's too early which will\n+\t potentially produce issues.  */\n+      gcc_assert (info.dirty_with_killed_avl_p ());\n+      if (info.get_avl_source ()\n+\t  && get_same_bb_set (sets, bb->cfg_bb ()) == info.get_avl_source ())\n+\treturn false;\n     }\n \n-  rtx new_reg = gen_rtx_REG (GET_MODE (reg), REGNO (reg));\n-  gcc_assert (new_reg != reg);\n-  const avl_info info = avl_info (new_reg, safe_dyn_cast<set_info *> (def));\n-  if (prop.dirty_with_killed_avl_p ())\n+  /* Condition 2:\n+     Suppress the VL/VTYPE info backward propagation too early:\n+\t\t\t ________\n+\t\t\t|   BB0  |\n+\t\t\t|________|\n+\t\t\t    |\n+\t\t\t____|____\n+\t\t\t|   BB1  |\n+\t\t\t|________|\n+     In this case, suppose BB 1 has multiple predecessors, BB 0 is one\n+     of them. BB1 has VL/VTYPE info (may be VALID or DIRTY) to backward\n+     propagate.\n+     The AVIN (available in) which is calculated by LCM is empty only\n+     in these 2 circumstances:\n+       1. all predecessors of BB1 are empty (not VALID\n+\t  and can not be polluted in backward fusion flow)\n+       2. VL/VTYPE info of BB1 predecessors are conflict.\n+\n+     We keep it as dirty in 2nd circumstance and set it as HARD_EMPTY\n+     (can not be polluted as DIRTY any more) in 1st circumstance.\n+     We don't backward propagate in 1st circumstance since there is\n+     no VALID RVV instruction and no polluted blocks (dirty blocks)\n+     by backward propagation from other following blocks.\n+     It's meaningless to keep it as Dirty anymore.\n+\n+     However, since we keep it as dirty in 2nd since there are VALID or\n+     Dirty blocks in predecessors, we can still gain the benefits and\n+     optimization opportunities. For example, in this case:\n+\tfor (size_t i = 0; i < n; i++)\n+\t {\n+\t   if (i != cond) {\n+\t     vint8mf8_t v = *(vint8mf8_t*)(in + i + 100);\n+\t     *(vint8mf8_t*)(out + i + 100) = v;\n+\t   } else {\n+\t     vbool1_t v = *(vbool1_t*)(in + i + 400);\n+\t     *(vbool1_t*)(out + i + 400) = v;\n+\t   }\n+\t }\n+     VL/VTYPE in if-else are conflict which will produce empty AVIN LCM result\n+     but we can still keep dirty blocks if *(i != cond)* is very unlikely then\n+     we can preset vsetvl (VL/VTYPE) info from else (static propability model).\n+\n+     We don't want to backward propagate VL/VTYPE information too early\n+     which is not the optimal and may potentially produce issues.  */\n+  if (bitmap_empty_p (avin))\n     {\n-      unsigned int bb_index;\n-      sbitmap_iterator sbi;\n-      sbitmap bitdata = m_vector_manager->vector_avout[bb->index ()];\n-      bool has_valid_avl = false;\n-      EXECUTE_IF_SET_IN_BITMAP (bitdata, 0, bb_index, sbi)\n-      {\n-\tconst vector_insn_info *expr = m_vector_manager->vector_exprs[bb_index];\n-\tif (expr->compatible_avl_p (info))\n-\t  {\n-\t    has_valid_avl = true;\n-\t    break;\n-\t  }\n-      }\n-      if (!has_valid_avl)\n-\treturn INVALID_FUSION;\n+      bool hard_empty_p = true;\n+      for (const basic_block pred_cfg_bb : pred_cfg_bbs)\n+\t{\n+\t  if (pred_cfg_bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+\t    continue;\n+\t  sbitmap avout = m_vector_manager->vector_avout[pred_cfg_bb->index];\n+\t  if (!bitmap_empty_p (avout))\n+\t    {\n+\t      hard_empty_p = false;\n+\t      break;\n+\t    }\n+\t}\n+      if (hard_empty_p)\n+\treturn true;\n     }\n \n-  if (reg_killed_by_bb_p (bb, reg))\n+  edge e;\n+  edge_iterator ei;\n+  bool has_avl_killed_insn_p = false;\n+  FOR_EACH_EDGE (e, ei, cfg_bb->succs)\n     {\n-      unsigned int bb_index;\n-      sbitmap_iterator sbi;\n-      sbitmap bitdata = m_vector_manager->vector_avin[bb->index ()];\n-      hash_set<basic_block> blocks = get_all_predecessors (bb->cfg_bb ());\n-      for (const auto block : blocks)\n-\tif (block == insn->bb ()->cfg_bb ())\n-\t  return INVALID_FUSION;\n-      if (bitmap_empty_p (bitdata))\n+      const auto block_info\n+\t= m_vector_manager->vector_block_infos[e->dest->index];\n+      if (block_info.local_dem.dirty_with_killed_avl_p ())\n \t{\n-\t  /* void f (int8_t *restrict in, int8_t *restrict out, int n, int m,\n-\t\t    unsigned cond, size_t vl)\n-\t  {\n-\t    vbool64_t mask = *(vbool64_t *) (in + 1000000);\n-\n-\t    vl = 101;\n-\t    if (cond > 0)\n-\t      {\n-\t      vint8mf8_t v = __riscv_vle8_v_i8mf8 (in, vl);\n-\t      __riscv_vse8_v_i8mf8 (out, v, vl);\n-\t      }\n-\t    else\n-\t      {\n-\t      out[100] = out[100] + 300;\n-\t      }\n-\n-\t    for (size_t i = 0; i < n; i++)\n-\t      {\n-\t      vfloat32mf2_t v = __riscv_vle32_v_f32mf2 ((in + i + 200), vl);\n-\t      __riscv_vse32_v_f32mf2 ((out + i + 200), v, vl);\n+\t  has_avl_killed_insn_p = true;\n+\t  break;\n+\t}\n+    }\n+  if (!has_avl_killed_insn_p)\n+    return false;\n \n-\t      vfloat32mf2_t v2\n-\t\t= __riscv_vle32_v_f32mf2_tumu (mask, v, (in + i + 300), vl);\n-\t      __riscv_vse32_v_f32mf2_m (mask, (out + i + 300), v2, vl);\n-\t      }\n-\t  }  */\n-\t  for (const auto block : blocks)\n+  bool any_set_in_bbs_p = false;\n+  for (const basic_block pred_cfg_bb : pred_cfg_bbs)\n+    {\n+      insn_info *def_insn = extract_single_source (set);\n+      if (def_insn)\n+\t{\n+\t  /* Condition 3:\n+\n+\t    Case 1:                               Case 2:\n+\t\tbb 0:                                 bb 0:\n+\t\t  def a5 101                             ...\n+\t\tbb 1:                                 bb 1:\n+\t\t  ...                                    ...\n+\t\tbb 2:                                 bb 2:\n+\t\t  RVV 1 (use a5 with TAIL ANY)           ...\n+\t\tbb 3:                                 bb 3:\n+\t\t  def a5 101                             def a5 101\n+\t\tbb 4:                                 bb 4:\n+\t\t  ...                                    ...\n+\t\tbb 5:                                 bb 5:\n+\t\t  RVV 2 (use a5 with TU)                 RVV 1 (use a5)\n+\n+\t    Case 1: We can pollute BB3,BB2,BB1,BB0 are all Dirt blocks\n+\t    with killed AVL so that we can merge TU demand info from RVV 2\n+\t    into RVV 1 and elide the vsevl instruction in BB5.\n+\n+\t    TODO: We only optimize for single source def since multiple source\n+\t    def is quite complicated.\n+\n+\t    Case 2: We only can pollute bb 3 as dirty and it has been accepted\n+\t    in Condition 2 and we can't pollute BB3,BB2,BB1,BB0 like case 1. */\n+\t  insn_info *last_killed_insn\n+\t    = find_reg_killed_by (crtl->ssa->bb (pred_cfg_bb), avl);\n+\t  if (!last_killed_insn || pred_cfg_bb == def_insn->bb ()->cfg_bb ())\n+\t    continue;\n+\t  if (source_equal_p (last_killed_insn, def_insn))\n \t    {\n-\t      if (block == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n-\t\tcontinue;\n-\t      sbitmap avout = m_vector_manager->vector_avout[block->index];\n-\t      EXECUTE_IF_SET_IN_BITMAP (avout, 0, bb_index, sbi)\n-\t      {\n-\t\tconst vector_insn_info *expr\n-\t\t  = m_vector_manager->vector_exprs[bb_index];\n-\t\tif (expr->compatible_avl_p (info))\n-\t\t  return KILLED_AVL_FUSION;\n-\t      }\n+\t      any_set_in_bbs_p = true;\n+\t      break;\n \t    }\n-\t  return INVALID_FUSION;\n \t}\n       else\n \t{\n-\t  /* void f (int8_t * restrict in, int8_t * restrict out, int n, int\n-\t      m, unsigned cond, size_t vl)\n-\t      {\n-\t\tvbool64_t mask = *(vbool64_t *) (in + 1000000);\n-\n-\t\tvl = 101;\n-\t\tif (cond > 0)\n-\t\t  {\n-\t\t  vint8mf8_t v = __riscv_vle8_v_i8mf8 (in, vl);\n-\t\t  __riscv_vse8_v_i8mf8 (out, v, vl);\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t  vint8mf8_t v = __riscv_vle8_v_i8mf8 (in + 1000, vl);\n-\t\t  __riscv_vse8_v_i8mf8 (out + 1000, v, vl);\n-\t\t  }\n-\n-\t\tfor (size_t i = 0; i < n; i++)\n-\t\t  {\n-\t\t  vfloat32mf2_t v = __riscv_vle32_v_f32mf2 ((in + i + 200), vl);\n-\t\t  __riscv_vse32_v_f32mf2 ((out + i + 200), v, vl);\n-\n-\t\t  vfloat32mf2_t v2\n-\t\t    = __riscv_vle32_v_f32mf2_tumu (mask, v, (in + i + 300), vl);\n-\t\t  __riscv_vse32_v_f32mf2_m (mask, (out + i + 300), v2, vl);\n-\t\t  }\n-\t  }  */\n-\t  EXECUTE_IF_SET_IN_BITMAP (bitdata, 0, bb_index, sbi)\n-\t  {\n-\t    const vector_insn_info *expr\n-\t      = m_vector_manager->vector_exprs[bb_index];\n-\t    if (expr->compatible_avl_p (info))\n-\t      return KILLED_AVL_FUSION;\n-\t  }\n+\t  /* Condition 4:\n+\n+\t      bb 0:        bb 1:         bb 3:\n+\t\tdef1 a5       def2 a5     ...\n+\t\t    \\         /            /\n+\t\t     \\       /            /\n+\t\t      \\     /            /\n+\t\t       \\   /            /\n+\t\t\tbb 4:          /\n+\t\t\t |            /\n+\t\t\t |           /\n+\t\t\tbb 5:       /\n+\t\t\t |         /\n+\t\t\t |        /\n+\t\t\tbb 6:    /\n+\t\t\t |      /\n+\t\t\t |     /\n+\t\t\t  bb 8:\n+\t\t\tRVV 1 (use a5)\n+\t  If we get-def (REAL) of a5 from RVV 1 instruction, we will get\n+\t  def1 from BB0 and def2 from BB1. So we will pollute BB6,BB5,BB4,\n+\t  BB0,BB1 with DIRTY and set BB3 as HARD_EMPTY so that we won't\n+\t  propagate AVL to BB3.  */\n+\t  if (any_set_in_bb_p (sets, crtl->ssa->bb (pred_cfg_bb)))\n+\t    {\n+\t      any_set_in_bbs_p = true;\n+\t      break;\n+\t    }\n \t}\n-      return INVALID_FUSION;\n     }\n-\n-  return prop.dirty_with_killed_avl_p () ? KILLED_AVL_FUSION : VALID_AVL_FUSION;\n+  if (!any_set_in_bbs_p)\n+    return true;\n+  return false;\n }\n \n /* Compute global backward demanded info.  */\n@@ -2268,6 +2562,8 @@ pass_vsetvl::backward_demand_fusion (void)\n \n \t  if (block_info.reaching_out.unknown_p ())\n \t    continue;\n+\t  else if (block_info.reaching_out.hard_empty_p ())\n+\t    continue;\n \t  else if (block_info.reaching_out.empty_p ())\n \t    {\n \t      enum fusion_type type\n@@ -2277,6 +2573,17 @@ pass_vsetvl::backward_demand_fusion (void)\n \n \t      block_info.reaching_out = prop;\n \t      block_info.reaching_out.set_dirty (type);\n+\n+\t      if (prop.has_avl_reg () && !vlmax_avl_p (prop.get_avl ()))\n+\t\t{\n+\t\t  hash_set<set_info *> sets\n+\t\t    = get_all_sets (prop.get_avl_source (), true, true, true);\n+\t\t  set_info *set = get_same_bb_set (sets, e->src);\n+\t\t  if (set)\n+\t\t    block_info.reaching_out.set_avl_info (\n+\t\t      avl_info (prop.get_avl (), set));\n+\t\t}\n+\n \t      block_info.local_dem = block_info.reaching_out;\n \t      block_info.probability = curr_block_info.probability;\n \t      changed_p = true;\n@@ -2290,22 +2597,28 @@ pass_vsetvl::backward_demand_fusion (void)\n \t\t{\n \t\t  if (block_info.reaching_out >= prop)\n \t\t    continue;\n-\t\t  block_info.probability += curr_block_info.probability;\n \t\t  new_info = block_info.reaching_out.merge (prop, GLOBAL_MERGE);\n+\t\t  new_info.set_dirty (\n+\t\t    block_info.reaching_out.dirty_with_killed_avl_p ());\n+\t\t  block_info.probability += curr_block_info.probability;\n \t\t}\n \t      else\n \t\t{\n \t\t  if (curr_block_info.probability > block_info.probability)\n \t\t    {\n+\t\t      enum fusion_type type\n+\t\t\t= get_backward_fusion_type (crtl->ssa->bb (e->src),\n+\t\t\t\t\t\t    prop);\n+\t\t      if (type == INVALID_FUSION)\n+\t\t\tcontinue;\n \t\t      new_info = prop;\n+\t\t      new_info.set_dirty (type);\n \t\t      block_info.probability = curr_block_info.probability;\n \t\t    }\n \t\t  else\n \t\t    continue;\n \t\t}\n \n-\t      new_info.set_dirty (\n-\t\tblock_info.reaching_out.dirty_with_killed_avl_p ());\n \t      block_info.local_dem = new_info;\n \t      block_info.reaching_out = new_info;\n \t      changed_p = true;\n@@ -2315,10 +2628,28 @@ pass_vsetvl::backward_demand_fusion (void)\n \t      /* We not only change the info during backward propagation,\n \t\t but also change the VSETVL instruction.  */\n \t      gcc_assert (block_info.reaching_out.valid_p ());\n-\t      if (!block_info.reaching_out.compatible_p (prop))\n-\t\tcontinue;\n-\t      if (block_info.reaching_out >= prop)\n-\t\tcontinue;\n+\t      hash_set<set_info *> sets\n+\t\t= get_all_sets (prop.get_avl_source (), true, false, false);\n+\t      set_info *set = get_same_bb_set (sets, e->src);\n+\t      if (vsetvl_insn_p (block_info.reaching_out.get_insn ()->rtl ())\n+\t\t  && prop.has_avl_reg () && !vlmax_avl_p (prop.get_avl ()))\n+\t\t{\n+\t\t  if (!block_info.reaching_out.same_vlmax_p (prop))\n+\t\t    continue;\n+\t\t  if (block_info.reaching_out.same_vtype_p (prop))\n+\t\t    continue;\n+\t\t  if (!set)\n+\t\t    continue;\n+\t\t  if (set->insn () != block_info.reaching_out.get_insn ())\n+\t\t    continue;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (!block_info.reaching_out.compatible_p (prop))\n+\t\t    continue;\n+\t\t  if (block_info.reaching_out >= prop)\n+\t\t    continue;\n+\t\t}\n \n \t      vector_insn_info be_merged = block_info.reaching_out;\n \t      if (block_info.local_dem == block_info.reaching_out)\n@@ -2406,8 +2737,8 @@ pass_vsetvl::forward_demand_fusion (void)\n \t  if (local_dem.dirty_p ())\n \t    {\n \t      gcc_assert (local_dem == reaching_out);\n+\t      new_info.set_dirty (local_dem.dirty_with_killed_avl_p ());\n \t      local_dem = new_info;\n-\t      local_dem.set_dirty (local_dem.dirty_with_killed_avl_p ());\n \t      reaching_out = local_dem;\n \t    }\n \t  else\n@@ -2435,9 +2766,6 @@ pass_vsetvl::demand_fusion (void)\n   while (changed_p)\n     {\n       changed_p = false;\n-      prune_expressions ();\n-      m_vector_manager->create_bitmap_vectors ();\n-      compute_local_properties ();\n       /* To optimize the case like this:\n \t void f2 (int8_t * restrict in, int8_t * restrict out, int n, int cond)\n \t   {\n@@ -2471,12 +2799,22 @@ pass_vsetvl::demand_fusion (void)\n \tan AVL kill instruction in bb 2 that we can't backward fuse bb 3 or\n \tforward bb 1 arbitrarily. We need available information of each block to\n \thelp for such cases.  */\n+      changed_p |= backward_demand_fusion ();\n+      changed_p |= forward_demand_fusion ();\n+    }\n+\n+  changed_p = true;\n+  while (changed_p)\n+    {\n+      changed_p = false;\n+      prune_expressions ();\n+      m_vector_manager->create_bitmap_vectors ();\n+      compute_local_properties ();\n       compute_available (m_vector_manager->vector_comp,\n \t\t\t m_vector_manager->vector_kill,\n \t\t\t m_vector_manager->vector_avout,\n \t\t\t m_vector_manager->vector_avin);\n-      changed_p |= backward_demand_fusion ();\n-      changed_p |= forward_demand_fusion ();\n+      changed_p |= cleanup_illegal_dirty_blocks ();\n       m_vector_manager->free_bitmap_vectors ();\n       if (!m_vector_manager->vector_exprs.is_empty ())\n \tm_vector_manager->vector_exprs.release ();\n@@ -2493,6 +2831,34 @@ pass_vsetvl::demand_fusion (void)\n     }\n }\n \n+/* Cleanup illegal dirty blocks.  */\n+bool\n+pass_vsetvl::cleanup_illegal_dirty_blocks (void)\n+{\n+  bool changed_p = false;\n+  for (const bb_info *bb : crtl->ssa->bbs ())\n+    {\n+      basic_block cfg_bb = bb->cfg_bb ();\n+      const auto &prop\n+\t= m_vector_manager->vector_block_infos[cfg_bb->index].reaching_out;\n+\n+      /* If there is nothing to cleanup, just skip it.  */\n+      if (!prop.valid_or_dirty_p ())\n+\tcontinue;\n+\n+      if (hard_empty_block_p (bb, prop))\n+\t{\n+\t  m_vector_manager->vector_block_infos[cfg_bb->index].local_dem\n+\t    = vector_insn_info::get_hard_empty ();\n+\t  m_vector_manager->vector_block_infos[cfg_bb->index].reaching_out\n+\t    = vector_insn_info::get_hard_empty ();\n+\t  changed_p = true;\n+\t  continue;\n+\t}\n+    }\n+  return changed_p;\n+}\n+\n /* Assemble the candidates expressions for LCM.  */\n void\n pass_vsetvl::prune_expressions (void)\n@@ -2608,18 +2974,20 @@ pass_vsetvl::compute_local_properties (void)\n \t     as long as the all real def insn of avl do not come from this\n \t     block. This configuration may be still missing some optimization\n \t     opportunities.  */\n-\t  if (reg_killed_by_bb_p (bb, expr->get_avl ()))\n+\t  if (find_reg_killed_by (bb, expr->get_avl ()))\n \t    {\n-\t      hash_set<insn_info *> insns = get_all_nonphi_defs (\n-\t\tsafe_dyn_cast<phi_info *> (expr->get_avl_source ()));\n-\t      if (any_insn_in_bb_p (insns, bb))\n+\t      hash_set<set_info *> sets\n+\t\t= get_all_sets (expr->get_avl_source (), true, false, false);\n+\t      if (any_set_in_bb_p (sets, bb))\n \t\tbitmap_clear_bit (m_vector_manager->vector_transp[curr_bb_idx],\n \t\t\t\t  i);\n \t    }\n \t}\n \n       /* Compute anticipatable occurrences.  */\n-      if (local_dem.valid_p () || local_dem.real_dirty_p ())\n+      if (local_dem.valid_p () || local_dem.real_dirty_p ()\n+\t  || (has_vsetvl_killed_avl_p (bb, local_dem)\n+\t      && vlmax_avl_p (local_dem.get_avl ())))\n \tif (anticipatable_occurrence_p (bb, local_dem))\n \t  bitmap_set_bit (m_vector_manager->vector_antic[curr_bb_idx],\n \t\t\t  m_vector_manager->get_expr_id (local_dem));\n@@ -2687,7 +3055,8 @@ pass_vsetvl::compute_local_properties (void)\n \n /* Return true if VSETVL in the block can be refined as vsetvl zero,zero.  */\n bool\n-pass_vsetvl::can_refine_vsetvl_p (const basic_block cfg_bb, uint8_t ratio) const\n+pass_vsetvl::can_refine_vsetvl_p (const basic_block cfg_bb,\n+\t\t\t\t  const vector_insn_info &info) const\n {\n   if (!m_vector_manager->all_same_ratio_p (\n \tm_vector_manager->vector_avin[cfg_bb->index]))\n@@ -2699,7 +3068,9 @@ pass_vsetvl::can_refine_vsetvl_p (const basic_block cfg_bb, uint8_t ratio) const\n \n   size_t expr_id\n     = bitmap_first_set_bit (m_vector_manager->vector_avin[cfg_bb->index]);\n-  if (m_vector_manager->vector_exprs[expr_id]->get_ratio () != ratio)\n+  if (!m_vector_manager->vector_exprs[expr_id]->same_vlmax_p (info))\n+    return false;\n+  if (!m_vector_manager->vector_exprs[expr_id]->compatible_avl_p (info))\n     return false;\n \n   edge e;\n@@ -2742,7 +3113,7 @@ pass_vsetvl::refine_vsetvls (void) const\n \tcontinue;\n \n       rtx_insn *rinsn = insn->rtl ();\n-      if (!can_refine_vsetvl_p (cfg_bb, info.get_ratio ()))\n+      if (!can_refine_vsetvl_p (cfg_bb, info))\n \tcontinue;\n \n       if (!vector_config_insn_p (rinsn))\n@@ -2865,7 +3236,7 @@ pass_vsetvl::commit_vsetvls (void)\n \t}\n \n       rtx new_pat;\n-      if (can_refine_vsetvl_p (cfg_bb, reaching_out.get_ratio ()))\n+      if (can_refine_vsetvl_p (cfg_bb, reaching_out))\n \tnew_pat\n \t  = gen_vsetvl_pat (VSETVL_VTYPE_CHANGE_ONLY, reaching_out, NULL_RTX);\n       else if (vlmax_avl_p (reaching_out.get_avl ()))\n@@ -2959,6 +3330,115 @@ pass_vsetvl::cleanup_insns (void) const\n     }\n }\n \n+void\n+pass_vsetvl::propagate_avl (void) const\n+{\n+  /* Rebuild the RTL_SSA according to the new CFG generated by LCM.  */\n+  /* Finalization of RTL_SSA.  */\n+  free_dominance_info (CDI_DOMINATORS);\n+  if (crtl->ssa->perform_pending_updates ())\n+    cleanup_cfg (0);\n+  delete crtl->ssa;\n+  crtl->ssa = nullptr;\n+  /* Initialization of RTL_SSA.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  df_analyze ();\n+  crtl->ssa = new function_info (cfun);\n+\n+  hash_set<rtx_insn *> to_delete;\n+  for (const bb_info *bb : crtl->ssa->bbs ())\n+    {\n+      for (insn_info *insn : bb->real_nondebug_insns ())\n+\t{\n+\t  if (vsetvl_discard_result_insn_p (insn->rtl ()))\n+\t    {\n+\t      rtx avl = get_avl (insn->rtl ());\n+\t      if (!REG_P (avl))\n+\t\tcontinue;\n+\n+\t      set_info *set = find_access (insn->uses (), REGNO (avl))->def ();\n+\t      insn_info *def_insn = extract_single_source (set);\n+\t      if (!def_insn)\n+\t\tcontinue;\n+\n+\t      /* Handle this case:\n+\t\t vsetvli\ta6,zero,e32,m1,ta,mu\n+\t\t li\ta5,4096\n+\t\t add\ta7,a0,a5\n+\t\t addi\ta7,a7,-96\n+\t\t vsetvli\tt1,zero,e8,mf8,ta,ma\n+\t\t vle8.v\tv24,0(a7)\n+\t\t add\ta5,a3,a5\n+\t\t addi\ta5,a5,-96\n+\t\t vse8.v\tv24,0(a5)\n+\t\t vsetvli\tzero,a6,e32,m1,tu,ma\n+\t      */\n+\t      if (vsetvl_insn_p (def_insn->rtl ()))\n+\t\t{\n+\t\t  vl_vtype_info def_info = get_vl_vtype_info (def_insn);\n+\t\t  vl_vtype_info info = get_vl_vtype_info (insn);\n+\t\t  rtx avl = get_avl (def_insn->rtl ());\n+\t\t  rtx vl = get_vl (def_insn->rtl ());\n+\t\t  if (def_info.get_ratio () == info.get_ratio ())\n+\t\t    {\n+\t\t      if (vlmax_avl_p (def_info.get_avl ()))\n+\t\t\t{\n+\t\t\t  info.set_avl_info (\n+\t\t\t    avl_info (def_info.get_avl (), nullptr));\n+\t\t\t  rtx new_pat\n+\t\t\t    = gen_vsetvl_pat (VSETVL_NORMAL, info, vl);\n+\t\t\t  validate_change (insn->rtl (),\n+\t\t\t\t\t   &PATTERN (insn->rtl ()), new_pat,\n+\t\t\t\t\t   false);\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t      if (def_info.has_avl_imm () || rtx_equal_p (avl, vl))\n+\t\t\t{\n+\t\t\t  info.set_avl_info (avl_info (avl, nullptr));\n+\t\t\t  emit_vsetvl_insn (VSETVL_DISCARD_RESULT, EMIT_AFTER,\n+\t\t\t\t\t    info, NULL_RTX, insn->rtl ());\n+\t\t\t  if (set->single_nondebug_insn_use ())\n+\t\t\t    {\n+\t\t\t      to_delete.add (insn->rtl ());\n+\t\t\t      to_delete.add (def_insn->rtl ());\n+\t\t\t    }\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  /* Change vsetvl rd, rs1 --> vsevl zero, rs1,\n+\t     if rd is not used by any nondebug instructions.\n+\t     Even though this PASS runs after RA and it doesn't help for\n+\t     reduce register pressure, it can help instructions scheduling\n+\t     since we remove the dependencies.  */\n+\t  if (vsetvl_insn_p (insn->rtl ()))\n+\t    {\n+\t      rtx vl = get_vl (insn->rtl ());\n+\t      rtx avl = get_avl (insn->rtl ());\n+\t      if (vlmax_avl_p (avl))\n+\t\tcontinue;\n+\t      def_info *def = find_access (insn->defs (), REGNO (vl));\n+\t      set_info *set = safe_dyn_cast<set_info *> (def);\n+\t      gcc_assert (set);\n+\t      const vl_vtype_info info = get_vl_vtype_info (insn);\n+\t      rtx new_pat\n+\t\t= gen_vsetvl_pat (VSETVL_DISCARD_RESULT, info, NULL_RTX);\n+\t      if (!set->has_nondebug_insn_uses ())\n+\t\t{\n+\t\t  validate_change (insn->rtl (), &PATTERN (insn->rtl ()),\n+\t\t\t\t   new_pat, false);\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  for (rtx_insn *rinsn : to_delete)\n+    eliminate_insn (rinsn);\n+}\n+\n void\n pass_vsetvl::init (void)\n {\n@@ -3077,6 +3557,12 @@ pass_vsetvl::lazy_vsetvl (void)\n   if (dump_file)\n     fprintf (dump_file, \"\\nPhase 5: Cleanup AVL and VL operands\\n\");\n   cleanup_insns ();\n+\n+  /* Phase 6 - Rebuild RTL_SSA to propagate AVL between vsetvls.  */\n+  if (dump_file)\n+    fprintf (dump_file,\n+\t     \"\\nPhase 6: Rebuild RTL_SSA to propagate AVL between vsetvls\\n\");\n+  propagate_avl ();\n }\n \n /* Main entry point for this pass.  */"}, {"sha": "09df4695518305a948cb54c201ec318f05c890ed", "filename": "gcc/config/riscv/riscv-vsetvl.h", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6b9c680bc43c19b24a2e01ddc99f2c061e0511/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6b9c680bc43c19b24a2e01ddc99f2c061e0511/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vsetvl.h?ref=6b6b9c680bc43c19b24a2e01ddc99f2c061e0511", "patch": "@@ -65,6 +65,21 @@ enum merge_type\n   GLOBAL_MERGE\n };\n \n+enum def_type\n+{\n+  REAL_SET = 1 << 0,\n+  PHI_SET = 1 << 1,\n+  BB_HEAD_SET = 1 << 2,\n+  BB_END_SET = 1 << 3,\n+  /* ??? TODO: In RTL_SSA framework, we have REAL_SET,\n+     PHI_SET, BB_HEAD_SET, BB_END_SET and\n+     CLOBBER_DEF def_info types. Currently,\n+     we conservatively do not optimize clobber\n+     def since we don't see the case that we\n+     need to optimize it.  */\n+  CLOBBER_DEF = 1 << 4\n+};\n+\n /* AVL info for RVV instruction. Most RVV instructions have AVL operand in\n    implicit dependency. The AVL comparison between 2 RVV instructions is\n    very important since it affects our decision whether we should insert\n@@ -143,6 +158,7 @@ class avl_info\n   rtx get_value () const { return m_value; }\n   rtl_ssa::set_info *get_source () const { return m_source; }\n   bool single_source_equal_p (const avl_info &) const;\n+  bool multiple_source_equal_p (const avl_info &) const;\n   avl_info &operator= (const avl_info &);\n   bool operator== (const avl_info &) const;\n   bool operator!= (const avl_info &) const;\n@@ -210,6 +226,8 @@ class vector_insn_info : public vl_vtype_info\n     VALID,\n     UNKNOWN,\n     EMPTY,\n+    /* The empty block can not be polluted as dirty.  */\n+    HARD_EMPTY,\n \n     /* The block is polluted as containing VSETVL instruction during dem\n        backward propagation to gain better LCM optimization even though\n@@ -280,7 +298,8 @@ class vector_insn_info : public vl_vtype_info\n   bool uninit_p () const { return m_state == UNINITIALIZED; }\n   bool valid_p () const { return m_state == VALID; }\n   bool unknown_p () const { return m_state == UNKNOWN; }\n-  bool empty_p () const { return m_state == EMPTY; }\n+  bool empty_p () const { return m_state == EMPTY || m_state == HARD_EMPTY; }\n+  bool hard_empty_p () const { return m_state == HARD_EMPTY; }\n   bool dirty_p () const\n   {\n     return m_state == DIRTY || m_state == DIRTY_WITH_KILLED_AVL;\n@@ -295,6 +314,7 @@ class vector_insn_info : public vl_vtype_info\n     return m_state == VALID || m_state == DIRTY\n \t   || m_state == DIRTY_WITH_KILLED_AVL;\n   }\n+  bool available_p (const vector_insn_info &) const;\n \n   static vector_insn_info get_unknown ()\n   {\n@@ -303,9 +323,17 @@ class vector_insn_info : public vl_vtype_info\n     return info;\n   }\n \n+  static vector_insn_info get_hard_empty ()\n+  {\n+    vector_insn_info info;\n+    info.set_hard_empty ();\n+    return info;\n+  }\n+\n   void set_valid () { m_state = VALID; }\n   void set_unknown () { m_state = UNKNOWN; }\n   void set_empty () { m_state = EMPTY; }\n+  void set_hard_empty () { m_state = HARD_EMPTY; }\n   void set_dirty (enum fusion_type type)\n   {\n     gcc_assert (type == VALID_AVL_FUSION || type == KILLED_AVL_FUSION);"}]}