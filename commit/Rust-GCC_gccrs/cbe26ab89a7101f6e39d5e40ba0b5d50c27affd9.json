{"sha": "cbe26ab89a7101f6e39d5e40ba0b5d50c27affd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JlMjZhYjg5YTcxMDFmNmUzOWQ1ZTQwYmEwYjVkNTBjMjdhZmZkOQ==", "commit": {"author": {"name": "Dorit Naishlos", "email": "dorit@il.ibm.com", "date": "2003-10-20T15:36:19Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2003-10-20T15:36:19Z"}, "message": "rs6000.h: (rs6000_sched_insert_nops): support new flag -minsert-sched-nops.\n\n\n        * config/rs6000/rs6000.h: (rs6000_sched_insert_nops):\n        support new flag -minsert-sched-nops.\n        (DEFAULT_SCHED_FINISH_NOP_INSERTION_SCHEME): Define.\n        * config/rs6000/rs6000.c: (rs6000_sched_insert_nops):\n        support new flag -minsert-sched-nops.\n        (is_cracked_insn, is_microcoded_insn): New functions.\n        (rs6000_sched_finish): New function.\n        (rs6000_issue_rate): Return 5 for power4.\n        (get_next_active_insn, insn_terminates_group_p): New\n        functions.\n        (is_costly_group, force_new_group): New functions.\n        (redefine_groups, pad_groups): New functions.\n        (rs6000_variable_issue): Use new functions.\n        * doc/invoke.texi (-minsert-sched-nops): Document new\n        option.\n\nFrom-SVN: r72707", "tree": {"sha": "af6c71aa4ff6785fe2bd30618d1b7b973850084d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af6c71aa4ff6785fe2bd30618d1b7b973850084d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbe26ab89a7101f6e39d5e40ba0b5d50c27affd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbe26ab89a7101f6e39d5e40ba0b5d50c27affd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbe26ab89a7101f6e39d5e40ba0b5d50c27affd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbe26ab89a7101f6e39d5e40ba0b5d50c27affd9/comments", "author": null, "committer": null, "parents": [{"sha": "8d36c4999a10bf225ae5edf44a53f2cae2051922", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d36c4999a10bf225ae5edf44a53f2cae2051922", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d36c4999a10bf225ae5edf44a53f2cae2051922"}], "stats": {"total": 618, "additions": 596, "deletions": 22}, "files": [{"sha": "46406b51b5d3e294ba0d7b3173e4e62e0842ac2f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe26ab89a7101f6e39d5e40ba0b5d50c27affd9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe26ab89a7101f6e39d5e40ba0b5d50c27affd9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cbe26ab89a7101f6e39d5e40ba0b5d50c27affd9", "patch": "@@ -1,3 +1,21 @@\n+2003-10-20  Dorit Naishlos  <dorit@il.ibm.com>\n+\n+\t* config/rs6000/rs6000.h: (rs6000_sched_insert_nops): \t\n+\tsupport new flag -minsert-sched-nops.\n+\t(DEFAULT_SCHED_FINISH_NOP_INSERTION_SCHEME): Define.\n+\t* config/rs6000/rs6000.c: (rs6000_sched_insert_nops): \t\n+\tsupport new flag -minsert-sched-nops.\t\n+\t(is_cracked_insn, is_microcoded_insn): New functions.\n+\t(rs6000_sched_finish): New function.\n+\t(rs6000_issue_rate): Return 5 for power4.\n+\t(get_next_active_insn, insn_terminates_group_p): New \t\n+\tfunctions.\n+\t(is_costly_group, force_new_group): New functions.\n+\t(redefine_groups, pad_groups): New functions.\n+\t(rs6000_variable_issue): Use new functions.\n+\t* doc/invoke.texi (-minsert-sched-nops): Document new\n+\toption.\n+\n 2003-10-20  David S. Miller  <davem@redhat.com>\n \n \t* config/sparc/sparc.md (type attribute): Add new insn types"}, {"sha": "16807751539b49bc2db72c5d549c93ae2b42fabb", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 538, "deletions": 21, "changes": 559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe26ab89a7101f6e39d5e40ba0b5d50c27affd9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe26ab89a7101f6e39d5e40ba0b5d50c27affd9/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=cbe26ab89a7101f6e39d5e40ba0b5d50c27affd9", "patch": "@@ -90,6 +90,10 @@ int rs6000_sched_restricted_insns_priority;\n const char *rs6000_sched_costly_dep_str;\n enum rs6000_dependence_cost rs6000_sched_costly_dep;\n \n+/* Support for -minsert-sched-nops option.  */\n+const char *rs6000_sched_insert_nops_str;\n+enum rs6000_nop_insertion rs6000_sched_insert_nops;\n+\n /* Size of long double */\n const char *rs6000_long_double_size_string;\n int rs6000_long_double_type_size;\n@@ -279,10 +283,20 @@ static int rs6000_use_dfa_pipeline_interface (void);\n static int rs6000_variable_issue (FILE *, int, rtx, int);\n static bool rs6000_rtx_costs (rtx, int, int, int *);\n static int rs6000_adjust_cost (rtx, rtx, rtx, int);\n+static bool is_microcoded_insn (rtx);\n static int is_dispatch_slot_restricted (rtx);\n+static bool is_cracked_insn (rtx);\n+static bool is_branch_slot_insn (rtx);\n static int rs6000_adjust_priority (rtx, int);\n static int rs6000_issue_rate (void);\n static bool rs6000_is_costly_dependence (rtx, rtx, rtx, int, int);\n+static rtx get_next_active_insn (rtx, rtx);\n+static bool insn_terminates_group_p (rtx , enum group_termination);\n+static bool is_costly_group (rtx *, rtx);\n+static int force_new_group (int, FILE *, rtx *, rtx, bool *, int, int *);\n+static int redefine_groups (FILE *, int, rtx, rtx);\n+static int pad_groups (FILE *, int, rtx, rtx);\n+static void rs6000_sched_finish (FILE *, int);\n static int rs6000_use_sched_lookahead (void);\n \n static void rs6000_init_builtins (void);\n@@ -477,6 +491,8 @@ static const char alt_reg_names[][8] =\n #define TARGET_SCHED_ADJUST_PRIORITY rs6000_adjust_priority\n #undef TARGET_SCHED_IS_COSTLY_DEPENDENCE      \n #define TARGET_SCHED_IS_COSTLY_DEPENDENCE rs6000_is_costly_dependence\n+#undef TARGET_SCHED_FINISH\n+#define TARGET_SCHED_FINISH rs6000_sched_finish\n \n #undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD rs6000_use_sched_lookahead\n@@ -866,7 +882,7 @@ rs6000_override_options (const char *default_cpu)\n       rs6000_default_long_calls = (base[0] != 'n');\n     }\n \n-  /* Handle -mprioritize-restrcted-insns option.  */\n+  /* Handle -mprioritize-restricted-insns option.  */\n   rs6000_sched_restricted_insns_priority = DEFAULT_RESTRICTED_INSNS_PRIORITY;\n   if (rs6000_sched_restricted_insns_priority_str)\n     rs6000_sched_restricted_insns_priority =\n@@ -884,7 +900,22 @@ rs6000_override_options (const char *default_cpu)\n         rs6000_sched_costly_dep = true_store_to_load_dep_costly;\n       else if (! strcmp (rs6000_sched_costly_dep_str, \"store_to_load\"))\n         rs6000_sched_costly_dep = store_to_load_dep_costly;\n-      else rs6000_sched_costly_dep = atoi (rs6000_sched_costly_dep_str);\n+      else \n+        rs6000_sched_costly_dep = atoi (rs6000_sched_costly_dep_str);\n+    }\n+\n+  /* Handle -minsert-sched-nops option.  */\n+  rs6000_sched_insert_nops = DEFAULT_SCHED_FINISH_NOP_INSERTION_SCHEME;\n+  if (rs6000_sched_insert_nops_str)\n+    {\n+      if (! strcmp (rs6000_sched_insert_nops_str, \"no\"))\n+        rs6000_sched_insert_nops = sched_finish_none;\n+      else if (! strcmp (rs6000_sched_insert_nops_str, \"pad\"))\n+        rs6000_sched_insert_nops = sched_finish_pad_groups;\n+      else if (! strcmp (rs6000_sched_insert_nops_str, \"regroup_exact\"))\n+        rs6000_sched_insert_nops = sched_finish_regroup_exact;\n+      else\n+        rs6000_sched_insert_nops = atoi (rs6000_sched_insert_nops_str);\n     }\n \n #ifdef TARGET_REGNAMES\n@@ -13241,20 +13272,10 @@ rs6000_variable_issue (FILE *stream ATTRIBUTE_UNUSED,\n \n   if (rs6000_cpu == PROCESSOR_POWER4)\n     {\n-      enum attr_type type = get_attr_type (insn);\n-      if (type == TYPE_LOAD_EXT_U || type == TYPE_LOAD_EXT_UX\n-\t  || type == TYPE_LOAD_UX || type == TYPE_STORE_UX\n-\t  || type == TYPE_MFCR)\n-\treturn 0;\n-      else if (type == TYPE_LOAD_U || type == TYPE_STORE_U\n-\t       || type == TYPE_FPLOAD_U || type == TYPE_FPSTORE_U\n-\t       || type == TYPE_FPLOAD_UX || type == TYPE_FPSTORE_UX\n-\t       || type == TYPE_LOAD_EXT || type == TYPE_DELAYED_CR\n-\t       || type == TYPE_COMPARE || type == TYPE_DELAYED_COMPARE\n-\t       || type == TYPE_IMUL_COMPARE || type == TYPE_LMUL_COMPARE\n-\t       || type == TYPE_IDIV || type == TYPE_LDIV\n-\t       || type == TYPE_INSERT_WORD)\n-\treturn more > 2 ? more - 2 : 0;\n+      if (is_microcoded_insn (insn))\n+        return 0;\n+      else if (is_cracked_insn (insn))\n+        return more > 2 ? more - 2 : 0;\n     }\n \n   return more - 1;\n@@ -13318,13 +13339,38 @@ rs6000_adjust_cost (rtx insn, rtx link, rtx dep_insn ATTRIBUTE_UNUSED,\n   return cost;\n }\n \n+/* The function returns a true if INSN is microcoded.\n+   Return false ptherwise.  */\n+\n+static bool\n+is_microcoded_insn (rtx insn)\n+{\n+  if (!insn || !INSN_P (insn)\n+      || GET_CODE (PATTERN (insn)) == USE\n+      || GET_CODE (PATTERN (insn)) == CLOBBER)\n+    return false;\n+\n+  if (rs6000_cpu == PROCESSOR_POWER4)\n+    {\n+      enum attr_type type = get_attr_type (insn);\n+      if (type == TYPE_LOAD_EXT_U\n+\t  || type == TYPE_LOAD_EXT_UX\n+\t  || type == TYPE_LOAD_UX\n+\t  || type == TYPE_STORE_UX\n+\t  || type == TYPE_MFCR)\n+        return true;\n+    }\n+\n+  return false;\n+}\n+\n /* The function returns a non-zero value if INSN can be scheduled only\n-   as the first insn in a dispatch group (\"dispatch-slot restricted\"). \n-   In this case, the returned value indicates how many dispatch slots \n-   the insn occupies (at the beginning of the group). \n+   as the first insn in a dispatch group (\"dispatch-slot restricted\").\n+   In this case, the returned value indicates how many dispatch slots\n+   the insn occupies (at the beginning of the group).\n    Return 0 otherwise.  */\n \n-static int \n+static int\n is_dispatch_slot_restricted (rtx insn)\n {\n   enum attr_type type;\n@@ -13358,6 +13404,55 @@ is_dispatch_slot_restricted (rtx insn)\n   }\n }\n \n+/* The function returns true if INSN is cracked into 2 instructions\n+   by the processor (and therefore occupies 2 issue slots).  */\n+\n+static bool\n+is_cracked_insn (rtx insn)\n+{\n+  if (!insn || !INSN_P (insn)\n+      || GET_CODE (PATTERN (insn)) == USE\n+      || GET_CODE (PATTERN (insn)) == CLOBBER)\n+    return false;\n+\n+  if (rs6000_cpu == PROCESSOR_POWER4)\n+    {\n+      enum attr_type type = get_attr_type (insn);\n+      if (type == TYPE_LOAD_U || type == TYPE_STORE_U\n+\t       || type == TYPE_FPLOAD_U || type == TYPE_FPSTORE_U\n+\t       || type == TYPE_FPLOAD_UX || type == TYPE_FPSTORE_UX\n+\t       || type == TYPE_LOAD_EXT || type == TYPE_DELAYED_CR\n+\t       || type == TYPE_COMPARE || type == TYPE_DELAYED_COMPARE\n+\t       || type == TYPE_IMUL_COMPARE || type == TYPE_LMUL_COMPARE\n+\t       || type == TYPE_IDIV || type == TYPE_LDIV\n+\t       || type == TYPE_INSERT_WORD)\n+        return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* The function returns true if INSN can be issued only from\n+   the branch slot. */\n+\n+static bool\n+is_branch_slot_insn (rtx insn)\n+{\n+  if (!insn || !INSN_P (insn)\n+      || GET_CODE (PATTERN (insn)) == USE\n+      || GET_CODE (PATTERN (insn)) == CLOBBER)\n+    return false;\n+\n+  if (rs6000_cpu == PROCESSOR_POWER4)\n+    {\n+      enum attr_type type = get_attr_type (insn);\n+      if (type == TYPE_BRANCH || type == TYPE_JMPREG)\n+\treturn true;\t \n+      return false;\n+    }\n+\n+  return false;\n+}\n \n /* A C statement (sans semicolon) to update the integer scheduling\n    priority INSN_PRIORITY (INSN). Increase the priority to execute the\n@@ -13446,8 +13541,9 @@ rs6000_issue_rate (void)\n   case CPU_PPC604E:\n   case CPU_PPC620:\n   case CPU_PPC630:\n-  case CPU_POWER4:\n     return 4;\n+  case CPU_POWER4:\n+    return 5;\n   default:\n     return 1;\n   }\n@@ -13602,7 +13698,428 @@ rs6000_is_costly_dependence (rtx insn, rtx next, rtx link, int cost, int distanc\n   return false;\n }\n \n+/* Return the next insn after INSN that is found before TAIL is reached, \n+   skipping any \"non-active\" insns - insns that will not actually occupy\n+   an issue slot.  Return NULL_RTX if such an insn is not found.  */\n+\n+static rtx\n+get_next_active_insn (rtx insn, rtx tail)\n+{\n+  rtx next_insn;\n+\n+  if (!insn || insn == tail)\n+    return NULL_RTX;\n+\n+  next_insn = NEXT_INSN (insn);\n+\n+  while (next_insn\n+  \t && next_insn != tail\n+\t && (GET_CODE(next_insn) == NOTE\n+\t     || GET_CODE (PATTERN (next_insn)) == USE\n+\t     || GET_CODE (PATTERN (next_insn)) == CLOBBER))\n+    {\n+      next_insn = NEXT_INSN (next_insn);\n+    }\n+\n+  if (!next_insn || next_insn == tail)\n+    return NULL_RTX;\n+\n+  return next_insn;\n+}\n+\n+/* Return whether the presence of INSN causes a dispatch group terminatation\n+   of group WHICH_GROUP.\n+\n+   If WHICH_GROUP == current_group, this function will return true if INSN\n+   causes the termination of the current group (i.e, the dispatch group to\n+   which INSN belongs). This means that INSN will be the last insn in the\n+   group it belongs to.\n+\n+   If WHICH_GROUP == previous_group, this function will return true if INSN\n+   causes the termination of the previous group (i.e, the dispatch group that\n+   precedes the group to which INSN belongs).  This means that INSN will be\n+   the first insn in the group it belongs to).  */\n+\n+static bool\n+insn_terminates_group_p (rtx insn, enum group_termination which_group)\n+{\n+  enum attr_type type;\n+\n+  if (! insn)\n+    return false;\n \n+  type = get_attr_type (insn);\n+\n+  if (is_microcoded_insn (insn))\n+    return true;\n+\n+  if (which_group == current_group)\n+    {\n+      if (is_branch_slot_insn (insn))\n+        return true;\n+      return false;\n+    }\n+  else if (which_group == previous_group)\n+    {\n+      if (is_dispatch_slot_restricted (insn))\n+        return true;\n+      return false;\n+    }\n+\n+  return false;\n+}\n+\n+/* Return true if it is recommended to keep NEXT_INSN \"far\" (in a seperate\n+   dispatch group) from the insns in GROUP_INSNS.  Return false otherwise.  */\n+\n+static bool\n+is_costly_group (rtx *group_insns, rtx next_insn)\n+{\n+  int i;\n+  rtx link;\n+  int cost;\n+  int issue_rate = rs6000_issue_rate ();\n+\n+  for (i = 0; i < issue_rate; i++)\n+    {\n+      rtx insn = group_insns[i];\n+      if (!insn)\n+        continue;\n+      for (link = INSN_DEPEND (insn); link != 0; link = XEXP (link, 1))\n+        {\n+          rtx next = XEXP (link, 0);\n+          if (next == next_insn)\n+            {\n+              cost = insn_cost (insn, link, next_insn);\n+              if (rs6000_is_costly_dependence (insn, next_insn, link, cost, 0))\n+                return true;\n+            }\n+        }\n+    }\n+\n+  return false;\n+}\n+\n+/* Utility of the function redefine_groups. \n+   Check if it is too costly to schedule NEXT_INSN together with GROUP_INSNS\n+   in the same dispatch group.  If so, insert nops before NEXT_INSN, in order\n+   to keep it \"far\" (in a separate group) from GROUP_INSNS, following\n+   one of the following schemes, depending on the value of the flag\n+   -minsert_sched_nops = X:\n+   (1) X == sched_finish_regroup_exact: insert exactly as many nops as needed\n+       in order to force NEXT_INSN into a seperate group.\n+   (2) X < sched_finish_regroup_exact: insert exactly X nops.  \n+   GROUP_END, CAN_ISSUE_MORE and GROUP_COUNT record the state after nop \n+   insertion (has a group just ended, how many vacant issue slots remain in the\n+   last group, and how many dispatch groups were encountered so far).  */\n+\n+static int \n+force_new_group (int sched_verbose, FILE *dump, rtx *group_insns, rtx next_insn,\n+\t\t bool *group_end, int can_issue_more, int *group_count)\n+{\n+  rtx nop;\n+  bool force;\n+  int issue_rate = rs6000_issue_rate ();\n+  bool end = *group_end;\n+  int i;\n+\n+  if (next_insn == NULL_RTX)\n+    return can_issue_more;\n+\n+  if (rs6000_sched_insert_nops > sched_finish_regroup_exact)\n+    return can_issue_more;\n+\n+  force = is_costly_group (group_insns, next_insn);\n+  if (!force)\n+    return can_issue_more;\n+\n+  if (sched_verbose > 6)\n+    fprintf (dump,\"force: group count = %d, can_issue_more = %d\\n\",\n+\t\t\t*group_count ,can_issue_more);\n+\n+  if (rs6000_sched_insert_nops == sched_finish_regroup_exact)\n+    {\n+      if (*group_end)\n+        can_issue_more = 0;\n+\n+      /* Since only a branch can be issued in the last issue_slot, it is\n+\t sufficient to insert 'can_issue_more - 1' nops if next_insn is not\n+\t a branch. If next_insn is a branch, we insert 'can_issue_more' nops;\n+\t in this case the last nop will start a new group and the branch will be\n+\t forced to the new group.  */\n+      if (can_issue_more && !is_branch_slot_insn (next_insn))\n+        can_issue_more--;\n+\n+      while (can_issue_more > 0)\n+        {\n+          nop = gen_nop();\n+          emit_insn_before (nop, next_insn);\n+          can_issue_more--;\n+        }\n+\n+      *group_end = true;\n+      return 0;\n+    } \n+\n+  if (rs6000_sched_insert_nops < sched_finish_regroup_exact)\n+    {\n+      int n_nops = rs6000_sched_insert_nops;\n+\n+      /* Nops can't be issued from the branch slot, so the effective \n+         issue_rate for nops is 'issue_rate - 1'.  */\n+      if (can_issue_more == 0)\n+        can_issue_more = issue_rate;\n+      can_issue_more--;\n+      if (can_issue_more == 0)\n+        {\n+          can_issue_more = issue_rate - 1;\n+          (*group_count)++;\n+          end = true;\n+          for (i = 0; i < issue_rate; i++)\n+            {\n+              group_insns[i] = 0;\n+            }\n+        }\n+\n+      while (n_nops > 0)\n+        {\n+          nop = gen_nop ();\n+          emit_insn_before (nop, next_insn);\n+          if (can_issue_more == issue_rate - 1) /* new group begins */\n+            end = false;\n+          can_issue_more--;\n+          if (can_issue_more == 0)\n+            {\n+              can_issue_more = issue_rate - 1;\n+              (*group_count)++;\n+              end = true;\n+              for (i = 0; i < issue_rate; i++)\n+                {\n+                  group_insns[i] = 0;\n+                } \n+            }\t\n+          n_nops--;\n+        }\n+\n+      /* Scale back relative to 'issue_rate' (instead of 'issue_rate - 1').  */\n+      can_issue_more++; \n+\n+      *group_end = /* Is next_insn going to start a new group?  */\n+\t  (end \n+\t   || (can_issue_more == 1 && !is_branch_slot_insn (next_insn))\n+\t   || (can_issue_more <= 2 && is_cracked_insn (next_insn))\n+\t   || (can_issue_more < issue_rate &&\n+\t      insn_terminates_group_p (next_insn, previous_group)));\n+      if (*group_end && end)\n+        (*group_count)--;\n+\n+      if (sched_verbose > 6)\n+        fprintf (dump, \"done force: group count = %d, can_issue_more = %d\\n\",\n+\t\t\t*group_count, can_issue_more);\n+      return can_issue_more;\t\n+    } \n+\n+  return can_issue_more;\n+}\n+\n+/* This function tries to synch the dispatch groups that the compiler \"sees\"\n+   with the dispatch groups that the processor dispatcher is expected to \n+   form in practice.  It tries to achieve this synchronization by forcing the\n+   estimated processor grouping on the compiler (as opposed to the function\n+   'pad_goups' which tries to force the scheduler's grouping on the processor).\n+\n+   The function scans the insn sequence between PREV_HEAD_INSN and TAIL and\n+   examines the (estimated) dispatch groups that will be formed by the processor\n+   dispatcher.  It marks these group boundaries to reflect the estimated\n+   processor grouping, overriding the grouping that the scheduler had marked.\n+   Depending on the value of the flag '-minsert-sched-nops' this function can\n+   force certain insns into separate groups or force a certain distance between\n+   them by inserting nops, for example, if there exists a \"costly dependence\"\n+   between the insns.\n+\n+   The function estimates the group boundaries that the processor will form as\n+   folllows:  It keeps track of how many vacant issue slots are available after\n+   each insn.  A subsequent insn will start a new group if one of the following\n+   4 cases applies:\n+   - no more vacant issue slots remain in the current dispatch group.\n+   - only the last issue slot, which is the branch slot, is vacant, but the next\n+     insn is not a branch.\n+   - only the last 2 or less issue slots, including the branch slot, are vacant,\n+     which means that a cracked insn (which occupies two issue slots) can't be\n+     issued in this group.\n+   - less than 'issue_rate' slots are vacant, and the next insn always needs to \n+     start a new group.  */\n+\n+static int\n+redefine_groups (FILE *dump, int sched_verbose, rtx prev_head_insn, rtx tail)\n+{\n+  rtx insn, next_insn;\n+  int issue_rate;\n+  int can_issue_more;\n+  int slot, i;\n+  bool group_end;\n+  int group_count = 0;\n+  rtx *group_insns;\n+\n+  /* Initialize.  */\n+  issue_rate = rs6000_issue_rate ();\n+  group_insns = alloca (issue_rate * sizeof (rtx));\n+  for (i = 0; i < issue_rate; i++) \n+    {\n+      group_insns[i] = 0;\n+    }\n+  can_issue_more = issue_rate;\n+  slot = 0;\n+  insn = get_next_active_insn (prev_head_insn, tail);\n+  group_end = false;\n+\n+  while (insn != NULL_RTX)\n+    {\n+      slot = (issue_rate - can_issue_more);\n+      group_insns[slot] = insn;\n+      can_issue_more =\n+        rs6000_variable_issue (dump, sched_verbose, insn, can_issue_more);\n+      if (insn_terminates_group_p (insn, current_group))\n+        can_issue_more = 0;\n+\n+      next_insn = get_next_active_insn (insn, tail);\n+      if (next_insn == NULL_RTX)\n+        return group_count + 1;\n+\n+      group_end = /* Is next_insn going to start a new group?  */\n+        (can_issue_more == 0\n+         || (can_issue_more == 1 && !is_branch_slot_insn (next_insn))\n+         || (can_issue_more <= 2 && is_cracked_insn (next_insn))\n+         || (can_issue_more < issue_rate &&\n+             insn_terminates_group_p (next_insn, previous_group)));\n+\n+      can_issue_more = force_new_group (sched_verbose, dump, group_insns, \n+\t\t\tnext_insn, &group_end, can_issue_more, &group_count);\n+\n+      if (group_end)\n+        {\n+          group_count++;\n+          can_issue_more = 0;\n+          for (i = 0; i < issue_rate; i++)\n+            {\n+              group_insns[i] = 0;\n+            }\n+        }\n+\n+      if (GET_MODE (next_insn) == TImode && can_issue_more)\n+        PUT_MODE(next_insn, VOIDmode);\n+      else if (!can_issue_more && GET_MODE (next_insn) != TImode)\n+        PUT_MODE (next_insn, TImode);\n+\n+      insn = next_insn;\n+      if (can_issue_more == 0)\n+        can_issue_more = issue_rate;\n+   } /* while */\n+\n+  return group_count;\n+}\n+\n+/* Scan the insn sequence between PREV_HEAD_INSN and TAIL and examine the\n+   dispatch group boundaries that the scheduler had marked.  Pad with nops\n+   any dispatch groups which have vacant issue slots, in order to force the\n+   scheduler's grouping on the processor dispatcher.  The function\n+   returns the number of dispatch groups found.  */\n+\n+static int\n+pad_groups (FILE *dump, int sched_verbose, rtx prev_head_insn, rtx tail)\n+{\n+  rtx insn, next_insn;\n+  rtx nop;\n+  int issue_rate;\n+  int can_issue_more;\n+  int group_end;\n+  int group_count = 0;\n+\n+  /* Initialize issue_rate.  */\n+  issue_rate = rs6000_issue_rate ();\n+  can_issue_more = issue_rate;\n+\n+  insn = get_next_active_insn (prev_head_insn, tail);\n+  next_insn = get_next_active_insn (insn, tail);\n+\n+  while (insn != NULL_RTX)\n+    {\n+      can_issue_more =\n+      \trs6000_variable_issue (dump, sched_verbose, insn, can_issue_more);\n+\n+      group_end = (next_insn == NULL_RTX || GET_MODE (next_insn) == TImode);\n+\n+      if (next_insn == NULL_RTX)\n+        break;\n+\n+      if (group_end)\n+        {\n+          /* If the scheduler had marked group termination at this location\n+             (between insn and next_indn), and neither insn nor next_insn will\n+             force group termination, pad the group with nops to force group\n+             termination.  */\n+          if (can_issue_more\n+              && (rs6000_sched_insert_nops == sched_finish_pad_groups)\n+              && !insn_terminates_group_p (insn, current_group)\n+              && !insn_terminates_group_p (next_insn, previous_group))\n+            {\n+              if (!is_branch_slot_insn(next_insn))\n+                can_issue_more--;\n+\n+              while (can_issue_more)\n+                {\n+                  nop = gen_nop ();\n+                  emit_insn_before (nop, next_insn);\n+                  can_issue_more--;\n+                }\n+            }\n+\n+          can_issue_more = issue_rate;\n+          group_count++;\n+        }\n+\n+      insn = next_insn;\n+      next_insn = get_next_active_insn (insn, tail);\n+    }\n+\n+  return group_count;\n+}\n+\n+/* The following function is called at the end of scheduling BB.\n+   After reload, it inserts nops at insn group bundling.  */\n+\n+static void\n+rs6000_sched_finish (dump, sched_verbose)\n+     FILE *dump;\n+     int sched_verbose;\n+{\n+  int n_groups;\n+\n+  if (sched_verbose)\n+    fprintf (dump, \"=== Finishing schedule.\\n\");\n+\n+  if (reload_completed && rs6000_cpu == PROCESSOR_POWER4)\n+    {\n+      if (rs6000_sched_insert_nops == sched_finish_none)\n+        return;\n+\n+      if (rs6000_sched_insert_nops == sched_finish_pad_groups)\n+        n_groups = pad_groups (dump, sched_verbose,\n+\t\t\t\tcurrent_sched_info->prev_head,\n+  \t\t\t   \tcurrent_sched_info->next_tail);\n+      else\n+        n_groups = redefine_groups (dump, sched_verbose,\n+\t\t\t\tcurrent_sched_info->prev_head,\n+  \t\t\t\tcurrent_sched_info->next_tail);\n+\n+      if (sched_verbose >= 6)\n+\t{\n+    \t  fprintf (dump, \"ngroups = %d\\n\", n_groups);\n+\t  print_rtl (dump, current_sched_info->prev_head);\n+\t  fprintf (dump, \"Done finish_sched\\n\");\n+\t}\n+    }\n+}\n \f\n /* Length in units of the trampoline for entering a nested function.  */\n "}, {"sha": "8ab42b153cf24460ac70a20dbbd42dd786567263", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe26ab89a7101f6e39d5e40ba0b5d50c27affd9/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe26ab89a7101f6e39d5e40ba0b5d50c27affd9/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=cbe26ab89a7101f6e39d5e40ba0b5d50c27affd9", "patch": "@@ -386,6 +386,21 @@ enum rs6000_dependence_cost\n    store_to_load_dep_costly\n  };\n \n+/* Types of nop insertion schemes in sched target hook sched_finish.  */\n+enum rs6000_nop_insertion\n+  {\n+    sched_finish_regroup_exact = 1000,\n+    sched_finish_pad_groups,\n+    sched_finish_none\n+  };\n+\n+/* Dispatch group termination caused by an insn.  */\n+enum group_termination\n+  {\n+    current_group,\n+    previous_group\n+  };\n+\n /* This is meant to be overridden in target specific files.  */\n #define\tSUBTARGET_OPTIONS\n \n@@ -413,7 +428,9 @@ enum rs6000_dependence_cost\n     N_(\"Avoid all range limits on call instructions\"), 0},\t\t\\\n    {\"no-longcall\", &rs6000_longcall_switch, \"\", 0},\t\t\t\\\n    {\"sched-costly-dep=\", &rs6000_sched_costly_dep_str,                  \\\n-    N_(\"determine which dependences between insns are considered costly\"), 0}, \\\n+    N_(\"Determine which dependences between insns are considered costly\"), 0}, \\\n+   {\"insert-sched-nops=\", &rs6000_sched_insert_nops_str,                \\\n+    N_(\"Specify which post scheduling nop insertion scheme to apply\"), 0}, \\\n    {\"align-\", &rs6000_alignment_string,\t\t\t\t\t\\\n     N_(\"Specify alignment of structure fields default/natural\"), 0},\t\\\n    {\"prioritize-restricted-insns=\", &rs6000_sched_restricted_insns_priority_str, \\\n@@ -475,6 +492,8 @@ extern const char *rs6000_sched_restricted_insns_priority_str;\n extern int rs6000_sched_restricted_insns_priority;\n extern const char *rs6000_sched_costly_dep_str;\n extern enum rs6000_dependence_cost rs6000_sched_costly_dep;\n+extern const char *rs6000_sched_insert_nops_str;\n+extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n \n /* Alignment options for fields in structures for sub-targets following\n    AIX-like ABI.\n@@ -501,6 +520,11 @@ extern enum rs6000_dependence_cost rs6000_sched_costly_dep;\n /* Define if the target has restricted dispatch slot instructions.  */\n #define DEFAULT_RESTRICTED_INSNS_PRIORITY (rs6000_cpu == PROCESSOR_POWER4 ? 1 : 0)\n \n+/* Set a default value for post scheduling nop insertion scheme\n+   (used by taget hook sched_finish).  */\n+#define DEFAULT_SCHED_FINISH_NOP_INSERTION_SCHEME          \\\n+  (rs6000_cpu == PROCESSOR_POWER4 ? sched_finish_regroup_exact : sched_finish_none)\n+\n /* Define TARGET_MFCRF if the target assembler supports the optional\n    field operand for mfcr and the target processor supports the\n    instruction.  */"}, {"sha": "0689af7e0df05a8ebb4900802b93e1e1d70407e7", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe26ab89a7101f6e39d5e40ba0b5d50c27affd9/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe26ab89a7101f6e39d5e40ba0b5d50c27affd9/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=cbe26ab89a7101f6e39d5e40ba0b5d50c27affd9", "patch": "@@ -435,6 +435,7 @@ in the following sections.\n -mdynamic-no-pic @gol\n -mprioritize-restricted-insns=@var{priority} @gol\n -msched-costly-dep=@var{dependence_type} @gol\n+-minsert-sched-nops=@var{scheme} @gol\n -mcall-sysv  -mcall-netbsd @gol\n -maix-struct-return  -msvr4-struct-return @gol\n -mabi=altivec  -mabi=no-altivec @gol\n@@ -7590,6 +7591,20 @@ by the target during instruction scheduling.  The argument\n @var{store_to_load}: any dependence from store to load is costly,\n @var{number}: any dependence which latency >= @var{number} is costly.\n  \n+@item -minsert-sched-nops=@var{scheme}\n+@opindex minsert-sched-nops\n+This option controls which nop insertion scheme will be used during\n+the second scheduling pass. The argument @var{scheme} takes one of the\n+following values:\n+@var{no}: Don't insert nops.\n+@var{pad}: Pad with nops any dispatch group which has vacant issue slots,\n+according to the scheduler's grouping.\n+@var{regroup_exact}: Insert nops to force costly dependent insns into\n+separate groups.  Insert exactly as many nops as needed to force an insn\n+to a new group, according to the estimatied processor grouping.\n+@var{number}: Insert nops to force costly dependent insns into \n+separate groups.  Insert @var{number} nops to force an insn to a new group.\n+\n @item -mcall-sysv\n @opindex mcall-sysv\n On System V.4 and embedded PowerPC systems compile code using calling"}]}