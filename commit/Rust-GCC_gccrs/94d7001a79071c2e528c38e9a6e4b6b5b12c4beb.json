{"sha": "94d7001a79071c2e528c38e9a6e4b6b5b12c4beb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRkNzAwMWE3OTA3MWMyZTUyOGMzOGU5YTZlNGI2YjViMTJjNGJlYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-02-22T13:40:06Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-02-22T13:40:06Z"}, "message": "(movsfcc, movdfcc): New standard patterns.\n\n(fselsfsf4, fseldfsf4, fseldfdf4, fselsfdf4): Name and create variants of\nexisting anonymous patterns for movsfcc and movdfcc.\n\nFrom-SVN: r9031", "tree": {"sha": "bc1e37dcc03e5e8b9ff77e837a65199b8399510e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc1e37dcc03e5e8b9ff77e837a65199b8399510e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94d7001a79071c2e528c38e9a6e4b6b5b12c4beb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94d7001a79071c2e528c38e9a6e4b6b5b12c4beb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94d7001a79071c2e528c38e9a6e4b6b5b12c4beb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94d7001a79071c2e528c38e9a6e4b6b5b12c4beb/comments", "author": null, "committer": null, "parents": [{"sha": "cb64953075c20b6e004949206c3d7cdd6795d773", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb64953075c20b6e004949206c3d7cdd6795d773", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb64953075c20b6e004949206c3d7cdd6795d773"}], "stats": {"total": 172, "additions": 164, "deletions": 8}, "files": [{"sha": "47215d2c3320ad5a65696c6ad0d750f6d2130386", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 164, "deletions": 8, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d7001a79071c2e528c38e9a6e4b6b5b12c4beb/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d7001a79071c2e528c38e9a6e4b6b5b12c4beb/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=94d7001a79071c2e528c38e9a6e4b6b5b12c4beb", "patch": "@@ -2732,9 +2732,9 @@\n   \"fsqrt %0,%1\"\n   [(set_attr \"type\" \"dsqrt\")])\n \n-;; For SMIN, SMAX, UMIN, and UMAX, we use DEFINE_EXPAND's that involve a fsel\n-;; instruction and some auxiliary computations.  Then we just have a single\n-;; DEFINE_INSN for fsel and the define_splits to make them if made by\n+;; For MIN, MAX, and conditional move, we use DEFINE_EXPAND's that involve a\n+;; fsel instruction and some auxiliary computations.  Then we just have a\n+;; single DEFINE_INSN for fsel and the define_splits to make them if made by\n ;; combine.\n (define_expand \"maxsf3\"\n   [(set (match_dup 3)\n@@ -2792,7 +2792,76 @@\n \t\t\t (match_dup 2)))]\n   \"\")\n \n-(define_insn \"\"\n+(define_expand \"movsfcc\"\n+   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n+\t (if_then_else:SF (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t  (match_operand:SF 2 \"gpc_reg_operand\" \"f\")\n+\t\t\t  (match_operand:SF 3 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_PPC_GFXOPT\"\n+  \"\n+{\n+  rtx temp, op0, op1;\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  if (! rs6000_compare_fp_p)\n+    FAIL;\n+  switch (code)\n+    {\n+    case GE: case EQ: case NE:\n+      op0 = rs6000_compare_op0;\n+      op1 = rs6000_compare_op1;\n+      break;\n+    case GT:\n+      op0 = rs6000_compare_op1;\n+      op1 = rs6000_compare_op0;\n+      temp = operands[2]; operands[2] = operands[3]; operands[3] = temp;\n+      break;\n+    case LE:\n+      op0 = rs6000_compare_op1;\n+      op1 = rs6000_compare_op0;\n+      break;\n+    case LT:\n+      op0 = rs6000_compare_op0;\n+      op1 = rs6000_compare_op1;\n+      temp = operands[2]; operands[2] = operands[3]; operands[3] = temp;\n+      break;\n+    default:\n+      FAIL;\n+    }\n+  if (GET_MODE (rs6000_compare_op0) == DFmode)\n+    {\n+      temp = gen_reg_rtx (DFmode);\n+      emit_insn (gen_subdf3 (temp, op0, op1));\n+      emit_insn (gen_fseldfsf4 (operands[0], temp, operands[2], operands[3]));\n+      if (code == EQ)\n+\t{\n+\t  emit_insn (gen_negdf2 (temp, temp));\n+\t  emit_insn (gen_fseldfsf4 (operands[0], temp, operands[0], operands[3]));\n+\t}\n+      if (code == NE)\n+\t{\n+\t  emit_insn (gen_negdf2 (temp, temp));\n+\t  emit_insn (gen_fseldfsf4 (operands[0], temp, operands[3], operands[0]));\n+\t}\n+    }\n+  else\n+    {\n+      temp = gen_reg_rtx (SFmode);\n+      emit_insn (gen_subsf3 (temp, op0, op1));\n+      emit_insn (gen_fselsfsf4 (operands[0], temp, operands[2], operands[3]));\n+      if (code == EQ)\n+\t{\n+\t  emit_insn (gen_negsf2 (temp, temp));\n+\t  emit_insn (gen_fselsfsf4 (operands[0], temp, operands[0], operands[3]));\n+\t}\n+      if (code == NE)\n+\t{\n+\t  emit_insn (gen_negsf2 (temp, temp));\n+\t  emit_insn (gen_fselsfsf4 (operands[0], temp, operands[3], operands[0]));\n+\t}\n+    }\n+  DONE;\n+}\")\n+(define_insn \"fselsfsf4\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(if_then_else:SF (ge (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n \t\t\t     (const_int 0))\n@@ -2802,6 +2871,15 @@\n   \"fsel %0,%1,%2,%3\"\n   [(set_attr \"type\" \"fp\")])\n \n+(define_insn \"fseldfsf4\"\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n+\t(if_then_else:SF (ge (match_operand:DF 1 \"gpc_reg_operand\" \"f\")\n+\t\t\t     (const_int 0))\n+\t\t\t (match_operand:SF 2 \"gpc_reg_operand\" \"f\")\n+\t\t\t (match_operand:SF 3 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_PPC_GFXOPT\"\n+  \"fsel %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"fp\")])\n (define_insn \"negdf2\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n \t(neg:DF (match_operand:DF 1 \"gpc_reg_operand\" \"f\")))]\n@@ -2898,9 +2976,9 @@\n   \"fsqrt %0,%1\"\n   [(set_attr \"type\" \"dsqrt\")])\n \n-;; For SMIN, SMAX, UMIN, and UMAX, we use DEFINE_EXPAND's that involve a fsel\n-;; instruction and some auxiliary computations.  Then we just have a single\n-;; DEFINE_INSN for fsel and the define_splits to make them if made by\n+;; For MIN, MAX, and conditional move, we use DEFINE_EXPAND's that involve a\n+;; fsel instruction and some auxiliary computations.  Then we just have a\n+;; single DEFINE_INSN for fsel and the define_splits to make them if made by\n ;; combine.\n \n (define_expand \"maxdf3\"\n@@ -2959,7 +3037,76 @@\n \t\t\t (match_dup 2)))]\n   \"\")\n \n-(define_insn \"\"\n+(define_expand \"movdfcc\"\n+   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n+\t (if_then_else:DF (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t  (match_operand:DF 2 \"gpc_reg_operand\" \"f\")\n+\t\t\t  (match_operand:DF 3 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_PPC_GFXOPT\"\n+  \"\n+{\n+  rtx temp, op0, op1;\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  if (! rs6000_compare_fp_p)\n+    FAIL;\n+  switch (code)\n+    {\n+    case GE: case EQ: case NE:\n+      op0 = rs6000_compare_op0;\n+      op1 = rs6000_compare_op1;\n+      break;\n+    case GT:\n+      op0 = rs6000_compare_op1;\n+      op1 = rs6000_compare_op0;\n+      temp = operands[2]; operands[2] = operands[3]; operands[3] = temp;\n+      break;\n+    case LE:\n+      op0 = rs6000_compare_op1;\n+      op1 = rs6000_compare_op0;\n+      break;\n+    case LT:\n+      op0 = rs6000_compare_op0;\n+      op1 = rs6000_compare_op1;\n+      temp = operands[2]; operands[2] = operands[3]; operands[3] = temp;\n+      break;\n+    default:\n+      FAIL;\n+    }\n+  if (GET_MODE (rs6000_compare_op0) == DFmode)\n+    {\n+      temp = gen_reg_rtx (DFmode);\n+      emit_insn (gen_subdf3 (temp, op0, op1));\n+      emit_insn (gen_fseldfdf4 (operands[0], temp, operands[2], operands[3]));\n+      if (code == EQ)\n+\t{\n+\t  emit_insn (gen_negdf2 (temp, temp));\n+\t  emit_insn (gen_fseldfdf4 (operands[0], temp, operands[0], operands[3]));\n+\t}\n+      if (code == NE)\n+\t{\n+\t  emit_insn (gen_negdf2 (temp, temp));\n+\t  emit_insn (gen_fseldfdf4 (operands[0], temp, operands[3], operands[0]));\n+\t}\n+    }\n+  else\n+    {\n+      temp = gen_reg_rtx (SFmode);\n+      emit_insn (gen_subsf3 (temp, op0, op1));\n+      emit_insn (gen_fselsfdf4 (operands[0], temp, operands[2], operands[3]));\n+      if (code == EQ)\n+\t{\n+\t  emit_insn (gen_negsf2 (temp, temp));\n+\t  emit_insn (gen_fselsfdf4 (operands[0], temp, operands[0], operands[3]));\n+\t}\n+      if (code == NE)\n+\t{\n+\t  emit_insn (gen_negsf2 (temp, temp));\n+\t  emit_insn (gen_fselsfdf4 (operands[0], temp, operands[3], operands[0]));\n+\t}\n+    }\n+  DONE;\n+}\")\n+(define_insn \"fseldfdf4\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n \t(if_then_else:DF (ge (match_operand:DF 1 \"gpc_reg_operand\" \"f\")\n \t\t\t     (const_int 0))\n@@ -2968,6 +3115,15 @@\n   \"TARGET_PPC_GFXOPT\"\n   \"fsel %0,%1,%2,%3\"\n   [(set_attr \"type\" \"fp\")])\n+(define_insn \"fselsfdf4\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n+\t(if_then_else:DF (ge (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n+\t\t\t     (const_int 0))\n+\t\t\t (match_operand:DF 2 \"gpc_reg_operand\" \"f\")\n+\t\t\t (match_operand:DF 3 \"gpc_reg_operand\" \"f\")))]\n+  \"TARGET_PPC_GFXOPT\"\n+  \"fsel %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"fp\")])\n \f\n ;; Conversions to and from floating-point.\n (define_expand \"floatsidf2\""}]}