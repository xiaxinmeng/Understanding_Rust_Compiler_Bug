{"sha": "d0e6940256a41b142fc109acebeb3dd6284a700c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBlNjk0MDI1NmE0MWIxNDJmYzEwOWFjZWJlYjNkZDYyODRhNzAwYw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2014-01-29T15:34:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-29T15:34:14Z"}, "message": "exp_ch9.adb, [...]: Minor reformatting and code clean up.\n\n2014-01-29  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch9.adb, sem_ch7.ads, s-regexp.adb, sem_ch13.adb: Minor\n\treformatting and code clean up.\n\t* gnat_ugn.texi: Add documentation section on Atomic Variables\n\tand Optimization.\n\nFrom-SVN: r207253", "tree": {"sha": "ea409045cd6ddfb89320db52464b5594f1d1b738", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea409045cd6ddfb89320db52464b5594f1d1b738"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0e6940256a41b142fc109acebeb3dd6284a700c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0e6940256a41b142fc109acebeb3dd6284a700c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0e6940256a41b142fc109acebeb3dd6284a700c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0e6940256a41b142fc109acebeb3dd6284a700c/comments", "author": null, "committer": null, "parents": [{"sha": "5627964c4ae9de7ac15ed4a4e833a2a27e534e2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5627964c4ae9de7ac15ed4a4e833a2a27e534e2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5627964c4ae9de7ac15ed4a4e833a2a27e534e2b"}], "stats": {"total": 257, "additions": 139, "deletions": 118}, "files": [{"sha": "43d4f4244b915306b8a3dee6d9de6a099d6b88f8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0e6940256a41b142fc109acebeb3dd6284a700c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0e6940256a41b142fc109acebeb3dd6284a700c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d0e6940256a41b142fc109acebeb3dd6284a700c", "patch": "@@ -1,3 +1,10 @@\n+2014-01-29  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch9.adb, sem_ch7.ads, s-regexp.adb, sem_ch13.adb: Minor\n+\treformatting and code clean up.\n+\t* gnat_ugn.texi: Add documentation section on Atomic Variables\n+\tand Optimization.\n+\n 2014-01-29  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* einfo.adb Flag264 is now unused."}, {"sha": "f6629626e876cf5969d424676f6757df6133bc37", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0e6940256a41b142fc109acebeb3dd6284a700c/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0e6940256a41b142fc109acebeb3dd6284a700c/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=d0e6940256a41b142fc109acebeb3dd6284a700c", "patch": "@@ -8874,13 +8874,14 @@ package body Exp_Ch9 is\n       procedure Expand_Entry_Declaration (Comp : Entity_Id) is\n          Bdef : Entity_Id;\n          Edef : Entity_Id;\n+\n       begin\n          E_Count := E_Count + 1;\n          Comp_Id := Defining_Identifier (Comp);\n \n          Edef :=\n            Make_Defining_Identifier (Loc,\n-             Build_Selected_Name (Prot_Typ, Comp_Id, 'E'));\n+             Chars => Build_Selected_Name (Prot_Typ, Comp_Id, 'E'));\n          Sub :=\n            Make_Subprogram_Declaration (Loc,\n              Specification =>"}, {"sha": "c5632d7844956e9aa10de28b27105b1e7de0e2df", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0e6940256a41b142fc109acebeb3dd6284a700c/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0e6940256a41b142fc109acebeb3dd6284a700c/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=d0e6940256a41b142fc109acebeb3dd6284a700c", "patch": "@@ -10176,6 +10176,7 @@ some guidelines on debugging optimized code.\n * Other Optimization Switches::\n * Optimization and Strict Aliasing::\n * Aliased Variables and Optimization::\n+* Atomic Variables and Optimization::\n * Passive Task Optimization::\n \n @ifset vms\n@@ -11022,6 +11023,80 @@ inhibits optimizations that assume the value cannot be assigned.\n This means that the above example will in fact \"work\" reliably,\n that is, it will produce the expected results.\n \n+@node Atomic Variables and Optimization\n+@subsection Atomic Variables and Optimization\n+@cindex Atomic\n+There are two considerations with regard to performance when\n+atomic variables are used.\n+\n+First, the RM only guarantees that access to atomic variables\n+be atomic, it has nothing to say about how this is achieved,\n+though there is a strong implication that this should not be\n+achieved by explicit locking code. Indeed GNAT will never\n+generate any locking code for atomic variable access (it will\n+simply reject any attempt to make a variable or type atomic\n+if the atomic access cannot be achieved without such locking code).\n+\n+That being said, it is important to understand that you cannot\n+assume that the entire variable will always be accessed. Consider\n+this example:\n+\n+@smallexample @c ada\n+type R is record\n+   A,B,C,D : Character;\n+end record;\n+for R'Size use 32;\n+for R'Alignment use 4;\n+\n+RV : R;\n+pragma Atomic (RV);\n+X : Character;\n+...\n+X := RV.B;\n+@end smallexample\n+\n+@noindent\n+You cannot assume that the reference to @code{RV.B}\n+will read the entire 32-bit\n+variable with a single load instruction. It is perfectly legitimate if\n+the hardware allows it to do a byte read of just the B field. This read\n+is still atomic, which is all the RM requires. GNAT can and does take\n+advantage of this, depending on the architecture and optimization level.\n+Any assumption to the contrary is non-portable and risky. Even if you\n+examine the assembly language and see a full 32-bit load, this might\n+change in a future version of the compiler.\n+\n+If your application requires that all accesses to @code{RV} in this\n+example be full 32-bit loads, you need to make a copy for the access\n+as in:\n+\n+@smallexample @c ada\n+declare\n+   RV_Copy : constant R := RV;\n+begin\n+   X := RV_Copy.B;\n+end;\n+@end smallexample\n+\n+\n+@noindent\n+Now the reference to RV must read the whole variable.\n+Actually one can imagine some compiler which figures\n+out that the whole copy is not required (because only\n+the B field is actually accessed), but GNAT\n+certainly won't do that, and we don't know of any\n+compiler that would not handle this right, and the\n+above code will in practice work portably across\n+all architectures (that permit the Atomic declaration).\n+\n+The second issue with atomic variables has to do with\n+the possible requirement of generating synchronization\n+code. For more details on this, consult the sections on\n+the pragmas Enable/Disable_Atomic_Synchronization in the\n+GNAT Reference Manual. If performance is critical, and\n+such synchronization code is not required, it may be\n+useful to disable it.\n+\n @node Passive Task Optimization\n @subsection Passive Task Optimization\n @cindex Passive Task"}, {"sha": "68cef650aacc2b12c21b7628e1444506e728d962", "filename": "gcc/ada/s-regexp.adb", "status": "modified", "additions": 41, "deletions": 101, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0e6940256a41b142fc109acebeb3dd6284a700c/gcc%2Fada%2Fs-regexp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0e6940256a41b142fc109acebeb3dd6284a700c/gcc%2Fada%2Fs-regexp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-regexp.adb?ref=d0e6940256a41b142fc109acebeb3dd6284a700c", "patch": "@@ -30,8 +30,6 @@\n ------------------------------------------------------------------------------\n \n with Ada.Unchecked_Deallocation;\n-with Ada.Text_IO; use Ada.Text_IO;\n-\n with System.Case_Util;\n \n package body System.Regexp is\n@@ -53,13 +51,12 @@ package body System.Regexp is\n \n    type Regexp_Array is array\n      (State_Index range <>, Column_Index range <>) of State_Index;\n-   --  First index is for the state number\n-   --  Second index is for the character type\n-   --  Contents is the new State\n+   --  First index is for the state number. Second index is for the character\n+   --  type. Contents is the new State.\n \n    type Regexp_Array_Access is access Regexp_Array;\n-   --  Use this type through the functions Set below, so that it\n-   --  can grow dynamically depending on the needs.\n+   --  Use this type through the functions Set below, so that it can grow\n+   --  dynamically depending on the needs.\n \n    type Mapping is array (Character'Range) of Column_Index;\n    --  Mapping between characters and column in the Regexp_Array\n@@ -77,56 +74,6 @@ package body System.Regexp is\n    end record;\n    --  Deterministic finite-state machine\n \n-   procedure Dump\n-      (Table         : Regexp_Array_Access;\n-       Map           : Mapping;\n-       Alphabet_Size : Column_Index;\n-       Num_States    : State_Index;\n-       Start_State   : State_Index;\n-       End_State     : State_Index);\n-   --  Display the state machine (indeterministic, from the first pass) on\n-   --  stdout.\n-\n-   ----------\n-   -- Dump --\n-   ----------\n-\n-   procedure Dump\n-      (Table         : Regexp_Array_Access;\n-       Map           : Mapping;\n-       Alphabet_Size : Column_Index;\n-       Num_States    : State_Index;\n-       Start_State   : State_Index;\n-       End_State     : State_Index)\n-   is\n-      Empty_Char : constant Column_Index := Alphabet_Size + 1;\n-      Col : Column_Index;\n-   begin\n-      for S in Table'First (1) .. Num_States loop\n-         if S = Start_State then\n-            Put (\"Start\" & S'Img & \" => \");\n-         elsif S = End_State then\n-            Put (\"End  \" & S'Img);\n-         else\n-            Put (\"State\" & S'Img & \" => \");\n-         end if;\n-\n-         for C in Map'Range loop\n-            Col := Map (C);\n-            if Table (S, Col) /= 0 then\n-               Put (Table (S, Col)'Img & \"(\" & C'Img & \")\");\n-            end if;\n-         end loop;\n-\n-         for Col in Empty_Char .. Table'Last (2) loop\n-            exit when Table (S, Col) = 0;\n-            Put (Table (S, Col)'Img & \" (empty)\");\n-         end loop;\n-\n-         New_Line;\n-      end loop;\n-   end Dump;\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -142,10 +89,9 @@ package body System.Regexp is\n    function Get\n      (Table  : Regexp_Array_Access;\n       State  : State_Index;\n-      Column : Column_Index)\n-      return   State_Index;\n-   --  Returns the value in the table at (State, Column).\n-   --  If this index does not exist in the table, returns 0\n+      Column : Column_Index) return State_Index;\n+   --  Returns the value in the table at (State, Column). If this index does\n+   --  not exist in the table, returns zero.\n \n    procedure Free is new Ada.Unchecked_Deallocation\n      (Regexp_Array, Regexp_Array_Access);\n@@ -156,7 +102,6 @@ package body System.Regexp is\n \n    procedure Adjust (R : in out Regexp) is\n       Tmp : Regexp_Access;\n-\n    begin\n       if R.R /= null then\n          Tmp := new Regexp_Value (Alphabet_Size => R.R.Alphabet_Size,\n@@ -173,8 +118,7 @@ package body System.Regexp is\n    function Compile\n      (Pattern        : String;\n       Glob           : Boolean := False;\n-      Case_Sensitive : Boolean := True)\n-      return           Regexp\n+      Case_Sensitive : Boolean := True) return Regexp\n    is\n       S : String := Pattern;\n       --  The pattern which is really compiled (when the pattern is case\n@@ -210,10 +154,10 @@ package body System.Regexp is\n       --  parenthesis sub-expressions.\n       --\n       --  Table : at the end of the procedure : Column 0 is for any character\n-      --  ('.') and the last columns are for no character (closure)\n-      --  Num_States is set to the number of states in the table\n-      --  Start_State is the number of the starting state in the regexp\n-      --  End_State is the number of the final state when the regexp matches\n+      --  ('.') and the last columns are for no character (closure). Num_States\n+      --  is set to the number of states in the table Start_State is the number\n+      --  of the starting state in the regexp End_State is the number of the\n+      --  final state when the regexp matches.\n \n       procedure Create_Primary_Table_Glob\n         (Table       : out Regexp_Array_Access;\n@@ -226,10 +170,8 @@ package body System.Regexp is\n \n       function Create_Secondary_Table\n         (First_Table : Regexp_Array_Access;\n-         Num_States  : State_Index;\n          Start_State : State_Index;\n-         End_State   : State_Index)\n-         return        Regexp;\n+         End_State   : State_Index) return Regexp;\n       --  Creates the definitive table representing the regular expression\n       --  This is actually a transformation of the primary table First_Table,\n       --  where every state is grouped with the states in its 'no-character'\n@@ -601,8 +543,8 @@ package body System.Regexp is\n                      J := J + 1;\n                   end loop;\n \n-                  --  A close bracket must follow a open_bracket,\n-                  --  and cannot be found alone on the line\n+                  --  A close bracket must follow a open_bracket and cannot be\n+                  --  found alone on the line\n \n                when Close_Bracket =>\n                   Raise_Exception\n@@ -614,7 +556,7 @@ package body System.Regexp is\n                      Add_In_Map (S (J));\n \n                   else\n-                     --  \\ not allowed at the end of the regexp\n+                     --  Back slash \\ not allowed at the end of the regexp\n \n                      Raise_Exception\n                        (\"Incorrect character '\\' in regular expression\", J);\n@@ -748,11 +690,11 @@ package body System.Regexp is\n             End_Index   : Integer;\n             Start_State : out State_Index;\n             End_State   : out State_Index);\n-         --  Fill the table for the regexp Simple.\n-         --  This is the recursive procedure called to handle () expressions\n-         --  If End_State = 0, then the call to Create_Simple creates an\n-         --  independent regexp, not a concatenation\n-         --  Start_Index .. End_Index is the starting index in the string S.\n+         --  Fill the table for the regexp Simple. This is the recursive\n+         --  procedure called to handle () expressions If End_State = 0, then\n+         --  the call to Create_Simple creates an independent regexp, not a\n+         --  concatenation Start_Index .. End_Index is the starting index in\n+         --  the string S.\n          --\n          --  Warning: it may look like we are creating too many empty-string\n          --  transitions, but they are needed to get the correct regexp.\n@@ -799,8 +741,7 @@ package body System.Regexp is\n \n          function Next_Sub_Expression\n            (Start_Index : Integer;\n-            End_Index   : Integer)\n-            return        Integer;\n+            End_Index   : Integer) return Integer;\n          --  Returns the index of the last character of the next sub-expression\n          --  in Simple. Index cannot be greater than End_Index.\n \n@@ -1096,8 +1037,7 @@ package body System.Regexp is\n \n          function Next_Sub_Expression\n            (Start_Index : Integer;\n-            End_Index   : Integer)\n-            return        Integer\n+            End_Index   : Integer) return Integer\n          is\n             J              : Integer := Start_Index;\n             Start_On_Alter : Boolean := False;\n@@ -1188,15 +1128,15 @@ package body System.Regexp is\n            (State    : State_Index;\n             To_State : State_Index)\n          is\n-            J : Column_Index := Empty_Char;\n+            J : Column_Index;\n \n          begin\n+            J := Empty_Char;\n             while Get (Table, State, J) /= 0 loop\n                J := J + 1;\n             end loop;\n \n-            Set (Table, State, J,\n-                 Value => To_State);\n+            Set (Table, State, J, Value => To_State);\n          end Add_Empty_Char;\n \n          -------------------\n@@ -1209,13 +1149,14 @@ package body System.Regexp is\n             Start_State : out State_Index;\n             End_State   : out State_Index)\n          is\n-            J          : Integer := Start_Index;\n+            J          : Integer;\n             Last_Start : State_Index := 0;\n \n          begin\n             Start_State := 0;\n             End_State   := 0;\n \n+            J := Start_Index;\n             while J <= End_Index loop\n                case S (J) is\n \n@@ -1256,6 +1197,7 @@ package body System.Regexp is\n                            then\n                               declare\n                                  Start : constant Integer := J - 1;\n+\n                               begin\n                                  J := J + 1;\n \n@@ -1427,7 +1369,6 @@ package body System.Regexp is\n \n       function Create_Secondary_Table\n         (First_Table : Regexp_Array_Access;\n-         Num_States  : State_Index;\n          Start_State : State_Index;\n          End_State   : State_Index) return Regexp\n       is\n@@ -1482,8 +1423,9 @@ package body System.Regexp is\n          -----------------------\n \n          procedure Ensure_Meta_State (Meta : State_Index) is\n-            Tmp : Meta_States_List := Meta_States;\n+            Tmp  : Meta_States_List       := Meta_States;\n             Tmp2 : Meta_States_Transition := Table;\n+\n          begin\n             if Meta_States = null then\n                Meta_States := new Meta_States_Array\n@@ -1517,7 +1459,8 @@ package body System.Regexp is\n \n          procedure Closure\n            (Meta_State : State_Index;\n-            State      : State_Index) is\n+            State      : State_Index)\n+         is\n          begin\n             if not Meta_States (Meta_State)(State) then\n                Meta_States (Meta_State)(State) := True;\n@@ -1539,17 +1482,14 @@ package body System.Regexp is\n          Ensure_Meta_State (Current_State);\n          Closure (Current_State, Start_State);\n \n-         if False then\n-            Dump (First_Table, Map, Alphabet_Size, Num_States,\n-                  Start_State, End_State);\n-         end if;\n-\n          while Current_State <= Nb_State loop\n+\n             --  We will be trying, below, to create the next meta-state\n+\n             Ensure_Meta_State (Nb_State + 1);\n \n             --  For every character in the regexp, calculate the possible\n-            --  transitions from Current_State\n+            --  transitions from Current_State.\n \n             for Column in 0 .. Alphabet_Size loop\n                Temp_State_Not_Null := False;\n@@ -1573,7 +1513,8 @@ package body System.Regexp is\n                      if Meta_States (K) = Meta_States (Nb_State + 1) then\n                         Table (Current_State)(Column) := K;\n \n-                        --  reset data, for the next time we try that state\n+                        --  Reset data, for the next time we try that state\n+\n                         Meta_States (Nb_State + 1) := No_States;\n                         exit;\n                      end if;\n@@ -1634,6 +1575,7 @@ package body System.Regexp is\n    begin\n       --  Special case for the empty string: it always matches, and the\n       --  following processing would fail on it.\n+\n       if S = \"\" then\n          return (Ada.Finalization.Controlled with\n                  R => new Regexp_Value'\n@@ -1676,8 +1618,7 @@ package body System.Regexp is\n \n          --  Creates the secondary table\n \n-         R := Create_Secondary_Table\n-            (Table, Num_States, Start_State, End_State);\n+         R := Create_Secondary_Table (Table, Start_State, End_State);\n          Free (Table);\n          return R;\n       end;\n@@ -1690,7 +1631,6 @@ package body System.Regexp is\n    procedure Finalize (R : in out Regexp) is\n       procedure Free is new\n         Ada.Unchecked_Deallocation (Regexp_Value, Regexp_Access);\n-\n    begin\n       Free (R.R);\n    end Finalize;\n@@ -1766,7 +1706,7 @@ package body System.Regexp is\n          Table (State, Column) := Value;\n       else\n          --  Doubles the size of the table until it is big enough that\n-         --  (State, Column) is a valid index\n+         --  (State, Column) is a valid index.\n \n          New_Lines := Table'Last (1) * (State / Table'Last (1) + 1);\n          New_Columns := Table'Last (2) * (Column / Table'Last (2) + 1);"}, {"sha": "f28be3b6879e24649a4eda7e499d1a723b199511", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0e6940256a41b142fc109acebeb3dd6284a700c/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0e6940256a41b142fc109acebeb3dd6284a700c/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=d0e6940256a41b142fc109acebeb3dd6284a700c", "patch": "@@ -2242,8 +2242,7 @@ package body Sem_Ch13 is\n                          Expression => Relocate_Node (Expr))),\n                      Pragma_Name                  => Name_Refined_Global);\n \n-                  Decorate_Aspect_And_Pragma\n-                    (Aspect, Aitem, Delayed => True);\n+                  Decorate_Aspect_And_Pragma (Aspect, Aitem, Delayed => True);\n                   Insert_Delayed_Pragma (Aitem);\n                   goto Continue;\n "}, {"sha": "b74e4667b4cec97718c3d4a4e886462fa8314ee3", "filename": "gcc/ada/sem_ch7.ads", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0e6940256a41b142fc109acebeb3dd6284a700c/gcc%2Fada%2Fsem_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0e6940256a41b142fc109acebeb3dd6284a700c/gcc%2Fada%2Fsem_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.ads?ref=d0e6940256a41b142fc109acebeb3dd6284a700c", "patch": "@@ -35,13 +35,13 @@ package Sem_Ch7 is\n    procedure Analyze_Package_Body_Contract (Body_Id : Entity_Id);\n    --  Analyze all delayed aspects chained on the contract of package body\n    --  Body_Id as if they appeared at the end of a declarative region. The\n-   --  aspects in consideration are:\n+   --  aspects that are considered are:\n    --    Refined_State\n \n    procedure Analyze_Package_Contract (Pack_Id : Entity_Id);\n    --  Analyze all delayed aspects chained on the contract of package Pack_Id\n-   --  as if they appeared at the end of a declarative region. The aspects in\n-   --  consideration are:\n+   --  as if they appeared at the end of a declarative region. The aspects\n+   --  that are considered are:\n    --    Initial_Condition\n    --    Initializes\n    --    Part_Of\n@@ -59,7 +59,7 @@ package Sem_Ch7 is\n \n    --  On entrance to a package body, make declarations in package spec\n    --  immediately visible.\n-\n+   --\n    --  When compiling the body of a package,  both routines are called in\n    --  succession. When compiling the body of a child package, the call\n    --  to Install_Private_Declaration is immediate for private children,\n@@ -86,17 +86,16 @@ package Sem_Ch7 is\n    --  calling stubs.\n \n    procedure New_Private_Type (N : Node_Id; Id : Entity_Id; Def : Node_Id);\n-   --  Common processing for private type declarations and for formal\n-   --  private type declarations. For private types, N and Def are the type\n-   --  declaration node; for formal private types, Def is the formal type\n-   --  definition.\n+   --  Common processing for private type declarations and for formal private\n+   --  type declarations. For private types, N and Def are the type declaration\n+   --  node; for formal private types, Def is the formal type definition.\n \n    procedure Uninstall_Declarations (P : Entity_Id);\n-   --  At the end of a package declaration or body, declarations in the\n-   --  visible part are no longer immediately visible, and declarations in\n-   --  the private part are not visible at all. For inner packages, place\n-   --  visible entities at the end of their homonym chains. For compilation\n-   --  units, make all entities invisible. In both cases, exchange private\n-   --  and visible declarations to restore order of elaboration.\n+   --  At the end of a package declaration or body, declarations in the visible\n+   --  part are no longer immediately visible, and declarations in the private\n+   --  part are not visible at all. For inner packages, place visible entities\n+   --  at the end of their homonym chains. For compilation units, make\n+   --  all entities invisible. In both cases, exchange private and visible\n+   --  declarations to restore order of elaboration.\n \n end Sem_Ch7;"}]}