{"sha": "15814ba0a2c2bbbd8b4617447edb6065da14cb6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU4MTRiYTBhMmMyYmJiZDhiNDYxNzQ0N2VkYjYwNjVkYTE0Y2I2YQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2007-02-06T14:34:51Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2007-02-06T14:34:51Z"}, "message": "Makefile.in (tree-ssa-loop-ivopts.o): Add pointer-set.h dependency.\n\n2006-02-06  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* Makefile.in (tree-ssa-loop-ivopts.o): Add pointer-set.h dependency.\n\t(tree-ssa-reassoc.o): Add pointer-set.h dependency.\n\t(tree-cfg.o): Remove hashtab.h dependency.\n\n\t* tree-ssa-loop-ivopts.c: Include pointer-set.h.\n\t(struct ivopts_data): Change niters to pointer_map_t.\n\t(struct nfe_cache_elt, nfe_hash, nfe_eq): Delete.\n\t(niter_for_exit): Create pointer_map on demand.  Change for\n\tpointer_map API.\n\t(tree_ssa_iv_optimize_init): Initialize data->niters to NULL.\n\t(free_loop_data): Destroy data->niters if created and reset field.\n\t(tree_ssa_iv_optimize_finalize): Don't delete data->niters here.\n\t(tree_ssa_iv_optimize_loop): Check for presence of stale data.\n\n\t* tree-ssa-reassoc.c: Include pointer-set.h.\n\t(bb_rank): Change to long *.\n\t(operand_rank): Change to pointer_map_t.\n\t(find_operand_rank): Return long, -1 if not found.  Declare as inline.\n\t(insert_operand_rank): Accept long.\n\t(operand_entry_hash, operand_entry_eq): Remove.\n\t(get_rank): Return long.  Adjust for changes above.\n\t(init_reassoc): Change rank type to long.  Adjust creation of bb_rank\n\tand operand_rank.\n\t(fini_reassoc): Delete operand_rank with pointer_map_destroy.\n\n\t* tree-ssa-structalias.c (vi_for_tree): Change to pointer_map.\n\t(struct tree_vi, tree_vi_t, tree_vi_hash, tree_vi_eq): Delete.\n\t(insert_vi_for_tree): Rewrite for pointer_map API.  Assert argument\n\tis not NULL.\n\t(lookup_vi_for_tree): Rewrite for pointer_map API.  Return varinfo_t\n\tdirectly since it cannot be NULL.\n\t(get_vi_for_tree): Rewrite for pointer_map API.\n\t(find_what_p_points_to): Adjust for change to lookup_vi_for_tree.\n\t(init_alias_vars): Create vi_for_tree as pointer_map.\n\t(delete_points_to_sets): Delete vi_for_tree using pointer_map_destroy.\n\n\t* tree-cfg.c: Don't include hashtab.h.\n\t(edge_to_cases): Declare as pointer_map.\n\t(struct edge_to_cases_elt, edge_to_cases_hash, edge_to_cases_eq):\n\tDelete.\n\t(edge_to_cases_cleanup): Rewrite as pointer_map_traverse callback.\n\t(start_recording_case_labels): Create edge_to_cases as pointer_map.\n\t(end_recoding_case_labels): Cleanup edge_to_cases manually before\n\tdestroying it.\n\t(record_switch_edge): Delete.\n\t(get_cases_for_edge): Adjust for pointer_map API, inline\n\trecord_switch_edge (rewritten for new API), remove goto.\n\nFrom-SVN: r121648", "tree": {"sha": "9ee2a06ba9a73c0dbf9a0d7de12bd0049f095cce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ee2a06ba9a73c0dbf9a0d7de12bd0049f095cce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15814ba0a2c2bbbd8b4617447edb6065da14cb6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15814ba0a2c2bbbd8b4617447edb6065da14cb6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15814ba0a2c2bbbd8b4617447edb6065da14cb6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15814ba0a2c2bbbd8b4617447edb6065da14cb6a/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0802f6a2f718f63c240b0f77c319cd94fc9595c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0802f6a2f718f63c240b0f77c319cd94fc9595c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0802f6a2f718f63c240b0f77c319cd94fc9595c9"}], "stats": {"total": 590, "additions": 217, "deletions": 373}, "files": [{"sha": "f915a02171340d45d3d3d9023c4490505cc39864", "filename": "gcc/ChangeLog", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15814ba0a2c2bbbd8b4617447edb6065da14cb6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15814ba0a2c2bbbd8b4617447edb6065da14cb6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15814ba0a2c2bbbd8b4617447edb6065da14cb6a", "patch": "@@ -1,3 +1,74 @@\n+2006-02-06  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* Makefile.in (tree-ssa-loop-ivopts.o): Add pointer-set.h dependency.\n+\t(tree-ssa-reassoc.o): Add pointer-set.h dependency.\n+\t(tree-cfg.o): Remove hashtab.h dependency.\n+\n+\t* tree-ssa-loop-ivopts.c: Include pointer-set.h.\n+\t(struct ivopts_data): Change niters to pointer_map_t.\n+\t(struct nfe_cache_elt, nfe_hash, nfe_eq): Delete.\n+\t(niter_for_exit): Create pointer_map on demand.  Change for\n+\tpointer_map API.\n+\t(tree_ssa_iv_optimize_init): Initialize data->niters to NULL.\n+\t(free_loop_data): Destroy data->niters if created and reset field.\n+\t(tree_ssa_iv_optimize_finalize): Don't delete data->niters here.\n+\t(tree_ssa_iv_optimize_loop): Check for presence of stale data.\n+\n+\t* tree-ssa-reassoc.c: Include pointer-set.h.\n+\t(bb_rank): Change to long *.\n+\t(operand_rank): Change to pointer_map_t.\n+\t(find_operand_rank): Return long, -1 if not found.  Declare as inline.\n+\t(insert_operand_rank): Accept long.\n+\t(operand_entry_hash, operand_entry_eq): Remove.\n+\t(get_rank): Return long.  Adjust for changes above.\n+\t(init_reassoc): Change rank type to long.  Adjust creation of bb_rank\n+\tand operand_rank.\n+\t(fini_reassoc): Delete operand_rank with pointer_map_destroy.\n+\n+\t* tree-ssa-structalias.c (vi_for_tree): Change to pointer_map.\n+\t(struct tree_vi, tree_vi_t, tree_vi_hash, tree_vi_eq): Delete.\n+\t(insert_vi_for_tree): Rewrite for pointer_map API.  Assert argument\n+\tis not NULL.\n+\t(lookup_vi_for_tree): Rewrite for pointer_map API.  Return varinfo_t\n+\tdirectly since it cannot be NULL.\n+\t(get_vi_for_tree): Rewrite for pointer_map API.\n+\t(find_what_p_points_to): Adjust for change to lookup_vi_for_tree.\n+\t(init_alias_vars): Create vi_for_tree as pointer_map.\n+\t(delete_points_to_sets): Delete vi_for_tree using pointer_map_destroy.\n+\n+\t* tree-cfg.c: Don't include hashtab.h.\n+\t(edge_to_cases): Declare as pointer_map.\n+\t(struct edge_to_cases_elt, edge_to_cases_hash, edge_to_cases_eq):\n+\tDelete.\n+\t(edge_to_cases_cleanup): Rewrite as pointer_map_traverse callback.\n+\t(start_recording_case_labels): Create edge_to_cases as pointer_map.\n+\t(end_recoding_case_labels): Cleanup edge_to_cases manually before\n+\tdestroying it.\n+\t(record_switch_edge): Delete.\n+\t(get_cases_for_edge): Adjust for pointer_map API, inline\n+\trecord_switch_edge (rewritten for new API), remove goto.\n+\n+2006-02-06  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* Makefile.in (tree-nested.o): Add pointer-set.h dependency.\n+\t* tree-nested.c: Include pointer-set.h.\n+\t(var_map_elt, var_map_eq, var_map_hash): Delete.\n+\t(struct nesting_info): Remove GTY marker.  Change the two htab_t's\n+\tto pointer_map_t's.\n+\t(nesting_info_bitmap_obstack): New.\n+\t(lookup_field_for_decl): Adjust for pointer_map API.\n+\t(lookup_tramp_for_decl): Adjust for pointer_map API.\n+\t(get_nonlocal_debug_decl): Adjust for pointer_map API.\n+\t(get_local_debug_decl): Adjust for pointer_map API.\n+\t(convert_nl_goto_reference): Adjust for pointer_map API.\n+\t(convert_nl_goto_receiver): Adjust for pointer_map API.\n+\t(create_nesting_tree): Create outside GGC space.  Create bitmap on\n+\tthe new obstack.  Create field_map and var_map as pointer_maps.\n+\t(free_nesting_tree): Adjust for changes to create_nesting_tree.\n+\t(root): Delete.\t\n+\t(lower_nested_functions): Move root here, no need to NULL it.\n+\tInitialize and release the obstack.\n+\n 2007-02-06  Paolo Bonzini  <bonzini@gnu.org>\n \n         * tree.c (tree_int_map_hash, tree_int_map_eq, tree_int_map_marked_p):"}, {"sha": "689122d14904cb3a6df7829817357559b23e695b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15814ba0a2c2bbbd8b4617447edb6065da14cb6a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15814ba0a2c2bbbd8b4617447edb6065da14cb6a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=15814ba0a2c2bbbd8b4617447edb6065da14cb6a", "patch": "@@ -2055,7 +2055,7 @@ tree-cfg.o : tree-cfg.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(FLAGS_H) output.h \\\n    $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) except.h langhooks.h $(CFGLOOP_H) tree-pass.h \\\n-   $(CFGLAYOUT_H) $(BASIC_BLOCK_H) hard-reg-set.h $(HASHTAB_H) toplev.h \\\n+   $(CFGLAYOUT_H) $(BASIC_BLOCK_H) hard-reg-set.h toplev.h \\\n    tree-ssa-propagate.h\n tree-cfgcleanup.o : tree-cfgcleanup.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(FLAGS_H) output.h \\\n@@ -2078,7 +2078,7 @@ tree-ssa-sink.o : tree-ssa-sink.c $(TREE_FLOW_H) $(CONFIG_H) \\\n tree-nested.o: tree-nested.c $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(TM_P_H) $(FUNCTION_H) $(TREE_DUMP_H) $(TREE_INLINE_H) \\\n    tree-iterator.h $(TREE_GIMPLE_H) $(CGRAPH_H) $(EXPR_H) langhooks.h \\\n-   $(GGC_H) gt-tree-nested.h coretypes.h $(TREE_FLOW_H)\n+   $(GGC_H) gt-tree-nested.h coretypes.h $(TREE_FLOW_H) pointer-set.h\n tree-if-conv.o: tree-if-conv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(FLAGS_H) $(TIMEVAR_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) \\\n    $(CFGLOOP_H) $(RTL_H) $(C_COMMON_H) tree-chrec.h $(TREE_DATA_REF_H) \\\n@@ -2140,7 +2140,7 @@ tree-ssa-loop-ivopts.o : tree-ssa-loop-ivopts.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    tree-pass.h $(GGC_H) $(RECOG_H) insn-config.h $(HASHTAB_H) $(SCEV_H) \\\n    $(CFGLOOP_H) $(PARAMS_H) langhooks.h $(BASIC_BLOCK_H) hard-reg-set.h \\\n-   tree-chrec.h $(VARRAY_H) tree-affine.h\n+   tree-chrec.h $(VARRAY_H) tree-affine.h pointer-set.h\n tree-affine.o : tree-affine.c tree-affine.h $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) \\\n    output.h $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H)\n@@ -2167,7 +2167,7 @@ tree-ssa-reassoc.o : tree-ssa-reassoc.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) errors.h $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) tree-iterator.h\\\n    $(BASIC_BLOCK_H) $(TREE_GIMPLE_H) $(TREE_INLINE_H) vec.h \\\n-   alloc-pool.h\n+   alloc-pool.h pointer-set.h\n tree-optimize.o : tree-optimize.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h $(DIAGNOSTIC_H) \\\n    $(FLAGS_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) toplev.h \\"}, {"sha": "d9794592cf6a143d1d09a9b4b7ec03a55e8d9c75", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 24, "deletions": 96, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15814ba0a2c2bbbd8b4617447edb6065da14cb6a/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15814ba0a2c2bbbd8b4617447edb6065da14cb6a/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=15814ba0a2c2bbbd8b4617447edb6065da14cb6a", "patch": "@@ -44,7 +44,6 @@ Boston, MA 02110-1301, USA.  */\n #include \"except.h\"\n #include \"cfgloop.h\"\n #include \"cfglayout.h\"\n-#include \"hashtab.h\"\n #include \"tree-ssa-propagate.h\"\n #include \"value-prof.h\"\n #include \"pointer-set.h\"\n@@ -70,19 +69,7 @@ static const int initial_cfg_capacity = 20;\n    more persistent.  The key is getting notification of changes to\n    the CFG (particularly edge removal, creation and redirection).  */\n \n-struct edge_to_cases_elt\n-{\n-  /* The edge itself.  Necessary for hashing and equality tests.  */\n-  edge e;\n-\n-  /* The case labels associated with this edge.  We link these up via\n-     their TREE_CHAIN field, then we wipe out the TREE_CHAIN fields\n-     when we destroy the hash table.  This prevents problems when copying\n-     SWITCH_EXPRs.  */\n-  tree case_labels;\n-};\n-\n-static htab_t edge_to_cases;\n+static struct pointer_map_t *edge_to_cases;\n \n /* CFG statistics.  */\n struct cfg_stats_d\n@@ -619,28 +606,6 @@ make_cond_expr_edges (basic_block bb)\n     }\n }\n \n-/* Hashing routine for EDGE_TO_CASES.  */\n-\n-static hashval_t\n-edge_to_cases_hash (const void *p)\n-{\n-  edge e = ((struct edge_to_cases_elt *)p)->e;\n-\n-  /* Hash on the edge itself (which is a pointer).  */\n-  return htab_hash_pointer (e);\n-}\n-\n-/* Equality routine for EDGE_TO_CASES, edges are unique, so testing\n-   for equality is just a pointer comparison.  */\n-\n-static int\n-edge_to_cases_eq (const void *p1, const void *p2)\n-{\n-  edge e1 = ((struct edge_to_cases_elt *)p1)->e;\n-  edge e2 = ((struct edge_to_cases_elt *)p2)->e;\n-\n-  return e1 == e2;\n-}\n \n /* Called for each element in the hash table (P) as we delete the\n    edge to cases hash table.\n@@ -649,18 +614,20 @@ edge_to_cases_eq (const void *p1, const void *p2)\n    SWITCH_EXPRs and structure sharing rules, then free the hash table\n    element.  */\n \n-static void\n-edge_to_cases_cleanup (void *p)\n+static bool\n+edge_to_cases_cleanup (void *key ATTRIBUTE_UNUSED, void **value,\n+\t\t       void *data ATTRIBUTE_UNUSED)\n {\n-  struct edge_to_cases_elt *elt = (struct edge_to_cases_elt *) p;\n   tree t, next;\n \n-  for (t = elt->case_labels; t; t = next)\n+  for (t = (tree) *value; t; t = next)\n     {\n       next = TREE_CHAIN (t);\n       TREE_CHAIN (t) = NULL;\n     }\n-  free (p);\n+\n+  *value = NULL;\n+  return false;\n }\n \n /* Start recording information mapping edges to case labels.  */\n@@ -669,11 +636,7 @@ void\n start_recording_case_labels (void)\n {\n   gcc_assert (edge_to_cases == NULL);\n-\n-  edge_to_cases = htab_create (37,\n-\t\t\t       edge_to_cases_hash,\n-\t\t\t       edge_to_cases_eq,\n-\t\t\t       edge_to_cases_cleanup);\n+  edge_to_cases = pointer_map_create ();\n }\n \n /* Return nonzero if we are recording information for case labels.  */\n@@ -689,46 +652,11 @@ recording_case_labels_p (void)\n void\n end_recording_case_labels (void)\n {\n-  htab_delete (edge_to_cases);\n+  pointer_map_traverse (edge_to_cases, edge_to_cases_cleanup, NULL);\n+  pointer_map_destroy (edge_to_cases);\n   edge_to_cases = NULL;\n }\n \n-/* Record that CASE_LABEL (a CASE_LABEL_EXPR) references edge E.  */\n-\n-static void\n-record_switch_edge (edge e, tree case_label)\n-{\n-  struct edge_to_cases_elt *elt;\n-  void **slot;\n-\n-  /* Build a hash table element so we can see if E is already\n-     in the table.  */\n-  elt = XNEW (struct edge_to_cases_elt);\n-  elt->e = e;\n-  elt->case_labels = case_label;\n-\n-  slot = htab_find_slot (edge_to_cases, elt, INSERT);\n-\n-  if (*slot == NULL)\n-    {\n-      /* E was not in the hash table.  Install E into the hash table.  */\n-      *slot = (void *)elt;\n-    }\n-  else\n-    {\n-      /* E was already in the hash table.  Free ELT as we do not need it\n-\t anymore.  */\n-      free (elt);\n-\n-      /* Get the entry stored in the hash table.  */\n-      elt = (struct edge_to_cases_elt *) *slot;\n-\n-      /* Add it to the chain of CASE_LABEL_EXPRs referencing E.  */\n-      TREE_CHAIN (case_label) = elt->case_labels;\n-      elt->case_labels = case_label;\n-    }\n-}\n-\n /* If we are inside a {start,end}_recording_cases block, then return\n    a chain of CASE_LABEL_EXPRs from T which reference E.\n \n@@ -737,7 +665,6 @@ record_switch_edge (edge e, tree case_label)\n static tree\n get_cases_for_edge (edge e, tree t)\n {\n-  struct edge_to_cases_elt elt, *elt_p;\n   void **slot;\n   size_t i, n;\n   tree vec;\n@@ -747,16 +674,9 @@ get_cases_for_edge (edge e, tree t)\n   if (!recording_case_labels_p ())\n     return NULL;\n \n-restart:\n-  elt.e = e;\n-  elt.case_labels = NULL;\n-  slot = htab_find_slot (edge_to_cases, &elt, NO_INSERT);\n-\n+  slot = pointer_map_contains (edge_to_cases, e);\n   if (slot)\n-    {\n-      elt_p = (struct edge_to_cases_elt *)*slot;\n-      return elt_p->case_labels;\n-    }\n+    return (tree) *slot;\n \n   /* If we did not find E in the hash table, then this must be the first\n      time we have been queried for information about E & T.  Add all the\n@@ -766,11 +686,19 @@ get_cases_for_edge (edge e, tree t)\n   n = TREE_VEC_LENGTH (vec);\n   for (i = 0; i < n; i++)\n     {\n-      tree lab = CASE_LABEL (TREE_VEC_ELT (vec, i));\n+      tree elt = TREE_VEC_ELT (vec, i);\n+      tree lab = CASE_LABEL (elt);\n       basic_block label_bb = label_to_block (lab);\n-      record_switch_edge (find_edge (e->src, label_bb), TREE_VEC_ELT (vec, i));\n+      edge this_edge = find_edge (e->src, label_bb);\n+\n+      /* Add it to the chain of CASE_LABEL_EXPRs referencing E, or create\n+\t a new chain.  */\n+      slot = pointer_map_insert (edge_to_cases, this_edge);\n+      TREE_CHAIN (elt) = (tree) *slot;\n+      *slot = elt;\n     }\n-  goto restart;\n+\n+  return (tree) *pointer_map_contains (edge_to_cases, e);\n }\n \n /* Create the edges for a SWITCH_EXPR starting at block BB."}, {"sha": "a3ea11432d000de2280a8cf6eb3cde3cbac29b47", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 49, "deletions": 108, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15814ba0a2c2bbbd8b4617447edb6065da14cb6a/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15814ba0a2c2bbbd8b4617447edb6065da14cb6a/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=15814ba0a2c2bbbd8b4617447edb6065da14cb6a", "patch": "@@ -34,6 +34,7 @@\n #include \"cgraph.h\"\n #include \"expr.h\"\n #include \"langhooks.h\"\n+#include \"pointer-set.h\"\n #include \"ggc.h\"\n \n \n@@ -77,20 +78,14 @@\n    been written as independent functions without change.  */\n \n \n-struct var_map_elt GTY(())\n-{\n-  tree old;\n-  tree new;\n-};\n-\n-struct nesting_info GTY ((chain_next (\"%h.next\")))\n+struct nesting_info\n {\n   struct nesting_info *outer;\n   struct nesting_info *inner;\n   struct nesting_info *next;\n   \n-  htab_t GTY ((param_is (struct var_map_elt))) field_map;\n-  htab_t GTY ((param_is (struct var_map_elt))) var_map;\n+  struct pointer_map_t *field_map;\n+  struct pointer_map_t *var_map;\n   bitmap suppress_expansion;\n \n   tree context;\n@@ -108,22 +103,9 @@ struct nesting_info GTY ((chain_next (\"%h.next\")))\n };\n \n \n-/* Hashing and equality functions for nesting_info->var_map.  */\n+/* Obstack used for the bitmaps in the struct above.  */\n+static struct bitmap_obstack nesting_info_bitmap_obstack;\n \n-static hashval_t\n-var_map_hash (const void *x)\n-{\n-  const struct var_map_elt *a = (const struct var_map_elt *) x;\n-  return htab_hash_pointer (a->old);\n-}\n-\n-static int\n-var_map_eq (const void *x, const void *y)\n-{\n-  const struct var_map_elt *a = (const struct var_map_elt *) x;\n-  const struct var_map_elt *b = (const struct var_map_elt *) y;\n-  return a->old == b->old;\n-}\n \n /* We're working in so many different function contexts simultaneously,\n    that create_tmp_var is dangerous.  Prevent mishap.  */\n@@ -268,22 +250,18 @@ static tree\n lookup_field_for_decl (struct nesting_info *info, tree decl,\n \t\t       enum insert_option insert)\n {\n-  struct var_map_elt *elt, dummy;\n   void **slot;\n-  tree field;\n \n-  dummy.old = decl;\n-  slot = htab_find_slot (info->field_map, &dummy, insert);\n-  if (!slot)\n+  if (insert == NO_INSERT)\n     {\n-      gcc_assert (insert != INSERT);\n-      return NULL;\n+      slot = pointer_map_contains (info->field_map, decl);\n+      return slot ? *slot : NULL;\n     }\n-  elt = (struct var_map_elt *) *slot;\n \n-  if (!elt && insert == INSERT)\n+  slot = pointer_map_insert (info->field_map, decl);\n+  if (!*slot)\n     {\n-      field = make_node (FIELD_DECL);\n+      tree field = make_node (FIELD_DECL);\n       DECL_NAME (field) = DECL_NAME (decl);\n \n       if (use_pointer_in_frame (decl))\n@@ -304,19 +282,13 @@ lookup_field_for_decl (struct nesting_info *info, tree decl,\n \t}\n \n       insert_field_into_struct (get_frame_type (info), field);\n-  \n-      elt = GGC_NEW (struct var_map_elt);\n-      elt->old = decl;\n-      elt->new = field;\n-      *slot = elt;\n+      *slot = field;\n \n       if (TREE_CODE (decl) == PARM_DECL)\n \tinfo->any_parm_remapped = true;\n     }\n-  else\n-    field = elt ? elt->new : NULL;\n \n-  return field;\n+  return *slot;\n }\n \n /* Build or return the variable that holds the static chain within\n@@ -469,39 +441,29 @@ static tree\n lookup_tramp_for_decl (struct nesting_info *info, tree decl,\n \t\t       enum insert_option insert)\n {\n-  struct var_map_elt *elt, dummy;\n   void **slot;\n-  tree field;\n \n-  dummy.old = decl;\n-  slot = htab_find_slot (info->var_map, &dummy, insert);\n-  if (!slot)\n+  if (insert == NO_INSERT)\n     {\n-      gcc_assert (insert != INSERT);\n-      return NULL;\n+      slot = pointer_map_contains (info->var_map, decl);\n+      return slot ? *slot : NULL;\n     }\n-  elt = (struct var_map_elt *) *slot;\n \n-  if (!elt && insert == INSERT)\n+  slot = pointer_map_insert (info->var_map, decl);\n+  if (!*slot)\n     {\n-      field = make_node (FIELD_DECL);\n+      tree field = make_node (FIELD_DECL);\n       DECL_NAME (field) = DECL_NAME (decl);\n       TREE_TYPE (field) = get_trampoline_type ();\n       TREE_ADDRESSABLE (field) = 1;\n \n       insert_field_into_struct (get_frame_type (info), field);\n-\n-      elt = GGC_NEW (struct var_map_elt);\n-      elt->old = decl;\n-      elt->new = field;\n-      *slot = elt;\n+      *slot = field;\n \n       info->any_tramp_created = true;\n     }\n-  else\n-    field = elt ? elt->new : NULL;\n \n-  return field;\n+  return *slot;\n } \n \n /* Build or return the field within the non-local frame state that holds\n@@ -767,10 +729,10 @@ check_for_nested_with_variably_modified (tree fndecl, tree orig_fndecl)\n static struct nesting_info *\n create_nesting_tree (struct cgraph_node *cgn)\n {\n-  struct nesting_info *info = GGC_CNEW (struct nesting_info);\n-  info->field_map = htab_create_ggc (7, var_map_hash, var_map_eq, ggc_free);\n-  info->var_map = htab_create_ggc (7, var_map_hash, var_map_eq, ggc_free);\n-  info->suppress_expansion = BITMAP_GGC_ALLOC ();\n+  struct nesting_info *info = XCNEW (struct nesting_info);\n+  info->field_map = pointer_map_create ();\n+  info->var_map = pointer_map_create ();\n+  info->suppress_expansion = BITMAP_ALLOC (&nesting_info_bitmap_obstack);\n   info->context = cgn->decl;\n \n   for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n@@ -865,18 +827,15 @@ get_frame_field (struct nesting_info *info, tree target_context,\n static tree\n get_nonlocal_debug_decl (struct nesting_info *info, tree decl)\n {\n-  struct var_map_elt *elt, dummy;\n   tree target_context;\n   struct nesting_info *i;\n   tree x, field, new_decl;\n   void **slot;\n \n-  dummy.old = decl;\n-  slot = htab_find_slot (info->var_map, &dummy, INSERT);\n-  elt = *slot;\n+  slot = pointer_map_insert (info->var_map, decl);\n \n-  if (elt)\n-    return elt->new;\n+  if (*slot)\n+    return *slot;\n \n   target_context = decl_function_context (decl);\n \n@@ -920,11 +879,7 @@ get_nonlocal_debug_decl (struct nesting_info *info, tree decl)\n   SET_DECL_VALUE_EXPR (new_decl, x);\n   DECL_HAS_VALUE_EXPR_P (new_decl) = 1;\n \n-  elt = ggc_alloc (sizeof (*elt));\n-  elt->old = decl;\n-  elt->new = new_decl;\n-  *slot = elt;\n-\n+  *slot = new_decl;\n   TREE_CHAIN (new_decl) = info->debug_var_chain;\n   info->debug_var_chain = new_decl;\n \n@@ -1198,16 +1153,12 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n static tree\n get_local_debug_decl (struct nesting_info *info, tree decl, tree field)\n {\n-  struct var_map_elt *elt, dummy;\n   tree x, new_decl;\n   void **slot;\n \n-  dummy.old = decl;\n-  slot = htab_find_slot (info->var_map, &dummy, INSERT);\n-  elt = *slot;\n-\n-  if (elt)\n-    return elt->new;\n+  slot = pointer_map_insert (info->var_map, decl);\n+  if (*slot)\n+    return *slot;\n \n   /* Make sure frame_decl gets created.  */\n   (void) get_frame_type (info);\n@@ -1227,11 +1178,7 @@ get_local_debug_decl (struct nesting_info *info, tree decl, tree field)\n \n   SET_DECL_VALUE_EXPR (new_decl, x);\n   DECL_HAS_VALUE_EXPR_P (new_decl) = 1;\n-\n-  elt = ggc_alloc (sizeof (*elt));\n-  elt->old = decl;\n-  elt->new = new_decl;\n-  *slot = elt;\n+  *slot = new_decl;\n \n   TREE_CHAIN (new_decl) = info->debug_var_chain;\n   info->debug_var_chain = new_decl;\n@@ -1491,7 +1438,6 @@ convert_nl_goto_reference (tree *tp, int *walk_subtrees, void *data)\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n   struct nesting_info *info = wi->info, *i;\n   tree t = *tp, label, new_label, target_context, x, arg, field;\n-  struct var_map_elt *elt, dummy;\n   void **slot;\n \n   *walk_subtrees = 0;\n@@ -1514,21 +1460,15 @@ convert_nl_goto_reference (tree *tp, int *walk_subtrees, void *data)\n      (hairy target-specific) non-local goto receiver code to be generated\n      when we expand rtl.  Enter this association into var_map so that we\n      can insert the new label into the IL during a second pass.  */\n-  dummy.old = label;\n-  slot = htab_find_slot (i->var_map, &dummy, INSERT);\n-  elt = (struct var_map_elt *) *slot;\n-  if (elt == NULL)\n+  slot = pointer_map_insert (i->var_map, label);\n+  if (*slot == NULL)\n     {\n       new_label = create_artificial_label ();\n       DECL_NONLOCAL (new_label) = 1;\n-\n-      elt = GGC_NEW (struct var_map_elt); \n-      elt->old = label;\n-      elt->new = new_label;\n-      *slot = elt;\n+      *slot = new_label;\n     }\n   else\n-    new_label = elt->new;\n+    new_label = *slot;\n   \n   /* Build: __builtin_nl_goto(new_label, &chain->nl_goto_field).  */\n   field = get_nl_goto_field (i);\n@@ -1559,19 +1499,17 @@ convert_nl_goto_receiver (tree *tp, int *walk_subtrees, void *data)\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n   struct nesting_info *info = wi->info;\n   tree t = *tp, label, new_label, x;\n-  struct var_map_elt *elt, dummy;\n   tree_stmt_iterator tmp_tsi;\n+  void **slot;\n \n   *walk_subtrees = 0;\n   if (TREE_CODE (t) != LABEL_EXPR)\n     return NULL_TREE;\n   label = LABEL_EXPR_LABEL (t);\n \n-  dummy.old = label;\n-  elt = (struct var_map_elt *) htab_find (info->var_map, &dummy);\n-  if (!elt)\n+  slot = pointer_map_contains (info->var_map, label);\n+  if (!slot)\n     return NULL_TREE;\n-  new_label = elt->new;\n \n   /* If there's any possibility that the previous statement falls through,\n      then we must branch around the new non-local label.  */\n@@ -1582,6 +1520,8 @@ convert_nl_goto_receiver (tree *tp, int *walk_subtrees, void *data)\n       x = build1 (GOTO_EXPR, void_type_node, label);\n       tsi_link_before (&wi->tsi, x, TSI_SAME_STMT);\n     }\n+\n+  new_label = (tree) *slot;\n   x = build1 (LABEL_EXPR, void_type_node, new_label);\n   tsi_link_before (&wi->tsi, x, TSI_SAME_STMT);\n \n@@ -1953,29 +1893,30 @@ free_nesting_tree (struct nesting_info *root)\n     {\n       if (root->inner)\n \tfree_nesting_tree (root->inner);\n-      htab_delete (root->var_map);\n+      pointer_map_destroy (root->var_map);\n+      pointer_map_destroy (root->field_map);\n       next = root->next;\n-      ggc_free (root);\n+      free (root);\n       root = next;\n     }\n   while (root);\n }\n \n-static GTY(()) struct nesting_info *root;\n-\n /* Main entry point for this pass.  Process FNDECL and all of its nested\n    subroutines and turn them into something less tightly bound.  */\n \n void\n lower_nested_functions (tree fndecl)\n {\n   struct cgraph_node *cgn;\n+  struct nesting_info *root;\n \n   /* If there are no nested functions, there's nothing to do.  */\n   cgn = cgraph_node (fndecl);\n   if (!cgn->nested)\n     return;\n \n+  bitmap_obstack_initialize (&nesting_info_bitmap_obstack);\n   root = create_nesting_tree (cgn);\n   walk_all_functions (convert_nonlocal_reference, root);\n   walk_all_functions (convert_local_reference, root);\n@@ -1985,7 +1926,7 @@ lower_nested_functions (tree fndecl)\n   finalize_nesting_tree (root);\n   unnest_nesting_tree (root);\n   free_nesting_tree (root);\n-  root = NULL;\n+  bitmap_obstack_release (&nesting_info_bitmap_obstack);\n }\n \n #include \"gt-tree-nested.h\""}, {"sha": "5982b3d3f6229a00fe9840f7b39014837c1f8bde", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 25, "deletions": 50, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15814ba0a2c2bbbd8b4617447edb6065da14cb6a/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15814ba0a2c2bbbd8b4617447edb6065da14cb6a/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=15814ba0a2c2bbbd8b4617447edb6065da14cb6a", "patch": "@@ -83,6 +83,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"ggc.h\"\n #include \"insn-config.h\"\n #include \"recog.h\"\n+#include \"pointer-set.h\"\n #include \"hashtab.h\"\n #include \"tree-chrec.h\"\n #include \"tree-scalar-evolution.h\"\n@@ -208,7 +209,7 @@ struct ivopts_data\n   unsigned regs_used;\n \n   /* Numbers of iterations for all exits of the current loop.  */\n-  htab_t niters;\n+  struct pointer_map_t *niters;\n \n   /* The size of version_info array allocated.  */\n   unsigned version_info_size;\n@@ -673,58 +674,26 @@ contains_abnormal_ssa_name_p (tree expr)\n   return false;\n }\n \n-/* Element of the table in that we cache the numbers of iterations obtained\n-   from exits of the loop.  */\n-\n-struct nfe_cache_elt\n-{\n-  /* The edge for that the number of iterations is cached.  */\n-  edge exit;\n-\n-  /* Number of iterations corresponding to this exit, or NULL if it cannot be\n-     determined.  */\n-  tree niter;\n-};\n-\n-/* Hash function for nfe_cache_elt E.  */\n-\n-static hashval_t\n-nfe_hash (const void *e)\n-{\n-  const struct nfe_cache_elt *elt = e;\n-\n-  return htab_hash_pointer (elt->exit);\n-}\n-\n-/* Equality function for nfe_cache_elt E1 and edge E2.  */\n-\n-static int\n-nfe_eq (const void *e1, const void *e2)\n-{\n-  const struct nfe_cache_elt *elt1 = e1;\n-\n-  return elt1->exit == e2;\n-}\n-\n /*  Returns tree describing number of iterations determined from\n     EXIT of DATA->current_loop, or NULL if something goes wrong.  */\n \n static tree\n niter_for_exit (struct ivopts_data *data, edge exit)\n {\n-  struct nfe_cache_elt *nfe_desc;\n   struct tree_niter_desc desc;\n-  PTR *slot;\n-\n-  slot = htab_find_slot_with_hash (data->niters, exit,\n-\t\t\t\t   htab_hash_pointer (exit),\n-\t\t\t\t   INSERT);\n+  tree niter;\n+  void **slot;\n \n-  if (!*slot)\n+  if (!data->niters)\n     {\n-      nfe_desc = xmalloc (sizeof (struct nfe_cache_elt));\n-      nfe_desc->exit = exit;\n+      data->niters = pointer_map_create ();\n+      slot = NULL;\n+    }\n+  else\n+    slot = pointer_map_contains (data->niters, exit);\n \n+  if (!slot)\n+    {\n       /* Try to determine number of iterations.  We must know it\n \t unconditionally (i.e., without possibility of # of iterations\n \t being zero).  Also, we cannot safely work with ssa names that\n@@ -734,14 +703,16 @@ niter_for_exit (struct ivopts_data *data, edge exit)\n \t\t\t\t     exit, &desc, true)\n \t  && integer_zerop (desc.may_be_zero)\n      \t  && !contains_abnormal_ssa_name_p (desc.niter))\n-\tnfe_desc->niter = desc.niter;\n+\tniter = desc.niter;\n       else\n-\tnfe_desc->niter = NULL_TREE;\n+\tniter = NULL_TREE;\n+\n+      *pointer_map_insert (data->niters, exit) = niter;\n     }\n   else\n-    nfe_desc = *slot;\n+    niter = *slot;\n \n-  return nfe_desc->niter;\n+  return niter;\n }\n \n /* Returns tree describing number of iterations determined from\n@@ -770,7 +741,7 @@ tree_ssa_iv_optimize_init (struct ivopts_data *data)\n   data->relevant = BITMAP_ALLOC (NULL);\n   data->important_candidates = BITMAP_ALLOC (NULL);\n   data->max_inv_id = 0;\n-  data->niters = htab_create (10, nfe_hash, nfe_eq, free);\n+  data->niters = NULL;\n   data->iv_uses = VEC_alloc (iv_use_p, heap, 20);\n   data->iv_candidates = VEC_alloc (iv_cand_p, heap, 20);\n   decl_rtl_to_reset = VEC_alloc (tree, heap, 20);\n@@ -5236,7 +5207,11 @@ free_loop_data (struct ivopts_data *data)\n   bitmap_iterator bi;\n   tree obj;\n \n-  htab_empty (data->niters);\n+  if (data->niters)\n+    {\n+      pointer_map_destroy (data->niters);\n+      data->niters = NULL;\n+    }\n \n   EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, i, bi)\n     {\n@@ -5304,7 +5279,6 @@ tree_ssa_iv_optimize_finalize (struct ivopts_data *data)\n   free (data->version_info);\n   BITMAP_FREE (data->relevant);\n   BITMAP_FREE (data->important_candidates);\n-  htab_delete (data->niters);\n \n   VEC_free (tree, heap, decl_rtl_to_reset);\n   VEC_free (iv_use_p, heap, data->iv_uses);\n@@ -5320,6 +5294,7 @@ tree_ssa_iv_optimize_loop (struct ivopts_data *data, struct loop *loop)\n   struct iv_ca *iv_ca;\n   edge exit;\n \n+  gcc_assert (!data->niters);\n   data->current_loop = loop;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "e216f996637b7d91ad16a6cf0376ea9a3b0968e8", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 23, "deletions": 54, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15814ba0a2c2bbbd8b4617447edb6065da14cb6a/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15814ba0a2c2bbbd8b4617447edb6065da14cb6a/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=15814ba0a2c2bbbd8b4617447edb6065da14cb6a", "patch": "@@ -38,6 +38,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"alloc-pool.h\"\n #include \"vec.h\"\n #include \"langhooks.h\"\n+#include \"pointer-set.h\"\n \n /*  This is a simple global reassociation pass.  It is, in part, based\n     on the LLVM pass of the same name (They do some things more/less\n@@ -179,68 +180,38 @@ static alloc_pool operand_entry_pool;\n /* Starting rank number for a given basic block, so that we can rank\n    operations using unmovable instructions in that BB based on the bb\n    depth.  */\n-static unsigned int *bb_rank;\n+static long *bb_rank;\n \n /* Operand->rank hashtable.  */\n-static htab_t operand_rank;\n+static struct pointer_map_t *operand_rank;\n \n \n /* Look up the operand rank structure for expression E.  */\n \n-static operand_entry_t\n+static inline long\n find_operand_rank (tree e)\n {\n-  void **slot;\n-  struct operand_entry vrd;\n-\n-  vrd.op = e;\n-  slot = htab_find_slot (operand_rank, &vrd, NO_INSERT);\n-  if (!slot)\n-    return NULL;\n-  return ((operand_entry_t) *slot);\n+  void **slot = pointer_map_contains (operand_rank, e);\n+  return slot ? (long) *slot : -1;\n }\n \n /* Insert {E,RANK} into the operand rank hashtable.  */\n \n-static void\n-insert_operand_rank (tree e, unsigned int rank)\n+static inline void\n+insert_operand_rank (tree e, long rank)\n {\n   void **slot;\n-  operand_entry_t new_pair = pool_alloc (operand_entry_pool);\n-\n-  new_pair->op = e;\n-  new_pair->rank = rank;\n-  slot = htab_find_slot (operand_rank, new_pair, INSERT);\n-  gcc_assert (*slot == NULL);\n-  *slot = new_pair;\n-}\n-\n-/* Return the hash value for a operand rank structure  */\n-\n-static hashval_t\n-operand_entry_hash (const void *p)\n-{\n-  const operand_entry_t vr = (operand_entry_t) p;\n-  return iterative_hash_expr (vr->op, 0);\n-}\n-\n-/* Return true if two operand rank structures are equal.  */\n-\n-static int\n-operand_entry_eq (const void *p1, const void *p2)\n-{\n-  const operand_entry_t vr1 = (operand_entry_t) p1;\n-  const operand_entry_t vr2 = (operand_entry_t) p2;\n-  return vr1->op == vr2->op;\n+  gcc_assert (rank > 0);\n+  slot = pointer_map_insert (operand_rank, e);\n+  gcc_assert (!*slot);\n+  *slot = (void *) rank;\n }\n \n /* Given an expression E, return the rank of the expression.  */\n \n-static unsigned int\n+static long\n get_rank (tree e)\n {\n-  operand_entry_t vr;\n-\n   /* Constants have rank 0.  */\n   if (is_gimple_min_invariant (e))\n     return 0;\n@@ -260,12 +231,12 @@ get_rank (tree e)\n     {\n       tree stmt;\n       tree rhs;\n-      unsigned int rank, maxrank;\n+      long rank, maxrank;\n       int i;\n \n       if (TREE_CODE (SSA_NAME_VAR (e)) == PARM_DECL\n \t  && SSA_NAME_IS_DEFAULT_DEF (e))\n-\treturn find_operand_rank (e)->rank;\n+\treturn find_operand_rank (e);\n \n       stmt = SSA_NAME_DEF_STMT (e);\n       if (bb_for_stmt (stmt) == NULL)\n@@ -276,9 +247,9 @@ get_rank (tree e)\n \treturn bb_rank[bb_for_stmt (stmt)->index];\n \n       /* If we already have a rank for this expression, use that.  */\n-      vr = find_operand_rank (e);\n-      if (vr)\n-\treturn vr->rank;\n+      rank = find_operand_rank (e);\n+      if (rank != -1)\n+\treturn rank;\n \n       /* Otherwise, find the maximum rank for the operands, or the bb\n \t rank, whichever is less.   */\n@@ -301,7 +272,7 @@ get_rank (tree e)\n \t{\n \t  fprintf (dump_file, \"Rank for \");\n \t  print_generic_expr (dump_file, e, 0);\n-\t  fprintf (dump_file, \" is %d\\n\", (rank + 1));\n+\t  fprintf (dump_file, \" is %ld\\n\", (rank + 1));\n \t}\n \n       /* Note the rank in the hashtable so we don't recompute it.  */\n@@ -1417,7 +1388,7 @@ static void\n init_reassoc (void)\n {\n   int i;\n-  unsigned int rank = 2;\n+  long rank = 2;\n   tree param;\n   int *bbs = XNEWVEC (int, last_basic_block + 1);\n \n@@ -1429,10 +1400,8 @@ init_reassoc (void)\n   /* Reverse RPO (Reverse Post Order) will give us something where\n      deeper loops come later.  */\n   pre_and_rev_post_order_compute (NULL, bbs, false);\n-  bb_rank = XCNEWVEC (unsigned int, last_basic_block + 1);\n-  \n-  operand_rank = htab_create (511, operand_entry_hash,\n-\t\t\t      operand_entry_eq, 0);\n+  bb_rank = XCNEWVEC (long, last_basic_block + 1);\n+  operand_rank = pointer_map_create ();\n \n   /* Give each argument a distinct rank.   */\n   for (param = DECL_ARGUMENTS (current_function_decl);\n@@ -1483,8 +1452,8 @@ fini_reassoc (void)\n       fprintf (dump_file, \"Statements rewritten: %d\\n\",\n \t       reassociate_stats.rewritten);\n     }\n-  htab_delete (operand_rank);\n \n+  pointer_map_destroy (operand_rank);\n   free_alloc_pool (operand_entry_pool);\n   free (bb_rank);\n   VEC_free (tree, heap, broken_up_subtracts);"}, {"sha": "238e7f487c1319b479ab4f56ef3716d80a025d84", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 21, "deletions": 61, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15814ba0a2c2bbbd8b4617447edb6065da14cb6a/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15814ba0a2c2bbbd8b4617447edb6065da14cb6a/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=15814ba0a2c2bbbd8b4617447edb6065da14cb6a", "patch": "@@ -2138,67 +2138,31 @@ solve_graph (constraint_graph_t graph)\n }\n \n /* Map from trees to variable infos.  */\n-static htab_t vi_for_tree;\n+static struct pointer_map_t *vi_for_tree;\n \n-typedef struct tree_vi\n-{\n-  tree t;\n-  varinfo_t vi;\n-} *tree_vi_t;\n-\n-/* Hash a tree id structure.  */\n-\n-static hashval_t\n-tree_vi_hash (const void *p)\n-{\n-  const tree_vi_t ta = (tree_vi_t) p;\n-  return htab_hash_pointer (ta->t);\n-}\n-\n-/* Return true if the tree in P1 and the tree in P2 are the same.  */\n-\n-static int\n-tree_vi_eq (const void *p1, const void *p2)\n-{\n-  const tree_vi_t ta1 = (tree_vi_t) p1;\n-  const tree_vi_t ta2 = (tree_vi_t) p2;\n-  return ta1->t == ta2->t;\n-}\n \n-/* Insert ID as the variable id for tree T in the hashtable.  */\n+/* Insert ID as the variable id for tree T in the vi_for_tree map.  */\n \n static void\n insert_vi_for_tree (tree t, varinfo_t vi)\n {\n-  void **slot;\n-  struct tree_vi finder;\n-  tree_vi_t new_pair;\n-\n-  finder.t = t;\n-  slot = htab_find_slot (vi_for_tree, &finder, INSERT);\n+  void **slot = pointer_map_insert (vi_for_tree, t);\n+  gcc_assert (vi);\n   gcc_assert (*slot == NULL);\n-  new_pair = XNEW (struct tree_vi);\n-  new_pair->t = t;\n-  new_pair->vi = vi;\n-  *slot = (void *)new_pair;\n+  *slot = vi;\n }\n \n /* Find the variable info for tree T in VI_FOR_TREE.  If T does not\n-   exist in the hash table, return false, otherwise, return true and\n-   set *VI to the varinfo we found.  */\n+   exist in the map, return NULL, otherwise, return the varinfo we found.  */\n \n-static bool\n-lookup_vi_for_tree (tree t, varinfo_t *vi)\n+static varinfo_t\n+lookup_vi_for_tree (tree t)\n {\n-  tree_vi_t pair;\n-  struct tree_vi finder;\n+  void **slot = pointer_map_contains (vi_for_tree, t);\n+  if (slot == NULL)\n+    return NULL;\n \n-  finder.t = t;\n-  pair = htab_find (vi_for_tree,  &finder);\n-  if (pair == NULL)\n-    return false;\n-  *vi = pair->vi;\n-  return true;\n+  return (varinfo_t) *slot;\n }\n \n /* Return a printable name for DECL  */\n@@ -2235,21 +2199,17 @@ alias_get_name (tree decl)\n   return res;\n }\n \n-/* Find the variable id for tree T in the hashtable.\n-   If T doesn't exist in the hash table, create an entry for it.  */\n+/* Find the variable id for tree T in the map.\n+   If T doesn't exist in the map, create an entry for it and return it.  */\n \n static varinfo_t\n get_vi_for_tree (tree t)\n {\n-  tree_vi_t pair;\n-  struct tree_vi finder;\n-\n-  finder.t = t;\n-  pair = htab_find (vi_for_tree,  &finder);\n-  if (pair == NULL)\n+  void **slot = pointer_map_contains (vi_for_tree, t);\n+  if (slot == NULL)\n     return get_varinfo (create_variable_info_for (t, alias_get_name (t)));\n \n-  return pair->vi;\n+  return (varinfo_t) *slot;\n }\n \n /* Get a constraint expression from an SSA_VAR_P node.  */\n@@ -4383,9 +4343,9 @@ find_what_p_points_to (tree p)\n       && SSA_NAME_IS_DEFAULT_DEF (p))\n     lookup_p = SSA_NAME_VAR (p);\n \n-  if (lookup_vi_for_tree (lookup_p, &vi))\n+  vi = lookup_vi_for_tree (lookup_p);\n+  if (vi)\n     {\n-\n       if (vi->is_artificial_var)\n \treturn false;\n \n@@ -4633,7 +4593,7 @@ init_alias_vars (void)\n \t\t\t\t\t  sizeof (struct variable_info), 30);\n   constraints = VEC_alloc (constraint_t, heap, 8);\n   varmap = VEC_alloc (varinfo_t, heap, 8);\n-  vi_for_tree = htab_create (10, tree_vi_hash, tree_vi_eq, free);\n+  vi_for_tree = pointer_map_create ();\n \n   memset (&stats, 0, sizeof (stats));\n \n@@ -4774,7 +4734,7 @@ delete_points_to_sets (void)\n     fprintf (dump_file, \"Points to sets created:%d\\n\",\n \t     stats.points_to_sets_created);\n \n-  htab_delete (vi_for_tree);\n+  pointer_map_destroy (vi_for_tree);\n   bitmap_obstack_release (&pta_obstack);\n   VEC_free (constraint_t, heap, constraints);\n "}]}