{"sha": "6162cec0d9ca47c71ab3b0effe544d53ce27e3c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE2MmNlYzBkOWNhNDdjNzFhYjNiMGVmZmU1NDRkNTNjZTI3ZTNjOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-09-25T20:27:37Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-09-25T20:27:37Z"}, "message": "trans.c (Loop_Statement_to_gnu): In the case of an iteration scheme...\n\n\t* gcc-interface/trans.c (Loop_Statement_to_gnu): In the case of an\n\titeration scheme, always generate the do-while form if optimization\n\tis enabled.  Use more straightforward test at the end.\n\nFrom-SVN: r179169", "tree": {"sha": "eb8dae879eeabcbdf2ae8b1757975f0d32a66047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb8dae879eeabcbdf2ae8b1757975f0d32a66047"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6162cec0d9ca47c71ab3b0effe544d53ce27e3c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6162cec0d9ca47c71ab3b0effe544d53ce27e3c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6162cec0d9ca47c71ab3b0effe544d53ce27e3c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6162cec0d9ca47c71ab3b0effe544d53ce27e3c8/comments", "author": null, "committer": null, "parents": [{"sha": "dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dee12fcd11764d3a1c2f5f6f8d00a2b17f1119ec"}], "stats": {"total": 165, "additions": 105, "deletions": 60}, "files": [{"sha": "ac679302bf6e7a9a3c36bc958ad1b41276ef7f62", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6162cec0d9ca47c71ab3b0effe544d53ce27e3c8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6162cec0d9ca47c71ab3b0effe544d53ce27e3c8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6162cec0d9ca47c71ab3b0effe544d53ce27e3c8", "patch": "@@ -1,3 +1,9 @@\n+2011-09-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (Loop_Statement_to_gnu): In the case of an\n+\titeration scheme, always generate the do-while form if optimization\n+\tis enabled.  Use more straightforward test at the end.\n+\n 2011-09-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Access_Subtype>: Use"}, {"sha": "2f41ad3309db418feac75a27a6bec8bbb7d24e3d", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 99, "deletions": 60, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6162cec0d9ca47c71ab3b0effe544d53ce27e3c8/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6162cec0d9ca47c71ab3b0effe544d53ce27e3c8/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=6162cec0d9ca47c71ab3b0effe544d53ce27e3c8", "patch": "@@ -218,6 +218,7 @@ static bool set_end_locus_from_node (tree, Node_Id);\n static void set_gnu_expr_location_from_node (tree, Node_Id);\n static int lvalue_required_p (Node_Id, tree, bool, bool, bool);\n static tree build_raise_check (int, enum exception_info_kind);\n+static tree create_init_temporary (const char *, tree, tree *, Node_Id);\n \n /* Hooks for debug info back-ends, only supported and used in a restricted set\n    of configurations.  */\n@@ -2161,8 +2162,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n   tree gnu_loop_stmt = build4 (LOOP_STMT, void_type_node, NULL_TREE,\n \t\t\t       NULL_TREE, NULL_TREE, NULL_TREE);\n   tree gnu_loop_label = create_artificial_label (input_location);\n-  tree gnu_loop_var = NULL_TREE, gnu_cond_expr = NULL_TREE;\n-  tree gnu_result;\n+  tree gnu_cond_expr = NULL_TREE, gnu_result;\n \n   /* Set location information for statement and end label.  */\n   set_expr_location_from_node (gnu_loop_stmt, gnat_node);\n@@ -2196,9 +2196,9 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n       tree gnu_high = TYPE_MAX_VALUE (gnu_type);\n       tree gnu_base_type = get_base_type (gnu_type);\n       tree gnu_one_node = convert (gnu_base_type, integer_one_node);\n-      tree gnu_first, gnu_last;\n+      tree gnu_loop_var, gnu_loop_iv, gnu_first, gnu_last, gnu_stmt;\n       enum tree_code update_code, test_code, shift_code;\n-      bool reverse = Reverse_Present (gnat_loop_spec), fallback = false;\n+      bool reverse = Reverse_Present (gnat_loop_spec), use_iv = false;\n \n       /* We must disable modulo reduction for the iteration variable, if any,\n \t in order for the loop comparison to be effective.  */\n@@ -2222,8 +2222,8 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n       /* We use two different strategies to translate the loop, depending on\n \t whether optimization is enabled.\n \n-\t If it is, we try to generate the canonical form of loop expected by\n-\t the loop optimizer, which is the do-while form:\n+\t If it is, we generate the canonical loop form expected by the loop\n+\t optimizer and the loop vectorizer, which is the do-while form:\n \n \t     ENTRY_COND\n \t   loop:\n@@ -2232,64 +2232,67 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \t     BOTTOM_COND\n \t     GOTO loop\n \n-\t This makes it possible to bypass loop header copying and to turn the\n-\t BOTTOM_COND into an inequality test.  This should catch (almost) all\n-\t loops with constant starting point.  If we cannot, we try to generate\n-\t the default form, which is:\n+\t This avoids an implicit dependency on loop header copying and makes\n+\t it possible to turn BOTTOM_COND into an inequality test.\n+\n+\t If optimization is disabled, loop header copying doesn't come into\n+\t play and we try to generate the loop form with the fewer conditional\n+\t branches.  First, the default form, which is:\n \n \t   loop:\n \t     TOP_COND\n \t     BODY\n \t     BOTTOM_UPDATE\n \t     GOTO loop\n \n-\t It will be rotated during loop header copying and an entry test added\n-\t to yield the do-while form.  This should catch (almost) all loops with\n-\t constant ending point.  If we cannot, we generate the fallback form:\n+\t It should catch most loops with constant ending point.  Then, if we\n+\t cannot, we try to generate the shifted form:\n \n-\t     ENTRY_COND\n \t   loop:\n+\t     TOP_COND\n+\t     TOP_UPDATE\n \t     BODY\n-\t     BOTTOM_COND\n-\t     BOTTOM_UPDATE\n \t     GOTO loop\n \n-\t which works in all cases but for which loop header copying will copy\n-\t the BOTTOM_COND, thus adding a third conditional branch.\n-\n-\t If optimization is disabled, loop header copying doesn't come into\n-\t play and we try to generate the loop forms with the less conditional\n-\t branches directly.  First, the default form, it should catch (almost)\n-\t all loops with constant ending point.  Then, if we cannot, we try to\n-\t generate the shifted form:\n+\t which should catch loops with constant starting point.  Otherwise, if\n+\t we cannot, we generate the fallback form:\n \n+\t     ENTRY_COND\n \t   loop:\n-\t     TOP_COND\n-\t     TOP_UPDATE\n \t     BODY\n+\t     BOTTOM_COND\n+\t     BOTTOM_UPDATE\n \t     GOTO loop\n \n-\t which should catch loops with constant starting point.  Otherwise, if\n-\t we cannot, we generate the fallback form.  */\n+\t which works in all cases.  */\n \n       if (optimize)\n \t{\n-\t  /* We can use the do-while form if GNU_FIRST-1 doesn't overflow.  */\n+\t  /* We can use the do-while form directly if GNU_FIRST-1 doesn't\n+\t     overflow.  */\n \t  if (!can_equal_min_val_p (gnu_first, gnu_base_type, reverse))\n-\t    {\n-\t      gnu_first = build_binary_op (shift_code, gnu_base_type,\n-\t\t\t\t\t   gnu_first, gnu_one_node);\n-\t      LOOP_STMT_TOP_UPDATE_P (gnu_loop_stmt) = 1;\n-\t      LOOP_STMT_BOTTOM_COND_P (gnu_loop_stmt) = 1;\n-\t    }\n-\n-\t  /* Otherwise, we can use the default form if GNU_LAST+1 doesn't.  */\n-\t  else if (!can_equal_max_val_p (gnu_last, gnu_base_type, reverse))\n \t    ;\n \n-\t  /* Otherwise, use the fallback form.  */\n+\t  /* Otherwise, use the do-while form with the help of a special\n+\t     induction variable in the (unsigned version of) the base\n+\t     type, in order to have wrap-around arithmetics for it.  */\n \t  else\n-\t    fallback = true;\n+\t    {\n+\t      if (!TYPE_UNSIGNED (gnu_base_type))\n+\t\t{\n+\t\t  gnu_base_type = gnat_unsigned_type (gnu_base_type);\n+\t\t  gnu_first = convert (gnu_base_type, gnu_first);\n+\t\t  gnu_last = convert (gnu_base_type, gnu_last);\n+\t\t  gnu_one_node = convert (gnu_base_type, integer_one_node);\n+\t\t}\n+\t      use_iv = true;\n+\t    }\n+\n+\t  gnu_first\n+\t    = build_binary_op (shift_code, gnu_base_type, gnu_first,\n+\t\t\t       gnu_one_node);\n+\t  LOOP_STMT_TOP_UPDATE_P (gnu_loop_stmt) = 1;\n+\t  LOOP_STMT_BOTTOM_COND_P (gnu_loop_stmt) = 1;\n \t}\n       else\n \t{\n@@ -2302,21 +2305,20 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \t  else if (!can_equal_min_val_p (gnu_first, gnu_base_type, reverse)\n \t\t   && !can_equal_min_val_p (gnu_last, gnu_base_type, reverse))\n \t    {\n-\t      gnu_first = build_binary_op (shift_code, gnu_base_type,\n-\t\t\t\t\t   gnu_first, gnu_one_node);\n-\t      gnu_last = build_binary_op (shift_code, gnu_base_type,\n-\t\t\t\t          gnu_last, gnu_one_node);\n+\t      gnu_first\n+\t\t= build_binary_op (shift_code, gnu_base_type, gnu_first,\n+\t\t\t\t   gnu_one_node);\n+\t      gnu_last\n+\t\t= build_binary_op (shift_code, gnu_base_type, gnu_last,\n+\t\t\t\t   gnu_one_node);\n \t      LOOP_STMT_TOP_UPDATE_P (gnu_loop_stmt) = 1;\n \t    }\n \n \t  /* Otherwise, use the fallback form.  */\n \t  else\n-\t    fallback = true;\n+\t    LOOP_STMT_BOTTOM_COND_P (gnu_loop_stmt) = 1;\n \t}\n \n-      if (fallback)\n-\tLOOP_STMT_BOTTOM_COND_P (gnu_loop_stmt) = 1;\n-\n       /* If we use the BOTTOM_COND, we can turn the test into an inequality\n \t test but we may have to add ENTRY_COND to protect the empty loop.  */\n       if (LOOP_STMT_BOTTOM_COND_P (gnu_loop_stmt))\n@@ -2338,6 +2340,19 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n       start_stmt_group ();\n       gnat_pushlevel ();\n \n+      /* If we use the special induction variable, create it and set it to\n+\t its initial value.  Morever, the regular iteration variable cannot\n+\t itself be initialized, lest the initial value wrapped around.  */\n+      if (use_iv)\n+\t{\n+\t  gnu_loop_iv\n+\t    = create_init_temporary (\"I\", gnu_first, &gnu_stmt, gnat_loop_var);\n+\t  add_stmt (gnu_stmt);\n+\t  gnu_first = NULL_TREE;\n+\t}\n+      else\n+\tgnu_loop_iv = NULL_TREE;\n+\n       /* Declare the iteration variable and set it to its initial value.  */\n       gnu_loop_var = gnat_to_gnu_entity (gnat_loop_var, gnu_first, 1);\n       if (DECL_BY_REF_P (gnu_loop_var))\n@@ -2347,18 +2362,42 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n       gnu_loop_var = convert (gnu_base_type, gnu_loop_var);\n \n       /* Set either the top or bottom exit condition.  */\n-      LOOP_STMT_COND (gnu_loop_stmt)\n-\t= build_binary_op (test_code, boolean_type_node, gnu_loop_var,\n-\t\t\t   gnu_last);\n+      if (use_iv)\n+        LOOP_STMT_COND (gnu_loop_stmt)\n+\t  = build_binary_op (test_code, boolean_type_node, gnu_loop_iv,\n+\t\t\t     gnu_last);\n+      else\n+        LOOP_STMT_COND (gnu_loop_stmt)\n+\t  = build_binary_op (test_code, boolean_type_node, gnu_loop_var,\n+\t\t\t     gnu_last);\n \n       /* Set either the top or bottom update statement and give it the source\n \t location of the iteration for better coverage info.  */\n-      LOOP_STMT_UPDATE (gnu_loop_stmt)\n-\t= build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_loop_var,\n-\t\t\t   build_binary_op (update_code, gnu_base_type,\n-\t\t\t\t\t    gnu_loop_var, gnu_one_node));\n-      set_expr_location_from_node (LOOP_STMT_UPDATE (gnu_loop_stmt),\n-\t\t\t\t   gnat_iter_scheme);\n+      if (use_iv)\n+\t{\n+\t  gnu_stmt\n+\t    = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_loop_iv,\n+\t\t\t       build_binary_op (update_code, gnu_base_type,\n+\t\t\t\t\t\tgnu_loop_iv, gnu_one_node));\n+\t  set_expr_location_from_node (gnu_stmt, gnat_iter_scheme);\n+\t  append_to_statement_list (gnu_stmt,\n+\t\t\t\t    &LOOP_STMT_UPDATE (gnu_loop_stmt));\n+\t  gnu_stmt\n+\t    = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_loop_var,\n+\t\t\t       gnu_loop_iv);\n+\t  set_expr_location_from_node (gnu_stmt, gnat_iter_scheme);\n+\t  append_to_statement_list (gnu_stmt,\n+\t\t\t\t    &LOOP_STMT_UPDATE (gnu_loop_stmt));\n+\t}\n+      else\n+\t{\n+\t  gnu_stmt\n+\t    = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_loop_var,\n+\t\t\t       build_binary_op (update_code, gnu_base_type,\n+\t\t\t\t\t\tgnu_loop_var, gnu_one_node));\n+\t  set_expr_location_from_node (gnu_stmt, gnat_iter_scheme);\n+\t  LOOP_STMT_UPDATE (gnu_loop_stmt) = gnu_stmt;\n+\t}\n     }\n \n   /* If the loop was named, have the name point to this loop.  In this case,\n@@ -2372,9 +2411,9 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n     = build_stmt_group (Statements (gnat_node), true);\n   TREE_SIDE_EFFECTS (gnu_loop_stmt) = 1;\n \n-  /* If we declared a variable, then we are in a statement group for that\n-     declaration.  Add the LOOP_STMT to it and make that the \"loop\".  */\n-  if (gnu_loop_var)\n+  /* If we have an iteration scheme, then we are in a statement group.  Add\n+     the LOOP_STMT to it, finish it and make it the \"loop\".  */\n+  if (Present (gnat_iter_scheme) && No (Condition (gnat_iter_scheme)))\n     {\n       add_stmt (gnu_loop_stmt);\n       gnat_poplevel ();"}]}