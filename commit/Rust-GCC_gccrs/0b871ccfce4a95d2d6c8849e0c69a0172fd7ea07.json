{"sha": "0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI4NzFjY2ZjZTRhOTVkMmQ2Yzg4NDllMGM2OWEwMTcyZmQ3ZWEwNw==", "commit": {"author": {"name": "Yuri Rumyantsev", "email": "yuri.s.rumyantsev@intel.com", "date": "2013-05-30T10:10:21Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2013-05-30T10:10:21Z"}, "message": "Silvermont (SLM) architecture pipeline model, tuning and insn selection.\n\n        Silvermont (SLM) architecture pipeline model, tuning and\n        insn selection.\n        * config.gcc: Add slm config options and target.\n\n        * config/i386/slm.md: New.\n\n        * config/i386/driver-i386.c (host_detect_local_cpu): Check movbe.\n\n        * gcc/config/i386/i386-c.c (ix86_target_macros_internal):  New case\n        PROCESSOR_SLM.\n        (ix86_target_macros_internal): Likewise.\n\n        * gcc/config/i386/i386.c (slm_cost): New cost.\n        (m_SLM): New macro flag.\n        (initial_ix86_tune_features): Set m_SLM.\n        (x86_accumulate_outgoing_args): Likewise.\n        (x86_arch_always_fancy_math_387): Likewise.\n        (processor_target_table): Add slm cost.\n        (cpu_names): Add slm cpu name.\n        (x86_option_override_internal): Set SLM ISA.\n        (ix86_issue_rate): New case PROCESSOR_SLM.\n        (ia32_multipass_dfa_lookahead): Likewise.\n        (fold_builtin_cpu): Add slm.\n\n        * config/i386/i386.h (TARGET_SLM): New target macro.\n        (target_cpu_default): Add TARGET_CPU_DEFAULT_slm.\n        (processor_type): Add PROCESSOR_SLM.\n\n        * config/i386/i386.md (cpu): Add new value \"slm\".\n        (slm.md): Include slm.md.\n\n        * libgcc/config/i386/cpuinfo.c (INTEL_SLM): New enum value.\n\n\nCo-Authored-By: Igor Zamyatin <igor.zamyatin@intel.com>\n\nFrom-SVN: r199444", "tree": {"sha": "0dc5a1becfc78111732c177d3e6945ad05128393", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0dc5a1becfc78111732c177d3e6945ad05128393"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/comments", "author": null, "committer": null, "parents": [{"sha": "24d5b0970a7d07a30430b17b2a837832c3b1b38e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24d5b0970a7d07a30430b17b2a837832c3b1b38e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24d5b0970a7d07a30430b17b2a837832c3b1b38e"}], "stats": {"total": 970, "additions": 937, "deletions": 33}, "files": [{"sha": "8b27ecc44c7bd9bd7b46e921444d1dec575d50ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07", "patch": "@@ -1,3 +1,39 @@\n+2013-05-30  Yuri Rumyantsev  <yuri.s.rumyantsev@intel.com>\n+\t    Igor Zamyatin  <igor.zamyatin@intel.com>\n+\n+\tSilvermont (SLM) architecture pipeline model, tuning and\n+\tinsn selection.\n+\t* config.gcc: Add slm config options and target.\n+\n+\t* config/i386/slm.md: New.\n+\n+\t* config/i386/driver-i386.c (host_detect_local_cpu): Check movbe.\n+\n+\t* gcc/config/i386/i386-c.c (ix86_target_macros_internal):  New case\n+\tPROCESSOR_SLM.\n+\t(ix86_target_macros_internal): Likewise.\n+\n+\t* gcc/config/i386/i386.c (slm_cost): New cost.\n+\t(m_SLM): New macro flag.\n+\t(initial_ix86_tune_features): Set m_SLM.\n+\t(x86_accumulate_outgoing_args): Likewise.\n+\t(x86_arch_always_fancy_math_387): Likewise.\n+\t(processor_target_table): Add slm cost.\n+\t(cpu_names): Add slm cpu name.\n+\t(x86_option_override_internal): Set SLM ISA.\n+\t(ix86_issue_rate): New case PROCESSOR_SLM.\n+\t(ia32_multipass_dfa_lookahead): Likewise.\n+\t(fold_builtin_cpu): Add slm.\n+\n+\t* config/i386/i386.h (TARGET_SLM): New target macro.\n+\t(target_cpu_default): Add TARGET_CPU_DEFAULT_slm.\n+\t(processor_type): Add PROCESSOR_SLM.\n+\n+\t* config/i386/i386.md (cpu): Add new value \"slm\".\n+\t(slm.md): Include slm.md.\n+\n+\t* libgcc/config/i386/cpuinfo.c (INTEL_SLM): New enum value.\n+\n 2013-05-30  Bernd Schmidt  <bernds@codesourcery.com>\n \t    Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n "}, {"sha": "a3dc2a9c78145f30c40f67c6564c01d25cae4c5f", "filename": "gcc/config.gcc", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07", "patch": "@@ -1293,7 +1293,7 @@ i[34567]86-*-linux* | i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-knetbsd*-gnu | i\n \t\t\tTM_MULTILIB_CONFIG=`echo $TM_MULTILIB_CONFIG | sed 's/^,//'`\n \t\t\tneed_64bit_isa=yes\n \t\t\tcase X\"${with_cpu}\" in\n-\t\t\tXgeneric|Xatom|Xcore2|Xcorei7|Xcorei7-avx|Xnocona|Xx86-64|Xbdver3|Xbdver2|Xbdver1|Xbtver2|Xbtver1|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx|Xathlon64-sse3|Xk8-sse3|Xopteron-sse3)\t\t\t\n+\t\t\tXgeneric|Xatom|Xslm|Xcore2|Xcorei7|Xcorei7-avx|Xnocona|Xx86-64|Xbdver3|Xbdver2|Xbdver1|Xbtver2|Xbtver1|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx|Xathlon64-sse3|Xk8-sse3|Xopteron-sse3)\t\t\t\n \t\t\t\t;;\n \t\t\tX)\n \t\t\t\tif test x$with_cpu_64 = x; then\n@@ -1302,7 +1302,7 @@ i[34567]86-*-linux* | i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-knetbsd*-gnu | i\n \t\t\t\t;;\n \t\t\t*)\n \t\t\t\techo \"Unsupported CPU used in --with-cpu=$with_cpu, supported values:\" 1>&2\n-\t\t\t\techo \"generic atom core2 corei7 corei7-avx nocona x86-64 bdver3 bdver2 bdver1 btver2 btver1 amdfam10 barcelona k8 opteron athlon64 athlon-fx athlon64-sse3 k8-sse3 opteron-sse3\" 1>&2\n+\t\t\t\techo \"generic atom slm core2 corei7 corei7-avx nocona x86-64 bdver3 bdver2 bdver1 btver2 btver1 amdfam10 barcelona k8 opteron athlon64 athlon-fx athlon64-sse3 k8-sse3 opteron-sse3\" 1>&2\n \t\t\t\texit 1\n \t\t\t\t;;\n \t\t\tesac\n@@ -1414,7 +1414,7 @@ i[34567]86-*-solaris2* | x86_64-*-solaris2.1[0-9]*)\n \t\ttmake_file=\"$tmake_file i386/t-sol2-64\"\n \t\tneed_64bit_isa=yes\n \t\tcase X\"${with_cpu}\" in\n-\t\tXgeneric|Xatom|Xcore2|Xcorei7|Xcorei7-avx|Xnocona|Xx86-64|Xbdver3|Xbdver2|Xbdver1|Xbtver2|Xbtver1|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx|Xathlon64-sse3|Xk8-sse3|Xopteron-sse3)\n+\t\tXgeneric|Xatom|Xslm|Xcore2|Xcorei7|Xcorei7-avx|Xnocona|Xx86-64|Xbdver3|Xbdver2|Xbdver1|Xbtver2|Xbtver1|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx|Xathlon64-sse3|Xk8-sse3|Xopteron-sse3)\n \t\t\t;;\n \t\tX)\n \t\t\tif test x$with_cpu_64 = x; then\n@@ -1423,7 +1423,7 @@ i[34567]86-*-solaris2* | x86_64-*-solaris2.1[0-9]*)\n \t\t\t;;\n \t\t*)\n \t\t\techo \"Unsupported CPU used in --with-cpu=$with_cpu, supported values:\" 1>&2\n-\t\t\techo \"generic atom core2 corei7 corei7-avx nocona x86-64 bdver3 bdver2 bdver1 btver2 btver1 amdfam10 barcelona k8 opteron athlon64 athlon-fx athlon64-sse3 k8-sse3 opteron-sse3\" 1>&2\n+\t\t\techo \"generic atom slm core2 corei7 corei7-avx nocona x86-64 bdver3 bdver2 bdver1 btver2 btver1 amdfam10 barcelona k8 opteron athlon64 athlon-fx athlon64-sse3 k8-sse3 opteron-sse3\" 1>&2\n \t\t\texit 1\n \t\t\t;;\n \t\tesac\n@@ -1496,7 +1496,7 @@ i[34567]86-*-mingw* | x86_64-*-mingw*)\n \t\t\tif test x$enable_targets = xall; then\n \t\t\t\ttm_defines=\"${tm_defines} TARGET_BI_ARCH=1\"\n \t\t\t\tcase X\"${with_cpu}\" in\n-\t\t\t\tXgeneric|Xatom|Xcore2|Xcorei7|Xcorei7-avx|Xnocona|Xx86-64|Xbdver3|Xbdver2|Xbdver1|Xbtver2|Xbtver1|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx|Xathlon64-sse3|Xk8-sse3|Xopteron-sse3)\n+\t\t\t\tXgeneric|Xatom|Xslm|Xcore2|Xcorei7|Xcorei7-avx|Xnocona|Xx86-64|Xbdver3|Xbdver2|Xbdver1|Xbtver2|Xbtver1|Xamdfam10|Xbarcelona|Xk8|Xopteron|Xathlon64|Xathlon-fx|Xathlon64-sse3|Xk8-sse3|Xopteron-sse3)\n \t\t\t\t\t;;\n \t\t\t\tX)\n \t\t\t\t\tif test x$with_cpu_64 = x; then\n@@ -1505,7 +1505,7 @@ i[34567]86-*-mingw* | x86_64-*-mingw*)\n \t\t\t\t\t;;\n \t\t\t\t*)\n \t\t\t\t\techo \"Unsupported CPU used in --with-cpu=$with_cpu, supported values:\" 1>&2\n-\t\t\t\t\techo \"generic atom core2 corei7 Xcorei7-avx nocona x86-64 bdver3 bdver2 bdver1 btver2 btver1 amdfam10 barcelona k8 opteron athlon64 athlon-fx athlon64-sse3 k8-sse3 opteron-sse3\" 1>&2\n+\t\t\t\t\techo \"generic atom slm core2 corei7 Xcorei7-avx nocona x86-64 bdver3 bdver2 bdver1 btver2 btver1 amdfam10 barcelona k8 opteron athlon64 athlon-fx athlon64-sse3 k8-sse3 opteron-sse3\" 1>&2\n \t\t\t\t\texit 1\n \t\t\t\t\t;;\n \t\t\t\tesac\n@@ -2848,6 +2848,10 @@ case ${target} in\n \tarch=atom\n \tcpu=atom\n \t;;\n+      slm-*)\n+\tarch=slm\n+\tcpu=slm\n+\t;;\n       core2-*)\n \tarch=core2\n \tcpu=core2\n@@ -2919,6 +2923,10 @@ case ${target} in\n \tarch=atom\n \tcpu=atom\n \t;;\n+      slm-*)\n+\tarch=slm\n+\tcpu=slm\n+\t;;\n       core2-*)\n \tarch=core2\n \tcpu=core2\n@@ -3422,7 +3430,7 @@ case \"${target}\" in\n \t\t\t| k8 | k8-sse3 | athlon64 | athlon64-sse3 | opteron \\\n \t\t\t| opteron-sse3 | athlon-fx | bdver3 | bdver2 | bdver1 | btver2 \\\n \t\t\t| btver1 | amdfam10 | barcelona | nocona | core2 | corei7 \\\n-\t\t\t| corei7-avx | core-avx-i | core-avx2 | atom)\n+\t\t\t| corei7-avx | core-avx-i | core-avx2 | atom | slm)\n \t\t\t\t# OK\n \t\t\t\t;;\n \t\t\t*)"}, {"sha": "249c4cd1d53d239c54345e9e9e7a47443e37c191", "filename": "gcc/config/i386/driver-i386.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdriver-i386.c?ref=0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07", "patch": "@@ -674,8 +674,14 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n \t\t/* Assume Sandy Bridge.  */\n \t\tcpu = \"corei7-avx\";\n \t      else if (has_sse4_2)\n-\t\t/* Assume Core i7.  */\n-\t\tcpu = \"corei7\";\n+\t\t{\n+\t\t  if (has_movbe)\n+\t\t    /* Assume SLM.  */\n+\t\t    cpu = \"slm\";\n+\t\t  else\n+\t\t    /* Assume Core i7.  */\n+\t\t    cpu = \"corei7\";\n+\t\t}\n \t      else if (has_ssse3)\n \t\t{\n \t\t  if (has_movbe)"}, {"sha": "ef1e1eb3c62405fc19a4cc1cad97e173c910f732", "filename": "gcc/config/i386/i386-c.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/gcc%2Fconfig%2Fi386%2Fi386-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/gcc%2Fconfig%2Fi386%2Fi386-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.c?ref=0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07", "patch": "@@ -149,6 +149,10 @@ ix86_target_macros_internal (HOST_WIDE_INT isa_flag,\n       def_or_undef (parse_in, \"__atom\");\n       def_or_undef (parse_in, \"__atom__\");\n       break;\n+    case PROCESSOR_SLM:\n+      def_or_undef (parse_in, \"__slm\");\n+      def_or_undef (parse_in, \"__slm__\");\n+      break;\n     /* use PROCESSOR_max to not set/unset the arch macro.  */\n     case PROCESSOR_max:\n       break;\n@@ -241,6 +245,9 @@ ix86_target_macros_internal (HOST_WIDE_INT isa_flag,\n     case PROCESSOR_ATOM:\n       def_or_undef (parse_in, \"__tune_atom__\");\n       break;\n+    case PROCESSOR_SLM:\n+      def_or_undef (parse_in, \"__tune_slm__\");\n+      break;\n     case PROCESSOR_GENERIC32:\n     case PROCESSOR_GENERIC64:\n       break;"}, {"sha": "c37108b81bd6e59ce6fd23fd62d73962bdccf2dd", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 107, "deletions": 23, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07", "patch": "@@ -1482,6 +1482,79 @@ struct processor_costs atom_cost = {\n   1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n };\n \n+static const\n+struct processor_costs slm_cost = {\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n+  COSTS_N_INSNS (1) + 1,\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (2)},\t\t\t/*\t\t\t      other */\n+  0,\t\t\t\t\t/* cost of multiply per each bit set */\n+  {COSTS_N_INSNS (18),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (26),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (42),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (74),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (74)},\t\t\t/*\t\t\t    other */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n+  8,\t\t\t\t\t/* \"large\" insn */\n+  17,\t\t\t\t\t/* MOVE_RATIO */\n+  4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {4, 4, 4},\t\t\t\t/* cost of storing integer registers */\n+  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {12, 12, 12},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {6, 6, 8},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {8, 8},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {8, 8},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2,\t\t\t\t\t/* cost of moving SSE register */\n+  {8, 8, 8},\t\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  {8, 8, 8},\t\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  5,\t\t\t\t\t/* MMX or SSE register to integer */\n+  32,\t\t\t\t\t/* size of l1 cache.  */\n+  256,\t\t\t\t\t/* size of l2 cache.  */\n+  64,\t\t\t\t\t/* size of prefetch block */\n+  6,\t\t\t\t\t/* number of parallel prefetches */\n+  3,\t\t\t\t\t/* Branch cost */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FADD and FSUB insns.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FMUL instruction.  */\n+  COSTS_N_INSNS (20),\t\t\t/* cost of FDIV instruction.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n+  COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n+  {{libcall, {{11, loop, false}, {-1, rep_prefix_4_byte, false}}},\n+   {libcall, {{32, loop, false}, {64, rep_prefix_4_byte, false},\n+          {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}},\n+  {{libcall, {{8, loop, false}, {15, unrolled_loop, false},\n+          {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+   {libcall, {{24, loop, false}, {32, unrolled_loop, false},\n+          {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}},\n+  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  1,\t\t\t\t\t/* scalar load_cost.  */\n+  1,\t\t\t\t\t/* scalar_store_cost.  */\n+  1,\t\t\t\t\t/* vec_stmt_cost.  */\n+  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  1,\t\t\t\t\t/* vec_align_load_cost.  */\n+  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  1,\t\t\t\t\t/* vec_store_cost.  */\n+  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n+};\n+\n /* Generic64 should produce code tuned for Nocona and K8.  */\n static const\n struct processor_costs generic64_cost = {\n@@ -1735,6 +1808,7 @@ const struct processor_costs *ix86_cost = &pentium_cost;\n #define m_HASWELL (1<<PROCESSOR_HASWELL)\n #define m_CORE_ALL (m_CORE2 | m_COREI7  | m_HASWELL)\n #define m_ATOM (1<<PROCESSOR_ATOM)\n+#define m_SLM (1<<PROCESSOR_SLM)\n \n #define m_GEODE (1<<PROCESSOR_GEODE)\n #define m_K6 (1<<PROCESSOR_K6)\n@@ -1778,7 +1852,7 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n   m_486 | m_PENT,\n \n   /* X86_TUNE_UNROLL_STRLEN */\n-  m_486 | m_PENT | m_PPRO | m_ATOM | m_CORE_ALL | m_K6 | m_AMD_MULTIPLE | m_GENERIC,\n+  m_486 | m_PENT | m_PPRO | m_ATOM | m_SLM | m_CORE_ALL | m_K6 | m_AMD_MULTIPLE | m_GENERIC,\n \n   /* X86_TUNE_BRANCH_PREDICTION_HINTS: Branch hints were put in P4 based\n      on simulation result. But after P4 was made, no performance benefit\n@@ -1790,11 +1864,11 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n   ~m_386,\n \n   /* X86_TUNE_USE_SAHF */\n-  m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_K6_GEODE | m_K8 | m_AMDFAM10 | m_BDVER | m_BTVER | m_GENERIC,\n+  m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_SLM | m_K6_GEODE | m_K8 | m_AMDFAM10 | m_BDVER | m_BTVER | m_GENERIC,\n \n   /* X86_TUNE_MOVX: Enable to zero extend integer registers to avoid\n      partial dependencies.  */\n-  m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_GEODE | m_AMD_MULTIPLE  | m_GENERIC,\n+  m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_SLM | m_GEODE | m_AMD_MULTIPLE  | m_GENERIC,\n \n   /* X86_TUNE_PARTIAL_REG_STALL: We probably ought to watch for partial\n      register stalls on Generic32 compilation setting as well.  However\n@@ -1817,13 +1891,13 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n   m_386 | m_486 | m_K6_GEODE,\n \n   /* X86_TUNE_USE_SIMODE_FIOP */\n-  ~(m_PENT | m_PPRO | m_CORE_ALL | m_ATOM | m_AMD_MULTIPLE | m_GENERIC),\n+  ~(m_PENT | m_PPRO | m_CORE_ALL | m_ATOM | m_SLM | m_AMD_MULTIPLE | m_GENERIC),\n \n   /* X86_TUNE_USE_MOV0 */\n   m_K6,\n \n   /* X86_TUNE_USE_CLTD */\n-  ~(m_PENT | m_ATOM | m_K6),\n+  ~(m_PENT | m_ATOM | m_SLM | m_K6),\n \n   /* X86_TUNE_USE_XCHGB: Use xchgb %rh,%rl instead of rolw/rorw $8,rx.  */\n   m_PENT4,\n@@ -1838,7 +1912,7 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n   ~(m_PENT | m_PPRO),\n \n   /* X86_TUNE_PROMOTE_QIMODE */\n-  m_386 | m_486 | m_PENT | m_CORE_ALL | m_ATOM | m_K6_GEODE | m_AMD_MULTIPLE | m_GENERIC,\n+  m_386 | m_486 | m_PENT | m_CORE_ALL | m_ATOM | m_SLM | m_K6_GEODE | m_AMD_MULTIPLE | m_GENERIC,\n \n   /* X86_TUNE_FAST_PREFIX */\n   ~(m_386 | m_486 | m_PENT),\n@@ -1879,10 +1953,10 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n \n   /* X86_TUNE_INTEGER_DFMODE_MOVES: Enable if integer moves are preferred\n      for DFmode copies */\n-  ~(m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_GEODE | m_AMD_MULTIPLE | m_ATOM | m_GENERIC),\n+  ~(m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_SLM | m_GEODE | m_AMD_MULTIPLE | m_GENERIC),\n \n   /* X86_TUNE_PARTIAL_REG_DEPENDENCY */\n-  m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_AMD_MULTIPLE | m_GENERIC,\n+  m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_SLM | m_AMD_MULTIPLE | m_GENERIC,\n \n   /* X86_TUNE_SSE_PARTIAL_REG_DEPENDENCY: In the Generic model we have a\n      conflict here in between PPro/Pentium4 based chips that thread 128bit\n@@ -1893,13 +1967,13 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n      shows that disabling this option on P4 brings over 20% SPECfp regression,\n      while enabling it on K8 brings roughly 2.4% regression that can be partly\n      masked by careful scheduling of moves.  */\n-  m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_ATOM  | m_AMDFAM10 | m_BDVER | m_GENERIC,\n+  m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_SLM | m_AMDFAM10 | m_BDVER | m_GENERIC,\n \n   /* X86_TUNE_SSE_UNALIGNED_LOAD_OPTIMAL */\n-  m_COREI7 | m_AMDFAM10 | m_BDVER | m_BTVER,\n+  m_COREI7 | m_AMDFAM10 | m_BDVER | m_BTVER | m_SLM,\n \n   /* X86_TUNE_SSE_UNALIGNED_STORE_OPTIMAL */\n-  m_COREI7 | m_BDVER,\n+  m_COREI7 | m_BDVER | m_SLM,\n \n   /* X86_TUNE_SSE_PACKED_SINGLE_INSN_OPTIMAL */\n   m_BDVER ,\n@@ -1917,7 +1991,7 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n   m_PPRO | m_P4_NOCONA,\n \n   /* X86_TUNE_MEMORY_MISMATCH_STALL */\n-  m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_AMD_MULTIPLE | m_GENERIC,\n+  m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_SLM | m_AMD_MULTIPLE | m_GENERIC,\n \n   /* X86_TUNE_PROLOGUE_USING_MOVE */\n   m_PPRO | m_ATHLON_K8,\n@@ -1942,16 +2016,16 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n \n   /* X86_TUNE_FOUR_JUMP_LIMIT: Some CPU cores are not able to predict more\n      than 4 branch instructions in the 16 byte window.  */\n-  m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_AMD_MULTIPLE | m_GENERIC,\n+  m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_SLM | m_AMD_MULTIPLE | m_GENERIC,\n \n   /* X86_TUNE_SCHEDULE */\n-  m_PENT | m_PPRO | m_CORE_ALL | m_ATOM | m_K6_GEODE | m_AMD_MULTIPLE | m_GENERIC,\n+  m_PENT | m_PPRO | m_CORE_ALL | m_ATOM | m_SLM | m_K6_GEODE | m_AMD_MULTIPLE | m_GENERIC,\n \n   /* X86_TUNE_USE_BT */\n-  m_CORE_ALL | m_ATOM | m_AMD_MULTIPLE | m_GENERIC,\n+  m_CORE_ALL | m_ATOM | m_SLM | m_AMD_MULTIPLE | m_GENERIC,\n \n   /* X86_TUNE_USE_INCDEC */\n-  ~(m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_GENERIC),\n+  ~(m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_SLM | m_GENERIC),\n \n   /* X86_TUNE_PAD_RETURNS */\n   m_CORE_ALL | m_AMD_MULTIPLE | m_GENERIC,\n@@ -1960,7 +2034,7 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n   m_ATOM,\n \n   /* X86_TUNE_EXT_80387_CONSTANTS */\n-  m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_K6_GEODE | m_ATHLON_K8 | m_GENERIC,\n+  m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_SLM | m_K6_GEODE | m_ATHLON_K8 | m_GENERIC,\n \n   /* X86_TUNE_AVOID_VECTOR_DECODE */\n   m_CORE_ALL | m_K8 | m_GENERIC64,\n@@ -2005,7 +2079,7 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n \n   /* X86_TUNE_OPT_AGU: Optimize for Address Generation Unit. This flag\n      will impact LEA instruction selection. */\n-  m_ATOM,\n+  m_ATOM | m_SLM,\n \n   /* X86_TUNE_VECTORIZE_DOUBLE: Enable double precision vector\n      instructions.  */\n@@ -2026,7 +2100,7 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n \n   /* X86_TUNE_REASSOC_FP_TO_PARALLEL: Try to produce parallel computations\n      during reassociation of fp computation.  */\n-  m_ATOM | m_HASWELL | m_BDVER1 | m_BDVER2,\n+  m_ATOM | m_SLM | m_HASWELL | m_BDVER1 | m_BDVER2,\n \n   /* X86_TUNE_GENERAL_REGS_SSE_SPILL: Try to spill general regs to SSE\n      regs instead of memory.  */\n@@ -2060,10 +2134,10 @@ static unsigned int initial_ix86_arch_features[X86_ARCH_LAST] = {\n };\n \n static const unsigned int x86_accumulate_outgoing_args\n-  = m_PPRO | m_P4_NOCONA | m_ATOM | m_CORE_ALL | m_AMD_MULTIPLE | m_GENERIC;\n+  = m_PPRO | m_P4_NOCONA | m_ATOM | m_SLM | m_CORE_ALL | m_AMD_MULTIPLE | m_GENERIC;\n \n static const unsigned int x86_arch_always_fancy_math_387\n-  = m_PENT | m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_AMD_MULTIPLE | m_GENERIC;\n+  = m_PENT | m_PPRO | m_P4_NOCONA | m_CORE_ALL | m_ATOM | m_SLM | m_AMD_MULTIPLE | m_GENERIC;\n \n static const unsigned int x86_avx256_split_unaligned_load\n   = m_COREI7 | m_GENERIC;\n@@ -2458,7 +2532,8 @@ static const struct ptt processor_target_table[PROCESSOR_max] =\n   {&bdver3_cost, 16, 10, 16, 7, 11},\n   {&btver1_cost, 16, 10, 16, 7, 11},\n   {&btver2_cost, 16, 10, 16, 7, 11},\n-  {&atom_cost, 16, 15, 16, 7, 16}\n+  {&atom_cost, 16, 15, 16, 7, 16},\n+  {&slm_cost, 16, 15, 16, 7, 16}\n };\n \n static const char *const cpu_names[TARGET_CPU_DEFAULT_max] =\n@@ -2479,6 +2554,7 @@ static const char *const cpu_names[TARGET_CPU_DEFAULT_max] =\n   \"corei7\",\n   \"core-avx2\",\n   \"atom\",\n+  \"slm\",\n   \"geode\",\n   \"k6\",\n   \"k6-2\",\n@@ -2940,6 +3016,10 @@ ix86_option_override_internal (bool main_args_p)\n       {\"atom\", PROCESSOR_ATOM, CPU_ATOM,\n \tPTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3\n \t| PTA_SSSE3 | PTA_CX16 | PTA_MOVBE | PTA_FXSR},\n+      {\"slm\", PROCESSOR_SLM, CPU_SLM,\n+\tPTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3\n+\t| PTA_SSSE3 | PTA_SSE4_1 | PTA_SSE4_2 | PTA_CX16 | PTA_MOVBE\n+\t| PTA_FXSR},\n       {\"geode\", PROCESSOR_GEODE, CPU_GEODE,\n \tPTA_MMX | PTA_3DNOW | PTA_3DNOW_A | PTA_PREFETCH_SSE | PTA_PRFCHW},\n       {\"k6\", PROCESSOR_K6, CPU_K6, PTA_MMX},\n@@ -24199,6 +24279,7 @@ ix86_issue_rate (void)\n     {\n     case PROCESSOR_PENTIUM:\n     case PROCESSOR_ATOM:\n+    case PROCESSOR_SLM:\n     case PROCESSOR_K6:\n     case PROCESSOR_BTVER2:\n       return 2;\n@@ -24466,6 +24547,7 @@ ia32_multipass_dfa_lookahead (void)\n     case PROCESSOR_COREI7:\n     case PROCESSOR_HASWELL:\n     case PROCESSOR_ATOM:\n+    case PROCESSOR_SLM:\n       /* Generally, we want haifa-sched:max_issue() to look ahead as far\n \t as many instructions can be executed on a cycle, i.e.,\n \t issue_rate.  I wonder why tuning for many CPUs does not do this.  */\n@@ -24566,7 +24648,7 @@ ix86_sched_reorder(FILE *dump, int sched_verbose, rtx *ready, int *pn_ready,\n \t\t    continue;\n                   if (pro != insn)\n                     index = -1;\n-\t        }\n+                }\n               if (index >= 0)\n                 break;\n             }\n@@ -29752,6 +29834,7 @@ fold_builtin_cpu (tree fndecl, tree *args)\n     M_AMD,\n     M_CPU_TYPE_START,\n     M_INTEL_ATOM,\n+    M_INTEL_SLM,\n     M_INTEL_CORE2,\n     M_INTEL_COREI7,\n     M_AMDFAM10H,\n@@ -29778,6 +29861,7 @@ fold_builtin_cpu (tree fndecl, tree *args)\n       {\"amd\", M_AMD},\n       {\"intel\", M_INTEL},\n       {\"atom\", M_INTEL_ATOM},\n+      {\"slm\", M_INTEL_SLM},\n       {\"core2\", M_INTEL_CORE2},\n       {\"corei7\", M_INTEL_COREI7},\n       {\"nehalem\", M_INTEL_COREI7_NEHALEM},"}, {"sha": "776582a66de6c909d2e45179651186ef89e2057e", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07", "patch": "@@ -257,6 +257,7 @@ extern const struct processor_costs ix86_size_cost;\n #define TARGET_BTVER1 (ix86_tune == PROCESSOR_BTVER1)\n #define TARGET_BTVER2 (ix86_tune == PROCESSOR_BTVER2)\n #define TARGET_ATOM (ix86_tune == PROCESSOR_ATOM)\n+#define TARGET_SLM (ix86_tune == PROCESSOR_SLM)\n \n /* Feature tests against the various tunings.  */\n enum ix86_tune_indices {\n@@ -623,6 +624,7 @@ enum target_cpu_default\n   TARGET_CPU_DEFAULT_corei7,\n   TARGET_CPU_DEFAULT_haswell,\n   TARGET_CPU_DEFAULT_atom,\n+  TARGET_CPU_DEFAULT_slm,\n \n   TARGET_CPU_DEFAULT_geode,\n   TARGET_CPU_DEFAULT_k6,\n@@ -2131,6 +2133,7 @@ enum processor_type\n   PROCESSOR_BTVER1,\n   PROCESSOR_BTVER2,\n   PROCESSOR_ATOM,\n+  PROCESSOR_SLM,\n   PROCESSOR_max\n };\n "}, {"sha": "28b0c78093a5ff33bff0d5c157ef006485939ecf", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07", "patch": "@@ -323,7 +323,7 @@\n \f\n ;; Processor type.\n (define_attr \"cpu\" \"none,pentium,pentiumpro,geode,k6,athlon,k8,core2,corei7,\n- \t\t    atom,generic64,amdfam10,bdver1,bdver2,bdver3,btver1,btver2\"\n+\t\t    atom,slm,generic64,amdfam10,bdver1,bdver2,bdver3,btver1,btver2\"\n   (const (symbol_ref \"ix86_schedule\")))\n \n ;; A basic instruction type.  Refinements due to arguments to be\n@@ -964,6 +964,7 @@\n (include \"btver2.md\")\n (include \"geode.md\")\n (include \"atom.md\")\n+(include \"slm.md\")\n (include \"core2.md\")\n \n \f"}, {"sha": "3ac919e372c0062edb1cd631362719e697c6b000", "filename": "gcc/config/i386/slm.md", "status": "added", "additions": 758, "deletions": 0, "changes": 758, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/gcc%2Fconfig%2Fi386%2Fslm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/gcc%2Fconfig%2Fi386%2Fslm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fslm.md?ref=0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07", "patch": "@@ -0,0 +1,758 @@\n+;; Slivermont(SLM) Scheduling\n+;; Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+;;\n+;; Silvermont has 2 out-of-order IEC, 2 in-order FEC and 1 in-order MEC.\n+\n+\n+(define_automaton \"slm\")\n+\n+;;  EU: Execution Unit\n+;;  Silvermont EUs are connected by port 0 or port 1.\n+\n+;;  SLM has two ports: port 0 and port 1 connecting to all execution units\n+(define_cpu_unit \"slm-port-0,slm-port-1\" \"slm\")\n+\n+(define_cpu_unit \"slm-ieu-0, slm-ieu-1,\n+                  slm-imul, slm-feu-0, slm-feu-1\"\n+                  \"slm\")\n+\n+(define_reservation \"slm-all-ieu\" \"(slm-ieu-0 + slm-ieu-1 + slm-imul)\")\n+(define_reservation \"slm-all-feu\" \"(slm-feu-0 + slm-feu-1)\")\n+(define_reservation \"slm-all-eu\" \"(slm-all-ieu + slm-all-feu)\")\n+(define_reservation \"slm-fp-0\" \"(slm-port-0 + slm-feu-0)\")\n+\n+;; Some EUs have duplicated copied and can be accessed via either\n+;; port 0 or port 1\n+;; (define_reservation \"slm-port-either\" \"(slm-port-0 | slm-port-1)\"\n+(define_reservation \"slm-port-dual\" \"(slm-port-0 + slm-port-1)\")\n+\n+;;; fmul insn can have 4 or 5 cycles latency\n+(define_reservation \"slm-fmul-5c\"\n+                    \"(slm-port-0 + slm-feu-0), slm-feu-0, nothing*3\")\n+(define_reservation \"slm-fmul-4c\" \"(slm-port-0 + slm-feu-0), nothing*3\")\n+\n+;;; fadd can has 3 cycles latency depends on instruction forms\n+(define_reservation \"slm-fadd-3c\" \"(slm-port-1 + slm-feu-1), nothing*2\")\n+(define_reservation \"slm-fadd-4c\"\n+                    \"(slm-port-1 + slm-feu-1), slm-feu-1, nothing*2\")\n+\n+;;; imul insn has 3 cycles latency for SI operands\n+(define_reservation \"slm-imul-32\"\n+                    \"(slm-port-1 + slm-imul), nothing*2\")\n+(define_reservation \"slm-imul-mem-32\"\n+                    \"(slm-port-1 + slm-imul + slm-port-0), nothing*2\")\n+;;; imul has 4 cycles latency for DI operands with 1/2 tput\n+(define_reservation \"slm-imul-64\"\n+                    \"(slm-port-1 + slm-imul), slm-imul, nothing*2\")\n+\n+;;; dual-execution instructions can have 1,2,4,5 cycles latency depends on\n+;;; instruction forms\n+(define_reservation \"slm-dual-1c\" \"(slm-port-dual + slm-all-eu)\")\n+(define_reservation \"slm-dual-2c\"\n+                    \"(slm-port-dual + slm-all-eu, nothing)\")\n+\n+;;; Most of simple ALU instructions have 1 cycle latency. Some of them\n+;;; issue in port 0, some in port 0 and some in either port.\n+(define_reservation \"slm-simple-0\" \"(slm-port-0 + slm-ieu-0)\")\n+(define_reservation \"slm-simple-1\" \"(slm-port-1 + slm-ieu-1)\")\n+(define_reservation \"slm-simple-either\" \"(slm-simple-0 | slm-simple-1)\")\n+\n+;;; Complex macro-instruction has variants of latency, and uses both ports.\n+(define_reservation \"slm-complex\" \"(slm-port-dual + slm-all-eu)\")\n+\n+(define_insn_reservation  \"slm_other\" 9\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"other\")\n+            (eq_attr \"atom_unit\" \"!jeu\")))\n+  \"slm-complex, slm-all-eu*8\")\n+\n+;; return has type \"other\" with atom_unit \"jeu\"\n+(define_insn_reservation  \"slm_other_2\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"other\")\n+            (eq_attr \"atom_unit\" \"jeu\")))\n+  \"slm-dual-1c\")\n+\n+(define_insn_reservation  \"slm_multi\" 9\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (eq_attr \"type\" \"multi\"))\n+  \"slm-complex, slm-all-eu*8\")\n+\n+;; Normal alu insns without carry\n+(define_insn_reservation  \"slm_alu\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"alu\")\n+            (and (eq_attr \"memory\" \"none\")\n+                 (eq_attr \"use_carry\" \"0\"))))\n+  \"slm-simple-either\")\n+\n+;; Normal alu insns without carry, but use MEC.\n+(define_insn_reservation  \"slm_alu_mem\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"alu\")\n+            (and (eq_attr \"memory\" \"!none\")\n+                 (eq_attr \"use_carry\" \"0\"))))\n+  \"slm-simple-either\")\n+\n+;; Alu insn consuming CF, such as add/sbb\n+(define_insn_reservation  \"slm_alu_carry\" 2\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"alu\")\n+            (and (eq_attr \"memory\" \"none\")\n+                 (eq_attr \"use_carry\" \"1\"))))\n+  \"slm-simple-either, nothing\")\n+\n+;; Alu insn consuming CF, such as add/sbb\n+(define_insn_reservation  \"slm_alu_carry_mem\" 2\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"alu\")\n+            (and (eq_attr \"memory\" \"!none\")\n+                (eq_attr \"use_carry\" \"1\"))))\n+  \"slm-simple-either, nothing\")\n+\n+(define_insn_reservation  \"slm_alu1\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"alu1\")\n+            (eq_attr \"memory\" \"none\") (eq_attr \"prefix_0f\" \"0\")))\n+  \"slm-simple-either\")\n+\n+;; bsf and bsf insn\n+(define_insn_reservation  \"slm_alu1_1\" 10\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"alu1\")\n+            (eq_attr \"memory\" \"none\") (eq_attr \"prefix_0f\" \"1\")))\n+  \"slm-simple-1, slm-ieu-1*9\")\n+\n+(define_insn_reservation  \"slm_alu1_mem\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"alu1\")\n+            (eq_attr \"memory\" \"!none\")))\n+  \"slm-simple-either\")\n+\n+(define_insn_reservation  \"slm_negnot\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"negnot\")\n+            (eq_attr \"memory\" \"none\")))\n+  \"slm-simple-either\")\n+\n+(define_insn_reservation  \"slm_negnot_mem\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"negnot\")\n+            (eq_attr \"memory\" \"!none\")))\n+  \"slm-simple-either\")\n+\n+(define_insn_reservation  \"slm_imov\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"imov\")\n+            (eq_attr \"memory\" \"none\")))\n+  \"slm-simple-either\")\n+\n+(define_insn_reservation  \"slm_imov_mem\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"imov\")\n+            (eq_attr \"memory\" \"!none\")))\n+  \"slm-simple-0\")\n+\n+;; 16<-16, 32<-32\n+(define_insn_reservation  \"slm_imovx\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"imovx\")\n+            (and (eq_attr \"memory\" \"none\")\n+                 (ior (and (match_operand:HI 0 \"register_operand\")\n+                           (match_operand:HI 1 \"general_operand\"))\n+                      (and (match_operand:SI 0 \"register_operand\")\n+                           (match_operand:SI 1 \"general_operand\"))))))\n+  \"slm-simple-either\")\n+\n+;; 16<-16, 32<-32, mem\n+(define_insn_reservation  \"slm_imovx_mem\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"imovx\")\n+            (and (eq_attr \"memory\" \"!none\")\n+                 (ior (and (match_operand:HI 0 \"register_operand\")\n+                           (match_operand:HI 1 \"general_operand\"))\n+                      (and (match_operand:SI 0 \"register_operand\")\n+                           (match_operand:SI 1 \"general_operand\"))))))\n+  \"slm-simple-either\")\n+\n+;; 32<-16, 32<-8, 64<-16, 64<-8, 64<-32, 8<-8\n+(define_insn_reservation  \"slm_imovx_2\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"imovx\")\n+            (and (eq_attr \"memory\" \"none\")\n+                 (ior (match_operand:QI 0 \"register_operand\")\n+                      (ior (and (match_operand:SI 0 \"register_operand\")\n+                                (not (match_operand:SI 1 \"general_operand\")))\n+                           (match_operand:DI 0 \"register_operand\"))))))\n+  \"slm-simple-either\")\n+\n+;; 32<-16, 32<-8, 64<-16, 64<-8, 64<-32, 8<-8, mem\n+(define_insn_reservation  \"slm_imovx_2_mem\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"imovx\")\n+            (and (eq_attr \"memory\" \"!none\")\n+                 (ior (match_operand:QI 0 \"register_operand\")\n+                      (ior (and (match_operand:SI 0 \"register_operand\")\n+                                (not (match_operand:SI 1 \"general_operand\")))\n+                           (match_operand:DI 0 \"register_operand\"))))))\n+  \"slm-simple-0\")\n+\n+;; 16<-8\n+(define_insn_reservation  \"slm_imovx_3\" 3\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"imovx\")\n+            (and (match_operand:HI 0 \"register_operand\")\n+                 (match_operand:QI 1 \"general_operand\"))))\n+  \"slm-simple-0, nothing*2\")\n+\n+(define_insn_reservation  \"slm_lea\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"lea\")\n+            (eq_attr \"mode\" \"!HI\")))\n+  \"slm-simple-either\")\n+\n+;; lea 16bit address is complex insn\n+(define_insn_reservation  \"slm_lea_2\" 2\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"lea\")\n+            (eq_attr \"mode\" \"HI\")))\n+  \"slm-complex, slm-all-eu\")\n+\n+(define_insn_reservation  \"slm_incdec\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"incdec\")\n+            (eq_attr \"memory\" \"none\")))\n+  \"slm-simple-0\")\n+\n+(define_insn_reservation  \"slm_incdec_mem\" 3\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"incdec\")\n+            (eq_attr \"memory\" \"!none\")))\n+  \"slm-simple-0, nothing*2\")\n+\n+;; simple shift instruction use SHIFT eu, none memory\n+(define_insn_reservation  \"slm_ishift\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ishift\")\n+            (and (eq_attr \"memory\" \"none\") (eq_attr \"prefix_0f\" \"0\"))))\n+  \"slm-simple-0\")\n+\n+;; simple shift instruction use SHIFT eu, memory\n+(define_insn_reservation  \"slm_ishift_mem\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ishift\")\n+            (and (eq_attr \"memory\" \"!none\") (eq_attr \"prefix_0f\" \"0\"))))\n+  \"slm-simple-0\")\n+\n+;; DF shift (prefixed with 0f) is complex insn with latency of 4 cycles\n+(define_insn_reservation  \"slm_ishift_3\" 4\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ishift\")\n+            (eq_attr \"prefix_0f\" \"1\")))\n+  \"slm-complex, slm-all-eu*3\")\n+\n+(define_insn_reservation  \"slm_ishift1\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ishift1\")\n+            (eq_attr \"memory\" \"none\")))\n+  \"slm-simple-0\")\n+\n+(define_insn_reservation  \"slm_ishift1_mem\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ishift1\")\n+            (eq_attr \"memory\" \"!none\")))\n+  \"slm-simple-0\")\n+\n+(define_insn_reservation  \"slm_rotate\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"rotate\")\n+            (eq_attr \"memory\" \"none\")))\n+  \"slm-simple-0\")\n+\n+(define_insn_reservation  \"slm_rotate_mem\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"rotate\")\n+            (eq_attr \"memory\" \"!none\")))\n+  \"slm-simple-0\")\n+\n+(define_insn_reservation  \"slm_rotate1\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"rotate1\")\n+            (eq_attr \"memory\" \"none\")))\n+  \"slm-simple-0\")\n+\n+(define_insn_reservation  \"slm_rotate1_mem\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"rotate1\")\n+            (eq_attr \"memory\" \"!none\")))\n+  \"slm-simple-0\")\n+\n+(define_insn_reservation  \"slm_imul\" 3\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"imul\")\n+            (and (eq_attr \"memory\" \"none\") (eq_attr \"mode\" \"SI\"))))\n+  \"slm-imul-32\")\n+\n+(define_insn_reservation  \"slm_imul_mem\" 3\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"imul\")\n+            (and (eq_attr \"memory\" \"!none\") (eq_attr \"mode\" \"SI\"))))\n+  \"slm-imul-mem-32\")\n+\n+;; latency set to 4 as common 64x64 imul with 1/2 tput\n+(define_insn_reservation  \"slm_imul_3\" 4\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"imul\")\n+            (eq_attr \"mode\" \"!SI\")))\n+  \"slm-imul-64\")\n+\n+(define_insn_reservation  \"slm_idiv\" 33\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (eq_attr \"type\" \"idiv\"))\n+  \"slm-complex, slm-all-eu*16, nothing*16\")\n+\n+(define_insn_reservation  \"slm_icmp\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"icmp\")\n+            (eq_attr \"memory\" \"none\")))\n+  \"slm-simple-either\")\n+\n+(define_insn_reservation  \"slm_icmp_mem\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"icmp\")\n+            (eq_attr \"memory\" \"!none\")))\n+  \"slm-simple-either\")\n+\n+(define_insn_reservation  \"slm_test\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"test\")\n+            (eq_attr \"memory\" \"none\")))\n+  \"slm-simple-either\")\n+\n+(define_insn_reservation  \"slm_test_mem\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"test\")\n+            (eq_attr \"memory\" \"!none\")))\n+  \"slm-simple-either\")\n+\n+(define_insn_reservation  \"slm_ibr\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ibr\")\n+            (eq_attr \"memory\" \"!load\")))\n+  \"slm-simple-1\")\n+\n+;; complex if jump target is from address\n+(define_insn_reservation  \"slm_ibr_2\" 2\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ibr\")\n+            (eq_attr \"memory\" \"load\")))\n+  \"slm-complex, slm-all-eu\")\n+\n+(define_insn_reservation  \"slm_setcc\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"setcc\")\n+            (eq_attr \"memory\" \"!store\")))\n+  \"slm-simple-either\")\n+\n+;; 2 cycles complex if target is in memory\n+(define_insn_reservation  \"slm_setcc_2\" 2\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"setcc\")\n+            (eq_attr \"memory\" \"store\")))\n+  \"slm-complex, slm-all-eu\")\n+\n+(define_insn_reservation  \"slm_icmov\" 2\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"icmov\")\n+            (eq_attr \"memory\" \"none\")))\n+  \"slm-simple-either, nothing\")\n+\n+(define_insn_reservation  \"slm_icmov_mem\" 2\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"icmov\")\n+            (eq_attr \"memory\" \"!none\")))\n+  \"slm-simple-0, nothing\")\n+\n+;; UCODE if segreg, ignored\n+(define_insn_reservation  \"slm_push\" 2\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (eq_attr \"type\" \"push\"))\n+  \"slm-dual-2c\")\n+\n+;; pop r64 is 1 cycle. UCODE if segreg, ignored\n+(define_insn_reservation  \"slm_pop\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"pop\")\n+            (eq_attr \"mode\" \"DI\")))\n+  \"slm-dual-1c\")\n+\n+;; pop non-r64 is 2 cycles. UCODE if segreg, ignored\n+(define_insn_reservation  \"slm_pop_2\" 2\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"pop\")\n+            (eq_attr \"mode\" \"!DI\")))\n+  \"slm-dual-2c\")\n+\n+;; UCODE if segreg, ignored\n+(define_insn_reservation  \"slm_call\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (eq_attr \"type\" \"call\"))\n+  \"slm-dual-1c\")\n+\n+(define_insn_reservation  \"slm_callv\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (eq_attr \"type\" \"callv\"))\n+  \"slm-dual-1c\")\n+\n+(define_insn_reservation  \"slm_leave\" 3\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (eq_attr \"type\" \"leave\"))\n+  \"slm-complex, slm-all-eu*2\")\n+\n+(define_insn_reservation  \"slm_str\" 3\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (eq_attr \"type\" \"str\"))\n+  \"slm-complex, slm-all-eu*2\")\n+\n+(define_insn_reservation  \"slm_sselog\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sselog\")\n+            (eq_attr \"memory\" \"none\")))\n+  \"slm-simple-either\")\n+\n+(define_insn_reservation  \"slm_sselog_mem\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sselog\")\n+            (eq_attr \"memory\" \"!none\")))\n+  \"slm-simple-either\")\n+\n+(define_insn_reservation  \"slm_sselog1\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sselog1\")\n+            (eq_attr \"memory\" \"none\")))\n+  \"slm-simple-0\")\n+\n+(define_insn_reservation  \"slm_sselog1_mem\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sselog1\")\n+            (eq_attr \"memory\" \"!none\")))\n+  \"slm-simple-0\")\n+\n+;; not pmad, not psad\n+(define_insn_reservation  \"slm_sseiadd\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sseiadd\")\n+            (and (not (match_operand:V2DI 0 \"register_operand\"))\n+                 (and (eq_attr \"atom_unit\" \"!simul\")\n+                      (eq_attr \"atom_unit\" \"!complex\")))))\n+  \"slm-simple-either\")\n+\n+;; pmad, psad and 64\n+(define_insn_reservation  \"slm_sseiadd_2\" 4\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sseiadd\")\n+            (and (not (match_operand:V2DI 0 \"register_operand\"))\n+                 (and (eq_attr \"atom_unit\" \"simul\" )\n+                      (eq_attr \"mode\" \"DI\")))))\n+  \"slm-fmul-4c\")\n+\n+;; pmad, psad and 128\n+(define_insn_reservation  \"slm_sseiadd_3\" 5\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sseiadd\")\n+            (and (not (match_operand:V2DI 0 \"register_operand\"))\n+                 (and (eq_attr \"atom_unit\" \"simul\" )\n+                      (eq_attr \"mode\" \"TI\")))))\n+  \"slm-fmul-5c\")\n+\n+;; if paddq(64 bit op), phadd/phsub\n+(define_insn_reservation  \"slm_sseiadd_4\" 4\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sseiadd\")\n+            (ior (match_operand:V2DI 0 \"register_operand\")\n+                 (eq_attr \"atom_unit\" \"complex\"))))\n+  \"slm-fadd-4c\")\n+\n+;; if immediate op.\n+(define_insn_reservation  \"slm_sseishft\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sseishft\")\n+            (and (eq_attr \"atom_unit\" \"!sishuf\")\n+                 (match_operand 2 \"immediate_operand\"))))\n+  \"slm-simple-either\")\n+\n+;; if palignr or psrldq\n+(define_insn_reservation  \"slm_sseishft_2\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (ior (eq_attr \"type\" \"sseishft1\")\n+\t    (and (eq_attr \"type\" \"sseishft\")\n+\t\t (and (eq_attr \"atom_unit\" \"sishuf\")\n+\t\t      (match_operand 2 \"immediate_operand\")))))\n+  \"slm-simple-0\")\n+\n+;; if reg/mem op\n+(define_insn_reservation  \"slm_sseishft_3\" 2\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sseishft\")\n+            (not (match_operand 2 \"immediate_operand\"))))\n+  \"slm-complex, slm-all-eu\")\n+\n+(define_insn_reservation  \"slm_sseimul\" 5\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (eq_attr \"type\" \"sseimul\"))\n+  \"slm-fmul-5c\")\n+\n+;; rcpss or rsqrtss\n+(define_insn_reservation  \"slm_sse\" 4\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sse\")\n+            (and (eq_attr \"atom_sse_attr\" \"rcp\") (eq_attr \"mode\" \"SF\"))))\n+  \"slm-fmul-4c\")\n+\n+;; movshdup, movsldup. Suggest to type sseishft\n+(define_insn_reservation  \"slm_sse_2\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sse\")\n+            (eq_attr \"atom_sse_attr\" \"movdup\")))\n+  \"slm-simple-0\")\n+\n+;; lfence\n+(define_insn_reservation  \"slm_sse_3\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sse\")\n+            (eq_attr \"atom_sse_attr\" \"lfence\")))\n+  \"slm-simple-either\")\n+\n+;; sfence,clflush,mfence, prefetch\n+(define_insn_reservation  \"slm_sse_4\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sse\")\n+            (ior (eq_attr \"atom_sse_attr\" \"fence\")\n+                 (eq_attr \"atom_sse_attr\" \"prefetch\"))))\n+  \"slm-simple-0\")\n+\n+;; rcpps, rsqrtss, sqrt, ldmxcsr\n+(define_insn_reservation  \"slm_sse_5\" 9\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sse\")\n+            (ior (ior (eq_attr \"atom_sse_attr\" \"sqrt\")\n+                      (eq_attr \"atom_sse_attr\" \"mxcsr\"))\n+                 (and (eq_attr \"atom_sse_attr\" \"rcp\")\n+                      (eq_attr \"mode\" \"V4SF\")))))\n+  \"slm-complex, slm-all-eu*7, nothing\")\n+\n+;; xmm->xmm\n+(define_insn_reservation  \"slm_ssemov\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ssemov\")\n+            (and (match_operand 0 \"register_operand\" \"xy\")\n+                 (match_operand 1 \"register_operand\" \"xy\"))))\n+  \"slm-simple-either\")\n+\n+;; reg->xmm\n+(define_insn_reservation  \"slm_ssemov_2\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ssemov\")\n+            (and (match_operand 0 \"register_operand\" \"xy\")\n+                 (match_operand 1 \"register_operand\" \"r\"))))\n+  \"slm-simple-0\")\n+\n+;; xmm->reg\n+(define_insn_reservation  \"slm_ssemov_3\" 3\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ssemov\")\n+            (and (match_operand 0 \"register_operand\" \"r\")\n+                 (match_operand 1 \"register_operand\" \"xy\"))))\n+  \"slm-simple-0, nothing*2\")\n+\n+;; mov mem\n+(define_insn_reservation  \"slm_ssemov_4\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ssemov\")\n+            (and (eq_attr \"movu\" \"0\") (eq_attr \"memory\" \"!none\"))))\n+  \"slm-simple-0\")\n+\n+;; movu mem\n+(define_insn_reservation  \"slm_ssemov_5\" 2\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ssemov\")\n+            (ior (eq_attr \"movu\" \"1\") (eq_attr \"memory\" \"!none\"))))\n+  \"slm-simple-0, nothing\")\n+\n+;; no memory simple\n+(define_insn_reservation  \"slm_sseadd\" 3\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sseadd\")\n+            (and (eq_attr \"memory\" \"none\")\n+                 (and (eq_attr \"mode\" \"!V2DF\")\n+                      (eq_attr \"atom_unit\" \"!complex\")))))\n+  \"slm-fadd-3c\")\n+\n+;; memory simple\n+(define_insn_reservation  \"slm_sseadd_mem\" 3\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sseadd\")\n+            (and (eq_attr \"memory\" \"!none\")\n+                 (and (eq_attr \"mode\" \"!V2DF\")\n+                      (eq_attr \"atom_unit\" \"!complex\")))))\n+  \"slm-fadd-3c\")\n+\n+;; maxps, minps, *pd, hadd, hsub\n+(define_insn_reservation  \"slm_sseadd_3\" 4\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sseadd\")\n+            (ior (eq_attr \"mode\" \"V2DF\") (eq_attr \"atom_unit\" \"complex\"))))\n+  \"slm-fadd-4c\")\n+\n+;; Except dppd/dpps\n+(define_insn_reservation  \"slm_ssemul\" 5\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ssemul\")\n+            (eq_attr \"mode\" \"!SF\")))\n+  \"slm-fmul-5c\")\n+\n+;; Except dppd/dpps, 4 cycle if mulss\n+(define_insn_reservation  \"slm_ssemul_2\" 4\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ssemul\")\n+            (eq_attr \"mode\" \"SF\")))\n+  \"slm-fmul-4c\")\n+\n+(define_insn_reservation  \"slm_ssecmp\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (eq_attr \"type\" \"ssecmp\"))\n+  \"slm-simple-either\")\n+\n+(define_insn_reservation  \"slm_ssecomi\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (eq_attr \"type\" \"ssecomi\"))\n+  \"slm-simple-0\")\n+\n+;; no memory and cvtpi2ps, cvtps2pi, cvttps2pi\n+(define_insn_reservation  \"slm_ssecvt\" 5\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ssecvt\")\n+            (ior (and (match_operand:V2SI 0 \"register_operand\")\n+                      (match_operand:V4SF 1 \"register_operand\"))\n+                 (and (match_operand:V4SF 0 \"register_operand\")\n+                      (match_operand:V2SI 1 \"register_operand\")))))\n+  \"slm-fp-0, slm-feu-0, nothing*3\")\n+\n+;; memory and cvtpi2ps, cvtps2pi, cvttps2pi\n+(define_insn_reservation  \"slm_ssecvt_mem\" 5\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ssecvt\")\n+            (ior (and (match_operand:V2SI 0 \"register_operand\")\n+                      (match_operand:V4SF 1 \"memory_operand\"))\n+                 (and (match_operand:V4SF 0 \"register_operand\")\n+                      (match_operand:V2SI 1 \"memory_operand\")))))\n+\"slm-fp-0, slm-feu-0, nothing*3\")\n+\n+;; cvtpd2pi, cvtpi2pd\n+(define_insn_reservation  \"slm_ssecvt_1\" 2\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ssecvt\")\n+            (ior (and (match_operand:V2DF 0 \"register_operand\")\n+                      (match_operand:V2SI 1 \"register_operand\"))\n+                 (and (match_operand:V2SI 0 \"register_operand\")\n+                      (match_operand:V2DF 1 \"register_operand\")))))\n+  \"slm-fp-0, slm-feu-0\")\n+\n+;; memory and cvtpd2pi, cvtpi2pd\n+(define_insn_reservation  \"slm_ssecvt_1_mem\" 2\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ssecvt\")\n+            (ior (and (match_operand:V2DF 0 \"register_operand\")\n+                      (match_operand:V2SI 1 \"memory_operand\"))\n+                 (and (match_operand:V2SI 0 \"register_operand\")\n+                      (match_operand:V2DF 1 \"memory_operand\")))))\n+  \"slm-fp-0, slm-feu-0\")\n+\n+;; otherwise. 4 cycles average for cvtss2sd\n+(define_insn_reservation  \"slm_ssecvt_3\" 4\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"ssecvt\")\n+            (not (ior (and (match_operand:V2SI 0 \"register_operand\")\n+                           (match_operand:V4SF 1 \"nonimmediate_operand\"))\n+                      (and (match_operand:V4SF 0 \"register_operand\")\n+                           (match_operand:V2SI 1 \"nonimmediate_operand\"))))))\n+  \"slm-fp-0, nothing*3\")\n+\n+;; memory and cvtsi2sd\n+(define_insn_reservation  \"slm_sseicvt\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sseicvt\")\n+            (and (match_operand:V2DF 0 \"register_operand\")\n+                 (match_operand:SI 1 \"nonimmediate_operand\"))))\n+  \"slm-fp-0\")\n+\n+;; otherwise. 8 cycles average for cvtsd2si\n+(define_insn_reservation  \"slm_sseicvt_2\" 4\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"sseicvt\")\n+            (not (and (match_operand:V2DF 0 \"register_operand\")\n+                      (match_operand:SI 1 \"memory_operand\")))))\n+  \"slm-fp-0, nothing*3\")\n+\n+(define_insn_reservation  \"slm_ssediv\" 13\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (eq_attr \"type\" \"ssediv\"))\n+  \"slm-fp-0, slm-feu-0*10, nothing*2\")\n+\n+;; simple for fmov\n+(define_insn_reservation  \"slm_fmov\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"fmov\")\n+            (eq_attr \"memory\" \"none\")))\n+  \"slm-simple-either\")\n+\n+;; simple for fmov\n+(define_insn_reservation  \"slm_fmov_mem\" 1\n+  (and (eq_attr \"cpu\" \"slm\")\n+       (and (eq_attr \"type\" \"fmov\")\n+            (eq_attr \"memory\" \"!none\")))\n+  \"slm-simple-either\")\n+\n+;; Define bypass here\n+\n+;; There will be 0 cycle stall from cmp/test to jcc\n+\n+;; There will be 1 cycle stall from flag producer to cmov and adc/sbb\n+(define_bypass 2 \"slm_icmp, slm_test, slm_alu, slm_alu_carry,\n+                  slm_alu1, slm_negnot, slm_incdec, slm_ishift,\n+                  slm_ishift1, slm_rotate, slm_rotate1\"\n+                 \"slm_icmov, slm_alu_carry\")\n+\n+;; lea to shift source stall is 1 cycle\n+(define_bypass 2 \"slm_lea\"\n+                 \"slm_ishift, slm_ishift1, slm_rotate, slm_rotate1\"\n+                 \"!ix86_dep_by_shift_count\")\n+\n+;; non-lea to shift count stall is 1 cycle\n+(define_bypass 2 \"slm_alu_carry,\n+                  slm_alu,slm_alu1,slm_negnot,slm_imov,slm_imovx,\n+                  slm_incdec,slm_ishift,slm_ishift1,slm_rotate,\n+                  slm_rotate1, slm_setcc, slm_icmov, slm_pop,\n+                  slm_alu_mem, slm_alu_carry_mem, slm_alu1_mem,\n+                  slm_imovx_mem, slm_imovx_2_mem,\n+                  slm_imov_mem, slm_icmov_mem, slm_fmov_mem\"\n+                 \"slm_ishift, slm_ishift1, slm_rotate, slm_rotate1,\n+                  slm_ishift_mem, slm_ishift1_mem,\n+                  slm_rotate_mem, slm_rotate1_mem\"\n+                 \"ix86_dep_by_shift_count\")"}, {"sha": "39b9d1175bb0d2604ca51f72d219d1c4299755e1", "filename": "libgcc/config/i386/cpuinfo.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/libgcc%2Fconfig%2Fi386%2Fcpuinfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07/libgcc%2Fconfig%2Fi386%2Fcpuinfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fcpuinfo.c?ref=0b871ccfce4a95d2d6c8849e0c69a0172fd7ea07", "patch": "@@ -50,6 +50,7 @@ enum processor_vendor\n enum processor_types\n {\n   INTEL_ATOM = 1,\n+  INTEL_SLM,\n   INTEL_CORE2,\n   INTEL_COREI7,\n   AMDFAM10H,"}]}