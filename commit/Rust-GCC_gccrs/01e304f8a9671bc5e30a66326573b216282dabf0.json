{"sha": "01e304f8a9671bc5e30a66326573b216282dabf0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFlMzA0ZjhhOTY3MWJjNWUzMGE2NjMyNjU3M2IyMTYyODJkYWJmMA==", "commit": {"author": {"name": "Roman Zippel", "email": "zippel@linux-m68k.org", "date": "2007-02-18T01:30:58Z"}, "committer": {"name": "Roman Zippel", "email": "zippel@gcc.gnu.org", "date": "2007-02-18T01:30:58Z"}, "message": "m68k.c (split_di): New.\n\n\t* config/m68k/m68k.c (split_di): New.\n\t* config/m68k/m68k-protos.h: Declare split_di.\n\t* config/m68k/m68k.md (extendsidi2*,ashldi3*,ashrdi3*,lshrdi3*):\n\t  Improve predicate handling and split constant shifts.\n\nFrom-SVN: r122084", "tree": {"sha": "8284bf7a7ec45cedc67dd506c11cac021a5b7b26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8284bf7a7ec45cedc67dd506c11cac021a5b7b26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01e304f8a9671bc5e30a66326573b216282dabf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01e304f8a9671bc5e30a66326573b216282dabf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01e304f8a9671bc5e30a66326573b216282dabf0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01e304f8a9671bc5e30a66326573b216282dabf0/comments", "author": null, "committer": null, "parents": [{"sha": "3670ec284deac22cb2c850a354736a649031d6fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3670ec284deac22cb2c850a354736a649031d6fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3670ec284deac22cb2c850a354736a649031d6fa"}], "stats": {"total": 651, "additions": 488, "deletions": 163}, "files": [{"sha": "8e104718950c5453147968294b20fc3da351bf5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01e304f8a9671bc5e30a66326573b216282dabf0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01e304f8a9671bc5e30a66326573b216282dabf0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01e304f8a9671bc5e30a66326573b216282dabf0", "patch": "@@ -1,3 +1,10 @@\n+2007-02-18  Roman Zippel <zippel@linux-m68k.org>\n+\n+\t* config/m68k/m68k.c (split_di): New.\n+\t* config/m68k/m68k-protos.h: Declare split_di.\n+\t* config/m68k/m68k.md (extendsidi2*,ashldi3*,ashrdi3*,lshrdi3*):\n+\t  Improve predicate handling and split constant shifts.\n+\n 2007-02-18  Roman Zippel <zippel@linux-m68k.org>\n \n \t* config/m68k/m68k.md (extv,extzv,insv): disable dynamic"}, {"sha": "85a5376826b0c289508e2b58c1218793e30f776e", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01e304f8a9671bc5e30a66326573b216282dabf0/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01e304f8a9671bc5e30a66326573b216282dabf0/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=01e304f8a9671bc5e30a66326573b216282dabf0", "patch": "@@ -22,6 +22,9 @@ Boston, MA 02110-1301, USA.  */\n \n #ifdef RTX_CODE\n extern HOST_WIDE_INT m68k_initial_elimination_offset (int from, int to);\n+\n+extern void split_di (rtx[], int, rtx[], rtx[]);\n+\n extern bool valid_mov3q_const (HOST_WIDE_INT);\n extern const char *output_move_simode (rtx *);\n extern const char *output_move_himode (rtx *);"}, {"sha": "08ebbd20dac9536850cdffccabdbd5b5f5541f48", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01e304f8a9671bc5e30a66326573b216282dabf0/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01e304f8a9671bc5e30a66326573b216282dabf0/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=01e304f8a9671bc5e30a66326573b216282dabf0", "patch": "@@ -2722,6 +2722,38 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n   return 0;\n }\n \n+/* Split one or more DImode RTL references into pairs of SImode\n+   references.  The RTL can be REG, offsettable MEM, integer constant, or\n+   CONST_DOUBLE.  \"operands\" is a pointer to an array of DImode RTL to\n+   split and \"num\" is its length.  lo_half and hi_half are output arrays\n+   that parallel \"operands\".  */\n+\n+void\n+split_di (rtx operands[], int num, rtx lo_half[], rtx hi_half[])\n+{\n+  while (num--)\n+    {\n+      rtx op = operands[num];\n+\n+      /* simplify_subreg refuses to split volatile memory addresses,\n+\t but we still have to handle it.  */\n+      if (GET_CODE (op) == MEM)\n+\t{\n+\t  lo_half[num] = adjust_address (op, SImode, 4);\n+\t  hi_half[num] = adjust_address (op, SImode, 0);\n+\t}\n+      else\n+\t{\n+\t  lo_half[num] = simplify_gen_subreg (SImode, op,\n+\t\t\t\t\t      GET_MODE (op) == VOIDmode\n+\t\t\t\t\t      ? DImode : GET_MODE (op), 4);\n+\t  hi_half[num] = simplify_gen_subreg (SImode, op,\n+\t\t\t\t\t      GET_MODE (op) == VOIDmode\n+\t\t\t\t\t      ? DImode : GET_MODE (op), 0);\n+\t}\n+    }\n+}\n+\n /* Return a REG that occurs in ADDR with coefficient 1.\n    ADDR can be effectively incremented by incrementing REG.  */\n "}, {"sha": "42e5f21dfce7d9ff6101c582e1fb6a9dad43b095", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 446, "deletions": 163, "changes": 609, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01e304f8a9671bc5e30a66326573b216282dabf0/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01e304f8a9671bc5e30a66326573b216282dabf0/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=01e304f8a9671bc5e30a66326573b216282dabf0", "patch": "@@ -1476,17 +1476,31 @@\n })\n \n (define_insn \"extendsidi2\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d\")\n-\t(sign_extend:DI\n-\t (match_operand:SI 1 \"general_operand\" \"rm\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(sign_extend:DI (match_operand:SI 1 \"nonimmediate_src_operand\" \"rm\")))]\n   \"\"\n {\n   CC_STATUS_INIT;\n-  operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n   if (TARGET_68020 || TARGET_COLDFIRE)\n-    return \"move%.l %1,%2\\;smi %0\\;extb%.l %0\";\n+    return \"move%.l %1,%R0\\;smi %0\\;extb%.l %0\";\n+  else\n+    return \"move%.l %1,%R0\\;smi %0\\;ext%.w %0\\;ext%.l %0\";\n+})\n+\n+(define_insn \"*extendsidi2_mem\"\n+  [(set (match_operand:DI 0 \"memory_operand\" \"=o,<\")\n+\t(sign_extend:DI (match_operand:SI 1 \"nonimmediate_src_operand\" \"rm,rm\")))\n+   (clobber (match_scratch:SI 2 \"=d,d\"))]\n+   \"\"\n+{\n+  CC_STATUS_INIT;\n+  operands[3] = adjust_address (operands[0], SImode,\n+\t\t\t\twhich_alternative == 0 ? 4 : 0);\n+  operands[0] = adjust_address (operands[0], SImode, 0);\n+  if (TARGET_68020 || TARGET_COLDFIRE)\n+    return \"move%.l %1,%3\\;smi %2\\;extb%.l %2\\;move%.l %2,%0\";\n   else\n-    return \"move%.l %1,%2\\;smi %0\\;ext%.w %0\\;ext%.l %0\";\n+    return \"move%.l %1,%3\\;smi %2\\;ext%.w %2\\;ext%.l %2\\;move%.l %2,%0\";\n })\n \n ;; Special case when one can avoid register clobbering, copy and test\n@@ -4087,69 +4101,168 @@\n     return \"move%.w %1,%0\\;sub%.l %R0,%R0\";\n })\n \n-(define_insn \"ashldi_const32\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n-\t\t     (const_int 32)))]\n+(define_insn \"*ashldi3_const1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t   (const_int 1)))]\n+  \"!TARGET_COLDFIRE\"\n+  \"add%.l %R0,%R0\\;addx%.l %0,%0\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t   (const_int 2)))]\n+  \"reload_completed && !TARGET_COLDFIRE\"\n+  [(set (match_dup 0)\n+\t(ashift:DI (match_dup 1) (const_int 1)))\n+   (set (match_dup 0)\n+\t(ashift:DI (match_dup 0) (const_int 1)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t   (const_int 3)))]\n+  \"reload_completed && !TARGET_COLDFIRE\"\n+  [(set (match_dup 0)\n+\t(ashift:DI (match_dup 1) (const_int 2)))\n+   (set (match_dup 0)\n+\t(ashift:DI (match_dup 0) (const_int 1)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t   (const_int 8)))]\n+  \"reload_completed && !TARGET_COLDFIRE\"\n+  [(set (match_dup 2)\n+\t(rotate:SI (match_dup 2) (const_int 8)))\n+   (set (match_dup 3)\n+\t(rotate:SI (match_dup 3) (const_int 8)))\n+   (set (strict_low_part (subreg:QI (match_dup 0) 3))\n+\t(subreg:QI (match_dup 0) 7))\n+   (set (strict_low_part (subreg:QI (match_dup 0) 7))\n+\t(const_int 0))]\n+{\n+  operands[2] = gen_highpart (SImode, operands[0]);\n+  operands[3] = gen_lowpart (SImode, operands[0]);\n+})\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t   (const_int 16)))]\n+  \"reload_completed && !TARGET_COLDFIRE\"\n+  [(set (match_dup 2)\n+\t(rotate:SI (match_dup 2) (const_int 16)))\n+   (set (match_dup 3)\n+\t(rotate:SI (match_dup 3) (const_int 16)))\n+   (set (strict_low_part (subreg:HI (match_dup 0) 2))\n+\t(subreg:HI (match_dup 0) 6))\n+   (set (strict_low_part (subreg:HI (match_dup 0) 6))\n+\t(const_int 0))]\n+{\n+  operands[2] = gen_highpart (SImode, operands[0]);\n+  operands[3] = gen_lowpart (SImode, operands[0]);\n+})\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"pre_dec_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n+\t\t   (const_int 32)))]\n+  \"reload_completed\"\n+  [(set (match_dup 0) (const_int 0))\n+   (set (match_dup 0) (match_dup 1))]\n+{\n+  operands[0] = adjust_address(operands[0], SImode, 0);\n+  operands[1] = gen_lowpart(SImode, operands[1]);\n+})\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"post_inc_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n+\t\t   (const_int 32)))]\n+  \"reload_completed\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 0) (const_int 0))]\n+{\n+  operands[0] = adjust_address(operands[0], SImode, 0);\n+  operands[1] = gen_lowpart(SImode, operands[1]);\n+})\n+\n+(define_insn_and_split \"*ashldi3_const32\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=ro<>\")\n+\t(ashift:DI (match_operand:DI 1 \"nonimmediate_operand\" \"ro\")\n+\t\t   (const_int 32)))]\n   \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 4) (match_dup 3))\n+   (set (match_dup 2) (const_int 0))]\n+  \"split_di(operands, 2, operands + 2, operands + 4);\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t   (match_operand 2 \"const_int_operand\" \"\")))]\n+  \"reload_completed && !TARGET_COLDFIRE\n+   && INTVAL (operands[2]) > 32 && INTVAL (operands[2]) <= 40\"\n+  [(set (match_dup 4) (ashift:SI (match_dup 4) (match_dup 2)))\n+   (set (match_dup 3) (match_dup 4))\n+   (set (match_dup 4) (const_int 0))]\n+{\n+  operands[2] = GEN_INT (INTVAL (operands[2]) - 32);\n+  operands[3] = gen_highpart (SImode, operands[0]);\n+  operands[4] = gen_lowpart (SImode, operands[0]);\n+})\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t   (const_int 48)))]\n+  \"reload_completed && !TARGET_COLDFIRE\"\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 2)\n+\t(rotate:SI (match_dup 2) (const_int 16)))\n+   (set (match_dup 3) (const_int 0))\n+   (set (strict_low_part (subreg:HI (match_dup 0) 2))\n+\t(const_int 0))]\n {\n-  CC_STATUS_INIT;\n-  if (GET_CODE (operands[1]) == REG)\n-    operands[3] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-  else\n-    operands[3] = adjust_address (operands[1], SImode, 4);\n-  if (GET_CODE (operands[0]) == REG)\n-    operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-    return \"clr%.l %0\\;move%.l %3,%0\";\n-  else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n-    return \"move%.l %3,%0\\;clr%.l %0\";\n-  else\n-    operands[2] = adjust_address (operands[0], SImode, 4);\n-  if (ADDRESS_REG_P (operands[2]))\n-    return \"move%.l %3,%0\\;sub%.l %2,%2\";\n-  else\n-    return \"move%.l %3,%0\\;clr%.l %2\";\n+  operands[2] = gen_highpart (SImode, operands[0]);\n+  operands[3] = gen_lowpart (SImode, operands[0]);\n })\n \n-;; The predicate below must be general_operand, because ashldi3 allows that\n-(define_insn \"ashldi_const\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d\")\n-\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand 2 \"const_int_operand\" \"n\")))]\n-  \"(!TARGET_COLDFIRE\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t   (match_operand 2 \"const_int_operand\" \"\")))]\n+  \"reload_completed && !TARGET_COLDFIRE\n+   && INTVAL (operands[2]) > 40 && INTVAL (operands[2]) <= 63\"\n+  [(set (match_dup 3) (match_dup 2))\n+   (set (match_dup 4) (ashift:SI (match_dup 4) (match_dup 3)))\n+   (set (match_dup 3) (match_dup 4))\n+   (set (match_dup 4) (const_int 0))]\n+{\n+  operands[2] = GEN_INT (INTVAL (operands[2]) - 32);\n+  operands[3] = gen_highpart (SImode, operands[0]);\n+  operands[4] = gen_lowpart (SImode, operands[0]);\n+})\n+\n+(define_insn \"*ashldi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand 2 \"const_int_operand\" \"n\")))]\n+  \"!TARGET_COLDFIRE\n     && ((INTVAL (operands[2]) >= 1 && INTVAL (operands[2]) <= 3)\n \t|| INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16\n-\t|| (INTVAL (operands[2]) > 32 && INTVAL (operands[2]) <= 63)))\"\n-{\n-  operands[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  if (INTVAL (operands[2]) == 1)\n-    return \"add%.l %1,%1\\;addx%.l %0,%0\";\n-  else if (INTVAL (operands[2]) == 8)\n-    return \"rol%.l #8,%1\\;rol%.l #8,%0\\;move%.b %1,%0\\;clr%.b %1\";\n-  else if (INTVAL (operands[2]) == 16)\n-    return \"swap %1\\;swap %0\\;move%.w %1,%0\\;clr%.w %1\";\n-  else if (INTVAL (operands[2]) == 48)\n-    return \"mov%.l %1,%0\\;swap %0\\;clr%.l %1\\;clr%.w %0\";\n-  else if (INTVAL (operands[2]) == 2)\n-    return \"add%.l %1,%1\\;addx%.l %0,%0\\;add%.l %1,%1\\;addx%.l %0,%0\";\n-  else if (INTVAL (operands[2]) == 3)\n-    return \"add%.l %1,%1\\;addx%.l %0,%0\\;add%.l %1,%1\\;addx%.l %0,%0\\;add%.l %1,%1\\;addx%.l %0,%0\";\n-  else /* 32 < INTVAL (operands[2]) <= 63 */\n-    {\n-      operands[2] = GEN_INT (INTVAL (operands[2]) - 32);\n-      output_asm_insn (INTVAL (operands[2]) <= 8 ? \"asl%.l %2,%1\" :\n-\t\t\t\"moveq %2,%0\\;asl%.l %0,%1\", operands);\n-      return \"mov%.l %1,%0\\;moveq #0,%1\";\n-    }\n-})\n+\t|| (INTVAL (operands[2]) > 32 && INTVAL (operands[2]) <= 63))\"\n+  \"#\")\n \n (define_expand \"ashldi3\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"\")\n-\t\t     (match_operand 2 \"const_int_operand\" \"\")))]\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t   (match_operand 2 \"const_int_operand\" \"\")))]\n   \"!TARGET_COLDFIRE\"\n-  \"\n {\n   /* ???  This is a named pattern like this is not allowed to FAIL based\n      on its operands.  */\n@@ -4158,7 +4271,7 @@\n \t  && INTVAL (operands[2]) != 8 && INTVAL (operands[2]) != 16\n \t  && (INTVAL (operands[2]) < 32 || INTVAL (operands[2]) > 63)))\n     FAIL;\n-} \")\n+})\n \n ;; On most 68k models, this makes faster code in a special case.\n \n@@ -4276,66 +4389,131 @@\n   return \"move%.l %1,%0\";\n })\n \n-(define_insn \"ashrdi_const32\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,o,<\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro,ro,ro\")\n+(define_insn \"*ashrdi3_const1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t     (const_int 1)))]\n+  \"!TARGET_COLDFIRE\"\n+{\n+  operands[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n+  return \"asr%.l #1,%0\\;roxr%.l #1,%1\";\n+})\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (const_int 2)))]\n+  \"reload_completed && !TARGET_COLDFIRE\"\n+  [(set (match_dup 0)\n+\t(ashiftrt:DI (match_dup 1) (const_int 1)))\n+   (set (match_dup 0)\n+\t(ashiftrt:DI (match_dup 0) (const_int 1)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (const_int 3)))]\n+  \"reload_completed && !TARGET_COLDFIRE\"\n+  [(set (match_dup 0)\n+\t(ashiftrt:DI (match_dup 1) (const_int 2)))\n+   (set (match_dup 0)\n+\t(ashiftrt:DI (match_dup 0) (const_int 1)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (const_int 8)))]\n+  \"reload_completed && !TARGET_COLDFIRE\"\n+  [(set (strict_low_part (subreg:QI (match_dup 0) 7))\n+\t(subreg:QI (match_dup 0) 3))\n+   (set (match_dup 2)\n+\t(ashiftrt:SI (match_dup 2) (const_int 8)))\n+   (set (match_dup 3)\n+\t(rotatert:SI (match_dup 3) (const_int 8)))]\n+{\n+  operands[2] = gen_highpart (SImode, operands[0]);\n+  operands[3] = gen_lowpart (SImode, operands[0]);\n+})\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (const_int 16)))]\n+  \"reload_completed && !TARGET_COLDFIRE\"\n+  [(set (strict_low_part (subreg:HI (match_dup 0) 6))\n+\t(subreg:HI (match_dup 0) 2))\n+   (set (match_dup 2)\n+\t(rotate:SI (match_dup 2) (const_int 16)))\n+   (set (match_dup 3)\n+\t(rotate:SI (match_dup 3) (const_int 16)))\n+   (set (match_dup 2)\n+\t(sign_extend:SI (subreg:HI (match_dup 2) 2)))]\n+{\n+  operands[2] = gen_highpart (SImode, operands[0]);\n+  operands[3] = gen_lowpart (SImode, operands[0]);\n+})\n+\n+(define_insn \"*ashrdi_const32\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"nonimmediate_src_operand\" \"ro\")\n+\t\t     (const_int 32)))]\n+  \"\"\n+{\n+  CC_STATUS_INIT;\n+  if (TARGET_68020)\n+    return \"move%.l %1,%R0\\;smi %0\\;extb%.l %0\";\n+  else\n+    return \"move%.l %1,%R0\\;smi %0\\;ext%.w %0\\;ext%.l %0\";\n+})\n+\n+(define_insn \"*ashrdi_const32_mem\"\n+  [(set (match_operand:DI 0 \"memory_operand\" \"=o,<\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"nonimmediate_src_operand\" \"ro,ro\")\n \t\t     (const_int 32)))\n-   (clobber (match_scratch:SI 2 \"=X,d,d\"))]\n+   (clobber (match_scratch:SI 2 \"=d,d\"))]\n   \"\"\n {\n   CC_STATUS_INIT;\n-  if (which_alternative == 0)\n-    {\n-      operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-      if (TARGET_68020)\n-\treturn \"move%.l %1,%2\\;smi %0\\;extb%.l %0\";\n-      else\n-\treturn \"move%.l %1,%2\\;smi %0\\;ext%.w %0\\;ext%.l %0\";\n-    }\n+  operands[3] = adjust_address (operands[0], SImode,\n+\t\t\t\twhich_alternative == 0 ? 4 : 0);\n+  operands[0] = adjust_address (operands[0], SImode, 0);\n+  if (TARGET_68020 || TARGET_COLDFIRE)\n+    return \"move%.l %1,%3\\;smi %2\\;extb%.l %2\\;move%.l %2,%0\";\n   else\n-    {\n-      if (which_alternative == 2)\n-\toperands[3] = operands[0];\n-      else if (which_alternative == 1)\n-\toperands[3] = adjust_address (operands[0], SImode, 4);\n-      if (TARGET_68020)\n-\treturn \"move%.l %1,%3\\;smi %2\\;extb%.l %2\\;move%.l %2,%0\";\n-      else\n-\treturn \"move%.l %1,%3\\;smi %2\\;ext%.w %2\\;ext%.l %2\\;move%.l %2,%0\";\n-    }\n+    return \"move%.l %1,%3\\;smi %2\\;ext%.w %2\\;ext%.l %2\\;move%.l %2,%0\";\n })\n \n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (const_int 63)))]\n+  \"reload_completed && !TARGET_COLDFIRE\"\n+  [(set (match_dup 3)\n+\t(ashiftrt:SI (match_dup 3) (const_int 31)))\n+   (set (match_dup 2)\n+\t(match_dup 3))]\n+  \"split_di(operands, 1, operands + 2, operands + 3);\")\n+\n ;; The predicate below must be general_operand, because ashrdi3 allows that\n (define_insn \"ashrdi_const\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand 2 \"const_int_operand\" \"n\")))\n-   (clobber (match_scratch:SI 3 \"=X\"))]\n-  \"(!TARGET_COLDFIRE \n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand 2 \"const_int_operand\" \"n\")))]\n+  \"!TARGET_COLDFIRE\n     && ((INTVAL (operands[2]) >= 1 && INTVAL (operands[2]) <= 3)\n \t|| INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16\n \t|| INTVAL (operands[2]) == 31\n-\t|| (INTVAL (operands[2]) > 32 && INTVAL (operands[2]) <= 63)))\"\n+\t|| (INTVAL (operands[2]) > 32 && INTVAL (operands[2]) <= 63))\"\n {\n   operands[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  if (INTVAL (operands[2]) == 63)\n-    return \"add%.l %0,%0\\;subx%.l %0,%0\\;move%.l %0,%1\";\n   CC_STATUS_INIT;\n-  if (INTVAL (operands[2]) == 1)\n-    return \"asr%.l #1,%0\\;roxr%.l #1,%1\";\n-  else if (INTVAL (operands[2]) == 8)\n-    return \"move%.b %0,%1\\;asr%.l #8,%0\\;ror%.l #8,%1\";\n-  else if (INTVAL (operands[2]) == 16)\n-    return \"move%.w %0,%1\\;swap %0\\;ext%.l %0\\;swap %1\";\n-  else if (INTVAL (operands[2]) == 48)\n+  if (INTVAL (operands[2]) == 48)\n     return \"swap %0\\;ext%.l %0\\;move%.l %0,%1\\;smi %0\\;ext%.w %0\";\n-  else if (INTVAL (operands[2]) == 31)\n+  if (INTVAL (operands[2]) == 31)\n     return \"add%.l %1,%1\\;addx%.l %0,%0\\;move%.l %0,%1\\;subx%.l %0,%0\";\n-  else if (INTVAL (operands[2]) == 2)\n-    return \"asr%.l #1,%0\\;roxr%.l #1,%1\\;asr%.l #1,%0\\;roxr%.l #1,%1\";\n-  else if (INTVAL (operands[2]) == 3)\n-    return \"asr%.l #1,%0\\;roxr%.l #1,%1\\;asr%.l #1,%0\\;roxr%.l #1,%1\\;asr%.l #1,%0\\;roxr%.l #1,%1\";\n-  else /* 32 < INTVAL (operands[2]) <= 63 */\n+  if (INTVAL (operands[2]) > 32 && INTVAL (operands[2]) <= 63)\n     {\n       operands[2] = GEN_INT (INTVAL (operands[2]) - 32);\n       output_asm_insn (INTVAL (operands[2]) <= 8 ? \"asr%.l %2,%0\" :\n@@ -4344,15 +4522,14 @@\n       return INTVAL (operands[2]) >= 15 ? \"ext%.w %d0\" :\n \t     TARGET_68020 ? \"extb%.l %0\" : \"ext%.w %0\\;ext%.l %0\";\n     }\n+  return \"#\";\n })\n \n (define_expand \"ashrdi3\"\n-  [(parallel [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t\t   (ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"\")\n-\t\t\t\t(match_operand 2 \"const_int_operand\" \"\")))\n-\t      (clobber (match_scratch:SI 3 \"\"))])]\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (match_operand 2 \"const_int_operand\" \"\")))]\n   \"!TARGET_COLDFIRE\"\n-  \"\n {\n   /* ???  This is a named pattern like this is not allowed to FAIL based\n      on its operands.  */\n@@ -4361,8 +4538,7 @@\n \t  && INTVAL (operands[2]) != 8 && INTVAL (operands[2]) != 16\n \t  && (INTVAL (operands[2]) < 31 || INTVAL (operands[2]) > 63)))\n     FAIL;\n-  operands[3] = gen_rtx_SCRATCH (SImode);\n-} \")\n+})\n \n ;; On all 68k models, this makes faster code in a special case.\n \n@@ -4450,69 +4626,176 @@\n   return \"move%.l %1,%0\";\n })\n \n-(define_insn \"lshrdi_const32\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=ro,<,>\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro,ro,ro\")\n+(define_insn \"*lshrdi3_const1\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t     (const_int 1)))]\n+  \"!TARGET_COLDFIRE\"\n+  \"lsr%.l #1,%0\\;roxr%.l #1,%R0\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (const_int 2)))]\n+  \"reload_completed && !TARGET_COLDFIRE\"\n+  [(set (match_dup 0)\n+\t(lshiftrt:DI (match_dup 1) (const_int 1)))\n+   (set (match_dup 0)\n+\t(lshiftrt:DI (match_dup 0) (const_int 1)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (const_int 3)))]\n+  \"reload_completed && !TARGET_COLDFIRE\"\n+  [(set (match_dup 0)\n+\t(lshiftrt:DI (match_dup 1) (const_int 2)))\n+   (set (match_dup 0)\n+\t(lshiftrt:DI (match_dup 0) (const_int 1)))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (const_int 8)))]\n+  \"reload_completed && !TARGET_COLDFIRE\"\n+  [(set (strict_low_part (subreg:QI (match_dup 0) 7))\n+\t(subreg:QI (match_dup 0) 3))\n+   (set (match_dup 2)\n+\t(lshiftrt:SI (match_dup 2) (const_int 8)))\n+   (set (match_dup 3)\n+\t(rotatert:SI (match_dup 3) (const_int 8)))]\n+{\n+  operands[2] = gen_highpart (SImode, operands[0]);\n+  operands[3] = gen_lowpart (SImode, operands[0]);\n+})\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (const_int 16)))]\n+  \"reload_completed && !TARGET_COLDFIRE\"\n+  [(set (strict_low_part (subreg:HI (match_dup 0) 6))\n+\t(subreg:HI (match_dup 0) 2))\n+   (set (strict_low_part (subreg:HI (match_dup 0) 2))\n+\t(const_int 0))\n+   (set (match_dup 3)\n+\t(rotate:SI (match_dup 3) (const_int 16)))\n+   (set (match_dup 2)\n+\t(rotate:SI (match_dup 2) (const_int 16)))]\n+{\n+  operands[2] = gen_highpart (SImode, operands[0]);\n+  operands[3] = gen_lowpart (SImode, operands[0]);\n+})\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"pre_dec_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n+\t\t     (const_int 32)))]\n+  \"reload_completed\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 0) (const_int 0))]\n+{\n+  operands[0] = adjust_address(operands[0], SImode, 0);\n+  operands[1] = gen_highpart(SImode, operands[1]);\n+})\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"post_inc_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n+\t\t     (const_int 32)))]\n+  \"reload_completed\"\n+  [(set (match_dup 0) (const_int 0))\n+   (set (match_dup 0) (match_dup 1))]\n+{\n+  operands[0] = adjust_address(operands[0], SImode, 0);\n+  operands[1] = gen_highpart(SImode, operands[1]);\n+})\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"nonimmediate_operand\" \"\")\n+\t\t     (const_int 32)))]\n+  \"reload_completed\"\n+  [(set (match_dup 2) (match_dup 5))\n+   (set (match_dup 4) (const_int 0))]\n+  \"split_di(operands, 2, operands + 2, operands + 4);\")\n+\n+(define_insn \"*lshrdi_const32\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=ro<>\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"ro\")\n \t\t     (const_int 32)))]\n   \"\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (match_operand 2 \"const_int_operand\" \"\")))]\n+  \"reload_completed && !TARGET_COLDFIRE\n+   && INTVAL (operands[2]) > 32 && INTVAL (operands[2]) <= 40\"\n+  [(set (match_dup 3) (lshiftrt:SI (match_dup 3) (match_dup 2)))\n+   (set (match_dup 4) (match_dup 3))\n+   (set (match_dup 3) (const_int 0))]\n {\n-  CC_STATUS_INIT;\n-  if (which_alternative == 1)\n-    return \"move%.l %1,%0\\;clr%.l %0\";\n-  if (which_alternative == 2)\n-    return \"clr%.l %0\\;move%.l %1,%0\";\n-  if (GET_CODE (operands[0]) == REG)\n-    operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  else\n-    operands[2] = adjust_address (operands[0], SImode, 4);\n-  if (GET_CODE (operands[1]) == REG)\n-    operands[3] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-  else\n-    operands[3] = adjust_address (operands[1], SImode, 4);\n-  if (ADDRESS_REG_P (operands[0]))\n-    return \"move%.l %1,%2\\;sub%.l %0,%0\";\n-  else\n-    return \"move%.l %1,%2\\;clr%.l %0\";\n+  operands[2] = GEN_INT (INTVAL (operands[2]) - 32);\n+  operands[3] = gen_highpart (SImode, operands[0]);\n+  operands[4] = gen_lowpart (SImode, operands[0]);\n })\n \n-;; The predicate below must be general_operand, because lshrdi3 allows that\n-(define_insn \"lshrdi_const\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"0\")\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (const_int 48)))]\n+  \"reload_completed\"\n+  [(set (match_dup 3) (match_dup 2))\n+   (set (strict_low_part (subreg:HI (match_dup 0) 6))\n+\t(const_int 0))\n+   (set (match_dup 2) (const_int 0))\n+   (set (match_dup 3)\n+\t(rotate:SI (match_dup 3) (const_int 16)))]\n+{\n+  operands[2] = gen_highpart (SImode, operands[0]);\n+  operands[3] = gen_lowpart (SImode, operands[0]);\n+})\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t     (match_operand 2 \"const_int_operand\" \"\")))]\n+  \"reload_completed && !TARGET_COLDFIRE\n+   && INTVAL (operands[2]) > 40 && INTVAL (operands[2]) <= 62\"\n+  [(set (match_dup 4) (match_dup 2))\n+   (set (match_dup 3) (lshiftrt:SI (match_dup 3) (match_dup 4)))\n+   (set (match_dup 4) (match_dup 3))\n+   (set (match_dup 3) (const_int 0))]\n+{\n+  operands[2] = GEN_INT (INTVAL (operands[2]) - 32);\n+  operands[3] = gen_highpart (SImode, operands[0]);\n+  operands[4] = gen_lowpart (SImode, operands[0]);\n+})\n+\n+(define_insn \"*lshrdi_const63\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t     (const_int 63)))]\n+  \"\"\n+  \"add%.l %0,%0\\;clr%.l %0\\;clr%.l %R1\\;addx%.l %R1,%R1\")\n+\n+(define_insn \"*lshrdi3_const\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n \t\t     (match_operand 2 \"const_int_operand\" \"n\")))]\n   \"(!TARGET_COLDFIRE\n-    && ((INTVAL (operands[2]) >= 1 && INTVAL (operands[2]) <= 3)\n+    && ((INTVAL (operands[2]) >= 2 && INTVAL (operands[2]) <= 3)\n \t || INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16\n \t || (INTVAL (operands[2]) > 32 && INTVAL (operands[2]) <= 63)))\"\n-{\n-  operands[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  if (INTVAL (operands[2]) == 63)\n-    return \"add%.l %0,%0\\;clr%.l %0\\;clr%.l %1\\;addx%.l %1,%1\";\n-  CC_STATUS_INIT;\n-  if (INTVAL (operands[2]) == 1)\n-    return \"lsr%.l #1,%0\\;roxr%.l #1,%1\";\n-  else if (INTVAL (operands[2]) == 8)\n-    return \"move%.b %0,%1\\;lsr%.l #8,%0\\;ror%.l #8,%1\";\n-  else if (INTVAL (operands[2]) == 16)\n-    return \"move%.w %0,%1\\;clr%.w %0\\;swap %1\\;swap %0\";\n-  else if (INTVAL (operands[2]) == 48)\n-    return \"move%.l %0,%1\\;clr%.w %1\\;clr%.l %0\\;swap %1\";\n-  else if (INTVAL (operands[2]) == 2)\n-    return \"lsr%.l #1,%0\\;roxr%.l #1,%1\\;lsr%.l #1,%0\\;roxr%.l #1,%1\";\n-  else if (INTVAL (operands[2]) == 3)\n-    return \"lsr%.l #1,%0\\;roxr%.l #1,%1\\;lsr%.l #1,%0\\;roxr%.l #1,%1\\;lsr%.l #1,%0\\;roxr%.l #1,%1\";\n-  else /* 32 < INTVAL (operands[2]) <= 63 */\n-    {\n-      operands[2] = GEN_INT (INTVAL (operands[2]) - 32);\n-      output_asm_insn (INTVAL (operands[2]) <= 8 ? \"lsr%.l %2,%0\" :\n-\t\t\t\"moveq %2,%1\\;lsr%.l %1,%0\", operands);\n-      return \"mov%.l %0,%1\\;moveq #0,%0\";\n-    }\n-})\n+  \"#\")\n \n (define_expand \"lshrdi3\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t     (match_operand 2 \"const_int_operand\" \"\")))]\n   \"!TARGET_COLDFIRE\"\n {"}]}