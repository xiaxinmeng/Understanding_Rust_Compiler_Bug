{"sha": "b063450945a40f5120cd5d836cc7e3487d7cda0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA2MzQ1MDk0NWE0MGY1MTIwY2Q1ZDgzNmNjN2UzNDg3ZDdjZGEwZQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-12-11T04:59:25Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-12-11T04:59:25Z"}, "message": "Approved by Jeffrey A Law:\n\n\t* reload1.c (reload_combine): Use BASIC_BLOCK_LIVE_AT_START\n\tto determine if a register is live at a jump destination.\n\tEverything is dead at a BARRIER.\n\nFrom-SVN: r24258", "tree": {"sha": "9f0a7734f63c0dacc4ec3e37383d7630e8c2fb6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f0a7734f63c0dacc4ec3e37383d7630e8c2fb6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b063450945a40f5120cd5d836cc7e3487d7cda0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b063450945a40f5120cd5d836cc7e3487d7cda0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b063450945a40f5120cd5d836cc7e3487d7cda0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b063450945a40f5120cd5d836cc7e3487d7cda0e/comments", "author": null, "committer": null, "parents": [{"sha": "2f058422b6dcb68193f3f880605d1af429b15604", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f058422b6dcb68193f3f880605d1af429b15604", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f058422b6dcb68193f3f880605d1af429b15604"}], "stats": {"total": 49, "additions": 47, "deletions": 2}, "files": [{"sha": "d9fa444a48fb1f8fe382840d371ac335cf209098", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b063450945a40f5120cd5d836cc7e3487d7cda0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b063450945a40f5120cd5d836cc7e3487d7cda0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b063450945a40f5120cd5d836cc7e3487d7cda0e", "patch": "@@ -1,3 +1,9 @@\n+Fri Dec 11 12:56:07 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* reload1.c (reload_combine): Use BASIC_BLOCK_LIVE_AT_START\n+\tto determine if a register is live at a jump destination.\n+\tEverything is dead at a BARRIER.\n+\n Thu Dec 10 16:02:06 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* cse.c (simplify_unary_operation): Sign-extend constants when"}, {"sha": "dca868526d7e18f71574e1c52721e45dd967b110", "filename": "gcc/reload1.c", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b063450945a40f5120cd5d836cc7e3487d7cda0e/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b063450945a40f5120cd5d836cc7e3487d7cda0e/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=b063450945a40f5120cd5d836cc7e3487d7cda0e", "patch": "@@ -9375,13 +9375,18 @@ static struct\n    and the store_ruid / use_ruid fields in reg_state.  */\n static int reload_combine_ruid;\n \n+#define LABEL_LIVE(LABEL) \\\n+  (label_live[CODE_LABEL_NUMBER (LABEL) - min_labelno])\n+\n static void\n reload_combine ()\n {\n   rtx insn, set;\n   int first_index_reg = 1, last_index_reg = 0;\n   int i;\n   int last_label_ruid;\n+  int min_labelno, n_labels;\n+  HARD_REG_SET ever_live_at_start, *label_live;\n \n   /* If reg+reg can be used in offsetable memory adresses, the main chunk of\n      reload has already used it where appropriate, so there is no use in\n@@ -9404,6 +9409,28 @@ reload_combine ()\n   if (first_index_reg > last_index_reg)\n     return;\n \n+  /* Set up LABEL_LIVE and EVER_LIVE_AT_START.  The register lifetime\n+     information is a bit fuzzy immediately after reload, but it's\n+     still good enough to determine which registers are live at a jump\n+     destination.  */\n+  min_labelno = get_first_label_num ();\n+  n_labels = max_label_num () - min_labelno;\n+  label_live = (HARD_REG_SET *) xmalloc (n_labels * sizeof (HARD_REG_SET));\n+  CLEAR_HARD_REG_SET (ever_live_at_start);\n+  for (i = n_basic_blocks - 1; i >= 0; i--)\n+    {\n+      insn = basic_block_head[i];\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\t{\n+\t  HARD_REG_SET live;\n+\n+\t  REG_SET_TO_HARD_REG_SET (live, basic_block_live_at_start[i]);\n+\t  compute_use_by_pseudos (&live, basic_block_live_at_start[i]);\n+\t  COPY_HARD_REG_SET (LABEL_LIVE (insn), live);\n+\t  IOR_HARD_REG_SET (ever_live_at_start, live);\n+\t}\n+    }\n+\n   /* Initialize last_label_ruid, reload_combine_ruid and reg_state.  */\n   last_label_ruid = reload_combine_ruid = 0;\n   for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; --i)\n@@ -9424,6 +9451,11 @@ reload_combine ()\n          is and then later disable any optimization that would cross it.  */\n       if (GET_CODE (insn) == CODE_LABEL)\n \tlast_label_ruid = reload_combine_ruid;\n+      if (GET_CODE (insn) == BARRIER)\n+\t{\n+\t  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; --i)\n+\t    reg_state[i].use_index = RELOAD_COMBINE_MAX_USES;\n+\t}\n       if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n \tcontinue;\n       reload_combine_ruid++;\n@@ -9578,13 +9610,19 @@ reload_combine ()\n \t\treg_state[regno].use_index = -1;\n \t    }\n \t}\n-      if (GET_CODE (insn) == JUMP_INSN)\n+      if (GET_CODE (insn) == JUMP_INSN && GET_CODE (PATTERN (insn)) != RETURN)\n \t{\n \t  /* Non-spill registers might be used at the call destination in\n \t     some unknown fashion, so we have to mark the unknown use.  */\n+\t  HARD_REG_SET *live;\n+\t  if ((condjump_p (insn) || condjump_in_parallel_p (insn))\n+\t      && JUMP_LABEL (insn))\n+\t    live = &LABEL_LIVE (JUMP_LABEL (insn));\n+\t  else\n+\t    live = &ever_live_at_start;\n \t  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; --i)\n \t    {\n-\t      if (1)\n+\t      if (TEST_HARD_REG_BIT (*live, i))\n \t\treg_state[i].use_index = -1;\n \t    }\n \t}\n@@ -9601,6 +9639,7 @@ reload_combine ()\n \t    }\n \t}\n     }\n+  free (label_live);\n }\n \n /* Check if DST is a register or a subreg of a register; if it is,"}]}