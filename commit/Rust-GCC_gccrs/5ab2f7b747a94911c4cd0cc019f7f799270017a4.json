{"sha": "5ab2f7b747a94911c4cd0cc019f7f799270017a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFiMmY3Yjc0N2E5NDkxMWM0Y2QwY2MwMTlmN2Y3OTkyNzAwMTdhNA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-11-17T14:47:07Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-11-17T14:47:07Z"}, "message": "* builtins.c: Fix formatting.\n\nFrom-SVN: r59194", "tree": {"sha": "53febe4d6fddb5382dbcd6fd61f1635b2ea3454d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53febe4d6fddb5382dbcd6fd61f1635b2ea3454d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ab2f7b747a94911c4cd0cc019f7f799270017a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ab2f7b747a94911c4cd0cc019f7f799270017a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ab2f7b747a94911c4cd0cc019f7f799270017a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ab2f7b747a94911c4cd0cc019f7f799270017a4/comments", "author": null, "committer": null, "parents": [{"sha": "7b8dbd504195b81937b0ad86cdd3ce5399a7b4f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b8dbd504195b81937b0ad86cdd3ce5399a7b4f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b8dbd504195b81937b0ad86cdd3ce5399a7b4f4"}], "stats": {"total": 83, "additions": 45, "deletions": 38}, "files": [{"sha": "bc2c88b905fa97b90ccfdbe677b41318c9645025", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ab2f7b747a94911c4cd0cc019f7f799270017a4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ab2f7b747a94911c4cd0cc019f7f799270017a4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ab2f7b747a94911c4cd0cc019f7f799270017a4", "patch": "@@ -1,3 +1,7 @@\n+2002-11-17  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* builtins.c: Fix formatting.\n+\n 2002-11-16  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.md (two anonymous patterns): Fix typos."}, {"sha": "7eea0365639a0c2dd2ba6417b6952edb2b579bc8", "filename": "gcc/builtins.c", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ab2f7b747a94911c4cd0cc019f7f799270017a4/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ab2f7b747a94911c4cd0cc019f7f799270017a4/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=5ab2f7b747a94911c4cd0cc019f7f799270017a4", "patch": "@@ -790,10 +790,10 @@ expand_builtin_prefetch (arglist)\n #ifdef HAVE_prefetch\n   if (HAVE_prefetch)\n     {\n-      if ((! (*insn_data[(int)CODE_FOR_prefetch].operand[0].predicate)\n+      if ((! (*insn_data[(int) CODE_FOR_prefetch].operand[0].predicate)\n \t     (op0,\n-\t      insn_data[(int)CODE_FOR_prefetch].operand[0].mode)) ||\n-\t  (GET_MODE(op0) != Pmode))\n+\t      insn_data[(int) CODE_FOR_prefetch].operand[0].mode))\n+\t  || (GET_MODE(op0) != Pmode))\n \t{\n #ifdef POINTERS_EXTEND_UNSIGNED\n \t  if (GET_MODE(op0) != Pmode)\n@@ -806,10 +806,10 @@ expand_builtin_prefetch (arglist)\n   else\n #endif\n     op0 = protect_from_queue (op0, 0);\n-    /* Don't do anything with direct references to volatile memory, but\n-       generate code to handle other side effects.  */\n-    if (GET_CODE (op0) != MEM && side_effects_p (op0))\n-      emit_insn (op0);\n+  /* Don't do anything with direct references to volatile memory, but\n+     generate code to handle other side effects.  */\n+  if (GET_CODE (op0) != MEM && side_effects_p (op0))\n+    emit_insn (op0);\n }\n \n /* Get a MEM rtx for expression EXP which is the address of an operand\n@@ -833,7 +833,7 @@ get_memory_rtx (exp)\n      If it is an ADDR_EXPR, use the operand.  Otherwise, dereference it if\n      we can.  First remove any nops.  */\n   while ((TREE_CODE (exp) == NOP_EXPR || TREE_CODE (exp) == CONVERT_EXPR\n-\t || TREE_CODE (exp) == NON_LVALUE_EXPR)\n+\t  || TREE_CODE (exp) == NON_LVALUE_EXPR)\n \t && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (exp, 0))))\n     exp = TREE_OPERAND (exp, 0);\n \n@@ -887,7 +887,7 @@ apply_args_register_offset (regno)\n   /* Arguments are always put in outgoing registers (in the argument\n      block) if such make sense.  */\n #ifdef OUTGOING_REGNO\n-  regno = OUTGOING_REGNO(regno);\n+  regno = OUTGOING_REGNO (regno);\n #endif\n   return apply_args_reg_offset[regno];\n }\n@@ -1014,7 +1014,7 @@ apply_result_size ()\n \t\t   mode = GET_MODE_WIDER_MODE (mode))\n \t\tif (HARD_REGNO_MODE_OK (regno, mode)\n \t\t    && have_insn_for (SET, mode))\n-\t\t      best_mode = mode;\n+\t\t  best_mode = mode;\n \n \t    if (best_mode == VOIDmode)\n \t      for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_INT);\n@@ -1262,7 +1262,7 @@ expand_builtin_apply (function, arguments, argsize)\n       emit_move_insn (value, adjust_address (arguments, Pmode, size));\n       emit_move_insn (struct_value_rtx, value);\n       if (GET_CODE (struct_value_rtx) == REG)\n-\t  use_reg (&call_fusage, struct_value_rtx);\n+\tuse_reg (&call_fusage, struct_value_rtx);\n       size += GET_MODE_SIZE (Pmode);\n     }\n \n@@ -1652,7 +1652,7 @@ expand_builtin_strlen (exp, target)\n \n       /* Mark the beginning of the strlen sequence so we can emit the\n \t source operand later.  */\n-      before_strlen = get_last_insn();\n+      before_strlen = get_last_insn ();\n \n       char_rtx = const0_rtx;\n       char_mode = insn_data[(int) icode].operand[2].mode;\n@@ -2179,14 +2179,14 @@ builtin_memset_gen_str (data, offset, mode)\n   char *p;\n \n   size = GET_MODE_SIZE (mode);\n-  if (size==1)\n-    return (rtx)data;\n+  if (size == 1)\n+    return (rtx) data;\n \n   p = alloca (size);\n   memset (p, 1, size);\n   coeff = c_readstr (p, mode);\n \n-  target = convert_to_mode (mode, (rtx)data, 1);\n+  target = convert_to_mode (mode, (rtx) data, 1);\n   target = expand_mult (mode, target, coeff, NULL_RTX, 1);\n   return force_reg (mode, target);\n }\n@@ -2257,7 +2257,7 @@ expand_builtin_memset (exp, target, mode)\n \t  dest_mem = get_memory_rtx (dest);\n \t  store_by_pieces (dest_mem, tree_low_cst (len, 1),\n \t\t\t   builtin_memset_gen_str,\n-\t\t\t   (PTR)val_rtx, dest_align);\n+\t\t\t   (PTR) val_rtx, dest_align);\n \t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n #ifdef POINTERS_EXTEND_UNSIGNED\n \t  if (GET_MODE (dest_mem) != ptr_mode)\n@@ -3241,7 +3241,7 @@ expand_builtin_va_end (arglist)\n \n #ifdef EXPAND_BUILTIN_VA_END\n   valist = stabilize_va_list (valist, 0);\n-  EXPAND_BUILTIN_VA_END(arglist);\n+  EXPAND_BUILTIN_VA_END (arglist);\n #else\n   /* Evaluate for side effects, if needed.  I hate macros that don't\n      do that.  */\n@@ -4257,29 +4257,32 @@ validate_arglist VPARAMS ((tree arglist, ...))\n   VA_OPEN (ap, arglist);\n   VA_FIXEDARG (ap, tree, arglist);\n \n-  do {\n-    code = va_arg (ap, enum tree_code);\n-    switch (code)\n+  do\n     {\n-    case 0:\n-      /* This signifies an ellipses, any further arguments are all ok.  */\n-      res = 1;\n-      goto end;\n-    case VOID_TYPE:\n-      /* This signifies an endlink, if no arguments remain, return\n-         true, otherwise return false.  */\n-      res = arglist == 0;\n-      goto end;\n-    default:\n-      /* If no parameters remain or the parameter's code does not\n-         match the specified code, return false.  Otherwise continue\n-         checking any remaining arguments.  */\n-      if (arglist == 0 || code != TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))))\n-\tgoto end;\n-      break;\n+      code = va_arg (ap, enum tree_code);\n+      switch (code)\n+\t{\n+\tcase 0:\n+\t  /* This signifies an ellipses, any further arguments are all ok.  */\n+\t  res = 1;\n+\t  goto end;\n+\tcase VOID_TYPE:\n+\t  /* This signifies an endlink, if no arguments remain, return\n+\t     true, otherwise return false.  */\n+\t  res = arglist == 0;\n+\t  goto end;\n+\tdefault:\n+\t  /* If no parameters remain or the parameter's code does not\n+\t     match the specified code, return false.  Otherwise continue\n+\t     checking any remaining arguments.  */\n+\t  if (arglist == 0\n+\t      || code != TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))))\n+\t    goto end;\n+\t  break;\n+\t}\n+      arglist = TREE_CHAIN (arglist);\n     }\n-    arglist = TREE_CHAIN (arglist);\n-  } while (1);\n+  while (1);\n \n   /* We need gotos here since we can only have one VA_CLOSE in a\n      function.  */"}]}