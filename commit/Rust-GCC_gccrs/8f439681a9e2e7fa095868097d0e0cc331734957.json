{"sha": "8f439681a9e2e7fa095868097d0e0cc331734957", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY0Mzk2ODFhOWUyZTdmYTA5NTg2ODA5N2QwZTBjYzMzMTczNDk1Nw==", "commit": {"author": {"name": "Revital Eres", "email": "eres@il.ibm.com", "date": "2009-06-05T15:28:50Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2009-06-05T15:28:50Z"}, "message": "misaligned store support\n\nCo-Authored-By: Leehod Baruch <leehod@il.ibm.com>\n\nFrom-SVN: r148211", "tree": {"sha": "571ecc16c72471ada3d0e6110405190f1bf85bd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/571ecc16c72471ada3d0e6110405190f1bf85bd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f439681a9e2e7fa095868097d0e0cc331734957", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f439681a9e2e7fa095868097d0e0cc331734957", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f439681a9e2e7fa095868097d0e0cc331734957", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f439681a9e2e7fa095868097d0e0cc331734957/comments", "author": {"login": "revit13", "id": 16211463, "node_id": "MDQ6VXNlcjE2MjExNDYz", "avatar_url": "https://avatars.githubusercontent.com/u/16211463?v=4", "gravatar_id": "", "url": "https://api.github.com/users/revit13", "html_url": "https://github.com/revit13", "followers_url": "https://api.github.com/users/revit13/followers", "following_url": "https://api.github.com/users/revit13/following{/other_user}", "gists_url": "https://api.github.com/users/revit13/gists{/gist_id}", "starred_url": "https://api.github.com/users/revit13/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/revit13/subscriptions", "organizations_url": "https://api.github.com/users/revit13/orgs", "repos_url": "https://api.github.com/users/revit13/repos", "events_url": "https://api.github.com/users/revit13/events{/privacy}", "received_events_url": "https://api.github.com/users/revit13/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b89f8e3cf93504308c957b408a96ef2866567ccc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b89f8e3cf93504308c957b408a96ef2866567ccc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b89f8e3cf93504308c957b408a96ef2866567ccc"}], "stats": {"total": 333, "additions": 233, "deletions": 100}, "files": [{"sha": "b2d2502fa52b9a1ccff551cdb6d7ecd250a38bfb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -1,3 +1,15 @@\n+2009-06-05  Revital Eres  <eres@il.ibm.com>\n+\t    Leehod Baruch  <leehod@il.ibm.com>\n+\n+\t* expr.c (expand_assignment): Expand MISALIGNED_INDIRECT_REF.\n+\t(expand_expr_real_1): Remove comment.\n+\t* tree-vect-data-refs.c (vect_enhance_data_refs_alignment):\n+\tVectorize misaligned access when the target supports it.\n+\t(vect_supportable_dr_alignment): Check for unaligned access\n+\tsupport.\n+\t* tree-vect-stmts.c (vectorizable_store): Generate misaligned store\n+\tand remove asset.\n+\n 2009-06-05  Julian Brown  <julian@codesourcery.com>\n \n \t* config/arm/ieee754-df.S (cmpdf2): Avoid writing below SP."}, {"sha": "f287c9f4f6208c8f29e6ec87bd3cb257f68cd7c0", "filename": "gcc/expr.c", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -4296,6 +4296,36 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       return;\n     }\n \n+   else if (TREE_CODE (to) == MISALIGNED_INDIRECT_REF)\n+     {\n+       enum machine_mode mode, op_mode1;\n+       enum insn_code icode;\n+       rtx reg, addr, mem, insn;\n+\n+       reg = expand_expr (from, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+       reg = force_not_mem (reg);\n+\n+       mode = TYPE_MODE (TREE_TYPE (to));\n+       addr = expand_expr (TREE_OPERAND (to, 0), NULL_RTX, VOIDmode,\n+                         EXPAND_SUM);\n+       addr = memory_address (mode, addr);\n+       mem = gen_rtx_MEM (mode, addr);\n+\n+       set_mem_attributes (mem, to, 0);\n+\n+       icode = movmisalign_optab->handlers[mode].insn_code;\n+       gcc_assert (icode != CODE_FOR_nothing);\n+\n+       op_mode1 = insn_data[icode].operand[1].mode;\n+       if (! (*insn_data[icode].operand[1].predicate) (reg, op_mode1)\n+           && op_mode1 != VOIDmode)\n+         reg = copy_to_mode_reg (op_mode1, reg);\n+\n+      insn = GEN_FCN (icode) (mem, reg);\n+       emit_insn (insn);\n+       return;\n+     }\n+\n   /* If the rhs is a function call and its value is not an aggregate,\n      call the function before we start to compute the lhs.\n      This is needed for correct code for cases such as\n@@ -7575,9 +7605,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n \t/* Resolve the misalignment now, so that we don't have to remember\n \t   to resolve it later.  Of course, this only works for reads.  */\n-\t/* ??? When we get around to supporting writes, we'll have to handle\n-\t   this in store_expr directly.  The vectorizer isn't generating\n-\t   those yet, however.  */\n \tif (code == MISALIGNED_INDIRECT_REF)\n \t  {\n \t    int icode;"}, {"sha": "e3aa9afafb72d7a55d9cacb7339a988356d01af0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -1,3 +1,45 @@\n+2009-06-05  Revital Eres  <eres@il.ibm.com>\n+\n+\t* lib/target-supports.exp:\n+\t(check_effective_target_vect_hw_misalign): New procedure.\n+\t* gcc.dg/vect/vect-50.c: Change checks to use vect_hw_misalign.\n+\t* gcc.dg/vect/vect-33.c: Likewise.\n+\t* gcc.dg/vect/vect-92.c: Likewise.\n+\t* gcc.dg/vect/vect-58.c: Likewise.\n+\t* gcc.dg/vect/no-section-anchors-vect-69.c: Likewise.\n+\t* gcc.dg/vect/vect-42.c: Likewise.\n+\t* gcc.dg/vect/slp-25.c: Likewise.\n+\t* gcc.dg/vect/vect-align-1.c: Likewise.\n+\t* gcc.dg/vect/vect-align-2.c: Likewise.\n+\t* gcc.dg/vect/vect-93.c: Likewise.\n+\t* gcc.dg/vect/no-scevccp-outer-8.c: Likewise.\n+\t* gcc.dg/vect/costmodel/i386/costmodel-vect-31.c: Likewise.\n+\t* gcc.dg/vect/costmodel/i386/costmodel-vect-33.c: Likewise.\n+\t* gcc.dg/vect/costmodel/x86_64/costmodel-vect-31.c: Likewise.\n+\t* gcc.dg/vect/costmodel/x86_64/costmodel-vect-33.c: Likewise.\n+\t* gcc.dg/vect/vect-26.c: Likewise.\n+\t* gcc.dg/vect/vect-44.c: Likewise.\n+\t* gcc.dg/vect/vect-70.c: Likewise.\n+\t* gcc.dg/vect/vect-95.c: Likewise.\n+\t* gcc.dg/vect/no-section-anchors-vect-64.c: Likewise.\n+\t* gcc.dg/vect/vect-28.c: Likewise.\n+\t* gcc.dg/vect/no-section-anchors-vect-31.c: Likewise.\n+\t* gcc.dg/vect/vect-87.c: Likewise.\n+\t* gcc.dg/vect/vect-109.c: Likewise.\n+\t* gcc.dg/vect/vect-54.c: Likewise.\n+\t* gcc.dg/vect/vect-96.c: Likewise.\n+\t* gcc.dg/vect/vect-multitypes-1.c: Likewise.\n+\t* gcc.dg/vect/vect-88.c: Likewise.\n+\t* gcc.dg/vect/no-section-anchors-vect-66.c: Likewise.\n+\t* gcc.dg/vect/vect-89.c: Likewise.\n+\t* gcc.dg/vect/vect-91.c: Likewise.\n+\t* gcc.dg/vect/no-section-anchors-vect-68.c: Likewise.\n+\t* gcc.dg/vect/vect-multitypes-4.c: Likewise.\n+\t* gfortran.dg/vect/vect-2.f90: Likewise.\n+\t* gfortran.dg/vect/vect-3.f90: Likewise.\n+\t* gfortran.dg/vect/vect-4.f90: Likewise.\n+\t* gfortran.dg/vect/vect-5.f90: Likewise.\n+\n 2009-06-05  Alexander Strange <astrange@ithinksw.com>\n \n \tPR tree-optimization/36318"}, {"sha": "da7b7c3b3f8b361ecd56e4b3079c37429e464371", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-vect-31.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-31.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -86,7 +86,8 @@ int main (void)\n   return main1 ();\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } }\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" { xfail vect_hw_misalign } } }\n  */\n-/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\" { target vect_hw_misalign } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "8a14ededc2522dbf60a1ecc71dc3cd2ac845a1e3", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-vect-33.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-33.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -36,5 +36,5 @@ int main (void)\n   return main1 ();\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" { xfail vect_hw_misalign } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "4490cdc218249363f19b8901ab70acfeaa3729c3", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-vect-31.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-31.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -86,7 +86,7 @@ int main (void)\n   return main1 ();\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } }\n- */\n-/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" { xfail vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { target {! vect_hw_misalign} } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\" { target {vect_hw_misalign } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "8a14ededc2522dbf60a1ecc71dc3cd2ac845a1e3", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-vect-33.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-33.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -36,5 +36,5 @@ int main (void)\n   return main1 ();\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" { xfail vect_hw_misalign } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ea67946e5053f7c8537a2f4e1277191e1b1b207b", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-outer-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-outer-8.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -46,5 +46,5 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"OUTER LOOP VECTORIZED.\" 1 \"vect\" { xfail { ! { vect_hw_misalign } } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "6060a418a3d0ac77123e85a42c01b3df08c5ccfd", "filename": "gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-31.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-31.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -87,6 +87,7 @@ int main (void)\n } \n \n /* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" { xfail vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { target vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail vect_hw_misalign } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "2b6f99787c168ae1aba62f9ba5c1f63504d0e404", "filename": "gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-64.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-64.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -83,6 +83,7 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" { xfail vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { target vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail vect_hw_misalign } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "19bd4f12d0501e93a1b9f652a5aa958174825327", "filename": "gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-68.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-68.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-68.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-68.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -87,6 +87,7 @@ int main (void)\n } \n \n /* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\"  { xfail vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\"  { target vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail vect_hw_misalign } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "5f0aeaa9df19d237aa38270e84c279970e2b6b7f", "filename": "gcc/testsuite/gcc.dg/vect/no-section-anchors-vect-69.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-69.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-69.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-section-anchors-vect-69.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -113,8 +113,9 @@ int main (void)\n } \n \n /* { dg-final { scan-tree-dump-times \"vectorized 4 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail {! vector_alignment_reachable} } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target {! vector_alignment_reachable} } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target {! vector_alignment_reachable} } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" { xfail vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { target vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail { {! vector_alignment_reachable} || vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "d10720e7d8420eae5d6f86d04faca55a55e13cbe", "filename": "gcc/testsuite/gcc.dg/vect/slp-25.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-25.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -55,6 +55,7 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\"  } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" { xfail vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { target vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "173b8c06970579ac640a59aee76e912d75bb0cbf", "filename": "gcc/testsuite/gcc.dg/vect/vect-109.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-109.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-109.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-109.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -73,6 +73,7 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 2 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"not vectorized: unsupported unaligned store\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"not vectorized: unsupported unaligned store\" 2 \"vect\" { xfail vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 3 \"vect\" { target vect_hw_misalign } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "268ed05061f7271f1d3b8f47871433b92d89b1b2", "filename": "gcc/testsuite/gcc.dg/vect/vect-26.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-26.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -36,6 +36,6 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail {! vect_hw_misalign} } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_hw_misalign } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ddf1ee3b0ed688ad5e82525b2cd25b6363bcbdf2", "filename": "gcc/testsuite/gcc.dg/vect/vect-28.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-28.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -39,7 +39,7 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target vector_alignment_reachable } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { ! vector_alignment_reachable } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { ! { vect_hw_misalign } } } } }  */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target { vector_alignment_reachable && { ! { vect_hw_misalign } } } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "9ee4aecb2ea34aae8149f6b6e8d9de091b7a82d4", "filename": "gcc/testsuite/gcc.dg/vect/vect-33.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-33.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -38,7 +38,7 @@ int main (void)\n \n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target vector_alignment_reachable } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { ! vector_alignment_reachable } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { ! { vect_hw_misalign } } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { target { vector_alignment_reachable && {! vect_hw_misalign} } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } */ \n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "482a333d1efb0e8f1baea12ab11ad34d424a3273", "filename": "gcc/testsuite/gcc.dg/vect/vect-42.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-42.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-42.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-42.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -63,7 +63,7 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 3 \"vect\" { target { vect_no_align || { ! vector_alignment_reachable } } } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { xfail { vect_no_align || { ! vector_alignment_reachable } } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail {vect_no_align || { ! vector_alignment_reachable } } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 3 \"vect\" { target { vect_no_align || { { ! vector_alignment_reachable} && {!vect_hw_misalign} } } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { xfail { { vect_no_align || vect_hw_misalign } || { ! vector_alignment_reachable } } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { { vect_no_align || vect_hw_misalign } || { ! vector_alignment_reachable } } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "89d09b3653523abf2ad990137222479120977062", "filename": "gcc/testsuite/gcc.dg/vect/vect-44.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-44.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-44.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-44.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -65,8 +65,9 @@ int main (void)\n    two loads to be aligned).  */\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 3 \"vect\" { xfail { ! {vect_hw_misalign } } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { { vect_no_align || vect_hw_misalign } || {! vector_alignment_reachable} } } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 3 \"vect\" { target vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target { {! vector_alignment_reachable} && {! vect_no_align} } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target { {! vector_alignment_reachable} && {{! vect_no_align} && {! vect_hw_misalign} } } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "f247679a9892f9c88ca01dacc8b3c4173ac110bd", "filename": "gcc/testsuite/gcc.dg/vect/vect-50.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-50.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-50.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-50.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -56,13 +56,14 @@ int main (void)\n   return 0;\n }\n \n-/* For targets that don't support misaligned loads we version for the\n-   all three accesses (peeling to align the store will not force the\n-   two loads to be aligned).  */\n+/* For targets that don't support misaligned loads and don't support\n+   misaligned stores we version for the all three accesses (peeling to\n+   align the store will not force the two loads to be aligned).  */\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 3 \"vect\" { target vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { { vect_no_align || vect_hw_misalign } || {! vector_alignment_reachable} } } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 3 \"vect\" { target vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target { {! vector_alignment_reachable} && {! vect_no_align} } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target { {! vector_alignment_reachable} && {!vect_no_align && !vect_hw_misalign} } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "85387fa6a34beae5fe3636d012caaeed4a50113b", "filename": "gcc/testsuite/gcc.dg/vect/vect-54.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-54.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-54.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-54.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -59,6 +59,7 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 3 \"vect\" { target vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" { xfail vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_hw_misalign } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "bf206874ecde3b1e5cb3deecf23390fe13772f71", "filename": "gcc/testsuite/gcc.dg/vect/vect-70.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-70.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-70.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-70.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -63,7 +63,8 @@ int main (void)\n }\n           \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" {target vector_alignment_reachable } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" {target {! vector_alignment_reachable} } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" { xfail vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" {target { vector_alignment_reachable && { ! {vect_hw_misalign} } } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" {target {{! vector_alignment_reachable} && {! vect_hw_misalign} } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e7c5bbc71591b5c3494ff233c6ae4dd6420d28d7", "filename": "gcc/testsuite/gcc.dg/vect/vect-87.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-87.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-87.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-87.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -50,7 +50,8 @@ int main (void)\n \n /* Fails for targets that don't vectorize PLUS (e.g alpha).  */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" {target vector_alignment_reachable } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" {target {! vector_alignment_reachable} } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" { xfail vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" {target { vector_alignment_reachable && {! vect_hw_misalign} } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" {target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "4a6e7ae47f7cfb87ec8b382af232394a4e36270d", "filename": "gcc/testsuite/gcc.dg/vect/vect-89.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-89.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-89.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-89.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -45,6 +45,7 @@ int main (void)\n } \n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" { xfail vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_hw_misalign } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "c5aee4403f2d31c7b53125e29fa1500475f62faa", "filename": "gcc/testsuite/gcc.dg/vect/vect-91.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-91.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-91.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-91.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -58,7 +58,8 @@ main3 ()\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 3 \"vect\" { xfail vect_no_int_add } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 6 \"vect\" { target vect_hw_misalign } } } */\n /* { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 3 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" {target vector_alignment_reachable } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 3 \"vect\" {target {! vector_alignment_reachable} } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" {target { vector_alignment_reachable && {! vect_hw_misalign} } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 3 \"vect\" {target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "62aa97540f2594c8ea11d2e7264dc8ff944d760e", "filename": "gcc/testsuite/gcc.dg/vect/vect-92.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-92.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-92.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-92.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -91,6 +91,7 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 3 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 9 \"vect\" { target vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" { xfail vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" { xfail vect_hw_misalign } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "4c41e60df0afe635763f8d022a968ecafdb54c6c", "filename": "gcc/testsuite/gcc.dg/vect/vect-93.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-93.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-93.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-93.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -71,15 +71,16 @@ int main (void)\n \n /* main && main1 together: */\n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 2 \"vect\" { target powerpc*-*-* i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 3 \"vect\" { target vect_hw_misalign } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { target { vect_no_align && {! vector_alignment_reachable} } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" { xfail { { vect_no_align || vect_hw_misalign } || {! vector_alignment_reachable} } } } } */\n \n /* in main1: */\n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target !powerpc*-*-* !i?86-*-* !x86_64-*-* } } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" { target vect_no_align } } } */\n \n /* in main: */\n /* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" { target vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n \n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "9f1a2c4b256ce9cdf55b35eb572db44115788e90", "filename": "gcc/testsuite/gcc.dg/vect/vect-95.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-95.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-95.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-95.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -62,8 +62,9 @@ int main (void)\n    stores and generate misaligned accesses for the loads. For targets that \n    don't support unaligned loads we version for all four accesses.  */\n \n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 2 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { target vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n /*  { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" { target vect_no_align } } } */\n /*  { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 4 \"vect\" { target vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "1a6feca71cffc75458e4b3971e5da6d8b9e31e2c", "filename": "gcc/testsuite/gcc.dg/vect/vect-96.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-96.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -44,6 +44,6 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target { {! vect_no_align} && vector_alignment_reachable } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target { vect_no_align || {! vector_alignment_reachable} } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { { vect_no_align || vect_hw_misalign } || {! vector_alignment_reachable} } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target { vect_no_align || { {! vector_alignment_reachable} && {!vect_hw_misalign} } } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "099b7fea443ac1dad70202e1d7ab261cd1212a84", "filename": "gcc/testsuite/gcc.dg/vect/vect-align-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-align-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-align-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-align-1.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -46,6 +46,7 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { target vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { xfail vect_hw_misalign} } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "08a80112d73235a39db50658f8fbffe4a5706e29", "filename": "gcc/testsuite/gcc.dg/vect/vect-align-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-align-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-align-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-align-2.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -43,6 +43,6 @@ int main (void)\n \n \n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { xfail vect_hw_misalign} } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "1a0375266b07d9a175cd89618b2c8330889262f1", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-1.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -78,11 +78,11 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail {! vect_hw_misalign}  } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_no_align } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || vect_hw_misalign }} } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { xfail {! vect_hw_misalign} } } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "f1d62f7cd0e78b33656bfe07667c83281c07ac38", "filename": "gcc/testsuite/gcc.dg/vect/vect-multitypes-4.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-multitypes-4.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -85,10 +85,10 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail {! vect_hw_misalign} } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n /* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail vect_no_align } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 8 \"vect\" { xfail *-*-* } } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 4 \"vect\" { xfail vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "adc8d9c0b846d7eb9f2bc7db1823e6f87df7faed", "filename": "gcc/testsuite/gfortran.dg/vect/vect-2.f90", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-2.f90?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -15,8 +15,9 @@ SUBROUTINE FOO(A, B, C)\n ! support unaligned loads).\n \n ! { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } }\n-! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } }\n-! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { target { vect_no_align && {! vector_alignment_reachable} } } } }\n-! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail vect_no_align } } }\n-! { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 3 \"vect\" {target { vect_no_align || {! vector_alignment_reachable} } } } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" { xfail { { vect_no_align || vect_hw_misalign } || {! vector_alignment_reachable} } } } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" { target { vect_no_align && { {! vector_alignment_reachable } && {! vect_hw_misalign } } } } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { xfail { vect_no_align || vect_hw_misalign} } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 5 \"vect\" { target vect_hw_misalign } } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 3 \"vect\" {target { vect_no_align || { {!  vector_alignment_reachable  } && {! vect_hw_misalign }} } } } } \n ! { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "c0d7f0001d58f5fb45cde8459b554cd6636e20fe", "filename": "gcc/testsuite/gfortran.dg/vect/vect-3.f90", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-3.f90?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -8,11 +8,10 @@ SUBROUTINE SAXPY(X, Y, A, N)\n \n ! { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 3 \"vect\" { target vect_no_align } } }\n ! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" { target vect_no_align } } } \n-\n-! { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { {! vect_no_align} && {! vector_alignment_reachable} } } } }\n-! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { target { {! vect_no_align} && {! vector_alignment_reachable} } } } }\n-\n-! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } }\n-! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { {! vect_no_align} && { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { target { {! vect_no_align} && { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 3 \"vect\" {target vect_hw_misalign} } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { { vect_no_align || vect_hw_misalign } || {! vector_alignment_reachable}} } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { { vect_no_align || vect_hw_misalign } || { ! vector_alignment_reachable} } } } }\n \n ! { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "34047343692555d00bf2984cac1a9975d89c5890", "filename": "gcc/testsuite/gfortran.dg/vect/vect-4.f90", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-4.f90?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -10,8 +10,9 @@ SUBROUTINE SAXPY(X, Y, A)\n END\n \n ! { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } \n-! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } }\n-! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } }\n-! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { target {! vector_alignment_reachable} } } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { { vect_no_align || vect_hw_misalign } || {! vector_alignment_reachable} } } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { { vect_no_align || vect_hw_misalign } || {! vector_alignment_reachable} } } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 3 \"vect\" { target vect_hw_misalign } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } }\n ! { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 1 \"vect\" } }\n ! { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "c562a81bacc0a552bc58caac72041c7ec1bbd42b", "filename": "gcc/testsuite/gfortran.dg/vect/vect-5.f90", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-5.f90?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -36,8 +36,9 @@ program main\n         end\n \n ! { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } }\n-! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { vect_no_align || {! vector_alignment_reachable} } } } }\n-! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { vect_no_align } } } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail { { vect_no_align || vect_hw_misalign } || {! vector_alignment_reachable} } } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail { vect_no_align || vect_hw_misalign } } } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 2 \"vect\" { target { vect_hw_misalign } } } }\n ! { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 2 \"vect\" { target { vect_no_align } } } }\n-! { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target {! vector_alignment_reachable} } } }\n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning.\" 1 \"vect\" { target { {! vector_alignment_reachable} && {! vect_hw_misalign} } } } }\n ! { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "7703380b5ad30963c6e295c2011b4a7c92bc23fd", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -2220,6 +2220,26 @@ proc check_effective_target_vect_no_align { } {\n     return $et_vect_no_align_saved\n }\n \n+# Return 1 if the target supports a vector misalign access, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vect_hw_misalign { } {\n+    global et_vect_hw_misalign_saved\n+\n+    if [info exists et_vect_hw_misalign_saved] {\n+        verbose \"check_effective_target_vect_hw_misalign: using cached result\" 2\n+    } else {\n+        set et_vect_hw_misalign_saved 0\n+       if { [istarget x86_64-*-*] } {\n+          set et_vect_hw_misalign_saved 1\n+       }\n+    }\n+    verbose \"check_effective_target_vect_hw_misalign: returning $et_vect_hw_misalign_saved\" 2\n+    return $et_vect_hw_misalign_saved\n+}\n+\n+\n # Return 1 if arrays are aligned to the vector alignment\n # boundary, 0 otherwise.\n #"}, {"sha": "7646cc1ad0f290d0290349dce17da5301fadfa29", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -1138,11 +1138,10 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   /* While cost model enhancements are expected in the future, the high level\n      view of the code at this time is as follows:\n \n-     A) If there is a misaligned write then see if peeling to align this write\n-        can make all data references satisfy vect_supportable_dr_alignment.\n-        If so, update data structures as needed and return true.  Note that\n-        at this time vect_supportable_dr_alignment is known to return false\n-        for a misaligned write.\n+     A) If there is an unsupported misaligned access then see if peeling\n+        to align this access can make all data references satisfy\n+        vect_supportable_dr_alignment.  If so, update data structures\n+        as needed and return true.\n \n      B) If peeling wasn't possible and there is a data reference with an\n         unknown misalignment that does not satisfy vect_supportable_dr_alignment\n@@ -1169,23 +1168,23 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n        in code size).\n \n      The scheme we use FORNOW: peel to force the alignment of the first\n-     misaligned store in the loop.\n-     Rationale: misaligned stores are not yet supported.\n+     unsupported misaligned access in the loop.\n \n      TODO: Use a cost model.  */\n \n   for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n     {\n       stmt = DR_STMT (dr);\n       stmt_info = vinfo_for_stmt (stmt);\n+      supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n \n       /* For interleaving, only the alignment of the first access\n          matters.  */\n       if (STMT_VINFO_STRIDED_ACCESS (stmt_info)\n           && DR_GROUP_FIRST_DR (stmt_info) != stmt)\n         continue;\n \n-      if (!DR_IS_READ (dr) && !aligned_access_p (dr))\n+      if (!supportable_dr_alignment)\n         {\n \t  do_peeling = vector_alignment_reachable_p (dr);\n \t  if (do_peeling)\n@@ -3475,6 +3474,11 @@ vect_supportable_dr_alignment (struct data_reference *dr)\n \t/* Can't software pipeline the loads, but can at least do them.  */\n \treturn dr_unaligned_supported;\n     }\n+   else\n+     {\n+       if (movmisalign_optab->handlers[mode].insn_code != CODE_FOR_nothing)\n+         return dr_unaligned_supported;\n+     }\n \n   /* Unsupported.  */\n   return dr_unaligned_unsupported;"}, {"sha": "f9fc0f59aaf3e560106c55aa849aae04f8f70723", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f439681a9e2e7fa095868097d0e0cc331734957/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=8f439681a9e2e7fa095868097d0e0cc331734957", "patch": "@@ -3018,7 +3018,6 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n   alignment_support_scheme = vect_supportable_dr_alignment (first_dr);\n   gcc_assert (alignment_support_scheme);\n-  gcc_assert (alignment_support_scheme == dr_aligned);  /* FORNOW */\n \n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n@@ -3157,7 +3156,16 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t       vect_permute_store_chain().  */\n \t    vec_oprnd = VEC_index (tree, result_chain, i);\n \n-\t  data_ref = build_fold_indirect_ref (dataref_ptr);\n+          if (aligned_access_p (first_dr))\n+            data_ref = build_fold_indirect_ref (dataref_ptr);\n+          else\n+          {\n+            int mis = DR_MISALIGNMENT (first_dr);\n+            tree tmis = (mis == -1 ? size_zero_node : size_int (mis));\n+            tmis = size_binop (MULT_EXPR, tmis, size_int (BITS_PER_UNIT));\n+            data_ref = build2 (MISALIGNED_INDIRECT_REF, vectype, dataref_ptr, tmis);\n+           }\n+\n \t  /* If accesses through a pointer to vectype do not alias the original\n \t     memory reference we have a problem.  This should never happen.  */\n \t  gcc_assert (alias_sets_conflict_p (get_alias_set (data_ref),"}]}