{"sha": "be35cf60c40ae1c70bb1d1520f66141228d53aa5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUzNWNmNjBjNDBhZTFjNzBiYjFkMTUyMGY2NjE0MTIyOGQ1M2FhNQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-09-26T08:32:40Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-09-26T08:32:40Z"}, "message": "re PR tree-optimization/17591 (Ada bootstrap SEGV in stage2 on osint.adb, no SEGV when -fno-ivopts)\n\n\tPR bootstrap/17591\n\t* tree-ssa-loop-im.c (for_each_index): Call callback for component_refs\n\twith varying offset.\n\t* tree-ssa-loop-ivopts.c (abnormal_ssa_name_p): New function.\n\t(idx_contains_abnormal_ssa_name_p): Scan step and lower bound for\n\tARRAY_REFS.\n\t(expr_invariant_in_loop_p): New function.\n\t(idx_find_step): Handle step and lower bound for ARRAY_REFs.  Handle\n\tcomponent_ref_field_offset for COMPONENT_REFs.  Do not allow\n\tALIGN_INDIRECT_REFs and MISALIGNED_INDIRECT_REFs.\n\t(add_address_candidates): Do not handle ALIGN_INDIRECT_REFs and\n\tMISALIGNED_INDIRECT_REFs.\n\t(idx_remove_ssa_names): Handle step and lower bound for ARRAY_REFs.\n\t(rewrite_address_base): Do not handle ALIGN_INDIRECT_REFs and\n\tMISALIGNED_INDIRECT_REFs.\n\nFrom-SVN: r88123", "tree": {"sha": "9fbca781fd14460ac4104a6cc02b07fbb1a75822", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fbca781fd14460ac4104a6cc02b07fbb1a75822"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be35cf60c40ae1c70bb1d1520f66141228d53aa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be35cf60c40ae1c70bb1d1520f66141228d53aa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be35cf60c40ae1c70bb1d1520f66141228d53aa5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be35cf60c40ae1c70bb1d1520f66141228d53aa5/comments", "author": null, "committer": null, "parents": [{"sha": "34096b92f493baa7e052bea535c03b90ab12a181", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34096b92f493baa7e052bea535c03b90ab12a181", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34096b92f493baa7e052bea535c03b90ab12a181"}], "stats": {"total": 194, "additions": 148, "deletions": 46}, "files": [{"sha": "c89c8ed8520ba0f205e2209a5e1c5795654a9dd2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be35cf60c40ae1c70bb1d1520f66141228d53aa5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be35cf60c40ae1c70bb1d1520f66141228d53aa5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be35cf60c40ae1c70bb1d1520f66141228d53aa5", "patch": "@@ -1,3 +1,21 @@\n+2004-09-26  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\tPR bootstrap/17591\n+\t* tree-ssa-loop-im.c (for_each_index): Call callback for component_refs\n+\twith varying offset.\n+\t* tree-ssa-loop-ivopts.c (abnormal_ssa_name_p): New function.\n+\t(idx_contains_abnormal_ssa_name_p): Scan step and lower bound for\n+\tARRAY_REFS.\n+\t(expr_invariant_in_loop_p): New function.\n+\t(idx_find_step): Handle step and lower bound for ARRAY_REFs.  Handle\n+\tcomponent_ref_field_offset for COMPONENT_REFs.  Do not allow\n+\tALIGN_INDIRECT_REFs and MISALIGNED_INDIRECT_REFs.\n+\t(add_address_candidates): Do not handle ALIGN_INDIRECT_REFs and\n+\tMISALIGNED_INDIRECT_REFs.\n+\t(idx_remove_ssa_names): Handle step and lower bound for ARRAY_REFs.\n+\t(rewrite_address_base): Do not handle ALIGN_INDIRECT_REFs and\n+\tMISALIGNED_INDIRECT_REFs.\n+\n 2004-09-26  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \tPR c/11459"}, {"sha": "0330a278009cfd361bd0e4f2e8dde2a9b2022efe", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be35cf60c40ae1c70bb1d1520f66141228d53aa5/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be35cf60c40ae1c70bb1d1520f66141228d53aa5/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=be35cf60c40ae1c70bb1d1520f66141228d53aa5", "patch": "@@ -128,7 +128,7 @@ get_stmt_uid (tree stmt)\n bool\n for_each_index (tree *addr_p, bool (*cbck) (tree, tree *, void *), void *data)\n {\n-  tree *nxt;\n+  tree *nxt, *idx;\n \n   for (; ; addr_p = nxt)\n     {\n@@ -144,14 +144,24 @@ for_each_index (tree *addr_p, bool (*cbck) (tree, tree *, void *), void *data)\n \t  return cbck (*addr_p, nxt, data);\n \n \tcase BIT_FIELD_REF:\n-\tcase COMPONENT_REF:\n \tcase VIEW_CONVERT_EXPR:\n \tcase ARRAY_RANGE_REF:\n \tcase REALPART_EXPR:\n \tcase IMAGPART_EXPR:\n \t  nxt = &TREE_OPERAND (*addr_p, 0);\n \t  break;\n \n+\tcase COMPONENT_REF:\n+\t  /* If the component has varying offset, it behaves like index\n+\t     as well.  */\n+\t  idx = &TREE_OPERAND (*addr_p, 2);\n+\t  if (*idx\n+\t      && !cbck (*addr_p, idx, data))\n+\t    return false;\n+\n+\t  nxt = &TREE_OPERAND (*addr_p, 0);\n+\t  break;\n+\n \tcase ARRAY_REF:\n \t  nxt = &TREE_OPERAND (*addr_p, 0);\n \t  if (!cbck (*addr_p, &TREE_OPERAND (*addr_p, 1), data))"}, {"sha": "d0b468f2c1c569af302c1e53b506ed59a1c79562", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 118, "deletions": 44, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be35cf60c40ae1c70bb1d1520f66141228d53aa5/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be35cf60c40ae1c70bb1d1520f66141228d53aa5/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=be35cf60c40ae1c70bb1d1520f66141228d53aa5", "patch": "@@ -701,17 +701,36 @@ determine_biv_step (tree phi)\n   return step;\n }\n \n-/* Returns false if INDEX is a ssa name that occurs in an\n+/* Returns true if EXP is a ssa name that occurs in an abnormal phi node.  */\n+\n+static bool\n+abnormal_ssa_name_p (tree exp)\n+{\n+  if (!exp)\n+    return false;\n+\n+  if (TREE_CODE (exp) != SSA_NAME)\n+    return false;\n+\n+  return SSA_NAME_OCCURS_IN_ABNORMAL_PHI (exp) != 0;\n+}\n+\n+/* Returns false if BASE or INDEX contains a ssa name that occurs in an\n    abnormal phi node.  Callback for for_each_index.  */\n \n static bool\n-idx_contains_abnormal_ssa_name_p (tree base ATTRIBUTE_UNUSED, tree *index,\n+idx_contains_abnormal_ssa_name_p (tree base, tree *index,\n \t\t\t\t  void *data ATTRIBUTE_UNUSED)\n {\n-  if (TREE_CODE (*index) != SSA_NAME)\n-    return true;\n+  if (TREE_CODE (base) == ARRAY_REF)\n+    {\n+      if (abnormal_ssa_name_p (TREE_OPERAND (base, 2)))\n+\treturn false;\n+      if (abnormal_ssa_name_p (TREE_OPERAND (base, 3)))\n+\treturn false;\n+    }\n \n-  return SSA_NAME_OCCURS_IN_ABNORMAL_PHI (*index) == 0;\n+  return !abnormal_ssa_name_p (*index);\n }\n \n /* Returns true if EXPR contains a ssa name that occurs in an\n@@ -1146,6 +1165,39 @@ find_interesting_uses_cond (struct ivopts_data *data, tree stmt, tree *cond_p)\n   record_use (data, cond_p, civ, stmt, USE_COMPARE);\n }\n \n+/* Returns true if expression EXPR is obviously invariant in LOOP,\n+   i.e. if all its operands are defined outside of the LOOP.  */\n+\n+static bool\n+expr_invariant_in_loop_p (struct loop *loop, tree expr)\n+{\n+  basic_block def_bb;\n+  unsigned i, len;\n+\n+  if (is_gimple_min_invariant (expr))\n+    return true;\n+\n+  if (TREE_CODE (expr) == SSA_NAME)\n+    {\n+      def_bb = bb_for_stmt (SSA_NAME_DEF_STMT (expr));\n+      if (def_bb\n+\t  && flow_bb_inside_loop_p (loop, def_bb))\n+\treturn false;\n+\n+      return true;\n+    }\n+\n+  if (!EXPR_P (expr))\n+    return false;\n+\n+  len = first_rtl_op (TREE_CODE (expr));\n+  for (i = 0; i < len; i++)\n+    if (!expr_invariant_in_loop_p (loop, TREE_OPERAND (expr, i)))\n+      return false;\n+\n+  return true;\n+}\n+\n /* Cumulates the steps of indices into DATA and replaces their values with the\n    initial ones.  Returns false when the value of the index cannot be determined.\n    Callback for for_each_index.  */\n@@ -1162,10 +1214,35 @@ idx_find_step (tree base, tree *idx, void *data)\n {\n   struct ifs_ivopts_data *dta = data;\n   struct iv *iv;\n-  tree step, type, iv_type, iv_step, lbound;\n-  basic_block def_bb;\n+  tree step, type, iv_type, iv_step, lbound, off;\n   struct loop *loop = dta->ivopts_data->current_loop;\n-  \n+\n+  if (TREE_CODE (base) == MISALIGNED_INDIRECT_REF\n+      || TREE_CODE (base) == ALIGN_INDIRECT_REF)\n+    return false;\n+\n+  /* If base is a component ref, require that the offset of the reference\n+     is invariant.  */\n+  if (TREE_CODE (base) == COMPONENT_REF)\n+    {\n+      off = component_ref_field_offset (base);\n+      return expr_invariant_in_loop_p (loop, off);\n+    }\n+\n+  /* If base is array, first check whether we will be able to move the\n+     reference out of the loop (in order to take its address in strength\n+     reduction).  In order for this to work we need both lower bound\n+     and step to be loop invariants.  */\n+  if (TREE_CODE (base) == ARRAY_REF)\n+    {\n+      step = array_ref_element_size (base);\n+      lbound = array_ref_low_bound (base);\n+\n+      if (!expr_invariant_in_loop_p (loop, step)\n+\t  || !expr_invariant_in_loop_p (loop, lbound))\n+\treturn false;\n+    }\n+\n   if (TREE_CODE (*idx) != SSA_NAME)\n     return true;\n \n@@ -1183,27 +1260,10 @@ idx_find_step (tree base, tree *idx, void *data)\n   if (TREE_CODE (base) == ARRAY_REF)\n     {\n       step = array_ref_element_size (base);\n-      lbound = array_ref_low_bound (base);\n \n       /* We only handle addresses whose step is an integer constant.  */\n       if (TREE_CODE (step) != INTEGER_CST)\n \treturn false;\n-\n-      /* We need the lower bound to be invariant in loop, since otherwise\n-\t we are unable to initialize a new induction variable created\n-\t in strength reduction -- we need to take the address of the\n-\t reference in front of the loop.  */\n-      if (is_gimple_min_invariant (lbound))\n-\t; /* Nothing to do.  */\n-      else if (TREE_CODE (lbound) != SSA_NAME)\n-\treturn false;\n-      else\n-\t{\n-\t  def_bb = bb_for_stmt (SSA_NAME_DEF_STMT (lbound));\n-\t  if (def_bb\n-\t      && flow_bb_inside_loop_p (loop, def_bb))\n-\t    return false;\n-\t}\n     }\n   else\n     /* The step for pointer arithmetics already is 1 byte.  */\n@@ -1269,9 +1329,10 @@ find_interesting_uses_address (struct ivopts_data *data, tree stmt, tree *op_p)\n       || zero_p (step))\n     goto fail;\n \n-  if (TREE_CODE (base) == INDIRECT_REF\n-      || TREE_CODE (base) == ALIGN_INDIRECT_REF\n-      || TREE_CODE (base) == MISALIGNED_INDIRECT_REF)\n+  gcc_assert (TREE_CODE (base) != ALIGN_INDIRECT_REF);\n+  gcc_assert (TREE_CODE (base) != MISALIGNED_INDIRECT_REF);\n+\n+  if (TREE_CODE (base) == INDIRECT_REF)\n     base = TREE_OPERAND (base, 0);\n   else\n     base = build_addr (base);\n@@ -1701,9 +1762,10 @@ add_address_candidates (struct ivopts_data *data,\n \n       if (base != TREE_OPERAND (iv->base, 0))\n \t{ \n-\t  if (TREE_CODE (base) == INDIRECT_REF\n-\t      || TREE_CODE (base) == ALIGN_INDIRECT_REF\n-\t      || TREE_CODE (base) == MISALIGNED_INDIRECT_REF)\n+\t  gcc_assert (TREE_CODE (base) != ALIGN_INDIRECT_REF);\n+\t  gcc_assert (TREE_CODE (base) != MISALIGNED_INDIRECT_REF);\n+\n+\t  if (TREE_CODE (base) == INDIRECT_REF)\n \t    base = TREE_OPERAND (base, 0);\n \t  else\n \t    base = build_addr (base);\n@@ -3805,11 +3867,26 @@ rewrite_use_nonlinear_expr (struct ivopts_data *data,\n    for_each_index.  */\n \n static bool\n-idx_remove_ssa_names (tree base ATTRIBUTE_UNUSED, tree *idx,\n+idx_remove_ssa_names (tree base, tree *idx,\n \t\t      void *data ATTRIBUTE_UNUSED)\n {\n+  tree *op;\n+\n   if (TREE_CODE (*idx) == SSA_NAME)\n     *idx = SSA_NAME_VAR (*idx);\n+\n+  if (TREE_CODE (base) == ARRAY_REF)\n+    {\n+      op = &TREE_OPERAND (base, 2);\n+      if (*op\n+\t  && TREE_CODE (*op) == SSA_NAME)\n+\t*op = SSA_NAME_VAR (*op);\n+      op = &TREE_OPERAND (base, 3);\n+      if (*op\n+\t  && TREE_CODE (*op) == SSA_NAME)\n+\t*op = SSA_NAME_VAR (*op);\n+    }\n+\n   return true;\n }\n \n@@ -3837,9 +3914,10 @@ rewrite_address_base (block_stmt_iterator *bsi, tree *op, tree with)\n \n   if (!var || TREE_CODE (with) != SSA_NAME)\n     goto do_rewrite;\n-  if (TREE_CODE (var) == INDIRECT_REF\n-      || TREE_CODE (var) == ALIGN_INDIRECT_REF\n-      || TREE_CODE (var) == MISALIGNED_INDIRECT_REF)\n+\n+  gcc_assert (TREE_CODE (var) != ALIGN_INDIRECT_REF);\n+  gcc_assert (TREE_CODE (var) != MISALIGNED_INDIRECT_REF);\n+  if (TREE_CODE (var) == INDIRECT_REF)\n     var = TREE_OPERAND (var, 0);\n   if (TREE_CODE (var) == SSA_NAME)\n     {\n@@ -3876,19 +3954,15 @@ rewrite_address_base (block_stmt_iterator *bsi, tree *op, tree with)\n do_rewrite:\n \n   orig = NULL_TREE;\n-  if (TREE_CODE (*op) == INDIRECT_REF\n-      || TREE_CODE (*op) == ALIGN_INDIRECT_REF\n-      || TREE_CODE (*op) == MISALIGNED_INDIRECT_REF)\n+  gcc_assert (TREE_CODE (*op) != ALIGN_INDIRECT_REF);\n+  gcc_assert (TREE_CODE (*op) != MISALIGNED_INDIRECT_REF);\n+\n+  if (TREE_CODE (*op) == INDIRECT_REF)\n     orig = REF_ORIGINAL (*op);\n   if (!orig)\n     orig = unshare_and_remove_ssa_names (*op);\n \n-  if (TREE_CODE (bvar) == ALIGN_INDIRECT_REF)\n-    *op = build1 (ALIGN_INDIRECT_REF, TREE_TYPE (*op), with);\n-  else if (TREE_CODE (bvar) == MISALIGNED_INDIRECT_REF)\n-    *op = build2 (MISALIGNED_INDIRECT_REF, TREE_TYPE (*op), with, TREE_OPERAND (*op, 1));\n-  else\n-    *op = build1 (INDIRECT_REF, TREE_TYPE (*op), with);\n+  *op = build1 (INDIRECT_REF, TREE_TYPE (*op), with);\n \n   /* Record the original reference, for purposes of alias analysis.  */\n   REF_ORIGINAL (*op) = orig;"}]}