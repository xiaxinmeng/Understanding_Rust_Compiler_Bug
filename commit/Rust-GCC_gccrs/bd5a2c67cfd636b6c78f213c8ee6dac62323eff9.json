{"sha": "bd5a2c67cfd636b6c78f213c8ee6dac62323eff9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ1YTJjNjdjZmQ2MzZiNmM3OGYyMTNjOGVlNmRhYzYyMzIzZWZmOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-10-26T16:53:43Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-10-26T16:53:43Z"}, "message": "Add wider_subreg_mode helper functions\n\nThis patch adds helper functions that say which of the two modes\ninvolved in a subreg is the larger, preferring the outer mode in\nthe event of a tie.  It also converts IRA and reload to track modes\ninstead of byte sizes, since this is slightly more convenient when\nvariable-sized modes are added later.\n\n2017-10-26  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* rtl.h (wider_subreg_mode): New function.\n\t* ira.h (ira_sort_regnos_for_alter_reg): Take a machine_mode *\n\trather than an unsigned int *.\n\t* ira-color.c (regno_max_ref_width): Replace with...\n\t(regno_max_ref_mode): ...this new variable.\n\t(coalesced_pseudo_reg_slot_compare): Update accordingly.\n\tUse wider_subreg_mode.\n\t(ira_sort_regnos_for_alter_reg): Likewise.  Take a machine_mode *\n\trather than an unsigned int *.\n\t* lra-constraints.c (uses_hard_regs_p): Use wider_subreg_mode.\n\t(process_alt_operands): Likewise.\n\t(invariant_p): Likewise.\n\t* lra-spills.c (assign_mem_slot): Likewise.\n\t(add_pseudo_to_slot): Likewise.\n\t* lra.c (collect_non_operand_hard_regs): Likewise.\n\t(add_regs_to_insn_regno_info): Likewise.\n\t* reload1.c (regno_max_ref_width): Replace with...\n\t(regno_max_ref_mode): ...this new variable.\n\t(reload): Update accordingly.  Update call to\n\tira_sort_regnos_for_alter_reg.\n\t(alter_reg): Update to use regno_max_ref_mode.  Call wider_subreg_mode.\n\t(init_eliminable_invariants): Update to use regno_max_ref_mode.\n\t(scan_paradoxical_subregs): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254115", "tree": {"sha": "793d74fec25534f3062be8641413cfa6430d1cf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/793d74fec25534f3062be8641413cfa6430d1cf0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9/comments", "author": null, "committer": null, "parents": [{"sha": "204d2c03acff4bf3b73cb5d2c9578b50c2aac703", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/204d2c03acff4bf3b73cb5d2c9578b50c2aac703", "html_url": "https://github.com/Rust-GCC/gccrs/commit/204d2c03acff4bf3b73cb5d2c9578b50c2aac703"}], "stats": {"total": 135, "additions": 89, "deletions": 46}, "files": [{"sha": "4312ac2d75e0e28c561b77121513c2742024219a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd5a2c67cfd636b6c78f213c8ee6dac62323eff9", "patch": "@@ -1,3 +1,31 @@\n+2017-10-26  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* rtl.h (wider_subreg_mode): New function.\n+\t* ira.h (ira_sort_regnos_for_alter_reg): Take a machine_mode *\n+\trather than an unsigned int *.\n+\t* ira-color.c (regno_max_ref_width): Replace with...\n+\t(regno_max_ref_mode): ...this new variable.\n+\t(coalesced_pseudo_reg_slot_compare): Update accordingly.\n+\tUse wider_subreg_mode.\n+\t(ira_sort_regnos_for_alter_reg): Likewise.  Take a machine_mode *\n+\trather than an unsigned int *.\n+\t* lra-constraints.c (uses_hard_regs_p): Use wider_subreg_mode.\n+\t(process_alt_operands): Likewise.\n+\t(invariant_p): Likewise.\n+\t* lra-spills.c (assign_mem_slot): Likewise.\n+\t(add_pseudo_to_slot): Likewise.\n+\t* lra.c (collect_non_operand_hard_regs): Likewise.\n+\t(add_regs_to_insn_regno_info): Likewise.\n+\t* reload1.c (regno_max_ref_width): Replace with...\n+\t(regno_max_ref_mode): ...this new variable.\n+\t(reload): Update accordingly.  Update call to\n+\tira_sort_regnos_for_alter_reg.\n+\t(alter_reg): Update to use regno_max_ref_mode.  Call wider_subreg_mode.\n+\t(init_eliminable_invariants): Update to use regno_max_ref_mode.\n+\t(scan_paradoxical_subregs): Likewise.\n+\n 2017-10-26  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/aarch64/aarch64.h (EXIT_IGNORE_STACK): Set if alloca is used."}, {"sha": "240eb48d3f0be14865ecc1ce7b823392028b1272", "filename": "gcc/ira-color.c", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=bd5a2c67cfd636b6c78f213c8ee6dac62323eff9", "patch": "@@ -3908,7 +3908,7 @@ coalesced_pseudo_reg_freq_compare (const void *v1p, const void *v2p)\n \n /* Widest width in which each pseudo reg is referred to (via subreg).\n    It is used for sorting pseudo registers.  */\n-static unsigned int *regno_max_ref_width;\n+static machine_mode *regno_max_ref_mode;\n \n /* Sort pseudos according their slot numbers (putting ones with\n   smaller numbers first, or last when the frame pointer is not\n@@ -3921,7 +3921,7 @@ coalesced_pseudo_reg_slot_compare (const void *v1p, const void *v2p)\n   ira_allocno_t a1 = ira_regno_allocno_map[regno1];\n   ira_allocno_t a2 = ira_regno_allocno_map[regno2];\n   int diff, slot_num1, slot_num2;\n-  int total_size1, total_size2;\n+  machine_mode mode1, mode2;\n \n   if (a1 == NULL || ALLOCNO_HARD_REGNO (a1) >= 0)\n     {\n@@ -3936,11 +3936,11 @@ coalesced_pseudo_reg_slot_compare (const void *v1p, const void *v2p)\n   if ((diff = slot_num1 - slot_num2) != 0)\n     return (frame_pointer_needed\n \t    || (!FRAME_GROWS_DOWNWARD) == STACK_GROWS_DOWNWARD ? diff : -diff);\n-  total_size1 = MAX (PSEUDO_REGNO_BYTES (regno1),\n-\t\t     regno_max_ref_width[regno1]);\n-  total_size2 = MAX (PSEUDO_REGNO_BYTES (regno2),\n-\t\t     regno_max_ref_width[regno2]);\n-  if ((diff = total_size2 - total_size1) != 0)\n+  mode1 = wider_subreg_mode (PSEUDO_REGNO_MODE (regno1),\n+\t\t\t     regno_max_ref_mode[regno1]);\n+  mode2 = wider_subreg_mode (PSEUDO_REGNO_MODE (regno2),\n+\t\t\t     regno_max_ref_mode[regno2]);\n+  if ((diff = GET_MODE_SIZE (mode2) - GET_MODE_SIZE (mode1)) != 0)\n     return diff;\n   return regno1 - regno2;\n }\n@@ -4144,7 +4144,7 @@ coalesce_spill_slots (ira_allocno_t *spilled_coalesced_allocnos, int num)\n    reload.  */\n void\n ira_sort_regnos_for_alter_reg (int *pseudo_regnos, int n,\n-\t\t\t       unsigned int *reg_max_ref_width)\n+\t\t\t       machine_mode *reg_max_ref_mode)\n {\n   int max_regno = max_reg_num ();\n   int i, regno, num, slot_num;\n@@ -4225,10 +4225,14 @@ ira_sort_regnos_for_alter_reg (int *pseudo_regnos, int n,\n \t  ira_assert (ALLOCNO_HARD_REGNO (a) < 0);\n \t  ALLOCNO_HARD_REGNO (a) = -slot_num;\n \t  if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n-\t    fprintf (ira_dump_file, \" a%dr%d(%d,%d)\",\n-\t\t     ALLOCNO_NUM (a), ALLOCNO_REGNO (a), ALLOCNO_FREQ (a),\n-\t\t     MAX (PSEUDO_REGNO_BYTES (ALLOCNO_REGNO (a)),\n-\t\t\t  reg_max_ref_width[ALLOCNO_REGNO (a)]));\n+\t    {\n+\t      machine_mode mode = wider_subreg_mode\n+\t\t(PSEUDO_REGNO_MODE (ALLOCNO_REGNO (a)),\n+\t\t reg_max_ref_mode[ALLOCNO_REGNO (a)]);\n+\t      fprintf (ira_dump_file, \" a%dr%d(%d,%d)\",\n+\t\t       ALLOCNO_NUM (a), ALLOCNO_REGNO (a), ALLOCNO_FREQ (a),\n+\t\t       GET_MODE_SIZE (mode));\n+\t    }\n \n \t  if (a == allocno)\n \t    break;\n@@ -4239,7 +4243,7 @@ ira_sort_regnos_for_alter_reg (int *pseudo_regnos, int n,\n   ira_spilled_reg_stack_slots_num = slot_num - 1;\n   ira_free (spilled_coalesced_allocnos);\n   /* Sort regnos according the slot numbers.  */\n-  regno_max_ref_width = reg_max_ref_width;\n+  regno_max_ref_mode = reg_max_ref_mode;\n   qsort (pseudo_regnos, n, sizeof (int), coalesced_pseudo_reg_slot_compare);\n   FOR_EACH_ALLOCNO (a, ai)\n     ALLOCNO_ADD_DATA (a) = NULL;"}, {"sha": "fba2ca53225de7173bf094772608f73114aa0d53", "filename": "gcc/ira.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=bd5a2c67cfd636b6c78f213c8ee6dac62323eff9", "patch": "@@ -195,7 +195,7 @@ extern void ira_set_pseudo_classes (bool, FILE *);\n extern void ira_expand_reg_equiv (void);\n extern void ira_update_equiv_info_by_shuffle_insn (int, int, rtx_insn *);\n \n-extern void ira_sort_regnos_for_alter_reg (int *, int, unsigned int *);\n+extern void ira_sort_regnos_for_alter_reg (int *, int, machine_mode *);\n extern void ira_mark_allocation_change (int);\n extern void ira_mark_memory_move_deletion (int, int);\n extern bool ira_reassign_pseudos (int *, int, HARD_REG_SET, HARD_REG_SET *,"}, {"sha": "a423f0698363610c0d188ffec52c8f4b3e8db4b2", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=bd5a2c67cfd636b6c78f213c8ee6dac62323eff9", "patch": "@@ -1772,10 +1772,9 @@ uses_hard_regs_p (rtx x, HARD_REG_SET set)\n   mode = GET_MODE (x);\n   if (code == SUBREG)\n     {\n+      mode = wider_subreg_mode (x);\n       x = SUBREG_REG (x);\n       code = GET_CODE (x);\n-      if (GET_MODE_SIZE (GET_MODE (x)) > GET_MODE_SIZE (mode))\n-\tmode = GET_MODE (x);\n     }\n \n   if (REG_P (x))\n@@ -1953,10 +1952,8 @@ process_alt_operands (int only_alternative)\n       biggest_mode[nop] = GET_MODE (op);\n       if (GET_CODE (op) == SUBREG)\n \t{\n+\t  biggest_mode[nop] = wider_subreg_mode (op);\n \t  operand_reg[nop] = reg = SUBREG_REG (op);\n-\t  if (GET_MODE_SIZE (biggest_mode[nop])\n-\t      < GET_MODE_SIZE (GET_MODE (reg)))\n-\t    biggest_mode[nop] = GET_MODE (reg);\n \t}\n       if (! REG_P (reg))\n \toperand_reg[nop] = NULL_RTX;\n@@ -5659,8 +5656,7 @@ invariant_p (const_rtx x)\n     {\n       x = SUBREG_REG (x);\n       code = GET_CODE (x);\n-      if (GET_MODE_SIZE (GET_MODE (x)) > GET_MODE_SIZE (mode))\n-\tmode = GET_MODE (x);\n+      mode = wider_subreg_mode (mode, GET_MODE (x));\n     }\n \n   if (MEM_P (x))"}, {"sha": "9abcda4467c2f7e7ffbf2c09e22cdf2f309090c8", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=bd5a2c67cfd636b6c78f213c8ee6dac62323eff9", "patch": "@@ -134,8 +134,7 @@ assign_mem_slot (int i)\n   machine_mode mode = GET_MODE (regno_reg_rtx[i]);\n   HOST_WIDE_INT inherent_size = PSEUDO_REGNO_BYTES (i);\n   machine_mode wider_mode\n-    = (GET_MODE_SIZE (mode) >= GET_MODE_SIZE (lra_reg_info[i].biggest_mode)\n-       ? mode : lra_reg_info[i].biggest_mode);\n+    = wider_subreg_mode (mode, lra_reg_info[i].biggest_mode);\n   HOST_WIDE_INT total_size = GET_MODE_SIZE (wider_mode);\n   HOST_WIDE_INT adjust = 0;\n \n@@ -312,10 +311,8 @@ add_pseudo_to_slot (int regno, int slot_num)\n      and a total size which provides room for paradoxical subregs.\n      We need to make sure the size and alignment of the slot are\n      sufficient for both.  */\n-  machine_mode mode = (GET_MODE_SIZE (PSEUDO_REGNO_MODE (regno))\n-\t\t       >= GET_MODE_SIZE (lra_reg_info[regno].biggest_mode)\n-\t\t       ? PSEUDO_REGNO_MODE (regno)\n-\t\t       : lra_reg_info[regno].biggest_mode);\n+  machine_mode mode = wider_subreg_mode (PSEUDO_REGNO_MODE (regno),\n+\t\t\t\t\t lra_reg_info[regno].biggest_mode);\n   unsigned int align = spill_slot_alignment (mode);\n   slots[slot_num].align = MAX (slots[slot_num].align, align);\n   slots[slot_num].size = MAX (slots[slot_num].size, GET_MODE_SIZE (mode));"}, {"sha": "66fbfd5477b37aabb5af02f80057cd552b93655e", "filename": "gcc/lra.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=bd5a2c67cfd636b6c78f213c8ee6dac62323eff9", "patch": "@@ -832,12 +832,11 @@ collect_non_operand_hard_regs (rtx *x, lra_insn_recog_data_t data,\n   subreg_p = false;\n   if (code == SUBREG)\n     {\n+      mode = wider_subreg_mode (op);\n       if (read_modify_subreg_p (op))\n \tsubreg_p = true;\n       op = SUBREG_REG (op);\n       code = GET_CODE (op);\n-      if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (op)))\n-\tmode = GET_MODE (op);\n     }\n   if (REG_P (op))\n     {\n@@ -1425,12 +1424,11 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x, int uid,\n   subreg_p = false;\n   if (GET_CODE (x) == SUBREG)\n     {\n+      mode = wider_subreg_mode (x);\n       if (read_modify_subreg_p (x))\n \tsubreg_p = true;\n       x = SUBREG_REG (x);\n       code = GET_CODE (x);\n-      if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (x)))\n-\tmode = GET_MODE (x);\n     }\n   if (REG_P (x))\n     {"}, {"sha": "e15bd8a2c1a94af0e517fd44a6e6bf462fd7ee33", "filename": "gcc/reload1.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=bd5a2c67cfd636b6c78f213c8ee6dac62323eff9", "patch": "@@ -97,8 +97,8 @@ static regset_head reg_has_output_reload;\n    in the current insn.  */\n static HARD_REG_SET reg_is_output_reload;\n \n-/* Widest width in which each pseudo reg is referred to (via subreg).  */\n-static unsigned int *reg_max_ref_width;\n+/* Widest mode in which each pseudo reg is referred to (via subreg).  */\n+static machine_mode *reg_max_ref_mode;\n \n /* Vector to remember old contents of reg_renumber before spilling.  */\n static short *reg_old_renumber;\n@@ -830,7 +830,7 @@ reload (rtx_insn *first, int global)\n   if (ira_conflicts_p)\n     /* Ask IRA to order pseudo-registers for better stack slot\n        sharing.  */\n-    ira_sort_regnos_for_alter_reg (temp_pseudo_reg_arr, n, reg_max_ref_width);\n+    ira_sort_regnos_for_alter_reg (temp_pseudo_reg_arr, n, reg_max_ref_mode);\n \n   for (i = 0; i < n; i++)\n     alter_reg (temp_pseudo_reg_arr[i], -1, false);\n@@ -1252,7 +1252,7 @@ reload (rtx_insn *first, int global)\n   /* Indicate that we no longer have known memory locations or constants.  */\n   free_reg_equiv ();\n \n-  free (reg_max_ref_width);\n+  free (reg_max_ref_mode);\n   free (reg_old_renumber);\n   free (pseudo_previous_regs);\n   free (pseudo_forbidden_regs);\n@@ -2142,8 +2142,9 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n       machine_mode mode = GET_MODE (regno_reg_rtx[i]);\n       unsigned int inherent_size = PSEUDO_REGNO_BYTES (i);\n       unsigned int inherent_align = GET_MODE_ALIGNMENT (mode);\n-      unsigned int total_size = MAX (inherent_size, reg_max_ref_width[i]);\n-      unsigned int min_align = reg_max_ref_width[i] * BITS_PER_UNIT;\n+      machine_mode wider_mode = wider_subreg_mode (mode, reg_max_ref_mode[i]);\n+      unsigned int total_size = GET_MODE_SIZE (wider_mode);\n+      unsigned int min_align = GET_MODE_BITSIZE (reg_max_ref_mode[i]);\n       int adjust = 0;\n \n       something_was_spilled = true;\n@@ -4083,9 +4084,9 @@ init_eliminable_invariants (rtx_insn *first, bool do_subregs)\n \n   grow_reg_equivs ();\n   if (do_subregs)\n-    reg_max_ref_width = XCNEWVEC (unsigned int, max_regno);\n+    reg_max_ref_mode = XCNEWVEC (machine_mode, max_regno);\n   else\n-    reg_max_ref_width = NULL;\n+    reg_max_ref_mode = NULL;\n \n   num_eliminable_invariants = 0;\n \n@@ -4404,7 +4405,7 @@ finish_spills (int global)\n   return something_changed;\n }\n \f\n-/* Find all paradoxical subregs within X and update reg_max_ref_width.  */\n+/* Find all paradoxical subregs within X and update reg_max_ref_mode.  */\n \n static void\n scan_paradoxical_subregs (rtx x)\n@@ -4427,13 +4428,14 @@ scan_paradoxical_subregs (rtx x)\n       return;\n \n     case SUBREG:\n-      if (REG_P (SUBREG_REG (x))\n-\t  && (GET_MODE_SIZE (GET_MODE (x))\n-\t      > reg_max_ref_width[REGNO (SUBREG_REG (x))]))\n+      if (REG_P (SUBREG_REG (x)))\n \t{\n-\t  reg_max_ref_width[REGNO (SUBREG_REG (x))]\n-\t    = GET_MODE_SIZE (GET_MODE (x));\n-\t  mark_home_live_1 (REGNO (SUBREG_REG (x)), GET_MODE (x));\n+\t  unsigned int regno = REGNO (SUBREG_REG (x));\n+\t  if (partial_subreg_p (reg_max_ref_mode[regno], GET_MODE (x)))\n+\t    {\n+\t      reg_max_ref_mode[regno] = GET_MODE (x);\n+\t      mark_home_live_1 (regno, GET_MODE (x));\n+\t    }\n \t}\n       return;\n "}, {"sha": "8e82f045402235727c8bd18d6553a3dd1d297b54", "filename": "gcc/rtl.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd5a2c67cfd636b6c78f213c8ee6dac62323eff9/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=bd5a2c67cfd636b6c78f213c8ee6dac62323eff9", "patch": "@@ -2877,6 +2877,24 @@ subreg_lowpart_offset (machine_mode outermode, machine_mode innermode)\n \t\t\t\t     GET_MODE_SIZE (innermode));\n }\n \n+/* Given that a subreg has outer mode OUTERMODE and inner mode INNERMODE,\n+   return the mode that is big enough to hold both the outer and inner\n+   values.  Prefer the outer mode in the event of a tie.  */\n+\n+inline machine_mode\n+wider_subreg_mode (machine_mode outermode, machine_mode innermode)\n+{\n+  return partial_subreg_p (outermode, innermode) ? innermode : outermode;\n+}\n+\n+/* Likewise for subreg X.  */\n+\n+inline machine_mode\n+wider_subreg_mode (const_rtx x)\n+{\n+  return wider_subreg_mode (GET_MODE (x), GET_MODE (SUBREG_REG (x)));\n+}\n+\n extern unsigned int subreg_size_highpart_offset (unsigned int, unsigned int);\n \n /* Return the SUBREG_BYTE for an OUTERMODE highpart of an INNERMODE value.  */"}]}