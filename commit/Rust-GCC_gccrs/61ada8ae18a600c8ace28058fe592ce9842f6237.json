{"sha": "61ada8ae18a600c8ace28058fe592ce9842f6237", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFhZGE4YWUxOGE2MDBjOGFjZTI4MDU4ZmU1OTJjZTk4NDJmNjIzNw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-06-26T05:03:55Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-06-26T05:03:55Z"}, "message": "c-typeck.c, [...]: Fix comment typos.\n\n\t* c-typeck.c, cfgexpand.c, ddg.c, ddg.h, df.c, fold-const.c,\n\tgcov.c, gimplify.c, modulo-sched.c, passes.c, tree-cfg.c,\n\ttree-mudflap.c, tree-nrv.c, tree-outof-ssa.c, tree-ssa-dom.c,\n\ttree-ssa-dse.c, tree-ssa-operands.c, tree-ssa-pre.c,\n\ttree-tailcall.c: Fix comment typos.  Follow spelling\n\tconventions.\n\nFrom-SVN: r83703", "tree": {"sha": "33b4de272330067b4be95383df8cefd291cd4392", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33b4de272330067b4be95383df8cefd291cd4392"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61ada8ae18a600c8ace28058fe592ce9842f6237", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61ada8ae18a600c8ace28058fe592ce9842f6237", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61ada8ae18a600c8ace28058fe592ce9842f6237", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61ada8ae18a600c8ace28058fe592ce9842f6237/comments", "author": null, "committer": null, "parents": [{"sha": "e1152c0bc885278944dfbfa1c877e045702abc3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1152c0bc885278944dfbfa1c877e045702abc3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1152c0bc885278944dfbfa1c877e045702abc3f"}], "stats": {"total": 79, "additions": 44, "deletions": 35}, "files": [{"sha": "b22693a90cf85a0171df61c958eb6885afc06b80", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -1,3 +1,12 @@\n+2004-06-26  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* c-typeck.c, cfgexpand.c, ddg.c, ddg.h, df.c, fold-const.c,\n+\tgcov.c, gimplify.c, modulo-sched.c, passes.c, tree-cfg.c,\n+\ttree-mudflap.c, tree-nrv.c, tree-outof-ssa.c, tree-ssa-dom.c,\n+\ttree-ssa-dse.c, tree-ssa-operands.c, tree-ssa-pre.c,\n+\ttree-tailcall.c: Fix comment typos.  Follow spelling\n+\tconventions.\n+\n 2004-06-25  Eric Christopher  <echristo@redhat.com>\n \n \t* config/mips/mips.md: Add back scheduling exclusion info."}, {"sha": "2a2c2548e1401567a94881841ae54abbfdc2cf3b", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -6490,7 +6490,7 @@ c_finish_if_stmt (location_t if_locus, tree cond, tree then_block,\n     {\n       tree inner_if = then_block;\n \n-      /* We know from the grammer productions that there is an IF nested\n+      /* We know from the grammar productions that there is an IF nested\n \t within THEN_BLOCK.  Due to labels and c99 conditional declarations,\n \t it might not be exactly THEN_BLOCK, but should be the last\n \t non-container statement within.  */\n@@ -6547,7 +6547,7 @@ c_finish_if_stmt (location_t if_locus, tree cond, tree then_block,\n /* Emit a general-purpose loop construct.  START_LOCUS is the location of\n    the beginning of the loop.  COND is the loop condition.  COND_IS_FIRST\n    is false for DO loops.  INCR is the FOR increment expression.  BODY is\n-   the statement controled by the loop.  BLAB is the break label.  CLAB is\n+   the statement controlled by the loop.  BLAB is the break label.  CLAB is\n    the continue label.  Everything is allowed to be NULL.  */\n \n void"}, {"sha": "1576566dc92a77ca9f7d1a30cecdd9dbf7cfb2e1", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -389,7 +389,7 @@ set_save_expr_context (tree *tp,\n    We do conversion per basic block and preserve/update the tree CFG.\n    This implies we have to do some magic as the CFG can simultaneously\n    consist of basic blocks containing RTL and GIMPLE trees.  This can\n-   confuse the CFG hooks, so be curefull to not manipulate CFG during\n+   confuse the CFG hooks, so be careful to not manipulate CFG during\n    the expansion.  */\n \n static void"}, {"sha": "00c78f9feefd0c3891af74948ea2feecb0daf601", "filename": "gcc/ddg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -383,7 +383,7 @@ build_intra_loop_deps (ddg_ptr g)\n   get_block_head_tail (g->bb->index, &head, &tail);\n   sched_analyze (&tmp_deps, head, tail);\n \n-  /* Build intra-loop data dependecies using the scheduler dependecy\n+  /* Build intra-loop data dependencies using the scheduler dependency\n      analysis.  */\n   for (i = 0; i < g->num_nodes; i++)\n     {\n@@ -509,7 +509,7 @@ create_ddg (basic_block bb, struct df *df, int closing_branch_deps)\n   if (!g->closing_branch)\n     abort ();  /* Found no branch in DDG.  */\n \n-  /* Build the data dependecy graph.  */\n+  /* Build the data dependency graph.  */\n   build_intra_loop_deps (g);\n   build_inter_loop_deps (g, df);\n   return g;"}, {"sha": "c958aec1eae12e1b9fb533b20903f467b64eae59", "filename": "gcc/ddg.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Fddg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Fddg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.h?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -92,7 +92,7 @@ struct ddg_edge\n   /* REG or MEM dependency.  */\n   dep_data_type data_type;\n \n-  /* Latency of the depedency.  */\n+  /* Latency of the dependency.  */\n   int latency;\n \n   /* The distance: number of loop iterations the dependency crosses.  */"}, {"sha": "e25c37a237aa1feae5222d0e3b5eaa62dc6c84e9", "filename": "gcc/df.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -2348,7 +2348,7 @@ prune_to_subcfg (int list[], unsigned len, bitmap blocks)\n   return last;\n }\n \n-/* Alternative entry point to the analysis.  Analyse just the part of the cfg\n+/* Alternative entry point to the analysis.  Analyze just the part of the cfg\n    graph induced by BLOCKS.\n    \n    TODO I am not quite sure how to avoid code duplication with df_analyze_1"}, {"sha": "24bde0fc323361937f972fba27e2653e3cef2f76", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -3717,7 +3717,7 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \n \n \t  /* If we're converting arg0 from an unsigned type, to exp,\n-\t     a signed type,  we will be doing the compairson as unsigned.\n+\t     a signed type,  we will be doing the comparison as unsigned.\n \t     The tests above have already verified that LOW and HIGH\n \t     are both positive.\n "}, {"sha": "6fd49699f194c7d60f29fcacae58eb8ff810407d", "filename": "gcc/gcov.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -1738,7 +1738,7 @@ accumulate_line_counts (source_t *src)\n     }\n }\n \n-/* Ouput information about ARC number IX.  Returns nonzero if\n+/* Output information about ARC number IX.  Returns nonzero if\n    anything is output.  */\n \n static int"}, {"sha": "347e946e265b20378fd15fa9133a52e3312bd28b", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -2641,7 +2641,7 @@ gimplify_modify_expr (tree *expr_p, tree *pre_p, tree *post_p, bool want_value)\n   return ret;\n }\n \n-/*  Subroutine of above to do simplications of MODIFY_EXPRs based on\n+/*  Subroutine of above to do simplifications of MODIFY_EXPRs based on\n     the code of the RHS.  We loop for as long as we can do something.  */\n \n static enum gimplify_status"}, {"sha": "68eeb364e9f82e04aca04f64e7429eb269cb3ca7", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -217,7 +217,7 @@ typedef struct node_sched_params\n \n \f\n /* The following three functions are copied from the current scheduler\n-   code in order to use sched_analyze() for computing the dependecies.\n+   code in order to use sched_analyze() for computing the dependencies.\n    They are used when initializing the sched_info structure.  */\n static const char *\n sms_print_insn (rtx insn, int aligned ATTRIBUTE_UNUSED)\n@@ -386,7 +386,7 @@ set_node_sched_params (ddg_ptr g)\n \t\t\t\tsizeof (struct node_sched_params));\n \n   /* Set the pointer of the general data of the node to point to the\n-     appropriate sched_params strcture.  */\n+     appropriate sched_params structure.  */\n   for (i = 0; i < g->num_nodes; i++)\n     {\n       /* Watch out for aliasing problems?  */\n@@ -447,7 +447,7 @@ calculate_maxii (ddg_ptr g)\n    of the register live range is more than ii; the number of moves is\n    determined according to the following equation:\n \t\tSCHED_TIME (use) - SCHED_TIME (def)   { 1 broken loop-carried\n-   nreg_moves = ----------------------------------- - {   dependecnce.\n+   nreg_moves = ----------------------------------- - {   dependence.\n \t\t\t      ii\t\t      { 0 if not.\n    This handles the modulo-variable-expansions (mve's) needed for the ps.  */\n static void\n@@ -832,7 +832,7 @@ sms_schedule (FILE *dump_file)\n   else\n     issue_rate = 1;\n \n-  /* Initilize the scheduler.  */\n+  /* Initialize the scheduler.  */\n   current_sched_info = &sms_sched_info;\n   sched_init (NULL);\n \n@@ -1526,7 +1526,7 @@ calculate_order_params (ddg_ptr g, int mii ATTRIBUTE_UNUSED)\n   node_order_params_arr = (nopa) xcalloc (num_nodes,\n \t\t\t\t\t  sizeof (struct node_order_params));\n \n-  /* Set the aux pointer of each node to point to its order_params strcture.  */\n+  /* Set the aux pointer of each node to point to its order_params structure.  */\n   for (u = 0; u < num_nodes; u++)\n     g->nodes[u].aux.info = &node_order_params_arr[u];\n "}, {"sha": "f6e1ad588ad531ba71e7031cddcd0c6ec51ae77a", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -758,7 +758,7 @@ rest_of_handle_sched (void)\n       close_dump_file (DFI_sms, print_rtl, get_insns ());\n \n \n-      /* Update the life information, becuase we add pseudos.  */\n+      /* Update the life information, because we add pseudos.  */\n       max_regno = max_reg_num ();\n       allocate_reg_info (max_regno, FALSE, FALSE);\n       update_life_info_in_dirty_blocks (UPDATE_LIFE_GLOBAL_RM_NOTES,"}, {"sha": "6855d712833a9b77d9440bcd4dfbb7cb1928699d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -3924,7 +3924,7 @@ thread_jumps (void)\n \t       dest = dest->succ->dest)\n \t    {\n \t      /* An infinite loop detected.  We redirect the edge anyway, so\n-\t\t that the loop is shrinked into single basic block.  */\n+\t\t that the loop is shrunk into single basic block.  */\n \t      if (!bb_ann (dest)->forwardable)\n \t\tbreak;\n "}, {"sha": "dcde2ac9555de422b94b661e780892efe80e5ce5", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -819,7 +819,7 @@ mx_register_decls (tree decl, tree *stmt_list)\n             {\n               /* Oh no ... it's probably a variable-length array (VLA).\n                  The size and address cannot be computed by merely\n-                 looking at the DECL.  See gimplfiy_decl_stmt for the\n+                 looking at the DECL.  See gimplify_decl_stmt for the\n                  method by which VLA declarations turn into calls to\n                  BUILT_IN_STACK_ALLOC.  We assume that multiple\n                  VLAs declared later in the same block get allocation "}, {"sha": "761bb03c94a090be5919036a1098be8704ba517f", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -85,7 +85,7 @@ finalize_nrv_r (tree *tp, int *walk_subtrees, void *data)\n   else if (TREE_CODE (*tp) == RETURN_EXPR)\n     TREE_OPERAND (*tp, 0) = dp->result;\n \n-  /* Othewise replace all occurrences of VAR with RESULT.  */\n+  /* Otherwise replace all occurrences of VAR with RESULT.  */\n   else if (*tp == dp->var)\n     *tp = dp->result;\n "}, {"sha": "7d195cc2e754a185bedede92bf090c9aa1221b82", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -1183,7 +1183,7 @@ coalesce_vars (var_map map, tree_live_info_p liveinfo)\n    it is replaced with the RHS of the defining expression.  */\n \n \n-/* Dependancy list element.  This can contain either a partition index or a\n+/* Dependency list element.  This can contain either a partition index or a\n    version number, depending on which list it is in.  */\n \n typedef struct value_expr_d \n@@ -1208,7 +1208,7 @@ typedef struct temp_expr_table_d\n   value_expr_p pending_dependence;\n } *temp_expr_table_p;\n \n-/* Used to indicate a dependancy on V_MAY_DEFs.  */\n+/* Used to indicate a dependency on V_MAY_DEFs.  */\n #define VIRTUAL_PARTITION(table)\t(table->virtual_partition)\n \n static temp_expr_table_p new_temp_expr_table (var_map);\n@@ -1398,8 +1398,8 @@ remove_value_from_list (value_expr_p *list, int value)\n }\n \n \n-/* Add a dependancy between the def of ssa VERSION and VAR.  if VAR is \n-   replaceable by an expression, add a dependance each of the elements of the \n+/* Add a dependency between the def of ssa VERSION and VAR.  If VAR is \n+   replaceable by an expression, add a dependence each of the elements of the \n    expression.  These are contained in the pending list.  TAB is the\n    expression table.  */\n \n@@ -1503,7 +1503,7 @@ check_replaceable (temp_expr_table_p tab, tree stmt)\n \n   version = SSA_NAME_VERSION (def);\n \n-  /* Add this expression to the dependancy list for each use partition.  */\n+  /* Add this expression to the dependency list for each use partition.  */\n   for (i = 0; i < num_use_ops; i++)\n     {\n       var = USE_OP (uses, i);\n@@ -1535,7 +1535,7 @@ finish_expr (temp_expr_table_p tab, int version, bool replace)\n   value_expr_p info, tmp;\n   int partition;\n \n-  /* Remove this expression from its dependent lists.  The partition dependance\n+  /* Remove this expression from its dependent lists.  The partition dependence\n      list is retained and transfered later to whomever uses this version.  */\n   for (info = (value_expr_p) tab->version_info[version]; info; info = tmp)\n     {\n@@ -1551,7 +1551,7 @@ finish_expr (temp_expr_table_p tab, int version, bool replace)\n         abort ();\n #endif\n       free_value_expr (tab, tmp);\n-      /* Only clear the bit when the dependancy list is emptied via \n+      /* Only clear the bit when the dependency list is emptied via \n          a replacement. Otherwise kill_expr will take care of it.  */\n       if (!(tab->partition_dep_list[partition]) && replace)\n         bitmap_clear_bit (tab->partition_in_use, partition);\n@@ -1610,7 +1610,7 @@ kill_expr (temp_expr_table_p tab, int partition, bool clear_bit)\n {\n   value_expr_p ptr;\n \n-  /* Mark every active expr dependant on this var as not replaceable.  */\n+  /* Mark every active expr dependent on this var as not replaceable.  */\n   while ((ptr = tab->partition_dep_list[partition]) != NULL)\n     finish_expr (tab, ptr->value, false);\n \n@@ -1619,7 +1619,7 @@ kill_expr (temp_expr_table_p tab, int partition, bool clear_bit)\n }\n \n \n-/* This function kills all expressions in TAB which are dependant on virtual \n+/* This function kills all expressions in TAB which are dependent on virtual \n    DEFs.  CLEAR_BIT determines whether partition_in_use gets cleared.  */\n \n static inline void\n@@ -1680,7 +1680,7 @@ find_replaceable_in_bb (temp_expr_table_p tab, basic_block bb)\n       if (!ann->has_volatile_ops)\n \tcheck_replaceable (tab, stmt);\n \n-      /* Free any unused dependancy lists.  */\n+      /* Free any unused dependency lists.  */\n       while ((p = tab->pending_dependence))\n \t{\n \t  tab->pending_dependence = p->next;"}, {"sha": "eadef0d41b85d69878c476a02b75013abdb7dea5", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -649,7 +649,7 @@ tree_ssa_dominator_optimize (void)\n   if (dump_file && (dump_flags & TDF_STATS))\n     dump_dominator_optimization_stats (dump_file);\n \n-  /* We emptyed the hash table earlier, now delete it completely.  */\n+  /* We emptied the hash table earlier, now delete it completely.  */\n   htab_delete (avail_exprs);\n \n   /* It is not necessary to clear CURRDEFS, REDIRECTION_EDGES, VRP_DATA,\n@@ -3361,7 +3361,7 @@ avail_expr_eq (const void *p1, const void *p2)\n   return false;\n }\n \n-/* Given STMT and a pointer to the block local defintions BLOCK_DEFS_P,\n+/* Given STMT and a pointer to the block local definitions BLOCK_DEFS_P,\n    register register all objects set by this statement into BLOCK_DEFS_P\n    and CURRDEFS.  */\n "}, {"sha": "ce28694805657a9e48570f2ad02745104208938d", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -55,7 +55,7 @@ Boston, MA 02111-1307, USA.  */\n \n    It may help to think of this as first moving the earlier store to\n    the point immediately before the later store.  Again, the single\n-   use of the virtual defintion and the post-dominance relationship\n+   use of the virtual definition and the post-dominance relationship\n    ensure that such movement would be safe.  Clearly if there are \n    back to back stores, then the second is redundant.\n "}, {"sha": "3129b9a0c3becd6d85b235c04317ef20f823e8cd", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -741,7 +741,7 @@ get_stmt_operands (tree stmt)\n   prev_vops.vuse_ops = VUSE_OPS (ann);\n   prev_vops.v_must_def_ops = V_MUST_DEF_OPS (ann);\n \n-  /* Dont free the previous values to memory since we're still using them.  */\n+  /* Don't free the previous values to memory since we're still using them.  */\n   free_v_may_defs (&(ann->v_may_def_ops), false);\n   free_vuses (&(ann->vuse_ops), false);\n   free_v_must_defs (&(ann->v_must_def_ops), false);"}, {"sha": "45ac8740ddabc2bdb03ee1243e24303db4cacb81", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -1151,7 +1151,7 @@ find_or_generate_expression (basic_block block, tree expr, tree stmts)\n   /* Depending on the order we process DOM branches in, the value\n      may not have propagated to all the dom children yet during\n      this iteration.  In this case, the value will always be in\n-     the NEW_SETS for us already, having been propogated from our\n+     the NEW_SETS for us already, having been propagated from our\n      dominator.  */\n   if (genop == NULL)\n     genop = find_leader (NEW_SETS (block), expr);"}, {"sha": "6036cfaad771a8960ce8f1742821981cf5182a5f", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61ada8ae18a600c8ace28058fe592ce9842f6237/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=61ada8ae18a600c8ace28058fe592ce9842f6237", "patch": "@@ -210,7 +210,7 @@ independent_of_stmt_p (tree expr, tree at, block_stmt_iterator bsi)\n       at = SSA_NAME_DEF_STMT (expr);\n       bb = bb_for_stmt (at);\n \n-      /* The default defininition or defined before the chain.  */\n+      /* The default definition or defined before the chain.  */\n       if (!bb || !bb->aux)\n \tbreak;\n "}]}