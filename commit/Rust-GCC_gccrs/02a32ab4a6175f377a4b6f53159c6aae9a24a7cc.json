{"sha": "02a32ab4a6175f377a4b6f53159c6aae9a24a7cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJhMzJhYjRhNjE3NWYzNzdhNGI2ZjUzMTU5YzZhYWU5YTI0YTdjYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-12-06T18:22:24Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-12-06T18:22:24Z"}, "message": "[C++] Pass type uses through the verify_type_context hook\n\nThis patch makes the C++ frontend work with the verify_type_context hook.\nWe need some new type contexts for features that don't exist in C, but\notherwise the patch is very similar to the C one.\n\nTCTX_CAPTURE_BY_COPY could really be treated as an instance of\nTCTX_FIELD, but the error message is better if we split it out.\n\n2019-12-06  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* target.h (TCTX_ALLOCATION, TCTX_DEALLOCATION, TCTX_EXCEPTIONS)\n\t(TCTX_CAPTURE_BY_COPY): New type_context_kinds.\n\t* config/aarch64/aarch64-sve-builtins.cc (verify_type_context):\n\tHandle them.\n\ngcc/cp/\n\t* decl.c (start_decl_1): Use verify_type_context to check whether\n\tthe target allows variables of a particular type to have static\n\tor thread-local storage duration.\n\t(check_array_initializer): Use verify_type_context to check whether\n\tthe target allows a particular type to be used as an array element.\n\t(create_array_type_for_decl): Likewise.\n\t(cp_finish_decl): Use verify_type_context to check whether\n\tthe target allows static member variables of a particular type.\n\t(grokdeclarator): Likewise.  Also use verify_type_context to check\n\twhether the target allows non-static member variables of a particular\n\ttype.\n\t* except.c: Include target.h.\n\t(is_admissible_throw_operand_or_catch_parameter): Use\n\tverify_type_context to check whether the target allows particular\n\ttypes to be thrown and caught.\n\t* typeck2.c (add_exception_specifier): Likewise.\n\t* init.c (build_new_1): Use verify_type_context to check whether\n\tthe target allows particular types to be dynamically allocated.\n\t(build_vec_delete_1, build_delete): Use verify_type_context to check\n\twhether the target allows particular types to be deleted.\n\t* lambda.c (add_capture): Use verify_type_context to check\n\twhether the target allows particular types to be captured by copy.\n\t* pt.c: Include target.h.\n\t(instantiate_class_template_1): Use verify_type_context to check\n\twhether the target allows non-static member variables of a particular\n\ttype.\n\t* typeck.c (cxx_alignof_expr): Use verify_type_context to check\n\twhether the target allows the alignment of a particular type\n\tto be measured.\n\t(pointer_diff, cp_build_unary_op): Use verify_type_context to check\n\twhether the target allows arithmetic involving pointers to particular\n\ttypes.\n\ngcc/testsuite/\n\t* g++.dg/ext/sve-sizeless-1.C: New test.\n\t* g++.dg/ext/sve-sizeless-2.C: Likewise.\n\nFrom-SVN: r279058", "tree": {"sha": "edbc148180bd6cb0282ec8b9b5fd5c124f0cdfd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/edbc148180bd6cb0282ec8b9b5fd5c124f0cdfd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1e8f5d49d791018310b9df540a3c19f7330351f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e8f5d49d791018310b9df540a3c19f7330351f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e8f5d49d791018310b9df540a3c19f7330351f6"}], "stats": {"total": 997, "additions": 995, "deletions": 2}, "files": [{"sha": "58969ceb3b9135f0300fa67af414ef928f9cc1b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02a32ab4a6175f377a4b6f53159c6aae9a24a7cc", "patch": "@@ -1,3 +1,10 @@\n+2019-12-06  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* target.h (TCTX_ALLOCATION, TCTX_DEALLOCATION, TCTX_EXCEPTIONS)\n+\t(TCTX_CAPTURE_BY_COPY): New type_context_kinds.\n+\t* config/aarch64/aarch64-sve-builtins.cc (verify_type_context):\n+\tHandle them.\n+\n 2019-12-06  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* config/gcn/gcn-valu.md (gather<mode>_insn_1offset<exec>): Use %o"}, {"sha": "88a8b791df713ddacaf3808588ce864416886c57", "filename": "gcc/config/aarch64/aarch64-sve-builtins.cc", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc?ref=02a32ab4a6175f377a4b6f53159c6aae9a24a7cc", "patch": "@@ -3352,6 +3352,26 @@ verify_type_context (location_t loc, type_context_kind context,\n       if (!silent_p)\n \terror_at (loc, \"array elements cannot have SVE type %qT\", type);\n       return false;\n+\n+    case TCTX_ALLOCATION:\n+      if (!silent_p)\n+\terror_at (loc, \"cannot allocate objects with SVE type %qT\", type);\n+      return false;\n+\n+    case TCTX_DEALLOCATION:\n+      if (!silent_p)\n+\terror_at (loc, \"cannot delete objects with SVE type %qT\", type);\n+      return false;\n+\n+    case TCTX_EXCEPTIONS:\n+      if (!silent_p)\n+\terror_at (loc, \"cannot throw or catch SVE type %qT\", type);\n+      return false;\n+\n+    case TCTX_CAPTURE_BY_COPY:\n+      if (!silent_p)\n+\terror_at (loc, \"capture by copy of SVE type %qT\", type);\n+      return false;\n     }\n   gcc_unreachable ();\n }"}, {"sha": "5b0f3cd81f2327213745ffa29af0cfef3c7ba985", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=02a32ab4a6175f377a4b6f53159c6aae9a24a7cc", "patch": "@@ -1,3 +1,38 @@\n+2019-12-06  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* decl.c (start_decl_1): Use verify_type_context to check whether\n+\tthe target allows variables of a particular type to have static\n+\tor thread-local storage duration.\n+\t(check_array_initializer): Use verify_type_context to check whether\n+\tthe target allows a particular type to be used as an array element.\n+\t(create_array_type_for_decl): Likewise.\n+\t(cp_finish_decl): Use verify_type_context to check whether\n+\tthe target allows static member variables of a particular type.\n+\t(grokdeclarator): Likewise.  Also use verify_type_context to check\n+\twhether the target allows non-static member variables of a particular\n+\ttype.\n+\t* except.c: Include target.h.\n+\t(is_admissible_throw_operand_or_catch_parameter): Use\n+\tverify_type_context to check whether the target allows particular\n+\ttypes to be thrown and caught.\n+\t* typeck2.c (add_exception_specifier): Likewise.\n+\t* init.c (build_new_1): Use verify_type_context to check whether\n+\tthe target allows particular types to be dynamically allocated.\n+\t(build_vec_delete_1, build_delete): Use verify_type_context to check\n+\twhether the target allows particular types to be deleted.\n+\t* lambda.c (add_capture): Use verify_type_context to check\n+\twhether the target allows particular types to be captured by copy.\n+\t* pt.c: Include target.h.\n+\t(instantiate_class_template_1): Use verify_type_context to check\n+\twhether the target allows non-static member variables of a particular\n+\ttype.\n+\t* typeck.c (cxx_alignof_expr): Use verify_type_context to check\n+\twhether the target allows the alignment of a particular type\n+\tto be measured.\n+\t(pointer_diff, cp_build_unary_op): Use verify_type_context to check\n+\twhether the target allows arithmetic involving pointers to particular\n+\ttypes.\n+\n 2019-12-05  Marek Polacek  <polacek@redhat.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "b5d689ad03ba52b476c9966ebc06ca7169e6d7e1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=02a32ab4a6175f377a4b6f53159c6aae9a24a7cc", "patch": "@@ -5470,6 +5470,13 @@ start_decl_1 (tree decl, bool initialized)\n       cp_apply_type_quals_to_decl (cp_type_quals (type), decl);\n     }\n \n+  if (is_global_var (decl))\n+    {\n+      type_context_kind context = (DECL_THREAD_LOCAL_P (decl)\n+\t\t\t\t   ? TCTX_THREAD_STORAGE\n+\t\t\t\t   : TCTX_STATIC_STORAGE);\n+      verify_type_context (input_location, context, TREE_TYPE (decl));\n+    }\n   if (initialized)\n     /* Is it valid for this decl to have an initializer at all?  */\n     {\n@@ -6535,6 +6542,11 @@ check_array_initializer (tree decl, tree type, tree init)\n \terror (\"elements of array %q#T have incomplete type\", type);\n       return true;\n     }\n+\n+  location_t loc = (decl ? location_of (decl) : input_location);\n+  if (!verify_type_context (loc, TCTX_ARRAY_ELEMENT, element_type))\n+    return true;\n+\n   /* A compound literal can't have variable size.  */\n   if (init && !decl\n       && ((COMPLETE_TYPE_P (type) && !TREE_CONSTANT (TYPE_SIZE (type)))\n@@ -7482,6 +7494,8 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \n   if (VAR_P (decl)\n       && DECL_CLASS_SCOPE_P (decl)\n+      && verify_type_context (DECL_SOURCE_LOCATION (decl),\n+\t\t\t      TCTX_STATIC_STORAGE, type)\n       && DECL_INITIALIZED_IN_CLASS_P (decl))\n     check_static_variable_definition (decl, type);\n \n@@ -10550,6 +10564,10 @@ create_array_type_for_decl (tree name, tree type, tree size, location_t loc)\n       break;\n     }\n \n+  if (!verify_type_context (name ? loc : input_location,\n+\t\t\t    TCTX_ARRAY_ELEMENT, type))\n+    return error_mark_node;\n+\n   /* [dcl.array]\n \n      The constant expressions that specify the bounds of the arrays\n@@ -13254,6 +13272,14 @@ grokdeclarator (const cp_declarator *declarator,\n \t\tdecl = NULL_TREE;\n \t      }\n \t  }\n+\telse if (!verify_type_context (input_location,\n+\t\t\t\t       staticp\n+\t\t\t\t       ? TCTX_STATIC_STORAGE\n+\t\t\t\t       : TCTX_FIELD, type))\n+\t  {\n+\t    type = error_mark_node;\n+\t    decl = NULL_TREE;\n+\t  }\n \telse\n \t  {\n \t    if (friendp)"}, {"sha": "8bc831d93e0176c32a2cdf4b95007fc1f7673a98", "filename": "gcc/cp/except.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=02a32ab4a6175f377a4b6f53159c6aae9a24a7cc", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"trans-mem.h\"\n #include \"attribs.h\"\n #include \"tree-iterator.h\"\n+#include \"target.h\"\n \n static void push_eh_cleanup (tree);\n static tree prepare_eh_type (tree);\n@@ -927,6 +928,10 @@ is_admissible_throw_operand_or_catch_parameter (tree t, bool is_throw)\n   if (!complete_ptr_ref_or_void_ptr_p (type, expr))\n     return false;\n \n+  tree nonref_type = non_reference (type);\n+  if (!verify_type_context (input_location, TCTX_EXCEPTIONS, nonref_type))\n+    return false;\n+\n   /* 10.4/3 An abstract class shall not be used as a parameter type,\n \t    as a function return type or as type of an explicit\n \t    conversion.  */"}, {"sha": "e40afe27e1a2909e9b8a6903a582e1167b25b28e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=02a32ab4a6175f377a4b6f53159c6aae9a24a7cc", "patch": "@@ -3058,6 +3058,10 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t\t\t\t    complain);\n     }\n \n+  if (!verify_type_context (input_location, TCTX_ALLOCATION, elt_type,\n+\t\t\t    !(complain & tf_error)))\n+    return error_mark_node;\n+\n   if (variably_modified_type_p (elt_type, NULL_TREE) && (complain & tf_error))\n     {\n       error (\"variably modified type not allowed in new-expression\");\n@@ -3942,6 +3946,10 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n   if (base == error_mark_node || maxindex == error_mark_node)\n     return error_mark_node;\n \n+  if (!verify_type_context (input_location, TCTX_DEALLOCATION, type,\n+\t\t\t    !(complain & tf_error)))\n+    return error_mark_node;\n+\n   if (!COMPLETE_TYPE_P (type))\n     {\n       if (complain & tf_warning)\n@@ -4827,6 +4835,11 @@ build_delete (tree otype, tree addr, special_function_kind auto_delete,\n       if (!VOID_TYPE_P (type))\n \t{\n \t  complete_type (type);\n+\t  if (deleting\n+\t      && !verify_type_context (input_location, TCTX_DEALLOCATION, type,\n+\t\t\t\t       !(complain & tf_error)))\n+\t    return error_mark_node;\n+\n \t  if (!COMPLETE_TYPE_P (type))\n \t    {\n \t      if (complain & tf_warning)"}, {"sha": "b448ea7e8d0f5206a0ff6cf3fd9c69f30fd231f5", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=02a32ab4a6175f377a4b6f53159c6aae9a24a7cc", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-iterator.h\"\n #include \"toplev.h\"\n #include \"gimplify.h\"\n+#include \"target.h\"\n \n /* Constructor for a lambda expression.  */\n \n@@ -579,6 +580,9 @@ add_capture (tree lambda, tree id, tree orig_init, bool by_reference_p,\n \t      cxx_incomplete_type_inform (type);\n \t      return error_mark_node;\n \t    }\n+\t  else if (!verify_type_context (input_location,\n+\t\t\t\t\t TCTX_CAPTURE_BY_COPY, type))\n+\t    return error_mark_node;\n \t}\n     }\n "}, {"sha": "d845a886b924c0e849c1316ef8efe29edba07cee", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=02a32ab4a6175f377a4b6f53159c6aae9a24a7cc", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n #include \"gcc-rich-location.h\"\n #include \"selftest.h\"\n+#include \"target.h\"\n \n /* The type of functions taking a tree, and some additional data, and\n    returning an int.  */\n@@ -11815,6 +11816,9 @@ instantiate_class_template_1 (tree type)\n \t\t\t      error (\"flexible array member %qD in union\", r);\n \t\t\t      TREE_TYPE (r) = error_mark_node;\n \t\t\t    }\n+\t\t\t  else if (!verify_type_context (input_location,\n+\t\t\t\t\t\t\t TCTX_FIELD, rtype))\n+\t\t\t    TREE_TYPE (r) = error_mark_node;\n \t\t\t}\n \n \t\t      /* If it is a TYPE_DECL for a class-scoped ENUMERAL_TYPE,"}, {"sha": "bf59550663b9a0854ff556a1c25f6b24e9f5cd20", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=02a32ab4a6175f377a4b6f53159c6aae9a24a7cc", "patch": "@@ -1824,7 +1824,14 @@ cxx_alignof_expr (tree e, tsubst_flags_t complain)\n \n   e = mark_type_use (e);\n \n-  if (VAR_P (e))\n+  if (!verify_type_context (input_location, TCTX_ALIGNOF, TREE_TYPE (e),\n+\t\t\t    !(complain & tf_error)))\n+    {\n+      if (!(complain & tf_error))\n+\treturn error_mark_node;\n+      t = size_one_node;\n+    }\n+  else if (VAR_P (e))\n     t = size_int (DECL_ALIGN_UNIT (e));\n   else if (bitfield_p (e))\n     {\n@@ -5778,6 +5785,13 @@ pointer_diff (location_t loc, tree op0, tree op1, tree ptrtype,\n       else\n \treturn error_mark_node;\n     }\n+  else if (!verify_type_context (loc, TCTX_POINTER_ARITH,\n+\t\t\t\t TREE_TYPE (TREE_TYPE (op0)),\n+\t\t\t\t !(complain & tf_error))\n+\t   || !verify_type_context (loc, TCTX_POINTER_ARITH,\n+\t\t\t\t    TREE_TYPE (TREE_TYPE (op1)),\n+\t\t\t\t    !(complain & tf_error)))\n+    return error_mark_node;\n \n   /* Determine integer type result of the subtraction.  This will usually\n      be the same as the result type (ptrdiff_t), but may need to be a wider\n@@ -6572,6 +6586,10 @@ cp_build_unary_op (enum tree_code code, tree xarg, bool noconvert,\n                 else\n                   return error_mark_node;\n               }\n+\t    else if (!verify_type_context (location, TCTX_POINTER_ARITH,\n+\t\t\t\t\t   TREE_TYPE (argtype),\n+\t\t\t\t\t   !(complain & tf_error)))\n+\t      return error_mark_node;\n \n \t    inc = cxx_sizeof_nowarn (TREE_TYPE (argtype));\n \t  }"}, {"sha": "1dbf8cd89cdde647426f1b74b9a650e5980cda7e", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=02a32ab4a6175f377a4b6f53159c6aae9a24a7cc", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"varasm.h\"\n #include \"intl.h\"\n #include \"gcc-rich-location.h\"\n+#include \"target.h\"\n \n static tree\n process_init_constructor (tree type, tree init, int nested, int flags,\n@@ -2401,6 +2402,9 @@ add_exception_specifier (tree list, tree spec, tsubst_flags_t complain)\n     ok = true;\n   else if (processing_template_decl)\n     ok = true;\n+  else if (!verify_type_context (input_location, TCTX_EXCEPTIONS, core,\n+\t\t\t\t !(complain & tf_error)))\n+    return error_mark_node;\n   else\n     {\n       ok = true;"}, {"sha": "8894574f8fd11e97ae80a349938136fa793253a0", "filename": "gcc/target.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=02a32ab4a6175f377a4b6f53159c6aae9a24a7cc", "patch": "@@ -249,7 +249,19 @@ enum type_context_kind {\n \n   /* Adding to or subtracting from a pointer to T, or computing the\n      difference between two pointers when one of them is a pointer to T.  */\n-  TCTX_POINTER_ARITH\n+  TCTX_POINTER_ARITH,\n+\n+  /* Dynamically allocating objects of type T.  */\n+  TCTX_ALLOCATION,\n+\n+  /* Dynamically deallocating objects of type T.  */\n+  TCTX_DEALLOCATION,\n+\n+  /* Throwing or catching an object of type T.  */\n+  TCTX_EXCEPTIONS,\n+\n+  /* Capturing objects of type T by value in a closure.  */\n+  TCTX_CAPTURE_BY_COPY\n };\n \n extern bool verify_type_context (location_t, type_context_kind, const_tree,"}, {"sha": "378e053f67ee06f4451a2eb812410e9c460dea49", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=02a32ab4a6175f377a4b6f53159c6aae9a24a7cc", "patch": "@@ -1,3 +1,8 @@\n+2019-12-06  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* g++.dg/ext/sve-sizeless-1.C: New test.\n+\t* g++.dg/ext/sve-sizeless-2.C: Likewise.\n+\n 2019-12-06  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \tPR c/36941"}, {"sha": "f82fb2a9a9e830c182776679824d95932714762f", "filename": "gcc/testsuite/g++.dg/ext/sve-sizeless-1.C", "status": "added", "additions": 420, "deletions": 0, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fsve-sizeless-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fsve-sizeless-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fsve-sizeless-1.C?ref=02a32ab4a6175f377a4b6f53159c6aae9a24a7cc", "patch": "@@ -0,0 +1,420 @@\n+// { dg-do compile { target aarch64*-*-* } }\n+// { dg-options \"-Wclass-memaccess\" }\n+\n+#pragma GCC target \"+sve\"\n+\n+typedef __SIZE_TYPE__ size_t;\n+inline void *operator new (size_t, void *__p) throw() { return __p; }\n+\n+#include <arm_sve.h>\n+\n+typedef signed char int8x32_t __attribute__((__vector_size__ (32)));\n+\n+// Sizeless objects with global scope.\n+\n+svint8_t global_sve_sc; // { dg-error {SVE type 'svint8_t' does not have a fixed size} }\n+static svint8_t local_sve_sc; // { dg-error {SVE type 'svint8_t' does not have a fixed size} }\n+extern svint8_t extern_sve_sc; // { dg-error {SVE type 'svint8_t' does not have a fixed size} }\n+__thread svint8_t tls_sve_sc; // { dg-error {variables of type 'svint8_t' cannot have thread-local storage duration} }\n+\n+// Sizeless arrays.\n+\n+typedef svint8_t array_type[2]; // { dg-error {array elements cannot have SVE type 'svint8_t'} }\n+extern svint8_t extern_array[]; // { dg-error {array elements cannot have SVE type 'svint8_t'} }\n+\n+// Sizeless member variables.\n+\n+struct struct1 {\n+  svint8_t a; // { dg-error {member variables cannot have SVE type 'svint8_t'} }\n+};\n+\n+union union1 {\n+  svint8_t a; // { dg-error {member variables cannot have SVE type 'svint8_t'} }\n+};\n+\n+#if __cplusplus >= 201103L\n+struct static_sve_sc {\n+  static svint8_t sve_sc1 = {}; // { dg-error {SVE type 'svint8_t' does not have a fixed size} \"\" { target c++11 } }\n+};\n+#endif\n+\n+// Sizeless member variables in templated structures.\n+\n+template<typename T>\n+struct templated_struct1 {\n+  svint8_t a; // { dg-error {member variables cannot have SVE type 'svint8_t'} }\n+};\n+\n+template<typename T>\n+struct templated_struct2 {\n+  T a; // { dg-error {member variables cannot have SVE type '(svint8_t|__SVInt8_t)'} }\n+};\n+\n+template class templated_struct2<svint8_t>;\n+\n+template<typename T>\n+struct templated_struct3 {\n+  T &a;\n+};\n+\n+template class templated_struct3<svint8_t>;\n+\n+#if __cplusplus >= 201103L\n+template<typename T>\n+struct templated_struct4 {\n+  static T a; // { dg-error {SVE type '(svint8_t|__SVInt8_t)' does not have a fixed size} \"\" { target c++11 } }\n+  static T b = {}; // { dg-error {SVE type '(svint8_t|__SVInt8_t)' does not have a fixed size} \"\" { target c++11 } }\n+};\n+\n+template class templated_struct4<svint8_t>;\n+#endif\n+\n+template<typename T> struct templated_struct5 : T {}; // { dg-error {base type '[^']*' fails to be a struct or class type} }\n+template class templated_struct5<svint8_t>;\n+\n+#if __cplusplus >= 201103L\n+template<int N> using typedef_sizeless1 = svint8_t;\n+template<int N> using typedef_sizeless1 = svint8_t; // { dg-error {redefinition of 'template<int N> using typedef_sizeless1 = svint8_t'} \"\" { target c++11 } }\n+template<typename T> using array = T[2];\n+#endif\n+\n+// Pointers to sizeless types.\n+\n+svint8_t *global_sve_sc_ptr;\n+\n+// Sizeless arguments and return values.\n+\n+void ext_consume_sve_sc (svint8_t);\n+void ext_consume_const_int_ref (const int &);\n+void ext_consume_varargs (int, ...);\n+svint8_t ext_produce_sve_sc ();\n+\n+// Sizeless types in throw specifications.\n+\n+#if __cplusplus < 201103L\n+void thrower1 () throw (svint8_t); // { dg-error {cannot throw or catch SVE type 'svint8_t'} \"\" { target c++98_only } }\n+void thrower2 () throw (svint8_t); // { dg-error {cannot throw or catch SVE type 'svint8_t'} \"\" { target c++98_only } }\n+void thrower3 () throw (svint8_t); // { dg-error {cannot throw or catch SVE type 'svint8_t'} \"\" { target c++98_only } }\n+#endif\n+\n+// Main tests for statements and expressions.\n+\n+void\n+statements (int n)\n+{\n+  // Local declarations.\n+\n+  svint8_t sve_sc1, sve_sc2;\n+  volatile svint8_t volatile_sve_sc1;\n+  int8x32_t gnu_sc1;\n+  svint16_t sve_sh1;\n+\n+  // Layout queries.\n+\n+  sizeof (svint8_t); // { dg-error {SVE type 'svint8_t' does not have a fixed size} }\n+  sizeof (sve_sc1); // { dg-error {SVE type 'svint8_t' does not have a fixed size} }\n+  sizeof (ext_produce_sve_sc ()); // { dg-error {SVE type 'svint8_t' does not have a fixed size} }\n+  __alignof (svint8_t); // { dg-error {SVE type 'svint8_t' does not have a defined alignment} }\n+  __alignof (sve_sc1); // { dg-error {SVE type 'svint8_t' does not have a defined alignment} }\n+  __alignof (ext_produce_sve_sc ()); // { dg-error {SVE type 'svint8_t' does not have a defined alignment} }\n+\n+#if __cplusplus >= 201103L\n+  array<svint8_t> foo = {}; // { dg-error {array elements cannot have SVE type '(svint8_t|__SVInt8_t)'} \"\" { target c++11 } }\n+#endif\n+\n+  // Initialization.\n+\n+  int init_int1 = sve_sc1; // { dg-error {cannot convert 'svint8_t' to 'int' in initialization} }\n+  int init_int2 = { sve_sc1 }; // { dg-error {cannot convert 'svint8_t' to 'int' in initialization} }\n+\n+  svint8_t init_sve_sc1 (sve_sc1);\n+  svint8_t init_sve_sc2 (sve_sh1); // { dg-error {cannot convert 'svint16_t' to 'svint8_t'} }\n+  svint8_t init_sve_sc3 = sve_sc1;\n+  svint8_t init_sve_sc4 = sve_sh1; // { dg-error {cannot convert 'svint16_t' to 'svint8_t'} }\n+  svint8_t init_sve_sc5 = {};\n+  svint8_t init_sve_sc6 = { sve_sc1 };\n+  svint8_t init_sve_sc7 = { sve_sh1 }; // { dg-error {cannot convert 'svint16_t' to 'svint8_t'} }\n+\n+  // Constructor calls.\n+\n+  (0, svint8_t ());\n+\n+  // Lvalue reference binding\n+\n+  svint8_t &lvalue_ref_sve_sc1 = sve_sc1;\n+  svint8_t &lvalue_ref_sve_sc2 = ext_produce_sve_sc (); // { dg-error {cannot bind non-const lvalue reference of type 'svint8_t&' to an rvalue of type 'svint8_t'} }\n+  svint8_t &lvalue_ref_sve_sc3 = sve_sh1; // { dg-error {invalid initialization of reference of type 'svint8_t&' from expression of type 'svint16_t'} }\n+\n+  const svint8_t &const_lvalue_ref_sve_sc1 = sve_sc1;\n+  const svint8_t &const_lvalue_ref_sve_sc2 = ext_produce_sve_sc ();\n+  const svint8_t &const_lvalue_ref_sve_sc3 = sve_sh1; // { dg-error {invalid initialization of reference of type 'const svint8_t&' from expression of type 'svint16_t'} }\n+\n+  // Compound literals.\n+\n+  (int) { sve_sc1 }; // { dg-error {cannot convert 'svint8_t' to 'int' in initialization} }\n+\n+  // Arrays.\n+\n+  svint8_t array[2]; // { dg-error {array elements cannot have SVE type 'svint8_t'} }\n+  svint8_t zero_length_array[0]; // { dg-error {array elements cannot have SVE type 'svint8_t'} }\n+  svint8_t empty_init_array[] = {}; // { dg-error {array elements cannot have SVE type 'svint8_t'} }\n+\n+  // Assignment.\n+\n+  n = sve_sc1; // { dg-error {cannot convert 'svint8_t' to 'int' in assignment} }\n+\n+  sve_sc1 = 0; // { dg-error {cannot convert 'int' to 'svint8_t' in assignment} }\n+  sve_sc1 = sve_sc1;\n+  sve_sc1 = gnu_sc1; // { dg-error {cannot convert 'int8x32_t'[^\\n]* to 'svint8_t' in assignment} }\n+  gnu_sc1 = sve_sc1; // { dg-error {cannot convert 'svint8_t' to 'int8x32_t'} }\n+  sve_sc1 = sve_sh1; // { dg-error {cannot convert 'svint16_t' to 'svint8_t'} }\n+\n+  // Casting.\n+\n+  (void) sve_sc1;\n+  (void) volatile_sve_sc1;\n+  (void) *&volatile_sve_sc1;\n+\n+  // Addressing and dereferencing.\n+\n+  svint8_t *sve_sc_ptr = &sve_sc1;\n+  int8x32_t *gnu_sc_ptr = &gnu_sc1;\n+  sve_sc_ptr = (svint16_t *) 0; // { dg-error {cannot convert 'svint16_t\\*' to 'svint8_t\\*' in assignment} }\n+\n+  // Pointer assignment.\n+\n+  gnu_sc_ptr = sve_sc_ptr; // { dg-error {cannot convert 'svint8_t\\*' to 'int8x32_t\\*'} }\n+  sve_sc_ptr = gnu_sc_ptr; // { dg-error {cannot convert 'int8x32_t\\*'[^\\n]* to 'svint8_t\\*'} }\n+\n+  // Pointer arithmetic.\n+\n+  ++sve_sc_ptr; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  --sve_sc_ptr; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  sve_sc_ptr++; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  sve_sc_ptr--; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  sve_sc_ptr += 0; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  sve_sc_ptr += 1; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  sve_sc_ptr -= 0; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  sve_sc_ptr -= 1; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  sve_sc_ptr - sve_sc_ptr; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  gnu_sc_ptr - sve_sc_ptr; // { dg-error {invalid operands of types 'int8x32_t\\*'[^\\n]* and 'svint8_t\\*' to binary 'operator-'} }\n+  sve_sc_ptr - gnu_sc_ptr; // { dg-error {invalid operands of types 'svint8_t\\*' and 'int8x32_t\\*'[^\\n]* to binary 'operator-'} }\n+  sve_sc1 = sve_sc_ptr[0]; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  sve_sc1 = sve_sc_ptr[1]; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+\n+  // Pointer comparison.\n+\n+  sve_sc_ptr == &sve_sc1;\n+  sve_sc_ptr != &sve_sc1;\n+  sve_sc_ptr < &sve_sc1;\n+  sve_sc_ptr <= &sve_sc1;\n+  sve_sc_ptr > &sve_sc1;\n+  sve_sc_ptr >= &sve_sc1;\n+  gnu_sc_ptr == sve_sc_ptr; // { dg-error {comparison between distinct pointer types [^\\n]*lacks a cast} }\n+  gnu_sc_ptr != sve_sc_ptr; // { dg-error {comparison between distinct pointer types [^\\n]*lacks a cast} }\n+  gnu_sc_ptr < sve_sc_ptr; // { dg-error {comparison between distinct pointer types [^\\n]*lacks a cast} }\n+  gnu_sc_ptr <= sve_sc_ptr; // { dg-error {comparison between distinct pointer types [^\\n]*lacks a cast} }\n+  gnu_sc_ptr > sve_sc_ptr; // { dg-error {comparison between distinct pointer types [^\\n]*lacks a cast} }\n+  gnu_sc_ptr >= sve_sc_ptr; // { dg-error {comparison between distinct pointer types [^\\n]*lacks a cast} }\n+  sve_sc_ptr == gnu_sc_ptr; // { dg-error {comparison between distinct pointer types [^\\n]*lacks a cast} }\n+  sve_sc_ptr != gnu_sc_ptr; // { dg-error {comparison between distinct pointer types [^\\n]*lacks a cast} }\n+  sve_sc_ptr < gnu_sc_ptr; // { dg-error {comparison between distinct pointer types [^\\n]*lacks a cast} }\n+  sve_sc_ptr <= gnu_sc_ptr; // { dg-error {comparison between distinct pointer types [^\\n]*lacks a cast} }\n+  sve_sc_ptr > gnu_sc_ptr; // { dg-error {comparison between distinct pointer types [^\\n]*lacks a cast} }\n+  sve_sc_ptr >= gnu_sc_ptr; // { dg-error {comparison between distinct pointer types [^\\n]*lacks a cast} }\n+\n+  // New and delete.\n+\n+  new svint8_t; // { dg-error {cannot allocate objects with SVE type 'svint8_t'} }\n+  new svint8_t (); // { dg-error {cannot allocate objects with SVE type 'svint8_t'} }\n+\n+  new (global_sve_sc_ptr) svint8_t; // { dg-error {cannot allocate objects with SVE type 'svint8_t'} }\n+  new (global_sve_sc_ptr) svint8_t (); // { dg-error {cannot allocate objects with SVE type 'svint8_t'} }\n+\n+  sve_sc1.~svint8_t(); // { dg-error {expected class-name before '\\(' token} }\n+  delete sve_sc_ptr; // { dg-error {cannot delete objects with SVE type '(svint8_t|__SVInt8_t)'} }\n+  delete[] sve_sc_ptr; // { dg-error {cannot delete objects with SVE type 'svint8_t'} }\n+\n+  // Conditional expressions.\n+\n+  0 ? sve_sc1 : sve_sc1;\n+  0 ? sve_sc1 : sve_sh1; // { dg-error {different types 'svint8_t' and 'svint16_t'} }\n+  0 ? sve_sc1 : 0; // { dg-error {different types 'svint8_t' and 'int'} }\n+  0 ? 0 : sve_sc1; // { dg-error {different types 'int' and 'svint8_t'} }\n+  0 ? sve_sc1 : sve_sc1;\n+  0 ? sve_sc_ptr : sve_sc_ptr;\n+  0 ? sve_sc_ptr : gnu_sc_ptr; // { dg-error {conditional expression between distinct pointer types [^\\n]*lacks a cast} }\n+  0 ? gnu_sc_ptr : sve_sc_ptr; // { dg-error {conditional expression between distinct pointer types [^\\n]*lacks a cast} }\n+\n+  // Function arguments.\n+\n+  ext_consume_sve_sc (sve_sc1);\n+  ext_consume_sve_sc (sve_sh1); // { dg-error {cannot convert 'svint16_t' to 'svint8_t'} }\n+  ext_consume_const_int_ref (sve_sc1); // { dg-error {invalid initialization of reference of type 'const int&' from expression of type 'svint8_t'} }\n+  ext_consume_varargs (sve_sc1); // { dg-error {cannot convert 'svint8_t' to 'int'} }\n+  ext_consume_varargs (1, sve_sc1);\n+\n+  // Function returns.\n+\n+  ext_produce_sve_sc ();\n+  sve_sc1 = ext_produce_sve_sc ();\n+  sve_sh1 = ext_produce_sve_sc (); // { dg-error {cannot convert 'svint8_t' to 'svint16_t' in assignment} }\n+\n+  // Auto\n+\n+#if __cplusplus >= 201103L\n+  auto auto_sve_sc1 = sve_sc1;\n+  auto auto_sve_sc1_return = ext_produce_sve_sc ();\n+#endif\n+\n+  // Varargs processing.\n+\n+  __builtin_va_list valist;\n+  __builtin_va_arg (valist, svint8_t);\n+\n+  // Other built-ins\n+\n+  __builtin_launder (sve_sc1); // { dg-error {non-pointer argument to '__builtin_launder'} }\n+  __builtin_memcpy (&sve_sc1, &sve_sc2, 2);\n+\n+  // Lambdas\n+\n+#if __cplusplus >= 201103L\n+  [sve_sc1] () {}; // { dg-error {capture by copy of SVE type 'svint8_t'} \"\" { target c++11 } }\n+  [=] () { &sve_sc1; }; // { dg-error {capture by copy of SVE type 'svint8_t'} \"\" { target c++11 } }\n+  [&sve_sc1] () { sve_sc1 = sve_sc2; }; // { dg-error {'sve_sc2' is not captured} \"\" { target c++11 } }\n+  [&sve_sc1, &sve_sc2] () { sve_sc1 = sve_sc2; };\n+  [&] () { sve_sc1 = sve_sc2; };\n+  [] () { return ext_produce_sve_sc (); } ();\n+#endif\n+\n+  // Exceptions\n+\n+  throw svint8_t (); // { dg-error {cannot throw or catch SVE type 'svint8_t'} }\n+  try {} catch (svint8_t x) {} // { dg-error {cannot throw or catch SVE type 'svint8_t'} }\n+  try {} catch (svint8_t &x) {} // { dg-error {cannot throw or catch SVE type 'svint8_t'} }\n+  try {} catch (svint8_t *x) {}\n+#if __cplusplus < 201103L\n+  thrower2 ();\n+#endif\n+\n+  // Use in traits.  Doesn't use static_assert so that tests work with\n+  // earlier -std=s.\n+\n+  { typedef int f[__has_nothrow_assign (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__has_trivial_assign (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__has_nothrow_constructor (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__has_trivial_constructor (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__has_nothrow_copy (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__has_trivial_copy (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__has_trivial_destructor (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__has_unique_object_representations (svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__has_virtual_destructor (svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_abstract (svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_aggregate (svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_base_of (svint8_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_base_of (svint8_t, svint16_t) ? 1 : -1]; }\n+  { typedef int f[!__is_class (svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_empty (svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_enum (svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_final (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__is_pod (svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_polymorphic (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__is_same_as (svint8_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_same_as (svint8_t, int8x32_t) ? 1 : -1]; }\n+  { typedef int f[!__is_same_as (int8x32_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[__is_same_as (svint8_t *, svint8_t *) ? 1 : -1]; }\n+  { typedef int f[!__is_same_as (svint8_t *, int8x32_t *) ? 1 : -1]; }\n+  { typedef int f[!__is_same_as (int8x32_t *, svint8_t *) ? 1 : -1]; }\n+  { typedef int f[!__is_same_as (svint8_t, int) ? 1 : -1]; }\n+  { typedef int f[!__is_same_as (svint8_t, svint16_t) ? 1 : -1]; }\n+  { typedef int f[__is_trivial (svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_union (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__is_trivially_copyable (svint8_t) ? 1 : -1]; }\n+  /* The intention is that svint8_t should behave like int8x32_t here.  If the behavior\n+     for int8x32_t changes then the behavior for svint8_t should change in the same\n+     way.  */\n+  { typedef int f[!__is_trivially_assignable (int8x32_t, int8x32_t) ? 1 : -1]; }\n+  { typedef int f[!__is_trivially_assignable (svint8_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_trivially_assignable (svint8_t, int8x32_t) ? 1 : -1]; }\n+  { typedef int f[!__is_trivially_assignable (int8x32_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_trivially_assignable (svint8_t, int) ? 1 : -1]; }\n+  { typedef int f[!__is_trivially_assignable (svint8_t, svint16_t) ? 1 : -1]; }\n+  { typedef int f[!__is_assignable (int8x32_t, int8x32_t) ? 1 : -1]; }\n+  { typedef int f[!__is_assignable (svint8_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_assignable (svint8_t, int8x32_t) ? 1 : -1]; }\n+  { typedef int f[!__is_assignable (int8x32_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_assignable (svint8_t, int) ? 1 : -1]; }\n+  { typedef int f[!__is_assignable (svint8_t, svint16_t) ? 1 : -1]; }\n+  { typedef int f[__is_trivially_constructible (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__is_trivially_constructible (int8x32_t, int8x32_t) ? 1 : -1]; }\n+  { typedef int f[__is_trivially_constructible (svint8_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_trivially_constructible (svint8_t, int8x32_t) ? 1 : -1]; }\n+  { typedef int f[!__is_trivially_constructible (int8x32_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_trivially_constructible (svint8_t, int) ? 1 : -1]; }\n+  { typedef int f[!__is_trivially_constructible (svint8_t, svint16_t) ? 1 : -1]; }\n+  { typedef int f[__is_constructible (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__is_constructible (int8x32_t, int8x32_t) ? 1 : -1]; }\n+  { typedef int f[__is_constructible (svint8_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_constructible (svint8_t, int8x32_t) ? 1 : -1]; }\n+  { typedef int f[!__is_constructible (int8x32_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_constructible (svint8_t, int) ? 1 : -1]; }\n+  { typedef int f[!__is_constructible (svint8_t, svint16_t) ? 1 : -1]; }\n+}\n+\n+// Function parameters in definitions.\n+\n+void\n+unnamed_st1 (svint8_t)\n+{\n+}\n+\n+void\n+named_st1 (svint8_t param1)\n+{\n+  svint8_t sve_sc1 = param1;\n+}\n+\n+// Function return values in definitions.\n+\n+svint8_t\n+ret_st1 (svint8_t param)\n+{\n+  return param;\n+}\n+\n+svint8_t\n+bad_ret_st1 (svint16_t param)\n+{\n+  return param; // { dg-error {cannot convert 'svint16_t' to 'svint8_t' in return} }\n+}\n+\n+#if __cplusplus >= 201103L\n+template<typename T>\n+void\n+const_to_sve_sc (T i)\n+{\n+  constexpr svint8_t a = (svint8_t) i;\n+}\n+#endif\n+\n+template<typename T>\n+int\n+get_x (T *a)\n+{\n+  return a->a; // { dg-error {request for member 'a' in '\\* a', which is of non-class type} }\n+}\n+template int get_x<svint8_t>(svint8_t *);\n+\n+#if __cplusplus < 201103L\n+void thrower3 () throw (svint8_t) {} // { dg-error {cannot throw or catch SVE type 'svint8_t'} \"\" { target c++98_only } }\n+#endif\n+\n+// Using \"auto\" as a return type.\n+\n+#if __cplusplus >= 201402L\n+auto auto_ret_sve_sc (svint8_t *ptr) { return *ptr; }\n+const auto &auto_ret_const_sve_sc_ref (svint8_t *ptr) { return *ptr; }\n+auto &auto_ret_sve_sc_ref (svint8_t *ptr) { return *ptr; }\n+auto &&auto_ret_sve_sc_rvalue_ref (svint8_t *ptr) { return *ptr; }\n+#endif"}, {"sha": "34e6afdfdd639ec9870b063dcb5ef2ebb58dc168", "filename": "gcc/testsuite/g++.dg/ext/sve-sizeless-2.C", "status": "added", "additions": 420, "deletions": 0, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fsve-sizeless-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02a32ab4a6175f377a4b6f53159c6aae9a24a7cc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fsve-sizeless-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fsve-sizeless-2.C?ref=02a32ab4a6175f377a4b6f53159c6aae9a24a7cc", "patch": "@@ -0,0 +1,420 @@\n+// { dg-do compile { target aarch64*-*-* } }\n+// { dg-options \"-Wclass-memaccess -msve-vector-bits=256\" }\n+\n+#pragma GCC target \"+sve\"\n+\n+typedef __SIZE_TYPE__ size_t;\n+inline void *operator new (size_t, void *__p) throw() { return __p; }\n+\n+#include <arm_sve.h>\n+\n+typedef signed char int8x32_t __attribute__((__vector_size__ (32)));\n+\n+// Sizeless objects with global scope.\n+\n+svint8_t global_sve_sc; // { dg-error {SVE type 'svint8_t' does not have a fixed size} }\n+static svint8_t local_sve_sc; // { dg-error {SVE type 'svint8_t' does not have a fixed size} }\n+extern svint8_t extern_sve_sc; // { dg-error {SVE type 'svint8_t' does not have a fixed size} }\n+__thread svint8_t tls_sve_sc; // { dg-error {variables of type 'svint8_t' cannot have thread-local storage duration} }\n+\n+// Sizeless arrays.\n+\n+typedef svint8_t array_type[2]; // { dg-error {array elements cannot have SVE type 'svint8_t'} }\n+extern svint8_t extern_array[]; // { dg-error {array elements cannot have SVE type 'svint8_t'} }\n+\n+// Sizeless member variables.\n+\n+struct struct1 {\n+  svint8_t a; // { dg-error {member variables cannot have SVE type 'svint8_t'} }\n+};\n+\n+union union1 {\n+  svint8_t a; // { dg-error {member variables cannot have SVE type 'svint8_t'} }\n+};\n+\n+#if __cplusplus >= 201103L\n+struct static_sve_sc {\n+  static svint8_t sve_sc1 = {}; // { dg-error {SVE type 'svint8_t' does not have a fixed size} \"\" { target c++11 } }\n+};\n+#endif\n+\n+// Sizeless member variables in templated structures.\n+\n+template<typename T>\n+struct templated_struct1 {\n+  svint8_t a; // { dg-error {member variables cannot have SVE type 'svint8_t'} }\n+};\n+\n+template<typename T>\n+struct templated_struct2 {\n+  T a; // { dg-error {member variables cannot have SVE type '(svint8_t|__SVInt8_t)'} }\n+};\n+\n+template class templated_struct2<svint8_t>;\n+\n+template<typename T>\n+struct templated_struct3 {\n+  T &a;\n+};\n+\n+template class templated_struct3<svint8_t>;\n+\n+#if __cplusplus >= 201103L\n+template<typename T>\n+struct templated_struct4 {\n+  static T a; // { dg-error {SVE type '(svint8_t|__SVInt8_t)' does not have a fixed size} \"\" { target c++11 } }\n+  static T b = {}; // { dg-error {SVE type '(svint8_t|__SVInt8_t)' does not have a fixed size} \"\" { target c++11 } }\n+};\n+\n+template class templated_struct4<svint8_t>;\n+#endif\n+\n+template<typename T> struct templated_struct5 : T {}; // { dg-error {base type '[^']*' fails to be a struct or class type} }\n+template class templated_struct5<svint8_t>;\n+\n+#if __cplusplus >= 201103L\n+template<int N> using typedef_sizeless1 = svint8_t;\n+template<int N> using typedef_sizeless1 = svint8_t; // { dg-error {redefinition of 'template<int N> using typedef_sizeless1 = svint8_t'} \"\" { target c++11 } }\n+template<typename T> using array = T[2];\n+#endif\n+\n+// Pointers to sizeless types.\n+\n+svint8_t *global_sve_sc_ptr;\n+\n+// Sizeless arguments and return values.\n+\n+void ext_consume_sve_sc (svint8_t);\n+void ext_consume_const_int_ref (const int &);\n+void ext_consume_varargs (int, ...);\n+svint8_t ext_produce_sve_sc ();\n+\n+// Sizeless types in throw specifications.\n+\n+#if __cplusplus < 201103L\n+void thrower1 () throw (svint8_t); // { dg-error {cannot throw or catch SVE type 'svint8_t'} \"\" { target c++98_only } }\n+void thrower2 () throw (svint8_t); // { dg-error {cannot throw or catch SVE type 'svint8_t'} \"\" { target c++98_only } }\n+void thrower3 () throw (svint8_t); // { dg-error {cannot throw or catch SVE type 'svint8_t'} \"\" { target c++98_only } }\n+#endif\n+\n+// Main tests for statements and expressions.\n+\n+void\n+statements (int n)\n+{\n+  // Local declarations.\n+\n+  svint8_t sve_sc1, sve_sc2;\n+  volatile svint8_t volatile_sve_sc1;\n+  int8x32_t gnu_sc1;\n+  svint16_t sve_sh1;\n+\n+  // Layout queries.\n+\n+  sizeof (svint8_t); // { dg-error {SVE type 'svint8_t' does not have a fixed size} }\n+  sizeof (sve_sc1); // { dg-error {SVE type 'svint8_t' does not have a fixed size} }\n+  sizeof (ext_produce_sve_sc ()); // { dg-error {SVE type 'svint8_t' does not have a fixed size} }\n+  __alignof (svint8_t); // { dg-error {SVE type 'svint8_t' does not have a defined alignment} }\n+  __alignof (sve_sc1); // { dg-error {SVE type 'svint8_t' does not have a defined alignment} }\n+  __alignof (ext_produce_sve_sc ()); // { dg-error {SVE type 'svint8_t' does not have a defined alignment} }\n+\n+#if __cplusplus >= 201103L\n+  array<svint8_t> foo = {}; // { dg-error {array elements cannot have SVE type '(svint8_t|__SVInt8_t)'} \"\" { target c++11 } }\n+#endif\n+\n+  // Initialization.\n+\n+  int init_int1 = sve_sc1; // { dg-error {cannot convert 'svint8_t' to 'int' in initialization} }\n+  int init_int2 = { sve_sc1 }; // { dg-error {cannot convert 'svint8_t' to 'int' in initialization} }\n+\n+  svint8_t init_sve_sc1 (sve_sc1);\n+  svint8_t init_sve_sc2 (sve_sh1); // { dg-error {cannot convert 'svint16_t' to 'svint8_t'} }\n+  svint8_t init_sve_sc3 = sve_sc1;\n+  svint8_t init_sve_sc4 = sve_sh1; // { dg-error {cannot convert 'svint16_t' to 'svint8_t'} }\n+  svint8_t init_sve_sc5 = {};\n+  svint8_t init_sve_sc6 = { sve_sc1 };\n+  svint8_t init_sve_sc7 = { sve_sh1 }; // { dg-error {cannot convert 'svint16_t' to 'svint8_t'} }\n+\n+  // Constructor calls.\n+\n+  (0, svint8_t ());\n+\n+  // Lvalue reference binding\n+\n+  svint8_t &lvalue_ref_sve_sc1 = sve_sc1;\n+  svint8_t &lvalue_ref_sve_sc2 = ext_produce_sve_sc (); // { dg-error {cannot bind non-const lvalue reference of type 'svint8_t&' to an rvalue of type 'svint8_t'} }\n+  svint8_t &lvalue_ref_sve_sc3 = sve_sh1; // { dg-error {invalid initialization of reference of type 'svint8_t&' from expression of type 'svint16_t'} }\n+\n+  const svint8_t &const_lvalue_ref_sve_sc1 = sve_sc1;\n+  const svint8_t &const_lvalue_ref_sve_sc2 = ext_produce_sve_sc ();\n+  const svint8_t &const_lvalue_ref_sve_sc3 = sve_sh1; // { dg-error {invalid initialization of reference of type 'const svint8_t&' from expression of type 'svint16_t'} }\n+\n+  // Compound literals.\n+\n+  (int) { sve_sc1 }; // { dg-error {cannot convert 'svint8_t' to 'int' in initialization} }\n+\n+  // Arrays.\n+\n+  svint8_t array[2]; // { dg-error {array elements cannot have SVE type 'svint8_t'} }\n+  svint8_t zero_length_array[0]; // { dg-error {array elements cannot have SVE type 'svint8_t'} }\n+  svint8_t empty_init_array[] = {}; // { dg-error {array elements cannot have SVE type 'svint8_t'} }\n+\n+  // Assignment.\n+\n+  n = sve_sc1; // { dg-error {cannot convert 'svint8_t' to 'int' in assignment} }\n+\n+  sve_sc1 = 0; // { dg-error {cannot convert 'int' to 'svint8_t' in assignment} }\n+  sve_sc1 = sve_sc1;\n+  sve_sc1 = gnu_sc1;\n+  gnu_sc1 = sve_sc1;\n+  sve_sc1 = sve_sh1; // { dg-error {cannot convert 'svint16_t' to 'svint8_t'} }\n+\n+  // Casting.\n+\n+  (void) sve_sc1;\n+  (void) volatile_sve_sc1;\n+  (void) *&volatile_sve_sc1;\n+\n+  // Addressing and dereferencing.\n+\n+  svint8_t *sve_sc_ptr = &sve_sc1;\n+  int8x32_t *gnu_sc_ptr = &gnu_sc1;\n+  sve_sc_ptr = (svint16_t *) 0; // { dg-error {cannot convert 'svint16_t\\*' to 'svint8_t\\*' in assignment} }\n+\n+  // Pointer assignment.\n+\n+  gnu_sc_ptr = sve_sc_ptr;\n+  sve_sc_ptr = gnu_sc_ptr;\n+\n+  // Pointer arithmetic.\n+\n+  ++sve_sc_ptr; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  --sve_sc_ptr; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  sve_sc_ptr++; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  sve_sc_ptr--; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  sve_sc_ptr += 0; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  sve_sc_ptr += 1; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  sve_sc_ptr -= 0; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  sve_sc_ptr -= 1; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  sve_sc_ptr - sve_sc_ptr; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  gnu_sc_ptr - sve_sc_ptr; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  sve_sc_ptr - gnu_sc_ptr; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  sve_sc1 = sve_sc_ptr[0]; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+  sve_sc1 = sve_sc_ptr[1]; // { dg-error {arithmetic on pointer to SVE type 'svint8_t'} }\n+\n+  // Pointer comparison.\n+\n+  sve_sc_ptr == &sve_sc1;\n+  sve_sc_ptr != &sve_sc1;\n+  sve_sc_ptr < &sve_sc1;\n+  sve_sc_ptr <= &sve_sc1;\n+  sve_sc_ptr > &sve_sc1;\n+  sve_sc_ptr >= &sve_sc1;\n+  gnu_sc_ptr == sve_sc_ptr;\n+  gnu_sc_ptr != sve_sc_ptr;\n+  gnu_sc_ptr < sve_sc_ptr;\n+  gnu_sc_ptr <= sve_sc_ptr;\n+  gnu_sc_ptr > sve_sc_ptr;\n+  gnu_sc_ptr >= sve_sc_ptr;\n+  sve_sc_ptr == gnu_sc_ptr;\n+  sve_sc_ptr != gnu_sc_ptr;\n+  sve_sc_ptr < gnu_sc_ptr;\n+  sve_sc_ptr <= gnu_sc_ptr;\n+  sve_sc_ptr > gnu_sc_ptr;\n+  sve_sc_ptr >= gnu_sc_ptr;\n+\n+  // New and delete.\n+\n+  new svint8_t; // { dg-error {cannot allocate objects with SVE type 'svint8_t'} }\n+  new svint8_t (); // { dg-error {cannot allocate objects with SVE type 'svint8_t'} }\n+\n+  new (global_sve_sc_ptr) svint8_t; // { dg-error {cannot allocate objects with SVE type 'svint8_t'} }\n+  new (global_sve_sc_ptr) svint8_t (); // { dg-error {cannot allocate objects with SVE type 'svint8_t'} }\n+\n+  sve_sc1.~svint8_t(); // { dg-error {expected class-name before '\\(' token} }\n+  delete sve_sc_ptr; // { dg-error {cannot delete objects with SVE type '(svint8_t|__SVInt8_t)'} }\n+  delete[] sve_sc_ptr; // { dg-error {cannot delete objects with SVE type 'svint8_t'} }\n+\n+  // Conditional expressions.\n+\n+  0 ? sve_sc1 : sve_sc1;\n+  0 ? sve_sc1 : sve_sh1; // { dg-error {different types 'svint8_t' and 'svint16_t'} }\n+  0 ? sve_sc1 : 0; // { dg-error {different types 'svint8_t' and 'int'} }\n+  0 ? 0 : sve_sc1; // { dg-error {different types 'int' and 'svint8_t'} }\n+  0 ? sve_sc1 : sve_sc1;\n+  0 ? sve_sc_ptr : sve_sc_ptr;\n+  0 ? sve_sc_ptr : gnu_sc_ptr;\n+  0 ? gnu_sc_ptr : sve_sc_ptr;\n+\n+  // Function arguments.\n+\n+  ext_consume_sve_sc (sve_sc1);\n+  ext_consume_sve_sc (sve_sh1); // { dg-error {cannot convert 'svint16_t' to 'svint8_t'} }\n+  ext_consume_const_int_ref (sve_sc1); // { dg-error {invalid initialization of reference of type 'const int&' from expression of type 'svint8_t'} }\n+  ext_consume_varargs (sve_sc1); // { dg-error {cannot convert 'svint8_t' to 'int'} }\n+  ext_consume_varargs (1, sve_sc1);\n+\n+  // Function returns.\n+\n+  ext_produce_sve_sc ();\n+  sve_sc1 = ext_produce_sve_sc ();\n+  sve_sh1 = ext_produce_sve_sc (); // { dg-error {cannot convert 'svint8_t' to 'svint16_t' in assignment} }\n+\n+  // Auto\n+\n+#if __cplusplus >= 201103L\n+  auto auto_sve_sc1 = sve_sc1;\n+  auto auto_sve_sc1_return = ext_produce_sve_sc ();\n+#endif\n+\n+  // Varargs processing.\n+\n+  __builtin_va_list valist;\n+  __builtin_va_arg (valist, svint8_t);\n+\n+  // Other built-ins\n+\n+  __builtin_launder (sve_sc1); // { dg-error {non-pointer argument to '__builtin_launder'} }\n+  __builtin_memcpy (&sve_sc1, &sve_sc2, 2);\n+\n+  // Lambdas\n+\n+#if __cplusplus >= 201103L\n+  [sve_sc1] () {}; // { dg-error {capture by copy of SVE type 'svint8_t'} \"\" { target c++11 } }\n+  [=] () { &sve_sc1; }; // { dg-error {capture by copy of SVE type 'svint8_t'} \"\" { target c++11 } }\n+  [&sve_sc1] () { sve_sc1 = sve_sc2; }; // { dg-error {'sve_sc2' is not captured} \"\" { target c++11 } }\n+  [&sve_sc1, &sve_sc2] () { sve_sc1 = sve_sc2; };\n+  [&] () { sve_sc1 = sve_sc2; };\n+  [] () { return ext_produce_sve_sc (); } ();\n+#endif\n+\n+  // Exceptions\n+\n+  throw svint8_t (); // { dg-error {cannot throw or catch SVE type 'svint8_t'} }\n+  try {} catch (svint8_t x) {} // { dg-error {cannot throw or catch SVE type 'svint8_t'} }\n+  try {} catch (svint8_t &x) {} // { dg-error {cannot throw or catch SVE type 'svint8_t'} }\n+  try {} catch (svint8_t *x) {}\n+#if __cplusplus < 201103L\n+  thrower2 ();\n+#endif\n+\n+  // Use in traits.  Doesn't use static_assert so that tests work with\n+  // earlier -std=s.\n+\n+  { typedef int f[__has_nothrow_assign (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__has_trivial_assign (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__has_nothrow_constructor (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__has_trivial_constructor (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__has_nothrow_copy (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__has_trivial_copy (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__has_trivial_destructor (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__has_unique_object_representations (svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__has_virtual_destructor (svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_abstract (svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_aggregate (svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_base_of (svint8_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_base_of (svint8_t, svint16_t) ? 1 : -1]; }\n+  { typedef int f[!__is_class (svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_empty (svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_enum (svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_final (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__is_pod (svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_polymorphic (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__is_same_as (svint8_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[__is_same_as (svint8_t, int8x32_t) ? 1 : -1]; }\n+  { typedef int f[__is_same_as (int8x32_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[__is_same_as (svint8_t *, svint8_t *) ? 1 : -1]; }\n+  { typedef int f[__is_same_as (svint8_t *, int8x32_t *) ? 1 : -1]; }\n+  { typedef int f[__is_same_as (int8x32_t *, svint8_t *) ? 1 : -1]; }\n+  { typedef int f[!__is_same_as (svint8_t, int) ? 1 : -1]; }\n+  { typedef int f[!__is_same_as (svint8_t, svint16_t) ? 1 : -1]; }\n+  { typedef int f[__is_trivial (svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_union (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__is_trivially_copyable (svint8_t) ? 1 : -1]; }\n+  /* The intention is that svint8_t should behave like int8x32_t here.  If the behavior\n+     for int8x32_t changes then the behavior for svint8_t should change in the same\n+     way.  */\n+  { typedef int f[!__is_trivially_assignable (int8x32_t, int8x32_t) ? 1 : -1]; }\n+  { typedef int f[!__is_trivially_assignable (svint8_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_trivially_assignable (svint8_t, int8x32_t) ? 1 : -1]; }\n+  { typedef int f[!__is_trivially_assignable (int8x32_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_trivially_assignable (svint8_t, int) ? 1 : -1]; }\n+  { typedef int f[!__is_trivially_assignable (svint8_t, svint16_t) ? 1 : -1]; }\n+  { typedef int f[!__is_assignable (int8x32_t, int8x32_t) ? 1 : -1]; }\n+  { typedef int f[!__is_assignable (svint8_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_assignable (svint8_t, int8x32_t) ? 1 : -1]; }\n+  { typedef int f[!__is_assignable (int8x32_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_assignable (svint8_t, int) ? 1 : -1]; }\n+  { typedef int f[!__is_assignable (svint8_t, svint16_t) ? 1 : -1]; }\n+  { typedef int f[__is_trivially_constructible (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__is_trivially_constructible (int8x32_t, int8x32_t) ? 1 : -1]; }\n+  { typedef int f[__is_trivially_constructible (svint8_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[__is_trivially_constructible (svint8_t, int8x32_t) ? 1 : -1]; }\n+  { typedef int f[__is_trivially_constructible (int8x32_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_trivially_constructible (svint8_t, int) ? 1 : -1]; }\n+  { typedef int f[!__is_trivially_constructible (svint8_t, svint16_t) ? 1 : -1]; }\n+  { typedef int f[__is_constructible (svint8_t) ? 1 : -1]; }\n+  { typedef int f[__is_constructible (int8x32_t, int8x32_t) ? 1 : -1]; }\n+  { typedef int f[__is_constructible (svint8_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[__is_constructible (svint8_t, int8x32_t) ? 1 : -1]; }\n+  { typedef int f[__is_constructible (int8x32_t, svint8_t) ? 1 : -1]; }\n+  { typedef int f[!__is_constructible (svint8_t, int) ? 1 : -1]; }\n+  { typedef int f[!__is_constructible (svint8_t, svint16_t) ? 1 : -1]; }\n+}\n+\n+// Function parameters in definitions.\n+\n+void\n+unnamed_st1 (svint8_t)\n+{\n+}\n+\n+void\n+named_st1 (svint8_t param1)\n+{\n+  svint8_t sve_sc1 = param1;\n+}\n+\n+// Function return values in definitions.\n+\n+svint8_t\n+ret_st1 (svint8_t param)\n+{\n+  return param;\n+}\n+\n+svint8_t\n+bad_ret_st1 (svint16_t param)\n+{\n+  return param; // { dg-error {cannot convert 'svint16_t' to 'svint8_t' in return} }\n+}\n+\n+#if __cplusplus >= 201103L\n+template<typename T>\n+void\n+const_to_sve_sc (T i)\n+{\n+  constexpr svint8_t a = (svint8_t) i;\n+}\n+#endif\n+\n+template<typename T>\n+int\n+get_x (T *a)\n+{\n+  return a->a; // { dg-error {request for member 'a' in '\\* a', which is of non-class type} }\n+}\n+template int get_x<svint8_t>(svint8_t *);\n+\n+#if __cplusplus < 201103L\n+void thrower3 () throw (svint8_t) {} // { dg-error {cannot throw or catch SVE type 'svint8_t'} \"\" { target c++98_only } }\n+#endif\n+\n+// Using \"auto\" as a return type.\n+\n+#if __cplusplus >= 201402L\n+auto auto_ret_sve_sc (svint8_t *ptr) { return *ptr; }\n+const auto &auto_ret_const_sve_sc_ref (svint8_t *ptr) { return *ptr; }\n+auto &auto_ret_sve_sc_ref (svint8_t *ptr) { return *ptr; }\n+auto &&auto_ret_sve_sc_rvalue_ref (svint8_t *ptr) { return *ptr; }\n+#endif"}]}