{"sha": "ce7b376154d74610821b94aed418677baf998dba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U3YjM3NjE1NGQ3NDYxMDgyMWI5NGFlZDQxODY3N2JhZjk5OGRiYQ==", "commit": {"author": {"name": "Revital Eres", "email": "revital.eres@linaro.org", "date": "2011-05-11T07:08:44Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2011-05-11T07:08:44Z"}, "message": "Doloop pattern for ARM\n\nFrom-SVN: r173645", "tree": {"sha": "2ce89b08c7f88397801fe13872af4ffdb5a6a5a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ce89b08c7f88397801fe13872af4ffdb5a6a5a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce7b376154d74610821b94aed418677baf998dba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce7b376154d74610821b94aed418677baf998dba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce7b376154d74610821b94aed418677baf998dba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce7b376154d74610821b94aed418677baf998dba/comments", "author": null, "committer": null, "parents": [{"sha": "ed1db3f15abf1e8831f8a88c1d4db8fb19256f1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed1db3f15abf1e8831f8a88c1d4db8fb19256f1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed1db3f15abf1e8831f8a88c1d4db8fb19256f1f"}], "stats": {"total": 149, "additions": 136, "deletions": 13}, "files": [{"sha": "b2103c2c9a8b88826bf8bad0e915d68e4fb18a4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce7b376154d74610821b94aed418677baf998dba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce7b376154d74610821b94aed418677baf998dba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce7b376154d74610821b94aed418677baf998dba", "patch": "@@ -1,3 +1,11 @@\n+2011-05-11  Revital Eres  <revital.eres@linaro.org>\n+\n+\t* modulo-sched.c (sms_schedule): Support new form of doloop pattern\n+\t* loop-doloop.c (doloop_condition_get): Likewise.\n+\t* config/arm/thumb2.md (*thumb2_addsi3_compare0): Remove \"*\".\n+\t(doloop_end): New.\n+\t* config/arm/arm.md (*addsi3_compare0): Remove \"*\".\n+\n 2011-05-10  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* tree.def (CASE_LABEL_EXPR): Add an operand."}, {"sha": "fad82f01f52ee95f28bdbef147cac67805b07698", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce7b376154d74610821b94aed418677baf998dba/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce7b376154d74610821b94aed418677baf998dba/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=ce7b376154d74610821b94aed418677baf998dba", "patch": "@@ -797,7 +797,7 @@\n   \"\"\n )\n \n-(define_insn \"*addsi3_compare0\"\n+(define_insn \"addsi3_compare0\"\n   [(set (reg:CC_NOOV CC_REGNUM)\n \t(compare:CC_NOOV\n \t (plus:SI (match_operand:SI 1 \"s_register_operand\" \"r, r\")"}, {"sha": "897d80513b26ffb2b861baba7a370b9b3bfc2764", "filename": "gcc/config/arm/thumb2.md", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce7b376154d74610821b94aed418677baf998dba/gcc%2Fconfig%2Farm%2Fthumb2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce7b376154d74610821b94aed418677baf998dba/gcc%2Fconfig%2Farm%2Fthumb2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb2.md?ref=ce7b376154d74610821b94aed418677baf998dba", "patch": "@@ -836,7 +836,7 @@\n   \"operands[4] = GEN_INT (- INTVAL (operands[2]));\"\n )\n \n-(define_insn \"*thumb2_addsi3_compare0\"\n+(define_insn \"thumb2_addsi3_compare0\"\n   [(set (reg:CC_NOOV CC_REGNUM)\n \t(compare:CC_NOOV\n \t  (plus:SI (match_operand:SI 1 \"s_register_operand\" \"l,  0, r\")\n@@ -1118,3 +1118,55 @@\n   \"\n   operands[2] = GEN_INT (32 - INTVAL (operands[2]));\n   \")\n+\n+;; Define the subtract-one-and-jump insns so loop.c\n+;; knows what to generate.\n+(define_expand \"doloop_end\"\n+  [(use (match_operand 0 \"\" \"\"))      ; loop pseudo\n+   (use (match_operand 1 \"\" \"\"))      ; iterations; zero if unknown\n+   (use (match_operand 2 \"\" \"\"))      ; max iterations\n+   (use (match_operand 3 \"\" \"\"))      ; loop level\n+   (use (match_operand 4 \"\" \"\"))]     ; label\n+  \"TARGET_32BIT\"\n+  \"\n+ {\n+   /* Currently SMS relies on the do-loop pattern to recognize loops\n+      where (1) the control part consists of all insns defining and/or\n+      using a certain 'count' register and (2) the loop count can be\n+      adjusted by modifying this register prior to the loop.\n+      ??? The possible introduction of a new block to initialize the\n+      new IV can potentially affect branch optimizations.  */\n+   if (optimize > 0 && flag_modulo_sched)\n+   {\n+     rtx s0;\n+     rtx bcomp;\n+     rtx loc_ref;\n+     rtx cc_reg;\n+     rtx insn;\n+     rtx cmp;\n+\n+     /* Only use this on innermost loops.  */\n+     if (INTVAL (operands[3]) > 1)\n+       FAIL;\n+\n+     if (GET_MODE (operands[0]) != SImode)\n+       FAIL;\n+\n+     s0 = operands [0];\n+     if (TARGET_THUMB2)\n+       insn = emit_insn (gen_thumb2_addsi3_compare0 (s0, s0, GEN_INT (-1)));\n+     else\n+       insn = emit_insn (gen_addsi3_compare0 (s0, s0, GEN_INT (-1)));\n+\n+     cmp = XVECEXP (PATTERN (insn), 0, 0);\n+     cc_reg = SET_DEST (cmp);\n+     bcomp = gen_rtx_NE (VOIDmode, cc_reg, const0_rtx);\n+     loc_ref = gen_rtx_LABEL_REF (VOIDmode, operands [4]);\n+     emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n+                                  gen_rtx_IF_THEN_ELSE (VOIDmode, bcomp,\n+                                                        loc_ref, pc_rtx)));\n+     DONE;\n+   }else\n+      FAIL;\n+ }\")\n+"}, {"sha": "1527c48500c9cdceca96096524ddc20b72304cd2", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 67, "deletions": 7, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce7b376154d74610821b94aed418677baf998dba/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce7b376154d74610821b94aed418677baf998dba/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=ce7b376154d74610821b94aed418677baf998dba", "patch": "@@ -78,6 +78,8 @@ doloop_condition_get (rtx doloop_pat)\n   rtx inc_src;\n   rtx condition;\n   rtx pattern;\n+  rtx cc_reg = NULL_RTX;\n+  rtx reg_orig = NULL_RTX;\n \n   /* The canonical doloop pattern we expect has one of the following\n      forms:\n@@ -96,27 +98,64 @@ doloop_condition_get (rtx doloop_pat)\n      2)  (set (reg) (plus (reg) (const_int -1))\n          (set (pc) (if_then_else (reg != 0)\n \t                         (label_ref (label))\n-\t\t\t         (pc))).  */\n+\t\t\t         (pc))).  \n+\n+     Some targets (ARM) do the comparison before the branch, as in the\n+     following form:\n+\n+     3) (parallel [(set (cc) (compare ((plus (reg) (const_int -1), 0)))\n+                   (set (reg) (plus (reg) (const_int -1)))])\n+        (set (pc) (if_then_else (cc == NE)\n+                                (label_ref (label))\n+                                (pc))) */\n \n   pattern = PATTERN (doloop_pat);\n \n   if (GET_CODE (pattern) != PARALLEL)\n     {\n       rtx cond;\n       rtx prev_insn = prev_nondebug_insn (doloop_pat);\n+      rtx cmp_arg1, cmp_arg2;\n+      rtx cmp_orig;\n \n-      /* We expect the decrement to immediately precede the branch.  */\n+      /* In case the pattern is not PARALLEL we expect two forms\n+\t of doloop which are cases 2) and 3) above: in case 2) the\n+\t decrement immediately precedes the branch, while in case 3)\n+\t the compare and decrement instructions immediately precede\n+\t the branch.  */\n \n       if (prev_insn == NULL_RTX || !INSN_P (prev_insn))\n         return 0;\n \n       cmp = pattern;\n-      inc = PATTERN (PREV_INSN (doloop_pat));\n+      if (GET_CODE (PATTERN (prev_insn)) == PARALLEL)\n+        {\n+\t  /* The third case: the compare and decrement instructions\n+\t     immediately precede the branch.  */\n+\t  cmp_orig = XVECEXP (PATTERN (prev_insn), 0, 0);\n+\t  if (GET_CODE (cmp_orig) != SET)\n+\t    return 0;\n+\t  if (GET_CODE (SET_SRC (cmp_orig)) != COMPARE)\n+\t    return 0;\n+\t  cmp_arg1 = XEXP (SET_SRC (cmp_orig), 0);\n+          cmp_arg2 = XEXP (SET_SRC (cmp_orig), 1);\n+\t  if (cmp_arg2 != const0_rtx \n+\t      || GET_CODE (cmp_arg1) != PLUS)\n+\t    return 0;\n+\t  reg_orig = XEXP (cmp_arg1, 0);\n+\t  if (XEXP (cmp_arg1, 1) != GEN_INT (-1) \n+\t      || !REG_P (reg_orig))\n+\t    return 0;\n+\t  cc_reg = SET_DEST (cmp_orig);\n+\t  \n+\t  inc = XVECEXP (PATTERN (prev_insn), 0, 1);\n+\t}\n+      else\n+        inc = PATTERN (PREV_INSN (doloop_pat));\n       /* We expect the condition to be of the form (reg != 0)  */\n       cond = XEXP (SET_SRC (cmp), 0);\n       if (GET_CODE (cond) != NE || XEXP (cond, 1) != const0_rtx)\n         return 0;\n-\n     }\n   else\n     {\n@@ -162,11 +201,15 @@ doloop_condition_get (rtx doloop_pat)\n     return 0;\n \n   if ((XEXP (condition, 0) == reg)\n+      /* For the third case:  */  \n+      || ((cc_reg != NULL_RTX)\n+\t  && (XEXP (condition, 0) == cc_reg)\n+\t  && (reg_orig == reg))\n       || (GET_CODE (XEXP (condition, 0)) == PLUS\n-\t\t   && XEXP (XEXP (condition, 0), 0) == reg))\n+\t  && XEXP (XEXP (condition, 0), 0) == reg))\n    {\n      if (GET_CODE (pattern) != PARALLEL)\n-     /*  The second form we expect:\n+     /*  For the second form we expect:\n \n          (set (reg) (plus (reg) (const_int -1))\n          (set (pc) (if_then_else (reg != 0)\n@@ -181,7 +224,24 @@ doloop_condition_get (rtx doloop_pat)\n                      (set (reg) (plus (reg) (const_int -1)))\n                      (additional clobbers and uses)])\n \n-         So we return that form instead.\n+        For the third form we expect:\n+\n+        (parallel [(set (cc) (compare ((plus (reg) (const_int -1)), 0))\n+                   (set (reg) (plus (reg) (const_int -1)))])\n+        (set (pc) (if_then_else (cc == NE)\n+                                (label_ref (label))\n+                                (pc))) \n+\n+        which is equivalent to the following:\n+\n+        (parallel [(set (cc) (compare (reg,  1))\n+                   (set (reg) (plus (reg) (const_int -1)))\n+                   (set (pc) (if_then_else (NE == cc)\n+                                           (label_ref (label))\n+                                           (pc))))])\n+\n+        So we return the second form instead for the two cases.\n+\n      */\n         condition = gen_rtx_fmt_ee (NE, VOIDmode, inc_src, const1_rtx);\n "}, {"sha": "091c0059e5cf728de3c28853d5d0d261ceb26b1d", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce7b376154d74610821b94aed418677baf998dba/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce7b376154d74610821b94aed418677baf998dba/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=ce7b376154d74610821b94aed418677baf998dba", "patch": "@@ -1009,9 +1009,11 @@ sms_schedule (void)\n \tcontinue;\n       }\n \n-      /* Don't handle BBs with calls or barriers, or !single_set insns,\n-         or auto-increment insns (to avoid creating invalid reg-moves\n-         for the auto-increment insns).\n+      /* Don't handle BBs with calls or barriers or auto-increment insns \n+\t (to avoid creating invalid reg-moves for the auto-increment insns),\n+\t or !single_set with the exception of instructions that include\n+\t count_reg---these instructions are part of the control part\n+\t that do-loop recognizes.\n          ??? Should handle auto-increment insns.\n          ??? Should handle insns defining subregs.  */\n      for (insn = head; insn != NEXT_INSN (tail); insn = NEXT_INSN (insn))\n@@ -1021,7 +1023,8 @@ sms_schedule (void)\n         if (CALL_P (insn)\n             || BARRIER_P (insn)\n             || (NONDEBUG_INSN_P (insn) && !JUMP_P (insn)\n-                && !single_set (insn) && GET_CODE (PATTERN (insn)) != USE)\n+                && !single_set (insn) && GET_CODE (PATTERN (insn)) != USE\n+                && !reg_mentioned_p (count_reg, insn))\n             || (FIND_REG_INC_NOTE (insn, NULL_RTX) != 0)\n             || (INSN_P (insn) && (set = single_set (insn))\n                 && GET_CODE (SET_DEST (set)) == SUBREG))"}]}