{"sha": "29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlhMmY1MTgwNmM1YjMwZTE3YThkMGU5YmE3OTE1YTNjNTNjMzRmZg==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2021-02-26T12:34:49Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-05-21T16:58:07Z"}, "message": "openacc: Add support for gang local storage allocation in shared memory [PR90115]\n\nThis patch implements a method to track the \"private-ness\" of\nOpenACC variables declared in offload regions in gang-partitioned,\nworker-partitioned or vector-partitioned modes. Variables declared\nimplicitly in scoped blocks and those declared \"private\" on enclosing\ndirectives (e.g. \"acc parallel\") are both handled. Variables that are\ne.g. gang-private can then be adjusted so they reside in GPU shared\nmemory.\n\nThe reason for doing this is twofold: correct implementation of OpenACC\nsemantics, and optimisation, since shared memory might be faster than\nthe main memory on a GPU. Handling of private variables is intimately\ntied to the execution model for gangs/workers/vectors implemented by\na particular target: for current targets, we use (or on mainline, will\nsoon use) a broadcasting/neutering scheme.\n\nThat is sufficient for code that e.g. sets a variable in worker-single\nmode and expects to use the value in worker-partitioned mode. The\ndifficulty (semantics-wise) comes when the user wants to do something like\nan atomic operation in worker-partitioned mode and expects a worker-single\n(gang private) variable to be shared across each partitioned worker.\nForcing use of shared memory for such variables makes that work properly.\n\nIn terms of implementation, the parallelism level of a given loop is\nnot fixed until the oaccdevlow pass in the offload compiler, so the\npatch delays fixing the parallelism level of variables declared on or\nwithin such loops until the same point. This is done by adding a new\ninternal UNIQUE function (OACC_PRIVATE) that lists (the address of) each\nprivate variable as an argument, and other arguments set so as to be able\nto determine the correct parallelism level to use for the listed\nvariables. This new internal function fits into the existing scheme for\ndemarcating OpenACC loops, as described in comments in the patch.\n\nTwo new target hooks are introduced: TARGET_GOACC_ADJUST_PRIVATE_DECL and\nTARGET_GOACC_EXPAND_VAR_DECL.  The first can tweak a variable declaration\nat oaccdevlow time, and the second at expand time.  The first or both\nof these target hooks can be used by a given offload target, depending\non its strategy for implementing private variables.\n\nThis patch updates the TARGET_GOACC_ADJUST_PRIVATE_DECL target hook in\nthe AMD GCN backend to the current name and prototype. (An earlier\nversion of the hook was already present, but dormant.)\n\n\tgcc/\n\tPR middle-end/90115\n\t* doc/tm.texi.in (TARGET_GOACC_EXPAND_VAR_DECL)\n\t(TARGET_GOACC_ADJUST_PRIVATE_DECL): Add documentation hooks.\n\t* doc/tm.texi: Regenerate.\n\t* expr.c (expand_expr_real_1): Expand decls using the\n\texpand_var_decl OpenACC hook if defined.\n\t* internal-fn.c (expand_UNIQUE): Handle IFN_UNIQUE_OACC_PRIVATE.\n\t* internal-fn.h (IFN_UNIQUE_CODES): Add OACC_PRIVATE.\n\t* omp-low.c (omp_context): Add oacc_privatization_candidates\n\tfield.\n\t(lower_oacc_reductions): Add PRIVATE_MARKER parameter.  Insert\n\tbefore fork.\n\t(lower_oacc_head_tail): Add PRIVATE_MARKER parameter.  Modify\n\tprivate marker's gimple call arguments, and pass it to\n\tlower_oacc_reductions.\n\t(oacc_privatization_scan_clause_chain)\n\t(oacc_privatization_scan_decl_chain, lower_oacc_private_marker):\n\tNew functions.\n\t(lower_omp_for, lower_omp_target, lower_omp_1): Use these.\n\t* omp-offload.c (convert.h): Include.\n\t(oacc_loop_xform_head_tail): Treat private-variable markers like\n\tfork/join when transforming head/tail sequences.\n\t(struct var_decl_rewrite_info): Add struct.\n\t(oacc_rewrite_var_decl, is_sync_builtin_call): New functions.\n\t(execute_oacc_device_lower): Support rewriting gang-private\n\tvariables using target hook, and fix up addr_expr and var_decl\n\tnodes afterwards.\n\t* target.def (adjust_private_decl, expand_var_decl): New hooks.\n\t* config/gcn/gcn-protos.h (gcn_goacc_adjust_gangprivate_decl):\n\tRename to...\n\t(gcn_goacc_adjust_private_decl): ...this.\n\t* config/gcn/gcn-tree.c (gcn_goacc_adjust_gangprivate_decl):\n\tRename to...\n\t(gcn_goacc_adjust_private_decl): ...this. Add LEVEL parameter.\n\t* config/gcn/gcn.c (TARGET_GOACC_ADJUST_GANGPRIVATE_DECL): Rename\n\tdefinition using gcn_goacc_adjust_gangprivate_decl...\n\t(TARGET_GOACC_ADJUST_PRIVATE_DECL): ...to this, using\n\tgcn_goacc_adjust_private_decl.\n\t* config/nvptx/nvptx.c (tree-pretty-print.h): Include.\n\t(gang_private_shared_size): New global variable.\n\t(gang_private_shared_align): Likewise.\n\t(gang_private_shared_sym): Likewise.\n\t(gang_private_shared_hmap): Likewise.\n\t(nvptx_option_override): Initialize these.\n\t(nvptx_file_end): Output gang_private_shared_sym.\n\t(nvptx_goacc_adjust_private_decl, nvptx_goacc_expand_var_decl):\n\tNew functions.\n\t(nvptx_set_current_function): Clear gang_private_shared_hmap.\n\t(TARGET_GOACC_ADJUST_PRIVATE_DECL): Define hook.\n\t(TARGET_GOACC_EXPAND_VAR_DECL): Likewise.\n\tlibgomp/\n\tPR middle-end/90115\n\t* testsuite/libgomp.oacc-c-c++-common/private-atomic-1-gang.c: New\n\ttest.\n\t* testsuite/libgomp.oacc-fortran/private-atomic-1-gang.f90:\n\tLikewise.\n\t* testsuite/libgomp.oacc-fortran/private-atomic-1-worker.f90:\n\tLikewise.\n\nCo-Authored-By: Chung-Lin Tang <cltang@codesourcery.com>\nCo-Authored-By: Thomas Schwinge <thomas@codesourcery.com>", "tree": {"sha": "0e18184b3d50407c5100b2dcc182134227ceb053", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e18184b3d50407c5100b2dcc182134227ceb053"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "782e57f2c0900f3c3bbaec4b367568b6d05236b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/782e57f2c0900f3c3bbaec4b367568b6d05236b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/782e57f2c0900f3c3bbaec4b367568b6d05236b8"}], "stats": {"total": 621, "additions": 606, "deletions": 15}, "files": [{"sha": "7ef7ae8af469f22d03ff4fdcc9236f1e3d6dc257", "filename": "gcc/config/gcn/gcn-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h?ref=29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "patch": "@@ -40,7 +40,7 @@ extern rtx gcn_gen_undef (machine_mode);\n extern bool gcn_global_address_p (rtx);\n extern tree gcn_goacc_adjust_propagation_record (tree record_type, bool sender,\n \t\t\t\t\t\t const char *name);\n-extern void gcn_goacc_adjust_gangprivate_decl (tree var);\n+extern tree gcn_goacc_adjust_private_decl (tree var, int level);\n extern void gcn_goacc_reduction (gcall *call);\n extern bool gcn_hard_regno_rename_ok (unsigned int from_reg,\n \t\t\t\t      unsigned int to_reg);"}, {"sha": "75ea50c59dd45e906073e7a2973dfc50f76532aa", "filename": "gcc/config/gcn/gcn-tree.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Fconfig%2Fgcn%2Fgcn-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Fconfig%2Fgcn%2Fgcn-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-tree.c?ref=29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "patch": "@@ -577,9 +577,12 @@ gcn_goacc_adjust_propagation_record (tree record_type, bool sender,\n   return decl;\n }\n \n-void\n-gcn_goacc_adjust_gangprivate_decl (tree var)\n+tree\n+gcn_goacc_adjust_private_decl (tree var, int level)\n {\n+  if (level != GOMP_DIM_GANG)\n+    return var;\n+\n   tree type = TREE_TYPE (var);\n   tree lds_type = build_qualified_type (type,\n \t\t    TYPE_QUALS_NO_ADDR_SPACE (type)\n@@ -597,6 +600,8 @@ gcn_goacc_adjust_gangprivate_decl (tree var)\n \n   if (machfun)\n     machfun->use_flat_addressing = true;\n+\n+  return var;\n }\n \n /* }}}  */"}, {"sha": "283a91fe50a852a03e40de840df89ac24598b58f", "filename": "gcc/config/gcn/gcn.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Fconfig%2Fgcn%2Fgcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Fconfig%2Fgcn%2Fgcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.c?ref=29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "patch": "@@ -6320,8 +6320,8 @@ gcn_dwarf_register_span (rtx rtl)\n #undef  TARGET_GOACC_ADJUST_PROPAGATION_RECORD\n #define TARGET_GOACC_ADJUST_PROPAGATION_RECORD \\\n   gcn_goacc_adjust_propagation_record\n-#undef  TARGET_GOACC_ADJUST_GANGPRIVATE_DECL\n-#define TARGET_GOACC_ADJUST_GANGPRIVATE_DECL gcn_goacc_adjust_gangprivate_decl\n+#undef  TARGET_GOACC_ADJUST_PRIVATE_DECL\n+#define TARGET_GOACC_ADJUST_PRIVATE_DECL gcn_goacc_adjust_private_decl\n #undef  TARGET_GOACC_FORK_JOIN\n #define TARGET_GOACC_FORK_JOIN gcn_fork_join\n #undef  TARGET_GOACC_REDUCTION"}, {"sha": "80116e570d63683004242f47581fce0556ac7f47", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "patch": "@@ -75,6 +75,7 @@\n #include \"fold-const.h\"\n #include \"intl.h\"\n #include \"opts.h\"\n+#include \"tree-pretty-print.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -167,6 +168,12 @@ static unsigned vector_red_align;\n static unsigned vector_red_partition;\n static GTY(()) rtx vector_red_sym;\n \n+/* Shared memory block for gang-private variables.  */\n+static unsigned gang_private_shared_size;\n+static unsigned gang_private_shared_align;\n+static GTY(()) rtx gang_private_shared_sym;\n+static hash_map<tree_decl_hash, unsigned int> gang_private_shared_hmap;\n+\n /* Global lock variable, needed for 128bit worker & gang reductions.  */\n static GTY(()) tree global_lock_var;\n \n@@ -251,6 +258,10 @@ nvptx_option_override (void)\n   vector_red_align = GET_MODE_ALIGNMENT (SImode) / BITS_PER_UNIT;\n   vector_red_partition = 0;\n \n+  gang_private_shared_sym = gen_rtx_SYMBOL_REF (Pmode, \"__gang_private_shared\");\n+  SET_SYMBOL_DATA_AREA (gang_private_shared_sym, DATA_AREA_SHARED);\n+  gang_private_shared_align = GET_MODE_ALIGNMENT (SImode) / BITS_PER_UNIT;\n+\n   diagnose_openacc_conflict (TARGET_GOMP, \"-mgomp\");\n   diagnose_openacc_conflict (TARGET_SOFT_STACK, \"-msoft-stack\");\n   diagnose_openacc_conflict (TARGET_UNIFORM_SIMT, \"-muniform-simt\");\n@@ -5435,6 +5446,10 @@ nvptx_file_end (void)\n     write_shared_buffer (asm_out_file, vector_red_sym,\n \t\t\t vector_red_align, vector_red_size);\n \n+  if (gang_private_shared_size)\n+    write_shared_buffer (asm_out_file, gang_private_shared_sym,\n+\t\t\t gang_private_shared_align, gang_private_shared_size);\n+\n   if (need_softstack_decl)\n     {\n       write_var_marker (asm_out_file, false, true, \"__nvptx_stacks\");\n@@ -6662,6 +6677,64 @@ nvptx_truly_noop_truncation (poly_uint64, poly_uint64)\n   return false;\n }\n \n+/* Implement TARGET_GOACC_ADJUST_PRIVATE_DECL.  */\n+\n+static tree\n+nvptx_goacc_adjust_private_decl (tree decl, int level)\n+{\n+  if (level != GOMP_DIM_GANG)\n+    return decl;\n+\n+  /* Set \"oacc gang-private\" attribute for gang-private variable\n+     declarations.  */\n+  if (!lookup_attribute (\"oacc gang-private\", DECL_ATTRIBUTES (decl)))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Setting 'oacc gang-private' attribute for decl:\");\n+\t  print_generic_decl (dump_file, decl, TDF_SLIM);\n+\t  fputc ('\\n', dump_file);\n+\t}\n+      tree id = get_identifier (\"oacc gang-private\");\n+      DECL_ATTRIBUTES (decl) = tree_cons (id, NULL, DECL_ATTRIBUTES (decl));\n+    }\n+\n+  return decl;\n+}\n+\n+/* Implement TARGET_GOACC_EXPAND_VAR_DECL.  */\n+\n+static rtx\n+nvptx_goacc_expand_var_decl (tree var)\n+{\n+  /* Place \"oacc gang-private\" variables in shared memory.  */\n+  if (VAR_P (var)\n+      && lookup_attribute (\"oacc gang-private\", DECL_ATTRIBUTES (var)))\n+    {\n+      unsigned int offset, *poffset;\n+      poffset = gang_private_shared_hmap.get (var);\n+      if (poffset)\n+\toffset = *poffset;\n+      else\n+\t{\n+\t  unsigned HOST_WIDE_INT align = DECL_ALIGN (var);\n+\t  gang_private_shared_size\n+\t    = (gang_private_shared_size + align - 1) & ~(align - 1);\n+\t  if (gang_private_shared_align < align)\n+\t    gang_private_shared_align = align;\n+\n+\t  offset = gang_private_shared_size;\n+\t  bool existed = gang_private_shared_hmap.put (var, offset);\n+\t  gcc_checking_assert (!existed);\n+\t  gang_private_shared_size += tree_to_uhwi (DECL_SIZE_UNIT (var));\n+\t}\n+      rtx addr = plus_constant (Pmode, gang_private_shared_sym, offset);\n+      return gen_rtx_MEM (TYPE_MODE (TREE_TYPE (var)), addr);\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n static GTY(()) tree nvptx_previous_fndecl;\n \n static void\n@@ -6670,6 +6743,7 @@ nvptx_set_current_function (tree fndecl)\n   if (!fndecl || fndecl == nvptx_previous_fndecl)\n     return;\n \n+  gang_private_shared_hmap.empty ();\n   nvptx_previous_fndecl = fndecl;\n   vector_red_partition = 0;\n   oacc_bcast_partition = 0;\n@@ -6834,6 +6908,12 @@ nvptx_libc_has_function (enum function_class fn_class, tree type)\n #undef TARGET_HAVE_SPECULATION_SAFE_VALUE\n #define TARGET_HAVE_SPECULATION_SAFE_VALUE speculation_safe_value_not_needed\n \n+#undef TARGET_GOACC_ADJUST_PRIVATE_DECL\n+#define TARGET_GOACC_ADJUST_PRIVATE_DECL nvptx_goacc_adjust_private_decl\n+\n+#undef TARGET_GOACC_EXPAND_VAR_DECL\n+#define TARGET_GOACC_EXPAND_VAR_DECL nvptx_goacc_expand_var_decl\n+\n #undef TARGET_SET_CURRENT_FUNCTION\n #define TARGET_SET_CURRENT_FUNCTION nvptx_set_current_function\n "}, {"sha": "78c330c292d15669037c51c403b708bbd691557f", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "patch": "@@ -6236,6 +6236,31 @@ like @code{cond_add@var{m}}.  The default implementation returns a zero\n constant of type @var{type}.\n @end deftypefn\n \n+@deftypefn {Target Hook} tree TARGET_GOACC_ADJUST_PRIVATE_DECL (tree @var{var}, int @var{level})\n+This hook, if defined, is used by accelerator target back-ends to adjust\n+OpenACC variable declarations that should be made private to the given\n+parallelism level (i.e. @code{GOMP_DIM_GANG}, @code{GOMP_DIM_WORKER} or\n+@code{GOMP_DIM_VECTOR}).  A typical use for this hook is to force variable\n+declarations at the @code{gang} level to reside in GPU shared memory.\n+\n+You may also use the @code{TARGET_GOACC_EXPAND_VAR_DECL} hook if the\n+adjusted variable declaration needs to be expanded to RTL in a non-standard\n+way.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} rtx TARGET_GOACC_EXPAND_VAR_DECL (tree @var{var})\n+This hook, if defined, is used by accelerator target back-ends to expand\n+specially handled kinds of @code{VAR_DECL} expressions.  A particular use is\n+to place variables with specific attributes inside special accelarator\n+memories.  A return value of @code{NULL} indicates that the target does not\n+handle this @code{VAR_DECL}, and normal RTL expanding is resumed.\n+\n+Only define this hook if your accelerator target needs to expand certain\n+@code{VAR_DECL} nodes in a way that differs from the default.  You can also adjust\n+private variables at OpenACC device-lowering time using the\n+@code{TARGET_GOACC_ADJUST_PRIVATE_DECL} target hook.\n+@end deftypefn\n+\n @node Anchored Addresses\n @section Anchored Addresses\n @cindex anchored addresses"}, {"sha": "d9fbbe20e6f1350340048f230cd9552b2cfdaf9b", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "patch": "@@ -4221,6 +4221,10 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_PREFERRED_ELSE_VALUE\n \n+@hook TARGET_GOACC_ADJUST_PRIVATE_DECL\n+\n+@hook TARGET_GOACC_EXPAND_VAR_DECL\n+\n @node Anchored Addresses\n @section Anchored Addresses\n @cindex anchored addresses"}, {"sha": "e4660f0e90a8676b58ac085e9ce4e5a91e9aa174", "filename": "gcc/expr.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "patch": "@@ -10419,8 +10419,19 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n       exp = SSA_NAME_VAR (ssa_name);\n       goto expand_decl_rtl;\n \n-    case PARM_DECL:\n     case VAR_DECL:\n+      /* Allow accel compiler to handle variables that require special\n+\t treatment, e.g. if they have been modified in some way earlier in\n+\t compilation by the adjust_private_decl OpenACC hook.  */\n+      if (flag_openacc && targetm.goacc.expand_var_decl)\n+\t{\n+\t  temp = targetm.goacc.expand_var_decl (exp);\n+\t  if (temp)\n+\t    return temp;\n+\t}\n+      /* ... fall through ...  */\n+\n+    case PARM_DECL:\n       /* If a static var's type was incomplete when the decl was written,\n \t but the type is complete now, lay out the decl now.  */\n       if (DECL_SIZE (exp) == 0"}, {"sha": "d92080c80771e6fa61e4c065ce94212341424567", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "patch": "@@ -2969,6 +2969,8 @@ expand_UNIQUE (internal_fn, gcall *stmt)\n       else\n \tgcc_unreachable ();\n       break;\n+    case IFN_UNIQUE_OACC_PRIVATE:\n+      break;\n     }\n \n   if (pattern)"}, {"sha": "5bc5660c1ffc2bffc355072dfa349de5cc62e9ff", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "patch": "@@ -32,11 +32,15 @@ along with GCC; see the file COPYING3.  If not see\n    or leaving partitioned execution.\n       DEP_VAR = UNIQUE ({HEAD,TAIL}_MARK, REMAINING_MARKS, ...PRIMARY_FLAGS)\n \n-   The PRIMARY_FLAGS only occur on the first HEAD_MARK of a sequence.  */\n+   The PRIMARY_FLAGS only occur on the first HEAD_MARK of a sequence.\n+\n+   PRIVATE captures variables to be made private at the surrounding parallelism\n+   level.  */\n #define IFN_UNIQUE_CODES\t\t\t\t  \\\n   DEF(UNSPEC),\t\\\n     DEF(OACC_FORK), DEF(OACC_JOIN),\t\t\\\n-    DEF(OACC_HEAD_MARK), DEF(OACC_TAIL_MARK)\n+    DEF(OACC_HEAD_MARK), DEF(OACC_TAIL_MARK),\t\\\n+    DEF(OACC_PRIVATE)\n \n enum ifn_unique_kind {\n #define DEF(X) IFN_UNIQUE_##X"}, {"sha": "da827ef2e347a28a4efe56635b13aec10dbe2cc3", "filename": "gcc/omp-low.c", "status": "modified", "additions": 119, "deletions": 6, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "patch": "@@ -179,6 +179,9 @@ struct omp_context\n   /* Only used for omp target contexts.  True if an OpenMP construct other\n      than teams is strictly nested in it.  */\n   bool nonteams_nested_p;\n+\n+  /* Candidates for adjusting OpenACC privatization level.  */\n+  vec<tree> oacc_privatization_candidates;\n };\n \n static splay_tree all_contexts;\n@@ -7132,8 +7135,9 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *body_p,\n \n static void\n lower_oacc_reductions (location_t loc, tree clauses, tree level, bool inner,\n-\t\t       gcall *fork, gcall *join, gimple_seq *fork_seq,\n-\t\t       gimple_seq *join_seq, omp_context *ctx)\n+\t\t       gcall *fork, gcall *private_marker, gcall *join,\n+\t\t       gimple_seq *fork_seq, gimple_seq *join_seq,\n+\t\t       omp_context *ctx)\n {\n   gimple_seq before_fork = NULL;\n   gimple_seq after_fork = NULL;\n@@ -7337,6 +7341,8 @@ lower_oacc_reductions (location_t loc, tree clauses, tree level, bool inner,\n \n   /* Now stitch things together.  */\n   gimple_seq_add_seq (fork_seq, before_fork);\n+  if (private_marker)\n+    gimple_seq_add_stmt (fork_seq, private_marker);\n   if (fork)\n     gimple_seq_add_stmt (fork_seq, fork);\n   gimple_seq_add_seq (fork_seq, after_fork);\n@@ -8116,14 +8122,22 @@ lower_oacc_loop_marker (location_t loc, tree ddvar, bool head,\n    HEAD and TAIL.  */\n \n static void\n-lower_oacc_head_tail (location_t loc, tree clauses,\n+lower_oacc_head_tail (location_t loc, tree clauses, gcall *private_marker,\n \t\t      gimple_seq *head, gimple_seq *tail, omp_context *ctx)\n {\n   bool inner = false;\n   tree ddvar = create_tmp_var (integer_type_node, \".data_dep\");\n   gimple_seq_add_stmt (head, gimple_build_assign (ddvar, integer_zero_node));\n \n   unsigned count = lower_oacc_head_mark (loc, ddvar, clauses, head, ctx);\n+\n+  if (private_marker)\n+    {\n+      gimple_set_location (private_marker, loc);\n+      gimple_call_set_lhs (private_marker, ddvar);\n+      gimple_call_set_arg (private_marker, 1, ddvar);\n+    }\n+\n   tree fork_kind = build_int_cst (unsigned_type_node, IFN_UNIQUE_OACC_FORK);\n   tree join_kind = build_int_cst (unsigned_type_node, IFN_UNIQUE_OACC_JOIN);\n \n@@ -8154,7 +8168,8 @@ lower_oacc_head_tail (location_t loc, tree clauses,\n \t\t\t      &join_seq);\n \n       lower_oacc_reductions (loc, clauses, place, inner,\n-\t\t\t     fork, join, &fork_seq, &join_seq,  ctx);\n+\t\t\t     fork, (count == 1) ? private_marker : NULL,\n+\t\t\t     join, &fork_seq, &join_seq,  ctx);\n \n       /* Append this level to head. */\n       gimple_seq_add_seq (head, fork_seq);\n@@ -10129,6 +10144,32 @@ lower_omp_for_lastprivate (struct omp_for_data *fd, gimple_seq *body_p,\n     }\n }\n \n+/* Scan CLAUSES for candidates for adjusting OpenACC privatization level in\n+   CTX.  */\n+\n+static void\n+oacc_privatization_scan_clause_chain (omp_context *ctx, tree clauses)\n+{\n+  for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n+    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE)\n+      {\n+\ttree decl = OMP_CLAUSE_DECL (c);\n+\tif (VAR_P (decl) && TREE_ADDRESSABLE (decl))\n+\t  ctx->oacc_privatization_candidates.safe_push (decl);\n+      }\n+}\n+\n+/* Scan DECLS for candidates for adjusting OpenACC privatization level in\n+   CTX.  */\n+\n+static void\n+oacc_privatization_scan_decl_chain (omp_context *ctx, tree decls)\n+{\n+  for (tree decl = decls; decl; decl = DECL_CHAIN (decl))\n+    if (VAR_P (decl) && TREE_ADDRESSABLE (decl))\n+      ctx->oacc_privatization_candidates.safe_push (decl);\n+}\n+\n /* Callback for walk_gimple_seq.  Find #pragma omp scan statement.  */\n \n static tree\n@@ -10958,6 +10999,58 @@ lower_omp_for_scan (gimple_seq *body_p, gimple_seq *dlist, gomp_for *stmt,\n   *dlist = new_dlist;\n }\n \n+/* Build an internal UNIQUE function with type IFN_UNIQUE_OACC_PRIVATE listing\n+   the addresses of variables to be made private at the surrounding\n+   parallelism level.  Such functions appear in the gimple code stream in two\n+   forms, e.g. for a partitioned loop:\n+\n+      .data_dep.6 = .UNIQUE (OACC_HEAD_MARK, .data_dep.6, 1, 68);\n+      .data_dep.6 = .UNIQUE (OACC_PRIVATE, .data_dep.6, -1, &w);\n+      .data_dep.6 = .UNIQUE (OACC_FORK, .data_dep.6, -1);\n+      .data_dep.6 = .UNIQUE (OACC_HEAD_MARK, .data_dep.6);\n+\n+   or alternatively, OACC_PRIVATE can appear at the top level of a parallel,\n+   not as part of a HEAD_MARK sequence:\n+\n+      .UNIQUE (OACC_PRIVATE, 0, 0, &w);\n+\n+   For such stand-alone appearances, the 3rd argument is always 0, denoting\n+   gang partitioning.  */\n+\n+static gcall *\n+lower_oacc_private_marker (omp_context *ctx)\n+{\n+  if (ctx->oacc_privatization_candidates.length () == 0)\n+    return NULL;\n+\n+  auto_vec<tree, 5> args;\n+\n+  args.quick_push (build_int_cst (integer_type_node, IFN_UNIQUE_OACC_PRIVATE));\n+  args.quick_push (integer_zero_node);\n+  args.quick_push (integer_minus_one_node);\n+\n+  int i;\n+  tree decl;\n+  FOR_EACH_VEC_ELT (ctx->oacc_privatization_candidates, i, decl)\n+    {\n+      for (omp_context *thisctx = ctx; thisctx; thisctx = thisctx->outer)\n+\t{\n+\t  tree inner_decl = maybe_lookup_decl (decl, thisctx);\n+\t  if (inner_decl)\n+\t    {\n+\t      decl = inner_decl;\n+\t      break;\n+\t    }\n+\t}\n+      gcc_checking_assert (decl);\n+\n+      tree addr = build_fold_addr_expr (decl);\n+      args.safe_push (addr);\n+    }\n+\n+  return gimple_build_call_internal_vec (IFN_UNIQUE, args);\n+}\n+\n /* Lower code for an OMP loop directive.  */\n \n static void\n@@ -10974,6 +11067,8 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n   push_gimplify_context ();\n \n+  oacc_privatization_scan_clause_chain (ctx, gimple_omp_for_clauses (stmt));\n+\n   lower_omp (gimple_omp_for_pre_body_ptr (stmt), ctx);\n \n   block = make_node (BLOCK);\n@@ -10992,6 +11087,8 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       gbind *inner_bind\n \t= as_a <gbind *> (gimple_seq_first_stmt (omp_for_body));\n       tree vars = gimple_bind_vars (inner_bind);\n+      if (is_gimple_omp_oacc (ctx->stmt))\n+\toacc_privatization_scan_decl_chain (ctx, vars);\n       gimple_bind_append_vars (new_stmt, vars);\n       /* bind_vars/BLOCK_VARS are being moved to new_stmt/block, don't\n \t keep them on the inner_bind and it's block.  */\n@@ -11105,6 +11202,11 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n   lower_omp (gimple_omp_body_ptr (stmt), ctx);\n \n+  gcall *private_marker = NULL;\n+  if (is_gimple_omp_oacc (ctx->stmt)\n+      && !gimple_seq_empty_p (omp_for_body))\n+    private_marker = lower_oacc_private_marker (ctx);\n+\n   /* Lower the header expressions.  At this point, we can assume that\n      the header is of the form:\n \n@@ -11159,7 +11261,7 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   if (is_gimple_omp_oacc (ctx->stmt)\n       && !ctx_in_oacc_kernels_region (ctx))\n     lower_oacc_head_tail (gimple_location (stmt),\n-\t\t\t  gimple_omp_for_clauses (stmt),\n+\t\t\t  gimple_omp_for_clauses (stmt), private_marker,\n \t\t\t  &oacc_head, &oacc_tail, ctx);\n \n   /* Add OpenACC partitioning and reduction markers just before the loop.  */\n@@ -13156,8 +13258,14 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t     them as a dummy GANG loop.  */\n \t  tree level = build_int_cst (integer_type_node, GOMP_DIM_GANG);\n \n+\t  gcall *private_marker = lower_oacc_private_marker (ctx);\n+\n+\t  if (private_marker)\n+\t    gimple_call_set_arg (private_marker, 2, level);\n+\n \t  lower_oacc_reductions (gimple_location (ctx->stmt), clauses, level,\n-\t\t\t\t false, NULL, NULL, &fork_seq, &join_seq, ctx);\n+\t\t\t\t false, NULL, private_marker, NULL, &fork_seq,\n+\t\t\t\t &join_seq, ctx);\n \t}\n \n       gimple_seq_add_seq (&new_body, fork_seq);\n@@ -13399,6 +13507,11 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t ctx);\n       break;\n     case GIMPLE_BIND:\n+      if (ctx && is_gimple_omp_oacc (ctx->stmt))\n+\t{\n+\t  tree vars = gimple_bind_vars (as_a <gbind *> (stmt));\n+\t  oacc_privatization_scan_decl_chain (ctx, vars);\n+\t}\n       lower_omp (gimple_bind_body_ptr (as_a <gbind *> (stmt)), ctx);\n       maybe_remove_omp_member_access_dummy_vars (as_a <gbind *> (stmt));\n       break;"}, {"sha": "080bdddfe884b74da3bbc17d612098cffc767157", "filename": "gcc/omp-offload.c", "status": "modified", "additions": 224, "deletions": 1, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Fomp-offload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Fomp-offload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-offload.c?ref=29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "patch": "@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"cfgloop.h\"\n #include \"context.h\"\n+#include \"convert.h\"\n \n /* Describe the OpenACC looping structure of a function.  The entire\n    function is held in a 'NULL' loop.  */\n@@ -1357,7 +1358,9 @@ oacc_loop_xform_head_tail (gcall *from, int level)\n \t    = ((enum ifn_unique_kind)\n \t       TREE_INT_CST_LOW (gimple_call_arg (stmt, 0)));\n \n-\t  if (k == IFN_UNIQUE_OACC_FORK || k == IFN_UNIQUE_OACC_JOIN)\n+\t  if (k == IFN_UNIQUE_OACC_FORK\n+\t      || k == IFN_UNIQUE_OACC_JOIN\n+\t      || k == IFN_UNIQUE_OACC_PRIVATE)\n \t    *gimple_call_arg_ptr (stmt, 2) = replacement;\n \t  else if (k == kind && stmt != from)\n \t    break;\n@@ -1774,6 +1777,136 @@ default_goacc_reduction (gcall *call)\n   gsi_replace_with_seq (&gsi, seq, true);\n }\n \n+struct var_decl_rewrite_info\n+{\n+  gimple *stmt;\n+  hash_map<tree, tree> *adjusted_vars;\n+  bool avoid_pointer_conversion;\n+  bool modified;\n+};\n+\n+/* Helper function for execute_oacc_device_lower.  Rewrite VAR_DECLs (by\n+   themselves or wrapped in various other nodes) according to ADJUSTED_VARS in\n+   the var_decl_rewrite_info pointed to via DATA.  Used as part of coercing\n+   gang-private variables in OpenACC offload regions to reside in GPU shared\n+   memory.  */\n+\n+static tree\n+oacc_rewrite_var_decl (tree *tp, int *walk_subtrees, void *data)\n+{\n+  walk_stmt_info *wi = (walk_stmt_info *) data;\n+  var_decl_rewrite_info *info = (var_decl_rewrite_info *) wi->info;\n+\n+  if (TREE_CODE (*tp) == ADDR_EXPR)\n+    {\n+      tree arg = TREE_OPERAND (*tp, 0);\n+      tree *new_arg = info->adjusted_vars->get (arg);\n+\n+      if (new_arg)\n+\t{\n+\t  if (info->avoid_pointer_conversion)\n+\t    {\n+\t      *tp = build_fold_addr_expr (*new_arg);\n+\t      info->modified = true;\n+\t      *walk_subtrees = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      gimple_stmt_iterator gsi = gsi_for_stmt (info->stmt);\n+\t      tree repl = build_fold_addr_expr (*new_arg);\n+\t      gimple *stmt1\n+\t\t= gimple_build_assign (make_ssa_name (TREE_TYPE (repl)), repl);\n+\t      tree conv = convert_to_pointer (TREE_TYPE (*tp),\n+\t\t\t\t\t      gimple_assign_lhs (stmt1));\n+\t      gimple *stmt2\n+\t\t= gimple_build_assign (make_ssa_name (TREE_TYPE (*tp)), conv);\n+\t      gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);\n+\t      gsi_insert_before (&gsi, stmt2, GSI_SAME_STMT);\n+\t      *tp = gimple_assign_lhs (stmt2);\n+\t      info->modified = true;\n+\t      *walk_subtrees = 0;\n+\t    }\n+\t}\n+    }\n+  else if (TREE_CODE (*tp) == COMPONENT_REF || TREE_CODE (*tp) == ARRAY_REF)\n+    {\n+      tree *base = &TREE_OPERAND (*tp, 0);\n+\n+      while (TREE_CODE (*base) == COMPONENT_REF\n+\t     || TREE_CODE (*base) == ARRAY_REF)\n+\tbase = &TREE_OPERAND (*base, 0);\n+\n+      if (TREE_CODE (*base) != VAR_DECL)\n+\treturn NULL;\n+\n+      tree *new_decl = info->adjusted_vars->get (*base);\n+      if (!new_decl)\n+\treturn NULL;\n+\n+      int base_quals = TYPE_QUALS (TREE_TYPE (*new_decl));\n+      tree field = TREE_OPERAND (*tp, 1);\n+\n+      /* Adjust the type of the field.  */\n+      int field_quals = TYPE_QUALS (TREE_TYPE (field));\n+      if (TREE_CODE (field) == FIELD_DECL && field_quals != base_quals)\n+\t{\n+\t  tree *field_type = &TREE_TYPE (field);\n+\t  while (TREE_CODE (*field_type) == ARRAY_TYPE)\n+\t    field_type = &TREE_TYPE (*field_type);\n+\t  field_quals |= base_quals;\n+\t  *field_type = build_qualified_type (*field_type, field_quals);\n+\t}\n+\n+      /* Adjust the type of the component ref itself.  */\n+      tree comp_type = TREE_TYPE (*tp);\n+      int comp_quals = TYPE_QUALS (comp_type);\n+      if (TREE_CODE (*tp) == COMPONENT_REF && comp_quals != base_quals)\n+\t{\n+\t  comp_quals |= base_quals;\n+\t  TREE_TYPE (*tp)\n+\t    = build_qualified_type (comp_type, comp_quals);\n+\t}\n+\n+      *base = *new_decl;\n+      info->modified = true;\n+    }\n+  else if (TREE_CODE (*tp) == VAR_DECL)\n+    {\n+      tree *new_decl = info->adjusted_vars->get (*tp);\n+      if (new_decl)\n+\t{\n+\t  *tp = *new_decl;\n+\t  info->modified = true;\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Return TRUE if CALL is a call to a builtin atomic/sync operation.  */\n+\n+static bool\n+is_sync_builtin_call (gcall *call)\n+{\n+  tree callee = gimple_call_fndecl (call);\n+\n+  if (callee != NULL_TREE\n+      && gimple_call_builtin_p (call, BUILT_IN_NORMAL))\n+    switch (DECL_FUNCTION_CODE (callee))\n+      {\n+#undef DEF_SYNC_BUILTIN\n+#define DEF_SYNC_BUILTIN(ENUM, NAME, TYPE, ATTRS) case ENUM:\n+#include \"sync-builtins.def\"\n+#undef DEF_SYNC_BUILTIN\n+\treturn true;\n+\n+      default:\n+\t;\n+      }\n+\n+  return false;\n+}\n+\n /* Main entry point for oacc transformations which run on the device\n    compiler after LTO, so we know what the target device is at this\n    point (including the host fallback).  */\n@@ -1923,6 +2056,8 @@ execute_oacc_device_lower ()\n      dominance information to update SSA.  */\n   calculate_dominance_info (CDI_DOMINATORS);\n \n+  hash_map<tree, tree> adjusted_vars;\n+\n   /* Now lower internal loop functions to target-specific code\n      sequences.  */\n   basic_block bb;\n@@ -1999,6 +2134,45 @@ execute_oacc_device_lower ()\n \t\tcase IFN_UNIQUE_OACC_TAIL_MARK:\n \t\t  remove = true;\n \t\t  break;\n+\n+\t\tcase IFN_UNIQUE_OACC_PRIVATE:\n+\t\t  {\n+\t\t    HOST_WIDE_INT level\n+\t\t      = TREE_INT_CST_LOW (gimple_call_arg (call, 2));\n+\t\t    if (level == -1)\n+\t\t      break;\n+\t\t    for (unsigned i = 3;\n+\t\t\t i < gimple_call_num_args (call);\n+\t\t\t i++)\n+\t\t      {\n+\t\t\ttree arg = gimple_call_arg (call, i);\n+\t\t\tgcc_checking_assert (TREE_CODE (arg) == ADDR_EXPR);\n+\t\t\ttree decl = TREE_OPERAND (arg, 0);\n+\t\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\t  {\n+\t\t\t    static char const *const axes[] =\n+\t\t\t      /* Must be kept in sync with GOMP_DIM\n+\t\t\t\t enumeration.  */\n+\t\t\t      { \"gang\", \"worker\", \"vector\" };\n+\t\t\t    fprintf (dump_file, \"Decl UID %u has %s \"\n+\t\t\t\t     \"partitioning:\", DECL_UID (decl),\n+\t\t\t\t     axes[level]);\n+\t\t\t    print_generic_decl (dump_file, decl, TDF_SLIM);\n+\t\t\t    fputc ('\\n', dump_file);\n+\t\t\t  }\n+\t\t\tif (targetm.goacc.adjust_private_decl)\n+\t\t\t  {\n+\t\t\t    tree oldtype = TREE_TYPE (decl);\n+\t\t\t    tree newdecl\n+\t\t\t      = targetm.goacc.adjust_private_decl (decl, level);\n+\t\t\t    if (TREE_TYPE (newdecl) != oldtype\n+\t\t\t\t|| newdecl != decl)\n+\t\t\t      adjusted_vars.put (decl, newdecl);\n+\t\t\t  }\n+\t\t      }\n+\t\t    remove = true;\n+\t\t  }\n+\t\t  break;\n \t\t}\n \t      break;\n \t    }\n@@ -2030,6 +2204,55 @@ execute_oacc_device_lower ()\n \t  gsi_next (&gsi);\n       }\n \n+  /* Make adjustments to gang-private local variables if required by the\n+     target, e.g. forcing them into a particular address space.  Afterwards,\n+     ADDR_EXPR nodes which have adjusted variables as their argument need to\n+     be modified in one of two ways:\n+\n+       1. They can be recreated, making a pointer to the variable in the new\n+\t  address space, or\n+\n+       2. The address of the variable in the new address space can be taken,\n+\t  converted to the default (original) address space, and the result of\n+\t  that conversion subsituted in place of the original ADDR_EXPR node.\n+\n+     Which of these is done depends on the gimple statement being processed.\n+     At present atomic operations and inline asms use (1), and everything else\n+     uses (2).  At least on AMD GCN, there are atomic operations that work\n+     directly in the LDS address space.\n+\n+     COMPONENT_REFS, ARRAY_REFS and plain VAR_DECLs are also rewritten to use\n+     the new decl, adjusting types of appropriate tree nodes as necessary.  */\n+\n+  if (targetm.goacc.adjust_private_decl)\n+    {\n+      FOR_ALL_BB_FN (bb, cfun)\n+\tfor (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n+\t     !gsi_end_p (gsi);\n+\t     gsi_next (&gsi))\n+\t  {\n+\t    gimple *stmt = gsi_stmt (gsi);\n+\t    walk_stmt_info wi;\n+\t    var_decl_rewrite_info info;\n+\n+\t    info.avoid_pointer_conversion\n+\t      = (is_gimple_call (stmt)\n+\t\t && is_sync_builtin_call (as_a <gcall *> (stmt)))\n+\t\t|| gimple_code (stmt) == GIMPLE_ASM;\n+\t    info.stmt = stmt;\n+\t    info.modified = false;\n+\t    info.adjusted_vars = &adjusted_vars;\n+\n+\t    memset (&wi, 0, sizeof (wi));\n+\t    wi.info = &info;\n+\n+\t    walk_gimple_op (stmt, oacc_rewrite_var_decl, &wi);\n+\n+\t    if (info.modified)\n+\t      update_stmt (stmt);\n+\t  }\n+    }\n+\n   free_oacc_loop (loops);\n \n   return 0;"}, {"sha": "660b69f5cb5dfe87a2f7e3a7dd2aa7c89894529f", "filename": "gcc/target.def", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "patch": "@@ -1726,6 +1726,35 @@ for allocating any storage for reductions when necessary.\",\n void, (gcall *call),\n default_goacc_reduction)\n \n+DEFHOOK\n+(adjust_private_decl,\n+\"This hook, if defined, is used by accelerator target back-ends to adjust\\n\\\n+OpenACC variable declarations that should be made private to the given\\n\\\n+parallelism level (i.e. @code{GOMP_DIM_GANG}, @code{GOMP_DIM_WORKER} or\\n\\\n+@code{GOMP_DIM_VECTOR}).  A typical use for this hook is to force variable\\n\\\n+declarations at the @code{gang} level to reside in GPU shared memory.\\n\\\n+\\n\\\n+You may also use the @code{TARGET_GOACC_EXPAND_VAR_DECL} hook if the\\n\\\n+adjusted variable declaration needs to be expanded to RTL in a non-standard\\n\\\n+way.\",\n+tree, (tree var, int level),\n+NULL)\n+\n+DEFHOOK\n+(expand_var_decl,\n+\"This hook, if defined, is used by accelerator target back-ends to expand\\n\\\n+specially handled kinds of @code{VAR_DECL} expressions.  A particular use is\\n\\\n+to place variables with specific attributes inside special accelarator\\n\\\n+memories.  A return value of @code{NULL} indicates that the target does not\\n\\\n+handle this @code{VAR_DECL}, and normal RTL expanding is resumed.\\n\\\n+\\n\\\n+Only define this hook if your accelerator target needs to expand certain\\n\\\n+@code{VAR_DECL} nodes in a way that differs from the default.  You can also adjust\\n\\\n+private variables at OpenACC device-lowering time using the\\n\\\n+@code{TARGET_GOACC_ADJUST_PRIVATE_DECL} target hook.\",\n+rtx, (tree var),\n+NULL)\n+\n HOOK_VECTOR_END (goacc)\n \n /* Functions relating to vectorization.  */"}, {"sha": "28222c25da3baed6349a3f8af10545b460270398", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/private-atomic-1-gang.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fprivate-atomic-1-gang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fprivate-atomic-1-gang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fprivate-atomic-1-gang.c?ref=29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "patch": "@@ -0,0 +1,38 @@\n+#include <assert.h>\n+\n+int main (void)\n+{\n+  int ret;\n+\n+  #pragma acc parallel num_gangs(1) num_workers(32) copyout(ret)\n+  {\n+    int w = 0;\n+\n+    #pragma acc loop worker\n+    for (int i = 0; i < 32; i++)\n+      {\n+\t#pragma acc atomic update\n+\tw++;\n+      }\n+\n+    ret = (w == 32);\n+  }\n+  assert (ret);\n+\n+  #pragma acc parallel num_gangs(1) vector_length(32) copyout(ret)\n+  {\n+    int v = 0;\n+\n+    #pragma acc loop vector\n+    for (int i = 0; i < 32; i++)\n+      {\n+\t#pragma acc atomic update\n+\tv++;\n+      }\n+\n+    ret = (v == 32);\n+  }\n+  assert (ret);\n+\n+  return 0;\n+}"}, {"sha": "81487d7a7e06b23c6800c439ba759d65f1162083", "filename": "libgomp/testsuite/libgomp.oacc-fortran/private-atomic-1-gang.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivate-atomic-1-gang.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivate-atomic-1-gang.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivate-atomic-1-gang.f90?ref=29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "patch": "@@ -0,0 +1,25 @@\n+! Test for \"oacc gang-private\" attribute on gang-private variables\n+\n+! { dg-do run }\n+! { dg-additional-options \"-fdump-tree-oaccdevlow-details -w\" }\n+\n+program main\n+  integer :: w, arr(0:31)\n+\n+  !$acc parallel num_gangs(32) num_workers(32) copyout(arr)\n+    !$acc loop gang private(w)\n+! { dg-final { scan-tree-dump-times \"Decl UID \\[0-9\\]+ has gang partitioning:  integer\\\\(kind=4\\\\) w;\" 1 \"oaccdevlow\" } } */\n+    do j = 0, 31\n+      w = 0\n+      !$acc loop seq\n+      do i = 0, 31\n+        !$acc atomic update\n+        w = w + 1\n+        !$acc end atomic\n+      end do\n+      arr(j) = w\n+    end do\n+  !$acc end parallel\n+\n+  if (any (arr .ne. 32)) stop 1\n+end program main"}, {"sha": "21d137545910d4895a65faa99a18700a50c13ce5", "filename": "libgomp/testsuite/libgomp.oacc-fortran/private-atomic-1-worker.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivate-atomic-1-worker.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivate-atomic-1-worker.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivate-atomic-1-worker.f90?ref=29a2f51806c5b30e17a8d0e9ba7915a3c53c34ff", "patch": "@@ -0,0 +1,32 @@\n+! Test for worker-private variables\n+\n+! { dg-do run }\n+! { dg-additional-options \"-fdump-tree-oaccdevlow-details\" }\n+\n+program main\n+  integer :: w, arr(0:31)\n+\n+  !$acc parallel num_gangs(32) num_workers(32) copyout(arr)\n+    !$acc loop gang worker private(w)\n+! { dg-final { scan-tree-dump-times \"Decl UID \\[0-9\\]+ has worker partitioning:  integer\\\\(kind=4\\\\) w;\" 1 \"oaccdevlow\" } } */\n+    do j = 0, 31\n+      w = 0\n+      !$acc loop seq\n+      do i = 0, 31\n+        !$acc atomic update\n+        w = w + 1\n+        ! nvptx offloading: PR83812 \"operation not supported on global/shared address space\".\n+        ! { dg-output \"(\\n|\\r\\n|\\r)libgomp: cuStreamSynchronize error: operation not supported on global/shared address space(\\n|\\r\\n|\\r)$\" { target openacc_nvidia_accel_selected } }\n+        !   Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n+        ! { dg-shouldfail \"XFAILed\" { openacc_nvidia_accel_selected } }\n+        !   ... instead of 'dg-xfail-run-if' so that 'dg-output' is evaluated at all.\n+        ! { dg-final { if { [dg-process-target { xfail openacc_nvidia_accel_selected }] == \"F\" } { xfail \"[testname-for-summary] really is XFAILed\" } } }\n+        !   ... so that we still get an XFAIL visible in the log.\n+        !$acc end atomic\n+      end do\n+      arr(j) = w\n+    end do\n+  !$acc end parallel\n+\n+  if (any (arr .ne. 32)) stop 1\n+end program main"}]}