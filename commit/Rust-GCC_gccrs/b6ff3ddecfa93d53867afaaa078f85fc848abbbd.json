{"sha": "b6ff3ddecfa93d53867afaaa078f85fc848abbbd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZmZjNkZGVjZmE5M2Q1Mzg2N2FmYWFhMDc4Zjg1ZmM4NDhhYmJiZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-08T10:03:30Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-11T14:52:45Z"}, "message": "tree-optimization/94988 - enhance SM some more\n\nThis enhances store-order preserving store motion to handle the case\nof non-invariant dependent stores in the sequence of unconditionally\nexecuted stores on exit by re-issueing them as part of the sequence\nof stores on the exit.  This fixes the observed regression of\ngcc.target/i386/pr64110.c which relies on store-motion of 'b'\nfor a loop like\n\n  for (int i = 0; i < j; ++i)\n    *b++ = x;\n\nwhere for correctness we now no longer apply store-motion.  With\nthe patch we emit the correct\n\n  tem = b;\n  for (int i = 0; i < j; ++i)\n    {\n      tem = tem + 1;\n      *tem = x;\n    }\n  b = tem;\n  *tem = x;\n\npreserving the original order of stores.  A testcase reflecting\nthe miscompilation done by earlier GCC is added as well.\n\nThis also fixes the reported ICE in PR95025 and adds checking code\nto catch it earlier - the issue was not-supported refs propagation\nleaving stray refs in the sequence.\n\n2020-05-11  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/94988\n\tPR tree-optimization/95025\n\t* tree-ssa-loop-im.c (seq_entry): Make a struct, add from.\n\t(sm_seq_push_down): Take extra parameter denoting where we\n\tmoved the ref to.\n\t(execute_sm_exit): Re-issue sm_other stores in the correct\n\torder.\n\t(sm_seq_valid_bb): When always executed, allow sm_other to\n\tprevail inbetween sm_ord and record their stored value.\n\t(hoist_memory_references): Adjust refs_not_supported propagation\n\tand prune sm_other from the end of the ordered sequences.\n\n\t* gcc.dg/torture/pr94988.c: New testcase.\n\t* gcc.dg/torture/pr95025.c: Likewise.\n\t* gcc.dg/torture/pr95045.c: Likewise.\n\t* g++.dg/asan/pr95025.C: New testcase.", "tree": {"sha": "1f2f4e1320b8db08dcc8c0c3c9d82a368c89a610", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f2f4e1320b8db08dcc8c0c3c9d82a368c89a610"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6ff3ddecfa93d53867afaaa078f85fc848abbbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6ff3ddecfa93d53867afaaa078f85fc848abbbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6ff3ddecfa93d53867afaaa078f85fc848abbbd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6ff3ddecfa93d53867afaaa078f85fc848abbbd/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "892c7427ee234c04852e90d9ce32913a429adf9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/892c7427ee234c04852e90d9ce32913a429adf9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/892c7427ee234c04852e90d9ce32913a429adf9d"}], "stats": {"total": 290, "additions": 241, "deletions": 49}, "files": [{"sha": "6072e78cf7715bad9006f970c31acbaa5e9c5faa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ff3ddecfa93d53867afaaa078f85fc848abbbd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ff3ddecfa93d53867afaaa078f85fc848abbbd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b6ff3ddecfa93d53867afaaa078f85fc848abbbd", "patch": "@@ -1,3 +1,17 @@\n+2020-05-11  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/94988\n+\tPR tree-optimization/95025\n+\t* tree-ssa-loop-im.c (seq_entry): Make a struct, add from.\n+\t(sm_seq_push_down): Take extra parameter denoting where we\n+\tmoved the ref to.\n+\t(execute_sm_exit): Re-issue sm_other stores in the correct\n+\torder.\n+\t(sm_seq_valid_bb): When always executed, allow sm_other to\n+\tprevail inbetween sm_ord and record their stored value.\n+\t(hoist_memory_references): Adjust refs_not_supported propagation\n+\tand prune sm_other from the end of the ordered sequences.\n+\n 2020-05-11  Felix Yang  <felix.yang@huawei.com>\n \n \tPR target/94991"}, {"sha": "a79cdb561ddb3e6c7ad0a323ffb523eb9108b012", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ff3ddecfa93d53867afaaa078f85fc848abbbd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ff3ddecfa93d53867afaaa078f85fc848abbbd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b6ff3ddecfa93d53867afaaa078f85fc848abbbd", "patch": "@@ -1,3 +1,12 @@\n+2020-05-11  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/94988\n+\tPR tree-optimization/95025\n+\t* gcc.dg/torture/pr94988.c: New testcase.\n+\t* gcc.dg/torture/pr95025.c: Likewise.\n+\t* gcc.dg/torture/pr95045.c: Likewise.\n+\t* g++.dg/asan/pr95025.C: New testcase.\n+\n 2020-05-11  Jakub Jelinek  <jakub@redhat.com>\n \t    Tobias Burnus  <tobias@codesourcery.com>\n "}, {"sha": "dabb7e92f82443040168d0ead8f06332df900931", "filename": "gcc/testsuite/g++.dg/asan/pr95025.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ff3ddecfa93d53867afaaa078f85fc848abbbd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fpr95025.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ff3ddecfa93d53867afaaa078f85fc848abbbd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fpr95025.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fpr95025.C?ref=b6ff3ddecfa93d53867afaaa078f85fc848abbbd", "patch": "@@ -0,0 +1,28 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fsanitize=address\" }\n+\n+struct a {\n+    int b;\n+} * c;\n+struct d {\n+    d *e;\n+};\n+struct f {\n+    bool done;\n+    d *g;\n+};\n+int h;\n+int i(f *j) {\n+    if (j->g) {\n+\tj->g = j->g->e;\n+\treturn h;\n+    }\n+    j->done = true;\n+    return 0;\n+}\n+void k(bool j) { c->b = j; }\n+void l() {\n+    f a;\n+    for (; !(&a)->done; i(&a))\n+      k(true);\n+}"}, {"sha": "1ee99fea5ce0b7ba2f1d6d9cfe14d419f4d81bb4", "filename": "gcc/testsuite/gcc.dg/torture/pr94988.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ff3ddecfa93d53867afaaa078f85fc848abbbd/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr94988.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ff3ddecfa93d53867afaaa078f85fc848abbbd/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr94988.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr94988.c?ref=b6ff3ddecfa93d53867afaaa078f85fc848abbbd", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do run } */\n+\n+short *b;\n+\n+void __attribute__((noipa))\n+bar (short x, int j)\n+{\n+  for (int i = 0; i < j; ++i)\n+    *b++ = x;\n+}\n+\n+int\n+main()\n+{\n+  b = (short *)&b;\n+  bar (0, 1);\n+  if ((short)(__UINTPTR_TYPE__)b != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "5834dc048878cc9a43fabf89d78e95eb32a68371", "filename": "gcc/testsuite/gcc.dg/torture/pr95025.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ff3ddecfa93d53867afaaa078f85fc848abbbd/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr95025.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ff3ddecfa93d53867afaaa078f85fc848abbbd/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr95025.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr95025.c?ref=b6ff3ddecfa93d53867afaaa078f85fc848abbbd", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+\n+static int a;\n+short b;\n+int *c;\n+void d() {\n+    for (;; a -= 1)\n+      for (; b; b += 1) {\n+\t  *c ^= 5;\n+\t  if (a)\n+\t    return;\n+      }\n+}"}, {"sha": "9f591beb6be01aa13dbc187324fe06d883dd0bdf", "filename": "gcc/testsuite/gcc.dg/torture/pr95045.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ff3ddecfa93d53867afaaa078f85fc848abbbd/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr95045.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ff3ddecfa93d53867afaaa078f85fc848abbbd/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr95045.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr95045.c?ref=b6ff3ddecfa93d53867afaaa078f85fc848abbbd", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run } */\n+\n+int a, c, f;\n+long b;\n+char d;\n+int e[3];\n+int g[9][3][2];\n+int main()\n+{\n+    {\n+h:\n+      for (f = 0; f <= 5; f++) {\n+\t  b = 3;\n+\t  for (; b >= 0; b--) {\n+\t      e[2] = d = 0;\n+\t      for (; d <= 3; d++) {\n+\t\t  g[8][2][0] = e[1] = c = 0;\n+\t\t  for (; c <= 1; c++)\n+\t\t    e[c + 1] = g[d + 5][2][c] = 4;\n+\t      }\n+\t      if (a)\n+\t\tgoto h;\n+\t  }\n+      }\n+    }\n+  if (e[2] != 4)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "bb78dfb2ce841ea98c8900d7981b961b6db25392", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 128, "deletions": 49, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6ff3ddecfa93d53867afaaa078f85fc848abbbd/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6ff3ddecfa93d53867afaaa078f85fc848abbbd/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=b6ff3ddecfa93d53867afaaa078f85fc848abbbd", "patch": "@@ -2209,7 +2209,14 @@ execute_sm (class loop *loop, im_mem_ref *ref,\n        able to execute in arbitrary order with respect to other stores\n    sm_other is used for stores we do not try to apply store motion to.  */\n enum sm_kind { sm_ord, sm_unord, sm_other };\n-typedef std::pair<unsigned, sm_kind> seq_entry;\n+struct seq_entry\n+{\n+  seq_entry (unsigned f, sm_kind k, tree fr = NULL)\n+    : first (f), second (k), from (fr) {}\n+  unsigned first;\n+  sm_kind second;\n+  tree from;\n+};\n \n static void\n execute_sm_exit (class loop *loop, edge ex, vec<seq_entry> &seq,\n@@ -2218,35 +2225,54 @@ execute_sm_exit (class loop *loop, edge ex, vec<seq_entry> &seq,\n   /* Sink the stores to exit from the loop.  */\n   for (unsigned i = seq.length (); i > 0; --i)\n     {\n-      if (seq[i-1].second != kind)\n-\tcontinue;\n       im_mem_ref *ref = memory_accesses.refs_list[seq[i-1].first];\n-      sm_aux *aux = *aux_map.get (ref);\n-      if (!aux->store_flag)\n+      if (seq[i-1].second == sm_other)\n \t{\n-\t  gassign *store;\n-\t  store = gimple_build_assign (unshare_expr (ref->mem.ref),\n-\t\t\t\t       aux->tmp_var);\n+\t  gcc_assert (kind == sm_ord && seq[i-1].from != NULL_TREE);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Re-issueing dependent store of \");\n+\t      print_generic_expr (dump_file, ref->mem.ref);\n+\t      fprintf (dump_file, \" from loop %d on exit %d -> %d\\n\",\n+\t\t       loop->num, ex->src->index, ex->dest->index);\n+\t    }\n+\t  gassign *store = gimple_build_assign (unshare_expr (ref->mem.ref),\n+\t\t\t\t\t\tseq[i-1].from);\n \t  gsi_insert_on_edge (ex, store);\n \t}\n       else\n-\texecute_sm_if_changed (ex, ref->mem.ref, aux->tmp_var, aux->store_flag,\n-\t\t\t       loop_preheader_edge (loop), &aux->flag_bbs);\n+\t{\n+\t  sm_aux *aux = *aux_map.get (ref);\n+\t  if (!aux->store_flag)\n+\t    {\n+\t      gassign *store;\n+\t      store = gimple_build_assign (unshare_expr (ref->mem.ref),\n+\t\t\t\t\t   aux->tmp_var);\n+\t      gsi_insert_on_edge (ex, store);\n+\t    }\n+\t  else\n+\t    execute_sm_if_changed (ex, ref->mem.ref, aux->tmp_var,\n+\t\t\t\t   aux->store_flag,\n+\t\t\t\t   loop_preheader_edge (loop), &aux->flag_bbs);\n+\t}\n     }\n }\n \n /* Push the SM candidate at index PTR in the sequence SEQ down until\n    we hit the next SM candidate.  Return true if that went OK and\n-   false if we could not disambiguate agains another unrelated ref.  */\n+   false if we could not disambiguate agains another unrelated ref.\n+   Update *AT to the index where the candidate now resides.  */\n \n static bool\n-sm_seq_push_down (vec<seq_entry> &seq, unsigned ptr)\n+sm_seq_push_down (vec<seq_entry> &seq, unsigned ptr, unsigned *at)\n {\n+  *at = ptr;\n   for (; ptr > 0; --ptr)\n     {\n       seq_entry &new_cand = seq[ptr];\n       seq_entry &against = seq[ptr-1];\n-      if (against.second == sm_ord)\n+      if (against.second == sm_ord\n+\t  || (against.second == sm_other && against.from != NULL_TREE))\n \t/* Found the tail of the sequence.  */\n \tbreak;\n       if (!refs_independent_p (memory_accesses.refs_list[new_cand.first],\n@@ -2255,6 +2281,7 @@ sm_seq_push_down (vec<seq_entry> &seq, unsigned ptr)\n \t/* ???  Prune new_cand from the list of refs to apply SM to.  */\n \treturn false;\n       std::swap (new_cand, against);\n+      *at = ptr - 1;\n     }\n   return true;\n }\n@@ -2367,37 +2394,41 @@ sm_seq_valid_bb (class loop *loop, basic_block bb, tree vdef,\n \t\t     not order-preserving SM code.  */\n \t\t  if (first_edge_seq[i].first != edge_seq[i].first)\n \t\t    {\n-\t\t      bitmap_set_bit (refs_not_supported,\n-\t\t\t\t      first_edge_seq[i].first);\n-\t\t      bitmap_set_bit (refs_not_supported, edge_seq[i].first);\n-\t\t      first_edge_seq[i].second = sm_unord;\n+\t\t      if (first_edge_seq[i].second == sm_ord)\n+\t\t\tbitmap_set_bit (refs_not_supported,\n+\t\t\t\t\tfirst_edge_seq[i].first);\n+\t\t      if (edge_seq[i].second == sm_ord)\n+\t\t\tbitmap_set_bit (refs_not_supported, edge_seq[i].first);\n+\t\t      first_edge_seq[i].second = sm_other;\n \t\t    }\n-\t\t  /* sm_unord prevails.  */\n+\t\t  /* sm_other prevails.  */\n \t\t  else if (first_edge_seq[i].second != edge_seq[i].second)\n \t\t    {\n \t\t      /* This is just an optimization.  */\n \t\t      gcc_assert (bitmap_bit_p (refs_not_supported,\n \t\t\t\t\t\tfirst_edge_seq[i].first));\n-\t\t      first_edge_seq[i].second = sm_unord;\n+\t\t      first_edge_seq[i].second = sm_other;\n \t\t    }\n \t\t}\n-\t      /* Any excess elements become sm_unord since they are now\n+\t      /* Any excess elements become sm_other since they are now\n \t\t coonditionally executed.  */\n \t      if (first_edge_seq.length () > edge_seq.length ())\n \t\t{\n \t\t  for (unsigned i = edge_seq.length ();\n \t\t       i < first_edge_seq.length (); ++i)\n \t\t    {\n-\t\t      bitmap_set_bit (refs_not_supported,\n-\t\t\t\t      first_edge_seq[i].first);\n-\t\t      first_edge_seq[i].second = sm_unord;\n+\t\t      if (first_edge_seq[i].second == sm_ord)\n+\t\t\tbitmap_set_bit (refs_not_supported,\n+\t\t\t\t\tfirst_edge_seq[i].first);\n+\t\t      first_edge_seq[i].second = sm_other;\n \t\t    }\n \t\t}\n \t      else if (edge_seq.length () > first_edge_seq.length ())\n \t\t{\n \t\t  for (unsigned i = first_edge_seq.length ();\n \t\t       i < edge_seq.length (); ++i)\n-\t\t    bitmap_set_bit (refs_not_supported, edge_seq[i].first);\n+\t\t    if (edge_seq[i].second == sm_ord)\n+\t\t      bitmap_set_bit (refs_not_supported, edge_seq[i].first);\n \t\t}\n \t    }\n \t  /* Use the sequence from the first edge and push SMs down.  */\n@@ -2407,17 +2438,13 @@ sm_seq_valid_bb (class loop *loop, basic_block bb, tree vdef,\n \t\tbreak;\n \t      unsigned id = first_edge_seq[i].first;\n \t      seq.safe_push (first_edge_seq[i]);\n+\t      unsigned new_idx;\n \t      if (first_edge_seq[i].second == sm_ord\n-\t\t  && !sm_seq_push_down (seq, seq.length () - 1))\n+\t\t  && !sm_seq_push_down (seq, seq.length () - 1, &new_idx))\n \t\t{\n \t\t  bitmap_set_bit (refs_not_supported, id);\n-\t\t  /* ???  Mark it sm_unord but it's now \"somewhere\" ... */\n-\t\t  for (unsigned i = seq.length (); i != 0; --i)\n-\t\t    if (seq[i - 1].first == id)\n-\t\t      {\n-\t\t\tseq[i - 1].second = sm_unord;\n-\t\t\tbreak;\n-\t\t      }\n+\t\t  /* Mark it sm_other.  */\n+\t\t  seq[new_idx].second = sm_other;\n \t\t}\n \t    }\n \t  return 1;\n@@ -2429,21 +2456,21 @@ sm_seq_valid_bb (class loop *loop, basic_block bb, tree vdef,\n       /* One of the stores we want to apply SM to and we've not yet seen.  */\n       else if (bitmap_clear_bit (refs_not_in_seq, data->ref))\n \t{\n-\t  seq.safe_push (std::make_pair (data->ref, sm_ord));\n+\t  seq.safe_push (seq_entry (data->ref, sm_ord));\n \n \t  /* 1) push it down the queue until a SMed\n \t     and not ignored ref is reached, skipping all not SMed refs\n \t     and ignored refs via non-TBAA disambiguation.  */\n-\t  if (!sm_seq_push_down (seq, seq.length () - 1))\n+\t  unsigned new_idx;\n+\t  if (!sm_seq_push_down (seq, seq.length () - 1, &new_idx)\n+\t      /* If that fails but we did not fork yet continue, we'll see\n+\t\t to re-materialize all of the stores in the sequence then.\n+\t\t Further stores will only be pushed up to this one.  */\n+\t      && forked)\n \t    {\n \t      bitmap_set_bit (refs_not_supported, data->ref);\n-\t      /* ???  Mark it sm_unord but it's now \"somewhere\" ... */\n-\t      for (unsigned i = seq.length (); i != 0; --i)\n-\t\tif (seq[i - 1].first == data->ref)\n-\t\t  {\n-\t\t    seq[i - 1].second = sm_unord;\n-\t\t    break;\n-\t\t  }\n+\t      /* Mark it sm_other.  */\n+\t      seq[new_idx].second = sm_other;\n \t    }\n \n \t  /* 2) check whether we've seen all refs we want to SM and if so\n@@ -2453,7 +2480,8 @@ sm_seq_valid_bb (class loop *loop, basic_block bb, tree vdef,\n \t}\n       else\n \t/* Another store not part of the final sequence.  Simply push it.  */\n-\tseq.safe_push (std::make_pair (data->ref, sm_other));\n+\tseq.safe_push (seq_entry (data->ref, sm_other,\n+\t\t\t\t  gimple_assign_rhs1 (def)));\n \n       vdef = gimple_vuse (def);\n     }\n@@ -2513,21 +2541,72 @@ hoist_memory_references (class loop *loop, bitmap mem_refs,\n       std::pair<edge, vec<seq_entry> > *seq;\n       FOR_EACH_VEC_ELT (sms, i, seq)\n \t{\n+\t  bool need_to_push = false;\n \t  for (unsigned i = 0; i < seq->second.length (); ++i)\n \t    {\n-\t      if (seq->second[i].second == sm_other)\n+\t      sm_kind kind = seq->second[i].second;\n+\t      if (kind == sm_other && seq->second[i].from == NULL_TREE)\n \t\tbreak;\n \t      unsigned id = seq->second[i].first;\n-\t      if (bitmap_bit_p (refs_not_supported, id))\n-\t\tseq->second[i].second = sm_other;\n-\t      else if (!sm_seq_push_down (seq->second, i))\n+\t      unsigned new_idx;\n+\t      if (kind == sm_ord\n+\t\t  && bitmap_bit_p (refs_not_supported, id))\n \t\t{\n-\t\t  if (bitmap_set_bit (refs_not_supported, id))\n-\t\t    changed = true;\n+\t\t  seq->second[i].second = sm_other;\n+\t\t  gcc_assert (seq->second[i].from == NULL_TREE);\n+\t\t  need_to_push = true;\n+\t\t}\n+\t      else if (need_to_push\n+\t\t       && !sm_seq_push_down (seq->second, i, &new_idx))\n+\t\t{\n+\t\t  /* We need to push down both sm_ord and sm_other\n+\t\t     but for the latter we need to disqualify all\n+\t\t     following refs.  */\n+\t\t  if (kind == sm_ord)\n+\t\t    {\n+\t\t      if (bitmap_set_bit (refs_not_supported, id))\n+\t\t\tchanged = true;\n+\t\t      seq->second[new_idx].second = sm_other;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      for (unsigned j = seq->second.length () - 1;\n+\t\t\t   j > new_idx; --j)\n+\t\t\tif (seq->second[j].second == sm_ord\n+\t\t\t    && bitmap_set_bit (refs_not_supported,\n+\t\t\t\t\t       seq->second[j].first))\n+\t\t\t  changed = true;\n+\t\t      seq->second.truncate (new_idx);\n+\t\t      break;\n+\t\t    }\n \t\t}\n \t    }\n \t}\n     }\n+  std::pair<edge, vec<seq_entry> > *seq;\n+  FOR_EACH_VEC_ELT (sms, i, seq)\n+    {\n+      /* Prune sm_other from the end.  */\n+      while (!seq->second.is_empty ()\n+\t     && seq->second.last ().second == sm_other)\n+\tseq->second.pop ();\n+      /* Prune duplicates from the start.  */\n+      auto_bitmap seen (&lim_bitmap_obstack);\n+      unsigned j, k;\n+      for (j = k = 0; j < seq->second.length (); ++j)\n+\tif (bitmap_set_bit (seen, seq->second[j].first))\n+\t  {\n+\t    if (k != j)\n+\t      seq->second[k] = seq->second[j];\n+\t    ++k;\n+\t  }\n+      seq->second.truncate (k);\n+      /* And verify.  */\n+      seq_entry *e;\n+      FOR_EACH_VEC_ELT (seq->second, j, e)\n+\tgcc_assert (e->second == sm_ord\n+\t\t    || (e->second == sm_other && e->from != NULL_TREE));\n+    }\n \n   /* Verify dependence for refs we cannot handle with the order preserving\n      code (refs_not_supported) or prune them from mem_refs.  */\n@@ -2540,7 +2619,7 @@ hoist_memory_references (class loop *loop, bitmap mem_refs,\n       /* We've now verified store order for ref with respect to all other\n \t stores in the loop does not matter.  */\n       else\n-\tunord_refs.safe_push (std::make_pair (i, sm_unord));\n+\tunord_refs.safe_push (seq_entry (i, sm_unord));\n     }\n \n   hash_map<im_mem_ref *, sm_aux *> aux_map;"}]}