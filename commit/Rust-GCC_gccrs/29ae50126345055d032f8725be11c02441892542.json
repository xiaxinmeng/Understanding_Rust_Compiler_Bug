{"sha": "29ae50126345055d032f8725be11c02441892542", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlhZTUwMTI2MzQ1MDU1ZDAzMmY4NzI1YmUxMWMwMjQ0MTg5MjU0Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-03-15T12:14:27Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-03-15T12:14:27Z"}, "message": "(eliminate_regs): Add STORING arg.\n\n(eliminate_regs, case SET): Pass that we are storing to recursive call.\n(eliminate_regs, case SUBREG): If storing and same number of words, use\nlarger mode.\n\nFrom-SVN: r13704", "tree": {"sha": "ca6ed6949fe93823c3a0e5ed64cad8239e50e239", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca6ed6949fe93823c3a0e5ed64cad8239e50e239"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29ae50126345055d032f8725be11c02441892542", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ae50126345055d032f8725be11c02441892542", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29ae50126345055d032f8725be11c02441892542", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ae50126345055d032f8725be11c02441892542/comments", "author": null, "committer": null, "parents": [{"sha": "abd268e28d3cfd7e581b5116ec9f50234c4d5cf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abd268e28d3cfd7e581b5116ec9f50234c4d5cf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abd268e28d3cfd7e581b5116ec9f50234c4d5cf9"}], "stats": {"total": 88, "additions": 50, "deletions": 38}, "files": [{"sha": "ad0f8f80588121d8bbac897ee52082556bd6995c", "filename": "gcc/reload1.c", "status": "modified", "additions": 50, "deletions": 38, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ae50126345055d032f8725be11c02441892542/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ae50126345055d032f8725be11c02441892542/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=29ae50126345055d032f8725be11c02441892542", "patch": "@@ -946,7 +946,7 @@ reload (first, global, dumpfile)\n       for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n \tif (reg_renumber[i] < 0 && reg_equiv_memory_loc[i])\n \t  {\n-\t    rtx x = eliminate_regs (reg_equiv_memory_loc[i], 0, NULL_RTX);\n+\t    rtx x = eliminate_regs (reg_equiv_memory_loc[i], 0, NULL_RTX, 0);\n \n \t    if (strict_memory_address_p (GET_MODE (regno_reg_rtx[i]),\n \t\t\t\t\t XEXP (x, 0)))\n@@ -2759,10 +2759,11 @@ static struct rtvec_def *old_asm_operands_vec, *new_asm_operands_vec;\n    the proper thing.  */\n \n rtx\n-eliminate_regs (x, mem_mode, insn)\n+eliminate_regs (x, mem_mode, insn, storing)\n      rtx x;\n      enum machine_mode mem_mode;\n      rtx insn;\n+     int storing;\n {\n   enum rtx_code code = GET_CODE (x);\n   struct elim_table *ep;\n@@ -2819,7 +2820,7 @@ eliminate_regs (x, mem_mode, insn)\n \t     reference to the pseudo.  Ensure we make a copy of the\n \t     address in case it is shared.  */\n \t  new = eliminate_regs (reg_equiv_memory_loc[regno],\n-\t\t\t\tmem_mode, insn);\n+\t\t\t\tmem_mode, insn, 0);\n \t  if (new != reg_equiv_memory_loc[regno])\n \t    {\n \t      cannot_omit_stores[regno] = 1;\n@@ -2881,8 +2882,8 @@ eliminate_regs (x, mem_mode, insn)\n \t reload.  This is the desired action.  */\n \n       {\n-\trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n-\trtx new1 = eliminate_regs (XEXP (x, 1), mem_mode, insn);\n+\trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, insn, 0);\n+\trtx new1 = eliminate_regs (XEXP (x, 1), mem_mode, insn, 0);\n \n \tif (new0 != XEXP (x, 0) || new1 != XEXP (x, 1))\n \t  {\n@@ -2953,9 +2954,9 @@ eliminate_regs (x, mem_mode, insn)\n     case GE:       case GT:       case GEU:    case GTU:\n     case LE:       case LT:       case LEU:    case LTU:\n       {\n-\trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n+\trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, insn, 0);\n \trtx new1\n-\t  = XEXP (x, 1) ? eliminate_regs (XEXP (x, 1), mem_mode, insn) : 0;\n+\t  = XEXP (x, 1) ? eliminate_regs (XEXP (x, 1), mem_mode, insn, 0) : 0;\n \n \tif (new0 != XEXP (x, 0) || new1 != XEXP (x, 1))\n \t  return gen_rtx (code, GET_MODE (x), new0, new1);\n@@ -2966,7 +2967,7 @@ eliminate_regs (x, mem_mode, insn)\n       /* If we have something in XEXP (x, 0), the usual case, eliminate it.  */\n       if (XEXP (x, 0))\n \t{\n-\t  new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n+\t  new = eliminate_regs (XEXP (x, 0), mem_mode, insn, 0);\n \t  if (new != XEXP (x, 0))\n \t    x = gen_rtx (EXPR_LIST, REG_NOTE_KIND (x), new, XEXP (x, 1));\n \t}\n@@ -2979,7 +2980,7 @@ eliminate_regs (x, mem_mode, insn)\n \t strictly needed, but it simplifies the code.  */\n       if (XEXP (x, 1))\n \t{\n-\t  new = eliminate_regs (XEXP (x, 1), mem_mode, insn);\n+\t  new = eliminate_regs (XEXP (x, 1), mem_mode, insn, 0);\n \t  if (new != XEXP (x, 1))\n \t    return gen_rtx (GET_CODE (x), GET_MODE (x), XEXP (x, 0), new);\n \t}\n@@ -3015,7 +3016,7 @@ eliminate_regs (x, mem_mode, insn)\n     case ABS:\n     case SQRT:\n     case FFS:\n-      new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n+      new = eliminate_regs (XEXP (x, 0), mem_mode, insn, 0);\n       if (new != XEXP (x, 0))\n \treturn gen_rtx (code, GET_MODE (x), new);\n       return x;\n@@ -3034,7 +3035,7 @@ eliminate_regs (x, mem_mode, insn)\n \t  && reg_equiv_memory_loc[REGNO (SUBREG_REG (x))] != 0)\n \t{\n \t  new = eliminate_regs (reg_equiv_memory_loc[REGNO (SUBREG_REG (x))],\n-\t\t\t\tmem_mode, insn);\n+\t\t\t\tmem_mode, insn, 0);\n \n \t  /* If we didn't change anything, we must retain the pseudo.  */\n \t  if (new == reg_equiv_memory_loc[REGNO (SUBREG_REG (x))])\n@@ -3054,27 +3055,37 @@ eliminate_regs (x, mem_mode, insn)\n \t    }\n \t}\n       else\n-\tnew = eliminate_regs (SUBREG_REG (x), mem_mode, insn);\n+\tnew = eliminate_regs (SUBREG_REG (x), mem_mode, insn, 0);\n \n       if (new != XEXP (x, 0))\n \t{\n-\t  if (GET_CODE (new) == MEM\n-\t      && (GET_MODE_SIZE (GET_MODE (x))\n-\t\t  <= GET_MODE_SIZE (GET_MODE (new)))\n+\t  int x_size = GET_MODE_SIZE (GET_MODE (x));\n+\t  int new_size = GET_MODE_SIZE (GET_MODE (new));\n+\n+\t  /* When asked to spill a partial word subreg, we need to go\n+\t     ahead and spill the whole thing against the possibility\n+\t     that we reload the whole reg and find garbage at the top.  */\n+\t  if (storing\n+\t      && GET_CODE (new) == MEM\n+\t      && x_size < new_size\n+\t      && ((x_size + UNITS_PER_WORD-1) / UNITS_PER_WORD\n+\t\t  == (new_size + UNITS_PER_WORD-1) / UNITS_PER_WORD))\n+\t    return new;\n+\t  else if (GET_CODE (new) == MEM\n+\t\t   && x_size <= new_size\n #ifdef LOAD_EXTEND_OP\n-\t      /* On these machines we will be reloading what is\n-\t\t inside the SUBREG if it originally was a pseudo and\n-\t\t the inner and outer modes are both a word or\n-\t\t smaller.  So leave the SUBREG then.  */\n-\t      && ! (GET_CODE (SUBREG_REG (x)) == REG\n-\t\t    && GET_MODE_SIZE (GET_MODE (x)) <= UNITS_PER_WORD\n-\t\t    && GET_MODE_SIZE (GET_MODE (new)) <= UNITS_PER_WORD\n-\t\t    && (GET_MODE_SIZE (GET_MODE (x))\n-\t\t\t> GET_MODE_SIZE (GET_MODE (new)))\n-\t\t    && INTEGRAL_MODE_P (GET_MODE (new))\n-\t\t    && LOAD_EXTEND_OP (GET_MODE (new)) != NIL)\n+\t           /* On these machines we will be reloading what is\n+\t\t      inside the SUBREG if it originally was a pseudo and\n+\t\t      the inner and outer modes are both a word or\n+\t\t      smaller.  So leave the SUBREG then.  */\n+\t           && ! (GET_CODE (SUBREG_REG (x)) == REG\n+\t\t         && x_size <= UNITS_PER_WORD\n+\t\t         && new_size <= UNITS_PER_WORD\n+\t\t         && x_size > new_size\n+\t\t         && INTEGRAL_MODE_P (GET_MODE (new))\n+\t\t         && LOAD_EXTEND_OP (GET_MODE (new)) != NIL)\n #endif\n-\t      )\n+\t           )\n \t    {\n \t      int offset = SUBREG_WORD (x) * UNITS_PER_WORD;\n \t      enum machine_mode mode = GET_MODE (x);\n@@ -3102,7 +3113,7 @@ eliminate_regs (x, mem_mode, insn)\n \tif (ep->from_rtx == XEXP (x, 0))\n \t  ep->can_eliminate = 0;\n \n-      new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n+      new = eliminate_regs (XEXP (x, 0), mem_mode, insn, 0);\n       if (new != XEXP (x, 0))\n \treturn gen_rtx (code, GET_MODE (x), new);\n       return x;\n@@ -3115,7 +3126,7 @@ eliminate_regs (x, mem_mode, insn)\n \tif (ep->to_rtx == XEXP (x, 0))\n \t  ep->can_eliminate = 0;\n \n-      new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n+      new = eliminate_regs (XEXP (x, 0), mem_mode, insn, 0);\n       if (new != XEXP (x, 0))\n \treturn gen_rtx (code, GET_MODE (x), new);\n       return x;\n@@ -3133,7 +3144,7 @@ eliminate_regs (x, mem_mode, insn)\n \t    temp_vec = (rtx *) alloca (XVECLEN (x, 3) * sizeof (rtx));\n \t    for (i = 0; i < ASM_OPERANDS_INPUT_LENGTH (x); i++)\n \t      temp_vec[i] = eliminate_regs (ASM_OPERANDS_INPUT (x, i),\n-\t\t\t\t\t    mem_mode, insn);\n+\t\t\t\t\t    mem_mode, insn, 0);\n \n \t    for (i = 0; i < ASM_OPERANDS_INPUT_LENGTH (x); i++)\n \t      if (temp_vec[i] != ASM_OPERANDS_INPUT (x, i))\n@@ -3204,8 +3215,8 @@ eliminate_regs (x, mem_mode, insn)\n \n       /* Now avoid the loop below in this common case.  */\n       {\n-\trtx new0 = eliminate_regs (SET_DEST (x), 0, insn);\n-\trtx new1 = eliminate_regs (SET_SRC (x), 0, insn);\n+\trtx new0 = eliminate_regs (SET_DEST (x), 0, insn, 1);\n+\trtx new1 = eliminate_regs (SET_SRC (x), 0, insn, 0);\n \n \t/* If SET_DEST changed from a REG to a MEM and INSN is an insn,\n \t   write a CLOBBER insn.  */\n@@ -3224,7 +3235,7 @@ eliminate_regs (x, mem_mode, insn)\n       /* Our only special processing is to pass the mode of the MEM to our\n \t recursive call and copy the flags.  While we are here, handle this\n \t case more efficiently.  */\n-      new = eliminate_regs (XEXP (x, 0), GET_MODE (x), insn);\n+      new = eliminate_regs (XEXP (x, 0), GET_MODE (x), insn, 0);\n       if (new != XEXP (x, 0))\n \t{\n \t  new = gen_rtx (MEM, GET_MODE (x), new);\n@@ -3244,7 +3255,7 @@ eliminate_regs (x, mem_mode, insn)\n     {\n       if (*fmt == 'e')\n \t{\n-\t  new = eliminate_regs (XEXP (x, i), mem_mode, insn);\n+\t  new = eliminate_regs (XEXP (x, i), mem_mode, insn, 0);\n \t  if (new != XEXP (x, i) && ! copied)\n \t    {\n \t      rtx new_x = rtx_alloc (code);\n@@ -3261,7 +3272,7 @@ eliminate_regs (x, mem_mode, insn)\n \t  int copied_vec = 0;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    {\n-\t      new = eliminate_regs (XVECEXP (x, i, j), mem_mode, insn);\n+\t      new = eliminate_regs (XVECEXP (x, i, j), mem_mode, insn, 0);\n \t      if (new != XVECEXP (x, i, j) && ! copied_vec)\n \t\t{\n \t\t  rtvec new_v = gen_rtvec_vv (XVECLEN (x, i),\n@@ -3439,7 +3450,7 @@ eliminate_regs_in_insn (insn, replace)\n      but now can do this as a load-address.  This saves an insn in this\n      common case.  */\n \n-  new_body = eliminate_regs (old_body, 0, replace ? insn : NULL_RTX);\n+  new_body = eliminate_regs (old_body, 0, replace ? insn : NULL_RTX, 0);\n   if (new_body != old_body)\n     {\n       /* If we aren't replacing things permanently and we changed something,\n@@ -3528,7 +3539,7 @@ eliminate_regs_in_insn (insn, replace)\n      of spill registers to be needed in the final reload pass than in\n      the pre-passes.  */\n   if (val && REG_NOTES (insn) != 0)\n-    REG_NOTES (insn) = eliminate_regs (REG_NOTES (insn), 0, REG_NOTES (insn));\n+    REG_NOTES (insn) = eliminate_regs (REG_NOTES (insn), 0, REG_NOTES (insn), 0);\n \n   if (! replace)\n     pop_obstacks ();\n@@ -4006,7 +4017,8 @@ reload_as_needed (first, live_known)\n \t      && GET_CODE (XEXP (PATTERN (insn), 0)) == MEM)\n \t    XEXP (XEXP (PATTERN (insn), 0), 0)\n \t      = eliminate_regs (XEXP (XEXP (PATTERN (insn), 0), 0),\n-\t\t\t\tGET_MODE (XEXP (PATTERN (insn), 0)), NULL_RTX);\n+\t\t\t\tGET_MODE (XEXP (PATTERN (insn), 0)),\n+\t\t\t\tNULL_RTX, 0);\n \n \t  /* If we need to do register elimination processing, do so.\n \t     This might delete the insn, in which case we are done.  */"}]}