{"sha": "a45035b6ed1dacd448413747b09991e4c58e5e9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ1MDM1YjZlZDFkYWNkNDQ4NDEzNzQ3YjA5OTkxZTRjNThlNWU5ZA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-08-31T20:30:12Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-08-31T20:30:12Z"}, "message": "(assign_stack_temp): When allocate a slot too large,\n\nsplit extra off into a slot of its own.\n(combine_temp_slots): New function.\n(free_temp_slots, pop_temp_slots): Call combine_temp_slots.\n\nFrom-SVN: r5232", "tree": {"sha": "09d6044f42491568c72952db3c14f8e4f91a5118", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09d6044f42491568c72952db3c14f8e4f91a5118"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a45035b6ed1dacd448413747b09991e4c58e5e9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a45035b6ed1dacd448413747b09991e4c58e5e9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a45035b6ed1dacd448413747b09991e4c58e5e9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a45035b6ed1dacd448413747b09991e4c58e5e9d/comments", "author": null, "committer": null, "parents": [{"sha": "9d7877e3c8510fddcefe25d72fdf913016634c19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d7877e3c8510fddcefe25d72fdf913016634c19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d7877e3c8510fddcefe25d72fdf913016634c19"}], "stats": {"total": 72, "additions": 71, "deletions": 1}, "files": [{"sha": "4a0425a83e9c8c9e873e4efa1afb61138269e805", "filename": "gcc/function.c", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a45035b6ed1dacd448413747b09991e4c58e5e9d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a45035b6ed1dacd448413747b09991e4c58e5e9d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a45035b6ed1dacd448413747b09991e4c58e5e9d", "patch": "@@ -715,7 +715,36 @@ assign_stack_temp (mode, size, keep)\n \n   /* Make our best, if any, the one to use.  */\n   if (best_p)\n-    p = best_p;\n+    {\n+      /* If there are enough aligned bytes left over, make them into a new\n+\t temp_slot so that the extra bytes don't get wasted.  Do this only\n+\t for BLKmode slots, so that we can be sure of the alignment.  */\n+      if (GET_MODE (best_p->slot) == BLKmode)\n+\t{\n+\t  int alignment = BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n+\t  int rounded_size = CEIL_ROUND (size, alignment);\n+\n+\t  if (best_p->size - rounded_size >= alignment)\n+\t    {\n+\t      p = (struct temp_slot *) oballoc (sizeof (struct temp_slot));\n+\t      p->in_use = 0;\n+\t      p->size = best_p->size - rounded_size;\n+\t      p->slot = gen_rtx (MEM, BLKmode,\n+\t\t\t\t plus_constant (XEXP (best_p->slot, 0),\n+\t\t\t\t\t\trounded_size));\n+\t      p->next = temp_slots;\n+\t      temp_slots = p;\n+\n+\t      stack_slot_list = gen_rtx (EXPR_LIST, VOIDmode, p->slot,\n+\t\t\t\t\t stack_slot_list);\n+\n+\t      best_p->size = rounded_size;\n+\t    }\n+\t}\n+\n+      p = best_p;\n+    }\n+\t      \n \n   /* If we still didn't find one, make a new temporary.  */\n   if (p == 0)\n@@ -734,6 +763,43 @@ assign_stack_temp (mode, size, keep)\n   p->keep = keep;\n   return p->slot;\n }\n+\n+/* Combine temporary stack slots which are adjacent on the stack.\n+\n+   This allows for better use of already allocated stack space.  This is only\n+   done for BLKmode slots because we can be sure that we won't have alignment\n+   problems in this case.  */\n+\n+void\n+combine_temp_slots ()\n+{\n+  struct temp_slot *p, *q;\n+  struct temp_slot *prev_p, *prev_q;\n+\n+  for (p = temp_slots, prev_p = 0; p; prev_p = p, p = p->next)\n+    if (! p->in_use && GET_MODE (p->slot) == BLKmode)\n+      for (q = p->next, prev_q = p; q; prev_q = q, q = q->next)\n+\tif (! q->in_use && GET_MODE (q->slot) == BLKmode)\n+\t  {\n+\t    if (rtx_equal_p (plus_constant (XEXP (p->slot, 0), p->size),\n+\t\t\t     XEXP (q->slot, 0)))\n+\t      {\n+\t\t/* Combine q into p.  */\n+\t\tp->size += q->size;\n+\t\tprev_q->next = q->next;\n+\t      }\n+\t    else if (rtx_equal_p (plus_constant (XEXP (q->slot, 0), q->size),\n+\t\t\t\t  XEXP (p->slot, 0)))\n+\t      {\n+\t\t/* Combine p into q.  */\n+\t\tq->size += p->size;\n+\t\tif (prev_p)\n+\t\t  prev_p->next = p->next;\n+\t\telse\n+\t\t  temp_slots = p->next;\n+\t      }\n+\t  }\n+}\n \f\n /* If X could be a reference to a temporary slot, mark that slot as belonging\n    to the to one level higher.  If X matched one of our slots, just mark that\n@@ -779,6 +845,8 @@ free_temp_slots ()\n   for (p = temp_slots; p; p = p->next)\n     if (p->in_use && p->level == temp_slot_level && ! p->keep)\n       p->in_use = 0;\n+\n+  combine_temp_slots ();\n }\n \n /* Push deeper into the nesting level for stack temporaries.  */\n@@ -814,6 +882,8 @@ pop_temp_slots ()\n     if (p->in_use && p->level == temp_slot_level)\n       p->in_use = 0;\n \n+  combine_temp_slots ();\n+\n   temp_slot_level--;\n }\n \f"}]}