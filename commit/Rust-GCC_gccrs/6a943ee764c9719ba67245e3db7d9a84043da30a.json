{"sha": "6a943ee764c9719ba67245e3db7d9a84043da30a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE5NDNlZTc2NGM5NzE5YmE2NzI0NWUzZGI3ZDlhODQwNDNkYTMwYQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-03-12T22:00:52Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-03-12T22:00:52Z"}, "message": "re PR fortran/43291 ([OOP] Type mismatch in argument; passed CLASS(t1) to CLASS(t2))\n\n2010-03-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/43291\n\tPR fortran/43326\n\t* resolve.c (resolve_compcall): Add new boolean dummy argument\n\t'class_members'. Only resolve expression at end if false.\n\tRemove redundant, static variable 'class_object'.\n\t(check_class_members): Add extra argument to call of\n\tresolve_compcall.\n\t(resolve_typebound_function): Renamed resolve_class_compcall.\n\tDo all the detection of class references here. Correct calls to\n\tresolve_compcall for extra argument.\n\t(resolve_typebound_subroutine): resolve_class_typebound_call\n\trenamed. Otherwise same as resolve_typebound_function.\n\t(gfc_resolve_expr): Call resolve_typebound_function.\n\t(resolve_code): Call resolve_typebound_subroutine.\n\n2010-03-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/43291\n\tPR fortran/43326\n\t* gfortran.dg/dynamic_dispatch_7.f03: New test.\n\nFrom-SVN: r157411", "tree": {"sha": "4da09ecc18dc44b9841a498d42901e7f648b87dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4da09ecc18dc44b9841a498d42901e7f648b87dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a943ee764c9719ba67245e3db7d9a84043da30a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a943ee764c9719ba67245e3db7d9a84043da30a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a943ee764c9719ba67245e3db7d9a84043da30a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a943ee764c9719ba67245e3db7d9a84043da30a/comments", "author": null, "committer": null, "parents": [{"sha": "9c8cab4478ead482a1b758ba5155fc13cfd460f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c8cab4478ead482a1b758ba5155fc13cfd460f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c8cab4478ead482a1b758ba5155fc13cfd460f5"}], "stats": {"total": 143, "additions": 117, "deletions": 26}, "files": [{"sha": "9fd831dbd7c42235fb99b5e919002e5b143a7917", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a943ee764c9719ba67245e3db7d9a84043da30a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a943ee764c9719ba67245e3db7d9a84043da30a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6a943ee764c9719ba67245e3db7d9a84043da30a", "patch": "@@ -1,3 +1,20 @@\n+2010-03-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/43291\n+\tPR fortran/43326\n+\t* resolve.c (resolve_compcall): Add new boolean dummy argument\n+\t'class_members'. Only resolve expression at end if false.\n+\tRemove redundant, static variable 'class_object'.\n+\t(check_class_members): Add extra argument to call of\n+\tresolve_compcall.\n+\t(resolve_typebound_function): Renamed resolve_class_compcall.\n+\tDo all the detection of class references here. Correct calls to\n+\tresolve_compcall for extra argument.\n+\t(resolve_typebound_subroutine): resolve_class_typebound_call\n+\trenamed. Otherwise same as resolve_typebound_function.\n+\t(gfc_resolve_expr): Call resolve_typebound_function.\n+\t(resolve_code): Call resolve_typebound_subroutine.\n+\n 2010-03-10  Tobias Burnus  <burnus@net-b.de\n \n \tPR fortran/43303"}, {"sha": "9a95d3405a08d1f7a8eb39295c7e635d7c0612b9", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a943ee764c9719ba67245e3db7d9a84043da30a/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a943ee764c9719ba67245e3db7d9a84043da30a/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=6a943ee764c9719ba67245e3db7d9a84043da30a", "patch": "@@ -5082,7 +5082,7 @@ resolve_typebound_call (gfc_code* c)\n    resolving subroutine class methods, since we do not have to add a\n    gfc_code each time. */\n static gfc_try\n-resolve_compcall (gfc_expr* e, bool fcn)\n+resolve_compcall (gfc_expr* e, bool fcn, bool class_members)\n {\n   gfc_actual_arglist* newactual;\n   gfc_symtree* target;\n@@ -5132,10 +5132,10 @@ resolve_compcall (gfc_expr* e, bool fcn)\n   e->ts = target->n.sym->ts;\n   e->expr_type = EXPR_FUNCTION;\n \n-  /* Resolution is not necessary if this is a class subroutine; this\n-     function only has to identify the specific proc. Resolution of\n-     the call will be done next in resolve_typebound_call.  */\n-  return fcn ? gfc_resolve_expr (e) : SUCCESS;\n+  /* Resolution is not necessary when constructing component calls\n+     for class members, since this must only be done for the\n+     declared type, which is done afterwards.  */\n+  return !class_members ? gfc_resolve_expr (e) : SUCCESS;\n }\n \n \n@@ -5147,7 +5147,6 @@ static gfc_expr *list_e;\n static void check_class_members (gfc_symbol *);\n static gfc_try class_try;\n static bool fcn_flag;\n-static gfc_symbol *class_object;\n \n \n static void\n@@ -5202,7 +5201,7 @@ check_class_members (gfc_symbol *derived)\n \n   /* Do the renaming, PASSing, generic => specific and other\n      good things for each class member.  */\n-  class_try = (resolve_compcall (e, fcn_flag) == SUCCESS)\n+  class_try = (resolve_compcall (e, fcn_flag, true) == SUCCESS)\n \t\t\t\t? class_try : FAILURE;\n \n   /* Now transfer the found symbol to the esym list.  */\n@@ -5337,26 +5336,32 @@ resolve_arg_exprs (gfc_actual_arglist *arg)\n }\n \n \n-/* Resolve a CLASS typebound function, or 'method'.  */\n+/* Resolve a typebound function, or 'method'.  First separate all\n+   the non-CLASS references by calling resolve_compcall directly.\n+   Then treat the CLASS references by resolving for each of the class\n+   members in turn.  */\n+\n static gfc_try\n-resolve_class_compcall (gfc_expr* e)\n+resolve_typebound_function (gfc_expr* e)\n {\n   gfc_symbol *derived, *declared;\n   gfc_ref *new_ref;\n   gfc_ref *class_ref;\n   gfc_symtree *st;\n \n   st = e->symtree;\n-  class_object = st->n.sym;\n+  if (st == NULL)\n+    return resolve_compcall (e, true, false);\n \n   /* Get the CLASS declared type.  */\n   declared = get_declared_from_expr (&class_ref, &new_ref, e);\n \n   /* Weed out cases of the ultimate component being a derived type.  */\n-  if (class_ref && class_ref->u.c.component->ts.type == BT_DERIVED)\n+  if ((class_ref && class_ref->u.c.component->ts.type == BT_DERIVED)\n+\t|| (!class_ref && st->n.sym->ts.type != BT_CLASS))\n     {\n       gfc_free_ref_list (new_ref);\n-      return resolve_compcall (e, true);\n+      return resolve_compcall (e, true, false);\n     }\n \n   /* Resolve the argument expressions,  */\n@@ -5371,7 +5376,7 @@ resolve_class_compcall (gfc_expr* e)\n   list_e = gfc_copy_expr (e);\n   check_class_members (derived);\n \n-  class_try = (resolve_compcall (e, true) == SUCCESS)\n+  class_try = (resolve_compcall (e, true, false) == SUCCESS)\n \t\t ? class_try : FAILURE;\n \n   /* Transfer the class list to the original expression.  Note that\n@@ -5392,23 +5397,29 @@ resolve_class_compcall (gfc_expr* e)\n   return class_try;\n }\n \n-/* Resolve a CLASS typebound subroutine, or 'method'.  */\n+/* Resolve a typebound subroutine, or 'method'.  First separate all\n+   the non-CLASS references by calling resolve_typebound_call directly.\n+   Then treat the CLASS references by resolving for each of the class\n+   members in turn.  */\n+\n static gfc_try\n-resolve_class_typebound_call (gfc_code *code)\n+resolve_typebound_subroutine (gfc_code *code)\n {\n   gfc_symbol *derived, *declared;\n   gfc_ref *new_ref;\n   gfc_ref *class_ref;\n   gfc_symtree *st;\n \n   st = code->expr1->symtree;\n-  class_object = st->n.sym;\n+  if (st == NULL)\n+    return resolve_typebound_call (code);\n \n   /* Get the CLASS declared type.  */\n   declared = get_declared_from_expr (&class_ref, &new_ref, code->expr1);\n \n   /* Weed out cases of the ultimate component being a derived type.  */\n-  if (class_ref && class_ref->u.c.component->ts.type == BT_DERIVED)\n+  if ((class_ref && class_ref->u.c.component->ts.type == BT_DERIVED)\n+\t|| (!class_ref && st->n.sym->ts.type != BT_CLASS))\n     {\n       gfc_free_ref_list (new_ref);\n       return resolve_typebound_call (code);\n@@ -5584,10 +5595,7 @@ gfc_resolve_expr (gfc_expr *e)\n       break;\n \n     case EXPR_COMPCALL:\n-      if (e->symtree && e->symtree->n.sym->ts.type == BT_CLASS)\n-\tt = resolve_class_compcall (e);\n-      else\n-\tt = resolve_compcall (e, true);\n+      t = resolve_typebound_function (e);\n       break;\n \n     case EXPR_SUBSTRING:\n@@ -8150,11 +8158,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \n \tcase EXEC_COMPCALL:\n \tcompcall:\n-\t  if (code->expr1->symtree\n-\t\t&& code->expr1->symtree->n.sym->ts.type == BT_CLASS)\n-\t    resolve_class_typebound_call (code);\n-\t  else\n-\t    resolve_typebound_call (code);\n+\t  resolve_typebound_subroutine (code);\n \t  break;\n \n \tcase EXEC_CALL_PPC:"}, {"sha": "5db28bd9bcf7d90072cd5dd380df68c59dbae13e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a943ee764c9719ba67245e3db7d9a84043da30a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a943ee764c9719ba67245e3db7d9a84043da30a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6a943ee764c9719ba67245e3db7d9a84043da30a", "patch": "@@ -1,3 +1,9 @@\n+2010-03-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/43291\n+\tPR fortran/43326\n+\t* gfortran.dg/dynamic_dispatch_7.f03: New test.\n+\n 2010-03-12  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* gfortran.dg/default_format_denormal_1.f90: Don't assume"}, {"sha": "a84d9f9c483a704b7b5ec0503b43e9f0a112890b", "filename": "gcc/testsuite/gfortran.dg/dynamic_dispatch_7.f03", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a943ee764c9719ba67245e3db7d9a84043da30a/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a943ee764c9719ba67245e3db7d9a84043da30a/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdynamic_dispatch_7.f03?ref=6a943ee764c9719ba67245e3db7d9a84043da30a", "patch": "@@ -0,0 +1,64 @@\n+! { dg-do run }\n+! Test the fix for PR43291, which was a regression that caused\n+! incorrect type mismatch errors at line 46. In the course of\n+! fixing the PR, it was noted that the dynamic dispatch of the\n+! final typebound call was not occurring - hence the dg-do run.\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+!\n+module m1\n+  type  :: t1\n+  contains \n+    procedure :: sizeof\n+  end type\n+contains\n+  integer function sizeof(a)\n+    class(t1) :: a\n+    sizeof = 1\n+  end function sizeof\n+end module\n+\n+\n+module m2\n+  use m1\n+  type, extends(t1) :: t2    \n+  contains\n+    procedure :: sizeof => sizeof2\n+  end type\n+contains\n+  integer function sizeof2(a)\n+    class(t2) :: a\n+    sizeof2 = 2\n+  end function\n+end module\n+\n+\n+module m3\n+  use m2\n+  type :: t3\n+    class(t1), pointer  :: a \n+  contains\n+    procedure :: sizeof => sizeof3\n+  end type\n+contains \n+  integer function sizeof3(a)\n+    class(t3) :: a\n+    sizeof3 = a%a%sizeof()\n+  end function \n+end module\n+\n+  use m1\n+  use m2\n+  use m3\n+  type(t1), target :: x\n+  type(t2), target :: y\n+  type(t3) :: z\n+  z%a => x\n+  if ((z%sizeof() .ne. 1) .or. (z%a%sizeof() .ne. 1)) call abort\n+  z%a => y\n+  if ((z%sizeof() .ne. 2) .or. (z%a%sizeof() .ne. 2)) call abort\n+\n+end\n+\n+! { dg-final { cleanup-modules \"m1 m2 m3\" } }\n+"}]}