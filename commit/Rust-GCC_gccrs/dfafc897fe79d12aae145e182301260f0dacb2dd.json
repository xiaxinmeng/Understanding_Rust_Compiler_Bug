{"sha": "dfafc897fe79d12aae145e182301260f0dacb2dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZhZmM4OTdmZTc5ZDEyYWFlMTQ1ZTE4MjMwMTI2MGYwZGFjYjJkZA==", "commit": {"author": {"name": "Franz Sirl", "email": "Franz.Sirl-kernel@lauterbach.com", "date": "1999-08-02T20:40:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-08-02T20:40:56Z"}, "message": "Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n\n        * rs6000.c (rs6000_va_list): Type is an array.\n        (rs6000_va_start): Don't doubly adjust for varargs.\n        (rs6000_va_arg): Evaluate long long GPR adjustment.\n\nFrom-SVN: r28408", "tree": {"sha": "0948ea6b7c9abfa49c0aaa57a2584a7e416ecd61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0948ea6b7c9abfa49c0aaa57a2584a7e416ecd61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfafc897fe79d12aae145e182301260f0dacb2dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfafc897fe79d12aae145e182301260f0dacb2dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfafc897fe79d12aae145e182301260f0dacb2dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfafc897fe79d12aae145e182301260f0dacb2dd/comments", "author": {"login": "jinkama-san", "id": 1462162, "node_id": "MDQ6VXNlcjE0NjIxNjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1462162?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jinkama-san", "html_url": "https://github.com/jinkama-san", "followers_url": "https://api.github.com/users/jinkama-san/followers", "following_url": "https://api.github.com/users/jinkama-san/following{/other_user}", "gists_url": "https://api.github.com/users/jinkama-san/gists{/gist_id}", "starred_url": "https://api.github.com/users/jinkama-san/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jinkama-san/subscriptions", "organizations_url": "https://api.github.com/users/jinkama-san/orgs", "repos_url": "https://api.github.com/users/jinkama-san/repos", "events_url": "https://api.github.com/users/jinkama-san/events{/privacy}", "received_events_url": "https://api.github.com/users/jinkama-san/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "54dd04be06071998c00b0c66e881e8cd3f774d92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54dd04be06071998c00b0c66e881e8cd3f774d92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54dd04be06071998c00b0c66e881e8cd3f774d92"}], "stats": {"total": 354, "additions": 264, "deletions": 90}, "files": [{"sha": "4533f3931addea3a77a9df06fac800102d1f58d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfafc897fe79d12aae145e182301260f0dacb2dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfafc897fe79d12aae145e182301260f0dacb2dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dfafc897fe79d12aae145e182301260f0dacb2dd", "patch": "@@ -1,3 +1,9 @@\n+1999-08-02  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n+\n+\t* rs6000.c (rs6000_va_list): Type is an array.\n+\t(rs6000_va_start): Don't doubly adjust for varargs.\n+\t(rs6000_va_arg): Evaluate long long GPR adjustment.\n+\n Mon Aug  2 16:15:57 1999  David Edelsohn  <edelsohn@gnu.org>\n \n \t* rs6000/aix43.h (SUBTARGET_SWITCHES): Use -m64 and -m32 instead of"}, {"sha": "865ec9254e61e1713383fb4d0d57e4d4da4d89e0", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 245, "deletions": 82, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfafc897fe79d12aae145e182301260f0dacb2dd/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfafc897fe79d12aae145e182301260f0dacb2dd/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=dfafc897fe79d12aae145e182301260f0dacb2dd", "patch": "@@ -31,9 +31,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-attr.h\"\n #include \"flags.h\"\n #include \"recog.h\"\n-#include \"expr.h\"\n #include \"obstack.h\"\n #include \"tree.h\"\n+#include \"expr.h\"\n #include \"except.h\"\n #include \"function.h\"\n #include \"output.h\"\n@@ -1678,8 +1678,8 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n {\n   CUMULATIVE_ARGS next_cum;\n   int reg_size = TARGET_32BIT ? 4 : 8;\n-  rtx save_area;\n-  int first_reg_offset;\n+  rtx save_area, mem;\n+  int first_reg_offset, set;\n \n   if (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n     {\n@@ -1717,12 +1717,16 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n \tfirst_reg_offset += RS6000_ARG_SIZE (TYPE_MODE (type), type, 1);\n     }\n \n+  set = get_varargs_alias_set ();\n   if (!no_rtl && first_reg_offset < GP_ARG_NUM_REG)\n     {\n+      mem = gen_rtx_MEM (BLKmode,\n+\t\t         plus_constant (save_area,\n+\t\t\t\t\tfirst_reg_offset * reg_size)),\n+      MEM_ALIAS_SET (mem) = set;\n+\n       move_block_from_reg\n-\t(GP_ARG_MIN_REG + first_reg_offset,\n-\t gen_rtx_MEM (BLKmode,\n-\t\t      plus_constant (save_area, first_reg_offset * reg_size)),\n+\t(GP_ARG_MIN_REG + first_reg_offset, mem,\n \t GP_ARG_NUM_REG - first_reg_offset,\n \t (GP_ARG_NUM_REG - first_reg_offset) * UNITS_PER_WORD);\n \n@@ -1750,106 +1754,265 @@ setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n \n       while (fregno <= FP_ARG_V4_MAX_REG)\n \t{\n-\t  emit_move_insn (gen_rtx_MEM (DFmode, plus_constant (save_area, off)),\n-\t\t\t  gen_rtx_REG (DFmode, fregno));\n+\t  mem = gen_rtx_MEM (DFmode, plus_constant (save_area, off));\n+          MEM_ALIAS_SET (mem) = set;\n+\t  emit_move_insn (mem, gen_rtx_REG (DFmode, fregno));\n \t  fregno++;\n \t  off += 8;\n \t}\n \n       emit_label (lab);\n     }\n }\n-\f\n-/* If defined, is a C expression that produces the machine-specific\n-   code for a call to `__builtin_saveregs'.  This code will be moved\n-   to the very beginning of the function, before any parameter access\n-   are made.  The return value of this function should be an RTX that\n-   contains the value to use as the return of `__builtin_saveregs'.\n \n-   On the Power/PowerPC return the address of the area on the stack\n-   used to hold arguments.  Under AIX, this includes the 8 word register\n-   save area. \n+/* Create the va_list data type.  */\n \n-   Under V.4, things are more complicated.  We do not have access to\n-   all of the virtual registers required for va_start to do its job,\n-   so we construct the va_list in its entirity here, and reduce va_start\n-   to a block copy.  This is similar to the way we do things on Alpha.  */\n+tree\n+rs6000_build_va_list ()\n+{\n+  tree f_gpr, f_fpr, f_ovf, f_sav, record;\n+  tree uchar_type_node;\n \n-struct rtx_def *\n-rs6000_expand_builtin_saveregs ()\n+  /* Only SVR4 needs something special.  */\n+  if (DEFAULT_ABI != ABI_V4 && DEFAULT_ABI != ABI_SOLARIS)\n+    return ptr_type_node;\n+\n+  record = make_node (RECORD_TYPE);\n+  uchar_type_node = make_unsigned_type (CHAR_TYPE_SIZE);\n+  \n+  f_gpr = build_decl (FIELD_DECL, get_identifier (\"gpr\"), uchar_type_node);\n+  f_fpr = build_decl (FIELD_DECL, get_identifier (\"fpr\"), uchar_type_node);\n+  f_ovf = build_decl (FIELD_DECL, get_identifier (\"overflow_arg_area\"),\n+\t\t      ptr_type_node);\n+  f_sav = build_decl (FIELD_DECL, get_identifier (\"reg_save_area\"),\n+\t\t      ptr_type_node);\n+\n+  DECL_FIELD_CONTEXT (f_gpr) = record;\n+  DECL_FIELD_CONTEXT (f_fpr) = record;\n+  DECL_FIELD_CONTEXT (f_ovf) = record;\n+  DECL_FIELD_CONTEXT (f_sav) = record;\n+\n+  TYPE_FIELDS (record) = f_gpr;\n+  TREE_CHAIN (f_gpr) = f_fpr;\n+  TREE_CHAIN (f_fpr) = f_ovf;\n+  TREE_CHAIN (f_ovf) = f_sav;\n+\n+  layout_type (record);\n+\n+  /* The correct type is an array type of one element.  */\n+  return build_array_type (record, build_index_type (size_zero_node));\n+}\n+\n+/* Implement va_start.  */\n+\n+void\n+rs6000_va_start (stdarg_p, valist, nextarg)\n+     int stdarg_p;\n+     tree valist;\n+     rtx nextarg;\n {\n-  rtx block, mem_gpr_fpr, mem_reg_save_area, mem_overflow, tmp;\n-  tree fntype;\n-  int stdarg_p;\n-  HOST_WIDE_INT words, gpr, fpr;\n+  HOST_WIDE_INT words, n_gpr, n_fpr;\n+  tree f_gpr, f_fpr, f_ovf, f_sav;\n+  tree gpr, fpr, ovf, sav, t;\n \n+  /* Only SVR4 needs something special.  */\n   if (DEFAULT_ABI != ABI_V4 && DEFAULT_ABI != ABI_SOLARIS)\n-    return virtual_incoming_args_rtx;\n-\n-  fntype = TREE_TYPE (current_function_decl);\n-  stdarg_p = (TYPE_ARG_TYPES (fntype) != 0\n-\t      && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n-\t\t  != void_type_node));\n-\n-  /* Allocate the va_list constructor.  */\n-  block = assign_stack_local (BLKmode, 3 * UNITS_PER_WORD, BITS_PER_WORD);\n-  RTX_UNCHANGING_P (block) = 1;\n-  RTX_UNCHANGING_P (XEXP (block, 0)) = 1;\n-\n-  mem_gpr_fpr = change_address (block, word_mode, XEXP (block, 0));\n-  mem_overflow = change_address (block, ptr_mode, \n-\t\t\t         plus_constant (XEXP (block, 0),\n-\t\t\t\t\t\tUNITS_PER_WORD));\n-  mem_reg_save_area = change_address (block, ptr_mode, \n-\t\t\t\t      plus_constant (XEXP (block, 0),\n-\t\t\t\t\t\t     2 * UNITS_PER_WORD));\n-\n-  /* Construct the two characters of `gpr' and `fpr' as a unit.  */\n+    {\n+      std_expand_builtin_va_start (stdarg_p, valist, nextarg);\n+      return;\n+    }\n+\n+  f_gpr = TYPE_FIELDS (va_list_type_node);\n+  f_fpr = TREE_CHAIN (f_gpr);\n+  f_ovf = TREE_CHAIN (f_fpr);\n+  f_sav = TREE_CHAIN (f_ovf);\n+\n+  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n+  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n+  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf);\n+  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n+\n+  /* Count number of gp and fp argument registers used.  */\n   words = current_function_args_info.words;\n-  gpr = current_function_args_info.sysv_gregno - GP_ARG_MIN_REG;\n-  fpr = current_function_args_info.fregno - FP_ARG_MIN_REG;\n+  n_gpr = current_function_args_info.sysv_gregno - GP_ARG_MIN_REG;\n+  n_fpr = current_function_args_info.fregno - FP_ARG_MIN_REG;\n+\n+  if (TARGET_DEBUG_ARG)\n+    fprintf (stderr, \"va_start: words = %d, n_gpr = %d, n_fpr = %d\\n\",\n+\t     words, n_gpr, n_fpr);\n+\n+  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr, build_int_2 (n_gpr, 0));\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr, build_int_2 (n_fpr, 0));\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  /* Find the overflow area.  */\n+  t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);\n+  if (words != 0)\n+    t = build (PLUS_EXPR, TREE_TYPE (ovf), t,\n+\t       build_int_2 (words * UNITS_PER_WORD, 0));\n+  t = build (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  /* Find the register save area.  */\n+  t = make_tree (TREE_TYPE (sav), virtual_stack_vars_rtx);\n+  t = build (PLUS_EXPR, TREE_TYPE (sav), t,\n+\t     build_int_2 (-RS6000_VARARGS_SIZE, -1));\n+  t = build (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+}\n+\n+/* Implement va_arg.  */\n+\n+rtx\n+rs6000_va_arg (valist, type)\n+     tree valist, type;\n+{\n+  tree f_gpr, f_fpr, f_ovf, f_sav;\n+  tree gpr, fpr, ovf, sav, reg, t, u;\n+  int indirect_p, size, rsize, n_reg, sav_ofs, sav_scale;\n+  rtx lab_false, lab_over, addr_rtx, r;\n+\n+  /* Only SVR4 needs something special.  */\n+  if (DEFAULT_ABI != ABI_V4 && DEFAULT_ABI != ABI_SOLARIS)\n+    return std_expand_builtin_va_arg (valist, type);\n+\n+  f_gpr = TYPE_FIELDS (va_list_type_node);\n+  f_fpr = TREE_CHAIN (f_gpr);\n+  f_ovf = TREE_CHAIN (f_fpr);\n+  f_sav = TREE_CHAIN (f_ovf);\n+\n+  gpr = build (COMPONENT_REF, TREE_TYPE (f_gpr), valist, f_gpr);\n+  fpr = build (COMPONENT_REF, TREE_TYPE (f_fpr), valist, f_fpr);\n+  ovf = build (COMPONENT_REF, TREE_TYPE (f_ovf), valist, f_ovf);\n+  sav = build (COMPONENT_REF, TREE_TYPE (f_sav), valist, f_sav);\n \n-  /* Varargs has the va_dcl argument, but we don't count it.  */\n-  if (!stdarg_p)\n+  size = int_size_in_bytes (type);\n+  rsize = (size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  if (AGGREGATE_TYPE_P (type) || TYPE_MODE (type) == TFmode)\n     {\n-      if (gpr > GP_ARG_NUM_REG)\n-        words -= 1;\n-      else\n-        gpr -= 1;\n+      /* Aggregates and long doubles are passed by reference.  */\n+      indirect_p = 1;\n+      reg = gpr;\n+      n_reg = 1;\n+      sav_ofs = 0;\n+      sav_scale = 4;\n+      size = rsize = UNITS_PER_WORD;\n     }\n+  else if (FLOAT_TYPE_P (type) && ! TARGET_SOFT_FLOAT)\n+    {\n+      /* FP args go in FP registers, if present.  */\n+      indirect_p = 0;\n+      reg = fpr;\n+      n_reg = 1;\n+      sav_ofs = 8*4;\n+      sav_scale = 8;\n+    }\n+  else\n+    {\n+      /* Otherwise into GP registers.  */\n+      indirect_p = 0;\n+      reg = gpr;\n+      n_reg = rsize;\n+      sav_ofs = 0;\n+      sav_scale = 4;\n+    }\n+\n+  /*\n+   * Pull the value out of the saved registers ...\n+   */\n+\n+  lab_false = gen_label_rtx ();\n+  lab_over = gen_label_rtx ();\n+  addr_rtx = gen_reg_rtx (Pmode);\n \n-  if (BYTES_BIG_ENDIAN)\n+  emit_cmp_and_jump_insns (expand_expr (reg, NULL_RTX, QImode, EXPAND_NORMAL),\n+\t\t\t   GEN_INT (8 - n_reg + 1),\n+\t\t\t   GE, const1_rtx, QImode, 1, 1, lab_false);\n+\n+  /* Long long is aligned in the registers.  */\n+  if (n_reg > 1)\n     {\n-      HOST_WIDE_INT bits = gpr << 8 | fpr;\n-      if (HOST_BITS_PER_WIDE_INT >= BITS_PER_WORD)\n-        tmp = GEN_INT (bits << (BITS_PER_WORD - 16));\n-      else\n-\t{\n-\t  bits <<= BITS_PER_WORD - HOST_BITS_PER_WIDE_INT - 16;\n-\t  tmp = immed_double_const (0, bits, word_mode);\n-\t}\n+      u = build (BIT_AND_EXPR, TREE_TYPE (reg), reg,\n+\t\t build_int_2 (n_reg - 1, 0));\n+      u = build (PLUS_EXPR, TREE_TYPE (reg), reg, u);\n+      u = build (MODIFY_EXPR, TREE_TYPE (reg), reg, u);\n+      TREE_SIDE_EFFECTS (u) = 1;\n+      expand_expr (u, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n+\n+  if (sav_ofs)\n+    t = build (PLUS_EXPR, ptr_type_node, sav, build_int_2 (sav_ofs, 0));\n   else\n-    tmp = GEN_INT (fpr << 8 | gpr);\n+    t = sav;\n \n-  emit_move_insn (mem_gpr_fpr, tmp);\n+  u = build (POSTINCREMENT_EXPR, TREE_TYPE (reg), reg, build_int_2 (n_reg, 0));\n+  TREE_SIDE_EFFECTS (u) = 1;\n \n-  /* Find the overflow area.  */\n-  tmp = expand_binop (Pmode, add_optab, virtual_incoming_args_rtx,\n-\t\t      GEN_INT (words * UNITS_PER_WORD),\n-\t\t      mem_overflow, 0, OPTAB_WIDEN);\n-  if (tmp != mem_overflow)\n-    emit_move_insn (mem_overflow, tmp);\n+  u = build1 (CONVERT_EXPR, integer_type_node, u);\n+  TREE_SIDE_EFFECTS (u) = 1;\n \n-  /* Find the register save area.  */\n-  tmp = expand_binop (Pmode, add_optab, virtual_stack_vars_rtx,\n-\t\t      GEN_INT (-RS6000_VARARGS_SIZE),\n-\t\t      mem_reg_save_area, 0, OPTAB_WIDEN);\n-  if (tmp != mem_reg_save_area)\n-    emit_move_insn (mem_reg_save_area, tmp);\n-\n-  /* Return the address of the va_list constructor.  */\n-  return XEXP (block, 0);\n+  u = build (MULT_EXPR, integer_type_node, u, build_int_2 (sav_scale, 0));\n+  TREE_SIDE_EFFECTS (u) = 1;\n+\n+  t = build (PLUS_EXPR, ptr_type_node, t, u);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+\n+  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+  if (r != addr_rtx)\n+    emit_move_insn (addr_rtx, r);\n+\n+  emit_jump_insn (gen_jump (lab_over));\n+  emit_barrier ();\n+  emit_label (lab_false);\n+\n+  /*\n+   * ... otherwise out of the overflow area.\n+   */\n+\n+  /* Make sure we don't find reg 7 for the next int arg.  */\n+  if (n_reg > 1)\n+    {\n+      t = build (MODIFY_EXPR, TREE_TYPE (reg), reg, build_int_2 (8, 0));\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    }\n+\n+  /* Care for on-stack alignment if needed.  */\n+  if (rsize <= 1)\n+    t = ovf;\n+  else\n+    {\n+      t = build (PLUS_EXPR, TREE_TYPE (ovf), ovf, build_int_2 (7, 0));\n+      t = build (BIT_AND_EXPR, TREE_TYPE (t), t, build_int_2 (-8, -1));\n+    }\n+  t = save_expr (t);\n+\n+  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n+  if (r != addr_rtx)\n+    emit_move_insn (addr_rtx, r);\n+\n+  t = build (PLUS_EXPR, TREE_TYPE (t), t, build_int_2 (size, 0));\n+  t = build (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  emit_label (lab_over);\n+\n+  if (indirect_p)\n+    {\n+      r = gen_rtx_MEM (Pmode, addr_rtx);\n+      MEM_ALIAS_SET (r) = get_varargs_alias_set ();\n+      emit_move_insn (addr_rtx, r);\n+    }\n+\n+  return addr_rtx;\n }\n \f\n /* Generate a memory reference for expand_block_move, copying volatile,"}, {"sha": "d5eb6f61e5693ed443390aa0886e68ed9a40edb8", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfafc897fe79d12aae145e182301260f0dacb2dd/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfafc897fe79d12aae145e182301260f0dacb2dd/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=dfafc897fe79d12aae145e182301260f0dacb2dd", "patch": "@@ -1566,14 +1566,17 @@ typedef struct rs6000_args\n #define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL) \\\n   setup_incoming_varargs (&CUM, MODE, TYPE, &PRETEND_SIZE, NO_RTL)\n \n-/* If defined, is a C expression that produces the machine-specific\n-   code for a call to `__builtin_saveregs'.  This code will be moved\n-   to the very beginning of the function, before any parameter access\n-   are made.  The return value of this function should be an RTX that\n-   contains the value to use as the return of `__builtin_saveregs'.  */\n+/* Define the `__builtin_va_list' type for the ABI.  */\n+#define BUILD_VA_LIST_TYPE(VALIST) \\\n+  (VALIST) = rs6000_build_va_list ()\n \n-#define EXPAND_BUILTIN_SAVEREGS() \\\n-  rs6000_expand_builtin_saveregs ()\n+/* Implement `va_start' for varargs and stdarg.  */\n+#define EXPAND_BUILTIN_VA_START(stdarg, valist, nextarg) \\\n+  rs6000_va_start (stdarg, valist, nextarg)\n+\n+/* Implement `va_arg'.  */\n+#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n+  rs6000_va_arg (valist, type)\n \n /* This macro generates the assembly code for function entry.\n    FILE is a stdio stream to output the code to.\n@@ -3297,7 +3300,9 @@ extern struct rtx_def *function_arg ();\n extern int function_arg_partial_nregs ();\n extern int function_arg_pass_by_reference ();\n extern void setup_incoming_varargs ();\n-extern struct rtx_def *rs6000_expand_builtin_saveregs ();\n+extern union tree_node *rs6000_va_list ();\n+extern void rs6000_va_start ();\n+extern struct rtx_def *rs6000_va_arg ();\n extern struct rtx_def *rs6000_stack_temp ();\n extern int expand_block_move ();\n extern int load_multiple_operation ();"}]}