{"sha": "b5efa47076d28866e3be9770ea8a5788190f2d20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVlZmE0NzA3NmQyODg2NmUzYmU5NzcwZWE4YTU3ODgxOTBmMmQyMA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-07-11T02:38:30Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-07-11T02:38:30Z"}, "message": "tree-ssa-structalias.c (struct variable_info): Heapify complex.\n\n2005-07-07  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree-ssa-structalias.c (struct variable_info): Heapify complex.\n\t(varmap): Heapify varmap.\n\t(constraints): Heapify constraints.\n\t(struct constraint_graph): Heapify succs and preds.\n\t(constraint_vec_find): Update for heapification.\n\t(constraint_set_union): Ditto.\n\t(insert_into_complex): Ditto.\n\t(constraint_edge_vec_find): Ditto.\n\t(erase_graph_self_edge): Ditto.\n\t(add_graph_edge): Ditto.\n\t(get_graph_weights): Ditto.\n\t(merge_graph_nodes): Ditto.\n\t(build_constraint_graph): Ditto.\n\t(topo_visit): Ditto.\n\t(solve_graph): Ditto.\n\t(create_variable_info_for): Ditto.\n\t(init_base_vars): Ditto.\n\t(delete_points_to_sets): Free graph, varmap, and complex constraints.\n\t(condese_varmap_nodes): Free complex vector.\n\t(clear_edges_for_node): Clear succs and preds vector.\n\nFrom-SVN: r101862", "tree": {"sha": "534294ac5ca85f5a4a7e83af9bbe62a90ef81f9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/534294ac5ca85f5a4a7e83af9bbe62a90ef81f9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5efa47076d28866e3be9770ea8a5788190f2d20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5efa47076d28866e3be9770ea8a5788190f2d20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5efa47076d28866e3be9770ea8a5788190f2d20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5efa47076d28866e3be9770ea8a5788190f2d20/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0bfac35f9d98bbed3e18c312c85dc2009103216d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bfac35f9d98bbed3e18c312c85dc2009103216d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bfac35f9d98bbed3e18c312c85dc2009103216d"}], "stats": {"total": 137, "additions": 90, "deletions": 47}, "files": [{"sha": "87a89f443dc22ae39cb0c610c6e61d9d42c37838", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5efa47076d28866e3be9770ea8a5788190f2d20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5efa47076d28866e3be9770ea8a5788190f2d20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5efa47076d28866e3be9770ea8a5788190f2d20", "patch": "@@ -1,3 +1,26 @@\n+2005-07-07  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree-ssa-structalias.c (struct variable_info): Heapify complex.\n+\t(varmap): Heapify varmap.\n+\t(constraints): Heapify constraints.\n+\t(struct constraint_graph): Heapify succs and preds.\n+\t(constraint_vec_find): Update for heapification.\n+\t(constraint_set_union): Ditto.\n+\t(insert_into_complex): Ditto.\n+\t(constraint_edge_vec_find): Ditto.\n+\t(erase_graph_self_edge): Ditto.\n+\t(add_graph_edge): Ditto.\n+\t(get_graph_weights): Ditto.\n+\t(merge_graph_nodes): Ditto.\n+\t(build_constraint_graph): Ditto.\n+\t(topo_visit): Ditto.\n+\t(solve_graph): Ditto.\n+\t(create_variable_info_for): Ditto.\n+\t(init_base_vars): Ditto.\n+\t(delete_points_to_sets): Free graph, varmap, and complex constraints.\n+\t(condese_varmap_nodes): Free complex vector.\n+\t(clear_edges_for_node): Clear succs and preds vector.\n+\n 2005-07-10  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-ssa-structalias.c (update_alias_info): Change counting of"}, {"sha": "6f89799d00adcef4134dd5d2773e2a0557b1ca9d", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 67, "deletions": 47, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5efa47076d28866e3be9770ea8a5788190f2d20/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5efa47076d28866e3be9770ea8a5788190f2d20/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=b5efa47076d28866e3be9770ea8a5788190f2d20", "patch": "@@ -167,7 +167,7 @@ static void build_constraint_graph (void);\n static bitmap_obstack ptabitmap_obstack;\n static bitmap_obstack iteration_obstack;\n DEF_VEC_P(constraint_t);\n-DEF_VEC_ALLOC_P(constraint_t,gc);\n+DEF_VEC_ALLOC_P(constraint_t,heap);\n \n static struct constraint_stats\n {\n@@ -234,7 +234,7 @@ struct variable_info\n \n   /* Vector of complex constraints for this node.  Complex\n      constraints are those involving dereferences.  */\n-  VEC(constraint_t,gc) *complex;\n+  VEC(constraint_t,heap) *complex;\n };\n typedef struct variable_info *varinfo_t;\n \n@@ -245,11 +245,11 @@ static alloc_pool variable_info_pool;\n \n DEF_VEC_P(varinfo_t);\n \n-DEF_VEC_ALLOC_P(varinfo_t, gc);\n+DEF_VEC_ALLOC_P(varinfo_t, heap);\n \n /* Table of variable info structures for constraint variables.  Indexed directly\n    by variable info id.  */\n-static VEC(varinfo_t,gc) *varmap;\n+static VEC(varinfo_t,heap) *varmap;\n #define get_varinfo(n) VEC_index(varinfo_t, varmap, n)\n \n /* Variable that represents the unknown pointer.  */\n@@ -342,7 +342,7 @@ struct constraint\n \n /* List of constraints that we use to build the constraint graph from.  */\n \n-static VEC(constraint_t,gc) *constraints;\n+static VEC(constraint_t,heap) *constraints;\n static alloc_pool constraint_pool;\n \n /* An edge in the constraint graph.  We technically have no use for\n@@ -374,7 +374,7 @@ new_constraint_edge (unsigned int src, unsigned int dest)\n }\n \n DEF_VEC_P(constraint_edge_t);\n-DEF_VEC_ALLOC_P(constraint_edge_t,gc);\n+DEF_VEC_ALLOC_P(constraint_edge_t,heap);\n \n \n /* The constraint graph is simply a set of adjacency vectors, one per\n@@ -383,12 +383,12 @@ DEF_VEC_ALLOC_P(constraint_edge_t,gc);\n    IOW, all edges are \"forward\" edges, which is not like our CFG.  \n    So remember that\n    preds[x]->src == x, and\n-   succs[x]->src == x*/\n+   succs[x]->src == x.  */\n \n struct constraint_graph\n {\n-  VEC(constraint_edge_t,gc) **succs;\n-  VEC(constraint_edge_t,gc) **preds;\n+  VEC(constraint_edge_t,heap) **succs;\n+  VEC(constraint_edge_t,heap) **preds;\n };\n \n typedef struct constraint_graph *constraint_graph_t;\n@@ -541,7 +541,7 @@ constraint_equal (struct constraint a, struct constraint b)\n /* Find a constraint LOOKFOR in the sorted constraint vector VEC */\n \n static constraint_t\n-constraint_vec_find (VEC(constraint_t,gc) *vec,\n+constraint_vec_find (VEC(constraint_t,heap) *vec,\n \t\t     struct constraint lookfor)\n {\n   unsigned int place;  \n@@ -562,8 +562,8 @@ constraint_vec_find (VEC(constraint_t,gc) *vec,\n /* Union two constraint vectors, TO and FROM.  Put the result in TO.  */\n \n static void\n-constraint_set_union (VEC(constraint_t,gc) **to,\n-\t\t      VEC(constraint_t,gc) **from)\n+constraint_set_union (VEC(constraint_t,heap) **to,\n+\t\t      VEC(constraint_t,heap) **from)\n {\n   int i;\n   constraint_t c;\n@@ -574,7 +574,7 @@ constraint_set_union (VEC(constraint_t,gc) **to,\n \t{\n \t  unsigned int place = VEC_lower_bound (constraint_t, *to, c,\n \t\t\t\t\t\tconstraint_less);\n-\t  VEC_safe_insert (constraint_t, gc, *to, place, c);\n+\t  VEC_safe_insert (constraint_t, heap, *to, place, c);\n \t}\n     }\n }\n@@ -642,7 +642,7 @@ insert_into_complex (unsigned int var, constraint_t c)\n   varinfo_t vi = get_varinfo (var);\n   unsigned int place = VEC_lower_bound (constraint_t, vi->complex, c,\n \t\t\t\t\tconstraint_less);\n-  VEC_safe_insert (constraint_t, gc, vi->complex, place, c);\n+  VEC_safe_insert (constraint_t, heap, vi->complex, place, c);\n }\n \n \n@@ -671,7 +671,7 @@ constraint_edge_less (const constraint_edge_t a, const constraint_edge_t b)\n    Return the edge, if found, NULL otherwise.  */\n \n static constraint_edge_t \n-constraint_edge_vec_find (VEC(constraint_edge_t,gc) *vec, \n+constraint_edge_vec_find (VEC(constraint_edge_t,heap) *vec, \n \t\t\t  struct constraint_edge lookfor)\n {\n   unsigned int place;  \n@@ -719,6 +719,7 @@ condense_varmap_nodes (unsigned int to, unsigned int src)\n \tc->lhs.var = to;\n     }\n   constraint_set_union (&tovi->complex, &srcvi->complex);\n+  VEC_free (constraint_t, heap, srcvi->complex);\n   srcvi->complex = NULL;\n }\n \n@@ -728,8 +729,8 @@ condense_varmap_nodes (unsigned int to, unsigned int src)\n static void\n erase_graph_self_edge (constraint_graph_t graph, struct constraint_edge edge)\n {\n-  VEC(constraint_edge_t,gc) *predvec = graph->preds[edge.src];\n-  VEC(constraint_edge_t,gc) *succvec = graph->succs[edge.dest];\n+  VEC(constraint_edge_t,heap) *predvec = graph->preds[edge.src];\n+  VEC(constraint_edge_t,heap) *succvec = graph->succs[edge.dest];\n   unsigned int place;\n   gcc_assert (edge.src == edge.dest);\n \n@@ -765,8 +766,8 @@ erase_graph_self_edge (constraint_graph_t graph, struct constraint_edge edge)\n static void\n clear_edges_for_node (constraint_graph_t graph, unsigned int node)\n {\n-  VEC(constraint_edge_t,gc) *succvec = graph->succs[node];\n-  VEC(constraint_edge_t,gc) *predvec = graph->preds[node];\n+  VEC(constraint_edge_t,heap) *succvec = graph->succs[node];\n+  VEC(constraint_edge_t,heap) *predvec = graph->preds[node];\n   constraint_edge_t c;\n   int i;\n   \n@@ -795,6 +796,8 @@ clear_edges_for_node (constraint_graph_t graph, unsigned int node)\n \tVEC_ordered_remove (constraint_edge_t, graph->succs[c->dest], place);\n       }    \n   \n+  VEC_free (constraint_edge_t, heap, graph->preds[node]);\n+  VEC_free (constraint_edge_t, heap, graph->succs[node]);\n   graph->preds[node] = NULL;\n   graph->succs[node] = NULL;\n }\n@@ -809,7 +812,7 @@ add_graph_edge (constraint_graph_t graph, struct constraint_edge newe)\n   unsigned int place;\n   unsigned int src = newe.src;\n   unsigned int dest = newe.dest;\n-  VEC(constraint_edge_t,gc) *vec;\n+  VEC(constraint_edge_t,heap) *vec;\n \n   vec = graph->preds[src];\n   place = VEC_lower_bound (constraint_edge_t, vec, &newe, \n@@ -822,13 +825,13 @@ add_graph_edge (constraint_graph_t graph, struct constraint_edge newe)\n \n       weightbitmap = BITMAP_ALLOC (&ptabitmap_obstack);\n       edge->weights = weightbitmap;\n-      VEC_safe_insert (constraint_edge_t, gc, graph->preds[edge->src], \n+      VEC_safe_insert (constraint_edge_t, heap, graph->preds[edge->src], \n \t\t       place, edge);\n       edge = new_constraint_edge (dest, src);\n       edge->weights = weightbitmap;\n       place = VEC_lower_bound (constraint_edge_t, graph->succs[edge->src],\n \t\t\t       edge, constraint_edge_less);\n-      VEC_safe_insert (constraint_edge_t, gc, graph->succs[edge->src], \n+      VEC_safe_insert (constraint_edge_t, heap, graph->succs[edge->src], \n \t\t       place, edge);\n       edge_added = true;\n       return true;\n@@ -845,7 +848,7 @@ get_graph_weights (constraint_graph_t graph, struct constraint_edge lookfor)\n {\n   constraint_edge_t edge;\n   unsigned int src = lookfor.src;\n-  VEC(constraint_edge_t,gc) *vec;\n+  VEC(constraint_edge_t,heap) *vec;\n   vec = graph->preds[src];\n   edge = constraint_edge_vec_find (vec, lookfor);\n   gcc_assert (edge != NULL);\n@@ -859,8 +862,8 @@ static void\n merge_graph_nodes (constraint_graph_t graph, unsigned int to, \n \t\t   unsigned int from)\n {\n-  VEC(constraint_edge_t,gc) *succvec = graph->succs[from];\n-  VEC(constraint_edge_t,gc) *predvec = graph->preds[from];\n+  VEC(constraint_edge_t,heap) *succvec = graph->succs[from];\n+  VEC(constraint_edge_t,heap) *predvec = graph->preds[from];\n   int i;\n   constraint_edge_t c;\n   \n@@ -950,11 +953,11 @@ build_constraint_graph (void)\n   int i = 0;\n   constraint_t c;\n \n-  graph = ggc_alloc (sizeof (struct constraint_graph));\n-  graph->succs = ggc_alloc_cleared (VEC_length (varinfo_t, varmap)\n-                                    * sizeof (*graph->succs));\n-  graph->preds = ggc_alloc_cleared (VEC_length (varinfo_t, varmap)\n-                                    * sizeof (*graph->preds));\n+  graph = xmalloc (sizeof (struct constraint_graph));\n+  graph->succs = xcalloc (VEC_length (varinfo_t, varmap),\n+\t\t\t  sizeof (*graph->succs));\n+  graph->preds = xcalloc (VEC_length (varinfo_t, varmap),\n+\t\t\t  sizeof (*graph->preds));\n \n   for (i = 0; VEC_iterate (constraint_t, constraints, i, c); i++)\n     {\n@@ -1255,7 +1258,7 @@ static void\n topo_visit (constraint_graph_t graph, struct topo_info *ti,\n \t    unsigned int n)\n {\n-  VEC(constraint_edge_t,gc) *succs = graph->succs[n];\n+  VEC(constraint_edge_t,heap) *succs = graph->succs[n];\n   constraint_edge_t c;\n   int i;\n   SET_BIT (ti->visited, n);\n@@ -1555,7 +1558,7 @@ perform_var_substitution (constraint_graph_t graph)\n       varinfo_t vi = get_varinfo (i);\n       bool okay_to_elim = false;\n       unsigned int root = VEC_length (varinfo_t, varmap);\n-      VEC(constraint_edge_t,gc) *predvec = graph->preds[i];\n+      VEC(constraint_edge_t,heap) *predvec = graph->preds[i];\n       constraint_edge_t ce;\n       bitmap tmp;\n \n@@ -1687,8 +1690,8 @@ solve_graph (constraint_graph_t graph)\n \t      constraint_t c;\n \t      constraint_edge_t e;\n \t      bitmap solution;\n-\t      VEC(constraint_t,gc) *complex = get_varinfo (i)->complex;\n-\t      VEC(constraint_edge_t,gc) *succs;\n+\t      VEC(constraint_t,heap) *complex = get_varinfo (i)->complex;\n+\t      VEC(constraint_edge_t,heap) *succs;\n \n \t      RESET_BIT (changed, i);\n \t      changed_count--;\n@@ -1928,13 +1931,13 @@ process_constraint (constraint_t t)\n       for (vi = get_varinfo (rhs.var); vi != NULL; vi = vi->next)\n \tvi->address_taken = true;\n \n-      VEC_safe_push (constraint_t, gc, constraints, t);\n+      VEC_safe_push (constraint_t, heap, constraints, t);\n     }\n   else\n     {\n       if (lhs.type != DEREF && rhs.type == DEREF)\n \tget_varinfo (lhs.var)->indirect_target = true;\n-      VEC_safe_push (constraint_t, gc, constraints, t);\n+      VEC_safe_push (constraint_t, heap, constraints, t);\n     }\n }\n \n@@ -3014,7 +3017,7 @@ create_variable_info_for (tree decl, const char *name)\n     }\n   \n   insert_id_for_tree (vi->decl, index);  \n-  VEC_safe_push (varinfo_t, gc, varmap, vi);\n+  VEC_safe_push (varinfo_t, heap, varmap, vi);\n   if (is_global)\n     make_constraint_to_anything (vi);\n \n@@ -3078,7 +3081,7 @@ create_variable_info_for (tree decl, const char *name)\n \t  newvi->size = TREE_INT_CST_LOW (DECL_SIZE (field));\n \t  newvi->fullsize = vi->fullsize;\n \t  insert_into_field_list (vi, newvi);\n-\t  VEC_safe_push (varinfo_t, gc, varmap, newvi);\n+\t  VEC_safe_push (varinfo_t, heap, varmap, newvi);\n \t  if (is_global)\n \t    make_constraint_to_anything (newvi);\n \n@@ -3361,7 +3364,7 @@ init_base_vars (void)\n   var_nothing->size = ~0;\n   var_nothing->fullsize = ~0;\n   nothing_id = 0;\n-  VEC_safe_push (varinfo_t, gc, varmap, var_nothing);\n+  VEC_safe_push (varinfo_t, heap, varmap, var_nothing);\n \n   /* Create the ANYTHING variable, used to represent that a variable\n      points to some unknown piece of memory.  */\n@@ -3378,7 +3381,7 @@ init_base_vars (void)\n   /* Anything points to anything.  This makes deref constraints just\n      work in the presence of linked list and other p = *p type loops, \n      by saying that *ANYTHING = ANYTHING. */\n-  VEC_safe_push (varinfo_t, gc, varmap, var_anything);\n+  VEC_safe_push (varinfo_t, heap, varmap, var_anything);\n   lhs.type = SCALAR;\n   lhs.var = anything_id;\n   lhs.offset = 0;\n@@ -3390,7 +3393,7 @@ init_base_vars (void)\n   /* This specifically does not use process_constraint because\n      process_constraint ignores all anything = anything constraints, since all\n      but this one are redundant.  */\n-  VEC_safe_push (constraint_t, gc, constraints, new_constraint (lhs, rhs));\n+  VEC_safe_push (constraint_t, heap, constraints, new_constraint (lhs, rhs));\n   \n   /* Create the READONLY variable, used to represent that a variable\n      points to readonly memory.  */\n@@ -3403,7 +3406,7 @@ init_base_vars (void)\n   var_readonly->next = NULL;\n   insert_id_for_tree (readonly_tree, 2);\n   readonly_id = 2;\n-  VEC_safe_push (varinfo_t, gc, varmap, var_readonly);\n+  VEC_safe_push (varinfo_t, heap, varmap, var_readonly);\n \n   /* readonly memory points to anything, in order to make deref\n      easier.  In reality, it points to anything the particular\n@@ -3429,7 +3432,7 @@ init_base_vars (void)\n   var_integer->offset = 0;\n   var_integer->next = NULL;\n   integer_id = 3;\n-  VEC_safe_push (varinfo_t, gc, varmap, var_integer);\n+  VEC_safe_push (varinfo_t, heap, varmap, var_integer);\n \n   /* *INTEGER = ANYTHING, because we don't know where a dereference of a random\n      integer will point to.  */\n@@ -3455,7 +3458,7 @@ init_base_vars (void)\n   var_anyoffset->offset = 0;\n   var_anyoffset->next = NULL;\n   var_anyoffset->fullsize = ~0;\n-  VEC_safe_push (varinfo_t, gc, varmap, var_anyoffset);\n+  VEC_safe_push (varinfo_t, heap, varmap, var_anyoffset);\n \n   /* ANYOFFSET points to ANYOFFSET.  */\n   lhs.type = SCALAR;\n@@ -3487,8 +3490,8 @@ compute_points_to_sets (struct alias_info *ai)\n   constraint_edge_pool = create_alloc_pool (\"Constraint edges\",\n \t\t\t\t\t    sizeof (struct constraint_edge), 30);\n   \n-  constraints = VEC_alloc (constraint_t, gc, 8);\n-  varmap = VEC_alloc (varinfo_t, gc, 8);\n+  constraints = VEC_alloc (constraint_t, heap, 8);\n+  varmap = VEC_alloc (varinfo_t, heap, 8);\n   id_for_tree = htab_create (10, tree_id_hash, tree_id_eq, free);\n   memset (&stats, 0, sizeof (stats));\n \n@@ -3544,10 +3547,27 @@ compute_points_to_sets (struct alias_info *ai)\n void\n delete_points_to_sets (void)\n {\n+  varinfo_t v;\n+  int i;\n+\n   htab_delete (id_for_tree);\n+  bitmap_obstack_release (&ptabitmap_obstack);\n+  VEC_free (constraint_t, heap, constraints);\n+  \n+  for (i = 0; VEC_iterate (varinfo_t, varmap, i, v); i++)\n+    {\n+      VEC_free (constraint_edge_t, heap, graph->succs[i]);\n+      VEC_free (constraint_edge_t, heap, graph->preds[i]);\n+      VEC_free (constraint_t, heap, v->complex);\n+    }\n+  free (graph->succs);\n+  free (graph->preds);\n+  free (graph);\n+\n+  VEC_free (varinfo_t, heap, varmap);\n   free_alloc_pool (variable_info_pool);\n   free_alloc_pool (constraint_pool); \n   free_alloc_pool (constraint_edge_pool);\n-  bitmap_obstack_release (&ptabitmap_obstack);\n+\n   have_alias_info = false;\n }"}]}