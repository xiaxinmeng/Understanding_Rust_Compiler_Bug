{"sha": "ac6f2e594886e2209446114023ecdff96b0bd7c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM2ZjJlNTk0ODg2ZTIyMDk0NDYxMTQwMjNlY2RmZjk2YjBiZDdjNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-11-03T16:37:45Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-03T16:37:45Z"}, "message": "ipa-fnsummary.c (ipa_call_context::duplicate_from): New member function.\n\n\t* ipa-fnsummary.c (ipa_call_context::duplicate_from): New\n\tmember function.\n\t(ipa_call_context::release): Add ALL parameter.\n\t(ipa_call_context::equal_to): New member function.\n\t* ipa-fnsummary.h (ipa_call_context): Add empty constructor;\n\tduplicate_form, release, equal_to and exists_p member functoins.\n\t* ipa-inline-analysis.c (node_context_cache_entry): New\n\tclass.\n\t(node_context_summary): Likewise.\n\t(node_context_cache, node_context_cache_hit, node_context_cache_miss,\n\tnode_context_clear): New static vars.\n\t(initialize_growth_caches): New function.\n\t(free_growth_caches): Also delete node_context_cache; output stats.\n\t(do_estimate_edge_time): Cache contexts.\n\t(reset_node_cache): New function.\n\t* ipa-inline.c (reset_edge_caches): Reset also node cache.\n\t(inline_small_functions): Initialize growth caches.\n\t* ipa-inline.h (reset_node_cache, initialize_growth_caches):\n\tDeclare.\n\t* ipa-predicate.h (inline_param_summary::equal_to): New.\n\t* ipa-prop.c (ipa_agg_jf_item::equal_to): New.\n\t* ipa-prop.h (ipa_agg_jf_item): Declare equal_to member function.\n\t(ipa_agg_jump_function): Implement equal_to member function.\n\nFrom-SVN: r277757", "tree": {"sha": "08ad05645f41cd3331fef1728530f56b00673203", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08ad05645f41cd3331fef1728530f56b00673203"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac6f2e594886e2209446114023ecdff96b0bd7c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac6f2e594886e2209446114023ecdff96b0bd7c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac6f2e594886e2209446114023ecdff96b0bd7c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac6f2e594886e2209446114023ecdff96b0bd7c4/comments", "author": null, "committer": null, "parents": [{"sha": "360386c7ef1c3fa30de216b1d68ed6a27296fd80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/360386c7ef1c3fa30de216b1d68ed6a27296fd80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/360386c7ef1c3fa30de216b1d68ed6a27296fd80"}], "stats": {"total": 280, "additions": 270, "deletions": 10}, "files": [{"sha": "fdac1b2ca09ef575ad40599ec8f0e19a2057730b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6f2e594886e2209446114023ecdff96b0bd7c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6f2e594886e2209446114023ecdff96b0bd7c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac6f2e594886e2209446114023ecdff96b0bd7c4", "patch": "@@ -1,3 +1,29 @@\n+2019-11-02  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-fnsummary.c (ipa_call_context::duplicate_from): New\n+\tmember function.\n+\t(ipa_call_context::release): Add ALL parameter.\n+\t(ipa_call_context::equal_to): New member function.\n+\t* ipa-fnsummary.h (ipa_call_context): Add empty constructor;\n+\tduplicate_form, release, equal_to and exists_p member functoins.\n+\t* ipa-inline-analysis.c (node_context_cache_entry): New\n+\tclass.\n+\t(node_context_summary): Likewise.\n+\t(node_context_cache, node_context_cache_hit, node_context_cache_miss,\n+\tnode_context_clear): New static vars.\n+\t(initialize_growth_caches): New function.\n+\t(free_growth_caches): Also delete node_context_cache; output stats.\n+\t(do_estimate_edge_time): Cache contexts.\n+\t(reset_node_cache): New function.\n+\t* ipa-inline.c (reset_edge_caches): Reset also node cache.\n+\t(inline_small_functions): Initialize growth caches.\n+\t* ipa-inline.h (reset_node_cache, initialize_growth_caches):\n+\tDeclare.\n+\t* ipa-predicate.h (inline_param_summary::equal_to): New.\n+\t* ipa-prop.c (ipa_agg_jf_item::equal_to): New.\n+\t* ipa-prop.h (ipa_agg_jf_item): Declare equal_to member function.\n+\t(ipa_agg_jump_function): Implement equal_to member function.\n+\n 2019-11-02  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-fnsummary.c (inline_read_section): Set vector size"}, {"sha": "eaf904cd4017462ab45d041a672c899d90b4359a", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 91, "deletions": 2, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6f2e594886e2209446114023ecdff96b0bd7c4/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6f2e594886e2209446114023ecdff96b0bd7c4/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=ac6f2e594886e2209446114023ecdff96b0bd7c4", "patch": "@@ -2964,14 +2964,103 @@ ipa_call_context::ipa_call_context (cgraph_node *node,\n {\n }\n \n-/* Release memory used by known_vals/contexts/aggs vectors.  */\n+void\n+ipa_call_context::duplicate_from (const ipa_call_context &ctx)\n+{\n+  m_node = ctx.m_node;\n+  m_possible_truths = ctx.m_possible_truths;\n+  m_nonspec_possible_truths = ctx.m_nonspec_possible_truths;\n+\n+  if (ctx.m_inline_param_summary.exists ())\n+    m_inline_param_summary = ctx.m_inline_param_summary.copy ();\n+  else\n+    m_inline_param_summary = vNULL;\n+  if (ctx.m_known_vals.exists ())\n+    m_known_vals = ctx.m_known_vals.copy ();\n+  else\n+    m_known_vals = vNULL;\n+  if (ctx.m_known_contexts.exists ())\n+    m_known_contexts = ctx.m_known_contexts.copy ();\n+  else\n+    m_known_contexts = vNULL;\n+  if (ctx.m_known_aggs.exists ())\n+    m_known_aggs = ctx.m_known_aggs.copy ();\n+  else\n+    m_known_aggs = vNULL;\n+}\n+\n+/* Release memory used by known_vals/contexts/aggs vectors.\n+   If ALL is true release also inline_param_summary.\n+   This happens when context was previously duplciated to be stored\n+   into cache.  */\n \n void\n-ipa_call_context::release ()\n+ipa_call_context::release (bool all)\n {\n+  /* See if context is initialized at first place.  */\n+  if (!m_node)\n+    return;\n   m_known_vals.release ();\n   m_known_contexts.release ();\n   m_known_aggs.release ();\n+  if (all)\n+    m_inline_param_summary.release ();\n+}\n+\n+/* Return true if CTX describes the same call context as THIS.  */\n+\n+bool\n+ipa_call_context::equal_to (const ipa_call_context &ctx)\n+{\n+  if (m_node != ctx.m_node\n+      || m_possible_truths != ctx.m_possible_truths\n+      || m_nonspec_possible_truths != ctx.m_nonspec_possible_truths)\n+    return false;\n+  if (m_inline_param_summary.exists () != ctx.m_inline_param_summary.exists ()\n+      || m_known_vals.exists () != ctx.m_known_vals.exists()\n+      || m_known_contexts.exists () != ctx.m_known_contexts.exists ()\n+      || m_known_aggs.exists () != ctx.m_known_aggs.exists ())\n+    return false;\n+  if (m_inline_param_summary.exists ())\n+    {\n+      if (m_inline_param_summary.length () != ctx.m_inline_param_summary.length ())\n+\treturn false;\n+      for (unsigned int i = 0; i < m_inline_param_summary.length (); i++)\n+\tif (!m_inline_param_summary[i].equal_to (ctx.m_inline_param_summary[i]))\n+\t  return false;\n+    }\n+  if (m_known_vals.exists ())\n+    {\n+      if (m_known_vals.length () != ctx.m_known_vals.length ())\n+\treturn false;\n+      for (unsigned int i = 0; i < m_known_vals.length (); i++)\n+\t{\n+\t  tree t1 = m_known_vals[i];\n+\t  tree t2 = ctx.m_known_vals[i];\n+\n+\t  if (t1 != t2\n+\t      && (!t1 || !t2 || !operand_equal_p (m_known_vals[i],\n+\t\t\t\t\t\t  ctx.m_known_vals[i], 0)))\n+\t    return false;\n+\t}\n+    }\n+  if (m_known_contexts.exists ())\n+    {\n+      if (m_known_contexts.length () != ctx.m_known_contexts.length ())\n+\treturn false;\n+      for (unsigned int i = 0; i < m_known_contexts.length (); i++)\n+\tif (!m_known_contexts[i].equal_to (ctx.m_known_contexts[i]))\n+\t  return false;\n+    }\n+  if (m_known_aggs.exists ())\n+    {\n+      if (m_known_aggs.length () != ctx.m_known_aggs.length ())\n+\treturn false;\n+      for (unsigned int i = 0; i < m_known_aggs.length (); i++)\n+\tif (!m_known_aggs[i]->equal_to (*ctx.m_known_aggs[i]))\n+\t  return false;\n+    }\n+  return true;\n }\n \n /* Estimate size and time needed to execute call in the given context."}, {"sha": "91488a998814e069672396d7bbedc035a08bb325", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6f2e594886e2209446114023ecdff96b0bd7c4/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6f2e594886e2209446114023ecdff96b0bd7c4/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=ac6f2e594886e2209446114023ecdff96b0bd7c4", "patch": "@@ -295,11 +295,21 @@ class ipa_call_context\n \t\t    vec<ipa_polymorphic_call_context> known_contexts,\n \t\t    vec<ipa_agg_jump_function_p> known_aggs,\n \t\t    vec<inline_param_summary> m_inline_param_summary);\n+  ipa_call_context ()\n+  : m_node(NULL)\n+  {\n+  }\n   void estimate_size_and_time (int *ret_size, int *ret_min_size,\n \t\t\t       sreal *ret_time,\n \t\t\t       sreal *ret_nonspecialized_time,\n \t\t\t       ipa_hints *ret_hints);\n-  void release ();\n+  void duplicate_from (const ipa_call_context &ctx);\n+  void release (bool all = false);\n+  bool equal_to (const ipa_call_context &);\n+  bool exists_p ()\n+  {\n+    return m_node != NULL;\n+  }\n private:\n   /* Called function.  */\n   cgraph_node *m_node;"}, {"sha": "436310596ac475f9944424ddea2b329bb0d78675", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 105, "deletions": 5, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6f2e594886e2209446114023ecdff96b0bd7c4/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6f2e594886e2209446114023ecdff96b0bd7c4/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=ac6f2e594886e2209446114023ecdff96b0bd7c4", "patch": "@@ -53,6 +53,48 @@ along with GCC; see the file COPYING3.  If not see\n /* Cached node/edge growths.  */\n call_summary<edge_growth_cache_entry *> *edge_growth_cache = NULL;\n \n+/* The context cache remembers estimated time/size and hints for given\n+   ipa_call_context of a call.  */\n+class node_context_cache_entry\n+{\n+public:\n+  ipa_call_context ctx;\n+  sreal time, nonspec_time;\n+  int size;\n+  ipa_hints hints;\n+\n+  node_context_cache_entry ()\n+  : ctx ()\n+  {\n+  }\n+  ~node_context_cache_entry ()\n+  {\n+    ctx.release ();\n+  }\n+};\n+\n+/* At the moment we implement primitive single entry LRU cache.  */\n+class node_context_summary\n+{\n+public:\n+  node_context_cache_entry entry;\n+\n+  node_context_summary ()\n+  : entry ()\n+  {\n+  }\n+  ~node_context_summary ()\n+  {\n+  }\n+};\n+\n+/* Summary holding the context cache.  */\n+static fast_function_summary <node_context_summary *, va_heap>\n+\t*node_context_cache = NULL;\n+/* Statistics about the context cache effectivity.  */\n+static long node_context_cache_hit, node_context_cache_miss,\n+\t    node_context_cache_clear;\n+\n /* Give initial reasons why inlining would fail on EDGE.  This gets either\n    nullified or usually overwritten by more precise reasons later.  */\n \n@@ -77,14 +119,34 @@ initialize_inline_failed (struct cgraph_edge *e)\n \t\t\t    == CIF_FINAL_ERROR);\n }\n \n+/* Allocate edge growth caches.  */\n+\n+void\n+initialize_growth_caches ()\n+{\n+  edge_growth_cache\n+    = new call_summary<edge_growth_cache_entry *> (symtab, false);\n+  node_context_cache\n+    = new fast_function_summary<node_context_summary *, va_heap> (symtab);\n+}\n \n /* Free growth caches.  */\n \n void\n free_growth_caches (void)\n {\n   delete edge_growth_cache;\n+  delete node_context_cache;\n   edge_growth_cache = NULL;\n+  node_context_cache = NULL;\n+  if (dump_file)\n+    fprintf (dump_file, \"node context cache: %li hits, %li misses,\"\n+\t\t   \t\" %li initializations\\n\",\n+\t     node_context_cache_hit, node_context_cache_miss,\n+\t     node_context_cache_clear);\n+  node_context_cache_hit = 0;\n+  node_context_cache_miss = 0;\n+  node_context_cache_clear = 0;\n }\n \n /* Return hints derrived from EDGE.   */\n@@ -129,7 +191,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   vec<ipa_polymorphic_call_context> known_contexts;\n   vec<ipa_agg_jump_function_p> known_aggs;\n   class ipa_call_summary *es = ipa_call_summaries->get (edge);\n-  int min_size;\n+  int min_size = -1;\n \n   callee = edge->callee->ultimate_alias_target ();\n \n@@ -139,8 +201,37 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n \t\t\t\t&known_contexts, &known_aggs);\n   ipa_call_context ctx (callee, clause, nonspec_clause, known_vals,\n \t\t  \tknown_contexts, known_aggs, es->param);\n-  ctx.estimate_size_and_time (&size, &min_size,\n-\t\t\t      &time, &nonspec_time, &hints);\n+  if (node_context_cache != NULL)\n+    {\n+      node_context_summary *e = node_context_cache->get_create (callee);\n+      if (e->entry.ctx.equal_to (ctx))\n+\t{\n+\t  node_context_cache_hit++;\n+\t  size = e->entry.size;\n+\t  time = e->entry.time;\n+\t  nonspec_time = e->entry.nonspec_time;\n+\t  hints = e->entry.hints;\n+\t}\n+      else\n+\t{\n+\t  if (e->entry.ctx.exists_p ())\n+\t    node_context_cache_miss++;\n+\t  else\n+\t    node_context_cache_clear++;\n+\t  e->entry.ctx.release (true);\n+\t  e->entry.ctx = ctx;\n+\t  ctx.estimate_size_and_time (&size, &min_size,\n+\t\t\t\t      &time, &nonspec_time, &hints);\n+\t  e->entry.size = size;\n+\t  e->entry.time = time;\n+\t  e->entry.nonspec_time = nonspec_time;\n+\t  e->entry.hints = hints;\n+\t  e->entry.ctx.duplicate_from (ctx);\n+\t}\n+    }\n+  else\n+    ctx.estimate_size_and_time (&size, &min_size,\n+\t\t\t\t&time, &nonspec_time, &hints);\n \n   /* When we have profile feedback, we can quite safely identify hot\n      edges and for those we disable size limits.  Don't do that when\n@@ -160,8 +251,9 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   /* When caching, update the cache entry.  */\n   if (edge_growth_cache != NULL)\n     {\n-      ipa_fn_summaries->get (edge->callee->function_symbol ())->min_size\n-\t = min_size;\n+      if (min_size >= 0)\n+        ipa_fn_summaries->get (edge->callee->function_symbol ())->min_size\n+\t   = min_size;\n       edge_growth_cache_entry *entry\n \t= edge_growth_cache->get_create (edge);\n       entry->time = time;\n@@ -174,6 +266,14 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   return time;\n }\n \n+/* Reset cache for NODE.\n+   This must be done each time NODE body is modified.  */\n+void\n+reset_node_cache (struct cgraph_node *node)\n+{\n+  if (node_context_cache)\n+    node_context_cache->remove (node);\n+}\n \n /* Return estimated callee growth after inlining EDGE.\n    Only to be called via estimate_edge_size.  */"}, {"sha": "dacec7d401b728cbeb3ebd99a3f169c409fb4bdf", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6f2e594886e2209446114023ecdff96b0bd7c4/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6f2e594886e2209446114023ecdff96b0bd7c4/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=ac6f2e594886e2209446114023ecdff96b0bd7c4", "patch": "@@ -1368,6 +1368,8 @@ reset_edge_caches (struct cgraph_node *node)\n   if (where->inlined_to)\n     where = where->inlined_to;\n \n+  reset_node_cache (where);\n+\n   if (edge_growth_cache != NULL)\n     for (edge = where->callers; edge; edge = edge->next_caller)\n       if (edge->inline_failed)\n@@ -1900,8 +1902,7 @@ inline_small_functions (void)\n \t  max_count = max_count.max (edge->count.ipa ());\n       }\n   ipa_free_postorder_info ();\n-  edge_growth_cache\n-    = new call_summary<edge_growth_cache_entry *> (symtab, false);\n+  initialize_growth_caches ();\n \n   if (dump_file)\n     fprintf (dump_file,"}, {"sha": "7675b9e08fa8585b3105550d782c8f262a1067a6", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6f2e594886e2209446114023ecdff96b0bd7c4/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6f2e594886e2209446114023ecdff96b0bd7c4/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=ac6f2e594886e2209446114023ecdff96b0bd7c4", "patch": "@@ -48,6 +48,8 @@ bool growth_likely_positive (struct cgraph_node *, int);\n int do_estimate_edge_size (struct cgraph_edge *edge);\n sreal do_estimate_edge_time (struct cgraph_edge *edge);\n ipa_hints do_estimate_edge_hints (struct cgraph_edge *edge);\n+void reset_node_cache (struct cgraph_node *node);\n+void initialize_growth_caches ();\n void free_growth_caches (void);\n \n /* In ipa-inline.c  */"}, {"sha": "2509b1e516217ac616b989f1343dcbce792a2e7a", "filename": "gcc/ipa-predicate.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6f2e594886e2209446114023ecdff96b0bd7c4/gcc%2Fipa-predicate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6f2e594886e2209446114023ecdff96b0bd7c4/gcc%2Fipa-predicate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-predicate.h?ref=ac6f2e594886e2209446114023ecdff96b0bd7c4", "patch": "@@ -77,6 +77,10 @@ struct inline_param_summary\n \n      Value 0 is reserved for compile time invariants. */\n   int change_prob;\n+  bool equal_to (const inline_param_summary &other)\n+  {\n+    return change_prob == other.change_prob;\n+  }\n };\n \n typedef vec<condition, va_gc> *conditions;"}, {"sha": "5491aee2fc6090819f86b029b10d1f8b9157112b", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6f2e594886e2209446114023ecdff96b0bd7c4/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6f2e594886e2209446114023ecdff96b0bd7c4/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=ac6f2e594886e2209446114023ecdff96b0bd7c4", "patch": "@@ -5293,4 +5293,12 @@ ipcp_transform_function (struct cgraph_node *node)\n   return TODO_update_ssa_only_virtuals;\n }\n \n+\n+/* Return true if OTHER describes same agg item.  */\n+bool\n+ipa_agg_jf_item::equal_to (const ipa_agg_jf_item &other)\n+{\n+  return offset == other.offset\n+\t && operand_equal_p (value, other.value, 0);\n+}\n #include \"gt-ipa-prop.h\""}, {"sha": "121d0f647b11a16f9b91442bb894edada26bb65c", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6f2e594886e2209446114023ecdff96b0bd7c4/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6f2e594886e2209446114023ecdff96b0bd7c4/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=ac6f2e594886e2209446114023ecdff96b0bd7c4", "patch": "@@ -127,6 +127,9 @@ struct GTY(()) ipa_agg_jf_item\n \n   /* The known constant or type if this is a clobber.  */\n   tree value;\n+\n+  /* Return true if OTHER describes same agg item.  */\n+  bool equal_to (const ipa_agg_jf_item &other);\n };\n \n \n@@ -139,6 +142,23 @@ struct GTY(()) ipa_agg_jump_function\n   vec<ipa_agg_jf_item, va_gc> *items;\n   /* True if the data was passed by reference (as opposed to by value). */\n   bool by_ref;\n+\n+  /* Return true if OTHER describes same agg items.  */\n+  bool equal_to (const ipa_agg_jump_function &other)\n+  {\n+    if (by_ref != other.by_ref)\n+      return false;\n+    if (items != NULL && other.items == NULL)\n+      return false;\n+    if (!items)\n+      return other.items == NULL;\n+    if (items->length () != other.items->length ())\n+      return false;\n+    for (unsigned int i = 0; i < items->length (); i++)\n+      if (!(*items)[i].equal_to ((*other.items)[i]))\n+\treturn false;\n+    return true;\n+  }\n };\n \n typedef struct ipa_agg_jump_function *ipa_agg_jump_function_p;"}]}