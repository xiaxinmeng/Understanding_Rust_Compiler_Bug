{"sha": "473b30ce95c6b3f41ced3bcc18fceb2c5f2ac466", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDczYjMwY2U5NWM2YjNmNDFjZWQzYmNjMThmY2ViMmM1ZjJhYzQ2Ng==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2011-08-08T14:59:19Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2011-08-08T14:59:19Z"}, "message": "re PR target/49781 ([x32] Unnecessary lea in x32 mode)\n\n\tPR target/49781\n\t* config/i386/i386.c (ix86_decompose_address): Allow zero-extended\n\tSImode addresses.\n\t(ix86_print_operand_address): Handle zero-extended addresses.\n\t(memory_address_length): Add length of addr32 prefix for\n\tzero-extended addresses.\n\t(ix86_secondary_reload): Handle moves to/from double-word general\n\tregisters from/to zero-extended addresses.\n\t* config/i386/predicates.md (lea_address_operand): Reject\n\tzero-extended operands.\n\nFrom-SVN: r177566", "tree": {"sha": "71eb8713ed9043df8e60a9dda3a64fdf5aa2a4e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71eb8713ed9043df8e60a9dda3a64fdf5aa2a4e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/473b30ce95c6b3f41ced3bcc18fceb2c5f2ac466", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/473b30ce95c6b3f41ced3bcc18fceb2c5f2ac466", "html_url": "https://github.com/Rust-GCC/gccrs/commit/473b30ce95c6b3f41ced3bcc18fceb2c5f2ac466", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/473b30ce95c6b3f41ced3bcc18fceb2c5f2ac466/comments", "author": null, "committer": null, "parents": [{"sha": "d7cfa3145fc72f621ab2747df2f7bf046c0ee4db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7cfa3145fc72f621ab2747df2f7bf046c0ee4db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7cfa3145fc72f621ab2747df2f7bf046c0ee4db"}], "stats": {"total": 60, "additions": 49, "deletions": 11}, "files": [{"sha": "79d104eba8d656b16b88f1708c141702d335998f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473b30ce95c6b3f41ced3bcc18fceb2c5f2ac466/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473b30ce95c6b3f41ced3bcc18fceb2c5f2ac466/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=473b30ce95c6b3f41ced3bcc18fceb2c5f2ac466", "patch": "@@ -1,8 +1,20 @@\n+2011-08-07  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/49781\n+\t* config/i386/i386.c (ix86_decompose_address): Allow zero-extended\n+\tSImode addresses.\n+\t(ix86_print_operand_address): Handle zero-extended addresses.\n+\t(memory_address_length): Add length of addr32 prefix for\n+\tzero-extended addresses.\n+\t(ix86_secondary_reload): Handle moves to/from double-word general\n+\tregisters from/to zero-extended addresses.\n+\t* config/i386/predicates.md (lea_address_operand): Reject\n+\tzero-extended operands.\n+\n 2011-08-08  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR other/48007\n-\t* config.gcc (libgcc_tm_file): Add i386/value-unwind.h for\n-\tLinux/x86.\n+\t* config.gcc (libgcc_tm_file): Add i386/value-unwind.h for Linux/x86.\n \n \t* system.h (REG_VALUE_IN_UNWIND_CONTEXT): Poisoned.\n \t(ASSUME_EXTENDED_UNWIND_CONTEXT): Likewise.\n@@ -43,10 +55,8 @@\n \n \t* config/sparc/driver-sparc.c: New file.\n \t* config/sparc/x-sparc: New file.\n-\t* config.host: Use driver-sparc.o, sparc/x-sparc on\n-\tsparc*-*-solaris2*.\n-\t* config/sparc/sparc.opt (native): New value for enum\n-\tprocessor_type.\n+\t* config.host: Use driver-sparc.o, sparc/x-sparc on sparc*-*-solaris2*.\n+\t* config/sparc/sparc.opt (native): New value for enum processor_type.\n \t* config/sparc/sparc-opts.h (PROCESSOR_NATIVE): Declare.\n \t* config/sparc/sparc.c (sparc_option_override): Abort if\n \tPROCESSOR_NATIVE gets here.\n@@ -93,7 +103,7 @@\n \t(TARGET_INSTANTIATE_DECLS): New define.\n \n 2011-08-06  Paolo Bonzini  <bonzini@gnu.org>\n-            Mikael Morin   <mikael.morin@sfr.fr>\n+\t    Mikael Morin   <mikael.morin@sfr.fr>\n \n \t* Makefile.in (INCLUDES_FOR_TARGET): New.\n \t(LIBGCC2_CFLAGS): Use it."}, {"sha": "b50b3d018bbc83a37d3a38ffc5c866d54bbf90a6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473b30ce95c6b3f41ced3bcc18fceb2c5f2ac466/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473b30ce95c6b3f41ced3bcc18fceb2c5f2ac466/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=473b30ce95c6b3f41ced3bcc18fceb2c5f2ac466", "patch": "@@ -11142,6 +11142,14 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n   int retval = 1;\n   enum ix86_address_seg seg = SEG_DEFAULT;\n \n+  /* Allow zero-extended SImode addresses,\n+     they will be emitted with addr32 prefix.  */\n+  if (TARGET_64BIT\n+      && GET_CODE (addr) == ZERO_EXTEND\n+      && GET_MODE (addr) == DImode\n+      && GET_MODE (XEXP (addr, 0)) == SImode)\n+    addr = XEXP (addr, 0);\n+ \n   if (REG_P (addr))\n     base = addr;\n   else if (GET_CODE (addr) == SUBREG)\n@@ -14159,8 +14167,12 @@ ix86_print_operand_address (FILE *file, rtx addr)\n     }\n   else\n     {\n-      /* Print DImode registers on 64bit targets to avoid addr32 prefixes.  */\n-      int code = TARGET_64BIT ? 'q' : 0;\n+      int code = 0;\n+\n+      /* Print SImode registers for zero-extended addresses to force\n+\t addr32 prefix.  Otherwise print DImode registers to avoid it.  */\n+      if (TARGET_64BIT)\n+\tcode = (GET_CODE (addr) == ZERO_EXTEND) ? 'l' : 'q';\n \n       if (ASSEMBLER_DIALECT == ASM_ATT)\n \t{\n@@ -21772,7 +21784,8 @@ assign_386_stack_local (enum machine_mode mode, enum ix86_stack_slot n)\n }\n \f\n /* Calculate the length of the memory address in the instruction\n-   encoding.  Does not include the one-byte modrm, opcode, or prefix.  */\n+   encoding.  Includes addr32 prefix, does not include the one-byte modrm,\n+   opcode, or other prefixes.  */\n \n int\n memory_address_length (rtx addr)\n@@ -21799,7 +21812,9 @@ memory_address_length (rtx addr)\n   base = parts.base;\n   index = parts.index;\n   disp = parts.disp;\n-  len = 0;\n+\n+  /* Add length of addr32 prefix.  */\n+  len = (GET_CODE (addr) == ZERO_EXTEND);\n \n   /* Rule of thumb:\n        - esp as the base always wants an index,\n@@ -28233,6 +28248,15 @@ ix86_secondary_reload (bool in_p, rtx x, reg_class_t rclass,\n \t\t       enum machine_mode mode,\n \t\t       secondary_reload_info *sri ATTRIBUTE_UNUSED)\n {\n+  /* Double-word spills from general registers to non-offsettable memory\n+     references (zero-extended addresses) go through XMM register.  */\n+  if (TARGET_64BIT\n+      && MEM_P (x)\n+      && GET_MODE_SIZE (mode) > UNITS_PER_WORD\n+      && rclass == GENERAL_REGS\n+      && !offsettable_memref_p (x))\n+    return SSE_REGS;\n+\n   /* QImode spills from non-QI registers require\n      intermediate register on 32bit targets.  */\n   if (!TARGET_64BIT"}, {"sha": "cfcd061e1f645027eea90edb72b82cfca148a377", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473b30ce95c6b3f41ced3bcc18fceb2c5f2ac466/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473b30ce95c6b3f41ced3bcc18fceb2c5f2ac466/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=473b30ce95c6b3f41ced3bcc18fceb2c5f2ac466", "patch": "@@ -801,6 +801,10 @@\n   struct ix86_address parts;\n   int ok;\n \n+  /*  LEA handles zero-extend by itself.  */\n+  if (GET_CODE (op) == ZERO_EXTEND)\n+    return false;\n+\n   ok = ix86_decompose_address (op, &parts);\n   gcc_assert (ok);\n   return parts.seg == SEG_DEFAULT;"}]}