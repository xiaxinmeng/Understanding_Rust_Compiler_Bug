{"sha": "916f14f12b114faba1d7fe94076bae5ff6be1d71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE2ZjE0ZjEyYjExNGZhYmExZDdmZTk0MDc2YmFlNWZmNmJlMWQ3MQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-12T00:30:30Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-12T00:30:30Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r727", "tree": {"sha": "7e9c98b040d0c7134cb36d3d6bcee3a2f058f091", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e9c98b040d0c7134cb36d3d6bcee3a2f058f091"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/916f14f12b114faba1d7fe94076bae5ff6be1d71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916f14f12b114faba1d7fe94076bae5ff6be1d71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/916f14f12b114faba1d7fe94076bae5ff6be1d71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916f14f12b114faba1d7fe94076bae5ff6be1d71/comments", "author": null, "committer": null, "parents": [{"sha": "af929c62a22d6efb5da698ccae85d566416a44f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af929c62a22d6efb5da698ccae85d566416a44f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af929c62a22d6efb5da698ccae85d566416a44f0"}], "stats": {"total": 103, "additions": 93, "deletions": 10}, "files": [{"sha": "dfca1e7bfef70e99310552a93e4894ee7b5934ef", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916f14f12b114faba1d7fe94076bae5ff6be1d71/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916f14f12b114faba1d7fe94076bae5ff6be1d71/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=916f14f12b114faba1d7fe94076bae5ff6be1d71", "patch": "@@ -472,7 +472,7 @@ restore_referenced_regs (x, insn, insn_mode)\n \t\t\t\t insn, insn_mode);\n       else if (regno >= FIRST_PSEUDO_REGISTER\n \t       && reg_equiv_address[regno] != 0)\n-\trestore_referenced_regs (XEXP (reg_equiv_address[regno], 0),\n+\trestore_referenced_regs (reg_equiv_address[regno],\n \t\t\t\t insn, insn_mode);\n \n       /* Otherwise if this is a hard register, restore any piece of it that"}, {"sha": "bee3287bb8e3d1e7b66e404dd6beb60e81cb1172", "filename": "gcc/combine.c", "status": "modified", "additions": 92, "deletions": 9, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916f14f12b114faba1d7fe94076bae5ff6be1d71/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916f14f12b114faba1d7fe94076bae5ff6be1d71/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=916f14f12b114faba1d7fe94076bae5ff6be1d71", "patch": "@@ -1150,7 +1150,7 @@ try_combine (i3, i2, i1)\n   i1dest_in_i1src = i1 && reg_overlap_mentioned_p (i1dest, i1src);\n   i2dest_in_i1src = i1 && reg_overlap_mentioned_p (i2dest, i1src);\n \n-  /* See if I1 directly feeds into I3.  It does if I1dest is not used\n+  /* See if I1 directly feeds into I3.  It does if I1DEST is not used\n      in I2SRC.  */\n   i1_feeds_i3 = i1 && ! reg_overlap_mentioned_p (i1dest, i2src);\n \n@@ -1352,9 +1352,13 @@ try_combine (i3, i2, i1)\n       previous_num_undos = undobuf.num_undo;\n     }\n \n-  /* Fail if an autoincrement side-effect has been duplicated.  */\n-  if ((i2_is_used > 1 && FIND_REG_INC_NOTE (i2, 0) != 0)\n-      || (i1 != 0 && n_occurrences > 1 && FIND_REG_INC_NOTE (i1, 0) != 0)\n+  /* Fail if an autoincrement side-effect has been duplicated.  Be careful\n+     to count all the ways that I2SRC and I1SRC can be used.  */\n+  if ((FIND_REG_INC_NOTE (i2, 0) != 0\n+       && i2_is_used + added_sets_2 > 1)\n+      || (i1 != 0 && FIND_REG_INC_NOTE (i1, 0) != 0\n+\t  && (n_occurrences + added_sets_1 + (added_sets_2 && ! i1_feeds_i3)\n+\t      > 1))\n       /* Fail if we tried to make a new register (we used to abort, but there's\n \t really no reason to).  */\n       || max_reg_num () != maxreg\n@@ -1453,16 +1457,41 @@ try_combine (i3, i2, i1)\n \n   /* If we were combining three insns and the result is a simple SET\n      with no ASM_OPERANDS that wasn't recognized, try to split it into two\n-     insns.  */\n+     insns.  There are two ways to do this.  It can be split using a \n+     machine-specific method (like when you have an addition of a large\n+     constant) or by combine in the function find_split_point.  */\n+\n   if (i1 && insn_code_number < 0 && GET_CODE (newpat) == SET\n       && asm_noperands (newpat) < 0)\n     {\n-      rtx *split = find_split_point (&newpat);\n+      rtx m_split, *split;\n+\n+      /* See if the MD file can split NEWPAT.  If it can't, see if letting it\n+\t use I2DEST as a scratch register will help.  */\n+\n+      m_split = split_insns (newpat, i3);\n+      if (m_split == 0)\n+\tm_split = split_insns (gen_rtx (PARALLEL, VOIDmode,\n+\t\t\t\t\tgen_rtvec (2, newpat,\n+\t\t\t\t\t\t   gen_rtx (CLOBBER, VOIDmode,\n+\t\t\t\t\t\t\t    i2dest))),\n+\t\t\t       i3);\n+\n+      if (m_split && GET_CODE (m_split) == SEQUENCE\n+\t  && XVECLEN (m_split, 0) == 2)\n+\t{\n+\t  newi2pat = PATTERN (XVECEXP (m_split, 0, 0));\n+\t  newpat = PATTERN (XVECEXP (m_split, 0, 1));\n+\n+\t  i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes);\n+\t  if (i2_code_number >= 0)\n+\t    insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n+\t}\n \n       /* If we can split it and use I2DEST, go ahead and see if that\n \t helps things be recognized.  Verify that none of the registers\n \t are set between I2 and I3.  */\n-      if (split\n+      else if ((split = find_split_point (&newpat)) != 0\n #ifdef HAVE_cc0\n \t  && GET_CODE (i2dest) == REG\n #endif\n@@ -1909,8 +1938,8 @@ find_split_point (loc)\n #endif\n       return find_split_point (&SUBREG_REG (x));\n \n-#ifdef HAVE_lo_sum\n     case MEM:\n+#ifdef HAVE_lo_sum\n       /* If we have (mem (const ..)) or (mem (symbol_ref ...)), split it\n \t using LO_SUM and HIGH.  */\n       if (GET_CODE (XEXP (x, 0)) == CONST\n@@ -1922,9 +1951,63 @@ find_split_point (loc)\n \t\t\t\t  XEXP (x, 0)));\n \t  return &XEXP (XEXP (x, 0), 0);\n \t}\n-      break;\n #endif\n \n+      /* If we have a PLUS whose second operand is a constant and the\n+\t address is not valid, perhaps will can split it up using\n+\t the machine-specific way to split large constants.  We use\n+\t the first psuedo-reg (one of the virtual regs) as a placeholder;\n+\t it will not remain in the result.  */\n+      if (GET_CODE (XEXP (x, 0)) == PLUS\n+\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+\t  && ! memory_address_p (GET_MODE (x), XEXP (x, 0)))\n+\t{\n+\t  rtx reg = regno_reg_rtx[FIRST_PSEUDO_REGISTER];\n+\t  rtx seq = split_insns (gen_rtx (SET, VOIDmode, reg, XEXP (x, 0)),\n+\t\t\t\t subst_insn);\n+\n+\t  /* This should have produced two insns, each of which sets our\n+\t     placeholder.  If the source of the second is a valid address,\n+\t     we can make put both sources together and make a split point\n+\t     in the middle.  */\n+\n+\t  if (seq && XVECLEN (seq, 0) == 2\n+\t      && GET_CODE (XVECEXP (seq, 0, 0)) == INSN\n+\t      && GET_CODE (PATTERN (XVECEXP (seq, 0, 0))) == SET\n+\t      && SET_DEST (PATTERN (XVECEXP (seq, 0, 0))) == reg\n+\t      && ! reg_mentioned_p (reg,\n+\t\t\t\t    SET_SRC (PATTERN (XVECEXP (seq, 0, 0))))\n+\t      && GET_CODE (XVECEXP (seq, 0, 1)) == INSN\n+\t      && GET_CODE (PATTERN (XVECEXP (seq, 0, 1))) == SET\n+\t      && SET_DEST (PATTERN (XVECEXP (seq, 0, 1))) == reg\n+\t      && memory_address_p (GET_MODE (x),\n+\t\t\t\t   SET_SRC (PATTERN (XVECEXP (seq, 0, 1)))))\n+\t    {\n+\t      rtx src1 = SET_SRC (PATTERN (XVECEXP (seq, 0, 0)));\n+\t      rtx src2 = SET_SRC (PATTERN (XVECEXP (seq, 0, 1)));\n+\n+\t      /* Replace the placeholder in SRC2 with SRC1.  If we can\n+\t\t find where in SRC2 it was placed, that can become our\n+\t\t split point and we can replace this address with SRC2.\n+\t\t Just try two obvious places.  */\n+\n+\t      src2 = replace_rtx (src2, reg, src1);\n+\t      split = 0;\n+\t      if (XEXP (src2, 0) == src1)\n+\t\tsplit = &XEXP (src2, 0);\n+\t      else if (GET_RTX_FORMAT (GET_CODE (XEXP (src2, 0)))[0] == 'e'\n+\t\t       && XEXP (XEXP (src2, 0), 0) == src1)\n+\t\tsplit = &XEXP (XEXP (src2, 0), 0);\n+\n+\t      if (split)\n+\t\t{\n+\t\t  SUBST (XEXP (x, 0), src2);\n+\t\t  return split;\n+\t\t}\n+\t    }\n+\t}\n+      break;\n+\n     case SET:\n #ifdef HAVE_cc0\n       /* If SET_DEST is CC0 and SET_SRC is not an operand, a COMPARE, or a"}]}