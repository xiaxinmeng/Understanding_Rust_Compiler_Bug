{"sha": "8aab5218424ce6d1a646dc9d564413359a352911", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFhYjUyMTg0MjRjZTZkMWE2NDZkYzlkNTY0NDEzMzU5YTM1MjkxMQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2014-05-23T15:52:20Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2014-05-23T15:52:20Z"}, "message": "re PR tree-optimization/53787 (Possible IPA-SRA / IPA-CP improvement)\n\n2014-05-23  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/53787\n\t* params.def (PARAM_IPA_MAX_AA_STEPS): New param.\n\t* ipa-prop.h (ipa_node_params): Rename uses_analysis_done to\n\tanalysis_done, update all uses.\n\t* ipa-prop.c: Include domwalk.h\n\t(param_analysis_info): Removed.\n\t(param_aa_status): New type.\n\t(ipa_bb_info): Likewise.\n\t(func_body_info): Likewise.\n\t(ipa_get_bb_info): New function.\n\t(aa_overwalked): Likewise.\n\t(find_dominating_aa_status): Likewise.\n\t(parm_bb_aa_status_for_bb): Likewise.\n\t(parm_preserved_before_stmt_p): Changed to use new param AA info.\n\t(load_from_unmodified_param): Accept func_body_info as a parameter\n\tinstead of parms_ainfo.\n\t(parm_ref_data_preserved_p): Changed to use new param AA info.\n\t(parm_ref_data_pass_through_p): Likewise.\n\t(ipa_load_from_parm_agg_1): Likewise.  Update callers.\n\t(compute_complex_assign_jump_func): Changed to use new param AA info.\n\t(compute_complex_ancestor_jump_func): Likewise.\n\t(ipa_compute_jump_functions_for_edge): Likewise.\n\t(ipa_compute_jump_functions): Removed.\n\t(ipa_compute_jump_functions_for_bb): New function.\n\t(ipa_analyze_indirect_call_uses): Likewise, moved variable\n\tdeclarations down.\n\t(ipa_analyze_virtual_call_uses): Accept func_body_info instead of node\n\tand info, moved variable declarations down.\n\t(ipa_analyze_call_uses): Accept and pass on func_body_info instead of\n\tnode and info.\n\t(ipa_analyze_stmt_uses): Likewise.\n\t(ipa_analyze_params_uses): Removed.\n\t(ipa_analyze_params_uses_in_bb): New function.\n\t(ipa_analyze_controlled_uses): Likewise.\n\t(free_ipa_bb_info): Likewise.\n\t(analysis_dom_walker): New class.\n\t(ipa_analyze_node): Handle node-specific forbidden analysis,\n\tinitialize and free func_body_info, use dominator walker.\n\t(ipcp_modif_dom_walker): New class.\n\t(ipcp_transform_function): Create and free func_body_info, use\n\tipcp_modif_dom_walker, moved a lot of functionality there.\n\nFrom-SVN: r210864", "tree": {"sha": "53c92a4f7618b3834b1977f450705e4f7455e04f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53c92a4f7618b3834b1977f450705e4f7455e04f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8aab5218424ce6d1a646dc9d564413359a352911", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aab5218424ce6d1a646dc9d564413359a352911", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aab5218424ce6d1a646dc9d564413359a352911", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aab5218424ce6d1a646dc9d564413359a352911/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "63b0b10636f294a6f45a0ebb172ae422b5385da4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63b0b10636f294a6f45a0ebb172ae422b5385da4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63b0b10636f294a6f45a0ebb172ae422b5385da4"}], "stats": {"total": 862, "additions": 559, "deletions": 303}, "files": [{"sha": "7f169c2bf0db03304e466fe0b065b9eff6716500", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aab5218424ce6d1a646dc9d564413359a352911/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aab5218424ce6d1a646dc9d564413359a352911/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8aab5218424ce6d1a646dc9d564413359a352911", "patch": "@@ -1,3 +1,47 @@\n+2014-05-23  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/53787\n+\t* params.def (PARAM_IPA_MAX_AA_STEPS): New param.\n+\t* ipa-prop.h (ipa_node_params): Rename uses_analysis_done to\n+\tanalysis_done, update all uses.\n+\t* ipa-prop.c: Include domwalk.h\n+\t(param_analysis_info): Removed.\n+\t(param_aa_status): New type.\n+\t(ipa_bb_info): Likewise.\n+\t(func_body_info): Likewise.\n+\t(ipa_get_bb_info): New function.\n+\t(aa_overwalked): Likewise.\n+\t(find_dominating_aa_status): Likewise.\n+\t(parm_bb_aa_status_for_bb): Likewise.\n+\t(parm_preserved_before_stmt_p): Changed to use new param AA info.\n+\t(load_from_unmodified_param): Accept func_body_info as a parameter\n+\tinstead of parms_ainfo.\n+\t(parm_ref_data_preserved_p): Changed to use new param AA info.\n+\t(parm_ref_data_pass_through_p): Likewise.\n+\t(ipa_load_from_parm_agg_1): Likewise.  Update callers.\n+\t(compute_complex_assign_jump_func): Changed to use new param AA info.\n+\t(compute_complex_ancestor_jump_func): Likewise.\n+\t(ipa_compute_jump_functions_for_edge): Likewise.\n+\t(ipa_compute_jump_functions): Removed.\n+\t(ipa_compute_jump_functions_for_bb): New function.\n+\t(ipa_analyze_indirect_call_uses): Likewise, moved variable\n+\tdeclarations down.\n+\t(ipa_analyze_virtual_call_uses): Accept func_body_info instead of node\n+\tand info, moved variable declarations down.\n+\t(ipa_analyze_call_uses): Accept and pass on func_body_info instead of\n+\tnode and info.\n+\t(ipa_analyze_stmt_uses): Likewise.\n+\t(ipa_analyze_params_uses): Removed.\n+\t(ipa_analyze_params_uses_in_bb): New function.\n+\t(ipa_analyze_controlled_uses): Likewise.\n+\t(free_ipa_bb_info): Likewise.\n+\t(analysis_dom_walker): New class.\n+\t(ipa_analyze_node): Handle node-specific forbidden analysis,\n+\tinitialize and free func_body_info, use dominator walker.\n+\t(ipcp_modif_dom_walker): New class.\n+\t(ipcp_transform_function): Create and free func_body_info, use\n+\tipcp_modif_dom_walker, moved a lot of functionality there.\n+\n 2014-05-23  Marek Polacek  <polacek@redhat.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "fcdcb1d04b4273702c9a629b50cddc8e92f0581b", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aab5218424ce6d1a646dc9d564413359a352911/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aab5218424ce6d1a646dc9d564413359a352911/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8aab5218424ce6d1a646dc9d564413359a352911", "patch": "@@ -10108,6 +10108,13 @@ an array access known, it adds a bonus of\n @option{ipa-cp-array-index-hint-bonus} bonus to the profitability\n score of the candidate.\n \n+@item ipa-max-aa-steps\n+During its analysis of function bodies, IPA-CP employs alias analysis\n+in order to track values pointed to by function parameters.  In order\n+not spend too much time analyzing huge functions, it will give up and\n+consider all memory clobbered after examining\n+@option{ipa-max-aa-steps} statements modifying memory.\n+\n @item lto-partitions\n Specify desired number of partitions produced during WHOPR compilation.\n The number of partitions should exceed the number of CPUs used for compilation."}, {"sha": "5c1802cd442b2f6a533063d1da0e21ac91cc061a", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 499, "deletions": 301, "changes": 800, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aab5218424ce6d1a646dc9d564413359a352911/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aab5218424ce6d1a646dc9d564413359a352911/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=8aab5218424ce6d1a646dc9d564413359a352911", "patch": "@@ -60,14 +60,57 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"tree-ssanames.h\"\n #include \"dbgcnt.h\"\n+#include \"domwalk.h\"\n \n-/* Intermediate information about a parameter that is only useful during the\n-   run of ipa_analyze_node and is not kept afterwards.  */\n+/* Intermediate information that we get from alias analysis about a particular\n+   parameter in a particular basic_block.  When a parameter or the memory it\n+   references is marked modified, we use that information in all dominatd\n+   blocks without cosulting alias analysis oracle.  */\n \n-struct param_analysis_info\n+struct param_aa_status\n {\n+  /* Set when this structure contains meaningful information.  If not, the\n+     structure describing a dominating BB should be used instead.  */\n+  bool valid;\n+\n+  /* Whether we have seen something which might have modified the data in\n+     question.  PARM is for the parameter itself, REF is for data it points to\n+     but using the alias type of individual accesses and PT is the same thing\n+     but for computing aggregate pass-through functions using a very inclusive\n+     ao_ref.  */\n   bool parm_modified, ref_modified, pt_modified;\n-  bitmap parm_visited_statements, pt_visited_statements;\n+};\n+\n+/* Information related to a given BB that used only when looking at function\n+   body.  */\n+\n+struct ipa_bb_info\n+{\n+  /* Call graph edges going out of this BB.  */\n+  vec<cgraph_edge_p> cg_edges;\n+  /* Alias analysis statuses of each formal parameter at this bb.  */\n+  vec<param_aa_status> param_aa_statuses;\n+};\n+\n+/* Structure with global information that is only used when looking at function\n+   body. */\n+\n+struct func_body_info\n+{\n+  /* The node that is being analyzed.  */\n+  cgraph_node *node;\n+\n+  /* Its info.  */\n+  struct ipa_node_params *info;\n+\n+  /* Information about individual BBs. */\n+  vec<ipa_bb_info> bb_infos;\n+\n+  /* Number of parameters.  */\n+  int param_count;\n+\n+  /* Number of statements already walked by when analyzing this function.  */\n+  unsigned int aa_walked;\n };\n \n /* Vector where the parameter infos are actually stored. */\n@@ -511,6 +554,16 @@ ipa_binfo_from_known_type_jfunc (struct ipa_jump_func *jfunc)\n \t\t\t      jfunc->value.known_type.component_type);\n }\n \n+/* Get IPA BB information about the given BB.  FBI is the context of analyzis\n+   of this function body.  */\n+\n+static struct ipa_bb_info *\n+ipa_get_bb_info (struct func_body_info *fbi, basic_block bb)\n+{\n+  gcc_checking_assert (fbi);\n+  return &fbi->bb_infos[bb->index];\n+}\n+\n /* Structure to be passed in between detect_type_change and\n    check_stmt_for_type_change.  */\n \n@@ -770,34 +823,101 @@ mark_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef ATTRIBUTE_UNUSED,\n   return true;\n }\n \n+/* Return true if we have already walked so many statements in AA that we\n+   should really just start giving up.  */\n+\n+static bool\n+aa_overwalked (struct func_body_info *fbi)\n+{\n+  gcc_checking_assert (fbi);\n+  return fbi->aa_walked > (unsigned) PARAM_VALUE (PARAM_IPA_MAX_AA_STEPS);\n+}\n+\n+/* Find the nearest valid aa status for parameter specified by INDEX that\n+   dominates BB.  */\n+\n+static struct param_aa_status *\n+find_dominating_aa_status (struct func_body_info *fbi, basic_block bb,\n+\t\t\t   int index)\n+{\n+  while (true)\n+    {\n+      bb = get_immediate_dominator (CDI_DOMINATORS, bb);\n+      if (!bb)\n+\treturn NULL;\n+      struct ipa_bb_info *bi = ipa_get_bb_info (fbi, bb);\n+      if (!bi->param_aa_statuses.is_empty ()\n+\t  && bi->param_aa_statuses[index].valid)\n+\treturn &bi->param_aa_statuses[index];\n+    }\n+}\n+\n+/* Get AA status structure for the given BB and parameter with INDEX.  Allocate\n+   structures and/or intialize the result with a dominating description as\n+   necessary.  */\n+\n+static struct param_aa_status *\n+parm_bb_aa_status_for_bb (struct func_body_info *fbi, basic_block bb,\n+\t\t\t  int index)\n+{\n+  gcc_checking_assert (fbi);\n+  struct ipa_bb_info *bi = ipa_get_bb_info (fbi, bb);\n+  if (bi->param_aa_statuses.is_empty ())\n+    bi->param_aa_statuses.safe_grow_cleared (fbi->param_count);\n+  struct param_aa_status *paa = &bi->param_aa_statuses[index];\n+  if (!paa->valid)\n+    {\n+      gcc_checking_assert (!paa->parm_modified\n+\t\t\t   && !paa->ref_modified\n+\t\t\t   && !paa->pt_modified);\n+      struct param_aa_status *dom_paa;\n+      dom_paa = find_dominating_aa_status (fbi, bb, index);\n+      if (dom_paa)\n+\t*paa = *dom_paa;\n+      else\n+\tpaa->valid = true;\n+    }\n+\n+  return paa;\n+}\n+\n /* Return true if a load from a formal parameter PARM_LOAD is known to retrieve\n    a value known not to be modified in this function before reaching the\n-   statement STMT.  PARM_AINFO is a pointer to a structure containing temporary\n-   information about the parameter.  */\n+   statement STMT.  FBI holds information about the function we have so far\n+   gathered but do not survive the summary building stage.  */\n \n static bool\n-parm_preserved_before_stmt_p (struct param_analysis_info *parm_ainfo,\n-\t\t\t       gimple stmt, tree parm_load)\n+parm_preserved_before_stmt_p (struct func_body_info *fbi, int index,\n+\t\t\t      gimple stmt, tree parm_load)\n {\n+  struct param_aa_status *paa;\n   bool modified = false;\n-  bitmap *visited_stmts;\n   ao_ref refd;\n \n-  if (parm_ainfo && parm_ainfo->parm_modified)\n-    return false;\n+  /* FIXME: FBI can be NULL if we are being called from outside\n+     ipa_node_analysis or ipcp_transform_function, which currently happens\n+     during inlining analysis.  It would be great to extend fbi's lifetime and\n+     always have it.  Currently, we are just not afraid of too much walking in\n+     that case.  */\n+  if (fbi)\n+    {\n+      if (aa_overwalked (fbi))\n+\treturn false;\n+      paa = parm_bb_aa_status_for_bb (fbi, gimple_bb (stmt), index);\n+      if (paa->parm_modified)\n+\treturn false;\n+    }\n+  else\n+    paa = NULL;\n \n   gcc_checking_assert (gimple_vuse (stmt) != NULL_TREE);\n   ao_ref_init (&refd, parm_load);\n-  /* We can cache visited statements only when parm_ainfo is available and when\n-     we are looking at a naked load of the whole parameter.  */\n-  if (!parm_ainfo || TREE_CODE (parm_load) != PARM_DECL)\n-    visited_stmts = NULL;\n-  else\n-    visited_stmts = &parm_ainfo->parm_visited_statements;\n-  walk_aliased_vdefs (&refd, gimple_vuse (stmt), mark_modified, &modified,\n-\t\t      visited_stmts);\n-  if (parm_ainfo && modified)\n-    parm_ainfo->parm_modified = true;\n+  int walked = walk_aliased_vdefs (&refd, gimple_vuse (stmt), mark_modified,\n+\t\t\t\t   &modified, NULL);\n+  if (fbi)\n+    fbi->aa_walked += walked;\n+  if (paa && modified)\n+    paa->parm_modified = true;\n   return !modified;\n }\n \n@@ -806,8 +926,8 @@ parm_preserved_before_stmt_p (struct param_analysis_info *parm_ainfo,\n    modified.  Otherwise return -1.  */\n \n static int\n-load_from_unmodified_param (vec<ipa_param_descriptor> descriptors,\n-\t\t\t    struct param_analysis_info *parms_ainfo,\n+load_from_unmodified_param (struct func_body_info *fbi,\n+\t\t\t    vec<ipa_param_descriptor> descriptors,\n \t\t\t    gimple stmt)\n {\n   int index;\n@@ -822,45 +942,58 @@ load_from_unmodified_param (vec<ipa_param_descriptor> descriptors,\n \n   index = ipa_get_param_decl_index_1 (descriptors, op1);\n   if (index < 0\n-      || !parm_preserved_before_stmt_p (parms_ainfo ? &parms_ainfo[index]\n-\t\t\t\t\t: NULL, stmt, op1))\n+      || !parm_preserved_before_stmt_p (fbi, index, stmt, op1))\n     return -1;\n \n   return index;\n }\n \n-/* Return true if memory reference REF loads data that are known to be\n-   unmodified in this function before reaching statement STMT.  PARM_AINFO, if\n-   non-NULL, is a pointer to a structure containing temporary information about\n-   PARM.  */\n+/* Return true if memory reference REF (which must be a load through parameter\n+   with INDEX) loads data that are known to be unmodified in this function\n+   before reaching statement STMT.  */\n \n static bool\n-parm_ref_data_preserved_p (struct param_analysis_info *parm_ainfo,\n-\t\t\t      gimple stmt, tree ref)\n+parm_ref_data_preserved_p (struct func_body_info *fbi,\n+\t\t\t   int index, gimple stmt, tree ref)\n {\n+  struct param_aa_status *paa;\n   bool modified = false;\n   ao_ref refd;\n \n-  gcc_checking_assert (gimple_vuse (stmt));\n-  if (parm_ainfo && parm_ainfo->ref_modified)\n-    return false;\n+  /* FIXME: FBI can be NULL if we are being called from outside\n+     ipa_node_analysis or ipcp_transform_function, which currently happens\n+     during inlining analysis.  It would be great to extend fbi's lifetime and\n+     always have it.  Currently, we are just not afraid of too much walking in\n+     that case.  */\n+  if (fbi)\n+    {\n+      if (aa_overwalked (fbi))\n+\treturn false;\n+      paa = parm_bb_aa_status_for_bb (fbi, gimple_bb (stmt), index);\n+      if (paa->ref_modified)\n+\treturn false;\n+    }\n+  else\n+    paa = NULL;\n \n+  gcc_checking_assert (gimple_vuse (stmt));\n   ao_ref_init (&refd, ref);\n-  walk_aliased_vdefs (&refd, gimple_vuse (stmt), mark_modified, &modified,\n-\t\t      NULL);\n-  if (parm_ainfo && modified)\n-    parm_ainfo->ref_modified = true;\n+  int walked = walk_aliased_vdefs (&refd, gimple_vuse (stmt), mark_modified,\n+\t\t\t\t   &modified, NULL);\n+  if (fbi)\n+    fbi->aa_walked += walked;\n+  if (paa && modified)\n+    paa->ref_modified = true;\n   return !modified;\n }\n \n-/* Return true if the data pointed to by PARM is known to be unmodified in this\n-   function before reaching call statement CALL into which it is passed.\n-   PARM_AINFO is a pointer to a structure containing temporary information\n-   about PARM.  */\n+/* Return true if the data pointed to by PARM (which is a parameter with INDEX)\n+   is known to be unmodified in this function before reaching call statement\n+   CALL into which it is passed.  FBI describes the function body.  */\n \n static bool\n-parm_ref_data_pass_through_p (struct param_analysis_info *parm_ainfo,\n-\t\t\t       gimple call, tree parm)\n+parm_ref_data_pass_through_p (struct func_body_info *fbi, int index,\n+\t\t\t      gimple call, tree parm)\n {\n   bool modified = false;\n   ao_ref refd;\n@@ -869,17 +1002,21 @@ parm_ref_data_pass_through_p (struct param_analysis_info *parm_ainfo,\n      function because it is not goin to use it.  But do not cache the result\n      either.  Also, no such calculations for non-pointers.  */\n   if (!gimple_vuse (call)\n-      || !POINTER_TYPE_P (TREE_TYPE (parm)))\n+      || !POINTER_TYPE_P (TREE_TYPE (parm))\n+      || aa_overwalked (fbi))\n     return false;\n \n-  if (parm_ainfo->pt_modified)\n+  struct param_aa_status *paa = parm_bb_aa_status_for_bb (fbi, gimple_bb (call),\n+\t\t\t\t\t\t\t  index);\n+  if (paa->pt_modified)\n     return false;\n \n   ao_ref_init_from_ptr_and_size (&refd, parm, NULL_TREE);\n-  walk_aliased_vdefs (&refd, gimple_vuse (call), mark_modified, &modified,\n-\t\t      parm_ainfo ? &parm_ainfo->pt_visited_statements : NULL);\n+  int walked = walk_aliased_vdefs (&refd, gimple_vuse (call), mark_modified,\n+\t\t\t\t   &modified, NULL);\n+  fbi->aa_walked += walked;\n   if (modified)\n-    parm_ainfo->pt_modified = true;\n+    paa->pt_modified = true;\n   return !modified;\n }\n \n@@ -894,10 +1031,11 @@ parm_ref_data_pass_through_p (struct param_analysis_info *parm_ainfo,\n    reference respectively.  */\n \n static bool\n-ipa_load_from_parm_agg_1 (vec<ipa_param_descriptor> descriptors,\n-\t\t\t  struct param_analysis_info *parms_ainfo, gimple stmt,\n-\t\t\t  tree op, int *index_p, HOST_WIDE_INT *offset_p,\n-\t\t\t  HOST_WIDE_INT *size_p, bool *by_ref_p)\n+ipa_load_from_parm_agg_1 (struct func_body_info *fbi,\n+\t\t\t  vec<ipa_param_descriptor> descriptors,\n+\t\t\t  gimple stmt, tree op, int *index_p,\n+\t\t\t  HOST_WIDE_INT *offset_p, HOST_WIDE_INT *size_p,\n+\t\t\t  bool *by_ref_p)\n {\n   int index;\n   HOST_WIDE_INT size, max_size;\n@@ -910,8 +1048,7 @@ ipa_load_from_parm_agg_1 (vec<ipa_param_descriptor> descriptors,\n     {\n       int index = ipa_get_param_decl_index_1 (descriptors, base);\n       if (index >= 0\n-\t  && parm_preserved_before_stmt_p (parms_ainfo ? &parms_ainfo[index]\n-\t\t\t\t\t   : NULL, stmt, op))\n+\t  && parm_preserved_before_stmt_p (fbi, index, stmt, op))\n \t{\n \t  *index_p = index;\n \t  *by_ref_p = false;\n@@ -950,12 +1087,11 @@ ipa_load_from_parm_agg_1 (vec<ipa_param_descriptor> descriptors,\n       */\n \n       gimple def = SSA_NAME_DEF_STMT (TREE_OPERAND (base, 0));\n-      index = load_from_unmodified_param (descriptors, parms_ainfo, def);\n+      index = load_from_unmodified_param (fbi, descriptors, def);\n     }\n \n   if (index >= 0\n-      && parm_ref_data_preserved_p (parms_ainfo ? &parms_ainfo[index] : NULL,\n-\t\t\t\t    stmt, op))\n+      && parm_ref_data_preserved_p (fbi, index, stmt, op))\n     {\n       *index_p = index;\n       *by_ref_p = true;\n@@ -974,7 +1110,7 @@ ipa_load_from_parm_agg (struct ipa_node_params *info, gimple stmt,\n \t\t\ttree op, int *index_p, HOST_WIDE_INT *offset_p,\n \t\t\tbool *by_ref_p)\n {\n-  return ipa_load_from_parm_agg_1 (info->descriptors, NULL, stmt, op, index_p,\n+  return ipa_load_from_parm_agg_1 (NULL, info->descriptors, stmt, op, index_p,\n \t\t\t\t   offset_p, NULL, by_ref_p);\n }\n \n@@ -1032,8 +1168,8 @@ ipa_load_from_parm_agg (struct ipa_node_params *info, gimple stmt,\n    only needed for intraprocedural analysis.  */\n \n static void\n-compute_complex_assign_jump_func (struct ipa_node_params *info,\n-\t\t\t\t  struct param_analysis_info *parms_ainfo,\n+compute_complex_assign_jump_func (struct func_body_info *fbi,\n+\t\t\t\t  struct ipa_node_params *info,\n \t\t\t\t  struct ipa_jump_func *jfunc,\n \t\t\t\t  gimple call, gimple stmt, tree name,\n \t\t\t\t  tree param_type)\n@@ -1049,13 +1185,13 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n       if (SSA_NAME_IS_DEFAULT_DEF (op1))\n \tindex = ipa_get_param_decl_index (info, SSA_NAME_VAR (op1));\n       else\n-\tindex = load_from_unmodified_param (info->descriptors, parms_ainfo,\n+\tindex = load_from_unmodified_param (fbi, info->descriptors,\n \t\t\t\t\t    SSA_NAME_DEF_STMT (op1));\n       tc_ssa = op1;\n     }\n   else\n     {\n-      index = load_from_unmodified_param (info->descriptors, parms_ainfo, stmt);\n+      index = load_from_unmodified_param (fbi, info->descriptors, stmt);\n       tc_ssa = gimple_assign_lhs (stmt);\n     }\n \n@@ -1076,8 +1212,7 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n \t}\n       else if (gimple_assign_single_p (stmt))\n \t{\n-\t  bool agg_p = parm_ref_data_pass_through_p (&parms_ainfo[index],\n-\t\t\t\t\t\t     call, tc_ssa);\n+\t  bool agg_p = parm_ref_data_pass_through_p (fbi, index, call, tc_ssa);\n \t  bool type_p = false;\n \n \t  if (param_type && POINTER_TYPE_P (param_type))\n@@ -1116,7 +1251,7 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n       if (type_p || jfunc->type == IPA_JF_UNKNOWN)\n \tipa_set_ancestor_jf (jfunc, offset,\n \t\t\t     type_p ? TREE_TYPE (param_type) : NULL, index,\n-\t\t\t     parm_ref_data_pass_through_p (&parms_ainfo[index],\n+\t\t\t     parm_ref_data_pass_through_p (fbi, index,\n \t\t\t\t\t\t\t   call, ssa), type_p);\n     }\n }\n@@ -1188,8 +1323,8 @@ get_ancestor_addr_info (gimple assign, tree *obj_p, HOST_WIDE_INT *offset)\n      return D.1879_6;  */\n \n static void\n-compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n-\t\t\t\t    struct param_analysis_info *parms_ainfo,\n+compute_complex_ancestor_jump_func (struct func_body_info *fbi,\n+\t\t\t\t    struct ipa_node_params *info,\n \t\t\t\t    struct ipa_jump_func *jfunc,\n \t\t\t\t    gimple call, gimple phi, tree param_type)\n {\n@@ -1248,9 +1383,10 @@ compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n     type_p = !detect_type_change (obj, expr, TREE_TYPE (param_type),\n \t\t\t\t  call, jfunc, offset);\n   if (type_p || jfunc->type == IPA_JF_UNKNOWN)\n-    ipa_set_ancestor_jf (jfunc, offset, type_p ? TREE_TYPE (param_type) : NULL, index,\n-\t\t\t parm_ref_data_pass_through_p (&parms_ainfo[index],\n-\t\t\t\t\t\t       call, parm), type_p);\n+    ipa_set_ancestor_jf (jfunc, offset, type_p ? TREE_TYPE (param_type) : NULL,\n+\t\t\t index,\n+\t\t\t parm_ref_data_pass_through_p (fbi, index, call, parm),\n+\t\t\t type_p);\n }\n \n /* Given OP which is passed as an actual argument to a called function,\n@@ -1595,7 +1731,7 @@ ipa_get_callee_param_type (struct cgraph_edge *e, int i)\n    to this callsite.  */\n \n static void\n-ipa_compute_jump_functions_for_edge (struct param_analysis_info *parms_ainfo,\n+ipa_compute_jump_functions_for_edge (struct func_body_info *fbi,\n \t\t\t\t     struct cgraph_edge *cs)\n {\n   struct ipa_node_params *info = IPA_NODE_REF (cs->caller);\n@@ -1629,7 +1765,7 @@ ipa_compute_jump_functions_for_edge (struct param_analysis_info *parms_ainfo,\n \t  /* Aggregate passed by value, check for pass-through, otherwise we\n \t     will attempt to fill in aggregate contents later in this\n \t     for cycle.  */\n-\t  if (parm_preserved_before_stmt_p (&parms_ainfo[index], call, arg))\n+\t  if (parm_preserved_before_stmt_p (fbi, index, call, arg))\n \t    {\n \t      ipa_set_jf_simple_pass_through (jfunc, index, false, false);\n \t      continue;\n@@ -1643,8 +1779,7 @@ ipa_compute_jump_functions_for_edge (struct param_analysis_info *parms_ainfo,\n \t      if (index >= 0)\n \t\t{\n \t\t  bool agg_p, type_p;\n-\t\t  agg_p = parm_ref_data_pass_through_p (&parms_ainfo[index],\n-\t\t\t\t\t\t\tcall, arg);\n+\t\t  agg_p = parm_ref_data_pass_through_p (fbi, index, call, arg);\n \t\t  if (param_type && POINTER_TYPE_P (param_type))\n \t\t    type_p = !detect_type_change_ssa (arg, TREE_TYPE (param_type),\n \t\t\t\t\t\t      call, jfunc);\n@@ -1659,10 +1794,10 @@ ipa_compute_jump_functions_for_edge (struct param_analysis_info *parms_ainfo,\n \t    {\n \t      gimple stmt = SSA_NAME_DEF_STMT (arg);\n \t      if (is_gimple_assign (stmt))\n-\t\tcompute_complex_assign_jump_func (info, parms_ainfo, jfunc,\n+\t\tcompute_complex_assign_jump_func (fbi, info, jfunc,\n \t\t\t\t\t\t  call, stmt, arg, param_type);\n \t      else if (gimple_code (stmt) == GIMPLE_PHI)\n-\t\tcompute_complex_ancestor_jump_func (info, parms_ainfo, jfunc,\n+\t\tcompute_complex_ancestor_jump_func (fbi, info, jfunc,\n \t\t\t\t\t\t    call, stmt, param_type);\n \t    }\n \t}\n@@ -1693,27 +1828,29 @@ ipa_compute_jump_functions_for_edge (struct param_analysis_info *parms_ainfo,\n }\n \n /* Compute jump functions for all edges - both direct and indirect - outgoing\n-   from NODE.  Also count the actual arguments in the process.  */\n+   from BB.  */\n \n static void\n-ipa_compute_jump_functions (struct cgraph_node *node,\n-\t\t\t    struct param_analysis_info *parms_ainfo)\n+ipa_compute_jump_functions_for_bb (struct func_body_info *fbi, basic_block bb)\n {\n+  struct ipa_bb_info *bi = ipa_get_bb_info (fbi, bb);\n+  int i;\n   struct cgraph_edge *cs;\n \n-  for (cs = node->callees; cs; cs = cs->next_callee)\n+  FOR_EACH_VEC_ELT_REVERSE (bi->cg_edges, i, cs)\n     {\n-      struct cgraph_node *callee = cgraph_function_or_thunk_node (cs->callee,\n-\t\t\t\t\t\t\t\t  NULL);\n-      /* We do not need to bother analyzing calls to unknown\n-\t functions unless they may become known during lto/whopr.  */\n-      if (!callee->definition && !flag_lto)\n-\tcontinue;\n-      ipa_compute_jump_functions_for_edge (parms_ainfo, cs);\n-    }\n+      struct cgraph_node *callee = cs->callee;\n \n-  for (cs = node->indirect_calls; cs; cs = cs->next_callee)\n-    ipa_compute_jump_functions_for_edge (parms_ainfo, cs);\n+      if (callee)\n+\t{\n+\t  cgraph_function_or_thunk_node (callee, NULL);\n+\t  /* We do not need to bother analyzing calls to unknown functions\n+\t     unless they may become known during lto/whopr.  */\n+\t  if (!callee->definition && !flag_lto)\n+\t    continue;\n+\t}\n+      ipa_compute_jump_functions_for_edge (fbi, cs);\n+    }\n }\n \n /* If STMT looks like a statement loading a value from a member pointer formal\n@@ -1856,37 +1993,30 @@ ipa_note_param_call (struct cgraph_node *node, int param_index, gimple stmt)\n    passed by value or reference.  */\n \n static void\n-ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n-\t\t\t\tstruct ipa_node_params *info,\n-\t\t\t\tstruct param_analysis_info *parms_ainfo,\n-\t\t\t\tgimple call, tree target)\n+ipa_analyze_indirect_call_uses (struct func_body_info *fbi, gimple call,\n+\t\t\t\ttree target)\n {\n-  gimple def;\n-  tree n1, n2;\n-  gimple d1, d2;\n-  tree rec, rec2, cond;\n-  gimple branch;\n-  int index;\n-  basic_block bb, virt_bb, join;\n+  struct ipa_node_params *info = fbi->info;\n   HOST_WIDE_INT offset;\n   bool by_ref;\n \n   if (SSA_NAME_IS_DEFAULT_DEF (target))\n     {\n       tree var = SSA_NAME_VAR (target);\n-      index = ipa_get_param_decl_index (info, var);\n+      int index = ipa_get_param_decl_index (info, var);\n       if (index >= 0)\n-\tipa_note_param_call (node, index, call);\n+\tipa_note_param_call (fbi->node, index, call);\n       return;\n     }\n \n-  def = SSA_NAME_DEF_STMT (target);\n+  int index;\n+  gimple def = SSA_NAME_DEF_STMT (target);\n   if (gimple_assign_single_p (def)\n-      && ipa_load_from_parm_agg_1 (info->descriptors, parms_ainfo, def,\n+      && ipa_load_from_parm_agg_1 (fbi, info->descriptors, def,\n \t\t\t\t   gimple_assign_rhs1 (def), &index, &offset,\n \t\t\t\t   NULL, &by_ref))\n     {\n-      struct cgraph_edge *cs = ipa_note_param_call (node, index, call);\n+      struct cgraph_edge *cs = ipa_note_param_call (fbi->node, index, call);\n       if (cs->indirect_info->offset != offset)\n \tcs->indirect_info->outer_type = NULL;\n       cs->indirect_info->offset = offset;\n@@ -1905,14 +2035,16 @@ ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n \n   /* First, we need to check whether one of these is a load from a member\n      pointer that is a parameter to this function. */\n-  n1 = PHI_ARG_DEF (def, 0);\n-  n2 = PHI_ARG_DEF (def, 1);\n+  tree n1 = PHI_ARG_DEF (def, 0);\n+  tree n2 = PHI_ARG_DEF (def, 1);\n   if (!ipa_is_ssa_with_stmt_def (n1) || !ipa_is_ssa_with_stmt_def (n2))\n     return;\n-  d1 = SSA_NAME_DEF_STMT (n1);\n-  d2 = SSA_NAME_DEF_STMT (n2);\n+  gimple d1 = SSA_NAME_DEF_STMT (n1);\n+  gimple d2 = SSA_NAME_DEF_STMT (n2);\n \n-  join = gimple_bb (def);\n+  tree rec;\n+  basic_block bb, virt_bb;\n+  basic_block join = gimple_bb (def);\n   if ((rec = ipa_get_stmt_member_ptr_load_param (d1, false, &offset)))\n     {\n       if (ipa_get_stmt_member_ptr_load_param (d2, false, NULL))\n@@ -1940,7 +2072,7 @@ ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n   /* Third, let's see that the branching is done depending on the least\n      significant bit of the pfn. */\n \n-  branch = last_stmt (bb);\n+  gimple branch = last_stmt (bb);\n   if (!branch || gimple_code (branch) != GIMPLE_COND)\n     return;\n \n@@ -1949,7 +2081,7 @@ ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n       || !integer_zerop (gimple_cond_rhs (branch)))\n     return;\n \n-  cond = gimple_cond_lhs (branch);\n+  tree cond = gimple_cond_lhs (branch);\n   if (!ipa_is_ssa_with_stmt_def (cond))\n     return;\n \n@@ -1974,6 +2106,7 @@ ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n       def = SSA_NAME_DEF_STMT (cond);\n     }\n \n+  tree rec2;\n   rec2 = ipa_get_stmt_member_ptr_load_param (def,\n \t\t\t\t\t     (TARGET_PTRMEMFUNC_VBIT_LOCATION\n \t\t\t\t\t      == ptrmemfunc_vbit_in_delta),\n@@ -1983,9 +2116,9 @@ ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n \n   index = ipa_get_param_decl_index (info, rec);\n   if (index >= 0\n-      && parm_preserved_before_stmt_p (&parms_ainfo[index], call, rec))\n+      && parm_preserved_before_stmt_p (fbi, index, call, rec))\n     {\n-      struct cgraph_edge *cs = ipa_note_param_call (node, index, call);\n+      struct cgraph_edge *cs = ipa_note_param_call (fbi->node, index, call);\n       if (cs->indirect_info->offset != offset)\n \tcs->indirect_info->outer_type = NULL;\n       cs->indirect_info->offset = offset;\n@@ -1998,16 +2131,13 @@ ipa_analyze_indirect_call_uses (struct cgraph_node *node,\n \n /* Analyze a CALL to an OBJ_TYPE_REF which is passed in TARGET and if the\n    object referenced in the expression is a formal parameter of the caller\n-   (described by INFO), create a call note for the statement. */\n+   FBI->node (described by FBI->info), create a call note for the\n+   statement.  */\n \n static void\n-ipa_analyze_virtual_call_uses (struct cgraph_node *node,\n-\t\t\t       struct ipa_node_params *info, gimple call,\n-\t\t\t       tree target)\n+ipa_analyze_virtual_call_uses (struct func_body_info *fbi,\n+\t\t\t       gimple call, tree target)\n {\n-  struct cgraph_edge *cs;\n-  struct cgraph_indirect_call_info *ii;\n-  struct ipa_jump_func jfunc;\n   tree obj = OBJ_TYPE_REF_OBJECT (target);\n   int index;\n   HOST_WIDE_INT anc_offset;\n@@ -2018,8 +2148,10 @@ ipa_analyze_virtual_call_uses (struct cgraph_node *node,\n   if (TREE_CODE (obj) != SSA_NAME)\n     return;\n \n+  struct ipa_node_params *info = fbi->info;\n   if (SSA_NAME_IS_DEFAULT_DEF (obj))\n     {\n+      struct ipa_jump_func jfunc;\n       if (TREE_CODE (SSA_NAME_VAR (obj)) != PARM_DECL)\n \treturn;\n \n@@ -2032,6 +2164,7 @@ ipa_analyze_virtual_call_uses (struct cgraph_node *node,\n     }\n   else\n     {\n+      struct ipa_jump_func jfunc;\n       gimple stmt = SSA_NAME_DEF_STMT (obj);\n       tree expr;\n \n@@ -2046,8 +2179,8 @@ ipa_analyze_virtual_call_uses (struct cgraph_node *node,\n \treturn;\n     }\n \n-  cs = ipa_note_param_call (node, index, call);\n-  ii = cs->indirect_info;\n+  struct cgraph_edge *cs = ipa_note_param_call (fbi->node, index, call);\n+  struct cgraph_indirect_call_info *ii = cs->indirect_info;\n   ii->offset = anc_offset;\n   ii->otr_token = tree_to_uhwi (OBJ_TYPE_REF_TOKEN (target));\n   ii->otr_type = obj_type_ref_class (target);\n@@ -2059,12 +2192,9 @@ ipa_analyze_virtual_call_uses (struct cgraph_node *node,\n    containing intermediate information about each formal parameter.  */\n \n static void\n-ipa_analyze_call_uses (struct cgraph_node *node,\n-\t\t       struct ipa_node_params *info,\n-\t\t       struct param_analysis_info *parms_ainfo, gimple call)\n+ipa_analyze_call_uses (struct func_body_info *fbi, gimple call)\n {\n   tree target = gimple_call_fn (call);\n-  struct cgraph_edge *cs;\n \n   if (!target\n       || (TREE_CODE (target) != SSA_NAME\n@@ -2073,27 +2203,25 @@ ipa_analyze_call_uses (struct cgraph_node *node,\n \n   /* If we previously turned the call into a direct call, there is\n      no need to analyze.  */\n-  cs = cgraph_edge (node, call);\n+  struct cgraph_edge *cs = cgraph_edge (fbi->node, call);\n   if (cs && !cs->indirect_unknown_callee)\n     return;\n   if (TREE_CODE (target) == SSA_NAME)\n-    ipa_analyze_indirect_call_uses (node, info, parms_ainfo, call, target);\n+    ipa_analyze_indirect_call_uses (fbi, call, target);\n   else if (virtual_method_call_p (target))\n-    ipa_analyze_virtual_call_uses (node, info, call, target);\n+    ipa_analyze_virtual_call_uses (fbi, call, target);\n }\n \n \n /* Analyze the call statement STMT with respect to formal parameters (described\n-   in INFO) of caller given by NODE.  Currently it only checks whether formal\n-   parameters are called.  PARMS_AINFO is a pointer to a vector containing\n-   intermediate information about each formal parameter.  */\n+   in INFO) of caller given by FBI->NODE.  Currently it only checks whether\n+   formal parameters are called.  */\n \n static void\n-ipa_analyze_stmt_uses (struct cgraph_node *node, struct ipa_node_params *info,\n-\t\t       struct param_analysis_info *parms_ainfo, gimple stmt)\n+ipa_analyze_stmt_uses (struct func_body_info *fbi, gimple stmt)\n {\n   if (is_gimple_call (stmt))\n-    ipa_analyze_call_uses (node, info, parms_ainfo, stmt);\n+    ipa_analyze_call_uses (fbi, stmt);\n }\n \n /* Callback of walk_stmt_load_store_addr_ops for the visit_load.\n@@ -2117,37 +2245,43 @@ visit_ref_for_mod_analysis (gimple, tree op, tree, void *data)\n   return false;\n }\n \n-/* Scan the function body of NODE and inspect the uses of formal parameters.\n-   Store the findings in various structures of the associated ipa_node_params\n-   structure, such as parameter flags, notes etc.  PARMS_AINFO is a pointer to a\n-   vector containing intermediate information about each formal parameter.   */\n+/* Scan the statements in BB and inspect the uses of formal parameters.  Store\n+   the findings in various structures of the associated ipa_node_params\n+   structure, such as parameter flags, notes etc.  FBI holds various data about\n+   the function being analyzed.  */\n \n static void\n-ipa_analyze_params_uses (struct cgraph_node *node,\n-\t\t\t struct param_analysis_info *parms_ainfo)\n+ipa_analyze_params_uses_in_bb (struct func_body_info *fbi, basic_block bb)\n {\n-  tree decl = node->decl;\n-  basic_block bb;\n-  struct function *func;\n   gimple_stmt_iterator gsi;\n-  struct ipa_node_params *info = IPA_NODE_REF (node);\n-  int i;\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n \n-  if (ipa_get_param_count (info) == 0 || info->uses_analysis_done)\n-    return;\n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n \n-  info->uses_analysis_done = 1;\n-  if (ipa_func_spec_opts_forbid_analysis_p (node))\n-    {\n-      for (i = 0; i < ipa_get_param_count (info); i++)\n-\t{\n-\t  ipa_set_param_used (info, i, true);\n-\t  ipa_set_controlled_uses (info, i, IPA_UNDESCRIBED_USE);\n-\t}\n-      return;\n+      ipa_analyze_stmt_uses (fbi, stmt);\n+      walk_stmt_load_store_addr_ops (stmt, fbi->info,\n+\t\t\t\t     visit_ref_for_mod_analysis,\n+\t\t\t\t     visit_ref_for_mod_analysis,\n+\t\t\t\t     visit_ref_for_mod_analysis);\n     }\n+  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    walk_stmt_load_store_addr_ops (gsi_stmt (gsi), fbi->info,\n+\t\t\t\t   visit_ref_for_mod_analysis,\n+\t\t\t\t   visit_ref_for_mod_analysis,\n+\t\t\t\t   visit_ref_for_mod_analysis);\n+}\n+\n+/* Calculate controlled uses of parameters of NODE.  */\n+\n+static void\n+ipa_analyze_controlled_uses (struct cgraph_node *node)\n+{\n+  struct ipa_node_params *info = IPA_NODE_REF (node);\n \n-  for (i = 0; i < ipa_get_param_count (info); i++)\n+  for (int i = 0; i < ipa_get_param_count (info); i++)\n     {\n       tree parm = ipa_get_param (info, i);\n       int controlled_uses = 0;\n@@ -2183,45 +2317,36 @@ ipa_analyze_params_uses (struct cgraph_node *node,\n \tcontrolled_uses = IPA_UNDESCRIBED_USE;\n       ipa_set_controlled_uses (info, i, controlled_uses);\n     }\n+}\n \n-  func = DECL_STRUCT_FUNCTION (decl);\n-  FOR_EACH_BB_FN (bb, func)\n-    {\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  gimple stmt = gsi_stmt (gsi);\n-\n-\t  if (is_gimple_debug (stmt))\n-\t    continue;\n+/* Free stuff in BI.  */\n \n-\t  ipa_analyze_stmt_uses (node, info, parms_ainfo, stmt);\n-\t  walk_stmt_load_store_addr_ops (stmt, info,\n-\t\t\t\t\t visit_ref_for_mod_analysis,\n-\t\t\t\t\t visit_ref_for_mod_analysis,\n-\t\t\t\t\t visit_ref_for_mod_analysis);\n-\t}\n-      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\twalk_stmt_load_store_addr_ops (gsi_stmt (gsi), info,\n-\t\t\t\t       visit_ref_for_mod_analysis,\n-\t\t\t\t       visit_ref_for_mod_analysis,\n-\t\t\t\t       visit_ref_for_mod_analysis);\n-    }\n+static void\n+free_ipa_bb_info (struct ipa_bb_info *bi)\n+{\n+  bi->cg_edges.release ();\n+  bi->param_aa_statuses.release ();\n }\n \n-/* Free stuff in PARMS_AINFO, assume there are PARAM_COUNT parameters.  */\n+/* Dominator walker driving the analysis.  */\n \n-static void\n-free_parms_ainfo (struct param_analysis_info *parms_ainfo, int param_count)\n+class analysis_dom_walker : public dom_walker\n {\n-  int i;\n+public:\n+  analysis_dom_walker (struct func_body_info *fbi)\n+    : dom_walker (CDI_DOMINATORS), m_fbi (fbi) {}\n \n-  for (i = 0; i < param_count; i++)\n-    {\n-      if (parms_ainfo[i].parm_visited_statements)\n-\tBITMAP_FREE (parms_ainfo[i].parm_visited_statements);\n-      if (parms_ainfo[i].pt_visited_statements)\n-\tBITMAP_FREE (parms_ainfo[i].pt_visited_statements);\n-    }\n+  virtual void before_dom_children (basic_block);\n+\n+private:\n+  struct func_body_info *m_fbi;\n+};\n+\n+void\n+analysis_dom_walker::before_dom_children (basic_block bb)\n+{\n+  ipa_analyze_params_uses_in_bb (m_fbi, bb);\n+  ipa_compute_jump_functions_for_bb (m_fbi, bb);\n }\n \n /* Initialize the array describing properties of of formal parameters\n@@ -2231,24 +2356,60 @@ free_parms_ainfo (struct param_analysis_info *parms_ainfo, int param_count)\n void\n ipa_analyze_node (struct cgraph_node *node)\n {\n+  struct func_body_info fbi;\n   struct ipa_node_params *info;\n-  struct param_analysis_info *parms_ainfo;\n-  int param_count;\n \n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();\n   info = IPA_NODE_REF (node);\n-  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\n+  if (info->analysis_done)\n+    return;\n+  info->analysis_done = 1;\n+\n+  if (ipa_func_spec_opts_forbid_analysis_p (node))\n+    {\n+      for (int i = 0; i < ipa_get_param_count (info); i++)\n+\t{\n+\t  ipa_set_param_used (info, i, true);\n+\t  ipa_set_controlled_uses (info, i, IPA_UNDESCRIBED_USE);\n+\t}\n+      return;\n+    }\n+\n+  struct function *func = DECL_STRUCT_FUNCTION (node->decl);\n+  push_cfun (func);\n+  calculate_dominance_info (CDI_DOMINATORS);\n   ipa_initialize_node_params (node);\n+  ipa_analyze_controlled_uses (node);\n \n-  param_count = ipa_get_param_count (info);\n-  parms_ainfo = XALLOCAVEC (struct param_analysis_info, param_count);\n-  memset (parms_ainfo, 0, sizeof (struct param_analysis_info) * param_count);\n+  fbi.node = node;\n+  fbi.info = IPA_NODE_REF (node);\n+  fbi.bb_infos = vNULL;\n+  fbi.bb_infos.safe_grow_cleared (last_basic_block_for_fn (cfun));\n+  fbi.param_count = ipa_get_param_count (info);\n+  fbi.aa_walked = 0;\n \n-  ipa_analyze_params_uses (node, parms_ainfo);\n-  ipa_compute_jump_functions (node, parms_ainfo);\n+  for (struct cgraph_edge *cs = node->callees; cs; cs = cs->next_callee)\n+    {\n+      ipa_bb_info *bi = ipa_get_bb_info (&fbi, gimple_bb (cs->call_stmt));\n+      bi->cg_edges.safe_push (cs);\n+    }\n \n-  free_parms_ainfo (parms_ainfo, param_count);\n+  for (struct cgraph_edge *cs = node->indirect_calls; cs; cs = cs->next_callee)\n+    {\n+      ipa_bb_info *bi = ipa_get_bb_info (&fbi, gimple_bb (cs->call_stmt));\n+      bi->cg_edges.safe_push (cs);\n+    }\n+\n+  analysis_dom_walker (&fbi).walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+\n+  int i;\n+  struct ipa_bb_info *bi;\n+  FOR_EACH_VEC_ELT (fbi.bb_infos, i, bi)\n+    free_ipa_bb_info (bi);\n+  fbi.bb_infos.release ();\n+  free_dominance_info (CDI_DOMINATORS);\n   pop_cfun ();\n }\n \n@@ -3320,7 +3481,7 @@ ipa_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n   new_info->lattices = NULL;\n   new_info->ipcp_orig_node = old_info->ipcp_orig_node;\n \n-  new_info->uses_analysis_done = old_info->uses_analysis_done;\n+  new_info->analysis_done = old_info->analysis_done;\n   new_info->node_enqueued = old_info->node_enqueued;\n \n   old_av = ipa_get_agg_replacements_for_node (src);\n@@ -4445,7 +4606,7 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n   for (j = 0; j < ipa_get_param_count (info); j++)\n     streamer_write_uhwi (ob, ipa_get_param_move_cost (info, j));\n   bp = bitpack_create (ob->main_stream);\n-  gcc_assert (info->uses_analysis_done\n+  gcc_assert (info->analysis_done\n \t      || ipa_get_param_count (info) == 0);\n   gcc_assert (!info->node_enqueued);\n   gcc_assert (!info->ipcp_orig_node);\n@@ -4491,7 +4652,7 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n     \n   bp = streamer_read_bitpack (ib);\n   if (ipa_get_param_count (info) != 0)\n-    info->uses_analysis_done = true;\n+    info->analysis_done = true;\n   info->node_enqueued = false;\n   for (k = 0; k < ipa_get_param_count (info); k++)\n     ipa_set_param_used (info, k, bp_unpack_value (&bp, 1));\n@@ -4841,17 +5002,129 @@ adjust_agg_replacement_values (struct cgraph_node *node,\n     v->index = adj[v->index];\n }\n \n+/* Dominator walker driving the ipcp modification phase.  */\n+\n+class ipcp_modif_dom_walker : public dom_walker\n+{\n+public:\n+  ipcp_modif_dom_walker (struct func_body_info *fbi,\n+\t\t\t vec<ipa_param_descriptor> descs,\n+\t\t\t struct ipa_agg_replacement_value *av,\n+\t\t\t bool *sc, bool *cc)\n+    : dom_walker (CDI_DOMINATORS), m_fbi (fbi), m_descriptors (descs),\n+      m_aggval (av), m_something_changed (sc), m_cfg_changed (cc) {}\n+\n+  virtual void before_dom_children (basic_block);\n+\n+private:\n+  struct func_body_info *m_fbi;\n+  vec<ipa_param_descriptor> m_descriptors;\n+  struct ipa_agg_replacement_value *m_aggval;\n+  bool *m_something_changed, *m_cfg_changed;\n+};\n+\n+void\n+ipcp_modif_dom_walker::before_dom_children (basic_block bb)\n+{\n+  gimple_stmt_iterator gsi;\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      struct ipa_agg_replacement_value *v;\n+      gimple stmt = gsi_stmt (gsi);\n+      tree rhs, val, t;\n+      HOST_WIDE_INT offset, size;\n+      int index;\n+      bool by_ref, vce;\n+\n+      if (!gimple_assign_load_p (stmt))\n+\tcontinue;\n+      rhs = gimple_assign_rhs1 (stmt);\n+      if (!is_gimple_reg_type (TREE_TYPE (rhs)))\n+\tcontinue;\n \n-/* Function body transformation phase.  */\n+      vce = false;\n+      t = rhs;\n+      while (handled_component_p (t))\n+\t{\n+\t  /* V_C_E can do things like convert an array of integers to one\n+\t     bigger integer and similar things we do not handle below.  */\n+\t  if (TREE_CODE (rhs) == VIEW_CONVERT_EXPR)\n+\t    {\n+\t      vce = true;\n+\t      break;\n+\t    }\n+\t  t = TREE_OPERAND (t, 0);\n+\t}\n+      if (vce)\n+\tcontinue;\n+\n+      if (!ipa_load_from_parm_agg_1 (m_fbi, m_descriptors, stmt, rhs, &index,\n+\t\t\t\t     &offset, &size, &by_ref))\n+\tcontinue;\n+      for (v = m_aggval; v; v = v->next)\n+\tif (v->index == index\n+\t    && v->offset == offset)\n+\t  break;\n+      if (!v\n+\t  || v->by_ref != by_ref\n+\t  || tree_to_shwi (TYPE_SIZE (TREE_TYPE (v->value))) != size)\n+\tcontinue;\n+\n+      gcc_checking_assert (is_gimple_ip_invariant (v->value));\n+      if (!useless_type_conversion_p (TREE_TYPE (rhs), TREE_TYPE (v->value)))\n+\t{\n+\t  if (fold_convertible_p (TREE_TYPE (rhs), v->value))\n+\t    val = fold_build1 (NOP_EXPR, TREE_TYPE (rhs), v->value);\n+\t  else if (TYPE_SIZE (TREE_TYPE (rhs))\n+\t\t   == TYPE_SIZE (TREE_TYPE (v->value)))\n+\t    val = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (rhs), v->value);\n+\t  else\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"    const \");\n+\t\t  print_generic_expr (dump_file, v->value, 0);\n+\t\t  fprintf (dump_file, \"  can't be converted to type of \");\n+\t\t  print_generic_expr (dump_file, rhs, 0);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n+\t      continue;\n+\t    }\n+\t}\n+      else\n+\tval = v->value;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Modifying stmt:\\n  \");\n+\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t}\n+      gimple_assign_set_rhs_from_tree (&gsi, val);\n+      update_stmt (stmt);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"into:\\n  \");\n+\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      *m_something_changed = true;\n+      if (maybe_clean_eh_stmt (stmt)\n+\t  && gimple_purge_dead_eh_edges (gimple_bb (stmt)))\n+\t*m_cfg_changed = true;\n+    }\n+\n+}\n+\n+/* IPCP transformation phase doing propagation of aggregate values.  */\n \n unsigned int\n ipcp_transform_function (struct cgraph_node *node)\n {\n   vec<ipa_param_descriptor> descriptors = vNULL;\n-  struct param_analysis_info *parms_ainfo;\n+  struct func_body_info fbi;\n   struct ipa_agg_replacement_value *aggval;\n-  gimple_stmt_iterator gsi;\n-  basic_block bb;\n   int param_count;\n   bool cfg_changed = false, something_changed = false;\n \n@@ -4871,102 +5144,27 @@ ipcp_transform_function (struct cgraph_node *node)\n   adjust_agg_replacement_values (node, aggval);\n   if (dump_file)\n     ipa_dump_agg_replacement_values (dump_file, aggval);\n-  parms_ainfo = XALLOCAVEC (struct param_analysis_info, param_count);\n-  memset (parms_ainfo, 0, sizeof (struct param_analysis_info) * param_count);\n-  descriptors.safe_grow_cleared (param_count);\n-  ipa_populate_param_decls (node, descriptors);\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-      {\n-\tstruct ipa_agg_replacement_value *v;\n-\tgimple stmt = gsi_stmt (gsi);\n-\ttree rhs, val, t;\n-\tHOST_WIDE_INT offset, size;\n-\tint index;\n-\tbool by_ref, vce;\n-\n-\tif (!gimple_assign_load_p (stmt))\n-\t  continue;\n-\trhs = gimple_assign_rhs1 (stmt);\n-\tif (!is_gimple_reg_type (TREE_TYPE (rhs)))\n-\t  continue;\n-\n-\tvce = false;\n-\tt = rhs;\n-\twhile (handled_component_p (t))\n-\t  {\n-\t    /* V_C_E can do things like convert an array of integers to one\n-               bigger integer and similar things we do not handle below.  */\n-            if (TREE_CODE (rhs) == VIEW_CONVERT_EXPR)\n-\t      {\n-\t\tvce = true;\n-\t\tbreak;\n-\t      }\n-\t    t = TREE_OPERAND (t, 0);\n-\t  }\n-\tif (vce)\n-\t  continue;\n \n-\tif (!ipa_load_from_parm_agg_1 (descriptors, parms_ainfo, stmt,\n-\t\t\t\t       rhs, &index, &offset, &size, &by_ref))\n-\t  continue;\n-\tfor (v = aggval; v; v = v->next)\n-\t  if (v->index == index\n-\t      && v->offset == offset)\n-\t    break;\n-\tif (!v\n-\t    || v->by_ref != by_ref\n-\t    || tree_to_shwi (TYPE_SIZE (TREE_TYPE (v->value))) != size)\n-\t  continue;\n+  fbi.node = node;\n+  fbi.info = NULL;\n+  fbi.bb_infos = vNULL;\n+  fbi.bb_infos.safe_grow_cleared (last_basic_block_for_fn (cfun));\n+  fbi.param_count = param_count;\n+  fbi.aa_walked = 0;\n \n-\tgcc_checking_assert (is_gimple_ip_invariant (v->value));\n-\tif (!useless_type_conversion_p (TREE_TYPE (rhs), TREE_TYPE (v->value)))\n-\t  {\n-\t    if (fold_convertible_p (TREE_TYPE (rhs), v->value))\n-\t      val = fold_build1 (NOP_EXPR, TREE_TYPE (rhs), v->value);\n-\t    else if (TYPE_SIZE (TREE_TYPE (rhs))\n-\t\t     == TYPE_SIZE (TREE_TYPE (v->value)))\n-\t      val = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (rhs), v->value);\n-\t    else\n-\t      {\n-\t\tif (dump_file)\n-\t\t  {\n-\t\t    fprintf (dump_file, \"    const \");\n-\t\t    print_generic_expr (dump_file, v->value, 0);\n-\t\t    fprintf (dump_file, \"  can't be converted to type of \");\n-\t\t    print_generic_expr (dump_file, rhs, 0);\n-\t\t    fprintf (dump_file, \"\\n\");\n-\t\t  }\n-\t\tcontinue;\n-\t      }\n-\t  }\n-\telse\n-\t  val = v->value;\n-\n-\tif (dump_file && (dump_flags & TDF_DETAILS))\n-\t  {\n-\t    fprintf (dump_file, \"Modifying stmt:\\n  \");\n-\t    print_gimple_stmt (dump_file, stmt, 0, 0);\n-\t  }\n-\tgimple_assign_set_rhs_from_tree (&gsi, val);\n-\tupdate_stmt (stmt);\n-\n-\tif (dump_file && (dump_flags & TDF_DETAILS))\n-\t  {\n-\t    fprintf (dump_file, \"into:\\n  \");\n-\t    print_gimple_stmt (dump_file, stmt, 0, 0);\n-\t    fprintf (dump_file, \"\\n\");\n-\t  }\n-\n-\tsomething_changed = true;\n-\tif (maybe_clean_eh_stmt (stmt)\n-\t    && gimple_purge_dead_eh_edges (gimple_bb (stmt)))\n-\t  cfg_changed = true;\n-      }\n+  descriptors.safe_grow_cleared (param_count);\n+  ipa_populate_param_decls (node, descriptors);\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  ipcp_modif_dom_walker (&fbi, descriptors, aggval, &something_changed,\n+\t\t\t &cfg_changed).walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \n+  int i;\n+  struct ipa_bb_info *bi;\n+  FOR_EACH_VEC_ELT (fbi.bb_infos, i, bi)\n+    free_ipa_bb_info (bi);\n+  fbi.bb_infos.release ();\n+  free_dominance_info (CDI_DOMINATORS);\n   (*ipa_node_agg_replacements)[node->uid] = NULL;\n-  free_parms_ainfo (parms_ainfo, param_count);\n   descriptors.release ();\n \n   if (!something_changed)"}, {"sha": "cb23698df634ce46718d7d68acb52bd06cf133c8", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aab5218424ce6d1a646dc9d564413359a352911/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aab5218424ce6d1a646dc9d564413359a352911/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=8aab5218424ce6d1a646dc9d564413359a352911", "patch": "@@ -371,8 +371,9 @@ struct ipa_node_params\n   /* If this node is an ipa-cp clone, these are the known values that describe\n      what it has been specialized for.  */\n   vec<tree> known_vals;\n-  /* Whether the param uses analysis has already been performed.  */\n-  unsigned uses_analysis_done : 1;\n+  /* Whether the param uses analysis and jump function computation has already\n+     been performed.  */\n+  unsigned analysis_done : 1;\n   /* Whether the function is enqueued in ipa-cp propagation stack.  */\n   unsigned node_enqueued : 1;\n   /* Whether we should create a specialized version based on values that are"}, {"sha": "c3a8797f26b1888df14e01c1041e61c869d6a835", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aab5218424ce6d1a646dc9d564413359a352911/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aab5218424ce6d1a646dc9d564413359a352911/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=8aab5218424ce6d1a646dc9d564413359a352911", "patch": "@@ -959,6 +959,12 @@ DEFPARAM (PARAM_IPA_CP_ARRAY_INDEX_HINT_BONUS,\n \t  \"index known.\",\n \t  48, 0, 0)\n \n+DEFPARAM (PARAM_IPA_MAX_AA_STEPS,\n+\t  \"ipa-max-aa-steps\",\n+\t  \"Maximum number of statements that will be visited by IPA formal \"\n+\t  \"parameter analysis based on alias analysis in any given function\",\n+\t  25000, 0, 0)\n+\n /* WHOPR partitioning configuration.  */\n \n DEFPARAM (PARAM_LTO_PARTITIONS,"}]}