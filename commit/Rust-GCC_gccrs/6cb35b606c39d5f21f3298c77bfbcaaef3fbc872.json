{"sha": "6cb35b606c39d5f21f3298c77bfbcaaef3fbc872", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNiMzViNjA2YzM5ZDVmMjFmMzI5OGM3N2JmYmNhYWVmM2ZiYzg3Mg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-06-07T16:02:08Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-06-07T16:02:08Z"}, "message": "c++: access of dtor named by qualified template-id [PR100918]\n\nHere, when resolving the destructor named by Inner<int>::~Inner<int>\n(which is valid until C++20) we end up in cp_parser_lookup_name called\nindirectly from cp_parser_template_id to look up the name Inner from\nthe scope Inner<int>.  The lookup naturally finds the injected-class-name,\nand because the flag is_template is true, we adjust this lookup result\nto the TEMPLATE_DECL Inner.  We then check access of this adjusted\nlookup result.  But this access check fails because the lookup scope is\nInner<int> and the context_for_name_lookup for the TEMPLATE_DECL is\nOuter (whereas for the injected-class-name it's also Inner<int>).\n\nThe simplest fix seems to be to check access of the original lookup\nresult (the injected-class-name) instead of the adjusted result (the\nTEMPLATE_DECL).  So this patch moves the access check in\ncp_parser_lookup_name to before the injected-class-name adjustment.\n\n\tPR c++/100918\n\ngcc/cp/ChangeLog:\n\n\t* parser.c (cp_parser_lookup_name): Check access of the lookup\n\tresult before we potentially adjust an injected-class-name to\n\tits TEMPLATE_DECL.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/template/access38.C: New test.", "tree": {"sha": "d32e70dfba2570fb65379116c64fe0d6b37f16cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d32e70dfba2570fb65379116c64fe0d6b37f16cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cb35b606c39d5f21f3298c77bfbcaaef3fbc872", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cb35b606c39d5f21f3298c77bfbcaaef3fbc872", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cb35b606c39d5f21f3298c77bfbcaaef3fbc872", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cb35b606c39d5f21f3298c77bfbcaaef3fbc872/comments", "author": null, "committer": null, "parents": [{"sha": "5e2e15f212e2458a1258b8c856895c755460bc6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e2e15f212e2458a1258b8c856895c755460bc6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e2e15f212e2458a1258b8c856895c755460bc6b"}], "stats": {"total": 39, "additions": 28, "deletions": 11}, "files": [{"sha": "24f248af11ced0343056578e2004e51c135b5ec1", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb35b606c39d5f21f3298c77bfbcaaef3fbc872/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb35b606c39d5f21f3298c77bfbcaaef3fbc872/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=6cb35b606c39d5f21f3298c77bfbcaaef3fbc872", "patch": "@@ -29505,6 +29505,19 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n   if (!decl || decl == error_mark_node)\n     return error_mark_node;\n \n+  /* If we have resolved the name of a member declaration, check to\n+     see if the declaration is accessible.  When the name resolves to\n+     set of overloaded functions, accessibility is checked when\n+     overload resolution is done.  If we have a TREE_LIST, then the lookup\n+     is either ambiguous or it found multiple injected-class-names, the\n+     accessibility of which is trivially satisfied.\n+\n+     During an explicit instantiation, access is not checked at all,\n+     as per [temp.explicit].  */\n+  if (DECL_P (decl))\n+    check_accessibility_of_qualified_id (decl, object_type, parser->scope,\n+\t\t\t\t\t tf_warning_or_error);\n+\n   /* Pull out the template from an injected-class-name (or multiple).  */\n   if (is_template)\n     decl = maybe_get_template_decl_from_type_decl (decl);\n@@ -29531,17 +29544,6 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t      || TREE_CODE (decl) == UNBOUND_CLASS_TEMPLATE\n \t      || BASELINK_P (decl));\n \n-  /* If we have resolved the name of a member declaration, check to\n-     see if the declaration is accessible.  When the name resolves to\n-     set of overloaded functions, accessibility is checked when\n-     overload resolution is done.\n-\n-     During an explicit instantiation, access is not checked at all,\n-     as per [temp.explicit].  */\n-  if (DECL_P (decl))\n-    check_accessibility_of_qualified_id (decl, object_type, parser->scope,\n-\t\t\t\t\t tf_warning_or_error);\n-\n   maybe_record_typedef_use (decl);\n \n   return cp_expr (decl, name_location);"}, {"sha": "488f8650c97943fec3a56fa6e53c4ef91ef8461a", "filename": "gcc/testsuite/g++.dg/template/access38.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb35b606c39d5f21f3298c77bfbcaaef3fbc872/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess38.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb35b606c39d5f21f3298c77bfbcaaef3fbc872/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess38.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Faccess38.C?ref=6cb35b606c39d5f21f3298c77bfbcaaef3fbc872", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/100918\n+\n+struct Outer {\n+  template<class T>\n+  struct Inner { ~Inner(); };\n+};\n+\n+template<>\n+Outer::Inner<int>::~Inner<int>() { } // { dg-error \"template-id\" \"\" { target c++20 } }\n+\n+template<class T>\n+Outer::Inner<T>::~Inner<T>() { } // { dg-error \"template-id\" \"\" { target c++20 } }\n+\n+Outer::Inner<int> x;\n+Outer::Inner<char> y;"}]}