{"sha": "aeecf17ca32de8fcec84ad49f7d76a582515e84b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVlY2YxN2NhMzJkZThmY2VjODRhZDQ5ZjdkNzZhNTgyNTE1ZTg0Yg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-05-12T10:59:38Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-05-12T10:59:38Z"}, "message": "utils.c (update_pointer_to): Return early if the old pointer already points to the new type.\n\n\t* gcc-interface/utils.c (update_pointer_to): Return early if the old\n\tpointer already points to the new type.  Chain the old pointer and its\n\tvariants at the end of new pointer's chain after updating them.\n\nFrom-SVN: r159309", "tree": {"sha": "dbc1e0c1a27d3848e0e0979f31d510f914bb8efd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbc1e0c1a27d3848e0e0979f31d510f914bb8efd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aeecf17ca32de8fcec84ad49f7d76a582515e84b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeecf17ca32de8fcec84ad49f7d76a582515e84b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aeecf17ca32de8fcec84ad49f7d76a582515e84b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeecf17ca32de8fcec84ad49f7d76a582515e84b/comments", "author": null, "committer": null, "parents": [{"sha": "33e42d568d6b5ddeffdea224cb763471cdf3ba1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33e42d568d6b5ddeffdea224cb763471cdf3ba1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33e42d568d6b5ddeffdea224cb763471cdf3ba1c"}], "stats": {"total": 186, "additions": 141, "deletions": 45}, "files": [{"sha": "b47a534ab9410c340c8fbfb8dc8ff0ee78bfaf80", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeecf17ca32de8fcec84ad49f7d76a582515e84b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeecf17ca32de8fcec84ad49f7d76a582515e84b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=aeecf17ca32de8fcec84ad49f7d76a582515e84b", "patch": "@@ -1,3 +1,9 @@\n+2010-05-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/utils.c (update_pointer_to): Return early if the old\n+\tpointer already points to the new type.  Chain the old pointer and its\n+\tvariants at the end of new pointer's chain after updating them.\n+\n 2010-05-10  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* exp_disp.adb (Make_Tags): Mark the imported view of dispatch tables"}, {"sha": "a3b3cba5bcc260b56464bc565a2d45c87ff922fc", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 79, "deletions": 45, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeecf17ca32de8fcec84ad49f7d76a582515e84b/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeecf17ca32de8fcec84ad49f7d76a582515e84b/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=aeecf17ca32de8fcec84ad49f7d76a582515e84b", "patch": "@@ -3380,14 +3380,12 @@ update_pointer_to (tree old_type, tree new_type)\n {\n   tree ptr = TYPE_POINTER_TO (old_type);\n   tree ref = TYPE_REFERENCE_TO (old_type);\n-  tree ptr1, ref1;\n-  tree type;\n+  tree t;\n \n   /* If this is the main variant, process all the other variants first.  */\n   if (TYPE_MAIN_VARIANT (old_type) == old_type)\n-    for (type = TYPE_NEXT_VARIANT (old_type); type;\n-\t type = TYPE_NEXT_VARIANT (type))\n-      update_pointer_to (type, new_type);\n+    for (t = TYPE_NEXT_VARIANT (old_type); t; t = TYPE_NEXT_VARIANT (t))\n+      update_pointer_to (t, new_type);\n \n   /* If no pointers and no references, we are done.  */\n   if (!ptr && !ref)\n@@ -3423,47 +3421,79 @@ update_pointer_to (tree old_type, tree new_type)\n   /* Otherwise, first handle the simple case.  */\n   if (TREE_CODE (new_type) != UNCONSTRAINED_ARRAY_TYPE)\n     {\n-      TYPE_POINTER_TO (new_type) = ptr;\n-      TYPE_REFERENCE_TO (new_type) = ref;\n+      tree new_ptr, new_ref;\n+\n+      /* If pointer or reference already points to new type, nothing to do.\n+\t This can happen as update_pointer_to can be invoked multiple times\n+\t on the same couple of types because of the type variants.  */\n+      if ((ptr && TREE_TYPE (ptr) == new_type)\n+\t  || (ref && TREE_TYPE (ref) == new_type))\n+\treturn;\n+\n+      /* Chain PTR and its variants at the end.  */\n+      new_ptr = TYPE_POINTER_TO (new_type);\n+      if (new_ptr)\n+\t{\n+\t  while (TYPE_NEXT_PTR_TO (new_ptr))\n+\t    new_ptr = TYPE_NEXT_PTR_TO (new_ptr);\n+\t  TYPE_NEXT_PTR_TO (new_ptr) = ptr;\n+\t}\n+      else\n+\tTYPE_POINTER_TO (new_type) = ptr;\n \n+      /* Now adjust them.  */\n       for (; ptr; ptr = TYPE_NEXT_PTR_TO (ptr))\n-\tfor (ptr1 = TYPE_MAIN_VARIANT (ptr); ptr1;\n-\t     ptr1 = TYPE_NEXT_VARIANT (ptr1))\n-\t  TREE_TYPE (ptr1) = new_type;\n+\tfor (t = TYPE_MAIN_VARIANT (ptr); t; t = TYPE_NEXT_VARIANT (t))\n+\t  TREE_TYPE (t) = new_type;\n \n+      /* Chain REF and its variants at the end.  */\n+      new_ref = TYPE_REFERENCE_TO (new_type);\n+      if (new_ref)\n+\t{\n+\t  while (TYPE_NEXT_REF_TO (new_ref))\n+\t    new_ref = TYPE_NEXT_REF_TO (new_ref);\n+\t  TYPE_NEXT_REF_TO (new_ref) = ref;\n+\t}\n+      else\n+\tTYPE_REFERENCE_TO (new_type) = ref;\n+\n+      /* Now adjust them.  */\n       for (; ref; ref = TYPE_NEXT_REF_TO (ref))\n-\tfor (ref1 = TYPE_MAIN_VARIANT (ref); ref1;\n-\t     ref1 = TYPE_NEXT_VARIANT (ref1))\n-\t  TREE_TYPE (ref1) = new_type;\n+\tfor (t = TYPE_MAIN_VARIANT (ref); t; t = TYPE_NEXT_VARIANT (t))\n+\t  TREE_TYPE (t) = new_type;\n     }\n \n-  /* Now deal with the unconstrained array case.  In this case the \"pointer\"\n-     is actually a RECORD_TYPE where both fields are pointers to dummy nodes.\n+  /* Now deal with the unconstrained array case.  In this case the pointer\n+     is actually a record where both fields are pointers to dummy nodes.\n      Turn them into pointers to the correct types using update_pointer_to.  */\n-  else if (!TYPE_IS_FAT_POINTER_P (ptr))\n-    gcc_unreachable ();\n-\n   else\n     {\n+      tree new_ptr = TYPE_MAIN_VARIANT (TYPE_POINTER_TO (new_type));\n       tree new_obj_rec = TYPE_OBJECT_RECORD_TYPE (new_type);\n-      tree array_field = TYPE_FIELDS (ptr);\n-      tree bounds_field = TREE_CHAIN (TYPE_FIELDS (ptr));\n-      tree new_ptr = TYPE_POINTER_TO (new_type);\n-      tree new_ref;\n-      tree var;\n+      tree array_field, bounds_field, new_ref, last;\n+\n+      gcc_assert (TYPE_IS_FAT_POINTER_P (ptr));\n+\n+      /* If PTR already points to new type, nothing to do.  This can happen\n+\t since update_pointer_to can be invoked multiple times on the same\n+\t couple of types because of the type variants.  */\n+      if (TYPE_UNCONSTRAINED_ARRAY (ptr) == new_type)\n+\treturn;\n+\n+      array_field = TYPE_FIELDS (ptr);\n+      bounds_field = TREE_CHAIN (array_field);\n \n       /* Make pointers to the dummy template point to the real template.  */\n       update_pointer_to\n \t(TREE_TYPE (TREE_TYPE (bounds_field)),\n \t TREE_TYPE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (new_ptr)))));\n \n-      /* The references to the template bounds present in the array type\n-\t are made through a PLACEHOLDER_EXPR of type NEW_PTR.  Since we\n-\t are updating PTR to make it a full replacement for NEW_PTR as\n-\t pointer to NEW_TYPE, we must rework the PLACEHOLDER_EXPR so as\n-\t to make it of type PTR.  */\n+      /* The references to the template bounds present in the array type use\n+\t the bounds field of NEW_PTR through a PLACEHOLDER_EXPR.  Since we\n+\t are going to merge PTR in NEW_PTR, we must rework these references\n+\t to use the bounds field of PTR instead.  */\n       new_ref = build3 (COMPONENT_REF, TREE_TYPE (bounds_field),\n-\t\t\tbuild0 (PLACEHOLDER_EXPR, ptr),\n+\t\t\tbuild0 (PLACEHOLDER_EXPR, new_ptr),\n \t\t\tbounds_field, NULL_TREE);\n \n       /* Create the new array for the new PLACEHOLDER_EXPR and make pointers\n@@ -3473,42 +3503,46 @@ update_pointer_to (tree old_type, tree new_type)\n \t substitute_in_type (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (new_ptr))),\n \t\t\t     TREE_CHAIN (TYPE_FIELDS (new_ptr)), new_ref));\n \n-      /* Make PTR the pointer to NEW_TYPE.  */\n-      TYPE_POINTER_TO (new_type) = TYPE_REFERENCE_TO (new_type)\n-\t= TREE_TYPE (new_type) = ptr;\n+      /* Merge PTR in NEW_PTR.  */\n+      DECL_FIELD_CONTEXT (array_field) = new_ptr;\n+      DECL_FIELD_CONTEXT (bounds_field) = new_ptr;\n+      for (t = new_ptr; t; last = t, t = TYPE_NEXT_VARIANT (t))\n+\tTYPE_FIELDS (t) = TYPE_FIELDS (ptr);\n+\n+      /* Chain PTR and its variants at the end.  */\n+      TYPE_NEXT_VARIANT (last) = TYPE_MAIN_VARIANT (ptr);\n+\n+      /* Now adjust them.  */\n+      for (t = TYPE_MAIN_VARIANT (ptr); t; t = TYPE_NEXT_VARIANT (t))\n+\t{\n+\t  TYPE_MAIN_VARIANT (t) = new_ptr;\n+\t  SET_TYPE_UNCONSTRAINED_ARRAY (t, new_type);\n+\t}\n \n       /* And show the original pointer NEW_PTR to the debugger.  This is the\n \t counterpart of the equivalent processing in gnat_pushdecl when the\n-\t unconstrained array type is frozen after access types to it.  Note\n-\t that update_pointer_to can be invoked multiple times on the same\n-\t couple of types because of the type variants.  */\n-      if (TYPE_NAME (ptr)\n-\t  && TREE_CODE (TYPE_NAME (ptr)) == TYPE_DECL\n-\t  && !DECL_ORIGINAL_TYPE (TYPE_NAME (ptr)))\n+\t unconstrained array type is frozen after access types to it.  */\n+      if (TYPE_NAME (ptr) && TREE_CODE (TYPE_NAME (ptr)) == TYPE_DECL)\n \t{\n \t  DECL_ORIGINAL_TYPE (TYPE_NAME (ptr)) = new_ptr;\n \t  DECL_ARTIFICIAL (TYPE_NAME (ptr)) = 0;\n \t}\n-      for (var = TYPE_MAIN_VARIANT (ptr); var; var = TYPE_NEXT_VARIANT (var))\n-\tSET_TYPE_UNCONSTRAINED_ARRAY (var, new_type);\n \n       /* Now handle updating the allocation record, what the thin pointer\n \t points to.  Update all pointers from the old record into the new\n \t one, update the type of the array field, and recompute the size.  */\n       update_pointer_to (TYPE_OBJECT_RECORD_TYPE (old_type), new_obj_rec);\n-\n       TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (new_obj_rec)))\n \t= TREE_TYPE (TREE_TYPE (array_field));\n \n       /* The size recomputation needs to account for alignment constraints, so\n \t we let layout_type work it out.  This will reset the field offsets to\n \t what they would be in a regular record, so we shift them back to what\n \t we want them to be for a thin pointer designated type afterwards.  */\n-      DECL_SIZE (TYPE_FIELDS (new_obj_rec)) = 0;\n-      DECL_SIZE (TREE_CHAIN (TYPE_FIELDS (new_obj_rec))) = 0;\n-      TYPE_SIZE (new_obj_rec) = 0;\n+      DECL_SIZE (TYPE_FIELDS (new_obj_rec)) = NULL_TREE;\n+      DECL_SIZE (TREE_CHAIN (TYPE_FIELDS (new_obj_rec))) = NULL_TREE;\n+      TYPE_SIZE (new_obj_rec) = NULL_TREE;\n       layout_type (new_obj_rec);\n-\n       shift_unc_components_for_thin_pointers (new_obj_rec);\n \n       /* We are done, at last.  */"}, {"sha": "a1275c845c7b6973426880b032ecc266fd7e7fec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeecf17ca32de8fcec84ad49f7d76a582515e84b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeecf17ca32de8fcec84ad49f7d76a582515e84b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aeecf17ca32de8fcec84ad49f7d76a582515e84b", "patch": "@@ -1,3 +1,9 @@\n+2010-05-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/lto8.adb: New test.\n+\t* gnat.dg/lto8_pkg.ad[sb]: New helper.\n+\t* gnat.dg/frame_overflow.adb: XFAIL if -flto is specified.\n+\n 2010-05-11  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/34272"}, {"sha": "055fa283f19f3a944923df60d229350c4e29457e", "filename": "gcc/testsuite/gnat.dg/frame_overflow.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeecf17ca32de8fcec84ad49f7d76a582515e84b/gcc%2Ftestsuite%2Fgnat.dg%2Fframe_overflow.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeecf17ca32de8fcec84ad49f7d76a582515e84b/gcc%2Ftestsuite%2Fgnat.dg%2Fframe_overflow.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fframe_overflow.adb?ref=aeecf17ca32de8fcec84ad49f7d76a582515e84b", "patch": "@@ -1,4 +1,5 @@\n -- { dg-do compile }\n+-- { dg-xfail-if \"missing late warning\" { *-*-* } { \"-flto\" } { \"\" } }\n \n with System;\n "}, {"sha": "68f9ea1197dff14070e74874c0052999fbb6bcb2", "filename": "gcc/testsuite/gnat.dg/lto8.adb", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeecf17ca32de8fcec84ad49f7d76a582515e84b/gcc%2Ftestsuite%2Fgnat.dg%2Flto8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeecf17ca32de8fcec84ad49f7d76a582515e84b/gcc%2Ftestsuite%2Fgnat.dg%2Flto8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Flto8.adb?ref=aeecf17ca32de8fcec84ad49f7d76a582515e84b", "patch": "@@ -0,0 +1,22 @@\n+-- { dg-do run }\n+-- { dg-options \"-gnatws\" }\n+-- { dg-options \"-gnatws -flto\" { target lto } }\n+\n+pragma Locking_Policy (Ceiling_Locking);\n+\n+with Lto8_Pkg; use Lto8_Pkg;\n+\n+procedure Lto8 is\n+   task Tsk is\n+      pragma Priority (10);\n+   end Tsk;\n+   task body Tsk is\n+   begin\n+      Sema2.Seize;\n+      Sema1.Seize;\n+   exception\n+      when Program_Error => null;\n+   end;\n+begin\n+   null;\n+end;"}, {"sha": "de4c2a75797723dbef6b01d5e834d716a7fb47f4", "filename": "gcc/testsuite/gnat.dg/lto8_pkg.adb", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeecf17ca32de8fcec84ad49f7d76a582515e84b/gcc%2Ftestsuite%2Fgnat.dg%2Flto8_pkg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeecf17ca32de8fcec84ad49f7d76a582515e84b/gcc%2Ftestsuite%2Fgnat.dg%2Flto8_pkg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Flto8_pkg.adb?ref=aeecf17ca32de8fcec84ad49f7d76a582515e84b", "patch": "@@ -0,0 +1,9 @@\n+-- { dg-options \"-gnatws\" }\n+\n+package body Lto8_Pkg is\n+\n+   protected body Protected_Queue_T is\n+      entry Seize when True is begin null; end;\n+   end Protected_Queue_T;\n+\n+end Lto8_Pkg;"}, {"sha": "d9ea584df773e03225a413cfdd129b2f0e2dbe00", "filename": "gcc/testsuite/gnat.dg/lto8_pkg.ads", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeecf17ca32de8fcec84ad49f7d76a582515e84b/gcc%2Ftestsuite%2Fgnat.dg%2Flto8_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeecf17ca32de8fcec84ad49f7d76a582515e84b/gcc%2Ftestsuite%2Fgnat.dg%2Flto8_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Flto8_pkg.ads?ref=aeecf17ca32de8fcec84ad49f7d76a582515e84b", "patch": "@@ -0,0 +1,18 @@\n+with System;\n+with Unchecked_Conversion;\n+\n+package Lto8_Pkg is\n+\n+   type Task_Priority_T is new Natural;\n+   function Convert_To_System_Priority is\n+     new Unchecked_Conversion (Task_Priority_T, System.Priority);\n+\n+   protected type Protected_Queue_T( PO_Priority : Task_Priority_T ) is\n+      pragma Priority (Convert_To_System_Priority (PO_Priority ));\n+      entry Seize;\n+   end Protected_Queue_T;\n+\n+   Sema1 : protected_Queue_T (5);\n+   Sema2 : protected_Queue_T (10);\n+\n+end Lto8_Pkg;"}]}