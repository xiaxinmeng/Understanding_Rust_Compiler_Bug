{"sha": "5c2ed969a2d58217797cf2e938c0f833a50d7cb4", "node_id": "C_kwDOANBUbNoAKDVjMmVkOTY5YTJkNTgyMTc3OTdjZjJlOTM4YzBmODMzYTUwZDdjYjQ", "commit": {"author": {"name": "omkar-mohanty", "email": "franzohouser@gmail.com", "date": "2023-02-16T04:40:24Z"}, "committer": {"name": "CohenArthur", "email": "arthur.cohen@embecosm.com", "date": "2023-02-28T12:45:10Z"}, "message": "Implement and test include_str eager expansion\n\nbuiltins: Implement eager expansion for include_str!()\n\ngcc/rust/ChangeLog:\n\n\t* expand/rust-macro-builtins.cc\n\t(MacroBuiltin::include_str_handler): eager expansion\n\t(make_macro_path_str): macto to string\n\t(parse_single_string_literal): check for eager invocation\n\t(MacroBuiltin::assert_handler): eager expansion\n\t(MacroBuiltin::include_bytes_handler): eager expansion\n\t(MacroBuiltin::include_str_handler): eager expansion\n\t(MacroBuiltin::compile_error_handler): eager expansion\n\t(MacroBuiltin::include_handler): eager expansion\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/builtin_macro_eager3.rs: New test.\n\nSigned-off-by: omkar-mohanty <franzohouser@gmail.com>", "tree": {"sha": "1d77bc7d33d4817231eed267165a4908e20aa530", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d77bc7d33d4817231eed267165a4908e20aa530"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c2ed969a2d58217797cf2e938c0f833a50d7cb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c2ed969a2d58217797cf2e938c0f833a50d7cb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c2ed969a2d58217797cf2e938c0f833a50d7cb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c2ed969a2d58217797cf2e938c0f833a50d7cb4/comments", "author": {"login": "omkar-mohanty", "id": 95670488, "node_id": "U_kgDOBbPQ2A", "avatar_url": "https://avatars.githubusercontent.com/u/95670488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/omkar-mohanty", "html_url": "https://github.com/omkar-mohanty", "followers_url": "https://api.github.com/users/omkar-mohanty/followers", "following_url": "https://api.github.com/users/omkar-mohanty/following{/other_user}", "gists_url": "https://api.github.com/users/omkar-mohanty/gists{/gist_id}", "starred_url": "https://api.github.com/users/omkar-mohanty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/omkar-mohanty/subscriptions", "organizations_url": "https://api.github.com/users/omkar-mohanty/orgs", "repos_url": "https://api.github.com/users/omkar-mohanty/repos", "events_url": "https://api.github.com/users/omkar-mohanty/events{/privacy}", "received_events_url": "https://api.github.com/users/omkar-mohanty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce43f55e9976929f9ff2388c8971a65afd24e26d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce43f55e9976929f9ff2388c8971a65afd24e26d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce43f55e9976929f9ff2388c8971a65afd24e26d"}], "stats": {"total": 176, "additions": 126, "deletions": 50}, "files": [{"sha": "d7f15784cebd6965b3b4d9d82e8435963b9956a2", "filename": "gcc/rust/expand/rust-macro-builtins.cc", "status": "modified", "additions": 110, "deletions": 50, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c2ed969a2d58217797cf2e938c0f833a50d7cb4/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c2ed969a2d58217797cf2e938c0f833a50d7cb4/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-builtins.cc?ref=5c2ed969a2d58217797cf2e938c0f833a50d7cb4", "patch": "@@ -16,42 +16,24 @@\n // along with GCC; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n+#include \"rust-system.h\"\n #include \"rust-macro-builtins.h\"\n+#include \"rust-ast-fragment.h\"\n #include \"rust-ast.h\"\n+#include \"rust-attribute-visitor.h\"\n #include \"rust-diagnostics.h\"\n+#include \"rust-early-name-resolver.h\"\n #include \"rust-expr.h\"\n-#include \"rust-session-manager.h\"\n-#include \"rust-macro-invoc-lexer.h\"\n #include \"rust-lex.h\"\n+#include \"rust-macro-invoc-lexer.h\"\n+#include \"rust-macro.h\"\n #include \"rust-parse.h\"\n-#include \"rust-early-name-resolver.h\"\n-#include \"rust-attribute-visitor.h\"\n+#include \"rust-session-manager.h\"\n \n namespace Rust {\n namespace {\n-\n-/**\n- * Shorthand function for creating unique_ptr tokens\n- */\n-static std::unique_ptr<AST::Token>\n-make_token (const TokenPtr tok)\n-{\n-  return std::unique_ptr<AST::Token> (new AST::Token (tok));\n-}\n-\n-std::unique_ptr<AST::Expr>\n-make_string (Location locus, std::string value)\n-{\n-  return std::unique_ptr<AST::Expr> (\n-    new AST::LiteralExpr (value, AST::Literal::STRING,\n-\t\t\t  PrimitiveCoreType::CORETYPE_STR, {}, locus));\n-}\n-\n-// TODO: Is this correct?\n-static AST::Fragment\n-make_eager_builtin_invocation (\n-  AST::BuiltinMacro kind, Location locus, AST::DelimTokenTree arguments,\n-  std::vector<std::unique_ptr<AST::MacroInvocation>> &&pending_invocations)\n+std::string\n+make_macro_path_str (AST::BuiltinMacro kind)\n {\n   std::string path_str;\n \n@@ -93,6 +75,48 @@ make_eager_builtin_invocation (\n       break;\n     }\n \n+  return path_str;\n+}\n+\n+static std::vector<std::unique_ptr<AST::MacroInvocation>>\n+check_for_eager_invocations (\n+  std::vector<std::unique_ptr<AST::Expr>> &expressions)\n+{\n+  std::vector<std::unique_ptr<AST::MacroInvocation>> pending;\n+\n+  for (auto &expr : expressions)\n+    if (expr->get_ast_kind () == AST::Kind::MACRO_INVOCATION)\n+      pending.emplace_back (std::unique_ptr<AST::MacroInvocation> (\n+\tstatic_cast<AST::MacroInvocation *> (expr->clone_expr ().release ())));\n+\n+  return pending;\n+}\n+\n+/**\n+ * Shorthand function for creating unique_ptr tokens\n+ */\n+static std::unique_ptr<AST::Token>\n+make_token (const TokenPtr tok)\n+{\n+  return std::unique_ptr<AST::Token> (new AST::Token (tok));\n+}\n+\n+std::unique_ptr<AST::Expr>\n+make_string (Location locus, std::string value)\n+{\n+  return std::unique_ptr<AST::Expr> (\n+    new AST::LiteralExpr (value, AST::Literal::STRING,\n+\t\t\t  PrimitiveCoreType::CORETYPE_STR, {}, locus));\n+}\n+\n+// TODO: Is this correct?\n+static AST::Fragment\n+make_eager_builtin_invocation (\n+  AST::BuiltinMacro kind, Location locus, AST::DelimTokenTree arguments,\n+  std::vector<std::unique_ptr<AST::MacroInvocation>> &&pending_invocations)\n+{\n+  auto path_str = make_macro_path_str (kind);\n+\n   std::unique_ptr<AST::Expr> node = AST::MacroInvocation::Builtin (\n     kind,\n     AST::MacroInvocData (AST::SimplePath (\n@@ -195,8 +219,9 @@ try_expand_many_expr (Parser<MacroInvocLexer> &parser,\n    and return the LiteralExpr for it. Allow for an optional trailing comma,\n    but otherwise enforce that these are the only tokens.  */\n \n-std::unique_ptr<AST::LiteralExpr>\n-parse_single_string_literal (AST::DelimTokenTree &invoc_token_tree,\n+std::unique_ptr<AST::Expr>\n+parse_single_string_literal (AST::BuiltinMacro kind,\n+\t\t\t     AST::DelimTokenTree &invoc_token_tree,\n \t\t\t     Location invoc_locus, MacroExpander *expander)\n {\n   MacroInvocLexer lex (invoc_token_tree.to_token_stream ());\n@@ -205,6 +230,7 @@ parse_single_string_literal (AST::DelimTokenTree &invoc_token_tree,\n   auto last_token_id = macro_end_token (invoc_token_tree, parser);\n \n   std::unique_ptr<AST::LiteralExpr> lit_expr = nullptr;\n+  std::unique_ptr<AST::MacroInvocation> macro_invoc = nullptr;\n \n   if (parser.peek_current_token ()->get_id () == STRING_LITERAL)\n     {\n@@ -219,11 +245,42 @@ parse_single_string_literal (AST::DelimTokenTree &invoc_token_tree,\n   else if (parser.peek_current_token ()->get_id () == last_token_id)\n     rust_error_at (invoc_locus, \"macro takes 1 argument\");\n   else\n-    rust_error_at (invoc_locus, \"argument must be a string literal\");\n+    {\n+      macro_invoc = parser.parse_macro_invocation (AST::AttrVec ());\n+\n+      parser.maybe_skip_token (COMMA);\n+      if (parser.peek_current_token ()->get_id () != last_token_id)\n+\t{\n+\t  lit_expr = nullptr;\n+\t  rust_error_at (invoc_locus, \"macro takes 1 argument\");\n+\t}\n+\n+      if (macro_invoc != nullptr)\n+\t{\n+\t  auto path_str = make_macro_path_str (kind);\n+\n+\t  auto pending_invocations\n+\t    = std::vector<std::unique_ptr<AST::MacroInvocation>> ();\n+\n+\t  pending_invocations.push_back (std::move (macro_invoc));\n+\n+\t  return AST::MacroInvocation::Builtin (\n+\t    kind,\n+\t    AST::MacroInvocData (AST::SimplePath ({AST::SimplePathSegment (\n+\t\t\t\t   path_str, invoc_locus)}),\n+\t\t\t\t std::move (invoc_token_tree)),\n+\t    {}, invoc_locus, std::move (pending_invocations));\n+\t}\n+      else\n+\t{\n+\t  rust_error_at (invoc_locus, \"argument must be a string literal or a \"\n+\t\t\t\t      \"macro which expands to a string\");\n+\t}\n+    }\n \n   parser.skip_token (last_token_id);\n \n-  return lit_expr;\n+  return std::unique_ptr<AST::Expr> (std::move (lit_expr));\n }\n \n /* Treat PATH as a path relative to the source file currently being\n@@ -278,7 +335,7 @@ load_file_bytes (const char *filename)\n } // namespace\n \n AST::Fragment\n-MacroBuiltin::assert_handler (Location, AST::MacroInvocData &)\n+MacroBuiltin::assert_handler (Location invoc_locus, AST::MacroInvocData &invoc)\n {\n   rust_debug (\"assert!() called\");\n \n@@ -323,11 +380,14 @@ MacroBuiltin::include_bytes_handler (Location invoc_locus,\n   /* Get target filename from the macro invocation, which is treated as a path\n      relative to the include!-ing file (currently being compiled).  */\n   auto lit_expr\n-    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus,\n+    = parse_single_string_literal (AST::BuiltinMacro::IncludeBytes,\n+\t\t\t\t   invoc.get_delim_tok_tree (), invoc_locus,\n \t\t\t\t   invoc.get_expander ());\n   if (lit_expr == nullptr)\n     return AST::Fragment::create_error ();\n \n+  rust_assert (lit_expr->is_literal ());\n+\n   std::string target_filename\n     = source_relative_path (lit_expr->as_string (), invoc_locus);\n \n@@ -379,11 +439,19 @@ MacroBuiltin::include_str_handler (Location invoc_locus,\n   /* Get target filename from the macro invocation, which is treated as a path\n      relative to the include!-ing file (currently being compiled).  */\n   auto lit_expr\n-    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus,\n+    = parse_single_string_literal (AST::BuiltinMacro::IncludeStr,\n+\t\t\t\t   invoc.get_delim_tok_tree (), invoc_locus,\n \t\t\t\t   invoc.get_expander ());\n   if (lit_expr == nullptr)\n     return AST::Fragment::create_error ();\n \n+  if (!lit_expr->is_literal ())\n+    {\n+      auto token_tree = invoc.get_delim_tok_tree ();\n+      return AST::Fragment ({AST::SingleASTNode (std::move (lit_expr))},\n+\t\t\t    token_tree.to_token_stream ());\n+    }\n+\n   std::string target_filename\n     = source_relative_path (lit_expr->as_string (), invoc_locus);\n \n@@ -453,31 +521,20 @@ MacroBuiltin::compile_error_handler (Location invoc_locus,\n \t\t\t\t     AST::MacroInvocData &invoc)\n {\n   auto lit_expr\n-    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus,\n+    = parse_single_string_literal (AST::BuiltinMacro::CompileError,\n+\t\t\t\t   invoc.get_delim_tok_tree (), invoc_locus,\n \t\t\t\t   invoc.get_expander ());\n   if (lit_expr == nullptr)\n     return AST::Fragment::create_error ();\n \n+  rust_assert (lit_expr->is_literal ());\n+\n   std::string error_string = lit_expr->as_string ();\n   rust_error_at (invoc_locus, \"%s\", error_string.c_str ());\n \n   return AST::Fragment::create_error ();\n }\n \n-static std::vector<std::unique_ptr<AST::MacroInvocation>>\n-check_for_eager_invocations (\n-  std::vector<std::unique_ptr<AST::Expr>> &expressions)\n-{\n-  std::vector<std::unique_ptr<AST::MacroInvocation>> pending;\n-\n-  for (auto &expr : expressions)\n-    if (expr->get_ast_kind () == AST::Kind::MACRO_INVOCATION)\n-      pending.emplace_back (std::unique_ptr<AST::MacroInvocation> (\n-\tstatic_cast<AST::MacroInvocation *> (expr->clone_expr ().release ())));\n-\n-  return pending;\n-}\n-\n /* Expand builtin macro concat!(), which joins all the literal parameters\n    into a string with no delimiter. */\n \n@@ -707,11 +764,14 @@ MacroBuiltin::include_handler (Location invoc_locus, AST::MacroInvocData &invoc)\n   /* Get target filename from the macro invocation, which is treated as a path\n      relative to the include!-ing file (currently being compiled).  */\n   auto lit_expr\n-    = parse_single_string_literal (invoc.get_delim_tok_tree (), invoc_locus,\n+    = parse_single_string_literal (AST::BuiltinMacro::Include,\n+\t\t\t\t   invoc.get_delim_tok_tree (), invoc_locus,\n \t\t\t\t   invoc.get_expander ());\n   if (lit_expr == nullptr)\n     return AST::Fragment::create_error ();\n \n+  rust_assert (lit_expr->is_literal ());\n+\n   std::string filename\n     = source_relative_path (lit_expr->as_string (), invoc_locus);\n   auto target_filename"}, {"sha": "3b62cfe7c83400f58a79cef871fee9b13543b082", "filename": "gcc/testsuite/rust/compile/builtin_macro_eager3.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c2ed969a2d58217797cf2e938c0f833a50d7cb4/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_eager3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c2ed969a2d58217797cf2e938c0f833a50d7cb4/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_eager3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbuiltin_macro_eager3.rs?ref=5c2ed969a2d58217797cf2e938c0f833a50d7cb4", "patch": "@@ -0,0 +1,16 @@\n+#![feature(rustc_attrs)]\n+\n+#[rustc_builtin_macro]\n+macro_rules! include_str {\n+  () => {{}};\n+}\n+\n+macro_rules! file1 {\n+    () => {\n+        \"builtin_macro_include_str.rs\"\n+    };\n+}\n+\n+fn main () {\n+  include_str!(file1!()); // ok\n+}"}]}