{"sha": "01f62f016bb811b0010a36d058c660882a92ca1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFmNjJmMDE2YmI4MTFiMDAxMGEzNmQwNThjNjYwODgyYTkyY2ExYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-07-26T20:36:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-07-26T20:36:01Z"}, "message": "rtl.h (cleanup_barriers): Declare.\n\n\t* rtl.h (cleanup_barriers): Declare.\n\t* jump.c (cleanup_barriers): New function.\n\t* toplev.c (rest_of_compilation): Call cleanup_barriers\n\tbefore loop optimizer and after bb_reorder.\n\n\t* flow.c (back_edge_of_syntactic_loop_p): New.\n\t(split_edge): Use it.\n\nFrom-SVN: r44409", "tree": {"sha": "4d6e8197e32e92b663df66e7f3d07be1ccf41202", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d6e8197e32e92b663df66e7f3d07be1ccf41202"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01f62f016bb811b0010a36d058c660882a92ca1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01f62f016bb811b0010a36d058c660882a92ca1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01f62f016bb811b0010a36d058c660882a92ca1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01f62f016bb811b0010a36d058c660882a92ca1c/comments", "author": null, "committer": null, "parents": [{"sha": "aa069f77b2591aed51274befe68aeef5c903f45c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa069f77b2591aed51274befe68aeef5c903f45c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa069f77b2591aed51274befe68aeef5c903f45c"}], "stats": {"total": 69, "additions": 68, "deletions": 1}, "files": [{"sha": "fddead1cf2ebc561bedb1857b40461e2f5cec696", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01f62f016bb811b0010a36d058c660882a92ca1c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01f62f016bb811b0010a36d058c660882a92ca1c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01f62f016bb811b0010a36d058c660882a92ca1c", "patch": "@@ -1,3 +1,13 @@\n+Thu Jul 26 22:30:22 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* rtl.h (cleanup_barriers): Declare.\n+\t* jump.c (cleanup_barriers): New function.\n+\t* toplev.c (rest_of_compilation): Call cleanup_barriers\n+\tbefore loop optimizer and after bb_reorder.\n+\n+\t* flow.c (back_edge_of_syntactic_loop_p): New.\n+\t(split_edge): Use it.\n+\n 2001-07-26  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* glimits.h (_MACH_MACHLIMITS_H_): Delete."}, {"sha": "248d4296fb4afa5329376f832858cb24bee6550e", "filename": "gcc/flow.c", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01f62f016bb811b0010a36d058c660882a92ca1c/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01f62f016bb811b0010a36d058c660882a92ca1c/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=01f62f016bb811b0010a36d058c660882a92ca1c", "patch": "@@ -482,6 +482,7 @@ static void flow_loops_tree_build\tPARAMS ((struct loops *));\n static int flow_loop_level_compute\tPARAMS ((struct loop *, int));\n static int flow_loops_level_compute\tPARAMS ((struct loops *));\n static void delete_dead_jumptables\tPARAMS ((void));\n+static bool back_edge_of_syntactic_loop_p PARAMS ((basic_block, basic_block));\n \f\n /* Find basic blocks of the current function.\n    F is the first insn of the function and NREGS the number of register\n@@ -1968,6 +1969,30 @@ redirect_edge_and_branch_force (e, target)\n   return new_bb;\n }\n \n+/* Helper function for split_edge.  Return true in case edge BB2 to BB1\n+   is back edge of syntactic loop.  */\n+static bool\n+back_edge_of_syntactic_loop_p (bb1, bb2)\n+\tbasic_block bb1, bb2;\n+{\n+  rtx insn;\n+  int count;\n+  if (bb1->index > bb2->index)\n+    return false;\n+  if (bb1->index == bb2->index)\n+    return true;\n+  for (insn = bb1->end; insn != bb2->head && count >= 0;\n+       insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == NOTE)\n+      {\n+\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\t  count++;\n+\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n+\t  count--;\n+      }\n+  return count >= 0;\n+}\n+\n /* Split a (typically critical) edge.  Return the new block.\n    Abort on abnormal edges.\n \n@@ -2115,7 +2140,8 @@ split_edge (edge_in)\n   if (old_succ != EXIT_BLOCK_PTR\n       && PREV_INSN (old_succ->head)\n       && GET_CODE (PREV_INSN (old_succ->head)) == NOTE\n-      && NOTE_LINE_NUMBER (PREV_INSN (old_succ->head)) == NOTE_INSN_LOOP_BEG)\n+      && NOTE_LINE_NUMBER (PREV_INSN (old_succ->head)) == NOTE_INSN_LOOP_BEG\n+      && !back_edge_of_syntactic_loop_p (old_succ, old_pred))\n     bb_note = emit_note_before (NOTE_INSN_BASIC_BLOCK,\n \t\t\t\tPREV_INSN (old_succ->head));\n   else if (old_succ != EXIT_BLOCK_PTR)"}, {"sha": "e77ba5637db1b9e194c0e0baa5d18073cce3cebf", "filename": "gcc/jump.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01f62f016bb811b0010a36d058c660882a92ca1c/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01f62f016bb811b0010a36d058c660882a92ca1c/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=01f62f016bb811b0010a36d058c660882a92ca1c", "patch": "@@ -100,6 +100,32 @@ rebuild_jump_labels (f)\n       LABEL_NUSES (XEXP (insn, 0))++;\n }\n \f\n+/* Some old code expects exactly one BARRIER as the NEXT_INSN of a\n+   non-fallthru insn.  This is not generally true, as multiple barriers\n+   may have crept in, or the BARRIER may be separated from the last\n+   real insn by one or more NOTEs.\n+\n+   This simple pass moves barriers and removes duplicates so that the\n+   old code is happy.\n+ */\n+void\n+cleanup_barriers ()\n+{\n+  rtx insn, next, prev;\n+  for (insn = get_insns (); insn; insn = next)\n+    {\n+      next = NEXT_INSN (insn);\n+      if (GET_CODE (insn) == BARRIER)\n+\t{\n+\t  prev = prev_nonnote_insn (insn);\n+\t  if (GET_CODE (prev) == BARRIER)\n+\t    delete_barrier (insn);\n+\t  else if (prev != PREV_INSN (insn))\n+\t    reorder_insns (insn, insn, prev);\n+\t}\n+    }\n+}\n+\f\n void\n copy_loop_headers (f)\n      rtx f;"}, {"sha": "7cacfabcccacb51ac3eed226f2462101fe8eea30", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01f62f016bb811b0010a36d058c660882a92ca1c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01f62f016bb811b0010a36d058c660882a92ca1c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=01f62f016bb811b0010a36d058c660882a92ca1c", "patch": "@@ -1286,6 +1286,7 @@ extern enum rtx_code swap_condition\tPARAMS ((enum rtx_code));\n extern enum rtx_code unsigned_condition\tPARAMS ((enum rtx_code));\n extern enum rtx_code signed_condition\tPARAMS ((enum rtx_code));\n extern void mark_jump_label\t\tPARAMS ((rtx, rtx, int));\n+extern void cleanup_barriers\t\tPARAMS ((void));\n \n /* In jump.c */\n extern rtx squeeze_notes\t\tPARAMS ((rtx, rtx));"}, {"sha": "21d4fbbcbd0616d6ca2c3c077851870908297a42", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01f62f016bb811b0010a36d058c660882a92ca1c/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01f62f016bb811b0010a36d058c660882a92ca1c/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=01f62f016bb811b0010a36d058c660882a92ca1c", "patch": "@@ -3096,6 +3096,8 @@ rest_of_compilation (decl)\n \n       if (flag_rerun_loop_opt)\n \t{\n+\t  cleanup_barriers ();\n+\n \t  /* We only want to perform unrolling once.  */\n \n \t  loop_optimize (insns, rtl_dump_file, 0);\n@@ -3110,6 +3112,7 @@ rest_of_compilation (decl)\n \t\t  analysis code depends on this information.  */\n \t  reg_scan (insns, max_reg_num (), 1);\n \t}\n+      cleanup_barriers ();\n       loop_optimize (insns, rtl_dump_file,\n \t\t     (flag_unroll_loops ? LOOP_UNROLL : 0) | LOOP_BCT);\n \n@@ -3614,6 +3617,7 @@ rest_of_compilation (decl)\n   /* CFG no longer kept up to date.  */\n \n   purge_line_number_notes (insns);\n+  cleanup_barriers ();\n \n   /* If a scheduling pass for delayed branches is to be done,\n      call the scheduling code.  */"}]}