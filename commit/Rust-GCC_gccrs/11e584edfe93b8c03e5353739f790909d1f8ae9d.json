{"sha": "11e584edfe93b8c03e5353739f790909d1f8ae9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFlNTg0ZWRmZTkzYjhjMDNlNTM1MzczOWY3OTA5MDlkMWY4YWU5ZA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2004-01-08T05:27:39Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2004-01-08T05:27:39Z"}, "message": "re PR libgcj/13439 (gij VerifyError; works with JDK 1.4)\n\n\tPR libgcj/13439:\n\t* verify.cc (state::merge): Copy changed locals out of subroutine\n\tin NO_STACK case.\n\t(state::FLAG_CHANGED): New const.\n\t(state::FLAG_UNUSED): Likewise.\n\t(state::local_changed): Removed.  Updated all users.\n\t(state::flags): New field.\n\t(state::merge): Added jsr_semantics argument, more logic.\n\t(push_jump_merge): Added jsr_semantics argument.\n\t(handle_jsr_insn): Set jsr_semantics on push_jump_merge when\n\tmerging through the jsr instruction.\n\nFrom-SVN: r75533", "tree": {"sha": "dbfb232130bce7a7e8d98e5d14fe1dee7801fd37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbfb232130bce7a7e8d98e5d14fe1dee7801fd37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11e584edfe93b8c03e5353739f790909d1f8ae9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11e584edfe93b8c03e5353739f790909d1f8ae9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11e584edfe93b8c03e5353739f790909d1f8ae9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11e584edfe93b8c03e5353739f790909d1f8ae9d/comments", "author": null, "committer": null, "parents": [{"sha": "ce972ee8f60c89b666dcebe2ef5ea5df0514c095", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce972ee8f60c89b666dcebe2ef5ea5df0514c095", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce972ee8f60c89b666dcebe2ef5ea5df0514c095"}], "stats": {"total": 147, "additions": 121, "deletions": 26}, "files": [{"sha": "39a5669442a6266b3716f3c5fd2e14b47960e831", "filename": "libjava/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11e584edfe93b8c03e5353739f790909d1f8ae9d/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11e584edfe93b8c03e5353739f790909d1f8ae9d/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=11e584edfe93b8c03e5353739f790909d1f8ae9d", "patch": "@@ -1,3 +1,17 @@\n+2004-01-07  Tom Tromey  <tromey@redhat.com>\n+\n+\tPR libgcj/13439:\n+\t* verify.cc (state::merge): Copy changed locals out of subroutine\n+\tin NO_STACK case.\n+\t(state::FLAG_CHANGED): New const.\n+\t(state::FLAG_UNUSED): Likewise.\n+\t(state::local_changed): Removed.  Updated all users.\n+\t(state::flags): New field.\n+\t(state::merge): Added jsr_semantics argument, more logic.\n+\t(push_jump_merge): Added jsr_semantics argument.\n+\t(handle_jsr_insn): Set jsr_semantics on push_jump_merge when\n+\tmerging through the jsr instruction.\n+\n 2004-01-07  Tom Tromey  <tromey@redhat.com>\n \n \t* scripts/MakeDefaultMimeTypes.java: Use \\n, not"}, {"sha": "f91df81cde1090475ee77bb8a23399c2c2defe5f", "filename": "libjava/verify.cc", "status": "modified", "additions": 107, "deletions": 26, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11e584edfe93b8c03e5353739f790909d1f8ae9d/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11e584edfe93b8c03e5353739f790909d1f8ae9d/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=11e584edfe93b8c03e5353739f790909d1f8ae9d", "patch": "@@ -895,9 +895,9 @@ class _Jv_BytecodeVerifier\n     type *stack;\n     // The local variables.\n     type *locals;\n-    // This is used in subroutines to keep track of which local\n-    // variables have been accessed.\n-    bool *local_changed;\n+    // Flags are used in subroutines to keep track of which local\n+    // variables have been accessed.  They are also used after \n+    char *flags;\n     // If not 0, then we are in a subroutine.  The value is the PC of\n     // the subroutine's entry point.  We can use 0 as an exceptional\n     // value because PC=0 can never be a subroutine.\n@@ -930,12 +930,21 @@ class _Jv_BytecodeVerifier\n     // `ret'.  See handle_jsr_insn for more information.\n     static const int NO_STACK = -1;\n \n+    // This flag indicates that the local was changed in this\n+    // subroutine.\n+    static const int FLAG_CHANGED = 1;\n+    // This is set only on the flags of the state of an instruction\n+    // directly following a \"jsr\".  It indicates that the local\n+    // variable was changed by the subroutine corresponding to the\n+    // \"jsr\".\n+    static const int FLAG_USED = 2;\n+\n     state ()\n       : this_type ()\n     {\n       stack = NULL;\n       locals = NULL;\n-      local_changed = NULL;\n+      flags = NULL;\n       seen_subrs = NULL;\n     }\n \n@@ -948,12 +957,12 @@ class _Jv_BytecodeVerifier\n       for (int i = 0; i < max_stack; ++i)\n \tstack[i] = unsuitable_type;\n       locals = new type[max_locals];\n-      local_changed = (bool *) _Jv_Malloc (sizeof (bool) * max_locals);\n+      flags = (char *) _Jv_Malloc (sizeof (char) * max_locals);\n       seen_subrs = NULL;\n       for (int i = 0; i < max_locals; ++i)\n \t{\n \t  locals[i] = unsuitable_type;\n-\t  local_changed[i] = false;\n+\t  flags[i] = 0;\n \t}\n       next = INVALID;\n       subroutine = 0;\n@@ -964,7 +973,7 @@ class _Jv_BytecodeVerifier\n     {\n       stack = new type[max_stack];\n       locals = new type[max_locals];\n-      local_changed = (bool *) _Jv_Malloc (sizeof (bool) * max_locals);\n+      flags = (char *) _Jv_Malloc (sizeof (char) * max_locals);\n       seen_subrs = NULL;\n       copy (orig, max_stack, max_locals, ret_semantics);\n       next = INVALID;\n@@ -976,8 +985,8 @@ class _Jv_BytecodeVerifier\n \tdelete[] stack;\n       if (locals)\n \tdelete[] locals;\n-      if (local_changed)\n-\t_Jv_Free (local_changed);\n+      if (flags)\n+\t_Jv_Free (flags);\n       clean_subrs ();\n     }\n \n@@ -1025,12 +1034,29 @@ class _Jv_BytecodeVerifier\n \t{\n \t  // See push_jump_merge to understand this case.\n \t  if (ret_semantics)\n-\t    locals[i] = type (copy->local_changed[i]\n-\t\t\t      ? copy->locals[i]\n-\t\t\t      : unused_by_subroutine_type);\n+\t    {\n+\t      if ((copy->flags[i] & FLAG_CHANGED))\n+\t\t{\n+\t\t  // Changed in the subroutine, so we copy it here.\n+\t\t  locals[i] = copy->locals[i];\n+\t\t  flags[i] |= FLAG_USED;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  // Not changed in the subroutine.  Use a special\n+\t\t  // type so the coming merge will overwrite.\n+\t\t  locals[i] = type (unused_by_subroutine_type);\n+\t\t}\n+\t    }\n \t  else\n \t    locals[i] = copy->locals[i];\n-\t  local_changed[i] = subroutine ? copy->local_changed[i] : false;\n+\n+\t  // Clear the flag unconditionally just so printouts look ok,\n+\t  // then only set it if we're still in a subroutine and it\n+\t  // did in fact change.\n+\t  flags[i] &= ~FLAG_CHANGED;\n+\t  if (subroutine && (copy->flags[i] & FLAG_CHANGED) != 0)\n+\t    flags[i] |= FLAG_CHANGED;\n \t}\n \n       clean_subrs ();\n@@ -1064,7 +1090,7 @@ class _Jv_BytecodeVerifier\n       // nested subroutines, this information will be merged back into\n       // parent by the `ret'.\n       for (int i = 0; i < max_locals; ++i)\n-\tlocal_changed[i] = false;\n+\tflags[i] &= ~FLAG_CHANGED;\n     }\n \n     // Indicate that we've been in this this subroutine.\n@@ -1080,7 +1106,8 @@ class _Jv_BytecodeVerifier\n     // state.  Returns true if the new state was in fact changed.\n     // Will throw an exception if the states are not mergeable.\n     bool merge (state *state_old, bool ret_semantics,\n-\t\tint max_locals, _Jv_BytecodeVerifier *verifier)\n+\t\tint max_locals, _Jv_BytecodeVerifier *verifier,\n+\t\tbool jsr_semantics = false)\n     {\n       bool changed = false;\n \n@@ -1122,11 +1149,21 @@ class _Jv_BytecodeVerifier\n \t    }\n \t}\n \n-      // Merge stacks.  Special handling for NO_STACK case.\n+      // Merge stacks, including special handling for NO_STACK case.\n+      // If the destination is NO_STACK, this means it is the\n+      // instruction following a \"jsr\" and has not yet been processed\n+      // in any way.  In this situation, if we are currently\n+      // processing a \"ret\", then we must *copy* any locals changed in\n+      // the subroutine into the current state.  Merging in this\n+      // situation is incorrect because the locals we've noted didn't\n+      // come real program flow, they are just an artifact of how\n+      // we've chosen to handle the post-jsr state.\n+      bool copy_in_locals = ret_semantics && stacktop == NO_STACK;\n+\n       if (state_old->stacktop == NO_STACK)\n \t{\n-\t  // Nothing to do in this case; we don't care about modifying\n-\t  // the old state.\n+\t  // This can happen if we're doing a pass-through jsr merge.\n+\t  // Here we can just ignore the stack.\n \t}\n       else if (stacktop == NO_STACK)\n \t{\n@@ -1155,8 +1192,36 @@ class _Jv_BytecodeVerifier\n \t  // only merge locals which changed in the subroutine.  When\n \t  // processing a `ret', STATE_OLD is the state at the point\n \t  // of the `ret', and THIS is the state just after the `jsr'.\n-\t  if (! ret_semantics || state_old->local_changed[i])\n+\t  // See comment above for explanation of COPY_IN_LOCALS.\n+\t  if (copy_in_locals)\n \t    {\n+\t      if ((state_old->flags[i] & FLAG_CHANGED) != 0)\n+\t\t{\n+\t\t  locals[i] = state_old->locals[i];\n+\t\t  changed = true;\n+\t\t  // There's no point in calling note_variable here,\n+\t\t  // since we call it under the same condition before\n+\t\t  // the loop ends.\n+\t\t}\n+\t    }\n+\t  else if (jsr_semantics && (flags[i] & FLAG_USED) != 0)\n+\t    {\n+\t      // We are processing the \"pass-through\" part of a jsr\n+\t      // statement.  In this particular case, the local was\n+\t      // changed by the subroutine.  So, we have no work to\n+\t      // do, as the pre-jsr value does not survive the\n+\t      // subroutine call.\n+\t    }\n+\t  else if (! ret_semantics\n+\t\t   || (state_old->flags[i] & FLAG_CHANGED) != 0)\n+\t    {\n+\t      // If we have ordinary (not ret) semantics, then we have\n+\t      // merging flow control, so we merge types.  Or, we have\n+\t      // jsr pass-through semantics and the type survives the\n+\t      // subroutine (see above), so again we merge.  Or,\n+\t      // finally, we have ret semantics and this value did\n+\t      // change, in which case we merge the change from the\n+\t      // subroutine into the post-jsr instruction.\n \t      if (locals[i].merge (state_old->locals[i], true, verifier))\n \t\t{\n \t\t  // Note that we don't call `note_variable' here.\n@@ -1172,8 +1237,14 @@ class _Jv_BytecodeVerifier\n \n \t  // If we're in a subroutine, we must compute the union of\n \t  // all the changed local variables.\n-\t  if (state_old->local_changed[i])\n+\t  if ((state_old->flags[i] & FLAG_CHANGED) != 0)\n \t    note_variable (i);\n+\n+\t  // If we're returning from a subroutine, we must mark the\n+\t  // post-jsr instruction with information about what changed,\n+\t  // so that future \"pass-through\" jsr merges work correctly.\n+\t  if (ret_semantics && (state_old->flags[i] & FLAG_CHANGED) != 0)\n+\t    flags[i] |= FLAG_USED;\n \t}\n \n       return changed;\n@@ -1218,7 +1289,7 @@ class _Jv_BytecodeVerifier\n     void note_variable (int index)\n     {\n       if (subroutine > 0)\n-\tlocal_changed[index] = true;\n+\tflags[index] |= FLAG_CHANGED;\n     }\n \n     // Mark each `new'd object we know of that was allocated at PC as\n@@ -1259,7 +1330,10 @@ class _Jv_BytecodeVerifier\n       for (i = 0; i < max_locals; ++i)\n \t{\n \t  locals[i].print ();\n-\t  debug_print (local_changed[i] ? \"+\" : \" \");\n+\t  if ((flags[i] & FLAG_USED) != 0)\n+\t    debug_print ((flags[i] & FLAG_CHANGED) ? \">\" : \"<\");\n+\t  else\n+\t    debug_print ((flags[i] & FLAG_CHANGED) ? \"+\" : \" \");\n \t}\n       if (subroutine == 0)\n \tdebug_print (\"   | None\");\n@@ -1450,8 +1524,14 @@ class _Jv_BytecodeVerifier\n   // schedule a new PC if there is a change.  If RET_SEMANTICS is\n   // true, then we are merging from a `ret' instruction into the\n   // instruction after a `jsr'.  This is a special case with its own\n-  // modified semantics.\n-  void push_jump_merge (int npc, state *nstate, bool ret_semantics = false)\n+  // modified semantics.  If JSR_SEMANTICS is true, then we're merging\n+  // some type information from a \"jsr\" instruction to the immediately\n+  // following instruction.  In this situation we have to be careful\n+  // not to merge local variables whose values are modified by the\n+  // subroutine we're about to call.\n+  void push_jump_merge (int npc, state *nstate,\n+\t\t\tbool ret_semantics = false,\n+\t\t\tbool jsr_semantics = false)\n   {\n     bool changed = true;\n     if (states[npc] == NULL)\n@@ -1478,7 +1558,8 @@ class _Jv_BytecodeVerifier\n \tstates[npc]->print (\" To\", npc, current_method->max_stack,\n \t\t\t    current_method->max_locals);\n \tchanged = states[npc]->merge (nstate, ret_semantics,\n-\t\t\t\t      current_method->max_locals, this);\n+\t\t\t\t      current_method->max_locals, this,\n+\t\t\t\t      jsr_semantics);\n \tstates[npc]->print (\"New\", npc, current_method->max_stack,\n \t\t\t    current_method->max_locals);\n       }\n@@ -1672,7 +1753,7 @@ class _Jv_BytecodeVerifier\n     if (PC < current_method->code_length)\n       {\n \tcurrent_state->stacktop = state::NO_STACK;\n-\tpush_jump_merge (PC, current_state);\n+\tpush_jump_merge (PC, current_state, false, true);\n       }\n     invalidate_pc ();\n   }"}]}