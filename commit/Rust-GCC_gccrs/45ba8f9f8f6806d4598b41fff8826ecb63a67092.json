{"sha": "45ba8f9f8f6806d4598b41fff8826ecb63a67092", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDViYThmOWY4ZjY4MDZkNDU5OGI0MWZmZjg4MjZlY2I2M2E2NzA5Mg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2011-05-28T13:27:43Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2011-05-28T13:27:43Z"}, "message": "Makefile.am: Add new ptr_traits.h header.\n\n2011-05-28  Jonathan Wakely  <jwakely.gcc@gmail.com>\n\n\t* include/Makefile.am: Add new ptr_traits.h header.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/ptr_traits.h (pointer_traits): New.\n\t* include/bits/allocator.h (allocator_traits): Add.\n\t* include/ext/array_allocator.h (construct, destroy): Update C++0x\n\tversions.\n\t* include/ext/bitmap_allocator.h (construct, destroy): Likewise.\n\t* include/ext/extptr_allocator.h (construct, destroy): Likewise.\n\t* include/ext/malloc_allocator.h (construct, destroy): Likewise.\n\t* include/ext/mt_allocator.h (construct, destroy): Likewise.\n\t* include/ext/new_allocator.h (construct, destroy): Likewise.\n\t* include/ext/pool_allocator.h (construct, destroy): Likewise.\n\t* include/ext/throw_allocator.h (construct, destroy): Likewise.\n\t* testsuite/20_util/allocator_traits/requirements/typedefs.cc: New.\n\t* testsuite/20_util/allocator_traits/requirements/\n\texplicit_instantiation.cc: New.\n\t* testsuite/20_util/allocator_traits/members/max_size.cc: New.\n\t* testsuite/20_util/allocator_traits/members/select.cc: New.\n\t* testsuite/20_util/allocator_traits/members/construct.cc: New.\n\t* testsuite/20_util/allocator_traits/members/allocate_hint.cc: New.\n\t* testsuite/20_util/allocator_traits/members/destroy.cc: New.\n\t* testsuite/20_util/pointer_traits/requirements/typedefs.cc: New.\n\t* testsuite/20_util/pointer_traits/requirements/\n\texplicit_instantiation.cc: New.\n\nFrom-SVN: r174380", "tree": {"sha": "3395bb512611d5a4c57824500bd0bd037124d510", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3395bb512611d5a4c57824500bd0bd037124d510"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45ba8f9f8f6806d4598b41fff8826ecb63a67092", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45ba8f9f8f6806d4598b41fff8826ecb63a67092", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45ba8f9f8f6806d4598b41fff8826ecb63a67092", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45ba8f9f8f6806d4598b41fff8826ecb63a67092/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ca2afa0c3a41bb26c80fdeffc2cef044c5feec1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ca2afa0c3a41bb26c80fdeffc2cef044c5feec1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ca2afa0c3a41bb26c80fdeffc2cef044c5feec1"}], "stats": {"total": 1349, "additions": 1290, "deletions": 59}, "files": [{"sha": "85b55b5dee9c3a689a623e05345c162636397f46", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -1,3 +1,30 @@\n+2011-05-28  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* include/Makefile.am: Add new ptr_traits.h header.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/bits/ptr_traits.h (pointer_traits): New.\n+\t* include/bits/allocator.h (allocator_traits): Add.\n+\t* include/ext/array_allocator.h (construct, destroy): Update C++0x\n+\tversions.\n+\t* include/ext/bitmap_allocator.h (construct, destroy): Likewise.\n+\t* include/ext/extptr_allocator.h (construct, destroy): Likewise.\n+\t* include/ext/malloc_allocator.h (construct, destroy): Likewise.\n+\t* include/ext/mt_allocator.h (construct, destroy): Likewise.\n+\t* include/ext/new_allocator.h (construct, destroy): Likewise.\n+\t* include/ext/pool_allocator.h (construct, destroy): Likewise.\n+\t* include/ext/throw_allocator.h (construct, destroy): Likewise.\n+\t* testsuite/20_util/allocator_traits/requirements/typedefs.cc: New.\n+\t* testsuite/20_util/allocator_traits/requirements/\n+\texplicit_instantiation.cc: New.\n+\t* testsuite/20_util/allocator_traits/members/max_size.cc: New.\n+\t* testsuite/20_util/allocator_traits/members/select.cc: New.\n+\t* testsuite/20_util/allocator_traits/members/construct.cc: New.\n+\t* testsuite/20_util/allocator_traits/members/allocate_hint.cc: New.\n+\t* testsuite/20_util/allocator_traits/members/destroy.cc: New.\n+\t* testsuite/20_util/pointer_traits/requirements/typedefs.cc: New.\n+\t* testsuite/20_util/pointer_traits/requirements/\n+\texplicit_instantiation.cc: New.\n+\n 2011-05-28  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* include/std/future (launch): Update enumerators and define"}, {"sha": "d83678347d9676323abd1b6aa0dfd76601247144", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -119,6 +119,7 @@ bits_headers = \\\n \t${bits_srcdir}/ostream.tcc \\\n \t${bits_srcdir}/ostream_insert.h \\\n \t${bits_srcdir}/postypes.h \\\n+\t${bits_srcdir}/ptr_traits.h \\\n \t${bits_srcdir}/random.h \\\n \t${bits_srcdir}/random.tcc \\\n \t${bits_srcdir}/range_access.h \\"}, {"sha": "fedba33196da235c7b0a3f89203e7ccb128bfb94", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -370,6 +370,7 @@ bits_headers = \\\n \t${bits_srcdir}/ostream.tcc \\\n \t${bits_srcdir}/ostream_insert.h \\\n \t${bits_srcdir}/postypes.h \\\n+\t${bits_srcdir}/ptr_traits.h \\\n \t${bits_srcdir}/random.h \\\n \t${bits_srcdir}/random.tcc \\\n \t${bits_srcdir}/range_access.h \\"}, {"sha": "37c6a596b9189c07cf10b22bf814ee0123c61e76", "filename": "libstdc++-v3/include/bits/allocator.h", "status": "modified", "additions": 403, "deletions": 3, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -48,7 +48,9 @@\n #include <bits/c++allocator.h>\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#include <bits/ptr_traits.h>\n #include <type_traits> // For _GLIBCXX_HAS_NESTED_TYPE\n+#include <limits>\n #endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -85,8 +87,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @brief  The @a standard allocator, as per [20.4].\n    * @ingroup allocators\n    *\n-   *  Further details:\n-   *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt04ch11.html\n+   *  See http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt04ch11.html\n+   *  for further details.\n    */\n   template<typename _Tp>\n     class allocator: public __glibcxx_base_allocator<_Tp>\n@@ -185,7 +187,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // A very basic implementation for now.  In general we have to wait for\n   // the availability of the infrastructure described in N2983:  we should\n   // try when either T has a move constructor which cannot throw or T is\n-  // CopyContructible.\n+  // CopyConstructible.\n   // NB: This code doesn't properly belong here, we should find a more\n   // suited place common to std::vector and std::deque.\n   template<typename _Tp,\n@@ -231,6 +233,404 @@ _GLIBCXX_HAS_NESTED_TYPE(allocator_type)\n \t\t\t       __uses_allocator_helper<_Tp, _Alloc>::value>\n     { };\n \n+  template<typename _Alloc, typename _Tp>\n+    class __alloctr_rebind_helper\n+    {\n+      template<typename _Alloc2, typename _Tp2>\n+\tstatic constexpr bool\n+       \t_S_chk(typename _Alloc2::template rebind<_Tp2>::other*)\n+\t{ return true; }\n+\n+      template<typename, typename>\n+        static constexpr bool\n+       \t_S_chk(...)\n+       \t{ return false; }\n+\n+    public:\n+      static const bool __value = _S_chk<_Alloc, _Tp>(nullptr);\n+    };\n+\n+  template<typename _Alloc, typename _Tp,\n+           bool = __alloctr_rebind_helper<_Alloc, _Tp>::__value>\n+    struct __alloctr_rebind;\n+\n+  template<typename _Alloc, typename _Tp>\n+    struct __alloctr_rebind<_Alloc, _Tp, true>\n+    {\n+      typedef typename _Alloc::template rebind<_Tp>::other __type;\n+    };\n+\n+  template<template<typename, typename...> class _Alloc, typename _Tp,\n+            typename _Up, typename... _Args>\n+    struct __alloctr_rebind<_Alloc<_Up, _Args...>, _Tp, false>\n+    {\n+      typedef _Alloc<_Tp, _Args...> __type;\n+    };\n+\n+  /**\n+   * @brief  Uniform interface to all allocator types.\n+   * @ingroup allocators\n+  */\n+  template<typename _Alloc>\n+    struct allocator_traits\n+    {\n+      /// The allocator type\n+      typedef _Alloc allocator_type;\n+      /// The allocated type\n+      typedef typename _Alloc::value_type value_type;\n+\n+#define _GLIBCXX_ALLOC_TR_NESTED_TYPE(_NTYPE, _ALT) \\\n+  private: \\\n+  template<typename _Tp> \\\n+    static typename _Tp::_NTYPE _S_##_NTYPE##_helper(_Tp*); \\\n+  static _ALT _S_##_NTYPE##_helper(...); \\\n+    typedef decltype(_S_##_NTYPE##_helper((_Alloc*)0)) __##_NTYPE; \\\n+  public:\n+\n+_GLIBCXX_ALLOC_TR_NESTED_TYPE(pointer, value_type*)\n+\n+      /**\n+       * @brief   The allocator's pointer type.\n+       *\n+       * @c Alloc::pointer if that type exists, otherwise @c value_type*\n+      */\n+      typedef __pointer pointer;\n+\n+// TODO: Use pointer_traits::rebind alias template.\n+\n+_GLIBCXX_ALLOC_TR_NESTED_TYPE(const_pointer,\n+  typename pointer_traits<pointer>::template __rebind<const value_type>::__type)\n+\n+      /**\n+       * @brief   The allocator's const pointer type.\n+       *\n+       * @c Alloc::const_pointer if that type exists, otherwise\n+       * <tt> pointer_traits<pointer>::rebind<const value_type> </tt>\n+      */\n+      typedef __const_pointer const_pointer;\n+\n+_GLIBCXX_ALLOC_TR_NESTED_TYPE(void_pointer,\n+  typename pointer_traits<pointer>::template __rebind<void>::__type)\n+\n+      /**\n+       * @brief   The allocator's void pointer type.\n+       *\n+       * @c Alloc::void_pointer if that type exists, otherwise\n+       * <tt> pointer_traits<pointer>::rebind<void> </tt>\n+      */\n+      typedef __void_pointer void_pointer;\n+\n+_GLIBCXX_ALLOC_TR_NESTED_TYPE(const_void_pointer,\n+  typename pointer_traits<pointer>::template __rebind<const void>::__type)\n+\n+      /**\n+       * @brief   The allocator's const void pointer type.\n+       *\n+       * @c Alloc::const_void_pointer if that type exists, otherwise\n+       * <tt> pointer_traits<pointer>::rebind<const void> </tt>\n+      */\n+      typedef __const_void_pointer const_void_pointer;\n+\n+_GLIBCXX_ALLOC_TR_NESTED_TYPE(difference_type,\n+                              typename pointer_traits<pointer>::difference_type)\n+\n+      /**\n+       * @brief   The allocator's difference type\n+       *\n+       * @c Alloc::difference_type if that type exists, otherwise\n+       * <tt> pointer_traits<pointer>::difference_type </tt>\n+      */\n+      typedef __difference_type difference_type;\n+\n+_GLIBCXX_ALLOC_TR_NESTED_TYPE(size_type,\n+                              typename make_unsigned<difference_type>::type)\n+\n+      /**\n+       * @brief   The allocator's size type\n+       *\n+       * @c Alloc::size_type if that type exists, otherwise\n+       * <tt> make_unsigned<difference_type>::type </tt>\n+      */\n+      typedef __size_type size_type;\n+\n+_GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_copy_assignment,\n+                              false_type)\n+\n+      /**\n+       * @brief   How the allocator is propagated on copy assignment\n+       *\n+       * @c Alloc::propagate_on_container_copy_assignment if that type exists,\n+       * otherwise @c false_type\n+      */\n+      typedef __propagate_on_container_copy_assignment\n+       \tpropagate_on_container_copy_assignment;\n+\n+_GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_move_assignment,\n+                              false_type)\n+\n+      /**\n+       * @brief   How the allocator is propagated on move assignment\n+       *\n+       * @c Alloc::propagate_on_container_move_assignment if that type exists,\n+       * otherwise @c false_type\n+      */\n+      typedef __propagate_on_container_move_assignment\n+       \tpropagate_on_container_move_assignment;\n+\n+_GLIBCXX_ALLOC_TR_NESTED_TYPE(propagate_on_container_swap,\n+                              false_type)\n+\n+      /**\n+       * @brief   How the allocator is propagated on swap\n+       *\n+       * @c Alloc::propagate_on_container_swap if that type exists,\n+       * otherwise @c false_type\n+      */\n+      typedef __propagate_on_container_swap propagate_on_container_swap;\n+\n+#undef _GLIBCXX_ALLOC_TR_NESTED_TYPE\n+\n+      /* TODO: use template alias \n+      template<typename _Tp>\n+        using rebind_alloc = __alloctr_rebind<_Alloc, _Tp>::__type;\n+      template<typename _Tp>\n+        using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n+      */\n+      template<typename _Tp>\n+        struct __rebind_alloc\n+\t{\n+  \t  typedef typename __alloctr_rebind<_Alloc, _Tp>::__type __type;\n+       \t};\n+\n+      template<typename _Tp>\n+        struct __rebind_traits\n+\t{\n+\t  typedef allocator_traits<typename __rebind_alloc<_Tp>::__type> __type;\n+\t};\n+\n+    private:\n+      template<typename _Alloc2>\n+\tstruct __allocate_helper\n+\t{\n+\t  template<typename _Alloc3,\n+\t    typename = decltype(std::declval<_Alloc3*>()->allocate(\n+\t\t  std::declval<size_type>(),\n+\t\t  std::declval<const_void_pointer>()))>\n+\t    static true_type __test(int);\n+\n+\t  template<typename>\n+\t    static false_type __test(...);\n+\n+\t  typedef decltype(__test<_Alloc>(0)) type;\n+\t  static const bool value = type::value;\n+\t};\n+\n+      template<typename _Alloc2>\n+\tstatic typename\n+       \tenable_if<__allocate_helper<_Alloc2>::value, pointer>::type\n+       \t_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint)\n+\t{ return __a.allocate(__n, __hint); }\n+\n+      template<typename _Alloc2>\n+\tstatic typename\n+       \tenable_if<!__allocate_helper<_Alloc2>::value, pointer>::type\n+       \t_S_allocate(_Alloc2& __a, size_type __n, ...)\n+\t{ return __a.allocate(__n); }\n+\n+      template<typename _Tp, typename... _Args>\n+\tstruct __construct_helper\n+\t{\n+\t  template<typename _Alloc2,\n+\t    typename = decltype(std::declval<_Alloc2*>()->construct(\n+\t\t  std::declval<_Tp*>(), std::declval<_Args>()...))>\n+\t    static true_type __test(int);\n+\n+\t  template<typename>\n+\t    static false_type __test(...);\n+\n+\t  typedef decltype(__test<_Alloc>(0)) type;\n+\t  static const bool value = type::value;\n+\t};\n+\n+      template<typename _Tp, typename... _Args>\n+\tstatic typename\n+       \tenable_if<__construct_helper<_Tp, _Args...>::value, void>::type\n+       \t_S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)\n+\t{ __a.construct(__p, std::forward<_Args>(__args)...); }\n+\n+      template<typename _Tp, typename... _Args>\n+\tstatic typename\n+       \tenable_if<!__construct_helper<_Tp, _Args...>::value, void>::type\n+       \t_S_construct(_Alloc&, _Tp* __p, _Args&&... __args)\n+\t{ ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }\n+\n+      template<typename _Tp>\n+\tstruct __destroy_helper\n+\t{\n+\t  template<typename _Alloc2,\n+\t    typename = decltype(std::declval<_Alloc2*>()->destroy(\n+\t\t  std::declval<_Tp*>()))>\n+\t    static true_type __test(int);\n+\n+\t  template<typename>\n+\t    static false_type __test(...);\n+\n+\t  typedef decltype(__test<_Alloc>(0)) type;\n+\t  static const bool value = type::value;\n+\t};\n+\n+      template<typename _Tp>\n+\tstatic typename enable_if<__destroy_helper<_Tp>::value, void>::type\n+       \t_S_destroy(_Alloc& __a, _Tp* __p)\n+\t{ __a.destroy(__p); }\n+\n+      template<typename _Tp>\n+\tstatic typename enable_if<!__destroy_helper<_Tp>::value, void>::type\n+       \t_S_destroy(_Alloc&, _Tp* __p)\n+\t{ __p->~_Tp(); }\n+\n+      template<typename _Alloc2>\n+\tstruct __maxsize_helper\n+\t{\n+\t  template<typename _Alloc3,\n+\t    typename = decltype(std::declval<_Alloc3*>()->max_size())>\n+\t    static true_type __test(int);\n+\n+\t  template<typename>\n+\t    static false_type __test(...);\n+\n+\t  typedef decltype(__test<_Alloc2>(0)) type;\n+\t  static const bool value = type::value;\n+\t};\n+\n+      template<typename _Alloc2>\n+\tstatic typename\n+       \tenable_if<__maxsize_helper<_Alloc2>::value, size_type>::type\n+       \t_S_max_size(_Alloc2& __a)\n+\t{ return __a.max_size(); }\n+\n+      template<typename _Alloc2>\n+\tstatic typename\n+       \tenable_if<!__maxsize_helper<_Alloc2>::value, size_type>::type\n+\t_S_max_size(_Alloc2&)\n+\t{ return numeric_limits<size_type>::max(); }\n+\n+      template<typename _Alloc2>\n+\tstruct __select_helper\n+\t{\n+\t  template<typename _Alloc3, typename\n+\t    = decltype(std::declval<_Alloc3*>()\n+\t\t->select_on_container_copy_construction())>\n+\t    static true_type __test(int);\n+\n+\t  template<typename>\n+\t    static false_type __test(...);\n+\n+\t  typedef decltype(__test<_Alloc2>(0)) type;\n+\t  static const bool value = type::value;\n+\t};\n+      template<typename _Alloc2>\n+\tstatic typename\n+       \tenable_if<__select_helper<_Alloc2>::value, _Alloc2>::type\n+       \t_S_select(_Alloc2& __a)\n+\t{ return __a.select_on_container_copy_construction(); }\n+\n+      template<typename _Alloc2>\n+\tstatic typename\n+       \tenable_if<!__select_helper<_Alloc2>::value, _Alloc2>::type\n+       \t_S_select(_Alloc2& __a)\n+\t{ return __a; }\n+\n+    public:\n+\n+      /**\n+       *  @brief  Allocate memory.\n+       *  @param  a  An allocator.\n+       *  @param  n  The number of objects to allocate space for.\n+       *\n+       *  Calls @c a.allocate(n)\n+      */\n+      static pointer\n+      allocate(_Alloc& __a, size_type __n)\n+      { return __a.allocate(__n); }\n+\n+      /**\n+       *  @brief  Allocate memory.\n+       *  @param  a  An allocator.\n+       *  @param  n  The number of objects to allocate space for.\n+       *  @param  hint Aid to locality.\n+       *  @return Memory of suitable size and alignment for @a n objects\n+       *          of type @c value_type\n+       *\n+       *  Returns <tt> a.allocate(n, hint) </tt> if that expression is\n+       *  well-formed, otherwise returns @c a.allocate(n)\n+      */\n+      static pointer\n+      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)\n+      { return _S_allocate(__a, __n, __hint); }\n+\n+      /**\n+       *  @brief  Deallocate memory.\n+       *  @param  a  An allocator.\n+       *  @param  p  Pointer to the memory to deallocate.\n+       *  @param  n  The number of objects space was allocated for.\n+       *\n+       *  Calls <tt> a.deallocate(p, n) </tt>\n+      */\n+      static void deallocate(_Alloc& __a, pointer __p, size_type __n)\n+      { __a.deallocate(__p, __n); }\n+\n+      /**\n+       *  @brief  Construct an object of type @a Tp\n+       *  @param  a  An allocator.\n+       *  @param  p  Pointer to memory of suitable size and alignment for Tp\n+       *  @param  args Constructor arguments.\n+       *\n+       *  Calls <tt> a.construct(p, std::forward<Args>(args)...) </tt>\n+       *  if that expression is well-formed, otherwise uses placement-new\n+       *  to construct an object of type @a Tp at location @a p from the\n+       *  arguments @a args...\n+      */\n+      template<typename _Tp, typename... _Args>\n+\tstatic void construct(_Alloc& __a, _Tp* __p, _Args&&... __args)\n+\t{ _S_construct(__a, __p, std::forward<_Args>(__args)...); }\n+\n+      /**\n+       *  @brief  Destroy an object of type @a Tp\n+       *  @param  a  An allocator.\n+       *  @param  p  Pointer to the object to destroy\n+       *\n+       *  Calls @c a.destroy(p) if that expression is well-formed,\n+       *  otherwise calls @c p->~Tp()\n+      */\n+      template <class _Tp>\n+\tstatic void destroy(_Alloc& __a, _Tp* __p)\n+\t{ _S_destroy(__a, __p); }\n+\n+      /**\n+       *  @brief  The maximum supported allocation size\n+       *  @param  a  An allocator.\n+       *  @return @c a.max_size() or @c %numeric_limits<size_type>::max()\n+       *\n+       *  Returns @c a.max_size() if that expression is well-formed,\n+       *  otherwise returns @c %numeric_limits<size_type>::max()\n+      */\n+      static size_type max_size(const _Alloc& __a)\n+      { return _S_max_size(__a); }\n+\n+      /**\n+       *  @brief  Obtain an allocator to use when copying a container.\n+       *  @param  rhs  An allocator.\n+       *  @return @c rhs.select_on_container_copy_construction() or @a rhs\n+       *\n+       *  Returns @c rhs.select_on_container_copy_construction() if that\n+       *  expression is well-formed, otherwise returns @a rhs\n+      */\n+      static _Alloc\n+      select_on_container_copy_construction(const _Alloc& __rhs)\n+      { return _S_select(__rhs); }\n+    };\n+\n #endif\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "342db12aff87425a2e6c1f395fe3170bb3b5ebc8", "filename": "libstdc++-v3/include/bits/ptr_traits.h", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fptr_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fptr_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fptr_traits.h?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -0,0 +1,222 @@\n+// Pointer Traits -*- C++ -*-\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/ptr_traits.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{memory}\n+ */\n+\n+#ifndef _PTR_TRAITS_H\n+#define _PTR_TRAITS_H 1\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+\n+#include <type_traits> // For _GLIBCXX_HAS_NESTED_TYPE\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+_GLIBCXX_HAS_NESTED_TYPE(element_type)\n+_GLIBCXX_HAS_NESTED_TYPE(difference_type)\n+\n+  template<typename _Tp, bool = __has_element_type<_Tp>::value>\n+    struct __ptrtr_elt_type;\n+\n+  template<typename _Tp>\n+    struct __ptrtr_elt_type<_Tp, true>\n+    {\n+      typedef typename _Tp::element_type __type;\n+    };\n+\n+  template<template<typename, typename...> class _SomePtr, typename _Tp,\n+            typename... _Args>\n+    struct __ptrtr_elt_type<_SomePtr<_Tp, _Args...>, false>\n+    {\n+      typedef _Tp __type;\n+    };\n+\n+  template<typename _Tp, bool = __has_difference_type<_Tp>::value>\n+    struct __ptrtr_diff_type\n+    {\n+      typedef typename _Tp::difference_type __type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __ptrtr_diff_type<_Tp, false>\n+    {\n+      typedef ptrdiff_t __type;\n+    };\n+\n+  template<typename _Ptr, typename _Up>\n+    class __ptrtr_rebind_helper\n+    {\n+      template<typename _Ptr2, typename _Up2>\n+\tstatic constexpr bool\n+       \t_S_chk(typename _Ptr2::template rebind<_Up2>*)\n+       \t{ return true; }\n+\n+      template<typename, typename>\n+        static constexpr bool\n+       \t_S_chk(...)\n+       \t{ return false; }\n+\n+    public:\n+      static const bool __value = _S_chk<_Ptr, _Up>(nullptr);\n+    };\n+\n+  // hack to use _Tp::__rebind<_Up>::__type instead if that exists\n+  template<typename _Ptr, typename _Up>\n+    class __ptrtr_rebind_helper2\n+    {\n+      template<typename _Ptr2, typename _Up2>\n+\tstatic constexpr bool\n+       \t_S_chk(typename _Ptr2::template __rebind<_Up2>::__type*)\n+\t{ return true; }\n+\n+      template<typename, typename>\n+        static constexpr bool\n+       \t_S_chk(...)\n+       \t{ return false; }\n+\n+    public:\n+      static const bool __value = _S_chk<_Ptr, _Up>(nullptr);\n+    };\n+\n+  /* TODO: remove second bool when alias templates are supported */\n+  template<typename _Tp, typename _Up,\n+           bool = __ptrtr_rebind_helper<_Tp, _Up>::value,\n+           bool = __ptrtr_rebind_helper2<_Tp, _Up>::value>\n+    struct __ptrtr_rebind;\n+\n+  template<typename _Tp, typename _Up, bool _B2>\n+    struct __ptrtr_rebind<_Tp, _Up, true, _B2>\n+    {\n+      typedef typename _Tp::template rebind<_Up> __type;\n+    };\n+\n+  /* TODO: remove this when alias templates are supported */\n+  template<typename _Tp, typename _Up>\n+    struct __ptrtr_rebind<_Tp, _Up, false, true>\n+    {\n+      typedef typename _Tp::template __rebind<_Up>::__type __type;\n+    };\n+\n+  template<template<typename, typename...> class _SomePtr, typename _Up,\n+            typename _Tp, typename... _Args>\n+    struct __ptrtr_rebind<_SomePtr<_Tp, _Args...>, _Up, false, false>\n+    {\n+      typedef _SomePtr<_Up, _Args...> __type;\n+    };\n+\n+  template<typename _Tp, typename = typename remove_cv<_Tp>::type>\n+    struct __ptrtr_not_void\n+    {\n+      typedef _Tp __type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __ptrtr_not_void<_Tp, void>\n+    {\n+      struct __type { };\n+    };\n+\n+  template<typename _Ptr>\n+    class __ptrtr_pointer_to\n+    {\n+      typedef typename __ptrtr_elt_type<_Ptr>::__type   __orig_type;\n+      typedef typename __ptrtr_not_void<__orig_type>::__type __element_type;\n+\n+    public:\n+      static _Ptr pointer_to(__element_type& __e)\n+      { return _Ptr::pointer_to(__e); }\n+    };\n+\n+  /**\n+   * @brief  Uniform interface to all pointer-like types\n+   * @ingroup pointer_abstractions\n+  */\n+  template<typename _Ptr>\n+    struct pointer_traits : __ptrtr_pointer_to<_Ptr>\n+    {\n+      /// The pointer type\n+      typedef _Ptr                                      pointer;\n+      /// The type pointed to\n+      typedef typename __ptrtr_elt_type<_Ptr>::__type   element_type;\n+      /// Type used to represent the difference between two pointers\n+      typedef typename __ptrtr_diff_type<_Ptr>::__type  difference_type;\n+\n+    private:\n+      /* TODO: replace __rebind<U> with alias template rebind<U> */\n+      /*\n+      template<typename _Up>\n+        using rebind<_Up> = typename __ptrtr_rebind<_Ptr, _Up>::__type;\n+      */\n+      template<typename _Up>\n+       \tstruct __rebind\n+        { typedef typename __ptrtr_rebind<_Ptr, _Up>::__type __type; };\n+\n+      // allocator_traits needs to use __rebind\n+      template<typename> struct allocator_traits;\n+      template<typename, typename> class __ptrtr_rebind_helper2;\n+    };\n+\n+  /**\n+   * @brief  Partial specialization for built-in pointers.\n+   * @ingroup pointer_abstractions\n+  */\n+  template<typename _Tp>\n+    struct pointer_traits<_Tp*>\n+    {\n+      /// The pointer type\n+      typedef _Tp* pointer;\n+      /// The type pointed to\n+      typedef _Tp  element_type;\n+      /// Type used to represent the difference between two pointers\n+      typedef ptrdiff_t difference_type;\n+\n+      /* TODO: replace __rebind<U> with alias template rebind<U> */\n+      /*\n+      template<typename _Up>\n+        using rebind<_Up> = U*;\n+      */\n+      template<typename U>\n+       \tstruct __rebind { typedef U* __type; };\n+\n+      /**\n+       *  @brief  Obtain a pointer to an object\n+       *  @param  r  A reference to an object of type @c element_type\n+       *  @return @c addressof(r)\n+      */\n+      static pointer\n+      pointer_to(typename __ptrtr_not_void<element_type>::__type& __r)\n+      { return std::addressof(__r); }\n+    };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif\n+\n+#endif"}, {"sha": "cee53f59182ed88e8ba001373dd3382b66f4b74c", "filename": "libstdc++-v3/include/ext/array_allocator.h", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fext%2Farray_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fext%2Farray_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Farray_allocator.h?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -72,21 +72,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       max_size() const throw() \n       { return size_t(-1) / sizeof(_Tp); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Up, typename... _Args>\n+        void\n+        construct(_Up* __p, _Args&&... __args)\n+\t{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n+\n+      template<typename _Up>\n+        void \n+        destroy(_Up* __p) { __p->~_Up(); }\n+#else\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 402. wrong new expression in [some_] allocator::construct\n       void \n       construct(pointer __p, const _Tp& __val) \n       { ::new((void *)__p) value_type(__val); }\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      template<typename... _Args>\n-        void\n-        construct(pointer __p, _Args&&... __args)\n-\t{ ::new((void *)__p) _Tp(std::forward<_Args>(__args)...); }\n-#endif\n-\n       void \n       destroy(pointer __p) { __p->~_Tp(); }\n+#endif\n     };  \n \n   /**"}, {"sha": "b03dc6a8e03f0179f215f3092feadda10db3dc88", "filename": "libstdc++-v3/include/ext/bitmap_allocator.h", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -1053,20 +1053,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       max_size() const throw()\n       { return size_type(-1) / sizeof(value_type); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Up, typename... _Args>\n+        void\n+        construct(_Up* __p, _Args&&... __args)\n+\t{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n+\n+      template<typename _Up>\n+        void \n+        destroy(_Up* __p)\n+        { __p->~_Up(); }\n+#else\n       void \n       construct(pointer __p, const_reference __data)\n       { ::new((void *)__p) value_type(__data); }\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      template<typename... _Args>\n-        void\n-        construct(pointer __p, _Args&&... __args)\n-\t{ ::new((void *)__p) _Tp(std::forward<_Args>(__args)...); }\n-#endif\n-\n       void \n       destroy(pointer __p)\n       { __p->~value_type(); }\n+#endif\n     };\n \n   template<typename _Tp1, typename _Tp2>"}, {"sha": "c93a7280df64d39c77221d8f2749cbc494472934", "filename": "libstdc++-v3/include/ext/extptr_allocator.h", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fext%2Fextptr_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fext%2Fextptr_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fextptr_allocator.h?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -100,18 +100,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       size_type max_size() const throw()\n       { return std::numeric_limits<size_type>::max() / sizeof(_Tp); }\n \n-      void construct(pointer __p, const _Tp& __val)\n-      { ::new(__p.get()) _Tp(__val); }\n-\n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      template<typename... _Args>\n+      template<typename _Up, typename... _Args>\n         void\n-        construct(pointer __p, _Args&&... __args)\n-        { ::new(__p.get()) _Tp(std::forward<_Args>(__args)...); }\n-#endif\n+        construct(_Up* __p, _Args&&... __args)\n+\t{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n+\n+      template<typename _Up>\n+        void \n+        destroy(_Up* __p)\n+        { __p->~_Up(); }\n+#else\n+      void construct(pointer __p, const _Tp& __val)\n+      { ::new(__p.get()) _Tp(__val); }\n \n       void destroy(pointer __p)\n       { __p->~_Tp(); }\n+#endif\n \n       template<typename _Up>\n         inline bool"}, {"sha": "e1794f7a0d721b1b4f6a426a4f6d0cd1950fed9f", "filename": "libstdc++-v3/include/ext/malloc_allocator.h", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -104,21 +104,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       max_size() const throw() \n       { return size_t(-1) / sizeof(_Tp); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Up, typename... _Args>\n+        void\n+        construct(_Up* __p, _Args&&... __args)\n+\t{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n+\n+      template<typename _Up>\n+        void \n+        destroy(_Up* __p) { __p->~_Up(); }\n+#else\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 402. wrong new expression in [some_] allocator::construct\n       void \n       construct(pointer __p, const _Tp& __val) \n       { ::new((void *)__p) value_type(__val); }\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      template<typename... _Args>\n-        void\n-        construct(pointer __p, _Args&&... __args) \n-\t{ ::new((void *)__p) _Tp(std::forward<_Args>(__args)...); }\n-#endif\n-\n       void \n       destroy(pointer __p) { __p->~_Tp(); }\n+#endif\n     };\n \n   template<typename _Tp>"}, {"sha": "9281494e1861a26a9385c702a39f0ec2edc184ab", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -588,21 +588,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       max_size() const throw() \n       { return size_t(-1) / sizeof(_Tp); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Up, typename... _Args>\n+        void\n+        construct(_Up* __p, _Args&&... __args)\n+\t{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n+\n+      template<typename _Up>\n+        void \n+        destroy(_Up* __p) { __p->~_Up(); }\n+#else\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 402. wrong new expression in [some_] allocator::construct\n       void \n       construct(pointer __p, const _Tp& __val) \n       { ::new((void *)__p) _Tp(__val); }\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      template<typename... _Args>\n-        void\n-        construct(pointer __p, _Args&&... __args)\n-\t{ ::new((void *)__p) _Tp(std::forward<_Args>(__args)...); }\n-#endif\n-\n       void \n       destroy(pointer __p) { __p->~_Tp(); }\n+#endif\n     };\n \n #ifdef __GTHREADS"}, {"sha": "4dd2ca2c3d2d6fe89dcc3e005fd385d47faa69bd", "filename": "libstdc++-v3/include/ext/new_allocator.h", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -101,21 +101,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       max_size() const throw() \n       { return size_t(-1) / sizeof(_Tp); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Up, typename... _Args>\n+        void\n+        construct(_Up* __p, _Args&&... __args)\n+\t{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n+\n+      template<typename _Up>\n+        void \n+        destroy(_Up* __p) { __p->~_Up(); }\n+#else\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 402. wrong new expression in [some_] allocator::construct\n       void \n       construct(pointer __p, const _Tp& __val) \n       { ::new((void *)__p) _Tp(__val); }\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      template<typename... _Args>\n-        void\n-        construct(pointer __p, _Args&&... __args)\n-\t{ ::new((void *)__p) _Tp(std::forward<_Args>(__args)...); }\n-#endif\n-\n       void \n       destroy(pointer __p) { __p->~_Tp(); }\n+#endif\n     };\n \n   template<typename _Tp>"}, {"sha": "9a47b191fc642c22f0d7edc6f87c7f105402ffd6", "filename": "libstdc++-v3/include/ext/pool_allocator.h", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -158,21 +158,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       max_size() const throw() \n       { return size_t(-1) / sizeof(_Tp); }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Up, typename... _Args>\n+        void\n+        construct(_Up* __p, _Args&&... __args)\n+\t{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n+\n+      template<typename _Up>\n+        void \n+        destroy(_Up* __p) { __p->~_Up(); }\n+#else\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 402. wrong new expression in [some_] allocator::construct\n       void \n       construct(pointer __p, const _Tp& __val) \n       { ::new((void *)__p) _Tp(__val); }\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      template<typename... _Args>\n-        void\n-        construct(pointer __p, _Args&&... __args)\n-\t{ ::new((void *)__p) _Tp(std::forward<_Args>(__args)...); }\n-#endif\n-\n       void \n       destroy(pointer __p) { __p->~_Tp(); }\n+#endif\n \n       pointer\n       allocate(size_type __n, const void* = 0);"}, {"sha": "aa01b257ae2c8685993a873aa84441702cf9c5a5", "filename": "libstdc++-v3/include/ext/throw_allocator.h", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fext%2Fthrow_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Finclude%2Fext%2Fthrow_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fthrow_allocator.h?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -639,20 +639,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn a;\n       }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+      template<typename _Up, typename... _Args>\n+        void\n+        construct(_Up* __p, _Args&&... __args)\n+\t{ return _M_allocator.construct(__p, std::forward<_Args>(__args)...); }\n+\n+      template<typename _Up>\n+        void \n+        destroy(_Up* __p)\n+        { _M_allocator.destroy(__p); }\n+#else\n       void\n       construct(pointer __p, const value_type& val)\n       { return _M_allocator.construct(__p, val); }\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n-      template<typename... _Args>\n-\tvoid\n-\tconstruct(pointer __p, _Args&&... __args)\n-\t{ return _M_allocator.construct(__p, std::forward<_Args>(__args)...); }\n-#endif\n-\n       void\n       destroy(pointer __p)\n       { _M_allocator.destroy(__p); }\n+#endif\n \n       void\n       deallocate(pointer __p, size_type __n)"}, {"sha": "6a26adc9f9e2929712f3bfc2a848328b36f8a853", "filename": "libstdc++-v3/testsuite/20_util/allocator_traits/members/allocate_hint.cc", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Fallocate_hint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Fallocate_hint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Fallocate_hint.cc?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -0,0 +1,90 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+#include <cstddef>\n+#include <testsuite_hooks.h>\n+\n+struct X { };\n+\n+template<typename T>\n+struct hintable_allocator\n+{\n+  typedef T value_type;\n+  struct const_void_pointer { };\n+  typedef unsigned size_type;\n+\n+  hintable_allocator() : called(false) { }\n+\n+  bool called;\n+\n+  // this is the overload that should get called:\n+  T* allocate(size_type n, const_void_pointer) { called = true; return 0; }\n+\n+  // none of these should get called:\n+  T* allocate(size_type n);\n+  T* allocate(size_type n, void*);\n+  T* allocate(size_type n, const void*);\n+  T* allocate(size_type n, const_void_pointer) const;\n+};\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::allocator_traits<hintable_allocator<X>> traits_type;\n+  traits_type::allocator_type a;\n+  traits_type::const_void_pointer v;\n+  X* p = traits_type::allocate(a, 1, v);\n+  VERIFY( a.called );\n+}\n+\n+template<typename T>\n+struct unhintable_allocator\n+{\n+  typedef T value_type;\n+  typedef unsigned size_type;\n+\n+  unhintable_allocator() : called(false) { }\n+\n+  bool called;\n+\n+  // this is the overload that should get called:\n+  T* allocate(size_type n) { called = true; return 0; }\n+\n+  // this should not get called:\n+  T* allocate(size_type n, void*);\n+};\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::allocator_traits<unhintable_allocator<X>> traits_type;\n+  traits_type::allocator_type a;\n+  traits_type::const_void_pointer v;\n+  X* p = traits_type::allocate(a, 1, v);\n+  VERIFY( a.called );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "a133fb0d6370d5f72f9c811e836413529b79d484", "filename": "libstdc++-v3/testsuite/20_util/allocator_traits/members/construct.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Fconstruct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Fconstruct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Fconstruct.cc?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -0,0 +1,79 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+#include <cstddef>\n+#include <testsuite_hooks.h>\n+\n+struct X\n+{\n+  static int counter;\n+  X() { }\n+  X(const X&) { ++counter; }\n+  explicit X(int) { ++counter; }\n+  X(int, int) { ++counter; }\n+  X(int, int, int) { ++counter; }\n+};\n+\n+int X::counter = 0;\n+\n+template<typename T>\n+struct fake_allocator\n+{\n+  typedef T value_type;\n+\n+  fake_allocator() : counter() {}\n+\n+  int counter;\n+\n+  T* allocate(std::size_t n) { return (T*)new char[n*sizeof(T)]; }\n+  void deallocate(T* p, std::size_t) { delete[] (char*)p; }\n+\n+  // don't actually construct anything when these are called\n+  void construct(T* p) { ++counter; }\n+  void construct(T* p, int, int) { ++counter; }\n+};\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::allocator_traits<fake_allocator<X>> traits_type;\n+  traits_type::allocator_type a;\n+  X* p = traits_type::allocate(a, 1);\n+  traits_type::construct(a, p);\n+  VERIFY( a.counter == 1 );\n+  traits_type::construct(a, p, 1);\n+  VERIFY( a.counter == 1 );\n+  VERIFY( X::counter == 1 );\n+  traits_type::destroy(a, p);\n+  traits_type::construct(a, p, 1, 1);\n+  VERIFY( a.counter == 2 );\n+  VERIFY( X::counter == 1 );\n+  traits_type::construct(a, p, 1, 1, 1);\n+  VERIFY( a.counter == 2 );\n+  VERIFY( X::counter == 2 );\n+  traits_type::destroy(a, p);\n+  traits_type::deallocate(a, p, 1);\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "a74efb215c85b9f9cfc8408c22791c93bb5ca099", "filename": "libstdc++-v3/testsuite/20_util/allocator_traits/members/destroy.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Fdestroy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Fdestroy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Fdestroy.cc?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -0,0 +1,84 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+#include <new>\n+#include <testsuite_hooks.h>\n+\n+struct X\n+{\n+  static int counter;\n+  ~X() { ++counter; }\n+};\n+\n+int X::counter = 0;\n+\n+template<typename T>\n+struct allocator_with_destroy\n+{\n+  typedef T value_type;\n+\n+  allocator_with_destroy() : called() { }\n+\n+  void destroy(T* p) { called = true; }\n+\n+  int called;\n+};\n+\n+template<typename T>\n+struct allocator_without_destroy\n+{\n+  typedef T value_type;\n+\n+  allocator_without_destroy() : called() { }\n+\n+  int called;\n+};\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::allocator_traits<allocator_with_destroy<X>> traits_type;\n+  traits_type::allocator_type a;\n+  X* p = 0;\n+  traits_type::destroy(a, p);\n+  VERIFY( a.called );\n+  VERIFY( X::counter == 0 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::allocator_traits<allocator_without_destroy<X>> traits_type;\n+  traits_type::allocator_type a;\n+  char buf[sizeof(X)];\n+  X* p = ::new (static_cast<void*>(buf)) X();\n+  traits_type::destroy(a, p);\n+  VERIFY( !a.called );\n+  VERIFY( X::counter == 1 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "61403ce7c6aca5def6914c68eb10a1fd81db4454", "filename": "libstdc++-v3/testsuite/20_util/allocator_traits/members/max_size.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Fmax_size.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Fmax_size.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Fmax_size.cc?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -0,0 +1,67 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+#include <limits>\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+\n+struct X { };\n+\n+template<typename T>\n+struct maxsize_allocator\n+{\n+  typedef T value_type;\n+  typedef unsigned size_type;\n+\n+  size_type max_size() const { return 100; }\n+};\n+\n+template<typename T>\n+struct unsized_allocator\n+{\n+  typedef T value_type;\n+};\n+\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::allocator_traits<maxsize_allocator<X>> traits_type;\n+  traits_type::allocator_type a;\n+  auto size = a.max_size();\n+  VERIFY( traits_type::max_size(a) == size );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::allocator_traits<unsized_allocator<X>> traits_type;\n+  traits_type::allocator_type a;\n+  auto size = std::numeric_limits<traits_type::size_type>::max();\n+  VERIFY( traits_type::max_size(a) == size );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "eac924b05fd0ebc149b0669ddbac924d88bf1894", "filename": "libstdc++-v3/testsuite/20_util/allocator_traits/members/select.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Fselect.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Fselect.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Fmembers%2Fselect.cc?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -0,0 +1,68 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct X { };\n+\n+template<typename T>\n+struct alloc1\n+{\n+  typedef T value_type;\n+\n+  int id;\n+};\n+\n+template<typename T>\n+struct alloc2\n+{\n+  typedef T value_type;\n+\n+  int id;\n+\n+  alloc2 select_on_container_copy_construction() const\n+  { return alloc2{id+1}; }\n+};\n+\n+\n+void test01()\n+{\n+  typedef std::allocator_traits<alloc1<X>> traits_type;\n+  traits_type::allocator_type a{1};\n+  const traits_type::allocator_type& a2\n+    = traits_type::select_on_container_copy_construction(a);\n+  VERIFY( a2.id == a.id );\n+}\n+\n+void test02()\n+{\n+  typedef std::allocator_traits<alloc1<X>> traits_type;\n+  traits_type::allocator_type a{1};\n+  const traits_type::allocator_type& a2\n+    = traits_type::select_on_container_copy_construction(a);\n+  VERIFY( a2.id != a.id );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "13d3135cb140263b805d4302c32d5873bf511dc4", "filename": "libstdc++-v3/testsuite/20_util/allocator_traits/requirements/explicit_instantiation.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Frequirements%2Fexplicit_instantiation.cc?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -0,0 +1,29 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// NB: This file is for testing memory with NO OTHER INCLUDES.\n+\n+#include <memory>\n+\n+namespace std\n+{\n+  typedef short test_type;\n+  template struct allocator_traits<std::allocator<test_type>>;\n+}"}, {"sha": "346824ffc2b5656102fa6769ba01e6d932e3aa4b", "filename": "libstdc++-v3/testsuite/20_util/allocator_traits/requirements/typedefs.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_traits%2Frequirements%2Ftypedefs.cc?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++0x\" }\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// \n+// NB: This file is for testing memory with NO OTHER INCLUDES.\n+\n+#include <memory>\n+\n+// { dg-do compile }\n+\n+template<typename T>\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::allocator_traits<T>                  test_type;\n+  typedef typename test_type::pointer               pointer;\n+  typedef typename test_type::const_pointer         const_pointer;\n+  typedef typename test_type::void_pointer          void_pointer;\n+  typedef typename test_type::const_void_pointer    const_void_pointer;\n+  typedef typename test_type::difference_type       difference_type;\n+  typedef typename test_type::size_type             size_type;\n+  typedef typename test_type::propagate_on_container_copy_assignment\n+    propagate_on_container_copy_assignment;\n+  typedef typename test_type::propagate_on_container_move_assignment\n+    propagate_on_container_move_assignment;\n+  typedef typename test_type::propagate_on_container_swap\n+    propagate_on_container_swap;\n+}\n+\n+struct S { };\n+\n+int main()\n+{\n+  test01<std::allocator<int>>();\n+  test01<std::allocator<S>>();\n+}"}, {"sha": "38043d4eac68c79b03b88d36963967a46aca82a9", "filename": "libstdc++-v3/testsuite/20_util/pointer_traits/requirements/explicit_instantiation.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpointer_traits%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpointer_traits%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpointer_traits%2Frequirements%2Fexplicit_instantiation.cc?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -0,0 +1,31 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// NB: This file is for testing memory with NO OTHER INCLUDES.\n+\n+#include <memory>\n+\n+namespace std\n+{\n+  typedef short test_type;\n+  template struct pointer_traits<test_type*>;\n+  template struct pointer_traits<shared_ptr<test_type>>;\n+  template struct pointer_traits<unique_ptr<test_type>>;\n+}"}, {"sha": "c682557a0e3664aab48e322689e57aad21ec2e18", "filename": "libstdc++-v3/testsuite/20_util/pointer_traits/requirements/typedefs.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpointer_traits%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45ba8f9f8f6806d4598b41fff8826ecb63a67092/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpointer_traits%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpointer_traits%2Frequirements%2Ftypedefs.cc?ref=45ba8f9f8f6806d4598b41fff8826ecb63a67092", "patch": "@@ -0,0 +1,45 @@\n+// { dg-options \"-std=gnu++0x\" }\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// \n+// NB: This file is for testing memory with NO OTHER INCLUDES.\n+\n+#include <memory>\n+\n+// { dg-do compile }\n+\n+template<typename Ptr>\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::pointer_traits<Ptr>              test_type;\n+  typedef typename test_type::pointer           pointer;\n+  typedef typename test_type::element_type      element_type;\n+  typedef typename test_type::difference_type   difference_type;\n+}\n+\n+int main()\n+{\n+  test01<int*>();\n+  test01<void*>();\n+  test01<std::shared_ptr<int>>();\n+  test01<std::shared_ptr<void>>();\n+  test01<std::unique_ptr<int>>();\n+  test01<std::unique_ptr<void>>();\n+}"}]}