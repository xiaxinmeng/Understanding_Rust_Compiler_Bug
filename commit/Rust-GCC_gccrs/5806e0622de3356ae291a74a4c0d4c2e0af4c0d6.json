{"sha": "5806e0622de3356ae291a74a4c0d4c2e0af4c0d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgwNmUwNjIyZGUzMzU2YWUyOTFhNzRhNGMwZDRjMmUwYWY0YzBkNg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-12-15T22:11:06Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-12-15T22:11:06Z"}, "message": "re PR tree-optimization/81165 (Regression in GCC-8.0.0's optimizer)\n\n\tPR tree-optimization/81165\n\t* tree-ssa-threadupdate.c (uses_in_bb): New.\n\t(estimate_threading_killed_stmts): New.\n\t* tree-ssa-threadupdate.h (estimate_threading_killed_stmts): Prototype.\n\t* tree-ssa-threadedge.c\n\t(record_temporary_equivalences_from_stmts_at_dest): Expand limit\n\twhen its hit.\n\n\tPR tree-optimization/81165\n\t* gcc.dg/pr81165.c: New.\n\nFrom-SVN: r255724", "tree": {"sha": "b8e6c164eb187dd22c1305123e27d655276679ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8e6c164eb187dd22c1305123e27d655276679ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5806e0622de3356ae291a74a4c0d4c2e0af4c0d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5806e0622de3356ae291a74a4c0d4c2e0af4c0d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5806e0622de3356ae291a74a4c0d4c2e0af4c0d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5806e0622de3356ae291a74a4c0d4c2e0af4c0d6/comments", "author": null, "committer": null, "parents": [{"sha": "38f4bea834ef4c25cd89c824f15ee8d6b30a3760", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38f4bea834ef4c25cd89c824f15ee8d6b30a3760", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38f4bea834ef4c25cd89c824f15ee8d6b30a3760"}], "stats": {"total": 230, "additions": 228, "deletions": 2}, "files": [{"sha": "e5ab1b1a4c788ecf3a379239026edff457473e96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5806e0622de3356ae291a74a4c0d4c2e0af4c0d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5806e0622de3356ae291a74a4c0d4c2e0af4c0d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5806e0622de3356ae291a74a4c0d4c2e0af4c0d6", "patch": "@@ -1,4 +1,14 @@\n-2017-12-12  Jeff Law  <law@redhat.com>\n+2017-12-15  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR tree-optimization/81165\n+\t* tree-ssa-threadupdate.c (uses_in_bb): New.\n+\t(estimate_threading_killed_stmts): New.\n+\t* tree-ssa-threadupdate.h (estimate_threading_killed_stmts): Prototype.\n+\t* tree-ssa-threadedge.c \n+\t(record_temporary_equivalences_from_stmts_at_dest): Expand limit\n+\twhen its hit.\n+\n+2017-12-15  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/83410\n \t* tree-ssa-threadupdate.c (thread_block_1): Avoid certain jump"}, {"sha": "bc005b8de26a593245558d67d3ba95eaff9413a1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5806e0622de3356ae291a74a4c0d4c2e0af4c0d6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5806e0622de3356ae291a74a4c0d4c2e0af4c0d6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5806e0622de3356ae291a74a4c0d4c2e0af4c0d6", "patch": "@@ -1,3 +1,8 @@\n+2017-12-15  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR tree-optimization/81165\n+\t* gcc.dg/pr81165.c: New.\n+\n 2017-12-15  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/83205"}, {"sha": "8508d893bed6fbae74a3bc3d9172e1d3e152f009", "filename": "gcc/testsuite/gcc.dg/pr81165.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5806e0622de3356ae291a74a4c0d4c2e0af4c0d6/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81165.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5806e0622de3356ae291a74a4c0d4c2e0af4c0d6/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81165.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81165.c?ref=5806e0622de3356ae291a74a4c0d4c2e0af4c0d6", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-not \" \\[/%\\] \" \"optimized\" } } */\n+\n+/* Testcase submitted for PR81165, with its main function removed as\n+   it's turned into a compile test.  We want to make sure that all of\n+   the divide/remainder computations are removed by tree optimizers.\n+\n+   We can figure out that we don't need to compute at runtime even the\n+   condition to enter the loop: the initial i==0 would have to be\n+   greater than the sum of two small unsigned values: 1U>>t1 is in the\n+   range 0..1, whereas the char value is bounded by the range 0..127,\n+   being 128 % a positive number (zero would invoke undefined\n+   behavior, so we can assume it doesn't happen).  (We know it's\n+   nonnegative because it's 10 times a number that has no more than\n+   the bits for 16, 8 and 1 set.)\n+\n+   We don't realize that the loop is useless right away: jump\n+   threading helps remove some of the complexity, particularly of the\n+   computation within the loop: t1 is compared with 1, but it can\n+   never be 1.  (We could assume as much, since its being 1 would\n+   divide by zero, but we don't.)\n+\n+   If we don't enter the conditional block, t1 remains at 2; if we do,\n+   it's set to either -1.  If we jump thread at the end of the\n+   conditional block, we can figure out the ranges exclude 1 and the\n+   jump body is completely optimized out.  However, we used to fail to\n+   consider the block for jump threading due to the amount of\n+   computation in it, without realizing most of it would die in\n+   consequence of the threading.\n+\n+   We now take the dying code into account when deciding whether or\n+   not to try jump threading.  That might enable us to optimize the\n+   function into { if (x2 != 0 || (x1 & 1) == 0) abort (); }.  At the\n+   time of this writing, with the patch, we get close, but the test on\n+   x2 only gets as far as ((1 >> x2) == 0).  Without the patch, some\n+   of the loop remains.  */\n+\n+short x0 = 15;\n+\n+void func (){\n+  volatile int x1 = 1U;\n+  volatile char x2 = 0;\n+  char t0 = 0;\n+  unsigned long t1 = 2LU;\n+  int i = 0;\n+  \n+  if(1>>x2) {\n+    t0 = -1;\n+    t1 = (1&(short)(x1^8U))-1;\n+  }\n+\n+  while(i > (int)((1U>>t1)+(char)(128%(10*(25LU&(29%x0)))))) {\n+    i += (int)(12L/(1!=(int)t1));\n+  }\n+\n+  if (t0 != -1) __builtin_abort();\n+  if (t1 != 0L) __builtin_abort();\n+}"}, {"sha": "1fafd7b593257991ab32bee7b1bb27eb860eae21", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5806e0622de3356ae291a74a4c0d4c2e0af4c0d6/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5806e0622de3356ae291a74a4c0d4c2e0af4c0d6/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=5806e0622de3356ae291a74a4c0d4c2e0af4c0d6", "patch": "@@ -244,7 +244,22 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t expansion, then do not thread through this block.  */\n       stmt_count++;\n       if (stmt_count > max_stmt_count)\n-\treturn NULL;\n+\t{\n+\t  /* If any of the stmts in the PATH's dests are going to be\n+\t     killed due to threading, grow the max count\n+\t     accordingly.  */\n+\t  if (max_stmt_count\n+\t      == PARAM_VALUE (PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS))\n+\t    {\n+\t      max_stmt_count += estimate_threading_killed_stmts (e->dest);\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"threading bb %i up to %i stmts\\n\",\n+\t\t\t e->dest->index, max_stmt_count);\n+\t    }\n+\t  /* If we're still past the limit, we're done.  */\n+\t  if (stmt_count > max_stmt_count)\n+\t    return NULL;\n+\t}\n \n       /* These are temporary ranges, do nto reflect them back into\n \t the global range data.  */"}, {"sha": "b29ffe195c8dd105123266f02d1445b3f514aea6", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5806e0622de3356ae291a74a4c0d4c2e0af4c0d6/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5806e0622de3356ae291a74a4c0d4c2e0af4c0d6/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=5806e0622de3356ae291a74a4c0d4c2e0af4c0d6", "patch": "@@ -2431,3 +2431,139 @@ register_jump_thread (vec<jump_thread_edge *> *path)\n \n   paths.safe_push (path);\n }\n+\n+/* Return how many uses of T there are within BB, as long as there\n+   aren't any uses outside BB.  If there are any uses outside BB,\n+   return -1 if there's at most one use within BB, or -2 if there is\n+   more than one use within BB.  */\n+\n+static int\n+uses_in_bb (tree t, basic_block bb)\n+{\n+  int uses = 0;\n+  bool outside_bb = false;\n+\n+  imm_use_iterator iter;\n+  use_operand_p use_p;\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, t)\n+    {\n+      if (is_gimple_debug (USE_STMT (use_p)))\n+\tcontinue;\n+\n+      if (gimple_bb (USE_STMT (use_p)) != bb)\n+\toutside_bb = true;\n+      else\n+\tuses++;\n+\n+      if (outside_bb && uses > 1)\n+\treturn -2;\n+    }\n+\n+  if (outside_bb)\n+    return -1;\n+\n+  return uses;\n+}\n+\n+/* Starting from the final control flow stmt in BB, assuming it will\n+   be removed, follow uses in to-be-removed stmts back to their defs\n+   and count how many defs are to become dead and be removed as\n+   well.  */\n+\n+unsigned int\n+estimate_threading_killed_stmts (basic_block bb)\n+{\n+  int killed_stmts = 0;\n+  hash_map<tree, int> ssa_remaining_uses;\n+  auto_vec<gimple *, 4> dead_worklist;\n+\n+  /* If the block has only two predecessors, threading will turn phi\n+     dsts into either src, so count them as dead stmts.  */\n+  bool drop_all_phis = EDGE_COUNT (bb->preds) == 2;\n+\n+  if (drop_all_phis)\n+    for (gphi_iterator gsi = gsi_start_phis (bb);\n+\t !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+\tgphi *phi = gsi.phi ();\n+\ttree dst = gimple_phi_result (phi);\n+\n+\t/* We don't count virtual PHIs as stmts in\n+\t   record_temporary_equivalences_from_phis.  */\n+\tif (virtual_operand_p (dst))\n+\t  continue;\n+\n+\tkilled_stmts++;\n+      }\n+\n+  if (gsi_end_p (gsi_last_bb (bb)))\n+    return killed_stmts;\n+\n+  gimple *stmt = gsi_stmt (gsi_last_bb (bb));\n+  if (gimple_code (stmt) != GIMPLE_COND\n+      && gimple_code (stmt) != GIMPLE_GOTO\n+      && gimple_code (stmt) != GIMPLE_SWITCH)\n+    return killed_stmts;\n+\n+  /* The control statement is always dead.  */\n+  killed_stmts++;\n+  dead_worklist.quick_push (stmt);\n+  while (!dead_worklist.is_empty ())\n+    {\n+      stmt = dead_worklist.pop ();\n+\n+      ssa_op_iter iter;\n+      use_operand_p use_p;\n+      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n+\t{\n+\t  tree t = USE_FROM_PTR (use_p);\n+\t  gimple *def = SSA_NAME_DEF_STMT (t);\n+\n+\t  if (gimple_bb (def) == bb\n+\t      && (gimple_code (def) != GIMPLE_PHI\n+\t\t  || !drop_all_phis)\n+\t      && !gimple_has_side_effects (def))\n+\t    {\n+\t      int *usesp = ssa_remaining_uses.get (t);\n+\t      int uses;\n+\n+\t      if (usesp)\n+\t\tuses = *usesp;\n+\t      else\n+\t\tuses = uses_in_bb (t, bb);\n+\n+\t      gcc_assert (uses);\n+\n+\t      /* Don't bother recording the expected use count if we\n+\t\t won't find any further uses within BB.  */\n+\t      if (!usesp && (uses < -1 || uses > 1))\n+\t\t{\n+\t\t  usesp = &ssa_remaining_uses.get_or_insert (t);\n+\t\t  *usesp = uses;\n+\t\t}\n+\n+\t      if (uses < 0)\n+\t\tcontinue;\n+\n+\t      --uses;\n+\t      if (usesp)\n+\t\t*usesp = uses;\n+\n+\t      if (!uses)\n+\t\t{\n+\t\t  killed_stmts++;\n+\t\t  if (usesp)\n+\t\t    ssa_remaining_uses.remove (t);\n+\t\t  if (gimple_code (def) != GIMPLE_PHI)\n+\t\t    dead_worklist.safe_push (def);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"threading bb %i kills %i stmts\\n\",\n+\t     bb->index, killed_stmts);\n+\n+  return killed_stmts;\n+}"}, {"sha": "8a3b41d82cdb49eeda531147a04b0b12dc3e5e82", "filename": "gcc/tree-ssa-threadupdate.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5806e0622de3356ae291a74a4c0d4c2e0af4c0d6/gcc%2Ftree-ssa-threadupdate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5806e0622de3356ae291a74a4c0d4c2e0af4c0d6/gcc%2Ftree-ssa-threadupdate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.h?ref=5806e0622de3356ae291a74a4c0d4c2e0af4c0d6", "patch": "@@ -47,6 +47,7 @@ extern void remove_jump_threads_including (edge);\n extern void delete_jump_thread_path (vec <class jump_thread_edge *> *);\n extern void remove_ctrl_stmt_and_useless_edges (basic_block, basic_block);\n extern void free_dom_edge_info (edge);\n+extern unsigned int estimate_threading_killed_stmts (basic_block);\n \n enum bb_dom_status\n {"}]}