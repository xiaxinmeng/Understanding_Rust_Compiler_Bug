{"sha": "7e7760939bf69c764707b32676784af383dacfd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U3NzYwOTM5YmY2OWM3NjQ3MDdiMzI2NzY3ODRhZjM4M2RhY2ZkNA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-07-23T17:51:17Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-07-23T17:51:17Z"}, "message": "decl2.c (import_export_template): Fold in...\n\n\t* decl2.c (import_export_template): Fold in...\n\t(import_export_class): ...to here.  Handle dllimport/export.\n\nFrom-SVN: r21350", "tree": {"sha": "f1d0eee2a4dfa5cf7f48c34df65351e68eb69a81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1d0eee2a4dfa5cf7f48c34df65351e68eb69a81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e7760939bf69c764707b32676784af383dacfd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e7760939bf69c764707b32676784af383dacfd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e7760939bf69c764707b32676784af383dacfd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e7760939bf69c764707b32676784af383dacfd4/comments", "author": null, "committer": null, "parents": [{"sha": "71bca5068d4491157020bdb8a11723787c22f054", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71bca5068d4491157020bdb8a11723787c22f054", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71bca5068d4491157020bdb8a11723787c22f054"}], "stats": {"total": 69, "additions": 43, "deletions": 26}, "files": [{"sha": "e26305ec2f096eee624065498ccae15beb3af5d3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7760939bf69c764707b32676784af383dacfd4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7760939bf69c764707b32676784af383dacfd4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7e7760939bf69c764707b32676784af383dacfd4", "patch": "@@ -1,5 +1,8 @@\n 1998-07-23  Jason Merrill  <jason@yorick.cygnus.com>\n \n+\t* decl2.c (import_export_template): Fold in...\n+\t(import_export_class): ...to here.  Handle dllimport/export.\n+\n \t* class.c (build_vtable): Pass at_eof to import_export_vtable.\n \t(prepare_fresh_vtable): Likewise.\n \t* decl2.c (import_export_class): Split out..."}, {"sha": "c433e7ac9cfc476baef1718578fac5c8ccd73b40", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7760939bf69c764707b32676784af383dacfd4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7760939bf69c764707b32676784af383dacfd4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7e7760939bf69c764707b32676784af383dacfd4", "patch": "@@ -2485,6 +2485,7 @@ extern void finish_builtin_type\t\t\tPROTO((tree, char *, tree *, int, tree));\n extern tree coerce_new_type\t\t\tPROTO((tree));\n extern tree coerce_delete_type\t\t\tPROTO((tree));\n extern void comdat_linkage\t\t\tPROTO((tree));\n+extern void import_export_class\t\t\tPROTO((tree));\n extern void import_export_vtable\t\tPROTO((tree, tree, int));\n extern int finish_prevtable_vardecl\t\tPROTO((tree, tree));\n extern int walk_vtables\t\t\t\tPROTO((void (*)(tree, tree),"}, {"sha": "901f56587229d605a608fcdafa70b52009b8888f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 39, "deletions": 26, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e7760939bf69c764707b32676784af383dacfd4/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e7760939bf69c764707b32676784af383dacfd4/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=7e7760939bf69c764707b32676784af383dacfd4", "patch": "@@ -52,7 +52,6 @@ static int cpp_initialized;\n \n static tree get_sentry PROTO((tree));\n static void mark_vtable_entries PROTO((tree));\n-static void import_export_template PROTO((tree));\n static void grok_function_init PROTO((tree, tree));\n static int finish_vtable_vardecl PROTO((tree, tree));\n static int prune_vtable_vardecl PROTO((tree, tree));\n@@ -2594,28 +2593,39 @@ import_export_vtable (decl, type, final)\n     }\n }\n \n-static void\n-import_export_template (type)\n-     tree type;\n-{\n-  if (CLASSTYPE_IMPLICIT_INSTANTIATION (type)\n-      && ! flag_implicit_templates\n-      && CLASSTYPE_INTERFACE_UNKNOWN (type))\n-    {\n-      SET_CLASSTYPE_INTERFACE_KNOWN (type);\n-      CLASSTYPE_INTERFACE_ONLY (type) = 1;\n-      CLASSTYPE_VTABLE_NEEDS_WRITING (type) = 0;\n-    }\n-}\n+/* Determine whether or not we want to specifically import or export CTYPE,\n+   using various heuristics.  */\n \n void\n import_export_class (ctype)\n      tree ctype;\n {\n-  import_export_template (ctype);\n+  /* -1 for imported, 1 for exported.  */\n+  int import_export = 0;\n+\n+  if (CLASSTYPE_INTERFACE_KNOWN (ctype))\n+    return;\n+\n+#ifdef VALID_MACHINE_TYPE_ATTRIBUTE\n+  /* FIXME this should really use some sort of target-independent macro.  */\n+  if (lookup_attribute (\"dllimport\", TYPE_ATTRIBUTES (ctype)))\n+    import_export = -1;\n+  else if (lookup_attribute (\"dllexport\", TYPE_ATTRIBUTES (ctype)))\n+    import_export = 1;\n+#endif\n+\n+  /* If we got -fno-implicit-templates, we import template classes that\n+     weren't explicitly instantiated.  */\n+  if (import_export == 0\n+      && CLASSTYPE_IMPLICIT_INSTANTIATION (ctype)\n+      && ! flag_implicit_templates)\n+    import_export = -1;\n \n #ifndef MULTIPLE_SYMBOL_SPACES\n-  if (CLASSTYPE_INTERFACE_UNKNOWN (ctype) && TYPE_VIRTUAL_P (ctype)\n+  /* Base our import/export status on that of the first non-inline,\n+     non-abstract virtual function, if any.  */\n+  if (import_export == 0\n+      && TYPE_VIRTUAL_P (ctype)\n       && ! CLASSTYPE_TEMPLATE_INSTANTIATION (ctype))\n     {\n       tree method;\n@@ -2626,15 +2636,19 @@ import_export_class (ctype)\n \t      && !DECL_THIS_INLINE (method)\n \t      && !DECL_ABSTRACT_VIRTUAL_P (method))\n \t    {\n-\t      SET_CLASSTYPE_INTERFACE_KNOWN (ctype);\n-\t      CLASSTYPE_VTABLE_NEEDS_WRITING (ctype)\n-\t\t= ! DECL_REALLY_EXTERN (method);\n-\t      CLASSTYPE_INTERFACE_ONLY (ctype) = DECL_REALLY_EXTERN (method);\n+\t      import_export = (DECL_REALLY_EXTERN (method) ? -1 : 1);\n \t      break;\n \t    }\n \t}\n     }\n #endif\n+\n+  if (import_export)\n+    {\n+      SET_CLASSTYPE_INTERFACE_KNOWN (ctype);\n+      CLASSTYPE_VTABLE_NEEDS_WRITING (ctype) = (import_export > 0);\n+      CLASSTYPE_INTERFACE_ONLY (ctype) = (import_export < 0);\n+    }\n }\n     \n int\n@@ -2833,18 +2847,17 @@ import_export_decl (decl)\n     {\n       tree ctype = TREE_TYPE (DECL_NAME (decl));\n       if (IS_AGGR_TYPE (ctype) && CLASSTYPE_INTERFACE_KNOWN (ctype)\n-\t  && TYPE_VIRTUAL_P (ctype))\n-\t{\n+\t  && TYPE_VIRTUAL_P (ctype)\n \t  /* If the type is a cv-qualified variant of a type, then we\n \t     must emit the tinfo function in this translation unit\n \t     since it will not be emitted when the vtable for the type\n \t     is output (which is when the unqualified version is\n \t     generated).  */\n+\t  && ctype == TYPE_MAIN_VARIANT (ctype))\n+\t{\n \t  DECL_NOT_REALLY_EXTERN (decl)\n-\t    = TYPE_READONLY (ctype) \n-\t    || TYPE_VOLATILE (ctype)\n-\t    || ! (CLASSTYPE_INTERFACE_ONLY (ctype)\n-\t\t  || (DECL_THIS_INLINE (decl) && ! flag_implement_inlines));\n+\t    = ! (CLASSTYPE_INTERFACE_ONLY (ctype)\n+\t\t || (DECL_THIS_INLINE (decl) && ! flag_implement_inlines));\n \n \t  /* For WIN32 we also want to put explicit instantiations in\n \t     linkonce sections.  */"}]}