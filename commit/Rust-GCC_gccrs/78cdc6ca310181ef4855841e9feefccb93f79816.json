{"sha": "78cdc6ca310181ef4855841e9feefccb93f79816", "node_id": "C_kwDOANBUbNoAKDc4Y2RjNmNhMzEwMTgxZWY0ODU1ODQxZTlmZWVmY2NiOTNmNzk4MTY", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-18T12:46:44Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-18T12:46:44Z"}, "message": "Refactor type name resolution into their own .cc file", "tree": {"sha": "061b6e53eef166ebd4e31cbb37dcfbc0352b2352", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/061b6e53eef166ebd4e31cbb37dcfbc0352b2352"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78cdc6ca310181ef4855841e9feefccb93f79816", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78cdc6ca310181ef4855841e9feefccb93f79816", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78cdc6ca310181ef4855841e9feefccb93f79816", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78cdc6ca310181ef4855841e9feefccb93f79816/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbe22e87687c68357430e60361a8a124c81148cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbe22e87687c68357430e60361a8a124c81148cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbe22e87687c68357430e60361a8a124c81148cc"}], "stats": {"total": 375, "additions": 205, "deletions": 170}, "files": [{"sha": "6339ac08b2bce67669fdd70780fd9800db6b6568", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78cdc6ca310181ef4855841e9feefccb93f79816/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78cdc6ca310181ef4855841e9feefccb93f79816/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=78cdc6ca310181ef4855841e9feefccb93f79816", "patch": "@@ -81,6 +81,7 @@ GRS_OBJS = \\\n     rust/rust-ast-lower-pattern.o \\\n     rust/rust-ast-resolve.o \\\n     rust/rust-ast-resolve-pattern.o \\\n+    rust/rust-ast-resolve-type.o \\\n     rust/rust-hir-type-check.o \\\n     rust/rust-tyty.o \\\n     rust/rust-tyctx.o \\"}, {"sha": "271c6fa775c7daae3416d0b861278464539b0d00", "filename": "gcc/rust/resolve/rust-ast-resolve-type.cc", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78cdc6ca310181ef4855841e9feefccb93f79816/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78cdc6ca310181ef4855841e9feefccb93f79816/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc?ref=78cdc6ca310181ef4855841e9feefccb93f79816", "patch": "@@ -0,0 +1,201 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve-type.h\"\n+#include \"rust-ast-resolve-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+// rust-ast-resolve-type.h\n+\n+std::string\n+ResolveTypeToCanonicalPath::canonicalize_generic_args (AST::GenericArgs &args)\n+{\n+  std::string buf;\n+\n+  size_t i = 0;\n+  size_t total = args.get_type_args ().size ();\n+\n+  for (auto &ty_arg : args.get_type_args ())\n+    {\n+      buf += ty_arg->as_string ();\n+      if ((i + 1) < total)\n+\tbuf += \",\";\n+\n+      i++;\n+    }\n+\n+  return \"<\" + buf + \">\";\n+}\n+\n+bool\n+ResolveTypeToCanonicalPath::type_resolve_generic_args (AST::GenericArgs &args)\n+{\n+  for (auto &gt : args.get_type_args ())\n+    {\n+      ResolveType::go (gt.get (), UNKNOWN_NODEID);\n+      // FIXME error handling here for inference variable since they do not have\n+      // a node to resolve to\n+      // if (resolved == UNKNOWN_NODEID) return false;\n+    }\n+  return true;\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::TypePathSegmentGeneric &seg)\n+{\n+  if (seg.is_error ())\n+    {\n+      failure_flag = true;\n+      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n+\t\t     seg.as_string ().c_str ());\n+      return;\n+    }\n+\n+  if (!seg.has_generic_args ())\n+    {\n+      auto ident_segment\n+\t= CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t\t  seg.get_ident_segment ().as_string ());\n+      result = result.append (ident_segment);\n+      return;\n+    }\n+\n+  if (type_resolve_generic_args_flag)\n+    {\n+      bool ok = type_resolve_generic_args (seg.get_generic_args ());\n+      failure_flag = !ok;\n+    }\n+\n+  if (include_generic_args_flag)\n+    {\n+      std::string generics\n+\t= canonicalize_generic_args (seg.get_generic_args ());\n+      auto generic_segment\n+\t= CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t\t  seg.get_ident_segment ().as_string ()\n+\t\t\t\t    + \"::\" + generics);\n+      result = result.append (generic_segment);\n+      return;\n+    }\n+\n+  auto ident_segment\n+    = CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t      seg.get_ident_segment ().as_string ());\n+  result = result.append (ident_segment);\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::TypePathSegment &seg)\n+{\n+  if (seg.is_error ())\n+    {\n+      failure_flag = true;\n+      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n+\t\t     seg.as_string ().c_str ());\n+      return;\n+    }\n+\n+  CanonicalPath ident_seg\n+    = CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t      seg.get_ident_segment ().as_string ());\n+  result = result.append (ident_seg);\n+}\n+\n+void\n+ResolveType::visit (AST::ArrayType &type)\n+{\n+  type.get_elem_type ()->accept_vis (*this);\n+  // FIXME\n+  // the capacity expr can contain block-expr with functions but these should be\n+  // folded via constexpr code\n+  ResolveExpr::go (type.get_size_expr ().get (), type.get_node_id (),\n+\t\t   CanonicalPath::create_empty (),\n+\t\t   CanonicalPath::create_empty ());\n+}\n+\n+void\n+ResolveType::visit (AST::TraitObjectTypeOneBound &type)\n+{\n+  NodeId bound_resolved_id\n+    = ResolveTypeBound::go (&type.get_trait_bound (), type.get_node_id ());\n+  ok = bound_resolved_id != UNKNOWN_NODEID;\n+}\n+\n+void\n+ResolveType::visit (AST::TraitObjectType &type)\n+{\n+  ok = true;\n+  for (auto &bound : type.get_type_param_bounds ())\n+    {\n+      /* NodeId bound_resolved_id = */\n+      ResolveTypeBound::go (bound.get (), type.get_node_id ());\n+    }\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::ReferenceType &ref)\n+{\n+  auto inner_type\n+    = ResolveTypeToCanonicalPath::resolve (*ref.get_type_referenced ().get (),\n+\t\t\t\t\t   include_generic_args_flag,\n+\t\t\t\t\t   type_resolve_generic_args_flag);\n+\n+  std::string segment_string (\"&\");\n+  if (ref.get_has_mut ())\n+    segment_string += \"mut \";\n+\n+  segment_string += inner_type.get ();\n+\n+  auto ident_seg = CanonicalPath::new_seg (ref.get_node_id (), segment_string);\n+  result = result.append (ident_seg);\n+}\n+\n+void\n+ResolveType::visit (AST::ReferenceType &type)\n+{\n+  type.get_type_referenced ()->accept_vis (*this);\n+\n+  if (canonical_path != nullptr && canonical_path->size () > 0)\n+    {\n+      std::string seg = canonical_path->get ();\n+      *canonical_path = CanonicalPath::new_seg (type.get_node_id (), \"&\" + seg);\n+    }\n+}\n+\n+void\n+ResolveType::visit (AST::RawPointerType &type)\n+{\n+  type.get_type_pointed_to ()->accept_vis (*this);\n+\n+  if (canonical_path != nullptr && canonical_path->size () > 0)\n+    {\n+      std::string seg = canonical_path->get ();\n+      *canonical_path = CanonicalPath::new_seg (type.get_node_id (), \"*\" + seg);\n+    }\n+}\n+\n+void\n+ResolveType::visit (AST::InferredType &type)\n+{\n+  ok = true;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "2649e12bdaaa09cba6e209aea718ed71a4776680", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78cdc6ca310181ef4855841e9feefccb93f79816/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78cdc6ca310181ef4855841e9feefccb93f79816/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=78cdc6ca310181ef4855841e9feefccb93f79816", "patch": "@@ -382,31 +382,11 @@ class ResolveType : public ResolverBase\n \n   void visit (AST::ArrayType &type) override;\n \n-  void visit (AST::ReferenceType &type) override\n-  {\n-    type.get_type_referenced ()->accept_vis (*this);\n-\n-    if (canonical_path != nullptr && canonical_path->size () > 0)\n-      {\n-\tstd::string seg = canonical_path->get ();\n-\t*canonical_path\n-\t  = CanonicalPath::new_seg (type.get_node_id (), \"&\" + seg);\n-      }\n-  }\n+  void visit (AST::ReferenceType &type) override;\n \n-  void visit (AST::InferredType &type) override { ok = true; }\n+  void visit (AST::InferredType &type) override;\n \n-  void visit (AST::RawPointerType &type) override\n-  {\n-    type.get_type_pointed_to ()->accept_vis (*this);\n-\n-    if (canonical_path != nullptr && canonical_path->size () > 0)\n-      {\n-\tstd::string seg = canonical_path->get ();\n-\t*canonical_path\n-\t  = CanonicalPath::new_seg (type.get_node_id (), \"*\" + seg);\n-      }\n-  }\n+  void visit (AST::RawPointerType &type) override;\n \n   void visit (AST::TraitObjectTypeOneBound &type) override;\n "}, {"sha": "8f003e5fa5d22b2eb8796da2f9835129ba48fc5e", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78cdc6ca310181ef4855841e9feefccb93f79816/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78cdc6ca310181ef4855841e9feefccb93f79816/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=78cdc6ca310181ef4855841e9feefccb93f79816", "patch": "@@ -448,120 +448,6 @@ ResolveStructExprField::visit (AST::StructExprFieldIdentifier &field)\n   ResolveExpr::go (&expr, field.get_node_id (), prefix, canonical_prefix);\n }\n \n-// rust-ast-resolve-type.h\n-\n-std::string\n-ResolveTypeToCanonicalPath::canonicalize_generic_args (AST::GenericArgs &args)\n-{\n-  std::string buf;\n-\n-  size_t i = 0;\n-  size_t total = args.get_type_args ().size ();\n-\n-  for (auto &ty_arg : args.get_type_args ())\n-    {\n-      buf += ty_arg->as_string ();\n-      if ((i + 1) < total)\n-\tbuf += \",\";\n-\n-      i++;\n-    }\n-\n-  return \"<\" + buf + \">\";\n-}\n-\n-bool\n-ResolveTypeToCanonicalPath::type_resolve_generic_args (AST::GenericArgs &args)\n-{\n-  for (auto &gt : args.get_type_args ())\n-    {\n-      ResolveType::go (gt.get (), UNKNOWN_NODEID);\n-      // FIXME error handling here for inference variable since they do not have\n-      // a node to resolve to\n-      // if (resolved == UNKNOWN_NODEID) return false;\n-    }\n-  return true;\n-}\n-\n-void\n-ResolveTypeToCanonicalPath::visit (AST::TypePathSegmentGeneric &seg)\n-{\n-  if (seg.is_error ())\n-    {\n-      failure_flag = true;\n-      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n-\t\t     seg.as_string ().c_str ());\n-      return;\n-    }\n-\n-  if (!seg.has_generic_args ())\n-    {\n-      auto ident_segment\n-\t= CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t\t  seg.get_ident_segment ().as_string ());\n-      result = result.append (ident_segment);\n-      return;\n-    }\n-\n-  if (type_resolve_generic_args_flag)\n-    {\n-      bool ok = type_resolve_generic_args (seg.get_generic_args ());\n-      failure_flag = !ok;\n-    }\n-\n-  if (include_generic_args_flag)\n-    {\n-      std::string generics\n-\t= canonicalize_generic_args (seg.get_generic_args ());\n-      auto generic_segment\n-\t= CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t\t  seg.get_ident_segment ().as_string ()\n-\t\t\t\t    + \"::\" + generics);\n-      result = result.append (generic_segment);\n-      return;\n-    }\n-\n-  auto ident_segment\n-    = CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t      seg.get_ident_segment ().as_string ());\n-  result = result.append (ident_segment);\n-}\n-\n-void\n-ResolveTypeToCanonicalPath::visit (AST::TypePathSegment &seg)\n-{\n-  if (seg.is_error ())\n-    {\n-      failure_flag = true;\n-      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n-\t\t     seg.as_string ().c_str ());\n-      return;\n-    }\n-\n-  CanonicalPath ident_seg\n-    = CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t      seg.get_ident_segment ().as_string ());\n-  result = result.append (ident_seg);\n-}\n-\n-void\n-ResolveTypeToCanonicalPath::visit (AST::ReferenceType &ref)\n-{\n-  auto inner_type\n-    = ResolveTypeToCanonicalPath::resolve (*ref.get_type_referenced ().get (),\n-\t\t\t\t\t   include_generic_args_flag,\n-\t\t\t\t\t   type_resolve_generic_args_flag);\n-\n-  std::string segment_string (\"&\");\n-  if (ref.get_has_mut ())\n-    segment_string += \"mut \";\n-\n-  segment_string += inner_type.get ();\n-\n-  auto ident_seg = CanonicalPath::new_seg (ref.get_node_id (), segment_string);\n-  result = result.append (ident_seg);\n-}\n-\n // rust-ast-resolve-expr.h\n \n void\n@@ -799,39 +685,6 @@ ResolvePath::resolve_segments (CanonicalPath prefix, size_t offs,\n     }\n }\n \n-// rust-ast-resolve-type.h\n-\n-void\n-ResolveType::visit (AST::ArrayType &type)\n-{\n-  type.get_elem_type ()->accept_vis (*this);\n-  // FIXME\n-  // the capacity expr can contain block-expr with functions but these should be\n-  // folded via constexpr code\n-  ResolveExpr::go (type.get_size_expr ().get (), type.get_node_id (),\n-\t\t   CanonicalPath::create_empty (),\n-\t\t   CanonicalPath::create_empty ());\n-}\n-\n-void\n-ResolveType::visit (AST::TraitObjectTypeOneBound &type)\n-{\n-  NodeId bound_resolved_id\n-    = ResolveTypeBound::go (&type.get_trait_bound (), type.get_node_id ());\n-  ok = bound_resolved_id != UNKNOWN_NODEID;\n-}\n-\n-void\n-ResolveType::visit (AST::TraitObjectType &type)\n-{\n-  ok = true;\n-  for (auto &bound : type.get_type_param_bounds ())\n-    {\n-      /* NodeId bound_resolved_id = */\n-      ResolveTypeBound::go (bound.get (), type.get_node_id ());\n-    }\n-}\n-\n // rust-ast-resolve-item.h\n \n void"}]}