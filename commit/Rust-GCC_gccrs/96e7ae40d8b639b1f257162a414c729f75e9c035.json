{"sha": "96e7ae40d8b639b1f257162a414c729f75e9c035", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZlN2FlNDBkOGI2MzliMWYyNTcxNjJhNDE0YzcyOWY3NWU5YzAzNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-11-19T09:12:18Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "1999-11-19T09:12:18Z"}, "message": "i386.h (struct_processor_costs): New fileds int_load, int_store, fp_move, fp_load and fp_store\n\n\t* i386.h (struct_processor_costs): New fileds int_load, int_store, fp_move,\n\tfp_load and fp_store\n\t(REGISTER_MOVE_COST): Fix comment, calculate exactly the cost of\n\tfp->int moves\n\t(MEMORY_MOVE_COST): New macro.\n\t* i386.c (386_cost): Define new fields.\n\t(i486_cost): Likewise.\n\t(pentium_cost): Likewise.\n\t(pentiumpro_cost): Likewise.\n\t(k6_cost): Likewise.\n\nFrom-SVN: r30585", "tree": {"sha": "577a63534540be656ad0c7931693f22e26974e59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/577a63534540be656ad0c7931693f22e26974e59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96e7ae40d8b639b1f257162a414c729f75e9c035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96e7ae40d8b639b1f257162a414c729f75e9c035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96e7ae40d8b639b1f257162a414c729f75e9c035", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96e7ae40d8b639b1f257162a414c729f75e9c035/comments", "author": null, "committer": null, "parents": [{"sha": "25b540c639e38e008e16b2c00c47fdf21bc96eab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25b540c639e38e008e16b2c00c47fdf21bc96eab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25b540c639e38e008e16b2c00c47fdf21bc96eab"}], "stats": {"total": 114, "additions": 97, "deletions": 17}, "files": [{"sha": "46c575bfdddd6a495db2760976dfa99fe4744c8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e7ae40d8b639b1f257162a414c729f75e9c035/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e7ae40d8b639b1f257162a414c729f75e9c035/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96e7ae40d8b639b1f257162a414c729f75e9c035", "patch": "@@ -1,3 +1,15 @@\n+Fri Nov 18 13:39:22 CET 1999  Jam Hubicka  <hubicka@freesoft.cz>\n+\t* i386.h (struct_processor_costs): New fileds int_load, int_store, fp_move,\n+\tfp_load and fp_store\n+\t(REGISTER_MOVE_COST): Fix comment, calculate exactly the cost of\n+\tfp->int moves\n+\t(MEMORY_MOVE_COST): New macro.\n+\t* i386.c (386_cost): Define new fields.\n+\t(i486_cost): Likewise.\n+\t(pentium_cost): Likewise.\n+\t(pentiumpro_cost): Likewise.\n+\t(k6_cost): Likewise.\n+\n Fri Nov 19 11:11:55 1999  Greg McGary  <gkm@gnu.org>\n \t\t\t  Geoffrey Keating  <geoffk@cygnus.com>\n "}, {"sha": "4707ebff9e953b758dc97a7b2a65349b511096c1", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e7ae40d8b639b1f257162a414c729f75e9c035/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e7ae40d8b639b1f257162a414c729f75e9c035/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=96e7ae40d8b639b1f257162a414c729f75e9c035", "patch": "@@ -63,7 +63,15 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n   6,\t\t\t\t\t/* cost of starting a multiply */\n   1,\t\t\t\t\t/* cost of multiply per each bit set */\n   23,\t\t\t\t\t/* cost of a divide/mod */\n-  15\t\t\t\t\t/* \"large\" insn */\n+  15,\t\t\t\t\t/* \"large\" insn */\n+  {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2). */\n+  {2, 4, 2},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {8, 8, 8},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {8, 8, 8}\t\t\t\t/* cost of loading integer registers */\n };\n \n struct processor_costs i486_cost = {\t/* 486 specific costs */\n@@ -74,7 +82,15 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   12,\t\t\t\t\t/* cost of starting a multiply */\n   1,\t\t\t\t\t/* cost of multiply per each bit set */\n   40,\t\t\t\t\t/* cost of a divide/mod */\n-  15\t\t\t\t\t/* \"large\" insn */\n+  15,\t\t\t\t\t/* \"large\" insn */\n+  {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2). */\n+  {2, 4, 2},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {8, 8, 8},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {8, 8, 8}\t\t\t\t/* cost of loading integer registers */\n };\n \n struct processor_costs pentium_cost = {\n@@ -85,7 +101,15 @@ struct processor_costs pentium_cost = {\n   11,\t\t\t\t\t/* cost of starting a multiply */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   25,\t\t\t\t\t/* cost of a divide/mod */\n-  8\t\t\t\t\t/* \"large\" insn */\n+  8,\t\t\t\t\t/* \"large\" insn */\n+  {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2). */\n+  {2, 4, 2},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {2, 2, 6},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {4, 4, 6}\t\t\t\t/* cost of loading integer registers */\n };\n \n struct processor_costs pentiumpro_cost = {\n@@ -96,7 +120,15 @@ struct processor_costs pentiumpro_cost = {\n   1,\t\t\t\t\t/* cost of starting a multiply */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   17,\t\t\t\t\t/* cost of a divide/mod */\n-  8\t\t\t\t\t/* \"large\" insn */\n+  8,\t\t\t\t\t/* \"large\" insn */\n+  {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2). */\n+  {2, 2, 2},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {2, 2, 6},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {4, 4, 6}\t\t\t\t/* cost of loading integer registers */\n };\n \n struct processor_costs k6_cost = {\n@@ -107,7 +139,15 @@ struct processor_costs k6_cost = {\n   3,\t\t\t\t\t/* cost of starting a multiply */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   18,\t\t\t\t\t/* cost of a divide/mod */\n-  8\t\t\t\t\t/* \"large\" insn */\n+  8,\t\t\t\t\t/* \"large\" insn */\n+  {4, 5, 4},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2). */\n+  {2, 3, 2},\t\t\t\t/* cost of storing integer registers */\n+  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {6, 6, 6},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {4, 4, 4}\t\t\t\t/* cost of loading integer registers */\n };\n \n struct processor_costs *ix86_cost = &pentium_cost;"}, {"sha": "ee2b51f5a5112d86b6f2c29ad5b4f34c54247a33", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96e7ae40d8b639b1f257162a414c729f75e9c035/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96e7ae40d8b639b1f257162a414c729f75e9c035/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=96e7ae40d8b639b1f257162a414c729f75e9c035", "patch": "@@ -62,6 +62,16 @@ struct processor_costs {\n   int mult_bit;\t\t\t/* cost of multiply per each bit set */\n   int divide;\t\t\t/* cost of a divide/mod */\n   int large_insn;\t\t/* insns larger than this cost more */\n+  int int_load[3];\t\t/* cost of loading integer registers\n+\t\t\t\t   in QImode, HImode and SImode relative\n+\t\t\t\t   to reg-reg move (2).  */\n+  int int_store[3];\t\t/* cost of storing integer register\n+\t\t\t\t   in QImode, HImode and SImode */\n+  int fp_move;\t\t\t/* cost of reg,reg fld/fst */\n+  int fp_load[3];\t\t/* cost of loading FP register\n+\t\t\t\t   in SFmode, DFmode and XFmode */\n+  int fp_store[3];\t\t/* cost of storing FP register\n+\t\t\t\t   in SFmode, DFmode and XFmode */\n };\n \n extern struct processor_costs *ix86_cost;\n@@ -1956,22 +1966,28 @@ while (0)\n    : REG_P (RTX) ? 1\t\t\t\t\t\t\\\n    : 2)\n \n-/* A C expression for the cost of moving data of mode M between a\n-   register and memory.  A value of 2 is the default; this cost is\n-   relative to those in `REGISTER_MOVE_COST'.\n+/* A C expression for the cost of moving data from a register in class FROM to\n+   one in class TO.  The classes are expressed using the enumeration values\n+   such as `GENERAL_REGS'.  A value of 2 is the default; other values are\n+   interpreted relative to that.\n \n-   If moving between registers and memory is more expensive than\n-   between two registers, you should define this macro to express the\n-   relative cost.\n+   It is not required that the cost always equal 2 when FROM is the same as TO;\n+   on some machines it is expensive to move between registers if they are not\n+   general registers.\n \n    On the i386, copying between floating-point and fixed-point\n-   registers is expensive.  */\n+   registers is done trough memory.  \n+ \n+   Integer -> fp moves are noticeably slower than the opposite direction\n+   because of the partial memory stall they cause.  Give it an\n+   arbitary high cost.\n+ */\n \n #define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\t\t\t\\\n-  (((FLOAT_CLASS_P (CLASS1) && ! FLOAT_CLASS_P (CLASS2))\t\t\\\n-    || (! FLOAT_CLASS_P (CLASS1) && FLOAT_CLASS_P (CLASS2))) ? 10\t\\\n-   : 2)\n-\n+  ((FLOAT_CLASS_P (CLASS1) && ! FLOAT_CLASS_P (CLASS2))\t\t\t\\\n+   ? (MEMORY_MOVE_COST (DFmode, CLASS1, 0)\t\t\t\t\\\n+     + MEMORY_MOVE_COST (DFmode, CLASS2, 1))\t\t\t\t\\\n+   : (! FLOAT_CLASS_P (CLASS1) && FLOAT_CLASS_P (CLASS2)) ? 10 : 2)\n \n /* A C expression for the cost of moving data of mode M between a\n    register and memory.  A value of 2 is the default; this cost is\n@@ -1981,7 +1997,19 @@ while (0)\n    between two registers, you should define this macro to express the\n    relative cost.  */\n \n-/* #define MEMORY_MOVE_COST(M,C,I) 2  */\n+#define MEMORY_MOVE_COST(MODE,CLASS,IN)\t\t\t\t\t\\\n+  (FLOAT_CLASS_P (CLASS)\t\t\t\t\t\t\\\n+   ? (GET_MODE_SIZE (MODE)==4\t\t\t\t\t\t\\\n+      ? (IN ? ix86_cost->fp_load[0] : ix86_cost->fp_store[0])\t\t\\\n+      : (GET_MODE_SIZE (MODE)==8\t\t\t\t\t\\\n+\t ? (IN ? ix86_cost->fp_load[1] : ix86_cost->fp_store[1])\t\\\n+\t : (IN ? ix86_cost->fp_load[2] : ix86_cost->fp_store[2])))\t\\\n+   : (GET_MODE_SIZE (MODE)==1\t\t\t\t\t\t\\\n+      ? (IN ? ix86_cost->int_load[0] : ix86_cost->int_store[0])\t\t\\\n+      : (GET_MODE_SIZE (MODE)==2\t\t\t\t\t\\\n+\t ? (IN ? ix86_cost->int_load[1] : ix86_cost->int_store[1])\t\\\n+\t : ((IN ? ix86_cost->int_load[2] : ix86_cost->int_store[2])\t\\\n+\t    * GET_MODE_SIZE (MODE) / 4))))\n \n /* A C expression for the cost of a branch instruction.  A value of 1\n    is the default; other values are interpreted relative to that.  */"}]}