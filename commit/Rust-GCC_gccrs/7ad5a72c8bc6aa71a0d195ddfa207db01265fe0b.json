{"sha": "7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FkNWE3MmM4YmM2YWE3MWEwZDE5NWRkZmEyMDdkYjAxMjY1ZmUwYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-03-11T03:38:21Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-03-11T23:48:10Z"}, "message": "compiler: create temporaries for heap variables\n\nThe compiler generally doesn't create a temporary for an expression\nthat is a variable, because it's normally valid to simply reload the\nvalue from the variable.  However, if the variable is in the heap,\nthen loading the value is a pointer indirection.  The process of\ncreating GCC IR can cause the variable load and the pointer\nindirection to be split, such that the second evaluation only does the\npointer indirection.  If there are conditionals in between the two\nuses, this can cause the second use to load the pointer from an\nuninitialized register.\n\nAvoid this by introducing a new Expression method that returns whether\nit is safe to evaluate an expression multiple times, and use it\neverywhere.\n\nThe test case is https://golang.org/cl/300789.\n\nFixes golang/go#44383\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/300809", "tree": {"sha": "764937d8460563db6132d7c75e19b95ef3ea6ea8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/764937d8460563db6132d7c75e19b95ef3ea6ea8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3857edb5d32dcdc11d9a2fe3ad7c156c52a1ec7f"}], "stats": {"total": 155, "additions": 99, "deletions": 56}, "files": [{"sha": "58c881a787293eb50213326b0eb039d112742fd1", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b", "patch": "@@ -1,4 +1,4 @@\n-93380a9126e76b71fa208e62c31c7914084c0e37\n+bf35249a7c752836741b1cab43a312f87916fcb0\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "101cbe7ac316688eeb572c286cf25e67afaa01f4", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 87, "deletions": 49, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b", "patch": "@@ -526,7 +526,7 @@ Expression::convert_interface_to_interface(Type *lhs_type, Expression* rhs,\n   // method table.\n \n   // We are going to evaluate RHS multiple times.\n-  go_assert(rhs->is_variable());\n+  go_assert(rhs->is_multi_eval_safe());\n \n   // Get the type descriptor for the right hand side.  This will be\n   // NULL for a nil interface.\n@@ -569,7 +569,7 @@ Expression::convert_interface_to_type(Gogo* gogo, Type *lhs_type, Expression* rh\n                                       Location location)\n {\n   // We are going to evaluate RHS multiple times.\n-  go_assert(rhs->is_variable());\n+  go_assert(rhs->is_multi_eval_safe());\n \n   // Build an expression to check that the type is valid.  It will\n   // panic with an appropriate runtime type error if the type is not\n@@ -707,8 +707,8 @@ Expression::check_bounds(Expression* val, Operator op, Expression* bound,\n \t\t\t Statement_inserter* inserter,\n \t\t\t Location loc)\n {\n-  go_assert(val->is_variable() || val->is_constant());\n-  go_assert(bound->is_variable() || bound->is_constant());\n+  go_assert(val->is_multi_eval_safe());\n+  go_assert(bound->is_multi_eval_safe());\n \n   Type* int_type = Type::lookup_integer_type(\"int\");\n   int int_type_size = int_type->integer_type()->bits();\n@@ -3976,7 +3976,7 @@ Type_conversion_expression::do_flatten(Gogo*, Named_object*,\n   if (((this->type()->is_string_type()\n         && this->expr_->type()->is_slice_type())\n        || this->expr_->type()->interface_type() != NULL)\n-      && !this->expr_->is_variable())\n+      && !this->expr_->is_multi_eval_safe())\n     {\n       Temporary_statement* temp =\n           Statement::make_temporary(NULL, this->expr_, this->location());\n@@ -4264,7 +4264,7 @@ Type_conversion_expression::do_get_backend(Translate_context* context)\n       Array_type* a = expr_type->array_type();\n       Type* e = a->element_type()->forwarded();\n       go_assert(e->integer_type() != NULL);\n-      go_assert(this->expr_->is_variable());\n+      go_assert(this->expr_->is_multi_eval_safe());\n \n       Expression* buf;\n       if (this->no_escape_ && !this->no_copy_)\n@@ -4711,7 +4711,7 @@ Unary_expression::do_flatten(Gogo* gogo, Named_object*,\n \n   Location location = this->location();\n   if (this->op_ == OPERATOR_MULT\n-      && !this->expr_->is_variable())\n+      && !this->expr_->is_multi_eval_safe())\n     {\n       go_assert(this->expr_->type()->points_to() != NULL);\n       switch (this->requires_nil_check(gogo))\n@@ -4731,7 +4731,7 @@ Unary_expression::do_flatten(Gogo* gogo, Named_object*,\n         }\n     }\n \n-  if (this->create_temp_ && !this->expr_->is_variable())\n+  if (this->create_temp_ && !this->expr_->is_multi_eval_safe())\n     {\n       Temporary_statement* temp =\n           Statement::make_temporary(NULL, this->expr_, location);\n@@ -5326,7 +5326,7 @@ Unary_expression::do_get_backend(Translate_context* context)\n           bexpr = gogo->backend()->var_expression(decl, loc);\n         }\n \n-      go_assert(!this->create_temp_ || this->expr_->is_variable());\n+      go_assert(!this->create_temp_ || this->expr_->is_multi_eval_safe());\n       ret = gogo->backend()->address_expression(bexpr, loc);\n       break;\n \n@@ -5347,7 +5347,7 @@ Unary_expression::do_get_backend(Translate_context* context)\n               }\n             case NIL_CHECK_NEEDED:\n               {\n-                go_assert(this->expr_->is_variable());\n+                go_assert(this->expr_->is_multi_eval_safe());\n \n                 // If we're nil-checking the result of a set-and-use-temporary\n                 // expression, then pick out the target temp and use that\n@@ -6496,13 +6496,13 @@ Binary_expression::do_flatten(Gogo* gogo, Named_object*,\n \t  && (gogo->check_divide_by_zero() || gogo->check_divide_overflow()))\n       || is_string_op)\n     {\n-      if (!this->left_->is_variable() && !this->left_->is_constant())\n+      if (!this->left_->is_multi_eval_safe())\n         {\n           temp = Statement::make_temporary(NULL, this->left_, loc);\n           inserter->insert(temp);\n           this->left_ = Expression::make_temporary_reference(temp, loc);\n         }\n-      if (!this->right_->is_variable() && !this->right_->is_constant())\n+      if (!this->right_->is_multi_eval_safe())\n         {\n           temp =\n               Statement::make_temporary(NULL, this->right_, loc);\n@@ -7478,8 +7478,8 @@ Expression::comparison(Translate_context* context, Type* result_type,\n \n   if (left_type->is_string_type() && right_type->is_string_type())\n     {\n-      go_assert(left->is_variable() || left->is_constant());\n-      go_assert(right->is_variable() || right->is_constant());\n+      go_assert(left->is_multi_eval_safe());\n+      go_assert(right->is_multi_eval_safe());\n \n       if (op == OPERATOR_EQEQ || op == OPERATOR_NOTEQ)\n \t{\n@@ -8078,7 +8078,7 @@ Bound_method_expression::do_flatten(Gogo* gogo, Named_object*,\n   // we are going to do nil checks below, but it's easy enough to\n   // always do it.\n   Expression* expr = this->expr_;\n-  if (!expr->is_variable())\n+  if (!expr->is_multi_eval_safe())\n     {\n       Temporary_statement* etemp = Statement::make_temporary(NULL, expr, loc);\n       inserter->insert(etemp);\n@@ -8419,7 +8419,7 @@ Builtin_call_expression::do_lower(Gogo*, Named_object* function,\n \t   pa != this->args()->end();\n \t   ++pa)\n \t{\n-\t  if (!(*pa)->is_variable() && !(*pa)->is_constant())\n+\t  if (!(*pa)->is_multi_eval_safe())\n \t    {\n \t      Temporary_statement* temp =\n \t\tStatement::make_temporary(NULL, *pa, loc);\n@@ -8470,7 +8470,7 @@ Builtin_call_expression::do_flatten(Gogo* gogo, Named_object* function,\n \t\tExpression* zero = Expression::make_integer_ul(0, NULL, loc);\n \t\t*pa = Expression::make_slice_value(at, nil, zero, zero, loc);\n \t      }\n-\t    if (!(*pa)->is_variable())\n+\t    if (!(*pa)->is_multi_eval_safe())\n \t      {\n \t\tTemporary_statement* temp =\n                   Statement::make_temporary(NULL, *pa, loc);\n@@ -8484,8 +8484,8 @@ Builtin_call_expression::do_flatten(Gogo* gogo, Named_object* function,\n         go_assert(args != NULL && args->size() == 2);\n         Expression* arg1 = args->front();\n         Expression* arg2 = args->back();\n-        go_assert(arg1->is_variable());\n-        go_assert(arg2->is_variable());\n+\tgo_assert(arg1->is_multi_eval_safe());\n+\tgo_assert(arg2->is_multi_eval_safe());\n         bool arg2_is_string = arg2->type()->is_string_type();\n \n         Expression* ret;\n@@ -8573,7 +8573,8 @@ Builtin_call_expression::do_flatten(Gogo* gogo, Named_object* function,\n \t   pa != this->args()->end();\n \t   ++pa)\n \t{\n-\t  if (!(*pa)->is_variable() && (*pa)->type()->interface_type() != NULL)\n+\t  if (!(*pa)->is_multi_eval_safe()\n+\t      && (*pa)->type()->interface_type() != NULL)\n \t    {\n \t      Temporary_statement* temp =\n \t\tStatement::make_temporary(NULL, *pa, loc);\n@@ -8587,7 +8588,7 @@ Builtin_call_expression::do_flatten(Gogo* gogo, Named_object* function,\n     case BUILTIN_CAP:\n       {\n \tExpression_list::iterator pa = this->args()->begin();\n-\tif (!(*pa)->is_variable()\n+\tif (!(*pa)->is_multi_eval_safe()\n \t    && ((*pa)->type()->map_type() != NULL\n \t\t|| (*pa)->type()->channel_type() != NULL))\n \t  {\n@@ -9024,7 +9025,7 @@ Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n       Expression_list::const_iterator pa = args->begin();\n       for (++pa; pa != args->end(); ++pa)\n \t{\n-\t  if ((*pa)->is_variable())\n+\t  if ((*pa)->is_multi_eval_safe())\n \t    add->push_back(*pa);\n \t  else\n \t    {\n@@ -11235,7 +11236,7 @@ Call_expression::do_flatten(Gogo* gogo, Named_object*,\n \t    {\n \t      Location loc = (*pa)->location();\n \t      Expression* arg = *pa;\n-\t      if (!arg->is_variable())\n+\t      if (!arg->is_multi_eval_safe())\n \t\t{\n \t\t  Temporary_statement *temp =\n \t\t    Statement::make_temporary(NULL, arg, loc);\n@@ -11457,7 +11458,7 @@ Call_expression::intrinsify(Gogo* gogo,\n                && this->args_ != NULL && this->args_->size() == 1)\n         {\n           Expression* arg = this->args_->front();\n-          if (!arg->is_variable())\n+          if (!arg->is_multi_eval_safe())\n             {\n               Temporary_statement* ts = Statement::make_temporary(uint32_type, arg, loc);\n               inserter->insert(ts);\n@@ -11476,7 +11477,7 @@ Call_expression::intrinsify(Gogo* gogo,\n                && this->args_ != NULL && this->args_->size() == 1)\n         {\n           Expression* arg = this->args_->front();\n-          if (!arg->is_variable())\n+          if (!arg->is_multi_eval_safe())\n             {\n               Temporary_statement* ts = Statement::make_temporary(uint64_type, arg, loc);\n               inserter->insert(ts);\n@@ -11526,7 +11527,7 @@ Call_expression::intrinsify(Gogo* gogo,\n                && this->args_ != NULL && this->args_->size() == 1)\n         {\n           Expression* arg = this->args_->front();\n-          if (!arg->is_variable())\n+          if (!arg->is_multi_eval_safe())\n             {\n               Temporary_statement* ts = Statement::make_temporary(uint32_type, arg, loc);\n               inserter->insert(ts);\n@@ -11549,7 +11550,7 @@ Call_expression::intrinsify(Gogo* gogo,\n                && this->args_ != NULL && this->args_->size() == 1)\n         {\n           Expression* arg = this->args_->front();\n-          if (!arg->is_variable())\n+          if (!arg->is_multi_eval_safe())\n             {\n               Temporary_statement* ts = Statement::make_temporary(uint64_type, arg, loc);\n               inserter->insert(ts);\n@@ -13087,14 +13088,14 @@ Array_index_expression::do_flatten(Gogo* gogo, Named_object*,\n     }\n \n   Temporary_statement* temp;\n-  if (array_type->is_slice_type() && !array->is_variable())\n+  if (array_type->is_slice_type() && !array->is_multi_eval_safe())\n     {\n       temp = Statement::make_temporary(NULL, array, loc);\n       inserter->insert(temp);\n       this->array_ = Expression::make_temporary_reference(temp, loc);\n       array = this->array_;\n     }\n-  if (!start->is_variable() && !start->is_constant())\n+  if (!start->is_multi_eval_safe())\n     {\n       temp = Statement::make_temporary(NULL, start, loc);\n       inserter->insert(temp);\n@@ -13103,15 +13104,14 @@ Array_index_expression::do_flatten(Gogo* gogo, Named_object*,\n     }\n   if (end != NULL\n       && !end->is_nil_expression()\n-      && !end->is_variable()\n-      && !end->is_constant())\n+      && !end->is_multi_eval_safe())\n     {\n       temp = Statement::make_temporary(NULL, end, loc);\n       inserter->insert(temp);\n       this->end_ = Expression::make_temporary_reference(temp, loc);\n       end = this->end_;\n     }\n-  if (cap != NULL && !cap->is_variable() && !cap->is_constant())\n+  if (cap != NULL && !cap->is_multi_eval_safe())\n     {\n       temp = Statement::make_temporary(NULL, cap, loc);\n       inserter->insert(temp);\n@@ -13270,7 +13270,8 @@ Array_index_expression::do_get_backend(Translate_context* context)\n       go_assert(this->array_->type()->is_error());\n       return context->backend()->error_expression();\n     }\n-  go_assert(!array_type->is_slice_type() || this->array_->is_variable());\n+  go_assert(!array_type->is_slice_type()\n+\t    || this->array_->is_multi_eval_safe());\n \n   Location loc = this->location();\n   Gogo* gogo = context->gogo();\n@@ -13484,14 +13485,14 @@ String_index_expression::do_flatten(Gogo*, Named_object*,\n     }\n \n   Temporary_statement* temp;\n-  if (!string->is_variable())\n+  if (!string->is_multi_eval_safe())\n     {\n       temp = Statement::make_temporary(NULL, string, loc);\n       inserter->insert(temp);\n       this->string_ = Expression::make_temporary_reference(temp, loc);\n       string = this->string_;\n     }\n-  if (!start->is_variable())\n+  if (!start->is_multi_eval_safe())\n     {\n       temp = Statement::make_temporary(NULL, start, loc);\n       inserter->insert(temp);\n@@ -13500,7 +13501,7 @@ String_index_expression::do_flatten(Gogo*, Named_object*,\n     }\n   if (end != NULL\n       && !end->is_nil_expression()\n-      && !end->is_variable())\n+      && !end->is_multi_eval_safe())\n     {\n       temp = Statement::make_temporary(NULL, end, loc);\n       inserter->insert(temp);\n@@ -13659,8 +13660,8 @@ String_index_expression::do_get_backend(Translate_context* context)\n       return context->backend()->error_expression();\n     }\n \n-  go_assert(this->string_->is_variable());\n-  go_assert(this->start_->is_variable());\n+  go_assert(this->string_->is_multi_eval_safe());\n+  go_assert(this->start_->is_multi_eval_safe());\n \n   Expression* start = Expression::make_cast(int_type, this->start_, loc);\n   Bfunction* bfn = context->function()->func_value()->get_decl();\n@@ -13685,7 +13686,7 @@ String_index_expression::do_get_backend(Translate_context* context)\n     end = length;\n   else\n     {\n-      go_assert(this->end_->is_variable());\n+      go_assert(this->end_->is_multi_eval_safe());\n       end = Expression::make_cast(int_type, this->end_, loc);\n     }\n \n@@ -13815,7 +13816,7 @@ Map_index_expression::do_flatten(Gogo* gogo, Named_object*,\n \t\t\t   NULL))\n     {\n       if (this->index_->type()->interface_type() != NULL\n-\t  && !this->index_->is_variable())\n+\t  && !this->index_->is_multi_eval_safe())\n \t{\n \t  Temporary_statement* temp =\n \t    Statement::make_temporary(NULL, this->index_, loc);\n@@ -13826,7 +13827,7 @@ Map_index_expression::do_flatten(Gogo* gogo, Named_object*,\n \t\t\t\t\t\t\tthis->index_, loc);\n     }\n \n-  if (!this->index_->is_variable())\n+  if (!this->index_->is_multi_eval_safe())\n     {\n       Temporary_statement* temp = Statement::make_temporary(NULL, this->index_,\n                                                             loc);\n@@ -13839,7 +13840,7 @@ Map_index_expression::do_flatten(Gogo* gogo, Named_object*,\n   if (this->value_pointer_->is_error_expression()\n       || this->value_pointer_->type()->is_error_type())\n     return Expression::make_error(loc);\n-  if (!this->value_pointer_->is_variable())\n+  if (!this->value_pointer_->is_multi_eval_safe())\n     {\n       Temporary_statement* temp =\n \tStatement::make_temporary(NULL, this->value_pointer_, loc);\n@@ -13923,7 +13924,7 @@ Map_index_expression::do_get_backend(Translate_context* context)\n     }\n \n   go_assert(this->value_pointer_ != NULL\n-            && this->value_pointer_->is_variable());\n+            && this->value_pointer_->is_multi_eval_safe());\n \n   Expression* val = Expression::make_dereference(this->value_pointer_,\n                                                  NIL_CHECK_NOT_NEEDED,\n@@ -14268,7 +14269,7 @@ Interface_field_reference_expression::do_flatten(Gogo*, Named_object*,\n       return Expression::make_error(this->location());\n     }\n \n-  if (!this->expr_->is_variable())\n+  if (!this->expr_->is_multi_eval_safe())\n     {\n       Temporary_statement* temp =\n \tStatement::make_temporary(NULL, this->expr_, this->location());\n@@ -15165,7 +15166,7 @@ Struct_construction_expression::do_flatten(Gogo*, Named_object*,\n               go_assert(saw_errors());\n               return Expression::make_error(loc);\n             }\n-\t  if (!(*pv)->is_variable())\n+\t  if (!(*pv)->is_multi_eval_safe())\n \t    {\n \t      Temporary_statement* temp =\n \t\tStatement::make_temporary(NULL, *pv, loc);\n@@ -15471,7 +15472,7 @@ Array_construction_expression::do_flatten(Gogo*, Named_object*,\n               go_assert(saw_errors());\n               return Expression::make_error(loc);\n             }\n-\t  if (!(*pv)->is_variable())\n+\t  if (!(*pv)->is_multi_eval_safe())\n \t    {\n \t      Temporary_statement* temp =\n \t\tStatement::make_temporary(NULL, *pv, loc);\n@@ -15914,7 +15915,8 @@ Map_construction_expression::do_flatten(Gogo* gogo, Named_object*,\n               go_assert(saw_errors());\n               return Expression::make_error(loc);\n             }\n-\t  if (key->type()->interface_type() != NULL && !key->is_variable())\n+\t  if (key->type()->interface_type() != NULL\n+\t      && !key->is_multi_eval_safe())\n \t    {\n \t      Temporary_statement* temp =\n \t\tStatement::make_temporary(NULL, key, loc);\n@@ -15930,7 +15932,8 @@ Map_construction_expression::do_flatten(Gogo* gogo, Named_object*,\n               go_assert(saw_errors());\n               return Expression::make_error(loc);\n             }\n-\t  if (val->type()->interface_type() != NULL && !val->is_variable())\n+\t  if (val->type()->interface_type() != NULL\n+\t      && !val->is_multi_eval_safe())\n \t    {\n \t      Temporary_statement* temp =\n \t\tStatement::make_temporary(NULL, val, loc);\n@@ -17037,6 +17040,41 @@ Expression::is_local_variable() const\n \t  || (no->is_variable() && !no->var_value()->is_global()));\n }\n \n+// Return true if multiple evaluations are OK.\n+\n+bool\n+Expression::is_multi_eval_safe()\n+{\n+  switch (this->classification_)\n+    {\n+    case EXPRESSION_VAR_REFERENCE:\n+      {\n+\t// A variable is a simple reference if not stored in the heap.\n+\tconst Named_object* no = this->var_expression()->named_object();\n+\tif (no->is_variable())\n+\t  return !no->var_value()->is_in_heap();\n+\telse if (no->is_result_variable())\n+\t  return !no->result_var_value()->is_in_heap();\n+\telse\n+\t  go_unreachable();\n+      }\n+\n+    case EXPRESSION_TEMPORARY_REFERENCE:\n+      return true;\n+\n+    default:\n+      break;\n+    }\n+\n+  if (!this->is_constant())\n+    return false;\n+\n+  // Only numeric and boolean constants are really multi-evaluation\n+  // safe.  We don't want multiple copies of string constants.\n+  Type* type = this->type();\n+  return type->is_numeric_type() || type->is_boolean_type();\n+}\n+\n const Named_object*\n Expression::named_constant() const\n {\n@@ -17070,7 +17108,7 @@ Type_guard_expression::do_flatten(Gogo*, Named_object*,\n       return Expression::make_error(this->location());\n     }\n \n-  if (!this->expr_->is_variable())\n+  if (!this->expr_->is_multi_eval_safe())\n     {\n       Temporary_statement* temp = Statement::make_temporary(NULL, this->expr_,\n                                                             this->location());"}, {"sha": "e3747cc65d767e73ea7981c7b4fc3d7bc3c435e0", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b", "patch": "@@ -916,6 +916,11 @@ class Expression\n   bool\n   is_local_variable() const;\n \n+  // Return true if multiple evaluations of this expression are OK.\n+  // This is true for simple variable references and constants.\n+  bool\n+  is_multi_eval_safe();\n+\n   // Return true if two expressions refer to the same variable or\n   // struct field.\n   static bool"}, {"sha": "93b54fd8c118e722e897f5e94160592e14079f44", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b", "patch": "@@ -7579,7 +7579,7 @@ Variable::flatten_init_expression(Gogo* gogo, Named_object* function,\n \t\t\t\t  Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n \t\t\t\t  NULL)\n \t  && this->init_->type()->interface_type() != NULL\n-\t  && !this->init_->is_variable())\n+\t  && !this->init_->is_multi_eval_safe())\n \t{\n \t  Temporary_statement* temp =\n \t    Statement::make_temporary(NULL, this->init_, this->location_);"}, {"sha": "7ad7339bda8711d3dee4edb04bc980c89ab26b47", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b", "patch": "@@ -588,7 +588,7 @@ Temporary_statement::do_flatten(Gogo*, Named_object*, Block*,\n \t\t\t      Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n \t\t\t      NULL)\n       && this->init_->type()->interface_type() != NULL\n-      && !this->init_->is_variable())\n+      && !this->init_->is_multi_eval_safe())\n     {\n       Temporary_statement *temp =\n \tStatement::make_temporary(NULL, this->init_, this->location());\n@@ -1125,7 +1125,7 @@ Assignment_statement::do_flatten(Gogo*, Named_object*, Block*,\n \t\t\t      Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n \t\t\t      NULL)\n       && this->rhs_->type()->interface_type() != NULL\n-      && !this->rhs_->is_variable())\n+      && !this->rhs_->is_multi_eval_safe())\n     {\n       Temporary_statement* temp =\n \tStatement::make_temporary(NULL, this->rhs_, this->location());\n@@ -5116,7 +5116,7 @@ Send_statement::do_flatten(Gogo*, Named_object*, Block*,\n \t\t\t   Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n \t\t\t   NULL)\n       && this->val_->type()->interface_type() != NULL\n-      && !this->val_->is_variable())\n+      && !this->val_->is_multi_eval_safe())\n     {\n       Temporary_statement* temp =\n \tStatement::make_temporary(NULL, this->val_, this->location());"}, {"sha": "104c5db0b9bc6d3152ed9ef610b3e85c2106733c", "filename": "gcc/go/gofrontend/wb.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fwb.cc?ref=7ad5a72c8bc6aa71a0d195ddfa207db01265fe0b", "patch": "@@ -883,7 +883,7 @@ Gogo::assign_with_write_barrier(Function* function, Block* enclosing,\n \t\t\t   Type::COMPARE_ERRORS | Type::COMPARE_TAGS,\n \t\t\t   NULL)\n       && rhs->type()->interface_type() != NULL\n-      && !rhs->is_variable())\n+      && !rhs->is_multi_eval_safe())\n     {\n       // May need a temporary for interface conversion.\n       Temporary_statement* temp = Statement::make_temporary(NULL, rhs, loc);\n@@ -892,7 +892,7 @@ Gogo::assign_with_write_barrier(Function* function, Block* enclosing,\n     }\n   rhs = Expression::convert_for_assignment(this, type, rhs, loc);\n   Temporary_statement* rhs_temp = NULL;\n-  if (!rhs->is_variable() && !rhs->is_constant())\n+  if (!rhs->is_multi_eval_safe())\n     {\n       rhs_temp = Statement::make_temporary(NULL, rhs, loc);\n       inserter->insert(rhs_temp);"}]}