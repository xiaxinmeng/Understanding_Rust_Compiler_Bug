{"sha": "9e3bbb4a8024121eb0fa675cb1f074218c1345a6", "node_id": "C_kwDOANBUbNoAKDllM2JiYjRhODAyNDEyMWViMGZhNjc1Y2IxZjA3NDIxOGMxMzQ1YTY", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-02-19T08:03:57Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-02-19T08:03:57Z"}, "message": "asan: Mark instrumented vars addressable [PR102656]\n\nWe ICE on the following testcase, because the asan1 pass decides to\ninstrument\n  <retval>.x = 0;\nand does that by\n  _13 = &<retval>.x;\n  .ASAN_CHECK (7, _13, 4, 4);\n  <retval>.x = 0;\nand later sanopt pass turns that into:\n  _39 = (unsigned long) &<retval>.x;\n  _40 = _39 >> 3;\n  _41 = _40 + 2147450880;\n  _42 = (signed char *) _41;\n  _43 = *_42;\n  _44 = _43 != 0;\n  _45 = _39 & 7;\n  _46 = (signed char) _45;\n  _47 = _46 + 3;\n  _48 = _47 >= _43;\n  _49 = _44 & _48;\n  if (_49 != 0)\n    goto <bb 10>; [0.05%]\n  else\n    goto <bb 9>; [99.95%]\n\n  <bb 10> [local count: 536864]:\n  __builtin___asan_report_store4 (_39);\n\n  <bb 9> [local count: 1073741824]:\n  <retval>.x = 0;\nThe problem is during expansion, <retval> isn't marked TREE_ADDRESSABLE,\neven when we take its address in (unsigned long) &<retval>.x.\n\nNow, instrument_derefs has code to avoid the instrumentation altogether\nif we can prove the access is within bounds of an automatic variable in the\ncurrent function and the var isn't TREE_ADDRESSABLE (or we don't instrument\nuse after scope), but we do it solely for VAR_DECLs.\n\nI think we should treat RESULT_DECLs exactly like that too, which is what\nthe following patch does.  I must say I'm unsure about PARM_DECLs, those can\nhave different cases, either they are fully or partially passed in\nregisters, then if we take parameter's address, they are in a local copy\ninside of a function and so work like those automatic vars.  But if they\nare fully passed in memory, we typically just take address of the slot\nand in that case they live in the caller's frame.  It is true we don't\n(can't) put any asan padding in between the arguments, so all asan could\ndetect in that case is if caller passes fewer on stack arguments or smaller\narguments than callee accepts.  Anyway, as I'm unsure, I haven't added\nPARM_DECLs to that case.\n\nAnd another thing is, when we actually build_fold_addr_expr, we need to\nmark_addressable the inner if it isn't addressable already.\n\n2022-02-19  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR sanitizer/102656\n\t* asan.cc (instrument_derefs): If inner is a RESULT_DECL and access is\n\tknown to be within bounds, treat it like automatic variables.\n\tIf instrumenting access and inner is {VAR,PARM,RESULT}_DECL from\n\tcurrent function and !TREE_STATIC which is not TREE_ADDRESSABLE, mark\n\tit addressable.\n\n\t* g++.dg/asan/pr102656.C: New test.", "tree": {"sha": "9d9c500b6e622614b9d32d2d9d268c00e4cc3155", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d9c500b6e622614b9d32d2d9d268c00e4cc3155"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e3bbb4a8024121eb0fa675cb1f074218c1345a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e3bbb4a8024121eb0fa675cb1f074218c1345a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e3bbb4a8024121eb0fa675cb1f074218c1345a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e3bbb4a8024121eb0fa675cb1f074218c1345a6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a9ba3f27f3a514f27e8d8681049a756066198fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a9ba3f27f3a514f27e8d8681049a756066198fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a9ba3f27f3a514f27e8d8681049a756066198fe"}], "stats": {"total": 36, "additions": 34, "deletions": 2}, "files": [{"sha": "7c57cbca99c9b68521ae22b76078ccc36dd26c88", "filename": "gcc/asan.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e3bbb4a8024121eb0fa675cb1f074218c1345a6/gcc%2Fasan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e3bbb4a8024121eb0fa675cb1f074218c1345a6/gcc%2Fasan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.cc?ref=9e3bbb4a8024121eb0fa675cb1f074218c1345a6", "patch": "@@ -2688,13 +2688,13 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n     return;\n \n   poly_int64 decl_size;\n-  if (VAR_P (inner)\n+  if ((VAR_P (inner) || TREE_CODE (inner) == RESULT_DECL)\n       && offset == NULL_TREE\n       && DECL_SIZE (inner)\n       && poly_int_tree_p (DECL_SIZE (inner), &decl_size)\n       && known_subrange_p (bitpos, bitsize, 0, decl_size))\n     {\n-      if (DECL_THREAD_LOCAL_P (inner))\n+      if (VAR_P (inner) && DECL_THREAD_LOCAL_P (inner))\n \treturn;\n       /* If we're not sanitizing globals and we can tell statically that this\n \t access is inside a global variable, then there's no point adding\n@@ -2724,6 +2724,11 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n \t}\n     }\n \n+  if (DECL_P (inner)\n+      && decl_function_context (inner) == current_function_decl\n+      && !TREE_ADDRESSABLE (inner))\n+    mark_addressable (inner);\n+\n   base = build_fold_addr_expr (t);\n   if (!has_mem_ref_been_instrumented (base, size_in_bytes))\n     {"}, {"sha": "64be0c9c5acf3c7eff200f2db4932970fa260461", "filename": "gcc/testsuite/g++.dg/asan/pr102656.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e3bbb4a8024121eb0fa675cb1f074218c1345a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fpr102656.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e3bbb4a8024121eb0fa675cb1f074218c1345a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fpr102656.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fpr102656.C?ref=9e3bbb4a8024121eb0fa675cb1f074218c1345a6", "patch": "@@ -0,0 +1,27 @@\n+// PR sanitizer/102656\n+// { dg-do compile }\n+// { dg-options \"-std=c++20 -fsanitize=address\" }\n+\n+#include <coroutine>\n+\n+class promise;\n+\n+struct future {\n+  using promise_type = promise;\n+  future() = default;\n+  int x = 0;\n+};\n+\n+struct promise {\n+  future get_return_object() noexcept { return {}; }\n+  auto initial_suspend() noexcept { return std::suspend_never{}; }\n+  auto final_suspend() noexcept { return std::suspend_never{}; }\n+  void return_void() noexcept {}\n+  void unhandled_exception() {}\n+};\n+\n+future\n+func ()\n+{\n+  co_return;\n+}"}]}