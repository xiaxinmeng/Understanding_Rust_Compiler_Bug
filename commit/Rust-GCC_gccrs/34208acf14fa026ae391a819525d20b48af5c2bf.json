{"sha": "34208acf14fa026ae391a819525d20b48af5c2bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQyMDhhY2YxNGZhMDI2YWUzOTFhODE5NTI1ZDIwYjQ4YWY1YzJiZg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2004-02-24T16:58:39Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2004-02-24T16:58:39Z"}, "message": "Implement FR-V FDPIC ABI support for frv-uclinux and frv-linux.\n\n2004-02-05  Alexandre Oliva  <aoliva@redhat.com>\n* config/frv/frv.c (frv_emit_movsi): Use GOT relocations for\nsymbols in sections named by the user.\n2004-01-30  Alexandre Oliva  <aoliva@redhat.com>\n* config/frv/linux.h (TARGET_OS_CPP_BUILTINS): New.\n2004-01-27  Alexandre Oliva  <aoliva@redhat.com>\n* config.gcc (frv-*-*linux*): Handle like *-*-linux*.\n* config/frv/t-linux (EXTRA_MULTILIB_PARTS): Remove, obviated by\nthe above.\n2004-01-20  Alexandre Oliva  <aoliva@redhat.com>\n* config/frv/frv.md (symGOT2reg_hilo, symGOTOFF2reg_hilo): Add\none more pseudo to further improve code generation.\n2004-01-19  Alexandre Oliva  <aoliva@redhat.com>\n* config/frv/frv.md (movdi_ldd): Introduce explicit indirection\ninside UNSPEC.\n2004-01-16  Alexandre Oliva  <aoliva@redhat.com>\n* config/frv/frv.c (frv_legitimate_address_p): Added\nallow_double_reg_p argument.  Adjust all callers.  Use it to\ndecide whether to enable double-register indirect addressing.\n(frv_funcdesc_alias_set): Remove.\n(frv_expand_fdpic_call): Force non-SYMBOL_REF operand into\nregister.  Emit movdi_ldd.\n(ldd_address_operand): New.\n* config/frv/frv-protos.h (frv_legitimate_address_p): Adjust.\n* config/frv/frv.h (GO_IF_LEGITIMATE_ADDRESS): Likewise.\n(PREDICATE_CODES): Add ldd_address_operand.\n* config/frv/frv.md (movdi_ldd): New.\n(symGOT2reg_hilo, symGOTOFF2reg_hilo): Use separate pseudo for\nintermediate computations if possible.\n(symGOTOFF2reg_i): Fix harmless typo.\n2003-12-18  Alexandre Oliva  <aoliva@redhat.com>\n* unwind-dw2-fde-glibc.c (_Unwind_IteratePhdrCallback): Cast\nrelocated p_vaddr to vaddr type.\n* config/frv/frv-protos.h (frv_expand_fdpic_call): Return void.\n* config/frv/frv.c (frv_get_funcdesc_alias_set): New.\n(frv_expand_fdpic_call): Propagate incoming MEM's expr to funcdesc\nMEM, or use a funcdesc alias set.  Use regular move instead of\nldd.\n(dbl_memory_one_insn_operand): Recognize function descriptors by\ntype or by alias set, and don't split them.\n* config/frv/frv.md (call, call_value): Never use call_internal\nfor fdpic.\n(call_internal, call_value_internal): Never match for FDPIC.\n(call_fdpicdi, call_fdpicsi, call_value_fdpicdi,\ncall_value_fdpicsi): Require FDPIC.\n(ldd): Removed.\n2003-12-17  Alexandre Oliva  <aoliva@redhat.com>\n* config/frv/frv.h (CRT_GET_RFIB_DATA): Define for __FRV_FDPIC__.\n* unwind-dw2-fde-glibc.c: Don't include elf-fdpic.h any more.\n(_Unwind_IteratePhdrCallback): Adjust type of load_base for FRV\nFDPIC.  Compute data base address.\n* config/frv/linux.h (SUBTARGET_DRIVER_SELF_SPECS): Enable -mfdpic\nbefore the other self-specs are processed.\n* config/frv/t-linux (CRTSTUFF_T_CFLAGS, TARGET_LIBGCC2_CFLAGS):\nBuild with -fPIC.\n2003-12-15  Alexandre Oliva  <aoliva@redhat.com>\n* unwind-dw2-fde-glibc.c: Don't include bits/elf-fdpic.h if\ninhibit_libc is defined.\n2003-12-12  Alexandre Oliva  <aoliva@redhat.com>\n* unwind-dw2-fde-glibc.c: Include bits/elf-fdpic.h for\n__FRV_FDPIC__.\n(__RELOC_POINTER): Define.\n(_Unwind_IteratePhdrCallback): Use it.\n* config/frv/frv.h (Twrite): Define.\n(TRANSFER_FROM_TRAMPOLINE): Use it.\n* config/frv/linux.h (INVOKE__main): Undefine.\n(Twrite): Override.\n2003-12-05  Richard Sandiford  <rsandifo@redhat.com>\n* doc/invoke.texi (-mlong-calls, -mlinked-fp): Document FRV options.\n(-mlibrary-pic): Emphasize that this option generates EABI code.\n(-mcpu): Add fr550.\n(-mpack): Remove.\n2003-11-30  Alexandre Oliva  <aoliva@redhat.com>\n* config/frv/frv.c (int_2word_operand): Reject LABELs, SYMBOL_REFs\nand CONSTs in FDPIC mode.\n* gcc/config.gcc (with_cpu): Default to fr400 on frv-*-*linux*.\n2003-11-29  Richard Sandiford  <rsandifo@redhat.com>\n* config/frv/frv.c (move_source_operand): Don't accept symbolic\nconstants.\n* config/frv/frv.md (*movhi_internal, *movsi_internal): Use an 'n'\nrather than 'i' constraint for the 2-instruction alternative.\n(*movsi_2word): New, incorporating existing int_2word_operand splitter.\n2003-11-29  Richard Sandiford  <rsandifo@redhat.com>\n* config/frv/frv.h (EXTRA_CONSTRAINT_FOR_Q): Renamed from\nEXTRA_CONSTRAINT_FOR_Y.\n(EXTRA_CONSTRAINT): Remove handling of 'Y'.\n* config/frv/frv.md (*movsi_internal): Remove 'Q' constraint.\n(addsi3): Change 'Y' constraint to 'Q'.\n2003-11-27  Richard Sandiford  <rsandifo@redhat.com>\n* reload.c (CONST_POOL_OK_P): New macro.\n(find_reloads): Use it to decide whether a constant can be forced\ninto memory.\n* config/frv/frv.h (LEGITIMATE_PIC_OPERAND_P): Return true if the\nconstant satisfies got12_operand.\n(frv_cannot_force_const_mem): Always return true for TARGET_FDPIC.\n(frv_legitimate_address_p): Check for valid unspec offsets using\ngot12_operand rather than frv_legitimate_fdpic_operand_p.\n(frv_legitimate_fdpic_operand_p): Delete.\n(frv_emit_movsi): Abort if we try to use the FDPIC register during\nor after reload.\n(frv_legitimate_constant_p): Return LEGITIMATE_PIC_OPERAND_P if\nTARGET_FDPIC.\n* config/frv/frv.md (*movdf_double): Add alternatives for CONST_DOUBLE.\n2003-11-19  Richard Sandiford  <rsandifo@redhat.com>\n* config/frv/frv-protos.h (fdpic_operand, fdpic_got12_operand)\n(frv_fdpic_fptr_operand): Don't declare here.\n* config/frv/frv.h (EXTRA_CONSTRAINT_FOR_Y): Call got12_operand\nrather than fdpic_got12_operand.\n(PREDICATE_CODES): Remove symbolic_operand entry.  Add entries for\ngot12_operand and const_unspec_operand.\n* config/frv/frv.c (got12_operand): Renamed from fdpic_got12_operand.\n(gpr_or_int12_operand, dbl_memory_one_insn_operand): Update calls.\n(symbolic_operand): Remove.\n(const_unspec_operand): New predicate.\n* config/frv/frv.md (*movsi_got): Use got12_operand.\n(*movsi_high_got, *movsi_lo_sum_got): Use const_unspec_operand.\n2003-11-18  Richard Sandiford  <rsandifo@redhat.com>\n* config/frv/frv-protos.h (frv_output_addr_const_extra): Remove.\n* config/frv/frv.h (OUTPUT_ADDR_CONST_EXTRA): Remove definition.\n* config/frv/frv.c (frv_unspec): New structure.\n(frv_small_data_reloc_p, frv_const_unspec_p): New functions.\n(frv_print_operand_memory_reference): Use frv_const_unspec_p to\nvalidate CONST indices.  Use frv_output_const_unspec to print them.\n(frv_print_operand): Update call to unspec_got_name.  Use\nfrv_output_const_unspec to print constant unspecs.\n(frv_legitimate_fdpic_operand_p): Return true if frv_const_unspec_p.\nReject UNSPECs otherwise.\n(unspec_got_name): Take the relocation number as argument, not an\nrtx containing it.\n(frv_output_addr_const_extra): Remove, replacing with...\n(frv_output_const_unspec): ...this new function.\n(frv_find_base_term): Use frv_const_unspec_p & frv_small_data_reloc_p.\n(gpr_or_int12_operand): Use fdpic_got12_operand.\n(dbl_memory_one_insn_operand): Likewise.\n(fdpic_got12_operand): Use frv_const_unspec_p.\n(frv_emit_movsi): Use frv_const_unspec_p to check for CONSTs that\nare already legitimate.  Use frv_small_data_reloc_p when deciding\nwhether to use HIGH/LO_SUM for R_FRV_GOTOFF12 and R_FRV_GPREL12.\n2003-11-18  Alexandre Oliva  <aoliva@redhat.com>\n* config/frv/t-linux (SHLIB_MAPFILES): Override so as to export...\n* config/frv/libgcc-frv.ver: ... frv-specific symbols.  New file.\n* config/frv/frv-abi.h (CREATE_DOUBLE_SHIFT): Use branch to local\nlabel, for real this time.\n* config/frv/frv.c (frv_local_funcdesc_p): Update to new\nrepresentation of visibility.\n(fdpic_got12_operand, symbolic_operand): Mark unused arguments as\nsuch.\n2003-11-17  Richard Sandiford  <rsandifo@redhat.com>\n* config/frv/frv.h (MASK_LINKED_FP, TARGET_LINKED_FP): New macros.\n(TARGET_SWITCHES): Add -mlinked-fp and -mno-linked-fp.\n* config/frv/frv.c (frv_override_options): Set MASK_LINKED_FP unless\nit was explicitly disabled.\n(frv_stack_info): There is no need to save the link register in every\nframe unless TARGET_LINKED_FP is true.\n(frv_frame_pointer_required): If !TARGET_LINKED_FP, only require a\nframe pointer if the stack pointer might change value.\n(frv_return_addr_rtx): Check and process \"count\" argument.\n2003-11-14  Richard Sandiford  <rsandifo@redhat.com>\n* config/frv/frv-protos.h (frv_legitimize_address): Remove.\n(frv_find_base_term): Declare.\n* config/frv/frv.h (LEGITIMIZE_ADDRESS): Do nothing.\n(FIND_BASE_TERM): Define.\n(PREDICATE_CODES): Remove pic_register_operand, pic_symbolic_operand,\nsmall_data_register_operand, small_data_symbolic_operand.  Add\nsymbolic_operand.\n* config/frv/frv.c (const_small_data_p, plus_small_data_p): Delete.\n(frv_print_operand_memory_reference, output_move_single): Remove\nspecial handling for unlegitimized sdata addresses.\n(frv_legitimate_address_p): Don't allow sums of SDA_BASE_REG\nand symbolic addresses.\n(frv_legitimize_address, frv_legitimize_fdpic_address): Delete.\n(frv_find_base_term): New function.\n(int_2word_operand): Check specifically for symbolic address constants.\n(pic_register_operand, pic_symbolic_operand): Delete.\n(small_data_register_operand, small_data_symbolic_operand): Delete.\n(dbl_memory_one_insn_operand): Don't call plus_small_data_p.\nAllow UNSPEC_GOT constants if !TARGET_FDPIC.\n(move_source_operand): Only accept CONSTs if they're a two-insn\nsymbolic constant.\n(fdpic_got12_operand): Don't require TARGET_FDPIC.\n(frv_emit_movsi): Legitimize sdata and -mlibrary-pic addresses\nusing gen_symGOTOFF2reg*.\n(frv_ifcvt_rewrite_mem): Remove (plus gr16 ...) special cases.\n(frv_rtx_costs): Give all MEM addresses a cost of 0.  Give MEMs\nthemselves a cost of 3 insns.\n* config/mips/mips.md (*movsi_got): Allow for !TARGET_FDPIC too.\nChange predicate to symbolic_operand.\n(*movsi_high_got, *movsi_lo_sum_got): Likewise.\n(*movsi_lda_sdata): Delete.\n(*movsi_pic, movsi_high_pic, movsi_lo_sum_pic): Delete.\n2003-11-05  Alexandre Oliva  <aoliva@redhat.com>\n* config.gcc: Add t-slibgcc-elf-ver and support --with-cpu for\nfrv-*-*linux*.\n* config/frv/frv-abi.h (CREATE_DOUBLE_SHIFT): Use branch to local\nlabel.\n* config/frv/frv.h (DRIVER_SELF_SPECS): Add blank before\n-multilib-library-pic.\n(LINK_SPEC): Add -z text for -mfdpic.\n* config/frv/frvbegin.c (__ROFIXUP_LIST__): Don't define on FDPIC.\n* config/frv/frvend.c (__ROFIXUP_END__): Likewise.\n* config/frv/linux.h (STARTFILE_SPEC, ENDFILE_SPEC, LINK_SPEC):\nOverride.\n(OPTION_DEFAULT_SPECS, HAS_INIT_SECTION, INIT_SECTION_ASM_OP,\nFINI_SECTION_ASM_OP, CRT_CALL_STATIC_FUNCTION): Define.\n* config/frv/t-linux (EXTRA_MULTILIB_PARTS): Use\ncrtstuff-generated files.\n2003-10-31  Alexandre Oliva  <aoliva@redhat.com>\n* config.gcc: Add frv-*-*linux*.\n* config/frv/linux.h, config/frv/t-linux: New.\n2003-10-06  Alexandre Oliva  <aoliva@redhat.com>\n* config/frv/frv.h (LINK_SPEC): Pass -melf32frvfd to the linker\nwhen -mfdpic even if a linker script is explicitly listed.\n2003-10-02  Alexandre Oliva  <aoliva@redhat.com>\n* config/frv/frv.c (frv_override_options): Clear asm_out\nunaligned_op for SImode on FDPIC.\n(frv_emit_movsi): Use compute_reloc_for_constant to compute the\nargument passed to decl_readonly_section.\n(frv_assemble_integer): Revert 2003-09-30's change, but make the\nwhole block run with FDPIC even with -fno-PIC.\n2003-10-02  Alexandre Oliva  <aoliva@redhat.com>\n* config/frv/frv.c (frv_cannot_force_const_mem): Don't force\nsymbol or label plus offset to memory.\n(frv_emit_movsi): Emit GPREL only if -mgprel-ro.  Emit 32-bit\nGOTOFF and GPREL for LABEL_REF.\n* config/frv/frv.h (DRIVER_SELF_SPECS): Add -mgprel-ro with\n-mfdpic unless -mno-gprel-ro, -fpic or -fpie.\n(MASK_GPREL_RO, TARGET_GPREL_RO): New.\n(TARGET_SWITCHES): Added gprel-ro and no-gprel-ro.\n* doc/invoke.texi: Document them.\n2003-09-30  Alexandre Oliva  <aoliva@redhat.com>\n* config/frv/frv-protos.h (frv_gen_GPsym2reg): Declare.\n(frv_splittable_got_operand): Removed.\n* config/frv/frv.c (frv_cannot_force_const_mem): Reject HIGH and\nLO_SUM.  Add comments.\n(frv_override_options): Moved enabling of FDPIC to\nDRIVER_SELF_SPECS.  Don't enable MASK_DWORD.\n(frv_local_funcdesc_p): Remove unnecessary heck for flag_pie.\n(frv_legitimize_fdpic_address): Don't duplicate logic in\nfrv_emit_movsi.\n(frv_gen_GPsym2reg): New.\n(unspec_got_name): Added gprel.\n(frv_expand_fdpic_call): Add support for inlining PLTs.\n(fdpic_fptr_operand): Renamed from frv_fdpic_fptr_operand.\n(gpr_or_int12_operand): Added GPREL12.\n(pic_symbolic_operand): Match even if !flag_pic for FDPIC.\n(small_data_symbolic_operand): Fail if FDPIC.\n(fdpic_splittable_got_operand): Removed.\n(fdpic_got12_operand): Added GPREL12.\n(frv_emit_movsi): Reorganize to avoid duplication.  Emit GPREL\nwhen appropriate.  Fix sdata GOTOFF.\n(frv_legitimate_constant_p): Require legitimate PIC operand for\nFDPIC with pic, but only a legitimate fdpic operand for non-pic.\n(frv_assemble_integer): Move FDPIC funcdesc handling out of\nflag_pic case.\n(frv_asm_out_constructor, frv_asm_out_destructor): Abort if\nfrv_assemble_integer fails.\n* config/frv/frv.h (DRIVER_SELF_SPECS): New.\n(SUBTARGET_DRIVER_SELF_SPECS): New.\n(ASM_SPEC): Don't pass -mno-fdpic.\n(LINK_SPEC): Pass -melf32frvfd for FDPIC.\n(MASK_INLINE_PLT, TARGET_INLINE_PLT): New.\n(TARGET_SWITCHES): Add -minline-plt, -mno-inline-plt and\n-multilib-library-pic.\n(PREDICATE_CODES): Added fdpic_operand, fdpic_fptr_operand,\ncondexec_si_media_operator, condexec_sf_add_operator and\ncondexec_sf_conv_operator.  Removed condexec_sf_binary_operator\nand condexec_sf_unary_operator.\n* config/frv/frv.md (R_FRV_GPREL12, R_FRV_GPRELHI, R_FRV_GPRELLO):\nNew.\n(movsi_got, movsi_high_got, movsi_lo_sum_got): Move before\nmovsi_internal.  Give them internal names.  movsi_got has type\nint.\n(fdpic got splitters): Remove.\n(symGPREL2reg, symGPREL2reg_hilo): New.\n* config/frv/t-frv (MULTILIB_MATCHES): Don't map -fpic and -fPIC\nto -mlibrary-pic.  Map -multilib-library-pic to it.\n* doc/invoke.texi: -mfdpic, -minline-plt, -multilib-library-pic:\nDocument.\n2003-09-28  Alexandre Oliva  <aoliva@redhat.com>\n* config/frv/frv.c (frv_function_symbol_referenced_p): Declare.\n(TARGET_CANNOT_FORCE_CONST_MEM): Define to...\n(frv_cannot_force_const_mem): New function.\n(const_small_data_p, plus_small_data_p): Update comments on sdata\non FDPIC.\n(frv_override_options): Set flag_pie for FDPIC too.\n(frv_conditional_register_usage): Mark gr16 and gr17 as non-fixed,\ncall-saved registers on FDPIC.\n(frv_stack_info): Don't preserve the PIC register on FDPIC, and\ndon't force LR to be preserved.\n(frv_expand_prologue): Likewise.\n(frv_asm_output_mi_thunk): Use 12-bit funcdesc gotoff for -fpic.\n(frv_frame_pointer_required): Don't force it just because the\nFDPIC register is used.\n(frv_legitimate_address_p) <CONST>: Accept a legitimate FDPIC\noperand only if !condexec_p.\n(frv_legitimize_address): Return the FDPIC-legitimized address.\nDon't match small data here on FDPIC.\n(frv_legitimate_fdpic_operand_p): Don't accept unadorned function\nsymbols.  Use TRUE/FALSE instead of 1/0.\n(frv_local_funcdesc_p): New.\n(frv_legitimize_fdpic_address): Rewrite to use GOTOFF and 12-bit\nimmediates when possible.\n(pic_symbolic_operand): Accept SYMBOL_REFs and CONSTs in FDPIC.\n(dbl_memory_one_insn_operand): Accept addresses that add a REG and\nan UNSPEC_GOT.\n(frv_emit_movsi): Handle FDPIC before small data.  Use GOTOFF and\n12-bit immediates when possible.\n(frv_legitimate_constant_p): In FDPIC, reject SImode operands that\nare not legitimate pic operands.\n(frv_in_small_data_p): Re-enable for FDPIC.\n* config/frv/frv.h (SDA_BASE_REG): Remove comment about FDPIC.\n(FRV_GLOBAL_P): Removed.\n* config/frv/frv.md: Add modes to CONSTs.\n(movsi_got): New.\n(movsi_lo_sum_got): Use separate matches instead of match_dup.\n(movsi_high_pic, movsi_lo_sum_pic): Match on non-FDPIC only.\n(fdpic splittable operations): Match on flag_pic != 1.\n2003-09-22  Alexandre Oliva  <aoliva@redhat.com>\n* config/frv/frv.c (frv_asm_out_constructor,\nfrv_asm_out_destructor): Pass to frv_assemble_integer the size in\nbytes, not bits.\n2003-09-19  Alexandre Oliva  <aoliva@redhat.com>\n* config/frv/frv.c (frv_assemble_integer): Reject complex\nexpressions referencing function SYMBOL_REFs.\n* config/frv/frv.c (frv_function_symbol_referenced_p): New.\n(move_source_operand): Reject CONSTs that reference function\nSYMBOL_REFs on FDPIC.\n(frv_emit_movsi): If we get such a CONST, break it up.\n* config/frv/frv.h (CPP_SPEC): Define __FRV_FDPIC__ for -mfdpic.\n(TRANSFER_FROM_TRAMPOLINE): Use different definitions for FDPIC.\n* config/frv/frv.c (frv_print_operand) <I>: Recognize PLUS without\nMEM.\n(frv_assemble_integer): Don't use funcdesc for LABEL_REFs.\n(frv_trampoline_size): Increase for FDPIC.\n* config/frv/frv.h (TRAMPOLINE_ALIGNMENT): Bump to 64 for FDPIC.\n(TRANSFER_FROM_TRAMPOLINE): Handle FDPIC trampolines.\n* config/frv/frv.c (frv_legitimize_fdpic_address, frv_emit_movsi):\nDisable use of GOTOFF for now.\n(const_small_data_p, plus_small_data_p, frv_in_small_data_p):\nDisable use of small data in FDPIC for now.\n(frv_asm_output_mi_thunk): Implement for FDPIC.\n* config/frv/frv.h (SDA_BASE_REG): Set to -1 with FDPIC.\n* config/frv/frv.c (frv_asm_out_constructor): Use\nfrv_assemble_integer for FDPIC pointers.\n(frv_asm_out_destructor): Likewise.\n* config/frv/frv.md (ldd): Fix order of operands.  Use\naddress_operand for input.\n2003-09-18  DJ Delorie  <dj@redhat.com>\n* config/frv/frv.c (frv_legitimate_fdpic_operand_p): Remove UNSPEC_PIC.\n(unspec_got_name): Correct typo.\n(frv_emit_movsi): Pre-expand splittable GOTs.\n(frv_expand_fdpic_call): Rename gen_lddi to gen_ldd.\n* config/frv/frv.md (lddi): Fix syntax error, rename to ldd.\n(symGOT2reg_hilo, symGOTOFF2reg_hilo): New.\n* config/frv/t-frv: Add -mfdpic multilibs.\n* config/frv/frv.h (ASM_SPEC): Pass -mfdpic/-mno-fdpic.\n(TARGET_SWITCHES): Add -mno-fdpic, fix documentation.\n* config/frv/frv.c (frv_override_options): -mfdpic assumes\nflag_pic, default to 32-bit pics, require DWORD ops.\n(frv_override_options): Add W and Z constraints.\n(frv_expand_prologue): No pic prologue for -mfdpic.\n(frv_asm_output_mi_thunk): Support -mfdpic (soon).\n(frv_print_operand_memory_reference): Handle GOT constants.\n(frv_legitimate_address_p): Allow GOT constants.\n(frv_legitimize_address): Handle GOT addresses too.\n(frv_legitimate_fdpic_operand_p): New.\n(frv_legitimize_fdpic_address): New.\n(unspec_got_name): New.\n(frv_output_addr_const_extra): New.\n(frv_expand_fdpic_call): New.\n(frv_fdpic_fptr_operand): New.\n(gpr_or_int12_operand): Handle GOT operands.\n(int_2word_operand): Handle GOT operands.\n(fdpic_operand): New.\n(fdpic_splittable_got_operand): New.\n(fdpic_got12_operand): New.\n(frv_emit_movsi): Handle GOT operands.\n(frv_assemble_integer): -mfdpic doesn't use rofixups.\n(frv_print_operand): Support 'g' code for GOT operands.\n* config/frv/frv-protos.h: Add prototypes as needed.\n* config/frv/frv.md (R_FRV_GOT12, R_FRV_GOTHI, R_FRV_GOTLO,\nR_FRV_FUNCDESC, R_FRV_FUNCDESC_GOT12, R_FRV_FUNCDESC_GOTHI,\nR_FRV_FUNCDESC_GOTLO, R_FRV_FUNCDESC_VALUE,\nR_FRV_FUNCDESC_GOTOFF12, R_FRV_FUNCDESC_GOTOFFHI,\nR_FRV_FUNCDESC_GOTOFFLO, R_FRV_GOTOFF12, R_FRV_GOTOFFHI,\nR_FRV_GOTOFFLO): New.\n(movsi_high_got, movsi_lo_sum_got): New.\n(*movsi_pic): Don't use this splitter for -mfdpic.\n(addsi3): Allow GOT references also.\n(call, call_value): Handle -mfdpic separately.\n(call_fdpicdi, call_fdpicsi, lddi, call_value_fdpicdi,\ncall_value_fdpicsi): New.\n(symGOT2reg, symGOT2reg_i, got splitters, symGOTOFF2reg,\nsymGOTOFF2reg_i): New.\n* config/frv/frv.h (MASK_FDPIC): New.\n(TARGET_FDPIC): New.\n(TARGET_SWITCHES): Add -mfdpic.\n(FDPIC_FPTR_REGNO): New.\n(FDPIC_REGNO): New.\n(OUR_FDPIC_REG): New.\n(enum reg_class): Add FDPIC_REGS, FDPIC_FPTR_REGS, and\nFDPIC_CALL_REGS.\n(REG_CLASS_NAMES): Likewise.\n(REG_CLASS_CONTENTS): Likewise.\n(EXTRA_CONSTRAINT_FOR_Y): New, for 12-bit GOTs.\n(EXTRA_CONSTRAINT): Add it here.\n(FRV_GLOBAL_P): New.\n(OUTPUT_ADDR_CONST_EXTRA): New.\n\nFrom-SVN: r78373", "tree": {"sha": "fa4bf09113ced5cb7203a53fd8198a222f4348c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa4bf09113ced5cb7203a53fd8198a222f4348c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34208acf14fa026ae391a819525d20b48af5c2bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34208acf14fa026ae391a819525d20b48af5c2bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34208acf14fa026ae391a819525d20b48af5c2bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34208acf14fa026ae391a819525d20b48af5c2bf/comments", "author": null, "committer": null, "parents": [{"sha": "2d3a667a4132e0eab3e1fd205e6c3bd81956ae85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d3a667a4132e0eab3e1fd205e6c3bd81956ae85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d3a667a4132e0eab3e1fd205e6c3bd81956ae85"}], "stats": {"total": 2205, "additions": 1835, "deletions": 370}, "files": [{"sha": "afbb5256a81285439fde3b74058e6003e51b4027", "filename": "gcc/ChangeLog", "status": "modified", "additions": 412, "deletions": 0, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=34208acf14fa026ae391a819525d20b48af5c2bf", "patch": "@@ -1,3 +1,415 @@\n+2004-02-24  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tImplement FR-V FDPIC ABI support for frv-uclinux and frv-linux.\n+\t2004-02-05  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/frv/frv.c (frv_emit_movsi): Use GOT relocations for\n+\tsymbols in sections named by the user.\n+\t2004-01-30  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/frv/linux.h (TARGET_OS_CPP_BUILTINS): New.\n+\t2004-01-27  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config.gcc (frv-*-*linux*): Handle like *-*-linux*.\n+\t* config/frv/t-linux (EXTRA_MULTILIB_PARTS): Remove, obviated by\n+\tthe above.\n+\t2004-01-20  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/frv/frv.md (symGOT2reg_hilo, symGOTOFF2reg_hilo): Add\n+\tone more pseudo to further improve code generation.\n+\t2004-01-19  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/frv/frv.md (movdi_ldd): Introduce explicit indirection\n+\tinside UNSPEC.\n+\t2004-01-16  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/frv/frv.c (frv_legitimate_address_p): Added\n+\tallow_double_reg_p argument.  Adjust all callers.  Use it to\n+\tdecide whether to enable double-register indirect addressing.\n+\t(frv_funcdesc_alias_set): Remove.\n+\t(frv_expand_fdpic_call): Force non-SYMBOL_REF operand into\n+\tregister.  Emit movdi_ldd.\n+\t(ldd_address_operand): New.\n+\t* config/frv/frv-protos.h (frv_legitimate_address_p): Adjust.\n+\t* config/frv/frv.h (GO_IF_LEGITIMATE_ADDRESS): Likewise.\n+\t(PREDICATE_CODES): Add ldd_address_operand.\n+\t* config/frv/frv.md (movdi_ldd): New.\n+\t(symGOT2reg_hilo, symGOTOFF2reg_hilo): Use separate pseudo for\n+\tintermediate computations if possible.\n+\t(symGOTOFF2reg_i): Fix harmless typo.\n+\t2003-12-18  Alexandre Oliva  <aoliva@redhat.com>\n+\t* unwind-dw2-fde-glibc.c (_Unwind_IteratePhdrCallback): Cast\n+\trelocated p_vaddr to vaddr type.\n+\t* config/frv/frv-protos.h (frv_expand_fdpic_call): Return void.\n+\t* config/frv/frv.c (frv_get_funcdesc_alias_set): New.\n+\t(frv_expand_fdpic_call): Propagate incoming MEM's expr to funcdesc\n+\tMEM, or use a funcdesc alias set.  Use regular move instead of\n+\tldd.\n+\t(dbl_memory_one_insn_operand): Recognize function descriptors by\n+\ttype or by alias set, and don't split them.\n+\t* config/frv/frv.md (call, call_value): Never use call_internal\n+\tfor fdpic.\n+\t(call_internal, call_value_internal): Never match for FDPIC.\n+\t(call_fdpicdi, call_fdpicsi, call_value_fdpicdi,\n+\tcall_value_fdpicsi): Require FDPIC.\n+\t(ldd): Removed.\n+\t2003-12-17  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/frv/frv.h (CRT_GET_RFIB_DATA): Define for __FRV_FDPIC__.\n+\t* unwind-dw2-fde-glibc.c: Don't include elf-fdpic.h any more.\n+\t(_Unwind_IteratePhdrCallback): Adjust type of load_base for FRV\n+\tFDPIC.  Compute data base address.\n+\t* config/frv/linux.h (SUBTARGET_DRIVER_SELF_SPECS): Enable -mfdpic\n+\tbefore the other self-specs are processed.\n+\t* config/frv/t-linux (CRTSTUFF_T_CFLAGS, TARGET_LIBGCC2_CFLAGS):\n+\tBuild with -fPIC.\n+\t2003-12-15  Alexandre Oliva  <aoliva@redhat.com>\n+\t* unwind-dw2-fde-glibc.c: Don't include bits/elf-fdpic.h if\n+\tinhibit_libc is defined.\n+\t2003-12-12  Alexandre Oliva  <aoliva@redhat.com>\n+\t* unwind-dw2-fde-glibc.c: Include bits/elf-fdpic.h for\n+\t__FRV_FDPIC__.\n+\t(__RELOC_POINTER): Define.\n+\t(_Unwind_IteratePhdrCallback): Use it.\n+\t* config/frv/frv.h (Twrite): Define.\n+\t(TRANSFER_FROM_TRAMPOLINE): Use it.\n+\t* config/frv/linux.h (INVOKE__main): Undefine.\n+\t(Twrite): Override.\n+\t2003-12-05  Richard Sandiford  <rsandifo@redhat.com>\n+\t* doc/invoke.texi (-mlong-calls, -mlinked-fp): Document FRV options.\n+\t(-mlibrary-pic): Emphasize that this option generates EABI code.\n+\t(-mcpu): Add fr550.\n+\t(-mpack): Remove.\n+\t2003-11-30  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/frv/frv.c (int_2word_operand): Reject LABELs, SYMBOL_REFs\n+\tand CONSTs in FDPIC mode.\n+\t* gcc/config.gcc (with_cpu): Default to fr400 on frv-*-*linux*.\n+\t2003-11-29  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/frv/frv.c (move_source_operand): Don't accept symbolic\n+\tconstants.\n+\t* config/frv/frv.md (*movhi_internal, *movsi_internal): Use an 'n'\n+\trather than 'i' constraint for the 2-instruction alternative.\n+\t(*movsi_2word): New, incorporating existing int_2word_operand splitter.\n+\t2003-11-29  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/frv/frv.h (EXTRA_CONSTRAINT_FOR_Q): Renamed from\n+\tEXTRA_CONSTRAINT_FOR_Y.\n+\t(EXTRA_CONSTRAINT): Remove handling of 'Y'.\n+\t* config/frv/frv.md (*movsi_internal): Remove 'Q' constraint.\n+\t(addsi3): Change 'Y' constraint to 'Q'.\n+\t2003-11-27  Richard Sandiford  <rsandifo@redhat.com>\n+\t* reload.c (CONST_POOL_OK_P): New macro.\n+\t(find_reloads): Use it to decide whether a constant can be forced\n+\tinto memory.\n+\t* config/frv/frv.h (LEGITIMATE_PIC_OPERAND_P): Return true if the\n+\tconstant satisfies got12_operand.\n+\t(frv_cannot_force_const_mem): Always return true for TARGET_FDPIC.\n+\t(frv_legitimate_address_p): Check for valid unspec offsets using\n+\tgot12_operand rather than frv_legitimate_fdpic_operand_p.\n+\t(frv_legitimate_fdpic_operand_p): Delete.\n+\t(frv_emit_movsi): Abort if we try to use the FDPIC register during\n+\tor after reload.\n+\t(frv_legitimate_constant_p): Return LEGITIMATE_PIC_OPERAND_P if\n+\tTARGET_FDPIC.\n+\t* config/frv/frv.md (*movdf_double): Add alternatives for CONST_DOUBLE.\n+\t2003-11-19  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/frv/frv-protos.h (fdpic_operand, fdpic_got12_operand)\n+\t(frv_fdpic_fptr_operand): Don't declare here.\n+\t* config/frv/frv.h (EXTRA_CONSTRAINT_FOR_Y): Call got12_operand\n+\trather than fdpic_got12_operand.\n+\t(PREDICATE_CODES): Remove symbolic_operand entry.  Add entries for\n+\tgot12_operand and const_unspec_operand.\n+\t* config/frv/frv.c (got12_operand): Renamed from fdpic_got12_operand.\n+\t(gpr_or_int12_operand, dbl_memory_one_insn_operand): Update calls.\n+\t(symbolic_operand): Remove.\n+\t(const_unspec_operand): New predicate.\n+\t* config/frv/frv.md (*movsi_got): Use got12_operand.\n+\t(*movsi_high_got, *movsi_lo_sum_got): Use const_unspec_operand.\n+\t2003-11-18  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/frv/frv-protos.h (frv_output_addr_const_extra): Remove.\n+\t* config/frv/frv.h (OUTPUT_ADDR_CONST_EXTRA): Remove definition.\n+\t* config/frv/frv.c (frv_unspec): New structure.\n+\t(frv_small_data_reloc_p, frv_const_unspec_p): New functions.\n+\t(frv_print_operand_memory_reference): Use frv_const_unspec_p to\n+\tvalidate CONST indices.  Use frv_output_const_unspec to print them.\n+\t(frv_print_operand): Update call to unspec_got_name.  Use\n+\tfrv_output_const_unspec to print constant unspecs.\n+\t(frv_legitimate_fdpic_operand_p): Return true if frv_const_unspec_p.\n+\tReject UNSPECs otherwise.\n+\t(unspec_got_name): Take the relocation number as argument, not an\n+\trtx containing it.\n+\t(frv_output_addr_const_extra): Remove, replacing with...\n+\t(frv_output_const_unspec): ...this new function.\n+\t(frv_find_base_term): Use frv_const_unspec_p & frv_small_data_reloc_p.\n+\t(gpr_or_int12_operand): Use fdpic_got12_operand.\n+\t(dbl_memory_one_insn_operand): Likewise.\n+\t(fdpic_got12_operand): Use frv_const_unspec_p.\n+\t(frv_emit_movsi): Use frv_const_unspec_p to check for CONSTs that\n+\tare already legitimate.  Use frv_small_data_reloc_p when deciding\n+\twhether to use HIGH/LO_SUM for R_FRV_GOTOFF12 and R_FRV_GPREL12.\n+\t2003-11-18  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/frv/t-linux (SHLIB_MAPFILES): Override so as to export...\n+\t* config/frv/libgcc-frv.ver: ... frv-specific symbols.  New file.\n+\t* config/frv/frv-abi.h (CREATE_DOUBLE_SHIFT): Use branch to local\n+\tlabel, for real this time.\n+\t* config/frv/frv.c (frv_local_funcdesc_p): Update to new\n+\trepresentation of visibility.\n+\t(fdpic_got12_operand, symbolic_operand): Mark unused arguments as\n+\tsuch.\n+\t2003-11-17  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/frv/frv.h (MASK_LINKED_FP, TARGET_LINKED_FP): New macros.\n+\t(TARGET_SWITCHES): Add -mlinked-fp and -mno-linked-fp.\n+\t* config/frv/frv.c (frv_override_options): Set MASK_LINKED_FP unless\n+\tit was explicitly disabled.\n+\t(frv_stack_info): There is no need to save the link register in every\n+\tframe unless TARGET_LINKED_FP is true.\n+\t(frv_frame_pointer_required): If !TARGET_LINKED_FP, only require a\n+\tframe pointer if the stack pointer might change value.\n+\t(frv_return_addr_rtx): Check and process \"count\" argument.\n+\t2003-11-14  Richard Sandiford  <rsandifo@redhat.com>\n+\t* config/frv/frv-protos.h (frv_legitimize_address): Remove.\n+\t(frv_find_base_term): Declare.\n+\t* config/frv/frv.h (LEGITIMIZE_ADDRESS): Do nothing.\n+\t(FIND_BASE_TERM): Define.\n+\t(PREDICATE_CODES): Remove pic_register_operand, pic_symbolic_operand,\n+\tsmall_data_register_operand, small_data_symbolic_operand.  Add\n+\tsymbolic_operand.\n+\t* config/frv/frv.c (const_small_data_p, plus_small_data_p): Delete.\n+\t(frv_print_operand_memory_reference, output_move_single): Remove\n+\tspecial handling for unlegitimized sdata addresses.\n+\t(frv_legitimate_address_p): Don't allow sums of SDA_BASE_REG\n+\tand symbolic addresses.\n+\t(frv_legitimize_address, frv_legitimize_fdpic_address): Delete.\n+\t(frv_find_base_term): New function.\n+\t(int_2word_operand): Check specifically for symbolic address constants.\n+\t(pic_register_operand, pic_symbolic_operand): Delete.\n+\t(small_data_register_operand, small_data_symbolic_operand): Delete.\n+\t(dbl_memory_one_insn_operand): Don't call plus_small_data_p.\n+\tAllow UNSPEC_GOT constants if !TARGET_FDPIC.\n+\t(move_source_operand): Only accept CONSTs if they're a two-insn\n+\tsymbolic constant.\n+\t(fdpic_got12_operand): Don't require TARGET_FDPIC.\n+\t(frv_emit_movsi): Legitimize sdata and -mlibrary-pic addresses\n+\tusing gen_symGOTOFF2reg*.\n+\t(frv_ifcvt_rewrite_mem): Remove (plus gr16 ...) special cases.\n+\t(frv_rtx_costs): Give all MEM addresses a cost of 0.  Give MEMs\n+\tthemselves a cost of 3 insns.\n+\t* config/mips/mips.md (*movsi_got): Allow for !TARGET_FDPIC too.\n+\tChange predicate to symbolic_operand.\n+\t(*movsi_high_got, *movsi_lo_sum_got): Likewise.\n+\t(*movsi_lda_sdata): Delete.\n+\t(*movsi_pic, movsi_high_pic, movsi_lo_sum_pic): Delete.\n+\t2003-11-05  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config.gcc: Add t-slibgcc-elf-ver and support --with-cpu for\n+\tfrv-*-*linux*.\n+\t* config/frv/frv-abi.h (CREATE_DOUBLE_SHIFT): Use branch to local\n+\tlabel.\n+\t* config/frv/frv.h (DRIVER_SELF_SPECS): Add blank before\n+\t-multilib-library-pic.\n+\t(LINK_SPEC): Add -z text for -mfdpic.\n+\t* config/frv/frvbegin.c (__ROFIXUP_LIST__): Don't define on FDPIC.\n+\t* config/frv/frvend.c (__ROFIXUP_END__): Likewise.\n+\t* config/frv/linux.h (STARTFILE_SPEC, ENDFILE_SPEC, LINK_SPEC):\n+\tOverride.\n+\t(OPTION_DEFAULT_SPECS, HAS_INIT_SECTION, INIT_SECTION_ASM_OP,\n+\tFINI_SECTION_ASM_OP, CRT_CALL_STATIC_FUNCTION): Define.\n+\t* config/frv/t-linux (EXTRA_MULTILIB_PARTS): Use\n+\tcrtstuff-generated files.\n+\t2003-10-31  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config.gcc: Add frv-*-*linux*.\n+\t* config/frv/linux.h, config/frv/t-linux: New.\n+\t2003-10-06  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/frv/frv.h (LINK_SPEC): Pass -melf32frvfd to the linker\n+\twhen -mfdpic even if a linker script is explicitly listed.\n+\t2003-10-02  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/frv/frv.c (frv_override_options): Clear asm_out\n+\tunaligned_op for SImode on FDPIC.\n+\t(frv_emit_movsi): Use compute_reloc_for_constant to compute the\n+\targument passed to decl_readonly_section.\n+\t(frv_assemble_integer): Revert 2003-09-30's change, but make the\n+\twhole block run with FDPIC even with -fno-PIC.\n+\t2003-10-02  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/frv/frv.c (frv_cannot_force_const_mem): Don't force\n+\tsymbol or label plus offset to memory.\n+\t(frv_emit_movsi): Emit GPREL only if -mgprel-ro.  Emit 32-bit\n+\tGOTOFF and GPREL for LABEL_REF.\n+\t* config/frv/frv.h (DRIVER_SELF_SPECS): Add -mgprel-ro with\n+\t-mfdpic unless -mno-gprel-ro, -fpic or -fpie.\n+\t(MASK_GPREL_RO, TARGET_GPREL_RO): New.\n+\t(TARGET_SWITCHES): Added gprel-ro and no-gprel-ro.\n+\t* doc/invoke.texi: Document them.\n+\t2003-09-30  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/frv/frv-protos.h (frv_gen_GPsym2reg): Declare.\n+\t(frv_splittable_got_operand): Removed.\n+\t* config/frv/frv.c (frv_cannot_force_const_mem): Reject HIGH and\n+\tLO_SUM.  Add comments.\n+\t(frv_override_options): Moved enabling of FDPIC to\n+\tDRIVER_SELF_SPECS.  Don't enable MASK_DWORD.\n+\t(frv_local_funcdesc_p): Remove unnecessary heck for flag_pie.\n+\t(frv_legitimize_fdpic_address): Don't duplicate logic in\n+\tfrv_emit_movsi.\n+\t(frv_gen_GPsym2reg): New.\n+\t(unspec_got_name): Added gprel.\n+\t(frv_expand_fdpic_call): Add support for inlining PLTs.\n+\t(fdpic_fptr_operand): Renamed from frv_fdpic_fptr_operand.\n+\t(gpr_or_int12_operand): Added GPREL12.\n+\t(pic_symbolic_operand): Match even if !flag_pic for FDPIC.\n+\t(small_data_symbolic_operand): Fail if FDPIC.\n+\t(fdpic_splittable_got_operand): Removed.\n+\t(fdpic_got12_operand): Added GPREL12.\n+\t(frv_emit_movsi): Reorganize to avoid duplication.  Emit GPREL\n+\twhen appropriate.  Fix sdata GOTOFF.\n+\t(frv_legitimate_constant_p): Require legitimate PIC operand for\n+\tFDPIC with pic, but only a legitimate fdpic operand for non-pic.\n+\t(frv_assemble_integer): Move FDPIC funcdesc handling out of\n+\tflag_pic case.\n+\t(frv_asm_out_constructor, frv_asm_out_destructor): Abort if\n+\tfrv_assemble_integer fails.\n+\t* config/frv/frv.h (DRIVER_SELF_SPECS): New.\n+\t(SUBTARGET_DRIVER_SELF_SPECS): New.\n+\t(ASM_SPEC): Don't pass -mno-fdpic.\n+\t(LINK_SPEC): Pass -melf32frvfd for FDPIC.\n+\t(MASK_INLINE_PLT, TARGET_INLINE_PLT): New.\n+\t(TARGET_SWITCHES): Add -minline-plt, -mno-inline-plt and\n+\t-multilib-library-pic.\n+\t(PREDICATE_CODES): Added fdpic_operand, fdpic_fptr_operand,\n+\tcondexec_si_media_operator, condexec_sf_add_operator and\n+\tcondexec_sf_conv_operator.  Removed condexec_sf_binary_operator\n+\tand condexec_sf_unary_operator.\n+\t* config/frv/frv.md (R_FRV_GPREL12, R_FRV_GPRELHI, R_FRV_GPRELLO):\n+\tNew.\n+\t(movsi_got, movsi_high_got, movsi_lo_sum_got): Move before\n+\tmovsi_internal.  Give them internal names.  movsi_got has type\n+\tint.\n+\t(fdpic got splitters): Remove.\n+\t(symGPREL2reg, symGPREL2reg_hilo): New.\n+\t* config/frv/t-frv (MULTILIB_MATCHES): Don't map -fpic and -fPIC\n+\tto -mlibrary-pic.  Map -multilib-library-pic to it.\n+\t* doc/invoke.texi: -mfdpic, -minline-plt, -multilib-library-pic:\n+\tDocument.\n+\t2003-09-28  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/frv/frv.c (frv_function_symbol_referenced_p): Declare.\n+\t(TARGET_CANNOT_FORCE_CONST_MEM): Define to...\n+\t(frv_cannot_force_const_mem): New function.\n+\t(const_small_data_p, plus_small_data_p): Update comments on sdata\n+\ton FDPIC.\n+\t(frv_override_options): Set flag_pie for FDPIC too.\n+\t(frv_conditional_register_usage): Mark gr16 and gr17 as non-fixed,\n+\tcall-saved registers on FDPIC.\n+\t(frv_stack_info): Don't preserve the PIC register on FDPIC, and\n+\tdon't force LR to be preserved.\n+\t(frv_expand_prologue): Likewise.\n+\t(frv_asm_output_mi_thunk): Use 12-bit funcdesc gotoff for -fpic.\n+\t(frv_frame_pointer_required): Don't force it just because the\n+\tFDPIC register is used.\n+\t(frv_legitimate_address_p) <CONST>: Accept a legitimate FDPIC\n+\toperand only if !condexec_p.\n+\t(frv_legitimize_address): Return the FDPIC-legitimized address.\n+\tDon't match small data here on FDPIC.\n+\t(frv_legitimate_fdpic_operand_p): Don't accept unadorned function\n+\tsymbols.  Use TRUE/FALSE instead of 1/0.\n+\t(frv_local_funcdesc_p): New.\n+\t(frv_legitimize_fdpic_address): Rewrite to use GOTOFF and 12-bit\n+\timmediates when possible.\n+\t(pic_symbolic_operand): Accept SYMBOL_REFs and CONSTs in FDPIC.\n+\t(dbl_memory_one_insn_operand): Accept addresses that add a REG and\n+\tan UNSPEC_GOT.\n+\t(frv_emit_movsi): Handle FDPIC before small data.  Use GOTOFF and\n+\t12-bit immediates when possible.\n+\t(frv_legitimate_constant_p): In FDPIC, reject SImode operands that\n+\tare not legitimate pic operands.\n+\t(frv_in_small_data_p): Re-enable for FDPIC.\n+\t* config/frv/frv.h (SDA_BASE_REG): Remove comment about FDPIC.\n+\t(FRV_GLOBAL_P): Removed.\n+\t* config/frv/frv.md: Add modes to CONSTs.\n+\t(movsi_got): New.\n+\t(movsi_lo_sum_got): Use separate matches instead of match_dup.\n+\t(movsi_high_pic, movsi_lo_sum_pic): Match on non-FDPIC only.\n+\t(fdpic splittable operations): Match on flag_pic != 1.\n+\t2003-09-22  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/frv/frv.c (frv_asm_out_constructor,\n+\tfrv_asm_out_destructor): Pass to frv_assemble_integer the size in\n+\tbytes, not bits.\n+\t2003-09-19  Alexandre Oliva  <aoliva@redhat.com>\n+\t* config/frv/frv.c (frv_assemble_integer): Reject complex\n+\texpressions referencing function SYMBOL_REFs.\n+\t* config/frv/frv.c (frv_function_symbol_referenced_p): New.\n+\t(move_source_operand): Reject CONSTs that reference function\n+\tSYMBOL_REFs on FDPIC.\n+\t(frv_emit_movsi): If we get such a CONST, break it up.\n+\t* config/frv/frv.h (CPP_SPEC): Define __FRV_FDPIC__ for -mfdpic.\n+\t(TRANSFER_FROM_TRAMPOLINE): Use different definitions for FDPIC.\n+\t* config/frv/frv.c (frv_print_operand) <I>: Recognize PLUS without\n+\tMEM.\n+\t(frv_assemble_integer): Don't use funcdesc for LABEL_REFs.\n+\t(frv_trampoline_size): Increase for FDPIC.\n+\t* config/frv/frv.h (TRAMPOLINE_ALIGNMENT): Bump to 64 for FDPIC.\n+\t(TRANSFER_FROM_TRAMPOLINE): Handle FDPIC trampolines.\n+\t* config/frv/frv.c (frv_legitimize_fdpic_address, frv_emit_movsi):\n+\tDisable use of GOTOFF for now.\n+\t(const_small_data_p, plus_small_data_p, frv_in_small_data_p):\n+\tDisable use of small data in FDPIC for now.\n+\t(frv_asm_output_mi_thunk): Implement for FDPIC.\n+\t* config/frv/frv.h (SDA_BASE_REG): Set to -1 with FDPIC.\n+\t* config/frv/frv.c (frv_asm_out_constructor): Use\n+\tfrv_assemble_integer for FDPIC pointers.\n+\t(frv_asm_out_destructor): Likewise.\n+\t* config/frv/frv.md (ldd): Fix order of operands.  Use\n+\taddress_operand for input.\n+\t2003-09-18  DJ Delorie  <dj@redhat.com>\n+\t* config/frv/frv.c (frv_legitimate_fdpic_operand_p): Remove UNSPEC_PIC.\n+\t(unspec_got_name): Correct typo.\n+\t(frv_emit_movsi): Pre-expand splittable GOTs.\n+\t(frv_expand_fdpic_call): Rename gen_lddi to gen_ldd.\n+\t* config/frv/frv.md (lddi): Fix syntax error, rename to ldd.\n+\t(symGOT2reg_hilo, symGOTOFF2reg_hilo): New.\n+\t* config/frv/t-frv: Add -mfdpic multilibs.\n+\t* config/frv/frv.h (ASM_SPEC): Pass -mfdpic/-mno-fdpic.\n+\t(TARGET_SWITCHES): Add -mno-fdpic, fix documentation.\n+\t* config/frv/frv.c (frv_override_options): -mfdpic assumes\n+\tflag_pic, default to 32-bit pics, require DWORD ops.\n+\t(frv_override_options): Add W and Z constraints.\n+\t(frv_expand_prologue): No pic prologue for -mfdpic.\n+\t(frv_asm_output_mi_thunk): Support -mfdpic (soon).\n+\t(frv_print_operand_memory_reference): Handle GOT constants.\n+\t(frv_legitimate_address_p): Allow GOT constants.\n+\t(frv_legitimize_address): Handle GOT addresses too.\n+\t(frv_legitimate_fdpic_operand_p): New.\n+\t(frv_legitimize_fdpic_address): New.\n+\t(unspec_got_name): New.\n+\t(frv_output_addr_const_extra): New.\n+\t(frv_expand_fdpic_call): New.\n+\t(frv_fdpic_fptr_operand): New.\n+\t(gpr_or_int12_operand): Handle GOT operands.\n+\t(int_2word_operand): Handle GOT operands.\n+\t(fdpic_operand): New.\n+\t(fdpic_splittable_got_operand): New.\n+\t(fdpic_got12_operand): New.\n+\t(frv_emit_movsi): Handle GOT operands.\n+\t(frv_assemble_integer): -mfdpic doesn't use rofixups.\n+\t(frv_print_operand): Support 'g' code for GOT operands.\n+\t* config/frv/frv-protos.h: Add prototypes as needed.\n+\t* config/frv/frv.md (R_FRV_GOT12, R_FRV_GOTHI, R_FRV_GOTLO,\n+\tR_FRV_FUNCDESC, R_FRV_FUNCDESC_GOT12, R_FRV_FUNCDESC_GOTHI,\n+\tR_FRV_FUNCDESC_GOTLO, R_FRV_FUNCDESC_VALUE,\n+\tR_FRV_FUNCDESC_GOTOFF12, R_FRV_FUNCDESC_GOTOFFHI,\n+\tR_FRV_FUNCDESC_GOTOFFLO, R_FRV_GOTOFF12, R_FRV_GOTOFFHI,\n+\tR_FRV_GOTOFFLO): New.\n+\t(movsi_high_got, movsi_lo_sum_got): New.\n+\t(*movsi_pic): Don't use this splitter for -mfdpic.\n+\t(addsi3): Allow GOT references also.\n+\t(call, call_value): Handle -mfdpic separately.\n+\t(call_fdpicdi, call_fdpicsi, lddi, call_value_fdpicdi,\n+\tcall_value_fdpicsi): New.\n+\t(symGOT2reg, symGOT2reg_i, got splitters, symGOTOFF2reg,\n+\tsymGOTOFF2reg_i): New.\n+\t* config/frv/frv.h (MASK_FDPIC): New.\n+\t(TARGET_FDPIC): New.\n+\t(TARGET_SWITCHES): Add -mfdpic.\n+\t(FDPIC_FPTR_REGNO): New.\n+\t(FDPIC_REGNO): New.\n+\t(OUR_FDPIC_REG): New.\n+\t(enum reg_class): Add FDPIC_REGS, FDPIC_FPTR_REGS, and\n+\tFDPIC_CALL_REGS.\n+\t(REG_CLASS_NAMES): Likewise.\n+\t(REG_CLASS_CONTENTS): Likewise.\n+\t(EXTRA_CONSTRAINT_FOR_Y): New, for 12-bit GOTs.\n+\t(EXTRA_CONSTRAINT): Add it here.\n+\t(FRV_GLOBAL_P): New.\n+\t(OUTPUT_ADDR_CONST_EXTRA): New.\n+\n 2004-02-24  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/sparc/sparc.h: Remove commented-out definitions of"}, {"sha": "e090d8866ac0e3a95e98375ebe4bf521f34c6dcd", "filename": "gcc/config.gcc", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=34208acf14fa026ae391a819525d20b48af5c2bf", "patch": "@@ -420,7 +420,7 @@ case ${target} in\n *-*-linux*libc1* | *-*-linux*aout*)\n   # Avoid the generic linux case.\n   ;;\n-*-*-linux*)\n+*-*-linux* | frv-*-*linux*)\n   # Must come before *-*-gnu* (because of *-*-linux-gnu* systems).\n   extra_parts=\"crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o\"\n   gas=yes\n@@ -718,6 +718,11 @@ frv-*-elf)\n \ttmake_file=frv/t-frv\n \tuse_fixproto=yes\n \t;;\n+frv-*-*linux*)\n+\ttm_file=\"dbxelf.h elfos.h svr4.h ${tm_file} \\\n+\t         linux.h frv/linux.h frv/frv-abi.h\"\n+\ttmake_file=\"t-slibgcc-elf-ver t-linux frv/t-frv frv/t-linux\"\n+\t;;\n h8300-*-rtems*)\n \ttmake_file=\"h8300/t-h8300 t-rtems\"\n \ttm_file=\"h8300/h8300.h dbxcoff.h h8300/coff.h h8300/rtems.h rtems.h\"\n@@ -2159,6 +2164,9 @@ if test x$with_cpu = x ; then\n     alphaev5*-*-*)\n       with_cpu=ev5\n       ;;\n+    frv-*-*linux*)\n+      with_cpu=fr400\n+      ;;\n     sparc*-*-*)\n       with_cpu=\"`echo ${target} | sed 's/-.*$//'`\"\n       if [ x$with_cpu = xsparc64 ]; then\n@@ -2269,6 +2277,17 @@ fi\n \t\tfi\n \t\t;;\n \n+\tfr*-*-*linux*)\n+\t\tsupported_defaults=cpu\n+\t\tcase \"$with_cpu\" in\n+\t\tfr400) ;;\n+\t\t*)\n+\t\t\techo \"Unknown cpu used in --with-cpu=$with_cpu\" 1>&2\n+\t\t\texit 1\n+\t\t\t;;\n+\t\tesac\n+\t\t;;\n+\n \thppa*-*-* | parisc*-*-*)\n \t\tsupported_defaults=\"arch schedule\"\n "}, {"sha": "7a53775082452e952a8c38e49d11a6bdba672a79", "filename": "gcc/config/frv/frv-abi.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Ffrv-abi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Ffrv-abi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-abi.h?ref=34208acf14fa026ae391a819525d20b48af5c2bf", "patch": "@@ -1,5 +1,5 @@\n /* Frv map GCC names to FR-V ABI.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2003 Free Software Foundation, Inc.\n    Contributed by Red Hat, Inc.\n \n This file is part of GCC.\n@@ -43,7 +43,8 @@ __asm__ (\".text\\n\"\t\t\t\t\t\t\t\\\n \t \"\\t.type\\t\" #NEW \",@function\\n\"\t\t\t\t\\\n \t #NEW \":\\n\"\t\t\t\t\t\t\t\\\n \t \"\\tor\\tgr11, gr0, gr10\\n\"\t\t\t\t\t\\\n-\t \"\\tbra\\t\" #OLD \"\\n\");\n+\t \".L\" #OLD \" = \" #OLD \"\\n\"\t\t\t\t\t\\\n+\t \"\\tbra\\t.L\" #OLD \"\\n\");\n \n #ifdef L_sf_to_df\n #define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY(__extendsfdf2,__ftod)"}, {"sha": "642635090d03c180728d6c95dcb95d97de838bc4", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=34208acf14fa026ae391a819525d20b48af5c2bf", "patch": "@@ -63,9 +63,9 @@ extern int frv_frame_pointer_required\t\t(void);\n extern int frv_initial_elimination_offset\t(int, int);\n \n #ifdef RTX_CODE\n-extern int frv_legitimate_address_p \t\t(enum machine_mode, rtx,\n-\t\t\t\t\t\t int, int);\n-extern rtx frv_legitimize_address\t\t(rtx, rtx, enum machine_mode);\n+extern int frv_legitimate_address_p\t\t(enum machine_mode, rtx,\n+\t\t\t\t\t\t int, int, int);\n+extern rtx frv_find_base_term\t\t\t(rtx);\n \n #ifdef TREE_CODE\n extern void frv_init_cumulative_args\t\t(CUMULATIVE_ARGS *, tree,\n@@ -225,5 +225,7 @@ extern int even_acc_operand\t\t(rtx, enum machine_mode);\n extern int quad_acc_operand\t\t(rtx, enum machine_mode);\n extern int accg_operand\t\t\t(rtx, enum machine_mode);\n extern rtx frv_matching_accg_for_acc\t(rtx);\n+extern void frv_expand_fdpic_call\t(rtx *, int);\n+extern rtx frv_gen_GPsym2reg\t\t(rtx, rtx);\n #endif\n "}, {"sha": "92daeaa2f6d2cc13cc8a009c6887c74a763a4cb3", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 703, "deletions": 238, "changes": 941, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=34208acf14fa026ae391a819525d20b48af5c2bf", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2004\n+/* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003, 2004\n    Free Software Foundation, Inc.\n    Contributed by Red Hat, Inc.\n \n@@ -48,11 +48,21 @@ Boston, MA 02111-1307, USA.  */\n #include <ctype.h>\n #include \"target.h\"\n #include \"target-def.h\"\n+#include \"integrate.h\"\n \n #ifndef FRV_INLINE\n #define FRV_INLINE inline\n #endif\n \n+/* Information about a relocation unspec.  SYMBOL is the relocation symbol\n+   (a SYMBOL_REF or LABEL_REF), RELOC is the type of relocation and OFFSET\n+   is the constant addend.  */\n+struct frv_unspec {\n+  rtx symbol;\n+  int reloc;\n+  HOST_WIDE_INT offset;\n+};\n+\n /* Temporary register allocation support structure.  */\n typedef struct frv_tmp_reg_struct\n   {\n@@ -199,8 +209,8 @@ int frv_sched_lookahead = 4;\t\t /* -msched-lookahead=n */\n /* Forward references */\n static int frv_default_flags_for_cpu\t\t(void);\n static int frv_string_begins_with\t\t(tree, const char *);\n-static FRV_INLINE int const_small_data_p\t(rtx);\n-static FRV_INLINE int plus_small_data_p\t\t(rtx, rtx);\n+static FRV_INLINE bool frv_small_data_reloc_p\t(rtx, int);\n+static FRV_INLINE bool frv_const_unspec_p\t(rtx, struct frv_unspec *);\n static void frv_print_operand_memory_reference_reg\n \t\t\t\t\t\t(FILE *, rtx);\n static void frv_print_operand_memory_reference\t(FILE *, rtx, int);\n@@ -270,6 +280,11 @@ static rtx frv_expand_builtin_saveregs\t\t(void);\n static bool frv_rtx_costs\t\t\t(rtx, int, int, int*);\n static void frv_asm_out_constructor\t\t(rtx, int);\n static void frv_asm_out_destructor\t\t(rtx, int);\n+static bool frv_function_symbol_referenced_p\t(rtx);\n+static bool frv_cannot_force_const_mem\t\t(rtx);\n+static const char *unspec_got_name\t\t(int);\n+static void frv_output_const_unspec\t\t(FILE *,\n+\t\t\t\t\t\t const struct frv_unspec *);\n static rtx frv_struct_value_rtx\t\t\t(tree, int);\n \f\n /* Initialize the GCC target structure.  */\n@@ -304,6 +319,9 @@ static rtx frv_struct_value_rtx\t\t\t(tree, int);\n #undef  TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n #define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE frv_use_dfa_pipeline_interface\n \n+#undef TARGET_CANNOT_FORCE_CONST_MEM\n+#define TARGET_CANNOT_FORCE_CONST_MEM frv_cannot_force_const_mem\n+\n #undef TARGET_STRUCT_VALUE_RTX\n #define TARGET_STRUCT_VALUE_RTX frv_struct_value_rtx\n \n@@ -314,47 +332,74 @@ static rtx frv_struct_value_rtx\t\t\t(tree, int);\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n-/* Given a CONST, return true if the symbol_ref points to small data.  */\n+/* Return true if SYMBOL is a small data symbol and relocation RELOC\n+   can be used to access it directly in a load or store.  */\n \n-static FRV_INLINE int\n-const_small_data_p (rtx x)\n+static FRV_INLINE bool\n+frv_small_data_reloc_p (rtx symbol, int reloc)\n {\n-  rtx x0, x1;\n+  return (GET_CODE (symbol) == SYMBOL_REF\n+\t  && SYMBOL_REF_SMALL_P (symbol)\n+\t  && (!TARGET_FDPIC || flag_pic == 1)\n+\t  && (reloc == R_FRV_GOTOFF12 || reloc == R_FRV_GPREL12));\n+}\n \n-  if (GET_CODE (XEXP (x, 0)) != PLUS)\n-    return FALSE;\n+/* Return true if X is a valid relocation unspec.  If it is, fill in UNSPEC\n+   appropriately.  */\n \n-  x0 = XEXP (XEXP (x, 0), 0);\n-  if (GET_CODE (x0) != SYMBOL_REF || !SYMBOL_REF_SMALL_P (x0))\n-    return FALSE;\n+static FRV_INLINE bool\n+frv_const_unspec_p (rtx x, struct frv_unspec *unspec)\n+{\n+  if (GET_CODE (x) == CONST)\n+    {\n+      unspec->offset = 0;\n+      x = XEXP (x, 0);\n+      if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t{\n+\t  unspec->offset += INTVAL (XEXP (x, 1));\n+\t  x = XEXP (x, 0);\n+\t}\n+      if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_GOT)\n+\t{\n+\t  unspec->symbol = XVECEXP (x, 0, 0);\n+\t  unspec->reloc = INTVAL (XVECEXP (x, 0, 1));\n \n-  x1 = XEXP (XEXP (x, 0), 1);\n-  if (GET_CODE (x1) != CONST_INT\n-      || !IN_RANGE_P (INTVAL (x1), -2048, 2047))\n-    return FALSE;\n+\t  if (unspec->offset == 0)\n+\t    return true;\n \n-  return TRUE;\n+\t  if (frv_small_data_reloc_p (unspec->symbol, unspec->reloc)\n+\t      && unspec->offset > 0\n+\t      && (unsigned HOST_WIDE_INT) unspec->offset < g_switch_value)\n+\t    return true;\n+\t}\n+    }\n+  return false;\n }\n \n-/* Given a PLUS, return true if this is a small data reference.  */\n+/* Decide whether we can force certain constants to memory.  If we\n+   decide we can't, the caller should be able to cope with it in\n+   another way.\n \n-static FRV_INLINE int\n-plus_small_data_p (rtx op0, rtx op1)\n-{\n-  if (GET_MODE (op0) == SImode\n-      && GET_CODE (op0) == REG\n-      && REGNO (op0) == SDA_BASE_REG)\n-    {\n-      if (GET_CODE (op1) == SYMBOL_REF)\n-\treturn SYMBOL_REF_SMALL_P (op1);\n+   We never allow constants to be forced into memory for TARGET_FDPIC.\n+   This is necessary for several reasons:\n \n-      if (GET_CODE (op1) == CONST)\n-\treturn const_small_data_p (op1);\n-    }\n+   1. Since LEGITIMATE_CONSTANT_P rejects constant pool addresses, the\n+      target-independent code will try to force them into the constant\n+      pool, thus leading to infinite recursion.\n \n-  return FALSE;\n-}\n+   2. We can never introduce new constant pool references during reload.\n+      Any such reference would require use of the pseudo FDPIC register.\n \n+   3. We can't represent a constant added to a function pointer (which is\n+      not the same as a pointer to a function+constant).\n+\n+   4. In many cases, it's more efficient to calculate the constant in-line.  */\n+\n+static bool\n+frv_cannot_force_const_mem (rtx x ATTRIBUTE_UNUSED)\n+{\n+  return TARGET_FDPIC;\n+}\n \f\n static int\n frv_default_flags_for_cpu (void)\n@@ -577,13 +622,18 @@ frv_override_options (void)\n   reg_class_from_letter['A'] = QUAD_ACC_REGS;\n   reg_class_from_letter['B'] = ACCG_REGS;\n   reg_class_from_letter['C'] = CR_REGS;\n+  reg_class_from_letter['W'] = FDPIC_CALL_REGS; /* gp14+15 */\n+  reg_class_from_letter['Z'] = FDPIC_REGS; /* gp15 */\n \n   /* There is no single unaligned SI op for PIC code.  Sometimes we\n      need to use \".4byte\" and sometimes we need to use \".picptr\".\n      See frv_assemble_integer for details.  */\n-  if (flag_pic)\n+  if (flag_pic || TARGET_FDPIC)\n     targetm.asm_out.unaligned_op.si = 0;\n \n+  if ((target_flags_explicit & MASK_LINKED_FP) == 0)\n+    target_flags |= MASK_LINKED_FP;\n+\n   init_machine_status = frv_init_machine_status;\n }\n \n@@ -686,6 +736,10 @@ frv_conditional_register_usage (void)\n       fixed_regs[FCR_FIRST] = call_used_regs[FCR_FIRST] = 1;\n     }\n \n+  if (TARGET_FDPIC)\n+    fixed_regs[GPR_FIRST + 16] = fixed_regs[GPR_FIRST + 17] =\n+      call_used_regs[GPR_FIRST + 16] = call_used_regs[GPR_FIRST + 17] = 0;\n+\n #if 0\n   /* If -fpic, SDA_BASE_REG is the PIC register.  */\n   if (g_switch_value == 0 && !flag_pic)\n@@ -966,7 +1020,8 @@ frv_stack_info (void)\n \t      if ((regs_ever_live[regno] && !call_used_regs[regno])\n \t\t  || (current_function_calls_eh_return\n \t\t      && (regno >= FIRST_EH_REGNUM && regno <= LAST_EH_REGNUM))\n-\t\t  || (flag_pic && cfun->uses_pic_offset_table && regno == PIC_REGNO))\n+\t\t  || (!TARGET_FDPIC && flag_pic\n+\t\t      && cfun->uses_pic_offset_table && regno == PIC_REGNO))\n \t\t{\n \t\t  info_ptr->save_p[regno] = REG_SAVE_1WORD;\n \t\t  size_1word += UNITS_PER_WORD;\n@@ -982,8 +1037,11 @@ frv_stack_info (void)\n \tcase STACK_REGS_LR:\n \t  if (regs_ever_live[LR_REGNO]\n               || profile_flag\n-              || frame_pointer_needed\n-              || (flag_pic && cfun->uses_pic_offset_table))\n+\t      /* This is set for __builtin_return_address, etc.  */\n+\t      || cfun->machine->frame_needed\n+              || (TARGET_LINKED_FP && frame_pointer_needed)\n+              || (!TARGET_FDPIC && flag_pic\n+\t\t  && cfun->uses_pic_offset_table))\n \t    {\n \t      info_ptr->save_p[LR_REGNO] = REG_SAVE_1WORD;\n \t      size_1word += UNITS_PER_WORD;\n@@ -1077,6 +1135,7 @@ frv_stack_info (void)\n \n   /* See if we need to create a frame at all, if so add header area.  */\n   if (info_ptr->total_size  > 0\n+      || frame_pointer_needed\n       || info_ptr->regs[STACK_REGS_LR].size_1word > 0\n       || info_ptr->regs[STACK_REGS_STRUCT].size_1word > 0)\n     {\n@@ -1652,7 +1711,7 @@ frv_expand_prologue (void)\n     emit_insn (gen_blockage ());\n \n   /* Set up pic register/small data register for this function.  */\n-  if (flag_pic && cfun->uses_pic_offset_table)\n+  if (!TARGET_FDPIC && flag_pic && cfun->uses_pic_offset_table)\n     emit_insn (gen_pic_prologue (gen_rtx_REG (Pmode, PIC_REGNO),\n \t\t\t\t gen_rtx_REG (Pmode, LR_REGNO),\n \t\t\t\t gen_rtx_REG (SImode, OFFSET_REGNO)));\n@@ -1787,7 +1846,31 @@ frv_asm_output_mi_thunk (FILE *file,\n       fprintf (file, \"\\tadd %s,%s,%s\\n\", name_add, name_arg0, name_arg0);\n     }\n \n-  if (!flag_pic)\n+  if (TARGET_FDPIC)\n+    {\n+      const char *name_pic = reg_names[FDPIC_REGNO];\n+      name_jmp = reg_names[FDPIC_FPTR_REGNO];\n+\n+      if (flag_pic != 1)\n+\t{\n+\t  fprintf (file, \"\\tsethi%s #gotofffuncdeschi(\", parallel);\n+\t  assemble_name (file, name_func);\n+\t  fprintf (file, \"),%s\\n\", name_jmp);\n+\n+\t  fprintf (file, \"\\tsetlo #gotofffuncdesclo(\");\n+\t  assemble_name (file, name_func);\n+\t  fprintf (file, \"),%s\\n\", name_jmp);\n+\n+\t  fprintf (file, \"\\tldd @(%s,%s), %s\\n\", name_jmp, name_pic, name_jmp);\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\tlddo @(%s,#gotofffuncdesc12(\", name_pic);\n+\t  assemble_name (file, name_func);\n+\t  fprintf (file, \"\\t)), %s\\n\", name_jmp);\n+\t}\n+    }\n+  else if (!flag_pic)\n     {\n       fprintf (file, \"\\tsethi%s #hi(\", parallel);\n       assemble_name (file, name_func);\n@@ -1852,6 +1935,11 @@ frv_asm_output_mi_thunk (FILE *file,\n int\n frv_frame_pointer_required (void)\n {\n+  /* If we forgoing the usual linkage requirements, we only need\n+     a frame pointer if the stack pointer might change.  */\n+  if (!TARGET_LINKED_FP)\n+    return !current_function_sp_is_unchanging;\n+\n   if (! current_function_is_leaf)\n     return TRUE;\n \n@@ -1864,7 +1952,7 @@ frv_frame_pointer_required (void)\n   if (!current_function_sp_is_unchanging)\n     return TRUE;\n \n-  if (flag_pic && cfun->uses_pic_offset_table)\n+  if (!TARGET_FDPIC && flag_pic && cfun->uses_pic_offset_table)\n     return TRUE;\n \n   if (profile_flag)\n@@ -2292,8 +2380,10 @@ frv_dynamic_chain_address (rtx frame)\n    address of other frames.  */\n \n rtx\n-frv_return_addr_rtx (int count ATTRIBUTE_UNUSED, rtx frame)\n+frv_return_addr_rtx (int count, rtx frame)\n {\n+  if (count != 0)\n+    return const0_rtx;\n   cfun->machine->frame_needed = 1;\n   return gen_rtx_MEM (Pmode, plus_constant (frame, 8));\n }\n@@ -2366,6 +2456,7 @@ frv_print_operand_memory_reference_reg (FILE * stream, rtx x)\n static void\n frv_print_operand_memory_reference (FILE * stream, rtx x, int addr_offset)\n {\n+  struct frv_unspec unspec;\n   rtx x0 = NULL_RTX;\n   rtx x1 = NULL_RTX;\n \n@@ -2434,29 +2525,10 @@ frv_print_operand_memory_reference (FILE * stream, rtx x, int addr_offset)\n \t  fprintf (stream, \"%ld\", (long) (INTVAL (x1) + addr_offset));\n \t  break;\n \n-\tcase SYMBOL_REF:\n-\t  if (x0 && GET_CODE (x0) == REG && REGNO (x0) == SDA_BASE_REG\n-\t      && SYMBOL_REF_SMALL_P (x1))\n-\t    {\n-\t      fputs (\"#gprel12(\", stream);\n-\t      assemble_name (stream, XSTR (x1, 0));\n-\t      fputs (\")\", stream);\n-\t    }\n-\t  else\n-\t    fatal_insn (\"Bad insn to frv_print_operand_memory_reference:\", x);\n-\t  break;\n-\n \tcase CONST:\n-\t  if (x0 && GET_CODE (x0) == REG && REGNO (x0) == SDA_BASE_REG\n-\t      && const_small_data_p (x1))\n-\t    {\n-\t      fputs (\"#gprel12(\", stream);\n-\t      assemble_name (stream, XSTR (XEXP (XEXP (x1, 0), 0), 0));\n-\t      fprintf (stream, \"+\"HOST_WIDE_INT_PRINT_DEC\")\",\n-\t\t       INTVAL (XEXP (XEXP (x1, 0), 1)));\n-\t    }\n-\t  else\n-\t    fatal_insn (\"Bad insn to frv_print_operand_memory_reference:\", x);\n+\t  if (!frv_const_unspec_p (x1, &unspec))\n+\t    fatal_insn (\"Bad insn to frv_print_operand_memory_reference:\", x1);\n+\t  frv_output_const_unspec (stream, &unspec);\n \t  break;\n \n \tdefault:\n@@ -2573,6 +2645,7 @@ frv_print_operand_jump_hint (rtx insn)\n void\n frv_print_operand (FILE * file, rtx x, int code)\n {\n+  struct frv_unspec unspec;\n   HOST_WIDE_INT value;\n   int offset;\n \n@@ -2726,13 +2799,22 @@ frv_print_operand (FILE * file, rtx x, int code)\n \t}\n       break;\n \n+    case 'g':\n+      /* Print appropriate GOT function.  */\n+      if (GET_CODE (x) != CONST_INT)\n+\tfatal_insn (\"Bad insn to frv_print_operand, 'g' modifier:\", x);\n+      fputs (unspec_got_name (INTVAL (x)), file);\n+      break;\n+\n     case 'I':\n       /* Print 'i' if the operand is a constant, or is a memory reference that\n          adds a constant.  */\n       if (GET_CODE (x) == MEM)\n \tx = ((GET_CODE (XEXP (x, 0)) == PLUS)\n \t     ? XEXP (XEXP (x, 0), 1)\n \t     : XEXP (x, 0));\n+      else if (GET_CODE (x) == PLUS)\n+\tx = XEXP (x, 1);\n \n       switch (GET_CODE (x))\n \t{\n@@ -2861,6 +2943,9 @@ frv_print_operand (FILE * file, rtx x, int code)\n               || GET_CODE (x) == CONST_DOUBLE)\n         fprintf (file, \"%s%ld\", IMMEDIATE_PREFIX, (long) value);\n \n+      else if (frv_const_unspec_p (x, &unspec))\n+\tfrv_output_const_unspec (file, &unspec);\n+\n       else if (GET_CODE (x) == MEM)\n         frv_print_operand_address (file, XEXP (x, 0));\n \n@@ -3202,7 +3287,8 @@ int\n frv_legitimate_address_p (enum machine_mode mode,\n                           rtx x,\n                           int strict_p,\n-                          int condexec_p)\n+                          int condexec_p,\n+\t\t\t  int allow_double_reg_p)\n {\n   rtx x0, x1;\n   int ret = 0;\n@@ -3284,7 +3370,7 @@ frv_legitimate_address_p (enum machine_mode mode,\n \tcase REG:\n \t  /* Do not allow reg+reg addressing for modes > 1 word if we\n \t     can't depend on having move double instructions.  */\n-\t  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+\t  if (!allow_double_reg_p && GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n \t    ret = FALSE;\n \t  else\n \t    ret = frv_regno_ok_for_base_p (REGNO (x1), strict_p);\n@@ -3306,15 +3392,8 @@ frv_legitimate_address_p (enum machine_mode mode,\n \t    }\n \t  break;\n \n-\tcase SYMBOL_REF:\n-\t  if (!condexec_p\n-\t      && regno0 == SDA_BASE_REG\n-\t      && SYMBOL_REF_SMALL_P (x1))\n-\t    ret = TRUE;\n-\t  break;\n-\n \tcase CONST:\n-\t  if (!condexec_p && regno0 == SDA_BASE_REG && const_small_data_p (x1))\n+\t  if (!condexec_p && got12_operand (x1, VOIDmode))\n \t    ret = TRUE;\n \t  break;\n \n@@ -3334,54 +3413,107 @@ frv_legitimate_address_p (enum machine_mode mode,\n }\n \n \f\n-/* A C compound statement that attempts to replace X with a valid memory\n-   address for an operand of mode MODE.  WIN will be a C statement label\n-   elsewhere in the code; the macro definition may use\n+/* Test whether a local function descriptor is canonical, i.e.,\n+   whether we can use FUNCDESC_GOTOFF to compute the address of the\n+   function.  */\n+\n+static bool\n+frv_local_funcdesc_p (rtx fnx)\n+{\n+  tree fn;\n+  enum symbol_visibility vis;\n+  bool ret;\n \n-        GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN);\n+  if (! SYMBOL_REF_LOCAL_P (fnx))\n+    return FALSE;\n+\n+  fn = SYMBOL_REF_DECL (fnx);\n+\n+  if (! fn)\n+    return FALSE;\n \n-   to avoid further processing if the address has become legitimate.\n+  vis = DECL_VISIBILITY (fn);\n \n-   X will always be the result of a call to `break_out_memory_refs', and OLDX\n-   will be the operand that was given to that function to produce X.\n+  if (vis == VISIBILITY_PROTECTED)\n+    /* Private function descriptors for protected functions are not\n+       canonical.  Temporarily change the visibility to global.  */\n+    vis = VISIBILITY_DEFAULT;\n+  else if (flag_shlib)\n+    /* If we're already compiling for a shared library (that, unlike\n+       executables, can't assume that the existence of a definition\n+       implies local binding), we can skip the re-testing.  */\n+    return TRUE;\n \n-   The code generated by this macro should not alter the substructure of X.  If\n-   it transforms X into a more legitimate form, it should assign X (which will\n-   always be a C variable) a new value.\n+  ret = default_binds_local_p_1 (fn, flag_pic);\n \n-   It is not necessary for this macro to come up with a legitimate address.\n-   The compiler has standard ways of doing so in all cases.  In fact, it is\n-   safe for this macro to do nothing.  But often a machine-dependent strategy\n-   can generate better code.  */\n+  DECL_VISIBILITY (fn) = vis;\n+\n+  return ret;\n+}\n+\n+/* Load the _gp symbol into DEST.  SRC is supposed to be the FDPIC\n+   register.  */\n \n rtx\n-frv_legitimize_address (rtx x,\n-                        rtx oldx ATTRIBUTE_UNUSED,\n-                        enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  rtx ret = NULL_RTX;\n-\n-  /* Don't try to legitimize addresses if we are not optimizing, since the\n-     address we generate is not a general operand, and will horribly mess\n-     things up when force_reg is called to try and put it in a register because\n-     we aren't optimizing.  */\n-  if (optimize\n-      && ((GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_SMALL_P (x))\n-\t  || (GET_CODE (x) == CONST && const_small_data_p (x))))\n-    {\n-      ret = gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode, SDA_BASE_REG), x);\n-      if (flag_pic)\n-\tcfun->uses_pic_offset_table = TRUE;\n-    }\n+frv_gen_GPsym2reg (rtx dest, rtx src)\n+{\n+  tree gp = get_identifier (\"_gp\");\n+  rtx gp_sym = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (gp));\n \n-  if (TARGET_DEBUG_ADDR && ret != NULL_RTX)\n+  return gen_symGOT2reg (dest, gp_sym, src, GEN_INT (R_FRV_GOT12));\n+}\n+\n+static const char *\n+unspec_got_name (int i)\n+{\n+  switch (i)\n     {\n-      fprintf (stderr, \"\\n========== LEGITIMIZE_ADDRESS, mode = %s, modified address\\n\",\n-\t       GET_MODE_NAME (mode));\n-      debug_rtx (ret);\n+    case R_FRV_GOT12: return \"got12\";\n+    case R_FRV_GOTHI: return \"gothi\";\n+    case R_FRV_GOTLO: return \"gotlo\";\n+    case R_FRV_FUNCDESC: return \"funcdesc\";\n+    case R_FRV_FUNCDESC_GOT12: return \"gotfuncdesc12\";\n+    case R_FRV_FUNCDESC_GOTHI: return \"gotfuncdeschi\";\n+    case R_FRV_FUNCDESC_GOTLO: return \"gotfuncdesclo\";\n+    case R_FRV_FUNCDESC_VALUE: return \"funcdescvalue\";\n+    case R_FRV_FUNCDESC_GOTOFF12: return \"gotofffuncdesc12\";\n+    case R_FRV_FUNCDESC_GOTOFFHI: return \"gotofffuncdeschi\";\n+    case R_FRV_FUNCDESC_GOTOFFLO: return \"gotofffuncdesclo\";\n+    case R_FRV_GOTOFF12: return \"gotoff12\";\n+    case R_FRV_GOTOFFHI: return \"gotoffhi\";\n+    case R_FRV_GOTOFFLO: return \"gotofflo\";\n+    case R_FRV_GPREL12: return \"gprel12\";\n+    case R_FRV_GPRELHI: return \"gprelhi\";\n+    case R_FRV_GPRELLO: return \"gprello\";\n+    default: abort ();\n     }\n+}\n \n-  return ret;\n+/* Write the assembler syntax for UNSPEC to STREAM.  Note that any offset\n+   is added inside the relocation operator.  */\n+\n+static void\n+frv_output_const_unspec (FILE *stream, const struct frv_unspec *unspec)\n+{\n+  fprintf (stream, \"#%s(\", unspec_got_name (unspec->reloc));\n+  output_addr_const (stream, plus_constant (unspec->symbol, unspec->offset));\n+  fputs (\")\", stream);\n+}\n+\n+/* Implement FIND_BASE_TERM.  See whether ORIG_X represents #gprel12(foo)\n+   or #gotoff12(foo) for some small data symbol foo.  If so, return foo,\n+   otherwise return ORIG_X.  */\n+\n+rtx\n+frv_find_base_term (rtx x)\n+{\n+  struct frv_unspec unspec;\n+\n+  if (frv_const_unspec_p (x, &unspec)\n+      && frv_small_data_reloc_p (unspec.symbol, unspec.reloc))\n+    return plus_constant (unspec.symbol, unspec.offset);\n+\n+  return x;\n }\n \n /* Return 1 if operand is a valid FRV address.  CONDEXEC_P is true if\n@@ -3393,9 +3525,109 @@ frv_legitimate_memory_operand (rtx op, enum machine_mode mode, int condexec_p)\n   return ((GET_MODE (op) == mode || mode == VOIDmode)\n \t  && GET_CODE (op) == MEM\n \t  && frv_legitimate_address_p (mode, XEXP (op, 0),\n-\t\t\t\t       reload_completed, condexec_p));\n+\t\t\t\t       reload_completed, condexec_p, FALSE));\n+}\n+\n+void\n+frv_expand_fdpic_call (rtx *operands, int ret_value)\n+{\n+  rtx lr = gen_rtx_REG (Pmode, LR_REGNO);\n+  rtx picreg = get_hard_reg_initial_val (SImode, FDPIC_REG);\n+  rtx c, rvrtx=0;\n+  rtx addr;\n+\n+  if (ret_value)\n+    {\n+      rvrtx = operands[0];\n+      operands ++;\n+    }\n+\n+  addr = XEXP (operands[0], 0);\n+\n+  /* Inline PLTs if we're optimizing for speed.  We'd like to inline\n+     any calls that would involve a PLT, but can't tell, since we\n+     don't know whether an extern function is going to be provided by\n+     a separate translation unit or imported from a separate module.\n+     When compiling for shared libraries, if the function has default\n+     visibility, we assume it's overridable, so we inline the PLT, but\n+     for executables, we don't really have a way to make a good\n+     decision: a function is as likely to be imported from a shared\n+     library as it is to be defined in the executable itself.  We\n+     assume executables will get global functions defined locally,\n+     whereas shared libraries will have them potentially overridden,\n+     so we only inline PLTs when compiling for shared libraries.\n+\n+     In order to mark a function as local to a shared library, any\n+     non-default visibility attribute suffices.  Unfortunately,\n+     there's no simple way to tag a function declaration as ``in a\n+     different module'', which we could then use to trigger PLT\n+     inlining on executables.  There's -minline-plt, but it affects\n+     all external functions, so one would have to also mark function\n+     declarations available in the same module with non-default\n+     visibility, which is advantageous in itself.  */\n+  if (GET_CODE (addr) == SYMBOL_REF && !SYMBOL_REF_LOCAL_P (addr)\n+      && TARGET_INLINE_PLT)\n+    {\n+      rtx x, dest;\n+      dest = gen_reg_rtx (SImode);\n+      if (flag_pic != 1)\n+\tx = gen_symGOTOFF2reg_hilo (dest, addr, OUR_FDPIC_REG,\n+\t\t\t\t    GEN_INT (R_FRV_FUNCDESC_GOTOFF12));\n+      else\n+\tx = gen_symGOTOFF2reg (dest, addr, OUR_FDPIC_REG,\n+\t\t\t       GEN_INT (R_FRV_FUNCDESC_GOTOFF12));\n+      emit_insn (x);\n+      cfun->uses_pic_offset_table = TRUE;\n+      addr = dest;\n+    }    \n+  else if (GET_CODE (addr) == SYMBOL_REF)\n+    {\n+      /* These are always either local, or handled through a local\n+\t PLT.  */\n+      if (ret_value)\n+\tc = gen_call_value_fdpicsi (rvrtx, addr, operands[1],\n+\t\t\t\t    operands[2], picreg, lr);\n+      else\n+\tc = gen_call_fdpicsi (addr, operands[1], operands[2], picreg, lr);\n+      emit_call_insn (c);\n+      return;\n+    }\n+  else if (! ldd_address_operand (addr, Pmode))\n+    addr = force_reg (Pmode, addr);\n+\n+  picreg = gen_reg_rtx (DImode);\n+  emit_insn (gen_movdi_ldd (picreg, addr));\n+\n+  if (ret_value)\n+    c = gen_call_value_fdpicdi (rvrtx, picreg, const0_rtx, lr);\n+  else\n+    c = gen_call_fdpicdi (picreg, const0_rtx, lr);\n+  emit_call_insn (c);\n }\n \n+/* An address operand that may use a pair of registers, an addressing\n+   mode that we reject in general.  */\n+\n+int\n+ldd_address_operand (rtx x, enum machine_mode mode)\n+{\n+  if (GET_MODE (x) != mode && GET_MODE (x) != VOIDmode)\n+    return FALSE;\n+\n+  return frv_legitimate_address_p (DImode, x, reload_completed, FALSE, TRUE);\n+}\n+\n+int\n+fdpic_fptr_operand (rtx op, enum machine_mode mode)\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+  if (REGNO (op) != FDPIC_FPTR_REGNO && REGNO (op) < FIRST_PSEUDO_REGISTER)\n+    return FALSE;\n+  return TRUE;\n+}\n \f\n /* Return 1 is OP is a memory operand, or will be turned into one by\n    reload.  */\n@@ -3456,6 +3688,9 @@ gpr_or_int12_operand (rtx op, enum machine_mode mode)\n   if (GET_CODE (op) == CONST_INT)\n     return IN_RANGE_P (INTVAL (op), -2048, 2047);\n \n+  if (got12_operand (op, mode))\n+    return true;\n+\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n     return FALSE;\n \n@@ -3638,7 +3873,7 @@ uint1_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n    to load up and can be split into sethi/setlo instructions..  */\n \n int\n-int_2word_operand(rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+int_2word_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT value;\n   REAL_VALUE_TYPE rv;\n@@ -3650,13 +3885,24 @@ int_2word_operand(rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n       break;\n \n     case LABEL_REF:\n+      if (TARGET_FDPIC)\n+\treturn FALSE;\n+      \n       return (flag_pic == 0);\n \n     case CONST:\n-      /* small data references are already 1 word */\n-      return (flag_pic == 0) && (! const_small_data_p (op));\n+      if (flag_pic || TARGET_FDPIC)\n+\treturn FALSE;\n+\n+      op = XEXP (op, 0);\n+      if (GET_CODE (op) == PLUS && GET_CODE (XEXP (op, 1)) == CONST_INT)\n+\top = XEXP (op, 0);\n+      return GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF;\n \n     case SYMBOL_REF:\n+      if (TARGET_FDPIC)\n+\treturn FALSE;\n+      \n       /* small data references are already 1 word */\n       return (flag_pic == 0) && (! SYMBOL_REF_SMALL_P (op));\n \n@@ -3682,85 +3928,6 @@ int_2word_operand(rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   return FALSE;\n }\n \n-/* Return 1 if operand is the pic address register.  */\n-int\n-pic_register_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (! flag_pic)\n-    return FALSE;\n-\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  if (REGNO (op) != PIC_REGNO)\n-    return FALSE;\n-\n-  return TRUE;\n-}\n-\n-/* Return 1 if operand is a symbolic reference when a PIC option is specified\n-   that takes 3 separate instructions to form.  */\n-\n-int\n-pic_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (! flag_pic)\n-    return FALSE;\n-\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      break;\n-\n-    case LABEL_REF:\n-      return TRUE;\n-\n-    case SYMBOL_REF:\n-      /* small data references are already 1 word */\n-      return ! SYMBOL_REF_SMALL_P (op);\n-\n-    case CONST:\n-      /* small data references are already 1 word */\n-      return ! const_small_data_p (op);\n-    }\n-\n-  return FALSE;\n-}\n-\n-/* Return 1 if operand is the small data register.  */\n-int\n-small_data_register_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != REG)\n-    return FALSE;\n-\n-  if (REGNO (op) != SDA_BASE_REG)\n-    return FALSE;\n-\n-  return TRUE;\n-}\n-\n-/* Return 1 if operand is a symbolic reference to a small data area static or\n-   global object.  */\n-\n-int\n-small_data_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    default:\n-      break;\n-\n-    case CONST:\n-      return const_small_data_p (op);\n-\n-    case SYMBOL_REF:\n-      return SYMBOL_REF_SMALL_P (op);\n-    }\n-\n-  return FALSE;\n-}\n-\n /* Return 1 if operand is a 16 bit unsigned immediate.  */\n \n int\n@@ -4103,7 +4270,7 @@ dbl_memory_one_insn_operand (rtx op, enum machine_mode mode)\n       if (GET_CODE (addr0) != REG)\n \treturn FALSE;\n \n-      if (plus_small_data_p (addr0, addr1))\n+      if (got12_operand (addr1, VOIDmode))\n \treturn TRUE;\n \n       if (GET_CODE (addr1) != CONST_INT)\n@@ -4164,7 +4331,7 @@ move_destination_operand (rtx op, enum machine_mode mode)\n       code = GET_CODE (subreg);\n       if (code == MEM)\n \treturn frv_legitimate_address_p (mode, XEXP (subreg, 0),\n-\t\t\t\t\t reload_completed, FALSE);\n+\t\t\t\t\t reload_completed, FALSE, FALSE);\n \n       return (code == REG);\n \n@@ -4184,6 +4351,53 @@ move_destination_operand (rtx op, enum machine_mode mode)\n   return FALSE;\n }\n \n+/* Look for a SYMBOL_REF of a function in an rtx.  We always want to\n+   process these separately from any offsets, such that we add any\n+   offsets to the function descriptor (the actual pointer), not to the\n+   function address.  */\n+\n+static bool\n+frv_function_symbol_referenced_p (rtx x)\n+{\n+  const char *format;\n+  int length;\n+  int j;\n+\n+  if (GET_CODE (x) == SYMBOL_REF)\n+    return SYMBOL_REF_FUNCTION_P (x);\n+\n+  length = GET_RTX_LENGTH (GET_CODE (x));\n+  format = GET_RTX_FORMAT (GET_CODE (x));\n+\n+  for (j = 0; j < length; ++j)\n+    {\n+      switch (format[j])\n+\t{\n+\tcase 'e':\n+\t  if (frv_function_symbol_referenced_p (XEXP (x, j)))\n+\t    return TRUE;\n+\t  break;\n+\n+\tcase 'V':\n+\tcase 'E':\n+\t  if (XVEC (x, j) != 0)\n+\t    {\n+\t      int k;\n+\t      for (k = 0; k < XVECLEN (x, j); ++k)\n+\t\tif (frv_function_symbol_referenced_p (XVECEXP (x, j, k)))\n+\t\t  return TRUE;\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  /* Nothing to do.  */\n+\t  break;\n+\t}\n+    }\n+\n+  return FALSE;\n+}\n+\n /* Return true if operand is something that can be an input for a move\n    operation.  */\n \n@@ -4200,9 +4414,6 @@ move_source_operand (rtx op, enum machine_mode mode)\n \n     case CONST_INT:\n     case CONST_DOUBLE:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-    case CONST:\n       return immediate_operand (op, mode);\n \n     case SUBREG:\n@@ -4213,7 +4424,7 @@ move_source_operand (rtx op, enum machine_mode mode)\n       code = GET_CODE (subreg);\n       if (code == MEM)\n \treturn frv_legitimate_address_p (mode, XEXP (subreg, 0),\n-\t\t\t\t\t reload_completed, FALSE);\n+\t\t\t\t\t reload_completed, FALSE, FALSE);\n \n       return (code == REG);\n \n@@ -4255,7 +4466,7 @@ condexec_dest_operand (rtx op, enum machine_mode mode)\n       code = GET_CODE (subreg);\n       if (code == MEM)\n \treturn frv_legitimate_address_p (mode, XEXP (subreg, 0),\n-\t\t\t\t\t reload_completed, TRUE);\n+\t\t\t\t\t reload_completed, TRUE, FALSE);\n \n       return (code == REG);\n \n@@ -4301,7 +4512,7 @@ condexec_source_operand (rtx op, enum machine_mode mode)\n       code = GET_CODE (subreg);\n       if (code == MEM)\n \treturn frv_legitimate_address_p (mode, XEXP (subreg, 0),\n-\t\t\t\t\t reload_completed, TRUE);\n+\t\t\t\t\t reload_completed, TRUE, FALSE);\n \n       return (code == REG);\n \n@@ -4364,6 +4575,53 @@ lr_operand (rtx op, enum machine_mode mode)\n   return TRUE;\n }\n \n+/* Return true if operand is the uClinux PIC register.  */\n+\n+int\n+fdpic_operand (rtx op, enum machine_mode mode)\n+{\n+  if (!TARGET_FDPIC)\n+    return FALSE;\n+\n+  if (GET_CODE (op) != REG)\n+    return FALSE;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return FALSE;\n+\n+  if (REGNO (op) != FDPIC_REGNO && REGNO (op) < FIRST_PSEUDO_REGISTER)\n+    return FALSE;\n+\n+  return TRUE;\n+}\n+\n+int\n+got12_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  struct frv_unspec unspec;\n+\n+  if (frv_const_unspec_p (op, &unspec))\n+    switch (unspec.reloc)\n+      {\n+      case R_FRV_GOT12:\n+      case R_FRV_GOTOFF12:\n+      case R_FRV_FUNCDESC_GOT12:\n+      case R_FRV_FUNCDESC_GOTOFF12:\n+      case R_FRV_GPREL12:\n+\treturn true;\n+      }\n+  return false;\n+}\n+\n+/* Return true if OP is a valid const-unspec expression.  */\n+\n+int\n+const_unspec_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  struct frv_unspec unspec;\n+\n+  return frv_const_unspec_p (op, &unspec);\n+}\n /* Return true if operand is a gpr register or a valid memory operation.  */\n \n int\n@@ -4939,7 +5197,7 @@ condexec_memory_operand (rtx op, enum machine_mode mode)\n   if (GET_CODE (addr) == ADDRESSOF)\n     return TRUE;\n \n-  return frv_legitimate_address_p (mode, addr, reload_completed, TRUE);\n+  return frv_legitimate_address_p (mode, addr, reload_completed, TRUE, FALSE);\n }\n \n /* Return true if operator is an integer binary operator that can be combined\n@@ -5133,6 +5391,9 @@ int\n frv_emit_movsi (rtx dest, rtx src)\n {\n   int base_regno = -1;\n+  int unspec = 0;\n+  rtx sym = src;\n+  struct frv_unspec old_unspec;\n \n   if (!reload_in_progress\n       && !reload_completed\n@@ -5157,22 +5418,142 @@ frv_emit_movsi (rtx dest, rtx src)\n       break;\n \n     case LABEL_REF:\n-      if (flag_pic)\n+    handle_label:\n+      if (TARGET_FDPIC)\n+\t{\n+\t  /* Using GPREL12, we use a single GOT entry for all symbols\n+\t     in read-only sections, but trade sequences such as:\n+\n+\t     sethi #gothi(label), gr#\n+\t     setlo #gotlo(label), gr#\n+\t     ld    @(gr15,gr#), gr#\n+\n+\t     for\n+\n+\t     ld    @(gr15,#got12(_gp)), gr#\n+\t     sethi #gprelhi(label), gr##\n+\t     setlo #gprello(label), gr##\n+\t     add   gr#, gr##, gr##\n+\n+\t     We may often be able to share gr# for multiple\n+\t     computations of GPREL addresses, and we may often fold\n+\t     the final add into the pair of registers of a load or\n+\t     store instruction, so it's often profitable.  Even when\n+\t     optimizing for size, we're trading a GOT entry for an\n+\t     additional instruction, which trades GOT space\n+\t     (read-write) for code size (read-only, shareable), as\n+\t     long as the symbol is not used in more than two different\n+\t     locations.\n+\t     \n+\t     With -fpie/-fpic, we'd be trading a single load for a\n+\t     sequence of 4 instructions, because the offset of the\n+\t     label can't be assumed to be addressible with 12 bits, so\n+\t     we don't do this.  */\n+\t  if (TARGET_GPREL_RO)\n+\t    unspec = R_FRV_GPREL12;\n+\t  else\n+\t    unspec = R_FRV_GOT12;\n+\t}\n+      else if (flag_pic)\n \tbase_regno = PIC_REGNO;\n \n       break;\n \n     case CONST:\n-      if (const_small_data_p (src))\n-\tbase_regno = SDA_BASE_REG;\n-\n-      else if (flag_pic)\n-\tbase_regno = PIC_REGNO;\n+      if (frv_const_unspec_p (src, &old_unspec))\n+\tbreak;\n \n+      if (TARGET_FDPIC && frv_function_symbol_referenced_p (XEXP (src, 0)))\n+\t{\n+\thandle_whatever:\n+\t  src = force_reg (GET_MODE (XEXP (src, 0)), XEXP (src, 0));\n+\t  emit_move_insn (dest, src);\n+\t  return TRUE;\n+\t}\n+      else\n+\t{\n+\t  sym = XEXP (sym, 0);\n+\t  if (GET_CODE (sym) == PLUS\n+\t      && GET_CODE (XEXP (sym, 0)) == SYMBOL_REF\n+\t      && GET_CODE (XEXP (sym, 1)) == CONST_INT)\n+\t    sym = XEXP (sym, 0);\n+\t  if (GET_CODE (sym) == SYMBOL_REF)\n+\t    goto handle_sym;\n+\t  else if (GET_CODE (sym) == LABEL_REF)\n+\t    goto handle_label;\n+\t  else\n+\t    goto handle_whatever;\n+\t}\n       break;\n \n     case SYMBOL_REF:\n-      if (SYMBOL_REF_SMALL_P (src))\n+    handle_sym:\n+      if (TARGET_FDPIC)\n+\t{\n+\t  if (SYMBOL_REF_FUNCTION_P (sym))\n+\t    {\n+\t      if (frv_local_funcdesc_p (sym))\n+\t\tunspec = R_FRV_FUNCDESC_GOTOFF12;\n+\t      else\n+\t\tunspec = R_FRV_FUNCDESC_GOT12;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (CONSTANT_POOL_ADDRESS_P (sym))\n+\t\tswitch (GET_CODE (get_pool_constant (sym)))\n+\t\t  {\n+\t\t  case CONST:\n+\t\t  case SYMBOL_REF:\n+\t\t  case LABEL_REF:\n+\t\t    if (flag_pic)\n+\t\t      {\n+\t\t\tunspec = R_FRV_GOTOFF12;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t    /* Fall through.  */\n+\t\t  default:\n+\t\t    if (TARGET_GPREL_RO)\n+\t\t      unspec = R_FRV_GPREL12;\n+\t\t    else\n+\t\t      unspec = R_FRV_GOT12;\n+\t\t    break;\n+\t\t  }\n+\t      else if (SYMBOL_REF_LOCAL_P (sym)\n+\t\t       && !SYMBOL_REF_EXTERNAL_P (sym)\n+\t\t       && SYMBOL_REF_DECL (sym)\n+\t\t       && (!DECL_P (SYMBOL_REF_DECL (sym))\n+\t\t\t   || !DECL_COMMON (SYMBOL_REF_DECL (sym))))\n+\t\t{\n+\t\t  tree decl = SYMBOL_REF_DECL (sym);\n+\t\t  tree init = TREE_CODE (decl) == VAR_DECL\n+\t\t    ? DECL_INITIAL (decl)\n+\t\t    : TREE_CODE (decl) == CONSTRUCTOR\n+\t\t    ? decl : 0;\n+\t\t  int reloc = 0;\n+\t\t  bool named_section, readonly;\n+\n+\t\t  if (init && init != error_mark_node)\n+\t\t    reloc = compute_reloc_for_constant (init);\n+\t\t  \n+\t\t  named_section = TREE_CODE (decl) == VAR_DECL\n+\t\t    && lookup_attribute (\"section\", DECL_ATTRIBUTES (decl));\n+\t\t  readonly = decl_readonly_section (decl, reloc);\n+\t\t  \n+\t\t  if (named_section)\n+\t\t    unspec = R_FRV_GOT12;\n+\t\t  else if (!readonly)\n+\t\t    unspec = R_FRV_GOTOFF12;\n+\t\t  else if (readonly && TARGET_GPREL_RO)\n+\t\t    unspec = R_FRV_GPREL12;\n+\t\t  else\n+\t\t    unspec = R_FRV_GOT12;\n+\t\t}\n+\t      else\n+\t\tunspec = R_FRV_GOT12;\n+\t    }\n+\t}\n+\n+      else if (SYMBOL_REF_SMALL_P (sym))\n \tbase_regno = SDA_BASE_REG;\n \n       else if (flag_pic)\n@@ -5183,17 +5564,65 @@ frv_emit_movsi (rtx dest, rtx src)\n \n   if (base_regno >= 0)\n     {\n-      emit_insn (gen_rtx_SET (VOIDmode, dest,\n-\t\t\t      gen_rtx_PLUS (Pmode,\n-\t\t\t\t\t    gen_rtx_REG (Pmode, base_regno),\n-\t\t\t\t\t    src)));\n-\n+      if (GET_CODE (sym) == SYMBOL_REF && SYMBOL_REF_SMALL_P (sym))\n+\temit_insn (gen_symGOTOFF2reg (dest, src,\n+\t\t\t\t      gen_rtx_REG (Pmode, base_regno),\n+\t\t\t\t      GEN_INT (R_FRV_GPREL12)));\n+      else\n+\temit_insn (gen_symGOTOFF2reg_hilo (dest, src,\n+\t\t\t\t\t   gen_rtx_REG (Pmode, base_regno),\n+\t\t\t\t\t   GEN_INT (R_FRV_GPREL12)));\n       if (base_regno == PIC_REGNO)\n \tcfun->uses_pic_offset_table = TRUE;\n+      return TRUE;\n+    }\n \n+  if (unspec)\n+    {\n+      rtx x;\n+\n+      /* Since OUR_FDPIC_REG is a pseudo register, we can't safely introduce\n+\t new uses of it once reload has begun.  */\n+      if (reload_in_progress || reload_completed)\n+\tabort ();\n+\n+      switch (unspec)\n+\t{\n+\tcase R_FRV_GOTOFF12:\n+\t  if (!frv_small_data_reloc_p (sym, unspec))\n+\t    x = gen_symGOTOFF2reg_hilo (dest, src, OUR_FDPIC_REG,\n+\t\t\t\t\tGEN_INT (unspec));\n+\t  else\n+\t    x = gen_symGOTOFF2reg (dest, src, OUR_FDPIC_REG, GEN_INT (unspec));\n+\t  break;\n+\tcase R_FRV_GPREL12:\n+\t  if (!frv_small_data_reloc_p (sym, unspec))\n+\t    x = gen_symGPREL2reg_hilo (dest, src, OUR_FDPIC_REG,\n+\t\t\t\t       GEN_INT (unspec));\n+\t  else\n+\t    x = gen_symGPREL2reg (dest, src, OUR_FDPIC_REG, GEN_INT (unspec));\n+\t  break;\n+\tcase R_FRV_FUNCDESC_GOTOFF12:\n+\t  if (flag_pic != 1)\n+\t    x = gen_symGOTOFF2reg_hilo (dest, src, OUR_FDPIC_REG,\n+\t\t\t\t\tGEN_INT (unspec));\n+\t  else\n+\t    x = gen_symGOTOFF2reg (dest, src, OUR_FDPIC_REG, GEN_INT (unspec));\n+\t  break;\n+\tdefault:\n+\t  if (flag_pic != 1)\n+\t    x = gen_symGOT2reg_hilo (dest, src, OUR_FDPIC_REG,\n+\t\t\t\t     GEN_INT (unspec));\n+\t  else\n+\t    x = gen_symGOT2reg (dest, src, OUR_FDPIC_REG, GEN_INT (unspec));\n+\t  break;\n+\t}\n+      emit_insn (x);\n+      cfun->uses_pic_offset_table = TRUE;\n       return TRUE;\n     }\n \n+\n   return FALSE;\n }\n \n@@ -5280,11 +5709,6 @@ output_move_single (rtx operands[], rtx insn)\n \t\t   || GET_CODE (src) == LABEL_REF\n \t\t   || GET_CODE (src) == CONST)\n \t    {\n-\t      /* Silently fix up instances where the small data pointer is not\n-                 used in the address.  */\n-\t      if (small_data_symbolic_operand (src, GET_MODE (src)))\n-\t\treturn \"addi %@, #gprel12(%1), %0\";\n-\n \t      return \"#\";\n \t    }\n \t}\n@@ -6794,17 +7218,14 @@ frv_ifcvt_rewrite_mem (rtx mem, enum machine_mode mode, rtx insn)\n {\n   rtx addr = XEXP (mem, 0);\n \n-  if (!frv_legitimate_address_p (mode, addr, reload_completed, TRUE))\n+  if (!frv_legitimate_address_p (mode, addr, reload_completed, TRUE, FALSE))\n     {\n       if (GET_CODE (addr) == PLUS)\n \t{\n \t  rtx addr_op0 = XEXP (addr, 0);\n \t  rtx addr_op1 = XEXP (addr, 1);\n \n-\t  if (plus_small_data_p (addr_op0, addr_op1))\n-\t    addr = frv_ifcvt_load_value (addr, insn);\n-\n-\t  else if (GET_CODE (addr_op0) == REG && CONSTANT_P (addr_op1))\n+\t  if (GET_CODE (addr_op0) == REG && CONSTANT_P (addr_op1))\n \t    {\n \t      rtx reg = frv_ifcvt_load_value (addr_op1, insn);\n \t      if (!reg)\n@@ -6957,18 +7378,7 @@ frv_ifcvt_modify_insn (ce_if_block_t *ce_info,\n \t  op0 = XEXP (src, 0);\n \t  op1 = XEXP (src, 1);\n \n-\t  /* Special case load of small data address which looks like:\n-\t     r16+symbol_ref */\n-\t  if (GET_CODE (src) == PLUS && plus_small_data_p (op0, op1))\n-\t    {\n-\t      src = frv_ifcvt_load_value (src, insn);\n-\t      if (src)\n-\t\tCOND_EXEC_CODE (pattern) = gen_rtx_SET (VOIDmode, dest, src);\n-\t      else\n-\t\tgoto fail;\n-\t    }\n-\n-\t  else if (integer_register_operand (op0, SImode) && CONSTANT_P (op1))\n+\t  if (integer_register_operand (op0, SImode) && CONSTANT_P (op1))\n \t    {\n \t      op1 = frv_ifcvt_load_value (op1, insn);\n \t      if (op1)\n@@ -7241,7 +7651,11 @@ frv_ifcvt_modify_cancel (ce_if_block_t *ce_info ATTRIBUTE_UNUSED)\n int\n frv_trampoline_size (void)\n {\n-  return 5 /* instructions */ * 4 /* instruction size */;\n+  if (TARGET_FDPIC)\n+    /* Allocate room for the function descriptor and the lddi\n+       instruction.  */\n+    return 8 + 6 * 4;\n+  return 5 /* instructions */ * 4 /* instruction size.  */;\n }\n \n \f\n@@ -7697,6 +8111,22 @@ frv_legitimate_constant_p (rtx x)\n {\n   enum machine_mode mode = GET_MODE (x);\n \n+  /* frv_cannot_force_const_mem always returns true for FDPIC.  This\n+     means that the move expanders will be expected to deal with most\n+     kinds of constant, regardless of what we return here.\n+\n+     However, among its other duties, LEGITIMATE_CONSTANT_P decides whether\n+     a constant can be entered into reg_equiv_constant[].  If we return true,\n+     reload can create new instances of the constant whenever it likes.\n+\n+     The idea is therefore to accept as many constants as possible (to give\n+     reload more freedom) while rejecting constants that can only be created\n+     at certain times.  In particular, anything with a symbolic component will\n+     require use of the pseudo FDPIC register, which is only available before\n+     reload.  */\n+  if (TARGET_FDPIC)\n+    return LEGITIMATE_PIC_OPERAND_P (x);\n+\n   /* All of the integer constants are ok.  */\n   if (GET_CODE (x) != CONST_DOUBLE)\n     return TRUE;\n@@ -7833,13 +8263,24 @@ frv_register_move_cost (enum reg_class from, enum reg_class to)\n static bool\n frv_assemble_integer (rtx value, unsigned int size, int aligned_p)\n {\n-  if (flag_pic && size == UNITS_PER_WORD)\n+  if ((flag_pic || TARGET_FDPIC) && size == UNITS_PER_WORD)\n     {\n       if (GET_CODE (value) == CONST\n \t  || GET_CODE (value) == SYMBOL_REF\n \t  || GET_CODE (value) == LABEL_REF)\n \t{\n-\t  if (aligned_p)\n+\t  if (TARGET_FDPIC && GET_CODE (value) == SYMBOL_REF\n+\t      && SYMBOL_REF_FUNCTION_P (value))\n+\t    {\n+\t      fputs (\"\\t.picptr\\tfuncdesc(\", asm_out_file);\n+\t      output_addr_const (asm_out_file, value);\n+\t      fputs (\")\\n\", asm_out_file);\n+\t      return true;\n+\t    }\n+\t  else if (TARGET_FDPIC && GET_CODE (value) == CONST\n+\t\t   && frv_function_symbol_referenced_p (value))\n+\t    return false;\n+\t  if (aligned_p && !TARGET_FDPIC)\n \t    {\n \t      static int label_num = 0;\n \t      char buf[256];\n@@ -9433,6 +9874,14 @@ frv_rtx_costs (rtx x,\n                int outer_code ATTRIBUTE_UNUSED,\n                int *total)\n {\n+  if (outer_code == MEM)\n+    {\n+      /* Don't differentiate between memory addresses.  All the ones\n+\t we accept have equal cost.  */\n+      *total = COSTS_N_INSNS (0);\n+      return true;\n+    }\n+\n   switch (code)\n     {\n     case CONST_INT:\n@@ -9484,6 +9933,10 @@ frv_rtx_costs (rtx x,\n       *total = COSTS_N_INSNS (18);\n       return true;\n \n+    case MEM:\n+      *total = COSTS_N_INSNS (3);\n+      return true;\n+\n     default:\n       return false;\n     }\n@@ -9494,6 +9947,12 @@ frv_asm_out_constructor (rtx symbol, int priority ATTRIBUTE_UNUSED)\n {\n   ctors_section ();\n   assemble_align (POINTER_SIZE);\n+  if (TARGET_FDPIC)\n+    {\n+      if (!frv_assemble_integer (symbol, POINTER_SIZE / BITS_PER_UNIT, 1))\n+\tabort ();\n+      return;\n+    }\n   assemble_integer_with_op (\"\\t.picptr\\t\", symbol);\n }\n \n@@ -9502,6 +9961,12 @@ frv_asm_out_destructor (rtx symbol, int priority ATTRIBUTE_UNUSED)\n {\n   dtors_section ();\n   assemble_align (POINTER_SIZE);\n+  if (TARGET_FDPIC)\n+    {\n+      if (!frv_assemble_integer (symbol, POINTER_SIZE / BITS_PER_UNIT, 1))\n+\tabort ();\n+      return;\n+    }\n   assemble_integer_with_op (\"\\t.picptr\\t\", symbol);\n }\n "}, {"sha": "cfcab0ea35086386e4de49ece63e08b2599db4b3", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 148, "deletions": 46, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=34208acf14fa026ae391a819525d20b48af5c2bf", "patch": "@@ -62,6 +62,32 @@\n    Defined in svr4.h.  */\n #undef WORD_SWITCH_TAKES_ARG\n \n+/* -fpic and -fPIC used to imply the -mlibrary-pic multilib, but with\n+    FDPIC which multilib to use depends on whether FDPIC is in use or\n+    not.  The trick we use is to introduce -multilib-library-pic as a\n+    pseudo-flag that selects the library-pic multilib, and map fpic\n+    and fPIC to it only if fdpic is not selected.  Also, if fdpic is\n+    selected and no PIC/PIE options are present, we imply -fPIE.\n+    Otherwise, if -fpic or -fPIC are enabled and we're optimizing for\n+    speed, or if we have -On with n>=3, enable inlining of PLTs.  As\n+    for -mgprel-ro, we want to enable it by default, but not for -fpic or\n+    -fpie.  */\n+\n+#define DRIVER_SELF_SPECS SUBTARGET_DRIVER_SELF_SPECS \\\n+\"%{mno-pack:\\\n+   %{!mhard-float:-msoft-float}\\\n+   %{!mmedia:-mno-media}}\\\n+ %{!mfdpic:%{fpic|fPIC: -multilib-library-pic}}\\\n+ %{mfdpic:%{!fpic:%{!fpie:%{!fPIC:%{!fPIE:\\\n+   \t    %{!fno-pic:%{!fno-pie:%{!fno-PIC:%{!fno-PIE:-fPIE}}}}}}}} \\\n+\t  %{!mno-inline-plt:%{O*:%{!O0:%{!Os:%{fpic|fPIC:-minline-plt} \\\n+                    %{!fpic:%{!fPIC:%{!O:%{!O1:%{!O2:-minline-plt}}}}}}}}} \\\n+\t  %{!mno-gprel-ro:%{!fpic:%{!fpie:-mgprel-ro}}}} \\\n+\"\n+#ifndef SUBTARGET_DRIVER_SELF_SPECS\n+# define SUBTARGET_DRIVER_SELF_SPECS\n+#endif\n+\n /* A C string constant that tells the GCC driver program options to pass to\n    the assembler.  It can also specify how to translate options you give to GNU\n    CC into options for GCC to pass to the assembler.  See the file `sun3.h'\n@@ -83,6 +109,7 @@\n     %{mmedia} %{mno-media} \\\n     %{mmuladd} %{mno-muladd} \\\n     %{mpack} %{mno-pack} \\\n+    %{mfdpic} \\\n     %{fpic|fpie: -mpic} %{fPIC|fPIE: -mPIC} %{mlibrary-pic}}\"\n \n /* Another C string constant used much like `LINK_SPEC'.  The difference\n@@ -222,6 +249,7 @@\n #define LINK_SPEC \"\\\n %{h*} %{v:-V} \\\n %{b} %{Wl,*:%*} \\\n+%{mfdpic:-melf32frvfd -z text} \\\n %{static:-dn -Bstatic} \\\n %{shared:-Bdynamic} \\\n %{symbolic:-Bsymbolic} \\\n@@ -282,6 +310,9 @@\n     {\t\t\t\t\t\t\\\n       builtin_define (\"__frv__\");\t\t\\\n       builtin_assert (\"machine=frv\");\t\t\\\n+\t\t\t\t\t\t\\\n+      if (TARGET_FDPIC)\t\t\t\t\\\n+\tbuiltin_define (\"__FRV_FDPIC__\");\t\\\n     }\t\t\t\t\t\t\\\n   while (0)\n \n@@ -317,6 +348,7 @@ extern int target_flags;\n #define MASK_LIBPIC\t     0x00000100\t/* -fpic that can be linked w/o pic */\n #define MASK_ACC_4\t     0x00000200\t/* Only use four media accumulators */\n #define MASK_PACK\t     0x00000400 /* Set to enable packed output */\n+#define MASK_LINKED_FP\t     0x00002000 /* Follow ABI linkage requirements.  */\n \n \t\t\t \t\t/* put debug masks up high */\n #define MASK_DEBUG_ARG\t     0x40000000\t/* debug argument handling */\n@@ -331,6 +363,9 @@ extern int target_flags;\n #define MASK_NO_VLIW_BRANCH  0x00200000\t/* disable repacking branches */\n #define MASK_NO_MULTI_CE     0x00100000\t/* disable multi-level cond exec */\n #define MASK_NO_NESTED_CE    0x00080000\t/* disable nested cond exec */\n+#define MASK_FDPIC           0x00040000\t/* Follow the new uClinux ABI.  */\n+#define MASK_INLINE_PLT      0x00020000 /* Inline FDPIC PLTs.  */\n+#define MASK_GPREL_RO\t     0x00010000 /* Use GPREL for read-only data.  */\n \n #define MASK_DEFAULT\t\tMASK_DEFAULT_ALLOC_CC\n \n@@ -356,7 +391,11 @@ extern int target_flags;\n #define TARGET_NO_VLIW_BRANCH\t((target_flags & MASK_NO_VLIW_BRANCH) != 0)\n #define TARGET_NO_MULTI_CE\t((target_flags & MASK_NO_MULTI_CE) != 0)\n #define TARGET_NO_NESTED_CE\t((target_flags & MASK_NO_NESTED_CE) != 0)\n+#define TARGET_FDPIC\t        ((target_flags & MASK_FDPIC) != 0)\n+#define TARGET_INLINE_PLT\t((target_flags & MASK_INLINE_PLT) != 0)\n+#define TARGET_GPREL_RO\t\t((target_flags & MASK_GPREL_RO) != 0)\n #define TARGET_PACK\t\t((target_flags & MASK_PACK) != 0)\n+#define TARGET_LINKED_FP\t((target_flags & MASK_LINKED_FP) != 0)\n \n #define TARGET_GPR_64\t\t(! TARGET_GPR_32)\n #define TARGET_FPR_64\t\t(! TARGET_FPR_32)\n@@ -436,6 +475,7 @@ extern int target_flags;\n  { \"no-media\",\t\t -MASK_MEDIA,\t\t\"Do not use media insns\" }, \\\n  { \"muladd\",\t\t  MASK_MULADD,\t\t\"Use multiply add/subtract instructions\" }, \\\n  { \"no-muladd\",\t\t -MASK_MULADD,\t\t\"Do not use multiply add/subtract insns\" }, \\\n+ { \"ultilib-library-pic\", 0,\t\t\t\"Link with the library-pic libraries\" }, \\\n  { \"library-pic\",\t  MASK_LIBPIC,\t\t\"PIC support for building libraries\" }, \\\n  { \"acc-4\",\t\t  MASK_ACC_4,\t\t\"Use 4 media accumulators\" }, \\\n  { \"acc-8\",\t\t -MASK_ACC_4,\t\t\"Use 8 media accumulators\" }, \\\n@@ -460,6 +500,14 @@ extern int target_flags;\n  { \"no-multi-cond-exec\",  MASK_NO_MULTI_CE,\t\"Enable optimizing &&/|| in conditional execution\" }, \\\n  { \"nested-cond-exec\",\t -MASK_NO_NESTED_CE,\t\"Enable nested conditional execution optimizations\" }, \\\n  { \"no-nested-cond-exec\" ,MASK_NO_NESTED_CE,\t\"Disable nested conditional execution optimizations\" }, \\\n+ { \"linked-fp\",\t\t  MASK_LINKED_FP,\t\"Follow the EABI linkage requirements\" }, \\\n+ { \"no-linked-fp\",\t -MASK_LINKED_FP,\t\"Don't follow the EABI linkage requirements\" }, \\\n+ { \"fdpic\",\t          MASK_FDPIC,\t\t\"Enable file descriptor PIC mode\" }, \\\n+ { \"no-fdpic\",\t         -MASK_FDPIC,\t\t\"Disable file descriptor PIC mode\" }, \\\n+ { \"inline-plt\",\t  MASK_INLINE_PLT,\t\"Enable inlining of PLT in function calls\" }, \\\n+ { \"no-inline-plt\",\t -MASK_INLINE_PLT,\t\"Disable inlining of PLT in function calls\" }, \\\n+ { \"gprel-ro\",\t\t  MASK_GPREL_RO,\t\"Enable use of GPREL for read-only data in FDPIC\" }, \\\n+ { \"no-gprel-ro\",\t -MASK_GPREL_RO,\t\"Disable use of GPREL for read-only data in FDPIC\" }, \\\n  { \"tomcat-stats\",\t  0, \t\t\t\"Cause gas to print tomcat statistics\" }, \\\n  { \"\",\t\t\t  MASK_DEFAULT,\t\t\"\" }}\t\t\t    \\\n \n@@ -764,8 +812,12 @@ extern int target_flags;\n #define GPR_FP          (GPR_FIRST + 2)         /* Frame pointer */\n #define GPR_SP          (GPR_FIRST + 1)         /* Stack pointer */\n \t\t\t\t\t\t/* small data register */\n-#define SDA_BASE_REG    ((unsigned)(flag_pic ? PIC_REGNO : (GPR_FIRST+16)))\n-#define PIC_REGNO       (GPR_FIRST + 17)        /* PIC register */\n+#define SDA_BASE_REG    ((unsigned)(TARGET_FDPIC ? -1 : flag_pic ? PIC_REGNO : (GPR_FIRST + 16)))\n+#define PIC_REGNO       (GPR_FIRST + (TARGET_FDPIC?15:17))        /* PIC register.  */\n+#define FDPIC_FPTR_REGNO  (GPR_FIRST + 14)        /* uClinux PIC function pointer register.  */\n+#define FDPIC_REGNO   (GPR_FIRST + 15)        /* uClinux PIC register.  */\n+\n+#define OUR_FDPIC_REG\tget_hard_reg_initial_val (SImode, FDPIC_REGNO)\n \n #define FPR_FIRST       64\t\t\t/* First FP reg */\n #define FPR_LAST        127\t\t\t/* Last  FP reg */\n@@ -1213,6 +1265,9 @@ enum reg_class\n   CR_REGS,\n   LCR_REG,\n   LR_REG,\n+  FDPIC_REGS,\n+  FDPIC_FPTR_REGS,\n+  FDPIC_CALL_REGS,\n   SPR_REGS,\n   QUAD_ACC_REGS,\n   EVEN_ACC_REGS,\n@@ -1247,6 +1302,9 @@ enum reg_class\n    \"CR_REGS\",\t\t\t\t\t\t\t\t\\\n    \"LCR_REG\",\t\t\t\t\t\t\t\t\\\n    \"LR_REG\",\t\t\t\t\t\t\t\t\\\n+   \"FDPIC_REGS\",\t\t\t\t\t\t\t\\\n+   \"FDPIC_FPTR_REGS\",\t\t\t\t\t\t\t\\\n+   \"FDPIC_CALL_REGS\",\t\t\t\t\t\t\t\\\n    \"SPR_REGS\",\t\t\t\t\t\t\t\t\\\n    \"QUAD_ACC_REGS\",\t\t\t\t\t\t\t\\\n    \"EVEN_ACC_REGS\",\t\t\t\t\t\t\t\\\n@@ -1282,6 +1340,9 @@ enum reg_class\n   { 0x00000000,0x00000000,0x00000000,0x00000000,0x0000ff00,0x0}, /* CR_REGS  */\\\n   { 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x4}, /* LCR_REGS */\\\n   { 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x2}, /* LR_REGS  */\\\n+  { 0x00008000,0x00000000,0x00000000,0x00000000,0x00000000,0x0}, /* FDPIC_REGS */\\\n+  { 0x00004000,0x00000000,0x00000000,0x00000000,0x00000000,0x0}, /* FDPIC_FPTR_REGS */\\\n+  { 0x0000c000,0x00000000,0x00000000,0x00000000,0x00000000,0x0}, /* FDPIC_CALL_REGS */\\\n   { 0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x6}, /* SPR_REGS */\\\n   { 0x00000000,0x00000000,0x00000000,0x00000000,0x00ff0000,0x0}, /* QUAD_ACC */\\\n   { 0x00000000,0x00000000,0x00000000,0x00000000,0x00ff0000,0x0}, /* EVEN_ACC */\\\n@@ -1490,9 +1551,9 @@ extern enum reg_class reg_class_from_letter[];\n    input and `r' on the output.  The next alternative specifies `m' on the\n    input and a register class that does not include r0 on the output.  */\n \n-/* Small data references */\n+/* 12-bit relocations.  */\n #define EXTRA_CONSTRAINT_FOR_Q(VALUE)\t\t\t\t\t\\\n-  (small_data_symbolic_operand (VALUE, GET_MODE (VALUE)))\n+  (got12_operand (VALUE, GET_MODE (VALUE)))\n \n /* Double word memory ops that take one instruction.  */\n #define EXTRA_CONSTRAINT_FOR_R(VALUE)\t\t\t\t\t\\\n@@ -2102,7 +2163,7 @@ struct machine_function GTY(())\n \n    If you don't define this macro, the value of `BIGGEST_ALIGNMENT' is used for\n    aligning trampolines.  */\n-#define TRAMPOLINE_ALIGNMENT 32\n+#define TRAMPOLINE_ALIGNMENT (TARGET_FDPIC ? 64 : 32)\n \n /* A C statement to initialize the variable parts of a trampoline.  ADDR is an\n    RTX for the address of the trampoline; FNADDR is an RTX for the address of\n@@ -2129,8 +2190,11 @@ struct machine_function GTY(())\n #define TRAMPOLINE_TEMPLATE_NAME \"__trampoline_template\"\n #endif\n \n+#define Twrite _write\n+\n+#if ! __FRV_FDPIC__\n #define TRANSFER_FROM_TRAMPOLINE\t\t\t\t\t\\\n-extern int _write (int, const void *, unsigned);\t\t\t\\\n+extern int Twrite (int, const void *, unsigned);\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n void\t\t\t\t\t\t\t\t\t\\\n __trampoline_setup (short * addr, int size, int fnaddr, int sc)\t\t\\\n@@ -2142,7 +2206,7 @@ __trampoline_setup (short * addr, int size, int fnaddr, int sc)\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   if (size < 20)\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      _write (2, \"__trampoline_setup bad size\\n\",\t\t\t\\\n+      Twrite (2, \"__trampoline_setup bad size\\n\",\t\t\t\\\n \t      sizeof (\"__trampoline_setup bad size\\n\") - 1);\t\t\\\n       exit (-1);\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n@@ -2171,6 +2235,67 @@ __asm__(\"\\n\"\t\t\t\t\t\t\t\t\\\n \t\"\\tsethi #0, gr6\\n\"\t\t\t\t\t\t\\\n \t\"\\tsethi #0, gr7\\n\"\t\t\t\t\t\t\\\n \t\"\\tjmpl @(gr0,gr6)\\n\");\n+#else\n+#define TRANSFER_FROM_TRAMPOLINE\t\t\t\t\t\\\n+extern int Twrite (int, const void *, unsigned);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+__trampoline_setup (addr, size, fnaddr, sc)\t\t\t\t\\\n+     short * addr;\t\t\t\t\t\t\t\\\n+     int size;\t\t\t\t\t\t\t\t\\\n+     int fnaddr;\t\t\t\t\t\t\t\\\n+     int sc;\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  extern short __trampoline_template[];\t\t\t\t\t\\\n+  short * from = &__trampoline_template[0];\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\t\t\\\n+  short **desc = (short **)addr;\t\t\t\t\t\\\n+  short * to = addr + 4;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (size != 32)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      Twrite (2, \"__trampoline_setup bad size\\n\",\t\t\t\\\n+\t      sizeof (\"__trampoline_setup bad size\\n\") - 1);\t\t\\\n+      exit (-1);\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* Create a function descriptor with the address of the code below\n+     and NULL as the FDPIC value.  We don't need the real GOT value\n+     here, since we don't use it, so we use NULL, that is just as\n+     good.  */\t\t\t\t\t\t\t\t\\\n+  desc[0] = to;\t\t\t\t\t\t\t\t\\\n+  desc[1] = NULL;\t\t\t\t\t\t\t\\\n+  size -= 8;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  to[0] = from[0];\t\t\t\t\t\t\t\\\n+  to[1] = (short)(fnaddr);\t\t\t\t\t\t\\\n+  to[2] = from[2];\t\t\t\t\t\t\t\\\n+  to[3] = (short)(sc);\t\t\t\t\t\t\t\\\n+  to[4] = from[4];\t\t\t\t\t\t\t\\\n+  to[5] = (short)(fnaddr >> 16);\t\t\t\t\t\\\n+  to[6] = from[6];\t\t\t\t\t\t\t\\\n+  to[7] = (short)(sc >> 16);\t\t\t\t\t\t\\\n+  to[8] = from[8];\t\t\t\t\t\t\t\\\n+  to[9] = from[9];\t\t\t\t\t\t\t\\\n+  to[10] = from[10];\t\t\t\t\t\t\t\\\n+  to[11] = from[11];\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  for (i = 0; i < size; i++)\t\t\t\t\t\t\\\n+    __asm__ volatile (\"dcf @(%0,%1)\\n\\tici @(%0,%1)\" :: \"r\" (to), \"r\" (i)); \\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+__asm__(\"\\n\"\t\t\t\t\t\t\t\t\\\n+\t\"\\t.globl \" TRAMPOLINE_TEMPLATE_NAME \"\\n\"\t\t\t\\\n+\t\"\\t.text\\n\"\t\t\t\t\t\t\t\\\n+\tTRAMPOLINE_TEMPLATE_NAME \":\\n\"\t\t\t\t\t\\\n+\t\"\\tsetlos #0, gr6\\n\"\t/* Jump register.  */\t\t\t\\\n+\t\"\\tsetlos #0, gr7\\n\"\t/* Static chain.  */\t\t\t\\\n+\t\"\\tsethi #0, gr6\\n\"\t\t\t\t\t\t\\\n+\t\"\\tsethi #0, gr7\\n\"\t\t\t\t\t\t\\\n+\t\"\\tldd @(gr6,gr0),gr14\\n\"\t\t\t\t\t\\\n+\t\"\\tjmpl @(gr14,gr0)\\n\"\t\t\t\t\t\t\\\n+\t);\n+#endif\n \n \f\n /* Addressing Modes.  */\n@@ -2255,7 +2380,8 @@ __asm__(\"\\n\"\t\t\t\t\t\t\t\t\\\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      if (frv_legitimate_address_p (MODE, X, REG_OK_STRICT_P, FALSE))\t\\\n+      if (frv_legitimate_address_p (MODE, X, REG_OK_STRICT_P,\t\t\\\n+ \t\t\t\t    FALSE, FALSE))\t\t\t\\\n \tgoto LABEL;\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n@@ -2284,40 +2410,9 @@ __asm__(\"\\n\"\t\t\t\t\t\t\t\t\\\n    will reload one or both registers only if neither labeling works.  */\n #define REG_OK_FOR_INDEX_P(X) REG_OK_FOR_BASE_P (X)\n \n-/* A C compound statement that attempts to replace X with a valid memory\n-   address for an operand of mode MODE.  WIN will be a C statement label\n-   elsewhere in the code; the macro definition may use\n-\n-        GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN);\n-\n-   to avoid further processing if the address has become legitimate.\n-\n-   X will always be the result of a call to `break_out_memory_refs', and OLDX\n-   will be the operand that was given to that function to produce X.\n-\n-   The code generated by this macro should not alter the substructure of X.  If\n-   it transforms X into a more legitimate form, it should assign X (which will\n-   always be a C variable) a new value.\n-\n-   It is not necessary for this macro to come up with a legitimate address.\n-   The compiler has standard ways of doing so in all cases.  In fact, it is\n-   safe for this macro to do nothing.  But often a machine-dependent strategy\n-   can generate better code.  */\n-\n-/* On the FRV, we use it to convert small data and pic references into using\n-   the appropriate pointer in the address.  */\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      rtx newx = frv_legitimize_address (X, OLDX, MODE);\t\\\n-\t\t\t\t\t\t\t\t\\\n-      if (newx)\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  (X) = newx;\t\t\t\t\t\t\\\n-\t  goto WIN;\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\n+\n+#define FIND_BASE_TERM frv_find_base_term\n \n /* A C statement or compound statement with a conditional `goto LABEL;'\n    executed if memory address X (an RTX) can have different meanings depending\n@@ -2546,6 +2641,7 @@ fixup_section (void)\t\t\t\t\t\t\t\\\n   (   GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n    || GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\\\n    || (GET_CODE (X) == HIGH && GET_CODE (XEXP (X, 0)) == CONST_INT)\t\\\n+   || got12_operand (X, VOIDmode)\t\t\t\t\t\\\n    || GET_CODE (X) == CONSTANT_P_RTX)\n \n \f\n@@ -2996,10 +3092,11 @@ do {                                                                    \\\n   { \"int12_operand\",\t\t\t{ CONST_INT }},\t\t\t\\\n   { \"int_2word_operand\",\t\t{ CONST_INT, CONST_DOUBLE,\t\\\n \t\t\t\t\t  SYMBOL_REF, LABEL_REF, CONST }}, \\\n-  { \"pic_register_operand\",\t\t{ REG }},\t\t\t\\\n-  { \"pic_symbolic_operand\",\t\t{ SYMBOL_REF, LABEL_REF, CONST }}, \\\n-  { \"small_data_register_operand\",\t{ REG }},\t\t\t\\\n-  { \"small_data_symbolic_operand\",\t{ SYMBOL_REF, CONST }},\t\t\\\n+  { \"fdpic_operand\",\t\t\t{ REG }},\t\t\t\\\n+  { \"fdpic_fptr_operand\",\t\t{ REG }},\t\t\t\\\n+  { \"ldd_address_operand\",\t\t{ REG, SUBREG, PLUS }},\t\t\\\n+  { \"got12_operand\",\t\t\t{ CONST }},\t\t\t\\\n+  { \"const_unspec_operand\",\t\t{ CONST }},\t\t\t\\\n   { \"icc_operand\",\t\t\t{ REG }},\t\t\t\\\n   { \"fcc_operand\",\t\t\t{ REG }},\t\t\t\\\n   { \"cc_operand\",\t\t\t{ REG }},\t\t\t\\\n@@ -3302,4 +3399,9 @@ enum frv_builtins\n extern GTY(()) rtx frv_compare_op0;\t\t\t/* operand save for */\n extern GTY(()) rtx frv_compare_op1;\t\t\t/* comparison generation */\n \n+#ifdef __FRV_FDPIC__\n+#define CRT_GET_RFIB_DATA(dbase) \\\n+  ({ extern void *_GLOBAL_OFFSET_TABLE_; (dbase) = &_GLOBAL_OFFSET_TABLE_; })\n+#endif\n+\n #endif /* __FRV_H__ */"}, {"sha": "ef2b49d128c8029b34c32dedcaf36d3bd4aae316", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 318, "deletions": 61, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=34208acf14fa026ae391a819525d20b48af5c2bf", "patch": "@@ -1,5 +1,5 @@\n ;; Frv Machine Description\n-;; Copyright (C) 1999, 2000, 2001, 2004 Free Software Foundation, Inc.\n+;; Copyright (C) 1999, 2000, 2001, 2003, 2004 Free Software Foundation, Inc.\n ;; Contributed by Red Hat, Inc.\n \n ;; This file is part of GCC.\n@@ -28,14 +28,39 @@\n ;; ::\n ;; ::::::::::::::::::::\n \n+;; GOT constants must go 12/HI/LO for the splitter to work\n+\n (define_constants\n   [(UNSPEC_BLOCKAGE\t\t0)\n    (UNSPEC_CC_TO_GPR\t\t1)\n    (UNSPEC_GPR_TO_CC\t\t2)\n    (UNSPEC_PIC_PROLOGUE\t\t3)\n    (UNSPEC_CR_LOGIC\t\t4)\n    (UNSPEC_STACK_ADJUST\t\t5)\n-   (UNSPEC_EH_RETURN_EPILOGUE\t6)])\n+   (UNSPEC_EH_RETURN_EPILOGUE\t6)\n+   (UNSPEC_GOT\t\t\t7)\n+   (UNSPEC_LDD\t\t\t8)\n+\n+   (R_FRV_GOT12\t\t\t11)\n+   (R_FRV_GOTHI\t\t\t12)\n+   (R_FRV_GOTLO\t\t\t13)\n+   (R_FRV_FUNCDESC\t\t14)\n+   (R_FRV_FUNCDESC_GOT12\t15)\n+   (R_FRV_FUNCDESC_GOTHI\t16)\n+   (R_FRV_FUNCDESC_GOTLO\t17)\n+   (R_FRV_FUNCDESC_VALUE\t18)\n+   (R_FRV_FUNCDESC_GOTOFF12\t19)\n+   (R_FRV_FUNCDESC_GOTOFFHI\t20)\n+   (R_FRV_FUNCDESC_GOTOFFLO\t21)\n+   (R_FRV_GOTOFF12\t\t22)\n+   (R_FRV_GOTOFFHI\t\t23)\n+   (R_FRV_GOTOFFLO\t\t24)\n+   (R_FRV_GPREL12\t\t25)\n+   (R_FRV_GPRELHI\t\t26)\n+   (R_FRV_GPRELLO\t\t27)\n+\n+   (FDPIC_REG\t\t\t15)\n+   ])\n \n \n \f\n@@ -1317,7 +1342,7 @@\n \n (define_insn \"*movhi_internal\"\n   [(set (match_operand:HI 0 \"move_destination_operand\" \"=d,d,d,m,m,?f,?f,?d,?m,f\")\n-\t(match_operand:HI 1 \"move_source_operand\"       \"L,i,d,d,O, d, f, f, f,GO\"))]\n+\t(match_operand:HI 1 \"move_source_operand\"       \"L,n,d,d,O, d, f, f, f,GO\"))]\n   \"register_operand(operands[0], HImode) || reg_or_0_operand (operands[1], HImode)\"\n   \"* return output_move_single (operands, insn);\"\n   [(set_attr \"length\" \"4,8,4,4,4,4,4,4,4,4\")\n@@ -1385,86 +1410,69 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"gload,fload\")])\n \n-(define_insn \"*movsi_internal\"\n-  [(set (match_operand:SI 0 \"move_destination_operand\" \"=d,d,d,m,m,z,d,d,f,f,m,?f,?z\")\n-\t(match_operand:SI 1 \"move_source_operand\"      \"LQ,i,d,d,O,d,z,f,d,f,f,GO,GO\"))]\n-  \"register_operand (operands[0], SImode) || reg_or_0_operand (operands[1], SImode)\"\n-  \"* return output_move_single (operands, insn);\"\n-  [(set_attr \"length\" \"4,8,4,4,4,4,4,4,4,4,4,4,4\")\n-   (set_attr \"type\" \"int,multi,int,gstore,gstore,spr,spr,movfg,movgf,fsconv,fstore,movgf,spr\")])\n-\n-(define_insn \"*movsi_lda_sdata\"\n+(define_insn \"*movsi_got\"\n   [(set (match_operand:SI 0 \"integer_register_operand\" \"=d\")\n-\t(plus:SI (match_operand:SI 1 \"small_data_register_operand\" \"d\")\n-\t\t (match_operand:SI 2 \"small_data_symbolic_operand\" \"Q\")))]\n+\t(match_operand:SI 1 \"got12_operand\" \"\"))]\n   \"\"\n-  \"addi %1, #gprel12(%2), %0\"\n+  \"addi gr0, %1, %0\"\n   [(set_attr \"type\" \"int\")\n    (set_attr \"length\" \"4\")])\n \n-;; Split 2 word load of constants into sethi/setlo instructions\n-(define_split\n-  [(set (match_operand:SI 0 \"integer_register_operand\" \"\")\n-\t(match_operand:SI 1 \"int_2word_operand\" \"\"))]\n-  \"reload_completed\"\n-  [(set (match_dup 0)\n-\t(high:SI (match_dup 1)))\n-   (set (match_dup 0)\n-\t(lo_sum:SI (match_dup 0)\n-\t\t(match_dup 1)))]\n-  \"\")\n-\n-(define_insn \"movsi_high\"\n+(define_insn \"*movsi_high_got\"\n   [(set (match_operand:SI 0 \"integer_register_operand\" \"=d\")\n-\t(high:SI (match_operand:SI 1 \"int_2word_operand\" \"i\")))]\n+\t(high:SI (match_operand:SI 1 \"const_unspec_operand\" \"\")))]\n   \"\"\n-  \"sethi #hi(%1), %0\"\n+  \"sethi %1, %0\"\n   [(set_attr \"type\" \"sethi\")\n    (set_attr \"length\" \"4\")])\n \n-(define_insn \"movsi_lo_sum\"\n-  [(set (match_operand:SI 0 \"integer_register_operand\" \"+d\")\n-\t(lo_sum:SI (match_dup 0)\n-\t\t   (match_operand:SI 1 \"int_2word_operand\" \"i\")))]\n+(define_insn \"*movsi_lo_sum_got\"\n+  [(set (match_operand:SI 0 \"integer_register_operand\" \"=d\")\n+\t(lo_sum:SI (match_operand:SI 1 \"integer_register_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"const_unspec_operand\" \"\")))]\n   \"\"\n-  \"setlo #lo(%1), %0\"\n+  \"setlo %2, %0\"\n   [(set_attr \"type\" \"setlo\")\n    (set_attr \"length\" \"4\")])\n \n-;; Split loads of addresses with PIC specified into 3 separate instructions\n-(define_insn_and_split \"*movsi_pic\"\n+(define_insn \"*movsi_internal\"\n+  [(set (match_operand:SI 0 \"move_destination_operand\" \"=d,d,d,m,m,z,d,d,f,f,m,?f,?z\")\n+\t(match_operand:SI 1 \"move_source_operand\"      \"L,n,d,d,O,d,z,f,d,f,f,GO,GO\"))]\n+  \"register_operand (operands[0], SImode) || reg_or_0_operand (operands[1], SImode)\"\n+  \"* return output_move_single (operands, insn);\"\n+  [(set_attr \"length\" \"4,8,4,4,4,4,4,4,4,4,4,4,4\")\n+   (set_attr \"type\" \"int,multi,int,gstore,gstore,spr,spr,movfg,movgf,fsconv,fstore,movgf,spr\")])\n+\n+;; Split 2 word load of constants into sethi/setlo instructions\n+(define_insn_and_split \"*movsi_2word\"\n   [(set (match_operand:SI 0 \"integer_register_operand\" \"=d\")\n-\t(plus:SI (match_operand:SI 1 \"pic_register_operand\" \"d\")\n-\t\t (match_operand:SI 2 \"pic_symbolic_operand\" \"\")))]\n+\t(match_operand:SI 1 \"int_2word_operand\" \"i\"))]\n   \"\"\n   \"#\"\n   \"reload_completed\"\n   [(set (match_dup 0)\n-\t(high:SI (match_dup 2)))\n+\t(high:SI (match_dup 1)))\n    (set (match_dup 0)\n \t(lo_sum:SI (match_dup 0)\n-\t\t   (match_dup 2)))\n-   (set (match_dup 0)\n-\t(plus:SI (match_dup 0) (match_dup 1)))]\n-\n+\t\t(match_dup 1)))]\n   \"\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"12\")])\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"multi\")])\n \n-(define_insn \"movsi_high_pic\"\n+(define_insn \"movsi_high\"\n   [(set (match_operand:SI 0 \"integer_register_operand\" \"=d\")\n-\t(high:SI (match_operand:SI 1 \"pic_symbolic_operand\" \"\")))]\n+\t(high:SI (match_operand:SI 1 \"int_2word_operand\" \"i\")))]\n   \"\"\n-  \"sethi #gprelhi(%1), %0\"\n+  \"sethi #hi(%1), %0\"\n   [(set_attr \"type\" \"sethi\")\n    (set_attr \"length\" \"4\")])\n \n-(define_insn \"movsi_lo_sum_pic\"\n+(define_insn \"movsi_lo_sum\"\n   [(set (match_operand:SI 0 \"integer_register_operand\" \"+d\")\n \t(lo_sum:SI (match_dup 0)\n-\t\t   (match_operand:SI 1 \"pic_symbolic_operand\" \"\")))]\n+\t\t   (match_operand:SI 1 \"int_2word_operand\" \"i\")))]\n   \"\"\n-  \"setlo #gprello(%1), %0\"\n+  \"setlo #lo(%1), %0\"\n   [(set_attr \"type\" \"setlo\")\n    (set_attr \"length\" \"4\")])\n \n@@ -1692,14 +1700,14 @@\n }\")\n \n (define_insn \"*movdf_double\"\n-  [(set (match_operand:DF 0 \"move_destination_operand\" \"=h,?e,??f,??d,R,?R,??m,??m,h,?e,??f,??d,?h,??f,?e,??d,R,m,h,??f,e,??d\")\n-\t(match_operand:DF 1 \"move_source_operand\"      \" h,e,f,d,h,e,f,d,R,R,m,m,e,d,h,f,GO,GO,GO,GO,GO,GO\"))]\n+  [(set (match_operand:DF 0 \"move_destination_operand\" \"=h,?e,??f,??d,R,?R,??m,??m,h,?e,??f,??d,?h,??f,?e,??d,R,m,h,??f,e,??d,e,??d\")\n+\t(match_operand:DF 1 \"move_source_operand\"      \" h,e,f,d,h,e,f,d,R,R,m,m,e,d,h,f,GO,GO,GO,GO,GO,GO,F,F\"))]\n   \"TARGET_DOUBLE\n    && (register_operand (operands[0], DFmode)\n        || reg_or_0_operand (operands[1], DFmode))\"\n   \"* return output_move_double (operands, insn);\"\n-  [(set_attr \"length\" \"4,8,8,8,4,4,8,8,4,4,8,8,4,8,4,8,4,8,8,8,8,8\")\n-   (set_attr \"type\" \"fdconv,multi,multi,multi,fstore,gstore,fstore,gstore,fload,gload,fload,gload,movgf,movgf,movfg,movfg,gstore,gstore,movgf,movgf,multi,multi\")])\n+  [(set_attr \"length\" \"4,8,8,8,4,4,8,8,4,4,8,8,4,8,4,8,4,8,8,8,8,8,16,16\")\n+   (set_attr \"type\" \"fdconv,multi,multi,multi,fstore,gstore,fstore,gstore,fload,gload,fload,gload,movgf,movgf,movfg,movfg,gstore,gstore,movgf,movgf,multi,multi,multi,multi\")])\n \n ;; If we don't support the double instructions, prefer gprs over fprs, since it\n ;; will all be emulated\n@@ -2565,7 +2573,7 @@\n (define_insn \"addsi3\"\n   [(set (match_operand:SI 0 \"integer_register_operand\" \"=d\")\n \t(plus:SI (match_operand:SI 1 \"integer_register_operand\" \"%d\")\n-\t\t (match_operand:SI 2 \"gpr_or_int12_operand\" \"dNOP\")))]\n+\t\t (match_operand:SI 2 \"gpr_or_int12_operand\" \"dNOPQ\")))]\n   \"\"\n   \"add%I2 %1,%2,%0\"\n   [(set_attr \"length\" \"4\")\n@@ -5251,7 +5259,11 @@\n   if (! operands[2])\n     operands[2] = const0_rtx;\n \n-  emit_call_insn (gen_call_internal (addr, operands[1], operands[2], lr));\n+  if (TARGET_FDPIC)\n+    frv_expand_fdpic_call (operands, 0);\n+  else\n+    emit_call_insn (gen_call_internal (addr, operands[1], operands[2], lr));\n+\n   DONE;\n }\")\n \n@@ -5260,7 +5272,53 @@\n \t (match_operand 1 \"\" \"\"))\n    (use (match_operand 2 \"\" \"\"))\n    (clobber (match_operand:SI 3 \"lr_operand\" \"=l,l\"))]\n+  \"! TARGET_FDPIC\"\n+  \"@\n+   call %0\n+   call%i0l %M0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"call,jumpl\")])\n+\n+;; The odd use of GR0 within the UNSPEC below prevents cseing or\n+;; hoisting function descriptor loads out of loops.  This is almost\n+;; never desirable, since if we preserve the function descriptor in a\n+;; pair of registers, it takes two insns to move it to gr14/gr15, and\n+;; if it's in the stack, we just waste space with the store, since\n+;; we'll have to load back from memory anyway.  And, in the worst\n+;; case, we may end up reusing a function descriptor still pointing at\n+;; a PLT entry, instead of to the resolved function, which means going\n+;; through the resolver for every call that uses the outdated value.\n+;; Bad!\n+\n+;; The explicit MEM inside the SPEC prevents the compiler from moving\n+;; the load before a branch after a NULL test, or before a store that\n+;; initializes a function descriptor.\n+\n+(define_insn \"movdi_ldd\"\n+  [(set (match_operand:DI 0 \"fdpic_fptr_operand\" \"=e\")\n+\t(unspec:DI [(mem:DI (match_operand:SI 1 \"ldd_address_operand\" \"p\"))\n+\t\t    (reg:SI 0)] UNSPEC_LDD))]\n   \"\"\n+  \"ldd%I1 %M1, %0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"gload\")])\n+\n+(define_insn \"call_fdpicdi\"\n+  [(call (mem:QI (match_operand:DI 0 \"fdpic_fptr_operand\" \"W\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (match_operand:SI 2 \"lr_operand\" \"=l\"))]\n+  \"TARGET_FDPIC\"\n+  \"calll %M0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"jumpl\")])\n+\n+(define_insn \"call_fdpicsi\"\n+  [(call (mem:QI (match_operand:SI 0 \"call_operand\" \"S,dNOP\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))\n+   (use (match_operand:SI 3 \"fdpic_operand\" \"Z,Z\"))\n+   (clobber (match_operand:SI 4 \"lr_operand\" \"=l,l\"))]\n+  \"TARGET_FDPIC\"\n   \"@\n    call %0\n    call%i0l %M0\"\n@@ -5296,8 +5354,12 @@\n   if (! operands[3])\n     operands[3] = const0_rtx;\n \n-  emit_call_insn (gen_call_value_internal (operands[0], addr, operands[2],\n-\t\t\t\t\t   operands[3], lr));\n+  if (TARGET_FDPIC)\n+    frv_expand_fdpic_call (operands, 1);\n+  else\n+    emit_call_insn (gen_call_value_internal (operands[0], addr, operands[2],\n+\t\t\t\t\t     operands[3], lr));\n+\n   DONE;\n }\")\n \n@@ -5307,7 +5369,31 @@\n \t\t      (match_operand 2 \"\" \"\")))\n    (use (match_operand 3 \"\" \"\"))\n    (clobber (match_operand:SI 4 \"lr_operand\" \"=l,l\"))]\n-  \"\"\n+  \"! TARGET_FDPIC\"\n+  \"@\n+   call %1\n+   call%i1l %M1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"call,jumpl\")])\n+\n+(define_insn \"call_value_fdpicdi\"\n+  [(set (match_operand 0 \"register_operand\" \"=d\")\n+\t(call (mem:QI (match_operand:DI 1 \"fdpic_fptr_operand\" \"W\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (match_operand:SI 3 \"lr_operand\" \"=l\"))]\n+  \"TARGET_FDPIC\"\n+  \"calll %M1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"jumpl\")])\n+\n+(define_insn \"call_value_fdpicsi\"\n+  [(set (match_operand 0 \"register_operand\" \"=d,d\")\n+\t(call (mem:QI (match_operand:SI 1 \"call_operand\" \"S,dNOP\"))\n+\t\t      (match_operand 2 \"\" \"\")))\n+   (use (match_operand 3 \"\" \"\"))\n+   (use (match_operand:SI 4 \"fdpic_operand\" \"Z,Z\"))\n+   (clobber (match_operand:SI 5 \"lr_operand\" \"=l,l\"))]\n+  \"TARGET_FDPIC\"\n   \"@\n    call %1\n    call%i1l %M1\"\n@@ -7453,3 +7539,174 @@\n   \"mhdseth %2, %0\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"mset\")])\n+\n+;;-----------------------------------------------------------------------------\n+\n+(define_expand \"symGOT2reg\"\n+  [(match_operand:SI 0 \"\" \"\")\n+   (match_operand:SI 1 \"\" \"\")\n+   (match_operand:SI 2 \"\" \"\")\n+   (match_operand:SI 3 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx insn;\n+\n+  insn = emit_insn (gen_symGOT2reg_i (operands[0], operands[1], operands[2], operands[3]));\n+\n+  RTX_UNCHANGING_P (SET_SRC (PATTERN (insn))) = 1;\n+\n+  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, operands[1],\n+\t\t\t\t\tREG_NOTES (insn));\n+\n+  DONE;\n+}\")\n+\n+(define_expand \"symGOT2reg_i\"\n+  [(set (match_operand:SI 0 \"\" \"\")\n+\t(mem:SI (plus:SI (match_operand:SI 2 \"\" \"\")\n+\t\t\t (const:SI (unspec:SI [(match_operand:SI 1 \"\" \"\")\n+\t\t\t\t\t       (match_operand:SI 3 \"\" \"\")]\n+\t\t\t\t\t      UNSPEC_GOT)))))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"symGOT2reg_hilo\"\n+  [(set (match_dup 6)\n+\t(high:SI (const:SI (unspec:SI [(match_operand:SI 1 \"\" \"\")\n+\t\t\t\t       (match_dup 4)] UNSPEC_GOT))))\n+   (set (match_dup 5)\n+\t(lo_sum:SI (match_dup 6)\n+\t\t   (const:SI (unspec:SI [(match_dup 1)\n+\t\t\t\t\t (match_operand:SI 3 \"\" \"\")]\n+\t\t\t\t\tUNSPEC_GOT))))\n+   (set (match_operand:SI 0 \"\" \"\")\n+\t(mem:SI (plus:SI (match_dup 5)\n+\t\t\t (match_operand:SI 2 \"\" \"\"))))\n+   ]\n+  \"\"\n+  \"\n+{\n+  if (no_new_pseudos)\n+    operands[6] = operands[5] = operands[0];\n+  else\n+    {\n+      operands[6] = gen_reg_rtx (SImode);\n+      operands[5] = gen_reg_rtx (SImode);\n+    }\n+\n+  operands[4] = GEN_INT (INTVAL (operands[3]) + 1);\n+  operands[3] = GEN_INT (INTVAL (operands[3]) + 2);\n+}\")\n+\n+(define_expand \"symGOTOFF2reg_hilo\"\n+  [(set (match_dup 6)\n+\t(high:SI (const:SI (unspec:SI [(match_operand:SI 1 \"\" \"\")\n+\t\t\t\t       (match_dup 4)] UNSPEC_GOT))))\n+   (set (match_dup 5)\n+\t(lo_sum:SI (match_dup 6)\n+\t\t   (const:SI (unspec:SI [(match_dup 1)\n+\t\t\t\t\t (match_operand:SI 3 \"\" \"\")]\n+\t\t\t\t\tUNSPEC_GOT))))\n+   (set (match_operand:SI 0 \"\" \"\")\n+\t(plus:SI (match_dup 5)\n+\t\t (match_operand:SI 2 \"\" \"\")))\n+   ]\n+  \"\"\n+  \"\n+{\n+  if (no_new_pseudos)\n+    operands[6] = operands[5] = operands[0];\n+  else\n+    {\n+      operands[6] = gen_reg_rtx (SImode);\n+      operands[5] = gen_reg_rtx (SImode);\n+    }\n+\n+  operands[4] = GEN_INT (INTVAL (operands[3]) + 1);\n+  operands[3] = GEN_INT (INTVAL (operands[3]) + 2);\n+}\")\n+\n+(define_expand \"symGOTOFF2reg\"\n+  [(match_operand:SI 0 \"\" \"\")\n+   (match_operand:SI 1 \"\" \"\")\n+   (match_operand:SI 2 \"\" \"\")\n+   (match_operand:SI 3 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx insn = emit_insn (gen_symGOTOFF2reg_i (operands[0], operands[1], operands[2], operands[3]));\n+\n+  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, operands[1],\n+\t\t\t\t\tREG_NOTES (insn));\n+\n+  DONE;\n+}\")\n+\n+(define_expand \"symGOTOFF2reg_i\"\n+  [(set (match_operand:SI 0 \"\" \"\")\n+\t(plus:SI (match_operand:SI 2 \"\" \"\")\n+\t\t (const:SI\n+\t\t  (unspec:SI [(match_operand:SI 1 \"\" \"\")\n+\t\t\t     (match_operand:SI 3 \"\" \"\")]\n+\t\t\t     UNSPEC_GOT))))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"symGPREL2reg\"\n+  [(match_operand:SI 0 \"\" \"\")\n+   (match_operand:SI 1 \"\" \"\")\n+   (match_operand:SI 2 \"\" \"\")\n+   (match_operand:SI 3 \"\" \"\")\n+   (match_dup 4)]\n+  \"\"\n+  \"\n+{\n+  rtx insn;\n+\n+  if (no_new_pseudos)\n+    operands[4] = operands[0];\n+  else\n+    operands[4] = gen_reg_rtx (SImode);\n+\n+  emit_insn (frv_gen_GPsym2reg (operands[4], operands[2]));\n+\n+  insn = emit_insn (gen_symGOTOFF2reg_i (operands[0], operands[1],\n+\t\t\t\t\t operands[4], operands[3]));\n+\n+  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, operands[1],\n+\t\t\t\t\tREG_NOTES (insn));\n+\n+  DONE;\n+}\")\n+\n+(define_expand \"symGPREL2reg_hilo\"\n+  [(match_operand:SI 0 \"\" \"\")\n+   (match_operand:SI 1 \"\" \"\")\n+   (match_operand:SI 2 \"\" \"\")\n+   (match_operand:SI 3 \"\" \"\")\n+   (match_dup 4)]\n+  \"\"\n+  \"\n+{\n+  rtx insn;\n+\n+  if (no_new_pseudos)\n+    {\n+      emit_insn (gen_symGOT2reg (operands[0], operands[1], operands[2],\n+\t\t\t\t GEN_INT (R_FRV_GOT12)));\n+      DONE;\n+    }\n+\n+  operands[4] = gen_reg_rtx (SImode);\n+\n+  emit_insn (frv_gen_GPsym2reg (operands[4], operands[2]));\n+\n+  insn = emit_insn (gen_symGOTOFF2reg_hilo (operands[0], operands[1],\n+\t\t\t\t\t    operands[4], operands[3]));\n+\n+  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, operands[1],\n+\t\t\t\t\tREG_NOTES (insn));\n+\n+  DONE;\n+}\")"}, {"sha": "f888a481b153247db3ac32db40fbed45ce07158e", "filename": "gcc/config/frv/frvbegin.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Ffrvbegin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Ffrvbegin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrvbegin.c?ref=34208acf14fa026ae391a819525d20b48af5c2bf", "patch": "@@ -71,10 +71,13 @@ INIT_SECTION_NEG_ONE (\".dtors\", \"\\\"aw\\\"\", \"__DTOR_LIST__\");\n \n INIT_SECTION (\".eh_frame\", \"\\\"aw\\\"\", \"__EH_FRAME_BEGIN__\");\n \n+#if ! __FRV_FDPIC__\n+/* In FDPIC, the linker itself generates this.  */\n /* Beginning of .rofixup section that provides a list of pointers that we\n    need to adjust.  */\n \n INIT_SECTION (\".rofixup\", \"\\\"a\\\"\", \"__ROFIXUP_LIST__\");\n+#endif /* __FRV_FDPIC__ */\n \n extern void __frv_register_eh(void) __attribute__((__constructor__));\n extern void __frv_deregister_eh(void) __attribute__((__destructor__));"}, {"sha": "f8080c6f0313cb138ab9213f750600fe20f65c9f", "filename": "gcc/config/frv/frvend.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Ffrvend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Ffrvend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrvend.c?ref=34208acf14fa026ae391a819525d20b48af5c2bf", "patch": "@@ -64,7 +64,10 @@ FINI_SECTION_ZERO (\".dtors\", \"\\\"aw\\\"\", \"__DTOR_END__\");\n \n FINI_SECTION_ZERO (\".eh_frame\", \"\\\"aw\\\"\", \"__FRAME_END__\");\n \n+#if ! __FRV_FDPIC__\n+/* In FDPIC, the linker itself generates this.  */\n /* End of .rofixup section that provides a list of pointers that we\n    need to adjust.  */\n \n FINI_SECTION (\".rofixup\", \"\\\"a\\\"\", \"__ROFIXUP_END__\");\n+#endif /* __FRV_FDPIC__ */"}, {"sha": "2aae3db9c79bf97aafb1ac3f5814b2b3fb2c2690", "filename": "gcc/config/frv/libgcc-frv.ver", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Flibgcc-frv.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Flibgcc-frv.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Flibgcc-frv.ver?ref=34208acf14fa026ae391a819525d20b48af5c2bf", "patch": "@@ -0,0 +1,55 @@\n+GCC_3.4 {\n+  # frv abi symbol names\n+  __ftod\n+  __ftoi\n+  __ftoui\n+  __dtoi\n+  __ftoui\n+  __dtoui\n+  __ftoll\n+  __dtoll\n+  __ftoull\n+  __dtoull\n+  __itof\n+  __lltof\n+  __dtof\n+  __itod\n+  __lltof\n+  __lltod\n+  __addd\n+  __subd\n+  __muld\n+  __divd\n+  __addf\n+  __subf\n+  __mulf\n+  __divf\n+  __sllll\n+  __srlll\n+  __srall\n+  __addll\n+  __subll\n+  __mulll\n+  __umulll\n+  __divll\n+  __udivll\n+  __modll\n+  __umodll\n+  __cmpll\n+  __cmpf\n+  __cmpd\n+  __andll\n+  __orll\n+  __xorll\n+  __notll\n+  __cmov\n+  __cmovd\n+  __cmovh\n+  __cmovw\n+  __modi\n+  __uitod\n+  __uitof\n+  __ulltod\n+  __ulltof\n+  __umodi\n+}"}, {"sha": "6f0f1b27f677eeed846a5fce51f7377a449fb127", "filename": "gcc/config/frv/linux.h", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Flinux.h?ref=34208acf14fa026ae391a819525d20b48af5c2bf", "patch": "@@ -0,0 +1,74 @@\n+/* Target macros for the FRV Linux port of GCC.\n+   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+#ifndef __FRV_LINUX_H__\n+#define __FRV_LINUX_H__\n+\n+#undef SUBTARGET_DRIVER_SELF_SPECS\n+#define SUBTARGET_DRIVER_SELF_SPECS \\\n+  \"%{!mno-fdpic:-mfdpic}\",\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \\\n+  \"%{!shared: %{pg|p|profile:gcrt1.o%s;pie:Scrt1.o%s;:crt1.o%s}} \\\n+   crti.o%s %{static:crtbeginT.o%s;shared|pie:crtbeginS.o%s;:crtbegin.o%s}\"\n+\n+#undef ENDFILE_SPEC\n+#define ENDFILE_SPEC \\\n+  \"%{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s\"\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC \"\\\n+  %{mfdpic: -m elf32frvfd -z text} %{shared} %{pie} \\\n+  %{!shared: %{!static: \\\n+   %{rdynamic:-export-dynamic} \\\n+   %{!dynamic-linker:-dynamic-linker /lib/ld.so.1}} \\\n+   %{static}}\"\n+\n+/* Support for compile-time default CPU.  */\n+#define OPTION_DEFAULT_SPECS \\\n+  {\"cpu\", \"%{!mcpu=*:-mcpu=%(VALUE)}\" }\n+\n+/* Define OS-specific predefined preprocessor macros.  */\n+#define TARGET_OS_CPP_BUILTINS()\t\\\n+  do {\t\t\t\t\t\\\n+    builtin_define (\"__gnu_linux__\");\t\\\n+    builtin_define_std (\"linux\");\t\\\n+    builtin_define_std (\"unix\");\t\\\n+    builtin_assert (\"system=linux\");\t\\\n+  } while (0)\n+\n+#define HAS_INIT_SECTION 1\n+#define INIT_SECTION_ASM_OP\t\"\\t.section .init,\\\"ax\\\"\"\n+#define FINI_SECTION_ASM_OP\t\"\\t.section .fini,\\\"ax\\\"\"\n+\n+#define CRT_CALL_STATIC_FUNCTION(SECTION_OP, FUNC)\t\\\n+asm (SECTION_OP); \\\n+asm (\"ldi.p @(fp,4), gr15 ! call \" #FUNC); \\\n+asm (TEXT_SECTION_ASM_OP);\n+\n+#undef INVOKE__main\n+\n+#undef Twrite\n+#define Twrite __write\n+\n+#endif /* __FRV_LINUX_H__ */"}, {"sha": "37662b60b407f8d3a75757495500c95ea194ed5b", "filename": "gcc/config/frv/t-frv", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Ft-frv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Ft-frv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ft-frv?ref=34208acf14fa026ae391a819525d20b48af5c2bf", "patch": "@@ -82,9 +82,9 @@ $(T)frvend$(objext): $(srcdir)/config/frv/frvend.c $(GCC_PASSES) \\\n #MULTILIB_EXCEPTIONS\t= *mcpu=simple/*msoft-float* *mcpu=frv/*msoft-float*\n #MULTILIB_EXTRA_OPTS\t= mlibrary-pic\n \n-MULTILIB_OPTIONS\t= mcpu=frv/mcpu=fr400/mcpu=simple mno-pack mlibrary-pic\n-MULTILIB_DIRNAMES\t= frv fr400 simple unpacked pic\n-MULTILIB_MATCHES\t= mcpu?simple=mcpu?fr300 mlibrary-pic=fpic mlibrary-pic=fPIC\n+MULTILIB_OPTIONS\t= mcpu=frv/mcpu=fr400/mcpu=simple mno-pack mlibrary-pic/mfdpic\n+MULTILIB_DIRNAMES\t= frv fr400 simple unpacked pic fdpic\n+MULTILIB_MATCHES\t= mcpu?simple=mcpu?fr300 mlibrary-pic=multilib-library-pic\n MULTILIB_EXCEPTIONS\t= mcpu=frv/mno-pack* mcpu=simple/mno-pack*\n \n LIBGCC = stmp-multilib"}, {"sha": "298f59b0b4d54ed9a74d4daf0ccd0f4973831b87", "filename": "gcc/config/frv/t-linux", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Ft-linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fconfig%2Ffrv%2Ft-linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ft-linux?ref=34208acf14fa026ae391a819525d20b48af5c2bf", "patch": "@@ -0,0 +1,12 @@\n+# We don't want multilibs.\n+MULTILIB_OPTIONS=\n+MULTILIB_DIRNAMES=\n+MULTILIB_MATCHES=\n+MULTILIB_EXCEPTIONS=\n+MULTILIB_EXTRA_OPTS=\n+\n+CRTSTUFF_T_CFLAGS = -fPIC\n+TARGET_LIBGCC2_CFLAGS = -fPIC\n+\n+SHLIB_MAPFILES = $(srcdir)/libgcc-std.ver \\\n+\t\t $(srcdir)/config/frv/libgcc-frv.ver"}, {"sha": "3fe65737bcb9f54489c8a54d2c56a56942be9710", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=34208acf14fa026ae391a819525d20b48af5c2bf", "patch": "@@ -633,6 +633,7 @@ in the following sections.\n -malloc-cc  -mfixed-cc  -mdword  -mno-dword @gol\n -mdouble  -mno-double @gol\n -mmedia  -mno-media  -mmuladd  -mno-muladd @gol\n+-mfdpic -minline-plt -mgprel-ro -multilib-library-pic -mlinked-fp @gol\n -mlibrary-pic  -macc-4 -macc-8 @gol\n -mpack  -mno-pack  -mno-eflags  -mcond-move  -mno-cond-move @gol\n -mscc  -mno-scc  -mcond-exec  -mno-cond-exec @gol\n@@ -8655,6 +8656,53 @@ configure option, gcc's program search path, and finally by the user's\n @env{PATH}.  The linker used by GCC can be printed using @samp{which\n `gcc -print-prog-name=ld`}.\n \n+@item -mfdpic\n+@opindex mfdpic\n+\n+Select the FDPIC ABI, that uses function descriptors to represent\n+pointers to functions.  Without any PIC/PIE-related options, it\n+implies @option{-fPIE}.  With @option{-fpic} or @option{-fpie}, it\n+assumes GOT entries and small data are within a 12-bit range from the\n+GOT base address; with @option{-fPIC} or @option{-fPIE}, GOT offsets\n+are computed with 32 bits.\n+\n+@item -minline-plt\n+@opindex minline-plt\n+\n+Enable inlining of PLT entries in function calls to functions that are\n+not known to bind locally.  It has no effect without @option{-mfdpic}.\n+It's enabled by default if optimizing for speed and compiling for\n+shared libraries (i.e., @option{-fPIC} or @option{-fpic}), or when an\n+optimization option such as @option{-O3} or above is present in the\n+command line.\n+\n+@item -mgprel-ro\n+@opindex mgprel-ro\n+\n+Enable the use of @code{GPREL} relocations in the FDPIC ABI for data\n+that is known to be in read-only sections.  It's enabled by default,\n+except for @option{-fpic} or @option{-fpie}: even though it may help\n+make the global offset table smaller, it trades 1 instruction for 4.\n+With @option{-fPIC} or @option{-fPIE}, it trades 3 instructions for 4,\n+one of which may be shared by multiple symbols, and it avoids the need\n+for a GOT entry for the referenced symbol, so it's more likely to be a\n+win.  If it is not, @option{-mno-gprel-ro} can be used to disable it.\n+\n+@item -multilib-library-pic\n+@opindex multilib-library-pic\n+\n+Link with the (library, not FD) pic libraries.  It's implied by\n+@option{-mlibrary-pic}, as well as by @option{-fPIC} and\n+@option{-fpic} without @option{-mfdpic}.  You should never have to use\n+it explicitly.\n+\n+@item -mlinked-fp\n+@opindex mlinked-fp\n+\n+Follow the EABI requirement of always creating a frame pointer whenever\n+a stack frame is allocated.  This option is enabled by default and can\n+be disabled with @option{-mno-linked-fp}.\n+\n @item -mlong-calls\n @opindex mno-long-calls\n Generate code that uses long call sequences.  This ensures that a call\n@@ -10429,7 +10477,7 @@ Do not use multiply and add/subtract instructions.\n @item -mlibrary-pic\n @opindex mlibrary-pic\n \n-Enable PIC support for building libraries\n+Generate position-independent EABI code.\n \n @item -macc-4\n @opindex macc-4"}, {"sha": "5ac5a815f4e6189842524800b5d2cc5b290b5a2e", "filename": "gcc/reload.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=34208acf14fa026ae391a819525d20b48af5c2bf", "patch": "@@ -105,6 +105,7 @@ a register with any other reload.  */\n #include \"function.h\"\n #include \"toplev.h\"\n #include \"params.h\"\n+#include \"target.h\"\n \n #ifndef REGNO_MODE_OK_FOR_BASE_P\n #define REGNO_MODE_OK_FOR_BASE_P(REGNO, MODE) REGNO_OK_FOR_BASE_P (REGNO)\n@@ -113,6 +114,12 @@ a register with any other reload.  */\n #ifndef REG_MODE_OK_FOR_BASE_P\n #define REG_MODE_OK_FOR_BASE_P(REGNO, MODE) REG_OK_FOR_BASE_P (REGNO)\n #endif\n+\n+/* True if X is a constant that can be forced into the constant pool.  */\n+#define CONST_POOL_OK_P(X)\t\t\t\\\n+  (CONSTANT_P (X)\t\t\t\t\\\n+   && GET_CODE (X) != HIGH\t\t\t\\\n+   && !targetm.cannot_force_const_mem (X))\n \f\n /* All reloads of the current insn are recorded here.  See reload.h for\n    comments.  */\n@@ -3114,9 +3121,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t\t&& REGNO (operand) >= FIRST_PSEUDO_REGISTER\n \t\t\t&& reg_renumber[REGNO (operand)] < 0))\n \t\t  win = 1;\n-\t\tif (CONSTANT_P (operand)\n-\t\t    /* force_const_mem does not accept HIGH.  */\n-\t\t    && GET_CODE (operand) != HIGH)\n+\t\tif (CONST_POOL_OK_P (operand))\n \t\t  badop = 0;\n \t\tconstmemok = 1;\n \t\tbreak;\n@@ -3178,8 +3183,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t\t     && offsettable_memref_p (reg_equiv_mem[REGNO (operand)]))\n \t\t\t    || (reg_equiv_address[REGNO (operand)] != 0))))\n \t\t  win = 1;\n-\t\t/* force_const_mem does not accept HIGH.  */\n-\t\tif ((CONSTANT_P (operand) && GET_CODE (operand) != HIGH)\n+\t\tif (CONST_POOL_OK_P (operand)\n \t\t    || GET_CODE (operand) == MEM)\n \t\t  badop = 0;\n \t\tconstmemok = 1;\n@@ -3299,7 +3303,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t\t/* If we didn't already win, we can reload\n \t\t\t   constants via force_const_mem, and other\n \t\t\t   MEMs by reloading the address like for 'o'.  */\n-\t\t\tif ((CONSTANT_P (operand) && GET_CODE (operand) != HIGH)\n+\t\t\tif (CONST_POOL_OK_P (operand)\n \t\t\t    || GET_CODE (operand) == MEM)\n \t\t\t  badop = 0;\n \t\t\tconstmemok = 1;\n@@ -3375,9 +3379,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t an early reload pass.  Note that the test here is\n \t\t precisely the same as in the code below that calls\n \t\t force_const_mem.  */\n-\t      if (CONSTANT_P (operand)\n-\t\t  /* force_const_mem does not accept HIGH.  */\n-\t\t  && GET_CODE (operand) != HIGH\n+\t      if (CONST_POOL_OK_P (operand)\n \t\t  && ((PREFERRED_RELOAD_CLASS (operand,\n \t\t\t\t\t       (enum reg_class) this_alternative[i])\n \t\t       == NO_REGS)\n@@ -3751,9 +3753,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n      into registers are here changed into memory references.  */\n   for (i = 0; i < noperands; i++)\n     if (! goal_alternative_win[i]\n-\t&& CONSTANT_P (recog_data.operand[i])\n-\t/* force_const_mem does not accept HIGH.  */\n-\t&& GET_CODE (recog_data.operand[i]) != HIGH\n+\t&& CONST_POOL_OK_P (recog_data.operand[i])\n \t&& ((PREFERRED_RELOAD_CLASS (recog_data.operand[i],\n \t\t\t\t     (enum reg_class) goal_alternative[i])\n \t     == NO_REGS)"}, {"sha": "f6f62c6a19029c02c0f4a2cec6451060a3646a7e", "filename": "gcc/unwind-dw2-fde-glibc.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Funwind-dw2-fde-glibc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34208acf14fa026ae391a819525d20b48af5c2bf/gcc%2Funwind-dw2-fde-glibc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde-glibc.c?ref=34208acf14fa026ae391a819525d20b48af5c2bf", "patch": "@@ -52,6 +52,10 @@\n     && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2) \\\n \t|| (__GLIBC__ == 2 && __GLIBC_MINOR__ == 2 && defined(DT_CONFIG)))\n \n+#ifndef __RELOC_POINTER\n+# define __RELOC_POINTER(ptr, base) ((ptr) + (base))\n+#endif\n+\n static const fde * _Unwind_Find_registered_FDE (void *pc, struct dwarf_eh_bases *bases);\n \n #define _Unwind_Find_FDE _Unwind_Find_registered_FDE\n@@ -109,7 +113,11 @@ _Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n   struct unw_eh_callback_data *data = (struct unw_eh_callback_data *) ptr;\n   const ElfW(Phdr) *phdr, *p_eh_frame_hdr, *p_dynamic;\n   long n, match;\n+#ifdef __FRV_FDPIC__\n+  struct elf32_fdpic_loadaddr load_base;\n+#else\n   _Unwind_Ptr load_base;\n+#endif\n   const unsigned char *p;\n   const struct unw_eh_frame_hdr *hdr;\n   _Unwind_Ptr eh_frame;\n@@ -132,7 +140,8 @@ _Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n     {\n       if (phdr->p_type == PT_LOAD)\n \t{\n-\t  _Unwind_Ptr vaddr = phdr->p_vaddr + load_base;\n+\t  _Unwind_Ptr vaddr = (_Unwind_Ptr)\n+\t    __RELOC_POINTER (phdr->p_vaddr, load_base);\n \t  if (data->pc >= vaddr && data->pc < vaddr + phdr->p_memsz)\n \t    match = 1;\n \t}\n@@ -146,7 +155,7 @@ _Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n \n   /* Read .eh_frame_hdr header.  */\n   hdr = (const struct unw_eh_frame_hdr *)\n-\t(p_eh_frame_hdr->p_vaddr + load_base);\n+    __RELOC_POINTER (p_eh_frame_hdr->p_vaddr, load_base);\n   if (hdr->version != 1)\n     return 1;\n \n@@ -157,7 +166,8 @@ _Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n     {\n       /* For dynamically linked executables and shared libraries,\n \t DT_PLTGOT is the gp value for that object.  */\n-      ElfW(Dyn) *dyn = (ElfW(Dyn) *) (p_dynamic->p_vaddr + load_base);\n+      ElfW(Dyn) *dyn = (ElfW(Dyn) *)\n+\t__RELOC_POINTER (p_dynamic->p_vaddr, load_base);\n       for (; dyn->d_tag != DT_NULL ; dyn++)\n \tif (dyn->d_tag == DT_PLTGOT)\n \t  {\n@@ -166,6 +176,8 @@ _Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n \t    break;\n \t  }\n     }\n+# elif defined __FRV_FDPIC__ && defined __linux__\n+  data->dbase = load_base.got_value;\n # else\n #  error What is DW_EH_PE_datarel base on this platform?\n # endif"}]}