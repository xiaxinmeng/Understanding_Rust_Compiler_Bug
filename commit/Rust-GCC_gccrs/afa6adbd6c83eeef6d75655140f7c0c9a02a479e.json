{"sha": "afa6adbd6c83eeef6d75655140f7c0c9a02a479e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZhNmFkYmQ2YzgzZWVlZjZkNzU2NTUxNDBmN2MwYzlhMDJhNDc5ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-17T14:41:06Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-17T14:41:06Z"}, "message": "Improve handling of memory operands in ipa-icf 3/4\n\nthis patch is based on Maritn's patch\nhttps://gcc.gnu.org/legacy-ml/gcc-patches/2019-11/msg02633.html\nhowever based on new code that track and compare memory accesses\nso it can be implemented correctly.\n\nAs shown here\nhttps://gcc.gnu.org/pipermail/gcc-patches/2020-November/558773.html\nthe most common reason for function body being streamed in but merging to fail\nis the mismatch in base alias set.\n\nThis patch collect base and ref types ao_alias_ptr types, stream them to WPA\nand at WPA time hash is produced. Now we can use alias_sets since these these\nare assumed to be same as ltrans time alias sets. This is currently not always\ntrue - but that is pre-existing issue.  I will try to produce a testcase and\nmake followup patch on this (that will stream out ODR types with TYPE_CANONICAL\nthat is !ODR as !ODR type). However for this patch this is not a problem since\nthe real alias sets are finer but definitly not coarser.\n\nWe may make it possible to use canonical type hash and save some streaming, but\nI think it would be better to wait for next stage1 since it is not completely\ntrivial WRT ODR types: either we hash ODR type names and then hash values would\nbe too coarse for cases we got conflict betwen C and C++ type or we do not\nstream and will again get into trouble with hash values being too weak. Tried\nthat - we get a lot of types that are struturally same but distinguished by\nODR names (from template instantiations).\n\nAs followup I will add code for merging with mismatched base alias sets.  This\nmakes the aforementioned problem about ODR names less pronounced but it is\nstill present on pointer loads/stores which requires REF alias set mismatches.\n\n2020-11-13  Jan Hubicka  <hubicka@ucw.cz>\n\t    Martin Liska  <mliska@suse.cz>\n\n\t* ipa-icf.c: Include data-streamer.h and alias.h.\n\t(sem_function::sem_function): Initialize memory_access_types\n\tand m_alias_sets_hash.\n\t(sem_function::hash_stmt): For memory accesses and when going to\n\tdo lto streaming add base and ref types into memory_access_types.\n\t(sem_item_optimizer::write_summary): Stream memory access types.\n\t(sem_item_optimizer::read_section): Likewise and also iniitalize\n\tm_alias_sets_hash.\n\t(sem_item_optimizer::execute): Call\n\tsem_item_optimizer::update_hash_by_memory_access_type.\n\t(sem_item_optimizer::update_hash_by_memory_access_type): Updat.\n\t* ipa-icf.h (sem_function): Add memory_access_types and\n\tm_alias_sets_hash.", "tree": {"sha": "a4fdabfcf79d034d24efb534d7cb82adc38a3646", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4fdabfcf79d034d24efb534d7cb82adc38a3646"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afa6adbd6c83eeef6d75655140f7c0c9a02a479e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afa6adbd6c83eeef6d75655140f7c0c9a02a479e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afa6adbd6c83eeef6d75655140f7c0c9a02a479e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afa6adbd6c83eeef6d75655140f7c0c9a02a479e/comments", "author": null, "committer": null, "parents": [{"sha": "18dd295638724b455e072cd790451ace15a3d463", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18dd295638724b455e072cd790451ace15a3d463", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18dd295638724b455e072cd790451ace15a3d463"}], "stats": {"total": 81, "additions": 76, "deletions": 5}, "files": [{"sha": "27eeda3a319e30dc150a7dcddbe10a107c40b366", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 66, "deletions": 5, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa6adbd6c83eeef6d75655140f7c0c9a02a479e/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa6adbd6c83eeef6d75655140f7c0c9a02a479e/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=afa6adbd6c83eeef6d75655140f7c0c9a02a479e", "patch": "@@ -66,6 +66,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coverage.h\"\n #include \"gimple-pretty-print.h\"\n #include \"data-streamer.h\"\n+#include \"tree-streamer.h\"\n #include \"fold-const.h\"\n #include \"calls.h\"\n #include \"varasm.h\"\n@@ -86,6 +87,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"tree-vector-builder.h\"\n #include \"symtab-thunks.h\"\n+#include \"alias.h\"\n \n using namespace ipa_icf_gimple;\n \n@@ -227,14 +229,16 @@ hash_map<const_tree, hashval_t> sem_item::m_type_hash_cache;\n /* Semantic function constructor that uses STACK as bitmap memory stack.  */\n \n sem_function::sem_function (bitmap_obstack *stack)\n-: sem_item (FUNC, stack), m_checker (NULL), m_compared_func (NULL)\n+  : sem_item (FUNC, stack), memory_access_types (), m_alias_sets_hash (0),\n+    m_checker (NULL), m_compared_func (NULL)\n {\n   bb_sizes.create (0);\n   bb_sorted.create (0);\n }\n \n sem_function::sem_function (cgraph_node *node, bitmap_obstack *stack)\n-: sem_item (FUNC, node, stack), m_checker (NULL), m_compared_func (NULL)\n+  : sem_item (FUNC, node, stack), memory_access_types (),\n+    m_alias_sets_hash (0), m_checker (NULL), m_compared_func (NULL)\n {\n   bb_sizes.create (0);\n   bb_sorted.create (0);\n@@ -1438,9 +1442,30 @@ sem_function::hash_stmt (gimple *stmt, inchash::hash &hstate)\n \n \t/* All these statements are equivalent if their operands are.  */\n \tfor (unsigned i = 0; i < gimple_num_ops (stmt); ++i)\n-\t  m_checker->hash_operand (gimple_op (stmt, i), hstate, 0,\n-\t\t\t\t   func_checker::get_operand_access_type\n-\t\t\t\t\t(&map, gimple_op (stmt, i)));\n+\t  {\n+\t    func_checker::operand_access_type\n+\t\taccess_type = func_checker::get_operand_access_type\n+\t\t\t\t\t  (&map, gimple_op (stmt, i));\n+\t    m_checker->hash_operand (gimple_op (stmt, i), hstate, 0,\n+\t\t\t\t     access_type);\n+\t    /* For memory accesses when hasing for LTO stremaing record\n+\t       base and ref alias ptr types so we can compare them at WPA\n+\t       time without having to read actual function body.  */\n+\t    if (access_type == func_checker::OP_MEMORY\n+\t\t&& lto_streaming_expected_p ()\n+\t\t&& flag_strict_aliasing)\n+\t      {\n+\t\tao_ref ref;\n+\n+\t\tao_ref_init (&ref, gimple_op (stmt, i));\n+\t\ttree t = ao_ref_alias_ptr_type (&ref);\n+\t\tif (variably_modified_type_p (t, NULL_TREE))\n+\t\t  memory_access_types.safe_push (t);\n+\t\tt = ao_ref_base_alias_ptr_type (&ref);\n+\t\tif (variably_modified_type_p (t, NULL_TREE))\n+\t\t  memory_access_types.safe_push (t);\n+\t      }\n+\t  }\n \t/* Consider nocf_check attribute in hash as it affects code\n \t   generation.  */\n \tif (code == GIMPLE_CALL\n@@ -2129,6 +2154,14 @@ sem_item_optimizer::write_summary (void)\n \t  streamer_write_uhwi_stream (ob->main_stream, node_ref);\n \n \t  streamer_write_uhwi (ob, (*item)->get_hash ());\n+\n+\t  if ((*item)->type == FUNC)\n+\t    {\n+\t      sem_function *fn = static_cast<sem_function *> (*item);\n+\t      streamer_write_uhwi (ob, fn->memory_access_types.length ());\n+\t      for (unsigned i = 0; i < fn->memory_access_types.length (); i++)\n+\t\tstream_write_tree (ob, fn->memory_access_types[i], true);\n+\t    }\n \t}\n     }\n \n@@ -2180,6 +2213,18 @@ sem_item_optimizer::read_section (lto_file_decl_data *file_data,\n \t  cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n \n \t  sem_function *fn = new sem_function (cnode, &m_bmstack);\n+\t  unsigned count = streamer_read_uhwi (&ib_main);\n+\t  inchash::hash hstate (0);\n+\t  if (flag_incremental_link == INCREMENTAL_LINK_LTO)\n+\t    fn->memory_access_types.reserve_exact (count);\n+\t  for (unsigned i = 0; i < count; i++)\n+\t    {\n+\t      tree type = stream_read_tree (&ib_main, data_in);\n+\t      hstate.add_int (get_deref_alias_set (type));\n+\t      if (flag_incremental_link == INCREMENTAL_LINK_LTO)\n+\t\tfn->memory_access_types.quick_push (type);\n+\t    }\n+\t  fn->m_alias_sets_hash = hstate.end ();\n \t  fn->set_hash (hash);\n \t  m_items.safe_push (fn);\n \t}\n@@ -2376,6 +2421,7 @@ sem_item_optimizer::execute (void)\n \n   build_graph ();\n   update_hash_by_addr_refs ();\n+  update_hash_by_memory_access_type ();\n   build_hash_based_classes ();\n \n   if (dump_file)\n@@ -2513,6 +2559,21 @@ sem_item_optimizer::update_hash_by_addr_refs ()\n     m_items[i]->set_hash (m_items[i]->global_hash);\n }\n \n+void\n+sem_item_optimizer::update_hash_by_memory_access_type ()\n+{\n+  for (unsigned i = 0; i < m_items.length (); i++)\n+    {\n+      if (m_items[i]->type == FUNC)\n+\t{\n+\t  sem_function *fn = static_cast<sem_function *> (m_items[i]);\n+\t  inchash::hash hstate (fn->get_hash ());\n+\t  hstate.add_int (fn->m_alias_sets_hash);\n+\t  fn->set_hash (hstate.end ());\n+\t}\n+    }\n+}\n+\n /* Congruence classes are built by hash value.  */\n \n void"}, {"sha": "3e0e72428f73d1206b49c3b8ac8df83c8b86d4f5", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afa6adbd6c83eeef6d75655140f7c0c9a02a479e/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afa6adbd6c83eeef6d75655140f7c0c9a02a479e/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=afa6adbd6c83eeef6d75655140f7c0c9a02a479e", "patch": "@@ -371,12 +371,19 @@ class sem_function: public sem_item\n   /* GIMPLE codes hash value.  */\n   hashval_t gcode_hash;\n \n+  /* Vector of subpart of memory access types.  */\n+  vec<tree> memory_access_types;\n+\n   /* Total number of SSA names used in the function.  */\n   unsigned ssa_names_size;\n \n   /* Array of structures for all basic blocks.  */\n   vec <ipa_icf_gimple::sem_bb *> bb_sorted;\n \n+  /* Hash of canonical types used for memory references in the\n+     function.  */\n+  hashval_t m_alias_sets_hash;\n+\n   /* Return true if parameter I may be used.  */\n   bool param_used_p (unsigned int i);\n \n@@ -541,6 +548,9 @@ class sem_item_optimizer\n   /* For each semantic item, append hash values of references.  */\n   void update_hash_by_addr_refs ();\n \n+  /* Update hash by canonical types of memory accesses.  */\n+  void update_hash_by_memory_access_type ();\n+\n   /* Congruence classes are built by hash value.  */\n   void build_hash_based_classes (void);\n "}]}