{"sha": "34f89b5f682060e18cc4ba8dfaba8be1d309d5d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRmODliNWY2ODIwNjBlMThjYzRiYThkZmFiYThiZTFkMzA5ZDVkMw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-10-02T10:21:20Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-02T10:21:20Z"}, "message": "global.c (global_alloc): Delete code to manage the scratch_list.\n\n\t* global.c (global_alloc): Delete code to manage the scratch_list.\n\t* local-alloc.c (qty_scratch_rtx): Delete.\n\t(scratch_block): Delete.\n\t(scratch_list): Delete.\n\t(scratch_list_length): Delete.\n\t(scratch_index): Delete.\n\t(alloc_qty_for_scratch): Delete.\n\t(local-alloc): Update initialization of max_qty.\n\tDelete code to manage the scratch list.\n\tDelete code to allocate/initialize qty_scratch_rtx.\n\t(block_alloc): Don't allocate quantities for scratches.\n\tDelete code to manage the scratch list.\n\t* regs.h (scratch_list): Delete declaration.\n\t(scratch_block): Delete declaration.\n\t(scratch_list_length): Delete declaration.\n\t* reload1.c (reload): Delete code to manage the scratch list.\n\t(spill_hard_reg): Likewise.\n\t(mark_scratch_live): Delete.\n\nFrom-SVN: r22751", "tree": {"sha": "cc757909a43c13cae9d06d36541edf2dd5023758", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc757909a43c13cae9d06d36541edf2dd5023758"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34f89b5f682060e18cc4ba8dfaba8be1d309d5d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34f89b5f682060e18cc4ba8dfaba8be1d309d5d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34f89b5f682060e18cc4ba8dfaba8be1d309d5d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34f89b5f682060e18cc4ba8dfaba8be1d309d5d3/comments", "author": null, "committer": null, "parents": [{"sha": "4afb3646a5d46f24202d139f7c58748daab18ff6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4afb3646a5d46f24202d139f7c58748daab18ff6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4afb3646a5d46f24202d139f7c58748daab18ff6"}], "stats": {"total": 240, "additions": 23, "deletions": 217}, "files": [{"sha": "b9fc7bdae85a6558c862e761ed542433170e42ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f89b5f682060e18cc4ba8dfaba8be1d309d5d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f89b5f682060e18cc4ba8dfaba8be1d309d5d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=34f89b5f682060e18cc4ba8dfaba8be1d309d5d3", "patch": "@@ -1,5 +1,24 @@\n Fri Oct  2 10:51:35 1998  Bernd Schmidt <crux@Pool.Informatik.RWTH-Aachen.DE>\n \n+\t* global.c (global_alloc): Delete code to manage the scratch_list.\n+\t* local-alloc.c (qty_scratch_rtx): Delete.\n+\t(scratch_block): Delete.\n+\t(scratch_list): Delete.\n+\t(scratch_list_length): Delete.\n+\t(scratch_index): Delete.\n+\t(alloc_qty_for_scratch): Delete.\n+\t(local-alloc): Update initialization of max_qty.\n+\tDelete code to manage the scratch list.\n+\tDelete code to allocate/initialize qty_scratch_rtx.\n+\t(block_alloc): Don't allocate quantities for scratches.\n+\tDelete code to manage the scratch list.\n+\t* regs.h (scratch_list): Delete declaration.\n+\t(scratch_block): Delete declaration.\n+\t(scratch_list_length): Delete declaration.\n+\t* reload1.c (reload): Delete code to manage the scratch list.\n+\t(spill_hard_reg): Likewise.\n+\t(mark_scratch_live): Delete.\n+\n \t* recog.c (alter_subreg): Delete declaration.\n \n 1998-10-02  Andreas Jaeger  <aj@arthur.rhein-neckar.de>"}, {"sha": "e7edb6d36acae99c7f27c39999be449f7d7e8f5c", "filename": "gcc/global.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f89b5f682060e18cc4ba8dfaba8be1d309d5d3/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f89b5f682060e18cc4ba8dfaba8be1d309d5d3/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=34f89b5f682060e18cc4ba8dfaba8be1d309d5d3", "patch": "@@ -450,18 +450,6 @@ global_alloc (file)\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (regs_ever_live[i])\n       local_reg_n_refs[i] = 0;\n-\n-  /* Likewise for regs used in a SCRATCH.  */\n-  for (i = 0; i < scratch_list_length; i++)\n-    if (scratch_list[i])\n-      {\n-\tint regno = REGNO (scratch_list[i]);\n-\tint lim = regno + HARD_REGNO_NREGS (regno, GET_MODE (scratch_list[i]));\n-\tint j;\n-\n-\tfor (j = regno; j < lim; j++)\n-\t  local_reg_n_refs[j] = 0;\n-      }\n \t\n   /* Allocate the space for the conflict and preference tables and\n      initialize them.  */"}, {"sha": "3bcd4f8e1b191ba2237a2c1c3607700807bf9961", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 4, "deletions": 143, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f89b5f682060e18cc4ba8dfaba8be1d309d5d3/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f89b5f682060e18cc4ba8dfaba8be1d309d5d3/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=34f89b5f682060e18cc4ba8dfaba8be1d309d5d3", "patch": "@@ -156,19 +156,14 @@ static int *qty_n_calls_crossed;\n \n static enum reg_class *qty_alternate_class;\n \n-/* Element Q is the SCRATCH expression for which this quantity is being\n-   allocated or 0 if this quantity is allocating registers.  */\n-\n-static rtx *qty_scratch_rtx;\n-\n /* Element Q is nonzero if this quantity has been used in a SUBREG\n    that changes its size.  */\n \n static char *qty_changes_size;\n \n /* Element Q is the register number of one pseudo register whose\n-   reg_qty value is Q, or -1 is this quantity is for a SCRATCH.  This\n-   register should be the head of the chain maintained in reg_next_in_qty.  */\n+   reg_qty value is Q.  This register should be the head of the chain\n+   maintained in reg_next_in_qty.  */\n \n static int *qty_first_reg;\n \n@@ -227,11 +222,6 @@ static HARD_REG_SET regs_live;\n \n static HARD_REG_SET *regs_live_at;\n \n-int *scratch_block;\n-rtx *scratch_list;\n-int scratch_list_length;\n-static int scratch_index;\n-\n /* Communicate local vars `insn_number' and `insn'\n    from `block_alloc' to `reg_is_set', `wipe_dead_reg', and `alloc_qty'.  */\n static int this_insn_number;\n@@ -245,7 +235,6 @@ static rtx this_insn;\n static rtx *reg_equiv_replacement;\n \n static void alloc_qty\t\tPROTO((int, enum machine_mode, int, int));\n-static void alloc_qty_for_scratch PROTO((rtx, int, rtx, int, int));\n static void validate_equiv_mem_from_store PROTO((rtx, rtx));\n static int validate_equiv_mem\tPROTO((rtx, rtx, rtx));\n static int contains_replace_regs PROTO((rtx, char *));\n@@ -297,96 +286,6 @@ alloc_qty (regno, mode, size, birth)\n   qty_changes_size[qty] = REG_CHANGES_SIZE (regno);\n }\n \f\n-/* Similar to `alloc_qty', but allocates a quantity for a SCRATCH rtx\n-   used as operand N in INSN.  We assume here that the SCRATCH is used in\n-   a CLOBBER.  */\n-\n-static void\n-alloc_qty_for_scratch (scratch, n, insn, insn_code_num, insn_number)\n-     rtx scratch;\n-     int n;\n-     rtx insn;\n-     int insn_code_num, insn_number;\n-{\n-  register int qty;\n-  enum reg_class class;\n-  char *p, c;\n-  int i;\n-\n-#ifdef REGISTER_CONSTRAINTS\n-  /* If we haven't yet computed which alternative will be used, do so now.\n-     Then set P to the constraints for that alternative.  */\n-  if (which_alternative == -1)\n-    if (! constrain_operands (insn_code_num, 0))\n-      return;\n-\n-  for (p = insn_operand_constraint[insn_code_num][n], i = 0;\n-       *p && i < which_alternative; p++)\n-    if (*p == ',')\n-      i++;\n-\n-  /* Compute the class required for this SCRATCH.  If we don't need a\n-     register, the class will remain NO_REGS.  If we guessed the alternative\n-     number incorrectly, reload will fix things up for us.  */\n-\n-  class = NO_REGS;\n-  while ((c = *p++) != '\\0' && c != ',')\n-    switch (c)\n-      {\n-      case '=':  case '+':  case '?':\n-      case '#':  case '&':  case '!':\n-      case '*':  case '%':  \n-      case '0':  case '1':  case '2':  case '3':  case '4':\n-      case 'm':  case '<':  case '>':  case 'V':  case 'o':\n-      case 'E':  case 'F':  case 'G':  case 'H':\n-      case 's':  case 'i':  case 'n':\n-      case 'I':  case 'J':  case 'K':  case 'L':\n-      case 'M':  case 'N':  case 'O':  case 'P':\n-#ifdef EXTRA_CONSTRAINT\n-      case 'Q':  case 'R':  case 'S':  case 'T':  case 'U':\n-#endif\n-      case 'p':\n-\t/* These don't say anything we care about.  */\n-\tbreak;\n-\n-      case 'X':\n-\t/* We don't need to allocate this SCRATCH.  */\n-\treturn;\n-\n-      case 'g': case 'r':\n-\tclass = reg_class_subunion[(int) class][(int) GENERAL_REGS];\n-\tbreak;\n-\n-      default:\n-\tclass\n-\t  = reg_class_subunion[(int) class][(int) REG_CLASS_FROM_LETTER (c)];\n-\tbreak;\n-      }\n-\n-  if (class == NO_REGS)\n-    return;\n-\n-#else /* REGISTER_CONSTRAINTS */\n-\n-  class = GENERAL_REGS;\n-#endif\n-  \n-\n-  qty = next_qty++;\n-\n-  qty_first_reg[qty] = -1;\n-  qty_scratch_rtx[qty] = scratch;\n-  qty_size[qty] = GET_MODE_SIZE (GET_MODE (scratch));\n-  qty_mode[qty] = GET_MODE (scratch);\n-  qty_birth[qty] = 2 * insn_number - 1;\n-  qty_death[qty] = 2 * insn_number + 1;\n-  qty_n_calls_crossed[qty] = 0;\n-  qty_min_class[qty] = class;\n-  qty_alternate_class[qty] = NO_REGS;\n-  qty_n_refs[qty] = 1;\n-  qty_changes_size[qty] = 0;\n-}\n-\f\n /* Main entry point of this file.  */\n \n void\n@@ -407,26 +306,13 @@ local_alloc ()\n   update_equiv_regs ();\n \n   /* This sets the maximum number of quantities we can have.  Quantity\n-     numbers start at zero and we can have one for each pseudo plus the\n-     number of SCRATCHes in the largest block, in the worst case.  */\n-  max_qty = (max_regno - FIRST_PSEUDO_REGISTER) + max_scratch;\n+     numbers start at zero and we can have one for each pseudo.  */\n+  max_qty = (max_regno - FIRST_PSEUDO_REGISTER);\n \n   /* Allocate vectors of temporary data.\n      See the declarations of these variables, above,\n      for what they mean.  */\n \n-  /* There can be up to MAX_SCRATCH * N_BASIC_BLOCKS SCRATCHes to allocate.\n-     Instead of allocating this much memory from now until the end of\n-     reload, only allocate space for MAX_QTY SCRATCHes.  If there are more\n-     reload will allocate them.  */\n-\n-  scratch_list_length = max_qty;\n-  scratch_list = (rtx *) xmalloc (scratch_list_length * sizeof (rtx));\n-  bzero ((char *) scratch_list, scratch_list_length * sizeof (rtx));\n-  scratch_block = (int *) xmalloc (scratch_list_length * sizeof (int));\n-  bzero ((char *) scratch_block, scratch_list_length * sizeof (int));\n-  scratch_index = 0;\n-\n   qty_phys_reg = (short *) alloca (max_qty * sizeof (short));\n   qty_phys_copy_sugg\n     = (HARD_REG_SET *) alloca (max_qty * sizeof (HARD_REG_SET));\n@@ -435,7 +321,6 @@ local_alloc ()\n   qty_phys_num_sugg = (short *) alloca (max_qty * sizeof (short));\n   qty_birth = (int *) alloca (max_qty * sizeof (int));\n   qty_death = (int *) alloca (max_qty * sizeof (int));\n-  qty_scratch_rtx = (rtx *) alloca (max_qty * sizeof (rtx));\n   qty_first_reg = (int *) alloca (max_qty * sizeof (int));\n   qty_size = (int *) alloca (max_qty * sizeof (int));\n   qty_mode\n@@ -493,7 +378,6 @@ local_alloc ()\n \t{\n \t  for (i = 0; i < next_qty; i++)\n \t    {\n-\t      qty_scratch_rtx[i] = 0;\n \t      CLEAR_HARD_REG_SET (qty_phys_copy_sugg[i]);\n \t      qty_phys_num_copy_sugg[i] = 0;\n \t      CLEAR_HARD_REG_SET (qty_phys_sugg[i]);\n@@ -505,7 +389,6 @@ local_alloc ()\n #define CLEAR(vector)  \\\n \t  bzero ((char *) (vector), (sizeof (*(vector))) * next_qty);\n \n-\t  CLEAR (qty_scratch_rtx);\n \t  CLEAR (qty_phys_copy_sugg);\n \t  CLEAR (qty_phys_num_copy_sugg);\n \t  CLEAR (qty_phys_sugg);\n@@ -1029,9 +912,6 @@ block_alloc (b)\n   int max_uid = get_max_uid ();\n   int *qty_order;\n   int no_conflict_combined_regno = -1;\n-  /* Counter to prevent allocating more SCRATCHes than can be stored\n-     in SCRATCH_LIST.  */\n-  int scratches_allocated = scratch_index;\n \n   /* Count the instructions in the basic block.  */\n \n@@ -1285,15 +1165,6 @@ block_alloc (b)\n \t\t&& GET_CODE (XEXP (link, 0)) == REG)\n \t      wipe_dead_reg (XEXP (link, 0), 1);\n \n-\t  /* Allocate quantities for any SCRATCH operands of this insn.  */\n-\n-\t  if (insn_code_number >= 0)\n-\t    for (i = 0; i < insn_n_operands[insn_code_number]; i++)\n-\t      if (GET_CODE (recog_operand[i]) == SCRATCH\n-\t\t  && scratches_allocated++ < scratch_list_length)\n-\t\talloc_qty_for_scratch (recog_operand[i], i, insn,\n-\t\t\t\t       insn_code_number, insn_number);\n-\n \t  /* If this is an insn that has a REG_RETVAL note pointing at a \n \t     CLOBBER insn, we have reached the end of a REG_NO_CONFLICT\n \t     block, so clear any register number that combined within it.  */\n@@ -1492,16 +1363,6 @@ block_alloc (b)\n       {\n \tfor (i = qty_first_reg[q]; i >= 0; i = reg_next_in_qty[i])\n \t  reg_renumber[i] = qty_phys_reg[q] + reg_offset[i];\n-\tif (qty_scratch_rtx[q])\n-\t  {\n-\t    if (GET_CODE (qty_scratch_rtx[q]) == REG)\n-\t      abort ();\n-\t    qty_scratch_rtx[q] = gen_rtx_REG (GET_MODE (qty_scratch_rtx[q]),\n-\t\t\t\t\t      qty_phys_reg[q]);\n-\t    scratch_block[scratch_index] = b;\n-\t    scratch_list[scratch_index++] = qty_scratch_rtx[q];\n-\n-\t  }\n       }\n }\n \f"}, {"sha": "1ececb3c6a7b017e740dd35e66929f2541d475ad", "filename": "gcc/regs.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f89b5f682060e18cc4ba8dfaba8be1d309d5d3/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f89b5f682060e18cc4ba8dfaba8be1d309d5d3/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=34f89b5f682060e18cc4ba8dfaba8be1d309d5d3", "patch": "@@ -223,14 +223,5 @@ extern int caller_save_needed;\n #define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE) 0\n #endif\n \n-/* Allocated in local_alloc.  */\n-\n-/* A list of SCRATCH rtl allocated by local-alloc.  */\n-extern rtx *scratch_list;\n-/* The basic block in which each SCRATCH is used.  */\n-extern int *scratch_block;\n-/* The length of the arrays pointed to by scratch_block and scratch_list.  */\n-extern int scratch_list_length;\n-\n /* Allocate reg_n_info tables */\n extern void allocate_reg_info PROTO((size_t, int, int));"}, {"sha": "93745e1779dbaeeddf25b4fa36df6e9de2bf77d2", "filename": "gcc/reload1.c", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34f89b5f682060e18cc4ba8dfaba8be1d309d5d3/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34f89b5f682060e18cc4ba8dfaba8be1d309d5d3/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=34f89b5f682060e18cc4ba8dfaba8be1d309d5d3", "patch": "@@ -364,7 +364,6 @@ static int new_spill_reg\t\tPROTO((int, int, int *, int *, int,\n \t\t\t\t\t       FILE *));\n static void delete_dead_insn\t\tPROTO((rtx));\n static void alter_reg  \t\t\tPROTO((int, int));\n-static void mark_scratch_live\t\tPROTO((rtx));\n static void set_label_offsets\t\tPROTO((rtx, rtx, int));\n static int eliminate_regs_in_insn\tPROTO((rtx, int));\n static void mark_not_eliminable\t\tPROTO((rtx, rtx));\n@@ -645,10 +644,6 @@ reload (first, global, dumpfile)\n \t  regs_ever_live[i] = 1;\n       }\n \n-  for (i = 0; i < scratch_list_length; i++)\n-    if (scratch_list[i])\n-      mark_scratch_live (scratch_list[i]);\n-\n   /* Make sure that the last insn in the chain\n      is not something that needs reloading.  */\n   emit_note (NULL_PTR, NOTE_INSN_DELETED);\n@@ -1388,13 +1383,6 @@ reload (first, global, dumpfile)\n   if (real_at_ptr)\n     free (real_at_ptr);\n \n-  if (scratch_list)\n-    free (scratch_list);\n-  scratch_list = 0;\n-  if (scratch_block)\n-    free (scratch_block);\n-  scratch_block = 0;\n-\n   free (reg_equiv_constant);\n   free (reg_equiv_memory_loc);\n   free (reg_equiv_mem);\n@@ -2687,20 +2675,6 @@ mark_home_live (regno)\n   while (i < lim)\n     regs_ever_live[i++] = 1;\n }\n-\n-/* Mark the registers used in SCRATCH as being live.  */\n-\n-static void\n-mark_scratch_live (scratch)\n-     rtx scratch;\n-{\n-  register int i;\n-  int regno = REGNO (scratch);\n-  int lim = regno + HARD_REGNO_NREGS (regno, GET_MODE (scratch));\n-\n-  for (i = regno; i < lim; i++)\n-    regs_ever_live[i] = 1;\n-}\n \f\n /* This function handles the tracking of elimination offsets around branches.\n \n@@ -3824,33 +3798,6 @@ spill_hard_reg (regno, global, dumpfile, cant_eliminate)\n \t\t       i, reg_renumber[i]);\n \t  }\n       }\n-  for (i = 0; i < scratch_list_length; i++)\n-    {\n-     if (scratch_list[i] \n-          && regno >= REGNO (scratch_list[i]) \n-          && regno <  REGNO (scratch_list[i]) \n-                      + HARD_REGNO_NREGS (REGNO (scratch_list[i]),\n-                                          GET_MODE (scratch_list[i])))\n-\t{\n-\t  if (! cant_eliminate && basic_block_needs[0]\n-\t      && ! basic_block_needs[(int) class][scratch_block[i]])\n-\t    {\n-\t      enum reg_class *p;\n-\n-\t      for (p = reg_class_superclasses[(int) class];\n-\t\t   *p != LIM_REG_CLASSES; p++)\n-\t\tif (basic_block_needs[(int) *p][scratch_block[i]] > 0)\n-\t\t  break;\n-\n-\t      if (*p == LIM_REG_CLASSES)\n-\t\tcontinue;\n-\t    }\n-\t  PUT_CODE (scratch_list[i], SCRATCH);\n-\t  scratch_list[i] = 0;\n-\t  something_changed = 1;\n-\t  continue;\n-\t}\n-    }\n \n   return something_changed;\n }"}]}