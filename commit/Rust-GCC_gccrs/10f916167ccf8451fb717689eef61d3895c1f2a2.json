{"sha": "10f916167ccf8451fb717689eef61d3895c1f2a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBmOTE2MTY3Y2NmODQ1MWZiNzE3Njg5ZWVmNjFkMzg5NWMxZjJhMg==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2014-11-22T15:50:10Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2014-11-22T15:50:10Z"}, "message": "re PR target/63783 ([SH] Miscompilation of boolean negation on SH4 using -O2)\n\ngcc/\n\tPR target/63783\n\tPR target/51244\n\t* config/sh/sh_treg_combine.cc (sh_treg_combine::make_not_reg_insn):\n\tDo not emit bitwise not insn.  Emit logical not insn sequence instead.\n\tAdjust related comments throughout the file.\n\ngcc/testsuite/\n\tPR target/63783\n\tPR target/51244\n\t* gcc.target/sh/torture/pr63783-1.c: New.\n\t* gcc.target/sh/torture/pr63783-2.c: New.\n\t* gcc.target/sh/pr51244-20.c: Adjust.\n\t* gcc.target/sh/pr51244-20-sh2a.c: Adjust.\n\nFrom-SVN: r217969", "tree": {"sha": "3b53032d91c81a0483629d4862477fbb857ea682", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b53032d91c81a0483629d4862477fbb857ea682"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10f916167ccf8451fb717689eef61d3895c1f2a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10f916167ccf8451fb717689eef61d3895c1f2a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10f916167ccf8451fb717689eef61d3895c1f2a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10f916167ccf8451fb717689eef61d3895c1f2a2/comments", "author": null, "committer": null, "parents": [{"sha": "355e99758bceb3ffed95a0c4fc41fb348e0109d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355e99758bceb3ffed95a0c4fc41fb348e0109d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/355e99758bceb3ffed95a0c4fc41fb348e0109d3"}], "stats": {"total": 140, "additions": 122, "deletions": 18}, "files": [{"sha": "cd28dc43474350f69a99527403831cafbb8b7cd4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f916167ccf8451fb717689eef61d3895c1f2a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f916167ccf8451fb717689eef61d3895c1f2a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10f916167ccf8451fb717689eef61d3895c1f2a2", "patch": "@@ -1,3 +1,11 @@\n+2014-11-22  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/63783\n+\tPR target/51244\n+\t* config/sh/sh_treg_combine.cc (sh_treg_combine::make_not_reg_insn):\n+\tDo not emit bitwise not insn.  Emit logical not insn sequence instead.\n+\tAdjust related comments throughout the file.\n+\n 2014-11-22  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/63986"}, {"sha": "68c7fc1cc6d1c65c0d8e8bf2e327516ee24256c8", "filename": "gcc/config/sh/sh_treg_combine.cc", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f916167ccf8451fb717689eef61d3895c1f2a2/gcc%2Fconfig%2Fsh%2Fsh_treg_combine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f916167ccf8451fb717689eef61d3895c1f2a2/gcc%2Fconfig%2Fsh%2Fsh_treg_combine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh_treg_combine.cc?ref=10f916167ccf8451fb717689eef61d3895c1f2a2", "patch": "@@ -95,14 +95,17 @@ Example 1)\n \n In [bb 4] elimination of the comparison would require inversion of the branch\n condition and compensation of other BBs.\n-Instead an inverting reg-move can be used:\n+Instead the comparison in [bb 3] can be replaced with the comparison in [bb 5]\n+by using a reg-reg move.  In [bb 4] a logical not is used to compensate the\n+inverted condition.\n \n [bb 3]\n (set (reg:SI 167) (reg:SI 173))\n -> bb 5\n \n [BB 4]\n-(set (reg:SI 167) (not:SI (reg:SI 177)))\n+(set (reg:SI 147 t) (eq:SI (reg:SI 177) (const_int 0)))\n+(set (reg:SI 167) (reg:SI 147 t))\n -> bb 5\n \n [bb 5]\n@@ -231,9 +234,9 @@ In order to handle cases such as above the RTL pass does the following:\n       and replace the comparisons in the BBs with reg-reg copies to get the\n       operands in place (create new pseudo regs).\n \n-    - If the cstores differ, try to apply the special case\n-        (eq (reg) (const_int 0)) -> inverted = (not (reg)).\n-      for the subordinate cstore types and eliminate the dominating ones.\n+    - If the cstores differ and the comparison is a test against zero,\n+      use reg-reg copies for the dominating cstores and logical not cstores\n+      for the subordinate cstores.\n \n - If the comparison types in the BBs are not the same, or the first approach\n   doesn't work out for some reason, try to eliminate the comparison before the\n@@ -576,7 +579,8 @@ class sh_treg_combine : public rtl_opt_pass\n   bool can_extend_ccreg_usage (const bb_entry& e,\n \t\t\t       const cbranch_trace& trace) const;\n \n-  // Create an insn rtx that is a negating reg move (not operation).\n+  // Create an insn rtx that performs a logical not (test != 0) on the src_reg\n+  // and stores the result in dst_reg.\n   rtx make_not_reg_insn (rtx dst_reg, rtx src_reg) const;\n \n   // Create an insn rtx that inverts the ccreg.\n@@ -907,12 +911,32 @@ sh_treg_combine::can_remove_comparison (const bb_entry& e,\n rtx\n sh_treg_combine::make_not_reg_insn (rtx dst_reg, rtx src_reg) const\n {\n-  // This will to go through expanders and may output multiple insns\n-  // for multi-word regs.\n+  // On SH we can do only SImode and DImode comparisons.\n+  if (! (GET_MODE (src_reg) == SImode || GET_MODE (src_reg) == DImode))\n+    return NULL;\n+\n+  // On SH we can store the ccreg into an SImode or DImode reg only.\n+  if (! (GET_MODE (dst_reg) == SImode || GET_MODE (dst_reg) == DImode))\n+    return NULL;\n+\n   start_sequence ();\n-  expand_simple_unop (GET_MODE (dst_reg), NOT, src_reg, dst_reg, 0);\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, m_ccreg,\n+\t\t\t  gen_rtx_fmt_ee (EQ, SImode, src_reg, const0_rtx)));\n+\n+  if (GET_MODE (dst_reg) == SImode)\n+    emit_move_insn (dst_reg, m_ccreg);\n+  else if (GET_MODE (dst_reg) == DImode)\n+    {\n+      emit_move_insn (gen_lowpart (SImode, dst_reg), m_ccreg);\n+      emit_move_insn (gen_highpart (SImode, dst_reg), const0_rtx);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n   rtx i = get_insns ();\n   end_sequence ();\n+\n   return i;\n }\n \n@@ -1095,7 +1119,12 @@ sh_treg_combine::try_combine_comparisons (cbranch_trace& trace,\n   // There is one special case though, where an integer comparison\n   //     (eq (reg) (const_int 0))\n   // can be inverted with a sequence\n-  //     (eq (not (reg)) (const_int 0))\n+  //     (set (t) (eq (reg) (const_int 0))\n+  //     (set (reg) (t))\n+  //     (eq (reg) (const_int 0))\n+  //\n+  // FIXME: On SH2A it might be better to use the nott insn in this case,\n+  // i.e. do the try_eliminate_cstores approach instead.\n   if (inv_cstore_count != 0 && cstore_count != 0)\n     {\n       if (make_not_reg_insn (comp_op0, comp_op0) == NULL_RTX)"}, {"sha": "6cd4690dc9aefd29cc08c6765939db77c76ad776", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f916167ccf8451fb717689eef61d3895c1f2a2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f916167ccf8451fb717689eef61d3895c1f2a2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=10f916167ccf8451fb717689eef61d3895c1f2a2", "patch": "@@ -1,3 +1,12 @@\n+2014-11-22  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/63783\n+\tPR target/51244\n+\t* gcc.target/sh/torture/pr63783-1.c: New.\n+\t* gcc.target/sh/torture/pr63783-2.c: New.\n+\t* gcc.target/sh/pr51244-20.c: Adjust.\n+\t* gcc.target/sh/pr51244-20-sh2a.c: Adjust.\n+\n 2014-11-22  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.dg/coarray/cosubscript_1.f90: New."}, {"sha": "3208f932addc13c684d3b179d9b24af080ffd609", "filename": "gcc/testsuite/gcc.target/sh/pr51244-20-sh2a.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f916167ccf8451fb717689eef61d3895c1f2a2/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-20-sh2a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f916167ccf8451fb717689eef61d3895c1f2a2/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-20-sh2a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-20-sh2a.c?ref=10f916167ccf8451fb717689eef61d3895c1f2a2", "patch": "@@ -3,12 +3,12 @@\n /* { dg-do compile }  */\n /* { dg-options \"-O2\" } */\n /* { dg-skip-if \"\" { \"sh*-*-*\" } { \"*\" } { \"-m2a*\" } } */\n-/* { dg-final { scan-assembler-times \"tst\" 5 } } */\n-/* { dg-final { scan-assembler-times \"movt\" 0 } } */\n+/* { dg-final { scan-assembler-times \"tst\" 6 } } */\n+/* { dg-final { scan-assembler-times \"movt\" 1 } } */\n /* { dg-final { scan-assembler-times \"nott\" 1 } } */\n /* { dg-final { scan-assembler-times \"cmp/eq\" 2 } } */\n /* { dg-final { scan-assembler-times \"cmp/hi\" 4 } } */\n /* { dg-final { scan-assembler-times \"cmp/gt\" 3 } } */\n-/* { dg-final { scan-assembler-times \"not\\t\" 1 } } */\n+/* { dg-final { scan-assembler-not \"not\\t\" } } */\n \n #include \"pr51244-20.c\""}, {"sha": "aad6a2fd34fc67e511747729e6ba478313280a5c", "filename": "gcc/testsuite/gcc.target/sh/pr51244-20.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f916167ccf8451fb717689eef61d3895c1f2a2/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f916167ccf8451fb717689eef61d3895c1f2a2/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-20.c?ref=10f916167ccf8451fb717689eef61d3895c1f2a2", "patch": "@@ -1,15 +1,15 @@\n /* Check that the SH specific sh_treg_combine RTL optimization pass works as\n    expected.  On SH2A the expected insns are slightly different, see\n-   pr51244-21.c.  */\n+   pr51244-20-sh2a.c.  */\n /* { dg-do compile }  */\n /* { dg-options \"-O2\" } */\n /* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" \"-m2a*\" } { \"\" } } */\n-/* { dg-final { scan-assembler-times \"tst\" 6 } } */\n-/* { dg-final { scan-assembler-times \"movt\" 1 } } */\n+/* { dg-final { scan-assembler-times \"tst\" 7 } } */\n+/* { dg-final { scan-assembler-times \"movt\" 2 } } */\n /* { dg-final { scan-assembler-times \"cmp/eq\" 2 } } */\n /* { dg-final { scan-assembler-times \"cmp/hi\" 4 } } */\n /* { dg-final { scan-assembler-times \"cmp/gt\" 2 } } */\n-/* { dg-final { scan-assembler-times \"not\\t\" 1 } } */\n+/* { dg-final { scan-assembler-not \"not\\t\" } } */\n \n \n /* non-SH2A: 2x tst, 1x movt, 2x cmp/eq, 1x cmp/hi\n@@ -81,7 +81,7 @@ get_request_2 (int* q, int rw)\n }\n \n \n-/* 2x tst, 1x cmp/hi, 1x not  */\n+/* 3x tst, 1x movt, 1x cmp/hi, 1x not  */\n static inline int\n blk_oversized_queue_5 (int* q)\n {"}, {"sha": "f18beadd9c87b614b035fc7ae466bd650d9be969", "filename": "gcc/testsuite/gcc.target/sh/torture/pr63783-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f916167ccf8451fb717689eef61d3895c1f2a2/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Ftorture%2Fpr63783-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f916167ccf8451fb717689eef61d3895c1f2a2/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Ftorture%2Fpr63783-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Ftorture%2Fpr63783-1.c?ref=10f916167ccf8451fb717689eef61d3895c1f2a2", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run }  */\n+/* { dg-additional-options \"-std=c99\" }  */\n+\n+#include <assert.h>\n+\n+int decision_result;\n+int val;\n+int truecount = 0;\n+\n+static void __attribute__((noinline))\n+buggy (int flag)\n+{\n+  int condition;\n+  if(flag == 0)\n+    condition = val != 0;\n+  else\n+    condition = !decision_result;\n+  if (condition)\n+     truecount++;\n+}\n+\n+int\n+main (void)\n+{\n+  decision_result = 1;\n+  buggy(1);\n+  assert (truecount == 0);\n+  return 0;\n+}"}, {"sha": "c0bc9116c238614299553793a1933030576eb71b", "filename": "gcc/testsuite/gcc.target/sh/torture/pr63783-2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f916167ccf8451fb717689eef61d3895c1f2a2/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Ftorture%2Fpr63783-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f916167ccf8451fb717689eef61d3895c1f2a2/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Ftorture%2Fpr63783-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Ftorture%2Fpr63783-2.c?ref=10f916167ccf8451fb717689eef61d3895c1f2a2", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run }  */\n+/* { dg-additional-options \"-std=c99\" }  */\n+\n+#include <assert.h>\n+\n+long long decision_result;\n+long long val;\n+int truecount = 0;\n+\n+static void __attribute__((noinline))\n+buggy (int flag)\n+{\n+  int condition;\n+  if(flag == 0)\n+    condition = val != 0;\n+  else\n+    condition = !decision_result;\n+  if (condition)\n+     truecount++;\n+}\n+\n+int\n+main (void)\n+{\n+  decision_result = 1;\n+  buggy(1);\n+  assert (truecount == 0);\n+  return 0;\n+}"}]}