{"sha": "7a54d3deecf967029f18aa5ed1fcbdb752e213b9", "node_id": "C_kwDOANBUbNoAKDdhNTRkM2RlZWNmOTY3MDI5ZjE4YWE1ZWQxZmNiZGI3NTJlMjEzYjk", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2021-12-14T17:27:22Z"}, "committer": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2021-12-14T17:28:21Z"}, "message": "i386: Implement VxHF vector set/insert/extract with lower ABI levels\n\nThis is a preparation patch that moves VxHF vector set/insert/extract\nexpansions from AVX512FP16 ABI to lower ABIs.  There are no functional\nchanges for -mavx512fp16 and a follow-up patch is needed to actually\nenable VxHF vector modes for lower ABIs.\n\n2021-12-14  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n\ngcc/ChangeLog:\n\n\tPR target/103571\n\t* config/i386/i386-expand.c (ix86_expand_vector_init_duplicate)\n\t<case E_V8HFmode>: Implement for TARGET_SSE2.\n\t<case E_V16HFmode>: Implement for TARGET_AVX.\n\t<case E_V32HFmode>: Implement for TARGET_AVX512F.\n\t(ix86_expand_vector_set_var): Handle V32HFmode\n\twithout TARGET_AVX512BW.\n\t(ix86_expand_vector_extract)\n\t<case E_V8HFmode>: Implement for TARGET_SSE2.\n\t<case E_V16HFmode>: Implement for TARGET_AVX.\n\t<case E_V32HFmode>: Implement for TARGET_AVX512BW.\n\t(expand_vec_perm_broadcast_1) <case E_V8HFmode>: New.\n\t* config/i386/sse.md (VI12HF_AVX512VL): Remove\n\tTARGET_AVX512FP16 condition.\n\t(V): Ditto.\n\t(V_256_512): Ditto.\n\t(avx_vbroadcastf128_<mode>): Use V_256H mode iterator.", "tree": {"sha": "849f669059e68fe9a6a5315740601242f58e6664", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/849f669059e68fe9a6a5315740601242f58e6664"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a54d3deecf967029f18aa5ed1fcbdb752e213b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a54d3deecf967029f18aa5ed1fcbdb752e213b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a54d3deecf967029f18aa5ed1fcbdb752e213b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a54d3deecf967029f18aa5ed1fcbdb752e213b9/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cf62ef5aa80e3659a8150a48d93a1d333f1d292", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cf62ef5aa80e3659a8150a48d93a1d333f1d292", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cf62ef5aa80e3659a8150a48d93a1d333f1d292"}], "stats": {"total": 137, "additions": 91, "deletions": 46}, "files": [{"sha": "7013c20a97a7644a69abc21ffa5a75cf203e63fb", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 83, "deletions": 35, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a54d3deecf967029f18aa5ed1fcbdb752e213b9/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a54d3deecf967029f18aa5ed1fcbdb752e213b9/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=7a54d3deecf967029f18aa5ed1fcbdb752e213b9", "patch": "@@ -14855,6 +14855,7 @@ ix86_expand_vector_init_duplicate (bool mmx_ok, machine_mode mode,\n       goto widen;\n \n     case E_V8HImode:\n+    case E_V8HFmode:\n       if (TARGET_AVX2)\n \treturn ix86_vector_duplicate_value (mode, target, val);\n \n@@ -14871,15 +14872,22 @@ ix86_expand_vector_init_duplicate (bool mmx_ok, machine_mode mode,\n \t  dperm.op0 = dperm.op1 = gen_reg_rtx (mode);\n \t  dperm.one_operand_p = true;\n \n-\t  /* Extend to SImode using a paradoxical SUBREG.  */\n-\t  tmp1 = gen_reg_rtx (SImode);\n-\t  emit_move_insn (tmp1, gen_lowpart (SImode, val));\n-\n-\t  /* Insert the SImode value as low element of a V4SImode vector.  */\n-\t  tmp2 = gen_reg_rtx (V4SImode);\n-\t  emit_insn (gen_vec_setv4si_0 (tmp2, CONST0_RTX (V4SImode), tmp1));\n-\t  emit_move_insn (dperm.op0, gen_lowpart (mode, tmp2));\n+\t  if (mode == V8HFmode)\n+\t    tmp1 = lowpart_subreg (V8HFmode, force_reg (HFmode, val), HFmode);\n+\t  else\n+\t    {\n+\t      /* Extend to SImode using a paradoxical SUBREG.  */\n+\t      tmp1 = gen_reg_rtx (SImode);\n+\t      emit_move_insn (tmp1, gen_lowpart (SImode, val));\n+\n+\t      /* Insert the SImode value as\n+\t\t low element of a V4SImode vector.  */\n+\t      tmp2 = gen_reg_rtx (V4SImode);\n+\t      emit_insn (gen_vec_setv4si_0 (tmp2, CONST0_RTX (V4SImode), tmp1));\n+\t      tmp1 = gen_lowpart (mode, tmp2);\n+\t    }\n \n+\t  emit_move_insn (dperm.op0, tmp1);\n \t  ok = (expand_vec_perm_1 (&dperm)\n \t\t|| expand_vec_perm_broadcast_1 (&dperm));\n \t  gcc_assert (ok);\n@@ -14926,12 +14934,15 @@ ix86_expand_vector_init_duplicate (bool mmx_ok, machine_mode mode,\n       }\n \n     case E_V16HImode:\n+    case E_V16HFmode:\n     case E_V32QImode:\n       if (TARGET_AVX2)\n \treturn ix86_vector_duplicate_value (mode, target, val);\n       else\n \t{\n-\t  machine_mode hvmode = (mode == V16HImode ? V8HImode : V16QImode);\n+\t  machine_mode hvmode = (mode == V16HImode ? V8HImode\n+\t\t\t\t : mode == V16HFmode ? V8HFmode\n+\t\t\t\t : V16QImode);\n \t  rtx x = gen_reg_rtx (hvmode);\n \n \t  ok = ix86_expand_vector_init_duplicate (false, hvmode, x, val);\n@@ -14942,13 +14953,16 @@ ix86_expand_vector_init_duplicate (bool mmx_ok, machine_mode mode,\n \t}\n       return true;\n \n-    case E_V64QImode:\n     case E_V32HImode:\n+    case E_V32HFmode:\n+    case E_V64QImode:\n       if (TARGET_AVX512BW)\n \treturn ix86_vector_duplicate_value (mode, target, val);\n       else\n \t{\n-\t  machine_mode hvmode = (mode == V32HImode ? V16HImode : V32QImode);\n+\t  machine_mode hvmode = (mode == V32HImode ? V16HImode\n+\t\t\t\t : mode == V32HFmode ? V16HFmode\n+\t\t\t\t : V32QImode);\n \t  rtx x = gen_reg_rtx (hvmode);\n \n \t  ok = ix86_expand_vector_init_duplicate (false, hvmode, x, val);\n@@ -14959,11 +14973,6 @@ ix86_expand_vector_init_duplicate (bool mmx_ok, machine_mode mode,\n \t}\n       return true;\n \n-    case E_V8HFmode:\n-    case E_V16HFmode:\n-    case E_V32HFmode:\n-      return ix86_vector_duplicate_value (mode, target, val);\n-\n     default:\n       return false;\n     }\n@@ -15912,7 +15921,8 @@ ix86_expand_vector_set_var (rtx target, rtx val, rtx idx)\n   /* 512-bits vector byte/word broadcast and comparison only available\n      under TARGET_AVX512BW, break 512-bits vector into two 256-bits vector\n      when without TARGET_AVX512BW.  */\n-  if ((mode == V32HImode || mode == V64QImode) && !TARGET_AVX512BW)\n+  if ((mode == V32HImode || mode == V32HFmode || mode == V64QImode)\n+      && !TARGET_AVX512BW)\n     {\n       gcc_assert (TARGET_AVX512F);\n       rtx vhi, vlo, idx_hi;\n@@ -15926,6 +15936,12 @@ ix86_expand_vector_set_var (rtx target, rtx val, rtx idx)\n \t  extract_hi = gen_vec_extract_hi_v32hi;\n \t  extract_lo = gen_vec_extract_lo_v32hi;\n \t}\n+      else if (mode == V32HFmode)\n+\t{\n+\t  half_mode = V16HFmode;\n+\t  extract_hi = gen_vec_extract_hi_v32hf;\n+\t  extract_lo = gen_vec_extract_lo_v32hf;\n+\t}\n       else\n \t{\n \t  half_mode = V32QImode;\n@@ -15973,7 +15989,6 @@ ix86_expand_vector_set_var (rtx target, rtx val, rtx idx)\n \tcase E_V16SFmode:\n \t  cmp_mode = V16SImode;\n \t  break;\n-\t/* TARGET_AVX512FP16 implies TARGET_AVX512BW.  */\n \tcase E_V8HFmode:\n \t  cmp_mode = V8HImode;\n \t  break;\n@@ -16538,6 +16553,7 @@ ix86_expand_vector_extract (bool mmx_ok, rtx target, rtx vec, int elt)\n       break;\n \n     case E_V8HImode:\n+    case E_V8HFmode:\n     case E_V2HImode:\n       use_vec_extr = TARGET_SSE2;\n       break;\n@@ -16704,25 +16720,29 @@ ix86_expand_vector_extract (bool mmx_ok, rtx target, rtx vec, int elt)\n       return;\n \n     case E_V32HFmode:\n-      tmp = gen_reg_rtx (V16HFmode);\n-      if (elt < 16)\n-\temit_insn (gen_vec_extract_lo_v32hf (tmp, vec));\n-      else\n-\temit_insn (gen_vec_extract_hi_v32hf (tmp, vec));\n-      ix86_expand_vector_extract (false, target, tmp, elt & 15);\n-      return;\n+      if (TARGET_AVX512BW)\n+\t{\n+\t  tmp = gen_reg_rtx (V16HFmode);\n+\t  if (elt < 16)\n+\t    emit_insn (gen_vec_extract_lo_v32hf (tmp, vec));\n+\t  else\n+\t    emit_insn (gen_vec_extract_hi_v32hf (tmp, vec));\n+\t  ix86_expand_vector_extract (false, target, tmp, elt & 15);\n+\t  return;\n+\t}\n+      break;\n \n     case E_V16HFmode:\n-      tmp = gen_reg_rtx (V8HFmode);\n-      if (elt < 8)\n-\temit_insn (gen_vec_extract_lo_v16hf (tmp, vec));\n-      else\n-\temit_insn (gen_vec_extract_hi_v16hf (tmp, vec));\n-      ix86_expand_vector_extract (false, target, tmp, elt & 7);\n-      return;\n-\n-    case E_V8HFmode:\n-      use_vec_extr = true;\n+      if (TARGET_AVX)\n+\t{\n+\t  tmp = gen_reg_rtx (V8HFmode);\n+\t  if (elt < 8)\n+\t    emit_insn (gen_vec_extract_lo_v16hf (tmp, vec));\n+\t  else\n+\t    emit_insn (gen_vec_extract_hi_v16hf (tmp, vec));\n+\t  ix86_expand_vector_extract (false, target, tmp, elt & 7);\n+\t  return;\n+\t}\n       break;\n \n     case E_V8QImode:\n@@ -21443,6 +21463,34 @@ expand_vec_perm_broadcast_1 (struct expand_vec_perm_d *d)\n       emit_move_insn (d->target, gen_lowpart (d->vmode, dest));\n       return true;\n \n+    case E_V8HFmode:\n+      /* This can be implemented via interleave and pshufd.  */\n+      if (d->testing_p)\n+\treturn true;\n+\n+      if (elt >= nelt2)\n+\t{\n+\t  gen = gen_vec_interleave_highv8hf;\n+\t  elt -= nelt2;\n+\t}\n+      else\n+\tgen = gen_vec_interleave_lowv8hf;\n+      nelt2 /= 2;\n+\n+      dest = gen_reg_rtx (vmode);\n+      emit_insn (gen (dest, op0, op0));\n+\n+      vmode = V4SImode;\n+      op0 = gen_lowpart (vmode, dest);\n+\n+      memset (perm2, elt, 4);\n+      dest = gen_reg_rtx (vmode);\n+      ok = expand_vselect (dest, op0, perm2, 4, d->testing_p);\n+      gcc_assert (ok);\n+\n+      emit_move_insn (d->target, gen_lowpart (d->vmode, dest));\n+      return true;\n+\n     case E_V32QImode:\n     case E_V16HImode:\n     case E_V8SImode:"}, {"sha": "929eef54055d27b70c5389294b090fbbaa2f217e", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a54d3deecf967029f18aa5ed1fcbdb752e213b9/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a54d3deecf967029f18aa5ed1fcbdb752e213b9/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=7a54d3deecf967029f18aa5ed1fcbdb752e213b9", "patch": "@@ -266,9 +266,7 @@\n (define_mode_iterator VI12HF_AVX512VL\n   [V64QI (V16QI \"TARGET_AVX512VL\") (V32QI \"TARGET_AVX512VL\")\n    V32HI (V16HI \"TARGET_AVX512VL\") (V8HI \"TARGET_AVX512VL\")\n-   (V32HF \"TARGET_AVX512FP16\")\n-   (V16HF \"TARGET_AVX512FP16 && TARGET_AVX512VL\")\n-   (V8HF \"TARGET_AVX512FP16 && TARGET_AVX512VL\")])\n+   V32HF (V16HF \"TARGET_AVX512VL\") (V8HF \"TARGET_AVX512VL\")])\n \n ;; Same iterator, but without supposed TARGET_AVX512BW\n (define_mode_iterator VI12_AVX512VLBW\n@@ -285,8 +283,7 @@\n    (V32HI \"TARGET_AVX512F\") (V16HI \"TARGET_AVX\") V8HI\n    (V16SI \"TARGET_AVX512F\") (V8SI \"TARGET_AVX\") V4SI\n    (V8DI \"TARGET_AVX512F\")  (V4DI \"TARGET_AVX\") V2DI\n-   (V32HF \"TARGET_AVX512FP16\") (V16HF \"TARGET_AVX512FP16\")\n-   (V8HF \"TARGET_AVX512FP16\")\n+   (V32HF \"TARGET_AVX512F\") (V16HF \"TARGET_AVX\") V8HF\n    (V16SF \"TARGET_AVX512F\") (V8SF \"TARGET_AVX\") V4SF\n    (V8DF \"TARGET_AVX512F\")  (V4DF \"TARGET_AVX\") (V2DF \"TARGET_SSE2\")])\n \n@@ -311,10 +308,10 @@\n \n ;; All 256bit and 512bit vector modes\n (define_mode_iterator V_256_512\n-  [V32QI V16HI V8SI V4DI V8SF V4DF\n-   (V64QI \"TARGET_AVX512F\") (V32HI \"TARGET_AVX512F\") (V16SI \"TARGET_AVX512F\")\n-   (V8DI \"TARGET_AVX512F\") (V16SF \"TARGET_AVX512F\") (V8DF \"TARGET_AVX512F\")\n-   (V16HF \"TARGET_AVX512FP16\") (V32HF \"TARGET_AVX512FP16\")])\n+  [V32QI V16HI V16HF V8SI V4DI V8SF V4DF\n+   (V64QI \"TARGET_AVX512F\") (V32HI \"TARGET_AVX512F\") (V32HF \"TARGET_AVX512F\")\n+   (V16SI \"TARGET_AVX512F\") (V8DI \"TARGET_AVX512F\") (V16SF \"TARGET_AVX512F\")\n+   (V8DF \"TARGET_AVX512F\")])\n \n ;; All vector float modes\n (define_mode_iterator VF\n@@ -24892,8 +24889,8 @@\n   \"operands[2] = gen_lowpart (<ssehalfvecmode>mode, operands[0]);\")\n \n (define_insn \"avx_vbroadcastf128_<mode>\"\n-  [(set (match_operand:V_256 0 \"register_operand\" \"=x,x,x,v,v,v,v\")\n-\t(vec_concat:V_256\n+  [(set (match_operand:V_256H 0 \"register_operand\" \"=x,x,x,v,v,v,v\")\n+\t(vec_concat:V_256H\n \t  (match_operand:<ssehalfvecmode> 1 \"nonimmediate_operand\" \"m,0,?x,m,0,m,0\")\n \t  (match_dup 1)))]\n   \"TARGET_AVX\""}]}