{"sha": "ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E1YWYzMDVhMTNhNmY4ODZkYzZiNmUwYTA3ODYzYzdlZWVmZGJlZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T11:12:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-29T11:12:17Z"}, "message": "[multiple changes]\n\n2011-08-29  Robert Dewar  <dewar@adacore.com>\n\n\t* a-exexpr-gcc.adb, a-synbar.adb, sem_ch13.adb: Minor reformatting.\n\n2011-08-29  Bob Duff  <duff@adacore.com>\n\n\t* sem_aggr.adb (Resolve_Aggr_Expr): Call this routine even in the case\n\tof <>, because this is the routine that checks for dimensionality\n\terrors (for example, for a two-dimensional array, (others => <>) should\n\tbe (others => (others => <>)).\n\n2011-08-29  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* impunit.adb: Add new run-time units.\n\t* freeze.adb, exp_ch7.ads, exp_ch7.adb, exp_util.ads, exp_util.adb,\n\ts-stposu.ads, s-stposu.adb: Code clean up.\n\tHandle protected class-wide or task class-wide types\n\tHandle C/C++/CIL/Java types.\n\t* s-spsufi.adb, s-spsufi.ads: New files.\n\nFrom-SVN: r178205", "tree": {"sha": "814b7943f7ccb8cd2729a81e53f68f45e54ea661", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/814b7943f7ccb8cd2729a81e53f68f45e54ea661"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/comments", "author": null, "committer": null, "parents": [{"sha": "5accd7b6ca81d3f3b399bf55e201fc6f78771a13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5accd7b6ca81d3f3b399bf55e201fc6f78771a13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5accd7b6ca81d3f3b399bf55e201fc6f78771a13"}], "stats": {"total": 1358, "additions": 886, "deletions": 472}, "files": [{"sha": "75f4d4e7d05618af4f1324df2e14091af1eda9ff", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -1,3 +1,23 @@\n+2011-08-29  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-exexpr-gcc.adb, a-synbar.adb, sem_ch13.adb: Minor reformatting.\n+\n+2011-08-29  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Aggr_Expr): Call this routine even in the case\n+\tof <>, because this is the routine that checks for dimensionality\n+\terrors (for example, for a two-dimensional array, (others => <>) should\n+\tbe (others => (others => <>)).\n+\n+2011-08-29  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* impunit.adb: Add new run-time units.\n+\t* freeze.adb, exp_ch7.ads, exp_ch7.adb, exp_util.ads, exp_util.adb,\n+\ts-stposu.ads, s-stposu.adb: Code clean up.\n+\tHandle protected class-wide or task class-wide types\n+\tHandle C/C++/CIL/Java types.\n+\t* s-spsufi.adb, s-spsufi.ads: New files.\n+\n 2011-08-29  Yannick Moy  <moy@adacore.com>\n \n \t* sem_ch13.adb (Analyze_Aspect_Specifications): Reject test-case on"}, {"sha": "683c15aa7323dda3da04566289ad5f5075ed6630", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -155,7 +155,6 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-envvar$(objext) \\\n   a-except$(objext) \\\n   a-exctra$(objext) \\\n-  a-fihema$(objext) \\\n   a-finali$(objext) \\\n   a-flteio$(objext) \\\n   a-fwteio$(objext) \\\n@@ -291,6 +290,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-tiunio$(objext) \\\n   a-unccon$(objext) \\\n   a-uncdea$(objext) \\\n+  a-undesu$(objext) \\\n   a-wichha$(objext) \\\n   a-wichun$(objext) \\\n   a-widcha$(objext) \\\n@@ -496,6 +496,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-ficobl$(objext) \\\n   s-fileio$(objext) \\\n   s-filofl$(objext) \\\n+  s-finmas$(objext) \\\n   s-finroo$(objext) \\\n   s-fishfl$(objext) \\\n   s-flocon$(objext) \\\n@@ -606,12 +607,14 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-sequio$(objext) \\\n   s-shasto$(objext) \\\n   s-soflin$(objext) \\\n+  s-spsufi$(objext) \\\n   s-stache$(objext) \\\n   s-stalib$(objext) \\\n   s-stausa$(objext) \\\n   s-stchop$(objext) \\\n   s-stoele$(objext) \\\n   s-stopoo$(objext) \\\n+  s-stposu$(objext) \\\n   s-stratt$(objext) \\\n   s-strhas$(objext) \\\n   s-string$(objext) \\"}, {"sha": "66163dbb85bf677308038903c3fd590475b63b8d", "filename": "gcc/ada/a-exexpr-gcc.adb", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fa-exexpr-gcc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fa-exexpr-gcc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr-gcc.adb?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -277,13 +277,15 @@ package body Exception_Propagation is\n \n    procedure GNAT_GCC_Exception_Cleanup\n      (Reason : Unwind_Reason_Code;\n-      Excep  : not null GNAT_GCC_Exception_Access) is\n+      Excep  : not null GNAT_GCC_Exception_Access)\n+   is\n       pragma Unreferenced (Reason);\n \n       procedure Free is new Unchecked_Deallocation\n         (GNAT_GCC_Exception, GNAT_GCC_Exception_Access);\n \n       Copy : GNAT_GCC_Exception_Access := Excep;\n+\n    begin\n       --  Simply free the memory\n \n@@ -303,6 +305,7 @@ package body Exception_Propagation is\n       UW_Argument  : System.Address) return Unwind_Reason_Code\n    is\n       pragma Unreferenced (UW_Version, UW_Eclass, UW_Context, UW_Argument);\n+\n    begin\n       --  Terminate when the end of the stack is reached\n \n@@ -332,6 +335,7 @@ package body Exception_Propagation is\n       Reraised : Boolean := False)\n    is\n       pragma Unreferenced (Excep, Current, Reraised);\n+\n    begin\n       --  In the GNAT-SJLJ case this \"stack\" only exists implicitly, by way of\n       --  local occurrence declarations together with save/restore operations\n@@ -345,8 +349,10 @@ package body Exception_Propagation is\n    -------------------------\n \n    procedure Setup_Current_Excep\n-     (GCC_Exception : not null GCC_Exception_Access) is\n+     (GCC_Exception : not null GCC_Exception_Access)\n+   is\n       Excep : constant EOA := Get_Current_Excep.all;\n+\n    begin\n       --  Setup the exception occurrence\n \n@@ -356,7 +362,7 @@ package body Exception_Propagation is\n \n          declare\n             GNAT_Occurrence : constant GNAT_GCC_Exception_Access :=\n-              To_GNAT_GCC_Exception (GCC_Exception);\n+                                To_GNAT_GCC_Exception (GCC_Exception);\n          begin\n             Excep.all := GNAT_Occurrence.Occurrence;\n          end;\n@@ -404,7 +410,8 @@ package body Exception_Propagation is\n    -----------------------------\n \n    procedure Reraise_GCC_Exception\n-     (GCC_Exception : not null GCC_Exception_Access) is\n+     (GCC_Exception : not null GCC_Exception_Access)\n+   is\n    begin\n       --  Simply propagate it\n       Propagate_GCC_Exception (GCC_Exception);\n@@ -418,7 +425,8 @@ package body Exception_Propagation is\n    --  the two phase scheme it implements.\n \n    procedure Propagate_GCC_Exception\n-     (GCC_Exception : not null GCC_Exception_Access) is\n+     (GCC_Exception : not null GCC_Exception_Access)\n+   is\n    begin\n       --  Perform a standard raise first. If a regular handler is found, it\n       --  will be entered after all the intermediate cleanups have run. If\n@@ -436,15 +444,15 @@ package body Exception_Propagation is\n \n       --  Now, un a forced unwind to trigger cleanups. Control should not\n       --  resume there, if there are cleanups and in any cases as the\n-      --  unwinding hook calls Unhandled_Exception_Terminate when end of stack\n-      --  is reached.\n+      --  unwinding hook calls Unhandled_Exception_Terminate when end of\n+      --  stack is reached.\n \n       Unwind_ForcedUnwind (GCC_Exception,\n                            CleanupUnwind_Handler'Address,\n                            System.Null_Address);\n \n-      --  We get here in case of error.\n-      --  The debugger has been notified before the second step above.\n+      --  We get here in case of error. The debugger has been notified before\n+      --  the second step above.\n \n       Setup_Current_Excep (GCC_Exception);\n       Unhandled_Exception_Terminate;\n@@ -455,8 +463,8 @@ package body Exception_Propagation is\n    -------------------------\n \n    --  Build an object suitable for the libgcc processing and call\n-   --  Unwind_RaiseException to actually throw, taking care of handling\n-   --  the two phase scheme it implements.\n+   --  Unwind_RaiseException to actually do the raise, taking care of\n+   --  handling the two phase scheme it implements.\n \n    procedure Propagate_Exception\n      (E                   : Exception_Id;\n@@ -494,14 +502,16 @@ package body Exception_Propagation is\n \n       --  Allocate the GCC exception\n \n-      GCC_Exception := new GNAT_GCC_Exception'\n-        (Header    => (Class => GNAT_Exception_Class,\n-                       Cleanup => GNAT_GCC_Exception_Cleanup'Address,\n-                       Private1 => 0,\n-                       Private2 => 0),\n-         Occurrence => Excep.all);\n+      GCC_Exception :=\n+        new GNAT_GCC_Exception'\n+          (Header     => (Class => GNAT_Exception_Class,\n+                          Cleanup => GNAT_GCC_Exception_Cleanup'Address,\n+                          Private1 => 0,\n+                          Private2 => 0),\n+           Occurrence => Excep.all);\n+\n+      --  Propagate it\n \n-      --  Propagate it.\n       Propagate_GCC_Exception (To_GCC_Exception (GCC_Exception));\n    end Propagate_Exception;\n "}, {"sha": "33bb3e478c706a5a9079b48bbad8973e5f0bd87c", "filename": "gcc/ada/a-synbar.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fa-synbar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fa-synbar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-synbar.adb?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -61,7 +61,6 @@ package body Ada.Synchronous_Barriers is\n \n          Notified := Wait'Count = 0;\n       end Wait;\n-\n    end Synchronous_Barrier;\n \n    ----------------------"}, {"sha": "14c60aac50b73564ecc98d970f1b4a70e7c52482", "filename": "gcc/ada/a-undesu.adb", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fa-undesu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fa-undesu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-undesu.adb?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -17,20 +17,15 @@\n \n --  ??? What is the header version here, see a-uncdea.adb. No GPL?\n \n-with System.Storage_Pools.Subpools; use System.Storage_Pools.Subpools;\n+with System.Storage_Pools.Subpools,\n+     System.Storage_Pools.Subpools.Finalization;\n+\n+use System.Storage_Pools.Subpools,\n+    System.Storage_Pools.Subpools.Finalization;\n \n procedure Ada.Unchecked_Deallocate_Subpool\n   (Subpool : in out System.Storage_Pools.Subpools.Subpool_Handle)\n is\n begin\n-   --  Finalize all controlled objects allocated on the input subpool\n-\n-   --  ??? It is awkward to create a child of Storage_Pools.Subpools for the\n-   --  sole purpose of exporting Finalize_Subpool.\n-\n---   Finalize_Subpool (Subpool);\n-\n-   --  Dispatch to the user-defined implementation of Deallocate_Subpool\n-\n-   Deallocate_Subpool (Pool_Of_Subpool (Subpool).all, Subpool);\n+   Finalize_And_Deallocate (Subpool);\n end Ada.Unchecked_Deallocate_Subpool;"}, {"sha": "a22f86dff88cb968dd8fc59fffbfc2f2d2428c26", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -6626,35 +6626,31 @@ package body Exp_Ch3 is\n             --  finalization support if not needed.\n \n             if not Comes_From_Source (Def_Id)\n-               and then not Has_Private_Declaration (Def_Id)\n+              and then not Has_Private_Declaration (Def_Id)\n             then\n                null;\n \n-            elsif (Needs_Finalization (Desig_Type)\n-                    and then Convention (Desig_Type) /= Convention_Java\n-                    and then Convention (Desig_Type) /= Convention_CIL)\n-              or else\n-                (Is_Incomplete_Or_Private_Type (Desig_Type)\n-                  and then No (Full_View (Desig_Type))\n-\n-                  --  An exception is made for types defined in the run-time\n-                  --  because Ada.Tags.Tag itself is such a type and cannot\n-                  --  afford this unnecessary overhead that would generates a\n-                  --  loop in the expansion scheme...\n-\n-                   and then not In_Runtime (Def_Id)\n-\n-                  --  Another exception is if Restrictions (No_Finalization)\n-                  --  is active, since then we know nothing is controlled.\n+            --  An exception is made for types defined in the run-time because\n+            --  Ada.Tags.Tag itself is such a type and cannot afford this\n+            --  unnecessary overhead that would generates a loop in the\n+            --  expansion scheme. Another exception is if Restrictions\n+            --  (No_Finalization) is active, since then we know nothing is\n+            --  controlled.\n \n-                   and then not Restriction_Active (No_Finalization))\n+            elsif Restriction_Active (No_Finalization)\n+              or else In_Runtime (Def_Id)\n+            then\n+               null;\n \n-               --  If the designated type is not frozen yet, its controlled\n-               --  status must be retrieved explicitly.\n+            --  The machinery assumes that incomplete or private types are\n+            --  always completed by a controlled full vies.\n \n+            elsif Needs_Finalization (Desig_Type)\n+              or else\n+                (Is_Incomplete_Or_Private_Type (Desig_Type)\n+                  and then No (Full_View (Desig_Type)))\n               or else\n                 (Is_Array_Type (Desig_Type)\n-                  and then not Is_Frozen (Desig_Type)\n                   and then Needs_Finalization (Component_Type (Desig_Type)))\n             then\n                Build_Finalization_Master (Def_Id);"}, {"sha": "3c42b646730468a57c31bcd0805fabdc6d669378", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 114, "deletions": 128, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -91,12 +91,13 @@ package body Exp_Ch4 is\n    --  If a boolean array assignment can be done in place, build call to\n    --  corresponding library procedure.\n \n-   procedure Complete_Controlled_Allocation (Temp_Decl : Node_Id);\n-   --  Subsidiary to Expand_N_Allocator and Expand_Allocator_Expression. Formal\n-   --  Temp_Decl is the declaration of a temporary which hold the value of the\n-   --  original allocator. Create a custom Allocate routine for the expression\n-   --  of Temp_Decl. The routine does special processing for anonymous access\n-   --  types.\n+   function Current_Unit_First_Declaration return Node_Id;\n+   --  Return the current unit's first declaration. If the declaration list is\n+   --  empty, the routine generates a null statement and returns it.\n+\n+   function Current_Unit_Scope return Entity_Id;\n+   --  Return the scope of the current unit. If the current unit is a body,\n+   --  return the scope of the spec.\n \n    procedure Displace_Allocator_Pointer (N : Node_Id);\n    --  Ada 2005 (AI-251): Subsidiary procedure to Expand_N_Allocator and\n@@ -375,121 +376,78 @@ package body Exp_Ch4 is\n    end Build_Boolean_Array_Proc_Call;\n \n    ------------------------------------\n-   -- Complete_Controlled_Allocation --\n+   -- Current_Unit_First_Declaration --\n    ------------------------------------\n \n-   procedure Complete_Controlled_Allocation (Temp_Decl : Node_Id) is\n-      pragma Assert (Nkind (Temp_Decl) = N_Object_Declaration);\n-\n-      Ptr_Typ : constant Entity_Id := Etype (Defining_Identifier (Temp_Decl));\n+   function Current_Unit_First_Declaration return Node_Id is\n+      Sem_U : Node_Id := Unit (Cunit (Current_Sem_Unit));\n+      Decl  : Node_Id;\n+      Decls : List_Id;\n \n-      function First_Declaration_Of_Current_Unit return Node_Id;\n-      --  Return the current unit's first declaration. If the declaration list\n-      --  is empty, the routine generates a null statement and returns it.\n-\n-      ---------------------------------------\n-      -- First_Declaration_Of_Current_Unit --\n-      ---------------------------------------\n+   begin\n+      if Nkind (Sem_U) = N_Package_Declaration then\n+         Sem_U := Specification (Sem_U);\n+         Decls := Visible_Declarations (Sem_U);\n \n-      function First_Declaration_Of_Current_Unit return Node_Id is\n-         Sem_U : Node_Id := Unit (Cunit (Current_Sem_Unit));\n-         Decl  : Node_Id;\n-         Decls : List_Id;\n+         if No (Decls) then\n+            Decl := Make_Null_Statement (Sloc (Sem_U));\n+            Decls := New_List (Decl);\n+            Set_Visible_Declarations (Sem_U, Decls);\n \n-      begin\n-         if Nkind (Sem_U) = N_Package_Declaration then\n-            Sem_U := Specification (Sem_U);\n-            Decls := Visible_Declarations (Sem_U);\n-\n-            if No (Decls) then\n-               Decl  := Make_Null_Statement (Sloc (Sem_U));\n-               Decls := New_List (Decl);\n-               Set_Visible_Declarations (Sem_U, Decls);\n-            else\n-               Decl := First (Decls);\n-            end if;\n+         elsif Is_Empty_List (Decls) then\n+            Decl := Make_Null_Statement (Sloc (Sem_U));\n+            Append_To (Decls, Decl);\n \n          else\n-            Decls := Declarations (Sem_U);\n-\n-            if No (Decls) then\n-               Decl  := Make_Null_Statement (Sloc (Sem_U));\n-               Decls := New_List (Decl);\n-               Set_Declarations (Sem_U, Decls);\n-            else\n-               Decl := First (Decls);\n-            end if;\n+            Decl := First (Decls);\n          end if;\n \n-         return Decl;\n-      end First_Declaration_Of_Current_Unit;\n-\n-   --  Start of processing for Complete_Controlled_Allocation\n-\n-   begin\n-      --  Certain run-time configurations and targets do not provide support\n-      --  for controlled types.\n-\n-      if Restriction_Active (No_Finalization) then\n-         return;\n-\n-      --  Do nothing if the access type may never allocate an object\n+      else\n+         Decls := Declarations (Sem_U);\n \n-      elsif No_Pool_Assigned (Ptr_Typ) then\n-         return;\n+         if No (Decls) then\n+            Decl := Make_Null_Statement (Sloc (Sem_U));\n+            Decls := New_List (Decl);\n+            Set_Declarations (Sem_U, Decls);\n \n-      --  Access-to-controlled types are not supported on .NET/JVM\n+         elsif Is_Empty_List (Decls) then\n+            Decl := Make_Null_Statement (Sloc (Sem_U));\n+            Append_To (Decls, Decl);\n \n-      elsif VM_Target /= No_VM then\n-         return;\n+         else\n+            Decl := First (Decls);\n+         end if;\n       end if;\n \n-      --  ??? Now that finalization masters act as heterogeneous lists, it\n-      --  might be worthed to revisit the global master approach.\n-\n-      --  Processing for anonymous access-to-controlled types. These access\n-      --  types receive a special finalization master which appears in the\n-      --  declarations of the enclosing semantic unit.\n+      return Decl;\n+   end Current_Unit_First_Declaration;\n \n-      if Ekind (Ptr_Typ) = E_Anonymous_Access_Type\n-        and then No (Finalization_Master (Ptr_Typ))\n-        and then\n-          (not Restriction_Active (No_Nested_Finalization)\n-             or else Is_Library_Level_Entity (Ptr_Typ))\n-      then\n-         declare\n-            Pool_Id : constant Entity_Id :=\n-                        Get_Global_Pool_For_Access_Type (Ptr_Typ);\n-            Scop    : Node_Id := Cunit_Entity (Current_Sem_Unit);\n+   ------------------------\n+   -- Current_Unit_Scope --\n+   ------------------------\n \n-         begin\n-            --  Use the scope of the current semantic unit when analyzing\n+   function Current_Unit_Scope return Entity_Id is\n+      Scop_Id  : Entity_Id := Cunit_Entity (Current_Sem_Unit);\n+      Subp_Bod : Node_Id;\n \n-            if Ekind (Scop) = E_Subprogram_Body then\n-               Scop := Corresponding_Spec (Parent (Parent (Parent (Scop))));\n-            end if;\n+   begin\n+      if Ekind (Scop_Id) = E_Subprogram_Body then\n \n-            Build_Finalization_Master\n-              (Typ        => Ptr_Typ,\n-               Ins_Node   => First_Declaration_Of_Current_Unit,\n-               Encl_Scope => Scop);\n+         --  When processing subprogram bodies, the proper scope is always\n+         --  that of the spec.\n \n-            --  Decorate the anonymous access type and the allocator node\n+         Subp_Bod := Scop_Id;\n+         while Present (Subp_Bod)\n+           and then Nkind (Subp_Bod) /= N_Subprogram_Body\n+         loop\n+            Subp_Bod := Parent (Subp_Bod);\n+         end loop;\n \n-            Set_Associated_Storage_Pool (Ptr_Typ, Pool_Id);\n-            Set_Storage_Pool (Expression (Temp_Decl), Pool_Id);\n-         end;\n+         Scop_Id := Corresponding_Spec (Subp_Bod);\n       end if;\n \n-      --  Since the temporary object reuses the original allocator, generate a\n-      --  custom Allocate routine for the temporary.\n-\n-      if Present (Finalization_Master (Ptr_Typ)) then\n-         Build_Allocate_Deallocate_Proc\n-           (N           => Temp_Decl,\n-            Is_Allocate => True);\n-      end if;\n-   end Complete_Controlled_Allocation;\n+      return Scop_Id;\n+   end Current_Unit_Scope;\n \n    --------------------------------\n    -- Displace_Allocator_Pointer --\n@@ -777,14 +735,13 @@ package body Exp_Ch4 is\n             return;\n          end if;\n \n-         --    Actions inserted before:\n-         --              Temp : constant ptr_T := new T'(Expression);\n-         --   <no CW>    Temp._tag := T'tag;\n-         --   <CTRL>     Adjust (Finalizable (Temp.all));\n-         --   <CTRL>     Attach_To_Final_List (Finalizable (Temp.all));\n+         --  Actions inserted before:\n+         --    Temp : constant ptr_T := new T'(Expression);\n+         --    Temp._tag = T'tag;  --  when not class-wide\n+         --    [Deep_]Adjust (Temp.all);\n \n-         --  We analyze by hand the new internal allocator to avoid\n-         --  any recursion and inappropriate call to Initialize\n+         --  We analyze by hand the new internal allocator to avoid any\n+         --  recursion and inappropriate call to Initialize\n \n          --  We don't want to remove side effects when the expression must be\n          --  built in place. In the case of a build-in-place function call,\n@@ -858,7 +815,7 @@ package body Exp_Ch4 is\n                Set_No_Initialization (Expression (Temp_Decl));\n                Insert_Action (N, Temp_Decl);\n \n-               Complete_Controlled_Allocation (Temp_Decl);\n+               Build_Allocate_Deallocate_Proc (Temp_Decl, True);\n                Convert_Aggr_In_Allocator (N, Temp_Decl, Exp);\n \n                --  Attach the object to the associated finalization master.\n@@ -889,7 +846,7 @@ package body Exp_Ch4 is\n                    Expression          => Node);\n \n                Insert_Action (N, Temp_Decl);\n-               Complete_Controlled_Allocation (Temp_Decl);\n+               Build_Allocate_Deallocate_Proc (Temp_Decl, True);\n \n                --  Attach the object to the associated finalization master.\n                --  This is done manually on .NET/JVM since those compilers do\n@@ -961,7 +918,7 @@ package body Exp_Ch4 is\n                   Set_No_Initialization (Expression (Temp_Decl));\n                   Insert_Action (N, Temp_Decl);\n \n-                  Complete_Controlled_Allocation (Temp_Decl);\n+                  Build_Allocate_Deallocate_Proc (Temp_Decl, True);\n                   Convert_Aggr_In_Allocator (N, Temp_Decl, Exp);\n \n                else\n@@ -976,7 +933,7 @@ package body Exp_Ch4 is\n                       Expression          => Node);\n \n                   Insert_Action (N, Temp_Decl);\n-                  Complete_Controlled_Allocation (Temp_Decl);\n+                  Build_Allocate_Deallocate_Proc (Temp_Decl, True);\n                end if;\n \n                --  Generate an additional object containing the address of the\n@@ -1119,7 +1076,7 @@ package body Exp_Ch4 is\n          Set_No_Initialization (Expression (Temp_Decl));\n          Insert_Action (N, Temp_Decl);\n \n-         Complete_Controlled_Allocation (Temp_Decl);\n+         Build_Allocate_Deallocate_Proc (Temp_Decl, True);\n          Convert_Aggr_In_Allocator (N, Temp_Decl, Exp);\n \n          --  Attach the object to the associated finalization master. Thisis\n@@ -3250,8 +3207,9 @@ package body Exp_Ch4 is\n       Etyp  : constant Entity_Id  := Etype (Expression (N));\n       Loc   : constant Source_Ptr := Sloc (N);\n       Desig : Entity_Id;\n-      Temp  : Entity_Id;\n       Nod   : Node_Id;\n+      Pool  : Entity_Id;\n+      Temp  : Entity_Id;\n \n       procedure Rewrite_Coextension (N : Node_Id);\n       --  Static coextensions have the same lifetime as the entity they\n@@ -3374,22 +3332,51 @@ package body Exp_Ch4 is\n \n       Validate_Remote_Access_To_Class_Wide_Type (N);\n \n-      --  Set the Storage Pool\n+      --  Processing for anonymous access-to-controlled types. These access\n+      --  types receive a special finalization master which appears in the\n+      --  declarations of the enclosing semantic unit. This expansion is done\n+      --  now to ensure that any additional types generated by this routine\n+      --  or Expand_Allocator_Expression inherit the proper type attributes.\n+\n+      if Ekind (PtrT) = E_Anonymous_Access_Type\n+        and then Needs_Finalization (Dtyp)\n+      then\n+         --  Anonymous access-to-controlled types allocate on the global pool\n+\n+         if No (Associated_Storage_Pool (PtrT)) then\n+            Set_Associated_Storage_Pool (PtrT,\n+              Get_Global_Pool_For_Access_Type (PtrT));\n+         end if;\n+\n+         --  The finalization master must be inserted and analyzed as part of\n+         --  the current semantic unit.\n+\n+         if No (Finalization_Master (PtrT)) then\n+            Build_Finalization_Master\n+              (Typ        => PtrT,\n+               Ins_Node   => Current_Unit_First_Declaration,\n+               Encl_Scope => Current_Unit_Scope);\n+         end if;\n+      end if;\n+\n+      --  Set the storage pool and find the appropriate version of Allocate to\n+      --  call.\n \n-      Set_Storage_Pool (N, Associated_Storage_Pool (Root_Type (PtrT)));\n+      Pool := Associated_Storage_Pool (Root_Type (PtrT));\n+      Set_Storage_Pool (N, Pool);\n \n-      if Present (Storage_Pool (N)) then\n-         if Is_RTE (Storage_Pool (N), RE_SS_Pool) then\n+      if Present (Pool) then\n+         if Is_RTE (Pool, RE_SS_Pool) then\n             if VM_Target = No_VM then\n                Set_Procedure_To_Call (N, RTE (RE_SS_Allocate));\n             end if;\n \n-         elsif Is_Class_Wide_Type (Etype (Storage_Pool (N))) then\n+         elsif Is_Class_Wide_Type (Etype (Pool)) then\n             Set_Procedure_To_Call (N, RTE (RE_Allocate_Any));\n \n          else\n             Set_Procedure_To_Call (N,\n-              Find_Prim_Op (Etype (Storage_Pool (N)), Name_Allocate));\n+              Find_Prim_Op (Etype (Pool), Name_Allocate));\n          end if;\n       end if;\n \n@@ -3550,7 +3537,7 @@ package body Exp_Ch4 is\n               and then Present (Finalization_Master (PtrT))\n             then\n                Build_Allocate_Deallocate_Proc\n-                 (N           => Parent (N),\n+                 (N           => N,\n                   Is_Allocate => True);\n             end if;\n \n@@ -3788,14 +3775,13 @@ package body Exp_Ch4 is\n                Nod := Relocate_Node (N);\n \n                --  Here is the transformation:\n-               --    input:  new T\n-               --    output: Temp : constant ptr_T := new T;\n-               --            Init (Temp.all, ...);\n-               --    <CTRL>  Attach_To_Final_List (Finalizable (Temp.all));\n-               --    <CTRL>  Initialize (Finalizable (Temp.all));\n+               --    input:  new Ctrl_Typ\n+               --    output: Temp : constant Ctrl_Typ_Ptr := new Ctrl_Typ;\n+               --            Ctrl_TypIP (Temp.all, ...);\n+               --            [Deep_]Initialize (Temp.all);\n \n-               --  Here ptr_T is the pointer type for the allocator, and is the\n-               --  subtype of the allocator.\n+               --  Here Ctrl_Typ_Ptr is the pointer type for the allocator, and\n+               --  is the subtype of the allocator.\n \n                Temp_Decl :=\n                  Make_Object_Declaration (Loc,\n@@ -3807,7 +3793,7 @@ package body Exp_Ch4 is\n                Set_Assignment_OK (Temp_Decl);\n                Insert_Action (N, Temp_Decl, Suppress => All_Checks);\n \n-               Complete_Controlled_Allocation (Temp_Decl);\n+               Build_Allocate_Deallocate_Proc (Temp_Decl, True);\n \n                --  If the designated type is a task type or contains tasks,\n                --  create block to activate created tasks, and insert\n@@ -3844,7 +3830,7 @@ package body Exp_Ch4 is\n                   --  Special processing for .NET/JVM, the allocated object is\n                   --  attached to the finalization master. Generate:\n \n-                  --    Attach (<PtrT>FM, Root_Controlled_Ptr (Init_Arg1));\n+                  --    Attach (<PtrT>FC, Root_Controlled_Ptr (Init_Arg1));\n \n                   --  Types derived from [Limited_]Controlled are the only\n                   --  ones considered since they have fields Prev and Next."}, {"sha": "c0c73feb7153a2db444c21afe5c75b6a8165a279", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 105, "deletions": 73, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -777,9 +777,8 @@ package body Exp_Ch7 is\n \n       return\n         Make_Exception_Handler (Loc,\n-          Exception_Choices => New_List (\n-            Make_Others_Choice (Loc)),\n-\n+          Exception_Choices =>\n+            New_List (Make_Others_Choice (Loc)),\n           Statements => New_List (\n             Make_If_Statement (Loc,\n               Condition       =>\n@@ -807,6 +806,7 @@ package body Exp_Ch7 is\n       Encl_Scope : Entity_Id := Empty)\n    is\n       Desig_Typ : constant Entity_Id := Directly_Designated_Type (Typ);\n+      Ptr_Typ   : Entity_Id := Root_Type (Base_Type (Typ));\n \n       function In_Deallocation_Instance (E : Entity_Id) return Boolean;\n       --  Determine whether entity E is inside a wrapper package created for\n@@ -840,41 +840,57 @@ package body Exp_Ch7 is\n    --  Start of processing for Build_Finalization_Master\n \n    begin\n+      if Is_Private_Type (Ptr_Typ)\n+        and then Present (Full_View (Ptr_Typ))\n+      then\n+         Ptr_Typ := Full_View (Ptr_Typ);\n+      end if;\n+\n       --  Certain run-time configurations and targets do not provide support\n       --  for controlled types.\n \n       if Restriction_Active (No_Finalization) then\n          return;\n \n+      --  Do not process C, C++, CIL and Java types since it is assumend that\n+      --  the non-Ada side will handle their clean up.\n+\n+      elsif Convention (Desig_Typ) = Convention_C\n+        or else Convention (Desig_Typ) = Convention_CIL\n+        or else Convention (Desig_Typ) = Convention_CPP\n+        or else Convention (Desig_Typ) = Convention_Java\n+      then\n+         return;\n+\n       --  Various machinery such as freezing may have already created a\n       --  finalization master.\n \n-      elsif Present (Finalization_Master (Typ)) then\n+      elsif Present (Finalization_Master (Ptr_Typ)) then\n          return;\n \n       --  Do not process types that return on the secondary stack\n \n-      elsif Present (Associated_Storage_Pool (Typ))\n-        and then Is_RTE (Associated_Storage_Pool (Typ), RE_SS_Pool)\n+      elsif Present (Associated_Storage_Pool (Ptr_Typ))\n+        and then Is_RTE (Associated_Storage_Pool (Ptr_Typ), RE_SS_Pool)\n       then\n          return;\n \n       --  Do not process types which may never allocate an object\n \n-      elsif No_Pool_Assigned (Typ) then\n+      elsif No_Pool_Assigned (Ptr_Typ) then\n          return;\n \n       --  Do not process access types coming from Ada.Unchecked_Deallocation\n       --  instances. Even though the designated type may be controlled, the\n       --  access type will never participate in allocation.\n \n-      elsif In_Deallocation_Instance (Typ) then\n+      elsif In_Deallocation_Instance (Ptr_Typ) then\n          return;\n \n       --  Ignore the general use of anonymous access types unless the context\n       --  requires a finalization master.\n \n-      elsif Ekind (Typ) = E_Anonymous_Access_Type\n+      elsif Ekind (Ptr_Typ) = E_Anonymous_Access_Type\n         and then No (Ins_Node)\n       then\n          return;\n@@ -883,7 +899,7 @@ package body Exp_Ch7 is\n       --  Finalization is in effect since masters are controlled objects.\n \n       elsif Restriction_Active (No_Nested_Finalization)\n-        and then not Is_Library_Level_Entity (Typ)\n+        and then not Is_Library_Level_Entity (Ptr_Typ)\n       then\n          return;\n \n@@ -898,19 +914,12 @@ package body Exp_Ch7 is\n       end if;\n \n       declare\n-         Loc        : constant Source_Ptr := Sloc (Typ);\n+         Loc        : constant Source_Ptr := Sloc (Ptr_Typ);\n          Actions    : constant List_Id := New_List;\n          Fin_Mas_Id : Entity_Id;\n          Pool_Id    : Entity_Id;\n-         Ptr_Typ    : Entity_Id := Typ;\n \n       begin\n-         --  Access subtypes must use the storage pool of their base type\n-\n-         if Ekind (Ptr_Typ) = E_Access_Subtype then\n-            Ptr_Typ := Base_Type (Ptr_Typ);\n-         end if;\n-\n          --  Generate:\n          --    Fnn : aliased Finalization_Master;\n \n@@ -994,11 +1003,10 @@ package body Exp_Ch7 is\n \n             Pop_Scope;\n \n-         elsif Ekind (Typ) = E_Access_Subtype\n-           or else (Ekind (Desig_Typ) = E_Incomplete_Type\n-                     and then Has_Completion_In_Body (Desig_Typ))\n+         elsif Ekind (Desig_Typ) = E_Incomplete_Type\n+           and then Has_Completion_In_Body (Desig_Typ)\n          then\n-            Insert_Actions (Parent (Typ), Actions);\n+            Insert_Actions (Parent (Ptr_Typ), Actions);\n \n          --  If the designated type is not yet frozen, then append the actions\n          --  to that type's freeze actions. The actions need to be appended to\n@@ -1013,10 +1021,10 @@ package body Exp_Ch7 is\n          then\n             Append_Freeze_Actions (Desig_Typ, Actions);\n \n-         elsif Present (Freeze_Node (Typ))\n-           and then not Analyzed (Freeze_Node (Typ))\n+         elsif Present (Freeze_Node (Ptr_Typ))\n+           and then not Analyzed (Freeze_Node (Ptr_Typ))\n          then\n-            Append_Freeze_Actions (Typ, Actions);\n+            Append_Freeze_Actions (Ptr_Typ, Actions);\n \n          --  If there's a pool created locally for the access type, then we\n          --  need to ensure that the master gets created after the pool object,\n@@ -1027,12 +1035,12 @@ package body Exp_Ch7 is\n          --  this point. (This seems a little unclean.???)\n \n          elsif VM_Target = No_VM\n-           and then Scope (Pool_Id) = Scope (Typ)\n+           and then Scope (Pool_Id) = Scope (Ptr_Typ)\n          then\n             Insert_List_After_And_Analyze (Parent (Pool_Id), Actions);\n \n          else\n-            Insert_Actions (Parent (Typ), Actions);\n+            Insert_Actions (Parent (Ptr_Typ), Actions);\n          end if;\n       end;\n    end Build_Finalization_Master;\n@@ -1448,8 +1456,8 @@ package body Exp_Ch7 is\n             --  The local exception does not need to be reraised for library-\n             --  level finalizers. Generate:\n             --\n-            --    if Raised then\n-            --       Raise_From_Controlled_Operation (E, Abort);\n+            --    if Raised and then not Abort then\n+            --       Raise_From_Controlled_Operation (E);\n             --    end if;\n \n             if not For_Package\n@@ -2297,6 +2305,10 @@ package body Exp_Ch7 is\n \n                      if Is_Controlled (Typ) then\n                         Init := Find_Prim_Op (Typ, Name_Initialize);\n+\n+                        if Present (Init) then\n+                           Init := Ultimate_Alias (Init);\n+                        end if;\n                      end if;\n \n                      return\n@@ -2349,6 +2361,12 @@ package body Exp_Ch7 is\n                Utyp := Typ;\n             end if;\n \n+            if Is_Private_Type (Utyp)\n+              and then Present (Full_View (Utyp))\n+            then\n+               Utyp := Full_View (Utyp);\n+            end if;\n+\n             --  The init procedures are arranged as follows:\n \n             --    Object : Controlled_Type;\n@@ -3086,20 +3104,13 @@ package body Exp_Ch7 is\n       E_Id      : Entity_Id;\n       Raised_Id : Entity_Id) return Node_Id\n    is\n-      Params  : List_Id;\n       Proc_Id : Entity_Id;\n \n    begin\n-      --  The default parameter is the local exception occurrence\n-\n-      Params := New_List (New_Reference_To (E_Id, Loc));\n-\n-      --  Standard run-time, .NET/JVM targets, this case handles finalization\n-      --  exceptions raised during an abort.\n+      --  Standard run-time, .NET/JVM targets\n \n       if RTE_Available (RE_Raise_From_Controlled_Operation) then\n          Proc_Id := RTE (RE_Raise_From_Controlled_Operation);\n-         Append_To (Params, New_Reference_To (Abort_Id, Loc));\n \n       --  Restricted runtime: exception messages are not supported and hence\n       --  Raise_From_Controlled_Operation is not supported.\n@@ -3109,17 +3120,24 @@ package body Exp_Ch7 is\n       end if;\n \n       --  Generate:\n-      --    if Raised_Id then\n+      --    if Raised_Id and then not Abort_Id then\n       --       <Proc_Id> (<Params>);\n       --    end if;\n \n       return\n         Make_If_Statement (Loc,\n-          Condition       => New_Reference_To (Raised_Id, Loc),\n+          Condition =>\n+            Make_And_Then (Loc,\n+              Left_Opnd  => New_Reference_To (Raised_Id, Loc),\n+              Right_Opnd =>\n+                Make_Op_Not (Loc,\n+                  Right_Opnd => New_Reference_To (Abort_Id, Loc))),\n+\n           Then_Statements => New_List (\n             Make_Procedure_Call_Statement (Loc,\n               Name                   => New_Reference_To (Proc_Id, Loc),\n-              Parameter_Associations => Params)));\n+              Parameter_Associations =>\n+                New_List (New_Reference_To (E_Id, Loc)))));\n    end Build_Raise_Statement;\n \n    -----------------------------\n@@ -4325,8 +4343,8 @@ package body Exp_Ch7 is\n \n                --    exception\n                --       when others =>\n-               --          if not Rnn then\n-               --             Rnn := True;\n+               --          if not Raised then\n+               --             Raised := True;\n                --             Save_Occurrence\n                --               (Enn, Get_Current_Excep.all.all);\n                --          end if;\n@@ -4405,8 +4423,8 @@ package body Exp_Ch7 is\n          end loop;\n \n          --  Generate:\n-         --    if Rnn then\n-         --       Raise_From_Controlled_Operation (E, Abort);\n+         --    if Raised and then not Abort then\n+         --       Raise_From_Controlled_Operation (E);\n          --    end if;\n \n          if Built\n@@ -4723,8 +4741,8 @@ package body Exp_Ch7 is\n       --          ...\n       --       end loop;\n       --\n-      --       if Raised then\n-      --          Raise_From_Controlled_Operation (E, Abort);\n+      --       if Raised and then not Abort then\n+      --          Raise_From_Controlled_Operation (E);\n       --       end if;\n       --    end;\n \n@@ -4789,8 +4807,8 @@ package body Exp_Ch7 is\n       --                      end loop;\n       --                   end;\n \n-      --                   if Raised then\n-      --                      Raise_From_Controlled_Operation (E, Abort);\n+      --                   if Raised and then not Abort then\n+      --                      Raise_From_Controlled_Operation (E);\n       --                   end if;\n \n       --                   raise;\n@@ -4957,8 +4975,8 @@ package body Exp_Ch7 is\n          --    begin\n          --       <core loop>\n \n-         --       if Raised then  --  Expection handlers allowed\n-         --          Raise_From_Controlled_Operation (E, Abort);\n+         --       if Raised and then not Abort then  --  Expection handlers OK\n+         --          Raise_From_Controlled_Operation (E);\n          --       end if;\n          --    end;\n \n@@ -5249,11 +5267,11 @@ package body Exp_Ch7 is\n \n          --       <final loop>\n \n-         --       if Raised then  --  Exception handlers allowed\n-         --          Raise_From_Controlled_Operation (E, Abort);\n+         --       if Raised and then not Abort then  --  Exception handlers OK\n+         --          Raise_From_Controlled_Operation (E);\n          --       end if;\n \n-         --       raise;          --  Exception handlers allowed\n+         --       raise;  --  Exception handlers OK\n          --    end;\n \n          Stmts := New_List (Build_Counter_Assignment, Final_Loop);\n@@ -5537,8 +5555,8 @@ package body Exp_Ch7 is\n       --          end;\n       --       end if;\n       --\n-      --       if Raised then\n-      --          Raise_From_Controlled_Object (E, Abort);\n+      --       if Raised and then not Abort then\n+      --          Raise_From_Controlled_Operation (E);\n       --       end if;\n       --    end;\n \n@@ -5622,8 +5640,8 @@ package body Exp_Ch7 is\n       --             end if;\n       --       end;\n       --\n-      --       if Raised then\n-      --          Raise_From_Controlled_Object (E, Abort);\n+      --       if Raised and then not Abort then\n+      --          Raise_From_Controlled_Operation (E);\n       --       end if;\n       --    end;\n \n@@ -6036,8 +6054,8 @@ package body Exp_Ch7 is\n          --    begin\n          --       <adjust statements>\n \n-         --       if Raised then\n-         --          Raise_From_Controlled_Operation (E, Abort);\n+         --       if Raised and then not Abort then\n+         --          Raise_From_Controlled_Operation (E);\n          --       end if;\n          --    end;\n \n@@ -6618,15 +6636,10 @@ package body Exp_Ch7 is\n          --       Raised : Boolean := False;\n \n          --    begin\n-         --       if V.Finalized then\n-         --          return;\n-         --       end if;\n-\n          --       <finalize statements>\n-         --       V.Finalized := True;\n \n-         --       if Raised then\n-         --          Raise_From_Controlled_Operation (E, Abort);\n+         --       if Raised and then not Abort then\n+         --          Raise_From_Controlled_Operation (E);\n          --       end if;\n          --    end;\n \n@@ -6917,16 +6930,29 @@ package body Exp_Ch7 is\n    --------------------------------\n \n    procedure Make_Finalize_Address_Body (Typ : Entity_Id) is\n+      Is_Task : constant Boolean :=\n+                  Ekind (Typ) = E_Record_Type\n+                    and then Is_Concurrent_Record_Type (Typ)\n+                    and then Ekind (Corresponding_Concurrent_Type (Typ)) =\n+                               E_Task_Type;\n       Loc     : constant Source_Ptr := Sloc (Typ);\n       Proc_Id : Entity_Id;\n+      Stmts   : List_Id;\n \n    begin\n+      --  The corresponding records of task types are not controlled by design.\n+      --  For the sake of completeness, create an empty Finalize_Address to be\n+      --  used in task class-wide allocations.\n+\n+      if Is_Task then\n+         null;\n+\n       --  Nothing to do if the type is not controlled or it already has a\n       --  TSS entry for Finalize_Address. Skip class-wide subtypes which do not\n       --  come from source. These are usually generated for completeness and\n       --  do not need the Finalize_Address primitive.\n \n-      if not Needs_Finalization (Typ)\n+      elsif not Needs_Finalization (Typ)\n         or else Is_Abstract_Type (Typ)\n         or else Present (TSS (Typ, TSS_Finalize_Address))\n         or else\n@@ -6944,14 +6970,22 @@ package body Exp_Ch7 is\n       --  Generate:\n       --    procedure <Typ>FD (V : System.Address) is\n       --    begin\n-      --       declare\n+      --       null;                            --  for tasks\n+      --\n+      --       declare                          --  for all other types\n       --          type Pnn is access all Typ;\n       --          for Pnn'Storage_Size use 0;\n       --       begin\n       --          [Deep_]Finalize (Pnn (V).all);\n       --       end;\n       --    end TypFD;\n \n+      if Is_Task then\n+         Stmts := New_List (Make_Null_Statement (Loc));\n+      else\n+         Stmts := Make_Finalize_Address_Stmts (Typ);\n+      end if;\n+\n       Discard_Node (\n         Make_Subprogram_Body (Loc,\n           Specification =>\n@@ -6969,8 +7003,7 @@ package body Exp_Ch7 is\n \n           Handled_Statement_Sequence =>\n             Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements =>\n-                Make_Finalize_Address_Stmts (Typ))));\n+              Statements => Stmts)));\n \n       Set_TSS (Typ, Proc_Id);\n    end Make_Finalize_Address_Body;\n@@ -7218,7 +7251,7 @@ package body Exp_Ch7 is\n    --  Generate:\n \n    --    when E : others =>\n-   --      Raise_From_Controlled_Operation (E, False);\n+   --      Raise_From_Controlled_Operation (E);\n \n    --  or:\n \n@@ -7250,8 +7283,7 @@ package body Exp_Ch7 is\n                New_Reference_To\n                  (RTE (RE_Raise_From_Controlled_Operation), Loc),\n              Parameter_Associations => New_List (\n-               New_Reference_To (E_Occ, Loc),\n-               New_Reference_To (Standard_False, Loc)));\n+               New_Reference_To (E_Occ, Loc)));\n \n       --  Restricted runtime: exception messages are not supported\n "}, {"sha": "a9fea526c225df27c0d2b0d55a09140f6641d84b", "filename": "gcc/ada/exp_ch7.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fexp_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fexp_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.ads?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -84,8 +84,8 @@ package Exp_Ch7 is\n    --  Subsidiary to routines Build_Finalizer, Make_Deep_Array_Body and Make_\n    --  Deep_Record_Body. Generate the following conditional raise statement:\n    --\n-   --    if Raised_Id then\n-   --       Raise_From_Controlled_Operation (E_Id, Abort_Id);\n+   --    if Raised_Id and then not Abort_Id then\n+   --       Raise_From_Controlled_Operation (E_Id);\n    --    end if;\n    --\n    --  Abort_Id is a local boolean flag which is set when the finalization was"}, {"sha": "0d1f73c4044ffcd8c8932c1a72eea87b84bfa587", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 140, "deletions": 31, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -327,10 +327,11 @@ package body Exp_Util is\n      (N           : Node_Id;\n       Is_Allocate : Boolean)\n    is\n-      Expr      : constant Node_Id   := Expression (N);\n-      Ptr_Typ   : constant Entity_Id := Etype (Expr);\n-      Desig_Typ : constant Entity_Id :=\n-                    Available_View (Designated_Type (Ptr_Typ));\n+      Desig_Typ    : Entity_Id;\n+      Expr         : Node_Id;\n+      Pool_Id      : Entity_Id;\n+      Proc_To_Call : Node_Id := Empty;\n+      Ptr_Typ      : Entity_Id;\n \n       function Find_Finalize_Address (Typ : Entity_Id) return Entity_Id;\n       --  Locate TSS primitive Finalize_Address in type Typ\n@@ -351,13 +352,33 @@ package body Exp_Util is\n          Utyp : Entity_Id := Typ;\n \n       begin\n+         --  Handle protected class-wide or task class-wide types\n+\n+         if Is_Class_Wide_Type (Utyp) then\n+            if Is_Concurrent_Type (Root_Type (Utyp)) then\n+               Utyp := Root_Type (Utyp);\n+\n+            elsif Is_Private_Type (Root_Type (Utyp))\n+              and then Present (Full_View (Root_Type (Utyp)))\n+              and then Is_Concurrent_Type (Full_View (Root_Type (Utyp)))\n+            then\n+               Utyp := Full_View (Root_Type (Utyp));\n+            end if;\n+         end if;\n+\n+         --  Handle private types\n+\n          if Is_Private_Type (Utyp)\n            and then Present (Full_View (Utyp))\n          then\n             Utyp := Full_View (Utyp);\n          end if;\n \n-         if Is_Concurrent_Type (Utyp) then\n+         --  Handle protected and task types\n+\n+         if Is_Concurrent_Type (Utyp)\n+           and then Present (Corresponding_Record_Type (Utyp))\n+         then\n             Utyp := Corresponding_Record_Type (Utyp);\n          end if;\n \n@@ -459,18 +480,91 @@ package body Exp_Util is\n    --  Start of processing for Build_Allocate_Deallocate_Proc\n \n    begin\n-      --  The allocation / deallocation of a non-controlled object does not\n-      --  need the machinery created by this routine.\n+      --  Obtain the attributes of the allocation / deallocation\n+\n+      if Nkind (N) = N_Free_Statement then\n+         Expr := Expression (N);\n+         Ptr_Typ := Base_Type (Etype (Expr));\n+         Proc_To_Call := Procedure_To_Call (N);\n+\n+      else\n+         if Nkind (N) = N_Object_Declaration then\n+            Expr := Expression (N);\n+         else\n+            Expr := N;\n+         end if;\n+\n+         Ptr_Typ := Base_Type (Etype (Expr));\n+\n+         --  The allocator may have been rewritten into something else\n+\n+         if Nkind (Expr) = N_Allocator then\n+            Proc_To_Call := Procedure_To_Call (Expr);\n+         end if;\n+      end if;\n+\n+      Pool_Id := Associated_Storage_Pool (Ptr_Typ);\n+      Desig_Typ := Available_View (Designated_Type (Ptr_Typ));\n \n-      if not Needs_Finalization (Desig_Typ) then\n+      --  Handle concurrent types\n+\n+      if Is_Concurrent_Type (Desig_Typ)\n+        and then Present (Corresponding_Record_Type (Desig_Typ))\n+      then\n+         Desig_Typ := Corresponding_Record_Type (Desig_Typ);\n+      end if;\n+\n+      --  Do not process allocations / deallocations without a pool\n+\n+      if No (Pool_Id) then\n          return;\n \n-      --  The allocator or free statement has already been expanded and already\n-      --  has a custom Allocate / Deallocate routine.\n+      --  Do not process allocations on / deallocations from the secondary\n+      --  stack.\n+\n+      elsif Is_RTE (Pool_Id, RE_SS_Pool) then\n+         return;\n+\n+      --  Do not replicate the machinery if the allocator / free has already\n+      --  been expanded and has a custom Allocate / Deallocate.\n+\n+      elsif Present (Proc_To_Call)\n+        and then Is_Allocate_Deallocate_Proc (Proc_To_Call)\n+      then\n+         return;\n+      end if;\n+\n+      if Needs_Finalization (Desig_Typ) then\n+\n+         --  Certain run-time configurations and targets do not provide support\n+         --  for controlled types.\n+\n+         if Restriction_Active (No_Finalization) then\n+            return;\n+\n+         --  Do nothing if the access type may never allocate / deallocate\n+         --  objects.\n+\n+         elsif No_Pool_Assigned (Ptr_Typ) then\n+            return;\n+\n+         --  Access-to-controlled types are not supported on .NET/JVM since\n+         --  these targets cannot support pools and address arithmetic.\n+\n+         elsif VM_Target /= No_VM then\n+            return;\n+         end if;\n+\n+         --  The allocation / deallocation of a controlled object must be\n+         --  chained on / detached from a finalization master.\n+\n+         pragma Assert (Present (Finalization_Master (Ptr_Typ)));\n+\n+      --  The only other kind of allocation / deallocation supported by this\n+      --  routine is on / from a subpool.\n \n       elsif Nkind (Expr) = N_Allocator\n-        and then Present (Procedure_To_Call (Expr))\n-        and then Is_Allocate_Deallocate_Proc (Procedure_To_Call (Expr))\n+        and then No (Subpool_Handle_Name (Expr))\n       then\n          return;\n       end if;\n@@ -486,44 +580,35 @@ package body Exp_Util is\n          Fin_Addr_Id  : Entity_Id;\n          Fin_Mas_Act  : Node_Id;\n          Fin_Mas_Id   : Entity_Id;\n-         Fin_Mas_Typ  : Entity_Id;\n          Proc_To_Call : Entity_Id;\n+         Subpool      : Node_Id := Empty;\n \n       begin\n-         --  When dealing with an access subtype, always use the base type\n-         --  since it carries all the attributes.\n-\n-         if Ekind (Ptr_Typ) = E_Access_Subtype then\n-            Fin_Mas_Typ := Base_Type (Ptr_Typ);\n-         else\n-            Fin_Mas_Typ := Ptr_Typ;\n-         end if;\n-\n-         Actuals := New_List;\n-\n          --  Step 1: Construct all the actuals for the call to library routine\n          --  Allocate_Any_Controlled / Deallocate_Any_Controlled.\n \n          --  a) Storage pool\n \n-         Append_To (Actuals,\n-           New_Reference_To (Associated_Storage_Pool (Fin_Mas_Typ), Loc));\n+         Actuals := New_List (New_Reference_To (Pool_Id, Loc));\n \n          if Is_Allocate then\n \n             --  b) Subpool\n \n-            if Present (Subpool_Handle_Name (Expr)) then\n-               Append_To (Actuals,\n-                 New_Reference_To (Entity (Subpool_Handle_Name (Expr)), Loc));\n+            if Nkind (Expr) = N_Allocator then\n+               Subpool := Subpool_Handle_Name (Expr);\n+            end if;\n+\n+            if Present (Subpool) then\n+               Append_To (Actuals, New_Reference_To (Entity (Subpool), Loc));\n             else\n                Append_To (Actuals, Make_Null (Loc));\n             end if;\n \n             --  c) Finalization master\n \n             if Needs_Finalization (Desig_Typ) then\n-               Fin_Mas_Id  := Finalization_Master (Fin_Mas_Typ);\n+               Fin_Mas_Id  := Finalization_Master (Ptr_Typ);\n                Fin_Mas_Act := New_Reference_To (Fin_Mas_Id, Loc);\n \n                --  Handle the case where the master is actually a pointer to a\n@@ -545,7 +630,9 @@ package body Exp_Util is\n \n             Fin_Addr_Id := Find_Finalize_Address (Desig_Typ);\n \n-            if Present (Fin_Addr_Id) then\n+            if Needs_Finalization (Desig_Typ) then\n+               pragma Assert (Present (Fin_Addr_Id));\n+\n                Append_To (Actuals,\n                  Make_Attribute_Reference (Loc,\n                    Prefix         => New_Reference_To (Fin_Addr_Id, Loc),\n@@ -654,11 +741,23 @@ package body Exp_Util is\n \n                   Append_To (Actuals, New_Reference_To (Flag_Id, Loc));\n                end;\n+\n+            --  The object is statically known to be controlled\n+\n+            else\n+               Append_To (Actuals, New_Reference_To (Standard_True, Loc));\n             end if;\n          else\n             Append_To (Actuals, New_Reference_To (Standard_False, Loc));\n          end if;\n \n+         --  i) On_Subpool\n+\n+         if Is_Allocate then\n+            Append_To (Actuals,\n+              New_Reference_To (Boolean_Literals (Present (Subpool)), Loc));\n+         end if;\n+\n          --  Step 2: Build a wrapper Allocate / Deallocate which internally\n          --  calls Allocate_Any_Controlled / Deallocate_Any_Controlled.\n \n@@ -5296,6 +5395,16 @@ package body Exp_Util is\n       if Restriction_Active (No_Finalization) then\n          return False;\n \n+      --  C, C++, CIL and Java types are not considered controlled. It is\n+      --  assumed that the non-Ada side will handle their clean up.\n+\n+      elsif Convention (T) = Convention_C\n+        or else Convention (T) = Convention_CIL\n+        or else Convention (T) = Convention_CPP\n+        or else Convention (T) = Convention_Java\n+      then\n+         return False;\n+\n       else\n          --  Class-wide types are treated as controlled because derivations\n          --  from the root type can introduce controlled components."}, {"sha": "1f0ee42fc5d0daba62c5761ac13dec24ac32b876", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -198,8 +198,13 @@ package Exp_Util is\n      (N           : Node_Id;\n       Is_Allocate : Boolean);\n    --  Create a custom Allocate/Deallocate to be associated with an allocation\n-   --  or deallocation of a controlled or class-wide object. In the case of\n-   --  allocation, N is the declaration of the temporary variable which\n+   --  or deallocation:\n+   --\n+   --    1) controlled objects\n+   --    2) class-wide objects\n+   --    3) any kind of object on a subpool\n+   --\n+   --  N must be an allocator or the declaration of a temporary variable which\n    --  represents the expression of the original allocator node, otherwise N\n    --  must be a free statement. If flag Is_Allocate is set, the generated\n    --  routine is allocate, deallocate otherwise."}, {"sha": "3917aa40aa19cc5bd8c683a7fc3b77108cb3d1e4", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -1439,27 +1439,24 @@ package body Freeze is\n                end loop;\n             end;\n \n-         --  We add finalization collections to access types whose designated\n-         --  types require finalization. This is normally done when freezing\n-         --  the type, but this misses recursive type definitions where the\n-         --  later members of the recursion introduce controlled components\n-         --  (such as can happen when incomplete types are involved), as well\n-         --  cases where a component type is private and the controlled full\n-         --  type occurs after the access type is frozen. Cases that don't\n-         --  need a finalization collection are generic formal types (the\n-         --  actual type will have it) and types with Java and CIL conventions,\n-         --  since those are used for API bindings. (Are there any other cases\n-         --  that should be excluded here???)\n+         --  We add finalization masters to access types whose designated types\n+         --  require finalization. This is normally done when freezing the\n+         --  type, but this misses recursive type definitions where the later\n+         --  members of the recursion introduce controlled components (such as\n+         --  can happen when incomplete types are involved), as well cases\n+         --  where a component type is private and the controlled full type\n+         --  occurs after the access type is frozen. Cases that don't need a\n+         --  finalization master are generic formal types (the actual type will\n+         --  have it) and types with Java and CIL conventions, since those are\n+         --  used for API bindings. (Are there any other cases that should be\n+         --  excluded here???)\n \n          elsif Is_Access_Type (E)\n            and then Comes_From_Source (E)\n            and then not Is_Generic_Type (E)\n            and then Needs_Finalization (Designated_Type (E))\n-           and then No (Associated_Collection (E))\n-           and then Convention (Designated_Type (E)) /= Convention_Java\n-           and then Convention (Designated_Type (E)) /= Convention_CIL\n          then\n-            Build_Finalization_Collection (E);\n+            Build_Finalization_Master (E);\n          end if;\n \n          Next_Entity (E);"}, {"sha": "ea636fe8b0ad9088140ac353efc78a112e1689d5", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -346,6 +346,7 @@ package body Impunit is\n \n      \"s-addima\",    -- System.Address_Image\n      \"s-assert\",    -- System.Assertions\n+     \"s-finmas\",    -- System.Finalization_Masters\n      \"s-memory\",    -- System.Memory\n      \"s-parint\",    -- System.Partition_Interface\n      \"s-pooglo\",    -- System.Pool_Global\n@@ -508,6 +509,7 @@ package body Impunit is\n    Non_Imp_File_Names_12 : constant File_List := (\n      \"s-multip\",    -- System.Multiprocessors\n      \"s-mudido\",    -- System.Multiprocessors.Dispatching_Domains\n+     \"s-stposu\",    -- System.Storage_Pools.Subpools\n      \"a-cobove\",    -- Ada.Containers.Bounded_Vectors\n      \"a-cbdlli\",    -- Ada.Containers.Bounded_Doubly_Linked_Lists\n      \"a-cborse\",    -- Ada.Containers.Bounded_Ordered_Sets\n@@ -521,11 +523,13 @@ package body Impunit is\n      \"a-extiin\",    -- Ada.Execution_Time.Interrupts\n      \"a-iteint\",    -- Ada.Iterator_Interfaces\n      \"a-synbar\",    -- Ada.Synchronous_Barriers\n+     \"a-undesu\",    -- Ada.Unchecked_Deallocate_Subpool\n \n    -----------------------------------------\n    -- GNAT Defined Additions to Ada 20012 --\n    -----------------------------------------\n \n+     \"s-spsufi\",    -- System.Storage_Pools.Subpools.Finalization\n      \"a-cofove\",    -- Ada.Containers.Formal_Vectors\n      \"a-cfdlli\",    -- Ada.Containers.Formal_Doubly_Linked_Lists\n      \"a-cforse\",    -- Ada.Containers.Formal_Ordered_Sets"}, {"sha": "cd2b74c987c2d753548f9cabd9ccbb1e68b1911d", "filename": "gcc/ada/s-finmas.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fs-finmas.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fs-finmas.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finmas.ads?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -35,6 +35,8 @@ with Ada.Unchecked_Conversion;\n with System.Storage_Elements;\n with System.Storage_Pools;\n \n+pragma Compiler_Unit;\n+\n package System.Finalization_Masters is\n    pragma Preelaborate (System.Finalization_Masters);\n "}, {"sha": "86b18aad7df9bcabdda57550d19c89a99ef5ff47", "filename": "gcc/ada/s-spsufi.adb", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fs-spsufi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fs-spsufi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-spsufi.adb?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -0,0 +1,62 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--        S Y S T E M . S T O R A G E _ P O O L S . S U B P O O L S .       --\n+--                          F I N A L I Z A T I O N                         --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Storage_Pools.Subpools.Finalization is\n+\n+   -----------------------------\n+   -- Finalize_And_Deallocate --\n+   -----------------------------\n+\n+   procedure Finalize_And_Deallocate (Subpool : in out Subpool_Handle) is\n+   begin\n+      --  Do nothing if the subpool was never created or never used. The latter\n+      --  case may arise with an array of subpool implementations.\n+\n+      if Subpool = null\n+        or else Subpool.Owner = null\n+        or else Subpool.Node = null\n+      then\n+         return;\n+      end if;\n+\n+      --  Clean up all controlled objects allocated through the subpool\n+\n+      Finalize_Subpool (Subpool);\n+\n+      --  Dispatch to the user-defined implementation of Deallocate_Subpool\n+\n+      Deallocate_Subpool (Pool_Of_Subpool (Subpool).all, Subpool);\n+\n+      Subpool := null;\n+   end Finalize_And_Deallocate;\n+\n+end System.Storage_Pools.Subpools.Finalization;"}, {"sha": "66aac4b07a906122b4f7ecaaee40319542f63dcf", "filename": "gcc/ada/s-spsufi.ads", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fs-spsufi.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fs-spsufi.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-spsufi.ads?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -0,0 +1,44 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--        S Y S T E M . S T O R A G E _ P O O L S . S U B P O O L S .       --\n+--                          F I N A L I Z A T I O N                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Compiler_Unit;\n+\n+package System.Storage_Pools.Subpools.Finalization is\n+\n+   procedure Finalize_And_Deallocate (Subpool : in out Subpool_Handle);\n+   --  This routine performs the following actions:\n+   --    1) Finalize all objects chained on the subpool's master\n+   --    2) Remove the the subpool from the owner's list of subpools\n+   --    3) Deallocate the doubly linked list node associated with the subpool\n+   --    4) Call Deallocate_Subpool\n+\n+end System.Storage_Pools.Subpools.Finalization;"}, {"sha": "e7436c6088f07bdf6533526fe1552c4cb3ba6b02", "filename": "gcc/ada/s-stposu.adb", "status": "modified", "additions": 115, "deletions": 80, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fs-stposu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fs-stposu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stposu.adb?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -61,10 +61,6 @@ package body System.Storage_Pools.Subpools is\n       Alignment                : System.Storage_Elements.Storage_Count)\n    is\n    begin\n-      --  ??? The use of Allocate is very dangerous as it does not handle\n-      --  controlled objects properly. Perhaps we should provide an\n-      --  implementation which raises Program_Error instead.\n-\n       --  Dispatch to the user-defined implementations of Allocate_From_Subpool\n       --  and Default_Subpool_For_Pool.\n \n@@ -83,13 +79,14 @@ package body System.Storage_Pools.Subpools is\n \n    procedure Allocate_Any_Controlled\n      (Pool            : in out Root_Storage_Pool'Class;\n-      Context_Subpool : Subpool_Handle := null;\n-      Context_Master  : Finalization_Masters.Finalization_Master_Ptr := null;\n-      Fin_Address     : Finalization_Masters.Finalize_Address_Ptr := null;\n+      Context_Subpool : Subpool_Handle;\n+      Context_Master  : Finalization_Masters.Finalization_Master_Ptr;\n+      Fin_Address     : Finalization_Masters.Finalize_Address_Ptr;\n       Addr            : out System.Address;\n       Storage_Size    : System.Storage_Elements.Storage_Count;\n       Alignment       : System.Storage_Elements.Storage_Count;\n-      Is_Controlled   : Boolean := True)\n+      Is_Controlled   : Boolean;\n+      On_Subpool      : Boolean)\n    is\n       Is_Subpool_Allocation : constant Boolean :=\n                                 Pool in Root_Storage_Pool_With_Subpools'Class;\n@@ -108,7 +105,7 @@ package body System.Storage_Pools.Subpools is\n       --  Step 1: Pool-related runtime checks\n \n       --  Allocation on a pool_with_subpools. In this scenario there is a\n-      --  master for each subpool.\n+      --  master for each subpool. The master of the access type is ignored.\n \n       if Is_Subpool_Allocation then\n \n@@ -120,26 +117,21 @@ package body System.Storage_Pools.Subpools is\n               Default_Subpool_For_Pool\n                 (Root_Storage_Pool_With_Subpools'Class (Pool));\n \n-            --  Ensure proper ownership\n-\n-            if Subpool.Owner /=\n-                 Root_Storage_Pool_With_Subpools'Class (Pool)'Unchecked_Access\n-            then\n-               raise Program_Error with \"incorrect owner of default subpool\";\n-            end if;\n-\n          --  Allocation with a Subpool_Handle\n \n          else\n             Subpool := Context_Subpool;\n+         end if;\n \n-            --  Ensure proper ownership\n+         --  Ensure proper ownership and chaining of the subpool\n \n-            if Subpool.Owner /=\n-                 Root_Storage_Pool_With_Subpools'Class (Pool)'Unchecked_Access\n-            then\n-               raise Program_Error with \"incorrect owner of subpool\";\n-            end if;\n+         if Subpool.Owner /=\n+              Root_Storage_Pool_With_Subpools'Class (Pool)'Unchecked_Access\n+           or else Subpool.Node = null\n+           or else Subpool.Node.Prev = null\n+           or else Subpool.Node.Next = null\n+         then\n+            raise Program_Error with \"incorrect owner of subpool\";\n          end if;\n \n          Master := Subpool.Master'Unchecked_Access;\n@@ -148,25 +140,35 @@ package body System.Storage_Pools.Subpools is\n       --  each access-to-controlled type. No context subpool should be present.\n \n       else\n-\n          --  If the master is missing, then the expansion of the access type\n          --  failed to create one. This is a serious error.\n \n          if Context_Master = null then\n             raise Program_Error with \"missing master in pool allocation\";\n+         end if;\n \n          --  If a subpool is present, then this is the result of erroneous\n          --  allocator expansion. This is not a serious error, but it should\n          --  still be detected.\n \n-         elsif Context_Subpool /= null then\n+         if Context_Subpool /= null then\n             raise Program_Error with \"subpool not required in pool allocation\";\n          end if;\n \n+         --  If the allocation is intended to be on a subpool, but the access\n+         --  type's pool does not support subpools, then this is the result of\n+         --  erroneous end-user code.\n+\n+         if On_Subpool then\n+            raise Program_Error\n+              with \"pool of access type does not support subpools\";\n+         end if;\n+\n          Master := Context_Master;\n       end if;\n \n-      --  Step 2: Master-related runtime checks and size calculations\n+      --  Step 2: Master and Finalize_Address-related runtime checks and size\n+      --  calculations.\n \n       --  Allocation of a descendant from [Limited_]Controlled, a class-wide\n       --  object or a record with controlled components.\n@@ -180,6 +182,15 @@ package body System.Storage_Pools.Subpools is\n             raise Program_Error with \"allocation after finalization started\";\n          end if;\n \n+         --  Check whether primitive Finalize_Address is available. If it is\n+         --  not, then either the expansion of the designated type failed or\n+         --  the expansion of the allocator failed. This is a serious error.\n+\n+         if Fin_Address = null then\n+            raise Program_Error\n+              with \"primitive Finalize_Address not available\";\n+         end if;\n+\n          --  The size must acount for the hidden header preceding the object.\n          --  Account for possible padding space before the header due to a\n          --  larger alignment.\n@@ -224,29 +235,20 @@ package body System.Storage_Pools.Subpools is\n          --  due to larger alignment, the header is placed right next to the\n          --  object:\n \n-         --    N_Addr  N_Ptr\n-         --    |       |\n-         --    V       V\n-         --    +-------+---------------+----------------------+\n-         --    |Padding|    Header     |        Object        |\n-         --    +-------+---------------+----------------------+\n-         --    ^       ^               ^\n-         --    |       +- Header_Size -+\n-         --    |                       |\n-         --    +- Header_And_Padding --+\n+         --     N_Addr  N_Ptr\n+         --     |       |\n+         --     V       V\n+         --     +-------+---------------+----------------------+\n+         --     |Padding|    Header     |        Object        |\n+         --     +-------+---------------+----------------------+\n+         --     ^       ^               ^\n+         --     |       +- Header_Size -+\n+         --     |                       |\n+         --     +- Header_And_Padding --+\n \n          N_Ptr :=\n            Address_To_FM_Node_Ptr (N_Addr + Header_And_Padding - Header_Size);\n \n-         --  Check whether primitive Finalize_Address is available. If it is\n-         --  not, then either the expansion of the designated type failed or\n-         --  the expansion of the allocator failed. This is a serious error.\n-\n-         if Fin_Address = null then\n-            raise Program_Error\n-              with \"primitive Finalize_Address not available\";\n-         end if;\n-\n          N_Ptr.Finalize_Address := Fin_Address;\n \n          --  Prepend the allocated object to the finalization master\n@@ -268,6 +270,10 @@ package body System.Storage_Pools.Subpools is\n \n    procedure Attach (N : not null SP_Node_Ptr; L : not null SP_Node_Ptr) is\n    begin\n+      --  Ensure that the node has not been attached already\n+\n+      pragma Assert (N.Prev = null and then N.Next = null);\n+\n       Lock_Task.all;\n \n       L.Next.Prev := N;\n@@ -290,7 +296,7 @@ package body System.Storage_Pools.Subpools is\n       Addr          : System.Address;\n       Storage_Size  : System.Storage_Elements.Storage_Count;\n       Alignment     : System.Storage_Elements.Storage_Count;\n-      Is_Controlled : Boolean := True)\n+      Is_Controlled : Boolean)\n    is\n       N_Addr : Address;\n       N_Ptr  : FM_Node_Ptr;\n@@ -360,7 +366,7 @@ package body System.Storage_Pools.Subpools is\n \n    procedure Detach (N : not null SP_Node_Ptr) is\n    begin\n-      --  N must be attached to some list\n+      --  Ensure that the node is attached to some list\n \n       pragma Assert (N.Next /= null and then N.Prev /= null);\n \n@@ -379,22 +385,22 @@ package body System.Storage_Pools.Subpools is\n    -- Finalize --\n    --------------\n \n-   overriding procedure Finalize\n-     (Pool : in out Root_Storage_Pool_With_Subpools)\n-   is\n+   overriding procedure Finalize (Controller : in out Pool_Controller) is\n+   begin\n+      Finalize_Pool (Controller.Enclosing_Pool.all);\n+   end Finalize;\n+\n+   -------------------\n+   -- Finalize_Pool --\n+   -------------------\n+\n+   procedure Finalize_Pool (Pool : in out Root_Storage_Pool_With_Subpools) is\n       Curr_Ptr : SP_Node_Ptr;\n       Ex_Occur : Exception_Occurrence;\n       Next_Ptr : SP_Node_Ptr;\n       Raised   : Boolean := False;\n \n    begin\n-      --  Uninitialized pools do not have subpools and do not contain objects\n-      --  of any kind.\n-\n-      if not Pool.Initialized then\n-         return;\n-      end if;\n-\n       --  It is possible for multiple tasks to cause the finalization of a\n       --  common pool. Allow only one task to finalize the contents.\n \n@@ -415,11 +421,12 @@ package body System.Storage_Pools.Subpools is\n       while Curr_Ptr /= Pool.Subpools'Unchecked_Access loop\n          Next_Ptr := Curr_Ptr.Next;\n \n-         --  Remove the subpool node from the subpool list\n+         --  Perform the following actions:\n \n-         Detach (Curr_Ptr);\n-\n-         --  Finalize the current subpool\n+         --    1) Finalize all objects chained on the subpool's master\n+         --    2) Remove the the subpool from the owner's list of subpools\n+         --    3) Deallocate the doubly linked list node associated with the\n+         --       subpool.\n \n          begin\n             Finalize_Subpool (Curr_Ptr.Subpool);\n@@ -432,11 +439,6 @@ package body System.Storage_Pools.Subpools is\n                end if;\n          end;\n \n-         --  Since subpool nodes are not allocated on the owner pool, they must\n-         --  be explicitly destroyed.\n-\n-         Free (Curr_Ptr);\n-\n          Curr_Ptr := Next_Ptr;\n       end loop;\n \n@@ -446,17 +448,57 @@ package body System.Storage_Pools.Subpools is\n       if Raised then\n          Reraise_Occurrence (Ex_Occur);\n       end if;\n-   end Finalize;\n+   end Finalize_Pool;\n \n    ----------------------\n    -- Finalize_Subpool --\n    ----------------------\n \n    procedure Finalize_Subpool (Subpool : not null Subpool_Handle) is\n    begin\n+      --  Do nothing if the subpool was never used\n+\n+      if Subpool.Owner = null\n+        or else Subpool.Node = null\n+      then\n+         return;\n+      end if;\n+\n+      --  Clean up all controlled objects chained on the subpool's master\n+\n       Finalize (Subpool.Master);\n+\n+      --  Remove the subpool from its owner's list of subpools\n+\n+      Detach (Subpool.Node);\n+\n+      --  Destroy the associated doubly linked list node which was created in\n+      --  Set_Pool_Of_Subpool.\n+\n+      Free (Subpool.Node);\n    end Finalize_Subpool;\n \n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   overriding procedure Initialize (Controller : in out Pool_Controller) is\n+   begin\n+      Initialize_Pool (Controller.Enclosing_Pool.all);\n+   end Initialize;\n+\n+   ---------------------\n+   -- Initialize_Pool --\n+   ---------------------\n+\n+   procedure Initialize_Pool (Pool : in out Root_Storage_Pool_With_Subpools) is\n+   begin\n+      --  The dummy head must point to itself in both directions\n+\n+      Pool.Subpools.Next := Pool.Subpools'Unchecked_Access;\n+      Pool.Subpools.Prev := Pool.Subpools'Unchecked_Access;\n+   end Initialize_Pool;\n+\n    ---------------------\n    -- Pool_Of_Subpool --\n    ---------------------\n@@ -478,15 +520,6 @@ package body System.Storage_Pools.Subpools is\n       N_Ptr : SP_Node_Ptr;\n \n    begin\n-      if not Pool.Initialized then\n-\n-         --  The dummy head must point to itself in both directions\n-\n-         Pool.Subpools.Next := Pool.Subpools'Unchecked_Access;\n-         Pool.Subpools.Prev := Pool.Subpools'Unchecked_Access;\n-         Pool.Initialized   := True;\n-      end if;\n-\n       --  If the subpool is already owned, raise Program_Error. This is a\n       --  direct violation of the RM rules.\n \n@@ -502,13 +535,15 @@ package body System.Storage_Pools.Subpools is\n            with \"subpool creation after finalization started\";\n       end if;\n \n-      --  Create a subpool node, decorate it and associate it with the subpool\n-      --  list of Pool.\n+      Subpool.Owner := Pool'Unchecked_Access;\n \n-      N_Ptr := new SP_Node;\n+      --  Create a subpool node and decorate it. Since this node is not\n+      --  allocated on the owner's pool, it must be explicitly destroyed by\n+      --  Finalize_And_Detach.\n \n-      Subpool.Owner := Pool'Unchecked_Access;\n+      N_Ptr := new SP_Node;\n       N_Ptr.Subpool := Subpool;\n+      Subpool.Node := N_Ptr;\n \n       Attach (N_Ptr, Pool.Subpools'Unchecked_Access);\n    end Set_Pool_Of_Subpool;"}, {"sha": "bd2681869264a43444d8e750ff7c0c43b1eb99ae", "filename": "gcc/ada/s-stposu.ads", "status": "modified", "additions": 151, "deletions": 67, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fs-stposu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fs-stposu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stposu.ads?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -33,6 +33,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Ada.Finalization;\n+\n with System.Finalization_Masters;\n with System.Storage_Elements;\n \n@@ -61,7 +63,8 @@ package System.Storage_Pools.Subpools is\n       Size_In_Storage_Elements : System.Storage_Elements.Storage_Count;\n       Alignment                : System.Storage_Elements.Storage_Count);\n    --  Allocate an object described by Size_In_Storage_Elements and Alignment\n-   --  on the default subpool of Pool.\n+   --  on the default subpool of Pool. Controlled types allocated through this\n+   --  routine will NOT be handled properly.\n \n    procedure Allocate_From_Subpool\n      (Pool                     : in out Root_Storage_Pool_With_Subpools;\n@@ -126,50 +129,45 @@ package System.Storage_Pools.Subpools is\n \n private\n    --  Model\n-   --                           Pool_With_Subpools\n-   --                 +----> +---------------------+ <----+\n-   --                 |  +---------- Subpools      |      |\n-   --                 |  |   +---------------------+      |\n-   --                 |  |   :      User data      :      |\n-   --                 |  |   '.....................'      |\n-   --                 |  |                                |\n-   --                 |  |    SP_Node       SP_Node       |\n-   --                 |  +-> +-------+     +-------+      |\n-   --                 |      | Prev  <-----> Prev  |      |\n-   --                 |      +-------+     +-------+      |\n-   --                 |      | Next  <---->| Next  |      |\n-   --                 |      +-------+     +-------+      |\n-   --                 |  +----Subpool|     |Subpool----+  |\n-   --                 |  |   +-------+     +-------+   |  |\n-   --                 |  |                             |  |\n-   --                 |  |    Subpool       Subpool    |  |\n-   --                 |  +-> +-------+     +-------+ <-+  |\n-   --                 +------- Owner |     | Owner -------+\n-   --                        +-------+     +-------+\n-   --     +------------------- Master|     | Master---------------+\n-   --     |                  +-------+     +-------+              |\n-   --     |                  : User  :     : User  :              |\n-   --     |                  : Data  :     : Data  :              |\n-   --     |                  '.......'     '.......'              |\n-   --     |                                                       |\n-   --     |                           Heap                        |\n-   --  .. | ..................................................... | ..\n-   --  :  |                                                       |  :\n-   --  :  |    Object    Object    Object               Object    |  :\n-   --  :  +-> +------+  +------+  +------+             +------+ <-+  :\n-   --  :      | Prev <--> Prev <--> Prev |             | Prev |      :\n-   --  :      +------+  +------+  +------+             +------+      :\n-   --  :      | Next <--> Next <--> Next |             | Next |      :\n-   --  :      +------+  +------+  +------+             +------+      :\n-   --  :      |  FA  |  |  FA  |  |  FA  |             |  FA  |      :\n-   --  :      +------+  +------+  +------+             +------+      :\n-   --  :      :      :  :      :  :      :             :      :      :\n-   --  :      :      :  :      :  :      :             :      :      :\n-   --  :      '......'  '......'  '......'             '......'      :\n-   --  :                                                             :\n-   --  '.............................................................'\n+   --             Pool_With_Subpools     SP_Node    SP_Node    SP_Node\n+   --       +-->+--------------------+   +-----+    +-----+    +-----+\n+   --       |   |      Subpools -------->|  ------->|  ------->|  ------->\n+   --       |   +--------------------+   +-----+    +-----+    +-----+\n+   --       |   |Finalization_Started|<------  |<-------  |<-------  |<---\n+   --       |   +--------------------+   +-----+    +-----+    +-----+\n+   --       +--- Controller.Encl_Pool|   | nul |    |  +  |    |  +  |\n+   --       |   +--------------------+   +-----+    +--|--+    +--:--+\n+   --       |   :                    :    Dummy        |  ^       :\n+   --       |   :                    :                 |  |       :\n+   --       |                            Root_Subpool  V  |\n+   --       |                            +-------------+  |\n+   --       +-------------------------------- Owner    |  |\n+   --               FM_Node   FM_Node    +-------------+  |\n+   --               +-----+   +-----+<-- Master.Objects|  |\n+   --            <------  |<------  |    +-------------+  |\n+   --               +-----+   +-----+    |    Node -------+\n+   --               |  ------>|  ----->  +-------------+\n+   --               +-----+   +-----+    :             :\n+   --               |ctrl |    Dummy     :             :\n+   --               | obj |\n+   --               +-----+\n+   --\n+   --  SP_Nodes are created on the heap. FM_Nodes and associated objects are\n+   --  created on the pool_with_subpools.\n+\n+   type Any_Storage_Pool_With_Subpools_Ptr\n+     is access all Root_Storage_Pool_With_Subpools'Class;\n+   for Any_Storage_Pool_With_Subpools_Ptr'Storage_Size use 0;\n+\n+   --  A pool controller is a special controlled object which ensures the\n+   --  proper initialization and finalization of the enclosing pool.\n+\n+   type Pool_Controller (Enclosing_Pool : Any_Storage_Pool_With_Subpools_Ptr)\n+     is new Ada.Finalization.Limited_Controlled with null record;\n \n    --  Subpool list types. Each pool_with_subpools contains a list of subpools.\n+   --  This is an indirect doubly linked list since subpools are not supposed\n+   --  to be allocatable by language design.\n \n    type SP_Node;\n    type SP_Node_Ptr is access all SP_Node;\n@@ -180,19 +178,26 @@ private\n       Subpool : Subpool_Handle := null;\n    end record;\n \n-   --  Root_Storage_Pool_With_Subpools internal structure\n+   --  Root_Storage_Pool_With_Subpools internal structure. The type uses a\n+   --  special controller to perform initialization and finalization actions\n+   --  on itself. This is necessary because the end user of this package may\n+   --  decide to override Initialize and Finalize, thus disabling the desired\n+   --  behavior.\n+\n+   --          Pool_With_Subpools     SP_Node    SP_Node    SP_Node\n+   --    +-->+--------------------+   +-----+    +-----+    +-----+\n+   --    |   |      Subpools -------->|  ------->|  ------->|  ------->\n+   --    |   +--------------------+   +-----+    +-----+    +-----+\n+   --    |   |Finalization_Started|   :     :    :     :    :     :\n+   --    |   +--------------------+\n+   --    +--- Controller.Encl_Pool|\n+   --        +--------------------+\n+   --        :       End-user     :\n+   --        :      components    :\n \n    type Root_Storage_Pool_With_Subpools is abstract\n      new Root_Storage_Pool with\n    record\n-      Initialized : Boolean := False;\n-      pragma Atomic (Initialized);\n-      --  Even though this type is derived from Limited_Controlled, overriding\n-      --  Initialize would have no effect since the type is abstract. Routine\n-      --  Set_Pool_Of_Subpool is tasked with the initialization of a pool with\n-      --  subpools because it has to be called at some point. This flag is used\n-      --  to prevent the resetting of the subpool chain.\n-\n       Subpools : aliased SP_Node;\n       --  A doubly linked list of subpools\n \n@@ -201,55 +206,134 @@ private\n       --  A flag which prevents the creation of new subpools while the master\n       --  pool is being finalized. The flag needs to be atomic because it is\n       --  accessed without Lock_Task / Unlock_Task.\n-   end record;\n \n-   type Any_Storage_Pool_With_Subpools_Ptr\n-     is access all Root_Storage_Pool_With_Subpools'Class;\n-   for Any_Storage_Pool_With_Subpools_Ptr'Storage_Size use 0;\n+      Controller : Pool_Controller\n+                     (Root_Storage_Pool_With_Subpools'Unchecked_Access);\n+      --  A component which ensures that the enclosing pool is initialized and\n+      --  finalized at the appropriate places.\n+   end record;\n \n    --  A subpool is an abstraction layer which sits on top of a pool. It\n    --  contains links to all controlled objects allocated on a particular\n    --  subpool.\n \n+   --        Pool_With_Subpools   SP_Node    SP_Node    SP_Node\n+   --    +-->+----------------+   +-----+    +-----+    +-----+\n+   --    |   |    Subpools ------>|  ------->|  ------->|  ------->\n+   --    |   +----------------+   +-----+    +-----+    +-----+\n+   --    |   :                :<------  |<-------  |<-------  |\n+   --    |   :                :   +-----+    +-----+    +-----+\n+   --    |                        |null |    |  +  |    |  +  |\n+   --    |                        +-----+    +--|--+    +--:--+\n+   --    |                                      |  ^       :\n+   --    |                        Root_Subpool  V  |\n+   --    |                        +-------------+  |\n+   --    +---------------------------- Owner    |  |\n+   --                             +-------------+  |\n+   --                      .......... Master    |  |\n+   --                             +-------------+  |\n+   --                             |    Node -------+\n+   --                             +-------------+\n+   --                             :   End-user  :\n+   --                             :  components :\n+\n    type Root_Subpool is abstract tagged limited record\n       Owner : Any_Storage_Pool_With_Subpools_Ptr := null;\n       --  A reference to the master pool_with_subpools\n \n       Master : aliased System.Finalization_Masters.Finalization_Master;\n       --  A collection of controlled objects\n+\n+      Node : SP_Node_Ptr := null;\n+      --  A link to the doubly linked list node which contains the subpool.\n+      --  This back pointer is used in subpool deallocation.\n    end record;\n \n    --  ??? Once Storage_Pools.Allocate_Any is removed, this should be renamed\n    --  to Allocate_Any.\n \n    procedure Allocate_Any_Controlled\n      (Pool            : in out Root_Storage_Pool'Class;\n-      Context_Subpool : Subpool_Handle := null;\n-      Context_Master  : Finalization_Masters.Finalization_Master_Ptr := null;\n-      Fin_Address     : Finalization_Masters.Finalize_Address_Ptr := null;\n+      Context_Subpool : Subpool_Handle;\n+      Context_Master  : Finalization_Masters.Finalization_Master_Ptr;\n+      Fin_Address     : Finalization_Masters.Finalize_Address_Ptr;\n       Addr            : out System.Address;\n       Storage_Size    : System.Storage_Elements.Storage_Count;\n       Alignment       : System.Storage_Elements.Storage_Count;\n-      Is_Controlled   : Boolean := True);\n+      Is_Controlled   : Boolean;\n+      On_Subpool      : Boolean);\n    --  Compiler interface. This version of Allocate handles all possible cases,\n-   --  either on a pool or a pool_with_subpools.\n+   --  either on a pool or a pool_with_subpools, regardless of the controlled\n+   --  status of the allocated object. Parameter usage:\n+   --\n+   --    * Pool - The pool associated with the access type. Pool can be any\n+   --    derivation from Root_Storage_Pool, including a pool_with_subpools.\n+   --\n+   --    * Context_Subpool - The subpool handle name of an allocator. If no\n+   --    subpool handle is present at the point of allocation, the actual\n+   --    would be null.\n+   --\n+   --    * Context_Master - The finalization master associated with the access\n+   --    type. If the access type's designated type is not controlled, the\n+   --    actual would be null.\n+   --\n+   --    * Fin_Address - TSS routine Finalize_Address of the designated type.\n+   --    If the designated type is not controlled, the actual would be null.\n+   --\n+   --    * Addr - The address of the allocated object.\n+   --\n+   --    * Storage_Size - The size of the allocated object.\n+   --\n+   --    * Alignment - The alignment of the allocated object.\n+   --\n+   --    * Is_Controlled - A flag which determines whether the allocated object\n+   --    is controlled. When set to True, the machinery generates additional\n+   --    data.\n+   --\n+   --    * On_Subpool - A flag which determines whether the a subpool handle\n+   --    name is present at the point of allocation. This is used for error\n+   --    diagnostics.\n \n    procedure Deallocate_Any_Controlled\n      (Pool          : in out Root_Storage_Pool'Class;\n       Addr          : System.Address;\n       Storage_Size  : System.Storage_Elements.Storage_Count;\n       Alignment     : System.Storage_Elements.Storage_Count;\n-      Is_Controlled : Boolean := True);\n+      Is_Controlled : Boolean);\n    --  Compiler interface. This version of Deallocate handles all possible\n-   --  cases, either from a pool or a pool_with_subpools.\n-\n-   overriding procedure Finalize\n-     (Pool : in out Root_Storage_Pool_With_Subpools);\n+   --  cases, either from a pool or a pool_with_subpools, regardless of the\n+   --  controlled status of the deallocated object. Parameter usage:\n+   --\n+   --    * Pool - The pool associated with the access type. Pool can be any\n+   --    derivation from Root_Storage_Pool, including a pool_with_subpools.\n+   --\n+   --    * Addr - The address of the allocated object.\n+   --\n+   --    * Storage_Size - The size of the allocated object.\n+   --\n+   --    * Alignment - The alignment of the allocated object.\n+   --\n+   --    * Is_Controlled - A flag which determines whether the allocated object\n+   --    is controlled. When set to True, the machinery generates additional\n+   --    data.\n+\n+   overriding procedure Finalize (Controller : in out Pool_Controller);\n+   --  Buffer routine, calls Finalize_Pool\n+\n+   procedure Finalize_Pool (Pool : in out Root_Storage_Pool_With_Subpools);\n    --  Iterate over all subpools of Pool, detach them one by one and finalize\n    --  their masters. This action first detaches a controlled object from a\n    --  particular master, then invokes its Finalize_Address primitive.\n \n    procedure Finalize_Subpool (Subpool : not null Subpool_Handle);\n-   --  Finalize the master of a subpool\n+   --  Finalize all controlled objects chained on Subpool's master. Remove the\n+   --  subpool from its owner's list. Deallocate the associated doubly linked\n+   --  list node.\n+\n+   overriding procedure Initialize (Controller : in out Pool_Controller);\n+   --  Buffer routine, calls Initialize_Pool\n+\n+   procedure Initialize_Pool (Pool : in out Root_Storage_Pool_With_Subpools);\n+   --  Setup the doubly linked list of subpools\n \n end System.Storage_Pools.Subpools;"}, {"sha": "ec108be4e478930848fd9719a0843e6a2cc35839", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 47, "deletions": 16, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -1309,6 +1309,10 @@ package body Sem_Aggr is\n       --  for discrete choices such as \"L .. H => Expr\" or the OTHERS choice).\n       --  In this event we do not resolve Expr unless expansion is disabled.\n       --  To know why, see the DELAYED COMPONENT RESOLUTION note above.\n+      --\n+      --  NOTE: In the case of \"... => <>\", we pass the in the\n+      --  N_Component_Association node as Expr, since there is no Expression in\n+      --  that case, and we need a Sloc for the error message.\n \n       ---------\n       -- Add --\n@@ -1635,6 +1639,13 @@ package body Sem_Aggr is\n                end if;\n             end if;\n \n+            --  If it's \"... => <>\", nothing to resolve\n+\n+            if Nkind (Expr) = N_Component_Association then\n+               pragma Assert (Box_Present (Expr));\n+               return Success;\n+            end if;\n+\n             --  Ada 2005 (AI-231): Propagate the type to the nested aggregate.\n             --  Required to check the null-exclusion attribute (if present).\n             --  This value may be overridden later on.\n@@ -1644,19 +1655,29 @@ package body Sem_Aggr is\n             Resolution_OK := Resolve_Array_Aggregate\n               (Expr, Nxt_Ind, Nxt_Ind_Constr, Component_Typ, Others_Allowed);\n \n-         --  Do not resolve the expressions of discrete or others choices\n-         --  unless the expression covers a single component, or the expander\n-         --  is inactive.\n+         else\n+\n+            --  If it's \"... => <>\", nothing to resolve\n \n-         elsif Single_Elmt\n-           or else not Expander_Active\n-           or else In_Spec_Expression\n-         then\n-            Analyze_And_Resolve (Expr, Component_Typ);\n-            Check_Expr_OK_In_Limited_Aggregate (Expr);\n-            Check_Non_Static_Context (Expr);\n-            Aggregate_Constraint_Checks (Expr, Component_Typ);\n-            Check_Unset_Reference (Expr);\n+            if Nkind (Expr) = N_Component_Association then\n+               pragma Assert (Box_Present (Expr));\n+               return Success;\n+            end if;\n+\n+            --  Do not resolve the expressions of discrete or others choices\n+            --  unless the expression covers a single component, or the\n+            --  expander is inactive.\n+\n+            if Single_Elmt\n+              or else not Expander_Active\n+              or else In_Spec_Expression\n+            then\n+               Analyze_And_Resolve (Expr, Component_Typ);\n+               Check_Expr_OK_In_Limited_Aggregate (Expr);\n+               Check_Non_Static_Context (Expr);\n+               Aggregate_Constraint_Checks (Expr, Component_Typ);\n+               Check_Unset_Reference (Expr);\n+            end if;\n          end if;\n \n          if Raises_Constraint_Error (Expr)\n@@ -1988,9 +2009,15 @@ package body Sem_Aggr is\n \n                   --  Ada 2005 (AI-287): In case of default initialization of a\n                   --  component the expander will generate calls to the\n-                  --  corresponding initialization subprogram.\n+                  --  corresponding initialization subprogram. We need to call\n+                  --  Resolve_Aggr_Expr to check the rules about\n+                  --  dimensionality.\n \n-                  null;\n+                  if not Resolve_Aggr_Expr (Assoc,\n+                                            Single_Elmt => Single_Choice)\n+                  then\n+                     return Failure;\n+                  end if;\n \n                elsif not Resolve_Aggr_Expr (Expression (Assoc),\n                                             Single_Elmt => Single_Choice)\n@@ -2321,9 +2348,13 @@ package body Sem_Aggr is\n \n                --  Ada 2005 (AI-287): In case of default initialization of a\n                --  component the expander will generate calls to the\n-               --  corresponding initialization subprogram.\n+               --  corresponding initialization subprogram. We need to call\n+               --  Resolve_Aggr_Expr to check the rules about\n+               --  dimensionality.\n \n-               null;\n+               if not Resolve_Aggr_Expr (Assoc, Single_Elmt => False) then\n+                  return Failure;\n+               end if;\n \n             elsif not Resolve_Aggr_Expr (Expression (Assoc),\n                                          Single_Elmt => False)"}, {"sha": "db7e37bbb369ce81d119fd9a52cb80394a6696c4", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -1471,6 +1471,7 @@ package body Sem_Ch13 is\n \n                else\n                   case A_Id is\n+\n                      --  For Pre/Post cases, insert immediately after the\n                      --  entity declaration, since that is the required pragma\n                      --  placement."}, {"sha": "b8fd3e7533fca1688c23cb91605fc2329d0b29a2", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca5af305a13a6f886dc6b6e0a07863c7eeefdbee/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=ca5af305a13a6f886dc6b6e0a07863c7eeefdbee", "patch": "@@ -2348,7 +2348,7 @@ package body Sem_Ch6 is\n          --  the proper back-annotations.\n \n          if not Is_Frozen (Spec_Id)\n-           and then (Expander_Active or ASIS_Mode)\n+           and then (Expander_Active or else ASIS_Mode)\n          then\n             --  Force the generation of its freezing node to ensure proper\n             --  management of access types in the backend.\n@@ -6081,14 +6081,13 @@ package body Sem_Ch6 is\n             end if;\n \n             --  In the case of functions whose result type needs finalization,\n-            --  add an extra formal of type Ada.Finalization.Heap_Management.\n-            --  Finalization_Collection_Ptr.\n+            --  add an extra formal which represents the finalization master.\n \n-            if Needs_BIP_Collection (E) then\n+            if Needs_BIP_Finalization_Master (E) then\n                Discard :=\n                  Add_Extra_Formal\n-                   (E, RTE (RE_Finalization_Collection_Ptr),\n-                    E, BIP_Formal_Suffix (BIP_Collection));\n+                   (E, RTE (RE_Finalization_Master_Ptr),\n+                    E, BIP_Formal_Suffix (BIP_Finalization_Master));\n             end if;\n \n             --  If the result type contains tasks, we have two extra formals:"}]}