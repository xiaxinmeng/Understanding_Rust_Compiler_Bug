{"sha": "6060a79633cdde2801b51dbef337d0ce675b9950", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA2MGE3OTYzM2NkZGUyODAxYjUxZGJlZjMzN2QwY2U2NzViOTk1MA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-12-16T02:07:31Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-12-16T02:07:31Z"}, "message": "50th Cygnus<->FSF merge\n\nFrom-SVN: r8657", "tree": {"sha": "8a02e75662e98df5e0186667cb7832faad0a29a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a02e75662e98df5e0186667cb7832faad0a29a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6060a79633cdde2801b51dbef337d0ce675b9950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6060a79633cdde2801b51dbef337d0ce675b9950", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6060a79633cdde2801b51dbef337d0ce675b9950", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6060a79633cdde2801b51dbef337d0ce675b9950/comments", "author": null, "committer": null, "parents": [{"sha": "27efbf21c87e830be3786d61a0519f0c9a2f5cec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27efbf21c87e830be3786d61a0519f0c9a2f5cec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27efbf21c87e830be3786d61a0519f0c9a2f5cec"}], "stats": {"total": 1107, "additions": 750, "deletions": 357}, "files": [{"sha": "8fa9479866ed5f01039b8999b10e0137778805eb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 288, "deletions": 69, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -1,3 +1,80 @@\n+Thu Dec 15 16:32:12 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl2.c (check_classfn): Use decls_match to check if this has\n+\talready been declared, as the DECL_ASSEMBLER_NAME may have been\n+\tchanged via asm(\"new_name\").\n+\t* decl.c (decls_match): Make public.\n+\n+Thu Dec 15 15:17:55 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* *.[chy] (expand_aggr_init) Add fourth argument to handle\n+\tdistinction between = init and (init) style of initializations.\n+\t* *.[chy] (finish_decl): Add fifth argument to to handle\n+\tdistinction between = init and (init) style of initializations.\n+\n+Tue Dec 13 19:16:05 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\tFix some random `explicit' bugs.\n+\n+\t* cvt.c (convert_to_reference): Add third parameter to\n+\tconvert_force.\n+\t(convert_force): Ditto.\n+\t* call.c (build_method_call): Ditto.\n+\t* decl2.c (setup_vtbl_ptr): Ditto.\n+\t* init.c (expand_virtual_init): Ditto.\n+\t(build_member_call): Ditto.\n+\t(build_delete): Ditto.\n+\t(build_vbase_delete): Ditto.\n+\t* typeck.c (build_component_addr): Ditto.\n+\t(build_c_cast): Ditto.\n+\t(build_modify_expr): Ditto.\n+\t* cp-tree.h (CONV_NONCONVERTING): Ditto. Add so that we can\n+\tdistinguish the context in which the conversion appears.  Add thrid\n+\targument to build_c_cast.\n+\t* cvt.c (cp_convert): Pass whether or not we want to consider\n+\tnon-converting constructors down to build_method_call.\n+\t* decl2.c (reparse_absdcl_as_casts): Add third argument to\n+\tbuild_c_cast.\n+\t* gc.c (build_m_desc): Ditto.\n+\t* init.c (build_new): Ditto.\n+\t* parse.y (expr_no_commas): Ditto.\n+\t(primary): Ditto.\n+\t* typeck.c (build_x_function_call): Ditto.\n+\t(build_static_cast): Ditto.\n+\t(build_reinterpret_cast): Ditto.\n+\t(build_const_cast): Ditto.\n+\t(build_c_cast): Ditto.\n+\t(build_ptrmemfunc): Ditto.\n+\t* typeck2.c (build_functional_cast): Ditto.\n+\t* init.c (expand_aggr_init): Added LOOKUP_ONLYCONVERTING to\n+\texpand_aggr_init_1 as inits are converted to the destination type.\n+\n+Tue Dec 13 16:18:57 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* Make-lang.in (cc1plus): Depends on c-pragma.o.\n+\n+\t* Makefile.in (OBJ{DEP,}S): Add ../c-pragma.o.\n+\n+\t* lex.c (check_newline): If the #pragma is not recognized by g++,\n+\ttry machine-specific ones too.\n+\t(handle_sysv_pragma): Copied from c-lex.c.\n+\n+Mon Dec 12 23:53:06 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_throw): Fix Dec 6th change, build_new likes a\n+\treference better.\n+\n+Mon Dec 12 18:01:00 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (build_binary_op): Lose checks on TYPE_PTRMEMFUNC_P with\n+\tIS_AGGR_TYPE, since now they will not both be set on the same type.\n+\n+\t* pt.c (do_pending_expansions): Don't clear TREE_PUBLIC on\n+\tinstantiations controlled by -fexternal-templates.\n+\n+\t* decl.c (duplicate_decls): Don't complain about different values of\n+\t__attribute__ ((const)) and ((noreturn)).\n+\n Fri Dec  9 18:17:37 1994  Doug Evans  <dje@cygnus.com>\n \n \t* Makefile.in (BISONFLAGS): Delete --yacc.\n@@ -9,6 +86,148 @@ Fri Dec  2 10:44:36 1994  Mike Stump  (mrs@wombat.gnu.ai.mit.edu)\n \t* Makefile.in (BISONFLAGS): Add --yacc so that output winds up in\n \ty.tab.c.\n \n+Thu Dec  8 17:39:46 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (finish_decl): Don't call obscure_complex_init for decls\n+\tof indeterminate size.\n+\n+Wed Dec  7 16:49:22 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (obscure_complex_init): Function to tweak the decl to\n+\tprevent expand_decl from tring to initialize it.\n+\t(finish_decl): Use it rather than writing the same code in three\n+\tdifferent places.\n+\n+\t* parse.y (bad_parm): Stop trying to support parms without types.\n+\n+Wed Dec  7 12:06:56 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl2.c (grokfield): Make asm specs on static member functions\n+\twork.\n+\n+Tue Dec  6 15:43:20 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_throw): Make a copy of the thrown object.\n+\n+Tue Dec  6 14:16:34 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* parse.y: : has lower precedence than =.\n+\n+Tue Dec  6 12:46:17 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (pushdecl): Use DECL_NAME of VAR_DECLs to avoid namespace\n+\tmanglings.\n+\t(grokvardecl): Add namespace into variable name.\n+\n+Tue Dec  6 11:26:55 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl2.c (current_namespace_id): New routine to transform a simple\n+\tname into a name in a namespace.\n+\t* decl.c (grokdeclarator): Use it.\n+\t* decl2.c (get_namespace_id): Find the name of the current\n+\tnamespace.\n+\t(push_namespace, pop_namespace): Complete out missing\n+\tfunctionality.\n+\n+Mon Dec  5 17:11:51 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* class.c (finish_struct): Don't use LONG_LONG_TYPE_SIZE, as it may\n+\tnot be defined.  Fix warning message for enums and restore warning\n+\tfor non-enums.\n+\n+\t* decl2.c (push_namespace): Dummy function.\n+\t(pop_namespace): Ditto.\n+\t(do_namespace_alias): Ditto.\n+\t(do_using_decl): Ditto.\n+\t(do_using_directive): Ditto.\n+\n+\t* parse.y: New token NSNAME for namespace names.\n+\t(extdef): Add namespace, using definitions.\n+\t(using_decl): New rule for using declarations.\n+\t(any_id): New rule for identifiers with any degree of scoping.\n+\t(identifier): Add NSNAME.\n+\t(notype_identifier): Ditto.\n+\t(component_decl): Add using_decl.\n+\t(nested_name_specifier): Add NSNAME SCOPE.\n+\n+\t* typeck.c (convert_for_assignment): Handle conversions between\n+\tenums and bool.\n+\n+\t* decl.c (duplicate_decls): Only propagate DECL_MAIN_VARIANT on\n+\tFUNCTION_DECLs.\n+\n+Mon Dec  5 13:03:16 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* class.c (finish_struct): Give an error if one tries to declare a\n+\tbit-field's size greater than a long long, as the backend will dump.\n+\tIt is not an error to declare an enum bit-field greater than its\n+\tprecision.  Warn if an enum bit-field is too small to hold all\n+\tits values.\n+\n+Mon Dec  5 11:41:50 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (convert_for_assignment): Use cp_convert instead of\n+\tconvert so that we don't get static casts.\n+\n+Sun Dec  4 11:59:01 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cvt.c (cp_convert): Don't complain about int->enum conversion if\n+\twe are doing static casts.\n+\n+Fri Dec  2 18:32:41 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* error.c (dump_expr): Do something more intelligent with SAVE_EXPRs\n+\twhen dumping expressions in error messages.\n+\n+Fri Dec  2 17:04:27 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* gc.c (build_dynamic_cast): Change interface to libg++, ensure that\n+        the return type is the right type, and make references work.\n+\n+Fri Dec  2 16:36:43 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (poplevel): Don't be confused by function-scope\n+\tdeclarations of non-nested functions.\n+\t(duplicate_decls): Propagate DECL_MAIN_VARIANT.\n+\t(pushdecl): Use duplicate_decls to copy info from old decl into new\n+\tfunction-scope one rather than doing it here.\n+\n+\t* decl2.c (mark_inline_for_output): Deal with the DECL_MAIN_VARIANT\n+\tof this decl, in case this is a function-scope declaration.\n+\n+\t* decl.c (finish_enum): Make sure that the type has the right\n+\tprecision when we call fixup_*_type.\n+\n+Tue Nov 29 19:12:07 1994  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* cvt.c (build_up_reference): Strip superfluous NOP_EXPRs; we do\n+\twant to build up references to rvalues if possible.\n+\t(cp_convert): Stick on a NOP_EXPR when converting to the same type.\n+\n+Tue Nov 29 11:28:59 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* parse.y (maybe_raises): Handle throw ().\n+\t* parse.y (ansi_raise_identifier): grok type-ids in exception\n+\tspecifications.\n+\t* tree.c (build_exception_variant): Use list compare to check if\n+\ttwo exception specifications match.\n+\t* decl.c (duplicate_decls, bad_specifiers): Enhance wording on error\n+\tmessages.\n+\t* call.c (build_method_call): Remove TREE_RAISES.\n+\t* cvt.c (convert_to_aggr): Ditto.\n+\t* typeck.c (build_function_call_real, convert_arguments): Ditto.\n+\t* init.c (expand_aggr_init_1): Ditto.\n+\n+Tue Nov 29 09:50:39 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c: Add support for m68k and mips exception handling\n+\tsupport.\n+\n+Tue Nov 29 08:48:33 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_end_all_catch): Throw into outer context, if we\n+\tfall off end of catch handlers.\n+\n Mon Nov 28 16:44:41 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* Makefile.in: Make is easier to decide where parse.[ch] will be\n@@ -527,7 +746,7 @@ Thu Sep 29 13:08:50 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* decl.c (finish_decl): Also end temporary allocation if the decl in\n \tquestion has a type of error_mark_node.\n \n-Wed Sep 28 21:45:00 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Sep 28 21:45:00 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* typeck.c (build_modify_expr): When optimizing ?: on lhs, make sure\n \tthat if the ?: was a reference type, that the subparts will be also.\n@@ -804,7 +1023,7 @@ Wed Aug 24 11:11:50 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* error.c (cp_line_of): Use CLASSTYPE_SOURCE_LINE for aggregates.\n \t* class.c (finish_struct): Set CLASSTYPE_SOURCE_LINE.\n \n-Tue Aug 23 09:28:35 1994  Mike Stump  (mrs@cygnus.com)\n+Tue Aug 23 09:28:35 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* error.c (dump_decl): Improve wording, so that error messages\n \tdont't read template<, class foo>...\n@@ -839,7 +1058,7 @@ Fri Aug 19 14:04:47 1994  Kung Hsu  (kung@mexican.cygnus.com)\n \t* method.c (build_overload_name): ditto.\n \t* method.c (build_overload_identifier): ditto.\n \n-Thu Aug 18 16:24:43 1994  Mike Stump  (mrs@cygnus.com)\n+Thu Aug 18 16:24:43 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* error.c (dump_decl): Handle NULL args.\n \n@@ -853,7 +1072,7 @@ Wed Sep 14 10:17:27 1994  Michael I Bushnell  <mib@churchy.gnu.ai.mit.edu>\n \t* g++.c: Include <sys/errno.h> in case `errno' is a macro\n \tas permitted by ANSI C.\n \n-Thu Aug 18 12:48:09 1994  Mike Stump  (mrs@cygnus.com)\n+Thu Aug 18 12:48:09 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* class.c (finish_struct): Move setting of CLASSTYPE_INTERFACE and\n \tCLASSTYPE_VTABLE_NEEDS_WRITING up to left_curly time.\n@@ -1061,7 +1280,7 @@ Fri Aug  5 14:20:16 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t(finish_function): Use DECL_DEFER_OUTPUT to decide which inlines to\n \tmark for later consideration, rather than DECL_FUNCTION_MEMBER_P.\n \n-Fri Aug  5 01:12:20 1994  Mike Stump  (mrs@cygnus.com)\n+Fri Aug  5 01:12:20 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* class.c (get_class_offset_1, get_class_offset): New routine to\n \tfind the offset of the class where a virtual function is defined,\n@@ -1207,7 +1426,7 @@ Mon Jul 11 18:37:20 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* decl.c (grok_reference_init): Always save the initializer of a\n \treference.\n \n-Fri Jul  8 17:41:46 1994  Mike Stump  (mrs@cygnus.com)\n+Fri Jul  8 17:41:46 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* decl.c (cplus_expand_expr_stmt): Wrap statement expressions inside\n \tCLEANUP_POINT_EXPRs so that the stack slots can be reused.\n@@ -1263,7 +1482,7 @@ Thu Jul  7 13:39:37 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t(finish_vtable_vardecl): Call import_export_template before\n \timport_export_vtable.\n \n-Wed Jul  6 20:25:48 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Jul  6 20:25:48 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* except.c (init_exception_processing): Setup interim_eh_hook to\n \tcall lang_interim_eh. \n@@ -1360,7 +1579,7 @@ Fri Jun 24 16:49:41 1994  Gerald Baumgartner  (gb@cs.purdue.edu)\n \t* decl.c (grokdeclarator): If we are grokking an opaque typedef\n \tin a signature, don't complain about it begin static.\n \n-Wed Jun 29 16:44:45 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Jun 29 16:44:45 1994  Mike Stump  <mrs@cygnus.com>\n \n \tFixes a problem of the this pointer being wrong in virtual calls to\n \tmethods that are not overridden in more derived classes.\n@@ -1493,7 +1712,7 @@ Wed Jun 15 19:34:54 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* typeck2.c (process_init_constructor): Don't treat empty_init_node\n \tspecially.\n \n-Wed Jun 15 19:05:25 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Jun 15 19:05:25 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* class.c (override_one_vtable): Don't forget to merge in an old\n \toverrider when we wanted to reuse a vtable, but couldn't.\n@@ -1576,7 +1795,7 @@ Thu Jun  9 19:04:59 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t(finish_file): Output all pending inlines if\n \tflag_keep_inline_functions.\n \n-Wed Jun  8 20:48:02 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Jun  8 20:48:02 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* tree.c (layout_vbasetypes): Align virtual base classes inside\n \tcomplete objects, so that we don't core dump on machines such as\n@@ -1662,7 +1881,7 @@ Wed Jun  1 18:57:35 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* typeck.c (convert_arguments): Make sure type is not NULL before\n \tchecking its TREE_CODE.\n \n-Wed Jun  1 17:40:39 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Jun  1 17:40:39 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* class.c (get_derived_offset): New routine.\n \t* class.c (finish_base_struct): Make sure we set BINFO_VTABLE and\n@@ -1684,7 +1903,7 @@ Wed Jun  1 11:11:15 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n \t* decl.c (grokdeclarator): Make sure we have a DNAME set before we\n \ttry to use it in an error.\n \n-Wed Jun  1 09:48:49 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Jun  1 09:48:49 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* typeck.c (convert_arguments, convert_for_initialization): Don't\n \tstrip NOP_EXPRs, when we are converting to a reference.\n@@ -1780,7 +1999,7 @@ Fri May 27 13:57:40 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* typeck.c (build_binary_op_nodefault): Division by constant zero is\n \tan error.\n \n-Fri May 27 13:50:15 1994  Mike Stump  (mrs@cygnus.com)\n+Fri May 27 13:50:15 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* class.c (override_one_vtable): Don't modify things we don't own.\n \n@@ -2049,7 +2268,7 @@ Fri May 13 16:45:07 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* class.c (finish_struct_bits): Set TYPE_HAS_INT_CONVERSION if it\n \thas a conversion to enum or bool, too.\n \n-Fri May 13 16:31:27 1994  Mike Stump  (mrs@cygnus.com)\n+Fri May 13 16:31:27 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* method.c (emit_thunk):  Make declaration for\n \tcurrent_call_is_indirect local (needed for hppa).\n@@ -2059,7 +2278,7 @@ Fri May 13 16:16:37 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* pt.c (uses_template_parms): Grok BOOLEAN_TYPE.\n \t(tsubst): Ditto.\n \n-Fri May 13 16:23:32 1994  Mike Stump  (mrs@cygnus.com)\n+Fri May 13 16:23:32 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* pt.c (tsubst): If there is already a function for this expansion,\n \tuse it.\n@@ -2074,7 +2293,7 @@ Fri May 13 10:30:42 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n \t* cp-tree.h (build_static_cast, build_reinterpret_cast,\n \tbuild_const_cast): Add declarations.\n \n-Fri May 13 09:50:31 1994  Mike Stump  (mrs@cygnus.com)\n+Fri May 13 09:50:31 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* search.c (expand_indirect_vtbls_init): Fix breakage from Apr 27\n \tfix.  We now try get_binfo, and if that doesn't find what we want,\n@@ -2095,7 +2314,7 @@ Fri May 13 01:43:18 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t(build_default_unary_type_conversion): Convert arg of ! to bool.\n \t(type_promotes_to): bool promotes to int.\n \n-Fri May 13 01:43:18 1994  Mike Stump  (mrs@cygnus.com)\n+Fri May 13 01:43:18 1994  Mike Stump  <mrs@cygnus.com>\n \n \tImplement the new builtin `bool' type.\n \t* typeck.c (build_binary_op_nodefault): Convert args of && and || to\n@@ -2117,7 +2336,7 @@ Thu May 12 19:13:54 1994  Richard Earnshaw  (rwe11@cl.cam.ac.uk)\n \n \t* g++.c: Use #ifdef for __MSDOS__, not #if.\n \n-Thu May 12 18:05:18 1994  Mike Stump  (mrs@cygnus.com)\n+Thu May 12 18:05:18 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* decl2.c (lang_f_options): Handle -fshort-temps.  -fshort-temps\n \tgives old behavior , and destroys temporaries earlier.  Default\n@@ -2188,7 +2407,7 @@ Tue May 10 11:52:04 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n \t* init.c (emit_base_init): Check if there's a DECL_NAME on the\n \tmember before trying to do an initialization for it.\n \n-Tue May 10 11:34:37 1994  Mike Stump  (mrs@cygnus.com)\n+Tue May 10 11:34:37 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* except.c: Don't do anything useful when cross compiling.\n \n@@ -2225,7 +2444,7 @@ Sun May  8 01:29:13 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* decl.c (poplevel): Always call poplevel recursively if we're\n \tdealing with a temporary binding level.\n \n-Sat May  7 10:52:28 1994  Mike Stump  (mrs@cygnus.com)\n+Sat May  7 10:52:28 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* decl.c (finish_decl): Make sure we run cleanups for initial values\n \tof decls.  Cures memory leak.\n@@ -2297,7 +2516,7 @@ Fri May  6 03:53:23 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* cp/decl.c (finish_decl): Setting asmspec_tree should not\n \tzero out the old RTL.\n \n-Fri May  6 01:25:38 1994  Mike Stump  (mrs@cygnus.com)\n+Fri May  6 01:25:38 1994  Mike Stump  <mrs@cygnus.com>\n \n \tAdd alpha exception handling support to the compiler.\n \tQuick and dirty backend in except.c.\n@@ -2556,7 +2775,7 @@ Thu Apr 28 02:12:08 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* typeck2.c (build_functional_cast): Don't look for a function call\n \tinterpretation.\n \n-Thu Apr 28 15:19:46 1994  Mike Stump  (mrs@cygnus.com)\n+Thu Apr 28 15:19:46 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* cp-tree.h: disable use of backend EH.\n \n@@ -2585,7 +2804,7 @@ Wed Apr 27 18:10:12 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* call.c (build_overload_call_real): Don't take the single-function\n \tshortcut if we're dealing with an overloaded operator.\n \n-Wed Apr 27 17:35:37 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Apr 27 17:35:37 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* search.c (get_base_distance): Search the virtual base class\n \tbinfos, incase someone wants to convert to a real virtual base\n@@ -2600,7 +2819,7 @@ Wed Apr 27 15:36:49 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* typeck.c (build_unary_op): References are too lvalues.\n \n-Wed Apr 27 13:58:05 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Apr 27 13:58:05 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* class.c (override_one_vtable): We have to prepare_fresh_vtable\n \tbefore we modify it, not after, also, we cannot reuse an old vtable,\n@@ -2642,7 +2861,7 @@ Wed Apr 27 01:17:08 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* decl.c (grokdeclarator): Don't bash references to arrays into\n \treferences to pointers in function parms.  Use type_promotes_to.\n \n-Tue Apr 26 23:44:36 1994  Mike Stump  (mrs@cygnus.com)\n+Tue Apr 26 23:44:36 1994  Mike Stump  <mrs@cygnus.com>\n \n \tFinish off Apr 19th work.\n \n@@ -2885,7 +3104,7 @@ Wed Apr 20 16:51:06 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* lex.c (process_next_inline): Don't muck with DECL_INLINE.\n \t(do_pending_inlines): Ditto.\n \n-Tue Apr 19 22:25:41 1994  Mike Stump  (mrs@cygnus.com)\n+Tue Apr 19 22:25:41 1994  Mike Stump  <mrs@cygnus.com>\n \n \tReimplement vtable building, and most vtable pointer setting.\n \tAllows for earier maintenance, easier understandability, and most\n@@ -3305,7 +3524,7 @@ Thu Apr  7 17:47:53 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* decl.c (lookup_name): When called from the lexer, look at\n \tgot_scope and looking_at_typename; otherwise don't.\n \n-Thu Apr  7 22:05:47 1994  Mike Stump  (mrs@cygnus.com)\n+Thu Apr  7 22:05:47 1994  Mike Stump  <mrs@cygnus.com>\n \n \t31th Cygnus<->FSF merge.\n \n@@ -3322,7 +3541,7 @@ Thu Apr  7 17:47:53 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* typeck.c (compparms): Also allow t1 to be ... if strict == 0.\n \n-Thu Apr  7 16:17:50 1994  Mike Stump  (mrs@cygnus.com)\n+Thu Apr  7 16:17:50 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* class.c (build_vtable_entry): Fix breakage introduced Apr 5\n \t17:48:41.\n@@ -3403,7 +3622,7 @@ Tue Apr  5 17:48:41 1994  Per Bothner  (bothner@kalessin.cygnus.com)\n \tinstead.  (The rationale is that these optimizations both break binary\n \tcompatibility, but should become the default in a future release.)\n \n-Wed Apr  6 10:53:56 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Apr  6 10:53:56 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* class.c (modify_vtable_entries): Never reset the DECL_CONTEXT\n \tof a fndecl, as we might not be from that vfield.\n@@ -3468,7 +3687,7 @@ Sat Jan 23 23:23:26 1994  Stephen R. van den Berg  (berg@pool.informatik.rwth-aa\n \t* decl.c (init_decl_processing): Declare __builtin_return_address\n \tand __builtin_frame_address for C++ as well.\n \n-Thu Mar 31 12:35:49 1994  Mike Stump  (mrs@cygnus.com)\n+Thu Mar 31 12:35:49 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* typeck2.c (store_init_value): Integral constant variables are\n \talways constant, even when doing -fpic.\n@@ -3478,7 +3697,7 @@ Sat Jan 23 23:23:26 1994  Stephen R. van den Berg  (berg@pool.informatik.rwth-aa\n \t* decl.c (redeclaration_error_message): Pass the types to\n \tcomptypes.\n \n-Wed Mar 30 21:29:25 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Mar 30 21:29:25 1994  Mike Stump  <mrs@cygnus.com>\n \n \tCures incorrect errors about pure virtuals in a class, when they\n \thave been overridden in a derived class.\n@@ -3514,7 +3733,7 @@ Wed Mar 30 14:10:04 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t(pushdecl): Use DECL_FUNCTION_MEMBER_P to decide whether or not\n \ta function is a member.\n \n-Wed Mar 30 14:20:50 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Mar 30 14:20:50 1994  Mike Stump  <mrs@cygnus.com>\n \n \tCures calling a more base base class function, when a more derived\n \tbase class member should be called in some MI situations.\n@@ -3642,7 +3861,7 @@ Thu Mar 24 23:18:19 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* call.c (build_method_call): Preserve const & volatile on\n \t`this'.\n \n-Thu Mar 24 16:21:52 1994  Mike Stump  (mrs@cygnus.com)\n+Thu Mar 24 16:21:52 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* init.c (build_new, build_vec_delete): Use global new and delete\n \tfor arrays. \n@@ -3661,11 +3880,11 @@ Wed Mar 23 17:45:37 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* init.c (build_new): Handle array typedefs properly.\n \n-Wed Mar 23 18:23:33 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Mar 23 18:23:33 1994  Mike Stump  <mrs@cygnus.com>\n \n \t30th Cygnus<->FSF merge.\n \n-Wed Mar 23 00:46:24 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Mar 23 00:46:24 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* class.c (modify_vtable_entries): Avoid running off the end of the\n \tvirtuals list when processing a virtual destructor.\n@@ -3681,7 +3900,7 @@ Tue Mar 22 23:49:41 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* typeck.c (convert_for_assignment): Don't pedwarn about\n \tconverting function pointer to void *.\n \n-Tue Mar 22 22:23:19 1994  Mike Stump  (mrs@cygnus.com)\n+Tue Mar 22 22:23:19 1994  Mike Stump  <mrs@cygnus.com>\n \n \tMajor revamp of pointer to member functions.  Cures major\n \tnonfunctionality when used in casts, and MI situations.\n@@ -3702,7 +3921,7 @@ Tue Mar 22 22:23:19 1994  Mike Stump  (mrs@cygnus.com)\n \t* typeck.c (build_ptrmemfunc): Revamp to handle casting better, also\n \tget vtable pointer out of right subobject.\n \n-Tue Mar 22 17:56:48 1994  Mike Stump  (mrs@cygnus.com)\n+Tue Mar 22 17:56:48 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* search.c (get_binfo): Return NULL instead of aborting, when\n \tpassed a UNION_TYPE.\n@@ -3839,7 +4058,7 @@ Thu Mar 17 17:30:01 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t(finish_decl_parsing): New function to deal with parse nodes for\n \tcode like `int (*a);'.  See the difference?\n \n-Thu Mar 17 12:16:10 1994  Mike Stump  (mrs@cygnus.com)\n+Thu Mar 17 12:16:10 1994  Mike Stump  <mrs@cygnus.com>\n \n \tThese changes break binary compatibility in code with classes\n \tthat use virtual bases.\n@@ -3866,7 +4085,7 @@ Wed Mar 16 17:43:07 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* parse.y (direct_notype_declarator): Add PTYPENAME rule, remove\n \tall of the scoped PTYPENAME rules.\n \n-Wed Mar 16 16:39:02 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Mar 16 16:39:02 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* init.c (build_offset_ref): The value of A::typedef_name is\n \talways the TYPE_DECL, and never an error.\n@@ -3890,7 +4109,7 @@ Tue Mar 15 15:33:31 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* error.c (dump_expr): Support member functions (which show up as\n \tOFFSET_REFs).\n \n-Mon Mar 14 16:24:36 1994  Mike Stump  (mrs@cygnus.com)\n+Mon Mar 14 16:24:36 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* init.c (build_new): Set the return type of multidimensional\n \tnews correctly.\n@@ -3950,7 +4169,7 @@ Fri Mar  4 18:22:39 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t(direct_abstract_declarator): Replace `LEFT_RIGHT type_quals' rule\n \twith `fcast_or_absdcl type_quals' rule.\n \n-Fri Mar  4 16:18:03 1994  Mike Stump  (mrs@cygnus.com)\n+Fri Mar  4 16:18:03 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* tree.c (lvalue_p): Improve OFFSET_REF handling, so that it\n \tmatches Section 5.5.\n@@ -3960,7 +4179,7 @@ Fri Mar  4 14:01:59 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* error.c (dump_type_prefix): Don't print basetype twice for\n \tpmfs.\n \n-Fri Mar  4 13:24:33 1994  Mike Stump  (mrs@cygnus.com)\n+Fri Mar  4 13:24:33 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* typeck.c (convert_arguments): Handle setHandler(A::handlerFn)\n \tso that it is like setHandler(&A::handlerFn).  Cures an `invalid\n@@ -3990,7 +4209,7 @@ Fri Mar  4 11:15:59 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \ta decl.  Also move the IS_AGGR_TYPE check after the stripping of\n \tREFERENCE_TYPE.\n \n-Fri Mar  4 04:46:05 1994  Mike Stump  (mrs@cygnus.com)\n+Fri Mar  4 04:46:05 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* call.c (build_method_call): Handle b->setHandler(A::handlerFn)\n \tso that it is like b->setHandler(&A::handlerFn).  Cures an `invalid\n@@ -4092,7 +4311,7 @@ Fri Feb 25 15:23:42 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* decl.c (start_function): Fix detection of function overloading.\n \n-Thu Feb 24 22:26:19 1994  Mike Stump  (mrs@cygnus.com)\n+Thu Feb 24 22:26:19 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* lex.c (check_newline): #pragma interface can take a string\n \targument, just like #pragma implementation.  #pragma implementation\n@@ -4152,7 +4371,7 @@ Tue Feb 22 12:10:32 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* tree.c (lvalue_p): A COND_EXPR is an lvalue if both of the\n \toptions are.\n \n-Mon Feb 21 19:59:40 1994  Mike Stump  (mrs@cygnus.com)\n+Mon Feb 21 19:59:40 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* Makefile.in (mostlyclean): lex.c is a source file, don't\n \tremove.\n@@ -4313,29 +4532,29 @@ hu Jan 13 17:55:51 EST 1994 Gnanasekaran Swaminathan (gs4t@virginia.edu)\n \tstore_init_value fails, build and expand an INIT_EXPR.  If\n \tstore_init_value succeeds, call expand_decl_init.\n \n-Fri Feb 11 02:49:23 1994  Mike Stump  (mrs@cygnus.com)\n+Fri Feb 11 02:49:23 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* class.c (build_vbase_path): Use complete_type_p instead of\n \tresolves_to_fixed_type_p to determine if the virtual bases are in\n \ttheir right place for the type of expr.  Cures problem of thinking a\n \tvirtual base class is one place, when it is in fact someplace else.\n \n-Fri Feb 11 00:26:46 1994  Mike Stump  (mrs@cygnus.com)\n+Fri Feb 11 00:26:46 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* init.c (resolve_offset_ref): Make sure we first convert to\n \tintermediate type, if given, when dealing with members off `this'.\n \tSolves an incorrrect `type `foo' is not a base type for type\n \t`multiple'' when it is infact, a base type.\n \n-Thu Feb 10 21:49:35 1994  Mike Stump  (mrs@cygnus.com)\n+Thu Feb 10 21:49:35 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* class.c (modify_other_vtable_entries): Use get_binfo, instead\n \tof binfo_value.  Solves problem with compiler giving a `base class\n \t`B' ambiguous in binfo_value (compiler error)' on complex MI\n \therarchies, when a virtual function is first defied in a virtual\n \tbase class.\n \n-Thu Feb 10 17:19:32 1994  Mike Stump  (mrs@cygnus.com)\n+Thu Feb 10 17:19:32 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* class.c (build_vbase_path): Don't complain about ambiguous\n \tintermediate conversion when converting down to a virtual base\n@@ -4351,7 +4570,7 @@ Thu Feb 10 12:18:26 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* decl.c (grokdeclarator): Fix detection of virtual new/delete.\n \n-Wed Feb  9 22:02:32 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Feb  9 22:02:32 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* search.c (build_mi_virtuals, add_mi_virtuals,\n \treport_ambiguous_mi_virtuals): Removed unneeded code.\n@@ -4535,7 +4754,7 @@ Fri Feb  4 14:21:00 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* decl.c (grokdeclarator): If friendp && virtualp, friendp = 0.\n \n-Fri Feb  4 13:02:56 1994  Mike Stump  (mrs@cygnus.com)\n+Fri Feb  4 13:02:56 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* lex.c (reinit_parse_for_method, cons_up_default_function):\n \tDon't give warn_if_unknown_interface warning when it came from a\n@@ -4689,7 +4908,7 @@ Mon Jan 31 12:07:30 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t(build_x_unary_op): Ditto.\n \t(build_x_conditional_expr): Ditto.\n \n-Mon Jan 31 10:00:30 1994  Mike Stump  (mrs@cygnus.com)\n+Mon Jan 31 10:00:30 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* cvt.c (build_type_conversion_1): Change call to pedwarn into\n \twarning, and conditionalize upon warn_cast_qual.\n@@ -4723,7 +4942,7 @@ Thu Jan 27 19:26:51 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* decl.c (grokparms): Abort if we get called with something we don't\n \texpect.\n \n-Thu Jan 27 17:37:25 1994  Mike Stump  (mrs@cygnus.com)\n+Thu Jan 27 17:37:25 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* call.c (build_overload_call_real): Change argument complain to\n \tflags to match style of rest of code.  Pass it down to\n@@ -4784,20 +5003,20 @@ Wed Jan 26 18:28:14 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t(add_friend): Never stick in ctype.\n \tWhy are the friendship functions in init.c, anyway?\n \n-Wed Jan 26 17:50:00 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Jan 26 17:50:00 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* cvt.c (build_type_conversion_1): Don't conditionalize call to\n \tpedwarn upon pedantic.\n \n-Wed Jan 26 17:20:46 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Jan 26 17:20:46 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* cvt.c (convert_to_reference): Add 8.4.3 checking so that one\n \tgets a warning if one tries to initialize a non-const & from a\n \tnon-lvalue.\n \t* cvt.c (convert_to_reference): Use %P format for argument\n \tnumbers in warnings.\n \n-Wed Jan 26 14:35:06 1994  Mike Stump  (mrs@cygnus.com)\n+Wed Jan 26 14:35:06 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* init.c (build_delete): Follow style in call.c to construct the\n \tvirtual call to the desctructor, as that code is right.  Fixes a\n@@ -4814,7 +5033,7 @@ Tue Jan 25 18:39:12 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* typeck.c (build_modify_expr): Don't smash references if INIT_EXPR.\n \n-Tue Jan 25 13:54:29 1994  Mike Stump  (mrs@cygnus.com)\n+Tue Jan 25 13:54:29 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* init.c (build_delete): Back out Jan 17th & 18th pacthes, as\n \tthey break libg++.\n@@ -4933,7 +5152,7 @@ Mon Jan 17 13:58:18 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n \t* Makefile.in (TAGS): Don't try to run etags on cp-parse.y.\n \n-Sat Jan 15 18:34:33 1994  Mike Stump  (mrs@cygnus.com)\n+Sat Jan 15 18:34:33 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* Makefile.in, configure: Handle the C++ front-end in a\n \tsubdirectory.\n@@ -4974,7 +5193,7 @@ Fri Jan 14 18:25:29 1994  Kung Hsu  (kung@mexican.cygnus.com)\n \t* cp-spew.c (yylex) : generated SCOPED_NAME token.\n \t* cp-lex.c (yyprint): handle SCOPED_NAME.\n \n-Fri Jan 14 17:00:29 1994  Mike Stump  (mrs@cygnus.com)\n+Fri Jan 14 17:00:29 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* cp-decl.c (pushdecl): Revert patch from Jan 11 19:33:03, as it is\n \tnot right.\n@@ -4984,7 +5203,7 @@ Thu Jan 13 14:00:35 1994  Kung Hsu  (kung@mexican.cygnus.com)\n \t* cp-decl2.c (grok_x_components): fix a bug that enum type does not\n \thave type_flags.\n \n-Thu Jan 13 11:39:34 1994  Mike Stump  (mrs@cygnus.com)\n+Thu Jan 13 11:39:34 1994  Mike Stump  <mrs@cygnus.com>\n \n \tEnsure that all vtable pointers are initialized with all the right\n \tvalues.\n@@ -5034,7 +5253,7 @@ Tue Jan 11 19:33:03 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \t* cp-class.c (finish_struct): When generating default op=,\n \tset TYPE_HAS_ASSIGNMENT.\n \n-Mon Jan 10 18:48:06 1994  Mike Stump  (mrs@cygnus.com)\n+Mon Jan 10 18:48:06 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* cp-cvt.c (convert): Make {double, clashing enum} -> enum\n \tinvalid.\n@@ -5093,18 +5312,18 @@ Mon Jan  3 22:22:32 1994  Gerald Baumgartner  (gb@cygnus.com)\n \t* invoke.texi: Added `-fhandle-signatures' in the list of\n \tC++ language options.  Added explanation for this option.\n \n-Tue Dec 28 21:10:03 1993  Mike Stump  (mrs@cygnus.com)\n+Tue Dec 28 21:10:03 1993  Mike Stump  <mrs@cygnus.com>\n \n \t* cp-init.c (expand_vec_init): Remove comptypes test, as it is too\n \tharsh here.\n \n-Tue Dec 28 13:42:22 1993  Mike Stump  (mrs@cygnus.com)\n+Tue Dec 28 13:42:22 1993  Mike Stump  <mrs@cygnus.com>\n \n \t* cp-pt.c (do_pending_expansions): Decide to expand a template\n \tmember function, based upon it's class type, not the class type of\n \tthe first place it was declared.\n \n-Tue Dec 28 05:42:31 1993  Mike Stump  (mrs@cygnus.com)\n+Tue Dec 28 05:42:31 1993  Mike Stump  <mrs@cygnus.com>\n \n \t* cp-class.c (is_normal): New routine, use to determine when the\n \tgiven binfo is the normal one.  (The one that should have the simple\n@@ -5238,7 +5457,7 @@ Thu Dec 16 12:17:06 1993  Brendan Kehoe  (brendan@lisa.cygnus.com)\n \t* cp-method.c (hack_identifier): Also check for a TYPE_PTRMEMFUNC_P\n \tto see if something is a method.\n \n-Wed Dec 15 18:35:58 1993  Mike Stump  (mrs@cygnus.com)\n+Wed Dec 15 18:35:58 1993  Mike Stump  <mrs@cygnus.com>\n \n \t* cp-typeck.c (build_modify_expr): Avoid error messages on small\n \tenum bit fields.\n@@ -5287,7 +5506,7 @@ Fri Dec 10 12:40:25 1993  Brendan Kehoe  (brendan@lisa.cygnus.com)\n \tonly go for setting TRIVIAL_CODE if we are dealing with types that\n \tare compatible.\n \n-Thu Dec  9 18:27:22 1993  Mike Stump  (mrs@cygnus.com)\n+Thu Dec  9 18:27:22 1993  Mike Stump  <mrs@cygnus.com>\n \n \t* cp-decl.c (flag_huge_objects): New flag to allow large objects.\n \t* toplev.c (lang_options): Ditto.\n@@ -5305,7 +5524,7 @@ Thu Dec  9 16:19:05 1993  Brendan Kehoe  (brendan@lisa.cygnus.com)\n \tNO_{DOLLAR,DOT} macro checks, so it always gets defined.\n \t(VTABLE_NAME_P): Define for NO_DOT && NO_DOLLAR_IN_LABEL.\n \n-Wed Dec  8 17:38:06 1993  Mike Stump  (mrs@cygnus.com)\n+Wed Dec  8 17:38:06 1993  Mike Stump  <mrs@cygnus.com>\n \n \t* cp-decl.c (finish_decl): Make sure things that can go into\n \t\"common\", do go into common, if -fcommon is given.\n@@ -5593,7 +5812,7 @@ Wed Nov 24 00:49:35 1993  Jason Merrill  (jason@deneb.cygnus.com)\n \tPropagate TYPE_GETS_ASSIGN_REF.  Use cant_synth_copy_ctor.  Add call\n \tto cons_up_default_function for operator=.\n \n-Tue Nov 23 20:24:58 1993  Mike Stump  (mrs@cygnus.com)\n+Tue Nov 23 20:24:58 1993  Mike Stump  <mrs@cygnus.com>\n \n \t* cp-cvt.c (convert_force): Add code to perform casting of pointer\n \tto member function types.\n@@ -5612,7 +5831,7 @@ Tue Nov 23 18:06:58 1993  Jason Merrill  (jason@deneb.cygnus.com)\n \tand its kin properly.\n \t(xref_tag): Propagate TYPE_GETS_ASSIGN_REF.\n \n-Tue Nov 23 12:26:13 1993  Mike Stump  (mrs@cygnus.com)\n+Tue Nov 23 12:26:13 1993  Mike Stump  <mrs@cygnus.com>\n \n \t* cp-method.c (build_opfncall): Don't count pointer to member\n \tfunctions as aggregates here, as we don't want to look up methods in"}, {"sha": "8442d23f1d345b0e12df00ed03dee87a76a3f4ed", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -75,7 +75,7 @@ CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/decl2.c \\\n  $(srcdir)/cp/error.c $(srcdir)/cp/init.c $(srcdir)/cp/parse.y \\\n  $(srcdir)/cp/sig.c $(srcdir)/cp/typeck2.c\n \n-cc1plus: $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o\n+cc1plus: $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o c-pragma.o\n \tcd cp; $(MAKE) $(FLAGS_TO_PASS) $(CXX_FLAGS_TO_PASS) ../cc1plus\n \f\n # Build hooks:"}, {"sha": "ab3f58b9e12bfffe46cf52d66033cbeedca94c9c", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -162,8 +162,8 @@ CXX_OBJS = call.o decl.o errfn.o expr.o pt.o sig.o typeck2.o \\\n  edsel.o except.o init.o method.o search.o tree.o xref.o\n \n # Language-independent object files.\n-OBJS = `cat ../stamp-objlist` ../c-common.o\n-OBJDEPS = ../stamp-objlist ../c-common.o\n+OBJS = `cat ../stamp-objlist` ../c-common.o ../c-pragma.o\n+OBJDEPS = ../stamp-objlist ../c-common.o ../c-pragma.o\n \n compiler: ../cc1plus\n ../cc1plus: $(P) $(CXX_OBJS) $(OBJDEPS) $(LIBDEPS)"}, {"sha": "85a2788f19214a379cd16dab4d5349b958f5c84c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -1802,7 +1802,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t we can manage.  */\n \t      tree temp = get_temp_name (TREE_TYPE (instance), 0);\n \t      if (IS_AGGR_TYPE (TREE_TYPE (instance)))\n-\t\texpand_aggr_init (temp, instance, 0);\n+\t\texpand_aggr_init (temp, instance, 0, flags);\n \t      else\n \t\t{\n \t\t  store_init_value (temp, instance);\n@@ -2144,7 +2144,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t{\n \t\t  tree type = build_pointer_type\n \t\t    (build_type_variant (basetype, constp, volatilep));\n-\t\t  TREE_VALUE (parms) = convert_force (type, instance_ptr);\n+\t\t  TREE_VALUE (parms) = convert_force (type, instance_ptr, 0);\n \t\t}\n \t    }\n \n@@ -2652,8 +2652,6 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \n     TREE_TYPE (result) = value_type;\n     TREE_SIDE_EFFECTS (result) = 1;\n-    TREE_RAISES (result)\n-      = TYPE_RAISES_EXCEPTIONS (fntype) || (parms && TREE_RAISES (parms));\n     TREE_HAS_CONSTRUCTOR (result) = is_constructor;\n     return result;\n   }"}, {"sha": "9731ac1cb84ec8a817b7f414442a440c1e271810", "filename": "gcc/cp/class.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -2116,7 +2116,7 @@ finish_vtbls (binfo, do_self, t)\n \t      && DECL_INITIAL (decl) != BINFO_VIRTUALS (binfo))\n \t    DECL_INITIAL (decl) = build_nt (CONSTRUCTOR, NULL_TREE,\n \t\t\t\t\t    BINFO_VIRTUALS (binfo));\n-\t  finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0);\n+\t  finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0, 0);\n \t  DECL_CONTEXT (decl) = context;\n \t}\n       CLEAR_BINFO_NEW_VTABLE_MARKED (binfo);\n@@ -3161,10 +3161,26 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t\t      DECL_INITIAL (x) = NULL;\n \t\t      cp_error_at (\"zero width for bit-field `%D'\", x);\n \t\t    }\n-\t\t  else if ((unsigned)width > TYPE_PRECISION (TREE_TYPE (x)))\n+\t\t  else if (width\n+\t\t\t   > TYPE_PRECISION (long_long_unsigned_type_node))\n \t\t    {\n+\t\t      /* The backend will dump if you try to use something\n+\t\t\t too big; avoid that.  */\n \t\t      DECL_INITIAL (x) = NULL;\n-\t\t      cp_error_at (\"width of `%D' exceeds its type\", x);\n+\t\t      sorry (\"bit-fields larger than %d bits\",\n+\t\t\t     TYPE_PRECISION (long_long_unsigned_type_node));\n+\t\t      cp_error_at (\"  in declaration of `%D'\", x);\n+\t\t    }\n+\t\t  else if (width > TYPE_PRECISION (TREE_TYPE (x))\n+\t\t\t   && TREE_CODE (TREE_TYPE (x)) != ENUMERAL_TYPE)\n+\t\t    {\n+\t\t      cp_warning_at (\"width of `%D' exceeds its type\", x);\n+\t\t    }\n+\t\t  else if (width < TYPE_PRECISION (TREE_TYPE (x))\n+\t\t\t   && TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE)\n+\t\t    {\n+\t\t      cp_warning_at (\"`%D' is too small to hold all values of `%#T'\",\n+\t\t\t\t     x, TREE_TYPE (x));\n \t\t    }\n \t\t}\n "}, {"sha": "8b50002eb1c4cea93942e835856ffdb95b0bf8c9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -1787,6 +1787,7 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n      as well as the space of member functions.\n    LOOKUP_HAS_IN_CHARGE means that the \"in charge\" variable is already\n      in the parameter list.\n+   LOOKUP_ONLYCONVERTING means that non-conversion constructors are not tried.\n    LOOKUP_NO_CONVERSION means that user-defined conversions are not\n      permitted.  Built-in conversions are permitted.\n    LOOKUP_DESTRUCTOR means explicit call to destructor.  */\n@@ -1809,13 +1810,15 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n    CONV_STATIC     :  Perform the explicit conversions for static_cast.\n    CONV_CONST      :  Perform the explicit conversions for const_cast.\n    CONV_REINTERPRET:  Perform the explicit conversions for reinterpret_cast.\n-   CONV_PRIVATE    :  Perform upcasts to private bases.  */\n+   CONV_PRIVATE    :  Perform upcasts to private bases.\n+   CONV_NONCONVERTING : Allow non-converting constructors to be used.  */\n \n #define CONV_IMPLICIT    1\n #define CONV_STATIC      2\n #define CONV_CONST       4\n #define CONV_REINTERPRET 8\n #define CONV_PRIVATE\t 16\n+#define CONV_NONCONVERTING 32\n #define CONV_STATIC_CAST (CONV_IMPLICIT | CONV_STATIC)\n #define CONV_OLD_CONVERT (CONV_IMPLICIT | CONV_STATIC | CONV_CONST \\\n \t\t\t  | CONV_REINTERPRET)\n@@ -1896,7 +1899,8 @@ extern tree convert_pointer_to\t\t\tPROTO((tree, tree));\n extern tree convert_pointer_to_real\t\tPROTO((tree, tree));\n extern tree convert_pointer_to_vbase\t\tPROTO((tree, tree));\n extern tree convert\t\t\t\tPROTO((tree, tree));\n-extern tree convert_force\t\t\tPROTO((tree, tree));\n+extern tree cp_convert\t\t\t\tPROTO((tree, tree, int, int));\n+extern tree convert_force\t\t\tPROTO((tree, tree, int));\n extern tree build_type_conversion\t\tPROTO((enum tree_code, tree, tree, int));\n extern int build_default_binary_type_conversion\tPROTO((enum tree_code, tree *, tree *));\n extern int build_default_unary_type_conversion\tPROTO((enum tree_code, tree *));\n@@ -1956,7 +1960,7 @@ extern void shadow_tag\t\t\t\tPROTO((tree));\n extern int grok_ctor_properties\t\t\tPROTO((tree, tree));\n extern tree groktypename\t\t\tPROTO((tree));\n extern tree start_decl\t\t\t\tPROTO((tree, tree, int, tree));\n-extern void finish_decl\t\t\t\tPROTO((tree, tree, tree, int));\n+extern void finish_decl\t\t\t\tPROTO((tree, tree, tree, int, int));\n extern void expand_static_init\t\t\tPROTO((tree, tree));\n extern int complete_array_type\t\t\tPROTO((tree, tree, int));\n extern tree build_ptrmemfunc_type\t\tPROTO((tree));\n@@ -2018,6 +2022,9 @@ extern tree reparse_decl_as_expr\t\tPROTO((tree, tree));\n extern tree finish_decl_parsing\t\t\tPROTO((tree));\n extern tree lookup_name_nonclass\t\tPROTO((tree));\n extern tree check_cp_case_value\t\t\tPROTO((tree));\n+extern tree do_using_decl\t\t\tPROTO((tree));\n+extern tree current_namespace_id\t\tPROTO((tree));\n+extern tree get_namespace_id\t\t\tPROTO((void));\n \n /* in edsel.c */\n \n@@ -2066,7 +2073,7 @@ extern void check_base_init\t\t\tPROTO((tree));\n extern void expand_direct_vtbls_init\t\tPROTO((tree, tree, int, int, tree));\n extern void do_member_init\t\t\tPROTO((tree, tree, tree));\n extern void expand_member_init\t\t\tPROTO((tree, tree, tree));\n-extern void expand_aggr_init\t\t\tPROTO((tree, tree, int));\n+extern void expand_aggr_init\t\t\tPROTO((tree, tree, int, int));\n extern int is_aggr_typedef\t\t\tPROTO((tree, int));\n extern tree get_aggr_from_typedef\t\tPROTO((tree, int));\n extern tree get_type_value\t\t\tPROTO((tree));\n@@ -2347,7 +2354,7 @@ extern tree build_compound_expr\t\t\tPROTO((tree));\n extern tree build_static_cast\t\t\tPROTO((tree, tree));\n extern tree build_reinterpret_cast\t\tPROTO((tree, tree));\n extern tree build_const_cast\t\t\tPROTO((tree, tree));\n-extern tree build_c_cast\t\t\tPROTO((tree, tree));\n+extern tree build_c_cast\t\t\tPROTO((tree, tree, int));\n extern tree build_modify_expr\t\t\tPROTO((tree, enum tree_code, tree));\n extern int language_lvalue_valid\t\tPROTO((tree));\n extern void warn_for_assignment\t\t\tPROTO((char *, char *, char *, tree, int, int));"}, {"sha": "b472c83538be198f439357aedac36183b36adec3", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -309,6 +309,10 @@ build_up_reference (type, arg, flags, checkconst)\n   targ = arg;\n   if (TREE_CODE (targ) == SAVE_EXPR)\n     targ = TREE_OPERAND (targ, 0);\n+  while (TREE_CODE (targ) == NOP_EXPR\n+\t && (TYPE_MAIN_VARIANT (argtype)\n+\t     == TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (targ, 0)))))\n+    targ = TREE_OPERAND (targ, 0);\n \n   switch (TREE_CODE (targ))\n     {\n@@ -552,13 +556,16 @@ build_up_reference (type, arg, flags, checkconst)\n \t}\n       else\n \t{\n+\t  /* We should never get here for class objects, because they are\n+             always in memory.  */\n+\t  my_friendly_assert (! IS_AGGR_TYPE (argtype), 362);\n \t  temp = get_temp_name (argtype, 0);\n \t  if (global_bindings_p ())\n \t    {\n \t      /* Give this new temp some rtl and initialize it.  */\n \t      DECL_INITIAL (temp) = targ;\n \t      TREE_STATIC (temp) = 1;\n-\t      finish_decl (temp, targ, NULL_TREE, 0);\n+\t      finish_decl (temp, targ, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n \t      /* Do this after declaring it static.  */\n \t      rval = build_unary_op (ADDR_EXPR, temp, 0);\n \t      TREE_TYPE (rval) = type;\n@@ -605,8 +612,6 @@ build_up_reference (type, arg, flags, checkconst)\n    initialized.  It can be error_mark_node if we don't know the _DECL but\n    we know it's an initialization.  */\n \n-tree cp_convert PROTO((tree, tree, int, int));\n-\n tree\n convert_to_reference (reftype, expr, convtype, flags, decl)\n      tree reftype, expr;\n@@ -703,7 +708,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t  \n       rval = build_unary_op (ADDR_EXPR, expr, 0);\n       if (rval != error_mark_node)\n-\trval = convert_force (build_pointer_type (TREE_TYPE (reftype)), rval);\n+\trval = convert_force (build_pointer_type (TREE_TYPE (reftype)), rval, 0);\n       if (rval != error_mark_node)\n \trval = build1 (NOP_EXPR, reftype, rval);\n     }\n@@ -1061,7 +1066,6 @@ convert_to_aggr (type, expr, msgp, protect)\n \t\t     NULL_TREE);\n   TREE_TYPE (result) = TREE_TYPE (fntype);\n   TREE_SIDE_EFFECTS (result) = 1;\n-  TREE_RAISES (result) = !! TYPE_RAISES_EXCEPTIONS (fntype);\n   return result;\n }\n \n@@ -1184,10 +1188,8 @@ cp_convert (type, expr, convtype, flags)\n   register tree e = expr;\n   register enum tree_code code = TREE_CODE (type);\n \n-  if (type == TREE_TYPE (e)\n-      || TREE_CODE (e) == ERROR_MARK)\n-    return e;\n-  if (TREE_CODE (TREE_TYPE (e)) == ERROR_MARK)\n+  if (TREE_CODE (e) == ERROR_MARK\n+      || TREE_CODE (TREE_TYPE (e)) == ERROR_MARK)\n     return error_mark_node;\n \n   /* Trivial conversion: cv-qualifiers do not matter on rvalues.  */\n@@ -1229,7 +1231,8 @@ cp_convert (type, expr, convtype, flags)\n       /* enum = enum, enum = int, enum = float are all errors. */\n       if (flag_int_enum_equivalence == 0\n \t  && TREE_CODE (type) == ENUMERAL_TYPE\n-\t  && ARITHMETIC_TYPE_P (intype))\n+\t  && ARITHMETIC_TYPE_P (intype)\n+\t  && ! (convtype & CONV_STATIC))\n \t{\n \t  cp_pedwarn (\"conversion from `%#T' to `%#T'\", intype, type);\n \n@@ -1309,7 +1312,7 @@ cp_convert (type, expr, convtype, flags)\n \t  sig_ptr = get_temp_name (type, 1);\n \t  DECL_INITIAL (sig_ptr) = constructor;\n \t  CLEAR_SIGNATURE (sig_ty);\n-\t  finish_decl (sig_ptr, constructor, 0, 0);\n+\t  finish_decl (sig_ptr, constructor, NULL_TREE, 0, 0);\n \t  SET_SIGNATURE (sig_ty);\n \t  TREE_READONLY (sig_ptr) = 1;\n \n@@ -1338,7 +1341,7 @@ cp_convert (type, expr, convtype, flags)\n \t\t\t\t  build_tree_list (NULL_TREE, e),\n \t\t\t\t  TYPE_BINFO (type),\n \t\t\t\t  LOOKUP_NORMAL | LOOKUP_SPECULATIVELY\n-\t\t\t\t  | LOOKUP_ONLYCONVERTING\n+\t\t\t\t  | (convtype&CONV_NONCONVERTING ? 0 : LOOKUP_ONLYCONVERTING)\n \t\t\t\t  | (conversion ? LOOKUP_NO_CONVERSION : 0));\n \n       if (ctor == error_mark_node)\n@@ -1428,9 +1431,10 @@ convert (type, expr)\n    are not normally allowed due to access restrictions\n    (such as conversion from sub-type to private super-type).  */\n tree\n-convert_force (type, expr)\n+convert_force (type, expr, convtype)\n      tree type;\n      tree expr;\n+     int convtype;\n {\n   register tree e = expr;\n   register enum tree_code code = TREE_CODE (type);\n@@ -1455,13 +1459,8 @@ convert_force (type, expr)\n       /* compatible pointer to member functions. */\n       return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), e, 1);\n     }\n-  {\n-    int old_equiv = flag_int_enum_equivalence;\n-    flag_int_enum_equivalence = 1;\n-    e = convert (type, e);\n-    flag_int_enum_equivalence = old_equiv;\n-  }\n-  return e;\n+\n+  return cp_convert (type, e, CONV_OLD_CONVERT|convtype, 0);\n }\n \n /* Subroutine of build_type_conversion.  */"}, {"sha": "5d3c2f2c2648996d6ce879e86dd5aa1cb82ce8a0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 57, "deletions": 104, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -932,7 +932,8 @@ poplevel (keep, reverse, functionbody)\n     if (TREE_CODE (decl) == FUNCTION_DECL\n \t&& ! TREE_ASM_WRITTEN (decl)\n \t&& DECL_INITIAL (decl) != NULL_TREE\n-\t&& TREE_ADDRESSABLE (decl))\n+\t&& TREE_ADDRESSABLE (decl)\n+\t&& decl_function_context (decl) == current_function_decl)\n       {\n \t/* If this decl was copied from a file-scope decl\n \t   on account of a block-scope extern decl,\n@@ -1933,7 +1934,7 @@ clear_anon_tags ()\n    For C++, we must compare the parameter list so that `int' can match\n    `int&' in a parameter position, but `int&' is not confused with\n    `const int&'.  */\n-static int\n+int\n decls_match (newdecl, olddecl)\n      tree newdecl, olddecl;\n {\n@@ -2276,13 +2277,6 @@ duplicate_decls (newdecl, olddecl)\n \t\t\tDECL_LANGUAGE (newdecl));\n \t    }\n \t}\n-\n-      /* These bits are logically part of the type.  */\n-      if (pedantic\n-\t  && (TREE_READONLY (newdecl) != TREE_READONLY (olddecl)\n-\t      || TREE_THIS_VOLATILE (newdecl) != TREE_THIS_VOLATILE (olddecl)))\n-\tcp_error_at (\"type qualifiers for `%D' conflict with previous decl\",\n-\t\t     newdecl);\n     }\n \n   /* If new decl is `static' and an `extern' was seen previously,\n@@ -2391,7 +2385,7 @@ duplicate_decls (newdecl, olddecl)\n \n \t  if (! compexcepttypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl), 0))\n \t    {\n-\t      cp_error (\"declaration of `%D' raises different exceptions...\",\n+\t      cp_error (\"declaration of `%D' throws different exceptions...\",\n \t\t\tnewdecl);\n \t      cp_error_at (\"...from previous declaration here\", olddecl);\n \t    }\n@@ -2535,6 +2529,8 @@ duplicate_decls (newdecl, olddecl)\n \t  if (DECL_ARGUMENTS (olddecl))\n \t    DECL_ARGUMENTS (newdecl) = DECL_ARGUMENTS (olddecl);\n \t}\n+      if (DECL_LANG_SPECIFIC (olddecl))\n+\tDECL_MAIN_VARIANT (newdecl) = DECL_MAIN_VARIANT (olddecl);\n     }\n \n   if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n@@ -2671,7 +2667,7 @@ pushdecl (x)\n #else\n   /* Type are looked up using the DECL_NAME, as that is what the rest of the\n      compiler wants to use. */\n-  if (TREE_CODE (x) == TYPE_DECL)\n+  if (TREE_CODE (x) == TYPE_DECL || TREE_CODE (x) == VAR_DECL)\n     name = DECL_NAME (x);\n #endif\n \n@@ -2908,39 +2904,13 @@ pushdecl (x)\n \t      && TREE_CODE (oldglobal) == FUNCTION_DECL)\n \t    {\n \t      /* We have one.  Their types must agree.  */\n-\t      if (! comptypes (TREE_TYPE (x), TREE_TYPE (oldglobal), 1))\n+\t      if (duplicate_decls (x, oldglobal))\n+\t\t/* OK */;\n+\t      else\n \t\t{\n \t\t  cp_warning (\"extern declaration of `%#D' doesn't match\", x);\n \t\t  cp_warning_at (\"global declaration `%#D'\", oldglobal);\n \t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Inner extern decl is inline if global one is.\n-\t\t     Copy enough to really inline it.  */\n-\t\t  if (DECL_INLINE (oldglobal))\n-\t\t    {\n-\t\t      DECL_INLINE (x) = DECL_INLINE (oldglobal);\n-\t\t      DECL_INITIAL (x) = (current_function_decl == oldglobal\n-\t\t\t\t\t  ? NULL_TREE : DECL_INITIAL (oldglobal));\n-\t\t      DECL_SAVED_INSNS (x) = DECL_SAVED_INSNS (oldglobal);\n-\t\t      DECL_FRAME_SIZE (x) = DECL_FRAME_SIZE (oldglobal);\n-\t\t      DECL_ARGUMENTS (x) = DECL_ARGUMENTS (oldglobal);\n-\t\t      DECL_RESULT (x) = DECL_RESULT (oldglobal);\n-\t\t      TREE_ASM_WRITTEN (x) = TREE_ASM_WRITTEN (oldglobal);\n-\t\t      DECL_ABSTRACT_ORIGIN (x) = oldglobal;\n-\t\t    }\n-\t\t  /* Inner extern decl is built-in if global one is.  */\n-\t\t  if (DECL_BUILT_IN (oldglobal))\n-\t\t    {\n-\t\t      DECL_BUILT_IN (x) = DECL_BUILT_IN (oldglobal);\n-\t\t      DECL_FUNCTION_CODE (x) = DECL_FUNCTION_CODE (oldglobal);\n-\t\t    }\n-\t\t  /* Keep the arg types from a file-scope fcn defn.  */\n-\t\t  if (TYPE_ARG_TYPES (TREE_TYPE (oldglobal)) != NULL_TREE\n-\t\t      && DECL_INITIAL (oldglobal)\n-\t\t      && TYPE_ARG_TYPES (TREE_TYPE (x)) == NULL_TREE)\n-\t\t    TREE_TYPE (x) = TREE_TYPE (oldglobal);\n-\t\t}\n \t    }\n \t  /* If we have a local external declaration,\n \t     and no file-scope declaration has yet been seen,\n@@ -5625,7 +5595,7 @@ make_temporary_for_reference (decl, ctor_call, init, cleanupp)\n     {\n       DECL_INITIAL (tmp) = init;\n       TREE_STATIC (tmp) = current_binding_level == global_binding_level;\n-      finish_decl (tmp, init, 0, 0);\n+      finish_decl (tmp, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n     }\n   if (TREE_STATIC (tmp))\n     preserve_initializer ();\n@@ -5740,6 +5710,24 @@ grok_reference_init (decl, type, init, cleanupp)\n   return;\n }\n \n+/* Fill in DECL_INITIAL with some magical value to prevent expand_decl from\n+   mucking with forces it does not comprehend (i.e. initialization with a\n+   constructor).  If we are at global scope and won't go into COMMON, fill\n+   it in with a dummy CONSTRUCTOR to force the variable into .data;\n+   otherwise we can use error_mark_node.  */\n+\n+static void\n+obscure_complex_init (decl)\n+     tree decl;\n+{\n+  if (current_binding_level == global_binding_level\n+      && ! DECL_COMMON (decl))\n+    DECL_INITIAL (decl) = build (CONSTRUCTOR, TREE_TYPE (decl), NULL_TREE,\n+\t\t\t\t NULL_TREE);\n+  else\n+    DECL_INITIAL (decl) = error_mark_node;\n+}\n+\n /* Finish processing of a declaration;\n    install its line number and initial value.\n    If the length of an array type is not known before,\n@@ -5754,16 +5742,20 @@ grok_reference_init (decl, type, init, cleanupp)\n    INIT0 holds the value of an initializer that should be allowed to escape\n    the normal rules.\n \n+   FLAGS is LOOKUP_ONLYCONVERTING is the = init syntax was used, else 0\n+   if the (init) syntax was used.\n+\n    For functions that take default parameters, DECL points to its\n    \"maximal\" instantiation.  `finish_decl' must then also declared its\n    subsequently lower and lower forms of instantiation, checking for\n    ambiguity as it goes.  This can be sped up later.  */\n \n void\n-finish_decl (decl, init, asmspec_tree, need_pop)\n+finish_decl (decl, init, asmspec_tree, need_pop, flags)\n      tree decl, init;\n      tree asmspec_tree;\n      int need_pop;\n+     int flags;\n {\n   register tree type;\n   tree cleanup = NULL_TREE, ttype;\n@@ -5871,10 +5863,7 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n       if (asmspec)\n \t{\n \t  /* This must override the asm specifier which was placed\n-\t     by grokclassfn.  Lay this out fresh.\n-\t     \n-\t     @@ Should emit an error if this redefines an asm-specified\n-\t     @@ name, or if we have already used the function's name.  */\n+\t     by grokclassfn.  Lay this out fresh.  */\n \t  DECL_RTL (TREE_TYPE (decl)) = NULL_RTX;\n \t  DECL_ASSEMBLER_NAME (decl) = get_identifier (asmspec);\n \t  make_decl_rtl (decl, asmspec, 0);\n@@ -5971,18 +5960,7 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \n \t  /* We must hide the initializer so that expand_decl\n \t     won't try to do something it does not understand.  */\n-\t  if (current_binding_level == global_binding_level)\n-\t    {\n-\t      tree value;\n-\t      if (DECL_COMMON (decl))\n-\t\t/* Should this be a NULL_TREE? */\n-\t\tvalue = error_mark_node;\n-\t      else\n-\t\tvalue = build (CONSTRUCTOR, type, NULL_TREE, NULL_TREE);\n-\t      DECL_INITIAL (decl) = value;\n-\t    }\n-\t  else\n-\t    DECL_INITIAL (decl) = error_mark_node;\n+\t  obscure_complex_init (decl);\n \t}\n       else\n \t{\n@@ -5993,14 +5971,7 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t  /* Don't let anyone try to initialize this variable\n \t     until we are ready to do so.  */\n \t  if (init)\n-\t    {\n-\t      tree value;\n-\t      if (DECL_COMMON (decl))\n-\t\tvalue = error_mark_node;\n-\t      else\n-\t\tvalue = build (CONSTRUCTOR, type, NULL_TREE, NULL_TREE);\n-\t      DECL_INITIAL (decl) = value;\n-\t    }\n+\t    obscure_complex_init (decl);\n \t}\n     }\n   else if (DECL_EXTERNAL (decl))\n@@ -6026,20 +5997,9 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t  && (TYPE_READONLY (type) || TREE_READONLY (decl)))\n \tcp_error (\"uninitialized const `%D'\", decl);\n \n-      /* Initialize variables in need of static initialization with\n-\t an empty CONSTRUCTOR to keep assemble_variable from putting them in\n-\t the wrong program space.  */\n-      if (flag_pic == 0\n-\t  && TREE_STATIC (decl)\n-\t  && TREE_PUBLIC (decl)\n-\t  && ! DECL_EXTERNAL (decl)\n-\t  && TREE_CODE (decl) == VAR_DECL\n-\t  && TYPE_NEEDS_CONSTRUCTING (type)\n-\t  && (DECL_INITIAL (decl) == NULL_TREE\n-\t      || DECL_INITIAL (decl) == error_mark_node)\n-\t  && ! DECL_COMMON (decl))\n-\tDECL_INITIAL (decl) = build (CONSTRUCTOR, type, NULL_TREE,\n-\t\t\t\t     NULL_TREE);\n+      if (TYPE_SIZE (type) != NULL_TREE\n+\t  && TYPE_NEEDS_CONSTRUCTING (type))\n+\tobscure_complex_init (decl);\n     }\n   else if (TREE_CODE (decl) == VAR_DECL\n \t   && TREE_CODE (type) != REFERENCE_TYPE\n@@ -6396,7 +6356,7 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n \t\t{\n \t\t  emit_line_note (DECL_SOURCE_FILE (decl),\n \t\t\t\t  DECL_SOURCE_LINE (decl));\n-\t\t  expand_aggr_init (decl, init, 0);\n+\t\t  expand_aggr_init (decl, init, 0, flags);\n \t\t}\n \n \t      /* Set this to 0 so we can tell whether an aggregate which\n@@ -6510,7 +6470,7 @@ expand_static_init (decl, init)\n       expand_assignment (temp, integer_one_node, 0, 0);\n       if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n \t{\n-\t  expand_aggr_init (decl, init, 0);\n+\t  expand_aggr_init (decl, init, 0, 0);\n \t  do_pending_stack_adjust ();\n \t}\n       else\n@@ -6639,7 +6599,7 @@ bad_specifiers (object, type, virtualp, quals, inlinep, friendp, raises)\n   if (friendp)\n     cp_error_at (\"invalid friend declaration\", object);\n   if (raises)\n-    cp_error_at (\"invalid raises declaration\", object);\n+    cp_error_at (\"invalid exception specifications\", object);\n }\n \n /* CTYPE is class type, or null if non-class.\n@@ -6889,6 +6849,8 @@ grokvardecl (type, declarator, specbits, initialized)\n   else\n     decl = build_decl (VAR_DECL, declarator, type);\n \n+  DECL_ASSEMBLER_NAME (decl) = current_namespace_id (DECL_ASSEMBLER_NAME (decl));\n+\n   if (RIDBIT_SETP (RID_EXTERN, specbits))\n     {\n       DECL_THIS_EXTERN (decl) = 1;\n@@ -7166,7 +7128,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t      init = TREE_OPERAND (decl, 1);\n \n \t      decl = start_decl (declarator, declspecs, 1, NULL_TREE);\n-\t      finish_decl (decl, init, NULL_TREE, 1);\n+\t      finish_decl (decl, init, NULL_TREE, 1, 0);\n \t      return 0;\n \t    }\n \t  innermost_code = TREE_CODE (decl);\n@@ -9071,7 +9033,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t  return NULL_TREE;\n \n \tif (ctype == NULL_TREE && DECL_LANGUAGE (decl) != lang_c)\n-\t  DECL_ASSEMBLER_NAME (decl) = declarator;\n+\t  DECL_ASSEMBLER_NAME (decl) = current_namespace_id (declarator);\n \n \tif (staticp == 1)\n \t  {\n@@ -10349,26 +10311,17 @@ finish_enum (enumtype, values)\n     int highprec = min_precision (maxnode, unsignedp);\n     int precision = MAX (lowprec, highprec);\n \n-    if (! flag_short_enums && precision < TYPE_PRECISION (integer_type_node))\n-      precision = TYPE_PRECISION (integer_type_node);\n-\n+    TYPE_SIZE (enumtype) = NULL_TREE;\n \n-    /*\n-     *  The following code is unnecessary since the function \n-     *  type_promotes_to deals correctly with promotion of enums of \n-     *  underlying unsigned types to signed integer types.\n-     *  Moreover, it causes an enum bitfield to require one more bit of\n-     *  storage than defined by the ANSI/ISO C++ resolution section r.7.2\n-     *  which defines the range of an enum. \n-     */\n-#if 0\n-    /* Unlike the C frontend, we prefer signed types.  */\n-    if (unsignedp && int_fits_type_p (maxnode, type_for_size (precision, 0)))\n-      unsignedp = 0;\n-#endif\n+    /* Lay out the type as though it were an integer.  */\n+    if (! flag_short_enums && precision < TYPE_PRECISION (integer_type_node))\n+      {\n+\tTYPE_MIN_VALUE (enumtype) = minnode;\n+\tTYPE_PRECISION (enumtype) = TYPE_PRECISION (integer_type_node);\n+\tlayout_type (enumtype);\n+      }\n \n     TYPE_PRECISION (enumtype) = precision;\n-    TYPE_SIZE (enumtype) = NULL_TREE;\n     if (unsignedp)\n       fixup_unsigned_type (enumtype);\n     else\n@@ -11110,7 +11063,7 @@ store_return_init (return_id, init)\n       /* Let `finish_decl' know that this initializer is ok.  */\n       DECL_INITIAL (decl) = init;\n       pushdecl (decl);\n-      finish_decl (decl, init, 0, 0);\n+      finish_decl (decl, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n     }\n }\n \n@@ -11757,7 +11710,7 @@ start_method (declspecs, declarator, raises)\n \tgrok_op_properties (fndecl, DECL_VIRTUAL_P (fndecl), 0);\n     }\n \n-  finish_decl (fndecl, NULL_TREE, NULL_TREE, 0);\n+  finish_decl (fndecl, NULL_TREE, NULL_TREE, 0, 0);\n \n   /* Make a place for the parms */\n   pushlevel (0);"}, {"sha": "5e065725905a136479f425d3c67b995a4734fb68", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 106, "deletions": 12, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -1147,6 +1147,10 @@ check_classfn (ctype, cname, function)\n \t\t{\n \t\t  if (DECL_ASSEMBLER_NAME (function) == DECL_ASSEMBLER_NAME (fndecl))\n \t\t    return;\n+\t\t  /* We have to do more extensive argument checking here, as\n+\t\t     the name may have been changed by asm(\"new_name\"). */\n+\t\t  if (decls_match (function, fndecl))\n+\t\t    return;\n \t\t  fndecl = DECL_CHAIN (fndecl);\n \t\t}\n \t      break;\t\t/* loser */\n@@ -1195,6 +1199,7 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree)\n {\n   register tree value;\n   char *asmspec = 0;\n+  int flags = LOOKUP_ONLYCONVERTING;\n \n   /* Convert () initializers to = initializers.  */\n   if (init == NULL_TREE && declarator != NULL_TREE\n@@ -1206,6 +1211,7 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree)\n     {\n       init = TREE_OPERAND (declarator, 1);\n       declarator = TREE_OPERAND (declarator, 0);\n+      flags = 0;\n     }\n \n   if (init\n@@ -1353,17 +1359,22 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree)\n       DECL_INITIAL (value) = init;\n       DECL_IN_AGGR_P (value) = 1;\n \n-      finish_decl (value, init, asmspec_tree, 1);\n+      finish_decl (value, init, asmspec_tree, 1, flags);\n       pushdecl_class_level (value);\n       return value;\n     }\n   if (TREE_CODE (value) == FIELD_DECL)\n     {\n       if (asmspec)\n-\tDECL_ASSEMBLER_NAME (value) = get_identifier (asmspec);\n+\t{\n+\t  /* This must override the asm specifier which was placed\n+\t     by grokclassfn.  Lay this out fresh.  */\n+\t  DECL_RTL (value) = NULL_RTX;\n+\t  DECL_ASSEMBLER_NAME (value) = get_identifier (asmspec);\n+\t}\n       if (DECL_INITIAL (value) == error_mark_node)\n \tinit = error_mark_node;\n-      finish_decl (value, init, asmspec_tree, 1);\n+      finish_decl (value, init, asmspec_tree, 1, flags);\n       DECL_INITIAL (value) = init;\n       DECL_IN_AGGR_P (value) = 1;\n       return value;\n@@ -1378,7 +1389,14 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree)\n \t  /* When does this happen?  */\n \t  my_friendly_assert (init == NULL_TREE, 193);\n \t}\n-      finish_decl (value, init, asmspec_tree, 1);\n+      if (asmspec)\n+\t{\n+\t  /* This must override the asm specifier which was placed\n+\t     by grokclassfn.  Lay this out fresh.  */\n+\t  DECL_RTL (value) = NULL_RTX;\n+\t  DECL_ASSEMBLER_NAME (value) = get_identifier (asmspec);\n+\t}\n+      finish_decl (value, init, asmspec_tree, 1, flags);\n \n       /* Pass friends back this way.  */\n       if (DECL_FRIEND_P (value))\n@@ -1439,7 +1457,7 @@ grokbitfield (declarator, declspecs, width)\n       cp_error (\"static member `%D' cannot be a bitfield\", value);\n       return NULL_TREE;\n     }\n-  finish_decl (value, NULL_TREE, NULL_TREE, 0);\n+  finish_decl (value, NULL_TREE, NULL_TREE, 0, 0);\n \n   if (width != error_mark_node)\n     {\n@@ -1631,7 +1649,7 @@ groktypefield (declspecs, parmlist)\n       return void_type_node;\n     }\n \n-  finish_decl (decl, NULL_TREE, NULL_TREE, 0);\n+  finish_decl (decl, NULL_TREE, NULL_TREE, 0, 0);\n \n   /* If this declaration is common to another declaration\n      complain about such redundancy, and return NULL_TREE\n@@ -1934,7 +1952,7 @@ setup_vtbl_ptr ()\n       DECL_INITIAL (current_vtable_decl) = error_mark_node;\n       /* Have to cast the initializer, since it may have come from a\n \t more base class then we ascribe CURRENT_VTABLE_DECL to be.  */\n-      finish_decl (current_vtable_decl, convert_force (TREE_TYPE (current_vtable_decl), vfield), 0, 0);\n+      finish_decl (current_vtable_decl, convert_force (TREE_TYPE (current_vtable_decl), vfield, 0), NULL_TREE, 0, 0);\n       current_vtable_decl = build_indirect_ref (current_vtable_decl, NULL_PTR);\n     }\n   else\n@@ -1947,8 +1965,10 @@ void\n mark_inline_for_output (decl)\n      tree decl;\n {\n+  decl = DECL_MAIN_VARIANT (decl);\n   if (DECL_SAVED_INLINE (decl))\n     return;\n+  my_friendly_assert (TREE_PERMANENT (decl), 363);\n   DECL_SAVED_INLINE (decl) = 1;\n   if (DECL_PENDING_INLINE_INFO (decl) != 0\n       && ! DECL_PENDING_INLINE_INFO (decl)->deja_vu)\n@@ -2176,7 +2196,7 @@ finish_table (name, type, init, publicp)\n \t  DECL_INITIAL (empty_table) = init;\n \t  asmspec = build_string (IDENTIFIER_LENGTH (DECL_NAME (empty_table)),\n \t\t\t\t  IDENTIFIER_POINTER (DECL_NAME (empty_table)));\n-\t  finish_decl (empty_table, init, asmspec, 0);\n+\t  finish_decl (empty_table, init, asmspec, 0, 0);\n \t}\n       is_empty = 1;\n     }\n@@ -2214,7 +2234,7 @@ finish_table (name, type, init, publicp)\n \t\t\t      IDENTIFIER_POINTER (DECL_NAME (empty_table)));\n     }\n \n-  finish_decl (decl, init, asmspec, 0);\n+  finish_decl (decl, init, asmspec, 0, 0);\n   return decl;\n }\n \n@@ -2782,7 +2802,7 @@ finish_file ()\n \t\t}\n \t      if (IS_AGGR_TYPE (TREE_TYPE (decl))\n \t\t  || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n-\t\texpand_aggr_init (decl, init, 0);\n+\t\texpand_aggr_init (decl, init, 0, 0);\n \t      else if (TREE_CODE (init) == TREE_VEC)\n \t\t{\n \t\t  expand_expr (expand_vec_init (decl, TREE_VEC_ELT (init, 0),\n@@ -2803,7 +2823,7 @@ finish_file ()\n \t\t  /* a `new' expression at top level.  */\n \t\t  expand_expr (decl, const0_rtx, VOIDmode, 0);\n \t\t  free_temp_slots ();\n-\t\t  expand_aggr_init (build_indirect_ref (decl, NULL_PTR), init, 0);\n+\t\t  expand_aggr_init (build_indirect_ref (decl, NULL_PTR), init, 0, 0);\n \t\t}\n \t    }\n \t  else if (decl == error_mark_node)\n@@ -3041,7 +3061,7 @@ reparse_absdcl_as_casts (decl, expr)\n     {\n       type = groktypename (TREE_VALUE (TREE_OPERAND (decl, 1)));\n       decl = TREE_OPERAND (decl, 0);\n-      expr = build_c_cast (type, expr);\n+      expr = build_c_cast (type, expr, 0);\n     }\n \n   return expr;\n@@ -3166,3 +3186,77 @@ check_cp_case_value (value)\n \n   return value;\n }\n+\n+static tree current_namespace;\n+\n+/* Get the inner part of a namespace id.  It doesn't have any prefix, nor\n+   postfix.  Returns 0 if in global namespace.  */\n+tree\n+get_namespace_id ()\n+{\n+  tree x = current_namespace;\n+  if (x)\n+    x = TREE_PURPOSE (x);\n+  return x;\n+}\n+\n+/* Build up a DECL_ASSEMBLER_NAME for NAME in the current namespace. */\n+tree\n+current_namespace_id (name)\n+     tree name;\n+{\n+  tree old_id = get_namespace_id ();\n+  char *buf;\n+\n+  /* Global names retain old encoding. */\n+  if (! old_id)\n+    return name;\n+\n+  buf = (char *) alloca (8 + IDENTIFIER_LENGTH (old_id)\n+\t\t\t + IDENTIFIER_LENGTH (name));\n+  sprintf (buf, \"__ns_%s_%s\", IDENTIFIER_POINTER (old_id),\n+\t   IDENTIFIER_POINTER (name));\n+  return get_identifier (buf);\n+}\n+\n+/* Push into the scopre of the NAME namespace.  */\n+void\n+push_namespace (name)\n+     tree name;\n+{\n+  tree old_id = get_namespace_id ();\n+  char *buf;\n+\n+  current_namespace = tree_cons (NULL_TREE, name, current_namespace);\n+  buf = (char *) alloca (4 + (old_id ? IDENTIFIER_LENGTH (old_id) : 0)\n+\t\t\t + IDENTIFIER_LENGTH (name));\n+  sprintf (buf, \"%s%s\", old_id ? IDENTIFIER_POINTER (old_id) : \"\",\n+\t   IDENTIFIER_POINTER (name));\n+  TREE_PURPOSE (current_namespace) = get_identifier (buf);\n+}\n+\n+/* Pop from the scope of the current namespace.  */\n+void\n+pop_namespace ()\n+{\n+  current_namespace = TREE_CHAIN (current_namespace);\n+}\n+\n+void\n+do_namespace_alias (alias, namespace)\n+     tree alias, namespace;\n+{\n+}\n+\n+tree\n+do_using_decl (decl)\n+     tree decl;\n+{\n+  return error_mark_node;\n+}\n+\n+void\n+do_using_directive (namespace)\n+     tree namespace;\n+{\n+}"}, {"sha": "ff4cc0904ea9d3bf0cec8efb6015f26e98b723e2", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -1017,8 +1017,7 @@ dump_expr (t, nop)\n \t}\n       else\n \t{\n-\t  sorry (\"operand of SAVE_EXPR not understood\");\n-\t  goto error;\n+\t  dump_expr (TREE_OPERAND (t, 0), 0);\n \t}\n       break;\n "}, {"sha": "87ec7a80c6faa1c45b7474864f9b1ed65b775c60", "filename": "gcc/cp/except.c", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -43,7 +43,7 @@ tree builtin_return_address_fndecl;\n #define TRY_NEW_EH\n #endif\n #endif\n-#if defined(__i386) || defined(__rs6000) || defined(__hppa)\n+#if defined(__i386) || defined(__rs6000) || defined(__hppa) || defined(__mc68000) || defined (__mips)\n #define TRY_NEW_EH\n #endif\n #endif\n@@ -802,6 +802,16 @@ init_exception_processing ()\n   saved_pc = gen_rtx (REG, Pmode, 5);\n   saved_throw_type = gen_rtx (REG, Pmode, 6);\n   saved_throw_value = gen_rtx (REG, Pmode, 7);\n+#endif\n+#ifdef __mc68000\n+  saved_pc = gen_rtx (REG, Pmode, 10);\n+  saved_throw_type = gen_rtx (REG, Pmode, 11);\n+  saved_throw_value = gen_rtx (REG, Pmode, 12);\n+#endif\n+#ifdef __mips\n+  saved_pc = gen_rtx (REG, Pmode, 16);\n+  saved_throw_type = gen_rtx (REG, Pmode, 17);\n+  saved_throw_value = gen_rtx (REG, Pmode, 18);\n #endif\n   new_eh_queue (&ehqueue);\n   new_eh_queue (&eh_table_output_queue);\n@@ -977,6 +987,13 @@ expand_end_all_catch ()\n   if (! doing_eh (1))\n     return;\n \n+  /* Code to throw out to outer context, if we fall off end of catch\n+     handlers.  */\n+  emit_move_insn (saved_pc, gen_rtx (LABEL_REF,\n+\t\t\t\t     Pmode,\n+\t\t\t\t     top_label_entry (&caught_return_label_stack)));\n+  emit_jump (throw_label);\n+\n   /* Find the start of the catch block.  */\n   last = pop_last_insn ();\n   catchstart = NEXT_INSN (last);\n@@ -1136,7 +1153,7 @@ expand_start_catch_block (declspecs, declarator)\n \n       /* if it returned FALSE, jump over the catch block, else fall into it */\n       emit_jump_insn (gen_bne (false_label_rtx));\n-      finish_decl (decl, init, NULL_TREE, 0);\n+      finish_decl (decl, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n     }\n   else\n     {\n@@ -1165,7 +1182,7 @@ void expand_end_catch_block ()\n       /* label we jump to if we caught the exception */\n       emit_jump (top_label_entry (&caught_return_label_stack));\n \n-      /* Code to throw out to outer context, if we get an throw from within\n+      /* Code to throw out to outer context, if we get a throw from within\n \t our catch handler. */\n       /* These are saved for the exception table.  */\n       push_rtl_perm ();\n@@ -1240,7 +1257,7 @@ do_unwind (throw_label)\n   easy_expand_asm (\"restore\");\n   emit_barrier ();\n #endif\n-#if defined(__i386) || defined(__rs6000) || defined(__hppa)\n+#if defined(__i386) || defined(__rs6000) || defined(__hppa) || defined(__mc68000) || defined (__mips)\n   extern FILE *asm_out_file;\n   tree fcall;\n   tree params;\n@@ -1443,9 +1460,13 @@ expand_throw (exp)\n \n \temit_move_insn (saved_throw_type, throw_type_rtx);\n \texp = convert_to_reference (build_reference_type (build_type_variant (TREE_TYPE (exp), 1, 0)), exp, CONV_STATIC, LOOKUP_COMPLAIN, error_mark_node);\n+\n+\t/* Make a copy of the thrown object.  WP 15.1.5  */\n+\texp = build_new (NULL_TREE, TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (exp))), exp, 0);\n+\n \tif (exp == error_mark_node)\n \t  error (\"  in thrown expression\");\n-\tthrow_value_rtx = expand_expr (build_unary_op (ADDR_EXPR, exp, 0), NULL_RTX, VOIDmode, 0);\n+\tthrow_value_rtx = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n \temit_move_insn (saved_throw_value, throw_value_rtx);\n       }\n     }"}, {"sha": "a7dc3d8051a834d6c49548898a8d586d0b8d1b97", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -155,7 +155,7 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \t\tTREE_ADDRESSABLE (init) = 1;\n \n \t\tflag_access_control = 0;\n-\t\texpand_aggr_init (slot, init, 0);\n+\t\texpand_aggr_init (slot, init, 0, LOOKUP_ONLYCONVERTING);\n \t\tflag_access_control = old_ac;\n \n \t\tif (TYPE_NEEDS_DESTRUCTOR (type))\n@@ -195,7 +195,7 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \t    init = build (RTL_EXPR, return_type, 0, call_target);\n \t    /* We got back a reference to the type we want.  Now initialize\n \t       target with that.  */\n-\t    expand_aggr_init (slot, init, 0);\n+\t    expand_aggr_init (slot, init, 0, LOOKUP_ONLYCONVERTING);\n \t  }\n \n \tif (DECL_RTL (slot) != target)"}, {"sha": "961fb6d16f377047d0908c8908b68097b9e99049", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -1189,24 +1189,21 @@ the object was thrown.  This is so that there is always someplace for\n the exception object, and nothing can overwrite it, once we start\n throwing.  The only bad part, is that the stack remains large.\n \n-Flaws in g++'s exception handling.  The stack pointer is restored from\n-stack, we want to match rs6000, and propagate the stack pointer from\n-time of throw, down, to the catch place.\n-\n-Only exact type matching of throw types works (references work also),\n-catch variables cannot be used.  Only works on a Sun sparc running SunOS\n-4.1.x.  Unwinding to outer catch clauses works.  All temps and local\n-variables are cleaned up in all unwinded scopes.  Completed parts of\n-partially constructed objects are not cleaned up.  Don't expect\n-exception handling to work right if you optimize, in fact the compiler\n-will probably core dump.  If two EH regions are the exact same size, the\n-backend cannot tell which one is first.  It punts by picking the last\n-one, if they tie.  This is usually right.  We really should stick in a\n-nop, if they are the same size.\n-\n-If we fall off the end of a series of catch blocks, we return to the\n-flow of control in a normal fasion.  But this is wrong, we should\n-rethrow.\n+The below points out some flaws in g++'s exception handling, as it now\n+stands.\n+\n+Only exact type matching or reference matching of throw types works.\n+Only works on a SPARC machines (like Suns), and i386 machines.  Partial\n+support is also in for rs6000, hppa, m68k and mips machines, but a stack\n+unwinder called __unwind_function has to be written, and added to\n+libgcc2 for them.  All completely constructed temps and local variables\n+are cleaned up in all unwinded scopes.  Completed parts of partially\n+constructed objects are not cleaned up.  Don't expect exception handling\n+to work right if you optimize, in fact the compiler will probably core\n+dump.  If two EH regions are the exact same size, the backend cannot\n+tell which one is first.  It punts by picking the last one, if they tie.\n+This is usually right.  We really should stick in a nop, if they are the\n+same size.\n \n When we invoke the copy constructor for an exception object because it\n is passed by value, and if we take a hit (exception) inside the copy\n@@ -1216,16 +1213,24 @@ exists, but rather to allow the frame to unwind into the next series of\n handlers, if any.  If this is the wrong way to do it, we will need to\n protect the rest of the handler in some fashion.  Maybe just changing\n the handler's handler to protect the whole series of handlers is the\n-right way to go.\n-\n-The EH object is copied like it should be, if it is passed by value,\n-otherwise we get a reference directly to it.\n-\n-EH objects make it through unwinding, but are subject to being\n-overwritten as they are still past the top of stack.  Don't throw\n-automatic objects if this is a problem.\n-\n-Exceptions in catch handlers now go to outer block.\n+right way to go.  This part is wrong.  We should call terminate if an\n+exception is thrown while doing things like trying to copy the exception\n+object.\n+\n+Exception specifications are handled syntax wise, but not semantic wise.\n+build_exception_variant should sort the incoming list, so that is\n+implements set compares, not exact list equality.  Type smashing should\n+smash exception specifications using set union.\n+\n+Thrown objects are allocated on the heap, in the usual way, but they are\n+never deleted.  They should be deleted by the catch clauses.\n+\n+In stmt.c, expand_end_bindings attempts to eliminate the generation of\n+destructors for a binding contour if the code would be unreachable (last\n+insn == BARRIER). In this case, interim_eh_hook is never called for the\n+end of the lifetimes of auto variables, so the compiler generates\n+invalid assembler (the end label for the scope is never declared, and\n+destructor code isn't generated on the exception path).\n \n @node Free Store, Concept Index, Exception Handling, Top\n @section Free Store"}, {"sha": "cbff4c7549cde1fe35445930f4bf1aaf845cd1f6", "filename": "gcc/cp/init.c", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -185,7 +185,7 @@ perform_member_init (member, name, init, explicit)\n \t\t\t   array_type_nelts (type), TREE_VALUE (init), 1);\n \t}\n       else\n-\texpand_aggr_init (decl, init, 0);\n+\texpand_aggr_init (decl, init, 0, 0);\n     }\n   else\n     {\n@@ -734,7 +734,7 @@ expand_virtual_init (binfo, decl)\n     return;\n \n   /* Have to convert VTBL since array sizes may be different.  */\n-  vtbl = convert_force (TREE_TYPE (vtbl_ptr), vtbl);\n+  vtbl = convert_force (TREE_TYPE (vtbl_ptr), vtbl, 0);\n   expand_expr_stmt (build_modify_expr (vtbl_ptr, NOP_EXPR, vtbl));\n }\n \n@@ -1071,7 +1071,7 @@ expand_member_init (exp, name, init)\n   else if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (field)))\n     {\n       parm = build_component_ref (exp, name, 0, 0);\n-      expand_aggr_init (parm, NULL_TREE, 0);\n+      expand_aggr_init (parm, NULL_TREE, 0, 0);\n       rval = error_mark_node;\n     }\n \n@@ -1087,6 +1087,8 @@ expand_member_init (exp, name, init)\n    INIT comes in two flavors: it is either a value which\n    is to be stored in EXP, or it is a parameter list\n    to go to a constructor, which will operate on EXP.\n+   If FLAGS is LOOKUP_ONLYCONVERTING then it is the = init form of\n+   the initializer, if FLAGS is 0, then it is the (init) form.\n    If `init' is a CONSTRUCTOR, then we emit a warning message,\n    explaining that such initializations are illegal.\n \n@@ -1116,9 +1118,10 @@ expand_member_init (exp, name, init)\n    */\n \n void\n-expand_aggr_init (exp, init, alias_this)\n+expand_aggr_init (exp, init, alias_this, flags)\n      tree exp, init;\n      int alias_this;\n+     int flags;\n {\n   tree type = TREE_TYPE (exp);\n   int was_const = TREE_READONLY (exp);\n@@ -1179,7 +1182,7 @@ expand_aggr_init (exp, init, alias_this)\n     init = CONSTRUCTOR_ELTS (init);\n #endif\n   expand_aggr_init_1 (TYPE_BINFO (type), exp, exp,\n-\t\t      init, alias_this, LOOKUP_NORMAL);\n+\t\t      init, alias_this, LOOKUP_NORMAL|flags);\n   TREE_READONLY (exp) = was_const;\n }\n \n@@ -1353,9 +1356,6 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t\t  init = build (CALL_EXPR, init_type,\n \t\t\t\tTREE_OPERAND (init, 0), TREE_OPERAND (init, 1), 0);\n \t\t  TREE_SIDE_EFFECTS (init) = 1;\n-#if 0\n-\t\t  TREE_RAISES (init) = ??\n-#endif\n \t\t    if (init_list)\n \t\t      TREE_VALUE (init_list) = init;\n \t\t}\n@@ -1425,9 +1425,6 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t      init = build (CALL_EXPR, build_pointer_type (TREE_TYPE (init)),\n \t\t\t    TREE_OPERAND (init, 0), TREE_OPERAND (init, 1), 0);\n \t      TREE_SIDE_EFFECTS (init) = 1;\n-#if 0\n-\t      TREE_RAISES (init) = ??\n-#endif\n \t      TREE_VALUE (TREE_OPERAND (init, 1))\n \t\t= convert_pointer_to (TREE_TYPE (TREE_TYPE (TREE_VALUE (tmp))), arg);\n \n@@ -1561,7 +1558,7 @@ expand_recursive_init_1 (binfo, true_exp, addr, init_list, alias_this)\n \t      tree subexp = build_indirect_ref (convert_pointer_to (TREE_VALUE (init_list), addr), NULL_PTR);\n \t      tree member_base = build (COMPONENT_REF, TREE_TYPE (member), subexp, member);\n \t      if (IS_AGGR_TYPE (TREE_TYPE (member)))\n-\t\texpand_aggr_init (member_base, DECL_INITIAL (member), 0);\n+\t\texpand_aggr_init (member_base, DECL_INITIAL (member), 0, 0);\n \t      else if (TREE_CODE (TREE_TYPE (member)) == ARRAY_TYPE\n \t\t       && TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (member)))\n \t\t{\n@@ -1803,7 +1800,7 @@ build_member_call (cname, name, parmlist)\n \t{\n \t  tree newtype = build_type_variant (type, TYPE_READONLY (oldtype),\n \t\t\t\t\t     TYPE_VOLATILE (oldtype));\n-\t  decl = convert_force (build_pointer_type (newtype), olddecl);\n+\t  decl = convert_force (build_pointer_type (newtype), olddecl, 0);\n \t}\n       else\n \tdecl = olddecl;\n@@ -3114,7 +3111,7 @@ build_new (placement, decl, init, use_global_new)\n \t  /* New 2.0 interpretation: `new int (10)' means\n \t     allocate an int, and initialize it with 10.  */\n \n-\t  init = build_c_cast (type, init);\n+\t  init = build_c_cast (type, init, 1);\n \t  rval = build (COMPOUND_EXPR, TREE_TYPE (rval),\n \t\t\tbuild_modify_expr (build_indirect_ref (rval, NULL_PTR),\n \t\t\t\t\t   NOP_EXPR, init),\n@@ -3151,7 +3148,7 @@ build_new (placement, decl, init, use_global_new)\n \t\t\t\t    build_binary_op (MINUS_EXPR, nelts, integer_one_node, 1),\n \t\t\t\t    init, 0);\n \t  else\n-\t    expand_aggr_init (build_indirect_ref (rval, NULL_PTR), init, 0);\n+\t    expand_aggr_init (build_indirect_ref (rval, NULL_PTR), init, 0, 0);\n \n \t  do_pending_stack_adjust ();\n \n@@ -3179,7 +3176,7 @@ build_new (placement, decl, init, use_global_new)\n   if (rval && TREE_TYPE (rval) != build_pointer_type (type))\n     {\n       /* The type of new int [3][3] is not int *, but int [3] * */\n-      rval = build_c_cast (build_pointer_type (type), rval);\n+      rval = build_c_cast (build_pointer_type (type), rval, 0);\n     }\n \n   if (pending_sizes)\n@@ -3273,7 +3270,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \t  while (elts)\n \t    {\n \t      host_i -= 1;\n-\t      expand_aggr_init (baseref, TREE_VALUE (elts), 0);\n+\t      expand_aggr_init (baseref, TREE_VALUE (elts), 0, 0);\n \n \t      expand_assignment (base, baseinc, 0, 0);\n \t      elts = TREE_CHAIN (elts);\n@@ -3357,7 +3354,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \t  if (from_array == 2)\n \t    expand_expr_stmt (build_modify_expr (to, NOP_EXPR, from));\n \t  else if (TYPE_NEEDS_CONSTRUCTING (type))\n-\t    expand_aggr_init (to, from, 0);\n+\t    expand_aggr_init (to, from, 0, 0);\n \t  else if (from)\n \t    expand_assignment (to, from, 0, 0);\n \t  else\n@@ -3371,7 +3368,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \t\t\t   array_type_nelts (type), 0, 0);\n \t}\n       else\n-\texpand_aggr_init (build1 (INDIRECT_REF, type, base), init, 0);\n+\texpand_aggr_init (build1 (INDIRECT_REF, type, base), init, 0, 0);\n \n       expand_assignment (base,\n \t\t\t build (PLUS_EXPR, TYPE_POINTER_TO (type), base, size),\n@@ -3488,7 +3485,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \taddr = save_expr (addr);\n \n       /* throw away const and volatile on target type of addr */\n-      addr = convert_force (build_pointer_type (type), addr);\n+      addr = convert_force (build_pointer_type (type), addr, 0);\n       ref = build_indirect_ref (addr, NULL_PTR);\n       ptr = 1;\n     }\n@@ -3514,7 +3511,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n       if (TREE_CONSTANT (addr))\n \taddr = convert_pointer_to (type, addr);\n       else\n-\taddr = convert_force (build_pointer_type (type), addr);\n+\taddr = convert_force (build_pointer_type (type), addr, 0);\n \n       if (TREE_CODE (addr) == NOP_EXPR\n \t  && TREE_OPERAND (addr, 0) == current_class_decl)\n@@ -3803,7 +3800,7 @@ build_vbase_delete (type, decl)\n   while (vbases)\n     {\n       tree this_addr = convert_force (TYPE_POINTER_TO (BINFO_TYPE (vbases)),\n-\t\t\t\t      addr);\n+\t\t\t\t      addr, 0);\n       result = tree_cons (NULL_TREE,\n \t\t\t  build_delete (TREE_TYPE (this_addr), this_addr,\n \t\t\t\t\tinteger_zero_node,"}, {"sha": "97f1f023c97037b5b35a68ac9c4bcca206209a99", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -2587,6 +2587,15 @@ check_newline ()\n \t\t      TREE_INT_CST_HIGH (fileinfo) = interface_unknown;\n \t\t    }\n \t\t}\n+#ifdef HANDLE_SYSV_PRAGMA\n+\t      else\n+\t\treturn handle_sysv_pragma (finput, c);\n+#else\n+#ifdef HANDLE_PRAGMA\n+\t      else\n+\t        HANDLE_PRAGMA (finput);\n+#endif\n+#endif\n \t    }\n \t  goto skipline;\n \t}\n@@ -4874,3 +4883,46 @@ yyerror (string)\n \n   error (buf, token_buffer);\n }\n+\f\n+#ifdef HANDLE_SYSV_PRAGMA\n+\n+/* Handle a #pragma directive.  INPUT is the current input stream,\n+   and C is a character to reread.  Processes the entire input line\n+   and returns a character for the caller to reread: either \\n or EOF.  */\n+\n+/* This function has to be in this file, in order to get at\n+   the token types.  */\n+\n+int\n+handle_sysv_pragma (input, c)\n+     FILE *input;\n+     int c;\n+{\n+  for (;;)\n+    {\n+      while (c == ' ' || c == '\\t')\n+\tc = getc (input);\n+      if (c == '\\n' || c == EOF)\n+\t{\n+\t  handle_pragma_token (0, 0);\n+\t  return c;\n+\t}\n+      ungetc (c, input);\n+      switch (yylex ())\n+\t{\n+\tcase IDENTIFIER:\n+\tcase TYPENAME:\n+\tcase STRING:\n+\tcase CONSTANT:\n+\t  handle_pragma_token (token_buffer, yylval.ttype);\n+\t  break;\n+\tdefault:\n+\t  handle_pragma_token (token_buffer, 0);\n+\t}\n+      if (nextchar >= 0)\n+\tc = nextchar, nextchar = -1;\n+      else\n+\tc = getc (input);\n+    }\n+}\n+#endif /* HANDLE_SYSV_PRAGMA */"}, {"sha": "9fb1b37d6cd8a772014d63f322adae658f409ddf", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 79, "deletions": 31, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -167,13 +167,14 @@ empty_parms ()\n %nonassoc IF\n %nonassoc ELSE\n \n-%left IDENTIFIER TYPENAME PTYPENAME SCSPEC TYPESPEC TYPE_QUAL ENUM AGGR ELLIPSIS TYPEOF SIGOF OPERATOR\n+%left IDENTIFIER TYPENAME PTYPENAME SCSPEC TYPESPEC TYPE_QUAL ENUM AGGR ELLIPSIS TYPEOF SIGOF OPERATOR NSNAME\n \n %left '{' ',' ';'\n \n %nonassoc THROW\n+%right <code> ':'\n %right <code> ASSIGN '='\n-%right <code> '?' ':'\n+%right <code> '?'\n %left <code> OROR\n %left <code> ANDAND\n %left <code> '|'\n@@ -228,7 +229,7 @@ empty_parms ()\n %type <ttype> fcast_or_absdcl regcast_or_absdcl sub_cast_expr\n %type <ttype> expr_or_declarator complex_notype_declarator\n %type <ttype> notype_unqualified_id unqualified_id qualified_id\n-%type <ttype> overqualified_id notype_qualified_id\n+%type <ttype> overqualified_id notype_qualified_id any_id\n %type <ttype> complex_direct_notype_declarator functional_cast\n %type <ttype> named_parm complex_parmlist typed_declspecs1 parms_comma\n \n@@ -264,12 +265,16 @@ empty_parms ()\n %type <ttype> complex_type_name nested_name_specifier_1\n %type <itype> nomods_initdecls nomods_initdcl0\n %type <ttype> new_initializer new_placement specialization type_specifier_seq\n+%type <ttype> using_decl\n \n /* in order to recognize aggr tags as defining and thus shadowing. */\n %token TYPENAME_DEFN IDENTIFIER_DEFN PTYPENAME_DEFN\n %type <ttype> named_class_head_sans_basetype_defn \n %type <ttype> identifier_defn IDENTIFIER_DEFN TYPENAME_DEFN PTYPENAME_DEFN\n \n+%token NSNAME\n+%type <ttype> NSNAME\n+\n %type <strtype> .pushlevel\n \n /* spew.c depends on this being the last token.  Define\n@@ -313,6 +318,11 @@ extdefs:\n \t\t{ $<ttype>$ = NULL_TREE; }\n \t;\n \n+extdefs_opt:\n+\t  extdefs\n+\t| /* empty */\n+\t;\n+\n .hush_warning:\n \t\t{ have_extern_spec = 1;\n \t\t  used_extern_spec = 0;\n@@ -345,16 +355,46 @@ extdef:\n \t| asm_keyword '(' string ')' ';'\n \t\t{ if (TREE_CHAIN ($3)) $3 = combine_strings ($3);\n \t\t  assemble_asm ($3); }\n-\t| extern_lang_string '{' extdefs '}'\n-\t\t{ pop_lang_context (); }\n-\t| extern_lang_string '{' '}'\n+\t| extern_lang_string '{' extdefs_opt '}'\n \t\t{ pop_lang_context (); }\n \t| extern_lang_string .hush_warning fndef .warning_ok\n \t\t{ if (pending_inlines) do_pending_inlines ();\n \t\t  pop_lang_context (); }\n \t| extern_lang_string .hush_warning datadef .warning_ok\n \t\t{ if (pending_inlines) do_pending_inlines ();\n \t\t  pop_lang_context (); }\n+\t| NAMESPACE identifier '{'\n+\t\t{ push_namespace ($2); }\n+\t  extdefs_opt '}'\n+\t\t{ pop_namespace (); }\n+\t| NAMESPACE '{'\n+\t\t{ push_namespace (NULL_TREE); }\n+\t  extdefs_opt '}'\n+\t\t{ pop_namespace (); }\n+\t| NAMESPACE identifier '=' any_id ';'\n+\t\t{ do_namespace_alias ($2, $4); }\n+\t| using_decl ';'\n+\t\t{ }\n+\t| USING NAMESPACE any_id ';'\n+\t\t{ do_using_directive ($3); }\n+\t;\n+\n+using_decl:\n+\t  USING qualified_id\n+\t\t{ $$ = do_using_decl ($2); }\n+\t| USING global_scope qualified_id\n+\t\t{ $$ = do_using_decl ($3); }\n+\t| USING global_scope unqualified_id\n+\t\t{ $$ = do_using_decl ($3); }\n+\t;\n+\n+any_id:\n+\t  unqualified_id\n+\t| qualified_id\n+\t| global_scope qualified_id\n+\t\t{ $$ = $2; }\n+\t| global_scope unqualified_id\n+\t\t{ $$ = $2; }\n \t;\n \n extern_lang_string:\n@@ -462,7 +502,7 @@ template_def:\n \t\t  d = start_decl ($<ttype>2, /*current_declspecs*/NULL_TREE, 0,\n \t\t\t\t  $3);\n \t\t  cplus_decl_attributes (d, $5);\n-\t\t  finish_decl (d, NULL_TREE, $4, 0);\n+\t\t  finish_decl (d, NULL_TREE, $4, 0, 0);\n \t\t  end_template_decl ($1, d, 0, def);\n \t\t  if (def)\n \t\t    reinit_parse_for_template ((int) $6, $1, d);\n@@ -481,7 +521,7 @@ template_def:\n \t\t  d = start_decl ($<ttype>3, current_declspecs,\n \t\t\t\t  0, $<ttype>4);\n \t\t  cplus_decl_attributes (d, $6);\n-\t\t  finish_decl (d, NULL_TREE, $5, 0);\n+\t\t  finish_decl (d, NULL_TREE, $5, 0, 0);\n \t\t  end_template_decl ($1, d, 0, def);\n \t\t  if (def)\n \t\t    {\n@@ -495,7 +535,7 @@ template_def:\n \t\t{\n \t\t  int def = ($4 != ';');\n \t\t  tree d = start_decl ($<ttype>3, $<ttype>2, 0, NULL_TREE);\n-\t\t  finish_decl (d, NULL_TREE, NULL_TREE, 0);\n+\t\t  finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n \t\t  end_template_decl ($1, d, 0, def);\n \t\t  if (def)\n \t\t    reinit_parse_for_template ((int) $4, $1, d);\n@@ -521,7 +561,7 @@ datadef:\n \t| declmods notype_declarator ';'\n \t\t{ tree d;\n \t\t  d = start_decl ($<ttype>2, $<ttype>$, 0, NULL_TREE);\n-\t\t  finish_decl (d, NULL_TREE, NULL_TREE, 0);\n+\t\t  finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n \t\t}\n \t| typed_declspecs initdecls ';'\n \t\t{\n@@ -531,7 +571,7 @@ datadef:\n \t| typed_declspecs declarator ';'\n \t\t{ tree d;\n \t\t  d = start_decl ($<ttype>2, $<ttype>$, 0, NULL_TREE);\n-\t\t  finish_decl (d, NULL_TREE, NULL_TREE, 0);\n+\t\t  finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n \t\t  note_list_got_semicolon ($<ttype>$);\n \t\t}\n         | declmods ';'\n@@ -752,11 +792,13 @@ identifier:\n \t  IDENTIFIER\n \t| TYPENAME\n \t| PTYPENAME\n+\t| NSNAME\n \t;\n \n notype_identifier:\n \t  IDENTIFIER\n-\t| PTYPENAME %prec EMPTY\n+\t| PTYPENAME \n+\t| NSNAME %prec EMPTY\n \t;\n \n identifier_defn:\n@@ -939,7 +981,7 @@ condition:\n \t\t}\n \tinit\n \t\t{ \n-\t\t  finish_decl ($<ttype>7, $8, $5, 0);\n+\t\t  finish_decl ($<ttype>7, $8, $5, 0, LOOKUP_ONLYCONVERTING);\n \t\t  resume_momentary ($<itype>6);\n \t\t  $$ = $<ttype>7; \n \t\t  if (TREE_CODE (TREE_TYPE ($$)) == ARRAY_TYPE)\n@@ -1225,7 +1267,7 @@ expr_no_commas:\n \t\t{ $$ = build_m_component_ref ($$, build_x_unary_op ($2, $3)); }\n \t| object '(' type_id ')' expr_no_commas  %prec UNARY\n \t\t{ tree type = groktypename ($3);\n-\t\t  $$ = build_m_component_ref ($$, build_c_cast (type, $5)); }\n+\t\t  $$ = build_m_component_ref ($$, build_c_cast (type, $5, 0)); }\n \t| object primary_no_id  %prec UNARY\n \t\t{ $$ = build_m_component_ref ($$, $2); }\n */\n@@ -1236,7 +1278,8 @@ notype_unqualified_id:\n \t\t{ $$ = build_parse_node (BIT_NOT_EXPR, $3); }\n \t| operator_name\n \t| IDENTIFIER\n-\t| PTYPENAME %prec EMPTY\n+\t| PTYPENAME\n+\t| NSNAME %prec EMPTY\n \t;\n \n unqualified_id:\n@@ -1421,7 +1464,7 @@ primary:\n \t\t        }\n #endif\n \t\t      else my_friendly_abort (79);\n-\t\t      $$ = build_c_cast (type, build_compound_expr ($3));\n+\t\t      $$ = build_c_cast (type, build_compound_expr ($3), 1);\n \t\t    }\n \t\t}\n \t| functional_cast\n@@ -1659,7 +1702,7 @@ decl:\n \t\t{ tree d = get_decl_list ($1);\n \t\t  int yes = suspend_momentary ();\n \t\t  d = start_decl ($2, d, 0, NULL_TREE);\n-\t\t  finish_decl (d, NULL_TREE, NULL_TREE, 0);\n+\t\t  finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n \t\t  resume_momentary (yes);\n \t\t  if (IS_AGGR_TYPE_CODE (TREE_CODE ($1)))\n \t\t    note_got_semicolon ($1);\n@@ -1668,7 +1711,7 @@ decl:\n \t\t{ tree d = $1;\n \t\t  int yes = suspend_momentary ();\n \t\t  d = start_decl ($2, d, 0, NULL_TREE);\n-\t\t  finish_decl (d, NULL_TREE, NULL_TREE, 0);\n+\t\t  finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);\n \t\t  resume_momentary (yes);\n \t\t  note_list_got_semicolon ($1);\n \t\t}\n@@ -1899,7 +1942,7 @@ initdcl0:\n \t\t  cplus_decl_attributes ($<ttype>$, $4); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ finish_decl ($<ttype>6, $7, $3, 0);\n+\t\t{ finish_decl ($<ttype>6, $7, $3, 0, LOOKUP_ONLYCONVERTING);\n \t\t  $$ = $<itype>5; }\n \t| declarator maybe_raises maybeasm maybe_attribute\n \t\t{ tree d;\n@@ -1916,7 +1959,7 @@ initdcl0:\n \t\t  $$ = suspend_momentary ();\n \t\t  d = start_decl ($<ttype>1, current_declspecs, 0, $2);\n \t\t  cplus_decl_attributes (d, $4);\n-\t\t  finish_decl (d, NULL_TREE, $3, 0); }\n+\t\t  finish_decl (d, NULL_TREE, $3, 0, 0); }\n \t;\n \n initdcl:\n@@ -1925,11 +1968,11 @@ initdcl:\n \t\t  cplus_decl_attributes ($<ttype>$, $4); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ finish_decl ($<ttype>6, $7, $3, 0); }\n+\t\t{ finish_decl ($<ttype>6, $7, $3, 0, LOOKUP_ONLYCONVERTING); }\n \t| declarator maybe_raises maybeasm maybe_attribute\n \t\t{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 0, $2);\n \t\t  cplus_decl_attributes ($<ttype>$, $4);\n-\t\t  finish_decl ($<ttype>$, NULL_TREE, $3, 0); }\n+\t\t  finish_decl ($<ttype>$, NULL_TREE, $3, 0, 0); }\n \t;\n \n notype_initdcl0:\n@@ -1940,15 +1983,15 @@ notype_initdcl0:\n \t\t  cplus_decl_attributes ($<ttype>$, $4); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ finish_decl ($<ttype>6, $7, $3, 0);\n+\t\t{ finish_decl ($<ttype>6, $7, $3, 0, LOOKUP_ONLYCONVERTING);\n \t\t  $$ = $<itype>5; }\n \t| notype_declarator maybe_raises maybeasm maybe_attribute\n \t\t{ tree d;\n \t\t  current_declspecs = $<ttype>0;\n \t\t  $$ = suspend_momentary ();\n \t\t  d = start_decl ($<ttype>1, current_declspecs, 0, $2);\n \t\t  cplus_decl_attributes (d, $4);\n-\t\t  finish_decl (d, NULL_TREE, $3, 0); }\n+\t\t  finish_decl (d, NULL_TREE, $3, 0, 0); }\n \t;\n \n nomods_initdcl0:\n@@ -1959,15 +2002,15 @@ nomods_initdcl0:\n \t\t  cplus_decl_attributes ($<ttype>$, $4); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ finish_decl ($<ttype>6, $7, $3, 0);\n+\t\t{ finish_decl ($<ttype>6, $7, $3, 0, LOOKUP_ONLYCONVERTING);\n \t\t  $$ = $<itype>5; }\n \t| notype_declarator maybe_raises maybeasm maybe_attribute\n \t\t{ tree d;\n \t\t  current_declspecs = NULL_TREE;\n \t\t  $$ = suspend_momentary ();\n \t\t  d = start_decl ($1, current_declspecs, 0, $2);\n \t\t  cplus_decl_attributes (d, $4);\n-\t\t  finish_decl (d, NULL_TREE, $3, 0); }\n+\t\t  finish_decl (d, NULL_TREE, $3, 0, 0); }\n \t;\n \n /* the * rules are dummies to accept the Apollo extended syntax\n@@ -2569,6 +2612,7 @@ component_decl_1:\n \t\t\t\t\t empty_parms (), $3);\n \t\t  $$ = grokfield ($$, TREE_CHAIN ($1), NULL_TREE, NULL_TREE,\n \t\t\t\t  NULL_TREE); }\n+\t| using_decl\n \t;\n \n /* The case of exactly one component is handled directly by component_decl. */\n@@ -2887,6 +2931,8 @@ nested_name_specifier:\n nested_name_specifier_1:\n \t  TYPENAME SCOPE\n \t\t{ got_scope = TREE_TYPE ($$); }\n+\t| NSNAME SCOPE\n+\t\t{ got_scope = TREE_TYPE ($$); }\n \t| template_type SCOPE\n \t\t{ got_scope = TREE_TYPE ($$); }\n /* \tThese break 'const i;'\n@@ -3681,13 +3727,13 @@ try_for_typename:\n bad_parm:\n \t  /* empty */ %prec EMPTY\n \t\t{\n-\t\t  warning (\"type specifier omitted for parameter\");\n-\t\t  $$ = build_tree_list (TREE_PURPOSE (TREE_VALUE ($<ttype>-1)), NULL_TREE);\n+\t\t  error (\"type specifier omitted for parameter\");\n+\t\t  $$ = build_tree_list (integer_type_node, NULL_TREE);\n \t\t}\n \t| notype_declarator\n \t\t{\n-\t\t  warning (\"type specifier omitted for parameter\");\n-\t\t  $$ = build_tree_list (TREE_PURPOSE (TREE_VALUE ($<ttype>-1)), $$);\n+\t\t  error (\"type specifier omitted for parameter\");\n+\t\t  $$ = build_tree_list (integer_type_node, $$);\n \t\t}\n \t;\n \n@@ -3696,11 +3742,13 @@ maybe_raises:\n \t\t{ $$ = NULL_TREE; }\n \t| THROW '(' ansi_raise_identifiers  ')' %prec EMPTY\n \t\t{ $$ = $3; }\n+\t| THROW LEFT_RIGHT %prec EMPTY\n+\t\t{ $$ = build_decl_list (NULL_TREE, NULL_TREE); }\n \t;\n \n ansi_raise_identifier:\n \t  type_id\n-\t\t{ $$ = build_decl_list (NULL_TREE, $$); }\n+\t\t{ $$ = build_decl_list (NULL_TREE, groktypename($$)); }\n \t;\n \n ansi_raise_identifiers:"}, {"sha": "eab4e109f931ae418e73bd70da4ac2d78264d951", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -2303,8 +2303,9 @@ do_pending_expansions ()\n       else if (! flag_implicit_templates)\n \tDECIDE (0);\n \n-      /* OK, it was an implicit instantiation.  */\n-      TREE_PUBLIC (t) = 0;\n+      if (i->interface == 1)\n+\t/* OK, it was an implicit instantiation.  */\n+\tTREE_PUBLIC (t) = 0;\n \n       /* If it's a method, let the class type decide it.\n \t @@ What if the method template is in a separate file?"}, {"sha": "82583c73692c54afb76e70dd63eecbc206b5b0ac", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -1503,24 +1503,13 @@ build_exception_variant (ctype, type, raises)\n \t  || TYPE_VOLATILE (v) != volatilep)\n \tcontinue;\n \n-      t = raises;\n-      t2 = TYPE_RAISES_EXCEPTIONS (v);\n-      while (t && t2)\n-\t{\n-\t  if (TREE_TYPE (t) == TREE_TYPE (t2))\n-\t    {\n-\t      t = TREE_CHAIN (t);\n-\t      t2 = TREE_CHAIN (t2);\n-\t    }\n-\t  else break;\n-\t}\n-      if (t || t2)\n-\tcontinue;\n-      /* List of exceptions raised matches previously found list.\n+      /* @@ This should do set equality, not exact match. */\n+      if (simple_cst_list_equal (TYPE_RAISES_EXCEPTIONS (v), raises))\n+\t/* List of exceptions raised matches previously found list.\n \n-         @@ Nice to free up storage used in consing up the\n-\t @@ list of exceptions raised.  */\n-      return v;\n+\t   @@ Nice to free up storage used in consing up the\n+\t   @@ list of exceptions raised.  */\n+\treturn v;\n     }\n \n   /* Need to build a new variant.  */"}, {"sha": "90ea075a2354ebb03c49ee7213b6a1d37e7ee9f8", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -2162,7 +2162,7 @@ build_x_function_call (function, params, decl)\n \t  decl = convert_pointer_to (TREE_TYPE (ctypeptr), decl);\n \t}\n       else\n-\tdecl = build_c_cast (ctypeptr, decl);\n+\tdecl = build_c_cast (ctypeptr, decl, 0);\n       params = tree_cons (NULL_TREE, decl, params);\n     }\n \n@@ -2370,8 +2370,6 @@ build_function_call_real (function, params, require_complete, flags)\n \t     function, coerced_params, NULL_TREE);\n \n     TREE_SIDE_EFFECTS (result) = 1;\n-    /* Remove this sometime. */\n-    TREE_RAISES (result) |= !! TYPE_RAISES_EXCEPTIONS (fntype);\n     if (! require_complete)\n       return result;\n     if (value_type == void_type_node)\n@@ -2427,7 +2425,6 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n   register tree typetail, valtail;\n   register tree result = NULL_TREE;\n   char *called_thing;\n-  int maybe_raises = 0;\n   int i = 0;\n \n   if (! flag_elide_constructors)\n@@ -2541,8 +2538,6 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n       if (val == error_mark_node)\n \tcontinue;\n \n-      maybe_raises |= TREE_RAISES (val);\n-\n       if (type != 0)\n \t{\n \t  /* Formal parm type is specified by a function prototype.  */\n@@ -2648,7 +2643,6 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t\t    parmval = default_conversion (parmval);\n #endif\n \t\t}\n-\t      maybe_raises |= TREE_RAISES (parmval);\n \n \t      if (flag_gc\n \t\t  && type_needs_gc_entry (TREE_TYPE (parmval))\n@@ -2676,8 +2670,6 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t  return error_mark_list;\n \t}\n     }\n-  if (result)\n-    TREE_RAISES (result) = maybe_raises;\n \n   return nreverse (result);\n }\n@@ -2733,14 +2725,13 @@ build_binary_op (code, arg1, arg2, convert_p)\n       type1 = TREE_TYPE (args[0]);\n       type2 = TREE_TYPE (args[1]);\n \n-      if (IS_AGGR_TYPE_2 (type1, type2) && ! TYPE_PTRMEMFUNC_P (type1))\n+      if (IS_AGGR_TYPE_2 (type1, type2))\n \t{\n \t  /* Try to convert this to something reasonable.  */\n \t  if (! build_default_binary_type_conversion(code, &args[0], &args[1]))\n \t    return error_mark_node;\n \t}\n-      else if ((IS_AGGR_TYPE (type1) && ! TYPE_PTRMEMFUNC_P (type1))\n-\t       || (IS_AGGR_TYPE (type2) && ! TYPE_PTRMEMFUNC_P (type2)))\n+      else if (IS_AGGR_TYPE (type1) || IS_AGGR_TYPE (type2))\n \t{\n \t  int convert_index = IS_AGGR_TYPE (type2);\n \t  /* Avoid being tripped up by things like (ARG1 != 0).  */\n@@ -3735,7 +3726,7 @@ build_component_addr (arg, argtype, msg)\n     }\n   else\n     /* This conversion is harmless.  */\n-    rval = convert_force (argtype, rval);\n+    rval = convert_force (argtype, rval, 0);\n \n   if (! integer_zerop (DECL_FIELD_BITPOS (field)))\n     {\n@@ -4871,27 +4862,31 @@ build_compound_expr (list)\n tree build_static_cast (type, expr)\n    tree type, expr;\n {\n-  return build_c_cast (type, expr);\n+  return build_c_cast (type, expr, 0);\n }\n \n tree build_reinterpret_cast (type, expr)\n    tree type, expr;\n {\n-  return build_c_cast (type, expr);\n+  return build_c_cast (type, expr, 0);\n }\n \n tree build_const_cast (type, expr)\n    tree type, expr;\n {\n-  return build_c_cast (type, expr);\n+  return build_c_cast (type, expr, 0);\n }\n \n-/* Build an expression representing a cast to type TYPE of expression EXPR.  */\n+/* Build an expression representing a cast to type TYPE of expression EXPR.\n+\n+   ALLOW_NONCONVERTING is true if we should allow non-converting constructors\n+   when doing the cast.  */\n \n tree\n-build_c_cast (type, expr)\n+build_c_cast (type, expr, allow_nonconverting)\n      register tree type;\n      tree expr;\n+     int allow_nonconverting;\n {\n   register tree value = expr;\n \n@@ -5014,7 +5009,7 @@ build_c_cast (type, expr)\n \tvalue = decl_constant_value (value);\n \n       ovalue = value;\n-      value = convert_force (type, value);\n+      value = convert_force (type, value, allow_nonconverting?CONV_NONCONVERTING:0);\n \n       /* Ignore any integer overflow caused by the cast.  */\n       if (TREE_CODE (value) == INTEGER_CST)\n@@ -5848,7 +5843,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \t{\n \t  newrhs = convert_for_assignment (olhstype, newrhs, \"assignment\",\n \t\t\t\t\t   NULL_TREE, 0);\n-\t  newrhs = convert_force (lhstype, newrhs);\n+\t  newrhs = convert_force (lhstype, newrhs, 0);\n \t}\n       else\n \tnewrhs = convert_for_assignment (lhstype, newrhs, \"assignment\",\n@@ -6121,7 +6116,7 @@ build_ptrmemfunc (type, pfn, force)\n   /* Handle null pointer to member function conversions. */\n   if (integer_zerop (pfn))\n     {\n-      pfn = build_c_cast (type, integer_zero_node);\n+      pfn = build_c_cast (type, integer_zero_node, 0);\n       u = build_nt (CONSTRUCTOR, 0, tree_cons (pfn_identifier, pfn, NULL_TREE));\n       u = build_nt (CONSTRUCTOR, 0, tree_cons (NULL_TREE, integer_zero_node,\n \t\t\t\t\t       tree_cons (NULL_TREE, integer_zero_node,\n@@ -6299,11 +6294,11 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n     }\n   /* Conversions involving enums.  */\n   else if ((codel == ENUMERAL_TYPE\n-\t    && (coder == ENUMERAL_TYPE || coder == INTEGER_TYPE || coder == REAL_TYPE))\n+\t    && (INTEGRAL_CODE_P (coder) || coder == REAL_TYPE))\n \t   || (coder == ENUMERAL_TYPE\n-\t       && (codel == ENUMERAL_TYPE || codel == INTEGER_TYPE || codel == REAL_TYPE)))\n+\t       && (INTEGRAL_CODE_P (codel) || codel == REAL_TYPE)))\n     {\n-      return convert (type, rhs);\n+      return cp_convert (type, rhs, CONV_IMPLICIT, 0);\n     }\n   /* Conversions among pointers */\n   else if (codel == POINTER_TYPE\n@@ -7065,7 +7060,7 @@ c_expand_return (retval)\n       if (TREE_CODE (retval) == WITH_CLEANUP_EXPR\n \t  && TREE_CODE (TREE_OPERAND (retval, 0)) == TARGET_EXPR)\n \tretval = TREE_OPERAND (retval, 0);\n-      expand_aggr_init (result, retval, 0);\n+      expand_aggr_init (result, retval, 0, LOOKUP_ONLYCONVERTING);\n       expand_cleanups_to (NULL_TREE);\n       DECL_INITIAL (result) = NULL_TREE;\n       retval = 0;"}, {"sha": "e5e9c8ea1cda89fc6355933d6c23f6474639a510", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6060a79633cdde2801b51dbef337d0ce675b9950/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=6060a79633cdde2801b51dbef337d0ce675b9950", "patch": "@@ -329,7 +329,7 @@ ack (s, v, v2)\n    silly.  So instead, we just do the equivalent of a call to fatal in the\n    same situation (call exit).  */\n \n-/* First used: 0 (reserved), Last used: 361.  Free: */\n+/* First used: 0 (reserved), Last used: 363.  Free: */\n \n static int abortcount = 0;\n \n@@ -1430,7 +1430,7 @@ build_functional_cast (exp, parms)\n \t  pedwarn (\"initializer list being treated as compound expression\");\n \t  parms = build_compound_expr (parms);\n \t}\n-      return build_c_cast (type, parms);\n+      return build_c_cast (type, parms, 1);\n     }\n \n   if (TYPE_SIZE (type) == NULL_TREE)\n@@ -1440,7 +1440,7 @@ build_functional_cast (exp, parms)\n     }\n \n   if (parms && TREE_CHAIN (parms) == NULL_TREE)\n-    return build_c_cast (type, parms);\n+    return build_c_cast (type, parms, 1);\n \n   expr_as_ctor = build_method_call (NULL_TREE, name, parms,\n \t\t\t\t    NULL_TREE, LOOKUP_NORMAL);"}]}