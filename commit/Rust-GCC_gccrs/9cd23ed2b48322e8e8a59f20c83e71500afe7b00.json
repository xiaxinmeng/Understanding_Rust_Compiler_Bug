{"sha": "9cd23ed2b48322e8e8a59f20c83e71500afe7b00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNkMjNlZDJiNDgzMjJlOGU4YTU5ZjIwYzgzZTcxNTAwYWZlN2IwMA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2003-06-22T09:04:57Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2003-06-22T09:04:57Z"}, "message": "opts.c (find_opt): Fix to always guarantee a find of a switch with joined parameter.\n\n\t* opts.c (find_opt): Fix to always guarantee a find of a\n\tswitch with joined parameter.\n\t* opts.h (struct cl_option): New member back_chain.\n\t* opts.sh: Update to calculate and add back_chain member.\n\nFrom-SVN: r68324", "tree": {"sha": "2785029799589d4a21de52b61fca6dea41dbd6a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2785029799589d4a21de52b61fca6dea41dbd6a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cd23ed2b48322e8e8a59f20c83e71500afe7b00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cd23ed2b48322e8e8a59f20c83e71500afe7b00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cd23ed2b48322e8e8a59f20c83e71500afe7b00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cd23ed2b48322e8e8a59f20c83e71500afe7b00/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0e9e3a8b78c5e8f59542d62945ec227fab3e8afd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e9e3a8b78c5e8f59542d62945ec227fab3e8afd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e9e3a8b78c5e8f59542d62945ec227fab3e8afd"}], "stats": {"total": 160, "additions": 92, "deletions": 68}, "files": [{"sha": "3df66fbbd969da4e45dde25d729fce88b1989ab8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd23ed2b48322e8e8a59f20c83e71500afe7b00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd23ed2b48322e8e8a59f20c83e71500afe7b00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9cd23ed2b48322e8e8a59f20c83e71500afe7b00", "patch": "@@ -1,3 +1,10 @@\n+2003-06-22  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* opts.c (find_opt): Fix to always guarantee a find of a\n+\tswitch with joined parameter.\n+\t* opts.h (struct cl_option): New member back_chain.\n+\t* opts.sh: Update to calculate and add back_chain member.\n+\n 2003-06-22  Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n \t* diagnostic.h (output_host_wide_integer): Declare."}, {"sha": "22c518432ec587982558e1d1a5c2e9c9cccd055a", "filename": "gcc/opts.c", "status": "modified", "additions": 59, "deletions": 65, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd23ed2b48322e8e8a59f20c83e71500afe7b00/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd23ed2b48322e8e8a59f20c83e71500afe7b00/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=9cd23ed2b48322e8e8a59f20c83e71500afe7b00", "patch": "@@ -131,93 +131,87 @@ static void handle_param (const char *);\n static void set_Wextra (int);\n \n /* Perform a binary search to find which option the command-line INPUT\n-   matches.  Returns its index in the option array, and N_OPTS on\n-   failure.\n-\n-   Complications arise since some options can be suffixed with an\n-   argument, and multiple complete matches can occur, e.g. -pedantic\n-   and -pedantic-errors.  Also, some options are only accepted by some\n-   languages.  If a switch matches for a different language and\n-   doesn't match any alternatives for the true front end, the index of\n-   the matched switch is returned anyway.  The caller should check for\n-   this case.  */\n+   matches.  Returns its index in the option array, and N_OPTS\n+   (cl_options_count) on failure.\n+\n+   This routine is quite subtle.  A normal binary search is not good\n+   enough because some options can be suffixed with an argument, and\n+   multiple sub-matches can occur, e.g. input of \"-pedantic\" matching\n+   the initial substring of \"-pedantic-errors\".\n+\n+   A more complicated example is -gstabs.  It should match \"-g\" with\n+   an argument of \"stabs\".  Suppose, however, that the number and list\n+   of switches are such that the binary search tests \"-gen-decls\"\n+   before having tested \"-g\".  This doesn't match, and as \"-gen-decls\"\n+   is less than \"-gstabs\", it will become the lower bound of the\n+   binary search range, and \"-g\" will never be seen.  To resolve this\n+   issue, opts.sh makes \"-gen-decls\" point, via the back_chain member,\n+   to \"-g\" so that failed searches that end between \"-gen-decls\" and\n+   the lexicographically subsequent switch know to go back and see if\n+   \"-g\" causes a match (which it does in this example).\n+\n+   This search is done in such a way that the longest match for the\n+   front end in question wins.  If there is no match for the current\n+   front end, the longest match for a different front end is returned\n+   (or N_OPTS if none) and the caller emits an error message.  */\n static size_t\n find_opt (const char *input, int lang_mask)\n {\n-  size_t md, mn, mx;\n-  size_t opt_len;\n-  size_t result = cl_options_count;\n+  size_t mn, mx, md, opt_len;\n+  size_t match_wrong_lang;\n   int comp;\n \n   mn = 0;\n   mx = cl_options_count;\n \n-  while (mx > mn)\n+  /* Find mn such this lexicographical inequality holds:\n+     cl_options[mn] <= input < cl_options[mn + 1].  */\n+  while (mx - mn > 1)\n     {\n       md = (mn + mx) / 2;\n-\n       opt_len = cl_options[md].opt_len;\n       comp = strncmp (input, cl_options[md].opt_text, opt_len);\n \n       if (comp < 0)\n \tmx = md;\n-      else if (comp > 0)\n-\tmn = md + 1;\n       else\n-\t{\n-\t  /* The switch matches.  It it an exact match?  */\n-\t  if (input[opt_len] == '\\0')\n-\t    return md;\n-\t  else\n-\t    {\n-\t      mn = md + 1;\n-\n-\t      /* If the switch takes no arguments this is not a proper\n-\t\t match, so we continue the search (e.g. input=\"stdc++\"\n-\t\t match was \"stdc\").  */\n-\t      if (!(cl_options[md].flags & CL_JOINED))\n-\t\tcontinue;\n-\n-\t      /* Is this switch valid for this front end?  */\n-\t      if (!(cl_options[md].flags & lang_mask))\n-\t\t{\n-\t\t  /* If subsequently we don't find a better match,\n-\t\t     return this and let the caller report it as a bad\n-\t\t     match.  */\n-\t\t  result = md;\n-\t\t  continue;\n-\t\t}\n+\tmn = md;\n+    }\n \n-\t      /* Two scenarios remain: we have the switch's argument,\n-\t\t or we match a longer option.  This can happen with\n-\t\t -iwithprefix and -withprefixbefore.  The longest\n-\t\t possible option match succeeds.\n+  /* This is the switch that is the best match but for a different\n+     front end, or cl_options_count if there is no match at all.  */\n+  match_wrong_lang = cl_options_count;\n \n-\t\t Scan forwards, and return an exact match.  Otherwise\n-\t\t return the longest valid option-accepting match (mx).\n-\t\t This loops at most twice with current options.  */\n-\t      mx = md;\n-\t      for (md = md + 1; md < cl_options_count; md++)\n-\t\t{\n-\t\t  opt_len = cl_options[md].opt_len;\n-\t\t  comp = strncmp (input, cl_options[md].opt_text, opt_len);\n-\t\t  if (comp < 0)\n-\t\t    break;\n-\t\t  if (comp > 0)\n-\t\t    continue;\n-\t\t  if (input[opt_len] == '\\0')\n-\t\t    return md;\n-\t\t  if (cl_options[md].flags & lang_mask\n-\t\t      && cl_options[md].flags & CL_JOINED)\n-\t\t    mx = md;\n-\t\t}\n+  /* Backtrace the chain of possible matches, returning the longest\n+     one, if any, that fits best.  With current GCC switches, this\n+     loop executes at most twice.  */\n+  do\n+    {\n+      const struct cl_option *opt = &cl_options[mn];\n \n-\t      return mx;\n-\t    }\n+      /* Is this switch a prefix of the input?  */\n+      if (!strncmp (input, opt->opt_text, opt->opt_len))\n+\t{\n+\t  /* If language is OK, and the match is exact or the switch\n+\t     takes a joined argument, return it.  */\n+\t  if ((opt->flags & lang_mask)\n+\t      && (input[opt->opt_len] == '\\0' || (opt->flags & CL_JOINED)))\n+\t    return mn;\n+\n+\t  /* If we haven't remembered a prior match, remember this\n+\t     one.  Any prior match is necessarily better.  */\n+\t  if (match_wrong_lang != cl_options_count)\n+\t    match_wrong_lang = mn;\n \t}\n+\n+      /* Try the next possibility.  This is cl_options_count if there\n+\t are no more.  */\n+      mn = opt->back_chain;\n     }\n+  while (mn != cl_options_count);\n \n-  return result;\n+  /* Return the best wrong match, or cl_options_count if none.  */\n+  return match_wrong_lang;\n }\n \n /* If ARG is a non-negative integer made up solely of digits, return its"}, {"sha": "f5e7cfda34dd3906d0afe1438cc48663ddcaa8ef", "filename": "gcc/opts.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd23ed2b48322e8e8a59f20c83e71500afe7b00/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd23ed2b48322e8e8a59f20c83e71500afe7b00/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=9cd23ed2b48322e8e8a59f20c83e71500afe7b00", "patch": "@@ -26,6 +26,7 @@ extern int handle_option (int argc, char **argv, int lang_mask);\n struct cl_option\n {\n   const char *opt_text;\n+  unsigned short back_chain;\n   unsigned char opt_len;\n   unsigned int flags;\n };"}, {"sha": "07eb1fe1db6319f88d1106d7a8c4ed061fa02442", "filename": "gcc/opts.sh", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd23ed2b48322e8e8a59f20c83e71500afe7b00/gcc%2Fopts.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd23ed2b48322e8e8a59f20c83e71500afe7b00/gcc%2Fopts.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.sh?ref=9cd23ed2b48322e8e8a59f20c83e71500afe7b00", "patch": "@@ -100,21 +100,43 @@ ${AWK} '\n \tprint \"const unsigned int cl_options_count = N_OPTS;\\n\" >> c_file\n \tprint \"const struct cl_option cl_options[] =\\n{\" >> c_file\n \n+\tfor (i = 0; i < n_opts; i++)\n+\t    back_chain[i] = \"N_OPTS\";\n+\n \tfor (i = 0; i < n_opts; i++) {\n+\t    # Combine the flags of identical switches.  Switches\n+\t    # appear many times if they are handled by many front\n+\t    # ends, for example.\n \t    while( i + 1 != n_opts && opts[i] == opts[i + 1] ) {\n \t\tflags[i + 1] = flags[i] \" \" flags[i + 1];\n \t\ti++;\n \t    }\n \n+\t    len = length (opts[i]);\n \t    enum = \"OPT_\" opts[i]\n-\t    gsub( \"[^A-Za-z0-9]\", \"_\", enum)\n+\t    gsub (\"[^A-Za-z0-9]\", \"_\", enum)\n+\n+\t    # If this switch takes joined arguments, back-chain all\n+\t    # subsequent switches to it for which it is a prefix.  If\n+\t    # a later switch S is a longer prefix of a switch T, T\n+\t    # will be back-chained to S in a later iteration of this\n+\t    # for() loop, which is what we want.\n+\t    if (flags[i] ~ \"Joined\") {\n+\t\tfor (j = i + 1; j < n_opts; j++) {\n+\t\t    if (substr (opts[j], 1, len) != opts[i])\n+\t\t\tbreak;\n+\t\t    back_chain[j] = enum;\n+\t\t}\n+\t    }\n+\n \t    s = substr(\"                                  \", length (opts[i]))\n \t    if (i + 1 == n_opts)\n \t\tcomma = \"\"\n \n \t    printf(\"  %s,%s/* -%s */\\n\", enum, s, opts[i]) >> h_file\n-\t    printf(\"  { \\\"%s\\\", %u, %s }%s\\n\", opts[i], \\\n-\t\tlength(opts[i]), switch_flags(flags[i]), comma) >> c_file\n+\t    printf(\"  { \\\"%s\\\", (unsigned short) %s, %u,\\n\\t%s }%s\\n\",\n+\t\t   opts[i], back_chain[i], len, switch_flags(flags[i]),\n+\t\t   comma) >> c_file\n \t}\n \n \tprint \"  N_OPTS\\n};\"\t\t\t\t>> h_file"}]}