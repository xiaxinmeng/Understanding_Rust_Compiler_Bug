{"sha": "e600df51a15b2ec7a72731921a2464ffe59cf5ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYwMGRmNTFhMTViMmVjN2E3MjczMTkyMWEyNDY0ZmZlNTljZjVhYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-04-27T13:26:24Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-04-27T13:27:14Z"}, "message": "cfgcleanup: Fix -fcompare-debug issue in outgoing_edges_match [PR100254]\n\nThe following testcase fails with -fcompare-debug.  The problem is that\noutgoing_edges_match behaves differently between -g0 and -g, if\nsome load/store with REG_EH_REGION is followed by DEBUG_INSNs, the\nREG_EH_REGION check is not done, while when there are no DEBUG_INSNs, it is\ndone.\n\nWe already compute last1 and last2 as BB_END (bb{1,2}) with skipped debug\ninsns and notes, so this patch just uses those.\n\n2021-04-27  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR rtl-optimization/100254\n\t* cfgcleanup.c (outgoing_edges_match): Check REG_EH_REGION on\n\tlast1 and last2 insns rather than BB_END (bb1) and BB_END (bb2) insns.\n\n\t* g++.dg/opt/pr100254.C: New test.", "tree": {"sha": "fb77f6cffc86abe7d9fa17a9191eeed7725cafa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb77f6cffc86abe7d9fa17a9191eeed7725cafa1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e600df51a15b2ec7a72731921a2464ffe59cf5ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e600df51a15b2ec7a72731921a2464ffe59cf5ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e600df51a15b2ec7a72731921a2464ffe59cf5ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e600df51a15b2ec7a72731921a2464ffe59cf5ab/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d4c374c4419a8751cfae18d6b58169c62dea49f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d4c374c4419a8751cfae18d6b58169c62dea49f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d4c374c4419a8751cfae18d6b58169c62dea49f"}], "stats": {"total": 105, "additions": 103, "deletions": 2}, "files": [{"sha": "260a896ac48638861aefceebee9fd2b2b0542512", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e600df51a15b2ec7a72731921a2464ffe59cf5ab/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e600df51a15b2ec7a72731921a2464ffe59cf5ab/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=e600df51a15b2ec7a72731921a2464ffe59cf5ab", "patch": "@@ -1885,8 +1885,8 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \n   /* Ensure the same EH region.  */\n   {\n-    rtx n1 = find_reg_note (BB_END (bb1), REG_EH_REGION, 0);\n-    rtx n2 = find_reg_note (BB_END (bb2), REG_EH_REGION, 0);\n+    rtx n1 = find_reg_note (last1, REG_EH_REGION, 0);\n+    rtx n2 = find_reg_note (last2, REG_EH_REGION, 0);\n \n     if (!n1 && n2)\n       return false;"}, {"sha": "dbdac1638c7fdd5203b0afcd69b5fda0421f4803", "filename": "gcc/testsuite/g++.dg/opt/pr100254.C", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e600df51a15b2ec7a72731921a2464ffe59cf5ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr100254.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e600df51a15b2ec7a72731921a2464ffe59cf5ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr100254.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr100254.C?ref=e600df51a15b2ec7a72731921a2464ffe59cf5ab", "patch": "@@ -0,0 +1,101 @@\n+// PR rtl-optimization/100254\n+// { dg-do compile }\n+// { dg-options \"-O2 -fno-guess-branch-probability -fipa-pta -fnon-call-exceptions -fcompare-debug\" }\n+// { dg-additional-options \"-mtune=goldmont\" { target i?86-*-* x86_64-*-* } }\n+\n+struct _Rb_tree_node_base {\n+  typedef _Rb_tree_node_base *_Base_ptr;\n+  typedef _Rb_tree_node_base *_Const_Base_ptr;\n+  _Base_ptr _M_left;\n+};\n+template <typename _Key_compare> struct _Rb_tree_key_compare {\n+  _Key_compare _M_key_compare;\n+};\n+struct _Rb_tree_header {\n+  _Rb_tree_node_base _M_header;\n+};\n+struct _Rb_tree_iterator {\n+  _Rb_tree_iterator(_Rb_tree_node_base::_Base_ptr);\n+  friend bool operator==(_Rb_tree_iterator, _Rb_tree_iterator);\n+};\n+template <typename _Tp> struct _Rb_tree_const_iterator {\n+  typedef _Rb_tree_const_iterator _Self;\n+  _Rb_tree_const_iterator(_Rb_tree_node_base::_Const_Base_ptr) {}\n+  _Tp operator*();\n+  template <typename _Up>\n+  friend bool operator!=(_Rb_tree_const_iterator<_Up>, _Rb_tree_const_iterator<_Up>);\n+};\n+template <typename _Key, typename _Val, typename _Compare> struct _Rb_tree {\n+  template <typename _Key_compare>\n+  struct _Rb_tree_impl : _Rb_tree_key_compare<_Key_compare>, _Rb_tree_header {};\n+  _Rb_tree_impl<_Compare> _M_impl;\n+  _Key _S_key();\n+  typedef _Rb_tree_const_iterator<_Val> const_iterator;\n+  const_iterator begin() { return _M_impl._M_header._M_left; }\n+  _Rb_tree_iterator find(const _Key &);\n+};\n+template <typename _Key, typename _Val, typename _Compare>\n+_Rb_tree_iterator _Rb_tree<_Key, _Val, _Compare>::find(const _Key &__k) {\n+  _Rb_tree_iterator __j = 0;\n+  return __j == 0 || _M_impl._M_key_compare(__k, _S_key()) ? 0 : __j;\n+}\n+template <typename _Key, typename _Compare = _Key> struct set {\n+  typedef _Key key_type;\n+  typedef _Rb_tree<key_type, _Key, _Compare> _Rep_type;\n+  _Rep_type _M_t;\n+  typedef typename _Rep_type::const_iterator iterator;\n+  iterator begin() { return _M_t.begin(); }\n+  iterator end();\n+  void find(key_type __x) { _M_t.find(__x); }\n+};\n+struct WindowDesc {\n+  WindowDesc(short);\n+} _station_view_desc(0);\n+struct Window {\n+  void IsWidgetLowered();\n+  virtual void OnClick(int, int, int);\n+};\n+int AllocateWindowDescFront_window_number;\n+template <typename Wcls> void AllocateWindowDescFront(WindowDesc *desc, bool) {\n+  Wcls(desc, AllocateWindowDescFront_window_number);\n+}\n+class CargoDataEntry;\n+struct CargoSorter {\n+  bool operator()(const CargoDataEntry *, const CargoDataEntry *) const;\n+};\n+struct CargoDataEntry {\n+  ~CargoDataEntry();\n+  char Retrieve_cargo;\n+  void Retrieve() {\n+    CargoDataEntry t(Retrieve_cargo);\n+    children->find(&t);\n+  }\n+  CargoDataEntry(char);\n+  set<CargoDataEntry *, CargoSorter> *children;\n+};\n+CargoDataEntry::CargoDataEntry(char) : children() {}\n+CargoDataEntry::~CargoDataEntry() {\n+  if (children)\n+    for (set<CargoDataEntry *>::iterator i = children->begin();\n+         i != children->end();)\n+      delete *i;\n+}\n+bool CargoSorter::operator()(const CargoDataEntry *,\n+                             const CargoDataEntry *) const { return false; }\n+struct StationViewWindow : Window {\n+  StationViewWindow(WindowDesc *, int);\n+  CargoDataEntry HandleCargoWaitingClick_filter;\n+  void OnClick(int, int widget, int) {\n+    switch (widget) {\n+    case 0:\n+      HandleCargoWaitingClick_filter.Retrieve();\n+      HandleCargoWaitingClick_filter.Retrieve();\n+    case 1:\n+      IsWidgetLowered();\n+    }\n+  }\n+};\n+void ShowStationViewWindow_station() {\n+  AllocateWindowDescFront<StationViewWindow>(&_station_view_desc,\n+                                             ShowStationViewWindow_station);\n+}"}]}