{"sha": "2c69df3ba0b68d3f42d18a4b23576dd0c0eca752", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM2OWRmM2JhMGI2OGQzZjQyZDE4YTRiMjM1NzZkZDBjMGVjYTc1Mg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2014-08-30T18:47:40Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2014-08-30T18:47:40Z"}, "message": "trans.h (gfc_caf_get_image_index, [...]): New prototypes.\n\n2014-08-30  Tobias Burnus  <burnus@net-b.de>\n\n        * trans.h (gfc_caf_get_image_index,\n        gfc_get_caf_token_offset): New prototypes.\n        * trans-expr.c (gfc_caf_get_image_index): Moved from\n        trans-intrinsic.c and renamed.\n        (gfc_get_caf_token_offset) Ditto; support offset = NULL\n        with early return.\n        * trans-intrinsic.c (get_caf_token_offset, caf_get_image_index):\n        Moved to trans-expr.\n        (gfc_conv_intrinsic_caf_get, conv_caf_send,\n        conv_intrinsic_atomic_op, conv_intrinsic_atomic_ref,\n        conv_intrinsic_atomic_cas): Update callers.\n\nFrom-SVN: r214758", "tree": {"sha": "47f7417fc9f987bebd005478d98ab05f0adf6bd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47f7417fc9f987bebd005478d98ab05f0adf6bd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c69df3ba0b68d3f42d18a4b23576dd0c0eca752", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c69df3ba0b68d3f42d18a4b23576dd0c0eca752", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c69df3ba0b68d3f42d18a4b23576dd0c0eca752", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c69df3ba0b68d3f42d18a4b23576dd0c0eca752/comments", "author": null, "committer": null, "parents": [{"sha": "e284dec53b47987924dfaaec965c2e6c20defe66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e284dec53b47987924dfaaec965c2e6c20defe66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e284dec53b47987924dfaaec965c2e6c20defe66"}], "stats": {"total": 311, "additions": 159, "deletions": 152}, "files": [{"sha": "f2ed47467cd365cd2c2bf6022366e7ac035bc84a", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c69df3ba0b68d3f42d18a4b23576dd0c0eca752/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c69df3ba0b68d3f42d18a4b23576dd0c0eca752/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=2c69df3ba0b68d3f42d18a4b23576dd0c0eca752", "patch": "@@ -1444,6 +1444,149 @@ gfc_get_tree_for_caf_expr (gfc_expr *expr)\n }\n \n \n+/* Obtain the Coarray token - and optionally also the offset.  */\n+\n+void\n+gfc_get_caf_token_offset (tree *token, tree *offset, tree caf_decl, tree se_expr,\n+\t\t\t  gfc_expr *expr)\n+{\n+  tree tmp;\n+\n+  /* Coarray token.  */\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (caf_decl)))\n+    {\n+      gcc_assert (GFC_TYPE_ARRAY_AKIND (TREE_TYPE (caf_decl))\n+\t\t    == GFC_ARRAY_ALLOCATABLE\n+\t\t  || expr->symtree->n.sym->attr.select_type_temporary);\n+      *token = gfc_conv_descriptor_token (caf_decl);\n+    }\n+  else if (DECL_LANG_SPECIFIC (caf_decl)\n+\t   && GFC_DECL_TOKEN (caf_decl) != NULL_TREE)\n+    *token = GFC_DECL_TOKEN (caf_decl);\n+  else\n+    {\n+      gcc_assert (GFC_ARRAY_TYPE_P (TREE_TYPE (caf_decl))\n+\t\t  && GFC_TYPE_ARRAY_CAF_TOKEN (TREE_TYPE (caf_decl)) != NULL_TREE);\n+      *token = GFC_TYPE_ARRAY_CAF_TOKEN (TREE_TYPE (caf_decl));\n+    }\n+\n+  if (offset == NULL)\n+    return;\n+\n+  /* Offset between the coarray base address and the address wanted.  */\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (caf_decl))\n+      && (GFC_TYPE_ARRAY_AKIND (TREE_TYPE (caf_decl)) == GFC_ARRAY_ALLOCATABLE\n+\t  || GFC_TYPE_ARRAY_AKIND (TREE_TYPE (caf_decl)) == GFC_ARRAY_POINTER))\n+    *offset = build_int_cst (gfc_array_index_type, 0);\n+  else if (DECL_LANG_SPECIFIC (caf_decl)\n+\t   && GFC_DECL_CAF_OFFSET (caf_decl) != NULL_TREE)\n+    *offset = GFC_DECL_CAF_OFFSET (caf_decl);\n+  else if (GFC_TYPE_ARRAY_CAF_OFFSET (TREE_TYPE (caf_decl)) != NULL_TREE)\n+    *offset = GFC_TYPE_ARRAY_CAF_OFFSET (TREE_TYPE (caf_decl));\n+  else\n+    *offset = build_int_cst (gfc_array_index_type, 0);\n+\n+  if (POINTER_TYPE_P (TREE_TYPE (se_expr))\n+      && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (se_expr))))\n+    {\n+      tmp = build_fold_indirect_ref_loc (input_location, se_expr);\n+      tmp = gfc_conv_descriptor_data_get (tmp);\n+    }\n+  else if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se_expr)))\n+    tmp = gfc_conv_descriptor_data_get (se_expr);\n+  else\n+    {\n+      gcc_assert (POINTER_TYPE_P (TREE_TYPE (se_expr)));\n+      tmp = se_expr;\n+    }\n+\n+  *offset = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     *offset, fold_convert (gfc_array_index_type, tmp));\n+\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (caf_decl)))\n+    tmp = gfc_conv_descriptor_data_get (caf_decl);\n+  else\n+   {\n+     gcc_assert (POINTER_TYPE_P (TREE_TYPE (caf_decl)));\n+     tmp = caf_decl;\n+   }\n+\n+  *offset = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t    fold_convert (gfc_array_index_type, *offset),\n+\t\t\t    fold_convert (gfc_array_index_type, tmp));\n+}\n+\n+\n+/* Convert the coindex of a coarray into an image index; the result is\n+   image_num =  (idx(1)-lcobound(1)+1) + (idx(2)-lcobound(2)+1)*extent(1)\n+              + (idx(3)-lcobound(3)+1)*extent(2) + ...  */\n+\n+tree\n+gfc_caf_get_image_index (stmtblock_t *block, gfc_expr *e, tree desc)\n+{\n+  gfc_ref *ref;\n+  tree lbound, ubound, extent, tmp, img_idx;\n+  gfc_se se;\n+  int i;\n+\n+  for (ref = e->ref; ref; ref = ref->next)\n+    if (ref->type == REF_ARRAY && ref->u.ar.codimen > 0)\n+      break;\n+  gcc_assert (ref != NULL);\n+\n+  img_idx = integer_zero_node;\n+  extent = integer_one_node;\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))\n+    for (i = ref->u.ar.dimen; i < ref->u.ar.dimen + ref->u.ar.codimen; i++)\n+      {\n+\tgfc_init_se (&se, NULL);\n+\tgfc_conv_expr_type (&se, ref->u.ar.start[i], integer_type_node);\n+\tgfc_add_block_to_block (block, &se.pre);\n+\tlbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[i]);\n+\ttmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t       integer_type_node, se.expr,\n+\t\t\t       fold_convert(integer_type_node, lbound));\n+\ttmp = fold_build2_loc (input_location, MULT_EXPR, integer_type_node,\n+\t\t\t       extent, tmp);\n+\timg_idx = fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n+\t\t\t\t   img_idx, tmp);\n+\tif (i < ref->u.ar.dimen + ref->u.ar.codimen - 1)\n+\t  {\n+\t    ubound = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[i]);\n+\t    extent = gfc_conv_array_extent_dim (lbound, ubound, NULL);\n+\t    extent = fold_convert (integer_type_node, extent);\n+\t  }\n+      }\n+  else\n+    for (i = ref->u.ar.dimen; i < ref->u.ar.dimen + ref->u.ar.codimen; i++)\n+      {\n+\tgfc_init_se (&se, NULL);\n+\tgfc_conv_expr_type (&se, ref->u.ar.start[i], integer_type_node);\n+\tgfc_add_block_to_block (block, &se.pre);\n+\tlbound = GFC_TYPE_ARRAY_LBOUND (TREE_TYPE (desc), i);\n+\tlbound = fold_convert (integer_type_node, lbound);\n+\ttmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t       integer_type_node, se.expr, lbound);\n+\ttmp = fold_build2_loc (input_location, MULT_EXPR, integer_type_node,\n+\t\t\t       extent, tmp);\n+\timg_idx = fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n+\t\t\t\t   img_idx, tmp);\n+\tif (i < ref->u.ar.dimen + ref->u.ar.codimen - 1)\n+\t  {\n+\t    ubound = GFC_TYPE_ARRAY_UBOUND (TREE_TYPE (desc), i);\n+\t    ubound = fold_convert (integer_type_node, ubound);\n+\t    extent = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t      integer_type_node, ubound, lbound);\n+\t    extent = fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n+\t\t\t\t      extent, integer_one_node);\n+\t  }\n+      }\n+  img_idx = fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n+\t\t\t     img_idx, integer_one_node);\n+  return img_idx;\n+}\n+\n+\n /* For each character array constructor subexpression without a ts.u.cl->length,\n    replace it by its first element (if there aren't any elements, the length\n    should already be set to zero).  */"}, {"sha": "3aa59c98adcf5936f40bfce91a4b1f56c0ca8f10", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 14, "deletions": 152, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c69df3ba0b68d3f42d18a4b23576dd0c0eca752/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c69df3ba0b68d3f42d18a4b23576dd0c0eca752/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=2c69df3ba0b68d3f42d18a4b23576dd0c0eca752", "patch": "@@ -926,76 +926,6 @@ gfc_conv_intrinsic_exponent (gfc_se *se, gfc_expr *expr)\n }\n \n \n-/* Convert the coindex of a coarray into an image index; the result is\n-   image_num =  (idx(1)-lcobound(1)+1) + (idx(2)-lcobound(2)+1)*extent(1)\n-              + (idx(3)-lcobound(3)+1)*extent(2) + ...  */\n-\n-static tree\n-caf_get_image_index (stmtblock_t *block, gfc_expr *e, tree desc)\n-{\n-  gfc_ref *ref;\n-  tree lbound, ubound, extent, tmp, img_idx;\n-  gfc_se se;\n-  int i;\n-\n-  for (ref = e->ref; ref; ref = ref->next)\n-    if (ref->type == REF_ARRAY && ref->u.ar.codimen > 0)\n-      break;\n-  gcc_assert (ref != NULL);\n-\n-  img_idx = integer_zero_node;\n-  extent = integer_one_node;\n-  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))\n-    for (i = ref->u.ar.dimen; i < ref->u.ar.dimen + ref->u.ar.codimen; i++)\n-      {\n-\tgfc_init_se (&se, NULL);\n-\tgfc_conv_expr_type (&se, ref->u.ar.start[i], integer_type_node);\n-\tgfc_add_block_to_block (block, &se.pre);\n-\tlbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[i]);\n-\ttmp = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t       integer_type_node, se.expr,\n-\t\t\t       fold_convert(integer_type_node, lbound));\n-\ttmp = fold_build2_loc (input_location, MULT_EXPR, integer_type_node,\n-\t\t\t       extent, tmp);\n-\timg_idx = fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n-\t\t\t\t   img_idx, tmp);\n-\tif (i < ref->u.ar.dimen + ref->u.ar.codimen - 1)\n-\t  {\n-\t    ubound = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[i]);\n-\t    extent = gfc_conv_array_extent_dim (lbound, ubound, NULL);\n-\t    extent = fold_convert (integer_type_node, extent);\n-\t  }\n-      }\n-  else\n-    for (i = ref->u.ar.dimen; i < ref->u.ar.dimen + ref->u.ar.codimen; i++)\n-      {\n-\tgfc_init_se (&se, NULL);\n-\tgfc_conv_expr_type (&se, ref->u.ar.start[i], integer_type_node);\n-\tgfc_add_block_to_block (block, &se.pre);\n-\tlbound = GFC_TYPE_ARRAY_LBOUND (TREE_TYPE (desc), i);\n-\tlbound = fold_convert (integer_type_node, lbound);\n-\ttmp = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t       integer_type_node, se.expr, lbound);\n-\ttmp = fold_build2_loc (input_location, MULT_EXPR, integer_type_node,\n-\t\t\t       extent, tmp);\n-\timg_idx = fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n-\t\t\t\t   img_idx, tmp);\n-\tif (i < ref->u.ar.dimen + ref->u.ar.codimen - 1)\n-\t  {\n-\t    ubound = GFC_TYPE_ARRAY_UBOUND (TREE_TYPE (desc), i);\n-\t    ubound = fold_convert (integer_type_node, ubound);\n-\t    extent = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t\t      integer_type_node, ubound, lbound);\n-\t    extent = fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n-\t\t\t\t      extent, integer_one_node);\n-\t  }\n-      }\n-  img_idx = fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n-\t\t\t     img_idx, integer_one_node);\n-  return img_idx;\n-}\n-\n-\n /* Fill in the following structure\n      struct caf_vector_t {\n        size_t nvec;  // size of the vector\n@@ -1153,74 +1083,6 @@ conv_caf_vector_subscript (stmtblock_t *block, tree desc, gfc_array_ref *ar)\n }\n \n \n-static void\n-get_caf_token_offset (tree *token, tree *offset, tree caf_decl, tree se_expr,\n-\t\t      gfc_expr *expr)\n-{\n-  tree tmp;\n-\n-  /* Coarray token.  */\n-  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (caf_decl)))\n-    {\n-      gcc_assert (GFC_TYPE_ARRAY_AKIND (TREE_TYPE (caf_decl))\n-\t\t    == GFC_ARRAY_ALLOCATABLE\n-\t\t  || expr->symtree->n.sym->attr.select_type_temporary);\n-      *token = gfc_conv_descriptor_token (caf_decl);\n-    }\n-  else if (DECL_LANG_SPECIFIC (caf_decl)\n-\t   && GFC_DECL_TOKEN (caf_decl) != NULL_TREE)\n-    *token = GFC_DECL_TOKEN (caf_decl);\n-  else\n-    {\n-      gcc_assert (GFC_ARRAY_TYPE_P (TREE_TYPE (caf_decl))\n-\t\t  && GFC_TYPE_ARRAY_CAF_TOKEN (TREE_TYPE (caf_decl)) != NULL_TREE);\n-      *token = GFC_TYPE_ARRAY_CAF_TOKEN (TREE_TYPE (caf_decl));\n-    }\n-\n-  /* Offset between the coarray base address and the address wanted.  */\n-  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (caf_decl))\n-      && (GFC_TYPE_ARRAY_AKIND (TREE_TYPE (caf_decl)) == GFC_ARRAY_ALLOCATABLE\n-\t  || GFC_TYPE_ARRAY_AKIND (TREE_TYPE (caf_decl)) == GFC_ARRAY_POINTER))\n-    *offset = build_int_cst (gfc_array_index_type, 0);\n-  else if (DECL_LANG_SPECIFIC (caf_decl)\n-\t   && GFC_DECL_CAF_OFFSET (caf_decl) != NULL_TREE)\n-    *offset = GFC_DECL_CAF_OFFSET (caf_decl);\n-  else if (GFC_TYPE_ARRAY_CAF_OFFSET (TREE_TYPE (caf_decl)) != NULL_TREE)\n-    *offset = GFC_TYPE_ARRAY_CAF_OFFSET (TREE_TYPE (caf_decl));\n-  else\n-    *offset = build_int_cst (gfc_array_index_type, 0);\n-\n-  if (POINTER_TYPE_P (TREE_TYPE (se_expr))\n-      && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (se_expr))))\n-    {\n-      tmp = build_fold_indirect_ref_loc (input_location, se_expr);\n-      tmp = gfc_conv_descriptor_data_get (tmp);\n-    }\n-  else if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se_expr)))\n-    tmp = gfc_conv_descriptor_data_get (se_expr);\n-  else\n-    {\n-      gcc_assert (POINTER_TYPE_P (TREE_TYPE (se_expr)));\n-      tmp = se_expr;\n-    }\n-\n-  *offset = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     *offset, fold_convert (gfc_array_index_type, tmp));\n-\n-  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (caf_decl)))\n-    tmp = gfc_conv_descriptor_data_get (caf_decl);\n-  else\n-   {\n-     gcc_assert (POINTER_TYPE_P (TREE_TYPE (caf_decl)));\n-     tmp = caf_decl;\n-   }\n-\n-  *offset = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n-\t\t\t    fold_convert (gfc_array_index_type, *offset),\n-\t\t\t    fold_convert (gfc_array_index_type, tmp));\n-}\n-\n-\n /* Get data from a remote coarray.  */\n \n static void\n@@ -1328,8 +1190,8 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind)\n   caf_decl = gfc_get_tree_for_caf_expr (array_expr);\n   if (TREE_CODE (TREE_TYPE (caf_decl)) == REFERENCE_TYPE)\n     caf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n-  image_index = caf_get_image_index (&se->pre, array_expr, caf_decl);\n-  get_caf_token_offset (&token, &offset, caf_decl, argse.expr, array_expr);\n+  image_index = gfc_caf_get_image_index (&se->pre, array_expr, caf_decl);\n+  gfc_get_caf_token_offset (&token, &offset, caf_decl, argse.expr, array_expr);\n \n   tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_get, 8,\n \t\t\t     token, offset, image_index, argse.expr, vec,\n@@ -1425,8 +1287,8 @@ conv_caf_send (gfc_code *code) {\n   caf_decl = gfc_get_tree_for_caf_expr (lhs_expr);\n   if (TREE_CODE (TREE_TYPE (caf_decl)) == REFERENCE_TYPE)\n     caf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n-  image_index = caf_get_image_index (&block, lhs_expr, caf_decl);\n-  get_caf_token_offset (&token, &offset, caf_decl, lhs_se.expr, lhs_expr);\n+  image_index = gfc_caf_get_image_index (&block, lhs_expr, caf_decl);\n+  gfc_get_caf_token_offset (&token, &offset, caf_decl, lhs_se.expr, lhs_expr);\n \n   /* RHS.  */\n   gfc_init_se (&rhs_se, NULL);\n@@ -1490,9 +1352,9 @@ conv_caf_send (gfc_code *code) {\n       caf_decl = gfc_get_tree_for_caf_expr (rhs_expr);\n       if (TREE_CODE (TREE_TYPE (caf_decl)) == REFERENCE_TYPE)\n \tcaf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n-      rhs_image_index = caf_get_image_index (&block, rhs_expr, caf_decl);\n-      get_caf_token_offset (&rhs_token, &rhs_offset, caf_decl, rhs_se.expr,\n-\t\t\t    rhs_expr);\n+      rhs_image_index = gfc_caf_get_image_index (&block, rhs_expr, caf_decl);\n+      gfc_get_caf_token_offset (&rhs_token, &rhs_offset, caf_decl, rhs_se.expr,\n+\t\t\t\trhs_expr);\n       tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_sendget, 12,\n \t\t\t\t token, offset, image_index, lhs_se.expr, vec,\n \t\t\t\t rhs_token, rhs_offset, rhs_image_index,\n@@ -5908,7 +5770,7 @@ gfc_conv_intrinsic_sizeof (gfc_se *se, gfc_expr *expr)\n   if (arg->ts.type == BT_ASSUMED)\n     {\n       /* This only works if an array descriptor has been passed; thus, extract\n-\t  the size from the descriptor.  */\n+\t the size from the descriptor.  */\n       gcc_assert (TYPE_PRECISION (gfc_array_index_type)\n \t\t  == TYPE_PRECISION (size_type_node));\n       tmp = arg->symtree->n.sym->backend_decl;\n@@ -8519,7 +8381,7 @@ conv_intrinsic_atomic_op (gfc_code *code)\n \tcaf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n \n       if (gfc_is_coindexed (atom_expr))\n-\timage_index = caf_get_image_index (&block, atom_expr, caf_decl);\n+\timage_index = gfc_caf_get_image_index (&block, atom_expr, caf_decl);\n       else\n \timage_index = integer_zero_node;\n \n@@ -8530,7 +8392,7 @@ conv_intrinsic_atomic_op (gfc_code *code)\n           value = gfc_build_addr_expr (NULL_TREE, tmp);\n \t}\n \n-      get_caf_token_offset (&token, &offset, caf_decl, atom, atom_expr);\n+      gfc_get_caf_token_offset (&token, &offset, caf_decl, atom, atom_expr);\n \n       if (code->resolved_isym->id == GFC_ISYM_ATOMIC_DEF)\n \ttmp = build_call_expr_loc (input_location, gfor_fndecl_caf_atomic_def, 7,\n@@ -8672,11 +8534,11 @@ conv_intrinsic_atomic_ref (gfc_code *code)\n \tcaf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n \n       if (gfc_is_coindexed (atom_expr))\n-\timage_index = caf_get_image_index (&block, atom_expr, caf_decl);\n+\timage_index = gfc_caf_get_image_index (&block, atom_expr, caf_decl);\n       else\n \timage_index = integer_zero_node;\n \n-      get_caf_token_offset (&token, &offset, caf_decl, atom, atom_expr);\n+      gfc_get_caf_token_offset (&token, &offset, caf_decl, atom, atom_expr);\n \n       /* Different type, need type conversion.  */\n       if (!POINTER_TYPE_P (TREE_TYPE (value)))\n@@ -8790,7 +8652,7 @@ conv_intrinsic_atomic_cas (gfc_code *code)\n \tcaf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n \n       if (gfc_is_coindexed (atom_expr))\n-\timage_index = caf_get_image_index (&block, atom_expr, caf_decl);\n+\timage_index = gfc_caf_get_image_index (&block, atom_expr, caf_decl);\n       else\n \timage_index = integer_zero_node;\n \n@@ -8809,7 +8671,7 @@ conv_intrinsic_atomic_cas (gfc_code *code)\n           comp = gfc_build_addr_expr (NULL_TREE, tmp);\n \t}\n \n-      get_caf_token_offset (&token, &offset, caf_decl, atom, atom_expr);\n+      gfc_get_caf_token_offset (&token, &offset, caf_decl, atom, atom_expr);\n \n       tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_atomic_cas, 9,\n \t\t\t\t token, offset, image_index, old, comp, new_val,"}, {"sha": "70c794bb47d2c63863c960cc7c6675a650d6e8a1", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c69df3ba0b68d3f42d18a4b23576dd0c0eca752/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c69df3ba0b68d3f42d18a4b23576dd0c0eca752/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=2c69df3ba0b68d3f42d18a4b23576dd0c0eca752", "patch": "@@ -420,6 +420,8 @@ tree gfc_conv_scalar_to_descriptor (gfc_se *, tree, symbol_attribute);\n void gfc_conv_scalar_char_value (gfc_symbol *sym, gfc_se *se, gfc_expr **expr);\n tree gfc_string_to_single_character (tree len, tree str, int kind);\n tree gfc_get_tree_for_caf_expr (gfc_expr *);\n+void gfc_get_caf_token_offset (tree *, tree *, tree, tree, gfc_expr *);\n+tree gfc_caf_get_image_index (stmtblock_t *, gfc_expr *, tree);\n \n /* Find the decl containing the auxiliary variables for assigned variables.  */\n void gfc_conv_label_variable (gfc_se * se, gfc_expr * expr);"}]}