{"sha": "f5ae2781823b3a2bcded1ac3446de83cc52403a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVhZTI3ODE4MjNiM2EyYmNkZWQxYWMzNDQ2ZGU4M2NjNTI0MDNhOQ==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-11-12T14:22:41Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-08T13:10:28Z"}, "message": "Added more expression stripping\n\nFixed compile errors and started on enum expr stripping", "tree": {"sha": "e90b9876a23cd40e0da140aa62fb220ef22dfd58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e90b9876a23cd40e0da140aa62fb220ef22dfd58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5ae2781823b3a2bcded1ac3446de83cc52403a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5ae2781823b3a2bcded1ac3446de83cc52403a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5ae2781823b3a2bcded1ac3446de83cc52403a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5ae2781823b3a2bcded1ac3446de83cc52403a9/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37bbf2b8cbd4578f0fbe7cbbd573493481f62a45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37bbf2b8cbd4578f0fbe7cbbd573493481f62a45"}], "stats": {"total": 324, "additions": 264, "deletions": 60}, "files": [{"sha": "fcf475e3c95ba736004034c88a571962947bae0e", "filename": "gcc/rust/analysis/rust-type-resolution.cc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5ae2781823b3a2bcded1ac3446de83cc52403a9/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5ae2781823b3a2bcded1ac3446de83cc52403a9/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc?ref=f5ae2781823b3a2bcded1ac3446de83cc52403a9", "patch": "@@ -427,15 +427,15 @@ TypeResolution::visit (AST::StructExprFieldIdentifier &field)\n void\n TypeResolution::visit (AST::StructExprFieldIdentifierValue &field)\n {\n-  identifierBuffer = &field.field_name;\n-  field.value->accept_vis (*this);\n+  identifierBuffer = std::unique_ptr<std::string> (new std::string (field.get_field_name ()));\n+  field.get_value ()->accept_vis (*this);\n }\n \n void\n TypeResolution::visit (AST::StructExprFieldIndexValue &field)\n {\n-  tupleIndexBuffer = &field.index;\n-  field.value->accept_vis (*this);\n+  tupleIndexBuffer = std::unique_ptr<int> (new int (field.get_index ()));\n+  field.get_value ()->accept_vis (*this);\n }\n \n void\n@@ -448,7 +448,7 @@ TypeResolution::visit (AST::StructExprStructFields &expr)\n       return;\n     }\n \n-  for (auto &field : expr.fields)\n+  for (auto &field : expr.get_fields ())\n     {\n       identifierBuffer = NULL;\n       tupleIndexBuffer = NULL;\n@@ -1069,14 +1069,14 @@ TypeResolution::visit (AST::LetStmt &stmt)\n void\n TypeResolution::visit (AST::ExprStmtWithoutBlock &stmt)\n {\n-  stmt.expr->accept_vis (*this);\n+  stmt.get_expr ()->accept_vis (*this);\n }\n \n void\n TypeResolution::visit (AST::ExprStmtWithBlock &stmt)\n {\n   scope.Push ();\n-  stmt.expr->accept_vis (*this);\n+  stmt.get_expr ()->accept_vis (*this);\n   auto localMap = scope.PeekLocals ();\n   for (auto &[_, value] : localMap)\n     {"}, {"sha": "0c6413b9efaaaf0be4122bbb7b6fbbfddf5a29d9", "filename": "gcc/rust/analysis/rust-type-resolution.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5ae2781823b3a2bcded1ac3446de83cc52403a9/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5ae2781823b3a2bcded1ac3446de83cc52403a9/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h?ref=f5ae2781823b3a2bcded1ac3446de83cc52403a9", "patch": "@@ -301,8 +301,8 @@ class TypeResolution : public Resolution\n   bool isTypeInScope (AST::Type *type, Location locus);\n \n   TypeScoping scope;\n-  std::string *identifierBuffer;\n-  int *tupleIndexBuffer;\n+  std::unique_ptr<std::string> identifierBuffer;\n+  std::unique_ptr<int> tupleIndexBuffer;\n };\n \n } // namespace Analysis"}, {"sha": "1cf8f9c40965f434d86a012d9232c9ebcf57e88e", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5ae2781823b3a2bcded1ac3446de83cc52403a9/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5ae2781823b3a2bcded1ac3446de83cc52403a9/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=f5ae2781823b3a2bcded1ac3446de83cc52403a9", "patch": "@@ -1218,7 +1218,8 @@ class TupleExpr : public ExprWithoutBlock\n public:\n   std::string as_string () const override;\n \n-  std::vector<Attribute> get_inner_attrs () const { return inner_attrs; }\n+  const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n+  std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n   TupleExpr (std::vector<std::unique_ptr<Expr> > tuple_elements,\n \t     std::vector<Attribute> inner_attribs,\n@@ -1269,6 +1270,10 @@ class TupleExpr : public ExprWithoutBlock\n   void mark_for_strip () override { marked_for_strip = true; }\n   bool is_marked_for_strip () const override { return marked_for_strip; }\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  const std::vector<std::unique_ptr<Expr> > &get_tuple_elems () const { return tuple_elems; }\n+  std::vector<std::unique_ptr<Expr> > &get_tuple_elems () { return tuple_elems; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1340,6 +1345,12 @@ class TupleIndexExpr : public ExprWithoutBlock\n   void mark_for_strip () override { tuple_expr = nullptr; }\n   bool is_marked_for_strip () const override { return tuple_expr == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_tuple_expr () {\n+    rust_assert (tuple_expr != nullptr);\n+    return tuple_expr;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1382,7 +1393,8 @@ class StructExprStruct : public StructExpr\n public:\n   std::string as_string () const override;\n \n-  std::vector<Attribute> get_inner_attrs () const { return inner_attrs; }\n+  const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n+  std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n   // Constructor has to call protected constructor of base class\n   StructExprStruct (PathInExpression struct_path,\n@@ -1410,9 +1422,10 @@ class StructExprStruct : public StructExpr\n  * struct */\n struct StructBase\n {\n-public:\n+private:\n   std::unique_ptr<Expr> base_struct;\n \n+public:\n   // TODO: should this store location data?\n   StructBase (std::unique_ptr<Expr> base_struct_ptr)\n     : base_struct (std::move (base_struct_ptr))\n@@ -1453,6 +1466,12 @@ struct StructBase\n   bool is_invalid () const { return base_struct == nullptr; }\n \n   std::string as_string () const;\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_base_struct () {\n+    rust_assert (base_struct != nullptr);\n+    return base_struct;\n+  }\n };\n \n /* Base AST node for a single struct expression field (in struct instance\n@@ -1480,11 +1499,10 @@ class StructExprField\n // Identifier-only variant of StructExprField AST node\n class StructExprFieldIdentifier : public StructExprField\n {\n-public:\n   Identifier field_name;\n \n   // TODO: should this store location data?\n-\n+public:\n   StructExprFieldIdentifier (Identifier field_identifier)\n     : field_name (std::move (field_identifier))\n   {}\n@@ -1506,7 +1524,6 @@ class StructExprFieldIdentifier : public StructExprField\n  * abstract */\n class StructExprFieldWithVal : public StructExprField\n {\n-public:\n   std::unique_ptr<Expr> value;\n \n protected:\n@@ -1533,16 +1550,21 @@ class StructExprFieldWithVal : public StructExprField\n \n public:\n   std::string as_string () const override;\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_value () {\n+    rust_assert (value != nullptr);\n+    return value;\n+  }\n };\n \n // Identifier and value variant of StructExprField AST node\n class StructExprFieldIdentifierValue : public StructExprFieldWithVal\n {\n-public:\n   Identifier field_name;\n \n   // TODO: should this store location data?\n-\n+public:\n   StructExprFieldIdentifierValue (Identifier field_identifier,\n \t\t\t\t  std::unique_ptr<Expr> field_value)\n     : StructExprFieldWithVal (std::move (field_value)),\n@@ -1553,6 +1575,8 @@ class StructExprFieldIdentifierValue : public StructExprFieldWithVal\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  std::string get_field_name () const { return field_name; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1565,11 +1589,10 @@ class StructExprFieldIdentifierValue : public StructExprFieldWithVal\n // Tuple index and value variant of StructExprField AST node\n class StructExprFieldIndexValue : public StructExprFieldWithVal\n {\n-public:\n   TupleIndex index;\n \n   // TODO: should this store location data?\n-\n+public:\n   StructExprFieldIndexValue (TupleIndex tuple_index,\n \t\t\t     std::unique_ptr<Expr> field_value)\n     : StructExprFieldWithVal (std::move (field_value)), index (tuple_index)\n@@ -1579,6 +1602,8 @@ class StructExprFieldIndexValue : public StructExprFieldWithVal\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  TupleIndex get_index () const { return index; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1591,25 +1616,17 @@ class StructExprFieldIndexValue : public StructExprFieldWithVal\n // AST node of a struct creator with fields\n class StructExprStructFields : public StructExprStruct\n {\n-public:\n   // std::vector<StructExprField> fields;\n   std::vector<std::unique_ptr<StructExprField> > fields;\n \n   // bool has_struct_base;\n   StructBase struct_base;\n \n+public:\n   std::string as_string () const override;\n \n   bool has_struct_base () const { return !struct_base.is_invalid (); }\n \n-  /*inline std::vector<std::unique_ptr<StructExprField>> get_fields()\n-  const { return fields;\n-  }*/\n-\n-  /*inline StructBase get_struct_base() const {\n-      return has_struct_base ? struct_base : StructBase::error();\n-  }*/\n-\n   // Constructor for StructExprStructFields when no struct base is used\n   StructExprStructFields (\n     PathInExpression struct_path,\n@@ -1650,6 +1667,13 @@ class StructExprStructFields : public StructExprStruct\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<std::unique_ptr<StructExprField> > &get_fields () { return fields; }\n+  const std::vector<std::unique_ptr<StructExprField> > &get_fields () const { return fields; }\n+\n+  StructBase &get_struct_base () { return struct_base; }\n+  const StructBase &get_struct_base () const { return struct_base; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1660,17 +1684,15 @@ class StructExprStructFields : public StructExprStruct\n };\n \n // AST node of the functional update struct creator\n+/* TODO: remove and replace with StructExprStructFields, except with empty \n+ * vector of fields? */\n class StructExprStructBase : public StructExprStruct\n {\n   StructBase struct_base;\n \n public:\n   std::string as_string () const override;\n \n-  /*inline StructBase get_struct_base() const {\n-      return struct_base;\n-  }*/\n-\n   StructExprStructBase (PathInExpression struct_path, StructBase base_struct,\n \t\t\tstd::vector<Attribute> inner_attribs,\n \t\t\tstd::vector<Attribute> outer_attribs, Location locus)\n@@ -1681,6 +1703,9 @@ class StructExprStructBase : public StructExprStruct\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  StructBase &get_struct_base () { return struct_base; }\n+  const StructBase &get_struct_base () const { return struct_base; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1702,10 +1727,7 @@ class StructExprTuple : public StructExpr\n   std::string as_string () const override;\n \n   const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n-\n-  /*inline std::vector<std::unique_ptr<Expr>> get_exprs() const {\n-      return exprs;\n-  }*/\n+  std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n   StructExprTuple (PathInExpression struct_path,\n \t\t   std::vector<std::unique_ptr<Expr> > tuple_exprs,\n@@ -1748,6 +1770,9 @@ class StructExprTuple : public StructExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  const std::vector<std::unique_ptr<Expr> > &get_elems () const { return exprs; }\n+  std::vector<std::unique_ptr<Expr> > &get_elems () { return exprs; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1766,7 +1791,6 @@ class StructExprUnit : public StructExpr\n   std::string as_string () const override\n   {\n     return get_struct_name ().as_string ();\n-    // return struct_name.as_string();\n   }\n \n   StructExprUnit (PathInExpression struct_path,\n@@ -1990,6 +2014,10 @@ class EnumExprStruct : public EnumVariantExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<std::unique_ptr<EnumExprField> > &get_fields () { return fields; }\n+  const std::vector<std::unique_ptr<EnumExprField> > &get_fields () const { return fields; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "0bb1021d688d8b3dc28c3a676d9cac142de606ae", "filename": "gcc/rust/ast/rust-stmt.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5ae2781823b3a2bcded1ac3446de83cc52403a9/gcc%2Frust%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5ae2781823b3a2bcded1ac3446de83cc52403a9/gcc%2Frust%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-stmt.h?ref=f5ae2781823b3a2bcded1ac3446de83cc52403a9", "patch": "@@ -160,14 +160,14 @@ class ExprStmt : public Stmt\n  * difficulties, can only be guaranteed to hold an expression). */\n class ExprStmtWithoutBlock : public ExprStmt\n {\n-public:\n   // TODO: ensure that this works\n   std::unique_ptr<ExprWithoutBlock> expr;\n   /* HACK: cannot ensure type safety of ExprWithoutBlock due to Pratt parsing,\n    * so have to store more general type of Expr. FIXME: fix this issue somehow\n    * or redesign AST. */\n   // std::unique_ptr<Expr> expr;\n \n+public:\n   std::string as_string () const override;\n \n   ExprStmtWithoutBlock (std::unique_ptr<ExprWithoutBlock> expr, Location locus)\n@@ -232,9 +232,9 @@ class ExprStmtWithoutBlock : public ExprStmt\n // Statement containing an expression with a block\n class ExprStmtWithBlock : public ExprStmt\n {\n-public:\n   std::unique_ptr<ExprWithBlock> expr;\n \n+public:\n   std::string as_string () const override;\n \n   std::vector<LetStmt *> locals;"}, {"sha": "ca310cacb06853019bb8919a8b55d5281a37e5c4", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5ae2781823b3a2bcded1ac3446de83cc52403a9/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5ae2781823b3a2bcded1ac3446de83cc52403a9/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=f5ae2781823b3a2bcded1ac3446de83cc52403a9", "patch": "@@ -538,24 +538,24 @@ Compilation::visit (AST::StructExprFieldIdentifierValue &field)\n   bool found = false;\n   for (auto &df : decl->get_fields ())\n     {\n-      if (field.field_name.compare (df.field_name) == 0)\n+      if (field.get_field_name ().compare (df.field_name) == 0)\n \t{\n \t  found = true;\n \t  break;\n \t}\n     }\n   if (!found)\n     {\n-      rust_fatal_error (field.value->get_locus_slow (),\n+      rust_fatal_error (field.get_value ()->get_locus_slow (),\n \t\t\t\"failed to lookup field index\");\n       return;\n     }\n \n   Bexpression *value = NULL;\n-  VISIT_POP (field.value->get_locus_slow (), field.value.get (), value, exprs);\n+  VISIT_POP (field.get_value ()->get_locus_slow (), field.get_value ().get (), value, exprs);\n   if (value == NULL)\n     {\n-      rust_fatal_error (field.value->get_locus_slow (),\n+      rust_fatal_error (field.get_value ()->get_locus_slow (),\n \t\t\t\"failed to compile value to struct\");\n       return;\n     }\n@@ -566,10 +566,10 @@ void\n Compilation::visit (AST::StructExprFieldIndexValue &field)\n {\n   Bexpression *value = NULL;\n-  VISIT_POP (field.value->get_locus_slow (), field.value.get (), value, exprs);\n+  VISIT_POP (field.get_value ()->get_locus_slow (), field.get_value ().get (), value, exprs);\n   if (value == NULL)\n     {\n-      rust_fatal_error (field.value->get_locus_slow (),\n+      rust_fatal_error (field.get_value ()->get_locus_slow (),\n \t\t\t\"failed to compile value to struct\");\n       return;\n     }\n@@ -598,7 +598,7 @@ Compilation::visit (AST::StructExprStructFields &expr)\n \n   // FIXME type resolution pass should ensures these are in correct order\n   // and have defaults if required\n-  for (auto &field : expr.fields)\n+  for (auto &field : expr.get_fields ())\n     {\n       Bexpression *value = NULL;\n       VISIT_POP (expr.get_locus (), field, value, exprs);\n@@ -1332,7 +1332,7 @@ Compilation::visit (AST::LetStmt &stmt)\n void\n Compilation::visit (AST::ExprStmtWithoutBlock &stmt)\n {\n-  stmt.expr->accept_vis (*this);\n+  stmt.get_expr ()->accept_vis (*this);\n }\n \n void\n@@ -1348,7 +1348,7 @@ Compilation::visit (AST::ExprStmtWithBlock &stmt)\n \t\t      start_location, end_location);\n \n   scope.PushBlock (code_block);\n-  stmt.expr->accept_vis (*this);\n+  stmt.get_expr ()->accept_vis (*this);\n \n   // get trailing if required\n   for (auto &s : stmts)"}, {"sha": "65918dbb824a04077ce9655a2a4fb7ea8c950129", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 188, "deletions": 12, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5ae2781823b3a2bcded1ac3446de83cc52403a9/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5ae2781823b3a2bcded1ac3446de83cc52403a9/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=f5ae2781823b3a2bcded1ac3446de83cc52403a9", "patch": "@@ -345,20 +345,196 @@ namespace Rust {\n             expr.get_array_expr()->accept_vis(*this);\n             expr.get_index_expr()->accept_vis(*this);\n         }\n-        void visit(AST::TupleExpr& expr) override {}\n-        void visit(AST::TupleIndexExpr& expr) override {}\n-        void visit(AST::StructExprStruct& expr) override {}\n-        void visit(AST::StructExprFieldIdentifier& field) override {}\n-        void visit(AST::StructExprFieldIdentifierValue& field) override {}\n-        void visit(AST::StructExprFieldIndexValue& field) override {}\n-        void visit(AST::StructExprStructFields& expr) override {}\n-        void visit(AST::StructExprStructBase& expr) override {}\n-        void visit(AST::StructExprTuple& expr) override {}\n-        void visit(AST::StructExprUnit& expr) override {}\n-        void visit(AST::EnumExprFieldIdentifier& field) override {}\n+        void visit(AST::TupleExpr& expr) override {\n+            /* according to spec, outer attributes are allowed on \"elements of \n+             * tuple expressions\" */\n+\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip test based on inner attrs - spec says these are inner \n+             * attributes, not outer attributes of inner expr */\n+            expander.expand_cfg_attrs(expr.get_inner_attrs());\n+            if (expander.fails_cfg(expr.get_inner_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* apparently outer attributes are allowed in \"elements of tuple \n+             * expressions\" according to spec */\n+            auto& values = expr.get_tuple_elems();\n+            for (int i = 0; i < values.size();) {\n+                auto& value = values[i];\n+\n+                // mark for stripping if required\n+                value->accept_vis(*this);\n+\n+                if (value->is_marked_for_strip())\n+                    values.erase(values.begin() + i);\n+                else\n+                    i++;\n+            }\n+        }\n+        void visit(AST::TupleIndexExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* wouldn't strip this directly (as outer attrs should be \n+             * associated with this level), but any sub-expressions would be \n+             * stripped. Thus, no need to erase when strip check called. */\n+            expr.get_tuple_expr()->accept_vis(*this);\n+        }\n+        void visit(AST::StructExprStruct& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip test based on inner attrs - spec says these are inner \n+             * attributes, not outer attributes of inner expr */\n+            expander.expand_cfg_attrs(expr.get_inner_attrs());\n+            if (expander.fails_cfg(expr.get_inner_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }  \n+        }\n+        void visit(AST::StructExprFieldIdentifier& field) override {\n+            // as no attrs (at moment, at least), no stripping possible\n+        }\n+        void visit(AST::StructExprFieldIdentifierValue& field) override {\n+            /* as no attrs possible (at moment, at least), only sub-expression\n+             * stripping is possible */\n+            field.get_value()->accept_vis(*this);\n+        }\n+        void visit(AST::StructExprFieldIndexValue& field) override {\n+            /* as no attrs possible (at moment, at least), only sub-expression\n+             * stripping is possible */\n+            field.get_value()->accept_vis(*this);\n+        }\n+        void visit(AST::StructExprStructFields& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip test based on inner attrs - spec says these are inner \n+             * attributes, not outer attributes of inner expr */\n+            expander.expand_cfg_attrs(expr.get_inner_attrs());\n+            if (expander.fails_cfg(expr.get_inner_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }  \n+\n+            /* spec does not specify whether expressions are allowed to be \n+             * stripped at top level of struct fields, but I wouldn't think \n+             * that they would be, so operating under the assumption that only \n+             * sub-expressions can be stripped. */\n+            for (auto& field : expr.get_fields()) {\n+                field->accept_vis(*this);\n+                // shouldn't strip in this\n+            }\n+\n+            /* struct base presumably can't be stripped, as the '..' is before\n+             * the expression. as such, can only strip sub-expressions. */\n+            if (expr.has_struct_base())\n+                expr.get_struct_base().get_base_struct()->accept_vis(*this);\n+        }\n+        void visit(AST::StructExprStructBase& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip test based on inner attrs - spec says these are inner \n+             * attributes, not outer attributes of inner expr */\n+            expander.expand_cfg_attrs(expr.get_inner_attrs());\n+            if (expander.fails_cfg(expr.get_inner_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }  \n+\n+            /* struct base presumably can't be stripped, as the '..' is before\n+             * the expression. as such, can only strip sub-expressions. */\n+            rust_assert(!expr.get_struct_base().is_invalid());\n+            expr.get_struct_base().get_base_struct()->accept_vis(*this);\n+        }\n+        void visit(AST::StructExprTuple& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip test based on inner attrs - spec says these are inner \n+             * attributes, not outer attributes of inner expr */\n+            expander.expand_cfg_attrs(expr.get_inner_attrs());\n+            if (expander.fails_cfg(expr.get_inner_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* spec says outer attributes are specifically allowed for elements \n+             * of tuple-style struct expressions, so full stripping possible */\n+            auto& values = expr.get_elems();\n+            for (int i = 0; i < values.size();) {\n+                auto& value = values[i];\n+\n+                // mark for stripping if required\n+                value->accept_vis(*this);\n+\n+                if (value->is_marked_for_strip())\n+                    values.erase(values.begin() + i);\n+                else\n+                    i++;\n+            }\n+        }\n+        void visit(AST::StructExprUnit& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+        }\n+        void visit(AST::EnumExprFieldIdentifier& field) override {\n+            \n+        }\n         void visit(AST::EnumExprFieldIdentifierValue& field) override {}\n         void visit(AST::EnumExprFieldIndexValue& field) override {}\n-        void visit(AST::EnumExprStruct& expr) override {}\n+        void visit(AST::EnumExprStruct& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // supposedly spec doesn't allow inner attributes in enum exprs\n+\n+            /* spec does not specify whether expressions are allowed to be \n+             * stripped at top level of expression fields, but I wouldn't think\n+             * that they would be, so operating under the assumption that only \n+             * sub-expressions can be stripped. */\n+            for (auto& field : expr.get_fields()) {\n+                field->accept_vis(*this);\n+                // shouldn't strip in this\n+            }\n+        }\n         void visit(AST::EnumExprTuple& expr) override {}\n         void visit(AST::EnumExprFieldless& expr) override {}\n         void visit(AST::CallExpr& expr) override {}"}]}