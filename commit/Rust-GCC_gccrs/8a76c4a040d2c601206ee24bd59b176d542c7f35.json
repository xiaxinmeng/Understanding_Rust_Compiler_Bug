{"sha": "8a76c4a040d2c601206ee24bd59b176d542c7f35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE3NmM0YTA0MGQyYzYwMTIwNmVlMjRiZDU5YjE3NmQ1NDJjN2YzNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-06-14T14:59:52Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-06-14T14:59:52Z"}, "message": "re PR rtl-optimization/49390 (GCSE miscompilation)\n\n\tPR rtl-optimization/49390\n\tRevert:\n\t2010-06-29  Bernd Schmidt  <bernds@codesourcery.com>\n\n\t* cse.c (exp_equiv_p): For MEMs, if for_gcse, only compare\n\tMEM_ALIAS_SET.\n\n\t* gcc.c-torture/execute/pr49390.c: New test.\n\nFrom-SVN: r175023", "tree": {"sha": "1c93aea3877d84bba3664e6b823915a058c8dc67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c93aea3877d84bba3664e6b823915a058c8dc67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a76c4a040d2c601206ee24bd59b176d542c7f35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a76c4a040d2c601206ee24bd59b176d542c7f35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a76c4a040d2c601206ee24bd59b176d542c7f35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a76c4a040d2c601206ee24bd59b176d542c7f35/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b4a9343cf59f4ccb03c5be05a9314ff1f45712b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4a9343cf59f4ccb03c5be05a9314ff1f45712b4"}], "stats": {"total": 124, "additions": 118, "deletions": 6}, "files": [{"sha": "5a5fc8374150f7c4ab83203c3dc8a0339dfc6ae9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76c4a040d2c601206ee24bd59b176d542c7f35/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76c4a040d2c601206ee24bd59b176d542c7f35/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a76c4a040d2c601206ee24bd59b176d542c7f35", "patch": "@@ -1,3 +1,12 @@\n+2011-06-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/49390\n+\tRevert:\n+\t2010-06-29  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* cse.c (exp_equiv_p): For MEMs, if for_gcse, only compare\n+\tMEM_ALIAS_SET.\n+\n 2011-06-14  Zdenek Dvorak  <ook@ucw.cz>\n \t    Tom de Vries  <tom@codesourcery.com>\n "}, {"sha": "213b6083e7fd28409dffcaab3cbb1894d05023a5", "filename": "gcc/cse.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76c4a040d2c601206ee24bd59b176d542c7f35/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76c4a040d2c601206ee24bd59b176d542c7f35/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=8a76c4a040d2c601206ee24bd59b176d542c7f35", "patch": "@@ -2669,16 +2669,26 @@ exp_equiv_p (const_rtx x, const_rtx y, int validate, bool for_gcse)\n     case MEM:\n       if (for_gcse)\n \t{\n-\t  /* Can't merge two expressions in different alias sets, since we\n-\t     can decide that the expression is transparent in a block when\n-\t     it isn't, due to it being set with the different alias set.  */\n-\t  if (MEM_ALIAS_SET (x) != MEM_ALIAS_SET (y))\n-\t    return 0;\n-\n \t  /* A volatile mem should not be considered equivalent to any\n \t     other.  */\n \t  if (MEM_VOLATILE_P (x) || MEM_VOLATILE_P (y))\n \t    return 0;\n+\n+\t  /* Can't merge two expressions in different alias sets, since we\n+\t     can decide that the expression is transparent in a block when\n+\t     it isn't, due to it being set with the different alias set.\n+\n+\t     Also, can't merge two expressions with different MEM_ATTRS.\n+\t     They could e.g. be two different entities allocated into the\n+\t     same space on the stack (see e.g. PR25130).  In that case, the\n+\t     MEM addresses can be the same, even though the two MEMs are\n+\t     absolutely not equivalent.\n+\n+\t     But because really all MEM attributes should be the same for\n+\t     equivalent MEMs, we just use the invariant that MEMs that have\n+\t     the same attributes share the same mem_attrs data structure.  */\n+\t  if (MEM_ATTRS (x) != MEM_ATTRS (y))\n+\t    return 0;\n \t}\n       break;\n "}, {"sha": "4b7610d926f0883d52b982329efe91cb78817689", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76c4a040d2c601206ee24bd59b176d542c7f35/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76c4a040d2c601206ee24bd59b176d542c7f35/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8a76c4a040d2c601206ee24bd59b176d542c7f35", "patch": "@@ -1,3 +1,8 @@\n+2011-06-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/49390\n+\t* gcc.c-torture/execute/pr49390.c: New test.\n+\n 2011-06-14  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* g++.dg/torture/pr48954.C: Use dg-require-effective-target lto."}, {"sha": "dfcdea16fc05d289d4f7d8ad2b6d69ae414d47da", "filename": "gcc/testsuite/gcc.c-torture/execute/pr49390.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a76c4a040d2c601206ee24bd59b176d542c7f35/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr49390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a76c4a040d2c601206ee24bd59b176d542c7f35/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr49390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr49390.c?ref=8a76c4a040d2c601206ee24bd59b176d542c7f35", "patch": "@@ -0,0 +1,88 @@\n+/* PR rtl-optimization/49390 */\n+\n+struct S { unsigned int s1; unsigned int s2; };\n+struct T { unsigned int t1; struct S t2; };\n+struct U { unsigned short u1; unsigned short u2; };\n+struct V { struct U v1; struct T v2; };\n+struct S a;\n+char *b;\n+union { char b[64]; struct V v; } u;\n+volatile int v;\n+extern void abort (void);\n+\n+__attribute__((noinline, noclone)) void\n+foo (int x, void *y, unsigned int z, unsigned int w)\n+{\n+  if (x != 4 || y != (void *) &u.v.v2)\n+    abort ();\n+  v = z + w;\n+  v = 16384;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+bar (struct S x)\n+{\n+  v = x.s1;\n+  v = x.s2;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+baz (struct S *x)\n+{\n+  v = x->s1;\n+  v = x->s2;\n+  v = 0;\n+  return v + 1;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+test (struct S *c)\n+{\n+  struct T *d;\n+  struct S e = a;\n+  unsigned int f, g;\n+  if (c == 0)\n+    c = &e;\n+  else\n+    {\n+      if (c->s2 % 8192 <= 15 || (8192 - c->s2 % 8192) <= 31)\n+\tfoo (1, 0, c->s1, c->s2);\n+    }\n+  if (!baz (c))\n+    return;\n+  g = (((struct U *) b)->u2 & 2) ? 32 : __builtin_offsetof (struct V, v2);\n+  f = c->s2 % 8192;\n+  if (f == 0)\n+    {\n+      e.s2 += g;\n+      f = g;\n+    }\n+  else if (f < g)\n+    {\n+      foo (2, 0, c->s1, c->s2);\n+      return;\n+    }\n+  if ((((struct U *) b)->u2 & 1) && f == g)\n+    {\n+      bar (*c);\n+      foo (3, 0, c->s1, c->s2);\n+      return;\n+    }\n+  d = (struct T *) (b + c->s2 % 8192);\n+  if (d->t2.s1 >= c->s1 && (d->t2.s1 != c->s1 || d->t2.s2 >= c->s2))\n+    foo (4, d, c->s1, c->s2);\n+  return;\n+}\n+\n+int\n+main ()\n+{\n+  struct S *c = 0;\n+  asm (\"\" : \"+r\" (c) : \"r\" (&a));\n+  u.v.v2.t2.s1 = 8192;\n+  b = u.b;\n+  test (c);\n+  if (v != 16384)\n+    abort ();\n+  return 0;\n+}"}]}