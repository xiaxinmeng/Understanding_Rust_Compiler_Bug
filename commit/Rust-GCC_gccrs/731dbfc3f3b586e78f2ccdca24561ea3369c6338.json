{"sha": "731dbfc3f3b586e78f2ccdca24561ea3369c6338", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMxZGJmYzNmM2I1ODZlNzhmMmNjZGNhMjQ1NjFlYTMzNjljNjMzOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-01-10T17:49:03Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-01-21T23:40:19Z"}, "message": "Handle -Wsign-conversion in conversion_warning.\n\nIt seemed strange to me to warn about sign conversion in\nunsafe_conversion_p, when other warnings are in conversion_warning, and the\nlatter function is the only place that asks the former function to warn.\nThis change is also necessary for my -Warith-conversion patch.\n\n\t* c-common.c (unsafe_conversion_p): Don't warn, return UNSAFE_SIGN.\n\t* c-warn.c (conversion_warning): Warn about UNSAFE_SIGN.", "tree": {"sha": "09c32959a13bc55ae6e02299dbec36f1b85d56ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09c32959a13bc55ae6e02299dbec36f1b85d56ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/731dbfc3f3b586e78f2ccdca24561ea3369c6338", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/731dbfc3f3b586e78f2ccdca24561ea3369c6338", "html_url": "https://github.com/Rust-GCC/gccrs/commit/731dbfc3f3b586e78f2ccdca24561ea3369c6338", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/731dbfc3f3b586e78f2ccdca24561ea3369c6338/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0501b74264e93bf9ebf45cf10a624a549dc474f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0501b74264e93bf9ebf45cf10a624a549dc474f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0501b74264e93bf9ebf45cf10a624a549dc474f1"}], "stats": {"total": 157, "additions": 81, "deletions": 76}, "files": [{"sha": "fbbc924243d3e2d452d8d76ab7fa89fd572f8e6c", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/731dbfc3f3b586e78f2ccdca24561ea3369c6338/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/731dbfc3f3b586e78f2ccdca24561ea3369c6338/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=731dbfc3f3b586e78f2ccdca24561ea3369c6338", "patch": "@@ -1,3 +1,8 @@\n+2020-01-21  Jason Merrill  <jason@redhat.com>\n+\n+\t* c-common.c (unsafe_conversion_p): Don't warn, return UNSAFE_SIGN.\n+\t* c-warn.c (conversion_warning): Warn about UNSAFE_SIGN.\n+\n 2020-01-20  Nathan Sidwell  <nathan@acm.org>\n \n \tPR preprocessor/80005"}, {"sha": "4a7f3a52335fa4c8e4853a0557f343d6dac85b22", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 22, "deletions": 59, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/731dbfc3f3b586e78f2ccdca24561ea3369c6338/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/731dbfc3f3b586e78f2ccdca24561ea3369c6338/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=731dbfc3f3b586e78f2ccdca24561ea3369c6338", "patch": "@@ -1312,9 +1312,9 @@ int_safely_convertible_to_real_p (const_tree from_type, const_tree to_type)\n \t* EXPR is not a constant of integer type which cannot be\n \t  exactly converted to real type.\n \n-   Function allows conversions between types of different signedness and\n-   can return SAFE_CONVERSION (zero) in that case.  Function can produce\n-   signedness warnings if PRODUCE_WARNS is true.\n+   Function allows conversions between types of different signedness if\n+   CHECK_SIGN is false and can return SAFE_CONVERSION (zero) in that\n+   case.  Function can return UNSAFE_SIGN if CHECK_SIGN is true.\n \n    RESULT, when non-null is the result of the conversion.  When constant\n    it is included in the text of diagnostics.\n@@ -1325,14 +1325,11 @@ int_safely_convertible_to_real_p (const_tree from_type, const_tree to_type)\n \n enum conversion_safety\n unsafe_conversion_p (location_t loc, tree type, tree expr, tree result,\n-\t\t     bool produce_warns)\n+\t\t     bool check_sign)\n {\n   enum conversion_safety give_warning = SAFE_CONVERSION; /* is 0 or false */\n   tree expr_type = TREE_TYPE (expr);\n \n-  bool cstresult = (result\n-\t\t    && TREE_CODE_CLASS (TREE_CODE (result)) == tcc_constant);\n-\n   loc = expansion_point_location_if_in_system_header (loc);\n \n   expr = fold_for_warn (expr);\n@@ -1360,32 +1357,13 @@ unsafe_conversion_p (location_t loc, tree type, tree expr, tree result,\n \t  if (TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (expr_type)\n \t      && tree_int_cst_sgn (expr) < 0)\n \t    {\n-\t      if (produce_warns)\n-\t\t{\n-\t\t  if (cstresult)\n-\t\t    warning_at (loc, OPT_Wsign_conversion,\n-\t\t\t\t\"unsigned conversion from %qT to %qT \"\n-\t\t\t\t\"changes value from %qE to %qE\",\n-\t\t\t\texpr_type, type, expr, result);\n-\t\t  else\n-\t\t    warning_at (loc, OPT_Wsign_conversion,\n-\t\t\t\t\"unsigned conversion from %qT to %qT \"\n-\t\t\t\t\"changes the value of %qE\",\n-\t\t\t\texpr_type, type, expr);\n-\t\t}\n+\t      if (check_sign)\n+\t\tgive_warning = UNSAFE_SIGN;\n \t    }\n \t  else if (!TYPE_UNSIGNED (type) && TYPE_UNSIGNED (expr_type))\n \t    {\n-\t      if (cstresult)\n-\t\twarning_at (loc, OPT_Wsign_conversion,\n-\t\t\t    \"signed conversion from %qT to %qT changes \"\n-\t\t\t    \"value from %qE to %qE\",\n-\t\t\t    expr_type, type, expr, result);\n-\t      else\n-\t\twarning_at (loc, OPT_Wsign_conversion,\n-\t\t\t    \"signed conversion from %qT to %qT changes \"\n-\t\t\t    \"the value of %qE\",\n-\t\t\t    expr_type, type, expr);\n+\t      if (check_sign)\n+\t\tgive_warning = UNSAFE_SIGN;\n \t    }\n \t  else\n \t    give_warning = UNSAFE_OTHER;\n@@ -1425,29 +1403,19 @@ unsafe_conversion_p (location_t loc, tree type, tree expr, tree result,\n \t   is a constant, it's type is not used in text of generated warnings\n \t   (otherwise they could sound misleading).  */\n \treturn unsafe_conversion_p (loc, type, TREE_REALPART (expr), result,\n-\t\t\t\t    produce_warns);\n+\t\t\t\t    check_sign);\n       /* Conversion from complex constant with non-zero imaginary part.  */\n       else\n \t{\n \t  /* Conversion to complex type.\n \t     Perform checks for both real and imaginary parts.  */\n \t  if (TREE_CODE (type) == COMPLEX_TYPE)\n \t    {\n-\t      /* Unfortunately, produce_warns must be false in two subsequent\n-\t\t calls of unsafe_conversion_p, because otherwise we could\n-\t\t produce strange \"double\" warnings, if both real and imaginary\n-\t\t parts have conversion problems related to signedness.\n-\n-\t\t For example:\n-\t\t int32_t _Complex a = 0x80000000 + 0x80000000i;\n-\n-\t\t Possible solution: add a separate function for checking\n-\t\t constants and combine result of two calls appropriately.  */\n \t      enum conversion_safety re_safety =\n-\t\t  unsafe_conversion_p (loc, type, TREE_REALPART (expr),\n-\t\t\t\t       result, false);\n+\t\tunsafe_conversion_p (loc, type, TREE_REALPART (expr),\n+\t\t\t\t     result, check_sign);\n \t      enum conversion_safety im_safety =\n-\t\tunsafe_conversion_p (loc, type, imag_part, result, false);\n+\t\tunsafe_conversion_p (loc, type, imag_part, result, check_sign);\n \n \t      /* Merge the results into appropriate single warning.  */\n \n@@ -1530,15 +1498,13 @@ unsafe_conversion_p (location_t loc, tree type, tree expr, tree result,\n \t  /* When they are the same width but different signedness,\n \t     then the value may change.  */\n \t  else if (((TYPE_PRECISION (type) == TYPE_PRECISION (expr_type)\n-\t\t    && TYPE_UNSIGNED (expr_type) != TYPE_UNSIGNED (type))\n-\t\t   /* Even when converted to a bigger type, if the type is\n-\t\t      unsigned but expr is signed, then negative values\n-\t\t      will be changed.  */\n+\t\t     && TYPE_UNSIGNED (expr_type) != TYPE_UNSIGNED (type))\n+\t\t    /* Even when converted to a bigger type, if the type is\n+\t\t       unsigned but expr is signed, then negative values\n+\t\t       will be changed.  */\n \t\t    || (TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (expr_type)))\n-\t\t   && produce_warns)\n-\t    warning_at (loc, OPT_Wsign_conversion, \"conversion to %qT from %qT \"\n-\t\t\t\"may change the sign of the result\",\n-\t\t\ttype, expr_type);\n+\t\t   && check_sign)\n+\t    give_warning = UNSAFE_SIGN;\n \t}\n \n       /* Warn for integer types converted to real types if and only if\n@@ -1594,13 +1560,10 @@ unsafe_conversion_p (location_t loc, tree type, tree expr, tree result,\n \t      /* Check for different signedness, see case for real-domain\n \t\t integers (above) for a more detailed comment.  */\n \t      else if (((TYPE_PRECISION (to_type) == TYPE_PRECISION (from_type)\n-\t\t    && TYPE_UNSIGNED (to_type) != TYPE_UNSIGNED (from_type))\n-\t\t    || (TYPE_UNSIGNED (to_type) && !TYPE_UNSIGNED (from_type)))\n-\t\t    && produce_warns)\n-\t\twarning_at (loc, OPT_Wsign_conversion,\n-\t\t\t\"conversion to %qT from %qT \"\n-\t\t\t\"may change the sign of the result\",\n-\t\t\ttype, expr_type);\n+\t\t\t && TYPE_UNSIGNED (to_type) != TYPE_UNSIGNED (from_type))\n+\t\t\t|| (TYPE_UNSIGNED (to_type) && !TYPE_UNSIGNED (from_type)))\n+\t\t       && check_sign)\n+\t\tgive_warning = UNSAFE_SIGN;\n \t    }\n \t  else if (TREE_CODE (from_type) == INTEGER_TYPE\n \t\t   && TREE_CODE (to_type) == REAL_TYPE"}, {"sha": "fb0d53b079ebb4c2db6e366d180ac722c0f0e968", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/731dbfc3f3b586e78f2ccdca24561ea3369c6338/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/731dbfc3f3b586e78f2ccdca24561ea3369c6338/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=731dbfc3f3b586e78f2ccdca24561ea3369c6338", "patch": "@@ -784,8 +784,7 @@ enum conversion_safety {\n   SAFE_CONVERSION = 0,\n   /* Another type of conversion with problems.  */\n   UNSAFE_OTHER,\n-  /* Conversion between signed and unsigned integers\n-     which are all warned about immediately, so this is unused.  */\n+  /* Conversion between signed and unsigned integers.  */\n   UNSAFE_SIGN,\n   /* Conversions that reduce the precision of reals including conversions\n      from reals to integers.  */"}, {"sha": "6dbc660ddb442c58513caf438ec02137cad9ea83", "filename": "gcc/c-family/c-warn.c", "status": "modified", "additions": 53, "deletions": 15, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/731dbfc3f3b586e78f2ccdca24561ea3369c6338/gcc%2Fc-family%2Fc-warn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/731dbfc3f3b586e78f2ccdca24561ea3369c6338/gcc%2Fc-family%2Fc-warn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.c?ref=731dbfc3f3b586e78f2ccdca24561ea3369c6338", "patch": "@@ -1210,7 +1210,39 @@ conversion_warning (location_t loc, tree type, tree expr, tree result)\n \telse\n \t  break;\n \n-\tif (TREE_CODE_CLASS (TREE_CODE (result)) == tcc_constant)\n+\tif (conversion_kind == UNSAFE_SIGN)\n+\t  {\n+\t    bool cstresult\n+\t      = (result\n+\t\t && TREE_CODE_CLASS (TREE_CODE (result)) == tcc_constant);\n+\t    if (TYPE_UNSIGNED (type))\n+\t      {\n+\t\tif (cstresult)\n+\t\t  warning_at (loc, OPT_Wsign_conversion,\n+\t\t\t      \"unsigned conversion from %qT to %qT \"\n+\t\t\t      \"changes value from %qE to %qE\",\n+\t\t\t      expr_type, type, expr, result);\n+\t\telse\n+\t\t  warning_at (loc, OPT_Wsign_conversion,\n+\t\t\t      \"unsigned conversion from %qT to %qT \"\n+\t\t\t      \"changes the value of %qE\",\n+\t\t\t      expr_type, type, expr);\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (cstresult)\n+\t\t  warning_at (loc, OPT_Wsign_conversion,\n+\t\t\t      \"signed conversion from %qT to %qT changes \"\n+\t\t\t      \"value from %qE to %qE\",\n+\t\t\t      expr_type, type, expr, result);\n+\t\telse\n+\t\t  warning_at (loc, OPT_Wsign_conversion,\n+\t\t\t      \"signed conversion from %qT to %qT changes \"\n+\t\t\t      \"the value of %qE\",\n+\t\t\t      expr_type, type, expr);\n+\t      }\n+\t  }\n+\telse if (TREE_CODE_CLASS (TREE_CODE (result)) == tcc_constant)\n \t  warning_at (loc, warnopt,\n \t\t      \"conversion from %qT to %qT changes value from %qE to %qE\",\n \t\t      expr_type, type, expr, result);\n@@ -1234,23 +1266,29 @@ conversion_warning (location_t loc, tree type, tree expr, tree result)\n \n     default: /* 'expr' is not a constant.  */\n       conversion_kind = unsafe_conversion_p (loc, type, expr, result, true);\n-      if (conversion_kind == UNSAFE_IMAGINARY)\n-\twarning_at (loc, OPT_Wconversion,\n-\t\t    \"conversion from %qT to %qT discards imaginary component\",\n-\t\t    expr_type, type);\n-      else\n-\t{\n-\t  int warnopt;\n-\t  if (conversion_kind == UNSAFE_REAL)\n-\t    warnopt = OPT_Wfloat_conversion;\n-\t  else if (conversion_kind)\n-\t    warnopt = OPT_Wconversion;\n-\t  else\n-\t    break;\n+      {\n+\tint warnopt;\n+\tif (conversion_kind == UNSAFE_REAL)\n+\t  warnopt = OPT_Wfloat_conversion;\n+\telse if (conversion_kind == UNSAFE_SIGN)\n+\t  warnopt = OPT_Wsign_conversion;\n+\telse if (conversion_kind)\n+\t  warnopt = OPT_Wconversion;\n+\telse\n+\t  break;\n+\tif (conversion_kind == UNSAFE_SIGN)\n+\t  warning_at (loc, warnopt, \"conversion to %qT from %qT \"\n+\t\t      \"may change the sign of the result\",\n+\t\t      type, expr_type);\n+\telse if (conversion_kind == UNSAFE_IMAGINARY)\n+\t  warning_at (loc, warnopt,\n+\t\t      \"conversion from %qT to %qT discards imaginary component\",\n+\t\t      expr_type, type);\n+\telse\n \t  warning_at (loc, warnopt,\n \t\t      \"conversion from %qT to %qT may change value\",\n \t\t      expr_type, type);\n-\t}\n+      }\n     }\n }\n "}]}