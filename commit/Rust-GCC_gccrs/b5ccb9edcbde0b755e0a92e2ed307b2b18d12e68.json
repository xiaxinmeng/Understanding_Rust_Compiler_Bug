{"sha": "b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVjY2I5ZWRjYmRlMGI3NTVlMGE5MmUyZWQzMDdiMmIxOGQxMmU2OA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-10-14T10:13:12Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-10-14T10:13:12Z"}, "message": "re PR bootstrap/58509 (ICE in calc_dfs_tree, at dominance.c:397 during Ada runtime build)\n\n\tPR bootstrap/58509\n\t* config/sparc/sparc-protos.h (widen_mem_for_ldd_peep): Declare.\n\t(registers_ok_for_ldd_peep): Move around.\n\t* config/sparc/sparc.c (widen_mem_for_ldd_peep): New.\n\t* config/sparc/sparc.md (widening peepholes): Use it.\n\nFrom-SVN: r203518", "tree": {"sha": "e80ba9a544aabc55280794421e06a31c62a46ffc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e80ba9a544aabc55280794421e06a31c62a46ffc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68/comments", "author": null, "committer": null, "parents": [{"sha": "fd7e50840c8056f2065826849b7ff9b0ec90f60b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd7e50840c8056f2065826849b7ff9b0ec90f60b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd7e50840c8056f2065826849b7ff9b0ec90f60b"}], "stats": {"total": 140, "additions": 100, "deletions": 40}, "files": [{"sha": "70d49b9641c19db616fbbb467e11f9ed8a71aa9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68", "patch": "@@ -1,3 +1,11 @@\n+2013-10-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR bootstrap/58509\n+\t* config/sparc/sparc-protos.h (widen_mem_for_ldd_peep): Declare.\n+\t(registers_ok_for_ldd_peep): Move around.\n+\t* config/sparc/sparc.c (widen_mem_for_ldd_peep): New.\n+\t* config/sparc/sparc.md (widening peepholes): Use it.\n+\n 2013-10-14  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/58712"}, {"sha": "03f83b87b2878d5bdba19eee569f219108988d30", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68", "patch": "@@ -81,7 +81,9 @@ extern const char *output_probe_stack_range (rtx, rtx);\n extern const char *output_cbcond (rtx, rtx, rtx);\n extern bool emit_scc_insn (rtx []);\n extern void emit_conditional_branch_insn (rtx []);\n+extern int registers_ok_for_ldd_peep (rtx, rtx);\n extern int mems_ok_for_ldd_peep (rtx, rtx, rtx);\n+extern rtx widen_mem_for_ldd_peep (rtx, rtx, enum machine_mode);\n extern int empty_delay_slot (rtx);\n extern int emit_cbcond_nop (rtx);\n extern int eligible_for_return_delay (rtx);\n@@ -95,7 +97,6 @@ extern int mem_min_alignment (rtx, int);\n extern int pic_address_needs_scratch (rtx);\n extern int register_ok_for_ldd (rtx);\n extern int memory_ok_for_ldd (rtx);\n-extern int registers_ok_for_ldd_peep (rtx, rtx);\n extern int v9_regcmp_p (enum rtx_code);\n /* Function used for V8+ code generation.  Returns 1 if the high\n    32 bits of REG are 0 before INSN.  */   "}, {"sha": "8ef634133c546d02b5c8d1900c65ca2d5c830e2f", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68", "patch": "@@ -8543,6 +8543,16 @@ mems_ok_for_ldd_peep (rtx mem1, rtx mem2, rtx dependent_reg_rtx)\n   return 1;\n }\n \n+/* Return the widened memory access made of MEM1 and MEM2 in MODE.  */\n+\n+rtx\n+widen_mem_for_ldd_peep (rtx mem1, rtx mem2, enum machine_mode mode)\n+{\n+  rtx x = widen_memory_access (mem1, mode, 0);\n+  MEM_NOTRAP_P (x) = MEM_NOTRAP_P (mem1) && MEM_NOTRAP_P (mem2);\n+  return x;\n+}\n+\n /* Return 1 if reg is a pseudo, or is the first register in\n    a hard register pair.  This makes it suitable for use in\n    ldd and std insns.  */"}, {"sha": "be7bbe977a2fcd348b1078c6b51a050f4f54b7b0", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 48, "deletions": 39, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68", "patch": "@@ -6971,9 +6971,10 @@\n       (const_int 0))]\n   \"TARGET_V9\n    && mems_ok_for_ldd_peep (operands[0], operands[1], NULL_RTX)\"\n-  [(set (match_dup 0)\n-       (const_int 0))]\n-  \"operands[0] = widen_memory_access (operands[0], DImode, 0);\")\n+  [(set (match_dup 0) (const_int 0))]\n+{\n+  operands[0] = widen_mem_for_ldd_peep (operands[0], operands[1], DImode);\n+})\n \n (define_peephole2\n   [(set (match_operand:SI 0 \"memory_operand\" \"\")\n@@ -6982,9 +6983,10 @@\n       (const_int 0))]\n   \"TARGET_V9\n    && mems_ok_for_ldd_peep (operands[1], operands[0], NULL_RTX)\"\n-  [(set (match_dup 1)\n-       (const_int 0))]\n-  \"operands[1] = widen_memory_access (operands[1], DImode, 0);\")\n+  [(set (match_dup 1) (const_int 0))]\n+{\n+  operands[1] = widen_mem_for_ldd_peep (operands[1], operands[0], DImode);\n+})\n \n (define_peephole2\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -6993,10 +6995,11 @@\n         (match_operand:SI 3 \"memory_operand\" \"\"))]\n   \"registers_ok_for_ldd_peep (operands[0], operands[2]) \n    && mems_ok_for_ldd_peep (operands[1], operands[3], operands[0])\" \n-  [(set (match_dup 0)\n-\t(match_dup 1))]\n-  \"operands[1] = widen_memory_access (operands[1], DImode, 0);\n-   operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\")\n+  [(set (match_dup 0) (match_dup 1))]\n+{\n+  operands[1] = widen_mem_for_ldd_peep (operands[1], operands[3], DImode);\n+  operands[0] = gen_rtx_REG (DImode, REGNO (operands[0]));\n+})\n \n (define_peephole2\n   [(set (match_operand:SI 0 \"memory_operand\" \"\")\n@@ -7005,10 +7008,11 @@\n         (match_operand:SI 3 \"register_operand\" \"\"))]\n   \"registers_ok_for_ldd_peep (operands[1], operands[3]) \n    && mems_ok_for_ldd_peep (operands[0], operands[2], NULL_RTX)\"\n-  [(set (match_dup 0)\n-\t(match_dup 1))]\n-  \"operands[0] = widen_memory_access (operands[0], DImode, 0);\n-   operands[1] = gen_rtx_REG (DImode, REGNO (operands[1]));\")\n+  [(set (match_dup 0) (match_dup 1))]\n+{\n+  operands[0] = widen_mem_for_ldd_peep (operands[0], operands[2], DImode);\n+  operands[1] = gen_rtx_REG (DImode, REGNO (operands[1]));\n+})\n \n (define_peephole2\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n@@ -7017,10 +7021,11 @@\n         (match_operand:SF 3 \"memory_operand\" \"\"))]\n   \"registers_ok_for_ldd_peep (operands[0], operands[2]) \n    && mems_ok_for_ldd_peep (operands[1], operands[3], operands[0])\"\n-  [(set (match_dup 0)\n-\t(match_dup 1))]\n-  \"operands[1] = widen_memory_access (operands[1], DFmode, 0);\n-   operands[0] = gen_rtx_REG (DFmode, REGNO (operands[0]));\")\n+  [(set (match_dup 0) (match_dup 1))]\n+{\n+  operands[1] = widen_mem_for_ldd_peep (operands[1], operands[3], DFmode);\n+  operands[0] = gen_rtx_REG (DFmode, REGNO (operands[0]));\n+})\n \n (define_peephole2\n   [(set (match_operand:SF 0 \"memory_operand\" \"\")\n@@ -7029,10 +7034,11 @@\n         (match_operand:SF 3 \"register_operand\" \"\"))]\n   \"registers_ok_for_ldd_peep (operands[1], operands[3]) \n   && mems_ok_for_ldd_peep (operands[0], operands[2], NULL_RTX)\"\n-  [(set (match_dup 0)\n-\t(match_dup 1))]\n-  \"operands[0] = widen_memory_access (operands[0], DFmode, 0);\n-   operands[1] = gen_rtx_REG (DFmode, REGNO (operands[1]));\")\n+  [(set (match_dup 0) (match_dup 1))]\n+{\n+  operands[0] = widen_mem_for_ldd_peep (operands[0], operands[2], DFmode);\n+  operands[1] = gen_rtx_REG (DFmode, REGNO (operands[1]));\n+})\n \n (define_peephole2\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -7041,10 +7047,11 @@\n         (match_operand:SI 3 \"memory_operand\" \"\"))]\n   \"registers_ok_for_ldd_peep (operands[2], operands[0]) \n   && mems_ok_for_ldd_peep (operands[3], operands[1], operands[0])\"\n-  [(set (match_dup 2)\n-\t(match_dup 3))]\n-   \"operands[3] = widen_memory_access (operands[3], DImode, 0);\n-    operands[2] = gen_rtx_REG (DImode, REGNO (operands[2]));\")\n+  [(set (match_dup 2) (match_dup 3))]\n+{\n+  operands[3] = widen_mem_for_ldd_peep (operands[3], operands[1], DImode);\n+  operands[2] = gen_rtx_REG (DImode, REGNO (operands[2]));\n+})\n \n (define_peephole2\n   [(set (match_operand:SI 0 \"memory_operand\" \"\")\n@@ -7053,11 +7060,11 @@\n         (match_operand:SI 3 \"register_operand\" \"\"))]\n   \"registers_ok_for_ldd_peep (operands[3], operands[1]) \n   && mems_ok_for_ldd_peep (operands[2], operands[0], NULL_RTX)\" \n-  [(set (match_dup 2)\n-\t(match_dup 3))]\n-  \"operands[2] = widen_memory_access (operands[2], DImode, 0);\n-   operands[3] = gen_rtx_REG (DImode, REGNO (operands[3]));\n-   \")\n+  [(set (match_dup 2) (match_dup 3))]\n+{\n+  operands[2] = widen_mem_for_ldd_peep (operands[2],  operands[0], DImode);\n+  operands[3] = gen_rtx_REG (DImode, REGNO (operands[3]));\n+})\n  \n (define_peephole2\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n@@ -7066,10 +7073,11 @@\n         (match_operand:SF 3 \"memory_operand\" \"\"))]\n   \"registers_ok_for_ldd_peep (operands[2], operands[0]) \n   && mems_ok_for_ldd_peep (operands[3], operands[1], operands[0])\"\n-  [(set (match_dup 2)\n-\t(match_dup 3))]\n-  \"operands[3] = widen_memory_access (operands[3], DFmode, 0);\n-   operands[2] = gen_rtx_REG (DFmode, REGNO (operands[2]));\")\n+  [(set (match_dup 2) (match_dup 3))]\n+{\n+  operands[3] = widen_mem_for_ldd_peep (operands[3], operands[1], DFmode);\n+  operands[2] = gen_rtx_REG (DFmode, REGNO (operands[2]));\n+})\n \n (define_peephole2\n   [(set (match_operand:SF 0 \"memory_operand\" \"\")\n@@ -7078,10 +7086,11 @@\n         (match_operand:SF 3 \"register_operand\" \"\"))]\n   \"registers_ok_for_ldd_peep (operands[3], operands[1]) \n   && mems_ok_for_ldd_peep (operands[2], operands[0], NULL_RTX)\"\n-  [(set (match_dup 2)\n-\t(match_dup 3))]\n-  \"operands[2] = widen_memory_access (operands[2], DFmode, 0);\n-   operands[3] = gen_rtx_REG (DFmode, REGNO (operands[3]));\")\n+  [(set (match_dup 2) (match_dup 3))]\n+{\n+  operands[2] = widen_mem_for_ldd_peep (operands[2], operands[0], DFmode);\n+  operands[3] = gen_rtx_REG (DFmode, REGNO (operands[3]));\n+})\n  \n ;; Optimize the case of following a reg-reg move with a test\n ;; of reg just moved.  Don't allow floating point regs for operand 0 or 1."}, {"sha": "46218e3163c84e5dc752f1deeca43bfe8b9fbc8a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68", "patch": "@@ -1,3 +1,7 @@\n+2013-10-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/specs/opt1.ads: New test.\n+\n 2013-10-14  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/58640"}, {"sha": "89a405c3457798c638aa2b75ae49617a9e5a1449", "filename": "gcc/testsuite/gnat.dg/specs/opt1.ads", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fopt1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fopt1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fopt1.ads?ref=b5ccb9edcbde0b755e0a92e2ed307b2b18d12e68", "patch": "@@ -0,0 +1,28 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O2\" }\n+\n+with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n+\n+package Opt1 is\n+\n+   type Ptr is access all Integer;\n+\n+   type R1 is record\n+      I1 : Integer;\n+      I2 : Integer := 0;\n+      I3 : Integer;\n+   end record;\n+\n+   type R2 is record\n+      P  : Ptr;\n+      F1 : R1;\n+   end record;\n+\n+   type R3 is record\n+      S  : Unbounded_String;\n+      F1 : R2;\n+      I  : Integer := 0;\n+      F2 : R2;\n+   end record;\n+\n+end Opt1;"}]}