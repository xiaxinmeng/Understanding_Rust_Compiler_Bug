{"sha": "2e6834d33edeaf8203a5e37f6da40cbf60f9447f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU2ODM0ZDMzZWRlYWY4MjAzYTVlMzdmNmRhNDBjYmY2MGY5NDQ3Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2007-02-13T16:42:12Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2007-02-13T16:42:12Z"}, "message": "i386.md (bswapsi_1): Rename from bswapsi2, remove flags clobber.\n\n        * config/i386/i386.md (bswapsi_1): Rename from bswapsi2,\n        remove flags clobber.\n        (bswapsi2): New expander, emit code for !TARGET_BSWAP.\n        (bswaphi_lowpart): New.\n        (bswapdi2): Rename from bswapdi2_rex, remove flags clobber,\n        remove TARGET_BSWAP test.  Delete expander of the same name.\n\n        * optabs.c (widen_bswap, expand_doubleword_bswap): New.\n        (expand_unop): Use them.\n\nFrom-SVN: r121884", "tree": {"sha": "e19c66e1c3488380d7c834096930e84a64744608", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e19c66e1c3488380d7c834096930e84a64744608"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e6834d33edeaf8203a5e37f6da40cbf60f9447f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e6834d33edeaf8203a5e37f6da40cbf60f9447f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e6834d33edeaf8203a5e37f6da40cbf60f9447f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e6834d33edeaf8203a5e37f6da40cbf60f9447f/comments", "author": null, "committer": null, "parents": [{"sha": "a23132e116da1ce7395b84aa6de52d671b3eff26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a23132e116da1ce7395b84aa6de52d671b3eff26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a23132e116da1ce7395b84aa6de52d671b3eff26"}], "stats": {"total": 158, "additions": 129, "deletions": 29}, "files": [{"sha": "96ff9accdfb5511c0201c2bceb9ed9e210ff83af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e6834d33edeaf8203a5e37f6da40cbf60f9447f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e6834d33edeaf8203a5e37f6da40cbf60f9447f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e6834d33edeaf8203a5e37f6da40cbf60f9447f", "patch": "@@ -1,3 +1,15 @@\n+2007-02-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.md (bswapsi_1): Rename from bswapsi2,\n+\tremove flags clobber.\n+\t(bswapsi2): New expander, emit code for !TARGET_BSWAP.\n+\t(bswaphi_lowpart): New.\n+\t(bswapdi2): Rename from bswapdi2_rex, remove flags clobber,\n+\tremove TARGET_BSWAP test.  Delete expander of the same name.\n+\n+\t* optabs.c (widen_bswap, expand_doubleword_bswap): New.\n+\t(expand_unop): Use them.\n+\n 2007-02-13  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (cmpdi_ccno_1_rex64, *cmpsi_ccno_1,"}, {"sha": "0b529c2112af2c76332ba2bc02b6560a22c3cf83", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e6834d33edeaf8203a5e37f6da40cbf60f9447f/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e6834d33edeaf8203a5e37f6da40cbf60f9447f/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=2e6834d33edeaf8203a5e37f6da40cbf60f9447f", "patch": "@@ -14994,43 +14994,50 @@\n    (set_attr \"type\" \"bitmanip\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"bswapsi2\"\n+(define_expand \"bswapsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(bswap:SI (match_operand:SI 1 \"register_operand\" \"\")))]\n+  \"\"\n+{\n+  if (!TARGET_BSWAP)\n+    {\n+      rtx x = operands[0];\n+\n+      emit_move_insn (x, operands[1]);\n+      emit_insn (gen_bswaphi_lowpart (gen_lowpart (HImode, x)));\n+      emit_insn (gen_rotlsi3 (x, x, GEN_INT (16)));\n+      emit_insn (gen_bswaphi_lowpart (gen_lowpart (HImode, x)));\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"*bswapsi_1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(bswap:SI (match_operand:SI 1 \"register_operand\" \"0\")))\n-   (clobber (reg:CC FLAGS_REG))]\n+\t(bswap:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n   \"TARGET_BSWAP\"\n-  \"bswap\\t%k0\"\n+  \"bswap\\t%0\"\n   [(set_attr \"prefix_0f\" \"1\")\n    (set_attr \"length\" \"2\")])\n \n-(define_insn \"*bswapdi2_rex\"\n+(define_insn \"bswaphi_lowpart\"\n+  [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+Q\"))\n+\t(bswap:HI (match_dup 0)))]\n+  \"\"\n+  \"xchg{b}\\t%h0, %b0\"\n+  [(set_attr \"type\" \"alu1\")\n+   (set_attr \"mode\" \"QI\")\n+   (set_attr \"pent_pair\" \"np\")\n+   (set_attr \"athlon_decode\" \"vector\")\n+   (set_attr \"amdfam10_decode\" \"double\")])\n+\n+(define_insn \"bswapdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(bswap:DI (match_operand:DI 1 \"register_operand\" \"0\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && TARGET_BSWAP\"\n+\t(bswap:DI (match_operand:DI 1 \"register_operand\" \"0\")))]\n+  \"TARGET_64BIT\"\n   \"bswap\\t%0\"\n   [(set_attr \"prefix_0f\" \"1\")\n    (set_attr \"length\" \"3\")])\n \n-(define_expand \"bswapdi2\"\n-  [(parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t\t   (bswap:DI (match_operand:DI 1 \"register_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"TARGET_BSWAP\"\n-  {\n-    if (!TARGET_64BIT)\n-      {\n-\trtx tmp1, tmp2;\n-\ttmp1 = gen_reg_rtx (SImode);\n-\ttmp2 = gen_reg_rtx (SImode);\n-\temit_insn (gen_bswapsi2 (tmp1, gen_lowpart (SImode, operands[1])));\n-\temit_insn (gen_bswapsi2 (tmp2, gen_highpart (SImode, operands[1])));\n-\temit_move_insn (gen_lowpart (SImode, operands[0]), tmp2);\n-\temit_move_insn (gen_highpart (SImode, operands[0]), tmp1);\n-\tDONE;\n-      }\n-  })\n-\n (define_expand \"clzdi2\"\n   [(parallel\n      [(set (match_operand:DI 0 \"register_operand\" \"\")"}, {"sha": "c8ec9ef05a5705f33e8e308bc5f363f93aed3280", "filename": "gcc/optabs.c", "status": "modified", "additions": 83, "deletions": 2, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e6834d33edeaf8203a5e37f6da40cbf60f9447f/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e6834d33edeaf8203a5e37f6da40cbf60f9447f/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=2e6834d33edeaf8203a5e37f6da40cbf60f9447f", "patch": "@@ -2401,6 +2401,73 @@ widen_clz (enum machine_mode mode, rtx op0, rtx target)\n   return 0;\n }\n \n+/* Try calculating\n+\t(bswap:narrow x)\n+   as\n+\t(lshiftrt:wide (bswap:wide x) ((width wide) - (width narrow))).  */\n+static rtx\n+widen_bswap (enum machine_mode mode, rtx op0, rtx target)\n+{\n+  enum mode_class class = GET_MODE_CLASS (mode);\n+  enum machine_mode wider_mode;\n+  rtx x, last;\n+\n+  if (!CLASS_HAS_WIDER_MODES_P (class))\n+    return NULL_RTX;\n+\n+  for (wider_mode = GET_MODE_WIDER_MODE (mode);\n+       wider_mode != VOIDmode;\n+       wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n+    if (bswap_optab->handlers[wider_mode].insn_code != CODE_FOR_nothing)\n+      goto found;\n+  return NULL_RTX;\n+\n+ found:\n+  last = get_last_insn ();\n+\n+  x = widen_operand (op0, wider_mode, mode, true, true);\n+  x = expand_unop (wider_mode, bswap_optab, x, NULL_RTX, true);\n+\n+  if (x != 0)\n+    x = expand_shift (RSHIFT_EXPR, wider_mode, x,\n+\t\t      size_int (GET_MODE_BITSIZE (wider_mode)\n+\t\t\t        - GET_MODE_BITSIZE (mode)),\n+\t\t      NULL_RTX, true);\n+\n+  if (x != 0)\n+    {\n+      if (target == 0)\n+\ttarget = gen_reg_rtx (mode);\n+      emit_move_insn (target, gen_lowpart (mode, x));\n+    }\n+  else\n+    delete_insns_since (last);\n+\n+  return target;\n+}\n+\n+/* Try calculating bswap as two bswaps of two word-sized operands.  */\n+\n+static rtx\n+expand_doubleword_bswap (enum machine_mode mode, rtx op, rtx target)\n+{\n+  rtx t0, t1;\n+\n+  t1 = expand_unop (word_mode, bswap_optab,\n+\t\t    operand_subword_force (op, 0, mode), NULL_RTX, true);\n+  t0 = expand_unop (word_mode, bswap_optab,\n+\t\t    operand_subword_force (op, 1, mode), NULL_RTX, true);\n+\n+  if (target == 0)\n+    target = gen_reg_rtx (mode);\n+  if (REG_P (target))\n+    emit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n+  emit_move_insn (operand_subword (target, 0, 1, mode), t0);\n+  emit_move_insn (operand_subword (target, 1, 1, mode), t1);\n+\n+  return target;\n+}\n+\n /* Try calculating (parity x) as (and (popcount x) 1), where\n    popcount can also be done in a wider mode.  */\n static rtx\n@@ -2639,9 +2706,23 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \tgoto try_libcall;\n     }\n \n-  /* We can't widen a bswap.  */\n+  /* Widening (or narrowing) bswap needs special treatment.  */\n   if (unoptab == bswap_optab)\n-    goto try_libcall;\n+    {\n+      temp = widen_bswap (mode, op0, target);\n+      if (temp)\n+\treturn temp;\n+\n+      if (GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n+\t  && unoptab->handlers[word_mode].insn_code != CODE_FOR_nothing)\n+\t{\n+\t  temp = expand_doubleword_bswap (mode, op0, target);\n+\t  if (temp)\n+\t    return temp;\n+\t}\n+\n+      goto try_libcall;\n+    }\n \n   if (CLASS_HAS_WIDER_MODES_P (class))\n     for (wider_mode = GET_MODE_WIDER_MODE (mode);"}]}